--[连续升级]1
--[管理工具版本号]10.35.60
--本脚本支持从ZLHIS+ v10.35.50 升级到 v10.35.60
--请以系统所有者登录PLSQL并执行下列脚本
--脚本执行后，请手工升级导出报表
Define n_System=100;
-------------------------------------------------------------------------------
--结构修正部份
-------------------------------------------------------------------------------
--111107:焦博,2017-07-11,新增一个表三方交易记录来记录交易流水号
CREATE TABLE 三方交易记录(
    类别 varchar2(50),
    流水号 varchar2(50),
    状态  number(2),
    卡号 varchar2(50),
    交易说明 varchar2(500),
    结帐ID number(18),
    交易时间  DATE)
TABLESPACE ZL9EXPENSE ;

Alter Table 三方交易记录  Add Constraint 三方交易记录_PK  Primary Key (流水号,类别) Using Index Tablespace zl9Indexhis;

Create Index 三方交易记录_IX_交易时间 On 三方交易记录(交易时间) Tablespace zl9Indexhis;

--111315:黄捷,2017-07-10,检查号分隔符提供可选符号
alter table 科室号码表 modify 最大号码 VARCHAR2(64);

--107171:张德婷,2017-07-06,静配中心新增排班功能
CREATE TABLE 配液台(
  id number(4),
  名称 varchar2(50),
  部门id VARCHAR2(20)
  ) TABLESPACE zl9BaseItem;

CREATE TABLE 配液台药品对照(
  配药台id number(4),
  药品id number(18),
  部门id number(18)
  ) TABLESPACE zl9BaseItem;

CREATE TABLE 配液工作安排(
  部门id number(18),
  日期 date,
  配药台id number(4),
  批次 number(18),
  审核人 varchar2(20),
  摆药人 varchar2(20),
  核对人 varchar2(20),
  配液人 varchar2(20),
  复核人 varchar2(20)
  ) TABLESPACE zl9BaseItem;

alter table 输液配药记录 add 配药台 varchar2(20);

alter table 输液配药状态 add 实际工作人员 varchar2(20);

  Alter Table 配液台 Add Constraint 配液台_PK Primary Key (id) Using Index Tablespace ZL9INDEXHIS;

Alter Table 配液台药品对照 Add Constraint 配液台药品对照_PK Primary Key (配药台id,药品id) Using Index Tablespace ZL9INDEXHIS;

Alter Table 配液工作安排 Add Constraint 配液工作安排_UQ_部门id Unique (部门id,日期,配药台id,批次) Using Index Tablespace ZL9INDEXHIS;

Alter Table 配液工作安排 Modify 部门id Constraint 配液工作安排_NN_部门id Not Null;

Create Index 配液工作安排_IX_配药台id On 配液工作安排(配药台id) Tablespace ZL9INDEXHIS;

--105570:冉俊明,2017-07-03,转病区费用
Create Table 费用变动记录(
 ID Number(18),
 记录状态 Number(3),
 病人id Number(18),
 主页id Number(5),
 变动时间 Date,
 原变动id Number(18),
 目标变动id Number(18),
 原病区id Number(18),
 目标病区id Number(18),
 费用id Number(18),
 NO Varchar2(8),
 收费类别 Varchar2(1),
 收费细目id Number(18),
 医嘱序号 Number(18),
 数量 Number(16, 5),
 单价 Number(16, 5),
 应收金额 Number(16, 5),
 实收金额 Number(16, 5),
 状态 Number(2),
 摘要 Varchar2(500),
 操作员编号 Varchar2(6),
 操作员姓名 Varchar2(20),
 待转出 Number(3))
Tablespace Zl9expense Pctfree 5;
Alter Table 医嘱执行计价 Add 费用id Number(18);

Create Sequence 费用变动记录_Id Start With 1;

Alter Table 费用变动记录 Add Constraint 费用变动记录_Pk Primary Key(ID) Using Index Tablespace Zl9indexhis;

Alter Table 费用变动记录 Add Constraint 费用变动记录_Uq_变动时间 Unique(变动时间, 目标变动id, 费用id, 收费细目id) Using Index Tablespace Zl9indexhis;

Create Index 费用变动记录_Ix_目标变动id On 费用变动记录(目标变动id) Tablespace Zl9indexhis;

Create Index 费用变动记录_Ix_原病区id On 费用变动记录(原病区id) Tablespace Zl9indexhis;

Create Index 费用变动记录_Ix_目标病区id On 费用变动记录(目标病区id) Tablespace Zl9indexhis;

Create Index 费用变动记录_Ix_收费细目id On 费用变动记录(收费细目id) Tablespace Zl9indexhis;

Create Index 费用变动记录_Ix_费用id On 费用变动记录(费用id) Tablespace Zl9indexhis;

Create Index 费用变动记录_Ix_病人id On 费用变动记录(病人id, 主页id) Tablespace Zl9indexhis;

--104662:蒋廷中,2017-06-30,人员表增加特殊医嘱权限字段
Alter Table 人员表 Add 门诊特殊医嘱权限 VARCHAR2(10);

Alter Table 人员表 Add 住院特殊医嘱权限 VARCHAR2(10);

--111426:黄捷,2017-07-11,修改检查号后不删除备份
--103994:黄捷,2017-06-30,检查号改成字符型
drop index 影像检查记录_IX_检查号;
alter table 影像检查记录 rename column 检查号 to 检查号_bak;
alter table 影像检查记录 add 检查号 VARCHAR2(64);
update 影像检查记录 set 检查号=to_char(检查号_bak);
Create Index 影像检查记录_IX_检查号 On 影像检查记录(检查号, 影像类别) Tablespace zl9Indexcis nologging;


alter table 影像检查类别 rename column 最大号码 to 最大号码_bak ;
alter table 影像检查类别 add 最大号码 VARCHAR2(64);
update 影像检查类别 set 最大号码=to_char(最大号码_bak);

alter table 影像临时记录 rename column 检查号 to 检查号_bak;
alter table 影像临时记录 add 检查号 VARCHAR2(64);
update 影像临时记录 set 检查号=to_char(检查号_bak);

--110594:余伟节,2017-06-27,病案主页新增入科时间用于医生站显示
Alter Table 病案主页 Add 入科时间 Date;

--97621:胡俊勇,2017-06-26,约束命名不合规范
Alter Table 病人抗生素记录 rename Constraint 病人抗生素记录_药名ID to 病人抗生素记录_FK_药名ID;
Alter Table 病人抗生素记录 rename Constraint 病人抗生素记录_主页ID to 病人抗生素记录_FK_主页ID;

--106374:余伟节,2017-06-22,疾病编码分类、疾病编码目录更新
Alter Table 疾病编码分类 Add 建档时间 Date;

Alter Table 疾病编码分类 Add 撤档时间 Date;

Alter Table 疾病编码分类 Drop Constraint 疾病编码分类_UQ_序号 Cascade drop Index;

Alter Table 疾病编码分类 Add Constraint 疾病编码分类_UQ_序号 Unique(序号, 类别, 撤档时间) Using Index Tablespace ZL9INDEXHIS;

--98870:梁唐彬,2017-06-21,转病区费用问题
Alter table 病人医嘱执行 Add 执行科室ID Number(18);

--103996:黄捷,2017-06-12,报告图增加标记
alter table 影像检查图象 add 报告图 NUMBER(3);

--109251:李小东,2017-06-09,技师工作站过滤标识号判断
Create Index 检验标本记录_IX_NO On 检验标本记录(NO) Tablespace zl9Indexcis nologging;


--109923:董露露,2017-06-08,解决临床路径表单双审核的问题,在临床路径版本表中增加两个字段
alter table 临床路径版本 add 药剂科审核人 Varchar2(20);
alter table 临床路径版本 add 药剂科审核时间 Date;
--109432:张德婷,2017-06-05,修正35版本缺失病人id字段问题
Alter table 输液配药附费 add 病人id number(18);
Alter Table 输液配药附费 Add Constraint 输液配药附费_FK_病人id Foreign Key (病人id) References 病人信息(病人id) On Delete Cascade;
Create Index 输液配药附费_IX_病人id On 输液配药附费(病人id) Tablespace zl9Indexcis;

--109233:廖思奇,2017-06-02,影像图像备注增加主键、唯一键
Alter Table 影像图像备注 Add Constraint 影像图像备注_PK Primary Key (编码) Using Index Tablespace zl9Indexhis;
Alter Table 影像图像备注 Add Constraint 影像图像备注_UQ_名称 Unique (名称) Using Index Tablespace zl9Indexhis;

--109686:刘鹏飞,2017-05-31,主键或唯一键缺失补充
Alter Table 护理波动项目 Add Constraint 护理波动项目_PK Primary Key (项目序号) Using Index Tablespace zl9Indexcis;

Alter Table 护理适用科室 Add Constraint 护理适用科室_PK Primary Key (项目序号,科室ID) Using Index Tablespace zl9Indexcis;

--99878:冉俊明,2017-05-24,同一收费项目多个价格管理
Create Table 收费价格等级(
 编码 Varchar2(2), 
 名称 Varchar2(30), 
 简码 Varchar2(10), 
 是否适用药品 Number(1) Default 0,
 是否适用卫材 Number(1) Default 0, 
 是否适用普通项目 Number(1) Default 0, 
 建档时间 Date, 
 撤档时间 Date) 
Tablespace Zl9baseitem;

Alter Table 收费价格等级 Add Constraint 收费价格等级_PK Primary Key(编码) Using Index Tablespace Zl9indexhis;

Alter Table 收费价格等级 Add Constraint 收费价格等级_UQ_名称 Unique(名称) Using Index Tablespace Zl9indexhis;

Create Table 收费价格等级应用(
 价格等级 Varchar2(30), 
 站点 Varchar2(1), 
 医疗付款方式 Varchar2(20), 
 性质 Number(2)) 
Tablespace Zl9baseitem;

Alter Table 收费价格等级应用 Add Constraint 收费价格等级应用_UQ_价格等级 Unique(价格等级, 站点, 医疗付款方式) Using Index Tablespace Zl9indexhis;

Alter Table 收费价格等级应用 Add Constraint 收费价格等级应用_FK_价格等级 Foreign Key(价格等级) References 收费价格等级(名称);

Alter Table 收费价格等级应用 Modify 价格等级 Constraint 收费价格等级应用_NN_价格等级 Not Null;

Alter Table 收费价目 Add(价格等级 Varchar2(30));

Alter Table 收费价目 Drop Constraint 收费价目_Uq_收入项目id Cascade drop Index;

Alter Table 收费价目 Add Constraint 收费价目_Uq_收入项目id Unique(执行日期, 收费细目id, 收入项目id, 价格等级) Using Index Tablespace Zl9indexhis;

Alter Table 收费价目 Add Constraint 收费价目_FK_价格等级 Foreign Key(价格等级) References 收费价格等级(名称);

Create Index 收费价目_IX_价格等级 on 收费价目(价格等级) Tablespace zl9Indexhis;

Alter Table 收费调价记录 Add(价格等级 Varchar2(30));

Alter Table 收费调价记录 Add Constraint 收费调价记录_FK_价格等级 Foreign Key(价格等级) References 收费价格等级(名称);

Create Index 收费调价记录_IX_价格等级 on 收费调价记录(价格等级) Tablespace zl9Indexhis;

--109412:张德婷,2017-05-23,静配中心表主键缺失
alter table 输液不配置药品 add constraint 输液不配置药品_PK primary key(药品id) Using Index Tablespace zl9Indexhis;

alter table 输液配药类型 add constraint 输液配药类型_PK primary key(编码) Using Index Tablespace zl9Indexhis;

alter table 输液药品优先级 add constraint 输液药品优先级_PK primary key(科室id,配药类型,频次) Using Index Tablespace zl9Indexhis;

alter table 输液优先打印药品 add constraint 输液优先打印药品_PK primary key(药品id) Using Index Tablespace zl9Indexhis;

alter table 配置收费方案 drop constraint 配置收费方案_UQ_配药类型 cascade drop index; 

--109164:李南春,2017-05-23,增加病人免疫记录主键和外键
declare 
  n_count Number;   
begin   
  --增加病人免疫记录的主键前要处理可能存在的重复记录
  n_count := 0;
  For C_免疫 in (Select 病人ID,接种时间 From 病人免疫记录 group by 病人ID,接种时间 having count(1) > 1) Loop
      Update 病人免疫记录 set 接种时间 = 接种时间 + RowNum * 1/24/60/60  Where 病人ID = C_免疫.病人ID And 接种时间 = C_免疫.接种时间;
      n_count := 1;
  end Loop;

  If n_count = 1 Then 
     Commit;
  end if;
end;
/

Alter Table 病人免疫记录 add Constraint 病人免疫记录_PK Primary Key (病人ID,接种时间) Using Index Tablespace zl9indexhis;

--109168:谢荣,2017-05-16,医保病人档案和医保病人关联表的主键顺序不一致。
Alter Table 医保病人档案 Drop Constraint 医保病人档案_PK Cascade Drop Index;

Alter Table 医保病人档案 Add Constraint 医保病人档案_PK Primary Key (医保号,险类,中心) Using Index Tablespace zl9Indexhis;

--108762:冉俊明,2017-05-15,临床出诊安排医生姓名前显示职称标识符
Alter Table 专业技术职务 Add 标识符 Varchar2(5);

--109137:胡俊勇,2017-05-15,基础表主键缺失
Alter Table 医嘱常用原因 Add Constraint 医嘱常用原因_PK Primary Key (编码) Using Index Tablespace zl9Indexhis;

Alter Table 医嘱常用原因 Add Constraint 医嘱常用原因_UQ_人员 Unique (人员,名称,性质) Using Index Tablespace zl9Indexhis;

--109164:李南春,2017-05-23,增加病人免疫记录主键和外键
Alter Table 病人免疫记录 add Constraint 病人免疫记录_FK_病人ID Foreign Key (病人ID) References 病人信息(病人ID);

--109421:李业庆,2017-05-23,药品加成方案表增加主键
Alter Table 药品加成方案 Add Constraint 药品加成方案_PK Primary Key (序号) Using Index Tablespace zl9Indexhis;

--99878:冉俊明,2017-05-24,同一收费项目多个价格管理
Create Or Replace View 在院病人自动记帐 As
Select p.病人id, p.主页id, Nvl(a.姓名, i.姓名) As 姓名, Nvl(a.性别, i.性别) As 性别, Nvl(a.年龄, i.年龄) As 年龄, Nvl(a.住院号, i.住院号) As 住院号,
       a.费别, p.科室id, p.病区id, p.床号, p.附加床位, p.收费细目id, p.收入项目id, 1 As 标志, p.现价 As 标准单价, p.开始日期, p.终止日期,
       p.终止日期 - p.开始日期 As 天数, p.数量, p.经治医师, p.责任护士, p.操作员编号, p.操作员姓名
From 病人信息 I, 病案主页 A,
     (Select b.病人id, b.主页id, b.科室id, b.病区id, b.床号, b.附加床位, p.收费细目id, p.收入项目id, p.现价, b.经治医师, b.责任护士, b.操作员编号, b.操作员姓名,
              Zl_Date_Half(Greatest(Least(Nvl(b.上次计算时间, b.开始时间), Nvl(b.终止时间, Greatest(Nvl(b.上次计算时间, b.开始时间))),
                                           Greatest(Nvl(b.上次计算时间, b.开始时间))), p.执行日期, Nvl(a.启用日期, Add_Months(Sysdate, -2)))) As 开始日期,
              Zl_Date_Half(Least(Nvl(b.终止时间, Greatest(b.开始时间, Sysdate)), Nvl(p.终止日期, Sysdate + 30) + 1)) As 终止日期, b.数量
       From 自动计价项目 A,
            (Select a.病人id, a.主页id, a.开始时间, a.附加床位, a.病区id, a.科室id, a.床号, a.床位等级id, 1 As 数量, a.责任护士, a.经治医师, a.终止时间,
                     a.操作员编号, a.操作员姓名, a.上次计算时间
              From 病人变动记录 A, 病人信息 B
              Where a.开始原因 <> 10 And a.病人id = b.病人id And a.主页id = b.主页id And b.在院 = 1
              Union All
              Select b.病人id, b.主页id, 开始时间, 附加床位, b.病区id, b.科室id, 床号, i.从项id As 床位等级id, i.从项数次 As 数量, 责任护士, 经治医师, 终止时间, 操作员编号,
                     操作员姓名, 上次计算时间
              From 病人变动记录 B, 收费从属项目 I, 病人信息 C
              Where b.病人id = c.病人id And b.主页id = c.主页id And c.在院 = 1 And b.床位等级id = i.主项id And b.开始原因 <> 10 And i.固有从属 > 0) B,
            收费价目 P
       Where a.病区id = b.病区id And Zl_Date_Half(Nvl(b.上次计算时间, b.开始时间)) <> Zl_Date_Half(Nvl(b.终止时间, Sysdate)) And p.现价 <> 0 And
             a.计算标志 = 1 And b.床位等级id = p.收费细目id And Zl_Date_Half(Nvl(b.终止时间, Sysdate)) >= Zl_Date_Half(p.执行日期) And
             Zl_Date_Half(b.开始时间) <= Zl_Date_Half(Nvl(p.终止日期, Sysdate) + 1) And
             Zl_Date_Half(Least(Nvl(b.终止时间, Sysdate), Nvl(p.终止日期, Sysdate + 30) + 1)) >=
             Zl_Date_Half(Nvl(a.启用日期, Add_Months(Sysdate, -2))) And p.价格等级 Is Null
       Union All
       Select b.病人id, b.主页id, b.科室id, b.病区id, b.床号, b.附加床位, p.收费细目id, p.收入项目id, p.现价, b.经治医师, b.责任护士, b.操作员编号, b.操作员姓名,
              Zl_Date_Half(Greatest(Least(Nvl(b.上次计算时间, b.开始时间), Nvl(b.终止时间, Greatest(Nvl(b.上次计算时间, b.开始时间))),
                                           Greatest(Nvl(b.上次计算时间, b.开始时间))), p.执行日期, Nvl(a.启用日期, Add_Months(Sysdate, -2)))) As 开始日期,
              Zl_Date_Half(Least(Nvl(b.终止时间, Greatest(b.开始时间, Sysdate)), Nvl(p.终止日期, Sysdate + 30) + 1)) As 终止日期, b.数量
       From 自动计价项目 A,
            (Select a.病人id, a.主页id, 开始时间, 附加床位, a.病区id, a.科室id, 床号, 护理等级id, 1 As 数量, 责任护士, 经治医师, 终止时间, 操作员编号, 操作员姓名, 上次计算时间
              From 病人变动记录 A, 病人信息 B
              Where 开始原因 <> 10 And a.病人id = b.病人id And a.主页id = b.主页id And b.在院 = 1
              Union All
              Select b.病人id, b.主页id, 开始时间, 附加床位, b.病区id, b.科室id, 床号, i.从项id As 护理等级id, i.从项数次 As 数量, 责任护士, 经治医师, 终止时间, 操作员编号,
                     操作员姓名, 上次计算时间
              From 病人变动记录 B, 收费从属项目 I, 病人信息 C
              Where b.护理等级id = i.主项id And b.病人id = c.病人id And b.主页id = c.主页id And c.在院 = 1 And b.开始原因 <> 10 And i.固有从属 > 0) B,
            收费价目 P, 收费项目目录 C
       Where a.病区id = b.病区id And b.附加床位 <> 1 And
             Zl_Date_Half(Nvl(b.上次计算时间, b.开始时间)) <> Zl_Date_Half(Nvl(b.终止时间, Sysdate)) And p.现价 <> 0 And a.计算标志 = 2 And
             b.护理等级id = p.收费细目id And b.护理等级id = c.Id And Nvl(c.计算方式, 0) <> 1 And
             Zl_Date_Half(Nvl(b.终止时间, Sysdate)) >= Zl_Date_Half(p.执行日期) And
             Zl_Date_Half(b.开始时间) <= Zl_Date_Half(Nvl(p.终止日期, Sysdate) + 1) And
             Zl_Date_Half(Least(Nvl(b.终止时间, Sysdate), Nvl(p.终止日期, Sysdate + 30) + 1)) >=
             Zl_Date_Half(Nvl(a.启用日期, Add_Months(Sysdate, -2))) And p.价格等级 Is Null
       Union All
       Select b.病人id, b.主页id, b.科室id, b.病区id, b.床号, b.附加床位, p.收费细目id, p.收入项目id, p.现价, b.经治医师, b.责任护士, b.操作员编号, b.操作员姓名,
              Zl_Date_Half(Greatest(Least(Nvl(b.上次计算时间, b.开始时间), Nvl(b.终止时间, Greatest(Nvl(b.上次计算时间, b.开始时间))),
                                           Greatest(Nvl(b.上次计算时间, b.开始时间))), p.执行日期, Nvl(a.启用日期, Add_Months(Sysdate, -2)))) As 开始日期,
              Zl_Date_Half(Least(Nvl(b.终止时间, Greatest(b.开始时间, Sysdate)), Nvl(p.终止日期, Sysdate + 30) + 1)) As 终止日期, a.数量
       From (Select 病区id, 计算标志, 收费细目id, 1 As 数量, 启用日期
              From 自动计价项目
              Union All
              Select 病区id, 计算标志, 从项id, i.从项数次 As 数量, 启用日期
              From 自动计价项目 A, 收费从属项目 I
              Where a.收费细目id = i.主项id And i.固有从属 > 0) A, 病人变动记录 B, 收费价目 P, 病人信息 C
       Where a.病区id = b.病区id And b.病人id = c.病人id And b.主页id = c.主页id And c.在院 = 1 And b.附加床位 <> 1 And b.开始原因 <> 10 And
             Zl_Date_Half(Nvl(b.上次计算时间, b.开始时间)) <> Zl_Date_Half(Nvl(b.终止时间, Sysdate)) And p.现价 <> 0 And
             a.收费细目id = p.收费细目id And (a.计算标志 = 6 And b.床位等级id Is Not Null Or a.计算标志 = 7) And
             Zl_Date_Half(Nvl(b.终止时间, Sysdate)) >= Zl_Date_Half(p.执行日期) And
             Zl_Date_Half(b.开始时间) <= Zl_Date_Half(Nvl(p.终止日期, Sysdate) + 1) And
             Zl_Date_Half(Least(Nvl(b.终止时间, Sysdate), Nvl(p.终止日期, Sysdate + 30) + 1)) >=
             Zl_Date_Half(Nvl(a.启用日期, Add_Months(Sysdate, -2))) And p.价格等级 Is Null) P
Where i.病人id = p.病人id And a.病人id = p.病人id And a.主页id = p.主页id;

Create Or Replace View 出院病人自动记帐 As
Select p.病人id, p.主页id, Nvl(a.姓名, i.姓名) As 姓名, Nvl(a.性别, i.性别) As 性别, Nvl(a.年龄, i.年龄) As 年龄, Nvl(a.住院号, i.住院号) As 住院号,
       a.费别, p.科室id, p.病区id, p.床号, p.附加床位, p.收费细目id, p.收入项目id, 1 As 标志, p.现价 As 标准单价, p.开始日期, p.终止日期,
       p.终止日期 - p.开始日期 As 天数, p.数量, p.经治医师, p.责任护士, p.操作员编号, p.操作员姓名
From 病人信息 I, 病案主页 A,
     (Select b.病人id, b.主页id, b.科室id, b.病区id, b.床号, b.附加床位, p.收费细目id, p.收入项目id, p.现价, b.经治医师, b.责任护士, b.操作员编号, b.操作员姓名,
              Zl_Date_Half(Greatest(Least(Nvl(b.上次计算时间, b.开始时间), Nvl(b.终止时间, Greatest(Nvl(b.上次计算时间, b.开始时间))),
                                           Greatest(Nvl(b.上次计算时间, b.开始时间))), p.执行日期, Nvl(a.启用日期, Add_Months(Sysdate, -2)))) As 开始日期,
              Zl_Date_Half(Least(Nvl(b.终止时间, Greatest(b.开始时间, Sysdate)), Nvl(p.终止日期, Sysdate + 30) + 1)) As 终止日期, b.数量
       From 自动计价项目 A,
            (Select 病人id, 主页id, 开始时间, 附加床位, 病区id, 科室id, 床号, 床位等级id, 1 As 数量, 责任护士, 经治医师, 终止时间, 操作员编号, 操作员姓名, 上次计算时间
              From 病人变动记录 A
              Where 开始原因 <> 10
              Union All
              Select 病人id, 主页id, 开始时间, 附加床位, 病区id, 科室id, 床号, i.从项id As 床位等级id, i.从项数次 As 数量, 责任护士, 经治医师, 终止时间, 操作员编号, 操作员姓名,
                     上次计算时间
              From 病人变动记录 B, 收费从属项目 I
              Where b.床位等级id = i.主项id And b.开始原因 <> 10 And i.固有从属 > 0) B, 收费价目 P
       Where a.病区id = b.病区id And Zl_Date_Half(Nvl(b.上次计算时间, b.开始时间)) <> Zl_Date_Half(Nvl(b.终止时间, Sysdate)) And p.现价 <> 0 And
             a.计算标志 = 1 And b.床位等级id = p.收费细目id And Zl_Date_Half(Nvl(b.终止时间, Sysdate)) >= Zl_Date_Half(p.执行日期) And
             Zl_Date_Half(b.开始时间) <= Zl_Date_Half(Nvl(p.终止日期, Sysdate) + 1) And
             Zl_Date_Half(Least(Nvl(b.终止时间, Sysdate), Nvl(p.终止日期, Sysdate + 30) + 1)) >=
             Zl_Date_Half(Nvl(a.启用日期, Add_Months(Sysdate, -2))) And p.价格等级 Is Null
       Union All
       Select b.病人id, b.主页id, b.科室id, b.病区id, b.床号, b.附加床位, p.收费细目id, p.收入项目id, p.现价, b.经治医师, b.责任护士, b.操作员编号, b.操作员姓名,
              Zl_Date_Half(Greatest(Least(Nvl(b.上次计算时间, b.开始时间), Nvl(b.终止时间, Greatest(Nvl(b.上次计算时间, b.开始时间))),
                                           Greatest(Nvl(b.上次计算时间, b.开始时间))), p.执行日期, Nvl(a.启用日期, Add_Months(Sysdate, -2)))) As 开始日期,
              Zl_Date_Half(Least(Nvl(b.终止时间, Greatest(b.开始时间, Sysdate)), Nvl(p.终止日期, Sysdate + 30) + 1)) As 终止日期, b.数量
       From 自动计价项目 A,
            (Select 病人id, 主页id, 开始时间, 附加床位, 病区id, 科室id, 床号, 护理等级id, 1 As 数量, 责任护士, 经治医师, 终止时间, 操作员编号, 操作员姓名, 上次计算时间
              From 病人变动记录
              Where 开始原因 <> 10
              Union All
              Select 病人id, 主页id, 开始时间, 附加床位, 病区id, 科室id, 床号, i.从项id As 护理等级id, i.从项数次 As 数量, 责任护士, 经治医师, 终止时间, 操作员编号, 操作员姓名,
                     上次计算时间
              From 病人变动记录 B, 收费从属项目 I
              Where b.护理等级id = i.主项id And b.开始原因 <> 10 And i.固有从属 > 0) B, 收费价目 P, 收费项目目录 C
       Where a.病区id = b.病区id And b.附加床位 <> 1 And
             Zl_Date_Half(Nvl(b.上次计算时间, b.开始时间)) <> Zl_Date_Half(Nvl(b.终止时间, Sysdate)) And p.现价 <> 0 And a.计算标志 = 2 And
             b.护理等级id = p.收费细目id And b.护理等级id = c.Id And Nvl(c.计算方式, 0) <> 1 And
             Zl_Date_Half(Nvl(b.终止时间, Sysdate)) >= Zl_Date_Half(p.执行日期) And
             Zl_Date_Half(b.开始时间) <= Zl_Date_Half(Nvl(p.终止日期, Sysdate) + 1) And
             Zl_Date_Half(Least(Nvl(b.终止时间, Sysdate), Nvl(p.终止日期, Sysdate + 30) + 1)) >=
             Zl_Date_Half(Nvl(a.启用日期, Add_Months(Sysdate, -2))) And p.价格等级 Is Null
       Union All
       Select b.病人id, b.主页id, b.科室id, b.病区id, b.床号, b.附加床位, p.收费细目id, p.收入项目id, p.现价, b.经治医师, b.责任护士, b.操作员编号, b.操作员姓名,
              Zl_Date_Half(Greatest(Least(Nvl(b.上次计算时间, b.开始时间), Nvl(b.终止时间, Greatest(Nvl(b.上次计算时间, b.开始时间))),
                                           Greatest(Nvl(b.上次计算时间, b.开始时间))), p.执行日期, Nvl(a.启用日期, Add_Months(Sysdate, -2)))) As 开始日期,
              Zl_Date_Half(Least(Nvl(b.终止时间, Greatest(b.开始时间, Sysdate)), Nvl(p.终止日期, Sysdate + 30) + 1)) As 终止日期, a.数量
       From (Select 病区id, 计算标志, 收费细目id, 1 As 数量, 启用日期
              From 自动计价项目
              Union All
              Select 病区id, 计算标志, 从项id, i.从项数次 As 数量, 启用日期
              From 自动计价项目 A, 收费从属项目 I
              Where a.收费细目id = i.主项id And i.固有从属 > 0) A, 病人变动记录 B, 收费价目 P
       Where a.病区id = b.病区id And b.附加床位 <> 1 And b.开始原因 <> 10 And
             Zl_Date_Half(Nvl(b.上次计算时间, b.开始时间)) <> Zl_Date_Half(Nvl(b.终止时间, Sysdate)) And p.现价 <> 0 And
             a.收费细目id = p.收费细目id And (a.计算标志 = 6 And b.床位等级id Is Not Null Or a.计算标志 = 7) And
             Zl_Date_Half(Nvl(b.终止时间, Sysdate)) >= Zl_Date_Half(p.执行日期) And
             Zl_Date_Half(b.开始时间) <= Zl_Date_Half(Nvl(p.终止日期, Sysdate) + 1) And
             Zl_Date_Half(Least(Nvl(b.终止时间, Sysdate), Nvl(p.终止日期, Sysdate + 30) + 1)) >=
             Zl_Date_Half(Nvl(a.启用日期, Add_Months(Sysdate, -2))) And p.价格等级 Is Null) P
Where i.病人id = p.病人id And a.病人id = p.病人id And a.主页id = p.主页id;


--92837:李业庆,2017-06-07,出库单据库房信息中入库时间处理
create table 药品入库信息 
(
       药品id number(18),
       库房id number(18),
       批次 number(18),
       入库日期 date
) tablespace ZL9MEDLST;

Alter Table 药品入库信息 Add Constraint 药品入库信息_UQ_药品id Unique (药品id,库房id,批次) Using Index Tablespace zl9indexhis;
Alter Table 药品入库信息 Modify 药品id Constraint 药品入库信息_NN_药品id Not Null; 
Alter Table 药品入库信息 Modify 库房id Constraint 药品入库信息_NN_库房id Not Null; 
Alter Table 药品入库信息 Add Constraint 药品入库信息_FK_库房id Foreign Key (库房id) References 部门表(id);
Alter Table 药品入库信息 Add Constraint 药品入库信息_FK_药品id Foreign Key (药品id) References 收费项目目录(id);
Create Index 药品入库信息_IX_库房id on 药品入库信息(库房id) Tablespace zl9Indexhis;

--105570:冉俊明,2017-07-03,转病区费用
Alter Table 费用变动记录 Add Constraint 费用变动记录_Fk_原病区id Foreign Key(原病区id) References 部门表(ID);
Alter Table 费用变动记录 Add Constraint 费用变动记录_Fk_目标病区id Foreign Key(目标病区id) References 部门表(ID);
Alter Table 费用变动记录 Add Constraint 费用变动记录_Fk_收费细目id Foreign Key(收费细目id) References 收费项目目录(ID);
Alter Table 费用变动记录 Add Constraint 费用变动记录_Fk_病人id Foreign Key(病人id, 主页id) References 病案主页(病人id, 主页id);

--107171:张德婷,2017-07-06,静配中心新增排班功能
Alter Table 配液台药品对照 Add Constraint 配液台药品对照_FK_配药台id Foreign Key(配药台id) References 配液台(ID) On Delete Cascade;
Alter Table 配液台药品对照 Add Constraint 配液台药品对照_FK_药品id Foreign Key(药品id) References 收费项目目录(ID) On Delete Cascade;
Alter Table 配液工作安排 Add Constraint 配液工作安排_FK_配药台id Foreign Key(配药台id) References 配液台(ID) On Delete Cascade;

-------------------------------------------------------------------------------
--数据修正部份
-------------------------------------------------------------------------------
--111447:蔡青松,2017-07-11,添加参数控制是否发料退料
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1211, 0, 1, 0, 0, 0, 0, 19, '自动发料退料', '0', '0', '控制完成采集时是否自动发料，取消采集时是否自动退料',
         '1=完成采集时自动发料，取消采集时自动退料；0=完成采集时不自动发料，取消采集时不自动退料', Null, '适用于采集工作站完成采集和取消完成采集', Null
  From Dual;

--00000:张永康,2017-07-06,数据表分类
--A1:静态基础数据
Insert into zlTables(系统,表名,表空间,分类) Values(100,'ICU类型','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'变异常见原因','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病案费目','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病案类别','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病理类型','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病历标记图形','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病历常用样式','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病历时限要求','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病历书写事件','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病历替代关系','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病历文件格式','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病历文件结构','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病历文件列表','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病历文件图形','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病历页面格式','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病情','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人去向','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病生理情况','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病原学目录','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'不良事件','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'部门环境类别','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'部门性质分类','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'材料货源情况','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'采血管类型','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'常用剂量比例','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'常用体温说明','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'常用停诊原因','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'出院方式','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'传染病目录','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'床位编制分类','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'单病种目录','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'单据环节控制','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'地区','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'费用类型','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'分化程度','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'分娩方式','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'感染部位','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'感染因素','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'革兰染色分类','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'管理职务','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'国籍','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'号类','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'号码控制表','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'护理记录项目','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'毁损发生原因','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'毁损解决办法','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'婚姻状况','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'基本药物说明','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'疾病编码分类','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'疾病编码类别','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'疾病编码目录','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'家系称谓关系','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验拒收理由','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验细菌菌属','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验细菌类别','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'结算场合','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'结算方式','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'结算方式应用','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'抗菌用药评价项目','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'抗菌预防用药期间','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临床病例分型','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临床路径图标','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临床特征','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临床性质','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'路径报表目录','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'路径常见结果','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'路径结果性质','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'麻醉记录项目','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'民族','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'票据使用类别','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'期间表','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'器械导管目录','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'抢救病因分类','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'区域','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'人民币面额','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'人员性质分类','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'入院方式','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'入院属性','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'社会关系','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'身份','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'身份证未录原因','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'时间段','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'收费项目类别','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'收据费目','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'收入项目','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'手术类型','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'手术切口愈合','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'输血目的','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'输血性质','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'胎儿状况','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'特殊符号','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'体温部位','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'体温记录项目','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'体温重叠标记','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'停嘱原因','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'细菌检测方法','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'消费卡类型','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'性别','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'学历','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'血型','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药价管理级别','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品存储温度','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品单据分类','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品毒理分类','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品货源情况','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品剂型','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品价值分类','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品来源分类','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品入出类别','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品外观','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品卫材精度','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品用药梯次','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'业务消息类型','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'医疗付款方式','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'医疗卡挂失方式','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'医疗卡类别','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'医疗类别','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'医学警示','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'医院感染目录','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'医嘱未执行原因','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像MWL结果集','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像报告插件','ZLPACSBASETAB','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像报告事件','ZLPACSBASETAB','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像报告预备提纲','ZLPACSBASETAB','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像标注存储表','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像病理类别','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像检查类别','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像胶片规格','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像图像信息表','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像颜色清单','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像预设窗宽窗位','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'预约方式','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'造影剂','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'诊疗检查部位','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'诊疗检查类型','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'诊疗检验标本','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'诊疗检验类型','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'诊疗麻醉类型','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'诊疗频率时间','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'诊疗频率项目','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'诊疗手术规模','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'诊疗项目类别','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'诊治所见分类','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'诊治所见项目','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'诊治所见性质','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'证件类型','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'职业','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'执业类别','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'质控即刻法','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'质控控界系数','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'治疗结果','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'中药煎服脚注','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'中药输入快捷','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'住院目的','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'住院死亡期间','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'住院死亡原因','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'专业技术职务','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'咨询附加选项','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'咨询页面目录','ZL9BASEITEM','A1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'最高诊断依据','ZL9BASEITEM','A1');

--A2:动态基础数据
Insert into zlTables(系统,表名,表空间,分类) Values(100,'RIS启用控制','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'安排停用原因','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'保险病种','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'保险参数','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'保险费用档','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'保险类别','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'保险年龄段','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'保险人群','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'保险特准项目','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'保险项目','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'保险支付比例','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'保险支付大类','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'保险支付限额','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'保险支付项目','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'保险中心目录','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'报表条件','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'标准医价规范','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病案评分标准','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病案评分方案','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病案评分明细','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病案审查方案','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病案审查分类','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病案审查目录','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病案项目','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病理档案分类','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病理号码规则','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病理号码记录','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病理检查标本','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病理套餐关联','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病理套餐信息','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病历单据附项','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病历单据应用','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病历附项模板','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病历应用科室','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病区标记内容','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病区公告栏样式','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病区科室对应','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人发卡记录','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人类型','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'部门安排','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'部门表','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'部门扩展项目','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'部门扩展信息','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'部门人员','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'部门性质说明','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'材料材质分类','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'材料出库检查','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'材料储备限额','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'材料存储条件','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'材料加成方案','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'材料价值分类','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'材料库房货位','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'材料来源分类','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'材料领用用途','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'材料流向控制','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'材料生产商','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'材料特性','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'材料外销单位','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'材料中标单位','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'财务缴款分组','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'财务组组长构成','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'产程部件','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'产程要素内容','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'常用发卡原因','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'常用挂号摘要','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'常用就诊摘要','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'常用退费原因','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'常用退号原因','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'常用预交摘要','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'常用嘱托','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'成套收费项目','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'成套收费项目组合','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'成套项目分类','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'成套项目使用科室','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'出院转入','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'处方审查参数','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'处方审查常用理由','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'处方审查条件','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'处方审查项目','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'大类档次比例','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'单据操作控制','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'电子签名启用部门','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'发药窗口','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'发药类型','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'法定假日表','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'费别','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'费别明细','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'费别适用科室','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'供应商','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'供应商照片','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'挂号安排','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'挂号安排计划','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'挂号安排时段','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'挂号安排停用状态','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'挂号安排限制','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'挂号安排诊室','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'挂号合作单位','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'挂号计划时段','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'挂号计划限制','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'挂号计划诊室','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'合约单位','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'合作单位安排控制','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'合作单位计划控制','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'护理波动项目','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'护理汇总时段','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'护理汇总项目','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'护理适用科室','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'护理项目模板','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'护理项目频次','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'疾病报告前提','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'疾病报送单位','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'疾病编码科室','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'疾病病种对应','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'疾病申报对应','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'疾病诊断对照','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'疾病诊断科室','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'疾病诊疗措施','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'记帐报警线','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验报告项目','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验备注文字','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验标本形态','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验分析用途','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验合并规则','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验结果描述','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验抗生素用药','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验抗生素组','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验酶标模板','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验模板目录','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验模板内容','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验模板药敏','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验培养文字','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验评语文字','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验申请项目','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验审核规则','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验审核类别','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验试剂关系','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验细菌','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验细菌抗生素','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验细菌抗生素参考','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验细菌类型','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验项目','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验项目参考','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验项目取值','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验项目选项','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验小组','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验小组成员','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验小组仪器','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验仪器','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验仪器规则','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验仪器项目','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验仪器状态','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验用抗生素','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验质控均值','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验质控品','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验质控品项目','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'缴款成员组成','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'借阅理由','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'卡消费接口目录','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'抗菌药物抽样记录','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'抗菌药物抽样明细','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'抗菌药物抽样评价','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'抗菌药物抽样手术','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'抗菌药物抽样用药','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'科室号码表','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'科室容量设置','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'快捷功能关联','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'快捷功能信息','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临床部门','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临床出诊安排','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临床出诊变动记录','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临床出诊变动明细','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临床出诊表','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临床出诊挂号控制','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临床出诊挂号控制记录','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临床出诊号源','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临床出诊号源控制','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临床出诊号源时段','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临床出诊号源限制','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临床出诊号源诊室','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临床出诊记录','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临床出诊时段','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临床出诊停诊记录','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临床出诊限制','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临床出诊序号控制','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临床出诊诊室','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临床出诊诊室记录','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临床路径版本','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临床路径病历','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临床路径病种','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临床路径分类','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临床路径分支','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临床路径阶段','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临床路径科室','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临床路径目录','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临床路径评估','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临床路径文件','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临床路径项目','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临床路径医嘱','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临床医疗小组','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'路径报表结构','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'路径报表序号','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'路径评估条件','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'路径评估指标','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'路径上报变异原因','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'路径项目顺序','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'路径医嘱内容','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'门诊诊室','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'门诊诊室适用科室','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'排队LED显示部件','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'排队号码表','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'排队优先原因','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'配药工作批次','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'配置收费方案','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'配液台药品对照','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'配液工作安排','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'人员表','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'人员抗菌药物权限','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'人员扩展项目','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'人员扩展信息','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'人员手术权限','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'人员性质说明','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'人员照片','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'人员证书记录','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'上机人员表','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'社区参数','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'社区目录','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'审批项目模板','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'收费从属项目','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'收费调价记录','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'收费分类目录','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'收费记帐单','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'收费记帐单定义','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'收费价格等级','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'收费价格等级应用','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'收费价目','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'收费适用科室','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'收费特定项目','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'收费项目别名','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'收费项目目录','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'收费项目组成','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'收费执行科室','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'收据费目对应','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'输血检验对照','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'输液不配置药品','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'输液配药类型','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'输液通道','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'输液药品属性','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'输液药品优先级','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'输液优先打印药品','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'体温标记说明','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'体温部件','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'体温同步项目','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'细菌耐药机制','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'协定药品对照','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'虚拟库房对照','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药比附加条件','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药房配药控制','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品出库检查','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品储备限额','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品单据性质','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品规格','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品规格扩展项目','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品规格扩展信息','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品加成方案','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品库房单位','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品库房货位','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品领用控制','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品流向控制','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品设备接口','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品生产商','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品生产商对照','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品特性','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品外调单位','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品外销单位','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品用法用量','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品中标单位','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'一卡通目录','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'医保对照类别','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'医保对照明细','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'医技执行房间','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'医价接口','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'医疗机构','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'医疗小组人员','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'医生常用医嘱','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'医生常用诊断','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'医嘱常用原因','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'医嘱内容定义','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'移动查房接口','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'仪器细菌对照','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'隐私保护项目','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像DICOM服务参数','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像DICOM服务对','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像MWL部位对码','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像报告动作','ZLPACSBASETAB','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像报告范文清单','ZLPACSBASETAB','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像报告计量单位','ZLPACSBASETAB','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像报告片段清单','ZLPACSBASETAB','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像报告元素分类','ZLPACSBASETAB','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像报告元素清单','ZLPACSBASETAB','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像报告原型片段','ZLPACSBASETAB','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像报告原型清单','ZLPACSBASETAB','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像报告原型应用','ZLPACSBASETAB','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像报告值域清单','ZLPACSBASETAB','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像报告种类','ZLPACSBASETAB','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像报告组句清单','ZLPACSBASETAB','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像参数取值','ZLPACSBASETAB','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像参数说明','ZLPACSBASETAB','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像操作记录','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像插件功能','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像插件挂接','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像查询方案','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像查询配置','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像打印格式','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像打印机设置','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像分组关联','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像检查项目','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像胶片打印字体','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像接入设备','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像界面参数表','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像流程参数','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像滤镜模板','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像屏幕布局','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像设备目录','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像收藏类别','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像鼠标按钮分配','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像图像备注','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像图像消隐表','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像诊断分类','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像执行分组','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像字典内容','ZLPACSBASETAB','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像字典清单','ZLPACSBASETAB','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'诊断病种对应','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'诊疗分类目录','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'诊疗个人项目','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'诊疗适用科室','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'诊疗收费关系','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'诊疗项目别名','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'诊疗项目部位','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'诊疗项目目录','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'诊疗项目组合','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'诊疗用法用量','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'诊疗执行科室','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'质控检验方法','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'质控试剂来源','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'咨询表格内容','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'咨询表格元素','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'咨询段落链接','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'咨询段落目录','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'咨询广告序列','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'咨询图片元素','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'咨询页面排列','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'咨询专家清单','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'自动计价项目','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'自制材料构成','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'自制药品构成','ZL9BASEITEM','A2');

--A3:知识数据
Insert into zlTables(系统,表名,表空间,分类) Values(100,'标准路径表单','ZL9BASEITEM','A3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'标准路径病种','ZL9BASEITEM','A3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'标准路径流程','ZL9BASEITEM','A3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'标准路径目录','ZL9BASEITEM','A3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病历词句分类','ZL9BASEITEM','A3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病历词句示范','ZL9BASEITEM','A3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病历词句条件','ZL9BASEITEM','A3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病历词句组成','ZL9BASEITEM','A3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病历范文包','ZL9BASEITEM','A3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病历范文包组成','ZL9BASEITEM','A3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病历范文格式','ZL9BASEITEM','A3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病历范文目录','ZL9BASEITEM','A3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病历范文内容','ZL9BASEITEM','A3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病历范文条件','ZL9BASEITEM','A3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病历范文图形','ZL9BASEITEM','A3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病历提纲词句','ZL9BASEITEM','A3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'疾病参考项目','ZL9BASEITEM','A3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'疾病诊断别名','ZL9BASEITEM','A3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'疾病诊断参考','ZL9BASEITEM','A3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'疾病诊断分类','ZL9BASEITEM','A3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'疾病诊断规则','ZL9BASEITEM','A3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'疾病诊断目录','ZL9BASEITEM','A3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'疾病诊断属类','ZL9BASEITEM','A3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验质控范则','ZL9BASEITEM','A3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验质控规则','ZL9BASEITEM','A3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'诊疗参考别名','ZL9BASEITEM','A3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'诊疗参考分类','ZL9BASEITEM','A3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'诊疗参考疾病','ZL9BASEITEM','A3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'诊疗参考目录','ZL9BASEITEM','A3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'诊疗参考内容','ZL9BASEITEM','A3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'诊疗参考项目','ZL9BASEITEM','A3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'诊疗互斥项目','ZL9BASEITEM','A3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'质控报告词句','ZL9BASEITEM','A3');

--B1:业务活动数据
Insert into zlTables(系统,表名,表空间,分类) Values(100,'RIS检查预约','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'保险结算计算','ZL9EXPENSE','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'保险结算记录','ZL9EXPENSE','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'保险结算明细','ZL9EXPENSE','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'保险模拟结算','ZL9EXPENSE','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病案反馈记录','ZL9CISAUDIT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病案反馈历史','ZL9CISAUDIT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病案放疗记录','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病案封存记录','ZL9CISAUDIT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病案化疗记录','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病案接收记录','ZL9CISAUDIT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病案借阅记录','ZL9CISAUDIT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病案借阅内容','ZL9CISAUDIT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病案借阅人员','ZL9CISAUDIT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病案精神治疗','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病案评分结果','ZL9CISAUDIT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病案审阅书签','ZL9CISAUDIT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病案提交记录','ZL9CISAUDIT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病案重症监护情况','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病案主页','ZL9PATIENT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病案主页从表','ZL9PATIENT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病理报告延迟','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病理标本信息','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病理玻片信息','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病理档案信息','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病理归档信息','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病理归还信息','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病理过程报告','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病理会诊信息','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病理检查信息','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病理借阅关联','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病理借阅信息','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病理抗体反馈','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病理抗体信息','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病理取材信息','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病理申请信息','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病理送检信息','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病理特检信息','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病理脱钙信息','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病理遗失信息','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病理制片信息','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病理质量信息','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人备注信息','ZL9PATIENT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人变动记录','ZL9PATIENT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人病原学检查','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人出径记录','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人催款记录','ZL9EXPENSE','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人担保记录','ZL9PATIENT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人地址信息','ZL9PATIENT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人分娩信息','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人服务信息记录','ZL9BASEITEM','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人感染记录','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人挂号记录','ZL9PATIENT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人过敏记录','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人过敏药物','ZL9PATIENT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人合并记录','ZL9PATIENT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人合并路径','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人合并路径评估','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人护理活动项目','ZL9EPRDAT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人护理记录','ZL9EPRDAT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人护理明细','ZL9EPRDAT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人护理内容','ZL9EPRDAT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人护理数据','ZL9EPRDAT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人护理文件','ZL9EPRDAT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人护理要素内容','ZL9EPRDAT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人家属','ZL9PATIENT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人缴款对照','ZL9EXPENSE','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人缴款记录','ZL9EXPENSE','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人结帐记录','ZL9EXPENSE','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人卡结算对照','ZL9EXPENSE','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人卡结算记录','ZL9EXPENSE','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人抗生素记录','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人临床路径','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人路径变异','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人路径病历','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人路径评估','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人路径取消','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人路径医嘱','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人路径执行','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人路径指标','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人免疫记录','ZL9PATIENT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人社区信息','ZL9PATIENT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人审批项目','ZL9PATIENT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人手麻记录','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人新生儿记录','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人信息','ZL9PATIENT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人信息从表','ZL9PATIENT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人医疗卡变动','ZL9PATIENT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人医疗卡属性','ZL9PATIENT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人医疗卡信息','ZL9PATIENT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人医嘱报告','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人医嘱发送','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人医嘱附费','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人医嘱附件','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人医嘱计价','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人医嘱记录','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人医嘱执行','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人医嘱状态','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人预交记录','ZL9EXPENSE','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人照片','ZL9PATIENT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人诊断记录','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人诊断医嘱','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人症状记录','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人转诊记录','ZL9PATIENT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人自动计算','ZL9PATIENT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'材料采购计划','ZL9MEDLST','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'材料计划内容','ZL9MEDLST','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'材料领用信息','ZL9MEDLST','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'成本价调价信息','ZL9MEDLST','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'处方审查记录','ZL9MEDLST','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'处方审查结果','ZL9MEDLST','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'处方审查明细','ZL9MEDLST','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'电子病历附件','ZL9EPRLOB','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'电子病历格式','ZL9EPRLOB','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'电子病历记录','ZL9EPRDAT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'电子病历内容','ZL9EPRDAT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'电子病历图形','ZL9EPRLOB','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'调价汇总记录','ZL9MEDLST','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'费用变动记录','ZL9EXPENSE','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'费用补充记录','ZL9EXPENSE','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'费用审核记录','ZL9EXPENSE','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'服用造影剂','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'付款记录','ZL9DUEREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'疾病报告反馈','ZL9EPRDAT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'疾病申报反馈','ZL9EPRDAT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'疾病申报记录','ZL9EPRDAT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'疾病阳性记录','ZL9EPRDAT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验标本记录','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验操作记录','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验分析记录','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验拒收记录','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验流水线标本','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验流水线指标','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验酶标记录','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验酶标试剂','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验普通结果','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验弃用报告','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验签名记录','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验试剂记录','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验图像结果','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验项目分布','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验药敏结果','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验质控报告','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验质控记录','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'就诊登记记录','ZL9BASEITEM','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'库房确认记录','ZL9MEDLST','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'路径报表记录','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'路径报表文件','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'门诊病案记录','ZL9PATIENT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'门诊费用记录','ZL9EXPENSE','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'排队记录','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'票据报损记录','ZL9EXPENSE','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'票据领用记录','ZL9EXPENSE','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'票据入库记录','ZL9EXPENSE','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'票据使用明细','ZL9EXPENSE','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'器械导管使用情况','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'人员借款记录','ZL9EXPENSE','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'人员收缴对照','ZL9EXPENSE','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'人员收缴记录','ZL9EXPENSE','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'人员收缴明细','ZL9EXPENSE','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'人员收缴票据','ZL9EXPENSE','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'人员暂存记录','ZL9EXPENSE','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'三方结算交易','ZL9EXPENSE','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'三方退款信息','ZL9EXPENSE','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'收发记录补充信息','ZL9MEDLST','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'收费清点记录','ZL9EXPENSE','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'输血检验结果','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'输血申请记录','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'输液配药附费','ZL9MEDLST','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'输液配药记录','ZL9MEDLST','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'输液配药内容','ZL9MEDLST','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'输液配药状态','ZL9MEDLST','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'特殊病人','ZL9PATIENT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'消费卡充值记录','ZL9EXPENSE','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'消费卡目录','ZL9EXPENSE','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'新生儿诊断记录','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品财务审核','ZL9MEDLST','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品采购计划','ZL9MEDLST','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品计划内容','ZL9MEDLST','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品结存记录','ZL9MEDLST','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品结存明细','ZL9MEDLST','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品结存误差','ZL9MEDLST','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品留存计划','ZL9MEDLST','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品批号对照','ZL9MEDLST','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品签名记录','ZL9MEDLST','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品签名明细','ZL9MEDLST','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品入库信息','ZL9MEDLST','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品收发记录','ZL9MEDLST','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品收发门诊标志','ZL9MEDLST','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品收发住院标志','ZL9MEDLST','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品退药计划','ZL9MEDLST','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品验收记录','ZL9MEDLST','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品验收明细','ZL9MEDLST','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品质量记录','ZL9MEDLST','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'医保病人档案','ZL9PATIENT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'医保病人关联表','ZL9BASEITEM','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'医保结算明细','ZL9EXPENSE','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'医嘱报告内容','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'医嘱签名记录','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'医嘱执行计价','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'医嘱执行时间','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'应付记录','ZL9DUEREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像报告驳回','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像报告记录','ZLPACSBIZTAB','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像归档作业','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像检查记录','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像检查图象','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像检查序列','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像申请单图像','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像收藏内容','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像危急值记录','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'暂存药品记录','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'帐户年度信息','ZL9PATIENT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'诊断符合情况','ZL9CISREC','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'住院病案记录','ZL9PATIENT','B1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'住院费用记录','ZL9EXPENSE','B1');

--B2:临时数据
Insert into zlTables(系统,表名,表空间,分类) Values(100,'RIS医嘱失败记录','ZL9CISREC','B2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病历内容监测','','B2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病历时限监测','','B2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病区标记记录','ZL9EPRDAT','B2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'电子病历时机','ZL9EPRDAT','B2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'检验酶标板打印','','B2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临时病历内容','','B2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'临时票据打印内容','','B2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'排队叫号队列','ZL9BASEITEM','B2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'排队语音呼叫','ZL9BASEITEM','B2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'未发药品记录','ZL9MEDLST','B2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'未审药品记录','ZL9MEDLST','B2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'业务消息清单','ZL9CISREC','B2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'业务消息提醒部门','ZL9CISREC','B2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'业务消息提醒人员','ZL9CISREC','B2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'业务消息状态','ZL9CISREC','B2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像临时记录','ZL9CISREC','B2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像临时图象','ZL9CISREC','B2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像临时序列','ZL9CISREC','B2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'质控即刻法打印','','B2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'质控即刻图打印','','B2');

--B3:日志数据
Insert into zlTables(系统,表名,表空间,分类) Values(100,'RIS接口日志记录','ZL9CISREC','B3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'报告查阅记录','ZL9CISREC','B3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病案打印记录','ZL9CISAUDIT','B3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病历变动结果','ZL9EPRDAT','B3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病历变动原因','ZL9EPRDAT','B3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人费用销帐','ZL9EXPENSE','B3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人护理打印','ZL9EPRDAT','B3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人退费申请','ZL9EXPENSE','B3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人信息变动','ZL9PATIENT','B3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人医嘱打印','ZL9CISREC','B3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人执行单打印','ZL9CISREC','B3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'床位增减记录','ZL9PATIENT','B3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'电子病历打印','ZL9EPRDAT','B3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'费用清单打印','ZL9EXPENSE','B3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'呼叫器日志','ZL9CISREC','B3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'胶片打印记录','ZL9CISREC','B3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'结算日志','ZL9BASEITEM','B3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'三方交易记录','ZL9EXPENSE','B3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'就诊变动记录','ZL9PATIENT','B3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'路径医嘱变动','ZL9CISREC','B3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'门诊输液操作日志','ZL9CISREC','B3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'票据打印明细','ZL9EXPENSE','B3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'票据打印内容','ZL9EXPENSE','B3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'凭条打印记录','ZL9EXPENSE','B3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'体温单打印','ZL9EPRDAT','B3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'医嘱执行打印','ZL9CISREC','B3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'影像报告操作记录','ZLPACSBASETAB','B3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'诊疗单据打印','ZL9CISREC','B3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'执行打印记录','ZL9CISREC','B3');

--C1:状态数据
Insert into zlTables(系统,表名,表空间,分类) Values(100,'床位状况记录','ZL9PATIENT','C1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'挂号序号状态','ZL9PATIENT','C1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'号码编号表','ZL9BASEITEM','C1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'门诊穿刺台','ZL9CISREC','C1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'在院病人','ZL9PATIENT','C1');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'座位状况记录','ZL9CISREC','C1');

--C2:汇总数据
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人费用汇总','ZL9EXPENSE','C2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人挂号汇总','ZL9EXPENSE','C2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人结帐汇总','ZL9EXPENSE','C2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'合作单位挂号汇总','ZL9EXPENSE','C2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品收发汇总','ZL9MEDLST','C2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'医生收入汇总','ZL9EXPENSE','C2');

--C3:余额数据
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人未结费用','ZL9EXPENSE','C3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'病人余额','ZL9EXPENSE','C3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'人员缴款余额','ZL9EXPENSE','C3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品结存','ZL9MEDLST','C3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品库存','ZL9MEDLST','C3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品留存','ZL9MEDLST','C3');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'应付余额','ZL9DUEREC','C3');


--109301:殷瑞,2017-07-04,新增卫材移库按批次出库
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, -Null, -Null, -Null, -Null, -Null, 0, 0, 280, '按批次移库卫生材料','1', '1', '当该参数启用之后，移库时要确定具体批次，否则不用确定具体批次',
         '0-不启用;1-启用', Null, Null, Null
  From Dual;

--102594:秦龙,2017-07-03,修正民族名称
update 民族 set 名称='毛南族' where 名称='毛难族';

 --104662:蒋廷中,2017-06-30,增加医生授权管理的权限模块
Insert Into zlPrograms
  (序号, 标题, 说明, 系统, 部件)
  Select 1082 序号, '医生授权管理' 标题, '拥有本模块权限的人员可对本科室或全院临床医师的所有权限进行集中管理。' As 说明, &n_System 系统, 'zl9CISBase' 部件
  From Dual;

Insert Into zlMenus
  (组别, ID, 上级id, 标题, 快键, 说明, 系统, 模块, 短标题, 图标)
  Select a.组别, Zlmenus_Id.Nextval, a.Id, b.*
  From (Select 组别, ID From zlMenus Where 标题 = '医护基础项目' And 组别 = '缺省' And 系统 = &n_System And 模块 Is Null) A,
       (Select 标题, 快键, 说明, 系统, 模块, 短标题, 图标 From zlMenus Where 1 = 0 
       Union All
       Select '医生授权管理', 'O', '拥有本模块权限的人员可对本科室或全院临床医师的所有权限进行集中管理。', &n_System, 1082, '医生授权管理', 99 From Dual) B
  Where Not Exists (Select 1 From zlMenus Where 模块 = 1082 And 标题 = '医生授权管理');

--104662:蒋廷中,2017-06-30,修正毒麻贵重精神下达的授权数据
Declare
  l_人员id t_Numlist := t_Numlist();
  l_门诊   t_Strlist := t_Strlist();
  l_住院   t_Strlist := t_Strlist();
Begin
  Select 人员id, 是否有门诊毒性 || 是否有门诊麻醉 || 是否有门诊精神 || 是否有门诊贵重 As 门诊特殊医嘱权限,
         是否有住院毒性 || 是否有住院麻醉 || 是否有住院精神 || 是否有住院贵重 As 住院特殊医嘱权限 Bulk Collect
  Into l_人员id, l_门诊, l_住院
  From (Select 人员id, Max(Decode(序号, 1252, Decode(功能, '下达毒性药嘱', 1, 0), 0)) As 是否有门诊毒性,
                Max(Decode(序号, 1252, Decode(功能, '下达麻醉药嘱', 1, 0), 0)) As 是否有门诊麻醉,
                Max(Decode(序号, 1252, Decode(功能, '下达精神药嘱', 1, 0), 0)) As 是否有门诊精神,
                Max(Decode(序号, 1252, Decode(功能, '下达贵重药嘱', 1, 0), 0)) As 是否有门诊贵重,
                Max(Decode(序号, 1253, Decode(功能, '下达毒性药嘱', 1, 0), 0)) As 是否有住院毒性,
                Max(Decode(序号, 1253, Decode(功能, '下达麻醉药嘱', 1, 0), 0)) As 是否有住院麻醉,
                Max(Decode(序号, 1253, Decode(功能, '下达精神药嘱', 1, 0), 0)) As 是否有住院精神,
                Max(Decode(序号, 1253, Decode(功能, '下达贵重药嘱', 1, 0), 0)) As 是否有住院贵重
         From (Select Distinct c.人员id, b.序号, b.功能
                From Zluserroles A, zlRoleGrant B, 上机人员表 C, 人员性质说明 D
                Where a.角色 = b.角色 And a.用户 = c.用户名 And c.人员id = d.人员id And d.人员性质 = '医生' And b.序号 In (1252, 1253) And b.系统 = &n_System And
                      (b.功能 = '下达毒性药嘱' Or b.功能 = '下达麻醉药嘱' Or b.功能 = '下达精神药嘱' Or b.功能 = '下达贵重药嘱'))
         Group By 人员id);
       
  Forall I In 1 .. l_人员id.Count 
         Update 人员表 Set 门诊特殊医嘱权限 = l_门诊(I), 住院特殊医嘱权限 = l_住院(I) Where id = l_人员id(I);
End;
/



--108933:殷瑞,2017-06-30,药品领用模块新增申请冲销、审核冲销功能
Insert Into Zlparameters
  (Id, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1305, 0, 0, 0, 0, 0, 0, 9, '冲销申请', '0', '0',
         '勾选时如果对领用单进行冲销，需要由科室提出冲销申请，再由库房对申请进行审核；如果不勾选则无论科室还是库房都能进行直接冲销', '0-不启用;1-启用', Null,
         '领用冲销涉及到库房和科室两个库房的业务，如果希望冲销业务能互动，相互能更好的通过业务系统进行联系，那么采取冲销申请模式更合适', '当存在未审核的冲销申请单时，不能取消该参数'
  From Dual;

--109471:李南春,2017-06-28,候诊人数是否统计弃呼病人
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1802, 0, 0, 0, 0, 0, 0, 47, '候诊人数不包含弃号病人', '0',
         '0', '自助挂号管理中，在统计医生的候诊人数时，是否将已经弃呼的挂号病人也统计进来', '0-将弃呼但未退号的病人一起统计;1-不统计弃呼的病人', 
         '启用了排队叫号模式不统计弃呼的病人才会生效', '根据医院实际情况统计排队人数', Null
  From Dual;

--110538:焦博,2017-06-26,增加同一身份证只能对应一个建档病人的系统参数
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select zlParameters_ID.Nextval, &n_System, -Null, -Null,-Null,-Null,-Null, 0, 0, 279, '同一身份证只能对应一个建档病人', Null, '0', '控制在病人建档时,一张身份证对应一个还是多个建档病人',
         '1-身份证只能对应一个建档病人;0-身份证可以对应多个建档病人。如果参数值为1，则在输入身份证号或扫描身份证号时,需要去查找该病人是否建档，如存在建档，则以该建档病人为准（弹出选择），否则才新建立档案;如果参数为0,则保持原有功能',
         Null, '适用于一张身份证只对应一个建档病人', Null
  From Dual;

--109035:蔡青松,2017-06-23,生成条码时区分申请科室
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1211, 0, 0, 1, 0, 0, 0, 18, '生成条码时区分申请科室', '0', '0', '控制采集工作站在生成条码时是否根据不同申请科室生成不同条码,勾选此参数,会将申请科室作为条码的生成规则之一',
         '1-区分申请科室;0-不区分申请科室,缺省为0', Null, '适用于标本采集工作站勾选多个医嘱同时生成条码', Null
  From Dual;

--96362:胡俊勇,2017-06-20,本科执行自动完成医嘱类别，参数修改
Declare
  v_Val        Varchar2(80);
  v_Tmp        Varchar2(80);
  v_Par        Varchar2(80);
  v_参数值含义 Varchar2(3000);
Begin
  Select Nvl(参数值, '*'), 参数值含义
  Into v_Tmp, v_参数值含义
  From zlParameters
  Where 模块 = 1254 And 参数名 = '本科执行自动完成医嘱类别' And 系统 = &n_System;
  --防止参数值被重复更新
  If Instr(v_参数值含义 || ',', '8-其它医嘱') = 0 Then
    If v_Tmp <> '*' Then
      v_Tmp := v_Tmp || ',';
      While v_Tmp Is Not Null Loop
        v_Val := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
        v_Tmp := Substr(v_Tmp, Instr(v_Tmp, ',') + 1);
        If v_Val = '4' Then
          v_Par := v_Par || ',4,5,6';
        Elsif v_Val = '5' Then
          v_Par := v_Par || ',7';
        Elsif v_Val = '6' Then
          v_Par := v_Par || ',8';
        Else
          v_Par := v_Par || ',' || v_Val;
        End If;
      End Loop;
      v_Par := Substr(v_Par, 2);
    Else
      v_Par := v_Tmp;
    End If;
    Update zlParameters
    Set 参数值 = v_Par, 参数值含义 = '数字方式逗号分割一个数字表示一种类别:0-输液,1-注射,2-口服,3-采集,4-过敏试验,5-普通治疗,6-特殊治疗,7-其它给药途径,8-其它医嘱。* 表示所有',
        适用说明 = '控制住院医嘱发送，有关联参数"本科执行自动完成"'
    Where 模块 = 1254 And 参数名 = '本科执行自动完成医嘱类别' And 系统 = &n_System;
  End If;
End;
/
--95606:胡俊勇,2017-06-20,参数拆分
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1252, 0, 0, 0, 0, 0, 0, 63, '自动增加皮试医嘱', '0', '0',
         '医嘱下达时，对需要做皮试（过敏试验）的药品，如果在过敏有效天数内没有过敏记录，则根据本参数来决定是否自动增加皮试医嘱(如果存在有效天数之内的相同皮试医嘱，则不会重复添加)。医技站下药品医嘱，不会自动添加皮试，仅提示。', 
         '0-不启用;1-启用', '如果参数"过敏登记有效天数"为零，则不会检查及自动增加皮试项目。要设置药品对应用法用量中的皮试项目，药品品种的皮试属性不影响医嘱的下达。', 
         '主要是为了在医生下达需要皮试的药品医嘱时，自动产生皮试医嘱，减少医生开医嘱的工作量,但有的医院人为，医生在下达医嘱前，先下达皮试医嘱属于医生的工作职责范围，也是一种良好的医疗思维习惯，所以有了不同的两种处理方式',NULL
  From Dual;

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1252, 0, 0, 0, 0, 0, 0, 64, '医嘱发送皮试限制', '0', '0',
         '启用该项控制后,医嘱发送时，如果存在皮试结果为阳性或皮试还没有出结果的情况（不含作废或标记为免试的皮试医嘱），则以这些皮试项目（药品的用法用量中设置的过敏试验项目）为过敏试验的药品医嘱（包括一并给药的其他药品），均不发送。医技站发送时未限制。', 
         '0-不启用;1-启用', '要设置药品对应用法用量中的皮试项目，药品品种的皮试属性不影响医嘱的发送。', 
         '用于限制医嘱发送因为实际应用中的药品是必须用皮试结果来决定是否可以用药。',NULL
  From Dual;

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1253, 0, 0, 0, 0, 0, 0, 64, '自动增加皮试医嘱', '0', '0',
         '医嘱下达时，对需要做皮试（过敏试验）的药品，如果在过敏有效天数内没有过敏记录，则根据本参数来决定是否自动增加皮试医嘱(如果存在有效天数之内的相同皮试医嘱，则不会重复添加)。医技站下药品医嘱，不会自动添加皮试，仅提示。', 
         '0-不启用;1-启用', '如果参数"过敏登记有效天数"为零，则不会检查及自动增加皮试项目。要设置药品对应用法用量中的皮试项目，药品品种的皮试属性不影响医嘱的下达。', 
         '主要是为了在医生下达需要皮试的药品医嘱时，自动产生皮试医嘱，减少医生开医嘱的工作量,但有的医院人为，医生在下达医嘱前，先下达皮试医嘱属于医生的工作职责范围，也是一种良好的医疗思维习惯，所以有了不同的两种处理方式',NULL
  From Dual;

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1253, 0, 0, 0, 0, 0, 0, 65, '医嘱发送皮试限制', '0', '0',
         '启用该项控制后,医嘱发送时，如果存在皮试结果为阳性或皮试还没有出结果的情况（不含作废或标记为免试的皮试医嘱），则以这些皮试项目（药品的用法用量中设置的过敏试验项目）为过敏试验的药品医嘱（包括一并给药的其他药品），均不发送。医技站发送时未限制。', 
         '0-不启用;1-启用', '要设置药品对应用法用量中的皮试项目，药品品种的皮试属性不影响医嘱的发送。关联参数"根据皮试结果限制医嘱发送类型"也会影响医嘱发送。', 
         '用于限制医嘱发送因为实际应用中的药品是必须用皮试结果来决定是否可以用药。',NULL
  From Dual;

Update Zlparameters
Set 参数值 =
     (Select 参数值 From Zlparameters Where 系统 = &n_System And 模块 = 1252 And 参数名='自动处理皮试')
Where 系统 = &n_System And 模块 =1252 And 参数名 In ('自动增加皮试医嘱','医嘱发送皮试限制');

Update Zlparameters
Set 参数值 =
     (Select 参数值 From Zlparameters Where 系统 = &n_System And 模块 = 1253 And 参数名='自动处理皮试')
Where 系统 = &n_System And 模块 =1253 And 参数名 In ('自动增加皮试医嘱','医嘱发送皮试限制');

delete from Zlparameters where 系统=&n_System and nvl(模块,0) in (1252,1253)  And 参数名='自动处理皮试';

--110222:张德婷,2017-06-15,将参数特殊性质药品允许发送到配制中心拆分为3个独立参数
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1345, 0, 0, 0, 0, 0, 0, 39, '自备药允许发往静配中心', '0', '0', '自备药是否发往静配中心。',
         '1-允许;0-不允许,缺省为0', Null, '自备药需要发往静配中心的场合', Null
  From Dual;

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1345, 0, 0, 0, 0, 0, 0, 40, '不取药允许发往静配中心', '0', '0', '不取药是否发往静配中心。',
         '1-允许;0-不允许,缺省为0', Null, '不取药需要发往静配中心的场合', Null
  From Dual;

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1345, 0, 0, 0, 0, 0, 0, 41, '离院带药允许发往静配中心', '0', '0', '离院带药是否发往静配中心。',
         '1-允许;0-不允许,缺省为0', Null, '离院带药需要发往静配中心的场合', Null
  From Dual;

Update Zlparameters
Set 参数值 =
     (Select 参数值 From Zlparameters Where 系统 = &n_System And 模块 = 1345 And 参数名 = '特殊性质药品允许发送到配制中心')
Where 系统 = &n_System And 模块 =1345 And 参数名 In ('自备药允许发往静配中心', '不取药允许发往静配中心', '离院带药允许发往静配中心');

delete from Zlparameters where 系统=&n_System and 模块=1345 and 参数名='特殊性质药品允许发送到配制中心';

--109584:李南春,2017-06-13,自助挂号流程是否选择号类
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1802, 0, 0, 0, 0, 0, 0, 46, '挂号选择号类', '1','1', 
         '自助挂号管理中，是否需要对挂号类别进行分类选择。如果不分类选择，则在挂号列表中将支持满足条件的所有号别显示出来', '0-不分类选择；1-分类选择。', Null, '如果同科室的号别分类不多，可以取消分类选择，减少病人的操作步骤。', Null
  From Dual;

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1803, 0, 0, 0, 0, 0, 0, 46, '预约选择号类', '1','1', 
         '自助预约管理中，是否需要对挂号类别进行分类选择。如果不分类选择，则在挂号列表中将支持满足条件的所有号别显示出来', '0-不分类选择；1-分类选择。', Null, '如果同科室的号别分类不多，可以取消分类选择，减少病人的操作步骤。', Null
  From Dual;
--97835:张德婷,2017-06-07,修正退药单据自动默认为发药状态的问题
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1342, 0, 0, 0, 0, 0, 0, 28, '退药待发单据默认为发药状态', '0', '0', '退药待发单据默认为发药状态',
         '1-是;0-不是', Null, '退药待发单据需要默认为发药状态', Null
  From Dual;

--109923:董露露,2017-06-07,解决临床路径表单双审核的问题，添加一个‘双审核模式‘参数
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1078, 0, 0, 0, 0, 0, 0, 1, '双审核模式', '0', '0',
         '当该参数启用之后，新增了一个临床路径表单后，需要药剂科对路径表单进行初次审核，初次审核时科室不可使用该路径。然后医务科再在药剂科审核后的基础上完成二次审核，医务科审核完成后科室才能使用该路径。', '0-不启用，1-启用',
         Null, '该参数用于医院对临床路径表单管理需要药剂科审核后，医务科进行二次审核后才能使用该临床路径的情况', Null
  From Dual;

--109906:梁唐彬,2017-06-06,病人自动计算预出院报错
Declare
  n_当前id Number(18);
Begin
  Select 病人自动计算_Id.Nextval Into n_当前id From Dual;
  For c_Tmp In (Select ID From 病人自动计算 Where ID > n_当前id Order By ID) Loop
    Update 病人自动计算 Set ID = 病人自动计算_Id.Nextval Where ID = c_Tmp.Id;
  End Loop;
End;
/
--93077:董露露,2017-06-05,病人入院管理，添加控制科室下无空床不能登记的参数
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1131, 0, 0, 0, 0, 0, 0, 57, '科室下无空床不能登记', '0', '0',
         '控制病人入院登记时，如果入院科室下没有空床是否允许登记。   勾选：如果该科室和对应病区的病区下没有空床时，不能够登记。  取消勾选：如果入院科室下没有空床，允许登记。', '1 - 不允许，0 - 允许', Null,
         '适用于医院对病人入院登记时入院科室下无床位情况的控制', Null
  From Dual;

--108214:李南春,2017-05-31,自助身份证识别支持键盘录入
Update zluserParas Set 参数值 = Substr(参数值,1,Instr(参数值,'||2,')+4) || ',1' || Substr(Substr(参数值,Instr(参数值,'||2,')),Instr(Substr(参数值,Instr(参数值,'||2,')),'||',2)) 
where 参数ID in (Select ID from zlparameters Where 参数名 = '身份识别设置');

Update 医疗卡类别  Set 读卡性质 = substr(读卡性质,1,2) || '01' where 是否固定 = 1 And 名称 Like '%身份证%';

--109187:廖思奇,2017-05-26,增加病理站 录入外院信息 参数
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1294, 0, 0, 0, 1, 0, 0, 113, '录入外院信息', '0', '0',
         '病理工作站登记时是否显示送检信息录入框', '1-显示，0-不显示', Null, '少数需要录入特定信息的情况，比如外院条码信息', Null
  From Dual;

--106321:刘尔旋,2017-05-26,删除新版本中不使用的过程权限
Delete From zlProgPrivs Where Upper(对象) = Upper('zl_结帐预交记录_三方退款');

--107646:刘尔旋,2017-05-24,自动记帐费用记帐模式
Update zlParameters
Set 影响控制说明 = '如果启用了此参数，则在自动计算费用时以半天为计算单位,上午入院算1天,下午算半天,上午出院当天不算费用,下午算半天。',
    参数值含义 = '格式: 三位二进制数表示或一位二进制表示' || Chr(13) || '只有一位时，表示床位、护理或其他费用统一一起控制，有三位时，第一位为床位;第二位为护理;第三位为其他费用' || Chr(13) ||
             ' 每位用0或1表示,0表示不按半天模式;1表示按半天模式。', 适用说明 = '适用于按不同类型(床位，护理或其他费用)来采用不同的半天模式的用户。'
Where 参数名 = '下午算半天模式' And 模块 Is Null And 系统 = &n_System;

Insert Into zlParameters(ID,系统,模块,私有,本机,授权,固定,部门,性质,参数号,参数名,参数值,缺省值,影响控制说明,参数值含义,关联说明,适用说明,警告说明)
Select zlParameters_ID.Nextval,&n_System,-Null,-Null,-Null,-Null,-Null,A.* From (
Select 部门,性质,参数号,参数名,参数值,缺省值,影响控制说明,参数值含义,关联说明,适用说明,警告说明 From zlParameters Where 1 = 0 Union All 
Select 0,0,278,'自动记帐费用记帐模式',Null,'0','主要是临时控制自动记帐时是采用何种记帐模式,目前模式分三种:一种是标准记帐模式;二种是适用内蒙片区记帐模式;三种是标准记帐模式(临时)','0-标准记帐模式;1-适用内蒙片区记帐模式;2-三种是标准记帐模式(临时),主要是根据病人自动计算表来计算',Null,
  '适用于某些用户需要采用不同的记帐模式，对于第三种标准记帐模式(临时):目前只适用于试点用户，需重点监控每天自动计记帐的费用是否正确，试点完后，再根据情况来调整。','警告:第三种标准记帐模式(临时)只针对的是试点用户，不是试点用户，禁止将参数设置为第三种标准记帐模式(临时)。' From Dual  UNION all  
Select 部门,性质,参数号,参数名,参数值,缺省值,影响控制说明,参数值含义,关联说明,适用说明,警告说明 From zlParameters Where 1 = 0) A;


--99878:冉俊明,2017-05-24,同一收费项目多个价格管理
Insert Into zlPrograms(序号, 标题, 说明, 系统, 部件)
Values(1015, '价格等级管理', '主要实现针对收费项目的价格等级的增删改维护以及对应价格等级对照的相关操作。', &n_System, 'zl9BaseItem');

Insert Into zlMenus(组别, ID, 上级id, 标题, 快键, 说明, 系统, 模块, 短标题, 图标)
Select a.组别, Zlmenus_Id.Nextval, a.Id, b.*
From (Select 组别, ID From zlMenus Where 标题 = '费用基础项目' And 组别 = '缺省' And 系统 = &n_System And 模块 Is Null) A,
     (Select 标题, 快键, 说明, 系统, 模块, 短标题, 图标 From zlMenus Where 1 = 0 Union All
       Select '价格等级管理', 'J', '主要实现针对收费项目的价格等级的增删改维护以及对应价格等级对照的相关操作。', &n_System, 1015, '价格等级', 101 From Dual Union All
       Select 标题, 快键, 说明, 系统, 模块, 短标题, 图标 From zlMenus Where 1 = 0) B;

--109289:冉俊明,2017-05-23,使用“全部启用序号控制”功能时，对于启用序号但没有启用分时段的安排，没有生成对应的时段序号数据
--基础数据，临床出诊安排，数据量不会太大
Begin
  --1.规则数据
  --不分时段的序号控制号先生成序号,开始时间、终止时间填写时间段的开始时间和结束时间
  For c_安排 In (Select a.Id, b.号类, Nvl(c.站点, '-') As 站点
               From 临床出诊安排 A, 临床出诊号源 B, 部门表 C, 临床出诊表 D
               Where a.号源id = b.Id And b.科室id = c.Id And a.出诊id = d.Id And Nvl(d.排班方式, 0) In (0, 3)) Loop
  
    For c_记录 In (With c_时间段 As
                    (Select 时间段, 开始时间, 终止时间
                    From (Select 时间段,
                                  To_Date('3000-01-01' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                  To_Date('3000-01-01' || To_Char(终止时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 终止时间,
                                  Row_Number() Over(Partition By 时间段 Order By 时间段, 站点 Asc, 号类 Asc) As 组号
                           From 时间段
                           Where Nvl(站点, c_安排.站点) = c_安排.站点 And Nvl(号类, c_安排.号类) = c_安排.号类)
                    Where 组号 = 1)
                   Select a.Id, a.限号数,
                          To_Date(To_Char(Sysdate, 'yyyy-mm-dd ') || To_Char(b.开始时间, 'hh24:mi:ss'),
                                   'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                          To_Date(To_Char(Sysdate, 'yyyy-mm-dd ') || To_Char(b.终止时间, 'hh24:mi:ss'),
                                  'yyyy-mm-dd hh24:mi:ss') + Case
                            When b.终止时间 <= b.开始时间 Then
                             1
                            Else
                             0
                          End As 终止时间
                   From 临床出诊限制 A, c_时间段 B
                   Where a.上班时段 = b.时间段 And a.安排id = c_安排.Id And Nvl(a.限号数, 0) <> 0 And Nvl(a.是否序号控制, 0) = 1 And
                         Nvl(a.是否分时段, 0) = 0 And Not Exists (Select 1 From 临床出诊时段 Where 限制id = a.Id)) Loop
    
      For I In 1 .. c_记录.限号数 Loop
        Insert Into 临床出诊时段
          (限制id, 序号, 开始时间, 终止时间, 限制数量, 是否预约)
        Values
          (c_记录.Id, I, c_记录.开始时间, c_记录.终止时间, 1, 1);
      End Loop;
    End Loop;
  End Loop;

  --2.记录数据
  --不分时段的序号控制号先生成序号,开始时间、终止时间填写时间段的开始时间和结束时间
  For c_记录 In (Select a.Id, a.限号数, a.开始时间, a.终止时间
               From 临床出诊记录 A
               Where a.出诊日期 > Trunc(Sysdate) And Nvl(a.已挂数, 0) = 0 And Nvl(a.已约数, 0) = 0 And Nvl(a.限号数, 0) <> 0 And
                     Nvl(a.是否序号控制, 0) = 1 And Nvl(a.是否分时段, 0) = 0 And Not Exists
                (Select 1 From 临床出诊序号控制 Where 记录id = a.Id)) Loop
  
    For I In 1 .. c_记录.限号数 Loop
      Insert Into 临床出诊序号控制
        (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约)
      Values
        (c_记录.Id, I, c_记录.开始时间, c_记录.终止时间, 1, 1);
    End Loop;
  End Loop;
End;
/

--108348:刘尔旋,2017-05-19,挂号缴款输入控制
Update zlParameters
Set 参数名 = '挂号缴款输入控制', 影响控制说明 = '挂号时输入缴款金额的控制，分为不控制；必须输入缴款金额；与输入缴款金额后才结束本次挂号三种控制模式。否则保留病人信息和应缴金额合计(医保和不要求输姓名时除外)',
    参数值含义 = '0-不控制，1-输入缴款金额后才结束本次挂号，否则保留病人信息和应缴金额合计(医保和不要求输姓名时除外)，2-必须输入缴款金额', 适用说明 = '根据医院的需要控制挂号时的缴款方式'
Where 参数名 = '缴款挂号结束' And 模块 = 1111 And 系统 = &n_System;

--94432:胡俊勇,2017-05-16,界面个性化参数
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1261, 1, 1, 0, 1, 0, 1, 53, '会诊病人过滤', Null, '011',
         '住院医工作站会诊病人列表过滤条件个性化记录参数', '对应界面上的CheckBox控件,按位表示：0-不勾选,1-勾先;第1位-包含出院病人,第2位-未会诊,第3位-已会诊', Null, '窗体控件状态参数', Null
  From Dual;

--108210:李南春,2017-05-12,自助签约模式调整
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明,参数值含义,关联说明,适用说明,警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1802, 0, 0, 0, 0, 0, 0, 45, '签约模式', '0', '0',
         '针对自助挂号时，新卡进行签约的操作流程控制。','0-完整模式：需要由用户设置联系电话以及密码等操作，完善签约信息;' || chr(13) || '1-简略模式：不需要用户做任何设置，隐形完成签约过程，但账户风险会提高。',
         '当医院支持医疗卡自动签约时，此参数有效','如果医院不使用预交款，只见医疗卡作为身份识别使用，可以采用简略模式加快自助操作流程',NULL
  From Dual;

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明,参数值含义,关联说明,适用说明,警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1803, 0, 0, 0, 0, 0, 0, 45, '签约模式', '0', '0',
         '针对自助预约时，新卡进行签约的操作流程控制。','0-完整模式：需要由用户设置联系电话以及密码等操作，完善签约信息;' || chr(13) || '1-简略模式：不需要用户做任何设置，隐形完成签约过程，但账户风险会提高。',
         '当医院支持医疗卡自动签约时，此参数有效','如果医院不使用预交款，只见医疗卡作为身份识别使用，可以采用简略模式加快自助操作流程',NULL
  From Dual;

--108423:李小东,2017-05-11,检验标本登记，紧急标本提示
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1212, 0, 1, 0, 0, 0, 0, 6, '紧急标本提示', '0', '0', '是否提示登记的标本为紧急标本',
         '0-不提示;1-提示', Null, '检验标本登记，提示登记标本为紧急标本', Null
  From Dual;

--108685:余伟节,2017-07-04,检验报告打印
Insert Into zlParameters(ID,系统,模块,私有,本机,授权,固定,部门,性质,参数号,参数名,参数值,缺省值,影响控制说明,参数值含义,关联说明,适用说明,警告说明)
Select zlparameters_id.nextval,&n_System,1566,A.* From (
Select 私有,本机,授权,固定,部门,性质,参数号,参数名,参数值,缺省值,影响控制说明,参数值含义,关联说明,适用说明,警告说明 From zlParameters Where 1 = 0 Union All 
Select 0,0,0,0,0,0,3,'检验报告打印','0','0','控制检验报告按指定方式输出','0-按老版LIS或病历方式输出;1-按新版LIS报表方式输出',Null,'适用于安装了新版LIS系统,允许选择新版LIS报表打印',Null From Dual Union All  
Select 私有,本机,授权,固定,部门,性质,参数号,参数名,参数值,缺省值,影响控制说明,参数值含义,关联说明,适用说明,警告说明 From zlParameters Where 1 = 0) A;

--110594:余伟节,2017-06-27,病案主页新增入科时间
Begin
  For r_Info In (Select a.病人id, a.主页id, Max(b.开始时间) As 入科时间
                 From 在院病人 A, 病人变动记录 B
                 Where a.病人id = b.病人id And a.主页id = b.主页id And b.开始原因 In (1, 2)
                 Group By a.病人id, a.主页id) Loop
    Update 病案主页 Set 入科时间 = r_Info.入科时间 Where 病人id = r_Info.病人id And 主页id = r_Info.主页id;
  End Loop;
End;
/

-------------------------------------------------------------------------------
--权限修正部份
-------------------------------------------------------------------------------

--111205:刘硕,2017-07-06,部件清单重新整理
Update ZLTOOLS.zlPrograms Set 部件 = Null Where 系统 = &n_System And 序号 = 9010;
--107171:张德婷,2017-07-06,静配中心新增排班功能
Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select &n_System, 1345, '排班设置', 21, '排班设置的操作权限。有该权限时，可以进行排班设置相关操作', 0
  From Dual;

Insert Into Zlprogprivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1345, '排班设置', User, 'Zl_配液台_设置', 'EXECUTE'
  From Dual;

Insert Into Zlprogprivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1345, '排班设置', User, 'Zl_配液台_删除', 'EXECUTE'
  From Dual;

Insert Into Zlprogprivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1345, '排班设置', User, 'Zl_配液台药品对照_设置', 'EXECUTE'
  From Dual;

Insert Into Zlprogprivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1345, '排班设置', User, 'Zl_配液台药品对照_删除', 'EXECUTE'
  From Dual;

Insert Into Zlprogprivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1345, '排班设置', User, 'Zl_配液工作安排_设置', 'EXECUTE'
  From Dual;

Insert Into Zlprogprivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1345, '基本', User, '配液台', 'SELECT'
  From Dual;

Insert Into Zlprogprivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1345, '基本', User, '配液台药品对照', 'SELECT'
  From Dual;

Insert Into Zlprogprivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1345, '基本', User, '配液工作安排', 'SELECT'
  From Dual;

--101340:刘涛,2017-07-03,药品卫材价格等级
  Insert Into Zlprogprivs
    (系统, 序号, 功能, 所有者, 对象, 权限)
    Select &n_System, 1023, '基本', User, '收费价格等级应用', 'SELECT'
    From Dual
    Union All
    Select &n_System, 1023, '基本', User, '收费价格等级', 'SELECT'
    From Dual;

  Insert Into Zlprogprivs
    (系统, 序号, 功能, 所有者, 对象, 权限)
    Select &n_System, 1300, '基本', User, '收费价格等级应用', 'SELECT'
    From Dual
    Union All
    Select &n_System, 1300, '基本', User, '收费价格等级', 'SELECT'
    From Dual;

  Insert Into Zlprogprivs
    (系统, 序号, 功能, 所有者, 对象, 权限)
    Select &n_System, 1301, '基本', User, '收费价格等级应用', 'SELECT'
    From Dual
    Union All
    Select &n_System, 1301, '基本', User, '收费价格等级', 'SELECT'
    From Dual;

  Insert Into Zlprogprivs
    (系统, 序号, 功能, 所有者, 对象, 权限)
    Select &n_System, 1302, '基本', User, '收费价格等级应用', 'SELECT'
    From Dual
    Union All
    Select &n_System, 1302, '基本', User, '收费价格等级', 'SELECT'
    From Dual;

  Insert Into Zlprogprivs
    (系统, 序号, 功能, 所有者, 对象, 权限)
    Select &n_System, 1304, '基本', User, '收费价格等级应用', 'SELECT'
    From Dual
    Union All
    Select &n_System, 1304, '基本', User, '收费价格等级', 'SELECT'
    From Dual;

  Insert Into Zlprogprivs
    (系统, 序号, 功能, 所有者, 对象, 权限)
    Select &n_System, 1305, '基本', User, '收费价格等级应用', 'SELECT'
    From Dual
    Union All
    Select &n_System, 1305, '基本', User, '收费价格等级', 'SELECT'
    From Dual;

  Insert Into Zlprogprivs
    (系统, 序号, 功能, 所有者, 对象, 权限)
    Select &n_System, 1306, '基本', User, '收费价格等级应用', 'SELECT'
    From Dual
    Union All
    Select &n_System, 1306, '基本', User, '收费价格等级', 'SELECT'
    From Dual;

  Insert Into Zlprogprivs
    (系统, 序号, 功能, 所有者, 对象, 权限)
    Select &n_System, 1307, '基本', User, '收费价格等级应用', 'SELECT'
    From Dual
    Union All
    Select &n_System, 1307, '基本', User, '收费价格等级', 'SELECT'
    From Dual;

  Insert Into Zlprogprivs
    (系统, 序号, 功能, 所有者, 对象, 权限)
    Select &n_System, 1309, '基本', User, '收费价格等级应用', 'SELECT'
    From Dual
    Union All
    Select &n_System, 1309, '基本', User, '收费价格等级', 'SELECT'
    From Dual;

  Insert Into Zlprogprivs
    (系统, 序号, 功能, 所有者, 对象, 权限)
    Select &n_System, 1330, '基本', User, '收费价格等级应用', 'SELECT'
    From Dual
    Union All
    Select &n_System, 1330, '基本', User, '收费价格等级', 'SELECT'
    From Dual;

  Insert Into Zlprogprivs
    (系统, 序号, 功能, 所有者, 对象, 权限)
    Select &n_System, 1333, '基本', User, '收费价格等级应用', 'SELECT'
    From Dual
    Union All
    Select &n_System, 1333, '基本', User, '收费价格等级', 'SELECT'
    From Dual;

   Insert Into Zlprogprivs
    (系统, 序号, 功能, 所有者, 对象, 权限)
    Select &n_System, 1343, '基本', User, '收费价格等级应用', 'SELECT'
    From Dual
    Union All
    Select &n_System, 1343, '基本', User, '收费价格等级', 'SELECT'
    From Dual;

   Insert Into Zlprogprivs
    (系统, 序号, 功能, 所有者, 对象, 权限)
    Select &n_System, 1344, '基本', User, '收费价格等级应用', 'SELECT'
    From Dual
    Union All
    Select &n_System, 1344, '基本', User, '收费价格等级', 'SELECT'
    From Dual;

   Insert Into Zlprogprivs
    (系统, 序号, 功能, 所有者, 对象, 权限)
    Select &n_System, 1711, '基本', User, '收费价格等级应用', 'SELECT'
    From Dual
    Union All
    Select &n_System, 1711, '基本', User, '收费价格等级', 'SELECT'
    From Dual;

   Insert Into Zlprogprivs
    (系统, 序号, 功能, 所有者, 对象, 权限)
    Select &n_System, 1712, '基本', User, '收费价格等级应用', 'SELECT'
    From Dual
    Union All
    Select &n_System, 1712, '基本', User, '收费价格等级', 'SELECT'
    From Dual;

   Insert Into Zlprogprivs
    (系统, 序号, 功能, 所有者, 对象, 权限)
    Select &n_System, 1713, '基本', User, '收费价格等级应用', 'SELECT'
    From Dual
    Union All
    Select &n_System, 1713, '基本', User, '收费价格等级', 'SELECT'
    From Dual;

   Insert Into Zlprogprivs
    (系统, 序号, 功能, 所有者, 对象, 权限)
    Select &n_System, 1716, '基本', User, '收费价格等级应用', 'SELECT'
    From Dual
    Union All
    Select &n_System, 1716, '基本', User, '收费价格等级', 'SELECT'
    From Dual;

   Insert Into Zlprogprivs
    (系统, 序号, 功能, 所有者, 对象, 权限)
    Select &n_System, 1717, '基本', User, '收费价格等级应用', 'SELECT'
    From Dual
    Union All
    Select &n_System, 1717, '基本', User, '收费价格等级', 'SELECT'
    From Dual;

   Insert Into Zlprogprivs
    (系统, 序号, 功能, 所有者, 对象, 权限)
    Select &n_System, 1718, '基本', User, '收费价格等级应用', 'SELECT'
    From Dual
    Union All
    Select &n_System, 1718, '基本', User, '收费价格等级', 'SELECT'
    From Dual;

   Insert Into Zlprogprivs
    (系统, 序号, 功能, 所有者, 对象, 权限)
    Select &n_System, 1719, '基本', User, '收费价格等级应用', 'SELECT'
    From Dual
    Union All
    Select &n_System, 1719, '基本', User, '收费价格等级', 'SELECT'
    From Dual;

   Insert Into Zlprogprivs
    (系统, 序号, 功能, 所有者, 对象, 权限)
    Select &n_System, 1721, '基本', User, '收费价格等级应用', 'SELECT'
    From Dual
    Union All
    Select &n_System, 1721, '基本', User, '收费价格等级', 'SELECT'
    From Dual;

   Insert Into Zlprogprivs
    (系统, 序号, 功能, 所有者, 对象, 权限)
    Select &n_System, 1722, '基本', User, '收费价格等级应用', 'SELECT'
    From Dual
    Union All
    Select &n_System, 1722, '基本', User, '收费价格等级', 'SELECT'
    From Dual;

   Insert Into Zlprogprivs
    (系统, 序号, 功能, 所有者, 对象, 权限)
    Select &n_System, 1726, '基本', User, '收费价格等级应用', 'SELECT'
    From Dual
    Union All
    Select &n_System, 1726, '基本', User, '收费价格等级', 'SELECT'
    From Dual;

--105570:冉俊明,2017-07-03,转病区费用
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 9000, '基本', User, 'Zl_医嘱执行计价_修正', 'EXECUTE'
  From Dual;

--105570:冉俊明,2017-07-03,转病区费用
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 9000, '基本', User, '费用变动记录', 'SELECT'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 9000, '基本', User, 'Zl_Turntoward_Fee', 'EXECUTE'
  From Dual;

--110956:刘兴洪,2017-07-03,诊疗项目上管理中针对价格等级的处理
Insert Into zlProgPrivs(系统, 序号, 功能, 所有者, 对象, 权限)
Select &n_System, 1054, '基本', User, a.* From (
Select 对象, 权限 From zlProgPrivs Where 1 = 0 Union All
 Select '收费价格等级', 'SELECT' From Dual Union All
 Select '收费价格等级应用', 'SELECT' From Dual Union All
Select 对象, 权限 From zlProgPrivs Where 1 = 0) A;

--104662:蒋廷中,2017-06-30,增加医生授权管理的权限模块
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,1082,A.* From (
  Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
  Select '基本',1,'基本权限。',1 From Dual Union All
  Select '所有部门',2,'可以对所有部门下的医生进行授权。',0 From Dual Union All
  Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A
Where Not Exists (Select 1 From Zlprogfuncs Where 系统 = &n_System And 序号 = 1082);


Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1082,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
Select 'Zl_医生权限_UPDATE','EXECUTE' From Dual Union All
Select '部门性质说明','SELECT' From Dual Union All
Select '部门人员','SELECT' From Dual Union All
Select '病区科室对应','SELECT' From Dual Union All
Select '人员抗菌药物权限','SELECT' From Dual Union All
Select '人员性质说明','SELECT' From Dual Union All
Select '人员照片','SELECT' From Dual Union All
Select '专业技术职务','SELECT' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A
Where Not Exists (Select 1 From zlProgPrivs Where 系统 = &n_System And 序号 = 1082);

--104662:蒋廷中,2017-06-30,删除原有毒麻贵重精神的历史授权数据和权限模块
Delete From zlRoleGrant b Where b.功能 = '下达毒性药嘱' Or b.功能 = '下达麻醉药嘱' Or b.功能 = '下达精神药嘱' Or b.功能 = '下达贵重药嘱';
Delete From zlProgFuncs b Where b.功能 = '下达毒性药嘱' Or b.功能 = '下达麻醉药嘱' Or b.功能 = '下达精神药嘱' Or b.功能 = '下达贵重药嘱';


--108933:殷瑞,2017-06-30,药品领用模块新增申请冲销、审核冲销功能
Insert Into Zlprogfuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select &n_System, 1305, '冲销申请',13, '有该权限时，允许对已审核的药品领用单据进行冲销申请', 1
  From Dual;

Insert Into Zlprogfuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select &n_System, 1305, '冲销审核', 14, '有该权限时，允许对未审核的冲销单据进行冲销审核', 1
  From Dual;

--92335:李南春,2017-06-22,三方支付新模式及过程拆分
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1801, '基本', User, 'zl_人员缴款余额_Update', 'EXECUTE'
  From Dual;
         
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1802, '基本', User, 'zl_人员缴款余额_Update', 'EXECUTE'
  From Dual;
        
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1803, '基本', User, 'zl_人员缴款余额_Update', 'EXECUTE'
  From Dual;
         
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1804, '基本', User, 'zl_人员缴款余额_Update', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1805, '基本', User, 'zl_人员缴款余额_Update', 'EXECUTE'
  From Dual;

--106374:余伟节,2017-06-22,疾病编码分类、疾病编码目录更新
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1013,'增删改',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
Select 'Zl_疾病编码目录_Redo','EXECUTE' From Dual Union All
Select 'Zl_疾病编码分类_Stop','EXECUTE' From Dual Union All
Select 'Zl_疾病编码分类_Reuse','EXECUTE' From Dual Union All
Select '疾病编码分类','UPDATE' From Dual Union All 
Select '疾病编码目录','UPDATE' From Dual Union All 
Select '疾病编码分类','INSERT' From Dual Union All 
Select '疾病编码目录','INSERT' From Dual Union All
Select '疾病编码分类_ID','ALTER' From Dual Union All 
Select '疾病编码目录_ID','ALTER' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--109617:刘尔旋,2017-06-19,医生站地址控件结构化
Insert Into zlProgPrivs(系统, 序号, 功能, 所有者, 对象, 权限)
Select &n_System, 9000, '基本', User, a.* From (
Select 对象, 权限 From zlProgPrivs Where 1 = 0 Union All
 Select 'zl_病人地址信息_Update', 'EXECUTE' From Dual Union All
Select 对象, 权限 From zlProgPrivs Where 1 = 0) A;

--94711:蒋廷中,2017-06-13,增加修改手术等级权限控制医生是否可以修改手术等级
Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select &n_System, 1261, '修改手术等级', 16, '有该权限时，可以在住院首页修改已绑定手术等级的手术记录的手术等级',1
  From Dual;

--99878:梁唐彬,2017-06-13,同一收费项目多个价格管理
Insert Into zlProgPrivs(系统, 序号, 功能, 所有者, 对象, 权限)
Select &n_System, 9001, '基本', User, a.* From (
Select 对象, 权限 From zlProgPrivs Where 1 = 0 Union All
 Select '收费价格等级', 'SELECT' From Dual Union All
 Select '收费价格等级应用', 'SELECT' From Dual Union All
 Select 'Zl_Get_Pricegrade', 'EXECUTE' From Dual Union All
Select 对象, 权限 From zlProgPrivs Where 1 = 0) A;

--103996:黄捷,2017-06-12,报告图增加标记
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1290,'基本',User,A.* From (
	Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
	Select 'Zl_影像检查图象_报告图','EXECUTE' From Dual Union All
	Select 'Zl_影像检查_设置报告图','EXECUTE' From Dual Union All 
	Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--103996:黄捷,2017-06-12,报告图增加标记
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1291,'基本',User,A.* From (
	Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
	Select 'Zl_影像检查图象_报告图','EXECUTE' From Dual Union All
	Select 'Zl_影像检查_设置报告图','EXECUTE' From Dual Union All 
	Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--103996:黄捷,2017-06-12,报告图增加标记
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1294,'基本',User,A.* From (
	Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
	Select 'Zl_影像检查图象_报告图','EXECUTE' From Dual Union All
	Select 'Zl_影像检查_设置报告图','EXECUTE' From Dual Union All 
	Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--107951:张德婷,2017-06-11,静配中心添加销帐拒绝的权限
Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select &n_System, 1345, '销帐拒绝', 20, '如果有此权限，静配中心销帐时可以进行销帐拒绝操作。', 1
  From Dual;

--109923:董露露,2017-06-07,解决临床路径表单双审核的问题，添加’药剂科审核‘的功能
Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select &n_System, 1078, '药剂科审核', 16, '启用了(启用药剂科、医务科双审核模式)参数后，对制定好的临床路径有初次审核的权限；具有该权限同时可以药剂科取消审核。',0
  From Dual;

--105767:张德婷,2017-06-07,添加权限
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1345, '基本', User, '床位状况记录', 'SELECT'
  From Dual;
  
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1345, '基本', User, '床位编制分类', 'SELECT'
  From Dual;

--109889:张德婷,2017-06-06,删除zl_GetSysParameter的权限
delete from zlProgPrivs where 系统=&n_System and 序号=1345 and 功能='基本' and 对象 = 'zl_GetSysParameter';

--104245:董露露,2017-06-05,病人入院管理和病人信息管理中身份证未录原因从字典表里面读取
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1101, '基本', User, '身份证未录原因', 'SELECT'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1131, '基本', User, '身份证未录原因', 'SELECT'
  From Dual;

--107905:冉俊明,2017-06-05,重新收费他人的异常收费单据，重新结算他人的异常补充结算单据
Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select &n_System, 1121, '重收他人异常单据', 35, '允许针对其他人产生的收费异常单据进行重新收费。', 0
  From Dual;

Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select &n_System, 1124, '重结他人异常单据', 9, '允许针对其他人产生的结算异常单据进行重新结算。', 0
  From Dual;

--109070:张险华,2017-06-02,增加范文审核模块
Insert Into zlPrograms
  (序号, 标题, 说明, 系统, 部件)
  Select 2228 序号, '范文审核' 标题, '用于对范文进行审核操作' As 说明, &n_System 系统, 'zl9EmrInterface' 部件
  From Dual;

Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,2228,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
Select '基本',0,'基本信息',1 From Dual Union All
Select '科内审核',1,'对操作人员所属科室和操作本人私有范文的审核权限',1 From Dual Union All
Select '全院审核',2,'对所有范文的审核权限',0 From Dual Union All
Select '范文修改',3,'对范文标题,名称,说明,所属原型,适用范文的修改权限',0 From Dual Union All
Select '内容编辑',4,'对范文内容进行修改的权限',0 From Dual) A
Where Not Exists (Select 1 From zlProgFuncs Where 序号 = 2228 And 功能='基本');

Insert Into zlMenus(组别, ID, 上级id, 标题, 说明, 系统, 模块, 短标题, 图标)
Select A.组别,ZlMenus_ID.Nextval,A.ID,B.* From (
Select 组别,ID From zlMenus Where 标题 = '病历文档基础' And 组别 = '缺省' And 系统 = &n_System And 模块 Is Null) A,
(Select 标题, 说明, 系统, 模块, 短标题, 图标 From zlMenus Where 1=0 Union ALL
Select '范文审核','用于对范文进行审核操作',&n_System,2228,'范文审核',114 From Dual) B
Where Not Exists (Select 1 From zlMenus Where 模块 = 2228 And 标题='范文审核');

--100722:张德婷,2017-06-01,修正窗口改变不能读取数据的问题
Insert Into zlProgPrivs(系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1340, '增删改', User, 'zl_发药窗口_业务调整', 'EXECUTE'
  From Dual;

--106745:刘尔旋,2017-05-31,挂号检查封装
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1115, '预约挂号登记', User, 'Zl_Fun_病人挂号记录_Check', 'EXECUTE'
  From Dual;

--106745:刘尔旋,2017-05-31,挂号检查封装
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 9000, '挂号', User, 'Zl_Fun_病人挂号记录_Check', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 9000, '预约', User, 'Zl_Fun_病人挂号记录_Check', 'EXECUTE'
  From Dual;

--106745:刘尔旋,2017-05-31,挂号封装检查
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1111, '挂收费号', User, 'Zl_Fun_病人挂号记录_Check', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1111, '挂免费号', User, 'Zl_Fun_病人挂号记录_Check', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1111, '预约挂号', User, 'Zl_Fun_病人挂号记录_Check', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1111, '接收预约', User, 'Zl_Fun_病人挂号记录_Check', 'EXECUTE'
  From Dual;

--99878:冉俊明,2017-05-24,同一收费项目多个价格管理
Insert Into zlProgFuncs(系统, 序号, 功能, 排列, 说明, 缺省值)
Select &n_System, 1015, a.* From (
Select 功能, 排列, 说明, 缺省值 From zlProgFuncs Where 1 = 0 Union All
 Select '基本', -null, Null, 1 From Dual Union All
 Select '增删改', 1, '增加、修改、删除收费价格等级的操作权限。有该权限时，允许进行收费价格等级的增加、修改、删除操作。', 1 From Dual Union All
 Select '停用', 2, '停用收费价格等级的操作权限。有该权限时，允许进行停用操作。', 1 From Dual Union All
 Select '启用', 3, '启用已经停用的收费价格等级的操作权限。有该权限时，允许针对已经停用的价格等级进行启用操作。', 1 From Dual Union All
Select 功能, 排列, 说明, 缺省值 From zlProgFuncs Where 1 = 0) A;

Insert Into zlProgPrivs(系统, 序号, 功能, 所有者, 对象, 权限)
Select &n_System, 1015, '基本', User, a.* From (
Select 对象, 权限 From zlProgPrivs Where 1 = 0 Union All
 Select '收费价格等级', 'SELECT' From Dual Union All
 Select '收费价格等级应用', 'SELECT' From Dual Union All
 Select '医疗付款方式', 'SELECT' From Dual Union All
Select 对象, 权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统, 序号, 功能, 所有者, 对象, 权限)
Select &n_System, 1015, '增删改', User, a.* From (
Select 对象, 权限 From zlProgPrivs Where 1 = 0 Union All
 Select 'Zl_收费价格等级_Insert', 'EXECUTE' From Dual Union All
 Select 'Zl_收费价格等级_Update', 'EXECUTE' From Dual Union All
 Select 'Zl_收费价格等级_Delete', 'EXECUTE' From Dual Union All
Select 对象, 权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统, 序号, 功能, 所有者, 对象, 权限)
Select &n_System, 1015, '停用', User, a.* From (
Select 对象, 权限 From zlProgPrivs Where 1 = 0 Union All
 Select 'Zl_收费价格等级_Stop', 'EXECUTE' From Dual Union All
Select 对象, 权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统, 序号, 功能, 所有者, 对象, 权限)
Select &n_System, 1015, '启用', User, a.* From (
Select 对象, 权限 From zlProgPrivs Where 1 = 0 Union All
 Select 'Zl_收费价格等级_Start', 'EXECUTE' From Dual Union All
Select 对象, 权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select &n_System, 1009, '所有院区', 15, '启用了价格等级时，如果有此权限，则显示所有收费项目，否则只显示当前操作员登陆站点所对应的收费项目（包含未设置站点的项目）;未启用价格等级，该权限无效', 0
  From Dual;

Insert Into zlProgPrivs(系统, 序号, 功能, 所有者, 对象, 权限)
Select &n_System, 1537, '基本', User, a.* From (
Select 对象, 权限 From zlProgPrivs Where 1 = 0 Union All
 Select '收费价格等级', 'SELECT' From Dual Union All
 Select '收费价格等级应用', 'SELECT' From Dual Union All
 Select 'Zl_Get_Pricegrade', 'EXECUTE' From Dual Union All
Select 对象, 权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统, 序号, 功能, 所有者, 对象, 权限)
Select &n_System, 1801, '基本', User, a.* From (
Select 对象, 权限 From zlProgPrivs Where 1 = 0 Union All
 Select '收费价格等级', 'SELECT' From Dual Union All
 Select '收费价格等级应用', 'SELECT' From Dual Union All
 Select 'Zl_Get_Pricegrade', 'EXECUTE' From Dual Union All
Select 对象, 权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统, 序号, 功能, 所有者, 对象, 权限)
Select &n_System, 1802, '基本', User, a.* From (
Select 对象, 权限 From zlProgPrivs Where 1 = 0 Union All
 Select '收费价格等级', 'SELECT' From Dual Union All
 Select '收费价格等级应用', 'SELECT' From Dual Union All
 Select 'Zl_Get_Pricegrade', 'EXECUTE' From Dual Union All
Select 对象, 权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统, 序号, 功能, 所有者, 对象, 权限)
Select &n_System, 1803, '基本', User, a.* From (
Select 对象, 权限 From zlProgPrivs Where 1 = 0 Union All
 Select '收费价格等级', 'SELECT' From Dual Union All
 Select '收费价格等级应用', 'SELECT' From Dual Union All
 Select 'Zl_Get_Pricegrade', 'EXECUTE' From Dual Union All
Select 对象, 权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统, 序号, 功能, 所有者, 对象, 权限)
Select &n_System, 1009, '基本', User, a.* From (
Select 对象, 权限 From zlProgPrivs Where 1 = 0 Union All
 Select '收费价格等级', 'SELECT' From Dual Union All
 Select '收费价格等级应用', 'SELECT' From Dual Union All
Select 对象, 权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统, 序号, 功能, 所有者, 对象, 权限)
Select &n_System, 1130, '基本', User, a.* From (
Select 对象, 权限 From zlProgPrivs Where 1 = 0 Union All
 Select '收费价格等级', 'SELECT' From Dual Union All
 Select '收费价格等级应用', 'SELECT' From Dual Union All
Select 对象, 权限 From zlProgPrivs Where 1 = 0) A;


Insert Into zlProgPrivs(系统, 序号, 功能, 所有者, 对象, 权限)
Select &n_System, 9000, '基本', User, a.* From (
Select 对象, 权限 From zlProgPrivs Where 1 = 0 Union All
 Select '收费价格等级', 'SELECT' From Dual Union All
 Select '收费价格等级应用', 'SELECT' From Dual Union All
 Select 'Zl_Get_Pricegrade', 'EXECUTE' From Dual Union All
 Select 'Zl_Get_Retailprice', 'EXECUTE' From Dual Union All
Select 对象, 权限 From zlProgPrivs Where 1 = 0) A;

--108202:蒋廷中,2017-05-16,诊断符合允许不导入
Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select &n_System, 1256, '诊断符合允许不导入', 12, '有该权限时，诊断符合时允许不导入。',1
  From Dual;


--108762:冉俊明,2017-05-15,临床出诊安排医生姓名前显示职称标识符
Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select &n_System, 1114, '职称标识设置', 24, '具有该权限时，可以对显示在临床安排中医生姓名前的医生职称标识符进行设置。', 0
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1114, '基本', User, '专业技术职务', 'SELECT'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1114, '职称标识设置', User, 'Zl_专业技术职务_更新标识符', 'EXECUTE'
  From Dual;

--108210:李南春,2017-05-12,自助签约模式调整
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1802, '基本', User, 'Zl_病人信息_联系电话_Update', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1803, '基本', User, 'Zl_病人信息_联系电话_Update', 'EXECUTE'
  From Dual;

--107372:蒋廷中,2017-05-11,传染病管理用户支持可修改传染病文件
Insert Into zlProgPrivs(系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1278, '基本', User, 'Zl_疾病阳性检测记录_Update', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs(系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1278, '基本', User, '病人变动记录', 'SELECT'
  From Dual;

--108534:张险华,2017-5-11,增加取消完成审批模块
Insert Into zlPrograms
  (序号, 标题, 说明, 系统, 部件)
  Select 2227 序号, '取消完成审批' 标题, '用于在病历完成后需要再次修改时进行审批操作' As 说明, &n_System 系统, 'zl9EmrInterface' 部件
  From Dual;

Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,2227,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
Select '基本',0,'基本信息',1 From Dual Union All
Select '系统报表',1,'对系统自带报表的访问',1 From Dual) A
Where Not Exists (Select 1 From zlProgFuncs Where 序号 = 2227 And 功能='基本');

Insert Into zlMenus(组别, ID, 上级id, 标题, 说明, 系统, 模块, 短标题, 图标)
Select A.组别,ZlMenus_ID.Nextval,A.ID,B.* From (
Select 组别,ID From zlMenus Where 标题 = '质控系统管理' And 组别 = '缺省' And 系统 = &n_System And 模块 Is Null) A,
(Select 标题, 说明, 系统, 模块, 短标题, 图标 From zlMenus Where 1=0 Union ALL
Select '取消完成审批','用于在病历完成后需要再次修改时进行审批操作',&n_System,2227,'取消完成审批',109 From Dual) B
Where Not Exists (Select 1 From zlMenus Where 模块 = 2227 And 标题='取消完成审批');

--100642:董露露,2017-05-11,处理病人信息管理中增、删、改权限独立，可以分开进行授权的需求
Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select &n_System, 1101, '增加', 22, '增加病人信息的操作权限。有该权限时，允许对病人信息进行增加操作。', 1
  From Dual;

Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select &n_System, 1101, '修改', 23, '修改病人信息的操作权限。有该权限时，允许对病人信息进行修改操作。', 1
  From Dual;

Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select &n_System, 1101, '删除', 24, '删除病人信息的操作权限。有该权限时，允许对病人信息进行修改操作。', 1
  From Dual;

Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select &n_System, 1101, '启停', 25, '启用和停用病人信息的操作权限。有该权限时，允许对病人信息进行停用、取消停用操作。', 1
  From Dual;

Insert Into Zlprogrelas
  (系统, 序号, 组号, 功能, 关系, 主项, 主项关系)
  Select &n_System, 1101, 1, '增加', 2, 0, 0 From Dual;
  
Insert Into Zlprogrelas
  (系统, 序号, 组号, 功能, 关系, 主项, 主项关系)
  Select &n_System, 1101, 1, '修改', 2, 0, 0 From Dual;
  
Insert Into Zlprogrelas
  (系统, 序号, 组号, 功能, 关系, 主项, 主项关系)
  Select &n_System, 1101, 1, '删除', 2, 0, 0 From Dual;
  
Insert Into Zlprogrelas
  (系统, 序号, 组号, 功能, 关系, 主项, 主项关系)
  Select &n_System, 1101, 1, '启停', 2, 0, 0 From Dual;
   
--107898:冉俊明,2017-05-08,修正临床出诊号源“适用年龄”设置问题，同步增加“出诊号源设置”对“性别”表的“SELECT”权限
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1114, '出诊号源设置', User, '性别', 'SELECT'
  From Dual;

--107618:胡俊勇,2017-05-08,门诊医生工作站诊室设置
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select  &n_System,1260,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
       Select '门诊诊室适用科室','SELECT' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--99878:冉俊明,2017-05-27,同一收费项目多个价格管理
Insert Into Zlmodulerelas
  (系统, 模块, 功能, 相关系统, 相关模块, 相关类型, 相关功能, 缺省值)
  Select &n_System, 1107, Null, &n_System, 9000, 1, '基本', 1 From Dual union all
  Select &n_System, 1101, Null, &n_System, 9000, 1, '基本', 1 From Dual union all
  Select &n_System, 1111, Null, &n_System, 9000, 1, '基本', 1 From Dual union all
  Select &n_System, 1115, Null, &n_System, 9000, 1, '基本', 1 From Dual union all
  Select &n_System, 1120, Null, &n_System, 9000, 1, '基本', 1 From Dual union all
  Select &n_System, 1121, Null, &n_System, 9000, 1, '基本', 1 From Dual union all
  Select &n_System, 1122, Null, &n_System, 9000, 1, '基本', 1 From Dual union all
  Select &n_System, 1131, Null, &n_System, 9000, 1, '基本', 1 From Dual union all
  Select &n_System, 1133, Null, &n_System, 9000, 1, '基本', 1 From Dual union all
  Select &n_System, 1134, Null, &n_System, 9000, 1, '基本', 1 From Dual union all
  Select &n_System, 1135, Null, &n_System, 9000, 1, '基本', 1 From Dual union all
  Select &n_System, 1132, Null, &n_System, 9000, 1, '基本', 1 From Dual union all
  Select &n_System, 1139, Null, &n_System, 9000, 1, '基本', 1 From Dual;

--107905:冉俊明,2017-06-05,重新收费他人的异常收费单据，重新结算他人的异常补充结算单据
Insert Into Zlprogrelas
  (系统, 序号, 组号, 功能, 关系, 主项, 主项关系)
  Select &n_System, 1121, 2, '重收他人异常单据', 2, 0, 0
  From Dual;

Insert Into Zlprogrelas
  (系统, 序号, 组号, 功能, 关系, 主项, 主项关系)
  Select &n_System, 1124, 2, '医保结算', 2, 1, 0
  From Dual;

Insert Into Zlprogrelas
  (系统, 序号, 组号, 功能, 关系, 主项, 主项关系)
  Select &n_System, 1124, 2, '重结他人异常单据', 2, 0, 0
  From Dual;

--92837:李业庆,2017-06-07,出库单据库房信息中入库时间处理
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1300, '基本', User, '药品入库信息', 'SELECT'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1301, '基本', User, '药品入库信息', 'SELECT'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1302, '基本', User, '药品入库信息', 'SELECT'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1304, '基本', User, '药品入库信息', 'SELECT'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1305, '基本', User, '药品入库信息', 'SELECT'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1306, '基本', User, '药品入库信息', 'SELECT'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1307, '基本', User, '药品入库信息', 'SELECT'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1309, '基本', User, '药品入库信息', 'SELECT'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1330, '基本', User, '药品入库信息', 'SELECT'
  From Dual;                                                  

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1331, '基本', User, '药品入库信息', 'SELECT'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1333, '基本', User, '药品入库信息', 'SELECT'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1343, '基本', User, '药品入库信息', 'SELECT'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1344, '基本', User, '药品入库信息', 'SELECT'
  From Dual;

--107951:张德婷,2017-06-14,静配中心添加销帐拒绝的权限
Insert Into zlRoleGrant
  (系统, 序号, 角色, 功能)
  Select Distinct 系统, 序号, 角色, '销帐拒绝' 功能 From zlRoleGrant Where 系统 = &n_System And 序号 = 1345;





-------------------------------------------------------------------------------
--报表修正部份
-------------------------------------------------------------------------------






-------------------------------------------------------------------------------
--过程修正部份
-------------------------------------------------------------------------------
--111107:焦博,2017-07-11,增加一个oracle函数来根据交易流水号进行锁表,锁成功返回1,否则返回0
Create Or Replace Function ZL_Fun_三方交易记录_Locked
(
  类别_In     三方交易记录.类别%Type,
  流水号_In   三方交易记录.流水号%Type,
  卡号_In     三方交易记录.卡号%Type := Null,
  交易说明_In 三方交易记录.交易说明%Type := Null,
  结帐ID_In   三方交易记录.结帐ID%Type := Null
) Return Number Is

  --------------------------------------------------------------------------
  -- 功能:三方交易锁
  -- 类别_IN:医疗卡类别名称(比如：建行卡，招行卡，消费卡等）
  -- 流水号_In: 流水号不能传入空，传入空时，将不进行数据锁
  --返回:0-表示锁失败,1-表示锁成功
  --------------------------------------------------------------------------
  Err_Item Exception;
  v_Err_Msg Varchar2(255);
  n_Count   Number(18);
  n_Number  Integer;

  Procedure ZL_三方交易记录_Insert
  (
    类别_In     三方交易记录.类别%Type,
    流水号_In   三方交易记录.流水号%Type,
    卡号_In     三方交易记录.卡号%Type := Null,
    交易说明_In 三方交易记录.交易说明%Type := Null,
    结帐ID_In   三方交易记录.结帐ID%Type := Null,
    状态_Out    Out Integer
  ) Is
    Pragma Autonomous_Transaction;
    ------------------------------------------------
    --功能:插入数据
    --返回:状态_Out:1-插入成功,2-插入失败(其他用户已经在使用)
    ------------------------------------------------
    n_Return Integer;
  Begin
    n_Return := 1;
    Begin
      Insert Into 三方交易记录
        (类别, 流水号, 状态, 卡号, 交易说明,交易时间,结帐ID)
      Values
        (类别_In, 流水号_In, 0, 卡号_In, 交易说明_In,SYSDATE,结帐ID_In);
    Exception
      When Others Then
        n_Return := 2;
    End;
    状态_Out := n_Return;
    Commit;
  Exception
    When Others Then
      状态_Out := 0;
  End ZL_三方交易记录_Insert;
Begin
  If 流水号_In Is Null Then
    Return 1;
  End If;
  Select Count(1) Into n_Count From 三方交易记录 Where 类别 = 类别_In And 流水号 = 流水号_In;
  If Nvl(n_Count, 0) = 0 Then
    --插入数据
    Zl_三方交易记录_Insert(类别_In, 流水号_In, 卡号_In, 交易说明_In, 结帐ID_In, n_Number);
    If n_Number = 2 Then
      n_Count := 0;
      Return n_Count;
    End If;
  End If;
  Begin
    Select 状态 Into n_Count From 三方交易记录 Where 类别 = 类别_In And 流水号 = 流水号_In For Update Nowait;
    Update 三方交易记录 Set 状态 = 1 Where 类别 = 类别_In And 流水号 = 流水号_In;
    n_Count := 1;
  Exception
    When Others Then
      n_Count := 0;
  End;
  Return n_Count;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End ZL_Fun_三方交易记录_Locked;
/

--111107:焦博,2017-07-11,提供一个oracle函数接口来查询当前流水号的状态
Create Or Replace Procedure Zl_Third_Swapstaut
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:三方接口支付
  --入参:Xml_In:
  --<IN>
  --        <JYLB>交易类别</JYLB> //支付宝，微信等
  --        <JYLSH>交易流水号</JYLSH>                  
  --</IN>
  --出参:Xml_Out
  --  <OUT>
  --    <ZT>状态</ZT>  DD0-交易失败,1-交易成功;2-交易正在进行中;3-不存在该交易记录
  --    <JYSJ>交易时间</JYSJ>  DD当状态为1时才返回,否则为空
  --    <JZID>结帐ID</JZID>  DD当状态为1时才返回,否则为空
  --  </OUT>
  --------------------------------------------------------------------------------------------------
  v_Temp       Varchar2(32767); --临时XML
  x_Templet    Xmltype; --模板XML
  v_交易类别   三方交易记录.类别%Type;
  v_交易流水号 三方交易记录.流水号%Type;
  n_Count      Number(18);
  n_结帐id     三方交易记录.结帐id%Type;
  d_交易时间   Date;

Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/JYLB'), (Extractvalue(Value(A), 'IN/JYLSH'))
  Into v_交易类别, v_交易流水号
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  v_交易类别   := Nvl(v_交易类别, '-');
  v_交易流水号 := Nvl(v_交易流水号, '-');

  Begin
    Select 状态 Into n_Count From 三方交易记录 Where 类别 = v_交易类别 And 流水号 = v_交易流水号 For Update Nowait;
    Commit;
  Exception
    When Others Then
      n_Count := -1;
  End;
  If n_Count = -1 Then
    Select Count(1) Into n_Count From 三方交易记录 Where 类别 = v_交易类别 And 流水号 = v_交易流水号;
    If n_Count = 0 Then
      n_Count := 3;
    Else
      n_Count := 2;
    End If;
  Else
    If n_Count = 1 Then
      Select 交易时间, 结帐id
      Into d_交易时间, n_结帐id
      From 三方交易记录
      Where 类别 = v_交易类别 And 流水号 = v_交易流水号;
    End If;
  End If;
  v_Temp := '<ZT>' || n_Count || '</ZT>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  v_Temp := '<JYSJ>' || d_交易时间 || '</JYSJ>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  v_Temp := '<JZID>' || n_结帐id || '</JZID>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Xml_Out := x_Templet;
End Zl_Third_Swapstaut;
/

--111404:李业庆,2017-07-11,自制协定入库价格改由界面传入，不在过程中取或计算
Create Or Replace Procedure Zl_自制入库_Verify
(
  No_In     In 药品收发记录.No%Type := Null,
  审核人_In In 药品收发记录.审核人%Type := Null
) Is
  Err_Isverified Exception;

  n_库房id 药品收发记录.库房id%Type;

  Cursor c_药品收发记录 Is
    Select ID, 实际数量, Nvl(零售价, 0) As 零售价, 零售金额, 差价, 库房id, 药品id, 批次, 成本价, 批号, 效期, 产地, 入出类别id, 入出系数, 对方部门id, 供药单位id, 生产日期,
           批准文号
    From 药品收发记录
    Where NO = No_In And 单据 = 2 And 记录状态 = 1
    Order By 药品id;
Begin
  Update 药品收发记录
  Set 审核人 = Nvl(审核人_In, 审核人), 审核日期 = Sysdate
  Where NO = No_In And 单据 = 2 And 记录状态 = 1 And 审核人 Is Null;

  If Sql%RowCount = 0 Then
    Raise Err_Isverified;
  End If;

  For v_药品收发记录 In c_药品收发记录 Loop
    --调用库存更新过程
    If v_药品收发记录.入出系数 = 1 Then
      Zl_药品库存_Update(v_药品收发记录.Id, 2, 0);
    Else
      Zl_药品库存_Update(v_药品收发记录.Id, 2, 1);
      n_库房id := v_药品收发记录.库房id;
    End If;
  
    If v_药品收发记录.入出系数 = 1 Then
      --只有入业务才处理
      --更新该药品的成本价
      Update 药品规格 Set 成本价 = v_药品收发记录.成本价 Where 药品id = v_药品收发记录.药品id;
    End If;
  End Loop;
  --删除未审药品记录
  Zl_未审药品记录_Update(1, 2, No_In, n_库房id);
Exception
  When Err_Isverified Then
    Raise_Application_Error(-20101, '[ZLSOFT]该单据已经被他人审核！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_自制入库_Verify;
/

--111404:李业庆,2017-07-11,自制协定入库价格改由界面传入，不在过程中取或计算
Create Or Replace Procedure Zl_协定入库_Verify
(
  No_In     In 药品收发记录.No%Type := Null,
  审核人_In In 药品收发记录.审核人%Type := Null
) Is
  Err_Isverified Exception;

  Cursor c_药品收发记录 Is
    Select ID, 填写数量, 零售价, 零售金额, 差价, 库房id, 药品id, 批次, 成本价, 批号, 产地, 入出类别id, 入出系数, 对方部门id, 供药单位id, 生产日期, 批准文号, 效期
    From 药品收发记录
    Where NO = No_In And 单据 = 3 And 记录状态 = 1;
Begin
  Update 药品收发记录
  Set 审核人 = Nvl(审核人_In, 审核人), 审核日期 = Sysdate
  Where NO = No_In And 单据 = 3 And 记录状态 = 1 And 审核人 Is Null;

  If Sql%RowCount = 0 Then
    Raise Err_Isverified;
  End If;

  For v_药品收发记录 In c_药品收发记录 Loop
    --调用库存更新过程
    If v_药品收发记录.入出系数 = 1 Then
      Zl_药品库存_Update(v_药品收发记录.Id, 2, 0);
    Else
      Zl_药品库存_Update(v_药品收发记录.Id, 2, 1);
      --删除未审药品记录
      Zl_未审药品记录_Update(1, 3, No_In, v_药品收发记录.库房id);
    End If;
  
    If v_药品收发记录.入出系数 = 1 Then
      --只有入业务才处理
      --更新该药品的成本价
      Update 药品规格 Set 成本价 = v_药品收发记录.成本价 Where 药品id = v_药品收发记录.药品id;
    End If;
  
  End Loop;
Exception
  When Err_Isverified Then
    Raise_Application_Error(-20101, '[ZLSOFT]该单据已经被他人审核！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_协定入库_Verify;
/

--111357:李业庆,2017-07-11,自制协定入库价格改由界面传入，不在过程中取或计算
Create Or Replace Procedure Zl_自制入库_Insert
(
  No_In           In 药品收发记录.No%Type,
  序号_In         In 药品收发记录.序号%Type,
  库房id_In       In 药品收发记录.库房id%Type,
  对方部门id_In   In 药品收发记录.对方部门id%Type,
  药品id_In       In 药品收发记录.药品id%Type,
  实际数量_In     In 药品收发记录.实际数量%Type,
  成本价_In       In 药品收发记录.成本价%Type,
  成本金额_In     In 药品收发记录.成本金额%Type,
  零售价_In       In 药品收发记录.零售价%Type,
  零售金额_In     In 药品收发记录.零售金额%Type,
  差价_In         In 药品收发记录.差价%Type,
  填制人_In       In 药品收发记录.填制人%Type,
  批号_In         In 药品收发记录.批号%Type := Null,
  效期_In         In 药品收发记录.效期%Type := Null,
  摘要_In         In 药品收发记录.摘要%Type := Null,
  填制日期_In     药品收发记录.填制日期%Type := Null,
  耗损数量_In     In Varchar2 := Null,
  偏差成本金额_In In 药品收发记录.成本金额%Type := Null
) Is
  v_Lngid      药品收发记录.Id%Type; --收发ID
  v_入的类别id 药品收发记录.入出类别id%Type; --入出类别ID
  v_批次       药品收发记录.批次%Type := Null; --批次
  v_是否分批   Integer; --是否药库分批   1:分批;0:不分批
  v_药房分批   Integer; --是否药房分批   1:分批;0:不分批
Begin
  Select 药品收发记录_Id.Nextval Into v_Lngid From Dual;

  Select Nvl(药库分批, 0), Nvl(药房分批, 0) Into v_是否分批, v_药房分批 From 药品规格 Where 药品id = 药品id_In;

  If v_药房分批 = 0 Then
    If v_是否分批 = 1 Then
      Begin
        Select Distinct 0
        Into v_是否分批
        From 部门性质说明
        Where ((工作性质 Like '%药房') Or (工作性质 Like '制剂室')) And 部门id = 库房id_In;
      Exception
        When Others Then
          v_是否分批 := 1;
      End;
    
      If v_是否分批 = 1 Then
        v_批次 := v_Lngid;
      End If;
    End If;
  Else
    v_批次 := v_Lngid;
  End If;

  Select b.Id
  Into v_入的类别id
  From 药品单据性质 A, 药品入出类别 B
  Where a.类别id = b.Id And a.单据 = 2 And b.系数 = 1 And Rownum < 2;

  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 批号, 效期, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 零售金额, 差价, 摘要, 填制人,
     填制日期, 单量)
  Values
    (v_Lngid, 1, 2, No_In, 序号_In, 库房id_In, 对方部门id_In, v_入的类别id, 1, 药品id_In, v_批次, 批号_In, 效期_In, 实际数量_In, 实际数量_In,
     成本价_In, 成本金额_In, 零售价_In, 零售金额_In, 差价_In, 摘要_In, 填制人_In, 填制日期_In, 偏差成本金额_In);

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_自制入库_Insert;
/

--111357:李业庆,2017-07-11,自制协定入库价格改由界面传入，不在过程中取或计算
Create Or Replace Procedure Zl_协定入库_Insert
(
  入库类别id_In In 药品收发记录.入出类别id%Type,
  No_In         In 药品收发记录.No%Type,
  序号_In       In 药品收发记录.序号%Type,
  库房id_In     In 药品收发记录.库房id%Type,
  药品id_In     In 药品收发记录.药品id%Type,
  实际数量_In   In 药品收发记录.实际数量%Type,
  成本价_In     In 药品收发记录.成本价%Type,
  成本金额_In   In 药品收发记录.成本金额%Type,
  零售价_In     In 药品收发记录.零售价%Type,
  零售金额_In   In 药品收发记录.零售金额%Type,
  差价_In       In 药品收发记录.差价%Type,
  填制人_In     In 药品收发记录.填制人%Type,
  填制日期_In   In 药品收发记录.填制日期%Type := Null,
  摘要_In       In 药品收发记录.摘要%Type := Null
  
) Is
  v_Lngid    药品收发记录.Id%Type; --收发ID 
  v_批次     药品收发记录.批次%Type := Null; --批次 
  v_是否分批 Integer; --是否药库分批   1:分批;0:不分批 
  v_药房分批 Integer; --是否药房分批   1:分批;0:不分批 
Begin

  Select 药品收发记录_Id.Nextval Into v_Lngid From Dual;

  Select Nvl(药库分批, 0), Nvl(药房分批, 0) Into v_是否分批, v_药房分批 From 药品规格 Where 药品id = 药品id_In;

  If v_药房分批 = 0 Then
    If v_是否分批 = 1 Then
      Begin
        Select Distinct 0
        Into v_是否分批
        From 部门性质说明
        Where ((工作性质 Like '%药房') Or (工作性质 Like '制剂室')) And 部门id = 库房id_In;
      Exception
        When Others Then
          v_是否分批 := 1;
      End;
    
      If v_是否分批 = 1 Then
        v_批次 := v_Lngid;
      End If;
    End If;
  Else
    v_批次 := v_Lngid;
  End If;

  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 零售金额, 差价, 摘要, 填制人, 填制日期, 批次)
  Values
    (v_Lngid, 1, 3, No_In, 序号_In, 库房id_In, 库房id_In, 入库类别id_In, 1, 药品id_In, 实际数量_In, 实际数量_In, 成本价_In, 成本金额_In, 零售价_In,
     零售金额_In, 差价_In, 摘要_In, 填制人_In, 填制日期_In, v_批次);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_协定入库_Insert;
/



--91458:陈刘,2017-07-10,增加入量导入,分类汇总
Create Or Replace Procedure Zl_护理文件样式_Update
(
  文件id_In     In 病历文件结构.文件id%Type,
  表头层数_In   Number,
  总列数_In     Number,
  最小行高_In   Number,
  文本字体_In   Varchar2,
  文本颜色_In   Number,
  表格颜色_In   Number,
  标题文本_In   Varchar2,
  标题字体_In   Varchar2,
  开始时间_In   Number,
  终止时间_In   Number,
  条件字体_In   Varchar2,
  条件颜色_In   Number,
  有效数据行_In Number,
  首列合并_In   Number,
  时间隐藏_In   Number, --记录单预览、打印时隐藏时间列(如：血糖记录单不需要显示具体的时间)
  页面格式_In   病历页面格式.格式%Type, --按.PaperKind;.PaperOrient;.PaperHeight;.PaperWidth;.MarginLeft;.MarginRight;.MarginTop;.MarginBottom组织
  页眉文本_In   病历页面格式.页眉%Type,
  页脚文本_In   病历页面格式.页脚%Type,
  表上标签_In   Varchar2, --按照"前缀{项目}"组织，以"|"为分隔的表上标签集合
  表头单元_In   Varchar2, --按照"列号,层号,文本"组织，以"|"为分隔的表头单元集合
  表列集合_In   Varchar2, --按照"列号,列宽,项目集合"组织，以"|"为分隔的表列集合；其中项目集合组织为"前缀{项目}后缀`是否汇总", 空格分隔。
  汇总时段_In   Varchar2 := Null, --按照"时段名称,开始时间点,结束时间点"组织，以"|"为分隔的集合。
  表下标签_In   Varchar2 := Null, --按照"前缀{项目}"组织，以"|"为分隔的表上标签集合
  分类汇总_In   Number := Null
) Is
  v_Items    Varchar2(4000); --项目集合
  v_Subitems Varchar2(4000); --项目集合
  v_Fields   Varchar2(4000); --一个项目的属性组合
  v_Colno    Varchar2(100); --项目列号
  n_父id     病历文件结构.父id%Type;
  n_对象序号 病历文件结构.对象序号%Type;
  n_对象标记 病历文件结构.对象标记%Type;
  v_对象属性 病历文件结构.对象属性%Type;
  n_内容行次 病历文件结构.内容行次%Type;
  v_内容文本 病历文件结构.内容文本%Type;
  v_是否换行 病历文件结构.是否换行%Type;
  v_要素名称 病历文件结构.要素名称%Type;
  v_要素单位 病历文件结构.要素单位%Type;
  n_要素表示 病历文件结构.要素表示%Type;
Begin
  Delete 病历文件结构 Where 文件id = 文件id_In;

  Update 病历页面格式
  Set 格式 = 页面格式_In, 页眉 = 页眉文本_In, 页脚 = 页脚文本_In
  Where 种类 = 3 And 编号 In (Select 页面 From 病历文件列表 Where Id = 文件id_In);

  Select 病历文件结构_Id.Nextval Into n_父id From Dual;
  Insert Into 病历文件结构
    (Id, 文件id, 对象序号, 对象类型, 对象属性, 内容文本)
  Values
    (n_父id, 文件id_In, 1, 1, '表格基本属性和样式的说明', '表格样式');
  Insert Into 病历文件结构
    (Id, 文件id, 父id, 对象类型, 对象序号, 对象属性, 内容文本, 要素名称)
    Select 病历文件结构_Id.Nextval, 文件id_In, n_父id, 4, 序号, 属性, 文本, 名称
    From (Select 1 As 序号, '目前支持单层(1)和多层次(2)' As 属性, To_Char(表头层数_In) As 文本, '表头层数' As 名称
           From Dual
           Union All
           Select 2, '表格总共有的列数', To_Char(总列数_In), '总列数'
           From Dual
           Union All
           Select 3, '每行的最小高度(缇)', To_Char(最小行高_In), '最小行高'
           From Dual
           Union All
           Select 4, '表格的默认字体', 文本字体_In, '文本字体'
           From Dual
           Union All
           Select 5, '表格文本颜色RGB值', To_Char(文本颜色_In), '文本颜色'
           From Dual
           Union All
           Select 6, '表格线的基本颜色', To_Char(表格颜色_In), '表格颜色'
           From Dual
           Union All
           Select 7, '标题的文字内容', 标题文本_In, '标题文本'
           From Dual
           Union All
           Select 8, '标题的字体', 标题字体_In, '标题字体'
           From Dual
           Union All
           Select 9, '按24小时表示的条件开始范围', To_Char(开始时间_In), '开始时间'
           From Dual
           Union All
           Select 10, '小于开始时间表示次日终止', To_Char(终止时间_In), '终止时间'
           From Dual
           Union All
           Select 11, '符合条件的内容记录的字体', 条件字体_In, '条件字体'
           From Dual
           Union All
           Select 13, '有效数据行', To_Char(有效数据行_In), '有效数据行'
           From Dual
           Union All
           Select 14, '日期时间合并', To_Char(首列合并_In), '日期时间合并'
           From Dual
           Union All
           Select 12, '符合表件的内容记录的颜色', To_Char(条件颜色_In), '条件颜色'
           From Dual
           Union All
           Select 15, '时间列隐藏', To_Char(时间隐藏_In), '时间列隐藏'
           From Dual
           Union All
           Select 16, '分类汇总', To_Char(分类汇总_In), '分类汇总'
           From Dual);

  Select 病历文件结构_Id.Nextval Into n_父id From Dual;
  Insert Into 病历文件结构
    (Id, 文件id, 对象序号, 对象类型, 对象属性, 内容文本)
  Values
    (n_父id, 文件id_In, 2, 1, '由替换项组成的表上项目', '表上标签');
  If 表头单元_In Is Null Then
    v_Items := Null;
  Else
    v_Items := Rtrim(表上标签_In) || '|';
  End If;
  n_对象序号 := 0;
  While v_Items Is Not Null Loop
    v_Fields   := Substr(v_Items, 1, Instr(v_Items, '|') - 1);
    n_对象序号 := n_对象序号 + 1;
    v_内容文本 := Substr(v_Fields, 1, Instr(v_Fields, '{') - 1);
    v_要素名称 := Substr(v_Fields, Instr(v_Fields, '{') + 1, Instr(v_Fields, '}') - Instr(v_Fields, '{') - 1);
    If Substr(v_内容文本, 1, 2) = Chr(13) || Chr(10) Then
      v_是否换行 := 1;
      v_内容文本 := Substr(v_内容文本, 3);
    Else
      v_是否换行 := 0;
    End If;
    Insert Into 病历文件结构
      (Id, 文件id, 父id, 对象类型, 对象序号, 内容文本, 要素名称, 是否换行)
    Values
      (病历文件结构_Id.Nextval, 文件id_In, n_父id, 4, n_对象序号, v_内容文本, v_要素名称, v_是否换行);
    v_Items := Substr(v_Items, Instr(v_Items, '|') + 1);
  End Loop;

  Select 病历文件结构_Id.Nextval Into n_父id From Dual;
  Insert Into 病历文件结构
    (Id, 文件id, 对象序号, 对象类型, 对象属性, 内容文本)
  Values
    (n_父id, 文件id_In, 3, 1, '组成表头的各单元内容', '表头单元');
  If 表头单元_In Is Null Then
    v_Items := Null;
  Else
    v_Items := Rtrim(表头单元_In) || '|';
  End If;
  While v_Items Is Not Null Loop
    v_Fields   := Substr(v_Items, 1, Instr(v_Items, '|') - 1);
    n_对象序号 := To_Number(Substr(v_Fields, 1, Instr(v_Fields, ',', 1, 1) - 1));
    n_内容行次 := To_Number(Substr(v_Fields,
                               Instr(v_Fields, ',', 1, 1) + 1,
                               Instr(v_Fields, ',', 1, 2) - Instr(v_Fields, ',', 1, 1) - 1));
    v_内容文本 := Substr(v_Fields, Instr(v_Fields, ',', 1, 2) + 1);
    Insert Into 病历文件结构
      (Id, 文件id, 父id, 对象类型, 对象序号, 内容行次, 内容文本)
    Values
      (病历文件结构_Id.Nextval, 文件id_In, n_父id, 2, n_对象序号, n_内容行次, v_内容文本);
    v_Items := Substr(v_Items, Instr(v_Items, '|') + 1);
  End Loop;

  Select 病历文件结构_Id.Nextval Into n_父id From Dual;
  Insert Into 病历文件结构
    (Id, 文件id, 对象序号, 对象类型, 对象属性, 内容文本)
  Values
    (n_父id, 文件id_In, 4, 1, '表体各数据列的定义设置', '表列集合');
  If 表列集合_In Is Null Then
    v_Items := Null;
  Else
    v_Items := Rtrim(表列集合_In) || '|';
  End If;
  While v_Items Is Not Null Loop
    v_Fields := Substr(v_Items, 1, Instr(v_Items, '|') - 1);
    --汇总列设置了对照关系列号为:项目列号`对照列号
    v_Colno := Substr(v_Fields, 1, Instr(v_Fields, ',', 1, 1) - 1);
    If Instr(v_Colno, '`', 1, 1) > 0 Then
      n_对象序号 := To_Number(Substr(v_Colno, 1, Instr(v_Colno, '`', 1, 1) - 1));
      n_对象标记 := To_Number(Substr(v_Colno, Instr(v_Colno, '`', 1, 1) + 1));
    Else
      n_对象序号 := To_Number(v_Colno);
      n_对象标记 := Null;
    End If;
    v_对象属性 := Substr(v_Fields,
                     Instr(v_Fields, ',', 1, 1) + 1,
                     Instr(v_Fields, ',', 1, 2) - Instr(v_Fields, ',', 1, 1) - 1);
    v_Subitems := Substr(v_Fields, Instr(v_Fields, ',', 1, 2) + 1);
    If v_Subitems Is Null Then
      Insert Into 病历文件结构
        (Id, 文件id, 父id, 对象类型, 对象序号, 对象标记, 对象属性, 内容行次, 内容文本, 要素名称, 要素单位)
      Values
        (病历文件结构_Id.Nextval, 文件id_In, n_父id, 4, n_对象序号, n_对象标记, v_对象属性, 1, '', '', '');
    Else
      v_Subitems := Rtrim(v_Subitems) || ' ';
    End If;
    n_内容行次 := 0;
    While v_Subitems Is Not Null Loop
      n_内容行次 := n_内容行次 + 1;
      v_Fields   := Substr(v_Subitems, 1, Instr(v_Subitems, ' ') - 1);
      v_内容文本 := Substr(v_Fields, 1, Instr(v_Fields, '{') - 1);
      v_要素名称 := Substr(v_Fields, Instr(v_Fields, '{') + 1, Instr(v_Fields, '}') - Instr(v_Fields, '{') - 1);
      If Instr(v_Fields, '`') > 0 Then
        v_要素单位 := Substr(v_Fields, Instr(v_Fields, '}') + 1, Instr(v_Fields, '`') - Instr(v_Fields, '}') - 1);
        n_要素表示 := To_Number(Substr(v_Fields, Instr(v_Fields, '`', 1, 1) + 1));
      Else
        v_要素单位 := Substr(v_Fields, Instr(v_Fields, '}') + 1);
        n_要素表示 := 0;
      End If;
      If n_内容行次 > 1 Then
        n_对象标记 := Null;
      End If;
      Insert Into 病历文件结构
        (Id, 文件id, 父id, 对象类型, 对象序号, 对象标记, 对象属性, 内容行次, 内容文本, 要素名称, 要素单位, 要素表示)
      Values
        (病历文件结构_Id.Nextval, 文件id_In, n_父id, 4, n_对象序号, n_对象标记, v_对象属性, n_内容行次, v_内容文本, v_要素名称, v_要素单位, n_要素表示);
      v_Subitems := Substr(v_Subitems, Instr(v_Subitems, ' ') + 1);
    End Loop;
    v_Items := Substr(v_Items, Instr(v_Items, '|') + 1);
  End Loop;

  Select 病历文件结构_Id.Nextval Into n_父id From Dual;
  Insert Into 病历文件结构
    (Id, 文件id, 对象序号, 对象类型, 对象属性, 内容文本)
  Values
    (n_父id, 文件id_In, 5, 1, '汇总时的分组依据', '汇总时段');
  If 汇总时段_In Is Null Then
    v_Items := Null;
  Else
    v_Items := Rtrim(汇总时段_In) || '|';
  End If;

  n_内容行次 := 0;
  While v_Items Is Not Null Loop
    v_Fields   := Substr(v_Items, 1, Instr(v_Items, '|') - 1);
    n_内容行次 := n_内容行次 + 1;
    Insert Into 病历文件结构
      (Id, 文件id, 父id, 对象类型, 对象序号, 内容行次, 内容文本)
    Values
      (病历文件结构_Id.Nextval, 文件id_In, n_父id, 2, n_内容行次, n_内容行次, v_Fields);
    v_Items := Substr(v_Items, Instr(v_Items, '|') + 1);
  End Loop;

  Select 病历文件结构_Id.Nextval Into n_父id From Dual;
  Insert Into 病历文件结构
    (Id, 文件id, 对象序号, 对象类型, 对象属性, 内容文本)
  Values
    (n_父id, 文件id_In, 6, 1, '由替换项组成的表上项目', '表下标签');
  If 表头单元_In Is Null Then
    v_Items := Null;
  Else
    v_Items := Rtrim(表下标签_In) || '|';
  End If;
  n_对象序号 := 0;
  While v_Items Is Not Null Loop
    v_Fields   := Substr(v_Items, 1, Instr(v_Items, '|') - 1);
    n_对象序号 := n_对象序号 + 1;
    v_内容文本 := Substr(v_Fields, 1, Instr(v_Fields, '{') - 1);
    v_要素名称 := Substr(v_Fields, Instr(v_Fields, '{') + 1, Instr(v_Fields, '}') - Instr(v_Fields, '{') - 1);
    If Substr(v_内容文本, 1, 2) = Chr(13) || Chr(10) Then
      v_是否换行 := 1;
      v_内容文本 := Substr(v_内容文本, 3);
    Else
      v_是否换行 := 0;
    End If;
    Insert Into 病历文件结构
      (Id, 文件id, 父id, 对象类型, 对象序号, 内容文本, 要素名称, 是否换行)
    Values
      (病历文件结构_Id.Nextval, 文件id_In, n_父id, 4, n_对象序号, v_内容文本, v_要素名称, v_是否换行);
    v_Items := Substr(v_Items, Instr(v_Items, '|') + 1);
  End Loop;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_护理文件样式_Update;
/

--110234:李业庆,2017-07-07,无库存发料平均成本价字段为空处理
Create Or Replace Procedure Zl_药品收发记录_批量发料
(
  收发id_In     In Varchar2, --格式:id1,批次1|id2,批次2|.....
  库房id_In     In 药品收发记录.库房id%Type,
  审核人_In     In 药品收发记录.审核人%Type,
  审核日期_In   In 药品收发记录.审核日期%Type,
  发料方式_In   In 药品收发记录.发药方式%Type := 3, --1-处方发料;2-批量发料;3-部门发料;-1 停止发料
  领料人_In     In 药品收发记录.领用人%Type := Null,
  发料标识号_In In 药品收发记录.汇总发药号%Type := Null,
  配料人_In     In 药品收发记录.配药人%Type := Null,
  审核人编码_In In 人员表.编号%Type := Null
) Is
  --只读变量
  Err_Item Exception;
  v_Err_Msg Varchar2(255);

  v_批号     药品收发记录.批号%Type;
  v_上次产地 药品库存.上次产地%Type;
  v_批准文号 药品库存.批准文号%Type;

  v_Loop_Str Varchar2(4000);
  v_Fields   Varchar2(4000);

  n_Id       药品收发记录.Id%Type;
  n_批次     药品收发记录.批次%Type;
  n_成本价   药品收发记录.成本价%Type;
  n_库房id   药品收发记录.库房id%Type;
  n_库存金额 药品库存.实际金额%Type;
  n_库存差价 药品库存.实际差价%Type;
  n_未发数   未发药品记录.未发数%Type;
  --可写变量
  n_成本金额 药品收发记录.成本金额%Type;
  n_实际差价 药品收发记录.差价%Type;
  n_可用数量 药品收发记录.填写数量%Type;
  n_批次_Cur 药品收发记录.批次%Type;
  n_实价卫材 收费项目目录.是否变价%Type;

  n_上次供应商id       药品库存.上次供应商id%Type;
  n_上次采购价         药品库存.上次采购价%Type;
  n_执行状态           Number;
  n_差价率             Number;
  n_收费与发料分离     Number(1);
  n_小数               Number(2);
  n_允许未审核处方发料 Number(2);
  n_序号               Number;

  d_效期                   药品收发记录.效期%Type;
  d_上次生产日期           药品库存.上次生产日期%Type;
  n_门诊标志               Number(1);
  v_入库no                 药品收发记录.No%Type;
  v_入库库房id             药品收发记录.库房id%Type := 0;
  v_病人信息               Varchar2(200);
  v_备货                   Number(1);
  v_允许未审核记账单发料   Number(1);
  v_允许未收费的划价单发料 Number(1);
  v_自动审核记账单         Number(1);
  n_平均成本价             药品库存.平均成本价%Type;
Begin
  --获取金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into n_小数 From Dual;

  Select zl_GetSysParameter('允许未审核的记账处方发料') Into v_允许未审核记账单发料 From Dual;
  Select zl_GetSysParameter('执行后自动审核划价单') Into v_自动审核记账单 From Dual;
  Select zl_GetSysParameter('允许未收费的门诊划价处方发料') Into v_允许未收费的划价单发料 From Dual;

  If 收发id_In Is Null Then
    v_Loop_Str := Null;
  Else
    v_Loop_Str := 收发id_In || '|';
  End If;

  While v_Loop_Str Is Not Null Loop
    --分解单据ID串
    v_Fields   := Substr(v_Loop_Str, 1, Instr(v_Loop_Str, '|') - 1);
    n_Id       := Substr(v_Fields, 1, Instr(v_Fields, ',') - 1);
    n_批次     := Substr(v_Fields, Instr(v_Fields, ',') + 1);
    v_Loop_Str := Replace('|' || v_Loop_Str, '|' || v_Fields || '|');
  
    --检查相关操作
    v_Err_Msg := 'NO';
    For c_Check In (Select a.Id, a.单据, b.Id 费用id, a.No, b.No 费用no, b.病人id, Null 主页id, Null 病人病区id, b.病人科室id, b.开单部门id,
                           b.执行部门id, b.收入项目id, b.实收金额, b.操作员编号, b.操作员姓名, Nvl(b.记录状态, 0) As 审核标志, a.审核人,
                           Decode(Nvl(a.摘要, 'No拒发'), '拒发', 3, b.执行状态) 执行状态, 1 门诊标志
                    From 药品收发记录 A, 门诊费用记录 B
                    Where a.费用id = b.Id And a.Id = n_Id
                    Union All
                    Select a.Id, a.单据, b.Id 费用id, a.No, b.No 费用no, b.病人id, b.主页id, b.病人病区id, b.病人科室id, b.开单部门id, b.执行部门id,
                           b.收入项目id, b.实收金额, b.操作员编号, b.操作员姓名, Nvl(b.记录状态, 0) As 审核标志, a.审核人,
                           Decode(Nvl(a.摘要, 'No拒发'), '拒发', 3, b.执行状态) 执行状态, 2 门诊标志
                    From 药品收发记录 A, 住院费用记录 B
                    Where a.费用id = b.Id And a.Id = n_Id) Loop
      If Not (c_Check.审核人 Is Null) Then
        v_Err_Msg := '该处方[' || c_Check.No || ']已被其它操作员发料，操作被迫中止！';
        Raise Err_Item;
      End If;
      If Nvl(c_Check.执行状态, 0) = 3 Then
        v_Err_Msg := '该处方[' || c_Check.No || ']已拒发，操作被迫中止！';
        Raise Err_Item;
      End If;
    
      If Nvl(c_Check.审核标志, 0) = 0 And c_Check.单据 = 25 Then
        If v_允许未审核记账单发料 = 0 Then
          v_Err_Msg := '该处方[' || c_Check.No || ']还未审核，操作被迫中止！';
          Raise Err_Item;
        Else
          If v_自动审核记账单 = 1 Then
            --审核门诊和住院的单据
            If c_Check.操作员姓名 Is Null Then
              --审核门诊和住院的单据
              Zl_记帐记录_发料审核(c_Check.Id, c_Check.费用id, c_Check.费用no, c_Check.病人id, c_Check.主页id, c_Check.病人病区id,
                           c_Check.病人科室id, c_Check.开单部门id, c_Check.执行部门id, c_Check.收入项目id, c_Check.实收金额, 审核人编码_In,
                           审核人_In, c_Check.门诊标志, Null);
            Else
              --审核门诊和住院的单据
              Zl_记帐记录_发料审核(c_Check.Id, c_Check.费用id, c_Check.费用no, c_Check.病人id, c_Check.主页id, c_Check.病人病区id,
                           c_Check.病人科室id, c_Check.开单部门id, c_Check.执行部门id, c_Check.收入项目id, c_Check.实收金额, c_Check.操作员编号,
                           c_Check.操作员姓名, c_Check.门诊标志, Null);
            End If;
          End If;
        End If;
      End If;
    
      If Nvl(c_Check.审核标志, 0) = 0 And c_Check.单据 = 24 And v_允许未收费的划价单发料 = 0 Then
        v_Err_Msg := '该处方[' || c_Check.No || ']还未收费，操作被迫中止！';
        Raise Err_Item;
      End If;
    
      v_Err_Msg := 'Have';
    
      n_门诊标志 := c_Check.门诊标志;
    
    End Loop;
  
    If v_Err_Msg = 'NO' Then
      v_Err_Msg := '未找到指定单据,可能已经被其他操作员处理,操作被迫中止！';
      Raise Err_Item;
    End If;
  
    --获取该收发记录的单据、药品ID、库房ID,零售金额及实际数量、入出类别ID
    For c_收发 In (Select a.单据, a.No, a.药品id, a.库房id, a.费用id, a.零售价, Nvl(a.零售金额, 0) As 实际金额,
                        Nvl(a.实际数量, 0) * Nvl(a.付数, 1) As 实际数量, a.入出类别id, a.入出系数, Nvl(a.批次, 0) As 批次,
                        '[' || c.编码 || ']' || c.名称 As 名称, a.批号, a.效期, a.供药单位id, a.产地, a.生产日期, a.批准文号, a.商品条码, a.内部条码,
                        b.序号 As 费用序号
                 From 药品收发记录 A, 收费项目目录 C, 门诊费用记录 B
                 Where a.Id = n_Id And a.药品id = c.Id And a.费用id = b.Id
                 Union All
                 Select a.单据, a.No, a.药品id, a.库房id, a.费用id, a.零售价, Nvl(a.零售金额, 0) As 实际金额,
                        Nvl(a.实际数量, 0) * Nvl(a.付数, 1) As 实际数量, a.入出类别id, a.入出系数, Nvl(a.批次, 0) As 批次,
                        '[' || c.编码 || ']' || c.名称 As 名称, a.批号, a.效期, a.供药单位id, a.产地, a.生产日期, a.批准文号, a.商品条码, a.内部条码,
                        b.序号 As 费用序号
                 From 药品收发记录 A, 收费项目目录 C, 住院费用记录 B
                 Where a.Id = n_Id And a.药品id = c.Id And a.费用id = b.Id) Loop
      If Nvl(n_批次, 0) = 0 Then
        n_批次_Cur := c_收发.批次;
      Else
        n_批次_Cur := Nvl(n_批次, 0);
      End If;
    
      --检查是否已经填写库房
      n_收费与发料分离 := 0;
      If c_收发.库房id Is Null Then
        n_收费与发料分离 := 1;
      End If;
    
      n_库房id := 库房id_In;
      --取该批卫生材料的批号
      Begin
        Select 上次批号, 效期, Nvl(可用数量, 0), 上次供应商id, 上次产地, 上次生产日期, 批准文号, 上次采购价, Nvl(实际金额, 0) 实际金额, Nvl(实际差价, 0) 实际差价
        Into v_批号, d_效期, n_可用数量, n_上次供应商id, v_上次产地, d_上次生产日期, v_批准文号, n_上次采购价, n_库存金额, n_库存差价

        From 药品库存
        Where 库房id + 0 = n_库房id And 药品id = c_收发.药品id And 性质 = 1 And Nvl(批次, 0) = n_批次_Cur;
      Exception
        When Others Then
          n_库存金额   := 0;
          n_库存差价   := 0;
          n_上次采购价 := 0;
          n_可用数量   := 0;
      End;
    
      Begin
        Select 1
        Into v_备货
        From 药品收发记录
        Where 单据 = 21 And 审核日期 Is Null And 药品id = c_收发.药品id And Nvl(批次, 0) = c_收发.批次 And 费用id = c_收发.费用id And
              Rownum = 1;
      Exception
        When Others Then
          v_备货 := 0;
      End;
    
      --可用数量不足则退出
      If n_批次_Cur <> Nvl(c_收发.批次, 0) Then
        If v_备货 = 0 And n_可用数量 < Nvl(c_收发.实际数量, 0) And n_批次_Cur <> 0 Then
          v_Err_Msg := c_收发.名称 || '的可用数量不足，操作中止！';
          Raise Err_Item;
        End If;
      End If;
    
      n_成本价   := Round(Zl_Fun_Getoutcost(c_收发.药品id, c_收发.批次, n_库房id), 7);
      n_成本金额 := Round(n_成本价 * c_收发.实际数量, n_小数);
      n_实际差价 := Round(c_收发.实际金额 - n_成本金额, n_小数);
    
      --更新药品收发记录的零售金额、成本金额及差价
      Update 药品收发记录
      Set 成本价 = n_成本价, 成本金额 = n_成本金额, 差价 = n_实际差价, 库房id = n_库房id, 批次 = n_批次_Cur, 批号 = v_批号, 效期 = d_效期, 配药人 = 配料人_In,
          审核人 = 审核人_In, 审核日期 = 审核日期_In, 发药方式 = 发料方式_In, 领用人 = 领料人_In, 汇总发药号 = 发料标识号_In, 供药单位id = n_上次供应商id, 产地 = v_上次产地,
          生产日期 = d_上次生产日期, 批准文号 = v_批准文号
      Where ID = n_Id;
    
      --并发操作检查
      If Sql%RowCount = 0 Then
        v_Err_Msg := '不存在相关的发料记录，材料信息为:' || c_收发.名称 || '，操作中止！';
        Raise Err_Item;
      End If;
    
      --更新费用记录的执行状态(已执行)
      Select Decode(Sum(Nvl(付数, 1) * 实际数量), Null, 1, 0, 1, 2)
      Into n_执行状态
      From 药品收发记录
      Where 单据 = c_收发.单据 And NO = c_收发.No And 费用id = c_收发.费用id And 审核人 Is Null And 记录状态 <> 1 And Mod(记录状态, 3) <> 0;
    
      If n_门诊标志 = 1 Then
        Update 门诊费用记录
        Set 执行状态 = n_执行状态, 执行部门id = 库房id_In, 执行人 = 审核人_In, 执行时间 = 审核日期_In
        Where NO = c_收发.No And (Mod(记录性质, 10) = 1 Or Mod(记录性质, 10) = 2) And 记录状态 <> 2 And 序号 = c_收发.费用序号;
      Else
        Update 住院费用记录
        Set 执行状态 = n_执行状态, 执行部门id = 库房id_In, 执行人 = 审核人_In, 执行时间 = 审核日期_In
        Where ID = c_收发.费用id;
      End If;
    
      --更新未发药品记录(如果未发数为零则删除)
      Select Count(*)
      Into n_未发数
      From 药品收发记录
      Where 单据 = c_收发.单据 And NO = c_收发.No And 审核人 Is Null And (库房id + 0 = n_库房id Or 库房id Is Null) And
            Nvl(LTrim(RTrim(摘要)), 'No_拒发') <> '拒发';
    
      If n_未发数 = 0 Then
        Delete 未发药品记录 Where 单据 = c_收发.单据 And NO = c_收发.No And (库房id + 0 = n_库房id Or 库房id Is Null);
      End If;
    
      Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = c_收发.药品id;
    
      --更新原批次库存的可用数量
      --更新发料批次库存的可用及实际数量
      If c_收发.批次 <> n_批次_Cur Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) + c_收发.实际数量,
            零售价 = Decode(n_实价卫材, 1, Decode(Nvl(c_收发.批次, 0), 0, Null, Decode(Nvl(零售价, 0), 0, c_收发.零售价, 零售价)), Null)
        Where 性质 = 1 And 库房id + 0 = n_库房id And 药品id = c_收发.药品id And Nvl(批次, 0) = c_收发.批次;
      
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - c_收发.实际数量,
            零售价 = Decode(n_实价卫材, 1, Decode(Nvl(n_批次_Cur, 0), 0, Null, Decode(Nvl(零售价, 0), 0, c_收发.零售价, 零售价)), Null)
        Where 性质 = 1 And 库房id + 0 = n_库房id And 药品id = c_收发.药品id And Nvl(批次, 0) = n_批次_Cur;
      End If;
    
      If n_收费与发料分离 = 1 Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - c_收发.实际数量, 实际数量 = Nvl(实际数量, 0) - c_收发.实际数量, 实际金额 = Nvl(实际金额, 0) - c_收发.实际金额,
            实际差价 = Nvl(实际差价, 0) - n_实际差价,
            零售价 = Decode(n_实价卫材, 1, Decode(Nvl(n_批次_Cur, 0), 0, Null, Decode(Nvl(零售价, 0), 0, c_收发.零售价, 零售价)), Null),
            上次采购价 = Decode(上次采购价, Null, n_成本价, 上次采购价), 平均成本价 = Decode(平均成本价, Null, n_成本价, 平均成本价),
            商品条码 = Decode(商品条码, Null, c_收发.商品条码, 商品条码), 内部条码 = Decode(内部条码, Null, c_收发.内部条码, 内部条码),
            效期 = Decode(效期, Null, c_收发.效期, 效期), 上次批号 = Decode(上次批号, Null, c_收发.批号, 上次批号),
            上次生产日期 = Decode(上次生产日期, Null, c_收发.生产日期, 上次生产日期), 上次产地 = Decode(上次产地, Null, c_收发.产地, 上次产地)
        Where 库房id + 0 = n_库房id And 药品id = c_收发.药品id And 性质 = 1 And Nvl(批次, 0) = n_批次_Cur;
      Else
        Update 药品库存
        Set 实际数量 = Nvl(实际数量, 0) - c_收发.实际数量, 实际金额 = Nvl(实际金额, 0) - c_收发.实际金额, 实际差价 = Nvl(实际差价, 0) - n_实际差价,
            零售价 = Decode(n_实价卫材, 1, Decode(Nvl(n_批次_Cur, 0), 0, Null, Decode(Nvl(零售价, 0), 0, c_收发.零售价, 零售价)), Null),
            上次采购价 = Decode(上次采购价, Null, n_成本价, 上次采购价), 平均成本价 = Decode(平均成本价, Null, n_成本价, 平均成本价),
            商品条码 = Decode(商品条码, Null, c_收发.商品条码, 商品条码), 内部条码 = Decode(内部条码, Null, c_收发.内部条码, 内部条码),
            效期 = Decode(效期, Null, c_收发.效期, 效期), 上次批号 = Decode(上次批号, Null, c_收发.批号, 上次批号),
            上次生产日期 = Decode(上次生产日期, Null, c_收发.生产日期, 上次生产日期), 上次产地 = Decode(上次产地, Null, c_收发.产地, 上次产地)
        Where 库房id + 0 = n_库房id And 药品id = c_收发.药品id And 性质 = 1 And Nvl(批次, 0) = n_批次_Cur;
      End If;
    
      If Sql%RowCount = 0 Then
        If n_上次采购价 = 0 Then
          If Nvl(c_收发.实际数量, 0) = 0 Then
            n_上次采购价 := Round(n_成本金额, 5);
          Else
            n_上次采购价 := Round(n_成本金额 / c_收发.实际数量, 5);
          End If;
        
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次批号, 上次产地, 上次供应商id, 上次采购价, 上次生产日期, 批准文号, 效期, 零售价, 商品条码, 内部条码,
             平均成本价)
          Values
            (n_库房id, c_收发.药品id, n_批次_Cur, 1, 0 - c_收发.实际数量, 0 - c_收发.实际数量, 0 - c_收发.实际金额, 0 - n_实际差价, v_批号, v_上次产地,
             n_上次供应商id, n_上次采购价, d_上次生产日期, v_批准文号, d_效期,
             Decode(n_实价卫材, 1, Decode(Nvl(n_批次_Cur, 0), 0, Null, c_收发.零售价), Null), c_收发.商品条码, c_收发.内部条码, n_上次采购价);
        End If;
      
      End If;
      Delete 药品库存
      Where 性质 = 1 And 库房id + 0 = n_库房id And 药品id = c_收发.药品id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And
            Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0;
    
      If v_备货 = 1 Then
        --审核备货卫材在虚拟库房的其他出库单据
        For v_出库 In (Select 序号, NO, 库房id, 药品id, Nvl(批次, 0) As 批次, 实际数量, 成本价, 成本金额, 零售金额, 差价, 入出类别id
                     From 药品收发记录
                     Where 单据 = 21 And 审核日期 Is Null And 药品id = c_收发.药品id And Nvl(批次, 0) = c_收发.批次 And 费用id = c_收发.费用id) Loop
        
          Update 药品收发记录
          Set 汇总发药号 = n_Id
          Where 单据 = 21 And 审核日期 Is Null And 药品id = c_收发.药品id And Nvl(批次, 0) = c_收发.批次 And 费用id = c_收发.费用id;
        
          Zl_材料其他出库_Verify(v_出库.序号, v_出库.No, v_出库.库房id, v_出库.药品id, v_出库.批次, v_出库.实际数量, v_出库.成本价, v_出库.成本金额, v_出库.零售金额,
                           v_出库.差价, v_出库.入出类别id, 审核人_In, 审核日期_In);
        End Loop;
      
        --产生备货卫材在卫材仓库的外购入库单据
        For v_入库 In (Select NO, 序号, 供药单位id, 药品id, 产地, 批号, 生产日期, 效期, 灭菌日期, 灭菌效期, 实际数量, 成本价, 成本金额, 扣率, 零售价, 零售金额, 差价, 摘要,
                            注册证号, Nvl(批次, 0) As 批次, 商品条码, 内部条码
                     From 药品收发记录
                     Where 单据 = 21 And 审核日期 Is Not Null And 药品id = c_收发.药品id And Nvl(批次, 0) = c_收发.批次 And
                           费用id = c_收发.费用id And 汇总发药号 = n_Id) Loop
          Begin
            Select 库房id Into v_入库库房id From 虚拟库房对照 Where 科室id = c_收发.库房id;
          Exception
            When Others Then
              v_入库库房id := 0;
          End;
        
          If v_入库库房id > 0 Then
          
            --同一张发料单产生的入库单的NO要一致
            Select Max(NO), Max(序号) + 1
            Into v_入库no, n_序号
            From 药品收发记录
            Where 单据 = 15 And 审核日期 Is Null And 供药单位id = v_入库.供药单位id And
                  费用id In
                  (Select Distinct 费用id
                   From 药品收发记录
                   Where 单据 = 21 And 审核日期 Is Not Null And
                         NO = (Select Distinct NO
                               From 药品收发记录
                               Where 单据 = 21 And 审核日期 Is Not Null And 费用id = c_收发.费用id And 汇总发药号 = n_Id));
          
            If v_入库no Is Null Or v_入库no = '' Then
              --如果入库NO为Null, 产生新的入库单NO
              v_入库no := Nextno(68, v_入库库房id);
              n_序号   := 1;
            End If;
          
            Begin
              If n_门诊标志 = 1 Then
                Select b.名称 || ',' || a.姓名 || ',' || a.标识号 || ',' || '' As 病人信息
                Into v_病人信息
                From 门诊费用记录 A, 部门表 B
                Where a.病人科室id = b.Id And a.Id = c_收发.费用id;
              Else
                Select b.名称 || ',' || a.姓名 || ',' || a.标识号 || ',' || a.床号 As 病人信息
                Into v_病人信息
                From 住院费用记录 A, 部门表 B
                Where a.病人科室id = b.Id And a.Id = c_收发.费用id;
              End If;
            Exception
              When Others Then
                v_病人信息 := '';
            End;
          
            Zl_材料外购_Insert(v_入库no, n_序号, v_入库库房id, v_入库.供药单位id, v_入库.药品id, v_入库.产地, v_入库.批号, v_入库.生产日期, v_入库.效期,
                           v_入库.灭菌日期, v_入库.灭菌效期, v_入库.实际数量, v_入库.成本价, v_入库.成本金额, v_入库.扣率, v_入库.零售价, v_入库.零售金额, v_入库.差价,
                           Null, '【自动入账】' || v_入库.摘要, v_入库.注册证号, 审核人_In, Null, Null, Null, Null, 审核日期_In, Null, Null,
                           v_入库.批次, 1, v_病人信息, v_入库.商品条码, v_入库.内部条码, c_收发.费用id);
          End If;
        End Loop;
      End If;
    End Loop;
    --修正误差数据
    Zl_材料收发记录_调价修正(n_Id);
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_批量发料;
/

--110234:李业庆,2017-07-07,无库存发料平均成本价字段为空处理
Create Or Replace Procedure Zl_材料收发记录_处方发料
(
  Partid_In   In 药品收发记录.库房id%Type,
  Bill_In     In 药品收发记录.单据%Type,
  No_In       In 药品收发记录.No%Type,
  People_In   In 药品收发记录.审核人%Type,
  配药人_In   In 药品收发记录.配药人%Type := Null,
  校验人_In   In 药品收发记录.填制人%Type := Null,
  发药方式_In In 药品收发记录.发药方式%Type := 1,
  发药时间_In In 药品收发记录.审核日期%Type := Null
) Is
  --重新计算用
  Cursor c_Modifybill Is
    Select a.Id, a.药品id, a.入出类别id, a.入出系数, a.费用id, a.供药单位id, a.生产日期, a.批准文号, a.灭菌效期, a.效期, a.产地,
           Nvl(a.实际数量, 0) * Nvl(a.付数, 1) 数量, Nvl(a.零售金额, 0) 金额, Nvl(a.批次, 0) 批次, a.批号, 2 As 病人来源, a.库房id, a.内部条码, a.商品条码
    From 药品收发记录 A, 住院费用记录 B
    Where a.No = No_In And a.单据 = Bill_In And (a.库房id + 0 = Partid_In Or a.库房id Is Null) And Nvl(a.摘要, '拒发否') <> '拒发' And
          a.费用id = b.Id And b.执行状态 <> 1 And Mod(a.记录状态, 3) = 1 And a.审核人 Is Null
    Union All
    Select a.Id, a.药品id, a.入出类别id, a.入出系数, a.费用id, a.供药单位id, a.生产日期, a.批准文号, a.灭菌效期, a.效期, a.产地,
           Nvl(a.实际数量, 0) * Nvl(a.付数, 1) 数量, Nvl(a.零售金额, 0) 金额, Nvl(a.批次, 0) 批次, a.批号, 1 As 病人来源, a.库房id, a.内部条码, a.商品条码
    From 药品收发记录 A, 门诊费用记录 B
    Where a.No = No_In And a.单据 = Bill_In And (a.库房id + 0 = Partid_In Or a.库房id Is Null) And Nvl(a.摘要, '拒发否') <> '拒发' And
          a.费用id = b.Id And b.执行状态 <> 1 And Mod(a.记录状态, 3) = 1 And a.审核人 Is Null
    Order By 药品id;

  v_Modifybill c_Modifybill%RowType;

  --只读变量
  n_库存金额 药品库存.实际金额%Type;
  n_库存差价 药品库存.实际差价%Type;
  n_差价率   材料特性.指导差价率%Type;

  --可写变量
  n_成本金额       药品收发记录.成本金额%Type;
  n_成本价         药品收发记录.成本价%Type;
  n_实际差价       药品收发记录.差价%Type;
  d_操作时间       药品收发记录.审核日期%Type;
  n_收费与发料分离 Number(1);
  n_小数           Number(1);
  v_入库no         药品收发记录.No%Type;
  v_入库库房id     药品收发记录.库房id%Type := 0;
  v_病人信息       Varchar2(200);
  v_备货           Number(1);
  n_序号           Number;
  n_平均成本价     药品库存.平均成本价%Type;
Begin
  If 发药时间_In Is Null Then
    Select Sysdate Into d_操作时间 From Dual;
  Else
    d_操作时间 := 发药时间_In;
  End If;

  Begin
    Select 0 Into n_收费与发料分离 From 未发药品记录 Where 单据 = Bill_In And NO = No_In And 库房id + 0 = Partid_In;
  Exception
    When Others Then
      n_收费与发料分离 := 1;
  End;

  --获取金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into n_小数 From Dual;

  --重写已发料处方的配药人
  Update 药品收发记录
  Set 配药人 = Decode(配药人_In, Null, 配药人, 配药人_In)
  Where NO = No_In And 单据 = Bill_In And (库房id + 0 = Partid_In Or 库房id Is Null) And Mod(记录状态, 3) = 1 And 审核人 Is Not Null;

  --重新计算成本价、成本金额、零售金额及差价
  For v_Modifybill In c_Modifybill Loop
    n_成本价   := Round(Zl_Fun_Getoutcost(v_Modifybill.药品id, v_Modifybill.批次, Partid_In), n_小数);
    n_成本金额 := Round(n_成本价 * v_Modifybill.数量, n_小数);
    n_实际差价 := Round(Nvl(v_Modifybill.金额, 0) - n_成本金额, n_小数);
  
    --更新药品收发记录的零售金额、成本金额及差价
    Update 药品收发记录 Set 成本价 = n_成本价, 成本金额 = n_成本金额, 差价 = n_实际差价 Where ID = v_Modifybill.Id;
  
    If n_收费与发料分离 = 1 Then
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) - Nvl(v_Modifybill.数量, 0), 实际数量 = Nvl(实际数量, 0) - Nvl(v_Modifybill.数量, 0),
          实际金额 = Nvl(实际金额, 0) - Nvl(v_Modifybill.金额, 0), 实际差价 = Nvl(实际差价, 0) - n_实际差价,
          上次采购价 = Decode(上次采购价, Null, n_成本价, 上次采购价), 平均成本价 = Decode(平均成本价, Null, n_成本价, 平均成本价),
          商品条码 = Decode(商品条码, Null, v_Modifybill.商品条码, 商品条码), 内部条码 = Decode(内部条码, Null, v_Modifybill.内部条码, 内部条码),
          效期 = Decode(效期, Null, v_Modifybill.效期, 效期), 上次批号 = Decode(上次批号, Null, v_Modifybill.批号, 上次批号),
          上次生产日期 = Decode(上次生产日期, Null, v_Modifybill.生产日期, 上次生产日期), 上次产地 = Decode(上次产地, Null, v_Modifybill.产地, 上次产地)
      Where 库房id + 0 = Partid_In And 药品id = v_Modifybill.药品id And 性质 = 1 And Nvl(批次, 0) = v_Modifybill.批次;
    Else
      Update 药品库存
      Set 实际数量 = Nvl(实际数量, 0) - Nvl(v_Modifybill.数量, 0), 实际金额 = Nvl(实际金额, 0) - Nvl(v_Modifybill.金额, 0),
          实际差价 = Nvl(实际差价, 0) - n_实际差价, 上次采购价 = Decode(上次采购价, Null, n_成本价, 上次采购价),
          平均成本价 = Decode(平均成本价, Null, n_成本价, 平均成本价), 商品条码 = Decode(商品条码, Null, v_Modifybill.商品条码, 商品条码),
          内部条码 = Decode(内部条码, Null, v_Modifybill.内部条码, 内部条码), 效期 = Decode(效期, Null, v_Modifybill.效期, 效期),
          上次批号 = Decode(上次批号, Null, v_Modifybill.批号, 上次批号), 上次生产日期 = Decode(上次生产日期, Null, v_Modifybill.生产日期, 上次生产日期),
          上次产地 = Decode(上次产地, Null, v_Modifybill.产地, 上次产地)
      Where 库房id + 0 = Partid_In And 药品id = v_Modifybill.药品id And 性质 = 1 And Nvl(批次, 0) = v_Modifybill.批次;
    End If;
  
    If Sql%RowCount = 0 Then
      If n_收费与发料分离 = 1 Then
        Insert Into 药品库存
          (库房id, 药品id, 批次, 性质, 实际数量, 实际金额, 实际差价, 效期, 灭菌效期, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 批准文号, 平均成本价)
        Values
          (Partid_In, v_Modifybill.药品id, v_Modifybill.批次, 1, 0 - Nvl(v_Modifybill.数量, 0), 0 - Nvl(v_Modifybill.金额, 0),
           0 - n_实际差价, v_Modifybill.效期, v_Modifybill.灭菌效期, v_Modifybill.供药单位id, n_成本价, v_Modifybill.批号,
           v_Modifybill.生产日期, v_Modifybill.产地, v_Modifybill.批准文号, n_成本价);
      Else
        Insert Into 药品库存
          (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 效期, 灭菌效期, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 批准文号, 平均成本价)
        Values
          (Partid_In, v_Modifybill.药品id, v_Modifybill.批次, 1, 0 - Nvl(v_Modifybill.数量, 0), 0 - Nvl(v_Modifybill.数量, 0),
           0 - Nvl(v_Modifybill.金额, 0), 0 - n_实际差价, v_Modifybill.效期, v_Modifybill.灭菌效期, v_Modifybill.供药单位id, n_成本价,
           v_Modifybill.批号, v_Modifybill.生产日期, v_Modifybill.产地, v_Modifybill.批准文号, n_成本价);
      End If;
    End If;
  
    Delete 药品库存
    Where 库房id + 0 = Partid_In And 药品id = v_Modifybill.药品id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And
          Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0 And 性质 = 1;
  
    --更新病人费用记录的执行状态(已执行)
    If v_Modifybill.病人来源 = 2 Then
      Update 住院费用记录
      Set 执行状态 = 1, 执行人 = Decode(People_In, Null, Zl_Username, People_In), 执行时间 = 发药时间_In
      Where ID = v_Modifybill.费用id;
    Else
      Update 门诊费用记录
      Set 执行状态 = 1, 执行人 = Decode(People_In, Null, Zl_Username, People_In), 执行时间 = 发药时间_In
      Where ID = v_Modifybill.费用id;
    End If;
    --写审核人
    Update 药品收发记录
    Set 库房id = Partid_In, 配药人 = Decode(配药人_In, Null, 配药人, 配药人_In), 填制人 = Decode(校验人_In, Null, 填制人, 校验人_In),
        审核人 = People_In, 审核日期 = d_操作时间, 发药方式 = 发药方式_In
    Where ID = v_Modifybill.Id;
    --修正误差数据
    Zl_材料收发记录_调价修正(v_Modifybill.Id);
  
    Begin
      Select 1
      Into v_备货
      From 药品收发记录
      Where 单据 = 21 And 审核日期 Is Null And 药品id = v_Modifybill.药品id And Nvl(批次, 0) = v_Modifybill.批次 And
            费用id = v_Modifybill.费用id And Rownum = 1;
    Exception
      When Others Then
        v_备货 := 0;
    End;
  
    If v_备货 = 1 Then
      --审核备货卫材在虚拟库房的其他出库单据
      For v_出库 In (Select 序号, NO, 库房id, 药品id, Nvl(批次, 0) As 批次, 实际数量, 成本价, 成本金额, 零售金额, 差价, 入出类别id
                   From 药品收发记录
                   Where 单据 = 21 And 审核日期 Is Null And 药品id = v_Modifybill.药品id And Nvl(批次, 0) = v_Modifybill.批次 And
                         费用id = v_Modifybill.费用id) Loop
      
        Update 药品收发记录
        Set 汇总发药号 = v_Modifybill.Id
        Where 单据 = 21 And 审核日期 Is Null And 药品id = v_Modifybill.药品id And Nvl(批次, 0) = v_Modifybill.批次 And
              费用id = v_Modifybill.费用id;
      
        Zl_材料其他出库_Verify(v_出库.序号, v_出库.No, v_出库.库房id, v_出库.药品id, v_出库.批次, v_出库.实际数量, v_出库.成本价, v_出库.成本金额, v_出库.零售金额,
                         v_出库.差价, v_出库.入出类别id, People_In, d_操作时间);
      End Loop;
    
      --产生备货卫材在卫材仓库的外购入库单据
      For v_入库 In (Select NO, 序号, 供药单位id, 药品id, 产地, 批号, 生产日期, 效期, 灭菌日期, 灭菌效期, 实际数量, 成本价, 成本金额, 扣率, 零售价, 零售金额, 差价, 摘要,
                          注册证号, Nvl(批次, 0) As 批次, 商品条码, 内部条码
                   From 药品收发记录
                   Where 单据 = 21 And 审核日期 Is Not Null And 药品id = v_Modifybill.药品id And Nvl(批次, 0) = v_Modifybill.批次 And
                         费用id = v_Modifybill.费用id And 汇总发药号 = v_Modifybill.Id) Loop
        Begin
          Select 库房id Into v_入库库房id From 虚拟库房对照 Where 科室id = v_Modifybill.库房id;
        Exception
          When Others Then
            v_入库库房id := 0;
        End;
      
        If v_入库库房id > 0 Then
        
          --同一张发料单产生的入库单的NO要一致
          Select Max(NO), Max(序号) + 1
          Into v_入库no, n_序号
          From 药品收发记录
          Where 单据 = 15 And 审核日期 Is Null And 供药单位id = v_入库.供药单位id And
                费用id In (Select Distinct 费用id
                         From 药品收发记录
                         Where 单据 = 21 And 审核日期 Is Not Null And
                               NO = (Select Distinct NO
                                     From 药品收发记录
                                     Where 单据 = 21 And 审核日期 Is Not Null And 费用id = v_Modifybill.费用id));
        
          If v_入库no Is Null Or v_入库no = '' Then
            --如果入库NO为Null, 产生新的入库单NO
            v_入库no := Nextno(68, v_入库库房id);
            n_序号   := 1;
          End If;
        
          Begin
            If v_Modifybill.病人来源 = 1 Then
              Select b.名称 || ',' || a.姓名 || ',' || a.标识号 || ',' || '' As 病人信息
              Into v_病人信息
              From 门诊费用记录 A, 部门表 B
              Where a.病人科室id = b.Id And a.Id = v_Modifybill.费用id;
            Else
              Select b.名称 || ',' || a.姓名 || ',' || a.标识号 || ',' || a.床号 As 病人信息
              Into v_病人信息
              From 住院费用记录 A, 部门表 B
              Where a.病人科室id = b.Id And a.Id = v_Modifybill.费用id;
            End If;
          Exception
            When Others Then
              v_病人信息 := '';
          End;
        
          Zl_材料外购_Insert(v_入库no, n_序号, v_入库库房id, v_入库.供药单位id, v_入库.药品id, v_入库.产地, v_入库.批号, v_入库.生产日期, v_入库.效期,
                         v_入库.灭菌日期, v_入库.灭菌效期, v_入库.实际数量, v_入库.成本价, v_入库.成本金额, v_入库.扣率, v_入库.零售价, v_入库.零售金额, v_入库.差价,
                         Null, '【自动入账】' || v_入库.摘要, v_入库.注册证号, People_In, Null, Null, Null, Null, d_操作时间, Null, Null,
                         v_入库.批次, 1, v_病人信息, v_入库.商品条码, v_入库.内部条码, v_Modifybill.费用id);
        End If;
      End Loop;
    End If;
  End Loop;

  --更新或删除未发药品记录
  Delete 未发药品记录 Where NO = No_In And 单据 = Bill_In And (库房id + 0 = Partid_In Or 库房id Is Null);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料收发记录_处方发料;
/

--111266:冉俊明,2017-07-10,转病区费用调整
--111199:冉俊明,2017-07-07,转病区费用
Create Or Replace Procedure Zl_住院记帐记录_Delete
(
  No_In           住院费用记录.No%Type,
  序号_In         Varchar2,
  操作员编号_In   住院费用记录.操作员编号%Type,
  操作员姓名_In   住院费用记录.操作员姓名%Type,
  记录性质_In     住院费用记录.记录性质%Type := 2,
  操作状态_In     Number := 0,
  输液配药检查_In Number := 1,
  登记时间_In     住院费用记录.登记时间%Type := Sysdate
) As
  --功能：冲销一张住院记帐单据中指定序号行
  --序号：格式如"1,3,5,7,8",或"1:2:33456,3:2,5:2,7:2,8:2",冒号前面的数字表示行号,中间的数字表示退的数量,后面的数字表示配药记录的ID,目前仅在销帐审核时才传入
  --      为空表示冲销所有可冲销行
  --记录性质:    2-人工记帐单,3-自动记帐单
  --输液配药检查:    0-医嘱调用，不检查药品是否进入输液配药中心；1-非医嘱调用，检查药品是否进入配药中心
  --该光标用于销帐指定费用行
  --操作状态_In:0-表示直接销帐;1-表示审核销帐(通过销帐申请-->销帐审核流程);2-表示转病区费用
  --该游标为要退费单据的所有原始记录
  Cursor c_Bill Is
    Select ID, 价格父号, 序号, 执行状态, 记录性质, 收费类别, 医嘱序号, 收费细目id, 病人id, 主页id, 收入项目id, 开单部门id, 病人科室id, 执行部门id, 病人病区id, 付数, 数次
    From 住院费用记录
    Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 In (0, 1, 3) And 门诊标志 = 2
    Order By 收费细目id, 序号;

  --该游标用于处理药品库存可用数量
  --不要管费用的执行状态,因为先于此步处理
  Cursor c_Stock(v_序号_In Varchar2) Is
    Select ID, 单据, NO, 库房id, 药品id, 批次, 发药方式, 付数, 实际数量, 灭菌效期, 效期, 产地, 批号, 填制日期, 费用id, 商品条码, 内部条码
    From 药品收发记录
    Where NO = No_In And 单据 In (9, 10, 25, 26) And Mod(记录状态, 3) = 1 And 审核人 Is Null And
          费用id In (Select ID
                   From 住院费用记录
                   Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 In (0, 1, 3) And 收费类别 In ('4', '5', '6', '7') And
                         门诊标志 = 2 And (Instr(',' || v_序号_In || ',', ',' || 序号 || ',') > 0 Or v_序号_In Is Null))
    Order By 药品id, 填制日期 Desc;

  r_Stock c_Stock%RowType;
  --该游标用于处理费用记录序号
  Cursor c_Serial Is
    Select 序号, 价格父号
    From 住院费用记录
    Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 In (0, 1, 3)
    Order By 序号;

  Cursor Cr_药品 Is
    Select ID, 单据, NO, 库房id, 药品id, 批次, 发药方式, 0 As 数量, 灭菌效期, 效期, 产地, 批号, 填制日期, 费用id
    From 药品收发记录
    Where Rownum <= 1;
  v_药品 Cr_药品%RowType;

  v_医嘱id 病人医嘱记录.Id%Type;
  n_划价   Number;
  v_父号   住院费用记录.价格父号%Type;
  v_序号   Varchar2(2000);
  v_Tmp    Varchar2(4000);

  v_医嘱ids    Varchar2(4000);
  l_药品收发   t_Numlist := t_Numlist();
  l_划价       t_Numlist := t_Numlist();
  l_费用id     t_Numlist := t_Numlist();
  n_付数       Number;
  n_虚拟库房id 药品收发记录.库房id%Type;
  n_其他出库id 药品收发记录.Id%Type;
  n_库房id     药品收发记录.库房id%Type;
  n_返回值     Number;
  --部分退费计算变量
  v_剩余数量 Number;
  v_剩余应收 Number;
  v_剩余实收 Number;
  v_剩余统筹 Number;

  v_准退数量 Number;
  v_退费次数 Number;
  v_应收金额 Number;
  v_实收金额 Number;
  v_统筹金额 Number;
  n_Temp     Number;
  n_部分销帐 Number;
  v_Dec      Number;
  n_Count    Number;
  v_Curdate  Date;
  Err_Item Exception;
  v_Err_Msg        Varchar2(255);
  n_备货卫材       Number;
  n_病人id         病案主页.病人id%Type;
  n_主页id         病案主页.主页id%Type;
  n_审核标志       病案主页.审核标志%Type;
  n_住院状态       病案主页.状态%Type;
  n_病人审核方式   Number(2);
  n_未入科禁止记账 Number(2);
  v_配药id         Varchar2(4000);
  Type Ty_药品 Is Ref Cursor;
  c_药品 Ty_药品; --游标变量

Begin
  --销帐审核时,非药品会传入行号的销帐数量
  If Not 序号_In Is Null Then
    If Instr(序号_In, ':') > 0 Then
      v_Tmp := 序号_In || ',';
      While Not v_Tmp Is Null Loop
        v_序号 := v_序号 || ',' || Substr(v_Tmp, 1, Instr(v_Tmp, ':') - 1);
        If Instr(Substr(v_Tmp, Instr(v_Tmp, ':') + 1, Instr(v_Tmp, ',') - Instr(v_Tmp, ':') - 1), ':') > 0 Then
          v_配药id := v_配药id || ',' ||
                    Substr(v_Tmp, Instr(v_Tmp, ':', 1, 2) + 1, Instr(v_Tmp, ',') - Instr(v_Tmp, ':', 1, 2) - 1);
        End If;
        v_Tmp := Substr(v_Tmp, Instr(v_Tmp, ',') + 1);
      End Loop;
      v_序号 := Substr(v_序号, 2);
      If v_配药id Is Not Null Then
        v_配药id := Substr(v_配药id, 2);
      End If;
    Else
      v_序号 := 序号_In;
    End If;
  End If;

  --是否已经全部完全执行(只是整张单据的检查)
  Select Nvl(Count(*), 0), Nvl(Max(病人id), 0), Nvl(Max(主页id), 0)
  Into n_Count, n_病人id, n_主页id
  From 住院费用记录
  Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 In (0, 1, 3) And Nvl(执行状态, 0) <> 1 And 门诊标志 = 2;
  If n_Count = 0 Then
    v_Err_Msg := '该单据中的项目已经全部完全执行！';
    Raise Err_Item;
  End If;

  n_病人审核方式   := Nvl(zl_GetSysParameter(185), 0);
  n_未入科禁止记账 := Nvl(zl_GetSysParameter(215), 0);
  If n_病人审核方式 = 1 Or n_未入科禁止记账 = 1 Then
  
    Begin
      Select 审核标志, 状态 Into n_审核标志, n_住院状态 From 病案主页 Where 病人id = n_病人id And 主页id = n_主页id;
    Exception
      When Others Then
        n_审核标志 := 0;
        n_住院状态 := 0;
    End;
    If n_未入科禁止记账 = 1 And n_住院状态 = 1 Then
      v_Err_Msg := '病人未入科,禁止对病人相关费用的操作!';
      Raise Err_Item;
    End If;
  
    If n_病人审核方式 = 1 Then
    
      If Nvl(n_审核标志, 0) = 1 Then
        v_Err_Msg := '该病人目前正在审核费用,不能进行费用相关调整!';
        Raise Err_Item;
      End If;
      If Nvl(n_审核标志, 0) = 2 Then
        v_Err_Msg := '该病人目前已经完成了费用审核,不能进行费用相关调整!';
        Raise Err_Item;
      End If;
    End If;
  End If;

  --未完全执行的项目是否有剩余数量(只是整张单据的检查)
  Select Nvl(Count(*), 0)
  Into n_Count
  From (Select 序号, Sum(数量) As 剩余数量
         From (Select 记录状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                From 住院费用记录
                Where NO = No_In And 记录性质 = 记录性质_In And 门诊标志 = 2 And
                      Nvl(价格父号, 序号) In
                      (Select Nvl(价格父号, 序号)
                       From 住院费用记录
                       Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 In (0, 1, 3) And Nvl(执行状态, 0) <> 1)
                Group By 记录状态, Nvl(价格父号, 序号))
         Group By 序号
         Having Sum(数量) <> 0);
  If n_Count = 0 Then
    v_Err_Msg := '该单据中未完全执行部分项目剩余数量为零,没有可以销帐的费用！';
    Raise Err_Item;
  End If;

  --医嘱费用：检查正在执行的医嘱(注意已执行的情况在下面检查,因为不传 序号_IN 这种情况费用界面已限制)
  If Nvl(操作状态_In, 0) = 0 Then
    --走销帐申请流程的，不检查医保执行状态
    Select Nvl(Count(*), 0)
    Into n_Count
    From 病人医嘱发送
    Where 执行状态 = 3 And (NO, 记录性质, 医嘱id) In
          (Select NO, 记录性质, 医嘱序号
                        From 住院费用记录
                        Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 In (0, 1, 3) And 医嘱序号 Is Not Null And
                              (Instr(',' || v_序号 || ',', ',' || 序号 || ',') > 0 Or v_序号 Is Null));
    If n_Count > 0 Then
      v_Err_Msg := '要销帐的费用中存在对应的医嘱正在执行的情况，不能销帐！';
      Raise Err_Item;
    End If;
  End If;

  ---------------------------------------------------------------------------------
  --先打开药品对应数据集,以确保当前条件下有数据,为了处理并发判断
  --不能在游标条件中取消"审核人 is Null"条件，因为多次退药可能部份又已发
  Open c_Stock(v_序号);

  --公用变量
  Select 登记时间_In Into v_Curdate From Dual;

  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into v_Dec From Dual;

  For c_编目病案 In (Select a.姓名
                 From 病人信息 A, 病案主页 B
                 Where a.病人id = b.病人id And b.编目日期 Is Not Null And
                       (b.病人id, b.主页id) In
                       (Select Distinct 病人id, 主页id
                        From 住院费用记录
                        Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 In (0, 1, 3) And 门诊标志 = 2)) Loop
    v_Err_Msg := '病人『' || c_编目病案.姓名 || '』 已经被病案编目,不能被销帐！';
    Raise Err_Item;
  End Loop;
  v_医嘱ids := Null;
  --循环处理每行费用(收入项目行)
  For r_Bill In c_Bill Loop
    --检查已经存在病案编目的,则不能进行销帐处理
    If Instr(',' || v_序号 || ',', ',' || Nvl(r_Bill.价格父号, r_Bill.序号) || ',') > 0 Or v_序号 Is Null Then
      Select Decode(记录状态, 0, 1, 0) Into n_划价 From 住院费用记录 Where ID = r_Bill.Id;
      If Nvl(r_Bill.执行状态, 0) <> 1 Then
        --求剩余数量,剩余应收,剩余实收
        Select Sum(Nvl(付数, 1) * 数次), Sum(应收金额), Sum(实收金额), Sum(统筹金额)
        Into v_剩余数量, v_剩余应收, v_剩余实收, v_剩余统筹
        From 住院费用记录
        Where NO = No_In And 记录性质 = 记录性质_In And 序号 = r_Bill.序号;
        n_部分销帐 := 0;
        If v_剩余数量 = 0 Then
          If v_序号 Is Not Null Then
            v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经全部销帐！';
            Raise Err_Item;
          End If;
          --情况：未限定行号,原始单据中的该笔已经全部销帐(执行状态=0的一种可能)
        Else
        
          If Instr(序号_In, ':') > 0 Then
            v_Tmp := ',' || 序号_In;
            v_Tmp := Substr(v_Tmp, Instr(v_Tmp, ',' || r_Bill.序号 || ':') + Length(',' || r_Bill.序号 || ':'));
            v_Tmp := Substr(v_Tmp, 1, Instr(v_Tmp || ',', ',') - 1);
            If Instr(v_Tmp, ':') > 0 Then
              v_Tmp := Substr(v_Tmp, 1, Instr(v_Tmp, ':') - 1);
            End If;
            v_准退数量 := v_Tmp;
            n_部分销帐 := 1;
          End If;
        
          --准销数量(非药品项目为剩余数量,原始数量)
          If Instr(',4,5,6,7,', r_Bill.收费类别) = 0 Then
            If Instr(序号_In, ':') = 0 Or 序号_In Is Null Then
              v_准退数量 := v_剩余数量;
            End If;
          Else
            --医嘱超期收回时,卫材可能没有发放,但申请销帐的是部分数量,所以要以申请的为准
            If Instr(序号_In, ':') = 0 Or 序号_In Is Null Then
              Select Nvl(Sum(Nvl(付数, 1) * 实际数量), 0), Count(*)
              Into v_准退数量, n_Count
              From 药品收发记录
              Where NO = No_In And 单据 In (9, 10, 25, 26) And Mod(记录状态, 3) = 1 And 审核人 Is Null And 费用id = r_Bill.Id;
            End If;
          
            --有剩余数量无准退数量的有两种情况：
            --1.不跟踪在用的卫材无对应的收发记录,这时使用剩余数量
            --2.并发操作,此时已发药或发料
            If v_准退数量 = 0 Then
              If r_Bill.收费类别 = '4' Then
                If n_Count > 0 Then
                  v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发料,须退料后再退费！';
                  Raise Err_Item;
                Else
                  v_准退数量 := v_剩余数量;
                End If;
              Else
                v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发药,须退药后再退费！';
                Raise Err_Item;
              End If;
            End If;
          End If;
        
          --处理住院费用记录
          If Nvl(n_划价, 0) = 0 Then
            --划价时,直接更改数量,所以不须查划冲销次数
            --该笔项目第几次销帐
            Select Nvl(Max(Abs(执行状态)), 0) + 1
            Into v_退费次数
            From 住院费用记录
            Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 = 2 And 序号 = r_Bill.序号 And 门诊标志 = 2;
          End If;
        
          --金额=剩余金额*(准退数/剩余数)
          v_应收金额 := Round(v_剩余应收 * (v_准退数量 / v_剩余数量), v_Dec);
          v_实收金额 := Round(v_剩余实收 * (v_准退数量 / v_剩余数量), v_Dec);
          v_统筹金额 := Round(v_剩余统筹 * (v_准退数量 / v_剩余数量), v_Dec);
          If Nvl(n_划价, 0) = 1 Then
            If Nvl(n_部分销帐, 0) = 0 Then
              l_划价.Extend;
              l_划价(l_划价.Count) := r_Bill.Id;
              n_返回值 := 0;
            Else
              --更新数量
              --划价的,先将相关的数据处理在内部表集中
              n_付数 := 0;
              If r_Bill.付数 > 1 Then
                --如果是中药,超期回收肯定是回收的付数,而不是次数.因此,需要检查准退数量是否可以整 除
                If Trunc(v_准退数量 / r_Bill.数次) <> (v_准退数量 / r_Bill.数次) Then
                  v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用为中药,请按付数进行退费！';
                  Raise Err_Item;
                End If;
                n_付数 := Trunc(v_准退数量 / r_Bill.数次);
                If Nvl(r_Bill.付数, 0) - n_付数 < 0 Then
                  v_准退数量 := r_Bill.数次;
                Else
                  v_准退数量 := 0;
                End If;
              End If;
              Update 住院费用记录
              Set 付数 = 付数 - n_付数, 数次 = 数次 - v_准退数量, 应收金额 = Nvl(应收金额, 0) - v_应收金额, 实收金额 = Nvl(实收金额, 0) - v_实收金额,
                  登记时间 = v_Curdate, 统筹金额 = Nvl(统筹金额, 0) - v_统筹金额
              Where ID = r_Bill.Id
              Returning Nvl(数次, 0) * Nvl(付数, 0) Into n_返回值;
            End If;
            If Nvl(n_返回值, 0) <= 0 Then
              l_划价.Extend;
              l_划价(l_划价.Count) := r_Bill.Id;
            End If;
            If r_Bill.医嘱序号 Is Not Null Then
              If Instr(',' || Nvl(v_医嘱ids, '') || ',', ',' || r_Bill.医嘱序号 || ',') = 0 Then
                v_医嘱ids := Nvl(v_医嘱ids, '') || ',' || r_Bill.医嘱序号;
              End If;
              --记录病人医嘱附费对应的医嘱ID(不是主费用)
              If v_医嘱id Is Null Then
                v_医嘱id := r_Bill.医嘱序号;
              End If;
            End If;
          
          End If;
        
          If Nvl(n_划价, 0) = 0 Then
            --划价时,直接更改数量,所以不须查划冲销次数
            --插入退费记录
            Insert Into 住院费用记录
              (ID, NO, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 主页id, 病人id, 医嘱序号, 门诊标志, 多病人单, 婴儿费, 姓名, 性别, 年龄, 标识号, 床号, 费别, 病人病区id,
               病人科室id, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人,
               执行部门id, 划价人, 执行人, 执行状态, 执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 保险项目否, 保险大类id, 统筹金额, 保险编码, 记帐单id, 摘要, 费用类型, 是否急诊,
               结论, 医疗小组id)
              Select 病人费用记录_Id.Nextval, NO, 记录性质, 2, 序号, 从属父号, 价格父号, 主页id, 病人id, 医嘱序号, 门诊标志, 多病人单, 婴儿费, 姓名, 性别, 年龄, 标识号,
                     床号, 费别, 病人病区id, 病人科室id, 收费类别, 收费细目id, 计算单位, Decode(Sign(v_准退数量 - Nvl(付数, 1) * 数次), 0, 付数, 1), 发药窗口,
                     Decode(Sign(v_准退数量 - Nvl(付数, 1) * 数次), 0, -1 * 数次, -1 * v_准退数量), 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用,
                     标准单价, -1 * v_应收金额, -1 * v_实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, -1 * v_退费次数, 执行时间, 操作员编号_In,
                     操作员姓名_In, 发生时间, v_Curdate, 保险项目否, 保险大类id, -1 * v_统筹金额, 保险编码, 记帐单id, 摘要, 费用类型, 是否急诊, 结论, 医疗小组id
              From 住院费用记录
              Where ID = r_Bill.Id;
          
            --记录病人医嘱附费对应的医嘱ID(不是主费用)
            If v_医嘱id Is Null And r_Bill.医嘱序号 Is Not Null Then
              v_医嘱id := r_Bill.医嘱序号;
            End If;
          
            Update 病人审批项目
            Set 已用数量 = Nvl(已用数量, 0) - v_准退数量
            Where 病人id = r_Bill.病人id And 主页id = r_Bill.主页id And 项目id = r_Bill.收费细目id And Nvl(使用限量, 0) <> 0;
          
            --病人余额
            Update 病人余额
            Set 费用余额 = Nvl(费用余额, 0) - v_实收金额
            Where 病人id = r_Bill.病人id And 类型 = 2 And 性质 = 1;
            If Sql%RowCount = 0 Then
              Insert Into 病人余额
                (病人id, 类型, 性质, 费用余额, 预交余额)
              Values
                (r_Bill.病人id, 2, 1, -1 * v_实收金额, 0);
            End If;
          
            --病人未结费用
            Update 病人未结费用
            Set 金额 = Nvl(金额, 0) - v_实收金额
            Where 病人id = r_Bill.病人id And Nvl(主页id, 0) = Nvl(r_Bill.主页id, 0) And Nvl(病人病区id, 0) = Nvl(r_Bill.病人病区id, 0) And
                  Nvl(病人科室id, 0) = Nvl(r_Bill.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(r_Bill.开单部门id, 0) And
                  Nvl(执行部门id, 0) = Nvl(r_Bill.执行部门id, 0) And 收入项目id + 0 = r_Bill.收入项目id And 来源途径 + 0 = 2;
            If Sql%RowCount = 0 Then
              Insert Into 病人未结费用
                (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
              Values
                (r_Bill.病人id, r_Bill.主页id, r_Bill.病人病区id, r_Bill.病人科室id, r_Bill.开单部门id, r_Bill.执行部门id, r_Bill.收入项目id, 2,
                 -1 * v_实收金额);
            End If;
          
            --标记原费用记录
            --执行状态:全部退完(准退数=剩余数)标记为0,否则保持原状态
            If Instr(',4,5,6,7,', r_Bill.收费类别) = 0 Then
              --一般情况非药品和卫材的项目,不存在部分销帐的情况,只有销帐申请和销帐审核时,才会出现部分销帐,所以
              --执行状态只有两种:0.未执行;1已执行;
              --由于在销帐审核过程中将已执行强制改为了2部分执行,因此需要在此处改为1已执行.未执行的不变.
              Update 住院费用记录
              Set 记录状态 = 3, 执行状态 = Decode(Sign(v_准退数量 - v_剩余数量), 0, 0, Decode(执行状态, 2, 1, 执行状态))
              Where ID = r_Bill.Id;
            Else
              Update 住院费用记录
              Set 记录状态 = 3, 执行状态 = Decode(Sign(v_准退数量 - v_剩余数量), 0, 0, 执行状态)
              Where ID = r_Bill.Id;
            End If;
          End If;
        End If;
      Else
        If v_序号 Is Not Null Then
          v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经完全执行,不能销帐！';
          Raise Err_Item;
        End If;
        --情况:没限定行号,原始单据中包括已经完全执行的
      End If;
    End If;
  End Loop;

  If Nvl(操作状态_In, 0) = 2 Then
    --转病区费用时:
    --1.药品及跟踪在用的卫材不会调用该过程
    --2.划价记账单也不会调用该过程
    --3.不需要更改医嘱信息
    Return;
  End If;

  --不存在配药ID,检查该药品是否在输液配药中心
  If v_配药id Is Null And 输液配药检查_In = 1 Then
    For v_费用 In (Select ID
                 From 住院费用记录
                 Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 In (0, 1, 3) And 收费类别 In ('4', '5', '6', '7') And 门诊标志 = 2 And
                       (Instr(',' || v_序号 || ',', ',' || 序号 || ',') > 0 Or v_序号 Is Null)) Loop
      Begin
        Select Count(1)
        Into n_Count
        From 输液配药内容 A, 药品收发记录 B
        Where a.收发id = b.Id And b.费用id = v_费用.Id And Instr(',8,9,10,21,24,25,26,', ',' || b.单据 || ',') > 0;
      Exception
        When Others Then
          n_Count := 0;
      End;
      If n_Count <> 0 Then
        v_Err_Msg := '存在已经进入输液配药中心的待销帐药品，无法完成销帐！';
        Raise Err_Item;
      End If;
    End Loop;
  End If;

  n_部分销帐 := 0;
  ---------------------------------------------------------------------------------
  --药品相关处理:主要是对销帐审核有效.(可以是部分)
  For v_费用 In (Select ID, 序号, 收费类别
               From 住院费用记录
               Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 In (0, 1, 3) And 收费类别 In ('4', '5', '6', '7') And 门诊标志 = 2 And
                     (Instr(',' || v_序号 || ',', ',' || 序号 || ',') > 0 Or v_序号 Is Null)
               Order By 收费细目id) Loop
    --根据费用ID来进行相关的处理
    v_准退数量 := 0;
    If Instr(序号_In, ':') > 0 Then
      v_Tmp := ',' || 序号_In;
      v_Tmp := Substr(v_Tmp, Instr(v_Tmp, ',' || v_费用.序号 || ':') + Length(',' || v_费用.序号 || ':'));
      v_Tmp := Substr(v_Tmp, 1, Instr(v_Tmp || ',', ',') - 1);
      If Instr(v_Tmp, ':') > 0 Then
        v_Tmp := Substr(v_Tmp, 1, Instr(v_Tmp, ':') - 1);
      End If;
      v_准退数量 := v_Tmp;
    End If;
    If v_准退数量 <> 0 Then
      n_部分销帐 := 1;
      n_Temp     := 0;
      --------------------------------------------------------------------------------------
      --检查是否备货记帐卫材,规则如下
      -- a.如果存在存在未审核的其他出库且部分销帐时,直接在原来的基础上更改其他出库数量
      -- b.如果存在存在未审核的其他出库且完全销帐时,直接删除
      -- c.库存处理:还原为虚拟库房的可用数量;发料部门不处理
      -- d.如果已经发了料,这个时间由于其他出库单已经审核,因此就按正常情况流转,库存恢复到发料部门中
      n_虚拟库房id := Null;
      n_其他出库id := Null;
      If v_费用.收费类别 = '4' Then
        Begin
          Select 1, 库房id, ID
          Into n_备货卫材, n_虚拟库房id, n_其他出库id
          From 药品收发记录
          Where 费用id = v_费用.Id And 审核日期 Is Null And 单据 = 21 And Rownum = 1;
        Exception
          When Others Then
            n_备货卫材 := 0;
        End;
      Else
        n_备货卫材 := 0;
      End If;
      --------------------------------------------------------------------------------------
      If v_配药id Is Not Null Then
        Open c_药品 For
          Select /*+ rule*/
           a.Id, a.单据, a.No, a.库房id, a.药品id, a.批次, a.发药方式,
           Decode(a.发药方式, Null, 1, -1, 0, 1) * Nvl(a.付数, 1) * Nvl(a.实际数量, 0) As 数量, a.灭菌效期, a.效期, a.产地, a.批号, a.填制日期,
           a.费用id
          From 药品收发记录 A, Table(f_Str2list(v_配药id)) B, 输液配药内容 C
          Where a.No = No_In And a.单据 In (9, 10, 25, 26) And Mod(a.记录状态, 3) = 1 And a.审核人 Is Null And a.费用id = v_费用.Id And
                a.Id = c.收发id And c.记录id = b.Column_Value
          Order By 填制日期;
      Else
        Open c_药品 For
          Select ID, 单据, NO, 库房id, 药品id, 批次, 发药方式, Decode(发药方式, Null, 1, -1, 0, 1) * Nvl(付数, 1) * Nvl(实际数量, 0) As 数量,
                 灭菌效期, 效期, 产地, 批号, 填制日期, 费用id
          From 药品收发记录
          Where NO = No_In And 单据 In (9, 10, 25, 26) And Mod(记录状态, 3) = 1 And 审核人 Is Null And 费用id = v_费用.Id
          Order By 填制日期;
      End If;
      Loop
        Fetch c_药品
          Into v_药品;
        Exit When c_药品%NotFound;
        n_Temp := v_药品.数量;
        If v_准退数量 >= n_Temp Then
          l_药品收发.Extend;
          l_药品收发(l_药品收发.Count) := v_药品.Id;
          If Nvl(n_其他出库id, 0) > 0 Then
            l_药品收发.Extend;
            l_药品收发(l_药品收发.Count) := n_其他出库id;
          End If;
          v_准退数量 := v_准退数量 - n_Temp;
        Else
          If v_费用.收费类别 = '7' Then
            --当前行的数量要大
            Update 药品收发记录
            Set 付数 = 1, 实际数量 = Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - v_准退数量,
                填写数量 = Decode(付数, Null, 1, 0, 1, 付数) * Nvl(填写数量, 0) - v_准退数量,
                成本金额 =
                 (Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - v_准退数量) * 成本价,
                零售金额 =
                 (Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - v_准退数量) * 零售价,
                差价 = Round((Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - v_准退数量) * 零售价 -
                            (Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - v_准退数量) * 成本价, 5)
            Where ID = v_药品.Id;
          Else
            Update 药品收发记录
            Set 实际数量 = Nvl(实际数量, 0) - v_准退数量, 填写数量 = Nvl(填写数量, 0) - v_准退数量,
                成本金额 =
                 (Nvl(实际数量, 0) - v_准退数量) * 成本价,
                零售金额 =
                 (Nvl(实际数量, 0) - v_准退数量) * 零售价,
                差价 = Round((Nvl(实际数量, 0) - v_准退数量) * 零售价 - (Nvl(实际数量, 0) - v_准退数量) * 成本价, 5)
            Where ID = v_药品.Id;
          End If;
          --更新其他出库单
          If Nvl(n_其他出库id, 0) <> 0 Then
            If v_费用.收费类别 = '7' Then
              Update 药品收发记录
              Set 付数 = 1, 实际数量 = Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - v_准退数量,
                  填写数量 = Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - v_准退数量,
                  成本金额 =
                   (Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - v_准退数量) * 成本价,
                  零售金额 =
                   (Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - v_准退数量) * 零售价,
                  差价 = Round((Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - v_准退数量) * 零售价 -
                              (Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - v_准退数量) * 成本价, 5)
              Where ID = Nvl(n_其他出库id, 0);
            Else
              Update 药品收发记录
              Set 实际数量 = Nvl(实际数量, 0) - v_准退数量, 填写数量 = Nvl(实际数量, 0) - v_准退数量,
                  成本金额 =
                   (Nvl(实际数量, 0) - v_准退数量) * 成本价,
                  零售金额 =
                   (Nvl(实际数量, 0) - v_准退数量) * 零售价,
                  差价 = Round((Nvl(实际数量, 0) - v_准退数量) * 零售价 - (Nvl(实际数量, 0) - v_准退数量) * 成本价, 5)
              Where ID = Nvl(n_其他出库id, 0);
            End If;
          End If;
          n_Temp     := v_准退数量;
          v_准退数量 := 0;
        End If;
        If Nvl(n_备货卫材, 0) = 1 Then
          n_库房id := n_虚拟库房id;
        Else
          n_库房id := v_药品.库房id;
        End If;
      
        If n_库房id Is Not Null Then
          Update 药品库存
          Set 可用数量 = Nvl(可用数量, 0) + n_Temp
          Where 库房id = n_库房id And 药品id = v_药品.药品id And Nvl(批次, 0) = Nvl(v_药品.批次, 0) And 性质 = 1;
          If Sql%RowCount = 0 Then
            Insert Into 药品库存
              (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期)
            Values
              (n_库房id, v_药品.药品id, 1, v_药品.批次, v_药品.效期, n_Temp, v_药品.批号, v_药品.产地, v_药品.灭菌效期);
          End If;
          Delete 药品库存
          Where 库房id = n_库房id And 药品id = v_药品.药品id And Nvl(批次, 0) = Nvl(v_药品.批次, 0) And 性质 = 1 And Nvl(可用数量, 0) = 0 And
                Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0;
        End If;
      
        If Nvl(n_备货卫材, 0) = 1 Then
          Update 药品库存
          Set 可用数量 = Nvl(可用数量, 0) + n_Temp
          Where 库房id = v_药品.库房id And 药品id = v_药品.药品id And Nvl(批次, 0) = Nvl(v_药品.批次, 0) And 性质 = 1;
          If Sql%RowCount = 0 Then
            Insert Into 药品库存
              (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期)
            Values
              (v_药品.库房id, v_药品.药品id, 1, v_药品.批次, v_药品.效期, n_Temp, v_药品.批号, v_药品.产地, v_药品.灭菌效期);
          End If;
        End If;
      
        If v_准退数量 = 0 Then
          Exit;
        End If;
      End Loop;
      --不跟踪卫材的,不检查:因为不跟噻的话,不会在药品收发记录中存在
      If Nvl(v_准退数量, 0) <> 0 And Not (v_费用.收费类别 = '4' And n_Temp = 0) Then
        --未分配完成,表示此药品可能已经执行.
        v_Err_Msg := '要销帐的费用中存在已发的药品或卫材，或已被其他人销帐；这可能是并发操作引起的。';
        Raise Err_Item;
      End If;
    End If;
  End Loop;

  If n_部分销帐 = 0 Then
    ------------------------------------------------------------------------------------------------------------------------
    --先处理备货材料
    For v_出库 In (Select ID, 单据, NO, 库房id, 药品id, 批次, 发药方式, 付数, 实际数量, 灭菌效期, 效期, 产地, 批号, 填制日期, 费用id, 商品条码, 内部条码
                 From 药品收发记录
                 Where 单据 = 21 And Mod(记录状态, 3) = 1 And 审核人 Is Null And
                       费用id In (Select ID
                                From 住院费用记录
                                Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 In (0, 1, 3) And 收费类别 = '4' And 门诊标志 = 2 And
                                      (Instr(',' || v_序号 || ',', ',' || 序号 || ',') > 0 Or v_序号 Is Null))
                 Order By 药品id, 填制日期 Desc) Loop
      --处理药品库存
      If v_出库.库房id Is Not Null Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) + Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0)
        Where 库房id = v_出库.库房id And 药品id = v_出库.药品id And Nvl(批次, 0) = Nvl(v_出库.批次, 0) And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码)
          Values
            (v_出库.库房id, v_出库.药品id, 1, v_出库.批次, v_出库.效期,
             Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0), v_出库.批号, v_出库.产地, v_出库.灭菌效期,
             v_出库.商品条码, v_出库.内部条码);
        End If;
        Delete 药品库存
        Where 库房id = v_出库.库房id And 药品id = v_出库.药品id And Nvl(批次, 0) = Nvl(v_出库.批次, 0) And 性质 = 1 And Nvl(可用数量, 0) = 0 And
              Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0;
      End If;
      l_费用id.Extend;
      l_费用id(l_费用id.Count) := v_出库.费用id;
      l_药品收发.Extend;
      l_药品收发(l_药品收发.Count) := v_出库.Id;
    End Loop;
  
    --药品相关内容
    Fetch c_Stock
      Into r_Stock;
    While c_Stock%Found Loop
    
      --处理药品库存
      If r_Stock.库房id Is Not Null Then
      
        Select Decode(Count(Column_Value), Null, 0, 0, 0, 1)
        Into n_备货卫材
        From Table(l_费用id)
        Where Column_Value = r_Stock.费用id;
      
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) + Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0)
        Where 库房id = r_Stock.库房id And 药品id = r_Stock.药品id And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期)
          Values
            (r_Stock.库房id, r_Stock.药品id, 1, r_Stock.批次, r_Stock.效期,
             Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0), r_Stock.批号, r_Stock.产地,
             r_Stock.灭菌效期);
        End If;
        Delete 药品库存
        Where 库房id = r_Stock.库房id And 药品id = r_Stock.药品id And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1 And
              Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0;
      End If;
    
      --删除药品收发记录(加上并发操作检查:审核人 Is Null)
      --Delete From 药品收发记录 Where ID = r_Stock.ID And 审核人 Is Null;
    
      l_药品收发.Extend;
      l_药品收发(l_药品收发.Count) := r_Stock.Id;
      Fetch c_Stock
        Into r_Stock;
    End Loop;
    Close c_Stock;
  
    --删除药品收发记录
    Forall I In 1 .. l_药品收发.Count
      Delete From 药品收发记录 Where ID = l_药品收发(I) And 审核人 Is Null;
    If Sql%RowCount <> l_药品收发.Count And l_药品收发.Count <> 0 Then
      v_Err_Msg := '要销帐的费用中存在已发的药品或卫材，或已被其他人销帐；这可能是并发操作引起的。';
      Raise Err_Item;
    End If;
  Else
    --删除药品收发记录
    Forall I In 1 .. l_药品收发.Count
      Delete From 药品收发记录 Where ID = l_药品收发(I) And 审核人 Is Null;
  End If;
  --未发药品记录
  Delete From 未发药品记录 A
  Where NO = No_In And 单据 In (9, 10, 25, 26) And Not Exists
   (Select 1
         From 药品收发记录
         Where 单据 = a.单据 And Nvl(库房id, 0) = Nvl(a.库房id, 0) And NO = No_In And Mod(记录状态, 3) = 1 And 审核人 Is Null);

  ---------------------------------------------------------------------------------
  --如果是划价,直接删除费用记录(药品处理后)
  n_Count := l_划价.Count;
  --删除划价记录
  Forall I In 1 .. l_划价.Count
    Delete From 住院费用记录 Where ID = l_划价(I);

  --删除之后再统一调整序号
  If n_Count > 0 Then
    n_Count := 1;
    For r_Serial In c_Serial Loop
      If r_Serial.价格父号 Is Null Then
        v_父号 := n_Count;
      End If;
    
      Update 住院费用记录
      Set 序号 = n_Count, 价格父号 = Decode(价格父号, Null, Null, v_父号)
      Where NO = No_In And 记录性质 = 记录性质_In And 序号 = r_Serial.序号;
    
      Update 住院费用记录
      Set 从属父号 = n_Count
      Where NO = No_In And 记录性质 = 记录性质_In And 从属父号 = r_Serial.序号;
    
      n_Count := n_Count + 1;
    End Loop;
  
  End If;
  --整张单据全部冲完时，删除病人医嘱附费
  For c_医嘱 In (Select Distinct 医嘱序号
               From 住院费用记录
               Where NO = No_In And 记录性质 = 2 And 记录状态 = 3 And 医嘱序号 Is Not Null) Loop
    Select Nvl(Count(*), 0)
    Into n_Count
    From (Select 序号, Sum(数量) As 剩余数量
           From (Select 记录状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                  From 住院费用记录
                  Where 记录性质 = 2 And 医嘱序号 + 0 = c_医嘱.医嘱序号 And NO = No_In
                  Group By 记录状态, Nvl(价格父号, 序号))
           Group By 序号
           Having Sum(数量) <> 0);
  
    If n_Count = 0 Then
      Delete From 病人医嘱附费 Where 医嘱id = c_医嘱.医嘱序号 And 记录性质 = 2 And NO = No_In;
    End If;
  End Loop;

  If v_医嘱ids Is Not Null Then
    --医嘱处理
    --场合_In    Integer:=0, --0:门诊;1-住院
    --性质_In    Integer:=1, --1-收费单;2-记帐单
    --操作_In    Integer:=0, --0:删除划价单;1-收费或记帐;2-退费或销帐
    --No_In      门诊费用记录.No%Type,
    --医嘱ids_In Varchar2 := Null
    v_医嘱ids := Substr(v_医嘱ids, 2);
    Zl_医嘱发送_计费状态_Update(1, 2, 0, No_In, v_医嘱ids);
  Else
    Zl_医嘱发送_计费状态_Update(1, 2, 2, No_In);
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_住院记帐记录_Delete;
/

--107171:张德婷,2017-07-07,静配中心添加排班设置功能
CREATE OR REPLACE Procedure Zl_输液配药记录_发送
(
  配药id_In   In Varchar2, --ID串:ID1,ID2....
  操作人员_In In 输液配药记录.操作人员%Type := Null,
  操作时间_In In 输液配药记录.操作时间%Type := Null,
  操作说明_In In 输液配药状态.操作说明%Type := Null
) Is
  v_Tansid Varchar2(20);
  v_Tmp    Varchar2(4000);
  v_Error    Varchar2(255);
  n_操作状态 输液配药记录.操作状态%Type;
  n_People  number(2);
  v_No       Varchar2(20);
  n_项目id   number(18);
  v_收费项目id varchar2(200);
  n_row      number(2);
  n_Out number(10);
  n_OutNum number(10);
  n_count number(18);
  n_packet number(2);
  v_Usercode Varchar2(100);
  v_复核人   varchar2(20);
  Err_Custom Exception;

  Cursor c_Bill Is
    Select a.病人id, a.主页id, a.标识号, a.姓名, a.性别, a.年龄, a.床号, a.费别, a.病人病区id, a.病人科室id, a.婴儿费, e.药品id, b.库房id,f.配药类型,c.执行时间
    From 住院费用记录 A, 药品收发记录 B, 输液配药记录 C, 输液配药内容 D, 药品规格 E, 输液药品属性 F
    Where a.Id = b.费用id And b.Id = d.收发id And d.记录id = c.Id And b.药品id = e.药品id And b.药品id = f.药品id And Nvl(c.是否打包, 0) <> 0 And c.Id = v_Tansid;
Begin
  v_Usercode := Zl_Identity;
  v_Usercode := Substr(v_Usercode, Instr(v_Usercode, ';') + 1);
  v_Usercode := Substr(v_Usercode, Instr(v_Usercode, ',') + 1);
  v_Usercode := Substr(v_Usercode, 1, Instr(v_Usercode, ',') - 1);
  n_People:=Nvl(zl_GetSysParameter('配置费按病人收取', 1345), 0);
  n_Out:=Nvl(zl_GetSysParameter('出院病人不收配置费', 1345), 0);
  n_packet:=Nvl(zl_GetSysParameter('打包药品在发送环节收取配置费', 1345), 0);

  If 配药id_In Is Null Then
    v_Tmp := Null;
  Else
    v_Tmp := 配药id_In || ',';
  End If;
  While v_Tmp Is Not Null Loop
    --分解单据ID串
    v_Tansid := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
    v_Tmp    := Replace(',' || v_Tmp, ',' || v_Tansid || ',');

     Begin
      Select 操作状态 Into n_操作状态 From 输液配药记录 Where ID = v_Tansid;

      if n_操作状态>4 then
        v_Error := '该数据已被操作，不能进行发送操作！';
        Raise Err_Custom;
      end if;
    Exception
      When Others Then
        v_Error := '该数据已被操作！';
        Raise Err_Custom;
    End;
    
    v_复核人:='';
    Begin
      Select 复核人
      Into v_复核人
      From (Select e.复核人
             From 输液配药记录 a, 输液配药内容 b, 药品收发记录 c, 配液台药品对照 d, 配液工作安排 e
             Where a.Id = b.记录id And b.收发id = c.Id And c.药品id = d.药品id And c.库房id = d.部门id And d.配药台id = e.配药台id And
                   a.配药批次 = e.批次  and e.日期=to_date(to_char(sysdate,'yyyy-mm-dd'),'yyyy-mm-dd') And a.Id = v_Tansid  and rownum=1
             Order By d.配药台id)
      Where Rownum = 1;
    Exception
      When Others Then
        null;
    end;

    Insert Into 输液配药状态 (配药id, 操作类型, 操作人员, 操作时间,操作说明,实际工作人员) Values (v_Tansid, 5, 操作人员_In, 操作时间_In,操作说明_In,v_复核人);
    Update 输液配药记录 Set 操作状态 = 5, 操作人员 = 操作人员_In, 操作时间 = 操作时间_In Where ID = v_Tansid;

    --打包药品收费
    if n_packet=1 then
      n_count:=0;
      Select Nextno(14) Into v_No From Dual;
      For r_Bill In c_Bill Loop
        Select count(病人id) into n_OutNum From 病案主页 where 主页ID=r_Bill.主页id And 病人ID=r_Bill.病人id  And (Nvl(状态,0)=3 Or 出院日期 Is Not NULL);
        select count(项目id) into n_项目id from 配置收费方案 where 配药类型=substr(r_Bill.配药类型,INSTR(r_Bill.配药类型,'-',1,1)+1);
        if n_项目id<>0 then
          n_row:=0;
          select nvl(项目id,0) into n_项目id from 配置收费方案 where 配药类型=substr(r_Bill.配药类型,INSTR(r_Bill.配药类型,'-',1,1)+1);
          if n_People=1 then
            select count(配药id) into n_row from 输液配药附费 A,住院费用记录 B,输液配药记录 C where A.No=b.no and A.配药ID=C.id and b.病人id=r_Bill.病人id And B.记录状态=1 and B.收费细目id=n_项目id and r_Bill.执行时间 Between Trunc(c.执行时间) And Trunc(c.执行时间+1) - 1 / 24 / 60 / 60;
          end if;
        else
          n_row:=1;
        end if;

        if n_row=0 and (n_OutNum=0 or n_out=0) then
          For r_Item In (Select a.Id 收费细目id, a.类别 收费类别, a.计算单位, a.加班加价 加班标志, d.Id 收入项目id, d.收据费目, b.现价
                         From 收费项目目录 A, 收费价目 B, 收入项目 D
                         Where a.Id = b.收费细目id And b.收入项目id = d.Id And a.id=n_项目id and
                               b.执行日期 <= Sysdate And
                               (b.终止日期 >= Sysdate Or b.终止日期 Is Null)) Loop
            if n_count=0 then
              Insert Into 输液配药附费 (配药id, NO,病人id) Values (v_Tansid, v_No, r_Bill.病人id);
            end if;

            n_count:=n_count+1;
            Zl_住院记帐记录_Insert(v_No, n_count, r_Bill.病人id, r_Bill.主页id, r_Bill.标识号, r_Bill.姓名, r_Bill.性别, r_Bill.年龄, r_Bill.床号,
                             r_Bill.费别, r_Bill.病人病区id, r_Bill.病人科室id, r_Item.加班标志, r_Bill.婴儿费, r_Bill.库房id, 操作人员_In, Null,
                             r_Item.收费细目id, r_Item.收费类别, r_Item.计算单位, Null, Null, Null, 1, 1, Null, r_Bill.库房id, Null,
                             r_Item.收入项目id, r_Item.收据费目, r_Item.现价, r_Item.现价, r_Item.现价, Null, Sysdate, Sysdate, Null, Null,
                             v_Usercode, 操作人员_In);
          End Loop;
        end if;

        if n_People<>1 and n_row=0 then
          Exit;
        end if;
      end loop;
    end if;
  End Loop;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_输液配药记录_发送;
/

--111337:张德婷,2017-07-10,脚本提交错误
--107171:张德婷,2017-07-07,静配中心添加排班设置功能
CREATE OR REPLACE Procedure Zl_输液配药记录_配药
(
  配药id_In   In Varchar2, --ID串:ID1,ID2....
  操作人员_In In 输液配药记录.操作人员%Type := Null,
  操作时间_In In 输液配药记录.操作时间%Type := Null,
  操作说明_In In 输液配药状态.操作说明%Type := Null
) Is
  v_Tansid   Varchar2(20);
  v_Tmp      Varchar2(4000);
  v_No       Varchar2(20);
  v_Usercode Varchar2(100);
  n_操作状态 输液配药记录.操作状态%Type;
  v_Error    Varchar2(255);
  n_People      number(1);
  n_row      number(2);
  d_执行时间 date;
  v_配药类型 varchar2(50);
  n_项目id   number(18);
  v_收费项目id varchar2(200);
  v_info    varchar2(200);
  v_id varchar2(20);
  n_数次 number(2);
  n_count number(18);
  n_Out number(10);
  n_OutNum number(10);
  n_打包状态 number(1);
  v_核对人 varchar2(20);
  v_配液人 varchar2(20);
  Err_Custom Exception;

  Cursor c_Bill Is
    Select a.病人id, a.主页id, a.标识号, a.姓名, a.性别, a.年龄, a.床号, a.费别, a.病人病区id, a.病人科室id, a.婴儿费, e.药品id, b.库房id,f.配药类型
    From 住院费用记录 A, 药品收发记录 B, 输液配药记录 C, 输液配药内容 D, 药品规格 E, 输液药品属性 F
    Where a.Id = b.费用id And b.Id = d.收发id And d.记录id = c.Id And b.药品id = e.药品id And b.药品id = f.药品id And Nvl(c.是否打包, 0) <> 1 And c.Id = v_Tansid;

Begin
  v_Usercode := Zl_Identity;
  v_Usercode := Substr(v_Usercode, Instr(v_Usercode, ';') + 1);
  v_Usercode := Substr(v_Usercode, Instr(v_Usercode, ',') + 1);
  v_Usercode := Substr(v_Usercode, 1, Instr(v_Usercode, ',') - 1);
  n_People:=Nvl(zl_GetSysParameter('配置费按病人收取', 1345), 0);
  n_Out:=Nvl(zl_GetSysParameter('出院病人不收配置费', 1345), 0);

  If 配药id_In Is Null Then
    v_Tmp := Null;
  Else
    v_Tmp := 配药id_In || ',';
  End If;

  While v_Tmp Is Not Null Loop
    --分解单据ID串
    v_Tansid := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
    v_Tmp    := Replace(',' || v_Tmp, ',' || v_Tansid || ',');

    --检查当前输液单的状态是否为待摆药状态
    Begin
      Select 操作状态,执行时间,nvl(是否打包,0)  Into n_操作状态,d_执行时间,n_打包状态 From 输液配药记录 Where ID = v_Tansid;

      if n_操作状态>3 then
        v_Error := '该数据已被操作，不能进行发药！';
        Raise Err_Custom;
      end if;
    Exception
      When Others Then
        v_Error := '该数据已被操作！';
        Raise Err_Custom;
    End;
    
    v_核对人:='';
    v_配液人:='';
    Begin
      Select 核对人,配液人
      Into v_核对人,v_配液人
      From (Select e.核对人,e.配液人
             From 输液配药记录 a, 输液配药内容 b, 药品收发记录 c, 配液台药品对照 d, 配液工作安排 e
             Where a.Id = b.记录id And b.收发id = c.Id And c.药品id = d.药品id And c.库房id = d.部门id And d.配药台id = e.配药台id And
                   a.配药批次 = e.批次  and e.日期=to_date(to_char(sysdate,'yyyy-mm-dd'),'yyyy-mm-dd') And a.Id = v_Tansid  and rownum=1
             Order By d.配药台id)
      Where Rownum = 1;
    Exception
      When Others Then
        null;
    end;

    Update 输液配药记录 Set 操作状态 = 4, 操作人员 = 操作人员_In, 操作时间 = 操作时间_In Where ID = v_Tansid;
    Insert Into 输液配药状态 (配药id, 操作类型, 操作人员, 操作时间,操作说明,实际工作人员) Values (v_Tansid, 3, 操作人员_In, 操作时间_In,操作说明_In,v_核对人);
    Insert Into 输液配药状态 (配药id, 操作类型, 操作人员, 操作时间,操作说明,实际工作人员) Values (v_Tansid, 4, 操作人员_In, 操作时间_In,操作说明_In,v_配液人);

    if n_打包状态=0 then
      n_count:=0;
      Select Nextno(14) Into v_No From Dual;
      For r_Bill In c_Bill Loop
        Select count(病人id) into n_OutNum From 病案主页 where 主页ID=r_Bill.主页id And 病人ID=r_Bill.病人id  And (Nvl(状态,0)=3 Or 出院日期 Is Not NULL);
        if n_count=0 and (n_OutNum=0 or n_out=0) then
          --收取材料费
          --v_收费项目id:='6970,2;6971,1;';
          select zl_fun_PIVACustom(v_Tansid) into  v_收费项目id from dual;
          While v_收费项目id Is Not Null Loop
             v_info:= Substr(v_收费项目id, 1, Instr(v_收费项目id, ';') - 1);
             v_收费项目id := Replace(';' || v_收费项目id, ';' || v_info || ';');


             v_id:= Substr(v_info, 1, Instr(v_info, ',') - 1);
             v_info := Replace(',' || v_info, ',' || v_id || ',');

            For r_Item In (Select a.Id 收费细目id, a.类别 收费类别, a.计算单位, a.加班加价 加班标志, d.Id 收入项目id, d.收据费目, b.现价
                           From 收费项目目录 A, 收费价目 B, 收入项目 D
                           Where a.Id = b.收费细目id And b.收入项目id = d.Id And a.id=v_id and
                                 b.执行日期 <= Sysdate And
                                 (b.终止日期 >= Sysdate Or b.终止日期 Is Null)) Loop
              if n_count=0 then
                Insert Into 输液配药附费 (配药id, NO,病人id) Values (v_Tansid, v_No, r_Bill.病人id);
              end if;

              n_count:=n_count+1;
              Zl_住院记帐记录_Insert(v_No, n_count, r_Bill.病人id, r_Bill.主页id, r_Bill.标识号, r_Bill.姓名, r_Bill.性别, r_Bill.年龄, r_Bill.床号,
                               r_Bill.费别, r_Bill.病人病区id, r_Bill.病人科室id, r_Item.加班标志, r_Bill.婴儿费, r_Bill.库房id, 操作人员_In, Null,
                               r_Item.收费细目id, r_Item.收费类别, r_Item.计算单位, Null, Null, Null, 1,v_info, Null, r_Bill.库房id, Null,
                               r_Item.收入项目id, r_Item.收据费目, r_Item.现价, r_Item.现价*v_info, r_Item.现价*v_info, Null, Sysdate, Sysdate, Null, Null,
                               v_Usercode, 操作人员_In);
            End Loop;
          end loop;
        end if;


        select count(项目id) into n_项目id from 配置收费方案 where 配药类型=substr(r_Bill.配药类型,INSTR(r_Bill.配药类型,'-',1,1)+1);
        if n_项目id<>0 then
          n_row:=0;
          select nvl(项目id,0) into n_项目id from 配置收费方案 where 配药类型=substr(r_Bill.配药类型,INSTR(r_Bill.配药类型,'-',1,1)+1);
          if n_People=1 then
            select count(配药id) into n_row from 输液配药附费 A,住院费用记录 B,输液配药记录 C where A.No=b.no and A.配药ID=C.id and b.病人id=r_Bill.病人id And B.记录状态=1 and B.收费细目id=n_项目id and d_执行时间 Between Trunc(c.执行时间) And Trunc(c.执行时间+1) - 1 / 24 / 60 / 60;
          end if;
        else
          n_row:=1;
        end if;

        if n_row=0 and (n_OutNum=0 or n_out=0) then
          For r_Item In (Select a.Id 收费细目id, a.类别 收费类别, a.计算单位, a.加班加价 加班标志, d.Id 收入项目id, d.收据费目, b.现价
                         From 收费项目目录 A, 收费价目 B, 收入项目 D
                         Where a.Id = b.收费细目id And b.收入项目id = d.Id And a.id=n_项目id and
                               b.执行日期 <= Sysdate And
                               (b.终止日期 >= Sysdate Or b.终止日期 Is Null)) Loop
            if n_count=0 then
              Insert Into 输液配药附费 (配药id, NO,病人id) Values (v_Tansid, v_No, r_Bill.病人id);
            end if;

            n_count:=n_count+1;
            Zl_住院记帐记录_Insert(v_No, n_count, r_Bill.病人id, r_Bill.主页id, r_Bill.标识号, r_Bill.姓名, r_Bill.性别, r_Bill.年龄, r_Bill.床号,
                             r_Bill.费别, r_Bill.病人病区id, r_Bill.病人科室id, r_Item.加班标志, r_Bill.婴儿费, r_Bill.库房id, 操作人员_In, Null,
                             r_Item.收费细目id, r_Item.收费类别, r_Item.计算单位, Null, Null, Null, 1, 1, Null, r_Bill.库房id, Null,
                             r_Item.收入项目id, r_Item.收据费目, r_Item.现价, r_Item.现价, r_Item.现价, Null, Sysdate, Sysdate, Null, Null,
                             v_Usercode, 操作人员_In);
          End Loop;
        end if;

        if n_People<>1 and n_row=0 then
          Exit;
        end if;
      End Loop;
    end if;
  End Loop;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_输液配药记录_配药;
/

--107171:张德婷,2017-07-10,静配中心新增排班设置功能
Create Or Replace Procedure Zl_输液配药记录_摆药
(
  部门id_In   In 输液配药记录.部门id%Type,
  配药id_In   In Varchar2, --ID串:ID1,ID2....
  摆药单号_In In 输液配药记录.摆药单号%Type,
  操作人员_In In 输液配药状态.操作人员%Type := Null,
  操作时间_In In 输液配药状态.操作时间%Type := Null
) Is
  v_Tansid Varchar2(20);
  v_Tmp    Varchar2(4000);

  v_收发ids  Varchar2(4000);
  v_Error    Varchar2(255);
  n_是否打包 输液配药记录.是否打包%Type;
  n_操作状态 输液配药记录.操作状态%Type;
  v_摆药人   Varchar2(20);
  v_配药台   Varchar2(20);
  n_配药台id Number(4);
  n_部门id   Number(18);
  n_批次     Number(2);
  d_日期     Date;
  Err_Custom Exception;
  Cursor c_收发记录 Is
    Select /*+ rule*/
     a.Id, Nvl(a.批次, 0) As 批次
    From 药品收发记录 a,
         (Select Distinct 收发id
           From 输液配药内容 a, Table(Cast(f_Num2list(配药id_In) As Zltools.t_Numlist)) b
           Where a.记录id = b.Column_Value) b
    Where a.Id = b.收发id And a.审核人 Is Null;

  v_收发记录 c_收发记录%Rowtype;
Begin
  If 配药id_In Is Null Then
    v_Tmp := Null;
  Else
    v_Tmp := 配药id_In || ',';
  End If;

  While v_Tmp Is Not Null Loop
    --分解单据ID串
    v_Tansid := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
    v_Tmp    := Replace(',' || v_Tmp, ',' || v_Tansid || ',');
  
    --检查当前输液单的状态是否为待摆药状态
    Begin
      Select 操作状态 Into n_操作状态 From 输液配药记录 Where Id = v_Tansid;
    
      If n_操作状态 > 1 Then
        v_Error := '该数据已被操作，不能进行发药！';
        Raise Err_Custom;
      End If;
    Exception
      When Others Then
        v_Error := '该数据已被操作！';
        Raise Err_Custom;
    End;
  
    Begin
      Select 是否打包 Into n_是否打包 From 输液配药记录 Where Id = v_Tansid For Update Nowait;
    Exception
      When Others Then
        v_Error := '已有其他用户在执行发药，不能重复操作！';
        Raise Err_Custom;
    End;
    
    v_配药台:='';
    n_配药台id:=0;
    n_部门id:=0;
    v_摆药人:='';
    Begin
      Select 名称, Id, 部门id, 配药批次, 执行时间
      Into v_配药台, n_配药台id, n_部门id, n_批次, d_日期
      From (Select f.名称, f.Id, a.部门id, a.配药批次, a.执行时间
             From 输液配药记录 a, 输液配药内容 b, 药品收发记录 c, 配液台药品对照 d, 配液台 f
             Where a.Id = b.记录id And b.收发id = c.Id And c.药品id = d.药品id And d.配药台id = f.Id And c.库房id = d.部门id And
                   a.Id = v_Tansid
             Order By d.配药台id)
      Where Rownum = 1;
    
      Select 摆药人
      Into v_摆药人
      From 配液工作安排
      Where 部门id = n_部门id And 配药台id = n_配药台id And 批次 = n_批次 And
            日期 = To_Date(To_Char(Sysdate, 'yyyy-mm-dd'), 'yyyy-mm-dd');
    Exception
      When Others Then
        Null;
    End;
  
    Update 输液配药记录
    Set 操作状态 = 2, 操作人员 = 操作人员_In, 操作时间 = 操作时间_In, 摆药单号 = 摆药单号_In, 配药台 = v_配药台
    Where Id = v_Tansid;
  
    Insert Into 输液配药状态
      (配药id, 操作类型, 操作人员, 操作时间, 实际工作人员)
    Values
      (v_Tansid, 2, 操作人员_In, 操作时间_In, v_摆药人);
    If n_是否打包 <> 0 Then
      Update 输液配药记录 Set 操作状态 = 4, 操作人员 = 操作人员_In, 操作时间 = 操作时间_In Where Id = v_Tansid;
      Insert Into 输液配药状态 (配药id, 操作类型, 操作人员, 操作时间) Values (v_Tansid, 4, 操作人员_In, 操作时间_In);
    End If;
  End Loop;

  For v_收发记录 In c_收发记录 Loop
    If v_收发ids Is Null Then
      v_收发ids := v_收发记录.Id || ',' || v_收发记录.批次;
    Else
      If Length(v_收发ids || '|' || v_收发记录.Id || ',' || v_收发记录.批次) > 3950 Then
        Zl_药品收发记录_批量发药(v_收发ids, 部门id_In, 操作人员_In, 操作时间_In, 4, 操作人员_In, 摆药单号_In);
        v_收发ids := v_收发记录.Id || ',' || v_收发记录.批次;
      Else
        v_收发ids := v_收发ids || '|' || v_收发记录.Id || ',' || v_收发记录.批次;
      End If;
    End If;
  End Loop;

  If Not v_收发ids Is Null Then
    Zl_药品收发记录_批量发药(v_收发ids, 部门id_In, 操作人员_In, 操作时间_In, 4, 操作人员_In, 摆药单号_In);
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_输液配药记录_摆药;
/

--98870:梁唐彬,2017-07-06,德阳医院转病区问题；
Create Or Replace Procedure Zl_医嘱执行计价_Insert
(
  医嘱id_In     医嘱执行计价.医嘱id%Type,
  发送号_In     医嘱执行计价.发送号%Type,
  要求时间_In   医嘱执行计价.要求时间%Type,
  收费细目id_In 医嘱执行计价.收费细目id%Type,
  数量_In       医嘱执行计价.数量%Type,
  费用性质_In   医嘱执行计价.费用性质%Type := 0
) Is
 n_执行状态   医嘱执行计价.执行状态%Type;
Begin
  Select 执行状态 Into n_执行状态 From 病人医嘱发送 Where 医嘱ID = 医嘱id_In And 发送号 = 发送号_In;
  If n_执行状态 <> 1 Then
	n_执行状态 := 0;
  End If;
  Insert Into 医嘱执行计价
    (医嘱id, 发送号, 要求时间, 收费细目id, 数量,费用性质,执行状态)
  Values
    (医嘱id_In, 发送号_In, 要求时间_In, 收费细目id_In, 数量_In,费用性质_In,n_执行状态);
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_医嘱执行计价_Insert;
/

--98870:梁唐彬,2017-07-06,德阳医院转病区问题
Create Or Replace Procedure Zl_病人医嘱执行_Cancel
(
  医嘱id_In     病人医嘱执行.医嘱id%Type,
  发送号_In     病人医嘱执行.发送号%Type,
  取消皮试_In   Number := Null,
  单独执行_In   Number := 0,
  执行部门id_In 门诊费用记录.执行部门id%Type := 0,
  操作员编号_In 人员表.编号%Type := Null,
  操作员姓名_In 人员表.姓名%Type := Null
  --参数：医嘱ID_IN=单独执行的医嘱ID，检验组合为显示的检验项目的ID。
  --      单独执行_In=检验或检查医嘱组合是否采用对每个项目分散单独执行的方式
  --执行部门id_In=仅处理指定执行部门的费用，不传或传入0时不限制执行部门
) Is
  Cursor C_Advice Is
    Select A.Id, A.相关id, Nvl(A.相关id, A.Id) As 组id, A.病人id, Decode(A.病人来源, 1, C.Id, A.主页id) As 就诊id, A.诊疗类别, B.操作类型,
           A.病人来源
    From 病人医嘱记录 A, 诊疗项目目录 B, 病人挂号记录 C
    Where A.诊疗项目id = B.Id And A.Id = 医嘱id_In And A.挂号单 = C.No(+);
  R_Advice C_Advice%RowType;

  V_Temp     Varchar2(255);
  V_人员编号 人员表.编号%Type;
  V_人员姓名 人员表.姓名%Type;
  V_费用性质 病人医嘱发送.记录性质%Type;
  V_操作人员 人员表.姓名%Type;
  D_完成时间 病人医嘱发送.完成时间%Type;
  n_发送数次 Number;
  n_单次数次 Number;
  n_登记数次 Number;
  d_要求时间 date;
  N_取消执行 Number;
  N_Diffday  Number(18, 3);
  V_Date     Date;
  V_Count    Number;
  Err_Custom Exception;
  V_Error Varchar2(2000);
Begin
  --当前操作人员
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
    V_人员编号 := 操作员编号_In;
    V_人员姓名 := 操作员姓名_In;
  Else
    V_Temp     := Zl_Identity;
    V_Temp     := Substr(V_Temp, Instr(V_Temp, ';') + 1);
    V_Temp     := Substr(V_Temp, Instr(V_Temp, ',') + 1);
    V_人员编号 := Substr(V_Temp, 1, Instr(V_Temp, ',') - 1);
    V_人员姓名 := Substr(V_Temp, Instr(V_Temp, ',') + 1);
  End If;

  Open C_Advice;
  Fetch C_Advice
    Into R_Advice;
  Close C_Advice;
  --医嘱取消执行天数限制，会诊医嘱不做限制
  If Not (R_Advice.诊疗类别 = 'Z' And R_Advice.操作类型 = 7) Then
    --父医嘱不需要发送，没有发送记录，此时取子医嘱的完成时间
    If Nvl(单独执行_In, 0) <> 1 Then
      Select Count(1) Into V_Count From 病人医嘱发送 Where 发送号 + 0 = 发送号_In And 医嘱id = R_Advice.组id;
    End If;
  
    If Nvl(单独执行_In, 0) = 1 Or V_Count = 0 Then
      Select 完成时间 Into D_完成时间 From 病人医嘱发送 Where 发送号 + 0 = 发送号_In And 医嘱id = 医嘱id_In;
    Else
      Select 完成时间 Into D_完成时间 From 病人医嘱发送 Where 发送号 + 0 = 发送号_In And 医嘱id = R_Advice.组id;
    End If;
    If Not D_完成时间 Is Null Then
      Select Zl_To_Number(Nvl(zl_GetSysParameter(220), '999')) Into N_取消执行 From Dual;
      Select Sysdate - D_完成时间 Into N_Diffday From Dual;
      --完成时间超过取消执行天数的记录，不允许取消执行
      If N_Diffday > N_取消执行 Then
        V_Error := '医嘱执行完成时间超过了取消执行有效天数，不能取消执行！';
        Raise Err_Custom;
      End If;
    End If;
  End If;

  If (R_Advice.诊疗类别 = 'C' And R_Advice.相关id Is Not Null) Or R_Advice.诊疗类别 = 'D' Then
    If Nvl(单独执行_In, 0) = 1 Then
      Select Count(*)
      Into V_Count
      From 病人医嘱执行
      Where 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In And Nvl(执行结果, 1) <> 0;
      Update 病人医嘱发送
      Set 执行状态 = Decode(V_Count, 0, 0, 3), 完成人 = Null, 完成时间 = Null
      Where 发送号 + 0 = 发送号_In And 医嘱id = 医嘱id_In;
    Else
      Select Count(*)
      Into V_Count
      From 病人医嘱执行
      Where 发送号 + 0 = 发送号_In And 医嘱id In (Select ID From 病人医嘱记录 Where 相关id = R_Advice.相关id) And Nvl(执行结果, 1) <> 0;
    
      If R_Advice.诊疗类别 = 'D' Then
        Update 病人医嘱发送
        Set 执行状态 = Decode(V_Count, 0, 0, 3), 完成人 = Null, 完成时间 = Null
        Where 发送号 + 0 = 发送号_In And
              医嘱id In (Select ID From 病人医嘱记录 Where (ID = R_Advice.组id Or 相关id = R_Advice.组id));
      Else
        Update 病人医嘱发送
        Set 执行状态 = Decode(V_Count, 0, 0, 3), 完成人 = Null, 完成时间 = Null
        Where 发送号 + 0 = 发送号_In And 医嘱id In (Select ID From 病人医嘱记录 Where 相关id = R_Advice.相关id);
      End If;
    End If;
  Else
    Select Count(*) Into v_Count From 病人医嘱执行 Where 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In;
  
    --包含附加手术,检验部位,以及其它独立医嘱;麻醉和中药煎法是单独安排
    If r_Advice.诊疗类别 = 'E' And (r_Advice.操作类型 = '4' Or r_Advice.操作类型 = '3') Then
      Update 病人医嘱发送
      Set 执行状态 = Decode(v_Count, 0, 0, 3), 完成人 = Null, 完成时间 = Null
      Where 发送号 + 0 = 发送号_In And 医嘱id = 医嘱id_In;
    Else
      Update 病人医嘱发送
      Set 执行状态 = Decode(v_Count, 0, 0, 3), 完成人 = Null, 完成时间 = Null
      Where 发送号 + 0 = 发送号_In And
            医嘱id In (Select ID
                     From 病人医嘱记录
                     Where (ID = r_Advice.组id Or 相关id = r_Advice.组id) And 诊疗类别 = r_Advice.诊疗类别);
    End If;
  End If;
  --更新对应的费用执行状态为未执行，在Zl_门诊医嘱执行_Cancel和Zl_住院医嘱执行_Cancel中进行

  --删除过敏登记记录(当前人员登记的)
  If R_Advice.诊疗类别 = 'E' And R_Advice.操作类型 = '1' Then
    Select Max(操作时间), Max(操作人员)
    Into V_Date, V_操作人员
    From (Select 操作时间, 操作人员 From 病人医嘱状态 Where 医嘱id = 医嘱id_In And 操作类型 = 10 Order By 操作时间 Desc)
    Where Rownum < 2;
    If V_Date Is Not Null And ((V_操作人员 = V_人员姓名 and Nvl(取消皮试_In, 0) = 0) Or Nvl(取消皮试_In, 0) = 1) Then
      --可能因为未设置对应过敏药物而未填写过敏记录
      --删除状态，以便标记未用时回退发送记录
      Update 病人医嘱记录 Set 皮试结果 = Null Where ID = 医嘱id_In;
      For R_Date In (Select 操作时间 From 病人医嘱状态 Where 医嘱id = 医嘱id_In And 操作类型 = 10) Loop
	--过敏记录不回退，因为病人对药过敏与医嘱操作无关。
        Delete From 病人过敏记录
        Where 病人id = R_Advice.病人id And 记录来源 = 2 And Nvl(主页id, 0) = Nvl(R_Advice.就诊id, 0) And 记录时间 = R_Date.操作时间 And Nvl(结果,0) = 0;
        Delete 病人医嘱状态 Where 医嘱id = 医嘱id_In And 操作类型 = 10 And 操作时间 = R_Date.操作时间;
      End Loop;
    End If;
  End If;
  --检验自动采集，没有采集方式的医嘱执行记录，则清空采样人与采样时间
  Select Count(*) Into V_Count From 病人医嘱执行 Where 发送号 = 发送号_In And 医嘱id = R_Advice.组id;
  If V_Count = 0 And R_Advice.诊疗类别 = 'E' And R_Advice.操作类型 = '6' Then
    Update 病人医嘱发送 A
    Set A.采样人 = Null, A.采样时间 = Null
    Where 医嘱id In (Select ID From 病人医嘱记录 Where (ID = R_Advice.组id Or 相关id = R_Advice.组id)) And 发送号 = 发送号_In;
  End If;

  If R_Advice.病人来源 = 2 Then
    Select Decode(记录性质, 1, 1, Decode(门诊记帐, 1, 1, 2))
    Into V_费用性质
    From 病人医嘱发送
    Where 发送号 = 发送号_In And 医嘱id = 医嘱id_In;
  Else
    V_费用性质 := 1;
  End If;

  If V_费用性质 = 1 Then
    Zl_门诊医嘱执行_Cancel(医嘱id_In, 发送号_In, 单独执行_In, V_人员编号, V_人员姓名, R_Advice.组id, R_Advice.诊疗类别, 执行部门id_In);
  Else
    Zl_住院医嘱执行_Cancel(医嘱id_In, 发送号_In, 单独执行_In, V_人员编号, V_人员姓名, R_Advice.组id, R_Advice.诊疗类别, 执行部门id_In);
  End If;
  --更新医嘱执行计价.执行状态
  Select a.发送数次, c.登记次数
  Into n_发送数次, n_登记数次
  From 病人医嘱发送 A,
       (Select 医嘱id_In 医嘱id, 发送号_In 发送号, Nvl(Sum(b.本次数次), 0) As 登记次数
         From 病人医嘱执行 B
         Where b.医嘱id = 医嘱id_In And b.发送号 = 发送号_In And Nvl(b.执行结果, 1) <> 0) C
  Where a.医嘱id = c.医嘱id And a.发送号 = c.发送号 And a.医嘱id = 医嘱id_In And a.发送号 = 发送号_In;
  
  If n_发送数次 > 0 Then
    Select Count(distinct 要求时间) Into v_Count From 医嘱执行计价 Where 医嘱ID = 医嘱ID_IN And 发送号 = 发送号_IN;
    If v_Count > 0 Then
      n_单次数次 := n_发送数次 / v_Count;
      --已执行数量+本次数次 总共能够执行多少个时间点,取最大整数
      v_Count := ceil((n_登记数次 ) / n_单次数次);
      If n_登记数次 = 0 Then
        Update 医嘱执行计价 Set 执行状态 = 0 Where 医嘱id = 医嘱ID_IN And 发送号 = 发送号_IN And NVL(执行状态,0) <> 2;
      Else
        --获取执行截至要求时间 
        Select 要求时间 Into d_要求时间
        From (Select 要求时间, Rownum As 次数
               From (Select Distinct 要求时间 From 医嘱执行计价 Where 医嘱id = 医嘱ID_IN And 发送号 = 发送号_IN Order By 要求时间))
        Where 次数 = v_Count;
    	        
        If Not d_要求时间 Is Null Then
          --更新截至要求时间之前(含)的记录执行状态；
          Update 医嘱执行计价 Set 执行状态 = 1 Where 医嘱id = 医嘱ID_IN And 发送号 = 发送号_IN And 要求时间 <= d_要求时间 And NVL(执行状态,0) <> 2;
          Update 医嘱执行计价 Set 执行状态 = 0 Where 医嘱id = 医嘱ID_IN And 发送号 = 发送号_IN And 要求时间 > d_要求时间 And NVL(执行状态,0) <> 2;
        End If;
      End If;
    End If;
  End If;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || V_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱执行_Cancel;
/

--98870:梁唐彬,2017-07-06,德阳转病区问题
Create Or Replace Procedure Zl_病人医嘱执行_Finish
(
  医嘱id_In       病人医嘱执行.医嘱id%Type,
  发送号_In       病人医嘱执行.发送号%Type,
  阳性_In         病人医嘱发送.结果阳性%Type := Null,
  单独执行_In     Number := 0,
  操作员编号_In   人员表.编号%Type := Null,
  操作员姓名_In   人员表.姓名%Type := Null,
  执行部门id_In   门诊费用记录.执行部门id%Type := 0,
  检验项目记帐_In Number := 0
  --参数：医嘱ID_IN=单独执行的医嘱ID，检验组合为显示的检验项目的ID。
  --      单独执行_In=检验或检查医嘱组合是否采用对每个项目分散单独执行的方式
  --执行部门id_In=仅处理指定执行部门的费用，不传或传入0时不限制执行部门
  --检验项目记帐_In=如果是检验项目时，需要记帐但不完成医嘱发送状态
) Is
  Cursor c_Advice Is
    Select a.Id, a.相关id, Nvl(a.相关id, a.Id) As 组id, a.诊疗类别, a.病人来源, a.标本部位, a.开始执行时间, a.病人id, a.主页id, a.执行科室id, b.操作类型
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.Id = 医嘱id_In And a.诊疗项目id = b.Id;
  r_Advice c_Advice%RowType;

  v_Date     Date;
  v_开始时间 Date;
  v_诊疗类别 诊疗项目目录.类别%Type;
  v_操作类型 诊疗项目目录.操作类型%Type;
  v_Temp     Varchar2(255);
  v_费用性质 病人医嘱发送.记录性质%Type;
  v_人员编号 人员表.编号%Type;
  v_人员姓名 人员表.姓名%Type;
  n_Cnt      Number;

Begin

  --如果启用了参数：输血和皮试医嘱执行后需要核对，则输血和皮试医嘱不自动完成
  Select b.类别, b.操作类型
  Into v_诊疗类别, v_操作类型
  From 病人医嘱记录 A, 诊疗项目目录 B
  Where a.诊疗项目id = b.Id And a.Id = 医嘱id_In;

  v_Temp := zl_GetSysParameter(186);
  If v_Temp = '11' Then
    Select Count(1)
    Into n_Cnt
    From 病人医嘱执行
    Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In And 核对人 Is Null And (v_诊疗类别 = 'E' And v_操作类型 In ('1', '8') Or v_诊疗类别 = 'K');
  Elsif v_Temp = '01' Then
    Select Count(1)
    Into n_Cnt
    From 病人医嘱执行
    Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In And 核对人 Is Null And v_诊疗类别 = 'E' And v_操作类型 = '1';
  Elsif v_Temp = '10' Then
    Select Count(1)
    Into n_Cnt
    From 病人医嘱执行
    Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In And 核对人 Is Null And (v_诊疗类别 = 'E' And v_操作类型 = '8' Or v_诊疗类别 = 'K');
  End If;

  If n_Cnt > 0 Then
    Return;
  End If;

  --当前操作人员
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
    v_人员编号 := 操作员编号_In;
    v_人员姓名 := 操作员姓名_In;
  Else
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;
  Select Sysdate Into v_Date From Dual;

  --执行状态
  Open c_Advice;
  Fetch c_Advice
    Into r_Advice;
  Close c_Advice;

  If 检验项目记帐_In = 0 Then
    If (r_Advice.诊疗类别 = 'C' And r_Advice.相关id Is Not Null) Or r_Advice.诊疗类别 = 'D' Then
      If Nvl(单独执行_In, 0) = 1 Then
        --单个检验或检查项目
        Update 病人医嘱发送
        Set 执行状态 = 1, 完成人 = v_人员姓名, 完成时间 = v_Date, 结果阳性 = Decode(阳性_In, Null, 结果阳性, 阳性_In)
        Where 发送号 = 发送号_In And 医嘱id = 医嘱id_In;
      Else
        --一并的检验项目或多部位的检查项目
        If r_Advice.诊疗类别 = 'D' Then
          Update 病人医嘱发送
          Set 执行状态 = 1, 完成人 = v_人员姓名, 完成时间 = v_Date, 结果阳性 = Decode(阳性_In, Null, 结果阳性, 阳性_In)
          Where 发送号 + 0 = 发送号_In And
                医嘱id In (Select ID From 病人医嘱记录 Where (ID = r_Advice.组id Or 相关id = r_Advice.组id));
        Else
          Update 病人医嘱发送
          Set 执行状态 = 1, 完成人 = v_人员姓名, 完成时间 = v_Date, 结果阳性 = Decode(阳性_In, Null, 结果阳性, 阳性_In)
          Where 发送号 + 0 = 发送号_In And 医嘱id In (Select ID From 病人医嘱记录 Where 相关id = r_Advice.相关id);
        End If;
      End If;
     Else
      --包含附加手术,检查部位,以及其它独立医嘱;麻醉和中药煎法是单独安排 
      If r_Advice.诊疗类别 = 'E' And (r_Advice.操作类型 = '4' Or r_Advice.操作类型 = '3') Then
        Update 病人医嘱发送
        Set 执行状态 = 1, 完成人 = v_人员姓名, 完成时间 = v_Date, 结果阳性 = Decode(阳性_In, Null, 结果阳性, 阳性_In)
        Where 发送号 + 0 = 发送号_In And 医嘱id = 医嘱id_In;
      Else
        Update 病人医嘱发送
        Set 执行状态 = 1, 完成人 = v_人员姓名, 完成时间 = v_Date, 结果阳性 = Decode(阳性_In, Null, 结果阳性, 阳性_In)
        Where 发送号 + 0 = 发送号_In And
              医嘱id In (Select ID
                       From 病人医嘱记录
                       Where (ID = r_Advice.组id Or 相关id = r_Advice.组id) And 诊疗类别 = r_Advice.诊疗类别);
      End If;
    End If;
  End If;
  If r_Advice.病人来源 = 2 Then
    Select Decode(记录性质, 1, 1, Decode(门诊记帐, 1, 1, 2))
    Into v_费用性质
    From 病人医嘱发送
    Where 发送号 = 发送号_In And 医嘱id = 医嘱id_In;
  Else
    v_费用性质 := 1;
  End If;
  --检验自动完成采集
  If v_诊疗类别 = 'E' And v_操作类型 = '6' Then
    Update 病人医嘱发送 A
    Set a.采样人 = Nvl(a.采样人, v_人员姓名), a.采样时间 = Nvl(a.采样时间, v_Date)
    Where 医嘱id In (Select ID From 病人医嘱记录 Where (ID = r_Advice.组id Or 相关id = r_Advice.组id)) And 发送号 = 发送号_In;
  End If;

  If v_费用性质 = 1 Then
    Zl_门诊医嘱执行_Finish(医嘱id_In, 发送号_In, 单独执行_In, v_人员编号, v_人员姓名, r_Advice.组id, r_Advice.诊疗类别, 执行部门id_In);
  Else
    Zl_住院医嘱执行_Finish(医嘱id_In, 发送号_In, 单独执行_In, v_人员编号, v_人员姓名, r_Advice.组id, r_Advice.诊疗类别, 执行部门id_In);
  End If;
  
  --更新医嘱执行计价.执行状态
  Update 医嘱执行计价 Set 执行状态 = 1 Where 医嘱id = 医嘱ID_IN And 发送号 = 发送号_IN And NVL(执行状态,0) <> 2;

  If r_Advice.诊疗类别 = 'F' Then
    If Not r_Advice.标本部位 Is Null Then
      v_开始时间 := To_Date(r_Advice.标本部位, 'yyyy-mm-dd hh24:mi:ss');
    Else
      v_开始时间 := r_Advice.开始执行时间;
    End If;
    Zl_电子病历时机_Insert(r_Advice.病人id, r_Advice.主页id, 2, '手术', r_Advice.执行科室id, v_人员姓名, v_开始时间, v_Date);
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱执行_Finish;
/

--107171:张德婷,2017-07-06,静配中心新增排班功能
CREATE OR REPLACE Procedure Zl_配液台_设置
( 
  部门id_In In 配液台.部门id%Type, 
  名称_In   In  配液台.名称%Type,
  id_In     In 配液台.id%Type
) Is 

n_id  number(4);
Begin 
  if id_In<>0 then
    update 配液台 set 名称=名称_In where id= id_In;
  else
    select nvl(max(id),0) into n_id from 配液台;
    Insert Into 配液台 (部门id,名称, id) Values (部门id_In,名称_In,n_id+1); 
  end if;
Exception 
  When Others Then 
    zl_ErrorCenter(SQLCode, SQLErrM); 
End Zl_配液台_设置;
/

--107171:张德婷,2017-07-06,静配中心新增排班功能
CREATE OR REPLACE Procedure Zl_配液台_删除
( 
  id_In     In 配液台.id%Type
) Is 

n_id  number(4);
Begin 
  delete from 配液台 where id=id_In;
Exception 
  When Others Then 
    zl_ErrorCenter(SQLCode, SQLErrM); 
End Zl_配液台_删除;
/

--107171:张德婷,2017-07-06,静配中心新增排班功能
CREATE OR REPLACE Procedure Zl_配液台药品对照_设置
( 
  药品id_In In 配液台药品对照.药品id%Type, 
  配药台id_In   In 配液台药品对照.配药台id%Type, 
  部门id_In     In 配液台药品对照.部门id%Type, 
  n_First   In Number 
) Is 
Begin  
  if n_First=0 then 
     delete from 配液台药品对照 where 部门id=部门id_In;
  end if;
  Insert Into 配液台药品对照 (药品id,配药台id,部门id) Values (药品id_In,配药台id_In,部门id_In); 
Exception 
  When Others Then 
    zl_ErrorCenter(SQLCode, SQLErrM); 
End Zl_配液台药品对照_设置;
/

--107171:张德婷,2017-07-06,静配中心新增排班功能
CREATE OR REPLACE Procedure Zl_配液台药品对照_删除
( 
  药品id_In In 配液台药品对照.药品id%Type, 
  配药台id_In   In 配液台药品对照.配药台id%Type
) Is 
Begin  
  delete from 配液台药品对照 where 配药台id=配药台id_In and 药品id=药品id_In;
Exception 
  When Others Then 
    zl_ErrorCenter(SQLCode, SQLErrM); 
End Zl_配液台药品对照_删除;
/

--107171:张德婷,2017-07-06,静配中心新增排班功能
CREATE OR REPLACE Procedure Zl_配液工作安排_设置
( 
  部门id_In In 配液工作安排.部门id%Type, 
  日期_In   In  配液工作安排.日期%Type, 
  配药台id_In   In 配液工作安排.配药台id%Type, 
  批次_In   In 配液工作安排.批次%Type, 
  审核人_In   In 配液工作安排.审核人%Type, 
  摆药人_In   In 配液工作安排.摆药人%Type, 
  核对人_In   In 配液工作安排.核对人%Type, 
  配液人_In   In 配液工作安排.配液人%Type, 
  复核人_In   In 配液工作安排.复核人%Type, 
  n_First   In Number 
) Is 
Begin 
  If n_First = 1 Then 
    Delete From 配液工作安排 where 部门id=部门id_In and 日期=日期_In; 
  End If; 
 
  Insert Into 配液工作安排 (部门id,日期, 配药台id,批次,审核人,摆药人,核对人,配液人,复核人) Values (部门id_In,日期_In, 配药台id_In,批次_In,审核人_In,摆药人_In,核对人_In,配液人_In,复核人_In); 
Exception 
  When Others Then 
    zl_ErrorCenter(SQLCode, SQLErrM); 
End Zl_配液工作安排_设置;
/  

--110744:李业庆,2017-07-06,销售出库高值卫材虚拟库房价格取值错误
Create Or Replace Procedure Zl_药品收发记录_销售出库
(
  Id_In           In 门诊费用记录.Id%Type,
  药品摘要_In     药品收发记录.摘要%Type := Null,
  频次_In         药品收发记录.频次%Type := Null,
  单量_In         药品收发记录.单量%Type := Null,
  用法_In         药品收发记录.用法%Type := Null,
  煎法_In         药品收发记录.外观%Type := Null,
  期效_In         药品收发记录.扣率%Type := Null,
  计价特性_In     药品收发记录.扣率%Type := Null,
  主页id_In       未发药品记录.主页id%Type := Null,
  备货材料_In     Number := 0,
  备货材料批次_In 药品收发记录.批次%Type := Null
) Is
  ----------------------------------
  --功能：收费、划价时按照参数设置分解药品并产生相应的收发记录
  --规则：
  --      1、循环游标判断总出库数量与游标中每条记录数量是否充足，如果充足就是总数量，不充足挨个遍历直到数量直到遍历完并退出
  --      2、金额计算方式：定价取收费价目表现价，时价分批取库存表零售价，时价不分批，零售金额/实际数量，并将所有批次的金额累加起来为总出库金额
  --参数：
  --      Id_In：门诊费用记录或者住院费用记录ID
  --      备货材料_In：只有高值卫材才需要传入，非0表示是高值卫材
  --      备货材料批次_In：只有高值卫材才需要传入，非空表示是高值卫材的批次
  --      药品摘要_In：可选参数
  --      频次_In；单量_In；用法_In；煎法_In；期效_In；计价特性_In，可选参数，医嘱记录产生
  -----------------------------------
  Cursor c_Stock
  (
    n_Outmode  Number,
    n_库房id   药品收发记录.库房id%Type,
    n_药品id   药品收发记录.药品id%Type,
    n_备货材料 Number,
    n_备货批次 药品收发记录.批次%Type
  ) Is
    Select 库房id, 药品id, 批次, 效期, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 灭菌效期, 批准文号, 平均成本价, 零售价,
           上次扣率, 商品条码, 内部条码
    From 药品库存
    Where 药品id = n_药品id And 库房id = n_库房id And 性质 = 1 And
          Decode(n_备货材料, 0, 0, Nvl(批次, 0)) = Decode(n_备货材料, 0, 0, Nvl(n_备货批次, 0)) And
          (Nvl(批次, 0) = 0 Or 效期 Is Null Or 效期 > Trunc(Sysdate)) And Nvl(可用数量, 0) > 0
    Order By Decode(n_Outmode, 1, 效期, Null), Nvl(批次, 0);
  r_Stock c_Stock%RowType;

  n_Outmode      Number;
  n_分批         药品规格.药房分批%Type;
  n_时价         收费项目目录.是否变价%Type;
  n_当前数量     药品库存.实际数量%Type;
  n_费用金额小数 Number;
  n_费用单价小数 Number;
  n_流通金额小数 Number;
  n_流通单价小数 Number;
  n_标准单价     收费价目.现价%Type;
  n_当前单价     收费价目.现价%Type;
  n_类别         药品单据性质.类别id%Type;
  n_总金额       Number;
  n_总数量       药品库存.实际数量%Type;
  n_单据         药品单据性质.单据%Type;
  n_跟踪在用     材料特性.跟踪在用%Type;
  n_序号         门诊费用记录.序号%Type;
  v_名称         收费项目目录.名称%Type;
  n_虚拟库房id   部门表.Id%Type;
  n_库房id       部门表.Id%Type;
  n_优先级       身份.优先级%Type;
  n_Count        Number;
  Err_Custom Exception;
  v_Rust     Varchar2(300);
  v_Error    Varchar2(255);
  v_部门名称 部门表.名称%Type;

  v_单据类别   Varchar2(10);
  v_No         药品收发记录.No%Type;
  n_对方部门id 药品收发记录.对方部门id%Type;
  n_收费细目id 药品收发记录.药品id%Type;
  n_总出库数量 药品库存.实际数量%Type;
  n_发药库房id 药品收发记录.库房id%Type;
  n_记录性质   门诊费用记录.记录性质%Type;
  v_收费类别   门诊费用记录.收费类别%Type;
  n_多病人单   住院费用记录.多病人单%Type;
  n_医嘱序号   门诊费用记录.医嘱序号%Type;
  v_姓名       门诊费用记录.姓名%Type;
  n_付数       门诊费用记录.付数%Type;
  v_操作员     门诊费用记录.操作员姓名%Type;
  d_登记时间   门诊费用记录.登记时间%Type;
  n_门诊标志   门诊费用记录.门诊标志%Type;
  n_病人科室id 门诊费用记录.病人科室id%Type;
  n_标识号     门诊费用记录.标识号%Type;
  v_性别       门诊费用记录.性别%Type;
  n_年龄       门诊费用记录.年龄%Type;
  n_病人id     门诊费用记录.病人id%Type;
  v_发药窗口   门诊费用记录.发药窗口%Type;
  n_记录状态   门诊费用记录.记录状态%Type;

  --药品收发记录
  n_收发id   药品收发记录.Id%Type;
  n_扣率     药品收发记录.扣率%Type;
  d_灭菌效期 药品收发记录.灭菌效期%Type;
  d_灭菌日期 药品收发记录.灭菌日期%Type;

  v_其他出库no 药品收发记录.No%Type;
  n_出库序号   药品收发记录.序号%Type;
  n_定价售价   收费价目.现价%Type;
  n_出库检查   Number(1);
Begin
  Begin
    Select 类别, NO, 序号, 对方部门id, 收费细目id, 总出库数量, 发药库房id, 记录性质, 收费类别, 多病人单, 医嘱序号, 姓名, 付数, 划价人, 登记时间, 门诊标志, 病人科室id, 标识号, 性别,
           年龄, 病人id, 发药窗口, 记录状态, 标准单价
    Into v_单据类别, v_No, n_序号, n_对方部门id, n_收费细目id, n_总出库数量, n_发药库房id, n_记录性质, v_收费类别, n_多病人单, n_医嘱序号, v_姓名, n_付数, v_操作员,
         d_登记时间, n_门诊标志, n_病人科室id, n_标识号, v_性别, n_年龄, n_病人id, v_发药窗口, n_记录状态, n_标准单价
    From (Select '门诊' As 类别, NO, 序号, 病人科室id As 对方部门id, 收费细目id, 付数 * 数次 As 总出库数量, 执行部门id As 发药库房id, 记录性质, 收费类别, 0 As 多病人单,
                  医嘱序号, 姓名, 付数, 划价人, 登记时间, 门诊标志, 病人科室id, 标识号, 性别, 年龄, 病人id, 发药窗口, 记录状态, 标准单价
           From 门诊费用记录
           Where ID = Id_In
           Union All
           Select '住院' As 类别, NO, 序号, 病人科室id As 对方部门id, 收费细目id, 付数 * 数次 As 总出库数量, 执行部门id As 发药库房id, 记录性质, 收费类别, 多病人单, 医嘱序号,
                  姓名, 付数, 划价人, 登记时间, 门诊标志, 病人科室id, 标识号, 性别, 年龄, 病人id, 发药窗口, 记录状态, 标准单价
           From 住院费用记录
           Where ID = Id_In);
  Exception
    When Others Then
      v_No         := Null;
      n_对方部门id := 0;
      n_总出库数量 := 0;
  End;

  n_跟踪在用 := 0;
  --只处理有数量的
  If n_总出库数量 <> 0 Then
    --药品分批出库方式
    Select Zl_To_Number(Nvl(zl_GetSysParameter(150), 0)) Into n_Outmode From Dual;
    --金额小数位数
    Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')), Zl_To_Number(Nvl(zl_GetSysParameter(157), '5'))
    Into n_费用金额小数, n_费用单价小数
    From Dual;
  
    --取流通业务精度位数
    --类别:1-药品 2-卫材
    --内容：2-零售价 4-金额
    --单位：药品:1-售价 5-金额单位
    If v_收费类别 = '4' Then
      Select 精度 Into n_流通单价小数 From 药品卫材精度 Where 类别 = 2 And 内容 = 2 And 单位 = 1;
      Select 精度 Into n_流通金额小数 From 药品卫材精度 Where 类别 = 2 And 内容 = 4 And 单位 = 5;
    Else
      Select 精度 Into n_流通单价小数 From 药品卫材精度 Where 类别 = 1 And 内容 = 2 And 单位 = 1;
      Select 精度 Into n_流通金额小数 From 药品卫材精度 Where 类别 = 1 And 内容 = 4 And 单位 = 5;
    End If;
  
    n_总数量 := n_总出库数量;
  
    If v_收费类别 = '4' Then
      --收费类别=4表示是卫材单据
      If v_单据类别 = '门诊' Then
        If n_记录性质 = 1 Then
          n_单据 := 24;
        Else
          n_单据 := 25;
        End If;
      Elsif v_单据类别 = '住院' Then
        If n_多病人单 = 1 Then
          n_单据 := 26;
        Else
          n_单据 := 25;
        End If;
      End If;
    
      Select Nvl(a.在用分批, 0), Nvl(b.是否变价, 0), b.名称, c.现价
      Into n_分批, n_时价, v_名称, n_定价售价
      From 材料特性 A, 收费项目目录 B, 收费价目 C
      Where a.材料id = b.Id And b.Id = n_收费细目id And b.Id = c.收费细目id And Sysdate Between c.执行日期 And c.终止日期;
      --跟踪在用
      Select 跟踪在用 Into n_跟踪在用 From 材料特性 Where 材料id = n_收费细目id;
      --备货卫材需要判断是否设置了虚拟库房对照
      If Nvl(备货材料_In, 0) = 1 Then
        Begin
          Select 虚拟库房id Into n_虚拟库房id From 虚拟库房对照 Where 科室id = n_发药库房id And Rownum <= 1;
        Exception
          When Others Then
            n_虚拟库房id := 0;
        End;
        If Nvl(n_虚拟库房id, 0) = 0 Then
          Begin
            Select 名称 Into v_Error From 部门表 Where ID = n_发药库房id;
          Exception
            When Others Then
              v_Error := '';
          End;
          v_Error := '执行部门"' || Nvl(v_Error, '') || '"未设置虚拟部门,请在卫材参数设置中设置.';
          Raise Err_Custom;
        End If;
      End If;
    Else
      --收费类别<>4表示是药品单据，收费类别有"5，6，7"
      If v_单据类别 = '门诊' Then
        If n_记录性质 = 1 Then
          n_单据 := 8;
        Else
          n_单据 := 9;
        End If;
      Elsif v_单据类别 = '住院' Then
        If n_多病人单 = 1 Then
          n_单据 := 10;
        Else
          n_单据 := 9;
        End If;
      End If;
    
      Select Nvl(a.药房分批, 0), Nvl(b.是否变价, 0), b.名称, c.现价
      Into n_分批, n_时价, v_名称, n_定价售价
      From 药品规格 A, 收费项目目录 B, 收费价目 C
      Where a.药品id = b.Id And b.Id = n_收费细目id And b.Id = c.收费细目id And Sysdate Between c.执行日期 And c.终止日期;
    End If;
  
    --可能分批时价药品分解的批次变了
    If n_时价 = 1 Then
      --只有一个批次时,直接取该批次的单价
      --按照最小单位进行格式化
    
      If Nvl(备货材料_In, 0) = 1 And v_收费类别 = '4' Then
        v_Rust := Zl_Fun_Getprice(n_收费细目id, n_虚拟库房id, n_总出库数量, 备货材料_In, 备货材料批次_In);
      Else
        v_Rust := Zl_Fun_Getprice(n_收费细目id, n_发药库房id, n_总出库数量, 备货材料_In, 备货材料批次_In);
      End If;
      n_当前单价 := To_Number(Substr(v_Rust, 1, Instr(v_Rust, '|') - 1));
    
      If Round(n_当前单价, n_费用单价小数) <> Round(n_标准单价, n_费用单价小数) Then
        If n_医嘱序号 Is Null Then
          If v_收费类别 = '4' Then
            v_Error := '第 ' || n_序号 || ' 行的时价卫生材料"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
          Else
            v_Error := '第 ' || n_序号 || ' 行的时价药品"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
          End If;
        Else
          If v_收费类别 = '4' Then
            v_Error := '在处理病人"' || v_姓名 || '"时发现时价卫生材料"' || v_名称 || '"当前计算的单价发生变化。' || Chr(13) || Chr(10) ||
                       '请检查该病人是否同时使用了两笔相同的"' || v_名称 || '"！';
          Else
            v_Error := '在处理病人"' || v_姓名 || '"时发现时价药品"' || v_名称 || '"当前计算的单价发生变化。' || Chr(13) || Chr(10) ||
                       '请检查该病人是否同时使用了两笔相同的"' || v_名称 || '"！';
          End If;
        End If;
        Raise Err_Custom;
      End If;
    End If;
  
    If v_收费类别 In ('5', '6', '7') Or (v_收费类别 = '4' And Nvl(n_跟踪在用, 0) = 1) Then
      If Nvl(备货材料_In, 0) = 1 And v_收费类别 = '4' Then
        n_库房id := n_虚拟库房id;
      Else
        n_库房id := n_发药库房id;
      End If;
    
      Begin
        If v_收费类别 In ('5', '6', '7') Then
          Select 检查方式 Into n_出库检查 From 药品出库检查 Where 库房id = n_库房id;
        Else
          Select 检查方式 Into n_出库检查 From 材料出库检查 Where 库房id = n_库房id;
        End If;
      Exception
        When Others Then
          n_出库检查 := 0;
      End;
    
      If v_收费类别 = '4' Then
        Select 类别id Into n_类别 From 药品单据性质 Where 单据 = n_单据 + 16;
      Else
        Select 类别id Into n_类别 From 药品单据性质 Where 单据 = n_单据;
      End If;
    
      n_总金额 := 0;
      --打开游标
      Open c_Stock(n_Outmode, n_库房id, n_收费细目id, 备货材料_In, 备货材料批次_In);
      --循环遍历
      While n_总出库数量 <> 0 Loop
        Fetch c_Stock
          Into r_Stock;
        If c_Stock%NotFound Then
          --第一次就没有库存,分批或时价都不允许。
          --分批药品数量分解不完,也就是库存不足。
          If n_分批 = 1 Or n_时价 = 1 Then
            Close c_Stock;
            If n_单据 = 8 Or n_单据 = 24 Then
              If v_收费类别 = '4' Then
                v_Error := '第 ' || n_序号 || ' 行的分批或时价卫生材料"' || v_名称 || '"没有可用的库存！';
              Else
                v_Error := '第 ' || n_序号 || ' 行的分批或时价药品"' || v_名称 || '"没有可用的药品库存！';
              End If;
            Else
              --单据=9，10，25，26是记账单提示不一样
              If n_医嘱序号 Is Null Then
                If v_收费类别 = '4' Then
                  If Nvl(备货材料_In, 0) = 1 And Not (n_分批 = 1 Or n_时价 = 1) Then
                    v_Error := '第 ' || n_序号 || ' 行的卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
                  Else
                    v_Error := '第 ' || n_序号 || ' 行的分批或时价卫生材料"' || v_名称 || '"没有足够的材料库存' || Case
                                 When Nvl(备货材料_In, 0) = 0 Then
                                  '！'
                                 Else
                                  ',不能进行备货记帐！'
                               End;
                  End If;
                Else
                  v_Error := '第 ' || n_序号 || ' 行的分批或时价药品"' || v_名称 || '"没有足够的库存！';
                End If;
              Else
                If v_收费类别 = '4' Then
                  If Nvl(备货材料_In, 0) = 1 And Not (n_分批 = 1 Or n_时价 = 1) Then
                    v_Error := '在处理病人"' || v_姓名 || '"时发现卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
                  Else
                    v_Error := '在处理病人"' || v_姓名 || '"时发现分批或时价卫生材料"' || v_名称 || '"没有足够的材料库存' || Case
                                 When Nvl(备货材料_In, 0) = 0 Then
                                  '！'
                                 Else
                                  ',不能进行备货记帐！'
                               End;
                  End If;
                Else
                  v_Error := '在处理病人"' || v_姓名 || '"时发现分批或时价药品"' || v_名称 || '"没有足够的库存！';
                End If;
              End If;
            End If;
            Raise Err_Custom;
          End If;
        Elsif (n_分批 = 1 And Nvl(r_Stock.批次, 0) = 0) Or (n_分批 = 0 And Nvl(r_Stock.批次, 0) <> 0) Then
          Close c_Stock;
          If n_医嘱序号 Is Null Then
            If v_收费类别 = '4' Then
              v_Error := '第 ' || n_序号 || ' 行卫生材料"' || v_名称 || '"的在用分批属性与库存记录不相符,请检查材料数据的正确性！';
            Else
              v_Error := '第 ' || n_序号 || ' 行药品"' || v_名称 || '"的分批属性与库存记录不相符,请检查药品数据的正确性！';
            End If;
          Else
            If v_收费类别 = '4' Then
              v_Error := '在处理病人"' || v_姓名 || '"时发现卫生材料"' || v_名称 || '"的分批属性与库存记录不相符,请检查材料数据的正确性！';
            Else
              v_Error := '在处理病人"' || v_姓名 || '"时发现药品"' || v_名称 || '"的分批属性与库存记录不相符,请检查药品数据的正确性！';
            End If;
          End If;
          Raise Err_Custom;
        End If;
      
        If c_Stock%Found Then
          If Nvl(r_Stock.实际数量, 0) = 0 And (n_总出库数量 > 0 Or n_时价 = 1) And n_出库检查 = 2 Then
            --实际数量为零时，如果严格控制库存，不允许出库
            --实际数量不为零，金额为零，可能是正常的零价格管理。
            --负数的情况相当于入库,这种情况应是允许的；但时价需要计算价格，必须要有实际数量。
            Close c_Stock;
            If n_医嘱序号 Is Null Then
              If v_收费类别 = '4' Then
                v_Error := '第 ' || n_序号 || ' 行的卫生材料"' || v_名称 || '"当前无库存实际数量，可能存在尚未退料的记录，当前不能出库。';
              Else
                v_Error := '第 ' || n_序号 || ' 行药品"' || v_名称 || '"当前无库存实际数量，可能存在尚未退药的记录，当前不能出库。';
              End If;
            Else
              If v_收费类别 = '4' Then
                v_Error := '在处理病人"' || v_姓名 || '"时发现卫生材料"' || v_名称 || '"当前无库存实际数量，可能存在尚未退料的记录，当前不能出库。';
              Else
                v_Error := '在处理病人"' || v_姓名 || '"时发现药品"' || v_名称 || '"当前无库存实际数量，可能存在尚未退药的记录，当前不能出库。';
              End If;
            End If;
            Raise Err_Custom;
          End If;
        End If;
      
        If n_分批 = 1 Or n_时价 = 1 Then
          --对于不分批的时价只可能分解一次,分解不完上面判断了.它分解是为了计算单价.
          --每次分解取小者,库存不够分解不完在上面判断.
          If n_总出库数量 <= Nvl(r_Stock.可用数量, 0) Then
            n_当前数量 := n_总出库数量;
          Else
            n_当前数量 := Nvl(r_Stock.可用数量, 0);
          End If;
          If n_时价 = 1 Then
            n_当前单价 := Nvl(r_Stock.零售价, Nvl(r_Stock.实际金额 / r_Stock.实际数量, 0));
          Elsif n_分批 = 1 Then
            n_当前单价 := n_定价售价;
          End If;
        Else
          --定价不分批
          --非门诊单据且是高值卫材需要检查库存
          If n_单据 <> 8 Or n_单据 <> 24 Then
            If Nvl(备货材料_In, 0) = 1 And v_收费类别 = '4' Then
              If n_总出库数量 > Nvl(r_Stock.可用数量, 0) Then
                --不分批, 但又是备货卫材方式出库的,则需要检查当前库存是否充足.
                v_Error := '第 ' || n_序号 || ' 行的卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
                Raise Err_Custom;
              End If;
            End If;
          End If;
          n_当前数量 := n_总出库数量;
          n_当前单价 := n_定价售价;
        End If;
      
        --药品收发记录
        If c_Stock%Found Then
          --卫材灭菌效期:一次性材料且有效期
          If v_收费类别 = '4' Then
            n_Count := 0;
            Begin
              Select 灭菌效期 Into n_Count From 材料特性 Where Nvl(一次性材料, 0) = 1 And 材料id = n_收费细目id;
            Exception
              When Others Then
                Null;
            End;
            If Nvl(n_Count, 0) > 0 Then
              d_灭菌效期 := r_Stock.灭菌效期;
              d_灭菌日期 := d_灭菌效期 - n_Count * 30;
            End If;
          End If;
        End If;
      
        Select Nvl(Max(序号), 0) + 1 Into n_序号 From 药品收发记录 Where 单据 = n_单据 And 记录状态 = 1 And NO = v_No;
      
        n_扣率 := Null;
        If 期效_In Is Not Null Or 计价特性_In Is Not Null Then
          n_扣率 := Nvl(期效_In, 0) || Nvl(计价特性_In, 0);
        End If;
      
        --分批药品,如果是只使用了一个批次,则要填写付数
        If n_分批 = 1 And n_当前数量 <> n_总数量 Then
          n_Count := 1;
        Else
          n_Count := 0;
        End If;
      
        Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
        --修改的原单据号存放在摘要中
        Insert Into 药品收发记录
          (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人,
           填制日期, 费用id, 频次, 单量, 用法, 外观, 扣率, 灭菌效期, 灭菌日期, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
        Values
          (n_收发id, 1, n_单据, v_No, n_序号, n_发药库房id, n_对方部门id, n_类别, -1, n_收费细目id, r_Stock.批次, r_Stock.上次产地, r_Stock.上次批号,
           r_Stock.效期, Decode(n_Count, 1, 1, n_付数), Decode(n_Count, 1, n_当前数量, n_当前数量 / n_付数),
           Decode(n_Count, 1, n_当前数量, n_当前数量 / n_付数), n_当前单价, Round(n_当前单价 * n_当前数量, n_流通金额小数), 药品摘要_In, v_操作员, d_登记时间,
           Id_In, 频次_In, 单量_In, 用法_In, 煎法_In, n_扣率, d_灭菌效期, d_灭菌日期, r_Stock.上次供应商id, r_Stock.上次生产日期, r_Stock.批准文号,
           r_Stock.商品条码, r_Stock.内部条码);
      
        --药品库存(普通情况可能没有记录)
        Zl_药品库存_Update(n_收发id, 0, 1);
      
        --产生其他出库单 ，只有高值卫材才需要处理
        If v_收费类别 = '4' And Nvl(备货材料_In, 0) = 1 Then
          Begin
            Select Max(a.No), Max(a.序号)
            Into v_其他出库no, n_出库序号
            From 药品收发记录 A, 住院费用记录 B
            Where a.费用id = b.Id And b.No = v_No And 记录性质 = 2 And b.门诊标志 = n_门诊标志 And
                  Instr(',8,9,10,21,24,25,26,', ',' || a.单据 || ',') > 0;
          Exception
            When Others Then
              v_其他出库no := Null;
          End;
          If v_其他出库no Is Null Then
            v_其他出库no := Nextno(74, n_虚拟库房id, Null, 1);
          End If;
          If v_其他出库no Is Null Then
            v_Error := '在生成卫生材料的其他出库单时,获取相关的出库NO有误,请检查出库单的规则是否有误!';
            Raise Err_Custom;
          End If;
          If Nvl(n_病人科室id, 0) <> 0 Then
            Select 名称 Into v_部门名称 From 部门表 Where ID = n_病人科室id;
          End If;
          v_Error := LPad(' ', 4);
          v_Error := Substr('病人姓名:' || v_姓名 || v_Error || '性别:' || v_性别 || v_Error || '年龄' || n_年龄 || v_Error || '门诊号:' ||
                            Nvl(n_标识号, '') || v_Error || '病人科室:' || v_部门名称, 1, 100);
        
          n_出库序号 := Nvl(n_出库序号, 0) + 1;
          Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
        
          --高值卫材类别id默认19是为了方便统计，因为其他出库可以设置很多类别，所以默认19
          Insert Into 药品收发记录
            (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人,
             填制日期, 费用id, 频次, 发药窗口, 单量, 用法, 外观, 扣率, 灭菌效期, 灭菌日期, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
          Values
            (n_收发id, 1, 21, v_其他出库no, n_出库序号, n_虚拟库房id, n_对方部门id, 19, -1, n_收费细目id, r_Stock.批次, r_Stock.上次产地,
             r_Stock.上次批号, r_Stock.效期, 1, n_当前数量, n_当前数量, n_当前单价, Round(n_当前单价 * n_当前数量, n_流通金额小数), v_Error, v_操作员,
             d_登记时间, Id_In, 频次_In, v_发药窗口, 单量_In, 用法_In, 煎法_In, n_扣率, d_灭菌效期, d_灭菌日期, r_Stock.上次供应商id, r_Stock.上次生产日期,
             r_Stock.批准文号, r_Stock.商品条码, r_Stock.内部条码);
        
          --药品库存(普通情况可能没有记录)
          Zl_药品库存_Update(n_收发id, 0, 1);
        End If;
      
        v_Error      := '';
        n_总出库数量 := n_总出库数量 - n_当前数量;
        n_总金额     := n_总金额 + n_当前数量 * n_当前单价;
      End Loop;
    
      --未发药品记录
      Update 未发药品记录
      Set 病人id = n_病人id, 姓名 = v_姓名, 发药窗口 = v_发药窗口, 主页id = 主页id_In
      Where 单据 = n_单据 And NO = v_No And Nvl(库房id, 0) = Nvl(n_发药库房id, 0);
      If Sql%RowCount = 0 Then
        --取身份优先级
        Begin
          Select b.优先级 Into n_优先级 From 病人信息 A, 身份 B Where a.身份 = b.名称(+) And a.病人id = n_病人id;
        Exception
          When Others Then
            Null;
        End;
        Insert Into 未发药品记录
          (单据, NO, 病人id, 主页id, 姓名, 优先级, 库房id, 对方部门id, 填制日期, 已收费, 打印状态, 发药窗口)
        Values
          (n_单据, v_No, n_病人id, 主页id_In, v_姓名, n_优先级, n_发药库房id, n_对方部门id, d_登记时间, n_记录状态, 0, v_发药窗口);
      End If;
    
      --处理未发药记录状态
      Zl_Prescription_Type_Update(v_No, n_记录性质, n_收费细目id, v_收费类别);
    
      Close c_Stock;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_销售出库;
/

--111026:李业庆,2017-07-06,无库存冲销调价修正问题
Create Or Replace Procedure Zl_药品收发记录_调价修正(收发id_In In 药品收发记录.Id%Type) Is
  v_单据         药品收发记录.单据%Type;
  v_入出类别id   药品收发记录.入出类别id%Type;
  v_售价精度     Number;
  v_金额精度     Number;
  v_收发id       药品收发记录.Id%Type;
  v_原价         药品收发记录.零售价%Type;
  v_现价         药品收发记录.零售价%Type;
  v_是否变价     收费项目目录.是否变价%Type;
  v_价格id       收费价目.Id%Type;
  v_库房id       药品收发记录.库房id%Type;
  v_药品id       药品收发记录.药品id%Type;
  v_批次         药品收发记录.批次%Type;
  v_实际数量     药品收发记录.实际数量%Type;
  v_修正金额     药品收发记录.零售金额%Type;
  v_入出系数     药品收发记录.入出系数%Type;
  v_执行修正     Number;
  v_填制日期     药品收发记录.填制日期%Type;
  v_审核日期     药品收发记录.审核日期%Type;
  d_调价时间     收费价目.执行日期%Type;
  v_零售金额     药品收发记录.零售金额%Type;
  v_差价         药品收发记录.差价%Type;
  v_No           药品收发记录.No%Type;
  n_记录状态     药品收发记录.记录状态%Type;
  n_当前数量     药品库存.实际数量%Type;
  n_是否门诊记录 Number;
  n_价目表售价   药品收发记录.零售价%Type;
Begin
  ----售价：
  --定价和时价分批：判断在此期间有无主动调价，有则修正，无则不修正
  --时价不分批：直接比较价格
  --要修正时：判断当前价格与冲销价格是否不同，不同则处理否则不处理
  --          时价无库存不修正，因为取不出价格

  ----成本价：
  --有调价记录则修正，无调价检查库存与冲销价格是否不同，不同则修正，否则不修正

  --取原始单据的审核时间
  Select a.审核日期, a.填制日期
  Into v_审核日期, v_填制日期
  From 药品收发记录 A, 药品收发记录 B
  Where b.Id = 收发id_In And a.单据 = b.单据 And a.No = b.No And a.库房id = b.库房id And a.药品id + 0 = b.药品id And a.序号 = b.序号 And
        (a.记录状态 = 1 Or Mod(a.记录状态, 3) = 0);

  --1、售价调价处理
  --提取单据信息，原价，现价及药价属性
  Select a.单据, a.记录状态, a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, a.入出系数 * Nvl(a.实际数量, 0) * Nvl(a.付数, 1) As 实际数量,
         Nvl(a.零售价, 0) 原价, b.现价, Nvl(c.是否变价, 0) 是否变价, b.Id As 价格id, b.执行日期
  Into v_单据, n_记录状态, v_库房id, v_药品id, v_批次, v_实际数量, v_原价, v_现价, v_是否变价, v_价格id, d_调价时间
  From 药品收发记录 A, 收费价目 B, 收费项目目录 C
  Where a.药品id = b.收费细目id And a.药品id = c.Id And
        (Sysdate Between b.执行日期 And b.终止日期 Or Sysdate >= b.执行日期 And b.终止日期 Is Null) And a.Id = 收发id_In;

  v_执行修正 := 0;
  If v_是否变价 = 0 Then
    --定价，单据原始时间在最新调价时间后，需要执行调价修正
    If v_单据 = 8 Or v_单据 = 9 Or v_单据 = 10 Then
      --发药单看填制日期
      If v_填制日期 < d_调价时间 Then
        v_执行修正 := 1;
      End If;
    Elsif v_审核日期 < d_调价时间 Then
      --其他流通单据看审核时间
      v_执行修正 := 1;
    End If;
  Else
    --时价主要比较新老价格，这里不判断
    v_执行修正 := 1;
  End If;

  If v_执行修正 = 1 Then
    If v_是否变价 = 1 Then
      --时价从库存记录中取现价
      Begin
        Select Decode(Nvl(零售价, 0), 0, Decode(Nvl(实际数量, 0), 0, 0, 实际金额 / 实际数量), 零售价)
        Into v_现价
        From 药品库存
        Where 性质 = 1 And 库房id + 0 = v_库房id And 药品id = v_药品id And Nvl(批次, 0) = v_批次;
      Exception
        When Others Then
          --时价如果无库存则不进行修正
          v_现价     := 0;
          v_执行修正 := 0;
      End;
    
      If v_现价 = 0 Then
        v_执行修正 := 0;
      End If;
    End If;
  
    If v_执行修正 = 1 Then
      Select 精度 Into v_金额精度 From 药品卫材精度 Where 类别 = 1 And 内容 = 4 And 单位 = 5 And 性质 = 0;
    
      --比较原价和现价，不同则处理
      If Round(v_原价, 4) <> Round(v_现价, 4) Then
        v_修正金额 := Round(v_现价 * v_实际数量, v_金额精度) - Round(v_原价 * v_实际数量, v_金额精度);
      
        If v_修正金额 <> 0 Then
          Select 药品收发记录_Id.Nextval Into v_收发id From Dual;
          Select Nextno(147) Into v_No From Dual;
        
          Select 类别id Into v_入出类别id From 药品单据性质 Where 单据 = 13;
        
          --产生调价修正记录
          Insert Into 药品收发记录
            (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 零售金额, 差价, 摘要, 填制人,
             填制日期, 库房id, 入出系数, 价格id, 审核人, 审核日期, 费用id)
            Select v_收发id, 1, 13, v_No, 序号, v_入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, v_实际数量, 0, v_原价, 0, v_现价, 扣率, v_修正金额,
                   v_修正金额, '自动修正调价变动', 审核人, 审核日期, 库房id, 1, v_价格id, 审核人, 审核日期, 收发id_In
            From 药品收发记录
            Where ID = 收发id_In;
        
          --更新药品库存
          Zl_药品库存_Update(v_收发id, 2, 0);
        End If;
      End If;
    End If;
  End If;

  --2、成本价调价，发药单退药再发和冲销业务才修正
  v_执行修正 := 0;
  If (v_单据 In (8, 9, 10) And Mod(n_记录状态, 3) = 1 And n_记录状态 <> 1) Or Mod(n_记录状态, 3) = 2 Then
    Select 库房id, 药品id, Nvl(批次, 0) 批次, 入出系数 * Nvl(实际数量, 0) * Nvl(付数, 1) As 实际数量, 入出系数 * 零售金额, 入出系数 * 差价,
           Decode(单据, 12, 单量, 成本价) As 原价
    Into v_库房id, v_药品id, v_批次, v_实际数量, v_零售金额, v_差价, v_原价
    From 药品收发记录
    Where ID = 收发id_In;
  
    --冲销时取当前库存成本价
    Begin
      Select 1, 平均成本价, Nvl(实际数量, 0) As 实际数量
      Into v_执行修正, v_现价, n_当前数量
      From 药品库存
      Where 库房id = v_库房id And 药品id = v_药品id And Nvl(批次, 0) = v_批次 And 性质 = 1;
    Exception
      When Others Then
        v_现价     := 0;
        v_执行修正 := 0;
    End;
  
    --无库存判断
    If v_实际数量 = n_当前数量 Then
      --表示冲销或退药回去前无库存
      Begin
        Select 1, 现价
        Into v_执行修正, v_现价
        From (Select 新成本价 As 现价
               From 成本价调价信息
               Where 库房id = v_库房id And 药品id = v_药品id And 批次 = v_批次 And 执行日期 > v_审核日期
               Order By 执行日期 Desc)
        Where Rownum < 2;
      Exception
        When Others Then
          v_现价     := 0;
          v_执行修正 := 0;
      End;
    
      If v_现价 = 0 Then
        --可能调价时无库存，查询有无无库存调价的情况
        Begin
          Select 1, 现价
          Into v_执行修正, v_现价
          From (Select 新成本价 As 现价
                 From 成本价调价信息
                 Where 库房id Is Null And 药品id = v_药品id And Nvl(批次, 0) = 0 And 执行日期 > v_审核日期
                 Order By 执行日期 Desc)
          Where Rownum < 2;
        Exception
          When Others Then
            v_现价     := 0;
            v_执行修正 := 0;
        End;
      End If;
    End If;
  
    If v_执行修正 = 1 And Round(v_现价, 4) <> Round(v_原价, 4) Then
      Select 精度 Into v_金额精度 From 药品卫材精度 Where 类别 = 1 And 内容 = 4 And 单位 = 5 And 性质 = 0;
    
      v_修正金额 := Round(v_原价 * v_实际数量, v_金额精度) - Round(v_现价 * v_实际数量, v_金额精度);
    
      If v_修正金额 <> 0 Then
        Select 药品收发记录_Id.Nextval Into v_收发id From Dual;
        Select b.Id, b.系数
        Into v_入出类别id, v_入出系数
        From 药品单据性质 A, 药品入出类别 B
        Where a.类别id = b.Id And a.单据 = 5 And Rownum < 2;
      
        v_No := Nextno(25, v_库房id);
      
        --产生库存差价调整单
        Insert Into 药品收发记录
          (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 供药单位id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 零售价, 成本价, 差价, 摘要, 填制人, 填制日期,
           审核人, 审核日期, 生产日期, 批准文号, 单量, 发药方式, 扣率, 灭菌效期, 费用id)
          Select v_收发id, 1, 5, v_No, 1, 库房id, v_入出类别id, 供药单位id, v_入出系数, 药品id, 批次, 产地, 批号, 效期, v_实际数量, v_零售金额, v_差价,
                 v_修正金额, '自动修正调价变动', 审核人, 审核日期, 审核人, 审核日期, 生产日期, 批准文号, v_现价, 1, 成本价, 灭菌效期, 收发id_In
          From 药品收发记录
          Where ID = 收发id_In;
      
        --更新库存
        Zl_药品库存_Update(v_收发id, 2, 0);
      
      End If;
    End If;
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_调价修正;
/

--110755:蔡青松,2017-07-04,修正病历中单位名称要素为乱码问题
Create Or Replace Procedure Zl_检验报告单_Update
(
  检验标本id_In   In 检验普通结果.检验标本id%Type,
  显示隐私项目_In In Number := 0,
  单位名称_In     In Varchar2 := Null
) Is

  v_主页id     病人挂号记录.Id%Type;
  v_医嘱id     病人医嘱记录.Id%Type;
  v_开嘱科室id 病人医嘱记录.开嘱科室id%Type;
  v_病人来源   检验标本记录.病人来源%Type;
  v_病人id     检验标本记录.病人id%Type;
  v_婴儿       检验标本记录.婴儿%Type;
  v_审核人     检验标本记录.审核人%Type;
  v_病历文件id 病历单据应用.病历文件id%Type;
  v_病历文件名 病历文件列表.名称%Type;
  v_当前父id   电子病历内容.父id%Type;
  v_父id_In    电子病历内容.父id%Type;
  v_写入格式   Number := 0; --1=检验结果
  v_文件id     电子病历内容.文件id%Type;
  v_Nextid     电子病历内容.Id%Type;
  v_Loop       Number := 0;
  v_替换内容   电子病历内容.内容文本%Type;
  v_检验结果   Varchar2(5000);
  v_微生物     检验标本记录.微生物标本%Type;
  v_结果长度   Number := 32;
  v_报告       检验标本记录.一级报告%Type;

  Cursor v_Source Is
    Select ID, 文件id, Nvl(父id, 0) As 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行, 预制提纲id 复用提纲, 使用时机, 诊治要素id, 替换域,
           要素名称, 要素类型, 要素长度, 要素小数, 要素单位, 要素表示, 输入形态, 要素值域
    From 病历文件结构
    Where 文件id = v_病历文件id
    Order By 对象序号;

  Cursor v_Result Is
    Select RPad('检验项目', v_结果长度) As 检验项目, RPad('检验结果', 10) As 检验结果, LPad('单位', 8) As 单位, LPad('结果标志', 10) As 结果标志,
           LPad('结果参考', 23) As 结果参考, 0 As 诊疗项目id, 0 As 排列序号, 0 As 隐私项目, '0' As 编码
    From Dual
    Union All
    Select RPad(b.中文名 || '(' || b.英文名 || ')', v_结果长度) As 检验项目, RPad(Nvl(a.检验结果, ' '), 10) As 检验结果,
           LPad(Nvl(b.单位, ' '), 8) As 单位,
           LPad(Decode(a.结果标志, 3, '↑', 2, '↓', 1, ' ', 4, '异常', 5, '↓↓', 6, '↑↑', ' '), 10) As 结果标志,
           LPad(Nvl(Zlgetreference(b.Id, c.标本类型, Decode(c.性别, '男', 1, '女', 2, 0), c.出生日期, c.仪器id, c.年龄, c.申请科室id), ' '),
                 23) As 结果参考, 诊疗项目id, a.排列序号, Nvl(d.隐私项目, 0) As 隐私项目,
           LPad(Decode(d.排列序号, Null, Nvl(h.编码, b.编码), d.排列序号), 4, '0') As 编码
    From 检验普通结果 A, 诊治所见项目 B, 检验标本记录 C, 检验项目 D, 诊疗项目目录 H
    Where a.检验项目id = b.Id And a.检验标本id = c.Id And c.医嘱id = v_医嘱id And b.Id = d.诊治项目id And c.报告结果 = a.记录类型 And
          a.诊疗项目id = h.Id(+)
    Order By 编码, 排列序号;

  Cursor v_Mresult Is
    Select *
    From (Select Null As 上级id, b.Id, a.标本序号, '       鉴定结果：' As 项目, RPad(c.中文名, 30, ' ') As 耐药, b.检验结果 As 用法用量1,
                  '' As 用法用量2, '' As 血药浓度1, '' As 血药浓度2, '' As 尿药浓度1, '' As 尿药浓度2, c.编码, '' As 检验备注
           From 检验标本记录 A, 检验普通结果 B, 检验细菌 C
           Where a.Id = b.检验标本id And a.报告结果 = b.记录类型 And b.细菌id = c.Id And a.医嘱id = v_医嘱id And a.样本状态 = 2
           Union All
           Select Distinct d.细菌结果id, 0, a.标本序号, '       抗生素          ',
                           RPad(Decode(药敏方法, 1, '  MIC', 2, '  Disk', 3, '  K-B', ' '), 5, ' ') || '    耐药性 ',
                           '             用法用量                ', '用法用量2', '血药浓度     ', '血药浓度2', '  尿药浓度', '尿药浓度2',
                           '000' As 编码, ''
           From 检验标本记录 A, 检验普通结果 B, 检验药敏结果 D
           Where a.Id = b.检验标本id And a.报告结果 = b.记录类型 And b.Id = d.细菌结果id And a.医嘱id = v_医嘱id And a.样本状态 = 2
           Union All
           Select Distinct d.细菌结果id, 0, a.标本序号, '￣￣￣￣￣￣￣', '￣￣￣￣￣￣￣', '￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣', '￣￣￣￣￣', '￣￣￣￣￣￣￣￣',
                           '￣￣￣￣￣', '￣￣￣￣￣￣￣', '￣￣￣￣￣￣￣￣', '001' As 编码, ''
           From 检验标本记录 A, 检验普通结果 B, 检验药敏结果 D
           Where a.Id = b.检验标本id And a.报告结果 = b.记录类型 And b.Id = d.细菌结果id And a.医嘱id = v_医嘱id And a.样本状态 = 2
           Union All
           Select 细菌结果id, ID, 标本序号, 项目, 耐药, 用法用量1, 用法用量2, 血药浓度1, 血药浓度2, 尿药浓度1, 尿药浓度2, 编码, ''
           From (Select *
                  From (Select Distinct d.细菌结果id, 0 As ID, a.标本序号, '￣￣￣￣￣￣￣' As 项目, '￣￣￣￣￣￣￣' As 耐药,
                                         '￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣' As 用法用量1, '￣￣￣￣￣' As 用法用量2, '￣￣￣￣￣￣￣￣' As 血药浓度1,
                                         '￣￣￣￣￣￣￣￣' As 血药浓度2, '￣￣￣￣￣￣￣' As 尿药浓度1, '￣￣￣￣￣￣￣￣' As 尿药浓度2, 'AAA' As 编码, '',
                                         c.编码 As 排序
                         From 检验标本记录 A, 检验普通结果 B, 检验细菌 C, 检验药敏结果 D
                         Where a.Id = b.检验标本id And a.报告结果 = b.记录类型 And b.细菌id = c.Id And b.Id = d.细菌结果id(+) And
                               a.医嘱id = v_医嘱id And a.样本状态 = 2
                         Order By 排序) A,
                       (Select Count(Distinct b.细菌id) As Num
                         From 检验标本记录 A, 检验普通结果 B
                         Where a.Id = b.检验标本id And a.报告结果 = b.记录类型 And a.医嘱id = v_医嘱id And a.样本状态 = 2) E
                  Where Rownum < e.Num)
           Where 细菌结果id Is Not Null
           Union All
           Select d.细菌结果id, 0, a.标本序号, RPad('       ' || e.中文名, 23, ' ') As 中文名,
                  RPad('  ' || d.结果, 9, ' ') ||
                   RPad(Decode(d.结果类型, 'R', '耐药(R)', 'I', '中介(I)', 'S', '敏感(S)', ' '), 10, ' '),
                  RPad(Decode(Instr(c.中文名, '支原体'), 0, e.用法用量1, ' '), 30, ' '),
                  Decode(Instr(c.中文名, '支原体'), 0, e.用法用量2, ' '),
                  RPad(Decode(Instr(c.中文名, '支原体'), 0, '    ' || e.血药浓度1, ' '), 20),
                  Decode(Instr(c.中文名, '支原体'), 0, e.血药浓度2, ' '), RPad(Decode(Instr(c.中文名, '支原体'), 0, e.尿药浓度1, ' '), 15),
                  Decode(Instr(c.中文名, '支原体'), 0, e.尿药浓度2, ' '), e.编码, ' '
           From 检验标本记录 A, 检验普通结果 B, 检验细菌 C, 检验药敏结果 D, 检验用抗生素 E
           Where a.Id = b.检验标本id And a.报告结果 = b.记录类型 And b.细菌id = c.Id And b.Id = d.细菌结果id And d.抗生素id = e.Id And
                 a.医嘱id = v_医嘱id And a.样本状态 = 2
           Order By 标本序号, 编码)
    Connect By Prior ID = 上级id
    Start With 上级id Is Null;
Begin

  Select Nvl(b.主页id, 0), Nvl(a.医嘱id, 0), Decode(a.病人来源, 2, 2, 4, 4, 1), Nvl(a.病人id, 0), Nvl(b.开嘱科室id, 0), Nvl(a.婴儿, 0),
         a.审核人, Nvl(a.微生物标本, 0)
  Into v_主页id, v_医嘱id, v_病人来源, v_病人id, v_开嘱科室id, v_婴儿, v_审核人, v_微生物
  From 检验标本记录 A, 病人医嘱记录 B
  Where a.医嘱id = b.Id(+) And a.Id = 检验标本id_In;
  If v_病人来源 = 1 Then
    --主页ID： 门诊病人填挂号ID
    Select Nvl(b.Id, 0)
    Into v_主页id
    From 病人挂号记录 B, 检验标本记录 A
    Where a.挂号单 = b.No(+) And a.Id = 检验标本id_In;
  End If;

  Select Max(Lengthb(b.中文名 || '(' || b.英文名 || ')')) + 5
  Into v_结果长度
  From 检验普通结果 A, 诊治所见项目 B, 检验标本记录 C
  Where a.检验项目id = b.Id And a.检验标本id = c.Id And c.医嘱id = v_医嘱id;

  If Nvl(v_结果长度, 0) <= 32 Then
    v_结果长度 := 32;
  End If;

  Begin
    Select 病历文件id, c.名称
    Into v_病历文件id, v_病历文件名
    From 病人医嘱记录 A, 病历单据应用 B, 病历文件列表 C
    Where a.诊疗项目id = b.诊疗项目id And b.病历文件id = c.Id And a.相关id = v_医嘱id And b.应用场合 = v_病人来源 And Rownum <= 1;
  Exception
    When Others Then
      Return;
  End;

  --删除以前的报告记录
  Begin
    Select 病历id Into v_文件id From 病人医嘱报告 Where 医嘱id = v_医嘱id And Rownum <= 1;
    Delete 电子病历内容 Where 文件id = v_文件id;
  Exception
    When Others Then
      Select 电子病历记录_Id.Nextval Into v_文件id From Dual;
    
      Insert Into 电子病历记录
        (ID, 病人来源, 病人id, 主页id, 婴儿, 科室id, 病历种类, 文件id, 病历名称, 创建人, 创建时间, 保存人, 保存时间, 最后版本, 签名级别)
      Values
        (v_文件id, v_病人来源, v_病人id, v_主页id, v_婴儿, v_开嘱科室id, 7, v_病历文件id, v_病历文件名, v_审核人, Sysdate, v_审核人, Sysdate, 1, 0);
    
      Insert Into 病人医嘱报告
        (医嘱id, 病历id)
        Select Distinct 医嘱id, v_文件id
        From (Select Distinct Decode(b.医嘱id, Null, a.医嘱id, b.医嘱id) As 医嘱id
               From 检验标本记录 A, 检验项目分布 B
               Where a.Id = b.标本id(+) And a.Id = 检验标本id_In)
        Where 医嘱id Is Not Null;
  End;

  For r_Source In v_Source Loop
  
    v_Loop := v_Loop + 1;
    Select 电子病历内容_Id.Nextval Into v_Nextid From Dual;
    v_写入格式 := 0;
  
    If r_Source.父id = 0 Then
      v_当前父id := v_Nextid;
      v_父id_In  := Null;
    Else
      v_父id_In := v_当前父id;
    End If;
  
    If r_Source.对象类型 = 4 And r_Source.替换域 = 1 Then
      v_替换内容 := Zl_Replace_Element_Value(r_Source.要素名称, v_病人id, v_主页id, v_病人来源, v_医嘱id);
      If r_Source.要素名称 = '单位名称' Then
        v_替换内容 := 单位名称_In;
      End If;
      Insert Into 电子病历内容
        (ID, 文件id, 开始版, 终止版, 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行)
      Values
        (v_Nextid, v_文件id, 1, 0, v_父id_In, v_Loop, r_Source.对象类型, r_Source.对象标记, r_Source.保留对象, r_Source.对象属性,
         r_Source.内容行次, v_替换内容, r_Source.是否换行);
    Elsif r_Source.对象类型 = 1 And r_Source.内容文本 = '检验结果' Then
      Insert Into 电子病历内容
        (ID, 文件id, 开始版, 终止版, 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行)
      Values
        (v_Nextid, v_文件id, 1, 0, v_父id_In, v_Loop, r_Source.对象类型, r_Source.对象标记, r_Source.保留对象, r_Source.对象属性,
         r_Source.内容行次, r_Source.内容文本, r_Source.是否换行);
      v_写入格式 := 1;
    Elsif r_Source.对象类型 = 1 And (r_Source.内容文本 = '一级报告' Or r_Source.内容文本 = '二级报告' Or r_Source.内容文本 = '三级报告') Then
      Insert Into 电子病历内容
        (ID, 文件id, 开始版, 终止版, 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行)
      Values
        (v_Nextid, v_文件id, 1, 0, v_父id_In, v_Loop, r_Source.对象类型, r_Source.对象标记, r_Source.保留对象, r_Source.对象属性,
         r_Source.内容行次, r_Source.内容文本, r_Source.是否换行);
      v_写入格式 := 1;
    Else
      Insert Into 电子病历内容
        (ID, 文件id, 开始版, 终止版, 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行)
      Values
        (v_Nextid, v_文件id, 1, 0, v_父id_In, v_Loop, r_Source.对象类型, r_Source.对象标记, r_Source.保留对象, r_Source.对象属性,
         r_Source.内容行次, r_Source.内容文本, r_Source.是否换行);
    End If;
  
    If v_写入格式 = 1 Then
      Select 电子病历内容_Id.Nextval Into v_Nextid From Dual;
      --在循环中插入检验结果格式
      If v_微生物 = 0 Then
        --普通标本
        For r_Result In v_Result Loop
          If (r_Result.隐私项目 = 1 And 显示隐私项目_In = 1) Or r_Result.隐私项目 = 0 Then
            v_Loop := v_Loop + 1;
            Select 电子病历内容_Id.Nextval Into v_Nextid From Dual;
            If Instr(r_Result.结果参考, Chr(13) || Chr(10)) > 0 Then
              v_检验结果 := r_Result.检验项目 || r_Result.检验结果 || r_Result.单位 || r_Result.结果标志 ||
                        Substr(r_Result.结果参考, 1, Instr(r_Result.结果参考, Chr(13) || Chr(10)) - 1);
            Else
              v_检验结果 := r_Result.检验项目 || r_Result.检验结果 || r_Result.单位 || r_Result.结果标志 || r_Result.结果参考;
            End If;
            Insert Into 电子病历内容
              (ID, 文件id, 开始版, 终止版, 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行)
            Values
              (v_Nextid, v_文件id, 1, 0, v_当前父id, v_Loop, 2, v_Loop, Null, 0, Null, v_检验结果, 1);
          End If;
        End Loop;
      Else
        --微生物标本
        If r_Source.内容文本 = '检验结果' Then
          For r_Result In v_Mresult Loop
            v_Loop := v_Loop + 1;
            Select 电子病历内容_Id.Nextval Into v_Nextid From Dual;
            v_检验结果 := r_Result.项目 || r_Result.耐药 || r_Result.用法用量1 || r_Result.血药浓度1 || r_Result.尿药浓度1;
            Insert Into 电子病历内容
              (ID, 文件id, 开始版, 终止版, 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行)
            Values
              (v_Nextid, v_文件id, 1, 0, v_当前父id, v_Loop, 2, v_Loop, Null, 0, Null, v_检验结果, 1);
          End Loop;
        Elsif r_Source.内容文本 = '一级报告' Then
          Select 一级报告 Into v_报告 From 检验标本记录 Where ID = 检验标本id_In;
          Insert Into 电子病历内容
            (ID, 文件id, 开始版, 终止版, 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行)
          Values
            (v_Nextid, v_文件id, 1, 0, v_当前父id, v_Loop, 2, v_Loop, Null, 0, Null, v_报告, 1);
        Elsif r_Source.内容文本 = '二级报告' Then
          Select 二级报告 Into v_报告 From 检验标本记录 Where ID = 检验标本id_In;
          Insert Into 电子病历内容
            (ID, 文件id, 开始版, 终止版, 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行)
          Values
            (v_Nextid, v_文件id, 1, 0, v_当前父id, v_Loop, 2, v_Loop, Null, 0, Null, v_报告, 1);
        Elsif r_Source.内容文本 = '三级报告' Then
          Select 三级报告 Into v_报告 From 检验标本记录 Where ID = 检验标本id_In;
          Insert Into 电子病历内容
            (ID, 文件id, 开始版, 终止版, 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行)
          Values
            (v_Nextid, v_文件id, 1, 0, v_当前父id, v_Loop, 2, v_Loop, Null, 0, Null, v_报告, 1);
        End If;
      End If;
    End If;
  
  End Loop;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_检验报告单_Update;
/

--105441:刘尔旋,2017-07-03,结帐分别退三方卡预交
Create Or Replace Procedure Zl_三方结算交易_Insert
(
  卡类别id_In   病人预交记录.卡类别id%Type,
  消费卡_In     Number,
  卡号_In       病人预交记录.卡号%Type,
  结帐ids_In    Varchar2,
  交易信息_In   Varchar2,
  预交款缴款_In Number := 0,
  结算方式_In   病人预交记录.结算方式%Type := Null,
  预交id_In     病人预交记录.Id%Type := Null
) As
  --功能：用于填制扩展的交易信息
  --参数：
  --        消费卡_IN:1-消费卡结算;0-医疗卡结算
  --        卡类别ID_In:消费卡时为接口编号;医疗卡类别.ID;卡类别ID_In:NULL 表示不存三卡类别ID,但允许通过结算方式_In来更新三方结算数据
  --        结帐IDs_In:以逗号分离
  --        交易信息_IN:格式:交易项目|交易内容||...
  --        预交款缴款_In:1-代表预交款缴款;0-代表消费扣款
  v_Err_Msg Varchar2(500);
  Err_Item Exception;
  v_名称     Varchar2(100);
  v_交易信息 Varchar2(4000);
  v_当前交易 Varchar2(4000);
  v_交易项目 三方结算交易.交易项目%Type;
  v_交易内容 三方结算交易.交易内容%Type;
  v_附加内容 Varchar2(100);
Begin
  If 交易信息_In Is Null Then
    Return;
  End If;

  If Nvl(预交id_In, 0) <> 0 Then
    v_附加内容 := '(' || 预交id_In || ')';
  Else
    v_附加内容 := Null;
  End If;

  --1.按结算方式来更新(主要应用于自助机的相关信息)
  If 结算方式_In Is Not Null And 卡类别id_In Is Null Then
    v_交易信息 := 交易信息_In || '||';
    While v_交易信息 Is Not Null Loop
      v_当前交易 := Substr(v_交易信息, 1, Instr(v_交易信息, '||') - 1);
      v_交易项目 := Substr(v_当前交易, 1, Instr(v_当前交易, '|') - 1);
      v_交易内容 := Substr(v_当前交易, Instr(v_当前交易, '|') + 1);
      If v_交易项目 Is Not Null Then
        If 预交款缴款_In = 0 Then
          Insert Into 三方结算交易
            (交易id, 交易项目, 交易内容)
            Select /*+ rule */
             ID, v_交易项目 || v_附加内容, v_交易内容
            From 病人预交记录
            Where 卡类别id Is Null And 结算方式 = 结算方式_In And Mod(记录性质, 10) <> 1 And
                  结帐id In (Select Column_Value From Table(Cast(f_Num2list(结帐ids_In) As Zltools.t_Numlist)) J);
        Else
          Insert Into 三方结算交易
            (交易id, 交易项目, 交易内容)
            Select /*+ rule */
             ID, v_交易项目 || v_附加内容, v_交易内容
            From 病人预交记录
            Where 卡类别id Is Null And 结算方式 = 结算方式_In And
                  ID In (Select Column_Value From Table(Cast(f_Num2list(结帐ids_In) As Zltools.t_Numlist)) J);
        End If;
      End If;
      v_交易信息 := Substr(v_交易信息, Instr(v_交易信息, '||') + 2);
    End Loop;
    Return;
  End If;

  --2.按卡类别ID来更新(主要应用于自助机的相关信息)
  v_交易信息 := 交易信息_In || '||';
  While v_交易信息 Is Not Null Loop
    v_当前交易 := Substr(v_交易信息, 1, Instr(v_交易信息, '||') - 1);
    v_交易项目 := Substr(v_当前交易, 1, Instr(v_当前交易, '|') - 1);
    v_交易内容 := Substr(v_当前交易, Instr(v_当前交易, '|') + 1);
    If v_交易项目 Is Not Null Then
      If Nvl(消费卡_In, 0) = 1 Then
        Begin
          Select 名称 Into v_名称 From 卡消费接口目录 Where 编号 = 卡类别id_In;
        Exception
          When Others Then
            v_名称 := Null;
        End;
      
        If v_名称 Is Null Then
          v_Err_Msg := '卡类别参数传入错误,请检查  ！';
          Raise Err_Item;
        End If;
        If 预交款缴款_In = 0 Then
          Insert Into 三方结算交易
            (交易id, 交易项目, 交易内容)
            Select /*+ rule */
             ID, v_交易项目 || v_附加内容, v_交易内容
            From 病人预交记录
            Where 结算卡序号 = 卡类别id_In And Mod(记录性质, 10) <> 1 And (卡号 = 卡号_In Or 卡号 Is Null) And
                  结帐id In (Select Column_Value From Table(Cast(f_Num2list(结帐ids_In) As Zltools.t_Numlist)) J);
        Else
          Insert Into 三方结算交易
            (交易id, 交易项目, 交易内容)
            Select /*+ rule */
             ID, v_交易项目 || v_附加内容, v_交易内容
            From 病人预交记录
            Where 结算卡序号 = 卡类别id_In And (卡号 = 卡号_In Or 卡号 Is Null) And
                  ID In (Select Column_Value From Table(Cast(f_Num2list(结帐ids_In) As Zltools.t_Numlist)) J);
        End If;
      Else
        Begin
          Select 名称 Into v_名称 From 医疗卡类别 Where ID = 卡类别id_In;
        Exception
          When Others Then
            v_名称 := Null;
        End;
        If v_名称 Is Null Then
          v_Err_Msg := '卡类别参数传入错误,请检查  ！';
          Raise Err_Item;
        End If;
        If 预交款缴款_In = 0 Then
          Insert Into 三方结算交易
            (交易id, 交易项目, 交易内容)
            Select /*+ rule */
             ID, v_交易项目 || v_附加内容, v_交易内容
            From 病人预交记录
            Where 卡类别id = 卡类别id_In And Mod(记录性质, 10) <> 1 And (卡号 = 卡号_In Or 卡号 Is Null) And
                  结帐id In (Select Column_Value From Table(Cast(f_Num2list(结帐ids_In) As Zltools.t_Numlist)) J);
        Else
          Insert Into 三方结算交易
            (交易id, 交易项目, 交易内容)
            Select /*+ rule */
             ID, v_交易项目 || v_附加内容, v_交易内容
            From 病人预交记录
            Where 卡类别id = 卡类别id_In And (卡号 = 卡号_In Or 卡号 Is Null) And
                  ID In (Select Column_Value From Table(Cast(f_Num2list(结帐ids_In) As Zltools.t_Numlist)) J);
        
        End If;
      End If;
    End If;
    v_交易信息 := Substr(v_交易信息, Instr(v_交易信息, '||') + 2);
  End Loop;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_三方结算交易_Insert;
/

--105441:刘尔旋,2017-07-03,结帐分别退三方卡预交
Create Or Replace Procedure Zl_病人结帐结算_Modify
(
  操作类型_In      Number,
  病人id_In        门诊费用记录.病人id%Type,
  结帐id_In        病人预交记录.结帐id%Type,
  结算方式_In      Varchar2,
  冲预交_In        病人预交记录.冲预交%Type := Null,
  退支票额_In      病人预交记录.冲预交%Type := Null,
  卡类别id_In      病人预交记录.卡类别id%Type := Null,
  卡号_In          病人预交记录.卡号%Type := Null,
  交易流水号_In    病人预交记录.交易流水号%Type := Null,
  交易说明_In      病人预交记录.交易说明%Type := Null,
  缴款_In          病人预交记录.缴款%Type := Null,
  找补_In          病人预交记录.找补%Type := Null,
  误差金额_In      门诊费用记录.实收金额%Type := Null,
  结帐类型_In      Number := 2,
  缺省结算方式_In  结算方式.名称%Type := Null,
  操作员编号_In    病人预交记录.操作员编号%Type := Null,
  操作员姓名_In    病人预交记录.操作员姓名%Type := Null,
  收款时间_In      病人预交记录.收款时间%Type := Null,
  冲预交病人ids_In Varchar2 := Null,
  完成结算_In      Number := 0
) As
  ------------------------------------------------------------------------------------------------------------------------------
  --功能:收费结算时,修改结算的相关信息
  --操作类型_In:
  --   0-普通收费方式:
  --     ①结算方式_IN:允许传入多个,格式为:"结算方式|结算金额|结算号码|结算摘要||.." ;也允许传入空.
  --     ②退支票额_In:如果涉及退支票,则传入本次的退支票额,非正常收费时,传入零
  --   1.三方卡结算:
  --     ①结算方式_IN:只能传入一个结算方式,但允许包含一些辅助信息,格式为:"结算方式|结算金额|结算号码|结算摘要"
  --     ②退支票额_In:传入零
  --     ③卡类别ID_IN,卡号_IN,交易流水号_IN,交易说明_In:需要传入
  --   2-医保结算(如果存在医保的结算,则要先删除原医保结算,后按新传入的更新)
  --     ①结算方式_IN:允许传入多个,格式为:结算方式|结算金额||.."
  --     ②退支票额_In:传入零
  --   3-消费卡结算:
  --     ①结算方式_IN:允许一次刷多张卡,格式为:卡类别ID|卡号|消费卡ID|消费金额||."  消费卡ID:为零时,根据卡号自动定位
  --     ②冲预交_In: 传入零
  --     ②退支票额_In:传入零
  -- 冲预交_In: 存在冲预交时,传入
  -- 误差金额_In:存在误差费时,传入
  --  结帐类型_IN:1-门诊结帐;2-住院结帐
  --冲预交病人ids_In:多个用逗分分离,冲预交时有效(冲预交类别与业务操作保持一致),主要是使用家属的预交款
  -- 完成结算_In:1-完成收费;0-未完成收费
  ------------------------------------------------------------------------------------------------------------------------------
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_结算内容      Varchar2(500);
  v_当前结算      Varchar2(300);
  v_卡号          病人医疗卡信息.卡号%Type;
  n_消费卡id      消费卡目录.Id%Type;
  n_卡类别id      病人预交记录.结算卡序号%Type;
  v_名称          Varchar2(100);
  n_自制卡        卡消费接口目录.自制卡%Type;
  n_序号          病人卡结算记录.序号%Type;
  n_Id            病人卡结算记录.Id%Type;
  n_预交id        病人预交记录.Id%Type;
  v_结算方式      病人预交记录.结算方式%Type;
  n_结算金额      病人预交记录.冲预交%Type;
  n_返回值        人员缴款余额.余额%Type;
  n_预交金额      病人预交记录.冲预交%Type;
  n_冲预交        病人预交记录.冲预交%Type;
  n_主页id        病人预交记录.主页id%Type;
  v_退支票        病人预交记录.结算方式%Type;
  v_结算号码      病人预交记录.结算号码%Type;
  v_结算摘要      病人预交记录.摘要%Type;
  v_误差费        结算方式.名称%Type;
  n_误差金额      病人预交记录.冲预交%Type;
  n_科室id        病人预交记录.科室id%Type;
  n_Count         Number;
  n_Havenull      Number;
  l_预交id        t_Numlist := t_Numlist();
  v_冲预交病人ids Varchar2(4000);
  n_缴款组id      病人预交记录.缴款组id%Type;

  Cursor c_Balance_Record Is
    Select Max(m.病人id) As 病人id, Max(NO) As NO, Max(Nvl(收款时间_In, m.收费时间)) As 收费时间, Max(Nvl(操作员编号_In, m.操作员编号)) As 操作员编号,
           Max(Nvl(m.操作员姓名, 操作员姓名_In)) As 操作员姓名, Max(Nvl(n_缴款组id, m.缴款组id)) As 缴款组id, Max(结帐类型) As 结帐类型

    
    From 病人结帐记录 M
    Where m.Id = 结帐id_In;
  r_Balance_Record c_Balance_Record%RowType;

  Cursor c_Balancedata Is
    Select 记录性质, NO, 记录状态, 病人id, 主页id, 结算方式, Nvl(收款时间_In, 收款时间) As 收款时间, Nvl(操作员编号_In, 操作员编号) As 操作员编号,
           Nvl(操作员姓名_In, 操作员姓名) As 操作员姓名, 冲预交, 结帐id, Nvl(n_缴款组id, 缴款组id) As 缴款组id, 结算序号
    From 病人预交记录
    Where 结帐id = 结帐id_In And 结算方式 Is Null;

  r_Balancedata c_Balancedata%RowType;
Begin
  v_冲预交病人ids := Nvl(冲预交病人ids_In, 病人id_In);

  If 操作员姓名_In Is Null Then
    n_缴款组id := Null;
  Else
    n_缴款组id := Zl_Get组id(操作员姓名_In);
  End If;

  Begin
    Select 当前科室id Into n_科室id From 病人信息 Where 病人id = 病人id_In;
  Exception
    When Others Then
      n_科室id := Null;
  End;

  --0.正式结算
  Select Count(1), Max(Decode(结算方式, Null, 1, 0)), Sum(冲预交)
  Into n_Count, n_Havenull, n_冲预交
  From 病人预交记录
  Where 结帐id = 结帐id_In;

  If Nvl(n_Count, 0) = 0 Or Nvl(误差金额_In, 0) <> 0 Then
    --增加结算方式为NULL的记录
    Begin
      Select 名称 Into v_误差费 From 结算方式 Where Nvl(性质, 0) = 9;
    Exception
      When Others Then
        v_误差费 := '误差费';
    End;
  End If;

  --1.增加结算方式为空的结算数据
  If Nvl(n_Havenull, 0) = 0 Then
    n_Count := 0;
    Open c_Balance_Record;
    Begin
      Fetch c_Balance_Record
        Into r_Balance_Record;
    
      Select Sum(Nvl(结帐金额, 0))
      Into n_结算金额
      From (Select Sum(结帐金额) As 结帐金额
             From 住院费用记录
             Where 结帐id = 结帐id_In
             Union All
             Select Sum(结帐金额) As 结帐金额 From 门诊费用记录 Where 结帐id = 结帐id_In);
    
      Begin
        Select 主页id Into n_主页id From 病人结帐记录 Where ID = 结帐id_In;
      Exception
        When Others Then
          n_主页id := Null;
      End;
    
      n_误差金额 := n_结算金额 - Round(Nvl(n_结算金额, 0), 6);
      n_结算金额 := Round(Nvl(n_结算金额, 0) - Nvl(n_冲预交, 0), 6);
    
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 科室id, 主页id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 校对标志, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 2, r_Balance_Record.No, 1, Decode(病人id_In, 0, Null, 病人id_In), n_科室id, n_主页id, Null,
         r_Balance_Record.收费时间, r_Balance_Record.操作员编号, r_Balance_Record.操作员姓名, n_结算金额, 结帐id_In, r_Balance_Record.缴款组id,
         1, 2);
    
      --误差费(先汇总后生成误差费
      If n_误差金额 <> 0 Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 科室id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 2, r_Balance_Record.No, 1, Decode(病人id_In, 0, Null, 病人id_In), n_科室id, v_误差费,
           r_Balance_Record.收费时间, r_Balance_Record.操作员编号, r_Balance_Record.操作员姓名, n_误差金额, 结帐id_In,
           r_Balance_Record.缴款组id, -1 * 结帐id_In, 1, 2);
      End If;
    Exception
      When Others Then
        n_Count := 1;
    End;
  
    n_冲预交 := 0;
    Close c_Balance_Record;
    If n_Count = 1 Then
      v_Err_Msg := '未找到指定的结帐数据,结算操作失败！';
      Raise Err_Item;
    End If;
  End If;

  If 操作类型_In = 0 And Nvl(退支票额_In, 0) <> 0 Then
    Begin
      Select b.名称
      Into v_退支票
      From 结算方式应用 A, 结算方式 B
      Where a.应用场合 = '结帐' And b.名称 = a.结算方式 And Nvl(b.应付款, 0) = 1 And Rownum <= 1;
    Exception
      When Others Then
        v_退支票 := '无';
    End;
    If v_退支票 = '无' Then
      v_Err_Msg := '在结算场合中,不存在结算性质为应付款的结算方式,请在[结算方式]中设置！';
      Raise Err_Item;
    End If;
  End If;

  Open c_Balancedata;
  Fetch c_Balancedata
    Into r_Balancedata;

  If Nvl(误差金额_In, 0) <> 0 Then
    Update 病人预交记录
    Set 冲预交 = Nvl(冲预交, 0) + Nvl(误差金额_In, 0)
    Where 结帐id = 结帐id_In And 结算方式 = v_误差费;
    If Sql%NotFound Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 科室id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 2, r_Balancedata.No, 1, r_Balancedata.病人id, n_科室id, r_Balancedata.主页id, Null, v_误差费,
         r_Balancedata.收款时间, r_Balancedata.操作员编号, r_Balancedata.操作员姓名, 误差金额_In, r_Balancedata.结帐id, r_Balancedata.缴款组id,
         2, Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 2);
    End If;
    Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(误差金额_In, 0) Where 结帐id = 结帐id_In And 结算方式 Is Null;
    If Sql%NotFound Then
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
      Raise Err_Item;
    End If;
  End If;

  --预交款处理
  If Nvl(冲预交_In, 0) <> 0 Then
    If Nvl(病人id_In, 0) = 0 Then
      v_Err_Msg := '不能确定病人的病人ID,收费不能使用预交款结算,结算操作失败！';
      Raise Err_Item;
    End If;
  
    --病人余额检查
    Begin
      Select Sum(Nvl(预交余额, 0) - Nvl(费用余额, 0))
      Into n_预交金额
      From 病人余额
      Where 病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And Nvl(性质, 0) = 1 And
            类型 = Nvl(结帐类型_In, 0);
    Exception
      When Others Then
        n_预交金额 := 0;
    End;
  
    If Nvl(n_预交金额, 0) < Nvl(冲预交_In, 0) Then
      v_Err_Msg := '病人的当前预交余额为 ' || LTrim(To_Char(n_预交金额, '9999999990.00')) || '(含家属)，小于本次支付金额 ' ||
                   LTrim(To_Char(冲预交_In, '9999999990.00')) || '，支付失败！';
      Raise Err_Item;
    End If;
  
    n_预交金额 := 冲预交_In;
  
    For c_冲预交 In (Select *
                  From (Select a.Id, a.记录状态, a.病人id, a.No, Nvl(a.金额, 0) As 金额
                         From 病人预交记录 A,
                              (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                                From 病人预交记录 A
                                Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And
                                      a.病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And
                                      预交类别 = Nvl(结帐类型_In, 0)
                                Group By NO
                                Having Sum(Nvl(a.金额, 0)) <> 0) B
                         Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.No = b.No And
                               a.病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And
                               a.预交类别 = Nvl(结帐类型_In, 0)
                         Union All
                         Select 0 As ID, 记录状态, Max(病人id) As 病人id, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
                         From 病人预交记录
                         Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(金额, 0) <> Nvl(冲预交, 0) And
                               病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And 预交类别 = Nvl(结帐类型_In, 0)
                          Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
                         Group By 记录状态, NO)
                  Order By Decode(病人id, Nvl(病人id_In, 0), 0, 1), ID, NO) Loop
    
      If c_冲预交.金额 - n_预交金额 < 0 Then
        n_冲预交 := c_冲预交.金额;
      Else
        n_冲预交 := n_预交金额;
      End If;
    
      If c_冲预交.Id <> 0 Then
        --第一次冲预交(填上结帐ID,金额为0
        Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 2 Where ID = c_冲预交.Id;
      End If;
    
      --冲上次剩余额
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
               r_Balancedata.收款时间, r_Balancedata.操作员姓名, r_Balancedata.操作员编号, n_冲预交, 结帐id_In, r_Balancedata.缴款组id, 预交类别,
               卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 2
        From 病人预交记录
        Where NO = c_冲预交.No And 记录状态 = c_冲预交.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
    
      --更新数据(结算方式为NULL的)
      Update 病人预交记录
      Set 冲预交 = 冲预交 - n_冲预交
      Where 结帐id = 结帐id_In And 结算方式 Is Null
      Returning Nvl(冲预交, 0) Into n_返回值;
    
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - n_冲预交
      Where 病人id = c_冲预交.病人id And 性质 = 1 And 类型 = Nvl(结帐类型_In, 0)
      Returning 预交余额 Into n_返回值;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 类型, 预交余额, 性质)
        Values
          (c_冲预交.病人id, Nvl(结帐类型_In, 0), -1 * n_冲预交, 1);
        n_返回值 := -1 * n_冲预交;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = c_冲预交.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --检查是否已经处理完
      If c_冲预交.金额 < n_预交金额 Then
        n_预交金额 := n_预交金额 - c_冲预交.金额;
      Else
        n_预交金额 := 0;
      End If;
      If n_预交金额 = 0 Then
        Exit;
      End If;
    
    End Loop;
    --检查金额是否足够
    If Abs(n_预交金额) > 0 Then
      v_Err_Msg := '病人的当前预交余额小于本次支付金额 ' || LTrim(To_Char(冲预交_In, '9999999990.00')) || '，支付失败！';
      Raise Err_Item;
    End If;
  
  End If;
  If 操作类型_In = 0 Then
  
    If Nvl(退支票额_In, 0) <> 0 Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 科室id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 2, r_Balancedata.No, 1, r_Balancedata.病人id, n_科室id, r_Balancedata.主页id, Null, v_退支票,
         r_Balancedata.收款时间, r_Balancedata.操作员编号, r_Balancedata.操作员姓名, 退支票额_In, r_Balancedata.结帐id, r_Balancedata.缴款组id,
         2, Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 2);
    
      Update 病人预交记录 Set 冲预交 = 冲预交 - 退支票额_In Where 结帐id = 结帐id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
        Raise Err_Item;
      End If;
    End If;
  
    --各个收费结算 :格式为:"结算方式|结算金额|结算号码|结算摘要||.."
    v_结算内容 := 结算方式_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
    
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If Nvl(n_结算金额, 0) <> 0 Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 科室id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 2, r_Balancedata.No, 1, r_Balancedata.病人id, n_科室id, r_Balancedata.主页id, v_结算摘要, v_结算方式,
           r_Balancedata.收款时间, r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id,
           2, Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, v_结算号码, 2);
      
        Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 结帐id_In And 结算方式 Is Null;
        If Sql%NotFound Then
          v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
          Raise Err_Item;
        End If;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If 操作类型_In = 1 Then
    --三方卡结算交易
  
    v_当前结算 := 结算方式_In;
  
    v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
  
    If Nvl(n_结算金额, 0) <> 0 Then
      Update 病人预交记录 Set 冲预交 = 冲预交 + n_结算金额 Where 结帐id = 结帐id_In And 结算方式 = v_结算方式;
      If Sql%RowCount = 0 Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 科室id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 2, r_Balancedata.No, 1, r_Balancedata.病人id, n_科室id, r_Balancedata.主页id, v_结算摘要, v_结算方式,
           r_Balancedata.收款时间, r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id,
           2, 卡类别id_In, Null, 卡号_In, 交易流水号_In, 交易说明_In, v_结算号码, 2);
      End If;
      Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 结帐id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
        Raise Err_Item;
      End If;
    End If;
  End If;

  --2.医保结算(调用此过程,采取平均分摊的方式分摊结算情况):这种情况医保结处后,必须全退
  If 操作类型_In = 2 Then
    --2.1检查是否已经存在医保结算数据,存在先删除
    n_结算金额 := 0;
    For v_医保 In (Select ID, 结算方式, 冲预交
                 From 病人预交记录 A
                 Where 结帐id = 结帐id_In And Exists
                  (Select 1 From 结算方式 Where a.结算方式 = 名称 And 性质 In (3, 4)) And Mod(记录性质, 10) <> 1) Loop
      n_结算金额 := n_结算金额 + Nvl(v_医保.冲预交, 0);
      l_预交id.Extend;
      l_预交id(l_预交id.Count) := v_医保.Id;
    End Loop;
    If Nvl(n_结算金额, 0) <> 0 Then
      Update 病人预交记录
      Set 冲预交 = Nvl(冲预交, 0) + Nvl(n_结算金额, 0)
      Where 结帐id = 结帐id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
        Raise Err_Item;
      End If;
    End If;
    If l_预交id.Count <> 0 Then
      Forall I In 1 .. l_预交id.Count
        Delete 病人预交记录 Where ID = l_预交id(I);
    End If;
  
    If 结算方式_In Is Not Null Then
      v_结算内容 := 结算方式_In || '||';
    End If;
  
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If n_结算金额 <> 0 Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 科室id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 校对标志, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 2, r_Balancedata.No, 1, r_Balancedata.病人id, n_科室id, r_Balancedata.主页id, '保险结算', v_结算方式,
           r_Balancedata.收款时间, r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id,
           2, 2);
      
        --更新数据(结算方式为NULL的)
        Update 病人预交记录
        Set 冲预交 = 冲预交 - n_结算金额
        Where 结帐id = 结帐id_In And 结算方式 Is Null
        Returning Nvl(冲预交, 0) Into n_返回值;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
    --医保相关表的处理
    Update 保险结算明细 Set 标志 = 2 Where 结帐id = 结帐id_In;
  End If;

  --3-消费卡批量结算
  If 操作类型_In = 3 Then
    v_结算内容 := 结算方式_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      --卡类别ID|卡号|消费卡ID|消费金额
      n_卡类别id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_卡号     := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_消费卡id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(v_当前结算);
      Begin
        Select 名称, 自制卡, 结算方式 Into v_名称, n_自制卡, v_结算方式 From 卡消费接口目录 Where 编号 = n_卡类别id;
      Exception
        When Others Then
          v_名称 := Null;
      End;
      If v_名称 Is Null Then
        v_Err_Msg := '未找到对应的结算卡接口,本次刷卡消费失败!';
        Raise Err_Item;
      End If;
      If v_结算方式 Is Null Then
        v_Err_Msg := v_名称 || '未设置对应的结算方式,本次刷卡消费失败!';
        Raise Err_Item;
      End If;
      If Nvl(n_消费卡id, 0) = 0 Then
        --未传入消费卡ID时,以卡号为准进行查找(卡号的合法性,在程序中有判断)
        Begin
          Select ID
          Into n_消费卡id
          From 消费卡目录
          Where 接口编号 = n_卡类别id And 卡号 = v_卡号 And
                序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = n_卡类别id And 卡号 = v_卡号);
        Exception
          When Others Then
            n_消费卡id := 0;
        End;
        If Nvl(n_消费卡id, 0) = 0 Then
          v_Err_Msg := '未找到卡号为:' || v_卡号 || '的' || v_名称 || '.,本次刷卡消费失败!';
          Raise Err_Item;
        End If;
      End If;
    
      If Nvl(n_结算金额, 0) <> 0 Then
      
        Update 病人预交记录
        Set 冲预交 = Nvl(冲预交, 0) + n_结算金额
        Where 结帐id = r_Balancedata. 结帐id And 结算方式 = v_结算方式 And 结算卡序号 = n_卡类别id
        Returning ID Into n_预交id;
        If Sql%NotFound Then
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 科室id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算卡序号, 校对标志, 结算性质)
          Values
            (n_预交id, 2, r_Balancedata.No, 1, r_Balancedata. 病人id, n_科室id, r_Balancedata.主页id, Null, v_结算方式,
             r_Balancedata. 收款时间, r_Balancedata. 操作员编号, r_Balancedata. 操作员姓名, n_结算金额, r_Balancedata. 结帐id,
             r_Balancedata. 缴款组id, n_卡类别id, 2, 2);
        End If;
      
        --插入卡结算记录
        Begin
          Select Nvl(Max(Nvl(序号, 0)), 0) + 1
          Into n_序号
          From 病人卡结算记录
          Where 接口编号 = n_卡类别id And Nvl(消费卡id, 0) = Nvl(n_消费卡id, 0) And 卡号 = v_卡号;
        Exception
          When Others Then
            n_序号 := 1;
        End;
      
        Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      
        Insert Into 病人卡结算记录
          (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Values
          (n_Id, n_卡类别id, n_消费卡id, n_序号, 1, v_结算方式, n_结算金额, v_卡号, Null, r_Balancedata. 收款时间, Null, 0);
        --如果消费卡,需同时更改其余额
        If Nvl(n_消费卡id, 0) <> 0 Then
          Update 消费卡目录 Set 余额 = 余额 - n_结算金额 Where ID = n_消费卡id;
          If Sql%NotFound Then
            v_Err_Msg := '卡号为' || v_卡号 || '的' || v_名称 || '未找到!';
            Raise Err_Item;
          End If;
        End If;
        Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
      
        --更新数据(结算方式为NULL的)
        Update 病人预交记录
        Set 冲预交 = 冲预交 - n_结算金额
        Where 结帐id = r_Balancedata. 结帐id And 结算方式 Is Null And Nvl(校对标志, 0) = 1
        Returning Nvl(冲预交, 0) Into n_返回值;
      
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If Nvl(完成结算_In, 0) = 0 Then
    Close c_Balancedata;
    Return;
  End If;

  -----------------------------------------------------------------------------------------
  --完成收费,需要处理人员缴款余额,预交记录(结算方式=NULL)

  --1.删除结算方式为NULL的预交记录
  Delete 病人预交记录 Where 结帐id = 结帐id_In And 结算方式 Is Null And Nvl(冲预交, 0) = 0;
  If Sql%NotFound Then
    Select Count(*) Into n_Count From 病人预交记录 A Where 结帐id = 结帐id_In And 结算方式 Is Null;
    If n_Count <> 0 Then
      v_Err_Msg := '还存在未缴款的数据,不能完成结算!';
    Else
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！!';
    End If;
    Raise Err_Item;
  End If;

  --结算金额为零时，增加一条金额为0的病人预交记录
  Select Count(*) Into n_Count From 病人预交记录 A Where 结帐id = 结帐id_In;

  If n_Count = 0 Then
    v_结算方式 := 缺省结算方式_In;
    If v_结算方式 Is Null Then
      Begin
        Select 结算方式 Into v_结算方式 From 结算方式应用 Where 应用场合 = '结帐' And Nvl(缺省标志, 0) = 1;
      Exception
        When Others Then
          v_结算方式 := Null;
      End;
      If v_结算方式 Is Null Then
        Begin
          Select 名称 Into v_结算方式 From 结算方式 Where Nvl(性质, 0) = 1;
        Exception
          When Others Then
            v_结算方式 := '现金';
        End;
      End If;
    End If;
  
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 科室id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 校对标志, 卡类别id, 结算卡序号, 卡号,
       交易流水号, 交易说明, 结算号码, 结算性质)
    Values
      (病人预交记录_Id.Nextval, 2, Null, 1, r_Balancedata.病人id, n_科室id, Null, Null, v_结算方式, r_Balancedata.收款时间,
       r_Balancedata.操作员编号, r_Balancedata.操作员姓名, 0, r_Balancedata.结帐id, r_Balancedata.缴款组id, 2, Null, Null, Null, Null,
       交易说明_In, Null, 2);
  End If;

  --2.处理缴款数据和找补数据及校对标志更新为0
  Update 病人预交记录 Set 缴款 = 缴款_In, 找补 = 找补_In, 校对标志 = 0 Where 结帐id = 结帐id_In;

  --3.更新费用状态
  Update 病人结帐记录 Set 结算状态 = Null Where ID = 结帐id_In;

  --4.更新人员缴款数据
  For c_缴款 In (Select 结算方式, 操作员姓名, Sum(Nvl(a.冲预交, 0)) As 冲预交
               From 病人预交记录 A
               Where a.结帐id = 结帐id_In And Mod(a.记录性质, 10) <> 1
               Group By 结算方式, 操作员姓名) Loop
  
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + Nvl(c_缴款.冲预交, 0)
    Where 收款员 = c_缴款.操作员姓名 And 性质 = 1 And 结算方式 = c_缴款.结算方式;
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额
        (收款员, 结算方式, 性质, 余额)
      Values
        (c_缴款.操作员姓名, c_缴款.结算方式, 1, Nvl(c_缴款.冲预交, 0));
    End If;
  End Loop;
  Close c_Balancedata;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人结帐结算_Modify;
/

--111266:冉俊明,2017-07-10,转病区费用调整
--111241:冉俊明,2017-07-07,转病区费用
--111199:冉俊明,2017-07-07,转病区费用
--105570:冉俊明,2017-07-05,转病区费用
Create Or Replace Procedure Zl_Turntoward_Fee
(
  操作_In       Number,
  病人id_In     病案主页.病人id%Type,
  主页id_In     病案主页.病人id%Type,
  变动id_In     病人变动记录.Id%Type,
  原病区id_In   病案主页.当前病区id%Type,
  目标病区id_In 病案主页.当前病区id%Type,
  操作员编号_In 住院费用记录.操作员编号%Type,
  操作员姓名_In 住院费用记录.操作员姓名%Type,
  变动时间_In   住院费用记录.登记时间%Type := Null
) Is
  --功能:病人转病区费用的转入，转出处理
  --入参:操作_In: 0-病区变动,1-撤消病区变动
  --   1、操作_IN=0(病区变动)时
  --       变动ID_In: 原病区的变动记录的ID
  --       原病区ID_IN：原病区ID
  --       目标病区ID_IN:目标病区ID
  --   2、操作_IN=1(撤消病区变动)时
  --       变动ID_In: 恢复的原始病区的变动记录的ID
  --       原病区ID_IN：被撤消的病区ID
  --       目标病区ID_IN:恢复的原始病区ID
  --转入，转出规则:
  --1.病区执行的非药品和卫生材料，处理规则为
  --   1)将原记录进行销帐处理
  --   2)新增一条新病区的费用，病人科室，发生时间不变
  --2.病区执行的药品和卫生材料
  --   这个卫材退的处理在转病区时的界面中进行确认(可以打印核查清单)，在转病区发起的时候确认。
  --   a)卫材在原病区通过销帐申请来处理，新病区手工计卫材；
  --   b)撤消转病区时，自动撤消销帐申请，如果已经销帐审核了，则询问提示并且不作卫材费用处理，手工去处理。
  Err_Item Exception;
  v_Err_Msg Varchar2(200);

  v_No             住院费用记录.No%Type;
  n_Max序号        住院费用记录.序号%Type;
  n_Dec            Number;
  n_病人审核方式   Number(2);
  n_未入科禁止记账 Number(2);
  n_审核标志       病案主页.审核标志%Type;
  n_住院状态       病案主页.状态%Type;
  n_已检查         Number(2);
  v_责任护士       病人变动记录.责任护士%Type;
  d_登记时间       Date;
  n_Count          Number(18);

  n_未发料数量   病人费用销帐.数量%Type;
  n_申请未发数量 病人费用销帐.数量%Type;
  n_申请已发数量 病人费用销帐.数量%Type;
  n_申请销账数量 病人费用销帐.数量%Type;
  n_申请取消数量 病人费用销帐.数量%Type;

  v_原病区名称   部门表.名称%Type;
  v_目标病区名称 部门表.名称%Type;
  n_应收金额     住院费用记录.应收金额%Type;
  n_实收金额     住院费用记录.实收金额%Type;
  n_记录状态     费用变动记录.记录状态%Type;

  n_原变动id   病人变动记录.Id%Type;
  n_目标变动id 病人变动记录.Id%Type;
  n_变动id     病人变动记录.Id%Type;

  Procedure 销帐申请_Insert
  (
    费用id_In     病人费用销帐.费用id%Type,
    申请类别_In   病人费用销帐.申请类别%Type,
    收费细目id_In 病人费用销帐.收费细目id%Type,
    申请部门id_In 病人费用销帐.申请部门id%Type,
    审核部门id_In 病人费用销帐.审核部门id%Type,
    数量_In       病人费用销帐.数量%Type,
    申请人_In     病人费用销帐.申请人%Type,
    申请时间_In   病人费用销帐.申请时间%Type,
    状态_In       病人费用销帐.状态%Type,
    销帐原因_In   病人费用销帐.销帐原因%Type
  ) Is
  Begin
    --全部都执行了，肯定销帐数量为已执行的
    Insert Into 病人费用销帐
      (费用id, 申请类别, 收费细目id, 审核部门id, 申请部门id, 数量, 申请人, 申请时间, 状态, 销帐原因)
    Values
      (费用id_In, 申请类别_In, 收费细目id_In, 审核部门id_In, 申请部门id_In, 数量_In, 申请人_In, 申请时间_In, 状态_In, 销帐原因_In);
  End;
Begin
  If 目标病区id_In Is Null Then
    Return;
  End If;

  Begin
    Select ID
    Into n_变动id
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 15 And 终止时间 Is Null;
  Exception
    When Others Then
      v_Err_Msg := '未找到病人的原始变动记录，禁止操作!';
      Raise Err_Item;
  End;

  If Nvl(操作_In, 0) = 0 Then
    n_原变动id   := 变动id_In;
    n_目标变动id := n_变动id;
    n_记录状态   := 1;
  Else
    n_原变动id   := n_变动id;
    n_目标变动id := 变动id_In;
    n_记录状态   := 2;
  End If;

  Select Max(责任护士), Count(1) Into v_责任护士, n_Count From 病人变动记录 Where ID = n_原变动id;
  If Nvl(n_Count, 0) = 0 Then
    v_Err_Msg := '未找到病人的原始变动记录，禁止操作！';
    Raise Err_Item;
  End If;

  Select Max(Decode(ID, 原病区id_In, 名称, Null)), Max(Decode(ID, 目标病区id_In, 名称, Null))
  Into v_原病区名称, v_目标病区名称
  From 部门表
  Where ID In (原病区id_In, 目标病区id_In);

  d_登记时间 := 变动时间_In;
  If d_登记时间 Is Null Then
    d_登记时间 := Sysdate;
  End If;

  n_病人审核方式   := Nvl(zl_GetSysParameter(185), 0);
  n_未入科禁止记账 := Nvl(zl_GetSysParameter(215), 0);
  --金额小数位数
  n_Dec := Zl_To_Number(Nvl(zl_GetSysParameter(9), '2'));

  n_审核标志 := 0;
  n_住院状态 := 0;
  n_已检查   := 0;

  If n_病人审核方式 = 1 Or n_未入科禁止记账 = 1 Then
    Select Nvl(审核标志, 0), Nvl(状态, 0)
    Into n_审核标志, n_住院状态
    From 病案主页
    Where 病人id = 病人id_In And 主页id = 主页id_In;
  End If;

  n_Max序号 := 0;
  v_No      := '-~';
  For c_准退 In (Select c.医嘱id, c.发送号, b.No, c.收费细目id, Nvl(Sum(c.数量), 0) As 准退数, Nvl(Max(m.跟踪在用), 0) As 跟踪在用, n.序号 As 费用序号
               From 病人医嘱记录 A, 病人医嘱发送 B, 医嘱执行计价 C, 材料特性 M, 住院费用记录 N
               Where a.Id = b.医嘱id And b.医嘱id = c.医嘱id And b.发送号 = c.发送号 And c.收费细目id = m.材料id(+) And b.记录性质 = 2 And
                     (c.执行状态 = 0 Or Nvl(m.跟踪在用, 0) = 1) And a.病人id = 病人id_In And a.主页id = 主页id_In And c.费用id = n.Id(+) And
                     Nvl(n.记录状态, 0) <> 2
               Group By c.医嘱id, c.发送号, b.No, c.收费细目id, n.序号
               Having Nvl(Sum(c.数量), 0) <> 0
               Order By NO) Loop
    If v_No <> c_准退.No Then
      v_No := c_准退.No;
      Select Nvl(Max(序号), 0)
      Into n_Max序号
      From 住院费用记录
      Where NO = v_No And 记录性质 = 2 And 记录状态 In (0, 1, 3);
    End If;
  
    --填写 医嘱执行计价.费用ID
    Select Count(1)
    Into n_Count
    From 医嘱执行计价
    Where 医嘱id = c_准退.医嘱id And 发送号 = c_准退.发送号 And 费用id Is Null;
    If n_Count <> 0 Then
      For c_费用 In (Select ID, 收费细目id
                   From 住院费用记录
                   Where 记录性质 = 2 And NO = v_No And 医嘱序号 = c_准退.医嘱id And 价格父号 Is Null) Loop
        Update 医嘱执行计价
        Set 费用id = c_费用.Id
        Where 医嘱id = c_准退.医嘱id And 发送号 = c_准退.发送号 And 收费细目id = c_费用.收费细目id And 费用id Is Null;
      End Loop;
    End If;
  
    For c_费用 In (Select 序号, Max(记录状态) As 记录状态, Max(收费类别) As 收费类别, Max(收费细目id) As 收费细目id, Max(执行状态) As 执行状态,
                        Max(费用id) As 费用id, Sum(数量) As 数量, Max(标准单价) As 标准单价, Sum(应收金额) As 应收金额, Sum(实收金额) As 实收金额
                 From (Select Nvl(价格父号, 序号) As 序号, 记录状态 As 记录状态, Max(收费类别) As 收费类别, Max(收费细目id) As 收费细目id,
                               Max(Decode(记录状态, 2, -1, 执行状态)) As 执行状态,
                               Max(Decode(记录状态, 2, 0, Decode(价格父号, Null, ID, 0))) As 费用id,
                               Nvl(Sum(Nvl(付数, 1) * Nvl(数次, 0)), 0) As 数量, Sum(标准单价) As 标准单价, Sum(应收金额) As 应收金额,
                               Sum(实收金额) As 实收金额
                        From 住院费用记录
                        Where NO = v_No And 记录性质 = 2 And 收费细目id = c_准退.收费细目id And 医嘱序号 = c_准退.医嘱id And
                              (c_准退.费用序号 Is Null Or Nvl(价格父号, 序号) = c_准退.费用序号) And 执行部门id = 原病区id_In
                        Group By Nvl(价格父号, 序号), 记录状态)
                 Group By 序号
                 Having Nvl(Sum(数量), 0) <> 0) Loop
    
      --只有存在费用变动时才需要检查
      If Nvl(n_已检查, 0) = 0 Then
        --只检查一次
        If n_未入科禁止记账 = 1 And n_住院状态 = 1 Then
          v_Err_Msg := '病人未入科，禁止对病人相关费用的操作！';
          Raise Err_Item;
        End If;
        If n_病人审核方式 = 1 Then
          If Nvl(n_审核标志, 0) = 1 Then
            v_Err_Msg := '该病人目前正在审核费用，不能进行费用相关调整！';
            Raise Err_Item;
          End If;
          If Nvl(n_审核标志, 0) = 2 Then
            v_Err_Msg := '该病人目前已经完成了费用审核，不能进行费用相关调整！';
            Raise Err_Item;
          End If;
        End If;
        n_已检查 := 1;
      End If;
    
      --1.卫生材料在病区执行的，直接发出销帐申请
      If c_准退.跟踪在用 = 1 Then
        If c_费用.记录状态 = 0 Then
          v_Err_Msg := '单据 ' || c_准退.No || ' 还未进行审核，禁止转病区操作！';
          Raise Err_Item;
        End If;
        If v_责任护士 Is Null Then
          v_Err_Msg := '原病区的责任护士不存在，不能进行卫材销帐申请！';
          Raise Err_Item;
        End If;
      
        Select Sum(b.实际数量)
        Into n_未发料数量
        From 药品收发记录 B
        Where 费用id = c_费用.费用id And Mod(b.记录状态, 3) = 1 And b.单据 In (24, 25, 26) And b.审核人 Is Null;
      
        Select Sum(Decode(申请类别, 0, 1, 0) * 数量), Sum(Decode(申请类别, 0, 0, 1) * 数量)
        Into n_申请未发数量, n_申请已发数量
        From 病人费用销帐
        Where 费用id = c_费用.费用id And Nvl(状态, 0) = 0;
      
        n_申请销账数量 := 0;
        If Nvl(n_未发料数量, 0) >= Nvl(c_准退.准退数, 0) Then
          --都未执行
          n_申请未发数量 := Nvl(c_准退.准退数, 0) - Nvl(n_申请未发数量, 0);
          If n_申请未发数量 > 0 Then
            n_申请销账数量 := n_申请销账数量 + n_申请未发数量;
            销帐申请_Insert(c_费用.费用id, 0, c_准退.收费细目id, 原病区id_In, 原病区id_In, n_申请未发数量, v_责任护士, d_登记时间, 0,
                        '从' || v_原病区名称 || '转到' || v_目标病区名称);
          End If;
        Elsif Nvl(n_未发料数量, 0) = 0 Then
          --全部都执行了，肯定销帐数量为已执行的
          n_申请已发数量 := Nvl(c_准退.准退数, 0) - Nvl(n_申请已发数量, 0);
          If n_申请已发数量 > 0 Then
            n_申请销账数量 := n_申请销账数量 + n_申请已发数量;
            销帐申请_Insert(c_费用.费用id, 1, c_准退.收费细目id, 原病区id_In, 原病区id_In, n_申请已发数量, v_责任护士, d_登记时间, 0,
                        '从' || v_原病区名称 || '转到' || v_目标病区名称);
          End If;
        Else
          --可能有部分对执行的进行销帐，一部分对未执行的销帐
          n_申请未发数量 := Nvl(n_未发料数量, 0) - Nvl(n_申请未发数量, 0);
          If n_申请未发数量 > 0 Then
            n_申请销账数量 := n_申请销账数量 + n_申请未发数量;
            销帐申请_Insert(c_费用.费用id, 0, c_准退.收费细目id, 原病区id_In, 原病区id_In, n_申请未发数量, v_责任护士, d_登记时间, 0,
                        '从' || v_原病区名称 || '转到' || v_目标病区名称);
          End If;
          --已执行部分
          n_申请已发数量 := Nvl(c_费用.数量, 0) - Nvl(n_未发料数量, 0) - Nvl(n_申请已发数量, 0);
          If n_申请已发数量 > 0 Then
            n_申请销账数量 := n_申请销账数量 + n_申请已发数量;
            销帐申请_Insert(c_费用.费用id, 1, c_准退.收费细目id, 原病区id_In, 原病区id_In, n_申请已发数量, v_责任护士, d_登记时间, 0,
                        '从' || v_原病区名称 || '转到' || v_目标病区名称);
          End If;
        End If;
      
        --增加变动记录
        If Nvl(n_申请销账数量, 0) > 0 Then
          n_应收金额 := Round(n_申请销账数量 * Nvl(c_费用.标准单价, 0), n_Dec);
          n_实收金额 := 0;
          If Nvl(c_费用.应收金额, 0) <> 0 Then
            n_实收金额 := Round(Nvl(n_应收金额, 0) * Nvl(c_费用.实收金额, 0) / c_费用.应收金额, n_Dec);
          End If;
          Insert Into 费用变动记录
            (ID, 记录状态, 病人id, 主页id, 变动时间, 原变动id, 目标变动id, 原病区id, 目标病区id, 费用id, NO, 收费类别, 收费细目id, 医嘱序号, 数量, 单价, 应收金额, 实收金额,
             状态, 摘要, 操作员编号, 操作员姓名)
          Values
            (费用变动记录_Id.Nextval, n_记录状态, 病人id_In, 主页id_In, d_登记时间, n_原变动id, n_目标变动id, 原病区id_In, 目标病区id_In, c_费用.费用id,
             c_准退.No, c_费用.收费类别, c_准退.收费细目id, c_准退.医嘱id, n_申请销账数量, c_费用.标准单价, n_应收金额, n_实收金额, 2,
             Decode(操作_In, 0, '病区变动', '病区变动撤销') || '产生的销帐申请', 操作员编号_In, 操作员姓名_In);
        End If;
      End If;
    
      --2.其他收费项目(药品未包含)
      If Nvl(c_准退.跟踪在用, 0) = 0 And Instr(',5,6,7,', ',' || c_费用.收费类别 || ',') = 0 Then
      
        If Nvl(c_费用.数量, 0) < Nvl(c_准退.准退数, 0) Then
          Select 名称 Into v_Err_Msg From 收费项目目录 Where ID = c_准退.收费细目id;
          v_Err_Msg := '单据 ' || c_准退.No || ' 的收费项目 ' || v_Err_Msg || ' 在原病区中的准退数不足，禁止操作！';
          Raise Err_Item;
        End If;
      
        --处理规则:
        --1.对原始记录进行销帐
        --2.新增目标病区数据
        --3.如果是划价单，直接更改原记录病区id和执行部门
        If Nvl(c_费用.记录状态, 0) = 0 Then
          --直接修改(包含病人病区及目标病区)
          Update 住院费用记录
          Set 病人病区id = 目标病区id_In, 执行部门id = 目标病区id_In
          Where NO = c_准退.No And 记录性质 = 2 And 记录状态 = 0 And Nvl(价格父号, 序号) = c_费用.序号;
        
          Insert Into 费用变动记录
            (ID, 记录状态, 病人id, 主页id, 变动时间, 原变动id, 目标变动id, 原病区id, 目标病区id, 费用id, NO, 收费类别, 收费细目id, 医嘱序号, 数量, 单价, 应收金额, 实收金额,
             状态, 摘要, 操作员编号, 操作员姓名)
          Values
            (费用变动记录_Id.Nextval, n_记录状态, 病人id_In, 主页id_In, d_登记时间, n_原变动id, n_目标变动id, 原病区id_In, 目标病区id_In, c_费用.费用id,
             c_准退.No, c_费用.收费类别, c_准退.收费细目id, c_准退.医嘱id, c_费用.数量, c_费用.标准单价, c_费用.应收金额, c_费用.实收金额, 0,
             Decode(操作_In, 0, '病区变动', '病区变动撤销') || '修改记帐划价单', 操作员编号_In, 操作员姓名_In);
        Else
          --直接销帐处理
          --序号：格式如"1,3,5,7,8",或"1:2:33456,3:2,5:2,7:2,8:2",冒号前面的数字表示行号,中间的数字表示退的数量,后面的数字表示配药记录的ID,目前仅在销帐审核时才传入
          --1.先产生销帐记录
          Zl_住院记帐记录_Delete(c_准退.No, c_费用.序号 || ':' || Nvl(c_准退.准退数, 0), 操作员编号_In, 操作员姓名_In, 2, 2, 0, d_登记时间);
          --2.目标病区转入记录
          For c_明细 In (Select 病人费用记录_Id.Nextval As 费用id, NO, 记录性质, 1 As 记录状态, n_Max序号 + Rownum As 序号, 从属父号,
                              价格父号 + (n_Max序号 + Rownum - 序号) As 价格父号, 主页id, 病人id, 医嘱序号, 门诊标志, 多病人单, 婴儿费, 姓名, 性别, 年龄, 标识号,
                              床号, 费别, 目标病区id_In As 病人病区id, 病人科室id, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, -1 * 数次 As 数次, 加班标志,
                              附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, -1 * 应收金额 As 应收金额, -1 * 实收金额 As 实收金额, 开单部门id, 开单人,
                              目标病区id_In As 执行部门id, 划价人, 执行人, c_费用.执行状态 As 执行状态, 执行时间, 操作员编号_In As 操作员编号,
                              操作员姓名_In As 操作员姓名, 发生时间, d_登记时间 As 登记时间, 保险项目否, 保险大类id, -1 * 统筹金额 As 统筹金额, 保险编码, 记帐单id, 摘要,
                              费用类型, 是否急诊, 结论, 医疗小组id
                       From 住院费用记录
                       Where NO = c_准退.No And Nvl(价格父号, 序号) = c_费用.序号 And 记录状态 = 2 And 登记时间 = d_登记时间) Loop
            Insert Into 住院费用记录
              (ID, NO, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 主页id, 病人id, 医嘱序号, 门诊标志, 多病人单, 婴儿费, 姓名, 性别, 年龄, 标识号, 床号, 费别, 病人病区id,
               病人科室id, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人,
               执行部门id, 划价人, 执行人, 执行状态, 执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 保险项目否, 保险大类id, 统筹金额, 保险编码, 记帐单id, 摘要, 费用类型, 是否急诊,
               结论, 医疗小组id)
            Values
              (c_明细.费用id, c_明细.No, c_明细.记录性质, c_明细.记录状态, c_明细.序号, c_明细.从属父号, c_明细.价格父号, c_明细.主页id, c_明细.病人id, c_明细.医嘱序号,
               c_明细.门诊标志, c_明细.多病人单, c_明细.婴儿费, c_明细.姓名, c_明细.性别, c_明细.年龄, c_明细.标识号, c_明细.床号, c_明细.费别, c_明细.病人病区id,
               c_明细.病人科室id, c_明细.收费类别, c_明细.收费细目id, c_明细.计算单位, c_明细.付数, c_明细.发药窗口, c_明细.数次, c_明细.加班标志, c_明细.附加标志,
               c_明细.收入项目id, c_明细.收据费目, c_明细.记帐费用, c_明细.标准单价, c_明细.应收金额, c_明细.实收金额, c_明细.开单部门id, c_明细.开单人, c_明细.执行部门id,
               c_明细.划价人, c_明细.执行人, c_明细.执行状态, c_明细.执行时间, c_明细.操作员编号, c_明细.操作员姓名, c_明细.发生时间, c_明细.登记时间, c_明细.保险项目否,
               c_明细.保险大类id, c_明细.统筹金额, c_明细.保险编码, c_明细.记帐单id, c_明细.摘要, c_明细.费用类型, c_明细.是否急诊, c_明细.结论, c_明细.医疗小组id);
          
            Update 费用变动记录
            Set 单价 = Nvl(单价, 0) + Nvl(c_明细.标准单价, 0), 应收金额 = Nvl(应收金额, 0) + Nvl(c_明细.应收金额, 0),
                实收金额 = Nvl(实收金额, 0) + Nvl(c_明细.实收金额, 0)
            Where 费用id = c_费用.费用id And 变动时间 = d_登记时间 And 目标变动id = n_目标变动id And 收费细目id = c_准退.收费细目id And
                  病人id + 0 = c_明细.病人id;
            If Sql%NotFound Then
              Insert Into 费用变动记录
                (ID, 记录状态, 病人id, 主页id, 变动时间, 原变动id, 目标变动id, 原病区id, 目标病区id, 费用id, NO, 收费类别, 收费细目id, 医嘱序号, 数量, 单价, 应收金额,
                 实收金额, 状态, 摘要, 操作员编号, 操作员姓名)
              Values
                (费用变动记录_Id.Nextval, n_记录状态, 病人id_In, 主页id_In, d_登记时间, n_原变动id, n_目标变动id, 原病区id_In, 目标病区id_In, c_费用.费用id,
                 c_准退.No, c_费用.收费类别, c_准退.收费细目id, c_准退.医嘱id, Round(c_明细.数次 * Nvl(c_明细.付数, 1), 5), c_明细.标准单价, c_明细.应收金额,
                 c_明细.实收金额, 1, Decode(操作_In, 0, '病区变动', '病区变动撤销') || '修改记帐单', 操作员编号_In, 操作员姓名_In);
            End If;
          
            Update 病人审批项目
            Set 已用数量 = Nvl(已用数量, 0) + Round(c_明细.数次 * Nvl(c_明细.付数, 1), 5)
            Where 病人id = 病人id_In And 主页id = 主页id_In And 项目id = c_明细.收费细目id And Nvl(使用限量, 0) <> 0;
          
            --病人余额
            Update 病人余额
            Set 费用余额 = Nvl(费用余额, 0) + c_明细.实收金额
            Where 病人id = c_明细.病人id And 类型 = 2 And 性质 = 1;
            If Sql%RowCount = 0 Then
              Insert Into 病人余额
                (病人id, 类型, 性质, 费用余额, 预交余额)
              Values
                (c_明细.病人id, 2, 1, c_明细.实收金额, 0);
            End If;
            --病人未结费用
            Update 病人未结费用
            Set 金额 = Nvl(金额, 0) + c_明细.实收金额
            Where 病人id = c_明细.病人id And Nvl(主页id, 0) = Nvl(c_明细.主页id, 0) And Nvl(病人病区id, 0) = Nvl(c_明细.病人病区id, 0) And
                  Nvl(病人科室id, 0) = Nvl(c_明细.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(c_明细.开单部门id, 0) And
                  Nvl(执行部门id, 0) = Nvl(c_明细.执行部门id, 0) And 收入项目id + 0 = c_明细.收入项目id And 来源途径 + 0 = 2;
            If Sql%RowCount = 0 Then
              Insert Into 病人未结费用
                (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
              Values
                (c_明细.病人id, c_明细.主页id, c_明细.病人病区id, c_明细.病人科室id, c_明细.开单部门id, c_明细.执行部门id, c_明细.收入项目id, 2, c_明细.实收金额);
            End If;
          
            --更新医嘱执行计价的费用ID
            If Nvl(c_明细.价格父号, 0) = 0 Then
              Update 医嘱执行计价
              Set 费用id = c_明细.费用id
              Where 医嘱id = c_准退.医嘱id And 发送号 = c_准退.发送号 And 费用id = c_费用.费用id And 执行状态 = 0;
            End If;
          
            n_Max序号 := c_明细.序号;
          End Loop;
        End If;
      End If;
    End Loop;
  End Loop;

  If Nvl(操作_In, 0) = 1 Then
    --撤消操作,需要删除卫生材料部分中未审核部分
    For c_销账 In (Select a.费用id, a.病人id, a.主页id, a.No, a.收费类别, a.收费细目id, a.医嘱序号, a.数量, a.单价, a.应收金额, a.实收金额
                 From 费用变动记录 A
                 Where a.原变动id = n_目标变动id And a.目标变动id = n_原变动id And a.状态 = 2) Loop
    
      Select Sum(数量) Into n_申请取消数量 From 病人费用销帐 Where 费用id = c_销账.费用id And 状态 In (0, 2);
    
      If Nvl(n_申请取消数量, 0) > 0 Then
        n_应收金额 := Round(n_申请取消数量 * Nvl(c_销账.单价, 0), n_Dec);
        n_实收金额 := 0;
        If Nvl(c_销账.应收金额, 0) <> 0 Then
          n_实收金额 := Round(Nvl(n_应收金额, 0) * Nvl(c_销账.实收金额, 0) / c_销账.应收金额, n_Dec);
        End If;
      
        Insert Into 费用变动记录
          (ID, 记录状态, 病人id, 主页id, 变动时间, 原变动id, 目标变动id, 原病区id, 目标病区id, 费用id, NO, 收费类别, 收费细目id, 医嘱序号, 数量, 单价, 应收金额, 实收金额,
           状态, 摘要, 操作员编号, 操作员姓名)
        Values
          (费用变动记录_Id.Nextval, n_记录状态, c_销账.病人id, c_销账.主页id, d_登记时间, n_原变动id, n_目标变动id, 原病区id_In, 目标病区id_In, c_销账.费用id,
           c_销账.No, c_销账.收费类别, c_销账.收费细目id, c_销账.医嘱序号, n_申请取消数量, c_销账.单价, n_应收金额, n_实收金额, 3, '病区撤销后删除销帐申请', 操作员编号_In,
           操作员姓名_In);
      End If;
    
      Delete 病人费用销帐 Where 费用id = c_销账.费用id And 状态 In (0, 2);
    End Loop;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Turntoward_Fee;
/

--104662:蒋廷中,2017-06-30,增加医生授权管理的权限模块
CREATE OR REPLACE Procedure Zl_医生权限_Update
(
  Id_In       In 人员表.Id%Type,
  类型_In     In Number, --=1 处方权,=2 门诊抗菌药物权限,=3 住院抗菌药物权限,=4 手术等级权限,=5 门诊特殊医嘱权限,=6 住院特殊医嘱权限,=7 医生等级
  修改内容_In In Varchar2,
  场合_In     In Number := Null, --=0 全部, =1 住院,=2 门诊
  操作人员_In 人员抗菌药物权限.操作人员%Type := Null,
  操作时间_In 人员抗菌药物权限.操作时间%Type := Null
  
) Is
  v_操作时间 人员抗菌药物权限.操作时间%Type := Null;
  v_最新操作时间  人员抗菌药物权限.操作时间%Type := Null;
Begin

  --类型_In=1 设置处方权
  If 类型_In = 1 Then
    Update 人员表 Set 处方权标志 = 修改内容_In Where ID = Id_In;
  End If;

  --类型_In=2 设置门诊抗菌药物权限
  If 类型_In = 2 Then
    v_最新操作时间:=操作时间_In;
    Select Max(操作时间)
    Into v_操作时间
    From 人员抗菌药物权限
    Where 人员id = Id_In And 记录状态 = 1 And 场合 = 场合_In;
    If v_操作时间 Is Not Null Then
      Update 人员抗菌药物权限 Set 记录状态 = 0 Where 人员id = Id_In And 操作时间 = v_操作时间 And 场合 = 场合_In;
    End If;
    --插入新记录 
    If v_操作时间 >= 操作时间_In Then
      while v_最新操作时间 <= v_操作时间 loop 
         v_最新操作时间:=v_最新操作时间 + 1 / 24 / 60 / 60;
      end loop;  
      Insert Into 人员抗菌药物权限
        (人员id, 级别, 记录状态, 操作人员, 操作时间, 场合)
      Values
        (To_Number(Id_In), 修改内容_In, 1, 操作人员_In, v_最新操作时间, 场合_In);
    Else
      Insert Into 人员抗菌药物权限
        (人员id, 级别, 记录状态, 操作人员, 操作时间, 场合)
      Values
        (To_Number(Id_In), 修改内容_In, 1, 操作人员_In, 操作时间_In, 场合_In);
    End If;
  End If;

  --类型_In=3 设置住院抗菌药物权限
  If 类型_In = 3 Then
    v_最新操作时间:=操作时间_In;
    Select Max(操作时间)
    Into v_操作时间
    From 人员抗菌药物权限
    Where 人员id = Id_In And 记录状态 = 1 And 场合 = 场合_In;
    If v_操作时间 Is Not Null Then
      Update 人员抗菌药物权限 Set 记录状态 = 0 Where 人员id = Id_In And 操作时间 = v_操作时间 And 场合 = 场合_In;
    End If;
    --插入新记录 
    If v_操作时间 >= 操作时间_In Then
      while v_最新操作时间 <= v_操作时间 loop 
         v_最新操作时间:=v_最新操作时间 + 1 / 24 / 60 / 60;
      end loop;  
      Insert Into 人员抗菌药物权限
        (人员id, 级别, 记录状态, 操作人员, 操作时间, 场合)
      Values
        (To_Number(Id_In), 修改内容_In, 1, 操作人员_In, v_最新操作时间, 场合_In);
    Else
      Insert Into 人员抗菌药物权限
        (人员id, 级别, 记录状态, 操作人员, 操作时间, 场合)
      Values
        (To_Number(Id_In), 修改内容_In, 1, 操作人员_In, 操作时间_In, 场合_In);
    End If;
  End If;

  --类型_In=4 设置手术等级权限
  If 类型_In = 4 Then
    Update 人员表 Set 手术等级 = 修改内容_In Where ID = Id_In;
  End If;

  --类型_In=5 设置门诊特殊医嘱权限
  If 类型_In = 5 Then
    Update 人员表 Set 门诊特殊医嘱权限 = 修改内容_In Where ID = Id_In;
  End If;

  --类型_In=6 设置住院特殊医嘱权限
  If 类型_In = 6 Then
    Update 人员表 Set 住院特殊医嘱权限 = 修改内容_In Where ID = Id_In;
  End If;

  --类型_In=7 设置医生等级
  If 类型_In = 7 Then
    Update 人员表 Set 专业技术职务 = 修改内容_In Where ID = Id_In;
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_医生权限_Update;
/

--111317:黄捷,2017-07-10,检查号改成字符型，再使用数值检查号
--103994:黄捷,2017-06-30,检查号改成字符型
Create Or Replace Function Zl_检查号_Nextno
(
  科室id_In   影像流程参数.科室id%Type,
  影像类别_In 影像检查记录.影像类别%Type
) Return Varchar2 Is

  Pragma Autonomous_Transaction;
  Cursor c_AppnoRule(执行科室id_In 影像流程参数.科室id%Type) Is
    Select 参数值, 参数名
    From 影像流程参数
    Where 科室id = 执行科室id_In
    And 参数名 Like '检查号%';

  v_Temp         影像流程参数.参数值%Type;
  n_IncreaseMode Number;
  v_PreText      Varchar2(20);
  v_Delimiter1   Varchar2(1);
  v_Delimiter2   Varchar2(1);
  v_Year         Varchar2(4);
  v_Month        Varchar2(2);
  v_Day          Varchar2(2);
  n_StartNum     Number;
  n_FixedLen     Number;
  v_FixedStr     Varchar2(18);
  n_Checkmaxno   Number;
  v_序号         Number;
  v_Maxno        Varchar2(64);
  n_Maxno        Number;
  n_CurMaxno     Number;
  n_Count        Number;

  v_AppnoPre Varchar2(64);
  v_Error    Varchar(255);

  Err_Custom Exception;
Begin
  v_序号 := 123;

  Select Nvl(Max(参数值), 0)
  Into n_Checkmaxno
  From 影像流程参数
  Where 科室id = 科室id_In
  And 参数名 = '提取实际最大号码';

  For r_AppnoRule In c_AppnoRule(科室id_In) Loop
    --提取号码规则
    If r_AppnoRule.参数名 = '检查号生成方式' Then
      n_IncreaseMode := To_Number(r_AppnoRule.参数值);
    Elsif r_AppnoRule.参数名 = '检查号前缀' Then
      v_Temp := r_AppnoRule.参数值;
      If v_Temp = '1' Then
        v_PreText := 影像类别_In;
      Else
        v_PreText := v_Temp;
      End If;
    Elsif r_AppnoRule.参数名 = '检查号分隔符1' Then
      v_Delimiter1 := r_AppnoRule.参数值;
    Elsif r_AppnoRule.参数名 = '检查号分隔符2' Then
      v_Delimiter2 := r_AppnoRule.参数值;
    Elsif r_AppnoRule.参数名 = '检查号年' Then
      v_Temp := r_AppnoRule.参数值;
    
      If v_Temp = '1' Then
        v_Year := To_Char(Sysdate, 'yyyy');
      Elsif v_Temp = '2' Then
        v_Year := To_Char(Sysdate, 'yy');
      End If;
    Elsif r_AppnoRule.参数名 = '检查号月' Then
      If r_AppnoRule.参数值 = '1' Then
        v_Month := To_Char(Sysdate, 'mm');
      End If;
    Elsif r_AppnoRule.参数名 = '检查号日' Then
      If r_AppnoRule.参数值 = '1' Then
        v_Day := To_Char(Sysdate, 'dd');
      End If;
    Elsif r_AppnoRule.参数名 = '检查号起始数' Then
      n_StartNum := To_Number(r_AppnoRule.参数值);
    Elsif r_AppnoRule.参数名 = '检查号固定位数' Then
      n_FixedLen := To_Number(r_AppnoRule.参数值);
    End If;
  End Loop;

  --按照检查号生成方式产生新号码
  If n_IncreaseMode = 1 Then
    --按科室递增
    Select Count(*)
    Into n_Count
    From 科室号码表
    Where 项目序号 = v_序号
    And 科室id = 科室id_In;
    If Nvl(n_Count, 0) = 0 Then
      --没有记录，则自动增加科室号码表
      Insert Into 科室号码表 (项目序号, 科室id, 编号, 最大号码) Values (v_序号, 科室id_In, 'A', '1');
      Commit;
    End If;
  
    Select Nvl(最大号码, '0')
    Into v_Maxno
    From 科室号码表
    Where 项目序号 = v_序号
    And 科室id = 科室id_In
    For Update;
  
    If n_Checkmaxno = 1 Then
      Select Nvl(Max(检查号), 0) + 1
      Into n_CurMaxno
      From 影像检查记录
      Where 执行科室id = 科室id_In
      And 检查号 >= To_Number(v_Maxno);
    End If;
  
  Else
    --按影像类别递增
    Select Nvl(最大号码, '0') Into v_Maxno From 影像检查类别 Where 编码 = 影像类别_In For Update;
    If n_Checkmaxno = 1 Then
      Select Nvl(Max(检查号), 0) + 1
      Into n_CurMaxno
      From 影像检查记录
      Where 影像类别 = 影像类别_In
      And 检查号 >= To_Number(v_Maxno);
    End If;
  End If;

  --如果没有选择年，月，日，则按照旧方法递增检查号
  If v_PreText Is Null And v_Delimiter1 Is Null And v_Year Is Null And v_Month Is Null And v_day Is Null And
     v_Delimiter2 Is Null Then
  
    n_Maxno := To_Number(REGEXP_REPLACE(v_Maxno, '[^0-9]', ''));
    --提取实际最大号码,如果有实际最大号码，这个号码会比号码表中的大10
    If n_Checkmaxno = 1 Then
      If n_CurMaxno > n_Maxno Then
        n_Maxno := n_CurMaxno;
      End If;
    Else
      -- 如果不提取实际最大号码，加上10
      n_Maxno := n_Maxno + 10 + 1;
    End If;
  
    -- 回填最大号码
    If n_IncreaseMode = 1 Then
      Update 科室号码表
      Set 最大号码 = Decode(Sign(n_Maxno - 10), 1, n_Maxno - 10, 1)
      Where 项目序号 = v_序号
      And 科室id = 科室id_In;
    Else
    
      Update 影像检查类别 Set 最大号码 = Decode(Sign(n_Maxno - 10), 1, n_Maxno - 10, 1) Where 编码 = 影像类别_In;
    End If;
  
    v_Maxno := to_char(n_Maxno);
  Else
    --按年月日+000001生成检查号
    v_AppnoPre := v_PreText || v_Delimiter1 || v_Year || v_Month || v_Day || v_Delimiter2;
    If n_StartNum Is Null Then
      n_StartNum := 1;
    End If;
  
    If n_FixedLen <> 0 Then
      --按照固定位数编号
      n_Count := 0;
      While (n_count < n_FixedLen) Loop
        v_FixedStr := v_FixedStr || '0';
        n_count    := n_count + 1;
      End Loop;
    
      If v_Maxno = '0' Then
        v_Maxno := v_AppnoPre || Trim(To_Char(n_StartNum, v_FixedStr));
      Else
        If substr(v_maxno, 1, length(v_AppnoPre)) = v_AppnoPre Then
          v_Maxno := v_AppnoPre ||
                     Trim(To_Char(To_Number(substr(v_maxno, length(v_AppnoPre) + 1, n_fixedlen)) + 1, v_fixedstr));
        Else
          v_maxno := v_AppnoPre || Trim(To_Char(n_StartNum, v_FixedStr));
        End If;
      End If;
    Else
      --直接顺序编号
      If v_Maxno = '0' Then
        v_Maxno := v_AppnoPre || To_Char(n_StartNum);
      Else
        If substr(v_maxno, 1, length(v_AppnoPre)) = v_AppnoPre Then
          v_Maxno := v_AppnoPre ||
                     Trim(To_Char(To_Number(substr(v_maxno, length(v_AppnoPre) + 1, length(v_maxno) - length(v_appnopre))) + 1));
        Else
          v_Maxno := v_AppnoPre || To_Char(n_StartNum);
        End If;
      End If;
    End If;
  
    -- 回填最大号码
    If n_IncreaseMode = 1 Then
      Update 科室号码表
      Set 最大号码 = v_Maxno
      Where 项目序号 = v_序号
      And 科室id = 科室id_In;
    Else
    
      Update 影像检查类别 Set 最大号码 = v_Maxno Where 编码 = 影像类别_In;
    End If;
  End If;

  Commit;
  Return v_Maxno;
Exception
  When Err_Custom Then
    Rollback;
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Rollback;
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_检查号_Nextno;
/


--110541:余伟节,2017-06-30,身份证号唯一建档检查
Create Or Replace Procedure Zl_入院病案主页_Update
(
  登记模式_In       Number,
  病人id_In         病人信息.病人id%Type,
  住院号_In         病人信息.住院号%Type,
  医保号_In         保险帐户.医保号%Type,
  姓名_In           病人信息.姓名%Type,
  性别_In           病人信息.性别%Type,
  年龄_In           病人信息.年龄%Type,
  费别_In           病人信息.费别%Type,
  出生日期_In       病人信息.出生日期%Type,
  国籍_In           病人信息.国籍%Type,
  民族_In           病人信息.民族%Type,
  学历_In           病人信息.学历%Type,
  婚姻状况_In       病人信息.婚姻状况%Type,
  职业_In           病人信息.职业%Type,
  身份_In           病人信息.身份%Type,
  身份证号_In       病人信息.身份证号%Type,
  出生地点_In       病人信息.出生地点%Type,
  家庭地址_In       病人信息.家庭地址%Type,
  家庭地址邮编_In   病人信息.家庭地址邮编%Type,
  家庭电话_In       病人信息.家庭电话%Type,
  户口地址_In       病人信息.户口地址%Type,
  户口地址邮编_In   病人信息.户口地址邮编%Type,
  联系人姓名_In     病人信息.联系人姓名%Type,
  联系人关系_In     病人信息.联系人关系%Type,
  联系人地址_In     病人信息.联系人地址%Type,
  联系人电话_In     病人信息.联系人电话%Type,
  工作单位_In       病人信息.工作单位%Type,
  合同单位id_In     病人信息.合同单位id%Type,
  单位电话_In       病人信息.单位电话%Type,
  单位邮编_In       病人信息.单位邮编%Type,
  单位开户行_In     病人信息.单位开户行%Type,
  单位帐号_In       病人信息.单位帐号%Type,
  担保人_In         病人信息.担保人%Type,
  担保额_In         病人信息.担保额%Type,
  担保性质_In       病人信息.担保性质%Type,
  主页id_In         病案主页.主页id%Type,
  入院科室id_In     病案主页.入院科室id%Type,
  护理等级id_In     病案主页.护理等级id%Type,
  入院病况_In       病案主页.入院病况%Type,
  入院方式_In       病案主页.入院方式%Type,
  住院目的_In       病案主页.住院目的%Type,
  二级院转入_In     病案主页.二级院转入%Type,
  门诊医师_In       病案主页.门诊医师%Type,
  籍贯_In           病人信息.籍贯%Type,
  区域_In           病案主页.区域%Type,
  入院时间_In       病案主页.入院日期%Type,
  付款方式_In       病案主页.医疗付款方式%Type,
  疾病id_In         病人诊断记录.疾病id%Type,
  诊断id_In         病人诊断记录.诊断id%Type,
  门诊诊断_In       病人诊断记录.诊断描述%Type,
  中医疾病id_In     病人诊断记录.疾病id%Type,
  中医诊断id_In     病人诊断记录.诊断id%Type,
  中医诊断_In       病人诊断记录.诊断描述%Type,
  操作员编号_In     病案主页.编目员编号%Type,
  操作员姓名_In     病案主页.编目员姓名%Type,
  备注_In           病案主页.备注%Type,
  病区id_In         病案主页.入院病区id%Type,
  再入院_In         病案主页.再入院%Type,
  入院属性_In       病案主页.入院属性%Type := Null,
  其他证件_In       病人信息.其他证件%Type := Null,
  病人类型_In       病案主页.病人类型%Type := Null,
  联系人身份证号_In 病人信息.联系人身份证号%Type := Null,
  手机号_In         病人信息.手机号%Type := Null
) As
  -----------------------------------------------------------
  --说明：本函数仅用于入院未入科登记病人信息的修改
  --      登记模式_IN=0-正常登记,1-预约登记
  --      病区ID_IN=只有当病区管理病床模式下,入院时入科时,才会有值
  --      住院号_IN = 病人性质为 门诊留观时 住院号_In 为病人门诊号
  -----------------------------------------------------------
  v_病人性质 病案主页.病人性质%Type;
  v_Count    Number;
  v_Date     Date;
  v_Error    Varchar2(255);
  Err_Custom Exception;
Begin
  --判断病人是否锁定
  Select Count(病人id) Into v_Count From 病人信息 Where 病人id = 病人id_In;
  If v_Count <> 0 Then
    Zl_病人信息_锁定检查(病人id_In);
  End If;
  --判断病人是否未入院
  Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In And 状态 = 1;
  If v_Count = 0 Then
    v_Error := '病人当前不处于等待入科状态，操作不能继续！' || Chr(13) || Chr(10) || '可能该病人已经被其它操作员取消登记或分配床位。';
    Raise Err_Custom;
  End If;

  Select Sysdate Into v_Date From Dual;
  Select 病人性质 Into v_病人性质 From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
  --身份证号不等于空,根据系统参数判读是否唯一建档病人
  If 身份证号_In Is Not Null Then
    v_Count := Nvl(zl_GetSysParameter(279), 0);
    If v_Count = 1 Then
      Select Count(1) Into v_Count From 病人信息 Where 身份证号 = 身份证号_In And 病人id <> Nvl(病人id_In, 0);
      If v_Count <> 0 Then
        v_Error := '已经存在身份证号为' || 身份证号_In || '的病人,不能再录入相同的身份证号!';
        Raise Err_Custom;
      End If;
    End If;
  End If;
  --病人基本信息
  --非第一次入院时,门诊费别保持不变,除非是门诊留观病人

  Update 病人信息
  Set 住院号 = Decode(v_病人性质, 1, 住院号, 2, 住院号, 住院号_In), 门诊号 = Decode(v_病人性质, 1, 住院号_In, 门诊号), 姓名 = 姓名_In, 性别 = 性别_In,
      年龄 = 年龄_In, 医疗付款方式 = 付款方式_In, 费别 = Decode(v_病人性质, 1, 费别_In, 费别), 出生日期 = 出生日期_In, 国籍 = 国籍_In, 民族 = 民族_In,
      籍贯 = 籍贯_In, 区域 = 区域_In, 学历 = 学历_In, 婚姻状况 = 婚姻状况_In, 职业 = 职业_In, 身份 = 身份_In, 身份证号 = 身份证号_In, 出生地点 = 出生地点_In,
      家庭地址 = 家庭地址_In, 家庭地址邮编 = 家庭地址邮编_In, 家庭电话 = 家庭电话_In, 户口地址 = 户口地址_In, 户口地址邮编 = 户口地址邮编_In, 联系人姓名 = 联系人姓名_In,
      联系人关系 = 联系人关系_In, 联系人地址 = 联系人地址_In, 联系人电话 = 联系人电话_In, 联系人身份证号 = 联系人身份证号_In, 工作单位 = 工作单位_In,
      合同单位id = Decode(合同单位id_In, 0, Null, 合同单位id_In), 单位电话 = 单位电话_In, 单位邮编 = 单位邮编_In, 单位开户行 = 单位开户行_In, 单位帐号 = 单位帐号_In,
      担保人 = 担保人_In, 担保额 = Decode(担保额_In, 0, Null, 担保额_In), 担保性质 = 担保性质_In, 其他证件 = 其他证件_In, 手机号 = 手机号_In
  Where 病人id = 病人id_In;

  If 登记模式_In = 0 Then
    --病案信息
    Update 病人信息
    Set 当前病区id = 病区id_In, 当前科室id = 入院科室id_In, 入院时间 = 入院时间_In, 出院时间 = Null
    Where 病人id = 病人id_In;
  End If;

  Begin
    --在院病人  
    If 登记模式_In = 0 Then
      Update 在院病人 Set 病区id = Nvl(病区id_In, 0), 科室id = 入院科室id_In Where 病人id = 病人id_In;
      If Sql%RowCount = 0 Then
        Insert Into 在院病人
          (病人id, 科室id, 病区id, 主页id)
        Values
          (病人id_In, 入院科室id_In, Nvl(病区id_In, 0), Nvl(主页id_In, 0));
      End If;
    End If;
  Exception
    When Others Then
      Null;
  End;

  --修改病案主页
  Update 病案主页
  Set 住院号 = Decode(v_病人性质, 1, Null, 2, Null, 住院号_In), 留观号 = Decode(v_病人性质, 2, 住院号_In, Null), 费别 = 费别_In,
      入院病区id = 病区id_In, 入院科室id = 入院科室id_In, 入院日期 = 入院时间_In, 入院病况 = 入院病况_In, 入院方式 = 入院方式_In, 入院属性 = 入院属性_In,
      二级院转入 = 二级院转入_In, 住院目的 = 住院目的_In, 当前病况 = 入院病况_In, 当前病区id = 病区id_In, 护理等级id = Decode(护理等级id_In, 0, Null, 护理等级id_In),
      出院科室id = 入院科室id_In, 门诊医师 = 门诊医师_In, 编目员编号 = 操作员编号_In, 编目员姓名 = 操作员姓名_In, 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In,
      婚姻状况 = 婚姻状况_In, 职业 = 职业_In, 国籍 = 国籍_In, 学历 = 学历_In, 单位电话 = 单位电话_In, 单位邮编 = 单位邮编_In, 单位地址 = 工作单位_In, 区域 = 区域_In,
      家庭地址 = 家庭地址_In, 家庭电话 = 家庭电话_In, 家庭地址邮编 = 家庭地址邮编_In, 户口地址 = 户口地址_In, 户口地址邮编 = 户口地址邮编_In, 联系人姓名 = 联系人姓名_In,
      联系人关系 = 联系人关系_In, 联系人地址 = 联系人地址_In, 联系人电话 = 联系人电话_In, 联系人身份证号 = 联系人身份证号_In, 医疗付款方式 = 付款方式_In, 备注 = 备注_In,
      登记人 = 操作员姓名_In, 登记时间 = v_Date, 再入院 = 再入院_In, 病人类型 = 病人类型_In
  Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0);

  If 登记模式_In = 0 Then
    --医保号
    If 医保号_In Is Not Null Then
      Update 病案主页从表 Set 信息值 = 医保号_In Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '医保号';
      If Sql%RowCount = 0 Then
        Insert Into 病案主页从表 (病人id, 主页id, 信息名, 信息值) Values (病人id_In, 主页id_In, '医保号', 医保号_In);
      End If;
    Else
      Delete From 病案主页从表 Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '医保号';
    End If;
  
    --修改病人变动记录(肯定为入院变动;单独入科的不准修改,入院同时入科的病人界面程序禁止修改)
    Update 病人变动记录
    Set 开始时间 = 入院时间_In, 病区id = 病区id_In, 科室id = 入院科室id_In, 护理等级id = Decode(护理等级id_In, 0, Null, 护理等级id_In), 病情 = 入院病况_In,
        操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And 开始原因 = 1;
  
    --同步处理病人自动计算
    Update 病人自动计算 
    Set 开始时间 = 入院时间_In, 病区id = 病区id_In, 科室id = 入院科室id_In, 护理等级id = Decode(护理等级id_In, 0, Null, 护理等级id_In), 
        操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And 开始原因 = 1;
    
    --处理门诊诊断
    If 门诊诊断_In Is Null And 疾病id_In Is Null Then
      Delete From 病人诊断记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 诊断类型 = 1 And 记录来源 = 2;
    Else
      Update 病人诊断记录
      Set 疾病id = 疾病id_In, 诊断id = 诊断id_In, 诊断描述 = 门诊诊断_In, 记录日期 = Sysdate, 记录人 = 操作员姓名_In
      Where 病人id = 病人id_In And 主页id = 主页id_In And 诊断类型 = 1 And 记录来源 = 2;
      If Sql%RowCount = 0 Then
        Insert Into 病人诊断记录
          (ID, 病人id, 主页id, 记录来源, 诊断类型, 诊断次序, 疾病id, 诊断id, 诊断描述, 记录日期, 记录人)
        Values
          (病人诊断记录_Id.Nextval, 病人id_In, 主页id_In, 2, 1, 1, 疾病id_In, 诊断id_In, 门诊诊断_In, Sysdate, 操作员姓名_In);
      End If;
    End If;
  
    --处理中医诊断
    If 中医诊断_In Is Null And 中医疾病id_In Is Null Then
      Delete From 病人诊断记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 诊断类型 = 11 And 记录来源 = 2;
    Else
      Update 病人诊断记录
      Set 疾病id = 中医疾病id_In, 诊断id = 中医诊断id_In, 诊断描述 = 中医诊断_In, 记录日期 = Sysdate, 记录人 = 操作员姓名_In
      Where 病人id = 病人id_In And 主页id = 主页id_In And 诊断类型 = 11 And 记录来源 = 2;
      If Sql%RowCount = 0 Then
        Insert Into 病人诊断记录
          (ID, 病人id, 主页id, 记录来源, 诊断类型, 诊断次序, 疾病id, 诊断id, 诊断描述, 记录日期, 记录人)
        Values
          (病人诊断记录_Id.Nextval, 病人id_In, 主页id_In, 2, 11, 1, 中医疾病id_In, 中医诊断id_In, 中医诊断_In, Sysdate, 操作员姓名_In);
      End If;
    End If;
  End If;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_入院病案主页_Update;
/

--110541:余伟节,2017-06-30,启用身份证号唯一建档检查
Create Or Replace Procedure Zl_病人信息_Update
(
  病人id_In         病人信息.病人id%Type,
  门诊号_In         病人信息.门诊号%Type,
  住院号_In         病人信息.住院号%Type,
  费别_In           病人信息.费别%Type,
  医疗付款_In       病人信息.医疗付款方式%Type,
  姓名_In           病人信息.姓名%Type,
  性别_In           病人信息.性别%Type,
  年龄_In           病人信息.年龄%Type,
  出生日期_In       病人信息.出生日期%Type,
  出生地点_In       病人信息.出生地点%Type,
  身份证号_In       病人信息.身份证号%Type,
  身份_In           病人信息.身份%Type,
  职业_In           病人信息.职业%Type,
  民族_In           病人信息.民族%Type,
  国籍_In           病人信息.国籍%Type,
  学历_In           病人信息.学历%Type,
  婚姻_In           病人信息.婚姻状况%Type,
  家庭地址_In       病人信息.家庭地址%Type,
  家庭电话_In       病人信息.家庭电话%Type,
  家庭地址邮编_In   病人信息.家庭地址邮编%Type,
  联系人姓名_In     病人信息.联系人姓名%Type,
  联系人关系_In     病人信息.联系人关系%Type,
  联系人地址_In     病人信息.联系人地址%Type,
  联系人电话_In     病人信息.联系人电话%Type,
  合同单位id_In     病人信息.合同单位id%Type,
  工作单位_In       病人信息.工作单位%Type,
  单位电话_In       病人信息.单位电话%Type,
  单位邮编_In       病人信息.单位邮编%Type,
  单位开户行_In     病人信息.单位开户行%Type,
  单位帐号_In       病人信息.单位帐号%Type,
  担保人_In         病人信息.担保人%Type,
  担保额_In         病人信息.担保额%Type,
  险类_In           病人信息.险类%Type,
  住院费别_In       Number := 0, --是否修改的是病人的住院费别
  医保号_In         保险帐户.医保号%Type := Null,
  区域_In           病人信息.区域%Type := Null,
  担保性质_In       病人信息.担保性质%Type := Null,
  操作员编号_In     病人担保记录.操作员编号%Type := Null,
  操作员姓名_In     病人担保记录.操作员姓名%Type := Null,
  其他证件_In       病人信息.其他证件%Type := Null,
  病人类型_In       病案主页.病人类型%Type := Null,
  备注_In           病案主页.备注%Type := Null,
  籍贯_In           病人信息.籍贯%Type := Null,
  户口地址_In       病人信息.户口地址%Type := Null,
  户口地址邮编_In   病人信息.户口地址邮编%Type := Null,
  联系人身份证号_In In 病人信息.联系人身份证号%Type := Null,
  模块号_In         Number := 0, --修改病人姓名、性别、年龄、出生日期的模块
  监护人_In         病人信息.监护人%Type := Null,
  手机号_In         病人信息.手机号%Type := Null
) As
  v_主页id     病案主页.主页id%Type;
  v_出院日期   病案主页.出院日期%Type;
  v_模块号     Varchar2(1000); --要修改病人姓名的模块号组合,格式为:,模块号,模块号,....
  v_手机号     病人信息.手机号%Type;
  v_手机号字段 Varchar2(500);
  n_Count      Number;
  v_Error      Varchar2(255);
  Err_Custom Exception;
Begin
  v_模块号 := ',1111,1107,1103,';
  Begin
    Select Max(主页id) Into v_主页id From 病案主页 Where 病人id = 病人id_In;
  Exception
    When Others Then
      Null;
  End;
  If 门诊号_In Is Not Null Then
    Update 门诊病案记录 Set 病案号 = 门诊号_In Where 病人id = 病人id_In;
    If Sql%RowCount = 0 Then
      Insert Into 门诊病案记录
        (病人id, 病案号, 建立日期, 病案类别, 存储状态, 存放位置)
      Values
        (病人id_In, 门诊号_In, Sysdate, '一般', '正常', Null);
    End If;
  Else
    Delete From 门诊病案记录 Where 病人id = 病人id_In;
  End If;

  If 手机号_In Is Null Then
    If 家庭电话_In Is Not Null Then
      --中国移动
      v_手机号字段 := ',139,138,137,136,135,134,159,158,157,150,151,152,147,188,187,182,183,184,178';
      --中国联通
      v_手机号字段 := v_手机号字段 || ',130,131,132,156,155,186,185,145,176';
      --中国电信
      v_手机号字段 := v_手机号字段 || ',133,153,189,180,181,177,173';
      --虚拟运营商
      v_手机号字段 := v_手机号字段 || ',170,';
      If Not Instr(v_手机号字段, ',' || Substr(家庭电话_In, 1, 3) || ',') = 0 Then
        v_手机号 := 家庭电话_In;
      End If;
    End If;
  Else
    v_手机号 := 手机号_In;
  End If;
  --身份证号不等于空,根据系统参数判读是否唯一建档病人
  If 身份证号_In Is Not Null Then
    n_Count := Nvl(zl_GetSysParameter(279), 0);
    If n_Count = 1 Then
      Select Count(1) Into n_Count From 病人信息 Where 身份证号 = 身份证号_In And 病人id <> Nvl(病人id_In, 0);
      If n_Count <> 0 Then
        v_Error := '已经存在身份证号为' || 身份证号_In || '的病人,不能再录入相同的身份证号!';
        Raise Err_Custom;
      End If;
    End If;
  End If;
  If Instr(v_模块号, ',' || 模块号_In || ',', 1) = 0 Then
    Update 病人信息
    Set 门诊号 = 门诊号_In, 住院号 = 住院号_In, 医疗付款方式 = 医疗付款_In, 费别 = Decode(Nvl(住院费别_In, 0), 0, 费别_In, 费别), 出生地点 = 出生地点_In,
        身份证号 = 身份证号_In, 身份 = 身份_In, 职业 = 职业_In, 民族 = 民族_In, 国籍 = 国籍_In, 籍贯 = Nvl(籍贯_In, 籍贯), 区域 = 区域_In, 学历 = 学历_In,
        婚姻状况 = 婚姻_In, 家庭地址 = 家庭地址_In, 家庭电话 = 家庭电话_In, 家庭地址邮编 = 家庭地址邮编_In, 户口地址 = Nvl(户口地址_In, 户口地址),
        户口地址邮编 = Nvl(户口地址邮编_In, 户口地址邮编), 联系人姓名 = 联系人姓名_In, 联系人关系 = 联系人关系_In, 联系人地址 = 联系人地址_In, 联系人电话 = 联系人电话_In,
        合同单位id = Decode(合同单位id_In, 0, Null, 合同单位id_In), 工作单位 = 工作单位_In, 单位电话 = 单位电话_In, 单位邮编 = 单位邮编_In, 单位开户行 = 单位开户行_In,
        单位帐号 = 单位帐号_In, 担保人 = 担保人_In, 担保额 = Decode(担保额_In, 0, Null, 担保额_In), 担保性质 = 担保性质_In, 险类 = 险类_In, 医保号 = 医保号_In,
        其他证件 = 其他证件_In, 联系人身份证号 = 联系人身份证号_In, 病人类型 = 病人类型_In, 监护人 = 监护人_In, 手机号 = Nvl(v_手机号, 手机号)
    Where 病人id = 病人id_In;
  Else
    Update 病人信息
    Set 门诊号 = 门诊号_In, 住院号 = 住院号_In, 医疗付款方式 = 医疗付款_In, 费别 = Decode(Nvl(住院费别_In, 0), 0, 费别_In, 费别), 姓名 = 姓名_In, 性别 = 性别_In,
        年龄 = 年龄_In, 出生日期 = 出生日期_In, 出生地点 = 出生地点_In, 身份证号 = 身份证号_In, 身份 = 身份_In, 职业 = 职业_In, 民族 = 民族_In, 国籍 = 国籍_In,
        籍贯 = Nvl(籍贯_In, 籍贯), 区域 = 区域_In, 学历 = 学历_In, 婚姻状况 = 婚姻_In, 家庭地址 = 家庭地址_In, 家庭电话 = 家庭电话_In, 家庭地址邮编 = 家庭地址邮编_In,
        户口地址 = Nvl(户口地址_In, 户口地址), 户口地址邮编 = Nvl(户口地址邮编_In, 户口地址邮编), 联系人姓名 = 联系人姓名_In, 联系人关系 = 联系人关系_In, 联系人地址 = 联系人地址_In,
        联系人电话 = 联系人电话_In, 合同单位id = Decode(合同单位id_In, 0, Null, 合同单位id_In), 工作单位 = 工作单位_In, 单位电话 = 单位电话_In, 单位邮编 = 单位邮编_In,
        单位开户行 = 单位开户行_In, 单位帐号 = 单位帐号_In, 担保人 = 担保人_In, 担保额 = Decode(担保额_In, 0, Null, 担保额_In), 担保性质 = 担保性质_In,
        险类 = 险类_In, 医保号 = 医保号_In, 其他证件 = 其他证件_In, 联系人身份证号 = 联系人身份证号_In, 病人类型 = 病人类型_In, 监护人 = 监护人_In,
        手机号 = Nvl(v_手机号, 手机号)
    Where 病人id = 病人id_In;
  End If;

  If v_主页id Is Not Null Then
    Update 病案主页
    Set 住院号 = 住院号_In, 费别 = Decode(Nvl(住院费别_In, 0), 1, 费别_In, 费别), 医疗付款方式 = 医疗付款_In, 区域 = Decode(区域_In, Null, 区域, 区域_In),
        备注 = 备注_In
    Where 病人id = 病人id_In And 主页id = v_主页id;
  
    --对在院病人更新病案主页中的信息
    Begin
      Select 出院日期 Into v_出院日期 From 病案主页 Where 病人id = 病人id_In And 主页id = v_主页id;
    Exception
      When Others Then
        Null;
    End;
    If v_出院日期 Is Null Then
      Update 病案主页
      Set 婚姻状况 = 婚姻_In, 学历 = 学历_In, 职业 = 职业_In, 单位电话 = 单位电话_In, 单位邮编 = 单位邮编_In, 家庭地址 = 家庭地址_In, 家庭电话 = 家庭电话_In,
          家庭地址邮编 = 家庭地址邮编_In, 户口地址 = Nvl(户口地址_In, 户口地址), 户口地址邮编 = Nvl(户口地址邮编_In, 户口地址邮编), 联系人姓名 = 联系人姓名_In,
          联系人关系 = 联系人关系_In, 联系人地址 = 联系人地址_In, 联系人电话 = 联系人电话_In, 病人类型 = 病人类型_In, 备注 = 备注_In
      Where 病人id = 病人id_In And 主页id = v_主页id;
    End If;
  
    If 医保号_In Is Not Null Then
      Update 病案主页从表 Set 信息值 = 医保号_In Where 病人id = 病人id_In And 主页id = v_主页id And 信息名 = '医保号';
      If Sql%RowCount = 0 Then
        Insert Into 病案主页从表 (病人id, 主页id, 信息名, 信息值) Values (病人id_In, v_主页id, '医保号', 医保号_In);
      End If;
    Else
      Delete From 病案主页从表 Where 病人id = 病人id_In And 主页id = v_主页id And 信息名 = '医保号';
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人信息_Update;
/

--110541:余伟节,2017-06-30,启用身份证号唯一建档检查
Create Or Replace Procedure Zl_病人信息_Insert
(
  病人id_In         病人信息.病人id%Type,
  门诊号_In         病人信息.门诊号%Type,
  费别_In           病人信息.费别%Type,
  医疗付款_In       病人信息.医疗付款方式%Type,
  姓名_In           病人信息.姓名%Type,
  性别_In           病人信息.性别%Type,
  年龄_In           病人信息.年龄%Type,
  出生日期_In       病人信息.出生日期%Type,
  出生地点_In       病人信息.出生地点%Type,
  身份证号_In       病人信息.身份证号%Type,
  身份_In           病人信息.身份%Type,
  职业_In           病人信息.职业%Type,
  民族_In           病人信息.民族%Type,
  国籍_In           病人信息.国籍%Type,
  学历_In           病人信息.学历%Type,
  婚姻_In           病人信息.婚姻状况%Type,
  家庭地址_In       病人信息.家庭地址%Type,
  家庭电话_In       病人信息.家庭电话%Type,
  家庭地址邮编_In   病人信息.家庭地址邮编%Type,
  联系人姓名_In     病人信息.联系人姓名%Type,
  联系人关系_In     病人信息.联系人关系%Type,
  联系人地址_In     病人信息.联系人地址%Type,
  联系人电话_In     病人信息.联系人电话%Type,
  合同单位id_In     病人信息.合同单位id%Type,
  工作单位_In       病人信息.工作单位%Type,
  单位电话_In       病人信息.单位电话%Type,
  单位邮编_In       病人信息.单位邮编%Type,
  单位开户行_In     病人信息.单位开户行%Type,
  单位帐号_In       病人信息.单位帐号%Type,
  担保人_In         病人信息.担保人%Type,
  担保额_In         病人信息.担保额%Type,
  险类_In           病人信息.险类%Type,
  登记时间_In       病人信息.登记时间%Type,
  区域_In           病人信息.区域%Type := Null,
  担保性质_In       病人信息.担保性质%Type := Null,
  操作员编号_In     病人担保记录.操作员编号%Type := Null,
  操作员姓名_In     病人担保记录.操作员姓名%Type := Null,
  医保号_In         病人信息.医保号%Type := Null,
  其他证件_In       病人信息.其他证件%Type := Null,
  籍贯_In           病人信息.籍贯%Type := Null,
  户口地址_In       病人信息.户口地址%Type := Null,
  户口地址邮编_In   病人信息.户口地址邮编%Type := Null,
  联系人身份证号_In 病人信息.联系人身份证号%Type := Null,
  病人类型_In       病人信息.病人类型%Type := Null,
  监护人_In         病人信息.监护人%Type := Null,
  手机号_In         病人信息.手机号%Type := Null
) As
  v_费别       病人信息.费别%Type;
  v_手机号     病人信息.手机号%Type;
  v_手机号字段 Varchar2(500);
  n_Count      Number;
  v_Error      Varchar2(255);
  Err_Custom Exception;
Begin
  If 费别_In Is Null Then
    Select Max(名称) Into v_费别 From 费别 Where 缺省标志 = 1; --不管适用科室和服务对象
  Else
    v_费别 := 费别_In;
  End If;

  If 手机号_In Is Null Then
    If 家庭电话_In Is Not Null Then
      --中国移动
      v_手机号字段 := ',139,138,137,136,135,134,159,158,157,150,151,152,147,188,187,182,183,184,178';
      --中国联通
      v_手机号字段 := v_手机号字段 || ',130,131,132,156,155,186,185,145,176';
      --中国电信
      v_手机号字段 := v_手机号字段 || ',133,153,189,180,181,177,173';
      --虚拟运营商
      v_手机号字段 := v_手机号字段 || ',170,';
      If Not Instr(v_手机号字段, ',' || Substr(家庭电话_In, 1, 3) || ',') = 0 Then
        v_手机号 := 家庭电话_In;
      End If;
    End If;
  Else
    v_手机号 := 手机号_In;
  End If;
  --身份证号不等于空,根据系统参数判读是否唯一建档病人
  If 身份证号_In Is Not Null Then
    n_Count := Nvl(zl_GetSysParameter(279), 0);
    If n_Count = 1 Then
      Select Count(1) Into n_Count From 病人信息 Where 身份证号 = 身份证号_In And 病人id <> Nvl(病人id_In, 0);
      If n_Count <> 0 Then
        v_Error := '已经存在身份证号为' || 身份证号_In || '的病人,不能再录入相同的身份证号!';
        Raise Err_Custom;
      End If;
    End If;
  End If;
  Insert Into 病人信息
    (病人id, 门诊号, 费别, 医疗付款方式, 姓名, 性别, 年龄, 出生日期, 出生地点, 身份证号, 身份, 职业, 民族, 国籍, 区域, 籍贯, 学历, 婚姻状况, 家庭地址, 家庭电话, 家庭地址邮编, 户口地址,
     户口地址邮编, 联系人姓名, 联系人关系, 联系人地址, 联系人电话, 合同单位id, 工作单位, 单位电话, 单位邮编, 单位开户行, 单位帐号, 担保人, 担保额, 担保性质, 险类, 登记时间, 医保号, 其他证件,
     联系人身份证号, 病人类型, 监护人, 手机号)
  Values
    (病人id_In, 门诊号_In, v_费别, 医疗付款_In, 姓名_In, 性别_In, 年龄_In, 出生日期_In, 出生地点_In, 身份证号_In, 身份_In, 职业_In, 民族_In, 国籍_In, 区域_In,
     籍贯_In, 学历_In, 婚姻_In, 家庭地址_In, 家庭电话_In, 家庭地址邮编_In, 户口地址_In, 户口地址邮编_In, 联系人姓名_In, 联系人关系_In, 联系人地址_In, 联系人电话_In,
     Decode(合同单位id_In, 0, Null, 合同单位id_In), 工作单位_In, 单位电话_In, 单位邮编_In, 单位开户行_In, 单位帐号_In, 担保人_In,
     Decode(担保额_In, 0, Null, 担保额_In), 担保性质_In, 险类_In, 登记时间_In, 医保号_In, 其他证件_In, 联系人身份证号_In, 病人类型_In, 监护人_In, v_手机号);

  If 门诊号_In Is Not Null Then
    Insert Into 门诊病案记录
      (病人id, 病案号, 建立日期, 病案类别, 存储状态, 存放位置)
    Values
      (病人id_In, 门诊号_In, 登记时间_In, '一般', '正常', Null);
  End If;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人信息_Insert;
/

--97996:陈刘,2017-06-30,体温单编辑重整
Create Or Replace Procedure Zl_体温单数据_Update
(
  文件id_In   In 病人护理文件.Id%Type, --病人护理文件ID
  发生时间_In In 病人护理数据.发生时间%Type, --护理数据的发生时间
  记录类型_In In 病人护理明细.记录类型%Type, --护理项目=1，上标说明=2，入出转标记=3，手术日标记=4,下标说明=6
  项目序号_In In 病人护理明细.项目序号%Type, --护理项目的序号，非护理项目固定为0
  记录内容_In In 病人护理明细.记录内容%Type := Null, --记录内容，如果内容为空，即清除以前的内容  36或36/37
  体温部位_In In 病人护理明细.体温部位%Type := Null, --删除数据时不用填写部位 除活动项目外
  复试合格_In In Number := 0,
  未记说明_In In 病人护理明细.未记说明%Type := Null, --未记说明
  他人记录_In In Number := 1,
  数据来源_In In 病人护理明细.数据来源%Type := 0,
  来源id_In   In 病人护理明细.来源id%Type := Null, --始终为原始记录的来源ID
  共用_In     In 病人护理明细.共用%Type := 0,
  项目首次_In In Number := 0, --汇总项目使用，保存数据前是否先删除一段时间内的数据信息。 1 删除
  开始时间_In In 病人护理数据.发生时间%Type := Null, --本记录有效跨度的开始时间
  结束时间_In In 病人护理数据.发生时间%Type := Null, --本记录有效跨度的终止时间，单独记录为每分钟，体温表为4小时,时间跨度内的相同项目记录要删除

  操作员_In   In 病人护理数据.保存人%Type := Null,
  检查科室_In In Number := 1,
  显示_In     In Number := 0
) Is
  n_项目序号 病人护理明细.项目序号%Type;
  n_记录标记 病人护理明细.记录标记%Type; --记录内容的特殊标志
  v_保存人   病人护理数据.保存人%Type;
  v_记录人   病人护理明细.记录人%Type;
  d_结束时间 病人护理数据.发生时间%Type;
  d_发生时间 病人护理数据.发生时间%Type;
  d_开始时间 病人护理数据.发生时间%Type;
  n_记录id   病人护理明细.记录id%Type;
  v_科室id   病人护理文件.科室id%Type;
  n_心率应用 护理记录项目.应用方式%Type;
  n_脉搏     护理记录项目.项目序号%Type := 2;
  n_体温     护理记录项目.项目序号%Type := 1;
  n_心率     护理记录项目.项目序号%Type := -1;
  n_项目性质 护理记录项目.项目性质%Type := 1;
  n_开始版本 病人护理明细.开始版本%Type;
  n_疼痛强度 护理记录项目.项目序号%Type;
  n_Newid    病人护理明细.Id%Type;

  n_病人id       病人护理文件.病人id%Type;
  n_主页id       病人护理文件.主页id%Type;
  n_婴儿         病人护理文件.婴儿%Type;
  d_婴儿出院时间 病人医嘱记录.开始执行时间%Type;
  d_文件开始时间 病人护理文件.开始时间%Type;
  n_Preblue      Number;
  n_i            Number;
  n_Sqlrowcount  Number;
  v_记录内容     病人护理明细.记录内容%Type;
  v_Data         病人护理明细.记录内容%Type;
  --主过程
  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  d_发生时间 := 发生时间_In;

  If d_发生时间 Is Null Then
    v_Error := '数据发生时间不能为空！';
    Raise Err_Custom;
  End If;

  If 开始时间_In Is Null Then
    d_开始时间 := d_发生时间;
  Else
    d_开始时间 := 开始时间_In;
  End If;

  If 结束时间_In Is Null Then
    d_结束时间 := d_开始时间;
  Else
    d_结束时间 := 结束时间_In;
  End If;

  --提取记录ID
  n_记录id := 0;
  If 操作员_In Is Null Then
    v_保存人 := Zl_Username;
  Else
    v_保存人 := 操作员_In;
  End If;
  ----------------------------------------------------------------------------------------------------------------------
  Begin
    Select ID Into n_记录id From 病人护理数据 Where 文件id = 文件id_In And 发生时间 = 发生时间_In;
  Exception
    When Others Then
      n_记录id := 0;
  End;

  --检查数据的发生时间是否对应科室
  ---------------------------------------------------------------------------------------------------------------------
  Select 病人id, 主页id, Nvl(婴儿, 0), 开始时间
  Into n_病人id, n_主页id, n_婴儿, d_文件开始时间
  From 病人护理文件
  Where ID = 文件id_In;
  d_婴儿出院时间 := Null;
  If n_婴儿 <> 0 Then
    Begin
      Select 开始执行时间
      Into d_婴儿出院时间
      From 病人医嘱记录 B, 诊疗项目目录 C
      Where b.诊疗项目id + 0 = c.Id And b.医嘱状态 = 8 And Nvl(b.婴儿, 0) <> 0 And c.类别 = 'Z' And
            Instr(',3,5,11,', ',' || c.操作类型 || ',', 1) > 0 And b.病人id = n_病人id And b.主页id = n_主页id And b.婴儿 = n_婴儿;
    Exception
      When Others Then
        d_婴儿出院时间 := Null;
    End;
  End If;
  If d_婴儿出院时间 Is Null Then
    v_科室id := 0;
    Begin
      Select a.科室id
      Into v_科室id
      From 病人变动记录 A, 病人护理文件 B
      Where a.科室id Is Not Null And a.病人id = b.病人id And a.主页id = b.主页id And b.Id = 文件id_In And
            (发生时间_In >= a.开始时间 And (发生时间_In < = Nvl(a.终止时间, Sysdate) Or a.终止时间 Is Null)) And Rownum < 2;
    Exception
      When Others Then
        v_科室id := 0;
    End;
    If v_科室id = 0 And 检查科室_In = 1 Then
      v_Error := '数据发生时间 ' || To_Char(发生时间_In, 'YYYY-MM-DD HH24:MI:SS') || ' 不在病人有效变动时间范围内，不能操作！';
      Raise Err_Custom;
    End If;
  Else
    If 发生时间_In < d_文件开始时间 Or (发生时间_In > d_婴儿出院时间 And 检查科室_In = 1) Then
      v_Error := '数据发生时间 ' || To_Char(发生时间_In, 'YYYY-MM-DD HH24:MI:SS') || ' 不在病人有效变动时间范围内，不能操作！';
      Raise Err_Custom;
    End If;
  End If;
  --检查是不是本人的记录
  ---------------------------------------------------------------------------------------------------------------------
  If 他人记录_In = 0 And n_记录id > 0 Then
    v_记录人 := '';
    Begin
      Select 记录人
      Into v_记录人
      From 病人护理明细
      Where 记录id = n_记录id And 记录类型 = 记录类型_In And 项目序号 = 项目序号_In And 终止版本 Is Null And Rownum < 2
      Order By Nvl(记录标记, 0);
    Exception
      When Others Then
        v_记录人 := '';
    End;
    If v_记录人 Is Not Null And v_记录人 <> v_保存人 Then
      v_Error := '在' || To_Char(d_开始时间, 'yyyy-mm-dd hh24:mi:ss') || '至' || To_Char(d_结束时间, 'yyyy-mm-dd hh24:mi:ss') ||
                 '段内记录人不是当前人，你无权修改！';
      Raise Err_Custom;
    End If;
  End If;

  --提取疼痛强度曲线项目的项目序号
  Begin
    Select 项目序号 Into n_疼痛强度 From 体温记录项目 Where 记录名 = '疼痛强度';
  Exception
    When Others Then
      n_疼痛强度 := -999;
  End;
  --检查脉搏心率是否共用
  If 项目序号_In = n_脉搏 Then
    n_项目序号 := n_心率;
  Else
    n_项目序号 := 项目序号_In;
  End If;
  Begin
    Select 应用方式, 项目性质 Into n_心率应用, n_项目性质 From 护理记录项目 Where 项目序号 = n_项目序号;
  Exception
    When Others Then
      n_心率应用 := 0;
  End;

  ----清除某段时间内的护理数据信息
  --项目首次_In 汇总项目根据汇总时间段保存一天数据时先清除在保存 项目首次_In：=1
  --记录内容_In Is Null And 未记说明_In Is Null 则认为删除数据
  ---------------------------------------------------------------------------------------------------------------------
  If (项目首次_In = 1) Or (记录内容_In Is Null And 未记说明_In Is Null) Then
    If 项目首次_In = 1 Then
      For r_List In (Select l.Id, Count(*) As 记录数, Min(l.发生时间) 发生时间
                     From 病人护理文件 A, 病人护理数据 L, 病人护理明细 D
                     Where a.Id = l.文件id And l.Id = d.记录id And a.Id = 文件id_In And d.终止版本 Is Null And l.发生时间 >= d_开始时间 And
                           l.发生时间 <= d_结束时间
                     Group By l.Id) Loop
        n_Sqlrowcount := 0;
        If 记录类型_In = 2 Or 记录类型_In = 6 Then
          Delete 病人护理明细
          Where 记录id = r_List.Id And 记录类型 = 记录类型_In And 项目序号 = 项目序号_In And 终止版本 Is Null;
          n_Sqlrowcount := Sql%RowCount;
        Else
          If 体温部位_In Is Not Null Then
            --此处主要针对活动项目
            Delete 病人护理明细
            Where 记录id = r_List.Id And 记录类型 = 记录类型_In And 项目序号 = 项目序号_In And Nvl(体温部位, '无') = Nvl(体温部位_In, '无') And
                  终止版本 Is Null;
          Else
            Delete 病人护理明细
            Where 记录id = r_List.Id And 记录类型 = 记录类型_In And 项目序号 = 项目序号_In And 终止版本 Is Null;
          End If;
        
          n_Sqlrowcount := Sql%RowCount;
          --如果脉搏和心率共用删除脉搏是同时删除心率数据
          If 项目序号_In = n_脉搏 And n_心率应用 = 2 Then
            Delete 病人护理明细
            Where 记录id = r_List.Id And 记录类型 = 记录类型_In And 项目序号 = n_心率 And 终止版本 Is Null;
            n_Sqlrowcount := n_Sqlrowcount + Sql%RowCount;
          End If;
          --如果为收缩压/舒张压删除收缩压时同时删除舒张压数据
          If 项目序号_In = 4 Then
            Delete 病人护理明细
            Where 记录id = r_List.Id And 记录类型 = 记录类型_In And 项目序号 = 5 And 终止版本 Is Null;
            n_Sqlrowcount := n_Sqlrowcount + Sql%RowCount;
          End If;
        End If;
        If n_Sqlrowcount >= r_List.记录数 Then
          Delete 病人护理数据 Where ID = r_List.Id;
        End If;
        --更新打印
        Update 体温单打印
        Set 打印人 = Null, 打印时间 = Null
        Where 文件id = 文件id_In And
              开始时间 = (Select Max(开始时间) From 体温单打印 Where 文件id = 文件id_In And 开始时间 <= r_List.发生时间);
      End Loop;
    Else
      For r_List In (Select l.Id, Count(*) As 记录数, Min(l.发生时间) 发生时间
                     From 病人护理文件 A, 病人护理数据 L, 病人护理明细 D
                     Where a.Id = l.文件id And l.Id = d.记录id And a.Id = 文件id_In And d.终止版本 Is Null And l.发生时间 = 发生时间_In And
                           l.发生时间 >= d_开始时间 And l.发生时间 <= d_结束时间
                     Group By l.Id) Loop
        n_Sqlrowcount := 0;
        If 记录类型_In = 2 Or 记录类型_In = 6 Then
          Delete 病人护理明细
          Where 记录id = r_List.Id And 记录类型 = 记录类型_In And 项目序号 = 项目序号_In And 终止版本 Is Null;
          n_Sqlrowcount := Sql%RowCount;
        Else
          If 体温部位_In Is Not Null Then
            --此处主要针对活动项目
            Delete 病人护理明细
            Where 记录id = r_List.Id And 记录类型 = 记录类型_In And 项目序号 = 项目序号_In And Nvl(体温部位, '无') = Nvl(体温部位_In, '无') And
                  终止版本 Is Null;
          Else
            Delete 病人护理明细
            Where 记录id = r_List.Id And 记录类型 = 记录类型_In And 项目序号 = 项目序号_In And 终止版本 Is Null;
          End If;
        
          n_Sqlrowcount := Sql%RowCount;
          --如果脉搏和心率共用删除脉搏是同时删除心率数据
          If 项目序号_In = n_脉搏 And n_心率应用 = 2 Then
            Delete 病人护理明细
            Where 记录id = r_List.Id And 记录类型 = 记录类型_In And 项目序号 = n_心率 And 终止版本 Is Null;
            n_Sqlrowcount := n_Sqlrowcount + Sql%RowCount;
          End If;
          --如果为收缩压/舒张压删除收缩压时同时删除舒张压数据
          If 项目序号_In = 4 Then
            Delete 病人护理明细
            Where 记录id = r_List.Id And 记录类型 = 记录类型_In And 项目序号 = 5 And 终止版本 Is Null;
            n_Sqlrowcount := n_Sqlrowcount + Sql%RowCount;
          End If;
        End If;
        If n_Sqlrowcount >= r_List.记录数 Then
          Delete 病人护理数据 Where ID = r_List.Id;
        End If;
        --更新打印
        Update 体温单打印
        Set 打印人 = Null, 打印时间 = Null
        Where 文件id = 文件id_In And
              开始时间 = (Select Max(开始时间) From 体温单打印 Where 文件id = 文件id_In And 开始时间 <= r_List.发生时间);
      End Loop;
    End If;
  End If;

  If 记录内容_In Is Null And 未记说明_In Is Null Then
    Return;
  End If;

  --分解项目记录内容
  n_Preblue := 0;
  If 记录类型_In = 1 And Instr(',' || n_疼痛强度 || ',1,2,4,', ',' || 项目序号_In || ',', 1) > 0 Then
    n_Preblue := Nvl(Instr(Nvl(记录内容_In, ''), '/', 1), 0);
    If n_Preblue > 1 Then
      n_Preblue := 1;
    End If;
  End If;

  If 项目序号_In = 4 And n_Preblue = 0 Then
    v_Error := '血压数据格式错误! 格式:收缩压/舒张压。';
    Raise Err_Custom;
  End If;

  --确认开始版本号
  ---------------------------------------------------------------------------------------------------------------------
  n_开始版本 := 1;

  --改写病人护理数据：如果已经存在与病人、科室和发生时间相同的记录则修改，否则增加新的记录
  ---------------------------------------------------------------------------------------------------------------------
  --汇总项目是删除后在增加，可能开始提取的记录ID已经不存在。
  Begin
    Select ID Into n_记录id From 病人护理数据 Where ID = n_记录id;
  Exception
    When Others Then
      n_记录id := 0;
  End;

  If n_记录id = 0 Then
    Select 病人护理数据_Id.Nextval Into n_记录id From Dual;
    Insert Into 病人护理数据
      (ID, 文件id, 显示, 发生时间, 保存人, 保存时间, 最后版本)
    Values
      (n_记录id, 文件id_In, 0, d_发生时间, v_保存人, Sysdate, n_开始版本);
  End If;

  --检查删除物理降温数据或脉搏短轴数据
  If (项目序号_In = n_体温 Or 项目序号_In = n_疼痛强度 Or (项目序号_In = n_脉搏 And n_心率应用 = 2)) And n_Preblue = 0 Then
    Delete From 病人护理明细
    Where 记录id = n_记录id And 项目序号 = Decode(项目序号_In, n_脉搏, n_心率, 项目序号_In) And Decode(项目序号_In, n_脉搏, 1, Nvl(记录标记, 0)) = 1 And
          记录类型 = 记录类型_In And 终止版本 Is Null;
  End If;

  --改写病人护理明细：如果已经存在与病人、科室和发生时间相同的记录则修改，否则增加新的记录
  -----------------------------------------------------------------------------------------------------------------------
  v_Data     := 记录内容_In;
  n_项目序号 := 项目序号_In;
  For n_i In 0 .. n_Preblue Loop
    If n_i = 0 Then
      If 项目序号_In = n_心率 Then
        n_记录标记 := 1;
      Else
        n_记录标记 := 0;
      End If;
    Else
      --收缩压/舒张压
      If 项目序号_In = 4 Then
        n_记录标记 := 0;
        n_项目序号 := 5;
      Else
        n_记录标记 := 1;
        If 项目序号_In = n_脉搏 Then
          n_项目序号 := n_心率;
        End If;
      End If;
    
    End If;
    If n_Preblue > 0 Then
      v_记录内容 := Substr(v_Data, 1, Instr(v_Data, '/', 1) - 1);
      If v_记录内容 Is Null Then
        v_记录内容 := v_Data;
      End If;
    Else
      v_记录内容 := v_Data;
    End If;
  
    --为了兼容以前同步过来的心率数据记录标记为0
    If n_i = 0 Then
      Update 病人护理明细
      Set 记录内容 = v_记录内容, 体温部位 = 体温部位_In, 复试合格 = 复试合格_In,
          未记说明 = Decode(n_项目序号, n_体温, Decode(v_记录内容, '不升', Null, 未记说明_In), 未记说明_In), 记录人 = v_保存人, 记录时间 = Sysdate
      Where 记录id = n_记录id And 项目序号 = n_项目序号 And 记录类型 = 记录类型_In And
            Decode(项目序号_In, n_体温, Nvl(记录标记, 0), n_疼痛强度, Nvl(记录标记, 0), Nvl(n_记录标记, 0)) = Nvl(n_记录标记, 0) And
            Decode(n_项目性质, 2, Nvl(体温部位, '无'), Nvl(体温部位_In, '无')) = Nvl(体温部位_In, '无') And 终止版本 Is Null;
    Else
      Update 病人护理明细
      Set 记录内容 = v_记录内容, 记录人 = v_保存人, 记录时间 = Sysdate
      Where 记录id = n_记录id And 项目序号 = n_项目序号 And 记录类型 = 记录类型_In And
            Decode(项目序号_In, n_体温, Nvl(记录标记, 0), n_疼痛强度, Nvl(记录标记, 0), Nvl(n_记录标记, 0)) = Nvl(n_记录标记, 0) And 终止版本 Is Null;
    End If;
    If Sql%RowCount = 0 Then
      --插入本次登记的病人护理内容
      If Mod(记录类型_In, 10) = 1 Then
        select 病人护理明细_Id.Nextval into n_Newid from dual;
        Insert Into 病人护理明细
          (ID, 记录id, 记录类型, 项目分组, 项目id, 项目序号, 项目名称, 项目类型, 记录内容, 项目单位, 记录标记, 记录人, 体温部位, 复试合格, 开始版本, 终止版本, 记录组号, 未记说明,
           记录时间, 数据来源, 显示, 来源id, 共用)
          Select n_Newid, n_记录id, 记录类型_In, 分组名, 项目id, 项目序号, 项目名称, 项目类型, v_记录内容, 项目单位, n_记录标记, v_保存人, 体温部位_In, 复试合格_In,
                 n_开始版本, Null, Null, Decode(n_项目序号, n_体温, Decode(v_记录内容, '不升', Null, 未记说明_In), 未记说明_In), Sysdate,
                 数据来源_In, 0, 来源id_In, 共用_In
          From 护理记录项目
          Where 项目序号 = n_项目序号;
        If 显示_In = 1 Then
          Zl_体温单数据_设置显示(n_Newid,1 );
        End If;
      Else
        Insert Into 病人护理明细
          (ID, 记录id, 记录类型, 项目分组, 项目id, 项目序号, 项目名称, 项目类型, 记录内容, 项目单位, 记录标记, 记录人, 体温部位, 复试合格, 开始版本, 终止版本, 记录组号, 未记说明,
           记录时间, 数据来源, 显示, 来源id, 共用)
        Values
          (病人护理明细_Id.Nextval, n_记录id, 记录类型_In, Null, Null, 0,
           Decode(记录类型_In, 2, '上标说明', 6, '下标说明', 3, '入出转', 4, v_记录内容), Decode(记录类型_In, 3, 0, 1),
           Decode(记录类型_In, 4, '1', 记录内容_In), '', n_记录标记, v_保存人, 体温部位_In, 复试合格_In, n_开始版本, Null, Null, 未记说明_In, Sysdate,
           数据来源_In, 0, 来源id_In, 共用_In);
      End If;
    End If;
    If n_Preblue > 0 Then
      v_Data := Substr(v_Data, Instr(v_Data, '/', 1) + 1);
    End If;
  End Loop;
  --更新打印
  Update 体温单打印
  Set 打印人 = Null, 打印时间 = Null
  Where 文件id = 文件id_In And
        开始时间 = (Select Max(开始时间) From 体温单打印 Where 文件id = 文件id_In And 开始时间 <= d_发生时间);

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_体温单数据_Update;
/
--97996:陈刘,2017-06-30,体温单编辑重整
Create Or Replace Procedure ZL_体温单数据_设置显示(
	ID_IN		IN 病人护理明细.ID%Type,
	显示_IN		IN 病人护理明细.显示%Type
)
IS
	v_保存人  病人护理数据.保存人%Type;
	N_显示    病人护理明细.显示%Type;
Begin
	--提取原始显示状态
	Begin
		SELECT 显示 INTO N_显示
		FROM 病人护理明细
		WHERE ID=ID_IN;
	Exception
		When Others Then
			N_显示 :=0;
	End ;

	IF n_显示=显示_IN THEN
		RETURN;
	End IF ;
	--提取保存人
	V_保存人 := ZL_USERNAME;

	UPDATE 病人护理明细 SET 显示=显示_IN,记录人=v_保存人,记录时间=sysdate WHERE ID=ID_IN;
Exception
	When Others Then ZL_ERRORCENTER(SQLCODE, SQLERRM);
End ZL_体温单数据_设置显示;
/
--106313:余伟节,2017-06-30,病案接收允许录入病案号共享过程与病案系统保持一致。
Create Or Replace Procedure Zl_病案接收记录_Insert
(
  病人id_In   In 病案接收记录.病人id%Type,
  主页id_In   In 病案接收记录.主页id%Type,
  运送人_In   In 病案接收记录.运送人%Type,
  接收人_In   In 病案接收记录.接收人%Type,
  接收时间_In In 病案接收记录.接收时间%Type,
  记录时间_In In 病案接收记录.记录时间%Type,
  病案号_In   In 病案主页.病案号%Type := Null
) Is
  n_Id      病案接收记录.Id%Type;
  n_Count   Number := 0;
  v_Err_Msg Varchar2(2000);
  Err_Item Exception;
  n_提交id Number(18);
Begin
  Select Count(病人id) Into n_Count From 病案接收记录 Where 病人id = 病人id_In And 主页id = 主页id_In;
  If Nvl(n_Count, 0) > 0 Then
    Update 病案接收记录
    Set 病人id = 病人id_In, 主页id = 主页id_In, 运送人 = 运送人_In, 接收人 = 接收人_In, 接收时间 = 接收时间_In, 记录时间 = 记录时间_In
    Where 病人id = 病人id_In And 主页id = 主页id_In;
  Else
    Select 病案接收记录_Id.Nextval Into n_Id From Dual;
    Insert Into 病案接收记录
      (ID, 病人id, 主页id, 运送人, 接收人, 接收时间, 记录时间)
    Values
      (n_Id, 病人id_In, 主页id_In, 运送人_In, 接收人_In, 接收时间_In, 记录时间_In);
  End If;
  If Sql%NotFound Then
    v_Err_Msg := '[ZLSOFT]病案接收管理增加及修改接收记录失败，请核查再试！[ZLSOFT]';
    Raise Err_Item;
  End If;
  If Nvl(病案号_In, '空') <> '空' Then
    Update 病案主页 Set 病案号 = 病案号_In Where 病人id = 病人id_In And 主页id = 主页id_In;
  End If;
  Begin
    --电子病案接收需要，因为可能独立安装，所以只能动态执行 
    Execute Immediate 'Select ID From 病案提交记录 Where 病人ID=:1 and 主页id=:2'
      Into n_提交id
      Using 病人id_In, 主页id_In;
    Execute Immediate 'Call ZL_病案提交记录_RECEIVE(:1,:2)'
      Using n_提交id, 接收人_In;
  Exception
    When Others Then
      Null;
  End;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病案接收记录_Insert;
/

--110904:涂建华,2017-06-30,区位检查数据调用接口增加
Create Or Replace Procedure ZL_Thrid_GetStudyProject
(
  Xml_In    In  Xmltype,
  Xml_Out   Out Xmltype 
)Is
  v_Temp Varchar2(4000);
  x_Templet  Xmltype; --模板XML
  n_Id  Number(18);
  n_BRID Number(18);
  n_ZYID Number(18);
  n_BRLY Number(18);
  n_BRKS Number(18);
  n_CZRID Number(18);
  n_DQKS Number(18);
  n_ZXKS  Number(1);
  v_Sql   Varchar2(4000);
  n_Count Number(18);
  n_day   Number(18);
  
  
  cur_Id  Number(18);
  cur_Bm  Number(18);
  cur_MC  Varchar2(100);
  cur_FWDX  Number(18);
  
  TYPE Cursor_Type IS REF CURSOR;
  R_Department Cursor_Type;
       
  --项目基本信息
  Cursor Cur_Projects(Id_In Number) Is
    Select ID, 编码, 适用性别, 执行科室 From 诊疗项目目录 Where  id =ID_In;

  --项目部位信息
	Cursor Cur_Parts(Id_In Number) Is
		Select ID, 部位, 方法 From 诊疗项目部位 Where  项目id =ID_In;
      
  
Begin
  --------------------------------------------------------------------------------------------------
  --功能:根据诊疗项目ID获取项目相关信息
  --入参:Xml_In
  --<IN>
  --   <XMID></XMID>          //诊疗项目ID
  --   <BRID></BRID>          //病人ID
  --   <ZYID></ZYID>          //主页ID
  --   <BRLY></BRLY>          //病人来源
  --   <BRKS></BRKS>          //病人科室ID
  --   <CZRID></CZRID>        //当前用户ID
  --   <DQKS></DQKS>          //当前科室ID
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  --  <XMID></XMID>             //项目ID
  --  <XMBM></XMBM>             //项目编码
  --  <SYXB></SYXB>             //适用性别
  --  <KSLX></KSLX>             //科室类型
  --  <JCBW>                    //检查部位

  --      <ID></ID>             //部位方法ID
  --      <BWMC></BWMC>         //部位名称
  --      <BWFF></BWFF>         //部位方法        

  --  </JCBW>
  --  <ZXKS>
 
  --      <ID></ID>                 //科室ID
  --      <KSMC></KSMC>             //科室名称

  --  </ZXKS>
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
    Select Nvl(ExtractValue(Xml_In, '/IN/XMID'),0),
           Nvl(ExtractValue(Xml_In, '/IN/BRID'),0),
           Nvl(ExtractValue(Xml_In, '/IN/ZYID'),0),
           Nvl(ExtractValue(Xml_In, '/IN/BRLY'),0),
           Nvl(ExtractValue(Xml_In, '/IN/BRKS'),0),
           Nvl(ExtractValue(Xml_In, '/IN/CZRID'),0),
           Nvl(ExtractValue(Xml_In, '/IN/DQKS'),0) 
     Into n_Id, n_BRID, n_ZYID, n_BRLY, n_BRKS, n_CZRID, n_DQKS From Dual;
   
    --配置基本信息
    For Row_Project In Cur_Projects(n_Id) Loop
      v_Temp   := '<ID>'|| Row_Project.ID || '</ID>' || 
                  '<XMBM>' || Row_Project.编码 || '</XMBM>' ||
                  '<SYXB>' ||Row_Project.适用性别 || '</SYXB>' ||
                  '<KSLX>' || Row_Project.执行科室 || '</KSLX>' ;
      n_ZXKS :=Nvl(Row_Project.执行科室, 0);
      
      Select Xmltype('<?xml version="1.0" encoding="UTF-8" ?><OUTPUT>' || v_Temp || '</OUTPUT>') Into x_Templet From Dual;
    End Loop;
    
    --配置部位信息
		For Row_Part In Cur_Parts(n_Id) Loop
			v_Temp   := '<JCBW><ID>'|| Row_Part.ID || '</ID><BWMC>' || Row_Part.部位 || '</BWMC><BWFF>' ||Row_Part.方法 || '</BWFF></JCBW>' ;
      Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
		End Loop;
    
    v_sql := '';
    --配置科室信息
    Case n_ZXKS
      When 1 Then --病人所在科室
        v_sql := 'Select A.ID,A.编码,A.名称, B.服务对象 
                 From 部门表 A, 部门性质说明 B 
                 Where A.Id=B.部门ID And A.ID=' || n_BRKS || ' Order by 编码';                  
      When 2 Then --病人所在病区
        If n_BRLY = 1 Then     --门诊
          v_sql := 'Select A.ID,A.编码,A.名称, B.服务对象 
                   From 部门表 A, 部门性质说明 B 
                   Where A.Id=B.部门ID And A.ID=' || n_BRKS || ' Order by 编码';                 
        Else
          v_sql := 'Select A.ID,A.编码,A.名称,C.服务对象
                   From 部门表 A,病案主页 B, 部门性质说明 C
                   Where A.ID=B.当前病区ID And A.Id=C.部门ID And B.病人ID=' || n_BRID || ' And B.主页ID=' || n_ZYID || ' Order By 编码';
        End If;
      When 3 Then --操作员所在科室
        v_sql := 'Select Distinct A.ID, A.编码, A.名称, C.服务对象 
                   From 部门表 A,部门人员 B,部门性质说明 C
                   Where A.ID=B.部门ID And A.ID=C.部门ID 
                         And A.撤档时间 > to_date(''2999-1-1'',''yyyy-mm-dd'') And B.人员ID =' || n_CZRID || ' Order By 编码';
                      
      When 4 Then --指定执行科室
        Select Nvl(Max(1),0) Into n_Count 
        From 部门性质说明 A,部门安排 B 
        Where A.部门ID=B.部门ID And A.工作性质 Not IN('西药房','成药房','中药房') And Rownum<2;
        
        If n_Count <= 0 Then
           v_sql := 'Select Distinct c.Id, c.编码,c.名称, B.服务对象
                     From 诊疗执行科室 A,部门性质说明 B,部门表 C
                     Where A.执行科室ID=B.部门ID And A.诊疗项目ID=' || n_Id || '
                          And B.服务对象 IN(' || n_BRLY || ',3) And (A.病人来源 is NULL Or A.病人来源=' || n_BRLY || ')
                          And (A.开单科室ID is NULL Or A.开单科室ID=' || n_DQKS ||')
                          And A.执行科室ID=C.ID 
                          And (C.撤档时间=TO_DATE(''3000-01-01'',''YYYY-MM-DD'') Or C.撤档时间 is NULL)
                          Order by 编码';
        Else
          Select To_Number(To_Char(sysdate - 1,'d')) Into n_Day from dual;
          v_sql := 'Select Distinct d.Id, d.编码,d.名称, C.服务对象  
                    From 诊疗执行科室 A,部门安排 B,部门性质说明 C,部门表 D
                    Where A.执行科室ID+0=B.部门ID And B.星期='|| n_day || '
                      And To_Char(Sysdate,''HH24:MI:SS'') Between To_Char(B.开始时间,''HH24:MI:SS'') and To_Char(B.终止时间,''HH24:MI:SS'')
                      And A.执行科室ID=C.部门ID And C.服务对象 IN(' || n_BRLY || ',3) And (A.病人来源 is NULL Or A.病人来源=' || n_BRLY || ')
                      And (A.开单科室ID is NULL Or A.开单科室ID=' || n_DQKS || ')
                      And A.执行科室ID=D.ID 
                      And (D.撤档时间=TO_DATE(''3000-01-01'',''YYYY-MM-DD'') Or D.撤档时间 is NULL)
                      And A.诊疗项目ID=' || n_Id || '
                      Order by 编码';
        End If;
        
            
      When 5 Then --院外执行
        Null;
      When 6 Then --开单人所在科室
        v_sql := 'Select A.ID,A.编码,A.名称,B.服务对象 
                  From 部门表 A, 部门性质说明 B 
                  Where A.Id=B.部门ID And ID=' || n_DQKS || ' Order by 编码';
      Else
        Null;
    End Case;
    
    If v_sql is not null Then
      Open R_Department For v_Sql;
      Loop
        
        FETCH R_Department INTO Cur_ID, Cur_BM, Cur_MC, Cur_FWDX;
        EXIT WHEN R_Department%NOTFOUND;  
        
        v_Temp   := '<ZXKS><ID>'|| Cur_ID || '</ID><KSMC>' || Cur_MC || '</KSMC></ZXKS>';
        Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
      End Loop;
    End If;
    
    
    Xml_Out := x_Templet;    
    
Exception
  When Others Then
    v_Temp := '<ERROR><MSG>' || SQLErrM || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Xml_Out := x_Templet;
End ZL_Thrid_GetStudyProject;
/

--108933:殷瑞,2017-06-30,药品领用模块新增申请冲销、审核冲销功能
Create Or Replace Procedure Zl_药品领用_Strike
(
  行次_In       In Integer,
  原记录状态_In In 药品收发记录.记录状态%Type,
  No_In         In 药品收发记录.No%Type,
  序号_In       In 药品收发记录.序号%Type,
  药品id_In     In 药品收发记录.药品id%Type,
  冲销数量_In   In 药品收发记录.实际数量%Type,
  填制人_In     In 药品收发记录.填制人%Type,
  填制日期_In   In 药品收发记录.填制日期%Type,
  冲销方式_In   In Integer := 0 --0－正常冲销方式；1－产生冲销申请单据；2－审核已产生的冲销申请单据  
) Is
  Err_Isstriked Exception;
  Err_Isoutstock Exception;
  Err_Isnonum Exception;
  Err_Isbatch Exception;
  v_Druginf Varchar2(50); --原不分批现在分批的药品信息 

  v_库房id       药品收发记录.库房id%Type;
  v_对方部门id   药品收发记录.对方部门id%Type;
  v_入出类别id   药品收发记录.入出类别id%Type;
  v_产地         药品收发记录.产地%Type;
  v_批次         药品收发记录.批次%Type;
  v_批号         药品收发记录.批号%Type;
  v_效期         药品收发记录.效期%Type;
  v_成本价       药品收发记录.成本价%Type;
  v_成本金额     药品收发记录.成本金额%Type;
  v_扣率         药品收发记录.扣率%Type;
  v_零售价       药品收发记录.零售价%Type;
  v_零售金额     药品收发记录.零售金额%Type;
  v_差价         药品收发记录.差价%Type;
  v_摘要         药品收发记录.摘要%Type;
  v_剩余数量     药品收发记录.实际数量%Type;
  v_剩余成本金额 药品收发记录.成本金额%Type;
  v_剩余零售金额 药品收发记录.零售金额%Type;
  v_入出系数     药品收发记录.入出系数%Type;

  v_收发id   药品收发记录.Id%Type;
  v_领用人   药品收发记录.领用人%Type;
  v_批准文号 药品收发记录.批准文号%Type;
  v_发药方式 药品收发记录.发药方式%Type;

  v_是否变价     收费项目目录.是否变价%Type;
  Intdigit       Number;
  n_上次供应商id 药品库存.上次供应商id%Type;
  d_上次生产日期 药品库存.上次生产日期%Type;
  v_按月留存领用 Varchar2(4000);
Begin
  --获取金额小数位数 
  Select Nvl(精度, 2) Into Intdigit From 药品卫材精度 Where 性质 = 0 And 类别 = 1 And 内容 = 4 And 单位 = 5;
  Select Nvl(是否变价, 0) Into v_是否变价 From 收费项目目录 Where Id = 药品id_In;
  Select Zl_Getsysparameter('按月留存领用', 1305) Into v_按月留存领用 From Dual;

  If 冲销方式_In = 1 Then
    --产生冲销申请单据，不填写审核人、审核日期，不更新库存记录 
    If 行次_In = 1 Then
      Update 药品收发记录
      Set 记录状态 = Decode(原记录状态_In, 1, 3, 原记录状态_In + 3)
      Where No = No_In And 单据 = 7 And 记录状态 = 原记录状态_In;
      If Sql%Rowcount = 0 Then
        Raise Err_Isstriked;
      End If;
    End If;
  
    --主要针对原不分批现在分批的药品，不能对其冲销
    Begin
      Select Distinct '(' || i.编码 || ')' || Nvl(n.名称, i.名称) As 药品信息
      Into v_Druginf
      From 药品收发记录 a, 药品规格 b, 收费项目目录 i, 收费项目别名 n
      Where a.药品id = b.药品id And a.药品id = i.Id And a.药品id = n.收费细目id(+) And n.性质(+) = 3 And a.No = No_In And a.单据 = 7 And
            Mod(a.记录状态, 3) = 0 And Nvl(a.批次, 0) = 0 And a.药品id + 0 = 药品id_In And
            ((Nvl(b.药库分批, 0) = 1 And
            a.库房id Not In (Select 部门id From 部门性质说明 Where (工作性质 Like '%药房') Or (工作性质 Like '制剂室'))) Or
            Nvl(b.药房分批, 0) = 1) And Rownum = 1;
    Exception
      When Others Then
        v_Druginf := '';
    End;
  
    If v_Druginf Is Not Null Then
      Raise Err_Isbatch;
    End If;
  
    Select Sum(实际数量) As 剩余数量, Sum(成本金额) As 剩余成本金额, Sum(零售金额) As 剩余零售金额, 库房id, 对方部门id, 入出类别id, 入出系数, 批次, 产地, 批号, 效期, 成本价,
           扣率, 零售价, 摘要, 领用人, 批准文号, 发药方式, 供药单位id, 生产日期
    Into v_剩余数量, v_剩余成本金额, v_剩余零售金额, v_库房id, v_对方部门id, v_入出类别id, v_入出系数, v_批次, v_产地, v_批号, v_效期, v_成本价, v_扣率, v_零售价,
         v_摘要, v_领用人, v_批准文号, v_发药方式, n_上次供应商id, d_上次生产日期
    From 药品收发记录
    Where No = No_In And 单据 = 7 And 药品id = 药品id_In And 序号 = 序号_In
    Group By 库房id, 对方部门id, 入出类别id, 入出系数, 批次, 产地, 批号, 效期, 成本价, 扣率, 零售价, 摘要, 领用人, 批准文号, 发药方式, 供药单位id, 生产日期;
  
    --冲销数量大于剩余数量，不允许 
    If v_剩余数量 < 冲销数量_In Then
      Raise Err_Isnonum;
    End If;
  
    v_成本金额 := Round(冲销数量_In / v_剩余数量 * v_剩余成本金额, Intdigit);
    v_零售金额 := Round(冲销数量_In / v_剩余数量 * v_剩余零售金额, Intdigit);
    v_差价     := v_零售金额 - v_成本金额;
  
    Select 药品收发记录_Id.Nextval Into v_收发id From Dual;
  
    Insert Into 药品收发记录
      (Id, 记录状态, 单据, No, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 零售金额, 差价, 摘要,
       填制人, 填制日期, 审核人, 审核日期, 领用人, 批准文号, 发药方式, 供药单位id, 生产日期, 扣率)
    Values
      (v_收发id, Decode(原记录状态_In, 1, 2, 原记录状态_In + 2), 7, No_In, 序号_In, v_库房id, v_对方部门id, v_入出类别id, v_入出系数, 药品id_In, v_批次,
       v_产地, v_批号, v_效期, -冲销数量_In, -冲销数量_In, v_成本价, -v_成本金额, v_零售价, -v_零售金额, -v_差价, v_摘要, 填制人_In, 填制日期_In, Null, Null,
       v_领用人, v_批准文号, v_发药方式, n_上次供应商id, d_上次生产日期, v_扣率);
  
  Elsif 冲销方式_In = 2 Then
    --审核已产生的冲销申请单据，填写审核人、审核日期，更新库存记录 
  
    --填写审核人、审核日期 
    Update 药品收发记录
    Set 审核人 = 填制人_In, 审核日期 = 填制日期_In
    Where 单据 = 7 And No = No_In And 序号 = 序号_In And 记录状态 = 原记录状态_In;
  
    --查询当前行记录的对应ID
    Select Id
    Into v_收发id
    From 药品收发记录
    Where 单据 = 7 And No = No_In And 序号 = 序号_In And 记录状态 = 原记录状态_In;
  
    --更新库存信息 领用冲销相当于入库 
    Zl_药品库存_Update(v_收发id, 3, 0);
  
    --科室药品留存处理 
    If v_发药方式 = 1 Then
      Update 药品留存
      Set 可用数量 = Nvl(可用数量, 0) + 冲销数量_In, 实际数量 = Nvl(实际数量, 0) + 冲销数量_In, 实际金额 = Nvl(实际金额, 0) + v_零售金额
      Where 期间 = To_Char(Sysdate, Decode(v_按月留存领用, '1', 'yyyymm', 'yyyy')) And 科室id = v_对方部门id And 库房id = v_库房id And
            药品id = 药品id_In;
      --将金额和数量等于0的记录删除掉 
      Delete From 药品留存 Where Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0;
    End If;
  
    --处理调价后冲销 
    Zl_药品收发记录_调价修正(v_收发id);
  Else
    --正常冲销方式，产生冲销记录，填写审核人、审核日期，更新库存记录      
    If 行次_In = 1 Then
      Update 药品收发记录
      Set 记录状态 = Decode(原记录状态_In, 1, 3, 原记录状态_In + 3)
      Where No = No_In And 单据 = 7 And 记录状态 = 原记录状态_In;
      If Sql%Rowcount = 0 Then
        Raise Err_Isstriked;
      End If;
    End If;
  
    --主要针对原不分批现在分批的药品，不能对其冲销
    Begin
      Select Distinct '(' || i.编码 || ')' || Nvl(n.名称, i.名称) As 药品信息
      Into v_Druginf
      From 药品收发记录 a, 药品规格 b, 收费项目目录 i, 收费项目别名 n
      Where a.药品id = b.药品id And a.药品id = i.Id And a.药品id = n.收费细目id(+) And n.性质(+) = 3 And a.No = No_In And a.单据 = 7 And
            Mod(a.记录状态, 3) = 0 And Nvl(a.批次, 0) = 0 And a.药品id + 0 = 药品id_In And
            ((Nvl(b.药库分批, 0) = 1 And
            a.库房id Not In (Select 部门id From 部门性质说明 Where (工作性质 Like '%药房') Or (工作性质 Like '制剂室'))) Or
            Nvl(b.药房分批, 0) = 1) And Rownum = 1;
    Exception
      When Others Then
        v_Druginf := '';
    End;
  
    If v_Druginf Is Not Null Then
      Raise Err_Isbatch;
    End If;
  
    Select Sum(实际数量) As 剩余数量, Sum(成本金额) As 剩余成本金额, Sum(零售金额) As 剩余零售金额, 库房id, 对方部门id, 入出类别id, 入出系数, 批次, 产地, 批号, 效期, 成本价,
           扣率, 零售价, 摘要, 领用人, 批准文号, 发药方式, 供药单位id, 生产日期
    Into v_剩余数量, v_剩余成本金额, v_剩余零售金额, v_库房id, v_对方部门id, v_入出类别id, v_入出系数, v_批次, v_产地, v_批号, v_效期, v_成本价, v_扣率, v_零售价,
         v_摘要, v_领用人, v_批准文号, v_发药方式, n_上次供应商id, d_上次生产日期
    From 药品收发记录
    Where No = No_In And 单据 = 7 And 药品id = 药品id_In And 序号 = 序号_In
    Group By 库房id, 对方部门id, 入出类别id, 入出系数, 批次, 产地, 批号, 效期, 成本价, 扣率, 零售价, 摘要, 领用人, 批准文号, 发药方式, 供药单位id, 生产日期;
  
    --冲销数量大于剩余数量，不允许 
    If v_剩余数量 < 冲销数量_In Then
      Raise Err_Isnonum;
    End If;
  
    v_成本金额 := Round(冲销数量_In / v_剩余数量 * v_剩余成本金额, Intdigit);
    v_零售金额 := Round(冲销数量_In / v_剩余数量 * v_剩余零售金额, Intdigit);
    v_差价     := v_零售金额 - v_成本金额;
  
    Select 药品收发记录_Id.Nextval Into v_收发id From Dual;
    Insert Into 药品收发记录
      (Id, 记录状态, 单据, No, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 零售金额, 差价, 摘要,
       填制人, 填制日期, 审核人, 审核日期, 领用人, 批准文号, 发药方式, 供药单位id, 生产日期, 扣率)
    Values
      (v_收发id, Decode(原记录状态_In, 1, 2, 原记录状态_In + 2), 7, No_In, 序号_In, v_库房id, v_对方部门id, v_入出类别id, v_入出系数, 药品id_In, v_批次,
       v_产地, v_批号, v_效期, -冲销数量_In, -冲销数量_In, v_成本价, -v_成本金额, v_零售价, -v_零售金额, -v_差价, v_摘要, 填制人_In, 填制日期_In, 填制人_In,
       填制日期_In, v_领用人, v_批准文号, v_发药方式, n_上次供应商id, d_上次生产日期, v_扣率);
  
    --更新库存信息 领用冲销相当于入库 
    Zl_药品库存_Update(v_收发id, 3, 0);
  
    --科室药品留存处理 
    If v_发药方式 = 1 Then
      Update 药品留存
      Set 可用数量 = Nvl(可用数量, 0) + 冲销数量_In, 实际数量 = Nvl(实际数量, 0) + 冲销数量_In, 实际金额 = Nvl(实际金额, 0) + v_零售金额
      Where 期间 = To_Char(Sysdate, Decode(v_按月留存领用, '1', 'yyyymm', 'yyyy')) And 科室id = v_对方部门id And 库房id = v_库房id And
            药品id = 药品id_In;
      --将金额和数量等于0的记录删除掉 
      Delete From 药品留存 Where Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0;
    End If;
  
    --处理调价后冲销 
    Zl_药品收发记录_调价修正(v_收发id);
  End If;
Exception
  When Err_Isstriked Then
    Raise_Application_Error(-20101, '[ZLSOFT]该单据已经被他人冲销！[ZLSOFT]');
  When Err_Isbatch Then
    Raise_Application_Error(-20102,
                            '[ZLSOFT]该单据中包含有一条原来不分批，现在分批的药品[' || v_Druginf || ']，不能冲销！[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_药品领用_Strike;
/

--111248:殷瑞,2017-07-11,修正删除申请冲销单据时的数据错误
--108933:殷瑞,2017-06-30,药品领用模块新增申请冲销、审核冲销功能
Create Or Replace Procedure Zl_药品领用_Delete
(
  No_In       In 药品收发记录.No%Type,
  记录状态_In In 药品收发记录.记录状态%Type := 1
  
) Is
  Err_Isverified Exception;
  n_库房id 药品收发记录.库房id%Type;

  Cursor c_药品收发记录 Is
    Select ID, 填写数量, 库房id, 批次, 药品id, 批号, 效期, 产地, 批准文号, 对方部门id, 发药方式
    From 药品收发记录
    Where NO = No_In And 单据 = 7
    Order By 药品id;
  v_按月留存领用 Varchar2(4000);

Begin
  Select zl_GetSysParameter('按月留存领用', 1305) Into v_按月留存领用 From Dual;
  If 记录状态_In = 1 Then
    --通过循环，恢复原来的可用数量
    For v_药品收发记录 In c_药品收发记录 Loop
      Zl_药品库存_Update(v_药品收发记录.Id, 1);
    
      If v_药品收发记录.发药方式 = 1 Then
        Update 药品留存
        Set 可用数量 = Nvl(可用数量, 0) + v_药品收发记录.填写数量
        Where 期间 = To_Char(Sysdate, Decode(v_按月留存领用, '1', 'yyyymm', 'yyyy')) And 科室id = v_药品收发记录.对方部门id And
              库房id = v_药品收发记录.库房id And 药品id = v_药品收发记录.药品id;
      End If;
    End Loop;
  End If;

  Begin
    Select Distinct 库房id
    Into n_库房id
    From 药品收发记录
    Where NO = No_In And 单据 = 7 And 记录状态 = 1 And 审核人 Is Null;
  Exception
    When Others Then
      n_库房id := 0;
  End;
  Delete From 药品收发记录 Where NO = No_In And 单据 = 7 And 记录状态 = 记录状态_In And 审核人 Is Null;

  If Sql%RowCount = 0 Then
    Raise Err_Isverified;
  End If;
  --插入未审药品记录
  Zl_未审药品记录_Update(1, 7, No_In, n_库房id);
Exception
  When Err_Isverified Then
    Raise_Application_Error(-20101, '[ZLSOFT]该单据已经被他人删除或已被人审核！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品领用_Delete;
/

--111342:焦博,2017-07-10,调整公共函数Zl_Third_Getpatiid增加传入参数姓名_IN
--110711:焦博,2017-06-28,增加入参节点身份证号,当病人ID不存在时,用身份证号获取病人ID
Create Or Replace Procedure Zl_Third_Regist
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:HIS挂号
  --入参:Xml_In:
  --<IN>
  --   <CZFS>3</CZFS>    //操作方式
  --   <CZJLID>1</CZJLID>    //出诊记录ID
  --   <HM>号码</HM>    //号码
  --   <HX>号序</HX>     //号序
  --   <JKFS>0</JKFS>  //缴款方式,0-挂号或预约缴款;1-预约不缴款
  --   <YYSJ>2014-10-21 </YYSJ>    //预约日期 YYYY-MM-DD,分时段非序号控制需要传入时间
  --   <JE>金额</JE>     //金额
  --   <JSLIST>
  --     <JS>            //结算信息，挂号非医保结算目前仅支持一个，结构与收费一致
  --       <JSKLB>结算卡类别</JSKLB>    //结算卡类别
  --       <JSKH>支付宝帐号</JSKH>           //结算卡号(支付宝帐号)
  --       <JYSM>交易说明</JYSM>            //说明，固定传支付宝
  --       <JYLSH>流水号</JYLSH>           //流水号，传订单号
  --       <JSFS>结算方式</JSFS>            //结算方式:现金、支票，如果是三方卡,可以传空
  --       <JSJE>结算金额</JSJE>            //结算金额
  --       <ZY>摘要</ZY>                  //摘要
  --       <SFCYJ></SFCYJ>              //是否冲预交，挂号目前不传
  --       <SFXFK></SFXFK>              //是否消费卡,挂号目前不传
  --       <EXPENDLIST>                 //扩展信息
  --         <EXPEND>
  --           <JYMC>交易名称</JYMC>        //交易名称
  --           <JYLR>交易内容<JYLR>         //交易内容
  --         </EXPEND>
  --         <EXPEND>
  --           ...
  --         </EXPEND>
  --       </EXPENDLIST>
  --     </JS>
  --   </JSLIST>
  --   <HZDW>合作单位</HZDW>        //合作单位名称
  --   <YYFS>支付宝<YYFS>    //预约方式,如自助机，支付宝
  --   <BRID>病人ID</BRID>     //病人ID
  --   <SFZH>身份证号</SFZH>     //身份证号
  --   <XM>姓名</XM>            //姓名
  --   <BRLX></BRLX>             //医保病人类型
  --   <FB>普通</FB>               //病人费别，可以不传
  --   <JQM>机器名</JQM>            //机器名
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  -- <GHDH>挂号单号</GHDH>          //挂号单号
  -- <CZSJ>操作时间</CZSJ>          //HIS的登记时间
  -- <JZID>结帐ID</JZID>          //本次结帐ID
  -- <ERROR><MSG>错误信息</MSG></ERROR>  //出错时返回
  --</ OUTPUT>
  --------------------------------------------------------------------------------------------------
  v_号码     挂号安排.号码%Type;
  d_发生时间 Date;
  d_原始时间 Date;
  d_登记时间 Date;
  v_金额     Varchar2(200);

  n_应收金额   门诊费用记录.应收金额%Type;
  v_流水号     病人预交记录.交易流水号%Type;
  v_说明       门诊费用记录.摘要%Type;
  n_病人id     病人信息.病人id%Type;
  v_身份证号   病人信息.身份证号%Type;
  v_预约方式   预约方式.名称%Type;
  v_卡类别名称 医疗卡类别.名称%Type;
  v_结算卡号   病人预交记录.卡号%Type;
  n_门诊号     门诊费用记录.标识号%Type;
  v_姓名       门诊费用记录.姓名%Type;
  v_性别       门诊费用记录.性别%Type;
  v_年龄       门诊费用记录.年龄%Type;
  v_付款方式   门诊费用记录.付款方式%Type;
  v_费别       门诊费用记录.费别%Type;
  v_No         病人挂号记录.No%Type;
  v_结算方式   医疗卡类别.结算方式%Type;
  v_收费类别   门诊费用记录.收费类别%Type;
  n_收费细目id 门诊费用记录.收费细目id%Type;
  n_标准单价   门诊费用记录.标准单价%Type;
  n_收入项目id 门诊费用记录.收入项目id%Type;
  n_屏蔽费别   收费项目目录.屏蔽费别%Type;
  v_收据费目   门诊费用记录.收据费目%Type;
  n_病人科室id 门诊费用记录.病人科室id%Type;
  n_开单部门id 门诊费用记录.开单部门id%Type;
  v_操作员编号 门诊费用记录.操作员编号%Type;
  v_操作员姓名 门诊费用记录.操作员姓名%Type;
  v_医生姓名   挂号安排.医生姓名%Type;
  n_医生id     挂号安排.医生id%Type;
  n_结帐id     门诊费用记录.结帐id%Type;
  n_卡类别id   医疗卡类别.Id%Type;
  v_排班       挂号安排.周日%Type;
  n_安排id     挂号安排.Id%Type;
  n_计划id     挂号安排计划.Id%Type;
  n_预交id     病人预交记录.Id%Type;
  n_序号控制   挂号安排.序号控制%Type;
  n_号序       挂号序号状态.序号%Type;
  v_星期       挂号安排限制.限制项目%Type;
  v_病人类型   病人信息.病人类型%Type;
  n_存在       Number(3);
  v_现金       结算方式.名称%Type;
  n_分时段     Number(3);
  v_结算内容   Varchar2(3000);
  v_合作单位   病人挂号记录.合作单位%Type;
  v_机器名     挂号序号状态.机器名%Type;
  n_缴款方式   Number(3);
  n_挂号模式   Number(3);
  n_普通结算   Number(3);
  n_Exists     Number(3);
  v_保险结算   Varchar2(1000);
  n_记录id     临床出诊记录.Id%Type;
  v_Temp       Varchar2(32767); --临时XML
  x_Templet    Xmltype; --模板XML
  v_Err_Msg    Varchar2(200);
  d_启用时间   Date;
  v_Para       Varchar2(2000);
  Err_Item Exception;
  Err_Special Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/HM'), Extractvalue(Value(A), 'IN/HX'),
         To_Date(Extractvalue(Value(A), 'IN/YYSJ'), 'YYYY-MM-DD hh24:mi:ss'), Extractvalue(Value(A), 'IN/JE'),
         Extractvalue(Value(A), 'IN/YYFS'), Extractvalue(Value(A), 'IN/HZDW'), Extractvalue(Value(A), 'IN/BRID'),
         Extractvalue(Value(A), 'IN/BRLX'), Extractvalue(Value(A), 'IN/FB'), Extractvalue(Value(A), 'IN/JQM'),
         Extractvalue(Value(A), 'IN/JKFS'), Extractvalue(Value(A), 'IN/CZJLID'), Extractvalue(Value(A), 'IN/SFZH'),
		 Extractvalue(Value(A), 'IN/XM')
  Into v_号码, n_号序, d_原始时间, n_应收金额, v_预约方式, v_合作单位, n_病人id, v_病人类型, v_费别, v_机器名, n_缴款方式, n_记录id, v_身份证号,v_姓名
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  If Nvl(n_病人id, 0) = 0 And Not v_身份证号 Is Null And Not v_姓名 Is Null Then
    n_病人id := Zl_Third_Getpatiid(v_身份证号,v_姓名);
  End If;
  If Nvl(n_病人id, 0) = 0 Then
    v_Err_Msg := '无法确定病人信息,请检查!';
    Raise Err_Item;
  End If;

  v_Para     := zl_GetSysParameter(256);
  n_挂号模式 := Substr(v_Para, 1, 1);
  Begin
    d_启用时间 := To_Date(Substr(v_Para, 3), 'yyyy-mm-dd hh24:mi:ss');
  Exception
    When Others Then
      d_启用时间 := Null;
  End;

  If Sysdate - 10 > Nvl(d_启用时间, Sysdate - 30) Then
    If n_挂号模式 = 1 And Nvl(d_原始时间, Sysdate) > Nvl(d_启用时间, Sysdate - 30) And n_记录id Is Null Then
      v_Err_Msg := '系统当前处于出诊表排班模式，传入的参数无法确定挂号安排，请重试！';
      Raise Err_Item;
    End If;
  Else
    If n_挂号模式 = 1 And Nvl(d_原始时间, Sysdate) > Nvl(d_启用时间, Sysdate - 30) And n_记录id Is Null Then
      Begin
        Select a.Id
        Into n_记录id
        From 临床出诊记录 A, 临床出诊号源 B
        Where a.号源id = b.Id And b.号码 = v_号码 And Nvl(d_原始时间, Sysdate) Between a.开始时间 And a.终止时间;
      Exception
        When Others Then
          v_Err_Msg := '系统当前处于出诊表排班模式，传入的参数无法确定挂号安排，请重试！';
          Raise Err_Item;
      End;
    End If;
  End If;

  d_登记时间 := Sysdate;
  d_发生时间 := Trunc(d_原始时间);

  Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  Select 病人预交记录_Id.Nextval Into n_预交id From Dual;

  For c_交易记录 In (Select Extractvalue(b.Column_Value, '/JS/JSKLB') As 结算卡类别,
                        Extractvalue(b.Column_Value, '/JS/JYLSH') As 交易流水号,
                        Extractvalue(b.Column_Value, '/JS/JSKH') As 结算卡号, Extractvalue(b.Column_Value, '/JS/ZY') As 摘要
                 From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B) Loop
    Begin
      n_卡类别id := To_Number(c_交易记录.结算卡类别);
    Exception
      When Others Then
        Select ID Into n_卡类别id From 医疗卡类别 Where 名称 = c_交易记录.结算卡类别;
    End;
    If Zl_Fun_三方交易记录_Locked(n_卡类别id, c_交易记录.交易流水号, c_交易记录.结算卡号, c_交易记录.摘要,n_结帐id) = 0 Then
      v_Err_Msg := '交易流水号为:' || c_交易记录.交易流水号 || '的交易正在进行中，不允许再次提交此交易!';
      Raise Err_Special;
    End If;
  End Loop;
  
  If v_病人类型 Is Not Null Then
    Begin
      Select 1 Into n_存在 From 病人类型 Where 名称 = v_病人类型;
    Exception
      When Others Then
        v_Err_Msg := '没有发现为(' || v_病人类型 || ')的病人类型';
        Raise Err_Item;
    End;
    Update 病人信息 Set 病人类型 = Nvl(病人类型, v_病人类型) Where 病人id = n_病人id;
  End If;

  Select a.门诊号, a.姓名, a.性别, a.年龄, Nvl(b.编码, c.编码)
  Into n_门诊号, v_姓名, v_性别, v_年龄, v_付款方式
  From 病人信息 A, 医疗付款方式 B, (Select 编码 From 医疗付款方式 Where 缺省标志 = '1' And Rownum < 2) C
  Where a.病人id = n_病人id And a.医疗付款方式 = b.名称(+);
  v_No   := Nextno(12);
  v_Temp := Zl_Identity(1);
  Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_Temp From Dual;
  Select Substr(v_Temp, 0, Instr(v_Temp, ',') - 1) Into v_操作员编号 From Dual;
  Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_操作员姓名 From Dual;
  v_Temp := Zl_Identity(2);
  Select Substr(v_Temp, 0, Instr(v_Temp, ',') - 1) Into n_开单部门id From Dual;

  If n_记录id Is Null Then
    n_普通结算 := 0;
    For r_结算 In (Select Extractvalue(b.Column_Value, '/JS/JSKLB') As 结算卡类别,
                        Extractvalue(b.Column_Value, '/JS/JSKH') As 结算卡号,
                        Extractvalue(b.Column_Value, '/JS/JSFS') As 结算方式,
                        Extractvalue(b.Column_Value, '/JS/JYLSH') As 交易流水号,
                        Extractvalue(b.Column_Value, '/JS/JYSM') As 交易说明,
                        Extractvalue(b.Column_Value, '/JS/JSJE') As 结算金额
                 From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B) Loop
      If r_结算.结算方式 Is Null Then
        Begin
          Select b.结算方式, b.Id
          Into v_结算方式, n_卡类别id
          From 医疗卡类别 B
          Where b.名称 = r_结算.结算卡类别 And Rownum < 2;
        Exception
          When Others Then
            v_Err_Msg := '没有发现该结算卡的相关信息';
            Raise Err_Item;
        End;
      Else
        Select Nvl(Max(1), 0) Into n_Exists From 结算方式 Where 名称 = r_结算.结算方式 And 性质 In (3, 4);
        If n_Exists = 1 Then
          v_保险结算 := v_保险结算 || '||' || r_结算.结算方式 || '|' || r_结算.结算金额;
        Else
          If v_结算方式 Is Null Then
            v_结算方式 := r_结算.结算方式;
          Else
            v_Err_Msg := '目前计划排班挂号不支持非医保外的多种结算方式,请检查!';
            Raise Err_Item;
          End If;
        End If;
      End If;
      If r_结算.结算卡类别 Is Not Null Then
        v_卡类别名称 := r_结算.结算卡类别;
        v_结算卡号   := r_结算.结算卡号;
        v_流水号     := r_结算.交易流水号;
        v_说明       := r_结算.交易说明;
        If n_卡类别id Is Null Then
          Begin
            Select b.Id Into n_卡类别id From 医疗卡类别 B Where b.名称 = r_结算.结算卡类别 And Rownum < 2;
          Exception
            When Others Then
              v_Err_Msg := '没有发现该结算卡的相关信息';
              Raise Err_Item;
          End;
        End If;
      End If;
    End Loop;
    If v_保险结算 Is Not Null Then
      v_保险结算 := Substr(v_保险结算, 3);
    End If;
  
    Select Decode(To_Char(d_原始时间, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六',
                   Null)
    Into v_星期
    From Dual;
    Begin
      Select ID
      Into n_计划id
      From (Select ID
             From 挂号安排计划
             Where 号码 = v_号码 And d_原始时间 Between Nvl(生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                   Nvl(失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And 审核时间 Is Not Null
             Order By 生效时间 Desc)
      Where Rownum < 2;
    Exception
      When Others Then
        Select ID Into n_安排id From 挂号安排 Where 号码 = v_号码;
    End;
    If Nvl(n_计划id, 0) <> 0 Then
      --从计划读取信息
      Select a.项目id, b.科室id, a.医生姓名, a.医生id,
             Decode(To_Char(d_发生时间, 'D'), '1', a.周日, '2', a.周一, '3', a.周二, '4', a.周三, '5', a.周四, '6', a.周五, '7', a.周六,
                     Null), Nvl(a.序号控制, 0)
      Into n_收费细目id, n_病人科室id, v_医生姓名, n_医生id, v_排班, n_序号控制
      From 挂号安排计划 A, 挂号安排 B
      Where a.Id = n_计划id And b.Id = a.安排id;
      Select Count(Rownum) Into n_分时段 From 挂号计划时段 Where 星期 = v_星期 And 计划id = n_计划id And Rownum < 2;
      --合作单位检查
      If v_合作单位 Is Not Null Then
        Begin
          Select 1 Into n_存在 From 合作单位计划控制 Where 计划id = n_计划id And 数量 = 0 And 合作单位 = v_合作单位;
        Exception
          When Others Then
            n_存在 := 0;
        End;
      End If;
      If n_存在 = 1 Then
        v_Err_Msg := '传入的合作单位在此号码上被禁用！';
        Raise Err_Item;
      End If;
      If n_分时段 = 1 And n_序号控制 = 0 Then
        d_发生时间 := d_原始时间;
        Select 序号
        Into n_号序
        From 挂号计划时段
        Where 计划id = n_计划id And 星期 = v_星期 And To_Char(开始时间, 'hh24:mi:ss') = To_Char(d_发生时间, 'hh24:mi:ss');
      Else
        Begin
          Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || '' || To_Char(开始时间, 'hh24:mi:ss'), 'YYYY-MM-DD hh24:mi:ss')
          Into d_发生时间
          From 挂号计划时段
          Where 计划id = n_计划id And 星期 = v_星期 And 序号 = Nvl(n_号序, 0);
        Exception
          When Others Then
            If n_分时段 = 1 And n_序号控制 = 1 Then
              Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || '' || To_Char(Max(结束时间), 'hh24:mi:ss'),
                              'YYYY-MM-DD hh24:mi:ss')
              Into d_发生时间
              From 挂号计划时段
              Where 计划id = n_计划id And 星期 = v_星期;
            Else
              Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || '' || To_Char(开始时间, 'hh24:mi:ss'), 'YYYY-MM-DD hh24:mi:ss')
              Into d_发生时间
              From 时间段
              Where 时间段 = v_排班;
            End If;
            If d_发生时间 < d_登记时间 Then
              d_发生时间 := d_登记时间;
            End If;
        End;
      End If;
    Else
      --从安排读取信息
      Select b.项目id, b.科室id, b.医生姓名, b.医生id,
             Decode(To_Char(d_发生时间, 'D'), '1', b.周日, '2', b.周一, '3', b.周二, '4', b.周三, '5', b.周四, '6', b.周五, '7', b.周六,
                     Null), Nvl(b.序号控制, 0)
      Into n_收费细目id, n_病人科室id, v_医生姓名, n_医生id, v_排班, n_序号控制
      From 挂号安排 B
      Where b.Id = n_安排id;
      Select Count(Rownum) Into n_分时段 From 挂号安排时段 Where 星期 = v_星期 And 安排id = n_安排id And Rownum < 2;
      --合作单位检查
      If v_合作单位 Is Not Null Then
        Begin
          Select 1 Into n_存在 From 合作单位安排控制 Where 安排id = n_安排id And 数量 = 0 And 合作单位 = v_合作单位;
        Exception
          When Others Then
            n_存在 := 0;
        End;
      End If;
      If n_存在 = 1 Then
        v_Err_Msg := '传入的合作单位在此号码上被禁用！';
        Raise Err_Item;
      End If;
      If n_分时段 = 1 And n_序号控制 = 0 Then
        d_发生时间 := d_原始时间;
        Select 序号
        Into n_号序
        From 挂号安排时段
        Where 安排id = n_安排id And 星期 = v_星期 And To_Char(开始时间, 'hh24:mi:ss') = To_Char(d_发生时间, 'hh24:mi:ss');
      Else
        Begin
          Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || '' || To_Char(开始时间, 'hh24:mi:ss'), 'YYYY-MM-DD hh24:mi:ss')
          Into d_发生时间
          From 挂号安排时段
          Where 安排id = n_安排id And 星期 = v_星期 And 序号 = Nvl(n_号序, 0);
        Exception
          When Others Then
            If n_分时段 = 1 And n_序号控制 = 1 Then
              Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || '' || To_Char(Max(结束时间), 'hh24:mi:ss'),
                              'YYYY-MM-DD hh24:mi:ss')
              Into d_发生时间
              From 挂号安排时段
              Where 安排id = n_安排id And 星期 = v_星期;
            Else
              Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || '' || To_Char(开始时间, 'hh24:mi:ss'), 'YYYY-MM-DD hh24:mi:ss')
              Into d_发生时间
              From 时间段
              Where 时间段 = v_排班;
            End If;
            If d_发生时间 < d_登记时间 Then
              d_发生时间 := d_登记时间;
            End If;
        End;
      End If;
    End If;
  
  
    If Trunc(d_发生时间) <> Trunc(Sysdate) Then
      If Nvl(n_缴款方式, 0) = 0 Then
        Zl_三方机构挂号_Insert(3, n_病人id, v_号码, n_号序, v_No, Null, v_结算方式, Null, d_发生时间, d_登记时间, v_合作单位, n_应收金额, Null, Null,
                         v_流水号, v_说明, v_预约方式, n_预交id, n_卡类别id, Null, 1, n_结帐id, 0, Null, Null, v_结算卡号, 1, v_费别, Null,
                         v_机器名, 1);
      Else
        Zl_三方机构挂号_Insert(2, n_病人id, v_号码, n_号序, v_No, Null, v_结算方式, Null, d_发生时间, d_登记时间, v_合作单位, n_应收金额, Null, Null,
                         v_流水号, v_说明, v_预约方式, n_预交id, n_卡类别id, Null, 1, n_结帐id, 0, Null, Null, v_结算卡号, 1, v_费别, Null,
                         v_机器名, 1);
      End If;
    Else
      If Nvl(n_缴款方式, 0) = 0 Then
        Zl_三方机构挂号_Insert(1, n_病人id, v_号码, n_号序, v_No, Null, v_结算方式, Null, d_发生时间, d_登记时间, v_合作单位, n_应收金额, Null, Null,
                         v_流水号, v_说明, v_预约方式, n_预交id, n_卡类别id, Null, 1, n_结帐id, 0, Null, Null, v_结算卡号, 1, v_费别, Null,
                         v_机器名, 1);
      Else
        Zl_三方机构挂号_Insert(2, n_病人id, v_号码, n_号序, v_No, Null, v_结算方式, Null, d_发生时间, d_登记时间, v_合作单位, n_应收金额, Null, Null,
                         v_流水号, v_说明, v_预约方式, n_预交id, n_卡类别id, Null, 1, n_结帐id, 0, Null, Null, v_结算卡号, 1, v_费别, Null,
                         v_机器名, 1);
      End If;
    End If;
  
    For c_扩展信息 In (Select Extractvalue(b.Column_Value, '/EXPEND/JYMC') As 交易名称,
                          Extractvalue(b.Column_Value, '/EXPEND/JYLR') As 交易内容
                   From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS/EXPENDLIST/EXPEND'))) B) Loop
      Zl_三方结算交易_Insert(n_卡类别id, 0, v_结算卡号, n_结帐id, c_扩展信息.交易名称 || '|' || c_扩展信息.交易内容, 0);
    End Loop;
  
    v_Temp := '<GHDH>' || v_No || '</GHDH>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    v_Temp := '<CZSJ>' || To_Char(d_登记时间, 'YYYY-MM-DD hh24:mi:ss') || '</CZSJ>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    v_Temp := '<JZID>' || n_结帐id || '</JZID>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Else
    --出诊表排班模式
    For r_结算 In (Select Extractvalue(b.Column_Value, '/JS/JSKLB') As 结算卡类别,
                        Extractvalue(b.Column_Value, '/JS/JSKH') As 结算卡号,
                        Extractvalue(b.Column_Value, '/JS/JSFS') As 结算方式,
                        Extractvalue(b.Column_Value, '/JS/JYLSH') As 交易流水号,
                        Extractvalue(b.Column_Value, '/JS/JYSM') As 交易说明,
                        Extractvalue(b.Column_Value, '/JS/JSJE') As 结算金额
                 From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B) Loop
      If r_结算.结算方式 Is Null Then
        Begin
          Select b.结算方式, b.Id
          Into v_结算方式, n_卡类别id
          From 医疗卡类别 B
          Where b.名称 = r_结算.结算卡类别 And Rownum < 2;
        Exception
          When Others Then
            v_Err_Msg := '没有发现该结算卡的相关信息';
            Raise Err_Item;
        End;
        v_结算内容 := v_结算内容 || '|' || v_结算方式 || ',' || r_结算.结算金额 || ',,';
      Else
        v_结算内容 := v_结算内容 || '|' || r_结算.结算方式 || ',' || r_结算.结算金额 || ',,';
      End If;
      If r_结算.结算卡类别 Is Not Null Then
        v_结算内容   := v_结算内容 || '1';
        v_卡类别名称 := r_结算.结算卡类别;
        v_结算卡号   := r_结算.结算卡号;
        v_流水号     := r_结算.交易流水号;
        v_说明       := r_结算.交易说明;
        If n_卡类别id Is Null Then
          Begin
            Select b.Id Into n_卡类别id From 医疗卡类别 B Where b.名称 = r_结算.结算卡类别 And Rownum < 2;
          Exception
            When Others Then
              v_Err_Msg := '没有发现该结算卡的相关信息';
              Raise Err_Item;
          End;
        End If;
      Else
        v_结算内容 := v_结算内容 || '0';
      End If;
    End Loop;
    If v_结算内容 Is Not Null Then
      v_结算内容 := Substr(v_结算内容, 2);
    Else
      Begin
        Select 名称 Into v_现金 From 结算方式 Where 性质 = 1;
      Exception
        When Others Then
          v_现金 := '现金';
      End;
      v_结算内容 := v_现金 || ',' || 0 || ',,0';
    End If;
    Select 项目id, 科室id, 医生姓名, 医生id, 是否序号控制, 是否分时段
    Into n_收费细目id, n_病人科室id, v_医生姓名, n_医生id, n_序号控制, n_分时段
    From 临床出诊记录
    Where ID = n_记录id;
  
    Begin
      Select 开始时间 Into d_发生时间 From 临床出诊序号控制 Where 记录id = n_记录id And 序号 = n_号序;
    Exception
      When Others Then
        d_发生时间 := d_原始时间;
    End;
  
    Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
    Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
  
    If Trunc(d_发生时间) <> Trunc(Sysdate) Then
      If Nvl(n_缴款方式, 0) = 0 Then
        Zl_三方机构挂号_Insert(3, n_病人id, v_号码, n_号序, v_No, Null, v_结算内容, Null, d_发生时间, d_登记时间, v_合作单位, n_应收金额, Null, Null,
                         v_流水号, v_说明, v_预约方式, n_预交id, n_卡类别id, Null, 1, n_结帐id, 0, v_保险结算, Null, v_结算卡号, 1, v_费别, Null,
                         v_机器名, 1, 0, n_记录id);
      Else
        Zl_三方机构挂号_Insert(2, n_病人id, v_号码, n_号序, v_No, Null, v_结算内容, Null, d_发生时间, d_登记时间, v_合作单位, n_应收金额, Null, Null,
                         v_流水号, v_说明, v_预约方式, n_预交id, n_卡类别id, Null, 1, n_结帐id, 0, v_保险结算, Null, v_结算卡号, 1, v_费别, Null,
                         v_机器名, 1, 0, n_记录id);
      End If;
    Else
      If Nvl(n_缴款方式, 0) = 0 Then
        Zl_三方机构挂号_Insert(1, n_病人id, v_号码, n_号序, v_No, Null, v_结算内容, Null, d_发生时间, d_登记时间, v_合作单位, n_应收金额, Null, Null,
                         v_流水号, v_说明, v_预约方式, n_预交id, n_卡类别id, Null, 1, n_结帐id, 0, v_保险结算, Null, v_结算卡号, 1, v_费别, Null,
                         v_机器名, 1, 0, n_记录id);
      Else
        Zl_三方机构挂号_Insert(2, n_病人id, v_号码, n_号序, v_No, Null, v_结算内容, Null, d_发生时间, d_登记时间, v_合作单位, n_应收金额, Null, Null,
                         v_流水号, v_说明, v_预约方式, n_预交id, n_卡类别id, Null, 1, n_结帐id, 0, v_保险结算, Null, v_结算卡号, 1, v_费别, Null,
                         v_机器名, 1, 0, n_记录id);
      End If;
    End If;
  
    For c_扩展信息 In (Select Extractvalue(b.Column_Value, '/EXPEND/JYMC') As 交易名称,
                          Extractvalue(b.Column_Value, '/EXPEND/JYLR') As 交易内容
                   From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS/EXPENDLIST/EXPEND'))) B) Loop
      Zl_三方结算交易_Insert(n_卡类别id, 0, v_结算卡号, n_结帐id, c_扩展信息.交易名称 || '|' || c_扩展信息.交易内容, 0);
    End Loop;
  
    v_Temp := '<GHDH>' || v_No || '</GHDH>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    v_Temp := '<CZSJ>' || To_Char(d_登记时间, 'YYYY-MM-DD hh24:mi:ss') || '</CZSJ>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    v_Temp := '<JZID>' || n_结帐id || '</JZID>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  End If;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Err_Special Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20105, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Regist;
/

--111342:焦博,2017-07-10,调整公共函数Zl_Third_Getpatiid增加传入参数姓名_IN
--110711:焦博,2017-06-28,增加入参节点身份证号,当病人ID不存在时,用身份证号获取病人ID
Create Or Replace Procedure Zl_Third_Charge_Del
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is

  -------------------------------------------------------------------------------------------------- 
  --功能:三方退费交易 
  --入参:Xml_In: 
  --<IN>
  --    <BRID>病人ID</BRID>
  --    <XM>姓名</XM>
  --    <SFZH>身份证号</SFZH>
  --    <JE></JE> //退款总金额
  --    <JSKLB></JSKLB>     //结算卡类别
  --    <TFZY>退费摘要</TFZY>
  --    <JCFP>1</JCFP>      //检查发票
  --    <FYLIST>
  --        <FY>
  --           <DJH>退款单据号</DJH>
  --           <XH>退款序号(格式:1,2,3..为空代表退剩余数量)</DJH>
  --        <FY>
  --    </FYLIST>
  --    <TKLIST>
  --        <TK>
  --            <TKKLB>退款卡类别</TKKLB>
  --            <TKKH>退款卡号</TKKH>
  --            <TKFS>退款方式</TKFS> //退款方式:现金;支票,如果是三方卡,可以传空
  --            <TKJE>支付金额</TKJE>
  --            <JYLSH>交易流水号</JYLSH>
  --            <TKZY>摘要</TKZY>
  --            <TYJK>退回预交款</TYJK> //允冲预交时,只填JSJE节点:1-冲预交
  --            <SFXFK>是否消费卡</SFXFK>   //(1-是消费卡),消费卡时,传入结算卡类别,结算卡号,结算金额等接点
  --            <EXPENDLIST>  //扩展交易信息
  --                <EXPEND>
  --                    <JYMC>交易名称</JYMC>
  --                    <JYLR>交易内容</JYLR>
  --                </EXPEND>
  --            </EXPENDLIST>
  --        </TK>
  --    </TKLIST>
  --</IN>

  --出参:Xml_Out 
  --  <OUT> 
  --    <CZSJ>操作时间</CZSJ>          //HIS的登记时间
  --    <YJZID>原结帐ID</YJZID>       //原结帐ID
  --    <CXID>冲销ID</CXID>          //冲销ID
  --    DD如无下列错误结点则说明正确执行 
  --    <ERROR> 
  --      <MSG>错误信息</MSG> 
  --    </ERROR> 
  --  </OUT> 
  -------------------------------------------------------------------------------------------------- 
  n_退款总额 门诊费用记录.实收金额%Type;
  n_卡类别id 医疗卡类别.Id%Type;
  v_结算方式 Varchar2(2000);

  n_病人id     门诊费用记录.病人id%Type;
  v_姓名       病人信息.姓名%Type;
  v_身份证号   病人信息.身份证号%Type;
  n_单据病人id 门诊费用记录.病人id%Type;
  v_操作员编码 门诊费用记录.操作员编号%Type;
  v_操作员姓名 门诊费用记录.操作员姓名%Type;
  n_冲销id     门诊费用记录.结帐id%Type;
  n_结帐id     门诊费用记录.结帐id%Type;
  n_结帐金额   门诊费用记录.结帐金额%Type;
  n_误差额     病人预交记录.冲预交%Type;
  n_原结算序号 病人预交记录.结算序号%Type;
  l_挂号单     t_Strlist := t_Strlist();
  v_挂号单     门诊费用记录.No%Type;
  n_检查发票   Number(3);
  n_是否打印   Number(3);
  v_结算卡类别 Varchar2(100);
  v_结帐ids    Varchar2(1000);

  n_消费卡id 消费卡目录.Id%Type;
  v_摘要     门诊费用记录.摘要%Type;
  n_Count    Number(18);

  d_退费时间 病人预交记录.收款时间%Type;

  v_退费结算 Varchar2(2000);
  v_普通结算 Varchar2(4000);
  n_Temp     Number(18);

  v_Temp    Varchar2(32767); --临时XML 
  x_Templet Xmltype; --模板XML 

  v_Err_Msg Varchar2(200);
  Err_Item Exception;
  Procedure Third_Cardbalance_Modfiy
  (
    冲销id_In     病人预交记录.结帐id%Type,
    卡类别_In     Varchar2,
    卡号_In       病人预交记录.卡号%Type,
    退款金额_In   病人预交记录.冲预交%Type,
    交易流水号_In 病人预交记录.交易流水号%Type,
    交易说明_In   病人预交记录.交易说明%Type,
    摘要_In       病人预交记录.摘要%Type,
    Xmlexpned_In  Xmltype
  ) Is
    n_卡类别id 医疗卡类别.Id%Type;
    v_结算方式 病人预交记录.结算方式%Type;
  
  Begin
    v_Err_Msg := Null;
    Begin
      n_卡类别id := To_Number(卡类别_In);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
    If n_卡类别id = 0 Then
      Begin
        Select ID, 结算方式, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_卡类别id, v_结算方式, v_Err_Msg
        From 医疗卡类别
        Where 名称 = 卡类别_In;
      Exception
        When Others Then
          n_卡类别id := -1;
          v_Err_Msg  := 卡类别_In || '不存在!';
      End;
    Else
      Begin
        Select ID, 结算方式, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_卡类别id, v_结算方式, v_Err_Msg
        From 医疗卡类别
        Where ID = n_卡类别id;
      Exception
        When Others Then
          n_卡类别id := -1;
          v_Err_Msg  := '未找到指定的结算支付信息!';
      End;
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
  
    v_退费结算 := v_结算方式 || '|' || 退款金额_In || '|' || ' |' || Nvl(摘要_In, ' ');
    --   2.三方卡退费结算:
    --     ①结算方式_IN:只能传入一个结算方式,但允许包含一些辅助信息,格式为:结算方式|结算金额|结算号码|结算摘要
    --     ②卡类别ID_IN,卡号_IN,交易流水号_IN,交易说明_In:需要传入
    --结算方式|结算金额|结算号码|结算摘要 
    Zl_门诊退费结算_Modify(2, n_病人id, 冲销id_In, v_退费结算, 0, n_卡类别id, 卡号_In, 交易流水号_In, 交易说明_In, 0, 0, 0, 0);
  
    --保存扩展结算信息
    For c_扩展 In (Select Extractvalue(j.Column_Value, '/EXPEND/JYMC') As Jymc,
                        Extractvalue(j.Column_Value, '/EXPEND/JYLR') As Jylr
                 From Table(Xmlsequence(Extract(Xmlexpned_In, '/EXPENDLIST/EXPEND'))) J) Loop
      Zl_三方结算交易_Insert(n_卡类别id, 0, 卡号_In, 冲销id_In, c_扩展.Jymc || '|' || c_扩展.Jylr, 0);
    End Loop;
  End Third_Cardbalance_Modfiy;

  Procedure Square_Cardbalance_Modfiy
  (
    冲销id_In     病人预交记录.结帐id%Type,
    卡类别_In     Varchar2,
    卡号_In       病人预交记录.卡号%Type,
    退款金额_In   病人预交记录.冲预交%Type,
    交易流水号_In 病人预交记录.交易流水号%Type,
    交易说明_In   病人预交记录.交易说明%Type,
    摘要_In       病人预交记录.摘要%Type,
    
    Xmlexpned_In Xmltype
  ) Is
    n_卡类别id 医疗卡类别.Id%Type;
    v_结算方式 病人预交记录.结算方式%Type;
  
  Begin
    v_Err_Msg := Null;
    Begin
      n_卡类别id := To_Number(卡类别_In);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
  
    If n_卡类别id = 0 Then
      Begin
        Select 编号, 结算方式, Decode(Nvl(启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_卡类别id, v_结算方式, v_Err_Msg
        From 卡消费接口目录
        Where 名称 = 卡类别_In;
      Exception
        When Others Then
          v_Err_Msg := '消费:' || 卡类别_In || '不存在!';
      End;
    
    Else
    
      Begin
        Select 编号, 结算方式, Decode(Nvl(启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_卡类别id, v_结算方式, v_Err_Msg
        From 卡消费接口目录
        Where 编号 = 卡类别_In;
      Exception
        When Others Then
          v_Err_Msg := '未找到指定的结算支付信息!';
      End;
    
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
  
    v_退费结算 := v_结算方式 || '|' || 退款金额_In || '|' || ' |' || Nvl(摘要_In, ' ');
    --   4-消费卡结算:
    --     ①结算方式_IN:允许一次刷多张卡,格式为:卡类别ID|卡号|消费卡ID|消费金额||
    --     ②退支票额_In:传入零
    Select ID
    Into n_消费卡id
    From 消费卡目录
    Where 接口编号 = n_卡类别id And 卡号 = 卡号_In And
          序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = n_卡类别id And 卡号 = 卡号_In);
  
    --卡类别ID|卡号|消费卡ID|消费金额||.
    v_退费结算 := n_卡类别id || '|' || 卡号_In || '|' || n_消费卡id || '|' || 退款金额_In;
    Zl_门诊退费结算_Modify(4, n_病人id, 冲销id_In, v_退费结算, 0, Null, 卡号_In, 交易流水号_In, 交易说明_In, 0, 0, 0, 0);
  
    --保存扩展结算信息
    For c_扩展 In (Select Extractvalue(j.Column_Value, '/EXPEND/JYMC') As Jymc,
                        Extractvalue(j.Column_Value, '/EXPEND/JYLR') As Jylr
                 From Table(Xmlsequence(Extract(Xmlexpned_In, '/EXPENDLIST/EXPEND'))) J) Loop
      Zl_三方结算交易_Insert(n_卡类别id, 1, 卡号_In, 冲销id_In, c_扩展.Jymc || '|' || c_扩展.Jylr, 0);
    End Loop;
  End Square_Cardbalance_Modfiy;

Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  --0.获取入参中的病人ID等信息
  Select To_Number(Extractvalue(Value(A), 'IN/BRID')), To_Number(Extractvalue(Value(A), 'IN/JE')),
         Extractvalue(Value(A), 'IN/TFZY'), To_Number(Extractvalue(Value(A), 'IN/JCFP')),
         Extractvalue(Value(A), 'IN/JSKLB'), Extractvalue(Value(A), 'IN/SFZH'), Extractvalue(Value(A), 'IN/XM')
  Into n_病人id, n_退款总额, v_摘要, n_检查发票, v_结算卡类别, v_身份证号, v_姓名
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  If Nvl(n_病人id, 0) = 0 And Not v_身份证号 Is Null And Not v_姓名 Is Null Then
    n_病人id := Zl_Third_Getpatiid(v_身份证号, v_姓名);
  End If;

  If Nvl(n_病人id, 0) = 0 Then
    v_Err_Msg := '无法确定病人信息,请检查!';
    Raise Err_Item;
  End If;

  --人员id,人员编号,人员姓名 
  v_Temp       := Zl_Identity(1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员编码 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员姓名 := v_Temp;
  v_Err_Msg    := Null;
  v_结帐ids    := Null;

  If v_结算卡类别 Is Not Null Then
    Begin
      n_卡类别id := To_Number(v_结算卡类别);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
    If n_卡类别id = 0 Then
      Begin
        Select ID Into n_卡类别id From 医疗卡类别 Where 名称 = v_结算卡类别;
      Exception
        When Others Then
          v_Err_Msg := '无法确认传入的结算卡！';
          Raise Err_Item;
      End;
    End If;
  Else
    n_卡类别id := 0;
  End If;

  If Nvl(n_卡类别id, 0) <> 0 Then
    Select 结算方式 Into v_结算方式 From 医疗卡类别 Where ID = n_卡类别id;
  End If;

  --1.先进行退费

  Select 病人结帐记录_Id.Nextval, Sysdate Into n_冲销id, d_退费时间 From Dual;

  n_Count      := 0;
  n_原结算序号 := 0;
  For c_费用 In (Select Extractvalue(b.Column_Value, '/FY/DJH') As 单据号, Extractvalue(b.Column_Value, '/FY/XH') As 退款序号
               From Table(Xmlsequence(Extract(Xml_In, '/IN/FYLIST/FY'))) B) Loop
    Begin
      Select 结算序号, 结帐id, 病人id
      Into n_Temp, n_结帐id, n_单据病人id
      From 病人预交记录
      Where 结帐id In (Select 结帐id
                     From 门诊费用记录
                     Where NO = c_费用.单据号 And 记录性质 = 1 And Nvl(费用状态, 0) = 0 And 记录状态 In (1, 3) And Rownum < 2) And
            Rownum < 2;
    Exception
      When Others Then
        n_Temp := Null;
    End;
    If Instr(',' || v_结帐ids || ',', ',' || n_结帐id || ',') = 0 Then
      v_结帐ids := v_结帐ids || ',' || n_结帐id;
    End If;
  
    If n_Temp Is Null Then
      v_Err_Msg := '指定的单据号:' || c_费用.单据号 || '未找到,不能退费!';
      Raise Err_Item;
    End If;
    Begin
      Select b.No
      Into v_挂号单
      From 门诊费用记录 A, 病人挂号记录 B
      Where a.No = c_费用.单据号 And a.记录性质 = 1 And Nvl(费用状态, 0) = 0 And a.记录状态 In (1, 3) And a.挂号id = b.Id And Rownum < 2;
    Exception
      When Others Then
        v_挂号单 := Null;
    End;
    If Not v_挂号单 Is Null Then
      l_挂号单.Extend;
      l_挂号单(l_挂号单.Count) := v_挂号单;
    End If;
  
    If Nvl(n_单据病人id, 0) = 0 Then
      Begin
        Select 病人id
        Into n_单据病人id
        From 门诊费用记录
        Where NO = c_费用.单据号 And 记录性质 = 1 And Nvl(费用状态, 0) = 0 And 记录状态 In (1, 3) And Rownum < 2;
      Exception
        When Others Then
          n_单据病人id := 0;
      End;
    End If;
  
    If Nvl(n_病人id, 0) <> Nvl(n_单据病人id, 0) Then
      v_Err_Msg := '本次退费的收费单:' || c_费用.单据号 || '不是当前病人的收费单,不能退费!';
      Raise Err_Item;
    End If;
  
    If n_原结算序号 <> 0 And n_原结算序号 <> n_Temp Then
      v_Err_Msg := '本次退费的单据号不是一次收费结算,不能退费!';
      Raise Err_Item;
    End If;
    n_原结算序号 := n_Temp;
  
    Select Count(*) Into n_Temp From 费用补充记录 Where 收费结帐id = n_结帐id;
    If Nvl(n_Temp, 0) <> 0 Then
      v_Err_Msg := '本次退费的单据号已经进行了保险补充结算,不能退费!';
      Raise Err_Item;
    End If;
  
    If v_结算卡类别 Is Not Null Then
      Select Count(*) Into n_Temp From 病人预交记录 Where 结帐id = n_结帐id And 结算方式 = v_结算方式;
      If Nvl(n_Temp, 0) = 0 Then
        v_Err_Msg := '本次退费的单据不是' || v_结算方式 || '结算的,不能退费!';
        Raise Err_Item;
      End If;
    End If;
  
    If Nvl(n_检查发票, 0) = 1 Then
      Select Max(Decode(a.实际票号, Null, 0, 1))
      Into n_是否打印
      From 门诊费用记录 A
      Where NO = c_费用.单据号 And 记录性质 = 1;
      If Nvl(n_是否打印, 0) = 1 Then
        v_Err_Msg := '本次退费的单据号已开发票,不能退费!';
        Raise Err_Item;
      End If;
    End If;
  
    Zl_门诊收费记录_销帐(c_费用.单据号, v_操作员编码, v_操作员姓名, c_费用.退款序号, d_退费时间, v_摘要, n_冲销id);
    n_Count := n_Count + 1;
  End Loop;
  If n_Count = 0 Then
    v_Err_Msg := '未确定本次需要退费的单据,不能退费!';
    Raise Err_Item;
  End If;

  --2.处理退费的结算信息

  n_结帐金额 := 0;

  --检查总金额是否正确 
  Select Sum(结帐金额) Into n_结帐金额 From 门诊费用记录 Where 结帐id = n_冲销id;

  n_误差额 := -1 * Nvl(n_结帐金额, 0) - Nvl(n_退款总额, 0);
  If Abs(n_误差额) > 1.00 Then
    v_Err_Msg := '单据缴款金额与实际结算的误差太大!';
    Raise Err_Item;
  End If;

  --2.确定支付方式
  n_Count := 0;
  For c_结算方式 In (Select Extractvalue(b.Column_Value, '/TK/TKKLB') As 卡类别, Extractvalue(b.Column_Value, '/TK/TKKH') As 卡号,
                        Extractvalue(b.Column_Value, '/TK/TKFS') As 结算方式,
                        -1 * To_Number(Extractvalue(b.Column_Value, '/TK/TKJE')) As 退款金额,
                        Extractvalue(b.Column_Value, '/TK/JYLSH') As 交易流水号,
                        Extractvalue(b.Column_Value, '/TK/JYSM') As 交易说明, Extractvalue(b.Column_Value, '/TK/TKZY') As 摘要,
                        Extractvalue(b.Column_Value, '/TK/TYJK') As 是否退预交,
                        Extractvalue(b.Column_Value, '/TK/SFXFK') As 是否消费卡,
                        Extract(b.Column_Value, '/TK/EXPENDLIST') As Expend
                 From Table(Xmlsequence(Extract(Xml_In, '/IN/TKLIST/TK'))) B) Loop
  
    --1.退回三方卡
    If c_结算方式.卡类别 Is Not Null And Nvl(c_结算方式.是否消费卡, 0) = 0 Then
      --1.三方卡结算
      Third_Cardbalance_Modfiy(n_冲销id, c_结算方式.卡类别, c_结算方式.卡号, c_结算方式.退款金额, c_结算方式.交易流水号, c_结算方式.交易说明, c_结算方式.摘要,
                               c_结算方式.Expend);
    Elsif c_结算方式.卡类别 Is Not Null And Nvl(c_结算方式.是否消费卡, 0) = 1 Then
      --2.消费卡结算
      Square_Cardbalance_Modfiy(n_冲销id, c_结算方式.卡类别, c_结算方式.卡号, c_结算方式.退款金额, c_结算方式.交易流水号, c_结算方式.交易说明, c_结算方式.摘要,
                                c_结算方式.Expend);
    Elsif Nvl(c_结算方式.是否退预交, 0) = 1 Then
      --3.退预交款
      Zl_门诊退费结算_Modify(4, n_病人id, n_冲销id, Null, c_结算方式.退款金额, Null, Null, Null, Null, 0, 0, 0, 0);
    Else
      --4.普通结算
      If c_结算方式.结算方式 Is Null Then
        v_Err_Msg := '未指定指付方式，不允缴款!';
        Raise Err_Item;
      End If;
      --结算方式|结算金额|结算号码|结算摘要||..
      v_退费结算 := c_结算方式.结算方式 || '|' || c_结算方式.退款金额 || '| |' || Nvl(c_结算方式.摘要, '  ');
      v_普通结算 := Nvl(v_普通结算, '') || '||' || v_退费结算;
    End If;
    n_Count := n_Count + 1;
  End Loop;

  --   0-原样退
  --      原样结算一起全退,所有校对标志都为1,医保调用成功后,调整为2,完成后变成0
  --   1-普通退费方式:
  --     ①结算方式_IN:允许传入多个,格式为:"结算方式|结算金额|结算号码|结算摘要||.." ;也允许传入空.
  --   3-医保结算(如果存在医保的结算,则要先删除原医保结算,后按新传入的更新)
  --     ①结算方式_IN:允许传入多个,格式为:结算方式|结算金额||..
  --     ②退支票额_In:传入零
  If n_Count = 0 Then
    v_Err_Msg := '不能有效确认当前的支付方式!';
    Raise Err_Item;
  End If;

  --5.普通结算及完成结
  If v_普通结算 Is Not Null Then
    v_普通结算 := Substr(v_普通结算, 3);
  End If;
  Zl_门诊退费结算_Modify(1, n_病人id, n_冲销id, v_普通结算, 0, Null, Null, Null, Null, 0, 0, n_误差额, 2);

  If v_结帐ids Is Not Null Then
    v_结帐ids := Substr(v_结帐ids, 2);
  End If;

  If l_挂号单.Count <> 0 Then
    For I In 0 .. l_挂号单.Count Loop
      x_Templet := Xmltype('<IN></IN>');
      v_Temp    := '<GHDH>' || l_挂号单(I) || '</GHDH>';
      Select Appendchildxml(x_Templet, '/IN', Xmltype(v_Temp)) Into x_Templet From Dual;
      Zl_Third_Registdel(x_Templet, Xml_Out);
      v_Temp := '<JSKLB>' || 4 || '</JSKLB>';
      Select Appendchildxml(x_Templet, '/IN', Xmltype(v_Temp)) Into x_Templet From Dual;
      Zl_Third_Registdel(x_Templet, Xml_Out);
      v_Temp := '<GHJE>' || 0 || '</GHJE>';
      Select Appendchildxml(x_Templet, '/IN', Xmltype(v_Temp)) Into x_Templet From Dual;
      Zl_Third_Registdel(x_Templet, Xml_Out);
    End Loop;
  End If;
  v_Temp := '<CZSJ>' || To_Char(d_退费时间, 'YYYY-MM-DD hh24:mi:ss') || '</CZSJ>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  v_Temp := '<YJZID>' || v_结帐ids || '</YJZID>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  v_Temp := '<CXID>' || n_冲销id || '</CXID>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Xml_Out := x_Templet;

Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Charge_Del;
/

--111342:焦博,2017-07-10,调整公共函数Zl_Third_Getpatiid增加传入参数姓名_IN
--110711:焦博,2017-06-28,增加入参节点身份证号,当病人ID不存在时,用身份证号获取病人ID
Create Or Replace Procedure Zl_Third_Buildpatiinfo
(
  Xml_In    In Xmltype,
  Expend_In In Xmltype,
  Xml_Out   Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:挂号数据写入
  --入参:Xml_In:
  --  <IN>
  --    <FB>费别</FB>                      //掌上中联后台中设定
  --    <FKFS>医疗付款方式</FKFS>          //掌上中联后台中设定
  --    <XM>姓名</XM>
  --    <XB>性别</XB>
  --    <NL>年龄</NL>
  --    <CSRQ>出生日期</CSRQ>
  --    <SFZ >身份证号</SFZ>              //必须有
  --    <KLB>医疗卡名称</KLB>             //固定为：手机支付
  --    <SJH>手机号</SJH>                //如果手机号为空，则以身份证号创建就诊卡；否则以手机号创建就诊卡
  --  </IN>
  --      Expend_In:扩展信息,暂不用,主要是适应移动产品的参数统一
  --出参:Xml_Out
  --  <OUTPUT>
  --    <BRID>1</BRID>                   //返回创建好的档案，或原来已有的档案
  --                                     //如无下列错误结点则说明正确执行
  --    <ERROR>
  --      <MSG>错误信息</MSG>
  --    </ERROR>
  --  </OUTPUT>
  --------------------------------------------------------------------------------------------------
  v_费别         病人信息.费别%Type;
  v_付款方式     病人信息.医疗付款方式%Type;
  v_姓名         病人信息.姓名%Type;
  v_性别         病人信息.性别%Type;
  v_年龄         病人信息.年龄%Type;
  d_出生日期     病人信息.出生日期%Type;
  v_身份证号     病人信息.身份证号%Type;
  v_医疗卡名称   医疗卡类别.名称%Type;
  v_卡号         病人医疗卡信息.卡号%Type;
  v_手机号       病人信息.手机号%Type;
  n_卡类别id     医疗卡类别.Id%Type;
  v_结算方式     医疗卡类别.结算方式%Type;
  v_验证姓名     病人信息.姓名%Type;
  n_病人id       病人信息.病人id%Type;
  n_卡病人id     病人信息.病人id%Type;
  v_医疗卡编码   医疗卡类别.编码%Type;
  n_是否缺省密码 医疗卡类别.是否缺省密码%Type;
  v_密码         病人医疗卡信息.密码%Type;
  n_密码长度     医疗卡类别.密码长度%Type;
  v_Temp         Varchar2(32767); --临时XML
  x_Templet      Xmltype; --模板XML
  v_Err_Msg      Varchar2(200);
  n_Exists       Number(2);
  v_Para         Varchar2(20);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/FB'), Extractvalue(Value(A), 'IN/FKFS'), Extractvalue(Value(A), 'IN/XM'),
         Extractvalue(Value(A), 'IN/SFZ'), Extractvalue(Value(A), 'IN/KLB'), Extractvalue(Value(A), 'IN/SJH'),
         Extractvalue(Value(A), 'IN/XB'), Extractvalue(Value(A), 'IN/NL'), To_Date(Extractvalue(Value(A), 'IN/CSRQ'), 'yyyy-mm-dd hh24:mi:ss'),
         Extractvalue(Value(A), 'IN/YLKID'), Extractvalue(Value(A), 'IN/YLKBM')
  Into v_费别, v_付款方式, v_姓名, v_身份证号, v_医疗卡名称, v_手机号, v_性别, v_年龄, d_出生日期, n_卡类别id, v_医疗卡编码
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  v_卡号 := v_手机号;

  --某些入参节点为空的情况
  If Nvl(v_卡号, '_') = '_' Then
    v_卡号 := v_身份证号;
  End If;

  If Nvl(v_性别, '_') = '_' Then
    If Mod(To_Number(Substr(v_身份证号, -2, 1)), 2) = 1 Then
      v_性别 := '男';
    Else
      v_性别 := '女';
    End If;
  End If;

  If d_出生日期 Is Null Then
    If Length(Trim(v_身份证号)) = 15 Then
      d_出生日期 := To_Date('19' || Substr(v_身份证号, 7, 6), 'yyyy-mm-dd');
    End If;
    If Length(Trim(v_身份证号)) = 18 Then
      d_出生日期 := To_Date(Substr(v_身份证号, 7, 8), 'yyyy-mm-dd');
    End If;
  End If;
  If Nvl(v_年龄, '_') = '_' Then
    v_年龄 := Zl_Age_Calc(0, d_出生日期, Sysdate);
  End If;

  --检查医疗卡名称
  If Nvl(n_卡类别id, 0) = 0 Then
    If Nvl(v_医疗卡编码, '_') <> '_' Then
      v_Err_Msg := Null;
      Begin
        Select ID, 结算方式, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行挂号!')
        Into n_卡类别id, v_结算方式, v_Err_Msg
        From 医疗卡类别
        Where 编码 = v_医疗卡编码;
      Exception
        When Others Then
          v_Err_Msg := '医疗卡编码:' || v_医疗卡编码 || '不存在!';
      End;
      If Not v_Err_Msg Is Null Then
        Raise Err_Item;
      End If;
    Elsif Nvl(v_医疗卡名称, '_') <> '_' Then
    
      v_Err_Msg := Null;
      Begin
        Select ID, 结算方式, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行挂号!')
        Into n_卡类别id, v_结算方式, v_Err_Msg
        From 医疗卡类别
        Where 名称 = v_医疗卡名称;
      Exception
        When Others Then
          v_Err_Msg := v_医疗卡名称 || '不存在!';
      End;
      If Not v_Err_Msg Is Null Then
        Raise Err_Item;
      End If;
    Else
      v_Err_Msg := '系统不能识别有效的医疗卡,不允许挂号!';
      Raise Err_Item;
    End If;
  Else
    v_Err_Msg := Null;
    Begin
      Select ID, 结算方式, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行挂号!')
      Into n_卡类别id, v_结算方式, v_Err_Msg
      From 医疗卡类别
      Where ID = n_卡类别id;
    Exception
      When Others Then
        v_Err_Msg := '系统不能识别指定的医疗卡(' || n_卡类别id || ')!';
    End;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
  End If;

  --建档操作
  Select zl_GetSysParameter(279) Into v_Para From Dual;
  If v_Para = '1' Then
    If Not v_身份证号 Is Null And Not v_姓名 Is Null Then
      n_病人id := Zl_Third_Getpatiid(v_身份证号, v_姓名);
      If Nvl(n_病人id, 0) <> 0 Then
        Begin
          Select 1, 姓名 Into n_Exists, v_验证姓名 From 病人信息 Where 病人id = n_病人id;
        Exception
          When Others Then
            n_Exists := 0;
        End;
      End If;
    Else
      n_Exists := 0;
    End If;
  Else
    n_Exists := 0;
  End If;

  If n_Exists >= 1 Then
    If v_姓名 <> v_验证姓名 Then
      v_Err_Msg := '身份证号码与病人姓名不匹配!';
      Raise Err_Item;
    End If;
  Else
    n_病人id := Nextno(1);
    Zl_挂号病人病案_Insert(1, n_病人id, Null, Null, Null, v_姓名, v_性别, v_年龄, v_费别, v_付款方式, Null, Null, Null, Null, v_身份证号, Null,
                     Null, Null, Null, Null, Null, Null, Sysdate, Null, d_出生日期, Null, Null, Null, Null, Null, Null,
                     Null, Null, Null, Null, Null, Null, v_手机号);
  End If;
  v_Temp := '<BRID>' || n_病人id || '</BRID>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Xml_Out := x_Templet;
  --发卡操作
  Begin
    Select 1, 病人id Into n_Exists, n_卡病人id From 病人医疗卡信息 Where 卡类别id = n_卡类别id And 卡号 = v_卡号;
  Exception
    When Others Then
      n_Exists := 0;
  End;
  If n_Exists = 0 Then
    Zl_医疗卡变动_Insert(1, n_病人id, n_卡类别id, Null, v_卡号, '手机建档', Null, Null, Sysdate);
  Else
    If n_病人id <> n_卡病人id Then
      v_Err_Msg := '该卡号已经被其他人绑定!';
      Raise Err_Item;
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Buildpatiinfo;
/

--111342:焦博,2017-07-10,调整公共函数Zl_Third_Getpatiid增加传入参数姓名_IN
--110711:焦博,2017-06-28,增加入参节点身份证号,当病人ID不存在时,用身份证号获取病人ID
Create Or Replace Procedure Zl_Third_Getpati_Unique
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  -------------------------------------------------------------------------------------------------- 
  --功能:获取病人的唯一标识(病人ID) 
  --入参:Xml_In: 
  --   <IN> 
  --     <ZJH>证件号</ZJH>     //卡号 
  --     <ZJLX>证件类型</ZJLX>  //医疗卡类别.名称 
  --     <XM>姓名</XM> 
  --     <KH>卡号</KH> 
  --     <KLB>卡类别</KLB> 
  --    </IN> 
  --出参:Xml_Out 
  -- <OUTPUT> 
  --   <BRID>病人ID</BRID> 
  --   <MZH>门诊号</MZH> 
  --   <ERROR><MSG>错误信息</MSG></ERROR> 
  --  </OUTPUT> 

  -------------------------------------------------------------------------------------------------- 
  v_Err_Msg Varchar2(200);
  Err_Item Exception;

  x_Templet Xmltype; --模板XML 

  v_证件号       Varchar2(50);
  v_证件类型     医疗卡类别.名称%Type;
  v_姓名         Varchar2(100);
  v_验证姓名     Varchar2(100);
  v_卡号         Varchar2(100);
  v_卡类别       Varchar2(100);
  n_存在         Number(3);
  n_卡类别id     病人医疗卡信息.卡类别id%Type;
  v_操作员       人员表.姓名%Type;
  v_验证身份证号 病人信息.身份证号%Type;

  n_病人id     病人信息.病人id%Type;
  n_验证病人id 病人信息.病人id%Type;
  n_门诊号     病人信息.门诊号%Type;

  v_Temp Varchar2(32767); --临时XML 
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/ZJH'), Extractvalue(Value(A), 'IN/ZJLX'), Extractvalue(Value(A), 'IN/XM'),
         Extractvalue(Value(A), 'IN/KH'), Extractvalue(Value(A), 'IN/KLB')
  Into v_证件号, v_证件类型, v_姓名, v_卡号, v_卡类别
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  --先从用户自定义过程获取病人ID 
  n_病人id := Zl_Third_Custom_Getpati(v_卡类别, v_卡号);

  If Nvl(n_病人id, 0) = 0 Then
    If v_证件类型 Like '%身份证%' And v_证件号 Is Not Null And v_姓名 Is Not Null Then
      n_病人id := Zl_Third_Getpatiid(v_证件号,v_姓名);
    Else
      If Nvl(v_卡类别, '-') <> '-' And Nvl(v_卡号, '-') <> '-' Then
	    Select Max(a.病人id)
	    Into n_病人id
	    From 病人医疗卡信息 A
	    Where a.卡类别id = (Select Max(ID) From 医疗卡类别 Where 名称 = v_卡类别 And Nvl(是否启用, 0) = 1) And 卡号 = v_卡号 And
              (a.状态 = 0 Or Nvl(a.状态, 0) = 1 And Exists
               (Select 1 From 医疗卡挂失方式 Where a.挂失方式 = 名称 And a.挂失时间 + 有效天数 < Trunc(Sysdate)));
	  End If;
	End IF;
  
    If Nvl(n_病人id, 0) = 0 Then
      v_Err_Msg := '未找到该登记号的病人信息，请检查输入的登记号是否正确!';
      Raise Err_Item;
    End If;
  
  End If;

  If Nvl(n_病人id, 0) <> 0 Then
    v_Temp := '<BRID>' || n_病人id || '</BRID>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Select 门诊号, 姓名, 身份证号 Into n_门诊号, v_验证姓名, v_验证身份证号 From 病人信息 Where 病人id = n_病人id;
    If v_姓名 <> v_验证姓名 Then
      v_Err_Msg := '传入的病人姓名与已有的病人姓名不符,请检查!';
      Raise Err_Item;
    End If;
    If Not v_证件号 Is Null Then
      If v_证件类型 Like '%身份证%' Then
        If v_证件号 <> v_验证身份证号 Then
          v_Err_Msg := '传入的病人身份证号与已有的病人身份证号不符,请检查!';
          Raise Err_Item;
        End If;
      Else
        Select Max(病人id)
        Into n_验证病人id
        From 病人医疗卡信息 A
        Where 卡类别id = (Select Max(ID) From 医疗卡类别 Where 名称 = v_证件类型 And Nvl(是否启用, 0) = 1) And 卡号 = v_证件号 And
              (a.状态 = 0 Or Nvl(a.状态, 0) = 1 And Exists
               (Select 1 From 医疗卡挂失方式 Where a.挂失方式 = 名称 And a.挂失时间 + 有效天数 < Trunc(Sysdate)));
        If n_验证病人id <> n_病人id Then
          v_Err_Msg := '传入的病人证件类型与已有的病人证件类型不符,请检查!';
          Raise Err_Item;
        End If;
      End If;
    End If;
    If n_门诊号 Is Null Then
      n_门诊号 := Nextno(3);
      Update 病人信息 Set 门诊号 = n_门诊号 Where 病人id = n_病人id;
    End If;
    v_Temp := '<MZH>' || n_门诊号 || '</MZH>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  End If;

  Xml_Out := x_Templet;

Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getpati_Unique;
/

--111342:焦博,2017-07-10,调整公共函数Zl_Third_Getpatiid增加传入参数姓名_IN
--110711:焦博,2017-06-28,增加入参节点身份证号,当病人ID不存在时,用身份证号获取病人ID
Create Or Replace Procedure Zl_Third_Reghistory
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取历史挂号数据
  --入参:Xml_In:
  --<IN>
  --   <BRID>88393</BRID>    //病人ID
  --   <XM>姓名</XM>            //姓名
  --   <SFZH>身份证号</SFZH>    //身份证号
  --   <JLS>5</JLS >       //记录条数，按日期由近到远
  --   <JSKLB></JSKLB>     //结算卡类别
  --   <ZD></ZD>           //站点
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  --   <GHLIST>       //如果为空表示没有找到数据
  --    <GH>
  --     <GHDH>N001</GHDH>   //挂号单号
  --     <KS>门诊外科</KS>     //挂号科室
  --     <KSID>42</KSID>    //科室id
  --     <DJSJ>2014-10-21 14:12:44</DJSJ>    //登记时间
  --     <YYSJ>2014-10-21 14:10</YYSJ>    //预约时间
  --     <ZXZT>1</ZXZT>     //状态(预约中等待付款、已挂号、候诊等)
  --     <DDFK>1</DDFK>     //是否付款
  --     <GHFS>支付宝</GHFS>    //挂号方式(支付宝、自助机、窗口)
  --     <YSXM>LEX</YSXM>    //医生姓名
  --    </GH>
  --   </GHLIST>
  --   <ERROR><MSG>错误信息</MSG></ERROR>     //如果有错误返回
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  v_费别         病人信息.费别%Type;
  v_付款方式     病人信息.医疗付款方式%Type;
  v_姓名         病人信息.姓名%Type;
  v_性别         病人信息.性别%Type;
  v_年龄         病人信息.年龄%Type;
  d_出生日期     病人信息.出生日期%Type;
  v_身份证号     病人信息.身份证号%Type;
  v_卡类别       医疗卡类别.名称%Type;
  v_卡号         病人医疗卡信息.卡号%Type;
  n_卡类别id     医疗卡类别.Id%Type;
  v_结算方式     医疗卡类别.结算方式%Type;
  v_验证姓名     病人信息.姓名%Type;
  n_病人id       病人信息.病人id%Type;
  n_卡病人id     病人信息.病人id%Type;
  v_医疗卡编码   医疗卡类别.编码%Type;
  n_是否缺省密码 医疗卡类别.是否缺省密码%Type;
  v_密码         病人医疗卡信息.密码%Type;
  n_密码长度     医疗卡类别.密码长度%Type;
  n_记录数       Number(4);
  v_结算卡类别   Varchar2(100);
  n_是否付款     Number(3);
  v_Temp         Varchar2(32767); --临时XML
  x_Templet      Xmltype; --模板XML
  v_Err_Msg      Varchar2(200);
  n_Exists       Number(2);
  v_状态         Varchar2(100);
  n_站点         Number(1);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT><GHLIST></GHLIST></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/BRID'), Extractvalue(Value(A), 'IN/JLS'), Extractvalue(Value(A), 'IN/JSKLB'),
         Extractvalue(Value(A), 'IN/ZD'), Extractvalue(Value(A), 'IN/SFZH'), Extractvalue(Value(A), 'IN/XM')
  Into n_病人id, n_记录数, v_结算卡类别, n_站点, v_身份证号, v_姓名
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  If nvl(n_病人id, 0) = 0 And Not v_身份证号 Is Null And Not v_姓名 Is Null Then
    n_病人id := zl_third_GetPatiID(v_身份证号,v_姓名);
  End If;
  If nvl(n_病人id, 0) = 0 Then
    v_Err_Msg := '无法确定病人信息,请检查!';
    Raise Err_Item;
  End If;

  If v_结算卡类别 Is Not Null Then
    Begin
      n_卡类别id := To_Number(v_结算卡类别);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
    If n_卡类别id = 0 Then
      Begin
        Select ID Into n_卡类别id From 医疗卡类别 Where 名称 = v_结算卡类别;
      Exception
        When Others Then
          v_Err_Msg := '无法确认传入的结算卡！';
          Raise Err_Item;
      End;
    End If;
  Else
    n_卡类别id := 0;
  End If;

  n_记录数 := Nvl(n_记录数, 0);

  If Nvl(n_卡类别id, 0) = 0 Then
    For r_Reg In (Select Distinct a.No, a.执行部门id As 科室id, b.名称 As 科室, a.登记时间 As 创建时间, a.发生时间 As 预约时间,
                                  Decode(a.记录性质, 2, '预约中',
                                          Decode(a.执行状态, -1, '不就诊', 0, '等待就诊', 1, '完成就诊', 2, '正在就诊', '已挂号')) As 状态,
                                  Decode(c.记录状态, 0, 0, 1) As 是否付款, a.预约方式 As 挂号方式, a.执行人 As 医生姓名, a.收费单




                  From 病人挂号记录 A, 部门表 B, 门诊费用记录 C
                  Where a.病人id = n_病人id And a.执行部门id = b.Id And c.No = a.No And c.序号 = 1 And c.记录性质 = 4 And a.记录状态 = 1 And
                        (b.站点 = Nvl(n_站点, 0) Or b.站点 Is Null)
                  Order By a.登记时间 Desc) Loop
      If n_记录数 <> 0 Then
        Begin
          Select Decode(记录状态, 0, 0, 1)
          Into n_是否付款
          From 门诊费用记录
          Where 记录性质 = 1 And 病人id = n_病人id And NO = r_Reg.收费单 And Rownum < 2;
        Exception
          When Others Then
            n_是否付款 := r_Reg.是否付款;
        End;
        If n_是否付款 = 0 And r_Reg.状态 = '预约中' And Sysdate > r_Reg.预约时间 Then
          v_状态 := '已失效';
        Else
          v_状态 := r_Reg.状态;
        End If;
        v_Temp := '<GH>' || '<GHDH>' || r_Reg.No || '</GHDH>' || '<KS>' || r_Reg.科室 || '</KS>' || '<KSID>' ||
                  r_Reg.科室id || '</KSID>' || '<DJSJ>' || To_Char(r_Reg.创建时间, 'YYYY-MM-DD hh24:mi:ss') || '</DJSJ>' ||
                  '<YYSJ>' || To_Char(r_Reg.预约时间, 'YYYY-MM-DD hh24:mi:ss') || '</YYSJ>' || '<ZXZT>' || v_状态 ||
                  '</ZXZT>' || '<DDFK>' || n_是否付款 || '</DDFK>' || '<GHFS>' || r_Reg.挂号方式 || '</GHFS>' || '<YSXM>' ||
                  r_Reg.医生姓名 || '</YSXM>' || '</GH>';
        Select Appendchildxml(x_Templet, '/OUTPUT/GHLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
        n_记录数 := n_记录数 - 1;
      End If;
    End Loop;
  Else
    For r_Reg In (Select Distinct a.No, a.执行部门id As 科室id, b.名称 As 科室, a.登记时间 As 创建时间, a.发生时间 As 预约时间,
                                  Decode(a.记录性质, 2, '预约中',
                                          Decode(a.执行状态, -1, '不就诊', 0, '等待就诊', 1, '完成就诊', 2, '正在就诊', '已挂号')) As 状态,
                                  Decode(c.记录状态, 0, 0, 1) As 是否付款, a.预约方式 As 挂号方式, a.执行人 As 医生姓名, a.收费单




                  From 病人挂号记录 A, 部门表 B, 门诊费用记录 C, 病人预交记录 D
                  Where a.病人id = n_病人id And a.执行部门id = b.Id And c.No = a.No And c.序号 = 1 And c.记录性质 = 4 And a.记录状态 = 1 And
                        c.结帐id = d.结帐id And (d.卡类别id = n_卡类别id Or d.卡类别id Is Null) And Not Exists
                   (Select 1
                         From 病人预交记录
                         Where 结帐id = c.结帐id And Nvl(卡类别id, 0) <> 0 And Nvl(卡类别id, 0) <> n_卡类别id) And
                        (b.站点 = Nvl(n_站点, 0) Or b.站点 Is Null)
                  Order By a.登记时间 Desc) Loop
      If n_记录数 <> 0 Then
        Begin
          Select Decode(记录状态, 0, 0, 1)
          Into n_是否付款
          From 门诊费用记录
          Where 记录性质 = 1 And 病人id = n_病人id And NO = r_Reg.收费单 And Rownum < 2;
        Exception
          When Others Then
            n_是否付款 := r_Reg.是否付款;
        End;
        If n_是否付款 = 0 And r_Reg.状态 = '预约中' And Sysdate > r_Reg.预约时间 Then
          v_状态 := '已失效';
        Else
          v_状态 := r_Reg.状态;
        End If;
        v_Temp := '<GH>' || '<GHDH>' || r_Reg.No || '</GHDH>' || '<KS>' || r_Reg.科室 || '</KS>' || '<KSID>' ||
                  r_Reg.科室id || '</KSID>' || '<DJSJ>' || To_Char(r_Reg.创建时间, 'YYYY-MM-DD hh24:mi:ss') || '</DJSJ>' ||
                  '<YYSJ>' || To_Char(r_Reg.预约时间, 'YYYY-MM-DD hh24:mi:ss') || '</YYSJ>' || '<ZXZT>' || v_状态 ||
                  '</ZXZT>' || '<DDFK>' || n_是否付款 || '</DDFK>' || '<GHFS>' || r_Reg.挂号方式 || '</GHFS>' || '<YSXM>' ||
                  r_Reg.医生姓名 || '</YSXM>' || '</GH>';
        Select Appendchildxml(x_Templet, '/OUTPUT/GHLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
        n_记录数 := n_记录数 - 1;
      End If;
    End Loop;
  End If;

  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Reghistory;
/

--111342:焦博,2017-07-10,调整公共函数Zl_Third_Getpatiid增加传入参数姓名_IN
--110711:焦博,2017-06-28,增加入参节点身份证号,当病人ID不存在时,用身份证号获取病人ID
Create Or Replace Procedure Zl_Third_Getalarmline
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is

  -------------------------------------------------------------------------------------------------- 
  --功能:预交款充值 
  --入参:Xml_In: 
  --    <IN>
  --        <BRID>病人ID</BRID>
  --        <XM>姓名</XM> 
  --        <SFZH>身份证号</SFZH>
  --        <ZYID>主页ID</ZYID> //主页ID不传入或为零表示取门诊
  --    </IN>
  --出参:Xml_Out 
  --  <OUTPUT> 
  --     <YJDH>预交单号(多个逗号分隔)</YJDH>
  --    DD如无下列错误结点则说明正确执行 
  --    <ERROR> 
  --      <MSG>错误信息</MSG> 
  --    </ERROR> 
  --  </OUTPUT> 
  -------------------------------------------------------------------------------------------------- 
  n_类型   Number(2);
  v_方案   Varchar2(100);
  n_病人id 病人信息.病人id%Type;
  v_姓名     病人信息.姓名%Type;
  v_身份证号 病人信息.身份证号%Type;
  n_病区id 病人信息.当前病区id%Type;
  n_主页id 病案主页.主页id%Type;

  n_报警值    记帐报警线.报警值%Type;
  n_报警方法  记帐报警线.报警方法%Type;
  v_报警标志1 记帐报警线.报警标志1%Type;
  v_报警标志2 记帐报警线.报警标志2%Type;
  v_报警标志3 记帐报警线.报警标志3%Type;

  n_预交余额   病人余额.预交余额%Type;
  n_费用余额   病人余额.预交余额%Type;
  n_担保额     病人信息.担保额%Type;
  n_Temp       病人余额.预交余额%Type;
  n_险类       病案主页.险类%Type;
  n_医保结算额 保险模拟结算.金额%Type;
  v_Temp       Varchar2(32767); --临时XML 
  x_Templet    Xmltype; --模板XML 

  v_Err_Msg Varchar2(200);
  Err_Item Exception;

Begin

  v_Err_Msg := Null;

  Select Extractvalue(Value(A), 'IN/BRID'), To_Number(Extractvalue(Value(A), 'IN/ZYID')),
  Extractvalue(Value(A), 'IN/SFZH'), Extractvalue(Value(A), 'IN/XM')
  Into n_病人id, n_主页id, v_身份证号, v_姓名
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  If Nvl(n_主页id, 0) = 0 And Nvl(n_病人id, 0) = 0 And Not v_身份证号 Is Null And Not v_姓名 Is Null Then
    n_病人id := Zl_Third_Getpatiid(v_身份证号, v_姓名);
  End If;

  --0.相关检查
  If Nvl(n_主页id, 0) = 0 Then
    n_类型 := 1;
  Else
    n_类型 := 2;
  End If;

  If Nvl(n_病人id, 0) = 0 Then
    v_Err_Msg := '不能有效识别病人身份!';
    Raise Err_Item;
  
  End If;
  n_病区id := 0;
  If Nvl(n_主页id, 0) <> 0 Then
    Begin
      Select Nvl(Nvl(b.当前病区id, a.当前病区id), 0), Decode(担保额, Null, 担保额, Zl_Patientsurety(a.病人id, a.主页id)), b.险类
      Into n_病区id, n_担保额, n_险类
      From 病人信息 A, 病案主页 B
      Where a.病人id = b.病人id And a.病人id = n_病人id And b.主页id = n_主页id And Rownum < 2;
    Exception
      When Others Then
        n_病区id  := Null;
        v_Err_Msg := '未找到病案主页,请检查主页ID是否传入正确!';
      
    End;
    If v_Err_Msg Is Not Null Then
      Raise Err_Item;
    End If;
    If Nvl(n_险类, 0) <> 0 Then
      --医保包含医保模拟计算
      Select Nvl(Sum(金额), 0) Into n_医保结算额 From 保险模拟结算 Where 病人id = n_病人id And 主页id = n_主页id;
    End If;
  Else
    Select Decode(担保额, Null, 担保额, Zl_Patientsurety(病人id, 主页id))
    Into n_担保额
    From 病人信息
    Where 病人id = n_病人id;
  End If;

  v_方案 := Zl_Patiwarnscheme(n_病人id, n_主页id);
  Begin
    Select 报警值, Nvl(报警方法, 1), 报警标志1, 报警标志2, 报警标志3
    Into n_报警值, n_报警方法, v_报警标志1, v_报警标志2, v_报警标志3
    From 记帐报警线
    Where 适用病人 = v_方案 And Nvl(病区id, 0) = Decode(n_类型, 1, 0, n_病区id) And Rownum < 2;
  Exception
    When Others Then
      n_报警值 := 0;
  End;
  Begin
    Select 预交余额, 费用余额
    Into n_预交余额, n_费用余额
    From 病人余额
    Where 病人id = n_病人id And 性质 = 1 And 类型 = n_类型;
  Exception
    When Others Then
      n_预交余额 := 0;
      n_费用余额 := 0;
  End;
  n_Temp := Nvl(n_预交余额, 0) - Nvl(n_费用余额, 0) + Nvl(n_医保结算额, 0);

  v_Temp := '<YJYE>' || Nvl(n_预交余额, 0) || '</YJYE>';
  v_Temp := v_Temp || '<WJFY>' || Nvl(n_费用余额, 0) || '</WJFY>';
  v_Temp := v_Temp || '<BXMLJE>' || Nvl(n_医保结算额, 0) || '</BXMLJE>';
  v_Temp := v_Temp || '<SYK>' || Nvl(n_Temp, 0) || '</SYK>';
  v_Temp := v_Temp || '<DBE>' || Nvl(n_担保额, 0) || '</DBE>';
  v_Temp := v_Temp || '<BJJE>' || Nvl(n_报警值, 0) || '</BJJE>';

  v_Temp := '<OUTPUT>' || v_Temp || '</OUTPUT>';

  x_Templet := Xmltype(v_Temp);
  Xml_Out   := x_Templet;

Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getalarmline;
/

--111342:焦博,2017-07-10,调整公共函数Zl_Third_Getpatiid增加传入参数姓名_IN
--110711:焦博,2017-06-28,增加入参节点身份证号,当病人ID不存在时,用身份证号获取病人ID
Create Or Replace Procedure Zl_Third_Deposit_Recharge
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is

  -------------------------------------------------------------------------------------------------- 
  --功能:预交款充值 
  --入参:Xml_In: 
  --    <IN>
  --        <BRID>病人ID</BRID>
  --        <XM>姓名</XM> 
  --        <SFZH>身份证号</SFZH> 
  --        <ZYID>主页ID</ZYID>
  --        <SFMZ>是否门诊</SFMZ> //1-是门诊,0-住院
  --        <JSLIST>
  --            <JS>
  --              <JSKLB>支付卡类别</JSKLB >
  --              <JSKH>支付卡号</JSKH>
  --              <JYLSH>交易流水号</JYLSH>
  --              <JYSM>交易说明</JYSM>
  --              <JSFS>支付方式</JSFS> //充值方式:现金;支票,如果是三方卡,可以传空
  --              <JSJE>交易金额</JSJE> //充值金额
  --              <ZY>摘要</ZY> 
  --              <SFXFK>是否消费卡</SFXFK> 
  --              <JSHM>结算号码(可以不传)</JSHM> 
  --              <JKDW>缴款单位(可以不传)</JKDW> 
  --              <DWKFH>单位开户行(可以不传)</DWKFH> 
  --              <DWZH>单位帐号(可以不传)</DWZH> 
  --              <HZDW>合作单位(可以不传)</HZDW> 
  --              <EXPENDLIST>  //扩展交易信息
  --                   <EXPEND>
  --                        <JYMC>交易名称</JYMC>
  --                        <JYLR>交易内容</JYLR>
  --                   </EXPEND>
  --              </EXPENDLIST >
  --            </JS>
  --         </JSLIST>
  --    </IN>
  --出参:Xml_Out 
  --  <OUTPUT> 
  --     <CZSJ>操作时间</CZSJ>          //HIS的登记时间
  --     <YJDH>预交单号(多个逗号分隔)</YJDH>
  --    DD如无下列错误结点则说明正确执行 
  --    <ERROR> 
  --      <MSG>错误信息</MSG> 
  --    </ERROR> 
  --  </OUTPUT> 
  -------------------------------------------------------------------------------------------------- 
  v_结算方式   Varchar2(2000);
  v_Nos        Varchar2(4000);
  v_No         病人预交记录.No%Type;
  v_操作员编码 病人预交记录.操作员编号%Type;
  v_操作员姓名 病人预交记录.操作员姓名%Type;

  n_卡类别id   医疗卡类别.Id%Type;
  n_病人id     门诊费用记录.病人id%Type;
  v_姓名       病人信息.姓名%Type;
  v_身份证号   病人信息.身份证号%Type;
  n_主页id     病人预交记录.主页id%Type;
  n_科室id     病人预交记录.科室id%Type;
  n_预交id     病人预交记录.Id%Type;
  n_结算卡序号 病人预交记录.结算卡序号%Type;
  n_预交类别   病人预交记录.预交类别%Type;
  n_消费卡     Number(2);
  n_门诊预存   Number(2);

  d_登记时间 Date;

  v_Temp    Varchar2(32767); --临时XML 
  x_Templet Xmltype; --模板XML 

  v_Err_Msg Varchar2(200);
  Err_Item Exception;
  Err_Special Exception;
  n_Count Number(18);

  Function Zl_结算方式_Get
  (
    卡类别_In   Varchar2,
    消费卡_In   Number,
    卡类别id_In Out 病人预交记录.卡类别id%Type
  ) Return Varchar2 As
    v_名称 Varchar2(200);
  
  Begin
  
    v_结算方式 := Null;
    v_Err_Msg  := Null;
  
    Begin
      n_卡类别id := To_Number(卡类别_In);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
  
    If Nvl(消费卡_In, 0) = 1 Then
    
      If n_卡类别id = 0 Then
        Begin
          Select 编号, 结算方式, Decode(Nvl(启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
          Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
          From 卡消费接口目录
          Where 名称 = 卡类别_In;
        Exception
          When Others Then
            v_Err_Msg := '消费:' || 卡类别_In || '不存在!';
        End;
      
      Else
      
        Begin
          Select 编号, 结算方式, Decode(Nvl(启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
          Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
          From 卡消费接口目录
          Where 编号 = 卡类别_In;
        Exception
          When Others Then
            v_Err_Msg := '未找到指定的结算支付信息!';
        End;
      
      End If;
    
      If Not v_Err_Msg Is Null Then
        Raise Err_Item;
      End If;
      If v_结算方式 Is Null Then
        v_Err_Msg := Nvl(v_名称, '') || '未设置结算方式,请在消费卡管理中设置结算方式';
        Raise Err_Item;
      End If;
      卡类别id_In := n_卡类别id;
    
      Return v_结算方式;
    
    End If;
  
    If n_卡类别id = 0 Then
      Begin
        Select ID, 结算方式, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
        Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
        From 医疗卡类别
        Where 名称 = 卡类别_In;
      Exception
        When Others Then
          n_卡类别id := -1;
          v_Err_Msg  := 卡类别_In || '不存在!';
      End;
    Else
      Begin
        Select ID, 结算方式, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
        Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
        From 医疗卡类别
        Where ID = n_卡类别id;
      Exception
        When Others Then
          n_卡类别id := -1;
          v_Err_Msg  := '未找到指定的结算支付信息!';
      End;
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
    If v_结算方式 Is Null Then
      v_Err_Msg := Nvl(v_名称, '') || '未设置结算方式,请在医疗卡类别中设置结算方式';
      Raise Err_Item;
    End If;
  
    卡类别id_In := n_卡类别id;
    Return v_结算方式;
  End Zl_结算方式_Get;

Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/BRID'), To_Number(Extractvalue(Value(A), 'IN/ZYID')),
         To_Number(Extractvalue(Value(A), 'IN/SFMZ')), Extractvalue(Value(A), 'IN/SFZH'),
		 Extractvalue(Value(A), 'IN/XM')
  Into n_病人id, n_主页id, n_门诊预存, v_身份证号, v_姓名
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  If Nvl(n_门诊预存, 0) = 1 And Nvl(n_病人id, 0) = 0 And Not v_身份证号 Is Null And Not v_姓名 Is Null Then
    n_病人id := Zl_Third_Getpatiid(v_身份证号, v_姓名);
  End If;

  --0.相关检查
  If Nvl(n_门诊预存, 0) = 0 Then
    n_预交类别 := 2;
  Else
    n_预交类别 := 1;
  End If;
  If Nvl(n_病人id, 0) = 0 Then
    v_Err_Msg := '不能有效识别病人身份,不允许充值!';
    Raise Err_Item;
  
  End If;

  --操作员信息:部门ID,部门名称;人员ID,人员编号,人员姓名
  v_Temp := Zl_Identity;
  If Nvl(v_Temp, '0') = '0' Or Nvl(v_Temp, '_') = '_' Then
    v_Err_Msg := '系统不能认别有效的操作员,不允许缴费!';
    Raise Err_Item;
  End If;

  Select Nvl(a.当前科室id, b.出院科室id)
  Into n_科室id
  From 病人信息 A, 病案主页 B
  Where b.病人id(+) = a.病人id And a.主页id = b.主页id(+) And a.病人id = n_病人id;

  v_Temp       := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员编码 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_操作员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);

  v_Err_Msg := Null;

  If Not v_Err_Msg Is Null Then
    Raise Err_Item;
  End If;

  If Nvl(n_主页id, 0) = 0 Then
    n_主页id := Null;
  End If;

  If Nvl(n_科室id, 0) = 0 Then
    n_科室id := Null;
  End If;

  d_登记时间 := Sysdate;
  Select 病人预交记录_Id.Nextval Into n_预交id From Dual;

  For c_交易记录 In (Select Extractvalue(b.Column_Value, '/JS/JSKLB') As 结算卡类别,
                        Extractvalue(b.Column_Value, '/JS/JYLSH') As 交易流水号,
                        Extractvalue(b.Column_Value, '/JS/JSKH') As 结算卡号, Extractvalue(b.Column_Value, '/JS/ZY') As 摘要
                 From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B) Loop
    Begin
      n_卡类别id := To_Number(c_交易记录.结算卡类别);
    Exception
      When Others Then
        Select ID Into n_卡类别id From 医疗卡类别 Where 名称 = c_交易记录.结算卡类别;
    End;
    If Zl_Fun_三方交易记录_Locked(n_卡类别id, c_交易记录.交易流水号, c_交易记录.结算卡号, c_交易记录.摘要,n_预交id) = 0 Then
      v_Err_Msg := '交易流水号为:' || c_交易记录.交易流水号 || '的交易正在进行中，不允许再次提交此交易!';
      Raise Err_Special;
    End If;
  End Loop;

  --2.确定支付方式
  n_Count := 0;
  v_Nos   := Null;
  For c_结算方式 In (Select Extractvalue(b.Column_Value, '/JS/JSKLB') As 结算卡类别,
                        Extractvalue(b.Column_Value, '/JS/JSKH') As 结算卡号,
                        Extractvalue(b.Column_Value, '/JS/JSFS') As 结算方式,
                        Extractvalue(b.Column_Value, '/JS/JSJE') As 结算金额,
                        Extractvalue(b.Column_Value, '/JS/JYLSH') As 交易流水号,
                        Extractvalue(b.Column_Value, '/JS/JYSM') As 交易说明, Extractvalue(b.Column_Value, '/JS/ZY') As 摘要,
                        Extractvalue(b.Column_Value, '/JS/SFCYJ') As 是否冲预交,
                        Extractvalue(b.Column_Value, '/JS/SFXFK') As 是否消费卡,
                        Extractvalue(b.Column_Value, '/JS/JSHM') As 结算号码,
                        Extractvalue(b.Column_Value, '/JS/JKDW') As 缴款单位,
                        Extractvalue(b.Column_Value, '/JS/DWKFH') As 单位开户行,
                        Extractvalue(b.Column_Value, '/JS/DWZH') As 单位帐号,
                        Extractvalue(b.Column_Value, '/JS/HZDW') As 合作单位,
                        Extract(b.Column_Value, '/JS/EXPENDLIST') As Expend
                 From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B) Loop
  
    v_No := Nextno(11);
    If v_Nos Is Null Then
      v_Nos := v_No;
    Else
      v_Nos := v_Nos || ',' || v_No;
    End If;
  
    If Nvl(c_结算方式.结算金额, 0) = 0 Then
      v_Err_Msg := '传入的充值金额为零,没必要进行充值处理,请检查充值金额是否传入错误!';
      Raise Err_Item;
    End If;
  
    n_结算卡序号 := Null;
    n_卡类别id   := Null;
    n_消费卡     := Nvl(c_结算方式.是否消费卡, 0);
  
    If c_结算方式.结算卡类别 Is Not Null Then
      --三方卡结算
      v_结算方式 := Zl_结算方式_Get(c_结算方式.结算卡类别, n_消费卡, n_卡类别id);
      If Nvl(n_消费卡, 0) = 1 Then
        n_结算卡序号 := n_卡类别id;
        n_卡类别id   := Null;
      End If;
    
    Else
      v_结算方式 := c_结算方式.结算方式;
      If v_结算方式 Is Null Then
        v_Err_Msg := '未确定本次充值的支付方式,请检查支付方式是否传入错误!';
        Raise Err_Item;
      End If;
    End If;
    Zl_病人预交记录_Insert(n_预交id, v_No, Null, n_病人id, n_主页id, n_科室id, c_结算方式.结算金额, v_结算方式, c_结算方式.结算号码, c_结算方式.缴款单位,
                     c_结算方式.单位开户行, c_结算方式.单位帐号, c_结算方式.摘要, v_操作员编码, v_操作员姓名, Null, n_预交类别, n_卡类别id, n_结算卡序号, c_结算方式.结算卡号,
                     c_结算方式.交易流水号, c_结算方式.交易说明, c_结算方式.合作单位, d_登记时间, 0);
  
    --保存扩展结算信息
    For c_扩展 In (Select Extractvalue(j.Column_Value, '/EXPEND/JYMC') As Jymc,
                        Extractvalue(j.Column_Value, '/EXPEND/JYLR') As Jylr
                 From Table(Xmlsequence(Extract(c_结算方式.Expend, '/EXPENDLIST/EXPEND'))) J) Loop
      Zl_三方结算交易_Insert(n_卡类别id, n_消费卡, c_结算方式.结算卡号, n_预交id, c_扩展.Jymc || '|' || c_扩展.Jylr, 1);
    End Loop;
    n_Count := n_Count + 1;
  End Loop;

  If n_Count = 0 Then
    v_Err_Msg := '不能有效确认当前充值的支付方式!';
    Raise Err_Item;
  End If;

  v_Temp := '<YJDH>' || v_Nos || '</YJDH>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  v_Temp := '<CZSJ>' || To_Char(d_登记时间, 'YYYY-MM-DD hh24:mi:ss') || '</CZSJ>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Xml_Out := x_Templet;

Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Err_Special Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20105, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Deposit_Recharge;
/

--111342:焦博,2017-07-10,调整公共函数Zl_Third_Getpatiid增加传入参数姓名_IN
--110711:焦博,2017-06-28,增加入参节点身份证号,当病人ID不存在时,用身份证号获取病人ID
Create Or Replace Procedure Zl_Third_Registercheck
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:HIS挂号检查
  --入参:Xml_In:
  --<IN>
  --  <BRID>1</BRID>                    //病人ID
  --  <XM>姓名</XM>                     //姓名
  --  <SFZH>510221197008184710</SFZH>   //身份证号
  --  <HM>0100</HM>                     //号码
  --  <CZJLID>100</CZJLID>              //出诊记录ID,计划排班模式可以不传
  --  <GHSJ>2016-08-10 09:52:00</GHSJ>  //挂号时间
  --  <KSID>1</KSID>                    //科室ID
  --  <YSXM>张震</YSXM>                 //医生姓名
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  -- <ERROR><MSG></MSG></ERROR> //为空表示检查成功
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  n_存在           Number(3);
  n_病人id         病人信息.病人id%Type;
  v_姓名           病人信息.姓名%Type;
  v_身份证号       病人信息.身份证号%Type;
  v_号码           挂号安排.号码%Type;
  n_出诊记录id     Number(18);
  d_发生时间       病人挂号记录.发生时间%Type;
  v_Type           Varchar2(50);
  v_Para           Varchar2(500);
  d_启用时间       Date;
  n_挂号模式       Number(3);
  n_同科限号数     Number;
  n_同科限约数     Number;
  n_病人挂号科室数 Number;
  n_病人预约科室数 Number;
  n_专家号挂号限制 Number;
  n_专家号预约限制 Number;
  n_Exists         Number;
  n_Count          Number;
  n_科室id         病人挂号记录.执行部门id%Type;
  n_医生id         人员表.Id%Type;
  v_医生姓名       病人挂号记录.执行人%Type;
  v_性别           病人信息.性别%Type;
  v_年龄           病人信息.年龄%Type;
  n_已约科室       Number;
  v_Checkresult    Varchar2(500);
  v_Temp           Varchar2(32767); --临时XML
  x_Templet        Xmltype; --模板XML
  v_Err_Msg        Varchar2(200);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/BRID'), Extractvalue(Value(A), 'IN/HM'), Extractvalue(Value(A), 'IN/CZJLID'),
         To_Date(Extractvalue(Value(A), 'IN/GHSJ'), 'yyyy-mm-dd hh24:mi:ss'),
         To_Number(Extractvalue(Value(A), 'IN/KSID')), Extractvalue(Value(A), 'IN/YSXM'),
		 Extractvalue(Value(A), 'IN/SFZH'), Extractvalue(Value(A), 'IN/XM')
  Into n_病人id, v_号码, n_出诊记录id, d_发生时间, n_科室id, v_医生姓名, v_身份证号, v_姓名
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  If nvl(n_病人id, 0) = 0 And Not v_身份证号 Is Null And Not v_姓名 Is Null Then
    n_病人id := zl_third_GetPatiID(v_身份证号,v_姓名);
  End If;
  If nvl(n_病人id, 0) = 0 Then
    v_Err_Msg := '无法确定病人信息,请检查';
    Raise Err_Item;
  End If;

  v_Para := zl_GetSysParameter(256);
  If v_Para Is Not Null Then
    n_挂号模式 := Substr(v_Para, 1, 1);
    Begin
      d_启用时间 := To_Date(Substr(v_Para, 3), 'yyyy-mm-dd hh24:mi:ss');
    Exception
      When Others Then
        d_启用时间 := Null;
    End;
  
    If Sysdate - 10 > Nvl(d_启用时间, Sysdate - 30) Then
      If n_挂号模式 = 1 And Nvl(d_发生时间, Sysdate) > Nvl(d_启用时间, Sysdate - 30) And n_出诊记录id Is Null Then
        v_Temp := '系统当前处于出诊表排班模式，传入的参数无法确定挂号安排，请重试！';
        v_Temp := '<ERROR><MSG>' || v_Temp || '</MSG></ERROR>';
        Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
        Xml_Out := x_Templet;
        Return;
      End If;
    Else
      If n_挂号模式 = 1 And Nvl(d_发生时间, Sysdate) > Nvl(d_启用时间, Sysdate - 30) And n_出诊记录id Is Null Then
        Begin
          Select a.Id
          Into n_出诊记录id
          From 临床出诊记录 A, 临床出诊号源 B
          Where a.号源id = b.Id And b.号码 = v_号码 And Nvl(d_发生时间, Sysdate) Between a.开始时间 And a.终止时间;
        Exception
          When Others Then
            v_Temp := '系统当前处于出诊表排班模式，传入的参数无法确定挂号安排，请重试！';
            v_Temp := '<ERROR><MSG>' || v_Temp || '</MSG></ERROR>';
            Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
            Xml_Out := x_Templet;
            Return;
        End;
      End If;
    End If;
  End If;

  If n_出诊记录id Is Not Null Then
    Select 性别, 年龄 Into v_性别, v_年龄 From 病人信息 Where 病人id = n_病人id And Rownum < 2;
    v_Checkresult := Zl_临床出诊限制_Check(n_出诊记录id, v_年龄, v_性别);
    If Substr(Nvl(v_Checkresult, '0'), 1, 1) <> '0' Then
      v_Temp := '病人不适用该本号别,请检查！';
      v_Temp := '<ERROR><MSG>' || v_Temp || '</MSG></ERROR>';
      Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
      Xml_Out := x_Templet;
      Return;
    End If;
  End If;

  If Trunc(Sysdate) > Trunc(d_发生时间) Then
    v_Temp := '不能挂以前的号(' || To_Char(d_发生时间, 'yyyy-mm-dd') || ')。';
    v_Temp := '<ERROR><MSG>' || v_Temp || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Xml_Out := x_Templet;
    Return;
  End If;

  v_Temp := Zl_Identity(0);
  If Nvl(v_Temp, ' ') = ' ' Then
    v_Temp := '当前操作人员未设置对应的人员关系,不能继续。';
    v_Temp := '<ERROR><MSG>' || v_Temp || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Xml_Out := x_Templet;
    Return;
  End If;

  v_Temp           := Nvl(zl_GetSysParameter('病人同科限挂N个号', 1111), '0|0') || '|';
  n_同科限号数     := To_Number(Substr(v_Temp, 1, Instr(v_Temp, '|') - 1));
  n_同科限约数     := To_Number(Nvl(zl_GetSysParameter('病人同科限约N个号', 1111), '0'));
  n_病人预约科室数 := To_Number(Nvl(zl_GetSysParameter('病人预约科室数', 1111), '0'));
  n_病人挂号科室数 := To_Number(Nvl(zl_GetSysParameter('病人挂号科室限制', 1111), '0'));
  n_专家号挂号限制 := To_Number(Nvl(zl_GetSysParameter('专家号挂号限制'), '0'));
  n_专家号预约限制 := To_Number(Nvl(zl_GetSysParameter('专家号预约限制'), '0'));

  If Trunc(Sysdate) <> Trunc(d_发生时间) Then
    If Nvl(n_病人预约科室数, 0) <> 0 Then
      n_已约科室 := 0;
      For c_Chkitem In (Select Distinct 执行部门id
                        From 病人挂号记录
                        Where 病人id = n_病人id And 记录状态 = 1 And 记录性质 = 2 And 预约时间 Between Trunc(d_发生时间) And
                              Trunc(d_发生时间) + 1 - 1 / 24 / 60 / 60 And 执行部门id <> n_科室id) Loop
        n_已约科室 := n_已约科室 + 1;
      End Loop;
      If n_已约科室 >= Nvl(n_病人预约科室数, 0) And Nvl(n_病人预约科室数, 0) > 0 Then
        v_Temp := '同一病人最多同时能预约[' || Nvl(n_病人预约科室数, 0) || ']个科室,不能再预约！';
        v_Temp := '<ERROR><MSG>' || v_Temp || '</MSG></ERROR>';
        Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
        Xml_Out := x_Templet;
        Return;
      End If;
    End If;
    If Nvl(n_同科限约数, 0) <> 0 Then
      Select Count(1)
      Into n_Count
      From 病人挂号记录
      Where 病人id = n_病人id And 记录状态 = 1 And 记录性质 = 2 And 预约时间 Between Trunc(d_发生时间) And
            Trunc(d_发生时间) + 1 - 1 / 24 / 60 / 60 And 执行部门id = n_科室id;
      If n_Count >= Nvl(n_同科限约数, 0) And Nvl(n_同科限约数, 0) > 0 Then
        v_Temp := '该病人已经在该科室预约了' || n_Count || '次,不能再预约！';
        v_Temp := '<ERROR><MSG>' || v_Temp || '</MSG></ERROR>';
        Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
        Xml_Out := x_Templet;
        Return;
      End If;
    End If;
  Else
    If Nvl(n_病人挂号科室数, 0) <> 0 Then
      n_已约科室 := 0;
      For c_Chkitem In (Select Distinct 执行部门id
                        From 病人挂号记录
                        Where 病人id = n_病人id And 记录状态 = 1 And 记录性质 = 1 And 发生时间 Between Trunc(d_发生时间) And
                              Trunc(d_发生时间) + 1 - 1 / 24 / 60 / 60 And 执行部门id <> n_科室id) Loop
        n_已约科室 := n_已约科室 + 1;
      End Loop;
      If n_已约科室 >= Nvl(n_病人挂号科室数, 0) And Nvl(n_病人挂号科室数, 0) > 0 Then
        v_Temp := '同一病人最多同时能挂号[' || Nvl(n_病人挂号科室数, 0) || ']个科室,不能再挂号！';
        v_Temp := '<ERROR><MSG>' || v_Temp || '</MSG></ERROR>';
        Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
        Xml_Out := x_Templet;
        Return;
      End If;
    End If;
    If Nvl(n_同科限号数, 0) <> 0 Then
      Select Count(1)
      Into n_Count
      From 病人挂号记录
      Where 病人id = n_病人id And 记录状态 = 1 And 记录性质 = 1 And 发生时间 Between Trunc(d_发生时间) And
            Trunc(d_发生时间) + 1 - 1 / 24 / 60 / 60 And 执行部门id = n_科室id;
      If n_Count >= Nvl(n_同科限号数, 0) And Nvl(n_同科限号数, 0) > 0 Then
        v_Temp := '该病人已经在该科室挂号了' || n_Count || '次,不能再挂号！';
        v_Temp := '<ERROR><MSG>' || v_Temp || '</MSG></ERROR>';
        Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
        Xml_Out := x_Templet;
        Return;
      End If;
    End If;
  End If;

  If Trunc(Sysdate) = Trunc(d_发生时间) Then
    --挂号
    If Nvl(n_专家号挂号限制, 0) <> 0 And v_医生姓名 Is Not Null Then
      If n_出诊记录id Is Null Then
        --无出诊记录对应
        Begin
          Select Count(1)
          Into n_Exists
          From 病人挂号记录
          Where 病人id = n_病人id And 号别 = v_号码 And 发生时间 Between Trunc(d_发生时间) And Trunc(d_发生时间) + 1 - 1 / 24 / 60 / 60 And
                记录状态 = 1 And 记录性质 = 1;
        Exception
          When Others Then
            n_Exists := 0;
        End;
        If n_Exists >= n_专家号挂号限制 Then
          v_Temp := '该病人已经超过本号挂号限制,不能再次挂号！';
          v_Temp := '<ERROR><MSG>' || v_Temp || '</MSG></ERROR>';
          Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
          Xml_Out := x_Templet;
          Return;
        End If;
      Else
        --对应出诊记录
        Begin
          Select Count(1)
          Into n_Exists
          From 病人挂号记录
          Where 病人id = n_病人id And 出诊记录id = n_出诊记录id And 记录状态 = 1 And 记录性质 = 1;
        Exception
          When Others Then
            n_Exists := 0;
        End;
        If n_Exists >= n_专家号挂号限制 Then
          v_Temp := '该病人已经超过本号挂号限制,不能再次挂号！';
          v_Temp := '<ERROR><MSG>' || v_Temp || '</MSG></ERROR>';
          Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
          Xml_Out := x_Templet;
          Return;
        End If;
      End If;
    End If;
  Else
    --预约
    If Nvl(n_专家号预约限制, 0) <> 0 And v_医生姓名 Is Not Null Then
      If n_出诊记录id Is Null Then
        --无出诊记录对应
        Begin
          Select Count(1)
          Into n_Exists
          From 病人挂号记录
          Where 病人id = n_病人id And 号别 = v_号码 And 发生时间 Between Trunc(d_发生时间) And Trunc(d_发生时间) + 1 - 1 / 24 / 60 / 60 And
                记录状态 = 1 And 记录性质 = 2;
        Exception
          When Others Then
            n_Exists := 0;
        End;
        If n_Exists >= n_专家号预约限制 Then
          v_Temp := '该病人已经超过本号预约限制,不能再次预约！';
          v_Temp := '<ERROR><MSG>' || v_Temp || '</MSG></ERROR>';
          Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
          Xml_Out := x_Templet;
          Return;
        End If;
      Else
        --对应出诊记录
        Begin
          Select Count(1)
          Into n_Exists
          From 病人挂号记录
          Where 病人id = n_病人id And 出诊记录id = n_出诊记录id And 记录状态 = 1 And 记录性质 = 2;
        Exception
          When Others Then
            n_Exists := 0;
        End;
        If n_Exists >= n_专家号预约限制 Then
          v_Temp := '该病人已经超过本号预约限制,不能再次预约！';
          v_Temp := '<ERROR><MSG>' || v_Temp || '</MSG></ERROR>';
          Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
          Xml_Out := x_Templet;
          Return;
        End If;
      End If;
    End If;
  End If;

  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Registercheck;
/

--111342:焦博,2017-07-10,调整公共函数Zl_Third_Getpatiid增加传入参数姓名_IN
--110711:焦博,2017-06-28,增加入参节点身份证号,当病人ID不存在时,用身份证号获取病人ID
Create Or Replace Procedure Zl_Third_Getpayfeedetail
(
  Xml_In  In Xmltype,
  Xml_Out In Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取收费划价单费用明细
  --入参:Xml_In:
  --<IN>
  --  <BRID></BRID> //病人ID
  --  <XM></XM> //姓名
  --  <SFZH></SFZH> //身份证号
  --  <DJH></DJH> //单据号
  --</IN>
  --出参:Xml_Out
  -- <OUTPUT>
  --  <ZJE></ZJE>   //总实收金额
  --  <MXLIST>        //项目明细
  --    <ITEM>
  --      <DJH></DJH>       //单据号
  --      <MC></MC>   //项目名称
  --      <ID></ID>   //项目ID
  --      <SL></SL>   //数量，数次*付数
  --      <YSJE></YSJE>   //应收金额
  --      <SSJE></SSJE>   //实收金额
  --      <SJFM></SJFM>       //收据费目
  --    </ITEM>
  --    <ITEM>
  --    ...
  --    </ITEM>
  --  </MXLIST>
  -- </OUTPUT>

  --------------------------------------------------------------------------------------------------
  x_Templet    Xmltype; --模板XML
  v_Err_Msg    Varchar2(200);
  v_Temp       Varchar2(4000);
  v_Nos        Varchar2(4000);
  n_病人id     病人信息.病人id%Type;
  v_姓名       病人信息.姓名%Type;
  v_身份证号   病人信息.身份证号%Type;
  v_费别       病人信息.费别%Type;
  v_号码       挂号安排.号码%Type;
  n_总金额     门诊费用记录.实收金额%Type;
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');
  Select Extractvalue(Value(A), 'IN/BRID'), Extractvalue(Value(A), 'IN/DJH'), Extractvalue(Value(A), 'IN/SFZH'),
  Extractvalue(Value(A), 'IN/XM')
  Into n_病人id, v_Nos, v_身份证号,v_姓名
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  If Nvl(n_病人id, 0) = 0 And Not v_身份证号 Is Null And Not v_姓名 Is Null Then
    n_病人id := Zl_Third_Getpatiid(v_身份证号,v_姓名);
  End If;
  If Nvl(n_病人id, 0) = 0 Then
    v_Err_Msg := '无法确定病人信息,请检查';
    Raise Err_Item;
  End If;

  n_总金额 := 0;

  For c_项目 In (Select a.收费细目id As 项目id, a.应收金额, a.实收金额, a.计算单位, a.收据费目, b.名称 As 项目名称, a.No, Nvl(a.付数, 1) As 付数, a.数次
               From 门诊费用记录 A, 收费项目目录 B, Table(f_Str2list(v_Nos)) C
               Where a.收费细目id = b.Id And a.No = c.Column_Value And a.记录性质 = 1 And a.记录状态 = 0
               Order By NO, 序号) Loop
    n_总金额 := n_总金额 + Nvl(c_项目.实收金额, 0);
    v_号码   := c_项目.计算单位;
    v_Temp   := v_Temp || '<ITEM><DJH>' || c_项目.No || '</DJH><MC>' || c_项目.项目名称 || '</MC>' || '<ID>' || c_项目.项目id ||
                '</ID>' || '<SL>' || c_项目.付数 * c_项目.数次 || '</SL>' || '<YSJE>' || c_项目.应收金额 || '</YSJE>' || '<SSJE>' ||
                c_项目.实收金额 || '</SSJE>' || '<SJFM>' || c_项目.收据费目 || '</SJFM></ITEM>';
  End Loop;

  v_Temp := '<MXLIST>' || v_Temp || '</MXLIST>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;

  v_Temp := '<ZJE>' || n_总金额 || '</ZJE>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;

  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getpayfeedetail;
/

--111342:焦博,2017-07-10,调整公共函数Zl_Third_Getpatiid增加传入参数姓名_IN
--110711:焦博,2017-06-28,增加入参节点身份证号,当病人ID不存在时,用身份证号获取病人ID
Create Or Replace Procedure Zl_Third_Charge_Delcheck
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is

  -------------------------------------------------------------------------------------------------- 
  --功能:三方退费检查 
  --入参:Xml_In: 
  --<IN>
  --    <BRID>病人ID</BRID>
  --    <XM>姓名</XM>
  --    <SFZH>身份证号</SFZH>
  --    <JE></JE> //退款总金额
  --    <JSKLB></JSKLB>     //结算卡类别
  --    <TFZY>退费摘要</TFZY>
  --    <JCFP>1</JCFP>      //检查发票,0-不检查;1-检查;为1时，打印了发票的单据不能退费
  --    <XL>险类</XL>         //医保病人险类,空代表普通病人
  --    <FYLIST>
  --        <FY>
  --           <DJH>退款单据号</DJH>
  --           <XH>退款序号(格式:1,2,3..为空代表退剩余数量)</DJH>
  --        <FY>
  --    </FYLIST>
  --    <TKLIST>
  --        <TK>
  --            <TKKLB>退款卡类别</TKKLB>
  --            <TKKH>退款卡号</TKKH>
  --            <TKFS>退款方式</TKFS> //退款方式:现金;支票,如果是三方卡,可以传空
  --            <TKJE>支付金额</TKJE>
  --            <JYLSH>交易流水号</JYLSH>
  --            <TKZY>摘要</TKZY>
  --            <TYJK>退回预交款</TYJK> //允冲预交时,只填JSJE节点:1-冲预交
  --            <SFXFK>是否消费卡</SFXFK>   //(1-是消费卡),消费卡时,传入结算卡类别,结算卡号,结算金额等接点
  --            <EXPENDLIST>  //扩展交易信息
  --                <EXPEND>
  --                    <JYMC>交易名称</JYMC>
  --                    <JYLR>交易内容</JYLR>
  --                </EXPEND>
  --            </EXPENDLIST>
  --        </TK>
  --    </TKLIST>
  --</IN>

  --出参:Xml_Out 
  --  <OUT> 
  --    DD如无下列错误结点则说明通过检查
  --    <ERROR> 
  --      <MSG>错误信息</MSG> 
  --    </ERROR> 
  --  </OUT> 
  -------------------------------------------------------------------------------------------------- 
  n_退款总额 门诊费用记录.实收金额%Type;

  n_病人id     门诊费用记录.病人id%Type;
  v_姓名       病人信息.姓名%Type;
  v_身份证号   病人信息.身份证号%Type;
  n_单据病人id 门诊费用记录.病人id%Type;
  v_操作员编码 门诊费用记录.操作员编号%Type;
  v_操作员姓名 门诊费用记录.操作员姓名%Type;
  n_结帐id     门诊费用记录.结帐id%Type;
  n_原结算序号 病人预交记录.结算序号%Type;
  v_结算卡类别 Varchar2(100);
  v_结算方式   医疗卡类别.结算方式%Type;
  n_卡类别id   医疗卡类别.Id%Type;

  v_摘要     门诊费用记录.摘要%Type;
  n_Count    Number(18);
  n_Temp     Number(18);
  n_检查发票 Number(3);
  n_是否打印 Number(3);
  n_退费模式 Number(3);
  n_状态     Number(3);
  n_险类     病人信息.险类%Type;

  v_Temp    Varchar2(32767); --临时XML 
  x_Templet Xmltype; --模板XML 

  v_Err_Msg Varchar2(200);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');
  
  --0.获取入参中的病人ID等信息
  Select To_Number(Extractvalue(Value(A), 'IN/BRID')), To_Number(Extractvalue(Value(A), 'IN/JE')),
         Extractvalue(Value(A), 'IN/TFZY'), To_Number(Extractvalue(Value(A), 'IN/JCFP')),
         Extractvalue(Value(A), 'IN/JSKLB'), To_Number(Extractvalue(Value(A), 'IN/XL')),
		 Extractvalue(Value(A), 'IN/SFZH'), Extractvalue(Value(A), 'IN/XM')
  Into n_病人id, n_退款总额, v_摘要, n_检查发票, v_结算卡类别, n_险类, v_身份证号,v_姓名
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  If Nvl(n_病人id, 0) = 0 And Not v_身份证号 Is Null And Not v_姓名 Is Null Then
    n_病人id := Zl_Third_Getpatiid(v_身份证号,v_姓名);
  End If;
  --0.相关检查
  If Nvl(n_病人id, 0) = 0 Then
    v_Err_Msg := '不能有效识别病人身份,不允许退费操作!';
    Raise Err_Item;
  End If;

  n_退费模式 := zl_GetSysParameter('门诊退费须先申请');

  If v_结算卡类别 Is Not Null Then
    Begin
      n_卡类别id := To_Number(v_结算卡类别);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
    If n_卡类别id = 0 Then
      Begin
        Select ID Into n_卡类别id From 医疗卡类别 Where 名称 = v_结算卡类别;
      Exception
        When Others Then
          v_Err_Msg := '无法确认传入的结算卡！';
          Raise Err_Item;
      End;
    End If;
  Else
    n_卡类别id := 0;
  End If;

  If Nvl(n_卡类别id, 0) <> 0 Then
    Select 结算方式 Into v_结算方式 From 医疗卡类别 Where ID = n_卡类别id;
  End If;

  --人员id,人员编号,人员姓名 
  v_Temp := Zl_Identity(1);
  If Nvl(v_Temp, '0') = '0' Or Nvl(v_Temp, '_') = '_' Then
    v_Err_Msg := '系统不能认别有效的操作员,不允许退费!';
    Raise Err_Item;
  End If;
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员编码 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员姓名 := v_Temp;
  v_Err_Msg    := Null;

  --1.退费检查

  n_Count      := 0;
  n_原结算序号 := 0;
  For c_费用 In (Select Extractvalue(b.Column_Value, '/FY/DJH') As 单据号, Extractvalue(b.Column_Value, '/FY/XH') As 退款序号
               From Table(Xmlsequence(Extract(Xml_In, '/IN/FYLIST/FY'))) B) Loop
  
    If c_费用.单据号 Is Null Then
      v_Err_Msg := '未确定指定退费的单据号,不能退费!';
      Raise Err_Item;
    End If;
  
    If Nvl(n_退费模式, 0) = 1 Then
      Begin
        Select Nvl(状态, 0) Into n_状态 From 病人退费申请 Where NO = c_费用.单据号 And Mod(记录性质, 10) = 1;
      Exception
        When Others Then
          n_状态 := 0;
      End;
      If n_状态 <> 1 Then
        v_Err_Msg := '当前为退费申请模式,退费之前需申请并审核通过该单据!';
        Raise Err_Item;
      End If;
    End If;
  
    Begin
      Select a.结算序号, a.结帐id, a.病人id
      Into n_Temp, n_结帐id, n_单据病人id
      From 病人预交记录 A, 门诊费用记录 B
      Where a.结帐id = b.结帐id And b.No = c_费用.单据号 And b.记录性质 = 1 And Nvl(b.费用状态, 0) = 0 And b.记录状态 In (1, 3) And
            Rownum < 2;
    Exception
      When Others Then
        n_Temp := Null;
    End;
  
    If n_Temp Is Null Then
      v_Err_Msg := '指定的单据号:' || c_费用.单据号 || '未找到,不能退费!';
      Raise Err_Item;
    End If;
  
    If Nvl(n_单据病人id, 0) = 0 Then
      Begin
        Select 病人id
        Into n_单据病人id
        From 门诊费用记录
        Where NO = c_费用.单据号 And 记录性质 = 1 And Nvl(费用状态, 0) = 0 And 记录状态 In (1, 3) And Rownum < 2;
      Exception
        When Others Then
          n_单据病人id := 0;
      End;
    End If;
  
    If Nvl(n_病人id, 0) <> Nvl(n_单据病人id, 0) Then
      v_Err_Msg := '本次退费的收费单:' || c_费用.单据号 || '不是当前病人的收费单,不能退费!';
      Raise Err_Item;
    End If;
  
    If n_原结算序号 <> 0 And n_原结算序号 <> n_Temp Then
      v_Err_Msg := '本次退费的单据号不是一次收费结算,不能退费!';
      Raise Err_Item;
    End If;
    n_原结算序号 := n_Temp;
  
    Select Count(*) Into n_Temp From 费用补充记录 Where 收费结帐id = n_结帐id;
    If Nvl(n_Temp, 0) <> 0 Then
      v_Err_Msg := '本次退费的单据号已经进行了保险补充结算,不能退费!';
      Raise Err_Item;
    End If;
  
    If v_结算卡类别 Is Not Null Then
      If Nvl(n_险类, 0) = 0 Then
        Select Count(*) Into n_Temp From 病人预交记录 Where 结帐id = n_结帐id And 结算方式 <> v_结算方式;
      Else
        Select Count(*)
        Into n_Temp
        From 病人预交记录 A, 结算方式 B
        Where a.结帐id = n_结帐id And a.结算方式 <> v_结算方式 And a.结算方式 = b.名称 And b.性质 Not In (3, 4);
        If n_Temp = 0 Then
          Select Nvl(Max(1), 0)
          Into n_Temp
          From 保险结算记录 A
          Where a.记录id = n_结帐id And 险类 <> n_险类 And Rownum < 2;
        End If;
      End If;
      If Nvl(n_Temp, 0) > 0 Then
        v_Err_Msg := '本次退费的单据包含' || v_结算方式 || '以外的结算方式,不能退费!';
        Raise Err_Item;
      End If;
    End If;
  
    If Nvl(n_检查发票, 0) = 1 Then
      Select Max(Decode(a.实际票号, Null, 0, 1))
      Into n_是否打印
      From 门诊费用记录 A
      Where NO = c_费用.单据号 And 记录性质 = 1;
      If Nvl(n_是否打印, 0) = 1 Then
        v_Err_Msg := '本次退费的单据号已开发票,不能退费!';
        Raise Err_Item;
      End If;
    End If;
  
    n_Count := n_Count + 1;
  End Loop;

  If n_Count = 0 Then
    v_Err_Msg := '未确定本次需要退费的单据,不能退费!';
    Raise Err_Item;
  End If;

  --2.支付方式检查
  n_Count := 0;
  For c_结算方式 In (Select Extractvalue(b.Column_Value, '/TK/TKKLB') As 卡类别, Extractvalue(b.Column_Value, '/TK/TKKH') As 卡号,
                        Extractvalue(b.Column_Value, '/TK/TKFS') As 结算方式,
                        -1 * To_Number(Extractvalue(b.Column_Value, '/TK/TKJE')) As 退款金额,
                        Extractvalue(b.Column_Value, '/TK/JYLSH') As 交易流水号,
                        Extractvalue(b.Column_Value, '/TK/JYSM') As 交易说明, Extractvalue(b.Column_Value, '/TK/TKZY') As 摘要,
                        Extractvalue(b.Column_Value, '/TK/TYJK') As 是否退预交,
                        Extractvalue(b.Column_Value, '/TK/SFXFK') As 是否消费卡,
                        Extract(b.Column_Value, '/TK/EXPENDLIST') As Expend
                 From Table(Xmlsequence(Extract(Xml_In, '/IN/TKLIST/TK'))) B) Loop
  
    --1.退回三方卡
    If c_结算方式.卡类别 Is Not Null And Nvl(c_结算方式.是否消费卡, 0) = 0 Then
      --1.三方卡结算
      Null;
    Elsif c_结算方式.卡类别 Is Not Null And Nvl(c_结算方式.是否消费卡, 0) = 1 Then
      --2.消费卡结算
      Null;
    Elsif Nvl(c_结算方式.是否退预交, 0) = 1 Then
      --3.退预交款
      Null;
    Else
      --4.普通结算
      If c_结算方式.结算方式 Is Null Then
        v_Err_Msg := '未指定支付方式,不能退费!';
        Raise Err_Item;
      End If;
    End If;
    n_Count := n_Count + 1;
  End Loop;

  If n_Count = 0 Then
    v_Err_Msg := '不能有效确认当前的支付方式,不能退费!';
    Raise Err_Item;
  End If;

  Xml_Out := x_Templet;

Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Charge_Delcheck;
/

--111342:焦博,2017-07-10,调整公共函数Zl_Third_Getpatiid增加传入参数姓名_IN
--110711:焦博,2017-06-28,增加入参节点身份证号,当病人ID不存在时,用身份证号获取病人ID
Create Or Replace Procedure Zl_Third_Charge_Delapply
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  ---入参：
  ---<IN> 
  ---  <BRID></BRID>        //病人ID
  ---  <XM></XM>        //姓名
  ---  <SFZH></SFZH>      //身份证号
  ---  <JSKLB></JSKLB >　//结算卡类别(暂固定传“支付宝”，同医疗卡类别名称，主要用于不同平台的区分)
  ---  <SQSM></ SQSM >      //固定传“支付宝退款申请”
  ---  <FYLIST>
  ---    <FY>
  ---      <DJH> </DJH>   //单据号
  ---      <DJLX></DJLX>   //单据类型
  ---      <JE></JE>       //单据金额
  ---    </FY>
  ---  </FYLIST>
  ---</IN>
  ---出参:
  ---<OUTPUT>
  ---  <ERROR><MSG></MSG></ERROR> //error节点为空表示退费申请成功
  ---</OUTPUT>
  --------------------------------------------------------------------------------------------------
  n_病人id     门诊费用记录.病人id%Type;
  v_身份证号   病人信息.身份证号%Type;
  v_结算卡类别 Varchar2(100);
  n_卡类别id   医疗卡类别.Id%Type;
  v_申请说明   病人退费申请.申请原因%Type;
  n_金额       Number(8, 2);
  n_Klbid      Number(8);
  n_结帐id     Number(8);
  v_姓名       Varchar2(10);
  x_Templet    Xmltype; --模板XML
  v_Temp       Varchar2(1000);
  v_Err_Msg    Varchar2(200);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  ---获取基本信息
  Select To_Number(Extractvalue(Value(A), 'IN/BRID')), Extractvalue(Value(A), 'IN/JSKLB'),
         Extractvalue(Value(A), 'IN/SQSM'), Extractvalue(Value(A), 'IN/SFZH'), Extractvalue(Value(A), 'IN/XM')
  Into n_病人id, v_结算卡类别, v_申请说明, v_身份证号,v_姓名
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  If Nvl(n_病人id, 0) = 0 And Not v_身份证号 Is Null And Not v_姓名 Is Null Then
    n_病人id := Zl_Third_Getpatiid(v_身份证号,v_姓名);
  End If;
  If Nvl(n_病人id, 0) = 0 Then
    v_Err_Msg := '无法确定病人信息,请检查';
    Raise Err_Item;
  End If;

  Select ID Into n_卡类别id From 医疗卡类别 Where 名称 = v_结算卡类别;
  Select 姓名 Into v_姓名 From 病人信息 Where 病人id = n_病人id;

  ---退费申请检查
  For Mx In (Select Extractvalue(b.Column_Value, '/FY/DJH') As 单据号,
                    To_Number(Extractvalue(b.Column_Value, '/FY/DJLX')) As 单据类型,
                    To_Number(Extractvalue(b.Column_Value, '/FY/JE')) As 金额
             From Table(Xmlsequence(Extract(Xml_In, '/IN/FYLIST/FY'))) B) Loop
  
    If Mx.单据号 Is Null Then
      v_Err_Msg := '未确定指定退费申请的单据号,不能退费申请!';
      Raise Err_Item;
    End If;
  
    Begin
      Select a.结帐id, Sum(a.实收金额)
      Into n_结帐id, n_金额
      From 门诊费用记录 A
      Where a.No = Mx.单据号 And a.记录性质 = Mx.单据类型 And a.病人id = n_病人id And a.记录状态 In (1, 3)
      Group By a.结帐id;
    Exception
      When Others Then
        v_Err_Msg := '未确定指定退费申请的单据号,不能退费申请!';
        Raise Err_Item;
    End;
  
    If Mx.金额 <> n_金额 Then
      v_Err_Msg := '申请退费金额不正确，退费申请失败!';
      Raise Err_Item;
    End If;
  
    Select Distinct 卡类别id Into n_Klbid From 病人预交记录 Where 结帐id = n_结帐id;
  
    If n_卡类别id <> n_Klbid Then
      v_Err_Msg := '申请退费的单据不是由' || v_结算卡类别 || '结算，不能进行退费申请!';
      Raise Err_Item;
    End If;
  
    Zl_病人退费申请_Apply(0, Mx.单据号, Mx.单据类型, v_姓名, Sysdate, v_申请说明);
  End Loop;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '<ERROR><MSG>' || v_Err_Msg || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Xml_Out := x_Templet;
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Charge_Delapply;
/

--111342:焦博,2017-07-10,调整公共函数Zl_Third_Getpatiid增加传入参数姓名_IN
--110711:焦博,2017-06-28,增加入参节点身份证号,当病人ID不存在时,用身份证号获取病人ID
Create Or Replace Procedure Zl_Third_Payment
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is

  -------------------------------------------------------------------------------------------------- 
  --功能:三方接口支付 
  --入参:Xml_In: 
  --<IN>
  --        <NO></NO>                       //收费单据号串,逗号分隔多个单据号
  --        <JE></JE>                       //总金额
  --        <BRID>病人ID</BRID>             //病人ID
  --        <XM>姓名</XM>                   //姓名
  --        <SFZH>身份证号</SFZH>           //身份证号
  --        <SFGH></SFGH>                   //是否挂号单
  --        <WCJE>误差额</WCJE>             //误差项不传时,以总金额-本次结算费用总额为准
  --       <JSLIST>
  --         <JS>
  --              <JSKLB>支付卡类别</JSKLB >
  --              <JSKH>支付卡号</ JSKH >
  --              <JSFS>支付方式</JSFS> //支付方式:现金;支票,如果是三方卡,可以传空
  --              <JSJE>支付金额</JSJE>
  --              <JYLSH>交易流水号</JYLSH>
  --              <ZY>摘要</ZY>
  --              <SFCYJ>是否冲预交</SFCYJ>  //允冲预交时,只填JSJE节点:1-冲预交
  --              <SFXFK>是否消费卡</SFXFK>  //(1-是消费卡),消费卡时,传入结算卡类别,结算卡号,结算金额等接点
  --              <EXPENDLIST>  //扩展交易信息
  --                  <EXPEND>
  --                        <JYMC >交易名称</交易名称>
  --                        <JYLR>交易内容</JYLR>
  --                  </EXPEND>
  --              </EXPENDLIST>
  --         </JS>
  --       </JSLIST >
  --</IN>

  --出参:Xml_Out 
  --  <OUT> 
  --    <JZID></JZID>       //结帐ID
  --    <CZSJ>操作时间</CZSJ>          //HIS的登记时间
  --    DD如无下列错误结点则说明正确执行 
  --    <ERROR> 
  --      <MSG>错误信息</MSG> 
  --    </ERROR> 
  --  </OUT> 
  -------------------------------------------------------------------------------------------------- 
  v_Nos      Varchar2(4000);
  n_收费总额 门诊费用记录.实收金额%Type;

  n_卡类别id 医疗卡类别.Id%Type;
  v_结算方式 Varchar2(2000);
  n_病人id   门诊费用记录.病人id%Type;
  v_身份证号 病人信息.身份证号%Type;
  v_姓名     门诊费用记录.姓名%Type;
  v_性别     门诊费用记录.性别%Type;
  v_年龄     门诊费用记录.年龄%Type;

  v_医疗付款方式编码 医疗付款方式.编码%Type;
  v_操作员编码       门诊费用记录.操作员编号%Type;
  v_操作员姓名       门诊费用记录.操作员姓名%Type;
  n_结帐id           门诊费用记录.结帐id%Type;
  n_结帐金额         门诊费用记录.结帐金额%Type;
  d_收费时间         病人预交记录.收款时间%Type;
  n_消费卡id         消费卡目录.Id%Type;
  v_收费结算         Varchar2(2000);
  v_普通结算         Varchar2(4000);
  n_是否挂号         Number(3);
  n_预交支付         门诊费用记录.实收金额%Type;
  n_普通支付         门诊费用记录.实收金额%Type;
  v_结算卡号         病人预交记录.卡号%Type;
  n_结算卡序号       病人预交记录.结算卡序号%Type;
  v_交易流水号       病人预交记录.交易流水号%Type;
  v_交易说明         病人预交记录.交易说明%Type;
  v_摘要             病人预交记录.摘要%Type;
  n_科室id           挂号安排.科室id%Type;
  n_项目id           挂号安排.项目id%Type;
  n_医生id           挂号安排.医生id%Type;
  v_医生姓名         挂号安排.医生姓名%Type;
  v_号码             挂号安排.号码%Type;
  n_门诊号           病人信息.门诊号%Type;
  d_发生时间         病人挂号记录.发生时间%Type;
  v_费别             病人信息.费别%Type;
  n_号序             病人挂号记录.号序%Type;
  n_生成队列         Number(3);
  v_Para             Varchar2(500);
  n_挂号模式         Number(3);
  d_启用时间         Date;
  v_临时结算方式     病人预交记录.结算方式%Type;
  n_出诊记录id       临床出诊记录.Id%Type;
  n_医保支付         病人预交记录.冲预交%Type;
  n_Exists           Number;

  v_Temp    Varchar2(32767); --临时XML 
  x_Templet Xmltype; --模板XML 

  v_Err_Msg Varchar2(200);
  Err_Item    Exception;
  Err_Special Exception;
  n_Count    Number(18);
  v_操作员   门诊费用记录.操作员姓名%Type;
  v_发药窗口 Varchar2(4000);
  n_误差额   病人预交记录.冲预交%Type;

  Function Zl_出诊诊室(记录id_In 临床出诊记录.Id%Type) Return Varchar2 As
    n_分诊方式 临床出诊记录.分诊方式%Type;
    v_诊室     病人挂号记录.诊室%Type;
    v_Rowid    Varchar2(500);
    n_Next     Integer;
    n_First    Integer;
  Begin
    Begin
      Select Nvl(分诊方式, 0) Into n_分诊方式 From 临床出诊记录 Where ID = 记录id_In;
    Exception
      When Others Then
        v_Err_Msg := '出诊记录(' || 记录id_In || ')未找到!';
        Raise Err_Item;
    End;
  
    --0-不分诊、1-指定诊室、2-动态分诊、3-平均分诊,对应门诊诊室设置
    v_诊室 := Null;
    If n_分诊方式 = 1 Then
      --1-指定诊室
      Begin
        Select b.名称 Into v_诊室 From 临床出诊诊室记录 A, 门诊诊室 B Where a.诊室id = b.Id And a.记录id = 记录id_In;
      Exception
        When Others Then
          v_诊室 := Null;
      End;
    End If;
    If n_分诊方式 = 2 Then
      --2-动态分诊:该个号别当天挂号未诊数最少的诊室
      For c_诊室 In (Select 门诊诊室, Sum(Num) As Num
                   From (Select b.名称 As 门诊诊室, 0 As Num
                          From 临床出诊诊室记录 A, 门诊诊室 B
                          Where a.诊室id = b.Id And a.记录id = 记录id_In
                          Union All
                          Select 诊室, Count(诊室) As Num
                          From 病人挂号记录
                          Where Nvl(执行状态, 0) = 0 And 发生时间 Between Trunc(Sysdate) And Sysdate And 出诊记录id = 记录id_In And
                                诊室 In (Select d.名称
                                       From 临床出诊诊室记录 C, 门诊诊室 D
                                       Where c.诊室id = d.Id And c.记录id = 记录id_In)
                          Group By 诊室)
                   Group By 门诊诊室
                   Order By Num) Loop
        v_诊室 := c_诊室.门诊诊室;
        Exit;
      End Loop;
    End If;
    If n_分诊方式 = 3 Then
      --平均分诊：当前分配=1表示下次应取的当前诊室
      n_Next  := 0;
      n_First := 1;
      For c_诊室 In (Select a.Rowid As Rid, b.名称 As 门诊诊室, a.当前分配
                   From 临床出诊诊室记录 A, 门诊诊室 B
                   Where a.诊室id = b.Id And a.记录id = 记录id_In) Loop
        If n_First = 1 Then
          v_Rowid := c_诊室.Rid;
        End If;
        If n_Next = 1 Then
          v_诊室 := c_诊室.门诊诊室;
          Update 临床出诊诊室记录 Set 当前分配 = 1 Where Rowid = c_诊室.Rid;
          Exit;
        End If;
        If Nvl(c_诊室.当前分配, 0) = 1 Then
          Update 临床出诊诊室记录 Set 当前分配 = 0 Where Rowid = c_诊室.Rid;
          n_Next := 1;
        End If;
      End Loop;
      If v_诊室 Is Null Then
        Update 临床出诊诊室记录 Set 当前分配 = 1 Where Rowid = v_Rowid Returning 诊室id Into v_诊室;
        Select 名称 Into v_诊室 From 门诊诊室 Where ID = v_诊室;
      End If;
    End If;
    Return v_诊室;
  End;

  Function Zl_诊室(号码_In 挂号安排.号码%Type) Return Varchar2 As
    n_分诊方式 挂号安排.分诊方式%Type;
    n_安排id   挂号安排.Id%Type;
    v_诊室     病人挂号记录.诊室%Type;
    v_Rowid    Varchar2(500);
    n_Next     Integer;
    n_First    Integer;
  Begin
  
    Begin
      Select ID, Nvl(分诊方式, 0) Into n_安排id, n_分诊方式 From 挂号安排 Where 号码 = 号码_In;
    Exception
      When Others Then
        n_安排id := -1;
    End;
  
    If n_安排id = -1 Then
      v_Err_Msg := '号码(' || 号码_In || ')未找到!';
      Raise Err_Item;
    End If;
    --0-不分诊、1-指定诊室、2-动态分诊、3-平均分诊,对应门诊诊室设置
    v_诊室 := Null;
    If n_分诊方式 = 1 Then
      --1-指定诊室
      Begin
        Select 门诊诊室 Into v_诊室 From 挂号安排诊室 Where 号表id = n_安排id;
      Exception
        When Others Then
          v_诊室 := Null;
      End;
    End If;
    If n_分诊方式 = 2 Then
      --2-动态分诊:该个号别当天挂号未诊数最少的诊室
      For c_诊室 In (Select 门诊诊室, Sum(Num) As Num
                   From (Select 门诊诊室, 0 As Num
                          From 挂号安排诊室
                          Where 号表id = n_安排id
                          Union All
                          Select 诊室, Count(诊室) As Num
                          From 病人挂号记录
                          Where Nvl(执行状态, 0) = 0 And 发生时间 Between Trunc(Sysdate) And Sysdate And 号别 = 号码_In And
                                诊室 In (Select 门诊诊室 From 挂号安排诊室 Where 号表id = n_安排id)
                          Group By 诊室)
                   Group By 门诊诊室
                   Order By Num) Loop
        v_诊室 := c_诊室.门诊诊室;
        Exit;
      End Loop;
    End If;
    If n_分诊方式 = 3 Then
    
      --平均分诊：当前分配=1表示下次应取的当前诊室
      n_Next  := 0;
      n_First := 1;
      For c_诊室 In (Select Rowid As Rid, 号表id, 门诊诊室, 当前分配 From 挂号安排诊室 Where 号表id = n_安排id) Loop
        If n_First = 1 Then
          v_Rowid := c_诊室.Rid;
        End If;
        If n_Next = 1 Then
          v_诊室 := c_诊室.门诊诊室;
          Update 挂号安排诊室 Set 当前分配 = 1 Where Rowid = c_诊室.Rid;
          Exit;
        End If;
        If Nvl(c_诊室.当前分配, 0) = 1 Then
          Update 挂号安排诊室 Set 当前分配 = 0 Where Rowid = c_诊室.Rid;
          n_Next := 1;
        End If;
      End Loop;
      If v_诊室 Is Null Then
        Update 挂号安排诊室 Set 当前分配 = 1 Where Rowid = v_Rowid Returning 门诊诊室 Into v_诊室;
      End If;
    End If;
  
    Return v_诊室;
  End;
  Procedure Third_Cardbalance_Modfiy
  (
    结帐id_In     病人预交记录.结帐id%Type,
    卡类别_In     Varchar2,
    卡号_In       病人预交记录.卡号%Type,
    支付金额_In   病人预交记录.冲预交%Type,
    交易流水号_In 病人预交记录.交易流水号%Type,
    交易说明_In   病人预交记录.交易说明%Type,
    Xmlexpned_In  Xmltype
  ) Is
    n_卡类别id 医疗卡类别.Id%Type;
    v_结算方式 病人预交记录.结算方式%Type;
    v_名称     医疗卡类别.名称%Type;
  Begin
    v_Err_Msg := Null;
    Begin
      n_卡类别id := To_Number(卡类别_In);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
    If n_卡类别id = 0 Then
      Begin
        Select ID, 结算方式, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
        Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
        From 医疗卡类别
        Where 名称 = 卡类别_In;
      Exception
        When Others Then
          n_卡类别id := -1;
          v_Err_Msg  := 卡类别_In || '不存在!';
      End;
    Else
      Begin
        Select ID, 结算方式, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
        Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
        From 医疗卡类别
        Where ID = n_卡类别id;
      Exception
        When Others Then
          n_卡类别id := -1;
          v_Err_Msg  := '未找到指定的结算支付信息!';
      End;
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
    If v_结算方式 Is Null Then
      v_Err_Msg := Nvl(v_名称, '') || '未设置结算方式,请在医疗卡类别中设置结算方式';
      Raise Err_Item;
    End If;
  
    v_收费结算 := v_结算方式 || '|' || 支付金额_In || '|' || ' |' || ' ';
    --结算方式|结算金额|结算号码|结算摘要 
    Zl_门诊收费结算_Modify(1, n_病人id, 结帐id_In, v_收费结算, 0, 0, n_卡类别id, 卡号_In, 交易流水号_In, 交易说明_In, 0, 0, 0, 0);
  
    --保存扩展结算信息
    For c_扩展 In (Select Extractvalue(j.Column_Value, '/EXPEND/JYMC') As Jymc,
                        Extractvalue(j.Column_Value, '/EXPEND/JYLR') As Jylr
                 From Table(Xmlsequence(Extract(Xmlexpned_In, '/EXPENDLIST/EXPEND'))) J) Loop
      Zl_三方结算交易_Insert(n_卡类别id, 0, 卡号_In, 结帐id_In, c_扩展.Jymc || '|' || c_扩展.Jylr, 0);
    End Loop;
  End Third_Cardbalance_Modfiy;

  Procedure Square_Cardbalance_Modfiy
  (
    结帐id_In     病人预交记录.结帐id%Type,
    卡类别_In     Varchar2,
    卡号_In       病人预交记录.卡号%Type,
    支付金额_In   病人预交记录.冲预交%Type,
    交易流水号_In 病人预交记录.交易流水号%Type,
    交易说明_In   病人预交记录.交易说明%Type,
    Xmlexpned_In  Xmltype
  ) Is
    n_卡类别id 医疗卡类别.Id%Type;
    v_结算方式 病人预交记录.结算方式%Type;
    v_名称     卡消费接口目录.名称%Type;
  Begin
    v_Err_Msg := Null;
    Begin
      n_卡类别id := To_Number(卡类别_In);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
  
    If n_卡类别id = 0 Then
      Begin
        Select 编号, 结算方式, Decode(Nvl(启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
        Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
        From 卡消费接口目录
        Where 名称 = 卡类别_In;
      Exception
        When Others Then
          v_Err_Msg := '消费:' || 卡类别_In || '不存在!';
      End;
    
    Else
    
      Begin
        Select 编号, 结算方式, Decode(Nvl(启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
        Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
        From 卡消费接口目录
        Where 编号 = 卡类别_In;
      Exception
        When Others Then
          v_Err_Msg := '未找到指定的结算支付信息!';
      End;
    
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
    If v_结算方式 Is Null Then
      v_Err_Msg := Nvl(v_名称, '') || '未设置结算方式,请在医疗卡类别中设置结算方式';
      Raise Err_Item;
    End If;
  
    Select ID
    Into n_消费卡id
    From 消费卡目录
    Where 接口编号 = n_卡类别id And 卡号 = 卡号_In And
          序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = n_卡类别id And 卡号 = 卡号_In);
  
    --结算方式_IN格式为:卡类别ID|卡号|消费卡ID|消费金额||.... 
    v_收费结算 := n_卡类别id || '|' || 卡号_In || '|' || n_消费卡id || '|' || 支付金额_In;
    Zl_门诊收费结算_Modify(3, n_病人id, 结帐id_In, v_收费结算, 0, 0, n_卡类别id, 卡号_In, 交易流水号_In, 交易说明_In, 0, 0, 0, 0);
    --保存扩展结算信息
    For c_扩展 In (Select Extractvalue(j.Column_Value, '/EXPEND/JYMC') As Jymc,
                        Extractvalue(j.Column_Value, '/EXPEND/JYLR') As Jylr
                 From Table(Xmlsequence(Extract(Xmlexpned_In, '/EXPENDLIST/EXPEND'))) J) Loop
      Zl_三方结算交易_Insert(n_卡类别id, 1, 卡号_In, 结帐id_In, c_扩展.Jymc || '|' || c_扩展.Jylr, 0);
    End Loop;
  End Square_Cardbalance_Modfiy;

Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/NO'), To_Number(Extractvalue(Value(A), 'IN/BRID')),
         To_Number(Extractvalue(Value(A), 'IN/JE')), To_Number(Extractvalue(Value(A), 'IN/WCJE')),
         To_Number(Extractvalue(Value(A), 'IN/SFGH')),Extractvalue(Value(A), 'IN/SFZH'),
		 Extractvalue(Value(A), 'IN/XM')
  Into v_Nos, n_病人id, n_收费总额, n_误差额, n_是否挂号, v_身份证号, v_姓名
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  If Nvl(n_病人id, 0) = 0 And Not v_身份证号 Is Null And Not v_姓名 Is Null Then
    n_病人id := Zl_Third_Getpatiid(v_身份证号, v_姓名);
  End If;
  --0.相关检查

  If Nvl(n_病人id, 0) = 0 Then
    v_Err_Msg := '不能有效识别病人身份,不允许缴费!';
    Raise Err_Item;
  
  End If;

  If v_Nos Is Null Then
    v_Err_Msg := '没有指定相关的收费单据,不允许缴费!';
    Raise Err_Item;
  
  End If;

  --人员id,人员编号,人员姓名 
  v_Temp := Zl_Identity(1);
  If Nvl(v_Temp, '0') = '0' Or Nvl(v_Temp, '_') = '_' Then
    v_Err_Msg := '系统不能认别有效的操作员,不允许缴费!';
    Raise Err_Item;
  End If;
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员编码 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员姓名 := v_Temp;
  v_Err_Msg    := Null;
  Begin
    Select b.编码, a.姓名, a.性别, a.年龄
    Into v_医疗付款方式编码, v_姓名, v_性别, v_年龄
    From 病人信息 A, 医疗付款方式 B
    Where a.医疗付款方式 = b.名称(+) And a.病人id = n_病人id;
  Exception
    When Others Then
      v_Err_Msg := '指定的缴费单据中不能有效识别病人,不允许缴费!';
  End;
  If Not v_Err_Msg Is Null Then
    Raise Err_Item;
  End If;
  Select 病人结帐记录_Id.Nextval, Sysdate Into n_结帐id, d_收费时间 From Dual;

  For c_交易记录 In (Select Extractvalue(b.Column_Value, '/JS/JSKLB') As 结算卡类别,
                        Extractvalue(b.Column_Value, '/JS/JYLSH') As 交易流水号,
                        Extractvalue(b.Column_Value, '/JS/JSKH') As 结算卡号, Extractvalue(b.Column_Value, '/JS/ZY') As 摘要
                 From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B) Loop
    Begin
      n_卡类别id := To_Number(c_交易记录.结算卡类别);
    Exception
      When Others Then
        Select ID Into n_卡类别id From 医疗卡类别 Where 名称 = c_交易记录.结算卡类别;
    End;
    If Zl_Fun_三方交易记录_Locked(n_卡类别id, c_交易记录.交易流水号, c_交易记录.结算卡号, c_交易记录.摘要,n_结帐id) = 0 Then
      v_Err_Msg := '交易流水号为:' || c_交易记录.交易流水号 || '的交易正在进行中，不允许再次提交此交易!';
      Raise Err_Special;
    End If;
  End Loop;

  If Nvl(n_是否挂号, 0) = 0 Then
    --费用单据
    v_发药窗口 := Zl_Getclinicchargepaywins(v_Nos);
  
    --1.进行费用收费处理
    --获取发药窗口
  
    n_结帐金额 := 0;
    For c_缴费单 In (Select /*+ rule */
                   a.No, Max(a.开单部门id) As 开单部门id, Max(a.病人科室id) As 病人科室id, Max(a.病人id) As 病人id, Sum(实收金额) As 实收金额,
                   Max(a.开单人) As 开单人
                  From 门诊费用记录 A, Table(f_Str2list(v_Nos)) J
                  Where a.记录性质 = 1 And a.No = j.Column_Value And a.记录状态 = 0
                  Group By a.No) Loop
      If Nvl(c_缴费单.病人id, 0) <> n_病人id Then
        v_Err_Msg := '缴费单据:' || c_缴费单.No || '与当前病人身份不符,不允许缴费!';
        Raise Err_Item;
      End If;
    
      n_结帐金额 := n_结帐金额 + Nvl(c_缴费单.实收金额, 0);
      Zl_病人划价收费_Insert(c_缴费单.No, n_病人id, 1, v_医疗付款方式编码, v_姓名, v_性别, v_年龄, c_缴费单.病人科室id, c_缴费单.开单部门id, c_缴费单.开单人, n_结帐id,
                       d_收费时间, v_操作员编码, v_操作员姓名, v_发药窗口, 0, d_收费时间);
    
    End Loop;
  
    --检查总金额是否正确 
    If Nvl(n_误差额, 0) = 0 Then
      n_误差额 := Nvl(n_收费总额, 0) - Nvl(n_结帐金额, 0);
      If Abs(n_误差额) > 1.00 Then
        v_Err_Msg := '单据缴款金额与实际结算的误差太大!';
        Raise Err_Item;
      End If;
    End If;
    If Nvl(n_结帐金额, 0) + Nvl(n_误差额, 0) <> Nvl(n_收费总额, 0) Then
      v_Err_Msg := '指定的缴费单据的总金额不对,请重新选择缴费单据!';
      Raise Err_Item;
    End If;
  
    --2.确定支付方式
    n_Count := 0;
    For c_结算方式 In (Select Extractvalue(b.Column_Value, '/JS/JSKLB') As 结算卡类别,
                          Extractvalue(b.Column_Value, '/JS/JSKH') As 结算卡号,
                          Extractvalue(b.Column_Value, '/JS/JSFS') As 结算方式,
                          Extractvalue(b.Column_Value, '/JS/JSJE') As 结算金额,
                          Extractvalue(b.Column_Value, '/JS/JYLSH') As 交易流水号,
                          Extractvalue(b.Column_Value, '/JS/JYSM') As 交易说明, Extractvalue(b.Column_Value, '/JS/ZY') As 摘要,
                          Extractvalue(b.Column_Value, '/JS/SFCYJ') As 是否冲预交,
                          Extractvalue(b.Column_Value, '/JS/SFXFK') As 是否消费卡,
                          Extract(b.Column_Value, '/JS/EXPENDLIST') As Expend
                   From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B) Loop
    
      --1.三方卡结算
    
      If c_结算方式.结算卡类别 Is Not Null And Nvl(c_结算方式.是否消费卡, 0) = 0 Then
        --1.三方卡结算
        Third_Cardbalance_Modfiy(n_结帐id, c_结算方式.结算卡类别, c_结算方式.结算卡号, c_结算方式.结算金额, c_结算方式.交易流水号, c_结算方式.交易说明,
                                 c_结算方式.Expend);
      Elsif c_结算方式.结算卡类别 Is Not Null And Nvl(c_结算方式.是否消费卡, 0) = 1 Then
        --2.消费卡结算
        Square_Cardbalance_Modfiy(n_结帐id, c_结算方式.结算卡类别, c_结算方式.结算卡号, c_结算方式.结算金额, c_结算方式.交易流水号, c_结算方式.交易说明,
                                  c_结算方式.Expend);
      Elsif Nvl(c_结算方式.是否冲预交, 0) = 1 Then
        --3.冲预交款
        Zl_门诊收费结算_Modify(0, n_病人id, n_结帐id, Null, c_结算方式.结算金额, 0, Null, Null, Null, Null, 0, 0, 0, 0);
      Else
        --4.普通结算
        If c_结算方式.结算方式 Is Null Then
          v_Err_Msg := '未指定指付方式，不允缴款!';
          Raise Err_Item;
        End If;
        --结算方式|结算金额|结算号码|结算摘要||..
        v_收费结算 := c_结算方式.结算方式 || '|' || c_结算方式.结算金额 || '| | ';
        v_普通结算 := Nvl(v_普通结算, '') || '||' || v_收费结算;
      End If;
      n_Count := n_Count + 1;
    End Loop;
    If n_Count = 0 Then
      v_Err_Msg := '不能有效确认当前的支付方式!';
      Raise Err_Item;
    End If;
    --5.普通结算及完成结
    If v_普通结算 Is Not Null Then
      v_普通结算 := Substr(v_普通结算, 3);
    End If;
    Zl_门诊收费结算_Modify(0, n_病人id, n_结帐id, v_普通结算, Null, 0, Null, Null, Null, Null, 0, 0, n_误差额, 1);
  Else
    n_结帐金额 := 0;
    --挂号单据
    v_Para     := zl_GetSysParameter(256);
    n_挂号模式 := Substr(v_Para, 1, 1);
    Begin
      d_启用时间 := To_Date(Substr(v_Para, 3), 'yyyy-mm-dd hh24:mi:ss');
    Exception
      When Others Then
        d_启用时间 := Null;
    End;
    For c_费用 In (Select 1 As 顺序号, b.No, b.收据费目, b.结帐id, b.执行部门id, b.病人科室id, b.开单人, b.收费类别, b.收入项目id, b.附加标志,
                        To_Char(b.登记时间, 'yyyy-mm-dd hh24:mi:ss') As 登记时间, b.价格父号, b.从属父号, b.序号, b.收费细目id, b.计算单位,
                        Max(m.名称) As 名称, Max(m.规格) As 规格, Sum(b.标准单价) As 单价, Avg(Nvl(b.付数, 1) * b.数次) As 数量,
                        Sum(b.应收金额) As 应收金额, Sum(b.实收金额) As 实收金额, Max(j.名称) As 开单科室, Max(q.名称) As 执行科室
                 From 门诊费用记录 B, 收费项目目录 M, 部门表 J, 部门表 Q
                 Where b.No = v_Nos And b.记录性质 = 4 And Nvl(b.费用状态, 0) = 0 And b.记录状态 = 0 And b.收费细目id = m.Id And
                       b.开单部门id = j.Id(+) And b.执行部门id = q.Id(+)
                 Group By b.No, b.收据费目, b.结帐id, b.执行部门id, b.病人科室id, b.开单人, b.收入项目id, b.收费类别, b.登记时间, b.价格父号, b.从属父号, b.序号,
                          b.收费细目id, b.计算单位, b.附加标志
                 Order By 序号) Loop
      Zl_病人预约挂号记录_Update(c_费用.No, c_费用.序号, c_费用.价格父号, c_费用.从属父号, c_费用.收费类别, c_费用.收费细目id, c_费用.数量, c_费用.单价, c_费用.收入项目id,
                         c_费用.收据费目, c_费用.应收金额, c_费用.实收金额, c_费用.附加标志, Null, Null, Null, Null, c_费用.病人科室id, c_费用.执行部门id);
      n_结帐金额 := n_结帐金额 + c_费用.实收金额;
    End Loop;
  
    --检查总金额是否正确 
    If Nvl(n_误差额, 0) = 0 Then
      n_误差额 := Nvl(n_收费总额, 0) - Nvl(n_结帐金额, 0);
      If Abs(n_误差额) > 1.00 Then
        v_Err_Msg := '单据缴款金额与实际结算的误差太大!';
        Raise Err_Item;
      End If;
    End If;
    If Nvl(n_结帐金额, 0) + Nvl(n_误差额, 0) <> Nvl(n_收费总额, 0) Then
      Select Max(操作员姓名) Into v_操作员 From 门诊费用记录 Where 记录性质 = 4 And NO = v_Nos;
      If v_操作员 = v_操作员姓名 Then
        v_Err_Msg := '指定的缴费单据的总金额不对,请重新选择缴费单据!';
        Raise Err_Special;
      Else
        v_Err_Msg := '指定的缴费单据的总金额不对,请重新选择缴费单据!';
        Raise Err_Item;
      End If;
    End If;
  
    --预约接收
    Select a.执行部门id, a.收费细目id, c.Id, a.执行人, b.号别, b.门诊号, b.发生时间, a.费别, b.号序, b.出诊记录id
    Into n_科室id, n_项目id, n_医生id, v_医生姓名, v_号码, n_门诊号, d_发生时间, v_费别, n_号序, n_出诊记录id
    From 门诊费用记录 A, 病人挂号记录 B, 人员表 C
    Where a.No = v_Nos And a.记录性质 = 4 And a.序号 = 1 And a.No = b.No And a.执行人 = c.姓名(+);
  
    If n_挂号模式 = 1 Then
      If d_启用时间 > d_发生时间 And n_出诊记录id Is Null Then
        n_挂号模式 := 0;
      End If;
    End If;
  
    Select Decode(To_Number(zl_GetSysParameter('排队叫号模式', 1113, 100)), 0, 0, 1) Into n_生成队列 From Dual;
    If n_挂号模式 = 0 Then
      For c_结算方式 In (Select Extractvalue(b.Column_Value, '/JS/JSKLB') As 结算卡类别,
                            Extractvalue(b.Column_Value, '/JS/JSKH') As 结算卡号,
                            Extractvalue(b.Column_Value, '/JS/JSFS') As 结算方式,
                            Extractvalue(b.Column_Value, '/JS/JSJE') As 结算金额,
                            Extractvalue(b.Column_Value, '/JS/JYLSH') As 交易流水号,
                            Extractvalue(b.Column_Value, '/JS/JYSM') As 交易说明,
                            Extractvalue(b.Column_Value, '/JS/ZY') As 摘要,
                            Extractvalue(b.Column_Value, '/JS/SFCYJ') As 是否冲预交,
                            Extractvalue(b.Column_Value, '/JS/SFXFK') As 是否消费卡
                     From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B) Loop
        If Nvl(c_结算方式.是否冲预交, 0) = 1 Then
          n_预交支付 := c_结算方式.结算金额;
        Else
          If c_结算方式.结算方式 Is Not Null Then
            Select Nvl(Max(1), 0) Into n_Exists From 结算方式 Where 名称 = c_结算方式.结算方式 And 性质 In (3, 4);
            If n_Exists = 1 Then
              n_医保支付 := c_结算方式.结算金额;
            Else
              If Nvl(n_普通支付, 0) = 0 Then
                n_普通支付 := c_结算方式.结算金额;
                v_结算方式 := c_结算方式.结算方式;
                If Nvl(c_结算方式.是否消费卡, 0) = 1 Then
                  Begin
                    n_结算卡序号 := To_Number(c_结算方式.结算卡类别);
                  Exception
                    When Others Then
                      n_结算卡序号 := 0;
                  End;
                  If n_结算卡序号 = 0 Then
                    Begin
                      Select 编号
                      Into n_结算卡序号
                      From 卡消费接口目录
                      Where 名称 = c_结算方式.结算卡类别 And Nvl(启用, 0) = 1;
                    Exception
                      When Others Then
                        v_Err_Msg := '未找到对应的消费卡!';
                        Raise Err_Item;
                    End;
                  End If;
                  If v_结算方式 Is Null Then
                    Select 结算方式 Into v_结算方式 From 卡消费接口目录 Where 编号 = n_结算卡序号;
                  End If;
                Else
                  Begin
                    n_卡类别id := To_Number(c_结算方式.结算卡类别);
                  Exception
                    When Others Then
                      n_卡类别id := 0;
                  End;
                  If n_卡类别id = 0 Then
                    Begin
                      Select ID
                      Into n_卡类别id
                      From 医疗卡类别
                      Where 名称 = c_结算方式.结算卡类别 And Nvl(是否启用, 0) = 1;
                    Exception
                      When Others Then
                        v_Err_Msg := '未找到对应的医疗卡!';
                        Raise Err_Item;
                    End;
                  End If;
                  If v_结算方式 Is Null Then
                    Select 结算方式 Into v_结算方式 From 医疗卡类别 Where ID = n_卡类别id;
                  End If;
                End If;
                v_结算卡号   := c_结算方式.结算卡号;
                v_交易流水号 := c_结算方式.交易流水号;
                v_交易说明   := c_结算方式.交易说明;
                v_摘要       := c_结算方式.摘要;
              Else
                v_Err_Msg := '挂号结算暂不支持多种结算方式!';
                Raise Err_Item;
              End If;
            End If;
          Else
            If Nvl(n_普通支付, 0) = 0 Then
              n_普通支付 := c_结算方式.结算金额;
              v_结算方式 := c_结算方式.结算方式;
              If Nvl(c_结算方式.是否消费卡, 0) = 1 Then
                Begin
                  n_结算卡序号 := To_Number(c_结算方式.结算卡类别);
                Exception
                  When Others Then
                    n_结算卡序号 := 0;
                End;
                If n_结算卡序号 = 0 Then
                  Begin
                    Select 编号
                    Into n_结算卡序号
                    From 卡消费接口目录
                    Where 名称 = c_结算方式.结算卡类别 And Nvl(启用, 0) = 1;
                  Exception
                    When Others Then
                      v_Err_Msg := '未找到对应的消费卡!';
                      Raise Err_Item;
                  End;
                End If;
                If v_结算方式 Is Null Then
                  Select 结算方式 Into v_结算方式 From 卡消费接口目录 Where 编号 = n_结算卡序号;
                End If;
              Else
                Begin
                  n_卡类别id := To_Number(c_结算方式.结算卡类别);
                Exception
                  When Others Then
                    n_卡类别id := 0;
                End;
                If n_卡类别id = 0 Then
                  Begin
                    Select ID
                    Into n_卡类别id
                    From 医疗卡类别
                    Where 名称 = c_结算方式.结算卡类别 And Nvl(是否启用, 0) = 1;
                  Exception
                    When Others Then
                      v_Err_Msg := '未找到对应的医疗卡!';
                      Raise Err_Item;
                  End;
                End If;
                If v_结算方式 Is Null Then
                  Select 结算方式 Into v_结算方式 From 医疗卡类别 Where ID = n_卡类别id;
                End If;
              End If;
              v_结算卡号   := c_结算方式.结算卡号;
              v_交易流水号 := c_结算方式.交易流水号;
              v_交易说明   := c_结算方式.交易说明;
              v_摘要       := c_结算方式.摘要;
            Else
              v_Err_Msg := '挂号结算暂不支持多种结算方式!';
              Raise Err_Item;
            End If;
          End If;
        End If;
      End Loop;
      Zl_预约挂号接收_Insert(v_Nos, Null, Null, n_结帐id, Zl_诊室(v_号码), n_病人id, n_门诊号, v_姓名, v_性别, v_年龄, v_医疗付款方式编码, v_费别,
                       v_结算方式, n_普通支付, n_预交支付, n_医保支付, d_发生时间, n_号序, v_操作员编码, v_操作员姓名, n_生成队列, d_收费时间, n_卡类别id, n_结算卡序号,
                       v_结算卡号, v_交易流水号, v_交易说明, Null, 0, 0, Null, 1);
    Else
      For c_结算方式 In (Select Extractvalue(b.Column_Value, '/JS/JSKLB') As 结算卡类别,
                            Extractvalue(b.Column_Value, '/JS/JSKH') As 结算卡号,
                            Extractvalue(b.Column_Value, '/JS/JSFS') As 结算方式,
                            Extractvalue(b.Column_Value, '/JS/JSJE') As 结算金额,
                            Extractvalue(b.Column_Value, '/JS/JYLSH') As 交易流水号,
                            Extractvalue(b.Column_Value, '/JS/JYSM') As 交易说明,
                            Extractvalue(b.Column_Value, '/JS/ZY') As 摘要,
                            Extractvalue(b.Column_Value, '/JS/SFCYJ') As 是否冲预交,
                            Extractvalue(b.Column_Value, '/JS/SFXFK') As 是否消费卡
                     From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B) Loop
        If Nvl(c_结算方式.是否冲预交, 0) = 1 Then
          n_预交支付 := c_结算方式.结算金额;
        Else
          n_普通支付 := Nvl(n_普通支付, 0) + c_结算方式.结算金额;
          If c_结算方式.结算方式 Is Null Then
            --三方卡结算方式
            If Nvl(c_结算方式.是否消费卡, 0) = 1 Then
              Begin
                n_结算卡序号 := To_Number(c_结算方式.结算卡类别);
              Exception
                When Others Then
                  n_结算卡序号 := 0;
              End;
              If n_结算卡序号 = 0 Then
                Begin
                  Select 编号
                  Into n_结算卡序号
                  From 卡消费接口目录
                  Where 名称 = c_结算方式.结算卡类别 And Nvl(启用, 0) = 1;
                Exception
                  When Others Then
                    v_Err_Msg := '未找到对应的消费卡!';
                    Raise Err_Item;
                End;
              End If;
              Select 结算方式 Into v_临时结算方式 From 卡消费接口目录 Where 编号 = n_结算卡序号;
            Else
              Begin
                n_卡类别id := To_Number(c_结算方式.结算卡类别);
              Exception
                When Others Then
                  n_卡类别id := 0;
              End;
              If n_卡类别id = 0 Then
                Begin
                  Select ID
                  Into n_卡类别id
                  From 医疗卡类别
                  Where 名称 = c_结算方式.结算卡类别 And Nvl(是否启用, 0) = 1;
                Exception
                  When Others Then
                    v_Err_Msg := '未找到对应的医疗卡!';
                    Raise Err_Item;
                End;
              End If;
              Select 结算方式 Into v_临时结算方式 From 医疗卡类别 Where ID = n_卡类别id;
            End If;
            v_结算卡号   := c_结算方式.结算卡号;
            v_交易流水号 := c_结算方式.交易流水号;
            v_交易说明   := c_结算方式.交易说明;
            v_摘要       := c_结算方式.摘要;
            v_结算方式   := v_结算方式 || '|' || v_临时结算方式 || ',' || c_结算方式.结算金额 || ',,1';
          Else
            --其他结算方式
            v_结算方式 := v_结算方式 || '|' || c_结算方式.结算方式 || ',' || c_结算方式.结算金额 || ',,1';
          End If;
        End If;
      End Loop;
      If v_结算方式 Is Not Null Then
        v_结算方式 := Substr(v_结算方式, 2);
      End If;
      Zl_预约挂号接收_出诊_Insert(v_Nos, Null, Null, n_结帐id, Zl_出诊诊室(n_出诊记录id), n_病人id, n_门诊号, v_姓名, v_性别, v_年龄, v_医疗付款方式编码,
                          v_费别, v_结算方式, n_普通支付, n_预交支付, Null, d_发生时间, n_号序, v_操作员编码, v_操作员姓名, n_生成队列, d_收费时间, n_卡类别id,
                          n_结算卡序号, v_结算卡号, v_交易流水号, v_交易说明, Null, 0, 0, Null, 1);
    End If;
    --处理扩展信息
    If Nvl(n_卡类别id, 0) <> 0 Then
      For c_扩展信息 In (Select Extractvalue(b.Column_Value, '/EXPEND/JYMC') As 交易名称,
                            Extractvalue(b.Column_Value, '/EXPEND/JYLR') As 交易内容
                     From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS/EXPENDLIST/EXPEND'))) B) Loop
        Zl_三方结算交易_Insert(n_卡类别id, 0, v_结算卡号, n_结帐id, c_扩展信息.交易名称 || '|' || c_扩展信息.交易内容, 0);
      End Loop;
    End If;
    If Nvl(n_结算卡序号, 0) <> 0 Then
      For c_扩展信息 In (Select Extractvalue(b.Column_Value, '/EXPEND/JYMC') As 交易名称,
                            Extractvalue(b.Column_Value, '/EXPEND/JYLR') As 交易内容
                     From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS/EXPENDLIST/EXPEND'))) B) Loop
        Zl_三方结算交易_Insert(n_结算卡序号, 1, v_结算卡号, n_结帐id, c_扩展信息.交易名称 || '|' || c_扩展信息.交易内容, 0);
      End Loop;
    End If;
    --处理汇总
    Zl_病人挂号汇总_Update(v_医生姓名, n_医生id, n_项目id, n_科室id, d_发生时间, 2, v_号码, 1, n_出诊记录id);
  End If;
  v_Temp := '<CZSJ>' || To_Char(d_收费时间, 'YYYY-MM-DD hh24:mi:ss') || '</CZSJ>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  v_Temp := '<JZID>' || n_结帐id || '</JZID>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Err_Special Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20105, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Payment;
/

--111342:焦博,2017-07-10,调整公共函数Zl_Third_Getpatiid增加传入参数姓名_IN
--110711:焦博,2017-06-28,增加入参节点身份证号,当病人ID不存在时,用身份证号获取病人ID
Create Or Replace Procedure Zl_Third_Settlement
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is

  --------------------------------------------------------------------------------------------------
  --功能:三方接口支付
  --入参:Xml_In:
  --<IN>
  --        <BRID>病人ID</BRID>         //病人ID
  --        <XM>姓名</XM>               //姓名
  --        <SFZH>身份证号</SFZH>       //身份证号
  --        <ZYID>主页ID</ZYID>         //主页ID
  --        <JSLX>2</JSLX>         //结算类型,1-门诊,2-住院.目前固定传2
  --        <JE></JE>         //本次结算总金额
  --       <JSLIST>
  --         <JS>
  --              <JSKLB>支付卡类别</JSKLB >
  --              <JSKH>支付卡号</ JSKH >
  --              <JSFS>支付方式</JSFS> //支付方式:现金;支票,如果是三方卡,可以传空
  --              <JSJE>结算金额</JSJE> //结算金额(正金额：个人补款，负金额：医院退款)<SFCYJ>为1时为冲预交金额
  --              <JYLSH>交易流水号</JYLSH>
  --              <ZY>摘要</ZY>
  --              <SFCYJ>是否冲预交</SFCYJ>  //是否冲预交，0-结算，1-冲预交.允冲预交时,只填JSJE节点
  --              <SFXFK>是否消费卡</SFXFK>  //(1-是消费卡),消费卡时,传入结算卡类别,结算卡号,结算金额等接点
  --              <EXPENDLIST>  //扩展交易信息
  --                  <EXPEND>
  --                        <JYMC>交易名称</JYMC> //交易名称   退款时,传入冲预交的流水号
  --                        <JYLR>交易内容</JYLR> //交易内容   退款时,传入冲预交的金额
  --                  </EXPEND>
  --              </EXPENDLIST>
  --         </JS>
  --       </JSLIST >
  --</IN>

  --出参:Xml_Out
  --  <OUT>
  --    <CZSJ>操作时间</CZSJ>          //HIS的登记时间
  --    DD如无下列错误结点则说明正确执行
  --    <ERROR>
  --      <MSG>错误信息</MSG>
  --    </ERROR>
  --  </OUT>
  --------------------------------------------------------------------------------------------------
  n_主页id     病案主页.主页id%Type;
  n_病人id     病案主页.病人id%Type;
  v_姓名         病人信息.姓名%Type;
  v_身份证号     病人信息.身份证号%Type;
  n_结帐总额   病人预交记录.冲预交%Type;
  n_待结帐金额 病人预交记录.冲预交%Type;
  n_结算类型   Number(3);
  v_操作员编码 病人结帐记录.操作员编号%Type;
  v_操作员姓名 病人结帐记录.操作员姓名%Type;
  n_结帐id     病人结帐记录.Id%Type;
  n_冲预交金额 病人预交记录.冲预交%Type;
  d_结帐时间   Date;
  d_开始日期   Date;
  d_结束日期   Date;
  n_存在       Number(3);
  n_结算卡序号 卡消费接口目录.编号%Type;
  n_时间类型   Number(3);
  v_No         病人结帐记录.No%Type;
  n_卡类别id   医疗卡类别.Id%Type;
  v_结算卡号   病人预交记录.卡号%Type;
  v_结算方式   病人预交记录.结算方式%Type;
  v_Temp       Varchar2(500);
  v_Ids        Varchar2(20000);
  x_Templet    Xmltype; --模板XML
  v_Err_Msg    Varchar2(200);
  Err_Item Exception;
  Err_Special Exception;
  n_Count Number(18);

Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/ZYID'), To_Number(Extractvalue(Value(A), 'IN/BRID')),
         To_Number(Extractvalue(Value(A), 'IN/JE')), To_Number(Extractvalue(Value(A), 'IN/JSLX')),
		 Extractvalue(Value(A), 'IN/SFZH'),Extractvalue(Value(A), 'IN/XM')
  Into n_主页id, n_病人id, n_结帐总额, n_结算类型, v_身份证号, v_姓名
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  n_结算类型 := Nvl(n_结算类型, 2);
  If n_结算类型 = 1 And Nvl(n_病人id, 0) = 0 And Not v_身份证号 Is Null And Not v_姓名 Is Null Then
    n_病人id := Zl_Third_Getpatiid(v_身份证号, v_姓名);
  End If;
  --0.相关检查
  If Nvl(n_病人id, 0) = 0 Then
    v_Err_Msg := '不能有效识别病人身份,不允许缴费!';
    Raise Err_Item;
  End If;

  --人员id,人员编号,人员姓名
  v_Temp := Zl_Identity(1);
  If Nvl(v_Temp, '0') = '0' Or Nvl(v_Temp, '_') = '_' Then
    v_Err_Msg := '系统不能认别有效的操作员,不允许结算!';
    Raise Err_Item;
  End If;
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员编码 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员姓名 := v_Temp;
  v_Err_Msg    := Null;

  Select 病人结帐记录_Id.Nextval, Sysdate, Nextno(15) Into n_结帐id, d_结帐时间, v_No From Dual;

  For c_交易记录 In (Select Extractvalue(b.Column_Value, '/JS/JSKLB') As 结算卡类别,
                        Extractvalue(b.Column_Value, '/JS/JYLSH') As 交易流水号,
                        Extractvalue(b.Column_Value, '/JS/JSKH') As 结算卡号, Extractvalue(b.Column_Value, '/JS/ZY') As 摘要
                 From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B) Loop
    Begin
      n_卡类别id := To_Number(c_交易记录.结算卡类别);
    Exception
      When Others Then
        Select ID Into n_卡类别id From 医疗卡类别 Where 名称 = c_交易记录.结算卡类别;
    End;
    If Zl_Fun_三方交易记录_Locked(n_卡类别id, c_交易记录.交易流水号, c_交易记录.结算卡号, c_交易记录.摘要,n_结帐id) = 0 Then
      v_Err_Msg := '交易流水号为:' || c_交易记录.交易流水号 || '的交易正在进行中，不允许再次提交此交易!';
      Raise Err_Special;
    End If;
  End Loop;
  
  If n_结算类型 = 2 Then
    Begin
      Select Sum(Nvl(实收金额, 0)) - Sum(Nvl(结帐金额, 0))
      Into n_待结帐金额
      From 住院费用记录
      Where 病人id = n_病人id And 记录状态 <> 0 And 主页id = n_主页id And 记帐费用 = 1;
    Exception
      When Others Then
        n_待结帐金额 := 0;
    End;
  
    If n_待结帐金额 <> n_结帐总额 Then
      v_Err_Msg := '传入的结帐金额与实际结帐金额不符,不允许结算!';
      Raise Err_Item;
    End If;
  
  
    n_时间类型 := zl_GetSysParameter('结帐费用时间', 1137);
    If n_时间类型 = 0 Then
      --按登记时间
      Select Trunc(Min(登记时间)), Trunc(Max(登记时间))
      Into d_开始日期, d_结束日期
      From (Select NO, 序号, 登记时间, 发生时间
             From 住院费用记录
             Where 病人id = n_病人id And 记录状态 <> 0 And 主页id = n_主页id And 记帐费用 = 1
             Group By NO, 序号, 登记时间, 发生时间, Mod(记录性质, 10)
             Having Sum(Nvl(实收金额, 0)) - Sum(Nvl(结帐金额, 0)) <> 0);
    Else
      --按发生时间  
      Select Trunc(Min(发生时间)), Trunc(Max(发生时间))
      Into d_开始日期, d_结束日期
      From (Select NO, 序号, 登记时间, 发生时间
             From 住院费用记录
             Where 病人id = n_病人id And 记录状态 <> 0 And 主页id = n_主页id And 记帐费用 = 1
             Group By NO, 序号, 登记时间, 发生时间, Mod(记录性质, 10)
             Having Sum(Nvl(实收金额, 0)) - Sum(Nvl(结帐金额, 0)) <> 0);
    End If;
  
    Zl_病人结帐记录_Insert(n_结帐id, v_No, n_病人id, d_结帐时间, d_开始日期, d_结束日期, 0, 0, n_主页id, Null, 2, Null, 2, 0, n_主页id, n_结帐总额);
  
    For r_费用 In (Select Min(ID) As ID, Mod(记录性质, 10) As 记录性质, NO, 序号, 记录状态, 执行状态,
                        Sum(Nvl(实收金额, 0)) - Sum(Nvl(结帐金额, 0)) As 金额, Sum(Nvl(结帐金额, 0)) As 结帐金额
                 From 住院费用记录
                 Where 病人id = n_病人id And 记录状态 <> 0 And 主页id = n_主页id And 记帐费用 = 1
                 Group By Mod(记录性质, 10), NO, 序号, 记录状态, 执行状态
                 Having Sum(Nvl(实收金额, 0)) - Sum(Nvl(结帐金额, 0)) <> 0
                 Order By NO, 序号) Loop
      If Nvl(r_费用.结帐金额, 0) = 0 Then
        Begin
          Select 1 Into n_存在 From 住院费用记录 Where ID = r_费用.Id And 结帐id Is Null;
        Exception
          When Others Then
            n_存在 := 0;
        End;
        If n_存在 = 1 Then
          v_Ids := v_Ids || ',' || r_费用.Id;
        Else
          Zl_结帐费用记录_Insert(0, r_费用.No, r_费用.记录性质, r_费用.记录状态, r_费用.执行状态, r_费用.序号, r_费用.金额, n_结帐id);
        End If;
      Else
        Zl_结帐费用记录_Insert(0, r_费用.No, r_费用.记录性质, r_费用.记录状态, r_费用.执行状态, r_费用.序号, r_费用.金额, n_结帐id);
      End If;
    End Loop;
    
    If v_Ids Is Not Null Then
      v_Ids := Substr(v_Ids, 2);
      Zl_结帐费用记录_Batch(v_Ids, n_病人id, n_结帐id);
    End If;
  
    n_Count := 0;
    For r_结算方式 In (Select Extractvalue(b.Column_Value, '/JS/JSKLB') As 结算卡类别,
                          Extractvalue(b.Column_Value, '/JS/JSKH') As 结算卡号,
                          Extractvalue(b.Column_Value, '/JS/JSFS') As 结算方式,
                          Extractvalue(b.Column_Value, '/JS/JSJE') As 结算金额,
                          Extractvalue(b.Column_Value, '/JS/JYLSH') As 交易流水号,
                          Extractvalue(b.Column_Value, '/JS/JYSM') As 交易说明, Extractvalue(b.Column_Value, '/JS/ZY') As 摘要,
                          Extractvalue(b.Column_Value, '/JS/SFCYJ') As 是否冲预交,
                          Extractvalue(b.Column_Value, '/JS/SFXFK') As 是否消费卡,
                          Xmlsequence(Extract(b.Column_Value, '/JS/EXPENDLIST')) As Expend
                   From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B) Loop
      If Nvl(r_结算方式.是否冲预交, 0) = 0 Then
        --付款
        If n_Count = 1 Then
          v_Err_Msg := '结帐结算暂不支持多种结算方式!';
          Raise Err_Item;
        End If;
        If Nvl(r_结算方式.是否消费卡, 0) = 1 Then
          Begin
            n_结算卡序号 := To_Number(r_结算方式.结算卡类别);
          Exception
            When Others Then
              n_结算卡序号 := 0;
          End;
          If n_结算卡序号 = 0 Then
            Begin
              Select 编号
              Into n_结算卡序号
              From 卡消费接口目录
              Where 名称 = r_结算方式.结算卡类别 And Nvl(启用, 0) = 1;
            Exception
              When Others Then
                v_Err_Msg := '未找到对应的消费卡!';
                Raise Err_Item;
            End;
          End If;
          If v_结算方式 Is Null Then
            Select 结算方式 Into v_结算方式 From 卡消费接口目录 Where 编号 = n_结算卡序号;
          End If;
        Else
          Begin
            n_卡类别id := To_Number(r_结算方式.结算卡类别);
          Exception
            When Others Then
              n_卡类别id := 0;
          End;
          If n_卡类别id = 0 Then
            Begin
              Select ID Into n_卡类别id From 医疗卡类别 Where 名称 = r_结算方式.结算卡类别 And Nvl(是否启用, 0) = 1;
            Exception
              When Others Then
                v_Err_Msg := '未找到对应的医疗卡!';
                Raise Err_Item;
            End;
          End If;
          If v_结算方式 Is Null Then
            Select 结算方式 Into v_结算方式 From 医疗卡类别 Where ID = n_卡类别id;
          End If;
        End If;
      
        If n_卡类别id Is Not Null Then
          --三方卡
          v_结算方式 := v_结算方式 || '|' || r_结算方式.结算金额 || '|';
          Zl_病人结帐结算_Modify(1, n_病人id, n_结帐id, v_结算方式, Null, 0, n_卡类别id, r_结算方式.结算卡号, r_结算方式.交易流水号, r_结算方式.交易说明, 0, 0, 0,
                           2, Null, v_操作员编码, v_操作员姓名, d_结帐时间, Null, 0);
        Else
          If n_结算卡序号 Is Not Null Then
            --消费卡
            v_结算卡号 := r_结算方式.结算卡号;
            v_结算方式 := n_结算卡序号 || '|' || r_结算方式.结算卡号 || '|0|' || r_结算方式.结算金额 || '||';
            Zl_病人结帐结算_Modify(3, n_病人id, n_结帐id, v_结算方式, Null, 0, n_卡类别id, r_结算方式.结算卡号, r_结算方式.交易流水号, r_结算方式.交易说明, 0, 0,
                             0, 2, Null, v_操作员编码, v_操作员姓名, d_结帐时间, Null, 0);
          Else
            --其他结算
            v_结算方式 := r_结算方式.结算方式 || '|' || r_结算方式.结算金额 || '||';
            Zl_病人结帐结算_Modify(0, n_病人id, n_结帐id, v_结算方式, Null, 0, n_卡类别id, r_结算方式.结算卡号, r_结算方式.交易流水号, r_结算方式.交易说明, 0, 0,
                             0, 2, Null, v_操作员编码, v_操作员姓名, d_结帐时间, Null, 0);
          End If;
        End If;
      
        n_Count := 1;
      Else
        --冲预交,目前默认全冲
        n_冲预交金额 := r_结算方式.结算金额;
        For r_预交 In (Select Min(ID) As ID, NO, 结算方式, Sum(Nvl(金额, 0)) - Sum(Nvl(冲预交, 0)) As 金额, 交易流水号
                     From 病人预交记录
                     Where 病人id = n_病人id And Mod(记录性质, 10) = 1 And Nvl(预交类别, 2) = 2 And (主页id = n_主页id Or 主页id Is Null)
                     Group By NO, 结算方式, 交易流水号
                     Having Sum(Nvl(金额, 0)) - Sum(Nvl(冲预交, 0)) <> 0) Loop
          Zl_结帐预交记录_Insert(r_预交.Id, r_预交.No, 1, r_预交.金额, n_结帐id, n_病人id, v_操作员编码, v_操作员姓名, d_结帐时间);
          n_冲预交金额 := n_冲预交金额 - Nvl(r_预交.金额, 0);
        End Loop;
        If n_冲预交金额 <> 0 Then
          v_Err_Msg := '传入的预交冲销金额与实际不符,请检查!';
          Raise Err_Item;
        End If;
      End If;
    End Loop;
  
    --处理扩展信息
    If Nvl(n_卡类别id, 0) <> 0 Then
      For c_扩展信息 In (Select Extractvalue(b.Column_Value, '/EXPEND/JYMC') As 交易名称,
                            Extractvalue(b.Column_Value, '/EXPEND/JYLR') As 交易内容
                     From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS/EXPENDLIST/EXPEND'))) B) Loop
        Zl_三方结算交易_Insert(n_卡类别id, 0, v_结算卡号, n_结帐id, c_扩展信息.交易名称 || '|' || c_扩展信息.交易内容, 0);
      End Loop;
    End If;
    If Nvl(n_结算卡序号, 0) <> 0 Then
      For c_扩展信息 In (Select Extractvalue(b.Column_Value, '/EXPEND/JYMC') As 交易名称,
                            Extractvalue(b.Column_Value, '/EXPEND/JYLR') As 交易内容
                     From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS/EXPENDLIST/EXPEND'))) B) Loop
        Zl_三方结算交易_Insert(n_结算卡序号, 1, v_结算卡号, n_结帐id, c_扩展信息.交易名称 || '|' || c_扩展信息.交易内容, 0);
      End Loop;
    End If;
  
    Zl_病人结帐结算_Modify(0, n_病人id, n_结帐id, '', Null, 0, Null, Null, Null, Null, 0, 0, 0, 2, Null, v_操作员编码, v_操作员姓名, d_结帐时间,
                     Null, 1);
  End If;
  Update 病人预交记录 Set 校对标志 = 0 Where 结帐id = n_结帐id And Nvl(校对标志, 0) <> 0;
  v_Temp := '<CZSJ>' || To_Char(d_结帐时间, 'YYYY-MM-DD hh24:mi:ss') || '</CZSJ>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Err_Special Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20105, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Settlement;
/

--111342:焦博,2017-07-10,调整公共函数Zl_Third_Getpatiid增加传入参数姓名_IN
--110711:焦博,2017-06-28,增加入参节点身份证号,当病人ID不存在时,用身份证号来获取病人ID
Create Or Replace Procedure Zl_Third_Getsettlement
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取HIS结帐数据
  --入参:Xml_In:
  --<IN>
  -- <BRID></BRID>       //病人ID
  -- <XM></XM>          //姓名
  -- <SFZH></SFZH>       //身份证号  
  -- <ZYID></ZYID>         //主页ID
  -- <JSLX></JSLX>       //结算类型。1-门诊,2-住院。固定传2
  -- <JSKLB></JSKLB>       //结算卡类别
  --</IN>
  --出参:Xml_Out
  --<OUTPUT>
  --<JBXX>              //基本信息
  --   <XM></XM>           //姓名
  --   <XB></XB>           //性别
  --   <NL></NL>         //年龄
  --   <ZYH></ ZYH>        //住院号
  --   <ZYKS></ ZYKS>          //住院科室  
  --   <KSID></KSID>         //科室ID
  --   <ZZYS></ ZZYS>          //主治医生  
  --   <RYSJ></ RYSJ>          //入院时间
  --   <CYSJ></ CYSJ >         //出院时间 
  --   <JZSJ></JZSJ>         //结帐时间(未结帐为空)
  --   <DJH></DJH>         //单据号(未结帐为空)
  --   <JSZFY></JSZFY>         //结算总费用
  --</JBXX>
  --<YJKLIST>              //冲抵预缴款集合
  --   <ITEM>
  --     <DJH><DJH>        //预交款单据号
  --     <JSFS></JSFS>     //结算方式（为名称，返回什么就取什么）
  --     <JE></JE>           //预缴款金额
  --     <JYLSH></JYLSH>       //交易流水号（便于冲销使用）
  --     <SFJSK></SFJSK>       //是否结算卡，1-是，0-否。如果是由传入的卡类别缴费，返回1，否则返回0
  --   </ITEM>
  --</YJKLIST >
  --<TBQK>               //退补情况
  --   <TBLX></TBLX>         //退补类型(1:个人补款，2:医院退款)
  --   <TBJE></TBJE>         //退补金额
  --</TBQK>
  -- <ERROR><MSG></MSG></ERROR>    //出现错误时返回具体原因，error节点为空表示成功
  --</OUTPUT>  

  --------------------------------------------------------------------------------------------------
  n_病人id     病人信息.病人id%Type;
  v_姓名       病人信息.姓名%Type;
  v_身份证号   病人信息.身份证号%Type;
  n_主页id     病人信息.主页id%Type;
  n_结算类型   Number(3);
  n_卡类别id   医疗卡类别.Id%Type;
  v_结算卡类别 Varchar2(200);
  n_是否结清   Number(3); -- 1-未结清,0-结清
  n_结帐金额   住院费用记录.结帐金额%Type;
  v_Temp       Varchar2(32767); --临时XML
  v_Subtemp    Varchar2(32767);
  v_结帐ids    Varchar2(5000);
  n_退补金额   病人预交记录.冲预交%Type;
  n_病人余额   病人预交记录.金额%Type;
  n_结帐id     病人预交记录.结帐id%Type;
  x_Templet    Xmltype; --模板XML
  v_Err_Msg    Varchar2(200);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/BRID'), Extractvalue(Value(A), 'IN/ZYID'), Extractvalue(Value(A), 'IN/JSLX'),
         Extractvalue(Value(A), 'IN/JSKLB'), Extractvalue(Value(A), 'IN/SFZH'),Extractvalue(Value(A), 'IN/XM')
  Into n_病人id, n_主页id, n_结算类型, v_结算卡类别, v_身份证号, v_姓名
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  --默认住院结帐
  n_结算类型 := Nvl(n_结算类型, 2);
  If n_结算类型 = 1 And Nvl(n_病人id, 0) = 0 And Not v_身份证号 Is Null And Not v_姓名 Is Null Then
    n_病人id := Zl_Third_Getpatiid(v_身份证号, v_姓名);
  End If;
  If Nvl(n_病人id, 0) = 0 Then
    v_Err_Msg := '无法确定病人信息,请检查!';
    Raise Err_Item;
  End If;
  Begin
    Select ID Into n_卡类别id From 医疗卡类别 Where 名称 = v_结算卡类别;
  Exception
    When Others Then
      v_Err_Msg := '无法确认传入的结算卡,请检查!';
      Raise Err_Item;
  End;
  If n_结算类型 = 2 Then
    Begin
      Select Distinct 1
      Into n_是否结清
      From 住院费用记录
      Where 病人id = n_病人id And 记录状态 <> 0 And 主页id = n_主页id And 记帐费用 = 1 Having
       Sum(Nvl(实收金额, 0)) - Sum(Nvl(结帐金额, 0)) <> 0;
    Exception
      When Others Then
        n_是否结清 := 0;
    End;
    If n_是否结清 = 0 Then
      --结清,读取结帐数据
      For r_结帐 In (Select 姓名, 性别, 年龄, 住院号, 住院科室, 科室id, 主治医生, To_Char(入院时间, 'yyyy-mm-dd') As 入院时间,
                          To_Char(出院时间, 'yyyy-mm-dd') As 出院时间, To_Char(结帐时间, 'yyyy-mm-dd') As 结帐时间, 单据号, 结算总费用, 结帐id
                   From (Select c.姓名, c.性别, c.年龄, c.住院号, d.名称 As 住院科室, c.入院科室id As 科室id, c.住院医师 As 主治医生, c.入院日期 As 入院时间,
                                 c.出院日期 As 出院时间, a.收费时间 As 结帐时间, a.No As 单据号, a.结帐金额 As 结算总费用, a.Id As 结帐id
                          From 病人结帐记录 A, 病案主页 C, 部门表 D
                          Where a.记录状态 = 1 And Nvl(a.结算状态, 0) In (0, 2) And a.病人id = c.病人id And a.病人id = n_病人id And
                                a.主页id = n_主页id And a.主页id = c.主页id And c.入院科室id = d.Id(+) And Exists
                           (Select 1 From 病人预交记录 Where 结帐id = a.Id And 结算方式 = v_结算卡类别)
                          Order By 结帐时间 Desc)
                   Where Rownum < 2) Loop
        v_Temp := '<XM>' || r_结帐.姓名 || '</XM>';
        v_Temp := v_Temp || '<XB>' || r_结帐.性别 || '</XB>';
        v_Temp := v_Temp || '<NL>' || r_结帐.年龄 || '</NL>';
        v_Temp := v_Temp || '<ZYH>' || r_结帐.住院号 || '</ZYH>';
        v_Temp := v_Temp || '<ZYKS>' || r_结帐.住院科室 || '</ZYKS>';
        v_Temp := v_Temp || '<KSID>' || r_结帐.科室id || '</KSID>';
        v_Temp := v_Temp || '<ZZYS>' || r_结帐.主治医生 || '</ZZYS>';
        v_Temp := v_Temp || '<RYSJ>' || r_结帐.入院时间 || '</RYSJ>';
        v_Temp := v_Temp || '<CYSJ>' || r_结帐.出院时间 || '</CYSJ>';
        v_Temp := v_Temp || '<JZSJ>' || r_结帐.结帐时间 || '</JZSJ>';
        v_Temp := v_Temp || '<DJH>' || r_结帐.单据号 || '</DJH>';
        v_Temp := v_Temp || '<JSZFY>' || r_结帐.结算总费用 || '</JSZFY>';
        v_Temp := '<JBXX>' || v_Temp || '</JBXX>';
        Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
        n_结帐id := r_结帐.结帐id;
      End Loop;
      If n_结帐id Is Null Then
        v_Err_Msg := '该病人没有结帐数据!';
        Raise Err_Item;
      End If;
      v_Temp := '';
      For r_预交 In (Select NO As 单据号, 结算方式, Sum(冲预交) As 金额, 交易流水号, Max(卡类别id) As 卡类别id
                   From 病人预交记录
                   Where 结帐id = n_结帐id And Mod(记录性质, 10) = 1
                   Group By NO, 结算方式, 交易流水号
                   Order By 单据号 Desc) Loop
        v_Temp := '<DJH>' || r_预交.单据号 || '</DJH>';
        v_Temp := v_Temp || '<JSFS>' || r_预交.结算方式 || '</JSFS>';
        v_Temp := v_Temp || '<JE>' || r_预交.金额 || '</JE>';
        v_Temp := v_Temp || '<JYLSH>' || r_预交.交易流水号 || '</JYLSH>';
        If n_卡类别id = r_预交.卡类别id Then
          v_Temp := v_Temp || '<SFJSK>' || 1 || '</SFJSK>';
        Else
          v_Temp := v_Temp || '<SFJSK>' || 0 || '</SFJSK>';
        End If;
        v_Temp    := '<ITEM>' || v_Temp || '</ITEM>';
        v_Subtemp := v_Subtemp || v_Temp;
      End Loop;
      v_Subtemp := '<YJKLIST>' || v_Subtemp || '</YJKLIST>';
      Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Subtemp)) Into x_Templet From Dual;
      Select Nvl(Sum(冲预交), 0)
      Into n_退补金额
      From 病人预交记录
      Where 结帐id = n_结帐id And Mod(记录性质, 10) = 2 And Nvl(校对标志, 0) = 0;
      If n_退补金额 < 0 Then
        v_Temp := '<TBLX>' || 2 || '</TBLX>';
      Else
        v_Temp := '<TBLX>' || 1 || '</TBLX>';
      End If;
      v_Temp := v_Temp || '<TBJE>' || Abs(n_退补金额) || '</TBJE>';
      v_Temp := '<TBQK>' || v_Temp || '</TBQK>';
      Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Else
      --未结清，读取未结数据
      For r_Info In (Select c.姓名, c.性别, c.年龄, c.住院号, d.名称 As 住院科室, c.入院科室id As 科室id, c.住院医师 As 主治医生,
                            To_Char(c.入院日期, 'yyyy-mm-dd') As 入院时间, To_Char(c.出院日期, 'yyyy-mm-dd') As 出院时间
                     From 病案主页 C, 部门表 D
                     Where c.病人id = n_病人id And c.入院科室id = d.Id(+) And c.主页id = n_主页id And Rownum < 2) Loop
        v_Temp := '<XM>' || r_Info.姓名 || '</XM>';
        v_Temp := v_Temp || '<XB>' || r_Info.性别 || '</XB>';
        v_Temp := v_Temp || '<NL>' || r_Info.年龄 || '</NL>';
        v_Temp := v_Temp || '<ZYH>' || r_Info.住院号 || '</ZYH>';
        v_Temp := v_Temp || '<ZYKS>' || r_Info.住院科室 || '</ZYKS>';
        v_Temp := v_Temp || '<KSID>' || r_Info.科室id || '</KSID>';
        v_Temp := v_Temp || '<ZZYS>' || r_Info.主治医生 || '</ZZYS>';
        v_Temp := v_Temp || '<RYSJ>' || r_Info.入院时间 || '</RYSJ>';
        v_Temp := v_Temp || '<CYSJ>' || r_Info.出院时间 || '</CYSJ>';
        v_Temp := v_Temp || '<JZSJ>' || '' || '</JZSJ>';
        v_Temp := v_Temp || '<DJH>' || '' || '</DJH>';
      End Loop;
      Begin
        Select Sum(Nvl(实收金额, 0)) - Sum(Nvl(结帐金额, 0))
        Into n_结帐金额
        From 住院费用记录
        Where 病人id = n_病人id And 记录状态 <> 0 And 主页id = n_主页id And 记帐费用 = 1;
      Exception
        When Others Then
          n_结帐金额 := 0;
      End;
      v_Temp := v_Temp || '<JSZFY>' || n_结帐金额 || '</JSZFY>';
      v_Temp := '<JBXX>' || v_Temp || '</JBXX>';
      Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
      v_Subtemp := '';
      For r_预交 In (Select NO As 单据号, 结算方式, Sum(Nvl(金额, 0)) - Sum(Nvl(冲预交, 0)) As 金额, 交易流水号, Max(卡类别id) As 卡类别id
                   From 病人预交记录
                   Where 病人id = n_病人id And Mod(记录性质, 10) = 1 And Nvl(预交类别, 2) = 2 And (主页id = n_主页id Or 主页id Is Null)
                   Group By NO, 结算方式, 交易流水号
                   Having Sum(Nvl(金额, 0)) - Sum(Nvl(冲预交, 0)) <> 0) Loop
        v_Temp := '<DJH>' || r_预交.单据号 || '</DJH>';
        v_Temp := v_Temp || '<JSFS>' || r_预交.结算方式 || '</JSFS>';
        v_Temp := v_Temp || '<JE>' || r_预交.金额 || '</JE>';
        v_Temp := v_Temp || '<JYLSH>' || r_预交.交易流水号 || '</JYLSH>';
        If n_卡类别id = r_预交.卡类别id Then
          v_Temp := v_Temp || '<SFJSK>' || 1 || '</SFJSK>';
        Else
          v_Temp := v_Temp || '<SFJSK>' || 0 || '</SFJSK>';
        End If;
        v_Temp     := '<ITEM>' || v_Temp || '</ITEM>';
        v_Subtemp  := v_Subtemp || v_Temp;
        n_病人余额 := Nvl(n_病人余额, 0) + Nvl(r_预交.金额, 0);
      End Loop;
      v_Subtemp := '<YJKLIST>' || v_Subtemp || '</YJKLIST>';
      Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Subtemp)) Into x_Templet From Dual;
      If Nvl(n_病人余额,0) - Nvl(n_结帐金额,0) > 0 Then
        v_Temp := '<TBLX>' || 2 || '</TBLX>';
      Else
        v_Temp := '<TBLX>' || 1 || '</TBLX>';
      End If;
      v_Temp := v_Temp || '<TBJE>' || Abs(Nvl(n_病人余额,0) - Nvl(n_结帐金额,0)) || '</TBJE>';
      v_Temp := '<TBQK>' || v_Temp || '</TBQK>';
      Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    End If;
  End If;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getsettlement;
/

--92335:李南春,2017-06-28,自助更新人员缴款余额
CREATE OR REPLACE Procedure zl_人员缴款余额_Update(
费用模块_In      Number,
结帐id_In        病人预交记录.结帐id%Type,
结算方式_In      病人预交记录.结算方式%Type,
现金支付_In      病人预交记录.冲预交%Type,
个帐支付_In      病人预交记录.冲预交%Type,
操作员姓名_In    病人预交记录.操作员姓名%Type
) as 
  Err_Item Exception;
  v_Err_Msg Varchar2(255);
  n_返回值 病人余额.预交余额%Type;
  v_现金     结算方式.名称%Type;
  v_个人帐户 结算方式.名称%Type;
begin
  ---自助模块更新人员交款余额
  ---费用模块：1-预交款,2-结帐补款,3-收费收款,4-挂号收款,5-就诊卡收款
 if 费用模块_In=1 or 费用模块_In=5 then
    --人员缴款余额(现收)
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + 现金支付_In
    Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = 结算方式_In
    Returning 余额 Into n_返回值;

    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, 结算方式_In, 1, 现金支付_In);
      n_返回值 := 现金支付_In;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 人员缴款余额 Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = 结算方式_In And Nvl(余额, 0) = 0;
    End If;
 elsif 费用模块_In=3 then
    For c_缴款 In (Select 结算方式, 操作员姓名, Sum(Nvl(a.冲预交, 0)) As 冲预交
                 From 病人预交记录 A
                 Where a.结帐id = 结帐id_In And Mod(a.记录性质, 10) <> 1
                 Group By 结算方式, 操作员姓名) Loop

      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + Nvl(c_缴款.冲预交, 0)
      Where 收款员 = c_缴款.操作员姓名 And 性质 = 1 And 结算方式 = c_缴款.结算方式;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (c_缴款.操作员姓名, c_缴款.结算方式, 1, Nvl(c_缴款.冲预交, 0));
      End If;
    End Loop;
 elsif 费用模块_In=4 then
    --获取结算方式名称
    Begin
      Select 名称 Into v_现金 From 结算方式 Where 性质 = 1;
    Exception
      When Others Then
        v_现金 := '现金';
    End;
    Begin
      Select 名称 Into v_个人帐户 From 结算方式 Where 性质 = 3;
    Exception
      When Others Then
        v_个人帐户 := '个人帐户';
    End;
    
    If Nvl(现金支付_In, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + 现金支付_In
        Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = Nvl(结算方式_In, v_现金)
        Returning 余额 Into n_返回值;

        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (操作员姓名_In, Nvl(结算方式_In, v_现金), 1, 现金支付_In);
          n_返回值 := 现金支付_In;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = 操作员姓名_In And 结算方式 = Nvl(结算方式_In, v_现金) And 性质 = 1 And Nvl(余额, 0) = 0;
        End If;
     End If;

     If Nvl(个帐支付_In, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + 个帐支付_In
        Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = v_个人帐户
        Returning 余额 Into n_返回值;

        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, v_个人帐户, 1, 个帐支付_In);
          n_返回值 := 个帐支付_In;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_个人帐户 And Nvl(余额, 0) = 0;
        End If;
     End If;
 End if;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End zl_人员缴款余额_Update;
/

--110769:胡俊勇,2017-06-27,口服药超期收回后再回退医嘱停止
CREATE OR REPLACE Procedure Zl_病人医嘱记录_回退
(
  医嘱id_In     病人医嘱记录.Id%Type,
  Flag_In       Number := 0,
  医嘱内容_In   病人医嘱记录.医嘱内容%Type := Null,
  操作类型_In   病人医嘱状态.操作类型%Type := Null,
  操作员编号_In 人员表.编号%Type := Null,
  操作员姓名_In 人员表.姓名%Type := Null
  --功能：回退住院医嘱的状态操作或发送操作(回退重整操作通过调用Zl_病人医嘱记录_批量回退来进行)
  --参数：医嘱ID_IN=一组医嘱ID
  --      FLAG_IN=附加数据。回退停止：0=清除执行终止时间,1=保留现有的执行终止时间。
  --      医嘱内容_IN=该过程被批量回退调用时才用，用于错误提示。
  --      操作类型_IN=该过程被批量回退调用时才用，用于核对回退数据。0-回退发送,n=回退具体医嘱操作
) Is
  --包含指定医嘱的操作记录,第一条为要回退的内容(状态操作优先)
  --临嘱不回退发送后的自动停止,在回退发送时自动回退停止操作
  Cursor c_Rolladvice Is
    Select b.操作人员, b.操作时间, 0 As 发送号, b.操作类型, 0 As 执行状态, Sysdate + Null As 首次时间, Sysdate + Null As 末次时间, a.上次执行时间, a.医嘱期效,
           a.诊疗类别 As 类别, a.诊疗项目id, Null As 类型, a.病人id, a.主页id, a.婴儿, 0 As 记录性质, 0 As 门诊记帐, 0 As 开嘱科室id, a.审核标记, a.开嘱医生,
           a.执行科室id
    From 病人医嘱记录 A, 病人医嘱状态 B
    Where a.Id = b.医嘱id And (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In) And
          (Nvl(a.医嘱期效, 0) = 0 And b.操作类型 Not In (1, 2, 3) Or Nvl(a.医嘱期效, 0) = 1 And b.操作类型 Not In (1, 2, 3, 8))
    Union
    Select b.发送人 As 操作人员, b.发送时间 As 操作时间, b.发送号, -null As 操作类型, b.执行状态, b.首次时间, b.末次时间, a.上次执行时间, a.医嘱期效, c.类别, a.诊疗项目id,
           c.操作类型 As 类型, a.病人id, a.主页id, a.婴儿, b.记录性质, b.门诊记帐, a.开嘱科室id, a.审核标记, a.开嘱医生, a.执行科室id
    From 病人医嘱记录 A, 病人医嘱发送 B, 诊疗项目目录 C
    Where a.Id = b.医嘱id And a.诊疗项目id = c.Id And (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In)
    Order By 操作时间 Desc, 发送号;
  r_Rolladvice c_Rolladvice%RowType;

  --方式同c_Rolladvice，只取发送部份用了自动回退处理
  Cursor c_Rollsend(v_发送号 病人医嘱发送.发送号%Type) Is
    Select Distinct b.医嘱id, b.发送时间 As 操作时间, b.发送号, b.执行状态, a.诊疗类别 As 类别, c.当前病区id As 病人病区id, a.病人科室id,
                    b.执行部门id As 执行科室id
    From 病人医嘱记录 A, 病人医嘱发送 B, 病案主页 C
    Where a.Id = b.医嘱id And b.发送号 = v_发送号 And a.病人id = c.病人id And a.主页id = c.主页id And
          (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In)
    Order By b.发送时间 Desc, b.发送号;

  --根据医嘱及发送NO求出本次回退要销帐的费用记录
  --一组医嘱并不是都填写了发送记录,且可能NO不同(药品有,用法煎法不一定有)
  --不管发送记录的计费状态(可能无需计费),有费用记录自然关联出来
  --费用只求价格父号为空的,以便取序号销帐
  --只管记录状态为1的费用,对于已销帐或部份销帐的记录,不再处理；其中"记录状态=3"的读取出来仅用于判断，不处理。
  Cursor c_Rollmoneyout
  (
    v_发送号    病人医嘱发送.发送号%Type,
    v_医嘱id    病人医嘱记录.Id%Type,
    t_Adviceids t_Numlist
  ) Is
    Select /*+ Rule*/
     a.Id, a.记录状态, a.No, a.序号, a.收费类别, a.执行状态, d.跟踪在用, a.执行部门id, a.记录性质
    From 门诊费用记录 A, Table(t_Adviceids) B, 病人医嘱发送 C, 材料特性 D
    Where c.医嘱id = b.Column_Value And c.发送号 = v_发送号 And a.医嘱序号 = b.Column_Value And
          (a.医嘱序号 = v_医嘱id Or Nvl(v_医嘱id, 0) = 0) And a.记录状态 In (0, 1, 3) And a.No = c.No And a.记录性质 = c.记录性质 And
          a.价格父号 Is Null And a.收费细目id = d.材料id(+)
    Order By a.No, a.序号;

  Cursor c_Rollmoneyin
  (
    v_发送号    病人医嘱发送.发送号%Type,
    v_医嘱id    病人医嘱记录.Id%Type,
    t_Adviceids t_Numlist
  ) Is
    Select /*+ Rule*/
     a.Id, a.记录状态, a.No, a.序号, a.收费类别, a.执行状态, d.跟踪在用, a.执行部门id, a.记录性质
    From 住院费用记录 A, Table(t_Adviceids) B, 病人医嘱发送 C, 材料特性 D
    Where c.医嘱id = b.Column_Value And c.发送号 = v_发送号 And a.医嘱序号 = b.Column_Value And
          (a.医嘱序号 = v_医嘱id Or Nvl(v_医嘱id, 0) = 0) And a.记录状态 In (0, 1, 3) And a.No = c.No And a.记录性质 = c.记录性质 And
          a.价格父号 Is Null And a.收费细目id = d.材料id(+)
    Order By a.No, a.序号;

  --取发送住院记帐时自动发放的卫材(还没有退料的)
  Cursor c_Stuff_Drug(v_费用id 药品收发记录.费用id%Type) Is
    Select ID
    From 药品收发记录
    Where 费用id = v_费用id And (记录状态 = 1 Or Mod(记录状态, 3) = 0) And 审核人 Is Not Null
    Order By 药品id;

  --用于处理特殊医嘱的回退
  Cursor c_Patilog
  (
    v_病人id 病人变动记录.病人id%Type,
    v_主页id 病人变动记录.主页id%Type
  ) Is
    Select *
    From 病人变动记录
    Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 Is Null
    Order By 开始时间 Desc;
  r_Patilog c_Patilog%RowType;

  Cursor c_Adviceids Is
    Select ID From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
  t_Adviceids t_Numlist;

  v_医嘱状态     病人医嘱记录.医嘱状态%Type;
  v_医嘱期效     病人医嘱记录.医嘱期效%Type;
  v_费用no       病人医嘱发送.No%Type;
  v_费用序号     Varchar2(255);
  v_末次时间     病人医嘱发送.末次时间%Type;
  v_重整时间     病人医嘱状态.操作时间%Type;
  v_操作类型     诊疗项目目录.操作类型%Type;
  v_执行频率     诊疗项目目录.执行频率%Type;
  v_上次时间     病人医嘱记录.上次执行时间%Type;
  v_执行时间     病人医嘱记录.执行时间方案%Type;
  v_开始执行时间 病人医嘱记录.开始执行时间%Type;
  v_上次打印时间 病人医嘱记录.上次打印时间%Type;
  v_频率间隔     病人医嘱记录.频率间隔%Type;
  v_间隔单位     病人医嘱记录.间隔单位%Type;
  v_发送号       病人医嘱发送.发送号%Type;
  n_护理等级id   病人变动记录.护理等级id%Type;
  d_开始时间     病人变动记录.开始时间%Type;
  d_操作时间     病人医嘱状态.操作时间%Type;
  v_Tmp发送号    病人医嘱发送.发送号%Type;
  n_执行         Number;

  Intdigit   Number(3);
  v_Update   Number(1);
  v_Count    Number(5);
  v_Temp     Varchar2(2000);
  v_人员编号 人员表.编号%Type;
  v_人员姓名 人员表.姓名%Type;
  v_Time     Varchar2(4000);
  n_Blndo    Number;

  v_Error Varchar2(2000);
  Err_Custom Exception;

  Function Checkmoneyundo
  (
    v_No       住院费用记录.No%Type,
    v_记录性质 住院费用记录.记录性质%Type,
    v_序号     住院费用记录.序号%Type,
    n_场合     Number := 0 --0住院，1门诊
  ) Return Number Is
    n_Num      Number;
    n_执行状态 Number;
  Begin
    n_Num := 0;
    If n_场合 = 0 Then
      Select Nvl(Sum(Nvl(付数, 1) * 数次), 0) As 数量
      Into n_Num
      From 住院费用记录
      Where NO = v_No And 记录性质 = v_记录性质 And 序号 = v_序号 And 记录状态 In (2, 3);
      Select Nvl(执行状态, 0)
      Into n_执行状态
      From 住院费用记录
      Where NO = v_No And 记录性质 = v_记录性质 And 序号 = v_序号 And 记录状态 = 3;
    Else
      Select Nvl(Sum(Nvl(付数, 1) * 数次), 0) As 数量
      Into n_Num
      From 门诊费用记录
      Where NO = v_No And 记录性质 = v_记录性质 And 序号 = v_序号 And 记录状态 In (2, 3);
      Select Nvl(执行状态, 0)
      Into n_执行状态
      From 门诊费用记录
      Where NO = v_No And 记录性质 = v_记录性质 And 序号 = v_序号 And 记录状态 = 3;
    End If;
    If n_Num <> 0 Then
      n_Num := 1;
    End If;
    --如果主记录是已执行（部分执行的）则不自动退。
    If n_执行状态 <> 0 Then
      n_Num := 0;
    End If;
    Return(n_Num);
  End;
Begin
  v_Tmp发送号 := -1;
  Open c_Rolladvice;
  Loop
    Fetch c_Rolladvice
      Into r_Rolladvice;
    If c_Rolladvice%RowCount = 0 Then
      Close c_Rolladvice;
      v_Error := Nvl(医嘱内容_In, '该医嘱') || '当前没有可以回退的内容。';
      Raise Err_Custom;
    End If;
    Exit When c_Rolladvice%NotFound;
    Exit When d_操作时间 <> r_Rolladvice.操作时间 And d_操作时间 Is Not Null;
    d_操作时间 := r_Rolladvice.操作时间;

    --批量回退调用时判断
    If 医嘱内容_In Is Not Null Then
      If Nvl(r_Rolladvice.操作类型, 0) <> Nvl(操作类型_In, 0) Then
        v_Error := Nvl(医嘱内容_In, '该医嘱') || '不能与当前医嘱一起回退，可能该医嘱已经执行了其他操作。';
        Raise Err_Custom;
      End If;
    End If;

    --一组发送号只执行一次
    If v_Tmp发送号 <> r_Rolladvice.发送号 Then
      v_Tmp发送号 := r_Rolladvice.发送号;
      n_执行      := 1;
    Else
      n_执行 := 0;
    End If;

    If n_执行 = 1 Then
      Open c_Adviceids;
      Fetch c_Adviceids Bulk Collect
        Into t_Adviceids;
      Close c_Adviceids;

      If r_Rolladvice.发送号 = 0 Then
        --回退医嘱状态操作(以时间关键字)
        --4-作废；5-重整；6-暂停；7-启用；8-停止；9-确认停止；10-皮试结果;13-停嘱申请
        ------------------------------------------------------------------
        --最多只能退回到校对状态
        If r_Rolladvice.操作类型 = 3 Then
          v_Error := Nvl(医嘱内容_In, '该医嘱') || '当前处于通过校对状态，不能再回退。';
          Raise Err_Custom;
        Elsif r_Rolladvice.操作类型 = 4 And Nvl(r_Rolladvice.婴儿, 0) = 0 Then
          If r_Rolladvice.类别 = 'H' Then
            Select 操作类型, 执行频率 Into v_操作类型, v_执行频率 From 诊疗项目目录 Where ID = r_Rolladvice.诊疗项目id;
            If v_操作类型 = '1' And v_执行频率 = '2' Then
              v_Error := '护理等级作废后不能再回退。';
              Raise Err_Custom;
            End If;
          End If;
        End If;

        --检查是否回退最近次重整之前的操作
        If r_Rolladvice.操作类型 <> 5 Then
          --取最后重整时间
          Select Nvl(医嘱重整时间, To_Date('1900-01-01', 'YYYY-MM-DD'))
          Into v_重整时间
          From 病案主页
          Where 病人id = r_Rolladvice.病人id And 主页id = r_Rolladvice.主页id;

          If r_Rolladvice.操作时间 < v_重整时间 Then
            v_Error := '该病人最近次重整之前的操作不能再回退。';
            Raise Err_Custom;
          End If;
        End If;

        --删除(该组医嘱)最近的状态操作记录
        Delete /*+ Rule*/
        From 病人医嘱状态
        Where 医嘱id In (Select Column_Value From Table(t_Adviceids)) And 操作时间 = r_Rolladvice.操作时间;

        --取删除后应恢复的医嘱状态
        Select 操作类型
        Into v_医嘱状态
        From 病人医嘱状态
        Where 操作时间 = (Select Max(操作时间) From 病人医嘱状态 Where 医嘱id = 医嘱id_In) And 医嘱id = 医嘱id_In;

        --恢复(该组医嘱)回退后的状态
        Update 病人医嘱记录 Set 医嘱状态 = v_医嘱状态 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;

        --其它额外的处理
        If r_Rolladvice.操作类型 = 8 Then
          --被超期发送收回过的医嘱 ，如果是销帐申请模式，则判断对应的“病人费用销帐”申请是否取消，是则允许回退，否则不允许，
          --                       如果是产生负数费用模式，则不允许再回退。
          --可能超期发送收回时被全部收回(无上次执行时间)
          Select /*+ Rule*/
           Nvl(Count(*), 0)
          Into v_Count
          From 病人医嘱记录 A, 病人医嘱发送 B
          Where b.医嘱id = a.Id And (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In) And
                b.发送号 =
                (Select Max(发送号) From 病人医嘱发送 Where 医嘱id In (Select Column_Value From Table(t_Adviceids))) And
                a.执行终止时间 Is Not Null And ((a.上次执行时间 < b.末次时间) Or (a.上次执行时间 Is Null And b.末次时间 Is Not Null));
          If v_Count > 0 Then
            If zl_GetSysParameter('超期收回产生负数费用', 1254) = '1' Then
              v_Error := Nvl(医嘱内容_In, '该医嘱') || '已被超期发送收回，不能再撤消停止操作。';
              Raise Err_Custom;
            Else
              --如果已经取消销帐申请，则允许回退.
              Select Count(1)
              Into v_Count
              From 病人费用销帐 A, 住院费用记录 B, 病人医嘱记录 C
              Where a.费用id = b.Id And c.Id = b.医嘱序号 And (c.Id = 医嘱id_In Or c.相关id = 医嘱id_In);
              If v_Count > 0 Then
                v_Error := Nvl(医嘱内容_In, '该医嘱') || '已被超期发送收回，不能再撤消停止操作。';
                Raise Err_Custom;
              Else
                --得到上次执行时间等信息
                Select 上次执行时间, 执行时间方案, 开始执行时间, 上次打印时间, 频率间隔, 间隔单位
                Into v_上次时间, v_执行时间, v_开始执行时间, v_上次打印时间, v_频率间隔, v_间隔单位
                From 病人医嘱记录
                Where ID = 医嘱id_In;
                v_上次时间 := To_Date(To_Char(v_上次时间 + 1 / 24 / 60 / 60, 'yyyy-MM-dd hh24:mi:ss'), 'yyyy-MM-dd hh24:mi:ss');

                --修改上次执行时间为收回后的末次执行时间。
                v_末次时间 := Null;
                Begin
                  --一组医嘱的发送首末时间相同,一并给药是取最小的
                  --取相关ID为NULL的医嘱的发送记录的时间
                  --但给药途径或中药用法可能未填写发送记录
                  Select /*+ Rule*/
                   末次时间, 发送号
                  Into v_末次时间, v_发送号
                  From 病人医嘱发送
                  Where 医嘱id In (Select Column_Value From Table(t_Adviceids)) And
                        发送号 = (Select Max(发送号)
                               From 病人医嘱发送
                               Where 医嘱id In (Select Column_Value From Table(t_Adviceids))) And Rownum = 1;
                Exception
                  When Others Then
                    Null;
                End;
                Update 病人医嘱记录 Set 上次执行时间 = v_末次时间 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;

                Select Count(1) Into v_Count From 病人医嘱发送 Where 医嘱id = 医嘱id_In And 发送号 = v_发送号;
                If v_Count > 0 Then
                  --还原医嘱执行时间
                  Select Zl_Adviceexetimes(医嘱id_In, v_上次时间, v_末次时间, v_执行时间, v_开始执行时间, v_上次打印时间, v_频率间隔, v_间隔单位, 0)
                  Into v_Time
                  From Dual;
                  Insert Into 医嘱执行时间
                    (要求时间, 医嘱id, 发送号)
                    Select To_Date(Column_Value, 'yyyy-mm-dd hh24:mi:ss'), 医嘱id_In, v_发送号
                    From Table(f_Str2list(v_Time));
                End If;
              End If;
            End If;
          End If;

          --护理等级变动，后续有其他变动时，不允许回退
          If r_Rolladvice.类别 = 'H' And Nvl(r_Rolladvice.婴儿, 0) = 0 Then
            Select 操作类型, 执行频率 Into v_操作类型, v_执行频率 From 诊疗项目目录 Where ID = r_Rolladvice.诊疗项目id;
            If v_操作类型 = '1' And v_执行频率 = '2' Then
              Select Count(*), Max(a.护理等级id), Max(a.开始时间)
              Into v_Count, n_护理等级id, d_开始时间
              From 病人变动记录 A
              Where a.病人id = r_Rolladvice.病人id And a.主页id = r_Rolladvice.主页id And a.开始原因 = 6 And a.终止时间 Is Null And
                    a.附加床位 = 0;
              --如果没有找到最后一条是护理等级变动则禁止
              If v_Count = 0 Then
                --医嘱护理等级和入住时候的护理等级一致时要单独判断
                Select Count(*)
                Into v_Count
                From 病人变动记录 A
                Where a.病人id = r_Rolladvice.病人id And a.主页id = r_Rolladvice.主页id And a.开始原因 = 6;
                If v_Count > 0 Then
                  v_Error := '由于护理等级医嘱停止后该病人已经产生了其他变动记录,不能回退该医嘱的停止操作。';
                  Raise Err_Custom;
                End If;
              Else
                --如果n_护理等级ID为Null，则检查是否是当前回退的医嘱对应的变动记录,目的是有多个护理等级医嘱时要求按顺序回退。
                --如果n_护理等级ID不为Null，则有可能是校对下一条护理等级时，自动停止的，未产生变动记录，
                --     则需要检查当前最后一条变动的护理等级ID是否是当前医嘱的护理等级ID,目的是有多个护理等级医嘱时要求按顺序回退，如果是则不需要再撤销最后一次变动，直接回退医嘱即可。
                If n_护理等级id Is Null Then
                  Select Count(*)
                  Into v_Count
                  From 病人变动记录 B, 病人医嘱计价 C
                  Where b.病人id = r_Rolladvice.病人id And b.主页id = r_Rolladvice.主页id And c.医嘱id = 医嘱id_In And
                        c.收费细目id = b.护理等级id And b.终止时间 = d_开始时间 And b.终止原因 = 6 And b.附加床位 = 0;
                Else
                  --开始时间只取分钟对比，校对的时候护理等级的开始时间是医嘱开始时间+当前时间的秒钟
                  Select Count(*)
                  Into v_Count
                  From 病人医嘱计价 C, 病人医嘱记录 A
                  Where a.Id = c.医嘱id And a.Id = 医嘱id_In And c.收费细目id = n_护理等级id And
                        a.开始执行时间 = To_Date(To_Char(d_开始时间, 'yyyy-mm-dd hh24:mi'), 'yyyy-mm-dd hh24:mi');
                End If;
                If v_Count = 0 Then
                  v_Error := '您回退的医嘱不是最后一条护理等级医嘱，请将后面的护理等级医嘱作废后再回退本条医嘱。';
                  Raise Err_Custom;
                End If;

                If n_护理等级id Is Null Then
                  --当前操作人员
                  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
                    v_人员编号 := 操作员编号_In;
                    v_人员姓名 := 操作员姓名_In;
                  Else
                    v_Temp     := Zl_Identity;
                    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
                    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
                    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
                    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
                  End If;

                  Zl_病人变动记录_Undo(r_Rolladvice.病人id, r_Rolladvice.主页id, v_人员编号, v_人员姓名, '1', Null, Null, '护理等级变动');
                End If;
              End If;
            End If;
          End If;

          If r_Rolladvice.类别 = 'Z' And  Instr(',9,10,', ','||r_Rolladvice.类型||',') > 0 And Nvl(r_Rolladvice.婴儿, 0) = 0 Then
            --回退病况医嘱时，调用变动记录回退
            Zl_病人变动记录_Undo(r_Rolladvice.病人id, r_Rolladvice.主页id, v_人员编号, v_人员姓名, Null, Null, Null, '病况变动');
          End If;

          --回退医嘱停止时,清空停嘱医生和时间,如果是实习医师申请后审核的，则恢复待审核状态
          Update 病人医嘱记录
          Set 执行终止时间 = Decode(Flag_In, 1, 执行终止时间, Null), 停嘱医生 = Null, 停嘱时间 = Null,
              审核标记 = Decode(r_Rolladvice.审核标记, 3, 2, r_Rolladvice.审核标记)
          Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
        Elsif r_Rolladvice.操作类型 = 9 Then
          --回退医嘱确认停止时,检查是否已打印停嘱时间
          Select /*+ Rule*/
           Count(*)
          Into v_Count
          From 病人医嘱打印
          Where 打印标记 = 1 And 医嘱id In (Select Column_Value From Table(t_Adviceids));
          If v_Count > 0 Then
            v_Error := Nvl(医嘱内容_In, '该医嘱') || '的停嘱时间已经打印，不能再撤消确认停止操作。';
            Raise Err_Custom;
          End If;

          --回退医嘱确认停止时,清空停嘱医生和时间
          Update 病人医嘱记录 Set 确认停嘱时间 = Null, 确认停嘱护士 = Null Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
        Elsif r_Rolladvice.操作类型 = 10 Then
          --回退标注皮试结果,同时删除过敏登记(+)或(-),根据记录时间
    --过敏的记录与医嘱操作无观，不需要处理
          Delete From 病人过敏记录
          Where 病人id = r_Rolladvice.病人id And Nvl(主页id, 0) = Nvl(r_Rolladvice.主页id, 0) And 记录时间 = r_Rolladvice.操作时间 And Nvl(结果,0)=0;

          Update 病人医嘱记录 Set 皮试结果 = Null Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
        Elsif r_Rolladvice.操作类型 = 13 Then
          If Instr(r_Rolladvice.开嘱医生, '/') > 0 Then
            Update 病人医嘱记录 Set 审核标记 = 1 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
          Else
            Update 病人医嘱记录 Set 审核标记 = Null Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
          End If;
        End If;
      Else
        --回退医嘱发送(以发送号关键字)
        ------------------------------------------------------------------
        --当前操作人员
        v_Temp     := Zl_Identity;
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
        v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
        v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);

        --检查是否是输液配液记录，并是否已经锁定，如果查询有数据说明是配液记录
        Begin
          Select Decode(Max(是否锁定), 1, 1, 0)
          Into v_Count
          From 输液配药记录
          Where 医嘱id = 医嘱id_In And 发送号 = r_Rolladvice.发送号;
        Exception
          When Others Then
            v_Count := -1;
        End;

        If v_Count = 1 Then
          v_Error := '医嘱"' || 医嘱内容_In || '"是输液药品，已经被输液配置中心锁定，不能回退发送。';
          Raise Err_Custom;
        Elsif v_Count = 0 Then
          Zl_输液配药记录_医嘱回退(医嘱id_In, r_Rolladvice.发送号, v_人员姓名, Sysdate);
        End If;

        --检查是否存在未审核的销帐申请
        Select Count(*)
        into v_Count
        From 病人医嘱记录 A, 病人医嘱发送 B, 住院费用记录 C, 病人费用销帐 D
        Where (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In) And a.Id = b.医嘱id And b.医嘱id = c.医嘱序号 And c.Id = d.费用id And c.记录状态 In (0, 1, 3) And
              d.状态 = 0;

        If v_Count > 0 Then
          v_Error := '医嘱"' || 医嘱内容_In || '"存在未审核的销帐申请，请取消或审核销帐申请后再回退发送。';
          Raise Err_Custom;
        End If;

        --检查医嘱是否存在有效的医嘱附费
        Select Count(*)
        Into v_Count
        From 病人医嘱附费 A, 住院费用记录 B
        Where a.医嘱id = b.医嘱序号 And a.No = b.No And b.记录状态 = 1 And b.实收金额 <> 0 And a.发送号 = r_Rolladvice.发送号 And A.医嘱id In (Select Column_Value From Table(t_Adviceids));
        If v_Count > 0 Then
          v_Error := '该医嘱下还存在附费项目，请先冲销。';
          Raise Err_Custom;
        End If;

        --本科发送自动执行时，回退也自动回退执行(仅护士站有此功能)
        --非跟踪在用的卫材医嘱，同普通医嘱执行处理
        Select 医嘱期效 Into v_医嘱期效 From 病人医嘱记录 Where ID = 医嘱id_In;
        If Substr(zl_GetSysParameter('本科执行自动完成', 1254), v_医嘱期效 + 1, 1) = '1' Then
          Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into Intdigit From Dual;

          For r_Rollsend In c_Rollsend(r_Rolladvice.发送号) Loop
            If Nvl(r_Rollsend.执行状态, 0) = 1 And
               (Nvl(r_Rollsend.执行科室id, 0) = Nvl(r_Rollsend.病人病区id, 0) Or
                Nvl(r_Rollsend.执行科室id, 0) = Nvl(r_Rollsend.病人科室id, 0)) Then

              --医嘱的执行状态
              Update 病人医嘱发送 Set 执行状态 = 0 Where 发送号 = r_Rollsend.发送号 And 医嘱id = r_Rollsend.医嘱id;
              v_Update := 1;

              If r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 0 Then
                --费用的执行状态
                For r_Rollmoney In c_Rollmoneyin(r_Rollsend.发送号, r_Rollsend.医嘱id, t_Adviceids) Loop
                  n_Blndo := 0;
                  If r_Rollmoney.记录状态 <> 3 Then
                    n_Blndo := 1;
                  Else
                    n_Blndo := Checkmoneyundo(r_Rollmoney.No, r_Rollmoney.记录性质, r_Rollmoney.序号);
                  End If;
                  If n_Blndo > 0 Then
                    If Not (r_Rollmoney.收费类别 = '4' And Nvl(r_Rollmoney.跟踪在用, 0) = 1) And
                       Not r_Rollmoney.收费类别 In ('5', '6', '7') Then
                      --普通费用直接取消执行状态，不含药品和跟踪在用的卫材
                      Update 住院费用记录
                      Set 执行状态 = 0, 执行时间 = Null, 执行人 = Null
                      Where NO = r_Rollmoney.No And 记录性质 = r_Rolladvice.记录性质 And 记录状态 = r_Rollmoney.记录状态 And
                            Nvl(价格父号, 序号) = r_Rollmoney.序号 And 医嘱序号 = r_Rollsend.医嘱id;
                    Elsif r_Rollmoney.收费类别 = '4' And Nvl(r_Rollmoney.跟踪在用, 0) = 1 Then
                      --跟踪在用的卫材，才自动退料
                        For r_Stuff In c_Stuff_Drug(r_Rollmoney.Id) Loop
                          Zl_材料收发记录_部门退料(r_Stuff.Id, v_人员姓名, Sysdate, Null, Null, Null, Null, 0, v_人员姓名);
                        End Loop;
                    Elsif r_Rollmoney.收费类别 In ('5', '6', '7') Then
                      --住院科室发药的药品自动退药
                      If r_Rollmoney.执行部门id = r_Rollsend.病人病区id Or r_Rollmoney.执行部门id = r_Rollsend.病人科室id Then
                        For r_Drug In c_Stuff_Drug(r_Rollmoney.Id) Loop
                          Zl_药品收发记录_部门退药(r_Drug.Id, v_人员姓名, Sysdate, Null, Null, Null, Null, Null, Null, Intdigit, 2);
                        End Loop;
                      End If;
                    End If;
                  End If;
                End Loop;
              Else
                --住院病人费用发送到门诊的情况，病人来源都是住院的
                For r_Rollmoney In c_Rollmoneyout(r_Rollsend.发送号, r_Rollsend.医嘱id, t_Adviceids) Loop
                  n_Blndo := 0;
                  If r_Rollmoney.记录状态 <> 3 Then
                    n_Blndo := 1;
                  Else
                    n_Blndo := Checkmoneyundo(r_Rollmoney.No, r_Rollmoney.记录性质, r_Rollmoney.序号, 1);
                  End If;
                  If n_Blndo > 0 Then
                    If Not (r_Rollmoney.收费类别 = '4' And Nvl(r_Rollmoney.跟踪在用, 0) = 1) And
                       Not r_Rollmoney.收费类别 In ('5', '6', '7') Then
                      --普通费用直接取消执行状态，不含药品和跟踪在用的卫材
                      Update 门诊费用记录
                      Set 执行状态 = 0, 执行时间 = Null, 执行人 = Null
                      Where NO = r_Rollmoney.No And 记录性质 = r_Rolladvice.记录性质 And 记录状态 = r_Rollmoney.记录状态 And
                            Nvl(价格父号, 序号) = r_Rollmoney.序号 And 医嘱序号 = r_Rollsend.医嘱id;
                    Elsif r_Rollmoney.收费类别 = '4' And Nvl(r_Rollmoney.跟踪在用, 0) = 1 Then
                        --跟踪在用的卫材，才自动退料
                        For r_Stuff In c_Stuff_Drug(r_Rollmoney.Id) Loop
                          Zl_材料收发记录_部门退料(r_Stuff.Id, v_人员姓名, Sysdate, Null, Null, Null, Null, 0, v_人员姓名);
                        End Loop;
                    Elsif r_Rollmoney.收费类别 In ('5', '6', '7') Then
                      --本科室发药的药品自动退药
                      If r_Rollmoney.执行部门id = r_Rollsend.病人病区id Or r_Rollmoney.执行部门id = r_Rollsend.病人科室id Then
                        For r_Drug In c_Stuff_Drug(r_Rollmoney.Id) Loop
                          Zl_药品收发记录_部门退药(r_Drug.Id, v_人员姓名, Sysdate, Null, Null, Null, Null, Null, Null, Intdigit, 1);
                        End Loop;
                      End If;
                    End If;
                  End If;
                End Loop;
              End If;
            End If;
          End Loop;
        End If;
        ------------------------------------------------------------------
        --被超期收回的长期药品医嘱不允许回退(再退费用就多退了)
        If Nvl(r_Rolladvice.医嘱期效, 0) = 0 Then
          If r_Rolladvice.上次执行时间 Is Not Null And r_Rolladvice.末次时间 Is Not Null Then
            If r_Rolladvice.上次执行时间 < r_Rolladvice.末次时间 Then
              v_Error := Nvl(医嘱内容_In, '该医嘱') || '最近超期发送的内容已被收回，不能再回退。';
              Raise Err_Custom;
            End If;
          Elsif r_Rolladvice.上次执行时间 Is Null And r_Rolladvice.末次时间 Is Not Null Then
            --长嘱可能被全部超期收回
            v_Error := Nvl(医嘱内容_In, '该医嘱') || '未被发送，或发送的内容已被全部超期收回，不能再回退。';
            Raise Err_Custom;
          End If;
        End If;

        If Nvl(r_Rolladvice.执行状态, 0) In (1, 3) And v_Update <> 1 Then
          --1-完全执行;3-正在执行
          v_Error := Nvl(医嘱内容_In, '该医嘱') || '最近发送的内容已经执行或正在执行，不能回退。';
          Raise Err_Custom;
        Else
          --如果相关医嘱已执行，则也要限制回退（例如：检验的采集方式）
          Select /*+ Rule*/
           Count(1)
          Into v_Count
          From 病人医嘱发送
          Where 医嘱id In (Select Column_Value From Table(t_Adviceids)) And 执行状态 In (1, 3) And
                发送号 =
                (Select Max(发送号) From 病人医嘱发送 Where 医嘱id In (Select Column_Value From Table(t_Adviceids)));
          If v_Count > 0 Then
            v_Error := Nvl(医嘱内容_In, '该医嘱') || '最近发送的内容已经执行或正在执行，不能回退。';
            Raise Err_Custom;
          End If;
        End If;

        ------------------------------------------------------------------
        --将该组医嘱的费用销帐(按一组医嘱可能有不同NO处理)
        --如果原始费用已被销帐(或部分销帐),调用过程中有判断
        v_费用no   := Null;
        v_费用序号 := Null;
        If r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 0 Then
          For r_Rollmoney In c_Rollmoneyin(r_Rolladvice.发送号, Null, t_Adviceids) Loop
            --对应的费用已执行
            If Nvl(r_Rollmoney.执行状态, 0) <> 0 Then
              v_Error := Nvl(医嘱内容_In, '该医嘱') || '发送的费用单据"' || r_Rollmoney.No || '"中的内容已被部分或完全执行，不能回退。';
              Raise Err_Custom;
            End If;
            n_Blndo := 0;
            If r_Rollmoney.记录状态 <> 3 Then
              n_Blndo := 1;
            Else
              n_Blndo := Checkmoneyundo(r_Rollmoney.No, r_Rollmoney.记录性质, r_Rollmoney.序号);
            End If;
            If n_Blndo > 0 Then
              --这种仅用于判断部分退药
              If v_费用no <> r_Rollmoney.No And v_费用序号 Is Not Null Then
                Zl_住院记帐记录_Delete(v_费用no, Substr(v_费用序号, 2), v_人员编号, v_人员姓名, 2, 0, 0);
                v_费用序号 := Null;
              End If;
              v_费用no   := r_Rollmoney.No;
              v_费用序号 := v_费用序号 || ',' || r_Rollmoney.序号;
            End If;
          End Loop;
        Else
          For r_Rollmoney In c_Rollmoneyout(r_Rolladvice.发送号, Null, t_Adviceids) Loop
            --对应的费用已执行
            If Nvl(r_Rollmoney.执行状态, 0) <> 0 And Not (Nvl(r_Rollmoney.执行状态, 0) = -1 And Nvl(r_Rollmoney.记录状态, 0) = 0) Then
              v_Error := Nvl(医嘱内容_In, '该医嘱') || '发送的费用单据"' || r_Rollmoney.No || '"中的内容已被部分或完全执行，不能回退。';
              Raise Err_Custom;
            End If;
            --收费单据已收费
            If r_Rollmoney.记录状态 = 1 And Not (r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 1) Then
              v_Error := Nvl(医嘱内容_In, '该医嘱') || '发送的门诊单据"' || r_Rollmoney.No || '"已收费，不能回退。';
              Raise Err_Custom;
            End If;
            n_Blndo := 0;
            If r_Rollmoney.记录状态 <> 3 Then
              n_Blndo := 1;
            Else
              n_Blndo := Checkmoneyundo(r_Rollmoney.No, r_Rollmoney.记录性质, r_Rollmoney.序号, 1);
            End If;
            If n_Blndo > 0 Then
              --这种仅用于判断部分退药
              If v_费用no <> r_Rollmoney.No And v_费用序号 Is Not Null Then
                If r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 1 Then
                  --住院发送为门诊记帐(如果是门诊医生发送为门诊记帐，门诊医嘱没有回退功能)
                  Zl_门诊记帐记录_Delete(v_费用no, v_费用序号, v_人员编号, v_人员姓名);
                Else
                  Zl_门诊划价记录_Delete(v_费用no, Substr(v_费用序号, 2));
                End If;
                v_费用序号 := Null;
              End If;
              v_费用no   := r_Rollmoney.No;
              v_费用序号 := v_费用序号 || ',' || r_Rollmoney.序号;
            End If;
          End Loop;
        End If;
        If v_费用序号 Is Not Null And v_费用no Is Not Null Then
          v_费用序号 := Substr(v_费用序号, 2);
          If r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 0 Then
            Zl_住院记帐记录_Delete(v_费用no, v_费用序号, v_人员编号, v_人员姓名, 2, 0, 0);
          Elsif r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 1 Then
            --住院发送为门诊记帐(如果是门诊医生发送为门诊记帐，门诊医嘱没有回退功能)
            Zl_门诊记帐记录_Delete(v_费用no, v_费用序号, v_人员编号, v_人员姓名);
          Else
            Zl_门诊划价记录_Delete(v_费用no, v_费用序号);
          End If;
        End If;
        --输血医嘱先删除病人医嘱附费
        Delete From 病人医嘱附费 Where 发送号 = r_Rolladvice.发送号 And 医嘱id = 医嘱id_In;

        --删除医嘱执行时间 (仅主医嘱ID才产生了记录)
        Delete From 医嘱执行时间 Where 发送号 = r_Rolladvice.发送号 And 医嘱id = 医嘱id_In;

        --删除发送记录(该组医嘱的)
        Delete /*+ Rule*/
        From 病人医嘱发送
        Where 发送号 = r_Rolladvice.发送号 And 医嘱id In (Select Column_Value From Table(t_Adviceids));

        --标记(该组医嘱)上次执行时间(以上次发送的末次执行时间)
        --所有长嘱(包括持续性长嘱)发送时都填写了末次时间
        --临嘱可能没有，且只可能发送了一次。
        v_末次时间 := Null;
        Begin
          --一组医嘱的发送首末时间相同,一并给药是取最小的
          --取相关ID为NULL的医嘱的发送记录的时间
          --但给药途径或中药用法可能未填写发送记录
          Select /*+ Rule*/
           末次时间
          Into v_末次时间
          From 病人医嘱发送
          Where 医嘱id In (Select Column_Value From Table(t_Adviceids)) And
                发送号 =
                (Select Max(发送号) From 病人医嘱发送 Where 医嘱id In (Select Column_Value From Table(t_Adviceids))) And
                Rownum = 1;
        Exception
          When Others Then
            Null;
        End;
        Update 病人医嘱记录 Set 上次执行时间 = v_末次时间 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;

        --回退临嘱发送时，同时自动回退停止
        If Nvl(r_Rolladvice.医嘱期效, 0) = 1 Then
          --删除(该组临嘱)最近的停止状态操作记录
          Delete /*+ Rule*/
          From 病人医嘱状态
          Where 医嘱id In (Select Column_Value From Table(t_Adviceids)) And
                操作时间 = (Select Max(操作时间) From 病人医嘱状态 Where 医嘱id = 医嘱id_In) And 操作类型 = 8;
          --r_RollAdvice.操作时间:因发送时间可能不与自动停止时间相同。

          --取删除后应恢复的医嘱状态
          Select 操作类型
          Into v_医嘱状态
          From 病人医嘱状态
          Where 操作时间 = (Select Max(操作时间) From 病人医嘱状态 Where 医嘱id = 医嘱id_In) And 医嘱id = 医嘱id_In;

          --恢复(该组医嘱)回退后的状态
          Update 病人医嘱记录
          Set 医嘱状态 = v_医嘱状态, 执行终止时间 = Null, 停嘱医生 = Null, 停嘱时间 = Null
          Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
        End If;

        --住院特殊医嘱发送后的回退(3-转科;5-出院;6-转院,11-死亡)
        If r_Rolladvice.类别 = 'Z' And Instr(',3,5,6,11,', ','||r_Rolladvice.类型||',') > 0 And Nvl(r_Rolladvice.婴儿, 0) = 0 Then
          Open c_Patilog(r_Rolladvice.病人id, r_Rolladvice.主页id);
          Fetch c_Patilog
            Into r_Patilog;
          If c_Patilog%Found Then
            If r_Rolladvice.类型 = '3' And r_Patilog.开始原因 = 3 Then
              --取消病人转科状态
              If r_Patilog.开始时间 Is Null Then
                --转科医嘱的特殊处理，当一个病人有两条转科医嘱时，只能回退最近的一条,70443
                Select Count(1)
                Into v_Count
                From 病人医嘱记录 A, 诊疗项目目录 B
                Where a.诊疗项目id = b.Id And a.病人id = r_Rolladvice.病人id And a.主页id = r_Rolladvice.主页id And a.诊疗类别 = 'Z' And
                      b.操作类型 = '3' And a.医嘱状态 = 8 And
                      a.开始执行时间 > (Select 开始执行时间 From 病人医嘱记录 Where ID = 医嘱id_In);
                If v_Count = 0 Then
                  Zl_病人变动记录_Undo(r_Rolladvice.病人id, r_Rolladvice.主页id, v_人员编号, v_人员姓名, Null, Null, Null, '转科');
                Else
                  v_Error := '病人转科已经入科，不能再回退。';
                  Raise Err_Custom;
                End If;
              Else
                v_Error := '病人转科已经入科，不能再回退。';
                Raise Err_Custom;
              End If;
            Elsif r_Rolladvice.类型 In ('5', '6', '11') And r_Patilog.开始原因 = 10 Then
              --取消病人预出院状态
              Zl_病人变动记录_Undo(r_Rolladvice.病人id, r_Rolladvice.主页id, v_人员编号, v_人员姓名, Null, Null, Null, '预出院');
            End If;
          End If;
          Close c_Patilog;
        End If;

        --回退病历时机
        --1.特殊事件(只有一条医嘱记录)：手术，7-会诊,8-抢救,11-死亡
        If r_Rolladvice.类别 = 'F' Or r_Rolladvice.类别 = 'Z' And Instr(',7,8,11,', ','||r_Rolladvice.类型||',') > 0 Then
          Zl_电子病历时机_Delete(r_Rolladvice.病人id, r_Rolladvice.主页id, '医嘱', r_Rolladvice.开嘱科室id, 医嘱id_In);
        End If;

        --2.额外处理：知情同意书(手术相关的知情同意需再次调用，因为附加手术或麻醉项目可能有关联的知情同意书)
        If Instr('C,D,E,F,G,K,L', r_Rolladvice.类别) > 0 Then
          For R In (Select a.Id, a.诊疗类别 From 病人医嘱记录 A Where a.Id = 医嘱id_In Or a.相关id = 医嘱id_In) Loop
            --相关id的一组医嘱不一定是这个类别的，所以要再判断一次类别
            If Instr('C,D,E,F,G,K,L', r.诊疗类别) > 0 Then
              Zl_电子病历时机_Delete(r_Rolladvice.病人id, r_Rolladvice.主页id, '医嘱', r_Rolladvice.开嘱科室id, r.Id);
            End If;
          End Loop;
        End If;
      End If;
    End If;
    Exit When r_Rolladvice.发送号 = 0;
  End Loop;
  Close c_Rolladvice;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱记录_回退;
/

--98870:梁唐彬,2017-07-10,德阳转病区费用问题
--110594:余伟节,2017-06-27,病案主页新增入科时间
Create Or Replace Procedure Zl_病人变动记录_Undo
(
  病人id_In     病案主页.病人id%Type,
  主页id_In     病案主页.主页id%Type,
  操作员编号_In 病人变动记录.操作员编号%Type,
  操作员姓名_In 病人变动记录.操作员姓名%Type,
  数据_In       Varchar2 := Null, --a.转为住院时,清除住院号,b-检查自动记帐费用是否已结帐
  床号_In       Varchar2 := Null, --传入时表示撤销出院时安排到新的床号，原床位被占用在程序中判断
  主床位_In     Varchar2 := Null, --传入时表示撤销出院时安排到新的主床位，原床位被占用在程序中判断
  撤销方式_In   Varchar2 := Null --指明具体撤销操作，如撤销出院、转科等必须输入
) As
  -----------------------------------------------------------
  --说明：1.撤消病人最近一次的变动
  --        2.前提：当病人包床时,对其中一张床位作变动,则所有床位相应产生变动
  -----------------------------------------------------------
  --要撤消的变动记录(如果包床,可能多条)
  Cursor c_Curlog Is
    Select *
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And (终止时间 Is Null Or 终止原因 = 1)
    Order By 终止时间 Desc, 开始时间 Desc;
  r_Curlogrow c_Curlog%RowType;

  Cursor c_Curautolog Is
    Select *
    From 病人自动计算
    Where 病人id = 病人id_In And 主页id = 主页id_In And (终止时间 Is Null Or 终止原因 = 1) And 性质 = 2
    Order By 终止时间 Desc, 开始时间 Desc;
  r_Curautologrow c_Curautolog%RowType;

  Cursor c_Curautohllog Is
    Select *
    From 病人自动计算
    Where 病人id = 病人id_In And 主页id = 主页id_In And (终止时间 Is Null Or 终止原因 = 1) And 性质 = 1
    Order By 终止时间 Desc, 开始时间 Desc;
  r_Curautohllogrow c_Curautohllog%RowType;

  --撤消后要恢复的变动记录(如果包床,可能多条)
  Cursor c_Prelog
  (
    v_终止时间 病人变动记录.终止时间%Type,
    v_终止原因 病人变动记录.终止原因%Type
  ) Is
    Select *
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_终止时间 And 终止原因 = v_终止原因
    Order By 终止时间 Desc, 开始时间 Desc;
  r_Prelogrow c_Prelog%RowType;

  --获取病人原床位所住病人信息
  Cursor c_Prebed
  (
    v_病人id 病案主页.病人id%Type,
    v_主页id 病案主页.主页id%Type
  ) Is
    Select a.床号, c.出院病床, c.出院科室id, c.当前病区id
    From 病人变动记录 A, 床位状况记录 B, 病案主页 C
    Where a.病人id = 病人id_In And a.主页id = 主页id_In And 终止原因 = 4 And a.病区id = b.病区id And a.病人id = c.病人id And
          a.主页id = c.主页id And a.床号 = b.床号
    Order By 终止时间 Desc, 开始时间 Desc;
  r_Prebedrow c_Prebed%RowType;

  Cursor c_Prebedpati
  (
    v_出院科室id 病人变动记录.科室id%Type,
    v_病区id     病人变动记录.病区id%Type,
    v_原床号     病人变动记录.床号%Type
  ) Is
    Select a.病人id, c.主页id, a.床号, c.出院病床
    From 病人变动记录 A, 病案主页 C,
         (Select 病人id
           From 床位状况记录
           Where (科室id Is Null Or 科室id = v_出院科室id Or 共用 = 1) And 病区id = v_病区id And 床号 = v_原床号) D
    Where a.病人id = d.病人id And a.主页id = (Select 主页id From 病人信息 Where 病人id = d.病人id) And a.终止原因 = 4 And a.病人id = c.病人id And
          a.主页id = c.主页id
    Order By 终止时间 Desc, 开始时间 Desc;
  r_Prebedpati c_Prebedpati%RowType;

  v_开始时间       病人变动记录.开始时间%Type;
  v_开始原因       病人变动记录.开始原因%Type;
  v_终止人员       病人变动记录.终止人员%Type;
  v_Auto开始时间   病人变动记录.开始时间%Type;
  v_Autohl开始时间 病人变动记录.开始时间%Type;

  v_Count       Number;
  v_Countcurlog Number;
  v_Countprelog Number;

  Err_Custom Exception;
  v_Error Varchar2(255);

  v_撤销方式     Varchar2(100);
  v_共享号       Zlsystems.共享号%Type;
  v_病案状态     Number(3);
  v_床号串       Varchar2(255);
  v_床号         病人变动记录.床号%Type;
  v_病人id       病人变动记录.病人id%Type;
  v_主页id       病人变动记录.主页id%Type;
  v_病区id       病人变动记录.病区id%Type;
  v_原床号1      病人变动记录.床号%Type;
  v_原床号2      病人变动记录.床号%Type;
  v_当前床号1    病人变动记录.床号%Type;
  v_当前床号2    病人变动记录.床号%Type;
  v_出院科室id   病人变动记录.科室id%Type;
  v_床位等级id   病人变动记录.床位等级id%Type;
  v_险类         病案主页.险类%Type;
  v_姓名         病人信息.姓名%Type;
  n_原科室id     病案主页.出院科室id%Type;
  n_原病区id     病案主页.当前病区id%Type;
  v_母婴转科标志 病案主页.母婴转科标志%Type;
  v_Tmp          Varchar2(100);
  d_开始时间     Date;

  Function Checkpatiadvice
  (
    病人id_In   病案主页.病人id%Type,
    主页id_In   病案主页.主页id%Type,
    撤销方式_In Varchar2 := Null
  ) Return Varchar2 Is
    --本次住院所有医嘱记录都已作废
    v_Err Varchar2(255);
  Begin
    v_Err := Null;
  
    For r_Row In (Select 开嘱医生, Decode(医嘱状态, -1, '暂存', 1, '新开', 2, '校对疑问', '未作废') As 状态, 医嘱内容
                  From 病人医嘱记录
                  Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(医嘱状态, 0) <> 4 And Rownum < 2) Loop
      v_Err := '[ZLSOFT]【' || r_Row.开嘱医生 || '】医生有' || r_Row.状态 || '的医嘱没有处理,不允许撤销' || 撤销方式_In || '！[ZLSOFT]';
    End Loop;
    Return v_Err;
  End Checkpatiadvice;
Begin
  If 撤销方式_In Is Null Then
    v_Error := '[ZLSOFT]没有指明具体的撤销操作！[ZLSOFT]';
    Raise Err_Custom;
  Else
    v_撤销方式 := 撤销方式_In;
  End If;

  Open c_Curlog;
  Fetch c_Curlog
    Into r_Curlogrow;
  --撤销出院之前，先检查是否恢复病人自动计算数据；
  If r_Curlogrow.终止时间 Is Not Null And r_Curlogrow.终止原因 = 1 And v_撤销方式 = '出院' Then
    Zl_病人自动计算_修正(病人id_In, 主页id_In);
  End If;
  Open c_Curautolog;
  Fetch c_Curautolog
    Into r_Curautologrow;
  Open c_Curautohllog;
  Fetch c_Curautohllog
    Into r_Curautohllogrow;
  If c_Curlog%RowCount = 0 Then
    v_Error := '[ZLSOFT]病人当前没有可以撤消的操作！[ZLSOFT]';
    Close c_Curlog;
    Raise Err_Custom;
  End If;

  Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id > 主页id_In;
  If v_Count > 0 Then
    v_Error := '[ZLSOFT]您只能对病人的最后一次住院进行撤销操作,本次撤销操作终止![ZLSOFT]';
    Raise Err_Custom;
  End If;

  Select Count(ID)
  Into v_Countcurlog
  From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And (终止时间 Is Null Or 终止原因 = 1)
  Order By 终止时间 Desc, 开始时间 Desc;

  Select Count(a.床号)
  Into v_Countprelog
  From 病人变动记录 A, 床位状况记录 B, 病案主页 C
  Where a.病人id = 病人id_In And a.主页id = 主页id_In And 终止原因 = 4 And a.病区id = b.病区id And a.病人id = c.病人id And a.主页id = c.主页id And
        a.床号 = b.床号
  Order By 终止时间 Desc, 开始时间 Desc;

  --判断是否撤消床位对换
  If v_撤销方式 = '换床' And v_Countcurlog <= 1 And v_Countprelog <= 1 Then
    Open c_Prebed(病人id_In, 主页id_In);
    Fetch c_Prebed
      Into r_Prebedrow;
  
    v_出院科室id := r_Prebedrow.出院科室id;
    v_病区id     := r_Prebedrow.当前病区id;
    v_原床号1    := r_Prebedrow.床号;
    v_当前床号1  := r_Prebedrow.出院病床;
  
    For r_Prebedpati In c_Prebedpati(v_出院科室id, v_病区id, v_原床号1) Loop
      v_病人id    := r_Prebedpati.病人id;
      v_主页id    := r_Prebedpati.主页id;
      v_原床号2   := r_Prebedpati.床号;
      v_当前床号2 := r_Prebedpati.出院病床;
    
      If v_病人id <> 0 And v_主页id <> 0 And v_原床号1 = v_当前床号2 And v_原床号2 = v_当前床号1 Then
        v_撤销方式 := '床位对换';
        Select 险类 Into v_险类 From 病案主页 Where 病人id = v_病人id And 主页id = v_主页id;
        If v_险类 Is Null Then
          Zl_病人变动记录_Undo(v_病人id, v_主页id, 操作员编号_In, 操作员姓名_In, Null, 床号_In, 主床位_In, v_撤销方式);
        Else
          Zl_病人变动记录_Undo(v_病人id, v_主页id, 操作员编号_In, 操作员姓名_In, '1', 床号_In, 主床位_In, v_撤销方式);
        End If;
      End If;
    
      --只对最近一次床位是对方床位的记录进行处理
      Exit;
    End Loop;
  End If;

  If r_Curlogrow.终止时间 Is Null And r_Curlogrow.开始时间 Is Null And r_Curlogrow.开始原因 = 3 And v_撤销方式 = '转科' Then
    --撤消转科(标志)
    Delete From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 Is Null And 终止时间 Is Null And 开始原因 = 3;
  
    Update 病案主页 Set 状态 = 0 Where 病人id = 病人id_In And 主页id = 主页id_In;
  
    Close c_Curlog;
  Elsif r_Curlogrow.终止时间 Is Null And r_Curlogrow.开始时间 Is Null And r_Curlogrow.开始原因 = 15 And v_撤销方式 = '转病区' Then
    --撤消转科(标志)
    Delete From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 Is Null And 终止时间 Is Null And 开始原因 = 15;
  
    Update 病案主页 Set 状态 = 0 Where 病人id = 病人id_In And 主页id = 主页id_In;
  
    Close c_Curlog;
  Elsif r_Curlogrow.终止时间 Is Not Null And r_Curlogrow.终止原因 = 1 And v_撤销方式 = '出院' Then
    --撤消出院
    v_开始时间     := r_Curlogrow.终止时间; --新增的变动记录的开始时间
    v_Auto开始时间 := r_Curautologrow.终止时间;
    Select Zl_住院日报_Count(r_Curlogrow.科室id, r_Curlogrow.终止时间) Into v_Count From Dual;
    If v_Count > 0 Then
      v_Error := '[ZLSOFT]已产生业务时间内的住院日报,不能办理该业务![ZLSOFT]';
      Raise Err_Custom;
    End If;
    --是否进行过电子病案审查
    Select Nvl(病案状态, 0) Into v_病案状态 From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
    If v_病案状态 Not In (0, 2) Then
      v_Error := '[ZLSOFT]病人的电子病案已提交审查，不能再撤消出院。[ZLSOFT]';
      Close c_Curlog;
      Raise Err_Custom;
    End If;
  
    --删除病历书写时机
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '出院', r_Curlogrow.科室id);
  
    --恢复入院
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Not Null And 终止原因 = 1;
    Update 病人自动计算
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Not Null And 终止原因 = 1;
  
    Select 开始原因
    Into v_开始原因
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And Nvl(附加床位, 0) = 0;
  
    Update 病案主页
    Set 状态 = Decode(v_开始原因, 10, 3, 状态), 出院日期 = Null, 出院方式 = Null, 随诊标志 = Null, 随诊期限 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In;
    --处理床位
    If 床号_In Is Null Then
      --原床位没有被占用,家庭病床也不会被占用(程序中已判断被占用情况,占用会传入床号_In)
      Close c_Curlog;
      For r_Curlogrow In c_Curlog Loop
        If r_Curlogrow.床号 Is Not Null Then
          --检查床位
          Select Count(*)
          Into v_Count
          From 床位状况记录
          Where 病区id = r_Curlogrow.病区id And 床号 = r_Curlogrow.床号 And 状态 = '空床';
          If v_Count = 0 Then
            v_Error := '[ZLSOFT]操作失败,床位 ' || r_Curlogrow.床号 || ' 不是空床！[ZLSOFT]';
            Raise Err_Custom;
          End If;
          --重新占用床位
          Update 床位状况记录
          Set 状态 = '占用', 病人id = 病人id_In, 等级id = r_Curlogrow.床位等级id, 科室id = r_Curlogrow.科室id --强行恢复以前的科室,共用床也不用处理了。
          Where 病区id = r_Curlogrow.病区id And 床号 = r_Curlogrow.床号;
        End If;
      
        If Nvl(r_Curlogrow.附加床位, 0) = 0 Then
          Update 病人信息
          Set 出院时间 = Null, 当前病区id = r_Curlogrow.病区id, 当前科室id = r_Curlogrow.科室id, 当前床号 = r_Curlogrow.床号, 在院 = 1
          Where 病人id = 病人id_In;
        
          --更新在院病人
          Begin
            Update 在院病人
            Set 病区id = Nvl(r_Curlogrow.病区id, 0), 科室id = r_Curlogrow.科室id
            Where 病人id = 病人id_In;
            If Sql%RowCount = 0 Then
              Insert Into 在院病人
                (病人id, 科室id, 病区id, 主页id)
              Values
                (病人id_In, r_Curlogrow.科室id, Nvl(r_Curlogrow.病区id, 0), Nvl(主页id_In, 0));
            End If;
          Exception
            When Others Then
              Null;
          End;
        
        End If;
      End Loop;
    Else
      --原床位被占用，传入新安排的床位,入住一张或多张病床病床
      v_床号串 := 床号_In || ',';
      --如果病人出院前状态为预出院，则撤消预出院
      If v_开始原因 = 10 Then
        --撤消预出院
        Update 病案主页 Set 状态 = 0 Where 病人id = 病人id_In And 主页id = 主页id_In;
        --恢复变动
        Delete From 病人变动记录
        Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 10 And 终止时间 Is Null;
      
        Update 病人变动记录
        Set 终止时间 = v_开始时间, 终止原因 = 4, 终止人员 = 操作员姓名_In,
            上次计算时间 = Decode(Sign(Nvl(上次计算时间, v_开始时间) - v_开始时间), 1, Null, 上次计算时间)
        Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 10 And 终止时间 = r_Curlogrow.开始时间;
      Else
        Update 病人变动记录
        Set 终止时间 = v_开始时间, 终止原因 = 4, 终止人员 = 操作员姓名_In,
            上次计算时间 = Decode(Sign(Nvl(上次计算时间, v_开始时间) - v_开始时间), 1, Null, 上次计算时间)
        Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
      End If;
    
      Update 病人自动计算
      Set 终止时间 = v_Auto开始时间, 终止原因 = 4, 终止人员 = 操作员姓名_In,
          上次计算时间 = Decode(Sign(Nvl(上次计算时间, v_开始时间) - v_开始时间), 1, Null, 上次计算时间)
      Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And 性质 In (2, 3);
    
      While v_床号串 Is Not Null Loop
        v_床号 := Substr(v_床号串, 1, Instr(v_床号串, ',') - 1);
        --原始床位等级与新床位等级及数量在程序中判断
        --检查床位
        Select Count(*)
        Into v_Count
        From 床位状况记录
        Where 病区id = r_Curlogrow.病区id And 床号 = v_床号 And 状态 = '空床';
        If v_Count = 0 Then
          v_Error := '操作失败,床位 ' || v_床号 || ' 不是空床！';
          Close c_Curlog;
          Raise Err_Custom;
        End If;
        --更新床位状况记录
        Update 床位状况记录
        Set 状态 = '占用', 病人id = 病人id_In, 科室id = r_Curlogrow.科室id
        Where 病区id = r_Curlogrow.病区id And 床号 = v_床号;
      
        Select 等级id Into v_床位等级id From 床位状况记录 Where 病区id = r_Curlogrow.病区id And 床号 = v_床号;
        ----新增原因为4
        Insert Into 病人变动记录
          (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号,
           操作员姓名)
        Values
          (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, v_开始时间, 4, Decode(主床位_In, v_床号, 0, 1), r_Curlogrow.病区id,
           r_Curlogrow.科室id, r_Curlogrow.医疗小组id, r_Curlogrow.护理等级id, v_床位等级id, v_床号, r_Curlogrow.责任护士, r_Curlogrow.经治医师,
           r_Curlogrow.主治医师, r_Curlogrow.主任医师, r_Curlogrow.病情, 操作员编号_In, 操作员姓名_In);
        Insert Into 病人自动计算
          (ID, 病人id, 主页id, 开始时间, 开始原因, 性质, 附加床位, 病区id, 科室id, 床位等级id, 床号, 操作员编号, 操作员姓名)
        Values
          (病人自动计算_Id.Nextval, 病人id_In, 主页id_In, v_Auto开始时间, 4, 2, Decode(主床位_In, v_床号, 0, 1), r_Curautologrow.病区id,
           r_Curautologrow.科室id, v_床位等级id, v_床号, 操作员编号_In, 操作员姓名_In);
        Insert Into 病人自动计算
          (ID, 病人id, 主页id, 开始时间, 开始原因, 性质, 附加床位, 病区id, 科室id, 床位等级id, 床号, 操作员编号, 操作员姓名)
        Values
          (病人自动计算_Id.Nextval, 病人id_In, 主页id_In, v_Auto开始时间, 4, 3, Decode(主床位_In, v_床号, 0, 1), r_Curautologrow.病区id,
           r_Curautologrow.科室id, v_床位等级id, v_床号, 操作员编号_In, 操作员姓名_In);
      
        v_床号串 := Substr(v_床号串, Instr(v_床号串, ',') + 1);
      End Loop;
      --更新病人信息
      Update 病人信息
      Set 出院时间 = Null, 当前病区id = r_Curlogrow.病区id, 当前科室id = r_Curlogrow.科室id, 当前床号 = 主床位_In, 在院 = 1
      Where 病人id = 病人id_In;
    
      --更新在院病人
      Begin
        Update 在院病人 Set 病区id = Nvl(r_Curlogrow.病区id, 0), 科室id = r_Curlogrow.科室id Where 病人id = 病人id_In;
        If Sql%RowCount = 0 Then
          Insert Into 在院病人
            (病人id, 科室id, 病区id, 主页id)
          Values
            (病人id_In, r_Curlogrow.科室id, Nvl(r_Curlogrow.病区id, 0), Nvl(主页id_In, 0));
        End If;
      Exception
        When Others Then
          Null;
      End;
    
      --更新病案主页出院病床
      Update 病案主页 Set 出院病床 = 主床位_In Where 病人id = 病人id_In And 主页id = 主页id_In;
      Close c_Curlog;
    End If;
    --删除出院诊断 保留该诊断信息
    --Delete From 病人诊断记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 诊断类型 in (3,13) And 记录来源 = 2;
  
    Begin
      Select 共享号 Into v_共享号 From zlSystems Where Floor(编号 / 100) = 3;
    Exception
      When Others Then
        Null;
    End;
    --删除该病人的随诊记录
    If v_共享号 = 100 Then
      Execute Immediate 'Delete From 随诊记录 Where 病人id =:1 And 主页id =:2'
        Using 病人id_In, 主页id_In;
    End If;
  Elsif r_Curlogrow.开始原因 = 1 And v_撤销方式 = '入院入住' Then
    v_Error := Checkpatiadvice(病人id_In, 主页id_In, 撤销方式_In);
    If v_Error Is Not Null Then
      Raise Err_Custom;
    End If;
    --撤消入科(入院同时入科)
    v_开始时间 := r_Curlogrow.开始时间;
    Select Zl_住院日报_Count(r_Curlogrow.科室id, v_开始时间) Into v_Count From Dual;
    If v_Count > 0 Then
      v_Error := '[ZLSOFT]已产生业务时间内的住院日报,不能办理该业务![ZLSOFT]';
      Raise Err_Custom;
    End If;
  
    Select Count(1)
    Into v_Count
    From 病人护理文件 A, 病人护理数据 B
    Where a.Id = b.文件id And 病人id = 病人id_In And 主页id = 主页id_In And 科室id = r_Curlogrow.科室id And Rownum < 2;
    If v_Count > 0 Then
      v_Error := '[ZLSOFT]病人已产生有数据的护理文件，不能办理该业务！[ZLSOFT]';
      Raise Err_Custom;
    End If;
    Delete From 病人护理文件 Where 病人id = 病人id_In And 主页id = 主页id_In And 科室id = r_Curlogrow.科室id;
  
    Close c_Curlog;
  
    If 数据_In = '1' Then
      For r_Fee In (Select NO
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 登记时间 >= v_开始时间
                    Group By NO, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        v_Error := '[ZLSOFT]该病人的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
    --退除当前床位
    For r_Curlogrow In c_Curlog Loop
      If r_Curlogrow.床号 Is Not Null Then
        Update 床位状况记录
        Set 状态 = '空床', 病人id = Null, 科室id = Decode(共用, 1, Null, 科室id)
        Where 病区id = r_Curlogrow.病区id And 床号 = r_Curlogrow.床号;
      End If;
    End Loop;
    --相关信息还原
    Update 病案主页 Set 入院病床 = Null, 出院病床 = Null, 入科时间 = Null, 状态 = 1 Where 病人id = 病人id_In And 主页id = 主页id_In;
  
    Update 病人信息 Set 当前床号 = Null Where 病人id = 病人id_In;
  
    --恢复变动(入院同时入科不会有包床)
    --因为是同一条记录中的撤消,所以不处理人员
    Update 病人变动记录
    Set 床位等级id = Null, 床号 = Null, 责任护士 = Null, 经治医师 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 1 And 终止时间 Is Null;
  
    Update 病人自动计算
    Set 床位等级id = Null, 床号 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 1 And 终止时间 Is Null;
  Elsif r_Curlogrow.开始原因 = 2 And v_撤销方式 = '入住' Then
    v_Error := Checkpatiadvice(病人id_In, 主页id_In, 撤销方式_In);
    If v_Error Is Not Null Then
      Raise Err_Custom;
    End If;
    --撤消入院入科
    v_开始时间       := r_Curlogrow.开始时间;
    v_Auto开始时间   := r_Curautologrow.开始时间;
    v_Autohl开始时间 := r_Curautohllogrow.开始时间;
    Select Zl_住院日报_Count(r_Curlogrow.科室id, v_开始时间) Into v_Count From Dual;
    If v_Count > 0 Then
      v_Error := '[ZLSOFT]已产生业务时间内的住院日报,不能办理该业务![ZLSOFT]';
      Raise Err_Custom;
    End If;
  
    Select Count(1)
    Into v_Count
    From 病人护理文件 A, 病人护理数据 B
    Where a.Id = b.文件id And 病人id = 病人id_In And 主页id = 主页id_In And 科室id = r_Curlogrow.科室id And Rownum < 2;
    If v_Count > 0 Then
      v_Error := '[ZLSOFT]病人已产生有数据的护理文件，不能办理该业务！[ZLSOFT]';
      Raise Err_Custom;
    End If;
    Delete From 病人护理文件 Where 病人id = 病人id_In And 主页id = 主页id_In And 科室id = r_Curlogrow.科室id;
  
    If 数据_In = '1' Then
      For r_Fee In (Select NO
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 登记时间 >= v_开始时间
                    Group By NO, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        v_Error := '[ZLSOFT]该病人的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
    --删除病历书写时机
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '入院', r_Curlogrow.科室id);
    Close c_Curlog;
    --退除当前床位
    For r_Curlogrow In c_Curlog Loop
      If r_Curlogrow.床号 Is Not Null Then
        Update 床位状况记录
        Set 状态 = '空床', 病人id = Null, 科室id = Decode(共用, 1, Null, 科室id)
        Where 病区id = r_Curlogrow.病区id And 床号 = r_Curlogrow.床号;
      End If;
    End Loop;
    --相关信息还原
    Open c_Prelog(v_开始时间, 2);
    Fetch c_Prelog
      Into r_Prelogrow;
    Update 病案主页
    Set 入院病床 = Null, 出院病床 = Null, 入科时间 = Null, 状态 = 1, 当前病况 = r_Prelogrow.病情, 入院病况 = r_Prelogrow.病情, 医疗小组id = r_Prelogrow.医疗小组id,
        护理等级id = r_Prelogrow.护理等级id
    Where 病人id = 病人id_In And 主页id = 主页id_In;
    Close c_Prelog;
  
    Update 病人信息 Set 当前床号 = Null Where 病人id = 病人id_In;
    Delete 病案主页从表
    Where 病人id = 病人id_In And 主页id = 主页id_In And (信息名 = '主治医师' Or 信息名 = '主任医师');
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 2 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 2 And 终止时间 = v_开始时间
    Returning 病区id Into v_病区id;
    --入院时未指定病区,撤销入住时将病区清空
    If Nvl(v_病区id, 0) = 0 Then
      Update 病人信息 Set 当前病区id = Null Where 病人id = 病人id_In;
      Update 病案主页 Set 当前病区id = Null, 入院病区id = Null Where 病人id = 病人id_In And 主页id = 主页id_In;
      Update 在院病人 Set 病区id = 0 Where 病人id = 病人id_In;
    End If;
  
    Delete From 病人自动计算 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 2 And 终止时间 Is Null;
    Update 病人自动计算
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 2 And 终止时间 = v_Auto开始时间 And 性质 In (2, 3);
    Update 病人自动计算
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 2 And 终止时间 = v_Autohl开始时间 And 性质 = 1;
  Elsif r_Curlogrow.开始原因 = 3 And v_撤销方式 = '转科入住' Then
    --撤消转科入科
    v_开始时间       := r_Curlogrow.开始时间;
    v_Auto开始时间   := r_Curautologrow.开始时间;
    v_Autohl开始时间 := r_Curautohllogrow.开始时间;
    Select Zl_住院日报_Count(r_Curlogrow.科室id, v_开始时间) Into v_Count From Dual;
    If v_Count > 0 Then
      v_Error := '[ZLSOFT]已产生业务时间内的住院日报,不能办理该业务![ZLSOFT]';
      Raise Err_Custom;
    End If;
  
    Select Count(1)
    Into v_Count
    From 病人护理文件
    Where 病人id = 病人id_In And 主页id = 主页id_In And 科室id = r_Curlogrow.科室id And 创建时间 >= r_Curlogrow.开始时间;
    If v_Count > 0 Then
      v_Error := '[ZLSOFT]病人已产生护理文件，不能办理该业务！[ZLSOFT]';
      Raise Err_Custom;
    End If;
  
    If 数据_In = '1' Then
      For r_Fee In (Select NO
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 登记时间 >= v_开始时间
                    Group By NO, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        v_Error := '[ZLSOFT]该病人的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
  
    --删除病历书写时机
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '转科', r_Curlogrow.科室id);
    Close c_Curlog;
    --退除当前床位
    For r_Curlogrow In c_Curlog Loop
      If r_Curlogrow.床号 Is Not Null Then
        Update 床位状况记录
        Set 状态 = '空床', 病人id = Null, 科室id = Decode(共用, 1, Null, 科室id)
        Where 病区id = r_Curlogrow.病区id And 床号 = r_Curlogrow.床号;
      End If;
    End Loop;
    --检查及还原原床位
    For r_Prelogrow In c_Prelog(v_开始时间, 3) Loop
      d_开始时间 := r_Prelogrow.开始时间;
      If r_Prelogrow.床号 Is Not Null Then
        Select Count(*)
        Into v_Count
        From 床位状况记录
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号 And 状态 = '空床';
        If v_Count = 0 Then
          v_Error := '[ZLSOFT]病人转入该科室前的床位 ' || r_Prelogrow.床号 || ' 当前非空床或已经撤消！[ZLSOFT]';
          Raise Err_Custom;
        End If;
      
        Update 床位状况记录
        Set 状态 = '占用', 病人id = 病人id_In, 等级id = r_Prelogrow.床位等级id, 科室id = r_Prelogrow.科室id --强行恢复以前的科室,共用床也不用处理了。
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号;
      End If;
      --相关信息还原
      If Nvl(r_Prelogrow.附加床位, 0) = 0 Then
        --判断是否有婴儿
        Select Count(1) Into v_Count From 病人新生儿记录 Where 病人id = 病人id_In And 主页id = 主页id_In;
        If v_Count > 0 Then
          Select 母婴转科标志 Into v_母婴转科标志 From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
          If v_母婴转科标志 Is Not Null Then
            If Substr(v_母婴转科标志, Length(v_母婴转科标志)) = '1' Then
              --如果是1表示母亲和婴儿未分开，则清空“病案主页.婴儿科室ID”和”病案主页.婴儿病区ID”；
              Update 病案主页 Set 婴儿科室id = Null, 婴儿病区id = Null Where 病人id = 病人id_In And 主页id = 主页id_In;
              If Length(v_母婴转科标志) > 1 Then
                v_母婴转科标志 := Substr(v_母婴转科标志, 1, Length(v_母婴转科标志) - 1);
              Else
                v_母婴转科标志 := '';
              End If;
            Else
              --如果是0，表示是上次转科是母亲单独转走的，则重新将原产科科室和病区填写到“病案主页.婴儿科室ID”和”病案主页.婴儿病区ID”（从病人变动记录中取），并清除最后一位标识
              If Length(v_母婴转科标志) > 1 Then
                v_母婴转科标志 := Substr(v_母婴转科标志, 1, Length(v_母婴转科标志) - 1);
                --查看上一次转科的标识
                If Substr(v_母婴转科标志, Length(v_母婴转科标志)) = '1' Then
                  Update 病案主页
                  Set 婴儿科室id = Null, 婴儿病区id = Null
                  Where 病人id = 病人id_In And 主页id = 主页id_In;
                Else
                  --取出转科前的婴儿科室病区ID
                  v_Tmp   := v_母婴转科标志;
                  v_Count := 1;
                  While v_Tmp Is Not Null Loop
                    v_Count := v_Count + 1;
                    If Substr(v_Tmp, Length(v_Tmp)) = '1' Then
                      Select Max(a.科室id) As 科室id, Max(a.病区id) As 科室id
                      Into n_原科室id, n_原病区id
                      From (Select 科室id, 病区id, Rownum As 序号
                             From (Select 科室id, 病区id
                                    From 病人变动记录
                                    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 3 And 附加床位 = 0
                                    Order By 开始时间 Desc)) A
                      Where 序号 = v_Count;
                    End If;
                    If Length(v_Tmp) = 1 Then
                      v_Tmp := '';
                    Else
                      v_Tmp := Substr(v_Tmp, 1, Length(v_Tmp) - 1);
                    End If;
                  End Loop;
                  If Nvl(n_原科室id, 0) = 0 Then
                    --如果没有找到，则取入院科室
                    Select Max(b.科室id), Max(b.病区id)
                    Into n_原科室id, n_原病区id
                    From 病人变动记录 B
                    Where b.病人id = 病人id_In And b.主页id = 主页id_In And b.科室id Is Not Null And b.病区id Is Not Null And
                          b.开始时间 = (Select Min(a.开始时间)
                                    From 病人变动记录 A
                                    Where a.病人id = b.病人id And a.主页id = b.主页id And a.科室id Is Not Null And
                                          a.病区id Is Not Null And a.附加床位 = 0);
                  End If;
                
                  If Nvl(n_原科室id, 0) <> 0 Then
                    Update 病案主页
                    Set 婴儿科室id = n_原科室id, 婴儿病区id = n_原病区id
                    Where 病人id = 病人id_In And 主页id = 主页id_In;
                  Else
                    --之前没有转科记录,清空婴儿科室ID和婴儿病区ID
                    Update 病案主页
                    Set 婴儿科室id = Null, 婴儿病区id = Null
                    Where 病人id = 病人id_In And 主页id = 主页id_In;
                  End If;
                End If;
              Else
                --只有这一次转科,回退后清空婴儿科室病区ID
                v_母婴转科标志 := '';
                Update 病案主页
                Set 婴儿科室id = Null, 婴儿病区id = Null
                Where 病人id = 病人id_In And 主页id = 主页id_In;
              End If;
            End If;
            --去除最后一位标识
            Update 病案主页 Set 母婴转科标志 = v_母婴转科标志 Where 病人id = 病人id_In And 主页id = 主页id_In;
          End If;
        
        End If;
      
        Update 病案主页
        Set 状态 = 2, 当前病区id = r_Prelogrow.病区id, 出院科室id = r_Prelogrow.科室id, 医疗小组id = r_Prelogrow.医疗小组id,
            出院病床 = r_Prelogrow.床号, 护理等级id = r_Prelogrow.护理等级id, 责任护士 = r_Prelogrow.责任护士, 住院医师 = r_Prelogrow.经治医师,
            当前病况 = r_Curlogrow.病情
        Where 病人id = 病人id_In And 主页id = 主页id_In;
      
        Update 病案主页从表
        Set 信息值 = r_Prelogrow.主治医师
        Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主治医师';
        Update 病案主页从表
        Set 信息值 = r_Prelogrow.主任医师
        Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主任医师';
      
        Update 病人信息
        Set 当前病区id = r_Prelogrow.病区id, 当前科室id = r_Prelogrow.科室id, 当前床号 = r_Prelogrow.床号
        Where 病人id = 病人id_In;
      
        --更新在院病人
        Update 在院病人 Set 病区id = Nvl(r_Prelogrow.病区id, 0), 科室id = r_Prelogrow.科室id Where 病人id = 病人id_In;
      
      End If;
    End Loop;
    --恢复变动(恢复到临时转科标记状态)
    Delete From 病人变动记录
    Where 附加床位 = 1 And 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 3 And 终止时间 Is Null;
  
    Delete From 病人自动计算 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 3 And 终止时间 Is Null;
  
    Select 终止人员
    Into v_终止人员
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 3 And 终止时间 = v_开始时间 And Nvl(附加床位, 0) = 0;
    --临时记录的操作员信息记录的是终止人员,因为没有记录终止人员编号,就不恢复
    Update 病人变动记录
    Set 开始时间 = Null, 医疗小组id = Null, 护理等级id = Null, 床位等级id = Null, 床号 = Null, 责任护士 = Null, 经治医师 = Null, 操作员编号 = Null,
        操作员姓名 = v_终止人员, 上次计算时间 = Null, 病区id = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 3 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 3 And 终止时间 = v_开始时间 And 开始时间 = d_开始时间;
  
    Update 病人自动计算
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 3 And 终止时间 = v_Auto开始时间 And 性质 In (2, 3);
  
    Update 病人自动计算
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 3 And 终止时间 = v_Autohl开始时间 And 性质 = 1;
  
  Elsif r_Curlogrow.开始原因 = 4 And v_撤销方式 = '换床' Then
    --撤消换床
    v_开始时间     := r_Curlogrow.开始时间;
    v_Auto开始时间 := r_Curautologrow.开始时间;
    Close c_Curlog;
    If 数据_In = '1' Then
      For r_Fee In (Select NO
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 登记时间 >= v_开始时间
                    Group By NO, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        v_Error := '[ZLSOFT]该病人的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
    --退除当前床位
    For r_Curlogrow In c_Curlog Loop
      If r_Curlogrow.床号 Is Not Null Then
        Update 床位状况记录
        Set 状态 = '空床', 病人id = Null, 科室id = Decode(共用, 1, Null, 科室id)
        Where 病区id = r_Curlogrow.病区id And 床号 = r_Curlogrow.床号;
      End If;
    End Loop;
    --检查及还原原床位
    For r_Prelogrow In c_Prelog(v_开始时间, 4) Loop
      d_开始时间 := r_Prelogrow.开始时间;
      If r_Prelogrow.床号 Is Not Null Then
        Select Count(*)
        Into v_Count
        From 床位状况记录
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号 And 状态 = '空床';
        If v_Count = 0 Then
          v_Error := '[ZLSOFT]病人最近一次换床前所入住的床位 ' || r_Prelogrow.床号 || ' 当前非空床或已经撤消！[ZLSOFT]';
          Raise Err_Custom;
        End If;
      
        Update 床位状况记录
        Set 状态 = '占用', 病人id = 病人id_In, 等级id = r_Prelogrow.床位等级id, 科室id = Decode(共用, 1, r_Prelogrow.科室id, 科室id)
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号;
      End If;
      --病人信息、病案主页,仅当病区与科室独立时,换床才可以换病区,此处为简化判断,统一还原病区
      If Nvl(r_Prelogrow.附加床位, 0) = 0 Then
        Update 病案主页
        Set 出院病床 = r_Prelogrow.床号, 当前病区id = r_Prelogrow.病区id
        Where 病人id = 病人id_In And 主页id = 主页id_In;
      
        Update 病人信息 Set 当前床号 = r_Prelogrow.床号, 当前病区id = r_Prelogrow.病区id Where 病人id = 病人id_In;
        --更新在院病人
        Update 在院病人 Set 病区id = Nvl(r_Prelogrow.病区id, 0) Where 病人id = 病人id_In;
      End If;
    End Loop;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 4 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 4 And 终止时间 = v_开始时间 And 开始时间 = d_开始时间;
  
    Delete From 病人自动计算
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 4 And 终止时间 Is Null And 性质 In (2, 3);
  
    Update 病人自动计算
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 4 And 终止时间 = v_Auto开始时间 And 性质 In (2, 3);
  Elsif r_Curlogrow.开始原因 = 4 And v_撤销方式 = '床位对换' Then
    --撤消床位对换
    v_开始时间     := r_Curlogrow.开始时间;
    v_Auto开始时间 := r_Curautologrow.开始时间;
    Select 姓名 Into v_姓名 From 病人信息 Where 病人id = 病人id_In;
    Close c_Curlog;
    If 数据_In = '1' Then
      For r_Fee In (Select NO
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 登记时间 >= v_开始时间
                    Group By NO, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        v_Error := '[ZLSOFT]病人 ' || v_姓名 || ' 的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
    --退除当前床位
    --检查及还原原床位
    For r_Prelogrow In c_Prelog(v_开始时间, 4) Loop
      d_开始时间 := r_Prelogrow.开始时间;
      If r_Prelogrow.床号 Is Not Null Then
        Update 床位状况记录
        Set 状态 = '占用', 病人id = 病人id_In, 等级id = r_Prelogrow.床位等级id, 科室id = Decode(共用, 1, r_Prelogrow.科室id, 科室id)
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号;
      End If;
      --病人信息、病案主页,仅当病区与科室独立时,换床才可以换病区,此处为简化判断,统一还原病区
      If Nvl(r_Prelogrow.附加床位, 0) = 0 Then
        Update 病案主页
        Set 出院病床 = r_Prelogrow.床号, 当前病区id = r_Prelogrow.病区id
        Where 病人id = 病人id_In And 主页id = 主页id_In;
      
        Update 病人信息 Set 当前床号 = r_Prelogrow.床号, 当前病区id = r_Prelogrow.病区id Where 病人id = 病人id_In;
        --更新在院病人
        Update 在院病人 Set 病区id = Nvl(r_Prelogrow.病区id, 0) Where 病人id = 病人id_In;
      End If;
    End Loop;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 4 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 4 And 终止时间 = v_开始时间 And 开始时间 = d_开始时间;
  
    Delete From 病人自动计算
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 4 And 终止时间 Is Null And 性质 In (2, 3);
  
    Update 病人自动计算
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 4 And 终止时间 = v_Auto开始时间 And 性质 In (2, 3);
  Elsif r_Curlogrow.开始原因 = 5 And v_撤销方式 = '床位等级变动' Then
    --撤消床位等级变动
    If 数据_In = '1' Then
      For r_Fee In (Select NO
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 收费细目id = r_Curlogrow.床位等级id And
                          登记时间 >= r_Curlogrow.开始时间
                    Group By NO, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        Close c_Curlog;
        v_Error := '[ZLSOFT]该病人的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
    --还原原床位的等级
    For r_Prelogrow In c_Prelog(r_Curlogrow.开始时间, 5) Loop
      d_开始时间 := r_Prelogrow.开始时间;
      If r_Prelogrow.床号 Is Not Null Then
        Update 床位状况记录
        Set 等级id = r_Prelogrow.床位等级id
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号;
      End If;
    End Loop;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 5 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 5 And 终止时间 = r_Curlogrow.开始时间 And 开始时间 = d_开始时间;
  
    Delete From 病人自动计算
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 5 And 终止时间 Is Null And 性质 In (2, 3);
  
    Update 病人自动计算
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 5 And 终止时间 = r_Curautologrow.开始时间 And 性质 In (2, 3);
  
    Close c_Curlog;
  Elsif r_Curlogrow.开始原因 = 6 And v_撤销方式 = '护理等级变动' Then
    --撤消护理等级变动
    If 数据_In = '1' Then
      For r_Fee In (Select NO
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 收费细目id = r_Curlogrow.护理等级id And
                          登记时间 >= r_Curlogrow.开始时间
                    Group By NO, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        Close c_Curlog;
        v_Error := '[ZLSOFT]该病人的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
  
    Open c_Prelog(r_Curlogrow.开始时间, 6);
    Fetch c_Prelog
      Into r_Prelogrow;
    --恢复原护理等级
    Update 病案主页 Set 护理等级id = r_Prelogrow.护理等级id Where 病人id = 病人id_In And 主页id = 主页id_In;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 6 And 终止时间 Is Null;
    Delete From 病人自动计算
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 6 And 终止时间 Is Null And 性质 = 1;
  
    --医嘱产生的护理等级变动没有记录秒，可能前一等级的停止时间与当前等级的开始时间是同一分钟，所以要取max(id)
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 6 And 终止时间 = r_Curlogrow.开始时间 And 开始时间 = r_Prelogrow.开始时间;
    Update 病人自动计算
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 6 And 终止时间 = r_Curautohllogrow.开始时间 And 性质 = 1;
  
    Close c_Prelog;
    Close c_Curlog;
  Elsif r_Curlogrow.开始原因 = 7 And v_撤销方式 = '经治医师改变' Then
    --删除病历书写时机
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '交班', r_Curlogrow.科室id);
    --撤消经治医师改变
    Open c_Prelog(r_Curlogrow.开始时间, 7);
    Fetch c_Prelog
      Into r_Prelogrow;
    --恢复原医师
    Update 病案主页 Set 住院医师 = r_Prelogrow.经治医师 Where 病人id = 病人id_In And 主页id = 主页id_In;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 7 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 7 And 终止时间 = r_Curlogrow.开始时间 And 开始时间 = r_Prelogrow.开始时间;
  
    Close c_Prelog;
    Close c_Curlog;
  Elsif r_Curlogrow.开始原因 = 8 And v_撤销方式 = '责任护士改变' Then
    --撤消责任护士改变
    Open c_Prelog(r_Curlogrow.开始时间, 8);
    Fetch c_Prelog
      Into r_Prelogrow;
    --恢复原责任护士
    Update 病案主页 Set 责任护士 = r_Prelogrow.责任护士 Where 病人id = 病人id_In And 主页id = 主页id_In;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 8 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 8 And 终止时间 = r_Curlogrow.开始时间 And 开始时间 = r_Prelogrow.开始时间;
  
    Close c_Prelog;
    Close c_Curlog;
  Elsif r_Curlogrow.开始原因 = 9 And v_撤销方式 = '转为住院病人' Then
    --撤消转为住院病人
    --删除病历书写时机
    Open c_Prelog(r_Curlogrow.开始时间, 9);
    Fetch c_Prelog
      Into r_Prelogrow;
  
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '入院', r_Curlogrow.科室id);
    Update 病案主页 Set 病人性质 = 2 Where 病人id = 病人id_In And 主页id = 主页id_In;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 9 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 9 And 终止时间 = r_Curlogrow.开始时间 And 开始时间 = r_Prelogrow.开始时间;
  
    If 主页id_In = 1 And Nvl(数据_In, '0') = '1' Then
      Update 病人信息 Set 住院号 = Null Where 病人id = 病人id_In;
      Update 病案主页 Set 住院号 = Null Where 病人id = 病人id_In;
    End If;
  
    Close c_Curlog;
    Close c_Prelog;
  Elsif r_Curlogrow.开始原因 = 10 And v_撤销方式 = '预出院' Then
    --撤消预出院
    --删除病历书写时机
    Open c_Prelog(r_Curlogrow.开始时间, 10);
    Fetch c_Prelog
      Into r_Prelogrow;
  
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '出院', r_Curlogrow.科室id);
    --恢复住院状态
    Update 病案主页 Set 状态 = 0 Where 病人id = 病人id_In And 主页id = 主页id_In;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 10 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 上次计算时间 = Null, 终止人员 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 10 And 终止时间 = r_Curlogrow.开始时间 And 开始时间 = r_Prelogrow.开始时间;
    
    --恢复变动
    Delete From 病人自动计算 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 10 And 终止时间 Is Null;
  
    Update 病人自动计算
    Set 终止时间 = Null, 终止原因 = Null, 上次计算时间 = Null, 终止人员 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 10 And 终止时间 = r_CurAutologrow.开始时间 And 性质 In (2, 3);
    Update 病人自动计算
    Set 终止时间 = Null, 终止原因 = Null, 上次计算时间 = Null, 终止人员 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 10 And 终止时间 = r_CurAutohllogrow.开始时间 And 性质 = 1;
  
    Close c_Curlog;
    Close c_Prelog;
  Elsif r_Curlogrow.开始原因 = 11 And v_撤销方式 = '主治医师变动' Then
    --撤消主治医师改变
    Open c_Prelog(r_Curlogrow.开始时间, 11);
    Fetch c_Prelog
      Into r_Prelogrow;
    --恢复原主治医师
    Update 病案主页从表
    Set 信息值 = r_Prelogrow.主治医师
    Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主治医师';
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 11 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 11 And 终止时间 = r_Curlogrow.开始时间 And 开始时间 = r_Prelogrow.开始时间;
  
    Close c_Prelog;
    Close c_Curlog;
  Elsif r_Curlogrow.开始原因 = 12 And v_撤销方式 = '主任医师变动' Then
    --撤消主任医师改变
    Open c_Prelog(r_Curlogrow.开始时间, 12);
    Fetch c_Prelog
      Into r_Prelogrow;
    --恢复原主任医师
    Update 病案主页从表
    Set 信息值 = r_Prelogrow.主任医师
    Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主任医师';
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 12 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 12 And 终止时间 = r_Curlogrow.开始时间 And 开始时间 = r_Prelogrow.开始时间;
  
    Close c_Prelog;
    Close c_Curlog;
  Elsif r_Curlogrow.开始原因 = 13 And v_撤销方式 = '病况变动' Then
    --撤消病情改变
    Open c_Prelog(r_Curlogrow.开始时间, 13);
    Fetch c_Prelog
      Into r_Prelogrow;
    --恢复原病情
    Update 病案主页 Set 当前病况 = r_Prelogrow.病情 Where 病人id = 病人id_In And 主页id = 主页id_In;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 13 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 13 And 终止时间 = r_Curlogrow.开始时间 And 开始时间 = r_Prelogrow.开始时间;
  
    Close c_Prelog;
    Close c_Curlog;
  
  Elsif r_Curlogrow.开始原因 = 14 And v_撤销方式 = '转医疗小组' Then
    --删除病历书写时机
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '交班', r_Curlogrow.科室id);
  
    --撤消医疗小组改变
    Open c_Prelog(r_Curlogrow.开始时间, 14);
    Fetch c_Prelog
      Into r_Prelogrow;
    --恢复原医疗小组
    Update 病案主页
    Set 医疗小组id = r_Prelogrow.医疗小组id, 住院医师 = r_Prelogrow.经治医师
    Where 病人id = 病人id_In And 主页id = 主页id_In;
    --恢复原主治医师
    Update 病案主页从表
    Set 信息值 = r_Prelogrow.主治医师
    Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主治医师';
  
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 14 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 14 And 终止时间 = r_Curlogrow.开始时间 And 开始时间 = r_Prelogrow.开始时间;
  
    Close c_Prelog;
    Close c_Curlog;
  Elsif r_Curlogrow.开始原因 = 15 And v_撤销方式 = '转病区入住' Then
    --撤消入病区
    v_开始时间       := r_Curlogrow.开始时间;
    v_Auto开始时间   := r_Curautologrow.开始时间;
    v_Autohl开始时间 := r_Curautohllogrow.开始时间;
    If 数据_In = '1' Then
      For r_Fee In (Select NO
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 登记时间 >= v_开始时间
                    Group By NO, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        v_Error := '[ZLSOFT]该病人的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
  
    Open c_Prelog(v_开始时间, 15);
    Fetch c_Prelog
      Into r_Prelogrow;
  
    d_开始时间 := r_Prelogrow.开始时间;
    --对有效的医嘱(未停止、作废的长嘱，未发送的临嘱)，为原病区执行的，将执行科室自动更换为新的病区
    Update 病人医嘱记录
    Set 执行科室id = r_Prelogrow.病区id
    Where 病人id = 病人id_In And 主页id = 主页id_In And 执行科室id = r_Curlogrow.病区id And 医嘱状态 Not In (4, 8, 9) And 开嘱时间 < v_开始时间;
    --转病区时将需要原病区执行的未执行和部分执行的医嘱发送记录转为新病区执行；
    Update 病人医嘱发送 A
    Set a.执行部门id = r_Prelogrow.病区id
    Where a.执行部门id + 0 = r_Curlogrow.病区id And a.医嘱id In (Select ID From 病人医嘱记录 Where 病人id = 病人id_In And 主页id = 主页id_In)
          And A.执行状态 In(0,3);
    Close c_Prelog;
    Close c_Curlog;
  
    --退除当前床位
    For r_Curlogrow In c_Curlog Loop
      If r_Curlogrow.床号 Is Not Null Then
        Update 床位状况记录
        Set 状态 = '空床', 病人id = Null, 科室id = Decode(共用, 1, Null, 科室id)
        Where 病区id = r_Curlogrow.病区id And 床号 = r_Curlogrow.床号;
      End If;
    End Loop;
    --检查及还原原床位
    For r_Prelogrow In c_Prelog(v_开始时间, 15) Loop
      If r_Prelogrow.床号 Is Not Null Then
        Select Count(*)
        Into v_Count
        From 床位状况记录
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号 And 状态 = '空床';
        If v_Count = 0 Then
          v_Error := '[ZLSOFT]病人转入该病区前的床位 ' || r_Prelogrow.床号 || ' 当前非空床或已经撤消！[ZLSOFT]';
          Raise Err_Custom;
        End If;
      
        Update 床位状况记录
        Set 状态 = '占用', 病人id = 病人id_In, 等级id = r_Prelogrow.床位等级id, 科室id = r_Prelogrow.科室id --强行恢复以前的科室,共用床也不用处理了。
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号;
      End If;
      --相关信息还原
      If Nvl(r_Prelogrow.附加床位, 0) = 0 Then
        Update 病案主页
        Set 状态 = 2, 当前病区id = r_Prelogrow.病区id, 出院科室id = r_Prelogrow.科室id, 医疗小组id = r_Prelogrow.医疗小组id,
            出院病床 = r_Prelogrow.床号, 护理等级id = r_Prelogrow.护理等级id, 责任护士 = r_Prelogrow.责任护士, 住院医师 = r_Prelogrow.经治医师,
            当前病况 = r_Curlogrow.病情
        Where 病人id = 病人id_In And 主页id = 主页id_In;
      
        Update 病人信息 Set 当前病区id = r_Prelogrow.病区id, 当前床号 = r_Prelogrow.床号 Where 病人id = 病人id_In;
      
        --更新在院病人
        Update 在院病人 Set 病区id = Nvl(r_Prelogrow.病区id, 0) Where 病人id = 病人id_In;
      
      End If;
    End Loop;
  
    --恢复变动(恢复到临时转科标记状态)
    Delete From 病人变动记录
    Where 附加床位 = 1 And 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 15 And 终止时间 Is Null;
  
    Delete From 病人自动计算 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 15 And 终止时间 Is Null;
  
    Select 终止人员
    Into v_终止人员
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 15 And 终止时间 = v_开始时间 And Nvl(附加床位, 0) = 0;
    --临时记录的操作员信息记录的是终止人员,因为没有记录终止人员编号,就不恢复
    Update 病人变动记录
    Set 开始时间 = Null, 医疗小组id = Null, 护理等级id = Null, 床位等级id = Null, 床号 = Null, 责任护士 = Null, 经治医师 = Null, 操作员编号 = Null,
        操作员姓名 = v_终止人员, 上次计算时间 = Null, 附加床位 = Null, 主治医师 = Null, 病情 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 15 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 15 And 终止时间 = v_开始时间 And 开始时间 = d_开始时间;
    Update 病人自动计算
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 15 And 终止时间 = v_Auto开始时间 And 性质 In (2, 3);
    Update 病人自动计算
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 15 And 终止时间 = v_Autohl开始时间 And 性质 = 1;
  
  Else
    Close c_Curlog;
    v_Error := '[ZLSOFT]你执行的撤销' || v_撤销方式 || '操作已经被其他人执行,请刷新界面！[ZLSOFT]';
    Raise Err_Custom;
  End If;
  Close c_Curautolog;
  Close c_Curautohllog;
  --并发操作检查
  Select Count(*)
  Into v_Count
  From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(附加床位, 0) = 0 And 开始时间 Is Not Null And 终止时间 Is Null;
  If v_Count > 1 Then
    v_Error := '发现病人存在非法的变动记录,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;

  Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In And 出院日期 Is Null;
  If v_Count = 0 Then
    v_Error := '操作失败,该病人已出院,不能进行当前操作' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态！';
    Raise Err_Custom;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, v_Error);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人变动记录_Undo;
/

--110594:余伟节,2017-06-27,病案主页新增入科时间
Create Or Replace Procedure Zl_病人变动记录_Indept
(
  病人id_In       病案主页.病人id%Type,
  主页id_In       病案主页.主页id%Type,
  床号_In         Varchar2,
  病区id_In       病案主页.当前病区id%Type,
  科室id_In       病案主页.出院科室id%Type,
  医疗小组id_In   病案主页.医疗小组id%Type,
  护理等级id_In   病案主页.护理等级id%Type,
  当前病况_In     病案主页.当前病况%Type,
  责任护士_In     病案主页.责任护士%Type,
  门诊医师_In     病案主页.门诊医师%Type,
  住院医师_In     病案主页.住院医师%Type,
  是否陪伴_In     病案主页.是否陪伴%Type,
  入院时间_In     病案主页.入院日期%Type,
  入科时间_In     病人变动记录.开始时间%Type,
  操作员编号_In   人员表.编号%Type,
  操作员姓名_In   人员表.姓名%Type,
  入院_In         Number,
  主治医师_In     病案主页.住院医师%Type := Null,
  主任医师_In     病案主页.住院医师%Type := Null,
  主床位_In       病案主页.出院病床%Type := Null,
  母婴转科标志_In 病案主页.母婴转科标志%Type := '1'
) As
  -----------------------------------------------------------
  --说明：完成病人入院或转科入科处理。
  --参数：
  --       入院_IN:病人是入院还是转科入科。
  --       床号_IN:为空表示家庭病床,否则为"床号1,床号2,...床号n",多个床号时,表示包房。
  -----------------------------------------------------------
  Cursor c_Bedinfo Is
    Select 病区id, 床号 From 床位状况记录 Where 病人id = 病人id_In;

  Cursor c_Oldinfo Is
    Select b.*
    From (Select c.*
           From 病人变动记录 C
           Where c.病人id = 病人id_In And c.主页id = 主页id_In And
                 c.开始时间 = (Select Min(开始时间)
                           From 病人变动记录
                           Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入科时间_In)) A, 病人变动记录 B
    
    Where b.病人id = 病人id_In And b.主页id = 主页id_In And a.开始时间 = b.终止时间 And a.开始原因 = b.终止原因 And a.附加床位 = b.附加床位
    Union
    Select *
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And 开始时间 <= 入科时间_In;
  Cursor c_OldAutoinfo Is
    Select b.*
    From (Select c.*
           From 病人自动计算 C
           Where c.病人id = 病人id_In And c.主页id = 主页id_In And C.性质 = 2 And
                 c.开始时间 = (Select Min(开始时间)
                           From 病人自动计算
                           Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入科时间_In And 性质 = 2)) A, 病人自动计算 B
    
    Where b.病人id = 病人id_In And b.主页id = 主页id_In And a.开始时间 = b.终止时间 And a.开始原因 = b.终止原因 And a.附加床位 = b.附加床位 And B.性质 = 2
    Union
    Select *
    From 病人自动计算
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And 开始时间 <= 入科时间_In And 性质 = 2;
    
  Cursor c_OldAutoHLinfo Is 
        Select b.* 
    From (Select c.* 
           From 病人自动计算 C 
           Where c.病人id = 病人id_In And c.主页id = 主页id_In And C.性质 = 1 And 
                 c.开始时间 = (Select Min(开始时间) From 病人自动计算
                           Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入科时间_In  And 性质 = 1) And
                 NVL(c.终止时间|| '','空') = (Select  NVL(Min(终止时间)|| '','空')
                           From 病人自动计算 Where 病人id = 病人id_In And 主页id = 主页id_In And 性质 = 1 And 开始时间 > 入科时间_In)) A, 病人自动计算 B 
    Where b.病人id = 病人id_In And b.主页id = 主页id_In And a.开始时间 = b.终止时间 And a.开始原因 = b.终止原因 And B.性质 = 1 
    Union 
    Select * From 病人自动计算 Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And 开始时间 <= 入科时间_In And 性质 = 1; 
 
  Cursor c_Futureinfo Is
    Select *
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 附加床位 = 0 And 开始时间 > 入科时间_In;
  Cursor c_FutureAutoinfo Is
    Select *
    From 病人自动计算
    Where 病人id = 病人id_In And 主页id = 主页id_In And 附加床位 = 0 And 开始时间 > 入科时间_In And 性质 = 2;
    
  r_Futureinfo   c_Futureinfo %Rowtype;
  r_FutureAutoinfo   c_FutureAutoinfo %Rowtype;
  b_Isdel        Boolean;
  b_IsAutodel        Boolean;
  r_Oldinfo      c_Oldinfo%Rowtype;
  r_OldAutoinfo      c_OldAutoinfo%Rowtype;
  r_OldAutoHLinfo      c_OldAutoHLinfo%Rowtype;
  v_变动终止原因 病人变动记录.终止原因%Type;
  v_变动终止时间 病人变动记录.终止时间%Type;
  v_变动终止人员 病人变动记录.终止人员%Type;
  v_Auto变动终止原因 病人变动记录.终止原因%Type;
  v_Auto变动终止时间 病人变动记录.终止时间%Type;
  v_Auto变动终止人员 病人变动记录.终止人员%Type;
  v_AutoHL变动终止原因 病人变动记录.终止原因%Type;
  v_AutoHL变动终止时间 病人变动记录.终止时间%Type;
  v_AutoHL变动终止人员 病人变动记录.终止人员%Type;
  
  v_床号         Varchar2(255);
  v_当前床号     床位状况记录.床号%Type;
  v_等级id       床位状况记录.等级id%Type;
  v_病区id       病案主页.当前病区id%Type;
  n_原科室id     病案主页.出院科室id%Type;
  n_原病区id     病案主页.当前病区id%Type;
  v_再入院       病案主页.再入院%Type;
  v_终止人员     病人变动记录.终止人员%Type;
  v_母婴转科标志 病案主页.母婴转科标志%Type;
  v_Count        Number;
  Err_Custom Exception;
  v_Error Varchar2(255);
Begin
  Select Zl_住院日报_Count(科室id_In, 入科时间_In) Into v_Count From Dual;
  If v_Count > 0 Then
    v_Error := '已产生业务时间内的住院日报,不能办理该业务!';
    Raise Err_Custom;
  End If;
  --都要更新病人信息
  Update 病人信息
  Set 当前病区id = 病区id_In, 当前科室id = 科室id_In, 当前床号 = Decode(床号_In, Null, Null, 主床位_In), 入院时间 = 入院时间_In
  Where 病人id = 病人id_In;
  --更新在院病人
  Begin
    Update 在院病人 Set 病区id = Nvl(病区id_In, 0), 科室id = 科室id_In Where 病人id = 病人id_In;
    If Sql%Rowcount = 0 Then
      Insert Into 在院病人 (病人id, 科室id, 病区id,主页ID) Values (病人id_In, 科室id_In, Nvl(病区id_In, 0),NVL(主页ID_In,0));
    End If;
  Exception
    When Others Then
      Null;
  End;

  If 入院_In = 1 Then
    --入院入科
    Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In And 状态 = 1;
  
    If v_Count = 0 Then
      v_Error := '病人当前不处于入院状态,可能已经撤入院，操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的，请刷新病人状态后再试！';
      Raise Err_Custom;
    End If;
  
    Select 入院病区id, 再入院 Into v_病区id, v_再入院 From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
  
    If v_病区id <> 病区id_In Then
      v_Error := '当前入住病区与病人登记病区不一致,病人状态已经更改,操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的，请刷新病人状态后再试！';
      Raise Err_Custom;
    End If;
  
    --病案主页
    --同时更改了入院登记时的科室,病区,病况
    Update 病案主页
    Set 入院科室id = 科室id_In, 入院病区id = 病区id_In, 入院病况 = 当前病况_In, 状态 = 0, 入院病床 = Decode(床号_In, Null, Null, 主床位_In),
        出院病床 = Decode(床号_In, Null, Null, 主床位_In), 当前病区id = 病区id_In, 出院科室id = 科室id_In,
        医疗小组id = Decode(医疗小组id_In, 0, Null, 医疗小组id_In), 护理等级id = Decode(护理等级id_In, 0, Null, 护理等级id_In), 当前病况 = 当前病况_In,
        责任护士 = 责任护士_In, 门诊医师 = 门诊医师_In, 住院医师 = 住院医师_In, 是否陪伴 = 是否陪伴_In, 入院日期 = 入院时间_In, 入科时间 = 入科时间_In
    Where 病人id = 病人id_In And 主页id = 主页id_In;
  
    Update 病案主页从表
    Set 信息值 = 主治医师_In
    Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主治医师';
    If Sql%Rowcount = 0 Then
      Insert Into 病案主页从表 (病人id, 主页id, 信息名, 信息值) Values (病人id_In, 主页id_In, '主治医师', 主治医师_In);
    End If;
    Update 病案主页从表
    Set 信息值 = 主任医师_In
    Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主任医师';
    If Sql%Rowcount = 0 Then
      Insert Into 病案主页从表 (病人id, 主页id, 信息名, 信息值) Values (病人id_In, 主页id_In, '主任医师', 主任医师_In);
    End If;
  
    --记录上一步的终止操作人员
    Update 病人变动记录
    Set 终止时间 = 入科时间_In, 终止原因 = 2, 终止人员 = 操作员姓名_In,
          上次计算时间 = Decode(Sign(Nvl(上次计算时间, 入科时间_In) - 入科时间_In), 1, Null, 上次计算时间)
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 Is Not Null And 终止时间 Is Null;
    
    Update 病人自动计算
    Set 终止时间 = 入科时间_In, 终止原因 = 2, 终止人员 = 操作员姓名_In,
          上次计算时间 = Decode(Sign(Nvl(上次计算时间, 入科时间_In) - 入科时间_In), 1, Null, 上次计算时间)
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 Is Not Null And 终止时间 Is Null;
    
    Insert Into 病人自动计算
      (ID, 病人id, 主页id, 开始时间, 开始原因, 性质, 病区id, 科室id, 护理等级id, 操作员编号,
       操作员姓名)
    Values
      (病人自动计算_Id.Nextval, 病人id_In, 主页id_In, 入科时间_In, 2, 1, 病区id_In, 科室id_In,
       Decode(护理等级id_In, 0, Null, 护理等级id_In), 操作员编号_In, 操作员姓名_In);
          
    If 床号_In Is Null Then
      --仅家庭病床
      Insert Into 病人变动记录
        (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号,
         操作员姓名)
      Values
        (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, 入科时间_In, 2, 0, 病区id_In, 科室id_In, Decode(医疗小组id_In, 0, Null, 医疗小组id_In),
         Decode(护理等级id_In, 0, Null, 护理等级id_In), Null, Null, 责任护士_In, 住院医师_In, 主治医师_In, 主任医师_In, 当前病况_In, 操作员编号_In,
         操作员姓名_In);
      Insert Into 病人自动计算
        (ID, 病人id, 主页id, 开始时间, 开始原因, 性质, 附加床位, 病区id, 科室id, 床位等级id, 床号, 操作员编号,
         操作员姓名)
      Values
        (病人自动计算_Id.Nextval, 病人id_In, 主页id_In, 入科时间_In, 2, 2, 0, 病区id_In, 科室id_In,
         Null, Null, 操作员编号_In,操作员姓名_In);
      Insert Into 病人自动计算
        (ID, 病人id, 主页id, 开始时间, 开始原因, 性质, 附加床位, 病区id, 科室id, 床位等级id, 床号, 操作员编号,
         操作员姓名)
      Values
        (病人自动计算_Id.Nextval, 病人id_In, 主页id_In, 入科时间_In, 2, 3, 0, 病区id_In, 科室id_In,
         Null, Null, 操作员编号_In,操作员姓名_In);
    Else
      --多张床位
      v_床号 := 床号_In || ',';
      
      While v_床号 Is Not Null Loop
        v_当前床号 := Substr(v_床号, 1, Instr(v_床号, ',') - 1);
        Select 等级id Into v_等级id From 床位状况记录 Where 病区id = 病区id_In And 床号 = v_当前床号;
      
        Insert Into 病人变动记录
          (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号,
           操作员姓名)
        Values
          (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, 入科时间_In, 2, Decode(主床位_In, v_当前床号, 0, 1), 病区id_In, 科室id_In,
           Decode(医疗小组id_In, 0, Null, 医疗小组id_In), Decode(护理等级id_In, 0, Null, 护理等级id_In), v_等级id, v_当前床号, 责任护士_In,
           住院医师_In, 主治医师_In, 主任医师_In, 当前病况_In, 操作员编号_In, 操作员姓名_In);
        Insert Into 病人自动计算
          (ID, 病人id, 主页id, 开始时间, 开始原因, 性质, 附加床位, 病区id, 科室id, 床位等级id, 床号, 操作员编号,
           操作员姓名)
        Values
          (病人自动计算_Id.Nextval, 病人id_In, 主页id_In, 入科时间_In, 2, 2, Decode(主床位_In, v_当前床号, 0, 1), 病区id_In, 科室id_In,
           v_等级id, v_当前床号, 操作员编号_In, 操作员姓名_In);
        Insert Into 病人自动计算
          (ID, 病人id, 主页id, 开始时间, 开始原因, 性质, 附加床位, 病区id, 科室id, 床位等级id, 床号, 操作员编号,
           操作员姓名)
        Values
          (病人自动计算_Id.Nextval, 病人id_In, 主页id_In, 入科时间_In, 2, 3, Decode(主床位_In, v_当前床号, 0, 1), 病区id_In, 科室id_In,
           v_等级id, v_当前床号, 操作员编号_In, 操作员姓名_In);
              
        Select Count(*)
        Into v_Count
        From 床位状况记录
        Where 病区id = 病区id_In And 床号 = v_当前床号 And 状态 = '空床';
      
        If v_Count = 0 Then
          v_Error := '操作失败,床位 ' || v_当前床号 || ' 不是空床！';
          Raise Err_Custom;
        End If;
      
        Update 床位状况记录
        Set 状态 = '占用', 病人id = 病人id_In, 科室id = Decode(共用, 1, 科室id_In, 科室id)
        Where 病区id = 病区id_In And 床号 = v_当前床号;
      
        v_床号 := Substr(v_床号, Instr(v_床号, ',') + 1);
      End Loop;
    End If;
    --产生病历书写时机
    If v_再入院 = 0 Then
      Zl_电子病历时机_Insert(病人id_In, 主页id_In, 2, '入院', 科室id_In, 住院医师_In, 入科时间_In, 入科时间_In);
    Else
      Zl_电子病历时机_Insert(病人id_In, 主页id_In, 2, '再次入院', 科室id_In, 住院医师_In, 入科时间_In, 入科时间_In);
    End If;

    --添加首份体温单
    Zl_病人体温单_NewFirst(病人id_In,主页id_In,病区id_In);

    -- 修改入院时间
    If 入院时间_In Is Not Null Then
      Update 病人变动记录
      Set 开始时间 = 入院时间_In
      Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 1 And 开始时间 <> 入院时间_In;
      Update 病人自动计算
      Set 开始时间 = 入院时间_In
      Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 1 And 开始时间 <> 入院时间_In;
    End If;
  Else
    --转科入科
    Open c_Oldinfo; --必须先打开
    Fetch c_Oldinfo
      Into r_Oldinfo;
    Open c_OldAutoinfo; --必须先打开
    Fetch c_OldAutoinfo
      Into r_OldAutoinfo;
    Open c_OldAutoHLinfo; --必须先打开
    Fetch c_OldAutoHLinfo
      Into r_OldAutoHLinfo;
    Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In And 状态 = 2;
  
    If v_Count = 0 Then
      v_Error := '病人当前不处于转科状态,可能已经撤转科，操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的，请刷新病人状态后再试！';
      Raise Err_Custom;
    End If;
  
    Select 病区id, 操作员姓名
    Into v_病区id, v_终止人员
    From 病人变动记录 --病区与科室独立时,临时记录里没有填,为Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 Is Null And 终止时间 Is Null;
  
    If v_病区id <> 病区id_In Then
      --病区与科室独立时,由于是Null判断,所以不会提示
      v_Error := '当前入住病区与病人登记病区不一致,病人状态已经更改,操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的，请刷新病人状态后再试！';
      Raise Err_Custom;
    End If;
    Select Count(1) Into v_Count From 病人新生儿记录 Where 病人id = 病人id_In And 主页id = 主页id_In;
    If v_Count > 0 Then
      --有婴儿才处理
      v_母婴转科标志 := 母婴转科标志_In;
      --取出婴儿科室病区ID
      Select 婴儿科室id, 婴儿病区id
      Into n_原科室id, n_原病区id
      From 病案主页
      Where 病人id = 病人id_In And 主页id = 主页id_In;
    
      If Nvl(n_原科室id, 0) <> 0 Then
        --母婴转科标志_In=0表示只转母亲，婴儿科室ID不为Null表示已经分离了，已经分离了默认只转母亲
        v_母婴转科标志 := '0';
        --如果相等，则表示母亲转回婴儿科室,清空婴儿科室ID
        If n_原科室id = 科室id_In Then
          Update 病案主页 Set 婴儿科室id = Null, 婴儿病区id = Null Where 病人id = 病人id_In And 主页id = 主页id_In;
        End If;
      Else
        --为null表示母婴未分离
        Select 出院科室id, 当前病区id
        Into n_原科室id, n_原病区id
        From 病案主页
        Where 病人id = 病人id_In And 主页id = 主页id_In;
        If Nvl(n_原科室id, 0) <> 0 Then
          --只转母亲
          If v_母婴转科标志 = 0 Then
            Update 病案主页
            Set 婴儿科室id = n_原科室id, 婴儿病区id = n_原病区id
            Where 病人id = 病人id_In And 主页id = 主页id_In;
          Else
            Update 病案主页 Set 婴儿科室id = Null, 婴儿病区id = Null Where 病人id = 病人id_In And 主页id = 主页id_In;
          End If;
        End If;
      End If;
      Update 病案主页 Set 母婴转科标志 = 母婴转科标志 || v_母婴转科标志 where 病人id = 病人id_In And 主页id = 主页id_In;
    End If;
    --病案主页
    Update 病案主页
    Set 状态 = 0, 出院病床 = Decode(床号_In, Null, Null, 主床位_In), 当前病区id = 病区id_In, 出院科室id = 科室id_In,
        医疗小组id = Decode(医疗小组id_In, 0, Null, 医疗小组id_In), 护理等级id = Decode(护理等级id_In, 0, Null, 护理等级id_In), 当前病况 = 当前病况_In,
        责任护士 = 责任护士_In, 门诊医师 = 门诊医师_In, 住院医师 = 住院医师_In, 是否陪伴 = 是否陪伴_In
    Where 病人id = 病人id_In And 主页id = 主页id_In;
  
    Update 病案主页从表
    Set 信息值 = 主治医师_In
    Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主治医师';
    If Sql%Rowcount = 0 Then
      Insert Into 病案主页从表 (病人id, 主页id, 信息名, 信息值) Values (病人id_In, 主页id_In, '主治医师', 主治医师_In);
    End If;
    Update 病案主页从表
    Set 信息值 = 主任医师_In
    Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主任医师';
    If Sql%Rowcount = 0 Then
      Insert Into 病案主页从表 (病人id, 主页id, 信息名, 信息值) Values (病人id_In, 主页id_In, '主任医师', 主任医师_In);
    End If;
  
    --退除病人当前床位
    For r_Bedrow In c_Bedinfo Loop
      Update 床位状况记录
      Set 状态 = '空床', 病人id = Null, 科室id = Decode(共用, 1, Null, 科室id)
      Where 病区id = r_Bedrow.病区id And 床号 = r_Bedrow.床号;
    End Loop;
  
    --记录上一步的终止操作人员等
    If r_Oldinfo.终止时间 Is Not Null Then
      v_变动终止时间 := r_Oldinfo.终止时间;
      v_变动终止原因 := r_Oldinfo.终止原因;
      v_变动终止人员 := r_Oldinfo.终止人员;
      --取消上次变动
      Update 病人变动记录
      Set 终止时间 = 入科时间_In, 终止原因 = 3, 终止人员 = v_终止人员, 上次计算时间 = Null
      Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_变动终止时间 And 终止原因 = v_变动终止原因;
      --更新将来的记录如果有停止到将来的则删除上次计算时间
      Update 病人变动记录
      Set 上次计算时间 = Null
      Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入科时间_In;
    Else
      Update 病人变动记录
      Set 终止时间 = 入科时间_In, 终止原因 = 3, 终止人员 = v_终止人员,
          上次计算时间 = Decode(Sign(Nvl(上次计算时间, 入科时间_In) - 入科时间_In), 1, Null, 上次计算时间)
      Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 Is Not Null And 终止时间 Is Null;
    End If;
  
    Delete From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 3 And 开始时间 Is Null And 终止时间 Is Null;
    
    If r_OldAutoinfo.终止时间 Is Not Null Then
      v_Auto变动终止时间 := r_OldAutoinfo.终止时间;
      v_Auto变动终止原因 := r_OldAutoinfo.终止原因;
      v_Auto变动终止人员 := r_OldAutoinfo.终止人员;
      --取消上次变动
      Update 病人自动计算
      Set 终止时间 = 入科时间_In, 终止原因 = 3, 终止人员 = v_终止人员, 上次计算时间 = Null
      Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_Auto变动终止时间 And 终止原因 = v_Auto变动终止原因 and 性质 IN(2,3);
      --更新将来的记录如果有停止到将来的则删除上次计算时间
      Update 病人自动计算
      Set 上次计算时间 = Null
      Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入科时间_In  and 性质 IN(2,3);
    Else
      Update 病人自动计算
      Set 终止时间 = 入科时间_In, 终止原因 = 3, 终止人员 = v_终止人员,
          上次计算时间 = Decode(Sign(Nvl(上次计算时间, 入科时间_In) - 入科时间_In), 1, Null, 上次计算时间)
      Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 Is Not Null And 终止时间 Is Null  and 性质 IN(2,3);
    End If;
    
    If r_OldAutoHLinfo.终止时间 Is Not Null Then
      v_AutoHL变动终止时间 := r_OldAutoHLinfo.终止时间;
      v_AutoHL变动终止原因 := r_OldAutoHLinfo.终止原因;
      v_AutoHL变动终止人员 := r_OldAutoHLinfo.终止人员;
      --取消上次变动
      Update 病人自动计算
      Set 终止时间 = 入科时间_In, 终止原因 = 3, 终止人员 = v_终止人员, 上次计算时间 = Null
      Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_AutoHL变动终止时间 And 终止原因 = v_AutoHL变动终止原因  and 性质 = 1;
      --更新将来的记录如果有停止到将来的则删除上次计算时间
      Update 病人自动计算
      Set 上次计算时间 = Null
      Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入科时间_In  and 性质 = 1;
    Else
      Update 病人自动计算
      Set 终止时间 = 入科时间_In, 终止原因 = 3, 终止人员 = v_终止人员,
          上次计算时间 = Decode(Sign(Nvl(上次计算时间, 入科时间_In) - 入科时间_In), 1, Null, 上次计算时间)
      Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 Is Not Null And 终止时间 Is Null  and 性质 = 1;
    End If;
    --护理等级变动
    Insert Into 病人自动计算
      (ID, 病人id, 主页id, 开始时间, 开始原因, 性质, 病区id, 科室id, 护理等级id, 操作员编号,
       操作员姓名, 终止时间, 终止原因, 终止人员)
    Values
      (病人自动计算_Id.Nextval, 病人id_In, 主页id_In, 入科时间_In, 3, 1, 病区id_In, 科室id_In,
       Decode(护理等级id_In, 0, Null, 护理等级id_In), 操作员编号_In,操作员姓名_In, v_AutoHL变动终止时间, v_AutoHL变动终止原因, v_AutoHL变动终止人员);
      
    --新的床位记录
    If 床号_In Is Null Then
      --仅家庭病床
      Insert Into 病人变动记录
        (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号,
         操作员姓名, 终止时间, 终止原因, 终止人员)
      Values
        (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, 入科时间_In, 3, 0, 病区id_In, 科室id_In, Decode(医疗小组id_In, 0, Null, 医疗小组id_In),
         Decode(护理等级id_In, 0, Null, 护理等级id_In), Null, Null, 责任护士_In, 住院医师_In, 主治医师_In, 主任医师_In, 当前病况_In, 操作员编号_In,
         操作员姓名_In, v_变动终止时间, v_变动终止原因, v_变动终止人员);
      --如果修改了床位，则必须修改停止到将来的变动数
      If c_Oldinfo%Rowcount <> 1 Then
        --删除所有将来的附加床位的变动
        Delete From 病人变动记录
        Where 病人id = 病人id_In And 主页id = 主页id_In And 附加床位 = 1 And 开始时间 > 入科时间_In;
      End If;
      --如果有停到将来的情况，将将来的变动信息同步更新(附加床位和主床位记录不相同的字段。)
      Update 病人变动记录
      Set 床位等级id = Null, 床号 = Null
      Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入科时间_In;
      
      Insert Into 病人自动计算
        (ID, 病人id, 主页id, 开始时间, 开始原因, 性质, 附加床位, 病区id, 科室id, 床位等级id, 床号, 操作员编号,
         操作员姓名, 终止时间, 终止原因, 终止人员)
      Values
        (病人自动计算_Id.Nextval, 病人id_In, 主页id_In, 入科时间_In, 3, 2, 0, 病区id_In, 科室id_In, 
         Null, Null, 操作员编号_In,操作员姓名_In, v_Auto变动终止时间, v_Auto变动终止原因, v_Auto变动终止人员);
      Insert Into 病人自动计算
        (ID, 病人id, 主页id, 开始时间, 开始原因, 性质, 附加床位, 病区id, 科室id, 床位等级id, 床号, 操作员编号,
         操作员姓名, 终止时间, 终止原因, 终止人员)
      Values
        (病人自动计算_Id.Nextval, 病人id_In, 主页id_In, 入科时间_In, 3, 3, 0, 病区id_In, 科室id_In, 
         Null, Null, 操作员编号_In,操作员姓名_In, v_Auto变动终止时间, v_Auto变动终止原因, v_Auto变动终止人员);
         
      --如果修改了床位，则必须修改停止到将来的变动数
      If c_OldAutoinfo%Rowcount <> 1 Then
        --删除所有将来的附加床位的变动
        Delete From 病人自动计算
        Where 病人id = 病人id_In And 主页id = 主页id_In And 附加床位 = 1 And 开始时间 > 入科时间_In And 性质 In(2,3);
      End If;
      
      --如果有停到将来的情况，将将来的变动信息同步更新(附加床位和主床位记录不相同的字段。)
      Update 病人自动计算
      Set 床位等级id = Null, 床号 = Null
      Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入科时间_In And 性质 In(2,3);
    Else
      v_床号  := 床号_In || ',';
      v_Count := 0;
      While v_床号 Is Not Null Loop
        v_Count := v_Count + 1;
        v_床号  := Substr(v_床号, Instr(v_床号, ',') + 1);
      End Loop;
      --如果修改了床位，则必须修改停止到将来的变动数
      b_Isdel := False;
      If c_Oldinfo%Rowcount <> v_Count Then
        --删除所有将来的附加床位的变动
        Delete From 病人变动记录
        Where 病人id = 病人id_In And 主页id = 主页id_In And 附加床位 = 1 And 开始时间 > 入科时间_In;
        b_Isdel := True;
      End If;
      b_IsAutodel := False;
      If c_OldAutoinfo%Rowcount <> v_Count Then
        --删除所有将来的附加床位的变动
        Delete From 病人自动计算
        Where 病人id = 病人id_In And 主页id = 主页id_In And 附加床位 = 1 And 开始时间 > 入科时间_In And 性质 In(2,3);
        b_IsAutodel := True;
      End If;
      
      v_床号 := 床号_In || ',';
      While v_床号 Is Not Null Loop
        v_当前床号 := Substr(v_床号, 1, Instr(v_床号, ',') - 1);
        Select 等级id Into v_等级id From 床位状况记录 Where 病区id = 病区id_In And 床号 = v_当前床号;
      
        Insert Into 病人变动记录
          (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号,
           操作员姓名, 终止时间, 终止原因, 终止人员)
        Values
          (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, 入科时间_In, 3, Decode(主床位_In, v_当前床号, 0, 1), 病区id_In, 科室id_In,
           Decode(医疗小组id_In, 0, Null, 医疗小组id_In), Decode(护理等级id_In, 0, Null, 护理等级id_In), v_等级id, v_当前床号, 责任护士_In,
           住院医师_In, 主治医师_In, 主任医师_In, 当前病况_In, 操作员编号_In, 操作员姓名_In, v_变动终止时间, v_变动终止原因, v_变动终止人员);
        
        Insert Into 病人自动计算
          (ID, 病人id, 主页id, 开始时间, 开始原因, 性质, 附加床位, 病区id, 科室id, 床位等级id, 床号, 操作员编号,
           操作员姓名, 终止时间, 终止原因, 终止人员)
        Values
          (病人自动计算_Id.Nextval, 病人id_In, 主页id_In, 入科时间_In, 3, 2, Decode(主床位_In, v_当前床号, 0, 1), 病区id_In, 科室id_In,
           v_等级id, v_当前床号, 操作员编号_In, 操作员姓名_In, v_Auto变动终止时间, v_Auto变动终止原因, v_Auto变动终止人员);
        Insert Into 病人自动计算
          (ID, 病人id, 主页id, 开始时间, 开始原因, 性质, 附加床位, 病区id, 科室id, 床位等级id, 床号, 操作员编号,
           操作员姓名, 终止时间, 终止原因, 终止人员)
        Values
          (病人自动计算_Id.Nextval, 病人id_In, 主页id_In, 入科时间_In, 3, 3, Decode(主床位_In, v_当前床号, 0, 1), 病区id_In, 科室id_In,
           v_等级id, v_当前床号, 操作员编号_In, 操作员姓名_In, v_Auto变动终止时间, v_Auto变动终止原因, v_Auto变动终止人员);
        
        Select Count(*)
        Into v_Count
        From 床位状况记录
        Where 病区id = 病区id_In And 床号 = v_当前床号 And 状态 = '空床';
      
        If v_Count = 0 Then
          v_Error := '操作失败,床位 ' || v_当前床号 || ' 不是空床！';
          Raise Err_Custom;
        End If;
      
        Update 床位状况记录
        Set 状态 = '占用', 病人id = 病人id_In, 科室id = Decode(共用, 1, 科室id_In, 科室id)
        Where 病区id = 病区id_In And 床号 = v_当前床号;
      
        If b_Isdel = True Then
          --如果有停到将来的情况且有床位数变动,将将来的变动信息同步更新(附加床位和主床位记录不相同的字段。)和插入附加床位数据。
          If 主床位_In = v_当前床号 Then
            --如果是主床位则修改将来的主记录信息，如果不是主床位，就新插入数据
            Update 病人变动记录
            Set 床位等级id = v_等级id, 床号 = v_当前床号
            Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入科时间_In And 附加床位 = 0;
          Else
            Open c_Futureinfo; --必须先打开
            Fetch c_Futureinfo
              Into r_Futureinfo;
            --循环停到将来的数据，进行附加床位插入
            While c_Futureinfo%Found Loop
              Insert Into 病人变动记录
                (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 床位等级id, 床号, 操作员编号, 操作员姓名, 终止时间, 终止原因, 终止人员)
              Values
                (病人变动记录_Id.Nextval, r_Futureinfo.病人id, r_Futureinfo.主页id, r_Futureinfo.开始时间, r_Futureinfo.开始原因, 1,
                 v_等级id, v_当前床号, r_Futureinfo.操作员编号, r_Futureinfo.操作员姓名, r_Futureinfo.终止时间, r_Futureinfo.终止原因,
                 r_Futureinfo.终止人员);
              Fetch c_Futureinfo
                Into r_Futureinfo;
            End Loop;
            Close c_Futureinfo;
          End If;
        End If;
        --病人自动计算所需数据
        If b_IsAutodel = True Then
          --如果有停到将来的情况且有床位数变动,将将来的变动信息同步更新(附加床位和主床位记录不相同的字段。)和插入附加床位数据。
          If 主床位_In = v_当前床号 Then
            --如果是主床位则修改将来的主记录信息，如果不是主床位，就新插入数据
            Update 病人自动计算
            Set 床位等级id = v_等级id, 床号 = v_当前床号
            Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入科时间_In And 附加床位 = 0 And 性质 In(2,3);
          Else
            Open c_FutureAutoinfo; --必须先打开
            Fetch c_FutureAutoinfo
              Into r_FutureAutoinfo;
            --循环停到将来的数据，进行附加床位插入
            While c_FutureAutoinfo%Found Loop
              Insert Into 病人自动计算
                (ID, 病人id, 主页id, 开始时间, 开始原因, 性质, 附加床位, 床位等级id, 床号, 操作员编号, 操作员姓名, 终止时间, 终止原因, 终止人员)
              Values
                (病人自动计算_Id.Nextval, r_FutureAutoinfo.病人id, r_FutureAutoinfo.主页id, r_FutureAutoinfo.开始时间, r_FutureAutoinfo.开始原因, 2, 1,
                 v_等级id, v_当前床号, r_FutureAutoinfo.操作员编号, r_FutureAutoinfo.操作员姓名, r_FutureAutoinfo.终止时间, r_FutureAutoinfo.终止原因,
                 r_FutureAutoinfo.终止人员);
              Insert Into 病人自动计算
                (ID, 病人id, 主页id, 开始时间, 开始原因, 性质, 附加床位, 床位等级id, 床号, 操作员编号, 操作员姓名, 终止时间, 终止原因, 终止人员)
              Values
                (病人自动计算_Id.Nextval, r_FutureAutoinfo.病人id, r_FutureAutoinfo.主页id, r_FutureAutoinfo.开始时间, r_FutureAutoinfo.开始原因, 3, 1,
                 v_等级id, v_当前床号, r_FutureAutoinfo.操作员编号, r_FutureAutoinfo.操作员姓名, r_FutureAutoinfo.终止时间, r_FutureAutoinfo.终止原因,
                 r_FutureAutoinfo.终止人员);
              Fetch c_FutureAutoinfo
                Into r_FutureAutoinfo;
            End Loop;
            Close c_FutureAutoinfo;
          End If;
        End If;
        
        v_床号 := Substr(v_床号, Instr(v_床号, ',') + 1);
      End Loop;
    End If;
    --如果有停到将来的情况，将将来的变动信息同步更新（附加床位的记录和主记录相同的字段）
    Update 病人变动记录
    Set 病区id = 病区id_In, 科室id = 科室id_In, 医疗小组id = Decode(医疗小组id_In, 0, Null, 医疗小组id_In),
        护理等级id = Decode(护理等级id_In, 0, Null, 护理等级id_In), 责任护士 = 责任护士_In, 经治医师 = 住院医师_In, 主治医师 = 主治医师_In, 主任医师 = 主任医师_In,
        病情 = 当前病况_In
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入科时间_In;
    
    Update 病人自动计算
    Set 病区id = 病区id_In, 科室id = 科室id_In,
        护理等级id = Decode(护理等级id_In, 0, Null, 护理等级id_In)
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入科时间_In;
    Close c_Oldinfo;
    Close c_OldAutoinfo;
    Close c_OldAutoHLinfo;
    --产生病历书写时机
    Zl_电子病历时机_Insert(病人id_In, 主页id_In, 2, '转科', 科室id_In, 住院医师_In, 入科时间_In, 入科时间_In);
  End If;

  --并发操作检查
  Select Count(*)
  Into v_Count
  From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(附加床位, 0) = 0 And 开始时间 Is Not Null And 终止时间 Is Null;

  If v_Count > 1 Then
    v_Error := '发现病人存在非法的变动记录,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人变动记录_Indept;
/

--110541:余伟节,2017-06-30,身份号唯一建档检查
--110594:余伟节,2017-06-27,病案主页新增入科时间
Create Or Replace Procedure Zl_入院病案主页_Insert
(
  登记模式_In       Number,
  病人性质_In       病案主页.病人性质%Type,
  病人id_In         病人信息.病人id%Type,
  住院号_In         病人信息.住院号%Type,
  医保号_In         保险帐户.医保号%Type,
  姓名_In           病人信息.姓名%Type,
  性别_In           病人信息.性别%Type,
  年龄_In           病人信息.年龄%Type,
  费别_In           病人信息.费别%Type,
  出生日期_In       病人信息.出生日期%Type,
  国籍_In           病人信息.国籍%Type,
  民族_In           病人信息.民族%Type,
  学历_In           病人信息.学历%Type,
  婚姻状况_In       病人信息.婚姻状况%Type,
  职业_In           病人信息.职业%Type,
  身份_In           病人信息.身份%Type,
  身份证号_In       病人信息.身份证号%Type,
  出生地点_In       病人信息.出生地点%Type,
  家庭地址_In       病人信息.家庭地址%Type,
  家庭地址邮编_In   病人信息.家庭地址邮编%Type,
  家庭电话_In       病人信息.家庭电话%Type,
  户口地址_In       病人信息.户口地址%Type,
  户口地址邮编_In   病人信息.户口地址邮编%Type,
  联系人姓名_In     病人信息.联系人姓名%Type,
  联系人关系_In     病人信息.联系人关系%Type,
  联系人地址_In     病人信息.联系人地址%Type,
  联系人电话_In     病人信息.联系人电话%Type,
  工作单位_In       病人信息.工作单位%Type,
  合同单位id_In     病人信息.合同单位id%Type,
  单位电话_In       病人信息.单位电话%Type,
  单位邮编_In       病人信息.单位邮编%Type,
  单位开户行_In     病人信息.单位开户行%Type,
  单位帐号_In       病人信息.单位帐号%Type,
  担保人_In         病人信息.担保人%Type,
  担保额_In         病人信息.担保额%Type,
  担保性质_In       病人信息.担保性质%Type,
  入院科室id_In     病案主页.入院科室id%Type,
  护理等级id_In     病案主页.护理等级id%Type,
  入院病况_In       病案主页.入院病况%Type,
  入院方式_In       病案主页.入院方式%Type,
  住院目的_In       病案主页.住院目的%Type,
  二级院转入_In     病案主页.二级院转入%Type,
  门诊医师_In       病案主页.门诊医师%Type,
  籍贯_In           病人信息.籍贯%Type,
  区域_In           病案主页.区域%Type,
  入院时间_In       病案主页.入院日期%Type,
  是否陪伴_In       病案主页.是否陪伴%Type,
  床号_In           病案主页.入院病床%Type,
  付款方式_In       病案主页.医疗付款方式%Type,
  疾病id_In         病人诊断记录.疾病id%Type,
  诊断id_In         病人诊断记录.诊断id%Type,
  门诊诊断_In       病人诊断记录.诊断描述%Type,
  中医疾病id_In     病人诊断记录.疾病id%Type,
  中医诊断id_In     病人诊断记录.诊断id%Type,
  中医诊断_In       病人诊断记录.诊断描述%Type,
  险类_In           病案主页.险类%Type,
  操作员编号_In     病案主页.编目员编号%Type,
  操作员姓名_In     病案主页.编目员姓名%Type,
  新病人_In         Number := 1,
  备注_In           病案主页.备注%Type,
  入院病区id_In     病案主页.入院病区id%Type,
  再入院_In         病案主页.再入院%Type,
  入院属性_In       病案主页.入院属性%Type := Null,
  主页id_In         病案主页.主页id%Type := Null,
  住院次数_In       病人信息.住院次数%Type := Null,
  其他证件_In       病人信息.其他证件%Type := Null,
  病人类型_In       病案主页.病人类型%Type := Null,
  联系人身份证号_In 病人信息.联系人身份证号%Type := Null,
  手机号_In         病人信息.手机号%Type := Null
) As
  -----------------------------------------------------------
  --功能：对入院病人新增一张病案主页，同时可能处理入科。
  --参数：
  --      登记模式_IN=0-正常登记,1-预约登记,2-接收预约(新病人_IN=0)
  --      病人性质_IN=对应"病案主页.病人性质"
  --      床号_IN=Null:不同时入科;'家庭病床':分配家庭病床,填为空;其他:分配具体床位。
  --      新病人_IN=如果是已有档案的病人入院,则该参数为0；缺省为新病人
  --      入院病区ID_IN=只有当使用[病区管理病床]模式(参数号99)时,并且入院同时入科分床时,才有值
  --      住院号_In = 登记门诊留观病人时 住院号_In 为病人门诊号
  -----------------------------------------------------------
  v_主页id   病案主页.主页id%Type;
  v_等级id   床位状况记录.等级id%Type;
  n_住院次数 病人信息.住院次数%Type;

  v_费别  病案主页.费别%Type;
  v_Count Number;
  n_Uniqueid  Number;
  v_Date  Date;
  d_Indeptime Date;
  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --判断病人是否锁定
  Select Count(病人id) Into v_Count From 病人信息 Where 病人id = 病人id_In;
  If v_Count <> 0 Then
    Zl_病人信息_锁定检查(病人id_In);
  End If;

  Select Sysdate Into v_Date From Dual;
  Zl_病区标记记录_Clear(病人id_In);

  --身份证号不等于空,根据系统参数判读是否唯一建档病人
  If 身份证号_In Is Not Null Then
    n_Uniqueid := Nvl(zl_GetSysParameter(279), 0);
    If n_Uniqueid = 1 Then
      Select Count(1) Into v_Count From 病人信息 Where 身份证号 = 身份证号_In And 病人id <> Nvl(病人id_In, 0);
      If v_Count <> 0 Then
        v_Error := '已经存在身份证号为' || 身份证号_In || '的病人,不能再录入相同的身份证号!';
        Raise Err_Custom;
      End If;
    End If;
  End If;

  --病人基本信息
  If 病人性质_In = 1 Then
    If 新病人_In = 1 Then
      Insert Into 病人信息
        (病人id, 门诊号, 住院号, 姓名, 性别, 年龄, 费别, 医疗付款方式, 出生日期, 国籍, 民族, 籍贯, 区域, 学历, 婚姻状况, 职业, 身份, 身份证号, 出生地点, 家庭地址, 家庭地址邮编, 家庭电话,
         户口地址, 户口地址邮编, 联系人姓名, 联系人关系, 联系人地址, 联系人电话, 工作单位, 合同单位id, 单位电话, 单位邮编, 单位开户行, 单位帐号, 担保人, 担保额, 担保性质, 险类, 登记时间, 其他证件,
         联系人身份证号, 手机号)
      Values
        (病人id_In, 住院号_In, Null, 姓名_In, 性别_In, 年龄_In, 费别_In, 付款方式_In, 出生日期_In, 国籍_In, 民族_In, 籍贯_In, 区域_In, 学历_In,
         婚姻状况_In, 职业_In, 身份_In, 身份证号_In, 出生地点_In, 家庭地址_In, 家庭地址邮编_In, 家庭电话_In, 户口地址_In, 户口地址邮编_In, 联系人姓名_In, 联系人关系_In,
         联系人地址_In, 联系人电话_In, 工作单位_In, Decode(合同单位id_In, 0, Null, 合同单位id_In), 单位电话_In, 单位邮编_In, 单位开户行_In, 单位帐号_In, 担保人_In,
         Decode(担保额_In, 0, Null, 担保额_In), 担保性质_In, 险类_In, v_Date, 其他证件_In, 联系人身份证号_In, 手机号_In);
    Else
      --老病人的门诊费别不变,除非是门诊留观病人
      Update 病人信息
      Set 门诊号 = 住院号_In, 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In, 费别 = Decode(病人性质_In, 1, 费别_In, 费别), 医疗付款方式 = 付款方式_In,
          出生日期 = 出生日期_In, 国籍 = 国籍_In, 民族 = 民族_In, 籍贯 = 籍贯_In, 区域 = 区域_In, 学历 = 学历_In, 婚姻状况 = 婚姻状况_In, 职业 = 职业_In,
          身份 = 身份_In, 身份证号 = 身份证号_In, 出生地点 = 出生地点_In, 家庭地址 = 家庭地址_In, 家庭地址邮编 = 家庭地址邮编_In, 家庭电话 = 家庭电话_In, 户口地址 = 户口地址_In,
          户口地址邮编 = 户口地址邮编_In, 联系人姓名 = 联系人姓名_In, 联系人关系 = 联系人关系_In, 联系人地址 = 联系人地址_In, 联系人电话 = 联系人电话_In, 工作单位 = 工作单位_In,
          合同单位id = Decode(合同单位id_In, 0, Null, 合同单位id_In), 单位电话 = 单位电话_In, 单位邮编 = 单位邮编_In, 单位开户行 = 单位开户行_In,
          单位帐号 = 单位帐号_In, 担保人 = 担保人_In, 担保额 = Decode(担保额_In, 0, Null, 担保额_In), 担保性质 = 担保性质_In, 险类 = 险类_In,
          其他证件 = 其他证件_In, 联系人身份证号 = 联系人身份证号_In, 手机号 = NVL(手机号_In,手机号)
      Where 病人id = 病人id_In;
    End If;
  Else
    If 新病人_In = 1 Then
      Insert Into 病人信息
        (病人id, 住院号, 姓名, 性别, 年龄, 费别, 医疗付款方式, 出生日期, 国籍, 民族, 籍贯, 区域, 学历, 婚姻状况, 职业, 身份, 身份证号, 出生地点, 家庭地址, 家庭地址邮编, 家庭电话,
         户口地址, 户口地址邮编, 联系人姓名, 联系人关系, 联系人地址, 联系人电话, 工作单位, 合同单位id, 单位电话, 单位邮编, 单位开户行, 单位帐号, 担保人, 担保额, 担保性质, 险类, 登记时间, 其他证件,
         联系人身份证号, 手机号)
      Values
        (病人id_In, Decode(病人性质_In, 2, Null, 住院号_In), 姓名_In, 性别_In, 年龄_In, 费别_In, 付款方式_In, 出生日期_In, 国籍_In, 民族_In, 籍贯_In,
         区域_In, 学历_In, 婚姻状况_In, 职业_In, 身份_In, 身份证号_In, 出生地点_In, 家庭地址_In, 家庭地址邮编_In, 家庭电话_In, 户口地址_In, 户口地址邮编_In,
         联系人姓名_In, 联系人关系_In, 联系人地址_In, 联系人电话_In, 工作单位_In, Decode(合同单位id_In, 0, Null, 合同单位id_In), 单位电话_In, 单位邮编_In,
         单位开户行_In, 单位帐号_In, 担保人_In, Decode(担保额_In, 0, Null, 担保额_In), 担保性质_In, 险类_In, v_Date, 其他证件_In, 联系人身份证号_In, 手机号_In);
    Else
      --老病人的门诊费别不变,除非是门诊留观病人
      Update 病人信息
      Set 住院号 = Decode(病人性质_In, 2, 住院号, Decode(住院号_In, Null, 住院号, 住院号_In)), 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In,
          费别 = Decode(病人性质_In, 1, 费别_In, 费别), 医疗付款方式 = 付款方式_In, 出生日期 = 出生日期_In, 国籍 = 国籍_In, 民族 = 民族_In, 籍贯 = 籍贯_In,
          区域 = 区域_In, 学历 = 学历_In, 婚姻状况 = 婚姻状况_In, 职业 = 职业_In, 身份 = 身份_In, 身份证号 = 身份证号_In, 出生地点 = 出生地点_In, 家庭地址 = 家庭地址_In,
          家庭地址邮编 = 家庭地址邮编_In, 家庭电话 = 家庭电话_In, 户口地址 = 户口地址_In, 户口地址邮编 = 户口地址邮编_In, 联系人姓名 = 联系人姓名_In, 联系人关系 = 联系人关系_In,
          联系人地址 = 联系人地址_In, 联系人电话 = 联系人电话_In, 工作单位 = 工作单位_In, 合同单位id = Decode(合同单位id_In, 0, Null, 合同单位id_In),
          单位电话 = 单位电话_In, 单位邮编 = 单位邮编_In, 单位开户行 = 单位开户行_In, 单位帐号 = 单位帐号_In, 担保人 = 担保人_In,
          担保额 = Decode(担保额_In, 0, Null, 担保额_In), 担保性质 = 担保性质_In, 险类 = 险类_In, 其他证件 = 其他证件_In, 联系人身份证号 = 联系人身份证号_In,
          手机号 = NVL(手机号_In,手机号)
      Where 病人id = 病人id_In;
    End If;
  End If;

  --病案信息
  Begin
    If 登记模式_In = 1 Then
      v_主页id := 0; --预约登记记录的主页ID=0
    Else
      If 主页id_In Is Null Then
        Select Nvl(Max(主页id), 0) + 1 Into v_主页id From 病案主页 Where 病人id = 病人id_In And Nvl(主页id, 0) <> 0;
      Else
        v_主页id := 主页id_In;
      End If;
    End If;
  Exception
    When Others Then
      Null;
  End;

  If 登记模式_In <> 1 Then
    Update 病人信息
    Set 主页id = v_主页id, 当前病区id = 入院病区id_In, 当前科室id = 入院科室id_In, 当前床号 = Decode(床号_In, '家庭病床', Null, 床号_In), 入院时间 = 入院时间_In,
        出院时间 = Null, 在院 = 1
    Where 病人id = 病人id_In;
  End If;

  --更新住院次数
  If 登记模式_In <> 1 And 病人性质_In = 0 Then
    If Nvl(住院次数_In, 0) = 0 Then
      Select Nvl(住院次数, 0) + 1 Into n_住院次数 From 病人信息 Where 病人id = 病人id_In;
    Else
      n_住院次数 := 住院次数_In;
    End If;
    Update 病人信息 Set 住院次数 = n_住院次数 Where 病人id = 病人id_In;
  End If;

  --取入科时间
  If 床号_In Is Null Then
    d_Indeptime := Null;
  Else
    d_Indeptime := 入院时间_In;
  End If;

  --状态：0-正常在院,1-等待入科,2-等待转科
  If 登记模式_In = 2 Then
    --处理病案主页从表
    Delete From 病案主页从表 Where 病人id = 病人id_In And Nvl(主页id, 0) = 0;
    --接收预约
    Update 病案主页
    Set 主页id = v_主页id, 病人性质 = 病人性质_In, 住院号 = Decode(病人性质_In, 1, Null, 2, Null, 住院号_In),
        留观号 = Decode(病人性质_In, 2, 住院号_In, Null),
        --主页ID变更,病人性质可能变更
        费别 = 费别_In, 入院病区id = 入院病区id_In, 入院科室id = 入院科室id_In, 入院日期 = 入院时间_In,入科时间 = d_Indeptime, 入院病况 = 入院病况_In, 入院方式 = 入院方式_In,
        入院属性 = 入院属性_In, 二级院转入 = 二级院转入_In, 住院目的 = 住院目的_In, 入院病床 = Decode(床号_In, '家庭病床', Null, 床号_In), 是否陪伴 = 是否陪伴_In,
        当前病况 = 入院病况_In, 当前病区id = 入院病区id_In, 护理等级id = Decode(护理等级id_In, 0, Null, 护理等级id_In), 出院科室id = 入院科室id_In,
        出院病床 = Decode(床号_In, '家庭病床', Null, 床号_In), 门诊医师 = 门诊医师_In, 编目员编号 = 操作员编号_In, 编目员姓名 = 操作员姓名_In, 姓名 = 姓名_In,
        性别 = 性别_In, 年龄 = 年龄_In, 婚姻状况 = 婚姻状况_In, 职业 = 职业_In, 国籍 = 国籍_In, 学历 = 学历_In, 单位电话 = 单位电话_In, 单位邮编 = 单位邮编_In,
        单位地址 = 工作单位_In, 区域 = 区域_In, 家庭地址 = 家庭地址_In, 家庭电话 = 家庭电话_In, 家庭地址邮编 = 家庭地址邮编_In, 户口地址 = 户口地址_In,
        户口地址邮编 = 户口地址邮编_In, 联系人姓名 = 联系人姓名_In, 联系人关系 = 联系人关系_In, 联系人地址 = 联系人地址_In, 联系人身份证号 = 联系人身份证号_In, 联系人电话 = 联系人电话_In,
        医疗付款方式 = 付款方式_In, 备注 = 备注_In, 险类 = 险类_In, 状态 = Decode(床号_In, Null, 1, 0), 登记人 = 操作员姓名_In, 登记时间 = v_Date,
        再入院 = 再入院_In, 病人类型 = 病人类型_In
    Where 病人id = 病人id_In And Nvl(主页id, 0) = 0;
    Update 病人预交记录
    Set 主页id = 主页id_In
    Where 病人id = 病人id_In And 主页id Is Null And 科室id = 入院科室id_In And 预交类别 = 2 And 冲预交 Is Null And
          Trunc(收款时间) = Trunc(Sysdate);
  Else
    --入院登记或预约登记
    Insert Into 病案主页
      (病人性质, 病人id, 主页id, 住院号, 留观号, 费别, 入院病区id, 入院科室id, 入院日期, 入科时间, 入院病况, 入院方式, 入院属性, 二级院转入, 住院目的, 入院病床, 是否陪伴, 当前病况, 当前病区id,
       护理等级id, 出院科室id, 出院病床, 门诊医师, 编目员编号, 编目员姓名, 状态, 姓名, 性别, 年龄, 婚姻状况, 职业, 国籍, 学历, 单位电话, 单位邮编, 单位地址, 区域, 家庭地址, 家庭电话,
       家庭地址邮编, 户口地址, 户口地址邮编, 联系人姓名, 联系人关系, 联系人地址, 联系人电话, 联系人身份证号, 医疗付款方式, 险类, 备注, 登记人, 登记时间, 再入院, 病人类型)
    Values
      (病人性质_In, 病人id_In, v_主页id, Decode(病人性质_In, 1, Null, 2, Null, 住院号_In), Decode(病人性质_In, 2, 住院号_In, Null), 费别_In,
       入院病区id_In, 入院科室id_In, 入院时间_In, d_Indeptime, 入院病况_In, 入院方式_In, 入院属性_In, 二级院转入_In, 住院目的_In, Decode(床号_In, '家庭病床', Null, 床号_In),
       是否陪伴_In, 入院病况_In, 入院病区id_In, Decode(护理等级id_In, 0, Null, 护理等级id_In), 入院科室id_In, Decode(床号_In, '家庭病床', Null, 床号_In),
       门诊医师_In, 操作员编号_In, 操作员姓名_In, Decode(床号_In, Null, 1, 0), 姓名_In, 性别_In, 年龄_In, 婚姻状况_In, 职业_In, 国籍_In, 学历_In,
       单位电话_In, 单位邮编_In, 工作单位_In, 区域_In, 家庭地址_In, 家庭电话_In, 家庭地址邮编_In, 户口地址_In, 户口地址邮编_In, 联系人姓名_In, 联系人关系_In, 联系人地址_In,
       联系人电话_In, 联系人身份证号_In, 付款方式_In, 险类_In, 备注_In, 操作员姓名_In, v_Date, 再入院_In, 病人类型_In);
  End If;

  Begin
    If 登记模式_In <> 1 Then
      Update 在院病人 Set 病区id = Nvl(入院病区id_In, 0), 科室id = 入院科室id_In Where 病人id = 病人id_In;
      If Sql%RowCount = 0 Then
        Insert Into 在院病人
          (病人id, 科室id, 病区id, 主页id)
        Values
          (病人id_In, 入院科室id_In, Nvl(入院病区id_In, 0), Nvl(v_主页id, 0));
      End If;
    End If;
  Exception
    When Others Then
      Null;
  End;

  Select 费别 Into v_费别 From 病人信息 Where 病人id = 病人id_In;
  If v_费别 Is Null Then
    Update 病人信息
    Set 费别 =
         (Select 费别 From 病案主页 Where 病人id = 病人id_In And 主页id = v_主页id)
    Where 病人id = 病人id_In;
  End If;

  --医保号
  If 登记模式_In <> 1 Then
    Select Zl_住院日报_Count(入院科室id_In, Trunc(入院时间_In)) Into v_Count From Dual;
    If v_Count > 0 Then
      v_Error := '已产生业务时间内的住院日报,不能办理该业务!';
      Raise Err_Custom;
    End If;
  
    If 医保号_In Is Not Null Then
      Insert Into 病案主页从表 (病人id, 主页id, 信息名, 信息值) Values (病人id_In, v_主页id, '医保号', 医保号_In);
    End If;
  
    --病人变动记录
    --同时入科且非家庭病床时有等级
    If 床号_In Is Not Null And 床号_In <> '家庭病床' Then
      Select 等级id Into v_等级id From 床位状况记录 Where 病区id = 入院病区id_In And 床号 = 床号_In;
    End If;
  
    --如果同时入科,则入院和入科填写到一条入院变动
    Insert Into 病人变动记录
      (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 护理等级id, 床位等级id, 床号, 病情, 操作员编号, 操作员姓名)
    Values
      (病人变动记录_Id.Nextval, 病人id_In, v_主页id, 入院时间_In, 1, 0, 入院病区id_In, 入院科室id_In, Decode(护理等级id_In, 0, Null, 护理等级id_In),
       v_等级id, Decode(床号_In, '家庭病床', Null, 床号_In), 入院病况_In, 操作员编号_In, 操作员姓名_In);
    
    Insert Into 病人自动计算
      (ID, 病人id, 主页id, 开始时间, 开始原因, 性质, 病区id, 科室id, 护理等级id, 操作员编号, 操作员姓名)
    Values
      (病人自动计算_Id.Nextval, 病人id_In, v_主页id, 入院时间_In, 1, 1, 入院病区id_In, 入院科室id_In, Decode(护理等级id_In, 0, Null, 护理等级id_In),
       操作员编号_In, 操作员姓名_In);
    Insert Into 病人自动计算
      (ID, 病人id, 主页id, 开始时间, 开始原因, 性质, 附加床位, 病区id, 科室id, 床位等级id, 床号, 操作员编号, 操作员姓名)
    Values
      (病人自动计算_Id.Nextval, 病人id_In, v_主页id, 入院时间_In, 1, 2, 0, 入院病区id_In, 入院科室id_In,
       v_等级id, Decode(床号_In, '家庭病床', Null, 床号_In), 操作员编号_In, 操作员姓名_In);
    Insert Into 病人自动计算
      (ID, 病人id, 主页id, 开始时间, 开始原因, 性质, 附加床位, 病区id, 科室id, 床位等级id, 床号, 操作员编号, 操作员姓名)
    Values
      (病人自动计算_Id.Nextval, 病人id_In, v_主页id, 入院时间_In, 1, 3, 0, 入院病区id_In, 入院科室id_In,
       v_等级id, Decode(床号_In, '家庭病床', Null, 床号_In), 操作员编号_In, 操作员姓名_In);
       
    --同时入科且非家庭病床时床位被占用
    If 床号_In Is Not Null And 床号_In <> '家庭病床' Then
      Select Count(*) Into v_Count From 床位状况记录 Where 病区id = 入院病区id_In And 床号 = 床号_In And 状态 = '空床';
    
      If v_Count = 0 Then
        v_Error := '操作失败,床位 ' || 床号_In || ' 不是空床！';
        Raise Err_Custom;
      End If;
    
      Update 床位状况记录
      Set 状态 = '占用', 病人id = 病人id_In, 科室id = Decode(共用, 1, 入院科室id_In, 科室id)
      Where 病区id = 入院病区id_In And 床号 = 床号_In;
    End If;
  
    --病人诊断记录
    If 门诊诊断_In Is Not Null Or 疾病id_In Is Not Null Then
      Insert Into 病人诊断记录
        (ID, 病人id, 主页id, 记录来源, 诊断类型, 诊断次序, 疾病id, 诊断id, 诊断描述, 记录日期, 记录人)
      Values
        (病人诊断记录_Id.Nextval, 病人id_In, v_主页id, 2, 1, 1, 疾病id_In, 诊断id_In, 门诊诊断_In, Sysdate, 操作员姓名_In);
    End If;
    If 中医诊断_In Is Not Null Or 中医疾病id_In Is Not Null Then
      Insert Into 病人诊断记录
        (ID, 病人id, 主页id, 记录来源, 诊断类型, 诊断次序, 疾病id, 诊断id, 诊断描述, 记录日期, 记录人)
      Values
        (病人诊断记录_Id.Nextval, 病人id_In, v_主页id, 2, 11, 1, 中医疾病id_In, 中医诊断id_In, 中医诊断_In, Sysdate, 操作员姓名_In);
    End If;
    --病人担保记录
    Update 病人担保记录
    Set 到期时间 = Sysdate
    Where 病人id = 病人id_In And 到期时间 Is Not Null And 到期时间 > Sysdate;
  
    --病人费用审批项目
    If 登记模式_In <> 1 Then
      Delete From 病人审批项目 Where 病人id = 病人id_In;
    End If;
  
    If 登记模式_In = 0 And ((门诊诊断_In Is Not Null Or 疾病id_In Is Not Null) Or (中医诊断_In Is Not Null Or 中医疾病id_In Is Not Null)) Then
      --产生病历书写时机
      Zl_电子病历时机_Insert(病人id_In, 主页id_In, 2, '诊断', 入院科室id_In, Null, Sysdate, Sysdate);
    End If;
  
    If 登记模式_In = 0 And 床号_In Is Not Null Then
      If 再入院_In = 0 Then
        Zl_电子病历时机_Insert(病人id_In, 主页id_In, 2, '入院', 入院科室id_In, Null, 入院时间_In, 入院时间_In);
      Else
        Zl_电子病历时机_Insert(病人id_In, 主页id_In, 2, '再次入院', 入院科室id_In, Null, 入院时间_In, 入院时间_In);
      End If;
    End If;
  
    If 床号_In Is Not Null Then
      --添加首份体温单
      Zl_病人体温单_Newfirst(病人id_In, 主页id_In, 入院病区id_In);
    End If;
  
    --并发操作检查
    Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 出院日期 Is Null;
    If v_Count > 1 Then
      v_Error := '发现病人存在非法的病案记录,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
      Raise Err_Custom;
    End If;
  
    Select Count(*)
    Into v_Count
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = v_主页id And Nvl(附加床位, 0) = 0 And 开始时间 Is Not Null And 终止时间 Is Null;
    If v_Count > 1 Then
      v_Error := '发现病人存在非法的变动记录,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
      Raise Err_Custom;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_入院病案主页_Insert;
/

--99878:冉俊明,2017-06-27,住院程序中取药品卫材价格调用了封装过程，记帐同步调整
Create Or Replace Procedure Zl_住院记帐记录_Insert
(
  No_In             住院费用记录.No%Type,
  序号_In           住院费用记录.序号%Type,
  病人id_In         住院费用记录.病人id%Type,
  主页id_In         住院费用记录.主页id%Type,
  标识号_In         住院费用记录.标识号%Type,
  姓名_In           住院费用记录.姓名%Type,
  性别_In           住院费用记录.性别%Type,
  年龄_In           住院费用记录.年龄%Type,
  床号_In           住院费用记录.床号%Type,
  费别_In           住院费用记录.费别%Type,
  病区id_In         住院费用记录.病人病区id%Type,
  科室id_In         住院费用记录.病人科室id%Type,
  加班标志_In       住院费用记录.加班标志%Type,
  婴儿费_In         住院费用记录.婴儿费%Type,
  开单部门id_In     住院费用记录.开单部门id%Type,
  开单人_In         住院费用记录.开单人%Type,
  从属父号_In       住院费用记录.从属父号%Type,
  收费细目id_In     住院费用记录.收费细目id%Type,
  收费类别_In       住院费用记录.收费类别%Type,
  计算单位_In       住院费用记录.计算单位%Type,
  保险项目否_In     住院费用记录.保险项目否%Type,
  保险大类id_In     住院费用记录.保险大类id%Type,
  保险编码_In       住院费用记录.保险编码%Type,
  付数_In           住院费用记录.付数%Type,
  数次_In           住院费用记录.数次%Type,
  附加标志_In       住院费用记录.附加标志%Type,
  执行部门id_In     住院费用记录.执行部门id%Type,
  价格父号_In       住院费用记录.价格父号%Type,
  收入项目id_In     住院费用记录.收入项目id%Type,
  收据费目_In       住院费用记录.收据费目%Type,
  标准单价_In       住院费用记录.标准单价%Type,
  应收金额_In       住院费用记录.应收金额%Type,
  实收金额_In       住院费用记录.实收金额%Type,
  统筹金额_In       住院费用记录.统筹金额%Type,
  发生时间_In       住院费用记录.发生时间%Type,
  登记时间_In       住院费用记录.登记时间%Type,
  药品摘要_In       药品收发记录.摘要%Type,
  划价_In           Number,
  操作员编号_In     住院费用记录.操作员编号%Type,
  操作员姓名_In     住院费用记录.操作员姓名%Type,
  多病人单_In       Number := 0,
  类别id_In         药品单据性质.类别id%Type := Null,
  记帐单id_In       住院费用记录.记帐单id%Type := Null,
  费用摘要_In       住院费用记录.摘要%Type := Null,
  是否急诊_In       住院费用记录.是否急诊%Type := 0,
  医嘱序号_In       住院费用记录.医嘱序号%Type := Null,
  频次_In           药品收发记录.频次%Type := Null,
  单量_In           药品收发记录.单量%Type := Null,
  用法_In           药品收发记录.用法%Type := Null, --用法[|煎法]
  期效_In           药品收发记录.扣率%Type := Null,
  计价特性_In       药品收发记录.扣率%Type := Null,
  简单记帐_In       Number := 0,
  费用类型_In       住院费用记录.费用类型%Type := Null,
  医技补临床费用_In Number := 0,
  领药部门id_In     药品收发记录.对方部门id%Type := Null,
  中药形态_In       住院费用记录.结论%Type := Null,
  医疗小组id_In     住院费用记录.医疗小组id%Type := -1,
  备货材料_In       Number := 0,
  批次_In           药品收发记录.批次%Type := Null
) As
  --功能：新收一张住院记帐单据
  --参数：
  --   药品摘要_IN:存放医嘱中的附加说明或修改保存新单据时用。目前仅用于存放于药品收发记录的摘要中。
  --         原单据(记录状态=2)记录修改产生的新单据号。
  --         新单据(记录状态=1)记录所修改的原单据号。
  --   划价-是否属于住院划价。
  --   医技补临床费用_in:医技站补费时,如果开单科室为临床科室则划价人和记帐人填写为不同,用于销帐申请时区分填写审核科室
  --   备货材料_IN: 医技站的卫生材料备货处理方式:0-正常记帐单;1-备货材料记帐
  --   批次_In:当备货材料_IN=1时有效.传入指定的卫生材料的批次
  v_费用id 住院费用记录.Id%Type;
  v_优先级 未发药品记录.优先级%Type;

  --药房分批、时价药品--
  ------------------------------------------------------------
  --该游标用于分批药品数量分解
  Cursor c_Stock
  (
    n_Outmode Number,
    n_库房id  药品收发记录.库房id%Type
  ) Is
    Select 库房id, 药品id, 批次, 上次批号, 可用数量, 实际数量, 实际金额, 上次供应商id, 批准文号, 上次产地, 上次生产日期, 灭菌效期, 效期, 零售价, 商品条码, 内部条码
    From 药品库存
    Where 药品id = 收费细目id_In And 库房id = n_库房id And 性质 = 1 And (Nvl(批次, 0) = Nvl(批次_In, 0) Or Nvl(批次_In, 0) = 0) And
          (Nvl(批次, 0) = 0 Or 效期 Is Null Or 效期 > Trunc(Sysdate)) And Nvl(可用数量, 0) > 0
    Order By Decode(n_Outmode, 1, 效期, Null), Nvl(批次, 0);
  r_Stock c_Stock%RowType;

  --属性
  n_分批 药品规格.药房分批%Type;
  n_时价 收费项目目录.是否变价%Type;
  v_名称 收费项目目录.名称%Type;
  --临时变量
  n_总数量   Number;
  n_当前数量 Number;
  n_总金额   Number;
  n_当前单价 Number;
  --药品收发记录
  n_批次       药品收发记录.批次%Type;
  n_序号       药品收发记录.序号%Type;
  n_扣率       药品收发记录.扣率%Type;
  n_领药部门id 药品收发记录.对方部门id%Type;
  n_供药单位id 药品收发记录.供药单位id%Type;
  v_商品条码   药品收发记录.商品条码%Type;
  v_内部条码   药品收发记录.内部条码%Type;
  d_效期       药品收发记录.效期%Type;
  d_灭菌效期   药品收发记录.灭菌效期%Type;
  d_灭菌日期   药品收发记录.灭菌日期%Type;
  d_生产日期   药品收发记录.生产日期%Type;
  n_虚拟库房id 药品收发记录.库房id%Type;
  v_产地       药品收发记录.产地%Type;
  v_批号       药品收发记录.批号%Type;
  v_批准文号   药品收发记录.批准文号%Type;
  v_其他出库no 药品收发记录.No%Type;
  n_Aval       药品库存.可用数量%Type;
  v_部门名称   部门表.名称%Type;
  ------------------------------------------------------------
  v_用法       药品收发记录.用法%Type;
  v_煎法       药品收发记录.外观%Type;
  n_单价小数   Number;
  n_医疗小组id 住院费用记录.医疗小组id%Type;
  n_库房id     药品库存.库房id%Type;
  n_修正库房id 药品库存.库房id%Type;
  n_Outmode    Number(1);
  v_Dec        Number;
  v_Count      Number;
  v_Err_Msg    Varchar2(255);
  Err_Item Exception;
  n_出库序号       药品收发记录.序号%Type;
  n_审核标志       病案主页.审核标志%Type;
  n_住院状态       病案主页.状态%Type;
  n_病人审核方式   Number(2);
  n_未入科禁止记账 Number(2);
  n_流通金额小数   Number;
  n_标准单价       药品收发记录.零售价%Type;
Begin
  --根据执行库房取虚拟库房ID
  Begin
    Select 虚拟库房id Into n_虚拟库房id From 虚拟库房对照 Where 科室id = 执行部门id_In And Rownum <= 1;
  Exception
    When Others Then
      n_虚拟库房id := 0;
  End;
  If 批次_In Is Not Null Then
    Select Nvl(Sum(可用数量), 0)
    Into n_Aval
    From 药品库存
    Where 药品id = 收费细目id_In And 批次 = 批次_In And 库房id = 执行部门id_In;
    If n_Aval <= 0 Then
      n_修正库房id := n_虚拟库房id;
    End If;
  End If;

  If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
    If Nvl(n_虚拟库房id, 0) = 0 Then
      Begin
        Select 名称 Into v_Err_Msg From 部门表 Where ID = 执行部门id_In;
      Exception
        When Others Then
          v_Err_Msg := '';
      End;
      v_Err_Msg := '执行部门"' || Nvl(v_Err_Msg, '') || '"未设置虚拟部门,请在卫材参数设置中设置.';
      Raise Err_Item;
    End If;
  End If;
  If Nvl(多病人单_In, 0) = 1 Or Nvl(序号_In, 0) = 1 Then
    --记帐表,全部检查,如果是记帐单只检查第一条,其他不检查
  
    n_病人审核方式   := Nvl(zl_GetSysParameter(185), 0);
    n_未入科禁止记账 := Nvl(zl_GetSysParameter(215), 0);
    If n_病人审核方式 = 1 Or n_未入科禁止记账 = 1 Then
      Begin
        Select 审核标志, 状态
        Into n_审核标志, n_住院状态
        From 病案主页
        Where 病人id = Nvl(病人id_In, 0) And 主页id = Nvl(主页id_In, 0);
      Exception
        When Others Then
          n_审核标志 := 0;
          n_住院状态 := 0;
      End;
      If n_未入科禁止记账 = 1 And n_住院状态 = 1 Then
        v_Err_Msg := '病人未入科,禁止对病人相关费用的操作!';
        Raise Err_Item;
      End If;
    
      If n_病人审核方式 = 1 Then
      
        If Nvl(n_审核标志, 0) = 1 Then
          v_Err_Msg := '该病人目前正在审核费用,不能进行费用相关调整!';
          Raise Err_Item;
        End If;
        If Nvl(n_审核标志, 0) = 2 Then
          v_Err_Msg := '该病人目前已经完成了费用审核,不能进行费用相关调整!';
          Raise Err_Item;
        End If;
      End If;
    End If;
  End If;
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --领药部门确认规则:
  -- 1.传入 :领药部门ID_IN,直接以传入的为准
  -- 2.领药部门ID_IN=NULL的情况, 如果”开单科室=病人科室”，则填为”病人病区”，如果”开单科室<>病人科室”，则填写为”开单科室”
  If Nvl(领药部门id_In, 0) = 0 Then
    If Nvl(科室id_In, 0) = Nvl(开单部门id_In, 0) Then
      --如果”开单科室=病人科室”，则填为”病人病区”(如果没有入科,即病匹为空这种情况,则以病人科室为准,由于一般这种情况较少(护土开单),因此,这种情况应该不会存在)
      n_领药部门id := Nvl(病区id_In, 0);
      If Nvl(n_领药部门id, 0) = 0 Then
        n_领药部门id := 科室id_In;
      End If;
    Else
      --如果”开单科室<>病人科室”，则填写为”开单科室”
      n_领药部门id := 开单部门id_In;
    End If;
  Else
    n_领药部门id := 领药部门id_In;
  End If;
  --需要检查0这种情况,回为有关联
  If Nvl(n_领药部门id, 0) = 0 Then
    n_领药部门id := Null;
  End If;
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --药品用法煎法分解
  If 用法_In Is Not Null Then
    If Instr(用法_In, '|') > 0 Then
      v_用法 := Substr(用法_In, 1, Instr(用法_In, '|') - 1);
      v_煎法 := Substr(用法_In, Instr(用法_In, '|') + 1);
    Else
      v_用法 := 用法_In;
    End If;
  End If;

  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')), Zl_To_Number(Nvl(zl_GetSysParameter(157), '5'))
  Into v_Dec, n_单价小数
  From Dual;

  --取流通业务精度位数
  --类别:1-药品 2-卫材
  --内容：2-零售价 4-金额
  --单位：药品:1-售价 5-金额单位
  If 收费类别_In = '4' Then
    Select 精度 Into n_流通金额小数 From 药品卫材精度 Where 类别 = 2 And 内容 = 4 And 单位 = 5;
  Else
    Select 精度 Into n_流通金额小数 From 药品卫材精度 Where 类别 = 1 And 内容 = 4 And 单位 = 5;
  End If;

  If 收费类别_In In ('4', '5', '6', '7') Then
    --取定价药品/卫材价格
    Select c.现价
    Into n_标准单价
    From 收费价目 C
    Where c.收费细目id = 收费细目id_In And Sysdate Between c.执行日期 And c.终止日期;
  End If;

  --住院费用记录
  Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
  n_医疗小组id := 医疗小组id_In;

  If Nvl(医疗小组id_In, 0) < 0 Then
    n_医疗小组id := Zl_医疗小组_Get(开单部门id_In, 开单人_In, 病人id_In, 主页id_In, 发生时间_In);
  End If;

  Insert Into 住院费用记录
    (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id, 费别, 收费类别, 收费细目id,
     计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用, 开单部门id,
     开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 是否急诊, 医嘱序号, 结论, 医疗小组id)
  Values
    (v_费用id, 2, No_In, Decode(划价_In, 1, 0, 1), 序号_In, Decode(从属父号_In, 0, Null, 从属父号_In),
     Decode(价格父号_In, 0, Null, 价格父号_In), 多病人单_In, 2, 病人id_In, 主页id_In, Decode(标识号_In, 0, Null, 标识号_In), 姓名_In, 性别_In,
     年龄_In, 床号_In, Decode(病区id_In, 0, Null, 病区id_In), Decode(科室id_In, 0, Null, 科室id_In), 费别_In, 收费类别_In, 收费细目id_In,
     计算单位_In, 保险项目否_In, 保险大类id_In, 保险编码_In, 费用类型_In, Decode(Nvl(简单记帐_In, 0), 0, Null, 收费类别_In), 付数_In, 数次_In, 加班标志_In,
     附加标志_In, 婴儿费_In, 收入项目id_In, 收据费目_In, 标准单价_In, 应收金额_In, 实收金额_In, 统筹金额_In, 1, 开单部门id_In, 开单人_In, 发生时间_In, 登记时间_In,
     执行部门id_In, 0, Decode(划价_In, 1, 操作员姓名_In, Decode(医技补临床费用_In, 1, '补临床费', Null)), Decode(划价_In, 1, Null, 操作员编号_In),
     Decode(划价_In, 1, Null, 操作员姓名_In), 记帐单id_In, 费用摘要_In, 是否急诊_In, 医嘱序号_In, 中药形态_In, n_医疗小组id);

  Select Max(使用限量 - Nvl(已用数量, 0))
  Into n_当前数量
  From 病人审批项目
  Where 病人id = 病人id_In And 主页id = 主页id_In And 项目id = 收费细目id_In And Nvl(使用限量, 0) <> 0;
  If 付数_In * 数次_In <= Nvl(n_当前数量, 0) Then
    Update 病人审批项目
    Set 已用数量 = Nvl(已用数量, 0) + 付数_In * 数次_In
    Where 病人id = 病人id_In And 主页id = 主页id_In And 项目id = 收费细目id_In And Nvl(使用限量, 0) <> 0;
  Elsif Not n_当前数量 Is Null Then
    v_Err_Msg := '第 ' || 序号_In || ' 行输入的数次超过了批准的可用数量' || n_当前数量 || '.'; --简化为不转换,直接以售价单位提示.
    Raise Err_Item;
  End If;

  --相关汇总表的处理
  If Nvl(划价_In, 0) = 0 Then
    --病人余额
    Update 病人余额 Set 费用余额 = Nvl(费用余额, 0) + 实收金额_In Where 病人id = 病人id_In And 类型 = 2 And 性质 = 1;
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 类型, 性质, 费用余额, 预交余额) Values (病人id_In, 2, 1, 实收金额_In, 0);
    End If;
  
    --病人未结费用
    Update 病人未结费用
    Set 金额 = Nvl(金额, 0) + 实收金额_In
    Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0) And Nvl(病人病区id, 0) = Nvl(病区id_In, 0) And
          Nvl(病人科室id, 0) = Nvl(科室id_In, 0) And Nvl(开单部门id, 0) = Nvl(开单部门id_In, 0) And
          Nvl(执行部门id, 0) = Nvl(执行部门id_In, 0) And 收入项目id + 0 = 收入项目id_In And 来源途径 + 0 = 2;
    If Sql%RowCount = 0 Then
      Insert Into 病人未结费用
        (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
      Values
        (病人id_In, 主页id_In, 病区id_In, 科室id_In, 开单部门id_In, 执行部门id_In, 收入项目id_In, 2, 实收金额_In);
    End If;
  End If;

  --药品和卫生材料部分
  v_Count := 0; --@@@
  If 收费类别_In = '4' Then
    --跟踪在用的卫材才处理
    Select 跟踪在用 Into v_Count From 材料特性 Where 材料id = 收费细目id_In;
  End If;
  If 收费类别_In In ('5', '6', '7') Or (收费类别_In = '4' And Nvl(v_Count, 0) = 1) Then
    If 收费类别_In = '4' Then
      Select Nvl(a.在用分批, 0), Nvl(b.是否变价, 0), b.名称
      Into n_分批, n_时价, v_名称
      From 材料特性 A, 收费项目目录 B
      Where a.材料id = b.Id And b.Id = 收费细目id_In;
    Else
      Select Nvl(a.药房分批, 0), Nvl(b.是否变价, 0), b.名称
      Into n_分批, n_时价, v_名称
      From 药品规格 A, 收费项目目录 B
      Where a.药品id = b.Id And b.Id = 收费细目id_In;
    End If;
  
    --药品分批出库方式
    Select Zl_To_Number(Nvl(zl_GetSysParameter(150), 0)) Into n_Outmode From Dual;
  
    n_总数量 := 付数_In * 数次_In;
    n_总金额 := 0;
    If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
      n_库房id := n_虚拟库房id;
      Open c_Stock(n_Outmode, n_虚拟库房id);
    Else
      If Nvl(n_修正库房id, 0) <> 0 Then
        n_库房id := n_修正库房id;
        Open c_Stock(n_Outmode, n_修正库房id);
      Else
        n_库房id := 执行部门id_In;
        Open c_Stock(n_Outmode, 执行部门id_In);
      End If;
    End If;
  
    While n_总数量 <> 0 Loop
      Fetch c_Stock
        Into r_Stock;
      If c_Stock%NotFound Then
        --第一次就没有库存,分批或时价都不允许(包含备货卫材)。
        --分批药品数量分解不完,也就是库存不足。
        If n_分批 = 1 Or n_时价 = 1 Or (Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4') Then
          Close c_Stock;
          If 医嘱序号_In Is Null Then
            If 收费类别_In = '4' Then
              If Nvl(备货材料_In, 0) = 1 And Not (n_分批 = 1 Or n_时价 = 1) Then
                v_Err_Msg := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
              Else
                v_Err_Msg := '第 ' || 序号_In || ' 行的分批或时价卫生材料"' || v_名称 || '"没有足够的材料库存' || Case
                               When Nvl(备货材料_In, 0) = 0 Then
                                '！'
                               Else
                                ',不能进行备货记帐！'
                             End;
              End If;
            Else
              v_Err_Msg := '第 ' || 序号_In || ' 行的分批或时价药品"' || v_名称 || '"没有足够的药品库存！';
            End If;
          Else
            If 收费类别_In = '4' Then
              If Nvl(备货材料_In, 0) = 1 And Not (n_分批 = 1 Or n_时价 = 1) Then
                v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
              Else
                v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现分批或时价卫生材料"' || v_名称 || '"没有足够的材料库存' || Case
                               When Nvl(备货材料_In, 0) = 0 Then
                                '！'
                               Else
                                ',不能进行备货记帐！'
                             End;
              End If;
            Else
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现分批或时价药品"' || v_名称 || '"没有足够的药品库存！';
            End If;
          End If;
          Raise Err_Item;
        End If;
      Elsif (n_分批 = 1 And Nvl(r_Stock.批次, 0) = 0) Or (n_分批 = 0 And Nvl(r_Stock.批次, 0) <> 0) Then
        Close c_Stock;
        If 医嘱序号_In Is Null Then
          If 收费类别_In = '4' Then
            v_Err_Msg := '第 ' || 序号_In || ' 行卫生材料"' || v_名称 || '"的分批属性与库存记录不相符,请检查材料数据的正确性！';
          Else
            v_Err_Msg := '第 ' || 序号_In || ' 行药品"' || v_名称 || '"的分批属性与库存记录不相符,请检查药品数据的正确性！';
          End If;
        Else
          If 收费类别_In = '4' Then
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现卫生材料"' || v_名称 || '"的分批属性与库存记录不相符,请检查材料数据的正确性！';
          Else
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现药品"' || v_名称 || '"的分批属性与库存记录不相符,请检查药品数据的正确性！';
          End If;
        End If;
        Raise Err_Item;
      End If;
    
      If c_Stock%Found Then
        If Nvl(r_Stock.实际数量, 0) = 0 And (n_总数量 > 0 Or n_时价 = 1) Then
          --实际数量为零时，不正常，不允许出库
          --实际数量不为零，金额为零，可能是正常的零价格管理。
          --负数的情况相当于入库,这种情况应是允许的；但时价需要计算价格，必须要有实际数量。
          Close c_Stock;
          If 医嘱序号_In Is Null Then
            If 收费类别_In = '4' Then
              v_Err_Msg := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"当前无库存实际数量，可能存在尚未退料的记录，当前不能出库。';
            Else
              v_Err_Msg := '第 ' || 序号_In || ' 行药品"' || v_名称 || '"当前无库存实际数量，可能存在尚未退药的记录，当前不能出库。';
            End If;
          Else
            If 收费类别_In = '4' Then
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现卫生材料"' || v_名称 || '"当前无库存实际数量，可能存在尚未退料的记录，当前不能出库。';
            Else
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现药品"' || v_名称 || '"当前无库存实际数量，可能存在尚未退药的记录，当前不能出库。';
            End If;
          End If;
          Raise Err_Item;
        End If;
      End If;
    
      --确定本次分解数量
      If n_分批 = 1 Or n_时价 = 1 Then
        --对于不分批的时价只可能分解一次,分解不完上面判断了.它分解是为了计算单价.
        --每次分解取小者,库存不够分解不完在上面判断.
        If n_总数量 <= Nvl(r_Stock.可用数量, 0) Then
          n_当前数量 := n_总数量;
        Else
          n_当前数量 := Nvl(r_Stock.可用数量, 0);
        End If;
        If n_时价 = 1 Then
          n_当前单价 := Nvl(r_Stock.零售价, Nvl(r_Stock.实际金额 / r_Stock.实际数量, 0));
        Elsif n_分批 = 1 Then
          n_当前单价 := n_标准单价;
        End If;
      Else
        --普通药品
        --不管够不够,程序中已根据参数判断
        If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
          If n_总数量 > Nvl(r_Stock.可用数量, 0) Then
            --不分批, 但又是备货卫材方式出库的,则需要检查当前库存是否充足.
            v_Err_Msg := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
            Raise Err_Item;
          End If;
        End If;
        n_当前数量 := n_总数量;
        n_当前单价 := n_标准单价;
      End If;
    
      --药品库存(普通情况可能没有记录)
      If c_Stock%Found Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - n_当前数量
        Where 库房id = n_库房id And 药品id = 收费细目id_In And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1
        Returning 可用数量 Into v_Count;
        If n_分批 = 1 Or n_时价 = 1 Then
          If v_Count < 0 Then
            If 收费类别_In = '4' Then
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现卫生材料"' || v_名称 || '"当前库存实际数量不足，当前不能出库，可能是由于网络并发操作引起，请刷新后再试！。';
            Else
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现药品"' || v_名称 || '"当前库存实际数量不足，当前不能出库，可能是由于网络并发操作引起，请刷新后再试！。';
            End If;
            Raise Err_Item;
          End If;
        End If;
      Elsif n_库房id Is Not Null Then
        --只有不分批非时价药品可能库存不足出库
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - n_当前数量
        Where 库房id = n_库房id And 药品id = 收费细目id_In And Nvl(批次, 0) = 0 And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 可用数量, 商品条码, 内部条码)
          Values
            (n_库房id, 收费细目id_In, 1, -1 * n_当前数量, r_Stock.商品条码, r_Stock.内部条码);
        End If;
      End If;
    
      If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - n_当前数量
        Where 库房id = 执行部门id_In And 药品id = 收费细目id_In And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;
      
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 可用数量, 商品条码, 内部条码, 效期, 上次批号, 上次产地, 上次供应商id, 上次生产日期, 批准文号)
          Values
            (执行部门id_In, 收费细目id_In, Nvl(r_Stock.批次, 0), 1, -1 * n_当前数量, r_Stock.商品条码, r_Stock.内部条码, r_Stock.效期,
             r_Stock.上次批号, r_Stock.上次产地, r_Stock.上次供应商id, r_Stock.上次生产日期, r_Stock.批准文号);
        End If;
      End If;
    
      --药品收发记录
      n_批次       := Null;
      v_批号       := Null;
      d_效期       := Null;
      v_产地       := Null;
      d_灭菌效期   := Null;
      d_灭菌日期   := Null;
      n_供药单位id := Null;
      d_生产日期   := Null;
      v_批准文号   := Null;
      If c_Stock%Found Then
        n_批次       := r_Stock.批次;
        v_批号       := r_Stock.上次批号;
        d_效期       := r_Stock.效期;
        v_产地       := r_Stock.上次产地;
        n_供药单位id := r_Stock.上次供应商id;
        d_生产日期   := r_Stock.上次生产日期;
        v_批准文号   := r_Stock.批准文号;
        v_商品条码   := r_Stock.商品条码;
        v_内部条码   := r_Stock.内部条码;
      
        --卫材灭菌效期:一次性材料且有效期
        If 收费类别_In = '4' Then
          v_Count := 0;
          Begin
            Select 灭菌效期 Into v_Count From 材料特性 Where Nvl(一次性材料, 0) = 1 And 材料id = 收费细目id_In;
          Exception
            When Others Then
              Null;
          End;
          If Nvl(v_Count, 0) > 0 Then
            d_灭菌效期 := r_Stock.灭菌效期;
            d_灭菌日期 := d_灭菌效期 - v_Count * 30;
          End If;
        End If;
      End If;
    
      Select Nvl(Max(序号), 0) + 1
      Into n_序号
      From 药品收发记录
      Where NO = No_In And 记录状态 = 1 And 单据 = Decode(多病人单_In, 1, 10, 9) + Decode(收费类别_In, '4', 16, 0);
    
      n_扣率 := Null;
      If 期效_In Is Not Null Or 计价特性_In Is Not Null Then
        n_扣率 := Nvl(期效_In, 0) || Nvl(计价特性_In, 0);
      End If;
    
      --分批药品,如果是只使用了一个批次,则要填写付数
      If n_分批 = 1 And n_当前数量 <> 付数_In * 数次_In Then
        v_Count := 1;
      Else
        v_Count := 0;
      End If;
    
      --修改的原单据号存放在摘要中
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人,
         填制日期, 费用id, 频次, 单量, 用法, 外观, 扣率, 灭菌效期, 灭菌日期, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
      Values
        (药品收发记录_Id.Nextval, 1, Decode(多病人单_In, 1, 10, 9) + Decode(收费类别_In, '4', 16, 0), No_In, n_序号, 执行部门id_In,
         n_领药部门id, 类别id_In, -1, 收费细目id_In, n_批次, v_产地, v_批号, d_效期, Decode(v_Count, 1, 1, 付数_In),
         Decode(v_Count, 1, n_当前数量, n_当前数量 / 付数_In), Decode(v_Count, 1, n_当前数量, n_当前数量 / 付数_In), n_当前单价,
         Round(n_当前单价 * n_当前数量, n_流通金额小数), 药品摘要_In, 操作员姓名_In, 登记时间_In, v_费用id, 频次_In, 单量_In, v_用法, v_煎法, n_扣率, d_灭菌效期,
         d_灭菌日期, n_供药单位id, d_生产日期, v_批准文号, v_商品条码, v_内部条码);
    
      --产生其他出库单
      If 收费类别_In = '4' And (Nvl(备货材料_In, 0) = 1 Or Nvl(n_修正库房id, 0) <> 0) Then
        Begin
          Select Max(a.No), Max(a.序号)
          Into v_其他出库no, n_出库序号
          From 药品收发记录 A, 住院费用记录 B
          Where a.费用id = b.Id And a.单据 = 21 And b.No = No_In And b.记录性质 = 2;
        Exception
          When Others Then
            v_其他出库no := Null;
        End;
        If v_其他出库no Is Null Then
          v_其他出库no := Nextno(74, n_虚拟库房id, Null, 1);
        End If;
        If v_其他出库no Is Null Then
          v_Err_Msg := '在生成卫生材料的其他出库单时,获取相关的出库NO有误,请检查出库单的规则是否有误!';
          Raise Err_Item;
        End If;
        If Nvl(科室id_In, 0) <> 0 Then
          Select 名称 Into v_部门名称 From 部门表 Where ID = 科室id_In;
        End If;
        v_Err_Msg := LPad(' ', 4);
        v_Err_Msg := Substr('病人姓名:' || 姓名_In || v_Err_Msg || '性别:' || 性别_In || v_Err_Msg || '年龄' || 年龄_In || v_Err_Msg ||
                            '床号:' || 床号_In || v_Err_Msg || '住院号:' || Nvl(标识号_In, '') || v_Err_Msg || '病人科室:' || v_部门名称, 1,
                            100);
      
        n_出库序号 := Nvl(n_出库序号, 0) + 1;
        Insert Into 药品收发记录
          (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人,
           填制日期, 费用id, 频次, 单量, 用法, 外观, 扣率, 灭菌效期, 灭菌日期, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
        Values
          (药品收发记录_Id.Nextval, 1, 21, v_其他出库no, n_出库序号, n_虚拟库房id, n_领药部门id, 类别id_In, -1, 收费细目id_In, n_批次, v_产地, v_批号,
           d_效期, Decode(v_Count, 1, 1, 付数_In), Decode(v_Count, 1, n_当前数量, n_当前数量 / 付数_In),
           Decode(v_Count, 1, n_当前数量, n_当前数量 / 付数_In), n_当前单价, Round(n_当前单价 * n_当前数量, n_流通金额小数), v_Err_Msg, 操作员姓名_In,
           登记时间_In, v_费用id, 频次_In, 单量_In, v_用法, v_煎法, n_扣率, d_灭菌效期, d_灭菌日期, n_供药单位id, d_生产日期, v_批准文号, v_商品条码, v_内部条码);
      End If;
      v_Err_Msg := '';
      n_总数量  := n_总数量 - n_当前数量;
      n_总金额  := n_总金额 + n_当前数量 * n_当前单价;
    End Loop;
  
    --未发药品记录
    Update 未发药品记录
    Set 病人id = 病人id_In, 主页id = 主页id_In, 姓名 = 姓名_In
    Where 单据 = Decode(多病人单_In, 1, 10, 9) + Decode(收费类别_In, '4', 16, 0) And NO = No_In And
          Nvl(库房id, 0) = Nvl(执行部门id_In, 0);
    If Sql%RowCount = 0 Then
      --取身份优先级
      Begin
        Select b.优先级 Into v_优先级 From 病人信息 A, 身份 B Where a.身份 = b.名称(+) And a.病人id = 病人id_In;
      Exception
        When Others Then
          Null;
      End;
      Insert Into 未发药品记录
        (单据, NO, 病人id, 主页id, 姓名, 优先级, 对方部门id, 库房id, 填制日期, 已收费, 打印状态)
      Values
        (Decode(多病人单_In, 1, 10, 9) + Decode(收费类别_In, '4', 16, 0), No_In, 病人id_In, 主页id_In, 姓名_In, v_优先级, n_领药部门id,
         执行部门id_In, 登记时间_In, Decode(划价_In, 1, 0, 1), 0);
    End If;
    Zl_Prescription_Type_Zy_Update(No_In, 2, 收费细目id_In, 收费类别_In);
    --可能时价药品的库存金额和数量变化了
    If n_时价 = 1 Then
      --只有一个批次时,直接取该批次的单价
      If n_当前数量 <> 付数_In * 数次_In Then
        n_当前单价 := n_总金额 / (付数_In * 数次_In);
      End If;
      If Round(n_当前单价, n_单价小数) <> 标准单价_In Then
        Close c_Stock;
        If 医嘱序号_In Is Null Then
          If 收费类别_In = '4' Then
            v_Err_Msg := '第 ' || 序号_In || ' 行的时价卫生材料"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
          Else
            v_Err_Msg := '第 ' || 序号_In || ' 行的时价药品"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
          End If;
        Else
          --医嘱摆药时是按病人分次计算并提交数据库,因此不同病人使用相同实价药品没有问题。
          --但同一病人同时使用两笔以上相同实价药品则会有问题。
          If 收费类别_In = '4' Then
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现时价卫生材料"' || v_名称 || '"当前计算的单价发生变化。' || Chr(13) || Chr(10) ||
                         '请检查该病人是否同时使用了两笔相同的"' || v_名称 || '"！';
          Else
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现时价药品"' || v_名称 || '"当前计算的单价发生变化。' || Chr(13) || Chr(10) ||
                         '请检查该病人是否同时使用了两笔相同的"' || v_名称 || '"！';
          End If;
        End If;
        Raise Err_Item;
      End If;
    End If;
    Close c_Stock;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_住院记帐记录_Insert;
/

--111342:焦博,2017-07-10,调整公共函数zl_third_GetPatiID增加一个传入参数姓名_IN来提高病人信息的正确性
--110711:焦博,2017-06-26,增加一个公共函数zl_third_GetPatiID来根据身份证号来获取病人ID
Create Or Replace Function Zl_Third_GetPatiID
(
身份证号_IN In 病人信息.身份证号%Type,
姓名_IN     In 病人信息.姓名%Type
)
 Return Number Is
  ---------------------------------------------------------------------------------------------------------------------------
  --功能:根据传入的身份证号返回病人ID
  --参数：
  --  身份证号_IN:病人信息.身份证号
  -- 返回:
  --  n_病人ID:病人信息.病人ID
  -- 规则:
  --  根据传入的病人身份证获取病人ID,如果有多个病人ID,则以最新一次就诊时间为准,如果就诊时间为空,则以最后一次登记时间为准
  --说明:如果找不到病人ID,则病人ID=0
  ----------------------------------------------------------------------------------------------------------------------------
  n_病人ID  病人信息.病人ID%Type;
  v_Temp    Varchar2(225);
  v_Err_Msg Varchar2(200);
  Err_Item Exception;
Begin
  Begin
    Select 病人ID
    Into n_病人ID
    From (Select 病人ID From 病人信息 Where 身份证号 = 身份证号_IN And 姓名=姓名_IN Order By 就诊时间 Desc, 登记时间 Desc)
    Where rownum < 2;
  Exception
    When Others Then
      n_病人ID := 0;
  End;
  Return n_病人ID;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(Sqlcode, Sqlerrm);
End zl_third_GetPatiID;
/

--110538:刘尔旋,2017-06-26,身份证号唯一性检查
Create Or Replace Procedure Zl_挂号病人病案_Insert
(
  处理类型_In       Number,
  病人id_In         病人信息.病人id%Type,
  门诊号_In         病人信息.门诊号%Type,
  就诊卡号_In       病人信息.就诊卡号%Type,
  卡验证码_In       病人信息.卡验证码%Type,
  姓名_In           病人信息.姓名%Type,
  性别_In           病人信息.性别%Type,
  年龄_In           病人信息.年龄%Type,
  费别_In           病人信息.费别%Type,
  医疗付款方式_In   病人信息.医疗付款方式%Type,
  国籍_In           病人信息.国籍%Type,
  民族_In           病人信息.民族%Type,
  婚姻_In           病人信息.婚姻状况%Type,
  职业_In           病人信息.职业%Type,
  身份证号_In       病人信息.身份证号%Type,
  工作单位_In       病人信息.工作单位%Type,
  合同单位id_In     病人信息.合同单位id%Type,
  单位电话_In       病人信息.单位电话%Type,
  单位邮编_In       病人信息.单位邮编%Type,
  家庭地址_In       病人信息.家庭地址%Type,
  家庭电话_In       病人信息.家庭电话%Type,
  家庭地址邮编_In   病人信息.家庭地址邮编%Type,
  登记时间_In       病人信息.登记时间%Type,
  挂号单_In         病人挂号记录.No%Type := Null,
  出生日期_In       病人信息.出生日期%Type := Null,
  医保号_In         病人信息.医保号%Type := Null,
  Ic卡号_In         病人信息.Ic卡号%Type := Null,
  险类_In           病人信息.险类%Type := Null,
  区域_In           病人信息.区域%Type := Null,
  户口地址_In       病人信息.户口地址%Type := Null,
  户口地址邮编_In   病人信息.户口地址邮编%Type := Null,
  联系人身份证号_In In 病人信息.联系人身份证号%Type := Null,
  联系人姓名_In     In 病人信息.联系人姓名%Type := Null,
  联系人电话_In     In 病人信息.联系人电话%Type := Null,
  联系人关系_In     In 病人信息.联系人关系%Type := Null,
  监护人_In         In 病人信息.监护人%Type := Null,
  出生地点_In       In 病人信息.出生地点%Type := Null,
  手机号_In         In 病人信息.手机号%Type := Null
) As
  --功能：处理挂号病人病案信息
  --参数：
  --处理类型：
  --             1=新建病人信息及门诊病案(用于新挂号病人)
  --             2=修改病人信息，新建门诊病案(用于无病案的病人)
  --             3=修改病人信息，不处理门诊病案(用于有病案的病人,但可能修改了病案的门诊号)
  v_年龄         Varchar2(20);
  v_年龄单位     Varchar2(20);
  v_出生日期     Date;
  n_一卡通       Number(1);
  v_Username     人员表.姓名%Type;
  v_姓名信息     病人信息.姓名%Type;
  v_年龄信息     病人信息.年龄%Type;
  v_性别信息     病人信息.性别%Type;
  v_身份证号     病人信息.身份证号%Type;
  d_出生日期信息 Date;
  d_变动时间     Date;
  v_手机号       病人信息.手机号%Type;
  v_手机号字段   Varchar2(500);
  n_唯一身份证   Number(3);
  n_存在         Number(2);
  v_Err_Msg      Varchar2(255);
  Err_Item Exception;
Begin
  If 身份证号_In Is Not Null Then
    n_唯一身份证 := Nvl(zl_GetSysParameter(279), 0);
    If n_唯一身份证 = 1 Then
      --检查身份证唯一性
      Select Nvl(Max(1), 0) Into n_存在 From 病人信息 Where 身份证号 = 身份证号_In And 病人id <> Nvl(病人id_In, 0);
      If n_存在 = 1 Then
        v_Err_Msg := '已经存在身份证号为' || 身份证号_In || '的病人,不能再录入相同的身份证号!';
        Raise Err_Item;
      End If;
    End If;
  End If;

  If 出生日期_In Is Null And 年龄_In Is Not Null Then
    --根据年龄求出生日期
    v_年龄单位 := Substr(年龄_In, Length(年龄_In), 1);
    If Instr('岁,月,天', v_年龄单位) <= 0 Then
      v_年龄单位 := Null;
    Else
      v_年龄 := Replace(年龄_In, v_年龄单位, '');
    End If;
    Begin
      v_年龄 := To_Number(v_年龄);
    Exception
      When Others Then
        v_年龄 := Null;
    End;
    If v_年龄 Is Not Null And v_年龄单位 Is Not Null Then
      Select Decode(v_年龄单位, '岁', Add_Months(Sysdate, -12 * v_年龄), '月', Add_Months(Sysdate, -1 * v_年龄), '天',
                     Sysdate - v_年龄)
      Into v_出生日期
      From Dual;
    End If;
  Else
    v_出生日期 := 出生日期_In;
  End If;

  If 手机号_In Is Null Then
    If 家庭电话_In Is Not Null Then
      --中国移动
      v_手机号字段 := ',139,138,137,136,135,134,159,158,157,150,151,152,147,188,187,182,183,184,178';
      --中国联通
      v_手机号字段 := v_手机号字段 || ',130,131,132,156,155,186,185,145,176';
      --中国电信
      v_手机号字段 := v_手机号字段 || ',133,153,189,180,181,177,173';
      --虚拟运营商
      v_手机号字段 := v_手机号字段 || ',170,';
      If Not Instr(v_手机号字段, ',' || Substr(家庭电话_In, 1, 3) || ',') = 0 Then
        v_手机号 := 家庭电话_In;
      End If;
    End If;
  Else
    v_手机号 := 手机号_In;
  End If;

  Begin
    Select 姓名, 性别, 年龄, 出生日期, 身份证号
    Into v_姓名信息, v_性别信息, v_年龄信息, d_出生日期信息, v_身份证号
    From 病人信息
    Where 病人id = 病人id_In;
    v_年龄信息 := Zl_Age_Calc(病人id_In, d_出生日期信息);
  Exception
    When Others Then
      v_姓名信息     := 姓名_In;
      v_性别信息     := 性别_In;
      v_年龄信息     := 年龄_In;
      d_出生日期信息 := v_出生日期;
      v_身份证号     := 身份证号_In;
  End;

  Begin
    Select 1 Into n_一卡通 From 一卡通目录 Where 启用 = 2 And Rownum <= 1;
  Exception
    When Others Then
      n_一卡通 := 0;
  End;

  If Not 就诊卡号_In Is Null And n_一卡通 = 0 Then
    Update 病人信息
    Set 就诊卡号 = Null, Ic卡号 = Decode(Ic卡号, 就诊卡号, Null, Ic卡号)
    Where 病人id <> 病人id_In And 就诊卡号 = 就诊卡号_In;
  End If;

  If 处理类型_In = 1 Then
    --新病人信息
    Insert Into 病人信息
      (病人id, 门诊号, 就诊卡号, 卡验证码, Ic卡号, 姓名, 性别, 年龄, 出生日期, 费别, 医疗付款方式, 国籍, 民族, 婚姻状况, 职业, 身份证号, 工作单位, 合同单位id, 单位电话, 单位邮编,
       家庭地址, 家庭电话, 家庭地址邮编, 户口地址, 户口地址邮编, 登记时间, 医保号, 区域, 联系人身份证号, 联系人姓名, 联系人电话, 联系人关系, 监护人, 出生地点, 手机号)
    Values
      (病人id_In, 门诊号_In, 就诊卡号_In, 卡验证码_In, Ic卡号_In, 姓名_In, 性别_In, 年龄_In, v_出生日期, 费别_In, 医疗付款方式_In, 国籍_In, 民族_In, 婚姻_In,
       职业_In, 身份证号_In, 工作单位_In, Decode(合同单位id_In, 0, Null, 合同单位id_In), 单位电话_In, 单位邮编_In, 家庭地址_In, 家庭电话_In, 家庭地址邮编_In,
       户口地址_In, 户口地址邮编_In, 登记时间_In, 医保号_In, 区域_In, 联系人身份证号_In, 联系人姓名_In, 联系人电话_In, 联系人关系_In, 监护人_In, 出生地点_In, v_手机号);
  Elsif 处理类型_In In (2, 3) Then
    --宁波一卡通,档案号以IC卡号传入,此时不更新就诊卡号
    Update 病人信息
    Set 门诊号 = 门诊号_In, 就诊卡号 = Decode(n_一卡通, 1, Decode(Ic卡号_In, Null, Nvl(就诊卡号_In, 就诊卡号), 就诊卡号), Nvl(就诊卡号_In, 就诊卡号)),
        Ic卡号 = Decode(n_一卡通, 1, Decode(Ic卡号_In, Null, Ic卡号, Nvl(Ic卡号_In, Ic卡号)), Nvl(Ic卡号_In, Ic卡号)),
        卡验证码 = Decode(n_一卡通, 1, Decode(Ic卡号_In, Null, Nvl(卡验证码_In, 卡验证码), 卡验证码),
                       Decode(就诊卡号_In, Null, 卡验证码, Nvl(卡验证码_In, 卡验证码))), 姓名 = 姓名_In, 性别 = Nvl(性别_In, 性别), 年龄 = 年龄_In,
        出生日期 = v_出生日期, 费别 = Nvl(费别_In, 费别), 医疗付款方式 = Nvl(医疗付款方式_In, 医疗付款方式), 国籍 = Nvl(国籍_In, 国籍), 民族 = Nvl(民族_In, 民族),
        婚姻状况 = Nvl(婚姻_In, 婚姻状况), 职业 = Nvl(职业_In, 职业), 身份证号 = 身份证号_In, 工作单位 = 工作单位_In,
        合同单位id = Decode(合同单位id_In, 0, Null, 合同单位id_In), 单位电话 = 单位电话_In, 单位邮编 = 单位邮编_In, 家庭地址 = 家庭地址_In, 家庭电话 = 家庭电话_In,
        户口地址 = Nvl(户口地址_In, 户口地址), 户口地址邮编 = Nvl(户口地址邮编_In, 户口地址邮编), 家庭地址邮编 = 家庭地址邮编_In, 医保号 = 医保号_In, 险类 = 险类_In,
        区域 = Nvl(区域_In, 区域), 联系人身份证号 = 联系人身份证号_In, 联系人姓名 = 联系人姓名_In, 联系人电话 = 联系人电话_In, 联系人关系 = 联系人关系_In, 监护人 = 监护人_In,
        出生地点 = 出生地点_In, 手机号 = Nvl(v_手机号, 手机号)
    Where 病人id = 病人id_In;
  
    v_Username := Zl_Username;
    d_变动时间 := Sysdate;
    If Nvl(病人id_In, 0) > 0 Then
      If Nvl(姓名_In, '__') <> Nvl(v_姓名信息, '__') Then
        Insert Into 病人信息变动
          (病人id, 变动项目, 原信息, 新信息, 变动时间, 变动人, 变动模块, 说明)
        Values
          (病人id_In, '姓名', v_姓名信息, 姓名_In, d_变动时间, v_Username, '挂号', '病人基本信息调整');
      End If;
      If Nvl(身份证号_In, '__') <> Nvl(v_身份证号, '__') Then
        Insert Into 病人信息变动
          (病人id, 变动项目, 原信息, 新信息, 变动时间, 变动人, 变动模块, 说明)
        Values
          (病人id_In, '身份证号', v_身份证号, 身份证号_In, d_变动时间, v_Username, '挂号', '病人基本信息调整');
      End If;
      If Nvl(性别_In, '__') <> Nvl(v_性别信息, '__') Then
        Insert Into 病人信息变动
          (病人id, 变动项目, 原信息, 新信息, 变动时间, 变动人, 变动模块, 说明)
        Values
          (病人id_In, '性别', v_性别信息, 性别_In, d_变动时间, v_Username, '挂号', '病人基本信息调整');
      End If;
      If Nvl(年龄_In, '__') <> Nvl(v_年龄信息, '__') Then
        Insert Into 病人信息变动
          (病人id, 变动项目, 原信息, 新信息, 变动时间, 变动人, 变动模块, 说明)
        Values
          (病人id_In, '年龄', v_年龄信息, 年龄_In, d_变动时间, v_Username, '挂号', '病人基本信息调整');
      End If;
      If Nvl(v_出生日期, Sysdate) <> Nvl(d_出生日期信息, Sysdate) Then
        Insert Into 病人信息变动
          (病人id, 变动项目, 原信息, 新信息, 变动时间, 变动人, 变动模块, 说明)
        Values
          (病人id_In, '出生日期', To_Char(d_出生日期信息, 'YYYY-MM-DD hh24:mi'), To_Char(v_出生日期, 'YYYY-MM-DD hh24:mi'), d_变动时间,
           v_Username, '挂号', '病人基本信息调整');
      End If;
    End If;
  
    --北京医保:问题:26982
    If Nvl(险类_In, 0) = 920 And Not 医保号_In Is Null Then
      --需要反更新
      Update 医保病人档案 B
      Set 医保号 = 医保号_In
      Where (险类, 中心, 医保号) = (Select 险类, 中心, 医保号
                             From 医保病人关联表 A
                             Where 险类 = 险类_In And a.病人id = 病人id_In And a.医保号 <> 医保号_In And Rownum = 1);
      Update 医保病人关联表 Set 医保号 = 医保号_In Where 病人id = 病人id_In And 医保号 <> 医保号_In And 险类 = 险类_In;
    End If;
  
    If 挂号单_In Is Not Null Then
    
      Update 病人挂号记录
      Set 门诊号 = 门诊号_In, 姓名 = 姓名_In, 性别 = Nvl(性别_In, 性别), 年龄 = Nvl(年龄_In, 年龄)
      Where NO = 挂号单_In;
    
      Update 门诊费用记录
      Set 标识号 = 门诊号_In, 姓名 = 姓名_In, 性别 = Nvl(性别_In, 性别), 年龄 = Nvl(年龄_In, 年龄)
      Where NO = 挂号单_In And 记录性质 = 4;
    End If;
  End If;

  --门诊病案
  If 门诊号_In Is Not Null Then
    If 处理类型_In In (1, 2) Then
      Update 门诊病案记录 Set 病案号 = 门诊号_In Where 病人id = 病人id_In;
      If Sql%RowCount = 0 Then
        Insert Into 门诊病案记录
          (病人id, 病案号, 建立日期, 病案类别, 存储状态, 存放位置)
        Values
          (病人id_In, 门诊号_In, 登记时间_In, '一般', Null, Null);
      End If;
    Elsif 处理类型_In = 3 Then
      Update 门诊病案记录 Set 病案号 = 门诊号_In Where 病人id = 病人id_In;
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_挂号病人病案_Insert;
/

--109002:陈刘,2017-06-26,记录单单个病人重算数据行,跨页数据处理

CREATE OR REPLACE Procedure Zl_病人护理打印_Update
(
  文件id_In   In 病人护理打印.文件id%Type,
  发生时间_In In 病人护理打印.发生时间%Type,
  行数_In     In 病人护理打印.行数%Type,
  删除_In     Number := 0,
  继续重算_In Number := 0
) Is
  n_Actives   Number;
  n_Rows      Number; --0-新增,>0表示修改 
  n_Startpage Number; --开始页 
  n_Startrow  Number; --开始行 
  n_Endpage   Number; --结束页 
  n_Endrow    Number; --结束行 
  n_Count     Number; --发生时间之后的数据条数 
  n_Pagerows  Number; --每页有效数据行 
  n_Del       Number;
  n_行数      病人护理打印.行数%Type;
  n_Firstdata Number; --是否是录入的第一条数据 
  n_记录id    病人护理数据.Id%Type;
  n_记录oldid 病人护理打印.记录id%Type;
  n_格式id    病人护理文件.格式id%Type;
  d_发生时间  病人护理打印.发生时间%Type;
  v_Username  人员表.姓名%Type;

  Err_Item Exception;
  v_Err_Msg Varchar2(1000);
  v_Print   Varchar2(800);
Begin
  n_Del      := 删除_In;
  n_行数     := 行数_In;
  v_Username := Zl_Username;
  Select 格式id Into n_格式id From 病人护理文件 Where ID = 文件id_In;

  If n_行数 = 0 Then
    v_Err_Msg := '有效数据行不能等于零，请记录本次错误的操作过程！';
    Raise Err_Item;
  End If;

  Begin
    Select 记录id, 行数, 开始页号, 开始行号, 结束页号, 结束行号
    Into n_记录oldid, n_Rows, n_Startpage, n_Startrow, n_Endpage, n_Endrow
    From 病人护理打印
    Where 文件id = 文件id_In And 发生时间 = 发生时间_In;
  Exception
    When Others Then
      n_Rows := 0;
  End;

  --提取该护理文件格式每页有效数据行（不加错误处理） 
  Select To_Number(内容文本)
  Into n_Pagerows
  From 病历文件结构
  Where 对象属性 = '有效数据行' And 父id = (Select ID From 病历文件结构 Where 文件id = n_格式id And 对象序号 = 1 And 父id Is Null);

  Select Count(*) Into n_Count From 病人护理数据 Where 文件id = 文件id_In And 发生时间 = 发生时间_In;

  --修改数据时,也可能删除 
  If n_Del = 0 Then
    Begin
      If n_Count = 0 Then
        n_Del := 1;
      End If;
      If n_Count > 1 Then
        v_Err_Msg := '在发生时间【' || To_Char(发生时间_In, 'YYYY-MM-DD hh24:mi:ss') || '】已经存在相应的数据，您不能再次录入或修改数据的时间为此发生时间！';
        Raise Err_Item;
      End If;
    End;
  Elsif n_Del = 1 And n_Count > 0 Then
    n_Del  := 0;
    n_行数 := 1;
  End If;

  n_Firstdata := 0;
  If n_Del = 1 Then
    Delete 病人护理打印 Where 文件id = 文件id_In And 发生时间 = 发生时间_In;
    n_Rows := n_Rows * -1;
  Else
    Select ID Into n_记录id From 病人护理数据 Where 文件id = 文件id_In And 发生时间 = 发生时间_In;
  
    If n_Rows = 0 Then
      --根据现有打印数据及将要插入的数据，计算出开始页号，行号，结束页号，行号 
      Select Min(发生时间) Into d_发生时间 From 病人护理打印 Where 文件id = 文件id_In And 发生时间 > 发生时间_In;
      If d_发生时间 Is Null Then
        Select Max(发生时间) Into d_发生时间 From 病人护理打印 Where 文件id = 文件id_In And 发生时间 < 发生时间_In;
        If d_发生时间 Is Null Then
          n_Startpage := 1;
          n_Startrow  := 1;
          n_Firstdata := 1;
        Else
          Select 结束页号, 结束行号
          Into n_Startpage, n_Startrow
          From 病人护理打印
          Where 文件id = 文件id_In And 发生时间 = d_发生时间;
          n_Startrow := n_Startrow + 1;
        End If;
      Else
        Select 开始页号, 开始行号
        Into n_Startpage, n_Startrow
        From 病人护理打印
        Where 文件id = 文件id_In And 发生时间 = d_发生时间;
      End If;
    
      --校正页号,行号 
      If n_Startrow > n_Pagerows Then
        n_Startpage := n_Startpage + 1;
        n_Startrow  := n_Startrow - n_Pagerows;
      
        --翻页时，自动依据当前页的设置产生新页的活动项目设置 
        Begin
          Select 1 Into n_Actives From 病人护理活动项目 Where 文件id = 文件id_In And 页号 = n_Startpage And Rownum < 2;
        Exception
          When Others Then
            n_Actives := 0;
        End;
      
        If n_Actives = 0 Then
          Insert Into 病人护理活动项目
            (文件id, 页号, 列号, 列头名称, 序号, 项目序号, 部位, 操作员, 操作时间)
            Select 文件id, n_Startpage, 列号, 列头名称, 序号, 项目序号, 部位, v_Username, Sysdate
            From 病人护理活动项目
            Where 文件id = 文件id_In And 页号 = n_Startpage - 1;
        End If;
      End If;
      n_Endpage := n_Startpage;
      n_Endrow  := n_Startrow + n_行数 - 1;
      If n_Endrow > n_Pagerows Then
        --不考虑输入的数据超过一页的情况 
        n_Endpage := n_Endpage + 1;
        n_Endrow  := n_Endrow - n_Pagerows;
      
        --翻页时，自动依据当前页的设置产生新页的活动项目设置 
        Begin
          Select 1 Into n_Actives From 病人护理活动项目 Where 文件id = 文件id_In And 页号 = n_Endpage And Rownum < 2;
        Exception
          When Others Then
            n_Actives := 0;
        End;
      
        If n_Actives = 0 Then
          Insert Into 病人护理活动项目
            (文件id, 页号, 列号, 列头名称, 序号, 项目序号, 部位, 操作员, 操作时间)
            Select 文件id, n_Endpage, 列号, 列头名称, 序号, 项目序号, 部位, v_Username, Sysdate
            From 病人护理活动项目
            Where 文件id = 文件id_In And 页号 = n_Endpage - 1;
        End If;
      End If;
      --不允许录入跨两页的数据 
      If n_Endrow > n_Pagerows Or n_Endpage - n_Startpage > 1 Then
        If 继续重算_In = 1 Then
          n_行数   := n_行数 - n_Endrow + n_Pagerows;
          n_Endrow := n_Pagerows;
        Else
          v_Err_Msg := '您在发生时间【' || To_Char(发生时间_In, 'YYYY-MM-DD hh24:mi:ss') || '】录入的数据存在错误，录入的数据不能连续跨一页以上！';
          Raise Err_Item;
        End If;
      End If;
    
      Insert Into 病人护理打印
        (记录id, 文件id, 发生时间, 行数, 开始页号, 开始行号, 结束页号, 结束行号)
      Values
        (n_记录id, 文件id_In, 发生时间_In, n_行数, n_Startpage, n_Startrow, n_Endpage, n_Endrow);
      --新插入的数据的行数就是差值 
      n_Rows := n_行数;
    Else
      --计算与原行数的差值 
      n_Rows := n_行数 - n_Rows;
      --校正页号,行号 
      n_Endrow := n_Endrow + n_Rows;
      If n_Endrow <= 0 Then
        n_Endrow  := n_Pagerows + n_Endrow;
        n_Endpage := n_Endpage - 1;
      End If;
      If n_Endrow > n_Pagerows Then
        --不考虑输入的数据超过一页的情况 
        n_Endpage := n_Endpage + 1;
        n_Endrow  := n_Endrow - n_Pagerows;
      End If;
    
      --不允许录入跨两页的数据 
      If n_Endrow > n_Pagerows Or n_Endpage - n_Startpage > 1 Then
        v_Err_Msg := '您在发生时间【' || To_Char(发生时间_In, 'YYYY-MM-DD hh24:mi:ss') || '】录入的数据存在错误，录入的数据不能连续跨一页以上！';
        Raise Err_Item;
      End If;
    
      --更新打印数据（当前数据的打印人与打印时间更新为NULL，其后数据不动） 
      Update 病人护理打印
      Set 文件id = 文件id_In, 记录id = n_记录id, 发生时间 = 发生时间_In, 行数 = n_行数, 开始页号 = n_Startpage, 开始行号 = n_Startrow,
          结束页号 = n_Endpage, 结束行号 = n_Endrow, 行差 = Decode(打印人, Null, 0, n_Rows),
          --只有打印过的数据才记录行差 
          打印人 = Null, 打印时间 = Null
      Where 记录id = n_记录oldid;
    End If;
  End If;
  --无行差，退出 
  If n_Rows = 0 Then
    Return;
  End If;

  --之后是否存在数据？ 
  Begin
    Select 1 Into n_Count From 病人护理打印 Where 文件id = 文件id_In And 发生时间 > 发生时间_In And Rownum < 2;
  Exception
    When Others Then
      n_Count := 0;
  End;

  If n_Count = 1 Then
    --更新之后数据的打印相关数据（除打印人与打印时间） 
    If n_Rows > 0 Then
      Update 病人护理打印
      Set 开始页号 = 开始页号 + Decode(Sign(开始行号 + n_Rows - n_Pagerows), 1, 1, 0),
          结束页号 = 结束页号 + Decode(Sign(结束行号 + n_Rows - n_Pagerows), 1, 1, 0),
          开始行号 = Decode(Mod(开始行号 + n_Rows, n_Pagerows), 0, n_Pagerows, Mod(开始行号 + n_Rows, n_Pagerows)),
          结束行号 = Decode(Mod(结束行号 + n_Rows, n_Pagerows), 0, n_Pagerows, Mod(结束行号 + n_Rows, n_Pagerows)), 打印人 = Null,
          打印时间 = Null
      Where 文件id = 文件id_In And 发生时间 > 发生时间_In;
    Else
      --新的行号小于1则页号-1 
      --新的行号+每页的有效行后再进行判断 
      Update 病人护理打印
      Set 开始页号 = 开始页号 - Decode(Sign(开始行号 + n_Rows - 1), -1, 1, 0),
          结束页号 = 结束页号 - Decode(Sign(结束行号 + n_Rows - 1), -1, 1, 0),
          开始行号 = Decode(Mod(开始行号 + n_Pagerows + n_Rows, n_Pagerows), 0, n_Pagerows,
                         Mod(开始行号 + n_Pagerows + n_Rows, n_Pagerows)),
          结束行号 = Decode(Mod(结束行号 + n_Pagerows + n_Rows, n_Pagerows), 0, n_Pagerows,
                         Mod(结束行号 + n_Pagerows + n_Rows, n_Pagerows)), 打印人 = Null, 打印时间 = Null
      Where 文件id = 文件id_In And 发生时间 > 发生时间_In;
      --程序应该是先删除了数据才更新的，所以不会存在页号为零的，页号为零的肯定已经删除了。 
      --DELETE 病人护理打印 WHERE 开始页号=0; 
    End If;
    --检查更新之后的打印数据是否存在连续跨一页以上，如果存在则禁止。 
    v_Print := '';
    For r_Print In (Select 发生时间, 开始页号
                    From 病人护理打印
                    Where 文件id = 文件id_In And 发生时间 > 发生时间_In And 结束页号 - 开始页号 > 1
                    Order By 发生时间) Loop
      If Lengthb(v_Print || Chr(13) || Chr(10) || '页号【' || r_Print.开始页号 || '】    发生时间【' ||
                 To_Char(r_Print.发生时间, 'YYYY-MM-DD hh24:mi:ss') || '】') < 800 Then
        v_Print := v_Print || Chr(13) || Chr(10) || '页号【' || r_Print.开始页号 || '】    发生时间【' ||
                   To_Char(r_Print.发生时间, 'YYYY-MM-DD hh24:mi:ss') || '】';
      End If;
    End Loop;
    If v_Print Is Not Null Then
      v_Err_Msg := '您在发生时间【' || To_Char(发生时间_In, 'YYYY-MM-DD hh24:mi:ss') || '】录入的数据影响了后续数据位置，导致以下数据连续跨了一页以上：';
      v_Err_Msg := v_Err_Msg || v_Print || Chr(13) || Chr(10) || '目前产品暂不支持对跨一页以上的数据进行展示和打印，操作终止！';
    End If;
  End If;
  --进行关联文件的页号修正 
  Zl_病人护理打印_Batchretrypage(文件id_In, n_Firstdata || ';' || n_Firstdata);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人护理打印_Update;
/
--105161:张德婷,2017-06-26,人员停用时调用费用过程
Create Or Replace Procedure Zl_人员表_停用
(
  Id_In       In 人员表.ID%Type,
  撤档原因_In 人员表.撤档原因%Type := Null
) Is
Begin
  Update 人员表 Set 撤档时间 = Sysdate, 撤档原因 = 撤档原因_In Where ID = Id_In;
  
  Zl_人员表_更新挂号安排(Id_In,2,sysdate);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_人员表_停用;
/

--105161:张德婷,2017-06-26,人员启用时调用费用过程
Create Or Replace Procedure Zl_人员表_启用
(
  Id_In In 人员表.ID%Type
) Is
d_撤档时间 date;
v_Error    Varchar2(255);
Err_Custom Exception;
Begin
  Begin
    select 撤档时间 into d_撤档时间 from 人员表 where id=Id_In;
  Exception
    When Others Then
      v_Error := '该人员已被删除！';
      Raise Err_Custom;
  End;   
    
  Update 人员表 Set 撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd'), 撤档原因 = '' Where ID = Id_In;
  
  Zl_人员表_更新挂号安排(Id_In,3,d_撤档时间);
  
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_人员表_启用;
/

--105161:张德婷,2017-06-26,修改人员姓名的时候调用费用过程
Create Or Replace Procedure Zl_人员表_修改
(
  Id_In           In 人员表.Id%Type,
  编号_In         In 人员表.编号%Type,
  姓名_In         In 人员表.姓名%Type,
  简码_In         In 人员表.简码%Type,
  身份证号_In     In 人员表.身份证号%Type,
  出生日期_In     In 人员表.出生日期%Type,
  性别_In         In 人员表.性别%Type,
  民族_In         In 人员表.民族%Type,
  工作日期_In     In 人员表.工作日期%Type,
  办公室电话_In   In 人员表.办公室电话%Type,
  电子邮件_In     In 人员表.电子邮件%Type,
  执业类别_In     In 人员表.执业类别%Type,
  执业范围_In     In 人员表.执业范围%Type,
  管理职务_In     In 人员表.管理职务%Type,
  专业技术职务_In In 人员表.专业技术职务%Type,
  聘任技术职务_In In 人员表.聘任技术职务%Type,
  学历_In         In 人员表.学历%Type,
  所学专业_In     In 人员表.所学专业%Type,
  留学时间_In     In 人员表.留学时间%Type,
  留学渠道_In     In 人员表.留学渠道%Type,
  接受培训_In     In 人员表.接受培训%Type,
  科研课题_In     In 人员表.科研课题%Type,
  个人简介_In     In 人员表.个人简介%Type,
  部门列表_In     In Varchar2, --部门列表_IN参数的填写方式如下："12:1;23:0;" 
  人员性质_In     In Varchar2, --人员性质_IN参数的填写方式如下："门诊挂号员;医生;护士;" 
  别名_In         In 人员表.别名%Type := Null,
  站点_In         In 人员表.站点%Type := Null,
  签名_In         In 人员表.签名%Type := Null,
  执业证号_In     In 人员表.执业证号%Type := Null,
  资格证书号_In   In 人员表.资格证书号%Type := Null,
  执业开始日期_In In 人员表.执业开始日期%Type := Null,
  处方权标志_In   In 人员表.处方权标志%Type := Null,
  手术等级_In     In 人员表.手术等级%Type := Null,
  移动电话_In     In 人员表.移动电话%Type := Null,
  顺序_In         In 人员表.顺序%Type := Null
) Is
  Intpos    Pls_Integer;
  Int缺省   Number(1);
  Strtemp   Varchar2(2000);
  Str性质   Varchar2(10);
  Lng部门id 部门表.Id%Type;
  v_姓名    人员表.姓名%Type;
  v_Error    Varchar2(255);
  Err_Custom Exception;
Begin
  Begin
    select 姓名 into v_姓名 from 人员表 where id=Id_In;
  Exception
    When Others Then
      v_Error := '该人员已被删除！';
      Raise Err_Custom;
  End;
  
  --首先插入修改记录 
  Update 人员表
  Set 编号 = 编号_In, 姓名 = 姓名_In, 简码 = 简码_In, 身份证号 = 身份证号_In, 出生日期 = 出生日期_In, 性别 = 性别_In, 民族 = 民族_In, 工作日期 = 工作日期_In,
      办公室电话 = 办公室电话_In, 电子邮件 = 电子邮件_In, 执业类别 = 执业类别_In, 执业范围 = 执业范围_In, 管理职务 = 管理职务_In, 专业技术职务 = 专业技术职务_In,
      聘任技术职务 = 聘任技术职务_In, 学历 = 学历_In, 所学专业 = 所学专业_In, 留学时间 = 留学时间_In, 留学渠道 = 留学渠道_In, 接受培训 = 接受培训_In, 科研课题 = 科研课题_In,
      个人简介 = 个人简介_In, 站点 = 站点_In, 别名 = 别名_In, 签名 = 签名_In, 执业证号 = 执业证号_In, 资格证书号 = 资格证书号_In, 执业开始日期 = 执业开始日期_In,
      处方权标志 = 处方权标志_In, 手术等级 = 手术等级_In, 移动电话 = 移动电话_In, 顺序 = 顺序_In, 最后修改时间 = Sysdate
  Where ID = Id_In;

  --接着删除已有的所属部门 
  Delete From 部门人员 Where 人员id = Id_In;

  --接着修改所属部门 
  Strtemp := 部门列表_In;

  While Strtemp Is Not Null Loop
    Intpos := Instr(Strtemp, ':');
  
    If Intpos = 0 Then
      Strtemp := '';
    Else
      --得到部门ID 
      Str性质   := Substr(Strtemp, 1, Intpos - 1);
      Lng部门id := To_Number(Str性质);
      Strtemp   := Substr(Strtemp, Intpos + 1);
      --得到是否缺省 
      Intpos  := Instr(Strtemp, ';');
      Int缺省 := To_Number(Substr(Strtemp, 1, Intpos - 1));
      Strtemp := Substr(Strtemp, Intpos + 1);
    
      Insert Into 部门人员 (部门id, 人员id, 缺省) Values (Lng部门id, Id_In, Int缺省);
    End If;
  End Loop;

  --接着删除已有的性质说明 
  Delete From 人员性质说明 Where 人员id = Id_In;

  --最后修改人员性质说明 
  Strtemp := 人员性质_In;

  While Strtemp Is Not Null Loop
    Intpos := Instr(Strtemp, ';');
  
    If Intpos = 0 Then
      Strtemp := '';
    Else
      --得到人员性质 
      Str性质 := Substr(Strtemp, 1, Intpos - 1);
      Strtemp := Substr(Strtemp, Intpos + 1);
    
      Insert Into 人员性质说明 (人员性质, 人员id) Values (Str性质, Id_In);
    End If;
  End Loop;
  
  --同步费用数据
  if v_姓名<>姓名_In then
    Zl_人员表_更新挂号安排(Id_In,1);
  end if;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_人员表_修改;
/

--93163:余伟节,2017-06-24,长期担保针对住院病人出院后自动失效
Create Or Replace Procedure Zl_病人变动记录_Out
(
  病人id_In       病案主页.病人id%Type,
  主页id_In       病案主页.主页id%Type,
  疾病id_In       病人诊断记录.疾病id%Type,
  诊断id_In       病人诊断记录.诊断id%Type,
  出院诊断_In     病人诊断记录.诊断描述%Type,
  出院情况_In     病人诊断记录.出院情况%Type,
  中医疾病id_In   病人诊断记录.疾病id%Type,
  中医诊断id_In   病人诊断记录.诊断id%Type,
  中医诊断_In     病人诊断记录.诊断描述%Type,
  中医出院情况_In 病人诊断记录.出院情况%Type,
  是否疑诊_In     病案主页.是否确诊%Type, --同时作为西医的是否疑诊
  出院方式_In     病案主页.出院方式%Type,
  出院时间_In     病案主页.出院日期%Type,
  随诊标志_In     病案主页.随诊标志%Type, --0/NULL-不随诊，1-月，2-年，3-周，4-天，9-终身
  随诊期限_In     病案主页.随诊期限%Type,
  尸检标志_In     病案主页.尸检标志%Type,
  操作员编号_In   病人变动记录.操作员编号%Type,
  操作员姓名_In   病人变动记录.操作员姓名%Type,
  确诊日期_In     病案主页.确诊日期%Type := Null
) As
  -----------------------------------------------------------
  --说明：病人出院
  -----------------------------------------------------------
  Cursor c_Bedinfo Is
    Select 病区id, 床号 From 床位状况记录 Where 病人id = 病人id_In;

  v_Count Number;
  Err_Custom Exception;
  v_Error      Varchar2(255);
  v_随诊期限   Date;
  v_应发时间   Date;
  v_共享号     Zlsystems.共享号%Type;
  v_年龄       病人信息.年龄%Type;
  v_Sql        Varchar2(1000);
  v_住院医师   Varchar2(20);
  v_出院科室   Number;
  v_姓名       病人信息.姓名%Type;
  n_婴儿科室id 病案主页.婴儿科室id%Type;
Begin
  --首先判断该病人是否已出院
  Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In And 出院日期 Is Null;

  If v_Count = 0 Then
    v_Error := '操作失败,该病人可能已经出院！';
    Raise Err_Custom;
  End If;

  --首先判断该病人是否处于等待转科或入科状态
  Select Count(*)
  Into v_Count
  From 病案主页
  Where 病人id = 病人id_In And 主页id = 主页id_In And 出院日期 Is Null And Nvl(状态, 0) In (0, 3);
  If v_Count = 0 Then
    v_Error := '操作失败,该病人正处于转科状态或尚未入科,不能出院！';
    Raise Err_Custom;
  End If;

  --临床路径正在执行时不允许出院
  Select Max(b.状态)
  Into v_Count
  From 病案主页 A, 病人临床路径 B
  Where a.病人id = 病人id_In And a.主页id = 主页id_In And a.病人id = b.病人id And a.主页id = b.主页id And a.出院科室id = b.科室id;
  If v_Count = 1 Then
    v_Error := '该病人的临床路径正在执行中,不能出院。';
    Raise Err_Custom;
  End If;

  --母婴分离婴儿未出院则母亲不能出院
  Select 婴儿科室id Into n_婴儿科室id From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
  If n_婴儿科室id Is Not Null Then
    Select Count(*)
    Into v_Count
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.病人id = 病人id_In And a.主页id = 主页id_In And a.诊疗项目id = b.Id And b.操作类型 = '5' And b.类别 = 'Z' And
          Nvl(a.婴儿, 0) <> 0 And a.医嘱状态 <> 4;
    If v_Count = 0 Then
      v_Error := '该病人的婴儿还在其他科室，并未下达出院医嘱,请先给婴儿下达出院医嘱后再出院。';
      Raise Err_Custom;
    End If;
  End If;

  v_Count := Nvl(zl_GetSysParameter('特殊医嘱发送前检查未生效医嘱', 1254), 0);
  If v_Count = 1 Then
    v_姓名 := Null;
    Select Max(姓名)
    Into v_姓名
    From 病人医嘱记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 医嘱状态 = 1 And Rownum = 1;
    If v_姓名 Is Not Null Then
      v_Error := v_姓名 || '存在未校对的医嘱，请删除或校对后再继续。';
      Raise Err_Custom;
    End If;
  
    v_姓名 := Null;
    Select Max(姓名)
    Into v_姓名
    From 病人医嘱记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 医嘱期效 = 1 And 医嘱状态 In (2, 3) And Nvl(执行标记, 0) <> -1 And
          Nvl(执行性质, 0) <> 0 And Rownum = 1;
    If v_姓名 Is Not Null Then
      v_Error := v_姓名 || '存在校对后未发送的临嘱，请发送或作废后再继续。';
      Raise Err_Custom;
    End If;
  End If;

  --判断是否产生住院日报
  Select Nvl(出院科室id, 入院科室id), 住院医师
  Into v_出院科室, v_住院医师
  From 病案主页
  Where 病人id = 病人id_In And 主页id = 主页id_In;
  Select Zl_住院日报_Count(v_出院科室, 出院时间_In) Into v_Count From Dual;
  If v_Count > 0 Then
    v_Error := '已产生业务时间内的住院日报,不能办理该业务!';
    Raise Err_Custom;
  End If;

  --判断是否与病案系统共享
  Begin
    Select 共享号 Into v_共享号 From zlSystems Where Floor(编号 / 100) = 3;
  Exception
    When Others Then
      Null;
  End;
  --出院变动
  Update 病人变动记录
  Set 终止时间 = 出院时间_In, 终止原因 = 1, 终止人员 = 操作员姓名_In, 上次计算时间 = Decode(Sign(Nvl(上次计算时间, 出院时间_In) - 出院时间_In), 1, Null, 上次计算时间)
  Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
  
  Update 病人自动计算
  Set 终止时间 = 出院时间_In, 终止原因 = 1, 终止人员 = 操作员姓名_In, 上次计算时间 = Decode(Sign(Nvl(上次计算时间, 出院时间_In) - 出院时间_In), 1, Null, 上次计算时间)
  Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
  
  --床位记录
  For r_Bedrow In c_Bedinfo Loop
    Update 床位状况记录
    Set 状态 = '空床', 病人id = Null, 科室id = Decode(共用, 1, Null, 科室id)
    Where 病区id = r_Bedrow.病区id And 床号 = r_Bedrow.床号;
  End Loop;

  --病案主页
  Update 病案主页
  Set 状态 = 0, 出院日期 = 出院时间_In, 出院方式 = 出院方式_In,
      住院天数 = Decode(Trunc(出院时间_In) - Trunc(入院日期), 0, 1, Trunc(出院时间_In) - Trunc(入院日期)), 随诊标志 = 随诊标志_In,
      随诊期限 = Decode(随诊期限_In, 0, Null, 随诊期限_In), 尸检标志 = 尸检标志_In, 是否确诊 = Decode(Nvl(是否疑诊_In, 0), 0, 0, 1), 确诊日期 = 确诊日期_In
  Where 病人id = 病人id_In And 主页id = 主页id_In;

  --产生病历书写时机
  Zl_电子病历时机_Insert(病人id_In, 主页id_In, 2, '出院', v_出院科室, v_住院医师, 出院时间_In, 出院时间_In);
  --增加随诊记录
  If v_共享号 = 100 Then
    If Nvl(随诊期限_In, 0) <> 0 Then
      If 随诊标志_In = 1 Then
        v_随诊期限 := Add_Months(出院时间_In, 随诊期限_In);
      Elsif 随诊标志_In = 2 Then
        v_随诊期限 := Add_Months(出院时间_In, 12 * 随诊期限_In);
      Elsif 随诊标志_In = 3 Then
        v_随诊期限 := 出院时间_In + 7 * 随诊期限_In;
      Elsif 随诊标志_In = 4 Then
        v_随诊期限 := 出院时间_In + 随诊期限_In;
      End If;
    Else
      v_随诊期限 := To_Date('3000-1-1', 'YYYY-MM-DD');
    End If;
  
    If 随诊标志_In = 1 Or 随诊标志_In = 2 Or 随诊标志_In = 3 Or 随诊标志_In = 4 Then
      If v_随诊期限 > Add_Months(出院时间_In, 3) Then
        v_应发时间 := Trunc(Add_Months(出院时间_In, 3));
      Else
        v_应发时间 := v_随诊期限;
      End If;
      v_Sql := 'Insert Into 随诊记录 (ID, 病人id, 主页id, 随诊期限, 应发时间) Values (随诊记录_Id.Nextval,:1,:2,:3,:4)';
      Execute Immediate v_Sql
        Using 病人id_In, 主页id_In, To_Date(To_Char(v_随诊期限, 'YYYY-MM-DD'), 'YYYY-MM-DD'), To_Date(To_Char(v_应发时间, 'YYYY-MM-DD'), 'YYYY-MM-DD');
    End If;
  End If;
  --病人信息
  v_年龄 := Zl_Age_Calc(病人id_In);
  Update 病人信息
  Set 当前科室id = Null, 当前病区id = Null, 当前床号 = Null, 出院时间 = 出院时间_In, 年龄 = v_年龄, 在院 = Null
  Where 病人id = 病人id_In;
  --在院病人
  Delete From 在院病人 Where 病人id = 病人id_In;
  --出院诊断
  If 出院诊断_In Is Not Null Or 疾病id_In Is Not Null Or 诊断id_In Is Not Null Then
    Delete From 病人诊断记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 诊断类型 = 3 And 诊断次序 = 1 And 记录来源 = 2;
    Insert Into 病人诊断记录
      (ID, 病人id, 主页id, 记录来源, 诊断类型, 诊断次序, 疾病id, 诊断id, 诊断描述, 是否疑诊, 出院情况, 记录日期, 记录人)
    Values
      (病人诊断记录_Id.Nextval, 病人id_In, 主页id_In, 2, 3, 1, 疾病id_In, 诊断id_In, 出院诊断_In, Decode(Nvl(是否疑诊_In, 0), 0, 1, 0),
       出院情况_In, Sysdate, 操作员姓名_In);
  End If;

  --中医出院诊断
  If 中医诊断_In Is Not Null Or 中医疾病id_In Is Not Null Or 中医诊断id_In Is Not Null Then
    Delete From 病人诊断记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 诊断类型 = 13 And 诊断次序 = 1 And 记录来源 = 2;
    Insert Into 病人诊断记录
      (ID, 病人id, 主页id, 记录来源, 诊断类型, 诊断次序, 疾病id, 诊断id, 诊断描述, 是否疑诊, 出院情况, 记录日期, 记录人)
    Values
      (病人诊断记录_Id.Nextval, 病人id_In, 主页id_In, 2, 13, 1, 中医疾病id_In, 中医诊断id_In, 中医诊断_In, Null, 中医出院情况_In, Sysdate, 操作员姓名_In);
  End If;

  --正常担保记录出院后自动失效    
  Update 病人担保记录
  Set 到期时间 = Sysdate
  Where 病人id = 病人id_In And 主页id = 主页id_In And 到期时间 Is Not Null And 到期时间 > Sysdate And 删除标志 = 1 And Nvl(担保性质, 0) = 0;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人变动记录_Out;
/

--109786:胡俊勇,2017-06-24,妇幼保健医生站数据接口
CREATE OR REPLACE Procedure Zl_Third_Receive
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:病人接诊候诊病人，都要经过分诊，暂不考虑预约/转诊病人
  --入参:Xml_In:
  --  <IN>
  --    <JZID>1</JZID>                             挂号ID
  --    <JZZS>门诊内科</JZZS>                     接诊诊室
  --    <JZRQ>2017-05-23 08:30:30</JZRQ>          接诊时间
  --    <JZYS>张永康</JZYS>                       接诊医生
  --  </IN>
  --出参:Xml_Out
  --  <OUTPUT>
  --    <ERROR>
  --      <MSG>错误信息</MSG>
  --    </ERROR>
  --  </OUTPUT>
  --------------------------------------------------------------------------------------------------
  n_挂号id   病人挂号记录.Id%Type;
  v_执行人   病人挂号记录.执行人%Type;
  v_诊室     病人挂号记录.诊室%Type;
  d_接收时间 病人挂号记录.接收时间%Type;
  v_Tmp      Varchar2(2000);
  n_Cnt      Number;
  v_Err_Msg  Varchar2(200);
  Err_Item Exception;
Begin
  --参数名：病人接诊控制，模块：1260，忽略 
  Select Extractvalue(Value(A), 'IN/JZID'), Extractvalue(Value(A), 'IN/JZZS'), Extractvalue(Value(A), 'IN/JZRQ'),
         Extractvalue(Value(A), 'IN/JZYS')
  Into n_挂号id, v_诊室, v_Tmp, v_执行人
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  d_接收时间 := To_Date(v_Tmp, 'YYYY-MM-DD HH24:MI:ss');

  For R In (Select a.执行状态, a.执行人, a.病人id, a.No, a.记录性质, a.记录状态, a.姓名, a.诊室
            From 病人挂号记录 A
            Where a.Id = n_挂号id) Loop
  
    If r.诊室 Is Null Then
      v_Err_Msg := r.姓名 || ' 未分诊，要分诊后才能接诊。';
      Raise Err_Item;
    End If;
  
    If r.记录性质 = 1 And r.记录状态 = 1 Then
      If Nvl(r.执行状态, 0) <> 0 Then
        v_Err_Msg := r.姓名 || ' 已被医生：' || Nvl(r.执行人, '医生') || '接诊。';
        Raise Err_Item;
      End If;
    End If;
  
    Select Count(1)
    Into n_Cnt
    From 病人挂号记录 A
    Where a.记录性质 = 1 And a.记录状态 = 1 And Nvl(a.执行状态, 0) = 0 And a.Id = n_挂号id;
    If n_Cnt = 0 Then
      v_Err_Msg := r.姓名 || '已退号，不能接诊。';
      Raise Err_Item;
    End If;
  
    Zl_病人接诊(r.病人id, r.No, Null, v_执行人, v_诊室, 0, 0, d_接收时间);
  End Loop;
  Xml_Out := Xmltype('<OUTPUT><ERROR><MSG></MSG></ERROR></OUTPUT>');
Exception
  When Err_Item Then
    v_Tmp   := '<OUTPUT><ERROR><MSG>' || v_Err_Msg || '</MSG></ERROR></OUTPUT>';
    Xml_Out := Xmltype(v_Tmp);
  When Others Then
    v_Tmp   := '<OUTPUT><ERROR><MSG>错误信息：' || SQLErrM || '</MSG></ERROR></OUTPUT>';
    Xml_Out := Xmltype(v_Tmp);
End Zl_Third_Receive;
/

--109786:胡俊勇,2017-06-24,妇幼保健医生站数据接口
CREATE OR REPLACE Procedure Zl_Third_Cancel
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:取消接诊
  --入参:Xml_In:
  --  <IN>
  --    <JZID>1</JZID>                 挂号ID
  --    <JZYS>张永康</JZYS>            当前操作医生
  --  </IN>
  --出参:Xml_Out
  --  <OUTPUT>
  --    <ERROR>
  --      <MSG>错误信息</MSG>
  --    </ERROR>
  --  </OUTPUT>
  --------------------------------------------------------------------------------------------------
  n_挂号id  病人挂号记录.Id%Type;
  v_执行人  病人挂号记录.执行人%Type;
  n_Cnt     Number;
  n_天数    Number;
  v_Tmp     Varchar2(2000);
  v_Err_Msg Varchar2(200);
  Err_Item Exception;
Begin

  --参数：病人接诊控制，忽略   
  Select Extractvalue(Value(A), 'IN/JZID'), Extractvalue(Value(A), 'IN/JZYS')
  Into n_挂号id, v_执行人
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  For R In (Select a.登记时间, a.急诊, a.执行状态, a.执行人, a.病人id, a.No, a.记录性质, a.记录状态, a.姓名
            From 病人挂号记录 A
            Where a.Id = n_挂号id) Loop
  
    --挂号单是否过期检查    
    n_Cnt := To_Number(Nvl(zl_GetSysParameter(210), '0'));
    If n_Cnt = 0 Then
      v_Tmp := Nvl(zl_GetSysParameter(21), '11') || '11';
      If Nvl(r.急诊, 0) = 0 Then
        n_Cnt := To_Number(Substr(v_Tmp, 1, 1));
      Else
        n_Cnt := To_Number(Substr(v_Tmp, 2, 1));
      End If;
      If n_Cnt > 0 Then
        Select r.登记时间 - Trunc(Sysdate) Into n_天数 From Dual;
        If n_天数 > n_Cnt Then
          v_Err_Msg := '该病人挂号已超过有效天数，不允许再取消接诊。';
          Raise Err_Item;
        End If;
      End If;
    End If;
  
    If r.执行人 <> v_执行人 Then
      v_Err_Msg := r.姓名 || ' 是 ' || r.执行人 || ' 接诊，你能取消自己接诊的病人。';
      Raise Err_Item;
    End If;
  
    --医嘱数据的检查
    Select Count(1) Into n_Cnt From 病人医嘱记录 Where 医嘱状态 In (1, 8) And 挂号单 = r.No;
    If n_Cnt > 0 Then
      v_Err_Msg := r.姓名 || '已有新开或已发送的医嘱，不能取消接诊。' || Chr(13) || '如果确实要取消接诊，请先将这些医嘱删除或作废。';
      Raise Err_Item;
    End If;
    Zl_病人接诊_Cancel(r.病人id, r.No);
  End Loop;
  Xml_Out := Xmltype('<OUTPUT><ERROR><MSG></MSG></ERROR></OUTPUT>');
Exception
  When Err_Item Then
    v_Tmp   := '<OUTPUT><ERROR><MSG>' || v_Err_Msg || '</MSG></ERROR></OUTPUT>';
    Xml_Out := Xmltype(v_Tmp);
  When Others Then
    v_Tmp   := '<OUTPUT><ERROR><MSG>错误信息：' || SQLErrM || '</MSG></ERROR></OUTPUT>';
    Xml_Out := Xmltype(v_Tmp);
End Zl_Third_Cancel;
/

--109786:胡俊勇,2017-06-24,妇幼保健医生站数据接口
CREATE OR REPLACE Procedure Zl_Third_Finish
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:病人完成就诊
  --入参:Xml_In:
  --  <IN>
  --    <JZID>1</JZID>                             挂号ID
  --    <JZZS>门诊内科</JZZS>                     接诊诊室
  --    <JZYS>张永康</JZYS>                        接诊医生
  --  </IN>
  --出参:Xml_Out
  --  <OUTPUT>
  --    <ERROR>
  --      <MSG>错误信息</MSG>
  --    </ERROR>
  --  </OUTPUT>
  --------------------------------------------------------------------------------------------------
  n_挂号id  病人挂号记录.Id%Type;
  v_执行人  病人挂号记录.执行人%Type;
  v_诊室    病人挂号记录.诊室%Type;
  n_Cnt     Number;
  v_Tmp     Varchar2(2000);
  v_Err_Msg Varchar2(200);
  Err_Item Exception;
Begin
  Select Extractvalue(Value(A), 'IN/JZID'), Extractvalue(Value(A), 'IN/JZZS'), Extractvalue(Value(A), 'IN/JZYS')
  Into n_挂号id, v_诊室, v_执行人
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  For R In (Select a.执行状态, a.执行人, a.病人id, a.No, a.记录性质, a.记录状态, a.姓名, a.转诊状态
            From 病人挂号记录 A
            Where a.Id = n_挂号id) Loop
  
    --转诊后未接收判断 
    If r.转诊状态 = 0 Then
      v_Err_Msg := r.姓名 || '已经转诊，请取消转诊后再完成接诊。';
      Raise Err_Item;
    End If;
    
    --检查是否有医嘱询问提示，忽略  
    --疾病报告卡填写判断，忽略
    --社区信息提交，外挂部件调用，忽略
    --一卡通数据上传，忽略
  
    --并发操作检查
    If Not (r.执行人 = v_执行人 And r.执行状态 = 2 And r.记录性质 = 1 And r.记录状态 = 1) Then
      v_Err_Msg := r.姓名 || '可能被其他医生强制续诊接收，请刷新重试。';
      Raise Err_Item;
    End If;
  
    --检查未发送的医嘱
    Select Count(1)
    Into n_Cnt
    From 病人医嘱记录
    Where 挂号单 = r.No And 医嘱状态 = 1 And Nvl(执行标记, 0) <> -1 And Nvl(执行性质, 0) <> 0 And Nvl(皮试结果, '无') <> '免试';
    If n_Cnt > 0 Then
      v_Err_Msg := r.姓名 || '还有未发送的医嘱，不能完成接诊。';
      Raise Err_Item;
    End If;
    Zl_病人接诊完成(r.病人id, r.No, v_诊室, v_执行人);
  End Loop;
  Xml_Out := Xmltype('<OUTPUT><ERROR><MSG></MSG></ERROR></OUTPUT>');
Exception
  When Err_Item Then
    v_Tmp   := '<OUTPUT><ERROR><MSG>' || v_Err_Msg || '</MSG></ERROR></OUTPUT>';
    Xml_Out := Xmltype(v_Tmp);
  When Others Then
    v_Tmp   := '<OUTPUT><ERROR><MSG>错误信息：' || SQLErrM || '</MSG></ERROR></OUTPUT>';
    Xml_Out := Xmltype(v_Tmp);
End Zl_Third_Finish;
/

--109786:胡俊勇,2017-06-24,妇幼保健医生站数据接口
CREATE OR REPLACE Procedure Zl_Third_Redo
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:已经完成就诊的病人恢复接诊
  --入参:Xml_In:
  --  <IN>
  --    <JZID>1</JZID>                挂号ID
  --    <JZYS>张永康</JZYS>           接诊医生，即当前操作员
  --  </IN>
  --出参:Xml_Out
  --  <OUTPUT>
  --    <ERROR>
  --      <MSG>错误信息</MSG>
  --    </ERROR>
  --  </OUTPUT>
  --------------------------------------------------------------------------------------------------
  n_挂号id  病人挂号记录.Id%Type;
  v_执行人  病人挂号记录.执行人%Type;
  v_Tmp     Varchar2(2000);
  n_Tmp     Number;
  n_天数    Number;
  v_Err_Msg Varchar2(200);
  Err_Item Exception;
Begin
  Select Extractvalue(Value(A), 'IN/JZID'), Extractvalue(Value(A), 'IN/JZYS')
  Into n_挂号id, v_执行人
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  For R In (Select a.执行状态, a.执行人, a.病人id, a.No, a.记录性质, a.记录状态, a.姓名, a.急诊, a.登记时间
            From 病人挂号记录 A
            Where a.Id = n_挂号id) Loop
    --恢复就诊是针对完成就诊的病人
    If r.执行状态 <> 1 Then
      v_Err_Msg := r.姓名 || '还未完成就诊，不能恢复接诊。';
      Raise Err_Item;
    End If;
    --挂号单是否过期检查
    n_Tmp := To_Number(Nvl(zl_GetSysParameter(210), '0'));
    If n_Tmp = 0 Then
      v_Tmp := Nvl(zl_GetSysParameter(21), '11') || '11';
      If Nvl(r.急诊, 0) = 0 Then
        n_Tmp := To_Number(Substr(v_Tmp, 1, 1));
      Else
        n_Tmp := To_Number(Substr(v_Tmp, 2, 1));
      End If;
      If n_Tmp > 0 Then
        Select r.登记时间 - Trunc(Sysdate) Into n_天数 From Dual;
        If n_天数 > n_Tmp Then
          v_Err_Msg := '该病人挂号已超过有效天数，不允许再恢复接诊。';
          Raise Err_Item;
        End If;
      End If;
    End If;

    --数据转出检查，忽略
    --只能恢复本人完成的挂号单
    If v_执行人 <> r.执行人 Then
      v_Err_Msg := r.姓名 || '不是由你本人完成就诊的，不能直接恢复接诊。';
      Raise Err_Item;
    End If;
    Zl_病人接诊完成_Cancel(r.病人id, r.No);
  End Loop;
  Xml_Out := Xmltype('<OUTPUT><ERROR><MSG></MSG></ERROR></OUTPUT>');
Exception
  When Err_Item Then
    v_Tmp   := '<OUTPUT><ERROR><MSG>' || v_Err_Msg || '</MSG></ERROR></OUTPUT>';
    Xml_Out := Xmltype(v_Tmp);
  When Others Then
    v_Tmp   := '<OUTPUT><ERROR><MSG>错误信息：' || SQLErrM || '</MSG></ERROR></OUTPUT>';
    Xml_Out := Xmltype(v_Tmp);
End Zl_Third_Redo;
/

--109786:胡俊勇,2017-06-24,妇幼保健医生站数据接口
CREATE OR REPLACE Procedure Zl_Third_Advicesave
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:病人生成医嘱(检查检验)，一个病人调用一次
  --入参:Xml_In:
  --  <IN>
  --   <GHDH>R0000001</GHDH> 挂号单号
  --   <JZID></JZID>就诊ID，挂号ID
  --   <BRID></BRID>病人ID
  --   <YEXH></YEXH>婴儿序号，如果是病人医嘱，传0
  --   <BRKSID>21</BRKSID>  病人科室ID
  --   <CZYXM>张永康</CZYXM> 操作员姓名
  --   <CZYBH></CZYBH> 操作员编号
  --   <ZD></ZD>站点
  --   <JZD>0</JZD> 是否发送为记帐单，0-划价单，1-记帐单

  --   <YZNRLIST>  医嘱列表，可以含多个结点
  --   <YZNR> 医嘱内容
  --    <ZLLB>D</ZLLB>  诊疗类别 D-检查，C-检验
  --    <ZLXMID>123</ZLXMID>  诊疗项目ID
  --    <ZXKSID>123</ZXKSID>   执行科室ID
  --    <JJBZ>2</JJBZ>   紧急标志
  --    <KSZXSJ>2017-05-25 10:00:00</KSZXSJ> 开始执行时间
  --    <KZKSID>23</KZKSID>开嘱科室ID
  --    <KZYS>张永康</KZYS> 开嘱医生
  --    <KZSJ>2017-05-25 10:00:00</KZSJ> 开嘱时间
  ------检查相关的，非检验项目可以不传入
  --    <BWFFALL></BWFFALL>方法部位总述格式: 部位1(方法1),部位2(方法2,方法3),...  逗号为半角
  --                      如：胆囊和胆道(收缩功能检查),输卵管(超声造影),腹部的测试(膀胱余尿测定,常规)
  --    <BWLIST>        检查方法部位列表详情
  --     <BWFF>
  --     <BW>颅骨</BW>
  --     <FF>平扫</FF>
  --     </BWFF>
  --     <BWFF>
  --     ....
  --     </BWFF>
  --    </BWLIST>

  ------检验项目的采集相关内容，非检验项目可以不传入
  --    <CJXMID>12</CJXMID>      采集项目ID
  --    <CJZXKSID>12</CJZXKSID>  采集执行科室ID
  --    <CJBB>血清</CJBB>        采集标本

  --   </YZNR>
  --   </YZNRLIST>
  --  </IN>

  --出参:Xml_Out，生成的医嘱ID串，错误信息
  --  <OUTPUT>
  --    <LISAPP>C:1234,E:1235;C:3141,E:3142;..</LISAPP>检验医嘱相关,固定格式：类别:医嘱ID,类别:医嘱ID;....
  --    <YZIDS>1234,41234,64645,...</YZIDS>医嘱ID串，逗号分割
  --    <ERROR>
  --      <MSG>错误信息</MSG>
  --    </ERROR>
  --  </OUTPUT>
  --------------------------------------------------------------------------------------------------

  d_开始执行时间   病人医嘱记录.开始执行时间%Type;
  n_病人科室id     病人医嘱记录.病人科室id%Type;
  d_开嘱时间       病人医嘱记录.开嘱时间%Type;
  v_挂号单         病人医嘱记录.挂号单%Type;
  n_采集项目id     病人医嘱记录.开嘱科室id%Type;
  n_采集执行科室id 病人医嘱记录.开嘱科室id%Type;
  v_采集标本       病人医嘱记录.检查方法%Type;
  v_医嘱内容       病人医嘱记录.医嘱内容%Type;
  v_Tmp            Varchar2(32767);
  v_项目名称       诊疗项目目录.名称%Type;
  n_项目计价特性   诊疗项目目录.计价性质%Type;
  n_项目执行性质   诊疗项目目录.执行科室%Type;
  v_试管编码       诊疗项目目录.试管编码%Type;
  n_医嘱id         病人医嘱记录.Id%Type;
  n_相关id         病人医嘱记录.Id%Type;
  n_序号           病人医嘱记录.序号%Type;
  n_病人id         病人医嘱记录.病人id%Type;
  n_婴儿           病人医嘱记录.婴儿%Type;
  v_医嘱ids        Varchar2(32767);
  v_Lisapp         Varchar2(30000);
  x_Templet        Xmltype; --模板XML  
  Err_Item Exception;
Begin
  Select Extractvalue(Value(A), 'IN/GHDH'), Extractvalue(Value(A), 'IN/BRID'), Extractvalue(Value(A), 'IN/YEXH'),
         Extractvalue(Value(A), 'IN/BRKSID') As 病人科室id
  Into v_挂号单, n_病人id, n_婴儿, n_病人科室id
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  Select Nvl(Max(a.序号), 0) Into n_序号 From 病人医嘱记录 A Where a.挂号单 = v_挂号单;

  --产生医嘱，外层循环医嘱
  For R In (Select a.Column_Value As Node From Table(Xmlsequence(Extract(Xml_In, 'IN/YZNRLIST/YZNR'))) A) Loop
    For X In (Select Extractvalue(Value(A), 'YZNR/BRID') As 病人id, Extractvalue(Value(A), 'YZNR/YEXH') As 婴儿,
                     Extractvalue(Value(A), 'YZNR/ZLLB') As 诊疗类别, Extractvalue(Value(A), 'YZNR/ZLXMID') As 诊疗项目id,
                     Extractvalue(Value(A), 'YZNR/XMMC') As 项目名称, Extractvalue(Value(A), 'YZNR/JJTX') As 计价特性,
                     Extractvalue(Value(A), 'YZNR/ZXXZ') As 执行性质, Extractvalue(Value(A), 'YZNR/ZXKSID') As 执行科室id,
                     Extractvalue(Value(A), 'YZNR/JJBZ') As 紧急标志, Extractvalue(Value(A), 'YZNR/KSZXSJ') As 开始执行时间,
                     Extractvalue(Value(A), 'YZNR/BRKSID') As 病人科室id, Extractvalue(Value(A), 'YZNR/KZKSID') As 开嘱科室id,
                     Extractvalue(Value(A), 'YZNR/KZYS') As 开嘱医生, Extractvalue(Value(A), 'YZNR/KZSJ') As 开嘱时间,
                     Extractvalue(Value(A), 'YZNR/GHDH') As 挂号单, Extractvalue(Value(A), 'YZNR/CZYXM') As 操作员,
                     Extractvalue(Value(A), 'YZNR/CZYBH') As 操作员编号, Extractvalue(Value(A), 'YZNR/JZD') As 记帐,
                     Extractvalue(Value(A), 'YZNR/JZID') As 就诊id, Extractvalue(Value(A), 'YZNR/ZD') As 站点
              From Table(Xmlsequence(Extract(r.Node, 'YZNR'))) A) Loop
      d_开始执行时间 := To_Date(x.开始执行时间, 'YYYY-MM-DD HH24:MI:SS');
      d_开嘱时间     := To_Date(x.开嘱时间, 'YYYY-MM-DD HH24:MI:SS');
      If x.诊疗类别 = 'D' Then
        Select 名称, 计价性质, 执行科室
        Into v_项目名称, n_项目计价特性, n_项目执行性质
        From 诊疗项目目录
        Where ID = x.诊疗项目id;
        Select Extractvalue(Value(A), 'YZNR/BWFFALL')
        Into v_医嘱内容
        From Table(Xmlsequence(Extract(r.Node, 'YZNR'))) A;
        Select 病人医嘱记录_Id.Nextval Into n_医嘱id From Dual;
        n_相关id := n_医嘱id;
        v_Tmp    := v_项目名称;
        If v_医嘱内容 Is Not Null Then
          v_Tmp := v_Tmp || ':' || v_医嘱内容;
        End If;
        v_医嘱ids := v_医嘱ids || ',' || n_医嘱id;
        n_序号    := n_序号 + 1;
        Zl_病人医嘱记录_Insert(n_医嘱id, Null, n_序号, 1, n_病人id, Null, n_婴儿, 1, 1, x.诊疗类别, x.诊疗项目id, Null, Null, Null, 1, v_Tmp,
                         Null, Null, '一次性', Null, Null, Null, Null, n_项目计价特性, x.执行科室id, n_项目执行性质, x.紧急标志, d_开始执行时间, Null,
                         n_病人科室id, x.开嘱科室id, x.开嘱医生, d_开嘱时间, v_挂号单, Null, Null, 0, Null, Null, x.操作员);
      
        If v_医嘱内容 Is Not Null Then
          For W In (Select a.Column_Value As Node
                    From Table(Xmlsequence(Extract(Xml_In, 'IN/YZNRLIST/YZNR/BWLIST/BWFF'))) A) Loop
            For Y In (Select Extractvalue(Value(A), 'BWFF/BW') As 部位, Extractvalue(Value(A), 'BWFF/FF') As 方法
                      From Table(Xmlsequence(Extract(w.Node, 'BWFF'))) A) Loop
              Select 病人医嘱记录_Id.Nextval Into n_医嘱id From Dual;
              n_序号 := n_序号 + 1;
              Zl_病人医嘱记录_Insert(n_医嘱id, n_相关id, n_序号, 1, n_病人id, Null, n_婴儿, 1, 1, x.诊疗类别, x.诊疗项目id, Null, Null, Null, 1,
                               v_项目名称, Null, y.部位, '一次性', Null, Null, Null, Null, n_项目计价特性, x.执行科室id, n_项目执行性质, x.紧急标志,
                               d_开始执行时间, Null, n_病人科室id, x.开嘱科室id, x.开嘱医生, d_开嘱时间, v_挂号单, Null, y.方法, 0, Null, Null,
                               x.操作员);
              v_医嘱ids := v_医嘱ids || ',' || n_医嘱id;
            End Loop;
          End Loop;
        End If;
      Elsif x.诊疗类别 = 'C' Then
        Select Extractvalue(Value(A), 'YZNR/CJBB'), Extractvalue(Value(A), 'YZNR/CJXMID'),
               Extractvalue(Value(A), 'YZNR/CJZXKSID')
        Into v_采集标本, n_采集项目id, n_采集执行科室id
        From Table(Xmlsequence(Extract(r.Node, 'YZNR'))) A;
        Select 病人医嘱记录_Id.Nextval Into n_医嘱id From Dual;
        Select 病人医嘱记录_Id.Nextval Into n_相关id From Dual;
        Select 名称, 计价性质, 执行科室, 试管编码
        Into v_项目名称, n_项目计价特性, n_项目执行性质, v_试管编码
        From 诊疗项目目录
        Where ID = x.诊疗项目id;
        n_序号 := n_序号 + 1;
        Zl_病人医嘱记录_Insert(n_医嘱id, n_相关id, n_序号, 1, n_病人id, Null, n_婴儿, 1, 1, x.诊疗类别, x.诊疗项目id, Null, Null, Null, 1,
                         x.项目名称, Null, v_采集标本, '一次性', Null, Null, Null, Null, n_项目计价特性, x.执行科室id, n_项目执行性质, x.紧急标志,
                         d_开始执行时间, Null, n_病人科室id, x.开嘱科室id, x.开嘱医生, d_开嘱时间, v_挂号单, Null, Null, 0, Null, Null, x.操作员);
        v_Lisapp   := v_Lisapp || ';C:' || n_医嘱id || ',E:' || n_相关id;
        v_医嘱ids  := v_医嘱ids || ',' || n_医嘱id || ',' || n_相关id;
        v_医嘱内容 := v_项目名称 || '(' || v_采集标本 || ')';
        Select 名称, 计价性质, 执行科室
        Into v_项目名称, n_项目计价特性, n_项目执行性质
        From 诊疗项目目录
        Where ID = n_采集项目id;
        n_序号 := n_序号 + 1;
        Zl_病人医嘱记录_Insert(n_相关id, Null, n_序号, 1, n_病人id, Null, n_婴儿, 1, 1, 'E', n_采集项目id, Null, Null, Null, 1, v_医嘱内容,
                         Null, v_采集标本, '一次性', Null, Null, Null, Null, n_项目计价特性, n_采集执行科室id, n_项目执行性质, x.紧急标志, d_开始执行时间,
                         Null, n_病人科室id, x.开嘱科室id, x.开嘱医生, d_开嘱时间, v_挂号单, Null, Null, 0, Null, Null, x.操作员);
      
      End If;
    End Loop;
  End Loop;
  x_Templet := Xmltype('<OUTPUT><YZIDS>' || Substr(v_医嘱ids, 2) || '</YZIDS><LISAPP>' || Substr(v_Lisapp, 2) ||
                       '</LISAPP></OUTPUT>');
  Xml_Out   := x_Templet;
Exception
  When Others Then
    v_Tmp   := '<OUTPUT><ERROR><MSG>错误信息：' || SQLErrM || '</MSG></ERROR></OUTPUT>';
    Xml_Out := Xmltype(v_Tmp);
End Zl_Third_Advicesave;
/

--109786:胡俊勇,2017-06-24,妇幼保健医生站数据接口
CREATE OR REPLACE Procedure Zl_Third_Advicesend
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:门诊发送检查检验医嘱，诊疗项目对应的费用只是非药和不跟踪在用卫材，检验医嘱不能是一并采集
  --     外挂接口，医保接口，记帐报警，电子签名等功能失效。
  --入参:Xml_In:
  --  <IN>
  --  <BRID></BRID>病人ID
  --  <JZID></JZID>就诊ID，挂号ID
  --  <CZYXM></CZYXM> 操作员姓名
  --  <CZYBH></CZYBH> 操作员编号
  --  <ZD></ZD>站点
  --  <YZIDS>1</YZIDS>要发送的医嘱ID串，逗号分割
  --  <JZD>0</JZD> 是否发送为记帐单，0-划价单，1-记帐单
  --  <JBJJ></JBJJ>加班加价 由外部传入决定
  --  </IN>

  --出参:Xml_Out 
  --  <OUTPUT>
  --    <ERROR>
  --      <MSG>错误信息</MSG>
  --    </ERROR>
  --  </OUTPUT>
  --------------------------------------------------------------------------------------------------
  --病人信息相关
  Cursor c_Pati(就诊id_In 病人挂号记录.Id%Type) Is
    Select b.病人id, Nvl(b.姓名, a.姓名) As 姓名, Nvl(b.性别, a.性别) As 性别, Nvl(b.年龄, a.年龄) As 年龄, a.门诊号, a.费别
    From 病人信息 A, 病人挂号记录 B
    Where a.病人id = b.病人id And b.Id = 就诊id_In;
  r_Pati c_Pati%RowType;

  --医嘱记录集
  Cursor c_Advice(医嘱ids_In Varchar2) Is
    Select a.病人id, a.Id, a.相关id, Nvl(a.相关id, a.Id) As 组id, Nvl(x.序号, a.序号) As 组号, a.诊疗类别, f.名称 As 类别名称, a.诊疗项目id,
           b.名称 As 诊疗项目, a.收费细目id, c.规格, a.婴儿, a.医嘱内容, a.标本部位, a.检查方法, a.执行标记, a.天数, a.总给予量, d.门诊单位, a.单次用量,
           Decode(a.诊疗类别, '4', c.计算单位, b.计算单位) As 计算单位, d.剂量系数, d.门诊包装, a.开始执行时间, a.执行频次, a.频率次数, a.频率间隔, a.间隔单位, a.医生嘱托,
           a.执行时间方案, a.病人科室id, a.开嘱科室id, a.开嘱医生, a.计价特性, a.执行性质, a.执行科室id,
           Nvl(e.名称, Decode(Nvl(a.执行性质, 0), 5, '-')) As 执行科室, d.门诊可否分零 As 可否分零,
           Decode(a.诊疗类别, '4', g.在用分批, d.药房分批) As 分批, c.是否变价, g.跟踪在用, c.撤档时间, c.服务对象, a.前提id, a.新开签名id As 签名id, b.试管编码,
           b.操作类型, b.执行分类, a.摘要, a.紧急标志, a.零费记帐, b.计算方式, b.执行安排, h.毒理分类
    From 病人医嘱记录 A, 诊疗项目目录 B, 收费项目目录 C, 药品规格 D, 部门表 E, 诊疗项目类别 F, 材料特性 G, 药品特性 H, 病人医嘱记录 X
    Where a.相关id = x.Id(+) And b.类别 = f.编码 And a.诊疗项目id = b.Id And a.收费细目id = c.Id(+) And a.收费细目id = d.药品id(+) And
          a.收费细目id = g.材料id(+) And a.执行科室id = e.Id(+) And Not (a.诊疗类别 = 'H' And b.操作类型 = '1') And Nvl(a.执行标记, 0) <> -1 And
          b.Id = h.药名id(+) And Nvl(a.审核状态, 0) Not In (1, 3, 4, 5) And Nvl(a.皮试结果, '无') <> '免试' And a.开始执行时间 Is Not Null And
          a.病人来源 <> 3 And a.医嘱状态 = 1 And
          a.Id In (Select /*+cardinality(x,10)*/
                    x.Column_Value
                   From Table(f_Num2list(医嘱ids_In)) X)
    Order By a.婴儿, 组号, 组id, a.序号;
  r_Advice c_Advice%RowType;

  --当前行的医嘱计价
  Cursor c_Adviceprice(Xp_In Xmltype) Is
    Select b.医嘱id, b.相关id, b.费用性质, b.收费方式, b.类别, b.收费细目id, b.执行科室id, b.数量, b.单价, b.在用, b.变价, b.从项, b.固定, b.收入项目id,
           b.计算单位, b.收据费目, b.费用确认, b.收费细目id As ID, b.加班加价率, b.加班加价, b.附术收费率, b.屏蔽费别,
           --临时变量
           0 As 是否收费, 1 As 付数, b.数量 As 费用数量, b.单价 As 应收, b.单价 As 实收, b.收费细目id As 父序号, b.收据费目 As 费别, b.收据费目 As NO,
           b.收费细目id As 费用序号
    From (Select Xp_In As Datas From Dual) A,
         Xmltable('//DATA/PRICE/ROW' Passing a.Datas Columns 医嘱id Number(18) Path 'YZID', 相关id Number(18) Path 'XGID',
                   费用性质 Number(1) Path 'FYXZ', 收费方式 Number(1) Path 'SFFS', 类别 Varchar2(1) Path 'SFLB',
                   收费细目id Number(18) Path 'SFXMID', 执行科室id Number(18) Path 'ZXKSID', 数量 Number(16, 5) Path 'SL',
                   单价 Number(16, 5) Path 'DJ', 在用 Number(1) Path 'ZY', 变价 Number(1) Path 'BJ', 从项 Number(1) Path 'CX',
                   固定 Number(1) Path 'GD', 收入项目id Number(18) Path 'SRXMID', 计算单位 Varchar2(100) Path 'JSDW',
                   收据费目 Varchar2(100) Path 'SJFM', 费用确认 Number(1) Path 'FYQR', 加班加价率 Number(16, 5) Path 'JBJJL',
                   加班加价 Number(1) Path 'JBJJ', 附术收费率 Number(16, 5) Path 'FSSFL', 屏蔽费别 Number(1) Path 'FBPB') B
    Order By b.收费细目id, b.从项;

  Type t_Adviceprice Is Table Of c_Adviceprice%RowType;
  r_Ap t_Adviceprice;

  v_医嘱ids    Varchar2(30000);
  n_折扣       Number; --系统参数:从属项目汇总计算折扣
  n_单价小数   Number; --参数小数位 
  n_条码生成   Number;
  n_病人id     病人医嘱记录.病人id%Type;
  n_就诊id     病人挂号记录.Id%Type;
  n_接诊科室id 部门表.Id%Type;
  v_动态费别   Varchar2(32767);
  v_Tmp        Varchar2(32767);
  n_发送号     病人医嘱发送.发送号%Type;
  d_Cur        Date;
  d_Tmp        Date;
  v_Nokey      Varchar2(100);
  v_站点       部门表.站点%Type;
  n_记帐       Number(1); --0-划价单，1-记帐单  
  n_划价       Number(1);
  v_划价单     Varchar2(300); --系统参数，86号
  v_试管编码   诊疗项目目录.试管编码%Type;
  n_材料id     病人医嘱记录.Id%Type;
  n_采集科室id 病人医嘱记录.Id%Type;
  v_条码       Varchar2(30);

  n_Tmp    Number;
  x_Price  Xmltype;
  x_Exec   Xmltype; --医嘱执行计价
  x_Number Xmltype; --采集管码相关
  x_Money  Xmltype; --收费相关
  x_Bill   Xmltype; --费用NO号相关 
  x_t      Xmltype; --结果

  n_费用次数  Number(1);
  n_Makemoney Number(1);

  n_付数     Number(3);
  n_数量     Number(16, 5);
  n_单价     Number(16, 5);
  n_应收     Number(16, 5);
  n_实收     Number(16, 5);
  n_Idx父项  Number(18);
  n_从项合计 Number(16, 5);

  v_No         病人医嘱记录.挂号单%Type;
  n_费用序号   Number(3);
  n_父序号     Number(3);
  n_发送序号   Number(3);
  v_费别       Varchar2(3000);
  v_操作员姓名 人员表.姓名%Type;
  v_操作员编号 人员表.编号%Type;
  n_加班加价   Number;
  n_Dec        Number; --金额小数位数 
  Err_Item Exception;

  --获取某条指定医嘱的计价信息（与VB中有区别，VB中可以动态添加计价项，此处就固定读取一次）
  Procedure Getadviceprice
  (
    x_In  In Xmltype,
    x_Out Out Xmltype
  ) Is
    Cursor c_Price
    (
      Cp项目id     部门表.Id%Type,
      Cp执行科室id 部门表.Id%Type,
      Cp部位       Varchar2,
      Cp方法       Varchar2,
      Cp材料id     部门表.Id%Type,
      Cp关系       Number,
      Cp站点       部门表.站点%Type
    ) Is
      Select c.Id, c.类别, a.收费项目id, a.收费数量, a.固有对照, b.收入项目id, c.加班加价, b.加班加价率, Decode(c.是否变价, 1, b.缺省价格, b.现价) As 单价,
             c.是否变价, Nvl(a.从属项目, 0) As 从项, d.跟踪在用, Cp执行科室id As 执行科室id, c.屏蔽费别, Nvl(a.费用性质, 0) As 费用性质,
             Nvl(a.收费方式, 0) As 收费方式, c.费用确认, c.计算单位, f.收据费目, b.附术收费率
      From (Select *
             From (Select c.诊疗项目id, c.收费项目id, c.检查部位, c.检查方法, c.费用性质, c.收费数量, c.固有对照, c.从属项目, c.收费方式, c.适用科室id,
                           Max(Nvl(c.适用科室id, 0)) Over(Partition By c.诊疗项目id, c.检查部位, c.检查方法, c.费用性质) As Top
                    From 诊疗收费关系 C
                    Where c.诊疗项目id = Cp项目id And
                          (0 = Cp关系 And c.检查部位 = Cp部位 And c.检查方法 = Cp方法 And Nvl(c.费用性质, 0) = 0 Or
                          1 = Cp关系 And c.检查部位 Is Null And c.检查方法 Is Null And Nvl(c.费用性质, 0) = 0 Or
                          2 = Cp关系 And c.检查部位 Is Null And c.检查方法 Is Null And Nvl(c.费用性质, 0) In (0, 1)) And
                          (c.适用科室id Is Null And c.病人来源 = 0 Or c.适用科室id = Cp执行科室id And c.病人来源 = 1))
             Where Nvl(适用科室id, 0) = Top) A, 收费价目 B, 收费项目目录 C, 材料特性 D, 药品规格 E, 收入项目 F
      Where a.收费项目id = b.收费细目id And a.收费项目id = c.Id And a.收费项目id = d.材料id(+) And c.服务对象 In (1, 3) And c.Id = e.药品id(+) And
            b.收入项目id = f.Id And (c.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or c.撤档时间 Is Null) And
            (c.站点 = Cp站点 Or c.站点 Is Null) And
            ((Sysdate Between b.执行日期 And b.终止日期) Or (Sysdate >= b.执行日期 And b.终止日期 Is Null)) And
            (Nvl(a.收费方式, 0) = 1 And c.类别 = '4' And a.收费项目id = Cp材料id Or
            Not (Nvl(a.收费方式, 0) = 1 And c.类别 = '4' And Cp材料id <> 0))
      Order By 费用性质, 从项, a.收费项目id;
  
    r_Price c_Price%RowType;
  
    n_p_材料id Number(18);
    n_p_关系   Number(1);
    v_p_Tmp    Varchar2(2000);
  
  Begin
    For P In (Select Extractvalue(Value(A), 'DATA/PARIN/DJXS') As 单价小数, Extractvalue(Value(A), 'DATA/PARIN/ZD') As 站点,
                     Extractvalue(Value(A), 'DATA/PARIN/YZID') As 医嘱id, Extractvalue(Value(A), 'DATA/PARIN/XGID') As 相关id,
                     Extractvalue(Value(A), 'DATA/PARIN/ZLLB') As 诊疗类别,
                     Extractvalue(Value(A), 'DATA/PARIN/ZLXMID') As 诊疗项目id,
                     Extractvalue(Value(A), 'DATA/PARIN/ZXKSID') As 执行科室id,
                     Extractvalue(Value(A), 'DATA/PARIN/SGBM') As 试管编码, Extractvalue(Value(A), 'DATA/PARIN/JCBW') As 检查部位,
                     Extractvalue(Value(A), 'DATA/PARIN/JCFF') As 检查方法
              From Table(Xmlsequence(Extract(x_In, 'DATA'))) A) Loop
      x_Out := Xmltype('<DATA><PRICE></PRICE></DATA>');
    
      If p.检查部位 Is Not Null And p.检查方法 Is Not Null Then
        n_p_关系 := 0;
      Else
        n_p_关系 := 1;
      End If;
      Open c_Price(p.诊疗项目id, p.执行科室id, p.检查部位, p.检查方法, n_p_材料id, n_p_关系, p.站点);
      Loop
        Fetch c_Price
          Into r_Price;
        Exit When c_Price%NotFound;
        v_p_Tmp := '<ROW><YZID>' || p.医嘱id || '</YZID>'; --医嘱ID
        v_p_Tmp := v_p_Tmp || '<XGID>' || p.相关id || '</XGID>'; --相关ID
        v_p_Tmp := v_p_Tmp || '<FYXZ>' || Nvl(r_Price.费用性质, 0) || '</FYXZ>'; --费用性质
        v_p_Tmp := v_p_Tmp || '<SFFS>' || Nvl(r_Price.收费方式, 0) || '</SFFS>'; --收费方式
        v_p_Tmp := v_p_Tmp || '<SFLB>' || Nvl(r_Price.类别, 0) || '</SFLB>'; --收费类别
        v_p_Tmp := v_p_Tmp || '<SFXMID>' || Nvl(r_Price.收费项目id, 0) || '</SFXMID>'; --收费细目ID
        v_p_Tmp := v_p_Tmp || '<SL>' || Nvl(r_Price.收费数量, 0) || '</SL>'; --数量
        v_p_Tmp := v_p_Tmp || '<ZY>0</ZY>'; --在用
        v_p_Tmp := v_p_Tmp || '<BJ>0</BJ>'; --变价
        v_p_Tmp := v_p_Tmp || '<SRXMID>' || r_Price.收入项目id || '</SRXMID>'; --收入项目ID
        v_p_Tmp := v_p_Tmp || '<JSDW>' || r_Price.计算单位 || '</JSDW>'; --计算单位
        v_p_Tmp := v_p_Tmp || '<SJFM>' || r_Price.收据费目 || '</SJFM>'; --收据费目
        v_p_Tmp := v_p_Tmp || '<FYQR>' || r_Price.费用确认 || '</FYQR>'; --费用确认
        v_p_Tmp := v_p_Tmp || '<GD>' || Nvl(r_Price.固有对照, 0) || '</GD>'; --固定
        v_p_Tmp := v_p_Tmp || '<CX>' || Nvl(r_Price.从项, 0) || '</CX>'; --从项
        v_p_Tmp := v_p_Tmp || '<JBJJL>' || Nvl(r_Price.加班加价率, 0) || '</JBJJL>'; --加班加价率
        v_p_Tmp := v_p_Tmp || '<JBJJ>' || Nvl(r_Price.加班加价, 0) || '</JBJJ>'; --加班加价
        v_p_Tmp := v_p_Tmp || '<FSSFL>' || Nvl(r_Price.附术收费率, 0) || '</FSSFL>'; --附术收费率
        v_p_Tmp := v_p_Tmp || '<FBPB>' || Nvl(r_Price.屏蔽费别, 0) || '</FBPB>'; --屏蔽费别
        v_p_Tmp := v_p_Tmp || '<ZXKSID>' || Nvl(r_Price.执行科室id, 0) || '</ZXKSID>'; --执行科室ID
        v_p_Tmp := v_p_Tmp || '<DJ>' || Round(Nvl(r_Price.单价, 0), p.单价小数) || '</DJ></ROW>'; --单价
        Select Appendchildxml(x_Out, '/DATA/PRICE', Xmltype(v_p_Tmp)) Into x_Out From Dual;
      End Loop;
    End Loop;
  End Getadviceprice;

  --获取样本条码
  Procedure Getcuvettenumber
  (
    x_In  In Xmltype,
    x_Out Out Xmltype
  ) Is
    --只有检验行才会执行此方法
    Cursor c_Number(Xmlin Xmltype) Is
      Select b.管码, b.相关id, b.样本条码, b.诊疗项目id, b.执行科室id, b.婴儿, b.紧急, b.标本, b.采集科室id
      From (Select Xmlin As Datas From Dual) A,
           Xmltable('//YBNUMBER/ROW' Passing a.Datas Columns 管码 Varchar2(200) Path 'GM', 相关id Number(18) Path 'XGID',
                     样本条码 Varchar2(200) Path 'YBTM', 诊疗项目id Number(18) Path 'ZLXMID', 执行科室id Number(18) Path 'ZXKSID',
                     婴儿 Number(18) Path 'YE', 紧急 Number(1) Path 'JJ', 标本 Varchar2(200) Path 'BB',
                     采集科室id Number(18) Path 'CJKSID') B;
    Type t_Number Is Table Of c_Number%RowType;
    r_Number t_Number;
  
    x_p_Tmp  Xmltype;
    v_p_条码 Varchar2(300);
    v_p_管码 Varchar2(300);
    n_p_Tmp  Number(1);
  Begin
    x_Out := x_In;
    Select Deletexml(x_Out, '//PARIN') Into x_Out From Dual;
    Select a.Column_Value Into x_p_Tmp From Table(Xmlsequence(Extract(x_In, 'DATA/YBNUMBER'))) A;
    Open c_Number(x_p_Tmp);
    Fetch c_Number Bulk Collect
      Into r_Number;
    Close c_Number;
  
    For P In (Select Extractvalue(Value(A), 'DATA/PARIN/GM') As 管码, Extractvalue(Value(A), 'DATA/PARIN/YZID') As 医嘱id,
                     Extractvalue(Value(A), 'DATA/PARIN/XGID') As 相关id,
                     Extractvalue(Value(A), 'DATA/PARIN/ZXKSID') As 执行科室id, Extractvalue(Value(A), 'DATA/PARIN/YE') As 婴儿,
                     Extractvalue(Value(A), 'DATA/PARIN/ZLXMID') As 诊疗项目id, Extractvalue(Value(A), 'DATA/PARIN/JJ') As 紧急,
                     Extractvalue(Value(A), 'DATA/PARIN/BB') As 标本, Extractvalue(Value(A), 'DATA/PARIN/CJKSID') As 采集科室id
              From Table(Xmlsequence(Extract(x_In, 'DATA'))) A) Loop
      n_p_Tmp := 0;
      If r_Number.Count > 0 Then
        --相关ID过滤
        For J In 1 .. r_Number.Count Loop
          --该过滤主要是用于一并采集
          If r_Number(J).相关id = p.相关id Then
            v_p_管码 := r_Number(J).管码;
            v_p_条码 := r_Number(J).样本条码;
            Select Appendchildxml(x_Out, '/DATA/YBNUMBER',
                                   Xmltype('<ROW><GM>' || v_p_管码 || '</GM><XGID>' || p.相关id || '</XGID><YBTM>' || v_p_条码 ||
                                            '</YBTM><ZLXMID>' || p.诊疗项目id || '</ZLXMID><ZXKSID>' || p.执行科室id ||
                                            '</ZXKSID><YE>' || p.婴儿 || '</YE><JJ>' || p.紧急 || '</JJ><BB>' || p.标本 ||
                                            '</BB><CJKSID>' || p.采集科室id || '</CJKSID></ROW>'))
            Into x_Out
            From Dual;
            Select Appendchildxml(x_Out, '/DATA', Xmltype('<PAROUT><TM>' || v_p_条码 || '</TM></PAROUT>'))
            Into x_Out
            From Dual;
            n_p_Tmp := 1;
            Exit;
          End If;
        End Loop;
      
        If n_p_Tmp = 0 Then
          --诊疗项目ID过滤
          For J In 1 .. r_Number.Count Loop
            If r_Number(J).诊疗项目id = p.诊疗项目id Then
              Select Nextno(125, p.医嘱id, p.诊疗项目id, 1) Into v_p_条码 From Dual;
              Select Appendchildxml(x_Out, '/DATA/YBNUMBER',
                                     Xmltype('<ROW><GM>' || p.管码 || '</GM><XGID>' || p.相关id || '</XGID><YBTM>' || v_p_条码 ||
                                              '</YBTM><ZLXMID>' || p.诊疗项目id || '</ZLXMID><ZXKSID>' || p.执行科室id ||
                                              '</ZXKSID><YE>' || p.婴儿 || '</YE><JJ>' || p.紧急 || '</JJ><BB>' || p.标本 ||
                                              '</BB><CJKSID>' || p.采集科室id || '</CJKSID></ROW>'))
              Into x_Out
              From Dual;
              Select Appendchildxml(x_Out, '/DATA', Xmltype('<PAROUT><TM>' || v_p_条码 || '</TM></PAROUT>'))
              Into x_Out
              From Dual;
              n_p_Tmp := 1;
              Exit;
            End If;
          End Loop;
        End If;
      
        If n_p_Tmp = 0 Then
          --其它过滤
          For J In 1 .. r_Number.Count Loop
            If r_Number(J).管码 = p.管码 And r_Number(J).执行科室id = p.执行科室id And r_Number(J).婴儿 = p.婴儿 And r_Number(J)
               .紧急 = p.紧急 And r_Number(J).标本 = p.标本 And r_Number(J).采集科室id = p.采集科室id Then
              v_p_管码 := r_Number(J).管码;
              v_p_条码 := r_Number(J).样本条码;
              Select Appendchildxml(x_Out, '/DATA/YBNUMBER',
                                     Xmltype('<ROW><GM>' || v_p_管码 || '</GM><XGID>' || p.相关id || '</XGID><YBTM>' ||
                                              v_p_条码 || '</YBTM><ZLXMID>' || p.诊疗项目id || '</ZLXMID><ZXKSID>' || p.执行科室id ||
                                              '</ZXKSID><YE>' || p.婴儿 || '</YE><JJ>' || p.紧急 || '</JJ><BB>' || p.标本 ||
                                              '</BB><CJKSID>' || p.采集科室id || '</CJKSID></ROW>'))
              Into x_Out
              From Dual;
              Select Appendchildxml(x_Out, '/DATA', Xmltype('<PAROUT><TM>' || v_p_条码 || '</TM></PAROUT>'))
              Into x_Out
              From Dual;
              n_p_Tmp := 1;
              Exit;
            End If;
          End Loop;
        End If;
      End If;
    
      If n_p_Tmp = 0 Then
        Select Nextno(125, p.医嘱id, p.诊疗项目id, 1) Into v_p_条码 From Dual;
        Select Appendchildxml(x_Out, '/DATA/YBNUMBER',
                               Xmltype('<ROW><GM>' || p.管码 || '</GM><XGID>' || p.相关id || '</XGID><YBTM>' || v_p_条码 ||
                                        '</YBTM><ZLXMID>' || p.诊疗项目id || '</ZLXMID><ZXKSID>' || p.执行科室id ||
                                        '</ZXKSID><YE>' || p.婴儿 || '</YE><JJ>' || p.紧急 || '</JJ><BB>' || p.标本 ||
                                        '</BB><CJKSID>' || p.采集科室id || '</CJKSID></ROW>'))
        Into x_Out
        From Dual;
        Select Appendchildxml(x_Out, '/DATA', Xmltype('<PAROUT><TM>' || v_p_条码 || '</TM></PAROUT>'))
        Into x_Out
        From Dual;
      End If;
    End Loop;
  
  End Getcuvettenumber;

  --适用门诊医嘱的费用
  Procedure Getpatidaymoneydetail
  (
    x_In  In Xmltype,
    x_Out Out Xmltype
  ) Is
    Cursor c_Oldfee
    (
      P病人id_In   病案主页.病人id%Type,
      P主页id_In   病案主页.主页id%Type,
      P收费时间_In 病案主页.入院日期%Type
    ) Is
      Select a.诊疗项目id, c.收费细目id As 收费项目id, c.执行部门id, Decode(Nvl(c.执行状态, 0), 0, 0, 1) As 执行否,
             To_Char(b.首次时间, 'yyyy-mm-dd') As 首次时间, Trunc(b.末次时间) - Trunc(b.首次时间) + 1 As 天数, 0 As 收费方式,
             To_Char(b.末次时间, 'yyyy-mm-dd') As 末次时间, a.频率间隔, a.间隔单位, a.医嘱期效, a.Id, Nvl(a.相关id, 0) As 相关id
      From 病人医嘱记录 A, 病人医嘱发送 B, 门诊费用记录 C
      Where a.病人id = P病人id_In And Nvl(a.主页id, 0) = P主页id_In And a.医嘱期效 = 1 And a.Id = b.医嘱id And b.记录性质 = c.记录性质 And
            b.No = c.No And b.医嘱id = c.医嘱序号 And c.记录状态 In (0, 1) And b.末次时间 >= P收费时间_In
      Union
      Select a.诊疗项目id, d.收费细目id, d.执行科室id As 执行部门id, 0 As 执行否, To_Char(b.首次时间, 'yyyy-mm-dd') As 首次时间,
             Trunc(b.末次时间) - Trunc(b.首次时间) + 1 As 天数, -1 As 收费方式, To_Char(b.末次时间, 'yyyy-mm-dd') As 末次时间, a.频率间隔, a.间隔单位,
             a.医嘱期效, a.Id, Nvl(a.相关id, 0) As 相关id
      From 病人医嘱记录 A, 病人医嘱发送 B, 病人医嘱计价 D
      Where a.病人id = P病人id_In And Nvl(a.主页id, 0) = P主页id_In And a.医嘱期效 = 1 And a.Id = b.医嘱id And b.末次时间 >= P收费时间_In And
            a.Id = d.医嘱id And d.收费方式 = 7 And Not Exists
       (Select 1
             From 门诊费用记录 C
             Where c.收费细目id = d.收费细目id And b.记录性质 = c.记录性质 And b.No = c.No And a.Id = c.医嘱序号)
      Order By 诊疗项目id, 收费项目id;
    Type t_Oldfee Is Table Of c_Oldfee%RowType;
    r_Of t_Oldfee;
  
    d_p_Tmp Date;
    v_p_Cur Varchar2(16);
    v_p_Tmp Varchar2(30000);
    v_p_All Varchar2(30000);
  Begin
    v_p_All := '<MONEYDAY>';
    For P In (Select Extractvalue(Value(A), 'DATA/PARIN/BRID') As 病人id, Extractvalue(Value(A), 'DATA/PARIN/ZYID') As 主页id,
                     Extractvalue(Value(A), 'DATA/PARIN/SFSJ') As 时间
              From Table(Xmlsequence(Extract(x_In, 'DATA'))) A) Loop
      d_p_Tmp := To_Date(p.时间, 'yyyy-mm-dd');
      Open c_Oldfee(p.病人id, p.主页id, d_p_Tmp);
      Fetch c_Oldfee Bulk Collect
        Into r_Of;
      Close c_Oldfee;
      For I In 1 .. r_Of.Count Loop
        If Nvl(r_Of(I).频率间隔, 0) = 1 And r_Of(I).间隔单位 = '天' Or r_Of(I).间隔单位 = '小时' Or r_Of(I).间隔单位 = '分钟' Then
          For J In 1 .. r_Of(I).天数 Loop
            If J = 1 Then
              d_p_Tmp := To_Date(r_Of(I).首次时间, 'yyyy-mm-dd');
            Else
              d_p_Tmp := d_p_Tmp + 1;
            End If;
            v_p_Cur := To_Char(d_p_Tmp, 'yyyy-mm-dd');
            If v_p_Cur >= p.时间 Then
              v_p_Tmp := '<ROW><ZLXMID>' || Nvl(r_Of(I).诊疗项目id, 0) || '</ZLXMID><SFXMID>' || Nvl(r_Of(I).收费项目id, 0) ||
                         '</SFXMID><ZXF>' || Nvl(r_Of(I).执行否, 0) || '</ZXF><SFFS>' || Nvl(r_Of(I).收费方式, 0) ||
                         '</SFFS><SFSJ>' || v_p_Cur || '</SFSJ>';
              If Instr(v_p_All, v_p_Tmp) = 0 Then
                v_p_All := v_p_All || v_p_Tmp || '<ZXBMID>' || Nvl(r_Of(I).执行部门id, 0) || '</ZXBMID></ROW>';
              End If;
            End If;
          End Loop;
        Else
          v_p_Cur := r_Of(I).首次时间;
          If v_p_Cur >= p.时间 Then
            v_p_Tmp := '<ROW><ZLXMID>' || Nvl(r_Of(I).诊疗项目id, 0) || '</ZLXMID><SFXMID>' || Nvl(r_Of(I).收费项目id, 0) ||
                       '</SFXMID><ZXF>' || Nvl(r_Of(I).执行否, 0) || '</ZXF><SFFS>' || Nvl(r_Of(I).收费方式, 0) ||
                       '</SFFS><SFSJ>' || v_p_Cur || '</SFSJ>';
            If Instr(v_p_All, v_p_Tmp) = 0 Then
              v_p_All := v_p_All || v_p_Tmp || '<ZXBMID>' || Nvl(r_Of(I).执行部门id, 0) || '</ZXBMID></ROW>';
            End If;
          End If;
          v_p_Cur := r_Of(I).末次时间;
          If v_p_Cur >= p.时间 Then
            v_p_Tmp := '<ROW><ZLXMID>' || Nvl(r_Of(I).诊疗项目id, 0) || '</ZLXMID><SFXMID>' || Nvl(r_Of(I).收费项目id, 0) ||
                       '</SFXMID><ZXF>' || Nvl(r_Of(I).执行否, 0) || '</ZXF><SFFS>' || Nvl(r_Of(I).收费方式, 0) ||
                       '</SFFS><SFSJ>' || v_p_Cur || '</SFSJ>';
            If Instr(v_p_All, v_p_Tmp) = 0 Then
              v_p_All := v_p_All || v_p_Tmp || '<ZXBMID>' || Nvl(r_Of(I).执行部门id, 0) || '</ZXBMID></ROW>';
            End If;
          End If;
        End If;
      End Loop;
    End Loop;
    x_Out := Xmltype(v_p_All || '<SFHQ>1</SFHQ></MONEYDAY>');
  End Getpatidaymoneydetail;

  Procedure Advicemoneymake
  (
    x_In  In Xmltype,
    x_Out Out Xmltype
  ) Is
    Cursor c_Moneynow(Xmlin Xmltype) Is
      Select b.医嘱id, b.诊疗项目id, b.收费项目id, b.试管编码, b.样本条码, b.收费方式, b.收费时间, b.执行部门id
      From (Select Xmlin As Datas From Dual) A,
           Xmltable('//MONEYNOW/ROW' Passing a.Datas Columns 医嘱id Number(18) Path 'YZID',
                     诊疗项目id Number(18) Path 'ZLXMID', 收费项目id Number(18) Path 'SFXMID', 试管编码 Varchar2(200) Path 'SGBM',
                     样本条码 Varchar2(200) Path 'YBTM', 收费方式 Number(1) Path 'SFFS', 收费时间 Varchar2(20) Path 'SFSJ',
                     执行部门id Number(18) Path 'ZXBMID') B;
    Type t_Moneynow Is Table Of c_Moneynow%RowType;
    r_Moneynow t_Moneynow;
  
    Cursor c_Moneyday(Xmlin Xmltype) Is
      Select b.诊疗项目id, b.收费项目id, b.执行部门id, b.收费方式, b.执行否, b.收费时间
      From (Select Xmlin As Datas From Dual) A,
           Xmltable('//MONEYDAY/ROW' Passing a.Datas Columns 诊疗项目id Number(18) Path 'ZLXMID',
                     收费项目id Number(18) Path 'SFXMID', 执行部门id Number(18) Path 'ZXBMID', 收费方式 Number(1) Path 'SFFS',
                     执行否 Number(1) Path 'ZXF', 收费时间 Varchar2(20) Path 'SFSJ') B;
    Type t_Moneyday Is Table Of c_Moneyday%RowType;
    r_Moneyday t_Moneyday;
  
    Cursor c_Exec(Xmlin Xmltype) Is
      Select b.医嘱id, b.发送号, b.收费项目id, b.要求时间, b.数量, b.费用性质
      From (Select Xmlin As Datas From Dual) A,
           Xmltable('//EXEC/ROW' Passing a.Datas Columns 医嘱id Number(18) Path 'YZID', 发送号 Number(18) Path 'FSH',
                     收费项目id Number(18) Path 'SFXMID', 要求时间 Varchar2(20) Path 'YQSJ', 数量 Number(16, 5) Path 'SL',
                     费用性质 Number(1) Path 'FYXZ') B;
    Type t_Exec Is Table Of c_Exec%RowType;
    r_Exec t_Exec;
  
    x_p_Moneynow  Xmltype;
    x_p_Moneyday  Xmltype;
    x_p_Exec      Xmltype;
    x_p_In        Xmltype;
    n_p_费用次数  Number(1);
    n_p_Makemoney Number(1);
    v_p_Tmp       Varchar2(3000);
    n_p_Tmp       Number(16, 5);
    n_p_材料id    Number(18);
    n_p_获取历史  Number(1);
  
    Type t_p_Record Is Record(
      收费时间 Varchar2(10),
      存在     Number);
    Type t_p_Table Is Table Of t_p_Record;
    t_d t_p_Table := t_p_Table();
  
  Begin
    n_p_Makemoney := 1;
    n_p_费用次数  := 1;
  
    x_Out := x_In;
    Select Deletexml(x_Out, '//PARIN') Into x_Out From Dual;
  
    Select a.Column_Value Into x_p_Moneynow From Table(Xmlsequence(Extract(x_In, 'DATA/MONEYNOW'))) A;
    Select a.Column_Value Into x_p_Moneyday From Table(Xmlsequence(Extract(x_In, 'DATA/MONEYDAY'))) A;
    Select a.Column_Value Into x_p_Exec From Table(Xmlsequence(Extract(x_In, 'DATA/EXEC'))) A;
  
    Open c_Moneynow(x_p_Moneynow);
    Fetch c_Moneynow Bulk Collect
      Into r_Moneynow;
    Close c_Moneynow;
  
    Open c_Moneyday(x_p_Moneyday);
    Fetch c_Moneyday Bulk Collect
      Into r_Moneyday;
    Close c_Moneyday;
  
    Open c_Exec(x_p_Exec);
    Fetch c_Exec Bulk Collect
      Into r_Exec;
    Close c_Exec;
  
    For P In (Select Extractvalue(Value(A), 'DATA/PARIN/BRID') As 病人id, Extractvalue(Value(A), 'DATA/PARIN/ZYID') As 主页id,
                     Extractvalue(Value(A), 'DATA/PARIN/YZID') As 医嘱id,
                     Extractvalue(Value(A), 'DATA/PARIN/ZLXMID') As 诊疗项目id,
                     Extractvalue(Value(A), 'DATA/PARIN/SFXMID') As 收费项目id,
                     Extractvalue(Value(A), 'DATA/PARIN/ZXBMID') As 执行部门id,
                     Extractvalue(Value(A), 'DATA/PARIN/SGBM') As 试管编码, Extractvalue(Value(A), 'DATA/PARIN/SFLB') As 收费类别,
                     Extractvalue(Value(A), 'DATA/PARIN/SFFS') As 收费方式, Extractvalue(Value(A), 'DATA/PARIN/FJSJ') As 分解时间,
                     Extractvalue(Value(A), 'DATA/PARIN/LY') As 来源, Extractvalue(Value(A), 'DATA/PARIN/FYCS') As 费用次数,
                     Extractvalue(Value(A), 'DATA/PARIN/ZL') As 总量, Extractvalue(Value(A), 'DATA/PARIN/DQYZID') As 当前医嘱id,
                     Extractvalue(Value(A), 'DATA/PARIN/FSH') As 发送号, Extractvalue(Value(A), 'DATA/PARIN/JJSL') As 计价数量,
                     Extractvalue(Value(A), 'DATA/PARIN/JSFS') As 计算方式, Extractvalue(Value(A), 'DATA/PARIN/PL') As 频率,
                     Extractvalue(Value(A), 'DATA/PARIN/DL') As 单量, Extractvalue(Value(A), 'DATA/PARIN/QX') As 期效,
                     Extractvalue(Value(A), 'DATA/PARIN/FYXZ') As 费用性质, Extractvalue(Value(A), 'DATA/PARIN/ZLLB') As 诊疗类别,
                     Extractvalue(Value(A), 'DATA/PARIN/YBTM') As 样本条码,
                     Extractvalue(Value(A), 'DATA/MONEYDAY/SFHQ') As 是否获取历史费用
              From Table(Xmlsequence(Extract(x_In, 'DATA'))) A) Loop
      n_p_Tmp := 0;
      If p.收费方式 = 0 Then
        For I In 1 .. r_Moneynow.Count Loop
          If r_Moneynow(I)
           .医嘱id = p.医嘱id And r_Moneynow(I).诊疗项目id = p.诊疗项目id And (r_Moneynow(I).收费方式 = 5 Or r_Moneynow(I).收费方式 = 6) Then
            n_p_Makemoney := 0;
            Exit;
          End If;
        End Loop;
      Elsif p.收费方式 = 1 Then
        If p.试管编码 Is Not Null Then
          --相同条码(试管)只收取一次 
          For I In 1 .. r_Moneynow.Count Loop
            If r_Moneynow(I).试管编码 = p.试管编码 And r_Moneynow(I).样本条码 = p.样本条码 And r_Moneynow(I).收费项目id = p.收费项目id And r_Moneynow(I)
               .收费方式 <> -1 Then
              n_p_Makemoney := 0;
              Exit;
            End If;
          End Loop;
          --只收取试管对应的卫材费用
          If n_p_Makemoney = 1 And p.收费类别 = '4' Then
            Select Max(材料id) Into n_p_材料id From 采血管类型 Where 编码 = p.试管编码;
            If Nvl(n_p_材料id, 0) <> 0 And p.收费项目id <> n_p_材料id Then
              n_p_Makemoney := 0;
            End If;
          End If;
        End If;
      Elsif p.收费方式 = 2 Then
        For I In 1 .. r_Moneynow.Count Loop
          If r_Moneynow(I).诊疗项目id = p.诊疗项目id And r_Moneynow(I).收费项目id = p.收费项目id And r_Moneynow(I).收费方式 <> -1 Then
            n_p_Makemoney := 0;
            Exit;
          End If;
        End Loop;
      Elsif Instr(',3,4,5,6,7,', p.收费方式) > 0 Then
        If p.收费方式 = 7 Then
          For I In 1 .. r_Moneynow.Count Loop
            If r_Moneynow(I)
             .医嘱id = p.医嘱id And r_Moneynow(I).诊疗项目id = p.诊疗项目id And (r_Moneynow(I).收费方式 = 5 Or r_Moneynow(I).收费方式 = 6) Then
              n_p_Makemoney := 0;
              Exit;
            End If;
          End Loop;
        End If;
        If n_p_Makemoney = 1 Then
          --p.分解时间 目前这个分解时间只有1个点，对于已经发送过产生的费用的情况暂时不考虑
          For D In (Select Substr(Column_Value, 1, 10) As 时间
                    From Table(Cast(f_Str2list(p.分解时间) As t_Strlist))
                    Group By Substr(Column_Value, 1, 10)) Loop
            t_d.Extend;
            t_d(t_d.Count).收费时间 := d.时间;
            t_d(t_d.Count).存在 := 0;
            If p.收费方式 = 7 Then
              For I In 1 .. r_Moneynow.Count Loop
                If r_Moneynow(I).收费时间 = d.时间 And r_Moneynow(I).诊疗项目id = p.诊疗项目id And r_Moneynow(I).收费项目id = p.收费项目id Then
                  t_d(t_d.Count).存在 := 1;
                  Exit;
                End If;
              End Loop;
            Elsif p.收费方式 = 4 Or p.收费方式 = 6 Then
              For I In 1 .. r_Moneynow.Count Loop
                If r_Moneynow(I).收费时间 = d.时间 And r_Moneynow(I).诊疗项目id = p.诊疗项目id And r_Moneynow(I).收费项目id = p.收费项目id And r_Moneyday(I)
                   .收费方式 <> -1 And r_Moneynow(I).执行部门id = p.执行部门id Then
                  t_d(t_d.Count).存在 := 1;
                  Exit;
                End If;
              End Loop;
            Else
              For I In 1 .. r_Moneynow.Count Loop
                If r_Moneynow(I).收费时间 = d.时间 And r_Moneynow(I).诊疗项目id = p.诊疗项目id And r_Moneynow(I).收费项目id = p.收费项目id And r_Moneyday(I)
                   .收费方式 <> -1 Then
                  t_d(t_d.Count).存在 := 1;
                  Exit;
                End If;
              End Loop;
            End If;
            n_p_获取历史 := Nvl(p.是否获取历史费用, 0);
            If n_p_获取历史 = 0 Then
              n_p_获取历史 := 1;
              x_p_Moneyday := Null;
              x_p_In       := Xmltype('<DATA><PARIN><BRID>' || p.病人id || '</BRID><ZYID>0</ZYID><LY>1</LY><SFSJ>' || d.时间 ||
                                      '</SFSJ></PARIN></DATA>');
              Getpatidaymoneydetail(x_p_In, x_p_Moneyday);
              Open c_Moneyday(x_p_Moneyday);
              Fetch c_Moneyday Bulk Collect
                Into r_Moneyday;
              Close c_Moneyday;
              Select Deletexml(x_Out, '//MONEYDAY') Into x_Out From Dual;
              Select Appendchildxml(x_Out, '/DATA', x_p_Moneyday) Into x_Out From Dual;
            End If;
            If p.收费方式 = 7 Then
              For I In 1 .. r_Moneyday.Count Loop
                If r_Moneyday(I).收费时间 = d.时间 And r_Moneyday(I).诊疗项目id = p.诊疗项目id And r_Moneyday(I).收费项目id = p.收费项目id Then
                  t_d(t_d.Count).存在 := 1;
                  Exit;
                End If;
              End Loop;
            Elsif p.收费方式 = 4 Or p.收费方式 = 6 Then
              For I In 1 .. r_Moneyday.Count Loop
                If r_Moneyday(I).收费时间 = d.时间 And r_Moneyday(I).诊疗项目id = p.诊疗项目id And r_Moneyday(I).收费项目id = p.收费项目id And r_Moneyday(I)
                   .收费方式 <> -1 And r_Moneyday(I).执行部门id = p.执行部门id Then
                  t_d(t_d.Count).存在 := 1;
                  Exit;
                End If;
              End Loop;
            Else
              For I In 1 .. r_Moneyday.Count Loop
                If r_Moneyday(I).收费时间 = d.时间 And r_Moneyday(I).诊疗项目id = p.诊疗项目id And r_Moneyday(I).收费项目id = p.收费项目id And r_Moneyday(I)
                   .收费方式 <> -1 Then
                  t_d(t_d.Count).存在 := 1;
                  Exit;
                End If;
              End Loop;
            End If;
          End Loop;
        End If;
      Elsif p.收费方式 = 9 Then
        Select Zl_Fun_Customexpenses(p.病人id, p.主页id, p.来源, p.当前医嘱id, p.医嘱id, p.期效, p.频率, p.诊疗项目id, p.收费项目id, p.执行部门id,
                                      p.诊疗类别, p.收费类别, p.总量, p.单量, p.计价数量, p.费用性质, p.计算方式) As 返回结果
        Into v_p_Tmp
        From Dual;
        If v_p_Tmp Is Not Null Then
          If Substr(v_p_Tmp, 1, 1) = '0' Then
            n_p_Makemoney := 0;
          Else
            If To_Number(Nvl(Substr(v_p_Tmp, 3), 0)) > 0 Then
              n_p_费用次数 := Substr(v_p_Tmp, 3);
            End If;
          End If;
        End If;
      End If;
    
      --记录到本次发送明细项目记录中
      If Instr(',3,4,5,6,7,', p.收费方式) > 0 Then
        --按一个时间点算      
        If p.收费方式 = 7 Then
          If n_p_Makemoney = 1 Then
            --没收过的那些天(频率为一天一次但未收的当成收过了)，首次不收
            If t_d(1).存在 = 0 Then
              n_p_费用次数 := p.总量 - 1;
            End If;
            If n_p_费用次数 = 0 Then
              n_p_Makemoney := 0;
            End If;
          End If;
        Else
          If t_d(1).存在 = 0 Then
            n_p_Makemoney := 1;
            n_p_费用次数  := 1;
          Else
            n_p_Makemoney := 0;
            n_p_费用次数  := 0;
          End If;
        End If;
      
        If n_p_Makemoney = 1 Or p.收费方式 = 7 And n_p_费用次数 = 0 Then
          If p.收费方式 = 7 And n_p_费用次数 = 0 Then
            n_p_Tmp := -1;
          Else
            n_p_Tmp := p.收费方式;
          End If;
          --添加一条记录
          Select Appendchildxml(x_Out, '/DATA/MONEYNOW',
                                 Xmltype('<ROW><YZID>' || p.医嘱id || '</YZID>' || '<ZLXMID>' || p.诊疗项目id || '</ZLXMID>' ||
                                          '<SFXMID>' || p.收费项目id || '</SFXMID>' || '<SGBM>' || p.试管编码 || '</SGBM>' ||
                                          '<YBTM>' || p.样本条码 || '</YBTM>' || '<SFFS>' || n_p_Tmp || '</SFFS>' || '<SFSJ>' || t_d(1).收费时间 ||
                                          '</SFSJ>' || '<ZXBMID>' || p.执行部门id || '</ZXBMID></ROW>'))
          Into x_Out
          From Dual;
        End If;
      Elsif 1 = n_p_Makemoney Then
        --添加一条记录
        Select Appendchildxml(x_Out, '/DATA/MONEYNOW',
                               Xmltype('<ROW><YZID>' || p.医嘱id || '</YZID>' || '<ZLXMID>' || p.诊疗项目id || '</ZLXMID>' ||
                                        '<SFXMID>' || p.收费项目id || '</SFXMID>' || '<SGBM>' || p.试管编码 || '</SGBM>' ||
                                        '<YBTM>' || p.样本条码 || '</YBTM>' || '<SFFS>' || n_p_Tmp || '</SFFS>' || '<SFSJ>' ||
                                        Substr(p.分解时间, 1, 10) || '</SFSJ>' || '<ZXBMID>' || p.执行部门id || '</ZXBMID></ROW>'))
        Into x_Out
        From Dual;
      End If;
    
      --医嘱执行计价，简单考虑，直接生成
      v_p_Tmp := '<ROW><YZID>' || p.当前医嘱id || '</YZID>' || '<FSH>' || p.发送号 || '</FSH>' || '<SFXMID>' || p.收费项目id ||
                 '</SFXMID>' || '<YQSJ>' || p.分解时间 || '</YQSJ>';
      If n_p_Makemoney = 0 Then
        n_p_Tmp := 0;
      Else
        n_p_Tmp := p.总量 * p.计价数量;
      End If;
      v_p_Tmp := v_p_Tmp || '<SL>' || n_p_Tmp || '</SL>' || '<FYXZ>' || p.费用性质 || '</FYXZ></ROW>';
      Select Appendchildxml(x_Out, '/DATA/EXEC', Xmltype(v_p_Tmp)) Into x_Out From Dual;
      Select Appendchildxml(x_Out, '/DATA',
                             Xmltype('<PAROUT><SFSF>' || n_p_Makemoney || '</SFSF><FYCS>' || n_p_费用次数 ||
                                      '</FYCS></PAROUT>'))
      Into x_Out
      From Dual;
    End Loop;
  End Advicemoneymake;

  --获取费用NO号
  Procedure Getcurbillset
  (
    x_In  In Xmltype,
    x_Out Out Xmltype
  ) Is
    Cursor c_Bill(Xmlin Xmltype) Is
      Select b.Key, b.No, b.费用序号, b.发送序号
      From (Select Xmlin As Datas From Dual) A,
           Xmltable('//BILL/ROW' Passing a.Datas Columns Key Varchar2(200) Path 'KEY', NO Varchar2(20) Path 'NO',
                     费用序号 Number(18) Path 'FYXH', 发送序号 Number(18) Path 'FSXH') B;
    Type t_Bill Is Table Of c_Bill%RowType;
  
    r_Bill   t_Bill;
    n_p_Tmp  Number(3);
    x_p_Tmp  Xmltype;
    v_p_Tmp  Varchar2(3000);
    v_p_No   Varchar2(100);
    n_p_Find Number(3);
  Begin
    x_Out := Xmltype('<DATA><BILL></BILL></DATA>');
    Select a.Column_Value Into x_p_Tmp From Table(Xmlsequence(Extract(x_In, 'DATA/BILL'))) A;
    Open c_Bill(x_p_Tmp);
    Fetch c_Bill Bulk Collect
      Into r_Bill;
    Close c_Bill;
    For P In (Select Extractvalue(Value(A), 'DATA/PARIN/KEY') As Key, Extractvalue(Value(A), 'DATA/PARIN/NO') As NO,
                     Extractvalue(Value(A), 'DATA/PARIN/FYXH') As 费用序号, Extractvalue(Value(A), 'DATA/PARIN/FSXH') As 发送序号,
                     Extractvalue(Value(A), 'DATA/PARIN/JZ') As 记帐, Extractvalue(Value(A), 'DATA/BILL/SXH') As 顺序号
              From Table(Xmlsequence(Extract(x_In, 'DATA'))) A) Loop
    
      n_p_Tmp := Nvl(p.顺序号, 0);
    
      If r_Bill.Count > 0 Then
        For J In 1 .. r_Bill.Count Loop
          If p.Key = r_Bill(J).Key Then
            n_p_Find := J;
          Else
            v_p_Tmp := '<KEY>' || r_Bill(J).Key || '</KEY><NO>' || r_Bill(J).No || '</NO><FYXH>' || r_Bill(J).费用序号 ||
                       '</FYXH><FSXH>' || r_Bill(J).发送序号 || '</FSXH>';
            Select Appendchildxml(x_Out, '/DATA/BILL', Xmltype('<ROW>' || v_p_Tmp || '</ROW>')) Into x_Out From Dual;
          End If;
        End Loop;
      End If;
    
      If n_p_Find Is Not Null Then
        v_p_Tmp := '<KEY>' || r_Bill(n_p_Find).Key || '</KEY><NO>' || r_Bill(n_p_Find).No || '</NO>';
        If p.费用序号 = -1 Then
          v_p_Tmp := v_p_Tmp || '<FYXH>' || r_Bill(n_p_Find).费用序号 || '</FYXH>';
        Else
          v_p_Tmp := v_p_Tmp || '<FYXH>' || (r_Bill(n_p_Find).费用序号 + 1) || '</FYXH>';
        End If;
        If p.发送序号 = -1 Then
          v_p_Tmp := v_p_Tmp || '<FSXH>' || r_Bill(n_p_Find).发送序号 || '</FSXH>';
        Else
          v_p_Tmp := v_p_Tmp || '<FSXH>' || (r_Bill(n_p_Find).发送序号 + 1) || '</FSXH>';
        End If;
        Select Appendchildxml(x_Out, '/DATA/BILL', Xmltype('<ROW>' || v_p_Tmp || '</ROW>')) Into x_Out From Dual;
        Select Appendchildxml(x_Out, '/DATA', Xmltype('<PAROUT>' || v_p_Tmp || '</PAROUT>')) Into x_Out From Dual;
        Select Appendchildxml(x_Out, '/DATA/BILL', Xmltype('<SXH>' || n_p_Tmp || '</SXH>')) Into x_Out From Dual;
      Else
        v_p_Tmp := '<KEY>' || p.Key || '</KEY>';
        n_p_Tmp := n_p_Tmp + 1;
        Select LPad(n_p_Tmp, 5, '0') Into v_p_No From Dual;
        If p.记帐 = 1 Then
          Select Nextno(14, Null, Null, 1) Into v_p_No From Dual;
        Else
          Select Nextno(13, Null, Null, 1) Into v_p_No From Dual;
        End If;
        v_p_Tmp := v_p_Tmp || '<NO>' || v_p_No || '</NO>';
      
        If p.费用序号 = -1 Then
          v_p_Tmp := v_p_Tmp || '<FYXH>0</FYXH>';
        Else
          v_p_Tmp := v_p_Tmp || '<FYXH>1</FYXH>';
        End If;
      
        If p.发送序号 = -1 Then
          v_p_Tmp := v_p_Tmp || '<FSXH>0</FSXH>';
        Else
          v_p_Tmp := v_p_Tmp || '<FSXH>1</FSXH>';
        End If;
        Select Appendchildxml(x_Out, '/DATA/BILL', Xmltype('<ROW>' || v_p_Tmp || '</ROW>')) Into x_Out From Dual;
        Select Appendchildxml(x_Out, '/DATA', Xmltype('<PAROUT>' || v_p_Tmp || '</PAROUT>')) Into x_Out From Dual;
        Select Appendchildxml(x_Out, '/DATA/BILL', Xmltype('<SXH>' || n_p_Tmp || '</SXH>')) Into x_Out From Dual;
      End If;
    End Loop;
  End Getcurbillset;

Begin
  --系统参数
  n_Dec      := To_Number(Nvl(zl_GetSysParameter(9), '2'));
  n_单价小数 := To_Number(Nvl(zl_GetSysParameter(157), '5'));
  n_折扣     := To_Number(Nvl(zl_GetSysParameter(93), 0));
  n_条码生成 := To_Number(Nvl(zl_GetSysParameter(143), 0));
  v_划价单   := Nvl(zl_GetSysParameter(86), 0);
  --传入参数
  Select Extractvalue(Value(A), 'IN/BRID') As 病人id, Extractvalue(Value(A), 'IN/JZID') As 就诊id,
         Extractvalue(Value(A), 'IN/YZIDS') As 医嘱ids, Extractvalue(Value(A), 'IN/ZD') As 站点,
         Extractvalue(Value(A), 'IN/JZD') As 记帐, Extractvalue(Value(A), 'IN/CZYXM') As 操作员,
         Extractvalue(Value(A), 'IN/CZYBH') As 操作员编号, Extractvalue(Value(A), 'IN/JBJJ') As 加班加价
  Into n_病人id, n_就诊id, v_医嘱ids, v_站点, n_记帐, v_操作员姓名, v_操作员编号, n_加班加价
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  Select Nvl(Nvl(a.续诊科室id, a.转诊科室id), a.执行部门id) As 科室id
  Into n_接诊科室id
  From 病人挂号记录 A
  Where a.Id = n_就诊id;

  Select f_List2str(Cast(Collect(m.名称) As t_Strlist)) As 名称
  Into v_动态费别
  From (Select 编码, 简码, 名称
         From 费别
         Where Nvl(属性, 1) = 2 And Nvl(适用科室, 1) = 1 And Nvl(服务对象, 3) In (1, 3) And
               Trunc(Sysdate) Between Nvl(有效开始, To_Date('1900-01-01', 'YYYY-MM-DD')) And
               Nvl(有效结束, To_Date('3000-01-01', 'YYYY-MM-DD'))
         Union All
         Select Distinct a.编码, a.简码, a.名称
         From 费别 A, 费别适用科室 B
         Where a.名称 = b.费别 And b.科室id = n_接诊科室id And Nvl(a.属性, 1) = 2 And Nvl(a.适用科室, 1) = 2 And Nvl(a.服务对象, 3) In (1, 3) And
               Trunc(Sysdate) Between Nvl(a.有效开始, To_Date('1900-01-01', 'YYYY-MM-DD')) And
               Nvl(a.有效结束, To_Date('3000-01-01', 'YYYY-MM-DD'))) M;

  Select Nextno(10, Null, Null, 1) As 发送号, (Sysdate + 1 / 60 / 24) As 发送时间 Into n_发送号, d_Cur From Dual;

  x_Number := Xmltype('<DATA><YBNUMBER></YBNUMBER><PARIN></PARIN><PAROUT></PAROUT></DATA>');
  x_Money  := Xmltype('<DATA><MONEYNOW></MONEYNOW><MONEYDAY></MONEYDAY><EXEC></EXEC><PARIN></PARIN><PAROUT></PAROUT></DATA>');
  x_Price  := Xmltype('<DATA><PRICE></PRICE><PARIN></PARIN><PAROUT></PAROUT></DATA>');
  x_Bill   := Xmltype('<DATA><BILL></BILL><PARIN></PARIN><PAROUT></PAROUT></DATA>');

  Open c_Pati(n_就诊id);
  Fetch c_Pati
    Into r_Pati;

  Open c_Advice(v_医嘱ids);
  Loop
    Fetch c_Advice
      Into r_Advice;
    Exit When c_Advice%NotFound;
    If c_Advice%RowCount > 0 Then
      If Nvl(r_Advice.计价特性, 0) = 0 And Instr(',0,5,', Nvl(r_Advice.执行性质, 0)) = 0 Then
        n_Tmp    := 1;
        n_材料id := 0; --采集行在检验行之后
        If r_Advice.诊疗类别 = 'D' And r_Advice.相关id Is Null Then
          n_Tmp   := 0;
          v_Nokey := '主检查_' || r_Advice.Id;
          v_条码  := Null;
        Elsif r_Advice.诊疗类别 = 'E' Then
          v_Nokey  := '采集_' || r_Advice.Id;
          n_材料id := 0;
        Elsif r_Advice.诊疗类别 = 'C' Then
          v_Nokey := '检验_' || r_Advice.Id;
          If r_Advice.试管编码 Is Not Null Then
            --检验医嘱才会有条码，采集行和检验行同用一个条码，所以E类别是不置空 v_条码:=null;
            Select Nvl(Max(材料id), 0) Into n_材料id From 采血管类型 Where 编码 = r_Advice.试管编码;
            v_试管编码 := r_Advice.试管编码;
            Select a.执行科室id Into n_采集科室id From 病人医嘱记录 A Where a.Id = r_Advice.相关id;
            v_Tmp := '<PARIN>';
            v_Tmp := v_Tmp || '<GM>' || v_试管编码 || '</GM>';
            v_Tmp := v_Tmp || '<YZID>' || r_Advice.Id || '</YZID>';
            v_Tmp := v_Tmp || '<XGID>' || r_Advice.相关id || '</XGID>';
            v_Tmp := v_Tmp || '<ZXKSID>' || r_Advice.执行科室id || '</ZXKSID>';
            v_Tmp := v_Tmp || '<YE>' || r_Advice.婴儿 || '</YE>';
            v_Tmp := v_Tmp || '<ZLXMID>' || r_Advice.诊疗项目id || '</ZLXMID>';
            v_Tmp := v_Tmp || '<JJ>' || r_Advice.紧急标志 || '</JJ>';
            v_Tmp := v_Tmp || '<BB>' || r_Advice.标本部位 || '</BB>';
            v_Tmp := v_Tmp || '<CJKSID>' || n_采集科室id || '</CJKSID>';
            v_Tmp := v_Tmp || '</PARIN>';
          
            Select Deletexml(x_Number, '//PARIN') Into x_Number From Dual;
            Select Deletexml(x_Number, '//PAROUT') Into x_Number From Dual;
            Select Appendchildxml(x_Number, '/DATA', Xmltype(v_Tmp)) Into x_Number From Dual;
            Getcuvettenumber(x_Number, x_t);
            Select Extractvalue(Value(A), 'DATA/PAROUT/TM')
            Into v_条码
            From Table(Xmlsequence(Extract(x_t, 'DATA'))) A;
            x_Number := x_t;
          End If;
        Else
          v_Nokey := '检查_' || r_Advice.相关id;
          v_条码  := Null;
        End If;
      
        --本科执行的自动执行参数不判断“门诊本科自动执行”忽略      
        Select Deletexml(x_Price, '//PARIN') Into x_Price From Dual;
        Select Deletexml(x_Price, '//PAROUT') Into x_Price From Dual;
      
        --入参      
        v_Tmp := '<PARIN><DJXS>' || n_单价小数 || '</DJXS>'; -- 单价小数位数
        v_Tmp := v_Tmp || '<ZD>' || v_站点 || '</ZD>'; -- 站点
        v_Tmp := v_Tmp || '<YZID>' || r_Advice.Id || '</YZID>'; --医嘱ID
        v_Tmp := v_Tmp || '<XGID>' || r_Advice.相关id || '</XGID>'; --相关ID
        v_Tmp := v_Tmp || '<ZLLB>' || r_Advice.诊疗类别 || '</ZLLB>'; --诊疗类别
        v_Tmp := v_Tmp || '<ZLXMID>' || r_Advice.诊疗项目id || '</ZLXMID>'; --诊疗项目ID
        v_Tmp := v_Tmp || '<ZXKSID>' || r_Advice.执行科室id || '</ZXKSID>'; --执行科室ID
        v_Tmp := v_Tmp || '<SGBM>' || v_试管编码 || '</SGBM>'; --试管编码
        v_Tmp := v_Tmp || '<JCBW>' || r_Advice.标本部位 || '</JCBW>'; --检查部位
        v_Tmp := v_Tmp || '<JCFF>' || r_Advice.检查方法 || '</JCFF></PARIN>'; --检查方法
        Select Appendchildxml(x_Price, '/DATA', Xmltype(v_Tmp)) Into x_Price From Dual;
        Getadviceprice(x_Price, x_t);
        x_Price := x_t;
      
        --一条医嘱记录行，只会对应一个主项，收费细目ID 唯一
        Open c_Adviceprice(x_Price);
        Fetch c_Adviceprice Bulk Collect
          Into r_Ap;
        Close c_Adviceprice;
        n_从项合计 := Null;
        n_Idx父项  := Null;
        For I In 1 .. r_Ap.Count Loop
          --费用相关
          Select Deletexml(x_Money, '//PARIN') Into x_Money From Dual;
          Select Deletexml(x_Money, '//PAROUT') Into x_Money From Dual;
          --入参
          v_Tmp := '<PARIN>';
          v_Tmp := v_Tmp || '<BRID>' || r_Advice.病人id || '</BRID>';
          v_Tmp := v_Tmp || '<ZYID>0</ZYID>'; --主页ID
          v_Tmp := v_Tmp || '<YZID>' || r_Advice.组id || '</YZID>';
          v_Tmp := v_Tmp || '<ZLXMID>' || r_Advice.诊疗项目id || '</ZLXMID>';
          v_Tmp := v_Tmp || '<SFXMID>' || r_Ap(I).收费细目id || '</SFXMID>';
          v_Tmp := v_Tmp || '<ZXBMID>' || r_Ap(I).执行科室id || '</ZXBMID>';
          v_Tmp := v_Tmp || '<SGBM>' || v_试管编码 || '</SGBM>';
          v_Tmp := v_Tmp || '<SFLB>' || r_Ap(I).类别 || '</SFLB>';
          v_Tmp := v_Tmp || '<SFFS>' || r_Ap(I).收费方式 || '</SFFS>';
          v_Tmp := v_Tmp || '<FJSJ>' || To_Char(r_Advice.开始执行时间, 'YYYY-MM-DD HH24:MI:SS') || '</FJSJ>';
          v_Tmp := v_Tmp || '<LY>1</LY>';
          v_Tmp := v_Tmp || '<FYCS>1</FYCS>';
          v_Tmp := v_Tmp || '<ZL>1</ZL>';
          v_Tmp := v_Tmp || '<DQYZID>' || r_Advice.Id || '</DQYZID>';
          v_Tmp := v_Tmp || '<FSH>' || n_发送号 || '</FSH>';
          v_Tmp := v_Tmp || '<JJSL>' || r_Ap(I).数量 || '</JJSL>';
          v_Tmp := v_Tmp || '<JSFS>0</JSFS>'; --计算方式，目前没有用到 
          v_Tmp := v_Tmp || '<PL>一次性</PL>'; --频率，目前没有用到 
          v_Tmp := v_Tmp || '<DL>1</DL>'; --单量 
          v_Tmp := v_Tmp || '<QX>1</QX>';
          v_Tmp := v_Tmp || '<FYXZ>0</FYXZ>'; --费用性质，固定为0
          v_Tmp := v_Tmp || '<ZLLB>' || r_Advice.诊疗类别 || '</ZLLB>';
          v_Tmp := v_Tmp || '<YBTM>' || v_条码 || '</YBTM>';
          v_Tmp := v_Tmp || '</PARIN>';
          Select Appendchildxml(x_Money, '/DATA', Xmltype(v_Tmp)) Into x_Money From Dual;
          Advicemoneymake(x_Money, x_t);
          x_Money := x_t;
        
          Select Extractvalue(Value(A), 'DATA/PAROUT/SFSF'), Extractvalue(Value(A), 'DATA/PAROUT/FYCS')
          Into n_Makemoney, n_费用次数
          From Table(Xmlsequence(Extract(x_t, 'DATA'))) A;
        
          If n_Makemoney = 1 Then
            n_付数 := 1;
            If Instr(',1,2,3,4,5,6,7,9,', r_Ap(I).收费方式) > 0 Then
              n_数量 := n_费用次数 * r_Ap(I).数量;
            Else
              n_数量 := r_Ap(I).数量;
            End If;
            n_单价 := Round(r_Ap(I).单价, n_单价小数);
          
            --发送金额
            n_应收 := n_付数 * n_数量 * n_单价;
          
            --附加手术，手术医嘱下的时有附加手术时才涉及到，目前暂时不涉及到，忽略
          
            --加班处理(界面勾选决定)和费用项目的  加班加价率 字段决定，暂时忽略            
            If Nvl(n_加班加价, 0) = 1 And Nvl(r_Ap(I).加班加价, 0) = 1 Then
              n_应收 := n_应收 * (1 + Nvl(r_Ap(I).加班加价率, 0) / 100);
            End If;
          
            --获取NO和费用序号          
            Select Deletexml(x_Bill, '//PARIN') Into x_Bill From Dual;
            Select Deletexml(x_Bill, '//PAROUT') Into x_Bill From Dual;
            v_Tmp := '<PARIN><KEY>' || v_Nokey || '</KEY><NO></NO><FYXH>0</FYXH><FSXH>-1</FSXH><JZ>' || n_记帐 ||
                     '</JZ></PARIN>';
            Select Appendchildxml(x_Bill, '/DATA', Xmltype(v_Tmp)) Into x_Bill From Dual;
            Getcurbillset(x_Bill, x_t);
            x_Bill := x_t;
            Select Extractvalue(Value(A), 'DATA/PAROUT/NO'), Extractvalue(Value(A), 'DATA/PAROUT/FYXH')
            Into v_No, n_费用序号
            From Table(Xmlsequence(Extract(x_t, 'DATA'))) A;
          
            --主从关系记录 
            If r_Ap(I).从项 = 0 Then
              n_父序号  := n_费用序号;
              n_Idx父项 := I;
            End If;
          
            --折扣、费别等重算实收金额。暂时忽略
            --计算汇总折扣合计 n_从项合计，医嘱 零费记帐 不考虑
            v_费别 := r_Pati.费别;
            If n_折扣 = 1 And r_Ap(I).从项 = 1 Then
              n_实收     := Round(n_应收, n_Dec);
              n_从项合计 := Nvl(n_从项合计, 0) + n_实收;
            Elsif Nvl(r_Ap(I).屏蔽费别, 0) = 0 Then
              If n_记帐 = 0 Then
                --动态费别
                v_费别 := r_Pati.费别 || ',' || v_动态费别;
              End If;
              --根据费别重算费用
              v_Tmp := Null;
              Select Zl_Actualmoney(v_费别, r_Ap(I).收费细目id, r_Ap(I).收入项目id, (n_付数 * n_数量 * n_单价), (n_付数 * n_数量),
                                     r_Ap(I).执行科室id) As
              Into v_Tmp
              From Dual;
            
              v_费别 := Substr(v_Tmp, 1, Instr(v_Tmp, ':') - 1);
              n_实收 := To_Number(Substr(v_Tmp, Instr(v_Tmp, ':') + 1));
              If Nvl(n_加班加价, 0) = 1 And Nvl(r_Ap(I).加班加价, 0) = 1 Then
                n_实收 := n_实收 * (1 + Nvl(r_Ap(I).加班加价率, 0) / 100);
              End If;
              n_实收 := Round(n_实收, n_Dec);
            Else
              n_实收 := Round(n_应收, n_Dec);
            End If;
            --从属父号
            If r_Ap(I).从项 = 1 Then
              r_Ap(I).父序号 := n_父序号;
            Else
              r_Ap(I).父序号 := Null;
            End If;
            --1 As 付数, b.数量 As 费用数量, b.单价 As 应收, b.单价 As 实收, b.收费细目id As 父序号, b.收据费目 As 费别
            r_Ap(I).是否收费 := 1;
            r_Ap(I).付数 := n_付数;
            r_Ap(I).费用数量 := n_数量;
            r_Ap(I).单价 := n_单价;
            r_Ap(I).应收 := n_应收;
            r_Ap(I).实收 := n_实收;
            r_Ap(I).费别 := v_费别;
            r_Ap(I).No := v_No;
            r_Ap(I).费用序号 := n_费用序号;
          End If;
        End Loop;
      
        --循环完了之后处理从项折扣
        If n_从项合计 Is Not Null And n_折扣 = 1 Then
          If n_记帐 = 0 Then
            --动态费别
            v_费别 := r_Pati.费别 || ',' || v_动态费别;
          Else
            v_费别 := r_Pati.费别;
          End If;
        
          v_Tmp := Null;
          Select Zl_Actualmoney(v_费别, 0, r_Ap(n_Idx父项).收入项目id, n_从项合计, 0, 0) Into v_Tmp From Dual;
        
          v_费别 := Substr(v_Tmp, 1, Instr(v_Tmp, ':') - 1);
          n_实收 := To_Number(Substr(v_Tmp, Instr(v_Tmp, ':') + 1));
        
          n_实收 := n_实收 - n_从项合计;
          r_Ap(n_Idx父项).实收 := r_Ap(n_Idx父项).实收 + n_实收;
        End If;
      
        --执行数据提交
        Zl_病人医嘱计价_Delete(r_Advice.Id, 1);
        For I In 1 .. r_Ap.Count Loop
          Zl_病人医嘱计价_Insert(r_Ap(I).医嘱id, r_Ap(I).收费细目id, r_Ap(I).数量, r_Ap(I).单价, r_Ap(I).从项, r_Ap(I).执行科室id,
                           r_Ap(I).费用性质, r_Ap(I).收费方式);
        
          If r_Ap(I).是否收费 = 1 Then
            If n_记帐 = 0 Then
              Zl_门诊划价记录_Insert(r_Ap(I).No, r_Ap(I).费用序号, r_Pati.病人id, Null, r_Pati.门诊号, Null, r_Pati.姓名, r_Pati.性别,
                               r_Pati.年龄, r_Ap(I).费别, Null, r_Advice.开嘱科室id, r_Advice.开嘱科室id, r_Advice.开嘱医生, r_Ap(I).父序号,
                               r_Ap(I).收费细目id, r_Ap(I).类别, r_Ap(I).计算单位, Null, r_Ap(I).付数, r_Ap(I).费用数量, Null,
                               r_Ap(I).执行科室id, Null, r_Ap(I).收入项目id, r_Ap(I).收据费目, r_Ap(I).单价, r_Ap(I).应收, r_Ap(I).实收,
                               r_Advice.开始执行时间, d_Cur, '医嘱发送', v_操作员姓名, r_Advice.医嘱内容, r_Advice.Id, r_Advice.执行频次,
                               r_Advice.单次用量, r_Advice.诊疗项目, 1, r_Advice.计价特性, 1, Null, Null, Null, Null, Null, Null,
                               Null);
            Else
              --参数：门诊发送为划价单诊疗类别
              If Instr(v_划价单, r_Advice.诊疗类别) > 0 Then
                n_划价 := 1;
              Elsif Nvl(r_Ap(I).费用确认, 0) = 1 Then
                n_划价 := 1;
              Else
                n_划价 := 0;
              End If;
              If n_划价 = 1 Then
                d_Tmp := d_Cur + 1 / 24 / 60;
              Else
                d_Tmp := d_Cur;
              End If;
              Zl_门诊记帐记录_Insert(r_Ap(I).No, r_Ap(I).费用序号, r_Pati.病人id, r_Pati.门诊号, r_Pati.姓名, r_Pati.性别, r_Pati.年龄,
                               r_Ap(I).费别, Null, 0, r_Advice.开嘱科室id, r_Advice.开嘱科室id, r_Advice.开嘱医生, r_Ap(I).父序号,
                               r_Ap(I).收费细目id, r_Ap(I).类别, r_Ap(I).计算单位, r_Ap(I).付数, r_Ap(I).费用数量, Null, r_Ap(I).执行科室id,
                               Null, r_Ap(I).收入项目id, r_Ap(I).收据费目, r_Ap(I).单价, r_Ap(I).应收, r_Ap(I).实收, r_Advice.开始执行时间,
                               d_Tmp, '医嘱发送', n_划价, v_操作员编号, v_操作员姓名, Null, r_Advice.医嘱内容, r_Advice.Id, r_Advice.执行频次,
                               r_Advice.单次用量, r_Advice.诊疗项目, 1, r_Advice.计价特性, 1, Null, Null, Null);
            End If;
          End If;
        End Loop;
      End If;
      --产生发送记录
    
      --获取NO和费用序号
      Select Deletexml(x_Bill, '//PARIN') Into x_Bill From Dual;
      Select Deletexml(x_Bill, '//PAROUT') Into x_Bill From Dual;
      v_Tmp := '<PARIN><KEY>' || v_Nokey || '</KEY><NO></NO><FYXH>-1</FYXH><FSXH>0</FSXH><JZ>' || n_记帐 ||
               '</JZ></PARIN>';
      Select Appendchildxml(x_Bill, '/DATA', Xmltype(v_Tmp)) Into x_Bill From Dual;
      Getcurbillset(x_Bill, x_t);
      x_Bill := x_t;
      Select Extractvalue(Value(A), 'DATA/PAROUT/NO'), Extractvalue(Value(A), 'DATA/PAROUT/FSXH')
      Into v_No, n_发送序号
      From Table(Xmlsequence(Extract(x_t, 'DATA'))) A;
    
      --检验医嘱发送时生成条形码，系统参数 143 号
      If n_条码生成 = 1 Then
        v_Tmp := v_条码;
      Else
        v_Tmp := Null;
      End If;
    
      Zl_门诊医嘱发送_Insert(r_Advice.Id, n_发送号, n_记帐 + 1, v_No, n_发送序号, 1, r_Advice.开始执行时间, r_Advice.开始执行时间, d_Cur, 0,
                       r_Advice.执行科室id, 1, 0, v_Tmp, v_操作员编号, v_操作员姓名);
    
      Select a.Column_Value Into x_Exec From Table(Xmlsequence(Extract(x_Money, 'DATA/EXEC'))) A;
    
      For R In (Select b.医嘱id, b.发送号, b.收费项目id, b.要求时间, b.数量, b.费用性质
                From (Select x_Exec As Datas From Dual) A,
                     Xmltable('//EXEC/ROW' Passing a.Datas Columns 医嘱id Number(18) Path 'YZID', 发送号 Number(18) Path 'FSH',
                               收费项目id Number(18) Path 'SFXMID', 要求时间 Varchar2(20) Path 'YQSJ', 数量 Number(16, 5) Path 'SL',
                               费用性质 Number(1) Path 'FYXZ') B) Loop
        If r.医嘱id = r_Advice.Id Then
          Zl_医嘱执行计价_Insert(r.医嘱id, r.发送号, To_Date(r.要求时间, 'YYYY-MM-DD HH24:MI:SS'), r.收费项目id, r.数量, r.费用性质);
        End If;
      End Loop;
    End If;
  End Loop;
  Close c_Advice;
  Close c_Pati;
  Xml_Out := Xmltype('<OUTPUT><ERROR><MSG></MSG></ERROR></OUTPUT>');
Exception
  When Others Then
    v_Tmp   := '<OUTPUT><ERROR><MSG>错误信息：' || SQLErrM || '</MSG></ERROR></OUTPUT>';
    Xml_Out := Xmltype(v_Tmp);
End Zl_Third_Advicesend;
/

--109786:胡俊勇,2017-06-24,妇幼保健医生站数据接口
CREATE OR REPLACE Procedure Zl_Third_Advicesavesend
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:病人生成医嘱发送医嘱(检查检验)，一个病人调用一次
  --入参:Xml_In:
  --  <IN>
  --   <GHDH>R0000001</GHDH> 挂号单号
  --   <JZID></JZID>就诊ID，挂号ID
  --   <BRID></BRID>病人ID
  --   <YEXH></YEXH>婴儿序号，如果是病人医嘱，传0
  --   <BRKSID>21</BRKSID>  病人科室ID
  --   <CZYXM>张永康</CZYXM> 操作员姓名
  --   <CZYBH></CZYBH> 操作员编号
  --   <ZD></ZD>站点
  --   <JZD>0</JZD> 是否发送为记帐单，0-划价单，1-记帐单
  --   <JBJJ></JBJJ>加班加价 由外部传入决定
  --   <CLLIS></CLLIS>处理LIS申请，定决是否要在过程内部调用LIS接口， 0-不处理，1-要处理
  --   <FHLISDATA></FHLISDATA>是否需要返回LIS申请信息，0-不返回，1-返回

  --   <YZNRLIST>  医嘱列表，可以含多个结点
  --   <YZNR> 医嘱内容
  --    <ZLLB>D</ZLLB>  诊疗类别 D-检查，C-检验
  --    <ZLXMID>123</ZLXMID>  诊疗项目ID
  --    <ZXKSID>123</ZXKSID>   执行科室ID
  --    <JJBZ>2</JJBZ>   紧急标志
  --    <KSZXSJ>2017-05-25 10:00:00</KSZXSJ> 开始执行时间
  --    <KZKSID>23</KZKSID>开嘱科室ID
  --    <KZYS>张永康</KZYS> 开嘱医生
  --    <KZSJ>2017-05-25 10:00:00</KZSJ> 开嘱时间

  ------检查相关的，非检验项目可以不传入
  --    <BWFFALL></BWFFALL>方法部位总述格式: 部位1(方法1),部位2(方法2,方法3),...  逗号为半角
  --                      如：胆囊和胆道(收缩功能检查),输卵管(超声造影),腹部的测试(膀胱余尿测定,常规)
  --    <BWLIST>        检查方法部位列表详情
  --     <BWFF>
  --     <BW>颅骨</BW>
  --     <FF>平扫</FF>
  --     </BWFF>
  --     <BWFF>
  --     ....
  --     </BWFF>
  --    </BWLIST>

  ------检验项目的采集相关内容，非检验项目可以不传入
  --    <CJXMID>12</CJXMID>      采集项目ID
  --    <CJZXKSID>12</CJZXKSID>  采集执行科室ID
  --    <CJBB>血清</CJBB>        采集标本

  --   </YZNR>
  --   </YZNRLIST>
  --  </IN>

  --出参:Xml_Out，生成的医嘱ID串，错误信息
  --  <OUTPUT>
  --    <YZIDS>1234,41234,64645,...</YZIDS>医嘱ID串，逗号分割
  --    <LISAPP>C:44271,E:44272;C:44273,E:44274</LISAPP>检验医嘱信息，固定格式：类别:医嘱ID,类别:医嘱ID;....
  --    <LISDATA></LISDATA>新版LIS检验信息，返回值
  --         LISDATA 此结点的内容，为 Zl_Thrid_Sendlisapplication 过程的 入参数，
  --         结点内容可以有行<IN>XXX1</IN><IN>XXX2</IN>.....
  --    <ERROR>
  --      <MSG>错误信息</MSG>
  --    </ERROR>
  --  </OUTPUT>
  --------------------------------
  --申请基本信息，医嘱id_In 检验行医嘱ID
  Cursor c_Pati(医嘱id_In In 病人医嘱记录.Id%Type) Is
    Select a.Id As 医嘱id, a.相关id As 申请id, a.病人来源, a.病人id, a.婴儿, c.姓名, Decode(c.性别, '男', 1, '女', 2, '未知', 9, 0) 性别, a.年龄,
           a.开嘱医生 As 申请人, a.开嘱时间 As 申请时间, d.名称 As 申请科室, c.当前床号 As 床号, c.健康号, e.名称 As 病人科室, a.紧急标志, a.挂号单, c.门诊号, c.住院号,
           c.出生日期, a.主页id, b.接收人 As 签收人, b.接收时间 As 签收时间, b.采样人, b.采样时间, b.样本条码, 1 As 病人类型, Null As 路径状态, b.送检人,
           b.标本送出时间 As 送检时间, b.计费状态, a.诊疗项目id, f.编码 As 诊疗编码, a.标本部位 As 标本类型, b.记录性质, e.编码 As 病人科室编码, d.编码 As 申请科室编码,
           g.编码 As 病区编码, g.名称 As 病区
    From 病人医嘱记录 A, 病人医嘱发送 B, 病人信息 C, 部门表 D, 部门表 E, 诊疗项目目录 F, 部门表 G
    Where a.Id = b.医嘱id And a.病人id = c.病人id And a.开嘱科室id = d.Id And a.病人科室id = e.Id And a.诊疗项目id = f.Id And
          c.当前病区id = g.Id(+) And a.Id = 医嘱id_In;
  r_Pati c_Pati%RowType;

  --采集行 医嘱id_In 采集行医嘱ID
  Cursor c_Cjrow(医嘱id_In In 病人医嘱记录.Id%Type) Is
    Select 医嘱id_In As 医嘱id, b.名称 As 采集方式, c.名称 As 采集科室, Sum(d.应收金额) As 应收金额, Sum(Decode(d.记录状态, 1, d.实收金额, 0)) As 实收金额,
           Max(d.记录状态) As 记录状态, Max(d.记录性质) As 记录性质
    From 病人医嘱记录 A, 诊疗项目目录 B, 部门表 C, 门诊费用记录 D
    Where a.诊疗项目id = b.Id And a.执行科室id = c.Id And a.Id = d.医嘱序号(+) And a.Id = 医嘱id_In
    Group By b.名称, c.名称;
  r_Cj c_Cjrow%RowType;

  --检验行 医嘱id_In 检验行医嘱ID
  Cursor c_Jyrow(医嘱id_In In 病人医嘱记录.Id%Type) Is
    Select 医嘱id_In As 医嘱id, Max(a.费别) As 费别, Max(a.记录状态) As 记录状态, Max(a.记录性质) As 记录性质, Sum(a.应收金额) As 应收金额,
           Sum(Decode(a.记录状态, 1, a.实收金额, 0)) As 实收金额
    From 门诊费用记录 A
    Where a.医嘱序号 = 医嘱id_In;
  r_Jy c_Jyrow%RowType;

  v_Tmp      Varchar(32767);
  v_医嘱ids  Varchar2(32767);
  n_调用接   Number(1);
  n_返回信息 Number(1);
  v_Lisapp   Varchar2(30000);
  v_Lisinfo  Varchar2(30000);
  x_Lis      Xmltype;
  n_医嘱id   Number(18);
  x_Outsave  Xmltype;
  x_Outsend  Xmltype;
  x_T1       Xmltype;
  x_T2       Xmltype;

  n_记录状态 Number;
  n_记录性质 Number;
  n_计费状态 Number;
  v_Err_Msg  Varchar(2000);
  Err_Item Exception;
Begin
  Zl_Third_Advicesave(Xml_In, x_Outsave);
  Xml_Out := x_Outsave;
  Select Extractvalue(Value(A), 'OUTPUT/YZIDS') As 医嘱ids, Extractvalue(Value(A), 'OUTPUT/ERROR/MSG') As 错误信息
  Into v_医嘱ids, v_Err_Msg
  From Table(Xmlsequence(Extract(x_Outsave, 'OUTPUT'))) A;
  If v_Err_Msg Is Not Null Then
    Raise Err_Item;
  End If;
  x_Outsave := Xml_In;
  Select Appendchildxml(x_Outsave, '/IN', Xmltype('<YZIDS>' || v_医嘱ids || '</YZIDS>')) Into x_Outsave From Dual;
  Zl_Third_Advicesend(x_Outsave, x_Outsend);
  Select Extractvalue(Value(A), 'OUTPUT/ERROR/MSG') As 错误信息
  Into v_Err_Msg
  From Table(Xmlsequence(Extract(x_Outsend, 'OUTPUT'))) A;
  If v_Err_Msg Is Not Null Then
    Raise Err_Item;
  End If;

  --调用检验的接口
  Select Extractvalue(Value(A), 'IN/CLLIS') As 调接口, Extractvalue(Value(A), 'IN/FHLISDATA') As 返回信息
  Into n_调用接, n_返回信息
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  x_Lis := Xmltype('<LISDATA></LISDATA>');

  Select Extractvalue(Value(A), 'OUTPUT/LISAPP') Into v_Lisapp From Table(Xmlsequence(Extract(Xml_Out, 'OUTPUT'))) A;
  If v_Lisapp Is Not Null Then
    v_Lisapp := v_Lisapp || ';';
  End If;

  While v_Lisapp Is Not Null Loop
    v_Tmp    := Substr(v_Lisapp, 1, Instr(v_Lisapp, ';') - 1);
    v_Lisapp := Substr(v_Lisapp, Instr(v_Lisapp, ';') + 1);
    v_Tmp    := Replace(Replace(v_Tmp, 'C:', ''), ',E:', ',');
    n_医嘱id := To_Number(Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1));
    Open c_Pati(n_医嘱id);
    Fetch c_Pati
      Into r_Pati;
    Close c_Pati;
    Open c_Jyrow(n_医嘱id);
    Fetch c_Jyrow
      Into r_Jy;
    Close c_Jyrow;
  
    n_医嘱id := To_Number(Substr(v_Tmp, Instr(v_Tmp, ',') + 1));
    Open c_Cjrow(n_医嘱id);
    Fetch c_Cjrow
      Into r_Cj;
    Close c_Cjrow;
  
    --获取计费状态
    n_记录状态 := Nvl(r_Cj.记录状态, 0);
    n_记录性质 := Nvl(r_Cj.记录性质, 0);
    If n_记录性质 = 2 And n_记录状态 = 1 Then
      n_计费状态 := 3;
    Else
      If n_记录状态 = 0 Then
        n_计费状态 := 0;
      Else
        If n_记录状态 = 1 Then
          n_计费状态 := 1;
        Else
          If n_记录状态 = 2 Or n_记录状态 = 3 Then
            n_计费状态 := 2;
          Else
            n_计费状态 := 0;
          End If;
        End If;
      End If;
    End If;
  
    v_Lisinfo := '<IN>';
    v_Lisinfo := v_Lisinfo || '<TYPE>0</TYPE><ADVICE>'; --
  
    v_Lisinfo := v_Lisinfo || '<SQID>' || r_Cj.医嘱id || '</SQID>'; --
    v_Lisinfo := v_Lisinfo || '<YZID>' || r_Jy.医嘱id || '</YZID>'; --
    v_Lisinfo := v_Lisinfo || '<BRLY>1</BRLY>'; --
    v_Lisinfo := v_Lisinfo || '<BRID>' || r_Pati.病人id || '</BRID>'; --
    v_Lisinfo := v_Lisinfo || '<YE>0</YE>'; --
    v_Lisinfo := v_Lisinfo || '<XM>' || r_Pati.姓名 || '</XM>'; --
    v_Lisinfo := v_Lisinfo || '<XB>' || r_Pati.性别 || '</XB>'; --
    v_Lisinfo := v_Lisinfo || '<NL>' || r_Pati.年龄 || '</NL>'; --
    v_Lisinfo := v_Lisinfo || '<NLSZ>' || Substr(r_Pati.年龄, 1, Instr(r_Pati.年龄, '岁') - 1) || '</NLSZ>'; --
    v_Lisinfo := v_Lisinfo || '<NLDW>' || Substr(r_Pati.年龄, Instr(r_Pati.年龄, '岁')) || '</NLDW>'; --
    v_Lisinfo := v_Lisinfo || '<XMBM>' || r_Pati.诊疗编码 || '</XMBM>'; --
    v_Lisinfo := v_Lisinfo || '<BBLX>' || r_Pati.标本类型 || '</BBLX>'; --
    v_Lisinfo := v_Lisinfo || '<SQR>' || r_Pati.申请人 || '</SQR>'; --
    v_Lisinfo := v_Lisinfo || '<SQSJ>' || To_Char(r_Pati.申请时间, 'yyyy-mm-dd hh24:mi:ss') || '</SQSJ>'; --
    v_Lisinfo := v_Lisinfo || '<SQKS>' || r_Pati.申请科室 || '</SQKS>'; --
    v_Lisinfo := v_Lisinfo || '<CH>' || r_Pati.床号 || '</CH>'; --
    v_Lisinfo := v_Lisinfo || '<JKH>' || r_Pati.健康号 || '</JKH>'; --
    v_Lisinfo := v_Lisinfo || '<BRKS>' || r_Pati.病人科室 || '</BRKS>'; --
    v_Lisinfo := v_Lisinfo || '<JJ>' || r_Pati.紧急标志 || '</JJ>'; --
    v_Lisinfo := v_Lisinfo || '<GHD>' || r_Pati.挂号单 || '</GHD>'; --
    v_Lisinfo := v_Lisinfo || '<MZH>' || r_Pati.门诊号 || '</MZH>'; --
    v_Lisinfo := v_Lisinfo || '<ZYH>' || r_Pati.住院号 || '</ZYH>'; --
    v_Lisinfo := v_Lisinfo || '<CSRQ >' || To_Char(r_Pati.出生日期, 'yyyy-mm-dd hh24:mi:ss') || '</CSRQ>'; --
    v_Lisinfo := v_Lisinfo || '<ZYID>' || r_Pati.主页id || '</ZYID>'; --
    v_Lisinfo := v_Lisinfo || '<QSR>' || r_Pati.签收人 || '</QSR>'; --
    v_Lisinfo := v_Lisinfo || '<QSSJ>' || To_Char(r_Pati.签收时间, 'yyyy-mm-dd hh24:mi:ss') || '</QSSJ>'; --
    v_Lisinfo := v_Lisinfo || '<CYR>' || r_Pati.采样人 || '</CYR>'; --
    v_Lisinfo := v_Lisinfo || '<CYSJ>' || To_Char(r_Pati.采样时间, 'yyyy-mm-dd hh24:mi:ss') || '</CYSJ>'; --
    v_Lisinfo := v_Lisinfo || '<SJR>' || r_Pati.送检人 || '</SJR>'; --
    v_Lisinfo := v_Lisinfo || '<SJSJ>' || To_Char(r_Pati.送检时间, 'yyyy-mm-dd hh24:mi:ss') || '</SJSJ>'; --
    v_Lisinfo := v_Lisinfo || '<JFZT>' || n_计费状态 || '</JFZT>'; --计费状态，单独处理
    v_Lisinfo := v_Lisinfo || '<BQ>' || r_Pati.病区 || '</BQ>'; --
    v_Lisinfo := v_Lisinfo || '<BQBM>' || r_Pati.病区编码 || '</BQBM>'; --
    v_Lisinfo := v_Lisinfo || '<SQKSBM>' || r_Pati.申请科室编码 || '</SQKSBM>'; --
    v_Lisinfo := v_Lisinfo || '<BRKSBM>' || r_Pati.病人科室编码 || '</BRKSBM>'; --
    v_Lisinfo := v_Lisinfo || '<BRLX>' || r_Pati.病人类型 || '</BRLX>'; --
    v_Lisinfo := v_Lisinfo || '<LJZT>' || r_Pati.路径状态 || '</LJZT>'; --
    v_Lisinfo := v_Lisinfo || '<YBTM>' || r_Pati.样本条码 || '</YBTM>'; --
  
    v_Lisinfo := v_Lisinfo || '<CJFS>' || r_Cj.采集方式 || '</CJFS>'; --
    v_Lisinfo := v_Lisinfo || '<CJKS>' || r_Cj.采集科室 || '</CJKS>'; --
    v_Lisinfo := v_Lisinfo || '<YSJE>' || r_Jy.应收金额 || '</YSJE>'; --检验行
    v_Lisinfo := v_Lisinfo || '<SSJE>' || r_Jy.实收金额 || '</SSJE>'; --检验行
    v_Lisinfo := v_Lisinfo || '<FB>' || r_Jy.费别 || '</FB>'; --
    v_Lisinfo := v_Lisinfo || '<ZD></ZD>'; --诊断，暂时无
    v_Lisinfo := v_Lisinfo || '<YEXM></YEXM>'; --婴儿姓名，门诊无婴儿这一说
    v_Lisinfo := v_Lisinfo || '<YEXB></YEXB>'; --婴儿性别，门诊无
    v_Lisinfo := v_Lisinfo || '<YZFX></YZFX>'; --医嘱附项 无
    v_Lisinfo := v_Lisinfo || '<CJYSJE>' || r_Cj.应收金额 || '</CJYSJE>'; --采集行
    v_Lisinfo := v_Lisinfo || '<CJSSJE>' || r_Cj.实收金额 || '</CJSSJE>'; --采集行
  
    v_Lisinfo := v_Lisinfo || '</ADVICE></IN>';
  
    If n_返回信息 = 1 Then
      Select Appendchildxml(x_Lis, '/LISDATA', Xmltype(v_Lisinfo)) Into x_Lis From Dual;
    End If;
  
    If n_调用接 = 1 Then
      Begin
        x_T1 := Xmltype(v_Lisinfo);
        Execute Immediate 'Begin Zl_Thrid_Sendlisapplication(:1,:2); End;'
          Using In x_T1, Out x_T2;
      Exception
        When Others Then
          v_Err_Msg := '调用LIS检验接口出错。';
          Raise Err_Item;
      End;
      If x_T2 Is Not Null Then
        Select Extractvalue(Value(A), 'OUTPUT/ERROR/MSG')
        Into v_Err_Msg
        From Table(Xmlsequence(Extract(x_T2, 'OUTPUT'))) A;
        If v_Err_Msg Is Not Null Then
          Raise Err_Item;
        End If;
      End If;
    End If;
  End Loop;
  If n_返回信息 = 1 Then
    Select Appendchildxml(Xml_Out, '/OUTPUT', x_Lis) Into Xml_Out From Dual;
  End If;
Exception
  When Err_Item Then
    v_Tmp   := '<OUTPUT><ERROR><MSG>' || v_Err_Msg || '</MSG></ERROR></OUTPUT>';
    Xml_Out := Xmltype(v_Tmp);
  When Others Then
    v_Tmp   := '<OUTPUT><ERROR><MSG>错误信息：' || SQLErrM || '</MSG></ERROR></OUTPUT>';
    Xml_Out := Xmltype(v_Tmp); 
End Zl_Third_Advicesavesend;
/

--109786:胡俊勇,2017-06-24,妇幼保健医生站数据接口
CREATE OR REPLACE Procedure Zl_Third_Revokeoutadvice
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:作废门诊医嘱 
  --入参:Xml_In:
  --  <IN>
  --  <YZID></YZID>医嘱ID --主医嘱ID
  --  <CZYXM></CZYXM> 操作员姓名
  --  <CZYBH></CZYBH> 操作员编号 
  --  <CLLIS></CLLIS>处理LIS申请 0-不处理，1-要处理
  --  <JYXM></JYXM> 检验项目，是否是检验项目，0-不是检验，1-是检验
  --  </IN>
  --出参:Xml_Out
  --  <OUTPUT>
  --    <ERROR>
  --      <MSG>错误信息</MSG>
  --    </ERROR>
  --  </OUTPUT>
  --------------------------------------------------------------------------------------------------
  v_Tmp   Varchar2(2000);
  x_T1    Xmltype;
  x_T2    Xmltype;
  v_Error Varchar(255);
  Err_Custom Exception;
Begin
  --参数名：病人接诊控制，模块：1260，忽略
  For R In (Select Extractvalue(Value(A), 'IN/YZID') As 医嘱id, Extractvalue(Value(A), 'IN/CZYXM') As 操作员姓名,
                   Extractvalue(Value(A), 'IN/CZYBH') As 操作员编号, Extractvalue(Value(A), 'IN/CLLIS') As 处理lis,
                   Extractvalue(Value(A), 'IN/JYXM') As 检验项目
            From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A) Loop
    Zl_病人医嘱记录_作废(r.医嘱id, r.操作员编号, r.操作员姓名);
    Zl_病人诊断医嘱_Delete(r.医嘱id);
    If r.检验项目 = 1 And r.处理lis = 1 Then
      --调用LIS处理接口，要用动态SQL
      Begin
        x_T1 := Xmltype('<IN><TYPE>1</TYPE><ADVICE><SQID>' || r.医嘱id || '</SQID></ADVICE></IN>');
        Execute Immediate 'Begin Zl_Thrid_Sendlisapplication(:1,:2); End;'
          Using In x_T1, Out x_T2;
        If x_T2 Is Not Null Then
          Select Extractvalue(Value(A), 'OUTPUT/ERROR/MSG')
          Into v_Error
          From Table(Xmlsequence(Extract(x_T2, 'OUTPUT'))) A;
          If v_Error Is Not Null Then
            Raise Err_Custom;
          End If;
        End If;
      Exception
        When Others Then
          v_Error := '调用LIS检验撤消接口出错。';
          Raise Err_Custom;
      End;
    End If;
  End Loop;
  Xml_Out := Xmltype('<OUTPUT><ERROR><MSG></MSG></ERROR></OUTPUT>');
Exception
  When Err_Custom Then
    v_Tmp   := '<OUTPUT><ERROR><MSG>' || v_Error || '</MSG></ERROR></OUTPUT>';
    Xml_Out := Xmltype(v_Tmp);
  When Others Then
    v_Tmp   := '<OUTPUT><ERROR><MSG>错误信息：' || SQLErrM || '</MSG></ERROR></OUTPUT>';
    Xml_Out := Xmltype(v_Tmp);
End Zl_Third_Revokeoutadvice;
/

--109786:胡俊勇,2017-06-24,妇幼保健医生站数据接口
CREATE OR REPLACE Procedure Zl_Third_Getapplist
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取病人已经申请的检查检验项目
  --入参:Xml_In:
  --  <IN>
  --   <GHDH></GHDH>挂号单号
  --  </IN>
  --出参:Xml_Out
  --  <OUTPUT>
  --     <ITEM>
  --       <ID></ID>医嘱ID，主医嘱ID
  --       <XMMC></XMMC>项目名称
  --       <JG></JG> 结果
  --       <ZT></ZT>状态
  --     </ITEM>
  --  </OUTPUT>
  --------------------------------------------------------------------------------------------------
  v_Tmp   Varchar2(2000);
  v_No    Varchar2(20);
  v_Error Varchar(255);
  Err_Custom Exception;
Begin
  Xml_Out := Xmltype('<OUTPUT></OUTPUT>');
  Select Extractvalue(Value(A), 'IN/GHDH') Into v_No From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  For R In (Select a.Id, a.医嘱内容 As 名称, Null As 结果, Decode(b.执行状态, 1, '完全执行', 2, '拒绝执行', 3, '正在执行', '已申请') As 状态
            From 病人医嘱记录 A, 病人医嘱发送 B, 诊疗项目目录 C
            Where a.Id = b.医嘱id And a.诊疗项目id = c.Id And a.医嘱状态 = 8 And
                  (a.诊疗类别 = 'D' And a.相关id Is Null Or a.诊疗类别 = 'E' And c.操作类型 = '6') And a.挂号单 = v_No
            Order By a.序号) Loop
    v_Tmp := '<ITEM>';
    v_Tmp := v_Tmp || '<ID>' || r.Id || '</ID>';
    v_Tmp := v_Tmp || '<XMMC>' || r.名称 || '</XMMC>';
    v_Tmp := v_Tmp || '<JG>' || r.结果 || '</JG>';
    v_Tmp := v_Tmp || '<ZT>' || r.状态 || '</ZT>';
    v_Tmp := v_Tmp || '</ITEM>';
    Select Appendchildxml(Xml_Out, '/OUTPUT', Xmltype(v_Tmp)) Into Xml_Out From Dual;
  End Loop;
Exception
  When Err_Custom Then
    v_Tmp   := '<OUTPUT><ERROR><MSG>' || v_Error || '</MSG></ERROR></OUTPUT>';
    Xml_Out := Xmltype(v_Tmp);
  When Others Then
    v_Tmp   := '<OUTPUT><ERROR><MSG>错误信息：' || SQLErrM || '</MSG></ERROR></OUTPUT>';
    Xml_Out := Xmltype(v_Tmp);
End Zl_Third_Getapplist;
/

--111315:黄捷,2017-07-11,检查号分隔符提供可选符号
--103994:黄捷,2017-06-30,检查号改成字符型
--109786:胡俊勇,2017-06-24,妇幼保健医生站数据接口
CREATE OR REPLACE Function Nextno
(
  序号_In     In 号码控制表.项目序号%Type,
  科室id_In   In 部门表.Id%Type := Null,
  v_Tag       In Varchar2 := Null,
  号码个数_In In Integer := 1
) Return Varchar2
--    功能：根据特定规则产生新的号码,规则如下：
  --    一、项目序号：
  --       1   病人ID         数字
  --       2   住院号         数字
  --       3   门诊号         数字
  --       6   留观号         数字
  --       10  医嘱发送号     数字,顺序递增编号
  --       x   其它单据号     字符,根据编号规则顺序递增编号,不自动补缺
  --    二、年度位确定原则：
  --       以1990为基数，随年度增长，按“0～9/A～Z”顺序作为年度编码
  --
  --    说明：最大号码-10存入号码控制表,用于并发情况下补缺号(取了号,但未使用)
  --          For Update在并发情况下锁定行,不用Wait选项以避免向调用者返回空
  --          v_Tag 可用其它未指明的参数,目前 有影像检查类别(编码)
  --    返回：最大号码
 Is
  Pragma Autonomous_Transaction;
  v_No     Varchar2(64);
  v_Maxno  号码控制表.最大号码%Type;
  n_Maxno  Number;
  n_Mod    号码控制表.编号规则%Type;
  v_Deptno Varchar2(20);
  v_Year   Varchar2(1);
  v_Tmp    Varchar2(10);

  v_试管编码   Number;
  v_生成条码   Varchar2(20);
  v_编码       Varchar2(10);
  v_医嘱       Varchar2(18);
  v_Error      Varchar2(255);

  Err_Custom Exception;
Begin

  --1.病人ID
  If 序号_In = 1 Then
    Select Nvl(编号规则, 0) Into n_Mod From 号码控制表 Where 项目序号 = 序号_In;

    --从序列取值，用于不要求病人ID必须连续的用户减少并发争用
    If n_Mod = 1 Then
      Select 病人信息_Id.Nextval Into v_No From Dual;
    Else
      Select Nvl(最大号码, '0') Into v_Maxno From 号码控制表 Where 项目序号 = 序号_In For Update;

      Select Nvl(Max(病人id), 0) + 1 Into n_Maxno From 病人信息 Where 病人id >= To_Number(v_Maxno);

      Update 号码控制表 Set 最大号码 = Decode(Sign(n_Maxno - 10), 1, n_Maxno - 10, 1) Where 项目序号 = 序号_In;
      v_No := To_Char(n_Maxno);
    End If;
    --2.住院号
  Elsif 序号_In = 2 Then
    Select Nvl(最大号码, '0'), Nvl(编号规则, 0)
    Into v_Maxno, n_Mod
    From 号码控制表
    Where 项目序号 = 序号_In
    For Update;

    If n_Mod = 0 Then
      --0.顺序编号
      Select Nvl(Max(住院号), 0) + 1 Into n_Maxno From 病人信息 Where 住院号 >= To_Number(v_Maxno);

      Update 号码控制表 Set 最大号码 = Decode(Sign(n_Maxno - 10), 1, n_Maxno - 10, 1) Where 项目序号 = 序号_In;
    Elsif n_Mod = 1 Then
      --1.年月(YYMM)+顺序号(0000)
      v_Tmp := To_Char(Sysdate, 'YYMM');

      Select Nvl(Max(住院号), To_Number(v_Tmp || '0000')) + 1
      Into n_Maxno
      From 病人信息
      Where 住院号 Like To_Number(v_Tmp) || '%' And 住院号 >= To_Number(v_Maxno);
      Update 号码控制表
      Set 最大号码 = Decode(Sign(n_Maxno - 10 - To_Number(v_Tmp || '0000')), 1, n_Maxno - 10, To_Number(v_Tmp || '0001'))
      Where 项目序号 = 序号_In;

    Elsif n_Mod = 2 Then
      --2.年(YYYY)+顺序号(00000)
      v_Tmp := To_Char(Sysdate, 'YYYY');

      Select Nvl(Max(住院号), To_Number(v_Tmp || '00000')) + 1
      Into n_Maxno
      From 病人信息
      Where 住院号 Like To_Number(v_Tmp) || '%' And 住院号 >= To_Number(v_Maxno);
      Update 号码控制表
      Set 最大号码 = Decode(Sign(n_Maxno - 10 - To_Number(v_Tmp || '00000')), 1, n_Maxno - 10, To_Number(v_Tmp || '00001'))
      Where 项目序号 = 序号_In;

    End If;
    v_No := To_Char(n_Maxno);

    --3.门诊号
  Elsif 序号_In = 3 Then
    Select Nvl(最大号码, '0'), Nvl(编号规则, 0)
    Into v_Maxno, n_Mod
    From 号码控制表
    Where 项目序号 = 序号_In
    For Update;

    If n_Mod = 0 Then
      --0.顺序编号

      Select Nvl(Max(门诊号), 0) + 1 Into n_Maxno From 病人信息 Where 门诊号 >= To_Number(v_Maxno);

      Update 号码控制表 Set 最大号码 = Decode(Sign(n_Maxno - 10), 1, n_Maxno - 10, 1) Where 项目序号 = 序号_In;
    Elsif n_Mod = 1 Then
      --1.日期编号YYMMDD
      v_Tmp := To_Char(Sysdate, 'YYMMDD');

      Select Nvl(Max(门诊号), To_Number(v_Tmp || '0000')) + 1
      Into n_Maxno
      From 病人信息
      Where 门诊号 Like To_Number(v_Tmp) || '%' And 门诊号 >= To_Number(v_Maxno);
      Update 号码控制表
      Set 最大号码 = Decode(Sign(n_Maxno - 10 - To_Number(v_Tmp || '0000')), 1, n_Maxno - 10, To_Number(v_Tmp || '0001'))
      Where 项目序号 = 序号_In;

    End If;
    v_No := To_Char(n_Maxno);
    --6.留观号
  Elsif 序号_In = 6 Then
    Select Nvl(最大号码, '0'), Nvl(编号规则, 0)
    Into v_Maxno, n_Mod
    From 号码控制表
    Where 项目序号 = 序号_In
    For Update;

    If n_Mod = 0 Then
      --0.顺序编号
      Select Nvl(Max(留观号), 0) + 1 Into n_Maxno From 病案主页 Where 留观号 >= To_Number(v_Maxno);


      Update 号码控制表 Set 最大号码 = Decode(Sign(n_Maxno - 10), 1, n_Maxno - 10, 1) Where 项目序号 = 序号_In;
    Elsif n_Mod = 1 Then
      --1.年月(YYMM)+顺序号(0000)
      v_Tmp := To_Char(Sysdate, 'YYMM');

      Select Nvl(Max(留观号), To_Number(v_Tmp || '0000')) + 1
      Into n_Maxno
      From 病案主页
      Where 留观号 Like To_Number(v_Tmp) || '%' And 留观号 >= To_Number(v_Maxno);
      Update 号码控制表
      Set 最大号码 = Decode(Sign(n_Maxno - 10 - To_Number(v_Tmp || '0000')), 1, n_Maxno - 10, To_Number(v_Tmp || '0001'))
      Where 项目序号 = 序号_In;

    Elsif n_Mod = 2 Then
      --2.年(YYYY)+顺序号(00000)
      v_Tmp := To_Char(Sysdate, 'YYYY');

      Select Nvl(Max(留观号), To_Number(v_Tmp || '00000')) + 1
      Into n_Maxno
      From 病案主页
      Where 留观号 Like To_Number(v_Tmp) || '%' And 留观号 >= To_Number(v_Maxno);
      Update 号码控制表
      Set 最大号码 = Decode(Sign(n_Maxno - 10 - To_Number(v_Tmp || '00000')), 1, n_Maxno - 10, To_Number(v_Tmp || '00001'))
      Where 项目序号 = 序号_In;

    End If;
    v_No := To_Char(n_Maxno);
    --10.医嘱发送号
  Elsif 序号_In = 10 Then
    Select Nvl(最大号码, '0') Into v_Maxno From 号码控制表 Where 项目序号 = 序号_In For Update;
    v_Maxno := To_Char(To_Number(v_Maxno) + 1);
    Update 号码控制表 Set 最大号码 = v_Maxno Where 项目序号 = 序号_In;
    v_No := v_Maxno;

    --汇总发药号
  Elsif 序号_In = 20 Then
    --YYYYMMDD+5位顺序号(00000)
    Select To_Char(Sysdate, 'yyyymmdd') Into v_Tmp From Dual;
    Select Nvl(最大号码, '0') Into v_Maxno From 号码控制表 Where 项目序号 = 序号_In For Update;

    If v_Maxno = '0' Then
      v_Maxno := v_Tmp || '00001';
    Else
      If Substr(v_Maxno, 1, 8) = v_Tmp Then
        If To_Number(Substr(v_Maxno, 9, 5)) = 99999 Then
          v_Maxno := v_Tmp || '00001';
        Else
          v_Maxno := v_Tmp || Trim(To_Char(To_Number(Substr(v_Maxno, 9, 5)) + 1, '00000'));
        End If;
      Else
        v_Maxno := v_Tmp || '00001';
      End If;
    End If;
    Update 号码控制表 Set 最大号码 = v_Maxno Where 项目序号 = 序号_In;

    v_No := v_Maxno;

  Elsif 序号_In = 123 Then

    ---影像检查号
    v_No := zl_检查号_nextno(科室id_In, v_Tag);

  Elsif 序号_In = 124 Then
    ----------------------------------------------------------------------------------------------------------------------------
    --体检健康号

    Begin
      Select Nvl(编号规则, 0) Into n_Mod From 号码控制表 Where 项目序号 = 序号_In;
    Exception
      When Others Then
        v_Error := '号码控制表中不存在序号为' || 序号_In || '的号码';
        Raise Err_Custom;
    End;

    If n_Mod = 0 Then
      --顺序编号
      Select Nvl(Zl_To_Number(最大号码), 0) + 号码个数_In
      Into v_Maxno
      From 号码控制表
      Where 项目序号 = 序号_In
      For Update;
      Update 号码控制表 Set 最大号码 = v_Maxno Where 项目序号 = 序号_In;
    Else
      --前缀+顺序号
      Update 号码编号表 Set 最大号码 = 最大号码 Where 项目序号 = 序号_In And 号码前缀 = v_Tag;
      If Sql%Rowcount = 0 Then
        Insert Into 号码编号表
          (项目序号, 号码前缀, 日期, 最大号码)
          Select 序号_In, v_Tag, Sysdate, '' From Dual;
      End If;

      Select Nvl(Zl_To_Number(最大号码), 0) + 号码个数_In
      Into n_Maxno
      From 号码编号表 a
      Where a.项目序号 = 序号_In And a.号码前缀 = v_Tag;

      If Substr(n_Maxno, 1, Length(v_Tag)) <> v_Tag Then
        --进位了
        Select Nvl(Zl_To_Number(Substr(最大号码, Length(v_Tag) + 1)), 0) + 号码个数_In
        Into n_Maxno
        From 号码编号表 a
        Where a.项目序号 = 序号_In And a.号码前缀 = v_Tag;
        Select v_Tag || n_Maxno Into v_Maxno From Dual;
      Else
        If n_Maxno = 号码个数_In Then
          v_Maxno := v_Tag || To_Char(号码个数_In);
        Else
          v_Maxno := n_Maxno;
        End If;
      End If;

      Update 号码编号表 Set 最大号码 = v_Maxno Where 项目序号 = 序号_In And 号码前缀 = v_Tag;
    End If;
    v_No := v_Maxno;

  Elsif 序号_In = 125 Then
    --这里是为了减少号码控制表的锁定时间
    If n_Mod = 0 Then
      Begin
        If v_Tag Is Null Then
          Select b.试管编码
          Into v_试管编码
          From 病人医嘱记录 A, 诊疗项目目录 B
          Where a.诊疗项目id = b.Id And a.Id = 科室id_In And b.试管编码 Is Not Null;
        Else
          Select b.试管编码
          Into v_试管编码
          From 诊疗项目目录 B
          Where b.Id = To_Number(v_Tag) And b.试管编码 Is Not Null;
        End If;
      Exception
        When Others Then
          v_Error := '没有找到检验项目对应的管码！';
          Raise Err_Custom;
      End;
    Else
      Begin
        If v_Tag Is Null Then
          Select b.试管编码, c.编码
          Into v_试管编码, v_编码
          From 病人医嘱记录 A, 诊疗项目目录 B, 诊疗检验类型 C
          Where a.诊疗项目id = b.Id And a.Id = 科室id_In And b.操作类型 = c.名称 And b.试管编码 Is Not Null;
        Else
          Select b.试管编码, c.编码
          Into v_试管编码, v_编码
          From 诊疗项目目录 B, 诊疗检验类型 C
          Where b.Id = To_Number(v_Tag) And b.操作类型 = c.名称 And b.试管编码 Is Not Null;
        End If;
      Exception
        When Others Then
          v_Error := '没有找到检验项目对应的管码和编码！';
          Raise Err_Custom;
      End;
    End If;

    Select Nvl(最大号码, '0'), Nvl(编号规则, 0)
    Into v_Maxno, n_Mod
    From 号码控制表
    Where 项目序号 = 序号_In
    For Update;

    If n_Mod = 0 Then
      --按医嘱生成

      v_医嘱 := 科室id_In;
      If Length(v_医嘱) > 12 Then
        v_医嘱 := Substr(v_医嘱, Length(v_医嘱) - 11);
      Else
        v_医嘱 := Lpad(v_医嘱, 12, '0');
      End If;
      if Length(ltrim(v_医嘱,'0'))>8 then
         Select v_试管编码 || LPad(Substr(v_医嘱, Length(v_医嘱) - (13 - Length(v_试管编码) - 2)), (13 - Length(v_试管编码)), '0')
          Into v_生成条码
         From Dual;
      else
         Select v_试管编码 || LPad(Substr(v_医嘱, Length(v_医嘱) - (12 - Length(v_试管编码) - 2)), (12 - Length(v_试管编码)), '0')
         Into v_生成条码
         From Dual;
      end if;
      v_No := v_生成条码;
    Else
      --按"小组编号（1位）+管码(2位)+日期(6位)+顺序号(3)位"生成条码
      Begin
        Select 最大号码
        Into v_Maxno
        From 号码编号表
        Where 项目序号 = 序号_In And 号码前缀 = v_编码 || v_试管编码 And Trunc(日期) = Trunc(Sysdate)
        For Update;
        v_Maxno := v_Maxno + 1;
        If Length(v_Maxno) <= 3 Then
          v_Maxno := Lpad(v_Maxno, 3, '0');
        End If;
        v_No := v_编码 || v_试管编码 || To_Char(Trunc(Sysdate), 'yymmdd') || v_Maxno;
        Update 号码编号表
        Set 日期 = Trunc(Sysdate), 最大号码 = v_Maxno
        Where 号码前缀 = v_编码 || v_试管编码 And Trunc(日期) = Trunc(Sysdate);
      Exception
        When Others Then
          Update 号码编号表 Set 日期 = Trunc(Sysdate), 最大号码 = 1 Where 号码前缀 = v_编码 || v_试管编码;
          If Sql%Rowcount = 0 Then
            Insert Into 号码编号表
              (项目序号, 号码前缀, 日期, 最大号码)
            Values
              (序号_In, v_编码 || v_试管编码, Trunc(Sysdate), 1);
          End If;
          v_No := v_编码 || v_试管编码 || To_Char(Trunc(Sysdate), 'yymmdd') || '001';
      End;
    End If;
    --卫材条码序号
  Elsif 序号_In = 126 Then
    --12位顺序号
    Select Nvl(最大号码, '0') Into v_Maxno From 号码控制表 Where 项目序号 = 序号_In For Update;

    If v_Maxno = '0' Then
      v_Maxno := '000000000001';
    Else
      v_Maxno := Trim(To_Char(To_Number(v_Maxno) + 1, '000000000000'));
    End If;
    Update 号码控制表 Set 最大号码 = v_Maxno Where 项目序号 = 序号_In;

    v_No := v_Maxno;
  Elsif 序号_In = 135 Then
    --药品卫材调价
    Begin
      Select Nvl(编号规则, 0) Into n_Mod From 号码控制表 Where 项目序号 = 序号_In;
    Exception
      When Others Then
        v_Error := '号码控制表中不存在序号为' || 序号_In || '的号码';
        Raise Err_Custom;
    End;
    --1.年月(YYYYMM)+顺序号(0000)
    v_Tmp := To_Char(Sysdate, 'YYYYMM');
    Select Nvl(最大号码, '0') Into v_Maxno From 号码控制表 Where 项目序号 = 序号_In For Update;

    If v_Maxno = '0' Then
      v_Maxno := v_Tmp || '0001';
    Else
      If Substr(v_Maxno, 1, 6) = v_Tmp Then
        v_Maxno := v_Tmp || Trim(To_Char(To_Number(Substr(v_Maxno, 7, 4)) + 1, '0000'));
      Else
        v_Maxno := v_Tmp || '0001';
      End If;
    End If;
    Update 号码控制表 Set 最大号码 = v_Maxno Where 项目序号 = 序号_In;
    v_No := v_Maxno;
  Elsif 序号_In = 136 Then
    --YYMMDD+5位顺序号(00000)
    Select To_Char(Sysdate, 'yymmdd') Into v_Tmp From Dual;
    Select Nvl(最大号码, '0') Into v_Maxno From 号码控制表 Where 项目序号 = 序号_In For Update;

    If v_Maxno = '0' Then
      v_Maxno := v_Tmp || '00001';
    Else
      If Substr(v_Maxno, 1, 6) = v_Tmp Then
        If To_Number(Substr(v_Maxno, 7, 5)) = 99999 Then
          v_Maxno := v_Tmp || '00001';
        Else
          v_Maxno := v_Tmp || Trim(To_Char(To_Number(Substr(v_Maxno, 7, 5)) + 1, '00000'));
        End If;
      Else
        v_Maxno := v_Tmp || '00001';
      End If;
    End If;
    Update 号码控制表 Set 最大号码 = v_Maxno Where 项目序号 = 序号_In;
    v_No := v_Maxno;
  Elsif 序号_In = 131 Then
    --体检报到号
    Select Nvl(最大号码, '0') Into v_Maxno From 号码控制表 Where 项目序号 = 序号_In For Update;
    v_Maxno := To_Char(To_Number(v_Maxno) + 1);
    Update 号码控制表 Set 最大号码 = v_Maxno Where 项目序号 = 序号_In;
    v_No := v_Maxno;
    --其它单据号
  Else
    Begin
      Select Nvl(编号规则, 0) Into n_Mod From 号码控制表 Where 项目序号 = 序号_In;
    Exception
      When Others Then
        v_Error := '号码控制表中不存在序号为' || 序号_In || '的号码';
        Raise Err_Custom;
    End;

    --如果规则是按科室编号顺序产生，但又未设置科室编码，则采取按年顺序编号
    If n_Mod = 2 And 序号_In <> 122 Then
      Begin
        Select 编号 Into v_Deptno From 科室号码表 Where 科室id = 科室id_In And 项目序号 = 序号_In;
      Exception
        When Others Then
          Null;
      End;
      If v_Deptno Is Null Then
        n_Mod := 0;
      End If;
    End If;

    Select Decode(Sign(Intyear - 10), -1, To_Char(Intyear, '9'), Chr(55 + Intyear))
    Into v_Year
    From (Select To_Number(To_Char(Sysdate, 'yyyy'), '9999') - 1990 As Intyear From Dual);

    If n_Mod = 0 Then
      --0.按年顺序编号
      Select Nvl(最大号码, '0') Into v_No From 号码控制表 Where 项目序号 = 序号_In For Update;

      --第2位增长方式:0-9,A-Z
      Select Bit1 || Decode(Sign(Ascii(Bit2) - Ascii('9')),
                             -1,
                             Lpad(To_Number(Bit28) + 1, 7, '0'),
                             Decode(Bit38,
                                    '999999',
                                    Decode(Bit2, '9', 'A', Chr(Ascii(Bit2) + 1)) || '000000',
                                    Bit2 || Lpad(To_Number(Bit38) + 1, 6, '0')))
      Into v_No
      From (Select Substr(Maxno, 1, 1) As Bit1, Substr(Maxno, 2, 1) As Bit2, Substr(Maxno, 2) As Bit28,
                    Substr(Maxno, 3) As Bit38
             From (Select Decode(v_No,
                                   '0',
                                   v_Year || '0000000',
                                   Decode(Sign(Ascii(Substr(v_No, 1, 1)) - Ascii(v_Year)), -1, v_Year || '0000000', v_No)) As Maxno
                    From Dual));

      Update 号码控制表 Set 最大号码 = v_No Where 项目序号 = 序号_In;

    Elsif n_Mod = 1 Then
      --1.按年+日顺序编号:YDDD0000
      Select Nvl(最大号码, '0') Into v_No From 号码控制表 Where 项目序号 = 序号_In For Update;
      Select v_Year || Lpad(Trunc(Sysdate - Trunc(Sysdate, 'YYYY') + 1, 0), 3, '0') || '0000' Into v_Maxno From Dual;
      If v_No < v_Maxno Then
        v_No := v_Maxno;
      End If;
      v_No := Substr(v_No, 1, 4) || Lpad(To_Number(Substr(v_No, 5, 4)) + 1, 4, '0');
      Update 号码控制表 Set 最大号码 = v_No Where 项目序号 = 序号_In;

    Elsif n_Mod = 2 Then
      If 序号_In = 122 Then
        --2.按科室编码+YYMMDD+3位顺序号:2201090728001
        Select Count(*) Into n_Maxno From 科室号码表 Where 项目序号 = 序号_In And 科室id = 科室id_In;
        If Nvl(n_Maxno, 0) = 0 Then
          Insert Into 科室号码表 (项目序号, 科室id, 最大号码, 编号) Values (序号_In, 科室id_In, Null, Null);
          Commit;
        End If;

        Select 编码 Into v_Deptno From 部门表 Where Id = 科室id_In;
        Select Nvl(最大号码, '-') Into v_No From 科室号码表 Where 项目序号 = 序号_In And 科室id = 科室id_In For Update;
        v_Tmp := To_Char(Sysdate, 'YYMMDD');

        If Substr(v_No, 1, Length(v_Deptno || v_Tmp)) = v_Deptno || v_Tmp Then
          v_No := v_Deptno || v_Tmp || Lpad(To_Number(Substr(v_No, Length(v_Deptno || v_Tmp) + 1)) + 1, 3, '0');
        Else
          v_No := v_Deptno || v_Tmp || Lpad('1', 3, '0');
        End If;
        Update 科室号码表 Set 最大号码 = v_No Where 项目序号 = 序号_In And 科室id = 科室id_In;

      Else
        --2.按年+科室编号+月+顺序号:YKDD0000
        Begin
          --符号-的asscii为45,用于和year比较(0的ascii为48)
          Select 编号, Nvl(最大号码, '-')
          Into v_Deptno, v_No
          From 科室号码表
          Where 项目序号 = 序号_In And Nvl(科室id, 0) = Nvl(科室id_In, 0)
          For Update;
        Exception
          When Others Then
            Null;
        End;
        If v_Deptno Is Null Then
          v_Error := '科室未设置编号，无法产生号码！';
          Raise Err_Custom;
        Else
          v_Tmp := To_Char(Sysdate, 'MM');
          Select Substr(Maxno, 1, 4) || Lpad(To_Number(Substr(Maxno, 5, 4)) + 1, 4, '0')
          Into v_No
          From (Select Decode(Sign(Ascii(Substr(v_No, 1, 1)) - Ascii(v_Year)),
                                -1,
                                v_Year || v_Deptno || v_Tmp || '0000',
                                Decode(Sign(To_Number(Substr(v_No, 3, 2)) - To_Number(v_Tmp)),
                                       -1,
                                       v_Year || v_Deptno || v_Tmp || '0000',
                                       v_No)) As Maxno
                 From Dual);
          Update 科室号码表 Set 最大号码 = v_No Where 项目序号 = 序号_In And Nvl(科室id, 0) = Nvl(科室id_In, 0);

        End If;
      End If;
    Elsif n_Mod = 3 Then

      --按年月日+000001生成
      Select Substr(To_Char(Sysdate, 'yyyymmdd'), 3, 6) Into v_Tmp From Dual;
      Select Nvl(最大号码, '0') Into v_Maxno From 号码控制表 Where 项目序号 = 序号_In For Update;

      If v_Maxno = '0' Then
        v_Maxno := v_Tmp || '000001';
      Else
        If Substr(v_Maxno, 1, 6) = v_Tmp Then
          v_Maxno := v_Tmp || Trim(To_Char(To_Number(Substr(v_Maxno, 7, 6)) + 1, '000000'));
        Else
          v_Maxno := v_Tmp || '000001';
        End If;
      End If;
      Update 号码控制表 Set 最大号码 = v_Maxno Where 项目序号 = 序号_In;
      v_No := v_Maxno;

    Elsif n_Mod = 5 Then
      --1.年月(YYYYMM)+顺序号(000000)
      v_Tmp := To_Char(Sysdate, 'YYYYMM');
      Select Nvl(最大号码, '0') Into v_Maxno From 号码控制表 Where 项目序号 = 序号_In For Update;

      If v_Maxno = '0' Then
        v_Maxno := v_Tmp || '000001';
      Else
        If Substr(v_Maxno, 1, 6) = v_Tmp Then
          v_Maxno := v_Tmp || Trim(To_Char(To_Number(Substr(v_Maxno, 7, 6)) + 1, '000000'));
        Else
          v_Maxno := v_Tmp || '000001';
        End If;
      End If;
      Update 号码控制表 Set 最大号码 = v_Maxno Where 项目序号 = 序号_In;
      v_No := v_Maxno;
    Else
      v_Error := '序号为' || 序号_In || '的号码,其规则值:' || n_Mod || ',当前系统不支持！';
      Raise Err_Custom;
    End If;
  End If;

  Commit;
  Return v_No;
Exception
  When Err_Custom Then
    Rollback;
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Rollback;
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Nextno;
/

--110517:黄捷,2017-06-23,无报告完成不删除RIS报告
Create Or Replace Procedure Zl_影像检查_State
(
  医嘱id_In     影像检查记录.医嘱id%Type,
  发送号_In     影像检查记录.发送号%Type,
  执行过程_In   病人医嘱发送.执行过程%Type,
  删除报告_In   Number := 0, --1删除报告，无报告完成
  操作员编号_In 人员表.编号%Type := Null,
  操作员姓名_In 人员表.姓名%Type := Null,
  执行部门id_In 门诊费用记录.执行部门id%Type := Null,
  完成时间_In   病人医嘱发送.完成时间%Type := Null
) Is

  v_Temp     Varchar2(255);
  v_人员编号 人员表.编号%Type;
  v_人员姓名 人员表.姓名%Type;
  v_部门id   部门表.Id%Type;
  n_报告id   Number;
  v_完成人   人员表.姓名%Type;
  v_完成时间 Date;
  v_Risid    Number;

Begin

  --取得报告完成人和时间
  If 执行过程_In = 6 Then
    v_完成人   := 操作员姓名_In;
    v_完成时间 := 完成时间_In;
  End If;

  --取当前操作人员
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null And 执行部门id_In Is Not Null Then
    v_人员编号 := 操作员编号_In;
    v_人员姓名 := 操作员姓名_In;
    v_部门id   := 执行部门id_In;
  Else
    v_Temp     := Zl_Identity;
    v_部门id   := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;

  n_报告id := 0;

  If 删除报告_In <> 0 Then
    Begin
      Select 病历id, Risid Into n_报告id, v_Risid From 病人医嘱报告 Where 医嘱id = 医嘱id_In;
    Exception
      When Others Then
        Null;
    End;
    If v_Risid Is Null Then
      Delete 电子病历记录 Where Id = n_报告id;
      Zl_影像报告标记_Clear(医嘱id_In);
    End If;
  End If;

  --只更新跟主医嘱执行状态相同的部位医嘱，跟主医嘱执行状态不同的部位医嘱，是被分部位取消执行的
  Update 病人医嘱发送 a
  Set a.执行状态 = Decode(执行过程_In, 6, 1, 3), a.执行过程 = 执行过程_In, a.完成人 = v_完成人, a.完成时间 = v_完成时间, a.采样时间 = Sysdate
  Where a.发送号 + 0 = 发送号_In
  And a.医嘱id In (Select b.Id
                From 病人医嘱记录 b, 病人医嘱发送 c
                Where b.Id = c.医嘱id
                And (b.Id = 医嘱id_In Or b.相关id = 医嘱id_In)
                And c.执行状态 = (Select d.执行状态 From 病人医嘱发送 d Where d.医嘱id = 医嘱id_In));

  If 执行过程_In = 5 Then
    Update 影像检查记录
    Set 完成人 = Null
    Where 医嘱id = 医嘱id_In
    And 发送号 = 发送号_In;
  
    Begin
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 8, 医嘱id_In || ',' || 发送号_In;
    Exception
      When Others Then
        Null;
    End;
  Elsif 执行过程_In = 6 Then
    Update 影像检查记录
    Set 完成人 = v_人员姓名
    Where 医嘱id = 医嘱id_In
    And 发送号 = 发送号_In;
  
    --如果是检查完成，则不需要判断参数“执行费用_In”，检查完成时，必须执行费用
    Zl_影像费用执行(医嘱id_In, 发送号_In, 执行过程_In, 0, v_人员编号, v_人员姓名, v_部门id);
  End If;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_影像检查_State;
/

--92335:李南春,2017-06-22,三方支付新模式及过程拆分
CREATE OR REPLACE Procedure Zl_医疗卡记录_Insert
(
  --参数：发卡类型=0-发卡,1-补卡,2-换卡(相当于重打)
  --      换卡时,单据号_IN传入的是原发/补卡的单据号。
  --      补卡/换卡后,再换卡时是以最后一次卡号为准。
  发卡类型_In   Number,
  单据号_In     住院费用记录.No%Type,
  病人id_In     住院费用记录.病人id%Type,
  主页id_In     住院费用记录.主页id%Type,
  标识号_In     住院费用记录.标识号%Type,
  费别_In       住院费用记录.费别%Type,
  卡类别id_In   医疗卡类别.Id%Type,
  原卡号_In     病人医疗卡信息.卡号%Type,
  医疗卡号_In   病人医疗卡信息.卡号%Type,
  变动原因_In   病人医疗卡变动.变动原因%Type,
  密码_In       病人信息.卡验证码%Type,
  姓名_In       住院费用记录.姓名%Type,
  性别_In       住院费用记录.性别%Type,
  年龄_In       住院费用记录.年龄%Type,
  病人病区id_In 住院费用记录.病人病区id%Type,
  病人科室id_In 住院费用记录.病人科室id%Type,
  收费细目id_In 住院费用记录.收费细目id%Type,
  收费类别_In   住院费用记录.收费类别%Type,
  计算单位_In   住院费用记录.计算单位%Type,
  收入项目id_In 住院费用记录.收入项目id%Type,
  收据费目_In   住院费用记录.收据费目%Type,
  标准单价_In   住院费用记录.标准单价%Type,
  执行部门id_In 住院费用记录.执行部门id%Type,
  开单部门id_In 住院费用记录.开单部门id%Type,
  操作员编号_In 住院费用记录.操作员编号%Type,
  操作员姓名_In 住院费用记录.操作员姓名%Type,
  加班标志_In   住院费用记录.加班标志%Type,
  发卡时间_In   住院费用记录.登记时间%Type,
  领用id_In     票据使用明细.领用id%Type,
  Ic卡号_In     病人信息.Ic卡号%Type := Null,
  应收金额_In   住院费用记录.应收金额%Type,
  实收金额_In   住院费用记录.实收金额%Type,
  结算方式_In   病人预交记录.结算方式%Type,
  刷卡类别id_In 病人预交记录.卡类别id%Type,
  消费卡_In     Integer := 0,
  刷卡卡号_In   病人医疗卡信息.卡号%Type,
  结帐id_In     病人预交记录.结帐id%Type,
  交易流水号_In 病人预交记录.交易流水号%Type := Null,
  交易说明_In   病人预交记录.交易说明%Type := Null,
  合作单位_In   病人预交记录.合作单位%Type := Null,
  摘要_In       住院费用记录.摘要%Type := Null,
  更新交款余额_In  Number := 1
) As

  --更新交款余额_In  Number := 1 --是否更新人员交款余额，主要是处理统一操作员登录多台自助机的情况。
  Cursor c_Precard Is
    Select ID As 费用id From 住院费用记录 Where 记录性质 = 5 And 实际票号 = 原卡号_In And 病人id = 病人id_In;
  r_Cardrow c_Precard%RowType;

  Cursor c_医疗卡 Is
    Select ID, 编码, 名称, 短名, 前缀文本, 卡号长度, 缺省标志, 是否固定, 是否严格控制, Nvl(是否自制, 0) As 是否自制,
           Nvl(是否存在帐户, 0) As 是否存在帐户, Nvl(是否全退, 0) As 是否全退, 部件, 备注, 特定项目, 结算方式, 是否启用, 卡号密文, Nvl(是否重复使用, 0) As 是否重复使用
    From 医疗卡类别
    Where ID = 卡类别id_In;
  r_医疗卡 c_医疗卡%RowType;

  v_费用id         住院费用记录.Id%Type;
  v_结帐id         住院费用记录.结帐id%Type;
  v_收回id         票据打印内容.Id%Type;
  v_打印id         票据打印内容.Id%Type;
  n_回收次数       票据使用明细.回收次数%Type;
  n_性质           票据使用明细.性质%Type;
  n_返回值         病人余额.费用余额%Type;
  n_Count          Number(18);
  n_预交id         病人预交记录.Id%Type;
  n_消费卡id       消费卡目录.Id%Type;
  n_自制卡         Number;
  n_医疗卡重复使用 Number(3);
  Err_Item Exception;
  v_Err_Msg  Varchar2(500);
  n_组id     财务缴款分组.Id%Type;
  n_变动类型 Number;
Begin
  n_组id := Zl_Get组id(操作员姓名_In);
  Open c_医疗卡;
  Fetch c_医疗卡
    Into r_医疗卡;
  If c_医疗卡%RowCount = 0 Then
    Close c_医疗卡;
    v_Err_Msg := '[ZLSOFT]没有发现原医疗卡的相应类别,不能继续操作！[ZLSOFT]';
    Raise Err_Item;
  End If;

  n_医疗卡重复使用 := Nvl(r_医疗卡.是否重复使用, 0);
  Close c_医疗卡;
  If Not 结算方式_In Is Null Then
    If Nvl(结帐id_In, 0) <> 0 Then
      v_结帐id := 结帐id_In;
    Else
      Select 病人结帐记录_Id.Nextval Into v_结帐id From Dual;
    End If;
  End If;
  If 发卡类型_In <> 2 Then
    --发卡和补卡
    Select 病人费用记录_Id.Nextval Into v_费用id From Dual;

    Insert Into 住院费用记录
      (ID, 记录性质, 记录状态, NO, 实际票号, 序号, 病人id, 主页id, 病人病区id, 病人科室id, 标识号, 姓名, 性别, 年龄, 费别, 记帐费用, 门诊标志, 加班标志, 开单部门id, 开单人,
       操作员编号, 操作员姓名, 发生时间, 登记时间, 收费细目id, 收费类别, 计算单位, 付数, 数次, 发药窗口, 附加标志, 执行部门id, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 结帐id,
       结帐金额, 缴款组id, 结论,摘要)
    Values
      (v_费用id, 5, 1, 单据号_In, 医疗卡号_In, 1, 病人id_In, Decode(主页id_In, 0, Null, 主页id_In),
       Decode(病人病区id_In, 0, Null, 病人病区id_In), Decode(病人科室id_In, 0, Null, 病人科室id_In), Decode(标识号_In, 0, Null, 标识号_In),
       姓名_In, 性别_In, 年龄_In, 费别_In, Decode(结算方式_In, Null, 1, 0), 3, 加班标志_In, 开单部门id_In, 操作员姓名_In, 操作员编号_In, 操作员姓名_In,
       发卡时间_In, 发卡时间_In, 收费细目id_In, 收费类别_In, 计算单位_In, 1, 1, 医疗卡号_In, 发卡类型_In, 执行部门id_In, 收入项目id_In, 收据费目_In, 标准单价_In,
       应收金额_In, 实收金额_In, v_结帐id, Decode(结算方式_In, Null, Null, 实收金额_In), n_组id, 卡类别id_In, 摘要_In);

    --如果是现收医疗卡费用，则将结算填入病人预交记录
    If Not 结算方式_In Is Null Then
      Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      Insert Into 病人预交记录
        (ID, NO, 记录性质, 记录状态, 病人id, 主页id, 科室id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 摘要, 缴款组id, 卡类别id, 卡号, 结算卡序号, 交易流水号,
         交易说明, 结算序号, 合作单位, 结算性质)
      Values
        (n_预交id, 单据号_In, 5, 1, 病人id_In, Decode(主页id_In, 0, Null, 主页id_In), Decode(病人科室id_In, 0, Null, 病人科室id_In),
         结算方式_In, 发卡时间_In, 操作员编号_In, 操作员姓名_In, 实收金额_In, v_结帐id, '医疗卡费用', n_组id, Decode(消费卡_In, 0, 刷卡类别id_In, Null),
         刷卡卡号_In, Decode(消费卡_In, 0, Null, 刷卡类别id_In), 交易流水号_In, 交易说明_In, v_结帐id, 合作单位_In, 5);

      If 消费卡_In = 1 And 刷卡卡号_In Is Not Null Then

        n_消费卡id := Null;
        Begin
          Select Nvl(自制卡, 0), 1 Into n_自制卡, n_Count From 卡消费接口目录 Where 编号 = 刷卡类别id_In;
        Exception
          When Others Then
            n_Count := 0;
        End;
        If n_Count = 0 Then
          v_Err_Msg := '[ZLSOFT]没有发现原结算卡的相应类别,不能继续操作！[ZLSOFT]';
          Raise Err_Item;
        End If;
        If n_自制卡 = 1 Then
          Select ID
          Into n_消费卡id
          From 消费卡目录
          Where 接口编号 = 刷卡类别id_In And 卡号 = 刷卡卡号_In And
                序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = 刷卡类别id_In And 卡号 = 刷卡卡号_In);
        End If;
        Zl_病人卡结算记录_Insert(刷卡类别id_In, n_消费卡id, 结算方式_In, 实收金额_In, 刷卡卡号_In, Null, Null, Null, v_结帐id, n_预交id);
      End If;
    End If;

    --发卡使用票据
    Select 票据打印内容_Id.Nextval Into v_打印id From Dual;
    Insert Into 票据打印内容 (ID, 数据性质, NO) Values (v_打印id, 5, 单据号_In);
    n_回收次数 := 0;
    If n_医疗卡重复使用 = 1 Then
      Select Nvl(Max(回收次数), 0), Nvl(Max(性质), 0)
      Into n_回收次数, n_性质
      From 票据使用明细
      Where 票种 = 5 And 号码 = 医疗卡号_In;
      If n_回收次数 > 0 Or n_性质 > 0 Then
        n_回收次数 := n_回收次数 + 1;
      End If;
    Else
      --需要检查是否存在票据使用明细，如果存在，肯定会发生错误
      Select Nvl(Max(性质), 0)
      Into n_性质
      From 票据使用明细 A, 票据领用记录 B
      Where a.票种 = 5 And a.号码 = 医疗卡号_In And Nvl(a.领用id, 0) = Nvl(领用id_In, 0) And a.领用id = b.Id;
      If n_性质 <> 0 Then
        v_Err_Msg := '[ZLSOFT]卡号:' || 医疗卡号_In || ' 已经使用，不能再进行发卡操作,请检查![ZLSOFT]';
        Raise Err_Item;
      End If;
    End If;

    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 回收次数, 打印id, 使用时间, 使用人)
    Values
      (票据使用明细_Id.Nextval, 5, 医疗卡号_In, 1, 1, 领用id_In, Decode(n_回收次数, 0, Null, n_回收次数), v_打印id, 发卡时间_In, 操作员姓名_In);
    --如果是回收,再发的,则不减剩余数量
    If Nvl(n_回收次数, 0) = 0 Then
      --该批领用状态变化
      Update 票据领用记录
      Set 当前号码 = 医疗卡号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
      Where ID = Nvl(领用id_In, 0);
    End If;

    --相关汇总表的处理
    If 结算方式_In Is Null Then
      --汇总'病人余额'
      Update 病人余额
      Set 费用余额 = Nvl(费用余额, 0) + 实收金额_In
      Where 性质 = 1 And 病人id = 病人id_In And Nvl(类型, 2) = Decode(Nvl(主页id_In, 0), 0, 1, 2)
      Returning 费用余额 Into n_返回值;

      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 预交余额, 费用余额)
        Values
          (病人id_In, 1, Decode(Nvl(主页id_In, 0), 0, 1, 2), 0, 实收金额_In);
        n_返回值 := 实收金额_In;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;

      --汇总'病人未结费用'
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) + 实收金额_In
      Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0) And Nvl(病人病区id, 0) = Nvl(病人病区id_In, 0) And
            Nvl(病人科室id, 0) = Nvl(病人科室id_In, 0) And Nvl(开单部门id, 0) = Nvl(开单部门id_In, 0) And
            Nvl(执行部门id, 0) = Nvl(执行部门id_In, 0) And 收入项目id + 0 = 收入项目id_In And 来源途径 = 3;

      If Sql%RowCount = 0 Then
        Insert Into 病人未结费用
          (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
        Values
          (病人id_In, Decode(主页id_In, 0, Null, 主页id_In), Decode(病人病区id_In, 0, Null, 病人病区id_In),
           Decode(病人科室id_In, 0, Null, 病人科室id_In), 开单部门id_In, 执行部门id_In, 收入项目id_In, 3, 实收金额_In);
      End If;

    Else
      --汇总"人员缴款余额"
      If Nvl(更新交款余额_In,1) = 1 then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + 实收金额_In
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = 结算方式_In
        Returning 余额 Into n_返回值;

        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, 结算方式_In, 1, 实收金额_In);
          n_返回值 := 实收金额_In;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = 结算方式_In And Nvl(余额, 0) = 0;
        End If;
      End IF;
    End If;

  Else
    --处理换卡方式
    --首先查找需要换卡的原医疗卡费用记录
    Open c_Precard;
    Fetch c_Precard
      Into r_Cardrow;

    If c_Precard%RowCount = 0 Then
      Close c_Precard;
      v_Err_Msg := '[ZLSOFT]没有发现原医疗卡发放记录,换卡操作失败！[ZLSOFT]';
      Raise Err_Item;
    Else
      --仅当有原费用记录时才处理
      --重打收回票据
      Begin
        Select ID
        Into v_收回id
        From (Select b.Id
               From 票据使用明细 A, 票据打印内容 B
               Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 5 And b.No = 单据号_In
               Order By a.使用时间 Desc)
        Where Rownum < 2;
      Exception
        When Others Then
          Null;
      End;

      If v_收回id Is Not Null Then
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 回收次数, 打印id, 使用时间, 使用人)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 4, 领用id, 回收次数, 打印id, 发卡时间_In, 操作员姓名_In
          From 票据使用明细
          Where 打印id = v_收回id And 票种 = 5 And 性质 = 1;
      End If;

      --重打发出票据
      Select 票据打印内容_Id.Nextval Into v_打印id From Dual;

      Insert Into 票据打印内容 (ID, 数据性质, NO) Values (v_打印id, 5, 单据号_In);
      n_回收次数 := 0;
      If n_医疗卡重复使用 = 1 Then
        Select Nvl(Max(回收次数), 0), Nvl(Max(性质), 0)
        Into n_回收次数, n_性质
        From 票据使用明细
        Where 票种 = 5 And 号码 = 医疗卡号_In;
        If n_回收次数 > 0 Or n_性质 > 0 Then
          n_回收次数 := n_回收次数 + 1;
        End If;
      Else
        --需要检查是否存在票据使用明细，如果存在，肯定会发生错误
        Select Nvl(Max(性质), 0)
        Into n_性质
        From 票据使用明细 A, 票据领用记录 B
        Where a.票种 = 5 And a.号码 = 医疗卡号_In And Nvl(a.领用id, 0) = Nvl(领用id_In, 0) And a.领用id = b.Id;
        If n_性质 <> 0 Then
          v_Err_Msg := '[ZLSOFT]新卡号:' || 医疗卡号_In || ' 已经使用，请换一张新卡,请检查![ZLSOFT]';
          Raise Err_Item;
        End If;

      End If;

      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 回收次数, 打印id, 使用时间, 使用人)
      Values
        (票据使用明细_Id.Nextval, 5, 医疗卡号_In, 1, Decode(v_收回id, Null, 1, 3), 领用id_In, Decode(n_回收次数, 0, Null, n_回收次数), v_打印id,
         发卡时间_In, 操作员姓名_In);
      --如果是回收,再发的,则不减剩余数量
      If Nvl(n_回收次数, 0) = 0 Then
        --领用状态变化
        Update 票据领用记录
        Set 当前号码 = 医疗卡号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
        Where ID = Nvl(领用id_In, 0);
      End If;
      --更改原发卡记录状态
      Update 住院费用记录
      Set 实际票号 = 医疗卡号_In, 发药窗口 = 医疗卡号_In, 附加标志 = 2, 结论 = 卡类别id_In
      Where ID = r_Cardrow.费用id;
      Close c_Precard;
    End If;
  End If;

  --处理相关的变动信息
  --Zl_医疗卡变动_Insert (变动类型_In/病人id_In ,卡类别id_In, 原卡号_In, 医疗卡号_In, 变动原因_In, 密码_In, 操作员姓名_In, 变动时间_In
  --Ic卡号_In, 挂失方式_In)
  --变动类型_In:1-发卡(或11绑定卡);2-换卡;3-补卡(13-补卡停用);4-退卡(或14取消绑定); ５-密码调整(只记录);6-挂失(16取消挂失)
  n_变动类型 := Case
              When 发卡类型_In = 0 Then
               1
              When 发卡类型_In = 1 Then
               3
              Else
               2
            End;
  Zl_医疗卡变动_Insert(n_变动类型, 病人id_In, 卡类别id_In, 原卡号_In, 医疗卡号_In, 变动原因_In, 密码_In, 操作员姓名_In, 发卡时间_In, Ic卡号_In, Null);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_医疗卡记录_Insert;
/

--108736:李南春,2017-06-29,调整余额退款不足检查
--92335:李南春,2017-06-22,三方支付新模式及过程拆分
Create Or Replace Procedure Zl_病人预交记录_Insert
(
  Id_In         病人预交记录.Id%Type,
  单据号_In     病人预交记录.No%Type,
  票据号_In     票据使用明细.号码%Type,
  病人id_In     病人预交记录.病人id%Type,
  主页id_In     病人预交记录.主页id%Type,
  科室id_In     病人预交记录.科室id%Type,
  金额_In       病人预交记录.金额%Type,
  结算方式_In   病人预交记录.结算方式%Type,
  结算号码_In   病人预交记录.结算号码%Type,
  缴款单位_In   病人预交记录.缴款单位%Type,
  单位开户行_In 病人预交记录.单位开户行%Type,
  单位帐号_In   病人预交记录.单位帐号%Type,
  摘要_In       病人预交记录.摘要%Type,
  操作员编号_In 病人预交记录.操作员编号%Type,
  操作员姓名_In 病人预交记录.操作员姓名%Type,
  领用id_In     票据使用明细.领用id%Type,
  预交类别_In   病人预交记录.预交类别%Type := Null,
  卡类别id_In   病人预交记录.卡类别id%Type := Null,
  结算卡序号_In 病人预交记录.结算卡序号%Type := Null,
  卡号_In       病人预交记录.卡号%Type := Null,
  交易流水号_In 病人预交记录.交易流水号%Type := Null,
  交易说明_In   病人预交记录.交易说明%Type := Null,
  合作单位_In   病人预交记录.合作单位%Type := Null,
  收款时间_In   病人预交记录.收款时间%Type := Null,
  操作类型_In   Integer := 0,
  结帐id_In     病人预交记录.结帐id%Type := Null,
  结算性质_In   病人预交记录.结算性质%Type := Null,
  退款检查_In   Number := 0,
  强制退现_In   Number := 0,
  更新交款余额_In  Number := 1
) As
  ----------------------------------------------
  --操作类型_In:0-正常缴预交;1-存为划价单;3-余额退款
  --结帐ID_IN:>0时,表示某次结帐时,同步产生的预交记录
  --退款检查_In;0-忽略退款金额是否大于了病人余额；1-检查退款金额
  --更新交款余额_In:0-在 zl_人员缴款余额_Update 中更新；1-在本过程中更新

  v_Err_Msg Varchar2(200);
  Err_Item Exception;

  v_性质     结算方式.性质%Type;
  v_打印id   票据打印内容.Id%Type;
  v_担保     病人信息.担保性质%Type;
  v_Date     Date;
  n_返回值   病人余额.预交余额%Type;
  n_组id     财务缴款分组.Id%Type;
  n_病人余额 病人余额.预交余额%Type;
  n_三方预交 病人余额.预交余额%Type;
Begin
  v_Date := 收款时间_In;
  If v_Date Is Null Then
    Select Sysdate Into v_Date From Dual;
  End If;
  n_组id := Zl_Get组id(操作员姓名_In);

  --插入预交缴款记录
  Insert Into 病人预交记录
    (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要, 缴款组id, 预交类别,
     卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 冲预交, 结算性质)
  Values
    (Id_In, 单据号_In, 票据号_In, 1, Decode(操作类型_In, 1, 0, 1), 病人id_In, Decode(主页id_In, 0, Null, 主页id_In),
     Decode(科室id_In, 0, Null, 科室id_In), 金额_In, 结算方式_In, 结算号码_In, v_Date, 缴款单位_In, 单位开户行_In, 单位帐号_In, 操作员编号_In, 操作员姓名_In,
     摘要_In, n_组id, 预交类别_In, 卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, 合作单位_In, 结帐id_In,
     Decode(结帐id_In, Null, Null, 0), 结算性质_In);
  If 操作类型_In = 1 Then
    --暂不处理汇总表
    Return;
  End If;

  --处理票据
  If 票据号_In Is Not Null Then
    Select 票据打印内容_Id.Nextval Into v_打印id From Dual;
  
    --发出票据
    Insert Into 票据打印内容 (ID, 数据性质, NO) Values (v_打印id, 2, 单据号_In);
  
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
    Values
      (票据使用明细_Id.Nextval, 2, 票据号_In, 1, 1, 领用id_In, v_打印id, v_Date, 操作员姓名_In);
  
    --状态改动
    Update 票据领用记录
    Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
    Where ID = Nvl(领用id_In, 0);
  End If;

  --相关汇总表处理

  --病人余额(预交余额现收)
  Begin
    Select 性质 Into v_性质 From 结算方式 Where 名称 = 结算方式_In;
  Exception
    When Others Then
      Null;
  End;
  If Nvl(v_性质, 1) <> 5 Then
    Update 病人余额
    Set 预交余额 = Nvl(预交余额, 0) + 金额_In
    Where 性质 = 1 And 病人id = 病人id_In And Nvl(类型, 0) = Nvl(预交类别_In, 0)
    Returning 预交余额 Into n_返回值;
    If Sql%RowCount = 0 Then
      Insert Into 病人余额
        (病人id, 性质, 类型, 预交余额, 费用余额)
      Values
        (病人id_In, 1, Nvl(预交类别_In, 0), 金额_In, 0);
      n_返回值 := 金额_In;
    End If;
    If Nvl(金额_In, 0) = 0 Then
      Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
    End If;
  End If;

  If 金额_In < 0 Then
    Begin
      Select Nvl(预交余额, 0) - Nvl(费用余额, 0)
      Into n_病人余额
      From 病人余额
      Where 性质 = 1 And 病人id = 病人id_In And Nvl(类型, 0) = Nvl(预交类别_In, 0);
    Exception
      When Others Then
        Null;
    End;
    --余额退款要考虑三方预交是否支持退现
    If 操作类型_In = 3 And Nvl(强制退现_In, 0) = 0 Then
      For c_三方预交 In (Select a.预交id, a.预交类别, a.卡类别id, a.结算卡序号 As 消费接口id, Nvl(b.编码, c.编号) As 编码, Nvl(b.名称, c.名称) As 名称,
                            Decode(b.编码, Null, c.是否全退, b.是否全退) As 是否全退, Decode(b.编码, Null, c.是否退现, b.是否退现) As 是否退现, a.卡号,
                            a.交易流水号, a.交易说明, a.预交余额
                     From (Select a.预交类别, Nvl(a.卡类别id, 0) As 卡类别id, Nvl(a.结算卡序号, 0) As 结算卡序号, a.卡号, a.交易流水号, a.交易说明,
                                   Max(Decode(Sign(金额), -1, Decode(a.记录状态, 1, 0, 2, 0, ID), ID)) As 预交id,
                                   Nvl(Sum(金额), 0) - Nvl(Sum(Nvl(冲预交, 0)), 0) As 预交余额
                            From 病人预交记录 A
                            Where a.病人id = 病人id_In And (Nvl(a.结算卡序号, 0) <> 0 Or Nvl(卡类别id, 0) <> 0)
                            Group By a.预交类别, Nvl(a.卡类别id, 0), Nvl(a.结算卡序号, 0), a.卡号, a.交易流水号, a.交易说明
                            Having Nvl(Sum(金额), 0) - Nvl(Sum(Nvl(冲预交, 0)), 0) <> 0) A, 医疗卡类别 B, 卡消费接口目录 C
                     Where a.预交类别 = Nvl(预交类别_In, 0) And a.卡类别id = b.Id(+) And a.结算卡序号 = c.编号(+) And Nvl(a.预交余额, 0) <> 0
                     Order By 编码, a.卡号, a.交易流水号, a.交易说明) Loop
      
        If Instr(',7,8,', ',' || v_性质 || ',') = 0 And Nvl(c_三方预交.是否退现, 0) = 0 And Nvl(c_三方预交.预交余额, 0) > 0 Then
          n_三方预交 := Nvl(n_三方预交, 0) + Nvl(c_三方预交.预交余额, 0);
        Elsif Instr(',7,8,', ',' || v_性质 || ',') > 0 Then
          If Nvl(c_三方预交.卡号, '0') = Nvl(卡号_In, '0') And Nvl(c_三方预交.交易流水号, '0') = Nvl(交易流水号_In, '0') And
             Nvl(c_三方预交.交易说明, '0') = Nvl(交易说明_In, '0') Then
            n_三方预交 := Nvl(n_三方预交, 0) + Nvl(c_三方预交.预交余额, 0);
          End If;
        End If;
      End Loop;
    End If;
  
    If Instr(',7,8,', ',' || v_性质 || ',') > 0 And Nvl(n_三方预交, 0) < 0 And 操作类型_In = 3 Then
      v_Err_Msg := '退款金额大于病人三方预交金额。';
      Raise Err_Item;
    Elsif Nvl(n_病人余额, 0) < 0 And 退款检查_In = 1 Then
      v_Err_Msg := '退款金额大于病人剩余预交余额。';
      Raise Err_Item;
    Elsif Instr(',7,8,', ',' || v_性质 || ',') = 0 And Nvl(n_病人余额, 0) - Nvl(n_三方预交, 0) < 0 And 操作类型_In = 3 And 退款检查_In = 1 Then
      v_Err_Msg := '退款金额大于病人剩余预交余额。';
      Raise Err_Item;
    End If;
  End If;

  --人员缴款余额(现收)
  If Nvl(更新交款余额_In, 1) = 1 Then
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + 金额_In
    Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = 结算方式_In
    Returning 余额 Into n_返回值;

    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, 结算方式_In, 1, 金额_In);
      n_返回值 := 金额_In;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 人员缴款余额 Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = 结算方式_In And Nvl(余额, 0) = 0;
    End If;
  End if;
  --对临时担保的处理
  Select Nvl(担保性质, 0) Into v_担保 From 病人信息 Where 病人id = 病人id_In;
  If v_担保 = 1 And Nvl(金额_In, 0) > 0 Then
    Update 病人信息
    Set 担保额 = Decode(Sign(Nvl(担保额, 0) - Nvl(金额_In, 0)), 1, Nvl(担保额, 0) - Nvl(金额_In, 0), Null),
        担保人 = Decode(Sign(Nvl(担保额, 0) - Nvl(金额_In, 0)), 1, 担保人, Null),
        担保性质 = Decode(Sign(Nvl(担保额, 0) - Nvl(金额_In, 0)), 1, 担保性质, Null)
    Where 病人id = 病人id_In;
  End If;
  If 操作类型_In <> 1 And 结帐id_In Is Null Then
    --消息推送;
    Begin
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 11, Id_In;
    Exception
      When Others Then
        Null;
    End;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人预交记录_Insert;
/

--92335:李南春,2017-06-22,三方支付新模式及过程拆分
CREATE OR REPLACE Procedure Zl_病人挂号记录_Insert
(
  病人id_In        门诊费用记录.病人id%Type,
  门诊号_In        门诊费用记录.标识号%Type,
  姓名_In          门诊费用记录.姓名%Type,
  性别_In          门诊费用记录.性别%Type,
  年龄_In          门诊费用记录.年龄%Type,
  付款方式_In      门诊费用记录.付款方式%Type, --用于存放病人的医疗付款方式编号
  费别_In          门诊费用记录.费别%Type,
  单据号_In        门诊费用记录.No%Type,
  票据号_In        门诊费用记录.实际票号%Type,
  序号_In          门诊费用记录.序号%Type,
  价格父号_In      门诊费用记录.价格父号%Type,
  从属父号_In      门诊费用记录.从属父号%Type,
  收费类别_In      门诊费用记录.收费类别%Type,
  收费细目id_In    门诊费用记录.收费细目id%Type,
  数次_In          门诊费用记录.数次%Type,
  标准单价_In      门诊费用记录.标准单价%Type,
  收入项目id_In    门诊费用记录.收入项目id%Type,
  收据费目_In      门诊费用记录.收据费目%Type,
  结算方式_In      病人预交记录.结算方式%Type, --现金的结算名称
  应收金额_In      门诊费用记录.应收金额%Type,
  实收金额_In      门诊费用记录.实收金额%Type,
  病人科室id_In    门诊费用记录.病人科室id%Type,
  开单部门id_In    门诊费用记录.开单部门id%Type,
  执行部门id_In    门诊费用记录.执行部门id%Type,
  操作员编号_In    门诊费用记录.操作员编号%Type,
  操作员姓名_In    门诊费用记录.操作员姓名%Type,
  发生时间_In      门诊费用记录.发生时间%Type,
  登记时间_In      门诊费用记录.登记时间%Type,
  医生姓名_In      挂号安排.医生姓名%Type,
  医生id_In        挂号安排.医生id%Type,
  病历费_In        Number, --该条记录是否病历工本费
  急诊_In          Number,
  号别_In          挂号安排.号码%Type,
  诊室_In          门诊费用记录.发药窗口%Type,
  结帐id_In        门诊费用记录.结帐id%Type,
  领用id_In        票据使用明细.领用id%Type,
  预交支付_In      病人预交记录.冲预交%Type, --刷卡挂号时使用的预交金额,序号为1传入.
  现金支付_In      病人预交记录.冲预交%Type, --挂号时现金支付部份金额,序号为1传入.
  个帐支付_In      病人预交记录.冲预交%Type, --挂号时个人帐户支付金额,,序号为1传入.
  保险大类id_In    门诊费用记录.保险大类id%Type,
  保险项目否_In    门诊费用记录.保险项目否%Type,
  统筹金额_In      门诊费用记录.统筹金额%Type,
  摘要_In          门诊费用记录.摘要%Type, --预约挂号摘要信息
  预约挂号_In      Number := 0, --预约挂号时用(记录状态=0,发生时间为预约时间),此时不需要传入结算相关参数
  收费票据_In      Number := 0, --挂号是否使用收费票据
  保险编码_In      门诊费用记录.保险编码%Type,
  复诊_In          病人挂号记录.复诊%Type := 0,
  号序_In          挂号序号状态.序号%Type := Null, --预约时填入费用记录的发药窗口字段,挂号时填入挂号记录
  社区_In          病人挂号记录.社区%Type := Null,
  预约接收_In      Number := 0,
  预约方式_In      预约方式.名称%Type := Null,
  生成队列_In      Number := 0,
  卡类别id_In      病人预交记录.卡类别id%Type := Null,
  结算卡序号_In    病人预交记录.结算卡序号%Type := Null,
  卡号_In          病人预交记录.卡号%Type := Null,
  交易流水号_In    病人预交记录.交易流水号%Type := Null,
  交易说明_In      病人预交记录.交易说明%Type := Null,
  合作单位_In      病人预交记录.合作单位%Type := Null,
  操作类型_In      Number := 0,
  险类_In          病人挂号记录.险类%Type := Null,
  结算模式_In      Number := 0,
  记帐费用_In      Number := 0,
  退号重用_In      Number := 1,
  冲预交病人ids_In Varchar2 := Null,
  修正病人费别_In  Number := 0,
  修正病人年龄_In  Number := 0,
  收费单_In        病人挂号记录.收费单%Type := Null,
  更新交款余额_In Number := 1
) As
  ---------------------------------------------------------------------------
  --
  --参数:
  --     操作类型_in:0-正常挂号或者预约 1-操作员拥有加号权限加号
  --     修正病人费别_In:0-不修改病人费别 1-修改病人费别
  --     更新交款余额_In:0-在zl_人员缴款余额_Update 中更新 1-在本过程中更新
  ----------------------------------------------------------------------------
  --该游标用于收费冲预交的可用预交列表
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit
  (
    v_病人id        病人信息.病人id%Type,
    v_冲预交病人ids Varchar2
  ) Is
    Select 病人id, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额, Min(记录状态) As 记录状态, Nvl(Max(结帐id), 0) As 结帐id,
           Max(Decode(记录性质, 1, ID, 0) * Decode(记录状态, 2, 0, 1)) As 原预交id
    From 病人预交记录
    Where 记录性质 In (1, 11) And 病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And Nvl(预交类别, 2) = 1
     Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
    Group By NO, 病人id
    Order By Decode(病人id, Nvl(v_病人id, 0), 0, 1), 结帐id, NO;
  --功能：新增一行病人挂号费用，并将结算汇总到病人预交记录
  --       同时汇总相关的汇总表(病人挂号汇总、费用汇总)
  --       第一行费用处理票据使用情况(领用ID_IN>0)

  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_排队号码 排队叫号队列.排队号码%Type;
  v_现金     结算方式.名称%Type;
  v_个人帐户 结算方式.名称%Type;
  v_队列名称 排队叫号队列.队列名称%Type;

  n_分时段       Number;
  n_时段限号     Number;
  n_时段限约     Number;
  d_时段时间     Date;
  d_最大序号时间 Date;
  n_追加号       Number := 0; --处理时段过期 追加挂号的情况
  n_已约数       病人挂号汇总.已约数%Type;
  n_已接收       病人挂号汇总.其中已接收%Type;
  n_预约有效时间 Number;
  n_失效数       Number;
  n_失约挂号     Number := 0;
  n_已用数量     Number;
  n_锁定         Number := 0;

  n_打印id        票据打印内容.Id%Type;
  n_费用id        门诊费用记录.Id%Type;
  n_预交金额      病人预交记录.金额%Type;
  n_当前金额      病人预交记录.金额%Type;
  n_返回值        病人预交记录.金额%Type;
  n_预交id        病人预交记录.Id%Type;
  n_消费卡id      消费卡目录.Id%Type;
  n_挂号id        病人挂号记录.Id%Type;
  v_冲预交病人ids Varchar2(4000);

  n_组id           财务缴款分组.Id%Type;
  n_门诊号         病人信息.门诊号%Type;
  n_序号           挂号序号状态.序号%Type;
  n_已用序号       挂号序号状态.序号%Type;
  n_序号控制       挂号安排.序号控制%Type;
  n_分诊台签到排队 Number;
  n_Count          Number;
  n_限号数         Number(18);
  n_自制卡         Number;
  d_排队时间       Date;
  d_序号时间       Date;
  v_费别           费别.名称%Type;
  n_时段序号       Number := -1;
  n_预约生成队列   Number;
  n_安排id         挂号安排.Id%Type;
  n_计划id         挂号安排计划.Id%Type := 0;
  v_星期           挂号安排限制.限制项目%Type;
  n_限约数         Number(18);
  n_已挂数         Number(4) := 0;

  n_挂出的最大序号 Number(4) := 0;
  n_结算模式       病人信息.结算模式%Type;
  v_排队序号       排队叫号队列.排队序号%Type;
  v_机器名         挂号序号状态.机器名%Type;
  v_序号操作员     挂号序号状态.操作员姓名%Type;
  v_序号机器名     挂号序号状态.机器名%Type;
  v_付款方式       病人挂号记录.医疗付款方式%Type;
  v_Temp           Varchar2(3000);
  v_时间段         时间段.时间段%Type;
  d_检查开始时间   时间段.开始时间%Type;
  d_检查结束时间   时间段.终止时间%Type;
  n_出诊记录id     临床出诊记录.Id%Type;
  n_分时点显示     Number(3);
  d_启用时间       Date;
Begin
  --获取当前机器名称
  Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
  n_组id          := Zl_Get组id(操作员姓名_In);
  v_冲预交病人ids := Nvl(冲预交病人ids_In, 病人id_In);

  If 费别_In Is Null Then
    Begin
      Select 名称 Into v_费别 From 费别 Where 缺省标志 = 1 And Rownum < 2;
      Update 病人信息 Set 费别 = v_费别 Where 病人id = 病人id_In;
    Exception
      When Others Then
        v_Err_Msg := '无法确定病人费别，请检查缺省费别是否正确设置！';
        Raise Err_Item;
    End;
  Else
    v_费别 := 费别_In;
    If Nvl(修正病人费别_In, 0) = 1 Then
      Begin
        Update 病人信息 Set 费别 = v_费别 Where 病人id = 病人id_In;
      Exception
        When Others Then
          v_Err_Msg := '没有找到对应的病人！';
          Raise Err_Item;
      End;
    End If;
  End If;

  If Nvl(修正病人年龄_In, 0) = 1 Then
    Begin
      Update 病人信息 Set 年龄 = 年龄_In Where 病人id = 病人id_In;
    Exception
      When Others Then
        v_Err_Msg := '没有找到对应的病人！';
        Raise Err_Item;
    End;
  End If;

  If 门诊号_In Is Not Null Then
    Begin
      Select Nvl(门诊号, 0) Into n_门诊号 From 病人信息 Where 病人id = 病人id_In;
    Exception
      When Others Then
        n_门诊号 := 0;
    End;
    If n_门诊号 = 0 Then
      Update 病人信息 Set 门诊号 = 门诊号_In Where 病人id = 病人id_In;
    End If;
  End If;

  Begin
    Delete From 挂号序号状态
    Where 号码 = 号别_In And 日期 = 发生时间_In And 序号 = 号序_In And 状态 = 3 And 操作员姓名 = 操作员姓名_In;
  Exception
    When Others Then
      Null;
  End;
  v_Temp := zl_GetSysParameter(256);
  If v_Temp Is Null Or Substr(v_Temp, 1, 1) = '0' Then
    Null;
  Else
    Begin
      d_启用时间 := To_Date(Substr(v_Temp, 3), 'YYYY-MM-DD hh24:mi:ss');
    Exception
      When Others Then
        d_启用时间 := Null;
    End;
    If d_启用时间 Is Not Null Then
      If 发生时间_In > d_启用时间 Then
        v_Err_Msg := '当前挂号的发生时间' || To_Char(发生时间_In, 'yyyy-mm-dd hh24:mi:ss') || '已经启用了出诊表排班模式,不能再使用计划排班模式挂号!';
        Raise Err_Item;
      End If;
    End If;
  End If;

  If Nvl(预约挂号_In, 0) = 0 Then
    --挂号或者预约接收
    --因为现在有按日编单据号规则,日挂号量不能超过10000次,所以要检查唯一约束。
    Select Count(*)
    Into n_Count
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 In (1, 3) And 序号 = 序号_In And NO = 单据号_In;
    If n_Count <> 0 Then
      v_Err_Msg := '挂号单据号重复,不能保存！' || Chr(13) || '如果使用了按日顺序编号,当日挂号量不能超过10000人次。';
      Raise Err_Item;
    End If;

    --获取结算方式名称
    Begin
      Select 名称 Into v_现金 From 结算方式 Where 性质 = 1;
    Exception
      When Others Then
        v_现金 := '现金';
    End;
    Begin
      Select 名称 Into v_个人帐户 From 结算方式 Where 性质 = 3;
    Exception
      When Others Then
        v_个人帐户 := '个人帐户';
    End;
  End If;

  n_序号 := 号序_In;
  Select Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null)
  Into v_星期
  From Dual;

  --挂号获取安排
  Begin
    Select a.Id, a.序号控制, Nvl(b.限号数, 0), Nvl(b.限约数, 0)
    Into n_安排id, n_序号控制, n_限号数, n_限约数
    From 挂号安排 A, 挂号安排限制 B
    Where a.Id = b.安排id(+) And b.限制项目(+) = v_星期 And a.号码 = 号别_In;

  Exception
    When Others Then
      n_安排id := -1;
  End;

  --如果是病历费或者号别为空时不检查
  If Nvl(病历费_In, 0) = 0 Or 号别_In Is Not Null Then
    If n_安排id = -1 Then
      v_Err_Msg := '不存相应的挂号安排数据,请检查';
      Raise Err_Item;
    End If;
  End If;

  If Nvl(预约挂号_In, 0) = 1 Then
    --首先获取计划
    Begin
      Select ID
      Into n_计划id
      From 挂号安排计划
      Where 安排id = n_安排id And 审核时间 Is Not Null And
            Nvl(生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) =
            (Select Max(a.生效时间) As 生效
             From 挂号安排计划 A
             Where a.审核时间 Is Not Null And 发生时间_In Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                   Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) And a.安排id = n_安排id) And
            发生时间_In Between Nvl(生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
            Nvl(失效时间, To_Date('3000-01-01', 'yyyy-mm-dd'));

    Exception
      When Others Then
        n_计划id := 0;
    End;
    If Nvl(n_计划id, 0) <> 0 Then
      Begin
        --获取计划的限制
        Select a.Id, a.序号控制, Nvl(b.限号数, 0) As 限号数, Nvl(b.限约数, 0) As 限约数
        Into n_计划id, n_序号控制, n_限号数, n_限约数
        From 挂号安排计划 A, 挂号计划限制 B
        Where a.号码 = 号别_In And a.Id = n_计划id And a.审核时间 Is Not Null And a.Id = b.计划id(+) And b.限制项目(+) = v_星期;
      Exception
        When Others Then
          v_Err_Msg := '不存相应的挂号安排或计划数据,请检查';
          Raise Err_Item;
      End;
    End If;
  End If;

  --获取是否分时段
  Begin
    If Nvl(n_计划id, 0) = 0 Then
      Select Count(Rownum) Into n_分时段 From 挂号安排时段 Where 星期 = v_星期 And 安排id = n_安排id And Rownum <= 1;
      Select Decode(To_Char(发生时间_In, 'D'), '1', 周日, '2', 周一, '3', 周二, '4', 周三, '5', 周四, '6', 周五, '7', 周六, Null)
      Into v_时间段
      From 挂号安排
      Where ID = n_安排id;
    Else
      Select Count(Rownum) Into n_分时段 From 挂号计划时段 Where 星期 = v_星期 And 计划id = n_计划id And Rownum <= 1;
      Select Decode(To_Char(发生时间_In, 'D'), '1', 周日, '2', 周一, '3', 周二, '4', 周三, '5', 周四, '6', 周五, '7', 周六, Null)
      Into v_时间段
      From 挂号安排计划
      Where ID = n_计划id;
    End If;
  Exception
    When Others Then
      v_时间段 := Null;
  End;

  If v_时间段 Is Not Null And d_启用时间 Is Not Null And 序号_In = 1 Then
    --检查是否跨模式挂号安排
    Select To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'),
           To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(终止时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss')
    Into d_检查开始时间, d_检查结束时间
    From 时间段
    Where 时间段 = v_时间段 And 站点 Is Null And 号类 Is Null;
    If d_检查开始时间 > d_检查结束时间 Then
      d_检查结束时间 := d_检查结束时间 + 1;
    End If;
    If d_检查开始时间 < d_启用时间 And d_检查结束时间 > d_启用时间 Then
      --获取出诊记录id
      Begin
        Select a.Id
        Into n_出诊记录id
        From 临床出诊记录 A, 临床出诊号源 B
        Where a.号源id = b.Id And b.号码 = 号别_In And 上班时段 = v_时间段 And 发生时间_In Between 开始时间 And 终止时间;
      Exception
        When Others Then
          n_出诊记录id := Null;
      End;
    End If;
  End If;

  --分时段挂号时判断是否是过期挂号 也就是追加号的情况 目前只针对专家号分时段进行处理
  If Nvl(预约挂号_In, 0) = 0 And n_分时段 > 0 And Nvl(n_序号控制, 0) = 1 And 号序_In Is Null And Nvl(操作类型_In, 0) = 0 Then
    --发生时间_in>Sysdate 发生时间>最大的时段时间--号序_in is null
    Begin
      Select Max(To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'))
      Into d_最大序号时间
      From 挂号安排时段
      Where 安排id = n_安排id And 星期 = v_星期 And Nvl(限制数量, 0) <> 0;
      n_追加号 := Case Sign(发生时间_In - d_最大序号时间)
                 When -1 Then
                  0
                 Else
                  1
               End;
    Exception
      When Others Then
        n_追加号 := 0;
    End;
  End If;
  d_时段时间 := 发生时间_In;

  If 序号_In = 1 And Nvl(预约挂号_In, 0) = 0 And n_分时段 > 0 Then
    --挂号时检查 是否分了时段,分了时段,把时段的限制条件给取出来
    Begin
      Select Nvl(序号, 0),
             To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'),
             限制数量, Decode(Nvl(是否预约, 0), 0, 0, 限制数量)
      Into n_时段序号, d_时段时间, n_时段限号, n_时段限约
      From 挂号安排时段
      Where 安排id = n_安排id And 星期 = v_星期 And
            (序号, 安排id, 星期) In (Select Nvl(Max(序号), -1), 安排id, 星期
                               From 挂号安排时段
                               Where 安排id = n_安排id And 星期 = v_星期 And
                                     Decode(操作类型_In + n_追加号, 0, To_Char(发生时间_In, 'hh24:mi'),
                                            To_Char(Nvl(开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi')) =
                                     To_Char(Nvl(开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi')
                               Group By 安排id, 星期);
    Exception
      When Others Then
        n_时段序号 := -1;
        n_分时段   := 0;
        d_时段时间 := 发生时间_In;
        n_时段限号 := 0;
        n_时段限约 := 0;
    End;
  End If;

  If 序号_In = 1 And Nvl(预约挂号_In, 0) = 1 And n_分时段 > 0 Then
    --预约号,取计划
    Begin
      If Nvl(n_计划id, 0) = 0 Then
        --没计划生效,取安排的数据
        Select Nvl(序号, 0),
               To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(c.开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 时段时间,
               限制数量, Decode(Nvl(是否预约, 0), 0, 0, 限制数量)
        Into n_时段序号, d_时段时间, n_时段限号, n_时段限约
        From 挂号安排时段 C
        Where 安排id = n_安排id And 星期 = v_星期 And
              (序号, 安排id, 星期) In
              (Select Nvl(Max(c.序号), -1), 安排id, 星期
               From 挂号安排时段 C
               Where 安排id = n_安排id And c.星期 = v_星期 And
                     Decode(操作类型_In, 1, To_Char(Nvl(c.开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi'),
                            To_Char(发生时间_In, 'hh24:mi')) =
                     To_Char(Nvl(c.开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi')
               Group By 安排id, 星期);
      Else
        --有计划生效取计划
        --没生效，代表是从挂号计划时段查询
        Select Nvl(序号, -1),
               To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(c.开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 时段时间,
               限制数量, Decode(Nvl(是否预约, 0), 0, 0, 限制数量)
        Into n_时段序号, d_时段时间, n_时段限号, n_时段限约
        From 挂号计划时段 C
        Where 计划id = n_计划id And 星期 = v_星期 And
              (序号, 计划id, 星期) In
              (Select Nvl(Max(c.序号), -1), 计划id, 星期
               From 挂号计划时段 C
               Where 计划id = n_计划id And c.星期 = v_星期 And
                     Decode(操作类型_In, 1, To_Char(Nvl(c.开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi'),
                            To_Char(发生时间_In, 'hh24:mi')) =
                     To_Char(Nvl(c.开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi')
               Group By 计划id, 星期);
      End If;
    Exception
      When Others Then
        n_时段序号 := -1;
        n_分时段   := 0;
        d_时段时间 := 发生时间_In;
        n_时段限号 := 0;
        n_时段限约 := 0;
    End;
  End If;

  If 序号_In = 1 Then

    --获取当前未使用的序号
    If Nvl(n_序号控制, 0) = 1 And n_分时段 = 0 Then
      --<序号控制 未设置时段 获取可用的最大序号,以及已经使用的数量>
      Begin
        --最大序号
        If 退号重用_In = 1 Then
          Select Max(Nvl(序号, 0)), Sum(Decode(序号, Nvl(号序_In, 0), 0, 1)), Sum(Nvl(预约, 0))
          Into n_已用序号, n_已用数量, n_已约数
          From 挂号序号状态
          Where 号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 状态 Not In (4, 5);
        Else
          Select Max(Nvl(序号, 0)), Sum(Decode(序号, Nvl(号序_In, 0), 0, 1)), Sum(Nvl(预约, 0))
          Into n_已用序号, n_已用数量, n_已约数
          From 挂号序号状态
          Where 号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 状态 <> 5;
        End If;
      Exception
        When Others Then
          n_已用序号 := 0;
          n_已用数量 := 0;
      End;
      If n_序号 Is Null Then
        n_序号 := Nvl(n_已用序号, 0) + 1;
      End If;
      --<序号控制 未设置时段 获取可用的最大序号 以及已经使用的数量 --end>

      --非加号的情况需要检查是否超过了限制
      If 操作类型_In = 0 Then
        If Nvl(预约挂号_In, 0) = 0 Then
          --挂号时检查
          --启用序号控制未分时段 达到了限制
          If n_限号数 <= n_已用数量 And n_限号数 > 0 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(Trunc(发生时间_In), 'yyyy-mm-dd ') || '已达到最大限制数！';
            Raise Err_Item;
          End If;

        Else
          --预约时检查
          If n_限约数 = 0 Then
            n_限约数 := n_限号数;
          End If;

          If n_限约数 <= n_已约数 And n_限约数 > 0 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(Trunc(发生时间_In), 'yyyy-mm-dd') || '已达到最大限约数！';
            Raise Err_Item;
          End If;
        End If;

      Else
        Null;
        --启用序号控制,未分时段 加号情况   不处理,如果以后有限制条件以后补充
      End If;

    Elsif Nvl(n_分时段, 0) > 0 And Nvl(n_序号控制, 0) = 0 Then
      --<--普通号分时段 这里只有预约一种情况-->
      If 操作类型_In = 0 Then
        --<正常预约挂号-->
        Begin
          Select Count(0) As 已挂数, Nvl(Sum(Decode(Nvl(Sign(a.日期 - d_时段时间), 0), 0, 1, 0)), 0) As 已约数
          Into n_已挂数, n_已约数
          From 挂号序号状态 A
          Where a.号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And
                状态 Not In (4, 5);
        Exception
          When Others Then
            n_已挂数 := 0;
            n_已约数 := 0;
        End;

        n_时段限约 := n_时段限号; --普通号分时段的情况,29中n_时段限约始终是0 这里特殊处理
        --检查限制数量
        If n_限约数 = 0 Then
          n_限约数 := n_限号数;
        End If;
        If n_时段限约 <= n_已约数 Or n_限约数 <= n_已约数 Then
          v_Err_Msg := '号别' || 号别_In || '在时段' || To_Char(d_时段时间, 'hh24:mi') || '已达到最大限约数！';
          Raise Err_Item;
        End If;
        If n_限号数 <= n_已挂数 Then
          v_Err_Msg := '号别' || 号别_In || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
          Raise Err_Item;
        End If;
      End If;

      --没有达到时段的限号数 号码在当前时段往后追加

      --获取当天挂出的最大号序
      If 退号重用_In = 1 Then
        Select Nvl(Max(序号), 0)
        Into n_挂出的最大序号
        From 挂号序号状态 A
        Where a.日期 = d_时段时间 And 号码 = 号别_In And 状态 Not In (4, 5);
      Else
        Select Nvl(Max(序号), 0)
        Into n_挂出的最大序号
        From 挂号序号状态 A
        Where a.日期 = d_时段时间 And 号码 = 号别_In And 状态 <> 5;
      End If;

      --设置序号
      n_序号 := RPad(Nvl(n_时段序号, 0), Length(n_限号数) + Length(Nvl(n_时段序号, 0)), 0) + n_已约数 + 1;
      If n_序号 <= Nvl(n_挂出的最大序号, 0) Then
        n_序号 := Nvl(n_挂出的最大序号, 0) + 1;
      End If;

      --<--普通号分时段--End>
    Elsif Nvl(n_分时段, 0) > 0 And Nvl(n_序号控制, 0) = 1 Then
      --<启用序号控制 设置时段
      --专家号分时段
      Begin
        If 退号重用_In = 1 Then
          Select Max(序号), Sum(Decode(序号, Nvl(号序_In, 0), 0, 1)), Sum(Decode(Sign(日期 - d_时段时间), 0, 1, 0))
          Into n_已用序号, n_已挂数, n_已用数量
          From 挂号序号状态
          Where 号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 状态 Not In (4, 5);
        Else
          Select Max(序号), Sum(Decode(序号, Nvl(号序_In, 0), 0, 1)), Sum(Decode(Sign(日期 - d_时段时间), 0, 1, 0))
          Into n_已用序号, n_已挂数, n_已用数量
          From 挂号序号状态
          Where 号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 状态 <> 5;
        End If;
      Exception
        When Others Then
          n_已用序号 := 0;
          n_已用数量 := 0;
          n_已挂数   := 0;
      End;

      n_失效数 := 0;
      If Nvl(预约挂号_In, 0) = 0 Then
        n_预约有效时间 := Zl_To_Number(zl_GetSysParameter('预约有效时间', 1111));
        n_失约挂号     := Zl_To_Number(zl_GetSysParameter('失约用于挂号', 1111));
        If Nvl(n_预约有效时间, 0) <> 0 And Nvl(n_失约挂号, 0) > 0 Then
          Begin
            Select Sum(Decode(Sign((Sysdate - n_预约有效时间 / 24 / 60) - 日期), 1, 1, 0))
            Into n_失效数
            From 挂号序号状态
            Where 号码 = 号别_In And 日期 Between Trunc(Sysdate) And Sysdate And Nvl(预约, 0) = 1 And 状态 = 2;
          Exception
            When Others Then
              n_失效数 := 0;
          End;
        End If;
      End If;

      If 操作类型_In = 0 Then
        If Nvl(预约挂号_In, 0) = 0 Then

          --挂号 追加号码时不检查时段限号数
          If n_时段限号 <= n_已用数量 And Nvl(n_追加号, 0) = 0 Then
            v_Err_Msg := '号别' || 号别_In || '在时段' || To_Char(d_时段时间, 'hh24:mi') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
          If n_限号数 <= n_已挂数 - n_失效数 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;

        Else
          --挂号
          If n_限约数 = 0 Then
            n_限约数 := n_限号数;
          End If;
          If n_限约数 <= n_已用数量 Then
            v_Err_Msg := '号别' || 号别_In || '在时段' || To_Char(d_时段时间, 'hh24:mi') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
          If n_限号数 <= n_已挂数 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        End If;
      End If;
      If n_序号 Is Null Then
        --设置序号
        If Nvl(n_已用序号, 0) < Nvl(n_时段序号, 0) Then
          n_已用序号 := Nvl(n_时段序号, 0);
        End If;
        n_序号 := Nvl(n_已用序号, 0) + 1;
      End If;
    Elsif Nvl(n_分时段, 0) = 0 And Nvl(n_序号控制, 0) = 0 And Nvl(病历费_In, 0) = 0 And Nvl(号别_In, 0) > 0 Then
      ---<--普通号  -->
      Begin
        Select 已挂数, 已约数
        Into n_已用数量, n_已约数
        From 病人挂号汇总
        Where 日期 = Trunc(发生时间_In) And 号码 = 号别_In;
      Exception
        When Others Then
          n_已用数量 := 0;
          n_已约数   := 0;
      End;
      If Nvl(操作类型_In, 0) = 0 Then
        If Nvl(预约挂号_In, 0) = 0 Then
          --挂号
          If Nvl(n_已用数量, 0) >= Nvl(n_限号数, 0) And Nvl(n_限号数, 0) > 0 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        Else
          --预约
          If (Nvl(n_限约数, 0) > 0 And Nvl(n_已约数, 0) >= Nvl(n_限约数, 0)) Or
             (Nvl(n_已用数量, 0) >= Nvl(n_限号数, 0) And Nvl(n_限号数, 0) > 0) Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        End If;
      End If;
      ---<--普通号  -->
    End If;
  End If;

  --更新挂号序号状态
  If 序号_In = 1 And Not n_序号 Is Null Then
    If n_分时段 = 1 Then
      d_序号时间 := 发生时间_In;
    Else
      d_序号时间 := Trunc(发生时间_In);
    End If;
    --锁定序号的处理
    Begin
      Select 操作员姓名, 机器名
      Into v_序号操作员, v_序号机器名
      From 挂号序号状态
      Where 状态 = 5 And 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号;
      n_锁定 := 1;
    Exception
      When Others Then
        v_序号操作员 := Null;
        v_序号机器名 := Null;
        n_锁定       := 0;
    End;
    If n_锁定 = 0 Then
      Update 挂号序号状态
      Set 状态 = Decode(预约挂号_In, 1, 2, 1), 预约 = Decode(预约接收_In, 1, 1, 0), 登记时间 = Sysdate
      Where 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号 And 状态 = 3 And 操作员姓名 = 操作员姓名_In;
      If Sql%RowCount = 0 Then
        Begin
          If Nvl(n_分时段, 0) = 0 Or Nvl(预约挂号_In, 0) = 1 Or (Nvl(n_序号控制, 0) = 0 And Nvl(号序_In, 0) = 0) Then
            Insert Into 挂号序号状态
              (号码, 日期, 序号, 状态, 操作员姓名, 预约, 登记时间)
            Values
              (号别_In, d_序号时间, n_序号, Decode(预约挂号_In, 1, 2, 1), 操作员姓名_In, Decode(预约接收_In, 1, 1, 0), Sysdate);
            If Nvl(预约挂号_In, 0) = 0 And 预约方式_In Is Not Null Then
              Update 挂号序号状态 Set 预约 = 1 Where 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号;
            End If;
          Elsif Nvl(n_分时段, 0) > 0 Then
            --分时段后专家号 失约的预约号允许挂号
            Update 挂号序号状态
            Set 状态 = Decode(预约挂号_In, 1, 2, 1), 操作员姓名 = 操作员姓名_In, 预约 = Decode(预约接收_In, 1, 1, 0), 登记时间 = Sysdate
            Where 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号 And 状态 = 2;
            If Sql%NotFound Then
              Insert Into 挂号序号状态
                (号码, 日期, 序号, 状态, 操作员姓名, 预约, 登记时间)
              Values
                (号别_In, d_序号时间, n_序号, Decode(预约挂号_In, 1, 2, 1), 操作员姓名_In, Decode(预约接收_In, 1, 1, 0), Sysdate);
            End If;
            If Nvl(预约挂号_In, 0) = 0 And 预约方式_In Is Not Null Then
              Update 挂号序号状态 Set 预约 = 1 Where 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号;
            End If;
          End If;
        Exception
          When Others Then
            v_Err_Msg := '序号' || n_序号 || '已被使用,请重新选择一个序号.';
            Raise Err_Item;
        End;
      End If;
    Else
      If 操作员姓名_In <> v_序号操作员 Or v_机器名 <> v_序号机器名 Then
        v_Err_Msg := '序号' || n_序号 || '已被自助机' || v_机器名 || '锁定,请重新选择一个序号.';
        Raise Err_Item;
      Else
        Update 挂号序号状态
        Set 状态 = Decode(预约挂号_In, 1, 2, 1), 预约 = Decode(预约接收_In, 1, 1, 0), 登记时间 = Sysdate
        Where 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号 And 状态 = 5 And 操作员姓名 = 操作员姓名_In And 机器名 = v_机器名;
        If Nvl(预约挂号_In, 0) = 0 And 预约方式_In Is Not Null Then
          Update 挂号序号状态 Set 预约 = 1 Where 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号;
        End If;
      End If;
    End If;
  End If;

  If n_出诊记录id Is Not Null Then
    Update 临床出诊序号控制
    Set 挂号状态 = Decode(预约挂号_In, 1, 2, 1), 操作员姓名 = 操作员姓名_In
    Where 记录id = n_出诊记录id And 序号 = n_序号;
    If 预约挂号_In = 1 Then
      Update 临床出诊记录 Set 已约数 = 已约数 + 1 Where ID = n_出诊记录id;
    Else
      If 预约接收_In = 1 Then
        Update 临床出诊记录
        Set 已约数 = 已约数 + 1, 已挂数 = 已挂数 + 1, 其中已接收 = 其中已接收 + 1
        Where ID = n_出诊记录id;
      Else
        Update 临床出诊记录 Set 已挂数 = 已挂数 + 1 Where ID = n_出诊记录id;
      End If;
    End If;
  End If;

  --产生病人挂号费用(可能单独是或包括病历费用)
  Select 病人费用记录_Id.Nextval Into n_费用id From Dual; --应该通过程序得到

  Insert Into 门诊费用记录
    (ID, 记录性质, 记录状态, 序号, 价格父号, 从属父号, NO, 实际票号, 门诊标志, 加班标志, 附加标志, 发药窗口, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 病人科室id, 收费类别,
     计算单位, 收费细目id, 收入项目id, 收据费目, 付数, 数次, 标准单价, 应收金额, 实收金额, 结帐金额, 结帐id, 记帐费用, 开单部门id, 开单人, 划价人, 执行部门id, 执行人, 操作员编号, 操作员姓名,
     发生时间, 登记时间, 保险大类id, 保险项目否, 保险编码, 统筹金额, 摘要, 结论, 缴款组id)
  Values
    (n_费用id, 4, Decode(预约挂号_In, 1, 0, 1), 序号_In, Decode(价格父号_In, 0, Null, 价格父号_In), 从属父号_In, 单据号_In, 票据号_In, 1, 急诊_In,
     病历费_In, Decode(预约挂号_In, 1, To_Char(n_序号), 诊室_In), Decode(病人id_In, 0, Null, 病人id_In),
     Decode(门诊号_In, 0, Null, 门诊号_In), 付款方式_In, 姓名_In, Decode(姓名_In, Null, Null, 性别_In), Decode(姓名_In, Null, Null, 年龄_In),
     v_费别, 病人科室id_In, 收费类别_In, 号别_In, 收费细目id_In, 收入项目id_In, 收据费目_In, 1, 数次_In, 标准单价_In, 应收金额_In, 实收金额_In,
     Decode(预约挂号_In, 1, Null, Decode(Nvl(记帐费用_In, 0), 1, Null, 实收金额_In)),
     Decode(预约挂号_In, 1, Null, Decode(Nvl(记帐费用_In, 0), 1, Null, 结帐id_In)), Decode(Nvl(记帐费用_In, 0), 1, 1, 0), 开单部门id_In,
     操作员姓名_In, Decode(预约挂号_In, 1, 操作员姓名_In, Null), 执行部门id_In, 医生姓名_In, 操作员编号_In, 操作员姓名_In, 发生时间_In, 登记时间_In, 保险大类id_In,
     保险项目否_In, 保险编码_In, 统筹金额_In, 摘要_In, 预约方式_In, Decode(预约挂号_In, 1, Null, n_组id));

  --汇总结算到病人预交记录
  If Nvl(预约挂号_In, 0) = 0 And Nvl(记帐费用_In, 0) = 0 Then

    If (Nvl(现金支付_In, 0) <> 0 Or (Nvl(现金支付_In, 0) = 0 And Nvl(个帐支付_In, 0) = 0 And Nvl(预交支付_In, 0) = 0)) And 序号_In = 1 Then
      Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      Insert Into 病人预交记录
        (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
         结算性质)
      Values
        (n_预交id, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(结算方式_In, v_现金), Nvl(现金支付_In, 0), 登记时间_In,
         操作员编号_In, 操作员姓名_In, 结帐id_In, '挂号收费', n_组id, 卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, 合作单位_In, 4);

      If Nvl(结算卡序号_In, 0) <> 0 And Nvl(现金支付_In, 0) <> 0 Then

        n_消费卡id := Null;
        Begin
          Select Nvl(自制卡, 0), 1 Into n_自制卡, n_Count From 卡消费接口目录 Where 编号 = 结算卡序号_In;
        Exception
          When Others Then
            n_Count := 0;
        End;
        If n_Count = 0 Then
          v_Err_Msg := '没有发现原结算卡的相应类别,不能继续操作！';
          Raise Err_Item;
        End If;
        If n_自制卡 = 1 Then
          Select ID
          Into n_消费卡id
          From 消费卡目录
          Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In And
                序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In);
        End If;
        Zl_病人卡结算记录_Insert(结算卡序号_In, n_消费卡id, 结算方式_In, 现金支付_In, 卡号_In, Null, 登记时间_In, Null, 结帐id_In, n_预交id);
      End If;

    End If;

    --对于医保挂号
    If Nvl(个帐支付_In, 0) <> 0 And 序号_In = 1 Then
      Insert Into 病人预交记录
        (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), v_个人帐户, 个帐支付_In, 登记时间_In, 操作员编号_In,
         操作员姓名_In, 结帐id_In, '医保挂号', n_组id, 4);
    End If;

    --对于就诊卡通过预交金挂号
    If Nvl(预交支付_In, 0) <> 0 And 序号_In = 1 Then
      n_预交金额 := 预交支付_In;
      For r_Deposit In c_Deposit(病人id_In, v_冲预交病人ids) Loop
        n_当前金额 := Case
                    When r_Deposit.金额 - n_预交金额 < 0 Then
                     r_Deposit.金额
                    Else
                     n_预交金额
                  End;

        If r_Deposit.结帐id = 0 Then
          --第一次冲预交(填上结帐ID,金额为0)
          Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 4 Where ID = r_Deposit.原预交id;

        End If;
        --冲上次剩余额
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 预交类别, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号,
           冲预交, 结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 预交类别, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 登记时间_In, 操作员姓名_In, 操作员编号_In, n_当前金额, 结帐id_In, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
          From 病人预交记录
          Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;

        --更新病人预交余额
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) - n_当前金额
        Where 病人id = r_Deposit.病人id And 性质 = 1 And 类型 = Nvl(1, 2);
        --检查是否已经处理完
        If r_Deposit.金额 < n_预交金额 Then
          n_预交金额 := n_预交金额 - r_Deposit.金额;
        Else
          n_预交金额 := 0;
        End If;

        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
      If n_预交金额 > 0 Then
        v_Err_Msg := '预交余不够支付本次支付金额,不能继续操作！';
        Raise Err_Item;

      End If;
      Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
    End If;

    --相关汇总表的处理
    --人员缴款余额
    If 序号_In = 1 And Nvl(更新交款余额_In, 1) = 1 Then
      If Nvl(现金支付_In, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + 现金支付_In
        Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = Nvl(结算方式_In, v_现金)
        Returning 余额 Into n_返回值;

        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (操作员姓名_In, Nvl(结算方式_In, v_现金), 1, 现金支付_In);
          n_返回值 := 现金支付_In;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = 操作员姓名_In And 结算方式 = Nvl(结算方式_In, v_现金) And 性质 = 1 And Nvl(余额, 0) = 0;
        End If;
      End If;

      If Nvl(个帐支付_In, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + 个帐支付_In
        Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = v_个人帐户
        Returning 余额 Into n_返回值;

        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, v_个人帐户, 1, 个帐支付_In);
          n_返回值 := 个帐支付_In;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_个人帐户 And Nvl(余额, 0) = 0;
        End If;
      End If;
    End If;
  End If;

  --病人挂号汇总(只处理一次,且单独收取病历费不处理)
  If Nvl(预约挂号_In, 0) = 0 Then
    If Nvl(记帐费用_In, 0) = 0 Then
      --处理票据使用情况
      If 序号_In = 1 And 票据号_In Is Not Null Then
        Select 票据打印内容_Id.Nextval Into n_打印id From Dual;

        --发出票据
        Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 4, 单据号_In);

        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
        Values
          (票据使用明细_Id.Nextval, Decode(收费票据_In, 1, 1, 4), 票据号_In, 1, 1, 领用id_In, n_打印id, 登记时间_In, 操作员姓名_In);

        --状态改动
        Update 票据领用记录
        Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
        Where ID = Nvl(领用id_In, 0);
      End If;
    End If;
    --病人本次就诊(以发生时间为准)
    If Nvl(病人id_In, 0) <> 0 And 序号_In = 1 Then
      Update 病人信息 Set 就诊时间 = 发生时间_In, 就诊状态 = 1, 就诊诊室 = 诊室_In Where 病人id = 病人id_In;
    End If;
  End If;

  If Nvl(预约挂号_In, 0) = 0 And Nvl(记帐费用_In, 0) = 1 Then
    --记帐
    If Nvl(病人id_In, 0) = 0 Then
      v_Err_Msg := '要针对病人的挂号费进行记帐，必须是建档病人才能记帐挂号。';
      Raise Err_Item;
    End If;

    --病人余额
    Update 病人余额
    Set 费用余额 = Nvl(费用余额, 0) + Nvl(实收金额_In, 0)
    Where 病人id = Nvl(病人id_In, 0) And 性质 = 1 And 类型 = 1;

    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (病人id_In, 1, 1, Nvl(实收金额_In, 0), 0);
    End If;

    --病人未结费用
    Update 病人未结费用
    Set 金额 = Nvl(金额, 0) + Nvl(实收金额_In, 0)
    Where 病人id = 病人id_In And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(病人科室id_In, 0) And
          Nvl(开单部门id, 0) = Nvl(开单部门id_In, 0) And Nvl(执行部门id, 0) = Nvl(执行部门id_In, 0) And 收入项目id + 0 = 收入项目id_In And
          来源途径 + 0 = 1;

    If Sql%RowCount = 0 Then
      Insert Into 病人未结费用
        (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
      Values
        (病人id_In, Null, Null, 病人科室id_In, 开单部门id_In, 执行部门id_In, 收入项目id_In, 1, Nvl(实收金额_In, 0));
    End If;
  End If;

  --病人挂号记录
  If 号别_In Is Not Null And 序号_In = 1 Then
    --And Nvl(预约挂号_In, 0) = 0
    Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
    Begin
      Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In And Rownum < 2;
    Exception
      When Others Then
        v_付款方式 := Null;
    End;
    Insert Into 病人挂号记录
      (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 预约时间, 操作员编号,
       操作员姓名, 复诊, 号序, 社区, 预约, 预约方式, 摘要, 交易流水号, 交易说明, 合作单位, 接收时间, 接收人, 预约操作员, 预约操作员编号, 险类, 医疗付款方式, 收费单)
    Values
      (n_挂号id, 单据号_In, Decode(Nvl(预约挂号_In, 0), 1, 2, 1), 1, 病人id_In, 门诊号_In, 姓名_In, 性别_In, 年龄_In, 号别_In, 急诊_In, 诊室_In,
       Null, 执行部门id_In, 医生姓名_In, 0, Null, 登记时间_In, 发生时间_In, Decode(Nvl(预约挂号_In, 0), 1, 发生时间_In, Null), 操作员编号_In,
       操作员姓名_In, 复诊_In, n_序号, 社区_In, Decode(预约接收_In, 1, 1, 0), 预约方式_In, 摘要_In, 交易流水号_In, 交易说明_In, 合作单位_In,
       Decode(Nvl(预约挂号_In, 0), 0, 登记时间_In, Null), Decode(Nvl(预约挂号_In, 0), 0, 操作员姓名_In, Null),
       Decode(Nvl(预约挂号_In, 0), 1, 操作员姓名_In, Null), Decode(Nvl(预约挂号_In, 0), 1, 操作员编号_In, Null),
       Decode(Nvl(险类_In, 0), 0, Null, 险类_In), v_付款方式, 收费单_In);
    If Nvl(预约挂号_In, 0) = 0 And 预约方式_In Is Not Null Then
      Update 病人挂号记录
      Set 预约 = 1, 预约时间 = 发生时间_In, 预约操作员 = 操作员姓名_In, 预约操作员编号 = 操作员编号_In
      Where ID = n_挂号id;
    End If;
    n_预约生成队列 := 0;
    If Nvl(预约挂号_In, 0) = 1 Then
      n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
    End If;

    --0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站
    If Nvl(生成队列_In, 0) <> 0 And Nvl(预约挂号_In, 0) = 0 Or n_预约生成队列 = 1 Then
      n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
      If Nvl(n_分诊台签到排队, 0) = 0 Or n_预约生成队列 = 1 Then
      n_分时点显示 := Nvl(Zl_To_Number(zl_GetSysParameter(270)), 0);
      If Nvl(预约挂号_In, 0) = 1 And n_分时点显示 = 1 And n_分时段 = 1 Then
        n_分时点显示 := 1;
      Else
        n_分时点显示 := Null;
      End If;

        --产生队列
        --.按”执行部门” 的方式生成队列
        v_队列名称 := 执行部门id_In;
        v_排队号码 := Zlgetnextqueue(执行部门id_In, n_挂号id, 号别_In || '|' || n_序号);
        v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
        d_排队时间 := Zl_Get_Queuedate(n_挂号id, 号别_In, n_序号, 发生时间_In);
        --  队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,排队标记_In,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In, 排队时间_In
        Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, 执行部门id_In, v_排队号码, Null, 姓名_In, 病人id_In, 诊室_In, 医生姓名_In, d_排队时间, 预约方式_In,
                         n_分时点显示, v_排队序号);

        --挂号立即排队
        If Nvl(n_分诊台签到排队, 0) = 0 Then
          Update 病人挂号记录 Set 记录标志 = 1 Where ID = n_挂号id;
        End If;
      End If;
    End If;
  End If;
  --病人担保信息
  If 病人id_In Is Not Null And 序号_In = 1 Then
    --取参数:
    If Nvl(n_结算模式, 0) <> Nvl(结算模式_In, 0) Then
      --结算模式的确定

      v_Err_Msg := Null;
      Begin
        Select Nvl(结算模式, 0) Into n_结算模式 From 病人信息 Where 病人id = 病人id_In;
      Exception
        When Others Then
          v_Err_Msg := '未找到指定的病人信息,不允许挂号';
      End;

      If v_Err_Msg Is Not Null Then
        Raise Err_Item;
      End If;
      If n_结算模式 = 1 And Nvl(结算模式_In, 0) = 0 Then
        --病人已经是"先诊疗后结算的",本次是"先结算后诊疗的",则检查是否存在未结数据
        Select Count(1)
        Into n_Count
        From 病人未结费用
        Where 病人id = 病人id_In And (来源途径 In (1, 4) Or 来源途径 = 3 And Nvl(主页id, 0) = 0) And Nvl(金额, 0) <> 0 And Rownum < 2;
        If Nvl(n_Count, 0) <> 0 Then
          --存在未结算数据，必须先结算后才允许执行
          v_Err_Msg := '当前病人的就诊模式为先诊疗后结算且存在未结费用，不允许调整该病人的就诊模式,你可以先对未结费用结帐后再挂号或不调整病人的就诊模式!';
          Raise Err_Item;
        End If;
        --检查
        --未发生医嘱业务的（即当时就挂号的,需要保证同一次的就诊模式是一至的(程序已经检查，不用再处理)
      End If;
      Update 病人信息 Set 结算模式 = 结算模式_In Where 病人id = 病人id_In;
    End If;

    Update 病人信息
    Set 担保人 = Null, 担保额 = Null, 担保性质 = Null
    Where 病人id = 病人id_In And Nvl(在院, 0) = 0 And Exists
     (Select 1
           From 病人担保记录
           Where 病人id = 病人id_In And 主页id Is Not Null And
                 登记时间 = (Select Max(登记时间) From 病人担保记录 Where 病人id = 病人id_In));

    If Sql%RowCount > 0 Then
      Update 病人担保记录
      Set 到期时间 = Sysdate
      Where 病人id = 病人id_In And 主页id Is Not Null And Nvl(到期时间, Sysdate) >= Sysdate;
    End If;
  End If;
  If 序号_In = 1 Then
    --消息推送
    Begin
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 1, n_挂号id;
    Exception
      When Others Then
        Null;
    End;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人挂号记录_Insert;
/

--92335:李南春,2017-06-22,三方支付新模式及过程拆分
Create Or Replace Procedure Zl_预约挂号接收_Insert
(
  No_In            门诊费用记录.No%Type,
  票据号_In        门诊费用记录.实际票号%Type,
  领用id_In        票据使用明细.领用id%Type,
  结帐id_In        门诊费用记录.结帐id%Type,
  诊室_In          门诊费用记录.发药窗口%Type,
  病人id_In        门诊费用记录.病人id%Type,
  门诊号_In        门诊费用记录.标识号%Type,
  姓名_In          门诊费用记录.姓名%Type,
  性别_In          门诊费用记录.性别%Type,
  年龄_In          门诊费用记录.年龄%Type,
  付款方式_In      门诊费用记录.付款方式%Type, --用于存放病人的医疗付款方式编号
  费别_In          门诊费用记录.费别%Type,
  结算方式_In      病人预交记录.结算方式%Type, --现金的结算名称
  现金支付_In      病人预交记录.冲预交%Type, --挂号时现金支付部份金额
  预交支付_In      病人预交记录.冲预交%Type, --挂号时使用的预交金额
  个帐支付_In      病人预交记录.冲预交%Type, --挂号时个人帐户支付金额
  发生时间_In      门诊费用记录.发生时间%Type,
  号序_In          挂号序号状态.序号%Type,
  操作员编号_In    门诊费用记录.操作员编号%Type,
  操作员姓名_In    门诊费用记录.操作员姓名%Type,
  生成队列_In      Number := 0,
  登记时间_In      门诊费用记录.登记时间%Type := Null,
  卡类别id_In      病人预交记录.卡类别id%Type := Null,
  结算卡序号_In    病人预交记录.结算卡序号%Type := Null,
  卡号_In          病人预交记录.卡号%Type := Null,
  交易流水号_In    病人预交记录.交易流水号%Type := Null,
  交易说明_In      病人预交记录.交易说明%Type := Null,
  险类_In          病人挂号记录.险类%Type := Null,
  结算模式_In      Number := 0,
  记帐费用_In      Number := 0,
  冲预交病人ids_In Varchar2 := Null,
  三方调用_In      Number := 0,
  更新交款余额_In  Number := 1,
  摘要_In          病人挂号记录.摘要%Type := Null
) As
  --该游标用于收费冲预交的可用预交列表
  --以ID排序，优先冲上次未冲完的。
  --更新交款余额_In:0-在zl_人员缴款余额_Update 中更新 1-在本过程中更新
  Cursor c_Deposit
  (
    v_病人id        病人信息.病人id%Type,
    v_冲预交病人ids Varchar2
  ) Is
    Select 病人id, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额, Min(记录状态) As 记录状态, Nvl(Max(结帐id), 0) As 结帐id,
           Max(Decode(记录性质, 1, ID, 0) * Decode(记录状态, 2, 0, 1)) As 原预交id
    From 病人预交记录
    Where 记录性质 In (1, 11) And 病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And Nvl(预交类别, 2) = 1
     Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
    Group By NO, 病人id
    Order By Decode(病人id, Nvl(v_病人id, 0), 0, 1), 结帐id, NO;

  v_Err_Msg Varchar2(255);
  Err_Item    Exception;
  Err_Special Exception;

  v_现金     结算方式.名称%Type;
  v_个人帐户 结算方式.名称%Type;
  v_队列名称 排队叫号队列.队列名称%Type;
  v_号别     门诊费用记录.计算单位%Type;
  v_号序     门诊费用记录.发药窗口%Type;
  v_排队号码 排队叫号队列.排队号码 %Type;
  v_预约方式 病人挂号记录.预约方式 %Type;

  n_打印id        票据打印内容.Id%Type;
  n_预交金额      病人预交记录.金额%Type;
  n_返回值        病人预交记录.金额%Type;
  v_冲预交病人ids Varchar2(4000);

  n_挂号id         病人挂号记录.Id%Type;
  n_分诊台签到排队 Number;
  n_组id           财务缴款分组.Id%Type;
  n_Count          Number(18);
  n_排队           Number;
  n_当天排队       Number;
  n_当前金额       病人预交记录.金额%Type;
  n_预交id         病人预交记录.Id%Type;
  n_消费卡id       消费卡目录.Id%Type;
  n_自制卡         Number;

  d_Date       Date;
  d_预约时间   门诊费用记录.发生时间%Type;
  d_发生时间   Date;
  d_排队时间   Date;
  n_时段       Number := 0;
  n_存在       Number := 0;
  v_排队序号   排队叫号队列.排队序号%Type;
  n_结算模式   病人信息.结算模式%Type;
  n_票种       票据使用明细.票种%Type;
  v_付款方式   病人挂号记录.医疗付款方式%Type;
  v_操作员姓名 病人挂号记录.接收人%Type;
  n_接收模式   Number := 0;
Begin
  n_组id          := Zl_Get组id(操作员姓名_In);
  v_冲预交病人ids := Nvl(冲预交病人ids_In, 病人id_In);
  n_接收模式      := Nvl(zl_GetSysParameter('预约接收模式', 1111), 0);

  --获取结算方式名称
  Begin
    Select 名称 Into v_现金 From 结算方式 Where 性质 = 1;
  Exception
    When Others Then
      v_现金 := '现金';
  End;
  Begin
    Select 名称 Into v_个人帐户 From 结算方式 Where 性质 = 3;
  Exception
    When Others Then
      v_个人帐户 := '个人帐户';
  End;
  If 登记时间_In Is Null Then
    Select Sysdate Into d_Date From Dual;
  Else
    d_Date := 登记时间_In;
  End If;

  --更新挂号序号状态
  Begin
    Select 号别, 号序, Trunc(发生时间), 发生时间, 预约方式
    Into v_号别, v_号序, d_预约时间, d_发生时间, v_预约方式
    From 病人挂号记录
    Where 记录性质 = 2 And 记录状态 = 1 And Rownum = 1 And NO = No_In;
  Exception
    When Others Then
      Select Max(接收人) Into v_操作员姓名 From 病人挂号记录 Where 记录性质 = 2 And 记录状态 In (1, 3) And NO = No_In;
      If v_操作员姓名 Is Null Then
        v_Err_Msg := '当前预约挂号单已被取消';
        Raise Err_Item;
      Else
        If v_操作员姓名 = 操作员姓名_In Then
          v_Err_Msg := '当前预约挂号单已被接收';
          Raise Err_Special;
        Else
          v_Err_Msg := '当前预约挂号单已被其它人接收';
          Raise Err_Item;
        End If;
      End If;
  End;

  --判断是否分时段
  Begin
    Select 1
    Into n_时段
    From Dual
    Where Exists (Select 1
           From 挂号安排时段 A, 挂号安排 B
           Where a.安排id = b.Id And b.号码 = v_号别 And Rownum < 2
           Union All
           Select 1
           From 挂号计划时段 C, 挂号安排计划 D 　
           Where c.计划id = d.Id And d.号码 = v_号别 And d.生效时间 > Sysdate And Rownum < 2);
  Exception
    When Others Then
      n_时段 := 0;
  End;

  If n_时段 = 0 And 三方调用_In = 0 Then
    If n_接收模式 = 0 Then
      If Trunc(发生时间_In) = Trunc(Sysdate) Then
        d_发生时间 := 发生时间_In;
      Else
        d_发生时间 := Sysdate;
      End If;
    Else
      d_发生时间 := 发生时间_In;
    End If;
  Else
    If Not 发生时间_In Is Null Then
      d_发生时间 := 发生时间_In;
    End If;
  End If;
  If Not v_号序 Is Null Then
    If 号序_In Is Null Then
      Delete 挂号序号状态 Where 号码 = v_号别 And Trunc(日期) = Trunc(d_预约时间) And 序号 = v_号序;
    Else
      If Trunc(d_预约时间) <> Trunc(Sysdate) And n_接收模式 = 0 Then
      
        If n_时段 = 0 And 三方调用_In = 0 Then
          --提前接收或延迟接收
          Delete 挂号序号状态 Where 号码 = v_号别 And Trunc(日期) = Trunc(d_预约时间) And 序号 = v_号序;
          Begin
            Select 1 Into n_存在 From 挂号序号状态 Where 号码 = v_号别 And 日期 = Trunc(Sysdate) And 序号 = v_号序;
          Exception
            When Others Then
              n_存在 := 0;
          End;
          If n_存在 = 0 Then
            Insert Into 挂号序号状态
              (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
            Values
              (v_号别, Trunc(Sysdate), v_号序, 1, 操作员姓名_In, Sysdate);
          Else
            --号码已被使用的情况
            Begin
              v_号序 := 1;
              Insert Into 挂号序号状态
                (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
              Values
                (v_号别, Trunc(Sysdate), v_号序, 1, 操作员姓名_In, Sysdate);
            Exception
              When Others Then
                Select Min(序号 + 1)
                Into v_号序
                From 挂号序号状态 A
                Where 号码 = v_号别 And 日期 = Trunc(Sysdate) And Not Exists
                 (Select 1 From 挂号序号状态 Where 号码 = a.号码 And 日期 = a.日期 And 序号 = a.序号 + 1);
                Insert Into 挂号序号状态
                  (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
                Values
                  (v_号别, Trunc(Sysdate), v_号序, 1, 操作员姓名_In, Sysdate);
            End;
          End If;
        Else
          Update 挂号序号状态
          Set 状态 = 1, 登记时间 = Sysdate
          Where Trunc(日期) = Trunc(d_预约时间) And 序号 = v_号序 And 号码 = v_号别 And 状态 = 2;
          If Sql% NotFound Then
            Begin
              Insert Into 挂号序号状态
                (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
              Values
                (v_号别, Trunc(Sysdate), v_号序, 1, 操作员姓名_In, Sysdate);
            Exception
              When Others Then
                v_Err_Msg := '序号' || v_号序 || '已被其它人使用,请重新选择一个序号.';
                Raise Err_Item;
            End;
          End If;
        
        End If;
      
      Else
        Update 挂号序号状态
        Set 序号 = 号序_In, 状态 = 1, 登记时间 = Sysdate
        Where 号码 = v_号别 And Trunc(日期) = Trunc(d_预约时间) And 序号 = v_号序;
        If Sql%RowCount = 0 Then
          Begin
            Insert Into 挂号序号状态
              (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
            Values
              (v_号别, Trunc(d_发生时间), v_号序, 1, 操作员姓名_In, Sysdate);
          Exception
            When Others Then
              v_Err_Msg := '序号' || v_号序 || '已被其它人使用,请重新选择一个序号.';
              Raise Err_Item;
          End;
        End If;
      End If;
    End If;
  Else
    If Not 号序_In Is Null Then
      Begin
        Insert Into 挂号序号状态
          (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
        Values
          (v_号别, Trunc(Sysdate), 号序_In, 1, 操作员姓名_In, Sysdate);
      Exception
        When Others Then
          v_Err_Msg := '序号' || 号序_In || '已被其它人使用,请重新选择一个序号.';
          Raise Err_Item;
      End;
      v_号序 := 号序_In;
    Else
      v_号序 := Null;
    End If;
  End If;

  --更新门诊费用记录
  Update 门诊费用记录
  Set 记录状态 = 1, 实际票号 = Decode(Nvl(记帐费用_In, 0), 1, Null, 票据号_In), 结帐id = Decode(Nvl(记帐费用_In, 0), 1, Null, 结帐id_In),
      结帐金额 = Decode(Nvl(记帐费用_In, 0), 1, Null, 实收金额), 发药窗口 = 诊室_In, 病人id = 病人id_In, 标识号 = 门诊号_In, 姓名 = 姓名_In, 年龄 = 年龄_In,
      性别 = 性别_In, 付款方式 = 付款方式_In, 费别 = 费别_In, 发生时间 = d_发生时间, 登记时间 = d_Date, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In,
      缴款组id = n_组id, 记帐费用 = Decode(Nvl(记帐费用_In, 0), 1, 1, 0), 摘要 = Nvl(摘要_In, 摘要)
  Where 记录性质 = 4 And 记录状态 = 0 And NO = No_In;

  --病人挂号记录
  Update 病人挂号记录
  Set 接收人 = 操作员姓名_In, 接收时间 = d_Date, 记录性质 = 1, 病人id = 病人id_In, 门诊号 = 门诊号_In, 发生时间 = d_发生时间, 姓名 = 姓名_In, 性别 = 性别_In,
      年龄 = 年龄_In, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In, 险类 = Decode(Nvl(险类_In, 0), 0, Null, 险类_In), 号序 = v_号序, 诊室 = 诊室_In,
      摘要 = Nvl(摘要_In, 摘要)
  Where 记录状态 = 1 And NO = No_In And 记录性质 = 2
  Returning ID Into n_挂号id;
  If Sql%NotFound Then
    Begin
      Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
      Begin
        Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In And Rownum < 2;
      Exception
        When Others Then
          v_付款方式 := Null;
      End;
      Insert Into 病人挂号记录
        (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 操作员编号, 操作员姓名,
         摘要, 号序, 预约, 预约方式, 接收人, 接收时间, 预约时间, 险类, 医疗付款方式)
        Select n_挂号id, No_In, 1, 1, 病人id_In, 门诊号_In, 姓名_In, 性别_In, 年龄_In, 计算单位, 加班标志, 诊室_In, Null, 执行部门id, 执行人, 0, Null,
               登记时间, 发生时间, 操作员编号, 操作员姓名, Nvl(摘要_In, 摘要), v_号序, 1, Substr(结论, 1, 10) As 预约方式, 操作员姓名_In,
               Nvl(登记时间_In, Sysdate), 发生时间, Decode(Nvl(险类_In, 0), 0, Null, 险类_In), v_付款方式
        From 门诊费用记录
        Where 记录性质 = 4 And 记录状态 = 1 And Rownum = 1 And NO = No_In;
    Exception
      When Others Then
        v_Err_Msg := '由于并发原因,单据号为【' || No_In || '】的病人' || 姓名_In || '已经被接收';
        Raise Err_Item;
    End;
  End If;

  --0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站
  If Nvl(生成队列_In, 0) <> 0 Then
    n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
    If Nvl(n_分诊台签到排队, 0) = 0 Then
      For v_挂号 In (Select ID, 姓名, 诊室, 执行人, 执行部门id, 发生时间, 号别, 号序 From 病人挂号记录 Where NO = No_In) Loop
      
        Begin
          Select 1,
                 Case
                   When 排队时间 < Trunc(Sysdate) Then
                    1
                   Else
                    0
                 End
          Into n_排队, n_当天排队
          From 排队叫号队列
          Where 业务类型 = 0 And 业务id = v_挂号.Id And Rownum <= 1;
        Exception
          When Others Then
            n_排队 := 0;
        End;
        If n_排队 = 0 Then
          --产生队列
          --按”执行部门”产生队列
          n_挂号id   := v_挂号.Id;
          v_队列名称 := v_挂号.执行部门id;
          v_排队号码 := Zlgetnextqueue(v_挂号.执行部门id, n_挂号id, v_挂号.号别 || '|' || v_挂号.号序);
          v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
        
          --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)
          d_排队时间 := Zl_Get_Queuedate(n_挂号id, v_挂号.号别, v_挂号.号序, v_挂号.发生时间);
          --   队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,排队标记_In,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In,
          Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, v_挂号.执行部门id, v_排队号码, Null, 姓名_In, 病人id_In, v_挂号.诊室, v_挂号.执行人, d_排队时间,
                           v_预约方式, Null, v_排队序号);
        Elsif Nvl(n_当天排队, 0) = 1 Then
          --更新队列号
          v_排队号码 := Zlgetnextqueue(v_挂号.执行部门id, v_挂号.Id, v_挂号.号别 || '|' || Nvl(v_挂号.号序, 0));
          v_排队序号 := Zlgetsequencenum(0, v_挂号.Id, 1);
          --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In, 医生姓名_In ,排队号码_In
          Zl_排队叫号队列_Update(v_挂号.执行部门id, 0, v_挂号.Id, v_挂号.执行部门id, v_挂号.姓名, v_挂号.诊室, v_挂号.执行人, v_排队号码, v_排队序号);
        
        Else
          --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In, 医生姓名_In ,排队号码_In
          Zl_排队叫号队列_Update(v_挂号.执行部门id, 0, v_挂号.Id, v_挂号.执行部门id, v_挂号.姓名, v_挂号.诊室, v_挂号.执行人);
        End If;
        --预约接收时，改变记录标志
        Update 病人挂号记录 Set 记录标志 = 1 Where ID = n_挂号id;
      End Loop;
    End If;
  End If;

  --汇总结算到病人预交记录
  If (Nvl(现金支付_In, 0) <> 0 Or (Nvl(现金支付_In, 0) = 0 And Nvl(个帐支付_In, 0) = 0 And Nvl(预交支付_In, 0) = 0)) And
     Nvl(记帐费用_In, 0) = 0 Then
    Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
    Insert Into 病人预交记录
      (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 结算序号,
       结算性质)
    Values
      (n_预交id, 4, 1, No_In, 病人id_In, Nvl(结算方式_In, v_现金), Nvl(现金支付_In, 0), d_Date, 操作员编号_In, 操作员姓名_In, 结帐id_In, '挂号收费',
       n_组id, 卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, 结帐id_In, 4);
  
    If Nvl(结算卡序号_In, 0) <> 0 And Nvl(现金支付_In, 0) <> 0 Then
    
      n_消费卡id := Null;
      Begin
        Select Nvl(自制卡, 0), 1 Into n_自制卡, n_Count From 卡消费接口目录 Where 编号 = 结算卡序号_In;
      Exception
        When Others Then
          n_Count := 0;
      End;
      If n_Count = 0 Then
        v_Err_Msg := '[ZLSOFT]没有发现原结算卡的相应类别,不能继续操作！[ZLSOFT]';
        Raise Err_Item;
      End If;
      If n_自制卡 = 1 Then
        Select ID
        Into n_消费卡id
        From 消费卡目录
        Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In And
              序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In);
      End If;
      Zl_病人卡结算记录_Insert(结算卡序号_In, n_消费卡id, 结算方式_In, 现金支付_In, 卡号_In, Null, 登记时间_In, Null, 结帐id_In, n_预交id);
    End If;
  
  End If;

  --对于就诊卡通过预交金挂号
  If Nvl(预交支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 Then
    n_预交金额 := 预交支付_In;
    For r_Deposit In c_Deposit(病人id_In, v_冲预交病人ids) Loop
      n_当前金额 := Case
                  When r_Deposit.金额 - n_预交金额 < 0 Then
                   r_Deposit.金额
                  Else
                   n_预交金额
                End;
      If r_Deposit.结帐id = 0 Then
        --第一次冲预交(填上结帐ID,金额为0)
        Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 4 Where ID = r_Deposit.原预交id;
      End If;
      --冲上次剩余额
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结算序号, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 登记时间_In,
               操作员姓名_In, 操作员编号_In, n_当前金额, 结帐id_In, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结帐id_In, 4
        From 病人预交记录
        Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
    
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - n_当前金额
      Where 病人id = r_Deposit.病人id And 性质 = 1 And 类型 = Nvl(1, 2)
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (r_Deposit.病人id, Nvl(1, 2), -1 * n_当前金额, 1);
        n_返回值 := -1 * n_当前金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Deposit.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --检查是否已经处理完
      If r_Deposit.金额 < n_预交金额 Then
        n_预交金额 := n_预交金额 - r_Deposit.金额;
      Else
        n_预交金额 := 0;
      End If;
    
      If n_预交金额 = 0 Then
        Exit;
      End If;
    End Loop;
  End If;

  --对于医保挂号
  If Nvl(个帐支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 Then
    Insert Into 病人预交记录
      (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
       预交类别, 结算序号, 结算性质)
    Values
      (病人预交记录_Id.Nextval, 4, 1, No_In, 病人id_In, v_个人帐户, 个帐支付_In, d_Date, 操作员编号_In, 操作员姓名_In, 结帐id_In, '医保挂号', n_组id,
       Null, Null, Null, Null, Null, Null, Null, 结帐id_In, 4);
  End If;

  --相关汇总表的处理
  --人员缴款余额
  If Nvl(现金支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 And Nvl(更新交款余额_In, 1) = 1 Then
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + 现金支付_In
    Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = Nvl(结算方式_In, v_现金)
    Returning 余额 Into n_返回值;
  
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额
        (收款员, 结算方式, 性质, 余额)
      Values
        (操作员姓名_In, Nvl(结算方式_In, v_现金), 1, 现金支付_In);
      n_返回值 := 现金支付_In;
    
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 人员缴款余额
      Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = Nvl(结算方式_In, v_现金) And Nvl(余额, 0) = 0;
    End If;
  End If;

  If Nvl(个帐支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 And Nvl(更新交款余额_In, 1) = 1 Then
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + 个帐支付_In
    Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = v_个人帐户
    Returning 余额 Into n_返回值;
  
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, v_个人帐户, 1, 个帐支付_In);
      n_返回值 := 个帐支付_In;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 人员缴款余额 Where 收款员 = 操作员姓名_In And 性质 = 1 And Nvl(余额, 0) = 0;
    End If;
  End If;

  --处理票据使用情况
  If 票据号_In Is Not Null And Nvl(记帐费用_In, 0) = 0 Then
    Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
  
    --当前票据的票种
    Select 票种 Into n_票种 From 票据领用记录 Where ID = Nvl(领用id_In, 0);
    --发出票据
    Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 4, No_In);
  
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
    Values
      (票据使用明细_Id.Nextval, n_票种, 票据号_In, 1, 1, 领用id_In, n_打印id, d_Date, 操作员姓名_In);
  
    --状态改动
    Update 票据领用记录
    Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = d_Date
    Where ID = Nvl(领用id_In, 0);
  End If;

  If Nvl(记帐费用_In, 0) = 1 Then
    --记帐
    If Nvl(病人id_In, 0) = 0 Then
      v_Err_Msg := '要针对病人的挂号费进行记帐，必须是建档病人才能记帐挂号。';
      Raise Err_Item;
    End If;
    For c_费用 In (Select 实收金额, 病人科室id, 开单部门id, 执行部门id, 收入项目id
                 From 门诊费用记录
                 Where 记录性质 = 4 And 记录状态 = 1 And NO = No_In And Nvl(记帐费用, 0) = 1) Loop
      --病人余额
      Update 病人余额
      Set 费用余额 = Nvl(费用余额, 0) + Nvl(c_费用.实收金额, 0)
      Where 病人id = Nvl(病人id_In, 0) And 性质 = 1 And 类型 = 1;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 费用余额, 预交余额)
        Values
          (病人id_In, 1, 1, Nvl(c_费用.实收金额, 0), 0);
      End If;
    
      --病人未结费用
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) + Nvl(c_费用.实收金额, 0)
      Where 病人id = 病人id_In And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(c_费用.病人科室id, 0) And
            Nvl(开单部门id, 0) = Nvl(c_费用.开单部门id, 0) And Nvl(执行部门id, 0) = Nvl(c_费用.执行部门id, 0) And 收入项目id + 0 = c_费用.收入项目id And
            来源途径 + 0 = 1;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人未结费用
          (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
        Values
          (病人id_In, Null, Null, c_费用.病人科室id, c_费用.开单部门id, c_费用.执行部门id, c_费用.收入项目id, 1, Nvl(c_费用.实收金额, 0));
      End If;
    End Loop;
  End If;
  If Nvl(病人id_In, 0) <> 0 Then
    n_结算模式 := 0;
    Update 病人信息
    Set 就诊时间 = d_发生时间, 就诊状态 = 1, 就诊诊室 = 诊室_In
    Where 病人id = 病人id_In
    Returning Nvl(结算模式, 0) Into n_结算模式;
    --取参数:
    If Nvl(n_结算模式, 0) <> Nvl(结算模式_In, 0) Then
      --结算模式的确定
      If n_结算模式 = 1 And Nvl(结算模式_In, 0) = 0 Then
        --病人已经是"先诊疗后结算的",本次是"先结算后诊疗的",则检查是否存在未结数据
        Select Count(1)
        Into n_Count
        From 病人未结费用
        Where 病人id = 病人id_In And (来源途径 In (1, 4) Or 来源途径 = 3 And Nvl(主页id, 0) = 0) And Nvl(金额, 0) <> 0 And Rownum < 2;
        If Nvl(n_Count, 0) <> 0 Then
          --存在未结算数据，必须先结算后才允许执行
          v_Err_Msg := '当前病人的就诊模式为先诊疗后结算且存在未结费用，不允许调整该病人的就诊模式,你可以先对未结费用结帐后再挂号或不调整病人的就诊模式!';
          Raise Err_Item;
        End If;
        --检查
        --未发生医嘱业务的（即当时就挂号的,需要保证同一次的就诊模式是一至的(程序已经检查，不用再处理)
      End If;
      Update 病人信息 Set 结算模式 = 结算模式_In Where 病人id = 病人id_In;
    End If;
  End If;

  --病人担保信息
  If 病人id_In Is Not Null Then
    Update 病人信息
    Set 担保人 = Null, 担保额 = Null, 担保性质 = Null
    Where 病人id = 病人id_In And Nvl(在院, 0) = 0 And Exists
     (Select 1
           From 病人担保记录
           Where 病人id = 病人id_In And 主页id Is Not Null And
                 登记时间 = (Select Max(登记时间) From 病人担保记录 Where 病人id = 病人id_In));
    If Sql%RowCount > 0 Then
      Update 病人担保记录
      Set 到期时间 = d_Date
      Where 病人id = 病人id_In And 主页id Is Not Null And Nvl(到期时间, d_Date) >= d_Date;
    End If;
  End If;
  --消息推送
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 1, n_挂号id;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Err_Special Then
    Raise_Application_Error(-20105, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_预约挂号接收_Insert;
/

--92335:李南春,2017-06-22,三方支付新模式及过程拆分
Create Or Replace Procedure Zl_门诊收费结算_Modify
(
  操作类型_In      Number,
  病人id_In        门诊费用记录.病人id%Type,
  结帐id_In        病人预交记录.结帐id%Type,
  结算方式_In      Varchar2,
  冲预交_In        病人预交记录.冲预交%Type := Null,
  退支票额_In      病人预交记录.冲预交%Type := Null,
  卡类别id_In      病人预交记录.卡类别id%Type := Null,
  卡号_In          病人预交记录.卡号%Type := Null,
  交易流水号_In    病人预交记录.交易流水号%Type := Null,
  交易说明_In      病人预交记录.交易说明%Type := Null,
  缴款_In          病人预交记录.缴款%Type := Null,
  找补_In          病人预交记录.找补%Type := Null,
  误差金额_In      门诊费用记录.实收金额%Type := Null,
  完成结算_In      Number := 0,
  缺省结算方式_In  结算方式.名称%Type := Null,
  冲预交病人ids_In Varchar2 := Null,
  更新交款余额_In  Number := 1
) As
  ------------------------------------------------------------------------------------------------------------------------------
  --功能:收费结算时,修改结算的相关信息
  --操作类型_In:
  --   0-普通收费方式:
  --     ①结算方式_IN:允许传入多个,格式为:"结算方式|结算金额|结算号码|结算摘要||.." ;也允许传入空.
  --     ②退支票额_In:如果涉及退支票,则传入本次的退支票额,非正常收费时,传入零
  --   1.三方卡结算:
  --     ①结算方式_IN:只能传入一个结算方式,但允许包含一些辅助信息,格式为:"结算方式|结算金额|结算号码|结算摘要"
  --     ②退支票额_In:传入零
  --     ③卡类别ID_IN,卡号_IN,交易流水号_IN,交易说明_In:需要传入
  --   2-医保结算(如果存在医保的结算,则要先删除原医保结算,后按新传入的更新)
  --     ①结算方式_IN:允许传入多个,格式为:结算方式|结算金额||.."
  --     ②退支票额_In:传入零
  --   3-消费卡结算:
  --     ①结算方式_IN:允许一次刷多张卡,格式为:卡类别ID|卡号|消费卡ID|消费金额||."  消费卡ID:为零时,根据卡号自动定位
  --     ②冲预交_In: 传入零
  --     ②退支票额_In:传入零
  -- 冲预交_In: 存在冲预交时,传入
  -- 误差金额_In:存在误差费时,传入
  -- 完成结算_In:1-完成收费;0-未完成收费
  -- 冲预交病人ids_In:多个用逗分分离,冲预交时有效(冲预交类别与业务操作保持一致),主要是使用家属的预交款
  -- 更新交款余额_In:0-在zl_人员缴款余额_Update 中更新 1-在本过程中更新
  ------------------------------------------------------------------------------------------------------------------------------
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_结算内容      Varchar2(500);
  v_当前结算      Varchar2(50);
  v_卡号          病人医疗卡信息.卡号%Type;
  n_消费卡id      消费卡目录.Id%Type;
  n_卡类别id      病人预交记录.结算卡序号%Type;
  v_名称          Varchar2(100);
  n_自制卡        卡消费接口目录.自制卡%Type;
  n_序号          病人卡结算记录.序号%Type;
  n_Id            病人卡结算记录.Id%Type;
  n_预交id        病人预交记录.Id%Type;
  v_结算方式      病人预交记录.结算方式%Type;
  n_结算金额      病人预交记录.冲预交%Type;
  n_返回值        人员缴款余额.余额%Type;
  n_预交金额      病人预交记录.冲预交%Type;
  n_冲预交        病人预交记录.冲预交%Type;
  v_退支票        病人预交记录.结算方式%Type;
  v_结算号码      病人预交记录.结算号码%Type;
  v_结算摘要      病人预交记录.摘要%Type;
  v_误差费        结算方式.名称%Type;
  n_Count         Number;
  n_Havenull      Number;
  l_预交id        t_Numlist := t_Numlist();
  v_冲预交病人ids Varchar2(4000);
  n_会话号        病人预交记录.会话号%Type; --格式：SID+'_'+SERIAL#

  Cursor c_Feedata Is
    Select Max(m.病人id) As 病人id, Max(m.登记时间) As 登记时间, Max(m.操作员编号) As 操作员编号, Max(m.操作员姓名) As 操作员姓名, Sum(结帐金额) As 结算金额,
           Max(m.缴款组id) As 缴款组id
    From 门诊费用记录 M
    Where m.结帐id = 结帐id_In;
  r_Feedata c_Feedata%RowType;

  Cursor c_Balancedata Is
    Select 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号
    From 病人预交记录
    Where 结帐id = 结帐id_In And 结算方式 Is Null;
  r_Balancedata c_Balancedata%RowType;

Begin
  Begin
    Select Sid || '_' || Serial# Into n_会话号 From V$session Where Audsid = Userenv('sessionid');
  Exception
    When Others Then
      n_会话号 := Null;
  End;

  Begin
    Select 名称 Into v_误差费 From 结算方式 Where Nvl(性质, 0) = 9;
  Exception
    When Others Then
      v_误差费 := '误差费';
  End;

  v_冲预交病人ids := Nvl(冲预交病人ids_In, 病人id_In);

  --0.正式结算
  Select Count(1), Max(Decode(结算方式, Null, 1, 0))
  Into n_Count, n_Havenull
  From 病人预交记录
  Where 结帐id = 结帐id_In;

  --1.增加结算方式为空的结算数据
  n_结算金额 := 0;
  n_Count    := 0;
  Open c_Feedata;
  Begin
    Fetch c_Feedata
      Into r_Feedata;
    --修正或新增结算方式为null的记录
    Select Nvl(Sum(冲预交), 0) Into n_结算金额 From 病人预交记录 Where 结帐id = 结帐id_In;
    If Nvl(n_Havenull, 0) = 0 Or Round(Nvl(r_Feedata.结算金额, 0), 6) <> Round(Nvl(n_结算金额, 0), 6) Then
      --先删除存在的结算方式为null的记录
      Delete From 病人预交记录 Where 结帐id = 结帐id_In And 结算方式 Is Null;
      Select Nvl(Sum(冲预交), 0) Into n_结算金额 From 病人预交记录 Where 结帐id = 结帐id_In;
    
      n_结算金额 := Round(Nvl(r_Feedata.结算金额, 0) - n_结算金额, 6);
    
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质, 会话号)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 1, Decode(病人id_In, 0, Null, 病人id_In), Null, r_Feedata.登记时间, r_Feedata.操作员编号,
         r_Feedata.操作员姓名, n_结算金额, 结帐id_In, r_Feedata.缴款组id, -1 * 结帐id_In, 1, 3, n_会话号);
    End If;
  Exception
    When Others Then
      n_Count := 1;
  End;
  Close c_Feedata;
  If n_Count = 1 Then
    v_Err_Msg := '未找到指定的收费明细数据,结算操作失败！';
    Raise Err_Item;
  End If;

  If 操作类型_In = 0 And Nvl(退支票额_In, 0) <> 0 Then
    Begin
      Select b.名称
      Into v_退支票
      From 结算方式应用 A, 结算方式 B
      Where a.应用场合 = '收费' And b.名称 = a.结算方式 And Nvl(b.应付款, 0) = 1 And Rownum <= 1;
    Exception
      When Others Then
        v_退支票 := '无';
    End;
    If v_退支票 = '无' Then
      v_Err_Msg := '在结算场合中,不存在结算性质为应付款的结算方式,请在[结算方式]中设置！';
      Raise Err_Item;
    End If;
  End If;

  Open c_Balancedata;
  Fetch c_Balancedata
    Into r_Balancedata;

  If Nvl(误差金额_In, 0) <> 0 Then
    Update 病人预交记录
    Set 冲预交 = Nvl(冲预交, 0) + Nvl(误差金额_In, 0)
    Where 结帐id = 结帐id_In And 结算方式 = v_误差费;
    If Sql%NotFound Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, Null, v_误差费, r_Balancedata.收款时间, r_Balancedata.操作员编号,
         r_Balancedata.操作员姓名, 误差金额_In, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null, Null, 卡号_In,
         交易流水号_In, 交易说明_In, Null, 3, n_会话号);
    End If;
    Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(误差金额_In, 0) Where 结帐id = 结帐id_In And 结算方式 Is Null;
    If Sql%NotFound Then
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
      Raise Err_Item;
    End If;
  End If;

  --预交款处理
  If Nvl(冲预交_In, 0) <> 0 Then
    If Nvl(病人id_In, 0) = 0 Then
      v_Err_Msg := '不能确定病人的病人ID,收费不能使用预交款结算,结算操作失败！';
      Raise Err_Item;
    End If;
  
    --病人余额检查
    Begin
      Select Sum(Nvl(预交余额, 0) - Nvl(费用余额, 0))
      Into n_预交金额
      From 病人余额
      Where 病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And Nvl(性质, 0) = 1 And 类型 = 1;
    Exception
      When Others Then
        n_预交金额 := 0;
    End;
    If n_预交金额 < 冲预交_In Then
      v_Err_Msg := '病人的当前预交余额为 ' || LTrim(To_Char(n_预交金额, '9999999990.00')) || '，小于本次支付金额 ' ||
                   LTrim(To_Char(冲预交_In, '9999999990.00')) || '，支付失败！';
      Raise Err_Item;
    End If;
  
    n_预交金额 := 冲预交_In;
  
    --先缴先用，且先用自己的
    --不包含结算方式为代收款项的预交款。
    For c_冲预交 In (Select a.No, Sum(Nvl(a.金额, 0) - Nvl(a.冲预交, 0)) As 金额, Nvl(Max(a.结帐id), 0) As 结帐id, Max(病人id) As 病人id,
                         Max(Decode(a.记录性质, 1, a.记录状态, 1)) As 记录状态,
                         Max(Decode(a.记录性质, 1, Decode(a.记录状态, 1, a.Id, 3, a.Id, 0), 0)) As ID,
                         Max(Decode(a.记录性质, 1, Decode(a.记录状态, 1, a.收款时间, 3, a.收款时间, Null, Null))) As 收款时间
                  From 病人预交记录 A
                  Where a.记录性质 In (1, 11) And a.病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And
                        Nvl(a.预交类别, 2) = 1 And a.结算方式 Not In (Select 名称 From 结算方式 Where 性质 = 5)
                  Group By a.No
                  Having Sum(Nvl(a.金额, 0) - Nvl(a.冲预交, 0)) <> 0
                  Order By Decode(病人id, Nvl(病人id_In, 0), 0, 1), 收款时间) Loop
    
      If c_冲预交.金额 - n_预交金额 < 0 Then
        n_冲预交 := c_冲预交.金额;
      Else
        n_冲预交 := n_预交金额;
      End If;
    
      If c_冲预交.结帐id = 0 Then
        --第一次冲预交(填上结帐ID,金额为0)
        Update 病人预交记录
        Set 冲预交 = 0, 结帐id = 结帐id_In, 结算序号 = -1 * 结帐id_In, 结算性质 = 3, 会话号 = n_会话号
        Where ID = c_冲预交.Id;
      End If;
      --冲上次剩余额
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质, 会话号)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
               r_Balancedata.收款时间, r_Balancedata.操作员姓名, r_Balancedata.操作员编号, n_冲预交, 结帐id_In, r_Balancedata.缴款组id, 预交类别,
               卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, -1 * 结帐id_In, 3, n_会话号
        From 病人预交记录
        Where NO = c_冲预交.No And 记录状态 = c_冲预交.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
    
      --更新数据(结算方式为NULL的)
      Update 病人预交记录
      Set 冲预交 = 冲预交 - n_冲预交
      Where 结帐id = 结帐id_In And 结算方式 Is Null
      Returning Nvl(冲预交, 0) Into n_返回值;
    
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - n_冲预交
      Where 病人id = c_冲预交.病人id And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (c_冲预交.病人id, 1, -1 * n_冲预交, 1);
        n_返回值 := -1 * n_冲预交;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = c_冲预交.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --检查是否已经处理完
      If c_冲预交.金额 < n_预交金额 Then
        n_预交金额 := n_预交金额 - c_冲预交.金额;
      Else
        n_预交金额 := 0;
      End If;
      If n_预交金额 = 0 Then
        Exit;
      End If;
    
    End Loop;
    --检查金额是否足够
    If Abs(n_预交金额) > 0 Then
      v_Err_Msg := '病人的当前预交余额小于本次支付金额 ' || LTrim(To_Char(冲预交_In, '9999999990.00')) || '，支付失败！';
      Raise Err_Item;
    End If;
  End If;

  If 操作类型_In = 0 Then
  
    If Nvl(退支票额_In, 0) <> 0 Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, Null, v_退支票, r_Balancedata.收款时间, r_Balancedata.操作员编号,
         r_Balancedata.操作员姓名, 退支票额_In, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null, Null, 卡号_In,
         交易流水号_In, 交易说明_In, Null, 3, n_会话号);
    
      Update 病人预交记录 Set 冲预交 = 冲预交 - 退支票额_In Where 结帐id = 结帐id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
        Raise Err_Item;
      End If;
    End If;
  
    --各个收费结算 :格式为:"结算方式|结算金额|结算号码|结算摘要||.."
    v_结算内容 := 结算方式_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
    
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If Nvl(n_结算金额, 0) <> 0 Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号,
           2, Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, v_结算号码, 3, n_会话号);
      
        Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 结帐id_In And 结算方式 Is Null;
        If Sql%NotFound Then
          v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
          Raise Err_Item;
        End If;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If 操作类型_In = 1 Then
    --三方卡结算交易
  
    v_当前结算 := 结算方式_In;
  
    v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
  
    If Nvl(n_结算金额, 0) <> 0 Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
         r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号,
         2, 卡类别id_In, Null, 卡号_In, 交易流水号_In, 交易说明_In, v_结算号码, 3, n_会话号);
    
      Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 结帐id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
        Raise Err_Item;
      End If;
    End If;
  End If;

  --2.医保结算(调用此过程,采取平均分摊的方式分摊结算情况):这种情况医保结处后,必须全退
  If 操作类型_In = 2 Then
    --2.1检查是否已经存在医保结算数据,存在先删除
    n_结算金额 := 0;
    For v_医保 In (Select ID, 结算方式, 冲预交
                 From 病人预交记录 A
                 Where 结帐id = 结帐id_In And Exists
                  (Select 1 From 结算方式 Where a.结算方式 = 名称 And 性质 In (3, 4)) And Mod(记录性质, 10) <> 1)
    
     Loop
      n_结算金额 := n_结算金额 + Nvl(v_医保.冲预交, 0);
      l_预交id.Extend;
      l_预交id(l_预交id.Count) := v_医保.Id;
    End Loop;
    If Nvl(n_结算金额, 0) <> 0 Then
      Update 病人预交记录
      Set 冲预交 = Nvl(冲预交, 0) + Nvl(n_结算金额, 0)
      Where 结帐id = 结帐id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
        Raise Err_Item;
      End If;
    End If;
    If l_预交id.Count <> 0 Then
      Forall I In 1 .. l_预交id.Count
        Delete 病人预交记录 Where ID = l_预交id(I);
    End If;
  
    If 结算方式_In Is Not Null Then
      v_结算内容 := 结算方式_In || '||';
    End If;
  
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      For c_结算信息 In (Select 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号
                     From 病人预交记录
                     Where 结帐id = 结帐id_In And 结算方式 Is Null) Loop
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质, 会话号)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, c_结算信息.病人id, Null, '保险结算', v_结算方式, c_结算信息.收款时间, c_结算信息.操作员编号, c_结算信息.操作员姓名,
           n_结算金额, c_结算信息.结帐id, c_结算信息.缴款组id, c_结算信息.结算序号, 1, 3, n_会话号);
      End Loop;
      --更新数据(结算方式为NULL的)
      Update 病人预交记录
      Set 冲预交 = 冲预交 - n_结算金额
      Where 结帐id = 结帐id_In And 结算方式 Is Null
      Returning Nvl(冲预交, 0) Into n_返回值;
    
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --3-消费卡批量结算
  If 操作类型_In = 3 Then
    v_结算内容 := 结算方式_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      --卡类别ID|卡号|消费卡ID|消费金额
      n_卡类别id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_卡号     := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_消费卡id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(v_当前结算);
      Begin
        Select 名称, 自制卡, 结算方式 Into v_名称, n_自制卡, v_结算方式 From 卡消费接口目录 Where 编号 = 卡类别id_In;
      Exception
        When Others Then
          v_名称 := Null;
      End;
      If v_名称 Is Null Then
        v_Err_Msg := '未找到对应的结算卡接口,本次刷卡消费失败!';
        Raise Err_Item;
      End If;
      If v_结算方式 Is Null Then
        v_Err_Msg := v_名称 || '未设置对应的结算方式,本次刷卡消费失败!';
        Raise Err_Item;
      End If;
      If Nvl(n_消费卡id, 0) = 0 Then
        --未传入消费卡ID时,以卡号为准进行查找(卡号的合法性,在程序中有判断)
        Begin
          Select ID
          Into n_消费卡id
          From 消费卡目录
          Where 接口编号 = n_卡类别id And 卡号 = v_卡号 And
                序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = n_卡类别id And 卡号 = v_卡号);
        Exception
          When Others Then
            n_消费卡id := 0;
        End;
        If Nvl(n_消费卡id, 0) = 0 Then
          v_Err_Msg := '未找到卡号为:' || v_卡号 || '的' || v_名称 || '.,本次刷卡消费失败!';
          Raise Err_Item;
        End If;
      End If;
    
      If Nvl(n_结算金额, 0) <> 0 Then
      
        Update 病人预交记录
        Set 冲预交 = Nvl(冲预交, 0) + n_结算金额
        Where 结帐id = r_Balancedata. 结帐id And 结算方式 = v_结算方式 And 结算卡序号 = n_卡类别id
        Returning ID Into n_预交id;
        If Sql%NotFound Then
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算卡序号, 校对标志, 结算性质,
             会话号)
          Values
            (n_预交id, 3, Null, 1, r_Balancedata. 病人id, Null, Null, v_结算方式, r_Balancedata. 收款时间, r_Balancedata. 操作员编号,
             r_Balancedata. 操作员姓名, n_结算金额, r_Balancedata. 结帐id, r_Balancedata. 缴款组id, r_Balancedata. 结算序号, n_卡类别id, 2, 3,
             n_会话号);
        End If;
      
        --插入卡结算记录
        Begin
          Select Nvl(Max(Nvl(序号, 0)), 0) + 1
          Into n_序号
          From 病人卡结算记录
          Where 接口编号 = n_卡类别id And Nvl(消费卡id, 0) = Nvl(n_消费卡id, 0) And 卡号 = v_卡号;
        Exception
          When Others Then
            n_序号 := 1;
        End;
      
        Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      
        Insert Into 病人卡结算记录
          (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Values
          (n_Id, n_卡类别id, n_消费卡id, n_序号, 1, v_结算方式, n_结算金额, v_卡号, Null, r_Balancedata. 收款时间, Null, 0);
        --如果消费卡,需同时更改其余额
        If Nvl(n_消费卡id, 0) <> 0 Then
          Update 消费卡目录 Set 余额 = 余额 - n_结算金额 Where ID = n_消费卡id;
          If Sql%NotFound Then
            v_Err_Msg := '卡号为' || v_卡号 || '的' || v_名称 || '未找到!';
            Raise Err_Item;
          End If;
        End If;
        Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
      
        --更新数据(结算方式为NULL的)
        Update 病人预交记录
        Set 冲预交 = 冲预交 - n_结算金额
        Where 结帐id = r_Balancedata. 结帐id And 结算方式 Is Null And Nvl(校对标志, 0) = 1
        Returning Nvl(冲预交, 0) Into n_返回值;
      
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If Nvl(完成结算_In, 0) = 0 Then
    Return;
  End If;

  -----------------------------------------------------------------------------------------
  --完成收费,需要处理人员缴款余额,预交记录(结算方式=NULL)

  --1.删除结算方式为NULL的预交记录
  Delete 病人预交记录 Where 结帐id = 结帐id_In And 结算方式 Is Null And Nvl(冲预交, 0) = 0;
  If Sql%NotFound Then
    Select Count(*) Into n_Count From 病人预交记录 A Where 结帐id = 结帐id_In And 结算方式 Is Null;
    If n_Count <> 0 Then
      v_Err_Msg := '还存在未缴款的数据,不能完成结算!';
    Else
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！!';
    End If;
    Raise Err_Item;
  End If;

  --检查门诊费用记录与病人预交记录的金额是否相等
  n_结算金额 := 0;
  n_冲预交   := 0;
  Select Nvl(Sum(实收金额), 0) Into n_结算金额 From 门诊费用记录 Where 结帐id = 结帐id_In;
  Select Nvl(Sum(冲预交), 0) Into n_冲预交 From 病人预交记录 Where 结帐id = 结帐id_In;
  If n_结算金额 <> n_冲预交 Then
    v_Err_Msg := '结算信息有误，实收金额(' || n_结算金额 || ')与结算金额(' || n_冲预交 || ')不一致，不能完成结算！';
    Raise Err_Item;
  End If;

  --结算金额为零时，增加一条金额为0的病人预交记录
  Select Count(*) Into n_Count From 病人预交记录 A Where 结帐id = 结帐id_In;

  If n_Count = 0 Then
    v_结算方式 := 缺省结算方式_In;
    If v_结算方式 Is Null Then
      Begin
        Select 结算方式 Into v_结算方式 From 结算方式应用 Where 应用场合 = '收费' And Nvl(缺省标志, 0) = 1;
      Exception
        When Others Then
          v_结算方式 := Null;
      End;
      If v_结算方式 Is Null Then
        Begin
          Select 名称 Into v_结算方式 From 结算方式 Where Nvl(性质, 0) = 1;
        Exception
          When Others Then
            v_结算方式 := '现金';
        End;
      End If;
    End If;
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
       交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
    Values
      (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, Null, v_结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
       r_Balancedata.操作员姓名, 0, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null, Null, Null, Null,
       交易说明_In, Null, 3, n_会话号);
  End If;

  --2.处理缴款数据和找补数据及校对标志更新为0，会话号更新为NULL
  Update 病人预交记录 Set 缴款 = 缴款_In, 找补 = 找补_In, 校对标志 = 0, 会话号 = Null Where 结帐id = 结帐id_In;

  --3.更新费用状态
  Update 门诊费用记录 Set 费用状态 = 0 Where 结帐id = 结帐id_In;

  --4.更新人员缴款数据
  If Nvl(更新交款余额_In, 1) = 1 Then
    For c_缴款 In (Select 结算方式, 操作员姓名, Sum(Nvl(a.冲预交, 0)) As 冲预交
                 From 病人预交记录 A
                 Where a.结帐id = 结帐id_In And Mod(a.记录性质, 10) <> 1
                 Group By 结算方式, 操作员姓名) Loop
    
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + Nvl(c_缴款.冲预交, 0)
      Where 收款员 = c_缴款.操作员姓名 And 性质 = 1 And 结算方式 = c_缴款.结算方式;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (c_缴款.操作员姓名, c_缴款.结算方式, 1, Nvl(c_缴款.冲预交, 0));
      End If;
    End Loop;
  End IF;
  --收费后产生导引
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 4, 结帐id_In;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费结算_Modify;
/

--92335:李南春,2017-06-22,三方支付新模式及过程拆分
Create Or Replace Procedure Zl_预约挂号接收_出诊_Insert
(
  No_In            门诊费用记录.No%Type,
  票据号_In        门诊费用记录.实际票号%Type,
  领用id_In        票据使用明细.领用id%Type,
  结帐id_In        门诊费用记录.结帐id%Type,
  诊室_In          门诊费用记录.发药窗口%Type,
  病人id_In        门诊费用记录.病人id%Type,
  门诊号_In        门诊费用记录.标识号%Type,
  姓名_In          门诊费用记录.姓名%Type,
  性别_In          门诊费用记录.性别%Type,
  年龄_In          门诊费用记录.年龄%Type,
  付款方式_In      门诊费用记录.付款方式%Type, --用于存放病人的医疗付款方式编号
  费别_In          门诊费用记录.费别%Type,
  结算方式_In      Varchar2, --现金的结算名称
  现金支付_In      病人预交记录.冲预交%Type, --挂号时现金支付部份金额
  预交支付_In      病人预交记录.冲预交%Type, --挂号时使用的预交金额
  个帐支付_In      病人预交记录.冲预交%Type, --挂号时个人帐户支付金额
  发生时间_In      门诊费用记录.发生时间%Type,
  号序_In          挂号序号状态.序号%Type,
  操作员编号_In    门诊费用记录.操作员编号%Type,
  操作员姓名_In    门诊费用记录.操作员姓名%Type,
  生成队列_In      Number := 0,
  登记时间_In      门诊费用记录.登记时间%Type := Null,
  卡类别id_In      病人预交记录.卡类别id%Type := Null,
  结算卡序号_In    病人预交记录.结算卡序号%Type := Null,
  卡号_In          病人预交记录.卡号%Type := Null,
  交易流水号_In    病人预交记录.交易流水号%Type := Null,
  交易说明_In      病人预交记录.交易说明%Type := Null,
  险类_In          病人挂号记录.险类%Type := Null,
  结算模式_In      Number := 0,
  记帐费用_In      Number := 0,
  冲预交病人ids_In Varchar2 := Null,
  三方调用_In      Number := 0,
  更新交款余额_In  Number := 1, --是否更新人员交款余额，主要是处理统一操作员登录多台自助机的情况
  摘要_In          病人挂号记录.摘要%Type := Null
) As
  --该游标用于收费冲预交的可用预交列表
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit
  (
    v_病人id        病人信息.病人id%Type,
    v_冲预交病人ids Varchar2
  ) Is
    Select 病人id, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额, Min(记录状态) As 记录状态, Nvl(Max(结帐id), 0) As 结帐id,
           Max(Decode(记录性质, 1, ID, 0) * Decode(记录状态, 2, 0, 1)) As 原预交id
    From 病人预交记录
    Where 记录性质 In (1, 11) And 病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And Nvl(预交类别, 2) = 1
     Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
    Group By NO, 病人id
    Order By Decode(病人id, Nvl(v_病人id, 0), 0, 1), 结帐id, NO;

  v_Err_Msg Varchar2(255);
  Err_Item    Exception;
  Err_Special Exception;
  v_操作员姓名 病人挂号记录.接收人%Type;
  v_现金       结算方式.名称%Type;
  v_个人帐户   结算方式.名称%Type;
  v_队列名称   排队叫号队列.队列名称%Type;
  v_号别       门诊费用记录.计算单位%Type;
  v_号序       门诊费用记录.发药窗口%Type;
  v_排队号码   排队叫号队列.排队号码 %Type;
  v_预约方式   病人挂号记录.预约方式 %Type;

  n_打印id        票据打印内容.Id%Type;
  n_预交金额      病人预交记录.金额%Type;
  n_返回值        病人预交记录.金额%Type;
  v_冲预交病人ids Varchar2(4000);

  n_挂号id         病人挂号记录.Id%Type;
  n_分诊台签到排队 Number;
  n_组id           财务缴款分组.Id%Type;
  n_Count          Number(18);
  n_排队           Number;
  n_当天排队       Number;
  n_当前金额       病人预交记录.金额%Type;
  n_预交id         病人预交记录.Id%Type;
  n_消费卡id       消费卡目录.Id%Type;
  n_自制卡         Number;

  d_Date         Date;
  d_预约时间     门诊费用记录.发生时间%Type;
  d_发生时间     Date;
  d_排队时间     Date;
  n_时段         Number := 0;
  n_存在         Number := 0;
  v_结算内容     Varchar2(2000);
  v_当前结算     Varchar2(500);
  n_结算金额     病人预交记录.冲预交%Type;
  v_结算号码     病人预交记录.结算号码%Type;
  v_结算方式     病人预交记录.结算方式%Type;
  n_三方卡标志   Number(3);
  v_排队序号     排队叫号队列.排队序号%Type;
  n_结算模式     病人信息.结算模式%Type;
  n_票种         票据使用明细.票种%Type;
  v_付款方式     病人挂号记录.医疗付款方式%Type;
  n_接收模式     Number := 0;
  n_出诊记录id   病人挂号记录.出诊记录id%Type;
  n_新出诊记录id 病人挂号记录.出诊记录id%Type;
  n_号源id       临床出诊记录.号源id%Type;
  n_预约顺序号   临床出诊序号控制.预约顺序号%Type;
  n_旧分时段     临床出诊记录.是否分时段%Type;
  n_旧序号控制   临床出诊记录.是否序号控制%Type;
  n_旧科室id     临床出诊记录.科室id%Type;
  n_旧项目id     临床出诊记录.项目id%Type;
  n_旧医生id     临床出诊记录.医生id%Type;
  n_挂号模式     Number(3);
  d_启用时间     Date;
  v_Paratemp     Varchar2(500);
  v_Registtemp   Varchar2(500);
  n_检查         Number(3);
  n_序号控制     临床出诊记录.是否序号控制%Type;
  v_旧上班时段   临床出诊记录.上班时段%Type;
Begin
  n_组id          := Zl_Get组id(操作员姓名_In);
  v_冲预交病人ids := Nvl(冲预交病人ids_In, 病人id_In);
  v_Paratemp      := Nvl(zl_GetSysParameter('挂号排班模式'), 0);
  n_接收模式      := Nvl(zl_GetSysParameter('预约接收模式', 1111), 0);
  n_挂号模式      := To_Number(Substr(v_Paratemp, 1, 1));
  If n_挂号模式 = 1 Then
    Begin
      d_启用时间 := To_Date(Substr(v_Paratemp, 3), 'yyyy-mm-dd hh24:mi:ss');
    Exception
      When Others Then
        d_启用时间 := Null;
    End;
  End If;

  --获取结算方式名称
  Begin
    Select 名称 Into v_现金 From 结算方式 Where 性质 = 1;
  Exception
    When Others Then
      v_现金 := '现金';
  End;
  Begin
    Select 名称 Into v_个人帐户 From 结算方式 Where 性质 = 3;
  Exception
    When Others Then
      v_个人帐户 := '个人帐户';
  End;
  If 登记时间_In Is Null Then
    Select Sysdate Into d_Date From Dual;
  Else
    d_Date := 登记时间_In;
  End If;

  --更新挂号序号状态
  Begin
    Select 号别, 号序, Trunc(发生时间), 发生时间, 预约方式, 出诊记录id
    Into v_号别, v_号序, d_预约时间, d_发生时间, v_预约方式, n_出诊记录id
    From 病人挂号记录
    Where 记录性质 = 2 And 记录状态 = 1 And Rownum = 1 And NO = No_In;
  Exception
    When Others Then
      Select Max(接收人) Into v_操作员姓名 From 病人挂号记录 Where 记录性质 = 2 And 记录状态 In (1, 3) And NO = No_In;
      If v_操作员姓名 Is Null Then
        v_Err_Msg := '当前预约挂号单已被取消';
        Raise Err_Item;
      Else
        If v_操作员姓名 = 操作员姓名_In Then
          v_Err_Msg := '当前预约挂号单已被接收';
          Raise Err_Special;
        Else
          v_Err_Msg := '当前预约挂号单已被其它人接收';
          Raise Err_Item;
        End If;
      End If;
  End;

  --判断是否分时段
  Select Nvl(是否分时段, 0), 号源id, Nvl(是否序号控制, 0)
  Into n_时段, n_号源id, n_序号控制
  From 临床出诊记录
  Where ID = n_出诊记录id;

  If n_时段 = 1 And 三方调用_In = 0 And n_接收模式 = 0 Then
    If Trunc(发生时间_In) <> Trunc(Sysdate) Then
      v_Err_Msg := '分时段的预约挂号单只能当天接收！';
      Raise Err_Item;
    End If;
  End If;

  If n_时段 = 0 And 三方调用_In = 0 Then
    If n_接收模式 = 0 Then
      If Trunc(发生时间_In) = Trunc(Sysdate) Then
        d_发生时间 := 发生时间_In;
      Else
        d_发生时间 := Sysdate;
      End If;
    Else
      d_发生时间 := 发生时间_In;
    End If;
  Else
    If Not 发生时间_In Is Null Then
      d_发生时间 := 发生时间_In;
    End If;
  End If;

  If d_启用时间 Is Not Null Then
    If d_发生时间 < d_启用时间 Then
      v_Err_Msg := '当前预约挂号单属于出诊表排班模式安排，不能在' || To_Char(d_启用时间, 'yyyy-mm-dd hh24:mi:ss') || '之前接收!';
      Raise Err_Item;
    End If;
  End If;

  If Not v_号序 Is Null Then
    If 号序_In Is Null Then
      Update 临床出诊序号控制 Set 挂号状态 = 0 Where (序号 = v_号序 Or 备注 = v_号序) And 记录id = n_出诊记录id;
    Else
      If Trunc(d_预约时间) <> Trunc(Sysdate) And n_接收模式 = 0 Then
        If n_时段 = 0 And 三方调用_In = 0 Then
          --提前接收或延迟接收
          Update 临床出诊序号控制 Set 挂号状态 = 0 Where 序号 = v_号序 And 记录id = n_出诊记录id;
        
          Select 是否分时段, 是否序号控制, 科室id, 医生id, 项目id, 上班时段
          Into n_旧分时段, n_旧序号控制, n_旧科室id, n_旧医生id, n_旧项目id, v_旧上班时段
          From 临床出诊记录
          Where ID = n_出诊记录id;
          Begin
            Select ID
            Into n_新出诊记录id
            From 临床出诊记录
            Where 号源id = n_号源id And 是否分时段 = n_旧分时段 And 是否序号控制 = n_旧序号控制 And 科室id = n_旧科室id And
                  Nvl(医生id, 0) = Nvl(n_旧医生id, 0) And 上班时段 = v_旧上班时段 And Nvl(是否发布, 0) = 1 And 出诊日期 = Trunc(Sysdate) And
                  Rownum < 2;
          Exception
            When Others Then
              v_Err_Msg := '接收当天没有对应的出诊安排,无法接收!';
              Raise Err_Item;
          End;
        
          Begin
            Select 1
            Into n_存在
            From 临床出诊序号控制
            Where 记录id = n_新出诊记录id And 序号 = v_号序 And Nvl(挂号状态, 0) = 0;
          Exception
            When Others Then
              n_存在 := 0;
          End;
        
          If n_存在 = 1 Then
            Update 临床出诊序号控制
            Set 挂号状态 = 1, 操作员姓名 = 操作员姓名_In
            Where 记录id = n_新出诊记录id And 序号 = v_号序 And Nvl(挂号状态, 0) = 0;
          Else
            --号码已被使用的情况
            Select Min(序号) Into v_号序 From 临床出诊序号控制 Where 记录id = n_新出诊记录id And Nvl(挂号状态, 0) = 0;
            If v_号序 Is Null Then
              v_Err_Msg := '接收当天没有可用序号,无法接收!';
              Raise Err_Item;
            End If;
            Update 临床出诊序号控制
            Set 挂号状态 = 1, 操作员姓名 = 操作员姓名_In
            Where 记录id = n_新出诊记录id And 序号 = v_号序 And Nvl(挂号状态, 0) = 0;
          End If;
        Else
          Select 是否分时段, 是否序号控制, 科室id, 医生id, 项目id, 上班时段
          Into n_旧分时段, n_旧序号控制, n_旧科室id, n_旧医生id, n_旧项目id, v_旧上班时段
          From 临床出诊记录
          Where ID = n_出诊记录id;
          Begin
            Select ID
            Into n_新出诊记录id
            From 临床出诊记录
            Where 号源id = n_号源id And 是否分时段 = n_旧分时段 And 是否序号控制 = n_旧序号控制 And 科室id = n_旧科室id And
                  Nvl(医生id, 0) = Nvl(n_旧医生id, 0) And 上班时段 = v_旧上班时段 And Nvl(是否发布, 0) = 1 And 出诊日期 = Trunc(Sysdate) And
                  Rownum < 2;
          Exception
            When Others Then
              v_Err_Msg := '接收当天没有对应的出诊安排,无法接收!';
              Raise Err_Item;
          End;
          Update 临床出诊序号控制
          Set 挂号状态 = 0, 操作员姓名 = 操作员姓名_In
          Where (序号 = v_号序 Or 备注 = v_号序) And 记录id = n_出诊记录id And Nvl(挂号状态, 0) = 2
          Returning 预约顺序号 Into n_预约顺序号;
        
          Update 临床出诊序号控制
          Set 挂号状态 = 1, 操作员姓名 = 操作员姓名_In, 预约顺序号 = n_预约顺序号
          Where 序号 = v_号序 And 记录id = n_新出诊记录id And Nvl(挂号状态, 0) = 0;
          If Sql% RowCount = 0 Then
            v_Err_Msg := '接收当天序号' || v_号序 || '已被其它人使用,无法接收.';
            Raise Err_Item;
          End If;
        End If;
      Else
        Update 临床出诊序号控制
        Set 挂号状态 = 1, 操作员姓名 = 操作员姓名_In
        Where (序号 = v_号序 Or 备注 = v_号序) And 记录id = n_出诊记录id;
        If Sql%RowCount = 0 Then
          v_Err_Msg := '序号' || v_号序 || '已被其它人使用,请重新选择一个序号.';
          Raise Err_Item;
        End If;
      End If;
    End If;
  Else
    If Not 号序_In Is Null Then
      If Trunc(d_预约时间) <> Trunc(Sysdate) And n_接收模式 = 0 Then
        Select 是否分时段, 是否序号控制, 科室id, 医生id, 项目id, 上班时段
        Into n_旧分时段, n_旧序号控制, n_旧科室id, n_旧医生id, n_旧项目id, v_旧上班时段
        From 临床出诊记录
        Where ID = n_出诊记录id;
        Begin
          Select ID
          Into n_新出诊记录id
          From 临床出诊记录
          Where 号源id = n_号源id And 是否分时段 = n_旧分时段 And 是否序号控制 = n_旧序号控制 And 科室id = n_旧科室id And
                Nvl(医生id, 0) = Nvl(n_旧医生id, 0) And 上班时段 = v_旧上班时段 And Nvl(是否发布, 0) = 1 And 出诊日期 = Trunc(Sysdate) And
                Rownum < 2;
        Exception
          When Others Then
            v_Err_Msg := '接收当天没有对应的出诊安排,无法接收!';
            Raise Err_Item;
        End;
        Update 临床出诊序号控制
        Set 挂号状态 = 0, 操作员姓名 = 操作员姓名_In
        Where (序号 = 号序_In Or 备注 = 号序_In) And 记录id = n_出诊记录id And Nvl(挂号状态, 0) = 2
        Returning 预约顺序号 Into n_预约顺序号;
        Update 临床出诊序号控制
        Set 挂号状态 = 1, 操作员姓名 = 操作员姓名_In, 预约顺序号 = n_预约顺序号
        Where 序号 = 号序_In And 记录id = n_新出诊记录id And Nvl(挂号状态, 0) = 0;
        If Sql%RowCount = 0 Then
          v_Err_Msg := '接收当天序号' || 号序_In || '已被其它人使用,无法接收.';
          Raise Err_Item;
        End If;
      Else
        Update 临床出诊序号控制
        Set 挂号状态 = 1, 操作员姓名 = 操作员姓名_In
        Where (序号 = 号序_In Or 备注 = 号序_In) And 记录id = n_出诊记录id;
      
      End If;
      v_号序 := 号序_In;
    Else
      v_号序 := Null;
    End If;
  End If;

  --更新门诊费用记录
  Update 门诊费用记录
  Set 记录状态 = 1, 实际票号 = Decode(Nvl(记帐费用_In, 0), 1, Null, 票据号_In), 结帐id = Decode(Nvl(记帐费用_In, 0), 1, Null, 结帐id_In),
      结帐金额 = Decode(Nvl(记帐费用_In, 0), 1, Null, 实收金额), 发药窗口 = 诊室_In, 病人id = 病人id_In, 标识号 = 门诊号_In, 姓名 = 姓名_In, 年龄 = 年龄_In,
      性别 = 性别_In, 付款方式 = 付款方式_In, 费别 = 费别_In, 发生时间 = d_发生时间, 登记时间 = d_Date, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In,
      缴款组id = n_组id, 记帐费用 = Decode(Nvl(记帐费用_In, 0), 1, 1, 0), 摘要 = Nvl(摘要_In, 摘要)
  Where 记录性质 = 4 And 记录状态 = 0 And NO = No_In;

  v_Registtemp := zl_GetSysParameter('挂号排班模式');
  If Substr(v_Registtemp, 1, 1) = 1 Then
    Begin
      If To_Date(Substr(v_Registtemp, 3), 'yyyy-mm-dd hh24:mi:ss') > d_发生时间 Then
        v_Err_Msg := '接收时间' || To_Char(d_发生时间, 'yyyy-mm-dd hh24:mi:ss') || '未启用出诊表排班模式,目前无法接收!';
        Raise Err_Item;
      End If;
    Exception
      When Others Then
        Null;
    End;
    Begin
      Select 1
      Into n_检查
      From 临床出诊记录
      Where ID = Nvl(n_新出诊记录id, n_出诊记录id) And d_发生时间 Between 停诊开始时间 And 停诊终止时间;
    Exception
      When Others Then
        n_检查 := 0;
    End;
    If n_检查 = 1 And Not (n_时段 = 1 And n_序号控制 = 1) Then
      v_Err_Msg := '接收时间' || To_Char(d_发生时间, 'yyyy-mm-dd hh24:mi:ss') || '的安排已经被停诊,无法接收!';
      Raise Err_Item;
    End If;
  End If;

  --病人挂号记录
  Update 病人挂号记录
  Set 接收人 = 操作员姓名_In, 接收时间 = d_Date, 记录性质 = 1, 病人id = 病人id_In, 门诊号 = 门诊号_In, 发生时间 = d_发生时间, 姓名 = 姓名_In, 性别 = 性别_In,
      年龄 = 年龄_In, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In, 险类 = Decode(Nvl(险类_In, 0), 0, Null, 险类_In), 号序 = v_号序, 诊室 = 诊室_In,
      出诊记录id = Nvl(n_新出诊记录id, n_出诊记录id), 摘要 = Nvl(摘要_In, 摘要)
  Where 记录状态 = 1 And NO = No_In And 记录性质 = 2
  Returning ID Into n_挂号id;
  If Sql%NotFound Then
    Begin
      Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
      Begin
        Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In And Rownum < 2;
      Exception
        When Others Then
          v_付款方式 := Null;
      End;
      Insert Into 病人挂号记录
        (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 操作员编号, 操作员姓名,
         摘要, 号序, 预约, 预约方式, 接收人, 接收时间, 预约时间, 险类, 医疗付款方式, 出诊记录id)
        Select n_挂号id, No_In, 1, 1, 病人id_In, 门诊号_In, 姓名_In, 性别_In, 年龄_In, 计算单位, 加班标志, 诊室_In, Null, 执行部门id, 执行人, 0, Null,
               登记时间, 发生时间, 操作员编号, 操作员姓名, Nvl(摘要_In, 摘要), v_号序, 1, Substr(结论, 1, 10) As 预约方式, 操作员姓名_In,
               Nvl(登记时间_In, Sysdate), 发生时间, Decode(Nvl(险类_In, 0), 0, Null, 险类_In), v_付款方式, Nvl(n_新出诊记录id, n_出诊记录id)
        From 门诊费用记录
        Where 记录性质 = 4 And 记录状态 = 1 And Rownum = 1 And NO = No_In;
    Exception
      When Others Then
        v_Err_Msg := '由于并发原因,单据号为【' || No_In || '】的病人' || 姓名_In || '已经被接收';
        Raise Err_Item;
    End;
  End If;

  --0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站
  If Nvl(生成队列_In, 0) <> 0 Then
    n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
    If Nvl(n_分诊台签到排队, 0) = 0 Then
      For v_挂号 In (Select ID, 姓名, 诊室, 执行人, 执行部门id, 发生时间, 号别, 号序 From 病人挂号记录 Where NO = No_In) Loop
      
        Begin
          Select 1,
                 Case
                   When 排队时间 < Trunc(Sysdate) Then
                    1
                   Else
                    0
                 End
          Into n_排队, n_当天排队
          From 排队叫号队列
          Where 业务类型 = 0 And 业务id = v_挂号.Id And Rownum <= 1;
        Exception
          When Others Then
            n_排队 := 0;
        End;
        If n_排队 = 0 Then
          --产生队列
          --按”执行部门”产生队列
          n_挂号id   := v_挂号.Id;
          v_队列名称 := v_挂号.执行部门id;
          v_排队号码 := Zlgetnextqueue(v_挂号.执行部门id, n_挂号id, v_挂号.号别 || '|' || v_挂号.号序);
          v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
        
          --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)
          d_排队时间 := Zl_Get_Queuedate(n_挂号id, v_挂号.号别, v_挂号.号序, v_挂号.发生时间);
          --   队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,排队标记_In,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In,
          Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, v_挂号.执行部门id, v_排队号码, Null, 姓名_In, 病人id_In, v_挂号.诊室, v_挂号.执行人, d_排队时间,
                           v_预约方式, Null, v_排队序号);
        Elsif Nvl(n_当天排队, 0) = 1 Then
          --更新队列号
          v_排队号码 := Zlgetnextqueue(v_挂号.执行部门id, v_挂号.Id, v_挂号.号别 || '|' || Nvl(v_挂号.号序, 0));
          v_排队序号 := Zlgetsequencenum(0, v_挂号.Id, 1);
          --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In, 医生姓名_In ,排队号码_In
          Zl_排队叫号队列_Update(v_挂号.执行部门id, 0, v_挂号.Id, v_挂号.执行部门id, v_挂号.姓名, v_挂号.诊室, v_挂号.执行人, v_排队号码, v_排队序号);
        
        Else
          --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In, 医生姓名_In ,排队号码_In
          Zl_排队叫号队列_Update(v_挂号.执行部门id, 0, v_挂号.Id, v_挂号.执行部门id, v_挂号.姓名, v_挂号.诊室, v_挂号.执行人);
        End If;
      End Loop;
    End If;
  End If;

  --汇总结算到病人预交记录
  If Nvl(记帐费用_In, 0) = 0 Then
    If Nvl(现金支付_In, 0) = 0 And Nvl(个帐支付_In, 0) = 0 And Nvl(预交支付_In, 0) = 0 Then
      Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      Insert Into 病人预交记录
        (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
         结算性质)
      Values
        (n_预交id, 4, 1, No_In, Decode(病人id_In, 0, Null, 病人id_In), v_现金, 0, 登记时间_In, 操作员编号_In, 操作员姓名_In, 结帐id_In, '挂号收费',
         n_组id, 卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, Null, 4);
    End If;
    If Nvl(现金支付_In, 0) <> 0 Then
      v_结算内容 := 结算方式_In || '|'; --以空格分开以|结尾,没有结算号码的
      While v_结算内容 Is Not Null Loop
        v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '|') - 1);
        v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1);
      
        v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
        n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1));
      
        v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
        v_结算号码 := Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1);
      
        v_当前结算   := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
        n_三方卡标志 := To_Number(v_当前结算);
      
        If n_三方卡标志 = 0 Then
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          Insert Into 病人预交记录
            (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
             合作单位, 结算性质, 结算号码)
          Values
            (n_预交id, 4, 1, No_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(v_结算方式, v_现金), Nvl(n_结算金额, 0), 登记时间_In,
             操作员编号_In, 操作员姓名_In, 结帐id_In, '挂号收费', n_组id, Null, Null, Null, Null, Null, Null, 4, v_结算号码);
        Else
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          Insert Into 病人预交记录
            (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
             合作单位, 结算性质, 结算号码)
          Values
            (n_预交id, 4, 1, No_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(v_结算方式, v_现金), Nvl(n_结算金额, 0), 登记时间_In,
             操作员编号_In, 操作员姓名_In, 结帐id_In, '挂号收费', n_组id, 卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, Null, 4, v_结算号码);
          If Nvl(结算卡序号_In, 0) <> 0 Then
            n_消费卡id := Null;
            Begin
              Select Nvl(自制卡, 0), 1 Into n_自制卡, n_Count From 卡消费接口目录 Where 编号 = 结算卡序号_In;
            Exception
              When Others Then
                n_Count := 0;
            End;
            If n_Count = 0 Then
              v_Err_Msg := '没有发现原结算卡的相应类别,不能继续操作！';
              Raise Err_Item;
            End If;
            If n_自制卡 = 1 Then
              Select ID
              Into n_消费卡id
              From 消费卡目录
              Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In And
                    序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In);
            End If;
            Zl_病人卡结算记录_Insert(结算卡序号_In, n_消费卡id, v_结算方式, n_结算金额, 卡号_In, Null, 登记时间_In, Null, 结帐id_In, n_预交id);
          End If;
        End If;
      
        If Nvl(更新交款余额_In, 1) = 1 Then
          Update 人员缴款余额
          Set 余额 = Nvl(余额, 0) + n_结算金额
          Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = Nvl(v_结算方式, v_现金)
          Returning 余额 Into n_返回值;
        
          If Sql%RowCount = 0 Then
            Insert Into 人员缴款余额
              (收款员, 结算方式, 性质, 余额)
            Values
              (操作员姓名_In, Nvl(v_结算方式, v_现金), 1, n_结算金额);
            n_返回值 := n_结算金额;
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 人员缴款余额
            Where 收款员 = 操作员姓名_In And 结算方式 = Nvl(v_结算方式, v_现金) And 性质 = 1 And Nvl(余额, 0) = 0;
          End If;
        End If;
      
        v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '|') + 1);
      End Loop;
    End If;
  End If;

  --对于就诊卡通过预交金挂号
  If Nvl(预交支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 Then
    n_预交金额 := 预交支付_In;
    For r_Deposit In c_Deposit(病人id_In, v_冲预交病人ids) Loop
      n_当前金额 := Case
                  When r_Deposit.金额 - n_预交金额 < 0 Then
                   r_Deposit.金额
                  Else
                   n_预交金额
                End;
      If r_Deposit.结帐id = 0 Then
        --第一次冲预交(填上结帐ID,金额为0)
        Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 4 Where ID = r_Deposit.原预交id;
      End If;
      --冲上次剩余额
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结算序号, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 登记时间_In,
               操作员姓名_In, 操作员编号_In, n_当前金额, 结帐id_In, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结帐id_In, 4
        From 病人预交记录
        Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
    
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - n_当前金额
      Where 病人id = r_Deposit.病人id And 性质 = 1 And 类型 = Nvl(1, 2)
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (r_Deposit.病人id, Nvl(1, 2), -1 * n_当前金额, 1);
        n_返回值 := -1 * n_当前金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Deposit.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --检查是否已经处理完
      If r_Deposit.金额 < n_预交金额 Then
        n_预交金额 := n_预交金额 - r_Deposit.金额;
      Else
        n_预交金额 := 0;
      End If;
    
      If n_预交金额 = 0 Then
        Exit;
      End If;
    End Loop;
  End If;

  --对于医保挂号
  If Nvl(个帐支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 Then
    Insert Into 病人预交记录
      (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
       预交类别, 结算序号, 结算性质)
    Values
      (病人预交记录_Id.Nextval, 4, 1, No_In, 病人id_In, v_个人帐户, 个帐支付_In, d_Date, 操作员编号_In, 操作员姓名_In, 结帐id_In, '医保挂号', n_组id,
       Null, Null, Null, Null, Null, Null, Null, 结帐id_In, 4);
  End If;

  --相关汇总表的处理
  --人员缴款余额
  If Nvl(个帐支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 And Nvl(更新交款余额_In, 1) = 1 Then
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + 个帐支付_In
    Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = v_个人帐户
    Returning 余额 Into n_返回值;
  
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, v_个人帐户, 1, 个帐支付_In);
      n_返回值 := 个帐支付_In;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 人员缴款余额 Where 收款员 = 操作员姓名_In And 性质 = 1 And Nvl(余额, 0) = 0;
    End If;
  End If;

  --处理票据使用情况
  If 票据号_In Is Not Null And Nvl(记帐费用_In, 0) = 0 Then
    Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
  
    --当前票据的票种
    Select 票种 Into n_票种 From 票据领用记录 Where ID = Nvl(领用id_In, 0);
    --发出票据
    Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 4, No_In);
  
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
    Values
      (票据使用明细_Id.Nextval, n_票种, 票据号_In, 1, 1, 领用id_In, n_打印id, d_Date, 操作员姓名_In);
  
    --状态改动
    Update 票据领用记录
    Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = d_Date
    Where ID = Nvl(领用id_In, 0);
  End If;

  If Nvl(记帐费用_In, 0) = 1 Then
    --记帐
    If Nvl(病人id_In, 0) = 0 Then
      v_Err_Msg := '要针对病人的挂号费进行记帐，必须是建档病人才能记帐挂号。';
      Raise Err_Item;
    End If;
    For c_费用 In (Select 实收金额, 病人科室id, 开单部门id, 执行部门id, 收入项目id
                 From 门诊费用记录
                 Where 记录性质 = 4 And 记录状态 = 1 And NO = No_In And Nvl(记帐费用, 0) = 1) Loop
      --病人余额
      Update 病人余额
      Set 费用余额 = Nvl(费用余额, 0) + Nvl(c_费用.实收金额, 0)
      Where 病人id = Nvl(病人id_In, 0) And 性质 = 1 And 类型 = 1;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 费用余额, 预交余额)
        Values
          (病人id_In, 1, 1, Nvl(c_费用.实收金额, 0), 0);
      End If;
    
      --病人未结费用
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) + Nvl(c_费用.实收金额, 0)
      Where 病人id = 病人id_In And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(c_费用.病人科室id, 0) And
            Nvl(开单部门id, 0) = Nvl(c_费用.开单部门id, 0) And Nvl(执行部门id, 0) = Nvl(c_费用.执行部门id, 0) And 收入项目id + 0 = c_费用.收入项目id And
            来源途径 + 0 = 1;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人未结费用
          (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
        Values
          (病人id_In, Null, Null, c_费用.病人科室id, c_费用.开单部门id, c_费用.执行部门id, c_费用.收入项目id, 1, Nvl(c_费用.实收金额, 0));
      End If;
    End Loop;
  End If;
  If Nvl(病人id_In, 0) <> 0 Then
    n_结算模式 := 0;
    Update 病人信息
    Set 就诊时间 = d_发生时间, 就诊状态 = 1, 就诊诊室 = 诊室_In
    Where 病人id = 病人id_In
    Returning Nvl(结算模式, 0) Into n_结算模式;
    --取参数:
    If Nvl(n_结算模式, 0) <> Nvl(结算模式_In, 0) Then
      --结算模式的确定
      If n_结算模式 = 1 And Nvl(结算模式_In, 0) = 0 Then
        --病人已经是"先诊疗后结算的",本次是"先结算后诊疗的",则检查是否存在未结数据
        Select Count(1)
        Into n_Count
        From 病人未结费用
        Where 病人id = 病人id_In And (来源途径 In (1, 4) Or 来源途径 = 3 And Nvl(主页id, 0) = 0) And Nvl(金额, 0) <> 0 And Rownum < 2;
        If Nvl(n_Count, 0) <> 0 Then
          --存在未结算数据，必须先结算后才允许执行
          v_Err_Msg := '当前病人的就诊模式为先诊疗后结算且存在未结费用，不允许调整该病人的就诊模式,你可以先对未结费用结帐后再挂号或不调整病人的就诊模式!';
          Raise Err_Item;
        End If;
        --检查
        --未发生医嘱业务的（即当时就挂号的,需要保证同一次的就诊模式是一至的(程序已经检查，不用再处理)
      End If;
      Update 病人信息 Set 结算模式 = 结算模式_In Where 病人id = 病人id_In;
    End If;
  End If;

  --病人担保信息
  If 病人id_In Is Not Null Then
    Update 病人信息
    Set 担保人 = Null, 担保额 = Null, 担保性质 = Null
    Where 病人id = 病人id_In And Nvl(在院, 0) = 0 And Exists
     (Select 1
           From 病人担保记录
           Where 病人id = 病人id_In And 主页id Is Not Null And
                 登记时间 = (Select Max(登记时间) From 病人担保记录 Where 病人id = 病人id_In));
    If Sql%RowCount > 0 Then
      Update 病人担保记录
      Set 到期时间 = d_Date
      Where 病人id = 病人id_In And 主页id Is Not Null And Nvl(到期时间, d_Date) >= d_Date;
    End If;
  End If;
  --消息推送
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 1, n_挂号id;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Err_Special Then
    Raise_Application_Error(-20105, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_预约挂号接收_出诊_Insert;
/

--108646:谢荣,2017-06-22,人员管理修改医生姓名后，修改门诊挂号管理和临床出诊的医生信息。
Create Or Replace Procedure Zl_人员表_更新挂号安排
(
  人员id_In   人员表.Id%Type,
  操作方式_In Integer,
  撤档时间_In 人员表.撤档时间%Type := Null
) As
  --功能：调整号源、有效的安排、有效的出诊记录中的医生姓名。
  --入参：操作方式_IN:1-修改姓名,2-停用人员,3-启用人员
  --      撤档时间_In:停用和启用时传入，启用时传入原撤档时间
  --说明：该过程供人员姓名调整或人员停用/启用时调用，同步调整挂号安排
  v_Para     Varchar2(200);
  n_挂号模式 Number(2);

  Err_Item Exception;
  v_Err_Msg Varchar2(255);

  v_人员姓名 人员表.姓名%Type;
  d_开始时间 临床出诊记录.开始时间%Type;
Begin
  Begin
    Select a.姓名
    Into v_人员姓名
    From 人员表 A, 人员性质说明 B
    Where a.Id = 人员id_In And a.Id = b.人员id And b.人员性质 = '医生';
  Exception
    When Others Then
      --无需处理,退出
      Return;
  End;

  v_Para     := zl_GetSysParameter(256);
  n_挂号模式 := Substr(v_Para, 1, 1);

  If n_挂号模式 = 1 Then
    --出诊表模式
    If 操作方式_In = 1 Then
      --修改
      Update 临床出诊号源 Set 医生姓名 = v_人员姓名 Where 医生id = 人员id_In;
      Update 临床出诊安排 Set 医生姓名 = v_人员姓名 Where 医生id = 人员id_In And 终止时间 > Sysdate;
      Update 临床出诊记录 Set 医生姓名 = v_人员姓名 Where 医生id = 人员id_In And 出诊日期 >= Trunc(Sysdate);
      Update 临床出诊记录 Set 替诊医生姓名 = v_人员姓名 Where 替诊医生id = 人员id_In And 出诊日期 >= Trunc(Sysdate);
    Elsif 操作方式_In = 2 Then
      --停用
      Update 临床出诊号源
      Set 撤档时间 = 撤档时间_In
      Where 医生id = 人员id_In And (撤档时间 Is Null Or 撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd'));
    
      --将当前时间以后的所有出诊记录停诊
      For c_记录 In (Select ID, 开始时间, 终止时间
                   From 临床出诊记录
                   Where 医生id = 人员id_In And 出诊日期 >= Trunc(撤档时间_In) - 1 And 终止时间 > 撤档时间_In And 上班时段 Is Not Null) Loop
      
        If c_记录.开始时间 < 撤档时间_In Then
          d_开始时间 := 撤档时间_In;
        Else
          d_开始时间 := c_记录.开始时间;
        End If;
        Zl_临床出诊记录_Stopvisit(c_记录.Id, d_开始时间, c_记录.终止时间, '人员停用', Zl_Username, 撤档时间_In, 0, 1);
      End Loop;
    Elsif 操作方式_In = 3 Then
      --启用
      For c_记录 In (Select a.Id
                   From 临床出诊记录 A, 临床出诊号源 B
                   Where a.号源id = b.Id And b.撤档时间 = 撤档时间_In And b.医生id = 人员id_In And a.出诊日期 >= Trunc(Sysdate) - 1 And
                         a.终止时间 > Sysdate And a.上班时段 Is Not Null) Loop
      
        Zl_临床出诊记录_Stopvisit(c_记录.Id, Null, Null, Null, Zl_Username, Sysdate, 1, 1);
      End Loop;
    
      Update 临床出诊号源
      Set 撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')
      Where 医生id = 人员id_In And 撤档时间 = 撤档时间_In;
    
      --生成出诊记录
      Zl1_Auto_Buildingregisterplan;
    End If;
  Else
    --挂号排班模式
    If 操作方式_In = 1 Then
      --修改
      Update 挂号安排 Set 医生姓名 = v_人员姓名 Where 医生id = 人员id_In And (终止时间 Is Null Or 终止时间 > Sysdate);
      Update 挂号安排计划
      Set 医生姓名 = v_人员姓名
      Where 医生id = 人员id_In And (失效时间 Is Null Or 失效时间 > Sysdate);
    Elsif 操作方式_In = 2 Then
      --停用
      Update 挂号安排 Set 停用日期 = 撤档时间_In Where 医生id = 人员id_In And (终止时间 Is Null Or 终止时间 > Sysdate);
      Update 挂号安排计划
      Set 失效时间 = 撤档时间_In
      Where 医生id = 人员id_In And (失效时间 Is Null Or 失效时间 > Sysdate);
    Elsif 操作方式_In = 3 Then
      --启用，不处理
      Null;
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_人员表_更新挂号安排;
/

--111447:蔡青松,2017-07-11,添加参数控制是否自动发料退料
--109396:蔡青松,2017-06-23,完成审核时自动发料
Create Or Replace Procedure Zl_检验预置条码_采集完成
(
  医嘱内容_In Varchar2, --内容包括多个医嘱ID使用","分隔 
  人员编号_In 人员表.编号%Type := Null,
  人员姓名_In 人员表.姓名%Type := Null, --Null=取消，不为空时完成采集
  操作_In     Number := 0 --0=完成采集，1=取消采集
) Is
  n_自动发料 Number;
  --查找当前标本的相关申请 
  Cursor c_Samplequest(v_医嘱id In Varchar2) Is
    Select /*+ rule */
    Distinct ID As 医嘱id, 病人来源
    From 病人医嘱记录 A, 病人医嘱发送 B
    Where a.Id = b.医嘱id And b.接收人 Is Null And 相关id Is Null And
          a.Id In (Select * From Table(Cast(f_Num2list(v_医嘱id) As Zltools.t_Numlist)));

  --未审核的费用行(不包含药品) 
  Cursor c_Verify(v_医嘱id In Varchar2) Is
    Select /*+ rule */
    Distinct 记录性质, NO, 序号, 记录状态, 门诊标志
    From 住院费用记录
    Where 收费类别 Not In ('5', '6', '7') And
          医嘱序号 + 0 In
          (Select ID
           From 病人医嘱记录
           Where ID In (Select * From Table(Cast(f_Num2list(v_医嘱id) As Zltools.t_Numlist))) And 相关id Is Null) And
          记帐费用 = 1 And 记录状态 = 0 And 价格父号 Is Null And
          (记录性质, NO) In (Select 记录性质, NO
                         From 病人医嘱附费
                         Where 医嘱id In (Select * From Table(Cast(f_Num2list(v_医嘱id) As Zltools.t_Numlist)))
                         Union All
                         Select 记录性质, NO
                         From 病人医嘱发送
                         Where 医嘱id In (Select ID
                                        From 病人医嘱记录
                                        Where ID In (Select * From Table(Cast(f_Num2list(v_医嘱id) As Zltools.t_Numlist))) And
                                              相关id Is Null) And 接收人 Is Null)
    Union All
    Select /*+ rule */
    Distinct 记录性质, NO, 序号, 记录状态, 门诊标志
    From 门诊费用记录
    Where 收费类别 Not In ('5', '6', '7') And
          医嘱序号 + 0 In
          (Select ID
           From 病人医嘱记录
           Where ID In (Select * From Table(Cast(f_Num2list(v_医嘱id) As Zltools.t_Numlist))) And 相关id Is Null) And
          记帐费用 = 1 And 记录状态 = 0 And 价格父号 Is Null And
          (记录性质, NO) In (Select 记录性质, NO
                         From 病人医嘱附费
                         Where 医嘱id In (Select * From Table(Cast(f_Num2list(v_医嘱id) As Zltools.t_Numlist)))
                         Union All
                         Select 记录性质, NO
                         From 病人医嘱发送
                         Where 医嘱id In (Select ID
                                        From 病人医嘱记录
                                        Where ID In (Select * From Table(Cast(f_Num2list(v_医嘱id) As Zltools.t_Numlist))) And
                                              相关id Is Null) And 接收人 Is Null)
    Order By 记录性质, NO, 序号;

  v_检验标本记录 Number(18);
  v_执行状态     Number(1);
  v_接收人       Varchar2(50);
  v_Error        Varchar2(100);
  v_No           病人医嘱发送.No%Type;
  v_性质         病人医嘱发送.记录性质%Type;
  v_序号         Varchar2(1000);

  v_收发ids Varchar2(4000);
  n_库房id  Number;
  n_发料号  Number;

  Err_Custom Exception;
  n_Par Number;
Begin
  Select zl_GetSysParameter('自动发料退料', 1211) Into n_自动发料 From Dual;
  If 人员姓名_In Is Not Null And 操作_In = 0 Then
    --检查标本是否被核收或接收 
    Begin
      Select /*+ rule */
       Nvl(c.Id, 0), b.执行状态, b.接收人
      Into v_检验标本记录, v_执行状态, v_接收人
      From 病人医嘱记录 A, 病人医嘱发送 B, 检验标本记录 C
      Where a.Id = b.医嘱id And a.相关id = c.医嘱id(+) And
            a.Id In (Select * From Table(Cast(f_Num2list(医嘱内容_In) As Zltools.t_Numlist)));
    Exception
      When Others Then
        v_检验标本记录 := 0;
    End;
  
    If v_检验标本记录 <> 0 Then
      v_Error := '标本已被检验科核收不能完成采集!';
      Raise Err_Custom;
    End If;
  
    If v_执行状态 <> 2 And v_接收人 Is Not Null Then
      v_Error := '标本已被检验科签收不能完成采集!';
      Raise Err_Custom;
    End If;
  
    --检查医嘱是否收费
    n_Par := Zl_To_Number(Nvl(zl_GetSysParameter(163), '0'));
    If n_Par = 1 Then
      For r_Verify In c_Verify(医嘱内容_In) Loop
        If r_Verify.记录状态 = 0 Then
          If r_Verify.门诊标志 = 1 Then
            v_Error := '标本未收费，不允许执行，请联系管理员！';
            Raise Err_Custom;
          Elsif r_Verify.门诊标志 = 2 Then
            v_Error := '标本未记账，不允许执行，请联系管理员！';
            Raise Err_Custom;
          End If;
        End If;
      End Loop;
    End If;
  
    Update /*+ rule */ 检验拒收记录
    Set 重采人 = 人员姓名_In, 重采时间 = Sysdate
    Where 医嘱id In (Select * From Table(Cast(f_Num2list(医嘱内容_In) As Zltools.t_Numlist)));
  
    --更新采集信息(检验和采集） 
    Update /*+ rule */ 病人医嘱发送
    Set 采样人 = 人员姓名_In, 采样时间 = Sysdate, 执行状态 = Decode(执行状态, 2, 0, 执行状态),
        重采标本 = Decode(Nvl(重采标本, 0), 0, Decode(执行状态, 2, 1, 0), 重采标本), 执行说明 = Null
    Where 医嘱id In (Select * From Table(Cast(f_Num2list(医嘱内容_In) As Zltools.t_Numlist)));
  
    --更新医嘱和费用记录 
    For r_Samplequest In c_Samplequest(医嘱内容_In) Loop
      If r_Samplequest.病人来源 = 2 Then
        --2.费用执行处理 
        Update 住院费用记录
        Set 执行状态 = 1, 执行时间 = Sysdate, 执行人 = 人员姓名_In
        Where 收费类别 Not In ('5', '6', '7') And
              (医嘱序号, 记录性质, NO) In (Select 医嘱id, 记录性质, NO
                                   From 病人医嘱附费
                                   Where 医嘱id = r_Samplequest.医嘱id
                                   Union All
                                   Select 医嘱id, 记录性质, NO
                                   From 病人医嘱发送
                                   Where 医嘱id In (Select ID
                                                  From 病人医嘱记录 A, 病人医嘱发送 B
                                                  Where a.Id = b.医嘱id And r_Samplequest.医嘱id In (a.Id) And a.相关id Is Null And
                                                        b.执行状态 In (0, 2) And b.接收人 Is Null));
      Else
        --发料
        If n_自动发料 = 1 Then
          For c_Stuff In (Select a.记录性质, a.记录状态, b.Id, b.库房id
                          From 门诊费用记录 A, 药品收发记录 B
                          Where a.Id = b.费用id And a.收费类别 = '4' And b.审核人 Is Null And
                                (a.医嘱序号, a.记录性质, a.No) In
                                (Select 医嘱id, 记录性质, NO
                                 From 病人医嘱附费
                                 Where 医嘱id = r_Samplequest.医嘱id
                                 Union All
                                 Select 医嘱id, 记录性质, NO
                                 From 病人医嘱发送
                                 Where 医嘱id In (Select ID
                                                From 病人医嘱记录 A, 病人医嘱发送 B
                                                Where a.Id = b.医嘱id And r_Samplequest.医嘱id In (a.Id) And a.相关id Is Null And
                                                      b.执行状态 In (0, 2) And b.接收人 Is Null))) Loop
            If Mod(Nvl(c_Stuff.记录性质, 0), 10) = 1 And Nvl(c_Stuff.记录状态, 0) = 1 Then
              If n_发料号 Is Null Then
                n_发料号 := Nextno(20);
              End If;
            
              If c_Stuff.库房id <> Nvl(n_库房id, 0) Then
                If Nvl(n_库房id, 0) <> 0 And v_收发ids Is Not Null Then
                  v_收发ids := Substr(v_收发ids, 2);
                  Zl_药品收发记录_批量发料(v_收发ids, n_库房id, 人员姓名_In, Sysdate, 1, 人员姓名_In, n_发料号, 人员姓名_In);
                End If;
              
                n_库房id  := c_Stuff.库房id;
                v_收发ids := Null;
              End If;
            
              v_收发ids := v_收发ids || '|' || c_Stuff.Id || ',0';
            End If;
          End Loop;
          If Nvl(n_库房id, 0) <> 0 And v_收发ids Is Not Null Then
            v_收发ids := Substr(v_收发ids, 2);
            Zl_药品收发记录_批量发料(v_收发ids, n_库房id, 人员姓名_In, Sysdate, 1, 人员姓名_In, n_发料号, 人员姓名_In);
          End If;
        End If;
      
        --2.费用执行处理 
        Update 门诊费用记录
        Set 执行状态 = 1, 执行时间 = Sysdate, 执行人 = 人员姓名_In
        Where 收费类别 Not In ('5', '6', '7') And
              (医嘱序号, 记录性质, NO) In (Select 医嘱id, 记录性质, NO
                                   From 病人医嘱附费
                                   Where 医嘱id = r_Samplequest.医嘱id
                                   Union All
                                   Select 医嘱id, 记录性质, NO
                                   From 病人医嘱发送
                                   Where 医嘱id In (Select ID
                                                  From 病人医嘱记录 A, 病人医嘱发送 B
                                                  Where a.Id = b.医嘱id And r_Samplequest.医嘱id In (a.Id) And a.相关id Is Null And
                                                        b.执行状态 In (0, 2) And b.接收人 Is Null));
      End If;
    End Loop;
  
    --更新执行状态(只更新采集） 
    Update /*+ rule */ 病人医嘱发送
    Set 执行状态 = 1, 完成人 = 人员姓名_In, 完成时间 = Sysdate
    Where 医嘱id In
          (Select ID
           From 病人医嘱记录
           Where ID In (Select * From Table(Cast(f_Num2list(医嘱内容_In) As Zltools.t_Numlist))) And 相关id Is Null);
    --3.自动审核记帐 
    For r_Verify In c_Verify(医嘱内容_In) Loop
      If r_Verify.No || ',' || r_Verify.记录性质 <> v_No || ',' || v_性质 Then
        If v_序号 Is Not Null Then
          If v_性质 = 1 Then
            Zl_门诊记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
          Elsif v_性质 = 2 Then
            Zl_住院记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
          End If;
        End If;
        v_序号 := Null;
      End If;
      v_No   := r_Verify.No;
      v_性质 := r_Verify.记录性质;
      v_序号 := v_序号 || ',' || r_Verify.序号;
    End Loop;
    If v_序号 Is Not Null Then
      If v_性质 = 1 Then
        Zl_门诊记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
      Elsif v_性质 = 2 Then
        Zl_住院记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
      End If;
    End If;
  
  Else
    --检查标本是否被核收或接收 
    Begin
      Select /*+ rule */
       Nvl(c.Id, 0), b.执行状态, b.接收人
      Into v_检验标本记录, v_执行状态, v_接收人
      From 病人医嘱记录 A, 病人医嘱发送 B, 检验标本记录 C
      Where a.Id = b.医嘱id And a.相关id = c.医嘱id(+) And
            a.Id In (Select * From Table(Cast(f_Num2list(医嘱内容_In) As Zltools.t_Numlist)));
    Exception
      When Others Then
        v_检验标本记录 := 0;
    End;
  
    If v_检验标本记录 <> 0 Then
      v_Error := '标本已被检验科核收不能取消完成采集!';
      Raise Err_Custom;
    End If;
  
    If v_执行状态 <> 2 And v_接收人 Is Not Null Then
      v_Error := '标本已被检验科签收不能取消完成采集!';
      Raise Err_Custom;
    End If;
  
    Update /*+ rule */ 病人医嘱发送
    Set 采样人 = Null, 采样时间 = Null, 执行状态 = 0, 执行说明 = Null, 完成人 = Null, 完成时间 = Null
    Where 医嘱id In (Select ID
                   From 病人医嘱记录
                   Where ID In (Select * From Table(Cast(f_Num2list(医嘱内容_In) As Zltools.t_Numlist))));
  
    For r_Samplequest In c_Samplequest(医嘱内容_In) Loop
    
      If r_Samplequest.病人来源 = 2 Then
        --2.费用执行处理 
        Update 住院费用记录
        Set 执行状态 = 0, 执行时间 = Null, 执行人 = 人员姓名_In
        Where 收费类别 Not In ('5', '6', '7') And
              (医嘱序号, 记录性质, NO) In
              (Select 医嘱id, 记录性质, NO
               From 病人医嘱附费
               Where 医嘱id = r_Samplequest.医嘱id
               Union All
               Select 医嘱id, 记录性质, NO
               From 病人医嘱发送
               Where 医嘱id In (Select ID From 病人医嘱记录 Where r_Samplequest.医嘱id In (ID) And 相关id Is Null) And
                     执行状态 In (0, 2) And 接收人 Is Null);
      Else
        --退料
        If n_自动发料 = 1 Then
          For c_Stuff In (Select b.Id, b.实际数量
                          From 门诊费用记录 A, 药品收发记录 B
                          Where a.Id = b.费用id And a.收费类别 = '4' And (b.记录状态 = 1 Or Mod(b.记录状态, 3) = 0) And
                                b.审核人 Is Not Null And
                                (a.医嘱序号, a.记录性质, a.No) In
                                (Select 医嘱id, 记录性质, NO
                                 From 病人医嘱附费
                                 Where 医嘱id = r_Samplequest.医嘱id
                                 Union All
                                 Select 医嘱id, 记录性质, NO
                                 From 病人医嘱发送
                                 Where 医嘱id In
                                       (Select ID From 病人医嘱记录 Where r_Samplequest.医嘱id In (ID) And 相关id Is Null) And
                                       执行状态 In (0, 2) And 接收人 Is Null)) Loop
          
            Zl_材料收发记录_部门退料(c_Stuff.Id, 人员姓名_In, Sysdate, Null, Null, Null, c_Stuff.实际数量);
          End Loop;
        End If;
        --退费
        Update 门诊费用记录
        Set 执行状态 = 0, 执行时间 = Null, 执行人 = 人员姓名_In
        Where 收费类别 Not In ('5', '6', '7') And
              (医嘱序号, 记录性质, NO) In
              (Select 医嘱id, 记录性质, NO
               From 病人医嘱附费
               Where 医嘱id = r_Samplequest.医嘱id
               Union All
               Select 医嘱id, 记录性质, NO
               From 病人医嘱发送
               Where 医嘱id In (Select ID From 病人医嘱记录 Where r_Samplequest.医嘱id In (ID) And 相关id Is Null) And
                     执行状态 In (0, 2) And 接收人 Is Null);
      End If;
    End Loop;
  End If;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_检验预置条码_采集完成;
/

--110064:陈刘,2017-06-22,预出院打印体温单最后一页,无法显示诊断,调整诊断提取
Create Or Replace Function Zl_Replace_Element_Value
(
  元素名_In   In 诊治所见项目.中文名%Type,
  病人id_In   In 电子病历记录.病人id%Type,
  就诊id_In   In 电子病历记录.主页id%Type,
  病人来源_In In 电子病历记录.病人来源%Type,
  医嘱id_In   In 病人医嘱记录.Id%Type := Null,
  婴儿_In     In Number := 0,
  时间_In     In Date := Null
) Return Varchar2 Is
  v_Return Varchar2(4000) := Null;

  Cursor c_Annex Is
    Select 医嘱id, 项目, 内容 From 病人医嘱附件 Where 医嘱id = 医嘱id_In And 项目 = 元素名_In;
  r_Annex c_Annex%RowType;

  Cursor c_Pati Is
    Select 姓名, 性别, 年龄, 职业, 民族, 国籍, 婚姻状况, 出生日期, 出生地点, 身份证号, 身份, 学历, 家庭地址, 家庭电话, 工作单位, 单位电话, 门诊号, 住院次数, 联系人姓名, 联系人关系,
           联系人地址, 联系人电话
    From 病人信息
    Where 病人id = 病人id_In;
  r_Patient c_Pati%RowType;

  Cursor c_Reg Is
    Select 姓名, 性别, 年龄, 摘要, 登记时间, 急诊, 执行部门id
    From 病人挂号记录
    Where 病人id + 0 = 病人id_In And ID = 就诊id_In;
  r_Regist c_Reg%RowType;

  Cursor c_Inpage Is
    Select Nvl(b.姓名, a.姓名) 姓名, Nvl(b.性别, a.性别) 性别, Nvl(b.年龄, a.年龄) 年龄, b.住院号, b.入院日期, b.出院日期, b.住院目的, b.入院科室id, b.入院病区id,
           b.出院病床, b.当前病区id, b.当前病况, b.住院医师, b.责任护士, b.二级院转入, b.入院方式, b.护理等级id, b.出院方式, b.入院病床, b.联系人姓名, b.联系人关系,
           b.联系人地址, b.联系人电话, b.出院科室id, b.留观号
    From 病人信息 A, 病案主页 B
    Where a.病人id = b.病人id And b.病人id = 病人id_In And b.主页id = 就诊id_In;
  r_Inpage c_Inpage%RowType;

  Cursor c_Order Is
    Select 婴儿, 紧急标志, 开嘱科室id, 开嘱医生, 开嘱时间, 执行科室id, 开始执行时间, 医生嘱托, 诊疗类别, 诊疗项目id, 标本部位, 检查方法

    
    From 病人医嘱记录
    Where 病人id + 0 = 病人id_In And ID = 医嘱id_In;
  r_Order c_Order%RowType;

  Cursor c_Signs Is
    Select b.项目名称, b.记录内容
    From 病人护理记录 A, 病人护理内容 B
    Where a.病人id = 病人id_In And a.主页id = 就诊id_In And a.病人来源 = 病人来源_In And a.Id = b.记录id And b.记录类型 = 1 And
          b.项目名称 = 元素名_In;
  r_Signs c_Signs%RowType;

  v_Subtype 诊疗项目目录.操作类型%Type := Null;

  Type t_Str_Table Is Table Of Varchar2(2000);
  a_Return t_Str_Table := t_Str_Table();

  n_主页id 病案主页.主页id%Type;
  n_Times  Number;
  n_Have   Number(3);
  v_Sql    Varchar2(2000);

  --获取指定表的行类型
  Procedure p_Get_Rowtype(Table_In In Varchar2) Is
  Begin
    If Table_In = '病人信息' Then
      Open c_Pati;
      Fetch c_Pati
        Into r_Patient;
    Elsif Table_In = '病人挂号记录' Then
      Open c_Reg;
      Fetch c_Reg
        Into r_Regist;
    Elsif Table_In = '病案主页' Then
      Open c_Inpage;
      Fetch c_Inpage
        Into r_Inpage;
    Elsif Table_In = '病人医嘱记录' Then
      Open c_Order;
      Fetch c_Order
        Into r_Order;
    Elsif Table_In = '病人护理内容' Then
      Open c_Signs;
      Fetch c_Signs
        Into r_Signs;
    Elsif Table_In = '病人医嘱附件' Then
      Open c_Annex;
      Fetch c_Annex
        Into r_Annex;
    End If;
  Exception
    When Others Then
      Null;
  End p_Get_Rowtype;

  --从电子病历内容获取指定预制提纲的最新内容
  Function f_Latest_Epr_Content(提纲标题_In In 病历文件结构.内容文本%Type) Return Varchar2 Is
    v_Content Varchar2(32767);
    n_预制id  病历文件结构.Id%Type;
  Begin
    Select ID Into n_预制id From 病历文件结构 Where 内容文本 = 提纲标题_In And 文件id Is Null;
    Select c.内容文本 || Decode(c.要素类型, 0, c.要素单位) Bulk Collect
    Into a_Return
    From 电子病历内容 C,
         (Select ID
           From (Select r.Id 记录id, c.Id
                  From 电子病历记录 R, 电子病历内容 C
                  Where r.Id = c.文件id And r.病人id = 病人id_In And r.主页id = 就诊id_In And c.预制提纲id + 0 = n_预制id
                  Order By r.创建时间 Desc)
           Where Rownum = 1) P
    Where c.父id = p.Id And (c.对象类型 = 2 Or c.对象类型 = 4)
    Order By c.对象序号, c.内容行次;
    v_Content := Null;
    For n_Count In 1 .. a_Return.Count Loop
      v_Content := v_Content || a_Return(n_Count);
    End Loop;
    v_Content := Replace(v_Content, ' ', '');
    Return v_Content;
  Exception
    When Others Then
      Return Null;
  End f_Latest_Epr_Content;

  --从病人医嘱附件获取指定要素的最新内容，实际只有“病历摘要”需要
  Function f_Latest_Advice_Annex Return Varchar2 Is
    v_Content Varchar2(32767);
    n_要素id  病人医嘱附件.要素id%Type;
    v_挂号单  病人医嘱记录.挂号单%Type;
  Begin
    Select ID Into n_要素id From 诊治所见项目 Where 中文名 = 元素名_In;
    If 病人来源_In = 1 Then
      Select NO Into v_挂号单 From 病人挂号记录 Where ID = 就诊id_In;
    End If;
    Select 内容
    Into v_Content
    From (Select l.Id, a.内容, l.开嘱时间
           From 病人医嘱记录 L, 病人医嘱附件 A
           Where l.Id = a.医嘱id And l.病人id = 病人id_In And a.要素id = n_要素id
           Order By l.开嘱时间 Desc)
    Where Rownum = 1;
    Return v_Content;
  Exception
    When Others Then
      Return Null;
  End f_Latest_Advice_Annex;

  --获得病人指定就诊次数的最新诊断
  Function f_Latest_Diagnose
  (
    主页id_In In 病人诊断记录.主页id%Type,
    时间_In   In Date := Null
  ) Return Varchar2 Is
    v_Content Varchar2(32767);
  Begin
    If 时间_In Is Null Then
      --如果已经整理首页或病案中的诊断，则以这些诊断为最后诊断返回
      Select 诊断描述 || Decode(Nvl(是否疑诊, 0), 0, '', ' (？)') Bulk Collect
      Into a_Return
      From 病人诊断记录 D,
           (Select 记录来源, 诊断类型
             From (Select 记录来源, (Mod(诊断类型, 10)) As 诊断类型,
                           Row_Number() Over(Partition By 病人id Order By 记录来源 Desc, Mod(诊断类型, 10) Desc) As Top
                    From 病人诊断记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And 病历id Is Null And 记录来源 > 1 And 诊断类型 In (1, 11, 2, 12, 3, 13))
             Where Top = 1) F
      Where d.病人id = 病人id_In And d.主页id = 主页id_In And d.记录来源 = f.记录来源 And Mod(d.诊断类型, 10) = f.诊断类型
      Order By d.诊断次序;
      v_Content := Null;
      For n_Count In 1 .. a_Return.Count Loop
        If a_Return.Count > 1 Then
          v_Content := v_Content || '  ' || n_Count || '、' || a_Return(n_Count);
        Else
          v_Content := v_Content || a_Return(n_Count);
        End If;
      End Loop;
      If v_Content Is Not Null Then
        Return Trim(v_Content);
      End If;
    
      --否则，获取最后书写的病历中诊断作为最后诊断(隐含包括，如果还没有写病历，则以入院时填写的诊断为最后诊断)：
      Select d.诊断描述 || Decode(Nvl(d.是否疑诊, 0), 0, '', ' (？)') Bulk Collect
      Into a_Return
      From 病人诊断记录 D,
           (Select 病历id
             From (Select Distinct a.病历id, b.创建时间
                    From 病人诊断记录 A, 电子病历记录 B
                    Where a.病人id = 病人id_In And a.主页id = 主页id_In And a.诊断类型 In (1, 11, 2, 12, 3, 13) And Nvl(a.病历id, 0) <> 0 And
                          a.病历id = b.Id
                    Order By b.创建时间 Desc)
             Where Rownum = 1) M
      Where d.病人id = 病人id_In And d.主页id = 主页id_In And d.诊断类型 In (1, 11, 2, 12, 3, 13) And d.病历id = m.病历id
      Order By d.诊断次序;
      For n_Count In 1 .. a_Return.Count Loop
        If a_Return.Count > 1 Then
          v_Content := v_Content || '  ' || n_Count || '、' || a_Return(n_Count);
        Else
          v_Content := v_Content || a_Return(n_Count);
        End If;
      End Loop;
      Return Trim(v_Content);
    Else
      Select 诊断描述 || Decode(Nvl(是否疑诊, 0), 0, '', ' (？)') Bulk Collect
      Into a_Return
      From 病人诊断记录 D,
           (Select 记录来源, 诊断类型
             From (Select 记录来源, (Mod(诊断类型, 10)) As 诊断类型,
                           Row_Number() Over(Partition By 病人id Order By 记录来源 Desc, Mod(诊断类型, 10) Desc) As Top
                    From 病人诊断记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And 记录日期 < 时间_In And 诊断类型 In (1, 11, 2, 12, 3, 13))
             Where Top = 1) F
      Where d.病人id = 病人id_In And d.主页id = 主页id_In And d.记录来源 = f.记录来源 And Mod(d.诊断类型, 10) = f.诊断类型
      Order By d.诊断次序;
      v_Content := Null;
      For n_Count In 1 .. a_Return.Count Loop
        If a_Return.Count > 1 Then
          v_Content := v_Content || '  ' || n_Count || '、' || a_Return(n_Count);
        Else
          v_Content := v_Content || a_Return(n_Count);
        End If;
      End Loop;
      If v_Content Is Not Null Then
        Return Trim(v_Content);
      End If;
    End If;
  
  Exception
    When Others Then
      Return Null;
  End f_Latest_Diagnose;

  --获取病人最新疾病ID和诊断ID
  Function f_Last_Diagnoseid(主页id_In In 病人诊断记录.主页id%Type) Return Varchar2 Is
    v_Returndiagnose Varchar2(500);
  Begin
    For r_Diagnose In (Select 疾病id, 诊断id
                       From 病人诊断记录 D,
                            (Select 记录来源, 诊断类型
                              From (Select 记录来源, (Mod(诊断类型, 10)) As 诊断类型,
                                            Row_Number() Over(Partition By 病人id Order By 记录来源 Desc, Mod(诊断类型, 10) Desc) As Top
                                     From 病人诊断记录
                                     Where 病人id = 病人id_In And 主页id = 主页id_In And 病历id Is Null And 记录来源 > 1 And
                                           诊断类型 In (1, 11, 2, 12, 3, 13))
                              Where Top = 1) F
                       Where d.病人id = 病人id_In And d.主页id = 主页id_In And d.记录来源 = f.记录来源 And Mod(d.诊断类型, 10) = f.诊断类型
                       Order By d.诊断次序) Loop
      v_Returndiagnose := r_Diagnose.疾病id || '|' || r_Diagnose.诊断id;
      Return v_Returndiagnose;
    End Loop;
    --没取到则返回
    v_Returndiagnose := '|';
    Return v_Returndiagnose;
  Exception
    When Others Then
      Return Null;
  End f_Last_Diagnoseid;

  --获得病人指定住院诊断
  Function f_Diagnose(Inttype_In In Number) Return Varchar2 Is
    v_Content Varchar2(32767);
  Begin
    --intType_IN:1-西医门诊诊断;2-中医门诊诊断;3-西医入院诊断;4-中医入院诊断;
    --       5,所有西医出院诊断;6,只取西医出院主要诊断(诊断次序)=1;7,只取西医出院其他诊断(诊断次序)>1;8-中医出院诊断
    Select 诊断描述 || Decode(Nvl(是否疑诊, 0), 0, '', ' (？)') Bulk Collect
    Into a_Return
    From 病人诊断记录 D,
         (Select 记录来源, 诊断类型
           From (Select 记录来源, (Mod(诊断类型, 10)) As 诊断类型,
                         Row_Number() Over(Partition By 病人id Order By 记录来源 Desc, Mod(诊断类型, 10) Desc) As Top
                  From 病人诊断记录
                  Where 病人id = 病人id_In And 主页id = 就诊id_In And 病历id Is Null And 记录来源 > 1 And
                        诊断类型 = Decode(Inttype_In, 1, 1, 2, 11, 3, 2, 4, 12, 8, 13, 3))
           Where Top = 1) F
    Where d.病人id = 病人id_In And d.主页id = 就诊id_In And d.记录来源 = f.记录来源 And d.诊断类型 = f.诊断类型 And
          d.诊断次序 > Decode(Inttype_In, 7, 1, 0) And Rownum < Decode(Inttype_In, 6, 2, 10)
    Order By d.诊断次序;
  
    v_Content := Null;
    For n_Count In 1 .. a_Return.Count Loop
      If a_Return.Count > 1 Then
        v_Content := v_Content || '  ' || n_Count || '、' || a_Return(n_Count);
      Else
        v_Content := v_Content || a_Return(n_Count);
      End If;
    End Loop;
    If v_Content Is Not Null Then
      Return Trim(v_Content);
    End If;
  
  Exception
    When Others Then
      Return Null;
  End f_Diagnose;

  --获取病人本次就诊的医嘱内容
  Function f_Get_Advice_Text Return Varchar2 Is
    v_Text   Varchar2(4000);
    v_挂号单 病人挂号记录.No%Type;
  Begin
    If 病人来源_In = 1 Then
      Begin
        Select NO Into v_挂号单 From 病人挂号记录 Where ID = 就诊id_In;
      Exception
        When Others Then
          Return Null;
      End;
    End If;
  
    --提取病人医嘱：界面可见行医嘱内容，不含作废的
    For r_Row In (Select a.医嘱内容
                  From 病人医嘱记录 A, 诊疗项目目录 B
                  Where a.诊疗项目id = b.Id And a.开始执行时间 Is Not Null And a.医嘱状态 <> 4 And Nvl(a.婴儿, 0) = 0 And
                        Not (a.诊疗类别 In ('F', 'G', 'D', 'C', 'E') And a.相关id Is Not Null) And a.诊疗类别 <> '7' And
                        Not (a.诊疗类别 = 'E' And b.操作类型 In ('2', '4')) And a.病人来源 = 病人来源_In And a.病人id = 病人id_In And
                        (病人来源_In = 1 And a.挂号单 = v_挂号单 Or a.主页id = 就诊id_In)
                  Order By a.序号) Loop
      If Lengthb(v_Text || r_Row.医嘱内容) <= 4000 Then
        v_Text := v_Text || Chr(13) || Chr(10) || r_Row.医嘱内容;
      Else
        Exit;
      End If;
    End Loop;
  
    Return Substr(v_Text, 3);
  End f_Get_Advice_Text;
Begin
  Case
    When Instr('会诊范围,会诊邀请医院,会诊邀请科室,会诊医生级别,会诊邀请医生,会诊代表科室,会诊诊断,会诊目的,会诊意见,会诊完成时间,会诊完成科室,会诊医生', 元素名_In) > 0 Then
      p_Get_Rowtype('病人医嘱附件');
      v_Return := r_Annex.内容;
    When Instr('体温,呼吸,脉搏,收缩压,舒张压', 元素名_In) > 0 And 病人来源_In = 1 Then
      p_Get_Rowtype('病人护理内容');
      v_Return := r_Signs.记录内容;
    When Instr(',当前日期,当前时间,DQSJ', ',' || Upper(元素名_In)) > 0 Then
      --无需读取任何表数据的元素
      Case Upper(元素名_In)
        When '当前日期' Then
          v_Return := To_Char(Sysdate, 'yyyy-mm-dd');
          v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日';
        When '当前时间' Then
          v_Return := To_Char(Sysdate, 'yyyy-mm-dd hh24:mi');
          v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日' ||
                      Substr(v_Return, 12, 2) || '时' || Substr(v_Return, 15, 2) || '分';
        When 'DQSJ' Then
          v_Return := To_Char(Sysdate, 'yyyy-mm-dd hh24:mi');
          v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日' ||
                      Substr(v_Return, 12, 2) || '时' || Substr(v_Return, 15, 2) || '分';
      End Case;
    When Instr(',职业,民族,国籍,婚姻状况,出生日期,出生地点,身份证号,身份,学历,家庭地址,家庭电话,工作单位,单位电话,门诊号,住院次数', ',' || 元素名_In) > 0 Then
      --只查病人信息表的元素
      p_Get_Rowtype('病人信息');
      Case 元素名_In
        When '职业' Then
          v_Return := r_Patient.职业;
        When '民族' Then
          v_Return := r_Patient.民族;
        When '国籍' Then
          v_Return := r_Patient.国籍;
        When '婚姻状况' Then
          v_Return := r_Patient.婚姻状况;
        When '出生日期' Then
          v_Return := To_Char(r_Patient.出生日期, 'yyyy-mm-dd');
          v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日';
        When '出生地点' Then
          v_Return := r_Patient.出生地点;
        When '身份证号' Then
          v_Return := r_Patient.身份证号;
        When '身份' Then
          v_Return := r_Patient.身份;
        When '学历' Then
          v_Return := r_Patient.学历;
        When '家庭地址' Then
          v_Return := r_Patient.家庭地址;
        When '家庭电话' Then
          v_Return := r_Patient.家庭电话;
        When '工作单位' Then
          v_Return := r_Patient.工作单位;
        When '单位电话' Then
          v_Return := r_Patient.单位电话;
        When '门诊号' Then
          v_Return := r_Patient.门诊号;
        When '住院次数' Then
          v_Return := Nvl(r_Patient.住院次数, 0);
        Else
          v_Return := '';
      End Case;
    When Instr(',留观号,住院号,入院日期,出院日期,住院目的,入院科室,入院病区,当前床号,当前病区,当前病况,住院医师,责任护士,住院天数,入院方式,护理等级,出院方式,入院病室,出院病室,当前病室',
               ',' || 元素名_In) > 0 Then
      --只查病人主页的元素
      p_Get_Rowtype('病案主页');
      Case 元素名_In
        When '留观号' Then
          v_Return := r_Inpage.留观号;
        When '住院号' Then
          v_Return := r_Inpage.住院号;
        When '入院日期' Then
          If 病人来源_In = 2 Then
            v_Return := To_Char(r_Inpage.入院日期, 'yyyy-mm-dd hh24:mi');
            v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日' ||
                        Substr(v_Return, 12, 2) || '时' || Substr(v_Return, 15, 2) || '分';
          
          End If;
        When '出院日期' Then
          If 病人来源_In = 2 Then
            v_Return := To_Char(r_Inpage.出院日期, 'yyyy-mm-dd hh24:mi');
            v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日' ||
                        Substr(v_Return, 12, 2) || '时' || Substr(v_Return, 15, 2) || '分';
          End If;
        When '住院目的' Then
          If 病人来源_In = 2 Then
            v_Return := r_Inpage.住院目的;
          End If;
        
        When '入院科室' Then
          If 病人来源_In = 2 Then
            Select Max(d.名称)
            Into v_Return
            From 部门表 D, 病人变动记录 P
            Where d.Id = p.科室id And p.病人id = 病人id_In And p.主页id = 就诊id_In And p.开始原因 = 9;
            If v_Return Is Null Then
              Select 名称 Into v_Return From 部门表 Where ID = r_Inpage.入院科室id;
            End If;
          End If;
        When '入院病区' Then
          If 病人来源_In = 2 Then
            Select Max(d.名称)
            Into v_Return
            From 部门表 D, 病人变动记录 P
            Where d.Id = p.病区id And p.病人id = 病人id_In And p.主页id = 就诊id_In And p.开始原因 = 9;
            If v_Return Is Null Then
              Select 名称 Into v_Return From 部门表 Where ID = r_Inpage.入院病区id;
            End If;
          End If;
        When '当前床号' Then
          If 病人来源_In = 2 Then
            v_Return := r_Inpage.出院病床;
          End If;
        When '当前病区' Then
          If 病人来源_In = 2 Then
            Select 名称 Into v_Return From 部门表 Where ID = r_Inpage.当前病区id;
          End If;
        When '当前病况' Then
          If 病人来源_In = 2 Then
            v_Return := r_Inpage.当前病况;
          End If;
        When '住院医师' Then
          If 病人来源_In = 2 Then
            v_Return := r_Inpage.住院医师;
          End If;
        When '责任护士' Then
          If 病人来源_In = 2 Then
            v_Return := r_Inpage.责任护士;
          End If;
        When '住院天数' Then
          If 病人来源_In = 2 Then
            v_Return := Trunc(Nvl(r_Inpage.出院日期, Sysdate)) - Trunc(r_Inpage.入院日期);
          End If;
        When '入院方式' Then
          If 病人来源_In = 2 Then
            If r_Inpage.二级院转入 = 1 Then
              v_Return := '转入';
            Else
              v_Return := r_Inpage.入院方式;
            
            End If;
          
          End If;
        When '护理等级' Then
          If 病人来源_In = 2 Then
            Select 名称 Into v_Return From 收费项目目录 Where ID = r_Inpage.护理等级id;
          End If;
        When '出院方式' Then
          If 病人来源_In = 2 Then
            v_Return := r_Inpage.出院方式;
          End If;
        When '入院病室' Then
          If 病人来源_In = 2 Then
            If v_Return Is Null And r_Inpage.入院病床 Is Not Null Then
              Begin
                Select 房间号
                Into v_Return
                From 床位状况记录
                Where 病区id = r_Inpage.入院病区id And 床号 = r_Inpage.入院病床;
              Exception
              
                When Others Then
                  Null;
              End;
            End If;
          End If;
        When '出院病室' Then
          If 病人来源_In = 2 Then
            If v_Return Is Null And r_Inpage.出院病床 Is Not Null Then
            
              Begin
                Select 房间号
                Into v_Return
                From 床位状况记录
                Where 病区id = r_Inpage.当前病区id And 床号 = r_Inpage.出院病床;
              Exception
                When Others Then
                  Null;
              End;
            End If;
          End If;
        When '当前病室' Then
          If 病人来源_In = 2 Then
            If v_Return Is Null And r_Inpage.出院病床 Is Not Null Then
              Begin
                Select 房间号
                Into v_Return
                From 床位状况记录
                Where 病区id = r_Inpage.当前病区id And 床号 = r_Inpage.出院病床;
              Exception
                When Others Then
                  Null;
              End;
            End If;
          End If;
        Else
          v_Return := '';
      End Case;
    When Instr(',姓名,性别,年龄', ',' || 元素名_In) > 0 Then
      p_Get_Rowtype('病人医嘱记录');
      If Nvl(r_Order.婴儿, 0) = 0 And Nvl(婴儿_In, 0) = 0 Then
        If 病人来源_In = 2 Then
          p_Get_Rowtype('病案主页');
          If 元素名_In = '姓名' Then
            v_Return := r_Inpage.姓名;
          Elsif 元素名_In = '性别' Then
            v_Return := r_Inpage.性别;
          Elsif 元素名_In = '年龄' Then
            v_Return := r_Inpage.年龄;
          End If;
        Else
          p_Get_Rowtype('病人挂号记录');
          If Not r_Regist.姓名 Is Null Then
            If 元素名_In = '姓名' Then
              v_Return := r_Regist.姓名;
            Elsif 元素名_In = '性别' Then
              v_Return := r_Regist.性别;
            Elsif 元素名_In = '年龄' Then
              v_Return := r_Regist.年龄;
            End If;
          Else
            p_Get_Rowtype('病人信息');
            If 元素名_In = '姓名' Then
              v_Return := r_Patient.姓名;
            Elsif 元素名_In = '性别' Then
              v_Return := r_Patient.性别;
            Elsif 元素名_In = '年龄' Then
              v_Return := r_Patient.年龄;
            End If;
          End If;
        End If;
      Else
        If 元素名_In = '姓名' Then
          p_Get_Rowtype('病案主页');
          Select Decode(婴儿姓名, Null, r_Inpage.姓名 || '之婴' || Trim(To_Char(序号, '9')), 婴儿姓名) As 婴儿姓名
          Into v_Return
          From 病人新生儿记录
          Where 病人id = 病人id_In And 主页id = 就诊id_In And 序号 = Decode(婴儿_In, 0, Nvl(r_Order.婴儿, 0), 婴儿_In);
        Elsif 元素名_In = '性别' Then
          Select 婴儿性别
          Into v_Return
          From 病人新生儿记录
          Where 病人id = 病人id_In And 主页id = 就诊id_In And 序号 = Decode(婴儿_In, 0, Nvl(r_Order.婴儿, 0), 婴儿_In);
        Elsif 元素名_In = '年龄' Then
          Select To_Char(出生时间, 'yyyy-mm-dd hh24:mi')
          Into v_Return
          From 病人新生儿记录
          Where 病人id = 病人id_In And 主页id = 就诊id_In And 序号 = Decode(婴儿_In, 0, Nvl(r_Order.婴儿, 0), 婴儿_In);
        End If;
      End If;
    When Instr(',标识号,联系人姓名,联系人关系,联系人地址,联系人电话', ',' || 元素名_In) > 0 Then
      If 病人来源_In = 2 Then
        p_Get_Rowtype('病案主页');
        If 元素名_In = '标识号' Then
          v_Return := r_Inpage.住院号;
        Elsif 元素名_In = '联系人姓名' Then
          v_Return := r_Inpage.联系人姓名;
        Elsif 元素名_In = '联系人关系' Then
          v_Return := r_Inpage.联系人关系;
        Elsif 元素名_In = '联系人地址' Then
          v_Return := r_Inpage.联系人地址;
        Elsif 元素名_In = '联系人电话' Then
          v_Return := r_Inpage.联系人电话;
        End If;
      Else
        p_Get_Rowtype('病人信息');
        If 元素名_In = '标识号' Then
          v_Return := r_Patient.门诊号;
        Elsif 元素名_In = '联系人姓名' Then
          v_Return := r_Patient.联系人姓名;
        Elsif 元素名_In = '联系人关系' Then
          v_Return := r_Patient.联系人关系;
        Elsif 元素名_In = '联系人地址' Then
          v_Return := r_Patient.联系人地址;
        Elsif 元素名_In = '联系人电话' Then
          v_Return := r_Patient.联系人电话;
        End If;
      End If;
    When Instr(',门诊就诊摘要,就诊科室,就诊时间,是否急诊,当前科室', ',' || 元素名_In) > 0 Then
      --只查病人挂号记录的元素
      If 病人来源_In = 1 Then
        p_Get_Rowtype('病人挂号记录');
        If 元素名_In = '门诊就诊摘要' Then
          v_Return := r_Regist.摘要;
        Elsif 元素名_In = '就诊科室' Then
          Select 名称 Into v_Return From 部门表 Where ID = r_Regist.执行部门id;
        Elsif 元素名_In = '就诊时间' Then
          v_Return := To_Char(r_Regist.登记时间, 'yyyy-mm-dd hh24:mi');
          v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日' ||
                      Substr(v_Return, 12, 2) || '时' || Substr(v_Return, 15, 2) || '分';
        Elsif 元素名_In = '是否急诊' Then
          If r_Regist.急诊 = 1 Then
            v_Return := '急诊';
          End If;
        Elsif 元素名_In = '当前科室' Then
          Select 名称 Into v_Return From 部门表 Where ID = r_Regist.执行部门id;
        End If;
      Else
        If 元素名_In = '当前科室' Then
          p_Get_Rowtype('病案主页');
          Select 名称 Into v_Return From 部门表 Where ID = r_Inpage.出院科室id;
        End If;
      End If;
    When Instr(',紧急程度,开单科室,开单医生,开单时间,开单时间,执行科室,要求时间,医生嘱托,诊疗类别,申请项目,检查类型,部位方法,检验标本', ',' || 元素名_In) > 0 Then
      --只查病人医嘱记录的元素
      p_Get_Rowtype('病人医嘱记录');
      If 元素名_In = '紧急程度' Then
        If r_Order.紧急标志 = 1 Then
          v_Return := '急';
        End If;
      Elsif 元素名_In = '开单科室' Then
        Select 名称 Into v_Return From 部门表 Where ID = r_Order.开嘱科室id;
      Elsif 元素名_In = '开单医生' Then
        v_Return := r_Order.开嘱医生;
      Elsif 元素名_In = '开单时间' Then
        v_Return := To_Char(r_Order.开嘱时间, 'yyyy-mm-dd hh24:mi');
        v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日' ||
                    Substr(v_Return, 12, 2) || '时' || Substr(v_Return, 15, 2) || '分';
      Elsif 元素名_In = '执行科室' Then
        Select 名称 Into v_Return From 部门表 Where ID = r_Order.执行科室id;
      Elsif 元素名_In = '要求时间' Then
        v_Return := To_Char(r_Order.开始执行时间, 'yyyy-mm-dd hh24:mi');
        v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日' ||
                    Substr(v_Return, 12, 2) || '时' || Substr(v_Return, 15, 2) || '分';
      Elsif 元素名_In = '医生嘱托' Then
        v_Return := r_Order.医生嘱托;
      Elsif 元素名_In = '诊疗类别' Then
        Select 名称 Into v_Return From 诊疗项目类别 Where 编码 = r_Order.诊疗类别;
      Elsif 元素名_In = '申请项目' Then
        Select 操作类型 Into v_Subtype From 诊疗项目目录 Where ID = r_Order.诊疗项目id;
        If r_Order.诊疗类别 = 'E' And v_Subtype = '6' Then
          Select i.名称 Bulk Collect
          Into a_Return
          From 诊疗项目目录 I, (Select 序号, 诊疗项目id From 病人医嘱记录 Where 相关id = 医嘱id_In) A
          Where i.Id = a.诊疗项目id
          Order By a.序号;
        Else
          Select i.名称 Bulk Collect
          Into a_Return
          From 诊疗项目目录 I,
               (Select 序号, 诊疗项目id
                 From 病人医嘱记录
                 Where ID = 医嘱id_In
                 Union All
                 Select 序号, 诊疗项目id
                 From 病人医嘱记录
                 Where 相关id = 医嘱id_In And 诊疗类别 <> 'G') A
          Where i.Id = a.诊疗项目id
          Group By i.名称
          Order By Max(a.序号);
        End If;
        If a_Return.Count > 1 Then
          For n_Count In 1 .. a_Return.Count Loop
            v_Return := v_Return || ' ' || n_Count || ')' || a_Return(n_Count);
          End Loop;
        Else
          v_Return := a_Return(1);
        End If;
        v_Return := Trim(v_Return);
      Elsif 元素名_In = '检查类型' Then
        Select 操作类型 Into v_Return From 诊疗项目目录 Where ID = r_Order.诊疗项目id And 类别 = 'D';
      Elsif 元素名_In = '部位方法' Then
        Select 部位 || Chr(9) || 方法 Bulk Collect
        Into a_Return
        From (Select 标本部位 As 部位, 检查方法 As 方法
               From 病人医嘱记录
               Where 相关id = 医嘱id_In And 诊疗类别 = 'D'
               Union All
               Select r_Order.标本部位, r_Order.检查方法
               From Dual) A,
             (Select p.编码, p.名称
               From 诊疗检查部位 P, 诊疗项目目录 I
               Where p.类型 = i.操作类型 And ID = r_Order.诊疗项目id And 类别 = 'D') P
        Where a.部位 = p.名称
        Order By p.编码;
        For n_Count In 1 .. a_Return.Count Loop
          If Instr(v_Return, ' ' || Substr(a_Return(n_Count), 1, Instr(a_Return(n_Count), Chr(9)))) > 0 Then
            v_Return := v_Return || '、' || Substr(a_Return(n_Count), Instr(a_Return(n_Count), Chr(9)) + 1);
          Else
            v_Return := v_Return || '  ' || a_Return(n_Count);
          End If;
        End Loop;
        v_Return := Replace(v_Return, Chr(9), ':');
      Elsif 元素名_In = '检验标本' Then
        v_Return := r_Order.标本部位;
      Else
        v_Return := '';
      End If;
    Else
      --自行查询SQL返回值的元素
      If 元素名_In = '单位名称' Then
        Select 内容 Into v_Return From Zlregaudit Where 项目 = '单位名称';
        If Instr(v_Return, ';') > 0 Then
          v_Return := Substr(v_Return, 1, Instr(v_Return, ';') - 1);
        End If;
      Elsif 元素名_In = '入科时间' Then
        If 病人来源_In = 2 Then
          Select Count(*)
          Into n_Times
          From 病人变动记录
          Where 病人id = 病人id_In And 主页id = 就诊id_In And 开始原因 = 2;
          If n_Times = 0 Then
            Select To_Char(开始时间, 'yyyy-mm-dd hh24:mi')
            Into v_Return
            From 病人变动记录
            Where 病人id = 病人id_In And 主页id = 就诊id_In And 开始原因 = 1;
          Else
            Select To_Char(开始时间, 'yyyy-mm-dd hh24:mi')
            Into v_Return
            From 病人变动记录
            Where 病人id = 病人id_In And 主页id = 就诊id_In And 开始原因 = 2;
          End If;
          v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日' ||
                      Substr(v_Return, 12, 2) || '时' || Substr(v_Return, 15, 2) || '分';
        End If;
      
      Elsif 元素名_In = 'ABO' Or 元素名_In = 'RH' Then
        Select 信息值 Into v_Return From 病人信息从表 P Where p.病人id = 病人id_In And p.信息名 = 元素名_In;
      Elsif 元素名_In = '一次住院时间' Or 元素名_In = '二次住院时间' Or 元素名_In = '上次住院时间' Then
        If 病人来源_In = 2 Then
          Select To_Char(入院日期, 'yyyy-mm-dd hh24:mi') Bulk Collect
          Into a_Return
          From 病案主页
          Where 病人id = 病人id_In And 主页id < 就诊id_In
          Order By 入院日期;
          If 元素名_In = '一次住院时间' And a_Return.Count > 0 Then
            v_Return := a_Return(1);
          Elsif 元素名_In = '二次住院时间' And a_Return.Count > 1 Then
            v_Return := a_Return(2);
          Elsif 元素名_In = '上次住院时间' And a_Return.Count > 0 Then
            v_Return := a_Return(a_Return.Count);
          Else
            Return Null;
          End If;
          v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日' ||
                      Substr(v_Return, 12, 2) || '时' || Substr(v_Return, 15, 2) || '分';
        End If;
      Elsif 元素名_In = '最后诊断' Then
        v_Return := f_Latest_Diagnose(就诊id_In, 时间_In);
      Elsif 元素名_In = '最后诊断ID' Then
        v_Return := f_Last_Diagnoseid(就诊id_In);
      Elsif 元素名_In = '门诊诊断' Then
        v_Return := f_Diagnose(1);
      Elsif 元素名_In = '一次住院诊断' Or 元素名_In = '二次住院诊断' Or 元素名_In = '上次住院诊断' Then
        Select 主页id Bulk Collect
        Into a_Return
        From 病案主页
        Where 病人id = 病人id_In And 主页id < 就诊id_In
        Order By 入院日期;
        If 元素名_In = '一次住院诊断' And a_Return.Count > 0 Then
          n_主页id := To_Number(a_Return(1));
        Elsif 元素名_In = '二次住院诊断' And a_Return.Count > 1 Then
          n_主页id := To_Number(a_Return(2));
        Elsif 元素名_In = '上次住院诊断' And a_Return.Count > 0 Then
          n_主页id := To_Number(a_Return(a_Return.Count));
        Else
          Return Null;
        End If;
        v_Return := f_Latest_Diagnose(n_主页id);
      Elsif 元素名_In = '西医门诊诊断' Then
        v_Return := f_Diagnose(1);
      Elsif 元素名_In = '中医门诊诊断' Then
        v_Return := f_Diagnose(2);
      Elsif 元素名_In = '西医入院诊断' Then
        v_Return := f_Diagnose(3);
      Elsif 元素名_In = '中医入院诊断' Then
        v_Return := f_Diagnose(4);
      Elsif 元素名_In = '西医出院诊断' Then
        v_Return := f_Diagnose(5);
      Elsif 元素名_In = '西医出院主要诊断' Then
        v_Return := f_Diagnose(6);
      Elsif 元素名_In = '西医出院其他诊断' Then
        v_Return := f_Diagnose(7);
      Elsif 元素名_In = '中医出院诊断' Then
        v_Return := f_Diagnose(8);
      Elsif 元素名_In = '过敏药物' Then
        Select d.药物名 Bulk Collect
        Into a_Return
        From 病人过敏记录 D, (Select Max(记录时间) As 时间 From 病人过敏记录 Where 病人id = 病人id_In And 结果 = 1) M
        Where d.病人id = 病人id_In And d.结果 = 1 And d.记录时间 = m.时间;
        For n_Count In 1 .. a_Return.Count Loop
          v_Return := v_Return || '；' || a_Return(n_Count);
        End Loop;
        If v_Return Is Not Null Then
          v_Return := Substr(v_Return, 2);
        End If;
      Elsif 元素名_In = '病人主诉' Then
        v_Return := f_Latest_Epr_Content(元素名_In);
        v_Return := Replace(Replace(Replace(v_Return, '病人主诉：'), '病人主诉:'), '病人主诉');
        v_Return := Replace(Replace(Replace(v_Return, '主诉：'), '主诉:'), '主诉');
        v_Return := Replace(Replace(Replace(v_Return, Chr(13)), Chr(10)), ' ');
      Elsif 元素名_In = '病历摘要' Then
        v_Return := f_Latest_Epr_Content(元素名_In);
        If v_Return Is Null Then
          v_Return := f_Latest_Advice_Annex();
        End If;
        If v_Return Is Null Then
          v_Return := f_Latest_Epr_Content('病人主诉');
          v_Return := Replace(Replace(Replace(v_Return, '病人主诉：'), '病人主诉:'), '病人主诉');
          v_Return := Replace(Replace(Replace(v_Return, '主诉：'), '主诉:'), '主诉');
        End If;
      Elsif 元素名_In = '现病史' Or 元素名_In = '体格检查' Or 元素名_In = '辅助检查' Or 元素名_In = '专科检查' Or 元素名_In = '既往史' Then
        v_Return := f_Latest_Epr_Content(元素名_In);
        v_Return := Replace(Replace(Replace(v_Return, Chr(13)), Chr(10)), ' ');
      Elsif 元素名_In = '检验类型' Then
        Select 操作类型
        Into v_Return
        From 诊疗项目目录 I,
             (Select 序号, 诊疗项目id From 病人医嘱记录 Where 相关id = 医嘱id_In And 诊疗类别 = 'C' And Rownum < 2) A
        Where i.Id = a.诊疗项目id;
      Elsif 元素名_In = '麻醉方式' Then
        Select i.名称
        Into v_Return
        From 病人医嘱记录 A, 诊疗项目目录 I
        Where a.诊疗项目id = i.Id And a.相关id = 医嘱id_In And a.诊疗类别 = 'G';
      Elsif 元素名_In = '本次医嘱' Then
        v_Return := f_Get_Advice_Text();
      Elsif 元素名_In = '报到时间' Then
        Select To_Char(Max(报到时间), 'yyyy-mm-dd hh24:mi') Into v_Return From 病人医嘱发送 Where 医嘱id = 医嘱id_In;
        v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日' ||
                    Substr(v_Return, 12, 2) || '时' || Substr(v_Return, 15, 2) || '分';
      Elsif 元素名_In = '执行间' Then
        Select Max(执行间) Into v_Return From 病人医嘱发送 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '费用单号' Then
        Select Max(记录性质 || NO) Into v_Return From 病人医嘱发送 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '执行人' Then
        Select Max(执行人) Into v_Return From 病人医嘱执行 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '执行时间' Then
        Select To_Char(Max(执行时间), 'yyyy-mm-dd hh24:mi') Into v_Return From 病人医嘱执行 Where 医嘱id = 医嘱id_In;
        v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日' ||
                    Substr(v_Return, 12, 2) || '时' || Substr(v_Return, 15, 2) || '分';
      Elsif 元素名_In = '设备型号' Then
        Select 名称 Bulk Collect
        Into a_Return
        From (Select a.名称
               From (Select r.仪器id
                      From 检验标本记录 L, 检验普通结果 R
                      Where r.检验标本id = l.Id And l.医嘱id = 医嘱id_In
                      Union
                      Select l.仪器id
                      From 检验标本记录 L
                      Where l.医嘱id = 医嘱id_In) L, 检验仪器 A
               Where l.仪器id = a.Id
               Union All
               Select 检查设备
               From 影像检查记录
               Where 医嘱id = 医嘱id_In);
        For n_Count In 1 .. a_Return.Count Loop
          v_Return := v_Return || ' ' || a_Return(n_Count);
        End Loop;
        v_Return := Trim(v_Return);
      
      Elsif 元素名_In = '采样人' Then
        Select Max(采样人) Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '采样时间' Then
        Select To_Char(Max(采样时间), 'yyyy-mm-dd hh24:mi') Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '样本条码' Then
        Select Max(样本条码) Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '标本序号' Then
        Select Max(标本序号) Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '标本类型' Then
        Select Max(标本类型) Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '核收人' Then
        Select Max(核收人) Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '核收时间' Then
        Select To_Char(Max(核收时间), 'yyyy-mm-dd hh24:mi') Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '检验人' Then
        Select Max(检验人) Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '检验时间' Then
        Select To_Char(Max(检验时间), 'yyyy-mm-dd hh24:mi') Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '审核人' Then
        Select Max(审核人) Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '审核时间' Then
        Select To_Char(Max(审核时间), 'yyyy-mm-dd hh24:mi') Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '检验评语' Then
        Select Max(备注) Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '检验备注' Then
        Select Max(检验备注) Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '检验项目' Then
        Select 名称 Bulk Collect
        Into a_Return
        From (Select i.名称
               From 诊疗项目目录 I, 病人医嘱记录 A,
                    (Select r.医嘱id From 检验标本记录 L, 检验项目分布 R Where r.标本id = l.Id And l.医嘱id = 医嘱id_In) L
               Where i.Id = a.诊疗项目id And a.相关id = l.医嘱id
               Order By a.序号);
        For n_Count In 1 .. a_Return.Count Loop
          v_Return := v_Return || ' ' || a_Return(n_Count);
        End Loop;
        v_Return := Trim(v_Return);
      
      Elsif 元素名_In = '影像类别' Then
        Select Max(影像类别) Into v_Return From 影像检查记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '检查号' Then
        Select Max(检查号) Into v_Return From 影像检查记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '服用造影剂' Then
        Select 造影剂 || '  用量:' || 用量 || '  浓度:' || 浓度 Into v_Return From 服用造影剂 Where 医嘱id = 医嘱id_In;
      
      Elsif 元素名_In = '手术规模' Or 元素名_In = '手术执行间' Or 元素名_In = '手术麻醉质量' Or 元素名_In = '手术麻醉方式' Or 元素名_In = '手术开始时间' Or
            元素名_In = '手术结束时间' Or 元素名_In = '麻醉开始时间' Or 元素名_In = '麻醉结束时间' Or 元素名_In = '输氧开始时间' Or 元素名_In = '输氧结束时间' Or
            元素名_In = '主刀医生' Or 元素名_In = '助手医生' Or 元素名_In = '麻醉医生' Or 元素名_In = '洗手护士' Or 元素名_In = '巡回护士' Or
            元素名_In = '其他手术人员' Or 元素名_In = '拟行主手术' Or 元素名_In = '拟行附手术' Or 元素名_In = '已行主手术' Or 元素名_In = '已行附手术' Or
            元素名_In = '术前主诊断' Or 元素名_In = '术前次诊断' Or 元素名_In = '术后主诊断' Or 元素名_In = '术后次诊断' Or 元素名_In = '输液总量' Or
            元素名_In = '拟施手术时间' Or 元素名_In = '拟施麻醉方式' Then
      
        --这些要素从手麻子系统中获取
        n_Have := 0;
        Begin
          Select 1 Into n_Have From zlSystems Where Floor(编号 / 100) = 24;
        Exception
          When Others Then
            Null;
        End;
        If n_Have = 1 Then
          If 医嘱id_In Is Null Then
            v_Sql := 'Select Zl24_Replace_Element_Value(:v1,:v2,:v3,:v4,Null) From Dual';
            Begin
              Execute Immediate v_Sql
                Into v_Return
                Using 元素名_In, Trim(To_Char(病人id_In)), Trim(To_Char(就诊id_In)), Trim(To_Char(病人来源_In));
            Exception
              When Others Then
                Null;
            End;
          Else
            v_Sql := 'Select Zl24_Replace_Element_Value(:v1,:v2,:v3,:v4,:v5) From Dual';
            Begin
              Execute Immediate v_Sql
                Into v_Return
                Using 元素名_In, Trim(To_Char(病人id_In)), Trim(To_Char(就诊id_In)), Trim(To_Char(病人来源_In)), Trim(To_Char(医嘱id_In));
            Exception
              When Others Then
                Null;
            End;
          End If;
        End If;
      Else
        v_Sql := 'Select Zl_Replace_Element_Value_User(:v1,:v2,:v3,:v4,:v5,:v6) From Dual';
        Begin
          Execute Immediate v_Sql
            Into v_Return
            Using 元素名_In, 病人id_In, 就诊id_In, 病人来源_In, 医嘱id_In, 婴儿_In;
        Exception
          When Others Then
            Null;
        End;
      End If;
  End Case;
  Return Trim(v_Return);
Exception
  When Others Then
    Return Null;
End Zl_Replace_Element_Value;
/

--106374:余伟节,2017-06-22,疾病编码分类、疾病编码目录更新
Create Or Replace Procedure Zl_疾病编码目录_Redo
(
  建档时间_In 疾病编码目录.建档时间%Type,
  撤档时间_In 疾病编码目录.撤档时间%Type
) Is
  a_Id_Type t_Numlist := t_Numlist();
  a_Id_New  t_Numlist := t_Numlist();
  a_Id_Old  t_Numlist := t_Numlist();
  a_Id_Temp t_Numlist := t_Numlist();
  a_Rownum  t_Numlist := t_Numlist();
  n_Max     Number(18);
  n_Nextnum Number(18);
  n_Count   Number(18);
  Cursor c_Item
  (
    建档_In 疾病编码目录.建档时间%Type,
    撤档_In 疾病编码目录.撤档时间%Type
  ) Is
    Select a.Id As Id_New, b.Id As Id_Old, a.分类id
    From (Select ID, 分类id, 名称, 编码, 类别 From 疾病编码目录 Where 建档时间 = 建档_In) A,
         (Select ID, 名称, 编码, 类别 From 疾病编码目录 Where 撤档时间 = 撤档_In) B
    Where a.名称 = b.名称 And a.编码 = b.编码 And a.类别 = b.类别;
Begin
  Select Max(ID) Into n_Count From 疾病编码目录 Where (建档时间 < 建档时间_In Or 建档时间 Is Null);
  --
  Open c_Item(建档时间_In, 撤档时间_In);
  Fetch c_Item Bulk Collect
    Into a_Id_New, a_Id_Old, a_Id_Type;
  Close c_Item;

  Forall I In 1 .. a_Id_New.Count
    Delete 疾病编码目录 Where ID = a_Id_New(I);

  Forall I In 1 .. a_Id_Old.Count
    Update 疾病编码目录 Set 分类id = a_Id_Type(I), 撤档时间 = Null Where ID = a_Id_Old(I);

  --记录下新增数据的ID
  Select a.Id, Rownum Bulk Collect
  Into a_Id_Temp, a_Rownum
  From (Select ID From 疾病编码目录 Where 建档时间 = 建档时间_In Order By ID) A;
  n_Max := n_Count + a_Id_Temp.Count;
  --序列重整
  Select 疾病编码目录_Id.Nextval Into n_Nextnum From Dual;
  Execute Immediate 'Alter Sequence 疾病编码目录_Id Increment By' || (n_Max - n_Nextnum);
  Select 疾病编码目录_Id.Nextval Into n_Nextnum From Dual;
  Execute Immediate 'Alter Sequence 疾病编码目录_Id Increment By 1';
  --重置ID
  Forall I In 1 .. a_Id_Temp.Count
    Update 疾病编码目录 Set ID = a_Rownum(I) + n_Count Where ID = a_Id_Temp(I);
  --部分数据修正
  Update 疾病编码目录
  Set 性别限制 = '男'
  Where (Substr(编码, 1, 5) = 'B26.0' Or (Substr(编码, 1, 3) Between 'C60' And 'C63') Or
        (Substr(编码, 1, 5) Between 'D07.4' And 'D07.6') Or Substr(编码, 1, 5) = 'D17.6' Or Substr(编码, 1, 3) = 'D29' Or
        Substr(编码, 1, 3) = 'D40' Or Substr(编码, 1, 3) = 'E29' Or Substr(编码, 1, 5) = 'E89.5' Or
        Substr(编码, 1, 5) = 'F52.4' Or Substr(编码, 1, 5) = 'I86.1' Or Substr(编码, 1, 5) = 'L29.1' Or
        (Substr(编码, 1, 3) Between 'N40' And 'N51') Or (Substr(编码, 1, 3) Between 'Q53' And 'Q55') Or
        Substr(编码, 1, 3) = 'R86' Or (Substr(编码, 1, 5) Between 'S31.2' And 'S31.3') Or Substr(编码, 1, 5) = 'Z12.5') And
        建档时间 = 建档时间_In;

  Update 疾病编码目录
  Set 性别限制 = '女'
  Where (Substr(编码, 1, 3) = 'A34' Or Substr(编码, 1, 5) = 'B37.3' Or (Substr(编码, 1, 3) Between 'C51' And 'C58') Or
        Substr(编码, 1, 5) = 'C79.6' Or Substr(编码, 1, 3) = 'D06' Or (Substr(编码, 1, 5) Between 'D07.0' And 'D07.3') Or
        (Substr(编码, 1, 3) Between 'D25' And 'D28') Or Substr(编码, 1, 3) = 'D39' Or Substr(编码, 1, 3) = 'E28' Or
        Substr(编码, 1, 5) = 'E89.4' Or Substr(编码, 1, 5) = 'F52.5' Or Substr(编码, 1, 3) = 'F53' Or
        Substr(编码, 1, 5) = 'I86.3' Or Substr(编码, 1, 5) = 'L29.2' Or Substr(编码, 1, 5) = 'L70.5' Or
        (Substr(编码, 1, 5) Between 'M80.0' And 'M80.1') Or (Substr(编码, 1, 5) Between 'M81.0' And 'M81.1') Or
        Substr(编码, 1, 5) = 'M83.0' Or (Substr(编码, 1, 3) Between 'N70' And 'N98') Or
        (Substr(编码, 1, 5) Between 'N99.2' And 'N99.3') Or (Substr(编码, 1, 3) Between 'O00' And 'O99') Or
        Substr(编码, 1, 5) = 'P54.6' Or (Substr(编码, 1, 3) Between 'Q50' And 'Q52') Or Substr(编码, 1, 3) = 'R87' Or
        Substr(编码, 1, 5) = 'S31.4' Or (Substr(编码, 1, 5) Between 'S37.4' And 'S37.6') Or
        (Substr(编码, 1, 5) Between 'T19.2' And 'T19.3') Or Substr(编码, 1, 5) = 'T83.3' Or Substr(编码, 1, 3) = 'Y76' Or
        Substr(编码, 1, 5) = 'Z01.4' Or Substr(编码, 1, 5) = 'Z12.4' Or Substr(编码, 1, 5) = 'Z30.1' Or
        Substr(编码, 1, 5) = 'Z30.3' Or Substr(编码, 1, 5) = 'Z30.5' Or Substr(编码, 1, 5) = 'Z31.1' Or
        Substr(编码, 1, 5) = 'Z31.2' Or (Substr(编码, 1, 3) Between 'Z32' And 'Z39') Or Substr(编码, 1, 3) = 'Z39' Or
        Substr(编码, 1, 5) = 'Z43.7' Or Substr(编码, 1, 5) = 'Z87.5' Or Substr(编码, 1, 5) = 'Z97.5') And 建档时间 = 建档时间_In;

  Update 疾病编码目录
  Set 疗效限制 = '治愈'
  Where (编码 = 'I11.901' Or 编码 = 'I25.105' Or 编码 = 'I27.902' Or 编码 = 'I42.905' Or 编码 = 'G71.003' Or 编码 = 'C71.902' Or
        编码 = 'C79.301' Or 编码 = 'C22.001' Or Substr(编码, 1, 3) = 'B24' Or 编码 = 'E10.901' Or 编码 = 'E14.901') And
        建档时间 = 建档时间_In;

  Update 疾病编码目录
  Set 疗效限制 = '好转'
  Where (Substr(编码, 1, 3) = 'O80' Or Substr(编码, 1, 3) = 'O04' Or Substr(编码, 1, 3) = 'O05' Or Substr(编码, 1, 3) = 'O06' Or
        (Substr(编码, 1, 3) Between 'Z00' And 'Z99')) And 建档时间 = 建档时间_In;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_疾病编码目录_Redo;
/

--106374:余伟节,2017-06-23,疾病编码目录批量停用
Create Or Replace Procedure Zl_疾病编码分类_Stop(Id_In In 疾病编码分类.Id%Type) Is
  v_Err_Msg Varchar2(100);
  d_Curr    Date;
  Err_Item Exception;
Begin
  Select Sysdate Into d_Curr From Dual;
  Update 疾病编码分类
  Set 撤档时间 = d_Curr
  Where ID = Id_In And (撤档时间 Is Null Or 撤档时间 >= To_Date('3000-01-01', 'yyyy-mm-dd'));
  If Sql%NotFound Then
    v_Err_Msg := '[ZLSOFT]该项目已经被他人删除或停用,不能再停用![ZLSOFT]';
    Raise Err_Item;
  End If;
  --子节点分类一并停用
  Update 疾病编码分类
  Set 撤档时间 = d_Curr
  Where ID In (Select ID From 疾病编码分类 T Start With 上级id = Id_In Connect By Prior ID = 上级id) And
        (撤档时间 Is Null Or 撤档时间 >= To_Date('3000-01-01', 'yyyy-mm-dd'));
  --批量停用该分类下的疾病编码目录
  Update 疾病编码目录
  Set 撤档时间 = d_Curr
  Where (分类id In (Select ID From 疾病编码分类 Start With 上级id = Id_In Connect By Prior ID = 上级id) Or 分类id = Id_In) And
        (撤档时间 Is Null Or 撤档时间 >= To_Date('3000-01-01', 'yyyy-mm-dd'));
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_疾病编码分类_Stop;
/

--106374:余伟节,2017-06-23,疾病编码批量启用
Create Or Replace Procedure Zl_疾病编码分类_Reuse
(
  Id_In       In 疾病编码分类.Id%Type,
  撤档时间_In In 疾病编码分类.撤档时间%Type := Null
) Is
  v_Err_Msg Varchar2(100);
  Err_Item Exception;
Begin
  If 撤档时间_In Is Null Then
    Update 疾病编码分类
    Set 撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')
    Where ID = Id_In And 撤档时间 Is Not Null And 撤档时间 < To_Date('3000-01-01', 'yyyy-mm-dd');
    If Sql%NotFound Then
      v_Err_Msg := '[ZLSOFT]该项目已经被他人删除或启用,不能再启用![ZLSOFT]';
      Raise Err_Item;
    End If;
    --子节点一并处理
    Update 疾病编码分类
    Set 撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')
    Where ID In (Select ID From 疾病编码分类 Start With 上级id = Id_In Connect By Prior ID = 上级id) And
          (撤档时间 Is Not Null And 撤档时间 < To_Date('3000-01-01', 'yyyy-mm-dd'));
    --批量停用该分类下的疾病编码目录
    Update 疾病编码目录
    Set 撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')
    Where (分类id In (Select ID From 疾病编码分类 Start With 上级id = Id_In Connect By Prior ID = 上级id) Or 分类id = Id_In) And
          (撤档时间 Is Not Null And 撤档时间 < To_Date('3000-01-01', 'yyyy-mm-dd'));
  Else
    Update 疾病编码分类 Set 撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd') Where ID = Id_In And 撤档时间 = 撤档时间_In;
    If Sql%NotFound Then
      v_Err_Msg := '[ZLSOFT]该项目已经被他人删除或启用,不能再启用![ZLSOFT]';
      Raise Err_Item;
    End If;
    --子节点一并处理
    Update 疾病编码分类
    Set 撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')
    Where ID In (Select ID From 疾病编码分类 Start With 上级id = Id_In Connect By Prior ID = 上级id) And 撤档时间 = 撤档时间_In;
    --批量停用该分类下的疾病编码目录
    Update 疾病编码目录
    Set 撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')
    Where (分类id In (Select ID From 疾病编码分类 Start With 上级id = Id_In Connect By Prior ID = 上级id) Or 分类id = Id_In) And
          撤档时间 = 撤档时间_In;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_疾病编码分类_Reuse;
/

--98870:梁唐彬,2017-07-03,转病区费用问题
Create Or Replace Procedure Zl_病人变动记录_Inunit
(
  病人id_In     病案主页.病人id%Type,
  主页id_In     病案主页.主页id%Type,
  床号_In       Varchar2,
  病区id_In     病案主页.当前病区id%Type,
  护理等级id_In 病案主页.护理等级id%Type,
  当前病况_In   病案主页.当前病况%Type,
  是否陪伴_In   病案主页.是否陪伴%Type,
  责任护士_In   病案主页.责任护士%Type,
  入病区时间_In 病人变动记录.开始时间%Type,
  操作员编号_In 人员表.编号%Type,
  操作员姓名_In 人员表.姓名%Type,
  主床位_In     病案主页.出院病床%Type
) As
  -----------------------------------------------------------
  --说明：完成病人入病区处理
  --参数：
  --       床号_IN:为空表示家庭病床,否则为"床号1,床号2,...床号n",多个床号时,表示包房。
  -----------------------------------------------------------
  Cursor c_Oldinfo Is
    Select b.*
    From (Select c.*
           From 病人变动记录 c
           Where c.病人id = 病人id_In And c.主页id = 主页id_In And
                 c.开始时间 = (Select Min(开始时间)
                           From 病人变动记录
                           Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入病区时间_In)) a, 病人变动记录 b
    
    Where b.病人id = 病人id_In And b.主页id = 主页id_In And a.开始时间 = b.终止时间 And a.开始原因 = b.终止原因 And a.附加床位 = b.附加床位
    Union
    Select *
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And 开始时间 <= 入病区时间_In;
  Cursor c_Endinfo Is
    Select * From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
  Cursor c_Futureinfo Is
    Select *
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 附加床位 = 0 And 开始时间 > 入病区时间_In;
  
  Cursor c_OldAutoHLinfo Is 
        Select b.* 
    From (Select c.* 
           From 病人自动计算 C 
           Where c.病人id = 病人id_In And c.主页id = 主页id_In And C.性质 = 1 And 
                 c.开始时间 = (Select Min(开始时间) From 病人自动计算
                           Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入病区时间_In  And 性质 = 1) And
                 NVL(c.终止时间|| '','空') = (Select  NVL(Min(终止时间)|| '','空')
                           From 病人自动计算 Where 病人id = 病人id_In And 主页id = 主页id_In And 性质 = 1 And 开始时间 > 入病区时间_In)) A, 病人自动计算 B 
    Where b.病人id = 病人id_In And b.主页id = 主页id_In And a.开始时间 = b.终止时间 And a.开始原因 = b.终止原因 And B.性质 = 1 
    Union 
    Select * From 病人自动计算 Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And 开始时间 <= 入病区时间_In And 性质 = 1;   
  Cursor c_OldAutoinfo Is
    Select b.*
    From (Select c.*
           From 病人自动计算 c
           Where c.病人id = 病人id_In And c.主页id = 主页id_In And C.性质 = 2 And
                 c.开始时间 = (Select Min(开始时间)
                           From 病人自动计算
                           Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入病区时间_In And 性质 = 2)) a, 病人自动计算 b
    
    Where b.病人id = 病人id_In And b.主页id = 主页id_In And a.开始时间 = b.终止时间 And a.开始原因 = b.终止原因 And a.附加床位 = b.附加床位 And B.性质 = 2
    Union
    Select *
    From 病人自动计算
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And 开始时间 <= 入病区时间_In And 性质 = 2;
  Cursor c_FutureAutoinfo Is
    Select *
    From 病人自动计算
    Where 病人id = 病人id_In And 主页id = 主页id_In And 附加床位 = 0 And 开始时间 > 入病区时间_In And 性质 = 2;
    
  r_Futureinfo   c_Futureinfo %Rowtype;
  r_FutureAutoinfo   c_FutureAutoinfo %Rowtype;
  b_Isdel        Boolean;
  b_IsAutodel        Boolean;
  r_Endinfo      c_Endinfo%Rowtype;
  r_Oldinfo      c_Oldinfo%Rowtype;
  r_OldAutoinfo      c_OldAutoinfo%Rowtype;
  r_OldAutoHLinfo      c_OldAutoHLinfo%Rowtype;
  v_变动终止原因 病人变动记录.终止原因%Type;
  v_变动终止时间 病人变动记录.终止时间%Type;
  v_变动终止人员 病人变动记录.终止人员%Type;
  v_Auto变动终止原因 病人变动记录.终止原因%Type;
  v_Auto变动终止时间 病人变动记录.终止时间%Type;
  v_Auto变动终止人员 病人变动记录.终止人员%Type;
  v_AutoHL变动终止原因 病人变动记录.终止原因%Type;
  v_AutoHL变动终止时间 病人变动记录.终止时间%Type;
  v_AutoHL变动终止人员 病人变动记录.终止人员%Type;
  
  Cursor c_Bedinfo Is
    Select 病区id, 床号 From 床位状况记录 Where 病人id = 病人id_In;
  v_床号     Varchar2(255);
  v_当前床号 床位状况记录.床号%Type;
  v_等级id   床位状况记录.等级id%Type;
  v_病区id   病案主页.当前病区id%Type;
  v_科室id   病案主页.出院科室id%Type;
  v_终止人员 病人变动记录.终止人员%Type;
  v_Count    Number;
  Err_Custom Exception;
  v_Error Varchar2(255);
Begin
  Open c_Oldinfo; --必须先打开
  Open c_OldAutoinfo; --必须先打开
  Open c_OldAutoHLinfo; --必须先打开
  --入病区
  Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In And 状态 = 2;

  If v_Count = 0 Then
    v_Error := '病人当前不处于转病区状态,可能已经撤转病区，操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的，请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;

  Begin
    Select 病区id, 操作员姓名
    Into v_病区id, v_终止人员
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 15 And 开始时间 Is Null And 终止时间 Is Null;
  Exception
    When Others Then
      v_病区id := 0;
  End;
  --v_病区id=0说明病人可能是转科状态
  If v_病区id = 0 Then
    v_Error := '病人当前不处于转病区状态，而是处于转科状态，操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的，请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;
  If v_病区id <> 病区id_In Then
    v_Error := '当前该病人即将入住的病区和变动记录中实际要入住病区不符,操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的，请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;

  --产生新变动
  Fetch c_Oldinfo
    Into r_Oldinfo;
  Fetch c_OldAutoinfo
    Into r_OldAutoinfo;
  Fetch c_OldAutoHLinfo
    Into r_OldAutoHLinfo;
  Open c_Endinfo;
  Fetch c_Endinfo
    Into r_Endinfo;
  If c_Endinfo%Rowcount = 0 Then
    Close c_Endinfo;
    v_Error := '未发现该病人当前有效的变动记录！';
    Raise Err_Custom;
  End If;
  
  --转病区时将需要原病区执行的未执行和部分执行的医嘱发送记录转为新病区执行；
  Select 当前病区id Into v_病区id From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
  Update 病人医嘱发送 A
  Set a.执行部门id = 病区id_In
  Where a.执行部门id + 0 = v_病区id And a.医嘱id In (Select ID From 病人医嘱记录 Where 病人id = 病人id_In And 主页id = 主页id_In)
        And A.执行状态 In(0,3);
        
  --病案主页
  Update 病案主页
  Set 状态 = 0, 出院病床 = Decode(床号_In, Null, Null, 主床位_In), 当前病区id = 病区id_In,
      护理等级id = Decode(护理等级id_In, 0, Null, 护理等级id_In), 当前病况 = 当前病况_In, 责任护士 = 责任护士_In, 是否陪伴 = 是否陪伴_In
  Where 病人id = 病人id_In And 主页id = 主页id_In;

  --更新病人信息
  Update 病人信息
  Set 当前病区id = 病区id_In, 当前床号 = Decode(床号_In, Null, Null, 主床位_In)
  Where 病人id = 病人id_In;

  --更新在院病人
  v_科室id := 0;
  Begin
    Update 在院病人 Set 病区id = Nvl(病区id_In, 0) Where 病人id = 病人id_In;
    If Sql%Rowcount = 0 Then
      Select 出院科室id Into v_科室id From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
    End If;
  Exception
    When Others Then
      v_科室id := 0;
  End;
  If v_科室id > 0 Then
    Insert Into 在院病人 (病人id, 科室id, 病区id,主页ID) Values (病人id_In, v_科室id, Nvl(病区id_In, 0),nvl(主页ID_In,0));
  End If;

  --退除病人当前床位
  For r_Bedrow In c_Bedinfo Loop
    Update 床位状况记录
    Set 状态 = '空床', 病人id = Null, 科室id = Decode(共用, 1, Null, 科室id)
    Where 病区id = r_Bedrow.病区id And 床号 = r_Bedrow.床号;
  End Loop;

  --记录上一步的终止操作人员
  If r_Oldinfo.终止时间 Is Not Null Then
    v_变动终止时间 := r_Oldinfo.终止时间;
    v_变动终止原因 := r_Oldinfo.终止原因;
    v_变动终止人员 := r_Oldinfo.终止人员;
    --取消上次变动
    Update 病人变动记录
    Set 终止时间 = 入病区时间_In, 终止原因 = 15, 终止人员 = v_终止人员, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_变动终止时间 And 终止原因 = v_变动终止原因;
    --更新将来的记录如果有停止到将来的则删除上次计算时间
    Update 病人变动记录
    Set 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入病区时间_In;
  Else
    Update 病人变动记录
    Set 终止时间 = 入病区时间_In, 终止原因 = 15, 终止人员 = v_终止人员,
        上次计算时间 = Decode(Sign(Nvl(上次计算时间, 入病区时间_In) - 入病区时间_In), 1, Null, 上次计算时间)
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 Is Not Null And 终止时间 Is Null;
  End If;

  Delete From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 15 And 开始时间 Is Null And 终止时间 Is Null;
  
  If r_OldAutoinfo.终止时间 Is Not Null Then
    v_Auto变动终止时间 := r_OldAutoinfo.终止时间;
    v_Auto变动终止原因 := r_OldAutoinfo.终止原因;
    v_Auto变动终止人员 := r_OldAutoinfo.终止人员;
    --取消上次变动
    Update 病人自动计算
    Set 终止时间 = 入病区时间_In, 终止原因 = 15, 终止人员 = v_终止人员, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_Auto变动终止时间 And 终止原因 = v_Auto变动终止原因 and 性质 IN(2,3);
    --更新将来的记录如果有停止到将来的则删除上次计算时间
    Update 病人自动计算
    Set 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入病区时间_In  and 性质 IN(2,3);
  Else
    Update 病人自动计算
    Set 终止时间 = 入病区时间_In, 终止原因 = 15, 终止人员 = v_终止人员,
        上次计算时间 = Decode(Sign(Nvl(上次计算时间, 入病区时间_In) - 入病区时间_In), 1, Null, 上次计算时间)
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 Is Not Null And 终止时间 Is Null  and 性质 IN(2,3);
  End If;
    
  If r_OldAutoHLinfo.终止时间 Is Not Null Then
    v_AutoHL变动终止时间 := r_OldAutoHLinfo.终止时间;
    v_AutoHL变动终止原因 := r_OldAutoHLinfo.终止原因;
    v_AutoHL变动终止人员 := r_OldAutoHLinfo.终止人员;
    --取消上次变动
    Update 病人自动计算
    Set 终止时间 = 入病区时间_In, 终止原因 = 15, 终止人员 = v_终止人员, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_AutoHL变动终止时间 And 终止原因 = v_AutoHL变动终止原因  and 性质 = 1;
    --更新将来的记录如果有停止到将来的则删除上次计算时间
    Update 病人自动计算
    Set 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入病区时间_In  and 性质 = 1;
  Else
    Update 病人自动计算
    Set 终止时间 = 入病区时间_In, 终止原因 = 15, 终止人员 = v_终止人员,
        上次计算时间 = Decode(Sign(Nvl(上次计算时间, 入病区时间_In) - 入病区时间_In), 1, Null, 上次计算时间)
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 Is Not Null And 终止时间 Is Null  and 性质 = 1;
  End If;
  --护理等级变动
  Insert Into 病人自动计算
    (ID, 病人id, 主页id, 开始时间, 开始原因, 性质, 病区id, 科室id, 护理等级id, 操作员编号,
     操作员姓名, 终止时间, 终止原因, 终止人员)
  Values
    (病人自动计算_Id.Nextval, 病人id_In, 主页id_In, 入病区时间_In, 15, 1, 病区id_In, r_OldAutoHLinfo.科室ID,
     Decode(护理等级id_In, 0, Null, 护理等级id_In), 操作员编号_In,操作员姓名_In, v_AutoHL变动终止时间, v_AutoHL变动终止原因, v_AutoHL变动终止人员);
      
  --新的床位记录
  If 床号_In Is Null Then
    --仅家庭病床
    Insert Into 病人变动记录
      (Id, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号,
       操作员姓名, 终止时间, 终止原因, 终止人员)
    Values
      (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, 入病区时间_In, 15, 0, 病区id_In, r_Oldinfo.科室id, r_Oldinfo.医疗小组id,
       Decode(护理等级id_In, 0, Null, 护理等级id_In), Null, Null, 责任护士_In, r_Oldinfo.经治医师, r_Oldinfo.主治医师, r_Oldinfo.主任医师,
       当前病况_In, 操作员编号_In, 操作员姓名_In, v_变动终止时间, v_变动终止原因, v_变动终止人员);
    --如果修改了床位，则必须修改停止到将来的变动数
    If c_Oldinfo%Rowcount <> 1 Then
      --删除所有将来的附加床位的变动
      Delete From 病人变动记录
      Where 病人id = 病人id_In And 主页id = 主页id_In And 附加床位 = 1 And 开始时间 > 入病区时间_In;
    End If;
    --如果有停到将来的情况，将将来的变动信息同步更新(附加床位和主床位记录不相同的字段。)
    Update 病人变动记录
    Set 床位等级id = Null, 床号 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入病区时间_In;
    
    Insert Into 病人自动计算
      (ID, 病人id, 主页id, 开始时间, 开始原因, 性质, 附加床位, 病区id, 科室id, 床位等级id, 床号, 操作员编号,
       操作员姓名, 终止时间, 终止原因, 终止人员)
    Values
      (病人自动计算_Id.Nextval, 病人id_In, 主页id_In, 入病区时间_In, 15, 2, 0, 病区id_In, r_OldAutoinfo.科室ID, 
       Null, Null, 操作员编号_In,操作员姓名_In, v_Auto变动终止时间, v_Auto变动终止原因, v_Auto变动终止人员);
    Insert Into 病人自动计算
      (ID, 病人id, 主页id, 开始时间, 开始原因, 性质, 附加床位, 病区id, 科室id, 床位等级id, 床号, 操作员编号,
       操作员姓名, 终止时间, 终止原因, 终止人员)
    Values
      (病人自动计算_Id.Nextval, 病人id_In, 主页id_In, 入病区时间_In, 15, 3, 0, 病区id_In, r_OldAutoinfo.科室ID, 
       Null, Null, 操作员编号_In,操作员姓名_In, v_Auto变动终止时间, v_Auto变动终止原因, v_Auto变动终止人员);
         
    --如果修改了床位，则必须修改停止到将来的变动数
    If c_OldAutoinfo%Rowcount <> 1 Then
      --删除所有将来的附加床位的变动
      Delete From 病人自动计算
      Where 病人id = 病人id_In And 主页id = 主页id_In And 附加床位 = 1 And 开始时间 > 入病区时间_In And 性质 In(2,3);
    End If;
      
    --如果有停到将来的情况，将将来的变动信息同步更新(附加床位和主床位记录不相同的字段。)
    Update 病人自动计算
    Set 床位等级id = Null, 床号 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入病区时间_In And 性质 In(2,3);
  Else
    v_床号  := 床号_In || ',';
    v_Count := 0;
    While v_床号 Is Not Null Loop
      v_Count := v_Count + 1;
      v_床号  := Substr(v_床号, Instr(v_床号, ',') + 1);
    End Loop;
    --如果修改了床位，则必须修改停止到将来的变动数
    b_Isdel := False;
    If c_Oldinfo%Rowcount <> v_Count Then
      --删除所有将来的附加床位的变动
      Delete From 病人变动记录
      Where 病人id = 病人id_In And 主页id = 主页id_In And 附加床位 = 1 And 开始时间 > 入病区时间_In;
      b_Isdel := True;
    End If;
    
    b_IsAutodel := False;
    If c_OldAutoinfo%Rowcount <> v_Count Then
      --删除所有将来的附加床位的变动
      Delete From 病人自动计算
      Where 病人id = 病人id_In And 主页id = 主页id_In And 附加床位 = 1 And 开始时间 > 入病区时间_In And 性质 In(2,3);
      b_IsAutodel := True;
    End If;
      
    v_Count := 0;
    v_床号  := 床号_In || ',';
  
    While v_床号 Is Not Null Loop
      v_当前床号 := Substr(v_床号, 1, Instr(v_床号, ',') - 1);
      Select 等级id Into v_等级id From 床位状况记录 Where 病区id = 病区id_In And 床号 = v_当前床号;
    
      Insert Into 病人变动记录
        (Id, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号,
         操作员姓名, 终止时间, 终止原因, 终止人员)
      Values
        (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, 入病区时间_In, 15, Decode(主床位_In, v_当前床号, 0, 1), 病区id_In, r_Oldinfo.科室id,
         r_Oldinfo.医疗小组id, Decode(护理等级id_In, 0, Null, 护理等级id_In), v_等级id, v_当前床号, 责任护士_In, r_Oldinfo.经治医师,
         r_Oldinfo.主治医师, r_Oldinfo.主任医师, 当前病况_In, 操作员编号_In, 操作员姓名_In, v_变动终止时间, v_变动终止原因, v_变动终止人员);
      Insert Into 病人自动计算
        (ID, 病人id, 主页id, 开始时间, 开始原因, 性质, 附加床位, 病区id, 科室id, 床位等级id, 床号, 操作员编号,
         操作员姓名, 终止时间, 终止原因, 终止人员)
      Values
        (病人自动计算_Id.Nextval, 病人id_In, 主页id_In, 入病区时间_In, 15, 2, Decode(主床位_In, v_当前床号, 0, 1), 病区id_In, r_OldAutoinfo.科室ID,
         v_等级id, v_当前床号, 操作员编号_In, 操作员姓名_In, v_Auto变动终止时间, v_Auto变动终止原因, v_Auto变动终止人员);
      Insert Into 病人自动计算
        (ID, 病人id, 主页id, 开始时间, 开始原因, 性质, 附加床位, 病区id, 科室id, 床位等级id, 床号, 操作员编号,
         操作员姓名, 终止时间, 终止原因, 终止人员)
      Values
        (病人自动计算_Id.Nextval, 病人id_In, 主页id_In, 入病区时间_In, 15, 3, Decode(主床位_In, v_当前床号, 0, 1), 病区id_In, r_OldAutoinfo.科室ID,
         v_等级id, v_当前床号, 操作员编号_In, 操作员姓名_In, v_Auto变动终止时间, v_Auto变动终止原因, v_Auto变动终止人员);
           
      Select Count(*) Into v_Count From 床位状况记录 Where 病区id = 病区id_In And 床号 = v_当前床号 And 状态 = '空床';
    
      If v_Count = 0 Then
        v_Error := '操作失败,床位 ' || v_当前床号 || ' 不是空床！';
        Raise Err_Custom;
      End If;
    
      Update 床位状况记录
      Set 状态 = '占用', 病人id = 病人id_In, 科室id = Decode(共用, 1, r_Oldinfo.科室id, 科室id)
      Where 病区id = 病区id_In And 床号 = v_当前床号;
    
      If b_Isdel = True Then
        --如果有停到将来的情况且有床位数变动,将将来的变动信息同步更新(附加床位和主床位记录不相同的字段。)和插入附加床位数据。
        If 主床位_In = v_当前床号 Then
          --如果是主床位则修改将来的主记录信息，如果不是主床位，就新插入数据
          Update 病人变动记录
          Set 床位等级id = v_等级id, 床号 = v_当前床号
          Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入病区时间_In And 附加床位 = 0;
        Else
          Open c_Futureinfo; --必须先打开
          Fetch c_Futureinfo
            Into r_Futureinfo;
          --循环停到将来的数据，进行附加床位插入
          While c_Futureinfo%Found Loop
            Insert Into 病人变动记录
              (Id, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 科室id, 医疗小组id, 床位等级id, 床号, 经治医师, 主治医师, 主任医师, 操作员编号, 操作员姓名, 终止时间, 终止原因,
               终止人员)
            Values
              (病人变动记录_Id.Nextval, r_Futureinfo.病人id, r_Futureinfo.主页id, r_Futureinfo.开始时间, r_Futureinfo.开始原因, 1,
               r_Futureinfo.科室id, r_Futureinfo.医疗小组id, v_等级id, v_当前床号, r_Futureinfo.经治医师, r_Futureinfo.主治医师,
               r_Futureinfo.主任医师, r_Futureinfo.操作员编号, r_Futureinfo.操作员姓名, r_Futureinfo.终止时间, r_Futureinfo.终止原因,
               r_Futureinfo.终止人员);
            Fetch c_Futureinfo
              Into r_Futureinfo;
          End Loop;
          Close c_Futureinfo;
        End If;
      End If;
      --病人自动计算所需数据
      If b_IsAutodel = True Then
        --如果有停到将来的情况且有床位数变动,将将来的变动信息同步更新(附加床位和主床位记录不相同的字段。)和插入附加床位数据。
        If 主床位_In = v_当前床号 Then
          --如果是主床位则修改将来的主记录信息，如果不是主床位，就新插入数据
          Update 病人自动计算
          Set 床位等级id = v_等级id, 床号 = v_当前床号
          Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入病区时间_In And 附加床位 = 0 And 性质 In(2,3);
        Else
          Open c_FutureAutoinfo; --必须先打开
          Fetch c_FutureAutoinfo
            Into r_FutureAutoinfo;
          --循环停到将来的数据，进行附加床位插入
          While c_FutureAutoinfo%Found Loop
            Insert Into 病人自动计算
              (ID, 病人id, 主页id, 开始时间, 开始原因, 性质, 附加床位, 床位等级id, 床号, 操作员编号, 操作员姓名, 终止时间, 终止原因, 终止人员)
            Values
              (病人自动计算_Id.Nextval, r_FutureAutoinfo.病人id, r_FutureAutoinfo.主页id, r_FutureAutoinfo.开始时间, r_FutureAutoinfo.开始原因, 2, 1,
               v_等级id, v_当前床号, r_FutureAutoinfo.操作员编号, r_FutureAutoinfo.操作员姓名, r_FutureAutoinfo.终止时间, r_FutureAutoinfo.终止原因,
               r_FutureAutoinfo.终止人员);
            Insert Into 病人自动计算
              (ID, 病人id, 主页id, 开始时间, 开始原因, 性质, 附加床位, 床位等级id, 床号, 操作员编号, 操作员姓名, 终止时间, 终止原因, 终止人员)
            Values
              (病人自动计算_Id.Nextval, r_FutureAutoinfo.病人id, r_FutureAutoinfo.主页id, r_FutureAutoinfo.开始时间, r_FutureAutoinfo.开始原因, 3, 1,
               v_等级id, v_当前床号, r_FutureAutoinfo.操作员编号, r_FutureAutoinfo.操作员姓名, r_FutureAutoinfo.终止时间, r_FutureAutoinfo.终止原因,
               r_FutureAutoinfo.终止人员);
            Fetch c_FutureAutoinfo
              Into r_FutureAutoinfo;
          End Loop;
          Close c_FutureAutoinfo;
        End If;
      End If;
    
      v_床号  := Substr(v_床号, Instr(v_床号, ',') + 1);
      v_Count := v_Count + 1;
    End Loop;
  End If;
  --如果有停到将来的情况，将将来的变动信息同步更新（附加床位的记录和主记录相同的字段）
  Update 病人变动记录
  Set 病区id = 病区id_In, 责任护士 = 责任护士_In, 护理等级id = Decode(护理等级id_In, 0, Null, 护理等级id_In), 病情 = 当前病况_In
  Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入病区时间_In;
  Update 病人自动计算
  Set 病区id = 病区id_In, 护理等级id = Decode(护理等级id_In, 0, Null, 护理等级id_In)
  Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入病区时间_In;
  Close c_Oldinfo;
  Close c_OldAutoinfo;
  Close c_OldAutoHLinfo;
  Close c_Endinfo;
  --对有效的医嘱(未停止、作废的长嘱，未发送的临嘱)，为原病区执行的，将执行科室自动更换为新的病区
  Update 病人医嘱记录
  Set 执行科室id = 病区id_In
  Where 病人id = 病人id_In And 主页id = 主页id_In And 执行科室id = r_Oldinfo.病区id And 医嘱状态 Not In (4, 8, 9);

  --并发操作检查
  Select Count(*)
  Into v_Count
  From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(附加床位, 0) = 0 And 开始时间 Is Not Null And 终止时间 Is Null;

  If v_Count > 1 Then
    v_Error := '发现病人存在非法的变动记录,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人变动记录_Inunit;
/

--98870:梁唐彬,2017-06-21,转病区费用问题
CREATE OR REPLACE Procedure Zl_病人医嘱执行_Update
( 
  原执行时间_In 病人医嘱执行.执行时间%Type, 
  医嘱id_In     病人医嘱执行.医嘱id%Type, 
  发送号_In     病人医嘱执行.发送号%Type, 
  要求时间_In   病人医嘱执行.要求时间%Type, 
  本次数次_In   病人医嘱执行.本次数次%Type, 
  执行摘要_In   病人医嘱执行.执行摘要%Type, 
  执行人_In     病人医嘱执行.执行人%Type, 
  执行时间_In   病人医嘱执行.执行时间%Type, 
  执行结果_In   病人医嘱执行.执行结果%Type := 1, 
  未执行原因_In 病人医嘱执行.说明%Type := Null, 
  单独执行_In   Number := 0, 
  操作员编号_In 人员表.编号%Type := Null, 
  操作员姓名_In 人员表.姓名%Type := Null, 
  执行部门id_In 门诊费用记录.执行部门id%Type := 0 
  --参数：医嘱ID_IN=单独执行的医嘱ID，检验组合为显示的检验项目的ID。 
  --执行部门id_In=仅处理指定执行部门的费用，不传或传入0时不限制执行部门 
) Is 
  --除了要执行的主记录,还包含了附加手术,检查部位的记录 
  --手术麻醉,中药煎法,采集方法单独控制,检验组合只填写在第一个项目上，但执行状态相同 
  V_Temp     Varchar2(255); 
  V_人员编号 人员表.编号%Type; 
  V_人员姓名 人员表.姓名%Type; 
 
  V_组id        病人医嘱记录.Id%Type; 
  V_诊疗类别    病人医嘱记录.诊疗类别%Type; 
  V_执行结果old 病人医嘱执行.执行结果%Type; 
  N_本次数次old 病人医嘱执行.本次数次%Type; 
 
  V_病人来源 病人医嘱记录.病人来源%Type; 
  V_费用性质 病人医嘱发送.记录性质%Type; 
 
  N_执行次数 Number; 
  N_剩余次数 Number; 
  N_执行状态 Number; 
  n_发送数次 Number;
  n_单次数次 Number;
  v_Count    Number;
  n_登记数次 Number;
  d_要求时间 date;
  
  D_登记时间 病人医嘱执行.登记时间%Type; 
  N_取消执行 Number; 
  N_Diffday  Number(18, 3); 
  n_执行科室ID Number;
 
  V_Date  Date; 
  V_Error Varchar2(255); 
  Err_Custom Exception; 
Begin 
  --当前操作人员 
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then 
    V_人员编号 := 操作员编号_In; 
    V_人员姓名 := 操作员姓名_In; 
  Else 
    V_Temp     := Zl_Identity; 
    V_Temp     := Substr(V_Temp, Instr(V_Temp, ';') + 1); 
    V_Temp     := Substr(V_Temp, Instr(V_Temp, ',') + 1); 
    V_人员编号 := Substr(V_Temp, 1, Instr(V_Temp, ',') - 1); 
    V_人员姓名 := Substr(V_Temp, Instr(V_Temp, ',') + 1); 
  End If; 
 
  Select Sysdate Into V_Date From Dual; 
  Select Nvl(执行结果, 1), Nvl(本次数次, 0), 登记时间 
  Into V_执行结果old, N_本次数次old, D_登记时间 
  From 病人医嘱执行 
  Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In And 执行时间 = 原执行时间_In; 
  -----取消执行有效天数限制 
  Select Zl_To_Number(Nvl(zl_GetSysParameter(220), '999')) Into N_取消执行 From Dual; 
  Select V_Date - D_登记时间 Into N_Diffday From Dual; 
  --登记时间超过取消执行天数的记录，不允许修改医嘱执行情况 
  If N_Diffday > N_取消执行 Then 
    V_Error := '医嘱执行登记时间超过了取消执行有效天数，不能修改医嘱执行情况！'; 
    Raise Err_Custom; 
  End If; 
  Select 执行部门id Into n_执行科室id From 病人医嘱发送 Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In;
  --病人医嘱执行 
  Update 病人医嘱执行 
  Set 要求时间 = 要求时间_In, 本次数次 = 本次数次_In, 执行摘要 = 执行摘要_In, 执行人 = 执行人_In, 执行时间 = 执行时间_In, 登记时间 = V_Date, 登记人 = V_人员姓名, 
      执行结果 = 执行结果_In, 说明 = 未执行原因_In, 执行科室id = n_执行科室id
  Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In And 执行时间 = 原执行时间_In; 
  --本次执行次数或这执行结果修改后需要更新单据的执行状态 
  If V_执行结果old <> 执行结果_In Or N_本次数次old <> 本次数次_In Then 
    Select 病人来源, Nvl(相关id, ID), 诊疗类别 
    Into V_病人来源, V_组id, V_诊疗类别 
    From 病人医嘱记录 
    Where ID = 医嘱id_In; 
 
    If v_病人来源 = 2 Then 
      Select Decode(记录性质, 1, 1, Decode(门诊记帐, 1, 1, 2)) 
      Into v_费用性质 
      From 病人医嘱发送 
      Where 发送号 = 发送号_In And 医嘱id = 医嘱id_In; 
    Else 
      v_费用性质 := 1; 
    End If; 
   
    Select Decode(a.执行状态, 1, a.发送数次, c.登记次数), Decode(a.执行状态, 1, 0, a.发送数次 - c.登记次数) ,A.发送数次,C.登记次数
    Into n_执行次数, n_剩余次数 ,n_发送数次,n_登记数次
    From 病人医嘱发送 A, 
         (Select 医嘱id_In 医嘱id, 发送号_In 发送号, Nvl(Sum(b.本次数次), 0) As 登记次数 
           From 病人医嘱执行 B 
           Where b.医嘱id = 医嘱id_In And b.发送号 = 发送号_In And Nvl(b.执行结果, 1) <> 0) C 
    Where a.医嘱id = c.医嘱id And a.发送号 = c.发送号 And a.医嘱id = 医嘱id_In And a.发送号 = 发送号_In; 
   
    --如果全部执行则状态为1，未执行状态为0，部分执行状态为2 
    Select Decode(N_剩余次数, 0, 1, Decode(N_执行次数, 0, 0, 2)) Into N_执行状态 From Dual; 
    
    --更新医嘱执行计价.执行状态
    If n_发送数次 > 0 Then
      Select Count(distinct 要求时间) Into v_Count From 医嘱执行计价 Where 医嘱ID = 医嘱ID_IN And 发送号 = 发送号_IN;
      If v_Count > 0 Then
        n_单次数次 := n_发送数次 / v_Count;
        --已执行数量+本次数次 总共能够执行多少个时间点,取最大整数
        v_Count := ceil((n_登记数次 ) / n_单次数次);
		If n_登记数次 = 0 Then
			Update 医嘱执行计价 Set 执行状态 = 0 Where 医嘱id = 医嘱ID_IN And 发送号 = 发送号_IN And NVL(执行状态,0) <> 2;
		Else
	        --获取执行截至要求时间 
	        Select 要求时间 Into d_要求时间
	        From (Select 要求时间, Rownum As 次数
	               From (Select Distinct 要求时间 From 医嘱执行计价 Where 医嘱id = 医嘱ID_IN And 发送号 = 发送号_IN Order By 要求时间))
	        Where 次数 = v_Count;
	        
	        If Not d_要求时间 Is Null Then
	          --先检查是否已经退费
	          Select Max(NVL(执行状态,0)) Into v_Count From 医嘱执行计价 Where 医嘱id = 医嘱ID_IN And 发送号 = 发送号_IN And 要求时间 <= d_要求时间;
	          If v_Count = 2 Then
	            v_Error := '您指定的执行时间段的医嘱费用已经被退费，不允许再执行。'; 
	            Raise Err_Custom; 
	          End If;
	          --更新截至要求时间之前(含)的记录执行状态；
	          Update 医嘱执行计价 Set 执行状态 = 1 Where 医嘱id = 医嘱ID_IN And 发送号 = 发送号_IN And 要求时间 <= d_要求时间 And NVL(执行状态,0) <> 2;
	          Update 医嘱执行计价 Set 执行状态 = 0 Where 医嘱id = 医嘱ID_IN And 发送号 = 发送号_IN And 要求时间 > d_要求时间 And NVL(执行状态,0) <> 2;
	        End If;
		End If;
      End If;
    End If;
 
    --执行次数不为0就标记为正在执行 
    If Nvl(单独执行_In, 0) = 1 Then 
      Update 病人医嘱发送 
      Set 执行状态 = Decode(N_执行次数, 0, 0, 3), 完成人 = Null, 完成时间 = Null 
      Where 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In; 
    Else 
      Update 病人医嘱发送 
      Set 执行状态 = Decode(N_执行次数, 0, 0, 3), 完成人 = Null, 完成时间 = Null 
      Where 执行状态 In (0, 3) And 发送号 + 0 = 发送号_In And 
            医嘱id In (Select ID From 病人医嘱记录 Where (ID = V_组id Or 相关id = V_组id) And 诊疗类别 = V_诊疗类别); 
    End If; 
 
    If V_费用性质 = 2 Then 
      If Nvl(单独执行_In, 0) = 1 Then 
        Update 住院费用记录 A 
        Set 执行状态 = N_执行状态, 执行人 = Decode(N_执行状态, 0, Null, 执行人_In), 执行时间 = Decode(N_执行状态, 0, Null, 执行时间_In) 
        Where 收费类别 Not In ('5', '6', '7') And (执行部门id_In = 0 Or A.执行部门id = 执行部门id_In) And Not Exists 
         (Select 1 From 材料特性 Where 材料id = A.收费细目id And 跟踪在用 = 1) And A.记录状态 In (0, 1, 3) And 
              (医嘱序号, NO, 记录性质) In 
              (Select 医嘱id, NO, 记录性质 
               From 病人医嘱发送 
               Where 执行状态 = Decode(N_执行次数, 0, 0, 3) And 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In); 
      Else 
        Update 住院费用记录 A 
        Set 执行状态 = N_执行状态, 执行人 = Decode(N_执行状态, 0, Null, 执行人_In), 执行时间 = Decode(N_执行状态, 0, Null, 执行时间_In) 
        Where 收费类别 Not In ('5', '6', '7') And (执行部门id_In = 0 Or A.执行部门id = 执行部门id_In) And Not Exists 
         (Select 1 From 材料特性 Where 材料id = A.收费细目id And 跟踪在用 = 1) And A.记录状态 In (0, 1, 3) And 
              (医嘱序号, NO, 记录性质) In 
              (Select 医嘱id, NO, 记录性质 
               From 病人医嘱发送 
               Where 执行状态 = Decode(N_执行次数, 0, 0, 3) And 发送号 + 0 = 发送号_In And 
                     医嘱id In 
                     (Select ID From 病人医嘱记录 Where (ID = V_组id Or 相关id = V_组id) And 诊疗类别 = V_诊疗类别)); 
      End If; 
    Else 
      If Nvl(单独执行_In, 0) = 1 Then 
        Update 门诊费用记录 A 
        Set 执行状态 = N_执行状态, 执行人 = Decode(N_执行状态, 0, Null, 执行人_In), 执行时间 = Decode(N_执行状态, 0, Null, 执行时间_In) 
        Where 收费类别 Not In ('5', '6', '7') And (执行部门id_In = 0 Or A.执行部门id = 执行部门id_In) And Not Exists 
         (Select 1 From 材料特性 Where 材料id = A.收费细目id And 跟踪在用 = 1) And A.记录状态 In (0, 1, 3) And 
              (医嘱序号, NO, 记录性质) In 
              (Select 医嘱id, NO, 记录性质 
               From 病人医嘱发送 
               Where 执行状态 = Decode(N_执行次数, 0, 0, 3) And 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In); 
      Else 
        Update 门诊费用记录 A 
        Set 执行状态 = N_执行状态, 执行人 = Decode(N_执行状态, 0, Null, 执行人_In), 执行时间 = Decode(N_执行状态, 0, Null, 执行时间_In) 
        Where 收费类别 Not In ('5', '6', '7') And (执行部门id_In = 0 Or A.执行部门id = 执行部门id_In) And Not Exists 
         (Select 1 From 材料特性 Where 材料id = A.收费细目id And 跟踪在用 = 1) And A.记录状态 In (0, 1, 3) And 
              (医嘱序号, NO, 记录性质) In 
              (Select 医嘱id, NO, 记录性质 
               From 病人医嘱发送 
               Where 执行状态 = Decode(N_执行次数, 0, 0, 3) And 发送号 + 0 = 发送号_In And 
                     医嘱id In 
                     (Select ID From 病人医嘱记录 Where (ID = V_组id Or 相关id = V_组id) And 诊疗类别 = V_诊疗类别)); 
      End If; 
    End If; 
  End If; 
Exception 
  When Err_Custom Then 
    Raise_Application_Error(-20101, '[ZLSOFT]' || V_Error || '[ZLSOFT]'); 
  When Others Then 
    zl_ErrorCenter(SQLCode, SQLErrM); 
End Zl_病人医嘱执行_Update;
/

--98870:梁唐彬,2017-06-21,转病区费用问题
CREATE OR REPLACE Procedure Zl_病人医嘱执行_Insert
( 
  医嘱id_In       病人医嘱执行.医嘱id%Type, 
  发送号_In       病人医嘱执行.发送号%Type, 
  要求时间_In     病人医嘱执行.要求时间%Type, 
  本次数次_In     病人医嘱执行.本次数次%Type, 
  执行摘要_In     病人医嘱执行.执行摘要%Type, 
  执行人_In       病人医嘱执行.执行人%Type, 
  执行时间_In     病人医嘱执行.执行时间%Type, 
  单独执行_In     Number := 0, 
  自动完成_In     Number := 0, 
  执行结果_In     病人医嘱执行.执行结果%Type := 1, 
  未执行原因_In   病人医嘱执行.说明%Type := Null, 
  操作员编号_In   人员表.编号%Type := Null, 
  操作员姓名_In   人员表.姓名%Type := Null, 
  执行部门id_In   门诊费用记录.执行部门id%Type := 0, 
  配液检查_In     Number := 0, 
  检验项目记帐_In Number := 0, 
  输液通道_In     病人医嘱执行.输液通道%Type := Null 
  --参数：医嘱ID_IN=单独执行的医嘱ID，检验组合为显示的检验项目的ID。 
  --      执行结果_In=1- 完成   =0  -未执行 
  --      如果是台式机调用 操作员编号_In 操作员姓名_In 这两个参数必须传入 
  --执行部门id_In=仅处理指定执行部门的费用，不传或传入0时不限制执行部门 
  --配液检查_In=移动工作站调用时，是否检查配液信息。 
  --检验项目记帐_In=如果是检验项目时，需要记帐但不完成医嘱发送状态 
) Is 
  --除了要执行的主记录,还包含了附加手术,检查部位的记录 
  --手术麻醉,中药煎法,采集方法单独控制,检验组合只填写在第一个项目上，但执行状态相同 
  v_组id     病人医嘱记录.Id%Type; 
  v_诊疗类别 病人医嘱记录.诊疗类别%Type; 
  v_自动完成 Number; 
  v_病人来源 病人医嘱记录.病人来源%Type; 
  v_费用性质 病人医嘱发送.记录性质%Type; 
  v_操作类型 诊疗项目目录.操作类型%Type; 
  v_病区id   病案主页.当前病区id%Type; 
  v_配液病区 Varchar2(200); 
  v_Count    Number; 
  v_Temp     Varchar2(255); 
  v_人员编号 人员表.编号%Type; 
  v_人员姓名 人员表.姓名%Type; 
  n_期效     病人医嘱记录.医嘱期效%Type; 
 
  n_执行次数 Number; 
  n_剩余次数 Number; 
  n_执行状态 Number; 
  d_终止时间 Date; 
  d_开始时间 Date; 
  n_发送数次 Number;
  n_登记数次 Number;
  n_单次数次 Number;
  d_要求时间 Date;
  n_执行科室ID Number;
 
  v_Date  Date; 
  v_Error Varchar2(255); 
  Err_Custom Exception; 
Begin 
  --并发查检，防止产生多条执行记录 
  Begin 
    Select (a.发送数次 - c.登记次数) As 剩余数次 ,a.发送数次,A.执行部门ID
    Into v_Count ,n_发送数次,n_执行科室ID
    From 病人医嘱发送 A, 
         (Select 医嘱id_In As 医嘱id, 发送号_In As 发送号, Nvl(Sum(b.本次数次), 0) As 登记次数 
           From 病人医嘱执行 B 
           Where b.医嘱id = 医嘱id_In And b.发送号 = 发送号_In) C 
    Where a.医嘱id = c.医嘱id And a.发送号 = c.发送号 And a.医嘱id = 医嘱id_In And a.发送号 = 发送号_In; 
  Exception 
    When Others Then 
      v_Count := 本次数次_In; 
  End; 
  If 本次数次_In > v_Count Then 
    v_Error := '由于并发操作可能已经被他人登记，请刷新后再试。'; 
    Raise Err_Custom; 
  End If; 
  --当前操作人员 
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then 
    v_人员编号 := 操作员编号_In; 
    v_人员姓名 := 操作员姓名_In; 
  Else 
    Begin 
      Select 姓名, 编号 Into v_人员姓名, v_人员编号 From 人员表 Where 姓名 = 执行人_In; 
    Exception 
      When Others Then 
        v_Temp     := Zl_Identity; 
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1); 
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1); 
        v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1); 
        v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1); 
    End; 
  End If; 
  --对医嘱终止时间进行检查 
  Select a.执行终止时间, a.开始执行时间, a.医嘱期效 
  Into d_终止时间, d_开始时间, n_期效 
  From 病人医嘱记录 A 
  Where a.Id = 医嘱id_In; 
  If Not d_终止时间 Is Null And n_期效 = 0 Then 
    If 要求时间_In > d_终止时间 Then 
      v_Error := '要求时间超过了医嘱终止时间，请确认医嘱是否提前停止！'; 
      Raise Err_Custom; 
    End If; 
  End If; 
  If Not d_开始时间 Is Null Then 
    If 执行时间_In < d_开始时间 Then 
      v_Error := '执行时间必须大于医嘱的开始执行时间''' || To_Char(d_开始时间, 'yyyy-mm-dd HH24:mi:ss') || '''！'; 
      Raise Err_Custom; 
    End If; 
  End If; 
  Select Sysdate Into v_Date From Dual; 
  Select a.病人来源, 执行科室id, Nvl(a.相关id, a.Id), a.诊疗类别, Nvl(b.操作类型, '0') 操作类型 
  Into v_病人来源, v_病区id, v_组id, v_诊疗类别, v_操作类型 
  From 病人医嘱记录 A, 诊疗项目目录 B 
  Where a.Id = 医嘱id_In And a.诊疗项目id = b.Id; 
 
  If v_病人来源 = 2 Then 
    Select Decode(记录性质, 1, 1, Decode(门诊记帐, 1, 1, 2)) 
    Into v_费用性质 
    From 病人医嘱发送 
    Where 发送号 = 发送号_In And 医嘱id = 医嘱id_In; 
  Else 
    v_费用性质 := 1; 
  End If; 
 
  --移动系统配液检查 
  If 配液检查_In = 1 Then 
    --检查当前病人所属病区是否进行配液登记管理 
    Select Nvl(Zl_Getsysparameter(184), '') Into v_配液病区 From Dual; 
 
    If v_配液病区 Is Not Null And 执行结果_In <> 0 Then 
      If Instr(',' || v_配液病区 || ',', ',' || v_病区id || ',') > 0 Then 
        v_病区id   := 0; 
        v_配液病区 := 'Select 1 From 病区配液记录 where 医嘱ID=:YZID AND 发送号=:FSH AND 要求时间=:YQSJ'; 
        Begin 
          Execute Immediate v_配液病区 
            Into v_病区id 
            Using 医嘱id_In, 发送号_In, 要求时间_In; 
        Exception 
          When Others Then 
            Null; 
        End; 
        If v_病区id = 0 Then 
          v_Error := '当前医嘱还未进行配液，不允许进行执行登记！'; 
          Raise Err_Custom; 
        End If; 
      End If; 
    End If; 
    --检查当前医嘱是否已配液 
  End If; 
 
  --病人医嘱执行 
  Select Count(1) 
  Into v_Count 
  From 病人医嘱执行 
  Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In And 执行时间 = 执行时间_In; 
  If v_Count > 0 Then 
    v_Error := '您指定的执行时间，已经执行过本条医嘱，请更改一个执行时间。'; 
    Raise Err_Custom; 
  End If; 
  Insert Into 病人医嘱执行 
    (医嘱id, 发送号, 要求时间, 本次数次, 执行摘要, 执行人, 执行时间, 登记时间, 登记人, 执行结果, 说明, 输液通道, 执行科室ID) 
  Values 
    (医嘱id_In, 发送号_In, 要求时间_In, 本次数次_In, 执行摘要_In, 执行人_In, 执行时间_In, v_Date, v_人员姓名, 执行结果_In, 未执行原因_In, 输液通道_In, n_执行科室ID); 
 
  --费用记录的执行状态进行更新 
  Select Decode(a.执行状态, 1, a.发送数次, c.登记次数), Decode(a.执行状态, 1, 0, a.发送数次 - c.登记次数) ,c.登记次数
  Into n_执行次数, n_剩余次数 ,n_登记数次
  From 病人医嘱发送 A, 
       (Select 医嘱id_In 医嘱id, 发送号_In 发送号, Nvl(Sum(b.本次数次), 0) As 登记次数 
         From 病人医嘱执行 B 
         Where b.医嘱id = 医嘱id_In And b.发送号 = 发送号_In And Nvl(b.执行结果, 1) <> 0) C 
  Where a.医嘱id = c.医嘱id And a.发送号 = c.发送号 And a.医嘱id = 医嘱id_In And a.发送号 = 发送号_In; 
  --如果全部执行则状态为1，未执行状态为0，部分执行状态为2 
  Select Decode(n_剩余次数, 0, 1, Decode(n_执行次数, 0, 0, 2)) Into n_执行状态 From Dual; 
 
  --填写了执行状态后就标记为正在执行 
  If Nvl(单独执行_In, 0) = 1 Then 
    Update 病人医嘱发送 
    Set 执行状态 = Decode(n_执行次数, 0, 0, 3) 
    Where 执行状态 In (0, 3) And 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In; 
  Else 
    Update 病人医嘱发送 
    Set 执行状态 = Decode(n_执行次数, 0, 0, 3) 
    Where 执行状态 In (0, 3) And 发送号 + 0 = 发送号_In And 
          医嘱id In (Select ID 
                   From 病人医嘱记录 
                   Where ID = v_组id And 诊疗类别 = v_诊疗类别 
                   Union All 
                   Select ID From 病人医嘱记录 Where 相关id = v_组id And 诊疗类别 = v_诊疗类别); 
  End If; 
 
  --更新对应的费用执行状态为已执行(无正在执行) 
  --不应该处理药品和跟踪在用的卫材 
  If 执行结果_In = 1 Then 
    If v_费用性质 = 2 Then 
      If Nvl(单独执行_In, 0) = 1 Then 
        Update 住院费用记录 A 
        Set 执行状态 = n_执行状态, 执行人 = Decode(n_执行状态, 0, Null, 执行人_In), 执行时间 = Decode(n_执行状态, 0, Null, 执行时间_In) 
        Where 收费类别 Not In ('5', '6', '7') And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In) And Not Exists 
         (Select 1 From 材料特性 Where 材料id = a.收费细目id And 跟踪在用 = 1) And a.记录状态 In (0, 1, 3) And 
              (医嘱序号, NO, 记录性质) In 
              (Select 医嘱id, NO, 记录性质 
               From 病人医嘱发送 
               Where 执行状态 = Decode(n_执行次数, 0, 0, 3) And 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In); 
      Else 
        Update 住院费用记录 A 
        Set 执行状态 = n_执行状态, 执行人 = Decode(n_执行状态, 0, Null, 执行人_In), 执行时间 = Decode(n_执行状态, 0, Null, 执行时间_In) 
        Where 收费类别 Not In ('5', '6', '7') And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In) And Not Exists 
         (Select 1 From 材料特性 Where 材料id = a.收费细目id And 跟踪在用 = 1) And a.记录状态 In (0, 1, 3) And 
              (医嘱序号, NO, 记录性质) In 
              (Select 医嘱id, NO, 记录性质 
               From 病人医嘱发送 
               Where 执行状态 = Decode(n_执行次数, 0, 0, 3) And 发送号 + 0 = 发送号_In And 
                     医嘱id In (Select ID 
                              From 病人医嘱记录 
                              Where ID = v_组id And 诊疗类别 = v_诊疗类别 
                              Union All 
                              Select ID From 病人医嘱记录 Where 相关id = v_组id And 诊疗类别 = v_诊疗类别)); 
      End If; 
    Else 
      If Nvl(单独执行_In, 0) = 1 Then 
        --对于门诊单据n_执行状态可能为0（登记执行情况，选择执行结果为未执行），因此需判断 
        Update 门诊费用记录 A 
        Set 执行状态 = n_执行状态, 执行人 = Decode(n_执行状态, 0, Null, 执行人_In), 执行时间 = Decode(n_执行状态, 0, Null, 执行时间_In) 
        Where 收费类别 Not In ('5', '6', '7') And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In) And Not Exists 
         (Select 1 From 材料特性 Where 材料id = a.收费细目id And 跟踪在用 = 1) And a.记录状态 In (0, 1, 3) And 
              (医嘱序号, NO, 记录性质) In 
              (Select 医嘱id, NO, 记录性质 
               From 病人医嘱发送 
               Where 执行状态 = Decode(n_执行次数, 0, 0, 3) And 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In); 
      Else 
        Update 门诊费用记录 A 
        Set 执行状态 = n_执行状态, 执行人 = Decode(n_执行状态, 0, Null, 执行人_In), 执行时间 = Decode(n_执行状态, 0, Null, 执行时间_In) 
        Where 收费类别 Not In ('5', '6', '7') And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In) And Not Exists 
         (Select 1 From 材料特性 Where 材料id = a.收费细目id And 跟踪在用 = 1) And a.记录状态 In (0, 1, 3) And 
              (医嘱序号, NO, 记录性质) In 
              (Select 医嘱id, NO, 记录性质 
               From 病人医嘱发送 
               Where 执行状态 = Decode(n_执行次数, 0, 0, 3) And 发送号 + 0 = 发送号_In And 
                     医嘱id In (Select ID 
                              From 病人医嘱记录 
                              Where ID = v_组id And 诊疗类别 = v_诊疗类别 
                              Union All 
                              Select ID From 病人医嘱记录 Where 相关id = v_组id And 诊疗类别 = v_诊疗类别)); 
      End If; 
    End If; 
    --检验自动完成采集 
    If v_诊疗类别 = 'E' And v_操作类型 = '6' Then 
      Update 病人医嘱发送 A 
      Set a.采样人 = 执行人_In, a.采样时间 = 执行时间_In 
      Where 医嘱id In (Select ID 
                     From 病人医嘱记录 
                     Where ID = v_组id 
                     Union All 
                     Select ID From 病人医嘱记录 Where 相关id = v_组id) And 发送号 = 发送号_In; 
    End If; 
 
    --执行数次达到之后自动完成执行(主要用于PDA自动执行)，如果启用了移动临床，则护士站和PDA一致。 
    v_自动完成 := 自动完成_In; 
    If Nvl(v_自动完成, 0) = 0 And (v_病人来源 = 2 Or v_病人来源 = 1) And Instr('C,D', v_诊疗类别) = 0 Then 
      Begin 
        Execute Immediate 'Select Count(1) From ZLMBSYSTEMS' 
          Into v_Count; 
      Exception 
        When Others Then 
          Null; 
      End; 
      If v_Count > 0 Then 
        v_自动完成 := 1; 
      End If; 
    End If; 
 
    If Nvl(v_自动完成, 0) = 1 Or 检验项目记帐_In = 1 Then 
      Begin 
        Select Decode(Sign(Nvl(Sum(b.本次数次), 0) - a.发送数次), 1, 1, 0, 1, 0) 
        Into v_自动完成 
        From 病人医嘱发送 A, 病人医嘱执行 B 
        Where a.医嘱id = b.医嘱id And a.发送号 = b.发送号 And a.执行状态 In (0, 3) And a.医嘱id = 医嘱id_In And a.发送号 = 发送号_In 
        Group By a.发送数次; 
      Exception 
        When Others Then 
          Null; 
      End; 
 
      If Nvl(v_自动完成, 0) = 1 Or 检验项目记帐_In = 1 Then 
        Zl_病人医嘱执行_Finish(医嘱id_In, 发送号_In, Null, 单独执行_In, v_人员编号, v_人员姓名, 执行部门id_In, 检验项目记帐_In); 
      End If; 
    End If; 
    --更新医嘱执行计价.执行状态
    If n_发送数次 > 0 Then
      Select Count(distinct 要求时间) Into v_Count From 医嘱执行计价 Where 医嘱ID = 医嘱ID_IN And 发送号 = 发送号_IN;
      If v_Count > 0 Then
        n_单次数次 := n_发送数次 / v_Count;
        --已执行数量+本次数次 总共能够执行多少个时间点,取最大整数
        v_Count := ceil((n_登记数次) / n_单次数次);
        --获取执行截至要求时间 
        Select 要求时间 Into d_要求时间
        From (Select 要求时间, Rownum As 次数
               From (Select Distinct 要求时间 From 医嘱执行计价 Where 医嘱id = 医嘱ID_IN And 发送号 = 发送号_IN Order By 要求时间))
        Where 次数 = v_Count;
        
        If Not d_要求时间 Is Null Then
          --先检查是否已经退费
          Select Max(NVL(执行状态,0)) Into v_Count From 医嘱执行计价 Where 医嘱id = 医嘱ID_IN And 发送号 = 发送号_IN And 要求时间 <= d_要求时间;
          If v_Count = 2 Then
            v_Error := '您指定的执行时间段的医嘱费用已经被退费，不允许再执行。'; 
            Raise Err_Custom; 
          End If;
          --更新截至要求时间之前(含)的记录执行状态；
          Update 医嘱执行计价 Set 执行状态 = 1 Where 医嘱id = 医嘱ID_IN And 发送号 = 发送号_IN And 要求时间 <= d_要求时间 And NVL(执行状态,0) <> 2;
        End If;
      End If;
    End If;
  End If; 
Exception 
  When Err_Custom Then 
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]'); 
  When Others Then 
    Zl_Errorcenter(Sqlcode, Sqlerrm); 
End Zl_病人医嘱执行_Insert;
/

--104383:张德婷,2017-06-19,修正高值卫材退料问题
CREATE OR REPLACE Procedure Zl_材料其他出库_Strike
(
  行次_In       In Integer,
  原记录状态_In In 药品收发记录.记录状态%Type,
  No_In         In 药品收发记录.No%Type,
  序号_In       In 药品收发记录.序号%Type,
  材料id_In     In 药品收发记录.药品id%Type,
  冲销数量_In   In 药品收发记录.实际数量%Type,
  填制人_In     In 药品收发记录.填制人%Type,
  填制日期_In   In 药品收发记录.填制日期%Type,
  全部冲销_In   In 药品收发记录.实际数量%Type := 0 --1-全部冲销,0-部分冲销
) Is
  Err_Item Exception;
  v_Err_Msg Varchar2(500);

  v_批号     药品收发记录.批号%Type;
  v_摘要     药品收发记录.摘要%Type;
  v_产地     药品收发记录.产地%Type;
  v_批准文号 药品库存.批准文号%Type;

  d_上次生产日期 药品库存.上次生产日期%Type;
  d_效期         药品收发记录.效期%Type;
  d_灭菌效期     药品收发记录.灭菌效期%Type;

  n_Batch_Count  Integer; --原不分批现在分批的材料的数量
  n_库房id       药品收发记录.库房id%Type;
  n_入出类别id   药品收发记录.入出类别id%Type;
  n_批次         药品收发记录.批次%Type;
  n_成本价       药品收发记录.成本价%Type;
  n_成本金额     药品收发记录.成本金额%Type;
  n_扣率         药品收发记录.扣率%Type;
  n_零售价       药品收发记录.零售价%Type;
  n_零售金额     药品收发记录.零售金额%Type;
  n_差价         药品收发记录.差价%Type;
  n_剩余数量     药品收发记录.实际数量%Type;
  n_剩余成本金额 药品收发记录.成本金额%Type;
  n_剩余零售金额 药品收发记录.零售金额%Type;
  n_入出系数     药品收发记录.入出系数%Type;
  n_收发id       药品收发记录.Id%Type;
  n_冲销数量     药品收发记录.实际数量%Type;
  n_费用id       药品收发记录.费用id%Type;
  n_实价卫材     收费项目目录.是否变价%Type;
  n_上次供应商id 药品库存.上次供应商id%Type;
  n_记录数       Number;
  n_小数         Number(2);
  v_外调价       药品收发记录.单量%Type;
  v_外调单位     药品收发记录.发药窗口%Type;
  v_增值税率     药品收发记录.频次%Type;
  v_商品条码     药品库存.商品条码%Type;
  v_内部条码     药品库存.内部条码%Type;
  n_平均成本价   药品库存.平均成本价%Type;
Begin
  n_冲销数量 := 冲销数量_In;
  Select Nvl(精度, 2) Into n_小数 From 药品卫材精度 Where 性质 = 0 And 类别 = 2 And 内容 = 4 And 单位 = 5;

  If 行次_In = 1 Then
    Update 药品收发记录
    Set 记录状态 = Decode(原记录状态_In, 1, 3, 原记录状态_In + 3)
    Where NO = No_In And 单据 = 21 And 记录状态 = 原记录状态_In;
    If Sql%RowCount = 0 Then
      v_Err_Msg := '[ZLSOFT]该单据已经被他人冲销！[ZLSOFT]';
      Raise Err_Item;
    End If;
  End If;

  --主要针对原不分批现在分批的材料，不能对其审核
  Select Count(*)
  Into n_Batch_Count
  From 药品收发记录 A, 材料特性 B
  Where a.药品id = b.材料id And a.No = No_In And a.单据 = 21 And a.药品id + 0 = 材料id_In And Mod(a.记录状态, 3) = 0 And
        Nvl(a.批次, 0) = 0 And
        ((Nvl(b.库房分批, 0) = 1 And
        a.库房id Not In (Select 部门id From 部门性质说明 Where (工作性质 Like '发料部门') Or (工作性质 Like '制剂室'))) Or Nvl(b.在用分批, 0) = 1);

  If n_Batch_Count > 0 Then
    v_Err_Msg := '[ZLSOFT]该单据中包含有一条原来不分批，现在分批的材料，不能冲销！[ZLSOFT]';
    Raise Err_Item;
  End If;

  Select Sum(实际数量) As 剩余数量, Sum(成本金额) As 剩余成本金额, Sum(零售金额) As 剩余零售金额, Max(供药单位id) As 供药单位id, 库房id, 入出类别id, 入出系数, 批次, 产地,
         批号, 效期, 灭菌效期, 成本价, 扣率, 零售价, 摘要, 生产日期, 批准文号, 单量, 发药窗口, 费用id,
         To_Number(Trim(To_Char(Nvl(频次, '0'), '999999999999.0000'))) As 增值税率, 商品条码, 内部条码
  Into n_剩余数量, n_剩余成本金额, n_剩余零售金额, n_上次供应商id, n_库房id, n_入出类别id, n_入出系数, n_批次, v_产地, v_批号, d_效期, d_灭菌效期, n_成本价, n_扣率,
       n_零售价, v_摘要, d_上次生产日期, v_批准文号, v_外调价, v_外调单位,n_费用id, v_增值税率, v_商品条码, v_内部条码
  From 药品收发记录
  Where NO = No_In And 单据 = 21 And 药品id + 0 = 材料id_In And 序号 = 序号_In
  Group By 库房id, 入出类别id, 入出系数, 批次, 产地, 批号, 效期, 灭菌效期, 成本价, 扣率, 零售价, 摘要, 生产日期, 批准文号, 单量, 发药窗口,费用id,
           To_Number(Trim(To_Char(Nvl(频次, '0'), '999999999999.0000'))), 商品条码, 内部条码;

  If Nvl(n_剩余数量, 0) = 0 Then
    v_Err_Msg := '[ZLSOFT]该单据中第' || 序号_In || '行的材料已经被冲销完成,不能再冲！[ZLSOFT]';
    Raise Err_Item;
  End If;

  If 全部冲销_In = 1 Then
    n_冲销数量 := n_剩余数量;
  End If;
  --冲销数量大于剩余数量，不允许
  If Abs(n_剩余数量) < Abs(n_冲销数量) Then
    v_Err_Msg := '[ZLSOFT]该单据中第' || 序号_In || '行的材料冲销的数量大于了剩余的数据，不能冲销！[ZLSOFT]';
    Raise Err_Item;
  End If;

  n_成本金额 := Round(n_冲销数量 / n_剩余数量 * n_剩余成本金额, n_小数);
  n_零售金额 := Round(n_冲销数量 / n_剩余数量 * n_剩余零售金额, n_小数);
  n_差价     := Round(n_零售金额 - n_成本金额, n_小数);

  Select 药品收发记录_Id.Nextval Into n_收发id From Dual;

  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 灭菌效期, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 零售金额, 差价, 摘要,
     填制人, 填制日期, 审核人, 审核日期, 供药单位id, 生产日期, 批准文号, 扣率, 单量, 发药窗口, 频次, 商品条码, 内部条码,费用id)
  Values
    (n_收发id, Decode(原记录状态_In, 1, 2, 原记录状态_In + 2), 21, No_In, 序号_In, n_库房id, n_入出类别id, n_入出系数, 材料id_In, n_批次, v_产地,
     v_批号, d_效期, d_灭菌效期, -n_冲销数量, -n_冲销数量, n_成本价, -n_成本金额, n_零售价, -n_零售金额, -n_差价, v_摘要, 填制人_In, 填制日期_In, 填制人_In, 填制日期_In,
     n_上次供应商id, d_上次生产日期, v_批准文号, n_扣率, v_外调价, v_外调单位, v_增值税率, v_商品条码, v_内部条码,n_费用id);

  --原分批现不分批的材料,在冲消时，要处理他
  Begin
    Select Count(*)
    Into n_记录数
    From 药品收发记录 A, 材料特性 B
    Where a.药品id = b.材料id And b.材料id + 0 = 材料id_In And a.No = No_In And a.单据 = 21 And Mod(a.记录状态, 3) = 0 And
          Nvl(a.批次, 0) > 0 And
          (Nvl(b.库房分批, 0) = 0 Or
          (Nvl(b.在用分批, 0) = 0 And
          a.库房id In (Select 部门id From 部门性质说明 Where (工作性质 Like '发料部门') Or (工作性质 Like '制剂室'))));
  Exception
    When Others Then
      n_记录数 := 0;
  End;
  If n_记录数 > 0 Then
    n_批次 := 0;
  Else
    n_批次 := Nvl(n_批次, 0);
  End If;
  Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = 材料id_In;

  --更改药品库存表的相应数据
  Update 药品库存
  Set 可用数量 = Nvl(可用数量, 0) + Nvl(n_冲销数量, 0), 实际数量 = Nvl(实际数量, 0) + Nvl(n_冲销数量, 0), 实际金额 = Nvl(实际金额, 0) + Nvl(n_零售金额, 0),
      实际差价 = Nvl(实际差价, 0) + Nvl(n_差价, 0),
      零售价 = Decode(n_实价卫材, 1, Decode(Nvl(n_批次, 0), 0, Null, Decode(Nvl(零售价, 0), 0, n_零售价, 零售价)), Null),
      商品条码 = Nvl(商品条码, v_商品条码), 内部条码 = Nvl(内部条码, v_内部条码)
  Where 库房id = n_库房id And 药品id = 材料id_In And Nvl(批次, 0) = n_批次 And 性质 = 1;

  If Sql%NotFound Then
    Insert Into 药品库存
      (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 效期, 灭菌效期, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 批准文号, 零售价, 上次扣率, 商品条码,
       内部条码, 平均成本价)
    Values
      (n_库房id, 材料id_In, n_批次, 1, n_冲销数量, n_冲销数量, n_零售金额, n_差价, d_效期, d_灭菌效期, n_上次供应商id, n_成本价, v_批号, d_上次生产日期, v_产地,
       v_批准文号, Decode(n_实价卫材, 1, Decode(Nvl(n_批次, 0), 0, Null, n_零售价), Null), n_扣率, v_商品条码, v_内部条码, n_成本价);
  End If;

  Delete From 药品库存
  Where 库房id = n_库房id And 药品id = 材料id_In And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
        Nvl(实际差价, 0) = 0;

  Zl_材料收发记录_调价修正(n_收发id);

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料其他出库_Strike;
/

--109239:刘尔旋,2017-06-19,结帐红票打印异常处理
Create Or Replace Procedure Zl_病人结帐记录_Reprint
(
  No_In       病人预交记录.No%Type,
  票据号_In   票据使用明细.号码%Type,
  领用id_In   票据使用明细.领用id%Type,
  使用人_In   票据使用明细.使用人%Type,
  票据张数_In Number,
  票种_In     Number := 0, --0:住院医疗费收据,1-门诊医疗费收据
  红票打印_In Number := 0, --0:正常重打,1-作废时候红票打印
  使用时间_In Date := Null
) As
  --该游标用于票据范围判断
  Cursor c_Fact Is
    Select * From 票据领用记录 Where ID = Nvl(领用id_In, 0);
  r_Factrow c_Fact%RowType;

  v_收回id 票据打印内容.Id%Type;
  v_打印id 票据打印内容.Id%Type;
  v_票据号 票据使用明细.号码%Type;

  v_Date  Date;
  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  If Nvl(红票打印_In, 0) = 0 Then
    Begin
      Select ID
      Into v_收回id
      From (Select b.Id
             From 票据使用明细 A, 票据打印内容 B
             Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 3 And b.No = No_In
             Order By a.使用时间 Desc)
      Where Rownum < 2;
    Exception
      When Others Then
        Null;
    End;
    Select Sysdate Into v_Date From Dual;
  
    --收回原发出票据(可能以前没有使用票据,无法收回)
    If v_收回id Is Not Null Then
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
        Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 4, 领用id, 打印id, v_Date, 使用人_In
        From 票据使用明细
        Where 打印id = v_收回id And 票种 = Decode(票种_In, 0, 3, 1) And 性质 = 1;
    End If;
  
    --无票据号时,不用处理票据
    If 票据号_In Is Null Then
      Return;
    End If;
  
    --重新发出票据
    Select 票据打印内容_Id.Nextval Into v_打印id From Dual;
    --票据打印内容
    Insert Into 票据打印内容 (ID, 数据性质, NO) Values (v_打印id, 3, No_In);
    --病人结帐记录中填写开始票据号以便显示
    Update 病人结帐记录 Set 实际票号 = 票据号_In Where 记录状态 = 1 And NO = No_In;
  
    --并发出票据
    v_票据号 := 票据号_In;
    If Nvl(领用id_In, 0) <> 0 Then
      Open c_Fact;
      Fetch c_Fact
        Into r_Factrow;
      If c_Fact%RowCount = 0 Then
        v_Error := '无效的票据领用批次，无法完成结帐票据分配操作。';
        Close c_Fact;
        Raise Err_Custom;
      End If;
    End If;
    For I In 1 .. 票据张数_In Loop
      --检查票据范围是否正确
      If Nvl(领用id_In, 0) <> 0 Then
        If Not (Upper(v_票据号) >= Upper(r_Factrow.开始号码) And Upper(v_票据号) <= Upper(r_Factrow.终止号码) And
            Length(v_票据号) = Length(r_Factrow.终止号码)) Then
          v_Error := '该结帐单需要打印多张票据,但票据号"' || v_票据号 || '"超出票据领用的号码范围！';
          Close c_Fact;
          Raise Err_Custom;
        End If;
      End If;
    
      --发出票据
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
      Values
        (票据使用明细_Id.Nextval, Decode(票种_In, 0, 3, 1), v_票据号, 1, Decode(v_收回id, Null, 1, 3), 领用id_In, v_打印id, 使用人_In,
         v_Date);
    
      Update 票据领用记录
      Set 当前号码 = v_票据号, 剩余数量 = Decode(Sign(Nvl(剩余数量, 0) - 1), -1, 0, Nvl(剩余数量, 0) - 1)
      Where ID = Nvl(领用id_In, 0);
    
      --下一个票据号
      v_票据号 := Zl_Incstr(v_票据号);
    End Loop;
    Update 票据领用记录 Set 使用时间 = v_Date Where ID = 领用id_In;
  
    If Nvl(领用id_In, 0) <> 0 Then
      Close c_Fact;
    End If;
  Else
    --红票打印
    If 票据号_In Is Not Null Then
      Select 票据打印内容_Id.Nextval Into v_打印id From Dual;
    
      --发出票据
      Insert Into 票据打印内容 (ID, 数据性质, NO) Values (v_打印id, 3, No_In);
    
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
      Values
        (票据使用明细_Id.Nextval, 票种_In, 票据号_In, 1, 6, 领用id_In, v_打印id, 使用时间_In, 使用人_In);
    
      --状态改动
      Update 票据领用记录
      Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
      Where ID = Nvl(领用id_In, 0);
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人结帐记录_Reprint;
/

--98682:梁唐彬,2017-06-17,校对护理等级后自动确认停止
Create Or Replace Procedure Zl_病人医嘱记录_确认停止
(
  --功能：确认停止指定的医嘱
  --说明：一并给药的只能调用一次
  --参数：医嘱ID=相关ID为NULL的医嘱的ID(给药途径,中药用法,检查项目,主要手术,及独立医嘱)
  医嘱id_In     病人医嘱记录.Id%Type,
  确认时间_In   病人医嘱记录.确认停嘱时间%Type,
  操作员姓名_In 人员表.姓名%Type := Null,
  自动确认护理等级_In Number := 0
) Is
  v_状态     病人医嘱记录.医嘱状态%Type;
  v_医嘱内容 病人医嘱记录.医嘱内容%Type;

  v_Temp     Varchar2(255);
  v_人员姓名 病人医嘱状态.操作人员%Type;
  n_Count    Number;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --检查医嘱状态是否正确:并发操作
  Select 医嘱状态, 医嘱内容 Into v_状态, v_医嘱内容 From 病人医嘱记录 Where ID = 医嘱id_In;
  If v_状态 <> 8 Then
    v_Error := '医嘱"' || v_医嘱内容 || '"当前不处于停止状态。';
    Raise Err_Custom;
  End If;
  --检查是否是输液配液记录，并是否已经锁定
  Select Count(1) Into n_Count  From 输液配药记录 A,病人医嘱记录 B Where A.医嘱ID=B.ID And  医嘱ID = 医嘱id_In And A.执行时间 > B.执行终止时间 And A.是否锁定 = 1;
  If n_Count > 0 Then
    v_Error := '医嘱"' || v_医嘱内容 || '"是输液药品，已经被输液配置中心锁定，不能确认停止。';
    Raise Err_Custom;
  End If;

  --当前操作人员  
  If 操作员姓名_In Is Not Null Then
    v_人员姓名 := 操作员姓名_In;
  Else
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;

  Update 病人医嘱记录
  Set 医嘱状态 = 9, 确认停嘱时间 = 确认时间_In, 确认停嘱护士 = v_人员姓名
  Where ID = 医嘱id_In Or 相关id = 医嘱id_In;

  Insert Into 病人医嘱状态
    (医嘱id, 操作类型, 操作人员, 操作时间)
    Select ID, 9, v_人员姓名, Sysdate + 自动确认护理等级_In / 24 / 60 / 60 From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人医嘱记录_确认停止;
/

--110046:余伟节,2017-06-13,解决病人信息合并健康号丢失的情况
Create Or Replace Procedure Zl_病人信息_Merge
(
  A病人id_In    病人信息.病人id%Type, --要合并的病人信息
  B病人id_In    病人信息.病人id%Type, --要保留的病人信息
  合并原因_In   病人合并记录.合并原因%Type,
  操作员姓名_In 人员表.姓名%Type,
  强制保留_In   Number := 0
  --标准版
  ----------------------------------------------------------------------------
  --病人信息,病案主页,病案主页从表,病人变动记录,特殊病人
  --门诊病案记录,住院病案记录,床位状况记录
  --医保病人档案,保险模拟结算,保险结算记录,帐户年度信息
  --病人余额,病人未结费用,住院费用记录,门诊费用记录,病人预交记录,病人结帐记录,未发药品记录
  --病人挂号记录,病人过敏药物,病人过敏记录,病人诊断记录,诊断情况
  --病人医嘱记录,病人手麻记录
  --病人社区信息
  
  --后备表：
  --H病人结帐记录,H病人预交记录,H住院费用记录,H门诊费用记录
  --H病人医嘱记录,H病人诊断记录,H病人过敏记录
  --H病人病历记录,H病人手麻记录
  
  --病案系统
  ----------------------------------------------------------------------------
  --病人费用,随诊记录,借阅记录
  --新生儿诊断记录,病人分娩信息
  --诊断符合情况,病案评分结果
  
) As
  --病人相关表
  Cursor c_Patitable Is
    Select a.Table_Name, Max(Decode(b.Column_Name, '病人ID', 1, 0)) As 病人id,
           Max(Decode(b.Column_Name, '主页ID', 1, 0)) As 主页id
    From User_Tables A, User_Tab_Columns B
    Where a.Table_Name = b.Table_Name And b.Column_Name In ('病人ID', '主页ID') And
          a.Table_Name Not In
          ('病人信息', '病案主页', '病案主页从表', '病人变动记录','病人自动计算', '特殊病人', '门诊病案记录', '住院病案记录', '床位状况记录', '医保病人档案', '医保病人关联表', '保险模拟结算',
           '帐户年度信息', '病人余额', '病人未结费用', '住院费用记录', '门诊费用记录', '病人预交记录', '病人结帐记录', '未发药品记录', '病人挂号记录', '病人过敏药物', '病人过敏记录',
           '病人诊断记录', '诊断情况', '病人医嘱记录', '病人手麻记录', '病人费用', '随诊记录', '借阅记录', '病人分娩信息', '诊断符合情况', '病案评分结果', '病人担保记录', '病人社区信息',
           '病人免疫记录', '病人信息从表', '病人医疗卡属性') Having Max(Decode(b.Column_Name, '病人ID', 1, 0)) <> 0
    Group By a.Table_Name;

  --数组定义
  Type Array_Patitable Is Table Of Varchar2(100) Index By Binary_Integer;
  Arronbase Array_Patitable;
  Arronpage Array_Patitable;
  v_Loop    Number;
  n_Have    Number;

  -------------------------------------------------------
  --被合并的病人(住院号可能每次新产生,多次住院取最近一次)
  Cursor c_Infoa Is
    Select a.病人id, a.门诊号, a.住院号, a.就诊卡号, a.卡验证码, a.费别, a.医疗付款方式, a.姓名, a.性别, a.年龄, a.出生日期, a.出生地点, a.身份证号, a.其他证件, a.身份,
           a.职业, a.民族, a.国籍, a.籍贯, a.区域, a.学历, a.婚姻状况, a.家庭地址, a.家庭电话, a.家庭地址邮编, a.监护人, a.联系人姓名, a.联系人关系, a.联系人地址,
           a.联系人电话, a.户口地址, a.户口地址邮编, a.Email, a.Qq, a.合同单位id, a.工作单位, a.单位电话, a.单位邮编, a.单位开户行, a.单位帐号, a.担保人, a.担保额,
           a.担保性质, a.就诊时间, a.就诊状态, a.就诊诊室, a.住院次数, a.当前科室id, a.当前病区id, a.当前床号, a.入院时间, a.出院时间, a.在院, a.Ic卡号, a.健康号,
           a.医保号, a.险类, a.查询密码, a.登记时间, a.停用时间, a.锁定, a.联系人身份证号, b.主页id, b.入院日期, b.出院日期
    From 病人信息 A, 病案主页 B
    Where a.病人id = b.病人id(+) And a.病人id = A病人id_In
    Order By 出院日期 Desc, 主页id Desc;
  r_Infoa c_Infoa%RowType;

  --要保留的病人(住院号可能每次新产生,多次住院取最近一次)
  Cursor c_Infob Is
    Select a.病人id, a.门诊号, a.住院号, a.就诊卡号, a.卡验证码, a.费别, a.医疗付款方式, a.姓名, a.性别, a.年龄, a.出生日期, a.出生地点, a.身份证号, a.其他证件, a.身份,
           a.职业, a.民族, a.国籍, a.籍贯, a.区域, a.学历, a.婚姻状况, a.家庭地址, a.家庭电话, a.家庭地址邮编, a.监护人, a.联系人姓名, a.联系人关系, a.联系人地址,
           a.联系人电话, a.户口地址, a.户口地址邮编, a.Email, a.Qq, a.合同单位id, a.工作单位, a.单位电话, a.单位邮编, a.单位开户行, a.单位帐号, a.担保人, a.担保额,
           a.担保性质, a.就诊时间, a.就诊状态, a.就诊诊室, a.住院次数, a.当前科室id, a.当前病区id, a.当前床号, a.入院时间, a.出院时间, a.在院, a.Ic卡号, a.健康号,
           a.医保号, a.险类, a.查询密码, a.登记时间, a.停用时间, a.锁定, a.联系人身份证号, b.主页id, b.入院日期, b.出院日期
    From 病人信息 A, 病案主页 B
    Where a.病人id = b.病人id(+) And a.病人id = B病人id_In
    Order By 出院日期 Desc, 主页id Desc;
  r_Infob c_Infob%RowType;

  --合并后的信息
  Cursor c_Info(v_病人id 病人信息.病人id%Type) Is
    Select 病人id, 主页id, (Select Nvl(Max(主页id), 0) From 病案主页 Where 病人id = v_病人id) 最大主页id, 住院号, 病人性质, 医疗付款方式, 费别, 再入院,
           入院病区id, 入院科室id, 医疗小组id, 入院日期, 入院病况, 入院方式, 入院属性, 二级院转入, 住院目的, 入院病床, 是否陪伴, 当前病况, 当前病区id, 护理等级id, 出院科室id, 出院病床,
           出院日期, 住院天数, 出院方式, 是否确诊, 确诊日期, 新发肿瘤, 血型, 抢救次数, 成功次数, 随诊标志, 随诊期限, 尸检标志, 门诊医师, 责任护士, 住院医师, 病案号, 编目员编号, 编目员姓名,
           编目日期, 状态, 费用和, 年龄, 身高, 体重, 婚姻状况, 职业, 国籍, 学历, 单位电话, 单位邮编, 单位地址, 区域, 家庭地址, 家庭电话, 家庭地址邮编, 联系人姓名, 联系人关系, 联系人地址,
           联系人电话, 联系人身份证号, 户口地址, 户口地址邮编, 中医治疗类别, 险类, 社区, 审核标志, 审核人, 审核日期, 是否上传, 数据转出, 登记人, 登记时间, 备注, 病案状态, 病人类型
    From 病案主页
    Where 主页id = (Select Nvl(Max(主页id), 0)
                  From 病案主页
                  Where 病人id = v_病人id And Not Exists (Select 主页id From 病案主页 Where 病人id = v_病人id And 主页id = 0)) And
          病人id = v_病人id;
  r_Info c_Info%RowType;

  --合并两个住院病人
  Cursor c_Mergepati Is
    Select a.姓名, a.门诊号, a.住院号 当前住院号, b.病人id, b.主页id, b.住院号, b.留观号, b.病人性质, b.医疗付款方式, b.费别, b.再入院, b.入院病区id, b.入院科室id,
           b.医疗小组id, b.入院日期, b.入院病况, b.入院方式, b.入院属性, b.二级院转入, b.住院目的, b.入院病床, b.是否陪伴, b.当前病况, b.当前病区id, b.护理等级id,
           b.出院科室id, b.出院病床, b.出院日期, b.住院天数, b.出院方式, b.是否确诊, b.确诊日期, b.新发肿瘤, b.血型, b.抢救次数, b.成功次数, b.随诊标志, b.随诊期限,
           b.尸检标志, b.门诊医师, b.责任护士, b.住院医师, b.病案号, b.编目员编号, b.编目员姓名, b.编目日期, b.状态, b.费用和, b.性别, b.年龄, b.身高, b.体重, b.婚姻状况,
           b.职业, b.国籍, b.学历, b.单位电话, b.单位邮编, b.单位地址, b.区域, b.家庭地址, b.家庭电话, b.家庭地址邮编, b.联系人姓名, b.联系人关系, b.联系人地址, b.联系人电话,
           b.联系人身份证号, b.户口地址, b.户口地址邮编, b.中医治疗类别, b.险类, b.社区, b.审核标志, b.审核人, b.审核日期, b.是否上传, b.数据转出, b.登记人, b.登记时间, b.备注,
           b.病案状态, b.病人类型, b.封存时间, b.路径状态, b.单病种, b.婴儿科室id, b.婴儿病区id, b.母婴转科标志, b.医嘱重整时间
    From 病人信息 A, 病案主页 B
    Where a.病人id = b.病人id And a.病人id In (A病人id_In, B病人id_In)
    Order By b.入院日期 Desc, Nvl(b.出院日期, Sysdate) Desc;

  v_保留id 病人信息.病人id%Type;
  v_合并id 病人信息.病人id%Type;
  v_门诊号 病人信息.门诊号%Type;
  v_住院号 病人信息.住院号%Type;
  --病人未结费用(门诊部份)
  Cursor c_Owe(v_病人id 病人信息.病人id%Type) Is
    Select 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, Sum(金额) As 金额
    From 病人未结费用
    Where 主页id Is Null And 病人id = v_病人id
    Group By 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径;

  --病人余额
  Cursor c_Spare(v_病人id 病人信息.病人id%Type) Is
    Select 性质, 类型, 预交余额, 费用余额 From 病人余额 Where 病人id = v_病人id;

  --医保病人档案
  Cursor c_Insure(v_病人id 病人信息.病人id%Type) Is
    Select * From 保险帐户 Where 病人id = v_病人id Order By 险类;

  --要保留的医保病人档案
  Cursor c_Keepinsure
  (
    v_病人id 病人信息.病人id%Type,
    v_险类   医保病人档案.险类%Type
  ) Is
    Select * From 保险帐户 Where 病人id = v_病人id And 险类 = v_险类;
  r_Keepinsure c_Keepinsure%RowType;

  Cursor c_Year
  (
    v_病人id 病人信息.病人id%Type,
    v_险类   医保病人档案.险类%Type
  ) Is
    Select * From 帐户年度信息 Where 病人id = v_病人id And 险类 = v_险类;

  v_原信息   病人合并记录.原信息%Type;
  v_Count    Number;
  n_Readonly Number;
  v_Sql      Varchar2(1000);

  n_主页id       病人信息.主页id%Type;
  v_Error        Varchar2(255);
  n_担保额       病人担保记录.担保额%Type;
  v_担保人       病人信息.担保人%Type;
  n_担保性质     病人担保记录.担保性质%Type;
  n_Row          Number;
  n_独立病案     Number;
  n_每次新住院号 Number;
  n_Max主页id    Number;
  n_Cnt主页id    Number;
  n_Cur主页id    Number;
  n_Cnt住院次数  Number;
  n_Cur住院次数  Number;
  n_Max住院次数  Number;
  n_Loop主页id   病人信息.主页id%Type;

  n_Lengthb Number;
  Err_Custom Exception;
Begin
  Begin
    Select 只读 Into n_Readonly From zlBakSpaces Where 当前 = 1;
  Exception
    When Others Then
      Null;
  End;
  If n_Readonly = 1 Then
    n_Readonly := 0;
    For r_Bak In (Select a.表名 Table_Name
                  From Zltools.Zlbaktables A, User_Constraints B
                  Where a.表名 = b.Table_Name And b.r_Constraint_Name = '病人信息_PK' And b.Constraint_Type = 'R') Loop
      v_Sql := 'Select Count(病人Id) From ' || r_Bak.Table_Name || ' Where 病人Id In(:1,:2)';
      Execute Immediate v_Sql
        Into n_Readonly
        Using A病人id_In, B病人id_In;
      If n_Readonly > 0 Then
        v_Error := '病人在只读的当前转储空间存在数据,不能进行合并!';
        Raise Err_Custom;
      End If;
    End Loop;
  End If;

  --程序中已检查：
  --1.选择了同一个病人
  --2.两个住院病人先入院的却在院(包括两个都在院)。
  --3.两个住院病人的住院期间存在交叉的情况
  --4.医保病人存在未结费用

  --先锁定病人不允许进行其他业务
  Zl_病人信息_锁定(A病人id_In, 1);
  Zl_病人信息_锁定(B病人id_In, 1);

  Open c_Infoa;
  Fetch c_Infoa
    Into r_Infoa;
  If c_Infoa%RowCount = 0 Then
    Close c_Infoa;
    v_Error := '没有发现被合并的病人信息！';
    Raise Err_Custom;
  End If;

  Open c_Infob;
  Fetch c_Infob
    Into r_Infob;
  If c_Infob%RowCount = 0 Then
    Close c_Infob;
    v_Error := '没有发现要保留的病人信息！';
    Raise Err_Custom;
  End If;

  --读取其它相关病人表到数组
  For r_Patitable In c_Patitable Loop
    If r_Patitable.主页id = 0 Then
      Arronbase(Arronbase.Count + 1) := r_Patitable.Table_Name;
    Else
      Arronpage(Arronpage.Count + 1) := r_Patitable.Table_Name;
    End If;
  End Loop;

  --以先住院或先登记的病人ID作为实际上要保留的病人ID
  If Nvl(强制保留_In, 0) = 1 Then
    v_保留id := B病人id_In;
  Else
    Select 病人id
    Into v_保留id
    From (Select /*+ CHOOSE */
            a.病人id
           From 病人信息 A, 病案主页 B
           Where a.病人id = b.病人id(+) And a.病人id In (A病人id_In, B病人id_In)
           Order By Nvl(b.入院日期, To_Date('3000-01-01', 'YYYY-MM-DD')), Nvl(b.出院日期, To_Date('3000-01-01', 'YYYY-MM-DD')),
                    a.登记时间, a.病人id --住院病人优先
           )
    Where Rownum = 1;
  End If;

  --先确定病案号的模式
  Select Zl_To_Number(Nvl(zl_GetSysParameter(39), '0')) Into n_独立病案 From Dual;
  --住院号模式
  Select Zl_To_Number(Nvl(zl_GetSysParameter(145), '0')) Into n_每次新住院号 From Dual;

  --另外一个就是实际最后要删除的病人ID
  If v_保留id = A病人id_In Then
    v_合并id := B病人id_In;
    --问题27445 保留指定病人的门诊号、住院号、医保号
    v_门诊号 := Nvl(r_Infob.门诊号, r_Infoa.门诊号);
    v_住院号 := Nvl(r_Infob.住院号, r_Infoa.住院号);
  Else
    v_合并id := A病人id_In;
    v_门诊号 := Nvl(r_Infob.门诊号, r_Infoa.门诊号);
    v_住院号 := Nvl(r_Infob.住院号, r_Infoa.住院号);
  End If;

  ---记录合并操作,在后面会根据r_PatiTable把合并病人的合并记录更新为保留病人的
  v_原信息 := v_合并id || ',' || r_Infoa.门诊号 || ',' || r_Infoa.住院号 || ',' || r_Infoa.就诊卡号 || ',' || r_Infoa.姓名 || ',' ||
           r_Infoa.性别 || ',' || r_Infoa.年龄 || ',' || To_Char(r_Infoa.出生日期, 'yyyy-mm-dd') || ',' || r_Infoa.身份证号 || ',' ||
           r_Infoa.婚姻状况 || ',' || r_Infoa.职业 || ',' || r_Infoa.家庭地址;
  Insert Into 病人合并记录
    (病人id, 原信息, 合并原因, 操作员姓名, 合并时间)
  Values
    (v_保留id, v_原信息, 合并原因_In, 操作员姓名_In, Sysdate);

  --开始合并
  --84398修改将住院次数计算放在外面，因需要考虑门诊和住院病人合并
  --10.34开始,住院次数不包含留关病人,合并后的住院次数=保留病人住院次数+合并病人正常入院的次数
  Select Nvl(住院次数, 0) Into n_Cur住院次数 From 病人信息 Where 病人id = v_保留id;
  Select Count(*) Into n_Cnt住院次数 From 病案主页 Where 病人id = v_合并id And 主页id <> 0 And 病人性质 = 0;
  n_Max住院次数 := n_Cur住院次数 + n_Cnt住院次数;
  --处理病案主页部份(涉及病人ID,主页ID字段的表)
  If (r_Infoa.主页id Is Not Null And r_Infob.主页id Is Not Null) Or (强制保留_In = 1 And r_Infoa.主页id Is Not Null) Then
    If r_Infoa.主页id = 0 And r_Infob.主页id = 0 Then
      Close c_Infoa;
      Close c_Infob;
      v_Error := '两个预约病人不能进行病人合并操作！';
      Raise Err_Custom;
    Elsif r_Infoa.主页id = 0 Then
      If r_Infob.入院日期 Is Not Null And r_Infob.出院日期 Is Null Then
        Close c_Infoa;
        Close c_Infob;
        v_Error := '预约病人和在院病人不能进行病人合并操作！';
        Raise Err_Custom;
      End If;
    Elsif r_Infob.主页id = 0 Then
      If r_Infoa.入院日期 Is Not Null And r_Infoa.出院日期 Is Null Then
        Close c_Infoa;
        Close c_Infob;
        v_Error := '预约病人和在院病人不能进行病人合并操作！';
        Raise Err_Custom;
      End If;
    End If;
    --求两个病人总共的住院就诊次数
    Select Count(*) Into v_Count From 病案主页 Where 病人id In (A病人id_In, B病人id_In) And 主页id <> 0;
    --因为10.19开始，入院时允许修改主页id，所以最大主页ID可能大于总的住院就诊次数
    Select Max(主页id) Into n_Max主页id From 病案主页 Where 病人id = v_保留id And 主页id <> 0;
    Select Count(*) Into n_Cnt主页id From 病案主页 Where 病人id = v_合并id And 主页id <> 0;
    If n_Max主页id + n_Cnt主页id > v_Count Then
      v_Count := n_Max主页id + n_Cnt主页id;
    End If;
    --求实际要更新的主页截至值,以前用v_Count >= n_Max主页id判断存在一个问题（对于两个病人多次交叉入院，可能导致A,B病人部分就诊次数没有更新）
    Select Nvl(Max(主页id), 0)
    Into n_Loop主页id
    From 病案主页 A, (Select Min(入院日期) 入院日期 From 病案主页 Where 病人id = v_合并id) B
    Where a.病人id = v_保留id And a.入院日期 < b.入院日期;
  
    For r_Merge In c_Mergepati Loop
      If Not (r_Merge.病人id = v_保留id And r_Merge.主页id = v_Count) And v_Count <> 0 Then
        --该病案主页要删除时,不能是已编目了的。
        If r_Merge.编目日期 Is Not Null Then
          Close c_Infoa;
          Close c_Infob;
          If r_Merge.当前住院号 Is Null Then
            v_Error := '病人' || r_Merge.姓名 || '(病人ID=' || r_Merge.病人id || ')存在已编目的病案,不允许合并该病人。';
          Else
            v_Error := '病人' || r_Merge.姓名 || '(病人ID=' || r_Merge.病人id || ',住院号=' || r_Merge.当前住院号 ||
                       ')存在已编目的病案,不允许合并该病人。';
          End If;
          Raise Err_Custom;
        End If;
        If v_Count >= Nvl(n_Loop主页id, 0) Then
          If r_Merge.主页id = 0 Then
            n_Cur主页id := 0;
            Update 病案主页
            Set 病人性质 = r_Merge.病人性质, 医疗付款方式 = r_Merge.医疗付款方式, 费别 = r_Merge.费别, 再入院 = r_Merge.再入院,
                入院病区id = r_Merge.入院病区id, 入院科室id = r_Merge.入院科室id, 入院日期 = r_Merge.入院日期, 入院病况 = r_Merge.入院病况,
                入院方式 = r_Merge.入院方式, 二级院转入 = r_Merge.二级院转入, 住院目的 = r_Merge.住院目的, 入院病床 = r_Merge.入院病床,
                是否陪伴 = r_Merge.是否陪伴, 当前病况 = r_Merge.当前病况, 当前病区id = r_Merge.当前病区id, 护理等级id = r_Merge.护理等级id,
                出院科室id = r_Merge.出院科室id, 出院病床 = r_Merge.出院病床, 出院日期 = r_Merge.出院日期, 住院天数 = r_Merge.住院天数,
                出院方式 = r_Merge.出院方式, 是否确诊 = r_Merge.是否确诊, 确诊日期 = r_Merge.确诊日期, 新发肿瘤 = r_Merge.新发肿瘤, 血型 = r_Merge.血型,
                抢救次数 = r_Merge.抢救次数, 成功次数 = r_Merge.成功次数, 随诊标志 = r_Merge.随诊标志, 随诊期限 = r_Merge.随诊期限, 尸检标志 = r_Merge.尸检标志,
                门诊医师 = r_Merge.门诊医师, 责任护士 = r_Merge.责任护士, 住院医师 = r_Merge.住院医师, 编目员编号 = r_Merge.编目员编号,
                编目员姓名 = r_Merge.编目员姓名, 编目日期 = r_Merge.编目日期, 状态 = r_Merge.状态, 费用和 = r_Merge.费用和, 姓名 = r_Merge.姓名,
                性别 = r_Merge.性别, 年龄 = r_Merge.年龄, 婚姻状况 = r_Merge.婚姻状况, 职业 = r_Merge.职业, 国籍 = r_Merge.国籍, 学历 = r_Merge.学历,
                单位电话 = r_Merge.单位电话, 单位邮编 = r_Merge.单位邮编, 单位地址 = r_Merge.单位地址, 区域 = r_Merge.区域, 家庭地址 = r_Merge.家庭地址,
                家庭电话 = r_Merge.家庭电话, 家庭地址邮编 = r_Merge.家庭地址邮编, 户口地址 = r_Merge.户口地址, 户口地址邮编 = r_Merge.户口地址邮编,
                联系人姓名 = r_Merge.联系人姓名, 联系人关系 = r_Merge.联系人关系, 联系人地址 = r_Merge.联系人地址, 联系人电话 = r_Merge.联系人电话,
                中医治疗类别 = r_Merge.中医治疗类别, 登记人 = r_Merge.登记人, 登记时间 = r_Merge.登记时间, 险类 = r_Merge.险类, 审核标志 = r_Merge.审核标志,
                是否上传 = r_Merge.是否上传, 备注 = r_Merge.备注, 数据转出 = r_Merge.数据转出, 病案号 = r_Merge.病案号,
                住院号 = Decode(n_每次新住院号, 1, r_Merge.住院号, v_住院号), 留观号 = r_Merge.留观号, 病人类型 = r_Merge.病人类型,
                封存时间 = r_Merge.封存时间, 路径状态 = r_Merge.路径状态, 单病种 = r_Merge.单病种, 婴儿科室id = r_Merge.婴儿科室id,
                婴儿病区id = r_Merge.婴儿病区id, 母婴转科标志 = r_Merge.母婴转科标志, 医嘱重整时间 = r_Merge.医嘱重整时间
            Where 病人id = v_保留id And 主页id = n_Cur主页id;
            If Sql%RowCount = 0 Then
              Insert Into 病案主页
                (病人id, 主页id, 病人性质, 医疗付款方式, 费别, 再入院, 入院病区id, 入院科室id, 入院日期, 入院病况, 入院方式, 二级院转入, 住院目的, 入院病床, 是否陪伴, 当前病况,
                 当前病区id, 护理等级id, 出院科室id, 出院病床, 出院日期, 住院天数, 出院方式, 是否确诊, 确诊日期, 新发肿瘤, 血型, 抢救次数, 成功次数, 随诊标志, 随诊期限, 尸检标志,
                 门诊医师, 责任护士, 住院医师, 编目员编号, 编目员姓名, 编目日期, 状态, 费用和, 姓名, 性别, 年龄, 婚姻状况, 职业, 国籍, 学历, 单位电话, 单位邮编, 单位地址, 区域, 家庭地址,
                 家庭电话, 家庭地址邮编, 户口地址, 户口地址邮编, 联系人姓名, 联系人关系, 联系人地址, 联系人电话, 中医治疗类别, 登记人, 登记时间, 险类, 审核标志, 是否上传, 备注, 数据转出,
                 病案号, 住院号, 留观号, 病人类型, 封存时间, 路径状态, 单病种, 婴儿科室id, 婴儿病区id, 母婴转科标志, 医嘱重整时间)
              Values
                (v_保留id, n_Cur主页id, r_Merge.病人性质, r_Merge.医疗付款方式, r_Merge.费别, r_Merge.再入院, r_Merge.入院病区id,
                 r_Merge.入院科室id, r_Merge.入院日期, r_Merge.入院病况, r_Merge.入院方式, r_Merge.二级院转入, r_Merge.住院目的, r_Merge.入院病床,
                 r_Merge.是否陪伴, r_Merge.当前病况, r_Merge.当前病区id, r_Merge.护理等级id, r_Merge.出院科室id, r_Merge.出院病床, r_Merge.出院日期,
                 r_Merge.住院天数, r_Merge.出院方式, r_Merge.是否确诊, r_Merge.确诊日期, r_Merge.新发肿瘤, r_Merge.血型, r_Merge.抢救次数,
                 r_Merge.成功次数, r_Merge.随诊标志, r_Merge.随诊期限, r_Merge.尸检标志, r_Merge.门诊医师, r_Merge.责任护士, r_Merge.住院医师,
                 r_Merge.编目员编号, r_Merge.编目员姓名, r_Merge.编目日期, r_Merge.状态, r_Merge.费用和, r_Merge.姓名, r_Merge.性别, r_Merge.年龄,
                 r_Merge.婚姻状况, r_Merge.职业, r_Merge.国籍, r_Merge.学历, r_Merge.单位电话, r_Merge.单位邮编, r_Merge.单位地址, r_Merge.区域,
                 r_Merge.家庭地址, r_Merge.家庭电话, r_Merge.家庭地址邮编, r_Merge.户口地址, r_Merge.户口地址邮编, r_Merge.联系人姓名, r_Merge.联系人关系,
                 r_Merge.联系人地址, r_Merge.联系人电话, r_Merge.中医治疗类别, r_Merge.登记人, r_Merge.登记时间, r_Merge.险类, r_Merge.审核标志,
                 r_Merge.是否上传, r_Merge.备注, r_Merge.数据转出, r_Merge.病案号, Decode(n_每次新住院号, 1, r_Merge.住院号, v_住院号),
                 r_Merge.留观号, r_Merge.病人类型, r_Merge.封存时间, r_Merge.路径状态, r_Merge.单病种, r_Merge.婴儿科室id, r_Merge.婴儿病区id,
                 r_Merge.母婴转科标志, r_Merge.医嘱重整时间);
            End If;
          Else
            n_Cur主页id := v_Count;
            Insert Into 病案主页
              (病人id, 主页id, 病人性质, 医疗付款方式, 费别, 再入院, 入院病区id, 入院科室id, 入院日期, 入院病况, 入院方式, 二级院转入, 住院目的, 入院病床, 是否陪伴, 当前病况,
               当前病区id, 护理等级id, 出院科室id, 出院病床, 出院日期, 住院天数, 出院方式, 是否确诊, 确诊日期, 新发肿瘤, 血型, 抢救次数, 成功次数, 随诊标志, 随诊期限, 尸检标志, 门诊医师,
               责任护士, 住院医师, 编目员编号, 编目员姓名, 编目日期, 状态, 费用和, 姓名, 性别, 年龄, 婚姻状况, 职业, 国籍, 学历, 单位电话, 单位邮编, 单位地址, 区域, 家庭地址, 家庭电话,
               家庭地址邮编, 户口地址, 户口地址邮编, 联系人姓名, 联系人关系, 联系人地址, 联系人电话, 中医治疗类别, 登记人, 登记时间, 险类, 审核标志, 是否上传, 备注, 数据转出, 病案号, 住院号,
               留观号, 病人类型, 封存时间, 路径状态, 单病种, 婴儿科室id, 婴儿病区id, 母婴转科标志, 医嘱重整时间)
            Values
              (v_保留id, n_Cur主页id, r_Merge.病人性质, r_Merge.医疗付款方式, r_Merge.费别, r_Merge.再入院, r_Merge.入院病区id, r_Merge.入院科室id,
               r_Merge.入院日期, r_Merge.入院病况, r_Merge.入院方式, r_Merge.二级院转入, r_Merge.住院目的, r_Merge.入院病床, r_Merge.是否陪伴,
               r_Merge.当前病况, r_Merge.当前病区id, r_Merge.护理等级id, r_Merge.出院科室id, r_Merge.出院病床, r_Merge.出院日期, r_Merge.住院天数,
               r_Merge.出院方式, r_Merge.是否确诊, r_Merge.确诊日期, r_Merge.新发肿瘤, r_Merge.血型, r_Merge.抢救次数, r_Merge.成功次数,
               r_Merge.随诊标志, r_Merge.随诊期限, r_Merge.尸检标志, r_Merge.门诊医师, r_Merge.责任护士, r_Merge.住院医师, r_Merge.编目员编号,
               r_Merge.编目员姓名, r_Merge.编目日期, r_Merge.状态, r_Merge.费用和, r_Merge.姓名, r_Merge.性别, r_Merge.年龄, r_Merge.婚姻状况,
               r_Merge.职业, r_Merge.国籍, r_Merge.学历, r_Merge.单位电话, r_Merge.单位邮编, r_Merge.单位地址, r_Merge.区域, r_Merge.家庭地址,
               r_Merge.家庭电话, r_Merge.家庭地址邮编, r_Merge.户口地址, r_Merge.户口地址邮编, r_Merge.联系人姓名, r_Merge.联系人关系, r_Merge.联系人地址,
               r_Merge.联系人电话, r_Merge.中医治疗类别, r_Merge.登记人, r_Merge.登记时间, r_Merge.险类, r_Merge.审核标志, r_Merge.是否上传,
               r_Merge.备注, r_Merge.数据转出, r_Merge.病案号, Decode(n_每次新住院号, 1, r_Merge.住院号, v_住院号), r_Merge.留观号, r_Merge.病人类型,
               r_Merge.封存时间, r_Merge.路径状态, r_Merge.单病种, r_Merge.婴儿科室id, r_Merge.婴儿病区id, r_Merge.母婴转科标志, r_Merge.医嘱重整时间);
          End If;
        Else
          Exit;
        End If;
      
        --更新病人相关表的病人指向
        ---------------------------------------------------------------
        --病人变动记录
        Update 病人变动记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
        
        --病人自动计算
        Update 病人自动计算
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
        
        --病案主页从表
        Update 病案主页从表
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --住院费用记录
        Update 住院费用记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id,
            标识号 = Nvl(Decode(门诊标志, 1, v_门诊号, Decode(n_每次新住院号, 1, r_Merge.住院号, v_住院号)), 标识号)
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
        Update H住院费用记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id,
            标识号 = Nvl(Decode(门诊标志, 1, v_门诊号, Decode(n_每次新住院号, 1, r_Merge.住院号, v_住院号)), 标识号)
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
        --门诊费用记录
        --Update 门诊费用记录
        --Set 病人id = v_保留id,
        --    标识号 = Nvl(Decode(门诊标志, 1, v_门诊号, Decode(n_每次新住院号, 1, r_Merge.住院号, v_住院号)), 标识号)
        --Where 病人id = r_Merge.病人id;
        --Update H门诊费用记录
        --Set 病人id = v_保留id,
        --    标识号 = Nvl(Decode(门诊标志, 1, v_门诊号, Decode(n_每次新住院号, 1, r_Merge.住院号, v_住院号)), 标识号)
        --Where 病人id = r_Merge.病人id;
      
        --病人预交记录
        Update 病人预交记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
        Update H病人预交记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --病人未结费用
        Update 病人未结费用
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --未发药品记录
        Update 未发药品记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --诊断情况
        Update 诊断情况
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --保险结算记录(病人ID和非住院病人一起在后面处理)
        Update 保险结算记录 Set 主页id = n_Cur主页id Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --保险模拟结算
        Update 保险模拟结算
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --病人医嘱记录(ZLHIS+)
        Update 病人医嘱记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
        Update H病人医嘱记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --病人过敏记录(ZLHIS+)
        Update 病人过敏记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
        Update H病人过敏记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --病人诊断记录(ZLHIS+)
        Update 病人诊断记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
        Update H病人诊断记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --病人手麻记录(ZLHIS+)
        Update 病人手麻记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
        Update H病人手麻记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --病人担保记录(zlhis+)
        Update 病人担保记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --病案系统的表
        Begin
          v_Sql := 'Update 病人费用 Set 病人ID=:1,主页ID=:2 Where 病人ID=:3 And 主页ID=:4';
          Execute Immediate v_Sql
            Using v_保留id, n_Cur主页id, r_Merge.病人id, r_Merge.主页id;
        Exception
          When Others Then
            Null;
        End;
      
        Begin
          v_Sql := 'Update 随诊记录 Set 病人ID=:1,主页ID=:2 Where 病人ID=:3 And 主页ID=:4';
          Execute Immediate v_Sql
            Using v_保留id, n_Cur主页id, r_Merge.病人id, r_Merge.主页id;
        Exception
          When Others Then
            Null;
        End;
      
        Begin
          v_Sql := 'Update 诊断符合情况 Set 病人ID=:1,主页ID=:2 Where 病人ID=:3 And 主页ID=:4';
          Execute Immediate v_Sql
            Using v_保留id, n_Cur主页id, r_Merge.病人id, r_Merge.主页id;
        Exception
          When Others Then
            Null;
        End;
      
        Begin
          v_Sql := 'Update 病案评分结果 Set 病人ID=:1,主页ID=:2 Where 病人ID=:3 And 主页ID=:4';
          Execute Immediate v_Sql
            Using v_保留id, n_Cur主页id, r_Merge.病人id, r_Merge.主页id;
        Exception
          When Others Then
            Null;
        End;
      
        Begin
          v_Sql := 'Insert Into 病人分娩信息(病人ID,主页ID,胎儿次序,分娩方式,出生胎位,分娩情况,出生缺陷,婴儿性别,婴儿体重,Apgar评分) ' ||
                   'Select :1,:2,胎儿次序,分娩方式,出生胎位,分娩情况,出生缺陷,婴儿性别,婴儿体重,Apgar评分 From 病人分娩信息 Where 病人ID=:3 And 主页ID=:4';
          Execute Immediate v_Sql
            Using v_保留id, n_Cur主页id, r_Merge.病人id, r_Merge.主页id;
        Exception
          When Others Then
            Null;
        End;
      
        Begin
          v_Sql := 'Delete From 病人分娩信息 Where 病人ID=:1 And 主页ID=:2';
          Execute Immediate v_Sql
            Using r_Merge.病人id, r_Merge.主页id;
        Exception
          When Others Then
            Null;
        End;
      
        Begin
          v_Sql := 'Update 借阅记录 Set 病人ID=:1,主页ID=:2 Where 病人ID=:3 And 主页ID=:4';
          Execute Immediate v_Sql
            Using v_保留id, n_Cur主页id, r_Merge.病人id, r_Merge.主页id;
        Exception
          When Others Then
            Null;
        End;
      
        --其它病案主页相关表
        For v_Loop In 1 .. Arronpage.Count Loop
          v_Sql := 'Update ' || Arronpage(v_Loop) || ' Set 病人ID=:1,主页ID=:2 Where 病人ID=:3 And 主页ID=:4';
          Execute Immediate v_Sql
            Using v_保留id, n_Cur主页id, r_Merge.病人id, r_Merge.主页id;
        End Loop;
      
        --删除已调整后的病案主页
        Delete From 病案主页 Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      End If;
      If r_Merge.主页id <> 0 Then
        v_Count := v_Count - 1;
      End If;
    End Loop;
  End If;

  --不涉及主页ID部份的更改(无主页ID或主页ID可能为空)
  ---------------------------------------------------------------
  --住院费用记录
  Update 住院费用记录
  Set 病人id = v_保留id, 标识号 = Nvl(Decode(门诊标志, 2, v_住院号, v_门诊号), 标识号)
  Where 病人id = v_合并id;
  Update H住院费用记录
  Set 病人id = v_保留id, 标识号 = Nvl(Decode(门诊标志, 2, v_住院号, v_门诊号), 标识号)
  Where 病人id = v_合并id;
  --门诊费用记录
  Update 门诊费用记录
  Set 病人id = v_保留id, 标识号 = Nvl(Decode(门诊标志, 2, v_住院号, v_门诊号), 标识号)
  Where 病人id = v_合并id;
  Update H门诊费用记录
  Set 病人id = v_保留id, 标识号 = Nvl(Decode(门诊标志, 2, v_住院号, v_门诊号), 标识号)
  Where 病人id = v_合并id;

  --病人预交记录
  Update 病人预交记录 Set 病人id = v_保留id Where 病人id = v_合并id And 主页id Is Null;
  Update H病人预交记录 Set 病人id = v_保留id Where 病人id = v_合并id And 主页id Is Null;

  --未发药品记录
  Update 未发药品记录 Set 病人id = v_保留id Where 病人id = v_合并id And 主页id Is Null;

  --诊断情况
  Update 诊断情况 Set 病人id = v_保留id Where 病人id = v_合并id And 主页id Is Null;

  --病人医嘱记录(ZLHIS+)
  Update 病人医嘱记录 Set 病人id = v_保留id Where 病人id = v_合并id And 主页id Is Null;
  Update H病人医嘱记录 Set 病人id = v_保留id Where 病人id = v_合并id And 主页id Is Null;

  --病人过敏记录(ZLHIS+):主页ID可能是挂号ID
  Update 病人过敏记录 Set 病人id = v_保留id Where 病人id = v_合并id;
  Update H病人过敏记录 Set 病人id = v_保留id Where 病人id = v_合并id;

  --病人诊断记录(ZLHIS+):主页ID可能是挂号ID
  Update 病人诊断记录 Set 病人id = v_保留id Where 病人id = v_合并id;
  Update H病人诊断记录 Set 病人id = v_保留id Where 病人id = v_合并id;

  --病人手麻记录(ZLHIS+)
  Update 病人手麻记录 Set 病人id = v_保留id Where 病人id = v_合并id And 主页id Is Null;
  Update H病人手麻记录 Set 病人id = v_保留id Where 病人id = v_合并id And 主页id Is Null;

  --病人挂号记录(ZLHIS+)
  Update 病人挂号记录 Set 病人id = v_保留id, 门诊号 = Nvl(v_门诊号, 门诊号) Where 病人id = v_合并id;

  --病人结帐记录
  Update 病人结帐记录 Set 病人id = v_保留id Where 病人id = v_合并id;
  Update H病人结帐记录 Set 病人id = v_保留id Where 病人id = v_合并id;

  --床位状况记录
  Update 床位状况记录 Set 病人id = v_保留id Where 病人id = v_合并id;

  --病人担保记录
  Update 病人担保记录 Set 病人id = v_保留id Where 病人id = v_合并id;
  --特殊病人
  Select Count(*) Into v_Count From 特殊病人 Where 病人id = v_保留id;
  If v_Count = 0 Then
    Update 特殊病人 Set 病人id = v_保留id Where 病人id = v_合并id;
  Else
    Delete From 特殊病人 Where 病人id = v_合并id;
  End If;

  --病人未结费用
  For r_Owe In c_Owe(v_合并id) Loop
    Update 病人未结费用
    Set 金额 = Nvl(金额, 0) + Nvl(r_Owe.金额, 0)
    Where 主页id Is Null And 病人id = v_保留id And Nvl(病人病区id, 0) = Nvl(r_Owe.病人病区id, 0) And
          Nvl(病人科室id, 0) = Nvl(r_Owe.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(r_Owe.开单部门id, 0) And
          Nvl(执行部门id, 0) = Nvl(r_Owe.执行部门id, 0) And Nvl(收入项目id, 0) = Nvl(r_Owe.收入项目id, 0) And
          Nvl(来源途径, 0) = Nvl(r_Owe.来源途径, 0);
    If Sql%RowCount = 0 Then
      Insert Into 病人未结费用
        (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
      Values
        (v_保留id, Null, r_Owe.病人病区id, r_Owe.病人科室id, r_Owe.开单部门id, r_Owe.执行部门id, r_Owe.收入项目id, r_Owe.来源途径, r_Owe.金额);
    End If;
  End Loop;
  Delete From 病人未结费用 Where 病人id = v_合并id;
  Delete From 病人未结费用 Where 病人id = v_保留id And Nvl(金额, 0) = 0;

  --病人余额
  For r_Spare In c_Spare(v_合并id) Loop
    Update 病人余额
    Set 预交余额 = Nvl(预交余额, 0) + Nvl(r_Spare.预交余额, 0), 费用余额 = Nvl(费用余额, 0) + Nvl(r_Spare.费用余额, 0)
    Where Nvl(性质, 0) = Nvl(r_Spare.性质, 0) And 病人id = v_保留id And 类型 = Nvl(r_Spare.类型, 2);
    If Sql%RowCount = 0 Then
      Insert Into 病人余额
        (病人id, 性质, 类型, 预交余额, 费用余额)
      Values
        (v_保留id, r_Spare.性质, Nvl(r_Spare.类型, 2), r_Spare.预交余额, r_Spare.费用余额);
    End If;
  End Loop;
  Delete From 病人余额 Where 病人id = v_合并id;
  Delete From 病人余额 Where 病人id = v_保留id And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0 And 性质 = 1;

  --病人过敏药物
  Insert Into 病人过敏药物
    (病人id, 过敏药物id, 过敏药物)
    Select v_保留id, 过敏药物id, 过敏药物
    From 病人过敏药物
    Where 病人id = v_合并id And 过敏药物id Not In (Select 过敏药物id From 病人过敏药物 Where 病人id = v_保留id);
  Delete From 病人过敏药物 Where 病人id = v_合并id;

  --病人社区信息
  Insert Into 病人社区信息
    (病人id, 社区, 社区号, 标志, 就诊类型, 就诊时间)
    Select v_保留id, 社区, 社区号, 标志, 就诊类型, 就诊时间
    From 病人社区信息
    Where 病人id = v_合并id And 社区 Not In (Select 社区 From 病人社区信息 Where 病人id = v_保留id);
  Delete From 病人社区信息 Where 病人id = v_合并id;

  --病人免疫记录
  Insert Into 病人免疫记录
    (病人id, 接种时间, 接种名称)
    Select v_保留id, a.接种时间, a.接种名称
    From 病人免疫记录 A
    Where a.病人id = v_合并id And Not Exists (Select 1 From 病人免疫记录 Where 病人id = v_保留id And 接种时间 = a.接种时间);
  Delete From 病人免疫记录 Where 病人id = v_合并id;

  --病人信息从表
  Insert Into 病人信息从表
    (病人id, 信息名, 信息值, 就诊id)
    Select v_保留id, a.信息名, a.信息值, a.就诊id
    From 病人信息从表 A
    Where a.病人id = v_合并id And Not Exists (Select 1
           From 病人信息从表
           Where 病人id = v_保留id And 信息名 = a.信息名 And Nvl(就诊id, 0) = Nvl(a.就诊id, 0));
  Delete From 病人信息从表 Where 病人id = v_合并id;

  --病人医疗卡属性
  Insert Into 病人医疗卡属性
    (病人id, 卡类别id, 卡号, 信息名, 信息值)
    Select v_保留id, a.卡类别id, a.卡号, a.信息名, a.信息值
    From 病人医疗卡属性 A
    Where a.病人id = v_合并id And Not Exists (Select 1
           From 病人医疗卡属性
           Where 病人id = v_保留id And 卡类别id = a.卡类别id And 卡号 = a.卡号 And 信息名 = a.信息名);
  Delete From 病人医疗卡属性 Where 病人id = v_合并id;

  --门诊病案记录
  Select Count(*) Into v_Count From 门诊病案记录 Where 病人id = v_保留id;
  If v_Count = 0 Then
    Select Count(*) Into v_Count From 门诊病案记录 Where 病人id = v_合并id;
    If v_Count > 0 Then
      Update 门诊病案记录 Set 病人id = v_保留id Where 病人id = v_合并id;
    End If;
  Else
    Delete From 门诊病案记录 Where 病人id = v_合并id;
  End If;

  --住院病案记录
  Select Count(*) Into v_Count From 住院病案记录 Where 病人id = v_保留id;

  If v_Count = 0 Then
    Select Count(*) Into v_Count From 住院病案记录 Where 病人id = v_合并id;
    If v_Count > 0 Then
      Update 住院病案记录 Set 病人id = v_保留id Where 病人id = v_合并id;
    End If;
  Else
    Begin
      v_Sql := 'Delete From 借阅记录 Where 病人ID=:1';
      Execute Immediate v_Sql
        Using v_合并id;
    Exception
      When Others Then
        Null;
    End;
  
    Delete From 住院病案记录 Where 病人id = v_合并id;
  End If;

  --医保病人相关处理
  --即使合病或保留的病人当前不是医保帐户,只要曾是医保帐户,险类不同也不能合并
  Select Count(Distinct 险类) Into v_Count From 医保病人关联表 Where 病人id In (v_合并id, v_保留id);
  If v_Count = 2 Then
    Close c_Infoa;
    Close c_Infob;
    v_Error := '两个病人分别属于不同的保险类别，不允许合并。';
    Raise Err_Custom;
  End If;

  Select Count(*) Into v_Count From 医保病人关联表 Where 病人id = v_合并id And 标志 = 0;
  --a.合并的病人以前是医保帐户,现在不是
  If v_Count > 0 Then
    Select Count(*) Into v_Count From 医保病人关联表 Where 病人id = v_保留id;
    --a.1保留的病人现在是医保帐户
    --a.2.1保留的病人现在不是医保帐户,以前是,与a.1相同处理
    If v_Count > 0 Then
      Delete From 帐户年度信息 Where 病人id = v_合并id;
    
      Select Count(Distinct 医保号) Into v_Count From 医保病人关联表 Where 病人id In (v_合并id, v_保留id);
      If v_Count <> 2 Then
        --两个病人医保号相同时,不用处理医保病人档案
        For r_Insure In c_Insure(v_合并id) Loop
          --被合并的病人可能关联了多个医保病人,改为关联到保留的病人上
          --问题27445 保留指定病人的门诊号、住院号、医保号
          If v_合并id = B病人id_In Then
            Update 医保病人关联表
            Set 医保号 =
                 (Select 医保号 From 医保病人关联表 Where 病人id = v_合并id), 标志 = 0
            Where 险类 = r_Insure.险类 And 中心 = r_Insure.中心 And 医保号 = r_Insure.医保号 And 病人id <> v_合并id;
          Else
            Update 医保病人关联表
            Set 医保号 =
                 (Select 医保号 From 医保病人关联表 Where 病人id = v_保留id), 标志 = 0
            Where 险类 = r_Insure.险类 And 中心 = r_Insure.中心 And 医保号 = r_Insure.医保号 And 病人id <> v_合并id;
          End If;
          --合并的病人现在不是医保,即使是用户指定要保留该病人,也不保留它的帐户信息
          Delete From 医保病人档案 Where 险类 = r_Insure.险类 And 医保号 = r_Insure.医保号;
        End Loop;
      End If;
      Delete From 医保病人关联表 Where 病人id = v_合并id;
    Else
      --a.2.2保留的病人现在和以前都不是医保帐户
      Update 帐户年度信息 Set 病人id = v_保留id Where 病人id = v_合并id;
      Update 医保病人关联表 Set 病人id = v_保留id Where 病人id = v_合并id;
      --医保病人档案表不用处理,因为通过医保号关联<医保病人关联表>
    End If;
  Else
    Select Count(*) Into v_Count From 医保病人关联表 Where 病人id = v_合并id And 标志 = 1;
    --b.合并的病人现在是医保帐户
    If v_Count > 0 Then
      Select Count(*) Into v_Count From 医保病人关联表 Where 病人id = v_保留id;
      --b.1保留的病人现在也是医保帐户
      --b.2.1保留的病人现在不是医保帐户,以前是,与b.1相同处理
      If v_Count > 0 Then
        For r_Insure In c_Insure(v_合并id) Loop
          --转移帐户年度信息
          For r_Year In c_Year(v_合并id, r_Insure.险类) Loop
            Update 帐户年度信息
            Set 帐户增加累计 = Nvl(帐户增加累计, 0) + Nvl(r_Year.帐户增加累计, 0), 帐户支出累计 = Nvl(帐户支出累计, 0) + Nvl(r_Year.帐户支出累计, 0),
                进入统筹累计 = Nvl(进入统筹累计, 0) + Nvl(r_Year.进入统筹累计, 0), 统筹报销累计 = Nvl(统筹报销累计, 0) + Nvl(r_Year.统筹报销累计, 0),
                住院次数累计 = Nvl(住院次数累计, 0) + Nvl(r_Year.住院次数累计, 0), 大额统筹累计 = Nvl(大额统筹累计, 0) + Nvl(r_Year.大额统筹累计, 0),
                起付线累计 = Nvl(起付线累计, 0) + Nvl(r_Year.起付线累计, 0), 本次起付线 = Nvl(本次起付线, r_Year.本次起付线),
                基本统筹限额 = Nvl(基本统筹限额, r_Year.基本统筹限额), 大额统筹限额 = Nvl(大额统筹限额, r_Year.大额统筹限额), 封销信息 = Nvl(封销信息, r_Year.封销信息)
            Where 病人id = v_保留id And 险类 = r_Insure.险类 And 年度 = r_Year.年度;
            If Sql%RowCount = 0 Then
              Insert Into 帐户年度信息
                (病人id, 险类, 年度, 帐户增加累计, 帐户支出累计, 进入统筹累计, 统筹报销累计, 住院次数累计, 本次起付线, 基本统筹限额, 大额统筹限额, 起付线累计, 大额统筹累计, 封销信息)
              Values
                (v_保留id, r_Insure.险类, r_Year.年度, r_Year.帐户增加累计, r_Year.帐户支出累计, r_Year.进入统筹累计, r_Year.统筹报销累计,
                 r_Year.住院次数累计, r_Year.本次起付线, r_Year.基本统筹限额, r_Year.大额统筹限额, r_Year.起付线累计, r_Year.大额统筹累计, r_Year.封销信息);
            End If;
          End Loop;
          Delete From 帐户年度信息 Where 病人id = v_合并id;
        
          Select Count(Distinct 医保号) Into v_Count From 医保病人关联表 Where 病人id In (v_合并id, v_保留id);
          If v_Count <> 2 Then
            --两个病人医保号相同时,不用处理医保病人档案
            If v_合并id = B病人id_In Then
              Update 医保病人关联表
              Set 标志 = 0
              Where (险类, 中心, 医保号) In (Select 险类, 中心, 医保号 From 医保病人关联表 Where 病人id = v_保留id);
              Update 医保病人关联表 Set 标志 = 1 Where 病人id = v_保留id;
            End If;
            Delete From 医保病人关联表 Where 病人id = v_合并id;
          Else
            --被合并的病人可能关联了多个医保病人,改为关联到保留的病人上
            --问题27445 保留指定病人的门诊号、住院号、医保号
            If v_合并id = B病人id_In Then
              Update 医保病人关联表
              Set 医保号 =
                   (Select 医保号 From 医保病人关联表 Where 病人id = v_合并id), 标志 = 0
              Where 险类 = r_Insure.险类 And 中心 = r_Insure.中心 And 医保号 = r_Insure.医保号 And 病人id <> v_合并id;
            Else
              Update 医保病人关联表
              Set 医保号 =
                   (Select 医保号 From 医保病人关联表 Where 病人id = v_保留id), 标志 = 0
              Where 险类 = r_Insure.险类 And 中心 = r_Insure.中心 And 医保号 = r_Insure.医保号 And 病人id <> v_合并id;
            End If;
            --暂存用户指定要保留病人的帐户信息
            If v_合并id = B病人id_In Then
              Open c_Keepinsure(B病人id_In, r_Insure.险类);
              Fetch c_Keepinsure
                Into r_Keepinsure;
            End If;
          
            Delete From 医保病人关联表 Where 病人id = v_合并id;
            Delete From 医保病人档案 Where 险类 = r_Insure.险类 And 医保号 = r_Insure.医保号;
          
            --保留用户指定要保留病人的帐户信息
            If v_合并id = B病人id_In Then
              If c_Keepinsure%RowCount > 0 Then
                Update 医保病人档案
                Set 卡号 = r_Keepinsure.卡号, 医保号 = r_Keepinsure.医保号, 密码 = r_Keepinsure.密码, 人员身份 = r_Keepinsure.人员身份,
                    单位编码 = r_Keepinsure.单位编码, 顺序号 = r_Keepinsure.顺序号, 退休证号 = r_Keepinsure.退休证号, 帐户余额 = r_Keepinsure.帐户余额,
                    当前状态 = r_Keepinsure.当前状态, 病种id = r_Keepinsure.病种id, 在职 = r_Keepinsure.在职, 年龄段 = r_Keepinsure.年龄段,
                    灰度级 = r_Keepinsure.灰度级, 就诊时间 = r_Keepinsure.就诊时间
                Where (险类, 中心, 医保号) In (Select 险类, 中心, 医保号 From 医保病人关联表 Where 病人id = v_保留id);
                --保留病人可能关联了多个医保病人,都要更改医保号
                Update 医保病人关联表
                Set 医保号 = r_Keepinsure.医保号, 标志 = 0
                Where (险类, 中心, 医保号) In (Select 险类, 中心, 医保号 From 医保病人关联表 Where 病人id = v_保留id);
                Update 医保病人关联表 Set 标志 = 1 Where 病人id = v_保留id;
              End If;
              Close c_Keepinsure;
            End If;
          End If;
        End Loop;
      Else
        --b.2.2保留的病人现在和以前都不是医保帐户
        Update 帐户年度信息 Set 病人id = v_保留id Where 病人id = v_合并id;
        Update 医保病人关联表 Set 病人id = v_保留id Where 病人id = v_合并id;
        --医保病人档案表不用处理,因为通过医保号关联<医保病人关联表>
      End If;
    Else
      --c.合并的病人以前和现在都不是医保帐户,不作任何处理
      Null;
    End If;
  End If;

  --处理体检子系统的病人合并
  n_Have := 0;
  Begin
    Select 1 Into n_Have From zlSystems Where Floor(编号 / 100) = 21;
  Exception
    When Others Then
      Null;
  End;
  If n_Have = 1 Then
    v_Sql := 'Begin zl21_病人信息_Merge(:1,:2); End;';
    Execute Immediate v_Sql
      Using v_合并id, v_保留id;
  End If;

  --其它病人,病案主页相关表
  For v_Loop In 1 .. Arronpage.Count Loop
    --Executesql('Update ' || Arronpage(v_Loop) || ' Set 病人ID=' || v_保留id || ' Where 病人ID=' || v_合并id || ' And Nvl(主页ID,0) = 0');
    --"主页=0，主页ID is NULL，主页ID=挂号ID"都有可能，前面部分与主页ID关联都没处理到，因此不加条件
    v_Sql := 'Update ' || Arronpage(v_Loop) || ' Set 病人ID=:1 Where 病人ID=:2';
    Execute Immediate v_Sql
      Using v_保留id, v_合并id;
  End Loop;
  For v_Loop In 1 .. Arronbase.Count Loop
    If Arronbase(v_Loop) = '病人照片' Then
      Select Count(1) Into n_Have From 病人照片 Where 病人id = v_保留id;
      If n_Have = 1 Then
        Delete From 病人照片 Where 病人id = v_合并id;
      End If;
    End If;
    v_Sql := 'Update ' || Arronbase(v_Loop) || ' Set 病人ID=:1 Where 病人ID=:2';
    Execute Immediate v_Sql
      Using v_保留id, v_合并id;
  End Loop;

  --删除实际不保留的病人信息
  Delete From 病人信息 Where 病人id = v_合并id;

  --根据界面选择保留病人信息
  Update 病人信息
  Set 姓名 = Nvl(r_Infob.姓名, r_Infoa.姓名), 性别 = Nvl(r_Infob.性别, r_Infoa.性别), 年龄 = Nvl(r_Infob.年龄, r_Infoa.年龄), 门诊号 = v_门诊号,
      住院号 = v_住院号, 就诊卡号 = Nvl(r_Infob.就诊卡号, r_Infoa.就诊卡号), 卡验证码 = Decode(r_Infob.就诊卡号, Null, r_Infoa.卡验证码, r_Infob.卡验证码),
      费别 = Nvl(r_Infob.费别, r_Infoa.费别), 医疗付款方式 = Nvl(r_Infob.医疗付款方式, r_Infoa.医疗付款方式),
      出生日期 = Nvl(r_Infob.出生日期, r_Infoa.出生日期), 出生地点 = Nvl(r_Infob.出生地点, r_Infoa.出生地点),
      身份证号 = Nvl(r_Infob.身份证号, r_Infoa.身份证号), 身份 = Nvl(r_Infob.身份, r_Infoa.身份), 职业 = Nvl(r_Infob.职业, r_Infoa.职业),
      民族 = Nvl(r_Infob.民族, r_Infoa.民族), 国籍 = Nvl(r_Infob.国籍, r_Infoa.国籍), 学历 = Nvl(r_Infob.学历, r_Infoa.学历),
      籍贯 = Nvl(r_Infob.籍贯, r_Infoa.籍贯), 区域 = Nvl(r_Infob.区域, r_Infoa.区域), 婚姻状况 = Nvl(r_Infob.婚姻状况, r_Infoa.婚姻状况),
      家庭地址 = Nvl(r_Infob.家庭地址, r_Infoa.家庭地址), 家庭电话 = Nvl(r_Infob.家庭电话, r_Infoa.家庭电话),
      家庭地址邮编 = Nvl(r_Infob.家庭地址邮编, r_Infoa.家庭地址邮编), 户口地址 = Nvl(r_Infob.户口地址, r_Infoa.户口地址),
      户口地址邮编 = Nvl(r_Infob.户口地址邮编, r_Infoa.户口地址邮编), 联系人姓名 = Nvl(r_Infob.联系人姓名, r_Infoa.联系人姓名),
      联系人关系 = Nvl(r_Infob.联系人关系, r_Infoa.联系人关系), 联系人地址 = Nvl(r_Infob.联系人地址, r_Infoa.联系人地址),
      联系人电话 = Nvl(r_Infob.联系人电话, r_Infoa.联系人电话), 合同单位id = Nvl(r_Infob.合同单位id, r_Infoa.合同单位id),
      工作单位 = Nvl(r_Infob.工作单位, r_Infoa.工作单位), 单位电话 = Nvl(r_Infob.单位电话, r_Infoa.单位电话),
      单位邮编 = Nvl(r_Infob.单位邮编, r_Infoa.单位邮编), 单位开户行 = Nvl(r_Infob.单位开户行, r_Infoa.单位开户行),
      单位帐号 = Nvl(r_Infob.单位帐号, r_Infoa.单位帐号), 就诊时间 = Nvl(r_Infob.就诊时间, r_Infoa.就诊时间),
      就诊状态 = Nvl(r_Infob.就诊状态, r_Infoa.就诊状态), 就诊诊室 = Nvl(r_Infob.就诊诊室, r_Infoa.就诊诊室), 险类 = Nvl(r_Infob.险类, r_Infoa.险类),
      登记时间 = Nvl(r_Infob.登记时间, r_Infoa.登记时间), 住院次数 = Null, 主页id = Null, 当前床号 = Null, 当前科室id = Null, 当前病区id = Null,
      入院时间 = Null, 出院时间 = Null, 在院 = Decode(Nvl(r_Infob.在院, 0), 1, 1, Null), 健康号 = Nvl(r_Infob.健康号, r_Infoa.健康号)
  Where 病人id = v_保留id;

  Open c_Info(v_保留id);
  Fetch c_Info
    Into r_Info;
  If c_Info%RowCount > 0 Then
    --最后一次为预约病人,只需要更改住院次数和入院时间
    If r_Info.主页id = 0 Then
      Update 病人信息
      Set 主页id = Decode(r_Info.最大主页id, 0, Null, r_Info.最大主页id), 住院次数 = Decode(n_Max住院次数, 0, Null, n_Max住院次数)
      Where 病人id = v_保留id;
    Else
      Update 病人信息
      Set 主页id = Decode(r_Info.最大主页id, 0, Null, r_Info.最大主页id), 住院次数 = Decode(n_Max住院次数, 0, Null, n_Max住院次数),
          当前床号 = Decode(r_Info.出院日期, Null, r_Info.出院病床, Null), 当前病区id = Decode(r_Info.出院日期, Null, r_Info.当前病区id, Null),
          当前科室id = Decode(r_Info.出院日期, Null, r_Info.出院科室id, Null), 入院时间 = r_Info.入院日期, 出院时间 = r_Info.出院日期




      
      Where 病人id = v_保留id;
    End If;
    --处理担保信息
    Select Nvl(主页id, -1) Into n_主页id From 病人信息 Where 病人id = v_保留id;
    --提取当前有效的正常担保记录,确保正常担保与临时担保不并存
    Select Nvl(Sum(担保额), 0), Count(病人id)
    Into n_担保额, n_Row
    From 病人担保记录
    Where 病人id = v_保留id And Nvl(主页id, -1) = n_主页id And (到期时间 Is Null Or 到期时间 > Sysdate) And 担保性质 = 0 And 删除标志 = 1;
    If n_Row = 0 Then
      --保留最后一条临时担保记录,其余到期
      Update 病人担保记录
      Set 到期时间 = Sysdate - 1 / 24 / 60 / 60
      Where 病人id = v_保留id And Nvl(主页id, -1) = n_主页id And 担保性质 = 1 And (到期时间 Is Null Or 到期时间 > Sysdate) And 删除标志 = 1 And
            登记时间 <> (Select Max(登记时间)
                     From 病人担保记录
                     Where 病人id = v_保留id And Nvl(主页id, -1) = n_主页id And 担保性质 = 1 And (到期时间 Is Null Or 到期时间 > Sysdate) And
                           删除标志 = 1);
    Else
      --有正常担保就让临时担保失效
      Update 病人担保记录
      Set 到期时间 = Sysdate - 1 / 24 / 60 / 60
      Where 病人id = v_保留id And Nvl(主页id, -1) = n_主页id And 担保性质 = 1 And (到期时间 Is Null Or 到期时间 > Sysdate) And 删除标志 = 1;
    End If;
  
    --提取当前有效担保额及有效担保记录数
    n_Row    := 0;
    n_担保额 := 0;
    v_担保人 := '';
    For r_提保信息 In (Select 担保人, 担保额
                   From 病人担保记录
                   Where 病人id = v_保留id And Nvl(主页id, -1) = n_主页id And (到期时间 Is Null Or 到期时间 > Sysdate) And 删除标志 = 1) Loop
      n_Row     := n_Row + 1;
      n_担保额  := n_担保额 + r_提保信息.担保额;
      v_担保人  := v_担保人 || ',' || r_提保信息.担保人;
      n_Lengthb := Lengthb(v_担保人);
      If n_Lengthb >= 101 Then
        v_Error := '不能合并担保记录，在病人信息保存时超过担保人字段长度！';
        Raise Err_Custom;
      End If;
    End Loop;
    v_担保人 := Substr(v_担保人, 2, 100);
  
    If n_Row = 0 Then
      Update 病人信息 Set 担保人 = Null, 担保额 = Null, 担保性质 = Null Where 病人id = v_保留id;
    Else
      --提取最后一条有效担保人和担保性质
      Select 担保性质
      Into n_担保性质
      From 病人担保记录
      Where 病人id = v_保留id And Nvl(主页id, -1) = n_主页id And 删除标志 = 1 And
            登记时间 =
            (Select Max(登记时间)
             From 病人担保记录
             Where 病人id = v_保留id And Nvl(主页id, -1) = n_主页id And (到期时间 Is Null Or 到期时间 > Sysdate) And 删除标志 = 1);
    
      Update 病人信息 Set 担保人 = v_担保人, 担保额 = n_担保额, 担保性质 = n_担保性质 Where 病人id = v_保留id;
    End If;
  End If;

  Close c_Info;
  Close c_Infoa;
  Close c_Infob;

  --对病人进行解锁
  Update 病人信息 Set 锁定 = 0 Where 病人id In (A病人id_In, B病人id_In);
Exception
  When Err_Custom Then
    Begin
      Rollback; --不然会死锁
      Zl_病人信息_锁定(A病人id_In, 0);
      Zl_病人信息_锁定(B病人id_In, 0);
      Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
    End;
  When Others Then
    Begin
      Rollback; --不然会死锁
      Zl_病人信息_锁定(A病人id_In, 0);
      Zl_病人信息_锁定(B病人id_In, 0);
      zl_ErrorCenter(SQLCode, SQLErrM);
    End;
End Zl_病人信息_Merge;
/

--110094:蒋廷中,2017-06-12,修改结构化乡镇地址不自动匹配数据保留原数据
Create Or Replace Function Zl_Adderss_Structure(v_Addressinfo Varchar2) Return Varchar2 Is
  --返回结构：省,省编码,是否虚拟,是否不显示,是否只有虚拟级|市,市编码,是否虚拟,是否不显示,是否只有虚拟级 
  --          |区县,区县编码,是否虚拟,是否不显示,是否只有虚拟级|乡镇,乡镇编码,是否虚拟,是否不显示,是否只有虚拟级 
  --          |街道,街道编码,是否虚拟,是否不显示,是否只有虚拟级 
  v_省       Varchar2(100);
  v_Code省   Varchar2(15);
  v_Info省   Varchar2(150);
  v_市       Varchar2(100);
  v_Code市   Varchar2(15);
  v_Info市   Varchar2(150);
  v_区县     Varchar2(100);
  v_Code区县 Varchar2(15);
  v_Info区县 Varchar2(150);
  v_乡镇     Varchar2(100);
  v_Code乡镇 Varchar2(15);
  v_Info乡镇 Varchar2(150);
  v_街道     Varchar2(500);
  v_Code街道 Varchar2(15);
  v_Info街道 Varchar2(550);
  v_Tmp      Varchar2(100);
  v_Adrstmp  Varchar2(500);
  n_Pos      Number(5);
  n_虚拟     Number(1);
  n_不显示   Number(1);
  n_Count    Number(3);
  v_Return   Varchar2(700);
Begin
  --传入结构化的地址，不用进行地址标准化分割解析 
  v_Adrstmp := v_Addressinfo;
  If v_Addressinfo Like '%,%,%,%,%' Then
    n_Pos     := Instr(v_Adrstmp, ',');
    v_省      := Substr(v_Adrstmp, 1, n_Pos - 1);
    v_Adrstmp := Substr(v_Adrstmp, n_Pos + 1);
    n_Pos     := Instr(v_Adrstmp, ',');
    v_市      := Substr(v_Adrstmp, 1, n_Pos - 1);
    v_Adrstmp := Substr(v_Adrstmp, n_Pos + 1);
    n_Pos     := Instr(v_Adrstmp, ',');
    v_区县    := Substr(v_Adrstmp, 1, n_Pos - 1);
    v_Adrstmp := Substr(v_Adrstmp, n_Pos + 1);
    n_Pos     := Instr(v_Adrstmp, ',');
    v_乡镇    := Substr(v_Adrstmp, 1, n_Pos - 1);
    v_街道    := Substr(v_Adrstmp, n_Pos + 1);
    Select Max(编码) Into v_Code省 From 区域 Where 名称 = v_省 And Nvl(级数, 0) = 0;
    --省级地址都没有，就不做处理 
    If v_Code省 Is Not Null Then
      Select Max(编码), Max(是否虚拟), Max(是否不显示)
      Into v_Code市, n_虚拟, n_不显示
      From 区域
      Where 名称 = v_市 And Nvl(级数, 0) = 1 And 上级编码 = v_Code省;
      If v_Code市 Is Not Null Then
        v_Info市 := v_市 || ',' || v_Code市 || ',' || n_虚拟 || ',' || n_不显示;
        Select Max(编码), Max(是否虚拟), Max(是否不显示)
        Into v_Code区县, n_虚拟, n_不显示
        From 区域
        Where 名称 = v_区县 And Nvl(级数, 0) = 2 And 上级编码 = v_Code市;
        --可能是虚拟地址 
      Else
        Select Max(编码), Max(上级编码)
        Into v_Code区县, v_Code市
        From 区域
        Where 名称 = v_区县 And Nvl(级数, 0) = 2 And 上级编码 In (Select 编码 From 区域 Where 上级编码 = v_Code省);
        If v_Code市 Is Not Null Then
          Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示)
          Into v_市, v_Code市, n_虚拟, n_不显示
          From 区域
          Where 编码 = v_Code市;
        End If;
        v_Info市 := v_市 || ',' || v_Code市 || ',' || n_虚拟 || ',' || n_不显示;
        Select Max(编码), Max(是否虚拟), Max(是否不显示)
        Into v_Code区县, n_虚拟, n_不显示
        From 区域
        Where 编码 = v_Code区县;
      End If;
      v_Info区县 := v_区县 || ',' || v_Code区县 || ',' || n_虚拟 || ',' || n_不显示;
      If v_Code区县 Is Not Null Then
        --可能乡镇在详细地址中，关联参数乡镇地址结构化录入 

        Select Max(编码), Max(是否虚拟), Max(是否不显示)
        Into v_Code乡镇, n_虚拟, n_不显示
        From 区域
        Where 名称 = v_乡镇 And Nvl(级数, 0) = 3 And 上级编码 = v_Code区县;
        --可能是虚拟地址 
        If v_Code乡镇 Is Null Then
          Select Max(编码), Max(上级编码)
          Into v_Code街道, v_Code乡镇
          From 区域
          Where 名称 = v_街道 And Nvl(级数, 0) = 4 And 上级编码 In (Select 编码 From 区域 Where 上级编码 = v_Code区县);
          If v_Code乡镇 Is Not Null Then
            Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示)
            Into v_乡镇, v_Code乡镇, n_虚拟, n_不显示
            From 区域
            Where 编码 = v_Code乡镇;
          End If;
        End If;
        v_Info乡镇 := v_乡镇 || ',' || v_Code乡镇 || ',' || n_虚拟 || ',' || n_不显示;
        If v_Code乡镇 Is Not Null Then
          Select Max(编码), Max(是否虚拟), Max(是否不显示)
          Into v_Code街道, n_虚拟, n_不显示
          From 区域
          Where 名称 = v_街道 And Nvl(级数, 0) = 4 And 上级编码 = v_Code乡镇;
          v_Info街道 := v_街道 || ',' || v_Code街道 || ',' || n_虚拟 || ',' || n_不显示;
        End If;
      End If;
    End If;
    --非标准地址，是完整地址，需要分割省，市，县, 
  Else
    v_Adrstmp := v_Addressinfo;
    v_Tmp     := Substr(v_Adrstmp, 1, 2);
    Select Max(名称), Max(编码) Into v_省, v_Code省 From 区域 Where 名称 Like v_Tmp || '%' And Nvl(级数, 0) = 0;
    --有省级地址，说明可以结构化 
    If v_Code省 Is Not Null Then
      --省级地址是标准的 
      If Substr(v_Adrstmp, 1, Length(v_省)) = v_省 Then
        v_Adrstmp := Substr(v_Adrstmp, Length(v_省) + 1);
        --省级地址不标准,可能新疆省略自治区等,此时，市级地址可能是标准化的。 
      Else
        --先判断二级地址是否存在虚拟地址与不显示的地址 
        If v_Tmp = '内蒙' Then
          v_Tmp := '内蒙古';
        Elsif v_Tmp = '黑龙' Then
          v_Tmp := '黑龙江';
        End If;
        v_Adrstmp := Substr(v_Adrstmp, Length(v_Tmp) + 1);
      End If;
      --先截取市级的两个字做关键字，来匹配 
      v_Tmp := Substr(v_Adrstmp, 1, 2);
      Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示), Count(1)
      Into v_市, v_Code市, n_虚拟, n_不显示, n_Count
      From 区域
      Where 名称 Like v_Tmp || '%' And Nvl(级数, 0) = 1 And 上级编码 = v_Code省;
      --存在多行匹配，则继续增加长度，暂时从2个字增加到3个字匹配 
      If n_Count > 1 Then
        v_Tmp := Substr(v_Adrstmp, 1, 3);
        Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示)
        Into v_市, v_Code市, n_虚拟, n_不显示
        From 区域
        Where 名称 Like v_Tmp || '%' And Nvl(级数, 0) = 1 And 上级编码 = v_Code省;
      End If;
      --判断是否存在虚拟地址或不显示的地址导致的,如果存在，则根据第三级地址来确定虚拟地址 
      --可能是没有第二级，因此需要第三级判断
      If v_Code市 Is Null Then
        Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示), Count(1), Max(上级编码)
        Into v_区县, v_Code区县, n_虚拟, n_不显示, n_Count, v_Code市
        From 区域
        Where 名称 Like v_Tmp || '%' And Nvl(级数, 0) = 2 And 上级编码 In (Select 编码 From 区域 Where 上级编码 = v_Code省);
        --存在多行匹配，则继续增加长度，暂时从2个字增加到3个字匹配 
        If n_Count > 1 Then
          v_Tmp := Substr(v_Adrstmp, 1, 3);
          Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示), Max(上级编码)
          Into v_区县, v_Code区县, n_虚拟, n_不显示, v_Code市
          From 区域
          Where 名称 Like v_Tmp || '%' And Nvl(级数, 0) = 2 And 上级编码 In (Select 编码 From 区域 Where 上级编码 = v_Code省);
        End If;
        If v_Code市 Is Not Null Then
          v_Info区县 := v_区县 || ',' || v_Code区县 || ',' || n_虚拟 || ',' || n_不显示;
          v_Adrstmp  := Substr(v_Adrstmp, Length(v_区县) + 1);
          Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示)
          Into v_市, v_Code市, n_虚拟, n_不显示
          From 区域
          Where 编码 = v_Code市;
          v_Info市 := v_市 || ',' || v_Code市 || ',' || n_虚拟 || ',' || n_不显示;
        End If;
      Else
        v_Info市  := v_市 || ',' || v_Code市 || ',' || n_虚拟 || ',' || n_不显示;
        v_Adrstmp := Substr(v_Adrstmp, Length(v_市) + 1);
      End If;
      --没有区县，则解析区县 
      If Not v_Code市 Is Null And v_Code区县 Is Null Then
        --先截取县级的两个字做关键字，来匹配 
        v_Tmp := Substr(v_Adrstmp, 1, 2);
        Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示), Count(1)
        Into v_区县, v_Code区县, n_虚拟, n_不显示, n_Count
        From 区域
        Where 名称 Like v_Tmp || '%' And Nvl(级数, 0) = 2 And 上级编码 = v_Code市;
        --存在多行匹配，则继续增加长度，暂时从2个字增加到3个字匹配 
        If n_Count > 1 Then
          v_Tmp := Substr(v_Adrstmp, 1, 3);
          Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示)
          Into v_区县, v_Code区县, n_虚拟, n_不显示
          From 区域
          Where 名称 Like v_Tmp || '%' And Nvl(级数, 0) = 2 And 上级编码 = v_Code市;
        End If;
        If v_Code区县 Is Null Then
          Select Max(是否虚拟), Max(是否不显示) Into n_虚拟, n_不显示 From 区域 Where 上级编码 = v_Code市;
          If Nvl(n_虚拟, 0) = 1 Or Nvl(n_不显示, 0) = 1 Then
            Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示), Count(1), Max(上级编码)
            Into v_乡镇, v_Code乡镇, n_虚拟, n_不显示, n_Count, v_Code区县
            From 区域
            Where 名称 Like v_Tmp || '%' And Nvl(级数, 0) = 3 And 上级编码 In (Select 编码 From 区域 Where 上级编码 = v_Code市);
            --存在多行匹配，则继续增加长度，暂时从2个字增加到3个字匹配 
            If n_Count > 1 Then
              v_Tmp := Substr(v_Adrstmp, 1, 3);
              Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示), Max(上级编码)
              Into v_乡镇, v_Code乡镇, n_虚拟, n_不显示, v_Code区县
              From 区域
              Where 名称 Like v_Tmp || '%' And Nvl(级数, 0) = 3 And 上级编码 In (Select 编码 From 区域 Where 上级编码 = v_Code市);
            End If;
          
            If v_Code乡镇 Is Not Null Then
              v_Info乡镇 := v_乡镇 || ',' || v_Code乡镇 || ',' || n_虚拟 || ',' || n_不显示;
              v_Adrstmp  := Substr(v_Adrstmp, Length(v_乡镇) + 1);
              Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示)
              Into v_区县, v_Code区县, n_虚拟, n_不显示
              From 区域
              Where 编码 = v_Code区县;
              v_Info区县 := v_区县 || ',' || v_Code区县 || ',' || n_虚拟 || ',' || n_不显示;
            End If;
          End If;
        Else
          v_Info区县 := v_区县 || ',' || v_Code区县 || ',' || n_虚拟 || ',' || n_不显示;
          v_Adrstmp  := Substr(v_Adrstmp, Length(v_区县) + 1);
        End If;
      End If;
      If v_Code区县 Is Not Null And v_Code乡镇 Is Null Then
        --先截取乡镇级的两个字做关键字，来匹配 
        v_Tmp := Substr(v_Adrstmp, 1, 2);
        Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示), Count(1)
        Into v_乡镇, v_Code乡镇, n_虚拟, n_不显示, n_Count
        From 区域
        Where 名称 Like v_Tmp || '%' And Nvl(级数, 0) = 3 And 上级编码 = v_Code区县;
        --存在多行匹配，则继续增加长度，暂时从2个字增加到3个字匹配 
        If n_Count > 1 Then
          v_Tmp := Substr(v_Adrstmp, 1, 3);
          Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示), Count(1)
          Into v_乡镇, v_Code乡镇, n_虚拟, n_不显示, n_Count
          From 区域
          Where 名称 Like v_Tmp || '%' And Nvl(级数, 0) = 3 And 上级编码 = v_Code区县;
        End If;
        If v_Code乡镇 Is Null Then
          Select Max(是否虚拟), Max(是否不显示) Into n_虚拟, n_不显示 From 区域 Where 上级编码 = v_Code区县;
          If Nvl(n_虚拟, 0) = 1 Or Nvl(n_不显示, 0) = 1 Then
            Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示), Count(1), Max(上级编码)
            Into v_街道, v_Code街道, n_虚拟, n_不显示, n_Count, v_Code乡镇
            From 区域
            Where 名称 = v_Adrstmp And 上级编码 In (Select 编码 From 区域 Where 上级编码 = v_Code区县);
          End If;
          If v_Code乡镇 Is Not Null Then
            v_Info街道 := v_街道 || ',' || v_Code街道 || ',' || n_虚拟 || ',' || n_不显示;
            Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示)
            Into v_乡镇, v_Code乡镇, n_虚拟, n_不显示
            From 区域
            Where 编码 = v_Code乡镇;
            v_Info乡镇 := v_乡镇 || ',' || v_Code乡镇 || ',' || n_虚拟 || ',' || n_不显示;
          End If;
        Else
          v_Info乡镇 := v_乡镇 || ',' || v_Code乡镇 || ',' || n_虚拟 || ',' || n_不显示;
          v_Adrstmp  := Substr(v_Adrstmp, Length(v_乡镇) + 1);
        End If;
        If v_Code乡镇 Is Not Null And v_Code街道 Is Null Then
          Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示)
          Into v_街道, v_Code街道, n_虚拟, n_不显示
          From 区域
          Where 名称 = v_Adrstmp And Nvl(级数, 0) = 4 And 上级编码 = v_Code乡镇;
          If v_Code街道 Is Not Null Then
            v_Info街道 := v_街道 || ',' || v_Code街道 || ',' || n_虚拟 || ',' || n_不显示;
          End If;
        End If;
      End If;
    End If;
    If v_街道 Is Null Then
      v_街道 := v_Adrstmp;
    End If;
  End If;
  v_Info省 := v_省 || ',' || v_Code省 || ',,,';
  If v_Info市 Is Null Then
    v_Info市 := v_市 || ',,,';
  End If;
  --只有省没有市，判断市是否只有虚拟级 
  If Not v_Code省 Is Null And v_市 Is Null Then
    Select Count(1)
    Into n_Count
    From 区域
    Where 上级编码 = v_Code省 And Nvl(是否虚拟, 0) = 0 And Nvl(是否不显示, 0) = 0 And Rownum < 2;
    If n_Count = 0 Then
      Select Count(1) Into n_Count From 区域 Where 上级编码 = v_Code省 And Rownum < 2;
      If n_Count = 0 Then
        v_Info市 := v_Info市 || ',';
      Else
        v_Info市 := v_Info市 || ',1';
      End If;
    Else
      v_Info市 := v_Info市 || ',';
    End If;
  Else
    v_Info市 := v_Info市 || ',';
  End If;
  If v_Info区县 Is Null Then
    v_Info区县 := v_区县 || ',,,';
  End If;
  --只有市没有区县，判断区县只有虚拟级 
  If Not v_Code市 Is Null And v_区县 Is Null Then
    Select Count(1)
    Into n_Count
    From 区域
    Where 上级编码 = v_Code市 And Nvl(是否虚拟, 0) = 0 And Nvl(是否不显示, 0) = 0 And Rownum < 2;
    If n_Count = 0 Then
      Select Count(1) Into n_Count From 区域 Where 上级编码 = v_Code市 And Rownum < 2;
      If n_Count = 0 Then
        v_Info区县 := v_Info区县 || ',';
      Else
        v_Info区县 := v_Info区县 || ',1';
      End If;
    Else
      v_Info区县 := v_Info区县 || ',';
    End If;
  Else
    v_Info区县 := v_Info区县 || ',';
  End If;
  If v_Info乡镇 Is Null Then
    v_Info乡镇 := v_乡镇 || ',,,';
  End If;
  --只有区县没有乡镇，判断乡镇是否只有虚拟的下级 
  If Not v_Code区县 Is Null And v_乡镇 Is Null Then
    Select Count(1)
    Into n_Count
    From 区域
    Where 上级编码 = v_Code区县 And Nvl(是否虚拟, 0) = 0 And Nvl(是否不显示, 0) = 0 And Rownum < 2;
    If n_Count = 0 Then
      Select Count(1) Into n_Count From 区域 Where 上级编码 = v_Code区县 And Rownum < 2;
      If n_Count = 0 Then
        v_Info乡镇 := v_Info乡镇 || ',';
      Else
        v_Info乡镇 := v_Info乡镇 || ',1';
      End If;
    Else
      v_Info乡镇 := v_Info乡镇 || ',';
    End If;
  Else
    v_Info乡镇 := v_Info乡镇 || ',';
  End If;
  If v_Info街道 Is Null Then
    v_Info街道 := v_街道 || ',,,,';
  Else
    v_Info街道 := v_Info街道 || ',';
  End If;
  v_Return := v_Info省 || '|' || v_Info市 || '|' || v_Info区县 || '|' || v_Info乡镇 || '|' || v_Info街道;
  Return(v_Return);
End;
/

--103213:胡俊勇,2017-06-08,转科变动撤销后医嘱无法发送
CREATE OR REPLACE Procedure Zl_病人医嘱发送_Insert
( 
  医嘱id_In     病人医嘱发送.医嘱id%Type, 
  发送号_In     病人医嘱发送.发送号%Type, 
  记录性质_In   病人医嘱发送.记录性质%Type, 
  No_In         病人医嘱发送.No%Type, 
  记录序号_In   病人医嘱发送.记录序号%Type, 
  发送数次_In   病人医嘱发送.发送数次%Type, 
  首次时间_In   病人医嘱发送.首次时间%Type, 
  末次时间_In   病人医嘱发送.末次时间%Type, 
  发送时间_In   病人医嘱发送.发送时间%Type, 
  执行状态_In   病人医嘱发送.执行状态%Type, 
  执行部门id_In 病人医嘱发送.执行部门id%Type, 
  计费状态_In   病人医嘱发送.计费状态%Type, 
  First_In      Number := 0, 
  样本条码_In   病人医嘱发送.样本条码%Type := Null, 
  操作员编号_In 人员表.编号%Type := Null, 
  操作员姓名_In 人员表.姓名%Type := Null, 
  领药号_In     未发药品记录.领药号%Type := Null, 
  门诊记帐_In   病人医嘱发送.门诊记帐%Type := Null, 
  分解时间_In   Varchar2 := Null 
  --功能：填写病人医嘱发送记录 
  --参数： 
  --      医嘱id_In=要发送的每个医嘱ID 
  --      First_IN=表示是否一组医嘱的第一医嘱行,以便处理医嘱相关内容(如成药,配方的第一行,因为给药途径,配方煎法,用法可能为叮嘱不发送) 
  --      发送数次_IN,首次时间_IN,末次时间_IN:对"持续性"长嘱,不填写发送数次,可填写首末次时间(用于回退)。 
  --      门诊记帐_In,住院临嘱发送到门诊记帐时才填写为1（因为记录性质是2，用于区分住院记帐），其余情况均填空。 
) Is 
  --包含病人及医嘱(一组医嘱中第一行)相关信息的游标 
  Cursor c_Advice Is 
    Select Nvl(a.相关id, a.Id) As 组id, a.序号, a.病人id, a.主页id, a.婴儿, a.姓名, a.病人科室id, c.操作类型, a.诊疗类别, a.医嘱期效, a.医嘱状态, a.医嘱内容, 
           a.开嘱医生, a.开嘱时间, a.开始执行时间, a.上次执行时间, a.执行终止时间, a.执行时间方案, a.频率次数, a.频率间隔, a.间隔单位, a.开嘱科室id, a.标本部位, a.执行科室id, 
           a.相关id, a.诊疗项目id 
    From 病人医嘱记录 A, 诊疗项目目录 C 
    Where a.诊疗项目id = c.Id And a.Id = 医嘱id_In; 
  r_Advice c_Advice%RowType; 
 
  --包含病人(婴儿)的所有未停长嘱(含配方长嘱),婴儿传入-1表示都处理 
  Cursor c_Needstop 
  ( 
    v_病人id   病人医嘱记录.病人id%Type, 
    v_主页id   病人医嘱记录.主页id%Type, 
    v_婴儿     病人医嘱记录.婴儿%Type, 
    v_Stoptime Date 
  ) Is 
    Select a.Id, a.诊疗类别, b.操作类型, b.执行频率 
    From 病人医嘱记录 A, 诊疗项目目录 B 
    Where a.诊疗项目id = b.Id(+) And a.病人id = v_病人id And a.主页id = v_主页id And (v_婴儿 = -1 Or Nvl(a.婴儿, 0) = Nvl(v_婴儿, 0)) And 
          Nvl(a.医嘱期效, 0) = 0 And a.医嘱状态 Not In (1, 2, 4, 8, 9) And a.开始执行时间 < v_Stoptime 
    Order By a.序号; 
  --包含病人(婴儿)的已停但未确认的长嘱,终止执行时间在指定时间之后,婴儿传入-1表示都处理 
  Cursor c_Havestop 
  ( 
    v_病人id   病人医嘱记录.病人id%Type, 
    v_主页id   病人医嘱记录.主页id%Type, 
    v_婴儿     病人医嘱记录.婴儿%Type, 
    v_Stoptime Date 
  ) Is 
    Select ID 
    From 病人医嘱记录 
    Where 病人id = v_病人id And 主页id = v_主页id And (v_婴儿 = -1 Or Nvl(婴儿, 0) = Nvl(v_婴儿, 0)) And Nvl(医嘱期效, 0) = 0 And 
          医嘱状态 = 8 And 执行终止时间 > v_Stoptime And 开始执行时间 < v_Stoptime 
    Order By 序号; 
 
  --其它临时变量 
  v_婴儿     病人医嘱记录.婴儿%Type; 
  v_持续性   Number(1); --是否持续性长嘱 
  v_Autostop Number(1); 
  v_Date     Date; 
  v_Temp     Varchar2(255); 
  v_人员编号 人员表.编号%Type; 
  v_人员姓名 人员表.姓名%Type; 
  v_停止时间 病人医嘱记录.开嘱时间%Type; 
  n_执行状态 病人医嘱发送.执行状态%Type; 
  d_开始时间 病人医嘱记录.开始执行时间%Type; 
 
  v_Stopadviceids 病人医嘱记录.医嘱内容%Type; 
  n_Adviceid      病人医嘱记录.病人id%Type; 
  n_标记          Number(18); 
  v_Error         Varchar2(255); 
  Err_Custom Exception; 
Begin 
  --当前操作人员 
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then 
    v_人员编号 := 操作员编号_In; 
    v_人员姓名 := 操作员姓名_In; 
  Else 
    v_Temp     := Zl_Identity; 
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1); 
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1); 
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1); 
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1); 
  End If; 
  --如果首次时间为空则填入开始执行时间 
  If 首次时间_In Is Null Or 分解时间_In Is Null Or 末次时间_In Is Null Then 
    Select 开始执行时间 Into d_开始时间 From 病人医嘱记录 Where ID = 医嘱id_In; 
  End If; 
 
  Open c_Advice; 
  Fetch c_Advice 
    Into r_Advice; 
  Close c_Advice; 
 
  --是一组医嘱的第一行时处理医嘱内容 
  If Nvl(First_In, 0) = 1 Then 
    --并发操作检查 
    --------------------------------------------------------------------------------------- 
    If Nvl(r_Advice.医嘱状态, 0) = 4 Then 
      --检查要发送的医嘱是否被作废 
      v_Error := '"' || r_Advice.姓名 || '"的医嘱"' || r_Advice.医嘱内容 || '"已经被其他人作废。' || Chr(13) || Chr(10) || 
                 '该病人的医嘱发送失败。请重新读取发送清单再试。'; 
      Raise Err_Custom; 
    End If; 
 
    If Nvl(r_Advice.医嘱期效, 0) = 0 Then 
      --长嘱：含成药长嘱,配方长嘱,非药"可选频率"长嘱,非药"持续性"长嘱 
 
      --检查长嘱是否已被发送 
      If r_Advice.上次执行时间 Is Not Null Then 
        If r_Advice.上次执行时间 >= 首次时间_In Then 
          v_Error := '"' || r_Advice.姓名 || '"的医嘱"' || r_Advice.医嘱内容 || '"已经被其他人发送。' || Chr(13) || Chr(10) || 
                     '该病人的医嘱发送失败。请重新读取发送清单再试。'; 
          Raise Err_Custom; 
        End If; 
      End If; 
 
      --检查长嘱发送前是否已被自动停止(如术后) 
      If r_Advice.执行终止时间 Is Not Null Then 
        If 首次时间_In > r_Advice.执行终止时间 Then 
          v_Error := '"' || r_Advice.姓名 || '"的医嘱"' || r_Advice.医嘱内容 || '"已经被停止。' || Chr(13) || Chr(10) || 
                     '该病人的医嘱发送失败。请重新读取发送清单再试。'; 
          Raise Err_Custom; 
        End If; 
      End If; 
    Elsif Nvl(r_Advice.医嘱状态, 0) In (8, 9) Then 
      --临嘱：含配方临嘱 
 
      --检查是否已被发送(或因其它原因自动停止) 
      v_Error := '"' || r_Advice.姓名 || '"的医嘱"' || r_Advice.医嘱内容 || '"已经被其他人发送。' || Chr(13) || Chr(10) || 
                 '该病人的医嘱发送失败。请重新读取发送清单再试。'; 
      Raise Err_Custom; 
    End If; 
 
    --发送后的医嘱处理 
    --------------------------------------------------------------------------------------- 
    If Nvl(r_Advice.医嘱期效, 0) = 0 Then 
      --长期医嘱:更新上次执行时间 
      Update 病人医嘱记录 Set 上次执行时间 = 末次时间_In Where ID = r_Advice.组id Or 相关id = r_Advice.组id; 
 
      --判断是否持续性长嘱 
      v_持续性 := 0; 
      If r_Advice.执行时间方案 Is Null And (Nvl(r_Advice.频率次数, 0) = 0 Or Nvl(r_Advice.频率间隔, 0) = 0 Or r_Advice.间隔单位 Is Null) Then 
        v_持续性 := 1; 
      End If; 
 
      --预定了终止时间且未停止的自动停止 
      If r_Advice.执行终止时间 Is Not Null And Nvl(r_Advice.医嘱状态, 0) Not In (8, 9) Then 
        v_Autostop := 0; 
        If v_持续性 = 1 Then 
          --非药"持续性"长嘱 
          If Trunc(末次时间_In) = Trunc(r_Advice.执行终止时间 - 1) Then 
            v_Autostop := 1; --终止这天不执行 
          End If; 
        Elsif Zl_Advicenexttime(医嘱id_In) > r_Advice.执行终止时间 Then 
          --成药长嘱或非药"可选频率"长嘱 
          v_Autostop := 1; --如果是等于,还可以执行一次 
        End If; 
 
        If v_Autostop = 1 Then 
          Update 病人医嘱记录 
          Set 医嘱状态 = 8, 停嘱时间 = 末次时间_In, 停嘱医生 = r_Advice.开嘱医生 
          Where ID = r_Advice.组id Or 相关id = r_Advice.组id;  
          v_Temp := zl_GetSysParameter(271);
          If v_Temp = '1' Then
            v_Temp := '自动停止：预定停止时间。';
          Else
            v_Temp := Null;
          End If;
          Insert Into 病人医嘱状态
            (医嘱id, 操作类型, 操作人员, 操作时间, 操作说明)
            Select ID, 8, r_Advice.开嘱医生, 发送时间_In, v_Temp
            From 病人医嘱记录
            Where ID = r_Advice.组id Or 相关id = r_Advice.组id;
          v_Stopadviceids := v_Stopadviceids || ',' || r_Advice.组id; 
        End If; 
      End If; 
    Else 
      --临嘱停止。 
      --住院医生发送时自动校对、停止：校对是以Sysdate取的,为避免重复,停止时间也取Sysdate 
      Select Sysdate Into v_Date From Dual; 
      Update 病人医嘱记录 
      Set 医嘱状态 = 8, 执行终止时间 = 末次时间_In, 
          --为一次性临嘱时没有 
          上次执行时间 = 末次时间_In, 
          --为一次性临嘱时没有 
          停嘱时间 = v_Date, 
          --发送时间_IN, 
          停嘱医生 = r_Advice.开嘱医生 
      Where ID = r_Advice.组id Or 相关id = r_Advice.组id; 
 
      Insert Into 病人医嘱状态 
        (医嘱id, 操作类型, 操作人员, 操作时间) 
        Select ID, 8, v_人员姓名, v_Date --发送时间_IN 
        From 病人医嘱记录 
        Where ID = r_Advice.组id Or 相关id = r_Advice.组id; 
    End If; 
 
    --特殊医嘱的处理 
    --------------------------------------------------------------------------------------- 
    If r_Advice.诊疗类别 = 'Z' And Nvl(r_Advice.操作类型, '0') <> '0' Then 
      --(1-留观;2-住院;)3-转科;4-术后(不发送);5-出院;6-转院,7-会诊,11-死亡 
 
      --几种特殊医嘱要自动停止病人该医嘱之前(按时间算)所有未停的长嘱 
      If r_Advice.操作类型 In ('3', '5', '6', '11') Then 
        If Nvl(r_Advice.婴儿, 0) = 0 Then 
          v_婴儿 := -1; 
        Else 
          v_婴儿 := Nvl(r_Advice.婴儿, 0); 
        End If; 
        For r_Needstop In c_Needstop(r_Advice.病人id, r_Advice.主页id, v_婴儿, r_Advice.开始执行时间) Loop 
          Select Decode(Sign(开始执行时间 - r_Advice.开始执行时间), 1, 开始执行时间, r_Advice.开始执行时间) 
          Into v_停止时间 
          From 病人医嘱记录 
          Where ID = r_Needstop.Id; 
          Update 病人医嘱记录 
          Set 医嘱状态 = 8, 执行终止时间 = v_停止时间, 停嘱时间 = 发送时间_In, 停嘱医生 = r_Advice.开嘱医生 
          Where ID = r_Needstop.Id; 
 
          Insert Into 病人医嘱状态 
            (医嘱id, 操作类型, 操作人员, 操作时间) 
            Select ID, 8, v_人员姓名, 发送时间_In From 病人医嘱记录 Where ID = r_Needstop.Id; 
          v_Stopadviceids := v_Stopadviceids || ',' || r_Needstop.Id; 
        End Loop; 
        --已停止未确认的长嘱,终止时间在医嘱开始后的,调前其终止时间(同时多个特殊医嘱的情况) 
        For r_Havestop In c_Havestop(r_Advice.病人id, r_Advice.主页id, v_婴儿, r_Advice.开始执行时间) Loop 
          Update 病人医嘱记录 
          Set 执行终止时间 = Decode(Sign(开始执行时间 - r_Advice.开始执行时间), 1, 开始执行时间, r_Advice.开始执行时间), 停嘱时间 = 发送时间_In, 
              停嘱医生 = r_Advice.开嘱医生 
          Where ID = r_Havestop.Id; 
 
          --不修改停止医嘱的操作人员，因为停止时，医生可能已进行电子签名 
          Update 病人医嘱状态 Set 操作时间 = 发送时间_In Where 医嘱id = r_Havestop.Id And 操作类型 = 8; 
          v_Stopadviceids := v_Stopadviceids || ',' || r_Havestop.Id; 
        End Loop; 
        --处理长期备用医嘱(没有执行（发送）过的标记未用）,同时处理临嘱 
        Update 病人医嘱记录 
        Set 执行标记 = -1 
        Where 病人id = r_Advice.病人id And 主页id = r_Advice.主页id And 
              (医嘱期效 = 0 And 执行频次 = '必要时' And 上次执行时间 Is Null And 医嘱状态 In (3, 5, 6, 7) Or 
              医嘱期效 = 1 And 执行频次 = '需要时' And 医嘱状态 = 3) And 执行标记 <> -1; 
      End If; 
 
      --具体的特殊处理 
      If Nvl(r_Advice.婴儿, 0) = 0 Then 
        If r_Advice.操作类型 = '3' And 执行部门id_In Is Not Null And r_Advice.病人科室id Is Not Null And 
           Nvl(r_Advice.病人科室id, 0) <> Nvl(执行部门id_In, 0) Then 
          --转科医嘱,将病人登记转科到"执行科室ID"(在院病人且当前科室与转入科室不同才处理) 
          Select Count(1)
          Into v_Temp
          From 病案主页
          Where 病人id = r_Advice.病人id And 主页id = r_Advice.主页id And 出院科室id <> 执行部门id_In;
          If v_Temp = '1' Then
            Zl_病人变动记录_Change(r_Advice.病人id, r_Advice.主页id, 执行部门id_In, v_人员编号, v_人员姓名);
          End If;
        Elsif r_Advice.操作类型 In ('5', '6', '11') Then 
          --出院、转院、死亡医嘱,将病人标记为预出院 
          Begin 
            Select 开始时间 
            Into v_Date 
            From 病人变动记录 
            Where 开始时间 Is Not Null And 终止时间 Is Null And 病人id = r_Advice.病人id And 主页id = r_Advice.主页id; 
          Exception 
            When Others Then 
              v_Date := To_Date('1900-01-01', 'YYYY-MM-DD'); 
          End; 
          If r_Advice.开始执行时间 <= v_Date Then 
            v_Error := '医嘱"' || r_Advice.医嘱内容 || '"的开始时间应大于该病人上次变动时间 ' || To_Char(v_Date, 'YYYY-MM-DD HH24:Mi') || ' 。'; 
            Raise Err_Custom; 
          End If; 
          Zl_病人变动记录_Preout(r_Advice.病人id, r_Advice.主页id, r_Advice.开始执行时间); 
        End If; 
      End If; 
    End If; 
    --12小时未执行的备用临嘱处理为标记未用 
    If r_Advice.医嘱期效 = 1 Then 
      Update 病人医嘱记录 
      Set 执行标记 = -1 
      Where 病人id = r_Advice.病人id And 主页id = r_Advice.主页id And 执行标记 <> -1 And 医嘱期效 = 1 And 执行频次 = '需要时' And 
            Sysdate - 开始执行时间 > 0.5 And 医嘱状态 = 3; 
    End If; 
  End If; 
 
  --填写发送记录 
  --------------------------------------------------------------------------------------- 
  n_执行状态 := 执行状态_In; 
  If 执行状态_In = 1 Then 
    v_Temp := zl_GetSysParameter(186); 
    If v_Temp = '11' Then 
      If r_Advice.诊疗类别 = 'E' And r_Advice.操作类型 in ('1','8') Or r_Advice.诊疗类别 = 'K' Then 
        n_执行状态 := 0; 
      End If; 
    Elsif v_Temp = '01' Then 
      If r_Advice.诊疗类别 = 'E' And r_Advice.操作类型 = '1' Then 
        n_执行状态 := 0; 
      End If; 
    Elsif v_Temp = '10' Then 
      If r_Advice.诊疗类别 = 'E' And r_Advice.操作类型 = '8' Or r_Advice.诊疗类别 = 'K' Then 
        n_执行状态 := 0; 
      End If; 
    End If; 
  End If; 
 
  Insert Into 病人医嘱发送 
    (医嘱id, 发送号, 记录性质, NO, 记录序号, 发送数次, 发送人, 发送时间, 执行状态, 执行部门id, 计费状态, 首次时间, 末次时间, 样本条码, 门诊记帐) 
  Values 
    (医嘱id_In, 发送号_In, 记录性质_In, No_In, 记录序号_In, 发送数次_In, v_人员姓名, 发送时间_In, n_执行状态, 执行部门id_In, 计费状态_In, 
     Nvl(首次时间_In, d_开始时间), Nvl(末次时间_In, d_开始时间), 样本条码_In, 门诊记帐_In); 
     
  --手术和检查医嘱同步更新主医嘱的计费状态   
  If 计费状态_In = 1 And  r_Advice.组ID <> 医嘱id_In  And (r_Advice.诊疗类别 = 'D' Or r_Advice.诊疗类别 = 'F') Then   
     Update 病人医嘱发送 Set 计费状态 = 1 Where 医嘱ID = r_Advice.组ID And 发送号 = 发送号_In;
  End If;
 
  --领药号的填写 
  If 领药号_In Is Not Null Then 
    Update 未发药品记录 Set 领药号 = 领药号_In Where NO = No_In And 单据 = 9 And 领药号 Is Null; 
    Update 药品收发记录 Set 产品合格证 = 领药号_In Where NO = No_In And 单据 = 9 And 产品合格证 Is Null; 
  End If; 
 
  --自动填为已执行时，需要同步处理费用执行状态及审核划价状态 
  If 执行状态_In = 1 Then 
    Zl_病人医嘱执行_Finish(医嘱id_In, 发送号_In, Null, Null, v_人员编号, v_人员姓名, 执行部门id_In); 
  End If; 
 
  --产生医嘱执行时间记录(只产生主记录的) 
  If Nvl(分解时间_In, To_Char(d_开始时间, 'yyyy-mm-dd hh24:mi:ss')) Is Not Null Then 
    If r_Advice.相关id Is Null Then 
      Insert Into 医嘱执行时间 
        (要求时间, 医嘱id, 发送号) 
        Select To_Date(Column_Value, 'yyyy-mm-dd hh24:mi:ss'), 医嘱id_In, 发送号_In 
        From Table(f_Str2list(Nvl(分解时间_In, To_Char(d_开始时间, 'yyyy-mm-dd hh24:mi:ss')))); 
    End If; 
  End If; 
 
  --病历书写时机的填写 
  If r_Advice.诊疗类别 = 'F' Then 
    --一组手术只调一次 
    If r_Advice.相关id Is Null Then 
      If Not r_Advice.标本部位 Is Null Then 
        v_Date := To_Date(r_Advice.标本部位, 'yyyy-mm-dd hh24:mi:ss'); 
      Else 
        v_Date := r_Advice.开始执行时间; 
      End If; 
      Zl_电子病历时机_Insert(r_Advice.病人id, r_Advice.主页id, 2, '手术', r_Advice.开嘱科室id, r_Advice.开嘱医生, v_Date, v_Date, 
                       r_Advice.执行科室id); 
    End If; 
  Elsif r_Advice.诊疗类别 = 'Z' And r_Advice.操作类型 = '7' Then 
    Zl_电子病历时机_Insert(r_Advice.病人id, r_Advice.主页id, 2, '会诊', r_Advice.开嘱科室id, r_Advice.开嘱医生, r_Advice.开始执行时间, 
                     r_Advice.开始执行时间, r_Advice.执行科室id); 
  Elsif r_Advice.诊疗类别 = 'Z' And r_Advice.操作类型 = '8' Then 
    Zl_电子病历时机_Insert(r_Advice.病人id, r_Advice.主页id, 2, '抢救', r_Advice.开嘱科室id, r_Advice.开嘱医生, r_Advice.开始执行时间, 
                     r_Advice.开始执行时间, r_Advice.执行科室id); 
  Elsif r_Advice.诊疗类别 = 'Z' And r_Advice.操作类型 = '11' Then 
    Zl_电子病历时机_Insert(r_Advice.病人id, r_Advice.主页id, 2, '死亡', r_Advice.开嘱科室id, r_Advice.开嘱医生, r_Advice.开始执行时间, 
                     r_Advice.开始执行时间, r_Advice.执行科室id); 
  End If; 
  --额外调用(知情文件允许的诊疗类别才调用) 
  If Instr('C,D,E,F,G,K,L', r_Advice.诊疗类别) > 0 Then 
    Zl_电子病历时机_Insert(r_Advice.病人id, r_Advice.主页id, 2, '知情文书', r_Advice.开嘱科室id, r_Advice.开嘱医生, r_Advice.开始执行时间, 
                     r_Advice.开始执行时间, r_Advice.执行科室id, r_Advice.诊疗项目id, r_Advice.医嘱内容); 
  End If; 
  --医嘱停止消息的处理 
  If v_Stopadviceids Is Not Null Then 
    v_Stopadviceids := Substr(v_Stopadviceids, 2); 
    Select Max(a.Id) 
    Into n_标记 
    From 病人医嘱记录 A 
    Where a.Id In (Select Column_Value From Table(f_Num2list(v_Stopadviceids))) And a.医嘱期效 = 0 And a.医嘱状态 = 8 And 
          Nvl(a.执行标记, 0) <> -1 And a.病人来源 <> 3; 
    If n_标记 Is Not Null Then 
      Select Max(a.Id) 
      Into n_Adviceid 
      From 病人医嘱记录 A 
      Where a.Id In (Select Column_Value From Table(f_Num2list(v_Stopadviceids))) And a.紧急标志 = 1 And a.医嘱期效 = 0 And 
            a.医嘱状态 = 8 And Nvl(a.执行标记, 0) <> -1 And a.病人来源 <> 3; 
      If n_Adviceid Is Not Null Then 
        Select Nvl(Max(0), 2) 
        Into n_标记 
        From 业务消息清单 A 
        Where a.病人id = r_Advice.病人id And a.就诊id = r_Advice.主页id And a.类型编码 = 'ZLHIS_CIS_002' And a.优先程度 = 2 And 
              a.是否已阅 = 0; 
      Else 
        n_Adviceid := n_标记; 
        Select Nvl(Max(0), 1) 
        Into n_标记 
        From 业务消息清单 A 
        Where a.病人id = r_Advice.病人id And a.就诊id = r_Advice.主页id And a.类型编码 = 'ZLHIS_CIS_002' And a.是否已阅 = 0; 
      End If; 
      If n_标记 > 0 Then 
        For R In (Select a.病人性质 As 性质, a.出院科室id As 科室id, a.当前病区id As 病区id 
                  From 病案主页 A 
                  Where a.病人id = r_Advice.病人id And a.主页id = r_Advice.主页id) Loop 
          Zl_业务消息清单_Insert(r_Advice.病人id, r_Advice.主页id, r.科室id, r.病区id, r.性质, '有新停止医嘱。', '0010', 'ZLHIS_CIS_002', 
                           n_Adviceid, n_标记, 0, Null, r.病区id); 
        End Loop; 
      End If; 
    End If; 
  End If; 
Exception 
  When Err_Custom Then 
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]'); 
  When Others Then 
    zl_ErrorCenter(SQLCode, SQLErrM); 
End Zl_病人医嘱发送_Insert;
/

--109923:董露露,2017-06-10,解决启用了双审核模式后临床路径表单的审核
Create Or Replace Procedure Zl_临床路径版本_Audit
(
  路径id_In 临床路径项目.路径id%Type,
  版本号_In 临床路径项目.版本号%Type,
  审核_In   Number
  --参数：
  --   审核_IN：1=通过审核，-1=取消审核 2=药剂科审核 -2=药剂科取消审核
) Is
  v_Date  Date;
  v_Count Number;
  v_User  人员表.姓名%Type;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  If 审核_In = 1 Or 审核_In = 2 Then
    --审核
    Select Sysdate Into v_Date From Dual;
    Select Zl_Username Into v_User From Dual;
    If 审核_In = 1 Then
      Update 临床路径版本
      Set 审核人 = v_User, 审核时间 = v_Date
      Where 路径id = 路径id_In And 版本号 = 版本号_In And 审核时间 Is Null;
      If Sql%RowCount > 0 Then
        --自动停用之前的版本
        Update 临床路径版本
        Set 停用人 = v_User, 停用时间 = v_Date
        Where 路径id = 路径id_In And 版本号 < 版本号_In And 停用时间 Is Null;
      
        Update 临床路径目录 Set 最新版本 = 版本号_In Where ID = 路径id_In;
      End If;
    Else
      Update 临床路径版本
      Set 药剂科审核人 = v_User, 药剂科审核时间 = v_Date
      Where 路径id = 路径id_In And 版本号 = 版本号_In And 药剂科审核时间 Is Null;
    End If;
  Elsif 审核_In = -1 Or 审核_In = -2 Then
    --取消审核
    If 审核_In = -1 Then
      Select Count(*) Into v_Count From 病人临床路径 Where 路径id = 路径id_In And 版本号 = 版本号_In And Rownum = 1;
      If Nvl(v_Count, 0) > 0 Then
        v_Error := '该版本的临床路径已经在使用，不能取消审核。';
        Raise Err_Custom;
      End If;
    
      Select Count(*) Into v_Count From 临床路径版本 Where 路径id = 路径id_In And 版本号 > 版本号_In;
      If Nvl(v_Count, 0) > 0 Then
        v_Error := '该版本后面存在其他新的版本，不能取消审核。';
        Raise Err_Custom;
      End If;
      Select 审核人, 审核时间 Into v_User, v_Date From 临床路径版本 Where 路径id = 路径id_In And 版本号 = 版本号_In;
    
      Update 临床路径版本
      Set 审核人 = Null, 审核时间 = Null
      Where 路径id = 路径id_In And 版本号 = 版本号_In And 审核时间 Is Not Null;
      If Sql%RowCount > 0 Then
        --恢复之前审核时自动停用的版本(手工停用的不处理)
        Select Max(版本号)
        Into v_Count
        From 临床路径版本
        Where 路径id = 路径id_In And 版本号 < 版本号_In And 停用人 = v_User And 停用时间 = v_Date;
        If Nvl(v_Count, 0) > 0 Then
          Update 临床路径版本 Set 停用人 = Null, 停用时间 = Null Where 路径id = 路径id_In And 版本号 = v_Count;
        End If;
      
        --更新最新版本
        Select Max(版本号)
        Into v_Count
        From 临床路径版本
        Where 路径id = 路径id_In And 审核时间 Is Not Null And 停用时间 Is Null;
        If Nvl(v_Count, 0) > 0 Then
          Update 临床路径目录 Set 最新版本 = v_Count Where ID = 路径id_In;
        Else
          Update 临床路径目录 Set 最新版本 = Null Where ID = 路径id_In;
        End If;
      End If;
    Else
      Update 临床路径版本
      Set 药剂科审核人 = Null, 药剂科审核时间 = Null
      Where 路径id = 路径id_In And 版本号 = 版本号_In And 药剂科审核时间 Is Not Null;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床路径版本_Audit;
/

--92335:李南春,2017-06-22,三方支付新模式及过程拆分
--110062:刘尔旋,2017-06-12,挂号时检查排开失约的记录
--109779:刘尔旋,2017-06-08,序号状态并发检查
Create Or Replace Procedure Zl_病人挂号记录_出诊_Insert
(
  出诊记录id_In    临床出诊记录.Id%Type,
  病人id_In        门诊费用记录.病人id%Type,
  门诊号_In        门诊费用记录.标识号%Type,
  姓名_In          门诊费用记录.姓名%Type,
  性别_In          门诊费用记录.性别%Type,
  年龄_In          门诊费用记录.年龄%Type,
  付款方式_In      门诊费用记录.付款方式%Type, --用于存放病人的医疗付款方式编号
  费别_In          门诊费用记录.费别%Type,
  单据号_In        门诊费用记录.No%Type,
  票据号_In        门诊费用记录.实际票号%Type,
  序号_In          门诊费用记录.序号%Type,
  价格父号_In      门诊费用记录.价格父号%Type,
  从属父号_In      门诊费用记录.从属父号%Type,
  收费类别_In      门诊费用记录.收费类别%Type,
  收费细目id_In    门诊费用记录.收费细目id%Type,
  数次_In          门诊费用记录.数次%Type,
  标准单价_In      门诊费用记录.标准单价%Type,
  收入项目id_In    门诊费用记录.收入项目id%Type,
  收据费目_In      门诊费用记录.收据费目%Type,
  结算方式_In      Varchar2,
  应收金额_In      门诊费用记录.应收金额%Type,
  实收金额_In      门诊费用记录.实收金额%Type,
  病人科室id_In    门诊费用记录.病人科室id%Type,
  开单部门id_In    门诊费用记录.开单部门id%Type,
  执行部门id_In    门诊费用记录.执行部门id%Type,
  操作员编号_In    门诊费用记录.操作员编号%Type,
  操作员姓名_In    门诊费用记录.操作员姓名%Type,
  发生时间_In      门诊费用记录.发生时间%Type,
  登记时间_In      门诊费用记录.登记时间%Type,
  医生姓名_In      挂号安排.医生姓名%Type,
  医生id_In        挂号安排.医生id%Type,
  病历费_In        Number, --该条记录是否病历工本费
  急诊_In          Number,
  号别_In          挂号安排.号码%Type,
  诊室_In          门诊费用记录.发药窗口%Type,
  结帐id_In        门诊费用记录.结帐id%Type,
  领用id_In        票据使用明细.领用id%Type,
  预交支付_In      病人预交记录.冲预交%Type, --刷卡挂号时使用的预交金额,序号为1传入.
  现金支付_In      病人预交记录.冲预交%Type, --挂号时现金支付部份金额,序号为1传入.
  个帐支付_In      病人预交记录.冲预交%Type, --挂号时个人帐户支付金额,,序号为1传入.
  保险大类id_In    门诊费用记录.保险大类id%Type,
  保险项目否_In    门诊费用记录.保险项目否%Type,
  统筹金额_In      门诊费用记录.统筹金额%Type,
  摘要_In          门诊费用记录.摘要%Type, --预约挂号摘要信息
  预约挂号_In      Number := 0, --预约挂号时用(记录状态=0,发生时间为预约时间),此时不需要传入结算相关参数
  收费票据_In      Number := 0, --挂号是否使用收费票据
  保险编码_In      门诊费用记录.保险编码%Type,
  复诊_In          病人挂号记录.复诊%Type := 0,
  号序_In          挂号序号状态.序号%Type := Null, --预约时填入费用记录的发药窗口字段,挂号时填入挂号记录
  社区_In          病人挂号记录.社区%Type := Null,
  预约接收_In      Number := 0,
  预约方式_In      预约方式.名称%Type := Null,
  生成队列_In      Number := 0,
  卡类别id_In      病人预交记录.卡类别id%Type := Null,
  结算卡序号_In    病人预交记录.结算卡序号%Type := Null,
  卡号_In          病人预交记录.卡号%Type := Null,
  交易流水号_In    病人预交记录.交易流水号%Type := Null,
  交易说明_In      病人预交记录.交易说明%Type := Null,
  合作单位_In      病人预交记录.合作单位%Type := Null,
  操作类型_In      Number := 0,
  险类_In          病人挂号记录.险类%Type := Null,
  结算模式_In      Number := 0,
  记帐费用_In      Number := 0,
  退号重用_In      Number := 1,
  冲预交病人ids_In Varchar2 := Null,
  修正病人费别_In  Number := 0,
  预约顺序号_In    临床出诊序号控制.预约顺序号%Type := Null,
  修正病人年龄_In  Number := 0,
  收费单_In        病人挂号记录.收费单%Type := Null,
  更新交款余额_In Number := 1
) As
  ---------------------------------------------------------------------------
  --
  --参数:
  --     操作类型_in:0-正常挂号或者预约 1-操作员拥有加号权限加号
  --     修正病人费别_In:0-不修改病人费别 1-修改病人费别
  --     更新交款余额_In:0-在zl_人员缴款余额_Update 中更新 1-在本过程中更新
  ----------------------------------------------------------------------------
  --该游标用于收费冲预交的可用预交列表
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit
  (
    v_病人id        病人信息.病人id%Type,
    v_冲预交病人ids Varchar2
  ) Is
    Select 病人id, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额, Min(记录状态) As 记录状态, Nvl(Max(结帐id), 0) As 结帐id,
           Max(Decode(记录性质, 1, ID, 0) * Decode(记录状态, 2, 0, 1)) As 原预交id
    From 病人预交记录
    Where 记录性质 In (1, 11) And 病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And Nvl(预交类别, 2) = 1
     Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
    Group By NO, 病人id
    Order By Decode(病人id, Nvl(v_病人id, 0), 0, 1), 结帐id, NO;
  --功能：新增一行病人挂号费用，并将结算汇总到病人预交记录
  --       同时汇总相关的汇总表(病人挂号汇总、费用汇总)
  --       第一行费用处理票据使用情况(领用ID_IN>0)

  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_排队号码 排队叫号队列.排队号码%Type;
  v_现金     结算方式.名称%Type;
  v_个人帐户 结算方式.名称%Type;
  v_队列名称 排队叫号队列.队列名称%Type;

  n_分时段       Number;
  n_原始分时段   Number;
  n_时段限号     Number;
  n_时段限约     Number;
  d_时段时间     Date;
  d_最大序号时间 Date;
  n_追加号       Number := 0; --处理时段过期 追加挂号的情况
  n_已约数       病人挂号汇总.已约数%Type;
  n_已接收       病人挂号汇总.其中已接收%Type;
  n_预约有效时间 Number;
  n_失效数       Number;
  n_失约挂号     Number := 0;
  n_已用数量     Number;
  n_锁定         Number := 0;

  n_打印id        票据打印内容.Id%Type;
  n_费用id        门诊费用记录.Id%Type;
  n_预交金额      病人预交记录.金额%Type;
  n_当前金额      病人预交记录.金额%Type;
  n_返回值        病人预交记录.金额%Type;
  n_预交id        病人预交记录.Id%Type;
  n_消费卡id      消费卡目录.Id%Type;
  n_挂号id        病人挂号记录.Id%Type;
  v_冲预交病人ids Varchar2(4000);

  n_组id           财务缴款分组.Id%Type;
  n_门诊号         病人信息.门诊号%Type;
  n_序号           挂号序号状态.序号%Type;
  n_已用序号       挂号序号状态.序号%Type;
  n_序号控制       挂号安排.序号控制%Type;
  n_分诊台签到排队 Number;
  n_Count          Number;
  n_限号数         Number(18);
  n_自制卡         Number;
  d_排队时间       Date;
  v_结算方式记录   Varchar2(1000);
  d_序号时间       Date;
  v_费别           费别.名称%Type;
  n_时段序号       Number := -1;
  n_预约生成队列   Number;
  v_结算方式       结算方式.名称%Type;
  v_结算内容       Varchar2(1000);
  v_当前结算       Varchar2(200);
  v_结算号码       病人预交记录.结算号码%Type;
  n_结算金额       病人预交记录.冲预交%Type;
  n_三方卡标志     Number(2);
  n_安排id         挂号安排.Id%Type;
  n_预约顺序号     临床出诊序号控制.预约顺序号%Type;
  n_计划id         挂号安排计划.Id%Type := 0;
  v_星期           挂号安排限制.限制项目%Type;
  n_限约数         Number(18);
  n_已挂数         Number(4) := 0;
  n_Exists         Number;
  n_挂出的最大序号 Number(4) := 0;
  n_分时点显示     Number(3);
  n_结算模式       病人信息.结算模式%Type;
  v_排队序号       排队叫号队列.排队序号%Type;
  v_机器名         挂号序号状态.机器名%Type;
  v_序号操作员     挂号序号状态.操作员姓名%Type;
  v_序号机器名     挂号序号状态.机器名%Type;
  v_付款方式       病人挂号记录.医疗付款方式%Type;
  n_状态           临床出诊序号控制.挂号状态%Type;
Begin
  --记录锁定判断
  If 出诊记录id_In Is Not Null Then
    Begin
      Select 1
      Into n_Exists
      From 临床出诊记录
      Where ID = 出诊记录id_In And Nvl(是否发布, 0) = 1 And Nvl(是否锁定, 0) = 0;
    Exception
      When Others Then
        v_Err_Msg := '无法确定出诊记录，请检查出诊记录是否存在或被锁定！';
        Raise Err_Item;
    End;
  End If;

  --获取当前机器名称
  Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
  n_组id          := Zl_Get组id(操作员姓名_In);
  v_冲预交病人ids := Nvl(冲预交病人ids_In, 病人id_In);

  If 费别_In Is Null Then
    Begin
      Select 名称 Into v_费别 From 费别 Where 缺省标志 = 1 And Rownum < 2;
      Update 病人信息 Set 费别 = v_费别 Where 病人id = 病人id_In;
    Exception
      When Others Then
        v_Err_Msg := '无法确定病人费别，请检查缺省费别是否正确设置！';
        Raise Err_Item;
    End;
  Else
    v_费别 := 费别_In;
    If Nvl(修正病人费别_In, 0) = 1 Then
      Begin
        Update 病人信息 Set 费别 = v_费别 Where 病人id = 病人id_In;
      Exception
        When Others Then
          v_Err_Msg := '没有找到对应的病人！';
          Raise Err_Item;
      End;
    End If;
  End If;

  If Nvl(修正病人年龄_In, 0) = 1 Then
    Begin
      Update 病人信息 Set 年龄 = 年龄_In Where 病人id = 病人id_In;
    Exception
      When Others Then
        v_Err_Msg := '没有找到对应的病人！';
        Raise Err_Item;
    End;
  End If;

  If 门诊号_In Is Not Null Then
    Begin
      Select Nvl(门诊号, 0) Into n_门诊号 From 病人信息 Where 病人id = 病人id_In;
    Exception
      When Others Then
        n_门诊号 := 0;
    End;
    If n_门诊号 = 0 Then
      Update 病人信息 Set 门诊号 = 门诊号_In Where 病人id = 病人id_In;
    End If;
  End If;

  Begin
    Update 临床出诊序号控制
    Set 挂号状态 = 0
    Where 记录id = 出诊记录id_In And 序号 = 号序_In And Nvl(挂号状态, 0) = 3 And 操作员姓名 = 操作员姓名_In;
  Exception
    When Others Then
      Null;
  End;

  If Nvl(预约挂号_In, 0) = 0 Then
    --挂号或者预约接收
    --因为现在有按日编单据号规则,日挂号量不能超过10000次,所以要检查唯一约束。
    Select Count(*)
    Into n_Count
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 In (1, 3) And 序号 = 序号_In And NO = 单据号_In;
    If n_Count <> 0 Then
      v_Err_Msg := '挂号单据号重复,不能保存！' || Chr(13) || '如果使用了按日顺序编号,当日挂号量不能超过10000人次。';
      Raise Err_Item;
    End If;
  
    --获取结算方式名称
    Begin
      Select 名称 Into v_现金 From 结算方式 Where 性质 = 1;
    Exception
      When Others Then
        v_现金 := '现金';
    End;
    Begin
      Select 名称 Into v_个人帐户 From 结算方式 Where 性质 = 3;
    Exception
      When Others Then
        v_个人帐户 := '个人帐户';
    End;
  End If;

  n_序号 := 号序_In;

  --获取是否分时段
  Begin
    Select Nvl(是否分时段, 0), Nvl(是否序号控制, 0), 限号数, 限约数
    Into n_分时段, n_序号控制, n_限号数, n_限约数
    From 临床出诊记录
    Where ID = 出诊记录id_In;
    n_原始分时段 := n_分时段;
  Exception
    When Others Then
      n_分时段     := 0;
      n_原始分时段 := n_分时段;
      n_序号控制   := 0;
      n_限号数     := Null;
      n_限约数     := Null;
  End;

  If n_序号 Is Null And n_分时段 = 1 And n_序号控制 = 0 Then
    Begin
      Select 序号
      Into n_序号
      From 临床出诊序号控制
      Where 记录id = 出诊记录id_In And 开始时间 = 发生时间_In And Rownum < 2;
    Exception
      When Others Then
        n_序号 := Null;
    End;
  End If;

  --分时段挂号时判断是否是过期挂号 也就是追加号的情况 目前只针对专家号分时段进行处理
  If Nvl(预约挂号_In, 0) = 0 And n_分时段 > 0 And Nvl(n_序号控制, 0) = 1 And 号序_In Is Null And Nvl(操作类型_In, 0) = 0 Then
    Begin
      Select Max(To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'))
      Into d_最大序号时间
      From 临床出诊序号控制
      Where 记录id = 出诊记录id_In And Nvl(数量, 0) <> 0;
    
      n_追加号 := Case Sign(发生时间_In - d_最大序号时间)
                 When -1 Then
                  0
                 Else
                  1
               End;
    Exception
      When Others Then
        n_追加号 := 0;
    End;
  End If;
  d_时段时间 := 发生时间_In;

  If 序号_In = 1 And n_分时段 > 0 Then
    If Nvl(n_序号控制, 0) = 1 Then
      Begin
        Select Nvl(序号, 0),
               To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'),
               数量, Decode(Nvl(是否预约, 0), 0, 0, 数量)
        Into n_时段序号, d_时段时间, n_时段限号, n_时段限约
        From 临床出诊序号控制
        Where 记录id = 出诊记录id_In And 序号 = n_序号;
      Exception
        When Others Then
          n_时段序号 := -1;
          n_分时段   := 0;
          d_时段时间 := 发生时间_In;
          n_时段限号 := 0;
          n_时段限约 := 0;
      End;
    Else
      --挂号时检查 是否分了时段,分了时段,把时段的限制条件给取出来
      Begin
        Select Nvl(序号, 0),
               To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'),
               数量, Decode(Nvl(是否预约, 0), 0, 0, 数量)
        Into n_时段序号, d_时段时间, n_时段限号, n_时段限约
        From 临床出诊序号控制
        Where 记录id = 出诊记录id_In And 序号 = n_序号 And 预约顺序号 Is Null;
      Exception
        When Others Then
          n_时段序号 := -1;
          n_分时段   := 0;
          d_时段时间 := 发生时间_In;
          n_时段限号 := 0;
          n_时段限约 := 0;
      End;
    End If;
  End If;

  If 序号_In = 1 Then
    If Nvl(预约挂号_In, 0) = 0 Then
      n_预约有效时间 := Zl_To_Number(zl_GetSysParameter('预约有效时间', 1111));
      n_失约挂号     := Zl_To_Number(zl_GetSysParameter('失约用于挂号', 1111));
    End If;
    --获取当前未使用的序号
    If Nvl(n_序号控制, 0) = 1 And n_分时段 = 0 Then
      --<序号控制 未设置时段 获取可用的最大序号,以及已经使用的数量>
      Begin
        --最大序号
        Select Count(1) Into n_已用数量 From 病人挂号记录 Where 出诊记录id = 出诊记录id_In And 记录状态 = 1;
        Select Max(序号) Into n_已用序号 From 临床出诊序号控制 Where 记录id = 出诊记录id_In;
      Exception
        When Others Then
          n_已用序号 := 0;
          n_已用数量 := 0;
      End;
      Begin
        --最大序号
        Select Sum(Nvl(数量, 0))
        
        Into n_已约数
        From 临床出诊序号控制
        Where 记录id = 出诊记录id_In And Nvl(挂号状态, 0) = 2;
      Exception
        When Others Then
          n_已约数 := 0;
      End;
    
      n_失效数 := 0;
      If Nvl(预约挂号_In, 0) = 0 Then
        If Nvl(n_预约有效时间, 0) <> 0 And Nvl(n_失约挂号, 0) > 0 Then
          Begin
            Select Sum(Decode(Sign((Sysdate - n_预约有效时间 / 24 / 60) - 预约时间), 1, 1, 0))
            Into n_失效数
            From 病人挂号记录
            Where 出诊记录id = 出诊记录id_In And 记录状态 = 1 And 记录性质 = 2;
          Exception
            When Others Then
              n_失效数 := 0;
          End;
        End If;
      End If;
    
      If n_原始分时段 = 0 Then
        Begin
          Select Min(序号) Into n_已用序号 From 临床出诊序号控制 Where 记录id = 出诊记录id_In And Nvl(挂号状态, 0) = 0;
          If n_序号 Is Null Then
            n_序号 := Nvl(n_已用序号, 0);
          End If;
        Exception
          When Others Then
            Select Max(序号)
            Into n_已用序号
            From 临床出诊序号控制
            Where 记录id = 出诊记录id_In And Nvl(挂号状态, 0) <> 0;
            If n_序号 Is Null Then
              n_序号 := Nvl(n_已用序号, 0) + 1;
            End If;
        End;
      Else
        Select Max(序号) Into n_已用序号 From 临床出诊序号控制 Where 记录id = 出诊记录id_In;
        If n_序号 Is Null Then
          n_序号 := Nvl(n_已用序号, 0) + 1;
        End If;
      End If;
      --<序号控制 未设置时段 获取可用的最大序号 以及已经使用的数量 --end>
    
      --非加号的情况需要检查是否超过了限制
      If 操作类型_In = 0 Then
        If Nvl(预约挂号_In, 0) = 0 Then
          --挂号时检查
          --启用序号控制未分时段 达到了限制
          If n_限号数 <= n_已用数量 And n_限号数 > 0 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(Trunc(发生时间_In), 'yyyy-mm-dd ') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        
        Else
          --预约时检查
          If n_限约数 = 0 Then
            n_限约数 := n_限号数;
          End If;
        
          If n_限约数 <= n_已约数 And n_限约数 > 0 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(Trunc(发生时间_In), 'yyyy-mm-dd') || '已达到最大限约数！';
            Raise Err_Item;
          End If;
        End If;
      
      Else
        Null;
        --启用序号控制,未分时段 加号情况   不处理,如果以后有限制条件以后补充
      End If;
    
    Elsif Nvl(n_分时段, 0) > 0 And Nvl(n_序号控制, 0) = 0 Then
      --<--普通号分时段 这里只有预约一种情况-->
      If 操作类型_In = 0 Then
        --<正常预约挂号-->
        Begin
          Select Count(0) As 已挂数, Nvl(Sum(Decode(Nvl(Sign(a.开始时间 - d_时段时间), 0), 0, 1, 0)), 0) As 已约数
          Into n_已挂数, n_已约数
          From 临床出诊序号控制 A
          Where 记录id = 出诊记录id_In And 挂号状态 Not In (0, 4, 5);
        Exception
          When Others Then
            n_已挂数 := 0;
            n_已约数 := 0;
        End;
      
        n_时段限约 := n_时段限号; --普通号分时段的情况,29中n_时段限约始终是0 这里特殊处理
        --检查限制数量
        If n_限约数 = 0 Then
          n_限约数 := n_限号数;
        End If;
        If n_时段限约 <= n_已约数 Or n_限约数 <= n_已约数 Then
          v_Err_Msg := '号别' || 号别_In || '在时段' || To_Char(d_时段时间, 'hh24:mi') || '已达到最大限约数！';
          Raise Err_Item;
        End If;
        If n_限号数 <= n_已挂数 Then
          v_Err_Msg := '号别' || 号别_In || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
          Raise Err_Item;
        End If;
      End If;
    
      --没有达到时段的限号数 号码在当前时段往后追加
    
      --获取当天挂出的最大号序
      Select Nvl(Max(序号), 0)
      Into n_挂出的最大序号
      From 临床出诊序号控制 A
      Where 记录id = 出诊记录id_In And 预约顺序号 Is Null And 挂号状态 Not In (0, 5);
      If 预约顺序号_In Is Not Null Then
        n_预约顺序号 := 预约顺序号_In;
      Else
        Begin
          Select Nvl(Max(预约顺序号), 0) + 1
          Into n_预约顺序号
          From 临床出诊序号控制
          Where 记录id = 出诊记录id_In And 序号 = n_时段序号 And 预约顺序号 Is Not Null;
        Exception
          When Others Then
            n_预约顺序号 := Null;
        End;
      End If;
      --设置序号
      n_序号 := RPad(Nvl(n_时段序号, 0), Length(n_限号数) + Length(Nvl(n_时段序号, 0)), 0) + n_预约顺序号;
      If n_预约顺序号 Is Null Then
        n_序号 := Nvl(n_挂出的最大序号, 0) + 1;
      End If;
    
      --<--普通号分时段--End>
    Elsif Nvl(n_分时段, 0) > 0 And Nvl(n_序号控制, 0) = 1 Then
      --<启用序号控制 设置时段
      --专家号分时段
      Begin
        Select Max(序号), Sum(Decode(序号, Nvl(号序_In, 0), 0, 1)), Sum(Decode(Sign(开始时间 - d_时段时间), 0, 1, 0))
        Into n_已用序号, n_已挂数, n_已用数量
        From 临床出诊序号控制
        Where 记录id = 出诊记录id_In And 挂号状态 Not In (0, 4, 5);
      Exception
        When Others Then
          n_已用序号 := 0;
          n_已用数量 := 0;
          n_已挂数   := 0;
      End;
    
      n_失效数 := 0;
      If Nvl(预约挂号_In, 0) = 0 Then
        If Nvl(n_预约有效时间, 0) <> 0 And Nvl(n_失约挂号, 0) > 0 Then
          Begin
            Select Sum(Decode(Sign((Sysdate - n_预约有效时间 / 24 / 60) - 开始时间), 1, 1, 0))
            Into n_失效数
            From 临床出诊序号控制
            Where 记录id = 出诊记录id_In And 开始时间 Between Trunc(Sysdate) And Sysdate And Nvl(挂号状态, 0) = 2;
          Exception
            When Others Then
              n_失效数 := 0;
          End;
        End If;
      End If;
    
      If 操作类型_In = 0 Then
        If Nvl(预约挂号_In, 0) = 0 Then
        
          --挂号 追加号码时不检查时段限号数
          If n_时段限号 <= n_已用数量 And Nvl(n_追加号, 0) = 0 Then
            v_Err_Msg := '号别' || 号别_In || '在时段' || To_Char(d_时段时间, 'hh24:mi') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
          If n_限号数 <= n_已挂数 - n_失效数 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        
        Else
          --挂号
          If n_限约数 = 0 Then
            n_限约数 := n_限号数;
          End If;
          If n_限约数 <= n_已用数量 Then
            v_Err_Msg := '号别' || 号别_In || '在时段' || To_Char(d_时段时间, 'hh24:mi') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
          If n_限号数 <= n_已挂数 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        End If;
      End If;
      If n_序号 Is Null Then
        --设置序号
        If Nvl(n_已用序号, 0) < Nvl(n_时段序号, 0) Then
          n_已用序号 := Nvl(n_时段序号, 0);
        End If;
        n_序号 := Nvl(n_已用序号, 0) + 1;
      End If;
    Elsif Nvl(n_分时段, 0) = 0 And Nvl(n_序号控制, 0) = 0 And Nvl(病历费_In, 0) = 0 And Nvl(号别_In, 0) > 0 Then
      ---<--普通号  -->
      Begin
        Select 已挂数, 已约数 Into n_已用数量, n_已约数 From 临床出诊记录 Where ID = 出诊记录id_In;
      Exception
        When Others Then
          n_已用数量 := 0;
          n_已约数   := 0;
      End;
      If Nvl(操作类型_In, 0) = 0 Then
        If Nvl(预约挂号_In, 0) = 0 Then
          --挂号
          If Nvl(n_已用数量, 0) >= Nvl(n_限号数, 0) And Nvl(n_限号数, 0) > 0 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        Else
          --预约
          If (Nvl(n_限约数, 0) > 0 And Nvl(n_已约数, 0) >= Nvl(n_限约数, 0)) Or
             (Nvl(n_已用数量, 0) >= Nvl(n_限号数, 0) And Nvl(n_限号数, 0) > 0) Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        End If;
      End If;
      ---<--普通号  -->
    End If;
  End If;

  --更新挂号序号状态
  If 序号_In = 1 And Not n_序号 Is Null Then
    If n_分时段 = 1 Then
      d_序号时间 := 发生时间_In;
    Else
      d_序号时间 := Trunc(发生时间_In);
    End If;
    --锁定序号的处理
    Begin
      If n_预约顺序号 Is Null Then
        Select 操作员姓名, 工作站名称
        Into v_序号操作员, v_序号机器名
        From 临床出诊序号控制
        Where Nvl(挂号状态, 0) = 5 And 记录id = 出诊记录id_In And 序号 = n_序号;
      Else
        Select 操作员姓名, 工作站名称
        Into v_序号操作员, v_序号机器名
        From 临床出诊序号控制
        Where Nvl(挂号状态, 0) = 5 And 记录id = 出诊记录id_In And 序号 = n_时段序号 And 预约顺序号 = n_预约顺序号;
      End If;
      n_锁定 := 1;
    Exception
      When Others Then
        v_序号操作员 := Null;
        v_序号机器名 := Null;
        n_锁定       := 0;
    End;
    If n_锁定 = 0 Then
      If n_预约顺序号 Is Null Then
        Update 临床出诊序号控制
        Set 挂号状态 = Decode(预约挂号_In, 1, 2, 1)
        Where 记录id = 出诊记录id_In And 序号 = n_序号 And Nvl(挂号状态, 0) = 3 And 操作员姓名 = 操作员姓名_In;
      Else
        Update 临床出诊序号控制
        Set 挂号状态 = Decode(预约挂号_In, 1, 2, 1)
        Where 记录id = 出诊记录id_In And 序号 = n_序号 And 预约顺序号 = n_预约顺序号 And Nvl(挂号状态, 0) = 3 And 操作员姓名 = 操作员姓名_In;
      End If;
      If Sql%RowCount = 0 Then
        Begin
          If Nvl(n_分时段, 0) > 0 Then
            If Nvl(n_序号控制, 0) = 1 Then
              --分时段后专家号 失约的预约号允许挂号
              Update 临床出诊序号控制
              Set 挂号状态 = Decode(预约挂号_In, 1, 2, 1), 操作员姓名 = 操作员姓名_In
              Where 记录id = 出诊记录id_In And 序号 = n_序号 And Nvl(挂号状态, 0) In (0, 2);
              If Sql%NotFound Then
                Begin
                  Select 挂号状态 Into n_状态 From 临床出诊序号控制 Where 记录id = 出诊记录id_In And 序号 = n_序号;
                Exception
                  When Others Then
                    n_状态 := -1;
                End;
                If n_状态 = -1 Then
                  Insert Into 临床出诊序号控制
                    (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 锁号时间, 类型, 名称, 操作员姓名, 备注)
                    Select 出诊记录id_In, n_序号, d_序号时间, d_序号时间, 1, Decode(预约挂号_In, 1, 1, 0), Decode(预约挂号_In, 1, 2, 1), Null,
                           Null, Null, 操作员姓名_In, '追加号'
                    From Dual;
                Else
                  v_Err_Msg := '序号' || n_序号 || '已被使用,请重新选择一个序号.';
                  Raise Err_Item;
                End If;
              End If;
            Else
              If Nvl(预约接收_In, 0) = 1 Then
                Insert Into 临床出诊序号控制
                  (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 锁号时间, 类型, 名称, 操作员姓名, 备注, 预约顺序号)
                  Select 记录id, 序号, 开始时间, 终止时间, 1, 1, Decode(预约挂号_In, 1, 2, 1), Null, Null, Null, 操作员姓名_In, n_序号, n_预约顺序号
                  From 临床出诊序号控制
                  Where 记录id = 出诊记录id_In And 序号 = n_时段序号 And 预约顺序号 Is Null;
              End If;
            End If;
          Else
            If Nvl(n_序号控制, 0) = 1 Then
              Update 临床出诊序号控制
              Set 挂号状态 = Decode(预约挂号_In, 1, 2, 1), 操作员姓名 = 操作员姓名_In
              Where 记录id = 出诊记录id_In And 序号 = n_序号 And Nvl(挂号状态, 0) = 0;
            
              If Sql%RowCount = 0 Then
                Begin
                  Select 挂号状态 Into n_状态 From 临床出诊序号控制 Where 记录id = 出诊记录id_In And 序号 = n_序号;
                Exception
                  When Others Then
                    n_状态 := -1;
                End;
                If n_状态 = -1 Then
                  Insert Into 临床出诊序号控制
                    (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 锁号时间, 类型, 名称, 操作员姓名, 备注)
                    Select 出诊记录id_In, n_序号, 发生时间_In, 发生时间_In, 1, Decode(预约挂号_In, 1, 1, 0), Decode(预约挂号_In, 1, 2, 1),
                           Null, Null, Null, 操作员姓名_In, '追加号'
                    From Dual;
                Else
                  v_Err_Msg := '序号' || n_序号 || '已被使用,请重新选择一个序号.';
                  Raise Err_Item;
                End If;
              End If;
            End If;
          End If;
        Exception
          When Others Then
            v_Err_Msg := '序号' || n_序号 || '已被使用,请重新选择一个序号.';
            Raise Err_Item;
        End;
      End If;
    Else
      If 操作员姓名_In <> v_序号操作员 Or v_机器名 <> v_序号机器名 Then
        v_Err_Msg := '序号' || n_序号 || '已被自助机' || v_机器名 || '锁定,请重新选择一个序号.';
        Raise Err_Item;
      Else
        If n_预约顺序号 Is Null Then
          Update 临床出诊序号控制
          Set 挂号状态 = Decode(预约挂号_In, 1, 2, 1)
          Where 记录id = 出诊记录id_In And 序号 = n_序号 And Nvl(挂号状态, 0) = 5 And 操作员姓名 = 操作员姓名_In And 工作站名称 = v_机器名;
        Else
          Update 临床出诊序号控制
          Set 挂号状态 = Decode(预约挂号_In, 1, 2, 1)
          Where 记录id = 出诊记录id_In And 序号 = n_时段序号 And 预约顺序号 = n_预约顺序号 And Nvl(挂号状态, 0) = 5 And 操作员姓名 = 操作员姓名_In And
                工作站名称 = v_机器名;
        End If;
      End If;
    End If;
  End If;

  --产生病人挂号费用(可能单独是或包括病历费用)
  Select 病人费用记录_Id.Nextval Into n_费用id From Dual; --应该通过程序得到

  Insert Into 门诊费用记录
    (ID, 记录性质, 记录状态, 序号, 价格父号, 从属父号, NO, 实际票号, 门诊标志, 加班标志, 附加标志, 发药窗口, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 病人科室id, 收费类别,
     计算单位, 收费细目id, 收入项目id, 收据费目, 付数, 数次, 标准单价, 应收金额, 实收金额, 结帐金额, 结帐id, 记帐费用, 开单部门id, 开单人, 划价人, 执行部门id, 执行人, 操作员编号, 操作员姓名,
     发生时间, 登记时间, 保险大类id, 保险项目否, 保险编码, 统筹金额, 摘要, 结论, 缴款组id)
  Values
    (n_费用id, 4, Decode(预约挂号_In, 1, 0, 1), 序号_In, Decode(价格父号_In, 0, Null, 价格父号_In), 从属父号_In, 单据号_In, 票据号_In, 1, 急诊_In,
     病历费_In, Decode(预约挂号_In, 1, To_Char(n_序号), 诊室_In), Decode(病人id_In, 0, Null, 病人id_In),
     Decode(门诊号_In, 0, Null, 门诊号_In), 付款方式_In, 姓名_In, Decode(姓名_In, Null, Null, 性别_In), Decode(姓名_In, Null, Null, 年龄_In),
     v_费别, 病人科室id_In, 收费类别_In, 号别_In, 收费细目id_In, 收入项目id_In, 收据费目_In, 1, 数次_In, 标准单价_In, 应收金额_In, 实收金额_In,
     Decode(预约挂号_In, 1, Null, Decode(Nvl(记帐费用_In, 0), 1, Null, 实收金额_In)),
     Decode(预约挂号_In, 1, Null, Decode(Nvl(记帐费用_In, 0), 1, Null, 结帐id_In)), Decode(Nvl(记帐费用_In, 0), 1, 1, 0), 开单部门id_In,
     操作员姓名_In, Decode(预约挂号_In, 1, 操作员姓名_In, Null), 执行部门id_In, 医生姓名_In, 操作员编号_In, 操作员姓名_In, 发生时间_In, 登记时间_In, 保险大类id_In,
     保险项目否_In, 保险编码_In, 统筹金额_In, 摘要_In, 预约方式_In, Decode(预约挂号_In, 1, Null, n_组id));

  --汇总结算到病人预交记录
  If Nvl(预约挂号_In, 0) = 0 And Nvl(记帐费用_In, 0) = 0 Then
    If Nvl(现金支付_In, 0) = 0 And Nvl(个帐支付_In, 0) = 0 And Nvl(预交支付_In, 0) = 0 And 序号_In = 1 Then
      Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      Insert Into 病人预交记录
        (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
         结算性质)
      Values
        (n_预交id, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), v_现金, 0, 登记时间_In, 操作员编号_In, 操作员姓名_In, 结帐id_In, '挂号收费',
         n_组id, 卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, 合作单位_In, 4);
    End If;
    If Nvl(现金支付_In, 0) <> 0 And 序号_In = 1 Then
      v_结算内容     := 结算方式_In || '|'; --以空格分开以|结尾,没有结算号码的
      v_结算方式记录 := '';
      While v_结算内容 Is Not Null Loop
        v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '|') - 1);
        v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1);
      
        v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
        n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1));
      
        v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
        v_结算号码 := Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1);
      
        v_当前结算   := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
        n_三方卡标志 := To_Number(v_当前结算);
      
        If Instr('|' || v_结算方式记录 || '|', '|' || Nvl(v_结算方式, v_现金) || '|') <> 0 Then
          v_Err_Msg := '使用了重复的结算方式,请检查!';
          Raise Err_Item;
        Else
          v_结算方式记录 := v_结算方式记录 || '|' || Nvl(v_结算方式, v_现金);
        End If;
      
        If n_三方卡标志 = 0 Then
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          Insert Into 病人预交记录
            (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
             合作单位, 结算性质, 结算号码)
          Values
            (n_预交id, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(v_结算方式, v_现金), Nvl(n_结算金额, 0), 登记时间_In,
             操作员编号_In, 操作员姓名_In, 结帐id_In, '挂号收费', n_组id, Null, Null, Null, Null, Null, 合作单位_In, 4, v_结算号码);
        Else
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          Insert Into 病人预交记录
            (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
             合作单位, 结算性质, 结算号码)
          Values
            (n_预交id, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(v_结算方式, v_现金), Nvl(n_结算金额, 0), 登记时间_In,
             操作员编号_In, 操作员姓名_In, 结帐id_In, '挂号收费', n_组id, 卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, 合作单位_In, 4,
             v_结算号码);
          If Nvl(结算卡序号_In, 0) <> 0 And Nvl(现金支付_In, 0) <> 0 Then
            n_消费卡id := Null;
            Begin
              Select Nvl(自制卡, 0), 1 Into n_自制卡, n_Count From 卡消费接口目录 Where 编号 = 结算卡序号_In;
            Exception
              When Others Then
                n_Count := 0;
            End;
            If n_Count = 0 Then
              v_Err_Msg := '没有发现原结算卡的相应类别,不能继续操作！';
              Raise Err_Item;
            End If;
            If n_自制卡 = 1 Then
              Select ID
              Into n_消费卡id
              From 消费卡目录
              Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In And
                    序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In);
            End If;
            Zl_病人卡结算记录_Insert(结算卡序号_In, n_消费卡id, Nvl(v_结算方式, v_现金), Nvl(n_结算金额, 0), 卡号_In, Null, 登记时间_In, Null, 结帐id_In,
                              n_预交id);
          End If;
        End If;
        
        If Nvl(更新交款余额_In, 1) = 1 Then
          Update 人员缴款余额
          Set 余额 = Nvl(余额, 0) + n_结算金额
          Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = Nvl(v_结算方式, v_现金)
          Returning 余额 Into n_返回值;
        
          If Sql%RowCount = 0 Then
            Insert Into 人员缴款余额
              (收款员, 结算方式, 性质, 余额)
            Values
              (操作员姓名_In, Nvl(v_结算方式, v_现金), 1, n_结算金额);
            n_返回值 := n_结算金额;
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 人员缴款余额
            Where 收款员 = 操作员姓名_In And 结算方式 = Nvl(v_结算方式, v_现金) And 性质 = 1 And Nvl(余额, 0) = 0;
          End If;
        End If;
      
        v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '|') + 1);
      End Loop;
    End If;
  
    --对于医保挂号
    If Nvl(个帐支付_In, 0) <> 0 And 序号_In = 1 Then
      Insert Into 病人预交记录
        (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), v_个人帐户, 个帐支付_In, 登记时间_In, 操作员编号_In,
         操作员姓名_In, 结帐id_In, '医保挂号', n_组id, 4);
    End If;
  
    --对于就诊卡通过预交金挂号
    If Nvl(预交支付_In, 0) <> 0 And 序号_In = 1 Then
      n_预交金额 := 预交支付_In;
      For r_Deposit In c_Deposit(病人id_In, v_冲预交病人ids) Loop
        n_当前金额 := Case
                    When r_Deposit.金额 - n_预交金额 < 0 Then
                     r_Deposit.金额
                    Else
                     n_预交金额
                  End;
      
        If r_Deposit.结帐id = 0 Then
          --第一次冲预交(填上结帐ID,金额为0)
          Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 4 Where ID = r_Deposit.原预交id;
        
        End If;
        --冲上次剩余额
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 预交类别, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号,
           冲预交, 结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 预交类别, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 登记时间_In, 操作员姓名_In, 操作员编号_In, n_当前金额, 结帐id_In, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
          From 病人预交记录
          Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
      
        --更新病人预交余额
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) - n_当前金额
        Where 病人id = r_Deposit.病人id And 性质 = 1 And 类型 = Nvl(1, 2);
        --检查是否已经处理完
        If r_Deposit.金额 < n_预交金额 Then
          n_预交金额 := n_预交金额 - r_Deposit.金额;
        Else
          n_预交金额 := 0;
        End If;
      
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
      If n_预交金额 > 0 Then
        v_Err_Msg := '预交余不够支付本次支付金额,不能继续操作！';
        Raise Err_Item;
      
      End If;
      Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
    End If;
  
    --相关汇总表的处理
    --人员缴款余额
    If 序号_In = 1 And Nvl(更新交款余额_In, 1) = 1 Then
      If Nvl(个帐支付_In, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + 个帐支付_In
        Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = v_个人帐户
        Returning 余额 Into n_返回值;
      
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, v_个人帐户, 1, 个帐支付_In);
          n_返回值 := 个帐支付_In;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_个人帐户 And Nvl(余额, 0) = 0;
        End If;
      End If;
    End If;
  End If;

  --病人挂号汇总(只处理一次,且单独收取病历费不处理)
  If Nvl(预约挂号_In, 0) = 0 Then
    If Nvl(记帐费用_In, 0) = 0 Then
      --处理票据使用情况
      If 序号_In = 1 And 票据号_In Is Not Null Then
        Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
      
        --发出票据
        Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 4, 单据号_In);
      
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
        Values
          (票据使用明细_Id.Nextval, Decode(收费票据_In, 1, 1, 4), 票据号_In, 1, 1, 领用id_In, n_打印id, 登记时间_In, 操作员姓名_In);
      
        --状态改动
        Update 票据领用记录
        Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
        Where ID = Nvl(领用id_In, 0);
      End If;
    End If;
    --病人本次就诊(以发生时间为准)
    If Nvl(病人id_In, 0) <> 0 And 序号_In = 1 Then
      Update 病人信息 Set 就诊时间 = 发生时间_In, 就诊状态 = 1, 就诊诊室 = 诊室_In Where 病人id = 病人id_In;
    End If;
  End If;

  If Nvl(预约挂号_In, 0) = 0 And Nvl(记帐费用_In, 0) = 1 Then
    --记帐
    If Nvl(病人id_In, 0) = 0 Then
      v_Err_Msg := '要针对病人的挂号费进行记帐，必须是建档病人才能记帐挂号。';
      Raise Err_Item;
    End If;
  
    --病人余额
    Update 病人余额
    Set 费用余额 = Nvl(费用余额, 0) + Nvl(实收金额_In, 0)
    Where 病人id = Nvl(病人id_In, 0) And 性质 = 1 And 类型 = 1;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (病人id_In, 1, 1, Nvl(实收金额_In, 0), 0);
    End If;
  
    --病人未结费用
    Update 病人未结费用
    Set 金额 = Nvl(金额, 0) + Nvl(实收金额_In, 0)
    Where 病人id = 病人id_In And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(病人科室id_In, 0) And
          Nvl(开单部门id, 0) = Nvl(开单部门id_In, 0) And Nvl(执行部门id, 0) = Nvl(执行部门id_In, 0) And 收入项目id + 0 = 收入项目id_In And
          来源途径 + 0 = 1;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人未结费用
        (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
      Values
        (病人id_In, Null, Null, 病人科室id_In, 开单部门id_In, 执行部门id_In, 收入项目id_In, 1, Nvl(实收金额_In, 0));
    End If;
  End If;

  --病人挂号记录
  If 号别_In Is Not Null And 序号_In = 1 Then
    --And Nvl(预约挂号_In, 0) = 0
    Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
    Begin
      Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In And Rownum < 2;
    Exception
      When Others Then
        v_付款方式 := Null;
    End;
    Insert Into 病人挂号记录
      (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 预约时间, 操作员编号,
       操作员姓名, 复诊, 号序, 社区, 预约, 预约方式, 摘要, 交易流水号, 交易说明, 合作单位, 接收时间, 接收人, 预约操作员, 预约操作员编号, 险类, 医疗付款方式, 出诊记录id, 收费单)
    Values
      (n_挂号id, 单据号_In, Decode(Nvl(预约挂号_In, 0), 1, 2, 1), 1, 病人id_In, 门诊号_In, 姓名_In, 性别_In, 年龄_In, 号别_In, 急诊_In, 诊室_In,
       Null, 执行部门id_In, 医生姓名_In, 0, Null, 登记时间_In, 发生时间_In, Decode(Nvl(预约挂号_In, 0), 1, 发生时间_In, Null), 操作员编号_In,
       操作员姓名_In, 复诊_In, n_序号, 社区_In, Decode(预约接收_In, 1, 1, 0), 预约方式_In, 摘要_In, 交易流水号_In, 交易说明_In, 合作单位_In,
       Decode(Nvl(预约挂号_In, 0), 0, 登记时间_In, Null), Decode(Nvl(预约挂号_In, 0), 0, 操作员姓名_In, Null),
       Decode(Nvl(预约挂号_In, 0), 1, 操作员姓名_In, Null), Decode(Nvl(预约挂号_In, 0), 1, 操作员编号_In, Null),
       Decode(Nvl(险类_In, 0), 0, Null, 险类_In), v_付款方式, 出诊记录id_In, 收费单_In);
  
    If Nvl(预约挂号_In, 0) = 0 And 预约方式_In Is Not Null Then
      Update 病人挂号记录
      Set 预约 = 1, 预约时间 = 发生时间_In, 预约操作员 = 操作员姓名_In, 预约操作员编号 = 操作员编号_In
      Where ID = n_挂号id;
    End If;
  
    n_预约生成队列 := 0;
    If Nvl(预约挂号_In, 0) = 1 Then
      n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
    End If;
  
    --0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站
    If Nvl(生成队列_In, 0) <> 0 And Nvl(预约挂号_In, 0) = 0 Or n_预约生成队列 = 1 Then
      n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
      If Nvl(n_分诊台签到排队, 0) = 0 Or n_预约生成队列 = 1 Then
        n_分时点显示 := Nvl(Zl_To_Number(zl_GetSysParameter(270)), 0);
        If Nvl(预约挂号_In, 0) = 1 And n_分时点显示 = 1 And n_分时段 = 1 Then
          n_分时点显示 := 1;
        Else
          n_分时点显示 := Null;
        End If;
        --产生队列
        --.按”执行部门” 的方式生成队列
        v_队列名称 := 执行部门id_In;
        v_排队号码 := Zlgetnextqueue(执行部门id_In, n_挂号id, 号别_In || '|' || n_序号);
        v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
        d_排队时间 := Zl_Get_Queuedate(n_挂号id, 号别_In, n_序号, 发生时间_In);
        --  队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,排队标记_In,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In, 排队时间_In
        Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, 执行部门id_In, v_排队号码, Null, 姓名_In, 病人id_In, 诊室_In, 医生姓名_In, d_排队时间, 预约方式_In,
                         n_分时点显示, v_排队序号);
      
        --挂号立即排队
        If Nvl(n_分诊台签到排队, 0) = 0 Then
          Update 病人挂号记录 Set 记录标志 = 1 Where ID = n_挂号id;
        End If;
      End If;
    End If;
  End If;
  --病人担保信息
  If 病人id_In Is Not Null And 序号_In = 1 Then
    --取参数:
    If Nvl(n_结算模式, 0) <> Nvl(结算模式_In, 0) Then
      --结算模式的确定
    
      v_Err_Msg := Null;
      Begin
        Select Nvl(结算模式, 0) Into n_结算模式 From 病人信息 Where 病人id = 病人id_In;
      Exception
        When Others Then
          v_Err_Msg := '未找到指定的病人信息,不允许挂号';
      End;
    
      If v_Err_Msg Is Not Null Then
        Raise Err_Item;
      End If;
      If n_结算模式 = 1 And Nvl(结算模式_In, 0) = 0 Then
        --病人已经是"先诊疗后结算的",本次是"先结算后诊疗的",则检查是否存在未结数据
        Select Count(1)
        Into n_Count
        From 病人未结费用
        Where 病人id = 病人id_In And (来源途径 In (1, 4) Or 来源途径 = 3 And Nvl(主页id, 0) = 0) And Nvl(金额, 0) <> 0 And Rownum < 2;
        If Nvl(n_Count, 0) <> 0 Then
          --存在未结算数据，必须先结算后才允许执行
          v_Err_Msg := '当前病人的就诊模式为先诊疗后结算且存在未结费用，不允许调整该病人的就诊模式,你可以先对未结费用结帐后再挂号或不调整病人的就诊模式!';
          Raise Err_Item;
        End If;
        --检查
        --未发生医嘱业务的（即当时就挂号的,需要保证同一次的就诊模式是一至的(程序已经检查，不用再处理)
      End If;
      Update 病人信息 Set 结算模式 = 结算模式_In Where 病人id = 病人id_In;
    End If;
  
    Update 病人信息
    Set 担保人 = Null, 担保额 = Null, 担保性质 = Null
    Where 病人id = 病人id_In And Exists (Select 1
           From 病人担保记录
           Where 病人id = 病人id_In And 主页id Is Not Null And
                 登记时间 = (Select Max(登记时间) From 病人担保记录 Where 病人id = 病人id_In));
  
    If Sql%RowCount > 0 Then
      Update 病人担保记录
      Set 到期时间 = Sysdate
      Where 病人id = 病人id_In And 主页id Is Not Null And Nvl(到期时间, Sysdate) > Sysdate;
    End If;
  End If;
  If 序号_In = 1 Then
    --消息推送
    Begin
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 1, n_挂号id;
    Exception
      When Others Then
        Null;
    End;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人挂号记录_出诊_Insert;
/

--109906:梁唐彬,2017-06-06,病人自动计算预出院报错
Create Or Replace Procedure Zl_病人变动记录_Preout
(
  病人id_In   病案主页.病人id%Type,
  主页id_In   病案主页.主页id%Type,
  发生时间_In 病人变动记录.开始时间%Type
) As
  -----------------------------------------------------------
  --功能：将病人标为预出院状态，并产生一条变动
  -----------------------------------------------------------
  Cursor c_Oldinfo Is
    Select b.*
    From (Select c.*
           From 病人变动记录 C
           Where c.病人id = 病人id_In And c.主页id = 主页id_In And
                 c.开始时间 = (Select Min(开始时间)
                           From 病人变动记录
                           Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 发生时间_In)) A, 病人变动记录 B
    
    Where b.病人id = 病人id_In And b.主页id = 主页id_In And a.开始时间 = b.终止时间 And a.开始原因 = b.终止原因 And a.附加床位 = b.附加床位
    Union
    Select *
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And 开始时间 <= 发生时间_In;

  Cursor c_OldAutoinfo Is
    Select b.*
    From (Select c.*
           From 病人自动计算 C
           Where c.病人id = 病人id_In And c.主页id = 主页id_In And C.性质 = 2 And
                 c.开始时间 = (Select Min(开始时间)
                           From 病人自动计算
                           Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 发生时间_In And 性质 = 2)) A, 病人自动计算 B
    
    Where b.病人id = 病人id_In And b.主页id = 主页id_In And a.开始时间 = b.终止时间 And a.开始原因 = b.终止原因 And a.附加床位 = b.附加床位 And B.性质 = 2
    Union
    Select *
    From 病人自动计算
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And 开始时间 <= 发生时间_In And 性质 = 2;
  
  Cursor c_OldAutoHLinfo Is
    Select b.*
    From (Select c.*
           From 病人自动计算 C
           Where c.病人id = 病人id_In And c.主页id = 主页id_In And C.性质 = 1 And
                 c.开始时间 = (Select Min(开始时间)
                           From 病人自动计算
                           Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 发生时间_In And 性质 = 1)) A, 病人自动计算 B
    
    Where b.病人id = 病人id_In And b.主页id = 主页id_In And a.开始时间 = b.终止时间 And a.开始原因 = b.终止原因 And a.附加床位 = b.附加床位 And B.性质 = 1
    Union
    Select *
    From 病人自动计算
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And 开始时间 <= 发生时间_In And 性质 = 1;
  
  Cursor c_Endinfo Is
    Select * From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
  r_Oldinfo  c_Oldinfo%RowType;
  r_Endinfo  c_Endinfo%RowType;
  r_OldAutoinfo      c_OldAutoinfo%Rowtype;
  r_OldAutoHLinfo      c_OldAutoHLinfo%Rowtype;
  v_终止原因 病人变动记录.终止原因%Type;
  v_终止时间 病人变动记录.终止时间%Type;
  v_终止人员 病人变动记录.终止人员%Type;
  v_Auto变动终止原因 病人变动记录.终止原因%Type;
  v_Auto变动终止时间 病人变动记录.终止时间%Type;
  v_Auto变动终止人员 病人变动记录.终止人员%Type;
  v_AutoHL变动终止原因 病人变动记录.终止原因%Type;
  v_AutoHL变动终止时间 病人变动记录.终止时间%Type;
  v_AutoHL变动终止人员 病人变动记录.终止人员%Type;

  v_Temp     Varchar2(255);
  v_人员编号 住院费用记录.操作员编号%Type;
  v_人员姓名 住院费用记录.操作员姓名%Type;
  v_姓名     病人信息.姓名%Type;

  v_Count Number;
  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --并发操作检查
  Select Nvl(状态, 0) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
  If v_Count <> 0 Then
    v_Error := '该病人当前正在转科或尚未入科，不能执行预出院。';
    Raise Err_Custom;
  End If;

  v_Count := Nvl(zl_GetSysParameter('特殊医嘱发送前检查未生效医嘱', 1254), 0);
  If v_Count = 1 Then
    v_姓名 := Null;
    Select Max(姓名)
    Into v_姓名
    From 病人医嘱记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 医嘱状态 = 1 And Nvl(婴儿, 0) = 0 And Rownum = 1;
    If v_姓名 Is Not Null Then
      v_Error := v_姓名 || '存在未校对的医嘱，请删除或校对后再继续。';
      Raise Err_Custom;
    End If;
  
    v_姓名 := Null;
    Select Max(姓名)
    Into v_姓名
    From 病人医嘱记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 医嘱期效 = 1 And 医嘱状态 In (2, 3) And Nvl(执行标记, 0) <> -1 And Nvl(婴儿, 0) = 0 And
          Nvl(执行性质, 0) <> 0 And Rownum = 1;
    If v_姓名 Is Not Null Then
      v_Error := v_姓名 || '存在校对后未发送的临嘱，请发送或作废后再继续。';
      Raise Err_Custom;
    End If;
  End If;

  --操作员信息
  v_Temp     := Zl_Identity;
  v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);

  Open c_Oldinfo; --必须在处理之前先打开
  Fetch c_Oldinfo
    Into r_Oldinfo;
  Open c_OldAutoinfo; --必须先打开
    Fetch c_OldAutoinfo
      Into r_OldAutoinfo;
    Open c_OldAutoHLinfo; --必须先打开
    Fetch c_OldAutoHLinfo
      Into r_OldAutoHLinfo;
  Open c_Endinfo;
  Fetch c_Endinfo
    Into r_Endinfo;
  If c_Endinfo%RowCount = 0 Then
    Close c_Endinfo;
    v_Error := '未发现该病人当前有效的变动记录！';
    Raise Err_Custom;
  End If;

  --取消上次变动
  If r_Oldinfo.终止时间 Is Not Null Then
    v_终止时间 := r_Oldinfo.终止时间;
    v_终止原因 := r_Oldinfo.终止原因;
    v_终止人员 := r_Oldinfo.终止人员;
    --取消上次变动
    Update 病人变动记录
    Set 终止时间 = 发生时间_In, 终止原因 = 10, 终止人员 = v_人员姓名, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_终止时间 And 终止原因 = v_终止原因;
  Else
    Update 病人变动记录
    Set 终止时间 = 发生时间_In, 终止原因 = 10, 终止人员 = v_人员姓名, 上次计算时间 = Decode(Sign(Nvl(上次计算时间, 发生时间_In) - 发生时间_In), 1, Null, 上次计算时间)
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
  End If;
  --更新将来的记录如果有停止到将来的则删除上次计算时间
  Update 病人变动记录
  Set 上次计算时间 = Null
  Where 病人id = 病人id_In And 主页id = 主页id_In And (开始时间 > 发生时间_In Or Trunc(上次计算时间) = Trunc(发生时间_In));
  
  --床位自动计算
  If r_OldAutoinfo.终止时间 Is Not Null Then
    v_Auto变动终止时间 := r_OldAutoinfo.终止时间;
    v_Auto变动终止原因 := r_OldAutoinfo.终止原因;
    v_Auto变动终止人员 := r_OldAutoinfo.终止人员;
    --取消上次变动
    Update 病人自动计算
    Set 终止时间 = 发生时间_In, 终止原因 = 10, 终止人员 = v_人员姓名, 上次计算时间 = Null 
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_Auto变动终止时间 And 终止原因 = v_Auto变动终止原因 and 性质 IN(2,3);
  Else
    Update 病人自动计算
    Set 终止时间 = 发生时间_In, 终止原因 = 10, 终止人员 = v_人员姓名, 上次计算时间 = Decode(Sign(Nvl(上次计算时间, 发生时间_In) - 发生时间_In), 1, Null, 上次计算时间)
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null and 性质 IN(2,3);
  End If;
  --更新将来的记录如果有停止到将来的则删除上次计算时间
  Update 病人自动计算
  Set 上次计算时间 = Null
  Where 病人id = 病人id_In And 主页id = 主页id_In And (开始时间 > 发生时间_In Or Trunc(上次计算时间) = Trunc(发生时间_In)) and 性质 IN(2,3);
  
  --护理自动计算
  If r_OldAutoHLinfo.终止时间 Is Not Null Then
    v_AutoHL变动终止时间 := r_OldAutoHLinfo.终止时间;
    v_AutoHL变动终止原因 := r_OldAutoHLinfo.终止原因;
    v_AutoHL变动终止人员 := r_OldAutoHLinfo.终止人员;
    --取消上次变动
    Update 病人自动计算
    Set 终止时间 = 发生时间_In, 终止原因 = 10, 终止人员 = v_人员姓名, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_AutoHL变动终止时间 And 终止原因 = v_AutoHL变动终止原因 and 性质 = 1;
  Else
    Update 病人自动计算
    Set 终止时间 = 发生时间_In, 终止原因 = 10, 终止人员 = v_人员姓名, 上次计算时间 = Decode(Sign(Nvl(上次计算时间, 发生时间_In) - 发生时间_In), 1, Null, 上次计算时间)
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null and 性质 = 1;
  End If;
  --更新将来的记录如果有停止到将来的则删除上次计算时间
  Update 病人自动计算
  Set 上次计算时间 = Null
  Where 病人id = 病人id_In And 主页id = 主页id_In And (开始时间 > 发生时间_In Or Trunc(上次计算时间) = Trunc(发生时间_In)) and 性质 = 1;
  
  
  --产生新变动
  While c_Oldinfo%Found Loop
    Insert Into 病人变动记录
      (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号,
       操作员姓名, 终止时间, 终止原因, 终止人员)
    Values
      (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, 发生时间_In, 10, r_Oldinfo.附加床位, r_Oldinfo.病区id, r_Oldinfo.科室id,
       r_Oldinfo.医疗小组id, r_Oldinfo.护理等级id, r_Oldinfo.床位等级id, r_Oldinfo.床号, r_Oldinfo.责任护士, r_Oldinfo.经治医师,
       r_Oldinfo.主治医师, r_Oldinfo.主任医师, r_Oldinfo.病情, v_人员编号, v_人员姓名, v_终止时间, v_终止原因, v_终止人员);
    If Nvl(r_Oldinfo.附加床位, 0) = 0 Then
      --产生病历书写时机
      Zl_电子病历时机_Insert(病人id_In, 主页id_In, 2, '出院', r_Oldinfo.科室id, r_Oldinfo.经治医师, 发生时间_In, 发生时间_In);
    End If;
    Fetch c_Oldinfo
      Into r_Oldinfo;
  End Loop;   
  
  --产生床位其他自动计算
  While c_OldAutoinfo%Found Loop
    Insert Into 病人自动计算
      (ID, 病人id, 主页id, 开始时间, 开始原因,性质, 附加床位, 病区id, 科室id, 床位等级id, 床号, 操作员编号,
       操作员姓名, 终止时间, 终止原因, 终止人员)
    Values
      (病人自动计算_Id.Nextval, 病人id_In, 主页id_In, 发生时间_In, 10, 2, r_OldAutoinfo.附加床位, r_OldAutoinfo.病区id, r_OldAutoinfo.科室id,
       r_OldAutoinfo.床位等级id, r_OldAutoinfo.床号, v_人员编号, v_人员姓名, v_Auto变动终止时间, v_Auto变动终止原因, v_Auto变动终止人员);
    
    Insert Into 病人自动计算
      (ID, 病人id, 主页id, 开始时间, 开始原因,性质, 附加床位, 病区id, 科室id, 床位等级id, 床号, 操作员编号,
       操作员姓名, 终止时间, 终止原因, 终止人员)
    Values
      (病人自动计算_Id.Nextval, 病人id_In, 主页id_In, 发生时间_In, 10, 3, r_OldAutoinfo.附加床位, r_OldAutoinfo.病区id, r_OldAutoinfo.科室id,
       r_OldAutoinfo.床位等级id, r_OldAutoinfo.床号, v_人员编号, v_人员姓名, v_Auto变动终止时间, v_Auto变动终止原因, v_Auto变动终止人员);
    
    Fetch c_OldAutoinfo
      Into r_OldAutoinfo;
  End Loop;  
  
  --产生护理自动计算
  While c_OldAutoHLinfo%Found Loop
    Insert Into 病人自动计算
      (ID, 病人id, 主页id, 开始时间, 开始原因,性质, 病区id, 科室id, 护理等级id, 操作员编号,
       操作员姓名, 终止时间, 终止原因, 终止人员)
    Values
      (病人自动计算_Id.Nextval, 病人id_In, 主页id_In, 发生时间_In, 10, 1, r_OldAutoHLinfo.病区id, r_OldAutoHLinfo.科室id,
       r_OldAutoHLinfo.护理等级id, v_人员编号, v_人员姓名, v_AutoHL变动终止时间, v_AutoHL变动终止原因, v_AutoHL变动终止人员);
    Fetch c_OldAutoHLinfo
      Into r_OldAutoHLinfo;
  End Loop;                    

  Close c_Oldinfo;
  Close c_OldAutoinfo;
  Close c_OldAutoHLinfo;
  Close c_Endinfo;

  Update 病案主页 Set 状态 = 3 Where 病人id = 病人id_In And 主页id = 主页id_In;

  --并发操作检查
  Select Count(*)
  Into v_Count
  From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(附加床位, 0) = 0 And 开始时间 Is Not Null And 终止时间 Is Null;
  If v_Count > 1 Then
    v_Error := '发现病人存在非法的变动记录,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;

  Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In And 出院日期 Is Null;
  If v_Count = 0 Then
    v_Error := '操作失败,该病人已出院,不能进行当前操作.' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态！';
    Raise Err_Custom;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人变动记录_Preout;
/

--110466:黄捷,2017-06-22,已预约或在旧版PACS中已报到，出院后允许登记
--110511:黄捷,2017-06-22,已经检查后不允许在新版RIS中登记
--109791:黄捷,2017-06-06,RIS接口门诊报告专用复制
Create Or Replace Package b_Zlxwinterface Is
  Type t_Refcur Is Ref Cursor;

  --1、接收RIS状态改变
  Procedure Receiverisstate
  (
    医嘱id_In   病人医嘱发送.医嘱id%Type,
    Risid_In    病人医嘱报告.Risid%Type,
    状态_In     Number,
    操作人员_In 病人医嘱发送.完成人%Type,
    执行时间_In 病人医嘱发送.完成时间%Type := Null,
    执行说明_In 病人医嘱发送.执行说明%Type := Null,
    单独执行_In Number := 0
  );

  --2、费用确认
  Procedure 影像费用执行
  (
    医嘱id_In     影像检查记录.医嘱id%Type,
    单独执行_In   Number := 0,
    操作员编号_In 人员表.编号%Type := Null,
    操作员姓名_In 人员表.姓名%Type := Null,
    执行部门id_In 门诊费用记录.执行部门id%Type := Null
  );

  --3、取消费用确认
  Procedure 影像费用执行_Cancel
  (
    医嘱id_In     影像检查记录.医嘱id%Type,
    单独执行_In   Number := 0,
    操作员编号_In 人员表.编号%Type := Null,
    操作员姓名_In 人员表.姓名%Type := Null,
    执行部门id_In 门诊费用记录.执行部门id%Type := Null
  );

  --4、接收RIS的报告
  Procedure Receivereport
  (
    医嘱id_In   病人医嘱发送.医嘱id%Type,
    Risid_In    病人医嘱报告.Risid%Type,
    报告所见_In 电子病历内容.内容文本%Type,
    报告意见_In 电子病历内容.内容文本%Type,
    报告建议_In 电子病历内容.内容文本%Type,
    报告医生_In 电子病历记录.创建人%Type
  );

  --5、修改申请单信息
  Procedure 影像病人信息_修改
  (
    医嘱id_In       病人医嘱记录.Id%Type,
    姓名_In         病人信息.姓名%Type,
    性别_In         病人信息.性别%Type,
    年龄_In         病人信息.年龄%Type,
    费别_In         病人信息.费别%Type,
    医疗付款方式_In 病人信息.医疗付款方式%Type,
    民族_In         病人信息.民族%Type,
    婚姻_In         病人信息.婚姻状况%Type,
    职业_In         病人信息.职业%Type,
    身份证号_In     病人信息.身份证号%Type,
    家庭地址_In     病人信息.家庭地址%Type,
    家庭电话_In     病人信息.家庭电话%Type,
    家庭地址邮编_In 病人信息.家庭地址邮编%Type,
    出生日期_In     病人信息.出生日期%Type := Null
  );

  --6、取消申请单信息
  Procedure 取消检查申请单
  (
    医嘱id_In     病人医嘱执行.医嘱id%Type,
    操作员编号_In 人员表.编号%Type := Null,
    操作员姓名_In 人员表.姓名%Type := Null,
    执行部门id_In 门诊费用记录.执行部门id%Type := 0,
    拒绝原因_In   病人医嘱发送.执行说明%Type := Null
  );

  --7、插入医嘱操作失败记录
  Procedure Ris医嘱失败记录_Insert
  (
    病人来源_In   In Ris医嘱失败记录.病人来源%Type,
    病人id_In     In Ris医嘱失败记录.病人id%Type,
    主页id_In     In Ris医嘱失败记录.主页id%Type,
    挂号单号_In   In Ris医嘱失败记录.挂号单号%Type,
    发送号_In     In Ris医嘱失败记录.发送号%Type,
    体检任务id_In In Ris医嘱失败记录.体检任务id%Type,
    体检报到号_In In Ris医嘱失败记录.体检报到号%Type,
    发送类型_In   In Ris医嘱失败记录.发送类型%Type
  );

  --8、更新医嘱操作失败记录
  Procedure Ris医嘱失败记录_重发
  (
    Id_In       In Ris医嘱失败记录.Id%Type,
    操作类型_In In Number
  );

  --9、销账后新建住院记账单据
  Procedure 病人医嘱_重建单据
  (
    医嘱id_In In 病人医嘱发送.医嘱id%Type,
    No_In     In 病人医嘱发送.No%Type,
    Action_In In Number
  );

  --10、打印RIS检查预约通知单
  Procedure Ris检查预约_打印(医嘱id_In In Ris检查预约.医嘱id%Type);

  --11、更新RIS分科室启用参数
  Procedure Ris启用控制_Update
  (
    检查类型_In Ris启用控制.检查类型%Type,
    场合_In     Ris启用控制.场合%Type,
    部门ids_In  Varchar2,
    启用类型_In Number
  );

  --12、删除RIS分科室启用参数
  Procedure Ris启用控制_Delete;

  --13、根据元素名提取信息
  Function Ris_Replace_Element_Value
  (
    元素名_In   In 诊治所见项目.中文名%Type,
    病人id_In   In 电子病历记录.病人id%Type,
    就诊id_In   In 电子病历记录.主页id%Type,
    病人来源_In In 电子病历记录.病人来源%Type,
    医嘱id_In   In 病人医嘱发送.医嘱id%Type
  ) Return Varchar2;

End b_Zlxwinterface;
/
Create Or Replace Package Body b_Zlxwinterface Is

  --1、接收RIS状态改变
  Procedure Receiverisstate
  (
    医嘱id_In   病人医嘱发送.医嘱id%Type,
    Risid_In    病人医嘱报告.Risid%Type,
    状态_In     Number,
    操作人员_In 病人医嘱发送.完成人%Type,
    执行时间_In 病人医嘱发送.完成时间%Type := Null,
    执行说明_In 病人医嘱发送.执行说明%Type := Null,
    单独执行_In Number := 0
  ) Is
  
    --参数：医嘱ID_IN - 单独执行的医嘱ID。
    --      状态_IN - -1-删除；0-预约；1-登记；3-检查完成；4-检查中止；9-初步报告；12-报告审核；15-发放
    --     单独执行_In -0-全部执行；1-单独执行；检查医嘱组合是否采用对每个项目分散单独执行的方式
  
    Cursor c_Adviceinfo Is
      Select a.Id, a.相关id, Nvl(a.相关id, a.Id) As 组id, a.诊疗类别, a.病人来源, a.执行科室id, b.执行过程
      From 病人医嘱记录 a, 病人医嘱发送 b
      Where a.Id = b.医嘱id
      And Id = 医嘱id_In;
    r_Adviceinfo c_Adviceinfo%Rowtype;
  
    v_执行状态 病人医嘱发送.执行状态%Type;
    v_执行过程 病人医嘱发送.执行过程%Type;
    n_执行     Number; --标记是否需要更新状态，1：需要更新，其他不需要更新
    v_Count    Number;
    v_完成人   病人医嘱发送.完成人%Type;
    v_完成时间 病人医嘱发送.完成时间%Type;
    v_Error    Varchar2(255);
    Err_Custom Exception;
  
  Begin
  
    v_执行状态 := 0;
    v_执行过程 := 0;
  
    --提取医嘱的主医嘱ID，及组ID
    Open c_Adviceinfo;
    Fetch c_Adviceinfo
      Into r_Adviceinfo;
    Close c_Adviceinfo;
  
    --根据状态_IN执行医嘱
    ---1-删除；0-预约；1-登记；3-检查完成；4-检查中止；9-初步报告；12-报告审核；13-取消审核；14-报告删除；15-发放
  
    If 状态_In = -1 Or 状态_In = 0 Then
      v_执行状态 := 0; --未执行
      v_执行过程 := 0;
    Elsif 状态_In = 1 Then
      v_执行状态 := 3; --正在执行
      v_执行过程 := 2; --已报到
    Elsif 状态_In = 3 Or 状态_In = 14 Then
      v_执行状态 := 3; --正在执行
      v_执行过程 := 3; --已检查
    Elsif 状态_In = 4 Then
      --不改变
      v_执行状态 := v_执行状态;
    Elsif 状态_In = 9 Or 状态_In = 13 Then
      v_执行状态 := 3; --正在执行
      v_执行过程 := 4; --已报告
    Elsif 状态_In = 12 Then
      v_执行状态 := 3; --正在执行
      v_执行过程 := 5; --已审核
    Elsif 状态_In = 15 Then
      v_执行状态 := 1; --完全执行
      v_执行过程 := 6; --已完成
      v_完成人   := 操作人员_In;
      v_完成时间 := 执行时间_In;
    End If;
  
    n_执行 := 1; --默认都要更新状态
  
    If 状态_In = 13 Or 状态_In = 14 Then
      --删除对应报告数据
      Delete From 电子病历记录
      Where Id = (Select 病历id
                  From 病人医嘱报告
                  Where 医嘱id = 医嘱id_In
                  And Risid = Risid_In);
      Delete From 病人医嘱报告
      Where 医嘱id = 医嘱id_In
      And Risid = Risid_In;
    
      --删除后判断是否还存在报告，若存在则医嘱状态保持不变，若报告全部删除则更新医嘱状态
      Select Count(1) Into v_Count From 病人医嘱报告 Where 医嘱id = 医嘱id_In;
    
      If v_Count > 0 Then
        n_执行 := 0; --若存在则医嘱状态保持不变
      End If;
    End If;
  
    --如果是登记，先判断此检查是否未执行
    If 状态_In = 1 Then
      If r_Adviceinfo.执行过程 >= 3 Then
        v_Error := '患者已经做过检查了，不能重复登记。';
        Raise Err_Custom;
      End If;
    End If;
  
    --开始执行医嘱
    If n_执行 = 1 Then
      If Nvl(单独执行_In, 0) = 1 Then
        -- 单个部位医嘱单独执行
        Update 病人医嘱发送
        Set 执行状态 = v_执行状态, 执行过程 = v_执行过程, 执行说明 = 执行说明_In, 完成人 = v_完成人, 完成时间 = v_完成时间
        Where 医嘱id = 医嘱id_In;
      Else
        Update 病人医嘱发送
        Set 执行状态 = v_执行状态, 执行过程 = v_执行过程, 执行说明 = 执行说明_In, 完成人 = v_完成人, 完成时间 = v_完成时间
        Where 医嘱id In (Select Id From 病人医嘱记录 Where (Id = r_Adviceinfo.组id Or 相关id = r_Adviceinfo.组id));
      End If;
    End If;
  Exception
    When Err_Custom Then
      Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End Receiverisstate;

  --2、费用确认
  Procedure 影像费用执行
  (
    医嘱id_In     影像检查记录.医嘱id%Type,
    单独执行_In   Number := 0,
    操作员编号_In 人员表.编号%Type := Null,
    操作员姓名_In 人员表.姓名%Type := Null,
    执行部门id_In 门诊费用记录.执行部门id%Type := Null
  ) Is
    --参数：医嘱ID_IN=单独执行的医嘱ID。
    --      单独执行_In=检查医嘱组合是否采用对每个项目分散单独执行的方式,0-不单独执行
    Cursor c_Advice Is
      Select Id, 相关id, Nvl(相关id, Id) As 组id, 诊疗类别, 病人来源 From 病人医嘱记录 Where Id = 医嘱id_In;
    r_Advice c_Advice%Rowtype;
  
    v_Temp     Varchar2(255);
    v_人员编号 人员表.编号%Type;
    v_人员姓名 人员表.姓名%Type;
    v_部门id   部门表.Id%Type;
    v_费用性质 病人医嘱发送.记录性质%Type;
    v_发送号   病人医嘱发送.发送号%Type;
    v_执行过程 病人医嘱发送.执行过程%Type;
    v_Count    Number;
    v_Error    Varchar2(255);
    Err_Custom Exception;
  Begin
  
    --取主医嘱ID
    Open c_Advice;
    Fetch c_Advice
      Into r_Advice;
    Close c_Advice;
  
    Select 发送号, 执行过程 Into v_发送号, v_执行过程 From 病人医嘱发送 Where 医嘱id = r_Advice.组id;
  
    --登记和完成才执行费用  2-登记，3-检查，4-报告，5-审核，6-完成
    If v_执行过程 >= 2 Or v_执行过程 <= 6 Then
    
      --先检查是否已经出院的住院病人，已经预出院或者出院的检查申请，不允执行费用
      Select Count(*)
      Into v_Count
      From 病人医嘱记录 a, 病案主页 b
      Where a.病人id = b.病人id
      And a.主页id = b.主页id
      And (b.出院日期 Is Not Null Or b.状态 = 3)
      And a.Id = r_Advice.组id;
    
      If v_Count > 0 Then
        --已经出院或者预出院，如果已经预约则可以执行
        Select Count(*) Into v_Count From Ris检查预约 Where 医嘱id = r_Advice.组id;
        If v_Count = 0 Then
          --已经出院或者预出院，如果在旧版PACS已经报到，也可以执行
          Select Count(*) Into v_Count From 影像检查记录 Where 医嘱id = r_Advice.组id;
          If v_Count = 0 Then
            v_Error := '住院病人已经出院或者预出院，不能执行费用。';
            Raise Err_Custom;
          End If;
        End If;
      End If;
    
      --取当前操作人员
      If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null And 执行部门id_In Is Not Null Then
        v_人员编号 := 操作员编号_In;
        v_人员姓名 := 操作员姓名_In;
        v_部门id   := 执行部门id_In;
      Else
        v_Temp     := Zl_Identity;
        v_部门id   := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
        v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
        v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
      End If;
    
      If r_Advice.病人来源 = 2 Then
        Select Decode(记录性质, 1, 1, Decode(门诊记帐, 1, 1, 2))
        Into v_费用性质
        From 病人医嘱发送
        Where 发送号 = v_发送号
        And 医嘱id = 医嘱id_In;
      Else
        v_费用性质 := 1;
      End If;
    
      --执行费用和自动发料
      If v_费用性质 = 1 Then
        Zl_门诊医嘱执行_Finish(医嘱id_In, v_发送号, 单独执行_In, v_人员编号, v_人员姓名, r_Advice.组id, r_Advice.诊疗类别, v_部门id);
      Else
        Zl_住院医嘱执行_Finish(医嘱id_In, v_发送号, 单独执行_In, v_人员编号, v_人员姓名, r_Advice.组id, r_Advice.诊疗类别, v_部门id);
      End If;
    End If;
  
  Exception
    When Err_Custom Then
      Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End 影像费用执行;

  --3、取消费用确认
  Procedure 影像费用执行_Cancel
  (
    医嘱id_In     影像检查记录.医嘱id%Type,
    单独执行_In   Number := 0,
    操作员编号_In 人员表.编号%Type := Null,
    操作员姓名_In 人员表.姓名%Type := Null,
    执行部门id_In 门诊费用记录.执行部门id%Type := Null
  ) Is
    --参数：
    --      医嘱ID_IN=单独执行的医嘱ID。
    --      单独执行_In=检查医嘱组合是否采用对每个项目分散单独执行的方式,0-不单独执行
  
    Cursor c_Advice Is
      Select Id, 相关id, Nvl(相关id, Id) As 组id From 病人医嘱记录 Where Id = 医嘱id_In;
    r_Advice c_Advice%Rowtype;
  
    v_发送号 病人医嘱发送.发送号%Type;
    v_Count  Number;
    v_Error  Varchar2(255);
    Err_Custom Exception;
  
  Begin
  
    --取主医嘱ID
    Open c_Advice;
    Fetch c_Advice
      Into r_Advice;
    Close c_Advice;
  
    --先检查是否已经出院的住院病人，已经预出院或者出院的检查申请，不允执行费用
    Select Count(*)
    Into v_Count
    From 病人医嘱记录 a, 病案主页 b
    Where a.病人id = b.病人id
    And a.主页id = b.主页id
    And (b.出院日期 Is Not Null Or b.状态 = 3)
    And a.Id = r_Advice.组id;
  
    If v_Count > 0 Then
      v_Error := '住院病人已经出院或者预出院，不能取消费用。';
      Raise Err_Custom;
    End If;
  
    Select 发送号 Into v_发送号 From 病人医嘱发送 Where 医嘱id = r_Advice.组id;
  
    --调用统一的医嘱执行Cancel过程
    Zl_病人医嘱执行_Cancel(医嘱id_In, v_发送号, Null, 单独执行_In, 执行部门id_In, 操作员编号_In, 操作员姓名_In);
  
  Exception
    When Err_Custom Then
      Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End 影像费用执行_Cancel;

  --4、接收RIS的报告
  Procedure Receivereport
  (
    医嘱id_In   病人医嘱发送.医嘱id%Type,
    Risid_In    病人医嘱报告.Risid%Type,
    报告所见_In 电子病历内容.内容文本%Type,
    报告意见_In 电子病历内容.内容文本%Type,
    报告建议_In 电子病历内容.内容文本%Type,
    报告医生_In 电子病历记录.创建人%Type
  ) Is
    --提取病人医嘱及报告的相关信息
    Cursor c_Advice
    (
      v_组id  Number,
      v_Risid Number
    ) Is
      Select e.Id, e.病人来源, e.病人id, e.主页id, e.婴儿, e.病人科室id, e.文件id, e.病历种类, e.病历名称, f.病历id, e.执行科室id
      From (Select c.Id, c.病人来源, c.病人id, c.主页id, c.婴儿, c.病人科室id, c.文件id, d.种类 病历种类, d.名称 病历名称, c.执行科室id
             From (Select a.Id, a.病人来源, a.病人id, a.主页id, a.婴儿, a.病人科室id, b.病历文件id 文件id, a.执行科室id
                    From 病人医嘱记录 a, 病历单据应用 b
                    Where a.Id = v_组id
                    And a.诊疗项目id = b.诊疗项目id(+)
                    And b.应用场合(+) = Decode(a.病人来源, 2, 2, 4, 4, 1)) c, 病历文件列表 d
             Where c.文件id = d.Id(+)) e, 病人医嘱报告 f
      Where e.Id = f.医嘱id(+)
      And f.Risid(+) = v_Risid;
  
    --查找文件的组成元素
    Cursor c_File(v_File Number) Is
      Select a.Id, a.文件id, a.父id, a.对象序号, a.对象类型, a.对象标记, a.保留对象, a.对象属性, a.内容行次, a.内容文本, a.是否换行, a.预制提纲id, a.复用提纲,
             a.使用时机, a.诊治要素id, a.替换域, a.要素名称, a.要素类型, a.要素长度, a.要素小数, a.要素单位, a.要素表示, a.输入形态, a.要素值域
      From 病历文件结构 a
      Where a.文件id = v_File
      Order By a.对象序号;
  
    Cursor c_Report(v_电子病历记录id Number) Is
      Select b.Id, a.内容文本
      From 电子病历内容 a, 电子病历内容 b
      Where a.对象类型 = 3
      And a.Id = b.父id
      And b.对象类型 = 2
      And b.终止版 = 0
      And a.文件id = v_电子病历记录id;
  
    Cursor c_Content
    (
      v_文件id Number,
      v_表格id Number
    ) Is
      Select a.Id, a.文件id, a.父id, a.对象序号, a.对象类型, a.对象标记, a.保留对象, a.对象属性, a.内容行次, a.内容文本, a.是否换行, a.预制提纲id, a.复用提纲,
             a.使用时机, a.诊治要素id, a.替换域, a.要素名称, a.要素类型, a.要素长度, a.要素小数, a.要素单位, a.要素表示, a.输入形态, a.要素值域
      From 病历文件结构 a
      Where 文件id = v_文件id
      And 父id = v_表格id;
  
    r_Advice        c_Advice%Rowtype;
    v_病历id        电子病历内容.文件id%Type;
    v_病历内容id    电子病历内容.Id%Type;
    v_病历内容idnew 电子病历内容.Id%Type;
    v_对象序号      电子病历内容.对象序号%Type;
    v_父id          电子病历内容.父id%Type;
    v_内容文本      电子病历内容.内容文本%Type;
    v_定义提纲id    电子病历内容.定义提纲id%Type;
    --v_格式内容    电子病历格式.内容%Type;
    v_Error Varchar2(255);
    Err_Custom Exception;
    v_主医嘱id 病人医嘱发送.医嘱id%Type;
    v_表格     Varchar2(300);
    n_数量     Number;
    n_Rptcount Number;
    v_病历名称 电子病历记录.病历名称%Type;
    v_挂号单id 病人挂号记录.Id%Type;
  
    Function Getrptno
    (
      v_医嘱idin   病人医嘱发送.医嘱id%Type,
      v_病历名称in 电子病历记录.病历名称%Type
    ) Return Varchar As
      v_Return Number;
      v_No     Number;
      v_Count  Number;
    Begin
      Select Count(医嘱id) + 1 Into v_No From 病人医嘱报告 Where 医嘱id = v_医嘱idin;
      v_Count := 1;
      While v_Count = 1 Loop
        Select Count(Id)
        Into v_Count
        From 病人医嘱报告 a, 电子病历记录 b
        Where a.医嘱id = v_医嘱idin
        And a.病历id = b.Id
        And b.病历名称 = v_病历名称in || v_No;
        If v_Count = 1 Then
          v_No := v_No + 1;
        End If;
      End Loop;
      v_Return := v_No;
      Return v_Return;
    End Getrptno;
  
  Begin
  
    -- 提取主医嘱ID ，防止因为传入部位医嘱，导致报告保存出错
    Select Nvl(相关id, Id) As 组id Into v_主医嘱id From 病人医嘱记录 Where Id = 医嘱id_In;
  
    Open c_Advice(v_主医嘱id, Nvl(Risid_In, 0));
    Fetch c_Advice
      Into r_Advice;
  
    If Nvl(r_Advice.文件id, 0) = 0 Then
      v_Error := '本次检查项目没有对应相关的检查报告，请与管理员联系！';
      Raise Err_Custom;
    Else
      If Nvl(r_Advice.病历id, 0) > 0 Then
        ----产生过报告
        --找出检查已填写的报告提纲中含有"%所见%","%描述%","%建议%","%意见%",并用传入的参数更新
        For r_Report In c_Report(r_Advice.病历id) Loop
          If r_Report.内容文本 Like '%所见%' Then
            Update 电子病历内容 Set 内容文本 = 报告所见_In || Chr(13) || Chr(13) Where Id = r_Report.Id;
          Elsif r_Report.内容文本 Like '%意见%' Then
            Update 电子病历内容 Set 内容文本 = 报告意见_In || Chr(13) || Chr(13) Where Id = r_Report.Id;
          Elsif r_Report.内容文本 Like '%建议%' Then
            Update 电子病历内容 Set 内容文本 = 报告建议_In || Chr(13) || Chr(13) Where Id = r_Report.Id;
          End If;
        End Loop;
        --更新保存时间
        Update 电子病历记录
        Set 完成时间 = Sysdate, 保存人 = 报告医生_In, 保存时间 = Sysdate
        Where Id = r_Advice.病历id;
      Else
        --先判断单据中是否有对应的提纲和表格
        If Nvl(报告所见_In, ' ') <> ' ' Then
          Select Count(1)
          Into n_数量
          From 病历文件结构 a, 病历文件结构 b
          Where a.父id = b.Id
          And a.对象类型 = 3
          And b.对象类型 = 1
          And a.内容文本 Like '%所见%'
          And a.文件id = r_Advice.文件id;
        
          If n_数量 <= 0 Then
            v_Error := '在诊疗单据中没有找到【所见】对应的提纲或表格，请联系管理员设置！';
            Raise Err_Custom;
          End If;
        End If;
        If Nvl(报告意见_In, ' ') <> ' ' Then
          Select Count(1)
          Into n_数量
          From 病历文件结构 a, 病历文件结构 b
          Where a.父id = b.Id
          And a.对象类型 = 3
          And b.对象类型 = 1
          And a.内容文本 Like '%意见%'
          And a.文件id = r_Advice.文件id;
        
          If n_数量 <= 0 Then
            v_Error := '在诊疗单据中没有找到【意见】对应的提纲或表格，请联系管理员设置！';
            Raise Err_Custom;
          End If;
        End If;
        If Nvl(报告建议_In, ' ') <> ' ' Then
          Select Count(1)
          Into n_数量
          From 病历文件结构 a, 病历文件结构 b
          Where a.父id = b.Id
          And a.对象类型 = 3
          And b.对象类型 = 1
          And a.内容文本 Like '%建议%'
          And a.文件id = r_Advice.文件id;
        
          If n_数量 <= 0 Then
            v_Error := '在诊疗单据中没有找到【建议】对应的提纲或表格，请联系管理员设置！';
            Raise Err_Custom;
          End If;
        End If;
      
        If r_Advice.病人来源 = 1 Then
          --门诊，提取挂号单ID
          Select Nvl(c.Id, 0)
          Into v_挂号单id
          From 病人医嘱记录 b, 病人挂号记录 c
          Where b.挂号单 = c.No(+)
          And c.记录状态 In (1, 3)
          And b.Id = v_主医嘱id;
        Else
          --体检或者外诊，无挂号单ID，直接设置为0
          v_挂号单id := 0;
        End If;
      
        --产生电子病历记录
        Select 电子病历记录_Id.Nextval Into v_病历id From Dual;
        n_Rptcount := Getrptno(医嘱id_In, r_Advice.病历名称);
        If n_Rptcount > 1 Then
          v_病历名称 := r_Advice.病历名称 || n_Rptcount;
        Else
          v_病历名称 := r_Advice.病历名称;
        End If;
        Insert Into 电子病历记录
          (Id, 病人来源, 病人id, 主页id, 婴儿, 科室id, 病历种类, 文件id, 病历名称, 创建人, 创建时间, 完成时间, 保存人, 保存时间, 最后版本, 签名级别)
        Values
          (v_病历id, r_Advice.病人来源, r_Advice.病人id, Decode(r_Advice.病人来源, 2, r_Advice.主页id, v_挂号单id), r_Advice.婴儿,
           r_Advice.病人科室id, r_Advice.病历种类, r_Advice.文件id, v_病历名称, 报告医生_In, Sysdate, Sysdate, 报告医生_In, Sysdate, 1, 2);
      
        --产生医嘱报告记录
        Insert Into 病人医嘱报告 (医嘱id, 病历id, Risid) Values (v_主医嘱id, v_病历id, Risid_In);
      
        v_对象序号 := 0;
      
        --新产生报告内容
        For r_File In c_File(r_Advice.文件id) Loop
          Select 电子病历内容_Id.Nextval Into v_病历内容id From Dual;
          v_内容文本   := r_File.内容文本;
          v_定义提纲id := 0;
        
          If Nvl(r_File.对象类型, 0) = 1 And Nvl(r_File.父id, 0) = 0 Then
            --提纲
            v_定义提纲id := r_File.Id;
            v_父id       := v_病历内容id;
          End If;
        
          If Nvl(r_File.对象类型, 0) = 4 And r_File.要素名称 Is Not Null Then
            --元素
            v_内容文本 := Zl_Replace_Element_Value(r_File.要素名称, r_Advice.病人id, r_Advice.主页id, r_Advice.病人来源, r_Advice.Id);
          End If;
        
          If Nvl(r_File.父id, 0) <> 0 Then
            v_定义提纲id := 0;
          End If;
        
          v_对象序号 := v_对象序号 + 1;
        
          If Instr(v_表格, '|' || r_File.父id || '|') > 0 Then
            Null;
          Else
            Insert Into 电子病历内容
              (Id, 文件id, 开始版, 终止版, 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行, 预制提纲id, 复用提纲, 使用时机, 诊治要素id, 替换域,
               要素名称, 要素类型, 要素长度, 要素小数, 要素单位, 要素表示, 输入形态, 要素值域, 定义提纲id)
            Values
              (v_病历内容id, v_病历id, 1, 0, Decode(v_定义提纲id, 0, v_父id, Null), v_对象序号, r_File.对象类型, r_File.对象标记, r_File.保留对象,
               r_File.对象属性, Null, v_内容文本, r_File.是否换行, r_File.预制提纲id, r_File.复用提纲, r_File.使用时机, r_File.诊治要素id,
               r_File.替换域, r_File.要素名称, r_File.要素类型, r_File.要素长度, r_File.要素小数, r_File.要素单位, r_File.要素表示, r_File.输入形态,
               r_File.要素值域, Decode(v_定义提纲id, 0, Null, v_定义提纲id));
          End If;
        
          --为表格时，插入文本内容
          If Nvl(r_File.对象类型, 0) = 3 And Nvl(r_File.父id, 0) <> 0 Then
            v_表格 := v_表格 || ',|' || r_File.Id || '|';
          
            If r_File.内容文本 Like '%所见%' Then
              v_内容文本 := 报告所见_In || Chr(13) || Chr(13);
            Elsif r_File.内容文本 Like '%意见%' Then
              v_内容文本 := 报告意见_In || Chr(13) || Chr(13);
            Else
              v_内容文本 := 报告建议_In || Chr(13) || Chr(13);
            End If;
          
            For r_Con In c_Content(r_Advice.文件id, r_File.Id) Loop
              Select 电子病历内容_Id.Nextval Into v_病历内容idnew From Dual;
              v_对象序号 := v_对象序号 + 1;
            
              Insert Into 电子病历内容
                (Id, 文件id, 开始版, 终止版, 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行, 预制提纲id, 复用提纲, 使用时机, 诊治要素id,
                 替换域, 要素名称, 要素类型, 要素长度, 要素小数, 要素单位, 要素表示, 输入形态, 要素值域, 定义提纲id)
              Values
                (v_病历内容idnew, v_病历id, 1, 0, v_病历内容id, v_对象序号, 2, r_Con.对象标记, r_Con.保留对象, r_Con.对象属性, Null, v_内容文本,
                 r_Con.是否换行, r_Con.预制提纲id, r_Con.复用提纲, r_Con.使用时机, r_Con.诊治要素id, r_Con.替换域, r_Con.要素名称, r_Con.要素类型,
                 r_Con.要素长度, r_Con.要素小数, r_Con.要素单位, r_Con.要素表示, r_Con.输入形态, r_Con.要素值域,
                 Decode(v_定义提纲id, 0, Null, v_定义提纲id));
            End Loop;
          End If;
        End Loop;
      
        --因电子病历格式中含了内容文字格式，此种方法导入之后内容文字将不可见
        --Select 内容 Into v_格式内容 From 病历文件格式 Where 文件ID=r_Advice.文件ID;
        --Insert Into 电子病历格式 (文件ID,内容) Values (v_病历id,v_格式内容);
      
      End If;
    End If;
    Close c_Advice;
  
  Exception
    When Err_Custom Then
      Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End Receivereport;

  --5、修改申请单信息
  Procedure 影像病人信息_修改
  (
    医嘱id_In       病人医嘱记录.Id%Type,
    姓名_In         病人信息.姓名%Type,
    性别_In         病人信息.性别%Type,
    年龄_In         病人信息.年龄%Type,
    费别_In         病人信息.费别%Type,
    医疗付款方式_In 病人信息.医疗付款方式%Type,
    民族_In         病人信息.民族%Type,
    婚姻_In         病人信息.婚姻状况%Type,
    职业_In         病人信息.职业%Type,
    身份证号_In     病人信息.身份证号%Type,
    家庭地址_In     病人信息.家庭地址%Type,
    家庭电话_In     病人信息.家庭电话%Type,
    家庭地址邮编_In 病人信息.家庭地址邮编%Type,
    出生日期_In     病人信息.出生日期%Type := Null
  ) As
  
    v_年龄     Varchar2(20);
    v_年龄单位 Varchar2(20);
    v_出生日期 Date;
    v_病人来源 病人医嘱记录.病人来源%Type;
    v_病人id   病人医嘱记录.病人id%Type;
  Begin
    Begin
      Select 病人来源, 病人id Into v_病人来源, v_病人id From 病人医嘱记录 Where Id = 医嘱id_In;
    Exception
      When Others Then
        Return;
    End;
  
    If 出生日期_In Is Null And 年龄_In Is Not Null Then
      --根据年龄求出生日期
      v_年龄单位 := Substr(年龄_In, Length(年龄_In), 1);
      If Instr('岁,月,天', v_年龄单位) <= 0 Then
        v_年龄单位 := Null;
      Else
        v_年龄 := Replace(年龄_In, v_年龄单位, '');
      End If;
      Begin
        v_年龄 := To_Number(v_年龄);
      Exception
        When Others Then
          v_年龄 := Null;
      End;
      If v_年龄 Is Not Null And v_年龄单位 Is Not Null Then
        Select Decode(v_年龄单位, '岁', Add_Months(Sysdate, -12 * v_年龄), '月', Add_Months(Sysdate, -1 * v_年龄), '天',
                       Sysdate - v_年龄)
        Into v_出生日期
        From Dual;
      End If;
    Else
      v_出生日期 := 出生日期_In;
    End If;
  
    If v_病人来源 = 3 Then
      Update 病人信息
      Set 姓名 = 姓名_In, 性别 = Nvl(性别_In, 性别), 年龄 = 年龄_In, 出生日期 = v_出生日期, 费别 = Nvl(费别_In, 费别),
          医疗付款方式 = Nvl(医疗付款方式_In, 医疗付款方式), 民族 = Nvl(民族_In, 民族), 婚姻状况 = Nvl(婚姻_In, 婚姻状况), 职业 = Nvl(职业_In, 职业),
          身份证号 = 身份证号_In, 家庭地址 = 家庭地址_In, 家庭电话 = 家庭电话_In, 家庭地址邮编 = 家庭地址邮编_In
      Where 病人id = v_病人id;
    
      --修改对应的医嘱记录
      Update 病人医嘱记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In
      Where Id = 医嘱id_In
      Or 相关id = 医嘱id_In;
    Else
      Update 病人信息
      Set 民族 = Nvl(民族_In, 民族), 婚姻状况 = Nvl(婚姻_In, 婚姻状况), 职业 = Nvl(职业_In, 职业), 家庭地址 = 家庭地址_In, 家庭电话 = 家庭电话_In,
          家庭地址邮编 = 家庭地址邮编_In
      Where 病人id = v_病人id;
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End 影像病人信息_修改;

  --6、取消申请单信息
  Procedure 取消检查申请单
  (
    医嘱id_In     病人医嘱执行.医嘱id%Type,
    操作员编号_In 人员表.编号%Type := Null,
    操作员姓名_In 人员表.姓名%Type := Null,
    执行部门id_In 门诊费用记录.执行部门id%Type := 0,
    拒绝原因_In   病人医嘱发送.执行说明%Type := Null
  ) As
    --参数：医嘱ID_IN=单独执行的医嘱ID
  
    v_发送号 病人医嘱执行.发送号%Type;
  
  Begin
  
    Begin
      Select 发送号 Into v_发送号 From 病人医嘱发送 Where 医嘱id = 医嘱id_In;
    Exception
      When Others Then
        Return;
    End;
  
    Zl_病人医嘱执行_拒绝执行(医嘱id_In, v_发送号, 操作员编号_In, 操作员姓名_In, 执行部门id_In, 拒绝原因_In);
  
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End 取消检查申请单;

  --7、插入医嘱操作失败记录
  Procedure Ris医嘱失败记录_Insert
  (
    病人来源_In   In Ris医嘱失败记录.病人来源%Type,
    病人id_In     In Ris医嘱失败记录.病人id%Type,
    主页id_In     In Ris医嘱失败记录.主页id%Type,
    挂号单号_In   In Ris医嘱失败记录.挂号单号%Type,
    发送号_In     In Ris医嘱失败记录.发送号%Type,
    体检任务id_In In Ris医嘱失败记录.体检任务id%Type,
    体检报到号_In In Ris医嘱失败记录.体检报到号%Type,
    发送类型_In   In Ris医嘱失败记录.发送类型%Type
  ) Is
  Begin
    Insert Into Ris医嘱失败记录
      (Id, 病人来源, 病人id, 主页id, 挂号单号, 发送号, 体检任务id, 体检报到号, 发送类型, 发送时间, 重发次数)
    Values
      (Ris医嘱失败记录_Id.Nextval, 病人来源_In, 病人id_In, 主页id_In, 挂号单号_In, 发送号_In, 体检任务id_In, 体检报到号_In, 发送类型_In, Sysdate, 0);
  
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End Ris医嘱失败记录_Insert;

  --8、更新医嘱操作失败记录
  Procedure Ris医嘱失败记录_重发
  (
    Id_In       In Ris医嘱失败记录.Id%Type,
    操作类型_In In Number
  ) Is
    v_重发次数 Ris医嘱失败记录.重发次数%Type;
  Begin
    --操作类型_In -- 1 重发成功，删除记录；2--重发失败
  
    If 操作类型_In = 1 Then
      Delete From Ris医嘱失败记录 Where Id = Id_In;
    Else
      Select 重发次数 Into v_重发次数 From Ris医嘱失败记录 Where Id = Id_In;
      If v_重发次数 >= 99 Then
        v_重发次数 := 99;
      Else
        v_重发次数 := v_重发次数 + 1;
      End If;
      Update Ris医嘱失败记录 Set 发送时间 = Sysdate, 重发次数 = v_重发次数 Where Id = Id_In;
    End If;
  
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End Ris医嘱失败记录_重发;

  --9、销账后新建住院记账单据
  Procedure 病人医嘱_重建单据
  (
    医嘱id_In In 病人医嘱发送.医嘱id%Type,
    No_In     In 病人医嘱发送.No%Type,
    Action_In In Number
  ) Is
    -- Action_In: 1 重建单据；2 取消重建单据
    v_No 病人医嘱发送.No%Type;
  Begin
    If Action_In = 1 Then
      Select Nextno(14) Into v_No From Dual;
    
      Update 病人医嘱发送
      Set No = v_No, 计费状态 = 0
      Where 医嘱id In (Select Id
                     From 病人医嘱记录
                     Where Id = 医嘱id_In
                     Or 相关id = 医嘱id_In);
      Update 住院费用记录 Set 医嘱序号 = Null Where No = No_In;
    Elsif Action_In = 2 Then
      Update 住院费用记录 Set 医嘱序号 = 医嘱id_In Where No = No_In;
      Update 病人医嘱发送
      Set No = No_In, 计费状态 = 4
      Where 医嘱id In (Select Id
                     From 病人医嘱记录
                     Where Id = 医嘱id_In
                     Or 相关id = 医嘱id_In);
    End If;
  
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End 病人医嘱_重建单据;

  --10、打印RIS检查预约通知单
  Procedure Ris检查预约_打印(医嘱id_In In Ris检查预约.医嘱id%Type) Is
  Begin
    Update Ris检查预约 Set 是否打印 = 1 Where 医嘱id = 医嘱id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End Ris检查预约_打印;

  --11、更新RIS分科室启用参数
  Procedure Ris启用控制_Update
  (
    检查类型_In Ris启用控制.检查类型%Type,
    场合_In     Ris启用控制.场合%Type,
    部门ids_In  Varchar2,
    启用类型_In Number
  ) Is
  
    l_部门id   t_Numlist := t_Numlist();
    v_启用ris  Ris启用控制.是否启用ris%Type;
    v_启用预约 Ris启用控制.是否启用预约%Type;
  
    Cursor c_Dept(Dept_In Varchar2) Is
      Select Column_Value From Table(f_Num2list(Dept_In));
  Begin
  
    If 启用类型_In = 1 Then
      v_启用ris  := 1;
      v_启用预约 := Null;
      Delete From Ris启用控制
      Where 检查类型 = 检查类型_In
      And 场合 = 场合_In
      And 是否启用ris = 1;
    Else
      v_启用ris  := Null;
      v_启用预约 := 1;
      Delete From Ris启用控制
      Where 检查类型 = 检查类型_In
      And 场合 = 场合_In
      And 是否启用预约 = 1;
    End If;
  
    If 部门ids_In Is Null Then
      Insert Into Ris启用控制
        (Id, 检查类型, 场合, 部门id, 是否启用ris, 是否启用预约)
      Values
        (Ris启用控制_Id.Nextval, 检查类型_In, 场合_In, Null, v_启用ris, v_启用预约);
    Else
      Open c_Dept(部门ids_In);
      Fetch c_Dept Bulk Collect
        Into l_部门id;
      Close c_Dept;
    
      Forall i In 1 .. l_部门id.Count
        Insert Into Ris启用控制
          (Id, 检查类型, 场合, 部门id, 是否启用ris, 是否启用预约)
        Values
          (Ris启用控制_Id.Nextval, 检查类型_In, 场合_In, l_部门id(i), v_启用ris, v_启用预约);
    End If;
  
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End Ris启用控制_Update;

  --12、删除RIS分科室启用参数
  Procedure Ris启用控制_Delete Is
  
  Begin
    Delete From Ris启用控制;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End Ris启用控制_Delete;

  --13、根据元素名提取信息
  Function Ris_Replace_Element_Value
  (
    元素名_In   In 诊治所见项目.中文名%Type,
    病人id_In   In 电子病历记录.病人id%Type,
    就诊id_In   In 电子病历记录.主页id%Type,
    病人来源_In In 电子病历记录.病人来源%Type,
    医嘱id_In   In 病人医嘱发送.医嘱id%Type
  ) Return Varchar2 Is
    v_Return Varchar2(4000) := Null;
    Cursor c_Patient Is
      Select 姓名, 性别, Decode(性别, '男', 'M', '女', 'F', 'O') As 性别编码, 出生日期, 病人id, 联系人地址, 家庭电话, 联系人电话, 婚姻状况, 身份证号, 当前科室id,
             当前病区id, 当前床号 As 床号, 就诊卡号, 入院时间, 出院时间
      From 病人信息
      Where 病人id = 病人id_In;
    r_Patient c_Patient%Rowtype;
  
    Cursor c_Order Is
      Select 主页id, 婴儿, Decode(病人来源, 1, 'OUTPAT', 2, 'INPAT', 'UNK') As 病人来源, 开嘱医生, 开嘱时间, 校对护士, 医嘱内容, 紧急标志, 执行科室id
      From 病人医嘱记录
      Where Id = 医嘱id_In;
    r_Order c_Order%Rowtype;
  
    Cursor c_Diagnose Is
      Select 诊断描述 || Decode(Nvl(是否疑诊, 0), 0, '', ' (？)') As 临床诊断
      From 病人诊断医嘱 a, 病人诊断记录 b
      Where a.医嘱id = 医嘱id_In
      And a.诊断id = b.Id;
    r_Diagnose c_Diagnose%Rowtype;
  
    --获取指定表的行类型
    Procedure p_Get_Rowtype(Table_In In Varchar2) Is
    Begin
      If Table_In = '病人信息' Then
        Open c_Patient;
        Fetch c_Patient
          Into r_Patient;
      Elsif Table_In = '病人医嘱记录' Then
        Open c_Order;
        Fetch c_Order
          Into r_Order;
      Elsif Table_In = '病人诊断记录' Then
        Open c_Diagnose;
        Fetch c_Diagnose
          Into r_Diagnose;
      End If;
    Exception
      When Others Then
        Null;
    End p_Get_Rowtype;
  
  Begin
    Case
    --直接返回的输入元素
      When 元素名_In = '医嘱ID' Then
        v_Return := 医嘱id_In;
      When 元素名_In = '病人ID' Then
        v_Return := 病人id_In;
      
    --姓名，性别单独处理，可能是婴儿
      When Instr(',姓名,性别,性别编码,出生日期,', ',' || 元素名_In || ',') > 0 Then
        p_Get_Rowtype('病人医嘱记录');
        p_Get_Rowtype('病人信息');
        If Nvl(r_Order.婴儿, 0) = 0 Then
          If 元素名_In = '姓名' Then
            v_Return := r_Patient.姓名;
          Elsif 元素名_In = '性别' Then
            v_Return := r_Patient.性别;
          Elsif 元素名_In = '性别编码' Then
            v_Return := r_Patient.性别编码;
          Elsif 元素名_In = '出生日期' Then
            v_Return := To_Char(r_Patient.出生日期, 'YYYYMMDDMISS');
          End If;
        Else
          If 元素名_In = '姓名' Then
            Select Decode(婴儿姓名, Null, r_Patient.姓名 || '之婴' || Trim(To_Char(序号, '9')), 婴儿姓名) As 婴儿姓名
            Into v_Return
            From 病人新生儿记录
            Where 病人id = 病人id_In
            And 主页id = r_Order.主页id
            And 序号 = Nvl(r_Order.婴儿, 0);
          Elsif Instr('性别', 元素名_In) > 0 Then
            Select 婴儿性别
            Into v_Return
            From 病人新生儿记录
            Where 病人id = 病人id_In
            And 主页id = r_Order.主页id
            And 序号 = Nvl(r_Order.婴儿, 0);
            If 元素名_In = '性别编码' Then
              Select Decode(v_Return, '男', 'M', '女', 'F', 'O') Into v_Return From Dual;
            End If;
          Elsif 元素名_In = '出生日期' Then
            Select 出生时间
            Into v_Return
            From 病人新生儿记录
            Where 病人id = 病人id_In
            And 主页id = r_Order.主页id
            And 序号 = Nvl(r_Order.婴儿, 0);
            v_Return := To_Char(v_Return, 'YYYYMMDDMISS');
          End If;
        End If;
      
    --查询病人信息表返回的元素
      When Instr(',联系人地址,家庭电话,联系人电话,婚姻状况,身份证号,床号,就诊卡号,入院时间,出院时间,', ',' || 元素名_In || ',') > 0 Then
        p_Get_Rowtype('病人信息');
        Case 元素名_In
          When '联系人地址' Then
            v_Return := r_Patient.联系人地址;
          When '家庭电话' Then
            v_Return := r_Patient.家庭电话;
          When '联系人电话' Then
            v_Return := r_Patient.联系人电话;
          When '婚姻状况' Then
            v_Return := r_Patient.婚姻状况;
          When '身份证号' Then
            v_Return := r_Patient.身份证号;
          When '床号' Then
            v_Return := r_Patient.床号;
          When '就诊卡号' Then
            v_Return := r_Patient.就诊卡号;
          When '入院时间' Then
            v_Return := To_Char(r_Patient.入院时间, 'YYYYMMDDMISS');
          When '出院时间' Then
            v_Return := To_Char(r_Patient.出院时间, 'YYYYMMDDMISS');
          Else
            v_Return := '';
        End Case;
        --查询医嘱表返回的元素
      When Instr(',病人来源,开嘱医生,开嘱时间,校对护士,医嘱内容,紧急标志,紧急标志对码,', ',' || 元素名_In || ',') > 0 Then
        p_Get_Rowtype('病人医嘱记录');
        Case 元素名_In
          When '病人来源' Then
            v_Return := r_Order.病人来源;
          When '开嘱医生' Then
            v_Return := r_Order.开嘱医生;
          When '开嘱时间' Then
            v_Return := To_Char(r_Order.开嘱时间, 'YYYYMMDDMISS');
          When '校对护士' Then
            v_Return := r_Order.校对护士;
          When '医嘱内容' Then
            v_Return := r_Order.医嘱内容;
          When '紧急标志' Then
            v_Return := r_Order.紧急标志;
        End Case;
        --查询诊断记录返回的元素
      When 元素名_In = '临床诊断' Then
        p_Get_Rowtype('病人诊断记录');
        v_Return := r_Diagnose.临床诊断;
      
      Else
        --自行查询SQL返回值的元素
        If 元素名_In = '执行站点' Then
          p_Get_Rowtype('病人医嘱记录');
          Select Decode(站点, 1, 'SITE0002', 2, 'SITE0001', 3, 'SITE0003', 'SITE0001')
          Into v_Return
          From 部门表
          Where Id = r_Order.执行科室id;
        End If;
        If 元素名_In = '当前科室名称' Then
          p_Get_Rowtype('病人信息');
          Select 名称 Into v_Return From 部门表 Where Id = r_Patient.当前科室id;
        End If;
        If 元素名_In = '病区名称' Then
          p_Get_Rowtype('病人信息');
          Select 名称 Into v_Return From 部门表 Where Id = r_Patient.当前病区id;
        End If;
        If 元素名_In = '标识号' Then
          Select Decode(a.病人来源, 1, c.门诊号, 2, Decode(c.住院号, Null, c.门诊号, c.住院号), 4, c.健康号, c.门诊号)
          Into v_Return
          From 病人医嘱记录 a, 病人信息 c
          Where a.病人id = c.病人id
          And a.Id = 医嘱id_In;
        End If;
    End Case;
  
    Return Trim(v_Return);
  Exception
    When Others Then
      Return Null;
  End Ris_Replace_Element_Value;
End b_Zlxwinterface;
/

--107905:冉俊明,2017-07-05,重新收费他人的异常收费单据，重新结算他人的异常补充结算单据

Create Or Replace Procedure Zl_门诊异常收费_更新操作员
(
  病人id_In     门诊费用记录.病人id%Type,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  结算序号_In   病人预交记录.结算序号%Type
) As
  n_组id 病人预交记录.缴款组id%Type;
Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  For c_预交 In (Select Distinct 结帐id, 操作员姓名
               From 病人预交记录
               Where Nvl(病人id, 0) + 0 = Nvl(病人id_In, 0) And 结算序号 = 结算序号_In) Loop
    --1.更新门诊费用记录的操作员
    Update 门诊费用记录
    Set 缴款组id = n_组id, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In
    Where Nvl(病人id, 0) + 0 = Nvl(病人id_In, 0) And 结帐id = c_预交.结帐id;
    If Sql%RowCount = 0 Then
      Update 费用补充记录
      Set 缴款组id = n_组id, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In
      Where Nvl(病人id, 0) + 0 = Nvl(病人id_In, 0) And 结算id = c_预交.结帐id;
    End If;
  
    --2.更新病人预交记录的操作员
    --将原操作员姓名存在“摘要”中
    Update 病人预交记录
    Set 缴款组id = n_组id, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In, 摘要 = 摘要 || '(原收款员：' || c_预交.操作员姓名 || ')'
    Where 结帐id = c_预交.结帐id And Nvl(病人id, 0) + 0 = Nvl(病人id_In, 0);
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊异常收费_更新操作员;
/

--109209:涂建华,2017-06-05,调整检查报告返回格式
--109808:涂建华,2017-06-14,增加临时枚举元素处理
--110917:涂建华,2017-07-04,保持内容中的回车符
CREATE OR REPLACE Function Zlpub_Pacs_获取文档内容
( 
  报告ID_In In 影像报告记录.ID%Type, 
  报告提纲_In In 影像报告记录.诊断意见%Type 
) Return Varchar2 Is 
  x_Content        xmltype; 
  Xcdom            Xmldom.Domdocument; 
  Section_List     Xmldom.Domnodelist; 
  Section_Node     Xmldom.Domnode; 
  Node_List        Xmldom.Domnodelist; 
  n_Len            Number; 
  Element_Node     Xmldom.Domnode; 
  p_Node           Xmldom.Domnode; 
  Enum_Node        Xmldom.Domnode; 
  e_Node           Xmldom.Domnodelist; 
  c_Node           Xmldom.Domnode; 
  Enumeration_List Xmldom.Domnodelist; 
  Enumeration_Node Xmldom.Domnode; 
  Item_List        Xmldom.Domnodelist; 
  Item_Node        Xmldom.Domnode; 
  Item_Node1       Xmldom.Domnode; 
  v_Name           Varchar2(100); 
  v_Result         Varchar2(4000); 
  n_i              Number; 
  n_Num            Number; 
  n_j              Number; 
  n_Enum           Number; 
  v_Enum           Varchar2(4000);
  v_Val            Varchar2(20); 
  v_Content        Varchar2(4000); 
  v_Multisel       Varchar2(10); 
Begin 
    v_Result := ''; 
 
    Select 报告内容 Into x_Content From 影像报告记录 Where id = 报告ID_In; 
 
    --Select Deletexml(x_Content, '//image') Into x_Content From Dual; 
 
    Xcdom := Xmldom.Newdomdocument(x_Content); 
 
    For Myrow In (Select Column_Value Name From Table(f_Str2list(报告提纲_In))) Loop 
      n_i := -1; 
      --循环提纲名称 
      Section_List := Xmldom.Getelementsbytagname(Xcdom, 'section'); 
      n_Len        := Xmldom.Getlength(Section_List); 
 
      For I In 0 .. n_Len - 1 Loop 
        If Xmldom.Getattribute(Xmldom.Makeelement(Xmldom.Item(Section_List, I)), 'title') = Myrow.Name Then 
          n_i := I; 
          Exit; 
        End If; 
      End Loop; 
 
      If n_i >= 0 Then 
        Section_Node := Xmldom.Item(Section_List, n_i); 
        Node_List    := Xmldom.Getelementsbytagname(Xmldom.Makeelement(Section_Node), '*'); 
        n_Len        := Xmldom.Getlength(Node_List); 
 
        For I In 0 .. n_Len - 1 Loop 
          Element_Node := Xmldom.Item(Node_List, I); 
          v_Name       := Xmldom.Getnodename(Element_Node); 
 
          If v_Name = 'element' Then 
            If Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'unit') Is Not Null Then 
              v_Content := Xmldom.Getnodevalue(Xmldom.Getfirstchild(Element_Node)); 
 
              If Instr(v_Content, 'textstyleno') > 0 Then 
                v_Content := ''; 
              End If; 
              --如果有单位 
              v_Result := v_Result || v_Content || Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'unit'); 
            Else 
              p_Node := Xmldom.Getparentnode(Element_Node); 
              If Xmldom.Getnodename(p_Node) <> 'enumvalues' Then 
                v_Result := v_Result || Xmldom.Getnodevalue(Xmldom.Getfirstchild(Element_Node)); 
              End If; 
            End If; 
          Elsif v_Name = 'utext' Then 
            v_Result := v_Result || Chr(13) || chr(10) || LTrim(LTrim(Xmldom.Getnodevalue(Xmldom.Getfirstchild(Element_Node)), ':'), '：'); 
          Elsif v_Name = 'e_list' Or v_Name = 'e_enum' Or v_Name = 'e_etree' Or v_Name = 'e_utree' Then 
            Enumeration_List := Xmldom.Getelementsbytagname(Xmldom.Makeelement(Element_Node), 'enumeration'); 
            n_Num            := Xmldom.Getlength(Enumeration_List); 
 
            If v_Name = 'e_enum' And n_Num > 0 Then 
              For J In 0 .. n_Num - 1 Loop 
                Enumeration_Node := Xmldom.Item(Enumeration_List, J); 
                Item_List        := Xmldom.Getelementsbytagname(Xmldom.Makeelement(Element_Node), 'item'); 
                n_j              := Xmldom.Getlength(Item_List); 
 
                For K In 0 .. n_j - 1 Loop 
                  Item_Node := Xmldom.Item(Item_List, K); 
                  If Xmldom.Getattribute(Xmldom.Makeelement(Item_Node), 'checked') = '1' Then 
                    v_Val := Xmldom.Getattribute(Xmldom.Makeelement(Item_Node), 'val'); 
 
                    For Z In 0 .. n_j - 1 Loop 
                      Item_Node1 := Xmldom.Item(Item_List, Z); 
                      If Xmldom.Getattribute(Xmldom.Makeelement(Item_Node1), 'val') = v_Val And 
                         Xmldom.Getattribute(Xmldom.Makeelement(Item_Node1), 'issymbol') = '0' Then 
                        v_Result := v_Result || Xmldom.Getnodevalue(Xmldom.Getfirstchild(Item_Node1)); 
                        Exit; 
                      End If; 
                    End Loop; 
                  End If; 
                End Loop; 
              End Loop; 
            Else 
              --这里处理枚举有无的情况 
              v_Enum := Xmldom.getNodeValue(xmldom.getFirstChild(Element_Node));

              if v_Enum Is Null Or Instr(v_Enum, 'rangexml=') <= 0  Then
                Enumeration_List := xmldom.getChildNodes(Element_Node);
                n_j := Xmldom.Getlength(Enumeration_List);
                
                For j In 0 .. n_j - 1  Loop 
                    v_Enum := Xmldom.getNodeValue(Xmldom.Item(Enumeration_List,n_j-j-1)); 
                    If Instr(v_Enum, 'rangexml=') > 0 Then 
                      Exit;
                    End If;
                End Loop;
                
              End If;

              v_Enum := Replace(v_Enum, 'rangexml=', '');
              v_Enum := Replace(v_Enum, '''', '');
              
              Select Extractvalue(XmlType(v_Enum), '/root/multisel') Into v_Multisel From Dual;
 
              If v_Multisel = 2 And v_Name = 'e_enum' Then 
                --为是否类型的枚举 
                v_Result := v_Result || Xmldom.Getnodevalue(Xmldom.getLastChild(Element_Node)); 
              Else 
                Enum_Node := Xmldom.Item(Xmldom.Getelementsbytagname(Xmldom.Makeelement(Element_Node), 'enumvalues'), 0); 
                e_Node := Xmldom.Getelementsbytagname(Xmldom.Makeelement(Enum_Node), 'element'); 
                n_Enum := Xmldom.Getlength(e_Node); 
 
                For K In 0 .. n_Enum - 1 Loop 
                  c_Node   := Xmldom.Item(e_Node, K); 
                  v_Result := v_Result || Xmldom.Getattribute(Xmldom.Makeelement(c_Node), 'showtext'); 
 
                  If K <> n_Enum - 1 Then 
                    v_Result := v_Result || '、'; 
                  End If; 
                End Loop; 
              End If; 
            End If; 
          End If; 
        End Loop; 
      End If; 
    End Loop; 
 
    Xmldom.Freedocument(Xcdom); 

    --Return translate(v_Result,chr(13)||chr(10),','); 
    Return  LTrim(RTrim(v_Result, Chr(13) || chr(10)), Chr(13) || Chr(10));
Exception 
  When Others Then 
    zl_ErrorCenter(SQLCode, SQLErrM); 
End Zlpub_Pacs_获取文档内容;
/

--109710:刘尔旋,2017-06-02,妇幼保健第三方接口
Create Or Replace Procedure Zl_Third_Getroom
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  -------------------------------------------------------------------------------------------------- 
  --功能:获取某个科室下的当天排班的诊室，用于护士分诊时选择诊室
  --入参:Xml_In: 
  --  <IN> 
  --      <KSID></KSID>   --科室ID
  --  </IN> 
  --出参:Xml_Out 
  --  <OUTPUT> 
  --    <ZS>
  --      <ZSID></ZSID>    --医生ID
  --      <ZSMC></ZSMC>     --医生姓名
  --    </ZS>
  --    <ZS>
  --      ...
  --    </ZS>  
  --  </OUTPUT> 
  -------------------------------------------------------------------------------------------------- 

  n_科室id   挂号安排.科室id%Type;
  d_日期     Date;
  v_Para     Varchar2(5000);
  n_挂号模式 Number(3);
  d_启用时间 Date;
  v_Temp     Varchar2(32767); --临时XML 
  x_Templet  Xmltype; --模板XML 
  v_Err_Msg  Varchar2(200);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/KSID') Into n_科室id From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  d_日期 := Sysdate;

  v_Para     := zl_GetSysParameter(256);
  n_挂号模式 := Substr(v_Para, 1, 1);
  Begin
    d_启用时间 := To_Date(Substr(v_Para, 3), 'yyyy-mm-dd hh24:mi:ss');
  Exception
    When Others Then
      d_启用时间 := Null;
  End;

  If n_挂号模式 = 0 Or (n_挂号模式 = 1 And d_日期 < d_启用时间) Then
    --计划排班模式
    For r_诊室 In (Select Distinct c.Id, c.名称
                 From 挂号安排 A, 挂号安排诊室 B, 门诊诊室 C
                 Where a.科室id = n_科室id And a.Id = b.号表id And b.门诊诊室 = c.名称) Loop
      v_Temp := '<ZS><ZSID>' || r_诊室.Id || '</ZSID><ZSMC>' || r_诊室.名称 || '</ZSMC></ZS>';
      Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    End Loop;
  Else
    --出诊表排班模式
    For r_诊室 In (Select Distinct b.Id, b.名称
                 From 门诊诊室适用科室 A, 门诊诊室 B
                 Where a.科室id = n_科室id And a.诊室id = b.Id
                 Order By a.缺省标志 Desc) Loop
      v_Temp := '<ZS><ZSID>' || r_诊室.Id || '</ZSID><ZSMC>' || r_诊室.名称 || '</ZSMC></ZS>';
      Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    End Loop;
  End If;

  Xml_Out := x_Templet;

Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getroom;
/

--109710:刘尔旋,2017-06-20,妇幼保健第三方接口
Create Or Replace Procedure Zl_Third_Getpatiinfo
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  -------------------------------------------------------------------------------------------------- 
  --功能:获取病人基本信息
  --入参:Xml_In: 
  --  <IN> 
  --      <SFZH></SFZH>     --身份证号
  --      <YLKLB></YLKLB>   --医疗卡类别，ID或者名称
  --      <YLKH></YLKH>     --医疗卡号
  --      <BRXM></BRXM>     --病人姓名
  --  </IN> 
  --出参:Xml_Out 
  --  <OUTPUT> 
  --    <BR>
  --      <GHD></GHD>  --挂号单据,最后一次挂号单
  --      <BRID></BRID>  --病人ID
  --      <MZH></MZH>  --门诊号
  --      <XM></XM>  --姓名
  --      <XB></XB>  --性别
  --      <CSRQ></CSRQ>  --出生日期
  --      <SFZH></SFZH>  --身份证号
  --      <ZY></ZY>      --职业
  --      <XL></XL>      --学历
  --      <MZ></MZ>      --民族
  --      <JZKH></JZKH>  --就诊卡号
  --      <LXDH></LXDH>  --联系电话
  --      <XJZDZ></XJZDZ>    --现地址
  --      <HJDZ></HJDZ>      --户籍地址
  --    </BR>
  --    <BR>
  --      ...
  --    </BR>  
  --  </OUTPUT> 
  -------------------------------------------------------------------------------------------------- 

  v_病人ids  Varchar2(30000);
  v_医疗卡   Varchar2(500);
  v_卡号     病人医疗卡信息.卡号%Type;
  v_姓名     病人信息.姓名%Type;
  v_身份证号 病人信息.身份证号%Type;
  n_卡类别id 医疗卡类别.Id%Type;
  v_No       病人挂号记录.No%Type;
  v_就诊卡号 病人医疗卡信息.卡号%Type;
  v_Temp     Varchar2(32767); --临时XML 
  x_Templet  Xmltype; --模板XML 
  v_Err_Msg  Varchar2(200);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/SFZH'), Extractvalue(Value(A), 'IN/YLKLB'), Extractvalue(Value(A), 'IN/YLKH'),
         Extractvalue(Value(A), 'IN/BRXM')
  Into v_身份证号, v_医疗卡, v_卡号, v_姓名
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  If v_身份证号 Is Null And v_医疗卡 Is Null And v_卡号 Is Null And v_姓名 Is Null Then
    v_Err_Msg := '未传入任何条件,无法完成查询!';
    Raise Err_Item;
  End If;

  If v_医疗卡 Is Not Null Then
    Begin
      n_卡类别id := To_Number(v_医疗卡);
    Exception
      When Others Then
        Select ID Into n_卡类别id From 医疗卡类别 Where 名称 = v_医疗卡 And Rownum < 2;
    End;
  End If;

  If Nvl(n_卡类别id, 0) = 0 Then
    For r_病人 In (Select Distinct 病人id
                 From 病人信息
                 Where Nvl(身份证号, '-') = Nvl(v_身份证号, Nvl(身份证号, '-')) And 姓名 = Nvl(v_姓名, 姓名)) Loop
      v_病人ids := v_病人ids || ',' || r_病人.病人id;
    End Loop;
  Else
    For r_病人 In (Select Distinct a.病人id
                 From 病人信息 A, 病人医疗卡信息 B
                 Where a.病人id = b.病人id And b.卡类别id = n_卡类别id And b.卡号 = v_卡号 And
                       Nvl(a.身份证号, '-') = Nvl(v_身份证号, Nvl(a.身份证号, '-')) And a.姓名 = Nvl(v_姓名, a.姓名)) Loop
      v_病人ids := v_病人ids || ',' || r_病人.病人id;
    End Loop;
  End If;

  If v_病人ids Is Not Null Then
    v_病人ids := Substr(v_病人ids, 2);
  End If;

  For r_挂号 In (Select c.病人id, c.门诊号, c.姓名, c.性别, c.出生日期, c.身份证号, c.职业, c.学历, c.民族, c.家庭电话, c.家庭地址, c.户口地址
               From 病人信息 C, Table(f_Str2list(v_病人ids)) E
               Where c.病人id = e.Column_Value) Loop
    v_Temp := '<BR>';
    Begin
      Select NO
      Into v_No
      From (Select NO
             From 病人挂号记录
             Where 病人id = r_挂号.病人id And 记录性质 = 1 And 记录状态 = 1
             Order By 登记时间 Desc)
      Where Rownum < 2;
    Exception
      When Others Then
        v_No := Null;
    End;
    v_Temp := v_Temp || '<GHD>' || v_No || '</GHD>';
    v_Temp := v_Temp || '<BRID>' || r_挂号.病人id || '</BRID>';
    v_Temp := v_Temp || '<MZH>' || r_挂号.门诊号 || '</MZH>';
    v_Temp := v_Temp || '<XM>' || r_挂号.姓名 || '</XM>';
    v_Temp := v_Temp || '<XB>' || r_挂号.性别 || '</XB>';
    v_Temp := v_Temp || '<CSRQ>' || To_Char(r_挂号.出生日期, 'yyyy-mm-dd hh24:mi:ss') || '</CSRQ>';
    v_Temp := v_Temp || '<SFZH>' || r_挂号.身份证号 || '</SFZH>';
    v_Temp := v_Temp || '<ZY>' || r_挂号.职业 || '</ZY>';
    v_Temp := v_Temp || '<XL>' || r_挂号.学历 || '</XL>';
    v_Temp := v_Temp || '<MZ>' || r_挂号.民族 || '</MZ>';
    Select Max(卡号)
    Into v_就诊卡号
    From 病人医疗卡信息
    Where 病人id = r_挂号.病人id And 卡类别id = (Select ID From 医疗卡类别 Where 是否固定 = 1 And 名称 = '就诊卡');
    v_Temp := v_Temp || '<JZKH>' || v_就诊卡号 || '</JZKH>';
    v_Temp := v_Temp || '<LXDH>' || r_挂号.家庭电话 || '</LXDH>';
    v_Temp := v_Temp || '<XJZDZ>' || r_挂号.家庭地址 || '</XJZDZ>';
    v_Temp := v_Temp || '<HJDZ>' || r_挂号.户口地址 || '</HJDZ>';
    v_Temp := v_Temp || '</BR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  End Loop;

  Xml_Out := x_Templet;

Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getpatiinfo;
/

--109710:刘尔旋,2017-06-02,妇幼保健第三方接口
Create Or Replace Procedure Zl_Third_Distroom
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  -------------------------------------------------------------------------------------------------- 
  --功能:分诊操作数据处理
  --入参:Xml_In: 
  --  <IN> 
  --      <GHD></GHD>       --挂号单据号
  --      <FZSJ></FZSJ>   --分诊时间,默认为当前时间
  --      <FZYS></FZYS>   --分诊医生
  --      <FZZS></FZZS>   --分诊诊室
  --      <SFQD></SFQD>   --分诊时是否同步签到，0-不签到，1-签到,默认不签到
  --  </IN> 
  --出参:Xml_Out 
  --  <OUTPUT> 
  ---  <ERROR><MSG></MSG></ERROR> //无此节点表示分诊成功 
  --  </OUTPUT> 
  -------------------------------------------------------------------------------------------------- 

  v_No       病人挂号记录.No%Type;
  d_日期     Date;
  n_签到     Number;
  v_分诊医生 病人挂号记录.执行人%Type;
  v_分诊诊室 病人挂号记录.诊室%Type;
  n_病人id   病人挂号记录.病人id%Type;
  v_预约方式 病人挂号记录.预约方式%Type;
  n_挂号id   病人挂号记录.Id%Type;
  v_Temp     Varchar2(32767); --临时XML 
  x_Templet  Xmltype; --模板XML 
  v_Err_Msg  Varchar2(200);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/GHD'), To_Date(Extractvalue(Value(A), 'IN/FZSJ'), 'yyyy-mm-dd hh24:mi:ss'),
         Extractvalue(Value(A), 'IN/FZYS'), Extractvalue(Value(A), 'IN/FZZS'), Extractvalue(Value(A), 'IN/SFQD')
  Into v_No, d_日期, v_分诊医生, v_分诊诊室, n_签到
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  If d_日期 Is Null Then
    d_日期 := Sysdate;
  End If;

  Begin
    Select 病人id, 预约方式, ID
    Into n_病人id, v_预约方式, n_挂号id
    From 病人挂号记录
    Where 记录性质 = 1 And 记录状态 = 1 And NO = v_No And Nvl(执行状态, 0) = 0;
  Exception
    When Others Then
      v_Err_Msg := '病人已经接诊或已经退号，不能再分诊';
      Raise Err_Item;
  End;

  Zl_病人挂号记录_更新诊室(v_No, n_病人id, v_分诊诊室, v_分诊医生, d_日期, 1, v_预约方式);

  If Nvl(n_签到, 0) = 1 Then
    Zl_病人挂号记录_签到(n_挂号id, 0, v_预约方式);
  End If;

  v_Temp := '<ERROR><MSG>' || '</MSG></ERROR>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Xml_Out := x_Templet;

Exception
  When Err_Item Then
    v_Temp := '<ERROR><MSG>' || v_Err_Msg || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Xml_Out := x_Templet;
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Distroom;
/

--109710:刘尔旋,2017-06-26,妇幼保健第三方接口
Create Or Replace Procedure Zl_Third_Getregstatus
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  -------------------------------------------------------------------------------------------------- 
  --功能:获取某个科室当天排班医生的挂号数量
  --入参:Xml_In: 
  --  <IN> 
  --      <KSID></KSID>   --科室ID
  --  </IN> 
  --出参:Xml_Out 
  --  <OUTPUT> 
  --    <YS>
  --      <YSXM></YSXM>    --医生姓名
  --      <SYGHS></SYGHS>  --剩余挂号数
  --      <DDJZS></DDJZS>  --等待就诊数
  --      <SWGHS></SWGHS>  --上午挂号数
  --      <XWGHS></XWGHS>  --下午挂号数
  --      <QTGHS></QTGHS>  --全天挂号数
  --      <YSZJ><YSZJ>     --医生职级
  --    </YS>
  --    <YS>
  --      ...
  --    </YS>  
  --  </OUTPUT> 
  -------------------------------------------------------------------------------------------------- 

  n_科室id      挂号安排.科室id%Type;
  d_日期        Date;
  v_Para        Varchar2(5000);
  n_挂号模式    Number(3);
  d_启用时间    Date;
  v_Temp        Varchar2(32767); --临时XML 
  x_Templet     Xmltype; --模板XML 
  v_Err_Msg     Varchar2(200);
  n_已挂数      病人挂号汇总.已挂数%Type;
  n_限号数      挂号安排限制.限号数%Type;
  n_上午接诊    Number;
  n_下午接诊    Number;
  n_等待就诊    Number;
  v_出诊记录ids Varchar2(5000);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/KSID') Into n_科室id From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  d_日期 := Sysdate;

  v_Para     := zl_GetSysParameter(256);
  n_挂号模式 := Substr(v_Para, 1, 1);
  Begin
    d_启用时间 := To_Date(Substr(v_Para, 3), 'yyyy-mm-dd hh24:mi:ss');
  Exception
    When Others Then
      d_启用时间 := Null;
  End;

  If n_挂号模式 = 0 Or (n_挂号模式 = 1 And d_日期 < d_启用时间) Then
    --计划排班模式
    For r_医生 In (Select Distinct 医生id, 医生姓名, y.专业技术职务
                 From (Select a.医生id, a.医生姓名
                        From 挂号安排计划 A, 挂号安排 B
                        Where a.安排id = b.Id And b.停用日期 Is Null And a.审核时间 Is Not Null And b.科室id = n_科室id And
                              a.生效时间 = (Select Max(生效时间)
                                        From 挂号安排计划
                                        Where 安排id = b.Id And 审核时间 Is Not Null And d_日期 Between 生效时间 And 失效时间) And
                              Not Exists (Select 1
                               From 挂号安排停用状态
                               Where 安排id = b.Id And d_日期 Between 开始停止时间 And 结束停止时间) And
                              d_日期 Between Nvl(b.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                              Nvl(b.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD'))
                        Union All
                        Select a.医生id, a.医生姓名
                        From 挂号安排 A
                        Where a.停用日期 Is Null And a.科室id = n_科室id And
                              d_日期 Between Nvl(a.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                              Nvl(a.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Not Exists
                         (Select 1
                               From 挂号安排停用状态
                               Where 安排id = a.Id And d_日期 Between 开始停止时间 And 结束停止时间) And Not Exists
                         (Select 1
                               From 挂号安排计划
                               Where 安排id = a.Id And 审核时间 Is Not Null And d_日期 Between 生效时间 And 失效时间)) X, 人员表 Y
                 Where x.医生id = y.Id(+)) Loop
      If r_医生.医生姓名 Is Not Null Then
        v_Temp := '<YS>';
        v_Temp := v_Temp || '<YSXM>' || r_医生.医生姓名 || '</YSXM>';
        Select Nvl(Sum(a.已挂数), 0)
        Into n_已挂数
        From 病人挂号汇总 A,
             (Select Distinct 号码
               From (Select b.号码
                      From 挂号安排计划 A, 挂号安排 B
                      Where a.安排id = b.Id And b.停用日期 Is Null And a.审核时间 Is Not Null And b.科室id = n_科室id And
                            a.生效时间 = (Select Max(生效时间)
                                      From 挂号安排计划
                                      Where 安排id = b.Id And 审核时间 Is Not Null And d_日期 Between 生效时间 And 失效时间) And Not Exists
                       (Select 1
                             From 挂号安排停用状态
                             Where 安排id = b.Id And d_日期 Between 开始停止时间 And 结束停止时间) And
                            d_日期 Between Nvl(b.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                            Nvl(b.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD'))
                      Union All
                      Select a.号码
                      From 挂号安排 A
                      Where a.停用日期 Is Null And a.科室id = n_科室id And
                            d_日期 Between Nvl(a.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                            Nvl(a.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Not Exists
                       (Select 1
                             From 挂号安排停用状态
                             Where 安排id = a.Id And d_日期 Between 开始停止时间 And 结束停止时间) And Not Exists
                       (Select 1
                             From 挂号安排计划
                             Where 安排id = a.Id And 审核时间 Is Not Null And d_日期 Between 生效时间 And 失效时间))) B
        Where a.医生姓名 = r_医生.医生姓名 And a.科室id = n_科室id And a.号码 = b.号码 And 日期 = Trunc(d_日期);
      
        Select Nvl(Sum(限号数), 0)
        Into n_限号数
        From (Select c.限号数
               From 挂号安排计划 A, 挂号安排 B, 挂号计划限制 C
               Where a.Id = c.计划id And c.限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                       '周四', '6', '周五', '7', '周六', Null) And a.安排id = b.Id And
                     b.停用日期 Is Null And a.审核时间 Is Not Null And b.科室id = n_科室id And
                     a.生效时间 = (Select Max(生效时间)
                               From 挂号安排计划
                               Where 安排id = b.Id And 审核时间 Is Not Null And d_日期 Between 生效时间 And 失效时间) And Not Exists
                (Select 1 From 挂号安排停用状态 Where 安排id = b.Id And d_日期 Between 开始停止时间 And 结束停止时间) And
                     d_日期 Between Nvl(b.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                     Nvl(b.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD'))
               Union All
               Select b.限号数
               From 挂号安排 A, 挂号安排限制 B
               Where a.Id = b.安排id And b.限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                       '周四', '6', '周五', '7', '周六', Null) And a.停用日期 Is Null And
                     a.科室id = n_科室id And d_日期 Between Nvl(a.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                     Nvl(a.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Not Exists
                (Select 1 From 挂号安排停用状态 Where 安排id = a.Id And d_日期 Between 开始停止时间 And 结束停止时间) And Not Exists
                (Select 1
                      From 挂号安排计划
                      Where 安排id = a.Id And 审核时间 Is Not Null And d_日期 Between 生效时间 And 失效时间));
        If n_限号数 - n_已挂数 < 0 Then
          v_Temp := v_Temp || '<SYGHS>' || 0 || '</SYGHS>';
        Else
          v_Temp := v_Temp || '<SYGHS>' || To_Char(n_限号数 - n_已挂数) || '</SYGHS>';
        End If;
        
        Select Count(1)
        Into n_等待就诊
        From 病人挂号记录
        Where 执行人 = r_医生.医生姓名 And 执行部门id = n_科室id And Nvl(执行状态, 0) = 0 And 记录性质 = 1 And 记录状态 = 1 And
              发生时间 Between Trunc(d_日期) And Trunc(d_日期 + 1) - 1 / 24 / 60 / 60;
        v_Temp := v_Temp || '<DDJZS>' || n_等待就诊 || '</DDJZS>';
        
        Select Count(1)
        Into n_上午接诊
        From 病人挂号记录
        Where 执行人 = r_医生.医生姓名 And 执行部门id = n_科室id And 记录性质 = 1 And 记录状态 = 1 And
              发生时间 Between Trunc(d_日期) And Trunc(d_日期) + 0.5 - 1 / 24 / 60 / 60;
        v_Temp := v_Temp || '<SWGHS>' || n_上午接诊 || '</SWGHS>';
        
        Select Count(1)
        Into n_下午接诊
        From 病人挂号记录
        Where 执行人 = r_医生.医生姓名 And 执行部门id = n_科室id And 记录性质 = 1 And 记录状态 = 1 And
              发生时间 Between Trunc(d_日期) + 0.5 And Trunc(d_日期 + 1) - 1 / 24 / 60 / 60;
        v_Temp := v_Temp || '<XWGHS>' || n_下午接诊 || '</XWGHS>';
        
        v_Temp := v_Temp || '<QTGHS>' || To_Char(n_上午接诊 + n_下午接诊) || '</QTGHS>';
        v_Temp := v_Temp || '<YSZJ>' || r_医生.专业技术职务 || '</YSZJ>';
        v_Temp := v_Temp || '</YS>';
        Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
      End If;
    End Loop;
  Else
    --出诊表排班模式
    For r_医生 In (Select Distinct a.医生id, a.医生姓名, b.专业技术职务
                 From 临床出诊记录 A, 人员表 B
                 Where a.医生id = b.Id(+) And a.科室id = n_科室id And 是否发布 = 1 And Nvl(是否锁定, 0) = 0 And
                       (a.开始时间 < Nvl(a.停诊开始时间, a.终止时间) Or a.终止时间 > Nvl(a.停诊终止时间, a.开始时间))) Loop
      For r_出诊记录 In (Select Distinct ID
                     From 临床出诊记录
                     Where 医生姓名 = r_医生.医生姓名 And 科室id = n_科室id And 出诊日期 = Trunc(d_日期) And 是否发布 = 1 And Nvl(是否锁定, 0) = 0 And
                           (开始时间 < Nvl(停诊开始时间, 终止时间) Or 终止时间 > Nvl(停诊终止时间, 开始时间))) Loop
        v_出诊记录ids := v_出诊记录ids || ',' || r_出诊记录.Id;
      End Loop;
      If v_出诊记录ids Is Not Null Then
        v_出诊记录ids := Substr(v_出诊记录ids, 2);
      End If;
      Select Sum(限号数), Sum(已挂数)
      Into n_限号数, n_已挂数
      From 临床出诊记录 A, Table(f_Str2list(v_出诊记录ids)) B
      Where a.Id = b.Column_Value;
      v_Temp := '<YS>';
      v_Temp := v_Temp || '<YSXM>' || r_医生.医生姓名 || '</YSXM>';
      If n_限号数 - n_已挂数 < 0 Then
        v_Temp := v_Temp || '<SYGHS>' || 0 || '</SYGHS>';
      Else
        v_Temp := v_Temp || '<SYGHS>' || To_Char(n_限号数 - n_已挂数) || '</SYGHS>';
      End If;
      Select Count(1)
      Into n_等待就诊
      From 病人挂号记录 A, Table(f_Str2list(v_出诊记录ids)) B
      Where 执行人 = r_医生.医生姓名 And 执行部门id = n_科室id And Nvl(执行状态, 0) = 0 And 记录性质 = 1 And 记录状态 = 1 And
            a.出诊记录id = b.Column_Value;
      v_Temp := v_Temp || '<DDJZS>' || n_等待就诊 || '</DDJZS>';
      
      Select Count(1)
      Into n_上午接诊
      From 病人挂号记录 A, Table(f_Str2list(v_出诊记录ids)) B
      Where 执行人 = r_医生.医生姓名 And 执行部门id = n_科室id And 记录性质 = 1 And 记录状态 = 1 And
            发生时间 Between Trunc(d_日期) And Trunc(d_日期) + 0.5 - 1 / 24 / 60 / 60 And a.出诊记录id = b.Column_Value;
      v_Temp := v_Temp || '<SWGHS>' || n_上午接诊 || '</SWGHS>';
      
      Select Count(1)
      Into n_下午接诊
      From 病人挂号记录 A, Table(f_Str2list(v_出诊记录ids)) B
      Where 执行人 = r_医生.医生姓名 And 执行部门id = n_科室id And 记录性质 = 1 And 记录状态 = 1 And
            发生时间 Between Trunc(d_日期) + 0.5 And Trunc(d_日期 + 1) - 1 / 24 / 60 / 60 And a.出诊记录id = b.Column_Value;
      v_Temp := v_Temp || '<XWGHS>' || n_下午接诊 || '</XWGHS>';
      
      v_Temp := v_Temp || '<QTGHS>' || To_Char(n_上午接诊 + n_下午接诊) || '</QTGHS>';
      v_Temp := v_Temp || '<YSZJ>' || r_医生.专业技术职务 || '</YSZJ>';
      v_Temp := v_Temp || '</YS>';
      Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    End Loop;
  End If;

  Xml_Out := x_Templet;

Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getregstatus;
/

--109710:刘尔旋,2017-06-02,妇幼保健第三方接口
Create Or Replace Procedure Zl_Third_Getdoctor
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  -------------------------------------------------------------------------------------------------- 
  --功能:获取某个科室下的排班的医生，用于护士分诊时选择医生
  --入参:Xml_In: 
  --  <IN> 
  --      <KSID></KSID>   --科室ID
  --      <RQ></RQ>   --日期,默认为当天
  --  </IN> 
  --出参:Xml_Out 
  --  <OUTPUT> 
  --    <YS>
  --      <YSID></YSID>    --医生ID
  --      <YSXM></YSXM>     --医生姓名
  --    </YS>
  --    <YS>
  --      ...
  --    </YS>  
  --  </OUTPUT> 
  -------------------------------------------------------------------------------------------------- 

  n_科室id   挂号安排.科室id%Type;
  d_日期     Date;
  v_Para     Varchar2(5000);
  n_挂号模式 Number(3);
  d_启用时间 Date;
  v_Temp     Varchar2(32767); --临时XML 
  x_Templet  Xmltype; --模板XML 
  v_Err_Msg  Varchar2(200);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/KSID'), To_Date(Extractvalue(Value(A), 'IN/RQ'), 'yyyy-mm-dd hh24:mi:ss')
  Into n_科室id, d_日期
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  If d_日期 Is Null Then
    d_日期 := Sysdate;
  End If;

  v_Para     := zl_GetSysParameter(256);
  n_挂号模式 := Substr(v_Para, 1, 1);
  Begin
    d_启用时间 := To_Date(Substr(v_Para, 3), 'yyyy-mm-dd hh24:mi:ss');
  Exception
    When Others Then
      d_启用时间 := Null;
  End;

  If n_挂号模式 = 0 Or (n_挂号模式 = 1 And d_日期 < d_启用时间) Then
    --计划排班模式
    For r_医生 In (Select Distinct 医生id, 医生姓名
                 From (Select a.医生id, a.医生姓名
                        From 挂号安排计划 A, 挂号安排 B
                        Where a.安排id = b.Id And b.停用日期 Is Null And a.审核时间 Is Not Null And b.科室id = n_科室id And
                              a.生效时间 = (Select Max(生效时间)
                                        From 挂号安排计划
                                        Where 安排id = b.Id And 审核时间 Is Not Null And d_日期 Between 生效时间 And 失效时间) And
                              Not Exists (Select 1
                               From 挂号安排停用状态
                               Where 安排id = b.Id And d_日期 Between 开始停止时间 And 结束停止时间) And
                              d_日期 Between Nvl(b.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                              Nvl(b.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD'))
                        Union All
                        Select a.医生id, a.医生姓名
                        From 挂号安排 A
                        Where a.停用日期 Is Null And a.科室id = n_科室id And
                              d_日期 Between Nvl(a.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                              Nvl(a.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Not Exists
                         (Select 1
                               From 挂号安排停用状态
                               Where 安排id = a.Id And d_日期 Between 开始停止时间 And 结束停止时间) And Not Exists
                         (Select 1
                               From 挂号安排计划
                               Where 安排id = a.Id And 审核时间 Is Not Null And d_日期 Between 生效时间 And 失效时间))) Loop
      If r_医生.医生id Is Not Null Or r_医生.医生姓名 Is Not Null Then
        v_Temp := '<YS><YSID>' || r_医生.医生id || '</YSID><YSXM>' || r_医生.医生姓名 || '</YSXM></YS>';
        Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
      End If;
    End Loop;
  Else
    --出诊表排班模式
    For r_医生 In (Select Distinct 医生id, 医生姓名
                 From 临床出诊记录
                 Where 科室id = n_科室id And 出诊日期 = Trunc(d_日期) And 是否发布 = 1 And Nvl(是否锁定, 0) = 0 And
                       (开始时间 < Nvl(停诊开始时间, 终止时间) Or 终止时间 > Nvl(停诊终止时间, 开始时间))) Loop
      If r_医生.医生id Is Not Null Or r_医生.医生姓名 Is Not Null Then
        v_Temp := '<YS><YSID>' || r_医生.医生id || '</YSID><YSXM>' || r_医生.医生姓名 || '</YSXM></YS>';
        Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
      End If;
    End Loop;
  End If;

  Xml_Out := x_Templet;

Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getdoctor;
/

--109710:刘尔旋,2017-06-05,妇幼三方接口
Create Or Replace Procedure Zl_Third_Getdeptreg
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  -------------------------------------------------------------------------------------------------- 
  --功能:获取某个科室下的指定日期所有未分诊的挂号记录，用于分诊
  --入参:Xml_In: 
  --  <IN> 
  --      <KSID></KSID>   --科室ID
  --      <RQ></RQ>       --日期,默认为当天
  --  </IN> 
  --出参:Xml_Out 
  --  <OUTPUT> 
  --    <GH>
  --      <ID></ID>    --挂号记录ID
  --      <GHD></GHD>  --挂号单据
  --      <BRID></BRID>  --病人ID
  --      <MZH></MZH>  --门诊号
  --      <XM></XM>  --姓名
  --      <XB></XB>  --性别
  --      <NL></NL>  --年龄
  --      <SFZH></SFZH>  --身份证号
  --      <YSID></YSID>  --医生ID
  --      <YSXM></YSXM>  --医生姓名
  --      <KSID></KSID>  --科室ID
  --      <KSMC></KSMC>  --科室名称
  --      <GHSJ></GHSJ>  --挂号时间
  --    </GH>
  --    <GH>
  --      ...
  --    </GH>  
  --  </OUTPUT> 
  -------------------------------------------------------------------------------------------------- 

  n_科室id  挂号安排.科室id%Type;
  d_日期    Date;
  v_Temp    Varchar2(32767); --临时XML 
  x_Templet Xmltype; --模板XML 
  v_Err_Msg Varchar2(200);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/KSID'), To_Date(Extractvalue(Value(A), 'IN/RQ'), 'yyyy-mm-dd hh24:mi:ss')
  Into n_科室id, d_日期
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  If d_日期 Is Null Then
    d_日期 := Sysdate;
  End If;

  For r_挂号 In (Select a.Id, a.No, a.病人id, a.门诊号, a.姓名, a.性别, b.Id As 医生id, a.执行人 As 医生姓名, c.身份证号, d.Id As 科室id,
                      d.名称 As 科室名称, a.登记时间, a.年龄
               From 病人挂号记录 A, 人员表 B, 病人信息 C, 部门表 D
               Where a.记录性质 = 1 And a.记录状态 = 1 And a.执行人 = b.姓名(+) And a.病人id = c.病人id And a.执行部门id = n_科室id And
                     a.执行部门id = d.Id And a.诊室 Is Null And Nvl(a.执行状态, 0) = 0 And a.发生时间 Between Trunc(d_日期) And
                     Trunc(d_日期 + 1) - 1 / 24 / 60 / 60) Loop
    v_Temp := '<GH>';
    v_Temp := v_Temp || '<ID>' || r_挂号.Id || '</ID>';
    v_Temp := v_Temp || '<GHD>' || r_挂号.No || '</GHD>';
    v_Temp := v_Temp || '<BRID>' || r_挂号.病人id || '</BRID>';
    v_Temp := v_Temp || '<MZH>' || r_挂号.门诊号 || '</MZH>';
    v_Temp := v_Temp || '<XM>' || r_挂号.姓名 || '</XM>';
    v_Temp := v_Temp || '<XB>' || r_挂号.性别 || '</XB>';
    v_Temp := v_Temp || '<NL>' || r_挂号.年龄 || '</NL>';
    v_Temp := v_Temp || '<SFZH>' || r_挂号.身份证号 || '</SFZH>';
    v_Temp := v_Temp || '<YSID>' || r_挂号.医生id || '</YSID>';
    v_Temp := v_Temp || '<YSXM>' || r_挂号.医生姓名 || '</YSXM>';
    v_Temp := v_Temp || '<KSID>' || r_挂号.科室id || '</KSID>';
    v_Temp := v_Temp || '<KSMC>' || r_挂号.科室名称 || '</KSMC>';
    v_Temp := v_Temp || '<GHSJ>' || To_Char(r_挂号.登记时间, 'yyyy-mm-dd hh24:mi:ss') || '</GHSJ>';
    v_Temp := v_Temp || '</GH>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  End Loop;

  Xml_Out := x_Templet;

Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getdeptreg;
/

--109710:刘尔旋,2017-06-05,妇幼三方接口
Create Or Replace Procedure Zl_Third_Getpatireg
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  -------------------------------------------------------------------------------------------------- 
  --功能:获取某个人指定日期未分诊的挂号记录
  --入参:Xml_In: 
  --  <IN> 
  --      <RQ></RQ>         --日期,默认为当天
  --      <SFZH></SFZH>     --身份证号
  --      <YLKLB></YLKLB>   --医疗卡类别，ID或者名称
  --      <YLKH></YLKH>     --医疗卡号
  --      <BRXM></BRXM>     --病人姓名
  --  </IN> 
  --出参:Xml_Out 
  --  <OUTPUT> 
  --    <GH>
  --      <ID></ID>    --挂号记录ID
  --      <GHD></GHD>  --挂号单据
  --      <BRID></BRID>  --病人ID
  --      <MZH></MZH>  --门诊号
  --      <XM></XM>  --姓名
  --      <XB></XB>  --性别
  --      <NL></NL>  --年龄
  --      <SFZH></SFZH>  --身份证号
  --      <YSID></YSID>  --医生ID
  --      <YSXM></YSXM>  --医生姓名
  --      <KSID></KSID>  --科室ID
  --      <KSMC></KSMC>  --科室名称
  --      <GHSJ></GHSJ>  --挂号时间
  --    </GH>
  --    <GH>
  --      ...
  --    </GH>  
  --  </OUTPUT> 
  -------------------------------------------------------------------------------------------------- 

  v_病人ids  Varchar2(30000);
  v_医疗卡   Varchar2(500);
  d_日期     Date;
  v_卡号     病人医疗卡信息.卡号%Type;
  v_姓名     病人信息.姓名%Type;
  v_身份证号 病人信息.身份证号%Type;
  n_卡类别id 医疗卡类别.Id%Type;
  v_Temp     Varchar2(32767); --临时XML 
  x_Templet  Xmltype; --模板XML 
  v_Err_Msg  Varchar2(200);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/SFZH'), To_Date(Extractvalue(Value(A), 'IN/RQ'), 'yyyy-mm-dd hh24:mi:ss'),
         Extractvalue(Value(A), 'IN/YLKLB'), Extractvalue(Value(A), 'IN/YLKH'), Extractvalue(Value(A), 'IN/BRXM')
  Into v_身份证号, d_日期, v_医疗卡, v_卡号, v_姓名
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  If v_身份证号 Is Null And v_医疗卡 Is Null And v_卡号 Is Null And v_姓名 Is Null Then
    v_Err_Msg := '未传入任何条件,无法完成查询!';
    Raise Err_Item;
  End If;

  If d_日期 Is Null Then
    d_日期 := Sysdate;
  End If;

  Begin
    n_卡类别id := To_Number(v_医疗卡);
  Exception
    When Others Then
      Select ID Into n_卡类别id From 医疗卡类别 Where 名称 = v_医疗卡 And Rownum < 2;
  End;

  If Nvl(n_卡类别id, 0) = 0 Then
    For r_病人 In (Select Distinct 病人id
                 From 病人信息
                 Where 身份证号 = Nvl(v_身份证号, 身份证号) And 姓名 = Nvl(v_姓名, 姓名)) Loop
      v_病人ids := v_病人ids || ',' || r_病人.病人id;
    End Loop;
  Else
    For r_病人 In (Select Distinct a.病人id
                 From 病人信息 A, 病人医疗卡信息 B
                 Where a.病人id = b.病人id And b.卡类别id = n_卡类别id And b.卡号 = v_卡号 And a.身份证号 = Nvl(v_身份证号, a.身份证号) And
                       a.姓名 = Nvl(v_姓名, a.姓名)) Loop
      v_病人ids := v_病人ids || ',' || r_病人.病人id;
    End Loop;
  End If;

  If v_病人ids Is Not Null Then
    v_病人ids := Substr(v_病人ids, 2);
  End If;

  For r_挂号 In (Select a.Id, a.No, a.病人id, a.门诊号, a.姓名, a.性别, b.Id As 医生id, a.执行人 As 医生姓名, c.身份证号, d.Id As 科室id,
                      d.名称 As 科室名称, a.登记时间, a.年龄
               From 病人挂号记录 A, 人员表 B, 病人信息 C, 部门表 D, Table(f_Str2list(v_病人ids)) E
               Where a.记录性质 = 1 And a.记录状态 = 1 And Nvl(a.执行状态, 0) = 0 And a.执行人 = b.姓名(+) And a.病人id = c.病人id And
                     a.病人id = e.Column_Value And a.执行部门id = d.Id And a.诊室 Is Null And a.发生时间 Between Trunc(d_日期) And
                     Trunc(d_日期 + 1) - 1 / 24 / 60 / 60) Loop
    v_Temp := '<GH>';
    v_Temp := v_Temp || '<ID>' || r_挂号.Id || '</ID>';
    v_Temp := v_Temp || '<GHD>' || r_挂号.No || '</GHD>';
    v_Temp := v_Temp || '<BRID>' || r_挂号.病人id || '</BRID>';
    v_Temp := v_Temp || '<MZH>' || r_挂号.门诊号 || '</MZH>';
    v_Temp := v_Temp || '<XM>' || r_挂号.姓名 || '</XM>';
    v_Temp := v_Temp || '<XB>' || r_挂号.性别 || '</XB>';
    v_Temp := v_Temp || '<NL>' || r_挂号.年龄 || '</NL>';
    v_Temp := v_Temp || '<SFZH>' || r_挂号.身份证号 || '</SFZH>';
    v_Temp := v_Temp || '<YSID>' || r_挂号.医生id || '</YSID>';
    v_Temp := v_Temp || '<YSXM>' || r_挂号.医生姓名 || '</YSXM>';
    v_Temp := v_Temp || '<KSID>' || r_挂号.科室id || '</KSID>';
    v_Temp := v_Temp || '<KSMC>' || r_挂号.科室名称 || '</KSMC>';
    v_Temp := v_Temp || '<GHSJ>' || To_Char(r_挂号.登记时间, 'yyyy-mm-dd hh24:mi:ss') || '</GHSJ>';
    v_Temp := v_Temp || '</GH>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  End Loop;

  Xml_Out := x_Templet;

Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getpatireg;
/

--100722:张德婷,2017-06-01,修改发药窗口同步调整业务数据
Create Or Replace Procedure Zl_发药窗口_业务调整
(
  药房id_In In Number,
  旧窗口_In In Varchar2,
  新窗口_In In Varchar2
) Is

  Cursor c_未发数据 Is
    Select 单据, No, 库房id
    From 未发药品记录
    Where 填制日期 Between Sysdate - 3 And Sysdate And 发药窗口 = 旧窗口_In And 库房id = 药房id_In;

  --药房参数
  Cursor c_药房参数 Is
    Select a.参数值
    From (Select 机器名, 参数值 From Zluserparas Where 参数id = 1687) a,
         (Select 机器名, 参数值 From Zluserparas Where 参数id = 1688) b
    Where a.机器名 = b.机器名 And b.参数值 = 药房id_In;

  v_未发数据 c_未发数据%Rowtype;
  v_药房参数 c_药房参数%Rowtype;
Begin
  --费用参数
  Update Zluserparas
  Set 参数值 = 药房id_In || ':' || 新窗口_In
  Where 参数值 = 药房id_In || ':' || 旧窗口_In And
        参数id In (Select Id From Zlparameters Where 参数名 In ('西药房窗口', '中药房窗口', '成药房窗口'));

  --业务数据
  For v_未发数据 In c_未发数据 Loop
    Update 药品收发记录
    Set 发药窗口 = 新窗口_In
    Where 单据 = v_未发数据.单据 And No = v_未发数据.No And 库房id = v_未发数据.库房id And 发药窗口 = 旧窗口_In;
    Update 门诊费用记录
    Set 发药窗口 = 新窗口_In
    Where No = v_未发数据.No And 执行部门id = v_未发数据.库房id And 发药窗口 = 旧窗口_In;
    Update 住院费用记录
    Set 发药窗口 = 新窗口_In
    Where No = v_未发数据.No And 执行部门id = v_未发数据.库房id And 发药窗口 = 旧窗口_In;
  End Loop;

  Update 未发药品记录
  Set 发药窗口 = 新窗口_In
  Where 填制日期 Between Sysdate - 3 And Sysdate And 发药窗口 = 旧窗口_In And 库房id = 药房id_In;

  --药品参数
  Update Zluserparas
  Set 参数值 = Replace(参数值, 旧窗口_In, 新窗口_In)
  Where 参数id = 1687 And 机器名 In (Select 机器名 From Zluserparas Where 参数值 = 药房id_In And 参数id = 1688);

  --叫号窗口
  Update 发药窗口 Set 叫号窗口 = 新窗口_In Where 药房id = 药房id_In And 叫号窗口 = 旧窗口_In;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_发药窗口_业务调整;
/

--106745:刘尔旋,2017-06-01,挂号检查封装
Create Or Replace Function Zl_Fun_病人挂号记录_Check
(
  操作方式_In   Integer,
  病人id_In     门诊费用记录.病人id%Type,
  号码_In       挂号安排.号码%Type,
  出诊记录id_In 临床出诊记录.Id%Type := Null,
  发生时间_In   门诊费用记录.发生时间%Type,
  专家号_In     Number := 0
) Return Varchar2 As
  --功能：挂号有效性检查(包含预约;预约挂号不扣款;预约挂号扣款)
  --入参:操作方式_IN:0-挂号(包含收款预约),1-预约,2-预约接收
  --     是否加号_In:是否加号调用，0-非加号调用，1-加号调用
  --返回:0-检查通过
  --     1-特定检查项检查失败，同时返回错误提示文本
  --     2-其他错误导致的检查失败，同时返回错误提示文本
  Err_Item Exception;
  n_病人预约科室数 Number(18);
  n_已约科室       Number(18);
  v_Temp           Varchar2(500);
  v_加入原因       特殊病人.加入原因%Type;
  n_同科限号数     Number;
  n_同科限约数     Number;
  n_科室id         挂号安排.科室id%Type;
  n_Count          Number(18);
  n_病人挂号科室数 Number;
  n_专家号挂号限制 Number;
  n_专家号预约限制 Number;
  n_专家号         Number;
  d_生效时间       Date;
  n_计划id         挂号安排计划.Id%Type;

  Cursor c_Pati(n_病人id 病人信息.病人id%Type) Is
    Select a.病人id, a.姓名, a.性别, a.年龄, a.住院号, a.门诊号, a.费别, a.险类, c.编码 As 付款方式
    From 病人信息 A, 医疗付款方式 C
    Where a.病人id = n_病人id And a.医疗付款方式 = c.名称(+);

  r_Pati c_Pati%RowType;

  Function Zl_操作员
  (
    Type_In     Integer,
    Splitstr_In Varchar2
  ) Return Varchar2 As
    n_Step Number(18);
    v_Sub  Varchar2(1000);
    --Type_In:0-获取缺省部门ID;1-获取操作员编号;2-获取操作员姓名
    -- SplitStr:格式为:部门ID,部门名称;人员ID,人员编号,人员姓名(用Zl_Identity获取的)
  Begin
    If Type_In = 0 Then
      --缺省部门
      n_Step := Instr(Splitstr_In, ',');
      v_Sub  := Substr(Splitstr_In, 1, n_Step - 1);
      Return v_Sub;
    End If;
    If Type_In = 1 Then
      --操作员编码
      n_Step := Instr(Splitstr_In, ';');
      v_Sub  := Substr(Splitstr_In, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, 1, n_Step - 1);
      Return v_Sub;
    End If;
    If Type_In = 2 Then
      --操作员姓名
      n_Step := Instr(Splitstr_In, ';');
      v_Sub  := Substr(Splitstr_In, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      Return v_Sub;
    End If;
  End;

Begin
  --检测病人相关
  Open c_Pati(病人id_In);
  n_Count := 0;
  Begin
    Fetch c_Pati
      Into r_Pati;
    n_Count := 1;
  Exception
    When Others Then
      n_Count := -1;
  End;
  If n_Count <= 0 Then
    Return '1|病人未找到，不能继续。';
  End If;
  --预约检测黑名单
  If 操作方式_In = 1 Then
    Begin
      Select 加入原因 Into v_加入原因 From 特殊病人 Where 撤消时间 Is Null And 病人id = 病人id_In And Rownum = 1;
      Return '1|此病人在特殊病人名单中，原因：【' || v_加入原因 || '】不能继续！';
    Exception
      When Others Then
        Null;
    End;
  End If;

  --检测挂号时间
  If Trunc(Sysdate) > Trunc(发生时间_In) Then
    Return '1|不能挂以前的号(' || To_Char(发生时间_In, 'yyyy-mm-dd') || ')。';
  End If;

  --部门ID,部门名称;人员ID,人员编号,人员姓名
  v_Temp := Zl_Identity(0);
  If Nvl(v_Temp, ' ') = ' ' Then
    Return '1|当前操作人员未设置对应的人员关系,不能继续。';
  End If;

  n_专家号 := 专家号_In;
  If 出诊记录id_In Is Null Then
    Select 科室id Into n_科室id From 挂号安排 Where 号码 = 号码_In;
  Else
    Select 科室id Into n_科室id From 临床出诊记录 Where ID = 出诊记录id_In;
  End If;

  --检测系统参数
  v_Temp           := Nvl(zl_GetSysParameter('病人同科限挂N个号', 1111), '0|0') || '|';
  n_同科限号数     := To_Number(Substr(v_Temp, 1, Instr(v_Temp, '|') - 1));
  n_同科限约数     := To_Number(Nvl(zl_GetSysParameter('病人同科限约N个号', 1111), '0'));
  n_病人预约科室数 := To_Number(Nvl(zl_GetSysParameter('病人预约科室数', 1111), '0'));
  n_病人挂号科室数 := To_Number(Nvl(zl_GetSysParameter('病人挂号科室限制', 1111), '0'));
  n_专家号挂号限制 := To_Number(Nvl(zl_GetSysParameter('专家号挂号限制'), '0'));
  n_专家号预约限制 := To_Number(Nvl(zl_GetSysParameter('专家号预约限制'), '0'));
  --对参数控制进行检查
  If 操作方式_In = 1 Then
    If Nvl(n_同科限约数, 0) <> 0 Or Nvl(n_病人预约科室数, 0) <> 0 Then
      n_已约科室 := 0;
      For c_Chkitem In (Select Distinct 执行部门id
                        From 病人挂号记录
                        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 2 And 预约时间 Between Trunc(发生时间_In) And
                              Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id <> n_科室id) Loop
        n_已约科室 := n_已约科室 + 1;
      End Loop;
      If n_已约科室 >= Nvl(n_病人预约科室数, 0) And Nvl(n_病人预约科室数, 0) > 0 Then
        Return '1|同一病人最多同时能预约[' || Nvl(n_病人预约科室数, 0) || ']个科室,不能再预约！';
      End If;
    
      Select Count(1)
      Into n_Count
      From 病人挂号记录
      Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 2 And 预约时间 Between Trunc(发生时间_In) And
            Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id = n_科室id;
      If n_Count >= Nvl(n_同科限约数, 0) And Nvl(n_同科限约数, 0) > 0 Then
        Return '1|该病人已经在该科室预约了' || n_Count || '次,不能再预约！';
      End If;
    End If;
    If Nvl(n_专家号预约限制, 0) <> 0 And n_专家号 = 1 Then
      If 出诊记录id_In Is Null Then
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 2 And 预约时间 Between Trunc(发生时间_In) And
              Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 号别 = 号码_In;
      Else
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 2 And 出诊记录id = 出诊记录id_In;
      End If;
      If n_Count >= Nvl(n_专家号预约限制, 0) And Nvl(n_专家号预约限制, 0) > 0 Then
        Return '1|该病人已经超过本号预约限制,不能再预约！';
      End If;
    End If;
  Else
    If (Nvl(n_同科限号数, 0) <> 0 Or Nvl(n_病人挂号科室数, 0) <> 0) And 操作方式_In = 0 Then
      n_已约科室 := 0;
      For c_Chkitem In (Select Distinct 执行部门id
                        From 病人挂号记录
                        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 1 And 发生时间 Between Trunc(发生时间_In) And
                              Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id <> n_科室id) Loop
        n_已约科室 := n_已约科室 + 1;
      End Loop;
      If n_已约科室 >= Nvl(n_病人挂号科室数, 0) And Nvl(n_病人挂号科室数, 0) > 0 Then
        Return '1|同一病人最多同时能挂号[' || Nvl(n_病人挂号科室数, 0) || ']个科室,不能再挂号！';
      End If;
    
      Select Count(1)
      Into n_Count
      From 病人挂号记录
      Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 1 And 发生时间 Between Trunc(发生时间_In) And
            Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id = n_科室id;
      If n_Count >= Nvl(n_同科限号数, 0) And Nvl(n_同科限号数, 0) > 0 Then
        Return '1|该病人已经在该科室挂号了' || n_Count || '次,不能再挂号！';
      End If;
    End If;
  
    If Nvl(n_专家号挂号限制, 0) <> 0 And n_专家号 = 1 Then
      If 出诊记录id_In Is Null Then
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 1 And 发生时间 Between Trunc(发生时间_In) And
              Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 号别 = 号码_In;
      Else
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 1 And 出诊记录id = 出诊记录id_In;
      End If;
      If n_Count >= Nvl(n_专家号挂号限制, 0) And Nvl(n_专家号挂号限制, 0) > 0 Then
        Return '1|该病人已经超过本号挂号限制,不能再挂号！';
      End If;
    End If;
  End If;

  Return '0-号源正常';

Exception
  When Others Then
    Return '2-' || SQLErrM;
End Zl_Fun_病人挂号记录_Check;
/

--109187:廖思奇,2017-05-26,病理站登记界面送检信息录入
Create Or Replace Procedure Zl_病理报到_送检更新
(
  医嘱id_In   病理送检信息.医嘱id%Type,
  送检单位_In 病理送检信息.送检单位%Type,
  送检科室_In 病理送检信息.送检科室%Type,
  送检人_In   病理送检信息.送检人%Type,
  备注_In     病理送检信息.备注%Type
) Is
  d_Date        Date;
  n_Recordcount Number(5) := 0;
Begin
  --使用特定的时间表示是外院送检信息
  d_Date := To_Date('1000/10/10 10:10:10', 'yyyy/mm/dd hh24:mi:ss');
  Begin
    Select Count(1) Into n_Recordcount From 病理送检信息 Where 医嘱id = 医嘱id_In And 送检日期 = d_Date;
  Exception
    When Others Then
      n_Recordcount := 0;
  End;

  If n_Recordcount <= 0 Then
    --如果在病理送检信息中未找到数据，则新增病理送检信息，用于直接在登记窗口中进行报到
    Insert Into 病理送检信息
      (ID, 医嘱id, 送检单位, 送检科室, 送检人, 送检日期, 备注)
    Values
      (病理送检信息_Id.Nextval, 医嘱id_In, 送检单位_In, 送检科室_In, 送检人_In, d_Date, 备注_In);
  Else
  
    --更新病理送检信息
    Update 病理送检信息
    Set 送检单位 = 送检单位_In, 送检科室 = 送检科室_In, 送检人 = 送检人_In, 备注 = 备注_In
    Where 医嘱id = 医嘱id_In And 送检日期 = d_Date;
  
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病理报到_送检更新;
/

--109518:张永康,2017-05-24,每批转出后不重建待转出索引
Create Or Replace Procedure Zl1_Datamoveout1
(
  Demoded_In        In Number,
  Optmode_In        In Number := 0,
  Curtime_In        In Number := 1,
  Totaltime_In      In Number := 1,
  Speedmode_In      In Number := 0,
  Disabletrigger_In In Number := 0,
  Disablejob_In     In Number := 0,
  Parallel_In       In Number := 0,
  Sysowner_In       In Varchar2 := Null,
  Peissysowner_In   In Varchar2 := Null,
  Opersysowner_In   In Varchar2 := Null
) As
  --功能：标记并转出n天前的数据到历史表空间 
  --参数:Demoded_in:          标记转出多少天以前的数据,当参数Optmode_In为0或1时才有效 
  --     Optmode_in:           0-标记并执行转出,1-只进行标记，2-只执行转出(将已标记的) 
  --     Curtime_in,Totaltime_in，连续多次转出时的当前次数和总次数，如果都为1表示一次性转出 
  --                首次时会检查在线表与历史表的结构一致性、在线表的子表是否转出，并且禁用他表外键，禁用转出表引用非转出表的外键索引 
  --                最后一次执行后，需在界面程序中手工恢复禁用的外键和索引 
  --     Speedmode_in:        0-在线模式，1-离线模式（在客户端停用时，转出期间禁用转出表的主键、唯一键、外键约束和索引，以加快删除操作） 
  --                          历史库的约束和索引禁用在应用程序时进行（因为需要用到历史库的连接） 
  --     Disabletrigger_in:   1=转出期间禁用当前所有者的触发器，0-不禁用 
  --     Disablejob_in:       1=转出期间禁用当前所有者的自动作业，0-不禁用 
  --     parallel_in:         重建标记查询所需索引时的并行度，缺省为不并行执行
  --     SysOwner_In:         标准系统指定转出历史表空间所有者
  --     PeisSysOwner_In:     体检系统指定转出历史表空间所有者
  --     OperSysOwner_In:     手麻系统指定转出历史表空间所有者
  --说明：1.标记要转出的数据，可以多次标记，然后分批执行转出 
  --      2.转出时，根据zlBakTables中定义的分组和顺序转出数据，分组提交事务; 
  --      3.为了避免查询范围太大导致性能问题，及Undo表空间增长太大，建议每次不要转出太多的数据(界面程序调用时自动拆分为每次调用转一个月); 
  d_End        Date;
  n_System     Number(5);
  v_Systems    Varchar2(100);
  n_Peissystem Number(5);
  n_Opersystem Number(5);
  n_Reset      Number(1) := 0;
  v_Sql        Varchar2(4000);
  v_Owner      Varchar2(20);

  v_Pre组号      Number(2);
  v_当前批次     Number(8);
  v_序列         Number(8);
  n_重建索引间隔 Zldatamove.重建索引间隔%Type;
  n_重建索引范围 Zldatamove.重建索引范围%Type;

  Err_Item Exception;
  v_Err_Msg Varchar2(4000);

  --功能：转移数据（插入后删除，按组提交事务） 
  Procedure Movedata
  (
    v_Table    In Varchar2,
    v_当前批次 In Varchar2,
    v_Owner    In Varchar2
  ) As
    v_Colstr Varchar2(4000);
  Begin
    Select f_List2str(Cast(Collect(Column_Name) As t_Strlist)) As Colsstr
    Into v_Colstr
    From (Select Column_Name From User_Tab_Columns Where Table_Name = v_Table Order By Column_Id);
  
    v_Sql := 'Insert Into /*+ append */ ' || v_Owner || '.' || v_Table || '(' || v_Colstr || ') Select ' || v_Colstr ||
             ' From ' || v_Table || ' Where 待转出 = ' || v_当前批次;
    Execute Immediate v_Sql;
  
    v_Sql := 'Delete ' || v_Table || ' Where 待转出 = ' || v_当前批次;
    Execute Immediate v_Sql;
    Commit;
    --每张表提交一次，避免Undo占用过多，耗时的业务查询可能报ora-01555快照太旧的错误
  End Movedata;

  --检查历史表等 
  Function Checkvalid(v_Systems In Varchar2) Return Varchar2 Is
    n_只读 Number(3);
    n_状态 Number(1);
    v_Err  Varchar2(4000);
    v_Tmp1 Varchar2(4000);
    v_Tmp2 Varchar2(4000);
    v_Tmp3 Varchar2(4000);
  Begin
    Select Count(1)
    Into n_只读
    From zlBakSpaces
    Where 系统 In (Select Column_Value From Table(f_Num2list(v_Systems))) And
          (所有者 = Sysowner_In Or 所有者 = Peissysowner_In Or 所有者 = Opersysowner_In) And 只读 = 1;
  
    If n_只读 > 0 Then
      v_Err := '[ZLSOFT]存在只读状态的当前历史数据空间,操作不能继续![ZLSOFT]';
      Return(v_Err);
    End If;
  
    --并发检查，避免人工转出期间，自动作业又调用本过程 
    Select Nvl(状态, 0) Into n_状态 From zlDataMove Where 系统 = n_System And 组号 = 1;
    If n_状态 = 1 Then
      v_Err := '[ZLSOFT]其他用户正在进行转出操作，如果不是这种情况，请手工更新"zlDataMove.状态"的值为空![ZLSOFT]';
      Return(v_Err);
    End If;
    --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
    If Optmode_In <> 2 Then
      --检查在线表与后备表的字段是否一致,以避免数据转移了一部分时才报错。 
      For R In (Select 表名 From zlBakTables Where 系统 In (Select Column_Value From Table(f_Num2list(v_Systems)))) Loop
        v_Tmp1 := '';
        v_Tmp2 := '';
        v_Tmp3 := '';
        For C In (Select *
                  From (Select a.Column_Name, a.Data_Type, a.Data_Precision, b.Column_Name As Bcolumn_Name,
                                b.Data_Type As Bdata_Type, b.Data_Precision As Bdata_Precision
                         From (Select Column_Name, Data_Type,
                                       Decode(Data_Type, 'VARCHAR2', Data_Length, Data_Precision) As Data_Precision
                                From User_Tab_Columns A
                                Where Table_Name = r.表名) A,
                              (Select Column_Name, Data_Type,
                                       Decode(Data_Type, 'VARCHAR2', Data_Length, Data_Precision) As Data_Precision
                                From All_Tab_Columns
                                Where Table_Name = r.表名 And
                                      Owner In
                                      (Select 所有者
                                       From zlBakSpaces
                                       Where 系统 In (Select Column_Value From Table(f_Num2list(v_Systems))) And
                                             (所有者 = Sysowner_In Or 所有者 = Peissysowner_In Or 所有者 = Opersysowner_In))) B
                         Where a.Column_Name = b.Column_Name(+))
                  Where Bcolumn_Name Is Null Or Data_Type <> Bdata_Type Or Data_Precision > Bdata_Precision) Loop
        
          If c.Bcolumn_Name Is Null Then
            v_Tmp1 := v_Tmp1 || ',' || c.Column_Name || ' ' || c.Data_Type || '(' || c.Data_Precision || ')';
          Elsif c.Data_Type <> c.Bdata_Type Then
            If c.Data_Type = 'DATE' Then
              v_Tmp2 := v_Tmp2 || ',' || c.Column_Name || ' ' || c.Data_Type || ',历史表的为' || c.Bdata_Type;
            Else
              v_Tmp2 := v_Tmp2 || ',' || c.Column_Name || ' ' || c.Data_Type || '(' || c.Data_Precision || '),历史表的为' ||
                        c.Bdata_Type;
            End If;
          Else
            v_Tmp3 := v_Tmp3 || ',' || c.Column_Name || ' ' || c.Data_Type || '(' || c.Data_Precision || '),历史表的为' ||
                      c.Bdata_Precision;
          End If;
        End Loop;
      
        If v_Tmp1 Is Not Null Then
          v_Err := v_Err || Chr(10) || ',缺字段：' || r.表名 || ' ' || v_Tmp1;
        End If;
        If v_Tmp2 Is Not Null Then
          v_Err := v_Err || Chr(10) || ',类型不同：' || r.表名 || ' ' || v_Tmp2;
        End If;
        If v_Tmp3 Is Not Null Then
          v_Err := v_Err || Chr(10) || ',长度较小：' || r.表名 || ' ' || v_Tmp3;
        End If;
      
        If Lengthb(v_Err) > 3000 Then
          v_Err := '[ZLSOFT]请到【管理工具】中执行【历史库修正】' || Substr(v_Err, 1, 3000) || '......[ZLSOFT]';
          Return(v_Err);
        End If;
      End Loop;
    
      If v_Err Is Not Null Then
        v_Err := '[ZLSOFT]请到【管理工具】中执行【历史库修正】:' || Substr(v_Err, 1, 3000) || '[ZLSOFT]';
        --重建H表视图的脚本生成语句示例： 
        --Select 'Create or replace view  ZLHIS.H' || 表名 || ' as Select * From ZLBAK1.' || 表名 || ';' From Zlbaktables Where 系统 In(Select Column_Value From Table(f_num2list(v_Systems))) 
        Return(v_Err);
      End If;
    
      --可能由于历史升级脚本的遗漏，有些不再使用的外键或子表没有删除，为了避免转移到中途时才报错，先检查一遍 
      For P In (Select Constraint_Name
                From (Select Constraint_Name,
                              Row_Number() Over(Partition By Constraint_Name Order By Decode(Constraint_Type, 'P', 0, 1)) Rn
                       From User_Constraints A, zlBakTables B
                       Where b.表名 = a.Table_Name And b.系统 In (Select Column_Value From Table(f_Num2list(v_Systems))) And
                             a.Constraint_Type In ('P', 'U'))
                Where Rn = 1) Loop
        For R In (Select a.Table_Name, a.Constraint_Name, a.Delete_Rule
                  From User_Constraints A
                  Where a.r_Constraint_Name = p.Constraint_Name And Not Exists
                   (Select 1
                         From zlBakTables B
                         Where b.表名 = a.Table_Name And b.系统 In (Select Column_Value From Table(f_Num2list(v_Systems))))
                  Order By a.r_Constraint_Name) Loop
          v_Err := v_Err || Chr(10) || r.Table_Name || '(' || r.Constraint_Name || ',' || r.Delete_Rule || '->' ||
                   p.Constraint_Name || ')';
          If Lengthb(v_Err) > 2000 Then
            v_Err := '[ZLSOFT]子表未转出:' || Substr(v_Err, 1, 2000) || '......[ZLSOFT]';
            Return(v_Err);
          End If;
        End Loop;
      End Loop;
    
      If v_Err Is Not Null Then
        v_Err := '[ZLSOFT]子表未转出:' || Substr(v_Err, 1, 2000) || '[ZLSOFT]';
        Return(v_Err);
      End If;
    End If;
    Return('');
  End Checkvalid;
Begin
  If Optmode_In <> 2 Then
    Select Trunc(Sysdate) - Demoded_In Into d_End From Dual;
  End If;
  v_Owner := Zl_Owner;
  Select 编号 Into n_System From zlSystems Where Upper(所有者) = v_Owner And 编号 Like '1%';

  Select Nvl(Min(编号), 0) Into n_Peissystem From zlSystems Where Upper(所有者) = v_Owner And 编号 Like '21%';
  Select Nvl(Min(编号), 0) Into n_Opersystem From zlSystems Where Upper(所有者) = v_Owner And 编号 Like '24%';

  --1.安全性检查 
  ----------------------------------------------------------------------------------- 
  If Curtime_In = 1 Then
    v_Systems := n_System;
    If n_Peissystem > 0 Then
      v_Systems := v_Systems || ',' || n_Peissystem;
    End If;
    If n_Opersystem > 0 Then
      v_Systems := v_Systems || ',' || n_Opersystem;
    End If;
  
    v_Err_Msg := Checkvalid(v_Systems);
    If v_Err_Msg Is Not Null Then
      Raise Err_Item;
    End If;
  
    --一批中的首次调用时禁用触发器和作业 
    If Disabletrigger_In = 1 Then
      Zl1_Datamove_Reb(n_System, Speedmode_In, 1, 0);
      If n_Peissystem > 0 Then
        Zl1_Datamove_Reb(n_Peissystem, Speedmode_In, 1, 0);
      End If;
      If n_Opersystem > 0 Then
        Zl1_Datamove_Reb(n_Opersystem, Speedmode_In, 1, 0);
      End If;
    End If;
  
    If Disablejob_In = 1 Then
      Zl1_Datamove_Reb(n_System, Speedmode_In, 2, 0);
      If n_Peissystem > 0 Then
        Zl1_Datamove_Reb(n_Peissystem, Speedmode_In, 2, 0);
      End If;
      If n_Opersystem > 0 Then
        Zl1_Datamove_Reb(n_Opersystem, Speedmode_In, 2, 0);
      End If;
    End If;
  
    Update zlDataMove Set 状态 = 1 Where 系统 = n_System And 组号 = 1;
    Commit;
  End If;

  --2.标记要转出的数据 
  ----------------------------------------------------------------------------------- 
  If Optmode_In <> 2 Then
    --上次标记转出出错后继续进行标记转出 
    Select Nvl(Max(批次), 0) Into v_当前批次 From Zldatamovelog Where 系统 = n_System And 待转出 = 2;
  
    If v_当前批次 = 0 Then
      Select Nvl(Max(批次), 0) + 1, Decode(Curtime_In, 1, Nvl(Max(序列), 0) + 1, Max(序列))
      Into v_当前批次, v_序列
      From Zldatamovelog
      Where 系统 = n_System;
    
      Insert Into Zldatamovelog
        (系统, 批次, 序列, 截止时间, 标记开始时间, 待转出, 当前进度)
      Values
        (n_System, v_当前批次, v_序列, d_End, Sysdate, 2, '正在标记待转出数据');
      Commit;
    Else
      Update Zldatamovelog
      Set 标记开始时间 = Sysdate, 当前进度 = '正在标记待转出数据'
      Where 系统 = n_System And 批次 = v_当前批次;
      Commit;
    End If;
  
    Zl1_Datamove_Tag(d_End, v_当前批次, n_System);
    If n_Peissystem > 0 Then
      Execute Immediate 'Begin Zl21_Datamove_Tag(:1, :2, :3); End;'
        Using d_End, v_当前批次, n_Peissystem;
    End If;
    If n_Opersystem > 0 Then
      Execute Immediate 'Begin Zl24_Datamove_Tag(:1, :2, :3); End;'
        Using d_End, v_当前批次, n_Opersystem;
    End If;
  
    Update Zldatamovelog
    Set 标记结束时间 = Sysdate, 当前进度 = '标记待转出数据完成', 待转出 = 1
    Where 系统 = n_System And 批次 = v_当前批次;
    Commit;
  End If;

  --3.转移数据处理 
  ----------------------------------------------------------------------------------- 
  If Optmode_In = 1 Then
    If Curtime_In = Totaltime_In Then
      Update zlDataMove Set 状态 = Null Where 系统 = n_System And 组号 = 1;
    End If;
    Commit;
  Else
    --从最小的批次开始执行转出 
    If Optmode_In = 2 Then
      Select Nvl(Min(批次), 0), Max(截止时间)
      Into v_当前批次, d_End
      From Zldatamovelog
      Where 系统 = n_System And 待转出 = 1;
    
      If v_当前批次 = 0 Then
        Update zlDataMove Set 状态 = Null Where 系统 = n_System And 组号 = 1;
        Return;
      End If;
    End If;
  
    --禁用约束和索引 
    If Curtime_In = 1 Then
      Update Zldatamovelog Set 当前进度 = '正在禁用约束和索引' Where 系统 = n_System And 批次 = v_当前批次;
      --要先禁用约束，否则主键或唯一键的索引被禁用后，会导致查询或插入操作报错，而禁用主键或唯一键则会删除对应的索引 
      n_Reset := 1;
      Zl1_Datamove_Reb(n_System, Speedmode_In, 3, 0);
      If n_Peissystem > 0 Then
        Zl1_Datamove_Reb(n_Peissystem, Speedmode_In, 3, 0);
      End If;
      If n_Opersystem > 0 Then
        Zl1_Datamove_Reb(n_Opersystem, Speedmode_In, 3, 0);
      End If;
    
      Zl1_Datamove_Reb(n_System, Speedmode_In, 4, 0);
      If n_Peissystem > 0 Then
        Zl1_Datamove_Reb(n_Peissystem, Speedmode_In, 4, 0);
      End If;
      If n_Opersystem > 0 Then
        Zl1_Datamove_Reb(n_Opersystem, Speedmode_In, 4, 0);
      End If;
    End If;
  
    --数据转出处理 
    ----------------------------------------------------------------------------------- 
    --不更新汇总表：病人费用汇总，药品收发汇总，药品库存，人员缴款余额等，虽然只是更新的期初数， 
    --但是，由于并非这个时间以前的数据都转出了（部分未符合转出条件的数据未转出），更新后，如果按时间查询，会发现在线中这些日期的数据非常小，容易引起误解 
    --即使出于某些特殊原因需要更新汇总表，也可以通过汇总表处理的过程进行重新汇总，所以，不必在转出过程中逐条更新。 
  
    --"标记结束时间=转出开始时间"时不记录 
    If Optmode_In = 2 Then
      Update Zldatamovelog Set 转出开始时间 = Sysdate Where 系统 = n_System And 批次 = v_当前批次;
    End If;
  
    --a.转出标准版数据
    For R In (Select 表名, 组号 From zlBakTables Where 系统 = n_System And 直接转出 = 1 Order By 组号, 序号) Loop
      If Nvl(v_Pre组号, -1) <> r.组号 Then
        Update Zldatamovelog
        Set 当前进度 = '正在转出第' || r.组号 || '组(' || r.表名 || '...)数据'
        Where 系统 = n_System And 批次 = v_当前批次;
        Commit;
      End If;
    
      Movedata(r.表名, v_当前批次, Sysowner_In);
      v_Pre组号 := r.组号;
    End Loop;
  
    --b.转出体检数据
    v_Pre组号 := -1;
    For R In (Select 表名, 组号 From zlBakTables Where 系统 = n_Peissystem And 直接转出 = 1 Order By 组号, 序号) Loop
      If Nvl(v_Pre组号, -1) <> r.组号 Then
        Update Zldatamovelog
        Set 当前进度 = '正在转出体检第' || r.组号 || '组(' || r.表名 || '...)数据'
        Where 系统 = n_System And 批次 = v_当前批次;
        Commit;
      End If;
    
      Movedata(r.表名, v_当前批次, Peissysowner_In);
      v_Pre组号 := r.组号;
    End Loop;
  
    --c.转出手麻数据
    v_Pre组号 := -1;
    For R In (Select 表名, 组号 From zlBakTables Where 系统 = n_Opersystem And 直接转出 = 1 Order By 组号, 序号) Loop
      If Nvl(v_Pre组号, -1) <> r.组号 Then
        Update Zldatamovelog
        Set 当前进度 = '正在转出手麻第' || r.组号 || '组(' || r.表名 || '...)数据'
        Where 系统 = n_System And 批次 = v_当前批次;
        Commit;
      End If;
    
      Movedata(r.表名, v_当前批次, Opersysowner_In);
      v_Pre组号 := r.组号;
    End Loop;
    Commit;
  
    Update 病案主页 Set 待转出 = Null, 数据转出 = 1 Where 待转出 = v_当前批次;
  
    Update zlDataMove Set 上次日期 = d_End Where 系统 = n_System And 组号 = 1;
  
    v_Sql := 'Update ' || Sysowner_In || '.zlBakInfo Set 最后转储日期 = Sysdate Where 系统 = ' || n_System;
    Execute Immediate v_Sql;
  
    If n_Peissystem > 0 Then
      v_Sql := 'Update ' || Peissysowner_In || '.zlBakInfo Set 最后转储日期 = Sysdate Where 系统 = ' || n_Peissystem;
      Execute Immediate v_Sql;
    End If;
  
    If n_Opersystem > 0 Then
      v_Sql := 'Update ' || Opersysowner_In || '.zlBakInfo Set 最后转储日期 = Sysdate Where 系统 = ' || n_Opersystem;
      Execute Immediate v_Sql;
    End If;
  
    Update Zldatamovelog
    Set 转出结束时间 = Sysdate, 待转出 = Null, 当前进度 = '转出数据完成,正在重建待转出索引'
    Where 系统 = n_System And 批次 = v_当前批次;
    Commit;
  
    If Curtime_In = Totaltime_In Then
      Update zlDataMove
      Set 状态 = Null, 本次最终日期 = Decode(Sign(d_End - 本次最终日期), -1, 本次最终日期, Null)
      Where 系统 = n_System And 组号 = 1;
      Commit;
    End If;
  
    --4.索引重建（以提高下次标记转出查询的速度） 
    ----------------------------------------------------------------------------------- 
    --每次转完后不要重建待转出索引，在线重建容易出现卡死，并且索引无法重建和删除（ORA-08104）
   
    --收缩标记转出查询所需的索引被删除后的空闲空间，下次标记转出时减少范围扫描的数据块 
    --如果每次转完后进行，则耗时较多，所以，可根据查询的耗时来动态决定间隔次数(界面缺省为24次转出后重建一次) 
    Select Nvl(重建索引间隔, 0), Nvl(重建索引范围, 0)
    Into n_重建索引间隔, n_重建索引范围
    From zlDataMove
    Where 系统 = n_System And 组号 = 1;
  
    If Mod(Curtime_In, n_重建索引间隔) = 0 And n_重建索引间隔 <> 0 Then
      Zl1_Datamove_Reb(n_System, Speedmode_In, 6, 1, Parallel_In, n_重建索引范围);
    
      If n_Peissystem > 0 Then
        Zl1_Datamove_Reb(n_Peissystem, Speedmode_In, 6, 1, Parallel_In, n_重建索引范围);
      End If;
      If n_Opersystem > 0 Then
        Zl1_Datamove_Reb(n_Opersystem, Speedmode_In, 6, 1, Parallel_In, n_重建索引范围);
      End If;
    End If;
  
    Update Zldatamovelog Set 重建结束时间 = Sysdate, 当前进度 = '完成' Where 系统 = n_System And 批次 = v_当前批次;
    Commit;
  End If;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    --可能部分数据插入成功，删除操作由于主键或唯一的索引被禁用而失败 
    Rollback;
    Update zlDataMove Set 状态 = Null Where 系统 = n_System And 组号 = 1;
  
    v_Err_Msg := Substr(SQLErrM, 1, 60);
    If Curtime_In = 1 And n_Reset = 0 Then
      Update Zldatamovelog Set 当前进度 = '转出标记出错：' || v_Err_Msg Where 系统 = n_System And 批次 = v_当前批次;
    Else
      Update Zldatamovelog
      Set 当前进度 = '转出出错：' || v_Err_Msg || Substr(v_Sql, 1, 30)
      Where 系统 = n_System And 批次 = v_当前批次;
    End If;
    Commit;
  
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl1_Datamoveout1;
/

--109518:张永康,2017-05-24,电子病历内容触发器的修改
Create Or Replace Procedure Zl1_Datamove_Reb
(
  System_In    In Number,
  Speedmode_In In Number,
  Func_In      In Number,
  Enable_In    In Number := 0,
  Parallel_In  In Number := 0,
  Rebscope_In  In Number := 0
) As
  --功能：在历史数据转出之前，禁用触发器、自动作业、约束、索引，转出之后启用这些对象，以及重建待转出索引，收回标记转出所用索引的空间 
  --参数： 
  --System_In:    应用系统编号,100=标准版 
  --speedmode_in：数据转出模式，0-在线模式，1-离线模式（在客户端停用时，转出期间禁用转出表的主键、唯一键、外键约束和索引，以加快已转数据的删除操作） 
  --func_in:      1=触发器，2=自动作业，3=约束，4=索引，5=重建待转出索引，6-收回标记转出所用索引的空间，7-重组表的存储空间（move），并恢复被禁用的约束和索引 ,8-重建标记转出查询所需索引以外的其他索引 
  --Enable_in:    0-禁用，1=启用，对func_in值为1-4有效 
  --rebScope_in:   Func_In=6时，指重建索引的范围(0-经济核算类,1-经济核算类及医嘱类,2-全部)，Func_In=7时指Move表的范围(0-经济核算类，1-全部) 

  v_Sql      Varchar2(4000);
  n_Do       Number(1);
  n_Parallel Number(1);
  v_Tbs      Varchar2(100);
  v_Prompt   Varchar2(100);
  d_Curdate  Date;

  --功能：1.禁用或启用引用转出表主键的他表外键,避免删除主表记录时对子表每行记录执行一次SQL查询或删除 
  --      2.禁用或启用主键或唯一键约束（禁用时会自动删除对应的索引，启用时自动创建），以提高数据删除性能 
  --例如：病人医嘱发送_FK_医嘱ID，如果这些外键所在的表，数据未转出（未在zlbaktables表中定义），执行前会检查并限制转出。 
  Procedure Setconstraintstatus As
    v_Pcol Varchar2(50);    
    v_Del  Varchar2(4000);
  Begin
    --禁用时，先禁用引用转出表主键的他表外键，再禁用转出表的主键 
    If Enable_In = 0 Then
      --1.在线模式转出时，由于有业务产生删除操作，所以，对于级联删除的外键，用触发器来替代对子表数据的删除操作
      If Speedmode_In = 0 Then
        For Rp In (Select Distinct a.Table_Name As Ptable_Name, a.Constraint_Name
                   From User_Constraints A, User_Constraints C, zlBakTables B
                   Where a.Table_Name = b.表名 And b.直接转出 = 1 And b.系统 = System_In And a.Constraint_Type In ('P', 'U') And
                         c.r_Constraint_Name = a.Constraint_Name And c.Constraint_Type = 'R' And
                         c.Delete_Rule = 'CASCADE'
                   Order By a.Table_Name) Loop
        
          Select f_List2str(Cast(Collect(Column_Name Order By Position) As t_Strlist))
          Into v_Pcol
          From User_Cons_Columns
          Where Constraint_Name = Rp.Constraint_Name;
        
          --对级联删除的外键，引用自身所在表的字段（例：电子病历内容）,不用再根据"父ID"字段删除本表的子记录
          v_Del := '';
          For Rf In (Select b.Table_Name, b.Constraint_Name,
                            f_List2str(Cast(Collect(b.Column_Name Order By b.Position) As t_Strlist)) As r_Col
                     From User_Constraints A, User_Cons_Columns B
                     Where a.r_Constraint_Name = Rp.Constraint_Name And a.Constraint_Name = b.Constraint_Name And
                           b.Table_Name != Rp.Ptable_Name
                     Group By b.Table_Name, b.Constraint_Name) Loop
            If Instr(v_Pcol, ',') > 0 Then
              v_Del := v_Del || Chr(10) || '        Delete ' || Rf.Table_Name || ' Where (' || Rf.r_Col ||
                       ') in ((:Old.' || Replace(v_Pcol, ',', ',:Old.') || '));';
            Else
              v_Del := v_Del || Chr(10) || '        Delete ' || Rf.Table_Name || ' Where ' || Rf.r_Col || ' = :Old.' ||
                       v_Pcol || ';';
            End If;
          End Loop;
        
          v_Sql := 'Create Or Replace Trigger ' || Rp.Ptable_Name || '_Cascade_Del' || Chr(10) ||
                   '    After Delete On ' || Rp.Ptable_Name || Chr(10) || '    For Each Row' || Chr(10) || 'Begin' ||
                   Chr(10) || '    If :Old.待转出 Is Null Then ' || v_Del || Chr(10) || '    End If; ' || Chr(10) ||
                   'End ' || Rp.Ptable_Name || '_Cascade_Del;';
        
          Execute Immediate v_Sql;
        End Loop;
      End If;
    
      --2.禁用引用转出表主键的他表外键
      For R In (Select c.Table_Name, c.Constraint_Name, a.Table_Name As Ptable_Name
                From User_Constraints A, User_Constraints C, zlBakTables B
                Where a.Table_Name = b.表名 And b.直接转出 = 1 And b.系统 = System_In And a.Constraint_Type In ('P', 'U') And
                      c.r_Constraint_Name = a.Constraint_Name And c.Constraint_Type = 'R' And c.Status = 'ENABLED'
                Order By a.Table_Name) Loop
        v_Sql := 'Alter Table ' || r.Table_Name || ' Disable Constraint ' || r.Constraint_Name;
        Execute Immediate v_Sql;
      End Loop;
    
      --3.禁用主键或唯一键索引(离线转出时)
      If Speedmode_In = 1 Then
        --必须删除索引，否则即使skip_unusable_indexes为true，也无法删除存在Unusable状态的唯一性索引的表中的记录
        --保留转出标记中的SQL查询所需的索引(主键和唯一键对应的索引) 
        For R In (Select a.Table_Name, a.Constraint_Name
                  From User_Constraints A, zlBakTables T, User_Tables B
                  Where a.Table_Name = t.表名 And t.直接转出 = 1 And t.系统 = System_In And a.Status = 'ENABLED' And
                        a.Constraint_Type In ('P', 'U') And a.Table_Name = b.Table_Name And b.Iot_Type Is Null And
                        a.Constraint_Name Not In (Select Upper(索引名) From Zlbaktableindex Where 系统 = System_In)
                  Order By Constraint_Name) Loop
          v_Sql := 'Alter Table ' || r.Table_Name || ' Disable Constraint ' || r.Constraint_Name ||
                   ' Cascade Drop Index';
          Execute Immediate v_Sql;
        End Loop;
      End If;
    Else
      --启用时
      --1.先启用主键和唯一键，再启用引用转出表主键的他表外键 
      If Speedmode_In = 1 Then
        --先重建索引，再启用约束，以便重建索引时利用并行执行缩短时间，并且启用约束时也可以采用novalidate方式 
        For R In (Select d.Table_Name, d.Constraint_Name,
                         f_List2str(Cast(Collect(d.Column_Name Order By d.Position) As t_Strlist)) Colstr
                  From User_Cons_Columns D,
                       (Select a.Table_Name, a.Constraint_Name
                         From User_Constraints A, zlBakTables T
                         Where a.Table_Name = t.表名 And t.直接转出 = 1 And t.系统 = System_In And a.Status = 'DISABLED' And
                               a.Constraint_Type In ('P', 'U')) A
                  Where a.Constraint_Name = d.Constraint_Name And a.Table_Name = d.Table_Name
                  Group By d.Table_Name, d.Constraint_Name
                  Order By Constraint_Name) Loop
        
          Update zlDataMove Set 说明 = '正在恢复约束:' || r.Constraint_Name Where 系统 = 100 And 组号 = 1;
        
          Select Tablespace_Name Into v_Tbs From User_Indexes Where Table_Name = r.Table_Name And Rownum < 2;
        
          --禁用主键或唯一键时，索引是被删除了的，所以这里要用Create 
          v_Sql := 'Create Unique Index ' || r.Constraint_Name || ' On ' || r.Table_Name || '(' || r.Colstr ||
                   ') Tablespace ' || v_Tbs || ' Nologging';
          Begin
            Execute Immediate v_Sql;
          Exception
            When Others Then
              Null; --可能有些主键或唯一键不是本次转出期间被禁用的，之前就存在不唯一数据，创建唯一索引会出错 
          End;
        
          --会自动建立约束与索引的关联 
          v_Sql := 'Alter Table ' || r.Table_Name || ' Enable Novalidate Constraint ' || r.Constraint_Name;
          Execute Immediate v_Sql;
        End Loop;
      End If;
    
      --2.启用引用转出表主键的他表外键 
      For R In (Select c.Table_Name, c.Constraint_Name
                From User_Constraints A, User_Constraints C, zlBakTables B
                Where a.Table_Name = b.表名 And b.直接转出 = 1 And b.系统 = System_In And a.Constraint_Type In ('P', 'U') And
                      c.r_Constraint_Name = a.Constraint_Name And c.Constraint_Type = 'R' And c.Status = 'DISABLED'
                Order By a.Table_Name) Loop
        --为了加快速度，采用novalidate，不验证已有数据 
        --可能引用转出表主键的他表，在zlbaktables中定义了，但没有编写对应的数据转出脚本，未验证的数据可能有违反约束的情况。 
        v_Sql := 'Alter Table ' || r.Table_Name || ' Enable Novalidate Constraint ' || r.Constraint_Name;
        Execute Immediate v_Sql;
      End Loop;
    
      --3.在线模式转出时，删除之前创建的用来替代级联删除外键的触发器
      If Speedmode_In = 0 Then
        For R In (Select a.Trigger_Name
                  From User_Triggers A, zlBakTables B
                  Where a.Table_Name = b.表名 And b.直接转出 = 1 And b.系统 = System_In And
                        Trigger_Name = Table_Name || '_CASCADE_DEL' And Triggering_Event = 'DELETE') Loop
          v_Sql := 'Drop Trigger ' || r.Trigger_Name;
          Execute Immediate v_Sql;
        End Loop;
      End If;
    End If;
  End Setconstraintstatus;

  --功能：高速模式时禁用LOB以外的所有索引，在线模式时仅禁用转出表引用非转出表的外键索引(例如：病人医嘱计价_IX_收费细目ID) 
  --说明：禁用索引是为了提高删除数据的性能 
  Procedure Setindexstatus As
  Begin
    If Speedmode_In = 1 Then
      --保留转出标记中的SQL查询所需的索引 
      For R In (Select /*+ rule*/
                 a.Index_Name
                From User_Indexes A, zlBakTables T
                Where a.Table_Name = t.表名 And t.直接转出 = 1 And t.系统 = System_In And t.直接转出 = 1 And
                      a.Index_Name <> a.Table_Name || '_IX_待转出' And
                      a.Index_Name Not In (Select Upper(索引名) From Zlbaktableindex Where 系统 = System_In) And
                      a.Status = Decode(Enable_In, 0, 'VALID', 'UNUSABLE') And a.Index_Type = 'NORMAL' And Not Exists
                 (Select 1
                       From User_Constraints C
                       Where c.Index_Name = a.Index_Name And c.Constraint_Type In ('P', 'U'))
                Order By Index_Name) Loop
      
        If Enable_In = 0 Then
          v_Sql := 'Alter Index ' || r.Index_Name || ' Unusable';
          Execute Immediate v_Sql;
        Else
          Update zlDataMove Set 说明 = '正在重建索引:' || r.Index_Name Where 系统 = 100 And 组号 = 1;
        
          v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Nologging';
          Begin
            Execute Immediate v_Sql;
            --在线重建比较慢，不在线重建则需要锁表，如果有其他并发事务，则会出错：ORA-00054: 资源正忙, 但指定以 NOWAIT 方式获取资源 
          
          Exception
            When Others Then
              If SQLErrM Like 'ORA-00054%' Then
                v_Sql := Replace(v_Sql, 'Rebuild', 'Rebuild Online');
                Execute Immediate v_Sql;
              End If;
          End;
        End If;
      End Loop;
    Else
      For R In (Select a.Index_Name
                From (Select d.Table_Name, d.Index_Name,
                              f_List2str(Cast(Collect(d.Column_Name Order By d.Column_Position) As t_Strlist)) Colstr
                       From User_Ind_Columns D, zlBakTables T, User_Indexes C
                       Where c.Table_Name = t.表名 And t.直接转出 = 1 And t.系统 = System_In And c.Uniqueness = 'NONUNIQUE' And
                             c.Index_Type = 'NORMAL' And c.Status = Decode(Enable_In, 0, 'VALID', 'UNUSABLE') And
                             c.Index_Name = d.Index_Name And c.Table_Name = d.Table_Name
                       Group By d.Table_Name, d.Index_Name) A,
                     (Select e.Table_Name,
                              f_List2str(Cast(Collect(e.Column_Name Order By e.Position) As t_Strlist)) Colstr
                       From User_Cons_Columns E, User_Constraints F, zlBakTables T, User_Constraints C
                       Where e.Table_Name = t.表名 And t.直接转出 = 1 And t.系统 = System_In And
                             e.Constraint_Name = f.Constraint_Name And f.Constraint_Type = 'R' And
                             c.Constraint_Name = f.r_Constraint_Name And c.Table_Name Not In ('病案主页', '病人信息') And
                             Not Exists
                        (Select 1 From zlBakTables G Where g.表名 = c.Table_Name And g.系统 = System_In)
                       Group By e.Table_Name, e.Constraint_Name) B
                Where a.Table_Name = b.Table_Name And a.Colstr = b.Colstr
                Order By Index_Name) Loop
      
        If Enable_In = 0 Then
          --特殊处理：以下两个索引不禁用，是由于药品目录修改规格，财务缴款需要使用 
          If r.Index_Name Not In ('病人医嘱记录_IX_收费细目ID', '药品收发记录_IX_药品ID', '药品收发记录_IX_价格ID') Then
            v_Sql := 'Alter Index ' || r.Index_Name || ' Unusable';
            Execute Immediate v_Sql;
          End If;
        Else
          Update zlDataMove Set 说明 = '正在重建索引:' || r.Index_Name Where 系统 = 100 And 组号 = 1;
        
          v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Online Nologging';
          Execute Immediate v_Sql;
          --在线重建比较慢，不在线重建则需要锁表，如果有其他并发事务，则会出错：ORA-00054: 资源正忙, 但指定以 NOWAIT 方式获取资源 
        End If;
      End Loop;
    End If;
  End Setindexstatus;

  --功能：转出数据期间，停用转出表上的所有触发器，转出后再恢复 
  Procedure Settriggerstatus As
  Begin
    For R In (Select Distinct a.Table_Name, t.停用触发器
              From User_Triggers A, zlBakTables T
              Where a.Status = Decode(Enable_In, 0, 'ENABLED', 'DISABLED') And a.Table_Name = t.表名 And t.直接转出 = 1 And
                    t.系统 = System_In) Loop
      If Enable_In = 0 Then
        v_Sql := 'Alter Table ' || r.Table_Name || ' DISABLE ALL TRIGGERS';
        Update zlBakTables Set 停用触发器 = 1 Where 系统 = System_In And 表名 = r.Table_Name;
      Elsif Nvl(r.停用触发器, 0) = 1 Then
        v_Sql := 'Alter Table ' || r.Table_Name || ' ENABLE ALL TRIGGERS';
        Update zlBakTables Set 停用触发器 = Null Where 系统 = System_In And 表名 = r.Table_Name;
      End If;
      Execute Immediate v_Sql;
    End Loop;
    Commit;
  End Settriggerstatus;

  --功能：转出数据期间，停用当前所有者的所有自动作业，转出后再启用 
  Procedure Setjobstatus As
    v_Jobs Varchar2(4000);
  Begin
    --停用 
    If Enable_In = 0 Then
      For R In (Select Job From User_Jobs Where Broken = 'N') Loop
        Dbms_Job.Broken(r.Job, True);
        v_Jobs := v_Jobs || ',' || r.Job;
      End Loop;
    
      If v_Jobs Is Not Null Then
        v_Jobs := Substr(v_Jobs, 2);
        Update zlDataMove Set 停用作业号 = v_Jobs Where 系统 = System_In And 组号 = 1;
      End If;
    Else
      --启用 
      Select 停用作业号 Into v_Jobs From zlDataMove Where 系统 = System_In And 组号 = 1;
      If v_Jobs Is Not Null Then
        For R In (Select Job
                  From User_Jobs
                  Where Broken = 'Y' And Job In (Select Column_Value From Table(f_Num2list(v_Jobs)))) Loop
          Dbms_Job.Broken(r.Job, False);
        End Loop;
        Update zlDataMove Set 停用作业号 = Null Where 系统 = System_In And 组号 = 1;
      End If;
    End If;
    --作业设置后必须提交事务才生效 
    Commit;
  End Setjobstatus;
Begin
  If Parallel_In < 2 Then
    Execute Immediate 'Alter Session DISABLE PARALLEL DDL';
  Else
    If Func_In In (6, 7, 8) Or Func_In In (3, 4) And Enable_In = 1 Then
      --为重建索引设置并行执行（由于通常受限于IO设备的性能，设置太高的并行度反而会降低性能，如有高性能存储设备，可加大并行度） 
      --执行重建索引后会自动为索引加上并行度属性，如果不取消，会影响相关SQL的执行计划(全表扫描+并行查询，巨慢),在后面取消索引的并行度 
      --恢复在线库的约束和索引时，不管是不是在线模式，都加上并行，否则太慢
      Execute Immediate 'Alter Session FORCE PARALLEL DDL PARALLEL ' || Parallel_In;
      n_Parallel := 1;
    End If;
  End If;

  --提高索引创建速度（缩短40%以上的时间）
  If Func_In In (6, 7, 8) Or Func_In In (3, 4) And Enable_In = 1 Then
    Execute Immediate 'alter session set workarea_size_policy=MANUAL';
  
    --设置直接路径IO的大小
    Execute Immediate 'alter session set events ''10351 trace name context forever, level 128''';
    Execute Immediate 'alter session SET db_file_multiblock_read_count=128';
    Execute Immediate 'alter session set "_sort_multiblock_read_count"=128';
    Begin
      --由于10G的BUG，sort_area_size需执行两次才会生效
      Execute Immediate 'alter session SET sort_area_size=512000000';
      Execute Immediate 'alter session SET sort_area_size=512000000';
    Exception
      When Others Then
        Null; --如果可用内存不足500M，失败则忽略
    End;
    Execute Immediate 'alter session SET db_block_checking=false';
  End If;

  If Func_In In (5, 6, 7, 8) Or Func_In In (3, 4) And Enable_In = 1 Then
    d_Curdate := Sysdate;
  End If;

  If Func_In = 1 Then
    --1.设置触发器 
    Settriggerstatus;
  Elsif Func_In = 2 Then
    --2.设置自动作业 
    Setjobstatus;
  Elsif Func_In = 3 Then
    --3.设置约束状态    
    Setconstraintstatus;
    v_Prompt := '恢复禁用的约束';
  Elsif Func_In = 4 Then
    --4.设置索引状态 
    Setindexstatus;
    v_Prompt := '恢复禁用的索引';
  Elsif Func_In = 5 Then
    --5.重建"待转出"索引    
    For R In (Select Index_Name
              From (Select b.Index_Name
                     From zlBakTables A, User_Indexes B
                     Where a.表名 = b.Table_Name And a.直接转出 = 1 And a.系统 = System_In And
                           b.Index_Name = b.Table_Name || '_IX_待转出'
                     Union All
                     Select '病案主页_IX_待转出'
                     From Dual
                     Where System_In = 100)
              Order By 1) Loop
      Update zlDataMove Set 说明 = '正在重建待转出索引:' || r.Index_Name Where 系统 = 100 And 组号 = 1;
    
      --耗时太短，无须并行DDL 
      --在线转出时如果重建索引会锁表，如果有其他并发事务，则会出错：ORA-00054: 资源正忙, 但指定以 NOWAIT 方式获取资源 
      --在线重建索引太慢，所以，即使在线转出模式也不用在线重建
      v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Nologging';
      Begin
        Execute Immediate v_Sql;
      Exception
        When Others Then
          If SQLErrM Like 'ORA-00054%' Then
            v_Sql := Replace(v_Sql, 'Rebuild', 'Rebuild Online');
            Execute Immediate v_Sql;
          End If;
      End;
    End Loop;
    v_Prompt := '重建待转出索引';
  
  Elsif Func_In = 6 Then
    --6.重建标记转出查询所用到的索引（测试表明重建后最多可缩短一半的查询时间） 
    --根据业务的启用阶段来决定重建哪些索引，以避免一些不必要的重建耗时    
    For R In (Select b.Index_Name, a.组号
              From User_Indexes B, zlBakTables A
              Where a.表名 = b.Table_Name And a.系统 = System_In And
                    (b.Table_Name, b.Index_Name) In
                    (Select 表名, Upper(索引名) From Zlbaktableindex Where 系统 = System_In)
              Order By Index_Name) Loop
      n_Do := 0;
      If Rebscope_In = 0 Then
        If r.组号 < 5 Then
          n_Do := 1; --仅经济核算类 
        End If;
      Elsif Rebscope_In = 1 Then
        If r.组号 < 5 Or r.组号 = 8 Then
          n_Do := 1; --仅经济核算类、医嘱类 
        End If;
      Else
        n_Do := 1;
      End If;
    
      If n_Do = 1 Then
        Update zlDataMove Set 说明 = '正在重建索引:' || r.Index_Name Where 系统 = 100 And 组号 = 1;
      
        --v_Sql := 'Alter Index ' || r.Index_Name || ' shrink Space'; 
        --使用shrink方式不能并行执行,试验表明速度比rebuild PARALLEL 8 慢6倍 
        If Speedmode_In = 1 Then
          v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Nologging';
        Else
          v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Online Nologging';
        End If;
        Begin
          Execute Immediate v_Sql;
          --在线重建比较慢，不在线重建则需要锁表，如果有其他并发事务，则会出错：ORA-00054: 资源正忙, 但指定以 NOWAIT 方式获取资源 
        
        Exception
          When Others Then
            If SQLErrM Like 'ORA-00054%' Then
              v_Sql := Replace(v_Sql, 'Rebuild', 'Rebuild Online');
              Execute Immediate v_Sql;
            End If;
        End;
      End If;
    End Loop;
    v_Prompt := '重建标记转出所需索引';
  
    --重组表的数据
  Elsif Func_In = 7 Then
    --rebScope_in=0,只重组组号小于5的经济核算类表（费用、药品、票据），否则全部重组     
    For R In (Select a.表名 As Table_Name
              From zlBakTables A
              Where a.直接转出 = 1 And a.系统 = System_In And (组号 < Decode(Rebscope_In, 0, 5, 100))
              Order By 组号, 序号) Loop
    
      Update zlDataMove Set 说明 = '正在重组表:' || r.Table_Name Where 系统 = 100 And 组号 = 1;
    
      --如果有空闲的空间，最好移到其他表空间，只有这样才能绝对移动文件尾部的数据块，以便进行表空间文件的收缩 
      --在前面设置了会话级的强制并行 
      v_Sql := 'Alter Table ' || r.Table_Name || ' Move Nologging';
      Execute Immediate v_Sql;
    
      --单独移动Lob对象 
      For L In (Select Column_Name, Tablespace_Name From User_Lobs Where Table_Name = r.Table_Name) Loop
        v_Sql := 'Alter Table ' || r.Table_Name || ' Move Lob(' || l.Column_Name || ') Store as (Tablespace ' ||
                 l.Tablespace_Name || ') Nologging';
        Execute Immediate v_Sql;
      End Loop;
    
      v_Sql := 'Alter Table ' || r.Table_Name || ' Noparallel';
      Execute Immediate v_Sql;
    
      --move后，表相关的索引会全部失效，需要全部重建 
      For S In (Select Index_Name
                From User_Indexes
                Where Table_Name = r.Table_Name And Status = 'UNUSABLE'
                Order By Index_Name) Loop
      
        Update zlDataMove Set 说明 = '正在恢复失效索引:' || s.Index_Name Where 系统 = 100 And 组号 = 1;
      
        --在前面设置了会话级的强制并行 
        v_Sql := 'Alter Index ' || s.Index_Name || ' Rebuild Nologging';
        Execute Immediate v_Sql;
      End Loop;
    End Loop;
    v_Prompt := '重组表数据';
  
    --重建转出表上标记转出以外的其他索引（用于转出完成后收回空闲空间）
    --失效的索引不重建，因为转出完后有单独的重建功能
  Elsif Func_In = 8 Then
    For R In (Select b.Index_Name, a.组号
              From User_Indexes B, zlBakTables A
              Where a.表名 = b.Table_Name And a.系统 = System_In And b.Status = 'VALID' And b.Index_Type = 'NORMAL' And
                    b.Index_Name Not Like 'BIN$%' And
                    b.Index_Name Not In (Select Upper(索引名) From Zlbaktableindex Where 系统 = System_In)
              Order By Index_Name) Loop
    
      Update zlDataMove Set 说明 = '正在重建索引:' || r.Index_Name Where 系统 = 100 And 组号 = 1;
    
      If Speedmode_In = 1 Then
        v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Nologging';
      Else
        v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Online Nologging';
      End If;
      Begin
        Execute Immediate v_Sql;
        --在线重建比较慢，不在线重建则需要锁表，如果有其他并发事务，则会出错：ORA-00054: 资源正忙, 但指定以 NOWAIT 方式获取资源    
      Exception
        When Others Then
          If SQLErrM Like 'ORA-00054%' Then
            v_Sql := Replace(v_Sql, 'Rebuild', 'Rebuild Online');
            Execute Immediate v_Sql;
          End If;
      End;
    End Loop;
    v_Prompt := '重建标记转出以外的其他索引';
  End If;

  If Func_In In (5, 6, 7, 8) Or Func_In In (3, 4) And Enable_In = 1 Then
    Update zlDataMove
    Set 说明 = To_Char(Sysdate, 'mm-dd hh24:mi') || v_Prompt || ':' || Trunc((Sysdate - d_Curdate) * 24 * 60) || '分钟'
    Where 系统 = 100 And 组号 = 1;
  End If;

  --执行重建索引后会自动为索引加上并行度属性，如果不取消，会影响相关SQL的执行计划(全表扫描+并行查询，巨慢) 
  --------------------------------------------------------------------------------------------------- 
  If n_Parallel = 1 Then
    Execute Immediate 'ALTER Session DISABLE PARALLEL DDL';
  
    For R In (Select Index_Name From User_Indexes Where Degree Not In ('1', '0')) Loop
      v_Sql := 'Alter Index ' || r.Index_Name || ' Noparallel';
      Execute Immediate v_Sql;
    End Loop;
  End If;

  Commit;
  --本过程不进行错误处理，错误由调用过程处理 
End Zl1_Datamove_Reb;
/

--108964:李小东,2017-05-24,不同年龄段参考值提取
CREATE OR REPLACE Function Zl_Get_Reference
(
  Type_In       In Number, --0=参考 1=参考ID 2=危急参考 3=危急参考下限 4=危急参考上限
  项目id_In     In Number,
  标本类型_In   In Varchar2,
  性别_In       In Number,
  出生日期_In   In Date,
  仪器id_In     In Number := Null,
  年龄_In       In Varchar2 := Null,
  申请科室id_In In Number := Null
) Return Varchar2 As

  Cursor v_Reference_Type Is
    Select a.Id,
           Trim(To_Char(a.参考低值, c.格式)) || '～' || Trim(To_Char(a.参考高值, c.格式)) ||
            Decode(a.临床特征, Null, '', '成人', '', '婴儿', '', ' ' || a.临床特征) As 结果参考, b.结果类型, b.取值序列,
           Trim(To_Char(a.警示下限, c.格式)) || '～' || Trim(To_Char(a.警示上限, c.格式)) ||
            Decode(a.临床特征, Null, '', '成人', '', '婴儿', '', ' ' || a.临床特征) As 危急参考, a.警示下限, a.警示上限, Nvl(b.多参考, 0) 多参考
    From 检验项目参考 A, 检验项目 B,
         (Select '9999990' ||
                   Decode(Max(Nvl(c.小数位数, -1)), 0, '', -1, '.00', Substr('.000000', 1, 1 + Max(Nvl(c.小数位数, -1)))) As 格式



           From 检验仪器项目 C, 检验项目 D
           Where d.诊治项目id = 项目id_In And d.诊治项目id = c.项目id(+)) C
    Where a.项目id = 项目id_In And a.项目id = b.诊治项目id;

  v_Return Varchar2(4000);
  v_Sql    Varchar2(4000);

  Type c_Type Is Ref Cursor; --声明REF游标类型
  r_Emp v_Reference_Type%RowType; --声明一个行类型变量
  Cur   c_Type; --声明REF游标类型的变量

  v_结果类型 Number(1);

  v_年数     Number(18, 1);
  v_月数     Number(18, 1);
  v_日数     Number(18, 1);
  v_小时     Number(18, 1);
  v_出生日期 Date;
  v_Pos      Number(4);
  v_多参考   Number(4);
  v_Value    Number(18);
  v_Valuerec Varchar2(255);
  v_年龄     Varchar2(50);
  v_结果参考 Varchar2(1000);
  v_参考id   Number(18);
  v_危紧参考 Varchar2(1000);
  v_警示下限 Varchar2(1000);
  v_警示上限 Varchar2(1000);
  d_Sysdate  Date;

  v_项目id_Bound   检验项目参考.项目id%Type;
  v_标本类型_Bound 检验项目参考.标本类型%Type;
  v_性别域1_Bound  检验项目参考.性别域%Type;
  v_性别域2_Bound  检验项目参考.性别域%Type;
  v_性别域3_Bound  检验项目参考.性别域%Type;
  v_仪器id_Bound   检验项目参考.仪器id%Type;

  v_年龄单位日_Bound   检验项目参考.年龄单位%Type;
  v_年龄单位月_Bound   检验项目参考.年龄单位%Type;
  v_年龄单位小时_Bound 检验项目参考.年龄单位%Type;
  v_年龄单位年_Bound   检验项目参考.年龄单位%Type;

  v_年龄单位日1_Bound   检验项目参考.年龄单位%Type;
  v_年龄单位月1_Bound   检验项目参考.年龄单位%Type;
  v_年龄单位小时1_Bound 检验项目参考.年龄单位%Type;
  v_年龄单位年1_Bound   检验项目参考.年龄单位%Type;

  v_临床特征_Bound   检验项目参考.临床特征%Type;
  v_申请科室id_Bound 检验项目参考.申请科室id%Type;
  v_年龄_1           Varchar2(50);
  v_年龄_2           Varchar2(50);

  Function Sub_Is_Number(v_In In Varchar2) Return Boolean Is
    n_Tmp Number;
  Begin
    n_Tmp := To_Number(v_In);
    If n_Tmp Is Not Null Then
      Return True;
    Else
      Return False;
    End If;
  Exception
    When Others Then
      Return False;
  End Sub_Is_Number;

  Function Zlsplit
  (
    v_Str       In Varchar2,
    v_Delimiter In Varchar2,
    v_Number    In Number
  ) Return Varchar2 Is
    v_Record     Varchar2(1000);
    v_Currrecord Varchar2(1000);
    v_Currnum    Number;
  Begin
    v_Record  := v_Str || v_Delimiter;
    v_Currnum := 0;
    While v_Record Is Not Null Loop
      v_Currrecord := Substr(v_Record, 1, Instr(v_Record, v_Delimiter) - 1);
      If v_Currnum = v_Number Then
        Return(v_Currrecord);
      End If;

      v_Currnum := v_Currnum + 1;
      v_Record  := Replace(v_Delimiter || v_Record, v_Delimiter || v_Currrecord || v_Delimiter);
    End Loop;

    Return('');
  End Zlsplit;
  Function Zlval(Vstr In Varchar2) Return Number Is
    Result Number(16, 6);
    Intbit Number(8);
    Strnum Varchar(10);
  Begin
    Strnum := '';
    For Intbit In 1 .. 10 Loop
      If Instr('0123456789.', Substr(Vstr, Intbit, 1)) = 0 Then
        Exit;
      End If;
      Strnum := Strnum || Substr(Vstr, Intbit, 1);
      Null;
    End Loop;
    Result := To_Number(Strnum);
    Return(Result);
  End Zlval;

Begin
  d_Sysdate := Sysdate;

  v_Sql := ' Select a.id,Trim(To_Char(A.参考低值, C.格式)) || ''～'' || Trim(To_Char(A.参考高值, C.格式)) || ' ||
           ' Decode(A.临床特征, Null, '''', ''成人'', '''', ''婴儿'','''', '' '' || A.临床特征) As 结果参考, B.结果类型, B.取值序列, ' ||
           ' Trim(To_Char(A.警示下限, C.格式)) || ''～'' || Trim(To_Char(A.警示上限, C.格式)) || ' || ' Decode(A.临床特征, Null, '''', ''成人'', '''', ''婴儿'','''', '' '' || A.临床特征) As 危急参考,a.警示下限,a.警示上限,
             nvl(b.多参考,0) 多参考 ' || ' From 检验项目参考 A, 检验项目 B, ' || ' (Select ''9999990'' || ' ||
           ' Decode(Max(Nvl(C.小数位数, -1)), 0, '''', -1, ''.00'', Substr(''.000000'', 1, 1 + Max(Nvl(C.小数位数, -1)))) As 格式 ' ||
           ' From 检验仪器项目 C, 检验项目 D ' || ' Where D.诊治项目ID = :项目ID And D.诊治项目ID = C.项目ID(+)) C ' ||
           ' Where A.项目ID = :项目ID And A.项目ID = B.诊治项目ID ';

  v_项目id_Bound := 项目id_In;

  v_年龄 := 年龄_In;
  If v_年龄 = '岁' Then
    v_年龄 := Null;
  End If;

  If v_年龄 = '月' Then
    v_年龄 := Null;
  End If;

  If v_年龄 = '小时' Then
    v_年龄 := Null;
  End If;

  If v_年龄 = '天' Then
    v_年龄 := Null;
  End If;

  If Nvl(标本类型_In, '') <> '' Or 标本类型_In Is Not Null Then
    v_Sql := v_Sql || ' And A.标本类型 = :标本类型 ';
  Else
    v_Sql := v_Sql || ' And (A.标本类型 = :标本类型 or 1=1) ';
  End If;
  v_标本类型_Bound := 标本类型_In;

  If Nvl(性别_In, '') <> '' Or 性别_In Is Not Null Then
    --V_Sql := V_Sql || ' And A.性别域 = Nvl(' || 性别_In || ', 1) ';
    v_Sql := v_Sql || ' And decode(A.性别域,null,:性别,0,:性别,A.性别域) = Nvl(:性别, 1) ';

  Else
    v_Sql := v_Sql || ' And (decode(A.性别域,null,:性别1,0,:性别2,A.性别域) = Nvl(:性别3, 1) or 1 = 1) ';
  End If;
  v_性别域1_Bound := 性别_In;
  v_性别域2_Bound := 性别_In;
  v_性别域3_Bound := 性别_In;

  If Nvl(仪器id_In, '') <> '' Or 仪器id_In Is Not Null Then
    v_Sql := v_Sql || ' And (A.仪器id = :仪器ID Or A.仪器id Is Null) ';
  Else
    v_Sql := v_Sql || ' And (A.仪器id = :仪器ID Or A.仪器id Is Null or 1=1) ';
  End If;
  v_仪器id_Bound := 仪器id_In;

  If Nvl(v_年龄, '') <> '' Or v_年龄 Is Not Null Then
    If Instr(v_年龄, '岁') > 0 Or Instr(v_年龄, '月') > 0 Or Instr(v_年龄, '天') > 0 Or Instr(v_年龄, '小时') > 0 Or
       Sub_Is_Number(v_年龄) Then
      --处理日期
      v_出生日期 := 出生日期_In;
      v_年龄_1   := v_年龄;
      If Instr(v_年龄_1, '岁') > 0 Then
        v_年龄   := Substr(v_年龄_1, 1, Instr(v_年龄_1, '岁'));
        v_年龄_2 := Substr(v_年龄_1, Instr(v_年龄_1, '岁') + 1);
      Elsif Instr(v_年龄, '月') > 0 Then
        v_年龄   := Substr(v_年龄_1, 1, Instr(v_年龄_1, '月'));
        v_年龄_2 := Substr(v_年龄_1, Instr(v_年龄_1, '月') + 1);
      Elsif Instr(v_年龄, '天') > 0 Then
        v_年龄   := Substr(v_年龄_1, 1, Instr(v_年龄_1, '天'));
        v_年龄_2 := Substr(v_年龄_1, Instr(v_年龄_1, '天') + 1);
      Elsif Instr(v_年龄, '小时') > 0 Then
        v_年龄   := Substr(v_年龄_1, 1, Instr(v_年龄_1, '小时') + 1);
        v_年龄_2 := Substr(v_年龄_1, Instr(v_年龄_1, '小时') + 2);
        If v_年龄 = '0小时' Or v_年龄 = '0时' Then
          v_年龄 := ' ';
        End If;
      End If;
      If v_年龄 Is Not Null And (v_年龄 = '成人' Or v_年龄 = '婴儿' Or v_年龄 = '岁') = False Then
        If Substr(v_年龄, 1, 1) = '*' Then
          v_出生日期 := Add_Months(d_Sysdate, -216);
        Else
          If Substr(v_年龄, Length(v_年龄)) = '月' Then
            v_出生日期 := Add_Months(d_Sysdate, -1 * Nvl(Zlval(v_年龄), 0));
          Else
            If Substr(v_年龄, Length(v_年龄)) = '天' Then
              v_出生日期 := d_Sysdate - Nvl(Zlval(v_年龄), 0);
            Else
              If Substr(v_年龄, Length(v_年龄) - 1) = '小时' Then
                If Nvl(Zlval(v_年龄), 0) <> 0 Then
                  v_出生日期 := d_Sysdate - Nvl(Zlval(v_年龄), 0) / 24;
                End If;
              Else
                v_出生日期 := Add_Months(d_Sysdate, -12 * Nvl(Zlval(v_年龄), 0)) - 1;
              End If;
            End If;
          End If;
          If v_年龄_2 Is Not Null Then
            If Substr(v_年龄_2, Length(v_年龄_2)) = '月' Then
              v_出生日期 := Add_Months(v_出生日期, -1 * Nvl(Zlval(v_年龄_2), 0));
            Else
              If Substr(v_年龄_2, Length(v_年龄_2)) = '天' Then
                v_出生日期 := v_出生日期 - Nvl(Zlval(v_年龄_2), 0);
              Else
                If Substr(v_年龄_2, Length(v_年龄_2) - 1) = '小时' Then
                  If Nvl(Zlval(v_年龄_2), 0) <> 0 Then
                    v_出生日期 := v_出生日期 - Nvl(Zlval(v_年龄_2), 0) / 24;
                  End If;
                End If;
              End If;
            End If;
          End If;
        End If;
      End If;
      If Not (v_出生日期 Is Null) Then
        v_年数 := Round(Months_Between(d_Sysdate, v_出生日期) / 12 ,1);
        v_月数 := Round(Months_Between(d_Sysdate, v_出生日期) ,1);
        v_日数 := Round(d_Sysdate - v_出生日期 ,1);
        v_小时 := Round((d_Sysdate - (v_出生日期 - 1 / 24)) * 24 - 1);
      End If;
      v_Sql := v_Sql || 'And (Decode(A.年龄单位, ''日'',:日, ''月'',:月,''小时'',:小时,:年) ' ||
               ' Between Nvl(A.年龄下限, -9999) And Nvl(A.年龄上限, 9999) )';
    Else
      v_Sql := v_Sql || 'And (Decode(A.年龄单位, ''日'',:日, ''月'',:月,''小时'',:小时,:年) ' ||
               ' Between Nvl(A.年龄下限, -9999) And Nvl(A.年龄上限, 9999) or 1=1 )';
    End If;

  Else
    v_Sql := v_Sql || 'And (Decode(A.年龄单位, ''日'',:日, ''月'',:月,''小时'',:小时,:年) ' ||
             ' Between Nvl(A.年龄下限, -9999) And Nvl(A.年龄上限, 9999) or 1=1 )';
  End If;
  v_年龄单位日_Bound   := v_日数;
  v_年龄单位月_Bound   := v_月数;
  v_年龄单位小时_Bound := v_小时;
  v_年龄单位年_Bound   := v_年数;
  If Instr(v_年龄, '成人') > 0 Or Instr(v_年龄, '婴儿') > 0 Or Instr(v_年龄, '分钟') > 0 Then
    --处理成人和婴儿
    v_Sql := v_Sql || ' And A.临床特征 =:年龄';
  Else
    v_Sql := v_Sql || ' And (A.临床特征 =:年龄 or 1=1)';
    v_Sql := v_Sql || ' And instr(''婴儿,成人'',nvl(临床特征,'' '')) <= 0  ';
  End If;

  v_临床特征_Bound := Replace(v_年龄, '分钟', '婴儿');

  If Nvl(申请科室id_In, '') <> '' Or 申请科室id_In Is Not Null Then
    v_Sql := v_Sql || ' And (A.申请科室ID = :申请科室ID Or nvl(A.申请科室ID,0) = 0) ';
  Else
    v_Sql := v_Sql || ' And ((A.申请科室ID = :申请科室ID Or nvl(A.申请科室ID,0) = 0) or 1=1) ';
  End If;
  v_申请科室id_Bound := 申请科室id_In;

  If (Nvl(v_年龄, '') = '' Or v_年龄 Is Null) And (出生日期_In <> '' Or 出生日期_In Is Not Null) Then
    --按出生日期查询
    If Not (出生日期_In Is Null) Then
      v_年数 := Round(Months_Between(d_Sysdate, 出生日期_In) / 12 - 0.5);
      v_月数 := Round(Months_Between(d_Sysdate, 出生日期_In) - 0.5);
      v_日数 := Round(d_Sysdate - 出生日期_In - 0.5);
      v_小时 := Round((d_Sysdate - (出生日期_In - 1 / 24)) * 24 - 1);

      v_Sql := v_Sql || 'And (Decode(A.年龄单位, ''日'',:日, ''月'',:月,''小时'',:小时,:年) ' ||
               ' Between Nvl(A.年龄下限, -9999) And Nvl(A.年龄上限, 9999) )';
    Else
      v_Sql := v_Sql || 'And (Decode(A.年龄单位, ''日'',:日, ''月'',:月,''小时'',:小时,:年) ' ||
               ' Between Nvl(A.年龄下限, -9999) And Nvl(A.年龄上限, 9999) or 1=1 )';
    End If;

  Else
    v_Sql := v_Sql || 'And (Decode(A.年龄单位, ''日'',:日, ''月'',:月,''小时'',:小时,:年) ' ||
             ' Between Nvl(A.年龄下限, -9999) And Nvl(A.年龄上限, 9999) or 1=1 )';
  End If;
  v_年龄单位日1_Bound   := v_日数;
  v_年龄单位月1_Bound   := v_月数;
  v_年龄单位小时1_Bound := v_小时;
  v_年龄单位年1_Bound   := v_年数;

  --加上排序
  v_Sql := v_Sql || ' Order By a.默认 desc,A.临床特征 ';

  If Nvl(申请科室id_In, '') <> '' Or 申请科室id_In Is Not Null Then
    v_Sql := v_Sql || ' ,a.申请科室ID  ';
  End If;

  If Nvl(性别_In, '') <> '' Or 性别_In Is Not Null Then
    v_Sql := v_Sql || ' ,a.性别域 desc  ';
  Else
    v_Sql := v_Sql || ' ,a.性别域 ';
  End If;

  v_Sql := v_Sql || ' ,a.id ';

  v_Return := '';
  Open Cur For v_Sql
    Using v_项目id_Bound, v_项目id_Bound, v_标本类型_Bound, v_性别域1_Bound, v_性别域2_Bound, v_性别域3_Bound, v_仪器id_Bound, v_年龄单位日_Bound, v_年龄单位月_Bound, v_年龄单位小时_Bound, v_年龄单位年_Bound, v_临床特征_Bound, v_申请科室id_Bound, v_年龄单位日1_Bound, v_年龄单位月1_Bound, v_年龄单位小时1_Bound, v_年龄单位年1_Bound;

  Loop
    Fetch Cur
      Into r_Emp;
    Exit When Cur%NotFound;
    If Cur%RowCount > 0 Then

      v_结果类型 := r_Emp.结果类型;
      v_Valuerec := r_Emp.取值序列;
      v_参考id   := r_Emp.Id;
      v_多参考   := r_Emp.多参考;

      If Nvl(v_Return, '') = '' Or v_Return Is Null Then
        If Type_In = 2 Then
          v_Return := r_Emp.危急参考;
        Else
          v_Return := r_Emp.结果参考;
        End If;
      Else
        If Type_In = 2 Then
          v_Return := v_Return || Chr(13) || Chr(10) || r_Emp.危急参考;
        Else
          If v_多参考 = 1 Then
            v_Return := v_Return || Chr(13) || Chr(10) || r_Emp.结果参考;
          End If;
        End If;
      End If;

      --只增加第一个选出的警示参考
      If v_警示下限 = '' Or v_警示下限 Is Null Then
        v_警示下限 := r_Emp.警示下限;
      End If;
      If v_警示上限 = '' Or v_警示上限 Is Null Then
        v_警示上限 := r_Emp.警示上限;
      End If;
    End If;
  End Loop;

  If v_Return = '' Or v_Return Is Null Then
    Begin
      Select 结果参考, 结果类型, 取值序列, ID, 危急参考, 警示下限, 警示上限
      Into v_结果参考, v_结果类型, v_Valuerec, v_参考id, v_危紧参考, v_警示下限, v_警示上限
      From (Select a.Id,
                    Trim(To_Char(a.参考低值, c.格式)) || '～' || Trim(To_Char(a.参考高值, c.格式)) ||
                     Decode(a.临床特征, Null, '', '成人', '', '婴儿', '', ' ' || a.临床特征) As 结果参考, b.结果类型, b.取值序列,
                    Trim(To_Char(a.警示下限, c.格式)) || '～' || Trim(To_Char(a.警示上限, c.格式)) ||
                     Decode(a.临床特征, Null, '', '成人', '', '婴儿', '', ' ' || a.临床特征) As 危急参考, a.警示下限, a.警示上限
             From 检验项目参考 A, 检验项目 B,
                  (Select '9999990' ||
                            Decode(Max(Nvl(c.小数位数, -1)), 0, '', -1, '.00', Substr('.000000', 1, 1 + Max(Nvl(c.小数位数, -1)))) As 格式
                    From 检验仪器项目 C, 检验项目 D
                    Where d.诊治项目id = 项目id_In And d.诊治项目id = c.项目id(+)) C
             Where a.项目id = 项目id_In And a.项目id = b.诊治项目id
             Order By a.默认 Desc, a.临床特征, a.性别域)
      Where Rownum = 1;
      If Type_In = 2 Then
        v_Return := v_危紧参考;
      Else
        v_Return := v_结果参考;
      End If;
      --只增加第一个选出的警示参考
      If v_警示下限 = '' Or v_警示下限 Is Null Then
        v_警示下限 := r_Emp.警示下限;
      End If;
      If v_警示上限 = '' Or v_警示上限 Is Null Then
        v_警示上限 := r_Emp.警示上限;
      End If;
    Exception
      When Others Then
        v_Return := Null;
    End;
  End If;
  If v_Return <> '' Or v_Return Is Not Null Then

    If v_Return = '～' Then
      v_Return := '';
    Else
      If v_结果类型 = 2 Then
        v_Pos := Instr(v_Return, '～');

        Begin
          Select To_Number(Substr(v_Return, 1, v_Pos - 1)) Into v_Value From Dual;
        Exception
          When Others Then
            v_Value := 0;
        End;
        v_Return := Zlsplit(v_Valuerec, ';', v_Value);
      End If;
    End If;
    If Type_In = 0 Then
      Return v_Return;
    Elsif Type_In = 1 Then
      Return v_参考id;
    Elsif Type_In = 2 Then
      Return v_Return;
    Elsif Type_In = 3 Then
      Return v_警示下限;
    Elsif Type_In = 4 Then
      Return v_警示上限;
    End If;
  End If;
  Close Cur; --关闭游标
  Return v_Return;
End Zl_Get_Reference;
/

--107646:刘尔旋,2017-07-06,自动记帐模式
Create Or Replace Procedure Zl1_Autocptall(强制记帐_In In Number := 0) As

  v_期间           期间表.期间%Type; --需要计算的最小期间
  n_Modi_Last      Number(1); --是否修正上期自动计费参数
  n_记帐模式       Number(2);
  n_是否用价格等级 Number(2);

  Cursor c_Pati_Tab Is
    Select Distinct 病人id, 主页id
    From 在院病人自动记帐
    Where Trunc(终止日期) >= (Select Min(开始日期) From 期间表 Where 期间 >= v_期间);

  Cursor c_Pati Is
    Select Distinct a.病人id, a.主页id
    From 在院病人 A, 病人自动计算 C
    Where a.病人id = c.病人id And a.主页id = c.主页id And Nvl(c.上次计算时间, c.开始时间) <= Nvl(c.终止时间, Sysdate + 1) And
          Trunc(Nvl(c.终止时间, Sysdate)) >= (Select Min(开始日期) From 期间表 Where 期间 >= v_期间);
Begin

  If f_Is_Primary_Node = 0 Then
    Return;
  End If;

  Begin
    Select 期间 Into v_期间 From 期间表 Where Trunc(Sysdate) - 1 Between Trunc(开始日期) And Trunc(终止日期);
  Exception
    When Others Then
      Return;
  End;
  Select Nvl(Max(1), 0) Into n_是否用价格等级 From 收费价格等级应用 Where Rownum < 2;

  Select zl_GetSysParameter(7), Zl_To_Number(zl_GetSysParameter(278)) Into n_Modi_Last, n_记帐模式 From Dual;

  If n_Modi_Last = 1 Then
    v_期间 := To_Char(Add_Months(To_Date(v_期间 || '05', 'yyyymmdd'), -1), 'yyyymm');
  End If;
  If Nvl(n_记帐模式, 0) > 0 Then
    For r_Pati In c_Pati Loop
      If r_Pati.病人id Is Not Null And r_Pati.主页id Is Not Null Then
        If Nvl(n_记帐模式, 0) = 1 Then
          --1-内蒙片区独有的记帐模式
          Zl1_Autocalc_Pati_Charge_Nm(r_Pati.病人id, r_Pati.主页id, v_期间, 强制记帐_In, n_是否用价格等级);
        Else
          --2.标准记帐模式（临时）:目前试点用户才用，主要是根据病人自动计算表中取数来进行计算。需要一定时间监控后才能正常使用
          Zl1_Autocalc_Pati_Charge(r_Pati.病人id, r_Pati.主页id, v_期间, 强制记帐_In, n_是否用价格等级);
        End If;
        Commit;
      End If;
    End Loop;
  Else
    For r_Pati In c_Pati_Tab Loop
      If r_Pati.病人id Is Not Null And r_Pati.主页id Is Not Null Then
        Zl1_Autocptone(r_Pati.病人id, r_Pati.主页id, v_期间, 1, 强制记帐_In);
        Commit;
      End If;
    End Loop;
  End If;
End Zl1_Autocptall;
/

--107646:刘尔旋,2017-07-06,自动记帐模式
Create Or Replace Procedure Zl1_Autocptward
(
  病区id_In       In 部门表.Id%Type,
  上次计算时间_In In 病人变动记录.上次计算时间%Type := Null,
  强制记帐_In     In Number := 0
) As
  v_期间           期间表.期间%Type; --需要计算的最小期间
  n_Modi_Last      Number(1); --是否修正上期自动计费参数
  n_记帐模式       Number(2);
  n_是否用价格等级 Number(2);
  Cursor c_Patitab Is
    Select Distinct 病人id, 主页id
    From 在院病人自动记帐
    Where 病区id = 病区id_In And Trunc(终止日期) >= (Select Min(开始日期) From 期间表 Where 期间 >= v_期间);

  Cursor c_Pati Is
    Select Distinct a.病人id, a.主页id
    From 在院病人 A, 病人自动计算 C
    Where a.病区id = 病区id_In And a.病人id = c.病人id And a.主页id = c.主页id And
          Nvl(c.上次计算时间, c.开始时间) <= Nvl(c.终止时间, Sysdate + 1) And
          Trunc(Nvl(c.终止时间, Sysdate)) >= (Select Min(开始日期) From 期间表 Where 期间 >= v_期间);

Begin
  Begin
    Select 期间 Into v_期间 From 期间表 Where Trunc(Sysdate) - 1 Between Trunc(开始日期) And Trunc(终止日期);
  Exception
    When Others Then
      Return;
  End;
  Select zl_GetSysParameter(7), Zl_To_Number(zl_GetSysParameter(278)) Into n_Modi_Last, n_记帐模式 From Dual;

  If n_Modi_Last = 1 Then
    v_期间 := To_Char(Add_Months(To_Date(v_期间 || '05', 'yyyymmdd'), -1), 'yyyymm');
  End If;

  Select Nvl(Max(1), 0) Into n_是否用价格等级 From 收费价格等级应用 Where Rownum < 2;

  If 上次计算时间_In Is Not Null Then
    Update 病人变动记录
    Set 上次计算时间 = Null
    Where (病人id, 主页id) In (Select 病人id, 主页id From 病案主页 Where 当前病区id = 病区id_In And 出院日期 Is Null) And 上次计算时间 >= 上次计算时间_In;
  
    Update 病人自动计算
    Set 上次计算时间 = Null
    Where (病人id, 主页id) In (Select 病人id, 主页id From 病案主页 Where 当前病区id = 病区id_In And 出院日期 Is Null) And 上次计算时间 >= 上次计算时间_In;
    Commit;
  End If;
  If Nvl(n_记帐模式, 0) > 0 Then
    For r_Pati In c_Pati Loop
      If r_Pati.病人id Is Not Null And r_Pati.主页id Is Not Null Then
        If Nvl(n_记帐模式, 0) = 1 Then
          --1-内蒙片区独有的记帐模式
          Zl1_Autocalc_Pati_Charge_Nm(r_Pati.病人id, r_Pati.主页id, v_期间, 强制记帐_In, n_是否用价格等级);
        Else
          --2.标准记帐模式（临时）:目前试点用户才用，主要是根据病人自动计算表中取数来进行计算。需要一定时间监控后才能正常使用
          Zl1_Autocalc_Pati_Charge(r_Pati.病人id, r_Pati.主页id, v_期间, 强制记帐_In, n_是否用价格等级);
        End If;
        Commit;
      End If;
    End Loop;
  Else
    For r_Pati In c_Patitab Loop
      If r_Pati.病人id Is Not Null And r_Pati.主页id Is Not Null Then
        --0-标准记帐模式
        Zl1_Autocptone(r_Pati.病人id, r_Pati.主页id, v_期间, 1, 强制记帐_In);
        Commit;
      End If;
    End Loop;
  End If;
End Zl1_Autocptward;
/

--107646:刘尔旋,2017-07-06,自动记帐模式
Create Or Replace Procedure Zl1_Autocptpati
(
  病人id_In       In 病案主页.病人id%Type,
  主页id_In       In 病案主页.主页id%Type,
  上次计算时间_In In 病人变动记录.上次计算时间%Type := Null,
  强制记帐_In     In Number := 0,
  启用价格等级_In In Number := -1
) As
  --参数: 启用价格等级_In number ：-1表示未判断价格等级,内部会自动去检查;0-不启用价格等级;1-启用了价格等级的
  n_Modi_Last Number(1); --是否修正上期自动计费参数
  v_期间      Varchar2(6); --需要计算的最小期间
  n_记帐模式  Number(2);

Begin
  Begin
    Select 期间 Into v_期间 From 期间表 Where Trunc(Sysdate) Between Trunc(开始日期) And Trunc(终止日期);
  Exception
    When Others Then
      Return;
  End;
  Select Zl_To_Number(zl_GetSysParameter(7)), Zl_To_Number(zl_GetSysParameter(278))
  Into n_Modi_Last, n_记帐模式
  From Dual;

  If n_Modi_Last = 1 Then
    v_期间 := To_Char(Add_Months(To_Date(v_期间 || '05', 'yyyymmdd'), -1), 'yyyymm');
  End If;

  If 上次计算时间_In Is Not Null Then
    Update 病人变动记录
    Set 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 上次计算时间 >= 上次计算时间_In;
  
    Update 病人自动计算
    Set 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 上次计算时间 >= 上次计算时间_In;
  
    Commit;
  End If;
  If Nvl(n_记帐模式, 0) = 0 Then
    --0-标准记帐模式
    Zl1_Autocptone(病人id_In, 主页id_In, v_期间, 0, 强制记帐_In);
  Elsif Nvl(n_记帐模式, 0) = 1 Then
    --1-内蒙片区独有的记帐模式
    Zl1_Autocalc_Pati_Charge_Nm(病人id_In, 主页id_In, v_期间, 强制记帐_In, 启用价格等级_In);
  Else
    --2.标准记帐模式（临时）:目前试点用户才用，主要是根据病人自动计算表中取数来进行计算。需要一定时间监控后才能正常使用
    Zl1_Autocalc_Pati_Charge(病人id_In, 主页id_In, v_期间, 强制记帐_In, 启用价格等级_In);
  End If;
  Commit;
End Zl1_Autocptpati;
/

--107646:刘尔旋,2017-07-10,自动记帐模式
Create Or Replace Procedure Zl1_Autocalc_Pati_Charge
(
  病人id_In       In Number,
  主页id_In       In Number,
  期间_In         In Varchar2,
  强制记帐_In     In Number := 0,
  启用价格等级_In In Number := -1
) As
  -------------------------------------------------------------------------
  --功能说明：完成指定病人指定期间的自动记帐
  --          1、系统首先根据系统参数"修正上期自动计费"，修改以往该病人自动记帐记录标志;
  --          2、综合病人的床位变化、入出转情况、调价情况等多项因素，结合期间跨度、病人费
  --             别等完成费用的正确计算：
  --             如果发现已经计算，则修改标志为正常;如果未计算，则插入新的自动记帐记录;
  --             作废以前的错误计算的记录;
  --             统计本次变动(新增和作废)，填写余额表和汇总表;
  --入口参数：
  --       病人ID_IN  number    病人身份ID
  --       主页ID_IN  number    病案主页ID，两个参数共同确定需要计算的病人
  --       期间_IN  varchar2     需要计算的最小期间
  --       强制记帐_IN number   为1时,不受病案主页.禁止自动记帐属性控制
  --       启用价格等级_In number ：-1表示未判断价格等级,内部会自动去检查;0-不启用价格等级;1-启用了价格等级的
  --调用关系：zl1_AutoCptPati/zl1_AutoCptWard/zl1_AutoCptAll 调用本过程
  -------------------------------------------------------------------------
  v_价格等级         收费价格等级.名称%Type;
  v_站点_Pre         收费价格等级.名称%Type;
  v_付款方式价格等级 收费价格等级.名称%Type;

  v_Temp      Varchar2(500);
  v_Billno    Varchar2(8); --费用表实际的自动记帐号码
  n_Billcount Number(5) := 0; --单据序号计数器

  n_Exsetax  Number(16, 2) := 0; --费用收取比率
  n_Summoney Number(16, 2) := 0; --金额

  n_Dec        Number; --金额小数位数
  n_Dates      Number(3, 1); --当前记录的天数，全天为1
  n_Delete     Number;
  n_返回值     病人余额.预交余额%Type;
  n_收费细目id 收费项目目录.Id%Type;

  n_住院状态       病案主页.状态%Type;
  n_病人审核方式   Number(2);
  n_未入科禁止记账 Number(2);

  n_床位半天模式 Number(2);
  n_护理半天模式 Number(2);
  n_其他半天模式 Number(2);

  n_床位价格优先   Number(2);
  n_护理价格优先   Number(2);
  n_其他项价格优先 Number(2);
  n_是否用价格等级 Number(2); --0-未启用;1-启用
  n_是否计算费用   Number(2);
  n_类型           Number(2); --1-护理;2- 床位;3-其他
  n_Finded         Number(2);

  d_Start_Date Date;
  d_登记时间   Date; --登记时间
  d_发生时间   Date; --发生时间
  d_Temp       Date;

  l_Mulit_细目id t_Numlist := t_Numlist();

  Type t_病人变动_Rec Is Record(
    ID         病人变动记录.Id%Type,
    开始时间   病人变动记录.开始时间%Type,
    终止时间   病人变动记录.开始时间%Type,
    科室id     病人变动记录.科室id%Type,
    病区id     病人变动记录.病区id%Type,
    经治医师   病人变动记录.经治医师%Type,
    责任护士   病人变动记录.责任护士%Type,
    医疗小组id 病人变动记录.医疗小组id%Type);

  Type c_病人变动_Rec Is Table Of t_病人变动_Rec;
  r_病人变动 c_病人变动_Rec := c_病人变动_Rec();
  r_变动_Cur c_病人变动_Rec := c_病人变动_Rec();

  Cursor c_Sumcur_Rec
  (
    Billno    Varchar2,
    Datestart Date
  ) Is
    Select 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, Sum(Decode(附加标志, 0, 1, -1) * 应收金额) As 应收金额,
           Sum(Decode(附加标志, 0, 1, -1) * 实收金额) As 实收金额
    From 住院费用记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And
          (NO = Billno Or 附加标志 = 5 And 发生时间 >= Datestart)
    Group By 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id;

  n_收入项目id 收入项目.Id%Type;
  v_收据费目   收入项目.收据费目%Type;
  v_计算单位   收费项目目录.计算单位%Type;
  v_类别       收费项目目录.类别%Type;
  n_标准价格   收费价目.现价%Type;

  n_算法     保险支付大类.算法%Type;
  n_统筹比额 保险支付大类.统筹比额%Type;

  Type t_价格_Rec Is Ref Cursor;
  c_价格_Rec t_价格_Rec;

  Cursor c_Pati Is
    Select a.病人id, a.主页id, Nvl(a.姓名, i.姓名) As 姓名, Nvl(a.性别, i.性别) As 性别, Nvl(a.年龄, i.年龄) As 年龄, Nvl(a.住院号, i.住院号) As 住院号,
           a.费别, Nvl(a.险类, 0) As 险类, Nvl(a.审核标志, 0) As 审核标志, Nvl(a.状态, 0) As 住院状态, Nvl(a.是否禁止自动记帐, 0) As 是否禁止自动记帐,
           a.医疗付款方式 As 付款方式
    From 病案主页 A, 病人信息 I
    Where a.病人id = i.病人id And a.病人id = 病人id_In And a.主页id = 主页id_In;

  r_Pati c_Pati%RowType;

  Function Get_Discount_Rate
  (
    费别_In       病人信息.费别%Type,
    收费细目id_In 费别明细.收费细目id%Type,
    收入项目id_In 费别明细.收入项目id%Type,
    金额_In       费别明细.应收段首值%Type
  ) Return Number As
    n_Discount_Rate Number(16, 5);
  Begin
    Begin
      Select 实收比率
      Into n_Discount_Rate
      From (Select 实收比率
             From 费别明细
             Where 费别 = Nvl(费别_In, '-') And 收费细目id = Nvl(收费细目id_In, 0) And (金额_In Between 应收段首值 And 应收段尾值)
             Union All
             Select 实收比率
             From 费别明细
             Where 费别 = Nvl(费别_In, '-') And 收入项目id = Nvl(收入项目id_In, 0) And (金额_In Between 应收段首值 And 应收段尾值) And Not Exists
              (Select 1 From 费别明细 Where 费别 = Nvl(费别_In, '-') And 收费细目id = Nvl(收费细目id_In, 0)));
    Exception
      When Others Then
        n_Discount_Rate := 100.00;
    End;
    n_Discount_Rate := Nvl(n_Discount_Rate, 100);
    Return n_Discount_Rate;
  End Get_Discount_Rate;

Begin

  --获取病人信息
  Begin
    Open c_Pati;
    Fetch c_Pati
      Into r_Pati;
  Exception
    When Others Then
      Return;
  End;
  If Nvl(强制记帐_In, 0) = 0 And Nvl(r_Pati.是否禁止自动记帐, 0) = 1 Then
    Return;
  End If;

  n_病人审核方式   := Nvl(zl_GetSysParameter(185), 0);
  n_未入科禁止记账 := Nvl(zl_GetSysParameter(215), 0);

  If n_病人审核方式 = 1 And Nvl(r_Pati.审核标志, 0) >= 1 Then
    Return;
  End If;

  If n_未入科禁止记账 = 1 And n_住院状态 = 1 Then
    Return;
  End If;

  --------------------------------------------------------------------------------
  --1.初始化相关的参数
  n_床位半天模式 := 1;
  n_护理半天模式 := 1;
  n_其他半天模式 := 1;

  n_床位价格优先   := 0;
  n_其他项价格优先 := 0;

  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')), Zl_To_Number(Nvl(zl_GetSysParameter(160), '0'))
  Into n_Dec, n_护理价格优先
  From Dual;

  n_是否用价格等级 := 启用价格等级_In;
  If n_是否用价格等级 < 0 Then
    Select Nvl(Max(1), 0) Into n_是否用价格等级 From 收费价格等级应用 Where Rownum < 2;
  End If;
  --每天5点以前，将记录时间登记为昨天，否则登记为当时
  Select Decode(Sign(To_Number(To_Char(Sysdate, 'HH24')) - 5), -1, Trunc(Sysdate) - 1 / 24 / 60, Sysdate)
  Into d_登记时间
  From Dual;

  v_付款方式价格等级 := Null;
  If Nvl(n_是否用价格等级, 0) = 1 Then
    Select Max(价格等级)
    Into v_付款方式价格等级
    From 收费价格等级应用 A, 收费价格等级 B
    Where a.价格等级 = b.名称 And a.性质 = 1 And a.医疗付款方式 = Nvl(r_Pati.付款方式, '-') And Nvl(b.是否适用普通项目, 0) = 1 And
          Nvl(b.撤档时间, Sysdate + 1) > Sysdate;
  End If;
  --------------------------------------------------------------------------------

  --锁定该病人的记录,以免重复计算
  Update 病案主页 Set 状态 = 状态 Where 病人id = 病人id_In And 主页id = 主页id_In;

  --------------------------------------------------------------------------------
  --2. 先将变动信息给记录集,以便提取经治医师和责任护士
  For c_变动 In (Select ID, 开始时间, 终止时间, 科室id, 病区id, 经治医师, 责任护士, 医疗小组id
               From 病人变动记录 A
               Where 病人id = 病人id_In And 主页id = 主页id_In And 科室id Is Not Null And
                     Nvl(终止时间, Sysdate) >= (Select Nvl(Min(上次计算时间), Sysdate - 1000)
                                            From 病人自动计算
                                            Where 病人id = 病人id_In And 主页id = 主页id_In)
               Order By 病区id, 科室id, 开始时间 Desc) Loop
    r_病人变动.Extend;
    r_病人变动(r_病人变动.Count).Id := c_变动.Id;
    r_病人变动(r_病人变动.Count).开始时间 := c_变动.开始时间;
    r_病人变动(r_病人变动.Count).终止时间 := c_变动.终止时间;
    r_病人变动(r_病人变动.Count).科室id := c_变动.科室id;
    r_病人变动(r_病人变动.Count).病区id := c_变动.病区id;
    r_病人变动(r_病人变动.Count).经治医师 := c_变动.经治医师;
    r_病人变动(r_病人变动.Count).责任护士 := c_变动.责任护士;
    r_病人变动(r_病人变动.Count).医疗小组id := c_变动.医疗小组id;
  End Loop;

  -----------------------------------------------------------------
  --循环检查计算情况，并增加正确和新计算的记录
  -----------------------------------------------------------------
  d_Start_Date := Sysdate + 1000;
  d_Temp       := Sysdate - 1000;

  --1.计算床位费
  For c_自动记帐 In (Select a.类型, a.病人id, a.主页id, a.科室id, a.病区id, a.床号, a.附加床位, a.收费细目id, a.操作员编号, a.操作员姓名, a.开始时间, a.终止时间,
                        a.启用日期, a.数量, Greatest(a.开始日期, Trunc(p.开始日期)) As 开始日期, a.终止日期, a.天数, Nvl(Q1.站点, Q2.站点) As 站点,
                        m.计算单位, m.类别, i.险类, i.大类id, k.算法, k.统筹比额,
                        Nvl(m.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) As 项目撤档时间, a.计算标志
                 From (Select 2 As 类型, b.病人id, b.主页id, b.科室id, b.病区id, b.床号, b.附加床位, b.床位等级id As 收费细目id, b.操作员编号, b.操作员姓名,
                               b.开始时间, b.终止时间, a.启用日期, b.数量, Zl_Date_Half(b.开始时间, n_床位半天模式) As 开始日期,
                               Zl_Date_Half(b.终止时间, n_床位半天模式) As 终止日期, Trunc(Nvl(b.终止时间, Sysdate)) - Trunc(b.开始时间) As 天数,
                               0 As 计算标志
                        From 自动计价项目 A,
                             (Select a.Id, a.病人id, a.主页id, a.开始时间, a.附加床位, a.病区id, a.科室id, a.床号, a.床位等级id, 1 As 数量, a.终止时间,
                                      a.操作员编号, a.操作员姓名, a.上次计算时间
                               From 病人自动计算 A
                               Where a.性质 = 2 And a.病人id = 病人id_In And a.主页id = 主页id_In And Nvl(a.上次计算时间, a.开始时间) <= a.终止时间
                               Union All
                               Select b.Id, b.病人id, b.主页id, 开始时间, 附加床位, b.病区id, b.科室id, 床号, i.从项id As 床位等级id, i.从项数次 As 数量,
                                      b.终止时间, b.操作员编号, b.操作员姓名, b.上次计算时间
                               From 病人自动计算 B, 收费从属项目 I
                               Where b.性质 = 2 And b.病人id = 病人id_In And b.主页id = 主页id_In And b.床位等级id = i.主项id And i.固有从属 > 0 And
                                     Nvl(b.上次计算时间, b.开始时间) <= b.终止时间) B
                        Where a.病区id = b.病区id And a.计算标志 = 1
                        Union All
                        Select 1 As 类型, b.病人id, b.主页id, b.科室id, b.病区id, b.床号, b.附加床位, b.护理等级id As 收费细目id, b.操作员编号, b.操作员姓名,
                               b.开始时间, b.终止时间, a.启用日期, b.数量, Zl_Date_Half(b.开始时间, n_护理半天模式) As 开始日期,
                               Zl_Date_Half(b.终止时间, n_护理半天模式) As 终止日期, Trunc(Nvl(b.终止时间, Sysdate)) - Trunc(b.开始时间) As 天数,
                               0 As 计算标志
                        From 自动计价项目 A,
                             (Select a.Id, a.病人id, a.主页id, a.开始时间, a.附加床位, a.病区id, a.科室id, a.床号, a.护理等级id, 1 As 数量, a.终止时间,
                                      a.操作员编号, a.操作员姓名, a.上次计算时间
                               From 病人自动计算 A
                               Where a.性质 = 1 And a.病人id = 病人id_In And a.主页id = 主页id_In And Nvl(a.上次计算时间, a.开始时间) <= a.终止时间
                               Union All
                               Select b.Id, b.病人id, b.主页id, 开始时间, 附加床位, b.病区id, b.科室id, 床号, i.从项id As 床位等级id, i.从项数次 As 数量,
                                      b.终止时间, b.操作员编号, b.操作员姓名, b.上次计算时间
                               From 病人自动计算 B, 收费从属项目 I
                               Where b.性质 = 1 And b.病人id = 病人id_In And b.主页id = 主页id_In And b.护理等级id = i.主项id And i.固有从属 > 0 And
                                     Nvl(b.上次计算时间, b.开始时间) <= b.终止时间) B
                        Where a.病区id = b.病区id And a.计算标志 = 1
                        Union All
                        Select 3 As 类型, b.病人id, b.主页id, b.科室id, b.病区id, b.床号, b.附加床位, a.收费细目id, b.操作员编号, b.操作员姓名, b.开始时间,
                               b.终止时间, a.启用日期, a.数量, Zl_Date_Half(b.开始时间, n_其他半天模式) As 开始日期,
                               Zl_Date_Half(b.终止时间, n_其他半天模式) As 终止日期, Trunc(Nvl(b.终止时间, Sysdate)) - Trunc(b.开始时间) As 天数,
                               a.计算标志
                        From (Select 病区id, 计算标志, 收费细目id, 1 As 数量, 启用日期
                               From 自动计价项目
                               Union All
                               Select 病区id, 计算标志, 从项id, i.从项数次 As 数量, 启用日期
                               From 自动计价项目 A, 收费从属项目 I
                               Where a.收费细目id = i.主项id And i.固有从属 > 0) A, 病人自动计算 B
                        Where a.病区id = b.病区id And a.计算标志 = 1 And b.病人id = 病人id_In And b.主页id = 主页id_In And b.性质 = 3 And
                              (a.计算标志 = 6 And b.床位等级id Is Not Null Or a.计算标志 = 7) And Nvl(b.上次计算时间, b.开始时间) <= b.终止时间) A,
                      (Select Min(开始日期) As 开始日期 From 期间表 Where 期间 >= 期间_In) P, 保险支付项目 I, 保险支付大类 K, 收费项目目录 M, 部门表 Q1,
                      部门表 Q2
                 Where Trunc(a.终止时间) >= Trunc(p.开始日期) And a.收费细目id = i.收费细目id(+) And i.险类(+) = Nvl(r_Pati.险类, 0) And
                       i.大类id = k.Id(+) And a.收费细目id = m.Id And a.病区id = Q1.Id(+) And a.科室id = Q2.Id(+)
                 Order By 类型, 开始时间) Loop
    --产生数据
    If v_付款方式价格等级 Is Null Then
      If Nvl(n_是否用价格等级, 0) = 1 And Nvl(v_站点_Pre, '-') <> Nvl(c_自动记帐.站点, '-') Then
        v_Temp     := Nvl(Zl_Get_Pricegrade(c_自动记帐.站点, 病人id_In, 主页id_In, r_Pati.付款方式), '|||') || '||||';
        v_价格等级 := Substr(v_Temp, 1, Instr(v_Temp, '|') - 1);
      End If;
    Else
      v_价格等级 := v_付款方式价格等级;
    End If;
  
    If d_Start_Date > c_自动记帐.开始日期 Then
      d_Start_Date := c_自动记帐.开始日期;
    End If;
  
    Update 住院费用记录
    Set 附加标志 = 5
    Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And 附加标志 <> 8 And Nvl(医嘱序号, 0) = 0 And
          发生时间 >= c_自动记帐.开始日期 And 收费细目id = c_自动记帐.收费细目id And 附加标志 <> 5;
  
    --生成每天费用
    For I In 0 .. c_自动记帐.天数 Loop
      d_发生时间 := Greatest(c_自动记帐.开始日期, Trunc(c_自动记帐.开始日期 + I));
      n_Dates    := Least(Trunc(c_自动记帐.开始日期 + I + 1), c_自动记帐.终止日期) - Greatest(c_自动记帐.开始日期, Trunc(c_自动记帐.开始日期 + I));
    
      If (n_护理价格优先 = 1 And c_自动记帐.类型 = 1) Or (n_床位价格优先 = 1 And c_自动记帐.类型 = 2) Or (n_其他项价格优先 = 1 And c_自动记帐.类型 = 3) Then
      
        If d_发生时间 <> d_Temp Or Nvl(n_类型, 0) <> Nvl(c_自动记帐.类型, 0) Then
          l_Mulit_细目id.Delete;
          d_Temp := d_发生时间;
          n_类型 := Nvl(c_自动记帐.类型, 0);
        End If;
      
        n_Finded := 0;
        For J In 1 .. l_Mulit_细目id.Count Loop
          If l_Mulit_细目id(J) = c_自动记帐.收费细目id Then
            n_Finded := 1;
            Exit;
          End If;
        End Loop;
        If n_Finded = 0 Then
          l_Mulit_细目id.Extend;
          l_Mulit_细目id(l_Mulit_细目id.Count) := c_自动记帐.收费细目id;
        End If;
      End If;
    
      n_是否计算费用 := 1;
      If d_发生时间 > c_自动记帐.项目撤档时间 Or n_Dates = 0 Then
        n_是否计算费用 := 0;
      End If;
    
      If n_是否计算费用 = 1 Then
        --需要检查是否在指定日期被停用了的
        n_收费细目id := c_自动记帐.收费细目id;
        n_算法       := c_自动记帐.算法;
        n_统筹比额   := c_自动记帐.统筹比额;
      
        If (n_护理价格优先 = 1 And c_自动记帐.类型 = 1) Or (n_床位价格优先 = 1 And c_自动记帐.类型 = 2) Or
           (n_其他项价格优先 = 1 And c_自动记帐.类型 = 3) And l_Mulit_细目id.Count > 1 Then
          --取最高价格的收费项目
          If v_价格等级 Is Null Then
            Open c_价格_Rec For
              Select b.收费细目id, Sum(b.现价) As 标准单价
              From 收费价目 B, 收入项目 C
              Where b.收费细目id In (Select Column_Value From Table(l_Mulit_细目id)) And b.收入项目id = c.Id And
                    (c.撤档时间 Is Null Or c.撤档时间 > d_发生时间) And Trunc(d_发生时间) Between Trunc(b.执行日期) And
                    Nvl(b.终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')) And b.价格等级 Is Null
              
              Group By 收费细目id
              Order By 标准单价 Desc;
          Else
            Open c_价格_Rec For
              Select b.收费细目id, Sum(b.现价) As 标准单价
              From 收费价目 B, 收入项目 C
              Where b.收费细目id In (Select Column_Value From Table(l_Mulit_细目id)) And b.收入项目id = c.Id And
                    (c.撤档时间 Is Null Or c.撤档时间 > d_发生时间) And Trunc(d_发生时间) Between Trunc(b.执行日期) And
                    Nvl(b.终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')) And
                    (b.价格等级 = Nvl(v_价格等级, '-') Or
                    (b.价格等级 Is Null And Not Exists
                     (Select 1
                       From 收费价目
                       Where 收费细目id = b.收费细目id And 价格等级 = Nvl(v_价格等级, '-') And Trunc(d_发生时间) Between Trunc(执行日期) And
                             Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')))))
              Group By 收费细目id
              Order By 标准单价 Desc;
          End If;
        
          Begin
            Fetch c_价格_Rec
              Into n_收费细目id, n_标准价格;
          Exception
            When Others Then
              n_收费细目id := c_自动记帐.收费细目id;
          End;
          Close c_价格_Rec;
        End If;
        If c_自动记帐.收费细目id <> n_收费细目id Then
          --最高价格的收费细目不对，可能统筹比额不一样
          Select Max(k.算法), Max(k.统筹比额)
          Into n_算法, n_统筹比额
          From 保险支付项目 I, 保险支付大类 K
          Where i.收费细目id = n_收费细目id And i.险类(+) = Nvl(r_Pati.险类, 0) And i.大类id = k.Id(+);
        End If;
      End If;
    
      If n_是否计算费用 = 1 Then
        If v_价格等级 Is Null Then
          Open c_价格_Rec For
            Select b.现价 As 标准单价, b.收入项目id, c.收据费目, m.计算单位, m.类别
            From 收费价目 B, 收入项目 C, 收费项目目录 M
            Where b.收费细目id = m.Id And b.收费细目id = n_收费细目id And b.收入项目id = c.Id And (c.撤档时间 Is Null Or c.撤档时间 > d_发生时间) And
                  Trunc(d_发生时间) Between Trunc(b.执行日期) And Nvl(b.终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')) And
                  b.价格等级 Is Null;
        Else
          Open c_价格_Rec For
            Select b.现价 As 标准单价, b.收入项目id, c.收据费目, m.计算单位, m.类别
            From 收费价目 B, 收入项目 C, 收费项目目录 M
            Where b.收费细目id = m.Id And b.收费细目id = n_收费细目id And b.收入项目id = c.Id And (c.撤档时间 Is Null Or c.撤档时间 > d_发生时间) And
                  Trunc(d_发生时间) Between Trunc(b.执行日期) And Nvl(b.终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')) And
                  (b.价格等级 = v_价格等级 Or
                  (b.价格等级 Is Null And Not Exists
                   (Select 1
                     From 收费价目
                     Where 收费细目id = n_收费细目id And 价格等级 = Nvl(v_价格等级, '-') And Trunc(d_发生时间) Between Trunc(执行日期) And
                           Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')))));
        End If;
      
        Loop
          Fetch c_价格_Rec
            Into n_标准价格, n_收入项目id, v_收据费目, v_计算单位, v_类别;
          Exit When c_价格_Rec%NotFound;
          --For c_价格 In c_价格_Rec(n_收费细目id, d_发生时间, v_价格等级) Loop
          --提取当前收入项目的收费比率
          n_Exsetax := Get_Discount_Rate(r_Pati.费别, n_收费细目id, n_收入项目id, Abs(n_标准价格 * c_自动记帐.数量));
        
          --如果已经计算，原记录计算完全正确，则直接修改将标志改正
          Update 住院费用记录
          Set 附加标志 = 0
          Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And Nvl(加班标志, 0) = c_自动记帐.附加床位 And
                病人科室id = c_自动记帐.科室id And 病人病区id = Nvl(c_自动记帐.病区id, 0) And Nvl(床号, 0) = Nvl(c_自动记帐.床号, 0) And
                收费细目id = n_收费细目id And 收入项目id = n_收入项目id And 发生时间 = d_发生时间 And 数次 = c_自动记帐.数量 * n_Dates And
                标准单价 = n_标准价格 And 应收金额 = Round(n_标准价格 * c_自动记帐.数量 * n_Dates, n_Dec) And
                实收金额 = Round(n_标准价格 * c_自动记帐.数量 * n_Dates * n_Exsetax / 100, n_Dec);
        
          If Sql%RowCount = 0 Then
            --如果未计算或计算错误，则增加正确的计算记录
            r_变动_Cur.Delete;
            r_变动_Cur.Extend;
            For Q In 1 .. r_病人变动.Count Loop
              If r_病人变动(Q).病区id = c_自动记帐.病区id And r_病人变动(Q).科室id = c_自动记帐.科室id And
                  d_发生时间 Between Zl_Date_Half(r_病人变动(Q).开始时间, n_床位半天模式) And r_病人变动(Q).终止时间 Then
                r_变动_Cur(r_变动_Cur.Count).Id := r_病人变动(Q).Id;
                r_变动_Cur(r_变动_Cur.Count).开始时间 := r_病人变动(Q).开始时间;
                r_变动_Cur(r_变动_Cur.Count).终止时间 := r_病人变动(Q).终止时间;
                r_变动_Cur(r_变动_Cur.Count).科室id := r_病人变动(Q).科室id;
                r_变动_Cur(r_变动_Cur.Count).病区id := r_病人变动(Q).病区id;
                r_变动_Cur(r_变动_Cur.Count).经治医师 := r_病人变动(Q).经治医师;
                r_变动_Cur(r_变动_Cur.Count).责任护士 := r_病人变动(Q).责任护士;
                r_变动_Cur(r_变动_Cur.Count).医疗小组id := r_病人变动(Q).医疗小组id;
                Exit;
              End If;
            End Loop;
          
            If v_Billno Is Null Then
              v_Billno := Nextno(17);
            End If;
            Insert Into 住院费用记录
              (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 医嘱序号, 门诊标志, 病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 姓名, 性别,
               年龄, 标识号, 床号, 费别, 记帐费用, 收费细目id, 收入项目id, 附加标志, 标准单价, 付数, 数次, 应收金额, 实收金额, 收费类别, 计算单位, 加班标志, 收据费目, 开单人, 划价人,
               操作员编号, 操作员姓名, 发生时间, 登记时间, 保险项目否, 保险大类id, 统筹金额, 医疗小组id)
              Select 病人费用记录_Id.Nextval, 3, v_Billno, 1, Rownum + n_Billcount, Null, Null, 0, Null,
                     Decode(c_自动记帐.主页id, Null, 1, 2), c_自动记帐.病人id, c_自动记帐.主页id, c_自动记帐.病区id, c_自动记帐.科室id, c_自动记帐.科室id,
                     c_自动记帐.病区id, r_Pati.姓名, r_Pati.性别, r_Pati.年龄, r_Pati.住院号, c_自动记帐.床号, r_Pati.费别, 1, n_收费细目id,
                     n_收入项目id, 0, n_标准价格, 1, c_自动记帐.数量 * n_Dates, Round(n_标准价格 * c_自动记帐.数量 * n_Dates, n_Dec),
                     Round(n_标准价格 * c_自动记帐.数量 * n_Dates * n_Exsetax / 100, n_Dec), v_类别, v_计算单位, c_自动记帐.附加床位, v_收据费目,
                     r_变动_Cur(1).经治医师,r_变动_Cur(1).责任护士, c_自动记帐.操作员编号, c_自动记帐.操作员姓名, d_发生时间, d_登记时间,
                     Decode(c_自动记帐.险类, Null, 0, 1), c_自动记帐.大类id,
                     Decode(Nvl(n_算法, 0), 1, Round(n_标准价格 * c_自动记帐.数量 * n_Dates * n_Exsetax / 100 * n_统筹比额 / 100, n_Dec),
                             2, n_统筹比额, 0),r_变动_Cur(1).医疗小组id
              From Dual;
            n_Billcount := n_Billcount + Sql%RowCount;
          End If;
        End Loop;
        Close c_价格_Rec;
      End If;
    End Loop;
  End Loop;

  -----------------------------------------------------------------
  --作废以前计算的错误记录
  -----------------------------------------------------------------
  Insert Into 住院费用记录
    (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 医嘱序号, 门诊标志, 病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 姓名, 性别, 年龄, 标识号,
     床号, 费别, 记帐费用, 收费细目id, 收入项目id, 附加标志, 标准单价, 付数, 数次, 应收金额, 实收金额, 收费类别, 计算单位, 加班标志, 收据费目, 开单人, 划价人, 操作员编号, 操作员姓名, 发生时间,
     登记时间, 保险项目否, 保险大类id, 统筹金额, 医疗小组id)
    Select 病人费用记录_Id.Nextval, 记录性质, NO, 2, 序号, 从属父号, 价格父号, 多病人单, 医嘱序号, 门诊标志, 病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id,
           姓名, 性别, 年龄, 标识号, 床号, 费别, 记帐费用, 收费细目id, 收入项目id, 0, 标准单价, 付数, -数次, -应收金额, -实收金额, 收费类别, 计算单位, 加班标志, 收据费目, 开单人,
           划价人, 操作员编号, 操作员姓名, 发生时间, d_登记时间, 保险项目否, 保险大类id, -统筹金额, 医疗小组id
    From 住院费用记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And 附加标志 = 5 And 发生时间 >= d_Start_Date;

  -----------------------------------------------------------------
  --填写病人余额
  -----------------------------------------------------------------
  Select Sum(Decode(附加标志, 0, 1, -1) * 实收金额) As 实收金额
  Into n_Summoney
  From 住院费用记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And
        (NO = v_Billno Or 附加标志 = 5 And 发生时间 >= d_Start_Date);

  Update 病人余额
  Set 费用余额 = Nvl(费用余额, 0) + Nvl(n_Summoney, 0)
  Where 病人id = 病人id_In And 性质 = 1 And 类型 = 2
  Returning 费用余额 Into n_返回值;

  If Sql%RowCount = 0 Then
    Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (病人id_In, 1, 2, n_Summoney, 0);
    n_返回值 := n_Summoney;
  End If;

  If Nvl(n_返回值, 0) = 0 Then
    Delete From 病人余额 Where 性质 = 1 And 病人id = 病人id_In And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
  End If;

  -----------------------------------------------------------------
  --填写病人汇总费用
  -----------------------------------------------------------------
  n_Delete := 0;
  For v_Currrow In c_Sumcur_Rec(v_Billno, d_Start_Date) Loop
    Update 病人未结费用
    Set 金额 = Nvl(金额, 0) + Nvl(v_Currrow.实收金额, 0)
    Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0) And Nvl(病人病区id, 0) = Nvl(v_Currrow.病人病区id, 0) And
          Nvl(病人科室id, 0) = Nvl(v_Currrow.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(v_Currrow.开单部门id, 0) And
          Nvl(执行部门id, 0) = Nvl(v_Currrow.执行部门id, 0) And Nvl(收入项目id, 0) = Nvl(v_Currrow.收入项目id, 0) And 来源途径 + 0 = 2
    Returning 金额 Into n_返回值;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人未结费用
        (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
      Values
        (病人id_In, 主页id_In, v_Currrow.病人病区id, v_Currrow.病人科室id, v_Currrow.开单部门id, v_Currrow.执行部门id, v_Currrow.收入项目id, 2,
         v_Currrow.实收金额);
      n_返回值 := v_Currrow.实收金额;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      n_Delete := 1;
    End If;
  End Loop;

  If Nvl(n_Delete, 0) = 1 Then
    Delete From 病人未结费用 Where 病人id = 病人id_In And 金额 = 0;
  End If;
  -----------------------------------------------------------------
  --将所有修改的附加标志还原为正常标志
  -----------------------------------------------------------------
  Update 住院费用记录
  Set 附加标志 = 0, 记录状态 = 3
  Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And 附加标志 = 5 And 发生时间 >= d_Start_Date;
  -----------------------------------------------------------------
  --修改计算时间标志
  -----------------------------------------------------------------
  Update 病人自动计算
  Set 上次计算时间 = Greatest(Sysdate, Nvl(终止时间, Sysdate))
  Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(终止时间, Sysdate) > d_Start_Date;
End Zl1_Autocalc_Pati_Charge;
/

--107646:刘尔旋,2017-07-11,自动记帐模式
Create Or Replace Procedure Zl1_Autocalc_Pati_Charge_Nm
(
  病人id_In       In 病案主页.病人id%Type,
  主页id_In       In 病案主页.主页id%Type,
  期间_In         In 期间表.期间%Type,
  强制记帐_In     In Number := 0,
  启用价格等级_In In Number := -1
) As
  -------------------------------------------------------------------------
  --功能说明：完成指定病人指定期间的自动记帐(主要是针对内蒙片区的自动记帐项目的计算)
  --          1、系统首先根据系统参数"修正上期自动计费"，修改以往该病人自动记帐记录标志;
  --          2、综合病人的床位变化、入出转情况、调价情况等多项因素，结合期间跨度、病人费
  --             别等完成费用的正确计算：
  --             如果发现已经计算，则修改标志为正常;如果未计算，则插入新的自动记帐记录;
  --             作废以前的错误计算的记录;
  --             统计本次变动(新增和作废)，填写余额表和汇总表;
  --入口参数：
  --       病人ID_IN  number    病人身份ID
  --       主页ID_IN  number    病案主页ID，两个参数共同确定需要计算的病人
  --       期间_IN  varchar2     需要计算的最小期间
  --       强制记帐_IN number   为1时,不受病案主页.禁止自动记帐属性控制
  --       启用价格等级_In number ：-1表示未判断价格等级,内部会自动去检查;0-不启用价格等级;1-启用了价格等级的
  --调用关系：zl1_AutoCptPati/zl1_AutoCptWard/zl1_AutoCptAll 调用本过程
  --自动记帐规则说明:
  --   1. 床位:  计入不计出, 存在中途调整的(转科，转病区，等级变动等),12点以前，按转入科室为准;12点以后以转出科室为准
  --   2.护理及其他费用:  入院当天按一天计算,出院当天中午12点之前算半天，12点之后算一天
  ----------------------------------------------------------------------------------------------------------------------------------
  v_价格等级         收费价格等级.名称%Type;
  v_付款方式价格等级 收费价格等级.名称%Type;

  v_Temp      Varchar2(500);
  v_Billno    Varchar2(8); --费用表实际的自动记帐号码
  n_Billcount Number(5) := 0; --单据序号计数器

  n_Exsetax  Number(16, 2) := 0; --费用收取比率
  n_Summoney Number(16, 2) := 0; --金额

  n_Dec    Number; --金额小数位数
  n_Dates  Number(4, 1); --当前记录的天数，全天为1
  n_Delete Number;
  n_Exists Number;
  n_返回值 病人余额.预交余额%Type;

  v_收据费目   收入项目.收据费目%Type;
  v_计算单位   收费项目目录.计算单位%Type;
  n_住院状态   病案主页.状态%Type;
  n_标准价格   收费价目.现价%Type;
  n_收入项目id 收入项目.Id%Type;
  v_类别       收费项目目录.类别%Type;
  n_算法       保险支付大类.算法%Type;
  n_统筹比额   保险支付大类.统筹比额%Type;
  n_检查类型   病人自动计算.性质%Type;

  n_病人审核方式   Number(2);
  n_未入科禁止记账 Number(2);
  n_护理价格优先   Number(2);
  n_是否用价格等级 Number(2);
  n_是否计算费用   Number(2);
  n_Finded         Number(2);
  n_类型           Number(2); --1-护理;2- 床位;3-其他
  n_Find           Number(2);
  n_Last           Number(2);
  n_前科室id       病人自动计算.科室id%Type;
  n_前病区id       病人自动计算.病区id%Type;
  n_前收费细目id   病人自动计算.护理等级id%Type;
  v_前床号         病人自动计算.床号%Type;
  n_前床位等级id   病人自动计算.床位等级id%Type;
  n_一次标志       Number(2);
  v_重算站点       部门表.站点%Type;

  d_Start_Date Date;
  d_登记时间   Date; --登记时间
  d_发生时间   Date; --发生时间
  d_Temp       Date;

  d_床位时间_Max Date;
  d_护理时间_Max Date;
  d_其他时间_Max Date;

  l_Mulit_细目id t_Numlist := t_Numlist();

  Type t_价格_Rec Is Ref Cursor;
  c_价格_Rec t_价格_Rec;

  Type t_病人变动_Rec Is Record(
    ID         病人变动记录.Id%Type,
    开始时间   病人变动记录.开始时间%Type,
    终止时间   病人变动记录.开始时间%Type,
    科室id     病人变动记录.科室id%Type,
    病区id     病人变动记录.病区id%Type,
    经治医师   病人变动记录.经治医师%Type,
    责任护士   病人变动记录.责任护士%Type,
    医疗小组id 病人变动记录.医疗小组id%Type);

  Type c_病人变动_Rec Is Table Of t_病人变动_Rec;
  r_病人变动 c_病人变动_Rec := c_病人变动_Rec();
  r_变动_Cur c_病人变动_Rec := c_病人变动_Rec();

  Cursor c_Sumcur_Rec
  (
    Billno    Varchar2,
    Datestart Date
  ) Is
    Select 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, Sum(Decode(附加标志, 0, 1, -1) * 应收金额) As 应收金额,
           Sum(Decode(附加标志, 0, 1, -1) * 实收金额) As 实收金额
    From 住院费用记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And
          (NO = Billno Or 附加标志 = 5 And 发生时间 >= Datestart)
    Group By 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id;

  Cursor c_Pati Is
    Select a.病人id, a.主页id, Nvl(a.姓名, i.姓名) As 姓名, Nvl(a.性别, i.性别) As 性别, Nvl(a.年龄, i.年龄) As 年龄, Nvl(a.住院号, i.住院号) As 住院号,
           a.费别, Nvl(a.险类, 0) As 险类, Nvl(a.审核标志, 0) As 审核标志, Nvl(a.状态, 0) As 住院状态, Nvl(a.是否禁止自动记帐, 0) As 是否禁止自动记帐,
           a.医疗付款方式 As 付款方式, a.入院日期, a.出院日期
    From 病案主页 A, 病人信息 I
    Where a.病人id = i.病人id And a.病人id = 病人id_In And a.主页id = 主页id_In;

  r_Pati c_Pati%RowType;
  Cursor c_Pati_Change
  (
    病人id_In In 病案主页.病人id%Type,
    主页id_In In 病案主页.主页id%Type,
    险类_In   In 病案主页.险类%Type,
    期间_In   In Varchar2
  ) Is
    Select a.类型, a.Id, a.病人id, a.主页id, a.科室id, a.病区id, a.床号, a.附加床位, a.收费细目id, a.操作员编号, a.操作员姓名, a.开始时间, a.终止时间, a.启用日期,
           a.数量, Greatest(a.开始日期, Trunc(p.开始日期)) As 开始日期, a.终止日期, a.天数, Nvl(Q1.站点, Q2.站点) As 站点, m.计算单位, m.类别, i.险类,
           i.大类id, k.算法, k.统筹比额, Nvl(m.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) As 项目撤档时间, a.计算标志
    From (Select 2 As 类型, b.Id, b.病人id, b.主页id, b.科室id, b.病区id, b.床号, b.附加床位, b.床位等级id As 收费细目id, b.操作员编号, b.操作员姓名,
                  b.开始时间, b.终止时间, a.启用日期, b.数量, Trunc(b.开始时间) As 开始日期, Trunc(Nvl(b.终止时间, Sysdate)) As 终止日期,
                  Trunc(Nvl(b.终止时间, Sysdate)) - Trunc(b.开始时间) As 天数, 0 As 计算标志
           From 自动计价项目 A,
                (Select a.Id, a.病人id, a.主页id, a.开始时间, a.附加床位, a.病区id, a.科室id, a.床号, a.床位等级id, 1 As 数量, a.终止时间, a.操作员编号,
                         a.操作员姓名, a.上次计算时间
                  From 病人自动计算 A
                  Where a.性质 = 2 And a.病人id = 病人id_In And a.主页id = 主页id_In And
                        Nvl(a.上次计算时间, a.开始时间) <= Nvl(a.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD'))
                  Union All
                  Select b.Id, b.病人id, b.主页id, 开始时间, 附加床位, b.病区id, b.科室id, 床号, i.从项id As 床位等级id, i.从项数次 As 数量, b.终止时间,
                         b.操作员编号, b.操作员姓名, b.上次计算时间
                  From 病人自动计算 B, 收费从属项目 I
                  Where b.性质 = 2 And b.病人id = 病人id_In And b.主页id = 主页id_In And b.床位等级id = i.主项id And i.固有从属 > 0 And
                        Nvl(b.上次计算时间, b.开始时间) <= Nvl(b.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD'))) B
           Where a.病区id = b.病区id And a.计算标志 = 1 And Trunc(Nvl(b.终止时间, Sysdate)) >= a.启用日期
           Union All
           Select 1 As 类型, b.Id, b.病人id, b.主页id, b.科室id, b.病区id, b.床号, b.附加床位, b.护理等级id As 收费细目id, b.操作员编号, b.操作员姓名,
                  b.开始时间, b.终止时间, a.启用日期, b.数量, Trunc(b.开始时间) As 开始日期,
                  Decode(Trunc(b.终止时间), Trunc(b.开始时间), Trunc(Nvl(b.终止时间, Sysdate)),
                          Zl_Date_Half(Nvl(b.终止时间, Trunc(Sysdate)), 1)) As 终止日期,
                  Decode(Trunc(b.终止时间), Trunc(b.开始时间), Trunc(Nvl(b.终止时间, Sysdate)),
                          Zl_Date_Half(Nvl(b.终止时间, Trunc(Sysdate)), 1)) - Trunc(b.开始时间) As 天数, 0 As 计算标志
           From 自动计价项目 A,
                (Select a.Id, a.病人id, a.主页id, a.开始时间, a.附加床位, a.病区id, a.科室id, a.床号, a.护理等级id, 1 As 数量, a.终止时间, a.操作员编号,
                         a.操作员姓名, a.上次计算时间
                  From 病人自动计算 A
                  Where a.性质 = 1 And a.病人id = 病人id_In And a.主页id = 主页id_In And
                        Nvl(a.上次计算时间, a.开始时间) <= Nvl(a.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD'))
                  Union All
                  Select b.Id, b.病人id, b.主页id, 开始时间, 附加床位, b.病区id, b.科室id, 床号, i.从项id As 床位等级id, i.从项数次 As 数量, b.终止时间,
                         b.操作员编号, b.操作员姓名, b.上次计算时间
                  From 病人自动计算 B, 收费从属项目 I
                  Where b.性质 = 1 And b.病人id = 病人id_In And b.主页id = 主页id_In And b.护理等级id = i.主项id And i.固有从属 > 0 And
                        Nvl(b.上次计算时间, b.开始时间) <= Nvl(b.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD'))) B
           Where a.病区id = b.病区id And a.计算标志 = 2 And
                 Decode(Trunc(b.终止时间), Trunc(b.开始时间), Trunc(Nvl(b.终止时间, Sysdate)),
                        Zl_Date_Half(Nvl(b.终止时间, Trunc(Sysdate)), 1)) >= a.启用日期
           Union All
           Select 3 As 类型, b.Id, b.病人id, b.主页id, b.科室id, b.病区id, b.床号, b.附加床位, a.收费细目id, b.操作员编号, b.操作员姓名, b.开始时间, b.终止时间,
                  a.启用日期, a.数量, Trunc(b.开始时间) As 开始日期, Zl_Date_Half(Nvl(b.终止时间, Trunc(Sysdate)), 1) As 终止日期,
                  Trunc(Nvl(b.终止时间, Sysdate)) - Trunc(b.开始时间) As 天数, a.计算标志
           From (Select 病区id, 计算标志, 收费细目id, 1 As 数量, 启用日期
                  From 自动计价项目
                  Union All
                  Select 病区id, 计算标志, 从项id, i.从项数次 As 数量, 启用日期
                  From 自动计价项目 A, 收费从属项目 I
                  Where a.收费细目id = i.主项id And i.固有从属 > 0) A, 病人自动计算 B
           Where a.病区id = b.病区id And b.病人id = 病人id_In And Zl_Date_Half(Nvl(b.终止时间, Trunc(Sysdate)), 1) >= a.启用日期 And
                 b.主页id = 主页id_In And b.性质 = 3 And Nvl(b.附加床位, 0) = 0 And
                 (a.计算标志 = 6 And b.床位等级id Is Not Null Or a.计算标志 = 7) And
                 Nvl(b.上次计算时间, b.开始时间) <= Nvl(b.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD'))) A,
         (Select Min(开始日期) As 开始日期 From 期间表 Where 期间 >= 期间_In) P, 保险支付项目 I, 保险支付大类 K, 收费项目目录 M, 部门表 Q1, 部门表 Q2
    Where Trunc(Nvl(a.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD'))) >= Trunc(p.开始日期) And a.收费细目id = i.收费细目id(+) And
          i.险类(+) = Nvl(险类_In, 0) And i.大类id = k.Id(+) And a.收费细目id = m.Id(+) And a.病区id = Q1.Id(+) And
          a.科室id = Q2.Id(+)
    Order By 类型, 附加床位, 开始时间;

  r_Pati_Change     c_Pati_Change%RowType;
  r_Pati_Change_Pre c_Pati_Change%RowType;

  Function Get_Discount_Rate
  (
    费别_In       病人信息.费别%Type,
    收费细目id_In 费别明细.收费细目id%Type,
    收入项目id_In 费别明细.收入项目id%Type,
    金额_In       费别明细.应收段首值%Type
  ) Return Number As
    n_Discount_Rate Number(16, 5);
  Begin
    Begin
      Select 实收比率
      Into n_Discount_Rate
      From (Select 实收比率
             From 费别明细
             Where 费别 = Nvl(费别_In, '-') And 收费细目id = Nvl(收费细目id_In, 0) And (金额_In Between 应收段首值 And 应收段尾值)
             Union All
             Select 实收比率
             From 费别明细
             Where 费别 = Nvl(费别_In, '-') And 收入项目id = Nvl(收入项目id_In, 0) And (金额_In Between 应收段首值 And 应收段尾值) And Not Exists
              (Select 1 From 费别明细 Where 费别 = Nvl(费别_In, '-') And 收费细目id = Nvl(收费细目id_In, 0)));
    Exception
      When Others Then
        n_Discount_Rate := 100.00;
    End;
    n_Discount_Rate := Nvl(n_Discount_Rate, 100);
    Return n_Discount_Rate;
  End Get_Discount_Rate;

Begin

  --获取病人信息
  Begin
    Open c_Pati;
    Fetch c_Pati
      Into r_Pati;
  Exception
    When Others Then
      Return;
  End;

  If Nvl(强制记帐_In, 0) = 0 And Nvl(r_Pati.是否禁止自动记帐, 0) = 1 Then
    Return;
  End If;

  n_病人审核方式   := Nvl(zl_GetSysParameter(185), 0);
  n_未入科禁止记账 := Nvl(zl_GetSysParameter(215), 0);

  If n_病人审核方式 = 1 And Nvl(r_Pati.审核标志, 0) >= 1 Then
    Return;
  End If;

  If n_未入科禁止记账 = 1 And n_住院状态 = 1 Then
    Return;
  End If;

  --------------------------------------------------------------------------------
  --1.初始化相关的参数
  n_是否用价格等级 := 启用价格等级_In;
  If n_是否用价格等级 < 0 Then
    Select Nvl(Max(1), 0) Into n_是否用价格等级 From 收费价格等级应用 Where Rownum < 2;
  End If;
  --每天5点以前，将记录时间登记为昨天，否则登记为当时
  Select Decode(Sign(To_Number(To_Char(Sysdate, 'HH24')) - 5), -1, Trunc(Sysdate) - 1 / 24 / 60, Sysdate)
  Into d_登记时间
  From Dual;

  v_付款方式价格等级 := Null;
  If Nvl(n_是否用价格等级, 0) = 1 Then
    Select Max(价格等级)
    Into v_付款方式价格等级
    From 收费价格等级应用 A, 收费价格等级 B
    Where a.价格等级 = b.名称 And a.性质 = 1 And a.医疗付款方式 = Nvl(r_Pati.付款方式, '-') And Nvl(b.是否适用普通项目, 0) = 1 And
          Nvl(b.撤档时间, Sysdate + 1) > Sysdate;
  End If;

  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')), Zl_To_Number(Nvl(zl_GetSysParameter(160), '0'))
  Into n_Dec, n_护理价格优先
  From Dual;

  n_护理价格优先 := 1;
  --每天5点以前，将记录时间登记为昨天，否则登记为当时
  Select Decode(Sign(To_Number(To_Char(Sysdate, 'HH24')) - 5), -1, Trunc(Sysdate) - 1 / 24 / 60, Sysdate)
  Into d_登记时间
  From Dual;
  --------------------------------------------------------------------------------

  --锁定该病人的记录,以免重复计算
  Update 病案主页 Set 状态 = 状态 Where 病人id = 病人id_In And 主页id = 主页id_In;

  --------------------------------------------------------------------------------
  --2. 先将变动信息给记录集,以便提取经治医师和责任护士
  d_护理时间_Max := Null;
  d_其他时间_Max := Null;
  d_床位时间_Max := Null;
  For c_变动 In (Select ID, 开始时间, Nvl(终止时间, Sysdate + 1) As 终止时间, 科室id, 病区id, 护理等级id, 床位等级id, 经治医师, 责任护士, 医疗小组id
               From 病人变动记录 A
               Where 病人id = 病人id_In And 主页id = 主页id_In And 科室id Is Not Null And
                     Nvl(终止时间, Sysdate) >= (Select Nvl(Min(上次计算时间), Sysdate - 1000)
                                            From 病人自动计算
                                            Where 病人id = 病人id_In And 主页id = 主页id_In)
               Order By 病区id, 科室id, 开始时间 Desc) Loop
  
    If c_变动.护理等级id Is Not Null And Nvl(d_护理时间_Max, c_变动.终止时间 - 1) <= c_变动.终止时间 Then
      d_护理时间_Max := c_变动.终止时间;
    End If;
  
    If c_变动.床位等级id Is Not Null And Nvl(d_床位时间_Max, c_变动.终止时间 - 1) <= c_变动.终止时间 Then
      d_床位时间_Max := c_变动.终止时间;
    End If;
  
    If c_变动.科室id Is Not Null And Nvl(d_其他时间_Max, c_变动.终止时间 - 1) <= c_变动.终止时间 Then
      d_其他时间_Max := c_变动.终止时间;
    End If;
    r_病人变动.Extend;
    r_病人变动(r_病人变动.Count).Id := c_变动.Id;
    r_病人变动(r_病人变动.Count).开始时间 := c_变动.开始时间;
    r_病人变动(r_病人变动.Count).终止时间 := c_变动.终止时间;
    r_病人变动(r_病人变动.Count).科室id := c_变动.科室id;
    r_病人变动(r_病人变动.Count).病区id := c_变动.病区id;
    r_病人变动(r_病人变动.Count).经治医师 := c_变动.经治医师;
    r_病人变动(r_病人变动.Count).责任护士 := c_变动.责任护士;
    r_病人变动(r_病人变动.Count).医疗小组id := c_变动.医疗小组id;
  End Loop;

  --超过12:00,以12:00为准
  d_护理时间_Max := Zl_Date_Half(d_护理时间_Max, 1);
  d_床位时间_Max := Zl_Date_Half(d_床位时间_Max, 1);
  d_其他时间_Max := Zl_Date_Half(d_其他时间_Max, 1);

  -----------------------------------------------------------------
  --循环检查计算情况，并增加正确和新计算的记录
  -----------------------------------------------------------------

  d_Start_Date := Sysdate + 1000;
  d_Temp       := Sysdate - 1000;
  n_一次标志   := 1;

  --1.计算床位费
  For c_自动记帐 In c_Pati_Change(病人id_In, 主页id_In, r_Pati.险类, 期间_In) Loop
  
    If v_付款方式价格等级 Is Null Then
      If Nvl(n_是否用价格等级, 0) = 1 And Nvl(r_Pati_Change_Pre.站点, '-') <> Nvl(c_自动记帐.站点, '-') Then
        v_Temp     := Nvl(Zl_Get_Pricegrade(c_自动记帐.站点, 病人id_In, 主页id_In, r_Pati.付款方式), '|||') || '||||';
        v_价格等级 := Substr(v_Temp, 1, Instr(v_Temp, '|') - 1);
      End If;
    Else
      v_价格等级 := v_付款方式价格等级;
    End If;
  
    r_Pati_Change := c_自动记帐;
    If d_Start_Date > r_Pati_Change.开始日期 Then
      d_Start_Date := r_Pati_Change.开始日期;
    End If;
  
    If Nvl(r_Pati_Change.类型, 0) <> Nvl(n_检查类型, 0) Then
      n_检查类型 := Nvl(r_Pati_Change.类型, 0);
      Update 住院费用记录
      Set 附加标志 = 5
      Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And 附加标志 <> 8 And Nvl(医嘱序号, 0) = 0 And
            发生时间 >= r_Pati_Change.开始日期 And 附加标志 <> 5 And (发药窗口 Is Null Or 发药窗口 = Nvl(n_检查类型, 0));
    End If;
  
    --生成每天费用
    For I In 0 .. r_Pati_Change.天数 Loop
      v_重算站点    := Null;
      r_Pati_Change := c_自动记帐;
      d_发生时间    := Greatest(c_自动记帐.开始日期, Trunc(c_自动记帐.开始日期 + I));
      n_Dates       := Least(Trunc(c_自动记帐.开始日期 + I + 1), c_自动记帐.终止日期) - Greatest(c_自动记帐.开始日期, Trunc(c_自动记帐.开始日期 + I));
    
      If r_Pati_Change.类型 <> 2 Then
        ----护理及其他费用:  入院当天按一天计算,出院当天中午12点之前算半天，12点之后算一天
        If (r_Pati_Change.类型 = 1 And Trunc(d_护理时间_Max) = Trunc(d_发生时间) And d_护理时间_Max = r_Pati_Change.终止日期) Or
           (r_Pati_Change.类型 = 3 And Trunc(d_其他时间_Max) = Trunc(d_发生时间) And d_其他时间_Max = r_Pati_Change.终止日期 And
           r_Pati_Change.计算标志 = 7) Or (r_Pati_Change.类型 = 3 And Trunc(d_床位时间_Max) = Trunc(d_发生时间) And
           d_床位时间_Max = r_Pati_Change.终止日期 And r_Pati_Change.计算标志 = 6) Then
          If To_Char(r_Pati_Change.终止日期, 'hh24') >= 12 Then
            n_Dates := 1;
          Else
            n_Dates    := 0.5;
            d_发生时间 := Trunc(d_发生时间) + 0.5;
          End If;
        Else
          n_Dates    := Least(Trunc(c_自动记帐.开始日期 + I + 1), Trunc(c_自动记帐.终止日期)) -
                        Greatest(c_自动记帐.开始日期, Trunc(c_自动记帐.开始日期 + I));
          d_发生时间 := Trunc(d_发生时间);
        End If;
      End If;
    
      If n_护理价格优先 = 1 And c_自动记帐.类型 = 1 Then
        If d_发生时间 <> d_Temp Or Nvl(n_类型, 0) <> Nvl(c_自动记帐.类型, 0) Then
          l_Mulit_细目id.Delete;
          d_Temp := d_发生时间;
          n_类型 := Nvl(c_自动记帐.类型, 0);
        End If;
      
        n_Finded := 0;
        For J In 1 .. l_Mulit_细目id.Count Loop
          If l_Mulit_细目id(J) = c_自动记帐.收费细目id Then
            n_Finded := 1;
            Exit;
          End If;
        End Loop;
        If n_Finded = 0 Then
          l_Mulit_细目id.Extend;
          l_Mulit_细目id(l_Mulit_细目id.Count) := c_自动记帐.收费细目id;
        End If;
      End If;
    
      n_Last         := 0;
      n_是否计算费用 := 1;
      If d_发生时间 > r_Pati_Change.项目撤档时间 Or n_Dates <= 0 Or (d_发生时间 > r_Pati_Change.终止日期) Then
        Select Nvl(Max(1), 0)
        Into n_Exists
        From 病人自动计算 A
        Where (a.终止原因 = 1 Or a.终止原因 = 10) And a.Id = r_Pati_Change.Id And r_Pati_Change.类型 <> 2;
        If n_Exists = 0 Or n_Dates <= 0 Then
          n_是否计算费用 := 0;
        Else
          n_Last := 0.5;
        End If;
      End If;
    
      Select Nvl(Max(1), 0)
      Into n_Exists
      From 病人自动计算 A
      Where a.终止原因 = 1 And a.Id = r_Pati_Change.Id And Exists
       (Select 1
             From 病人自动计算
             Where 病人id = a.病人id And 主页id = a.主页id And 开始原因 = 2 And Trunc(开始时间) = Trunc(a.终止时间));
    
      If n_Exists = 1 Then
        n_是否计算费用 := 1;
        n_Dates        := 1;
      End If;
    
      If n_是否计算费用 = 1 And r_Pati_Change.类型 = 3 And r_Pati_Change.计算标志 = 8 Then
        If n_一次标志 = 1 Then
          n_一次标志 := 0;
        Else
          n_是否计算费用 := 0;
        End If;
      End If;
    
      If n_是否计算费用 = 1 Then
      
        If d_发生时间 = Trunc(r_Pati_Change.开始时间) And Nvl(r_Pati_Change.附加床位, 0) = 0 Then
          --12点以前，按转入出科室为准;12点以后以转出为准
          If To_Char(r_Pati_Change.开始时间, 'hh24') >= 12 Then
            --多条变动记录的处理
            Begin
              n_Find := 1;
              Select 科室id, 病区id, Decode(r_Pati_Change.类型, 1, 护理等级id, 2, 床位等级id, r_Pati_Change.收费细目id), 床号, 床位等级id
              Into n_前科室id, n_前病区id, n_前收费细目id, v_前床号, n_前床位等级id
              From 病人自动计算
              Where 病人id = 病人id_In And 主页id = 主页id_In And 性质 = r_Pati_Change.类型 And
                    开始时间 = (Select Max(开始时间)
                            From 病人自动计算
                            Where 病人id = 病人id_In And 主页id = 主页id_In And 性质 = r_Pati_Change.类型 And
                                  开始时间 <= To_Date(To_Char(r_Pati_Change.开始时间, 'yyyy-mm-dd') || ' 12:00:00',
                                                  'yyyy-mm-dd hh24:mi:ss'));
            Exception
              When Others Then
                n_Find := 0;
            End;
            If n_Find = 1 And n_前收费细目id Is Not Null And n_前病区id Is Not Null And n_前科室id Is Not Null And
               Not (r_Pati_Change.类型 = 3 And r_Pati_Change.计算标志 = 6 And n_前床位等级id Is Null) Then
              r_Pati_Change.科室id     := n_前科室id;
              r_Pati_Change.病区id     := n_前病区id;
              r_Pati_Change.收费细目id := n_前收费细目id;
              r_Pati_Change.床号       := v_前床号;
            
              Select Nvl(a.站点, b.站点)
              Into v_重算站点
              From 部门表 A, 部门表 B
              Where a.Id = n_前病区id And b.Id = n_前科室id;
            End If;
          End If;
        End If;
      
        If v_重算站点 Is Not Null Then
          If v_付款方式价格等级 Is Null Then
            If Nvl(n_是否用价格等级, 0) = 1 Then
              v_Temp     := Nvl(Zl_Get_Pricegrade(v_重算站点, 病人id_In, 主页id_In, r_Pati.付款方式), '|||') || '||||';
              v_价格等级 := Substr(v_Temp, 1, Instr(v_Temp, '|') - 1);
            End If;
          Else
            v_价格等级 := v_付款方式价格等级;
          End If;
        Else
          If v_付款方式价格等级 Is Null Then
            If Nvl(n_是否用价格等级, 0) = 1 Then
              v_Temp     := Nvl(Zl_Get_Pricegrade(r_Pati_Change.站点, 病人id_In, 主页id_In, r_Pati.付款方式), '|||') || '||||';
              v_价格等级 := Substr(v_Temp, 1, Instr(v_Temp, '|') - 1);
            End If;
          Else
            v_价格等级 := v_付款方式价格等级;
          End If;
        End If;
      
        If v_价格等级 Is Null Then
          Open c_价格_Rec For
            Select b.现价 As 标准单价, b.收入项目id, c.收据费目, m.计算单位, m.类别
            From 收费价目 B, 收入项目 C, 收费项目目录 M
            Where b.收费细目id = m.Id And b.收费细目id = r_Pati_Change.收费细目id And b.收入项目id = c.Id And
                  (c.撤档时间 Is Null Or c.撤档时间 > d_发生时间) And Trunc(d_发生时间) Between Trunc(b.执行日期) And
                  Nvl(b.终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')) And b.价格等级 Is Null;
        Else
          Open c_价格_Rec For
            Select b.现价 As 标准单价, b.收入项目id, c.收据费目, m.计算单位, m.类别
            From 收费价目 B, 收入项目 C, 收费项目目录 M
            Where b.收费细目id = m.Id And b.收费细目id = r_Pati_Change.收费细目id And b.收入项目id = c.Id And
                  (c.撤档时间 Is Null Or c.撤档时间 > d_发生时间) And Trunc(d_发生时间) Between Trunc(b.执行日期) And
                  Nvl(b.终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')) And
                  (b.价格等级 = v_价格等级 Or
                  (b.价格等级 Is Null And Not Exists
                   (Select 1
                     From 收费价目
                     Where 收费细目id = r_Pati_Change.收费细目id And 价格等级 = Nvl(v_价格等级, '-') And
                           Trunc(d_发生时间) Between Trunc(执行日期) And Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')))));
        End If;
      
        Loop
          Fetch c_价格_Rec
            Into n_标准价格, n_收入项目id, v_收据费目, v_计算单位, v_类别;
          Exit When c_价格_Rec%NotFound;
          --For c_价格 In c_价格_Rec(n_收费细目id, d_发生时间, v_价格等级) Loop
          --提取当前收入项目的收费比率
          n_Exsetax := Get_Discount_Rate(r_Pati.费别, r_Pati_Change.收费细目id, n_收入项目id, Abs(n_标准价格 * r_Pati_Change.数量));
        
          --如果已经计算，原记录计算完全正确，则直接修改将标志改正
          Update 住院费用记录
          Set 附加标志 = 0, 发药窗口 = r_Pati_Change.类型
          Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And
                Nvl(加班标志, 0) = Nvl(r_Pati_Change.附加床位, 0) And 病人科室id = r_Pati_Change.科室id And
                病人病区id = Nvl(r_Pati_Change.病区id, 0) And Nvl(床号, 0) = Nvl(r_Pati_Change.床号, 0) And
                收费细目id = r_Pati_Change.收费细目id And 收入项目id = n_收入项目id And 发生时间 = d_发生时间 And
                数次 = r_Pati_Change.数量 * n_Dates And 标准单价 = n_标准价格 And
                应收金额 = Round(n_标准价格 * r_Pati_Change.数量 * n_Dates, n_Dec) And
                实收金额 = Round(n_标准价格 * r_Pati_Change.数量 * n_Dates * n_Exsetax / 100, n_Dec);
        
          If Sql%RowCount = 0 Then
            --如果未计算或计算错误，则增加正确的计算记录
            r_变动_Cur.Delete;
            r_变动_Cur.Extend;
            For Q In 1 .. r_病人变动.Count Loop
              If r_病人变动(Q).病区id = r_Pati_Change.病区id And r_病人变动(Q).科室id = r_Pati_Change.科室id And
                  d_发生时间 - n_Last Between Trunc(r_病人变动(Q).开始时间) And r_病人变动(Q).终止时间 Then
                r_变动_Cur(r_变动_Cur.Count).Id := r_病人变动(Q).Id;
                r_变动_Cur(r_变动_Cur.Count).开始时间 := r_病人变动(Q).开始时间;
                r_变动_Cur(r_变动_Cur.Count).终止时间 := r_病人变动(Q).终止时间;
                r_变动_Cur(r_变动_Cur.Count).科室id := r_病人变动(Q).科室id;
                r_变动_Cur(r_变动_Cur.Count).病区id := r_病人变动(Q).病区id;
                r_变动_Cur(r_变动_Cur.Count).经治医师 := r_病人变动(Q).经治医师;
                r_变动_Cur(r_变动_Cur.Count).责任护士 := r_病人变动(Q).责任护士;
                r_变动_Cur(r_变动_Cur.Count).医疗小组id := r_病人变动(Q).医疗小组id;
                Exit;
              End If;
            End Loop;
          
            If v_Billno Is Null Then
              v_Billno := Nextno(17);
            End If;
            Insert Into 住院费用记录
              (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 医嘱序号, 门诊标志, 病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 姓名, 性别,
               年龄, 标识号, 床号, 费别, 记帐费用, 收费细目id, 收入项目id, 附加标志, 标准单价, 付数, 数次, 应收金额, 实收金额, 收费类别, 计算单位, 加班标志, 收据费目, 开单人, 划价人,
               操作员编号, 操作员姓名, 发生时间, 登记时间, 保险项目否, 保险大类id, 统筹金额, 医疗小组id, 发药窗口)
              Select 病人费用记录_Id.Nextval, 3, v_Billno, 1, Rownum + n_Billcount, Null, Null, 0, Null,
                     Decode(r_Pati_Change.主页id, Null, 1, 2), r_Pati_Change.病人id, r_Pati_Change.主页id, r_Pati_Change.病区id,
                     r_Pati_Change.科室id, r_Pati_Change.科室id, r_Pati_Change.病区id, r_Pati.姓名, r_Pati.性别, r_Pati.年龄,
                     r_Pati.住院号, r_Pati_Change.床号, r_Pati.费别, 1, r_Pati_Change.收费细目id, n_收入项目id, 0, n_标准价格, 1,
                     r_Pati_Change.数量 * n_Dates, Round(n_标准价格 * r_Pati_Change.数量 * n_Dates, n_Dec),
                     Round(n_标准价格 * r_Pati_Change.数量 * n_Dates * n_Exsetax / 100, n_Dec), v_类别, v_计算单位,
                     r_Pati_Change.附加床位, v_收据费目,r_变动_Cur(1).经治医师,r_变动_Cur(1).责任护士, r_Pati_Change.操作员编号,
                     r_Pati_Change.操作员姓名, d_发生时间, d_登记时间, Decode(r_Pati_Change.险类, Null, 0, 1), r_Pati_Change.大类id,
                     Decode(Nvl(n_算法, 0), 1,
                             Round(n_标准价格 * r_Pati_Change.数量 * n_Dates * n_Exsetax / 100 * n_统筹比额 / 100, n_Dec), 2, n_统筹比额,
                             0),r_变动_Cur(1).医疗小组id, r_Pati_Change.类型
              From Dual;
            n_Billcount := n_Billcount + Sql%RowCount;
          End If;
        End Loop;
        Close c_价格_Rec;
      End If;
      r_Pati_Change_Pre := c_自动记帐;
    End Loop;
  End Loop;

  -----------------------------------------------------------------
  --作废以前计算的错误记录
  -----------------------------------------------------------------
  Insert Into 住院费用记录
    (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 医嘱序号, 门诊标志, 病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 姓名, 性别, 年龄, 标识号,
     床号, 费别, 记帐费用, 收费细目id, 收入项目id, 附加标志, 标准单价, 付数, 数次, 应收金额, 实收金额, 收费类别, 计算单位, 加班标志, 收据费目, 开单人, 划价人, 操作员编号, 操作员姓名, 发生时间,
     登记时间, 保险项目否, 保险大类id, 统筹金额, 医疗小组id, 发药窗口)
    Select 病人费用记录_Id.Nextval, 记录性质, NO, 2, 序号, 从属父号, 价格父号, 多病人单, 医嘱序号, 门诊标志, 病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id,
           姓名, 性别, 年龄, 标识号, 床号, 费别, 记帐费用, 收费细目id, 收入项目id, 0, 标准单价, 付数, -数次, -应收金额, -实收金额, 收费类别, 计算单位, 加班标志, 收据费目, 开单人,
           划价人, 操作员编号, 操作员姓名, 发生时间, d_登记时间, 保险项目否, 保险大类id, -统筹金额, 医疗小组id, 发药窗口
    From 住院费用记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And 附加标志 = 5 And 发生时间 >= d_Start_Date;

  -----------------------------------------------------------------
  --填写病人余额
  -----------------------------------------------------------------
  Select Sum(Decode(附加标志, 0, 1, -1) * 实收金额) As 实收金额
  Into n_Summoney
  From 住院费用记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And
        (NO = v_Billno Or 附加标志 = 5 And 发生时间 >= d_Start_Date);

  Update 病人余额
  Set 费用余额 = Nvl(费用余额, 0) + Nvl(n_Summoney, 0)
  Where 病人id = 病人id_In And 性质 = 1 And 类型 = 2
  Returning 费用余额 Into n_返回值;

  If Sql%RowCount = 0 Then
    Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (病人id_In, 1, 2, n_Summoney, 0);
    n_返回值 := n_Summoney;
  End If;

  If Nvl(n_返回值, 0) = 0 Then
    Delete From 病人余额 Where 性质 = 1 And 病人id = 病人id_In And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
  End If;

  -----------------------------------------------------------------
  --填写病人汇总费用
  -----------------------------------------------------------------
  n_Delete := 0;
  For v_Currrow In c_Sumcur_Rec(v_Billno, d_Start_Date) Loop
    Update 病人未结费用
    Set 金额 = Nvl(金额, 0) + Nvl(v_Currrow.实收金额, 0)
    Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0) And Nvl(病人病区id, 0) = Nvl(v_Currrow.病人病区id, 0) And
          Nvl(病人科室id, 0) = Nvl(v_Currrow.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(v_Currrow.开单部门id, 0) And
          Nvl(执行部门id, 0) = Nvl(v_Currrow.执行部门id, 0) And Nvl(收入项目id, 0) = Nvl(v_Currrow.收入项目id, 0) And 来源途径 + 0 = 2
    Returning 金额 Into n_返回值;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人未结费用
        (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
      Values
        (病人id_In, 主页id_In, v_Currrow.病人病区id, v_Currrow.病人科室id, v_Currrow.开单部门id, v_Currrow.执行部门id, v_Currrow.收入项目id, 2,
         v_Currrow.实收金额);
      n_返回值 := v_Currrow.实收金额;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      n_Delete := 1;
    End If;
  End Loop;

  If Nvl(n_Delete, 0) = 1 Then
    Delete From 病人未结费用 Where 病人id = 病人id_In And 金额 = 0;
  End If;
  -----------------------------------------------------------------
  --将所有修改的附加标志还原为正常标志
  -----------------------------------------------------------------
  Update 住院费用记录
  Set 附加标志 = 0, 记录状态 = 3
  Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And 附加标志 = 5 And 发生时间 >= d_Start_Date;
  -----------------------------------------------------------------
  --修改计算时间标志
  -----------------------------------------------------------------
  Update 病人自动计算
  Set 上次计算时间 = Greatest(Sysdate, Nvl(终止时间, Sysdate))
  Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(终止时间, Sysdate) > d_Start_Date;
End Zl1_Autocalc_Pati_Charge_Nm;
/

--107646:刘尔旋,2017-05-24,自动记帐费用记帐模式
Create Or Replace Function Zl_Date_Half
(
  Date_In     In Date,
  半天模式_In Number := -1
) Return Date As
  --    功能：进行日期格式化
  --    参数：
  --        Date_In:需要格式化的日期
  --        半天模式_In:<0 表示统一根据系统参数(100)的设置来处理;0-非半天模式;>=1-半天模式
  --    返回：返回格式化的日期，如果半天模式且传入的日期超过上午12点，则返回传入日期 yyyy-mm-dd 12:00:00的形式,否则返回yyyy-mm-dd 00:00:00
  n_下午算半天 Number(1);
Begin
  If Date_In Is Null Then
    Return Null;
  End If;

  If To_Char(Date_In, 'hh24') < 12 Or 半天模式_In = 0 Then
    Return Trunc(Date_In);
  End If;

  n_下午算半天 := 半天模式_In;
  If 半天模式_In < 0 Then
    n_下午算半天 := To_Number(Nvl(zl_GetSysParameter(100), 0));
  End If;
  If n_下午算半天 = 1 Then
    Return Trunc(Date_In) + 0.5;
  Else
    Return Trunc(Date_In);
  End If;

Exception
  When Others Then
    Return Null;
End Zl_Date_Half;
/

--99878:冉俊明,2017-05-26,同一收费项目多个价格管理
Create Or Replace Procedure Zl_门诊收费误差_Insert
(
  No_In       门诊费用记录.No%Type,
  误差_In     门诊费用记录.实收金额%Type,
  退费_In     Number := 0,
  更新预交_In Number := 0
) As
  --功能：填写门诊收费时所产生的误差费用,以保证与结算金额一致。
  --      用于门诊收费,门诊收取划价单费用,门诊退费。
  --参数：误差_IN=Sum(结算金额)-Sum(结帐金额)
  --      退费_IN=表明是否门诊退费时调用(仅单张单据部份退费时才调用)
  --      更新预交_IN :1-用误差更新病人预交记录中的冲预交(主要是更新结算方式为NULL 的记录)
  v_收费类别   门诊费用记录.收费类别%Type;
  v_收费细目id 门诊费用记录.收费细目id%Type;
  v_计算单位   门诊费用记录.计算单位%Type;
  v_收入项目id 门诊费用记录.收入项目id%Type;
  v_收据费目   门诊费用记录.收据费目%Type;

  v_执行部门id 门诊费用记录.执行部门id%Type;

  v_费用id   门诊费用记录.Id%Type;
  v_序号     门诊费用记录.序号%Type;
  v_结帐id   门诊费用记录.结帐id%Type;
  v_执行状态 门诊费用记录.执行状态%Type;

  v_Temp     Varchar2(255);
  v_人员编号 门诊费用记录.操作员编号%Type;
  v_人员姓名 门诊费用记录.操作员姓名%Type;
  n_费用状态 门诊费用记录.费用状态%Type;
  v_Sign     Number;

  Err_Custom Exception;
  v_Error Varchar2(255);
Begin
  If Nvl(误差_In, 0) = 0 Then
    Return;
  End If;

  --操作员信息:部门ID,部门名称;人员ID,人员编号,人员姓名
  v_Temp       := Zl_Identity;
  v_执行部门id := To_Number(Substr(v_Temp, 1, Instr(v_Temp, ',') - 1));
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_人员编号   := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_人员姓名   := Substr(v_Temp, Instr(v_Temp, ',') + 1);

  --误差项目内容
  Begin
    Select a.类别, a.Id, a.计算单位, c.Id, c.收据费目
    Into v_收费类别, v_收费细目id, v_计算单位, v_收入项目id, v_收据费目
    From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费特定项目 D
    Where d.特定项目 = '误差项' And d.收费细目id = a.Id And a.Id = b.收费细目id And b.收入项目id = c.Id And
          ((Sysdate Between b.执行日期 And b.终止日期) Or (Sysdate >= b.执行日期 And b.终止日期 Is Null)) And b.价格等级 Is Null;
  Exception
    When Others Then
      Begin
        v_Error := '不能正确读取处理费用误差的项目信息，请先检查该项目是否正确设置。';
        Raise Err_Custom;
      End;
  End;

  If Nvl(退费_In, 0) <> 0 Then
    --退费处理误差时,在收费的误差记录上处理；如果无,则直接新增退费记录
    Begin
      Select 序号
      Into v_序号
      From 门诊费用记录
      Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And 附加标志 = 9;
    Exception
      When Others Then
        Null;
    End;
  End If;
  If v_序号 Is Null Then
    Select Max(序号) + 1 Into v_序号 From 门诊费用记录 Where NO = No_In And 记录性质 = 1;
  End If;
  v_Sign     := 1;
  v_执行状态 := 0;
  --该笔项目第几次退费(退费时)
  If Nvl(退费_In, 0) <> 0 Then
    v_Sign := -1;
    Select Max(费用状态), Decode(Max(执行状态), 9, 9, -1 * (Nvl(Max(Abs(执行状态)), 0) + 1))
    Into n_费用状态, v_执行状态
    From 门诊费用记录
    Where NO = No_In And 记录性质 = 1 And 记录状态 = 2 And 序号 = v_序号;
  Else
    Select 费用状态, 执行状态
    Into n_费用状态, v_执行状态
    From 门诊费用记录
    Where NO = No_In And 记录性质 = 1 And 记录状态 = 1 And 序号 = 1;
  End If;

  --取最近收费或退费的结帐ID(主要是为了确定最后一次退费)
  Select Max(结帐id) Into v_结帐id From 门诊费用记录 Where NO = No_In And 记录性质 = 1;
  Select 病人费用记录_Id.Nextval Into v_费用id From Dual;

  --门诊费用记录:附加标志=9
  Update 门诊费用记录
  Set 标准单价 = Nvl(标准单价, 0) + Nvl(误差_In, 0), 应收金额 = Nvl(应收金额, 0) + v_Sign * 误差_In, 实收金额 = Nvl(实收金额, 0) + v_Sign * 误差_In,
      结帐金额 = Nvl(结帐金额, 0) + v_Sign * 误差_In
  Where NO = No_In And 记录性质 = 1 And 记录状态 = Decode(Nvl(退费_In, 0), 0, 1, 2) And 结帐id = v_结帐id And Nvl(附加标志, 0) = 9;
  If Sql%NotFound Then
    Insert Into 门诊费用记录
      (ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位,
       发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 记帐费用, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 费用状态,
       结帐id, 结帐金额, 操作员编号, 操作员姓名, 是否上传)
      Select v_费用id, 记录性质, NO, 实际票号, 记录状态, v_序号, Null, Null, 门诊标志, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 病人科室id, 费别, v_收费类别,
             v_收费细目id, v_计算单位, 发药窗口, 1, v_Sign * 1, 加班标志, 9, v_收入项目id, v_收据费目, 误差_In, v_Sign * 误差_In, v_Sign * 误差_In,
             记帐费用, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, v_执行部门id, v_执行状态, n_费用状态, 结帐id, v_Sign * 误差_In, v_人员编号, v_人员姓名, 1
      From 门诊费用记录
      Where NO = No_In And 记录性质 = 1 And 记录状态 = Decode(Nvl(退费_In, 0), 0, 1, 2) And 结帐id = v_结帐id And Rownum = 1;
  End If;

  If Nvl(退费_In, 0) <> 0 Then
    Update 门诊费用记录 Set 记录状态 = 3 Where 记录性质 = 1 And NO = No_In And 记录状态 = 1 And 序号 = v_序号;
  End If;
  If Nvl(更新预交_In, 0) = 1 Then
    Update 病人预交记录
    Set 冲预交 = Nvl(冲预交, 0) + v_Sign * Nvl(误差_In, 0)
    Where 结帐id = v_结帐id And 结算方式 Is Null;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费误差_Insert;
/

--99878:冉俊明,2017-05-26,同一收费项目多个价格管理
Create Or Replace Procedure Zl_门诊收费结算_完成收费
(
  病人id_In     门诊费用记录.病人id%Type,
  结算序号id_In 病人预交记录.结算序号%Type,
  缴款_In       病人预交记录.缴款%Type := Null,
  找补_In       病人预交记录.找补%Type := Null,
  误差金额_In   门诊费用记录.实收金额%Type := Null,
  结算方式_In   病人预交记录.结算方式%Type := Null,
  预存款_In     病人预交记录.冲预交%Type := Null,
  退支票额_In   病人预交记录.冲预交%Type := Null,
  收费结算_In   Varchar2 := Null
) As
  --功能:完成收费处理
  --入参:结算方式_In-只针对全免费用的数据(即:一张单据中实收金额为零的费用)
  --收费结算_IN:格式="结算方式|结算金额|结算号码|结算摘要||.....",注意无结算号码和摘要时要用空格填充
  --预存款_IN:冲预存款

  --该游标用于收费冲预交的可用预交列表
  --先缴先用
  --不包含结算方式为代收款项的预交款。
  Cursor c_Deposit(v_病人id 病人信息.病人id%Type) Is
    Select a.No, Sum(Nvl(a.金额, 0) - Nvl(a.冲预交, 0)) As 金额, Nvl(Max(a.结帐id), 0) As 结帐id,
           Max(Decode(a.记录性质, 1, a.记录状态, 1)) As 记录状态,
           Max(Decode(a.记录性质, 1, Decode(a.记录状态, 1, a.Id, 3, a.Id, 0), 0)) As ID,
           Max(Decode(a.记录性质, 1, Decode(a.记录状态, 1, a.收款时间, 3, a.收款时间, Null, Null))) As 收款时间
    From 病人预交记录 A
    Where a.记录性质 In (1, 11) And a.病人id = v_病人id And a.预交类别 = 1 And
          a.结算方式 Not In (Select 名称 From 结算方式 Where 性质 = 5)
    Group By a.No
    Having Sum(Nvl(a.金额, 0) - Nvl(a.冲预交, 0)) <> 0
    Order By 收款时间;

  Cursor c_Balancedata(n_结帐id 病人预交记录.结帐id%Type) Is
    Select 记录性质, NO, 记录状态, 病人id, 主页id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号

    
    From 病人预交记录
    Where 结帐id = n_结帐id And 结算方式 Is Null;
  r_Balancedata c_Balancedata%RowType;

  v_Err_Msg Varchar2(255);
  Err_Item Exception;
  v_操作员姓名 病人预交记录.操作员姓名%Type;
  v_误差no     门诊费用记录.No%Type;
  v_Maxno      门诊费用记录.No%Type;
  n_误差结帐id 病人预交记录.结帐id%Type;
  n_Count      Number;
  v_结帐ids    Varchar2(500);
  n_Max结帐id  病人预交记录.结帐id%Type;
  n_执行状态   门诊费用记录.执行状态%Type;
  l_结帐id     t_Numlist := t_Numlist();
  n_病人id     病人预交记录.病人id%Type;
  ------------------------------------------------------------
  --结算方式串
  v_结算内容 Varchar2(3000);
  v_当前结算 Varchar2(150);
  v_结算方式 病人预交记录.结算方式%Type;

  n_结算金额     病人预交记录.冲预交%Type;
  v_结算号码     病人预交记录.结算号码%Type;
  v_结算摘要     病人预交记录.摘要%Type;
  n_冲预交       病人预交记录.冲预交%Type;
  n_当前剩余预交 病人预交记录.冲预交%Type;
  --------------------------------------------------------------
  --预存款
  n_预交金额 病人预交记录.冲预交%Type;
  n_返回值   病人预交记录.冲预交%Type;
  n_发送号   病人医嘱发送.发送号%Type;

Begin
  n_Max结帐id  := 0;
  n_误差结帐id := 0;
  v_操作员姓名 := Null;

  For v_结帐 In (Select 结帐id, Max(Decode(结算方式, Null, '-', '')) As 结算方式, Max(Decode(结算方式, Null, 冲预交, 0)) As 冲预交,
                      Max(Decode(记录性质, 1, Null, 11, Null, 操作员姓名)) As 操作员姓名,
                      Max(Decode(记录性质, 1, Null, 11, Null, NO)) As NO
               From 病人预交记录
               Where Nvl(病人id, 0) = Nvl(病人id_In, 0) And (结算序号 = 结算序号id_In Or 结帐id = 结算序号id_In)
               Group By 结帐id
               Order By 结帐id) Loop
  
    If Nvl(n_Max结帐id, 0) < Nvl(v_结帐.结帐id, 0) Then
      n_Max结帐id := Nvl(v_结帐.结帐id, 0);
      v_Maxno     := v_结帐.No;
    End If;
    If v_结帐.操作员姓名 Is Not Null And v_操作员姓名 Is Null Then
      v_操作员姓名 := v_结帐.操作员姓名;
    End If;
  
    If Nvl(v_结帐.结算方式, '-') = '-' And Floor(Abs(v_结帐.冲预交) * 10) <> Abs(v_结帐.冲预交) * 10 Then
      --存在分币小数,则可能需要处理分币,误差放在有小数的单据上
      n_误差结帐id := Nvl(v_结帐.结帐id, 0);
      v_误差no     := v_结帐.No;
    End If;
    l_结帐id.Extend;
    l_结帐id(l_结帐id.Count) := v_结帐.结帐id;
  End Loop;

  If l_结帐id.Count = 0 Or Nvl(n_Max结帐id, 0) = 0 Then
    v_Err_Msg := '未找到相关的结帐数据,不能完成收费,请与系统管员联系！';
    Raise Err_Item;
  End If;
  If Nvl(n_误差结帐id, 0) = 0 Then
    n_误差结帐id := n_Max结帐id;
    v_误差no     := v_Maxno;
  End If;

  n_病人id := Nvl(病人id_In, 0);
  If n_病人id = 0 Then
    n_病人id := Null;
  End If;

  If v_操作员姓名 Is Null Or v_误差no Is Null Or Nvl(n_误差结帐id, 0) = 0 Then
    Begin
      Select NO, 操作员姓名, 结帐id, 病人id
      Into v_误差no, v_操作员姓名, n_误差结帐id, n_病人id
      From 门诊费用记录
      Where 结帐id = Nvl(n_Max结帐id, 0) And Rownum = 1;
    Exception
      When Others Then
        n_误差结帐id := 0;
    End;
  End If;

  Open c_Balancedata(n_Max结帐id);
  Fetch c_Balancedata
    Into r_Balancedata;

  If Nvl(误差金额_In, 0) <> 0 Then
    --：填写门诊收费时所产生的误差费用,以保证与结算金额一致。
    --误差处理规则:放在存在小数结算的最后一张单据
    Zl_门诊收费误差_Insert(v_误差no, 误差金额_In, 0, 0);
    Update 病人预交记录
    Set 冲预交 = Nvl(冲预交, 0) + Nvl(误差金额_In, 0)
    Where 结帐id = n_误差结帐id And 结算方式 Is Null;
    If Sql%NotFound Then
      --插入保存数据
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款, 找补, 缴款组id, 结算序号, 结算性质)
        Select 病人预交记录_Id.Nextval, 3, v_误差no, 1, 病人id, 主页id, Null, Null, Null, 收款时间, 操作员编号, 操作员姓名, Nvl(误差金额_In, 0),
               n_误差结帐id, 0, 0, 缴款组id, 结算序号, 3
        From 病人预交记录
        Where 结帐id = n_Max结帐id And Rownum < 2;
    End If;
  End If;

  If Nvl(预存款_In, 0) <> 0 Then
  
    If Nvl(n_病人id, 0) = 0 Then
      v_Err_Msg := '不能确定病人的病人ID,收费使用预交款结算失败！';
      Raise Err_Item;
    End If;
  
    n_预交金额 := 预存款_In;
    For v_预交 In (Select /*+ rule */
                 Distinct c.结帐id, Max(c.冲预交) As 冲预交, Max(a.No) As NO
                 From 门诊费用记录 A, 病人预交记录 C, Table(l_结帐id) B
                 Where a.结帐id = c.结帐id And a.结帐id = b.Column_Value And c.结算方式 Is Null
                 Group By c.结帐id
                 Order By 结帐id) Loop
      If Nvl(n_预交金额, 0) > Nvl(v_预交.冲预交, 0) Then
        n_冲预交   := Nvl(v_预交.冲预交, 0);
        n_预交金额 := Nvl(n_预交金额, 0) - Nvl(v_预交.冲预交, 0);
      Else
        n_冲预交   := Nvl(n_预交金额, 0);
        n_预交金额 := 0;
      End If;
    
      If n_冲预交 <> 0 Then
        Update 病人预交记录 Set 冲预交 = Nvl(冲预交, 0) - n_冲预交 Where 结算方式 Is Null And 结帐id = v_预交.结帐id;
        n_当前剩余预交 := n_冲预交;
        For r_Deposit In c_Deposit(n_病人id) Loop
          If n_当前剩余预交 >= Nvl(r_Deposit.金额, 0) Then
            n_当前剩余预交 := n_当前剩余预交 - Nvl(r_Deposit.金额, 0);
            n_冲预交       := Nvl(r_Deposit.金额, 0);
          Else
            n_冲预交       := Nvl(n_当前剩余预交, 0);
            n_当前剩余预交 := 0;
          End If;
          If n_冲预交 <> 0 Then
          
            If r_Deposit.结帐id = 0 Then
              --第一次冲预交(填上结帐ID,金额为0)
              Update 病人预交记录
              Set 冲预交 = 0, 结帐id = v_预交.结帐id, 结算序号 = 结算序号id_In, 结算性质 = 3
              Where ID = r_Deposit.Id;
            End If;
          
            --冲上次剩余额
            Insert Into 病人预交记录
              (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号,
               冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
              Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                     r_Balancedata.收款时间, r_Balancedata.操作员姓名, r_Balancedata.操作员编号,
                     Decode(Sign(r_Deposit.金额 - n_冲预交), -1, r_Deposit.金额, n_冲预交), v_预交.结帐id, r_Balancedata.缴款组id, 预交类别,
                     卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号id_In, 3
              From 病人预交记录
              Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
          
          End If;
          If Nvl(n_当前剩余预交, 0) = 0 Then
            Exit;
          End If;
        End Loop;
      
        --检查金额是否足够
        If Nvl(n_当前剩余预交, 0) > 0 Then
          v_Err_Msg := '病人的当前预交余额不足金额 ' || LTrim(To_Char(预存款_In, '9999999990.00')) || ' ！';
          Raise Err_Item;
        End If;
      End If;
      If Nvl(n_预交金额, 0) = 0 Then
        Exit;
      End If;
    End Loop;
    --检查金额是否足够
    If n_预交金额 > 0 Then
      v_Err_Msg := '病人的当前预交余额不足金额 ' || LTrim(To_Char(预存款_In, '9999999990.00')) || ' ！';
      Raise Err_Item;
    End If;
  
    --更新病人预交余额
    Update 病人余额
    Set 预交余额 = Nvl(预交余额, 0) - Nvl(预存款_In, 0)
    Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1
    Returning 预交余额 Into n_返回值;
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 预交余额, 性质, 类型) Values (病人id_In, -预存款_In, 1, 1);
      n_返回值 := -预存款_In;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
    End If;
    If n_返回值 < 0 Then
      v_Err_Msg := '病人的当前预交余额不足金额 ' || LTrim(To_Char(预存款_In, '9999999990.00')) || ' ！';
      Raise Err_Item;
    End If;
  End If;

  If 收费结算_In Is Not Null Then
    If Nvl(退支票额_In, 0) <> 0 Then
      Begin
        Select b.名称
        Into v_结算方式
        From 结算方式应用 A, 结算方式 B
        Where a.应用场合 = '收费' And b.名称 = a.结算方式 And Nvl(b.应付款, 0) = 1 And Rownum <= 1;
      Exception
        When Others Then
          v_结算方式 := Null;
      End;
      If v_结算方式 Is Null Then
        v_Err_Msg := '在结算方式设置中不存在退支票的结算方式,请在结算方式中设置！';
        Raise Err_Item;
      End If;
      --退支票,单独处理
      Update 病人预交记录 Set 冲预交 = Nvl(冲预交, 0) - 退支票额_In Where 结算方式 Is Null And 结帐id = n_Max结帐id;
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款, 找补, 缴款组id, 结算序号, 结算性质)
        Select 病人预交记录_Id.Nextval, 3, NO, 1, 病人id, 主页id, Null, v_结算方式, Null, 收款时间, 操作员编号, 操作员姓名, 退支票额_In, 结帐id, 缴款_In,
               找补_In, 缴款组id, 结算序号, 3
        From 病人预交记录 A
        Where 结帐id = n_Max结帐id And 结算方式 Is Null;
    End If;
    --各个收费结算
    v_结算内容 := 收费结算_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
      If Nvl(n_结算金额, 0) <> 0 Then
        For v_预交 In (Select /*+ rule */
                     Distinct c.结帐id, Max(c.冲预交) As 冲预交, Max(a.No) As NO
                     From 门诊费用记录 A, 病人预交记录 C, Table(l_结帐id) B
                     Where a.结帐id = c.结帐id And a.结帐id = b.Column_Value And c.结算方式 Is Null
                     Group By c.结帐id
                     Order By 结帐id) Loop
          n_冲预交 := Nvl(n_结算金额, 0);
          If Abs(Nvl(n_结算金额, 0)) > Abs(Nvl(v_预交.冲预交, 0)) Then
            n_冲预交 := Nvl(v_预交.冲预交, 0);
          End If;
          n_结算金额 := Nvl(n_结算金额, 0) - Nvl(n_冲预交, 0);
          If Nvl(n_冲预交, 0) <> 0 Then
            Update 病人预交记录
            Set 冲预交 = Nvl(冲预交, 0) - n_冲预交
            Where 结算方式 Is Null And 结帐id = v_预交.结帐id;
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款, 找补, 缴款组id, 结算序号, 结算性质)
              Select 病人预交记录_Id.Nextval, 3, v_预交.No, 1, 病人id, 主页id, v_结算摘要, v_结算方式, v_结算号码, 收款时间, 操作员编号, 操作员姓名, n_冲预交,
                     结帐id, 缴款_In, 找补_In, 缴款组id, 结算序号, 3
              From 病人预交记录
              Where 结帐id = v_预交.结帐id And 结算方式 Is Null;
          End If;
          If n_结算金额 = 0 Then
            Exit;
          End If;
        End Loop;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --如果本次结算中结算方式为空的记录的冲预交之和为0，也表示全部结算
  Begin
    Select Nvl(Sum(冲预交), 0)
    Into n_预交金额
    From 病人预交记录
    Where 结算序号 = 结算序号id_In And 结算方式 Is Null And Nvl(病人id, 0) = Nvl(病人id_In, 0)
    Group By 结算序号;
  Exception
    When Others Then
      n_预交金额 := 0;
  End;

  If Nvl(n_预交金额, 0) = 0 Then
    Begin
      Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum = 1;
    Exception
      When Others Then
        v_结算方式 := '现金';
    End;
    For v_预交 In (Select Distinct 结帐id, Nvl(冲预交, 0) As 冲预交
                 From 病人预交记录
                 Where 结算序号 = 结算序号id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0) Loop
    
      n_冲预交 := v_预交.冲预交;
      Update 病人预交记录
      Set 冲预交 = Nvl(冲预交, 0) + n_冲预交
      Where 结算方式 = v_结算方式 And 结帐id = v_预交.结帐id;
      If Sql%NotFound Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款, 找补, 缴款组id, 结算序号, 结算性质)
          Select 病人预交记录_Id.Nextval, 3, NO, 1, 病人id, 主页id, 摘要, v_结算方式, v_结算号码, 收款时间, 操作员编号, 操作员姓名, n_冲预交, 结帐id, 缴款_In,
                 找补_In, 缴款组id, 结算序号, 3
          From 病人预交记录
          Where 结帐id = v_预交.结帐id And 结算方式 Is Null;
      End If;
    
      Update 病人预交记录 Set 冲预交 = Nvl(冲预交, 0) - n_冲预交 Where 结算方式 Is Null And 结帐id = v_预交.结帐id;
    End Loop;
  End If;

  --删除已经分摊完成的记录
  Forall I In 1 .. l_结帐id.Count
    Delete 病人预交记录 Where 结帐id = l_结帐id(I) And 结算方式 Is Null And Nvl(冲预交, 0) = 0;

  Update 病人预交记录 Set 缴款 = 缴款_In, 找补 = 找补_In Where 结算序号 = 结算序号id_In;
  Select Count(*) Into n_Count From 病人预交记录 A Where 结算序号 = 结算序号id_In And 结算方式 Is Null;
  If n_Count <> 0 Then
    v_Err_Msg := '还存在未缴款的数据,不能完成结算!';
    Raise Err_Item;
  End If;

  Forall I In 1 .. l_结帐id.Count
    Update 病人预交记录 Set 校对标志 = 0 Where 结帐id = l_结帐id(I) And Nvl(病人id, 0) = Nvl(病人id_In, 0);

  Forall I In 1 .. l_结帐id.Count
    Update 门诊费用记录 Set 执行状态 = 0, 费用状态 = 0 Where 结帐id = l_结帐id(I) And Nvl(费用状态, 0) = 1;

  --更新执行状态
  --执行状态含义：0:未执行;1:完全执行;2:部份执行
  --1:非药品和卫材,如果执行人不为空,则执行状态为1,否则为0
  --2.药品和卫材,如果执行人为空,则为零,否则按如下规则处理:
  --  存在数量与药品收发记录中的数量不等时,则为部分执行,填为2,否则为1完全执行
  For v_费用 In (Select /*+ rule */
                Max(Decode(a.价格父号, Null, a.Id, 0)) ID, NO, Nvl(a.价格父号, a.序号) As 序号, a.收费类别, a.收费细目id, a.执行人, Avg(a.付数) 付数,
                Avg(a.数次) 数次, a.医嘱序号, Max(Nvl(m.跟踪在用, 0)) As 跟踪在用, Max(Nvl(j.诊疗类别, '--')) As 诊疗类别
               From 门诊费用记录 A, Table(l_结帐id) B, 材料特性 M, 病人医嘱记录 J
               Where a.结帐id = b.Column_Value And a.记录性质 = 1 And a.收费细目id + 0 = m.材料id(+) And a.执行时间 Is Not Null And
                     a.医嘱序号 + 0 = j.Id(+)
               Group By NO, Nvl(a.价格父号, a.序号), 收费类别, a.收费细目id, 执行人, a.医嘱序号) Loop
    n_执行状态 := 1;
    If Instr(',5,6,7,', ',' || v_费用.收费类别 || ',') > 0 Or (v_费用.跟踪在用 = 1 And v_费用.收费类别 = '4') Then
      --药品卫生材料,需要检查是否存数据
      Begin
        Select Max(2)
        Into n_执行状态
        From 药品收发记录
        Where 单据 In (24, 8) And NO = v_费用.No And 费用id = v_费用.Id And 审核日期 Is Not Null Having
         Sum(Nvl(付数, 1) * Nvl(实际数量, 0)) <> Nvl(v_费用.付数, 1) * Nvl(v_费用.数次, 0);
      Exception
        When Others Then
          Null;
      End;
    Else
      If Nvl(v_费用.医嘱序号, 0) <> 0 Then
        Begin
          --拒绝执行的,表示未执行
          Select Decode(执行状态, 2, 0, 执行状态), 发送号
          Into n_执行状态, n_发送号
          From 病人医嘱发送
          Where NO = v_费用.No And 记录性质 = 1 And 医嘱id = Nvl(v_费用.医嘱序号, 0);
        Exception
          When Others Then
            n_执行状态 := 0;
        End;
        If Nvl(n_执行状态, 0) = 3 Then
          --分两种情况判断(根据医吃执行计价表中有无数据进行检查)
          --1.无数据,就按以前的统计办法来判断是否部分执行(主要是歉容以前数据)
          --2.有数据,按此表数据统计未执行数量来判断是否部分执行
          Select Count(*)
          Into n_Count
          From 医嘱执行计价 A
          Where 医嘱id = Nvl(v_费用.医嘱序号, 0) And a.发送号 = Nvl(n_发送号, 0) And Rownum <= 1;
        
          If Nvl(n_Count, 0) = 0 Then
            --1.无数据,就按以前的统计办法来判断是否部分执行(主要是歉容以前数据)
            If Instr(',C,D,F,G,K,--,', ',' || v_费用.诊疗类别 || ',') = 0 And Nvl(v_费用.医嘱序号, 0) <> 0 Then
              --总执行与未执数相同,为未执行;未执行数为零,完全执行;否则部分执行
              Begin
                Select Decode(剩余数, 执行总次数, 0, 0, 1, 2)
                Into n_执行状态
                From (Select Max(a.发送数次) As 执行总次数,
                              Max(a.发送数次) - Nvl(Sum(Decode(Nvl(b.执行结果, 0), 1, 1, 0) * Nvl(b.本次数次, 0)), 0) As 剩余数
                       From 病人医嘱发送 A, 病人医嘱执行 B
                       Where a.医嘱id = b.医嘱id(+) And a.发送号 = b.发送号(+) And a.医嘱id = Nvl(v_费用.医嘱序号, 0) And
                             a.发送号 = Nvl(n_发送号, 0));
              Exception
                When Others Then
                  n_执行状态 := 1;
              End;
            End If;
          Else
            --2. 有数据,按此表数据统计未执行数量来判断是否部分执行
            Begin
              Select Decode(Sign(Nvl(未执行数量, 0)), 0, 1, 2)
              Into n_执行状态
              From (Select Sum(Decode(Nvl(b.执行结果, 0), 0, 1, 0) * a.数量) As 未执行数量
                     From 医嘱执行计价 A, 病人医嘱执行 B
                     Where a.医嘱id = b.医嘱id(+) And a.发送号 = b.发送号(+) And a.要求时间 = b.要求时间(+) And a.医嘱id = Nvl(v_费用.医嘱序号, 0) And
                           a.发送号 = Nvl(n_发送号, 0));
            Exception
              When Others Then
                n_执行状态 := 0;
            End;
          End If;
        End If;
      End If;
    End If;
    n_执行状态 := Nvl(n_执行状态, 1);
    Update 门诊费用记录
    Set 执行状态 = n_执行状态
    Where 记录性质 = 1 And 记录状态 = 1 And NO = v_费用.No And Nvl(价格父号, 序号) = v_费用.序号 And 收费细目id = v_费用.收费细目id;
  End Loop;

  For v_缴款 In (Select 结算方式, Sum(Nvl(a.冲预交, 0)) As 冲预交
               From 病人预交记录 A
               Where a.结算序号 = 结算序号id_In And Mod(a.记录性质, 10) <> 1 And Nvl(病人id, 0) = Nvl(病人id_In, 0)
               Group By 结算方式) Loop
  
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + Nvl(v_缴款.冲预交, 0)
    Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = v_缴款.结算方式;
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额
        (收款员, 结算方式, 性质, 余额)
      Values
        (v_操作员姓名, v_缴款.结算方式, 1, Nvl(v_缴款.冲预交, 0));
    End If;
  End Loop;

  --收费后产生导引
  For r_结帐 In (Select Distinct a.结帐id From 病人预交记录 A Where 结算序号 = 结算序号id_In) Loop
    v_结帐ids := v_结帐ids || ',' || r_结帐.结帐id;
  End Loop;
  If v_结帐ids Is Not Null Then
    v_结帐ids := Substr(v_结帐ids, 2);
  End If;
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 4, v_结帐ids;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费结算_完成收费;
/

--99878:冉俊明,2017-05-26,同一收费项目多个价格管理
Create Or Replace Procedure Zl_门诊收费记录_Delete
(
  No_In           门诊费用记录.No%Type,
  操作员编号_In   门诊费用记录.操作员编号%Type,
  操作员姓名_In   门诊费用记录.操作员姓名%Type,
  医保结算方式_In Varchar2 := Null,
  序号_In         Varchar2 := Null,
  结算方式_In     病人预交记录.结算方式%Type := Null,
  误差_In         门诊费用记录.实收金额%Type := 0,
  退费时间_In     门诊费用记录.登记时间%Type := Null,
  回收票据_In     Number := 0,
  退费摘要_In     门诊费用记录.摘要%Type := Null,
  校对标志_In     Number := 0,
  结帐id_In       病人预交记录.结帐id%Type := Null,
  结算序号_In     病人预交记录.结算序号%Type := Null,
  一卡通结算_In   Varchar2 := Null,
  退款操作_In     Number := 0,
  多单据全退_In   Number := 0
) As
  --功能：删除一张门诊收费单据
  --参数：
  --        医保结算方式_IN   =医保退费时,不支持结算作废的结算方式,如果为空表示非医保退费或医保退费全部结算允许作废。
  --        序号_IN           =要退费的项目序号,格式为"1,3,5,6...",缺省NULL表示退"未退的"所有行。
  --        结算方式_IN       =当为部分退费时,退费金额的结算方式。
  --        误差_IN           =指退费时新产生的误差金额,部份退费或医保全退但某种结算退现金时才会产生新的误差。
  --                           此时传入仅用于计算本次退费的结算金额,误差费用记录的处理在本过程执行完后调用Zl_门诊收费误差_Insert产生
  --        回收票据_In       =0:单张全退或多张一起全退时收回票据,注意,多张单据退费循环调本过程时只收回一次。
  --                           1:部份退费不处理票据,通过重打调用单独处理。
  --        校对标志_IN:0-不需要较对;1-需较对(不处理人员缴款余额,不回收票据,不处理预交余额)
  --        一卡通结算_In 全退时传入不原样退回的结算方式；医疗卡部分退费时，传入"结算方式|金额"
  --        退款操作_In:1-进行部分退(将退款方式退到指定的结算方式<结算方式_In>中,0-不指定退款方式)
  --        多单据全退_IN=1-多单据全退(多张单据全退,原样退);0-非原样退
  --该游标为要退费单据的所有原始记录

  --医保全退但某种结算退现金从而产生了新的误差时,排开此处的误差处理,执行完本过程后,界面程序中单独处理新误差
  Cursor c_Bill Is
    Select a.Id, a.No, a.附加标志, a.收费细目id, a.序号, a.价格父号, a.执行状态, a.收费类别, a.付数, a.数次, a.医嘱序号, j.诊疗类别, m.跟踪在用,
           Nvl(a.附加标志, 0) As 误差
    From 门诊费用记录 A, 病人医嘱记录 J, 材料特性 M
    Where a.医嘱序号 = j.Id(+) And a.No = No_In And a.记录性质 = 1 And a.记录状态 In (1, 3) And a.收费细目id + 0 = m.材料id(+) And
          Nvl(a.附加标志, 0) <> Decode(多单据全退_In, 1, 999, 9)
    Order By a.收费细目id, a.序号;
  --:不管原始单据误差,都应该根据当前退费产生的误差项进行处理
  -- Decode(Sign(误差_In), 0, 999, 9)

  --该光标用于处理人员缴款余额中退的不同结算方式的金额
  Cursor c_Money(冲销id_In 病人预交记录.结帐id%Type) Is
    Select 结算方式, 冲预交
    From 病人预交记录
    Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = 冲销id_In And 结算方式 Is Not Null And Nvl(冲预交, 0) <> 0 And Nvl(校对标志, 0) = 0;

  --该游标用于查找收费时使用过的冲预交款记录
  Cursor c_Deposit(V结帐id 病人预交记录.结帐id%Type) Is
    Select ID, 病人id, 冲预交 As 金额, 预交类别
    From 病人预交记录
    Where 记录性质 In (1, 11) And 记录状态 In (1, 3) And 结帐id = V结帐id And Nvl(冲预交, 0) <> 0
    Order By ID Desc;

  n_病人id   病人信息.病人id%Type;
  n_结帐id   门诊费用记录.结帐id%Type;
  n_结算序号 病人预交记录.结算序号%Type;
  n_打印id   票据打印内容.Id%Type;

  n_已退金额 病人预交记录.冲预交%Type;
  n_预交金额 病人预交记录.冲预交%Type;
  n_返回值   病人预交记录.冲预交%Type;
  n_原误差费 门诊费用记录.实收金额%Type;
  --部分退费计算变量
  n_剩余数量 Number;
  n_剩余应收 Number;
  n_剩余实收 Number;
  n_剩余统筹 Number;
  n_准退数量 Number;
  n_退费次数 Number;

  n_应收金额 Number;
  n_实收金额 Number;
  n_统筹金额 Number;
  n_总金额   Number;
  n_费用状态 门诊费用记录.费用状态%Type;
  n_正常退费 Number; --是否第一次退费且全部退费,在每行退费过程中判断得到。
  n_组id     财务缴款分组.Id%Type;

  v_退费结算 结算方式.名称%Type;
  v_结算内容 Varchar2(500);
  n_部分退   Number(2);
  v_当前结算 Varchar2(50);
  v_结算方式 病人预交记录.结算方式%Type;
  n_结算金额 病人预交记录.冲预交%Type;

  l_使用id   t_Numlist := t_Numlist();
  n_Dec      Number;
  d_Date     Date;
  n_Count    Number;
  n_原结帐id Number;

  Err_Item Exception;
  v_Err_Msg      Varchar2(255);
  n_启用模式     Number(3);
  v_Para         Varchar2(1000);
  n_医属执行计价 Number;
  n_会话号       病人预交记录.会话号%Type; --格式：SID+'_'+SERIAL#

  Procedure Zl_Square_Update
  (
    原结帐id_In 病人预交记录.结帐id%Type,
    现结帐id_In 病人预交记录.结帐id%Type,
    缴款组id_In 病人预交记录.缴款组id%Type,
    退款时间_In 病人预交记录.收款时间%Type,
    结算序号_In 病人预交记录.结算序号%Type,
    结算内容_In Varchar2 := Null
  ) As
    n_记录状态 病人卡结算记录.记录状态%Type;
    n_预交id   病人预交记录.Id%Type;
    v_卡号     病人卡结算记录.卡号%Type;
    n_存在卡片 Number;
    d_停用日期 消费卡目录.停用日期%Type;
    n_最大序号 病人卡结算记录.序号%Type;
    n_序号     病人卡结算记录.序号%Type;
    n_余额     消费卡目录.余额%Type;
    n_接口编号 病人卡结算记录.接口编号%Type;
    d_回收时间 消费卡目录.回收时间%Type;
    n_Id       病人预交记录.Id%Type;
  Begin
    n_预交id := 0;
    --处理消费卡,结算卡在上面就已经处理了
    For v_校对 In (Select a.Id As 预交id, c.消费卡id, c.结算金额, c.接口编号, c.卡号, c.序号, c.Id
                 From 病人预交记录 A, 病人卡结算对照 B, 病人卡结算记录 C
                 Where a.Id = b.预交id And b.卡结算id = c.Id And a.记录性质 = 3 And a.记录状态 = 1 And
                       Instr(Nvl(结算内容_In, '_LXH'), ',' || a.结算方式 || ',') = 0 And a.结帐id = 原结帐id_In) Loop
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id = Nvl(v_校对.消费卡id, 0) And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      Else
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id Is Null And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      End If;
    
      If n_记录状态 = 1 Then
        n_记录状态 := 2;
      Else
        n_记录状态 := n_记录状态 + 2;
      End If;
      --多条时,只更新一条
      If n_预交id = 0 Then
        Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id,
           预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
          Select n_预交id, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, 退款时间_In, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
                 -1 * 冲预交, 现结帐id_In, 缴款组id_In, 预交类别, 卡类别id, Nvl(结算卡序号, v_校对.接口编号), 卡号, 交易流水号, 交易说明, 合作单位,
                 Decode(Nvl(校对标志_In, 0), 0, 0, Decode(Nvl(v_校对.消费卡id, 0), 0, 1, 2)), 结算序号_In, 3, n_会话号
          From 病人预交记录 A
          Where ID = v_校对.预交id;
      End If;
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        --消费卡,直接退回卡数据中
        Begin
          Select 卡号, 1, 停用日期, (Select Max(序号) From 消费卡目录 B Where a.卡号 = b.卡号 And a.接口编号 = b.接口编号), 序号, 余额, 接口编号, 回收时间
          Into v_卡号, n_存在卡片, d_停用日期, n_最大序号, n_序号, n_余额, n_接口编号, d_回收时间
          From 消费卡目录 A
          Where ID = v_校对.消费卡id;
        Exception
          When Others Then
            n_存在卡片 := 0;
        End;
      
        --取消停用
        If n_存在卡片 = 0 Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡被他人删除，不能再启用该卡片,请检查！';
          Raise Err_Item;
        End If;
        If Nvl(n_序号, 0) < Nvl(n_最大序号, 0) Then
          v_Err_Msg := '不能启用历史发卡记录(卡号为"' || v_卡号 || '"),请检查！';
          Raise Err_Item;
        End If;
        If Nvl(d_停用日期, To_Date('3000-01-01', 'yyyy-mm-dd')) < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经被他人停用，不能再进行退费,请检查！';
          Raise Err_Item;
        End If;
      
        If d_回收时间 < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经回收，不能退费,请检查！';
          Raise Err_Item;
        End If;
        Update 消费卡目录 Set 余额 = Nvl(余额, 0) + v_校对.结算金额 Where ID = Nvl(v_校对.消费卡id, 0);
      End If;
    
      Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      Insert Into 病人卡结算记录
        (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Select n_Id, 接口编号, 消费卡id, 序号, n_记录状态, 结算方式, -1 * v_校对.结算金额, 卡号, 交易流水号, 交易时间, 备注,
               Decode(消费卡id, Null, 0, 0, 0, 1) As 标志
        From 病人卡结算记录
        Where ID = v_校对.Id;
      Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
    
      If n_记录状态 <> 2 And n_记录状态 <> 1 Then
        Update 病人卡结算记录 Set 记录状态 = 3 Where ID = v_校对.Id;
      End If;
    End Loop;
  End;

Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  Begin
    Select Sid || '_' || Serial# Into n_会话号 From V$session Where Audsid = Userenv('sessionid');
  Exception
    When Others Then
      n_会话号 := Null;
  End;

  n_部分退 := 0;
  --是否已经全部完全执行(只是该单据整张单据的检查)
  Select Nvl(Count(*), 0)
  Into n_Count
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1;
  If n_Count = 0 Then
    v_Err_Msg := '该单据中的项目已经全部完全执行！';
    Raise Err_Item;
  End If;

  --未完全执行的项目是否有剩余数量(只是整张单据的检查)
  --执行状态在原始记录上判断
  Select Nvl(Count(*), 0)
  Into n_Count
  From (Select 序号, Sum(数量) As 剩余数量
         From (Select 记录状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                From 门诊费用记录
                Where NO = No_In And 记录性质 = 1 And Nvl(附加标志, 0) <> 9 And
                      Nvl(价格父号, 序号) In
                      (Select Nvl(价格父号, 序号)
                       From 门诊费用记录
                       Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1)
                Group By 记录状态, Nvl(价格父号, 序号))
         Group By 序号
         Having Sum(数量) <> 0);
  If n_Count = 0 Then
    v_Err_Msg := '该单据中未完全执行部分项目剩余数量为零,没有可以退费的费用！';
    Raise Err_Item;
  End If;
  --确定是否在医嘱执行计价中存在数据,如果存在数据,则根据医嘱执行计价进行退费,否则按旧方式进行处理
  Select Count(1)
  Into n_医属执行计价
  From 门诊费用记录 A, 医嘱执行计价 B
  Where a.医嘱序号 = b.医嘱id And a.记录性质 = 1 And a.No = No_In And a.记录状态 In (1, 3) And Rownum = 1;

  ---------------------------------------------------------------------------------
  --公用变量
  If 退费时间_In Is Not Null Then
    d_Date := 退费时间_In;
  Else
    Select Sysdate Into d_Date From Dual;
  End If;
  If 结帐id_In Is Null Then
    Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  Else
    n_结帐id := 结帐id_In;
  End If;
  n_结算序号 := 结算序号_In;
  If n_结算序号 Is Null Then
    n_结算序号 := 结帐id_In;
  End If;
  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into n_Dec From Dual;

  --获取结算方式名称
  v_退费结算 := 结算方式_In;
  If v_退费结算 Is Null Then
    Begin
      Select 名称 Into v_退费结算 From 结算方式 Where 性质 = 1;
    Exception
      When Others Then
        v_退费结算 := '现金';
    End;
  End If;
  --循环处理每行费用(收入项目行)
  n_总金额   := 0;
  n_正常退费 := 1;
  For r_Bill In c_Bill Loop
    If Instr(',' || 序号_In || ',', ',' || Nvl(r_Bill.价格父号, r_Bill.序号) || ',') > 0 Or 序号_In Is Null Then
      If Nvl(r_Bill.执行状态, 0) <> 1 Then
        --求剩余数量,剩余应收,剩余实收
        Select Sum(Nvl(付数, 1) * 数次), Sum(应收金额), Sum(实收金额), Sum(统筹金额)
        Into n_剩余数量, n_剩余应收, n_剩余实收, n_剩余统筹
        From 门诊费用记录
        Where NO = No_In And 记录性质 = 1 And 序号 = r_Bill.序号;
      
        If n_剩余数量 = 0 Then
          If 序号_In Is Not Null Then
            v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经全部退费！';
            Raise Err_Item;
          End If;
          --情况：未限定行号,原始单据中的该笔已经全部退费(执行状态=0的一种可能)
          n_正常退费 := 0;
        Else
          --准退数量(非药品项目为剩余数量,原始数量)
          If Instr(',4,5,6,7,', r_Bill.收费类别) = 0 Or (r_Bill.收费类别 = '4' And Nvl(r_Bill.跟踪在用, 0) = 0) Then
            --@@@
            --非药品部分(以具体医嘱执行为准进行检查)
            --: 1.存在医嘱发送的,则以医嘱执行为准(但不能包含:检查;检验;手术;麻醉及输血)
            --: 2.不存在医嘱的,则以剩余数量为准
            n_Count := 0;
            If Instr(',C,D,F,G,K,', ',' || r_Bill.诊疗类别 || ',') = 0 And r_Bill.诊疗类别 Is Not Null Then
              If n_医属执行计价 = 1 Then
                Select Decode(Sign(Sum(数量)), -1, 0, Sum(数量)), Count(*)
                Into n_准退数量, n_Count
                From (Select Max(Decode(a.记录状态, 2, 0, a.Id)) As ID, Max(a.医嘱序号) As 医嘱id, Max(a.收费细目id) As 收费细目id,
                              Sum(Nvl(a.付数, 1) * Nvl(a.数次, 1)) As 数量,
                              Sum(Decode(a.记录状态, 2, 0, Nvl(a.付数, 1) * Nvl(a.数次, 1))) As 原始数量
                       From 门诊费用记录 A, 病人医嘱记录 M
                       Where a.医嘱序号 = m.Id And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                             Instr('5,6,7', a.收费类别) = 0 And a.No = No_In And a.序号 = r_Bill.序号 And a.记录性质 = 1 And
                             a.记录状态 In (1, 2, 3) And a.价格父号 Is Null
                       Group By a.序号
                       Union All
                       Select a.Id, a.医嘱序号 As 医嘱id, a.收费细目id, -1 * b.数量 As 已执行, 0 原始数量
                       From 门诊费用记录 A, 医嘱执行计价 B, 病人医嘱记录 M
                       Where a.医嘱序号 = b.医嘱id And a.收费细目id = b.收费细目id + 0 And a.医嘱序号 = m.Id And
                             Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Instr('5,6,7', a.收费类别) = 0 And
                             (Exists
                              (Select 1
                               From 病人医嘱执行
                               Where b.医嘱id = 医嘱id And b.发送号 = 发送号 And b.要求时间 = 要求时间 And Nvl(执行结果, 0) = 1) Or Exists
                              (Select 1
                               From 病人医嘱发送
                               Where b.医嘱id = 医嘱id And b.发送号 = 发送号 And Nvl(执行状态, 0) = 1)) And Not Exists
                        (Select 1
                              From 病人医嘱附费
                              Where a.医嘱序号 = 医嘱id And a.No = NO And Mod(a.记录性质, 10) = 记录性质) And a.No = No_In And
                             a.序号 = r_Bill.序号 And a.记录性质 = 1 And a.记录状态 In (1, 3) 　and a.价格父号 Is Null) Q1
                Where Not Exists (Select 1
                       From 药品收发记录
                       Where 费用id = Q1.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0) Having
                 Max(ID) <> 0;
              Else
              
                Select Nvl(Sum(数量), 0), Count(*)
                Into n_准退数量, n_Count
                From (Select a.医嘱id, a.收费细目id, Nvl(a.数量, 1) * Nvl(b.发送数次, 1) As 数量
                       From 病人医嘱计价 A, 病人医嘱发送 B, 门诊费用记录 J, 病人医嘱记录 M
                       Where a.医嘱id = b.医嘱id And a.医嘱id = m.Id And Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And
                             a.收费细目id = j.收费细目id And j.No = No_In And j.记录性质 = 1 And j.序号 = r_Bill.序号 And
                             j.记录状态 In (1, 3) And j.价格父号 Is Null And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                             Exists
                        (Select 1
                              From 病人医嘱计价 A
                              Where a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And Nvl(a.收费方式, 0) = 0) And Not Exists
                        (Select 1
                              From 药品收发记录
                              Where 费用id = j.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0)
                       Union All
                       Select a.医嘱id, a.收费细目id, -1 * Nvl(a.数量, 1) * Nvl(c.本次数次, 1) As 数量
                       From 病人医嘱计价 A, 病人医嘱发送 B, 病人医嘱执行 C, 门诊费用记录 J, 病人医嘱记录 M
                       Where a.医嘱id = b.医嘱id And b.医嘱id = c.医嘱id And b.发送号 = c.发送号 And a.医嘱id = m.Id And
                             Nvl(c.执行结果, 1) = 1 And Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And
                             j.No = No_In And j.记录性质 = 1 And Nvl(a.收费方式, 0) = 0 And j.序号 = r_Bill.序号 And j.记录状态 In (1, 3) And
                             j.价格父号 Is Null And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Not Exists
                        (Select 1
                              From 药品收发记录
                              Where 费用id = j.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0) And Not Exists
                        (Select 1 From 材料特性 Where 材料id = j.收费细目id And Nvl(跟踪在用, 0) = 1)
                       Union All
                       Select a.医嘱序号 As 医嘱id, a.收费细目id, Nvl(a.付数, 1) * a.数次 As 数量
                       From 门诊费用记录 A, 病人医嘱记录 M
                       Where a.医嘱序号 = m.Id And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And a.No = No_In And
                             a.记录性质 = 1 And a.序号 = r_Bill.序号 And a.记录状态 = 2 And a.价格父号 Is Null And Not Exists
                        (Select 1 From 药品收发记录 Where NO = No_In And 单据 In (8, 24) And 药品id = a.收费细目id));
              End If;
            End If;
            If Nvl(n_Count, 0) <> 0 And n_准退数量 = 0 Then
              v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已执行,不允许退费！';
              Raise Err_Item;
            End If;
          
            If Nvl(n_Count, 0) = 0 Then
              n_准退数量 := n_剩余数量;
            End If;
          
          Else
            Select Nvl(Sum(Nvl(付数, 1) * 实际数量), 0), Count(*)
            Into n_准退数量, n_Count
            From 药品收发记录
            Where NO = No_In And 单据 In (8, 24) And Mod(记录状态, 3) = 1 --@@@
                  And 审核人 Is Null And 费用id = r_Bill.Id;
          
            --有剩余数量无准退数量的有两种情况：
            --1.不跟踪在用的卫材无对应的收发记录,这时使用剩余数量
            --2.并发操作,此时已发药或发料
            If n_准退数量 = 0 Then
              If r_Bill.收费类别 = '4' Then
                If n_Count > 0 Then
                  v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发料,须退料后再退费！';
                  Raise Err_Item;
                Else
                  n_准退数量 := n_剩余数量;
                End If;
              Else
                v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发药,须退药后再退费！';
                Raise Err_Item;
              End If;
            End If;
          End If;
        
          --是否部分退费
          If r_Bill.执行状态 = 2 Or n_准退数量 <> Nvl(r_Bill.付数, 1) * r_Bill.数次 Then
            n_正常退费 := 0;
          End If;
        
          --处理门诊费用记录
          n_费用状态 := 0;
          --该笔项目第几次退费
          If Nvl(校对标志_In, 0) <> 0 Then
            n_退费次数 := -9; --先标明,固定为9
            n_费用状态 := 1;
          Else
            Select Nvl(Max(Abs(执行状态)), 0) + 1
            Into n_退费次数
            From 门诊费用记录
            Where NO = No_In And 记录性质 = 1 And 记录状态 = 2 And Nvl(执行状态, 0) < 0 And 序号 = r_Bill.序号;
          End If;
        
          --金额=剩余金额*(准退数/剩余数)
          If Nvl(r_Bill.误差, 0) = 9 Then
            --误差可以超过设置的小数位(比如:医保结算超过小数位后,误差就可能超过小数位
            n_应收金额 := Round(n_剩余应收 * (n_准退数量 / n_剩余数量), 5);
            n_实收金额 := Round(n_剩余实收 * (n_准退数量 / n_剩余数量), 5);
            n_统筹金额 := Round(n_剩余统筹 * (n_准退数量 / n_剩余数量), 5);
          Else
            n_应收金额 := Round(n_剩余应收 * (n_准退数量 / n_剩余数量), n_Dec);
            n_实收金额 := Round(n_剩余实收 * (n_准退数量 / n_剩余数量), n_Dec);
            n_统筹金额 := Round(n_剩余统筹 * (n_准退数量 / n_剩余数量), n_Dec);
          End If;
          n_总金额 := n_总金额 + n_实收金额;
        
          --插入退费记录
          Insert Into 门诊费用记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别,
             收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人,
             执行状态, 费用状态, 执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 结论,
             缴款组id)
            Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别,
                   病人科室id, 收费类别, 收费细目id, 计算单位, Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, 付数, 1), 发药窗口,
                   Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, -1 * 数次, -1 * n_准退数量), 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价,
                   -1 * n_应收金额, -1 * n_实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, -1 * n_退费次数, n_费用状态, 执行时间, 操作员编号_In,
                   操作员姓名_In, 发生时间, d_Date, n_结帐id, -1 * n_实收金额, 保险项目否, 保险大类id, -1 * n_统筹金额, Nvl(退费摘要_In, 摘要),
                   Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, 结论, n_组id
            From 门诊费用记录
            Where ID = r_Bill.Id;
        
          --标记原费用记录
          --执行状态:全部退完(准退数=剩余数)标记为0,否则标记为1,异常收费单,还是标明9
          Update 门诊费用记录
          Set 记录状态 = 3, 执行状态 = Decode(Nvl(执行状态, 0), 9, 9, Decode(Sign(n_准退数量 - n_剩余数量), 0, 0, 1))
          Where ID = r_Bill.Id;
        End If;
      Else
        If 序号_In Is Not Null Then
          v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经完全执行,不能退费！';
          Raise Err_Item;
        End If;
        --情况:没限定行号,原始单据中包括已经完全执行的
        n_正常退费 := 0;
      End If;
    Else
      n_正常退费 := 0; --未指定该笔,属于部分退费
    End If;
  End Loop;
  ---------------------------------------------------------------------------------
  --处理病人预交记录

  --原单据的结帐ID
  Select 结帐id, 病人id
  Into n_原结帐id, n_病人id
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Rownum = 1;

  If n_正常退费 = 1 And Nvl(退款操作_In, 0) = 0 Then
    --单据第一次退费且全部退完
    --冲预交部分记录
    Insert Into 病人预交记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交, 结帐id,
       缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
      Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, d_Date,
             操作员姓名_In, 操作员编号_In, -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
             Decode(校对标志_In, 1, 2, 校对标志_In), n_结算序号, 3, n_会话号
      From 病人预交记录
      Where 记录性质 In (1, 11) And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0;
    If Nvl(校对标志_In, 0) = 0 Then
      --处理病人预交余额
      For v_预交 In (Select 预交类别, Nvl(Sum(Nvl(冲预交, 0)), 0) As 预交金额, 病人id
                   From 病人预交记录
                   Where 记录性质 In (1, 11) And 结帐id = n_原结帐id
                   Group By 预交类别, 病人id
                   Having Sum(Nvl(冲预交, 0)) <> 0) Loop
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) + Nvl(v_预交.预交金额, 0)
        Where 病人id = v_预交.病人id And 性质 = 1 And 类型 = Nvl(v_预交.预交类别, 2)
        Returning 预交余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 病人余额
            (病人id, 类型, 预交余额, 性质)
          Values
            (v_预交.病人id, Nvl(v_预交.预交类别, 2), Nvl(v_预交.预交金额, 0), 1);
          n_返回值 := n_预交金额;
        End If;
        If n_返回值 = 0 Then
          Delete From 病人余额
          Where 病人id = v_预交.病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
        End If;
      End Loop;
    End If;
    --非医保全退,和医保所有结算方式都允许回退,原样退回(冲预交在前面已处理)
    If 医保结算方式_In Is Null Then
      v_结算内容 := ',' || Nvl(一卡通结算_In, '-Lxh') || ',' || Nvl(一卡通结算_In, 'Lxh') || ',';
    
      --一卡通或消费卡或银行卡的相关数据需要特殊处理,需要最后较对.
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
         卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
        Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, d_Date, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
               -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
               Case
                 When Nvl(卡类别id, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(结算卡序号, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(q.预交id, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(j.名称, '-') <> '-' Then
                  Decode(校对标志_In, 1, 1, 0)
                 Else
                  Decode(校对标志_In, 1, 2, 0)
               End As 校对标志, n_结算序号, 3, n_会话号
        From 病人预交记录 A, (Select 名称 From 结算方式 Where 性质 In (3, 4)) J,
             (Select m.Id As 预交id
               From 病人预交记录 M, 一卡通目录 C
               Where m.结帐id = n_原结帐id And m.结算方式 = c.结算方式 And m.记录性质 = 3 And m.记录状态 = 1) Q
        Where a.记录性质 = 3 And a.记录状态 = 1 And a.结帐id = n_原结帐id And a.Id = q.预交id(+) And a.结算方式 = j.名称(+) And
              Instr(v_结算内容, ',' || 结算方式 || ',') = 0 And
              (Not Exists (Select 1 From 病人卡结算对照 Where a.Id = 预交id) Or Nvl(结算卡序号, 0) = 0);
    
      --处理消费卡,结算卡在上面就已经处理了
      Zl_Square_Update(n_原结帐id, n_结帐id, n_组id, d_Date, n_结算序号, v_结算内容);
      --b.余下的就是三方接口支持的退现了,不允许作废的结算方式,加上到指定的结算方式上,加上误差(因为界面程序会在这之后退误差)
      If 一卡通结算_In Is Not Null Then
        Begin
          Select -1 * Nvl(Sum(冲预交), 0) Into n_已退金额 From 病人预交记录 Where 结帐id = n_结帐id;
        Exception
          When Others Then
            n_已退金额 := 0;
        End;
      
        If (n_总金额 - n_已退金额) <> 0 Then
          --此时的总金额还没有包含误差,因为界面程序中在调用本过程后才产生误差费用记录
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号,
             交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
            Select 病人预交记录_Id.Nextval, 3, NO, 2, 病人id, 主页id, '门诊退费结算', v_退费结算, d_Date, 操作员编号_In, 操作员姓名_In,
                   -1 * (n_总金额 - n_已退金额), n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
                   Decode(校对标志_In, 1, 2, 0), n_结算序号, 3, n_会话号
            From 病人预交记录
            Where 记录性质 = 3 And 记录状态 = 1 And 结帐id = n_原结帐id And Rownum = 1;
          n_部分退 := 1;
        End If;
      End If;
      --医保按允许作废的结算方式退,不允许的,退到指定的结算方式上
      --需要处理误差金额
    Else
      --a.原样退回
      v_结算内容 := ',' || 医保结算方式_In || ',' || Nvl(一卡通结算_In, '-Lxh') || ',' || v_退费结算 || ',';
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
        Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, d_Date, 操作员编号_In, 操作员姓名_In, -1 * 冲预交, n_结帐id,
               n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
               
               Case
                 When Nvl(卡类别id, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(结算卡序号, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(q.预交id, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(j.名称, '-') <> '-' Then
                  Decode(校对标志_In, 1, 1, 0)
                 Else
                  Decode(校对标志_In, 1, 2, 0)
               End As 校对标志, n_结算序号, 3, n_会话号
        From 病人预交记录 A, (Select 名称 From 结算方式 Where 性质 In (3, 4)) J,
             (Select m.Id As 预交id
               From 病人预交记录 M, 一卡通目录 C
               Where m.结帐id = n_原结帐id And m.结算方式 = c.结算方式 And m.记录性质 = 3 And m.记录状态 = 1) Q
        Where a.记录性质 = 3 And a.记录状态 = 1 And a.结算方式 = j.名称(+) And a.结帐id = n_原结帐id And
              Instr(v_结算内容, ',' || a.结算方式 || ',') = 0 And a.Id = q.预交id(+) And
              (Not Exists (Select 1 From 病人卡结算对照 Where a.Id = 预交id) Or Nvl(结算卡序号, 0) = 0);
    
      --处理消费卡,结算卡在上面就已经处理了
      Zl_Square_Update(n_原结帐id, n_结帐id, n_组id, d_Date, n_结算序号, v_结算内容);
    
      --b.余下的就是医保不允许作废的结算方式,加上到指定的结算方式上,加上误差(因为界面程序会在这之后退误差)
      Begin
        Select -1 * Nvl(Sum(冲预交), 0) Into n_已退金额 From 病人预交记录 Where 结帐id = n_结帐id;
      Exception
        When Others Then
          n_已退金额 := 0;
      End;
    
      If (n_总金额 - n_已退金额) <> 0 Then
        --此时的总金额还没有包含误差,因为界面程序中在调用本过程后才产生误差费用记录
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
          Select 病人预交记录_Id.Nextval, 3, NO, 2, 病人id, 主页id, Decode(一卡通结算_In, Null, '门诊医保接口退费', '门诊医保接口和三方接口退费'), v_退费结算,
                 d_Date, 操作员编号_In, 操作员姓名_In, -1 * (n_总金额 - n_已退金额), n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
                 合作单位, Decode(校对标志_In, 1, 2, 0), n_结算序号, 3, n_会话号
          From 病人预交记录
          Where 记录性质 = 3 And 记录状态 = 1 And 结帐id = n_原结帐id And Rownum = 1;
        n_部分退 := 1;
      End If;
    
    End If;
  Else
    -------------------------------------------------
    --部分退费
    n_已退金额 := 0;
    --医疗卡部分退费时，传入:结算方式|金额
    If 一卡通结算_In Is Not Null Then
      If Instr(一卡通结算_In, '|') > 0 Then
        v_当前结算 := 一卡通结算_In;
        v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
        v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
        n_结算金额 := Nvl(To_Number(v_当前结算), 0);
        If Not Nvl(v_结算方式, 'TMP') = 'TMP' Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
             卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
            Select 病人预交记录_Id.Nextval, 3, No_In, 2, 病人id, 主页id, '三方接口部分退费', v_结算方式, d_Date, Null, Null, Null, 操作员编号_In,
                   操作员姓名_In, -1 * (n_结算金额), n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
                   Decode(校对标志_In, 1, 1, 0), n_结算序号, 3, n_会话号
            From 病人预交记录
            Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id And Rownum < 2;
        End If;
        n_已退金额 := n_结算金额;
      End If;
    End If;
    --其它直接退为指定结算方式
    If (n_总金额 - n_已退金额 + Nvl(误差_In, 0)) <> 0 Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
         结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
        Select 病人预交记录_Id.Nextval, 3, No_In, 2, 病人id, 主页id, '部分退费结算', v_退费结算, d_Date, Null, Null, Null, 操作员编号_In,
               操作员姓名_In, -1 * (n_总金额 - n_已退金额 + Nvl(误差_In, 0)), n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
               Decode(校对标志, 1, 2, 0), n_结算序号, 3, n_会话号
        From 病人预交记录
        Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id And Rownum = 1;
    End If;
  
    --如果收费时只使用了预交款,则要退预交,并且可能有多笔冲预交
    If Sql%RowCount = 0 And 一卡通结算_In Is Null Then
      n_预交金额 := n_总金额 - n_已退金额 + Nvl(误差_In, 0);
    
      For r_Deposit In c_Deposit(n_原结帐id) Loop
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 d_Date, 操作员姓名_In, 操作员编号_In, Decode(Sign(r_Deposit.金额 - n_预交金额), -1, -1 * r_Deposit.金额, -1 * n_预交金额),
                 n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, Decode(校对标志_In, 1, 2, 0), n_结算序号, 3, n_会话号
          From 病人预交记录
          Where ID = r_Deposit.Id;
      
        If Nvl(校对标志_In, 0) = 0 Then
          --更新病人预交余额
          Update 病人余额
          Set 预交余额 = Nvl(预交余额, 0) + n_总金额 + Nvl(误差_In, 0)
          Where 病人id = r_Deposit.病人id And 性质 = 1 And 类型 = 1
          Returning 预交余额 Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 病人余额
              (病人id, 类型, 预交余额, 性质)
            Values
              (r_Deposit.病人id, 1, n_总金额 + Nvl(误差_In, 0), 1);
            n_返回值 := n_总金额 + Nvl(误差_In, 0);
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 病人余额
            Where 病人id = r_Deposit.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
          End If;
        End If;
      
        --检查是否已经处理完
        If r_Deposit.金额 < n_预交金额 Then
          n_预交金额 := n_预交金额 - r_Deposit.金额;
        Else
          n_预交金额 := 0;
        End If;
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
    End If;
  End If;

  --更新原记录
  Update 病人预交记录 Set 记录状态 = 3 Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id;

  If 多单据全退_In <> 1 Then
    --处理误差项,多单据全退时 ,按原样退无误差处理
    --将误差项的记录状态调整为3
    If Nvl(误差_In, 0) <> 0 Then
      n_Count := 1;
      If n_正常退费 = 1 And Nvl(退款操作_In, 0) = 0 Then
        n_原误差费 := 0;
        --原样退,但存在误差
        If n_部分退 = 0 Then
          Select -1 * Nvl(Sum(实收金额), 0)
          Into n_原误差费
          From 门诊费用记录 A
          Where NO = No_In And a.记录性质 = 1 And a.记录状态 In (1, 3) And Nvl(a.附加标志, 0) = 9;
        End If;
        If Nvl(n_原误差费, 0) <> 0 Or Nvl(误差_In, 0) <> 0 Then
          Update 病人预交记录
          Set 冲预交 = 冲预交 - n_原误差费 - Nvl(误差_In, 0)
          Where 结算方式 = v_退费结算 And 结帐id = n_结帐id;
          If Sql%NotFound Then
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
               卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
              Select 病人预交记录_Id.Nextval, 3, No_In, 2, 病人id, 主页id, '误差费', v_退费结算, d_Date, Null, Null, Null, 操作员编号_In,
                     操作员姓名_In, -1 * n_原误差费 - Nvl(误差_In, 0), n_结帐id, n_组id, 预交类别, Null, Null, Null, Null, Null, Null, 0,
                     n_结算序号, 3, n_会话号
              From 病人预交记录
              Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id And Rownum = 1;
          End If;
        End If;
      End If;
    Elsif n_正常退费 = 1 And Nvl(退款操作_In, 0) = 0 Then
      --原样退时,需要处理预交记录不足的情况
      Select Nvl(Sum(Nvl(结帐金额, 0)), 0) Into n_实收金额 From 门诊费用记录 Where 结帐id = n_结帐id;
      Select Nvl(Sum(Nvl(冲预交, 0)), 0) Into n_返回值 From 病人预交记录 Where 结帐id = n_结帐id;
      If Abs(n_实收金额) <> Abs(n_返回值) Then
        n_实收金额 := n_实收金额 - n_返回值;
        Update 病人预交记录 Set 冲预交 = 冲预交 + Nvl(n_实收金额, 0) Where 结算方式 = v_退费结算 And 结帐id = n_结帐id;
        If Sql%NotFound Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
             卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
            Select 病人预交记录_Id.Nextval, 3, No_In, 2, 病人id, 主页id, '误差费', v_退费结算, d_Date, Null, Null, Null, 操作员编号_In,
                   操作员姓名_In, Nvl(n_实收金额, 0), n_结帐id, n_组id, 预交类别, Null, Null, Null, Null, Null, Null, 0, n_结算序号, 3,
                   n_会话号
            From 病人预交记录
            Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id And Rownum = 1;
        End If;
      End If;
    End If;
  
    Select Nvl(Sum(Nvl(结帐金额, 0)), 0) Into n_实收金额 From 门诊费用记录 Where 结帐id = n_结帐id;
    Select Nvl(Sum(Nvl(冲预交, 0)), 0) Into n_返回值 From 病人预交记录 Where 结帐id = n_结帐id;
  
    n_实收金额 := n_实收金额 - n_返回值;
  
    If n_实收金额 <> 0 Then
      --未找到，新产生误差项
      Zl_门诊收费误差_Insert(No_In, n_实收金额, 1, 0);
    End If;
  End If;
  ---------------------------------------------------------------------------------
  --人员缴款余额(注意是预交记录处理后才处理，包括个人帐户等的结算金额,不含退冲预交款)
  --如果是需要校对的,暂不处理人员缴款余额
  If Nvl(校对标志_In, 0) = 0 Then
    For r_Moneyrow In c_Money(n_结帐id) Loop
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + r_Moneyrow.冲预交
      Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Moneyrow.结算方式
      Returning 余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (操作员姓名_In, r_Moneyrow.结算方式, 1, r_Moneyrow.冲预交);
        n_返回值 := r_Moneyrow.冲预交;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Moneyrow.结算方式 And Nvl(余额, 0) = 0;
      End If;
    End Loop;
  End If;

  ---------------------------------------------------------------------------------
  --退费票据回收(仅全退时才回退,部分退是在重打过程中回收)
  If 回收票据_In = 0 Then
  
    --启用标志||NO;执行科室(条数);收据费目(首页汇总,条数);收费细目(条数)
    v_Para     := Nvl(zl_GetSysParameter('票据分配规则', 1121), '0||0;0;0,0;0');
    n_启用模式 := Zl_To_Number(Substr(v_Para, 1, 1));
    If n_启用模式 <> 0 Then
      --收回票据
      Select 使用id Bulk Collect
      Into l_使用id
      From (Select Distinct b.使用id From 票据打印明细 B Where b.No = No_In And Nvl(b.票种, 0) = 1);
    
      n_启用模式 := l_使用id.Count;
      If l_使用id.Count <> 0 Then
        --插入回收记录
        Forall I In 1 .. l_使用id.Count
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 操作员姓名_In, d_Date
            From 票据使用明细 A
            Where ID = l_使用id(I) And 性质 = 1 And Not Exists
             (Select 1 From 票据使用明细 Where 号码 = a.号码 And 票种 = a.票种 And Nvl(性质, 0) <> 1);
      
        Forall I In 1 .. l_使用id.Count
          Update 票据打印明细 Set 是否回收 = 1 Where 使用id = l_使用id(I) And Nvl(是否回收, 0) = 0;
      
      End If;
    End If;
    If n_启用模式 = 0 Then
      --获取单据最后一次的打印ID(可能是多张单据收费打印)
      Begin
        --性质=1，原因=6为退费打印票据(红票)，不回收
        Select ID
        Into n_打印id
        From (Select b.Id
               From 票据使用明细 A, 票据打印内容 B
               Where a.打印id = b.Id And a.性质 = 1 And a.原因 In (1, 3) And b.数据性质 = 1 And b.No = No_In
               Order By a.使用时间 Desc)
        Where Rownum < 2;
      Exception
        When Others Then
          Null;
      End;
      --可能以前没有打印,无收回
      If n_打印id Is Not Null Then
        --a.多张单据循环调用时只能收回一次
        Select Count(*) Into n_Count From 票据使用明细 Where 票种 = 1 And 性质 = 2 And 打印id = n_打印id;
        If n_Count = 0 Then
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
            From 票据使用明细
            Where 打印id = n_打印id And 票种 = 1 And 性质 = 1;
        Else
          --b.部分退费多次收回时,最后一次全退收回要排开已收回的
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
            From 票据使用明细 A
            Where 打印id = n_打印id And 票种 = 1 And 性质 = 1 And Not Exists
             (Select 1 From 票据使用明细 B Where a.号码 = b.号码 And 打印id = n_打印id And 票种 = 1 And 性质 = 2);
        End If;
      End If;
    End If;
  End If;

  ---------------------------------------------------------------------------------
  --药品卫材相关内容
  --必须按照“收费细目id”升序排序，防止并发锁“药品库存”表
  For r_Expenses In (Select ID
                     From 门诊费用记录
                     Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And 收费类别 In ('4', '5', '6', '7') And
                           (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null)
                     Order By 收费细目id) Loop
    Zl_药品收发记录_销售退费(r_Expenses.Id);
  End Loop;

  --医嘱处理
  --删除病人医嘱附费(最后一次删除时)
  For c_医嘱 In (Select Distinct 医嘱序号
               From 门诊费用记录
               Where NO = No_In And 记录性质 = 1 And 记录状态 = 3 And 医嘱序号 Is Not Null) Loop
    Select Nvl(Count(*), 0)
    Into n_Count
    From (Select 序号, Sum(数量) As 剩余数量
           From (Select 记录状态, 执行状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                  From 门诊费用记录
                  Where 记录性质 = 1 And Nvl(附加标志, 0) <> 9 And 医嘱序号 + 0 = c_医嘱.医嘱序号 And NO = No_In
                  Group By 记录状态, 执行状态, Nvl(价格父号, 序号))
           Group By 序号
           Having Sum(数量) <> 0);
  
    If n_Count = 0 Then
      Delete From 病人医嘱附费 Where 医嘱id = c_医嘱.医嘱序号 And 记录性质 = 1 And NO = No_In;
    End If;
  End Loop;

  --场合_In    Integer:=0, --0:门诊;1-住院
  --性质_In    Integer:=1, --1-收费单;2-记帐单
  --操作_In    Integer:=0, --0:删除划价单;1-收费或记帐;2-退费或销帐
  --No_In      门诊费用记录.No%Type,
  --医嘱ids_In Varchar2 := Null
  Zl_医嘱发送_计费状态_Update(0, 1, 2, No_In);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费记录_Delete;
/

--99878:冉俊明,2017-05-26,同一收费项目多个价格管理
Create Or Replace Procedure Zl_门诊收费结算_Update
(
  结帐id_In        门诊费用记录.结帐id%Type,
  收费结算_In      Varchar2,
  冲预交额_In      病人预交记录.冲预交%Type,
  保险结算_In      Varchar2,
  误差_In          门诊费用记录.实收金额%Type,
  缴款_In          病人预交记录.缴款%Type := Null,
  找补_In          病人预交记录.找补%Type := Null,
  冲预交病人ids_In Varchar2 := Null,
  是否退费结算_In  Number := 0
) As
  --功能:处理收费时和医保正式结算后,相关结算信息的调整
  --     因为预结算后,生成的医保结算金额总额及分摊可能会与正式结算时有差异,所以提供了校对功能,
  --   操作员在结算校对时,可以调整非医保结算方式的各种结算金额及方式,重新生成结算串,并且可能产生误差金额.
  -- 冲预交病人ids_In:多个用逗分分离,冲预交时有效(冲预交类别与业务操作保持一致),主要是使用家属的预交款
  --是否退费结算_In:是否退费结算调用

  --该游标用于收费冲预交的可用预交列表(该SQL参考住院结帐)
  --先缴先用，且先用自己的
  --不包含结算方式为代收款项的预交款。
  Cursor c_Deposit
  (
    n_病人id        病人信息.病人id%Type,
    v_冲预交病人ids Varchar2
  ) Is
    Select a.No, Sum(Nvl(a.金额, 0) - Nvl(a.冲预交, 0)) As 金额, Nvl(Max(a.结帐id), 0) As 结帐id, Max(病人id) As 病人id,
           Max(Decode(a.记录性质, 1, a.记录状态, 1)) As 记录状态,
           Max(Decode(a.记录性质, 1, Decode(a.记录状态, 1, a.Id, 3, a.Id, 0), 0)) As ID,
           Max(Decode(a.记录性质, 1, Decode(a.记录状态, 1, a.收款时间, 3, a.收款时间, Null, Null))) As 收款时间
    From 病人预交记录 A
    Where a.记录性质 In (1, 11) And a.病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And
          Nvl(a.预交类别, 2) = 1 And a.结算方式 Not In (Select 名称 From 结算方式 Where 性质 = 5)
    Group By a.No
    Having Sum(Nvl(a.金额, 0) - Nvl(a.冲预交, 0)) <> 0
    Order By Decode(病人id, Nvl(n_病人id, 0), 0, 1), 收款时间;

  --过程变量
  v_结算内容 Varchar2(500);
  v_当前结算 Varchar2(50);
  v_结算方式 病人预交记录.结算方式%Type;
  v_结算金额 病人预交记录.冲预交%Type;
  v_结算号码 病人预交记录.结算号码%Type;

  v_费用id 门诊费用记录.Id%Type;
  v_序号   门诊费用记录.序号%Type;

  v_收费类别      门诊费用记录.收费类别%Type;
  v_收费细目id    门诊费用记录.收费细目id%Type;
  v_计算单位      门诊费用记录.计算单位%Type;
  v_收入项目id    门诊费用记录.收入项目id%Type;
  v_收据费目      门诊费用记录.收据费目%Type;
  v_执行部门id    门诊费用记录.执行部门id%Type;
  v_Temp          Varchar2(500);
  n_返回值        人员缴款余额.余额%Type;
  v_No            病人预交记录.No%Type;
  n_病人id        病人预交记录.病人id%Type;
  v_收款时间      病人预交记录.收款时间%Type;
  v_操作员编号    病人预交记录.操作员编号%Type;
  v_操作员姓名    病人预交记录.操作员姓名%Type;
  v_冲预交病人ids Varchar2(4000);
  n_冲预交        病人预交记录.冲预交%Type;

  v_预交金额 病人预交记录.冲预交%Type;
  n_组id     财务缴款分组.Id%Type;
  n_结算序号 病人预交记录.结算序号%Type;
  n_执行状态 门诊费用记录.执行状态%Type;
  n_费用状态 门诊费用记录.费用状态%Type;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --1.取预交记录需要的相关信息
  Select NO, 病人id, 登记时间, 操作员编号, 操作员姓名, 缴款组id, 执行状态, 费用状态
  Into v_No, n_病人id, v_收款时间, v_操作员编号, v_操作员姓名, n_组id, n_执行状态, n_费用状态
  From 门诊费用记录
  Where 结帐id = 结帐id_In And Rownum = 1 And 记录性质 = 1;

  v_冲预交病人ids := Nvl(冲预交病人ids_In, n_病人id);

  --误差相关信息
  Begin
    Select a.类别, a.Id, a.计算单位, c.Id, c.收据费目
    Into v_收费类别, v_收费细目id, v_计算单位, v_收入项目id, v_收据费目
    From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费特定项目 D
    Where d.特定项目 = '误差项' And d.收费细目id = a.Id And a.Id = b.收费细目id And b.收入项目id = c.Id And Sysdate Between b.执行日期 And
          Nvl(b.终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')) And b.价格等级 Is Null;
  Exception
    When Others Then
      Begin
        v_Error := '不能正确读取收费误差项的信息，请先检查该项目是否设置正确。';
        Raise Err_Custom;
      End;
  End;

  Select 结算序号 Into n_结算序号 From 病人预交记录 Where 结帐id = 结帐id_In And Rownum = 1;

  If Nvl(n_费用状态, 0) <> 1 Then
    --2.删除旧的记录,回退汇总数据
    --回退人员缴款余额,病人余额,
    --人员缴款余额中不包含未较对的,未较对的直接删除
    For c_Del In (Select 冲预交, 操作员姓名, 结算方式
                  From 病人预交记录
                  Where 结帐id = 结帐id_In And 记录性质 = 3 And Nvl(校对标志, 0) = 0) Loop
    
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) - Nvl(c_Del.冲预交, 0)
      Where 结算方式 = c_Del.结算方式 And 收款员 = v_操作员姓名 And 性质 = 1
      Returning 余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (v_操作员姓名, c_Del.结算方式, 1, -1 * c_Del.冲预交);
        n_返回值 := -1 * c_Del.冲预交;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 性质 = 1 And 收款员 = v_操作员姓名 And 结算方式 = c_Del.结算方式 And Nvl(余额, 0) = 0;
      End If;
    End Loop;
  End If;
  If n_病人id > 0 Then
    For v_预交 In (Select 预交类别, Nvl(Sum(冲预交), 0) As 预交金额
                 From 病人预交记录
                 Where 结帐id = 结帐id_In And 记录性质 In (1, 11)
                 Group By 预交类别
                 Having Sum(Nvl(冲预交, 0)) <> 0) Loop
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + Nvl(v_预交.预交金额, 0)
      Where 病人id = n_病人id And 性质 = 1 And 类型 = Nvl(v_预交.预交类别, 2);
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (n_病人id, Nvl(v_预交.预交类别, 2), v_预交金额, 1);
      End If;
    
    End Loop;
  End If;

  --回退汇总表
  --只可能产生误差金额的变化,其它的不会变,并且只可能存在一行,仅为了变量处理方便而用游标

  --删除收费结算,保险结算记录
  Delete 病人预交记录 Where 结帐id = 结帐id_In And 记录性质 = 3;
  --第一次冲预交的,清空冲减额
  Update 病人预交记录 Set 冲预交 = Null, 结帐id = Null, 结算性质 = Null Where 结帐id = 结帐id_In And 记录性质 = 1;
  --删除冲余款
  Delete 病人预交记录 Where 结帐id = 结帐id_In And 记录性质 = 11;
  --删除误差记录
  Delete 门诊费用记录 Where 结帐id = 结帐id_In And 附加标志 = 9;

  --3.产生门诊费用记录的误差记录
  If 误差_In <> 0 Then
    Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
    Select Max(序号) + 1 Into v_序号 From 门诊费用记录 Where 结帐id = 结帐id_In And 记录性质 = 1;
    v_Temp       := Zl_Identity;
    v_执行部门id := To_Number(Substr(v_Temp, 1, Instr(v_Temp, ',') - 1));
  
    Insert Into 门诊费用记录
      (ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位,
       发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 记帐费用, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 费用状态,
       结帐id, 结帐金额, 操作员编号, 操作员姓名, 是否上传, 缴款组id)
      Select v_费用id, 记录性质, NO, 实际票号, 记录状态, v_序号, Null, Null, 门诊标志, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 病人科室id, 费别, v_收费类别,
             v_收费细目id, v_计算单位, 发药窗口, 1, 1, 加班标志, 9, v_收入项目id, v_收据费目, 误差_In, 误差_In, 误差_In, 记帐费用, 划价人, 开单部门id, 开单人, 发生时间,
             登记时间, v_执行部门id, 执行状态, 费用状态, 结帐id, 误差_In, 操作员编号, 操作员姓名, 1, 缴款组id
      From 门诊费用记录
      Where 记录性质 = 1 And 结帐id = 结帐id_In And Rownum = 1;
  End If;

  --4.重新生成病人预交记录相关数据
  --4.1.收费结算
  If 收费结算_In Is Not Null Then
    v_结算内容 := 收费结算_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_结算号码 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If Nvl(v_结算金额, 0) <> 0 Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款, 找补, 缴款组id, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, v_No, Decode(是否退费结算_In, 1, 2, 1), n_病人id, Null, Decode(是否退费结算_In, 1, '退费结算', '收费结算'),
           v_结算方式, v_结算号码, v_收款时间, v_操作员编号, v_操作员姓名, v_结算金额, 结帐id_In, Decode(v_结算内容, 收费结算_In || '||', 缴款_In, Null),
           Decode(v_结算内容, 收费结算_In || '||', 找补_In, Null), n_组id, 3);
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --4.2.保险结算
  If 保险结算_In Is Not Null Then
    v_结算内容 := 保险结算_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If Nvl(v_结算金额, 0) <> 0 Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, v_No, Decode(是否退费结算_In, 1, 2, 1), n_病人id, Null, '保险结算', v_结算方式, v_收款时间, v_操作员编号,
           v_操作员姓名, v_结算金额, 结帐id_In, n_组id, n_结算序号, 3);
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --4.3.预交结算
  If Nvl(冲预交额_In, 0) <> 0 Then
    If Nvl(n_病人id, 0) = 0 Then
      v_Error := '不能确定病人的病人ID,收费不能使用预交款结算,结算操作失败！';
      Raise Err_Custom;
    End If;
  
    v_预交金额 := 冲预交额_In;
    For r_Deposit In c_Deposit(n_病人id, v_冲预交病人ids) Loop
      If r_Deposit.金额 - v_预交金额 < 0 Then
        n_冲预交 := r_Deposit.金额;
      Else
        n_冲预交 := v_预交金额;
      End If;
    
      If r_Deposit.结帐id = 0 Then
        --第一次冲预交(填上结帐ID,金额为0)
        Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 3 Where ID = r_Deposit.Id;
      End If;
      --冲上次剩余额
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, v_收款时间,
               v_操作员姓名, v_操作员编号, n_冲预交, 结帐id_In, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 3
        From 病人预交记录
        Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
    
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - n_冲预交
      Where 病人id = r_Deposit.病人id And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (r_Deposit.病人id, 1, -1 * n_冲预交, 1);
        n_返回值 := -1 * n_冲预交;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Deposit.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --检查是否已经处理完
      If r_Deposit.金额 < v_预交金额 Then
        v_预交金额 := v_预交金额 - r_Deposit.金额;
      Else
        v_预交金额 := 0;
      End If;
      If v_预交金额 = 0 Then
        Exit;
      End If;
    End Loop;
    --检查金额是否足够
    If v_预交金额 > 0 Then
      v_Error := '病人的当前预交余额不足金额 ' || LTrim(To_Char(冲预交额_In, '9999999990.00')) || ' ！';
      Raise Err_Custom;
    End If;
  End If;

  --5.相关汇总表的处理
  --汇总"人员缴款余额"
  --收费结算
  If 收费结算_In Is Not Null And Nvl(n_费用状态, 0) <> 1 Then
    v_结算内容 := 收费结算_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      If Nvl(v_结算金额, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + Nvl(v_结算金额, 0)
        Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = v_结算方式;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (v_操作员姓名, v_结算方式, 1, Nvl(v_结算金额, 0));
        End If;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --各个保险结算

  If 保险结算_In Is Not Null And Nvl(n_费用状态, 0) <> 1 Then
    v_结算内容 := 保险结算_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If Nvl(v_结算金额, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + Nvl(v_结算金额, 0)
        Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = v_结算方式;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (v_操作员姓名, v_结算方式, 1, Nvl(v_结算金额, 0));
        End If;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --汇总表,只需重汇误差行,因为其它项不会变
  --6.医保相关表的处理
  --Delete 医保核对表 Where 结帐Id=结帐Id_IN;
  Update 保险结算明细 Set 标志 = 2 Where 结帐id = 结帐id_In;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费结算_Update;
/

--99878:冉俊明,2017-05-26,同一收费项目多个价格管理
Create Or Replace Procedure Zl_门诊转住院结帐_结帐作废
(
  No_In         病人结帐记录.No%Type,
  操作员编号_In 病人结帐记录.操作员编号%Type,
  操作员姓名_In 病人结帐记录.操作员姓名%Type,
  作废日期_In   病人结帐记录.收费时间%Type
) As
  --该游标包含误差项目的相关信息
  Cursor c_Erritem Is
    Select a.类别 As 收费类别, a.Id As 收费细目id, a.计算单位, c.Id As 收入项目id, c.收据费目
    From 收费细目 A, 收费价目 B, 收入项目 C, 收费特定项目 D
    Where d.特定项目 = '误差项' And d.收费细目id = a.Id And a.Id = b.收费细目id And b.收入项目id = c.Id And
          ((Sysdate Between b.执行日期 And b.终止日期) Or (Sysdate >= b.执行日期 And b.终止日期 Is Null)) And b.价格等级 Is Null;
  r_Erritem c_Erritem%RowType;

  --该游标包含病人的相关信息
  Cursor c_Pati(n_病人id 病人信息.病人id%Type) Is
    Select a.姓名, a.性别, a.年龄, a.住院号, a.门诊号, b.主页id, b.出院病床, b.当前病区id, b.出院科室id, Nvl(b.费别, a.费别) As 费别, a.险类, c.编码 As 付款方式
    From 病人信息 A, 病案主页 B, 医疗付款方式 C
    Where a.病人id = n_病人id And a.病人id = b.病人id(+) And Nvl(a.主页id, 0) = b.主页id(+) And a.医疗付款方式 = c.名称(+);
  r_Pati c_Pati%RowType;

  Err_Item Exception;
  v_Err_Msg   Varchar2(255);
  v_Temp      Varchar2(255);
  v_实际票号  病人预交记录.实际票号%Type;
  v_误差no    住院费用记录.No%Type;
  v_预交no    病人预交记录.No%Type;
  v_New误差no 住院费用记录.No%Type;

  n_病人id     病人信息.病人id%Type;
  n_人员部门id 部门人员.部门id%Type;

  n_原结帐id 病人结帐记录.Id%Type;
  n_结帐id   病人结帐记录.Id%Type;
  n_打印id   票据打印内容.Id%Type;

  n_医疗小组id 住院费用记录.医疗小组id%Type;
  n_来源       Number; --1-门诊;2-住院;3-门诊和住院
  n_返回值     病人余额.预交余额%Type;
  n_组id       财务缴款分组.Id%Type;
  v_现金结算   结算方式.名称%Type;
  n_冲预交     病人预交记录.冲预交%Type;
  n_Temp       病人预交记录.冲预交%Type;
  n_误差金额   病人预交记录.冲预交%Type;
  n_原主页id   病人预交记录.主页id%Type;
Begin
  n_组id := Zl_Get组id(操作员姓名_In);
  Begin
    Select 名称 Into v_现金结算 From 结算方式 Where 性质 = 1 And Rownum = 1;
  Exception
    When Others Then
      v_现金结算 := '现金';
  End;

  Begin
    Select ID, 病人id, 实际票号
    Into n_原结帐id, n_病人id, v_实际票号
    From 病人结帐记录
    Where 记录状态 = 1 And NO = No_In;
    --最后一次打印的内容
    Select Max(ID)
    Into n_打印id
    From (Select b.Id
           From 票据使用明细 A, 票据打印内容 B
           Where a.打印id = b.Id And a.性质 = 1 And a.原因 In (1, 3) And b.数据性质 = 3 And b.No = No_In
           Order By a.使用时间 Desc)
    Where Rownum < 2;
  Exception
    When Others Then
      Begin
        v_Err_Msg := '没有发现要作废的结帐单据,可能已经作废！';
        Raise Err_Item;
      End;
  End;

  Open c_Pati(n_病人id);
  Fetch c_Pati
    Into r_Pati; --体检系统调用此过程,团体结帐时没有病人信息

  Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;

  --病人结帐记录
  Insert Into 病人结帐记录
    (ID, NO, 实际票号, 记录状态, 中途结帐, 病人id, 操作员编号, 操作员姓名, 开始日期, 结束日期, 收费时间, 备注, 原因, 缴款组id, 结帐类型)
    Select n_结帐id, NO, 实际票号, 2, 中途结帐, 病人id, 操作员编号_In, 操作员姓名_In, 开始日期, 结束日期, 作废日期_In, 备注, 原因, n_组id, 结帐类型
    From 病人结帐记录
    Where ID = n_原结帐id;

  Update 病人结帐记录 Set 记录状态 = 3 Where ID = n_原结帐id;

  --作废收回票据(可能以前没有使用票据,无法收回)
  If n_打印id Is Not Null Then
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
      Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 作废日期_In, 操作员姓名_In
      From 票据使用明细
      Where 打印id = n_打印id And 票种 = 3 And 性质 = 1;
  End If;
  -------------------------------------------------------------------------------------------------------------
  --冲预交处理
  Select Nvl(Sum(冲预交), 0) Into n_冲预交 From 病人预交记录 A Where Mod(a.记录性质, 10) = 1 And a.结帐id = n_原结帐id;

  n_Temp := Zl_Cent_Money(n_冲预交, 3);
  If n_Temp <> n_冲预交 Then
    --算误差费
    n_误差金额 := n_Temp - n_冲预交;
    n_冲预交   := n_Temp;
  End If;
  --先处理医保结算方式

  For v_预交 In (Select a.Id, a.记录性质, a.结算方式, 冲预交, b.性质, a.主页id
               From 病人预交记录 A, 结算方式 B
               Where a.结帐id = n_原结帐id And Mod(a.记录性质, 10) = 2 And a.结算方式 = b.名称(+)) Loop
    If v_预交.性质 >= 3 Then
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, To_Number('1' || Substr(记录性质, Length(记录性质), 1)), 记录状态, 病人id, 主页id, 科室id,
               Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 作废日期_In, 操作员姓名_In, 操作员编号_In, -1 * 冲预交, n_结帐id, n_组id, 预交类别,
               卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 2
        From 病人预交记录
        Where ID = v_预交.Id;
    Else
      n_冲预交 := Nvl(n_冲预交, 0) + Nvl(v_预交.冲预交, 0);
    End If;
    n_原主页id := Nvl(v_预交.主页id, 0);
  End Loop;
  If Nvl(n_原主页id, 0) = 0 Then
    n_原主页id := Null;
  End If;
  n_冲预交 := Nvl(n_冲预交, 0);
  If n_冲预交 <> 0 Then
    --增加"现金冲回"
    Insert Into 病人预交记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交, 结帐id,
       缴款组id, 结算性质)
    Values
      (病人预交记录_Id.Nextval, No_In, v_实际票号, 12, 1, n_病人id, n_原主页id, r_Pati.出院科室id, Null, v_现金结算, Null, '结帐作废退款', Null,
       Null, Null, 作废日期_In, 操作员姓名_In, 操作员编号_In, -1 * n_冲预交, n_结帐id, n_组id, 2);
  
    --增加:预交款(现金)
    v_预交no := Nextno(11);
    Insert Into 病人预交记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要, 缴款组id,
       预交类别)
    Values
      (病人预交记录_Id.Nextval, v_预交no, Null, 1, 1, n_病人id, r_Pati.主页id, r_Pati.出院科室id, n_冲预交, v_现金结算, Null, 作废日期_In, Null,
       Null, Null, 操作员编号_In, 操作员姓名_In, '门诊转住院预交', n_组id, '2');
  
    Update 病人余额
    Set 预交余额 = Nvl(预交余额, 0) + n_冲预交 --注:新的结帐ID产生的是负数金额
    Where 病人id = n_病人id And 性质 = 1 And 类型 = 2
    Returning 预交余额 Into n_返回值;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 性质, 类型, 预交余额, 费用余额) Values (n_病人id, 2, 1, n_冲预交, 0);
    End If;
  
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + n_冲预交
    Where 收款员 = 操作员姓名_In And 结算方式 = v_现金结算 And 性质 = 1
    Returning 余额 Into n_返回值;
  
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, v_现金结算, 1, n_冲预交);
      n_返回值 := -1 * n_冲预交;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 人员缴款余额
      Where 收款员 = 操作员姓名_In And 结算方式 = v_现金结算 And 性质 = 1 And Nvl(余额, 0) = 0;
    End If;
  End If;
  --住院费用记录
  --读取原结帐时产生的误差费用,并销帐,然后将销帐记录处理在本次结帐作废中
  Begin
    Select NO, 医疗小组id
    Into v_误差no, n_医疗小组id
    From 住院费用记录
    Where 结帐id = n_原结帐id And Nvl(附加标志, 0) = 9 And 记录性质 = 2 And 记录状态 = 1;
    n_来源 := 2;
  Exception
    When Others Then
      Null;
  End;

  If v_误差no Is Null Then
    Begin
      Select NO
      Into v_误差no
      From 门诊费用记录
      Where 结帐id = n_原结帐id And Nvl(附加标志, 0) = 9 And 记录性质 = 2 And 记录状态 = 1;
    Exception
      When Others Then
        Null;
    End;
    n_来源 := 1;
  End If;

  --a.如果结帐时有误差,则在原误差单据上处理
  If v_误差no Is Not Null Then
    --在原有误差基础上产生新误差费用并结帐
    If n_来源 = 1 Then
      Insert Into 门诊费用记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 病人科室id, 费别, 收费类别, 收费细目id,
         计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id,
         执行状态, 操作员姓名, 操作员编号, 结帐金额, 结帐id, 是否上传, 缴款组id)
        Select 病人费用记录_Id.Nextval, NO, Null, 记录性质, 2, 1, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 病人科室id, 费别,
               收费类别, 收费细目id, 计算单位, 付数, 发药窗口, -1 * 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目,
               Decode(n_误差金额, 0, 应收金额, 应收金额 + n_误差金额), Decode(n_误差金额, 0, -1 * 应收金额, -1 * (应收金额 + n_误差金额)),
               Decode(n_误差金额, 0, -1 * 实收金额, -1 * (实收金额 + n_误差金额)), 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, -1, 操作员姓名,
               操作员编号, Decode(n_误差金额, 0, -1 * 实收金额, -1 * (实收金额 + n_误差金额)), n_结帐id, Decode(r_Pati.险类, Null, Null, 1),
               缴款组id
        From 门诊费用记录
        Where 结帐id = n_原结帐id And Nvl(附加标志, 0) = 9 And 记录性质 = 2 And 记录状态 = 1;
    
      --作废结帐时的误差记录
      Update 门诊费用记录
      Set 记录状态 = 3, 执行状态 = 0
      Where 结帐id = n_原结帐id And Nvl(附加标志, 0) = 9 And 记录性质 = 2 And 记录状态 = 1;
    
    Else
      Insert Into 住院费用记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 病人id, 主页id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 床号, 病人病区id, 病人科室id,
         费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 划价人, 开单部门id, 开单人,
         发生时间, 登记时间, 执行部门id, 执行状态, 操作员姓名, 操作员编号, 结帐金额, 结帐id, 是否上传, 缴款组id, 医疗小组id)
        Select 病人费用记录_Id.Nextval, NO, Null, 记录性质, 2, 1, 从属父号, 价格父号, 多病人单, 病人id, 主页id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 床号,
               病人病区id, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, -1 * 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目,
               Decode(n_误差金额, 0, 应收金额, 应收金额 + n_误差金额), Decode(n_误差金额, 0, -1 * 应收金额, -1 * (应收金额 + n_误差金额)),
               Decode(n_误差金额, 0, -1 * 实收金额, -1 * (实收金额 + n_误差金额)), 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, -1, 操作员姓名,
               操作员编号, Decode(n_误差金额, 0, -1 * 实收金额, -1 * (实收金额 + n_误差金额)), n_结帐id, Decode(r_Pati.险类, Null, Null, 1),
               缴款组id, 医疗小组id
        From 住院费用记录
        Where 结帐id = n_原结帐id And Nvl(附加标志, 0) = 9 And 记录性质 = 2 And 记录状态 = 1;
    
      --作废结帐时的误差记录
      Update 住院费用记录
      Set 记录状态 = 3, 执行状态 = 0
      Where 结帐id = n_原结帐id And Nvl(附加标志, 0) = 9 And 记录性质 = 2 And 记录状态 = 1;
    End If;
  
    Begin
      Select Case
               When Nvl(Max(住院), 0) = 1 And Nvl(Max(门诊), 0) = 1 Then
                3
               When Nvl(Max(住院), 0) = 1 Then
                2
               Else
                1
             End
      Into n_来源
      From (Select 1 As 住院, 0 As 门诊
             From 住院费用记录
             Where 结帐id = n_原结帐id And Rownum = 1
             Union All
             Select 0 As 住院, 1 As 门诊 From 门诊费用记录 Where 结帐id = n_原结帐id And Rownum = 1);
    
    Exception
      When Others Then
        n_来源 := 3;
    End;
  
  Else
    Begin
      Select Case
               When Nvl(Max(住院), 0) = 1 And Nvl(Max(门诊), 0) = 1 Then
                3
               When Nvl(Max(住院), 0) = 1 Then
                2
               Else
                1
             End
      Into n_来源
      From (Select 1 As 住院, 0 As 门诊
             From 住院费用记录
             Where 结帐id = n_原结帐id And Rownum = 1
             Union All
             Select 0 As 住院, 1 As 门诊 From 门诊费用记录 Where 结帐id = n_原结帐id And Rownum = 1);
    Exception
      When Others Then
        n_来源 := 3;
    End;
  
    --b.作废时新产生的误差
    If n_误差金额 <> 0 Then
      v_Temp       := Zl_Identity;
      n_人员部门id := To_Number(Substr(v_Temp, 1, Instr(v_Temp, ',') - 1));
    
      Open c_Erritem();
      Fetch c_Erritem
        Into r_Erritem;
      If c_Erritem%RowCount = 0 Then
        Close c_Erritem;
        v_Err_Msg := '不能正确读取处理费用误差的项目信息，请先检查该项目是否正确设置。';
        Raise Err_Item;
      End If;
    
      If Nvl(n_来源, 1) = 1 Then
        --产生误差单据并结帐此误差费用
        v_New误差no := Nextno(14);
      
        Insert Into 门诊费用记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 病人科室id, 费别, 收费类别, 收费细目id,
           计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 划价人, 开单部门id, 开单人, 发生时间, 登记时间,
           执行部门id, 执行状态, 操作员姓名, 操作员编号, 结帐金额, 结帐id, 是否上传, 记帐单id, 保险项目否, 缴款组id)
        Values
          (病人费用记录_Id.Nextval, v_New误差no, Null, 2, 1, 1, Null, Null, n_病人id, Null, 1, r_Pati.姓名, r_Pati.性别, r_Pati.年龄,
           Decode(r_Pati.主页id, Null, r_Pati.门诊号, r_Pati.住院号), r_Pati.付款方式, Nvl(r_Pati.出院科室id, n_人员部门id), r_Pati.费别,
           r_Erritem.收费类别, r_Erritem.收费细目id, r_Erritem.计算单位, 1, Null, 1, Null, 9, 0, 1, r_Erritem.收入项目id, r_Erritem.收据费目,
           -1 * n_误差金额, -1 * n_误差金额, -1 * n_误差金额, Null, n_人员部门id, 操作员姓名_In, 作废日期_In, 作废日期_In, n_人员部门id, 0, 操作员姓名_In,
           操作员编号_In, -1 * n_误差金额, n_结帐id, Decode(r_Pati.险类, Null, Null, 1), Null, 0, n_组id);
      Else
        n_医疗小组id := Zl_医疗小组_Get(n_人员部门id, 操作员姓名_In, n_病人id, r_Pati.主页id, 作废日期_In);
        v_New误差no  := Nextno(14);
      
        --产生误差单据并结帐此误差费用
        Insert Into 住院费用记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 病人id, 主页id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 床号, 病人病区id, 病人科室id,
           费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 划价人, 开单部门id, 开单人,
           发生时间, 登记时间, 执行部门id, 执行状态, 操作员姓名, 操作员编号, 结帐金额, 结帐id, 是否上传, 记帐单id, 保险项目否, 缴款组id, 医疗小组id)
        Values
          (病人费用记录_Id.Nextval, v_New误差no, Null, 2, 1, 1, Null, Null, 0, n_病人id, r_Pati.主页id, Null,
           Decode(r_Pati.主页id, Null, 1, 2), r_Pati.姓名, r_Pati.性别, r_Pati.年龄,
           Decode(r_Pati.主页id, Null, r_Pati.门诊号, r_Pati.住院号), r_Pati.出院病床, Nvl(r_Pati.当前病区id, n_人员部门id),
           Nvl(r_Pati.出院科室id, n_人员部门id), r_Pati.费别, r_Erritem.收费类别, r_Erritem.收费细目id, r_Erritem.计算单位, 1, Null, 1, Null,
           9, 0, 1, r_Erritem.收入项目id, r_Erritem.收据费目, -1 * n_误差金额, -1 * n_误差金额, -1 * n_误差金额, Null, n_人员部门id, 操作员姓名_In,
           作废日期_In, 作废日期_In, n_人员部门id, 0, 操作员姓名_In, 操作员编号_In, -1 * n_误差金额, n_结帐id, Decode(r_Pati.险类, Null, Null, 1),
           Null, 0, n_组id, n_医疗小组id);
      
      End If;
      Close c_Erritem;
    End If;
  End If;

  If n_来源 = 2 Or n_来源 = 3 Then
    --作废结帐对应的费用记录:不包含原始结帐产生的误差项目
    Insert Into 住院费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 记帐单id, 病人id, 主页id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 床号, 病人病区id,
       病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 划价人, 开单部门id,
       开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 执行人, 执行时间, 操作员姓名, 操作员编号, 结帐金额, 结帐id, 保险项目否, 保险大类id, 统筹金额, 是否急诊, 保险编码, 费用类型, 摘要,
       缴款组id, 医疗小组id)
      Select 病人费用记录_Id.Nextval, NO, 实际票号, To_Number('1' || Substr(记录性质, Length(记录性质), 1)), 记录状态, 序号, 从属父号, 价格父号, 多病人单,
             记帐单id, 病人id, 主页id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 床号, 病人病区id, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次,
             加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, Null, Null, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 执行人,
             执行时间, 操作员姓名, 操作员编号, -1 * 结帐金额, n_结帐id, 保险项目否, 保险大类id, 统筹金额, 是否急诊, 保险编码, 费用类型, 摘要, 缴款组id, 医疗小组id
      From 住院费用记录
      Where 结帐id = n_原结帐id And Nvl(附加标志, 0) <> 9;
  End If;

  If n_来源 = 1 Or n_来源 = 3 Then
    Insert Into 门诊费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 记帐单id, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 病人科室id, 费别, 收费类别,
       收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 划价人, 开单部门id, 开单人, 发生时间, 登记时间,
       执行部门id, 执行状态, 执行人, 执行时间, 操作员姓名, 操作员编号, 结帐金额, 结帐id, 保险项目否, 保险大类id, 统筹金额, 是否急诊, 保险编码, 费用类型, 摘要, 缴款组id)
      Select 病人费用记录_Id.Nextval, NO, 实际票号, To_Number('1' || Substr(记录性质, Length(记录性质), 1)), 记录状态, 序号, 从属父号, 价格父号, 记帐单id,
             病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费,
             记帐费用, 收入项目id, 收据费目, 标准单价, Null, Null, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 执行人, 执行时间, 操作员姓名, 操作员编号,
             -1 * 结帐金额, n_结帐id, 保险项目否, 保险大类id, 统筹金额, 是否急诊, 保险编码, 费用类型, 摘要, 缴款组id
      From 门诊费用记录
      Where 结帐id = n_原结帐id And Nvl(附加标志, 0) <> 9;
  End If;

  --相关汇总表处理
  For v_预交 In (Select 病人id, 记录性质, Nvl(预交类别, 2) As 预交类型, 结算方式, 冲预交
               From 病人预交记录
               Where 结帐id = n_结帐id) Loop
    If v_预交.记录性质 In (1, 11) Then
      --病人余额(预交)
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - v_预交.冲预交 --注:新的结帐ID产生的是负数金额
      Where 病人id = v_预交.病人id And 性质 = 1 And 类型 = Nvl(v_预交.预交类型, 2)
      Returning 预交余额 Into n_返回值;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 预交余额, 费用余额)
        Values
          (v_预交.病人id, 1, Nvl(v_预交.预交类型, 2), -1 * v_预交.冲预交, 0);
        n_返回值 := -1 * v_预交.冲预交;
      End If;
    
      If Nvl(n_返回值, 0) = 0 Then
        Delete 病人余额 Where 性质 = 1 And 病人id = v_预交.病人id And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
      End If;
    
    Else
      --人员缴款余额,医保不支持作废的结算方式在新的预交结算中已被处理为了退现金,
      --此处用加,表示收回退给病人的现金(结帐时,退款是负,作废时是正)
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + v_预交.冲预交
      Where 收款员 = 操作员姓名_In And 结算方式 = v_预交.结算方式 And 性质 = 1
      Returning 余额 Into n_返回值;
    
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (操作员姓名_In, v_预交.结算方式, 1, v_预交.冲预交);
        n_返回值 := -1 * v_预交.冲预交;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = 操作员姓名_In And 结算方式 = v_预交.结算方式 And 性质 = 1 And Nvl(余额, 0) = 0;
      End If;
    End If;
  End Loop;
  Close c_Pati;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊转住院结帐_结帐作废;
/

--99878:冉俊明,2017-05-26,同一收费项目多个价格管理
Create Or Replace Procedure Zl_住院一次费用_Insert
(
  病人id_In 住院费用记录.病人id%Type,
  主页id_In 住院费用记录.主页id%Type
) As
  Cursor c_Money
  (
    药品价格等级_In     收费价目.价格等级%Type,
    卫材价格等级_In     收费价目.价格等级%Type,
    普通项目价格等级_In 收费价目.价格等级%Type
  ) Is
    Select e.姓名, e.性别, e.年龄, e.住院号, d.出院病床, d.入院病区id, d.入院科室id, d.费别, a.类别, c.收费细目id, a.计算单位, b.收入项目id, f.收据费目, b.现价,
           d.入院日期, Nvl(a.执行科室, 0) As 执行科室, Nvl(a.屏蔽费别, 0) As 屏蔽费别
    From 收费细目 A, 收费价目 B, 自动计价项目 C, 病案主页 D, 病人信息 E, 收入项目 F
    Where a.Id = b.收费细目id And a.Id = c.收费细目id And c.病区id = d.入院病区id And c.计算标志 = 8 And
          d.入院日期 >= Nvl(c.启用日期, To_Date('3000-01-01', 'YYYY-MM-DD')) And d.主页id = 主页id_In And d.病人id = 病人id_In And
          e.病人id = d.病人id And b.收入项目id = f.Id And
          ((d.入院日期 Between b.执行日期 And b.终止日期) Or (d.入院日期 >= b.执行日期 And b.终止日期 Is Null)) And
          ((Instr(';5;6;7;', ';' || a.类别 || ';') > 0 And b.价格等级 = 药品价格等级_In) Or
          (Instr(';4;', ';' || a.类别 || ';') > 0 And b.价格等级 = 卫材价格等级_In) Or
          (Instr(';4;5;6;7;', ';' || a.类别 || ';') = 0 And b.价格等级 = 普通项目价格等级_In) Or
          (b.价格等级 Is Null And Not Exists
           (Select 1
             From 收费价目
             Where b.收费细目id = 收费细目id And Sysdate Between 执行日期 And Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')) And
                   ((Instr(';5;6;7;', ';' || a.类别 || ';') > 0 And 价格等级 = 药品价格等级_In) Or
                   (Instr(';4;', ';' || a.类别 || ';') > 0 And 价格等级 = 卫材价格等级_In) Or
                   (Instr(';4;5;6;7;', ';' || a.类别 || ';') = 0 And 价格等级 = 普通项目价格等级_In)))))
    Order By a.Id, b.收入项目id;

  --功能：对住院病人计算一次性费用。
  v_Billno     住院费用记录.No%Type;
  v_执行部门id 住院费用记录.执行部门id%Type;
  v_实收金额   住院费用记录.实收金额%Type;
  v_价格父号   住院费用记录.价格父号%Type;
  v_项目id     收费项目目录.Id%Type;

  v_人员编号   住院费用记录.操作员编号%Type;
  v_人员姓名   住院费用记录.操作员姓名%Type;
  v_人员部门id 部门表.Id%Type;
  n_单价小数   Number;
  n_医疗小组id 住院费用记录.医疗小组id%Type;

  v_Dec   Number;
  v_Date  Date;
  v_Count Number;
  v_Temp  Varchar2(255);

  v_站点             部门表.站点%Type;
  v_药品价格等级     收费价目.价格等级%Type;
  v_卫材价格等级     收费价目.价格等级%Type;
  v_普通项目价格等级 收费价目.价格等级%Type;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --检查是否是计算一次的项目
  Select Count(*)
  Into v_Count
  From 病案主页 A, 自动计价项目 B
  Where a.病人id = 病人id_In And a.主页id = 主页id_In And a.入院病区id = b.病区id And b.计算标志 = 8 And
        a.入院日期 >= Nvl(b.启用日期, To_Date('3000-01-01', 'YYYY-MM-DD'));
  If v_Count = 0 Then
    Return;
  End If;

  --检查该病人本次住院是否已经计算过
  Select Count(*)
  Into v_Count
  From 住院费用记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And 附加标志 = 8;
  If v_Count > 0 Then
    Return;
  End If;

  --取操作员信息(部门ID,部门名称;人员ID,人员编号,人员姓名)
  v_Temp       := Zl_Identity;
  v_人员部门id := To_Number(Substr(v_Temp, 1, Instr(v_Temp, ',') - 1));
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_人员编号   := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_人员姓名   := Substr(v_Temp, Instr(v_Temp, ',') + 1);

  --取单据号
  v_Billno := Nextno(17);

  --取时间
  Select Sysdate Into v_Date From Dual;

  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')), Zl_To_Number(Nvl(zl_GetSysParameter(157), '5'))
  Into v_Dec, n_单价小数
  From Dual;

  --取价格等级
  Begin
    Select b.站点
    Into v_站点
    From 病案主页 A, 部门表 B
    Where a.入院科室id = b.Id And a.病人id = 病人id_In And a.主页id = 主页id_In;
  Exception
    When Others Then
      v_站点 := Null;
  End;
  --返回格式:普通价格等级|药品价格等级|卫生材料价格等级
  v_Temp             := Zl_Get_Pricegrade(v_站点, 病人id_In, 主页id_In);
  v_普通项目价格等级 := Substr(v_Temp, 1, Instr(v_Temp, '|') - 1);
  v_Temp             := Substr(v_Temp, Instr(v_Temp, '|') + 1);
  v_药品价格等级     := Substr(v_Temp, 1, Instr(v_Temp, '|') - 1);
  v_卫材价格等级     := Substr(v_Temp, Instr(v_Temp, '|') + 1);

  --产生费用信息
  v_项目id := Null;
  v_Count  := 1; --序号

  For r_Money In c_Money(v_药品价格等级, v_卫材价格等级, v_普通项目价格等级) Loop
    If Nvl(v_项目id, 0) <> r_Money.收费细目id Then
      --求执行部门
      If r_Money.执行科室 = 2 Then
        --入住病区
        v_执行部门id := r_Money.入院病区id;
      Elsif r_Money.执行科室 = 1 Then
        --指定科室
        Begin
          Select 执行部门id Into v_执行部门id From 收费执行部门 Where 收费细目id = r_Money.收费细目id And Rownum < 2;
        Exception
          When Others Then
            v_执行部门id := v_人员部门id;
        End;
      Else
        --未指定或操作员科室
        v_执行部门id := v_人员部门id;
      End If;
      --该项目各后续收入项目的价格父号
      v_价格父号 := v_Count;
    
    End If;
  
    --求实收金额
    If r_Money.屏蔽费别 = 1 Then
      v_实收金额 := Round(r_Money.现价, v_Dec);
    Else
      Begin
        Select Round(Round(r_Money.现价, n_单价小数) * 实收比率 / 100, v_Dec)
        Into v_实收金额
        From 费别明细
        Where 收入项目id = r_Money.收入项目id And 费别 = r_Money.费别 And Round(r_Money.现价, n_单价小数) Between 应收段首值 And 应收段尾值;
      Exception
        When Others Then
          v_实收金额 := Round(r_Money.现价, v_Dec);
      End;
    End If;
    n_医疗小组id := Zl_医疗小组_Get(v_人员部门id, v_人员姓名, 病人id_In, 主页id_In, r_Money.入院日期);
  
    --插入费用记录(附加标志=8,记录性质=3)
    Insert Into 住院费用记录
      (ID, 记录性质, NO, 记录状态, 序号, 价格父号, 病人id, 主页id, 门诊标志, 记帐费用, 姓名, 性别, 年龄, 标识号, 床号, 病人病区id, 病人科室id, 费别, 收费类别, 收费细目id,
       计算单位, 付数, 数次, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 操作员编号, 操作员姓名, 医疗小组id)
    Values
      (病人费用记录_Id.Nextval, 3, v_Billno, 1, v_Count, Decode(Sign(Nvl(v_项目id, 0) - r_Money.收费细目id), 0, v_价格父号, Null),
       病人id_In, 主页id_In, 2, 1, r_Money.姓名, r_Money.性别, r_Money.年龄, r_Money.住院号, r_Money.出院病床, r_Money.入院病区id,
       r_Money.入院科室id, r_Money.费别, r_Money.类别, r_Money.收费细目id, r_Money.计算单位, 1, 1, 8, r_Money.收入项目id, r_Money.收据费目,
       Round(r_Money.现价, n_单价小数), Round(r_Money.现价, v_Dec), v_实收金额, v_人员姓名, v_人员部门id, v_人员姓名, r_Money.入院日期, v_Date,
       v_执行部门id, v_人员编号, v_人员姓名, n_医疗小组id);
  
    v_Count  := v_Count + 1;
    v_项目id := r_Money.收费细目id; --记录上次处理行的项目
  
    --相关汇总表的处理
    --病人余额
    Update 病人余额 Set 费用余额 = Nvl(费用余额, 0) + v_实收金额 Where 病人id = 病人id_In And 性质 = 1 And 类型 = 2;
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (病人id_In, 1, 2, v_实收金额, 0);
    End If;
  
    --病人未结费用
    Update 病人未结费用
    Set 金额 = Nvl(金额, 0) + v_实收金额
    Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0) And Nvl(病人病区id, 0) = Nvl(r_Money.入院病区id, 0) And
          Nvl(病人科室id, 0) = Nvl(r_Money.入院科室id, 0) And Nvl(开单部门id, 0) = v_人员部门id And Nvl(执行部门id, 0) = v_执行部门id And
          收入项目id + 0 = r_Money.收入项目id And 来源途径 = 2;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人未结费用
        (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
      Values
        (病人id_In, 主页id_In, r_Money.入院病区id, r_Money.入院科室id, v_人员部门id, v_执行部门id, r_Money.收入项目id, 2, v_实收金额);
    End If;
  End Loop;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_住院一次费用_Insert;
/

--99878:冉俊明,2017-05-24,同一收费项目多个价格管理
Create Or Replace Procedure Zl_收费价格等级_Insert
(
  编码_In             In 收费价格等级.编码%Type,
  名称_In             In 收费价格等级.名称%Type,
  简码_In             In 收费价格等级.简码%Type,
  是否适用药品_In     In 收费价格等级.是否适用药品%Type := 0,
  是否适用卫材_In     In 收费价格等级.是否适用卫材%Type := 0,
  是否适用普通项目_In In 收费价格等级.是否适用普通项目%Type := 1,
  应用站点_In         In Varchar2,
  应用医疗付款方式_In In Varchar2
) Is
  --功能：增加收费价格等级
  --入参：
  --    应用站点_In 应用于的站点编号，多个用单竖线"|"分隔，如：01|02|...
  --    应用医疗付款方式_In 应用于的医疗付款方式，多个用单竖线"|"分隔，如：公费医疗|自费医疗|...
  v_Err_Item Varchar2(1000);
  Err_Item Exception;
Begin
  Insert Into 收费价格等级
    (编码, 名称, 简码, 是否适用药品, 是否适用卫材, 是否适用普通项目, 建档时间, 撤档时间)
  Values
    (编码_In, 名称_In, 简码_In, 是否适用药品_In, 是否适用卫材_In, 是否适用普通项目_In, Sysdate, To_Date('3000-01-01', 'yyyy-mm-dd'));

  --修改价格等级应用
  --性质：0-按站点进行价格等级划分;1-按医疗付款方式进行价格等级划分
  --一个站点只能设置一个价格等级
  If 应用站点_In Is Not Null Then
  
    For c_记录 In (Select Column_Value As 站点 From Table(f_Str2list(应用站点_In, '|'))) Loop
      --删除当前价格等级应用的院区已设置的其它有效的价格等级
      Delete From 收费价格等级应用 A
      Where Nvl(a.性质, 0) = 0 And a.站点 = c_记录.站点 And Exists
       (Select 1
             From 收费价格等级
             Where 名称 = a.价格等级 And (撤档时间 Is Null Or 撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')));
    
      Insert Into 收费价格等级应用 (性质, 价格等级, 站点, 医疗付款方式) Values (0, 名称_In, c_记录.站点, Null);
    End Loop;
  End If;

  --一个医疗付款方式只能设置一个价格等级
  If 应用医疗付款方式_In Is Not Null Then
    --删除当前价格等级应用的医疗付款方式已设置的其它有效的价格等级
    For c_记录 In (Select Column_Value As 医疗付款方式 From Table(f_Str2list(应用医疗付款方式_In, '|'))) Loop
      Delete From 收费价格等级应用 A
      Where Nvl(a.性质, 0) = 1 And a.医疗付款方式 = c_记录.医疗付款方式 And Exists
       (Select 1
             From 收费价格等级
             Where 名称 = a.价格等级 And (撤档时间 Is Null Or 撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')));
    
      Insert Into 收费价格等级应用 (性质, 价格等级, 站点, 医疗付款方式) Values (1, 名称_In, Null, c_记录.医疗付款方式);
    End Loop;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Item || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_收费价格等级_Insert;
/

--99878:冉俊明,2017-05-24,同一收费项目多个价格管理
Create Or Replace Procedure Zl_收费价格等级_Update
(
  原名称_In           In 收费价格等级.名称%Type,
  编码_In             In 收费价格等级.编码%Type,
  名称_In             In 收费价格等级.名称%Type,
  简码_In             In 收费价格等级.简码%Type,
  是否适用药品_In     In 收费价格等级.是否适用药品%Type := 0,
  是否适用卫材_In     In 收费价格等级.是否适用卫材%Type := 0,
  是否适用普通项目_In In 收费价格等级.是否适用普通项目%Type := 1,
  应用站点_In         In Varchar2,
  应用医疗付款方式_In In Varchar2
) Is
  --功能：调整收费价格等级
  --入参：
  --    应用站点_In 应用于的站点编号，多个用单竖线"|"分隔，如：01|02|...
  --    应用医疗付款方式_In 应用于的医疗付款方式，多个用单竖线"|"分隔，如：公费医疗|自费医疗|...
  n_是否停用 Number(2);

  n_Count Number(2);

  v_Err_Item Varchar2(1000);
  Err_Item Exception;
Begin
  Begin
    Select Decode(Nvl(撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')), To_Date('3000-01-01', 'yyyy-mm-dd'), 0, 1)
    Into n_是否停用
    From 收费价格等级
    Where 名称 = 原名称_In;
  Exception
    When Others Then
      v_Err_Item := '当前价格等级可能已被他人删除，请刷新后查看...';
      Raise Err_Item;
  End;

  --1.如果当前价格等级已经调价（即已经存在调价记录），则不允许更改名称。
  If 原名称_In <> 名称_In Then
    Begin
      Select 1 Into n_Count From 收费价目 Where 价格等级 = 原名称_In And Rownum < 2;
    Exception
      When Others Then
        n_Count := 0;
    End;
    If Nvl(n_Count, 0) = 1 Then
      v_Err_Item := '当前价格等级已在收费价目中使用，不允许更改名称。';
      Raise Err_Item;
    End If;
  End If;

  --2.已经停用的，不允许修改
  If Nvl(n_是否停用, 0) = 1 Then
    v_Err_Item := '当前价格等级已停用，不允许调整。';
    Raise Err_Item;
  End If;

  --修改记录
  Update 收费价格等级
  Set 编码 = 编码_In, 名称 = 名称_In, 简码 = 简码_In, 是否适用药品 = 是否适用药品_In, 是否适用卫材 = 是否适用卫材_In, 是否适用普通项目 = 是否适用普通项目_In
  Where 名称 = 原名称_In;

  --删除原有价格等级应用
  Delete From 收费价格等级应用 Where 价格等级 = 原名称_In;

  --修改价格等级应用
  --性质：0-按站点进行价格等级划分;1-按医疗付款方式进行价格等级划分
  --一个站点只能设置一个价格等级
  If 应用站点_In Is Not Null Then
  
    For c_记录 In (Select Column_Value As 站点 From Table(f_Str2list(应用站点_In, '|'))) Loop
      --删除当前价格等级应用的院区已设置的其它有效的价格等级
      Delete From 收费价格等级应用 A
      Where Nvl(a.性质, 0) = 0 And a.站点 = c_记录.站点 And Exists
       (Select 1
             From 收费价格等级
             Where 名称 = a.价格等级 And (撤档时间 Is Null Or 撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')));
    
      Insert Into 收费价格等级应用 (性质, 价格等级, 站点, 医疗付款方式) Values (0, 名称_In, c_记录.站点, Null);
    End Loop;
  End If;

  --一个医疗付款方式只能设置一个价格等级
  If 应用医疗付款方式_In Is Not Null Then
    --删除当前价格等级应用的医疗付款方式已设置的其它有效的价格等级
    For c_记录 In (Select Column_Value As 医疗付款方式 From Table(f_Str2list(应用医疗付款方式_In, '|'))) Loop
      Delete From 收费价格等级应用 A
      Where Nvl(a.性质, 0) = 1 And a.医疗付款方式 = c_记录.医疗付款方式 And Exists
       (Select 1
             From 收费价格等级
             Where 名称 = a.价格等级 And (撤档时间 Is Null Or 撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')));
    
      Insert Into 收费价格等级应用 (性质, 价格等级, 站点, 医疗付款方式) Values (1, 名称_In, Null, c_记录.医疗付款方式);
    End Loop;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Item || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_收费价格等级_Update;
/

--99878:冉俊明,2017-05-24,同一收费项目多个价格管理
Create Or Replace Procedure Zl_收费价格等级_Delete(名称_In In 收费价格等级.名称%Type) Is
  --功能：删除收费价格等级
  n_是否停用 Number(2);

  n_Count    Number(2);
  v_Err_Item Varchar2(100);
  Err_Item Exception;
Begin
  Begin
    Select Decode(Nvl(撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')), To_Date('3000-01-01', 'yyyy-mm-dd'), 0, 1)
    Into n_是否停用
    From 收费价格等级
    Where 名称 = 名称_In;
  Exception
    When Others Then
      v_Err_Item := '当前价格等级可能已被他人删除，请刷新后查看...';
      Raise Err_Item;
  End;

  --1.如果当前价格等级已经调价（即已经存在调价记录），则不允许删除。
  Begin
    Select 1 Into n_Count From 收费价目 Where 价格等级 = 名称_In And Rownum < 2;
  Exception
    When Others Then
      n_Count := 0;
  End;
  If Nvl(n_Count, 0) = 1 Then
    v_Err_Item := '当前价格等级已在收费价目中使用，不允许删除。';
    Raise Err_Item;
  End If;

  --2.已经停用的，不允许删除
  If Nvl(n_是否停用, 0) = 1 Then
    v_Err_Item := '当前价格等级已停用，不允许删除。';
    Raise Err_Item;
  End If;

  Delete From 收费价格等级应用 Where 价格等级 = 名称_In;
  Delete From 收费价格等级 Where 名称 = 名称_In;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Item || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_收费价格等级_Delete;
/

--99878:冉俊明,2017-05-24,同一收费项目多个价格管理
Create Or Replace Procedure Zl_收费价格等级_Stop(名称_In 收费价格等级.名称%Type) As
  --功能：停用收费价格等级
  n_是否停用 Number(2);

  v_Err_Item Varchar2(100);
  Err_Item Exception;
Begin
  Begin
    Select Decode(Nvl(撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')), To_Date('3000-01-01', 'yyyy-mm-dd'), 0, 1)
    Into n_是否停用
    From 收费价格等级
    Where 名称 = 名称_In;
  Exception
    When Others Then
      v_Err_Item := '当前价格等级可能已被他人删除，请刷新后查看...';
      Raise Err_Item;
  End;

  --已经停用的，无需再次停用
  If Nvl(n_是否停用, 0) = 1 Then
    v_Err_Item := '当前价格等级已被停用，无需再次停用。';
    Raise Err_Item;
  End If;

  Update 收费价格等级 Set 撤档时间 = Sysdate Where 名称 = 名称_In;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Item || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_收费价格等级_Stop;
/

--99878:冉俊明,2017-05-24,同一收费项目多个价格管理
Create Or Replace Procedure Zl_收费价格等级_Start(名称_In 收费价格等级.名称%Type) As
  --功能：启用收费价格等级
  n_是否停用 Number(2);

  v_Err_Item Varchar2(100);
  Err_Item Exception;
Begin
  Begin
    Select Decode(Nvl(撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')), To_Date('3000-01-01', 'yyyy-mm-dd'), 0, 1)
    Into n_是否停用
    From 收费价格等级
    Where 名称 = 名称_In;
  Exception
    When Others Then
      v_Err_Item := '当前价格等级可能已被他人删除，请刷新后查看...';
      Raise Err_Item;
  End;

  --已是启用状态的，无需再启用
  If Nvl(n_是否停用, 0) = 0 Then
    v_Err_Item := '当前价格等级已是启用状态，无需再启用。';
    Raise Err_Item;
  End If;

  --删除当前价格等级应用的院区或医疗付款方式已设置的其它有效的价格等级
  For c_记录 In (Select 价格等级, 性质, 站点, 医疗付款方式 From 收费价格等级应用 Where 价格等级 = 名称_In) Loop
    If Nvl(c_记录.性质, 0) = 0 Then
      --院区
      Delete From 收费价格等级应用 A
      Where Nvl(a.性质, 0) = 0 And a.价格等级 <> c_记录.价格等级 And a.站点 = c_记录.站点 And Exists
       (Select 1
             From 收费价格等级
             Where 名称 = a.价格等级 And (撤档时间 Is Null Or 撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')));
    Else
      --医疗付款方式
      Delete From 收费价格等级应用 A
      Where Nvl(a.性质, 0) = 1 And a.价格等级 <> c_记录.价格等级 And a.医疗付款方式 = c_记录.医疗付款方式 And Exists
       (Select 1
             From 收费价格等级
             Where 名称 = a.价格等级 And (撤档时间 Is Null Or 撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')));
    End If;
  End Loop;

  Update 收费价格等级 Set 撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd') Where 名称 = 名称_In;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Item || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_收费价格等级_Start;
/

--99878:冉俊明,2017-05-24,同一收费项目多个价格管理
Create Or Replace Procedure Zl_收费价目_Insert
(
  Id_In         In 收费价目.Id%Type,
  原价id_In     In 收费价目.原价id%Type := Null,
  收费细目id_In In 收费价目.收费细目id%Type := Null,
  收入项目id_In In 收费价目.收入项目id%Type := Null,
  原价_In       In 收费价目.原价%Type := Null,
  现价_In       In 收费价目.现价%Type := Null,
  附术收费率_In In 收费价目.附术收费率%Type := Null,
  加班加价率_In In 收费价目.加班加价率%Type := Null,
  调价说明_In   In 收费价目.调价说明%Type := Null,
  调价id_In     In 收费价目.调价id%Type := Null,
  调价人_In     In 收费价目.调价人%Type := Null,
  执行日期_In   In 收费价目.执行日期%Type := Null,
  变动原因_In   In 收费价目.变动原因%Type := 1,
  No_In         In 收费价目.No%Type := Null,
  序号_In       In 收费价目.序号%Type := 1,
  缺省价格_In   In 收费价目.缺省价格%Type := Null,
  调价汇总号_In In 收费价目.调价汇总号%Type := Null,
  价格等级_In   In 收费价目.价格等级%Type := Null
) Is
Begin
  Insert Into 收费价目
    (ID, 原价id, 收费细目id, 原价, 现价, 收入项目id, 加班加价率, 附术收费率, 变动原因, 调价说明, 调价id, 调价人, 执行日期, 终止日期, NO, 序号, 缺省价格, 调价汇总号, 价格等级)
  Values
    (Id_In, 原价id_In, 收费细目id_In, 原价_In, 现价_In, 收入项目id_In, 加班加价率_In, 附术收费率_In, 变动原因_In, 调价说明_In, 调价id_In, 调价人_In, 执行日期_In,
     To_Date('3000-01-01', 'yyyy-mm-dd'), No_In, 序号_In, 缺省价格_In, 调价汇总号_In, 价格等级_In);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_收费价目_Insert;
/

--99878:冉俊明,2017-05-24,同一收费项目多个价格管理
Create Or Replace Procedure Zl_收费调价记录_Insert
(
  Id_In         In 收费价目.Id%Type,
  原价id_In     In 收费价目.原价id%Type := Null,
  收费细目id_In In 收费价目.收费细目id%Type := Null,
  收入项目id_In In 收费价目.收入项目id%Type := Null,
  原价_In       In 收费价目.原价%Type := Null,
  现价_In       In 收费价目.现价%Type := Null,
  缺省价格_In   In 收费价目.缺省价格%Type := Null,
  附术收费率_In In 收费价目.附术收费率%Type := Null,
  加班加价率_In In 收费价目.加班加价率%Type := Null,
  调价说明_In   In 收费价目.调价说明%Type := Null,
  调价id_In     In 收费价目.调价id%Type := Null,
  填制人_In     In 收费调价记录.填制人%Type := Null,
  填制日期_In   In 收费调价记录.填制日期%Type := Null,
  执行日期_In   In 收费价目.执行日期%Type := Null,
  变动原因_In   In 收费价目.变动原因%Type := 1,
  No_In         In 收费价目.No%Type := Null,
  序号_In       In 收费价目.序号%Type := 1,
  价格等级_In   In 收费价目.价格等级%Type := Null
) Is
Begin
  Insert Into 收费调价记录
    (ID, 原价id, 收费细目id, 原价, 现价, 缺省价格, 收入项目id, 加班加价率, 附术收费率, 变动原因, 调价说明, 调价id, 填制人, 填制日期, 执行日期, 终止日期, NO, 序号, 审核标志, 价格等级)
  Values
    (Id_In, 原价id_In, 收费细目id_In, 原价_In, 现价_In, 缺省价格_In, 收入项目id_In, 加班加价率_In, 附术收费率_In, 变动原因_In, 调价说明_In, 调价id_In, 填制人_In,
     填制日期_In, 执行日期_In, To_Date('3000-01-01', 'yyyy-mm-dd'), No_In, 序号_In, 0, 价格等级_In);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_收费调价记录_Insert;
/

--99878:冉俊明,2017-05-24,同一收费项目多个价格管理
Create Or Replace Procedure Zl_收费调价记录_Verify
(
  Id_In       In 收费调价记录.Id%Type,
  审核标志_In In 收费调价记录.审核标志%Type := 1,
  审核人_In   In 收费调价记录.审核人%Type := Null,
  审核日期_In In 收费调价记录.审核日期%Type := Null,
  说明_In     In 收费调价记录.说明%Type := Null
) Is
  Cursor c_收费调价记录 Is
    Select ID, 原价id, 收费细目id, 原价, 现价, 缺省价格, 收入项目id, 加班加价率, 附术收费率, 变动原因, 调价说明, 调价id, 填制人 As 调价人, 执行日期, 终止日期, NO, 序号, 价格等级
    From 收费调价记录
    Where ID = Id_In And 审核标志 = 1;

  n_变价     Number;
  n_调价id   收费价目.调价id%Type;
  d_执行日期 收费调价记录.执行日期%Type;
Begin
  --先将原始的调价记录状态改变 
  Update 收费调价记录
  Set 审核标志 = 审核标志_In, 审核人 = 审核人_In, 审核日期 = 审核日期_In, 说明 = 说明_In
  Where ID = Id_In And 审核标志 = 0;

  For r_收费调价 In c_收费调价记录 Loop
    If Sysdate - r_收费调价.执行日期 > 0 Then
      d_执行日期 := Sysdate;
      Update 收费调价记录 Set 执行日期 = d_执行日期, 审核日期 = Sysdate Where ID = r_收费调价.Id;
    Else
      d_执行日期 := r_收费调价.执行日期;
    End If;
  
    Select Nvl(是否变价, 0) Into n_变价 From 收费项目目录 Where ID = r_收费调价.收费细目id;
    If n_变价 = 0 Then
      --定价需要先停用原始的价格，然后再产生新的记录 
      --由于停用原始价格是所有收入项目一起停用因此只需要停用一次即可 
      Begin
        Select 1
        Into n_调价id
        From 收费价目
        Where 收费细目id = r_收费调价.收费细目id And 调价id = r_收费调价.调价id And Rownum <= 1;
      Exception
        When Others Then
          n_调价id := 0;
      End;
      If n_调价id = 0 Then
        Zl_收费价目_Stop(r_收费调价.收费细目id, d_执行日期 - 1 / (24 * 60 * 60), r_收费调价.价格等级);
      End If;
      Zl_收费价目_Insert(r_收费调价.Id, r_收费调价.原价id, r_收费调价.收费细目id, r_收费调价.收入项目id, r_收费调价.原价, r_收费调价.现价, r_收费调价.附术收费率,
                     r_收费调价.加班加价率, r_收费调价.调价说明, r_收费调价.调价id, r_收费调价.调价人, d_执行日期, r_收费调价.变动原因, r_收费调价.No, r_收费调价.序号,
                     r_收费调价.缺省价格, Null, r_收费调价.价格等级);
    Else
      --时价直接修改原始记录即可 
      Zl_收费价目_Update(r_收费调价.收费细目id, r_收费调价.收入项目id, r_收费调价.原价, r_收费调价.现价, r_收费调价.附术收费率, r_收费调价.加班加价率, r_收费调价.调价说明,
                     r_收费调价.调价id, r_收费调价.调价人, r_收费调价.缺省价格, r_收费调价.价格等级);
    End If;
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_收费调价记录_Verify;
/

--99878:冉俊明,2017-05-24,同一收费项目多个价格管理
Create Or Replace Procedure Zl_收费价目_Stop
(
  收费细目id_In In 收费价目.收费细目id%Type,
  终止日期_In   In 收费价目.终止日期%Type := Null,
  价格等级_In   In 收费价目.价格等级%Type := Null
) Is
Begin
  Update 收费价目
  Set 终止日期 = 终止日期_In
  Where Decode(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD'), Null, 终止日期) Is Null And 收费细目id = 收费细目id_In And
        Nvl(价格等级, '-') = Nvl(价格等级_In, '-');
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_收费价目_Stop;
/

--99878:冉俊明,2017-05-24,同一收费项目多个价格管理
Create Or Replace Procedure Zl_收费价目_Update
(
  收费细目id_In In 收费价目.收费细目id%Type := Null,
  收入项目id_In In 收费价目.收入项目id%Type := Null,
  原价_In       In 收费价目.原价%Type := Null,
  现价_In       In 收费价目.现价%Type := Null,
  附术收费率_In In 收费价目.附术收费率%Type := Null,
  加班加价率_In In 收费价目.加班加价率%Type := Null,
  调价说明_In   In 收费价目.调价说明%Type := Null,
  调价id_In     In 收费价目.调价id%Type := Null,
  调价人_In     In 收费价目.调价人%Type := Null,
  缺省价格_In   In 收费价目.缺省价格%Type := Null,
  价格等级_In   In 收费价目.价格等级%Type := Null
) Is
Begin
  Update 收费价目
  Set 原价 = 原价_In, 现价 = 现价_In, 收入项目id = 收入项目id_In, 加班加价率 = 加班加价率_In, 附术收费率 = 附术收费率_In, 调价说明 = 调价说明_In, 调价id = 调价id_In,
      调价人 = 调价人_In, 缺省价格 = 缺省价格_In
  Where 收费细目id = 收费细目id_In And Nvl(价格等级, '-') = Nvl(价格等级_In, '-') And
        Decode(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD'), Null, 终止日期) Is Null;

  If Sql%NotFound Then
    --只有时价才会出现这种情况
    Insert Into 收费价目
      (ID, 原价id, 收费细目id, 原价, 现价, 收入项目id, 加班加价率, 附术收费率, 变动原因, 调价说明, 调价id, 调价人, 执行日期, 终止日期, NO, 序号, 缺省价格, 调价汇总号, 价格等级)
    Values
      (收费价目_Id.Nextval, Null, 收费细目id_In, 原价_In, 现价_In, 收入项目id_In, 加班加价率_In, 附术收费率_In, 1, 调价说明_In, 调价id_In, 调价人_In,
       Sysdate, To_Date('3000-01-01', 'yyyy-mm-dd'), Nextno(9), 1, 缺省价格_In, Null, 价格等级_In);
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_收费价目_Update;
/

--99878:冉俊明,2017-05-24,同一收费项目多个价格管理
Create Or Replace Procedure Zl_收费价目_Delete
(
  细目id_In   In 收费价目.收费细目id%Type,
  站点_In     In 收费项目目录.站点%Type := Null,
  价格等级_In In 收费价目.价格等级%Type := Null
) Is
  --说明：
  --     如果价格等级_in不为空，则表示删除该价格等级的收费价目,否则表示删除最后一次未执行价格
Begin
  If 价格等级_In Is Null Then
    Delete From 收费价目 A
    Where 收费细目id = 细目id_In And Nvl(终止日期, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
          (Nvl(价格等级, '-'), 执行日期) In
          (Select Nvl(价格等级, '-'), Max(执行日期)
           From 收费价目
           Where 收费细目id = 细目id_In And 执行日期 > Sysdate And
                 Nvl(终止日期, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd')
           Group By 价格等级) And
          (
          --1.有"所有院区"权限
           站点_In Is Null
          --无“所有院区”权限 
           Or
          --2.1本站点项目
           Exists (Select 1 From 收费项目目录 Where ID = a.收费细目id And 站点 = 站点_In)
          --2.2全院项目
           Or Exists (Select 1 From 收费项目目录 Where ID = a.收费细目id And 站点 Is Null) And
           a.价格等级 In (Select m.名称
                                From 收费价格等级 M, 收费价格等级应用 N
                                Where m.名称 = n.价格等级 And Nvl(m.是否适用普通项目, 0) = 1 And n.站点 = 站点_In));
  
    Update 收费价目 A
    Set 终止日期 = To_Date('3000-01-01', 'yyyy-mm-dd')
    Where 收费细目id = 细目id_In And
          (Nvl(价格等级, '-'), 执行日期) In
          (Select Nvl(价格等级, '-'), Max(执行日期) From 收费价目 Where 收费细目id = 细目id_In Group By 价格等级) And
          (
          --1.有"所有院区"权限
           站点_In Is Null
          --无“所有院区”权限 
           Or
          --2.1本站点项目
           Exists (Select 1 From 收费项目目录 Where ID = a.收费细目id And 站点 = 站点_In)
          --2.2全院项目
           Or Exists (Select 1 From 收费项目目录 Where ID = a.收费细目id And 站点 Is Null) And
           a.价格等级 In (Select m.名称
                                From 收费价格等级 M, 收费价格等级应用 N
                                Where m.名称 = n.价格等级 And Nvl(m.是否适用普通项目, 0) = 1 And n.站点 = 站点_In));
  
  Else
    Delete From 收费价目 Where 收费细目id = 细目id_In And 价格等级 = 价格等级_In;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_收费价目_Delete;
/

--109706:冉俊明,2017-07-10,批量调价时，价格等级还未设置价格时在缺省价格等级基础上调整
--99878:冉俊明,2017-05-24,同一收费项目多个价格管理
Create Or Replace Procedure Zl_收费细目_Raisemass
(
  调整类型_In       In Number,
  调整值_In         In Number,
  执行日期_In       In Date,
  终止日期_In       In Date,
  调价人_In         In Varchar2,
  分类id_In         In 收费项目目录.分类id%Type := Null,
  类别_In           In 收费项目目录.类别%Type := Null,
  价格等级_In       In 收费价目.价格等级%Type := '所有',
  站点_In           In 收费项目目录.站点%Type := Null,
  以缺省价格调整_In Number := 0
) Is
  --批量调价 
  --入参： 
  --     以缺省价格调整_In 价格等级未设置价格时，是否在缺省价格的原价基础上调整 
  Type t_收费价目 Is Ref Cursor Return 收费价目%RowType;

  c_收费价目 t_收费价目;
  v_收费价目 收费价目%RowType;
  v_现价     收费价目.现价%Type;
  v_No       收费价目.No%Type;
  v_序号     收费价目.序号%Type;

  c_收费细目 Sys_Refcursor;
  n_细目id   收费项目目录.Id%Type;
  v_站点     收费项目目录.站点%Type;
Begin
  v_No   := Nextno(9);
  v_序号 := 1;

  If Nvl(以缺省价格调整_In, 0) = 1 Then
    If 调整类型_In = 1 Or 调整类型_In = 3 Then
      --同级项目 
      If 分类id_In Is Null Or 分类id_In = 0 Then
        Open c_收费细目 For
          Select ID, 站点 From 收费项目目录 Where 类别 = 类别_In And 是否变价 = 0;
      Else
        If 类别_In Is Null Then
          Open c_收费细目 For
            Select ID, 站点 From 收费项目目录 Where 分类id = 分类id_In And 是否变价 = 0;
        Else
          Open c_收费细目 For
            Select ID, 站点 From 收费项目目录 Where 分类id = 分类id_In And 类别 = 类别_In And 是否变价 = 0;
        End If;
      End If;
    Else
      --分类下所有项目 
      If 分类id_In Is Null Or 分类id_In = 0 Then
        Open c_收费细目 For
          Select c.Id, c.站点
          From 收费项目目录 C, (Select ID From 收费分类目录 Start With 上级id Is Null Connect By Prior ID = 上级id) D
          Where d.Id = c.分类id And c.类别 = 类别_In And c.是否变价 = 0;
      Else
        If 类别_In Is Null Then
          Open c_收费细目 For
            Select c.Id, c.站点
            From 收费项目目录 C, (Select ID From 收费分类目录 Start With ID = 分类id_In Connect By Prior ID = 上级id) D
            Where d.Id = c.分类id And c.是否变价 = 0;
        Else
          Open c_收费细目 For
            Select c.Id, c.站点
            From 收费项目目录 C, (Select ID From 收费分类目录 Start With ID = 分类id_In Connect By Prior ID = 上级id) D
            Where d.Id = c.分类id And c.类别 = 类别_In And c.是否变价 = 0;
        End If;
      End If;
    End If;
  
    Loop
      Fetch c_收费细目
        Into n_细目id, v_站点;
      Exit When c_收费细目%NotFound;
    
      For c_价格等级 In (Select Distinct a.名称 As 价格等级
                     From 收费价格等级 A, 收费价格等级应用 B
                     Where a.名称 = b.价格等级 And Nvl(a.是否适用普通项目, 0) = 1 And
                           (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
                           (价格等级_In = '所有' Or a.名称 = 价格等级_In) And Not Exists
                      (Select 1 From 收费价目 Where 收费细目id = n_细目id And 价格等级 = a.名称) And
                           (
                           --1.有"所有院区"权限，处理所有价格等级/指定价格等级 
                            (站点_In Is Null And (价格等级_In = '所有' Or Nvl(a.名称, '-') = Nvl(价格等级_In, '-')))
                           --2.无"所有院区"权限 
                            Or
                           --2.1本站点项目，处理所有价格等级/指定价格等级 
                            (v_站点 = 站点_In And (价格等级_In = '所有' Or Nvl(a.名称, '-') = Nvl(价格等级_In, '-')))
                           --2.2全院项目，所有价格等级/指定价格等级都只能处理本站点的有效价格等级价目 
                            Or (v_站点 Is Null
                            --2.2.1所有价格等级 
                            And (价格等级_In = '所有' And b.站点 = 站点_In)
                            --2.2.2指定价格等级 
                            Or a.名称 = 价格等级_In))) Loop
      
        For c_缺省价格 In (Select 收费细目id, 现价, 收入项目id, 加班加价率, 附术收费率
                       From 收费价目
                       Where 收费细目id = n_细目id And (终止日期 Is Null Or 终止日期 = To_Date('3000-01-01', 'YYYY-MM-DD')) And
                             价格等级 Is Null) Loop
        
          If 调整类型_In = 1 Or 调整类型_In = 2 Then
            --按比例 
            v_现价 := c_缺省价格.现价 * (1 + 调整值_In);
          Else
            v_现价 := c_缺省价格.现价 + 调整值_In;
          End If;
        
          If v_现价 > 0 Then
            --不填原价ID，否则在删除“未执行价格时”无法删除 
            Insert Into 收费价目
              (ID, 原价id, 收费细目id, 原价, 现价, 收入项目id, 加班加价率, 附术收费率, 变动原因, 调价说明, 调价id, 调价人, 执行日期, 终止日期, NO, 序号, 价格等级)
            Values
              (收费价目_Id.Nextval, Null, c_缺省价格.收费细目id, c_缺省价格.现价, v_现价, c_缺省价格.收入项目id, c_缺省价格.加班加价率, c_缺省价格.附术收费率, 1,
               '批量调价', 收费价目_Id.Nextval, 调价人_In, 执行日期_In, To_Date('3000-01-01', 'YYYY-MM-DD'), v_No, v_序号, c_价格等级.价格等级);
          
            v_序号 := v_序号 + 1;
          End If;
        End Loop;
      End Loop;
    End Loop;
    Close c_收费细目;
  End If;

  --首先按不同范围打开记录集 
  --取值为1、按比例，本范围;2、按比例，全范围;3、按值，本范围;4、按值，全范围; 
  If 调整类型_In = 1 Or 调整类型_In = 3 Then
    --同级项目 
    If 分类id_In Is Null Or 分类id_In = 0 Then
      Open c_收费价目 For
        Select a.*
        From 收费价目 A, (Select ID, 站点 From 收费项目目录 Where 类别 = 类别_In And 是否变价 = 0) B, 收费价格等级 P
        Where a.收费细目id = b.Id And a.价格等级 = p.名称(+) And
              (
              --1.有"所有院区"权限，处理所有价格等级/指定价格等级 
               (站点_In Is Null And (价格等级_In = '所有' Or Nvl(a.价格等级, '-') = Nvl(价格等级_In, '-')))
              --2.无"所有院区"权限 
               Or
              --2.1本站点项目，处理所有价格等级/指定价格等级 
               (b.站点 = 站点_In And (价格等级_In = '所有' Or Nvl(a.价格等级, '-') = Nvl(价格等级_In, '-')))
              --2.2全院项目，所有价格等级/指定价格等级都只能处理本站点的有效价格等级价目 
               Or (b.站点 Is Null
               --2.2.1所有价格等级 
               And (价格等级_In = '所有' And
               a.价格等级 In (Select m.名称
                                   From 收费价格等级 M, 收费价格等级应用 N
                                   Where m.名称 = n.价格等级 And Nvl(m.是否适用普通项目, 0) = 1 And n.站点 = 站点_In)
               --2.2.2指定价格等级 
               Or a.价格等级 = 价格等级_In))) And
              Nvl(a.终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')) = To_Date('3000-01-01', 'YYYY-MM-DD') And
              (p.撤档时间 Is Null Or p.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And Nvl(a.No, '-') <> v_No
        Order By a.收费细目id;
    Else
      If 类别_In Is Null Then
        Open c_收费价目 For
          Select a.*
          From 收费价目 A, (Select ID, 站点 From 收费项目目录 Where 分类id = 分类id_In And 是否变价 = 0) B, 收费价格等级 P
          Where a.收费细目id = b.Id And a.价格等级 = p.名称(+) And
                (
                --1.有"所有院区"权限，处理所有价格等级/指定价格等级 
                 (站点_In Is Null And (价格等级_In = '所有' Or Nvl(a.价格等级, '-') = Nvl(价格等级_In, '-')))
                --2.无"所有院区"权限 
                 Or
                --2.1本站点项目，处理所有价格等级/指定价格等级 
                 (b.站点 = 站点_In And (价格等级_In = '所有' Or Nvl(a.价格等级, '-') = Nvl(价格等级_In, '-')))
                --2.2全院项目，所有价格等级/指定价格等级都只能处理本站点的有效价格等级价目 
                 Or (b.站点 Is Null
                 --2.2.1所有价格等级 
                 And (价格等级_In = '所有' And
                 a.价格等级 In (Select m.名称
                                     From 收费价格等级 M, 收费价格等级应用 N
                                     Where m.名称 = n.价格等级 And Nvl(m.是否适用普通项目, 0) = 1 And n.站点 = 站点_In)
                 --2.2.2指定价格等级 
                 Or a.价格等级 = 价格等级_In))) And
                Nvl(a.终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')) = To_Date('3000-01-01', 'YYYY-MM-DD') And
                (p.撤档时间 Is Null Or p.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And Nvl(a.No, '-') <> v_No
          Order By a.收费细目id;
      Else
        Open c_收费价目 For
          Select a.*
          From 收费价目 A, (Select ID, 站点 From 收费项目目录 Where 分类id = 分类id_In And 类别 = 类别_In And 是否变价 = 0) B, 收费价格等级 P
          Where a.收费细目id = b.Id And a.价格等级 = p.名称(+) And
                (
                --1.有"所有院区"权限，处理所有价格等级/指定价格等级 
                 (站点_In Is Null And (价格等级_In = '所有' Or Nvl(a.价格等级, '-') = Nvl(价格等级_In, '-')))
                --2.无"所有院区"权限 
                 Or
                --2.1本站点项目，处理所有价格等级/指定价格等级 
                 (b.站点 = 站点_In And (价格等级_In = '所有' Or Nvl(a.价格等级, '-') = Nvl(价格等级_In, '-')))
                --2.2全院项目，所有价格等级/指定价格等级都只能处理本站点的有效价格等级价目 
                 Or (b.站点 Is Null
                 --2.2.1所有价格等级 
                 And (价格等级_In = '所有' And
                 a.价格等级 In (Select m.名称
                                     From 收费价格等级 M, 收费价格等级应用 N
                                     Where m.名称 = n.价格等级 And Nvl(m.是否适用普通项目, 0) = 1 And n.站点 = 站点_In)
                 --2.2.2指定价格等级 
                 Or a.价格等级 = 价格等级_In))) And
                Nvl(a.终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')) = To_Date('3000-01-01', 'YYYY-MM-DD') And
                (p.撤档时间 Is Null Or p.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And Nvl(a.No, '-') <> v_No
          Order By a.收费细目id;
      End If;
    End If;
  Else
    --分类下所有项目 
    If 分类id_In Is Null Or 分类id_In = 0 Then
      Open c_收费价目 For
        Select a.*
        From 收费价目 A,
             (Select c.Id, c.站点
               From 收费项目目录 C, (Select ID From 收费分类目录 Start With 上级id Is Null Connect By Prior ID = 上级id) D
               Where d.Id = c.分类id And c.类别 = 类别_In And c.是否变价 = 0) B, 收费价格等级 P
        Where a.收费细目id = b.Id And a.价格等级 = p.名称(+) And
              (
              --1.有"所有院区"权限，处理所有价格等级/指定价格等级 
               (站点_In Is Null And (价格等级_In = '所有' Or Nvl(a.价格等级, '-') = Nvl(价格等级_In, '-')))
              --2.无"所有院区"权限 
               Or
              --2.1本站点项目，处理所有价格等级/指定价格等级 
               (b.站点 = 站点_In And (价格等级_In = '所有' Or Nvl(a.价格等级, '-') = Nvl(价格等级_In, '-')))
              --2.2全院项目，所有价格等级/指定价格等级都只能处理本站点的有效价格等级价目 
               Or (b.站点 Is Null
               --2.2.1所有价格等级 
               And (价格等级_In = '所有' And
               a.价格等级 In (Select m.名称
                                   From 收费价格等级 M, 收费价格等级应用 N
                                   Where m.名称 = n.价格等级 And Nvl(m.是否适用普通项目, 0) = 1 And n.站点 = 站点_In)
               --2.2.2指定价格等级 
               Or a.价格等级 = 价格等级_In))) And
              Nvl(a.终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')) = To_Date('3000-01-01', 'YYYY-MM-DD') And
              (p.撤档时间 Is Null Or p.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And Nvl(a.No, '-') <> v_No
        Order By a.收费细目id;
    Else
      If 类别_In Is Null Then
        Open c_收费价目 For
          Select a.*
          From 收费价目 A,
               (Select c.Id, c.站点
                 From 收费项目目录 C, (Select ID From 收费分类目录 Start With ID = 分类id_In Connect By Prior ID = 上级id) D
                 Where d.Id = c.分类id And c.是否变价 = 0) B, 收费价格等级 P
          Where a.收费细目id = b.Id And a.价格等级 = p.名称(+) And
                (
                --1.有"所有院区"权限，处理所有价格等级/指定价格等级 
                 (站点_In Is Null And (价格等级_In = '所有' Or Nvl(a.价格等级, '-') = Nvl(价格等级_In, '-')))
                --2.无"所有院区"权限 
                 Or
                --2.1本站点项目，处理所有价格等级/指定价格等级 
                 (b.站点 = 站点_In And (价格等级_In = '所有' Or Nvl(a.价格等级, '-') = Nvl(价格等级_In, '-')))
                --2.2全院项目，所有价格等级/指定价格等级都只能处理本站点的有效价格等级价目 
                 Or (b.站点 Is Null
                 --2.2.1所有价格等级 
                 And (价格等级_In = '所有' And
                 a.价格等级 In (Select m.名称
                                     From 收费价格等级 M, 收费价格等级应用 N
                                     Where m.名称 = n.价格等级 And Nvl(m.是否适用普通项目, 0) = 1 And n.站点 = 站点_In)
                 --2.2.2指定价格等级 
                 Or a.价格等级 = 价格等级_In))) And
                Nvl(a.终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')) = To_Date('3000-01-01', 'YYYY-MM-DD') And
                (p.撤档时间 Is Null Or p.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And Nvl(a.No, '-') <> v_No
          Order By a.收费细目id;
      Else
        Open c_收费价目 For
          Select a.*
          From 收费价目 A,
               (Select c.Id, c.站点
                 From 收费项目目录 C, (Select ID From 收费分类目录 Start With ID = 分类id_In Connect By Prior ID = 上级id) D
                 Where d.Id = c.分类id And c.类别 = 类别_In And c.是否变价 = 0) B, 收费价格等级 P
          Where a.收费细目id = b.Id And a.价格等级 = p.名称(+) And
                (
                --1.有"所有院区"权限，处理所有价格等级/指定价格等级 
                 (站点_In Is Null And (价格等级_In = '所有' Or Nvl(a.价格等级, '-') = Nvl(价格等级_In, '-')))
                --2.无"所有院区"权限 
                 Or
                --2.1本站点项目，处理所有价格等级/指定价格等级 
                 (b.站点 = 站点_In And (价格等级_In = '所有' Or Nvl(a.价格等级, '-') = Nvl(价格等级_In, '-')))
                --2.2全院项目，所有价格等级/指定价格等级都只能处理本站点的有效价格等级价目 
                 Or (b.站点 Is Null
                 --2.2.1所有价格等级 
                 And (价格等级_In = '所有' And
                 a.价格等级 In (Select m.名称
                                     From 收费价格等级 M, 收费价格等级应用 N
                                     Where m.名称 = n.价格等级 And Nvl(m.是否适用普通项目, 0) = 1 And n.站点 = 站点_In)
                 --2.2.2指定价格等级 
                 Or a.价格等级 = 价格等级_In))) And
                Nvl(a.终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')) = To_Date('3000-01-01', 'YYYY-MM-DD') And
                (p.撤档时间 Is Null Or p.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And Nvl(a.No, '-') <> v_No
          Order By a.收费细目id;
      End If;
    End If;
  End If;

  --接着修改 
  Loop
    Fetch c_收费价目
      Into v_收费价目;
    Exit When c_收费价目%NotFound;
  
    If 调整类型_In = 1 Or 调整类型_In = 2 Then
      --按比例 
      v_现价 := v_收费价目.现价 * (1 + 调整值_In);
    Else
      v_现价 := v_收费价目.现价 + 调整值_In;
    End If;
  
    If v_现价 > 0 Then
      Update 收费价目 Set 终止日期 = 终止日期_In Where ID = v_收费价目.Id;
    
      Insert Into 收费价目
        (ID, 原价id, 收费细目id, 原价, 现价, 收入项目id, 加班加价率, 附术收费率, 变动原因, 调价说明, 调价id, 调价人, 执行日期, 终止日期, NO, 序号, 价格等级)
      Values
        (收费价目_Id.Nextval, v_收费价目.Id, v_收费价目.收费细目id, v_收费价目.现价, v_现价, v_收费价目.收入项目id, v_收费价目.加班加价率, v_收费价目.附术收费率, 1,
         '批量调价', 收费价目_Id.Nextval, 调价人_In, 执行日期_In, To_Date('3000-01-01', 'YYYY-MM-DD'), v_No, v_序号, v_收费价目.价格等级);
    
      v_序号 := v_序号 + 1;
    End If;
  End Loop;
  Close c_收费价目;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_收费细目_Raisemass;
/

--99878:冉俊明,2017-05-24,同一收费项目多个价格管理
Create Or Replace Procedure Zl_收费细目_Dept
(
  收费细目id_In In 收费项目目录.Id%Type,
  执行科室_In   In Number,
  应用范围_In   In Number,
  分类id_In     In 收费项目目录.分类id%Type,
  类别_In       In 收费项目目录.类别%Type,
  科室列表_In   In Varchar2, --开单科室定向执行的说明串，以|分割，每个定向按开单科室id^执行科室id形式组织
  门诊执行_In   In 诊疗执行科室.执行科室id%Type := Null,
  住院执行_In   In 诊疗执行科室.执行科室id%Type := Null,
  站点_In       In 收费项目目录.站点%Type := Null
) Is
  Type t_收费细目 Is Ref Cursor;

  c_收费细目   t_收费细目;
  v_Id         收费项目目录.Id%Type;
  v_执行科室   收费项目目录.执行科室%Type;
  v_Records    Varchar2(4000); --临时记录开单科室定向执行科室的字符串
  v_Currrec    Varchar2(1000); --包含在定向执行科室字符串中的一个定向
  v_Fields     Varchar2(1000);
  v_开单科室id 收费执行科室.开单科室id%Type := Null;
  v_执行科室id 收费执行科室.执行科室id%Type := Null;
Begin
  --首先按不同范围打开记录集
  If 应用范围_In = 1 Then
    --同级项目
    If 分类id_In Is Null Then
      Open c_收费细目 For
        Select ID, 执行科室
        From 收费项目目录
        Where 分类id Is Null And (站点_In Is Null Or 站点 = 站点_In)
        Order By 编码;
    Else
      Open c_收费细目 For
        Select ID, 执行科室
        From 收费项目目录
        Where 分类id = 分类id_In And (站点_In Is Null Or 站点 = 站点_In)
        Order By 编码;
    End If;
  Elsif 应用范围_In = 2 Then
    --分类下所有项目
    If 分类id_In Is Null Then
      Open c_收费细目 For
        Select c.Id, c.执行科室
        From 收费项目目录 C, (Select ID From 收费分类目录 Start With 上级id Is Null Connect By Prior ID = 上级id) D
        Where d.Id = c.分类id And (站点_In Is Null Or c.站点 = 站点_In)
        Order By 编码;
    Else
      Open c_收费细目 For
        Select c.Id, c.执行科室
        From 收费项目目录 C, (Select ID From 收费分类目录 Start With ID = 分类id_In Connect By Prior ID = 上级id) D
        Where d.Id = c.分类id And (站点_In Is Null Or c.站点 = 站点_In)
        Order By 编码;
    End If;
  Elsif 应用范围_In = 3 Then
    --类别下所有项目
    Open c_收费细目 For
      Select ID, 执行科室 From 收费项目目录 Where 类别 = 类别_In And (站点_In Is Null Or 站点 = 站点_In) Order By 编码;
  Else
    Open c_收费细目 For
      Select ID, 执行科室 From 收费项目目录 Where ID = 收费细目id_In;
  End If;

  --接着修改
  Loop
    Fetch c_收费细目
      Into v_Id, v_执行科室;
    Exit When c_收费细目%NotFound;
  
    If v_执行科室 = 4 Or v_执行科室 = 0 Then
      Delete From 收费执行科室 Where 收费细目id = v_Id;
    End If;
  
    Update 收费项目目录 Set 执行科室 = 执行科室_In Where ID = v_Id;
  
    If 执行科室_In = 4 And 门诊执行_In Is Not Null Then
      Insert Into 收费执行科室 (收费细目id, 病人来源, 开单科室id, 执行科室id) Values (v_Id, 1, Null, 门诊执行_In);
    End If;
    If (执行科室_In = 4 Or 执行科室_In = 0) And 住院执行_In Is Not Null Then
      Insert Into 收费执行科室 (收费细目id, 病人来源, 开单科室id, 执行科室id) Values (v_Id, 2, Null, 住院执行_In);
    End If;
    If 执行科室_In <> 4 Or 科室列表_In Is Null Then
      v_Records := Null;
    Else
      v_Records := 科室列表_In || '|';
    End If;
    While v_Records Is Not Null Loop
      v_Currrec    := Substr(v_Records, 1, Instr(v_Records, '|') - 1);
      v_Fields     := v_Currrec;
      v_开单科室id := To_Number(Substr(v_Fields, 1, Instr(v_Fields, '^') - 1));
      v_Fields     := Substr(v_Fields, Instr(v_Fields, '^') + 1);
      v_执行科室id := To_Number(v_Fields);
      Insert Into 收费执行科室
        (收费细目id, 病人来源, 开单科室id, 执行科室id)
      Values
        (v_Id, Null, Decode(v_开单科室id, 0, Null, v_开单科室id), v_执行科室id);
      v_Records := Replace('|' || v_Records, '|' || v_Currrec || '|');
    End Loop;
  End Loop;

  Close c_收费细目;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_收费细目_Dept;
/

--99878:冉俊明,2017-05-24,同一收费项目多个价格管理
Create Or Replace Procedure Zl_患者服务中心_换诊
(
  消息id_In     病人服务信息记录.Id%Type,
  No_In         病人挂号记录.No%Type,
  换诊序号_In   病人挂号记录.号序%Type,
  换诊时间_In   病人挂号记录.预约时间%Type,
  换诊id_In     临床出诊记录.Id%Type,
  处理说明_In   病人服务信息记录.处理说明%Type,
  操作员姓名_In 病人服务信息记录.处理人%Type,
  操作员编号_In 病人挂号记录.操作员编号%Type,
  价格等级_In   收费价目.价格等级%Type
) As
  Cursor c_Registinfo Is
    Select a.发生时间, a.登记时间, c.接收时间, a.收费细目id As 项目id, c.执行部门id As 科室id, c.执行人 As 医生姓名, d.Id As 医生id, c.号别 As 号码, c.号序
    From 门诊费用记录 A, 挂号安排 B, 病人挂号记录 C, 人员表 D
    Where a.记录性质 = 4 And c.No = a.No And c.执行人 = d.姓名(+) And a.No = No_In And Nvl(a.计算单位, '号别') = c.号别 And Rownum < 2;
  r_Registrow   c_Registinfo%RowType;
  v_号别        病人挂号记录.号别%Type;
  n_执行部门id  病人挂号记录.执行部门id%Type;
  n_项目id      临床出诊记录.项目id%Type;
  v_执行人      病人挂号记录.执行人%Type;
  n_执行人id    人员表.Id%Type;
  n_病历费      Number(2);
  n_收费        Number(2);
  n_Exists      Number(3);
  v_Temp        Varchar2(500);
  v_收费项目ids Varchar2(500);
  v_Err_Msg     Varchar2(500);
  n_病历费id    收费项目目录.Id%Type;
  n_序号        门诊费用记录.序号%Type;
  n_预约        病人挂号记录.预约%Type;
  n_实收金额    门诊费用记录.实收金额%Type;
  n_应收金额    门诊费用记录.应收金额%Type;
  v_费别        门诊费用记录.费别%Type;
  n_病人id      病人挂号记录.病人id%Type;
  n_已用        临床出诊记录.已挂数%Type;
  n_限制        临床出诊记录.限号数%Type;
  n_原号序      病人挂号记录.号序%Type;
  n_原记录id    临床出诊记录.Id%Type;
  n_原挂号状态  临床出诊序号控制.挂号状态%Type;
  v_原操作员    临床出诊序号控制.操作员姓名%Type;
  v_原备注      临床出诊序号控制.备注%Type;
  n_序号控制    临床出诊记录.是否序号控制%Type;
  n_预约顺序号  临床出诊序号控制.预约顺序号%Type;
  n_实际序号    临床出诊序号控制.序号%Type;
  n_变动id      就诊变动记录.Id%Type;
  Err_Item Exception;
Begin
  Begin
    Select 1, 病人id Into n_Exists, n_病人id From 病人挂号记录 Where NO = No_In And 记录状态 = 1;
  Exception
    When Others Then
      v_Err_Msg := '单据号为' || No_In || '的预约记录不存在,无法换诊!';
      Raise Err_Item;
  End;
  Begin
    Select 费别 Into v_费别 From 门诊费用记录 Where NO = No_In And 记录性质 = 4;
  Exception
    When Others Then
      Begin
        Select 费别 Into v_费别 From 病人信息 Where 病人id = n_病人id;
      Exception
        When Others Then
          v_费别 := Null;
      End;
  End;

  Select b.号码, b.科室id, Nvl(c.姓名, a.医生姓名), a.项目id, c.Id, Nvl(a.是否序号控制, 0)
  Into v_号别, n_执行部门id, v_执行人, n_项目id, n_执行人id, n_序号控制
  From 临床出诊记录 A, 临床出诊号源 B, 人员表 C
  Where a.Id = 换诊id_In And a.号源id = b.Id And a.医生id = c.Id(+);

  Select Max(1) Into n_收费 From 门诊费用记录 Where NO = No_In And 记录性质 = 4 And 结帐金额 Is Not Null;
  Select Max(1)
  Into n_病历费
  From 门诊费用记录 A, 收费特定项目 B
  Where a.No = No_In And a.记录性质 = 4 And a.收费细目id = b.收费细目id And b.特定项目 = '病历费';

  --就诊变动记录
  Select 就诊变动记录_Id.Nextval Into n_变动id From Dual;
  Zl_就诊变动记录_Insert(No_In, 4, '患者服务中心换诊', 操作员姓名_In, 操作员编号_In, v_号别, n_执行部门id, n_项目id, n_执行人id, v_执行人, Null, 换诊序号_In,
                   换诊时间_In, n_变动id);

  --更新患者服务记录
  Update 病人服务信息记录 Set 处理人 = 操作员姓名_In, 处理时间 = Sysdate, 处理说明 = 处理说明_In Where ID = 消息id_In;

  --更新病人挂号汇总(减少)
  Select 预约, 出诊记录id Into n_预约, n_原记录id From 病人挂号记录 Where NO = No_In And 记录状态 = 1;

  --检查换诊记录是否数量足够
  If n_预约 = 0 Then
    Select 已挂数, 限号数 Into n_已用, n_限制 From 临床出诊记录 Where ID = 换诊id_In;
    If Not n_限制 Is Null Then
      If Nvl(n_已用, 0) >= n_限制 Then
        v_Err_Msg := '要换诊的记录已经超过最大限制数量' || n_限制 || ',无法换诊!';
        Raise Err_Item;
      End If;
    End If;
  Else
    If n_收费 = 1 Then
      Select 已挂数, 限号数 Into n_已用, n_限制 From 临床出诊记录 Where ID = 换诊id_In;
      If Not n_限制 Is Null Then
        If Nvl(n_已用, 0) >= n_限制 Then
          v_Err_Msg := '要换诊的记录已经超过最大限制数量' || n_限制 || ',无法换诊!';
          Raise Err_Item;
        End If;
      End If;
    Else
      Select 已约数, 限约数 Into n_已用, n_限制 From 临床出诊记录 Where ID = 换诊id_In;
      If Not n_限制 Is Null Then
        If Nvl(n_已用, 0) >= n_限制 Then
          v_Err_Msg := '要换诊的记录已经超过最大限制数量' || n_限制 || ',无法换诊!';
          Raise Err_Item;
        End If;
      End If;
    End If;
  End If;

  If n_预约 = 0 Then
    Open c_Registinfo;
    Fetch c_Registinfo
      Into r_Registrow;
  
    n_原号序 := r_Registrow.号序;
    Update 临床出诊记录 Set 已挂数 = Nvl(已挂数, 0) - 1 Where ID = n_原记录id;
    Update 病人挂号汇总
    Set 已挂数 = Nvl(已挂数, 0) - 1
    Where 日期 = Trunc(r_Registrow.发生时间) And 医生姓名 = r_Registrow.医生姓名 And 医生id = r_Registrow.医生id And
          科室id = r_Registrow.科室id And 项目id = r_Registrow.项目id And (号码 = r_Registrow.号码 Or 号码 Is Null);
  
    If Sql%RowCount = 0 Then
      Insert Into 病人挂号汇总
        (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数)
      Values
        (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
         Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, -1);
    End If;
    Close c_Registinfo;
  Else
    If n_收费 = 1 Then
      Open c_Registinfo;
      Fetch c_Registinfo
        Into r_Registrow;
    
      n_原号序 := r_Registrow.号序;
    
      Update 临床出诊记录
      Set 已约数 = Nvl(已约数, 0) - 1, 其中已接收 = Nvl(其中已接收, 0) - 1, 已挂数 = Nvl(已挂数, 0) - 1
      Where ID = n_原记录id;
    
      Update 病人挂号汇总
      Set 已约数 = Nvl(已约数, 0) - 1, 其中已接收 = Nvl(其中已接收, 0) - 1, 已挂数 = Nvl(已挂数, 0) - 1
      Where 日期 = Trunc(r_Registrow.发生时间) And 医生姓名 = r_Registrow.医生姓名 And 医生id = r_Registrow.医生id And
            科室id = r_Registrow.科室id And 项目id = r_Registrow.项目id And (号码 = r_Registrow.号码 Or 号码 Is Null);
    
      If Sql%RowCount = 0 Then
        Insert Into 病人挂号汇总
          (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已约数, 其中已接收, 已挂数)
        Values
          (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
           Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, -1, -1, -1);
      End If;
      Close c_Registinfo;
    Else
      Open c_Registinfo;
      Fetch c_Registinfo
        Into r_Registrow;
    
      n_原号序 := r_Registrow.号序;
    
      Update 临床出诊记录 Set 已约数 = Nvl(已约数, 0) - 1 Where ID = n_原记录id;
      Update 病人挂号汇总
      Set 已约数 = Nvl(已约数, 0) - 1
      Where 日期 = Trunc(r_Registrow.发生时间) And 医生姓名 = r_Registrow.医生姓名 And 医生id = r_Registrow.医生id And
            科室id = r_Registrow.科室id And 项目id = r_Registrow.项目id And (号码 = r_Registrow.号码 Or 号码 Is Null);
    
      If Sql%RowCount = 0 Then
        Insert Into 病人挂号汇总
          (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已约数)
        Values
          (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
           Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, -1);
      End If;
      Close c_Registinfo;
    End If;
  End If;

  If n_序号控制 = 0 And Nvl(换诊序号_In, 0) <> 0 Then
    Select Max(预约顺序号)
    Into n_预约顺序号
    From 临床出诊序号控制
    Where 记录id = 换诊id_In And 序号 = 换诊序号_In And 预约顺序号 Is Not Null;
    If n_预约顺序号 Is Null Then
      n_预约顺序号 := 1;
    Else
      n_预约顺序号 := n_预约顺序号 + 1;
    End If;
    n_实际序号 := To_Number(换诊序号_In || n_预约顺序号);
  Else
    n_实际序号 := 换诊序号_In;
  End If;
  --更新病人挂号记录
  Update 病人挂号记录
  Set 号别 = v_号别, 执行部门id = n_执行部门id, 执行人 = v_执行人, 号序 = n_实际序号, 发生时间 = 换诊时间_In, 预约时间 = 换诊时间_In, 出诊记录id = 换诊id_In
  Where NO = No_In And 记录状态 = 1;

  --更新门诊费用记录
  If n_病历费 = 1 Then
    Select 收费细目id Into n_病历费id From 收费特定项目 Where 特定项目 = '病历费';
    v_收费项目ids := n_项目id || ',' || n_病历费id;
  Else
    v_收费项目ids := n_项目id;
  End If;
  Update 门诊费用记录
  Set 病人科室id = n_执行部门id, 计算单位 = v_号别, 发药窗口 = n_实际序号, 执行部门id = n_执行部门id, 执行人 = v_执行人, 发生时间 = 换诊时间_In
  Where NO = No_In And 记录性质 = 4;
  n_序号 := 1;
  For c_Item In (Select 1 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次, c.Id As 收入项目id,
                        c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, Null As 从属父号
                 From 收费项目目录 A, 收费价目 B, 收入项目 C
                 Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = n_项目id And Sysdate Between b.执行日期 And
                       Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And
                       (b.价格等级 = 价格等级_In Or
                       (b.价格等级 Is Null And Not Exists
                        (Select 1
                          From 收费价目
                          Where b.收费细目id = 收费细目id And 价格等级 = 价格等级_In And Sysdate Between 执行日期 And
                                Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')))))
                 Union All
                 Select 2 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次, c.Id As 收入项目id,
                        c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, Null As 从属父号
                 From 收费项目目录 A, 收费价目 B, 收入项目 C
                 Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = n_病历费id And Sysdate Between b.执行日期 And
                       Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And
                       (b.价格等级 = 价格等级_In Or
                       (b.价格等级 Is Null And Not Exists
                        (Select 1
                          From 收费价目
                          Where b.收费细目id = 收费细目id And 价格等级 = 价格等级_In And Sysdate Between 执行日期 And
                                Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')))))
                 Union All
                 Select 3 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, d.从项数次 As 数次,
                        c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, 1 As 从属父号
                 From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费从属项目 D
                 Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = d.从项id And
                       d.主项id In (Select Column_Value From Table(f_Str2list(v_收费项目ids))) And Sysdate Between b.执行日期 And
                       Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And
                       (b.价格等级 = 价格等级_In Or
                       (b.价格等级 Is Null And Not Exists
                        (Select 1
                          From 收费价目
                          Where b.收费细目id = 收费细目id And 价格等级 = 价格等级_In And Sysdate Between 执行日期 And
                                Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')))))
                 Order By 性质, 项目编码, 收入编码) Loop
    n_应收金额 := c_Item.单价 * c_Item.数次;
  
    If Nvl(c_Item.屏蔽费别, 0) <> 1 Then
      --打折:
      v_Temp     := Zl_Actualmoney(v_费别, c_Item.项目id, c_Item.收入项目id, n_应收金额);
      v_Temp     := Substr(v_Temp, Instr(v_Temp, ':') + 1);
      n_实收金额 := Zl_To_Number(v_Temp);
    Else
      n_实收金额 := n_应收金额;
    End If;
  
    If n_收费 = 1 Then
      Update 门诊费用记录
      Set 收费类别 = c_Item.类别, 收费细目id = c_Item.项目id, 收入项目id = c_Item.收入项目id, 收据费目 = c_Item.收据费目, 数次 = c_Item.数次,
          标准单价 = c_Item.单价, 应收金额 = n_应收金额, 实收金额 = n_实收金额, 结帐金额 = n_实收金额
      Where 序号 = n_序号 And 记录性质 = 4 And NO = No_In;
      If Sql%RowCount = 0 Then
        Insert Into 门诊费用记录
          (ID, 记录性质, 记录状态, 序号, 价格父号, 从属父号, NO, 实际票号, 门诊标志, 加班标志, 附加标志, 发药窗口, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 病人科室id,
           收费类别, 计算单位, 收费细目id, 收入项目id, 收据费目, 付数, 数次, 标准单价, 应收金额, 实收金额, 结帐金额, 结帐id, 记帐费用, 开单部门id, 开单人, 划价人, 执行部门id, 执行人,
           操作员编号, 操作员姓名, 发生时间, 登记时间, 保险大类id, 保险项目否, 保险编码, 统筹金额, 摘要, 结论, 缴款组id)
          Select 病人费用记录_Id.Nextval, 4, 记录状态, n_序号, Null, Null, NO, 实际票号, 门诊标志, Null, Null, 发药窗口, 病人id, 标识号, 付款方式, 姓名, 性别,
                 年龄, 费别, 病人科室id, c_Item.类别, 计算单位, c_Item.项目id, c_Item.收入项目id, c_Item.收据费目, 1, c_Item.数次, c_Item.单价,
                 n_应收金额, n_实收金额, n_实收金额, 结帐id, 0, 开单部门id, 开单人, 划价人, 执行部门id, 执行人, 操作员编号, 操作员姓名, 发生时间, 登记时间, 保险大类id, 保险项目否,
                 保险编码, 统筹金额, 摘要, 结论, 缴款组id
          From 门诊费用记录
          Where 记录性质 = 4 And NO = No_In And 序号 = 1;
      End If;
    Else
      Update 门诊费用记录
      Set 收费细目id = c_Item.项目id, 收入项目id = c_Item.收入项目id, 收据费目 = c_Item.收据费目, 标准单价 = c_Item.单价, 应收金额 = c_Item.单价,
          实收金额 = c_Item.单价
      Where 序号 = n_序号 And 记录性质 = 4 And NO = No_In;
      If Sql%RowCount = 0 Then
        Insert Into 门诊费用记录
          (ID, 记录性质, 记录状态, 序号, 价格父号, 从属父号, NO, 实际票号, 门诊标志, 加班标志, 附加标志, 发药窗口, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 病人科室id,
           收费类别, 计算单位, 收费细目id, 收入项目id, 收据费目, 付数, 数次, 标准单价, 应收金额, 实收金额, 结帐金额, 结帐id, 记帐费用, 开单部门id, 开单人, 划价人, 执行部门id, 执行人,
           操作员编号, 操作员姓名, 发生时间, 登记时间, 保险大类id, 保险项目否, 保险编码, 统筹金额, 摘要, 结论, 缴款组id)
          Select 病人费用记录_Id.Nextval, 4, 记录状态, n_序号, Null, Null, NO, 实际票号, 门诊标志, Null, Null, 发药窗口, 病人id, 标识号, 付款方式, 姓名, 性别,
                 年龄, 费别, 病人科室id, c_Item.类别, 计算单位, c_Item.项目id, c_Item.收入项目id, c_Item.收据费目, 1, c_Item.数次, c_Item.单价,
                 n_应收金额, n_实收金额, Null, 结帐id, 0, 开单部门id, 开单人, 划价人, 执行部门id, 执行人, 操作员编号, 操作员姓名, 发生时间, 登记时间, 保险大类id, 保险项目否,
                 保险编码, 统筹金额, 摘要, 结论, 缴款组id
          From 门诊费用记录
          Where 记录性质 = 4 And NO = No_In And 序号 = 1;
      End If;
    End If;
    n_序号 := n_序号 + 1;
  End Loop;

  --更新病人挂号汇总(增加)
  If n_预约 = 0 Then
    Open c_Registinfo;
    Fetch c_Registinfo
      Into r_Registrow;
  
    Update 临床出诊记录 Set 已挂数 = Nvl(已挂数, 0) + 1 Where ID = 换诊id_In;
  
    Update 病人挂号汇总
    Set 已挂数 = Nvl(已挂数, 0) + 1
    Where 日期 = Trunc(r_Registrow.发生时间) And 医生姓名 = r_Registrow.医生姓名 And 医生id = r_Registrow.医生id And
          科室id = r_Registrow.科室id And 项目id = r_Registrow.项目id And (号码 = r_Registrow.号码 Or 号码 Is Null);
  
    If Sql%RowCount = 0 Then
      Insert Into 病人挂号汇总
        (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数)
      Values
        (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
         Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, 1);
    End If;
    Close c_Registinfo;
  Else
    If n_收费 = 1 Then
      Open c_Registinfo;
      Fetch c_Registinfo
        Into r_Registrow;
    
      Update 临床出诊记录
      Set 已约数 = Nvl(已约数, 0) + 1, 其中已接收 = Nvl(其中已接收, 0) + 1, 已挂数 = Nvl(已挂数, 0) + 1
      Where ID = 换诊id_In;
    
      Update 病人挂号汇总
      Set 已约数 = Nvl(已约数, 0) + 1, 其中已接收 = Nvl(其中已接收, 0) + 1, 已挂数 = Nvl(已挂数, 0) + 1
      Where 日期 = Trunc(r_Registrow.发生时间) And 医生姓名 = r_Registrow.医生姓名 And 医生id = r_Registrow.医生id And
            科室id = r_Registrow.科室id And 项目id = r_Registrow.项目id And (号码 = r_Registrow.号码 Or 号码 Is Null);
    
      If Sql%RowCount = 0 Then
        Insert Into 病人挂号汇总
          (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已约数, 其中已接收, 已挂数)
        Values
          (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
           Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, 1, 1, 1);
      End If;
      Close c_Registinfo;
    Else
      Open c_Registinfo;
      Fetch c_Registinfo
        Into r_Registrow;
    
      Update 临床出诊记录 Set 已约数 = Nvl(已约数, 0) + 1 Where ID = 换诊id_In;
    
      Update 病人挂号汇总
      Set 已约数 = Nvl(已约数, 0) + 1
      Where 日期 = Trunc(r_Registrow.发生时间) And 医生姓名 = r_Registrow.医生姓名 And 医生id = r_Registrow.医生id And
            科室id = r_Registrow.科室id And 项目id = r_Registrow.项目id And (号码 = r_Registrow.号码 Or 号码 Is Null);
    
      If Sql%RowCount = 0 Then
        Insert Into 病人挂号汇总
          (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已约数)
        Values
          (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
           Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, 1);
      End If;
      Close c_Registinfo;
    End If;
  End If;
  --更新序号
  Begin
    Select 挂号状态, 操作员姓名, 备注
    Into n_原挂号状态, v_原操作员, v_原备注
    From 临床出诊序号控制
    Where 记录id = n_原记录id And (序号 = n_原号序 Or 备注 = n_原号序);
  
    If n_序号控制 = 0 And Nvl(换诊序号_In, 0) <> 0 Then
      Insert Into 临床出诊序号控制
        (记录id, 序号, 预约顺序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 操作员姓名, 备注)
        Select 记录id, 序号, n_预约顺序号, 开始时间, 终止时间, 1, 是否预约, n_原挂号状态, v_原操作员, n_实际序号
        From 临床出诊序号控制
        Where 记录id = 换诊id_In And 序号 = 换诊序号_In And 预约顺序号 Is Null;
    Else
      Update 临床出诊序号控制
      Set 挂号状态 = n_原挂号状态, 操作员姓名 = v_原操作员, 备注 = v_原备注
      Where 记录id = 换诊id_In And 序号 = 换诊序号_In;
    End If;
  
    Update 临床出诊序号控制
    Set 挂号状态 = Null, 操作员姓名 = Null, 备注 = Null
    Where 记录id = n_原记录id And (序号 = n_原号序 Or 备注 = n_原号序);
  Exception
    When Others Then
      Null;
  End;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_患者服务中心_换诊;
/

--99878:冉俊明,2017-05-24,同一收费项目多个价格管理
Create Or Replace Procedure Zl1_Autocptone
(
  病人id_In   In Number,
  主页id_In   In Number,
  期间_In     In Varchar2,
  在院记帐_In In Number := 0,
  强制记帐_In In Number := 0
) As

  -------------------------------------------------------------------------
  --功能说明：完成指定病人指定期间自动计价项目表设置自动计算的项目进行记帐处理
  --          1、系统首先根据系统参数"修正上期自动计费"，修改以往该病人自动记帐记录标志;
  --          2、综合病人的床位变化、入出转情况、调价情况等多项因素，结合期间跨度、病人费
  --             别等完成费用的正确计算：
  --             如果发现已经计算，则修改标志为正常;如果未计算，则插入新的自动记帐记录;
  --             作废以前的错误计算的记录;
  --             统计本次变动(新增和作废)，填写余额表和汇总表;
  --入口参数：
  --       病人ID_IN  number    病人身份ID
  --       主页ID_IN  number    病案主页ID，两个参数共同确定需要计算的病人
  --       期间_IN  varchar2     需要计算的最小期间
  --       在院记帐_IN number   为1时,仅计算在院病人的费用
  --       强制记帐_IN number   为1时,不受病案主页.禁止自动记帐属性控制
  --调用关系：zl1_AutoCptPati/zl1_AutoCptWard/zl1_AutoCptAll 调用本过程

  Cursor v_Autocur
  (
    期间_In Varchar2,
    Insure  病案主页.险类%Type
  ) Is
    Select l.病人id, l.主页id, l.姓名, l.性别, l.年龄, l.住院号, l.费别, l.科室id, l.病区id, l.床号, l.附加床位, l.收费细目id, l.收入项目id, l.标志, l.标准单价,
           Greatest(l.开始日期, Trunc(p.开始日期)) As 开始日期, l.终止日期, l.天数, l.数量, l.经治医师, l.责任护士, l.操作员编号, l.操作员姓名, i.险类, i.大类id,
           k.算法, k.统筹比额
    From (Select * From 出院病人自动记帐 Where 病人id = 病人id_In And 主页id = 主页id_In) L,
         (Select Min(开始日期) As 开始日期 From 期间表 Where 期间 >= 期间_In) P, 保险支付项目 I, 保险支付大类 K
    Where Trunc(l.终止日期) >= Trunc(p.开始日期) And l.收费细目id = i.收费细目id(+) And i.险类(+) = Insure And i.大类id = k.Id(+)
    Order By l.开始日期;

  Cursor v_Autocurzy
  (
    期间_In Varchar2,
    Insure  病案主页.险类%Type
  ) Is
    Select l.病人id, l.主页id, l.姓名, l.性别, l.年龄, l.住院号, l.费别, l.科室id, l.病区id, l.床号, l.附加床位, l.收费细目id, l.收入项目id, l.标志, l.标准单价,
           Greatest(l.开始日期, Trunc(p.开始日期)) As 开始日期, l.终止日期, l.天数, l.数量, l.经治医师, l.责任护士, l.操作员编号, l.操作员姓名, i.险类, i.大类id,
           k.算法, k.统筹比额
    From (Select * From 在院病人自动记帐 Where 病人id = 病人id_In And 主页id = 主页id_In) L,
         (Select Min(开始日期) As 开始日期 From 期间表 Where 期间 >= 期间_In) P, 保险支付项目 I, 保险支付大类 K
    Where Trunc(l.终止日期) >= Trunc(p.开始日期) And l.收费细目id = i.收费细目id(+) And i.险类(+) = Insure And i.大类id = k.Id(+)
    Order By l.开始日期;

  n_Insure       病案主页.险类%Type;
  v_Billno       Varchar2(8); --费用表实际的自动记帐号码
  n_Datecount    Integer; --日期计数器
  d_Datefrom     Date; --开始计算日期
  d_Dateto       Date; --终止计算日期
  d_Datelast     Date;
  n_Billcount    Number(5) := 0; --单据序号计数器
  n_Exsetax      Number(16, 2) := 0; --费用收取比率
  n_Exsetax_Temp Number(16, 2) := 0; --费用收取比率
  n_Summoney     Number(16, 2) := 0; --金额

  Cursor v_Sumcur
  (
    Billno    Varchar2,
    Datestart Date
  ) Is
    Select 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, Sum(Decode(附加标志, 0, 1, -1) * 应收金额) As 应收金额,
           Sum(Decode(附加标志, 0, 1, -1) * 实收金额) As 实收金额
    From 住院费用记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And
          (NO = Billno Or 附加标志 = 5 And 发生时间 >= Datestart)
    Group By 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id;

  n_Dec            Number; --金额小数位数
  d_登记时间       Date; --登记时间
  d_发生时间       Date; --发生时间
  n_Dates          Number(3, 1); --当前记录的天数，全天为1
  n_Do             Number(1);
  n_返回值         病人余额.预交余额%Type;
  n_Delete         Number;
  n_医疗小组id     住院费用记录.医疗小组id%Type;
  n_护理计算标准   Number(2); --护理费计算标准
  n_收费细目id     Number(18);
  n_Temp           Number(18);
  l_护理id         t_Numlist := t_Numlist();
  l_护理等级       t_Numlist := t_Numlist();
  n_护理项目       Number(2); --1:是护理项目;0-非不护理
  n_价格           收费价目.现价%Type;
  n_护理已处理     Number(2); --1-护理费已经处理,;0-未处理
  n_收入项目id     Number(18);
  n_从属项目       Number(2);
  n_审核标志       病案主页.审核标志%Type;
  n_住院状态       病案主页.状态%Type;
  n_病人审核方式   Number(2);
  n_未入科禁止记账 Number(2);
  n_禁止自动记帐   Number(2);

  n_病人病区id 住院费用记录.病人病区id%Type;
  n_开单部门id 住院费用记录.开单部门id%Type;

  --已经计算了的护理类型
  Type t_护理_Rec Is Record(
    收费细目id 收费项目目录.Id%Type,
    日期       Date);
  Type t_护理 Is Table Of t_护理_Rec;
  c_护理 t_护理 := t_护理();
Begin
  Begin
    Select 险类, Nvl(审核标志, 0), Nvl(状态, 0), Nvl(是否禁止自动记帐, 0)
    Into n_Insure, n_审核标志, n_住院状态, n_禁止自动记帐
    From 病案主页
    Where 病人id = 病人id_In And 主页id = 主页id_In;
  Exception
    When Others Then
      Return;
  End;

  If 强制记帐_In = 0 And n_禁止自动记帐 = 1 Then
    Return;
  End If;

  n_病人审核方式   := Nvl(zl_GetSysParameter(185), 0);
  n_未入科禁止记账 := Nvl(zl_GetSysParameter(215), 0);
  If n_病人审核方式 = 1 And Nvl(n_审核标志, 0) >= 1 Then
    Return;
  End If;
  If n_未入科禁止记账 = 1 And n_住院状态 = 1 Then
    Return;
  End If;

  v_Billno := Nextno(17);

  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')), Zl_To_Number(Nvl(zl_GetSysParameter(160), '0'))
  Into n_Dec, n_护理计算标准
  From Dual;

  --每天5点以前，将记录时间登记为昨天，否则登记为当时
  Select Decode(Sign(To_Number(To_Char(Sysdate, 'HH24')) - 5), -1, Trunc(Sysdate) - 1 / 24 / 60, Sysdate)
  Into d_登记时间
  From Dual;

  --锁定该病人的记录,以免重复计算
  Update 病案主页 Set 状态 = 状态 Where 病人id = 病人id_In And 主页id = 主页id_In;

  -----------------------------------------------------------------
  d_Datefrom := Sysdate + 1000;
  d_Dateto   := Sysdate - 1000;
  n_Do       := 0;
  --------------------------------------------------------------------
  If n_护理计算标准 = 1 Then
    --同天以最高价位的护理费为准,先将其护理等级记住,
    For v_护理 In (Select Distinct 护理等级id
                 From (Select 护理等级id
                        From 病人变动记录
                        Where 开始原因 <> 10 And 病人id = 病人id_In And 主页id = 主页id_In
                        Union All
                        Select i.从项id As 护理等级id
                        From 病人变动记录 B, 收费从属项目 I
                        Where b.护理等级id = i.主项id And 病人id = 病人id_In And 主页id = 主页id_In And b.开始原因 <> 10 And i.固有从属 > 0)) Loop
      If Nvl(v_护理.护理等级id, 0) <> 0 Then
        l_护理id.Extend;
        l_护理id(l_护理id.Count) := v_护理.护理等级id;
      End If;
    End Loop;
  End If;
  -----------------------------------------------------------------
  --循环检查计算情况，并增加正确和新计算的记录
  -----------------------------------------------------------------
  If 在院记帐_In = 1 Then
    For v_Currrow In v_Autocurzy(期间_In, n_Insure) Loop
    
      n_医疗小组id := Zl_医疗小组_Get(v_Currrow.科室id, v_Currrow.操作员姓名, v_Currrow.病人id, v_Currrow.主页id, d_发生时间);
    
      If d_Datefrom > v_Currrow.开始日期 Then
        d_Datefrom := v_Currrow.开始日期;
        n_Do       := 1;
        --将本次开始计算时间以后的已计算记录标志修改
        Update 住院费用记录
        Set 附加标志 = 5
        Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And 附加标志 <> 8 And Nvl(医嘱序号, 0) = 0 And
              发生时间 >= v_Currrow.开始日期;
      End If;
    
      If d_Dateto < v_Currrow.终止日期 Then
        d_Dateto := v_Currrow.终止日期;
      End If;
      n_收费细目id := v_Currrow.收费细目id;
      n_护理项目   := 0;
      --护理费计算标准:0-按最后一次护理计算;1-按价格最高的护理等级计算。
      If n_护理计算标准 = 1 Then
        --先确定是否护理项目,如果是,则需要重新进行计算
        Select Count(*) Into n_护理项目 From Table(l_护理id) Where Column_Value = n_收费细目id;
      End If;
    
      --提取当前收入项目的收费比率
      Begin
        Select 实收比率
        Into n_Exsetax
        From (Select 实收比率
               From 费别明细
               Where 费别 = v_Currrow.费别 And 收费细目id = v_Currrow.收费细目id And
                     (Abs(v_Currrow.标准单价 * v_Currrow.数量) Between 应收段首值 And 应收段尾值)
               Union All
               Select 实收比率
               From 费别明细
               Where 费别 = v_Currrow.费别 And 收入项目id = v_Currrow.收入项目id And
                     (Abs(v_Currrow.标准单价 * v_Currrow.数量) Between 应收段首值 And 应收段尾值) And Not Exists
                (Select 1 From 费别明细 Where 费别 = v_Currrow.费别 And 收费细目id = v_Currrow.收费细目id));
      Exception
        When Others Then
          n_Exsetax := 100.00;
      End;
    
      n_Exsetax := Nvl(n_Exsetax, 100);
      For n_Datecount In 0 .. (Trunc(v_Currrow.终止日期 + 0.5) - Trunc(v_Currrow.开始日期)) - 1 Loop
        d_发生时间   := Greatest(v_Currrow.开始日期, Trunc(v_Currrow.开始日期 + n_Datecount));
        n_Dates      := Least(Trunc(v_Currrow.开始日期 + n_Datecount + 1), v_Currrow.终止日期) -
                        Greatest(v_Currrow.开始日期, Trunc(v_Currrow.开始日期 + n_Datecount));
        n_护理已处理 := 0;
        If n_护理项目 = 1 Then
          --1.先检查当天是否存在护理变动,只有存在多个护理变动的,才会去处理(以主项目为准)
          n_从属项目 := 1;
          If l_护理等级.Count > 0 Then
            l_护理等级.Delete;
          End If;
          For v_护理 In (Select Distinct 护理等级id
                       From 病人变动记录
                       Where 开始原因 <> 10 And 病人id = 病人id_In And 主页id = 主页id_In And
                             (Trunc(开始时间) = Trunc(d_发生时间) Or Trunc(Nvl(终止时间, Sysdate)) = Trunc(d_发生时间))) Loop
            If Nvl(v_护理.护理等级id, 0) <> 0 Then
              l_护理等级.Extend;
              l_护理等级(l_护理等级.Count) := v_护理.护理等级id;
              If Nvl(v_护理.护理等级id, 0) = Nvl(v_Currrow.收费细目id, 0) Then
                n_从属项目 := 0;
              End If;
            End If;
          End Loop;
          If l_护理等级.Count > 1 Then
            --2. 存在两个以上变动,则取价位最高的
            n_Temp       := v_Currrow.收费细目id;
            n_价格       := Nvl(v_Currrow.标准单价, 0);
            n_收入项目id := v_Currrow.收入项目id;
            --本身是从属项目时,由于主项目计算时,已经计算了的,所以就不再计算
            If Nvl(n_从属项目, 0) = 1 Then
              n_护理已处理 := 1;
            End If;
            --因为可能存在多个收入项目,但收费细目相同的情况,因此,必须先检查该项目是否已经参与计算过的
            For I In 1 .. c_护理.Count Loop
              If c_护理(I).收费细目id = v_Currrow.收费细目id And c_护理(I).日期 = Trunc(d_发生时间) Then
                n_护理已处理 := 1;
                Exit;
              End If;
            End Loop;
            If Nvl(n_护理已处理, 0) = 0 Then
              c_护理.Extend;
              c_护理(c_护理.Count).收费细目id := v_Currrow.收费细目id;
              c_护理(c_护理.Count).日期 := Trunc(d_发生时间);
            End If;
            If Nvl(n_从属项目, 0) = 0 And Nvl(n_护理已处理, 0) = 0 Then
              --3.处理最高价位
              For v_价位 In (Select /*+ rule */
                            a.Column_Value As 收费细目id, p.现价, p.收入项目id
                           From Table(l_护理等级) A, 收费价目 P, 收费项目目录 C
                           Where a.Column_Value = p.收费细目id And a.Column_Value = c.Id And d_发生时间 Between p.执行日期 And
                                 Nvl(p.终止日期, Sysdate) And Nvl(c.计算方式, 0) <> 1 And p.价格等级 Is Null) Loop
                If Nvl(v_价位.现价, 0) > n_价格 Then
                  n_价格       := Nvl(v_价位.现价, 0);
                  n_Temp       := v_价位.收费细目id;
                  n_收入项目id := v_价位.收入项目id;
                End If;
              End Loop;
            
              If n_Temp <> v_Currrow.收费细目id And Nvl(n_护理已处理, 0) = 0 Then
              
                n_开单部门id := v_Currrow.科室id;
                n_病人病区id := v_Currrow.病区id;
              
                For c_变动记录 In (Select 病区id, 科室id
                               From 病人变动记录
                               Where 开始原因 <> 10 And 病人id = 病人id_In And 主页id = 主页id_In And 护理等级id + 0 = n_Temp And
                                     (Trunc(开始时间) = Trunc(d_发生时间) Or Trunc(Nvl(终止时间, Sysdate)) = Trunc(d_发生时间))
                               Order By 开始时间 Desc) Loop
                  n_开单部门id := c_变动记录.科室id;
                  n_病人病区id := c_变动记录.病区id;
                  Exit;
                End Loop;
              
                --4. 不等的话,需要重新处理相关费用
                For v_费用 In (Select n_Temp As 收费细目id, v_Currrow.数量 As 数量, n_价格 As 单价, n_收入项目id As 收入项目id
                             From Dual
                             Union All
                             Select 从项id As 收费细目id, a.从项数次 As 数量, p.现价 As 单价, p.收入项目id
                             From 收费从属项目 A, 收费价目 P, 收费项目目录 C
                             Where a.从项id = p.收费细目id And a.从项id = c.Id And Nvl(c.计算方式, 0) <> 1 And a.主项id = n_Temp And
                                   d_发生时间 Between p.执行日期 And Nvl(p.终止日期, Sysdate) And p.价格等级 Is Null) Loop
                  --确定比例
                  Begin
                    Select 实收比率
                    Into n_Exsetax_Temp
                    From (Select 实收比率
                           From 费别明细
                           Where 费别 = v_Currrow.费别 And 收费细目id = v_费用.收费细目id And
                                 (Abs(v_费用.单价 * v_费用.数量) Between 应收段首值 And 应收段尾值)
                           Union All
                           Select 实收比率
                           From 费别明细
                           Where 费别 = v_Currrow.费别 And 收入项目id = v_费用.收入项目id And
                                 (Abs(v_费用.单价 * v_费用.数量) Between 应收段首值 And 应收段尾值) And Not Exists
                            (Select 1 From 费别明细 Where 费别 = v_Currrow.费别 And 收费细目id = v_费用.收费细目id));
                  Exception
                    When Others Then
                      n_Exsetax_Temp := 100.00;
                  End;
                  n_Exsetax_Temp := Nvl(n_Exsetax_Temp, 100);
                  --如果已经计算，原记录计算完全正确，则直接修改将标志改正
                  Update 住院费用记录
                  Set 附加标志 = 0
                  Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And Nvl(加班标志, 0) = v_Currrow.附加床位 And
                        病人科室id = Nvl(n_开单部门id, 0) And 病人病区id = Nvl(n_病人病区id, 0) And Nvl(床号, 0) = Nvl(v_Currrow.床号, 0) And
                        收费细目id = v_费用.收费细目id And 收入项目id = v_费用.收入项目id And 发生时间 = d_发生时间 And 数次 = v_费用.数量 * n_Dates And
                        标准单价 = v_费用.单价 And 应收金额 = Round(v_费用.单价 * v_费用.数量 * n_Dates, n_Dec) And
                        实收金额 = Round(v_费用.单价 * v_费用.数量 * n_Dates * n_Exsetax / 100, n_Dec);
                
                  If Sql%RowCount = 0 Then
                    --如果未计算或计算错误，则增加正确的计算记录
                    Insert Into 住院费用记录
                      (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 医嘱序号, 门诊标志, 病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id,
                       姓名, 性别, 年龄, 标识号, 床号, 费别, 记帐费用, 收费细目id, 收入项目id, 附加标志, 标准单价, 付数, 数次, 应收金额, 实收金额, 收费类别, 计算单位, 加班标志,
                       收据费目, 开单人, 划价人, 操作员编号, 操作员姓名, 发生时间, 登记时间, 保险项目否, 保险大类id, 统筹金额, 医疗小组id)
                      Select 病人费用记录_Id.Nextval, 3, v_Billno, 1, Rownum + n_Billcount, Null, Null, 0, Null,
                             Decode(v_Currrow.主页id, Null, 1, 2), v_Currrow.病人id, v_Currrow.主页id, n_病人病区id, n_开单部门id,
                             n_开单部门id, n_病人病区id, v_Currrow.姓名, v_Currrow.性别, v_Currrow.年龄, v_Currrow.住院号, v_Currrow.床号,
                             v_Currrow.费别, 1, v_费用.收费细目id, v_费用.收入项目id, 0, v_费用.单价, 1, v_费用.数量 * n_Dates,
                             Round(v_费用.单价 * v_费用.数量 * n_Dates, n_Dec),
                             Round(v_费用.单价 * v_费用.数量 * n_Dates * n_Exsetax / 100, n_Dec), i.类别, i.计算单位, v_Currrow.附加床位,
                             j.收据费目, v_Currrow.经治医师, v_Currrow.责任护士, v_Currrow.操作员编号, v_Currrow.操作员姓名, d_发生时间, d_登记时间,
                             Decode(v_Currrow.险类, Null, 0, 1), v_Currrow.大类id,
                             Decode(v_Currrow.算法, 1,
                                     Round(v_费用.单价 * v_费用.数量 * n_Dates * n_Exsetax / 100 * v_Currrow.统筹比额 / 100, n_Dec), 2,
                                     v_Currrow.统筹比额, 0), n_医疗小组id
                      From (Select 类别, 计算单位
                             From 收费细目
                             Where ID = v_费用.收费细目id And (撤档时间 Is Null Or 撤档时间 > d_发生时间)) I,
                           (Select 收据费目
                             From 收入项目
                             Where ID = v_费用.收入项目id And (撤档时间 Is Null Or 撤档时间 > d_发生时间)) J;
                    n_Billcount := n_Billcount + Sql%RowCount;
                  End If;
                  n_护理已处理 := 1;
                End Loop;
              End If;
            End If;
          End If;
        End If;
      
        If Nvl(n_护理已处理, 0) = 0 Then
          --如果已经计算，原记录计算完全正确，则直接修改将标志改正
          Update 住院费用记录
          Set 附加标志 = 0
          Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And Nvl(加班标志, 0) = v_Currrow.附加床位 And
                病人科室id = v_Currrow.科室id And 病人病区id = Nvl(v_Currrow.病区id, 0) And Nvl(床号, 0) = Nvl(v_Currrow.床号, 0) And
                收费细目id = v_Currrow.收费细目id And 收入项目id = v_Currrow.收入项目id And 发生时间 = d_发生时间 And
                数次 = v_Currrow.数量 * n_Dates And 标准单价 = v_Currrow.标准单价 And
                应收金额 = Round(v_Currrow.标准单价 * v_Currrow.数量 * n_Dates, n_Dec) And
                实收金额 = Round(v_Currrow.标准单价 * v_Currrow.数量 * n_Dates * n_Exsetax / 100, n_Dec);
        
          If Sql%RowCount = 0 Then
            --如果未计算或计算错误，则增加正确的计算记录\
            Insert Into 住院费用记录
              (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 医嘱序号, 门诊标志, 病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 姓名, 性别,
               年龄, 标识号, 床号, 费别, 记帐费用, 收费细目id, 收入项目id, 附加标志, 标准单价, 付数, 数次, 应收金额, 实收金额, 收费类别, 计算单位, 加班标志, 收据费目, 开单人, 划价人,
               操作员编号, 操作员姓名, 发生时间, 登记时间, 保险项目否, 保险大类id, 统筹金额, 医疗小组id)
              Select 病人费用记录_Id.Nextval, 3, v_Billno, 1, Rownum + n_Billcount, Null, Null, 0, Null,
                     Decode(v_Currrow.主页id, Null, 1, 2), v_Currrow.病人id, v_Currrow.主页id, v_Currrow.病区id, v_Currrow.科室id,
                     v_Currrow.科室id, v_Currrow.病区id, v_Currrow.姓名, v_Currrow.性别, v_Currrow.年龄, v_Currrow.住院号,
                     v_Currrow.床号, v_Currrow.费别, 1, v_Currrow.收费细目id, v_Currrow.收入项目id, 0, v_Currrow.标准单价, 1,
                     v_Currrow.数量 * n_Dates, Round(v_Currrow.标准单价 * v_Currrow.数量 * n_Dates, n_Dec),
                     Round(v_Currrow.标准单价 * v_Currrow.数量 * n_Dates * n_Exsetax / 100, n_Dec), i.类别, i.计算单位,
                     v_Currrow.附加床位, j.收据费目, v_Currrow.经治医师, v_Currrow.责任护士, v_Currrow.操作员编号, v_Currrow.操作员姓名, d_发生时间,
                     d_登记时间, Decode(v_Currrow.险类, Null, 0, 1), v_Currrow.大类id,
                     Decode(v_Currrow.算法, 1,
                             Round(v_Currrow.标准单价 * v_Currrow.数量 * n_Dates * n_Exsetax / 100 * v_Currrow.统筹比额 / 100, n_Dec),
                             2, v_Currrow.统筹比额, 0), n_医疗小组id
              From (Select 类别, 计算单位
                     From 收费细目
                     Where ID = v_Currrow.收费细目id And (撤档时间 Is Null Or 撤档时间 > d_发生时间)) I,
                   (Select 收据费目
                     From 收入项目
                     Where ID = v_Currrow.收入项目id And (撤档时间 Is Null Or 撤档时间 > d_发生时间)) J;
          
            n_Billcount := n_Billcount + Sql%RowCount;
          End If;
        End If;
      End Loop;
    End Loop;
  Else
    For v_Currrow In v_Autocur(期间_In, n_Insure) Loop
    
      n_医疗小组id := Zl_医疗小组_Get(v_Currrow.科室id, v_Currrow.操作员姓名, v_Currrow.病人id, v_Currrow.主页id, d_发生时间);
    
      If d_Datefrom > v_Currrow.开始日期 Then
        d_Datefrom := v_Currrow.开始日期;
        n_Do       := 1;
        --将本次开始计算时间以后的已计算记录标志修改
        Update 住院费用记录
        Set 附加标志 = 5
        Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And 附加标志 <> 8 And Nvl(医嘱序号, 0) = 0 And
              发生时间 >= v_Currrow.开始日期;
      End If;
    
      If d_Dateto < v_Currrow.终止日期 Then
        d_Dateto := v_Currrow.终止日期;
      End If;
      n_收费细目id := v_Currrow.收费细目id;
      n_护理项目   := 0;
      --护理费计算标准:0-按最后一次护理计算;1-按价格最高的护理等级计算。
      If n_护理计算标准 = 1 Then
        --先确定是否护理项目,如果是,则需要重新进行计算
        Select Count(*) Into n_护理项目 From Table(l_护理id) Where Column_Value = n_收费细目id;
      End If;
    
      --提取当前收入项目的收费比率
      Begin
        Select 实收比率
        Into n_Exsetax
        From (Select 实收比率
               From 费别明细
               Where 费别 = v_Currrow.费别 And 收费细目id = v_Currrow.收费细目id And
                     (Abs(v_Currrow.标准单价 * v_Currrow.数量) Between 应收段首值 And 应收段尾值)
               Union All
               Select 实收比率
               From 费别明细
               Where 费别 = v_Currrow.费别 And 收入项目id = v_Currrow.收入项目id And
                     (Abs(v_Currrow.标准单价 * v_Currrow.数量) Between 应收段首值 And 应收段尾值) And Not Exists
                (Select 1 From 费别明细 Where 费别 = v_Currrow.费别 And 收费细目id = v_Currrow.收费细目id));
      Exception
        When Others Then
          n_Exsetax := 100.00;
      End;
    
      n_Exsetax := Nvl(n_Exsetax, 100);
      For n_Datecount In 0 .. (Trunc(v_Currrow.终止日期 + 0.5) - Trunc(v_Currrow.开始日期)) - 1 Loop
        d_发生时间   := Greatest(v_Currrow.开始日期, Trunc(v_Currrow.开始日期 + n_Datecount));
        n_Dates      := Least(Trunc(v_Currrow.开始日期 + n_Datecount + 1), v_Currrow.终止日期) -
                        Greatest(v_Currrow.开始日期, Trunc(v_Currrow.开始日期 + n_Datecount));
        n_护理已处理 := 0;
        If n_护理项目 = 1 Then
          --1.先检查当天是否存在护理变动,只有存在多个护理变动的,才会去处理(以主项目为准)
          n_从属项目 := 1;
          If l_护理等级.Count > 0 Then
            l_护理等级.Delete;
          End If;
          For v_护理 In (Select Distinct 护理等级id
                       From 病人变动记录
                       Where 开始原因 <> 10 And 病人id = 病人id_In And 主页id = 主页id_In And
                             (Trunc(开始时间) = Trunc(d_发生时间) Or Trunc(Nvl(终止时间, Sysdate)) = Trunc(d_发生时间))) Loop
            If Nvl(v_护理.护理等级id, 0) <> 0 Then
              l_护理等级.Extend;
              l_护理等级(l_护理等级.Count) := v_护理.护理等级id;
              If Nvl(v_护理.护理等级id, 0) = Nvl(v_Currrow.收费细目id, 0) Then
                n_从属项目 := 0;
              End If;
            End If;
          End Loop;
          If l_护理等级.Count > 1 Then
            --2. 存在两个以上变动,则取价位最高的
            n_Temp       := v_Currrow.收费细目id;
            n_价格       := Nvl(v_Currrow.标准单价, 0);
            n_收入项目id := v_Currrow.收入项目id;
            --本身是从属项目时,由于主项目计算时,已经计算了的,所以就不再计算
            If Nvl(n_从属项目, 0) = 1 Then
              n_护理已处理 := 1;
            End If;
            --因为可能存在多个收入项目,但收费细目相同的情况,因此,必须先检查该项目是否已经参与计算过的
            For I In 1 .. c_护理.Count Loop
              If c_护理(I).收费细目id = v_Currrow.收费细目id And c_护理(I).日期 = Trunc(d_发生时间) Then
                n_护理已处理 := 1;
                Exit;
              End If;
            End Loop;
            If Nvl(n_护理已处理, 0) = 0 Then
              c_护理.Extend;
              c_护理(c_护理.Count).收费细目id := v_Currrow.收费细目id;
              c_护理(c_护理.Count).日期 := Trunc(d_发生时间);
            End If;
            If Nvl(n_从属项目, 0) = 0 And Nvl(n_护理已处理, 0) = 0 Then
              --3.处理最高价位
              For v_价位 In (Select /*+ rule */
                            a.Column_Value As 收费细目id, p.现价, p.收入项目id
                           From Table(l_护理等级) A, 收费价目 P, 收费项目目录 C
                           Where a.Column_Value = p.收费细目id And a.Column_Value = c.Id And d_发生时间 Between p.执行日期 And
                                 Nvl(p.终止日期, Sysdate) And Nvl(c.计算方式, 0) <> 1 And p.价格等级 Is Null) Loop
                If Nvl(v_价位.现价, 0) > n_价格 Then
                  n_价格       := Nvl(v_价位.现价, 0);
                  n_Temp       := v_价位.收费细目id;
                  n_收入项目id := v_价位.收入项目id;
                End If;
              End Loop;
            
              If n_Temp <> v_Currrow.收费细目id And Nvl(n_护理已处理, 0) = 0 Then
              
                n_开单部门id := v_Currrow.科室id;
                n_病人病区id := v_Currrow.病区id;
              
                For c_变动记录 In (Select 病区id, 科室id
                               From 病人变动记录
                               Where 开始原因 <> 10 And 病人id = 病人id_In And 主页id = 主页id_In And 护理等级id + 0 = n_Temp And
                                     (Trunc(开始时间) = Trunc(d_发生时间) Or Trunc(Nvl(终止时间, Sysdate)) = Trunc(d_发生时间))
                               Order By 开始时间 Desc) Loop
                  n_开单部门id := c_变动记录.科室id;
                  n_病人病区id := c_变动记录.病区id;
                  Exit;
                End Loop;
              
                --4. 不等的话,需要重新处理相关费用
                For v_费用 In (Select n_Temp As 收费细目id, v_Currrow.数量 As 数量, n_价格 As 单价, n_收入项目id As 收入项目id
                             From Dual
                             Union All
                             Select 从项id As 收费细目id, a.从项数次 As 数量, p.现价 As 单价, p.收入项目id
                             From 收费从属项目 A, 收费价目 P, 收费项目目录 C
                             Where a.从项id = p.收费细目id And a.从项id = c.Id And Nvl(c.计算方式, 0) <> 1 And a.主项id = n_Temp And
                                   d_发生时间 Between p.执行日期 And Nvl(p.终止日期, Sysdate) And p.价格等级 Is Null) Loop
                  --确定比例
                  Begin
                    Select 实收比率
                    Into n_Exsetax_Temp
                    From (Select 实收比率
                           From 费别明细
                           Where 费别 = v_Currrow.费别 And 收费细目id = v_费用.收费细目id And
                                 (Abs(v_费用.单价 * v_费用.数量) Between 应收段首值 And 应收段尾值)
                           Union All
                           Select 实收比率
                           From 费别明细
                           Where 费别 = v_Currrow.费别 And 收入项目id = v_费用.收入项目id And
                                 (Abs(v_费用.单价 * v_费用.数量) Between 应收段首值 And 应收段尾值) And Not Exists
                            (Select 1 From 费别明细 Where 费别 = v_Currrow.费别 And 收费细目id = v_费用.收费细目id));
                  Exception
                    When Others Then
                      n_Exsetax_Temp := 100.00;
                  End;
                  n_Exsetax_Temp := Nvl(n_Exsetax_Temp, 100);
                  --如果已经计算，原记录计算完全正确，则直接修改将标志改正
                  Update 住院费用记录
                  Set 附加标志 = 0
                  Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And Nvl(加班标志, 0) = v_Currrow.附加床位 And
                        病人科室id = Nvl(n_开单部门id, 0) And 病人病区id = Nvl(n_病人病区id, 0) And Nvl(床号, 0) = Nvl(v_Currrow.床号, 0) And
                        收费细目id = v_费用.收费细目id And 收入项目id = v_费用.收入项目id And 发生时间 = d_发生时间 And 数次 = v_费用.数量 * n_Dates And
                        标准单价 = v_费用.单价 And 应收金额 = Round(v_费用.单价 * v_费用.数量 * n_Dates, n_Dec) And
                        实收金额 = Round(v_费用.单价 * v_费用.数量 * n_Dates * n_Exsetax / 100, n_Dec);
                
                  If Sql%RowCount = 0 Then
                    --如果未计算或计算错误，则增加正确的计算记录
                    Insert Into 住院费用记录
                      (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 医嘱序号, 门诊标志, 病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id,
                       姓名, 性别, 年龄, 标识号, 床号, 费别, 记帐费用, 收费细目id, 收入项目id, 附加标志, 标准单价, 付数, 数次, 应收金额, 实收金额, 收费类别, 计算单位, 加班标志,
                       收据费目, 开单人, 划价人, 操作员编号, 操作员姓名, 发生时间, 登记时间, 保险项目否, 保险大类id, 统筹金额, 医疗小组id)
                      Select 病人费用记录_Id.Nextval, 3, v_Billno, 1, Rownum + n_Billcount, Null, Null, 0, Null,
                             Decode(v_Currrow.主页id, Null, 1, 2), v_Currrow.病人id, v_Currrow.主页id, n_病人病区id, n_开单部门id,
                             n_开单部门id, n_病人病区id, v_Currrow.姓名, v_Currrow.性别, v_Currrow.年龄, v_Currrow.住院号, v_Currrow.床号,
                             v_Currrow.费别, 1, v_费用.收费细目id, v_费用.收入项目id, 0, v_费用.单价, 1, v_费用.数量 * n_Dates,
                             Round(v_费用.单价 * v_费用.数量 * n_Dates, n_Dec),
                             Round(v_费用.单价 * v_费用.数量 * n_Dates * n_Exsetax / 100, n_Dec), i.类别, i.计算单位, v_Currrow.附加床位,
                             j.收据费目, v_Currrow.经治医师, v_Currrow.责任护士, v_Currrow.操作员编号, v_Currrow.操作员姓名, d_发生时间, d_登记时间,
                             Decode(v_Currrow.险类, Null, 0, 1), v_Currrow.大类id,
                             Decode(v_Currrow.算法, 1,
                                     Round(v_费用.单价 * v_费用.数量 * n_Dates * n_Exsetax / 100 * v_Currrow.统筹比额 / 100, n_Dec), 2,
                                     v_Currrow.统筹比额, 0), n_医疗小组id
                      From (Select 类别, 计算单位
                             From 收费细目
                             Where ID = v_费用.收费细目id And (撤档时间 Is Null Or 撤档时间 > d_发生时间)) I,
                           (Select 收据费目
                             From 收入项目
                             Where ID = v_费用.收入项目id And (撤档时间 Is Null Or 撤档时间 > d_发生时间)) J;
                    n_Billcount := n_Billcount + Sql%RowCount;
                  End If;
                  n_护理已处理 := 1;
                End Loop;
              End If;
            End If;
          End If;
        End If;
      
        If Nvl(n_护理已处理, 0) = 0 Then
          --如果已经计算，原记录计算完全正确，则直接修改将标志改正
          Update 住院费用记录
          Set 附加标志 = 0
          Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And Nvl(加班标志, 0) = v_Currrow.附加床位 And
                病人科室id = v_Currrow.科室id And 病人病区id = Nvl(v_Currrow.病区id, 0) And Nvl(床号, 0) = Nvl(v_Currrow.床号, 0) And
                收费细目id = v_Currrow.收费细目id And 收入项目id = v_Currrow.收入项目id And 发生时间 = d_发生时间 And
                数次 = v_Currrow.数量 * n_Dates And 标准单价 = v_Currrow.标准单价 And
                应收金额 = Round(v_Currrow.标准单价 * v_Currrow.数量 * n_Dates, n_Dec) And
                实收金额 = Round(v_Currrow.标准单价 * v_Currrow.数量 * n_Dates * n_Exsetax / 100, n_Dec);
        
          If Sql%RowCount = 0 Then
            --如果未计算或计算错误，则增加正确的计算记录\
            Insert Into 住院费用记录
              (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 医嘱序号, 门诊标志, 病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 姓名, 性别,
               年龄, 标识号, 床号, 费别, 记帐费用, 收费细目id, 收入项目id, 附加标志, 标准单价, 付数, 数次, 应收金额, 实收金额, 收费类别, 计算单位, 加班标志, 收据费目, 开单人, 划价人,
               操作员编号, 操作员姓名, 发生时间, 登记时间, 保险项目否, 保险大类id, 统筹金额, 医疗小组id)
              Select 病人费用记录_Id.Nextval, 3, v_Billno, 1, Rownum + n_Billcount, Null, Null, 0, Null,
                     Decode(v_Currrow.主页id, Null, 1, 2), v_Currrow.病人id, v_Currrow.主页id, v_Currrow.病区id, v_Currrow.科室id,
                     v_Currrow.科室id, v_Currrow.病区id, v_Currrow.姓名, v_Currrow.性别, v_Currrow.年龄, v_Currrow.住院号,
                     v_Currrow.床号, v_Currrow.费别, 1, v_Currrow.收费细目id, v_Currrow.收入项目id, 0, v_Currrow.标准单价, 1,
                     v_Currrow.数量 * n_Dates, Round(v_Currrow.标准单价 * v_Currrow.数量 * n_Dates, n_Dec),
                     Round(v_Currrow.标准单价 * v_Currrow.数量 * n_Dates * n_Exsetax / 100, n_Dec), i.类别, i.计算单位,
                     v_Currrow.附加床位, j.收据费目, v_Currrow.经治医师, v_Currrow.责任护士, v_Currrow.操作员编号, v_Currrow.操作员姓名, d_发生时间,
                     d_登记时间, Decode(v_Currrow.险类, Null, 0, 1), v_Currrow.大类id,
                     Decode(v_Currrow.算法, 1,
                             Round(v_Currrow.标准单价 * v_Currrow.数量 * n_Dates * n_Exsetax / 100 * v_Currrow.统筹比额 / 100, n_Dec),
                             2, v_Currrow.统筹比额, 0), n_医疗小组id
              From (Select 类别, 计算单位
                     From 收费细目
                     Where ID = v_Currrow.收费细目id And (撤档时间 Is Null Or 撤档时间 > d_发生时间)) I,
                   (Select 收据费目
                     From 收入项目
                     Where ID = v_Currrow.收入项目id And (撤档时间 Is Null Or 撤档时间 > d_发生时间)) J;
          
            n_Billcount := n_Billcount + Sql%RowCount;
          End If;
        End If;
      End Loop;
    End Loop;
  End If;
  If n_Do = 0 Then
    --撤销出院后,如果修改出院时间为入院当天则不产生新费用,但以前的费用要冲销
    Begin
      Select Nvl(Trunc(b.上次计算时间), Trunc(b.终止时间))
      Into d_Datelast
      From 病人变动记录 A, 病人变动记录 B
      Where a.病人id = 病人id_In And a.主页id = 主页id_In And a.终止原因 = 1 And a.病人id = b.病人id And a.主页id = b.主页id And b.开始原因 = 1 And
            Trunc(b.开始时间) = Trunc(a.终止时间) And a.附加床位 = 0 And b.附加床位 = 0;
    Exception
      When Others Then
        Null;
    End;
    If d_Datelast Is Not Null Then
      d_Datefrom := d_Datelast;
      d_Dateto   := Sysdate;
      Update 住院费用记录
      Set 附加标志 = 5
      Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And 附加标志 <> 8 And Nvl(医嘱序号, 0) = 0 And
            发生时间 >= d_Datefrom;
    End If;
  End If;

  -----------------------------------------------------------------
  --作废以前计算的错误记录
  -----------------------------------------------------------------
  Insert Into 住院费用记录
    (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 医嘱序号, 门诊标志, 病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 姓名, 性别, 年龄, 标识号,
     床号, 费别, 记帐费用, 收费细目id, 收入项目id, 附加标志, 标准单价, 付数, 数次, 应收金额, 实收金额, 收费类别, 计算单位, 加班标志, 收据费目, 开单人, 划价人, 操作员编号, 操作员姓名, 发生时间,
     登记时间, 保险项目否, 保险大类id, 统筹金额, 医疗小组id)
    Select 病人费用记录_Id.Nextval, 记录性质, NO, 2, 序号, 从属父号, 价格父号, 多病人单, 医嘱序号, 门诊标志, 病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id,
           姓名, 性别, 年龄, 标识号, 床号, 费别, 记帐费用, 收费细目id, 收入项目id, 0, 标准单价, 付数, -数次, -应收金额, -实收金额, 收费类别, 计算单位, 加班标志, 收据费目, 开单人,
           划价人, 操作员编号, 操作员姓名, 发生时间, d_登记时间, 保险项目否, 保险大类id, -统筹金额, 医疗小组id
    From 住院费用记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And 附加标志 = 5 And 发生时间 >= d_Datefrom;

  -----------------------------------------------------------------
  --填写病人余额
  -----------------------------------------------------------------
  Select Sum(Decode(附加标志, 0, 1, -1) * 实收金额) As 实收金额
  Into n_Summoney
  From 住院费用记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And
        (NO = v_Billno Or 附加标志 = 5 And 发生时间 >= d_Datefrom);

  Update 病人余额
  Set 费用余额 = Nvl(费用余额, 0) + Nvl(n_Summoney, 0)
  Where 病人id = 病人id_In And 性质 = 1 And 类型 = 2
  Returning 费用余额 Into n_返回值;

  If Sql%RowCount = 0 Then
    Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (病人id_In, 1, 2, n_Summoney, 0);
    n_返回值 := n_Summoney;
  End If;

  If Nvl(n_返回值, 0) = 0 Then
    Delete From 病人余额 Where 性质 = 1 And 病人id = 病人id_In And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
  End If;

  -----------------------------------------------------------------
  --填写病人汇总费用
  -----------------------------------------------------------------
  n_Delete := 0;
  For v_Currrow In v_Sumcur(v_Billno, d_Datefrom) Loop
    Update 病人未结费用
    Set 金额 = Nvl(金额, 0) + Nvl(v_Currrow.实收金额, 0)
    Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0) And Nvl(病人病区id, 0) = Nvl(v_Currrow.病人病区id, 0) And
          Nvl(病人科室id, 0) = Nvl(v_Currrow.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(v_Currrow.开单部门id, 0) And
          Nvl(执行部门id, 0) = Nvl(v_Currrow.执行部门id, 0) And Nvl(收入项目id, 0) = Nvl(v_Currrow.收入项目id, 0) And 来源途径 + 0 = 2
    Returning 金额 Into n_返回值;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人未结费用
        (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
      Values
        (病人id_In, 主页id_In, v_Currrow.病人病区id, v_Currrow.病人科室id, v_Currrow.开单部门id, v_Currrow.执行部门id, v_Currrow.收入项目id, 2,
         v_Currrow.实收金额);
      n_返回值 := v_Currrow.实收金额;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      n_Delete := 1;
    End If;
  End Loop;

  If Nvl(n_Delete, 0) = 1 Then
    Delete From 病人未结费用 Where 病人id = 病人id_In And 金额 = 0;
  End If;

  -----------------------------------------------------------------
  --将所有修改的附加标志还原为正常标志
  -----------------------------------------------------------------
  Update 住院费用记录
  Set 附加标志 = 0, 记录状态 = 3
  Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And 附加标志 = 5 And 发生时间 >= d_Datefrom;

  -----------------------------------------------------------------
  --修改计算时间标志
  -----------------------------------------------------------------
  Update 病人变动记录
  Set 上次计算时间 = Least(d_Dateto, Nvl(终止时间, Greatest(开始时间, Sysdate)))
  Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(终止时间, Sysdate) > d_Datefrom;
  Commit; --单个病人提交
End Zl1_Autocptone;
/

--99878:冉俊明,2017-05-24,同一收费项目多个价格管理
Create Or Replace Function Zl_Get_Pricegrade
(
  站点_In         In 收费价格等级应用.站点%Type,
  病人id_In       In 病人信息.病人id%Type := Null,
  主页id_In       In 病案主页.主页id%Type := Null,
  医疗付款方式_In In 收费价格等级应用.医疗付款方式%Type := Null
) Return Varchar2
-----------------------------------------------------------------------------------------------------------------------------------------
  --功能：根据医疗付款方式或站点，获取对应的价格等级
  --入参：
  --       站点_in-登陆的站点，必须传入，传入NULL时，药品，卫材的价格等级为返回空,普通收费项目，根据病人类型再确定等级。
  --       病人ID_in和主页ID：用于提取医疗付款方式.
  --       医疗付款方式_In:如果传入非空，则以传的医疗付款方式_In方式来提取价格等级;否则以病人ID_In或主页ID来获取对应的病人的医疗付款方式。
  --返回：药品，卫生材料或普通收费项目所以应的价格等级
  --      格式:普通价格等级|药品价格等级|卫生材料价格等级
  --说明:
  --    1.针对药品，卫材的价格等级提取，只根据院区(站点)提取价格等级
  --    2.针对普通材料的价格提取有优先级别：病人类型-->院区(站点)
  --      病人类型（即医疗付款方式的获取规则):
  --        1)如果入参【医疗付款方式_IN】为非空，则以该医疗付款方式为准
  --        2)如果入参【医疗付款方式_IN】为空，则根据病人ID和主页ID来获取
  --           a)主页ID 为空或0时，直接从病人信息中读取
  --           b)主页ID 为非空和非零时，直接从病案主页中读取。
  -----------------------------------------------------------------------------------------------------------------------------------------
 Is
  v_价格等级 Varchar2(4000);
  v_药品等级 收费价格等级.名称%Type;
  v_卫材等级 收费价格等级.名称%Type;
  v_普通等级 收费价格等级.名称%Type;
  v_Temp     收费价格等级.名称%Type;
  n_Count    Number(18);
  v_Err_Item Varchar2(100);
  Err_Item Exception;
  v_医疗付款方式 收费价格等级应用.医疗付款方式%Type;
Begin

  If 站点_In Is Not Null Then
    Select Max(Decode(b.是否适用药品, 1, 价格等级, Null)) As 药品等级, Max(Decode(b.是否适用卫材, 1, 价格等级, Null)) As 卫材等级,
           Max(Decode(b.是否适用普通项目, 1, 价格等级, Null)) As 普通等级
    Into v_药品等级, v_卫材等级, v_普通等级
    From 收费价格等级应用 A, 收费价格等级 B
    Where a.价格等级 = b.名称 And a.性质 = 0 And a.站点 = 站点_In And Nvl(b.撤档时间, Sysdate + 1) > Sysdate;
  End If;
  v_医疗付款方式 := 医疗付款方式_In;

  Select Max(1) Into n_Count From 收费价格等级应用 Where 性质 = 1;
  If Nvl(n_Count, 0) > 0 Then
    If v_医疗付款方式 Is Null And Nvl(病人id_In, 0) <> 0 Then
      --取病人信息的医疗付款方式
      If Nvl(主页id_In, 0) = 0 Then
        Select Max(医疗付款方式) Into v_医疗付款方式 From 病人信息 Where 病人id = 病人id_In;
      Else
        Select Max(Nvl(a.医疗付款方式, b.医疗付款方式))
        Into v_医疗付款方式
        From 病案主页 A, 病人信息 B
        Where a.病人id = b.病人id And a.病人id = 病人id_In And a.主页id = 主页id_In;
      End If;
    End If;
  
    If Not v_医疗付款方式 Is Null Then
      Select Max(价格等级)
      Into v_Temp
      From 收费价格等级应用 A, 收费价格等级 B
      Where a.价格等级 = b.名称 And a.性质 = 1 And a.医疗付款方式 = v_医疗付款方式 And Nvl(b.是否适用普通项目, 0) = 1 And
            Nvl(b.撤档时间, Sysdate + 1) > Sysdate;
    
      If Not v_Temp Is Null Then
        v_普通等级 := v_Temp;
      End If;
    End If;
  End If;
  v_价格等级 := Nvl(v_普通等级, '') || '|' || Nvl(v_药品等级, '') || '|' || Nvl(v_卫材等级, '');
  Return v_价格等级;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Item || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Get_Pricegrade;
/

--99878:冉俊明,2017-05-24,同一收费项目多个价格管理
Create Or Replace Function Zl_Get_Retailprice
(
  收费细目id_In In 收费项目目录.Id%Type,
  价格等级_In   In 收费价格等级.名称%Type,
  库房id_In     In 部门表.Id%Type := Null,
  数量_In       In Number := 0
) Return Varchar2
-----------------------------------------------------------------------------------------------------------------------------------------
  --功能：根据价格等级获取指定收费项目的零售价的相关信息
  --入参：
  --     数量_In:针对药品和卫生材料有效，表示当前输入的数量，主要是实价药品和卫材的售价计算.
  --返回：零售价格
  --      a.药品和卫生材料:零售价|未分解数
  --      b.针对针对普通收费项目:零售价(实价为缺省价格)|0
  -----------------------------------------------------------------------------------------------------------------------------------------
 Is
  n_Count    Number(18);
  v_Err_Item Varchar2(100);
  Err_Item Exception;
  n_收费类别    收费项目目录.类别%Type;
  n_变价        收费项目目录.是否变价%Type;
  n_跟踪在用    材料特性.跟踪在用%Type;
  v_药品信息    Varchar2(4000);
  n_Retailprice 收费价目.现价%Type;
  n_剩余数      药品库存.实际数量%Type;
  v_Temp        Varchar2(4000);
Begin

  Begin
    Select a.类别, a.是否变价, Nvl(b.跟踪在用, 0)
    Into n_收费类别, n_变价, n_跟踪在用
    From 收费项目目录 A, 材料特性 B
    Where a.Id = 收费细目id_In And a.Id = b.材料id(+);
  Exception
    When Others Then
      n_Count := -1;
  End;
  If Nvl(n_Count, 0) = -1 Then
    v_Err_Item := '未找到指定的收费项目,ID=' || 收费细目id_In;
    Raise Err_Item;
    Return 0;
  End If;

  --1.针对药品和卫生材料
  If Instr(',5,6,7,', ',' || n_收费类别 || ',') > 0 Or (n_收费类别 = '4' And Nvl(n_跟踪在用, 0) = 1) Then
    --Zl_Fun_Getprice:根据传过来的参数返回出库药品、卫材的售价|成本价|剩余数量，中间用“|”隔断；剩余数量等于0表示数量足够，大于0则表示数量不够
    v_药品信息 := Zl_Fun_Getprice(收费细目id_In, 库房id_In, 数量_In);
    For c_价格 In (Select Rownum As 序号, Column_Value As 值 From Table(f_Num2list(v_药品信息, '|'))) Loop
      If c_价格.序号 = 1 Then
        n_Retailprice := Nvl(c_价格.值, 0);
      End If;
      If c_价格.序号 = 3 Then
        n_剩余数 := Nvl(c_价格.值, 0);
      End If;
    End Loop;
    v_Temp := Nvl(n_Retailprice, 0) || '|' || Nvl(n_剩余数, 0);
    Return v_Temp;
  End If;

  --2.针对普通材料
  For c_价格 In (Select a.价格等级, Sum(a.现价) As 现价, Max(缺省价格) As 缺省价格
               From 收费价目 A
               Where a.收费细目id = 收费细目id_In And Sysdate Between a.执行日期 And Nvl(a.终止日期, Sysdate + 1) And
                     (a.价格等级 Is Null Or a.价格等级 = 价格等级_In)
               Group By a.价格等级
               Order By 价格等级) Loop
    If Nvl(n_变价, 0) = 0 Then
      n_Retailprice := Nvl(c_价格.现价, 0);
    Else
      n_Retailprice := Nvl(c_价格.缺省价格, 0);
    End If;
    Exit;
  End Loop;
  v_Temp := Nvl(n_Retailprice, 0) || '|0';
  Return v_Temp;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Item || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Get_Retailprice;
/

--100956:刘尔旋,2017-5-23,收费价格等级支付宝相关调整
Create Or Replace Procedure Zl_三方机构挂号_Insert
(
  操作方式_In      Integer,
  病人id_In        门诊费用记录.病人id%Type,
  号码_In          挂号安排.号码%Type,
  号序_In          挂号序号状态.序号%Type,
  单据号_In        门诊费用记录.No%Type,
  票据号_In        门诊费用记录.实际票号%Type,
  结算方式_In      Varchar2,
  摘要_In          门诊费用记录.摘要%Type, --预约挂号摘要信息
  发生时间_In      门诊费用记录.发生时间%Type,
  登记时间_In      门诊费用记录.登记时间%Type,
  合作单位_In      挂号合作单位.名称%Type,
  挂号金额合计_In  门诊费用记录.实收金额%Type,
  领用id_In        票据使用明细.领用id%Type,
  收费票据_In      Number := 0, --挂号是否使用收费票据
  交易流水号_In    病人预交记录.交易流水号%Type,
  交易说明_In      病人预交记录.交易说明%Type,
  预约方式_In      预约方式.名称%Type := Null,
  预交id_In        病人预交记录.Id%Type := Null,
  卡类别id_In      病人预交记录.卡类别id%Type := Null,
  加入序号状态_In  Number := 0,
  是否自助设备_In  Number := 0,
  结帐id_In        门诊费用记录.结帐id%Type := Null,
  锁定类型_In      Number := 0,
  保险结算_In      Varchar2 := Null,
  冲预交_In        Number := Null,
  支付卡号_In      病人预交记录.卡号%Type := Null,
  退号重用_In      Number := 1,
  费别_In          门诊费用记录.费别%Type := Null,
  冲预交病人ids_In Varchar2 := Null,
  机器名_In        挂号序号状态.机器名%Type := Null,
  更新年龄_In      Number := 0,
  购买病历_In      Number := 0,
  出诊记录id_In    临床出诊记录.Id%Type := Null,
  记帐费用_In      Number := 0
) As
  --功能：三方机构进行挂号(包含预约;预约挂号不扣款;预约挂号扣款)
  --入参:操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
  --      结算方式_IN:支持多种结算方式,多种结算方式时，传入格式如下:结算方式名称1,金额,结算号码,三方卡标志|结算方式名称2,金额,结算号码,三方卡标志|...
  --      加入序号状态_In:1-表示强制加入挂号序号状态表中;否则根据启用序号或启用时段时才加入.
  --      是否自助设备_In:1-表示是医院的自助设备进行此函数的调用,自助设备调用此函数 允许加号,否则不允许
  --      锁定类型_In :0-产生正常数据 1-表示对单据进行锁定,产生未生效的单据信息;2-对锁定的记录进行解锁-生成正常数据:未生效的单据在银行扣款完成后进行解锁
  --      保险结算_IN:格式="结算方式|结算金额||....."
  --      冲预交病人ids_In:多个用逗分分离,冲预交时有效(冲预交类别与业务操作保持一致),主要是使用家属的预交款
  Err_Item    Exception;
  Err_Special Exception;
  v_Err_Msg  Varchar2(255);
  n_打印id   票据打印内容.Id%Type;
  n_返回值   病人预交记录.金额%Type;
  v_排队号码 Varchar2(20);
  v_队列名称 排队叫号队列.队列名称%Type;
  n_预交id   病人预交记录.Id%Type;
  n_挂号id   病人挂号记录.Id%Type;
  v_结算内容 Varchar2(3000);
  v_当前结算 Varchar2(150);

  v_结算方式       病人预交记录.结算方式%Type;
  n_结算金额       病人预交记录.冲预交%Type;
  n_结算合计       Number(16, 5);
  n_预交金额       病人预交记录.冲预交%Type;
  n_组id           财务缴款分组.Id%Type;
  d_排队时间       Date;
  n_锁定           Number;
  n_同科限约一个号 Number(18);
  n_病人预约科室数 Number(18);
  n_已约科室       Number(18);

  n_合作单位限制       Number(18);
  n_是否开放           Number(1);
  n_Count              Number(18);
  n_行号               Number(18);
  n_序号               病人挂号记录.号序%Type;
  n_费用id             门诊费用记录.Id%Type;
  n_价格父号           Number(18);
  n_原项目id           收费项目目录.Id%Type;
  n_原收入项目id       收费项目目录.Id%Type;
  v_诊室               病人挂号记录.诊室%Type;
  n_安排id             挂号安排.Id%Type;
  n_实收金额合计       门诊费用记录.实收金额%Type;
  n_开单部门id         门诊费用记录.开单部门id%Type;
  n_实收金额           门诊费用记录.实收金额%Type;
  n_应收金额           门诊费用记录.实收金额%Type;
  n_结帐id             病人结帐记录.Id%Type;
  v_Temp               Varchar2(500);
  n_预约时段序号       Number;
  n_预约总数           Number;
  n_Exists             Number;
  n_分时点显示         Number;
  d_时段开始时间       Date;
  v_冲预交病人ids      Varchar2(4000);
  v_收费项目ids        Varchar2(300);
  n_预约数量           合作单位挂号汇总.已约数%Type;
  n_号序               病人挂号记录.号序%Type;
  d_登记时间           Date;
  v_操作员编号         人员表.编号%Type;
  v_操作员姓名         人员表.姓名%Type;
  n_急诊               病人挂号记录.急诊%Type;
  n_预约               Integer;
  v_星期               挂号安排时段.星期%Type;
  n_启用分时段         Integer;
  n_已挂数             病人挂号汇总.已挂数%Type;
  n_已约数             病人挂号汇总.已约数%Type;
  n_其中已接收         病人挂号汇总.已约数%Type;
  n_预约生成队列       Number;
  d_Date               Date;
  n_挂号序号           Number;
  v_排队标记           排队叫号队列.排队标记%Type;
  v_排队序号           排队叫号队列.排队序号%Type;
  v_机器名             挂号序号状态.机器名%Type;
  v_序号操作员         挂号序号状态.操作员姓名%Type;
  v_序号机器名         挂号序号状态.机器名%Type;
  n_序号锁定           Number := 0;
  n_病历费id           收费特定项目.收费细目id%Type;
  v_付款方式           病人挂号记录.医疗付款方式%Type;
  v_费别               门诊费用记录.费别%Type;
  n_屏蔽费别           Number(3) := 0;
  n_Tmp安排id          挂号安排.Id%Type;
  n_计划id             挂号安排计划.Id%Type;
  v_年龄               病人信息.年龄%Type;
  n_合作单位限数量模式 Number;
  n_出诊记录id         临床出诊记录.Id%Type;
  n_挂号模式           Number(3);
  n_同科限号数         Number;
  n_同科限约数         Number;
  n_病人挂号科室数     Number;
  d_启用时间           Date;
  v_Para               Varchar2(2000);
  n_专家号挂号限制     Number;
  n_专家号预约限制     Number;
  v_站点               部门表.站点%Type;
  v_药品等级           Varchar2(100);
  v_卫材等级           Varchar2(100);
  v_普通等级           Varchar2(100);
  v_Pricegrade         Varchar2(500);
  v_时间段             时间段.时间段%Type;
  d_检查开始时间       时间段.开始时间%Type;
  d_检查结束时间       时间段.终止时间%Type;

  Cursor c_Pati(n_病人id 病人信息.病人id%Type) Is
    Select a.病人id, a.姓名, a.性别, a.年龄, a.住院号, a.门诊号, a.费别, a.险类, c.编码 As 付款方式
    From 病人信息 A, 医疗付款方式 C
    Where a.病人id = n_病人id And a.医疗付款方式 = c.名称(+);

  r_Pati c_Pati%RowType;

  --该游标用于收费冲预交的可用预交列表
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit
  (
    v_病人id        病人信息.病人id%Type,
    v_冲预交病人ids Varchar2
  ) Is
    Select 病人id, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额, Min(记录状态) As 记录状态, Nvl(Max(结帐id), 0) As 结帐id,
           Max(Decode(记录性质, 1, ID, 0) * Decode(记录状态, 2, 0, 1)) As 原预交id
    From 病人预交记录
    Where 记录性质 In (1, 11) And 病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And Nvl(预交类别, 2) = 1
     Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
    Group By NO, 病人id
    Order By Decode(病人id, Nvl(v_病人id, 0), 0, 1), 结帐id, NO;

  Cursor c_安排
  (
    v_号码        挂号安排.号码%Type,
    d_发生时间_In Date
  ) Is
    Select *
    From (With 安排时间段 As (Select 时间段
                         From (Select 时间段,
                                       To_Date(Decode(Sign(开始时间 - 终止时间), 1, '3000-01-09 ' || To_Char(开始时间, 'HH24:MI:SS'),
                                                       '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS')), 'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                       To_Date(Decode(Sign(开始时间 - 终止时间), 1, '3000-01-11 ' || To_Char(终止时间, 'HH24:MI:SS'),
                                                       '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS')), 'yyyy-mm-dd hh24:mi:ss') As 终止时间,
                                       To_Date('3000-01-10 ' || To_Char(d_发生时间_In, 'HH24:MI:SS'), 'yyyy-mm-dd hh24:mi:ss') As 当前时间,
                                       To_Date('3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS'), 'yyyy-mm-dd hh24:mi:ss') As 开始时间1,
                                       To_Date('3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS'), 'yyyy-mm-dd hh24:mi:ss') As 终止时间1
                                From 时间段)
                         Where 当前时间 Between 开始时间 And 终止时间1 Or 当前时间 Between 开始时间1 And 终止时间)
           Select Distinct p.Id, p.号类, p.号码, p.科室id, b.编码 As 科室编码, b.名称 As 科室名称, p.项目id, c.编码 As 项目编码, c.名称 As 项目名称,
                           p.医生id, d.编号 As 医生编号, p.医生姓名, p.限号数, p.限约数, p.周日 As 日, p.周一 As 一, p.周二 As 二, p.周三 As 三,
                           p.周四 As 四, p.周五 As 五, p.周六 As 六, p.序号控制, p.计划id
           From (Select p.Id, p.号码, p.号类, p.科室id, p.项目id, p.医生id, p.医生姓名, b.限号数, b.限约数, Nvl(p.病案必须, 0) As 病案必须, p.周日, p.周一,
                         p.周二, p.周三, p.周四, p.周五, p.周六, p.分诊方式, p.序号控制,
                         Decode(To_Char(d_发生时间_In, 'D'), '1', p.周日, '2', p.周一, '3', p.周二, '4', p.周三, '5', p.周四, '6', p.周五,
                                 '7', p.周六, Null) As 排班, Null As 计划id
                  From 挂号安排 P, 挂号安排限制 B
                  Where p.停用日期 Is Null And p.Id = b.安排id(+) And
                        b.限制项目(+) = Decode(To_Char(d_发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四',
                                           '6', '周五', '7', '周六', Null) And
                        d_发生时间_In Between Nvl(p.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                        Nvl(p.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Not Exists
                   (Select 1
                         From 挂号安排计划
                         Where 安排id = p.Id And (d_发生时间_In Between 生效时间 And 失效时间) And 审核时间 Is Not Null) And Not Exists
                   (Select 1
                         From 挂号安排停用状态
                         Where 安排id = p.Id And d_发生时间_In Between 开始停止时间 And 结束停止时间) And p.号码 = v_号码
                  Union All
                  Select c.Id, c.号码, c.号类, c.科室id, p.项目id, p.医生id, p.医生姓名, b.限号数, b.限约数, Nvl(c.病案必须, 0) As 病案必须, p.周日, p.周一,
                         p.周二, p.周三, p.周四, p.周五, p.周六, p.分诊方式, p.序号控制,
                         Decode(To_Char(d_发生时间_In, 'D'), '1', p.周日, '2', p.周一, '3', p.周二, '4', p.周三, '5', p.周四, '6', p.周五,
                                 '7', p.周六, Null) As 排班, p.Id As 计划id
                  From 挂号安排计划 P, 挂号安排 C, 挂号计划限制 B,
                       (Select Max(a.生效时间) As 生效, 安排id
                         From 挂号安排计划 A, 挂号安排 B
                         Where a.安排id = b.Id And a.审核时间 Is Not Null And
                               发生时间_In Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                               Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) And b.号码 = 号码_In
                         Group By 安排id) E
                  Where p.安排id = c.Id And p.Id = b.计划id(+) And p.生效时间 = e.生效 And p.安排id = e.安排id And
                        Nvl(p.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) = Nvl(e.生效, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                        b.限制项目(+) = Decode(To_Char(d_发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四',
                                           '6', '周五', '7', '周六', Null) And (d_发生时间_In Between p.生效时间 And p.失效时间) And
                        p.审核时间 Is Not Null And Not Exists
                   (Select 1
                         From 挂号安排停用状态
                         Where 安排id = c.Id And d_发生时间_In Between 开始停止时间 And 结束停止时间) And p.号码 = v_号码) P, 部门表 B, 收费项目目录 C,
                人员表 D
           Where p.科室id = b.Id And p.医生id = d.Id(+) And p.项目id = c.Id And
                 (c.撤档时间 Is Null Or c.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD')) And
                 (Nvl(p.医生id, 0) = 0 Or Exists
                  (Select 1
                   From 人员表 Q
                   Where p.医生id = q.Id And (q.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or q.撤档时间 Is Null))) And Exists
            (Select 1 From 安排时间段 Where 时间段 = p.排班))
           Order By 号码;


  r_安排 c_安排%RowType;

  Function Zl_诊室(号码_In 挂号安排.号码%Type) Return Varchar2 As
    n_分诊方式 挂号安排.分诊方式%Type;
    n_安排id   挂号安排.Id%Type;
    v_诊室     病人挂号记录.诊室%Type;
    v_Rowid    Varchar2(500);
    n_Next     Integer;
    n_First    Integer;
  Begin
  
    If 锁定类型_In = 2 Then
      --对单据进行解锁,首先检查是否存在锁定
      Select Count(Rowid) Into n_锁定 From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
      If n_锁定 = 0 Then
        v_Err_Msg := '单据号为(' || 单据号_In || ')的单据,不存在或者已经被解锁!';
        Raise Err_Item;
      End If;
      Select Max(号序) Into n_号序 From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
    End If;
  
    Begin
      Select ID, Nvl(分诊方式, 0) Into n_安排id, n_分诊方式 From 挂号安排 Where 号码 = 号码_In;
    Exception
      When Others Then
        n_安排id := -1;
    End;
  
    If n_安排id = -1 Then
      v_Err_Msg := '号码(' || 号码_In || ')未找到!';
      Raise Err_Item;
    End If;
    --0-不分诊、1-指定诊室、2-动态分诊、3-平均分诊,对应门诊诊室设置
    v_诊室 := Null;
    If n_分诊方式 = 1 Then
      --1-指定诊室
      Begin
        Select 门诊诊室 Into v_诊室 From 挂号安排诊室 Where 号表id = n_安排id;
      Exception
        When Others Then
          v_诊室 := Null;
      End;
    End If;
    If n_分诊方式 = 2 Then
      --2-动态分诊:该个号别当天挂号未诊数最少的诊室
      For c_诊室 In (Select 门诊诊室, Sum(Num) As Num
                   From (Select 门诊诊室, 0 As Num
                          From 挂号安排诊室
                          Where 号表id = n_安排id
                          Union All
                          Select 诊室, Count(诊室) As Num
                          From 病人挂号记录
                          Where Nvl(执行状态, 0) = 0 And 发生时间 Between Trunc(Sysdate) And Sysdate And 号别 = 号码_In And
                                诊室 In (Select 门诊诊室 From 挂号安排诊室 Where 号表id = n_安排id)
                          Group By 诊室)
                   Group By 门诊诊室
                   Order By Num) Loop
        v_诊室 := c_诊室.门诊诊室;
        Exit;
      End Loop;
    End If;
    If n_分诊方式 = 3 Then
    
      --平均分诊：当前分配=1表示下次应取的当前诊室
      n_Next  := 0;
      n_First := 1;
      For c_诊室 In (Select Rowid As Rid, 号表id, 门诊诊室, 当前分配 From 挂号安排诊室 Where 号表id = n_安排id) Loop
        If n_First = 1 Then
          v_Rowid := c_诊室.Rid;
        End If;
        If n_Next = 1 Then
          v_诊室 := c_诊室.门诊诊室;
          Update 挂号安排诊室 Set 当前分配 = 1 Where Rowid = c_诊室.Rid;
          Exit;
        End If;
        If Nvl(c_诊室.当前分配, 0) = 1 Then
          Update 挂号安排诊室 Set 当前分配 = 0 Where Rowid = c_诊室.Rid;
          n_Next := 1;
        End If;
      End Loop;
      If v_诊室 Is Null Then
        Update 挂号安排诊室 Set 当前分配 = 1 Where Rowid = v_Rowid Returning 门诊诊室 Into v_诊室;
      End If;
    End If;
  
    Return v_诊室;
  End;

  Function Zl_操作员
  (
    Type_In     Integer,
    Splitstr_In Varchar2
  ) Return Varchar2 As
    n_Step Number(18);
    v_Sub  Varchar2(1000);
    --Type_In:0-获取缺省部门ID;1-获取操作员编号;2-获取操作员姓名
    -- SplitStr:格式为:部门ID,部门名称;人员ID,人员编号,人员姓名(用Zl_Identity获取的)
  Begin
    If Type_In = 0 Then
      --缺省部门
      n_Step := Instr(Splitstr_In, ',');
      v_Sub  := Substr(Splitstr_In, 1, n_Step - 1);
      Return v_Sub;
    End If;
    If Type_In = 1 Then
      --操作员编码
      n_Step := Instr(Splitstr_In, ';');
      v_Sub  := Substr(Splitstr_In, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, 1, n_Step - 1);
      Return v_Sub;
    End If;
    If Type_In = 2 Then
      --操作员姓名
      n_Step := Instr(Splitstr_In, ';');
      v_Sub  := Substr(Splitstr_In, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      Return v_Sub;
    End If;
  End;

  Procedure Zl_三方机构挂号_出诊_Insert
  (
    记录id_In        临床出诊记录.Id%Type,
    操作方式_In      Integer,
    病人id_In        门诊费用记录.病人id%Type,
    号码_In          挂号安排.号码%Type,
    号序_In          挂号序号状态.序号%Type,
    单据号_In        门诊费用记录.No%Type,
    票据号_In        门诊费用记录.实际票号%Type,
    结算方式_In      Varchar2,
    摘要_In          门诊费用记录.摘要%Type, --预约挂号摘要信息
    发生时间_In      门诊费用记录.发生时间%Type,
    登记时间_In      门诊费用记录.登记时间%Type,
    合作单位_In      挂号合作单位.名称%Type,
    挂号金额合计_In  门诊费用记录.实收金额%Type,
    领用id_In        票据使用明细.领用id%Type,
    收费票据_In      Number := 0, --挂号是否使用收费票据
    交易流水号_In    病人预交记录.交易流水号%Type,
    交易说明_In      病人预交记录.交易说明%Type,
    预约方式_In      预约方式.名称%Type := Null,
    预交id_In        病人预交记录.Id%Type := Null,
    卡类别id_In      病人预交记录.卡类别id%Type := Null,
    加入序号状态_In  Number := 0,
    是否自助设备_In  Number := 0,
    结帐id_In        门诊费用记录.结帐id%Type := Null,
    锁定类型_In      Number := 0,
    保险结算_In      Varchar2 := Null,
    冲预交_In        Number := Null,
    支付卡号_In      病人预交记录.卡号%Type := Null,
    退号重用_In      Number := 1,
    费别_In          门诊费用记录.费别%Type := Null,
    冲预交病人ids_In Varchar2 := Null,
    机器名_In        挂号序号状态.机器名%Type := Null,
    更新年龄_In      Number := 0,
    购买病历_In      Number := 0,
    记帐费用_In      Number := 0
  ) As
    --功能：三方机构进行挂号(包含预约;预约挂号不扣款;预约挂号扣款),出诊表排班模式下使用
    --入参: 操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
    --      加入序号状态_In:1-表示强制加入挂号序号状态表中;否则根据启用序号或启用时段时才加入.
    --      是否自助设备_In:1-表示是医院的自助设备进行此函数的调用,自助设备调用此函数 允许加号,否则不允许
    --      锁定类型_In :0-产生正常数据 1-表示对单据进行锁定,产生未生效的单据信息;2-对锁定的记录进行解锁-生成正常数据:未生效的单据在银行扣款完成后进行解锁
    --      保险结算_IN:格式="结算方式|结算金额||....."
    --      冲预交病人ids_In:多个用逗分分离,冲预交时有效(冲预交类别与业务操作保持一致),主要是使用家属的预交款
    Err_Item    Exception;
    Err_Special Exception;
    v_Err_Msg  Varchar2(255);
    n_打印id   票据打印内容.Id%Type;
    n_返回值   病人预交记录.金额%Type;
    v_排队号码 Varchar2(20);
    v_队列名称 排队叫号队列.队列名称%Type;
    n_预交id   病人预交记录.Id%Type;
    n_挂号id   病人挂号记录.Id%Type;
    v_结算内容 Varchar2(3000);
    v_当前结算 Varchar2(150);
  
    v_结算方式       病人预交记录.结算方式%Type;
    n_结算金额       病人预交记录.冲预交%Type;
    n_结算合计       Number(16, 5);
    n_预交金额       病人预交记录.冲预交%Type;
    n_组id           财务缴款分组.Id%Type;
    d_排队时间       Date;
    n_锁定           Number;
    n_同科限约一个号 Number(18);
    n_病人预约科室数 Number(18);
    n_已约科室       Number(18);
  
    n_合作单位限制       Number(18);
    n_是否开放           Number(1);
    n_Count              Number(18);
    n_行号               Number(18);
    n_序号               病人挂号记录.号序%Type;
    n_费用id             门诊费用记录.Id%Type;
    n_价格父号           Number(18);
    n_原项目id           收费项目目录.Id%Type;
    n_原收入项目id       收费项目目录.Id%Type;
    v_诊室               病人挂号记录.诊室%Type;
    n_安排id             挂号安排.Id%Type;
    n_实收金额合计       门诊费用记录.实收金额%Type;
    n_开单部门id         门诊费用记录.开单部门id%Type;
    n_实收金额           门诊费用记录.实收金额%Type;
    n_应收金额           门诊费用记录.实收金额%Type;
    n_急诊               病人挂号记录.急诊%Type;
    n_结帐id             病人结帐记录.Id%Type;
    v_Temp               Varchar2(500);
    v_结算方式记录       Varchar2(1000);
    n_预约时段序号       Number;
    n_序号控制           临床出诊记录.是否序号控制%Type;
    n_限约数             临床出诊记录.限约数%Type;
    n_项目id             临床出诊记录.项目id%Type;
    n_科室id             临床出诊记录.科室id%Type;
    d_终止时间           临床出诊记录.终止时间%Type;
    v_医生姓名           临床出诊记录.医生姓名%Type;
    n_医生id             临床出诊记录.医生id%Type;
    n_预约顺序号         临床出诊序号控制.预约顺序号%Type;
    n_预约总数           Number;
    d_时段开始时间       Date;
    d_时段终止时间       Date;
    v_收费项目ids        Varchar2(300);
    n_三方卡标志         Number;
    n_预约数量           合作单位挂号汇总.已约数%Type;
    n_号序               病人挂号记录.号序%Type;
    d_登记时间           Date;
    n_单笔金额           病人预交记录.冲预交%Type;
    v_结算号码           病人预交记录.结算号码%Type;
    v_操作员编号         人员表.编号%Type;
    v_操作员姓名         人员表.姓名%Type;
    n_预约               Integer;
    n_分时点显示         Number;
    v_现金               病人预交记录.结算方式%Type;
    v_星期               挂号安排时段.星期%Type;
    n_启用分时段         Integer;
    n_已挂数             病人挂号汇总.已挂数%Type;
    n_已约数             病人挂号汇总.已约数%Type;
    n_其中已接收         病人挂号汇总.已约数%Type;
    n_预约生成队列       Number;
    n_限号数             临床出诊记录.限号数%Type;
    d_Date               Date;
    n_挂号序号           Number;
    v_排队标记           排队叫号队列.排队标记%Type;
    v_排队序号           排队叫号队列.排队序号%Type;
    v_机器名             挂号序号状态.机器名%Type;
    v_序号操作员         挂号序号状态.操作员姓名%Type;
    v_序号机器名         挂号序号状态.机器名%Type;
    n_序号锁定           Number := 0;
    n_病历费id           收费特定项目.收费细目id%Type;
    v_付款方式           病人挂号记录.医疗付款方式%Type;
    v_费别               门诊费用记录.费别%Type;
    n_屏蔽费别           Number(3) := 0;
    v_年龄               病人信息.年龄%Type;
    n_合作单位限数量模式 Number;
    n_同科限号数         Number;
    n_同科限约数         Number;
    n_病人挂号科室数     Number;
    n_Exists             Number(5);
    v_冲预交病人ids      Varchar2(4000);
    n_替诊医生id         临床出诊记录.替诊医生id%Type;
    v_替诊医生姓名       临床出诊记录.替诊医生姓名%Type;
    d_替诊开始时间       临床出诊记录.替诊开始时间%Type;
    d_替诊终止时间       临床出诊记录.替诊终止时间%Type;
    n_专家号挂号限制     Number;
    n_专家号预约限制     Number;
    v_站点               部门表.站点%Type;
    v_药品等级           Varchar2(100);
    v_卫材等级           Varchar2(100);
    v_普通等级           Varchar2(100);
    v_Pricegrade         Varchar2(500);
  
    Cursor c_Pati(n_病人id 病人信息.病人id%Type) Is
      Select a.病人id, a.姓名, a.性别, a.年龄, a.住院号, a.门诊号, a.费别, a.险类, c.编码 As 付款方式
      From 病人信息 A, 医疗付款方式 C
      Where a.病人id = n_病人id And a.医疗付款方式 = c.名称(+);
  
    r_Pati c_Pati%RowType;
  
    --该游标用于收费冲预交的可用预交列表
    --以ID排序，优先冲上次未冲完的。
    Cursor c_Deposit
    (
      v_病人id        病人信息.病人id%Type,
      v_冲预交病人ids Varchar2
    ) Is
      Select 病人id, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额, Min(记录状态) As 记录状态, Nvl(Max(结帐id), 0) As 结帐id,
             Max(Decode(记录性质, 1, ID, 0) * Decode(记录状态, 2, 0, 1)) As 原预交id
      From 病人预交记录
      Where 记录性质 In (1, 11) And 病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And Nvl(预交类别, 2) = 1
       Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
      Group By NO, 病人id
      Order By Decode(病人id, Nvl(v_病人id, 0), 0, 1), 结帐id, NO;
  
    Function Zl_诊室(记录id_In 临床出诊记录.Id%Type) Return Varchar2 As
      n_分诊方式 临床出诊记录.分诊方式%Type;
      v_诊室     病人挂号记录.诊室%Type;
      v_Rowid    Varchar2(500);
      n_Next     Integer;
      n_First    Integer;
    Begin
    
      If 锁定类型_In = 2 Then
        --对单据进行解锁,首先检查是否存在锁定
        Select Count(Rowid)
        Into n_锁定
        From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
        If n_锁定 = 0 Then
          v_Err_Msg := '单据号为(' || 单据号_In || ')的单据,不存在或者已经被解锁!';
          Raise Err_Item;
        End If;
        Select Max(号序) Into n_号序 From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
      End If;
    
      Begin
        Select Nvl(分诊方式, 0) Into n_分诊方式 From 临床出诊记录 Where ID = 记录id_In;
      Exception
        When Others Then
          v_Err_Msg := '出诊记录(' || 记录id_In || ')未找到!';
          Raise Err_Item;
      End;
    
      --0-不分诊、1-指定诊室、2-动态分诊、3-平均分诊,对应门诊诊室设置
      v_诊室 := Null;
      If n_分诊方式 = 1 Then
        --1-指定诊室
        Begin
          Select b.名称 Into v_诊室 From 临床出诊诊室记录 A, 门诊诊室 B Where a.诊室id = b.Id And a.记录id = 记录id_In;
        Exception
          When Others Then
            v_诊室 := Null;
        End;
      End If;
      If n_分诊方式 = 2 Then
        --2-动态分诊:该个号别当天挂号未诊数最少的诊室
        For c_诊室 In (Select 门诊诊室, Sum(Num) As Num
                     From (Select b.名称 As 门诊诊室, 0 As Num
                            From 临床出诊诊室记录 A, 门诊诊室 B
                            Where a.诊室id = b.Id And a.记录id = 记录id_In
                            Union All
                            Select 诊室, Count(诊室) As Num
                            From 病人挂号记录
                            Where Nvl(执行状态, 0) = 0 And 发生时间 Between Trunc(Sysdate) And Sysdate And 号别 = 号码_In And
                                  诊室 In (Select d.名称
                                         From 临床出诊诊室记录 C, 门诊诊室 D
                                         Where c.诊室id = d.Id And c.记录id = 记录id_In)
                            Group By 诊室)
                     Group By 门诊诊室
                     Order By Num) Loop
          v_诊室 := c_诊室.门诊诊室;
          Exit;
        End Loop;
      End If;
      If n_分诊方式 = 3 Then
        --平均分诊：当前分配=1表示下次应取的当前诊室
        n_Next  := 0;
        n_First := 1;
        For c_诊室 In (Select a.Rowid As Rid, b.名称 As 门诊诊室, a.当前分配
                     From 临床出诊诊室记录 A, 门诊诊室 B
                     Where a.诊室id = b.Id And a.记录id = 记录id_In) Loop
          If n_First = 1 Then
            v_Rowid := c_诊室.Rid;
          End If;
          If n_Next = 1 Then
            v_诊室 := c_诊室.门诊诊室;
            Update 临床出诊诊室记录 Set 当前分配 = 1 Where Rowid = c_诊室.Rid;
            Exit;
          End If;
          If Nvl(c_诊室.当前分配, 0) = 1 Then
            Update 临床出诊诊室记录 Set 当前分配 = 0 Where Rowid = c_诊室.Rid;
            n_Next := 1;
          End If;
        End Loop;
        If v_诊室 Is Null Then
          Update 临床出诊诊室记录 Set 当前分配 = 1 Where Rowid = v_Rowid Returning 诊室id Into v_诊室;
          Select 名称 Into v_诊室 From 门诊诊室 Where ID = v_诊室;
        End If;
      End If;
      Return v_诊室;
    End;
  
    Function Zl_操作员
    (
      Type_In     Integer,
      Splitstr_In Varchar2
    ) Return Varchar2 As
      n_Step Number(18);
      v_Sub  Varchar2(1000);
      --Type_In:0-获取缺省部门ID;1-获取操作员编号;2-获取操作员姓名
      -- SplitStr:格式为:部门ID,部门名称;人员ID,人员编号,人员姓名(用Zl_Identity获取的)
    Begin
      If Type_In = 0 Then
        --缺省部门
        n_Step := Instr(Splitstr_In, ',');
        v_Sub  := Substr(Splitstr_In, 1, n_Step - 1);
        Return v_Sub;
      End If;
      If Type_In = 1 Then
        --操作员编码
        n_Step := Instr(Splitstr_In, ';');
        v_Sub  := Substr(Splitstr_In, n_Step + 1);
        n_Step := Instr(v_Sub, ',');
        v_Sub  := Substr(v_Sub, n_Step + 1);
        n_Step := Instr(v_Sub, ',');
        v_Sub  := Substr(v_Sub, 1, n_Step - 1);
        Return v_Sub;
      End If;
      If Type_In = 2 Then
        --操作员姓名
        n_Step := Instr(Splitstr_In, ';');
        v_Sub  := Substr(Splitstr_In, n_Step + 1);
        n_Step := Instr(v_Sub, ',');
        v_Sub  := Substr(v_Sub, n_Step + 1);
        n_Step := Instr(v_Sub, ',');
        v_Sub  := Substr(v_Sub, n_Step + 1);
        Return v_Sub;
      End If;
    End;
  
  Begin
    v_冲预交病人ids := Nvl(冲预交病人ids_In, 病人id_In);
    Begin
      Select 名称 Into v_现金 From 结算方式 Where 性质 = 1;
    Exception
      When Others Then
        v_现金 := '现金';
    End;
  
    If 费别_In Is Null Then
      Select Zl_Custom_Getpatifeetype(1, 病人id_In) Into v_费别 From Dual;
    Else
      v_费别 := 费别_In;
    End If;
    If v_费别 Is Null Then
      n_屏蔽费别 := 1;
      Select 名称 Into v_费别 From 费别 Where 缺省标志 = 1 And Rownum < 2;
    End If;
    Update 病人信息 Set 费别 = v_费别 Where 病人id = 病人id_In;
  
    If 更新年龄_In = 1 Then
      Select Zl_Age_Calc(病人id_In) Into v_年龄 From Dual;
      If v_年龄 Is Not Null Then
        Update 病人信息 Set 年龄 = v_年龄 Where 病人id = 病人id_In;
      End If;
    End If;
    --获取当前机器名称
    If 机器名_In Is Not Null Then
      v_机器名 := 机器名_In;
    Else
      Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
    End If;
    n_实收金额合计 := 0;
  
    Select Count(*) + 1
    Into n_挂号序号
    From 病人挂号记录
    Where 出诊记录id = 记录id_In And 登记时间 Between Trunc(发生时间_In) And Trunc(发生时间_In + 1) - 1 / 24 / 60 / 60;
  
    If 登记时间_In Is Null Then
      d_登记时间 := Sysdate;
    Else
      d_登记时间 := 登记时间_In;
    End If;
    If Trunc(Sysdate) > Trunc(发生时间_In) Then
      v_Err_Msg := '不能挂以前的号(' || To_Char(发生时间_In, 'yyyy-mm-dd') || ')。';
      Raise Err_Item;
    End If;
  
    v_Temp           := Nvl(zl_GetSysParameter('病人同科限挂N个号', 1111), '0|0') || '|';
    n_同科限号数     := To_Number(Substr(v_Temp, 1, Instr(v_Temp, '|') - 1));
    n_同科限约数     := To_Number(Nvl(zl_GetSysParameter('病人同科限约N个号', 1111), '0'));
    n_病人预约科室数 := To_Number(Nvl(zl_GetSysParameter('病人预约科室数', 1111), '0'));
    n_病人挂号科室数 := To_Number(Nvl(zl_GetSysParameter('病人挂号科室限制', 1111), '0'));
    n_专家号挂号限制 := To_Number(Nvl(zl_GetSysParameter('专家号挂号限制'), '0'));
    n_专家号预约限制 := To_Number(Nvl(zl_GetSysParameter('专家号预约限制'), '0'));
  
    --部门ID,部门名称;人员ID,人员编号,人员姓名
    v_Temp := Zl_Identity(0);
    If Nvl(v_Temp, ' ') = ' ' Then
      v_Err_Msg := '当前操作人员未设置对应的人员关系,不能继续。';
      Raise Err_Item;
    End If;
    n_开单部门id := To_Number(Zl_操作员(0, v_Temp));
    v_操作员编号 := Zl_操作员(1, v_Temp);
    v_操作员姓名 := Zl_操作员(2, v_Temp);
    n_组id       := Zl_Get组id(v_操作员姓名);
  
    --支付宝并发提交检查
    Select Nvl(Max(1), 0)
    Into n_Exists
    From 病人挂号记录
    Where 病人id = 病人id_In And 号别 = 号码_In And 号序 = 号序_In And 操作员姓名 = v_操作员姓名 And Nvl(记录id_In, 0) = Nvl(出诊记录id, 0) And
          登记时间 > Sysdate - 0.01 And 记录状态 = 1 And 发生时间 = 发生时间_In;
    If n_Exists = 1 Then
      v_Err_Msg := '病人已经挂号,不能重复挂相同的号！';
      Raise Err_Special;
    End If;
  
    If 操作方式_In <> 1 Then
      --预约检查是否添加合作单位控制
      --如果设置了合作单位控制 则
      Begin
        Select 1
        Into n_合作单位限制
        From 临床出诊挂号控制记录
        Where 记录id = 记录id_In And 类型 = 1 And 性质 = 1 And 控制方式 <> 4 And Rownum < 2;
      Exception
        When Others Then
          n_合作单位限制 := 0;
      End;
    End If;
  
    If 操作方式_In <> 2 Then
      v_诊室 := Zl_诊室(记录id_In);
    End If;
  
    --因为现在有按日编单据号规则,日挂号量不能超过10000次,所以要检查唯一约束。
    Select Count(*) Into n_Count From 门诊费用记录 Where 记录性质 = 4 And 记录状态 In (1, 3) And NO = 单据号_In;
    If n_Count <> 0 Then
      v_Err_Msg := '挂号单据号重复,不能保存！' || Chr(13) || '如果使用了按日顺序编号,当日挂号量不能超过10000人次。';
      Raise Err_Item;
    End If;
  
    Open c_Pati(病人id_In);
    n_Count := 0;
    Begin
      Fetch c_Pati
        Into r_Pati;
    Exception
      When Others Then
        n_Count := -1;
    End;
    If n_Count = -1 Then
      v_Err_Msg := '病人未找到，不能继续。';
      Raise Err_Item;
    End If;
  
    Begin
      Select Nvl(是否分时段, 0), 限号数, 已挂数, 其中已接收, 已约数, 是否序号控制, 限约数, 项目id, 科室id, 医生id, 医生姓名, 替诊医生id, 替诊医生姓名, 替诊开始时间, 替诊终止时间
      Into n_启用分时段, n_限号数, n_已挂数, n_其中已接收, n_已约数, n_序号控制, n_限约数, n_项目id, n_科室id, n_医生id, v_医生姓名, n_替诊医生id, v_替诊医生姓名,
           d_替诊开始时间, d_替诊终止时间
      From 临床出诊记录
      Where ID = 记录id_In;
    Exception
      When Others Then
        n_Count := -1;
    End;
    If n_Count = -1 Then
      v_Err_Msg := '该号别没有在' || To_Char(发生时间_In, 'yyyy-mm-dd hh24:mi:ss') || '中进行安排。';
      Raise Err_Item;
    End If;
  
    Select Min(站点) Into v_站点 From 部门表 Where ID = n_科室id;
    v_Pricegrade := Zl_Get_Pricegrade(v_站点, 病人id_In);
    v_药品等级   := Substr(v_Pricegrade, 1, Instr(v_Pricegrade, '|') - 1);
    v_Pricegrade := Substr(v_Pricegrade, Instr(v_Pricegrade, '|') + 1);
    v_卫材等级   := Substr(v_Pricegrade, 1, Instr(v_Pricegrade, '|') - 1);
    v_Pricegrade := Substr(v_Pricegrade, Instr(v_Pricegrade, '|') + 1);
    v_普通等级   := Substr(v_Pricegrade, 1, Instr(v_Pricegrade, '|') - 1);
  
    If 发生时间_In Between Nvl(d_替诊开始时间, Sysdate) And Nvl(d_替诊终止时间, Sysdate - 1) And v_替诊医生姓名 Is Not Null Then
      n_医生id   := n_替诊医生id;
      v_医生姓名 := v_替诊医生姓名;
    End If;
  
    --对参数控制进行检查
    --仅在预约不扣款时进行检查
    If 操作方式_In = 2 Then
      If Nvl(n_同科限约数, 0) <> 0 Or Nvl(n_病人预约科室数, 0) <> 0 Then
        n_已约科室 := 0;
        For c_Chkitem In (Select Distinct 执行部门id
                          From 病人挂号记录
                          Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 2 And 预约时间 Between Trunc(发生时间_In) And
                                Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id <> n_科室id) Loop
          n_已约科室 := n_已约科室 + 1;
        End Loop;
        If n_已约科室 >= Nvl(n_病人预约科室数, 0) And Nvl(n_病人预约科室数, 0) > 0 Then
          v_Err_Msg := '同一病人最多同时能预约[' || Nvl(n_病人预约科室数, 0) || ']个科室,不能再预约！';
          Raise Err_Item;
        End If;
      
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 2 And 预约时间 Between Trunc(发生时间_In) And
              Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id = n_科室id;
        If n_Count >= Nvl(n_同科限约数, 0) And Nvl(n_同科限约数, 0) > 0 Then
          v_Err_Msg := '该病人已经在该科室预约了' || n_Count || '次,不能再预约！';
          Raise Err_Item;
        End If;
      End If;
      If Nvl(n_专家号预约限制, 0) <> 0 Then
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 2 And 出诊记录id = 记录id_In;
        If n_Count >= Nvl(n_专家号预约限制, 0) And Nvl(n_专家号预约限制, 0) > 0 Then
          v_Err_Msg := '该病人已经超过本号预约限制,不能再预约！';
          Raise Err_Item;
        End If;
      End If;
    Else
      If Nvl(n_同科限号数, 0) <> 0 Or Nvl(n_病人挂号科室数, 0) <> 0 Then
        n_已约科室 := 0;
        For c_Chkitem In (Select Distinct 执行部门id
                          From 病人挂号记录
                          Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 1 And 发生时间 Between Trunc(发生时间_In) And
                                Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id <> n_科室id) Loop
          n_已约科室 := n_已约科室 + 1;
        End Loop;
        If n_已约科室 >= Nvl(n_病人挂号科室数, 0) And Nvl(n_病人挂号科室数, 0) > 0 Then
          v_Err_Msg := '同一病人最多同时能挂号[' || Nvl(n_病人挂号科室数, 0) || ']个科室,不能再挂号！';
          Raise Err_Item;
        End If;
      
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 1 And 发生时间 Between Trunc(发生时间_In) And
              Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id = n_科室id;
        If n_Count >= Nvl(n_同科限号数, 0) And Nvl(n_同科限号数, 0) > 0 Then
          v_Err_Msg := '该病人已经在该科室挂号了' || n_Count || '次,不能再挂号！';
          Raise Err_Item;
        End If;
      End If;
      If Nvl(n_专家号挂号限制, 0) <> 0 Then
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 1 And 出诊记录id = 记录id_In;
        If n_Count >= Nvl(n_专家号挂号限制, 0) And Nvl(n_专家号挂号限制, 0) > 0 Then
          v_Err_Msg := '该病人已经超过本号挂号限制,不能再挂号！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  
    d_Date         := Null;
    d_时段开始时间 := Null;
  
    If Nvl(n_限号数, 0) >= 0 Or n_限号数 Is Null Then
      If n_启用分时段 = 1 Then
        If Nvl(n_序号控制, 0) = 1 Then
          If Nvl(是否自助设备_In, 0) = 0 Then
            Select Count(*), Max(开始时间)
            Into n_Count, d_时段开始时间
            From 临床出诊序号控制
            Where 记录id = 记录id_In And 序号 = Nvl(号序_In, 0);
          
            v_Temp := '挂号';
            If 操作方式_In > 1 Then
              v_Temp := '预约挂号';
            End If;
          
            If n_Count = 0 Then
              v_Err_Msg := '号别为' || 号码_In || '的挂号安排中不存在序号为' || Nvl(号序_In, 0) || '的安排,不能再' || v_Temp || '！';
              Raise Err_Item;
            End If;
          End If;
        
          --过点的,不能选择挂号
          If Trunc(Sysdate) = Trunc(发生时间_In) Then
            --挂当天的号
            v_Temp := To_Char(Sysdate, 'yyyy-mm-dd') || ' ';
            For v_时段 In (Select To_Date(v_Temp || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                To_Date(To_Char(Sysdate + Decode(Sign(开始时间 - 终止时间), 1, 1, 0), 'yyyy-mm-dd') || ' ' ||
                                         To_Char(终止时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 终止时间, 数量, 是否预约
                         From 临床出诊序号控制
                         Where 记录id = 记录id_In And 序号 = Nvl(号序_In, 0)) Loop
              If Sysdate > v_时段.终止时间 Then
                v_Err_Msg := '号别为' || 号码_In || '及号序为' || Nvl(号序_In, 0) || '的安排,已经超过时点,不能再' || v_Temp || '！';
                Raise Err_Item;
              End If;
            End Loop;
          End If;
        Elsif 操作方式_In > 1 Then
          --未启用序号的,需要检查预约的情况
          n_Count := 0;
          For v_时段 In (Select 序号, 开始时间, 终止时间, 数量, 是否预约
                       From 临床出诊序号控制
                       Where 记录id = 记录id_In And
                             (('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                             Decode(Sign(开始时间 - 终止时间 - 1 / 24 / 60 / 60), 1,
                                      '3000-01-09 ' || To_Char(开始时间, 'HH24:MI:SS'),
                                      '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS')) And
                             '3000-01-10 ' || To_Char(终止时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS')) Or
                             ('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                             '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS') And
                             Decode(Sign(开始时间 - 终止时间 - 1 / 24 / 60 / 60), 1,
                                      '3000-01-11 ' || To_Char(终止时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'),
                                      '3000-01-10 ' || To_Char(终止时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'))))) Loop
            n_预约时段序号 := v_时段.序号;
            d_时段开始时间 := v_时段.开始时间;
            d_时段终止时间 := v_时段.终止时间;
          
            Select Count(*), Max(序号), Max(预约顺序号) + 1
            Into n_Count, n_预约总数, n_预约顺序号
            From 临床出诊序号控制
            Where 记录id = 记录id_In And Nvl(挂号状态, 0) Not In (0, 4, 5);
          
            If Nvl(n_Count, 0) > Nvl(v_时段.数量, 0) And 锁定类型_In <> 2 Then
              v_Err_Msg := '号别为' || 号码_In || '的挂号安排中在' || To_Char(v_时段.开始时间, 'hh24:mi:ss') || '至' ||
                           To_Char(v_时段.终止时间, 'hh24:mi:ss') || '最多只能预约' || Nvl(v_时段.数量, 0) || '人,不能再进行预约挂号！';
              Raise Err_Item;
            End If;
            n_Count := 1;
          End Loop;
        
          If n_Count = 0 Then
            v_Err_Msg := '号别为' || 号码_In || '的挂号安排中没有相关的安排计划(' || To_Char(发生时间_In, 'YYYY-mm-dd HH24:MI:SS') ||
                         '),不能进行预约挂号！';
            Raise Err_Item;
          End If;
        End If;
      End If;
    End If;
  
    If 操作方式_In = 1 And 锁定类型_In <> 2 Then
      --挂号规则:
      --  已挂数不能大于限号数
      If n_已挂数 >= Nvl(n_限号数, 0) And n_限号数 Is Not Null Then
        v_Err_Msg := '该号别今天已达到限号数 ' || Nvl(n_限号数, 0) || '不能再挂号！';
        Raise Err_Item;
      End If;
    End If;
  
    If 操作方式_In > 1 Then
      --预约的相关检查
      --规则:
      --   1.已限约不能超过限约数
      --   2.检查是否启用时段的
      If n_已约数 >= Nvl(n_限约数, 0) And Nvl(n_限约数, 0) <> 0 And n_限约数 Is Not Null And 锁定类型_In <> 2 Then
        v_Err_Msg := '该号别已达到限约数 ' || Nvl(n_限约数, 0) || '不能再预约挂号！';
        Raise Err_Item;
      End If;
      If 预约方式_In Is Not Null Then
        Select To_Number(Substr(Zl_Fun_Get临床出诊预约状态(记录id_In, 发生时间_In, 号序_In, 预约方式_In), 1, 1))
        Into n_Exists
        From Dual;
        If n_Exists <> 0 Then
          v_Err_Msg := '传入的预约方式' || 预约方式_In || '不可用,不能继续。';
          Raise Err_Item;
        End If;
      End If;
    End If;
    If n_合作单位限制 > 0 And 操作方式_In <> 1 And 合作单位_In Is Not Null Then
      If Nvl(n_序号控制, 0) = 1 And Nvl(号序_In, 0) = 0 Then
        v_Err_Msg := '当前安排使用了序号控制,请确认所需要预约的序号,不能继续。';
        Raise Err_Item;
      End If; --Nvl(r_安排.序号控制, 0) =0
    
      n_序号 := Case
                When Nvl(n_序号控制, 0) = 1 Or n_启用分时段 = 1 And 操作方式_In > 1 Then
                 Nvl(号序_In, 0)
                Else
                 0
              End;
    
      --合作单位控制模式
      Select Nvl(控制方式, 0)
      Into n_合作单位限数量模式
      From 临床出诊挂号控制记录
      Where 记录id = 记录id_In And 名称 = 合作单位_In And 类型 = 1 And 性质 = 1 And Rownum < 2;
    
      If n_合作单位限数量模式 = 0 Then
        v_Err_Msg := '当前号码(' || Nvl(号码_In, 0) || '未开放' || 合作单位_In || '的预约,不能继续。';
        Raise Err_Item;
      End If;
      If n_合作单位限数量模式 = 1 Or n_合作单位限数量模式 = 2 Then
        Select 数量
        Into n_Count
        From 临床出诊挂号控制记录
        Where 记录id = 记录id_In And 名称 = 合作单位_In And 类型 = 1 And 性质 = 1;
        If n_合作单位限数量模式 = 1 Then
          n_Count := Round(Nvl(n_限约数, n_限号数) * n_Count / 100);
        End If;
        Select Count(1)
        Into n_Exists
        From 病人挂号记录
        Where 记录状态 = 1 And 出诊记录id = 记录id_In And 合作单位 = 合作单位_In;
        If n_Exists >= n_Count Then
          v_Err_Msg := '当前号码(' || Nvl(号码_In, 0) || '已经超过' || 合作单位_In || '的预约限制,不能继续。';
          Raise Err_Item;
        End If;
      End If;
      --开放序号检查
      If n_合作单位限数量模式 = 3 Then
        For c_合作单位 In (Select 序号, 数量
                       From 临床出诊挂号控制记录
                       Where 记录id = 记录id_In And 名称 = 合作单位_In And 类型 = 1 And 性质 = 1 And 序号 = 号序_In) Loop
          If n_序号控制 = 1 Then
            Begin
              Select 1
              Into n_Count
              From 临床出诊序号控制
              Where 记录id = 记录id_In And 序号 = 号序_In And Nvl(挂号状态, 0) = 0;
            Exception
              When Others Then
                n_Count := 0;
            End;
            If n_Count = 1 Then
              n_是否开放 := 1;
            Else
              v_Err_Msg := '当前序号(' || Nvl(号序_In, 0) || '已经超过' || 合作单位_In || '的预约限制,不能继续。';
              Raise Err_Item;
            End If;
          Else
            Select Count(1)
            Into n_Count
            From 临床出诊序号控制
            Where 记录id = 记录id_In And 序号 = 号序_In And 预约顺序号 Is Not Null And Nvl(挂号状态, 0) <> 0;
            If n_Count >= c_合作单位.数量 Then
              v_Err_Msg := '当前序号(' || Nvl(号序_In, 0) || '已经超过' || 合作单位_In || '的预约限制,不能继续。';
              Raise Err_Item;
            Else
              n_是否开放 := 1;
            End If;
          End If;
        End Loop;
      
        If Nvl(n_是否开放, 0) = 0 Then
          v_Err_Msg := '当前序号(' || Nvl(号序_In, 0) || '未开放,不能继续。';
          Raise Err_Item;
        End If;
      End If;
    End If;
  
    --检查限号数和限约数
    n_行号         := 1;
    n_原项目id     := 0;
    n_原收入项目id := 0;
    n_实收金额合计 := 0;
    If 锁定类型_In <> 1 Then
      If 操作方式_In <> 2 Then
        If Nvl(结帐id_In, 0) = 0 Then
          --这里应该程序传入
          Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
        Else
          n_结帐id := 结帐id_In;
        End If;
      Else
        n_结帐id := Null;
      End If;
    End If;
  
    If Nvl(购买病历_In, 0) = 1 Then
      Begin
        Select 收费细目id Into n_病历费id From 收费特定项目 Where 特定项目 = '病历费';
        v_收费项目ids := n_项目id || ',' || n_病历费id;
      Exception
        When Others Then
          v_Err_Msg := '不能确定病历费,挂号失败!';
          Raise Err_Item;
      End;
    Else
      v_收费项目ids := n_项目id;
    End If;
  
    For c_Item In (Select 1 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, Null As 从属父号,
                          Nvl(a.项目特性, 0) As 急诊
                   From 收费项目目录 A, 收费价目 B, 收入项目 C
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = n_项目id And Sysdate Between b.执行日期 And
                         Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And
                         (b.价格等级 = v_普通等级 Or
                         (b.价格等级 Is Null And Not Exists
                          (Select 1
                            From 收费价目
                            Where b.收费细目id = 收费细目id And 价格等级 = v_普通等级 And Sysdate Between 执行日期 And
                                  Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')))))
                   Union All
                   Select 2 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, Null As 从属父号, 0 As 急诊
                   From 收费项目目录 A, 收费价目 B, 收入项目 C
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = n_病历费id And Sysdate Between b.执行日期 And
                         Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And
                         (b.价格等级 = v_普通等级 Or
                         (b.价格等级 Is Null And Not Exists
                          (Select 1
                            From 收费价目
                            Where b.收费细目id = 收费细目id And 价格等级 = v_普通等级 And Sysdate Between 执行日期 And
                                  Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')))))
                   Union All
                   Select 3 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, d.从项数次 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, 1 As 从属父号, 0 As 急诊
                   From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费从属项目 D
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = d.从项id And
                         d.主项id In (Select Column_Value From Table(f_Str2list(v_收费项目ids))) And Sysdate Between b.执行日期 And
                         Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And
                         (b.价格等级 = v_普通等级 Or
                         (b.价格等级 Is Null And Not Exists
                          (Select 1
                            From 收费价目
                            Where b.收费细目id = 收费细目id And 价格等级 = v_普通等级 And Sysdate Between 执行日期 And
                                  Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')))))
                   Order By 性质, 项目编码, 收入编码) Loop
      If c_Item.性质 = 1 Then
        n_急诊 := Nvl(c_Item.急诊, 0);
      End If;
      n_价格父号 := Null;
      If n_原项目id = c_Item.项目id Then
        If n_原收入项目id <> c_Item.收入项目id Then
          n_价格父号 := n_行号;
        End If;
        n_原收入项目id := c_Item.收入项目id;
      End If;
      n_原项目id := c_Item.项目id;
      n_应收金额 := Round(c_Item.数次 * c_Item.单价, 5);
      n_实收金额 := n_应收金额;
      If Nvl(c_Item.屏蔽费别, 0) <> 1 And n_屏蔽费别 = 0 Then
        --打折:
        v_Temp     := Zl_Actualmoney(r_Pati.费别, c_Item.项目id, c_Item.收入项目id, n_应收金额);
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ':') + 1);
        n_实收金额 := Zl_To_Number(v_Temp);
      End If;
      n_实收金额合计 := Nvl(n_实收金额合计, 0) + n_实收金额;
    
      --锁定单据不产生费用
      If 锁定类型_In <> 1 Then
        --产生病人挂号费用(可能单独是或包括病历费用)
        Select 病人费用记录_Id.Nextval Into n_费用id From Dual;
        --:操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
        Insert Into 门诊费用记录
          (ID, 记录性质, 记录状态, 序号, 价格父号, 从属父号, NO, 实际票号, 门诊标志, 加班标志, 附加标志, 发药窗口, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 病人科室id,
           收费类别, 计算单位, 收费细目id, 收入项目id, 收据费目, 付数, 数次, 标准单价, 应收金额, 实收金额, 结帐金额, 结帐id, 记帐费用, 开单部门id, 开单人, 划价人, 执行部门id, 执行人,
           操作员编号, 操作员姓名, 发生时间, 登记时间, 保险大类id, 保险项目否, 保险编码, 统筹金额, 摘要, 结论, 缴款组id)
        Values
          (n_费用id, 4, Decode(操作方式_In, 2, 0, 1), n_行号, n_价格父号, c_Item.从属父号, 单据号_In, 票据号_In, 1, n_急诊, Null,
           Decode(操作方式_In, 2, To_Char(号序_In), v_诊室), r_Pati.病人id, r_Pati.门诊号, r_Pati.付款方式, r_Pati.姓名, r_Pati.性别,
           r_Pati.年龄, r_Pati.费别, n_科室id, c_Item.类别, 号码_In, c_Item.项目id, c_Item.收入项目id, c_Item.收据费目, 1, c_Item.数次,
           c_Item.单价, n_应收金额, n_实收金额, Decode(操作方式_In, 2, Null, Decode(Nvl(记帐费用_In, 0), 1, Null, n_实收金额)),
           Decode(Nvl(记帐费用_In, 0), 1, Null, n_结帐id), Decode(Nvl(记帐费用_In, 0), 1, 1, 0), n_开单部门id, v_操作员姓名,
           Decode(操作方式_In, 2, v_操作员姓名, Null), n_科室id, v_医生姓名, v_操作员编号, v_操作员姓名, 发生时间_In, d_登记时间, Null, 0, Null, Null,
           摘要_In, 预约方式_In, Decode(操作方式_In, 2, Null, n_组id));
      End If;
      n_行号 := n_行号 + 1;
    
    End Loop;
  
    If Round(Nvl(挂号金额合计_In, 0), 5) <> Round(Nvl(n_实收金额合计, 0), 5) Then
      v_Err_Msg := '本次挂号金额不正确,可能是因为医院调整了价格,请重新获取挂号收费项目的价格,不能继续。';
      Raise Err_Item;
    End If;
  
    If n_启用分时段 = 1 Then
      d_Date := To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(d_时段开始时间, 'hh24:mi:ss'),
                        'yyyy-mm-dd hh24:mi:ss');
    Else
      d_Date := Trunc(发生时间_In);
    End If;
  
    --更新挂号序号状态
    If 锁定类型_In <> 2 Then
      n_号序 := 号序_In;
    End If;
    Begin
      Select 1
      Into n_Count
      From 临床出诊序号控制
      Where 记录id = 记录id_In And 序号 = n_号序 And Nvl(挂号状态, 0) Not In (0, 5);
    Exception
      When Others Then
        n_Count := 0;
    End;
    If n_Count = 1 Then
      If n_启用分时段 = 0 And Nvl(n_序号控制, 0) = 1 Then
        n_号序 := Null;
      End If;
      If n_启用分时段 = 1 And Nvl(n_序号控制, 0) = 1 Then
        v_Err_Msg := '当前序号已被使用，请重新选择一个序号！';
        Raise Err_Item;
      End If;
    End If;
    n_Count := 0;
    If n_启用分时段 = 0 And Nvl(n_序号控制, 0) = 1 And n_号序 Is Null And 锁定类型_In <> 2 Then
      Select Nvl(Min(序号), 0)
      Into n_号序
      From 临床出诊序号控制
      Where 记录id = 记录id_In And Nvl(挂号状态, 0) = 5 And 操作员姓名 = v_操作员姓名 And 工作站名称 = v_机器名;
      If n_号序 = 0 Then
        Select Nvl(Min(序号), 0) Into n_号序 From 临床出诊序号控制 Where 记录id = 记录id_In And Nvl(挂号状态, 0) = 0;
        If n_号序 = 0 Then
          Select Nvl(Max(序号), 0) + 1 Into n_号序 From 临床出诊序号控制 Where 记录id = 记录id_In;
        End If;
      End If;
    End If;
  
    If n_启用分时段 = 1 And 锁定类型_In <> 2 Then
      If 操作方式_In > 1 And Nvl(n_序号控制, 0) = 0 Then
        --规则:预约时段序号||预约数
        If Nvl(n_预约总数, 0) = 0 Then
          v_Temp := Nvl(n_限约数, 0);
          v_Temp := LTrim(RTrim(v_Temp));
          v_Temp := LPad(Nvl(n_预约总数, 0) + 1, Length(v_Temp), '0');
          v_Temp := n_预约时段序号 || v_Temp;
          n_号序 := To_Number(v_Temp);
        Else
          n_号序 := n_预约总数 + 1;
        End If;
      End If;
    End If;
  
    If Nvl(n_序号控制, 0) = 1 Or (操作方式_In > 1 And n_启用分时段 = 1) Or 加入序号状态_In = 1 Then
      --锁定序号的处理
      Begin
        Select 操作员姓名, 工作站名称
        Into v_序号操作员, v_序号机器名
        From 临床出诊序号控制
        Where 挂号状态 = 5 And 记录id = 记录id_In And 序号 = n_号序;
        n_序号锁定 := 1;
      Exception
        When Others Then
          v_序号操作员 := Null;
          v_序号机器名 := Null;
          n_序号锁定   := 0;
      End;
      If n_序号锁定 = 0 Then
        If n_启用分时段 = 1 And n_序号控制 = 0 Then
          Insert Into 临床出诊序号控制
            (记录id, 序号, 预约顺序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 类型, 名称, 操作员姓名, 备注)
            Select 记录id_In, n_预约时段序号, n_预约顺序号, d_时段开始时间, d_时段终止时间, 1, Decode(操作方式_In, 1, 0, 1), Decode(操作方式_In, 2, 2, 1),
                   1, 合作单位_In, v_操作员姓名, n_号序
            From Dual;
        Else
          Update 临床出诊序号控制
          Set 挂号状态 = Decode(操作方式_In, 2, 2, 1), 操作员姓名 = v_操作员姓名
          Where 记录id = 记录id_In And 序号 = n_号序;
        End If;
        If Sql%RowCount = 0 Then
          Begin
            If n_启用分时段 = 1 Then
              --分时段
              If n_序号控制 = 1 Then
                --序号控制
                Select Max(终止时间) Into d_终止时间 From 临床出诊序号控制 Where 记录id = 记录id_In;
                If Sysdate > d_终止时间 Then
                  d_终止时间 := Sysdate;
                End If;
                Insert Into 临床出诊序号控制
                  (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 类型, 名称, 操作员姓名)
                  Select 记录id_In, n_号序, d_终止时间, d_终止时间, 1, Decode(操作方式_In, 1, 0, 1), Decode(操作方式_In, 2, 2, 1), 1,
                         合作单位_In, v_操作员姓名
                  From Dual;
              Else
                --分时段,非序号控制
                Null;
              End If;
            Else
              --不分时段
              Insert Into 临床出诊序号控制
                (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 类型, 名称, 操作员姓名)
                Select 记录id_In, n_号序, 开始时间, 终止时间, 1, Decode(操作方式_In, 1, 0, 1), Decode(操作方式_In, 2, 2, 1), 1, 合作单位_In,
                       v_操作员姓名
                From 临床出诊序号控制
                Where 记录id = 记录id_In And 序号 = 1;
            End If;
          Exception
            When Others Then
              v_Err_Msg := '序号' || n_号序 || '已被使用,请重新选择一个序号.';
              Raise Err_Item;
          End;
        End If;
      Else
        If v_操作员姓名 <> v_序号操作员 Or v_机器名 <> v_序号机器名 Then
          v_Err_Msg := '序号' || n_号序 || '已被机器' || v_机器名 || '锁定,请重新选择一个序号.';
          Raise Err_Item;
        Else
          Update 临床出诊序号控制
          Set 挂号状态 = Decode(操作方式_In, 2, 2, 1), 锁号时间 = Null
          Where 记录id = 记录id_In And 序号 = n_号序 And 挂号状态 = 5 And 操作员姓名 = v_操作员姓名 And 工作站名称 = v_机器名;
        End If;
      End If;
    End If;
  
    --锁定单据不产生任何 费用
    If 操作方式_In <> 2 And 锁定类型_In <> 1 And Nvl(记帐费用_In, 0) = 0 Then
      --挂号,预约挂号已经扣款部分
      n_预交id := 预交id_In;
      If Nvl(n_预交id, 0) = 0 Then
        Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      End If;
      n_结算合计 := 0;
      If 保险结算_In Is Not Null Then
        --各个保险结算
        v_结算内容 := 保险结算_In || '||';
        n_结算合计 := 0;
        While v_结算内容 Is Not Null Loop
          v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
          v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
          n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
          If Nvl(n_结算金额, 0) <> 0 Then
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 记录状态, 病人id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算性质)
            Values
              (n_预交id, 4, 单据号_In, 1, Decode(病人id_In, 0, Null, 病人id_In), '保险结算', v_结算方式, d_登记时间, v_操作员编号, v_操作员姓名,
               n_结算金额, n_结帐id, n_组id, n_结帐id, 4);
            Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          End If;
          n_结算合计 := Nvl(n_结算合计, 0) + Nvl(n_结算金额, 0);
          v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
        End Loop;
      End If;
    
      If Nvl(冲预交_In, 0) <> 0 Then
        --处理总预交
        n_结算合计 := n_结算合计 + Nvl(冲预交_In, 0);
        n_预交金额 := 冲预交_In;
        For r_Deposit In c_Deposit(病人id_In, v_冲预交病人ids) Loop
          n_结算金额 := Case
                      When r_Deposit.金额 - n_预交金额 < 0 Then
                       r_Deposit.金额
                      Else
                       n_预交金额
                    End;
          If r_Deposit.结帐id = 0 Then
            --第一次冲预交(填上结帐ID,金额为0)
            Update 病人预交记录 Set 冲预交 = 0, 结帐id = n_结帐id, 结算性质 = 4 Where ID = r_Deposit.原预交id;
          End If;
          --冲上次剩余额
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 预交类别, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名,
             操作员编号, 冲预交, 结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 预交类别, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行,
                   单位帐号, d_登记时间, v_操作员姓名, v_操作员编号, n_结算金额, n_结帐id, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, n_结帐id, 4
            From 病人预交记录
            Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
        
          --更新病人预交余额
          Update 病人余额
          Set 预交余额 = Nvl(预交余额, 0) - n_结算金额
          Where 病人id = r_Deposit.病人id And 性质 = 1 And 类型 = Nvl(1, 2)
          Returning 预交余额 Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 病人余额 (病人id, 预交余额, 性质, 类型) Values (r_Deposit.病人id, -1 * n_结算金额, 1, 1);
            n_返回值 := -1 * n_结算金额;
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 病人余额
            Where 病人id = r_Deposit.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
          End If;
        
          --检查是否已经处理完
          If r_Deposit.金额 <= n_结算金额 Then
            n_预交金额 := n_预交金额 - r_Deposit.金额;
          Else
            n_预交金额 := 0;
          End If;
          If n_预交金额 = 0 Then
            Exit;
          End If;
        End Loop;
        If n_预交金额 > 0 Then
          v_Err_Msg := '预交余额不够支付本次支付金额,不能继续操作！';
          Raise Err_Item;
        End If;
      End If;
      --剩余款项,用指定结算方支付
      n_结算金额 := Nvl(n_实收金额合计, 0) - Nvl(n_结算合计, 0);
      If Nvl(n_结算金额, 0) < 0 Then
        v_Err_Msg := '挂号的相关结算金额超出了当前实结金额,不能继续操作！';
        Raise Err_Item;
      End If;
    
      If Nvl(n_结算金额, 0) <> 0 Or (Nvl(n_结算金额, 0) = 0 And Nvl(冲预交_In, 0) = 0) Then
        If 结算方式_In Is Null Then
          v_Err_Msg := '未传入指定的结算方式,不能继续操作！';
          Raise Err_Item;
        End If;
      
        If Nvl(预交id_In, 0) <> 0 Then
          --传入的预交ID_In主要是为了解决三方交易,如果医保结算站用了该ID,需要用新的ID进行更新,三方交易用转入的ID
          Update 病人预交记录 Set ID = n_预交id Where ID = Nvl(预交id_In, 0);
          n_预交id := Nvl(预交id_In, 0);
        End If;
        If Instr(结算方式_In, ',') = 0 Then
          --只传入一种结算方式的
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          Insert Into 病人预交记录
            (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
             合作单位, 结算性质, 结算号码)
          Values
            (n_预交id, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(结算方式_In, v_现金), Nvl(n_结算金额, 0), 登记时间_In,
             v_操作员编号, v_操作员姓名, n_结帐id, '挂号收费', n_组id, 卡类别id_In, Null, 支付卡号_In, 交易流水号_In, 交易说明_In, 合作单位_In, 4, v_结算号码);
        Else
          v_结算内容     := 结算方式_In || '|'; --以空格分开以|结尾,没有结算号码的
          n_Exists       := 0;
          v_结算方式记录 := '';
          While v_结算内容 Is Not Null Loop
            v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '|') - 1);
            v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1);
          
            v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
            n_单笔金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1));
          
            v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
            v_结算号码 := Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1);
          
            v_当前结算   := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
            n_三方卡标志 := To_Number(v_当前结算);
          
            If Instr('|' || v_结算方式记录 || '|', '|' || Nvl(v_结算方式, v_现金) || '|') <> 0 Then
              v_Err_Msg := '使用了重复的结算方式,请检查!';
              Raise Err_Item;
            Else
              v_结算方式记录 := v_结算方式记录 || '|' || Nvl(v_结算方式, v_现金);
            End If;
          
            If n_三方卡标志 = 0 Then
              Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
              Insert Into 病人预交记录
                (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号,
                 交易说明, 合作单位, 结算性质, 结算号码)
              Values
                (n_预交id, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(v_结算方式, v_现金), Nvl(n_单笔金额, 0), 登记时间_In,
                 v_操作员编号, v_操作员姓名, n_结帐id, '挂号收费', n_组id, Null, Null, Null, Null, Null, 合作单位_In, 4, v_结算号码);
            Else
              If n_Exists = 1 Then
                v_Err_Msg := '目前挂号仅支持一种三方结算方式,不能继续操作！';
                Raise Err_Item;
              End If;
              Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
              Insert Into 病人预交记录
                (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号,
                 交易说明, 合作单位, 结算性质, 结算号码)
              Values
                (n_预交id, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(v_结算方式, v_现金), Nvl(n_单笔金额, 0), 登记时间_In,
                 v_操作员编号, v_操作员姓名, n_结帐id, '挂号收费', n_组id, 卡类别id_In, Null, 支付卡号_In, 交易流水号_In, 交易说明_In, 合作单位_In, 4, v_结算号码);
              n_Exists := 1;
            End If;
          
            v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '|') + 1);
          End Loop;
        End If;
      End If;
    
      --更新人员缴款数据
    
      For v_缴款 In (Select 结算方式, Sum(Nvl(a.冲预交, 0)) As 冲预交
                   From 病人预交记录 A
                   Where a.结帐id = n_结帐id And Mod(a.记录性质, 10) <> 1 And Nvl(病人id, 0) = Nvl(病人id_In, 0)
                   Group By 结算方式) Loop
      
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + Nvl(v_缴款.冲预交, 0)
        Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = v_缴款.结算方式
        Returning 余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (v_操作员姓名, v_缴款.结算方式, 1, Nvl(v_缴款.冲预交, 0));
          n_返回值 := Nvl(v_缴款.冲预交, 0);
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = v_操作员姓名 And 结算方式 = v_缴款.结算方式 And 性质 = 1 And Nvl(余额, 0) = 0;
        End If;
      End Loop;
    End If;
  
    --处理挂号记录
    If 锁定类型_In = 2 Then
      Begin
        Select ID Into n_挂号id From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
      Exception
        When Others Then
          Null;
      End;
    Else
      Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
    End If;
  
    Update 病人挂号记录
    Set 记录性质 = Decode(操作方式_In, 2, 2, 1), 记录状态 = Decode(锁定类型_In, 1, 0, 1), 门诊号 = r_Pati.门诊号, 操作员姓名 = v_操作员姓名,
        操作员编号 = v_操作员编号, 预约 = Decode(操作方式_In, 1, 0, 1),
        接收人 = Decode(锁定类型_In, 1, Null, Decode(操作方式_In, 2, Null, v_操作员姓名)),
        接收时间 = Case 锁定类型_In
                  When 1 Then
                   Null
                  Else
                   Case 操作方式_In
                     When 2 Then
                      Null
                     Else
                      d_登记时间
                   End
                End, 交易流水号 = Nvl(交易流水号_In, 交易流水号), 交易说明 = Nvl(交易说明_In, 交易说明), 合作单位 = Nvl(合作单位_In, 合作单位),
        预约操作员 = Decode(操作方式_In, 1, Nvl(预约操作员, Null), Nvl(预约操作员, v_操作员姓名)),
        预约操作员编号 = Decode(操作方式_In, 1, Nvl(预约操作员编号, Null), Nvl(预约操作员编号, v_操作员编号)), 出诊记录id = 记录id_In
    Where ID = n_挂号id;
    If Sql%NotFound Then
      Begin
        Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = r_Pati.付款方式 And Rownum < 2;
      Exception
        When Others Then
          v_付款方式 := Null;
      End;
      Insert Into 病人挂号记录
        (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 预约时间, 操作员编号,
         操作员姓名, 复诊, 号序, 预约, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 医疗付款方式, 预约操作员, 预约操作员编号, 出诊记录id)
      Values
        (n_挂号id, 单据号_In, Decode(操作方式_In, 2, 2, 1), Decode(锁定类型_In, 1, 0, 1), r_Pati.病人id, r_Pati.门诊号, r_Pati.姓名,
         r_Pati.性别, r_Pati.年龄, 号码_In, n_急诊, v_诊室, Null, n_科室id, v_医生姓名, 0, Null, d_登记时间, 发生时间_In,
         Case When(Nvl(操作方式_In, 0)) = 1 Then Null Else 发生时间_In End, v_操作员编号, v_操作员姓名, 0, n_号序, Decode(操作方式_In, 1, 0, 1),
         Decode(操作方式_In, 2, Null, v_操作员姓名), Decode(操作方式_In, 2, To_Date(Null), d_登记时间), 交易流水号_In, 交易说明_In, 合作单位_In,
         v_付款方式, Decode(操作方式_In, 1, Null, v_操作员姓名), Decode(操作方式_In, 1, Null, v_操作员编号), 记录id_In);
    End If;
    --锁定单据不能产生队列
    If 锁定类型_In <> 1 Then
      n_预约生成队列 := 0;
      If 操作方式_In > 1 Then
        n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
      End If;
      --挂号和收费的预约都直接进入队列(收费预约缺少接收过程,所以直接和挂号一样直接进入队列)
      If 操作方式_In <> 2 Or n_预约生成队列 = 1 Then
        If Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113)) <> 0 Then
          --排队叫号模式:-0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站
          If Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113)) = 0 Or n_预约生成队列 = 1 Then
            n_分时点显示 := Nvl(Zl_To_Number(zl_GetSysParameter(270)), 0);
            If Nvl(操作方式_In, 0) > 1 And n_分时点显示 = 1 And n_启用分时段 = 1 Then
              n_分时点显示 := 1;
            Else
              n_分时点显示 := Null;
            End If;
            --产生队列
            --.按”执行部门” 的方式生成队列
            v_队列名称 := n_科室id;
            v_排队号码 := Zlgetnextqueue(n_科室id, n_挂号id, 号码_In || '|' || 号序_In);
            --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)
            v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
            --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)
            d_排队时间 := Zl_Get_Queuedate(n_挂号id, 号码_In, 号序_In, d_Date);
            --  队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,v_排队标记,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In, 排队时间_In
            Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, n_科室id, v_排队号码, Null, r_Pati.姓名, r_Pati.病人id, v_诊室, v_医生姓名, d_排队时间,
                             预约方式_In, n_分时点显示, v_排队序号);
          End If;
        End If;
      End If;
    
      If Nvl(操作方式_In, 0) = 1 And Nvl(记帐费用_In, 0) = 0 Then
        --处理票据使用情况
        If 票据号_In Is Not Null Then
          Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
          --发出票据
          Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 4, 单据号_In);
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
          Values
            (票据使用明细_Id.Nextval, Decode(收费票据_In, 1, 1, 4), 票据号_In, 1, 1, 领用id_In, n_打印id, d_登记时间, v_操作员姓名);
          --状态改动
          Update 票据领用记录
          Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
          Where ID = Nvl(领用id_In, 0);
        End If;
        --病人本次就诊(以发生时间为准)
        If Nvl(r_Pati.病人id, 0) <> 0 Then
          Update 病人信息 Set 就诊时间 = 发生时间_In, 就诊状态 = 1, 就诊诊室 = v_诊室 Where 病人id = r_Pati.病人id;
        End If;
      End If;
    End If;
    --病人挂号汇总
    --解锁单据时不用再对汇总单据进行统计了 在锁定单据时已经进行了汇总
    If 锁定类型_In <> 2 Then
      --操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
      --是否为预约接收:0-非预约挂号; 1-预约挂号,2-预约接收;3-收费预约
      n_预约 := Case
                When Nvl(操作方式_In, 0) = 1 Then
                 0
                When Nvl(操作方式_In, 0) = 2 Then
                 1
                When Nvl(操作方式_In, 0) = 3 Then
                 3
                Else
                 0
              End;
      Zl_病人挂号汇总_Update(v_医生姓名, n_医生id, n_项目id, n_科室id, 发生时间_In, n_预约, 号码_In, 0, 记录id_In);
    End If;
    --消息推送
    Begin
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 1, n_挂号id;
    Exception
      When Others Then
        Null;
    End;
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, '[ZLSOFT]+' || v_Err_Msg || '+[ZLSOFT]');
    When Err_Special Then
      Raise_Application_Error(-20105, '[ZLSOFT]+' || v_Err_Msg || '+[ZLSOFT]');
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End;

Begin
  n_出诊记录id := 出诊记录id_In;
  v_Para       := zl_GetSysParameter(256);
  n_挂号模式   := Substr(v_Para, 1, 1);
  Begin
    d_启用时间 := To_Date(Substr(v_Para, 3), 'yyyy-mm-dd hh24:mi:ss');
  Exception
    When Others Then
      d_启用时间 := Null;
  End;

  If Sysdate - 10 > Nvl(d_启用时间, Sysdate - 30) Then
    If n_挂号模式 = 1 And Nvl(发生时间_In, Sysdate) > Nvl(d_启用时间, Sysdate - 30) And n_出诊记录id Is Null Then
      v_Err_Msg := '系统当前处于出诊表排班模式，传入的参数无法确定挂号安排，请重试！';
      Raise Err_Item;
    End If;
  Else
    If n_挂号模式 = 1 And Nvl(发生时间_In, Sysdate) > Nvl(d_启用时间, Sysdate - 30) And n_出诊记录id Is Null Then
      Begin
        Select a.Id
        Into n_出诊记录id
        From 临床出诊记录 A, 临床出诊号源 B
        Where a.号源id = b.Id And b.号码 = 号码_In And Nvl(发生时间_In, Sysdate) Between a.开始时间 And a.终止时间;
      Exception
        When Others Then
          v_Err_Msg := '系统当前处于出诊表排班模式，传入的参数无法确定挂号安排，请重试！';
          Raise Err_Item;
      End;
    End If;
  End If;

  If n_出诊记录id Is Not Null Then
    --出诊表排班模式
    Zl_三方机构挂号_出诊_Insert(n_出诊记录id, 操作方式_In, 病人id_In, 号码_In, 号序_In, 单据号_In, 票据号_In, 结算方式_In, 摘要_In, 发生时间_In, 登记时间_In,
                        合作单位_In, 挂号金额合计_In, 领用id_In, 收费票据_In, 交易流水号_In, 交易说明_In, 预约方式_In, 预交id_In, 卡类别id_In, 加入序号状态_In,
                        是否自助设备_In, 结帐id_In, 锁定类型_In, 保险结算_In, 冲预交_In, 支付卡号_In, 退号重用_In, 费别_In, 机器名_In, 更新年龄_In, 购买病历_In,
                        记帐费用_In);
  Else
    v_冲预交病人ids := Nvl(冲预交病人ids_In, 病人id_In);
    v_Temp          := zl_GetSysParameter(256);
    If v_Temp Is Null Or Substr(v_Temp, 1, 1) = '0' Then
      Null;
    Else
      Begin
        d_启用时间 := To_Date(Substr(v_Temp, 3), 'YYYY-MM-DD hh24:mi:ss');
      Exception
        When Others Then
          Null;
      End;
      If 发生时间_In > d_启用时间 Then
        v_Err_Msg := '当前挂号的发生时间' || To_Char(发生时间_In, 'yyyy-mm-dd hh24:mi:ss') || '已经启用了出诊表排班模式,不能再使用计划排班模式挂号!';
        Raise Err_Item;
      End If;
    End If;
    If 费别_In Is Null Then
      Select Zl_Custom_Getpatifeetype(1, 病人id_In) Into v_费别 From Dual;
    Else
      v_费别 := 费别_In;
    End If;
    If v_费别 Is Null Then
      n_屏蔽费别 := 1;
      Select 名称 Into v_费别 From 费别 Where 缺省标志 = 1 And Rownum < 2;
    End If;
    Update 病人信息 Set 费别 = v_费别 Where 病人id = 病人id_In;
  
    If 更新年龄_In = 1 Then
      Select Zl_Age_Calc(病人id_In) Into v_年龄 From Dual;
      If v_年龄 Is Not Null Then
        Update 病人信息 Set 年龄 = v_年龄 Where 病人id = 病人id_In;
      End If;
    End If;
    --获取当前机器名称
    If 机器名_In Is Not Null Then
      v_机器名 := 机器名_In;
    Else
      Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
    End If;
    n_实收金额合计 := 0;
    Select Count(*) + 1
    Into n_挂号序号
    From 病人挂号记录
    Where 号别 = 号码_In And 登记时间 Between Trunc(发生时间_In) And Trunc(发生时间_In + 1) - 1 / 24 / 60 / 60;
    --Begin
    v_Temp           := Nvl(zl_GetSysParameter('病人同科限挂N个号', 1111), '0|0') || '|';
    n_同科限号数     := To_Number(Substr(v_Temp, 1, Instr(v_Temp, '|') - 1));
    n_同科限约数     := To_Number(Nvl(zl_GetSysParameter('病人同科限约N个号', 1111), '0'));
    n_病人预约科室数 := To_Number(Nvl(zl_GetSysParameter('病人预约科室数', 1111), '0'));
    n_病人挂号科室数 := To_Number(Nvl(zl_GetSysParameter('病人挂号科室限制', 1111), '0'));
    n_专家号挂号限制 := To_Number(Nvl(zl_GetSysParameter('专家号挂号限制'), '0'));
    n_专家号预约限制 := To_Number(Nvl(zl_GetSysParameter('专家号预约限制'), '0'));
  
    --部门ID,部门名称;人员ID,人员编号,人员姓名
    v_Temp := Zl_Identity(0);
    If Nvl(v_Temp, ' ') = ' ' Then
      v_Err_Msg := '当前操作人员未设置对应的人员关系,不能继续。';
      Raise Err_Item;
    End If;
  
    If 登记时间_In Is Null Then
      d_登记时间 := Sysdate;
    Else
      d_登记时间 := 登记时间_In;
    End If;
    If Trunc(Sysdate) > Trunc(发生时间_In) Then
      v_Err_Msg := '不能挂以前的号(' || To_Char(发生时间_In, 'yyyy-mm-dd') || ')。';
      Raise Err_Item;
    End If;
    n_开单部门id := To_Number(Zl_操作员(0, v_Temp));
    v_操作员编号 := Zl_操作员(1, v_Temp);
    v_操作员姓名 := Zl_操作员(2, v_Temp);
    n_组id       := Zl_Get组id(v_操作员姓名);
  
    --支付宝并发提交检查
    Select Nvl(Max(1), 0)
    Into n_Exists
    From 病人挂号记录
    Where 病人id = 病人id_In And 号别 = 号码_In And 号序 = 号序_In And 操作员姓名 = v_操作员姓名 And Nvl(n_出诊记录id, 0) = Nvl(出诊记录id, 0) And
          登记时间 > Sysdate - 0.01 And 记录状态 = 1 And 发生时间 = 发生时间_In;
    If n_Exists = 1 Then
      v_Err_Msg := '病人已经挂号,不能重复挂相同的号！';
      Raise Err_Special;
    End If;
  
    If 操作方式_In <> 1 Then
      --预约检查是否添加合作单位控制
      --如果设置了合作单位控制 则
      Begin
        Select ID
        Into n_计划id
        From 挂号安排计划
        Where 号码 = 号码_In And 发生时间_In Between Nvl(生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
              Nvl(失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Rownum < 2
        Order By 生效时间 Desc;
      Exception
        When Others Then
          Select ID Into n_Tmp安排id From 挂号安排 Where 号码 = 号码_In;
      End;
      If Nvl(n_计划id, 0) <> 0 Then
        Select Count(0)
        Into n_合作单位限制
        From 合作单位计划控制
        Where 合作单位 = 合作单位_In And 计划id = n_计划id And Rownum < 2;
      Else
        Select Count(0)
        Into n_合作单位限制
        From 合作单位安排控制
        Where 合作单位 = 合作单位_In And 安排id = n_Tmp安排id And Rownum < 2;
      End If;
    End If;
  
    If 操作方式_In <> 2 Then
      v_诊室 := Zl_诊室(号码_In);
    End If;
    If 操作方式_In <> 2 And 结算方式_In Is Not Null Then
      --检查结算方式是否完备
      Select Count(*) Into n_Count From 结算方式 Where 名称 = Nvl(结算方式_In, 'Lxh') And 性质 In (2, 7, 8);
      If Nvl(卡类别id_In, 0) <> 0 And n_Count = 0 Then
        Select Count(1)
        Into n_Count
        From 医疗卡类别
        Where ID = Nvl(卡类别id_In, 0) And 结算方式 = Nvl(结算方式_In, 'lxh');
      End If;
      If n_Count = 0 Then
        v_Err_Msg := '结算方式(' || 结算方式_In || ')未设置,请在结算方式管理中设置。';
        Raise Err_Item;
      End If;
    End If;
  
    --因为现在有按日编单据号规则,日挂号量不能超过10000次,所以要检查唯一约束。
    Select Count(*) Into n_Count From 门诊费用记录 Where 记录性质 = 4 And 记录状态 In (1, 3) And NO = 单据号_In;
    If n_Count <> 0 Then
      v_Err_Msg := '挂号单据号重复,不能保存！' || Chr(13) || '如果使用了按日顺序编号,当日挂号量不能超过10000人次。';
      Raise Err_Item;
    End If;
  
    Open c_Pati(病人id_In);
    n_Count := 0;
    Begin
      Fetch c_Pati
        Into r_Pati;
    Exception
      When Others Then
        n_Count := -1;
    End;
    If n_Count = -1 Then
      v_Err_Msg := '病人未找到，不能继续。';
      Raise Err_Item;
    End If;
  
    Open c_安排(号码_In, 发生时间_In);
    Begin
      Fetch c_安排
        Into r_安排;
    Exception
      When Others Then
        n_Count := -1;
    End;
    If n_Count = -1 Then
      v_Err_Msg := '该号别没有在' || To_Char(发生时间_In, 'yyyy-mm-dd hh24:mi:ss') || '中进行安排。';
      Raise Err_Item;
    End If;
  
    Select Min(站点) Into v_站点 From 部门表 Where ID = r_安排.科室id;
    v_Pricegrade := Zl_Get_Pricegrade(v_站点, 病人id_In);
    v_药品等级   := Substr(v_Pricegrade, 1, Instr(v_Pricegrade, '|') - 1);
    v_Pricegrade := Substr(v_Pricegrade, Instr(v_Pricegrade, '|') + 1);
    v_卫材等级   := Substr(v_Pricegrade, 1, Instr(v_Pricegrade, '|') - 1);
    v_Pricegrade := Substr(v_Pricegrade, Instr(v_Pricegrade, '|') + 1);
    v_普通等级   := Substr(v_Pricegrade, 1, Instr(v_Pricegrade, '|') - 1);
  
    Select Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六',
                   '周日')
    Into v_星期
    From Dual;
    Begin
      If r_安排.计划id Is Null Then
        Select Max(1) Into n_启用分时段 From 挂号安排时段 Where 安排id = r_安排.Id And 星期 = v_星期 And Rownum < 2;
        Select Decode(To_Char(发生时间_In, 'D'), '1', 周日, '2', 周一, '3', 周二, '4', 周三, '5', 周四, '6', 周五, '7', 周六, Null)
        Into v_时间段
        From 挂号安排
        Where ID = r_安排.Id;
      Else
        Select Max(1)
        Into n_启用分时段
        From 挂号计划时段
        Where 计划id = r_安排.计划id And 星期 = v_星期 And Rownum < 2;
        Select Decode(To_Char(发生时间_In, 'D'), '1', 周日, '2', 周一, '3', 周二, '4', 周三, '5', 周四, '6', 周五, '7', 周六, Null)
        Into v_时间段
        From 挂号安排计划
        Where ID = r_安排.计划id;
      End If;
    Exception
      When Others Then
        n_启用分时段 := 0;
    End;
  
    If v_时间段 Is Not Null And d_启用时间 Is Not Null Then
      --检查是否跨模式挂号安排
      Select To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'),
             To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(终止时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss')
      Into d_检查开始时间, d_检查结束时间
      From 时间段
      Where 时间段 = v_时间段 And 站点 Is Null And 号类 Is Null;
      If d_检查开始时间 > d_检查结束时间 Then
        d_检查结束时间 := d_检查结束时间 + 1;
      End If;
      If d_检查结束时间 > d_启用时间 Then
        --获取出诊记录id
        Begin
          Select a.Id
          Into n_出诊记录id
          From 临床出诊记录 A, 临床出诊号源 B
          Where a.号源id = b.Id And b.号码 = 号码_In And 上班时段 = v_时间段 And 发生时间_In Between 开始时间 And 终止时间;
        Exception
          When Others Then
            n_出诊记录id := Null;
        End;
      End If;
    End If;
  
    --对参数控制进行检查
    --仅在预约不扣款时进行检查
    If 操作方式_In = 2 Then
      If Nvl(n_同科限约数, 0) <> 0 Or Nvl(n_病人预约科室数, 0) <> 0 Then
        n_已约科室 := 0;
        For c_Chkitem In (Select Distinct 执行部门id
                          From 病人挂号记录
                          Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 2 And 预约时间 Between Trunc(发生时间_In) And
                                Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id <> r_安排.科室id) Loop
          n_已约科室 := n_已约科室 + 1;
        End Loop;
        If n_已约科室 >= Nvl(n_病人预约科室数, 0) And Nvl(n_病人预约科室数, 0) > 0 Then
          v_Err_Msg := '同一病人最多同时能预约[' || Nvl(n_病人预约科室数, 0) || ']个科室,不能再预约！';
          Raise Err_Item;
        End If;
      
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 2 And 预约时间 Between Trunc(发生时间_In) And
              Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id = r_安排.科室id;
        If n_Count >= Nvl(n_同科限约数, 0) And Nvl(n_同科限约数, 0) > 0 Then
          v_Err_Msg := '该病人已经在该科室预约了' || n_Count || '次,不能再预约！';
          Raise Err_Item;
        End If;
      End If;
      If Nvl(n_专家号预约限制, 0) <> 0 Then
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 2 And 预约时间 Between Trunc(发生时间_In) And
              Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 号别 = r_安排.号码;
        If n_Count >= Nvl(n_专家号预约限制, 0) And Nvl(n_专家号预约限制, 0) > 0 Then
          v_Err_Msg := '该病人已经超过本号预约限制,不能再预约！';
          Raise Err_Item;
        End If;
      End If;
    Else
      If Nvl(n_同科限号数, 0) <> 0 Or Nvl(n_病人挂号科室数, 0) <> 0 Then
        n_已约科室 := 0;
        For c_Chkitem In (Select Distinct 执行部门id
                          From 病人挂号记录
                          Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 1 And 发生时间 Between Trunc(发生时间_In) And
                                Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id <> r_安排.科室id) Loop
          n_已约科室 := n_已约科室 + 1;
        End Loop;
        If n_已约科室 >= Nvl(n_病人挂号科室数, 0) And Nvl(n_病人挂号科室数, 0) > 0 Then
          v_Err_Msg := '同一病人最多同时能挂号[' || Nvl(n_病人挂号科室数, 0) || ']个科室,不能再挂号！';
          Raise Err_Item;
        End If;
      
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 1 And 发生时间 Between Trunc(发生时间_In) And
              Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id = r_安排.科室id;
        If n_Count >= Nvl(n_同科限号数, 0) And Nvl(n_同科限号数, 0) > 0 Then
          v_Err_Msg := '该病人已经在该科室挂号了' || n_Count || '次,不能再挂号！';
          Raise Err_Item;
        End If;
      End If;
      If Nvl(n_专家号挂号限制, 0) <> 0 Then
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 1 And 预约时间 Between Trunc(发生时间_In) And
              Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 号别 = r_安排.号码;
        If n_Count >= Nvl(n_专家号挂号限制, 0) And Nvl(n_专家号挂号限制, 0) > 0 Then
          v_Err_Msg := '该病人已经超过本号挂号限制,不能再挂号！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  
    d_Date         := Null;
    d_时段开始时间 := Null;
  
    If Nvl(r_安排.限号数, 0) >= 0 Or r_安排.限号数 Is Null Then
    
      Select Nvl(Sum(Nvl(b.已挂数, 0)), 0), Nvl(Sum(Nvl(b.其中已接收, 0)), 0), Nvl(Sum(Nvl(b.已约数, 0)), 0)
      Into n_已挂数, n_其中已接收, n_已约数
      From 挂号安排 A, 病人挂号汇总 B
      Where a.科室id = b.科室id And a.项目id = b.项目id And a.号码 = 号码_In And b.日期 Between Trunc(发生时间_In) And
            Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And (a.号码 = b.号码 Or b.号码 Is Null) And Nvl(a.医生id, 0) = Nvl(b.医生id, 0) And
            Nvl(a.医生姓名, '医生') = Nvl(b.医生姓名, '医生');
    
      If n_启用分时段 = 1 Then
        If Nvl(r_安排.序号控制, 0) = 1 Then
          If Nvl(是否自助设备_In, 0) = 0 Then
            If r_安排.计划id Is Null Then
              Select Count(*), Max(开始时间)
              Into n_Count, d_时段开始时间
              From 挂号安排时段
              Where 安排id = r_安排.Id And 星期 = v_星期 And 序号 = Nvl(号序_In, 0);
            Else
              Select Count(*), Max(开始时间)
              Into n_Count, d_时段开始时间
              From 挂号计划时段
              Where 计划id = r_安排.计划id And 星期 = v_星期 And 序号 = Nvl(号序_In, 0);
            End If;
            v_Temp := '挂号';
            If 操作方式_In > 1 Then
              v_Temp := '预约挂号';
            End If;
          
            If n_Count = 0 Then
              v_Err_Msg := '号别为' || 号码_In || '的挂号安排中不存在序号为' || Nvl(号序_In, 0) || '的安排,不能再' || v_Temp || '！';
              Raise Err_Item;
            End If;
          End If;
          --过点的,不能选择挂号
          If Trunc(Sysdate) = Trunc(发生时间_In) Then
            --挂当天的号
            v_Temp := To_Char(Sysdate, 'yyyy-mm-dd') || ' ';
            If r_安排.计划id Is Null Then
              For v_时段 In (Select To_Date(v_Temp || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                  To_Date(To_Char(Sysdate + Decode(Sign(开始时间 - 结束时间), 1, 1, 0), 'yyyy-mm-dd') || ' ' ||
                                           To_Char(结束时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 结束时间, 限制数量, 是否预约
                           From 挂号安排时段
                           Where 安排id = r_安排.Id And 星期 = v_星期 And 序号 = Nvl(号序_In, 0)) Loop
                If Sysdate > v_时段.结束时间 Then
                  v_Err_Msg := '号别为' || 号码_In || '及号序为' || Nvl(号序_In, 0) || '的安排,已经超过时点,不能再' || v_Temp || '！';
                  Raise Err_Item;
                End If;
              End Loop;
            Else
              For v_时段 In (Select To_Date(v_Temp || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                  To_Date(To_Char(Sysdate + Decode(Sign(开始时间 - 结束时间), 1, 1, 0), 'yyyy-mm-dd') || ' ' ||
                                           To_Char(结束时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 结束时间, 限制数量, 是否预约
                           From 挂号计划时段
                           Where 计划id = r_安排.计划id And 星期 = v_星期 And 序号 = Nvl(号序_In, 0)) Loop
                If Sysdate > v_时段.结束时间 Then
                  v_Err_Msg := '号别为' || 号码_In || '及号序为' || Nvl(号序_In, 0) || '的安排,已经超过时点,不能再' || v_Temp || '！';
                  Raise Err_Item;
                End If;
              End Loop;
            End If;
          End If;
        Elsif 操作方式_In > 1 Then
          --未启用序号的,需要检查预约的情况
          n_Count := 0;
          If r_安排.计划id Is Null Then
            For v_时段 In (Select 序号, 开始时间, 结束时间, 限制数量, 是否预约
                         From 挂号安排时段
                         Where 安排id = r_安排.Id And 星期 = v_星期 And
                               (('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                               Decode(Sign(开始时间 - 结束时间 - 1 / 24 / 60 / 60), 1,
                                        '3000-01-09 ' || To_Char(开始时间, 'HH24:MI:SS'),
                                        '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS')) And
                               '3000-01-10 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS')) Or
                               ('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                               '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS') And
                               Decode(Sign(开始时间 - 结束时间 - 1 / 24 / 60 / 60), 1,
                                        '3000-01-11 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'),
                                        '3000-01-10 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'))))) Loop
              n_预约时段序号 := v_时段.序号;
              d_时段开始时间 := v_时段.开始时间;
            
              Select Count(*), Max(序号)
              Into n_Count, n_预约总数
              From 挂号序号状态
              Where 号码 = 号码_In And 日期 = 发生时间_In And 状态 Not In (4, 5);
            
              If Nvl(n_Count, 0) > Nvl(v_时段.限制数量, 0) And 锁定类型_In <> 2 Then
                v_Err_Msg := '号别为' || 号码_In || '的挂号安排中在' || To_Char(v_时段.开始时间, 'hh24:mi:ss') || '至' ||
                             To_Char(v_时段.结束时间, 'hh24:mi:ss') || '最多只能预约' || Nvl(v_时段.限制数量, 0) || '人,不能再进行预约挂号！';
                Raise Err_Item;
              End If;
              n_Count := 1;
            End Loop;
          Else
            For v_时段 In (Select 序号, 开始时间, 结束时间, 限制数量, 是否预约
                         From 挂号计划时段
                         Where 计划id = r_安排.计划id And 星期 = v_星期 And
                               (('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                               Decode(Sign(开始时间 - 结束时间 - 1 / 24 / 60 / 60), 1,
                                        '3000-01-09 ' || To_Char(开始时间, 'HH24:MI:SS'),
                                        '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS')) And
                               '3000-01-10 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS')) Or
                               ('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                               '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS') And
                               Decode(Sign(开始时间 - 结束时间 - 1 / 24 / 60 / 60), 1,
                                        '3000-01-11 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'),
                                        '3000-01-10 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'))))) Loop
              n_预约时段序号 := v_时段.序号;
              d_时段开始时间 := v_时段.开始时间;
            
              Select Count(*), Max(序号)
              Into n_Count, n_预约总数
              From 挂号序号状态
              Where 号码 = 号码_In And 日期 = 发生时间_In And 状态 Not In (4, 5);
            
              If Nvl(n_Count, 0) > Nvl(v_时段.限制数量, 0) And 锁定类型_In <> 2 Then
                v_Err_Msg := '号别为' || 号码_In || '的挂号安排中在' || To_Char(v_时段.开始时间, 'hh24:mi:ss') || '至' ||
                             To_Char(v_时段.结束时间, 'hh24:mi:ss') || '最多只能预约' || Nvl(v_时段.限制数量, 0) || '人,不能再进行预约挂号！';
                Raise Err_Item;
              End If;
              n_Count := 1;
            End Loop;
          End If;
        
          If n_Count = 0 Then
            v_Err_Msg := '号别为' || 号码_In || '的挂号安排中没有相关的安排计划(' || To_Char(发生时间_In, 'YYYY-mm-dd HH24:MI:SS') ||
                         '),不能进行预约挂号！';
            Raise Err_Item;
          End If;
        End If;
      End If;
    End If;
  
    If 操作方式_In = 1 And 锁定类型_In <> 2 Then
      --挂号规则:
      --  已挂数不能大于限号数
      If n_已挂数 >= Nvl(r_安排.限号数, 0) And r_安排.限号数 Is Not Null Then
        v_Err_Msg := '该号别今天已达到限号数 ' || Nvl(r_安排.限号数, 0) || '不能再挂号！';
        Raise Err_Item;
      End If;
    End If;
  
    If 操作方式_In > 1 Then
      --预约的相关检查
      --规则:
      --   1.已限约不能超过限约数
      --   2.检查是否启用时段的
      If n_已约数 >= Nvl(r_安排.限约数, 0) And Nvl(r_安排.限约数, 0) <> 0 And r_安排.限约数 Is Not Null And 锁定类型_In <> 2 Then
        v_Err_Msg := '该号别已达到限约数 ' || Nvl(r_安排.限约数, 0) || '不能再预约挂号！';
        Raise Err_Item;
      End If;
    End If;
    If n_合作单位限制 > 0 And 操作方式_In <> 1 And 合作单位_In Is Not Null Then
    
      If Nvl(r_安排.序号控制, 0) = 1 And Nvl(号序_In, 0) = 0 Then
        v_Err_Msg := '当前安排使用了序号控制,请确认所需要预约的序号,不能继续。';
        Raise Err_Item;
      End If; --Nvl(r_安排.序号控制, 0) =0
    
      n_序号 := Case
                When Nvl(r_安排.序号控制, 0) = 1 Or n_启用分时段 = 1 And 操作方式_In > 1 Then
                 Nvl(号序_In, 0)
                Else
                 0
              End;
    
      --合作单位限数量模式
      Begin
        If Nvl(n_计划id, 0) <> 0 Then
          Select 0
          Into n_序号
          From 合作单位计划控制
          Where 合作单位 = 合作单位_In And 计划id = n_计划id And
                限制项目 = Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                              '7', '周六', Null) And 数量 <> 0 And 序号 = 0 And Rownum < 2;
        Else
          Select 0
          Into n_序号
          From 合作单位安排控制
          Where 合作单位 = 合作单位_In And 安排id = n_Tmp安排id And
                限制项目 = Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                              '7', '周六', Null) And 数量 <> 0 And 序号 = 0 And Rownum < 2;
        End If;
        n_合作单位限数量模式 := 1;
      Exception
        When Others Then
          n_合作单位限数量模式 := 0;
      End;
      --开放序号检查
      For c_合作单位 In (Select c.序号, 数量
                     From 挂号安排 A, 合作单位安排控制 C
                     Where a.号码 = 号码_In And Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                   '周四', '6', '周五', '7', '周六', Null) = c.限制项目(+) And a.Id = c.安排id And
                           c.合作单位 = 合作单位_In And c.序号 = n_序号 And Not Exists
                      (Select 1
                            From 挂号安排计划 D
                            Where d.安排id = a.Id And d.审核时间 Is Not Null And
                                  发生时间_In Between Nvl(d.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                                  Nvl(d.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')))
                     Union All
                     Select c.序号, 数量
                     From 挂号安排计划 A, 挂号安排 D, 合作单位计划控制 C,
                          (Select Max(a.生效时间) As 生效, 安排id
                            From 挂号安排计划 A, 挂号安排 B
                            Where a.安排id = b.Id And a.审核时间 Is Not Null And
                                  发生时间_In Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                                  Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) And b.号码 = 号码_In
                            Group By 安排id) E
                     Where a.安排id = d.Id And a.审核时间 Is Not Null And d.号码 = 号码_In And a.安排id = e.安排id And
                           Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) =
                           Nvl(e.生效, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                           Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) = c.限制项目(+) And a.Id = c.计划id And c.合作单位 = 合作单位_In And c.序号 = n_序号 And
                           发生时间_In Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                           Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd'))) Loop
      
        If Nvl(r_安排.序号控制, 0) = 1 And c_合作单位.序号 = n_序号 And n_合作单位限数量模式 = 0 Then
          n_是否开放 := 1;
          Exit;
        Elsif (Nvl(r_安排.序号控制, 0) = 0 And c_合作单位.序号 = n_序号) Or n_合作单位限数量模式 = 1 Then
          Begin
            Select Nvl(已约数, 0)
            Into n_预约数量
            From 合作单位挂号汇总
            Where 合作单位 = 合作单位_In And 日期 = Trunc(发生时间_In) And 号码 = 号码_In;
          Exception
            When Others Then
              n_预约数量 := 0;
          End;
          If c_合作单位.数量 <= n_预约数量 And Nvl(c_合作单位.数量, 0) > 0 And 锁定类型_In <> 2 Then
            v_Err_Msg := '该号别已达到限约数 ' || Nvl(c_合作单位.数量, 0) || '不能再预约挂号！';
            Raise Err_Item;
          End If;
          n_是否开放 := 1;
          Exit;
        End If;
      
      End Loop;
    
      If Nvl(n_是否开放, 0) = 0 Then
        v_Err_Msg := '当前序号(' || Nvl(号序_In, 0) || '未开放,不能继续。';
        Raise Err_Item;
      End If;
    End If;
  
    --检查限号数和限约数
    n_行号         := 1;
    n_原项目id     := 0;
    n_原收入项目id := 0;
    n_实收金额合计 := 0;
    If 锁定类型_In <> 1 Then
      If 操作方式_In <> 2 Then
        If Nvl(结帐id_In, 0) = 0 Then
          --这里应该程序传入
          Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
        Else
          n_结帐id := 结帐id_In;
        End If;
      Else
        n_结帐id := Null;
      End If;
    End If;
  
    If Nvl(购买病历_In, 0) = 1 Then
      Begin
        Select 收费细目id Into n_病历费id From 收费特定项目 Where 特定项目 = '病历费';
        v_收费项目ids := r_安排.项目id || ',' || n_病历费id;
      Exception
        When Others Then
          v_Err_Msg := '不能确定病历费,挂号失败!';
          Raise Err_Item;
      End;
    Else
      v_收费项目ids := r_安排.项目id;
    End If;
  
    For c_Item In (Select 1 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, Null As 从属父号,
                          Nvl(a.项目特性, 0) As 急诊
                   From 收费项目目录 A, 收费价目 B, 收入项目 C
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = r_安排.项目id And Sysdate Between b.执行日期 And
                         Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And
                         (b.价格等级 = v_普通等级 Or
                         (b.价格等级 Is Null And Not Exists
                          (Select 1
                            From 收费价目
                            Where b.收费细目id = 收费细目id And 价格等级 = v_普通等级 And Sysdate Between 执行日期 And
                                  Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')))))
                   Union All
                   Select 2 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, Null As 从属父号, 0 As 急诊
                   From 收费项目目录 A, 收费价目 B, 收入项目 C
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = n_病历费id And Sysdate Between b.执行日期 And
                         Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And
                         (b.价格等级 = v_普通等级 Or
                         (b.价格等级 Is Null And Not Exists
                          (Select 1
                            From 收费价目
                            Where b.收费细目id = 收费细目id And 价格等级 = v_普通等级 And Sysdate Between 执行日期 And
                                  Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')))))
                   Union All
                   Select 3 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, d.从项数次 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, 1 As 从属父号, 0 As 急诊
                   From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费从属项目 D
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = d.从项id And
                         d.主项id In (Select Column_Value From Table(f_Str2list(v_收费项目ids))) And Sysdate Between b.执行日期 And
                         Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And
                         (b.价格等级 = v_普通等级 Or
                         (b.价格等级 Is Null And Not Exists
                          (Select 1
                            From 收费价目
                            Where b.收费细目id = 收费细目id And 价格等级 = v_普通等级 And Sysdate Between 执行日期 And
                                  Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')))))
                   Order By 性质, 项目编码, 收入编码) Loop
      If c_Item.性质 = 1 Then
        n_急诊 := Nvl(c_Item.急诊, 0);
      End If;
      n_价格父号 := Null;
      If n_原项目id = c_Item.项目id Then
        If n_原收入项目id <> c_Item.收入项目id Then
          n_价格父号 := n_行号;
        End If;
        n_原收入项目id := c_Item.收入项目id;
      End If;
      n_原项目id := c_Item.项目id;
      n_应收金额 := Round(c_Item.数次 * c_Item.单价, 5);
      n_实收金额 := n_应收金额;
      If Nvl(c_Item.屏蔽费别, 0) <> 1 And n_屏蔽费别 = 0 Then
        --打折:
        v_Temp     := Zl_Actualmoney(r_Pati.费别, c_Item.项目id, c_Item.收入项目id, n_应收金额);
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ':') + 1);
        n_实收金额 := Zl_To_Number(v_Temp);
      End If;
      n_实收金额合计 := Nvl(n_实收金额合计, 0) + n_实收金额;
    
      --锁定单据不产生费用
      If 锁定类型_In <> 1 Then
        --产生病人挂号费用(可能单独是或包括病历费用)
        Select 病人费用记录_Id.Nextval Into n_费用id From Dual;
        --:操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
        Insert Into 门诊费用记录
          (ID, 记录性质, 记录状态, 序号, 价格父号, 从属父号, NO, 实际票号, 门诊标志, 加班标志, 附加标志, 发药窗口, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 病人科室id,
           收费类别, 计算单位, 收费细目id, 收入项目id, 收据费目, 付数, 数次, 标准单价, 应收金额, 实收金额, 结帐金额, 结帐id, 记帐费用, 开单部门id, 开单人, 划价人, 执行部门id, 执行人,
           操作员编号, 操作员姓名, 发生时间, 登记时间, 保险大类id, 保险项目否, 保险编码, 统筹金额, 摘要, 结论, 缴款组id)
        Values
          (n_费用id, 4, Decode(操作方式_In, 2, 0, 1), n_行号, n_价格父号, c_Item.从属父号, 单据号_In, 票据号_In, 1, n_急诊, Null,
           Decode(操作方式_In, 2, To_Char(号序_In), v_诊室), r_Pati.病人id, r_Pati.门诊号, r_Pati.付款方式, r_Pati.姓名, r_Pati.性别,
           r_Pati.年龄, r_Pati.费别, r_安排.科室id, c_Item.类别, 号码_In, c_Item.项目id, c_Item.收入项目id, c_Item.收据费目, 1, c_Item.数次,
           c_Item.单价, n_应收金额, n_实收金额, Decode(操作方式_In, 2, Null, Decode(Nvl(记帐费用_In, 0), 1, Null, n_实收金额)),
           Decode(Nvl(记帐费用_In, 0), 1, Null, n_结帐id), Decode(Nvl(记帐费用_In, 0), 1, 1, 0), n_开单部门id, v_操作员姓名,
           Decode(操作方式_In, 2, v_操作员姓名, Null), r_安排.科室id, r_安排.医生姓名, v_操作员编号, v_操作员姓名, 发生时间_In, d_登记时间, Null, 0, Null,
           Null, 摘要_In, 预约方式_In, Decode(操作方式_In, 2, Null, n_组id));
      End If;
      n_行号 := n_行号 + 1;
    
    End Loop;
  
    If Round(Nvl(挂号金额合计_In, 0), 5) <> Round(Nvl(n_实收金额合计, 0), 5) Then
      v_Err_Msg := '本次挂号金额不正确,可能是因为医院调整了价格,请重新获取挂号收费项目的价格,不能继续。';
      Raise Err_Item;
    End If;
  
    If n_启用分时段 = 1 Then
      d_Date := To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(d_时段开始时间, 'hh24:mi:ss'),
                        'yyyy-mm-dd hh24:mi:ss');
    Else
      d_Date := Trunc(发生时间_In);
    End If;
  
    --更新挂号序号状态
    If 锁定类型_In <> 2 Then
      n_号序 := 号序_In;
    End If;
    Begin
      Select 1
      Into n_Count
      From 挂号序号状态
      Where Trunc(日期) = Trunc(发生时间_In) And 号码 = 号码_In And 序号 = n_号序 And 状态 <> 5;
    Exception
      When Others Then
        n_Count := 0;
    End;
    If n_Count = 1 Then
      If n_启用分时段 = 0 And Nvl(r_安排.序号控制, 0) = 1 Then
        n_号序 := Null;
      End If;
      If n_启用分时段 = 1 And Nvl(r_安排.序号控制, 0) = 1 Then
        v_Err_Msg := '当前序号已被使用，请重新选择一个序号！';
        Raise Err_Item;
      End If;
    End If;
    n_Count := 0;
    If n_启用分时段 = 0 And Nvl(r_安排.序号控制, 0) = 1 And n_号序 Is Null And 锁定类型_In <> 2 Then
      If 退号重用_In = 1 Then
        Select Nvl(Max(序号), 0) + 1
        Into n_号序
        From 挂号序号状态
        Where 日期 = Trunc(发生时间_In) And 号码 = r_安排.号码 And 状态 Not In (4, 5);
      Else
        Select Nvl(Max(序号), 0) + 1
        Into n_号序
        From 挂号序号状态
        Where 日期 = Trunc(发生时间_In) And 号码 = r_安排.号码 And 状态 <> 5;
      End If;
    End If;
    If n_启用分时段 = 1 And 锁定类型_In <> 2 Then
    
      If 操作方式_In > 1 And Nvl(r_安排.序号控制, 0) = 0 Then
        --规则:预约时段序号||预约数
        If Nvl(n_预约总数, 0) = 0 Then
          v_Temp := Nvl(r_安排.限约数, 0);
          v_Temp := LTrim(RTrim(v_Temp));
          v_Temp := LPad(Nvl(n_预约总数, 0) + 1, Length(v_Temp), '0');
          v_Temp := n_预约时段序号 || v_Temp;
          n_号序 := To_Number(v_Temp);
        Else
          n_号序 := n_预约总数 + 1;
        End If;
      End If;
    End If;
  
    If Nvl(r_安排.序号控制, 0) = 1 Or (操作方式_In > 1 And n_启用分时段 = 1) Or 加入序号状态_In = 1 Then
      --锁定序号的处理
      Begin
        Select 操作员姓名, 机器名
        Into v_序号操作员, v_序号机器名
        From 挂号序号状态
        Where 状态 = 5 And 号码 = 号码_In And Trunc(日期) = Trunc(d_Date) And 序号 = n_号序;
        n_序号锁定 := 1;
      Exception
        When Others Then
          v_序号操作员 := Null;
          v_序号机器名 := Null;
          n_序号锁定   := 0;
      End;
      If n_序号锁定 = 0 Then
        Update 挂号序号状态
        Set 状态 = Decode(操作方式_In, 2, 2, 1), 预约 = Decode(操作方式_In, 1, 0, 1), 登记时间 = Sysdate
        Where 号码 = 号码_In And 日期 = d_Date And 序号 = n_号序 And 操作员姓名 = v_操作员姓名;
        If Sql%RowCount = 0 Then
          Begin
            Insert Into 挂号序号状态
              (号码, 日期, 序号, 状态, 操作员姓名, 预约, 登记时间)
            Values
              (号码_In, d_Date, n_号序, Decode(操作方式_In, 2, 2, 1), v_操作员姓名, Decode(操作方式_In, 1, 0, 1), Sysdate);
          
            If n_合作单位限制 > 0 And 操作方式_In > 1 And Nvl(n_是否开放, 0) = 1 Then
              Update 合作单位挂号汇总
              Set 已约数 = 已约数 + Decode(操作方式_In, 2, 1, 0), 已接数 = 已接数 + Decode(操作方式_In, 3, 1, 0)
              Where 号码 = 号码_In And 日期 = d_Date And 序号 = n_号序 And 合作单位 = 合作单位_In;
              If Sql%NotFound Then
                Insert Into 合作单位挂号汇总
                  (号码, 日期, 序号, 合作单位, 已约数, 已接数)
                Values
                  (号码_In, d_Date, n_号序, 合作单位_In, Decode(操作方式_In, 1, 0, 1), Decode(操作方式_In, 3, 1, 0));
              End If;
            End If;
          Exception
            When Others Then
              v_Err_Msg := '序号' || n_号序 || '已被使用,请重新选择一个序号.';
              Raise Err_Item;
          End;
        End If;
      Else
        If v_操作员姓名 <> v_序号操作员 Or v_机器名 <> v_序号机器名 Then
          v_Err_Msg := '序号' || n_号序 || '已被自助机' || v_机器名 || '锁定,请重新选择一个序号.';
          Raise Err_Item;
        Else
          Update 挂号序号状态
          Set 状态 = Decode(操作方式_In, 2, 2, 1), 预约 = Decode(操作方式_In, 1, 0, 1), 登记时间 = Sysdate
          Where 号码 = 号码_In And Trunc(日期) = Trunc(d_Date) And 序号 = n_号序 And 状态 = 5 And 操作员姓名 = v_操作员姓名 And 机器名 = v_机器名;
        End If;
      End If;
    End If;
  
    If n_出诊记录id Is Not Null Then
      Update 临床出诊序号控制
      Set 挂号状态 = Decode(操作方式_In, 2, 2, 1), 操作员姓名 = v_操作员姓名
      Where 记录id = n_出诊记录id And 序号 = n_序号;
      If 操作方式_In = 2 Then
        Update 临床出诊记录 Set 已约数 = 已约数 + 1 Where ID = n_出诊记录id;
      Else
        If 操作方式_In <> 1 Then
          Update 临床出诊记录
          Set 已约数 = 已约数 + 1, 已挂数 = 已挂数 + 1, 其中已接收 = 其中已接收 + 1
          Where ID = n_出诊记录id;
        Else
          Update 临床出诊记录 Set 已挂数 = 已挂数 + 1 Where ID = n_出诊记录id;
        End If;
      End If;
    End If;
  
    --锁定单据不产生任何 费用
    If 操作方式_In <> 2 And 锁定类型_In <> 1 And Nvl(记帐费用_In, 0) = 0 Then
      --挂号,预约挂号已经扣款部分
      n_预交id := 预交id_In;
      If Nvl(n_预交id, 0) = 0 Then
        Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      End If;
      n_结算合计 := 0;
      If 保险结算_In Is Not Null Then
        --各个保险结算
        v_结算内容 := 保险结算_In || '||';
        n_结算合计 := 0;
        While v_结算内容 Is Not Null Loop
          v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
          v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
          n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
          If Nvl(n_结算金额, 0) <> 0 Then
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 记录状态, 病人id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算性质)
            Values
              (n_预交id, 4, 单据号_In, 1, Decode(病人id_In, 0, Null, 病人id_In), '保险结算', v_结算方式, d_登记时间, v_操作员编号, v_操作员姓名,
               n_结算金额, n_结帐id, n_组id, n_结帐id, 4);
            Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          End If;
          n_结算合计 := Nvl(n_结算合计, 0) + Nvl(n_结算金额, 0);
          v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
        End Loop;
      End If;
    
      If Nvl(冲预交_In, 0) <> 0 Then
        --处理总预交
        n_结算合计 := n_结算合计 + Nvl(冲预交_In, 0);
        n_预交金额 := 冲预交_In;
        For r_Deposit In c_Deposit(病人id_In, v_冲预交病人ids) Loop
          n_结算金额 := Case
                      When r_Deposit.金额 - n_预交金额 < 0 Then
                       r_Deposit.金额
                      Else
                       n_预交金额
                    End;
          If r_Deposit.结帐id = 0 Then
            --第一次冲预交(填上结帐ID,金额为0)
            Update 病人预交记录 Set 冲预交 = 0, 结帐id = n_结帐id, 结算性质 = 4 Where ID = r_Deposit.原预交id;
          End If;
          --冲上次剩余额
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 预交类别, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名,
             操作员编号, 冲预交, 结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 预交类别, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行,
                   单位帐号, d_登记时间, v_操作员姓名, v_操作员编号, n_结算金额, n_结帐id, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, n_结帐id, 4
            From 病人预交记录
            Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
        
          --更新病人预交余额
          Update 病人余额
          Set 预交余额 = Nvl(预交余额, 0) - n_结算金额
          Where 病人id = r_Deposit.病人id And 性质 = 1 And 类型 = Nvl(1, 2)
          Returning 预交余额 Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 病人余额 (病人id, 预交余额, 性质, 类型) Values (r_Deposit.病人id, -1 * n_结算金额, 1, 1);
            n_返回值 := -1 * n_结算金额;
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 病人余额
            Where 病人id = r_Deposit.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
          End If;
        
          --检查是否已经处理完
          If r_Deposit.金额 <= n_结算金额 Then
            n_预交金额 := n_预交金额 - r_Deposit.金额;
          Else
            n_预交金额 := 0;
          End If;
          If n_预交金额 = 0 Then
            Exit;
          End If;
        End Loop;
        If n_预交金额 > 0 Then
          v_Err_Msg := '预交余额不够支付本次支付金额,不能继续操作！';
          Raise Err_Item;
        End If;
      End If;
      --剩余款项,用指定结算方支付
      n_结算金额 := Nvl(n_实收金额合计, 0) - Nvl(n_结算合计, 0);
      If Nvl(n_结算金额, 0) < 0 Then
        v_Err_Msg := '挂号的相关结算金额超出了当前实结金额,不能继续操作！';
        Raise Err_Item;
      End If;
      If Nvl(n_结算金额, 0) <> 0 Or (Nvl(n_结算金额, 0) = 0 And Nvl(冲预交_In, 0) = 0) Then
        If 结算方式_In Is Null Then
          v_Err_Msg := '未传入指定的结算方式,不能继续操作！';
          Raise Err_Item;
        End If;
      
        If Nvl(预交id_In, 0) <> 0 Then
          --传入的预交ID_In主要是为了解决三方交易,如果医保结算站用了该ID,需要用新的ID进行更新,三方交易用转入的ID
          Update 病人预交记录 Set ID = n_预交id Where ID = Nvl(预交id_In, 0);
          n_预交id := Nvl(预交id_In, 0);
        End If;
      
        Insert Into 病人预交记录
          (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 交易流水号, 交易说明, 结算序号, 合作单位, 卡类别id, 卡号,
           结算性质)
        Values
          (n_预交id, 4, 1, 单据号_In, r_Pati.病人id, 结算方式_In, Nvl(n_结算金额, 0), d_登记时间, v_操作员编号, v_操作员姓名, n_结帐id,
           合作单位_In || '缴款', n_组id, 交易流水号_In, 交易说明_In, n_结帐id, 合作单位_In, 卡类别id_In, 支付卡号_In, 4);
      End If;
    
      --更新人员缴款数据
    
      For v_缴款 In (Select 结算方式, Sum(Nvl(a.冲预交, 0)) As 冲预交
                   From 病人预交记录 A
                   Where a.结帐id = n_结帐id And Mod(a.记录性质, 10) <> 1 And Nvl(病人id, 0) = Nvl(病人id_In, 0)
                   Group By 结算方式) Loop
      
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + Nvl(v_缴款.冲预交, 0)
        Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = v_缴款.结算方式
        Returning 余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (v_操作员姓名, v_缴款.结算方式, 1, Nvl(v_缴款.冲预交, 0));
          n_返回值 := Nvl(v_缴款.冲预交, 0);
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = v_操作员姓名 And 结算方式 = 结算方式_In And 性质 = 1 And Nvl(余额, 0) = 0;
        End If;
      
      End Loop;
    
    End If;
  
    --处理挂号记录
    If 锁定类型_In = 2 Then
      Begin
        Select ID Into n_挂号id From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
      Exception
        When Others Then
          Null;
      End;
    Else
      Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
    End If;
  
    Update 病人挂号记录
    Set 记录性质 = Decode(操作方式_In, 2, 2, 1), 记录状态 = Decode(锁定类型_In, 1, 0, 1), 门诊号 = r_Pati.门诊号, 操作员姓名 = v_操作员姓名,
        操作员编号 = v_操作员编号, 预约 = Decode(操作方式_In, 1, 0, 1),
        接收人 = Decode(锁定类型_In, 1, Null, Decode(操作方式_In, 2, Null, v_操作员姓名)),
        接收时间 = Case 锁定类型_In
                  When 1 Then
                   Null
                  Else
                   Case 操作方式_In
                     When 2 Then
                      Null
                     Else
                      d_登记时间
                   End
                End, 交易流水号 = Nvl(交易流水号_In, 交易流水号), 交易说明 = Nvl(交易说明_In, 交易说明), 合作单位 = Nvl(合作单位_In, 合作单位),
        预约操作员 = Decode(操作方式_In, 1, Nvl(预约操作员, Null), Nvl(预约操作员, v_操作员姓名)),
        预约操作员编号 = Decode(操作方式_In, 1, Nvl(预约操作员编号, Null), Nvl(预约操作员编号, v_操作员编号))
    Where ID = n_挂号id;
    If Sql%NotFound Then
      Begin
        Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = r_Pati.付款方式 And Rownum < 2;
      Exception
        When Others Then
          v_付款方式 := Null;
      End;
      Insert Into 病人挂号记录
        (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 预约时间, 操作员编号,
         操作员姓名, 复诊, 号序, 预约, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 医疗付款方式, 预约操作员, 预约操作员编号)
      Values
        (n_挂号id, 单据号_In, Decode(操作方式_In, 2, 2, 1), Decode(锁定类型_In, 1, 0, 1), r_Pati.病人id, r_Pati.门诊号, r_Pati.姓名,
         r_Pati.性别, r_Pati.年龄, 号码_In, n_急诊, v_诊室, Null, r_安排.科室id, r_安排.医生姓名, 0, Null, d_登记时间, 发生时间_In,
         Case When(Nvl(操作方式_In, 0)) = 1 Then Null Else 发生时间_In End, v_操作员编号, v_操作员姓名, 0, n_号序, Decode(操作方式_In, 1, 0, 1),
         Decode(操作方式_In, 2, Null, v_操作员姓名), Decode(操作方式_In, 2, To_Date(Null), d_登记时间), 交易流水号_In, 交易说明_In, 合作单位_In,
         v_付款方式, Decode(操作方式_In, 1, Null, v_操作员姓名), Decode(操作方式_In, 1, Null, v_操作员编号));
    End If;
    --锁定单据不能产生队列
    If 锁定类型_In <> 1 Then
      n_预约生成队列 := 0;
      If 操作方式_In > 1 Then
        n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
      End If;
      --挂号和收费的预约都直接进入队列(收费预约缺少接收过程,所以直接和挂号一样直接进入队列)
      If 操作方式_In <> 2 Or n_预约生成队列 = 1 Then
        If Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113)) <> 0 Then
          --排队叫号模式:-0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站
          If Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113)) = 0 Or n_预约生成队列 = 1 Then
            n_分时点显示 := Nvl(Zl_To_Number(zl_GetSysParameter(270)), 0);
            If Nvl(操作方式_In, 0) > 1 And n_分时点显示 = 1 And n_启用分时段 = 1 Then
              n_分时点显示 := 1;
            Else
              n_分时点显示 := Null;
            End If;
            --产生队列
            --.按”执行部门” 的方式生成队列
            v_队列名称 := r_安排.科室id;
            v_排队号码 := Zlgetnextqueue(r_安排.科室id, n_挂号id, 号码_In || '|' || 号序_In);
            --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)
            v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
            --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)
            d_排队时间 := Zl_Get_Queuedate(n_挂号id, 号码_In, 号序_In, d_Date);
            --  队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,v_排队标记,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In, 排队时间_In
            Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, r_安排.科室id, v_排队号码, Null, r_Pati.姓名, r_Pati.病人id, v_诊室, r_安排.医生姓名,
                             d_排队时间, 预约方式_In, n_分时点显示, v_排队序号);
          End If;
        End If;
      End If;
    
      If Nvl(操作方式_In, 0) = 1 Then
        --处理票据使用情况
        If 票据号_In Is Not Null Then
          Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
          --发出票据
          Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 4, 单据号_In);
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
          Values
            (票据使用明细_Id.Nextval, Decode(收费票据_In, 1, 1, 4), 票据号_In, 1, 1, 领用id_In, n_打印id, d_登记时间, v_操作员姓名);
          --状态改动
          Update 票据领用记录
          Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
          Where ID = Nvl(领用id_In, 0);
        End If;
        --病人本次就诊(以发生时间为准)
        If Nvl(r_Pati.病人id, 0) <> 0 Then
          Update 病人信息 Set 就诊时间 = 发生时间_In, 就诊状态 = 1, 就诊诊室 = v_诊室 Where 病人id = r_Pati.病人id;
        End If;
      End If;
    End If;
    --病人挂号汇总
    --解锁单据时不用再对汇总单据进行统计了 在锁定单据时已经进行了汇总
    If 锁定类型_In <> 2 Then
      --操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
      --是否为预约接收:0-非预约挂号; 1-预约挂号,2-预约接收;3-收费预约
      n_预约 := Case
                When Nvl(操作方式_In, 0) = 1 Then
                 0
                When Nvl(操作方式_In, 0) = 2 Then
                 1
                When Nvl(操作方式_In, 0) = 3 Then
                 3
                Else
                 0
              End;
      Zl_病人挂号汇总_Update(r_安排.医生姓名, r_安排.医生id, r_安排.项目id, r_安排.科室id, 发生时间_In, n_预约, 号码_In);
    End If;
    --消息推送
    Begin
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 1, n_挂号id;
    Exception
      When Others Then
        Null;
    End;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]+' || v_Err_Msg || '+[ZLSOFT]');
  When Err_Special Then
    Raise_Application_Error(-20105, '[ZLSOFT]+' || v_Err_Msg || '+[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_三方机构挂号_Insert;
/


--111342:焦博,2017-07-10,调整公共函数Zl_Third_Getpatiid增加传入参数姓名_IN
--110711:焦博,2017-06-28,增加入参节点身份证号,当病人ID不存在时,用身份证号获取病人ID
--100956:刘尔旋,2017-5-23,收费价格等级支付宝相关调整
Create Or Replace Procedure Zl_Third_Getregfeedetail
(
  Xml_In  In Xmltype,
  Xml_Out In Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取挂号费用明细
  --入参:Xml_In:
  --<IN>
  --  <BRID></BRID> //病人ID
  --  <XM></XM>     //姓名
  --  <SFZH></SFZH> //身份证号
  --  <SFYY></SFYY> //是否仅预约不支付,1-仅预约不支付,0-挂号,预约支付,预约接收，默认为0
  --  <GHDH></GHDH> //挂号单号,预约接收时传入
  --  <GHHM></GHHM> //挂号安排号码,挂号和预约时传入
  --  <XMID></XMID> //挂号安排的项目ID,挂号和预约时传入
  --  <FB></FB>     //病人费别
  --  <ZD></ZD>     //站点
  --</IN>
  --出参:Xml_Out
  -- <OUTPUT>
  --  <ZJE></ZJE>   //总实收金额
  --  <XMMX>        //项目明细
  --    <XM>
  --      <DJH></DJH>       //单据号
  --      <MC></MC>   //项目名称
  --      <ID></ID>   //项目ID
  --      <SL></SL>   //数量，数次*付数
  --      <YSJE></YSJE>   //应收金额
  --      <SSJE></SSJE>   //实收金额
  --      <SJFM></SJFM>       //收据费目
  --    </XM>
  --    <XM>
  --    ...
  --    </XM>
  --  </XMMX>
  -- </OUTPUT>

  --------------------------------------------------------------------------------------------------
  x_Templet    Xmltype; --模板XML
  v_Err_Msg    Varchar2(200);
  v_Temp       Varchar2(4000);
  n_项目id     挂号安排.项目id%Type;
  v_No         门诊费用记录.No%Type;
  n_预约       Number(3);
  n_病人id     病人信息.病人id%Type;
  v_姓名       病人信息.姓名%Type;
  v_身份证号   病人信息.身份证号%Type;
  v_费别       病人信息.费别%Type;
  v_站点       部门表.站点%Type;
  v_号码       挂号安排.号码%Type;
  n_总金额     门诊费用记录.实收金额%Type;
  n_实收金额   门诊费用记录.实收金额%Type;
  v_实收       Varchar(500);
  v_附加项目id Varchar2(500);
  v_药品等级   Varchar2(100);
  v_卫材等级   Varchar2(100);
  v_普通等级   Varchar2(100);
  v_Pricegrade Varchar2(500);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');
  Select Extractvalue(Value(A), 'IN/BRID'), Extractvalue(Value(A), 'IN/XMID'), Extractvalue(Value(A), 'IN/GHHM'),
         Extractvalue(Value(A), 'IN/FB'), Extractvalue(Value(A), 'IN/ZD'), Extractvalue(Value(A), 'IN/SFYY'),
         Extractvalue(Value(A), 'IN/GHDH'), Extractvalue(Value(A), 'IN/SFZH'), Extractvalue(Value(A), 'IN/XM')
  Into n_病人id, n_项目id, v_号码, v_费别, v_站点, n_预约, v_No, v_身份证号, v_姓名
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  If Nvl(n_病人id, 0) = 0 And Not v_身份证号 Is Null And Not v_姓名 Is Null Then
    n_病人id := Zl_Third_Getpatiid(v_身份证号, v_姓名);
  End If;
  If Nvl(n_病人id, 0) = 0 Then
    v_Err_Msg := '无法确定病人信息,请检查';
    Raise Err_Item;
  End If;

  v_Pricegrade := Zl_Get_Pricegrade(v_站点);
  v_药品等级   := Substr(v_Pricegrade, 1, Instr(v_Pricegrade, '|') - 1);
  v_Pricegrade := Substr(v_Pricegrade, Instr(v_Pricegrade, '|') + 1);
  v_卫材等级   := Substr(v_Pricegrade, 1, Instr(v_Pricegrade, '|') - 1);
  v_Pricegrade := Substr(v_Pricegrade, Instr(v_Pricegrade, '|') + 1);
  v_普通等级   := Substr(v_Pricegrade, 1, Instr(v_Pricegrade, '|') - 1);

  n_总金额 := 0;
  If v_No Is Null Then
    --挂号或者预约
    For c_挂号项目 In (Select 1 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, -1 As 执行科室类型
                   From 收费项目目录 A, 收费价目 B, 收入项目 C
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = n_项目id And Sysdate Between b.执行日期 And
                         Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And
                         (b.价格等级 = v_普通等级 Or (b.价格等级 Is Null And Not Exists
                          (Select 1
                                               From 收费价目
                                               Where b.收费细目id = 收费细目id And 价格等级 = v_普通等级 And Sysdate Between 执行日期 And
                                                     Nvl(终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')))))
                   Union All
                   Select 2 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, d.从项数次 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, -1 As 执行科室类型
                   From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费从属项目 D
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = d.从项id And d.主项id = n_项目id And
                         Sysdate Between b.执行日期 And Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And
                         (b.价格等级 = v_普通等级 Or (b.价格等级 Is Null And Not Exists
                          (Select 1
                                               From 收费价目
                                               Where b.收费细目id = 收费细目id And 价格等级 = v_普通等级 And Sysdate Between 执行日期 And
                                                     Nvl(终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')))))) Loop
      v_实收     := Zl_Actualmoney(v_费别, c_挂号项目.项目id, c_挂号项目.收入项目id, c_挂号项目.数次 * c_挂号项目.单价);
      n_实收金额 := To_Number(Substr(v_实收, Instr(v_实收, ':') + 1));
      n_总金额   := n_总金额 + Nvl(n_实收金额, 0);
      v_Temp     := v_Temp || '<XM><DJH></DJH><MC>' || c_挂号项目.项目名称 || '</MC>' || '<ID>' || c_挂号项目.项目id || '</ID>' ||
                    '<SL>' || c_挂号项目.数次 || '</SL>' || '<YSJE>' || c_挂号项目.数次 * c_挂号项目.单价 || '</YSJE>' || '<SSJE>' ||
                    n_实收金额 || '</SSJE>' || '<SJFM>' || c_挂号项目.收据费目 || '</SJFM></XM>';
    End Loop;
  Else
    --预约接收
    For c_挂号项目 In (Select a.收费细目id As 项目id, a.应收金额, a.实收金额, a.计算单位, a.收据费目, b.名称 As 项目名称, a.No, Nvl(a.付数, 1) As 付数, a.数次
                   From 门诊费用记录 A, 收费项目目录 B
                   Where a.收费细目id = b.Id And a.No = v_No And a.记录性质 = 4 And a.记录状态 = 0) Loop
      n_总金额 := n_总金额 + Nvl(c_挂号项目.实收金额, 0);
      v_号码   := c_挂号项目.计算单位;
      v_Temp   := v_Temp || '<XM><DJH>' || c_挂号项目.No || '</DJH><MC>' || c_挂号项目.项目名称 || '</MC>' || '<ID>' || c_挂号项目.项目id ||
                  '</ID>' || '<SL>' || c_挂号项目.付数 * c_挂号项目.数次 || '</SL>' || '<YSJE>' || c_挂号项目.应收金额 || '</YSJE>' ||
                  '<SSJE>' || c_挂号项目.实收金额 || '</SSJE>' || '<SJFM>' || c_挂号项目.收据费目 || '</SJFM></XM>';
    End Loop;
  End If;

  If Nvl(n_预约, 0) = 0 Then
    Begin
      Select Zl_Fun_Customregexpenses(n_病人id, 0, v_号码) Into v_附加项目id From Dual;
    Exception
      When Others Then
        v_附加项目id := Null;
    End;
    If v_附加项目id Is Not Null Then
      For c_附加项目 In (Select /*+cardinality(D,10)*/
                      5 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次, c.Id As 收入项目id,
                      c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, -1 As 执行科室类型
                     From 收费项目目录 A, 收费价目 B, 收入项目 C, Table(f_Str2list(v_附加项目id)) D
                     Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = d.Column_Value And Sysdate Between b.执行日期 And
                           Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And
                           (b.价格等级 = v_普通等级 Or
                           (b.价格等级 Is Null And Not Exists
                            (Select 1
                              From 收费价目
                              Where b.收费细目id = 收费细目id And 价格等级 = v_普通等级 And Sysdate Between 执行日期 And
                                    Nvl(终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')))))
                     Union All
                     Select /*+cardinality(E,10)*/
                      5 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, d.从项数次 As 数次,
                      c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, -1 As 执行科室类型
                     From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费从属项目 D, Table(f_Str2list(v_附加项目id)) E
                     Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = d.从项id And d.主项id = e.Column_Value And
                           Sysdate Between b.执行日期 And Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And
                           (b.价格等级 = v_普通等级 Or
                           (b.价格等级 Is Null And Not Exists
                            (Select 1
                              From 收费价目
                              Where b.收费细目id = 收费细目id And 价格等级 = v_普通等级 And Sysdate Between 执行日期 And
                                    Nvl(终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')))))) Loop
        v_实收     := Zl_Actualmoney(v_费别, c_附加项目.项目id, c_附加项目.收入项目id, c_附加项目.数次 * c_附加项目.单价);
        n_实收金额 := To_Number(Substr(v_实收, Instr(v_实收, ':') + 1));
        n_总金额   := n_总金额 + Nvl(n_实收金额, 0);
        v_Temp     := v_Temp || '<XM><DJH></DJH><MC>' || c_附加项目.项目名称 || '</MC>' || '<ID>' || c_附加项目.项目id || '</ID>' ||
                      '<SL>' || c_附加项目.数次 || '</SL>' || '<YSJE>' || c_附加项目.数次 * c_附加项目.单价 || '</YSJE>' || '<SSJE>' ||
                      n_实收金额 || '</SSJE>' || '<SJFM>' || c_附加项目.收据费目 || '</SJFM></XM>';
      End Loop;
    End If;
  End If;

  v_Temp := '<XMMX>' || v_Temp || '</XMMX>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;

  v_Temp := '<ZJE>' || n_总金额 || '</ZJE>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;

  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getregfeedetail;
/


--100956:刘尔旋,2017-5-23,收费价格等级支付宝相关调整
Create Or Replace Procedure Zl_Third_Getnolist
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取号源列表(简易模式)
  --入参:Xml_In:
  --<IN>
  --  <RQ>日期</RQ>
  --  <KSID>科室ID</KSID>
  --  <YSID>医生ID</YSID>
  --  <YSXM>医生姓名</YSXM>
  --  <HZDW>支付宝</HZDW>    //合作单位，传入了的时候，只取合作单位的号;为空时，只取非合作单位的号
  --  <SJJG>60</SJJG>     //时间间隔,不传则返回序号时段
  --  <ZD></ZD>           //站点
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  --  <GROUP>
  --    <RQ>日期</RQ>
  --    <HBLIST>
  --     <HB>
  --        <CZJLID>1</CZJLID>     //出诊记录ID
  --        <HM>235</HM>       //号码
  --        <YSID>549</YSID>      //医生ID
  --        <YS>张锐</YS>       //医生姓名
  --        <KSID>123</KSID>   //科室ID
  --        <KSMC>内科</KSMC>   //科室名称
  --        <ZC>主治医师</ZC> //职称
  --        <XMID>10086<XMID> //挂号项目的ID
  --        <XMMC>挂号费</XMMC> //挂号项目的名称
  --        <YGHS>0</YGHS>      //已挂号数
  --        <SYHS>99</SYHS>   //剩余号数
  --        <PRICE>15</PRICE>      //价格
  --        <HL>普通</HL>       //挂号类型
  --        <HCXH>1</HCXH>    //是否存在缓冲序号时间段，1-存在 0或者空-不存在
  --        <FSD>0</FSD>      //是否分时段
  --        <FWMC>白天</FWMC>     //号别时段
  --        <HBTIME>(08:00-17:59)</HBTIME> //可挂时间
  --     <SPANLIST>
  --            <SPAN>
  --                  <SJD></SJD>          //时间段,格式:hh24:mi-hh24:mi
  --                  <GHZS></GHZS>      //时段挂号总数
  --                  <SL></SL>      //剩余数量
  --            </SPAN>
  --            ……
  --          </SPANLIST>
  --      </HB>
  --      <HB>
  --      ……
  --      </HB>
  --    </HBLIST>
  --  </GROUP>
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  d_日期         Date;
  n_科室id       病人挂号记录.执行部门id%Type;
  n_医生id       人员表.Id%Type;
  v_医生姓名     人员表.姓名%Type;
  v_星期         挂号安排限制.限制项目%Type;
  v_时间段       Varchar2(100);
  v_合作单位     挂号合作单位.名称%Type;
  n_分时段       Number(3);
  n_单个剩余     Number(5);
  n_已挂数       Number(5);
  n_合约已挂数   Number(5);
  n_合计金额     收费价目.现价%Type;
  n_合约总数量   Number(5);
  n_合约剩余数量 Number(5);
  n_最大可用数量 Number(5);
  n_合约模式     Number(3); --合约模式:1-合约单位限数量模式 0-合约单位指定序号模式
  n_非合约       Number(3);
  n_是否预留     Number(3);
  d_加号时间     Date;
  d_开始时间     临床出诊记录.开始时间%Type;
  d_终止时间     临床出诊记录.终止时间%Type;
  n_缓冲序号     Number(3);
  n_时段数量     Number(5);
  n_序号控制     临床出诊记录.是否序号控制%Type;
  n_预留数量     Number(5);
  n_特殊预约     Number(3);
  n_禁用         Number(3);
  v_剩余数量     Varchar2(100);
  v_Timetemp     Varchar2(100);
  v_Temp         Varchar2(32767); --临时XML
  v_Xmlmain      Clob; --临时XML
  c_Xmlmain      Clob; --临时XML
  x_Templet      Xmltype; --模板XML
  v_Err_Msg      Varchar2(200);
  n_Exists       Number(5);
  n_时段已挂     Number(5);
  n_挂号模式     Number(3);
  v_挂号模式     Varchar2(500);
  v_启用时间     Varchar2(500);
  n_时间间隔     Number(5);
  n_预约天数     Number(5);
  n_补充天数     Number(5);
  d_时段开始     Date;
  d_时段结束     Date;
  n_时段总数     Number(5);
  n_时段剩余     Number(5);
  v_药品等级     Varchar2(100);
  v_卫材等级     Varchar2(100);
  v_普通等级     Varchar2(100);
  v_Pricegrade   Varchar2(500);
  v_站点         部门表.站点%Type;
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select To_Date(Extractvalue(Value(A), 'IN/RQ'), 'YYYY-MM-DD hh24:mi:ss'), Extractvalue(Value(A), 'IN/KSID'),
         Extractvalue(Value(A), 'IN/YSID'), Extractvalue(Value(A), 'IN/YSXM'), Extractvalue(Value(A), 'IN/HZDW'),
         Extractvalue(Value(A), 'IN/SJJG'), Extractvalue(Value(A), 'IN/ZD')
  Into d_日期, n_科室id, n_医生id, v_医生姓名, v_合作单位, n_时间间隔, v_站点
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  v_挂号模式 := zl_GetSysParameter('挂号排班模式');
  n_挂号模式 := To_Number(Substr(v_挂号模式, 1, 1));
  If n_挂号模式 = 1 Then
    Begin
      v_启用时间 := Substr(v_挂号模式, 3);
    Exception
      When Others Then
        v_启用时间 := Null;
    End;
  End If;
  --日期节点为空的情况
  If d_日期 Is Null Then
    d_日期 := Trunc(Sysdate);
  End If;
  v_Pricegrade := Zl_Get_Pricegrade(v_站点);
  v_药品等级   := Substr(v_Pricegrade, 1, Instr(v_Pricegrade, '|') - 1);
  v_Pricegrade := Substr(v_Pricegrade, Instr(v_Pricegrade, '|') + 1);
  v_卫材等级   := Substr(v_Pricegrade, 1, Instr(v_Pricegrade, '|') - 1);
  v_Pricegrade := Substr(v_Pricegrade, Instr(v_Pricegrade, '|') + 1);
  v_普通等级   := Substr(v_Pricegrade, 1, Instr(v_Pricegrade, '|') - 1);
  n_预约天数   := Nvl(zl_GetSysParameter(66), 7);
  If d_日期 < To_Date(v_启用时间, 'yyyy-mm-dd hh24:mi:ss') And n_挂号模式 = 1 Then
    n_挂号模式 := 0;
  End If;

  If n_挂号模式 = 0 Then
    Select Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null)
    Into v_星期
    From Dual;
    n_合约剩余数量 := 0;
  
    For r_No In (Select a.科室id, a.号类, a.科室名称, a.医生姓名, a.医生id, a.职称, a.号码, a.安排id, a.计划id, a.排班, a.项目id, a.项目名称, a.序号控制,
                        a.限号数, a.限约数, a.预约天数, Nvl(Hz.已挂数, 0) As 已挂数, Nvl(Hz.已约数, 0) As 已约数, Nvl(Hz.其中已接收, 0) As 已接收,
                        Sum(b.现价) As 价格
                 From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Nvl(Ap.医生id, 0) As 医生id, Ry.专业技术职务 As 职称, Ap.号码,
                               Ap.安排id, Ap.计划id, Ap.排班, Ap.项目id, Fy.名称 As 项目名称, Ap.序号控制, Ap.限号数, Ap.限约数, Ap.预约天数
                        From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Ap.医生id, Ap.号码, Ap.Id As 安排id, 0 As 计划id,
                                      Ap.项目id, Nvl(Ap.序号控制, 0) As 序号控制,
                                      Decode(To_Char(d_日期, 'D'), '1', Ap.周日, '2', Ap.周一, '3', Ap.周二, '4', Ap.周三, '5', Ap.周四,
                                              '6', Ap.周五, '7', Ap.周六, Null) As 排班, Xz.限约数, Xz.限号数,
                                      Nvl(Ap.预约天数, n_预约天数) As 预约天数
                               From 挂号安排 Ap, 部门表 Bm, 挂号安排限制 Xz
                               Where Ap.科室id = Bm.Id(+) And Decode(Nvl(n_科室id, 0), 0, 0, Ap.科室id) = Nvl(n_科室id, 0) And
                                     Decode(Nvl(n_医生id, 0), 0, 0, Ap.医生id) = Nvl(n_医生id, 0) And
                                     Decode(Nvl(v_医生姓名, '-'), '-', '-', Ap.医生姓名) = Nvl(v_医生姓名, '-') And Ap.停用日期 Is Null And
                                     d_日期 Between Nvl(Ap.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                     Nvl(Ap.终止时间, To_Date('3000 - 01 - 01', 'YYYY-MM-DD')) And Xz.安排id(+) = Ap.Id And
                                     Xz.限制项目(+) = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                         '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                (Select Rownum
                                      From 挂号安排停用状态 Ty
                                      Where Ty.安排id = Ap.Id And d_日期 Between Ty.开始停止时间 And Ty.结束停止时间) And Not Exists
                                (Select Rownum
                                      From 挂号安排计划 Jh
                                      Where Jh.安排id = Ap.Id And Jh.审核时间 Is Not Null And
                                            d_日期 Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                            Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')))
                               Union All
                               Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Jh.医生姓名, Jh.医生id, Ap.号码, Ap.Id As 安排id, Jh.Id As 计划id,
                                      Jh.项目id, Nvl(Jh.序号控制, 0) As 序号控制,
                                      Decode(To_Char(d_日期, 'D'), '1', Jh.周日, '2', Jh.周一, '3', Jh.周二, '4', Jh.周三, '5', Jh.周四,
                                              '6', Jh.周五, '7', Jh.周六, Null) As 排班, Xz.限约数, Xz.限号数,
                                      Nvl(Ap.预约天数, n_预约天数) As 预约天数
                               From 挂号安排计划 Jh, 挂号安排 Ap, 部门表 Bm, 挂号计划限制 Xz
                               Where Jh.安排id = Ap.Id And Ap.科室id = Bm.Id(+) And Ap.停用日期 Is Null And
                                     Decode(Nvl(n_科室id, 0), 0, 0, Ap.科室id) = Nvl(n_科室id, 0) And
                                     Decode(Nvl(n_医生id, 0), 0, 0, Jh.医生id) = Nvl(n_医生id, 0) And
                                     Decode(Nvl(v_医生姓名, '-'), '-', '-', Jh.医生姓名) = Nvl(v_医生姓名, '-') And
                                     d_日期 Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                     Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.计划id(+) = Jh.Id And
                                     Xz.限制项目(+) = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                         '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                (Select Rownum
                                      From 挂号安排停用状态 Ty
                                      Where Ty.安排id = Ap.Id And d_日期 Between Ty.开始停止时间 And Ty.结束停止时间) And
                                     (Jh.生效时间, Jh.安排id) =
                                     (Select Max(Sxjh.生效时间) As 生效时间, 安排id
                                      From 挂号安排计划 Sxjh
                                      Where Sxjh.审核时间 Is Not Null And
                                            d_日期 Between Nvl(Sxjh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                            Nvl(Sxjh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Sxjh.安排id = Jh.安排id
                                      Group By Sxjh.安排id)) Ap, 部门表 Bm, 人员表 Ry, 收费项目目录 Fy
                        Where Ap.科室id = Bm.Id(+) And Ap.医生id = Ry.Id(+) And Ap.项目id = Fy.Id And 排班 Is Not Null) A,
                      病人挂号汇总 Hz, 收费价目 B
                 Where a.号码 = Hz.号码(+) And Hz.日期(+) = Trunc(d_日期) And a.项目id = b.收费细目id And
                       Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-Mm-DD')) > d_日期 And b.执行日期 <= d_日期 And
                       (b.价格等级 = v_普通等级 Or (b.价格等级 Is Null And Not Exists
                        (Select 1
                                             From 收费价目
                                             Where b.收费细目id = 收费细目id And 价格等级 = v_普通等级 And Sysdate Between 执行日期 And
                                                   Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')))))
                 Group By a.科室id, a.号类, a.科室名称, a.医生姓名, a.医生id, a.职称, a.号码, a.安排id, a.计划id, a.排班, a.项目id, a.项目名称, a.序号控制,
                          a.限号数, a.限约数, a.预约天数, Nvl(Hz.已挂数, 0), Nvl(Hz.已约数, 0), Nvl(Hz.其中已接收, 0)) Loop
      Zl_挂号序号状态_Delete(1, r_No.号码);
      If Sysdate + Nvl(r_No.预约天数, n_预约天数) >= d_日期 Then
        If r_No.计划id <> 0 Then
          Select Sign(Count(Rownum))
          Into n_分时段
          From 挂号安排计划 Jh, 挂号计划时段 Sd
          Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7',
                               '周六', Null) And Rownum < 2;
        Else
          Select Sign(Count(Rownum))
          Into n_分时段
          From 挂号安排 Ap, 挂号安排时段 Sd
          Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7',
                               '周六', Null) And Rownum < 2;
        End If;
        --分时段不序号控制当天号为普通号
        If Trunc(Sysdate) = Trunc(d_日期) And n_分时段 = 1 And r_No.序号控制 = 0 Then
          n_分时段 := 0;
        End If;
        If n_分时段 = 0 Then
          v_Temp := '';
          If v_合作单位 Is Not Null And r_No.序号控制 = 1 Then
            If r_No.计划id <> 0 Then
              Select Nvl(Sum(数量), 0)
              Into n_合约总数量
              From 合作单位计划控制
              Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null);
              Select Count(1)
              Into n_合约模式
              From 合作单位计划控制
              Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 序号 = 0;
            Else
              Select Nvl(Sum(数量), 0)
              Into n_合约总数量
              From 合作单位安排控制
              Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null);
              Select Count(1)
              Into n_合约模式
              From 合作单位安排控制
              Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 序号 = 0;
            End If;
            If n_合约模式 = 0 Then
              If r_No.计划id <> 0 Then
                Select Count(1)
                Into n_合约已挂数
                From 病人挂号记录 A
                Where 号别 = r_No.号码 And 记录状态 = 1 And 发生时间 Between Trunc(d_日期) And Trunc(d_日期 + 1) - 1 / 60 / 60 / 24 And
                      Exists
                 (Select 1
                       From 合作单位计划控制
                       Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                             限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                           '周五', '7', '周六', Null) And 序号 = a.号序 And 数量 <> 0);
              Else
                Select Count(1)
                Into n_合约已挂数
                From 病人挂号记录 A
                Where 号别 = r_No.号码 And 记录状态 = 1 And 发生时间 Between Trunc(d_日期) And Trunc(d_日期 + 1) - 1 / 60 / 60 / 24 And
                      Exists
                 (Select 1
                       From 合作单位安排控制
                       Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                             限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                           '周五', '7', '周六', Null) And 序号 = a.号序 And 数量 <> 0);
              End If;
            Else
              Select Count(1)
              Into n_合约已挂数
              From 病人挂号记录
              Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                    Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
            End If;
            If n_合约总数量 = 0 Then
              n_合约剩余数量 := 0;
            Else
              n_合约剩余数量 := n_合约总数量 - n_合约已挂数;
              If n_合约剩余数量 > (Nvl(r_No.限号数, 0) - r_No.已挂数) Then
                n_合约剩余数量 := Nvl(r_No.限号数, 0) - r_No.已挂数;
              End If;
            End If;
          End If;
        Else
          v_Temp := '<SPANLIST>';
          If r_No.计划id <> 0 Then
            Select To_Date(To_Char(d_日期, 'yyyy-mm-dd') || To_Char(Max(结束时间), 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss')
            Into d_加号时间
            From 挂号计划时段
            Where 计划id = r_No.计划id And 星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                   '周四', '6', '周五', '7', '周六', Null);
            If r_No.序号控制 = 1 Then
              If Trunc(d_日期) = Trunc(Sysdate) Then
                n_特殊预约 := 0;
              Else
                Select Nvl(Max(Jh.是否预约), 0)
                Into n_特殊预约
                From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                              To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                              To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                       From 挂号安排计划 Jh, 挂号计划时段 Sd
                       Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                             Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                            '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                Where Zt.日期(+) = Jh.开始时间 And Zt.号码(+) = Jh.号码 And Zt.序号(+) = Jh.序号 And
                      Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) <> 1;
              End If;
            
              d_时段开始 := Null;
              d_时段结束 := Null;
              n_时段总数 := 0;
              n_时段剩余 := 0;
              For r_Time In (Select Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约, 0 As 已约数,
                                    Decode(Nvl(Zt.序号, 0), 0, 1, 0) As 剩余数,
                                    Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) As 失效时段
                             From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                    From 挂号安排计划 Jh, 挂号计划时段 Sd
                                    Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And Not Exists
                                     (Select 1
                                           From 挂号安排停用状态
                                           Where 安排id = Jh.安排id And
                                                 To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' ||
                                                         To_Char(Sd.开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') Between
                                                 开始停止时间 And 结束停止时间) And
                                          Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                         '5', '周四', '6', '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                             Where Zt.日期(+) = Jh.开始时间 And Zt.号码(+) = Jh.号码 And Zt.序号(+) = Jh.序号
                             Order By 序号) Loop
                If Nvl(n_时间间隔, 0) <> 0 Then
                  If d_时段开始 Is Null Then
                    d_时段开始 := r_Time.开始时间;
                    d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                    n_时段总数 := n_时段总数 + r_Time.限制数量;
                    If d_加号时间 < d_时段结束 Then
                      d_时段结束 := d_加号时间;
                    End If;
                  Else
                    If r_Time.开始时间 >= d_时段结束 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                    To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                    '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                      n_时段总数 := r_Time.限制数量;
                      n_时段剩余 := 0;
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      n_时段总数 := n_时段总数 + r_Time.限制数量;
                    End If;
                  End If;
                End If;
                If v_合作单位 Is Not Null Then
                  Select Nvl(Max(1), 0)
                  Into n_合约模式
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
                Else
                  n_合约模式 := 0;
                End If;
                If r_Time.剩余数 = 0 Then
                  n_单个剩余 := 0;
                Else
                  n_单个剩余 := r_Time.限制数量;
                End If;
                If v_合作单位 Is Null Or n_合约模式 = 1 Then
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And Rownum < 2;
                  If n_Exists = 0 And r_Time.失效时段 <> 1 Then
                    If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                      Null;
                    Else
                      Select Nvl(Max(1), 0)
                      Into n_是否预留
                      From 挂号序号状态
                      Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                      If n_是否预留 = 0 Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                    '</SPAN>';
                        Else
                          n_时段剩余 := n_时段剩余 + n_单个剩余;
                        End If;
                        n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                      End If;
                    End If;
                  End If;
                Else
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                  Begin
                    Select 0
                    Into n_非合约
                    From 合作单位计划控制
                    Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_非合约 := 1;
                  End;
                  If (n_Exists = 1 Or n_非合约 = 1) And r_Time.失效时段 <> 1 Then
                    If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                      Null;
                    Else
                      Select Nvl(Max(1), 0)
                      Into n_是否预留
                      From 挂号序号状态
                      Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                      If n_是否预留 = 0 Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                    '</SPAN>';
                        Else
                          n_时段剩余 := n_时段剩余 + n_单个剩余;
                        End If;
                        n_合约剩余数量 := n_合约剩余数量 + 1;
                      End If;
                    End If;
                  End If;
                End If;
              End Loop;
              If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                              To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                              n_时段剩余 || '</SL>' || '</SPAN>';
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
              End If;
            Else
              n_最大可用数量 := Nvl(r_No.限约数, Nvl(r_No.限号数, 0)) - Nvl(r_No.已约数, 0);
              n_时段总数     := 0;
              n_时段剩余     := 0;
              d_时段开始     := Null;
              d_时段结束     := Null;
              For r_Time In (Select Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约,
                                    Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 已约数,
                                    Jh.限制数量 - Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 剩余数,
                                    Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) As 失效时段
                             From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                    From 挂号安排计划 Jh, 挂号计划时段 Sd
                                    Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And Not Exists
                                     (Select 1
                                           From 挂号安排停用状态
                                           Where 安排id = Jh.安排id And
                                                 To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' ||
                                                         To_Char(Sd.开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') Between
                                                 开始停止时间 And 结束停止时间) And
                                          Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                         '5', '周四', '6', '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                             Where Jh.号码 = Zt.号码(+) And Jh.开始时间 = Zt.日期(+)
                             Group By Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约
                             Order By Jh.序号) Loop
                If Nvl(n_时间间隔, 0) <> 0 Then
                  If d_时段开始 Is Null Then
                    d_时段开始 := r_Time.开始时间;
                    d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                    n_时段总数 := n_时段总数 + r_Time.限制数量;
                    If d_加号时间 < d_时段结束 Then
                      d_时段结束 := d_加号时间;
                    End If;
                  Else
                    If r_Time.开始时间 >= d_时段结束 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                    To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                    '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                      n_时段总数 := r_Time.限制数量;
                      n_时段剩余 := 0;
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      n_时段总数 := n_时段总数 + r_Time.限制数量;
                    End If;
                  End If;
                End If;
                If v_合作单位 Is Not Null Then
                  Select Nvl(Max(1), 0)
                  Into n_合约模式
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
                Else
                  n_合约模式 := 0;
                End If;
                n_单个剩余 := r_Time.剩余数;
                If v_合作单位 Is Null Or n_合约模式 = 1 Then
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And Rownum < 2;
                  If n_Exists = 0 And r_Time.失效时段 <> 1 Then
                    If n_最大可用数量 < n_单个剩余 Then
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_最大可用数量;
                      End If;
                      n_时段数量 := Nvl(n_时段数量, 0) + n_最大可用数量;
                    Else
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_单个剩余;
                      End If;
                      n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                    End If;
                  End If;
                Else
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                  Begin
                    Select 0
                    Into n_非合约
                    From 合作单位计划控制
                    Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_非合约 := 1;
                  End;
                  If (n_Exists = 1 Or n_非合约 = 1) And r_Time.失效时段 <> 1 Then
                    If n_最大可用数量 < n_单个剩余 Then
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_最大可用数量;
                      End If;
                      n_合约剩余数量 := n_合约剩余数量 + Nvl(n_最大可用数量, 0);
                    Else
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_单个剩余;
                      End If;
                      n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                    End If;
                  End If;
                End If;
              End Loop;
              If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                              To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                              n_时段剩余 || '</SL>' || '</SPAN>';
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
              End If;
            End If;
          Else
            Select To_Date(To_Char(d_日期, 'yyyy-mm-dd') || To_Char(Max(结束时间), 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss')
            Into d_加号时间
            From 挂号安排时段
            Where 安排id = r_No.安排id And 星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                   '周四', '6', '周五', '7', '周六', Null);
            If r_No.序号控制 = 1 Then
              If Trunc(d_日期) = Trunc(Sysdate) Then
                n_特殊预约 := 0;
              Else
                Select Nvl(Max(Ap.是否预约), 0)
                Into n_特殊预约
                From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                              To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                              To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                       From 挂号安排 Ap, 挂号安排时段 Sd
                       Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                             Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                            '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                Where Zt.日期(+) = Ap.开始时间 And Zt.号码(+) = Ap.号码 And Zt.序号(+) = Ap.序号 And
                      Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) <> 1;
              End If;
              n_时段总数 := 0;
              n_时段剩余 := 0;
              d_时段开始 := Null;
              d_时段结束 := Null;
              For r_Time In (Select Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约, 0 As 已约数,
                                    Decode(Nvl(Zt.序号, 0), 0, 1, 0) As 剩余数,
                                    Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) As 失效时段
                             
                             From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                    From 挂号安排 Ap, 挂号安排时段 Sd
                                    Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And Not Exists
                                     (Select 1
                                           From 挂号安排停用状态
                                           Where 安排id = Ap.Id And
                                                 To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' ||
                                                         To_Char(Sd.开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') Between
                                                 开始停止时间 And 结束停止时间) And
                                          Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                         '5', '周四', '6', '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                             Where Zt.日期(+) = Ap.开始时间 And Zt.号码(+) = Ap.号码 And Zt.序号(+) = Ap.序号
                             Order By 序号) Loop
                If Nvl(n_时间间隔, 0) <> 0 Then
                  If d_时段开始 Is Null Then
                    d_时段开始 := r_Time.开始时间;
                    n_时段总数 := n_时段总数 + r_Time.限制数量;
                    d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                    If d_加号时间 < d_时段结束 Then
                      d_时段结束 := d_加号时间;
                    End If;
                  Else
                    If r_Time.开始时间 >= d_时段结束 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                    To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                    '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                      n_时段总数 := r_Time.限制数量;
                      n_时段剩余 := 0;
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      n_时段总数 := n_时段总数 + r_Time.限制数量;
                    End If;
                  End If;
                End If;
                If v_合作单位 Is Not Null Then
                  Begin
                    Select 1
                    Into n_合约模式
                    From 合作单位安排控制
                    Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
                  Exception
                    When Others Then
                      n_合约模式 := 0;
                  End;
                Else
                  n_合约模式 := 0;
                End If;
                If r_Time.剩余数 = 0 Then
                  n_单个剩余 := 0;
                Else
                  n_单个剩余 := r_Time.限制数量;
                End If;
                If v_合作单位 Is Null Or n_合约模式 = 1 Then
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And Rownum < 2;
                  If n_Exists = 0 And r_Time.失效时段 <> 1 Then
                    If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                      Null;
                    Else
                      Select Nvl(Max(1), 0)
                      Into n_是否预留
                      From 挂号序号状态
                      Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                      If n_是否预留 = 0 Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                    '</SPAN>';
                        Else
                          n_时段剩余 := n_时段剩余 + n_单个剩余;
                        End If;
                        n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                      End If;
                    End If;
                  End If;
                Else
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                  Begin
                    Select 0
                    Into n_非合约
                    From 合作单位安排控制
                    Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_非合约 := 1;
                  End;
                  If (n_Exists = 1 Or n_非合约 = 1) And r_Time.失效时段 <> 1 Then
                    If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                      Null;
                    Else
                      Select Nvl(Max(1), 0)
                      Into n_是否预留
                      From 挂号序号状态
                      Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                      If n_是否预留 = 0 Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                    '</SPAN>';
                        Else
                          n_时段剩余 := n_时段剩余 + n_单个剩余;
                        End If;
                        n_合约剩余数量 := n_合约剩余数量 + n_单个剩余;
                      End If;
                    End If;
                  End If;
                End If;
              End Loop;
              If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                              To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                              n_时段剩余 || '</SL>' || '</SPAN>';
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
              End If;
            Else
              n_最大可用数量 := Nvl(r_No.限约数, Nvl(r_No.限号数, 0)) - Nvl(r_No.已约数, 0);
              n_时段总数     := 0;
              n_时段剩余     := 0;
              d_时段开始     := Null;
              d_时段结束     := Null;
              For r_Time In (Select Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约,
                                    Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 已约数,
                                    Ap.限制数量 - Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 剩余数,
                                    Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) As 失效时段
                             From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                    From 挂号安排 Ap, 挂号安排时段 Sd
                                    Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And Not Exists
                                     (Select 1
                                           From 挂号安排停用状态
                                           Where 安排id = Ap.Id And
                                                 To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' ||
                                                         To_Char(Sd.开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') Between
                                                 开始停止时间 And 结束停止时间) And
                                          Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                         '5', '周四', '6', '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                             Where Ap.号码 = Zt.号码(+) And Ap.开始时间 = Zt.日期(+)
                             Group By Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约
                             Order By Ap.序号) Loop
                If Nvl(n_时间间隔, 0) <> 0 Then
                  If d_时段开始 Is Null Then
                    d_时段开始 := r_Time.开始时间;
                    d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                    n_时段总数 := n_时段总数 + r_Time.限制数量;
                    If d_加号时间 < d_时段结束 Then
                      d_时段结束 := d_加号时间;
                    End If;
                  Else
                    If r_Time.开始时间 >= d_时段结束 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                    To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                    '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                      n_时段总数 := r_Time.限制数量;
                      n_时段剩余 := 0;
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      n_时段总数 := n_时段总数 + r_Time.限制数量;
                    End If;
                  End If;
                End If;
                If v_合作单位 Is Not Null Then
                  Select Nvl(Max(1), 0)
                  Into n_合约模式
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
                Else
                  n_合约模式 := 0;
                End If;
                n_单个剩余 := r_Time.剩余数;
                If v_合作单位 Is Null Or n_合约模式 = 1 Then
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And Rownum < 2;
                  If n_Exists = 0 And r_Time.失效时段 <> 1 Then
                    If n_最大可用数量 < n_单个剩余 Then
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_最大可用数量;
                      End If;
                      n_时段数量 := Nvl(n_时段数量, 0) + n_最大可用数量;
                    Else
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_单个剩余;
                      End If;
                      n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                    End If;
                  End If;
                Else
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                  Begin
                    Select 0
                    Into n_非合约
                    From 合作单位安排控制
                    Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_非合约 := 1;
                  End;
                  If (n_Exists = 1 Or n_非合约 = 1) And r_Time.失效时段 <> 1 Then
                    If n_最大可用数量 < n_单个剩余 Then
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_最大可用数量;
                      End If;
                      n_合约剩余数量 := n_合约剩余数量 + Nvl(n_最大可用数量, 0);
                    Else
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_单个剩余;
                      End If;
                      n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                    End If;
                  End If;
                End If;
              End Loop;
              If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                              To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                              n_时段剩余 || '</SL>' || '</SPAN>';
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
              End If;
            End If;
          End If;
        End If;
        If v_合作单位 Is Not Null Then
          If Nvl(r_No.计划id, 0) <> 0 Then
            Begin
              Select 0
              Into n_非合约
              From 合作单位计划控制
              Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
            Exception
              When Others Then
                n_非合约 := 1;
            End;
          Else
            Begin
              Select 0
              Into n_非合约
              From 合作单位安排控制
              Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
            Exception
              When Others Then
                n_非合约 := 1;
            End;
          End If;
        End If;
        If v_合作单位 Is Null Or n_非合约 = 1 Then
          If r_No.限号数 = 0 Then
            v_剩余数量 := '';
          Else
            If Nvl(r_No.计划id, 0) <> 0 Then
              Select Sum(数量)
              Into n_合约总数量
              From 合作单位计划控制
              Where 计划id = r_No.计划id And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null);
            Else
              Select Sum(数量)
              Into n_合约总数量
              From 合作单位安排控制
              Where 安排id = r_No.安排id And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null);
            End If;
            Select Count(1)
            Into n_合约已挂数
            From 病人挂号记录
            Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 Is Not Null And 发生时间 Between Trunc(d_日期) And
                  Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
            Select Count(1)
            Into n_预留数量
            From 挂号序号状态
            Where 状态 = 3 And 号码 = r_No.号码 And Trunc(日期) = Trunc(d_日期);
            If Trunc(d_日期) = Trunc(Sysdate) Then
              If Nvl(n_合约总数量, 0) = 0 Then
                v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_预留数量;
              Else
                v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_合约总数量 + n_合约已挂数 - n_预留数量;
              End If;
              n_已挂数 := r_No.已挂数;
              If Nvl(n_时段数量, 0) < v_剩余数量 And n_分时段 <> 0 Then
                n_缓冲序号 := 1;
                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_加号时间, 'hh24:mi:ss') || '-' || '</SJD>' ||
                              '<SL>' || To_Number(v_剩余数量 - Nvl(n_时段数量, 0) - Nvl(n_合约剩余数量, 0)) || '</SL>' || '</SPAN>';
              Else
                n_缓冲序号 := 0;
              End If;
            Else
              If Nvl(n_合约总数量, 0) = 0 Then
                v_剩余数量 := r_No.限约数 - r_No.已约数 - n_预留数量;
                If v_剩余数量 Is Null Then
                  v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_预留数量;
                End If;
              Else
                v_剩余数量 := r_No.限约数 - r_No.已约数 - n_合约总数量 + n_合约已挂数 - n_预留数量;
                If v_剩余数量 Is Null Then
                  v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_合约总数量 + n_合约已挂数 - n_预留数量;
                End If;
              End If;
              n_已挂数 := r_No.已挂数;
            End If;
          End If;
        Else
          If Nvl(r_No.计划id, 0) <> 0 Then
            If v_合作单位 Is Not Null Then
              Select Nvl(Max(1), 0)
              Into n_合约模式
              From 合作单位计划控制
              Where 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
            Else
              n_合约模式 := 0;
            End If;
            Select Sum(数量)
            Into n_合约总数量
            From 合作单位计划控制
            Where 计划id = r_No.计划id And 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                     '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
          Else
            If v_合作单位 Is Not Null Then
              Select Nvl(Max(1), 0)
              Into n_合约模式
              From 合作单位安排控制
              Where 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
            Else
              n_合约模式 := 0;
            End If;
            Select Sum(数量)
            Into n_合约总数量
            From 合作单位安排控制
            Where 安排id = r_No.安排id And 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                     '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
          End If;
          If n_合约模式 = 0 Then
            v_剩余数量   := n_合约剩余数量;
            n_已挂数     := r_No.已挂数;
            n_合约已挂数 := Nvl(n_合约总数量, 0) - n_合约剩余数量;
          Else
            n_已挂数 := r_No.已挂数;
            Select Count(1)
            Into n_合约已挂数
            From 病人挂号记录
            Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                  Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
            If Nvl(n_合约总数量, 0) = 0 Then
              v_剩余数量 := '0';
            Else
              v_剩余数量 := n_合约总数量 - n_合约已挂数;
            End If;
          End If;
        End If;
        Select To_Char(开始时间, 'hh24:mi') Into v_Timetemp From 时间段 Where 时间段 = r_No.排班;
        v_时间段 := v_Timetemp || '-';
        Select To_Char(终止时间, 'hh24:mi') Into v_Timetemp From 时间段 Where 时间段 = r_No.排班;
        v_时间段 := v_时间段 || v_Timetemp;
        If v_Temp Is Not Null Then
          v_Temp := v_Temp || '</SPANLIST>';
        End If;
        If v_合作单位 Is Not Null Then
          If Nvl(r_No.计划id, 0) <> 0 Then
            Select Nvl(Max(1), 0)
            Into n_禁用
            From 合作单位计划控制
            Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
          Else
            Select Nvl(Max(1), 0)
            Into n_禁用
            From 合作单位安排控制
            Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
          End If;
        End If;
        --限约数=0的预约禁止
        If Trunc(d_日期) <> Trunc(Sysdate) Then
          If r_No.限约数 = 0 Then
            n_禁用 := 1;
          End If;
        End If;
        If Nvl(n_禁用, 0) = 0 Then
          --从项金额计算
          n_合计金额 := r_No.价格;
          For r_Subfee In (Select 现价, 从项数次
                           From 收费从属项目 A, 收费价目 B
                           Where a.主项id = r_No.项目id And a.从项id = b.收费细目id And Sysdate Between b.执行日期 And
                                 Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And
                                 (b.价格等级 = v_普通等级 Or
                                 (b.价格等级 Is Null And Not Exists
                                  (Select 1
                                    From 收费价目
                                    Where b.收费细目id = 收费细目id And 价格等级 = v_普通等级 And Sysdate Between 执行日期 And
                                          Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')))))) Loop
            n_合计金额 := n_合计金额 + r_Subfee.现价 * r_Subfee.从项数次;
          End Loop;
          If Trunc(Sysdate) = Trunc(d_日期) Then
            Select Nvl(Max(1), 0)
            Into n_Exists
            From (Select 时间段
                   From 时间段
                   Where ('3000-01-10 ' || To_Char(Sysdate, 'HH24:MI:SS') < '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS')) Or
                         ('3000-01-10 ' || To_Char(Sysdate, 'HH24:MI:SS') <
                         Decode(Sign(开始时间 - 终止时间), 1, '3000-01-11 ' || To_Char(终止时间, 'HH24:MI:SS'),
                                 '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS'))))
            Where 时间段 = r_No.排班;
          Else
            n_Exists := 1;
          End If;
          If n_Exists = 1 Then
            If v_剩余数量 > 0 Then
              c_Xmlmain := '<HB>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' || r_No.医生id || '</YSID>' || '<YS>' ||
                           r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id || '</KSID>' || '<KSMC>' || r_No.科室名称 ||
                           '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' || r_No.项目id || '</XMID>' || '<XMMC>' ||
                           r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 || '</YGHS>' || '<SYHS>' || v_剩余数量 || '</SYHS>' ||
                           '<PRICE>' || n_合计金额 || '</PRICE>' || '<HCXH>' || n_缓冲序号 || '</HCXH>' || '<HL>' || r_No.号类 ||
                           '</HL>' || '<FSD>' || n_分时段 || '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' || '<FWMC>' ||
                           r_No.排班 || '</FWMC>' || v_Temp || '</HB>';
              v_Xmlmain := v_Xmlmain || c_Xmlmain;
            Else
              c_Xmlmain := '<HB>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' || r_No.医生id || '</YSID>' || '<YS>' ||
                           r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id || '</KSID>' || '<KSMC>' || r_No.科室名称 ||
                           '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' || r_No.项目id || '</XMID>' || '<XMMC>' ||
                           r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 || '</YGHS>' || '<SYHS>' || v_剩余数量 || '</SYHS>' ||
                           '<PRICE>' || n_合计金额 || '</PRICE>' || '<HL>' || r_No.号类 || '</HL>' || '<FSD>' || n_分时段 ||
                           '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' || '<FWMC>' || r_No.排班 || '</FWMC>' ||
                           '</HB>';
              v_Xmlmain := v_Xmlmain || c_Xmlmain;
            End If;
          End If;
        End If;
      End If;
      n_合约剩余数量 := 0;
      n_合约总数量   := 0;
      n_时段数量     := 0;
      n_禁用         := 0;
      n_非合约       := 0;
    End Loop;
    v_Xmlmain := '<GROUP>' || '<RQ>' || To_Char(d_日期, 'yyyy-mm-dd') || '</RQ>' || '<HBLIST>' || v_Xmlmain ||
                 '</HBLIST>' || '</GROUP>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Xmlmain)) Into x_Templet From Dual;
  Else
    --出诊表排班模式
    n_补充天数     := Zl_Fun_Getappointmentdays;
    n_合约剩余数量 := 0;
    For r_No In (Select a.科室id, b.号类, c.名称 As 科室名称, a.医生姓名, a.医生id, d.专业技术职务 As 职称, b.号码, a.Id As 记录id, a.上班时段 As 排班,
                        a.项目id, e.名称 As 项目名称, a.是否序号控制 As 序号控制, a.限号数, Nvl(a.限约数, a.限号数) As 限约数, Nvl(a.已挂数, 0) As 已挂数,
                        Nvl(a.已约数, 0) As 已约数, Nvl(a.其中已接收, 0) As 已接收, a.是否分时段 As 分时段, a.开始时间, a.终止时间, a.预约控制, a.替诊开始时间,
                        a.替诊终止时间, Nvl(b.预约天数, n_预约天数) + n_补充天数 As 预约天数, a.停诊开始时间, a.停诊终止时间
                 From 临床出诊记录 A, 临床出诊号源 B, 部门表 C, 人员表 D, 收费项目目录 E
                 Where a.出诊日期 = Trunc(d_日期) And a.终止时间 > Sysdate And a.号源id = b.Id And a.项目id = e.Id And
                       a.医生id = d.Id(+) And b.科室id = c.Id And Nvl(a.是否锁定, 0) = 0 And
                       (a.开始时间 < Nvl(a.停诊开始时间, a.终止时间) Or a.终止时间 > Nvl(a.停诊终止时间, a.开始时间) Or Exists
                        (Select 1
                         From 临床出诊序号控制 C, 临床出诊记录 D
                         Where d.Id = a.Id And c.记录id = d.Id And Nvl(c.是否停诊, 0) = 0 And d.是否序号控制 = 1 And d.是否分时段 = 1 And
                               c.开始时间 <> c.终止时间)) And (a.开始时间 < Nvl(a.替诊开始时间, a.终止时间) Or a.终止时间 > Nvl(a.替诊终止时间, a.开始时间)) And
                       Nvl(a.是否发布, 0) = 1 And a.开始时间 > Trunc(To_Date(v_启用时间, 'yyyy-mm-dd hh24:mi:ss')) And
                       Decode(Nvl(n_科室id, 0), 0, 0, b.科室id) = Nvl(n_科室id, 0) And
                       Decode(Nvl(n_医生id, 0), 0, 0, a.医生id) = Nvl(n_医生id, 0) And
                       Decode(Nvl(v_医生姓名, '-'), '-', '-', a.医生姓名) = Nvl(v_医生姓名, '-')) Loop
      Zl_挂号序号状态_出诊_Delete(r_No.记录id);
      v_Temp := Null;
      If Sysdate + Nvl(r_No.预约天数, n_预约天数) + n_补充天数 >= d_日期 Then
        If Trunc(d_日期) = Trunc(Sysdate) Then
          --当天挂号
          If v_合作单位 Is Null Then
            --未传入合作单位
            n_已挂数   := r_No.已挂数;
            v_剩余数量 := r_No.限号数 - Nvl(r_No.已挂数, 0) - (Nvl(r_No.已约数, 0) - Nvl(r_No.已接收, 0));
            If r_No.分时段 = 1 And r_No.序号控制 = 1 Then
              --分时段
              Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
              v_Temp     := '<SPANLIST>';
              n_Exists   := 0;
              n_时段总数 := 0;
              n_时段剩余 := 0;
              d_时段开始 := Null;
              d_时段结束 := Null;
              For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                             From 临床出诊序号控制
                             Where 记录id = r_No.记录id And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                                   Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1) Loop
                If Nvl(n_时间间隔, 0) <> 0 Then
                  If d_时段开始 Is Null Then
                    d_时段开始 := r_Time.开始时间;
                    d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                    n_时段总数 := n_时段总数 + 1;
                    If d_加号时间 < d_时段结束 Then
                      d_时段结束 := d_加号时间;
                    End If;
                  Else
                    If r_Time.开始时间 >= d_时段结束 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                    To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                    '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                      n_时段总数 := 1;
                      n_时段剩余 := 0;
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      n_时段总数 := n_时段总数 + 1;
                    End If;
                  End If;
                End If;
                If r_Time.开始时间 > Sysdate Then
                  If Nvl(n_时间间隔, 0) = 0 Then
                    v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                              To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                    If Nvl(r_Time.挂号状态, 0) = 0 Then
                      v_Temp   := v_Temp || '<SL>1</SL></SPAN>';
                      n_Exists := n_Exists + 1;
                    Else
                      v_Temp := v_Temp || '<SL>0</SL></SPAN>';
                    End If;
                  Else
                    If Nvl(r_Time.挂号状态, 0) = 0 Then
                      n_时段剩余 := n_时段剩余 + 1;
                      n_Exists   := n_Exists + 1;
                    End If;
                  End If;
                End If;
              End Loop;
              If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                              To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                              n_时段剩余 || '</SL>' || '</SPAN>';
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
              End If;
            
              If n_Exists < To_Number(v_剩余数量) And r_No.替诊开始时间 Is Null Then
                v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_加号时间, 'hh24:mi:ss') || '-' || '</SJD><SL>' ||
                          To_Number(v_剩余数量 - n_Exists) || '</SL></SPAN>';
              End If;
              v_Temp := v_Temp || '</SPANLIST>';
            End If;
          Else
            --传入合作单位
            n_已挂数 := r_No.已挂数;
            Begin
              Select 控制方式
              Into n_合约模式
              From 临床出诊挂号控制记录
              Where 记录id = r_No.记录id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1 And Rownum < 2;
            Exception
              When Others Then
                n_合约模式 := 4;
            End;
            If n_合约模式 = 0 Then
              n_禁用 := 1;
            End If;
            If n_合约模式 = 1 Or n_合约模式 = 2 Then
              Select 数量
              Into n_合约总数量
              From 临床出诊挂号控制记录
              Where 记录id = r_No.记录id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1;
              If n_合约模式 = 1 Then
                n_合约总数量 := Round(r_No.限号数 * n_合约总数量 / 100);
              End If;
              Select Count(1)
              Into n_合约已挂数
              From 病人挂号记录
              Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                    Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
              n_合约剩余数量 := n_合约总数量 - n_合约已挂数;
              If r_No.限号数 - Nvl(r_No.已挂数, 0) < n_合约剩余数量 Then
                v_剩余数量 := r_No.限号数 - Nvl(r_No.已挂数, 0);
              Else
                v_剩余数量 := n_合约剩余数量;
              End If;
              If r_No.分时段 = 1 And r_No.序号控制 = 1 Then
                --分时段
                v_Temp   := '<SPANLIST>';
                n_Exists := 0;
                Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
                For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                               From 临床出诊序号控制
                               Where 记录id = r_No.记录id And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                                     Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1) Loop
                  If Nvl(n_时间间隔, 0) <> 0 Then
                    If d_时段开始 Is Null Then
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                      n_时段总数 := n_时段总数 + 1;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      If r_Time.开始时间 >= d_时段结束 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 1;
                        n_时段剩余 := 0;
                        d_时段开始 := r_Time.开始时间;
                        d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                        If d_加号时间 < d_时段结束 Then
                          d_时段结束 := d_加号时间;
                        End If;
                      Else
                        n_时段总数 := n_时段总数 + 1;
                      End If;
                    End If;
                  End If;
                  If r_Time.开始时间 > Sysdate Then
                    If Nvl(n_时间间隔, 0) = 0 Then
                      v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                      If Nvl(r_Time.挂号状态, 0) = 0 Then
                        v_Temp   := v_Temp || '<SL>1</SL></SPAN>';
                        n_Exists := n_Exists + 1;
                      Else
                        v_Temp := v_Temp || '<SL>0</SL></SPAN>';
                      End If;
                    Else
                      If Nvl(r_Time.挂号状态, 0) = 0 Then
                        n_时段剩余 := n_时段剩余 + 1;
                        n_Exists   := n_Exists + 1;
                      End If;
                    End If;
                  End If;
                End Loop;
                If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                  v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                                n_时段剩余 || '</SL>' || '</SPAN>';
                  n_时段总数 := 0;
                  n_时段剩余 := 0;
                  d_时段开始 := Null;
                  d_时段结束 := Null;
                End If;
                If n_Exists < To_Number(v_剩余数量) And r_No.替诊开始时间 Is Null Then
                  v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_加号时间, 'hh24:mi:ss') || '-' || '</SJD><SL>' ||
                            To_Number(v_剩余数量 - n_Exists) || '</SL></SPAN>';
                End If;
                v_Temp := v_Temp || '</SPANLIST>';
              End If;
            End If;
            If n_合约模式 = 3 Then
              If n_序号控制 = 0 Then
                n_已挂数   := r_No.已挂数;
                v_剩余数量 := r_No.限号数 - Nvl(r_No.已挂数, 0) - (Nvl(r_No.已约数, 0) - Nvl(r_No.已接收, 0));
              Else
                n_已挂数   := 0;
                v_剩余数量 := 0;
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
                For r_合作 In (Select 序号
                             From 临床出诊挂号控制记录
                             Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位) Loop
                  Begin
                    Select 1, 开始时间, 终止时间
                    Into n_Exists, d_开始时间, d_终止时间
                    From 临床出诊序号控制
                    Where 序号 = r_合作.序号 And Nvl(挂号状态, 0) = 0 And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                          Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1;
                  Exception
                    When Others Then
                      n_Exists := 0;
                  End;
                  If Nvl(n_时间间隔, 0) <> 0 Then
                    If d_时段开始 Is Null Then
                      d_时段开始 := d_开始时间;
                      d_时段结束 := d_开始时间 + 1 / 24 / 60 * n_时间间隔;
                      n_时段总数 := n_时段总数 + 1;
                    Else
                      If d_开始时间 >= d_时段结束 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 1;
                        n_时段剩余 := 0;
                        d_时段开始 := d_开始时间;
                        d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                      Else
                        n_时段总数 := n_时段总数 + 1;
                      End If;
                    End If;
                  End If;
                  If n_Exists = 1 Then
                    v_剩余数量 := v_剩余数量 + 1;
                    If r_No.分时段 = 1 Then
                      If d_开始时间 > Sysdate Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(d_终止时间, 'hh24:mi:ss') || '</SJD><SL>1</SL></SPAN>';
                        Else
                          n_时段剩余 := n_时段剩余 + 1;
                        End If;
                      End If;
                    End If;
                  Else
                    n_已挂数 := n_已挂数 + 1;
                  End If;
                End Loop;
                If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                  v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                                n_时段剩余 || '</SL>' || '</SPAN>';
                  n_时段总数 := 0;
                  n_时段剩余 := 0;
                  d_时段开始 := Null;
                  d_时段结束 := Null;
                End If;
                If v_Temp Is Not Null Then
                  v_Temp := '<SPANLIST>' || v_Temp || '</SPANLIST>';
                End If;
              End If;
            End If;
            If n_合约模式 = 4 Then
              n_已挂数   := r_No.已挂数;
              v_剩余数量 := r_No.限号数 - Nvl(r_No.已挂数, 0) - (Nvl(r_No.已约数, 0) - Nvl(r_No.已接收, 0));
              If r_No.分时段 = 1 And r_No.序号控制 = 1 Then
                --分时段
                v_Temp   := '<SPANLIST>';
                n_Exists := 0;
                Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
                For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                               From 临床出诊序号控制
                               Where 记录id = r_No.记录id And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                                     Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1) Loop
                  If Nvl(n_时间间隔, 0) <> 0 Then
                    If d_时段开始 Is Null Then
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                      n_时段总数 := n_时段总数 + 1;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      If r_Time.开始时间 >= d_时段结束 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 1;
                        n_时段剩余 := 0;
                        d_时段开始 := r_Time.开始时间;
                        d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                        If d_加号时间 < d_时段结束 Then
                          d_时段结束 := d_加号时间;
                        End If;
                      Else
                        n_时段总数 := n_时段总数 + 1;
                      End If;
                    End If;
                  End If;
                  If r_Time.开始时间 > Sysdate Then
                    If Nvl(n_时间间隔, 0) = 0 Then
                      v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                      If Nvl(r_Time.挂号状态, 0) = 0 Then
                        v_Temp   := v_Temp || '<SL>1</SL></SPAN>';
                        n_Exists := n_Exists + 1;
                      Else
                        v_Temp := v_Temp || '<SL>0</SL></SPAN>';
                      End If;
                    Else
                      If Nvl(r_Time.挂号状态, 0) = 0 Then
                        n_时段剩余 := n_时段剩余 + 1;
                        n_Exists   := n_Exists + 1;
                      End If;
                    End If;
                  End If;
                End Loop;
                If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                  v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                                n_时段剩余 || '</SL>' || '</SPAN>';
                  n_时段总数 := 0;
                  n_时段剩余 := 0;
                  d_时段开始 := Null;
                  d_时段结束 := Null;
                End If;
                If n_Exists < To_Number(v_剩余数量) And r_No.替诊开始时间 Is Null Then
                  v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_加号时间, 'hh24:mi:ss') || '-' || '</SJD><SL>' ||
                            To_Number(v_剩余数量 - n_Exists) || '</SL></SPAN>';
                End If;
                v_Temp := v_Temp || '</SPANLIST>';
              End If;
            End If;
          End If;
        Else
          --预约挂号
          If r_No.预约控制 = 1 Then
            n_禁用 := 1;
          Else
            --不限制预约
            If v_合作单位 Is Null Then
              If r_No.分时段 = 0 Then
                n_已挂数   := r_No.已约数;
                v_剩余数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
              Else
                --分时段
                n_已挂数   := 0;
                v_剩余数量 := 0;
                v_Temp     := '<SPANLIST>';
                If r_No.序号控制 = 0 Then
                  --非序号控制分时段预约
                  n_时段总数 := 0;
                  n_时段剩余 := 0;
                  d_时段开始 := Null;
                  d_时段结束 := Null;
                  Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                  For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态, 数量
                                 From 临床出诊序号控制
                                 Where 记录id = r_No.记录id And 预约顺序号 Is Null And 是否预约 = 1 And
                                       开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) And
                                       开始时间 Not Between Nvl(r_No.停诊开始时间, Sysdate) And Nvl(r_No.停诊终止时间, Sysdate - 1)) Loop
                    If Nvl(n_时间间隔, 0) <> 0 Then
                      If d_时段开始 Is Null Then
                        d_时段开始 := r_Time.开始时间;
                        d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                        n_时段总数 := n_时段总数 + r_Time.数量;
                        If d_加号时间 < d_时段结束 Then
                          d_时段结束 := d_加号时间;
                        End If;
                      Else
                        If r_Time.开始时间 >= d_时段结束 Then
                          v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                        To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                        '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                          n_时段总数 := r_Time.数量;
                          n_时段剩余 := 0;
                          d_时段开始 := r_Time.开始时间;
                          d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                          If d_加号时间 < d_时段结束 Then
                            d_时段结束 := d_加号时间;
                          End If;
                        Else
                          n_时段总数 := n_时段总数 + r_Time.数量;
                        End If;
                      End If;
                    End If;
                    Select Count(1)
                    Into n_时段已挂
                    From 临床出诊序号控制
                    Where 预约顺序号 Is Not Null And Nvl(挂号状态, 0) <> 0;
                    If r_Time.开始时间 > Sysdate Then
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                        v_Temp := v_Temp || '<SL>' || r_Time.数量 - n_时段已挂 || '</SL></SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + r_Time.数量 - n_时段已挂;
                      End If;
                      n_已挂数   := n_已挂数 + n_时段已挂;
                      v_剩余数量 := v_剩余数量 + (r_Time.数量 - n_时段已挂);
                    End If;
                  End Loop;
                  If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                    v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                  To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                  '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                    n_时段总数 := 0;
                    n_时段剩余 := 0;
                    d_时段开始 := Null;
                    d_时段结束 := Null;
                  End If;
                Else
                  n_时段总数 := 0;
                  n_时段剩余 := 0;
                  d_时段开始 := Null;
                  d_时段结束 := Null;
                  Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                  For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                                 From 临床出诊序号控制
                                 Where 记录id = r_No.记录id And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                                       Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1) Loop
                    If Nvl(n_时间间隔, 0) <> 0 Then
                      If d_时段开始 Is Null Then
                        d_时段开始 := r_Time.开始时间;
                        d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                        n_时段总数 := n_时段总数 + 1;
                        If d_加号时间 < d_时段结束 Then
                          d_时段结束 := d_加号时间;
                        End If;
                      Else
                        If r_Time.开始时间 >= d_时段结束 Then
                          v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                        To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                        '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                          n_时段总数 := 1;
                          n_时段剩余 := 0;
                          d_时段开始 := r_Time.开始时间;
                          d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                          If d_加号时间 < d_时段结束 Then
                            d_时段结束 := d_加号时间;
                          End If;
                        Else
                          n_时段总数 := n_时段总数 + 1;
                        End If;
                      End If;
                    End If;
                    If r_Time.开始时间 > Sysdate Then
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                        If Nvl(r_Time.挂号状态, 0) = 0 Then
                          v_Temp     := v_Temp || '<SL>1</SL></SPAN>';
                          v_剩余数量 := v_剩余数量 + 1;
                        Else
                          v_Temp   := v_Temp || '<SL>0</SL></SPAN>';
                          n_已挂数 := n_已挂数 + 1;
                        End If;
                      Else
                        If Nvl(r_Time.挂号状态, 0) = 0 Then
                          n_时段剩余 := n_时段剩余 + 1;
                          v_剩余数量 := v_剩余数量 + 1;
                        Else
                          n_已挂数 := n_已挂数 + 1;
                        End If;
                        n_时段剩余 := n_时段剩余 + 1;
                      End If;
                    End If;
                  End Loop;
                  If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                    v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                  To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                  '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                    n_时段总数 := 0;
                    n_时段剩余 := 0;
                    d_时段开始 := Null;
                    d_时段结束 := Null;
                  End If;
                End If;
                v_Temp := v_Temp || '</SPANLIST>';
              End If;
            Else
              --合作单位预约挂号
              If r_No.预约控制 = 2 Then
                n_禁用 := 1;
              Else
                Begin
                  Select 控制方式
                  Into n_合约模式
                  From 临床出诊挂号控制记录
                  Where 记录id = r_No.记录id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1 And Rownum < 2;
                Exception
                  When Others Then
                    n_合约模式 := 4;
                End;
                If n_合约模式 = 0 Then
                  n_禁用 := 1;
                End If;
                If n_合约模式 = 1 Or n_合约模式 = 2 Then
                  Select 数量
                  Into n_合约总数量
                  From 临床出诊挂号控制记录
                  Where 记录id = r_No.记录id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1;
                  If n_合约模式 = 1 Then
                    n_合约总数量 := Round(r_No.限号数 * n_合约总数量 / 100);
                  End If;
                  Begin
                    Select Count(1)
                    Into n_合约已挂数
                    From 病人挂号记录
                    Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                          Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
                  Exception
                    When Others Then
                      n_合约已挂数 := 0;
                  End;
                  n_合约剩余数量 := n_合约总数量 - n_合约已挂数;
                  If Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0) < n_合约剩余数量 Then
                    v_剩余数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
                  Else
                    v_剩余数量 := n_合约剩余数量;
                  End If;
                  If r_No.分时段 = 1 Then
                    v_Temp := '<SPANLIST>';
                    If r_No.序号控制 = 1 Then
                      --分时段,序号控制
                      n_Exists   := 0;
                      n_时段总数 := 0;
                      n_时段剩余 := 0;
                      d_时段开始 := Null;
                      d_时段结束 := Null;
                      Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                      For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                                     From 临床出诊序号控制
                                     Where 记录id = r_No.记录id And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                                           Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1) Loop
                        If Nvl(n_时间间隔, 0) <> 0 Then
                          If d_时段开始 Is Null Then
                            d_时段开始 := r_Time.开始时间;
                            d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                            n_时段总数 := n_时段总数 + 1;
                            If d_加号时间 < d_时段结束 Then
                              d_时段结束 := d_加号时间;
                            End If;
                          Else
                            If r_Time.开始时间 >= d_时段结束 Then
                              v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                            To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 ||
                                            '</GHZS>' || '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                              n_时段总数 := 1;
                              n_时段剩余 := 0;
                              d_时段开始 := r_Time.开始时间;
                              d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                              If d_加号时间 < d_时段结束 Then
                                d_时段结束 := d_加号时间;
                              End If;
                            Else
                              n_时段总数 := n_时段总数 + 1;
                            End If;
                          End If;
                        End If;
                        If r_Time.开始时间 > Sysdate Then
                          If Nvl(n_时间间隔, 0) = 0 Then
                            v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                            If Nvl(r_Time.挂号状态, 0) = 0 Then
                              v_Temp   := v_Temp || '<SL>1</SL></SPAN>';
                              n_Exists := n_Exists + 1;
                            Else
                              v_Temp := v_Temp || '<SL>0</SL></SPAN>';
                            End If;
                          Else
                            n_Exists   := n_Exists + 1;
                            n_时段剩余 := n_时段剩余 + 1;
                          End If;
                        End If;
                      End Loop;
                      If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 0;
                        n_时段剩余 := 0;
                        d_时段开始 := Null;
                        d_时段结束 := Null;
                      End If;
                      If n_Exists < To_Number(v_剩余数量) Then
                        v_剩余数量 := n_Exists;
                      End If;
                    Else
                      --分时段,非序号控制
                      n_Exists   := 0;
                      n_时段总数 := 0;
                      n_时段剩余 := 0;
                      d_时段开始 := Null;
                      d_时段结束 := Null;
                      Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                      For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态, 数量
                                     From 临床出诊序号控制
                                     Where 记录id = r_No.记录id And 预约顺序号 Is Null And 是否预约 = 1 And
                                           开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) And
                                           开始时间 Not Between Nvl(r_No.停诊开始时间, Sysdate) And Nvl(r_No.停诊终止时间, Sysdate - 1)) Loop
                        If Nvl(n_时间间隔, 0) <> 0 Then
                          If d_时段开始 Is Null Then
                            d_时段开始 := r_Time.开始时间;
                            d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                            n_时段总数 := n_时段总数 + r_Time.数量;
                            If d_加号时间 < d_时段结束 Then
                              d_时段结束 := d_加号时间;
                            End If;
                          Else
                            If r_Time.开始时间 >= d_时段结束 Then
                              v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                            To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 ||
                                            '</GHZS>' || '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                              n_时段总数 := r_Time.数量;
                              n_时段剩余 := 0;
                              d_时段开始 := r_Time.开始时间;
                              d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                              If d_加号时间 < d_时段结束 Then
                                d_时段结束 := d_加号时间;
                              End If;
                            Else
                              n_时段总数 := n_时段总数 + r_Time.数量;
                            End If;
                          End If;
                        End If;
                        Select Count(1)
                        Into n_时段已挂
                        From 临床出诊序号控制
                        Where 预约顺序号 Is Not Null And Nvl(挂号状态, 0) <> 0;
                        If r_Time.开始时间 > Sysdate Then
                          If Nvl(n_时间间隔, 0) = 0 Then
                            v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                            v_Temp := v_Temp || '<SL>' || r_Time.数量 - n_时段已挂 || '</SL></SPAN>';
                          Else
                            n_时段剩余 := n_时段剩余 + (r_Time.数量 - n_时段已挂);
                          End If;
                          n_Exists := n_Exists + (r_Time.数量 - n_时段已挂);
                        End If;
                      End Loop;
                      If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 0;
                        n_时段剩余 := 0;
                        d_时段开始 := Null;
                        d_时段结束 := Null;
                      End If;
                      If n_Exists < To_Number(v_剩余数量) Then
                        v_剩余数量 := n_Exists;
                      End If;
                    End If;
                    v_Temp := v_Temp || '</SPANLIST>';
                  End If;
                  n_已挂数 := r_No.已约数;
                End If;
                If n_合约模式 = 3 Then
                  If r_No.分时段 = 0 Then
                    If r_No.序号控制 = 0 Then
                      n_禁用 := 1;
                    Else
                      n_已挂数   := 0;
                      v_剩余数量 := 0;
                      For r_合作 In (Select 序号
                                   From 临床出诊挂号控制记录
                                   Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位) Loop
                        Begin
                          Select 1
                          Into n_Exists
                          From 临床出诊序号控制
                          Where 记录id = r_No.记录id And 序号 = r_合作.序号 And 是否预约 = 1 And Nvl(挂号状态, 0) = 0 And
                                开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) And
                                Nvl(是否停诊, 0) <> 1;
                        Exception
                          When Others Then
                            n_Exists := 0;
                        End;
                        If n_Exists = 1 Then
                          v_剩余数量 := v_剩余数量 + 1;
                        Else
                          n_已挂数 := n_已挂数 + 1;
                        End If;
                      End Loop;
                      If Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0) < v_剩余数量 Then
                        v_剩余数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
                      End If;
                    End If;
                  Else
                    If r_No.序号控制 = 0 Then
                      --合作单位,分时段,非序号控制
                      n_已挂数   := 0;
                      v_剩余数量 := 0;
                      v_Temp     := '<SPANLIST>';
                      n_时段总数 := 0;
                      n_时段剩余 := 0;
                      d_时段开始 := Null;
                      d_时段结束 := Null;
                      For r_合作 In (Select 序号, 数量
                                   From 临床出诊挂号控制记录
                                   Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位) Loop
                        Begin
                          Select Count(1), Max(开始时间), Max(终止时间)
                          Into n_时段已挂, d_开始时间, d_终止时间
                          From 临床出诊序号控制
                          Where 记录id = r_No.记录id And 预约顺序号 Is Not Null And Nvl(挂号状态, 0) <> 0 And 序号 = r_合作.序号 And
                                开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1);
                        
                          If Nvl(n_时间间隔, 0) <> 0 Then
                            If d_时段开始 Is Null Then
                              d_时段开始 := d_开始时间;
                              d_时段结束 := d_开始时间 + 1 / 24 / 60 * n_时间间隔;
                              n_时段总数 := n_时段总数 + r_合作.数量;
                            Else
                              If d_开始时间 >= d_时段结束 Then
                                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                              To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 ||
                                              '</GHZS>' || '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                                n_时段总数 := r_合作.数量;
                                n_时段剩余 := 0;
                                d_时段开始 := d_开始时间;
                                d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                              Else
                                n_时段总数 := n_时段总数 + r_合作.数量;
                              End If;
                            End If;
                          End If;
                          If d_开始时间 > Sysdate Then
                            n_已挂数 := n_已挂数 + n_时段已挂;
                            If Nvl(n_时间间隔, 0) = 0 Then
                              v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(d_终止时间, 'hh24:mi:ss') || '</SJD>';
                              v_Temp := v_Temp || '<SL>' || r_合作.数量 - n_时段已挂 || '</SL></SPAN>';
                            Else
                              n_时段剩余 := n_时段剩余 + r_合作.数量 - n_时段已挂;
                            End If;
                            v_剩余数量 := v_剩余数量 + r_合作.数量 - n_时段已挂;
                          End If;
                        Exception
                          When Others Then
                            Null;
                        End;
                      End Loop;
                      If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 0;
                        n_时段剩余 := 0;
                        d_时段开始 := Null;
                        d_时段结束 := Null;
                      End If;
                      v_Temp := v_Temp || '</SPANLIST>';
                    Else
                      n_已挂数   := 0;
                      v_剩余数量 := 0;
                      v_Temp     := '<SPANLIST>';
                      n_时段总数 := 0;
                      n_时段剩余 := 0;
                      d_时段开始 := Null;
                      d_时段结束 := Null;
                      For r_合作 In (Select 序号
                                   From 临床出诊挂号控制记录
                                   Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位) Loop
                        Begin
                          Select 1, 开始时间, 终止时间
                          Into n_Exists, d_开始时间, d_终止时间
                          From 临床出诊序号控制
                          Where 记录id = r_No.记录id And Nvl(挂号状态, 0) = 0 And 序号 = r_合作.序号 And
                                开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) And
                                Nvl(是否停诊, 0) <> 1;
                        Exception
                          When Others Then
                            n_Exists := 0;
                        End;
                        If Nvl(n_时间间隔, 0) <> 0 Then
                          If d_时段开始 Is Null Then
                            d_时段开始 := d_开始时间;
                            d_时段结束 := d_开始时间 + 1 / 24 / 60 * n_时间间隔;
                            n_时段总数 := n_时段总数 + 1;
                          Else
                            If d_开始时间 >= d_时段结束 Then
                              v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                            To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 ||
                                            '</GHZS>' || '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                              n_时段总数 := 1;
                              n_时段剩余 := 0;
                              d_时段开始 := d_开始时间;
                              d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                            Else
                              n_时段总数 := n_时段总数 + 1;
                            End If;
                          End If;
                        End If;
                        If d_开始时间 > Sysdate Then
                          If n_Exists = 1 Then
                            v_剩余数量 := v_剩余数量 + 1;
                            If Nvl(n_时间间隔, 0) = 0 Then
                              v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(d_终止时间, 'hh24:mi:ss') || '</SJD>';
                              v_Temp := v_Temp || '<SL>' || 1 || '</SL></SPAN>';
                            Else
                              n_时段剩余 := n_时段剩余 + 1;
                            End If;
                          Else
                            If Nvl(n_时间间隔, 0) = 0 Then
                              v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(d_终止时间, 'hh24:mi:ss') || '</SJD>';
                              v_Temp := v_Temp || '<SL>' || 0 || '</SL></SPAN>';
                            End If;
                            n_已挂数 := n_已挂数 + 1;
                          End If;
                        End If;
                      End Loop;
                      If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 0;
                        n_时段剩余 := 0;
                        d_时段开始 := Null;
                        d_时段结束 := Null;
                      End If;
                    End If;
                  End If;
                End If;
                If n_合约模式 = 4 Then
                  If r_No.分时段 = 0 Then
                    n_已挂数   := r_No.已约数;
                    v_剩余数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
                  Else
                    --分时段
                    n_已挂数   := 0;
                    v_剩余数量 := 0;
                    v_Temp     := '<SPANLIST>';
                    n_时段总数 := 0;
                    n_时段剩余 := 0;
                    d_时段开始 := Null;
                    d_时段结束 := Null;
                    Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                    If r_No.序号控制 = 0 Then
                      --非序号控制分时段预约
                      For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态, 数量
                                     From 临床出诊序号控制
                                     Where 记录id = r_No.记录id And 预约顺序号 Is Null And 是否预约 = 1 And
                                           开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) And
                                           开始时间 Not Between Nvl(r_No.停诊开始时间, Sysdate) And Nvl(r_No.停诊终止时间, Sysdate - 1)) Loop
                        If Nvl(n_时间间隔, 0) <> 0 Then
                          If d_时段开始 Is Null Then
                            d_时段开始 := r_Time.开始时间;
                            d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                            n_时段总数 := n_时段总数 + r_Time.数量;
                            If d_加号时间 < d_时段结束 Then
                              d_时段结束 := d_加号时间;
                            End If;
                          Else
                            If r_Time.开始时间 >= d_时段结束 Then
                              v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                            To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 ||
                                            '</GHZS>' || '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                              n_时段总数 := r_Time.数量;
                              n_时段剩余 := 0;
                              d_时段开始 := r_Time.开始时间;
                              d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                              If d_加号时间 < d_时段结束 Then
                                d_时段结束 := d_加号时间;
                              End If;
                            Else
                              n_时段总数 := n_时段总数 + r_Time.数量;
                            End If;
                          End If;
                        End If;
                        Select Count(1)
                        Into n_时段已挂
                        From 临床出诊序号控制
                        Where 预约顺序号 Is Not Null And Nvl(挂号状态, 0) <> 0;
                        If r_Time.开始时间 > Sysdate Then
                          If Nvl(n_时间间隔, 0) = 0 Then
                            v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                            v_Temp := v_Temp || '<SL>' || r_Time.数量 - n_时段已挂 || '</SL></SPAN>';
                          Else
                            n_时段剩余 := n_时段剩余 + (r_Time.数量 - n_时段已挂);
                          End If;
                          n_已挂数   := n_已挂数 + n_时段已挂;
                          v_剩余数量 := v_剩余数量 + (r_Time.数量 - n_时段已挂);
                        End If;
                      End Loop;
                      If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 0;
                        n_时段剩余 := 0;
                        d_时段开始 := Null;
                        d_时段结束 := Null;
                      End If;
                    Else
                      n_时段总数 := 0;
                      n_时段剩余 := 0;
                      d_时段开始 := Null;
                      d_时段结束 := Null;
                      For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                                     From 临床出诊序号控制
                                     Where 记录id = r_No.记录id And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                                           Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1) Loop
                        If Nvl(n_时间间隔, 0) <> 0 Then
                          If d_时段开始 Is Null Then
                            d_时段开始 := r_Time.开始时间;
                            d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                            n_时段总数 := n_时段总数 + 1;
                            If d_加号时间 < d_时段结束 Then
                              d_时段结束 := d_加号时间;
                            End If;
                          Else
                            If r_Time.开始时间 >= d_时段结束 Then
                              v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                            To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 ||
                                            '</GHZS>' || '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                              n_时段总数 := 1;
                              n_时段剩余 := 0;
                              d_时段开始 := r_Time.开始时间;
                              d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                              If d_加号时间 < d_时段结束 Then
                                d_时段结束 := d_加号时间;
                              End If;
                            Else
                              n_时段总数 := n_时段总数 + 1;
                            End If;
                          End If;
                        End If;
                        If r_Time.开始时间 > Sysdate Then
                          If Nvl(n_时间间隔, 0) = 0 Then
                            v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                            If Nvl(r_Time.挂号状态, 0) = 0 Then
                              v_Temp     := v_Temp || '<SL>1</SL></SPAN>';
                              v_剩余数量 := v_剩余数量 + 1;
                            Else
                              v_Temp   := v_Temp || '<SL>0</SL></SPAN>';
                              n_已挂数 := n_已挂数 + 1;
                            End If;
                          Else
                            If Nvl(r_Time.挂号状态, 0) = 0 Then
                              n_时段剩余 := n_时段剩余 + 1;
                              v_剩余数量 := v_剩余数量 + 1;
                            Else
                              n_已挂数 := n_已挂数 + 1;
                            End If;
                          End If;
                        End If;
                      End Loop;
                      If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 0;
                        n_时段剩余 := 0;
                        d_时段开始 := Null;
                        d_时段结束 := Null;
                      End If;
                    End If;
                    v_Temp := v_Temp || '</SPANLIST>';
                  End If;
                End If;
              End If;
            End If;
          End If;
        End If;
      
        If Not (r_No.分时段 = 1 And r_No.序号控制 = 1) Then
          If d_日期 Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) Then
            n_禁用 := 1;
          End If;
          If d_日期 Between Nvl(r_No.停诊开始时间, Sysdate) And Nvl(r_No.停诊终止时间, Sysdate - 1) Then
            n_禁用 := 1;
          End If;
        End If;
      
        If Nvl(n_禁用, 0) = 0 Then
          n_合计金额 := 0;
          For r_Fee In (Select b.现价, a.从项数次
                        From 收费从属项目 A, 收费价目 B
                        Where a.主项id = r_No.项目id And a.从项id = b.收费细目id And Sysdate Between b.执行日期 And
                              Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And
                              (b.价格等级 = v_普通等级 Or
                              (b.价格等级 Is Null And Not Exists
                               (Select 1
                                 From 收费价目
                                 Where b.收费细目id = 收费细目id And 价格等级 = v_普通等级 And Sysdate Between 执行日期 And
                                       Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')))))
                        Union
                        Select b.现价, 1 As 从项数次
                        From 收费项目目录 A, 收费价目 B
                        Where a.Id = b.收费细目id And a.Id = r_No.项目id And Sysdate Between b.执行日期 And
                              Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And
                              (b.价格等级 = v_普通等级 Or
                              (b.价格等级 Is Null And Not Exists
                               (Select 1
                                 From 收费价目
                                 Where b.收费细目id = 收费细目id And 价格等级 = v_普通等级 And Sysdate Between 执行日期 And
                                       Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')))))) Loop
            n_合计金额 := n_合计金额 + r_Fee.现价 * r_Fee.从项数次;
          End Loop;
          v_时间段 := To_Char(r_No.开始时间, 'HH24:MI') || '-' || To_Char(r_No.终止时间, 'HH24:MI');
          If Trunc(Sysdate) = Trunc(d_日期) Then
            c_Xmlmain := '<HB>' || '<CZJLID>' || r_No.记录id || '</CZJLID>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' ||
                         r_No.医生id || '</YSID>' || '<YS>' || r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id || '</KSID>' ||
                         '<KSMC>' || r_No.科室名称 || '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' || r_No.项目id ||
                         '</XMID>' || '<XMMC>' || r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 || '</YGHS>' || '<SYHS>' ||
                         v_剩余数量 || '</SYHS>' || '<PRICE>' || n_合计金额 || '</PRICE>' || '<HL>' || r_No.号类 || '</HL>' ||
                         '<FSD>' || r_No.分时段 || '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' || '<FWMC>' || r_No.排班 ||
                         '</FWMC>' || v_Temp || '</HB>';
            v_Xmlmain := v_Xmlmain || c_Xmlmain;
          Else
            If r_No.已约数 >= r_No.限约数 Then
              c_Xmlmain := '<HB>' || '<CZJLID>' || r_No.记录id || '</CZJLID>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' ||
                           r_No.医生id || '</YSID>' || '<YS>' || r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id ||
                           '</KSID>' || '<KSMC>' || r_No.科室名称 || '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' ||
                           r_No.项目id || '</XMID>' || '<XMMC>' || r_No.项目名称 || '</XMMC>' || '<YGHS>' || r_No.已约数 ||
                           '</YGHS>' || '<SYHS>' || 0 || '</SYHS>' || '<PRICE>' || n_合计金额 || '</PRICE>' || '<HL>' ||
                           r_No.号类 || '</HL>' || '<FSD>' || r_No.分时段 || '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' ||
                           '<FWMC>' || r_No.排班 || '</FWMC>' || '</HB>';
              v_Xmlmain := v_Xmlmain || c_Xmlmain;
            Else
              c_Xmlmain := '<HB>' || '<CZJLID>' || r_No.记录id || '</CZJLID>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' ||
                           r_No.医生id || '</YSID>' || '<YS>' || r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id ||
                           '</KSID>' || '<KSMC>' || r_No.科室名称 || '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' ||
                           r_No.项目id || '</XMID>' || '<XMMC>' || r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 ||
                           '</YGHS>' || '<SYHS>' || v_剩余数量 || '</SYHS>' || '<PRICE>' || n_合计金额 || '</PRICE>' || '<HL>' ||
                           r_No.号类 || '</HL>' || '<FSD>' || r_No.分时段 || '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' ||
                           '<FWMC>' || r_No.排班 || '</FWMC>' || v_Temp || '</HB>';
              v_Xmlmain := v_Xmlmain || c_Xmlmain;
            End If;
          End If;
        End If;
      End If;
      n_禁用 := 0;
    End Loop;
  
    --加入替诊号源
    n_合约剩余数量 := 0;
    For r_No In (Select a.科室id, b.号类, c.名称 As 科室名称, a.替诊医生姓名 As 医生姓名, a.替诊医生id As 医生id, d.专业技术职务 As 职称, b.号码,
                        a.Id As 记录id, a.上班时段 As 排班, a.项目id, e.名称 As 项目名称, a.是否序号控制 As 序号控制, a.限号数,
                        Nvl(a.限约数, a.限号数) As 限约数, Nvl(a.已挂数, 0) As 已挂数, Nvl(a.已约数, 0) As 已约数, Nvl(a.其中已接收, 0) As 已接收,
                        a.是否分时段 As 分时段, a.开始时间, a.终止时间, a.预约控制, a.替诊开始时间, a.替诊终止时间, Nvl(b.预约天数, n_预约天数) + n_补充天数 As 预约天数,
                        a.停诊开始时间, a.停诊终止时间
                 From 临床出诊记录 A, 临床出诊号源 B, 部门表 C, 人员表 D, 收费项目目录 E
                 Where a.出诊日期 = Trunc(d_日期) And a.替诊医生姓名 Is Not Null And a.终止时间 > Sysdate And a.号源id = b.Id And
                       a.项目id = e.Id And a.替诊医生id = d.Id(+) And b.科室id = c.Id And Nvl(a.是否锁定, 0) = 0 And
                       (a.开始时间 < Nvl(a.停诊开始时间, a.终止时间) Or a.终止时间 > Nvl(a.停诊终止时间, a.开始时间) Or Exists
                        (Select 1
                         From 临床出诊序号控制 C, 临床出诊记录 D
                         Where d.Id = a.Id And c.记录id = d.Id And Nvl(c.是否停诊, 0) = 0 And d.是否序号控制 = 1 And d.是否分时段 = 1 And
                               c.开始时间 <> c.终止时间)) And Nvl(a.是否发布, 0) = 1 And
                       a.开始时间 > Trunc(To_Date(v_启用时间, 'yyyy-mm-dd hh24:mi:ss')) And
                       Decode(Nvl(n_科室id, 0), 0, 0, b.科室id) = Nvl(n_科室id, 0) And
                       Decode(Nvl(n_医生id, 0), 0, 0, a.医生id) = Nvl(n_医生id, 0) And
                       Decode(Nvl(v_医生姓名, '-'), '-', '-', a.医生姓名) = Nvl(v_医生姓名, '-')) Loop
      v_Temp := '';
      If Sysdate + Nvl(r_No.预约天数, n_预约天数) + n_补充天数 >= d_日期 Then
        If Trunc(d_日期) = Trunc(Sysdate) Then
          --当天挂号
          If v_合作单位 Is Null Then
            --未传入合作单位
            n_已挂数   := r_No.已挂数;
            v_剩余数量 := r_No.限号数 - Nvl(r_No.已挂数, 0);
            If r_No.分时段 = 1 And r_No.序号控制 = 1 Then
              --分时段
              v_Temp     := '<SPANLIST>';
              n_Exists   := 0;
              n_时段总数 := 0;
              n_时段剩余 := 0;
              d_时段开始 := Null;
              d_时段结束 := Null;
              Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
              For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                             From 临床出诊序号控制
                             Where 记录id = r_No.记录id And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And
                                   Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1) Loop
                If Nvl(n_时间间隔, 0) <> 0 Then
                  If d_时段开始 Is Null Then
                    d_时段开始 := r_Time.开始时间;
                    d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                    n_时段总数 := n_时段总数 + 1;
                    If d_加号时间 < d_时段结束 Then
                      d_时段结束 := d_加号时间;
                    End If;
                  Else
                    If r_Time.开始时间 >= d_时段结束 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                    To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                    '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                      n_时段总数 := 1;
                      n_时段剩余 := 0;
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      n_时段总数 := n_时段总数 + 1;
                    End If;
                  End If;
                End If;
                If r_Time.开始时间 > Sysdate Then
                  If Nvl(n_时间间隔, 0) = 0 Then
                    v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                              To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                    If Nvl(r_Time.挂号状态, 0) = 0 Then
                      v_Temp   := v_Temp || '<SL>1</SL></SPAN>';
                      n_Exists := n_Exists + 1;
                    Else
                      v_Temp := v_Temp || '<SL>0</SL></SPAN>';
                    End If;
                  Else
                    If Nvl(r_Time.挂号状态, 0) = 0 Then
                      n_Exists   := n_Exists + 1;
                      n_时段剩余 := n_时段剩余 + 1;
                    End If;
                  End If;
                End If;
              End Loop;
              If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                              To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                              n_时段剩余 || '</SL>' || '</SPAN>';
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
              End If;
              If n_Exists < To_Number(v_剩余数量) And r_No.替诊开始时间 Is Null Then
                v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_加号时间, 'hh24:mi:ss') || '-' || '</SJD><SL>' ||
                          To_Number(v_剩余数量 - n_Exists) || '</SL></SPAN>';
              End If;
              v_Temp := v_Temp || '</SPANLIST>';
            End If;
          Else
            --传入合作单位
            n_已挂数 := r_No.已挂数;
            Begin
              Select 控制方式
              Into n_合约模式
              From 临床出诊挂号控制记录
              Where 记录id = r_No.记录id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1 And Rownum < 2;
            Exception
              When Others Then
                n_合约模式 := 4;
            End;
            If n_合约模式 = 0 Then
              n_禁用 := 1;
            End If;
            If n_合约模式 = 1 Or n_合约模式 = 2 Then
              Select 数量
              Into n_合约总数量
              From 临床出诊挂号控制记录
              Where 记录id = r_No.记录id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1;
              If n_合约模式 = 1 Then
                n_合约总数量 := Round(r_No.限号数 * n_合约总数量 / 100);
              End If;
              Select Count(1)
              Into n_合约已挂数
              From 病人挂号记录
              Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                    Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
              n_合约剩余数量 := n_合约总数量 - n_合约已挂数;
              If r_No.限号数 - Nvl(r_No.已挂数, 0) < n_合约剩余数量 Then
                v_剩余数量 := r_No.限号数 - Nvl(r_No.已挂数, 0);
              Else
                v_剩余数量 := n_合约剩余数量;
              End If;
              If r_No.分时段 = 1 And r_No.序号控制 = 1 Then
                --分时段
                v_Temp   := '<SPANLIST>';
                n_Exists := 0;
                Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
                For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                               From 临床出诊序号控制
                               Where 记录id = r_No.记录id And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And
                                     Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1) Loop
                
                  If Nvl(n_时间间隔, 0) <> 0 Then
                    If d_时段开始 Is Null Then
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                      n_时段总数 := n_时段总数 + 1;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      If r_Time.开始时间 >= d_时段结束 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 1;
                        n_时段剩余 := 0;
                        d_时段开始 := r_Time.开始时间;
                        d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                        If d_加号时间 < d_时段结束 Then
                          d_时段结束 := d_加号时间;
                        End If;
                      Else
                        n_时段总数 := n_时段总数 + 1;
                      End If;
                    End If;
                  End If;
                  If r_Time.开始时间 > Sysdate Then
                    If Nvl(n_时间间隔, 0) = 0 Then
                      v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                      If Nvl(r_Time.挂号状态, 0) = 0 Then
                        v_Temp   := v_Temp || '<SL>1</SL></SPAN>';
                        n_Exists := n_Exists + 1;
                      Else
                        v_Temp := v_Temp || '<SL>0</SL></SPAN>';
                      End If;
                    Else
                      If Nvl(r_Time.挂号状态, 0) = 0 Then
                        n_Exists   := n_Exists + 1;
                        n_时段剩余 := n_时段剩余 + 1;
                      End If;
                    End If;
                  End If;
                End Loop;
                If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                  v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                                n_时段剩余 || '</SL>' || '</SPAN>';
                  n_时段总数 := 0;
                  n_时段剩余 := 0;
                  d_时段开始 := Null;
                  d_时段结束 := Null;
                End If;
                If n_Exists < To_Number(v_剩余数量) And r_No.替诊开始时间 Is Null Then
                  v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_加号时间, 'hh24:mi:ss') || '-' || '</SJD><SL>' ||
                            To_Number(v_剩余数量 - n_Exists) || '</SL></SPAN>';
                End If;
                v_Temp := v_Temp || '</SPANLIST>';
              End If;
            End If;
            If n_合约模式 = 3 Then
              If n_序号控制 = 0 Then
                n_已挂数   := r_No.已挂数;
                v_剩余数量 := r_No.限号数 - Nvl(r_No.已挂数, 0);
              Else
                n_已挂数   := 0;
                v_剩余数量 := 0;
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
                For r_合作 In (Select 序号
                             From 临床出诊挂号控制记录
                             Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位) Loop
                  Begin
                    Select 1, 开始时间, 终止时间
                    Into n_Exists, d_开始时间, d_终止时间
                    From 临床出诊序号控制
                    Where 序号 = r_合作.序号 And Nvl(挂号状态, 0) = 0 And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And
                          Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1;
                  Exception
                    When Others Then
                      n_Exists := 0;
                  End;
                  If n_Exists = 1 Then
                    v_剩余数量 := v_剩余数量 + 1;
                    If r_No.分时段 = 1 Then
                    
                      If Nvl(n_时间间隔, 0) <> 0 Then
                        If d_时段开始 Is Null Then
                          d_时段开始 := d_开始时间;
                          d_时段结束 := d_开始时间 + 1 / 24 / 60 * n_时间间隔;
                          n_时段总数 := n_时段总数 + 1;
                        Else
                          If d_开始时间 >= d_时段结束 Then
                            v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                          To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                          '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                            n_时段总数 := 1;
                            n_时段剩余 := 0;
                            d_时段开始 := d_开始时间;
                            d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                          Else
                            n_时段总数 := n_时段总数 + 1;
                          End If;
                        End If;
                      End If;
                      If d_开始时间 > Sysdate Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(d_终止时间, 'hh24:mi:ss') || '</SJD><SL>1</SL></SPAN>';
                        Else
                          n_时段剩余 := n_时段剩余 + 1;
                        End If;
                      End If;
                    End If;
                  Else
                    n_已挂数 := n_已挂数 + 1;
                  End If;
                End Loop;
                If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                  v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                                n_时段剩余 || '</SL>' || '</SPAN>';
                  n_时段总数 := 0;
                  n_时段剩余 := 0;
                  d_时段开始 := Null;
                  d_时段结束 := Null;
                End If;
                If v_Temp Is Not Null Then
                  v_Temp := '<SPANLIST>' || v_Temp || '</SPANLIST>';
                End If;
              End If;
            End If;
            If n_合约模式 = 4 Then
              n_已挂数   := r_No.已挂数;
              v_剩余数量 := r_No.限号数 - Nvl(r_No.已挂数, 0);
              If r_No.分时段 = 1 And r_No.序号控制 = 1 Then
                --分时段
                v_Temp   := '<SPANLIST>';
                n_Exists := 0;
                Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
                For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                               From 临床出诊序号控制
                               Where 记录id = r_No.记录id And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And
                                     Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1) Loop
                
                  If Nvl(n_时间间隔, 0) <> 0 Then
                    If d_时段开始 Is Null Then
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                      n_时段总数 := n_时段总数 + 1;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      If r_Time.开始时间 >= d_时段结束 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 1;
                        n_时段剩余 := 0;
                        d_时段开始 := r_Time.开始时间;
                        d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                        If d_加号时间 < d_时段结束 Then
                          d_时段结束 := d_加号时间;
                        End If;
                      Else
                        n_时段总数 := n_时段总数 + 1;
                      End If;
                    End If;
                  End If;
                  If r_Time.开始时间 > Sysdate Then
                    If Nvl(n_时间间隔, 0) = 0 Then
                      v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                      If Nvl(r_Time.挂号状态, 0) = 0 Then
                        v_Temp   := v_Temp || '<SL>1</SL></SPAN>';
                        n_Exists := n_Exists + 1;
                      Else
                        v_Temp := v_Temp || '<SL>0</SL></SPAN>';
                      End If;
                    Else
                      If Nvl(r_Time.挂号状态, 0) = 0 Then
                        n_Exists   := n_Exists + 1;
                        n_时段剩余 := n_时段剩余 + 1;
                      End If;
                    End If;
                  End If;
                End Loop;
                If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                  v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                                n_时段剩余 || '</SL>' || '</SPAN>';
                  n_时段总数 := 0;
                  n_时段剩余 := 0;
                  d_时段开始 := Null;
                  d_时段结束 := Null;
                End If;
                If n_Exists < To_Number(v_剩余数量) And r_No.替诊开始时间 Is Null Then
                
                  v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_加号时间, 'hh24:mi:ss') || '-' || '</SJD><SL>' ||
                            To_Number(v_剩余数量 - n_Exists) || '</SL></SPAN>';
                End If;
                v_Temp := v_Temp || '</SPANLIST>';
              End If;
            End If;
          End If;
        Else
          --预约挂号
          If r_No.预约控制 = 1 Then
            n_禁用 := 1;
          Else
            --不限制预约
            If v_合作单位 Is Null Then
              If r_No.分时段 = 0 Then
                n_已挂数   := r_No.已约数;
                v_剩余数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
              Else
                --分时段
                n_已挂数   := 0;
                v_剩余数量 := 0;
                v_Temp     := '<SPANLIST>';
                If r_No.序号控制 = 0 Then
                  --非序号控制分时段预约
                  n_时段总数 := 0;
                  n_时段剩余 := 0;
                  d_时段开始 := Null;
                  d_时段结束 := Null;
                  Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                  For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态, 数量
                                 From 临床出诊序号控制
                                 Where 记录id = r_No.记录id And 预约顺序号 Is Null And 是否预约 = 1 And
                                       开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) And
                                       开始时间 Not Between Nvl(r_No.停诊开始时间, Sysdate) And Nvl(r_No.停诊终止时间, Sysdate - 1)) Loop
                    If Nvl(n_时间间隔, 0) <> 0 Then
                      If d_时段开始 Is Null Then
                        d_时段开始 := r_Time.开始时间;
                        d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                        n_时段总数 := n_时段总数 + r_Time.数量;
                        If d_加号时间 < d_时段结束 Then
                          d_时段结束 := d_加号时间;
                        End If;
                      Else
                        If r_Time.开始时间 >= d_时段结束 Then
                          v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                        To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                        '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                          n_时段总数 := r_Time.数量;
                          n_时段剩余 := 0;
                          d_时段开始 := r_Time.开始时间;
                          d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                          If d_加号时间 < d_时段结束 Then
                            d_时段结束 := d_加号时间;
                          End If;
                        Else
                          n_时段总数 := n_时段总数 + r_Time.数量;
                        End If;
                      End If;
                    End If;
                    Select Count(1)
                    Into n_时段已挂
                    From 临床出诊序号控制
                    Where 预约顺序号 Is Not Null And Nvl(挂号状态, 0) <> 0;
                    If r_Time.开始时间 > Sysdate Then
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                        v_Temp := v_Temp || '<SL>' || r_Time.数量 - n_时段已挂 || '</SL></SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + (r_Time.数量 - n_时段已挂);
                      End If;
                      n_已挂数   := n_已挂数 + n_时段已挂;
                      v_剩余数量 := v_剩余数量 + (r_Time.数量 - n_时段已挂);
                    End If;
                  End Loop;
                  If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                    v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                  To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                  '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                    n_时段总数 := 0;
                    n_时段剩余 := 0;
                    d_时段开始 := Null;
                    d_时段结束 := Null;
                  End If;
                Else
                  n_时段总数 := 0;
                  n_时段剩余 := 0;
                  d_时段开始 := Null;
                  d_时段结束 := Null;
                  Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                  For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                                 From 临床出诊序号控制
                                 Where 记录id = r_No.记录id And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And
                                       Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1) Loop
                    If Nvl(n_时间间隔, 0) <> 0 Then
                      If d_时段开始 Is Null Then
                        d_时段开始 := r_Time.开始时间;
                        d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                        n_时段总数 := n_时段总数 + 1;
                        If d_加号时间 < d_时段结束 Then
                          d_时段结束 := d_加号时间;
                        End If;
                      Else
                        If r_Time.开始时间 >= d_时段结束 Then
                          v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                        To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                        '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                          n_时段总数 := 1;
                          n_时段剩余 := 0;
                          d_时段开始 := r_Time.开始时间;
                          d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                          If d_加号时间 < d_时段结束 Then
                            d_时段结束 := d_加号时间;
                          End If;
                        Else
                          n_时段总数 := n_时段总数 + 1;
                        End If;
                      End If;
                    End If;
                    If r_Time.开始时间 > Sysdate Then
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                        If Nvl(r_Time.挂号状态, 0) = 0 Then
                          v_Temp     := v_Temp || '<SL>1</SL></SPAN>';
                          v_剩余数量 := v_剩余数量 + 1;
                        Else
                          v_Temp   := v_Temp || '<SL>0</SL></SPAN>';
                          n_已挂数 := n_已挂数 + 1;
                        End If;
                      Else
                        If Nvl(r_Time.挂号状态, 0) = 0 Then
                          n_时段剩余 := n_时段剩余 + 1;
                          v_剩余数量 := v_剩余数量 + 1;
                        Else
                          n_已挂数 := n_已挂数 + 1;
                        End If;
                      End If;
                    End If;
                  End Loop;
                  If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                    v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                  To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                  '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                    n_时段总数 := 0;
                    n_时段剩余 := 0;
                    d_时段开始 := Null;
                    d_时段结束 := Null;
                  End If;
                End If;
                v_Temp := v_Temp || '</SPANLIST>';
              End If;
            Else
              --合作单位预约挂号
              If r_No.预约控制 = 2 Then
                n_禁用 := 1;
              Else
                Begin
                  Select 控制方式
                  Into n_合约模式
                  From 临床出诊挂号控制记录
                  Where 记录id = r_No.记录id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1 And Rownum < 2;
                Exception
                  When Others Then
                    n_合约模式 := 4;
                End;
                If n_合约模式 = 0 Then
                  n_禁用 := 1;
                End If;
                If n_合约模式 = 1 Or n_合约模式 = 2 Then
                  Select 数量
                  Into n_合约总数量
                  From 临床出诊挂号控制记录
                  Where 记录id = r_No.记录id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1;
                  If n_合约模式 = 1 Then
                    n_合约总数量 := Round(r_No.限号数 * n_合约总数量 / 100);
                  End If;
                  Select Count(1)
                  Into n_合约已挂数
                  From 病人挂号记录
                  Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                        Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
                  n_合约剩余数量 := n_合约总数量 - n_合约已挂数;
                  If Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0) < n_合约剩余数量 Then
                    v_剩余数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
                  Else
                    v_剩余数量 := n_合约剩余数量;
                  End If;
                  If r_No.分时段 = 1 Then
                    v_Temp := '<SPANLIST>';
                    If r_No.序号控制 = 1 Then
                      --分时段,序号控制
                      n_Exists   := 0;
                      n_时段总数 := 0;
                      n_时段剩余 := 0;
                      d_时段开始 := Null;
                      d_时段结束 := Null;
                      Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                      For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                                     From 临床出诊序号控制
                                     Where 记录id = r_No.记录id And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And
                                           Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1) Loop
                      
                        If Nvl(n_时间间隔, 0) <> 0 Then
                          If d_时段开始 Is Null Then
                            d_时段开始 := r_Time.开始时间;
                            d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                            n_时段总数 := n_时段总数 + 1;
                            If d_加号时间 < d_时段结束 Then
                              d_时段结束 := d_加号时间;
                            End If;
                          Else
                            If r_Time.开始时间 >= d_时段结束 Then
                              v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                            To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 ||
                                            '</GHZS>' || '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                              n_时段总数 := 1;
                              n_时段剩余 := 0;
                              d_时段开始 := r_Time.开始时间;
                              d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                              If d_加号时间 < d_时段结束 Then
                                d_时段结束 := d_加号时间;
                              End If;
                            Else
                              n_时段总数 := n_时段总数 + 1;
                            End If;
                          End If;
                        End If;
                        If r_Time.开始时间 > Sysdate Then
                          If Nvl(n_时间间隔, 0) = 0 Then
                            v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                            If Nvl(r_Time.挂号状态, 0) = 0 Then
                              v_Temp   := v_Temp || '<SL>1</SL></SPAN>';
                              n_Exists := n_Exists + 1;
                            Else
                              v_Temp := v_Temp || '<SL>0</SL></SPAN>';
                            End If;
                          Else
                            If Nvl(r_Time.挂号状态, 0) = 0 Then
                              n_时段剩余 := n_时段剩余 + 1;
                              n_Exists   := n_Exists + 1;
                            End If;
                          End If;
                        End If;
                      End Loop;
                      If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 0;
                        n_时段剩余 := 0;
                        d_时段开始 := Null;
                        d_时段结束 := Null;
                      End If;
                      If n_Exists < To_Number(v_剩余数量) Then
                        v_剩余数量 := n_Exists;
                      End If;
                    Else
                      --分时段,非序号控制
                      n_Exists   := 0;
                      n_时段总数 := 0;
                      n_时段剩余 := 0;
                      d_时段开始 := Null;
                      d_时段结束 := Null;
                      Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                      For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态, 数量
                                     From 临床出诊序号控制
                                     Where 记录id = r_No.记录id And 预约顺序号 Is Null And 是否预约 = 1 And
                                           开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) And
                                           开始时间 Not Between Nvl(r_No.停诊开始时间, Sysdate) And Nvl(r_No.停诊终止时间, Sysdate - 1)) Loop
                        If Nvl(n_时间间隔, 0) <> 0 Then
                          If d_时段开始 Is Null Then
                            d_时段开始 := r_Time.开始时间;
                            d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                            n_时段总数 := n_时段总数 + r_Time.数量;
                            If d_加号时间 < d_时段结束 Then
                              d_时段结束 := d_加号时间;
                            End If;
                          Else
                            If r_Time.开始时间 >= d_时段结束 Then
                              v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                            To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 ||
                                            '</GHZS>' || '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                              n_时段总数 := r_Time.数量;
                              n_时段剩余 := 0;
                              d_时段开始 := r_Time.开始时间;
                              d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                              If d_加号时间 < d_时段结束 Then
                                d_时段结束 := d_加号时间;
                              End If;
                            Else
                              n_时段总数 := n_时段总数 + r_Time.数量;
                            End If;
                          End If;
                        End If;
                        Select Count(1)
                        Into n_时段已挂
                        From 临床出诊序号控制
                        Where 预约顺序号 Is Not Null And Nvl(挂号状态, 0) <> 0;
                        If r_Time.开始时间 > Sysdate Then
                          If Nvl(n_时间间隔, 0) = 0 Then
                            v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                            v_Temp := v_Temp || '<SL>' || r_Time.数量 - n_时段已挂 || '</SL></SPAN>';
                          Else
                            n_时段剩余 := n_时段剩余 + (r_Time.数量 - n_时段已挂);
                          End If;
                          n_Exists := n_Exists + (r_Time.数量 - n_时段已挂);
                        
                        End If;
                      End Loop;
                      If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 0;
                        n_时段剩余 := 0;
                        d_时段开始 := Null;
                        d_时段结束 := Null;
                      End If;
                      If n_Exists < To_Number(v_剩余数量) Then
                        v_剩余数量 := n_Exists;
                      End If;
                    End If;
                    v_Temp := v_Temp || '</SPANLIST>';
                  End If;
                  n_已挂数 := r_No.已约数;
                End If;
                If n_合约模式 = 3 Then
                  If r_No.分时段 = 0 Then
                    If r_No.序号控制 = 0 Then
                      n_禁用 := 1;
                    Else
                      n_已挂数   := 0;
                      v_剩余数量 := 0;
                      For r_合作 In (Select 序号
                                   From 临床出诊挂号控制记录
                                   Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位) Loop
                        Select Nvl(Max(1), 0)
                        Into n_Exists
                        From 临床出诊序号控制
                        Where 记录id = r_No.记录id And 序号 = r_合作.序号 And 是否预约 = 1 And Nvl(挂号状态, 0) = 0 And
                              开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) And
                              Nvl(是否停诊, 0) <> 1;
                        If n_Exists = 1 Then
                          v_剩余数量 := v_剩余数量 + 1;
                        Else
                          n_已挂数 := n_已挂数 + 1;
                        End If;
                      End Loop;
                      If Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0) < v_剩余数量 Then
                        v_剩余数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
                      End If;
                    End If;
                  Else
                    If r_No.序号控制 = 0 Then
                      --合作单位,分时段,非序号控制
                      n_已挂数   := 0;
                      v_剩余数量 := 0;
                      n_时段总数 := 0;
                      n_时段剩余 := 0;
                      d_时段开始 := Null;
                      d_时段结束 := Null;
                      v_Temp     := '<SPANLIST>';
                      For r_合作 In (Select 序号, 数量
                                   From 临床出诊挂号控制记录
                                   Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位) Loop
                        Begin
                          Select Count(1), Max(开始时间), Max(终止时间)
                          Into n_时段已挂, d_开始时间, d_终止时间
                          From 临床出诊序号控制
                          Where 记录id = r_No.记录id And 预约顺序号 Is Not Null And Nvl(挂号状态, 0) <> 0 And 序号 = r_合作.序号 And
                                开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1);
                        
                          If Nvl(n_时间间隔, 0) <> 0 Then
                            If d_时段开始 Is Null Then
                              d_时段开始 := d_开始时间;
                              d_时段结束 := d_开始时间 + 1 / 24 / 60 * n_时间间隔;
                              n_时段总数 := n_时段总数 + r_合作.数量;
                            Else
                              If d_开始时间 >= d_时段结束 Then
                                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                              To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 ||
                                              '</GHZS>' || '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                                n_时段总数 := r_合作.数量;
                                n_时段剩余 := 0;
                                d_时段开始 := d_开始时间;
                                d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                              Else
                                n_时段总数 := n_时段总数 + r_合作.数量;
                              End If;
                            End If;
                          End If;
                          n_已挂数 := n_已挂数 + n_时段已挂;
                          If d_开始时间 > Sysdate Then
                            If Nvl(n_时间间隔, 0) = 0 Then
                              v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(d_终止时间, 'hh24:mi:ss') || '</SJD>';
                              v_Temp := v_Temp || '<SL>' || r_合作.数量 - n_时段已挂 || '</SL></SPAN>';
                            Else
                              n_时段剩余 := n_时段剩余 + r_合作.数量 - n_时段已挂;
                            End If;
                            v_剩余数量 := v_剩余数量 + r_合作.数量 - n_时段已挂;
                          End If;
                        Exception
                          When Others Then
                            Null;
                        End;
                      End Loop;
                      If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 0;
                        n_时段剩余 := 0;
                        d_时段开始 := Null;
                        d_时段结束 := Null;
                      End If;
                      v_Temp := v_Temp || '</SPANLIST>';
                    Else
                      n_已挂数   := 0;
                      v_剩余数量 := 0;
                      n_时段总数 := 0;
                      n_时段剩余 := 0;
                      d_时段开始 := Null;
                      d_时段结束 := Null;
                      v_Temp     := '<SPANLIST>';
                      For r_合作 In (Select 序号
                                   From 临床出诊挂号控制记录
                                   Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位) Loop
                        Begin
                          Select 1, 开始时间, 终止时间
                          Into n_Exists, d_开始时间, d_终止时间
                          From 临床出诊序号控制
                          Where 记录id = r_No.记录id And Nvl(挂号状态, 0) = 0 And 序号 = r_合作.序号 And
                                开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) And
                                Nvl(是否停诊, 0) <> 1;
                        Exception
                          When Others Then
                            n_Exists := 0;
                        End;
                      
                        If Nvl(n_时间间隔, 0) <> 0 Then
                          If d_时段开始 Is Null Then
                            d_时段开始 := d_开始时间;
                            d_时段结束 := d_开始时间 + 1 / 24 / 60 * n_时间间隔;
                            n_时段总数 := n_时段总数 + 1;
                          Else
                            If d_开始时间 >= d_时段结束 Then
                              v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                            To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 ||
                                            '</GHZS>' || '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                              n_时段总数 := 1;
                              n_时段剩余 := 0;
                              d_时段开始 := d_开始时间;
                              d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                            Else
                              n_时段总数 := n_时段总数 + 1;
                            End If;
                          End If;
                        End If;
                        If d_开始时间 > Sysdate Then
                          If n_Exists = 1 Then
                            v_剩余数量 := v_剩余数量 + 1;
                            If Nvl(n_时间间隔, 0) = 0 Then
                              v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(d_终止时间, 'hh24:mi:ss') || '</SJD>';
                              v_Temp := v_Temp || '<SL>' || 1 || '</SL></SPAN>';
                            Else
                              n_时段剩余 := n_时段剩余 + 1;
                            End If;
                          Else
                            If Nvl(n_时间间隔, 0) = 0 Then
                              v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(d_终止时间, 'hh24:mi:ss') || '</SJD>';
                              v_Temp := v_Temp || '<SL>' || 0 || '</SL></SPAN>';
                            End If;
                            n_已挂数 := n_已挂数 + 1;
                          End If;
                        End If;
                      End Loop;
                      If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 0;
                        n_时段剩余 := 0;
                        d_时段开始 := Null;
                        d_时段结束 := Null;
                      End If;
                    End If;
                  End If;
                End If;
                If n_合约模式 = 4 Then
                  If r_No.分时段 = 0 Then
                    n_已挂数   := r_No.已约数;
                    v_剩余数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
                  Else
                    --分时段
                    n_已挂数   := 0;
                    v_剩余数量 := 0;
                    n_时段总数 := 0;
                    n_时段剩余 := 0;
                    d_时段开始 := Null;
                    d_时段结束 := Null;
                    v_Temp     := '<SPANLIST>';
                    If r_No.序号控制 = 0 Then
                      --非序号控制分时段预约
                      Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                      For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态, 数量
                                     From 临床出诊序号控制
                                     Where 记录id = r_No.记录id And 预约顺序号 Is Null And 是否预约 = 1 And
                                           开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) And
                                           开始时间 Not Between Nvl(r_No.停诊开始时间, Sysdate) And Nvl(r_No.停诊终止时间, Sysdate - 1)) Loop
                      
                        If Nvl(n_时间间隔, 0) <> 0 Then
                          If d_时段开始 Is Null Then
                            d_时段开始 := r_Time.开始时间;
                            d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                            n_时段总数 := n_时段总数 + r_Time.数量;
                            If d_加号时间 < d_时段结束 Then
                              d_时段结束 := d_加号时间;
                            End If;
                          Else
                            If r_Time.开始时间 >= d_时段结束 Then
                              v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                            To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 ||
                                            '</GHZS>' || '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                              n_时段总数 := r_Time.数量;
                              n_时段剩余 := 0;
                              d_时段开始 := r_Time.开始时间;
                              d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                              If d_加号时间 < d_时段结束 Then
                                d_时段结束 := d_加号时间;
                              End If;
                            Else
                              n_时段总数 := n_时段总数 + r_Time.数量;
                            End If;
                          End If;
                        End If;
                        Select Count(1)
                        Into n_时段已挂
                        From 临床出诊序号控制
                        Where 预约顺序号 Is Not Null And Nvl(挂号状态, 0) <> 0;
                        If r_Time.开始时间 > Sysdate Then
                          If Nvl(n_时间间隔, 0) = 0 Then
                            v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                            v_Temp := v_Temp || '<SL>' || r_Time.数量 - n_时段已挂 || '</SL></SPAN>';
                          Else
                            n_时段剩余 := n_时段剩余 + (r_Time.数量 - n_时段已挂);
                          End If;
                          n_已挂数   := n_已挂数 + n_时段已挂;
                          v_剩余数量 := v_剩余数量 + (r_Time.数量 - n_时段已挂);
                        End If;
                      End Loop;
                      If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 0;
                        n_时段剩余 := 0;
                        d_时段开始 := Null;
                        d_时段结束 := Null;
                      End If;
                    Else
                      n_时段总数 := 0;
                      n_时段剩余 := 0;
                      d_时段开始 := Null;
                      d_时段结束 := Null;
                      Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                      For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                                     From 临床出诊序号控制
                                     Where 记录id = r_No.记录id And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And
                                           Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1) Loop
                      
                        If Nvl(n_时间间隔, 0) <> 0 Then
                          If d_时段开始 Is Null Then
                            d_时段开始 := r_Time.开始时间;
                            d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                            n_时段总数 := n_时段总数 + 1;
                            If d_加号时间 < d_时段结束 Then
                              d_时段结束 := d_加号时间;
                            End If;
                          Else
                            If r_Time.开始时间 >= d_时段结束 Then
                              v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                            To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 ||
                                            '</GHZS>' || '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                              n_时段总数 := 1;
                              n_时段剩余 := 0;
                              d_时段开始 := r_Time.开始时间;
                              d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                              If d_加号时间 < d_时段结束 Then
                                d_时段结束 := d_加号时间;
                              End If;
                            Else
                              n_时段总数 := n_时段总数 + 1;
                            End If;
                          End If;
                        End If;
                        If r_Time.开始时间 > Sysdate Then
                          If Nvl(n_时间间隔, 0) = 0 Then
                            v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                            If Nvl(r_Time.挂号状态, 0) = 0 Then
                              v_Temp     := v_Temp || '<SL>1</SL></SPAN>';
                              v_剩余数量 := v_剩余数量 + 1;
                            Else
                              v_Temp   := v_Temp || '<SL>0</SL></SPAN>';
                              n_已挂数 := n_已挂数 + 1;
                            End If;
                          Else
                            If Nvl(r_Time.挂号状态, 0) = 0 Then
                              n_时段剩余 := n_时段剩余 + 1;
                              v_剩余数量 := v_剩余数量 + 1;
                            Else
                              n_已挂数 := n_已挂数 + 1;
                            End If;
                          End If;
                        End If;
                      End Loop;
                      If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 0;
                        n_时段剩余 := 0;
                        d_时段开始 := Null;
                        d_时段结束 := Null;
                      End If;
                    End If;
                    v_Temp := v_Temp || '</SPANLIST>';
                  End If;
                End If;
              End If;
            End If;
          End If;
        End If;
      
        If Not (r_No.分时段 = 1 And r_No.序号控制 = 1) Then
          If d_日期 Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) Then
            n_禁用 := 1;
          End If;
          If d_日期 Between Nvl(r_No.停诊开始时间, Sysdate) And Nvl(r_No.停诊终止时间, Sysdate - 1) Then
            n_禁用 := 1;
          End If;
        End If;
      
        If Nvl(n_禁用, 0) = 0 Then
          n_合计金额 := 0;
          For r_Fee In (Select b.现价, a.从项数次
                        From 收费从属项目 A, 收费价目 B
                        Where a.主项id = r_No.项目id And a.从项id = b.收费细目id And Sysdate Between b.执行日期 And
                              Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And
                              (b.价格等级 = v_普通等级 Or
                              (b.价格等级 Is Null And Not Exists
                               (Select 1
                                 From 收费价目
                                 Where b.收费细目id = 收费细目id And 价格等级 = v_普通等级 And Sysdate Between 执行日期 And
                                       Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')))))
                        Union
                        Select b.现价, 1 As 从项数次
                        From 收费项目目录 A, 收费价目 B
                        Where a.Id = b.收费细目id And a.Id = r_No.项目id And Sysdate Between b.执行日期 And
                              Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And
                              (b.价格等级 = v_普通等级 Or
                              (b.价格等级 Is Null And Not Exists
                               (Select 1
                                 From 收费价目
                                 Where b.收费细目id = 收费细目id And 价格等级 = v_普通等级 And Sysdate Between 执行日期 And
                                       Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')))))) Loop
            n_合计金额 := n_合计金额 + r_Fee.现价 * r_Fee.从项数次;
          End Loop;
          v_时间段 := To_Char(r_No.替诊开始时间, 'HH24:MI') || '-' || To_Char(r_No.替诊终止时间, 'HH24:MI');
          If Trunc(Sysdate) = Trunc(d_日期) Then
            c_Xmlmain := '<HB>' || '<CZJLID>' || r_No.记录id || '</CZJLID>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' ||
                         r_No.医生id || '</YSID>' || '<YS>' || r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id || '</KSID>' ||
                         '<KSMC>' || r_No.科室名称 || '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' || r_No.项目id ||
                         '</XMID>' || '<XMMC>' || r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 || '</YGHS>' || '<SYHS>' ||
                         v_剩余数量 || '</SYHS>' || '<PRICE>' || n_合计金额 || '</PRICE>' || '<HL>' || r_No.号类 || '</HL>' ||
                         '<FSD>' || r_No.分时段 || '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' || '<FWMC>' || r_No.排班 ||
                         '</FWMC>' || v_Temp || '</HB>';
            v_Xmlmain := v_Xmlmain || c_Xmlmain;
          Else
            If r_No.已约数 >= r_No.限约数 Then
              c_Xmlmain := '<HB>' || '<CZJLID>' || r_No.记录id || '</CZJLID>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' ||
                           r_No.医生id || '</YSID>' || '<YS>' || r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id ||
                           '</KSID>' || '<KSMC>' || r_No.科室名称 || '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' ||
                           r_No.项目id || '</XMID>' || '<XMMC>' || r_No.项目名称 || '</XMMC>' || '<YGHS>' || r_No.已约数 ||
                           '</YGHS>' || '<SYHS>' || 0 || '</SYHS>' || '<PRICE>' || n_合计金额 || '</PRICE>' || '<HL>' ||
                           r_No.号类 || '</HL>' || '<FSD>' || r_No.分时段 || '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' ||
                           '<FWMC>' || r_No.排班 || '</FWMC>' || '</HB>';
              v_Xmlmain := v_Xmlmain || c_Xmlmain;
            Else
              c_Xmlmain := '<HB>' || '<CZJLID>' || r_No.记录id || '</CZJLID>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' ||
                           r_No.医生id || '</YSID>' || '<YS>' || r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id ||
                           '</KSID>' || '<KSMC>' || r_No.科室名称 || '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' ||
                           r_No.项目id || '</XMID>' || '<XMMC>' || r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 ||
                           '</YGHS>' || '<SYHS>' || v_剩余数量 || '</SYHS>' || '<PRICE>' || n_合计金额 || '</PRICE>' || '<HL>' ||
                           r_No.号类 || '</HL>' || '<FSD>' || r_No.分时段 || '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' ||
                           '<FWMC>' || r_No.排班 || '</FWMC>' || v_Temp || '</HB>';
              v_Xmlmain := v_Xmlmain || c_Xmlmain;
            End If;
          End If;
        End If;
      End If;
      n_禁用 := 0;
    End Loop;
    v_Xmlmain := '<GROUP>' || '<RQ>' || To_Char(d_日期, 'yyyy-mm-dd') || '</RQ>' || '<HBLIST>' || v_Xmlmain ||
                 '</HBLIST>' || '</GROUP>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Xmlmain)) Into x_Templet From Dual;
  End If;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getnolist;
/

--100956:刘尔旋,2017-5-23,收费价格等级支付宝相关调整
Create Or Replace Procedure Zl_Third_Docarrange
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:医生排班计划
  --入参:Xml_In:
  --<IN>
  --   <YSID>870</YSID>    //医生ID
  --   <KDID>870</KSID>    //科室ID
  --   <KSSJ>2014-10-29 </KSSJ>    //开始时间
  --   <CXTS>14</CXTS>    //查询天数
  --   <HZDW>支付宝</HZDW> //合作单位
  --   <HL>号类</HL>      //号类，可传多个，用逗号分隔，格式:普通,专家,...
  --   <ZD></ZD>        //站点
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  --   <PBLIST>       //未返回该节点表示没有数据
  --    <PB>
  --     <RQ>2014-10-29</RQ>     //日期
  --     <SYHS>5</SYHS>    //剩余号数
  --     <SBSJ>全日</SBSJ>             //上班时间
  --     <YGS>5</YGS>    //已挂号数
  --    </PB>
  --   <PBLIST>
  --   <ERROR><MSG></MSG></ERROR> //错误情况返回
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  d_日期         Date;
  v_排班         挂号安排.周日%Type;
  n_限号数       挂号安排限制.限号数%Type;
  n_已挂数       挂号安排限制.限号数%Type;
  n_总已挂数     挂号安排限制.限号数%Type;
  n_限约数       挂号安排限制.限号数%Type;
  n_已约数       挂号安排限制.限号数%Type;
  n_剩余数       挂号安排限制.限号数%Type;
  v_上班时间     Varchar2(300);
  n_医生id       人员表.Id%Type;
  n_科室id       部门表.Id%Type;
  n_查询天数     Number(4);
  n_合作单位数量 Number(5);
  n_合约已挂数   Number(4);
  n_合约存在     Number(3);
  n_安排存在     Number(3);
  v_号码         挂号安排.号码%Type;
  n_安排id       挂号安排计划.安排id%Type;
  n_计划id       挂号安排计划.Id%Type;
  v_合作单位     挂号合作单位.名称%Type;
  n_Daycount     Number(4);
  d_开始时间     Date;
  d_原始时间     Date;
  n_禁用         Number(3);
  v_Temp         Varchar2(32767); --临时XML
  x_Templet      Xmltype; --模板XML
  v_Err_Msg      Varchar2(200);
  v_号类         Varchar2(200);
  n_Exists       Number(2);
  n_预约天数     Number(5);
  n_补充天数     Number(5);
  n_挂号模式     Number(3);
  n_合约模式     临床出诊挂号控制记录.控制方式%Type;
  v_启用时间     Varchar2(500);
  v_药品等级     Varchar2(100);
  v_卫材等级     Varchar2(100);
  v_普通等级     Varchar2(100);
  v_Pricegrade   Varchar2(500);
  v_站点         部门表.站点%Type;
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/YSID'), Extractvalue(Value(A), 'IN/KSID'), Extractvalue(Value(A), 'IN/CXTS'),
         To_Date(Extractvalue(Value(A), 'IN/KSSJ'), 'YYYY-MM-DD hh24:mi:ss'), Extractvalue(Value(A), 'IN/HZDW'),
         Extractvalue(Value(A), 'IN/HL'), Extractvalue(Value(A), 'IN/ZD')
  Into n_医生id, n_科室id, n_查询天数, d_开始时间, v_合作单位, v_号类, v_站点
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  n_查询天数 := Nvl(n_查询天数, 14);
  n_预约天数 := Nvl(zl_GetSysParameter(66), 7);
  d_原始时间 := Trunc(d_开始时间);
  d_开始时间 := Trunc(d_开始时间);
  n_Daycount := 0;

  v_Pricegrade := Zl_Get_Pricegrade(v_站点);
  v_药品等级   := Substr(v_Pricegrade, 1, Instr(v_Pricegrade, '|') - 1);
  v_Pricegrade := Substr(v_Pricegrade, Instr(v_Pricegrade, '|') + 1);
  v_卫材等级   := Substr(v_Pricegrade, 1, Instr(v_Pricegrade, '|') - 1);
  v_Pricegrade := Substr(v_Pricegrade, Instr(v_Pricegrade, '|') + 1);
  v_普通等级   := Substr(v_Pricegrade, 1, Instr(v_Pricegrade, '|') - 1);

  n_挂号模式 := To_Number(Substr(Nvl(zl_GetSysParameter('挂号排班模式'), '0'), 1, 1));
  v_启用时间 := Substr(Nvl(zl_GetSysParameter('挂号排班模式'), '0'), 3);
  If n_挂号模式 = 0 Then
    If Nvl(n_科室id, 0) = 0 Then
      While (n_Daycount < n_查询天数) Loop
        If Trunc(d_开始时间 + n_Daycount) = Trunc(Sysdate) Then
          d_开始时间 := Sysdate - n_Daycount;
        Else
          d_开始时间 := d_原始时间;
        End If;
        n_安排存在 := 0;
        v_上班时间 := Null;
        n_总已挂数 := 0;
        n_已挂数   := 0;
        n_剩余数   := 0;
        n_限号数   := 0;
        n_已约数   := 0;
        n_限约数   := 0;
        For r_排班 In (Select d_开始时间 + n_Daycount As 日期, a.排班, a.限号数, a.限约数, Nvl(Hz.已挂数, 0) As 已挂数, Nvl(Hz.已约数, 0) As 已约数,
                            a.安排id, a.计划id, a.号码, a.号类
                     
                     From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Nvl(Ap.医生id, 0) As 医生id, Ry.专业技术职务 As 职称, Ap.号码,
                                   Ap.安排id, Ap.计划id, Ap.排班, Ap.项目id, Fy.名称 As 项目名称, Ap.序号控制, Ap.限号数, Ap.限约数


                            
                            From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Ap.医生id, Ap.号码, Ap.Id As 安排id, 0 As 计划id,
                                          Ap.项目id, Nvl(Ap.序号控制, 0) As 序号控制,
                                          Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', Ap.周日, '2', Ap.周一, '3', Ap.周二, '4',
                                                  Ap.周三, '5', Ap.周四, '6', Ap.周五, '7', Ap.周六, Null) As 排班,
                                          Nvl(Xz.限约数, Xz.限号数) As 限约数, Nvl(Xz.限号数, 0) As 限号数
                                   From 挂号安排 Ap, 部门表 Bm, 挂号安排限制 Xz
                                   Where Ap.科室id = Bm.Id(+) And Ap.医生id = n_医生id And
                                         Sysdate + Nvl(Ap.预约天数, n_预约天数) >= d_开始时间 + n_Daycount And Ap.停用日期 Is Null And
                                         d_开始时间 + n_Daycount Between Nvl(Ap.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                         Nvl(Ap.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.安排id(+) = Ap.Id And
                                         Xz.限制项目(+) =
                                         Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                    (Select Rownum
                                          From 挂号安排停用状态 Ty
                                          Where Ty.安排id = Ap.Id And d_开始时间 + n_Daycount Between Ty.开始停止时间 And Ty.结束停止时间) And
                                         Not Exists
                                    (Select Rownum
                                          From 挂号安排计划 Jh
                                          Where Jh.安排id = Ap.Id And Jh.审核时间 Is Not Null And
                                                d_开始时间 + n_Daycount Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                                Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')))
                                   Union All
                                   Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Jh.医生姓名, Jh.医生id, Ap.号码, Ap.Id As 安排id,
                                          Jh.Id As 计划id, Jh.项目id, Nvl(Jh.序号控制, 0) As 序号控制,
                                          Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', Jh.周日, '2', Jh.周一, '3', Jh.周二, '4',
                                                  Jh.周三, '5', Jh.周四, '6', Jh.周五, '7', Jh.周六, Null) As 排班,
                                          Nvl(Xz.限约数, Xz.限号数) As 限约数, Nvl(Xz.限号数, 0) As 限号数
                                   From 挂号安排计划 Jh, 挂号安排 Ap, 部门表 Bm, 挂号计划限制 Xz
                                   Where Jh.安排id = Ap.Id And Ap.科室id = Bm.Id(+) And
                                         Sysdate + Nvl(Ap.预约天数, n_预约天数) >= d_开始时间 + n_Daycount And Ap.停用日期 Is Null And
                                         Jh.医生id = n_医生id And
                                         d_开始时间 + n_Daycount Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                         Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.计划id(+) = Jh.Id And
                                         Xz.限制项目(+) =
                                         Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                    (Select Rownum
                                          From 挂号安排停用状态 Ty
                                          Where Ty.安排id = Ap.Id And d_开始时间 + n_Daycount Between Ty.开始停止时间 And Ty.结束停止时间) And
                                         (Jh.生效时间, Jh.安排id) =
                                         (Select Max(Sxjh.生效时间) As 生效时间, 安排id
                                          From 挂号安排计划 Sxjh
                                          Where Sxjh.审核时间 Is Not Null And d_开始时间 + n_Daycount Between
                                                Nvl(Sxjh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                                Nvl(Sxjh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Sxjh.安排id = Jh.安排id
                                          Group By Sxjh.安排id)) Ap, 部门表 Bm, 人员表 Ry, 收费项目目录 Fy
                            Where Ap.科室id = Bm.Id(+) And Ap.医生id = Ry.Id(+) And Ap.项目id = Fy.Id And 排班 Is Not Null) A,
                          病人挂号汇总 Hz, 收费价目 B
                     Where a.号码 = Hz.号码(+) And Hz.日期(+) = Trunc(d_开始时间 + n_Daycount) And a.项目id = b.收费细目id And
                           b.终止日期 > d_开始时间 + n_Daycount And b.执行日期 <= d_开始时间 + n_Daycount And
                           (b.价格等级 = v_普通等级 Or
                           (b.价格等级 Is Null And Not Exists
                            (Select 1
                              From 收费价目
                              Where b.收费细目id = 收费细目id And 价格等级 = v_普通等级 And Sysdate Between 执行日期 And
                                    Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')))))) Loop
          If v_号类 Is Null Or Instr(',' || v_号类 || ',', ',' || r_排班.号类 || ',') > 0 Then
            v_上班时间 := v_上班时间 || '+' || r_排班.排班;
            n_总已挂数 := n_总已挂数 + r_排班.已挂数;
            n_已挂数   := r_排班.已挂数;
            n_限号数   := r_排班.限号数;
            n_已约数   := r_排班.已约数;
            n_限约数   := r_排班.限约数;
            n_安排id   := Nvl(r_排班.安排id, 0);
            n_计划id   := Nvl(r_排班.计划id, 0);
            v_号码     := r_排班.号码;
            n_安排存在 := 1;
            If v_上班时间 Is Not Null Then
              If v_合作单位 Is Not Null Then
                If n_计划id <> 0 Then
                  Begin
                    Select 1
                    Into n_合约存在
                    From 合作单位计划控制
                    Where 计划id = n_计划id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_合约存在 := 0;
                  End;
                Else
                  Begin
                    Select 1
                    Into n_合约存在
                    From 合作单位安排控制
                    Where 安排id = n_安排id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_合约存在 := 0;
                  End;
                End If;
              End If;
            
              If v_合作单位 Is Null Or Nvl(n_合约存在, 0) = 0 Then
                If n_计划id <> 0 Then
                  Begin
                    Select Sum(数量)
                    Into n_合作单位数量
                    From 合作单位计划控制
                    Where 计划id = n_计划id And
                          限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                        '5', '周四', '6', '周五', '7', '周六', Null);
                  Exception
                    When Others Then
                      n_合作单位数量 := 0;
                  End;
                Else
                  Begin
                    Select Sum(数量)
                    Into n_合作单位数量
                    From 合作单位安排控制
                    Where 安排id = n_安排id And
                          限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                        '5', '周四', '6', '周五', '7', '周六', Null);
                  Exception
                    When Others Then
                      n_合作单位数量 := 0;
                  End;
                End If;
                Begin
                  Select Count(1)
                  Into n_合约已挂数
                  From 病人挂号记录
                  Where 号别 = v_号码 And 记录状态 = 1 And 合作单位 Is Not Null And 发生时间 Between Trunc(d_开始时间 + n_Daycount) And
                        Trunc(d_开始时间 + n_Daycount + 1) - 1 / 60 / 60 / 24;
                Exception
                  When Others Then
                    n_合约已挂数 := 0;
                End;
                If n_合作单位数量 = 0 Then
                  n_合作单位数量 := Null;
                End If;
                If Trunc(d_开始时间 + n_Daycount) > Trunc(Sysdate) Then
                  n_剩余数 := Nvl(n_剩余数, 0) + n_限约数 - n_已约数 - Nvl(n_合作单位数量, n_合约已挂数) + Nvl(n_合约已挂数, 0);
                Else
                  n_剩余数 := Nvl(n_剩余数, 0) + n_限号数 - n_已挂数 - Nvl(n_合作单位数量, n_合约已挂数) + Nvl(n_合约已挂数, 0);
                End If;
              Else
                --合约单位
                If n_计划id <> 0 Then
                  Begin
                    Select 1
                    Into n_禁用
                    From 合作单位计划控制
                    Where 计划id = n_计划id And
                          限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                        '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位 And 数量 = 0 And
                          Rownum < 2;
                  Exception
                    When Others Then
                      n_禁用 := 0;
                  End;
                Else
                  Begin
                    Select 1
                    Into n_禁用
                    From 合作单位安排控制
                    Where 安排id = n_安排id And
                          限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                        '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位 And 数量 = 0 And
                          Rownum < 2;
                  Exception
                    When Others Then
                      n_禁用 := 0;
                  End;
                End If;
                If Nvl(n_禁用, 0) = 0 Then
                  Begin
                    Select Count(1)
                    Into n_合约已挂数
                    From 病人挂号记录
                    Where 号别 = v_号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_开始时间 + n_Daycount) And
                          Trunc(d_开始时间 + n_Daycount + 1) - 1 / 60 / 60 / 24;
                  Exception
                    When Others Then
                      n_合约已挂数 := 0;
                  End;
                  If n_计划id <> 0 Then
                    Begin
                      Select Sum(数量)
                      Into n_合作单位数量
                      From 合作单位计划控制
                      Where 计划id = n_计划id And
                            限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                          '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
                    Exception
                      When Others Then
                        n_合作单位数量 := 0;
                    End;
                  Else
                    Begin
                      Select Sum(数量)
                      Into n_合作单位数量
                      From 合作单位安排控制
                      Where 安排id = n_安排id And
                            限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                          '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
                    Exception
                      When Others Then
                        n_合作单位数量 := 0;
                    End;
                  End If;
                  If n_合作单位数量 = 0 Then
                    n_合作单位数量 := Null;
                  End If;
                  n_剩余数 := Nvl(n_剩余数, 0) + Nvl(n_合作单位数量, n_合约已挂数) - Nvl(n_合约已挂数, 0);
                
                End If;
              End If;
            End If;
            n_合作单位数量 := 0;
            n_合约存在     := 0;
            n_禁用         := 0;
          End If;
        End Loop;
        v_上班时间 := Substr(v_上班时间, 2);
        If n_安排存在 = 1 Then
          v_Temp := v_Temp || '<PB>' || '<RQ>' || To_Char(Trunc(d_开始时间 + n_Daycount), 'YYYY-MM-DD') || '</RQ>' ||
                    '<SYHS>' || n_剩余数 || '</SYHS>' || '<SBSJ>' || v_上班时间 || '</SBSJ>' || '<YGS>' || n_总已挂数 || '</YGS>' ||
                    '</PB>';
        End If;
        n_Daycount := n_Daycount + 1;
      End Loop;
    Else
      While (n_Daycount < n_查询天数) Loop
        If Trunc(d_开始时间 + n_Daycount) = Trunc(Sysdate) Then
          d_开始时间 := Sysdate - n_Daycount;
        Else
          d_开始时间 := d_原始时间;
        End If;
        v_上班时间 := Null;
        n_总已挂数 := 0;
        n_已挂数   := 0;
        n_剩余数   := 0;
        n_限号数   := 0;
        n_已约数   := 0;
        n_限约数   := 0;
        n_安排存在 := 0;
        For r_排班 In (Select d_开始时间 + n_Daycount As 日期, a.排班, a.限号数, a.限约数, Nvl(Hz.已挂数, 0) As 已挂数, Nvl(Hz.已约数, 0) As 已约数,
                            a.安排id, a.计划id, a.号码, a.号类
                     
                     From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Nvl(Ap.医生id, 0) As 医生id, Ry.专业技术职务 As 职称, Ap.号码,
                                   Ap.安排id, Ap.计划id, Ap.排班, Ap.项目id, Fy.名称 As 项目名称, Ap.序号控制, Ap.限号数, Ap.限约数


                            
                            From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Ap.医生id, Ap.号码, Ap.Id As 安排id, 0 As 计划id,
                                          Ap.项目id, Nvl(Ap.序号控制, 0) As 序号控制,
                                          Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', Ap.周日, '2', Ap.周一, '3', Ap.周二, '4',
                                                  Ap.周三, '5', Ap.周四, '6', Ap.周五, '7', Ap.周六, Null) As 排班,
                                          Nvl(Xz.限约数, Xz.限号数) As 限约数, Nvl(Xz.限号数, 0) As 限号数
                                   From 挂号安排 Ap, 部门表 Bm, 挂号安排限制 Xz
                                   Where Ap.科室id = Bm.Id(+) And Sysdate + Nvl(Ap.预约天数, n_预约天数) >= d_开始时间 + n_Daycount And
                                         Ap.医生id = n_医生id And Ap.科室id = n_科室id And Ap.停用日期 Is Null And
                                         d_开始时间 + n_Daycount Between Nvl(Ap.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                         Nvl(Ap.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.安排id(+) = Ap.Id And
                                         Xz.限制项目(+) =
                                         Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                    (Select Rownum
                                          From 挂号安排停用状态 Ty
                                          Where Ty.安排id = Ap.Id And d_开始时间 + n_Daycount Between Ty.开始停止时间 And Ty.结束停止时间) And
                                         Not Exists
                                    (Select Rownum
                                          From 挂号安排计划 Jh
                                          Where Jh.安排id = Ap.Id And Jh.审核时间 Is Not Null And
                                                d_开始时间 + n_Daycount Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                                Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')))
                                   Union All
                                   Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Jh.医生姓名, Jh.医生id, Ap.号码, Ap.Id As 安排id,
                                          Jh.Id As 计划id, Jh.项目id, Nvl(Jh.序号控制, 0) As 序号控制,
                                          Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', Jh.周日, '2', Jh.周一, '3', Jh.周二, '4',
                                                  Jh.周三, '5', Jh.周四, '6', Jh.周五, '7', Jh.周六, Null) As 排班,
                                          Nvl(Xz.限约数, Xz.限号数) As 限约数, Nvl(Xz.限号数, 0) As 限号数
                                   From 挂号安排计划 Jh, 挂号安排 Ap, 部门表 Bm, 挂号计划限制 Xz
                                   Where Jh.安排id = Ap.Id And Sysdate + Nvl(Ap.预约天数, n_预约天数) >= d_开始时间 + n_Daycount And
                                         Ap.科室id = Bm.Id(+) And Ap.停用日期 Is Null And Jh.医生id = n_医生id And Ap.科室id = n_科室id And
                                         d_开始时间 + n_Daycount Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                         Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.计划id(+) = Jh.Id And
                                         Xz.限制项目(+) =
                                         Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                    (Select Rownum
                                          From 挂号安排停用状态 Ty
                                          Where Ty.安排id = Ap.Id And d_开始时间 + n_Daycount Between Ty.开始停止时间 And Ty.结束停止时间) And
                                         (Jh.生效时间, Jh.安排id) =
                                         (Select Max(Sxjh.生效时间) As 生效时间, 安排id
                                          From 挂号安排计划 Sxjh
                                          Where Sxjh.审核时间 Is Not Null And d_开始时间 + n_Daycount Between
                                                Nvl(Sxjh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                                Nvl(Sxjh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Sxjh.安排id = Jh.安排id
                                          Group By Sxjh.安排id)) Ap, 部门表 Bm, 人员表 Ry, 收费项目目录 Fy
                            Where Ap.科室id = Bm.Id(+) And Ap.医生id = Ry.Id(+) And Ap.项目id = Fy.Id And 排班 Is Not Null) A,
                          病人挂号汇总 Hz, 收费价目 B
                     Where a.号码 = Hz.号码(+) And Hz.日期(+) = Trunc(d_开始时间 + n_Daycount) And a.项目id = b.收费细目id And
                           b.终止日期 > d_开始时间 + n_Daycount And b.执行日期 <= d_开始时间 + n_Daycount And
                           (b.价格等级 = v_普通等级 Or
                           (b.价格等级 Is Null And Not Exists
                            (Select 1
                              From 收费价目
                              Where b.收费细目id = 收费细目id And 价格等级 = v_普通等级 And Sysdate Between 执行日期 And
                                    Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')))))
                     
                     ) Loop
          If v_号类 Is Null Or Instr(',' || v_号类 || ',', ',' || r_排班.号类 || ',') > 0 Then
            v_上班时间 := v_上班时间 || '+' || r_排班.排班;
            n_总已挂数 := n_总已挂数 + r_排班.已挂数;
            n_已挂数   := r_排班.已挂数;
            n_限号数   := r_排班.限号数;
            n_已约数   := r_排班.已约数;
            n_限约数   := r_排班.限约数;
            n_安排id   := Nvl(r_排班.安排id, 0);
            n_计划id   := Nvl(r_排班.计划id, 0);
            v_号码     := r_排班.号码;
            n_安排存在 := 1;
          
            If v_上班时间 Is Not Null Then
              If v_合作单位 Is Not Null Then
                If n_计划id <> 0 Then
                  Begin
                    Select 1
                    Into n_合约存在
                    From 合作单位计划控制
                    Where 计划id = n_计划id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_合约存在 := 0;
                  End;
                Else
                  Begin
                    Select 1
                    Into n_合约存在
                    From 合作单位安排控制
                    Where 安排id = n_安排id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_合约存在 := 0;
                  End;
                End If;
              End If;
            
              If v_合作单位 Is Null Or Nvl(n_合约存在, 0) = 0 Then
                If n_计划id <> 0 Then
                  Begin
                    Select Sum(数量)
                    Into n_合作单位数量
                    From 合作单位计划控制
                    Where 计划id = n_计划id And
                          限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                        '5', '周四', '6', '周五', '7', '周六', Null);
                  Exception
                    When Others Then
                      n_合作单位数量 := 0;
                  End;
                Else
                  Begin
                    Select Sum(数量)
                    Into n_合作单位数量
                    From 合作单位安排控制
                    Where 安排id = n_安排id And
                          限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                        '5', '周四', '6', '周五', '7', '周六', Null);
                  Exception
                    When Others Then
                      n_合作单位数量 := 0;
                  End;
                End If;
                Begin
                  Select Count(1)
                  Into n_合约已挂数
                  From 病人挂号记录
                  Where 号别 = v_号码 And 记录状态 = 1 And 合作单位 Is Not Null And 发生时间 Between Trunc(d_开始时间 + n_Daycount) And
                        Trunc(d_开始时间 + n_Daycount + 1) - 1 / 60 / 60 / 24;
                Exception
                  When Others Then
                    n_合约已挂数 := 0;
                End;
                If n_合作单位数量 = 0 Then
                  n_合作单位数量 := Null;
                End If;
                If Trunc(d_开始时间 + n_Daycount) > Trunc(Sysdate) Then
                  n_剩余数 := Nvl(n_剩余数, 0) + n_限约数 - n_已约数 - Nvl(n_合作单位数量, n_合约已挂数) + Nvl(n_合约已挂数, 0);
                Else
                  n_剩余数 := Nvl(n_剩余数, 0) + n_限号数 - n_已挂数 - Nvl(n_合作单位数量, n_合约已挂数) + Nvl(n_合约已挂数, 0);
                End If;
              Else
                --合约单位
                If n_计划id <> 0 Then
                  Begin
                    Select 1
                    Into n_禁用
                    From 合作单位计划控制
                    Where 计划id = n_计划id And
                          限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                        '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位 And 数量 = 0 And
                          Rownum < 2;
                  Exception
                    When Others Then
                      n_禁用 := 0;
                  End;
                Else
                  Begin
                    Select 1
                    Into n_禁用
                    From 合作单位安排控制
                    Where 安排id = n_安排id And
                          限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                        '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位 And 数量 = 0 And
                          Rownum < 2;
                  Exception
                    When Others Then
                      n_禁用 := 0;
                  End;
                End If;
                If Nvl(n_禁用, 0) = 0 Then
                  Begin
                    Select Count(1)
                    Into n_合约已挂数
                    From 病人挂号记录
                    Where 号别 = v_号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_开始时间 + n_Daycount) And
                          Trunc(d_开始时间 + n_Daycount + 1) - 1 / 60 / 60 / 24;
                  Exception
                    When Others Then
                      n_合约已挂数 := 0;
                  End;
                  If n_计划id <> 0 Then
                    Begin
                      Select Sum(数量)
                      Into n_合作单位数量
                      From 合作单位计划控制
                      Where 计划id = n_计划id And
                            限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                          '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
                    Exception
                      When Others Then
                        n_合作单位数量 := 0;
                    End;
                  Else
                    Begin
                      Select Sum(数量)
                      Into n_合作单位数量
                      From 合作单位安排控制
                      Where 安排id = n_安排id And
                            限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                          '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
                    Exception
                      When Others Then
                        n_合作单位数量 := 0;
                    End;
                  End If;
                  If n_合作单位数量 = 0 Then
                    n_合作单位数量 := Null;
                  End If;
                  n_剩余数 := Nvl(n_剩余数, 0) + Nvl(n_合作单位数量, n_合约已挂数) - Nvl(n_合约已挂数, 0);
                
                End If;
              End If;
            End If;
            n_合作单位数量 := 0;
            n_合约存在     := 0;
            n_禁用         := 0;
          End If;
        End Loop;
        v_上班时间 := Substr(v_上班时间, 2);
        If n_安排存在 = 1 Then
          v_Temp := v_Temp || '<PB>' || '<RQ>' || To_Char(Trunc(d_开始时间 + n_Daycount), 'YYYY-MM-DD') || '</RQ>' ||
                    '<SYHS>' || n_剩余数 || '</SYHS>' || '<SBSJ>' || v_上班时间 || '</SBSJ>' || '<YGS>' || n_总已挂数 || '</YGS>' ||
                    '</PB>';
        End If;
        n_Daycount := n_Daycount + 1;
      End Loop;
    End If;
    v_Temp := '<PBLIST>' || v_Temp || '</PBLIST>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Else
    --出诊表排班模式
    n_补充天数 := Zl_Fun_Getappointmentdays;
    If Nvl(n_科室id, 0) = 0 Then
      --通过医生查找
      While (n_Daycount < n_查询天数) Loop
        If Trunc(d_开始时间 + n_Daycount) < To_Date(Substr(v_启用时间, 1, Instr(v_启用时间, ' ') - 1), 'yyyy-mm-dd') Then
          n_安排存在 := 0;
          v_上班时间 := Null;
          n_总已挂数 := 0;
          n_已挂数   := 0;
          n_剩余数   := 0;
          n_限号数   := 0;
          n_已约数   := 0;
          n_限约数   := 0;
          For r_排班 In (Select d_开始时间 + n_Daycount As 日期, a.排班, a.限号数, a.限约数, Nvl(Hz.已挂数, 0) As 已挂数, Nvl(Hz.已约数, 0) As 已约数,
                              a.安排id, a.计划id, a.号码, a.号类
                       From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Nvl(Ap.医生id, 0) As 医生id, Ry.专业技术职务 As 职称,
                                     Ap.号码, Ap.安排id, Ap.计划id, Ap.排班, Ap.项目id, Fy.名称 As 项目名称, Ap.序号控制, Ap.限号数, Ap.限约数
                              
                              From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Ap.医生id, Ap.号码, Ap.Id As 安排id, 0 As 计划id,
                                            Ap.项目id, Nvl(Ap.序号控制, 0) As 序号控制,
                                            Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', Ap.周日, '2', Ap.周一, '3', Ap.周二, '4',
                                                    Ap.周三, '5', Ap.周四, '6', Ap.周五, '7', Ap.周六, Null) As 排班,
                                            Nvl(Xz.限约数, Xz.限号数) As 限约数, Nvl(Xz.限号数, 0) As 限号数
                                     From 挂号安排 Ap, 部门表 Bm, 挂号安排限制 Xz
                                     Where Ap.科室id = Bm.Id(+) And Sysdate + Nvl(Ap.预约天数, n_预约天数) >= d_开始时间 + n_Daycount And
                                           Ap.医生id = n_医生id And Ap.停用日期 Is Null And
                                           d_开始时间 + n_Daycount Between Nvl(Ap.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                           Nvl(Ap.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.安排id(+) = Ap.Id And
                                           Xz.限制项目(+) =
                                           Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4',
                                                  '周三', '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                      (Select Rownum
                                            From 挂号安排停用状态 Ty
                                            Where Ty.安排id = Ap.Id And d_开始时间 + n_Daycount Between Ty.开始停止时间 And Ty.结束停止时间) And
                                           Not Exists (Select Rownum
                                            From 挂号安排计划 Jh
                                            Where Jh.安排id = Ap.Id And Jh.审核时间 Is Not Null And
                                                  d_开始时间 + n_Daycount Between
                                                  Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                                  Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')))
                                     Union All
                                     Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Jh.医生姓名, Jh.医生id, Ap.号码, Ap.Id As 安排id,
                                            Jh.Id As 计划id, Jh.项目id, Nvl(Jh.序号控制, 0) As 序号控制,
                                            Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', Jh.周日, '2', Jh.周一, '3', Jh.周二, '4',
                                                    Jh.周三, '5', Jh.周四, '6', Jh.周五, '7', Jh.周六, Null) As 排班,
                                            Nvl(Xz.限约数, Xz.限号数) As 限约数, Nvl(Xz.限号数, 0) As 限号数
                                     From 挂号安排计划 Jh, 挂号安排 Ap, 部门表 Bm, 挂号计划限制 Xz
                                     Where Jh.安排id = Ap.Id And Sysdate + Nvl(Ap.预约天数, n_预约天数) >= d_开始时间 + n_Daycount And
                                           Ap.科室id = Bm.Id(+) And Ap.停用日期 Is Null And Jh.医生id = n_医生id And
                                           d_开始时间 + n_Daycount Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                           Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.计划id(+) = Jh.Id And
                                           Xz.限制项目(+) =
                                           Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4',
                                                  '周三', '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                      (Select Rownum
                                            From 挂号安排停用状态 Ty
                                            Where Ty.安排id = Ap.Id And d_开始时间 + n_Daycount Between Ty.开始停止时间 And Ty.结束停止时间) And
                                           (Jh.生效时间, Jh.安排id) =
                                           (Select Max(Sxjh.生效时间) As 生效时间, 安排id
                                            From 挂号安排计划 Sxjh
                                            Where Sxjh.审核时间 Is Not Null And
                                                  d_开始时间 + n_Daycount Between
                                                  Nvl(Sxjh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                                  Nvl(Sxjh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Sxjh.安排id = Jh.安排id
                                            Group By Sxjh.安排id)) Ap, 部门表 Bm, 人员表 Ry, 收费项目目录 Fy
                              Where Ap.科室id = Bm.Id(+) And Ap.医生id = Ry.Id(+) And Ap.项目id = Fy.Id And 排班 Is Not Null) A,
                            病人挂号汇总 Hz, 收费价目 B
                       Where a.号码 = Hz.号码(+) And Hz.日期(+) = Trunc(d_开始时间 + n_Daycount) And a.项目id = b.收费细目id And
                             b.终止日期 > d_开始时间 + n_Daycount And b.执行日期 <= d_开始时间 + n_Daycount And
                             (b.价格等级 = v_普通等级 Or
                             (b.价格等级 Is Null And Not Exists
                              (Select 1
                                From 收费价目
                                Where b.收费细目id = 收费细目id And 价格等级 = v_普通等级 And Sysdate Between 执行日期 And
                                      Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')))))) Loop
            If v_号类 Is Null Or Instr(',' || v_号类 || ',', ',' || r_排班.号类 || ',') > 0 Then
              v_上班时间 := v_上班时间 || '+' || r_排班.排班;
              n_总已挂数 := n_总已挂数 + r_排班.已挂数;
              n_已挂数   := r_排班.已挂数;
              n_限号数   := r_排班.限号数;
              n_已约数   := r_排班.已约数;
              n_限约数   := r_排班.限约数;
              n_安排id   := Nvl(r_排班.安排id, 0);
              n_计划id   := Nvl(r_排班.计划id, 0);
              v_号码     := r_排班.号码;
              n_安排存在 := 1;
              If v_上班时间 Is Not Null Then
                If v_合作单位 Is Not Null Then
                  If n_计划id <> 0 Then
                    Begin
                      Select 1
                      Into n_合约存在
                      From 合作单位计划控制
                      Where 计划id = n_计划id And 合作单位 = v_合作单位 And Rownum < 2;
                    Exception
                      When Others Then
                        n_合约存在 := 0;
                    End;
                  Else
                    Begin
                      Select 1
                      Into n_合约存在
                      From 合作单位安排控制
                      Where 安排id = n_安排id And 合作单位 = v_合作单位 And Rownum < 2;
                    Exception
                      When Others Then
                        n_合约存在 := 0;
                    End;
                  End If;
                End If;
              
                If v_合作单位 Is Null Or Nvl(n_合约存在, 0) = 0 Then
                  If n_计划id <> 0 Then
                    Begin
                      Select Sum(数量)
                      Into n_合作单位数量
                      From 合作单位计划控制
                      Where 计划id = n_计划id And
                            限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                          '5', '周四', '6', '周五', '7', '周六', Null);
                    Exception
                      When Others Then
                        n_合作单位数量 := 0;
                    End;
                  Else
                    Begin
                      Select Sum(数量)
                      Into n_合作单位数量
                      From 合作单位安排控制
                      Where 安排id = n_安排id And
                            限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                          '5', '周四', '6', '周五', '7', '周六', Null);
                    Exception
                      When Others Then
                        n_合作单位数量 := 0;
                    End;
                  End If;
                  Begin
                    Select Count(1)
                    Into n_合约已挂数
                    From 病人挂号记录
                    Where 号别 = v_号码 And 记录状态 = 1 And 合作单位 Is Not Null And 发生时间 Between Trunc(d_开始时间 + n_Daycount) And
                          Trunc(d_开始时间 + n_Daycount + 1) - 1 / 60 / 60 / 24;
                  Exception
                    When Others Then
                      n_合约已挂数 := 0;
                  End;
                  If n_合作单位数量 = 0 Then
                    n_合作单位数量 := Null;
                  End If;
                  If Trunc(d_开始时间 + n_Daycount) > Trunc(Sysdate) Then
                    n_剩余数 := Nvl(n_剩余数, 0) + n_限约数 - n_已约数 - Nvl(n_合作单位数量, n_合约已挂数) + Nvl(n_合约已挂数, 0);
                  Else
                    n_剩余数 := Nvl(n_剩余数, 0) + n_限号数 - n_已挂数 - Nvl(n_合作单位数量, n_合约已挂数) + Nvl(n_合约已挂数, 0);
                  End If;
                Else
                  --合约单位
                  If n_计划id <> 0 Then
                    Begin
                      Select 1
                      Into n_禁用
                      From 合作单位计划控制
                      Where 计划id = n_计划id And
                            限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                          '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位 And 数量 = 0 And
                            Rownum < 2;
                    Exception
                      When Others Then
                        n_禁用 := 0;
                    End;
                  Else
                    Begin
                      Select 1
                      Into n_禁用
                      From 合作单位安排控制
                      Where 安排id = n_安排id And
                            限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                          '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位 And 数量 = 0 And
                            Rownum < 2;
                    Exception
                      When Others Then
                        n_禁用 := 0;
                    End;
                  End If;
                  If Nvl(n_禁用, 0) = 0 Then
                    Begin
                      Select Count(1)
                      Into n_合约已挂数
                      From 病人挂号记录
                      Where 号别 = v_号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_开始时间 + n_Daycount) And
                            Trunc(d_开始时间 + n_Daycount + 1) - 1 / 60 / 60 / 24;
                    Exception
                      When Others Then
                        n_合约已挂数 := 0;
                    End;
                    If n_计划id <> 0 Then
                      Begin
                        Select Sum(数量)
                        Into n_合作单位数量
                        From 合作单位计划控制
                        Where 计划id = n_计划id And
                              限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4',
                                            '周三', '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
                      Exception
                        When Others Then
                          n_合作单位数量 := 0;
                      End;
                    Else
                      Begin
                        Select Sum(数量)
                        Into n_合作单位数量
                        From 合作单位安排控制
                        Where 安排id = n_安排id And
                              限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4',
                                            '周三', '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
                      Exception
                        When Others Then
                          n_合作单位数量 := 0;
                      End;
                    End If;
                    If n_合作单位数量 = 0 Then
                      n_合作单位数量 := Null;
                    End If;
                    n_剩余数 := Nvl(n_剩余数, 0) + Nvl(n_合作单位数量, n_合约已挂数) - Nvl(n_合约已挂数, 0);
                  
                  End If;
                End If;
              End If;
              n_合作单位数量 := 0;
              n_合约存在     := 0;
              n_禁用         := 0;
            End If;
          End Loop;
          v_上班时间 := Substr(v_上班时间, 2);
          If n_安排存在 = 1 Then
            v_Temp := v_Temp || '<PB>' || '<RQ>' || To_Char(Trunc(d_开始时间 + n_Daycount), 'YYYY-MM-DD') || '</RQ>' ||
                      '<SYHS>' || n_剩余数 || '</SYHS>' || '<SBSJ>' || v_上班时间 || '</SBSJ>' || '<YGS>' || n_总已挂数 ||
                      '</YGS>' || '</PB>';
          End If;
        Else
          n_安排存在 := 0;
          v_上班时间 := Null;
          n_总已挂数 := 0;
          n_已挂数   := 0;
          n_剩余数   := 0;
          n_限号数   := 0;
          n_已约数   := 0;
          n_限约数   := 0;
          If v_合作单位 Is Null Then
            --非合作单位
            If Trunc(d_开始时间 + n_Daycount) = Trunc(Sysdate) Then
              --当天挂号
              For r_出诊 In (Select a.已挂数, a.限号数, a.上班时段
                           From 临床出诊记录 A, 临床出诊号源 B
                           Where a.出诊日期 = Trunc(d_开始时间 + n_Daycount) And a.号源id = b.Id And
                                 Sysdate + Nvl(b.预约天数, n_预约天数) + n_补充天数 >= d_开始时间 + n_Daycount And a.医生id = n_医生id And
                                 (a.开始时间 < Nvl(a.停诊开始时间, a.终止时间) Or a.终止时间 > Nvl(a.停诊终止时间, a.开始时间)) And
                                 Nvl(a.是否锁定, 0) = 0 And Exists
                            (Select 1
                                  From 临床出诊安排 M, 临床出诊表 N
                                  Where m.Id = a.安排id And m.出诊id = n.Id And n.发布时间 Is Not Null)) Loop
                n_已挂数   := n_已挂数 + Nvl(r_出诊.已挂数, 0);
                n_限号数   := n_限号数 + r_出诊.限号数;
                v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                n_安排存在 := 1;
              End Loop;
              If v_上班时间 Is Not Null Then
                v_上班时间 := Substr(v_上班时间, 2);
              End If;
              If n_安排存在 = 1 Then
                v_Temp := v_Temp || '<PB>' || '<RQ>' || To_Char(Trunc(d_开始时间 + n_Daycount), 'YYYY-MM-DD') || '</RQ>' ||
                          '<SYHS>' || n_限号数 - n_已挂数 || '</SYHS>' || '<SBSJ>' || v_上班时间 || '</SBSJ>' || '<YGS>' || n_已挂数 ||
                          '</YGS>' || '</PB>';
              End If;
            Else
              --预约挂号
              For r_出诊 In (Select a.已约数, a.限号数, a.限约数, a.上班时段
                           From 临床出诊记录 A, 临床出诊号源 B
                           Where a.出诊日期 = Trunc(d_开始时间 + n_Daycount) And a.号源id = b.Id And
                                 Sysdate + Nvl(b.预约天数, n_预约天数) + n_补充天数 >= d_开始时间 + n_Daycount And a.医生id = n_医生id And
                                 (a.开始时间 < Nvl(a.停诊开始时间, a.终止时间) Or a.终止时间 > Nvl(a.停诊终止时间, a.开始时间)) And
                                 Nvl(a.是否锁定, 0) = 0 And Exists
                            (Select 1
                                  From 临床出诊安排 M, 临床出诊表 N
                                  Where m.Id = a.安排id And m.出诊id = n.Id And n.发布时间 Is Not Null)) Loop
                n_已挂数   := n_已挂数 + Nvl(r_出诊.已约数, 0);
                n_限号数   := n_限号数 + Nvl(r_出诊.限约数, r_出诊.限号数);
                v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                n_安排存在 := 1;
              End Loop;
              If v_上班时间 Is Not Null Then
                v_上班时间 := Substr(v_上班时间, 2);
              End If;
              If n_安排存在 = 1 Then
                v_Temp := v_Temp || '<PB>' || '<RQ>' || To_Char(Trunc(d_开始时间 + n_Daycount), 'YYYY-MM-DD') || '</RQ>' ||
                          '<SYHS>' || n_限号数 - n_已挂数 || '</SYHS>' || '<SBSJ>' || v_上班时间 || '</SBSJ>' || '<YGS>' || n_已挂数 ||
                          '</YGS>' || '</PB>';
              End If;
            End If;
          Else
            --合作单位
            If Trunc(d_开始时间 + n_Daycount) = Trunc(Sysdate) Then
              For r_出诊 In (Select a.Id, a.已挂数, a.限号数, a.限约数, a.上班时段, a.是否序号控制
                           From 临床出诊记录 A, 临床出诊号源 B
                           Where a.出诊日期 = Trunc(d_开始时间 + n_Daycount) And a.号源id = b.Id And
                                 Sysdate + Nvl(b.预约天数, n_预约天数) + n_补充天数 >= d_开始时间 + n_Daycount And a.医生id = n_医生id And
                                 (a.开始时间 < Nvl(a.停诊开始时间, a.终止时间) Or a.终止时间 > Nvl(a.停诊终止时间, a.开始时间)) And
                                 Nvl(a.是否锁定, 0) = 0 And Exists
                            (Select 1
                                  From 临床出诊安排 M, 临床出诊表 N
                                  Where m.Id = a.安排id And m.出诊id = n.Id And n.发布时间 Is Not Null)) Loop
                Begin
                  Select 控制方式
                  Into n_合约模式
                  From 临床出诊挂号控制记录
                  Where 记录id = r_出诊.Id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1 And Rownum < 2;
                Exception
                  When Others Then
                    n_合约模式 := 4;
                End;
                If n_合约模式 = 1 Or n_合约模式 = 2 Then
                  Select 数量
                  Into n_限号数
                  From 临床出诊挂号控制记录
                  Where 记录id = r_出诊.Id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1;
                  If n_合约模式 = 1 Then
                    n_限号数 := n_限号数 * Nvl(r_出诊.限约数, r_出诊.限号数) / 100;
                  End If;
                  Select Count(1)
                  Into n_已挂数
                  From 病人挂号记录
                  Where 出诊记录id = r_出诊.Id And 记录状态 = 1 And 合作单位 = v_合作单位;
                  If r_出诊.限号数 - r_出诊.已挂数 < n_限号数 - n_已挂数 Then
                    n_剩余数 := n_剩余数 + r_出诊.限号数 - r_出诊.已挂数;
                  Else
                    n_剩余数 := n_剩余数 + n_限号数 - n_已挂数;
                  End If;
                  n_总已挂数 := n_总已挂数 + n_已挂数;
                  v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                  n_安排存在 := 1;
                End If;
                If n_合约模式 = 3 Then
                  If r_出诊.是否序号控制 = 0 Then
                    n_总已挂数 := n_总已挂数 + Nvl(r_出诊.已挂数, 0);
                    n_剩余数   := n_剩余数 + r_出诊.限号数 - Nvl(r_出诊.已挂数, 0);
                    v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                    n_安排存在 := 1;
                  Else
                    For r_合作 In (Select 序号, 数量
                                 From 临床出诊挂号控制记录
                                 Where 记录id = r_出诊.Id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1) Loop
                      Begin
                        Select 1
                        Into n_Exists
                        From 临床出诊序号控制
                        Where 记录id = r_出诊.Id And 序号 = r_合作.序号 And Nvl(挂号状态, 0) = 0;
                      Exception
                        When Others Then
                          n_Exists := 0;
                      End;
                      If n_Exists = 1 Then
                        n_剩余数   := n_剩余数 + 1;
                        n_安排存在 := 1;
                      End If;
                    End Loop;
                    v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                    n_总已挂数 := n_总已挂数 + Nvl(r_出诊.已挂数, 0);
                  End If;
                End If;
                If n_合约模式 = 4 Then
                  n_总已挂数 := n_总已挂数 + Nvl(r_出诊.已挂数, 0);
                  n_剩余数   := n_剩余数 + r_出诊.限号数 - Nvl(r_出诊.已挂数, 0);
                  v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                  n_安排存在 := 1;
                End If;
              End Loop;
            
              If v_上班时间 Is Not Null Then
                v_上班时间 := Substr(v_上班时间, 2);
              End If;
              If n_安排存在 = 1 Then
                v_Temp := v_Temp || '<PB>' || '<RQ>' || To_Char(Trunc(d_开始时间 + n_Daycount), 'YYYY-MM-DD') || '</RQ>' ||
                          '<SYHS>' || n_剩余数 || '</SYHS>' || '<SBSJ>' || v_上班时间 || '</SBSJ>' || '<YGS>' || n_总已挂数 ||
                          '</YGS>' || '</PB>';
              End If;
            Else
              --非当天
              For r_出诊 In (Select a.Id, a.已约数, a.已挂数, a.限号数, a.限约数, a.上班时段, a.是否序号控制
                           From 临床出诊记录 A, 临床出诊号源 B
                           Where a.出诊日期 = Trunc(d_开始时间 + n_Daycount) And a.号源id = b.Id And
                                 Sysdate + Nvl(b.预约天数, n_预约天数) + n_补充天数 >= d_开始时间 + n_Daycount And a.医生id = n_医生id And
                                 (a.开始时间 < Nvl(a.停诊开始时间, a.终止时间) Or a.终止时间 > Nvl(a.停诊终止时间, a.开始时间)) And
                                 Nvl(a.是否锁定, 0) = 0 And Exists
                            (Select 1
                                  From 临床出诊安排 M, 临床出诊表 N
                                  Where m.Id = a.安排id And m.出诊id = n.Id And n.发布时间 Is Not Null)) Loop
                Begin
                  Select 控制方式
                  Into n_合约模式
                  From 临床出诊挂号控制记录
                  Where 记录id = r_出诊.Id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1 And Rownum < 2;
                Exception
                  When Others Then
                    n_合约模式 := 4;
                End;
                If n_合约模式 = 1 Or n_合约模式 = 2 Then
                  Select 数量
                  Into n_限号数
                  From 临床出诊挂号控制记录
                  Where 记录id = r_出诊.Id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1;
                  If n_合约模式 = 1 Then
                    n_限号数 := n_限号数 * Nvl(r_出诊.限约数, r_出诊.限号数) / 100;
                  End If;
                  Select Count(1)
                  Into n_已挂数
                  From 病人挂号记录
                  Where 出诊记录id = r_出诊.Id And 记录状态 = 1 And 合作单位 = v_合作单位;
                  If Nvl(r_出诊.限约数, r_出诊.限号数) - r_出诊.已约数 < n_限号数 - n_已挂数 Then
                    n_剩余数 := n_剩余数 + Nvl(r_出诊.限约数, r_出诊.限号数) - r_出诊.已约数;
                  Else
                    n_剩余数 := n_剩余数 + n_限号数 - n_已挂数;
                  End If;
                  n_总已挂数 := n_总已挂数 + n_已挂数;
                  v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                  n_安排存在 := 1;
                End If;
                If n_合约模式 = 3 Then
                  If r_出诊.是否序号控制 = 0 Then
                    --分时段非序号控制
                    For r_合作 In (Select 序号, 数量
                                 From 临床出诊挂号控制记录
                                 Where 记录id = r_出诊.Id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1) Loop
                      Select Count(1)
                      Into n_Exists
                      From 临床出诊序号控制
                      Where 预约顺序号 Is Not Null And 记录id = r_出诊.Id And 序号 = r_合作.序号 And Nvl(挂号状态, 0) <> 0;
                      If r_合作.数量 - n_Exists > 0 Then
                        n_剩余数   := n_剩余数 + r_合作.数量 - n_Exists;
                        n_总已挂数 := n_总已挂数 + n_Exists;
                        n_安排存在 := 1;
                      Else
                        n_总已挂数 := n_总已挂数 + n_Exists;
                        n_安排存在 := 1;
                      End If;
                    End Loop;
                    v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                  Else
                    For r_合作 In (Select 序号
                                 From 临床出诊挂号控制记录
                                 Where 记录id = r_出诊.Id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1) Loop
                      Begin
                        Select 1
                        Into n_Exists
                        From 临床出诊序号控制
                        Where 记录id = r_出诊.Id And 序号 = r_合作.序号 And Nvl(挂号状态, 0) = 0;
                      Exception
                        When Others Then
                          n_Exists := 0;
                      End;
                      If n_Exists = 1 Then
                        n_剩余数   := n_剩余数 + 1;
                        n_安排存在 := 1;
                      Else
                        n_总已挂数 := n_总已挂数 + 1;
                        n_安排存在 := 1;
                      End If;
                    End Loop;
                    v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                  End If;
                End If;
                If n_合约模式 = 4 Then
                  n_总已挂数 := n_总已挂数 + Nvl(r_出诊.已约数, 0);
                  n_剩余数   := n_剩余数 + r_出诊.限约数 - Nvl(r_出诊.已约数, 0);
                  v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                  n_安排存在 := 1;
                End If;
              End Loop;
              If v_上班时间 Is Not Null Then
                v_上班时间 := Substr(v_上班时间, 2);
              End If;
              If n_安排存在 = 1 Then
                v_Temp := v_Temp || '<PB>' || '<RQ>' || To_Char(Trunc(d_开始时间 + n_Daycount), 'YYYY-MM-DD') || '</RQ>' ||
                          '<SYHS>' || n_剩余数 || '</SYHS>' || '<SBSJ>' || v_上班时间 || '</SBSJ>' || '<YGS>' || n_总已挂数 ||
                          '</YGS>' || '</PB>';
              End If;
            End If;
          End If;
        End If;
        n_Daycount := n_Daycount + 1;
      End Loop;
    Else
      --通过科室+医生查找
      While (n_Daycount < n_查询天数) Loop
        If Trunc(d_开始时间 + n_Daycount) < To_Date(Substr(v_启用时间, 1, Instr(v_启用时间, ' ') - 1), 'yyyy-mm-dd') Then
          v_上班时间 := Null;
          n_总已挂数 := 0;
          n_已挂数   := 0;
          n_剩余数   := 0;
          n_限号数   := 0;
          n_已约数   := 0;
          n_限约数   := 0;
          n_安排存在 := 0;
          For r_排班 In (Select d_开始时间 + n_Daycount As 日期, a.排班, a.限号数, a.限约数, Nvl(Hz.已挂数, 0) As 已挂数, Nvl(Hz.已约数, 0) As 已约数,
                              a.安排id, a.计划id, a.号码, a.号类
                       
                       From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Nvl(Ap.医生id, 0) As 医生id, Ry.专业技术职务 As 职称,
                                     Ap.号码, Ap.安排id, Ap.计划id, Ap.排班, Ap.项目id, Fy.名称 As 项目名称, Ap.序号控制, Ap.限号数, Ap.限约数
                              
                              From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Ap.医生id, Ap.号码, Ap.Id As 安排id, 0 As 计划id,
                                            Ap.项目id, Nvl(Ap.序号控制, 0) As 序号控制,
                                            Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', Ap.周日, '2', Ap.周一, '3', Ap.周二, '4',
                                                    Ap.周三, '5', Ap.周四, '6', Ap.周五, '7', Ap.周六, Null) As 排班,
                                            Nvl(Xz.限约数, Xz.限号数) As 限约数, Nvl(Xz.限号数, 0) As 限号数
                                     From 挂号安排 Ap, 部门表 Bm, 挂号安排限制 Xz
                                     Where Ap.科室id = Bm.Id(+) And Sysdate + Nvl(Ap.预约天数, n_预约天数) >= d_开始时间 + n_Daycount And
                                           Ap.医生id = n_医生id And Ap.科室id = n_科室id And Ap.停用日期 Is Null And
                                           d_开始时间 + n_Daycount Between Nvl(Ap.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                           Nvl(Ap.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.安排id(+) = Ap.Id And
                                           Xz.限制项目(+) =
                                           Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4',
                                                  '周三', '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                      (Select Rownum
                                            From 挂号安排停用状态 Ty
                                            Where Ty.安排id = Ap.Id And d_开始时间 + n_Daycount Between Ty.开始停止时间 And Ty.结束停止时间) And
                                           Not Exists (Select Rownum
                                            From 挂号安排计划 Jh
                                            Where Jh.安排id = Ap.Id And Jh.审核时间 Is Not Null And
                                                  d_开始时间 + n_Daycount Between
                                                  Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                                  Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')))
                                     Union All
                                     Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Jh.医生姓名, Jh.医生id, Ap.号码, Ap.Id As 安排id,
                                            Jh.Id As 计划id, Jh.项目id, Nvl(Jh.序号控制, 0) As 序号控制,
                                            Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', Jh.周日, '2', Jh.周一, '3', Jh.周二, '4',
                                                    Jh.周三, '5', Jh.周四, '6', Jh.周五, '7', Jh.周六, Null) As 排班,
                                            Nvl(Xz.限约数, Xz.限号数) As 限约数, Nvl(Xz.限号数, 0) As 限号数
                                     From 挂号安排计划 Jh, 挂号安排 Ap, 部门表 Bm, 挂号计划限制 Xz
                                     Where Jh.安排id = Ap.Id And Sysdate + Nvl(Ap.预约天数, n_预约天数) >= d_开始时间 + n_Daycount And
                                           Ap.科室id = Bm.Id(+) And Ap.停用日期 Is Null And Jh.医生id = n_医生id And Ap.科室id = n_科室id And
                                           d_开始时间 + n_Daycount Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                           Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.计划id(+) = Jh.Id And
                                           Xz.限制项目(+) =
                                           Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4',
                                                  '周三', '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                      (Select Rownum
                                            From 挂号安排停用状态 Ty
                                            Where Ty.安排id = Ap.Id And d_开始时间 + n_Daycount Between Ty.开始停止时间 And Ty.结束停止时间) And
                                           (Jh.生效时间, Jh.安排id) =
                                           (Select Max(Sxjh.生效时间) As 生效时间, 安排id
                                            From 挂号安排计划 Sxjh
                                            Where Sxjh.审核时间 Is Not Null And
                                                  d_开始时间 + n_Daycount Between
                                                  Nvl(Sxjh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                                  Nvl(Sxjh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Sxjh.安排id = Jh.安排id
                                            Group By Sxjh.安排id)) Ap, 部门表 Bm, 人员表 Ry, 收费项目目录 Fy
                              Where Ap.科室id = Bm.Id(+) And Ap.医生id = Ry.Id(+) And Ap.项目id = Fy.Id And 排班 Is Not Null) A,
                            病人挂号汇总 Hz, 收费价目 B
                       Where a.号码 = Hz.号码(+) And Hz.日期(+) = Trunc(d_开始时间 + n_Daycount) And a.项目id = b.收费细目id And
                             b.终止日期 > d_开始时间 + n_Daycount And b.执行日期 <= d_开始时间 + n_Daycount And
                             (b.价格等级 = v_普通等级 Or
                             (b.价格等级 Is Null And Not Exists
                              (Select 1
                                From 收费价目
                                Where b.收费细目id = 收费细目id And 价格等级 = v_普通等级 And Sysdate Between 执行日期 And
                                      Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')))))) Loop
            If v_号类 Is Null Or Instr(',' || v_号类 || ',', ',' || r_排班.号类 || ',') > 0 Then
              v_上班时间 := v_上班时间 || '+' || r_排班.排班;
              n_总已挂数 := n_总已挂数 + r_排班.已挂数;
              n_已挂数   := r_排班.已挂数;
              n_限号数   := r_排班.限号数;
              n_已约数   := r_排班.已约数;
              n_限约数   := r_排班.限约数;
              n_安排id   := Nvl(r_排班.安排id, 0);
              n_计划id   := Nvl(r_排班.计划id, 0);
              v_号码     := r_排班.号码;
              n_安排存在 := 1;
            
              If v_上班时间 Is Not Null Then
                If v_合作单位 Is Not Null Then
                  If n_计划id <> 0 Then
                    Begin
                      Select 1
                      Into n_合约存在
                      From 合作单位计划控制
                      Where 计划id = n_计划id And 合作单位 = v_合作单位 And Rownum < 2;
                    Exception
                      When Others Then
                        n_合约存在 := 0;
                    End;
                  Else
                    Begin
                      Select 1
                      Into n_合约存在
                      From 合作单位安排控制
                      Where 安排id = n_安排id And 合作单位 = v_合作单位 And Rownum < 2;
                    Exception
                      When Others Then
                        n_合约存在 := 0;
                    End;
                  End If;
                End If;
              
                If v_合作单位 Is Null Or Nvl(n_合约存在, 0) = 0 Then
                  If n_计划id <> 0 Then
                    Begin
                      Select Sum(数量)
                      Into n_合作单位数量
                      From 合作单位计划控制
                      Where 计划id = n_计划id And
                            限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                          '5', '周四', '6', '周五', '7', '周六', Null);
                    Exception
                      When Others Then
                        n_合作单位数量 := 0;
                    End;
                  Else
                    Begin
                      Select Sum(数量)
                      Into n_合作单位数量
                      From 合作单位安排控制
                      Where 安排id = n_安排id And
                            限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                          '5', '周四', '6', '周五', '7', '周六', Null);
                    Exception
                      When Others Then
                        n_合作单位数量 := 0;
                    End;
                  End If;
                  Begin
                    Select Count(1)
                    Into n_合约已挂数
                    From 病人挂号记录
                    Where 号别 = v_号码 And 记录状态 = 1 And 合作单位 Is Not Null And 发生时间 Between Trunc(d_开始时间 + n_Daycount) And
                          Trunc(d_开始时间 + n_Daycount + 1) - 1 / 60 / 60 / 24;
                  Exception
                    When Others Then
                      n_合约已挂数 := 0;
                  End;
                  If n_合作单位数量 = 0 Then
                    n_合作单位数量 := Null;
                  End If;
                  If Trunc(d_开始时间 + n_Daycount) > Trunc(Sysdate) Then
                    n_剩余数 := Nvl(n_剩余数, 0) + n_限约数 - n_已约数 - Nvl(n_合作单位数量, n_合约已挂数) + Nvl(n_合约已挂数, 0);
                  Else
                    n_剩余数 := Nvl(n_剩余数, 0) + n_限号数 - n_已挂数 - Nvl(n_合作单位数量, n_合约已挂数) + Nvl(n_合约已挂数, 0);
                  End If;
                Else
                  --合约单位
                  If n_计划id <> 0 Then
                    Begin
                      Select 1
                      Into n_禁用
                      From 合作单位计划控制
                      Where 计划id = n_计划id And
                            限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                          '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位 And 数量 = 0 And
                            Rownum < 2;
                    Exception
                      When Others Then
                        n_禁用 := 0;
                    End;
                  Else
                    Begin
                      Select 1
                      Into n_禁用
                      From 合作单位安排控制
                      Where 安排id = n_安排id And
                            限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                          '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位 And 数量 = 0 And
                            Rownum < 2;
                    Exception
                      When Others Then
                        n_禁用 := 0;
                    End;
                  End If;
                  If Nvl(n_禁用, 0) = 0 Then
                    Begin
                      Select Count(1)
                      Into n_合约已挂数
                      From 病人挂号记录
                      Where 号别 = v_号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_开始时间 + n_Daycount) And
                            Trunc(d_开始时间 + n_Daycount + 1) - 1 / 60 / 60 / 24;
                    Exception
                      When Others Then
                        n_合约已挂数 := 0;
                    End;
                    If n_计划id <> 0 Then
                      Begin
                        Select Sum(数量)
                        Into n_合作单位数量
                        From 合作单位计划控制
                        Where 计划id = n_计划id And
                              限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4',
                                            '周三', '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
                      Exception
                        When Others Then
                          n_合作单位数量 := 0;
                      End;
                    Else
                      Begin
                        Select Sum(数量)
                        Into n_合作单位数量
                        From 合作单位安排控制
                        Where 安排id = n_安排id And
                              限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4',
                                            '周三', '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
                      Exception
                        When Others Then
                          n_合作单位数量 := 0;
                      End;
                    End If;
                    If n_合作单位数量 = 0 Then
                      n_合作单位数量 := Null;
                    End If;
                    n_剩余数 := Nvl(n_剩余数, 0) + Nvl(n_合作单位数量, n_合约已挂数) - Nvl(n_合约已挂数, 0);
                  
                  End If;
                End If;
              End If;
              n_合作单位数量 := 0;
              n_合约存在     := 0;
              n_禁用         := 0;
            End If;
          End Loop;
          v_上班时间 := Substr(v_上班时间, 2);
          If n_安排存在 = 1 Then
            v_Temp := v_Temp || '<PB>' || '<RQ>' || To_Char(Trunc(d_开始时间 + n_Daycount), 'YYYY-MM-DD') || '</RQ>' ||
                      '<SYHS>' || n_剩余数 || '</SYHS>' || '<SBSJ>' || v_上班时间 || '</SBSJ>' || '<YGS>' || n_总已挂数 ||
                      '</YGS>' || '</PB>';
          End If;
        Else
          n_安排存在 := 0;
          v_上班时间 := Null;
          n_总已挂数 := 0;
          n_已挂数   := 0;
          n_剩余数   := 0;
          n_限号数   := 0;
          n_已约数   := 0;
          n_限约数   := 0;
          If v_合作单位 Is Null Then
            --非合作单位
            If Trunc(d_开始时间 + n_Daycount) = Trunc(Sysdate) Then
              --当天挂号
              For r_出诊 In (Select a.已挂数, a.限号数, a.上班时段
                           From 临床出诊记录 A, 临床出诊号源 B
                           Where a.出诊日期 = Trunc(d_开始时间 + n_Daycount) And a.号源id = b.Id And
                                 Sysdate + Nvl(b.预约天数, n_预约天数) + n_补充天数 >= d_开始时间 + n_Daycount And a.医生id = n_医生id And
                                 a.科室id = n_科室id And (a.开始时间 < Nvl(a.停诊开始时间, a.终止时间) Or a.终止时间 > Nvl(a.停诊终止时间, a.开始时间)) And
                                 Nvl(a.是否锁定, 0) = 0 And Exists
                            (Select 1
                                  From 临床出诊安排 M, 临床出诊表 N
                                  Where m.Id = a.安排id And m.出诊id = n.Id And n.发布时间 Is Not Null)) Loop
                n_已挂数   := n_已挂数 + Nvl(r_出诊.已挂数, 0);
                n_限号数   := n_限号数 + r_出诊.限号数;
                v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                n_安排存在 := 1;
              End Loop;
              If v_上班时间 Is Not Null Then
                v_上班时间 := Substr(v_上班时间, 2);
              End If;
              If n_安排存在 = 1 Then
                v_Temp := v_Temp || '<PB>' || '<RQ>' || To_Char(Trunc(d_开始时间 + n_Daycount), 'YYYY-MM-DD') || '</RQ>' ||
                          '<SYHS>' || n_限号数 - n_已挂数 || '</SYHS>' || '<SBSJ>' || v_上班时间 || '</SBSJ>' || '<YGS>' || n_已挂数 ||
                          '</YGS>' || '</PB>';
              End If;
            Else
              --预约挂号
              For r_出诊 In (Select a.已约数, a.限号数, a.限约数, a.上班时段
                           From 临床出诊记录 A, 临床出诊号源 B
                           Where a.出诊日期 = Trunc(d_开始时间 + n_Daycount) And a.号源id = b.Id And
                                 Sysdate + Nvl(b.预约天数, n_预约天数) + n_补充天数 >= d_开始时间 + n_Daycount And a.医生id = n_医生id And
                                 a.科室id = n_科室id And (a.开始时间 < Nvl(a.停诊开始时间, a.终止时间) Or a.终止时间 > Nvl(a.停诊终止时间, a.开始时间)) And
                                 Nvl(a.是否锁定, 0) = 0 And Exists
                            (Select 1
                                  From 临床出诊安排 M, 临床出诊表 N
                                  Where m.Id = a.安排id And m.出诊id = n.Id And n.发布时间 Is Not Null)) Loop
                n_已挂数   := n_已挂数 + Nvl(r_出诊.已约数, 0);
                n_限号数   := n_限号数 + Nvl(r_出诊.限约数, r_出诊.限号数);
                v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                n_安排存在 := 1;
              End Loop;
              If v_上班时间 Is Not Null Then
                v_上班时间 := Substr(v_上班时间, 2);
              End If;
              If n_安排存在 = 1 Then
                v_Temp := v_Temp || '<PB>' || '<RQ>' || To_Char(Trunc(d_开始时间 + n_Daycount), 'YYYY-MM-DD') || '</RQ>' ||
                          '<SYHS>' || n_限号数 - n_已挂数 || '</SYHS>' || '<SBSJ>' || v_上班时间 || '</SBSJ>' || '<YGS>' || n_已挂数 ||
                          '</YGS>' || '</PB>';
              End If;
            End If;
          Else
            --合作单位
            If Trunc(d_开始时间 + n_Daycount) = Trunc(Sysdate) Then
              For r_出诊 In (Select a.Id, a.已挂数, a.限号数, a.限约数, a.上班时段, a.是否序号控制
                           From 临床出诊记录 A, 临床出诊号源 B
                           Where a.出诊日期 = Trunc(d_开始时间 + n_Daycount) And a.号源id = b.Id And
                                 Sysdate + Nvl(b.预约天数, n_预约天数) + n_补充天数 >= d_开始时间 + n_Daycount And a.医生id = n_医生id And
                                 a.科室id = n_科室id And (a.开始时间 < Nvl(a.停诊开始时间, a.终止时间) Or a.终止时间 > Nvl(a.停诊终止时间, a.开始时间)) And
                                 Nvl(a.是否锁定, 0) = 0 And Exists
                            (Select 1
                                  From 临床出诊安排 M, 临床出诊表 N
                                  Where m.Id = a.安排id And m.出诊id = n.Id And n.发布时间 Is Not Null)) Loop
                Begin
                  Select 控制方式
                  Into n_合约模式
                  From 临床出诊挂号控制记录
                  Where 记录id = r_出诊.Id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1 And Rownum < 2;
                Exception
                  When Others Then
                    n_合约模式 := 4;
                End;
                If n_合约模式 = 1 Or n_合约模式 = 2 Then
                  Select 数量
                  Into n_限号数
                  From 临床出诊挂号控制记录
                  Where 记录id = r_出诊.Id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1;
                  If n_合约模式 = 1 Then
                    n_限号数 := n_限号数 * Nvl(r_出诊.限约数, r_出诊.限号数) / 100;
                  End If;
                  Select Count(1)
                  Into n_已挂数
                  From 病人挂号记录
                  Where 出诊记录id = r_出诊.Id And 记录状态 = 1 And 合作单位 = v_合作单位;
                  If r_出诊.限号数 - r_出诊.已挂数 < n_限号数 - n_已挂数 Then
                    n_剩余数 := n_剩余数 + r_出诊.限号数 - r_出诊.已挂数;
                  Else
                    n_剩余数 := n_剩余数 + n_限号数 - n_已挂数;
                  End If;
                  n_总已挂数 := n_总已挂数 + n_已挂数;
                  v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                  n_安排存在 := 1;
                End If;
                If n_合约模式 = 3 Then
                  If r_出诊.是否序号控制 = 0 Then
                    n_总已挂数 := n_总已挂数 + Nvl(r_出诊.已挂数, 0);
                    n_剩余数   := n_剩余数 + r_出诊.限号数 - Nvl(r_出诊.已挂数, 0);
                    v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                    n_安排存在 := 1;
                  Else
                    For r_合作 In (Select 序号, 数量
                                 From 临床出诊挂号控制记录
                                 Where 记录id = r_出诊.Id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1) Loop
                      Begin
                        Select 1
                        Into n_Exists
                        From 临床出诊序号控制
                        Where 记录id = r_出诊.Id And 序号 = r_合作.序号 And Nvl(挂号状态, 0) = 0;
                      Exception
                        When Others Then
                          n_Exists := 0;
                      End;
                      If n_Exists = 1 Then
                        n_剩余数   := n_剩余数 + 1;
                        n_安排存在 := 1;
                      End If;
                    End Loop;
                    v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                    n_总已挂数 := n_总已挂数 + Nvl(r_出诊.已挂数, 0);
                  End If;
                End If;
                If n_合约模式 = 4 Then
                  n_总已挂数 := n_总已挂数 + Nvl(r_出诊.已挂数, 0);
                  n_剩余数   := n_剩余数 + r_出诊.限号数 - Nvl(r_出诊.已挂数, 0);
                  v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                  n_安排存在 := 1;
                End If;
              End Loop;
            
              If v_上班时间 Is Not Null Then
                v_上班时间 := Substr(v_上班时间, 2);
              End If;
              If n_安排存在 = 1 Then
                v_Temp := v_Temp || '<PB>' || '<RQ>' || To_Char(Trunc(d_开始时间 + n_Daycount), 'YYYY-MM-DD') || '</RQ>' ||
                          '<SYHS>' || n_剩余数 || '</SYHS>' || '<SBSJ>' || v_上班时间 || '</SBSJ>' || '<YGS>' || n_总已挂数 ||
                          '</YGS>' || '</PB>';
              End If;
            Else
              --非当天
              For r_出诊 In (Select a.Id, a.已约数, a.已挂数, a.限号数, a.限约数, a.上班时段, a.是否序号控制
                           From 临床出诊记录 A, 临床出诊号源 B
                           Where a.出诊日期 = Trunc(d_开始时间 + n_Daycount) And a.号源id = b.Id And
                                 Sysdate + Nvl(b.预约天数, n_预约天数) + n_补充天数 >= d_开始时间 + n_Daycount And a.医生id = n_医生id And
                                 a.科室id = n_科室id And (a.开始时间 < Nvl(a.停诊开始时间, a.终止时间) Or a.终止时间 > Nvl(a.停诊终止时间, a.开始时间)) And
                                 Nvl(a.是否锁定, 0) = 0 And Exists
                            (Select 1
                                  From 临床出诊安排 M, 临床出诊表 N
                                  Where m.Id = a.安排id And m.出诊id = n.Id And n.发布时间 Is Not Null)) Loop
                Begin
                  Select 控制方式
                  Into n_合约模式
                  From 临床出诊挂号控制记录
                  Where 记录id = r_出诊.Id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1 And Rownum < 2;
                Exception
                  When Others Then
                    n_合约模式 := 4;
                End;
                If n_合约模式 = 1 Or n_合约模式 = 2 Then
                  Select 数量
                  Into n_限号数
                  From 临床出诊挂号控制记录
                  Where 记录id = r_出诊.Id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1;
                  If n_合约模式 = 1 Then
                    n_限号数 := n_限号数 * Nvl(r_出诊.限约数, r_出诊.限号数) / 100;
                  End If;
                  Select Count(1)
                  Into n_已挂数
                  From 病人挂号记录
                  Where 出诊记录id = r_出诊.Id And 记录状态 = 1 And 合作单位 = v_合作单位;
                  If Nvl(r_出诊.限约数, r_出诊.限号数) - r_出诊.已约数 < n_限号数 - n_已挂数 Then
                    n_剩余数 := n_剩余数 + Nvl(r_出诊.限约数, r_出诊.限号数) - r_出诊.已约数;
                  Else
                    n_剩余数 := n_剩余数 + n_限号数 - n_已挂数;
                  End If;
                  n_总已挂数 := n_总已挂数 + n_已挂数;
                  v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                  n_安排存在 := 1;
                End If;
                If n_合约模式 = 3 Then
                  If r_出诊.是否序号控制 = 0 Then
                    --分时段非序号控制
                    For r_合作 In (Select 序号, 数量
                                 From 临床出诊挂号控制记录
                                 Where 记录id = r_出诊.Id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1) Loop
                      Select Count(1)
                      Into n_Exists
                      From 临床出诊序号控制
                      Where 预约顺序号 Is Not Null And 记录id = r_出诊.Id And 序号 = r_合作.序号 And Nvl(挂号状态, 0) <> 0;
                      If r_合作.数量 - n_Exists > 0 Then
                        n_剩余数   := n_剩余数 + r_合作.数量 - n_Exists;
                        n_总已挂数 := n_总已挂数 + n_Exists;
                        n_安排存在 := 1;
                      Else
                        n_总已挂数 := n_总已挂数 + n_Exists;
                        n_安排存在 := 1;
                      End If;
                    End Loop;
                    v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                  Else
                    For r_合作 In (Select 序号
                                 From 临床出诊挂号控制记录
                                 Where 记录id = r_出诊.Id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1) Loop
                      Begin
                        Select 1
                        Into n_Exists
                        From 临床出诊序号控制
                        Where 记录id = r_出诊.Id And 序号 = r_合作.序号 And Nvl(挂号状态, 0) = 0;
                      Exception
                        When Others Then
                          n_Exists := 0;
                      End;
                      If n_Exists = 1 Then
                        n_剩余数   := n_剩余数 + 1;
                        n_安排存在 := 1;
                      Else
                        n_总已挂数 := n_总已挂数 + 1;
                        n_安排存在 := 1;
                      End If;
                    End Loop;
                    v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                  End If;
                End If;
                If n_合约模式 = 4 Then
                  n_总已挂数 := n_总已挂数 + Nvl(r_出诊.已约数, 0);
                  n_剩余数   := n_剩余数 + r_出诊.限约数 - Nvl(r_出诊.已约数, 0);
                  v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                  n_安排存在 := 1;
                End If;
              End Loop;
              If v_上班时间 Is Not Null Then
                v_上班时间 := Substr(v_上班时间, 2);
              End If;
              If n_安排存在 = 1 Then
                v_Temp := v_Temp || '<PB>' || '<RQ>' || To_Char(Trunc(d_开始时间 + n_Daycount), 'YYYY-MM-DD') || '</RQ>' ||
                          '<SYHS>' || n_剩余数 || '</SYHS>' || '<SBSJ>' || v_上班时间 || '</SBSJ>' || '<YGS>' || n_总已挂数 ||
                          '</YGS>' || '</PB>';
              End If;
            End If;
          End If;
        End If;
        n_Daycount := n_Daycount + 1;
      End Loop;
    End If;
    v_Temp := '<PBLIST>' || v_Temp || '</PBLIST>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  End If;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Docarrange;
/

--100956:刘尔旋,2017-5-23,收费价格等级支付宝相关调整
Create Or Replace Procedure Zl_Third_Getmoney
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  -------------------------------------------------------------------------------------------------- 
  --功能:计算项目的实收金额
  --入参:Xml_In: 
  --  <IN> 
  --    <FB>费别</FB>                      //费别名称,可以不传
  --    <XMID>收费项目ID</XMID>        //收费项目的ID
  --    <CXFY>1</CXFY>                     //是否计算从项费用,-0不计算,1-计算，默认计算
  --    <ZD></ZD>                          //站点
  --  </IN> 
  --出参:Xml_Out 
  --  <OUTPUT> 
  --    <JE>5</JE>                   //返回根据费别计算好的金额
  --                                     //如无下列错误结点则说明正确执行 
  --    <ERROR> 
  --      <MSG>错误信息</MSG> 
  --    </ERROR> 
  --  </OUTPUT> 
  -------------------------------------------------------------------------------------------------- 

  v_费别       费别.名称%Type;
  n_收费项目id 收费项目目录.Id%Type;
  n_收入项目id 收费价目.收入项目id%Type;
  n_标准单价   收费价目.现价%Type;
  v_收费类别   收费项目目录.类别%Type;
  v_收据费目   收入项目.收据费目%Type;
  n_屏蔽费别   收费项目目录.屏蔽费别%Type;
  n_实收金额   门诊费用记录.实收金额%Type;
  v_金额       Varchar2(200);
  v_站点       部门表.站点%Type;
  n_从项费用   Number(3);
  n_不计算     Number(3);
  v_Temp       Varchar2(32767); --临时XML 
  x_Templet    Xmltype; --模板XML 
  v_Err_Msg    Varchar2(200);
  n_Exists     Number(2);
  v_药品等级   Varchar2(100);
  v_卫材等级   Varchar2(100);
  v_普通等级   Varchar2(100);
  v_Pricegrade Varchar2(500);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/FB'), Extractvalue(Value(A), 'IN/XMID'), Extractvalue(Value(A), 'IN/CXFY'),
         Extractvalue(Value(A), 'IN/ZD')
  Into v_费别, n_收费项目id, n_从项费用, v_站点
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  v_Pricegrade := Zl_Get_Pricegrade(v_站点);
  v_药品等级   := Substr(v_Pricegrade, 1, Instr(v_Pricegrade, '|') - 1);
  v_Pricegrade := Substr(v_Pricegrade, Instr(v_Pricegrade, '|') + 1);
  v_卫材等级   := Substr(v_Pricegrade, 1, Instr(v_Pricegrade, '|') - 1);
  v_Pricegrade := Substr(v_Pricegrade, Instr(v_Pricegrade, '|') + 1);
  v_普通等级   := Substr(v_Pricegrade, 1, Instr(v_Pricegrade, '|') - 1);

  n_不计算 := 0;
  If v_费别 Is Null Then
    n_不计算 := 1;
    Select 名称 Into v_费别 From 费别 Where 缺省标志 = 1 And Rownum < 2;
  End If;

  Select a.类别, b.现价, b.收入项目id, c.收据费目, a.屏蔽费别
  Into v_收费类别, n_标准单价, n_收入项目id, v_收据费目, n_屏蔽费别
  From 收费项目目录 A, 收费价目 B, 收入项目 C
  Where a.Id = n_收费项目id And b.收费细目id = a.Id And b.收入项目id = c.Id And Sysdate Between b.执行日期 And
        Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And
        ((Instr(';5;6;7;', ';' || a.类别 || ';') > 0 And b.价格等级 = v_药品等级) Or
        (Instr(';4;', ';' || a.类别 || ';') > 0 And b.价格等级 = v_卫材等级) Or
        (Instr(';4;5;6;7;', ';' || a.类别 || ';') = 0 And b.价格等级 = v_普通等级) Or
        (b.价格等级 Is Null And Not Exists
         (Select 1
           From 收费价目
           Where b.收费细目id = 收费细目id And Sysdate Between 执行日期 And Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')) And
                 ((Instr(';5;6;7;', ';' || a.类别 || ';') > 0 And 价格等级 = v_药品等级) Or
                 (Instr(';4;', ';' || a.类别 || ';') > 0 And 价格等级 = v_卫材等级) Or
                 (Instr(';4;5;6;7;', ';' || a.类别 || ';') = 0 And 价格等级 = v_普通等级))))) And Rownum < 2;

  If Nvl(n_屏蔽费别, 0) = 0 And n_不计算 = 0 Then
    v_金额     := Zl_Actualmoney(v_费别, n_收费项目id, n_收入项目id, n_标准单价);
    v_金额     := Substr(v_金额, Instr(v_金额, ':') + 1);
    n_实收金额 := Zl_To_Number(v_金额);
  Else
    n_实收金额 := n_标准单价;
  End If;

  If Nvl(n_从项费用, 1) = 1 Then
    For r_Subfee In (Select b.现价, a.从项数次, b.收入项目id, c.屏蔽费别, a.从项id As 收费细目id
                     From 收费从属项目 A, 收费价目 B, 收费项目目录 C
                     Where a.主项id = n_收费项目id And c.Id = a.从项id And a.从项id = b.Id And
                           ((Instr(';5;6;7;', ';' || c.类别 || ';') > 0 And b.价格等级 = v_药品等级) Or
                           (Instr(';4;', ';' || c.类别 || ';') > 0 And b.价格等级 = v_卫材等级) Or
                           (Instr(';4;5;6;7;', ';' || c.类别 || ';') = 0 And b.价格等级 = v_普通等级) Or
                           (b.价格等级 Is Null And Not Exists
                            (Select 1
                              From 收费价目
                              Where b.收费细目id = 收费细目id And Sysdate Between 执行日期 And
                                    Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')) And
                                    ((Instr(';5;6;7;', ';' || c.类别 || ';') > 0 And 价格等级 = v_药品等级) Or
                                    (Instr(';4;', ';' || c.类别 || ';') > 0 And 价格等级 = v_卫材等级) Or
                                    (Instr(';4;5;6;7;', ';' || c.类别 || ';') = 0 And 价格等级 = v_普通等级))))) And
                           Sysdate Between b.执行日期 And Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))) Loop
      If Nvl(r_Subfee.屏蔽费别, 0) = 0 And n_不计算 = 0 Then
        v_金额     := Zl_Actualmoney(v_费别, r_Subfee.收费细目id, r_Subfee.收入项目id, r_Subfee.现价);
        v_金额     := Substr(v_金额, Instr(v_金额, ':') + 1);
        n_实收金额 := n_实收金额 + Zl_To_Number(v_金额) * r_Subfee.从项数次;
      Else
        n_实收金额 := n_实收金额 + r_Subfee.现价 * r_Subfee.从项数次;
      End If;
    End Loop;
  End If;

  v_Temp := '<JE>' || n_实收金额 || '</JE>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Xml_Out := x_Templet;

Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getmoney;
/

--111342:焦博,2017-07-10,调整公共函数Zl_Third_Getpatiid增加传入参数姓名_IN
--110711:焦博,2017-06-28,增加入参节点身份证号,当病人ID不存在时,用身份证号获取病人ID
--100956:刘尔旋,2017-5-23,收费价格等级支付宝相关调整
Create Or Replace Procedure Zl_Third_Salereginfo
(
  Xml_In  In Xmltype,
  Xml_Out In Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:调用用户自定义函数获取指定的费别
  --入参:Xml_In:
  --  <IN>
  --       <XMID>123</XMID>   //要计算的收费项目的ID
  --       <BRID>421</BRID>   //病人ID
  --       <XM>姓名</XM>        //姓名
  --       <SFZH>身份证号</SFZH>   //身份证号
  --       <ZD>1</ZD>         //站点
  --  </IN>
  --出参:Xml_Out
  -- <OUTPUT>
  --  <YHJE>优惠金额</YHJE>
  --  <JE>计算后的金额</JE>
  --  <FB>计算后的费别</FB>
  -- </OUTPUT>
  --    如无下列错误结点则说明正确执行
  --    <ERROR>
  --      <MSG>错误信息</MSG>
  --    </ERROR>
  -- </OUTPUT>

  --------------------------------------------------------------------------------------------------
  x_Templet    Xmltype; --模板XML
  v_Err_Msg    Varchar2(200);
  v_Temp       Varchar2(500);
  n_项目id     挂号安排.项目id%Type;
  n_病人id     病人信息.病人id%Type;
  v_姓名       病人信息.姓名%Type;
  v_身份证号   病人信息.身份证号%Type;
  v_费别       病人信息.费别%Type;
  n_实收金额   门诊费用记录.实收金额%Type := 0;
  n_应收金额   门诊费用记录.应收金额%Type := 0;
  n_优惠金额   门诊费用记录.实收金额%Type := 0;
  v_站点       部门表.站点%Type;
  v_药品等级   Varchar2(100);
  v_卫材等级   Varchar2(100);
  v_普通等级   Varchar2(100);
  v_Pricegrade Varchar2(500);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');
  Select Extractvalue(Value(A), 'IN/BRID'), Extractvalue(Value(A), 'IN/XMID'), Extractvalue(Value(A), 'IN/ZD'),
  Extractvalue(Value(A), 'IN/SFZH'),Extractvalue(Value(A), 'IN/XM')
  Into n_病人id, n_项目id, v_站点, v_身份证号,v_姓名
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  If Nvl(n_病人id, 0) = 0 And Not v_身份证号 Is Null And v_姓名 Is Not Null Then
    n_病人id := Zl_Third_Getpatiid(v_身份证号,v_姓名);
  End If;
  If Nvl(n_病人id, 0) = 0 Then
    v_Err_Msg := '无法确定病人信息,请检查!';
    Raise Err_Item;
  End If;

  v_费别       := Zl_Custom_Getpatifeetype(1, n_病人id);
  v_Pricegrade := Zl_Get_Pricegrade(v_站点, n_病人id);
  v_药品等级   := Substr(v_Pricegrade, 1, Instr(v_Pricegrade, '|') - 1);
  v_Pricegrade := Substr(v_Pricegrade, Instr(v_Pricegrade, '|') + 1);
  v_卫材等级   := Substr(v_Pricegrade, 1, Instr(v_Pricegrade, '|') - 1);
  v_Pricegrade := Substr(v_Pricegrade, Instr(v_Pricegrade, '|') + 1);
  v_普通等级   := Substr(v_Pricegrade, 1, Instr(v_Pricegrade, '|') - 1);
  For r_Fb In (Select 1 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次, c.Id As 收入项目id,
                      c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, Null As 从属父号
               From 收费项目目录 A, 收费价目 B, 收入项目 C
               Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = n_项目id And Sysdate Between b.执行日期 And
                     Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And
                     ((Instr(';5;6;7;', ';' || a.类别 || ';') > 0 And b.价格等级 = v_药品等级) Or
                     (Instr(';4;', ';' || a.类别 || ';') > 0 And b.价格等级 = v_卫材等级) Or
                     (Instr(';4;5;6;7;', ';' || a.类别 || ';') = 0 And b.价格等级 = v_普通等级) Or
                     (b.价格等级 Is Null And Not Exists
                      (Select 1
                        From 收费价目
                        Where b.收费细目id = 收费细目id And Sysdate Between 执行日期 And
                              Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')) And
                              ((Instr(';5;6;7;', ';' || a.类别 || ';') > 0 And 价格等级 = v_药品等级) Or
                              (Instr(';4;', ';' || a.类别 || ';') > 0 And 价格等级 = v_卫材等级) Or
                              (Instr(';4;5;6;7;', ';' || a.类别 || ';') = 0 And 价格等级 = v_普通等级)))))
               Union All
               Select 2 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, d.从项数次 As 数次,
                      c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, 1 As 从属父号
               From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费从属项目 D
               Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = d.从项id And d.主项id = n_项目id And
                     Sysdate Between b.执行日期 And Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And
                     ((Instr(';5;6;7;', ';' || a.类别 || ';') > 0 And b.价格等级 = v_药品等级) Or
                     (Instr(';4;', ';' || a.类别 || ';') > 0 And b.价格等级 = v_卫材等级) Or
                     (Instr(';4;5;6;7;', ';' || a.类别 || ';') = 0 And b.价格等级 = v_普通等级) Or
                     (b.价格等级 Is Null And Not Exists
                      (Select 1
                        From 收费价目
                        Where b.收费细目id = 收费细目id And Sysdate Between 执行日期 And
                              Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')) And
                              ((Instr(';5;6;7;', ';' || a.类别 || ';') > 0 And 价格等级 = v_药品等级) Or
                              (Instr(';4;', ';' || a.类别 || ';') > 0 And 价格等级 = v_卫材等级) Or
                              (Instr(';4;5;6;7;', ';' || a.类别 || ';') = 0 And 价格等级 = v_普通等级)))))
               Order By 性质, 项目编码, 收入编码) Loop
    v_Temp     := Zl_Actualmoney(v_费别, r_Fb.项目id, r_Fb.收入项目id, r_Fb.单价);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ':') + 1);
    n_实收金额 := n_实收金额 + Zl_To_Number(v_Temp);
    n_应收金额 := n_应收金额 + r_Fb.单价;
  End Loop;
  n_优惠金额 := n_应收金额 - n_实收金额;
  v_Temp     := '<YHJE>' || n_优惠金额 || '</YHJE>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  v_Temp := '<JE>' || n_实收金额 || '</JE>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  v_Temp := '<FB>' || v_费别 || '</FB>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Salereginfo;
/


--108762:焦博,2017-05-23,在临床出诊安排医生姓名前增加职称标识符
Create Or Replace Procedure Zl_专业技术职务_更新标识符(编码标识符_In Varchar2) As
  --功能：修改医生职务标识符
  --格式：编码1,标识符1;编码2,标识符2;...
  v_编码   专业技术职务.编码%Type;
  v_标识符 专业技术职务.标识符%Type;
Begin
  For c_编码标识符 In (Select C1 As 编码, C2 As 标识符 From Table(f_Str2list2(编码标识符_In, ';', ',')) Order By 编码) Loop
    v_编码   := c_编码标识符.编码;
    v_标识符 := c_编码标识符.标识符;
    Update 专业技术职务 Set 标识符 = v_标识符 Where 编码 = v_编码;
  End Loop;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_专业技术职务_更新标识符;
/

--109265:冉俊明,2017-05-23,门诊留观病人，门诊记帐销帐，销帐记录没有填写主页ID及挂号ID
Create Or Replace Procedure Zl_门诊记帐记录_Delete
(
  No_In         门诊费用记录.No%Type,
  序号_In       Varchar2,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type
) As
  --功能：冲销一张门诊记帐单据中指定序号行
  --序号：格式如"1,3,5,7,8",为空表示冲销所有可冲销行
  --该光标用于销帐指定费用行

  --该游标为要退费单据的所有原始记录
  Cursor c_Bill(n_标志 Number) Is
    Select a.Id, a.价格父号, a.序号, a.执行状态, a.收费类别, a.医嘱序号, a.病人id, a.收入项目id, a.开单部门id, a.执行部门id, a.病人科室id, a.实收金额,
           Decode(a.记录状态, 0, 1, 0) As 划价, j.诊疗类别, m.跟踪在用
    From 门诊费用记录 A, 病人医嘱记录 J, 材料特性 M
    Where a.医嘱序号 = j.Id(+) And a.收费细目id + 0 = m.材料id(+) And a.No = No_In And a.记录性质 = 2 And a.记录状态 In (0, 1, 3) And
          a.门诊标志 = n_标志
    Order By a.收费细目id, a.序号;

  --该游标用于处理费用记录序号
  Cursor c_Serial Is
    Select 序号, 价格父号 From 门诊费用记录 Where NO = No_In And 记录性质 = 2 And 记录状态 In (0, 1, 3) Order By 序号;
  l_划价 t_Numlist := t_Numlist();

  n_医嘱id   病人医嘱记录.Id%Type;
  v_医嘱ids  Varchar2(4000);
  n_父号     门诊费用记录.价格父号%Type;
  n_门诊标志 门诊费用记录.门诊标志%Type;

  --部分退费计算变量
  n_剩余数量 Number;
  n_剩余应收 Number;
  n_剩余实收 Number;
  n_剩余统筹 Number;

  n_准退数量 Number;
  n_退费次数 Number;

  n_应收金额 Number;
  n_实收金额 Number;
  n_统筹金额 Number;

  n_Dec Number;

  n_Count   Number;
  d_Curdate Date;
  Err_Item Exception;
  v_Err_Msg Varchar2(255);
Begin
  --是否已经全部完全执行(只是整张单据的检查)
  Select Nvl(Count(*), 0), Max(Nvl(门诊标志, 1))
  Into n_Count, n_门诊标志
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 2 And 记录状态 In (0, 1, 3) And Nvl(执行状态, 0) <> 1;
  If n_Count = 0 Then
    v_Err_Msg := '该单据中的项目已经全部完全执行！';
    Raise Err_Item;
  End If;

  If Nvl(n_门诊标志, 0) = 0 Then
    n_门诊标志 := 1;
  End If;

  --未完全执行的项目是否有剩余数量(只是整张单据的检查)
  Select Nvl(Count(*), 0)
  Into n_Count
  From (Select 序号, Sum(数量) As 剩余数量
         From (Select 记录状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                From 门诊费用记录
                Where NO = No_In And 记录性质 = 2 And 门诊标志 = n_门诊标志 And
                      Nvl(价格父号, 序号) In
                      (Select Nvl(价格父号, 序号)
                       From 门诊费用记录
                       Where NO = No_In And 记录性质 = 2 And 门诊标志 = n_门诊标志 And 记录状态 In (0, 1, 3) And Nvl(执行状态, 0) <> 1)
                Group By 记录状态, Nvl(价格父号, 序号))
         Group By 序号
         Having Sum(数量) <> 0);
  If n_Count = 0 Then
    v_Err_Msg := '该单据中未完全执行部分项目剩余数量为零,没有可以销帐的费用！';
    Raise Err_Item;
  End If;

  ---------------------------------------------------------------------------------
  --公用变量
  Select Sysdate Into d_Curdate From Dual;

  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into n_Dec From Dual;

  --循环处理每行费用(收入项目行)
  For r_Bill In c_Bill(n_门诊标志) Loop
    If Instr(',' || 序号_In || ',', ',' || Nvl(r_Bill.价格父号, r_Bill.序号) || ',') > 0 Or 序号_In Is Null Then
    
      If r_Bill.划价 = 0 Then
        If Nvl(r_Bill.执行状态, 0) <> 1 Then
          --求剩余数量,剩余应收,剩余实收
          Select Sum(Nvl(付数, 1) * 数次), Sum(应收金额), Sum(实收金额), Sum(统筹金额)
          Into n_剩余数量, n_剩余应收, n_剩余实收, n_剩余统筹
          From 门诊费用记录
          Where NO = No_In And 记录性质 = 2 And 序号 = r_Bill.序号;
        
          If n_剩余数量 = 0 Then
            If 序号_In Is Not Null Then
              v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经全部销帐！';
              Raise Err_Item;
            End If;
            --情况：未限定行号,原始单据中的该笔已经全部销帐(执行状态=0的一种可能)
          Else
            --准销数量(非药品项目为剩余数量,原始数量)
            If Instr(',4,5,6,7,', r_Bill.收费类别) = 0 Or (r_Bill.收费类别 = '4' And Nvl(r_Bill.跟踪在用, 0) = 0) Then
            
              --@@@
              --非药品部分(以具体医嘱执行为准进行检查)
              --: 1.存在医嘱发送的,则以医嘱执行为准(但不能包含:检查;检验;手术;麻醉及输血)
              --: 2.对于病人医吃计价中的收费方式为:0-正常收取 的,才支持部分退;如果是其他的,则只能全退
              --: 3.不存在医嘱的,则以剩余数量为准
              n_Count := 0;
              If Instr(',C,D,F,G,K,', ',' || r_Bill.诊疗类别 || ',') = 0 And r_Bill.诊疗类别 Is Not Null Then
              
                Select Nvl(Sum(数量), 0), Count(*)
                Into n_准退数量, n_Count
                From (Select j.医嘱序号 As 医嘱id, j.收费细目id, Nvl(j.付数, 1) * Nvl(j.数次, 1) As 数量
                       From 门诊费用记录 J, 病人医嘱记录 M
                       Where j.医嘱序号 = m.Id And j.No = No_In And j.记录性质 = 2 And j.序号 = r_Bill.序号 And j.记录状态 In (1, 3) And
                             Exists
                        (Select 1
                              From 病人医嘱发送 A
                              Where a.医嘱id = j.医嘱序号 And Nvl(a.执行状态, 0) <> 1 And a.No || '' = No_In) And Exists
                        (Select 1
                              From 病人医嘱计价 A
                              Where a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And Nvl(a.收费方式, 0) = 0) And j.价格父号 Is Null And
                             Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                             (j.记录状态 In (1, 3) And Not Exists
                              (Select 1
                               From 药品收发记录
                               Where 费用id = j.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0) Or
                              j.记录状态 = 2 And Not Exists
                              (Select 1 From 药品收发记录 Where NO = No_In And 单据 In (8, 24) And 药品id = j.收费细目id))
                       Union All
                       Select a.医嘱id, a.收费细目id, -1 * Nvl(a.数量, 1) * Nvl(c.本次数次, 1) As 数量
                       From 病人医嘱计价 A, 病人医嘱发送 B, 病人医嘱执行 C, 门诊费用记录 J, 病人医嘱记录 M
                       Where a.医嘱id = b.医嘱id And b.医嘱id = c.医嘱id And Nvl(a.收费方式, 0) = 0 And b.发送号 = c.发送号 And
                             a.医嘱id = m.Id And Nvl(c.执行结果, 1) = 1 And Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And
                             a.收费细目id = j.收费细目id And j.No = No_In And j.记录性质 = 2 And j.序号 = r_Bill.序号 And
                             j.记录状态 In (1, 3) And j.价格父号 Is Null And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                             Not Exists
                        (Select 1
                              From 药品收发记录
                              Where 费用id = j.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0) And Not Exists
                        (Select 1 From 材料特性 Where 材料id = j.收费细目id And Nvl(跟踪在用, 0) = 1)
                       Union All
                       Select a.医嘱id, a.收费细目id, 0 As 数量
                       From 病人医嘱计价 A, 门诊费用记录 J, 病人医嘱记录 M
                       Where a.医嘱id = m.Id And a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And Nvl(a.收费方式, 0) <> 0 And
                             j.No = No_In And j.记录性质 = 2 And Nvl(j.执行状态, 0) = 2 And Not Exists
                        (Select 1 From 材料特性 Where 材料id = j.收费细目id And Nvl(跟踪在用, 0) = 1) And
                             Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0);
              
              End If;
            
              If Nvl(n_Count, 0) = 0 Then
                n_准退数量 := n_剩余数量;
              End If;
            
            Else
              Select Sum(Nvl(付数, 1) * 实际数量)
              Into n_准退数量
              From 药品收发记录
              Where NO = No_In And 单据 In (9, 25) And Mod(记录状态, 3) = 1 And 审核人 Is Null And 费用id = r_Bill.Id;
            
              --不跟踪在用的卫生材料
              If r_Bill.收费类别 = '4' And Nvl(n_准退数量, 0) = 0 Then
                n_准退数量 := n_剩余数量;
              End If;
            End If;
          
            --处理门诊费用记录
          
            --该笔项目第几次销帐
            Select Nvl(Max(Abs(执行状态)), 0) + 1
            Into n_退费次数
            From 门诊费用记录
            Where NO = No_In And 记录性质 = 2 And 记录状态 = 2 And 序号 = r_Bill.序号;
          
            --金额=剩余金额*(准退数/剩余数)
            n_应收金额 := Round(n_剩余应收 * (n_准退数量 / n_剩余数量), n_Dec);
            n_实收金额 := Round(n_剩余实收 * (n_准退数量 / n_剩余数量), n_Dec);
            n_统筹金额 := Round(n_剩余统筹 * (n_准退数量 / n_剩余数量), n_Dec);
          
            --插入退费记录
            Insert Into 门诊费用记录
              (ID, NO, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 婴儿费, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别,
               收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人,
               执行人, 执行状态, 执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 保险项目否, 保险大类id, 统筹金额, 记帐单id, 摘要, 保险编码, 是否急诊, 结论, 挂号id, 主页id)
              Select 病人费用记录_Id.Nextval, NO, 记录性质, 2, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 婴儿费, 姓名, 性别, 年龄, 标识号, 付款方式, 费别,
                     病人科室id, 收费类别, 收费细目id, 计算单位, Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, 付数, 1), 发药窗口,
                     Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, -1 * 数次, -1 * n_准退数量), 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用,
                     标准单价, -1 * n_应收金额, -1 * n_实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, -1 * n_退费次数, 执行时间, 操作员编号_In,
                     操作员姓名_In, 发生时间, d_Curdate, 保险项目否, 保险大类id, -1 * n_统筹金额, 记帐单id, 摘要, 保险编码, 是否急诊, 结论, 挂号id, 主页id
              From 门诊费用记录
              Where ID = r_Bill.Id;
          
            --记录病人医嘱附费对应的医嘱ID(不是主费用)
            If n_医嘱id Is Null And r_Bill.医嘱序号 Is Not Null Then
              n_医嘱id := r_Bill.医嘱序号;
            End If;
          
            --病人余额
            If n_门诊标志 <> 4 Then
              Update 病人余额
              Set 费用余额 = Nvl(费用余额, 0) - n_实收金额
              Where 病人id = r_Bill.病人id And 性质 = 1 And 类型 = 1;
              If Sql%RowCount = 0 Then
                Insert Into 病人余额
                  (病人id, 性质, 类型, 费用余额, 预交余额)
                Values
                  (r_Bill.病人id, 1, 1, -1 * n_实收金额, 0);
              End If;
            End If;
          
            --病人未结费用
            Update 病人未结费用
            Set 金额 = Nvl(金额, 0) - n_实收金额
            Where 病人id = r_Bill.病人id And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And
                  Nvl(病人科室id, 0) = Nvl(r_Bill.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(r_Bill.开单部门id, 0) And
                  Nvl(执行部门id, 0) = Nvl(r_Bill.执行部门id, 0) And 收入项目id + 0 = r_Bill.收入项目id And 来源途径 + 0 = n_门诊标志;
            If Sql%RowCount = 0 Then
              Insert Into 病人未结费用
                (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
              Values
                (r_Bill.病人id, Null, Null, r_Bill.病人科室id, r_Bill.开单部门id, r_Bill.执行部门id, r_Bill.收入项目id, n_门诊标志,
                 -1 * n_实收金额);
            End If;
          
            --标记原费用记录
            --执行状态:全部退完(准退数=剩余数)标记为0,否则标记为1
            Update 门诊费用记录
            Set 记录状态 = 3, 执行状态 = Decode(Sign(n_准退数量 - n_剩余数量), 0, 0, 1)
            Where ID = r_Bill.Id;
          End If;
        Else
          If 序号_In Is Not Null Then
            v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经完全执行,不能销帐！';
            Raise Err_Item;
          End If;
          --情况:没限定行号,原始单据中包括已经完全执行的
        End If;
      End If;
    End If;
  End Loop;

  ---------------------------------------------------------------------------------
  --药品相关内容
  --必须按照“收费细目id”升序排序，防止并发锁“药品库存”表
  For r_Expenses In (Select ID
                     From 门诊费用记录
                     Where NO = No_In And 记录性质 = 2 And 记录状态 In (0, 1, 3) And 收费类别 In ('4', '5', '6', '7') And
                           门诊标志 = n_门诊标志 And (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null)
                     Order By 收费细目id) Loop
    Zl_药品收发记录_销售退费(r_Expenses.Id);
  End Loop;

  ---------------------------------------------------------------------------------
  --如果是划价,直接删除费用记录(药品处理后)
  n_Count   := 0;
  v_医嘱ids := Null;
  For r_Bill In c_Bill(n_门诊标志) Loop
    If Instr(',' || 序号_In || ',', ',' || Nvl(r_Bill.价格父号, r_Bill.序号) || ',') > 0 Or 序号_In Is Null Then
      If r_Bill.划价 = 1 Then
        If Nvl(r_Bill.执行状态, 0) <> 1 Then
          l_划价.Extend;
          l_划价(l_划价.Count) := r_Bill.Id;
        
          --Delete From 门诊费用记录 Where ID = r_Bill.ID;
          n_Count := n_Count + 1; --记录是否有删除行
        
          If r_Bill.医嘱序号 Is Not Null Then
            If Instr(',' || Nvl(v_医嘱ids, '') || ',', ',' || r_Bill.医嘱序号 || ',') = 0 Then
              v_医嘱ids := Nvl(v_医嘱ids, '') || ',' || r_Bill.医嘱序号;
            End If;
          
            --记录病人医嘱附费对应的医嘱ID(不是主费用)
            If n_医嘱id Is Null Then
              n_医嘱id := r_Bill.医嘱序号;
            End If;
          End If;
        Else
          If 序号_In Is Not Null Then
            v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经完全执行,不能销帐！';
            Raise Err_Item;
          End If;
          --情况:没限定行号,原始单据中包括已经完全执行的
        End If;
      End If;
    End If;
  End Loop;

  --删除划价记录
  Forall I In 1 .. l_划价.Count
    Delete From 门诊费用记录 Where ID = l_划价(I);

  --删除之后再统一调整序号
  If n_Count > 0 Then
    n_Count := 1;
    For r_Serial In c_Serial Loop
      If r_Serial.价格父号 Is Null Then
        n_父号 := n_Count;
      End If;
    
      Update 门诊费用记录
      Set 序号 = n_Count, 价格父号 = Decode(价格父号, Null, Null, n_父号)
      Where NO = No_In And 记录性质 = 2 And 序号 = r_Serial.序号;
    
      Update 门诊费用记录 Set 从属父号 = n_Count Where NO = No_In And 记录性质 = 2 And 从属父号 = r_Serial.序号;
    
      n_Count := n_Count + 1;
    End Loop;
  End If;

  --整张单据全部冲完时，删除病人医嘱附费
  For c_医嘱 In (Select Distinct 医嘱序号
               From 门诊费用记录
               Where NO = No_In And 记录性质 = 2 And 记录状态 = 3 And 医嘱序号 Is Not Null) Loop
    Select Nvl(Count(*), 0)
    Into n_Count
    From (Select 序号, Sum(数量) As 剩余数量
           From (Select 记录状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                  From 门诊费用记录
                  Where 记录性质 = 2 And 医嘱序号 + 0 = c_医嘱.医嘱序号 And NO = No_In
                  Group By 记录状态, Nvl(价格父号, 序号))
           Group By 序号
           Having Sum(数量) <> 0);
  
    If n_Count = 0 Then
      Delete From 病人医嘱附费 Where 医嘱id = c_医嘱.医嘱序号 And 记录性质 = 2 And NO = No_In;
    End If;
  End Loop;

  If v_医嘱ids Is Not Null Then
    --医嘱处理
    --场合_In    Integer:=0, --0:门诊;1-住院
    --性质_In    Integer:=1, --1-收费单;2-记帐单
    --操作_In    Integer:=0, --0:删除划价单;1-收费或记帐;2-退费或销帐
    --No_In      门诊费用记录.No%Type,
    --医嘱ids_In Varchar2 := Null
    v_医嘱ids := Substr(v_医嘱ids, 2);
    Zl_医嘱发送_计费状态_Update(0, 2, 0, No_In, v_医嘱ids);
  Else
    Zl_医嘱发送_计费状态_Update(0, 2, 2, No_In, v_医嘱ids);
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊记帐记录_Delete;
/

--109289:冉俊明,2017-05-23,使用“全部启用序号控制”功能时，对于启用序号但没有启用分时段的安排，没有生成对应的时段序号数据
Create Or Replace Procedure Zl_临床出诊安排_序号控制
(
  出诊id_In   临床出诊表.Id%Type,
  序号控制_In 临床出诊限制.是否序号控制%Type,
  站点_In     部门表.站点%Type := Null,
  人员id_In   人员表.Id%Type := 0
) As
  --全部启用序号控制或者全部取消序号控制
  --参数：
  --      人员id_In 不等于0则修改人员所在科室的所有号源安排，否则修改所有号源的安排
  n_Count    Number(2);
  n_出诊记录 Number(2);

  Err_Item Exception;
  v_Err_Msg Varchar2(255);

  l_安排id t_Numlist := t_Numlist();
  l_记录id t_Numlist := t_Numlist();

  --该游标用于读取所有临床出诊安排的ID
  Cursor c_安排
  (
    出诊id_In 临床出诊表.Id%Type,
    人员id_In 人员表.Id%Type := 0
  ) Is
    Select b.Id
    From 临床出诊安排 B, 临床出诊号源 C
    Where b.号源id = c.Id And b.出诊id = 出诊id_In And
          (Nvl(人员id_In, 0) = 0 Or (Nvl(人员id_In, 0) <> 0 And Nvl(c.是否临床排班, 0) = 1 And Exists
           (Select 1 From 部门人员 Where 部门id = c.科室id And 人员id = 人员id_In))) And Exists
     (Select 1 From 部门表 Where ID = c.科室id And (站点_In Is Null Or (站点 Is Null Or 站点 = 站点_In)));
Begin
  Select Count(1)
  Into n_Count
  From 临床出诊表 A
  Where a.Id = 出诊id_In And a.发布人 Is Not Null And a.排班方式 <> 3 And Rownum < 2;
  If n_Count <> 0 Then
    v_Err_Msg := '当前出诊表已发布，不允许修改！';
    Raise Err_Item;
  End If;

  Select Count(1) Into n_Count From 临床出诊表 A Where a.Id = 出诊id_In And a.排班方式 In (1, 2) And Rownum < 2;
  If n_Count <> 0 Then
    n_出诊记录 := 1;
  End If;

  Open c_安排(出诊id_In, 人员id_In);
  Fetch c_安排 Bulk Collect
    Into l_安排id;
  Close c_安排;

  If Nvl(n_出诊记录, 0) = 0 Then
    --临床出诊限制或模板
    Forall I In 1 .. l_安排id.Count
      Update 临床出诊限制
      Set 是否序号控制 = 序号控制_In
      Where (限号数 Is Not Null Or 限约数 Is Not Null) And 安排id = l_安排id(I);
  
    If Nvl(序号控制_In, 0) = 0 Then
      --取消序号控制，删除序号数据
      Select /*+cardinality(b,10)*/
       ID Bulk Collect
      Into l_记录id
      From 临床出诊限制 A, Table(l_安排id) B
      Where a.安排id = b.Column_Value And (a.限号数 Is Not Null Or a.限约数 Is Not Null) And Nvl(a.是否序号控制, 0) = 0 And
            Nvl(a.是否分时段, 0) = 0;
    
      Forall I In 1 .. l_记录id.Count
        Delete From 临床出诊时段 Where 限制id = l_记录id(I);
    Else
      --不分时段的序号控制号先生成序号,开始时间、终止时间填写时间段的开始时间和结束时间
      For c_安排 In (Select /*+cardinality(d,10)*/
                    a.Id, b.号类, c.站点
                   From 临床出诊安排 A, 临床出诊号源 B, 部门表 C, Table(l_安排id) D
                   Where a.号源id = b.Id And b.科室id = c.Id And a.Id = d.Column_Value) Loop
      
        For c_记录 In (With c_时间段 As
                        (Select 时间段, 开始时间, 终止时间
                        From (Select 时间段,
                                      To_Date('3000-01-01' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                      To_Date('3000-01-01' || To_Char(终止时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 终止时间,
                                      Row_Number() Over(Partition By 时间段 Order By 时间段, 站点 Asc, 号类 Asc) As 组号
                               From 时间段
                               Where Nvl(站点, c_安排.站点) = c_安排.站点 And Nvl(号类, c_安排.号类) = c_安排.号类)
                        Where 组号 = 1)
                       Select a.Id, a.限号数,
                              To_Date(To_Char(Sysdate, 'yyyy-mm-dd ') || To_Char(b.开始时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                              To_Date(To_Char(Sysdate, 'yyyy-mm-dd ') || To_Char(b.终止时间, 'hh24:mi:ss'),
                                      'yyyy-mm-dd hh24:mi:ss') + Case
                                When b.终止时间 <= b.开始时间 Then
                                 1
                                Else
                                 0
                              End As 终止时间
                       From 临床出诊限制 A, c_时间段 B
                       Where a.上班时段 = b.时间段 And 安排id = c_安排.Id And Nvl(限号数, 0) <> 0 And Nvl(是否序号控制, 0) = 1 And
                             Nvl(是否分时段, 0) = 0 And Not Exists (Select 1 From 临床出诊时段 Where 限制id = a.Id)) Loop
        
          For I In 1 .. c_记录.限号数 Loop
            Insert Into 临床出诊时段
              (限制id, 序号, 开始时间, 终止时间, 限制数量, 是否预约)
            Values
              (c_记录.Id, I, c_记录.开始时间, c_记录.终止时间, 1, 1);
          End Loop;
        End Loop;
      End Loop;
    End If;
  Else
    --临床出诊记录
    Forall I In 1 .. l_安排id.Count
      Update 临床出诊记录
      Set 是否序号控制 = 序号控制_In
      Where (限号数 Is Not Null Or 限约数 Is Not Null) And 安排id = l_安排id(I);
  
    If Nvl(序号控制_In, 0) = 0 Then
      --取消序号控制，删除序号数据
      Select /*+cardinality(b,10)*/
       a.Id Bulk Collect
      Into l_记录id
      From 临床出诊记录 A, Table(l_安排id) B
      Where a.安排id = b.Column_Value And Nvl(a.限号数, 0) <> 0 And Nvl(a.是否序号控制, 0) = 0 And Nvl(a.是否分时段, 0) = 0;
    
      Forall I In 1 .. l_记录id.Count
        Delete From 临床出诊序号控制 Where 记录id = l_记录id(I);
    Else
      --不分时段的序号控制号先生成序号,开始时间、终止时间填写时间段的开始时间和结束时间
      For c_记录 In (Select /*+cardinality(b,10)*/
                    a.Id, a.限号数, a.开始时间, a.终止时间
                   From 临床出诊记录 A, Table(l_安排id) B
                   Where a.安排id = b.Column_Value And Nvl(a.限号数, 0) <> 0 And Nvl(a.是否序号控制, 0) = 1 And Nvl(a.是否分时段, 0) = 0 And
                         Not Exists (Select 1 From 临床出诊序号控制 Where 记录id = a.Id)) Loop
      
        For I In 1 .. c_记录.限号数 Loop
          Insert Into 临床出诊序号控制
            (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约)
          Values
            (c_记录.Id, I, c_记录.开始时间, c_记录.终止时间, 1, 1);
        End Loop;
      End Loop;
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊安排_序号控制;
/


--109314:陈刘,2017-05-18,取消失效函数的使用
CREATE OR REPLACE Procedure Zl_病区公告栏样式_Updatedata
(
  病区id_In In 病区公告栏样式.病区id%Type,
  Id_In     In 病区公告栏样式.Id%Type := Null
) Is

  v_Content Varchar2(2000);
  v_Xh      Varchar2(4000);

  --只提取系统项
  Cursor c_Callboard Is
    Select Id, 名称, 别名, 行号, 位置, 是否固定, 是否隐藏, 内容, 时间
    From 病区公告栏样式
    Where 病区id = 病区id_In And (Id_In Is Null Or Id = Id_In)
    Order By 行号, 位置;

  Cursor c_Xry Is
    Select f_List2str(Cast(Collect(出院病床) As t_Strlist)) As 新入院
    From (Select b.出院病床
           From 病人信息 a, 病案主页 b,
                (Select 病人id, 主页id
                  From 病人变动记录
                  Where 病区id = 病区id_In And (开始原因 = 2 Or 开始原因 = 1) And
                        开始时间 Between To_Date(To_Char(Sysdate, 'yyyy-MM-dd') || ' 00:00:00', 'yyyy-MM-dd hh24:mi:ss') And
                        Sysdate
                  Group By 病人id, 主页id) c, 在院病人 d
           Where a.病人id = b.病人id And a.主页ID = b.主页id And b.病人id = c.病人id And b.主页id = c.主页id And a.病人id = d.病人id And
                 a.当前病区id = d.病区id And d.病区id = 病区id_In And Nvl(b.病案状态, 0) <> 5 And b.封存时间 Is Null
           Order By b.出院病床);
  r_Xry c_Xry%Rowtype;

  Cursor c_Xzy Is
    Select f_List2str(Cast(Collect(出院病床) As t_Strlist)) As 新转入
    From (Select b.出院病床
           From 病人信息 a, 病案主页 b,
                (Select 病人id, 主页id
                  From 病人变动记录
                  Where 病区id = 病区id_In And (开始原因 = 3 Or 开始原因 = 15) And
                        开始时间 Between To_Date(To_Char(Sysdate, 'yyyy-MM-dd') || ' 00:00:00', 'yyyy-MM-dd hh24:mi:ss') And
                        Sysdate
                  Group By 病人id, 主页id) c, 在院病人 d
           Where a.病人id = b.病人id And a.主页ID = b.主页id And b.病人id = c.病人id And b.主页id = c.主页id And a.病人id = d.病人id And
                 a.当前病区id = d.病区id And d.病区id = 病区id_In And Nvl(b.病案状态, 0) <> 5 And b.封存时间 Is Null
           Order By b.出院病床);
  r_Xzy c_Xzy%Rowtype;

  Cursor c_Yjhl Is
    Select f_List2str(Cast(Collect(出院病床) As t_Strlist)) As 一级护理
    From (Select b.出院病床
           From 病人信息 a, 病案主页 b, 收费项目目录 c, 在院病人 d
           Where a.病人id = b.病人id And a.主页ID = b.主页id And b.护理等级id = c.Id And a.病人id = d.病人id And a.当前病区id = d.病区id And
                 d.病区id = 病区id_In And
                 (Instr(c.名称, '一') > 0 Or Instr(c.名称, 'I') > 0 Or Instr(c.名称, 'Ⅰ') > 0 Or Instr(c.名称, '1') > 0) And
                 Nvl(b.病案状态, 0) <> 5 And b.封存时间 Is Null
           Order By b.出院病床);
  r_Yjhl c_Yjhl%Rowtype;

  Cursor c_Tjhl Is
    Select f_List2str(Cast(Collect(出院病床) As t_Strlist)) As 特级护理
    From (Select b.出院病床
           From 病人信息 a, 病案主页 b, 收费项目目录 c, 在院病人 d
           Where a.病人id = b.病人id And b.护理等级id = c.Id And a.病人id = d.病人id And a.当前病区id = d.病区id And d.病区id = 病区id_In And
                 (Instr(c.名称, '特') > 0 Or Instr(c.名称, '重') > 0) And Nvl(b.病案状态, 0) <> 5 And b.封存时间 Is Null
           Order By b.出院病床);
  r_Tjhl c_Tjhl%Rowtype;

  Cursor c_Bw Is
    Select f_List2str(Cast(Collect(出院病床) As t_Strlist)) As 病危
    From (Select b.出院病床
           From 病人信息 a, 病案主页 b, 在院病人 d
           Where a.病人id = b.病人id And a.主页ID = b.主页id And a.病人id = d.病人id And a.当前病区id = d.病区id And d.病区id = 病区id_In And
                 Instr(b.当前病况, '危') > 0 And Nvl(b.病案状态, 0) <> 5 And b.封存时间 Is Null
           Order By b.出院病床);
  r_Bw c_Bw%Rowtype;

  Cursor c_Ycy Is
    Select f_List2str(Cast(Collect(出院病床) As t_Strlist)) As 预出院
    From (Select b.出院病床
           From 病人信息 a, 病案主页 b, 在院病人 c
           Where a.病人id = b.病人id And a.主页ID = b.主页id And a.病人id = c.病人id And a.当前病区id = c.病区id And c.病区id = 病区id_In And
                 b.状态 = 3 And Nvl(b.病案状态, 0) <> 5 And b.封存时间 Is Null
           Order By b.出院病床);
  r_Ycy c_Ycy%Rowtype;

  Cursor c_Ss Is
    Select f_List2str(Cast(Collect(出院病床) As t_Strlist)) As 手术
    From (Select Distinct d.出院病床
           From 病人信息 b, 病案主页 d, 病人医嘱记录 a, 诊疗项目目录 c, 在院病人 e
           Where b.病人id = d.病人id And b.主页ID = d.主页id And d.病人id = a.病人id And d.主页id = a.主页id And b.病人id = e.病人id And
                 b.当前病区id = e.病区id And e.病区id = 病区id_In And
                 ((a.医嘱期效 = 0 And a.医嘱状态 In (3, 5, 6, 7, 8, 9) And (a.执行终止时间 Is Null Or a.执行终止时间 >= Sysdate)) Or
                 (a.医嘱期效 = 1 And a.医嘱状态 In (3, 5, 6, 7, 8))) And
                 a.开嘱时间 Between To_Date(To_Char(Sysdate - 7, 'yyyy-MM-dd') || ' 00:00:00', 'yyyy-MM-dd hh24:mi:ss') And
                 Sysdate And
                 Substr(Nvl(a.标本部位, To_Char(开始执行时间, 'YYYY-MM-DD HH24:MI')), 1, 10) = To_Char(Sysdate, 'YYYY-MM-DD') And
                 Nvl(a.婴儿, 0) = 0 And a.诊疗项目id = c.Id And c.类别 = 'F' And Nvl(d.病案状态, 0) <> 5 And d.封存时间 Is Null
           Order By d.出院病床);
  r_Ss c_Ss%Rowtype;

  Cursor c_Fs Is
    Select f_List2str(Cast(Collect(出院病床) As t_Strlist)) As 发烧
    From (Select Distinct b.出院病床
           From 病人信息 a, 病案主页 b, 在院病人 f
           Where a.病人id = b.病人id And a.主页ID = b.主页id And a.病人id = f.病人id And a.当前病区id = f.病区id And f.病区id = 病区id_In And
                 Nvl(b.病案状态, 0) <> 5 And b.封存时间 Is Null And Exists
            (Select c.Id
                  From 病人护理文件 c, 病人护理数据 d, 病人护理明细 e
                  Where c.Id = d.文件id And d.Id = e.记录id And e.记录类型 = 1 And e.项目序号 = 1 And
                        Length(Translate(e.记录内容, '-.0123456789' || e.记录内容, '-.0123456789')) = Length(e.记录内容) And
                        Zl_To_Number(e.记录内容) >= 37.2 And e.终止版本 Is Null And b.病人id = c.病人id And b.主页id = c.主页id And
                        Nvl(c.婴儿, 0) = 0 And d.发生时间 Between Sysdate - 3 And Sysdate)
           Order By b.出院病床);
  r_Fs c_Fs%Rowtype;

  Cursor c_Gms Is
    Select f_List2str(Cast(Collect(出院病床) As t_Strlist)) As 过敏史
    From (Select Distinct b.出院病床
           From 病人信息 a, 病案主页 b, 病人过敏记录 c, 在院病人 d
           Where a.病人id = b.病人id And a.主页ID = b.主页id And b.病人id = c.病人id And a.病人id = d.病人id And a.当前病区id = d.病区id And
                 d.病区id = 病区id_In And Nvl(b.病案状态, 0) <> 5 And b.封存时间 Is Null And c.结果 = 1 And Not Exists
            (Select 药物id
                  From 病人过敏记录
                  Where (Nvl(药物id, 0) = Nvl(c.药物id, 0) Or Nvl(药物名, 'Null') = Nvl(c.药物名, 'Null')) And Nvl(结果, 0) = 0 And
                        记录时间 > c.记录时间 And 病人id = c.病人id)
           Order By b.出院病床);
  r_Gms c_Gms%Rowtype;

  Cursor c_Diy Is
    Select /*+ Rule */
     f_List2str(Cast(Collect(当前床号) As t_Strlist)) As 床号列表
    From (Select Distinct b.当前床号
           From 病人信息 b, 病案主页 c, 病人医嘱记录 a, 在院病人 d, ((Select Column_Value From Table(f_Num2list(v_Xh)))) e
           Where b.病人id = c.病人id And b.主页ID = c.主页id And c.病人id = a.病人id And c.主页id = a.主页id And b.病人ID=d.病人ID And b.当前病区id = d.病区id And
                 d.病区id = 病区id_In And
                 ((a.医嘱期效 = 0 And a.医嘱状态 In (3, 5, 6, 7, 8, 9) And a.开始执行时间 >= b.入院时间 And
                 (a.执行终止时间 Is Null Or a.执行终止时间 >= Sysdate)) Or
                 (a.医嘱期效 = 1 And a.医嘱状态 In (3, 5, 6, 7, 8) And a.开始执行时间 Between Sysdate - 1 And Sysdate)) And
                 Nvl(a.婴儿, 0) = 0 And a.诊疗项目id + 0 = e.Column_Value And Nvl(c.病案状态, 0) <> 5 And c.封存时间 Is Null
           Order By b.当前床号);
  r_Diy c_Diy%Rowtype;

Begin
  For r_Board In c_Callboard Loop
    v_Content := '';
    If Instr(',新入院列表,新转入列表,一级护理列表,特级护理列表,病危列表,预出院列表,手术列表,发烧列表,过敏史列表,',
             ',' || r_Board.名称 || ',') > 0 Then
      --系统固定项
      If r_Board.名称 = '新入院列表' Then
        Open c_Xry;
        Fetch c_Xry
          Into r_Xry;
        If c_Xry%Rowcount > 0 Then
          v_Content := Nvl(r_Xry.新入院, '');
        End If;

        Update 病区公告栏样式 Set 内容 = v_Content, 时间 = Sysdate Where Id = r_Board.Id;
        Close c_Xry;
      Elsif r_Board.名称 = '新转入列表' Then
        Open c_Xzy;
        Fetch c_Xzy
          Into r_Xzy;
        If c_Xzy%Rowcount > 0 Then
          v_Content := Nvl(r_Xzy.新转入, '');
        End If;

        Update 病区公告栏样式 Set 内容 = v_Content, 时间 = Sysdate Where Id = r_Board.Id;
        Close c_Xzy;
      Elsif r_Board.名称 = '一级护理列表' Then
        Open c_Yjhl;
        Fetch c_Yjhl
          Into r_Yjhl;
        If c_Yjhl%Rowcount > 0 Then
          v_Content := Nvl(r_Yjhl.一级护理, '');
        End If;

        Update 病区公告栏样式 Set 内容 = v_Content, 时间 = Sysdate Where Id = r_Board.Id;
        Close c_Yjhl;
      Elsif r_Board.名称 = '特级护理列表' Then
        Open c_Tjhl;
        Fetch c_Tjhl
          Into r_Tjhl;
        If c_Tjhl%Rowcount > 0 Then
          v_Content := Nvl(r_Tjhl.特级护理, '');
        End If;

        Update 病区公告栏样式 Set 内容 = v_Content, 时间 = Sysdate Where Id = r_Board.Id;
        Close c_Tjhl;
      Elsif r_Board.名称 = '病危列表' Then
        Open c_Bw;
        Fetch c_Bw
          Into r_Bw;
        If c_Bw%Rowcount > 0 Then
          v_Content := Nvl(r_Bw.病危, '');
        End If;

        Update 病区公告栏样式 Set 内容 = v_Content, 时间 = Sysdate Where Id = r_Board.Id;
        Close c_Bw;
      Elsif r_Board.名称 = '预出院列表' Then
        Open c_Ycy;
        Fetch c_Ycy
          Into r_Ycy;
        If c_Ycy%Rowcount > 0 Then
          v_Content := Nvl(r_Ycy.预出院, '');
        End If;

        Update 病区公告栏样式 Set 内容 = v_Content, 时间 = Sysdate Where Id = r_Board.Id;
        Close c_Ycy;
      Elsif r_Board.名称 = '手术列表' Then
        Open c_Ss;
        Fetch c_Ss
          Into r_Ss;
        If c_Ss%Rowcount > 0 Then
          v_Content := Nvl(r_Ss.手术, '');
        End If;

        Update 病区公告栏样式 Set 内容 = v_Content, 时间 = Sysdate Where Id = r_Board.Id;
        Close c_Ss;
      Elsif r_Board.名称 = '发烧列表' Then
        Open c_Fs;
        Fetch c_Fs
          Into r_Fs;
        If c_Fs%Rowcount > 0 Then
          v_Content := Nvl(r_Fs.发烧, '');
        End If;

        Update 病区公告栏样式 Set 内容 = v_Content, 时间 = Sysdate Where Id = r_Board.Id;
        Close c_Fs;
      Else
        Open c_Gms;
        Fetch c_Gms
          Into r_Gms;
        If c_Gms%Rowcount > 0 Then
          v_Content := Nvl(r_Gms.过敏史, '');
        End If;

        Update 病区公告栏样式 Set 内容 = v_Content, 时间 = Sysdate Where Id = r_Board.Id;
        Close c_Gms;
      End If;
    Else
      --自添加已绑定的项目
      v_Content := '';
      Begin
        Select f_List2str(Cast(Collect(a.Xh) As t_Strlist))
        Into v_Xh
        From 病区公告栏样式 p, Xmltable('/ITEMLIST/ITEM/XH' Passing p.诊疗项目 Columns Xh Varchar2(256) Path '/XH') a
        Where p.Id = r_Board.Id;
      Exception
        When Others Then
          v_Xh := '';
      End;

      If v_Xh Is Not Null Then
        Open c_Diy;
        Fetch c_Diy
          Into r_Diy;
        If c_Diy%Rowcount > 0 Then
          v_Content := Nvl(r_Diy.床号列表, '');
        End If;

        Update 病区公告栏样式 Set 内容 = v_Content, 时间 = Sysdate Where Id = r_Board.Id;
        Close c_Diy;
      Else
        Update 病区公告栏样式 Set 内容 = Null, 时间 = Sysdate Where Id = r_Board.Id;
      End If;
    End If;
  End Loop;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病区公告栏样式_Updatedata;
/

--109214:刘尔旋,2017-05-18,取消失效函数的使用
Create Or Replace Procedure Zl_Third_Getvisitdetails
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  -------------------------------------------------------------------------------------------------- 
  --功能:根据挂号单号获取该次就诊详情
  --入参:Xml_In: 
  --<IN>
  --    <GHDH>挂号单号</GHDH>
  --    <JSKLB>结算卡类别</JSKLB>
  --</IN>
  --出参:Xml_Out 
  --<OUTPUT>
  --    <DJLIST>  //如果为空表示为找到数据
  --        <DJ>
  --            <NO>单据号</NO>
  --            <DJLX>单据类型</DJLX> //1-收费单;4-挂号单
  --            <KDSJ>开单时间</KDSJ>
  --            <ZFZT>支付状态</ZFZT>    //0未支付1已支付
  --            <SFJSK>是否结算卡支付</SFJSK> //即该单据是否存在入参<JSKLB>来进行支付的,是返回1,否则返回0
  --            <LX>类型</LX> //挂号单固定为挂号,其他按收费类别汇总
  --            <ZXKS>执行科室</ZXKS>
  --            <ZXKSID>执行科室ID</ZXKSID>
  --            <MXLIST> 
  --                     <MX>
  --                                <JZSJ>就诊时间</JZSJ>    //挂号有效:yyyy-mm-dd hh24:mi:ss
  --                                <BW>部位</BW>               //检查,检验时有效
  --                                <XM>项目名称</XM>     //挂号无效:其他项目有效
  --                                <ZXZT>执行状态</ZXZT> //挂号:未接诊;已接诊;完成就诊;收费:未执行;已执行;部分执行
  --                                <BG>报告状态</BG>// 1-已出报告;0未出报告,检查,检验时有效 
  --                                <BLID>病历ID</BLID>  //如果<BG>字段为1，该值不为空,检查,检验时有效
  --                                <GG>规格</GG>                       //药品有效
  --                                <SL>数量</SL> //非挂号有效
  --                                <DW>单位</DW> //非挂号有效
  --                                <DJ>单价</DJ> //非挂号有效
  --                                <JE>金额</JE>  
  --                     </MX>
  --             </MXLIST>
  --             <DL> //队列
  --                        <XH>序号</XH>
  --                        <QMRS>前面人数</QMRS>  //(由Oracle函数zl_GetSequenceBeforPerons获取)
  --             </DL>
  --        </DJ>
  --    </DJLIST>
  --    <ERROR><MSG></MSG></ERROR>                      //如果错误返回
  --</OUTPUT>

  -------------------------------------------------------------------------------------------------- 
  v_Err_Msg Varchar2(200);
  Err_Item Exception;
  x_Templet Xmltype; --模板XML 

  v_卡类别   Varchar2(100);
  n_卡类别id Number(18);
  v_挂号单   Varchar2(10);
  v_排队号码 Varchar2(10);
  n_Temp     Number(18);

  n_Count Number(18);

  v_Temp       Varchar2(32767); --临时XML 
  v_队列       Varchar2(32767);
  v_No         Varchar2(50);
  v_Tmp        Varchar2(4000);
  n_Add_Djlist Number(1); --是否增加了DJLIST的;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/GHDH'), Extractvalue(Value(A), 'IN/JSKLB')
  Into v_挂号单, v_卡类别
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  If v_挂号单 Is Null Then
    v_Err_Msg := '不能找到指定的挂号单号(当前挂号单号为空)';
    Raise Err_Item;
  End If;
  n_Add_Djlist := 0;

  v_Err_Msg := Null;
  If v_卡类别 Is Not Null Then
    Begin
      n_卡类别id := To_Number(v_卡类别);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
  
    If n_卡类别id = 0 Then
      Begin
        Select ID, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_卡类别id, v_Err_Msg
        From 医疗卡类别
        Where 名称 = v_卡类别;
      Exception
        When Others Then
          v_Err_Msg := '卡类别:' || v_卡类别 || '不存在!';
      End;
    
    Else
    
      Begin
        Select ID, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_卡类别id, v_Err_Msg
        From 医疗卡类别
        Where ID = n_卡类别id;
      Exception
        When Others Then
          v_Err_Msg := '未找到指定的结算支付信息!';
      End;
    
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
  End If;
  --1.获取挂号数据
  n_Count := 0;
  For c_挂号 In (Select a.Id, a.No, a.记录性质, a.执行部门id, c.名称 As 执行部门, To_Char(a.登记时间, 'yyyy-mm-dd hh24:mi:ss') As 登记时间,
                      a.预约时间, a.接收时间, To_Char(a.发生时间, 'yyyy-mm-dd HH24:mi') As 就诊时间, a.号别, a.号序, b.金额, a.记录状态,
                      Decode(Nvl(a.执行状态, 0), 0, '等待接诊', 1, '完成就诊', 2, '正在就诊', -1, '取消就诊') As 执行状态,
                      Decode(Nvl(b.结帐id, 0), 0, 0, 1) As 支付标志
               From 病人挂号记录 A,
                    (Select NO, Max(Nvl(结帐id, 0)) As 结帐id, Sum(实收金额) As 金额
                      From 门诊费用记录 B
                      Where 记录性质 = 4 And NO = v_挂号单
                      Group By NO) B, 部门表 C
               Where a.No = v_挂号单 And a.No = b.No And a.执行部门id = c.Id(+)) Loop
    If Nvl(c_挂号.记录状态, 0) <> 1 Then
      v_Err_Msg := '单据号:' || v_挂号单 || '已经被退号!';
      Raise Err_Item;
    End If;
    Begin
      Select 排队号码 Into v_排队号码 From 排队叫号队列 Where 业务id = c_挂号.Id And Nvl(业务类型, 0) = 0;
    Exception
      When Others Then
        v_排队号码 := Null;
    End;
    If v_排队号码 Is Not Null Then
      --业务id_In ,业务类型_In 排队号码_In Number := Null
      n_Temp := Zl_Getsequencebeforperons(c_挂号.Id, 0, v_排队号码);
      v_队列 := v_队列 || '<DL><XH>' || v_排队号码 || '</XH><QMRS>' || n_Temp || '</QMRS></DL>';
    End If;
    n_Temp := 0;
    If Nvl(n_卡类别id, 0) <> 0 Then
      Begin
        Select 1
        Into n_Temp
        From 病人预交记录
        Where NO = v_挂号单 And 记录性质 = 4 And 记录状态 In (1, 3) And 卡类别id = n_卡类别id And Rownum < 2;
      Exception
        When Others Then
          Null;
      End;
    End If;
    v_Temp := '<NO>' || c_挂号.No || '</NO>';
    v_Temp := v_Temp || '<DJLX>' || 4 || '</DJLX>';
    v_Temp := v_Temp || '<KDSJ>' || c_挂号.登记时间 || '</KDSJ>';
    v_Temp := v_Temp || '<ZFZT>' || c_挂号.支付标志 || '</ZFZT>';
    v_Temp := v_Temp || '<SFJSK>' || n_Temp || '</SFJSK>';
    v_Temp := v_Temp || '<LX>挂号</LX>';
    v_Temp := v_Temp || '<ZXKS>' || c_挂号.执行部门 || '</ZXKS>';
    v_Temp := v_Temp || '<ZXKSID>' || c_挂号.执行部门id || '</ZXKSID>';
    v_Temp := v_Temp || '<MXLIST><MX><JZSJ>' || c_挂号.就诊时间 || '</JZSJ><JE>' || c_挂号.金额 || '</JE></MX></MXLIST>';
    If v_队列 Is Not Null Then
      v_Temp := v_Temp || v_队列;
    End If;
  
    If Nvl(n_Add_Djlist, 0) = 0 Then
      --增加DJList节点
      Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype('<DJLIST></DJLIST>')) Into x_Templet From Dual;
      n_Add_Djlist := 1;
    End If;
    v_Temp := '<DJ>' || v_Temp || '</DJ>';
    Select Appendchildxml(x_Templet, '/OUTPUT/DJLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
    n_Count := n_Count + 1;
  End Loop;
  If Nvl(n_Count, 0) = 0 Then
    v_Err_Msg := '未找到指定的挂号单据:' || v_挂号单 || '!';
    Raise Err_Item;
  End If;

  --2.分类汇总收费单
  v_No := '-_';

  For c_费用 In (Select j.医嘱id, j.相关id As 组号, j.No, j.序号, j.收费类别, i.名称 As 收费类别名, j.执行部门id, q.名称 As 执行部门, j.收费细目id, m.名称,
                      m.规格, Max(j.计算单位) As 计算单位, Decode(Max(j.执行状态), 0, '未执行', 1, '完全执行', 2, '部分执行', '') As 执行状态,
                      Max(j.付款状态) As 付款状态, To_Char(Max(j.登记时间), 'yyyy-mm-dd hh24:mi:ss') As 登记时间, Max(j.单价) As 单价,
                      Sum(j.数量) As 数量, Sum(j.实收金额) As 实收金额
               From (Select a.相关id, a.Id As 医嘱id, b.No, b.收费类别, Max(Decode(b.记录状态, 0, 0, 1)) As 付款状态, b.结帐id, b.执行部门id,
                             Max(Decode(b.记录状态, 2, 0, b.执行状态)) As 执行状态,
                             Max(Decode(b.记录状态, 2, Null + Sysdate, b.登记时间)) As 登记时间, Nvl(b.价格父号, b.序号) As 序号, b.收费细目id,
                             b.计算单位, Sum(b.标准单价) As 单价, Avg(Nvl(b.付数, 1) * b.数次) As 数量, Sum(b.实收金额) As 实收金额

                      
                      From 门诊费用记录 B, 病人医嘱记录 A
                      Where Mod(b.记录性质, 10) = 1 And a.Id = b.医嘱序号 And Nvl(b.费用状态, 0) = 0 And a.挂号单 = v_挂号单
                      Group By a.相关id, a.Id, b.No, b.收费类别, b.结帐id, b.执行部门id, Nvl(b.价格父号, b.序号), b.收费细目id, b.计算单位) J,
                    收费项目目录 M, 部门表 Q, 收费项目类别 I
               Where j.收费细目id = m.Id And j.执行部门id = q.Id(+) And j.收费类别 = i.编码(+)
               Group By j.医嘱id, j.相关id, j.No, j.序号, j.收费类别, i.名称, j.执行部门id, q.名称, j.收费细目id, m.名称, m.规格
               Order By 登记时间 Desc, NO Desc, 收费类别, 序号) Loop
    If c_费用.No <> v_No Then
      n_Temp := 0;
      --单据不同,则产生的结构不同
      If Nvl(c_费用.付款状态, 0) = 1 Then
        --是否结算卡支付的
        Begin
          Select 1
          Into n_Temp
          From 病人预交记录 A, 门诊费用记录 B
          Where a.结帐id = b.结帐id And b.No = c_费用.No And Mod(b.记录性质, 10) = 1 And b.记录状态 In (1, 3) And a.卡类别id = n_卡类别id And
                Rownum < 2;
        Exception
          When Others Then
            n_Temp := 0;
        End;
      End If;
      v_Tmp := Null;
      Begin
        Select f_List2str(Cast(Collect(名称) As t_Strlist))
        Into v_Tmp
        From (Select Distinct b.名称
               From 门诊费用记录 A, 收费项目类别 B
               Where a.收费类别 = b.编码 And a.No = c_费用.No And a.记录性质 = 1 And a.记录状态 In (1, 3));
      Exception
        When Others Then
          Null;
      End;
    
      If Nvl(n_Add_Djlist, 0) = 0 Then
        --增加DJList节点
        Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype('<DJLIST></DJLIST>')) Into x_Templet From Dual;
        n_Add_Djlist := 1;
      End If;
    
      v_No   := c_费用.No;
      v_Temp := '<NO>' || c_费用.No || '</NO>';
      v_Temp := v_Temp || '<DJLX>' || 1 || '</DJLX>';
      v_Temp := v_Temp || '<KDSJ>' || c_费用.登记时间 || '</KDSJ>';
      v_Temp := v_Temp || '<ZFZT>' || c_费用.付款状态 || '</ZFZT>';
      v_Temp := v_Temp || '<SFJSK>' || n_Temp || '</SFJSK>';
    
      v_Temp := v_Temp || '<LX>' || Nvl(Replace(v_Tmp, ',', '/'), '') || '</LX>';
      v_Temp := v_Temp || '<ZXKS>' || c_费用.执行部门 || '</ZXKS>';
      v_Temp := v_Temp || '<ZXKSID>' || c_费用.执行部门id || '</ZXKSID>';
      v_Temp := v_Temp || '<MXLIST></MXLIST>' || Nvl(v_队列, '') || '';
      v_Temp := '<DJ NO="' || c_费用.No || '">' || v_Temp || '</DJ>';
      Select Appendchildxml(x_Templet, '/OUTPUT/DJLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
    End If;
  
    v_Temp := '<XM>' || Nvl(c_费用.名称, '') || '</XM>';
    If c_费用.收费类别 = 'D' Then
      --检查获取部位
      Begin
        Select f_List2str(Cast(Collect(标本部位) As t_Strlist))
        Into v_Tmp
        From 病人医嘱记录
        Where 相关id = c_费用.医嘱id;
      Exception
        When Others Then
          v_Tmp := Null;
      End;
      v_Temp := v_Temp || '<BW>' || Nvl(v_Tmp, '') || '</BW>';
    Elsif c_费用.收费类别 = 'C' Then
      --检验
      Begin
        Select Max(Decode(b.审核时间, Null, 0, 1))
        Into n_Temp
        From 病人医嘱记录 A, 检验标本记录 B
        Where a.Id = c_费用.医嘱id And a.Id = b.医嘱id(+) And Exists
         (Select 1 From 病人医嘱记录 Where 相关id = c_费用.医嘱id And 诊疗类别 = 'C');
      Exception
        When Others Then
          n_Temp := 0;
      End;
      v_Temp := v_Temp || '<BG>' || n_Temp || '</BG>';
      If n_Temp = 1 Then
        --取病历ID
        Begin
          Select 病历id
          Into n_Temp
          From 病人医嘱报告
          Where 医嘱id = c_费用.医嘱id And Nvl(病历id, 0) <> 0 And Rownum < 2;
        Exception
          When Others Then
            n_Temp := Null;
        End;
        v_Temp := v_Temp || '<BLID>' || Nvl(n_Temp, '') || '</BLID>';
      End If;
    End If;
  
    v_Temp := v_Temp || '<GG>' || Nvl(c_费用.规格, '') || '</GG>';
    v_Temp := v_Temp || '<SL>' || Nvl(c_费用.数量, 0) || '</SL>';
    v_Temp := v_Temp || '<DW>' || Nvl(c_费用.计算单位, '') || '</DW>';
    v_Temp := v_Temp || '<DJ>' || Nvl(c_费用.单价, 0) || '</DJ>';
    v_Temp := v_Temp || '<JE>' || Nvl(c_费用.实收金额, 0) || '</JE>';
    v_Temp := '<MX>' || v_Temp || '</MX>';
    Select Appendchildxml(x_Templet, '/OUTPUT/DJLIST/DJ[@NO="' || v_No || '"]/MXLIST', Xmltype(v_Temp))
    Into x_Templet
    From Dual;
  
  End Loop;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getvisitdetails;
/

--103996:黄捷,2017-06-12,报告图增加标记
--108543:黄捷,2017-05-17,报告文档编辑器打印控制
CREATE OR REPLACE Package b_Pacs_Rptmanage Is
  Type t_Refcur Is Ref Cursor;

  --1、锁定报告人
  Procedure p_Edit_Doc_Lockinfo
  (
    报告_Id_In 影像报告记录.Id%Type,
    锁定人_In  影像报告记录.锁定人%Type
  );

  --2、评定报告质量
  Procedure p_Edit_Doc_Evaluatrptquality
  (
    报告id_In   影像报告记录.Id%Type,
    质量等级_In 影像报告记录.报告质量%Type
  );

  --3、评定阴阳性
  Procedure p_Edit_Doc_Evaluatresult
  (
    报告id_In   影像报告记录.Id%Type,
    检查结果_In 影像报告记录.结果阳性%Type
  );

  --4、报告发放/回收
  Procedure p_Edit_Doc_Reportrelease
  (
    报告id_In     影像报告记录.Id%Type,
    当前操作人_In 影像报告记录.报告发放人%Type
  );

  --5、新增，修改报告
  Procedure p_影像报告记录_新增
  (
    原型id_In     影像报告记录.原型id%Type,
    报告内容_In   影像报告记录.报告内容%Type,
    记录人_In     影像报告记录.记录人%Type,
    最后编辑人_In 影像报告记录.最后编辑人%Type,
    Id_In         影像报告记录.Id%Type,
    医嘱id_In     影像报告记录.医嘱id%Type
  );

  --6、获取书写的文档内容
  Procedure p_Get_Doc_Content
  (
    Val      Out t_Refcur,
    Docid_In 影像报告记录.Id%Type
  );

  --7、设置报告打印作废信息
  Procedure p_Checkrejectsignature
  (
    Signdate_In Date,
    报告id_In   影像报告操作记录.报告id%Type,
    作废人_In   影像报告操作记录.作废人%Type,
    作废说明_In 影像报告操作记录.作废说明%Type,
    Val         Out Sys_Refcursor
  );

  --8、查询相应原型下的最大序号
  Procedure p_Get_Samplelist_Maxseqnum
  (
    Val       Out t_Refcur,
    原型id_In 影像报告范文清单.原型id%Type
  );

  --9、删除文档范文
  Procedure p_Del_影像报告范文清单(Id_In 影像报告范文清单.Id%Type);

  --10、添加文档的操作日志
  Procedure p_影像报告操作记录_Add
  (
    Id_In       影像报告操作记录.Id%Type,
    报告id_In   影像报告操作记录.报告id%Type,
    操作人_In   影像报告操作记录.操作人%Type,
    操作类型_In 影像报告操作记录.操作类型%Type
  );

  --11、删除报告
  Procedure p_影像报告记录_删除(报告_Id_In 影像报告记录.Id%Type);

  --12、获取签名类型
  Procedure p_Get_Sysconfigsignature
  (
    Val       Out t_Refcur,
    科室id_In In 部门表.Id%Type
  );

  --13、获取账户签名印章
  Procedure p_Get_Personsignimg
  (
    Val   Out t_Refcur,
    Id_In In 人员表.Id%Type
  );

  --14、获取签名的证书信息
  Procedure p_Get_Signcertinfo
  (
    Val       Out t_Refcur,
    证书id_In 人员证书记录.Id%Type
  );

  --15、更新报告状态
  Procedure p_Update_Reportstate
  (
    报告id_In   影像报告记录.Id%Type,
    报告状态_In 影像报告记录.报告状态%Type,
    审核人_In   影像报告记录.最后审核人%Type
  );

  --16、获取报告状态
  Procedure p_Get_Reportstate
  (
    Val       Out t_Refcur,
    报告id_In 影像报告记录.Id%Type
  );

  --17、报告驳回
  Procedure p_Reject_Report
  (
    医嘱id_In   影像报告驳回.医嘱id%Type,
    报告id_In   影像报告驳回.检查报告id%Type,
    驳回理由_In 影像报告驳回.驳回理由%Type,
    驳回时间_In 影像报告驳回.驳回时间%Type,
    驳回人_In   影像报告驳回.驳回人%Type,
    待处理人_In 影像报告记录.待处理人%Type,
    报告状态_In 影像报告记录.报告状态%Type
  );

  --17.1、撤销报告驳回
  Procedure p_Reject_Cancel
  (
    Id_In       影像报告驳回.Id%Type,
    报告id_In   影像报告驳回.检查报告id%Type,
    报告状态_In 影像报告记录.报告状态%Type
  );

  --18、获取报告驳回信息
  Procedure p_Get_Rejectinfo
  (
    Val       Out t_Refcur,
    报告id_In 影像报告驳回.检查报告id%Type
  );

  --19、获取原型动作
  Procedure p_Get_Doc_Process
  (
    Val       Out t_Refcur,
    原型id_In 影像报告动作.原型id%Type
  );

  --20、通过学科筛选获得相应的范文信息
  Procedure p_Get_Samplelist_By_Conditions
  (
    Val          Out t_Refcur,
    原型id_In    Varchar2,
    学科_In      Varchar2,
    Condition_In Varchar2, --过滤筛选
    作者_In      Varchar2
  );

  --21、通过部门ID获取部门名称
  Procedure p_Get_部门名称_By_Id
  (
    Val   Out t_Refcur,
    Id_In 部门表.Id%Type
  );

  --22、提取所有预备提纲
  Procedure p_Get_Allpreoutlines(Val Out t_Refcur);

  --23、提取文档标题
  Procedure p_Get_Reporttitle_By_Id
  (
    Val   Out t_Refcur,
    Id_In 影像报告记录.Id%Type
  );

  --24、提取报告锁定人
  Procedure p_Get_报告锁定人_By_Id
  (
    Val   Out t_Refcur,
    Id_In 影像报告记录.Id%Type
  );

  --25、通过医嘱ID获取报告列表
  Procedure p_Get_影像报告记录_By_医嘱id
  (
    Val       Out t_Refcur,
    医嘱id_In 影像报告记录.医嘱id%Type
  );

  --26、查询影像流程参数值
  Procedure p_Get_影像流程参数值
  (
    Val       Out t_Refcur,
    科室id_In 影像流程参数.科室id%Type
  );

  --27、根据医嘱ID，查询对应的原型列表
  Procedure p_Get_影像原型列表_By_医嘱id
  (
    Val     Out t_Refcur,
    医嘱_In 影像检查记录.医嘱id%Type
  );

  --28、根据报告ID查询打印记录
  Procedure p_Get_Reportprintlog_By_报告id
  (
    Val     Out Sys_Refcursor,
    报告_In 影像报告操作记录.报告id%Type
  );

  --29、根据医嘱ID查询报告发放列表
  Procedure p_Get_Reportreleaselist
  (
    Val     Out t_Refcur,
    医嘱_In 影像报告记录.医嘱id%Type
  );

  --30、根据报告ID查询驳回记录数量
  Procedure p_Get_Rejectedcount
  (
    Val     Out t_Refcur,
    报告_In 影像报告驳回.检查报告id%Type
  );

  --31、根据医嘱ID查询报告动作需要的一些ID们
  Procedure p_Get_Docprocess_Ids
  (
    Val     Out t_Refcur,
    医嘱_In 病人医嘱记录.Id%Type
  );

  --32、根据医嘱ID和报告ID查询报告的一些参数
  Procedure p_Get_Docinfo
  (
    Val       Out t_Refcur,
    医嘱id_In 影像检查记录.医嘱id%Type,
    报告id_In 影像报告记录.Id%Type
  );

  --33、查询一个检查中相同原型ID的报告数量
  Procedure p_Get_Sameantetypedoccounts
  (
    Val       Out t_Refcur,
    医嘱id_In 影像报告记录.医嘱id%Type,
    原型id_In 影像报告记录.原型id%Type
  );

  --34、提取报告图存储信息
  Procedure p_Get_Docimagesaveinof_By_Id
  (
    Val   Out t_Refcur,
    Id_In 影像报告记录.Id%Type
  );

  --35、修改原型使用次数
  Procedure p_Update_Antetypeusecount(Id_In 影像报告原型清单.Id%Type);

  --36、更新影像检查图像的报告图标记
  Procedure p_Update_Rptimage
  (
    Uid_In        影像检查图象.图像uid%Type,
    Actiontype_In Number
  );

  --37、提取打印控制信息
  Procedure p_Get_Printcontrol
  (
    Val       Out t_Refcur,
    报告id_In 影像报告记录.Id%Type
  );

End b_Pacs_Rptmanage;

/
CREATE OR REPLACE Package Body b_Pacs_Rptmanage Is

  --1、锁定报告人
  Procedure p_Edit_Doc_Lockinfo
  (
    报告_Id_In 影像报告记录.Id%Type,
    锁定人_In  影像报告记录.锁定人%Type
  ) Is
  Begin

    --  报告ID为空，则清空所有“锁定人_In”正在锁定的标记
    If 报告_Id_In Is Null Then
      Update 影像报告记录 a Set a.锁定人 = '' Where a.锁定人 = 锁定人_In;
    Else
      Update 影像报告记录 a Set a.锁定人 = 锁定人_In Where a.Id = 报告_Id_In;
    End If;

  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Doc_Lockinfo;

  --2、评定报告质量
  Procedure p_Edit_Doc_Evaluatrptquality
  (
    报告id_In   影像报告记录.Id%Type,
    质量等级_In 影像报告记录.报告质量%Type
  ) Is
  Begin
    Update 影像报告记录 Set 报告质量 = 质量等级_In Where Id = 报告id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Doc_Evaluatrptquality;

  --3、评定阴阳性
  Procedure p_Edit_Doc_Evaluatresult
  (
    报告id_In   影像报告记录.Id%Type,
    检查结果_In 影像报告记录.结果阳性%Type
  ) Is
  Begin
    Update 影像报告记录 Set 结果阳性 = 检查结果_In Where Id = 报告id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Doc_Evaluatresult;

  --4、报告发放/回收
  Procedure p_Edit_Doc_Reportrelease
  (
    报告id_In     影像报告记录.Id%Type,
    当前操作人_In 影像报告记录.报告发放人%Type
  ) Is
    v_报告发放 影像报告记录.报告发放%Type;
  Begin

    Begin
      Select Nvl(报告发放, 0) Into v_报告发放 From 影像报告记录 Where Id = 报告id_In;
    Exception
      When Others Then
        v_报告发放 := 0;
    End;

    Update 影像报告记录
    Set 报告发放 = Decode(v_报告发放, 0, 1, 0), 报告发放人 = Decode(v_报告发放, 0, 当前操作人_In, '')
    Where Id = 报告id_In;

  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Doc_Reportrelease;

  --5、新增，修改报告
  Procedure p_影像报告记录_新增
  (
    原型id_In     影像报告记录.原型id%Type,
    报告内容_In   影像报告记录.报告内容%Type,
    记录人_In     影像报告记录.记录人%Type,
    最后编辑人_In 影像报告记录.最后编辑人%Type,
    Id_In         影像报告记录.Id%Type,
    医嘱id_In     影像报告记录.医嘱id%Type
  ) As
    --原型ID_In 原型ID
    --保存文档书写记录
    --1 处理匿名数据
    --2 保存文档书写记录、状态
    --3 处理编辑日志
    --4 更新文档任务
    v_报告id    影像报告记录.Id%Type;
    v_原型名称  影像报告原型清单.名称%Type;
    v_设备号    影像报告原型清单.设备号%Type;
    v_报告序号  Number;
    x_Editlog   Xmltype;
    Cur_Time    Date;
    To_Editlist t_Editlist;
    Tn_Editlist t_Editlist;
    v_Msg       Varchar2(200);
    v_New       Number;
    Err_Custom Exception;
    v_Result 影像报告记录.诊断意见%Type;
    v_操作id 影像报告操作记录.Id%Type;

    Function Elist_Filter(Source_t t_Editlist) Return t_Editlist Is
      Target_t t_Editlist := t_Editlist();
    Begin

      --对独立文档来说，这个函数只是将 Source_t按照编辑时间排序后输出
      For Rs In (Select /*+rule*/
                  *
                 From Table(Cast(Source_t As t_Editlist)) a
                 Order By a.编辑时间) Loop
        Target_t.Extend;
        Target_t(Target_t.Count) := t_Edits(Rs.编辑人, Rs.编辑时间, Rs.签名, Rs.审订签名);
      End Loop;
      Return Target_t;
    End;

    Function Build_Editlog
    (
      Tn_Edit t_Editlist,
      To_Edit t_Editlist,
      v_Did   影像报告记录.Id%Type
    ) Return Xmltype Is
      --Tn_Edit 本次保存的新编辑记录；To_Edit上次保存的旧编辑记录
      --将两次编辑记录，组合成一个编辑记录

      x_Return Xmltype;
      r_Saveid Raw(16);
      n_Class  Number;
      --n_Class 编辑日志中的操作类别： 1-创建、2-删除、3-编辑、4-签名、5-审订、6-审签、7-撤签
      v_Signor  影像报告记录.创建人%Type;
      v_Adjunct 影像报告记录.创建人%Type;
      Tns_Edit  t_Editlist;
      Tos_Edit  t_Editlist;

      Function Atitle(原型id 影像报告原型清单.Id%Type) Return Varchar2 Is
        v_原型名称 影像报告原型清单.名称%Type;
      Begin
        --根据原型ID，返回原型名称
        If 原型id Is Null Then
          Return Null;
        Else
          Select 名称 Into v_原型名称 From 影像报告原型清单 Where Id = 原型id;
          Return v_原型名称;
        End If;
      End;

    Begin
      x_Return := Xmltype('<root></root>');
      If v_Did Is Null Then
        --表明是新增文档，新增文档传null进来
        Select Sys_Guid() Into r_Saveid From Dual;

        --PACS报告没有子文档，但是下面构造XML的语句保留成跟EMR相同，这里的v_Subiid赋值为空
        Tns_Edit := Elist_Filter(Tn_Edit);
        Select Decode(Tns_Edit(Tns_Edit.Count).签名, 0, 1, 4) Into n_Class From Dual;
        Select Appendchildxml(x_Return,
                               '/root',
                               Xmlelement("operate",
                                          Xmlforest(r_Saveid As "saving_id",
                                                    n_Class As "class",
                                                    To_Char(Cur_Time, 'yyyy-mm-dd hh24:mi:ss') As "cur_time",
                                                    最后编辑人_In As "operator",
                                                    Decode(n_Class, 4, Tns_Edit(Tns_Edit.Count).编辑人, '') As "signer",
                                                    '' As Adjunct)))
        Into x_Return
        From Dual;
      Else
        --不是新增的文档？
        Select Sys_Guid() Into r_Saveid From Dual;

        v_Signor  := '';
        v_Adjunct := '';
        Tns_Edit  := Elist_Filter(Tn_Edit);
        Tos_Edit  := Elist_Filter(To_Edit);
        If Tns_Edit(Tns_Edit.Count).签名 = 1 And Tns_Edit(Tns_Edit.Count).审订签名 = 0 Then
          --最近一次是签名
          If Tos_Edit.Count = 0 Then
            --新增子文档直接签名
            n_Class  := 4;
            v_Signor := Tns_Edit(Tns_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count).编辑人 Is Null Then
            --之前没签名
            n_Class  := 4;
            v_Signor := Tns_Edit(Tns_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count).签名 = 1 And Tns_Edit(Tns_Edit.Count).编辑时间 > Tos_Edit(Tos_Edit.Count).编辑时间 Then
            --多次普通签名
            n_Class  := 4;
            v_Signor := Tns_Edit(Tns_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count).签名 = 1 And Tns_Edit(Tns_Edit.Count).编辑时间 < Tos_Edit(Tos_Edit.Count).编辑时间 Then
            --撤消多次签名
            n_Class   := 7;
            v_Adjunct := Tos_Edit(Tos_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count).签名 = 1 And Tns_Edit(Tns_Edit.Count).编辑时间 = Tos_Edit(Tos_Edit.Count).编辑时间 Then
            --无变化
            n_Class := -1;
          End If;
        Elsif Tns_Edit(Tns_Edit.Count).签名 = 1 And Tns_Edit(Tns_Edit.Count).审订签名 = 1 Then
          --审订签名
          If Tos_Edit(Tos_Edit.Count).审订签名 = 0 Then
            --之前没审签，可能是已签名或已审订
            n_Class  := 6;
            v_Signor := Tns_Edit(Tns_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count).审订签名 = 1 And Tns_Edit(Tns_Edit.Count).编辑时间 > Tos_Edit(Tos_Edit.Count).编辑时间 Then
            --多次审签
            n_Class  := 6;
            v_Signor := Tns_Edit(Tns_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count).审订签名 = 1 And Tns_Edit(Tns_Edit.Count).编辑时间 < Tos_Edit(Tos_Edit.Count).编辑时间 Then
            --撤消多次审签
            n_Class   := 7;
            v_Adjunct := Tos_Edit(Tos_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count).审订签名 = 1 And Tns_Edit(Tns_Edit.Count).编辑时间 = Tos_Edit(Tos_Edit.Count).编辑时间 Then
            --无变化
            n_Class := -1;
          End If;
        Elsif Tns_Edit(Tns_Edit.Count).编辑人 Is Null And Tos_Edit.Count = 0 Then
          n_Class := 1;
        Elsif Tns_Edit(Tns_Edit.Count).编辑人 Is Null And Tos_Edit(Tos_Edit.Count).签名 = 1 Then
          n_Class   := 7;
          v_Adjunct := Tos_Edit(Tos_Edit.Count).编辑人;
        Elsif Tns_Edit(Tns_Edit.Count).编辑人 Is Null And Tos_Edit(Tos_Edit.Count).编辑人 Is Null Then
          n_Class := 3;
        Elsif Tns_Edit(Tns_Edit.Count).审订签名 = 0 And Tos_Edit(Tos_Edit.Count).审订签名 = 0 Then
          n_Class := 5;
        Elsif Tns_Edit(Tns_Edit.Count).审订签名 = 0 And Tos_Edit(Tos_Edit.Count).审订签名 = 1 Then
          n_Class   := 7;
          v_Adjunct := Tos_Edit(Tos_Edit.Count).编辑人;
        End If;

        If n_Class <> -1 Then
          Select Appendchildxml(x_Return,
                                 '/root',
                                 Xmlelement("operate",
                                            Xmlforest(r_Saveid As "saving_id",
                                                      n_Class As "class",
                                                      To_Char(Cur_Time, 'yyyy-mm-dd hh24:mi:ss') As "cur_time",
                                                      最后编辑人_In As "operator",
                                                      Decode(n_Class, 4, v_Signor, 6, v_Signor, '') As "signer",
                                                      v_Adjunct As Adjunct)))
          Into x_Return
          From Dual;
        End If;

      End If;
      Return x_Return;
    End Build_Editlog;

    Function Get_Nextrptnum
    (
      Antetypename 影像报告原型清单.名称%Type,
      Order_Id     影像报告记录.医嘱id%Type
    ) Return Number Is
      v_序号  Number;
      v_Count Number;
      v_Num   Number;
    Begin

      v_Count := 0;
      v_Num   := 1;
      Loop
        Select Count(*) + v_Num Into v_序号 From 影像报告记录 Where 医嘱id = Order_Id;
        Select Count(*)
        Into v_Count
        From 影像报告记录
        Where 医嘱id = Order_Id
        And 文档标题 = Antetypename || '_' || v_序号;

        If v_Count = 0 Then
          Exit;
        End If;

        v_Num := v_Num + 1;
      End Loop;

      Return v_序号;
    End;

  Begin

    Select 名称, 设备号, Sysdate Into v_原型名称, v_设备号, Cur_Time From 影像报告原型清单 Where Id = 原型id_In;

    --------------------1 保存文档书写记录、状态--------------------
    --提取文档的签名和编辑（新增、修改）记录
    Tn_Editlist := b_Pacs_Rptpublic.f_Geteditlist(报告内容_In);

    --------------------2 处理编辑日志--------------------
    Select Count(*) Into v_New From 影像报告记录 Where Id = Id_In;

    v_报告id := Id_In;
    Select Zlpub_Pacs_取提纲内容byxml(报告内容_In, '诊断意见') Into v_Result From Dual;
    If v_New = 0 Then
      --新增报告
      To_Editlist := t_Editlist();
      x_Editlog   := Build_Editlog(Tn_Editlist, To_Editlist, Null);

      --取报告序号
      v_报告序号 := Get_Nextrptnum(v_原型名称, 医嘱id_In);

      Insert Into 影像报告记录
        (Id, 原型id, 文档标题, 报告内容, 创建时间, 创建人, 报告状态, 最后编辑时间, 最后编辑人, 编辑日志, 医嘱id, 记录人, 诊断意见, 设备号)
      Values
        (v_报告id, 原型id_In, v_原型名称 || '_' || v_报告序号, 报告内容_In, Cur_Time, 最后编辑人_In, 1, Cur_Time, 最后编辑人_In, x_Editlog,
         医嘱id_In, 记录人_In, v_Result, v_设备号);
      Insert Into 病人医嘱报告 (医嘱id, 检查报告id) Values (医嘱id_In, v_报告id);

      Select Sys_Guid() Into v_操作id From Dual;
      Insert Into 影像报告操作记录
        (Id, 报告id, 医嘱id, 文档标题, 操作人, 操作时间, 操作类型)
      Values
        (v_操作id, v_报告id, 医嘱id_In, v_原型名称 || '_' || v_报告序号, 最后编辑人_In, Sysdate, 6);

    Else
      --提取文件原始编辑记录,必需在更新之前提取
      Select b_Pacs_Rptpublic.f_Geteditlist(报告内容) Into To_Editlist From 影像报告记录 Where Id = v_报告id;

      x_Editlog := Build_Editlog(Tn_Editlist, To_Editlist, v_报告id);
      Select Appendchildxml(编辑日志, '/root', Extract(x_Editlog, '/root/*'))
      Into x_Editlog
      From 影像报告记录
      Where Id = v_报告id;

      Update 影像报告记录
      Set 报告内容 = 报告内容_In, 最后编辑时间 = Cur_Time, 最后编辑人 = 最后编辑人_In, 编辑日志 = x_Editlog, 记录人 = 记录人_In, 诊断意见 = v_Result
      Where Id = v_报告id;
    End If;

  Exception
    When Err_Custom Then
      Raise_Application_Error(-20101, v_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_影像报告记录_新增;

  --6、获取书写的文档内容
  Procedure p_Get_Doc_Content
  (
    Val      Out t_Refcur,
    Docid_In 影像报告记录.Id%Type
  ) As
  Begin
    Open Val For
      Select (Nvl(a.报告内容, Xmltype('<ZLXML/>'))).Getclobval() As 报告内容 From 影像报告记录 a Where a.Id = Docid_In;
  End;

  --7、设置报告打印作废信息
  Procedure p_Checkrejectsignature
  (
    Signdate_In Date,
    报告id_In   影像报告操作记录.报告id%Type,
    作废人_In   影像报告操作记录.作废人%Type,
    作废说明_In 影像报告操作记录.作废说明%Type,
    Val         Out Sys_Refcursor
  ) As
  Begin
    Open Val For
      Select 操作人, 操作时间
      From 影像报告操作记录
      Where 报告id = 报告id_In
      And 操作类型 = 1
      And 操作时间 >= Signdate_In
      And 作废时间 Is Null
      Order By 操作时间 Asc;
    --作废打印记录
    Update 影像报告操作记录 b
    Set 作废人 = 作废人_In, 作废时间 = Sysdate, b.作废说明 = 作废说明_In
    Where 报告id = 报告id_In
    And 操作类型 = 1
    And 操作时间 >= Signdate_In;

  End p_Checkrejectsignature;

  --8、查询相应原型下的最大序号
  Procedure p_Get_Samplelist_Maxseqnum
  (
    Val       Out t_Refcur,
    原型id_In 影像报告范文清单.原型id%Type
  ) As
  Begin
    Open Val For
      Select Nvl(Max(a.编号), 0) + 1 As Num From 影像报告范文清单 a Where a.原型id = 原型id_In;
  End;

  --9、删除文档范文
  Procedure p_Del_影像报告范文清单(Id_In 影像报告范文清单.Id%Type) As
  Begin
    Delete From 影像报告范文清单 Where Id = Id_In;
  End;

  --10、添加文档的操作日志
  Procedure p_影像报告操作记录_Add
  (
    Id_In       影像报告操作记录.Id%Type,
    报告id_In   影像报告操作记录.报告id%Type,
    操作人_In   影像报告操作记录.操作人%Type,
    操作类型_In 影像报告操作记录.操作类型%Type
  ) As
    n_医嘱id   影像报告操作记录.医嘱id%Type;
    n_文档标题 影像报告记录.文档标题%Type;
  Begin

    Begin
      Select 医嘱id, 文档标题 Into n_医嘱id, n_文档标题 From 影像报告记录 Where Id = 报告id_In;
    Exception
      When Others Then
        Null;
    End;
    If n_医嘱id Is Not Null Then
      Insert Into 影像报告操作记录
        (Id, 报告id, 医嘱id, 文档标题, 操作人, 操作时间, 操作类型)
      Values
        (Id_In, 报告id_In, n_医嘱id, n_文档标题, 操作人_In, Sysdate, 操作类型_In);
      If 操作类型_In = 1 Then
        Update 影像报告记录 Set 报告打印 = 1 Where Id = 报告id_In;
      End If;
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --11、删除报告
  Procedure p_影像报告记录_删除(报告_Id_In 影像报告记录.Id%Type) As
  Begin

    Delete From 影像报告记录 Where 影像报告记录.Id = Hextoraw(报告_Id_In);

    Delete From 病人医嘱报告 Where 检查报告id = Hextoraw(报告_Id_In);

  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_影像报告记录_删除;

  --12、获取签名类型
  Procedure p_Get_Sysconfigsignature
  (
    Val       Out t_Refcur,
    科室id_In In 部门表.Id%Type
  ) Is
  Begin
    --返回用户, 模块号,功能
    Open Val For
      Select Zl_Fun_Getsignpar(7, 科室id_In) As 签名类型 From Dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --13、获取账户签名印章
  Procedure p_Get_Personsignimg
  (
    Val   Out t_Refcur,
    Id_In In 人员表.Id%Type
  ) Is
    --v_sql Varchar2(1000);
    --n_count Number(5);
  Begin
    --Select Count(*) Into n_Count From user_tables Where table_name =Upper('影像签名图片');

    --If n_Count > 0 Then
    --   v_sql := 'Truncate Table 影像签名图片';
    --   Execute Immediate v_sql;

    --   v_sql := 'Insert Into 影像签名图片 Select a.id, to_lob(a.签名图片) as 签名图片 From 人员表 a Where a.ID=' || ID_In;
    --   Execute Immediate v_sql;
    --Else
    --   v_sql := 'Create GLOBAL TEMPORARY TABLE 影像签名图片 ON COMMIT PRESERVE ROWS AS Select a.id, to_lob(a.签名图片) as 签名图片 From 人员表 a Where a.ID=' || ID_In;
    --   Execute Immediate v_sql;
    --End If;

    --v_sql := 'Select 签名图片 From 影像签名图片 Where Id=:ID';

    ----返回用户, 模块号,功能
    --Open  Val For v_sql Using ID_In;

    Open Val For
      Select To_Blob(签名图片) As 签名图片 From 人员表 Where Id = Id_In;

  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --14、获取签名的证书信息
  Procedure p_Get_Signcertinfo
  (
    Val       Out t_Refcur,
    证书id_In 人员证书记录.Id%Type
  ) Is
  Begin
    Open Val For
      Select Id, Certdn, Certsn, Signcert, Enccert From 人员证书记录 Where Id = 证书id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --15、更新报告状态
  Procedure p_Update_Reportstate
  (
    报告id_In   影像报告记录.Id%Type,
    报告状态_In 影像报告记录.报告状态%Type,
    审核人_In   影像报告记录.最后审核人%Type
  ) Is
  Begin
    --报告状态1-未签名；2-已诊断；3-已审核；4-已终审；5-诊断驳回；6-审核驳回
    --如果报告状态是1-未签名；2-已诊断;5-诊断驳回，此时是没有审核人的
    If (报告状态_In = 1) Or (报告状态_In = 2) Or (报告状态_In = 5) Then
      Update 影像报告记录 Set 报告状态 = 报告状态_In, 最后审核人 = Null, 最后审核时间 = Null Where Id = 报告id_In;
    Elsif (报告状态_In = 3) Or (报告状态_In = 4) Then
      Update 影像报告记录
      Set 报告状态 = 报告状态_In, 最后审核人 = 审核人_In, 最后审核时间 = Sysdate
      Where Id = 报告id_In;
    Else
      Update 影像报告记录 Set 报告状态 = 报告状态_In Where Id = 报告id_In;
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --16、获取报告状态
  Procedure p_Get_Reportstate
  (
    Val       Out t_Refcur,
    报告id_In 影像报告记录.Id%Type
  ) Is
  Begin
    Open Val For
      Select 报告状态 From 影像报告记录 Where Id = 报告id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --17、报告驳回
  Procedure p_Reject_Report
  (
    医嘱id_In   影像报告驳回.医嘱id%Type,
    报告id_In   影像报告驳回.检查报告id%Type,
    驳回理由_In 影像报告驳回.驳回理由%Type,
    驳回时间_In 影像报告驳回.驳回时间%Type,
    驳回人_In   影像报告驳回.驳回人%Type,
    待处理人_In 影像报告记录.待处理人%Type,
    报告状态_In 影像报告记录.报告状态%Type
  ) Is
  Begin
    Insert Into 影像报告驳回
      (Id, 医嘱id, 检查报告id, 驳回理由, 驳回时间, 驳回人)
    Values
      (影像报告驳回_Id.Nextval, 医嘱id_In, 报告id_In, 驳回理由_In, 驳回时间_In, 驳回人_In);

    Update 影像报告记录 Set 报告状态 = 报告状态_In, 待处理人 = 待处理人_In Where Id = 报告id_In;

    --Update 病人医嘱发送 Set 执行过程=-1 Where 医嘱ID= 医嘱ID_IN;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --17.1、撤销报告驳回
  Procedure p_Reject_Cancel
  (
    Id_In       影像报告驳回.Id%Type,
    报告id_In   影像报告驳回.检查报告id%Type,
    报告状态_In 影像报告记录.报告状态%Type
  ) Is
  Begin
    Update 影像报告驳回 Set 是否撤销 = 1 Where Id = Id_In;
    Update 影像报告记录 Set 报告状态 = 报告状态_In, 待处理人 = '' Where Id = 报告id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --18、获取报告驳回信息
  Procedure p_Get_Rejectinfo
  (
    Val       Out t_Refcur,
    报告id_In 影像报告驳回.检查报告id%Type
  ) Is
  Begin
    Open Val For
      Select a.Id, a.驳回理由, a.驳回时间, a.驳回人, Nvl(a.是否撤销, 0) As 驳回状态, b.报告状态
      From 影像报告驳回 a, 影像报告记录 b
      Where a.检查报告id = 报告id_In
      And a.检查报告id = b.Id
      Order By 驳回时间;
  End;

  --19、获取原型动作
  Procedure p_Get_Doc_Process
  (
    Val       Out t_Refcur,
    原型id_In 影像报告动作.原型id%Type
  ) As
  Begin
    Open Val For
      Select Rawtohex(p.Id) Id, p.名称 As 动作名称, e.名称 As 事件名称, e.种类 As 事件种类, e.元素iid As 元素iid, p.动作类型, p.序号, p.说明, p.可否手工执行,
             (Nvl(p.内容, Xmltype('<NULL/>'))).Getclobval() As 内容, Rawtohex(p.事件id) 事件id
      From 影像报告动作 p, 影像报告事件 e
      Where p.事件id = e.Id(+)
      And p.原型id = 原型id_In
      Order By 动作类型, 序号;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Doc_Process;

  --20、通过学科筛选获得相应的范文信息
  Procedure p_Get_Samplelist_By_Conditions
  (
    Val          Out t_Refcur,
    原型id_In    Varchar2,
    学科_In      Varchar2,
    Condition_In Varchar2, --过滤筛选
    作者_In      Varchar2
  ) As
  Begin

    Open Val For
      Select /*+ rule*/
       Rawtohex(a.Id) Id, a.名称, a.作者, a.说明, Nvl2(a.说明, a.说明 || '作者:' || a.作者, '作者:' || a.作者) Content, a.标签, a.学科
      From 影像报告范文清单 a
      Where a.原型id = Hextoraw(原型id_In)
      And ((a.学科 Is Null And a.是否私有 = 0) Or 学科_In Is Null Or a.作者 = 作者_In Or
            (a.学科 Is Not Null And b_Pacs_Rptpublic.f_If_Intersect(a.学科, 学科_In) > 0 And a.是否私有 = 0))
      And (Condition_In Is Null Or
            (a.标签 Is Not Null And Condition_In Is Not Null And b_Pacs_Rptpublic.f_If_Intersect(a.标签, Condition_In) > 0))
      Order By a.编号;

  End p_Get_Samplelist_By_Conditions;

  --21、通过部门ID获取部门名称
  Procedure p_Get_部门名称_By_Id
  (
    Val   Out t_Refcur,
    Id_In 部门表.Id%Type
  ) Is
  Begin
    Open Val For
      Select 名称 From 部门表 Where Id = Id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_部门名称_By_Id;

  --22、提取所有预备提纲
  Procedure p_Get_Allpreoutlines(Val Out t_Refcur) Is
  Begin
    Open Val For
      Select Rawtohex(Id) Id, a.编码, a.名称 From 影像报告预备提纲 a Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Allpreoutlines;

  --23、提取文档标题
  Procedure p_Get_Reporttitle_By_Id
  (
    Val   Out t_Refcur,
    Id_In 影像报告记录.Id%Type
  ) Is
  Begin
    Open Val For
      Select 文档标题 From 影像报告记录 Where Id = Id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Reporttitle_By_Id;

  --24、提取报告锁定人
  Procedure p_Get_报告锁定人_By_Id
  (
    Val   Out t_Refcur,
    Id_In 影像报告记录.Id%Type
  ) Is
  Begin
    Open Val For
      Select 锁定人 From 影像报告记录 Where Id = Id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_报告锁定人_By_Id;

  --25、通过医嘱ID获取报告列表
  Procedure p_Get_影像报告记录_By_医嘱id
  (
    Val       Out t_Refcur,
    医嘱id_In 影像报告记录.医嘱id%Type
  ) Is
  Begin
    Open Val For
      Select Rawtohex(Id) As Reportid, Rawtohex(原型id) As Antetypeid, 医嘱id As Orderid, 文档标题 As Reportname,
             创建时间 As Reportdate,
             Decode(Nvl(报告状态, 0), 1, '编辑中', 2, '已诊断', 3, '已审核', 4, '已终审', 5, '诊断驳回', '审核驳回') As Reportstate,
             创建人 As Createuser, 最后审核时间 As Examineydate, 最后审核人 As Examineyuser,
             Decode(Nvl(结果阳性, 0), 1, '阳性', '') As Resultpositive, Nvl(报告质量, 0) As Innerquality, ' ' As Reportquality,
             Decode(Nvl(报告打印, 0), 0, '未打印', '已打印') As Reportprint,
             Decode(Nvl(报告发放, 0), 0, '未发放', '已发放') As Reportrelease, 记录人 As Recdoctor
      From 影像报告记录
      Where 医嘱id = 医嘱id_In
      Order By Reportdate Desc;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_影像报告记录_By_医嘱id;

  --26、查询影像流程参数值
  Procedure p_Get_影像流程参数值
  (
    Val       Out t_Refcur,
    科室id_In 影像流程参数.科室id%Type
  ) Is
  Begin
    Open Val For
      Select 参数名, 参数值 From 影像流程参数 Where 科室id = 科室id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_影像流程参数值;

  --27、根据医嘱ID，查询对应的原型列表
  Procedure p_Get_影像原型列表_By_医嘱id
  (
    Val     Out t_Refcur,
    医嘱_In 影像检查记录.医嘱id%Type
  ) Is
  Begin
    Open Val For
      Select Rawtohex(c.Id) As Antetypeid, c.名称 As Antetypename, c.说明
      From 病人医嘱记录 a, 影像报告原型应用 b, 影像报告原型清单 c
      Where a.Id = 医嘱_In
      And a.诊疗项目id = b.诊疗项目id
      And b.报告原型id = c.Id
      And a.病人来源 = b.应用场合
      Order By c.使用次数 Desc;

  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_影像原型列表_By_医嘱id;

  --28、根据报告ID查询打印记录
  Procedure p_Get_Reportprintlog_By_报告id
  (
    Val     Out Sys_Refcursor,
    报告_In 影像报告操作记录.报告id%Type
  ) Is
  Begin
    Open Val For
      Select c.文档标题, b.操作人, To_Char(b.操作时间, 'yyyy-MM-dd HH24:mi') 打印时间, b.作废人,
             To_Char(b.作废时间, 'yyyy-MM-dd HH24:mi') 作废时间, b.作废说明
      From 影像报告操作记录 b, 影像报告记录 c
      Where c.Id = 报告_In
      And b.报告id = c.Id
      And 操作类型 = 1
      Order By b.操作时间;

  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Reportprintlog_By_报告id;

  --29、根据医嘱ID查询报告发放列表
  Procedure p_Get_Reportreleaselist
  (
    Val     Out t_Refcur,
    医嘱_In 影像报告记录.医嘱id%Type
  ) Is
  Begin
    Open Val For
      Select Rawtohex(Id) As 报告id, 文档标题 As 报告名称, 最后编辑时间 As 报告日期, Decode(Nvl(报告发放, 0), 0, '未发放', '已发放') As 报告发放
      From 影像报告记录
      Where 报告状态 Between 2 And 4
      And 医嘱id = 医嘱_In;

  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Reportreleaselist;

  --30、根据报告ID查询驳回记录数量
  Procedure p_Get_Rejectedcount
  (
    Val     Out t_Refcur,
    报告_In 影像报告驳回.检查报告id%Type
  ) Is
  Begin
    Open Val For
      Select Count(*) As 驳回数量 From 影像报告驳回 Where 检查报告id = 报告_In;

  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Rejectedcount;

  --31、根据医嘱ID查询报告动作需要的一些ID们
  Procedure p_Get_Docprocess_Ids
  (
    Val     Out t_Refcur,
    医嘱_In 病人医嘱记录.Id%Type
  ) Is
  Begin
    Open Val For
      Select Id As 医嘱id, 主页id, 挂号单 From 病人医嘱记录 Where Id = 医嘱_In;

  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Docprocess_Ids;

  --32、根据医嘱ID和报告ID查询报告的一些参数
  Procedure p_Get_Docinfo
  (
    Val       Out t_Refcur,
    医嘱id_In 影像检查记录.医嘱id%Type,
    报告id_In 影像报告记录.Id%Type
  ) Is
  Begin
    If 报告id_In Is Null Then
      Open Val For
        Select 执行科室id, '创建人' As 创建人 From 影像检查记录 Where 医嘱id = 医嘱id_In;
    Else
      Open Val For
        Select 执行科室id, 创建人
        From 影像检查记录 a, 影像报告记录 b
        Where a.医嘱id = b.医嘱id
        And b.Id = 报告id_In;
    End If;

  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Docinfo;

  --33、查询一个检查中相同原型ID的报告数量
  Procedure p_Get_Sameantetypedoccounts
  (
    Val       Out t_Refcur,
    医嘱id_In 影像报告记录.医嘱id%Type,
    原型id_In 影像报告记录.原型id%Type
  ) Is
  Begin
    Open Val For
      Select Count(Id) As Doccounts
      From 影像报告记录
      Where 医嘱id = 医嘱id_In
      And 原型id = 原型id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Sameantetypedoccounts;

  --34、提取报告图存储信息
  Procedure p_Get_Docimagesaveinof_By_Id
  (
    Val   Out t_Refcur,
    Id_In 影像报告记录.Id%Type
  ) Is
  Begin
    Open Val For
      Select 设备号, 创建时间 From 影像报告记录 Where Id = Id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Docimagesaveinof_By_Id;

  --35、修改原型使用次数
  Procedure p_Update_Antetypeusecount(Id_In 影像报告原型清单.Id%Type) Is
  Begin
    Update 影像报告原型清单 Set 使用次数 = 使用次数 + 1 Where Id = Id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Update_Antetypeusecount;

  --36、更新影像检查图像的报告图标记
  Procedure p_Update_Rptimage
  (
    Uid_In        影像检查图象.图像uid%Type,
    Actiontype_In Number
  ) Is
    v_Sql Varchar2(4000);
    No_Column Exception;
    Pragma Exception_Init(No_Column, -00904);
  Begin
    If Actiontype_In = 1 Then
      v_Sql := 'Update 影像检查图象 Set 报告图 = Nvl(报告图, 0) + 1 Where 图像uid = :1';
    Else
      v_Sql := 'Update 影像检查图象
      Set 报告图 = Decode(报告图, Null, Null, Decode(Nvl(报告图, 0) - 1, 0, Null, Nvl(报告图, 0) - 1))
      Where 图像uid = :1';
    End If;
    Execute Immediate v_Sql
      Using Uid_In;
  Exception
    When No_Column Then
      --兼容处理，10.36新增加 报告图 字段，问题号 103996
      Null;
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Update_Rptimage;

  --37、提取打印控制信息
  Procedure p_Get_Printcontrol
  (
    Val       Out t_Refcur,
    报告id_In 影像报告记录.Id%Type
  ) Is
    v_紧急     Number;
    v_打印控制 Number;
  Begin

    Select Nvl(Decode(a.急诊, 1, 1, b.紧急标志), 0) As 紧急
    Into v_紧急
    From 病人挂号记录 a, 病人医嘱记录 b
    Where a.No(+) = b.挂号单
    And b.Id = (Select c.医嘱id From 影像报告记录 c Where c.Id = 报告id_In);

    Select Nvl(Extractvalue(b.Column_Value, '/root/print_limit'), 0) Printlimit
    Into v_打印控制
    From 影像报告原型清单 a, Table(Xmlsequence(Extract(a.控制选项, '/root'))) b, 影像报告记录 c
    Where a.Id = c.原型id
    And c.Id = 报告id_In;

    Open Val For
      Select v_紧急 As 紧急, v_打印控制 As 打印控制 From Dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Printcontrol;

End b_Pacs_Rptmanage;
/

--103996:黄捷,2017-06-12,报告图增加标记
Create Or Replace Package b_Pacs_Rptpluginoriginal Is
  Type t_Refcur Is Ref Cursor;

  -- 1、功    能：获取历史报告记录
  Procedure p_Getreporthistory
  (
    Val                   Out t_Refcur,
    医嘱id_In             In 病人医嘱记录.Id%Type,
    人员id_In             In 部门人员.人员id%Type,
    当前科室id_In         In 部门人员.部门id%Type,
    查看其他科历史报告_In In Number := 0
  );

  --2、功    能：获取对应报告内容
  Procedure p_Getreportcontent
  (
    Val           Out t_Refcur,
    报告id_In     In Varchar2,
    Editortype_In Number := 0 --0:PACS报告编辑器，1--电子病历编辑器，2--报告文档编辑器
  );

  --3、功    能：根据医嘱ID获取检查信息
  Procedure p_Getstudyinfobyadviceid
  (
    Val       Out t_Refcur,
    医嘱id_In In 影像检查记录.医嘱id%Type
  );

  --4、功    能：获取报告图像总数
  Procedure p_Getreportimagecount
  (
    Val         Out t_Refcur,
    查询条件_In In Varchar2
  );

  --5、功    能：获取报告图像数据
  Procedure p_Getreportimagedata
  (
    Val         Out t_Refcur,
    查询条件_In In Varchar2,
    开始位置_In In Number,
    结束位置_In In Number
  );

  --6、功    能：获取预览图像总数
  Procedure p_Getstudyimagecount
  (
    Val         Out t_Refcur,
    查询条件_In In Varchar2,
    是否临时_In In Number := 0
  );

  --7、功    能：获取预览图像数据
  Procedure p_Getstudyimagedata
  (
    Val         Out t_Refcur,
    查询方式_In In Varchar2,
    查询条件_In In Varchar2,
    开始位置_In In Number,
    结束位置_In In Number,
    是否临时_In In Number
  );

  --8、功能：获取临时图像序列
  Procedure p_Get_Tempimageseries
  (
    Val         Out t_Refcur,
    时间范围_In In Number,
    姓名_In     In 影像临时记录.姓名%Type := Null
  );

  --9、功能;获取图像备注
  Procedure p_Get_Normalnote(Val Out t_Refcur);

  --10、功能：插入常用图像备注
  Procedure p_Insert_Normalnote
  (
    Note_In In 影像字典内容.名称%Type,
    Code_In 影像字典内容.简码%Type
  );

  --11、功能：修改常用图像备注
  Procedure p_Edit_Normalnote
  (
    Note_In In 影像字典内容.名称%Type,
    Num_In  影像字典内容.编号%Type
  );

  --12、功能：删除常用图像备注
  Procedure p_Del_Normalnote(Num_In 影像字典内容.编号%Type);

  --13、功能：获取备注的下一个编码
  Procedure p_Get_Normalnum(Val Out t_Refcur);
  --14、功能：获取插件ID
  Procedure p_Get_Plugid
  (
    Val     Out t_Refcur,
    类名_In In 影像报告插件.类名%Type
  );

  --15、功能：插入编辑器字体参数
  Procedure p_Setfontparam
  (
    Font_In Nvarchar2,
    User_In Nvarchar2
  );

  --16、功能：获取编辑器字体参数
  Procedure p_Getfontparam
  (
    Val     Out t_Refcur,
    User_In Nvarchar2
  );

  --17、功能：插入编辑器窗体参数
  Procedure p_Setformparam
  (
    Form_In Nvarchar2,
    User_In Nvarchar2
  );

  --18、功能：获取编辑器字体参数
  Procedure p_Getformparam
  (
    Val     Out t_Refcur,
    User_In Nvarchar2
  );

  --19、功能：根据图像UID获取检查信息
  Procedure p_Getstudyinfobyimageuid
  (
    Val        Out t_Refcur,
    医嘱id_In  In 影像检查记录.医嘱id%Type,
    图像uid_In In 影像检查图象.图像uid%Type
  );

  --20、功能：根据检查UID获取FTP信息
  Procedure p_Getftpinfobystudyuid
  (
    Val        Out t_Refcur,
    检查uid_In In 影像检查记录.检查uid%Type
  );

  --21、功能：根据科室ID获取FTP信息
  Procedure p_Getftpinfobydeptid
  (
    Val       Out t_Refcur,
    科室id_In In 影像流程参数.科室id%Type
  );

  --22、功能：根据医嘱ID获取FTP信息
  Procedure p_Getftpinfobyadvicetid
  (
    Val       Out t_Refcur,
    医嘱id_In In 影像检查记录.医嘱id%Type
  );

  --23、功能：获取检查UID
  Procedure p_Getstudyuid
  (
    Val        Out t_Refcur,
    检查uid_In In 影像检查记录.检查uid%Type
  );

  --24、功能：获取序列UID
  Procedure p_Getseriesuid
  (
    Val        Out t_Refcur,
    序列uid_In In 影像检查序列.序列uid%Type
  );

  --25、功能：根据设备号获取设备信息
  Procedure p_Getdeviceinfo
  (
    Val       Out t_Refcur,
    设备号_In In 影像设备目录.设备号%Type
  );

  --26、获取医技站存储设备号
  Procedure p_Getdeviceidbyadviceid
  (
    Val       Out t_Refcur,
    医嘱id_In In 病人医嘱发送.医嘱id%Type
  );
End b_Pacs_Rptpluginoriginal;

/

Create Or Replace Package Body b_Pacs_Rptpluginoriginal Is

  --1、功    能：获取历史报告记录
  Procedure p_Getreporthistory
  (
    Val                   Out t_Refcur,
    医嘱id_In             In 病人医嘱记录.Id%Type,
    人员id_In             In 部门人员.人员id%Type,
    当前科室id_In         In 部门人员.部门id%Type,
    查看其他科历史报告_In In Number := 0
  ) Is
    Strsql     Varchar2(4000);
    Strsqlback Varchar2(4000);
    Strfilter  Varchar2(400);
  Begin
    If 查看其他科历史报告_In = 1 Then
      Strfilter := ' ';
    Else
      Strfilter := ' And c.执行科室id+0 in (select 部门id from 部门人员 where 人员id = ' || 人员id_In ||
                   ' union all select to_Number(' || 当前科室id_In || ') from dual) ';
    End If;
  
    Strsql := 'Select 2 as 报告类型, f.编码' || '||''-''||' || 'f.名称 As 科室名称, c.Id As 医嘱id, a.影像类别 as 类别,b.创建人 as 报告人,' ||
              'to_char(b.创建时间,''yyyy-mm-dd hh24:mi:ss'') as 创建时间,b.文档标题 报告名称, c.医嘱内容, TO_CHAR(RAWTOHEX(b.id)) 报告ID ' ||
              'From 影像检查记录 A, 影像报告记录 B, 病人医嘱记录 C, 影像检查记录 D, 病人医嘱记录 E, 部门表 F ' ||
              'Where a.医嘱id = b.医嘱id And d.医嘱id = e.Id And e.Id =' || 医嘱id_In ||
              ' And e.执行科室ID = F.ID And b.医嘱id = c.Id And ' ||
              '(c.病人id = e.病人id Or a.关联id = d.关联id) And c.相关id Is Null ' || Strfilter || ' union all ' ||
              'Select 1 as 报告类型, g.编码' || '||''-''||' || 'g.名称 As 科室名称, c.Id As 医嘱id, a.影像类别 as 类别, a.报告人, ' ||
              'to_char(f.创建时间,''yyyy-mm-dd hh24:mi:ss'') as 创建时间, a.影像类别||''报告'' 报告名称, c.医嘱内容,TO_CHAR( b.病历id) as 报告ID ' ||
              'From 影像检查记录 A, 病人医嘱报告 B, 病人医嘱记录 C, 影像检查记录 D, 病人医嘱记录 E, 电子病历记录 F, 部门表 G ' ||
              'Where a.医嘱id = b.医嘱id And d.医嘱id = e.Id And e.Id = ' || 医嘱id_In ||
              ' And e.执行科室ID = g.ID And b.医嘱id = c.Id And b.病历ID Is Not Null And ' ||
              '(c.病人id = e.病人id Or a.关联id = d.关联id) And c.相关id Is Null And b.病历id = f.id ' || Strfilter;
  
    Strsqlback := Strsql;
    Strsqlback := Replace(Strsqlback, '影像检查记录', 'H影像检查记录');
    Strsqlback := Replace(Strsqlback, '病人医嘱报告', 'H病人医嘱报告');
    Strsqlback := Replace(Strsqlback, '病人医嘱记录', 'H病人医嘱记录');
  
    Strsql := Strsql || ' UNION ALL ' || Strsqlback || ' Order By 创建时间 Asc';
  
    Open Val For Strsql;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Getreporthistory;

  --2、功    能：获取对应报告内容
  Procedure p_Getreportcontent
  (
    Val           Out t_Refcur,
    报告id_In     Varchar2,
    Editortype_In Number := 0 --0:电子病历编辑器，1--PACS报告编辑器，2--报告文档编辑器
  ) Is
    Strsql Varchar2(1000);
  Begin
    If Editortype_In = 1 Then
      Strsql := 'Select a.内容文本 As 标题, b.对象属性, b.内容文本 As 正文,b.开始版 as 版本 From 电子病历内容 a,电子病历内容 b ' || 'Where a.文件id = ' ||
                报告id_In || ' And a.对象类型 = 3 And a.Id = b.父ID And b.对象类型 = 2 and b.终止版=0 ';
    Elsif Editortype_In = 0 Then
      Strsql := 'select 内容 from 电子病历格式 where 文件ID=' || 报告id_In;
    Else
      Strsql := 'Select 报告内容 As 内容 From 影像报告记录 Where ID=HexToRaw(''' || 报告id_In || ''')';
    End If;
  
    Open Val For Strsql;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Getreportcontent;

  --3、功    能：根据医嘱ID获取检查信息
  Procedure p_Getstudyinfobyadviceid
  (
    Val       Out t_Refcur,
    医嘱id_In In 影像检查记录.医嘱id%Type
  ) Is
    Strsql Varchar2(100);
  Begin
    Strsql := 'Select 检查UID,报告图象,接收日期,检查号,姓名,性别,年龄 from 影像检查记录 where 医嘱ID =' || 医嘱id_In;
    Open Val For Strsql;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Getstudyinfobyadviceid;

  --4、功    能：获取报告图像总数
  Procedure p_Getreportimagecount
  (
    Val         Out t_Refcur,
    查询条件_In In Varchar2
  ) Is
  Begin
    Open Val For
      Select Count(b.Column_Value) 返回值
      From 影像检查记录 a, Table(Cast(f_Str2list(Replace(a.报告图象, ';', ',')) As Zltools.t_Strlist)) b
      Where 医嘱id = 查询条件_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Getreportimagecount;

  --5、功    能：获取报告图像数据
  Procedure p_Getreportimagedata
  (
    Val         Out t_Refcur,
    查询条件_In In Varchar2,
    开始位置_In In Number,
    结束位置_In In Number
  ) Is
  Begin
    Open Val For
      Select *
      From (Select Rownum As 顺序号, Rownum As 图像号, b.Ftp用户名 As User1, b.Ftp密码 As Pwd1, b.Ip地址 As Host1,
                    '/' || b.Ftp目录 || '/' As Root1,
                    Decode(a.接收日期, Null, '', To_Char(a.接收日期, 'YYYYMMDD') || '/') || a.检查uid || '/' ||
                     Replace(Trim(d.Column_Value), '.jpg', '') As Url, b.设备号 As 设备号1, c.Ftp用户名 As User2, c.Ftp密码 As Pwd2,
                    c.Ip地址 As Host2, '/' || c.Ftp目录 || '/' As Root2, c.设备号 As 设备号2,
                    Replace(Trim(d.Column_Value), '.jpg', '') As 图像uid, a.检查uid, '' 序列uid, 0 动态图, '' 编码名称, '' 采集时间,
                    '' 录制长度, '' 报告图
             From 影像检查记录 a, 影像设备目录 b, 影像设备目录 c, Table(Cast(f_Str2list(Replace(a.报告图象, ';', ',')) As Zltools.t_Strlist)) d
             Where a.位置一 = b.设备号(+)
             And a.位置二 = c.设备号(+)
             And a.医嘱id = 查询条件_In)
      Where 顺序号 >= 开始位置_In
      And 顺序号 <= 结束位置_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Getreportimagedata;

  --6、功    能：获取预览图像总数
  Procedure p_Getstudyimagecount
  (
    Val         Out t_Refcur,
    查询条件_In In Varchar2,
    是否临时_In In Number := 0
  ) Is
    Strsql Varchar2(2000);
  Begin
    If 是否临时_In = 0 Then
      Strsql := 'select T1.返回值+T2.返回值 as 返回值 from ' || '(select count(1) as 返回值 from 影像检查图象 a, 影像检查序列 b, 影像检查记录 c ' ||
                'where a.序列UID=b.序列UID and b.检查UID=c.检查UID and c.医嘱ID=''' || 查询条件_In || ''') T1,' ||
                '(select count(1) as 返回值 from H影像检查图象 a, H影像检查序列 b, 影像检查记录 c ' ||
                'where a.序列UID=b.序列UID and b.检查UID=c.检查UID and c.医嘱ID=''' || 查询条件_In || ''') T2';
    Else
      Strsql := 'select count(1)  as 返回值 from 影像临时图象  where  序列UID=''' || 查询条件_In || '''';
    End If;
  
    Open Val For Strsql;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Getstudyimagecount;

  --7、功    能：获取预览图像数据
  Procedure p_Getstudyimagedata
  (
    Val         Out t_Refcur,
    查询方式_In In Varchar2,
    查询条件_In In Varchar2,
    开始位置_In In Number,
    结束位置_In In Number,
    是否临时_In In Number
  ) Is
    Strsql    Varchar2(2000);
    Strsql2   Varchar2(2000);
    Strfilter Varchar2(100);
    No_Column Exception;
    Pragma Exception_Init(No_Column, -00904);
  Begin
    If 查询方式_In = 0 Then
      Strfilter := 'and c.医嘱ID=''' || 查询条件_In || '''';
    Elsif 查询方式_In = 1 Then
      Strfilter := 'and B.序列UID=''' || 查询条件_In || '''';
    Else
      Strfilter := 'and A.图像UID=''' || 查询条件_In || '''';
    End If;
  
    Strsql := 'Select * from (Select rownum as 顺序号, T.* from(' ||
              'Select A.图像号,D.FTP用户名 As User1,D.FTP密码 As Pwd1,D.IP地址 As Host1,''/''||D.Ftp目录||''/'' As Root1,' ||
              'Decode(C.接收日期,Null,'''',to_Char(C.接收日期,''YYYYMMDD'')||''/'')||C.检查UID||''/''||A.图像UID As URL,d.设备号 as 设备号1,' ||
              'E.FTP用户名 As User2,E.FTP密码 As Pwd2,E.IP地址 As Host2,''/''||E.Ftp目录||''/'' As Root2,' ||
              'e.设备号 as 设备号2, A.图像UID,C.检查UID,B.序列UID,A.动态图,A.编码名称,A.采集时间, A.录制长度,A.报告图 ' ||
              'From 影像检查图象 A,影像检查序列 B,影像检查记录 C,影像设备目录 D,影像设备目录 E ' ||
              'Where A.序列UID=B.序列UID And B.检查UID=C.检查UID And C.位置一=D.设备号(+) And C.位置二=E.设备号(+) ' || Strfilter || ' ' ||
              'Order by 序列UID, 图像号) T ) ' || 'Where 顺序号>=' || 开始位置_In || ' and 顺序号<=' || 结束位置_In || '';
  
    Strsql2 := 'Select * from (Select rownum as 顺序号, T.* from(' ||
               'Select A.图像号,D.FTP用户名 As User1,D.FTP密码 As Pwd1,D.IP地址 As Host1,''/''||D.Ftp目录||''/'' As Root1,' ||
               'Decode(C.接收日期,Null,'''',to_Char(C.接收日期,''YYYYMMDD'')||''/'')||C.检查UID||''/''||A.图像UID As URL,d.设备号 as 设备号1,' ||
               'E.FTP用户名 As User2,E.FTP密码 As Pwd2,E.IP地址 As Host2,''/''||E.Ftp目录||''/'' As Root2,' ||
               'e.设备号 as 设备号2, A.图像UID,C.检查UID,B.序列UID,A.动态图,A.编码名称,A.采集时间, A.录制长度 ' ||
               'From 影像检查图象 A,影像检查序列 B,影像检查记录 C,影像设备目录 D,影像设备目录 E ' ||
               'Where A.序列UID=B.序列UID And B.检查UID=C.检查UID And C.位置一=D.设备号(+) And C.位置二=E.设备号(+) ' || Strfilter || ' ' ||
               'Order by 序列UID, 图像号) T ) ' || 'Where 顺序号>=' || 开始位置_In || ' and 顺序号<=' || 结束位置_In || '';
  
    If 是否临时_In = 1 Then
      Strsql  := Replace(Strsql, '影像检查', '影像临时');
      Strsql2 := Replace(Strsql2, '影像检查', '影像临时');
    End If;
  
    Begin
      Open Val For Strsql;
    Exception
      When No_Column Then
        --兼容处理，10.36新增加 报告图 字段，问题号 103996
        Open Val For Strsql2;
    End;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Getstudyimagedata;

  --8、功能：获取临时图像序列
  Procedure p_Get_Tempimageseries
  (
    Val         Out t_Refcur,
    时间范围_In In Number,
    姓名_In     In 影像临时记录.姓名%Type := Null
  ) As
  Begin
    If 姓名_In Is Null Then
      Open Val For
        Select b.序列uid, a.姓名, a.检查号 As 序号, a.接收日期
        From 影像临时记录 a, 影像临时序列 b
        Where a.检查uid = b.检查uid
        And a.接收日期 Between Sysdate - 时间范围_In And Sysdate
        Order By 序号;
    Else
      Open Val For
        Select b.序列uid, a.姓名, a.检查号 As 序号, a.接收日期
        From 影像临时记录 a, 影像临时序列 b
        Where a.检查uid = b.检查uid
        And a.接收日期 Between Sysdate - 时间范围_In And Sysdate
        And a.姓名 = 姓名_In
        Order By 序号;
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --9、功能：获取图像备注
  Procedure p_Get_Normalnote(Val Out t_Refcur) As
  Begin
    Open Val For
      Select b.编号 As 编号, b.名称 As 名称
      From 影像字典清单 a, 影像字典内容 b
      Where a.Id = b.字典id
      And a.名称 = '影像图像备注';
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --10、功能：插入常用图像备注
  Procedure p_Insert_Normalnote
  (
    Note_In In 影像字典内容.名称%Type,
    Code_In 影像字典内容.简码%Type
  ) As
    n_Num         Number;
    Dictionary_Id Varchar2(36);
  Begin
    Select Id Into Dictionary_Id From 影像字典清单 Where 说明 = '影像图像备注';
    Select Decode(Max(To_Number(编号)), Null, 0, Max(To_Number(编号)))
    Into n_Num
    From 影像字典内容
    Where 字典id = Dictionary_Id;
    n_Num := n_Num + 1;
    Insert Into 影像字典内容
      (字典id, 编号, 名称, 说明)
    Values
      (Dictionary_Id, To_Char(n_Num), Note_In, '影像图像备注');
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Insert_Normalnote;

  --11、功能：修改常用图像备注
  Procedure p_Edit_Normalnote
  (
    Note_In In 影像字典内容.名称%Type,
    Num_In  影像字典内容.编号%Type
  ) As
    Dictionary_Id Varchar2(36);
  Begin
    Select Id Into Dictionary_Id From 影像字典清单 Where 说明 = '影像图像备注';
    Update 影像字典内容 t
    Set t.名称 = Note_In
    Where t.字典id = Dictionary_Id
    And t.编号 = Num_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Normalnote;

  --12、功能：删除常用图像备注
  Procedure p_Del_Normalnote(Num_In 影像字典内容.编号%Type) As
    Dictionary_Id Varchar2(36);
  Begin
    Select Id Into Dictionary_Id From 影像字典清单 Where 说明 = '影像图像备注';
    Delete 影像字典内容 t
    Where t.字典id = Dictionary_Id
    And t.编号 = Num_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Del_Normalnote;

  --13、功能：获取备注的下一个编码
  Procedure p_Get_Normalnum(Val Out t_Refcur) As
    Dictionary_Id Varchar2(36);
  Begin
    Select Id Into Dictionary_Id From 影像字典清单 Where 说明 = '影像图像备注';
    Open Val For
      Select Decode(Max(To_Number(编号)), Null, 1, Max(To_Number(编号) + 1)) 编号
      From 影像字典内容 t
      Where t.字典id = Dictionary_Id;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Normalnum;

  --14、功能：获取插件ID
  Procedure p_Get_Plugid
  (
    Val     Out t_Refcur,
    类名_In In 影像报告插件.类名%Type
  ) Is
  Begin
    Open Val For
      Select Rawtohex(Id) Id From 影像报告插件 Where 类名 = 类名_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Plugid;

  --15、功能：插入编辑器字体参数
  Procedure p_Setfontparam
  (
    Font_In Nvarchar2,
    User_In Nvarchar2
  ) As
    m_Id     Nvarchar2(36);
    Numcount Int;
  Begin
    Select Rawtohex(Id)
    Into m_Id
    From 影像参数说明
    Where 模块 = 'ImageEditor'
    And 参数名 = '字体设置';
    Select Count(*)
    Into Numcount
    From 影像参数取值 t
    Where t.参数id = m_Id
    And t.参数标识 = User_In;
    If Numcount > 0 Then
      Update 影像参数取值 a
      Set a.参数值 = Font_In
      Where a.参数标识 = User_In
      And a.参数id = m_Id;
    Else
      Insert Into 影像参数取值 a (Id, 参数id, 参数标识, 参数值) Values (Sys_Guid(), m_Id, User_In, Font_In);
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Setfontparam;

  --16、功能：获取编辑器字体参数
  Procedure p_Getfontparam
  (
    Val     Out t_Refcur,
    User_In Nvarchar2
  ) As
    m_Id Nvarchar2(36);
  Begin
    Select Rawtohex(Id)
    Into m_Id
    From 影像参数说明
    Where 模块 = 'ImageEditor'
    And 参数名 = '字体设置';
    Open Val For
      Select a.参数值
      From 影像参数取值 a
      Where a.参数id = m_Id
      And a.参数标识 = User_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Getfontparam;

  --17、功能：插入编辑器窗体参数
  Procedure p_Setformparam
  (
    Form_In Nvarchar2,
    User_In Nvarchar2
  ) As
    m_Id     Nvarchar2(36);
    Numcount Int;
  Begin
    Select Rawtohex(Id)
    Into m_Id
    From 影像参数说明
    Where 模块 = 'ImageEditor'
    And 参数名 = '窗口设置';
    Select Count(*)
    Into Numcount
    From 影像参数取值 t
    Where t.参数id = m_Id
    And t.参数标识 = User_In;
    If Numcount > 0 Then
      Update 影像参数取值 a
      Set a.参数值 = Form_In
      Where a.参数标识 = User_In
      And a.参数id = m_Id;
    Else
      Insert Into 影像参数取值 a (Id, 参数id, 参数标识, 参数值) Values (Sys_Guid(), m_Id, User_In, Form_In);
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Setformparam;

  --18、功能：获取编辑器字体参数
  Procedure p_Getformparam
  (
    Val     Out t_Refcur,
    User_In Nvarchar2
  ) As
    m_Id Nvarchar2(36);
  Begin
    Select Rawtohex(Id)
    Into m_Id
    From 影像参数说明
    Where 模块 = 'ImageEditor'
    And 参数名 = '窗口设置';
    Open Val For
      Select a.参数值
      From 影像参数取值 a
      Where a.参数id = m_Id
      And a.参数标识 = User_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Getformparam;

  --19、功能：根据图像UID获取检查信息
  Procedure p_Getstudyinfobyimageuid
  (
    Val        Out t_Refcur,
    医嘱id_In  In 影像检查记录.医嘱id%Type,
    图像uid_In In 影像检查图象.图像uid%Type
  ) As
  Begin
    Open Val For
      Select d.检查uid
      From 影像检查图象 a, 影像检查序列 b, 影像检查记录 c, 影像临时序列 d
      Where c.医嘱id = 医嘱id_In
      And a.图像uid = 图像uid_In
      And a.序列uid = b.序列uid
      And b.检查uid = c.检查uid
      And a.序列uid = d.序列uid;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Getstudyinfobyimageuid;

  --20、功能：根据检查UID获取FTP信息
  Procedure p_Getftpinfobystudyuid
  (
    Val        Out t_Refcur,
    检查uid_In In 影像检查记录.检查uid%Type
  ) As
  Begin
    Open Val For
      Select d.Ftp用户名 As Ftpuser, d.Ftp密码 As Ftppwd, c.位置一, c.位置二, c.位置三, c.接收日期, d.Ip地址 As Host,
             '/' || d.Ftp目录 || '/' As Root,
             Decode(c.接收日期, Null, '', To_Char(c.接收日期, 'YYYYMMDD') || '/') || c.检查uid As Url
      From 影像检查记录 c, 影像设备目录 d
      Where Decode(c.位置一, Null, c.位置二, c.位置一) = d.设备号(+)
      And c.检查uid = 检查uid_In
      Union All
      Select d.Ftp用户名 As Ftpuser, d.Ftp密码 As Ftppwd, c.位置一, c.位置二, c.位置三, c.接收日期, d.Ip地址 As Host,
             '/' || d.Ftp目录 || '/' As Root,
             Decode(c.接收日期, Null, '', To_Char(c.接收日期, 'YYYYMMDD') || '/') || c.检查uid As Url
      From 影像临时记录 c, 影像设备目录 d
      Where Decode(c.位置一, Null, c.位置二, c.位置一) = d.设备号(+)
      And c.检查uid = 检查uid_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Getftpinfobystudyuid;

  --21、功能：根据科室ID获取FTP信息
  Procedure p_Getftpinfobydeptid
  (
    Val       Out t_Refcur,
    科室id_In In 影像流程参数.科室id%Type
  ) As
  Begin
    Open Val For
      Select a.设备号, a.Ip地址, a.Ftp用户名, a.Ftp密码
      From 影像设备目录 a, 影像流程参数 b
      Where a.设备号 = b.参数值
      And b.参数名 = '存储设备号'
      And b.科室id = 科室id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Getftpinfobydeptid;

  --22、功能：根据医嘱ID获取FTP信息
  Procedure p_Getftpinfobyadvicetid
  (
    Val       Out t_Refcur,
    医嘱id_In In 影像检查记录.医嘱id%Type
  ) As
  Begin
    Open Val For
      Select a.设备号, a.Ip地址, a.Ftp用户名, a.Ftp密码
      From 影像设备目录 a, 影像检查记录 b
      Where b.位置一 = a.设备号(+)
      And b.医嘱id = 医嘱id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Getftpinfobyadvicetid;

  --23、功能：获取检查UID
  Procedure p_Getstudyuid
  (
    Val        Out t_Refcur,
    检查uid_In In 影像检查记录.检查uid%Type
  ) As
  Begin
    Open Val For
      Select 检查uid
      From 影像检查记录
      Where 检查uid = 检查uid_In
      Union All
      Select 检查uid
      From 影像临时记录
      Where 检查uid = 检查uid_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Getstudyuid;

  --24、功能：获取序列UID
  Procedure p_Getseriesuid
  (
    Val        Out t_Refcur,
    序列uid_In In 影像检查序列.序列uid%Type
  ) As
  Begin
    Open Val For
      Select 序列uid
      From 影像检查序列
      Where 序列uid = 序列uid_In
      Union All
      Select 序列uid
      From 影像临时序列
      Where 序列uid = 序列uid_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Getseriesuid;

  --25、功能：根据设备号获取设备信息
  Procedure p_Getdeviceinfo
  (
    Val       Out t_Refcur,
    设备号_In In 影像设备目录.设备号%Type
  ) As
  Begin
    Open Val For
      Select 设备号, 设备名, '/' || Decode(Ftp目录, Null, '', Ftp目录 || '/') As Url, Ftp用户名, Ftp密码, Ip地址
      From 影像设备目录
      Where 类型 = 1
      And 设备号 = 设备号_In
      And Nvl(状态, 0) = 1;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Getdeviceinfo;

  --26、获取医技站存储设备号
  Procedure p_Getdeviceidbyadviceid
  (
    Val       Out t_Refcur,
    医嘱id_In In 病人医嘱发送.医嘱id%Type
  ) As
  Begin
    Open Val For
      Select d.参数值
      From 医技执行房间 a, 病人医嘱发送 b, 影像dicom服务对 c, 影像dicom服务参数 d
      Where a.科室id = b.执行部门id
      And a.执行间 = b.执行间
      And a.检查设备 = c.设备号
      And c.服务功能 = '图像接收'
      And c.服务id = d.服务id
      And d.参数名称 = '存储设备'
      And b.医嘱id = 医嘱id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Getdeviceidbyadviceid;
End b_Pacs_Rptpluginoriginal;

/

--103996:黄捷,2017-06-12,报告图增加标记
Create Or Replace Procedure Zl_影像检查_设置报告图
(
  图像uid_In 影像检查图象.图像uid%Type,
  Actiontype Number
) Is

Begin
  -- ActionType : 1 - 加入报告图；2 - 取消加入报告图
  If Actiontype = 1 Then
    Update 影像检查图象
    Set 报告图 = 0
    Where 图像uid = 图像uid_In
    And 报告图 Is Null;
  Else
    Update 影像检查图象
    Set 报告图 = Null
    Where 图像uid = 图像uid_In
    And 报告图 = 0;
  End If;

Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_影像检查_设置报告图;
/

--103996:黄捷,2017-06-12,报告图增加标记
Create Or Replace Procedure Zl_影像检查图象_报告图(医嘱id_In 病人医嘱记录.Id %Type) Is

  Cursor c_Images Is
    Select a.Id, a.对象属性
    From 电子病历内容 a
    Where 父id In (Select Id
                  From 电子病历内容 a, 病人医嘱报告 b
                  Where a.文件id = b.病历id
                  And b.医嘱id = 医嘱id_In
                  And a.对象类型 = 3
                  And Substr(a.对象属性, Instr(a.对象属性, ';', 1, 18) + 1, 1) = '2'
                  And 终止版 = 0)
    And a.终止版 = 0
    And a.对象类型 = 5;
  r_Images c_Images%Rowtype;

  v_对象属性 电子病历内容.对象属性%Type;
  v_图像名   影像检查图象.图像uid%Type;
  v_Length   Number;
Begin
  Update 影像检查图象
  Set 报告图 = Null
  Where 序列uid In (Select 序列uid
                  From 影像检查序列 a, 影像检查记录 b
                  Where a.检查uid = b.检查uid
                  And b.医嘱id = 医嘱id_In);

  For r_Images In c_Images Loop
    v_对象属性 := r_Images.对象属性;
    v_Length   := Instr(v_对象属性, ';', 1, 12) - Instr(v_对象属性, ';', 1, 11);
    If v_Length > 0 Then
      v_图像名 := Substr(v_对象属性, Instr(v_对象属性, ';', 1, 11) + 1, v_Length - 5);
    End If;
    Update 影像检查图象 Set 报告图 = Nvl(报告图, 0) + 1 Where 图像uid = v_图像名;
  End Loop;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_影像检查图象_报告图;
/

--109174:李南春,2017-05-16,删除医疗卡同时删除对应特定项目
Create Or Replace Procedure Zl_医疗卡类别_Delete(Id_In In 医疗卡类别.ID%Type) Is
  v_Err_Msg Varchar2(200);
  Err_Item Exception;
  n_是否启用 Number;
  n_是否固定 Number;
  v_特定项目 Varchar2(20);
Begin
  Begin
    Select 是否启用, 是否固定, 特定项目 Into n_是否启用, n_是否固定, v_特定项目 From 医疗卡类别 Where ID = Id_In;
  Exception
    When Others Then
      n_是否启用 := -1;
  End;
  If Nvl(n_是否启用, 0) = -1 Then
    v_Err_Msg := '[ZLSOFT]医疗卡类别可能被人他人删除，不能再次删除![ZLSOFT]';
    Raise Err_Item;
  End If;
  If Nvl(n_是否启用, 0) = 0 Then
    v_Err_Msg := '[ZLSOFT]医疗卡类别已经被停用，不能删除![ZLSOFT]';
    Raise Err_Item;
  End If;
  If Nvl(n_是否固定, 0) = 1 Then
    v_Err_Msg := '[ZLSOFT]医疗卡类别是系统固定的，不能删除![ZLSOFT]';
    Raise Err_Item;
  End If;

  Delete From 医疗卡类别 Where ID = Id_In And Nvl(是否启用, 0) = 1 And Nvl(是否固定, 0) = 0;
  If Sql%NotFound Then
    v_Err_Msg := '[ZLSOFT]医疗卡类别可能被人他人删除，不能再次删除![ZLSOFT]';
    Raise Err_Item;
  End If;
  
  IF Not v_特定项目 is Null then
    Delete From 收费特定项目 Where 特定项目 = v_特定项目;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_医疗卡类别_Delete;
/

--108046:刘尔旋,2017-05-15,费用审核管理取消审核出错问题
Create Or Replace Procedure Zl_费用审核记录_Delete
(
  费用id_In In 费用审核记录.费用id%Type,
  性质_In   In 费用审核记录.性质%Type
) Is
  v_Err_Msg Varchar2(100);
  Err_Item Exception;
  n_Count Number(4);
  v_No    门诊费用记录.No%Type;
Begin
  Select Count(a.Id), Max(a.No)
  Into n_Count, v_No
  From 门诊费用记录 A, (Select Mod(记录性质, 10) As 记录性质, NO, 序号 From 门诊费用记录 Where ID = 费用id_In) B
  Where a.No = b.No And Mod(a.记录性质, 10) = b.记录性质 And a.序号 = b.序号
  Group By a.No, Mod(a.记录性质, 10), a.序号
  Having Sum(a.数次) <> 0 Or Sum(a.实收金额) <> 0;
  If n_Count = 0 Then
    v_Err_Msg := '[ZLSOFT]单据『' || v_No || '』可能因并发原因,已经被他人转出或退费,不能取消审核![ZLSOFT]';
    Raise Err_Item;
  End If;
  Delete From 费用审核记录 Where 费用id = 费用id_In And 性质 = 性质_In;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_费用审核记录_Delete;
/

--99878:冉俊明,2017-05-26,同一收费项目多个价格管理
--109116:刘尔旋,2017-05-15,挂号医保校正处理误差费
Create Or Replace Procedure Zl_病人结算记录_Update
(
  结帐id_In        病人预交记录.结帐id%Type,
  保险结算_In      Varchar2, --"结算方式|结算金额||....."
  结帐_In          Number := 0,
  缺省结算方式_In  Varchar2 := Null,
  缺省冲预交_In    Number := 0, --0-用现金缴款,1:剩于款项用冲预交支付(门诊预交),2-剩于款项用冲预交支付(住院预交)
  卡类别id_In      病人预交记录.卡类别id%Type := Null,
  结算卡序号_In    病人预交记录.结算卡序号%Type := Null,
  卡号_In          病人预交记录.卡号%Type := Null,
  交易流水号_In    病人预交记录.交易流水号%Type := Null,
  交易说明_In      病人预交记录.交易说明%Type := Null,
  合作单位_In      病人预交记录.合作单位%Type := Null,
  冲预交病人ids_In Varchar2 := Null,
  仅修正医保_In    Number := 0
) As
  --该游标为要删除的由费用记录产生的结算记录

  Cursor c_Del Is
    Select a.Id, a.记录性质, a.冲预交, a.结算方式, b.性质, a.预交类别
    From 病人预交记录 A, 结算方式 B
    Where a.结算方式 = b.名称 And a.结帐id = 结帐id_In;

  Cursor c_Del_医保 Is
    Select a.Id, a.记录性质, a.冲预交, a.结算方式, b.性质, a.预交类别
    From 病人预交记录 A, 结算方式 B
    Where a.结算方式 = b.名称 And b.性质 In (3, 4) And a.结帐id = 结帐id_In;

  --相关信息
  v_No         病人预交记录.No%Type;
  v_病人id     住院费用记录.病人id%Type;
  v_主页id     住院费用记录.主页id%Type;
  v_发生时间   住院费用记录.发生时间%Type;
  v_登记时间   住院费用记录.登记时间%Type;
  v_操作员编号 住院费用记录.操作员编号%Type;
  v_操作员姓名 住院费用记录.操作员姓名%Type;

  v_冲预交病人ids Varchar2(4000);

  --本次结算变量
  v_金额合计 病人预交记录.冲预交%Type;

  --保险结算
  v_保险结算 Varchar2(255);
  v_当前结算 Varchar2(50);
  v_现金结算 病人预交记录.结算方式%Type;
  v_结算方式 病人预交记录.结算方式%Type;
  v_结算金额 病人预交记录.冲预交%Type;

  v_记录性质 病人预交记录.记录性质%Type;
  v_缺省     病人预交记录.结算方式%Type;

  --分币处理及误差变量
  v_现金金额   病人预交记录.冲预交%Type;
  v_Cashcented 病人预交记录.冲预交%Type;
  v_误差金额   病人预交记录.冲预交%Type;
  v_费用id     住院费用记录.Id%Type;
  v_序号       住院费用记录.序号%Type;
  v_收费类别   住院费用记录.收费类别%Type;
  v_收费细目id 住院费用记录.收费细目id%Type;
  v_收入项目id 住院费用记录.收入项目id%Type;
  v_收据费目   住院费用记录.收据费目%Type;
  n_Noexists   Number(3);
  n_医疗小组id 住院费用记录.医疗小组id%Type;
  n_结算序号   病人预交记录.结算序号%Type;
  n_费用状态   门诊费用记录.费用状态%Type;
  n_预交金额   病人预交记录.金额%Type;
  n_当前金额   病人预交记录.金额%Type;
  v_误差项     结算方式.名称%Type;

  --临时变量
  Err_Item Exception;
  v_Err_Msg  Varchar2(255);
  n_组id     财务缴款分组.Id%Type;
  n_执行状态 门诊费用记录.执行状态%Type;
Begin
  --如果缺省结算方式为空，则取现金结算方式
  If 缺省结算方式_In Is Null Then
    Begin
      Select 名称 Into v_缺省 From 结算方式 Where 性质 = 1 And Rownum < 2;
    Exception
      When Others Then
        v_缺省 := '现金';
    End;
  Else
    v_缺省 := 缺省结算方式_In;
  End If;

  --取得本次结算的相关信息
  If Nvl(结帐_In, 0) = 1 Then
    Select NO, 病人id, 收费时间, 操作员编号, 操作员姓名, 缴款组id, 0
    Into v_No, v_病人id, v_登记时间, v_操作员编号, v_操作员姓名, n_组id, n_执行状态
    From 病人结帐记录
    Where ID = 结帐id_In;
  Else
    Begin
      n_Noexists := 0;
      Select NO, 病人id, 登记时间, 操作员编号, 操作员姓名, 缴款组id, 执行状态, 费用状态
      Into v_No, v_病人id, v_登记时间, v_操作员编号, v_操作员姓名, n_组id, n_执行状态, n_费用状态
      From 门诊费用记录
      Where 结帐id = 结帐id_In And Rownum < 2;
    Exception
      When Others Then
        n_Noexists := 1;
    End;
    If n_Noexists = 1 Then
      --费用记录不存在，从补充记录中找
      Select NO, 病人id, 登记时间, 操作员编号, 操作员姓名, 缴款组id, 费用状态
      Into v_No, v_病人id, v_登记时间, v_操作员编号, v_操作员姓名, n_组id, n_费用状态
      From 费用补充记录
      Where 结算id = 结帐id_In And Rownum < 2;
    End If;
    If Nvl(n_费用状态, 0) = 1 Then
      --异常单据为空:
      v_缺省 := Null;
    End If;
  
    Begin
      --20051027 陈东
      Select 记录性质
      Into v_记录性质
      From 病人预交记录
      Where 结帐id = 结帐id_In And Rownum = 1 And Mod(记录性质, 10) <> 1;
    Exception
      When Others Then
        v_记录性质 := -1;
    End;
    If v_记录性质 = -1 Then
      Begin
        Select Decode(记录性质, 1, 3, 11, 3, 4, 4, 记录性质)
        Into v_记录性质
        From 门诊费用记录
        Where 结帐id = 结帐id_In And Rownum = 1;
      Exception
        When Others Then
          --可能是卡费
          Select 记录性质 Into v_记录性质 From 住院费用记录 Where 结帐id = 结帐id_In And Rownum = 1;
      End;
    End If;
  End If;

  If Nvl(v_病人id, 0) <> 0 And Nvl(结帐_In, 0) = 1 Then
    Select 主页id Into v_主页id From 病人信息 Where 病人id = v_病人id;
  End If;
  Select 结算序号 Into n_结算序号 From 病人预交记录 Where 结帐id = 结帐id_In And Rownum = 1;

  v_冲预交病人ids := Nvl(冲预交病人ids_In, v_病人id);

  ----回退缴款,预交不动,因为没有改冲预交的
  --收费未最未最终完成的,代表按异常单据修正,不处理人员缴款余额
  v_金额合计 := 0;

  If Nvl(仅修正医保_In, 0) = 0 Then
    For r_Del In c_Del Loop
      If r_Del.记录性质 Not In (1, 11) Then
        If Nvl(n_费用状态, 0) <> 1 Then
          Update 人员缴款余额
          Set 余额 = Nvl(余额, 0) - r_Del.冲预交
          Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = r_Del.结算方式;
        
          If Sql%RowCount = 0 Then
            Insert Into 人员缴款余额
              (收款员, 结算方式, 性质, 余额)
            Values
              (v_操作员姓名, r_Del.结算方式, 1, -1 * r_Del.冲预交);
          End If;
        End If;
        v_金额合计 := v_金额合计 + r_Del.冲预交;
        Delete From 病人预交记录 Where ID = r_Del.Id;
      Else
        --检查是否冲预交
        If Nvl(缺省冲预交_In, 0) <> 0 Then
          v_金额合计 := v_金额合计 + r_Del.冲预交;
          If Nvl(n_费用状态, 0) <> 1 Then
            Update 病人余额
            Set 预交余额 = Nvl(预交余额, 0) + Nvl(r_Del.冲预交, 0)
            Where 病人id = v_病人id And 类型 = Nvl(r_Del.预交类别, 2);
            If Sql%NotFound Then
              Insert Into 病人余额
                (病人id, 性质, 预交余额, 费用余额, 类型)
              Values
                (v_病人id, 1, Nvl(r_Del.冲预交, 0), 0, Nvl(r_Del.预交类别, 2));
            End If;
          End If;
          If r_Del.记录性质 = 1 Then
            Update 病人预交记录 Set 冲预交 = 0 Where ID = r_Del.Id;
          Else
            Delete 病人预交记录 Where ID = r_Del.Id;
          End If;
        End If;
      End If;
    End Loop;
  Else
    For r_Del In c_Del_医保 Loop
      If r_Del.记录性质 Not In (1, 11) Then
        If Nvl(n_费用状态, 0) <> 1 Then
          Update 人员缴款余额
          Set 余额 = Nvl(余额, 0) - r_Del.冲预交
          Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = r_Del.结算方式;
        
          If Sql%RowCount = 0 Then
            Insert Into 人员缴款余额
              (收款员, 结算方式, 性质, 余额)
            Values
              (v_操作员姓名, r_Del.结算方式, 1, -1 * r_Del.冲预交);
          End If;
        End If;
        v_金额合计 := v_金额合计 + r_Del.冲预交;
        Delete From 病人预交记录 Where ID = r_Del.Id;
      Else
        --检查是否冲预交
        If Nvl(缺省冲预交_In, 0) <> 0 Then
          v_金额合计 := v_金额合计 + r_Del.冲预交;
          If Nvl(n_费用状态, 0) <> 1 Then
            Update 病人余额
            Set 预交余额 = Nvl(预交余额, 0) + Nvl(r_Del.冲预交, 0)
            Where 病人id = v_病人id And 类型 = Nvl(r_Del.预交类别, 2);
            If Sql%NotFound Then
              Insert Into 病人余额
                (病人id, 性质, 预交余额, 费用余额, 类型)
              Values
                (v_病人id, 1, Nvl(r_Del.冲预交, 0), 0, Nvl(r_Del.预交类别, 2));
            End If;
          End If;
          If r_Del.记录性质 = 1 Then
            Update 病人预交记录 Set 冲预交 = 0 Where ID = r_Del.Id;
          Else
            Delete 病人预交记录 Where ID = r_Del.Id;
          End If;
        End If;
      End If;
    End Loop;
  End If;

  --------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------
  --产生医保支付结算
  If 保险结算_In Is Not Null Then
    --各个保险结算
    v_保险结算 := 保险结算_In || '||';
    While v_保险结算 Is Not Null Loop
      v_当前结算 := Substr(v_保险结算, 1, Instr(v_保险结算, '||') - 1);
    
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算性质)
      Values
        (病人预交记录_Id.Nextval, Decode(结帐_In, 1, 2, v_记录性质), v_No, 1, v_病人id, v_主页id, '保险部份', v_结算方式, v_登记时间, v_操作员编号,
         v_操作员姓名, v_结算金额, 结帐id_In, n_组id, n_结算序号, Mod(Decode(结帐_In, 1, 2, v_记录性质), 10));
    
      v_金额合计 := v_金额合计 - v_结算金额;
    
      v_保险结算 := Substr(v_保险结算, Instr(v_保险结算, '||') + 2);
    End Loop;
  End If;
  --剩余部分用预交
  If Nvl(缺省冲预交_In, 0) <> 0 And v_金额合计 <> 0 Then
    n_预交金额 := v_金额合计;
    --先缴先用，且先用自己的
    --不包含结算方式为代收款项的预交款。
    For c_预交 In (Select a.No, Sum(Nvl(a.金额, 0) - Nvl(a.冲预交, 0)) As 金额, Nvl(Max(a.结帐id), 0) As 结帐id, Max(病人id) As 病人id,
                        Max(Decode(a.记录性质, 1, a.记录状态, 1)) As 记录状态, a.预交类别,
                        Max(Decode(a.记录性质, 1, Decode(a.记录状态, 1, a.Id, 3, a.Id, 0), 0)) As ID,
                        Max(Decode(a.记录性质, 1, Decode(a.记录状态, 1, a.收款时间, 3, a.收款时间, Null, Null))) As 收款时间
                 From 病人预交记录 A
                 Where a.记录性质 In (1, 11) And a.病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And
                       Nvl(a.预交类别, 2) = 缺省冲预交_In And a.结算方式 Not In (Select 名称 From 结算方式 Where 性质 = 5)
                 Group By a.No, a.预交类别
                 Having Sum(Nvl(a.金额, 0) - Nvl(a.冲预交, 0)) <> 0
                 Order By Decode(病人id, Nvl(v_病人id, 0), 0, 1), 收款时间) Loop
    
      n_当前金额 := Case
                  When c_预交.金额 - n_预交金额 < 0 Then
                   c_预交.金额
                  Else
                   n_预交金额
                End;
    
      If c_预交.结帐id = 0 Then
        --第一次冲预交(填上结帐ID,金额为0)
        Update 病人预交记录
        Set 冲预交 = 0, 结帐id = 结帐id_In, 结算序号 = n_结算序号, 结算性质 = Mod(Decode(结帐_In, 1, 2, v_记录性质), 10)
        Where ID = c_预交.Id;
      End If;
      --冲上次剩余额
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 预交类别, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号,
         冲预交, 结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 预交类别, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
               v_登记时间, v_操作员姓名, v_操作员编号, n_当前金额, 结帐id_In, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, n_结算序号,
               Mod(Decode(结帐_In, 1, 2, v_记录性质), 10)
        From 病人预交记录
        Where NO = c_预交.No And 记录状态 = c_预交.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
    
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - n_当前金额
      Where 病人id = c_预交.病人id And 性质 = 1 And 类型 = Nvl(c_预交.预交类别, 2);
    
      --检查是否已经处理完
      If c_预交.金额 < n_预交金额 Then
        n_预交金额 := n_预交金额 - c_预交.金额;
      Else
        n_预交金额 := 0;
      End If;
    
      If n_预交金额 = 0 Then
        Exit;
      End If;
    End Loop;
    If n_预交金额 <> 0 Then
      v_Err_Msg := '[ZLSOFT]预交余不够支付本次支付金额,不能继续操作！[ZLSOFT]';
      Raise Err_Item;
    End If;
    Delete From 病人余额 Where 病人id = v_病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
    v_金额合计 := n_预交金额;
  End If;

  --剩余部份全部用缺省结算方式结算，(小于零也不进行额外处理)
  If v_金额合计 <> 0 Then
    Update 病人预交记录
    Set 冲预交 = 冲预交 + v_金额合计, 卡类别id = 卡类别id_In, 结算卡序号 = 结算卡序号_In, 卡号 = 卡号_In, 交易流水号 = 交易流水号_In, 交易说明 = 交易说明_In,
        合作单位 = 合作单位_In, 结算序号 = n_结算序号
    
    Where 结帐id = 结帐id_In And Nvl(结算方式, 'LXH_Test') = Nvl(v_缺省, 'LXH_Test') And 记录性质 = Decode(结帐_In, 1, 2, v_记录性质);
    If Sql%RowCount = 0 Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 卡类别id, 结算卡序号, 卡号, 交易流水号,
         交易说明, 合作单位, 结算性质)
      Values
        (病人预交记录_Id.Nextval, Decode(结帐_In, 1, 2, v_记录性质), v_No, 1, v_病人id, v_主页id, '保险结算修正', v_缺省, v_登记时间, v_操作员编号,
         v_操作员姓名, v_金额合计, 结帐id_In, n_组id, n_结算序号, 卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, 合作单位_In,
         Mod(Decode(结帐_In, 1, 2, v_记录性质), 10));
    End If;
  
    --挂号结算,分币处理(由于挂号界面没有预结算,所以在此过程中根据分币处理规则来修正)
    If v_记录性质 = 4 Then
      Begin
        Select a.冲预交, a.结算方式
        Into v_现金金额, v_现金结算
        From 病人预交记录 A, 结算方式 B
        Where a.结算方式 = b.名称 And b.性质 = 1 And a.结帐id = 结帐id_In And a.记录性质 = 4;
      Exception
        When Others Then
          v_现金金额 := 0;
      End;
      If Floor(Abs(v_现金金额) * 10) <> Abs(v_现金金额) * 10 Then
        --误差处理
        v_Cashcented := Zl_Cent_Money(v_现金金额, 1);
      
        v_误差金额 := v_现金金额 - v_Cashcented;
        If v_误差金额 <> 0 Then
          Begin
            Select 名称 Into v_误差项 From 结算方式 Where 性质 = 9;
          Exception
            When Others Then
              v_误差项 := Null;
          End;
          If v_误差项 Is Not Null Then
            --10.34之后误差数据
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算性质)
            Values
              (病人预交记录_Id.Nextval, Decode(结帐_In, 1, 2, v_记录性质), v_No, 1, v_病人id, v_主页id, '误差费', v_误差项, v_登记时间, v_操作员编号,
               v_操作员姓名, v_误差金额, 结帐id_In, n_组id, n_结算序号, Mod(Decode(结帐_In, 1, 2, v_记录性质), 10));
            Update 病人预交记录
            Set 冲预交 = v_Cashcented
            Where 结帐id = 结帐id_In And 记录性质 = 4 And 结算方式 = v_现金结算;
          Else
            --1.更新预交记录(一定存在记录)
            Update 病人预交记录
            Set 冲预交 = v_Cashcented
            Where 结算方式 = (Select 名称 From 结算方式 Where 性质 = 1 And Rownum = 1) And 结帐id = 结帐id_In;
          
            --2.生成误差费用记录(注:计算单位记录的是号别,所以不取误差项的)
            Begin
              Select a.类别, a.Id, c.Id, c.收据费目
              Into v_收费类别, v_收费细目id, v_收入项目id, v_收据费目
              From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费特定项目 D
              Where d.特定项目 = '误差项' And d.收费细目id = a.Id And a.Id = b.收费细目id And b.收入项目id = c.Id And
                    Sysdate Between b.执行日期 And Nvl(b.终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')) And b.价格等级 Is Null;
            Exception
              When Others Then
                v_Err_Msg := '不能正确读取收费误差项的信息，请先检查该项目是否设置正确。';
                Raise Err_Item;
            End;
            If Nvl(结帐_In, 0) = 1 Then
              Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
              Select Max(序号) + 1, Max(发生时间) Into v_序号, v_发生时间 From 住院费用记录 Where 结帐id = 结帐id_In;
              n_医疗小组id := Zl_医疗小组_Get(0, v_操作员姓名, v_病人id, v_主页id, v_发生时间);
            
              Insert Into 住院费用记录
                (ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 床号, 姓名, 性别, 年龄, 病人病区id, 病人科室id, 费别, 收费类别,
                 收费细目id, 计算单位, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 记帐费用, 划价人, 开单部门id, 开单人, 发生时间,
                 登记时间, 执行部门id, 执行人, 执行状态, 结帐id, 结帐金额, 操作员编号, 操作员姓名, 是否上传, 缴款组id, 医疗小组id)
                Select v_费用id, 记录性质, NO, 实际票号, 记录状态, v_序号, Null, Null, 门诊标志, 病人id, 标识号, 床号, 姓名, 性别, 年龄, 病人病区id, 病人科室id,
                       费别, v_收费类别, v_收费细目id, 计算单位, 发药窗口, 1, 1, 加班标志, 9, v_收入项目id, v_收据费目, v_误差金额, v_误差金额, v_误差金额, 记帐费用,
                       划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 执行状态, 结帐id_In, v_误差金额, 操作员编号, 操作员姓名, 1, 缴款组id,
                       Decode(n_医疗小组id, Null, 医疗小组id, n_医疗小组id)
                From 住院费用记录
                Where 结帐id = 结帐id_In And Rownum = 1;
            Else
              Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
              Select Max(序号) + 1 Into v_序号 From 门诊费用记录 Where 结帐id = 结帐id_In;
              Insert Into 门诊费用记录
                (ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id,
                 计算单位, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 记帐费用, 划价人, 开单部门id, 开单人, 发生时间, 登记时间,
                 执行部门id, 执行人, 执行状态, 费用状态, 结帐id, 结帐金额, 操作员编号, 操作员姓名, 是否上传, 缴款组id)
                Select v_费用id, 记录性质, NO, 实际票号, 记录状态, v_序号, Null, Null, 门诊标志, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 病人科室id, 费别,
                       v_收费类别, v_收费细目id, 计算单位, 发药窗口, 1, 1, 加班标志, 9, v_收入项目id, v_收据费目, v_误差金额, v_误差金额, v_误差金额, 记帐费用, 划价人,
                       开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 执行状态, 费用状态, 结帐id_In, v_误差金额, 操作员编号, 操作员姓名, 1, 缴款组id
                From 门诊费用记录
                Where 结帐id = 结帐id_In And Rownum = 1;
            End If;
          End If;
          --3.更新汇总表
          --只可能产生误差金额的变化.仅为了变量处理方便而用游标
        End If;
      End If;
    End If;
  End If;

  --最后再处理"人员缴款余额"(没有动冲预交那部分,所以"病人余额"的预交余额不用更新)
  For r_Del In c_Del Loop
    If r_Del.记录性质 Not In (1, 11) Then
      If Nvl(n_费用状态, 0) <> 1 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + r_Del.冲预交
        Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = r_Del.结算方式;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (v_操作员姓名, r_Del.结算方式, 1, r_Del.冲预交);
        End If;
      End If;
    End If;
  End Loop;
  Delete From 人员缴款余额 Where 性质 = 1 And 收款员 = v_操作员姓名 And Nvl(余额, 0) = 0;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人结算记录_Update;
/

--107618:胡俊勇,2017-05-12,分诊诊室
CREATE OR REPLACE Procedure Zl_病人接诊_Cancel
(
  病人id_In 病人信息.病人id%Type,
  No_In     病人挂号记录.No%Type
) As
  v_门诊号   病人信息.门诊号%Type;
  v_挂号id   病人挂号记录.Id%Type;
  v_分诊方式 挂号安排.分诊方式%Type;
  n_挂号模式 Number(3);
Begin
  n_挂号模式 := To_Number(Nvl(Substr(zl_GetSysParameter(256), 1, 1), 0));

  Select 门诊号 Into v_门诊号 From 病人信息 Where 病人id = 病人id_In;
  Select ID Into v_挂号id From 病人挂号记录 Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;

  --确定原挂号号别的医生,用于还原
  Begin
    If Nvl(n_挂号模式, 0) = 0 Then
      Select Nvl(a.分诊方式, 0) Into v_分诊方式 From 挂号安排 A, 病人挂号记录 B Where a.号码 = b.号别 And b.No = No_In;
    Else
      Select Nvl(a.分诊方式, 0)
      Into v_分诊方式
      From 临床出诊记录 A, 病人挂号记录 B
      Where a.Id = b.出诊记录id And b.No = No_In;
    End If;
  Exception
    When Others Then
      Null;
  End;

  --就诊状态
  Update 病人信息 Set 就诊时间 = Null, 就诊状态 = 1 Where 病人id = 病人id_In;

  Update 门诊费用记录
  Set 执行状态 = 0, 执行时间 = Null, 发药窗口 = Decode(v_分诊方式, 0, Null, 发药窗口), 结论 = Null
  Where NO = No_In And 记录性质 = 4 And 记录状态 In (1, 3);

  Update 病人挂号记录
  Set 执行状态 = 0, 执行时间 = Null, 诊室 = Decode(v_分诊方式, 0, Null, 诊室), 摘要 = Null
  Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;

  --删除过敏，诊断信息
  Zl_病人过敏记录_Delete(病人id_In, v_挂号id);
  Zl_病人诊断记录_Delete(病人id_In, v_挂号id, Null, Null, '1,11');
  Update 排队叫号队列 Set 排队状态 = 0 Where 业务类型 = 0 And 业务id = v_挂号id;

  Delete From 病人医嘱记录 Where 病人id = 病人id_In And 挂号单 = No_In And 医嘱状态 = 1;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人接诊_Cancel;
/

--108210:李南春,2017-05-12,自助签约模式调整
Create Or Replace Procedure Zl_病人信息_联系电话_Update
(
  病人id_In   病人信息.病人id%Type,
  家庭电话_In 病人信息.家庭电话%Type
) As
  v_手机号字段 Varchar2(500);
Begin
  Update 病人信息 Set 家庭电话 = 家庭电话_In Where 病人id = 病人id_In;
  
  If 家庭电话_In Is Not Null Then
    --中国移动
    v_手机号字段 := ',139,138,137,136,135,134,159,158,157,150,151,152,147,188,187,182,183,184,178';
    --中国联通
    v_手机号字段 := v_手机号字段 || ',130,131,132,156,155,186,185,145,176';
    --中国电信
    v_手机号字段 := v_手机号字段 || ',133,153,189,180,181,177,173';
    --虚拟运营商
    v_手机号字段 := v_手机号字段 || ',170,';
    If Not Instr(v_手机号字段, ',' || Substr(家庭电话_In, 1, 3) || ',') = 0 Then
      Update 病人信息 Set 手机号 = 家庭电话_In Where 病人id = 病人id_In;
    End If;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人信息_联系电话_Update;
/

--89348:胡俊勇,2017-05-23,医嘱单打印
--109076:胡俊勇,2017-05-12,医嘱单打印
Create Or Replace Procedure Zl_病人医嘱打印_Insert
(
  病人id_In 病人医嘱记录.病人id%Type,
  主页id_In 病人医嘱记录.主页id%Type,
  婴儿_In   病人医嘱记录.婴儿%Type,
  期效_In   病人医嘱记录.医嘱期效%Type,
  行数_In   Number
  --功能：将病人没有打印过的医嘱插入 病人医嘱打印
  --参数：行数_In：报表医嘱单一页可以打多少行
  --      行数_In医嘱单报表的行数，通常是28行。
) Is
  n_序号       病人医嘱记录.序号%Type;
  n_医嘱id     病人医嘱记录.Id%Type;
  n_重整标记   Number;
  v_Max_Date   Date;
  d_重整       Date;
  d_Pdate      Date;
  n_换页打     Number;
  n_打重开     Number;
  n_转科       Number;
  n_页号       Number;
  n_行号       Number;
  n_位置       Number;
  n_打印模式   Number;
  n_打给药方式 Number;
  n_Lzzkhy     Number;
  n_Cnt        Number;
  v_Tmp        Varchar2(200);

  --c_Advice 取出待打印的医嘱，在打印临嘱时转科医嘱都会读取出来，后面要判断是不是要生成打印记录
  Cursor c_Advice Is
    Select 医嘱id, 顺序, 打印标记, 特殊医嘱, 换页
    From (With Printtable As (Select a.Id As 医嘱id, a.序号 As 顺序, 0 As 打印标记, Null As 特殊医嘱,
                                     Decode(a.诊疗类别, 'Z', Decode(b.操作类型, '3', 3, '4', 4, 0), 0) As 换页, a.诊疗项目id, a.相关id,
                                     b.操作类型, a.诊疗类别
                              From 病人医嘱记录 A, 诊疗项目目录 B
                              Where a.病人id = 病人id_In And a.主页id = 主页id_In And Nvl(a.婴儿, 0) = 婴儿_In And a.诊疗项目id = b.Id(+) And
                                    (期效_In = 0 And (a.医嘱期效 = 0 Or n_位置 In (-1, 0, 2) And a.医嘱期效 = 1 And a.诊疗类别 = 'Z' And
                                    b.操作类型 In ('5', '3', '11')) Or
                                    期效_In = 1 And a.医嘱期效 = 1 And
                                    Not (n_位置 = 0 And Nvl(a.诊疗类别, 'X') = 'Z' And Nvl(b.操作类型, 'X') In ('5', '3', '11')) Or
                                    期效_In = 1 And a.医嘱期效 = 1 And n_位置 = 0 And a.诊疗类别 = 'Z' And b.操作类型 = '3') And
                                    a.医嘱状态 Not In (-1, 2) And (n_打印模式 = 1 And a.医嘱状态 = 1 Or a.医嘱状态 <> 1) And
                                    Nvl(a.屏蔽打印, 0) = 0 And a.序号 > n_序号 And
                                    a.病人来源 = 2)
           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
           From 病人医嘱记录 L, 诊疗项目目录 I, Printtable P
           Where l.Id = p.医嘱id And l.诊疗项目id = i.Id And
                 (l.诊疗类别 Not In ('5', '6', '7', 'E') Or l.诊疗类别 = 'E' And Nvl(i.操作类型, '0') Not In ('2', '3') Or
                 i.Id Is Null) And l.相关id Is Null
           Union All
           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
           From 病人医嘱记录 L, Printtable P
           Where l.Id = p.医嘱id And l.诊疗类别 In ('5', '6')
           Union All
           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
           From Printtable P
           Where p.诊疗类别 = 'E' And p.操作类型 = '2' And p.相关id Is Null And
                 (n_打给药方式 = 1 Or n_打给药方式 = 2 And Exists
                  (Select 1 From 病人医嘱记录 L Where l.相关id = p.医嘱id Having Count(1) > 1))
           Union All
           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
           From Printtable P
           Where p.诊疗项目id Is Null
           Order By 顺序);


  Cursor c_Advice_Redo Is
    Select 医嘱id, 顺序, 打印标记, 特殊医嘱, 换页
    From (With Printtable As (Select a.Id As 医嘱id, a.序号 As 顺序, 0 As 打印标记, Null As 特殊医嘱,
                                     Decode(a.诊疗类别, 'Z', Decode(b.操作类型, '3', 3, '4', 4, 0), 0) As 换页, a.诊疗项目id, a.相关id,
                                     b.操作类型, a.诊疗类别
                              From 病人医嘱记录 A, 诊疗项目目录 B
                              Where a.病人id = 病人id_In And a.主页id = 主页id_In And Nvl(a.婴儿, 0) = 婴儿_In And a.诊疗项目id = b.Id(+) And
                                    (期效_In = 0 And (a.医嘱期效 = 0 Or n_位置 In (-1, 0, 2) And a.医嘱期效 = 1 And a.诊疗类别 = 'Z' And
                                    b.操作类型 In ('5', '3', '11')) Or
                                    期效_In = 1 And a.医嘱期效 = 1 And
                                    Not (n_位置 = 0 And Nvl(a.诊疗类别, 'X') = 'Z' And Nvl(b.操作类型, 'X') In ('5', '3', '11'))) And
                                    a.医嘱状态 Not In (-1, 2) And (n_打印模式 = 1 And a.医嘱状态 = 1 Or a.医嘱状态 <> 1) And
                                    Nvl(a.屏蔽打印, 0) = 0 And a.序号 > n_序号 And Exists
                               (Select 1 From 病人医嘱状态 C Where a.Id = c.医嘱id And c.操作时间 >= v_Max_Date) And a.病人来源 = 2)
           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
           From 病人医嘱记录 L, 诊疗项目目录 I, Printtable P
           Where l.Id = p.医嘱id And l.诊疗项目id = i.Id And
                 (l.诊疗类别 Not In ('5', '6', '7', 'E') Or l.诊疗类别 = 'E' And Nvl(i.操作类型, '0') Not In ('2', '3') Or
                 i.Id Is Null) And l.相关id Is Null
           Union All
           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
           From 病人医嘱记录 L, Printtable P
           Where l.Id = p.医嘱id And l.诊疗类别 In ('5', '6')
           Union All
           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
           From Printtable P
           Where p.诊疗类别 = 'E' And p.操作类型 = '2' And p.相关id Is Null And
                 (n_打给药方式 = 1 Or n_打给药方式 = 2 And Exists
                  (Select 1 From 病人医嘱记录 L Where l.相关id = p.医嘱id Having Count(1) > 1))
           Union All
           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
           From Printtable P
           Where p.诊疗项目id Is Null
           Order By 顺序);


  --获取下一个或用的行号和页号
  Function Getnextpos
  (
    v_页号 病人医嘱打印.页号%Type,
    v_行号 病人医嘱打印.行号%Type,
    v_行数 Number
  ) Return Varchar2 Is
    n_p Number;
    n_r Number;
  Begin
    If v_行号 = 0 Then
      n_p := 1;
      n_r := 1;
    Elsif v_行号 = v_行数 Then
      n_p := v_页号 + 1;
      n_r := 1;
    Else
      n_p := v_页号;
      n_r := v_行号 + 1;
    End If;
    Return(n_p || ',' || n_r);
  End;

Begin
  n_位置       := Zl_To_Number(Nvl(zl_GetSysParameter('转科和出院打印', 1254), 0));
  n_打印模式   := Zl_To_Number(Nvl(zl_GetSysParameter('医嘱单打印模式', 1253), 0));
  n_打给药方式 := Zl_To_Number(Nvl(zl_GetSysParameter('药品用法单独打印一行', 1254), 0));
  n_Lzzkhy     := Zl_To_Number(Nvl(zl_GetSysParameter('临嘱单转科换页', 1254), 0));
  n_换页打     := Zl_To_Number(Nvl(zl_GetSysParameter('重整和术后医嘱换页打印', 1254), 0));
  n_打重开     := Zl_To_Number(Nvl(zl_GetSysParameter('转科换页后在首行打印重开医嘱', 1254), 0));

  --判断是不是重整后打印医嘱
  If 期效_In = 1 Then
    d_重整 := To_Date('1900-01-01', 'YYYY-MM-DD');
  Else
    Select 医嘱重整时间 Into d_重整 From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
    If d_重整 Is Null Then
      d_重整 := To_Date('1900-01-01', 'YYYY-MM-DD');
    End If;
  End If;
  v_Max_Date := d_重整;
  Begin
    Select 医嘱id, 打印时间, 页号, 行号
    Into n_医嘱id, d_Pdate, n_页号, n_行号
    From (Select 医嘱id, 打印时间, 页号, 行号
           From 病人医嘱打印
           Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And 医嘱id Is Not Null
           Order By 页号 Desc, 行号 Desc)
    Where Rownum < 2;
  
    Select Nvl(Max(序号), 0)
    Into n_序号
    From 病人医嘱记录
    Where ID = (Select Nvl(a.相关id, a.Id) From 病人医嘱记录 A Where a.Id = n_医嘱id);
  
    If 期效_In = 0 Then
      If d_Pdate Is Not Null Then
        If d_Pdate < d_重整 And d_重整 <> To_Date('1900-01-01', 'YYYY-MM-DD') Then
          n_重整标记 := 1;
          n_序号     := 0;
        End If;
      End If;
    End If;
  Exception
    When Others Then
      n_页号 := 0;
      n_行号 := 0;
      n_序号 := 0;
  End;

  If n_医嘱id Is Not Null Then
    Select Max(b.操作类型)
    Into v_Tmp
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id(+) And a.Id = n_医嘱id And a.诊疗类别 = 'Z';
  End If;
  If v_Tmp = '3' Then
    n_Cnt := 3;
  Elsif v_Tmp = '4' Then
    n_Cnt := 4;
  End If;

  v_Tmp  := Getnextpos(n_页号, n_行号, 行数_In);
  n_页号 := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
  n_行号 := Substr(v_Tmp, Instr(v_Tmp, ',') + 1);

  If n_Cnt = 3 And n_Lzzkhy = 1 And 期效_In = 1 Then
    --临时医嘱转科换页
    If n_行号 <> 1 Then
      n_行号 := 1;
      n_页号 := n_页号 + 1;
    End If;
  Elsif 期效_In = 0 Then
    --重整，术后，转科重开，这些只针对于长期医嘱单
    --重整标记
    If n_重整标记 = 1 Then
      If n_换页打 = 1 Then
        If n_行号 <> 1 Then
          n_行号 := 1;
          n_页号 := n_页号 + 1;
        End If;
      End If;
      Insert Into 病人医嘱打印
        (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
      Values
        (-1 * Null, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, 0, Null);
      v_Tmp  := Getnextpos(n_页号, n_行号, 行数_In);
      n_页号 := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
      n_行号 := Substr(v_Tmp, Instr(v_Tmp, ',') + 1);
    End If;
  
    --转科换页打重开字样
    If n_打重开 = 1 And n_Cnt = 3 Then
      If n_重整标记 = 1 Then
        --前面打了重整就不换页了
        If n_打重开 = 1 Then
          Insert Into 病人医嘱打印
            (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
          Values
            (-1 * Null, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, 0, 1);
          v_Tmp  := Getnextpos(n_页号, n_行号, 行数_In);
          n_页号 := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
          n_行号 := Substr(v_Tmp, Instr(v_Tmp, ',') + 1);
        End If;
      Else
        --打重开字样
        If n_行号 <> 1 Then
          n_行号 := 1;
          n_页号 := n_页号 + 1;
        End If;
        Insert Into 病人医嘱打印
          (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
        Values
          (-1 * Null, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, 0, 1);
        v_Tmp  := Getnextpos(n_页号, n_行号, 行数_In);
        n_页号 := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
        n_行号 := Substr(v_Tmp, Instr(v_Tmp, ',') + 1);
      End If;
    End If;
  
    --转科医嘱换页
    If Nvl(n_重整标记, 0) <> 1 And Nvl(n_打重开, 0) <> 1 And n_Cnt = 3 And n_换页打 = 1 Then
      If n_行号 <> 1 Then
        n_行号 := 1;
        n_页号 := n_页号 + 1;
      End If;
    End If;
  
    --术后医嘱换页
    If Nvl(n_重整标记, 0) <> 1 And n_Cnt = 4 And n_换页打 = 1 Then
      If n_行号 <> 1 Then
        n_行号 := 1;
        n_页号 := n_页号 + 1;
      End If;
    End If;
  End If;
  n_转科 := 0;

  --最近次重整后,需要打印的医嘱，考虑换页打印情况转科术后
  ---r_Print.换页 对特殊医嘱标记，4－术后，3－转科
  If v_Max_Date = To_Date('1900-01-01', 'YYYY-MM-DD') Then
    For r_Print In c_Advice Loop
      ----换页或者打医嘱重开字样
      If n_换页打 = 1 And n_转科 = 1 And 期效_In = 0 Then
        If n_打重开 = 1 Then
          --打重开字样
          If n_行号 <> 1 Then
            n_行号 := 1;
            n_页号 := n_页号 + 1;
          End If;
          Insert Into 病人医嘱打印
            (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
          Values
            (-1 * Null, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, 0, 1);
          v_Tmp  := Getnextpos(n_页号, n_行号, 行数_In);
          n_页号 := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
          n_行号 := Substr(v_Tmp, Instr(v_Tmp, ',') + 1);
        Else
          --只是单纯换一页
          If n_行号 <> 1 Then
            n_行号 := 1;
            n_页号 := n_页号 + 1;
          End If;
        End If;
        n_转科 := 0;
      End If;
    
      If 期效_In = 1 And n_转科 = 1 And n_Lzzkhy = 1 Then
        If n_行号 <> 1 Then
          n_行号 := 1;
          n_页号 := n_页号 + 1;
        End If;
        n_转科 := 0;
      End If;
    
      If r_Print.换页 = 4 And n_换页打 = 1 Then
        --术后医嘱换页
        --如果行号为1说明已经是新的一页的第一行,否则换页
        If n_行号 <> 1 Then
          n_行号 := 1;
          n_页号 := n_页号 + 1;
        End If;
      End If;
    
      If 期效_In = 0 Or 期效_In = 1 And (n_位置 = 2 Or n_位置 = 1 Or r_Print.换页 <> 3) Then
        Insert Into 病人医嘱打印
          (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
        Values
          (r_Print.医嘱id, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, r_Print.打印标记, r_Print.特殊医嘱);
        v_Tmp  := Getnextpos(n_页号, n_行号, 行数_In);
        n_页号 := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
        n_行号 := Substr(v_Tmp, Instr(v_Tmp, ',') + 1);
      End If;
      --启用了转科换页打重开字样，则插入一重开医嘱标记，此处一定换页，因为转科换页前要先打出转科医嘱，
      --这里不插入数据，只进行标记，再下一次循时才插入。如果转科医嘱是最后一条是不用打印新开字样的。
      If r_Print.换页 = 3 Then
        n_转科 := 1;
      End If;
    End Loop;
  Else
    For r_Print In c_Advice_Redo Loop
      ----换页或者打医嘱重开字样
      If n_换页打 = 1 And n_转科 = 1 And 期效_In = 0 Then
        If n_打重开 = 1 Then
          --打重开字样
          If n_行号 <> 1 Then
            n_行号 := 1;
            n_页号 := n_页号 + 1;
          End If;
          Insert Into 病人医嘱打印
            (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
          Values
            (-1 * Null, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, 0, 1);
          v_Tmp  := Getnextpos(n_页号, n_行号, 行数_In);
          n_页号 := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
          n_行号 := Substr(v_Tmp, Instr(v_Tmp, ',') + 1);
        Else
          --只是单纯换一页
          If n_行号 <> 1 Then
            n_行号 := 1;
            n_页号 := n_页号 + 1;
          End If;
        End If;
        n_转科 := 0;
      End If;
    
      If r_Print.换页 = 4 And n_换页打 = 1 Then
        --术后医嘱换页
        --如果行号为1说明已经是新的一页的第一行,否则换页
        If n_行号 <> 1 Then
          n_行号 := 1;
          n_页号 := n_页号 + 1;
        End If;
      End If;
      Insert Into 病人医嘱打印
        (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
      Values
        (r_Print.医嘱id, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, r_Print.打印标记, r_Print.特殊医嘱);
      v_Tmp  := Getnextpos(n_页号, n_行号, 行数_In);
      n_页号 := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
      n_行号 := Substr(v_Tmp, Instr(v_Tmp, ',') + 1);
      --启用了转科换页打重开字样，则插入一重开医嘱标记，此处一定换页，因为转科换页前要先打出转科医嘱
      --这里不插入数据，只进行标记，再下一次循时才插入。如果转科医嘱是最后一条是不用打印新开字样的。
    
      If r_Print.换页 = 3 And 期效_In = 0 Then
        n_转科 := 1;
      End If;
    End Loop;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱打印_Insert;
/

--108753:冉俊明,2017-05-09,修正在根据票据分配规则自动分配票据明细数据时，未按照性能规范加cardinality关键词的问题
Create Or Replace Procedure Zl_Custom_Invoice_Autoallot
(
  操作类型_In       Number,
  模拟计算_In       Number,
  票种_In           票据使用明细.票种%Type,
  领用id_In         票据使用明细.领用id%Type,
  病人id_In         门诊费用记录.病人id%Type,
  Nos_In            Varchar2,
  起始发票号_In     门诊费用记录.实际票号%Type,
  使用人_In         票据使用明细.使用人%Type,
  使用时间_In       票据使用明细.使用时间%Type,
  Next领用id_In     票据使用明细.领用id%Type := 0,
  Next票据号_In     票据使用明细.号码%Type := Null,
  发票号_In         In Out Varchar2,
  发票张数_In       Out Number,
  按病人补打票据_In Number := 0,
  打印id_In         票据使用明细.打印id%Type := Null,
  Print_Nos_In      t_Strlist := Null
) As
  -------------------------------------------------------------------------------------------------------------
  --功能：根据票据分配规则,自动分配票据明细数据
  --入参：
  --     操作类型_In :1-正常打印票据;2-补打票据;3-重打票据;4-退费收回票据并重新发出票据
  --     模拟计算_IN :0-不进行模拟计算;1-进行模拟计算,模拟计算时不保存数据
  --     票种_IN     :1-门诊收费;暂无其他类型票据
  --     病人ID_IN   :病人ID,如果Nos和发票号_In为空时,表示针对该病人的所有未打印的票据进行打印
  --     NOs_IN      :单据号,多个用逗号分离,最多有400张单据,格式为:A00001,A00002.....
  --     退费NOs:退费所涉及的单据
  --     启始发票号_IN:重打票据或发出票据的启始票号;
  --     Next领用id_In :下一个可用票据批次
  --     Next票据号_In :下一个可用票据批次的起始号
  --     发票号_In   :可以为多个,用逗号分隔,当操作类型为3-重打票据时和4-退费回收票据有效,表示本次需要回收的票据
  --     打印id_In:按病人补打示据时，传入了相关的打印ID,以外面传入的打印ID为准
  --     按病人补打票据_In：1-表示按病人补打票据,不分结算次数
  --     Print_Nos_in:当前的所涉及的收费单据号，主要是控制超过varchar2的大小限制，主要是按病人补打发票时会出现超长的情况，因此通过集合传入,主要是歉容用，本次打印单据>3000时，Nos_in传入值为空。
  --出参:
  --     发票号_In   :可以为多个,用逗号分隔,当操作类型为3-重打票据时和4-退费回收票据有效,表示重打或退费重新发出的票据
  --     发票张数_IN :返回本次收费所需要的发票张数
  -------------------------------------------------------------------------------------------------------------
  v_Err_Msg Varchar2(500);
  Err_Item Exception;
  n_分单据打印 Number(3);
  n_执行科室   Number(3);
  n_收据费目   Number(3);
  n_汇总条件   Number(3);
  n_收费细目   Number(3);

  --------------------------------------------------------
  --定义内部票据处理的数据集
  Type Ty_Rec_Bill Is Record(
    票号     票据打印明细.票号%Type,
    NO       票据打印明细.No%Type,
    序号     票据打印明细.序号%Type,
    关联序号 票据打印明细.关联票号序号%Type,
    修改标志 Number(1));
  Type Ty_Tb_Bill Is Table Of Ty_Rec_Bill;
  c_Invoce Ty_Tb_Bill := Ty_Tb_Bill();
  --------------------------------------------------------
  --按元素1,元素2,元素3,元素4,分别统计各单据的序号
  Type Ty_Rec_No Is Record(
    NO   门诊费用记录.No%Type,
    序号 Varchar2(1000));
  Type Ty_Tb_No Is Table Of Ty_Rec_No;
  c_No Ty_Tb_No := Ty_Tb_No();
  --------------------------------------------------------
  Cursor c_Fact Is
    Select 前缀文本, 剩余数量, 开始号码, 终止号码, 当前号码 From 票据领用记录 Where ID = Nvl(领用id_In, 0);
  r_Factrow c_Fact%RowType;

  Cursor c_Nextfact Is
    Select 开始号码, 终止号码, 剩余数量 From 票据领用记录 Where ID = Nvl(Next领用id_In, 0);
  r_Nextfactrow c_Nextfact%RowType;

  v_发票号     票据打印明细.票号%Type;
  v_开始发票号 票据打印明细.票号%Type;
  v_当前发票号 票据打印明细.票号%Type;
  v_回收票据号 Varchar2(4000);
  n_Find       Number(3);
  n_领用id     票据使用明细.领用id%Type;

  v_发票信息old Varchar2(4000);
  v_发票信息tmp Varchar2(4000);

  n_元素1_Count Number(3);
  n_元素2_Count Number(3);
  n_元素3_Count Number(3);
  n_元素4_Count Number(3);

  v_元素1    门诊费用记录.No%Type;
  n_元素2    门诊费用记录.执行部门id%Type;
  v_元素3    门诊费用记录.收据费目%Type;
  n_元素4    门诊费用记录.收费细目id%Type;
  v_发票信息 Varchar2(4000);
  n_误差项   Number(1);
  n_打印id   票据使用明细.打印id%Type;
  n_使用id   票据使用明细.Id%Type;
  n_返回数   Number(18);
  n_关联序号 Number(18);
  r_单据号   t_Strlist := t_Strlist();
  r_单据序号 t_Strlist := t_Strlist();
  l_使用id   t_Numlist := t_Numlist();
  l_关联序号 t_Numlist := t_Numlist();

  v_打印内容 Varchar2(4000);
  v_Temp     Varchar2(4000);
  Procedure Invoice_Split_Notgroup
  (
    Print_Nos        t_Strlist,
    回收发票_In      Varchar2,
    本次打印发票_Out In Out Varchar2,
    本次发票张数_Out In Out Number,
    Invoce_Out       In Out Ty_Tb_Bill
  ) As
    ----------------------------------------------------------------------------
    --入参:
    --   收费收费NOs_IN:本次需要处理的发票所涉及的单据,多个用逗号分离
    --   回收发票_IN-退费时有效,多个用逗号分离，表示本次需要回收的发票号
    --出参:
    -- 本次打印发票_Out-本次需要的发票号,多个用逗号分离
    -- 本次发票张数_Out-本次需要的发票数
    -- Invoce_Out:本次返回的发票号与单据的对应关系
    n_Count Number(18);
    n_分页  Number(18);
  
    Cursor Cr_Bill Is
      Select NO As 元素1, 执行部门id As 元素2, 收据费目 As 元素3, NO As 元素4, NO As 单据, 序号, 0 As 个数
      From 门诊费用记录
      Where Rownum <= 1;
    c_Bill Cr_Bill%RowType;
    --------------------------------------------------------------------------------------------
    --根据相关传入的数据,取对应的数据集
    Type Ty_费用明细 Is Ref Cursor;
    c_费用明细 Ty_费用明细; --游标变量
  
  Begin
    --按单据分配票据
    If 操作类型_In = 3 Or 操作类型_In = 4 Then
      --1-正常打印票据;2-补打票据;3-重打票据;4-退费收回票据并重新发出票据
      Open c_费用明细 For
        With c_费用 As
         (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                 Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, '-', a.No) As 元素4, a.No As 单据,
                 Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
          From 门诊费用记录 A,
               (Select /*+cardinality(j,10)*/
                  NO, 序号
                 From 票据打印明细 M, Table(f_Str2list(回收发票_In)) J
                 Where m.票号 = j.Column_Value) B
          Where Mod(a.记录性质, 10) = 1 And a.No = b.No And Instr(',' || b.序号 || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 And
                Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
          Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
          Having Sum(Nvl(a.付数, 1) * a.数次) <> 0)
        Select 元素1, 元素2, 元素3, 元素4, 单据, 序号, Count(*) As 个数
        From c_费用
        Group By 元素1, 元素2, 元素3, 元素4, 单据, 序号
        Order By 元素1, 元素2, 元素3, 元素4, 单据, 序号;
    Else
      Open c_费用明细 For
        With c_费用 As
         (Select /*+cardinality(b,10)*/
           Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
           Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, '-', a.No) As 元素4, a.No As 单据,
           Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
          From 门诊费用记录 A, Table(Print_Nos) B
          Where Mod(a.记录性质, 10) = 1 And a.No = b.Column_Value And Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
          Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
          Having Sum(Nvl(a.付数, 1) * a.数次) <> 0)
        Select 元素1, 元素2, 元素3, 元素4, 单据, 序号, Count(*) As 个数
        From c_费用
        Group By 元素1, 元素2, 元素3, 元素4, 单据, 序号
        Order By 元素1, 元素2, 元素3, 元素4, 单据, 序号;
    End If;
  
    v_元素1          := '+';
    n_元素2          := 0;
    v_元素3          := '+';
    n_元素4          := 0;
    n_元素1_Count    := 0;
    n_元素2_Count    := 0;
    n_元素3_Count    := 0;
    n_元素4_Count    := 0;
    本次发票张数_Out := 0;
    If n_汇总条件 <> 0 Then
      n_关联序号 := 1;
    Else
      n_关联序号 := 0;
    End If;
    n_Count := 0;
    c_No.Delete;
    Loop
      Fetch c_费用明细
        Into c_Bill;
      Exit When c_费用明细%NotFound;
      n_Count := 1;
    
      n_分页 := 0;
      If (v_元素1 <> c_Bill.元素1) Or (n_元素2 <> c_Bill.元素2 And n_元素2_Count >= n_执行科室 And n_执行科室 <> 0) Or
         (v_元素3 <> c_Bill.元素3 And n_元素3_Count >= n_收据费目 And n_收据费目 <> 0) Or (n_元素4_Count >= n_收费细目 And n_收费细目 <> 0) Then
      
        If (v_元素1 <> '+' Or n_元素2 <> 0 Or v_元素3 <> '+' Or n_元素4 <> 0) Then
          n_分页 := 1;
        End If;
        n_元素2_Count := 0;
        n_元素3_Count := 0;
        n_元素4_Count := 0;
        n_元素1_Count := 0;
        v_元素1       := '+';
        n_元素2       := 0;
        v_元素3       := '+';
      End If;
    
      If n_分页 = 1 Then
        --分页:计算发票号及相关的
        For I In 1 .. c_No.Count Loop
          Invoce_Out.Extend;
          Invoce_Out(Invoce_Out.Count).票号 := v_发票号;
          Invoce_Out(Invoce_Out.Count).No := c_No(I).No;
          Invoce_Out(Invoce_Out.Count).序号 := Case
                                               When Instr(c_No(I).序号, ',') > 0 Then
                                                Substr(c_No(I).序号, 2)
                                               Else
                                                c_No(I).序号
                                             End;
          Invoce_Out(Invoce_Out.Count).关联序号 := n_关联序号;
        End Loop;
      
        本次发票张数_Out := 本次发票张数_Out + 1;
        本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
        v_发票号         := Zl_Incstr(v_发票号);
        c_No.Delete;
      End If;
      If (v_元素1 <> c_Bill.元素1) Then
        n_元素1_Count := n_元素1_Count + 1;
        v_元素1       := c_Bill.元素1;
      End If;
      If (n_元素2 <> c_Bill.元素2) Then
        n_元素2_Count := n_元素2_Count + 1;
        n_元素2       := c_Bill.元素2;
      End If;
      If (v_元素3 <> c_Bill.元素3) Then
        n_元素3_Count := n_元素3_Count + 1;
        v_元素3       := c_Bill.元素3;
      End If;
      If n_收费细目 <> 0 Then
        n_元素4_Count := n_元素4_Count + 1;
      End If;
    
      -------------------------------------------
      --分配单据号及序号
      n_Find := 0;
      For J In 1 .. c_No.Count Loop
        If c_No(J).No = c_Bill.单据 Then
          --单据号相同,将序号合并
          c_No(J).序号 := c_No(J).序号 || ',' || c_Bill.序号;
          n_Find := 1;
          Exit;
        End If;
      End Loop;
      If n_Find = 0 Then
        c_No.Extend;
        c_No(c_No.Count).No := c_Bill.单据;
        c_No(c_No.Count).序号 := c_No(c_No.Count).序号 || ',' || c_Bill.序号;
      End If;
    End Loop;
  
    --是否有发票数据
    If n_Count >= 1 Then
      --最后一个发票分配
      本次发票张数_Out := 本次发票张数_Out + 1;
      本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
    Else
      本次发票张数_Out := 0;
      本次打印发票_Out := '';
    End If;
    If c_No.Count <> 0 Then
      For I In 1 .. c_No.Count Loop
        Invoce_Out.Extend;
        Invoce_Out(Invoce_Out.Count).票号 := v_发票号;
        Invoce_Out(Invoce_Out.Count).No := c_No(I).No;
        If Instr(c_No(I).序号, ',') > 0 Then
          c_No(I).序号 := Substr(c_No(I).序号, 2);
        End If;
        Invoce_Out(Invoce_Out.Count).序号 := c_No(I).序号;
        Invoce_Out(Invoce_Out.Count).关联序号 := n_关联序号;
      End Loop;
      c_No.Delete;
    End If;
    If Instr(Nvl(本次打印发票_Out, '-'), ',') > 0 Then
      本次打印发票_Out := Substr(本次打印发票_Out, 2);
    End If;
  End Invoice_Split_Notgroup;

Begin
  --处理票据数据
  If 票种_In <> 1 Then
    --暂不支持其他,只支持门诊收费
    Return;
  End If;
  v_发票号 := 起始发票号_In;
  -----------------------------------------------------------------------------------------------------------------------------
  --一、获取发票分配的相关规则
  --**开始
  --1.确定是否分单据分配票号,缺省不按单据分号
  n_分单据打印 := 0;
  --2.确定是否按执行科室分单据号,缺省为按1个执行科室分号
  n_执行科室 := 1;

  --3.确定是否按收据费目分单据号,缺省为按3个收据费目分号
  n_收据费目 := 3;

  --4.确定是否按收费细目分单据号,缺省为不按收费细目分号
  n_收费细目 := 0;

  --5.决定是否首页汇总,缺省为不汇总
  n_汇总条件 := 0;

  v_回收票据号 := 发票号_In;
  发票张数_In  := 0;
  --**结束

  If Nvl(按病人补打票据_In, 0) <> 0 Then
    --按病人补打票据时，只按收费费目打印
    n_执行科室 := 0;
  End If;
  -----------------------------------------------------------------------------------------------------------------------------
  --二、进行发票分配
  Invoice_Split_Notgroup(Print_Nos_In, 发票号_In, v_发票信息, 发票张数_In, c_Invoce);

  -----------------------------------------------------------------------------------------------------------------------------
  --*****************************************************************************************************************************
  --注意:
  --以下代码，不轻意更改,在上面的代码中需要确定两个变量的值:一是v_发票信息;二是c_Invoce集合中的值
  --  v_发票信息:本次所涉及的发票信息,多个用逗号分离,最好按升序排序
  --  c_Invoce:为集合数据，为发票号和单据的对应关系

  发票号_In := v_发票信息;
  If 模拟计算_In = 1 Then
    --模拟计算,只返回票据张数和使用的票据号,直接退出
    Return;
  End If;
  -----------------------------------------------------------------------------------------------------------------------------
  --四、退费时，需要先处理回收发票
  v_开始发票号 := Null;
  v_当前发票号 := Null;
  --1-正常打印票据;2-补打票据;3-重打票据;4-退费收回票据并重新发出票据
  If 操作类型_In = 3 Or 操作类型_In = 4 Then
    --收回票据
    Select 使用id Bulk Collect
    Into l_使用id
    From (Select /*+cardinality(j,10)*/
           Distinct b.使用id
           From 票据使用明细 A, 票据打印明细 B, Table(f_Str2list(v_回收票据号)) J
           Where a.Id = b.使用id And b.票号 = j.Column_Value And Nvl(b.票种, 0) = 1);
  
    --插入回收记录
    Forall I In 1 .. l_使用id.Count
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
        Select 票据使用明细_Id.Nextval, 票种, 号码, 2, Decode(操作类型_In, 3, 4, 2), 领用id, 打印id, 使用人_In, 使用时间_In
        From 票据使用明细
        Where ID = l_使用id(I);
    Forall I In 1 .. l_使用id.Count
      Update 票据打印明细 Set 是否回收 = 1 Where 使用id = l_使用id(I);
  End If;

  If c_Invoce.Count = 0 Then
    --无发票数据,则直接返回,退费时，表示只收回票据
    Return;
  End If;

  -----------------------------------------------------------------------------------------------------------------------------
  --五、重新处理发出的票据(含退费重新发出的票据处理)
  If 起始发票号_In Is Null Then
    v_Err_Msg := '未传入起始发票号,不能进行票据分配处理';
    Raise Err_Item;
  End If;

  If Nvl(领用id_In, 0) <> 0 Then
    Open c_Fact;
    Fetch c_Fact
      Into r_Factrow;
    If c_Fact%RowCount = 0 Then
      v_Err_Msg := '无效的票据领用批次，无法完成收费票据分配操作。';
      Close c_Fact;
      Raise Err_Item;
    Elsif Nvl(r_Factrow.剩余数量, 0) < 发票张数_In Then
      --检查下一个批次
      If Next票据号_In Is Null Then
        Close c_Fact;
        v_Err_Msg := '下一个领用批次未传入起始发票号，当前批次的剩余数量不足' || 发票张数_In || '张，不能进行票据分配处理。';
        Raise Err_Item;
      End If;
    
      Open c_Nextfact;
      Fetch c_Nextfact
        Into r_Nextfactrow;
      If c_Nextfact%RowCount = 0 Then
        Close c_Nextfact;
        Close c_Fact;
        v_Err_Msg := '下一个领用批次无效，当前批次的剩余数量不足' || 发票张数_In || '张，无法完成收费票据分配操作。';
        Raise Err_Item;
      Elsif Nvl(r_Factrow.剩余数量, 0) + Nvl(r_Nextfactrow.剩余数量, 0) < 发票张数_In Then
        Close c_Nextfact;
        Close c_Fact;
        v_Err_Msg := '当前批次以及下一个批次的剩余数量之和不足' || 发票张数_In || '张，无法完成收费票据分配操作。';
        Raise Err_Item;
      End If;
    End If;
  End If;

  --重新分配票号
  v_发票号      := 起始发票号_In;
  v_发票信息old := v_发票信息;
  v_发票信息    := '';
  v_发票信息tmp := '';
  --领用ID1:发票号1,领用ID2:发票号2,...

  n_领用id := 领用id_In;
  For c_Invoce_No In (Select Column_Value As 发票号 From Table(f_Str2list(v_发票信息old)) Order By 发票号) Loop
    If Nvl(n_领用id, 0) <> 0 Then
      If n_领用id = 领用id_In Then
        --检查当前批次票据范围
        If Not (Upper(v_发票号) >= Upper(r_Factrow.开始号码) And Upper(v_发票号) <= Upper(r_Factrow.终止号码) And
            Length(v_发票号) = Length(r_Factrow.终止号码)) Then
          If Nvl(Next领用id_In, 0) <> 0 And n_领用id <> Nvl(Next领用id_In, 0) Then
            --使用下一个领用批次
            n_领用id := Nvl(Next领用id_In, 0);
            v_发票号 := Next票据号_In;
          Else
            Close c_Nextfact;
            Close c_Fact;
            v_Err_Msg := '单据需要打印多张票据,但票据号"' || v_发票号 || '"超出票据领用的号码范围！';
            Raise Err_Item;
          End If;
        End If;
      End If;
      If n_领用id = Nvl(Next领用id_In, 0) Then
        --检查下一个批次票据范围
        If Not (Upper(v_发票号) >= Upper(r_Nextfactrow.开始号码) And Upper(v_发票号) <= Upper(r_Nextfactrow.终止号码) And
            Length(v_发票号) = Length(r_Nextfactrow.终止号码)) Then
          Close c_Nextfact;
          Close c_Fact;
          v_Err_Msg := '单据需要打印多张票据,但票据号"' || v_发票号 || '"超出票据领用的号码范围！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  
    For I In 1 .. c_Invoce.Count Loop
      If c_Invoce(I).票号 = c_Invoce_No.发票号 Then
        --分配新的发票号
        c_Invoce(I).票号 := v_发票号;
      End If;
    End Loop;
    v_发票信息    := Nvl(v_发票信息, '') || ',' || v_发票号;
    v_发票信息tmp := Nvl(v_发票信息tmp, '') || ',' || n_领用id || ':' || v_发票号;
    v_发票号      := Zl_Incstr(v_发票号);
  End Loop;
  If Instr(Nvl(v_发票信息, '-'), ',') > 0 Then
    发票号_In := Substr(v_发票信息, 2);
  End If;
  If Instr(Nvl(v_发票信息tmp, '-'), ',') > 0 Then
    v_发票信息tmp := Substr(v_发票信息tmp, 2);
  End If;

  --1.实际处理票据信息
  If Nvl(n_分单据打印, 0) <> 1 Or Nvl(按病人补打票据_In, 0) = 1 Then
    --不分单据打印时,表示一次打印,打印ID填成一致
    n_打印id := 打印id_In;
    If Nvl(n_打印id, 0) = 0 Then
      Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
    End If;
  End If;

  发票张数_In := 0;
  v_打印内容  := '';
  For c_Invoce_No In (Select C1 As 领用id, C2 As 发票号 From Table(f_Str2list2(v_发票信息tmp)) Order By 领用id, 发票号) Loop
  
    --2.处理票据打印明细
    r_单据号.Delete;
    r_单据序号.Delete;
    l_关联序号.Delete;
  
    Select 票据使用明细_Id.Nextval Into n_使用id From Dual;
  
    n_关联序号 := 0;
  
    For I In 1 .. c_Invoce.Count Loop
      If c_Invoce(I).票号 = c_Invoce_No.发票号 Then
        n_关联序号 := c_Invoce(I).关联序号;
        Exit;
      End If;
    End Loop;
    --处理关联票据,以便回收票据
    For I In 1 .. c_Invoce.Count Loop
      If c_Invoce(I).关联序号 = n_关联序号 And Nvl(c_Invoce(I).修改标志, 0) = 0 Then
        If n_关联序号 <> 0 Then
          c_Invoce(I).关联序号 := n_使用id;
        End If;
        c_Invoce(I).修改标志 := 1;
      End If;
    End Loop;
  
    For I In 1 .. c_Invoce.Count Loop
      If c_Invoce(I).票号 = c_Invoce_No.发票号 Then
        r_单据号.Extend;
        r_单据号(r_单据号.Count) := c_Invoce(I).No;
        r_单据序号.Extend;
        r_单据序号(r_单据序号.Count) := c_Invoce(I).序号;
        l_关联序号.Extend;
        If Nvl(c_Invoce(I).关联序号, 0) <> 0 Then
          --检查是否存在其他的票据
          n_Find := 0;
          For J In 1 .. c_Invoce.Count Loop
            If c_Invoce(I).关联序号 = c_Invoce(J).关联序号 And c_Invoce(I).票号 <> c_Invoce(J).票号 Then
              n_Find := 1;
              Exit;
            End If;
          End Loop;
        
          If n_Find = 0 Then
            l_关联序号(l_关联序号.Count) := Null;
            c_Invoce(I).关联序号 := 0;
          Else
            l_关联序号(l_关联序号.Count) := c_Invoce(I).关联序号;
          End If;
        Else
          l_关联序号(l_关联序号.Count) := Null;
        End If;
      End If;
    End Loop;
  
    --1.处理门打印内容
    If n_分单据打印 = 1 Then
      --分单据打印,需按单据进行处理
      --票据打印内容
      n_Find := 0;
      v_Temp := '';
      For I In 1 .. r_单据号.Count Loop
        v_Temp := v_Temp || ',' || r_单据号(I);
        If Instr(Nvl(v_打印内容, '-') || ',', ',' || r_单据号(I) || ',') > 0 Then
          --已经找到
          n_Find := 1;
        End If;
      End Loop;
      v_打印内容 := v_打印内容 || Nvl(v_Temp, '+');
    
      If Nvl(n_Find, 0) = 0 Then
        Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
        Forall I In 1 .. r_单据号.Count
          Insert Into 票据打印内容
            (ID, 数据性质, NO, 打印类型)
          Values
            (n_打印id, 1, r_单据号(I), Decode(Nvl(按病人补打票据_In, 0), 1, 1, 0));
        --以便更新门诊费用记录中的实际票号
        v_开始发票号 := c_Invoce_No.发票号;
        Forall I In 1 .. r_单据号.Count
          Update 门诊费用记录 Set 实际票号 = v_开始发票号 Where Mod(记录性质, 10) = 1 And NO = r_单据号(I);
      End If;
    Else
    
      If v_开始发票号 Is Null Then
        --以便更新门诊费用记录中的实际票号
        v_开始发票号 := c_Invoce_No.发票号;
      
        --票据打印内容
        Insert Into 票据打印内容
          (ID, 数据性质, NO, 打印类型)
          Select n_打印id, 1, Column_Value, Decode(Nvl(按病人补打票据_In, 0), 1, 1, 0) From Table(Print_Nos_In);
      
        Update 门诊费用记录
        Set 实际票号 = v_开始发票号
        Where Mod(记录性质, 10) = 1 And NO In (Select Column_Value From Table(Print_Nos_In));
      End If;
    End If;
  
    --2.处理票据打印明细
  
    发票张数_In := 发票张数_In + 1;
    --处理票据使用明细
  
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
    Values
      (n_使用id, 1, c_Invoce_No.发票号, 1, Decode(操作类型_In, 3, 3, 1),
       Decode(Nvl(c_Invoce_No.领用id, 0), 0, Null, c_Invoce_No.领用id), n_打印id, 使用人_In, 使用时间_In);
  
    Forall I In 1 .. r_单据号.Count
      Insert Into 票据打印明细
        (使用id, 票种, 是否回收, NO, 票号, 序号, 关联票号序号)
      Values
        (n_使用id, 1, 0, r_单据号(I), c_Invoce_No.发票号, r_单据序号(I), l_关联序号(I));
  
    Update 票据领用记录
    Set 使用时间 = 使用时间_In, 当前号码 = c_Invoce_No.发票号, 剩余数量 = Nvl(剩余数量, 0) - 1
    Where ID = c_Invoce_No.领用id;
  End Loop;

  If Nvl(领用id_In, 0) <> 0 Then
    Close c_Fact;
    If Nvl(Next领用id_In, 0) <> 0 And Nvl(r_Factrow.剩余数量, 0) < Nvl(发票张数_In, 0) Then
      Close c_Nextfact;
    End If;
  End If;
  --*****************************************************************************************************************************
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Custom_Invoice_Autoallot;
/

--108753:冉俊明,2017-05-09,修正在根据票据分配规则自动分配票据明细数据时，未按照性能规范加cardinality关键词的问题
Create Or Replace Procedure Zl_Invoice_Autoallot
(
  操作类型_In   Number,
  模拟计算_In   Number,
  票种_In       票据使用明细.票种%Type,
  领用id_In     票据使用明细.领用id%Type,
  病人id_In     门诊费用记录.病人id%Type,
  Nos_In        Varchar2,
  起始发票号_In 门诊费用记录.实际票号%Type,
  使用人_In     票据使用明细.使用人%Type,
  使用时间_In   票据使用明细.使用时间%Type,
  Next领用id_In 票据使用明细.领用id%Type := 0,
  Next票据号_In 票据使用明细.号码%Type := Null,
  发票号_In     In Out Varchar2,
  发票张数_In   Out Number,
  打印id_In     票据使用明细.打印id%Type := 0
) As
  ---------------------------------------------------------------------------------------------
  --功能：根据票据分配规则,自动分配票据明细数据
  --入参：
  --     操作类型_In :1-正常打印票据;2-补打票据;3-重打票据;4-退费收回票据并重新发出票据
  --     票种_IN     :1-门诊收费;暂无其他类型票据
  --     病人ID_IN   :病人ID,如果Nos和发票号_In为空时,表示针对该病人的所有未打印的票据进行打印
  --     NOs_IN      :单据号,多个用逗号分离,最多;有400张单据,格式为:A00001,A00002.....
  --     启始发票号_IN:重打票据或发出票据的启始票号;
  --     Next领用id_In :下一个可用票据批次
  --     Next票据号_In :下一个可用票据批次的起始号
  --     发票号_In   :可以为多个,当操作类型为3-重打票据时,有效
  --     模拟计算_IN :0-不进行模拟计算;1-进行模拟计算,模拟计算时不保存数据
  --     打印ID_In :打印ID_In<>0时，表示根据临时表"临时票据打印内容"所对应的NO来产生打印数据(主要解决按病人补打发票不分结算次数的情况)
  --出参:
  --     发票张数_IN :返回本次收费所需要的发票张数
  ---------------------------------------------------------------------------------------------
  v_Err_Msg Varchar2(500);
  Err_Item Exception;
  v_Para       Varchar2(1000);
  v_Temp       Varchar2(32767);
  n_启用模式   Number(3);
  n_分单据打印 Number(3);
  n_执行科室   Number(3);
  n_收据费目   Number(3);
  n_汇总条件   Number(3);
  n_收费细目   Number(3);

  ---------------------------------------------------------
  Type Ty_Rec_Splitno Is Record(
    元素1    票据打印明细.No%Type,
    元素2集  Varchar2(4000),
    元素3集  Varchar2(4000),
    关联序号 Number(18));

  Type Ty_Tb_Splitno Is Table Of Ty_Rec_Splitno;
  c_Split_No   Ty_Tb_Splitno := Ty_Tb_Splitno();
  c_Split_费目 Ty_Tb_Splitno := Ty_Tb_Splitno();

  --------------------------------------------------------
  --定义内部票据处理的数据集
  Type Ty_Rec_Bill Is Record(
    票号     票据打印明细.票号%Type,
    NO       票据打印明细.No%Type,
    序号     票据打印明细.序号%Type,
    关联序号 票据打印明细.关联票号序号%Type,
    修改标志 Number(1));
  Type Ty_Tb_Bill Is Table Of Ty_Rec_Bill;
  c_Invoce Ty_Tb_Bill := Ty_Tb_Bill();
  --------------------------------------------------------
  --按元素1,元素2,元素3,元素4,分别统计各单据的序号
  Type Ty_Rec_No Is Record(
    NO   门诊费用记录.No%Type,
    序号 Varchar2(1000));
  Type Ty_Tb_No Is Table Of Ty_Rec_No;
  c_No Ty_Tb_No := Ty_Tb_No();
  --------------------------------------------------------
  Cursor c_Fact Is
    Select 前缀文本, 剩余数量, 开始号码, 终止号码, 当前号码 From 票据领用记录 Where ID = Nvl(领用id_In, 0);
  r_Factrow c_Fact%RowType;

  Cursor c_Nextfact Is
    Select 开始号码, 终止号码, 剩余数量 From 票据领用记录 Where ID = Nvl(Next领用id_In, 0);
  r_Nextfactrow c_Nextfact%RowType;
  --------------------------------------------------------------------------------------------
  --根据相关传入的数据,取对应的数据集

  v_Nos        Varchar2(32767);
  v_发票号     票据打印明细.票号%Type;
  v_开始发票号 票据打印明细.票号%Type;
  v_回收票据号 Varchar2(4000);
  n_Find       Number(3);
  n_领用id     票据使用明细.领用id%Type;

  v_发票信息old Varchar2(4000);
  v_发票信息tmp Varchar2(4000);

  n_元素1_Count Number(3);
  n_元素2_Count Number(3);
  n_元素3_Count Number(3);
  n_元素4_Count Number(3);

  v_元素1    门诊费用记录.No%Type;
  n_元素2    门诊费用记录.执行部门id%Type;
  v_元素3    门诊费用记录.收据费目%Type;
  n_元素4    门诊费用记录.收费细目id%Type;
  v_发票信息 Varchar2(4000);
  n_误差项   Number(1);
  n_打印id   票据使用明细.打印id%Type;
  n_使用id   票据使用明细.Id%Type;
  n_关联序号 Number(18);
  r_单据号   t_Strlist := t_Strlist();

  l_Print_Nos t_Strlist := t_Strlist();

  r_单据序号 t_Strlist := t_Strlist();
  l_使用id   t_Numlist := t_Numlist();
  l_关联序号 t_Numlist := t_Numlist();

  v_打印内容   Varchar2(4000);
  l_元素2      t_Numlist := t_Numlist();
  l_元素3      t_Strlist := t_Strlist();
  v_起始发票号 票据领用记录.开始号码%Type;

  n_按病人补打票据 Number(2);
  n_打印类型       票据打印内容.打印类型%Type;
  -------------------------------------------------------------------------------------------------------------------
  --Invoice_Split_Notgroup:不进行分组汇总或首页汇总时调用此过程
  Procedure Invoice_Split_Notgroup
  (
    Print_Nos        t_Strlist,
    回收发票_In      Varchar2,
    本次打印发票_Out Out Varchar2,
    本次发票张数_Out Out Number
  ) As
    ----------------------------------------------------------------------------
    --入参:
    --   收费收费NOs_IN:本次需要处理的发票所涉及的单据,多个用逗号分离
    --   回收发票_IN-退费时有效,多个用逗号分离，表示本次需要回收的发票号
    --出参:
    -- 本次打印发票_Out-本次需要的发票号,多个用逗号分离
    -- 本次发票张数_Out-本次需要的发票数
    -- 本次退费单据_Out-退费回收所涉及的NO号,多个用逗号分离
  
    n_Count Number(18);
    n_分页  Number(18);
  
    Cursor Cr_Bill Is
      Select NO As 元素1, 执行部门id As 元素2, 收据费目 As 元素3, NO As 元素4, NO As 单据, 序号, 0 As 个数
      From 门诊费用记录
      Where Rownum <= 1;
    c_Bill Cr_Bill%RowType;
    --------------------------------------------------------------------------------------------
    --根据相关传入的数据,取对应的数据集
    Type Ty_费用明细 Is Ref Cursor;
    c_费用明细 Ty_费用明细; --游标变量
  
  Begin
    --按单据分配票据
    If 操作类型_In = 3 Or 操作类型_In = 4 Then
      Open c_费用明细 For
        With c_费用 As
         (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                 Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, '-', a.No) As 元素4, a.No As 单据,
                 Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
          From 门诊费用记录 A,
               (Select /*+cardinality(j,10)*/
                  NO, 序号
                 From 票据打印明细 M, Table(f_Str2list(回收发票_In)) J
                 Where m.票号 = j.Column_Value) B
          Where Mod(记录性质, 10) = 1 And a.No = b.No And Instr(',' || b.序号 || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 And
                Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
          Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
          Having Sum(Nvl(a.付数, 1) * a.数次) <> 0)
        Select 元素1, 元素2, 元素3, 元素4, 单据, 序号, Count(*) As 个数
        From c_费用
        Group By 元素1, 元素2, 元素3, 元素4, 单据, 序号
        Order By 元素1, 元素2, 元素3, 元素4, 单据, 序号;
    Else
      Open c_费用明细 For
        With c_费用 As
         (Select /*+cardinality(b,10)*/
           Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
           Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, '-', a.No) As 元素4, a.No As 单据,
           Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
          From 门诊费用记录 A, Table(Print_Nos) B
          Where Mod(记录性质, 10) = 1 And a.No = b.Column_Value And Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
          Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
          Having Sum(Nvl(a.付数, 1) * a.数次) <> 0)
        Select 元素1, 元素2, 元素3, 元素4, 单据, 序号, Count(*) As 个数
        From c_费用
        Group By 元素1, 元素2, 元素3, 元素4, 单据, 序号
        Order By 元素1, 元素2, 元素3, 元素4, 单据, 序号;
    End If;
  
    v_元素1          := '+';
    n_元素2          := 0;
    v_元素3          := '+';
    n_元素4          := 0;
    n_元素1_Count    := 0;
    n_元素2_Count    := 0;
    n_元素3_Count    := 0;
    n_元素4_Count    := 0;
    本次发票张数_Out := 0;
    If n_汇总条件 <> 0 Then
      n_关联序号 := 1;
    Else
      n_关联序号 := 0;
    End If;
    n_Count := 0;
    c_No.Delete;
    Loop
      Fetch c_费用明细
        Into c_Bill;
      Exit When c_费用明细%NotFound;
      n_Count := 1;
    
      n_分页 := 0;
      If (v_元素1 <> c_Bill.元素1) Or (n_元素2 <> c_Bill.元素2 And n_元素2_Count >= n_执行科室 And n_执行科室 <> 0) Or
         (v_元素3 <> c_Bill.元素3 And n_元素3_Count >= n_收据费目 And n_收据费目 <> 0) Or (n_元素4_Count >= n_收费细目 And n_收费细目 <> 0) Then
      
        If (v_元素1 <> '+' Or n_元素2 <> 0 Or v_元素3 <> '+' Or n_元素4 <> 0) Then
          n_分页 := 1;
        End If;
        n_元素2_Count := 0;
        n_元素3_Count := 0;
        n_元素4_Count := 0;
        n_元素1_Count := 0;
        v_元素1       := '+';
        n_元素2       := 0;
        v_元素3       := '+';
      End If;
    
      If n_分页 = 1 Then
        --分页:计算发票号及相关的
        For I In 1 .. c_No.Count Loop
          c_Invoce.Extend;
          c_Invoce(c_Invoce.Count).票号 := v_发票号;
          c_Invoce(c_Invoce.Count).No := c_No(I).No;
          c_Invoce(c_Invoce.Count).序号 := Case
                                           When Instr(c_No(I).序号, ',') > 0 Then
                                            Substr(c_No(I).序号, 2)
                                           Else
                                            c_No(I).序号
                                         End;
          c_Invoce(c_Invoce.Count).关联序号 := n_关联序号;
        End Loop;
      
        本次发票张数_Out := 本次发票张数_Out + 1;
        本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
        v_发票号         := Zl_Incstr(v_发票号);
        c_No.Delete;
      End If;
      If (v_元素1 <> c_Bill.元素1) Then
        n_元素1_Count := n_元素1_Count + 1;
        v_元素1       := c_Bill.元素1;
      End If;
      If (n_元素2 <> c_Bill.元素2) Then
        n_元素2_Count := n_元素2_Count + 1;
        n_元素2       := c_Bill.元素2;
      End If;
      If (v_元素3 <> c_Bill.元素3) Then
        n_元素3_Count := n_元素3_Count + 1;
        v_元素3       := c_Bill.元素3;
      End If;
      If n_收费细目 <> 0 Then
        n_元素4_Count := n_元素4_Count + 1;
      End If;
    
      -------------------------------------------
      --分配单据号及序号
      n_Find := 0;
      For J In 1 .. c_No.Count Loop
        If c_No(J).No = c_Bill.单据 Then
          --单据号相同,将序号合并
          c_No(J).序号 := c_No(J).序号 || ',' || c_Bill.序号;
          n_Find := 1;
          Exit;
        End If;
      End Loop;
      If n_Find = 0 Then
        c_No.Extend;
        c_No(c_No.Count).No := c_Bill.单据;
        c_No(c_No.Count).序号 := c_No(c_No.Count).序号 || ',' || c_Bill.序号;
      End If;
    End Loop;
  
    --是否有发票数据
    If n_Count >= 1 Then
      --最后一个发票分配
      本次发票张数_Out := 本次发票张数_Out + 1;
      本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
    Else
      本次发票张数_Out := 0;
      本次打印发票_Out := '';
    End If;
    If c_No.Count <> 0 Then
      For I In 1 .. c_No.Count Loop
        c_Invoce.Extend;
        c_Invoce(c_Invoce.Count).票号 := v_发票号;
        c_Invoce(c_Invoce.Count).No := c_No(I).No;
        If Instr(c_No(I).序号, ',') > 0 Then
          c_No(I).序号 := Substr(c_No(I).序号, 2);
        End If;
        c_Invoce(c_Invoce.Count).序号 := c_No(I).序号;
        c_Invoce(c_Invoce.Count).关联序号 := n_关联序号;
      End Loop;
      c_No.Delete;
    End If;
    If Instr(Nvl(本次打印发票_Out, '-'), ',') > 0 Then
      本次打印发票_Out := Substr(本次打印发票_Out, 2);
    End If;
  End Invoice_Split_Notgroup;
  --结束:不进行分组汇总或首页汇总时调用此过程
  -------------------------------------------------------------------------------------------------------------------
  --按组汇总
  Procedure Invoice_Split_Group
  (
    Print_Nos        t_Strlist,
    回收发票_In      Varchar2,
    本次打印发票_Out Out Varchar2,
    本次发票张数_Out Out Number
  ) As
  Begin
    v_元素1          := '+';
    n_元素2          := 0;
    v_元素3          := '+';
    n_元素4          := 0;
    n_元素1_Count    := 0;
    n_元素2_Count    := 0;
    n_元素3_Count    := 0;
    n_元素4_Count    := 0;
    本次发票张数_Out := 0;
  
    c_No.Delete;
    l_元素2.Delete;
  
    --按单据分配票据
    If 操作类型_In = 3 Or 操作类型_In = 4 Then
      --******************************************************************************************************************************
      --退费和重打按发票号处理(开始)
      --4.收据费目+收费细目
      If n_分单据打印 = 0 And n_执行科室 = 0 And n_收据费目 <> 0 And n_收费细目 <> 0 Then
        v_元素3 := '+';
        c_Split_费目.Delete;
        For c_分页 In (With c_费用 As
                        (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                               Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, 0, a.收费细目id) As 元素4, a.No As 单据,
                               Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
                        From 门诊费用记录 A,
                             (Select /*+cardinality(j,10)*/
                                NO, 序号
                               From 票据打印明细 M, Table(f_Str2list(回收发票_In)) J
                               Where m.票号 = j.Column_Value) B
                        Where Mod(记录性质, 10) = 1 And a.No = b.No And
                              Instr(',' || b.序号 || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 And
                              Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
                        Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
                        Having Sum(Nvl(a.付数, 1) * a.数次) <> 0)
                       Select a.元素3, Count(*) As 个数 From c_费用 A Group By 元素3 Order By 元素3) Loop
          If (v_元素3 <> c_分页.元素3 And n_元素3_Count >= n_收据费目 And n_收据费目 <> 0) Then
            If v_元素3 <> '+' Then
              c_Split_费目.Extend;
              For J In 1 .. l_元素3.Count Loop
                --单据号相同,将序号合并
                c_Split_费目(c_Split_费目.Count).元素3集 := c_Split_费目(c_Split_费目.Count).元素3集 || ',' || l_元素3(J);
              End Loop;
              v_元素3       := '+';
              n_元素3_Count := 0;
              l_元素3.Delete;
            End If;
          End If;
          If (v_元素3 <> c_分页.元素3) Then
            n_元素3_Count := n_元素3_Count + 1;
            v_元素3       := c_分页.元素3;
            l_元素3.Extend;
            l_元素3(l_元素3.Count) := v_元素3;
          End If;
        End Loop;
        If l_元素3.Count <> 0 Then
          c_Split_费目.Extend;
          For J In 1 .. l_元素3.Count Loop
            --单据号相同,将序号合并
            c_Split_费目(c_Split_费目.Count).元素3集 := c_Split_费目(c_Split_费目.Count).元素3集 || ',' || l_元素3(J);
          End Loop;
        End If;
        n_关联序号 := 0;
        For I In 1 .. c_Split_费目.Count Loop
          c_No.Delete;
          n_关联序号    := n_关联序号 + 1;
          n_元素4_Count := 0;
          For c_分页 In (With c_费用 As
                          (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                                 Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, 0, a.收费细目id) As 元素4, a.No As 单据,
                                 Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
                          From 门诊费用记录 A,
                               (Select /*+cardinality(j,10)*/
                                  NO, 序号
                                 From 票据打印明细 M, Table(f_Str2list(回收发票_In)) J
                                 Where m.票号 = j.Column_Value) B
                          Where Mod(记录性质, 10) = 1 And a.No = b.No And
                                Instr(',' || b.序号 || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 And
                                Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
                          Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
                          Having Sum(Nvl(a.付数, 1) * a.数次) <> 0)
                         Select m.元素1, 元素2, 元素3, m.元素4, m.单据, m.序号, Count(*) As 个数
                         From c_费用 M
                         Where Instr(',' || c_Split_费目(I).元素3集 || ',', ',' || m.元素3 || ',') > 0
                         Group By m.元素1, 元素2, m.元素4, 元素3, m.单据, m.序号
                         Order By m.元素1, 元素2, m.元素4, 元素3, m.单据, m.序号) Loop
            If n_元素4_Count >= n_收费细目 And n_收费细目 <> 0 Then
              --分页:计算发票号及相关的
              For J In 1 .. c_No.Count Loop
                c_Invoce.Extend;
                c_Invoce(c_Invoce.Count).票号 := v_发票号;
                c_Invoce(c_Invoce.Count).No := c_No(J).No;
                c_Invoce(c_Invoce.Count).序号 := Case
                                                 When Instr(c_No(J).序号, ',') > 0 Then
                                                  Substr(c_No(J).序号, 2)
                                                 Else
                                                  c_No(J).序号
                                               End;
                c_Invoce(c_Invoce.Count).关联序号 := n_关联序号;
              End Loop;
              本次发票张数_Out := 本次发票张数_Out + 1;
              本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
              v_发票号         := Zl_Incstr(v_发票号);
              c_No.Delete;
              n_元素4_Count := 0;
              --分页
            End If;
            n_元素4_Count := n_元素4_Count + 1;
            -------------------------------------------
            --分配单据号及序号
            n_Find := 0;
            For J In 1 .. c_No.Count Loop
              If c_No(J).No = c_分页.单据 Then
                --单据号相同,将序号合并
                c_No(J).序号 := c_No(J).序号 || ',' || c_分页.序号;
                n_Find := 1;
                Exit;
              End If;
            End Loop;
            If n_Find = 0 Then
              c_No.Extend;
              c_No(c_No.Count).No := c_分页.单据;
              c_No(c_No.Count).序号 := c_No(c_No.Count).序号 || ',' || c_分页.序号;
            End If;
          End Loop;
          If c_No.Count <> 0 Then
            --分页:计算发票号及相关的
            For J In 1 .. c_No.Count Loop
              c_Invoce.Extend;
              c_Invoce(c_Invoce.Count).票号 := v_发票号;
              c_Invoce(c_Invoce.Count).No := c_No(J).No;
              c_Invoce(c_Invoce.Count).序号 := Case
                                               When Instr(c_No(J).序号, ',') > 0 Then
                                                Substr(c_No(J).序号, 2)
                                               Else
                                                c_No(J).序号
                                             End;
              c_Invoce(c_Invoce.Count).关联序号 := n_关联序号;
            End Loop;
            本次发票张数_Out := 本次发票张数_Out + 1;
            本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
            v_发票号         := Zl_Incstr(v_发票号);
            c_No.Delete;
          End If;
        End Loop;
      End If;
    
      If (n_分单据打印 = 1 Or n_执行科室 > 0) And (n_收据费目 <> 0 Or n_收费细目 <> 0) Then
        n_元素2_Count := 0;
        v_元素1       := '+';
        n_元素2       := 0;
        c_Split_No.Delete;
        For c_分页 In (With c_费用 As
                        (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                               Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, 0, a.收费细目id) As 元素4, a.No As 单据,
                               Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
                        From 门诊费用记录 A,
                             (Select /*+cardinality(j,10)*/
                                NO, 序号
                               From 票据打印明细 M, Table(f_Str2list(回收发票_In)) J
                               Where m.票号 = j.Column_Value) B
                        Where Mod(记录性质, 10) = 1 And a.No = b.No And
                              Instr(',' || b.序号 || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 And
                             
                              Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
                        Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
                        Having Sum(Nvl(a.付数, 1) * a.数次) <> 0)
                       Select a.元素1, a.元素2, b.编码, Count(*) As 个数
                       From c_费用 A, 部门表 B
                       Where a.元素2 = b.Id(+)
                       Group By 元素1, b.编码, 元素2
                       Order By 元素1, b.编码, 元素2) Loop
          If (v_元素1 <> c_分页.元素1) Or (n_元素2 <> c_分页.元素2 And n_元素2_Count >= n_执行科室 And n_执行科室 <> 0) Then
            c_Split_No.Extend;
            n_元素2_Count := 0;
            v_元素1       := '+';
            n_元素2       := 0;
          End If;
          If (v_元素1 <> c_分页.元素1) Then
            v_元素1 := c_分页.元素1;
            c_Split_No(c_Split_No.Count).元素1 := v_元素1;
          End If;
          If (n_元素2 <> c_分页.元素2) Then
            n_元素2_Count := n_元素2_Count + 1;
            n_元素2 := c_分页.元素2;
            c_Split_No(c_Split_No.Count).元素2集 := c_Split_No(c_Split_No.Count).元素2集 || ',' || n_元素2;
          End If;
        End Loop;
      End If;
    
      --6.(no Or 执行科室)+收费细目
      If (n_分单据打印 = 0 Or n_执行科室 > 0) And n_收据费目 = 0 And n_收费细目 <> 0 Then
      
        For I In 1 .. c_Split_No.Count Loop
          v_元素3 := '+';
          --只有首页汇总的,才有关联序号
          n_关联序号    := n_关联序号 + 1;
          n_元素4_Count := 0;
          For c_分页 In (With c_费用 As
                          (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                                 Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, 0, a.收费细目id) As 元素4, a.No As 单据,
                                 Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
                          From 门诊费用记录 A,
                               (Select /*+cardinality(j,10)*/
                                  NO, 序号
                                 From 票据打印明细 M, Table(f_Str2list(回收发票_In)) J
                                 Where m.票号 = j.Column_Value) B
                          Where Mod(记录性质, 10) = 1 And a.No = b.No And
                                Instr(',' || b.序号 || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 And
                               
                                Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
                          Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
                          Having Sum(Nvl(a.付数, 1) * a.数次) <> 0)
                         Select 元素1, 元素2, 元素3, a.元素4, a.单据, a.序号, Count(*) As 个数
                         From c_费用 A
                         Where a.元素1 = c_Split_No(I).元素1 And
                               Instr(',' || c_Split_No(I).元素2集 || ',', ',' || a.元素2 || ',') > 0
                         Group By 元素1, 元素2, 元素4, 元素3, 单据, a.序号
                         Order By 元素1, 元素2, 元素4, 单据, 序号) Loop
            If n_元素4_Count >= n_收费细目 And n_收费细目 <> 0 Then
              --分配单据
              If c_No.Count <> 0 Then
                --分页:计算发票号及相关的
                For J In 1 .. c_No.Count Loop
                  c_Invoce.Extend;
                  c_Invoce(c_Invoce.Count).票号 := v_发票号;
                  c_Invoce(c_Invoce.Count).No := c_No(J).No;
                  c_Invoce(c_Invoce.Count).序号 := Case
                                                   When Instr(c_No(J).序号, ',') > 0 Then
                                                    Substr(c_No(J).序号, 2)
                                                   Else
                                                    c_No(J).序号
                                                 End;
                  c_Invoce(c_Invoce.Count).关联序号 := n_元素4_Count;
                End Loop;
                本次发票张数_Out := 本次发票张数_Out + 1;
                本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
                v_发票号         := Zl_Incstr(v_发票号);
                c_No.Delete;
              End If;
              n_元素4_Count := 0;
            End If;
            n_元素4_Count := n_元素4_Count + 1;
          
            -------------------------------------------
            --分配单据号及序号
            n_Find := 0;
            For J In 1 .. c_No.Count Loop
              If c_No(J).No = c_分页.单据 Then
                --单据号相同,将序号合并
                c_No(J).序号 := c_No(J).序号 || ',' || c_分页.序号;
                n_Find := 1;
                Exit;
              End If;
            End Loop;
            If n_Find = 0 Then
              c_No.Extend;
              c_No(c_No.Count).No := c_分页.单据;
              c_No(c_No.Count).序号 := c_No(c_No.Count).序号 || ',' || c_分页.序号;
            End If;
          End Loop;
          --分配单据
          If c_No.Count <> 0 Then
            --分页:计算发票号及相关的
            For J In 1 .. c_No.Count Loop
              c_Invoce.Extend;
              c_Invoce(c_Invoce.Count).票号 := v_发票号;
              c_Invoce(c_Invoce.Count).No := c_No(J).No;
              c_Invoce(c_Invoce.Count).序号 := Case
                                               When Instr(c_No(J).序号, ',') > 0 Then
                                                Substr(c_No(J).序号, 2)
                                               Else
                                                c_No(J).序号
                                             End;
              c_Invoce(c_Invoce.Count).关联序号 := n_元素4_Count;
            End Loop;
            本次发票张数_Out := 本次发票张数_Out + 1;
            本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
            v_发票号         := Zl_Incstr(v_发票号);
            c_No.Delete;
          End If;
        End Loop;
      End If;
    
      --7.(no Or 执行科室)+收据费目+收费细目
      n_关联序号 := 0;
      If (n_分单据打印 = 0 Or n_执行科室 > 0) And n_收据费目 <> 0 And n_收费细目 <> 0 Then
        c_Split_费目.Delete;
        For I In 1 .. c_Split_No.Count Loop
        
          n_关联序号    := n_关联序号 + 1;
          v_元素3       := '+';
          n_元素3_Count := 0;
          l_元素3.Delete;
          For c_分页 In (With c_费用 As
                          (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                                 Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, 0, a.收费细目id) As 元素4, a.No As 单据,
                                 Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
                          From 门诊费用记录 A,
                               (Select /*+cardinality(j,10)*/
                                  NO, 序号
                                 From 票据打印明细 M, Table(f_Str2list(回收发票_In)) J
                                 Where m.票号 = j.Column_Value) B
                          Where Mod(记录性质, 10) = 1 And a.No = b.No And
                                Instr(',' || b.序号 || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 And
                               
                                Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
                          Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
                          Having Sum(Nvl(a.付数, 1) * a.数次) <> 0)
                         Select a.元素3, Count(*) As 个数
                         From c_费用 A
                         Where a.元素1 = c_Split_No(I).元素1 And
                               Instr(',' || c_Split_No(I).元素2集 || ',', ',' || a.元素2 || ',') > 0
                         Group By 元素3
                         Order By 元素3) Loop
          
            If (v_元素3 <> c_分页.元素3 And n_元素3_Count >= n_收据费目 And n_收据费目 <> 0) Then
              If v_元素3 <> '+' Then
                c_Split_费目.Extend;
                c_Split_费目(c_Split_费目.Count).元素1 := c_Split_No(I).元素1;
                c_Split_费目(c_Split_费目.Count).元素2集 := c_Split_No(I).元素2集;
                c_Split_费目(c_Split_费目.Count).关联序号 := n_关联序号;
                For J In 1 .. l_元素3.Count Loop
                  --单据号相同,将序号合并
                  c_Split_费目(c_Split_费目.Count).元素3集 := c_Split_费目(c_Split_费目.Count).元素3集 || ',' || l_元素3(J);
                End Loop;
              End If;
              v_元素3       := '+';
              n_元素3_Count := 0;
              l_元素3.Delete;
            End If;
            If (v_元素3 <> c_分页.元素3) Then
              n_元素3_Count := n_元素3_Count + 1;
              v_元素3       := c_分页.元素3;
              l_元素3.Extend;
              l_元素3(l_元素3.Count) := v_元素3;
            End If;
          End Loop;
        
          If l_元素3.Count <> 0 Then
            c_Split_费目.Extend;
            c_Split_费目(c_Split_费目.Count).元素1 := c_Split_No(I).元素1;
            c_Split_费目(c_Split_费目.Count).元素2集 := c_Split_No(I).元素2集;
            c_Split_费目(c_Split_费目.Count).关联序号 := n_关联序号;
            For J In 1 .. l_元素3.Count Loop
              --单据号相同,将序号合并
              c_Split_费目(c_Split_费目.Count).元素3集 := c_Split_费目(c_Split_费目.Count).元素3集 || ',' || l_元素3(J);
            End Loop;
          End If;
        End Loop;
      
        For I In 1 .. c_Split_费目.Count Loop
          c_No.Delete;
          n_元素4_Count := 0;
          For c_分页 In (With c_费用 As
                          (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                                 Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, 0, a.收费细目id) As 元素4, a.No As 单据,
                                 Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
                          From 门诊费用记录 A,
                               (Select /*+cardinality(j,10)*/
                                  NO, 序号
                                 From 票据打印明细 M, Table(f_Str2list(回收发票_In)) J
                                 Where m.票号 = j.Column_Value) B
                          Where Mod(记录性质, 10) = 1 And a.No = b.No And
                                Instr(',' || b.序号 || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 And
                               
                                Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
                          Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
                          Having Sum(Nvl(a.付数, 1) * a.数次) <> 0)
                         Select 元素1, 元素2, 元素3, a.元素4, a.单据, a.序号, Count(*) As 个数
                         From c_费用 A
                         Where a.元素1 = c_Split_费目(I).元素1 And
                               Instr(',' || c_Split_费目(I).元素2集 || ',', ',' || a.元素2 || ',') > 0 And
                               Instr(',' || c_Split_费目(I).元素3集 || ',', ',' || a.元素3 || ',') > 0
                         Group By 元素1, 元素2, 元素4, 元素3, a.单据, a.序号
                         Order By 元素1, 元素2, 元素4, 元素3, 单据, 序号) Loop
            If (n_元素4_Count >= n_收费细目 And n_收费细目 <> 0) Then
              --分配单据
              If c_No.Count <> 0 Then
                --分页:计算发票号及相关的
                For J In 1 .. c_No.Count Loop
                  c_Invoce.Extend;
                  c_Invoce(c_Invoce.Count).票号 := v_发票号;
                  c_Invoce(c_Invoce.Count).No := c_No(J).No;
                  c_Invoce(c_Invoce.Count).序号 := Case
                                                   When Instr(c_No(J).序号, ',') > 0 Then
                                                    Substr(c_No(J).序号, 2)
                                                   Else
                                                    c_No(J).序号
                                                 End;
                  c_Invoce(c_Invoce.Count).关联序号 := c_Split_费目(I).关联序号;
                End Loop;
                本次发票张数_Out := 本次发票张数_Out + 1;
                本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
                v_发票号         := Zl_Incstr(v_发票号);
                c_No.Delete;
              End If;
              n_元素4_Count := 0;
            End If;
            n_元素4_Count := n_元素4_Count + 1;
            -------------------------------------------
            --分配单据号及序号
            n_Find := 0;
            For J In 1 .. c_No.Count Loop
              If c_No(J).No = c_分页.单据 Then
                --单据号相同,将序号合并
                c_No(J).序号 := c_No(J).序号 || ',' || c_分页.序号;
                n_Find := 1;
                Exit;
              End If;
            End Loop;
            If n_Find = 0 Then
              c_No.Extend;
              c_No(c_No.Count).No := c_分页.单据;
              c_No(c_No.Count).序号 := c_No(c_No.Count).序号 || ',' || c_分页.序号;
            End If;
          End Loop;
        
          --分配单据
          If c_No.Count <> 0 Then
            --分页:计算发票号及相关的
            For J In 1 .. c_No.Count Loop
              c_Invoce.Extend;
              c_Invoce(c_Invoce.Count).票号 := v_发票号;
              c_Invoce(c_Invoce.Count).No := c_No(J).No;
              c_Invoce(c_Invoce.Count).序号 := Case
                                               When Instr(c_No(J).序号, ',') > 0 Then
                                                Substr(c_No(J).序号, 2)
                                               Else
                                                c_No(J).序号
                                             End;
              c_Invoce(c_Invoce.Count).关联序号 := c_Split_费目(I).关联序号;
            End Loop;
            本次发票张数_Out := 本次发票张数_Out + 1;
            本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
            v_发票号         := Zl_Incstr(v_发票号);
            c_No.Delete;
          End If;
        End Loop;
      End If;
    
      --退费和重打按发票号处理(结束)
      --******************************************************************************************************************************
      If Instr(Nvl(本次打印发票_Out, '-'), ',') > 0 Then
        本次打印发票_Out := Substr(本次打印发票_Out, 2);
      End If;
      Return;
    
    End If;
  
    --******************************************************************************************************************************
    --以下是按正常分配单据(开始)
    --4.收据费目+收费细目
    If n_分单据打印 = 0 And n_执行科室 = 0 And n_收据费目 <> 0 And n_收费细目 <> 0 Then
      v_元素3 := '+';
      c_Split_费目.Delete;
    
      For c_分页 In (With c_费用 As
                      (Select /*+cardinality(b,10)*/
                       Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                       Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, 0, a.收费细目id) As 元素4, a.No As 单据,
                       Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
                      From 门诊费用记录 A, Table(Print_Nos) B
                      Where Mod(记录性质, 10) = 1 And a.No = b.Column_Value And Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
                      Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
                      Having Sum(Nvl(a.付数, 1) * a.数次) <> 0)
                     Select a.元素3, Count(*) As 个数 From c_费用 A Group By 元素3 Order By 元素3) Loop
        If (v_元素3 <> c_分页.元素3 And n_元素3_Count >= n_收据费目 And n_收据费目 <> 0) Then
          If v_元素3 <> '+' Then
            c_Split_费目.Extend;
            For J In 1 .. l_元素3.Count Loop
              --单据号相同,将序号合并
              c_Split_费目(c_Split_费目.Count).元素3集 := c_Split_费目(c_Split_费目.Count).元素3集 || ',' || l_元素3(J);
            End Loop;
            v_元素3       := '+';
            n_元素3_Count := 0;
            l_元素3.Delete;
          End If;
        End If;
        If (v_元素3 <> c_分页.元素3) Then
          n_元素3_Count := n_元素3_Count + 1;
          v_元素3       := c_分页.元素3;
          l_元素3.Extend;
          l_元素3(l_元素3.Count) := v_元素3;
        End If;
      End Loop;
      If l_元素3.Count <> 0 Then
        c_Split_费目.Extend;
        For J In 1 .. l_元素3.Count Loop
          --单据号相同,将序号合并
          c_Split_费目(c_Split_费目.Count).元素3集 := c_Split_费目(c_Split_费目.Count).元素3集 || ',' || l_元素3(J);
        End Loop;
      End If;
      n_关联序号 := 0;
      For I In 1 .. c_Split_费目.Count Loop
        c_No.Delete;
        n_关联序号    := n_关联序号 + 1;
        n_元素4_Count := 0;
        For c_分页 In (With c_费用 As
                        (Select /*+cardinality(b,10)*/
                         Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                         Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, 0, a.收费细目id) As 元素4, a.No As 单据,
                         Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
                        From 门诊费用记录 A, Table(Print_Nos) B
                        Where Mod(记录性质, 10) = 1 And a.No = b.Column_Value And Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
                        Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
                        Having Sum(Nvl(a.付数, 1) * a.数次) <> 0)
                       Select m.元素1, 元素2, 元素3, m.元素4, m.单据, m.序号, Count(*) As 个数
                       From c_费用 M
                       Where Instr(',' || c_Split_费目(I).元素3集 || ',', ',' || m.元素3 || ',') > 0
                       Group By m.元素1, 元素2, m.元素4, 元素3, m.单据, m.序号
                       Order By m.元素1, 元素2, m.元素4, 元素3, m.单据, m.序号) Loop
          If n_元素4_Count >= n_收费细目 And n_收费细目 <> 0 Then
            --分页:计算发票号及相关的
            For J In 1 .. c_No.Count Loop
              c_Invoce.Extend;
              c_Invoce(c_Invoce.Count).票号 := v_发票号;
              c_Invoce(c_Invoce.Count).No := c_No(J).No;
              c_Invoce(c_Invoce.Count).序号 := Case
                                               When Instr(c_No(J).序号, ',') > 0 Then
                                                Substr(c_No(J).序号, 2)
                                               Else
                                                c_No(J).序号
                                             End;
              c_Invoce(c_Invoce.Count).关联序号 := n_关联序号;
            End Loop;
            本次发票张数_Out := 本次发票张数_Out + 1;
            本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
            v_发票号         := Zl_Incstr(v_发票号);
            c_No.Delete;
            n_元素4_Count := 0;
            --分页
          End If;
          n_元素4_Count := n_元素4_Count + 1;
          -------------------------------------------
          --分配单据号及序号
          n_Find := 0;
          For J In 1 .. c_No.Count Loop
            If c_No(J).No = c_分页.单据 Then
              --单据号相同,将序号合并
              c_No(J).序号 := c_No(J).序号 || ',' || c_分页.序号;
              n_Find := 1;
              Exit;
            End If;
          End Loop;
          If n_Find = 0 Then
            c_No.Extend;
            c_No(c_No.Count).No := c_分页.单据;
            c_No(c_No.Count).序号 := c_No(c_No.Count).序号 || ',' || c_分页.序号;
          End If;
        End Loop;
        If c_No.Count <> 0 Then
          --分页:计算发票号及相关的
          For J In 1 .. c_No.Count Loop
            c_Invoce.Extend;
            c_Invoce(c_Invoce.Count).票号 := v_发票号;
            c_Invoce(c_Invoce.Count).No := c_No(J).No;
            c_Invoce(c_Invoce.Count).序号 := Case
                                             When Instr(c_No(J).序号, ',') > 0 Then
                                              Substr(c_No(J).序号, 2)
                                             Else
                                              c_No(J).序号
                                           End;
            c_Invoce(c_Invoce.Count).关联序号 := n_关联序号;
          End Loop;
          本次发票张数_Out := 本次发票张数_Out + 1;
          本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
          v_发票号         := Zl_Incstr(v_发票号);
          c_No.Delete;
        End If;
      End Loop;
    End If;
  
    If (n_分单据打印 = 1 Or n_执行科室 > 0) And (n_收据费目 <> 0 Or n_收费细目 <> 0) Then
      n_元素2_Count := 0;
      v_元素1       := '+';
      n_元素2       := 0;
      c_Split_No.Delete;
      For c_分页 In (With c_费用 As
                      (Select /*+cardinality(b,10)*/
                       Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                       Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, 0, a.收费细目id) As 元素4, a.No As 单据,
                       Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
                      From 门诊费用记录 A, Table(Print_Nos) B
                      Where Mod(记录性质, 10) = 1 And a.No = b.Column_Value And Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
                      Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
                      Having Sum(Nvl(a.付数, 1) * a.数次) <> 0)
                     Select a.元素1, a.元素2, b.编码, Count(*) As 个数
                     From c_费用 A, 部门表 B
                     Where a.元素2 = b.Id(+)
                     Group By 元素1, b.编码, 元素2
                     Order By 元素1, b.编码, 元素2) Loop
        If (v_元素1 <> c_分页.元素1) Or (n_元素2 <> c_分页.元素2 And n_元素2_Count >= n_执行科室 And n_执行科室 <> 0) Then
          c_Split_No.Extend;
          n_元素2_Count := 0;
          v_元素1       := '+';
          n_元素2       := 0;
        End If;
        If (v_元素1 <> c_分页.元素1) Then
          v_元素1 := c_分页.元素1;
          c_Split_No(c_Split_No.Count).元素1 := v_元素1;
        End If;
        If (n_元素2 <> c_分页.元素2) Then
          n_元素2_Count := n_元素2_Count + 1;
          n_元素2 := c_分页.元素2;
          c_Split_No(c_Split_No.Count).元素2集 := c_Split_No(c_Split_No.Count).元素2集 || ',' || n_元素2;
        End If;
      End Loop;
    End If;
  
    --3.(no Or 执行科室)+收费细目
    If (n_分单据打印 = 0 Or n_执行科室 > 0) And n_收据费目 = 0 And n_收费细目 <> 0 Then
    
      For I In 1 .. c_Split_No.Count Loop
        v_元素3 := '+';
        --只有首页汇总的,才有关联序号
        n_关联序号    := Nvl(n_关联序号, 0) + 1;
        n_元素4_Count := 0;
        For c_分页 In (With c_费用 As
                        (Select /*+cardinality(b,10)*/
                         Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                         Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, 0, a.收费细目id) As 元素4, a.No As 单据,
                         Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
                        From 门诊费用记录 A, Table(Print_Nos) B
                        Where Mod(记录性质, 10) = 1 And a.No = b.Column_Value And Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
                        Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
                        Having Sum(Nvl(a.付数, 1) * a.数次) <> 0)
                       Select 元素1, 元素2, 元素3, a.元素4, a.单据, a.序号, Count(*) As 个数
                       From c_费用 A
                       Where a.元素1 = c_Split_No(I).元素1 And
                             Instr(',' || c_Split_No(I).元素2集 || ',', ',' || a.元素2 || ',') > 0
                       Group By 元素1, 元素2, 元素4, 元素3, 单据, a.序号
                       Order By 元素1, 元素2, 元素4, 单据, 序号) Loop
          If n_元素4_Count >= n_收费细目 And n_收费细目 <> 0 Then
            --分配单据
            If c_No.Count <> 0 Then
              --分页:计算发票号及相关的
              For J In 1 .. c_No.Count Loop
                c_Invoce.Extend;
                c_Invoce(c_Invoce.Count).票号 := v_发票号;
                c_Invoce(c_Invoce.Count).No := c_No(J).No;
                c_Invoce(c_Invoce.Count).序号 := Case
                                                 When Instr(c_No(J).序号, ',') > 0 Then
                                                  Substr(c_No(J).序号, 2)
                                                 Else
                                                  c_No(J).序号
                                               End;
                c_Invoce(c_Invoce.Count).关联序号 := n_关联序号;
              End Loop;
              本次发票张数_Out := 本次发票张数_Out + 1;
              本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
              v_发票号         := Zl_Incstr(v_发票号);
              c_No.Delete;
            End If;
            n_元素4_Count := 0;
          End If;
          n_元素4_Count := n_元素4_Count + 1;
        
          -------------------------------------------
          --分配单据号及序号
          n_Find := 0;
          For J In 1 .. c_No.Count Loop
            If c_No(J).No = c_分页.单据 Then
              --单据号相同,将序号合并
              c_No(J).序号 := c_No(J).序号 || ',' || c_分页.序号;
              n_Find := 1;
              Exit;
            End If;
          End Loop;
          If n_Find = 0 Then
            c_No.Extend;
            c_No(c_No.Count).No := c_分页.单据;
            c_No(c_No.Count).序号 := c_No(c_No.Count).序号 || ',' || c_分页.序号;
          End If;
        End Loop;
        --分配单据
        If c_No.Count <> 0 Then
          --分页:计算发票号及相关的
          For J In 1 .. c_No.Count Loop
            c_Invoce.Extend;
            c_Invoce(c_Invoce.Count).票号 := v_发票号;
            c_Invoce(c_Invoce.Count).No := c_No(J).No;
            c_Invoce(c_Invoce.Count).序号 := Case
                                             When Instr(c_No(J).序号, ',') > 0 Then
                                              Substr(c_No(J).序号, 2)
                                             Else
                                              c_No(J).序号
                                           End;
            c_Invoce(c_Invoce.Count).关联序号 := n_关联序号;
          End Loop;
          本次发票张数_Out := 本次发票张数_Out + 1;
          本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
          v_发票号         := Zl_Incstr(v_发票号);
          c_No.Delete;
        End If;
      End Loop;
    End If;
  
    --7.(no Or 执行科室)+收据费目+收费细目
    n_关联序号 := 0;
    If (n_分单据打印 = 0 Or n_执行科室 > 0) And n_收据费目 <> 0 And n_收费细目 <> 0 Then
      c_Split_费目.Delete;
    
      For I In 1 .. c_Split_No.Count Loop
      
        n_关联序号    := n_关联序号 + 1;
        v_元素3       := '+';
        n_元素3_Count := 0;
        l_元素3.Delete;
        For c_分页 In (With c_费用 As
                        (Select /*+cardinality(b,10)*/
                         Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                         Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, 0, a.收费细目id) As 元素4, a.No As 单据,
                         Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
                        From 门诊费用记录 A, Table(Print_Nos) B
                        Where Mod(记录性质, 10) = 1 And a.No = b.Column_Value And Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
                        Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
                        Having Sum(Nvl(a.付数, 1) * a.数次) <> 0)
                       Select a.元素3, Count(*) As 个数
                       From c_费用 A
                       Where a.元素1 = c_Split_No(I).元素1 And
                             Instr(',' || c_Split_No(I).元素2集 || ',', ',' || a.元素2 || ',') > 0
                       Group By 元素3
                       Order By 元素3) Loop
          If (v_元素3 <> c_分页.元素3 And n_元素3_Count >= n_收据费目 And n_收据费目 <> 0) Then
            If v_元素3 <> '+' Then
              c_Split_费目.Extend;
              c_Split_费目(c_Split_费目.Count).元素1 := c_Split_No(I).元素1;
              c_Split_费目(c_Split_费目.Count).元素2集 := c_Split_No(I).元素2集;
              c_Split_费目(c_Split_费目.Count).关联序号 := n_关联序号;
              For J In 1 .. l_元素3.Count Loop
                --单据号相同,将序号合并
                c_Split_费目(c_Split_费目.Count).元素3集 := c_Split_费目(c_Split_费目.Count).元素3集 || ',' || l_元素3(J);
              End Loop;
            End If;
            v_元素3       := '+';
            n_元素3_Count := 0;
            l_元素3.Delete;
          End If;
          If (v_元素3 <> c_分页.元素3) Then
            n_元素3_Count := n_元素3_Count + 1;
            v_元素3       := c_分页.元素3;
            l_元素3.Extend;
            l_元素3(l_元素3.Count) := v_元素3;
          End If;
        End Loop;
      
        If l_元素3.Count <> 0 Then
          c_Split_费目.Extend;
          c_Split_费目(c_Split_费目.Count).元素1 := c_Split_No(I).元素1;
          c_Split_费目(c_Split_费目.Count).元素2集 := c_Split_No(I).元素2集;
          c_Split_费目(c_Split_费目.Count).关联序号 := n_关联序号;
          For J In 1 .. l_元素3.Count Loop
            --单据号相同,将序号合并
            c_Split_费目(c_Split_费目.Count).元素3集 := c_Split_费目(c_Split_费目.Count).元素3集 || ',' || l_元素3(J);
          End Loop;
        End If;
      End Loop;
    
      For I In 1 .. c_Split_费目.Count Loop
        c_No.Delete;
        n_元素4_Count := 0;
        --收费细目,按条数计数,还是要按执行科室+收据费目
        For c_分页 In (With c_费用 As
                        (Select /*+cardinality(b,10)*/
                         Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                         Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, 0, a.收费细目id) As 元素4, a.No As 单据,
                         Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
                        From 门诊费用记录 A, Table(Print_Nos) B
                        Where Mod(记录性质, 10) = 1 And a.No = b.Column_Value And Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
                        Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
                        Having Sum(Nvl(a.付数, 1) * a.数次) <> 0)
                       Select 元素1, 元素2, 元素3, a.元素4, a.单据, a.序号, Count(*) As 个数
                       From c_费用 A
                       Where a.元素1 = c_Split_费目(I).元素1 And
                             Instr(',' || c_Split_费目(I).元素2集 || ',', ',' || a.元素2 || ',') > 0 And
                             Instr(',' || c_Split_费目(I).元素3集 || ',', ',' || a.元素3 || ',') > 0
                       Group By 元素1, 元素2, 元素4, 元素3, a.单据, a.序号
                       Order By 元素1, 元素2, 元素4, 元素3, 单据, 序号) Loop
          If (n_元素4_Count >= n_收费细目 And n_收费细目 <> 0) Then
            --分配单据
            If c_No.Count <> 0 Then
              --分页:计算发票号及相关的
              For J In 1 .. c_No.Count Loop
                c_Invoce.Extend;
                c_Invoce(c_Invoce.Count).票号 := v_发票号;
                c_Invoce(c_Invoce.Count).No := c_No(J).No;
                c_Invoce(c_Invoce.Count).序号 := Case
                                                 When Instr(c_No(J).序号, ',') > 0 Then
                                                  Substr(c_No(J).序号, 2)
                                                 Else
                                                  c_No(J).序号
                                               End;
                c_Invoce(c_Invoce.Count).关联序号 := c_Split_费目(I).关联序号;
              End Loop;
              本次发票张数_Out := 本次发票张数_Out + 1;
              本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
              v_发票号         := Zl_Incstr(v_发票号);
              c_No.Delete;
            End If;
            n_元素4_Count := 0;
          End If;
          n_元素4_Count := n_元素4_Count + 1;
          -------------------------------------------
          --分配单据号及序号
          n_Find := 0;
          For J In 1 .. c_No.Count Loop
            If c_No(J).No = c_分页.单据 Then
              --单据号相同,将序号合并
              c_No(J).序号 := c_No(J).序号 || ',' || c_分页.序号;
              n_Find := 1;
              Exit;
            End If;
          End Loop;
          If n_Find = 0 Then
            c_No.Extend;
            c_No(c_No.Count).No := c_分页.单据;
            c_No(c_No.Count).序号 := c_No(c_No.Count).序号 || ',' || c_分页.序号;
          End If;
        End Loop;
        --分配单据
        If c_No.Count <> 0 Then
          --分页:计算发票号及相关的
          For J In 1 .. c_No.Count Loop
            c_Invoce.Extend;
            c_Invoce(c_Invoce.Count).票号 := v_发票号;
            c_Invoce(c_Invoce.Count).No := c_No(J).No;
            c_Invoce(c_Invoce.Count).序号 := Case
                                             When Instr(c_No(J).序号, ',') > 0 Then
                                              Substr(c_No(J).序号, 2)
                                             Else
                                              c_No(J).序号
                                           End;
            c_Invoce(c_Invoce.Count).关联序号 := c_Split_费目(I).关联序号;
          End Loop;
          本次发票张数_Out := 本次发票张数_Out + 1;
          本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
          v_发票号         := Zl_Incstr(v_发票号);
          c_No.Delete;
        End If;
      End Loop;
    End If;
    --正常分配单据结束
    --******************************************************************************************************************************
    If Instr(Nvl(本次打印发票_Out, '-'), ',') > 0 Then
      本次打印发票_Out := Substr(本次打印发票_Out, 2);
    End If;
  End Invoice_Split_Group;
  -------------------------------------------------------------------------------------------------------------------
Begin

  --启用标志||NO;执行科室(条数);收据费目(首页汇总,条数);收费细目(条数)
  v_Para := Nvl(zl_GetSysParameter('票据分配规则', 1121), '0||0;0;0,0;0');
  If Instr(v_Para, '||') = 0 Then
    v_Para := v_Para || '||';
  End If;
  v_Temp := Substr(v_Para, 1, Instr(v_Para, '||') - 1);
  If v_Temp Is Null Then
    --无设置值,代表无启用,直接返回
    Return;
  End If;

  --0-根据实际打印分配票号;1-根据预定规则分配票号;2-.根据自定义规则分配票号
  n_启用模式 := Zl_To_Number(v_Temp);
  If Nvl(n_启用模式, 0) = 0 Then
    --0-根据实际打印分配票号:按原来的处理方式分配票据,直接退出
    Return;
  End If;

  v_Temp       := Nvl(zl_GetSysParameter('误差项不使用票据', 1121), '0');
  n_误差项     := Zl_To_Number(v_Temp);
  v_起始发票号 := 起始发票号_In;

  If v_起始发票号 Is Null Then
    --模拟计算时,可以不传入起始发票号
    If Nvl(领用id_In, 0) <> 0 Then
      Open c_Fact;
      Fetch c_Fact
        Into r_Factrow;
    
      If c_Fact%RowCount <> 0 Then
        If Nvl(r_Factrow.当前号码, '-') <> '-' Then
          v_起始发票号 := Zl_Incstr(r_Factrow.当前号码);
        Else
          v_起始发票号 := r_Factrow.开始号码;
        End If;
      End If;
    End If;
    If v_起始发票号 Is Null Then
      v_起始发票号 := 'J0000001';
    End If;
  End If;

  v_发票号   := v_起始发票号;
  v_发票信息 := Null;

  n_按病人补打票据 := 0;
  --按单据分配票据
  If 操作类型_In = 3 Or 操作类型_In = 4 Then
    --1-正常打印票据;2-补打票据;3-重打票据;4-退费收回票据并重新发出票据
    If 发票号_In Is Null Then
      v_Err_Msg := '未传入指定的回收票据,不允许' || Case
                     When 操作类型_In = 1 Then
                      '重打票据。'
                     Else
                      '补打票据。'
                   End;
      Raise Err_Item;
    End If;
  
    --读取当前票据所涉及的所有票据
    Select 单据号 Bulk Collect
    Into l_Print_Nos
    From (Select /*+cardinality(j,10)*/
           Distinct c.No As 单据号
           From 票据打印明细 A, 票据使用明细 B, 票据打印内容 C, Table(f_Str2list(发票号_In)) J
           Where a.使用id = b.Id And b.打印id = c.Id And a.票号 = j.Column_Value
           Order By 单据号);
  
    If l_Print_Nos.Count = 0 Then
      v_Err_Msg := '未找到指定发票(' || 发票号_In || '所对应的收费单据!';
      Raise Err_Item;
    End If;
  
    Select /*+cardinality(b,10)*/
     Max(打印类型)
    Into n_打印类型
    From 票据打印内容 A, Table(l_Print_Nos) B
    Where a.No = b.Column_Value And a.数据性质 = 1;
  
    If Nvl(n_打印类型, 0) = 1 Then
      --一次打印有多次结算的，则表示以前为按病人打印的
      n_按病人补打票据 := 1;
      n_打印类型       := 1;
    End If;
  
  Elsif 打印id_In <> 0 Then
    n_按病人补打票据 := 1;
    n_打印类型       := 1;
    Select 单据号 Bulk Collect
    Into l_Print_Nos
    From (Select Distinct NO As 单据号
           From 临时票据打印内容 A
           Where a.Id = 打印id_In And Nvl(a.性质, 0) = 1
           Order By 单据号);
    If l_Print_Nos.Count = 0 Then
      v_Err_Msg := '未找到本次需要分配票据的单据信息(打印ID=' || 打印id_In || ')!';
      Raise Err_Item;
    End If;
  Else
    Select Column_Value Bulk Collect Into l_Print_Nos From Table(f_Str2list(Nos_In)) J;
    If l_Print_Nos.Count = 0 Then
      v_Err_Msg := '未找到本次需要分配票据的单据信息(单据信息：' || Nvl(Nos_In, '') || ')!';
      Raise Err_Item;
    End If;
  End If;

  v_Nos := Null;
  If n_启用模式 = 2 Then
    If l_Print_Nos.Count < 3000 Then
      --1.只有自定义模式时，才会涉及可能存在用户调整的情况，加入此判断，主要是为了歉容
      --2.以前不可能超过3000张单据，如果超过3000张单据，需要改造对应的票据,主要适用按病人补打票据的情况
      For I In 1 .. l_Print_Nos.Count Loop
        v_Nos := Nvl(v_Nos, '') || ',' || l_Print_Nos(I);
      
      End Loop;
      v_Nos := Substr(v_Nos, 2);
    End If;
  
    --根据自定义规则分配票号,调用:Zl_Custom_Invoice_Autoallot过程
    Zl_Custom_Invoice_Autoallot(操作类型_In, 模拟计算_In, 票种_In, 领用id_In, 病人id_In, v_Nos, 起始发票号_In, 使用人_In, 使用时间_In,
                                Next领用id_In, Next票据号_In, 发票号_In, 发票张数_In, n_按病人补打票据, 打印id_In, l_Print_Nos);
    Return;
  End If;

  --参数获取:
  --1.根据预定规则分配票号
  --   NO;执行科室(条数);收据费目(首页汇总,条数);收费细目(条数)
  v_Para := Substr(v_Para, Instr(v_Para, '||') + 2);
  If Instr(v_Para, ';') > 0 Then
    --NO:票据是否按单据进行分别打印,1表示按单据打印;0-不按单据打印
    v_Temp       := Substr(v_Para, 1, Instr(v_Para, ';') - 1);
    n_分单据打印 := Zl_To_Number(v_Temp);
    v_Para       := Substr(v_Para, Instr(v_Para, ';') + 1);
  End If;

  If Instr(v_Para, ';') > 0 Then
    --执行科室
    v_Temp     := Nvl(Substr(v_Para, 1, Instr(v_Para, ';') - 1), '0');
    n_执行科室 := Zl_To_Number(v_Temp);
    v_Para     := Substr(v_Para, Instr(v_Para, ';') + 1);
  End If;

  If Instr(v_Para, ';') > 0 Then
    --收据费目
    v_Temp     := Nvl(Substr(v_Para, 1, Instr(v_Para, ';') - 1), '0');
    n_收据费目 := Zl_To_Number(v_Temp);
    v_Para     := Substr(v_Para, Instr(v_Para, ';') + 1);
  End If;

  If Instr(v_Para, ';') > 0 Then
    --收据费目
    v_Temp     := Nvl(Substr(v_Para, 1, Instr(v_Para, ';') - 1), '0');
    n_收费细目 := Zl_To_Number(v_Temp);
    v_Para     := Substr(v_Para, Instr(v_Para, ';') + 1);
  End If;

  If Instr(v_Para, ';') > 0 Then
    --执行科室
    v_Temp := Nvl(Substr(v_Para, 1, Instr(v_Para, ';') - 1), '0');
  Else
    v_Temp := Nvl(v_Para, '0');
  End If;
  n_汇总条件 := Zl_To_Number(v_Temp);

  If n_按病人补打票据 = 1 Then
    --如果打印ID<>0的情况,如果不等零，表示按病人补打发票，则票据将自动不分单据打印，按执行科室打印及收据细目打印
    n_分单据打印 := 0;
    n_执行科室   := 0;
    n_收费细目   := 0;
  End If;

  v_回收票据号 := 发票号_In;
  发票张数_In  := 0;
  --一、首页汇总或不汇总
  If n_汇总条件 <> 2 Then
    Invoice_Split_Notgroup(l_Print_Nos, 发票号_In, v_发票信息, 发票张数_In);
  Else
    --二、分组汇总
    Invoice_Split_Group(l_Print_Nos, 发票号_In, v_发票信息, 发票张数_In);
  End If;

  发票号_In := v_发票信息;
  If 模拟计算_In = 1 Then
    --模拟计算,只返回票据张数和使用的票据号,直接退出
    Return;
  End If;

  v_开始发票号 := Null;
  --1-正常打印票据;2-补打票据;3-重打票据;4-退费收回票据并重新发出票据
  If 操作类型_In = 3 Or 操作类型_In = 4 Then
    --收回票据
    Select 使用id Bulk Collect
    Into l_使用id
    From (Select /*+cardinality(j,10)*/
           Distinct b.使用id
           From 票据使用明细 A, 票据打印明细 B, Table(f_Str2list(v_回收票据号)) J
           Where a.Id = b.使用id And b.票号 = j.Column_Value And Nvl(b.票种, 0) = 1);
  
    --插入回收记录
    Forall I In 1 .. l_使用id.Count
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
        Select 票据使用明细_Id.Nextval, 票种, 号码, 2, Decode(操作类型_In, 3, 4, 2), 领用id, 打印id, 使用人_In, 使用时间_In
        From 票据使用明细
        Where ID = l_使用id(I);
    Forall I In 1 .. l_使用id.Count
      Update 票据打印明细 Set 是否回收 = 1 Where 使用id = l_使用id(I);
  End If;

  If c_Invoce.Count = 0 Then
    --无数据,直接返回
    Return;
  End If;

  If 起始发票号_In Is Null Then
    v_Err_Msg := '未传入起始发票号,不能进行票据分配处理';
    Raise Err_Item;
  End If;

  If Nvl(领用id_In, 0) <> 0 Then
    Open c_Fact;
    Fetch c_Fact
      Into r_Factrow;
    If c_Fact%RowCount = 0 Then
      v_Err_Msg := '无效的票据领用批次，无法完成收费票据分配操作。';
      Close c_Fact;
      Raise Err_Item;
    Elsif Nvl(r_Factrow.剩余数量, 0) < 发票张数_In Then
      --检查下一个批次
      If Next票据号_In Is Null Then
        Close c_Fact;
        v_Err_Msg := '下一个领用批次未传入起始发票号，当前批次的剩余数量不足' || 发票张数_In || '张，不能进行票据分配处理。';
        Raise Err_Item;
      End If;
    
      Open c_Nextfact;
      Fetch c_Nextfact
        Into r_Nextfactrow;
      If c_Nextfact%RowCount = 0 Then
        Close c_Nextfact;
        Close c_Fact;
        v_Err_Msg := '下一个领用批次无效，当前批次的剩余数量不足' || 发票张数_In || '张，无法完成收费票据分配操作。';
        Raise Err_Item;
      Elsif Nvl(r_Factrow.剩余数量, 0) + Nvl(r_Nextfactrow.剩余数量, 0) < 发票张数_In Then
        Close c_Nextfact;
        Close c_Fact;
        v_Err_Msg := '当前批次以及下一个批次的剩余数量之和不足' || 发票张数_In || '张，无法完成收费票据分配操作。';
        Raise Err_Item;
      End If;
    End If;
  End If;

  --重新分配票号
  v_发票号      := v_起始发票号;
  v_发票信息old := v_发票信息;
  v_发票信息    := '';
  v_发票信息tmp := '';
  --领用ID1:发票号1,领用ID2:发票号2,...

  n_领用id := 领用id_In;
  For c_Invoce_No In (Select Column_Value As 发票号 From Table(f_Str2list(v_发票信息old)) Order By 发票号) Loop
    If Nvl(n_领用id, 0) <> 0 Then
      If n_领用id = 领用id_In Then
        --检查当前批次票据范围
        If Not (Upper(v_发票号) >= Upper(r_Factrow.开始号码) And Upper(v_发票号) <= Upper(r_Factrow.终止号码) And
            Length(v_发票号) = Length(r_Factrow.终止号码)) Then
          If Nvl(Next领用id_In, 0) <> 0 And n_领用id <> Nvl(Next领用id_In, 0) Then
            --使用下一个领用批次
            n_领用id := Nvl(Next领用id_In, 0);
            v_发票号 := Next票据号_In;
          Else
            Close c_Nextfact;
            Close c_Fact;
            v_Err_Msg := '单据需要打印多张票据,但票据号"' || v_发票号 || '"超出票据领用的号码范围！';
            Raise Err_Item;
          End If;
        End If;
      End If;
      If n_领用id = Nvl(Next领用id_In, 0) Then
        --检查下一个批次票据范围
        If Not (Upper(v_发票号) >= Upper(r_Nextfactrow.开始号码) And Upper(v_发票号) <= Upper(r_Nextfactrow.终止号码) And
            Length(v_发票号) = Length(r_Nextfactrow.终止号码)) Then
          Close c_Nextfact;
          Close c_Fact;
          v_Err_Msg := '单据需要打印多张票据,但票据号"' || v_发票号 || '"超出票据领用的号码范围！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  
    For I In 1 .. c_Invoce.Count Loop
      If c_Invoce(I).票号 = c_Invoce_No.发票号 Then
        --分配新的发票号
        c_Invoce(I).票号 := v_发票号;
      End If;
    End Loop;
    v_发票信息    := Nvl(v_发票信息, '') || ',' || v_发票号;
    v_发票信息tmp := Nvl(v_发票信息tmp, '') || ',' || n_领用id || ':' || v_发票号;
    v_发票号      := Zl_Incstr(v_发票号);
  End Loop;
  If Instr(Nvl(v_发票信息, '-'), ',') > 0 Then
    发票号_In := Substr(v_发票信息, 2);
  End If;
  If Instr(Nvl(v_发票信息tmp, '-'), ',') > 0 Then
    v_发票信息tmp := Substr(v_发票信息tmp, 2);
  End If;

  --实际处理票据信息
  If Nvl(n_分单据打印, 0) <> 1 Or Nvl(n_按病人补打票据, 0) = 1 Then
    --不分单据打印时,表示一次打印,打印ID填成一致
    n_打印id := 打印id_In;
    If Nvl(n_打印id, 0) = 0 Then
      Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
    End If;
  End If;

  发票张数_In := 0;
  v_打印内容  := '';
  For c_Invoce_No In (Select C1 As 领用id, C2 As 发票号 From Table(f_Str2list2(v_发票信息tmp)) Order By 领用id, 发票号) Loop
  
    --处理票据打印明细
    r_单据号.Delete;
    r_单据序号.Delete;
    l_关联序号.Delete;
  
    Select 票据使用明细_Id.Nextval Into n_使用id From Dual;
  
    n_关联序号 := 0;
  
    For I In 1 .. c_Invoce.Count Loop
      If c_Invoce(I).票号 = c_Invoce_No.发票号 Then
        n_关联序号 := c_Invoce(I).关联序号;
        Exit;
      End If;
    End Loop;
    --处理关联票据,以便回收票据
    For I In 1 .. c_Invoce.Count Loop
      If c_Invoce(I).关联序号 = n_关联序号 And Nvl(c_Invoce(I).修改标志, 0) = 0 Then
        If n_关联序号 <> 0 Then
          c_Invoce(I).关联序号 := n_使用id;
        End If;
        c_Invoce(I).修改标志 := 1;
      End If;
    End Loop;
  
    For I In 1 .. c_Invoce.Count Loop
      If c_Invoce(I).票号 = c_Invoce_No.发票号 Then
        r_单据号.Extend;
        r_单据号(r_单据号.Count) := c_Invoce(I).No;
        r_单据序号.Extend;
        r_单据序号(r_单据序号.Count) := c_Invoce(I).序号;
        l_关联序号.Extend;
        If Nvl(c_Invoce(I).关联序号, 0) <> 0 Then
          --检查是否存在其他的票据
          n_Find := 0;
          For J In 1 .. c_Invoce.Count Loop
            If c_Invoce(I).关联序号 = c_Invoce(J).关联序号 And c_Invoce(I).票号 <> c_Invoce(J).票号 Then
              n_Find := 1;
              Exit;
            End If;
          End Loop;
        
          If n_Find = 0 Then
            l_关联序号(l_关联序号.Count) := Null;
            c_Invoce(I).关联序号 := 0;
          Else
            l_关联序号(l_关联序号.Count) := c_Invoce(I).关联序号;
          End If;
        Else
          l_关联序号(l_关联序号.Count) := Null;
        End If;
      End If;
    End Loop;
  
    --1.处理门打印内容
    If n_分单据打印 = 1 Then
      --分单据打印,需按单据进行处理
      --票据打印内容
      n_Find := 0;
      v_Temp := '';
      For I In 1 .. r_单据号.Count Loop
        v_Temp := v_Temp || ',' || r_单据号(I);
        If Instr(Nvl(v_打印内容, '-') || ',', ',' || r_单据号(I) || ',') > 0 Then
          --已经找到
          n_Find := 1;
        End If;
      End Loop;
      v_打印内容 := v_打印内容 || Nvl(v_Temp, '+');
    
      If Nvl(n_Find, 0) = 0 Then
        Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
        Forall I In 1 .. r_单据号.Count
          Insert Into 票据打印内容 (ID, 数据性质, NO, 打印类型) Values (n_打印id, 1, r_单据号(I), n_打印类型);
        --以便更新门诊费用记录中的实际票号
        v_开始发票号 := c_Invoce_No.发票号;
        Forall I In 1 .. r_单据号.Count
          Update 门诊费用记录 Set 实际票号 = v_开始发票号 Where Mod(记录性质, 10) = 1 And NO = r_单据号(I);
      End If;
    Else
    
      If v_开始发票号 Is Null Then
        --以便更新门诊费用记录中的实际票号
        v_开始发票号 := c_Invoce_No.发票号;
      
        --票据打印内容
        Insert Into 票据打印内容
          (ID, 数据性质, NO, 打印类型)
          Select n_打印id, 1, Column_Value, n_打印类型 From Table(l_Print_Nos);
      
        Update 门诊费用记录
        Set 实际票号 = v_开始发票号
        Where Mod(记录性质, 10) = 1 And NO In (Select Column_Value From Table(l_Print_Nos));
      End If;
    End If;
  
    --2.处理票据打印明细
  
    发票张数_In := 发票张数_In + 1;
    --处理票据使用明细
  
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
    Values
      (n_使用id, 1, c_Invoce_No.发票号, 1, Decode(操作类型_In, 3, 3, 1),
       Decode(Nvl(c_Invoce_No.领用id, 0), 0, Null, c_Invoce_No.领用id), n_打印id, 使用人_In, 使用时间_In);
  
    Forall I In 1 .. r_单据号.Count
      Insert Into 票据打印明细
        (使用id, 票种, 是否回收, NO, 票号, 序号, 关联票号序号)
      Values
        (n_使用id, 1, 0, r_单据号(I), c_Invoce_No.发票号, r_单据序号(I), l_关联序号(I));
  
    Update 票据领用记录
    Set 使用时间 = 使用时间_In, 当前号码 = c_Invoce_No.发票号, 剩余数量 = Nvl(剩余数量, 0) - 1
    Where ID = c_Invoce_No.领用id;
  End Loop;

  If Nvl(领用id_In, 0) <> 0 Then
    Close c_Fact;
    If Nvl(Next领用id_In, 0) <> 0 And Nvl(r_Factrow.剩余数量, 0) < Nvl(发票张数_In, 0) Then
      Close c_Nextfact;
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Invoice_Autoallot;
/

--108706:刘尔旋,2017-05-08,门诊转住院产生三方卡原样住院预交单
Create Or Replace Procedure Zl_门诊转住院_三方卡结算
(
  No_In         住院费用记录.No%Type,
  操作员编号_In 住院费用记录.操作员编号%Type,
  操作员姓名_In 住院费用记录.操作员姓名%Type,
  退费时间_In   住院费用记录.发生时间%Type,
  门诊退费_In   Number := 0,
  入院科室id_In 住院费用记录.开单部门id%Type := Null,
  主页id_In     住院费用记录.主页id%Type := Null,
  三方退费_In   Number := 0,
  结帐id_In     病人预交记录.结帐id%Type := Null
) As
  v_结帐ids    Varchar2(3000);
  n_组id       财务缴款分组.Id%Type;
  n_退现       Number;
  v_预交no     病人预交记录.No%Type;
  n_结帐id     门诊费用记录.结帐id%Type;
  v_Nos        Varchar2(3000);
  v_Info       Varchar2(5000);
  v_当前结算   Varchar2(3000);
  v_原结帐ids  Varchar2(5000);
  n_Tempid     病人预交记录.Id%Type;
  v_流水号     病人预交记录.交易流水号%Type;
  v_说明       病人预交记录.交易说明%Type;
  n_预交id     病人预交记录.Id%Type;
  n_原预交id   病人预交记录.Id%Type;
  n_病人id     病人信息.病人id%Type;
  n_原结帐id   病人预交记录.结帐id%Type;
  n_冲销金额   病人预交记录.冲预交%Type;
  n_卡序号     病人预交记录.卡类别id%Type;
  n_三方卡     Number;
  n_返回值     人员缴款余额.余额%Type;
  v_结算方式   病人预交记录.结算方式%Type;
  n_卡类别id   医疗卡类别.Id%Type;
  v_卡号       病人预交记录.卡号%Type;
  v_交易流水号 病人预交记录.交易流水号%Type;
  v_交易说明   病人预交记录.交易说明%Type;
  n_原样退     Number;
  Err_Item Exception;
  v_Err_Msg Varchar2(200);
  Procedure Zl_Square_Update
  (
    结帐ids_In    Varchar2,
    现结帐id_In   病人预交记录.结帐id%Type,
    缴款组id_In   病人预交记录.缴款组id%Type,
    退款时间_In   病人预交记录.收款时间%Type,
    结算序号_In   病人预交记录.结算序号%Type,
    结算内容_In   Varchar2 := Null,
    退费金额_In   病人预交记录.冲预交%Type := Null,
    结算卡序号_In 病人预交记录.结算卡序号%Type := Null
  ) As
    n_记录状态 病人卡结算记录.记录状态%Type;
    n_预交id   病人预交记录.Id%Type;
    v_卡号     病人卡结算记录.卡号%Type;
    n_存在卡片 Number;
    d_停用日期 消费卡目录.停用日期%Type;
    n_最大序号 病人卡结算记录.序号%Type;
    n_序号     病人卡结算记录.序号%Type;
    n_余额     消费卡目录.余额%Type;
    n_接口编号 病人卡结算记录.接口编号%Type;
    d_回收时间 消费卡目录.回收时间%Type;
    n_Id       病人预交记录.Id%Type;
  Begin
    n_预交id := 0;
  
    --处理消费卡,结算卡在上面就已经处理了
    For v_校对 In (Select Min(a.Id) As 预交id, c.消费卡id, Sum(c.结算金额) As 结算金额, c.接口编号, c.卡号, Min(c.序号) As 序号, Min(c.Id) As ID
                 From 病人预交记录 A, 病人卡结算对照 B, 病人卡结算记录 C
                 Where a.Id = b.预交id And a.结算卡序号 = 结算卡序号_In And b.卡结算id = c.Id And a.记录性质 = 3 And
                       Instr(Nvl(结算内容_In, '_LXH'), ',' || a.结算方式 || ',') = 0 And
                       a.结帐id In (Select Column_Value From Table(f_Str2list(结帐ids_In)))
                 Group By c.消费卡id, c.接口编号, c.卡号) Loop
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id = Nvl(v_校对.消费卡id, 0) And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      Else
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id Is Null And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      End If;
    
      If n_记录状态 = 1 Then
        n_记录状态 := 2;
      Else
        n_记录状态 := n_记录状态 + 2;
      End If;
      --多条时,只更新一条
      If n_预交id = 0 Then
        Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id,
           预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
          Select n_预交id, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, 退款时间_In, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
                 -1 * 退费金额_In, 现结帐id_In, 缴款组id_In, 预交类别, 卡类别id, Nvl(结算卡序号, v_校对.接口编号), 卡号, 交易流水号, 交易说明, 合作单位, 2, 结算序号_In,
                 结算性质
          From 病人预交记录 A
          Where ID = v_校对.预交id;
      End If;
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        --消费卡,直接退回卡数据中
        Begin
          Select 卡号, 1, 停用日期, (Select Max(序号) From 消费卡目录 B Where a.卡号 = b.卡号 And a.接口编号 = b.接口编号), 序号, 余额, 接口编号, 回收时间
          Into v_卡号, n_存在卡片, d_停用日期, n_最大序号, n_序号, n_余额, n_接口编号, d_回收时间
          From 消费卡目录 A
          Where ID = v_校对.消费卡id;
        Exception
          When Others Then
            n_存在卡片 := 0;
        End;
      
        --取消停用
        If n_存在卡片 = 0 Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡被他人删除，不能再启用该卡片,请检查！';
          Raise Err_Item;
        End If;
        If Nvl(n_序号, 0) < Nvl(n_最大序号, 0) Then
          v_Err_Msg := '不能启用历史发卡记录(卡号为"' || v_卡号 || '"),请检查！';
          Raise Err_Item;
        End If;
        If Nvl(d_停用日期, To_Date('3000-01-01', 'yyyy-mm-dd')) < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经被他人停用，不能再进行退费,请检查！';
          Raise Err_Item;
        End If;
      
        If d_回收时间 < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经回收，不能退费,请检查！';
          Raise Err_Item;
        End If;
        Update 消费卡目录 Set 余额 = Nvl(余额, 0) + 退费金额_In Where ID = Nvl(v_校对.消费卡id, 0);
      End If;
    
      Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      Insert Into 病人卡结算记录
        (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Select n_Id, 接口编号, 消费卡id, 序号, n_记录状态, 结算方式, -1 * 退费金额_In, 卡号, 交易流水号, 交易时间, 备注,
               Decode(消费卡id, Null, 0, 0, 0, 1) As 标志
        From 病人卡结算记录
        Where ID = v_校对.Id;
      Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
    
      If n_记录状态 <> 2 And n_记录状态 <> 1 Then
        Update 病人卡结算记录 Set 记录状态 = 3 Where ID = v_校对.Id;
      End If;
    End Loop;
  End;
Begin
  n_组id := Zl_Get组id(操作员姓名_In);
  If 结帐id_In Is Null Then
    Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  Else
    n_结帐id := 结帐id_In;
  End If;

  Select 结帐id, 病人id
  Into n_原结帐id, n_病人id
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Rownum < 2;

  For r_结账id In (Select Distinct 结帐id
                 From 门诊费用记录
                 Where NO In (Select Distinct NO
                              From 门诊费用记录
                              Where 结帐id In (Select 结帐id
                                             From 病人预交记录
                                             Where 结算序号 In (Select b.结算序号
                                                            From 门诊费用记录 A, 病人预交记录 B
                                                            Where a.No = No_In And b.结算序号 < 0 And Mod(a.记录性质, 10) = 1 And
                                                                  a.记录状态 <> 0 And a.结帐id = b.结帐id))) And
                       Mod(记录性质, 10) = 1 And 记录状态 <> 0
                 Union
                 Select Distinct 结帐id
                 From 门诊费用记录
                 Where NO In (Select Distinct NO
                              From 门诊费用记录
                              Where 结帐id In (Select a.结帐id
                                             From 门诊费用记录 A, 病人预交记录 B
                                             Where a.No = No_In And b.结算序号 > 0 And Mod(a.记录性质, 10) = 1 And a.记录状态 <> 0 And
                                                   a.结帐id = b.结帐id))) Loop
    v_原结帐ids := v_原结帐ids || ',' || r_结账id.结帐id;
  End Loop;
  v_原结帐ids := Substr(v_原结帐ids, 2);

  Begin
    Select 摘要
    Into v_Info
    From 病人预交记录
    Where 结算方式 Is Null And 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id;
  Exception
    When Others Then
      v_Info := '';
  End;
  --处理卡结算信息
  If v_Info Is Not Null Then
    While v_Info Is Not Null Loop
      v_当前结算 := Substr(v_Info, 1, Instr(v_Info, '|') - 1);
      n_三方卡   := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
      n_卡序号   := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
      n_冲销金额 := -1 * To_Number(v_当前结算);
    
      If n_三方卡 = 0 Then
        --消费卡
        Select 结算方式
        Into v_结算方式
        From 病人预交记录
        Where 结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And 结算卡序号 = n_卡序号 And Rownum < 2;
        Zl_Square_Update(v_原结帐ids, n_结帐id, n_组id, 退费时间_In, -1 * n_结帐id, Null, n_冲销金额, n_卡序号);
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) - n_冲销金额
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
        Returning 余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (操作员姓名_In, v_结算方式, 1, -1 * n_冲销金额);
          n_返回值 := n_冲销金额;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式 And Nvl(余额, 0) = 0;
        End If;
      Else
        --结算卡
        Select 结算方式, 卡类别id, 卡号, 交易流水号, 交易说明
        Into v_结算方式, n_卡类别id, v_卡号, v_交易流水号, v_交易说明
        From 病人预交记录
        Where 结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And 卡类别id = n_卡序号 And Rownum < 2;
      
        If Nvl(门诊退费_In, 0) = 1 Then
          If 三方退费_In = 0 Then
            v_Err_Msg := '存在无法退现的三方账户,无法进行退费!';
            Raise Err_Item;
          End If;
          Update 病人预交记录
          Set 冲预交 = 冲预交 - n_冲销金额
          Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 = v_结算方式;
          If Sql%RowCount = 0 Then
            Insert Into 病人预交记录
              (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
               缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
            Values
              (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * n_冲销金额, v_结算方式, Null, 退费时间_In,
               Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, n_卡类别id, Null, v_卡号, v_交易流水号, v_交易说明, Null, n_结帐id,
               -1 * n_结帐id, 0, 3);
          End If;
          Update 人员缴款余额
          Set 余额 = Nvl(余额, 0) - n_冲销金额
          Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
          Returning 余额 Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 人员缴款余额
              (收款员, 结算方式, 性质, 余额)
            Values
              (操作员姓名_In, v_结算方式, 1, -1 * n_冲销金额);
            n_返回值 := -1 * n_冲销金额;
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 人员缴款余额
            Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式 And Nvl(余额, 0) = 0;
          End If;
        Else
          Begin
            Select 1 Into n_退现 From 医疗卡类别 Where ID = n_卡类别id And 是否退现 = 1;
          Exception
            When Others Then
              n_退现 := 0;
          End;
        
          If 三方退费_In = 1 Or n_退现 = 0 Then
            v_结算方式 := v_结算方式;
            n_原样退   := 1;
          Else
            n_原样退 := 0;
            Begin
              Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And 名称 Like '%现金%' And Rownum < 2;
            Exception
              When Others Then
                Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
            End;
          End If;
        
          If 三方退费_In = 0 Then
            If n_原样退 = 1 Then
              Select 交易流水号, 交易说明, ID
              Into v_流水号, v_说明, n_原预交id
              From 病人预交记录
              Where 结帐id = n_原结帐id And 结算方式 = v_结算方式 And Rownum < 2;
            
              Update 病人预交记录
              Set 冲预交 = 冲预交 - n_冲销金额
              Where 记录性质 = 3 And 记录状态 = 2 And 收款时间 = 退费时间_In And 病人id + 0 = n_病人id And 结算方式 = v_结算方式 And 结帐id = n_结帐id;
              If Sql%RowCount = 0 Then
                Insert Into 病人预交记录
                  (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                   摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
                Values
                  (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * n_冲销金额, v_结算方式, Null, 退费时间_In,
                   Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, n_卡类别id, Null, v_卡号, v_交易流水号, v_交易说明, Null, n_结帐id,
                   -1 * n_结帐id, 0, 3);
              End If;
            
              v_预交no := Nextno(11);
              Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
              Insert Into 病人预交记录
                (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
                 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位)
              Values
                (n_预交id, v_预交no, Null, 1, 1, n_病人id, 主页id_In, 入院科室id_In, n_冲销金额, v_结算方式, Null, 退费时间_In, Null, Null,
                 Null, 操作员编号_In, 操作员姓名_In, '门诊转住院预交', n_组id, 2, n_卡类别id, Null, v_卡号, v_流水号, v_说明, Null);
              Update 三方结算交易 Set 交易id = n_预交id Where 交易id = n_原预交id;
            Else
              Update 病人预交记录
              Set 冲预交 = 冲预交 - n_冲销金额
              Where 记录性质 = 3 And 记录状态 = 2 And 收款时间 = 退费时间_In And 病人id + 0 = n_病人id And 结算方式 = v_结算方式 And 结帐id = n_结帐id;
              If Sql%RowCount = 0 Then
                Insert Into 病人预交记录
                  (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                   摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
                Values
                  (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * n_冲销金额, v_结算方式, Null, 退费时间_In,
                   Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, Null, Null, Null, Null, Null, Null, n_结帐id,
                   -1 * n_结帐id, 0, 3);
              End If;
            
              Update 病人预交记录
              Set 金额 = 金额 + n_冲销金额
              Where 记录性质 = 1 And 记录状态 = 1 And 收款时间 = 退费时间_In And 病人id + 0 = n_病人id And 结算方式 = v_结算方式;
              If Sql%RowCount = 0 Then
                v_预交no := Nextno(11);
                Insert Into 病人预交记录
                  (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                   摘要, 缴款组id, 预交类别)
                Values
                  (病人预交记录_Id.Nextval, v_预交no, Null, 1, 1, n_病人id, 主页id_In, 入院科室id_In, n_冲销金额, v_结算方式, Null, 退费时间_In,
                   Null, Null, Null, 操作员编号_In, 操作员姓名_In, '门诊转住院预交', n_组id, 2);
              End If;
            End If;
          
            --病人余额
            Update 病人余额
            Set 预交余额 = Nvl(预交余额, 0) + n_冲销金额
            Where 性质 = 1 And 病人id = n_病人id And 类型 = 2
            Returning 预交余额 Into n_返回值;
            If Sql%RowCount = 0 Then
              Insert Into 病人余额 (病人id, 性质, 类型, 预交余额, 费用余额) Values (n_病人id, 1, 2, n_冲销金额, 0);
              n_返回值 := n_冲销金额;
            End If;
            If Nvl(n_返回值, 0) = 0 Then
              Delete From 病人余额
              Where 病人id = n_病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
            End If;
          End If;
          --4.2缴款数据处理
          --   因为没有实际收病人的钱,所以不处理
          --部分退费情况，退原预交记录
          If 三方退费_In = 1 Then
            Update 人员缴款余额
            Set 余额 = Nvl(余额, 0) - n_冲销金额
            Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
            Returning 余额 Into n_返回值;
            If Sql%RowCount = 0 Then
              Insert Into 人员缴款余额
                (收款员, 结算方式, 性质, 余额)
              Values
                (操作员姓名_In, v_结算方式, 1, -1 * n_冲销金额);
              n_返回值 := -1 * n_冲销金额;
            End If;
            If Nvl(n_返回值, 0) = 0 Then
              Delete From 人员缴款余额
              Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式 And Nvl(余额, 0) = 0;
            End If;
            Update 病人预交记录
            Set 冲预交 = 冲预交 + (-1 * n_冲销金额)
            Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 = v_结算方式;
            If Sql%RowCount = 0 Then
              Insert Into 病人预交记录
                (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
                 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
              Values
                (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * n_冲销金额, v_结算方式, Null, 退费时间_In,
                 Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, n_卡类别id, Null, v_卡号, v_交易流水号, v_交易说明, Null, n_结帐id,
                 -1 * n_结帐id, 0, 3);
            End If;
          End If;
        End If;
      End If;
      v_Info := Substr(v_Info, Instr(v_Info, '|') + 1);
    End Loop;
  End If;

  Delete From 病人预交记录 Where 结帐id = n_结帐id And 记录状态 = 2 And 结算方式 Is Null;
  Update 门诊费用记录 Set 费用状态 = 0 Where 结帐id = n_结帐id;
  Update 门诊费用记录 Set 费用状态 = 0 Where NO = No_In And Mod(记录性质, 10) = 1 And 记录状态 = 2;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊转住院_三方卡结算;
/

--108432:冉俊明,2017-05-08,修正固定出诊表临时安排取消审核后没有删除由该临时安排生成的出诊记录，导致清除该临时安排时报错的问题
Create Or Replace Procedure Zl_临床出诊安排_Publish
(
  Id_In       临床出诊表.Id%Type,
  发布人_In   临床出诊表.发布人%Type := Null,
  发布时间_In 临床出诊表.发布时间%Type := Null,
  取消发布_In Number := 0
) As
  --发布和取消发布安排
  --参数：
  --        取消发布_In 是否取消发布
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  n_Count    Number(2);
  n_排班方式 临床出诊表.排班方式%Type;
  l_记录id   t_Numlist := t_Numlist();

  d_开始时间 临床出诊安排.开始时间%Type;
  d_终止时间 临床出诊安排.终止时间%Type;

  n_跨月周出诊id 临床出诊表.Id%Type;

  Function Get跨月周出诊id(出诊id_In 临床出诊表.Id%Type) Return 临床出诊表.Id%Type Is
    ----------------------------------------
    --如果原周出诊表不是整周(不足7天)，则需要查找到另一个出诊表构成整周
    ----------------------------------------
    n_出诊id 临床出诊表.Id%Type;
    n_年份   临床出诊表.年份%Type;
    n_月份   临床出诊表.月份%Type;
    n_周数   临床出诊表.周数%Type;
  
    d_开始时间 临床出诊安排.开始时间%Type;
    d_结束时间 临床出诊安排.终止时间%Type;
  
    --根据日期计算当月的周数，以及每一周的时间范围
    Cursor c_Weekrange(Date_In Date) Is
      Select Rownum As 周数, 开始日期, 结束日期
      From (With Month_Range As (Select Trunc(Date_In) As First_Day, Last_Day(Trunc(Date_In)) As Last_Day From Dual)
             Select Decode(To_Char(First_Day, 'day'), '星期日', First_Day, Null) As 开始日期,
                    Decode(To_Char(First_Day, 'day'), '星期日', First_Day, Null) As 结束日期
             From Month_Range
             Union All
             Select Decode(Sign(Trunc(First_Day + 7 * Week, 'day') + 1 - First_Day), 1,
                            Trunc(First_Day + 7 * Week, 'day') + 1, First_Day) As 开始日期,
                    Decode(Sign(Trunc(First_Day + 7 * Week, 'day') + 7 - Last_Day), 1, Last_Day,
                            Trunc(First_Day + 7 * Week, 'day') + 7) As 结束日期
             From Month_Range A, (Select Level - 1 As Week From Dual Connect By Level <= 6) B)
             Where 开始日期 <= 结束日期;
  
  
  Begin
    Begin
      Select 年份, 月份, 周数 Into n_年份, n_月份, n_周数 From 临床出诊表 Where ID = 出诊id_In;
    Exception
      When Others Then
        Return 0;
    End;
  
    If n_年份 Is Null Or n_月份 Is Null Or n_周数 Is Null Then
      Return 0;
    End If;
  
    For r_Weekrange In c_Weekrange(To_Date(n_年份 || '-' || n_月份 || '-01', 'yyyy-mm-dd')) Loop
      If r_Weekrange.周数 = n_周数 Then
        d_开始时间 := r_Weekrange.开始日期;
        d_结束时间 := r_Weekrange.结束日期;
        Exit;
      End If;
    End Loop;
  
    If d_开始时间 Is Null Or d_结束时间 Is Null Then
      Return 0;
    End If;
    If Trunc(d_结束时间) - Trunc(d_开始时间) >= 6 Then
      Return 0;
    End If;
  
    --存在跨月的，查找另一个出诊表的年月周
    n_年份 := Null;
    n_月份 := Null;
    n_周数 := Null;
    If Trunc(d_开始时间 - 1, 'month') <> Trunc(d_开始时间, 'month') Then
      --当前是第一周,获取另一个出诊表的年月
      n_年份 := To_Number(To_Char(d_开始时间 - 1, 'yyyy'));
      n_月份 := To_Number(To_Char(d_开始时间 - 1, 'mm'));
    Elsif Trunc(d_结束时间 + 1, 'month') <> Trunc(d_结束时间, 'month') Then
      --当前是最后一周,获取另一个出诊表的年月
      n_年份 := To_Number(To_Char(d_结束时间 + 1, 'yyyy'));
      n_月份 := To_Number(To_Char(d_结束时间 + 1, 'mm'));
      n_周数 := 1;
    Else
      Return 0;
    End If;
  
    --获取跨月的另一个出诊表的ID
    Begin
      Select ID
      Into n_出诊id
      From (Select Rownum As 行号, ID
             From 临床出诊表
             Where Nvl(排班方式, 0) = 2 And 年份 = n_年份 And 月份 = n_月份 And (n_周数 Is Null Or 周数 = n_周数)
             Order By 周数 Desc)
      Where 行号 < 2;
    Exception
      When Others Then
        Return 0;
    End;
  
    Return n_出诊id;
  End;
Begin
  Begin
    Select Nvl(排班方式, 0) Into n_排班方式 From 临床出诊表 Where ID = Id_In;
  Exception
    When Others Then
      v_Err_Msg := '出诊表信息未找到！';
      Raise Err_Item;
  End;

  If Nvl(取消发布_In, 0) = 0 Then
    --发布安排
    If Nvl(n_排班方式, 0) = 0 Then
      Select Max(1)
      Into n_Count
      From 临床出诊安排 A, 临床出诊限制 B, 临床出诊表 C
      Where a.Id = b.安排id And a.出诊id = c.Id And c.排班方式 = 0 And c.Id = Id_In And Rownum < 2;
      If Nvl(n_Count, 0) = 0 Then
        v_Err_Msg := '当前出诊表无有效的安排，不能发布！';
        Raise Err_Item;
      End If;
    Else
      If Nvl(n_排班方式, 0) = 2 Then
        n_跨月周出诊id := Get跨月周出诊id(Id_In);
      End If;
      Select Max(1)
      Into n_Count
      From 临床出诊安排 A, 临床出诊记录 B, 临床出诊表 C
      Where a.Id = b.安排id And a.出诊id = c.Id And c.排班方式 In (1, 2) And (c.Id = Id_In Or c.Id = n_跨月周出诊id) And Rownum < 2;
      If Nvl(n_Count, 0) = 0 Then
        v_Err_Msg := '当前出诊表无有效的安排，不能发布！';
        Raise Err_Item;
      End If;
    
      Select Max(1)
      Into n_Count
      From 临床出诊记录 A, 临床出诊安排 B
      Where a.号源id = b.号源id And a.出诊日期 Between b.开始时间 And b.终止时间 And a.安排id <> b.Id And b.出诊id = Id_In And Rownum < 2;
      If Nvl(n_Count, 0) <> 0 Then
        v_Err_Msg := '当前出诊表中的部分号源在当前出诊表的生效时间范围内已经存在有效的安排，不能发布！';
        Raise Err_Item;
      End If;
    End If;
  
    --如果存在多个未发布的安排表，则不允许发布后面日期的安排，必须按最小有效时间进行发布
    Select Max(1)
    Into n_Count
    From (Select ID, 年份 || LPad(月份, 2, '0') || 周数 As 日期
           From 临床出诊表
           Where Nvl(排班方式, 0) = Nvl(n_排班方式, 0) And 发布人 Is Null) A,
         (Select ID, 年份 || LPad(月份, 2, '0') || 周数 As 日期 From 临床出诊表 Where ID = Id_In) B
    Where a.日期 < b.日期 And Rownum < 2;
    If Nvl(n_Count, 0) <> 0 Then
      If Nvl(n_排班方式, 0) = 0 Then
        v_Err_Msg := '当前出诊表前面还有未发布的固定出诊表，必须先将其发布或删除后才能发布该出诊表！';
      Elsif Nvl(n_排班方式, 0) = 1 Then
        v_Err_Msg := '当前出诊表前面还有未发布的月出诊表，必须先将其发布或删除后才能发布该出诊表！';
      Elsif Nvl(n_排班方式, 0) = 2 Then
        v_Err_Msg := '当前出诊表前面还有未发布的周出诊表，必须先将其发布或删除后才能发布该出诊表！';
      End If;
      Raise Err_Item;
    End If;
  
    Update 临床出诊表 Set 发布人 = 发布人_In, 发布时间 = 发布时间_In Where ID = Id_In;
    Update 临床出诊安排 Set 审核人 = 发布人_In, 审核时间 = 发布时间_In Where 出诊id = Id_In;
  
    --删除发布时有安排，但是号源已被停用的记录
    For c_安排 In (Select a.Id
                 From 临床出诊安排 A, 临床出诊号源 B, 部门表 C, 人员表 D, 收费项目目录 E
                 Where a.号源id = b.Id And b.科室id = c.Id And a.医生id = d.Id(+) And b.项目id = e.Id And a.出诊id = Id_In And
                       Not (Nvl(b.是否删除, 0) = 0 And (b.撤档时间 Is Null Or b.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
                        Nvl(c.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                        Nvl(d.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                        Nvl(e.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd'))) Loop
      Zl_临床出诊安排_Delete(c_安排.Id, Nvl(n_排班方式, 0));
    End Loop;
  
    If Nvl(n_排班方式, 0) <> 0 Then
      --月安排/周安排根据停诊安排和法定节假日调整出诊记录的出诊/预约情况
      Select 开始时间, 终止时间 Into d_开始时间, d_终止时间 From 临床出诊安排 Where 出诊id = Id_In And Rownum < 2;
      For c_安排 In (Select a.Id, a.号源id, b.日期
                   From 临床出诊安排 A,
                        (Select Trunc(d_开始时间) + Level - 1 As 日期
                          From Dual
                          Connect By Level <= Trunc(d_终止时间) - Trunc(d_开始时间) + 1) B
                   Where a.出诊id = Id_In
                   Order By 号源id, 日期) Loop
      
        Zl_Clinicvisitmodify(c_安排.号源id, c_安排.Id, c_安排.日期, 发布人_In, 发布时间_In);
      End Loop;
    
      --修改临床出诊记录中的"是否发布"
      Select a.Id Bulk Collect
      Into l_记录id
      From 临床出诊记录 A, 临床出诊安排 B
      Where a.安排id = b.Id And b.出诊id = Id_In;
    
      Forall I In 1 .. l_记录id.Count
        Update 临床出诊记录 Set 是否发布 = 1 Where ID = l_记录id(I);
    End If;
    Return;
  End If;

  --==================================================================================================================
  --取消发布
  Select Max(1)
  Into n_Count
  From (Select ID, 年份 || LPad(月份, 2, '0') || 周数 As 日期
         From 临床出诊表
         Where Nvl(排班方式, 0) = Nvl(n_排班方式, 0) And 发布人 Is Not Null) A,
       (Select ID, 年份 || LPad(月份, 2, '0') || 周数 As 日期 From 临床出诊表 Where ID = Id_In) B
  Where a.日期 > b.日期 And Rownum < 2;
  If Nvl(n_Count, 0) <> 0 Then
    If Nvl(n_排班方式, 0) = 0 Then
      v_Err_Msg := '当前出诊后面还有已发布的固定出诊表，必须先将其取消发布后才能取消发布该出诊表！';
    Elsif Nvl(n_排班方式, 0) = 1 Then
      v_Err_Msg := '当前出诊后面还有已发布的月出诊表，必须先将其取消发布后才能取消发布该出诊表！';
    Elsif Nvl(n_排班方式, 0) = 2 Then
      v_Err_Msg := '当前出诊后面还有已发布的周出诊表，必须先将其取消发布后才能取消发布该出诊表！';
    End If;
    Raise Err_Item;
  End If;

  Select Max(1)
  Into n_Count
  From 病人挂号记录 C, 临床出诊记录 A, 临床出诊安排 B
  Where c.出诊记录id = a.Id And a.安排id = b.Id And b.出诊id = Id_In And Rownum < 2;
  If Nvl(n_Count, 0) <> 0 Then
    v_Err_Msg := '当前出诊表的安排已被使用，不允许取消发布！';
    Raise Err_Item;
  End If;

  Update 临床出诊表 Set 发布人 = Null, 发布时间 = Null Where ID = Id_In;
  If Sql%NotFound Then
    v_Err_Msg := '出诊表信息未找到！';
    Raise Err_Item;
  End If;
  Update 临床出诊安排 Set 审核人 = Null, 审核时间 = Null Where 出诊id = Id_In;

  --固定安排取消发布时删除出诊记录
  If Nvl(n_排班方式, 0) = 0 Then
    --删除出诊记录
    Select a.Id Bulk Collect
    Into l_记录id
    From 临床出诊记录 A, 临床出诊安排 B
    Where a.安排id = b.Id And b.出诊id = Id_In;
  
    Zl_临床出诊记录_Batchdelete(l_记录id);
  Else
    --删除备份的出诊记录
    Select a.Id Bulk Collect
    Into l_记录id
    From 临床出诊记录 A, 临床出诊安排 B
    Where a.安排id = b.Id And b.出诊id = Id_In And a.相关id Is Not Null;
  
    Zl_临床出诊记录_Batchdelete(l_记录id);
  
    --月安排/周安排清除停诊信息，并修改是否发布
    Select a.Id Bulk Collect
    Into l_记录id
    From 临床出诊记录 A, 临床出诊安排 B
    Where a.安排id = b.Id And b.出诊id = Id_In;
  
    Forall I In 1 .. l_记录id.Count
      Delete From 临床出诊停诊记录 Where 记录id = l_记录id(I);
  
    --修改临床出诊记录中的"是否发布"
    Select a.Id Bulk Collect
    Into l_记录id
    From 临床出诊记录 A, 临床出诊安排 B
    Where a.安排id = b.Id And b.出诊id = Id_In;
  
    Forall I In 1 .. l_记录id.Count
      Update 临床出诊记录
      Set 停诊开始时间 = Null, 停诊终止时间 = Null, 停诊原因 = Null, 是否发布 = 0
      Where ID = l_记录id(I);
  
    --恢复临床出诊序号控制的"是否预约"及"是否停诊"
    For c_记录 In (Select a.Id, a.是否分时段, a.是否序号控制
                 From 临床出诊记录 A, 临床出诊安排 B
                 Where a.安排id = b.Id And b.出诊id = Id_In) Loop
      If Nvl(c_记录.是否分时段, 0) = 1 Then
        If Nvl(c_记录.是否序号控制, 0) = 0 Then
          Update 临床出诊序号控制 Set 是否预约 = 1 Where 记录id = c_记录.Id;
        Else
          Update 临床出诊序号控制 Set 是否预约 = Nvl(预约顺序号, 0), 是否停诊 = 0 Where 记录id = c_记录.Id;
        End If;
      End If;
    End Loop;
  
    --换休的不再恢复
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊安排_Publish;
/

--108432:冉俊明,2017-05-08,修正固定出诊表临时安排取消审核后没有删除由该临时安排生成的出诊记录，导致清除该临时安排时报错的问题
Create Or Replace Procedure Zl_临床出诊临时安排_Cancel(安排id_In In 临床出诊安排.Id%Type) Is
  Err_Item Exception;
  v_Err_Msg Varchar2(500);

  n_Count  Number(2);
  l_记录id t_Numlist := t_Numlist();
Begin
  Select Count(1)
  Into n_Count
  From 临床出诊记录 A, 病人挂号记录 B
  Where a.Id = b.出诊记录id And a.安排id = 安排id_In And Rownum < 2;
  If n_Count <> 0 Then
    v_Err_Msg := '当前安排已存在预约挂号数据，不能取消审核！';
    Raise Err_Item;
  End If;

  Select Count(1)
  Into n_Count
  From 临床出诊安排 A, 临床出诊安排 B, 临床出诊表 C
  Where a.号源id = b.号源id And a.出诊id = c.Id And c.排班方式 = 0 And a.Id <> b.Id And b.Id = 安排id_In And a.登记时间 > b.登记时间 And
        a.审核时间 Is Not Null And Rownum < 2;
  If n_Count <> 0 Then
    v_Err_Msg := '该号源在当前安排之后还存在已审核的安排，你不能取消审核当前安排！';
    Raise Err_Item;
  End If;

  Update 临床出诊安排 Set 审核人 = Null, 审核时间 = Null Where ID = 安排id_In And 审核时间 Is Not Null;
  If Sql%NotFound Then
    v_Err_Msg := '当前安排已被他人取消审核或删除，不能再取消审核！';
    Raise Err_Item;
  End If;

  --删除该安排已生成的出诊记录
  Select a.Id Bulk Collect Into l_记录id From 临床出诊记录 A Where a.安排id = 安排id_In;
  Zl_临床出诊记录_Batchdelete(l_记录id);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊临时安排_Cancel;
/

--108432:冉俊明,2017-05-08,修正固定出诊表临时安排取消审核后没有删除由该临时安排生成的出诊记录，导致清除该临时安排时报错的问题
Create Or Replace Procedure Zl1_Auto_Buildingregisterplan
(
  挂号时间_In In Date := Null,
  号源id_In   临床出诊号源.Id%Type := Null
) As
  -------------------------------------------------------------------------
  --功能说明：自动生成临床出诊记录
  --          1、根据号源自动生成预约数内的临床出诊记录;
  --          2、预约天数的确定:号源预约天数-->预约方式的天数（取最大)-->系统预约天数
  --入参:挂号时间_IN:NULL时，自动生成;否则只检查指定日期是否生成了出诊记录没有
  --    号源id_In:NULL时处理所有号源，否则只处理指定号源
  -------------------------------------------------------------------------
  n_缺省预约天数 临床出诊号源.预约天数%Type;
  v_操作员姓名   临床出诊安排.操作员姓名%Type;
  d_登记日期     临床出诊安排.登记时间%Type;
  n_安排id       临床出诊安排.Id%Type;
  n_项目id       临床出诊安排.项目id %Type;

  n_记录id   临床出诊记录.Id%Type;
  d_当前日期 临床出诊记录.出诊日期%Type;

  n_是否出诊 Number(2);
  l_固定时段 t_Strlist := t_Strlist();
  n_Count    Number(18);

  n_加预约天数 Number := 0;
  d_开始时间   临床出诊记录.开始时间%Type;
Begin

  Select Max(预约天数) Into n_缺省预约天数 From 预约方式;
  If Nvl(n_缺省预约天数, 0) = 0 Then
    n_缺省预约天数 := To_Number(Nvl(zl_GetSysParameter('挂号允许预约天数'), '0'));
  End If;
  If Nvl(n_缺省预约天数, 0) = 0 Then
    n_缺省预约天数 := 7;
  End If;

  --以半天为单位,如果参数“号源开放时间”在12:00:00-23:59:59期间的，则开放预约天数+1天
  n_加预约天数 := Zl_Fun_Getappointmentdays;

  d_当前日期   := Trunc(Nvl(挂号时间_In, Sysdate));
  d_登记日期   := Sysdate;
  v_操作员姓名 := Zl_Username;

  --第一层循环，号源信息
  For c_号源 In (Select c.Id, c.号类, c.号码, c.项目id, c.科室id, c.医生姓名,
                      Decode(Nvl(c.预约天数, 0), 0, n_缺省预约天数, c.预约天数) + n_加预约天数 As 预约天数, Nvl(b.站点, '-') As 站点,
                      Nvl(c.是否假日换休, 0) As 是否假日换休, Nvl(c.假日控制状态, 0) As 假日控制状态, Nvl(c.排班方式, 0) As 排班方式
               From 临床出诊号源 C, 部门表 B, 人员表 A, 收费项目目录 D
               Where c.科室id = b.Id And c.医生id = a.Id(+) And c.项目id = d.Id And Nvl(c.是否删除, 0) = 0 And
                     Nvl(c.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     Nvl(b.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     Nvl(a.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     Nvl(d.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     (号源id_In Is Null Or c.Id = 号源id_In)
                    --
                     And Exists (Select 1
                      From 临床出诊安排 M, 临床出诊表 N
                      Where m.出诊id = n.Id And m.号源id = c.Id And Nvl(n.排班方式, 0) = 0 And n.发布时间 Is Not Null And
                            m.审核时间 Is Not Null And d_当前日期 <= m.终止时间)) Loop
  
    --检查当前日期所在的安排的收费项目是否为号源中的收费项目，如果不是，则更新号源中的收费项目
    Begin
      Select 项目id
      Into n_项目id
      From (Select a.项目id
             From 临床出诊安排 A, 临床出诊表 B
             Where a.出诊id = b.Id And a.号源id = c_号源.Id And a.审核时间 Is Not Null And d_当前日期 Between a.开始时间 And a.终止时间 And
                   Nvl(b.排班方式, 0) = 0 And b.发布时间 Is Not Null
             Order By a.登记时间 Desc)
      Where Rownum < 2;
    Exception
      When Others Then
        n_项目id := Null;
    End;
    If Nvl(n_项目id, 0) <> 0 Then
      If Nvl(c_号源.项目id, 0) <> n_项目id Then
        Update 临床出诊号源 Set 项目id = n_项目id Where ID = c_号源.Id;
        Commit;
      End If;
    End If;
  
    --第二层循环，出诊日期
    --从头一天开始生成，避免如全日(8:00-7:59)在0:00-7:59没有出诊记录
    For c_日期 In (Select m.日期,
                        Decode(To_Char(m.日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7',
                                '周六', Null) As 星期
                 From (Select Trunc(d_当前日期) + 天数 As 日期
                        From (Select Level - 1 As 天数 From Dual Connect By Level <= c_号源.预约天数 + 1)
                        Where 号源id_In Is Not Null
                        Union All
                        Select Trunc(d_当前日期 - 1) + 天数 As 日期
                        From (Select Level - 1 As 天数 From Dual Connect By Level <= c_号源.预约天数 + 2)
                        Where 号源id_In Is Null) M) Loop
    
      l_固定时段 := t_Strlist();
      --检查当日是否在月/周出诊表中,若在，则不生成出诊记录
      Select Count(1)
      Into n_Count
      From 临床出诊安排 A, 临床出诊表 B
      Where a.出诊id = b.Id And a.号源id = c_号源.Id And c_日期.日期 Between Trunc(a.开始时间) And Trunc(a.终止时间) And
            Nvl(b.排班方式, 0) In (1, 2) And Rownum < 2;
    
      --当前号源为按月/周排班，且当前日期之前已有按月/周排班的出诊记录就不再按固定安排生成出诊记录了
      If Nvl(n_Count, 0) = 0 And Nvl(c_号源.排班方式, 0) <> 0 Then
        Select Count(1)
        Into n_Count
        From 临床出诊安排 A, 临床出诊表 B
        Where a.出诊id = b.Id And Nvl(b.排班方式, 0) In (1, 2) And a.号源id = c_号源.Id And a.开始时间 < c_日期.日期 And Rownum < 2;
      End If;
    
      If Nvl(n_Count, 0) = 0 Then
        If 号源id_In Is Null Then
          --出诊安排,取最后登记的一个
          Begin
            Select 安排id
            Into n_安排id
            From (Select a.Id As 安排id
                   From 临床出诊安排 A, 临床出诊表 B
                   Where a.号源id = c_号源.Id And a.出诊id = b.Id And Nvl(b.排班方式, 0) = 0 And b.发布时间 Is Not Null And
                         a.审核时间 Is Not Null And c_日期.日期 Between a.开始时间 And a.终止时间
                   Order By a.登记时间 Desc)
            Where Rownum < 2;
          Exception
            When Others Then
              n_安排id := 0;
          End;
        Else
          --如果指定了号源ID，肯定是发布后新增了临时安排重新生成出诊记录，最后登记的一个肯定是本次新增的，
          --只需要处理这个安排即可，不在这个安排有效时间范围内的就不处理
          Begin
            Select 安排id
            Into n_安排id
            From (Select a.Id As 安排id, a.开始时间, a.终止时间, Row_Number() Over(Order By a.登记时间 Desc) As 行号
                   From 临床出诊安排 A, 临床出诊表 B
                   Where a.号源id = c_号源.Id And a.出诊id = b.Id And Nvl(b.排班方式, 0) = 0 And b.发布时间 Is Not Null And
                         a.审核时间 Is Not Null And c_日期.日期 Between 开始时间 And 终止时间)
            Where 行号 = 1;
          Exception
            When Others Then
              n_安排id := 0;
          End;
        End If;
      
        If Nvl(n_安排id, 0) <> 0 Then
          If 号源id_In Is Null Then
            --确定当日是否有出诊记录
            Select Count(1)
            Into n_Count
            From 临床出诊记录 A
            Where a.号源id = c_号源.Id And a.出诊日期 = c_日期.日期 And Rownum < 2;
          
            --1.未指定号源ID，则是正常生成出诊记录，有出诊记录的日期将不再处理
            If Nvl(n_Count, 0) = 0 Then
              --1.1无出诊记录，正常生成
              n_是否出诊 := 1;
            Else
              --1.2有出诊记录，不再处理
              n_是否出诊 := 0;
            End If;
          Else
            --2.指定了号源ID，肯定是发布后新增了临时安排重新生成出诊记录
            n_是否出诊 := 1;
            --当日有出诊记录，需要做如下处理
            For c_记录 In (Select a.安排id, a.Id As 记录id, a.出诊日期, a.上班时段, a.是否分时段, a.是否序号控制
                         From 临床出诊记录 A
                         Where a.号源id = c_号源.Id And a.出诊日期 = c_日期.日期) Loop
            
              Select Count(1) Into n_Count From 病人挂号记录 Where 出诊记录id = c_记录.记录id;
              If Nvl(n_Count, 0) = 0 Then
                --2.2.1如果时段不存在预约挂号数据，则删除重新生成
                Zl_临床出诊上班时段_Delete(c_记录.安排id, To_Char(c_记录.出诊日期, 'yyyy-mm-dd'), 1, c_记录.上班时段);
              Else
                --2.2.2如果时段存在预约挂号数据，则只需调整出诊记录的安排ID即可
                Update 临床出诊记录 Set 安排id = n_安排id Where ID = c_记录.记录id;
                l_固定时段.Extend();
                l_固定时段(l_固定时段.Count) := c_记录.上班时段;
              End If;
            End Loop;
          End If;
        
          --检查这天是否出诊
          If n_是否出诊 = 1 Then
            Select Count(1) Into n_Count From 临床出诊限制 Where 安排id = n_安排id And 限制项目 = c_日期.星期;
            If Nvl(n_Count, 0) = 0 Then
              n_是否出诊 := 0;
            End If;
          End If;
        
          If Nvl(n_是否出诊, 0) = 0 Then
            --如果不存在临床出诊记录，则增加临床出诊记录(时间段为NULL 的空记录)
            Insert Into 临床出诊记录
              (ID, 安排id, 号源id, 出诊日期, 登记人, 登记时间)
              Select 临床出诊记录_Id.Nextval, n_安排id, a.Id As ID, c_日期.日期, v_操作员姓名, d_登记日期 As 登记时间
              From 临床出诊号源 A, 临床出诊安排 B
              Where a.Id = b.号源id And b.Id = n_安排id
                   --
                    And Not Exists (Select 1 From 临床出诊记录 Where 号源id = a.Id And 出诊日期 = c_日期.日期);
          Else
            For c_记录 In (With c_时间段 As
                            (Select 时间段, 开始时间, 终止时间, 号类, 站点, 缺省时间, 提前时间
                            From (Select 时间段, 开始时间, 终止时间, 号类, 站点, 缺省时间, 提前时间,
                                          Row_Number() Over(Partition By 时间段 Order By 时间段, 站点 Asc, 号类 Asc) As 组号
                                   From 时间段
                                   Where Nvl(站点, c_号源.站点) = c_号源.站点 And Nvl(号类, c_号源.号类) = c_号源.号类)
                            Where 组号 = 1)
                           Select n_安排id As 安排id, B1.号源id, c_日期.日期 As 出诊日期, m.上班时段, m.Id As 限制id,
                                  To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') || To_Char(j.开始时间, 'hh24:mi:ss'),
                                           'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                  To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') || To_Char(j.终止时间, 'hh24:mi:ss'),
                                          'yyyy-mm-dd hh24:mi:ss') + Case
                                    When j.终止时间 <= j.开始时间 Then
                                     1
                                    Else
                                     0
                                  End As 终止时间, Null As 停诊开始时间, Null As 停诊终止时间, Null As 停诊原因,
                                  To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') || To_Char(Nvl(j.缺省时间, j.开始时间), 'hh24:mi:ss'),
                                          'yyyy-mm-dd hh24:mi:ss') + Case
                                    When j.缺省时间 < j.开始时间 Then
                                     1
                                    Else
                                     0
                                  End As 缺省预约时间,
                                  To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') || To_Char(Nvl(j.提前时间, j.开始时间), 'hh24:mi:ss'),
                                          'yyyy-mm-dd hh24:mi:ss') + Case
                                    When j.开始时间 < j.提前时间 Then
                                     -1
                                    Else
                                     0
                                  End As 提前挂号时间, m.限号数, 0 As 已挂数, m.限约数, 0 As 已约数, 0 As 其中已接收, m.是否序号控制, m.是否分时段, m.预约控制,
                                  m.是否独占, B1.项目id, B1.医生id, B1.医生姓名, Null As 替诊医生id, Null As 替诊医生姓名, m.分诊方式, m.诊室id,
                                  0 As 是否锁定, 0 As 是否临时出诊, v_操作员姓名 As 操作员姓名, d_登记日期 As 登记时间, c_日期.星期 As 限制项目
                           From 临床出诊安排 B1, 临床出诊限制 M, c_时间段 J
                           Where B1.Id = n_安排id And B1.Id = m.安排id And m.限制项目 = c_日期.星期 And m.上班时段 = j.时间段 And
                                 To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') || To_Char(j.开始时间, 'hh24:mi:ss'),
                                         'yyyy-mm-dd hh24:mi:ss') >= B1.开始时间) Loop
              Begin
                Select 1 Into n_Count From Table(l_固定时段) Where Column_Value = c_记录.上班时段;
              Exception
                When Others Then
                  n_Count := 0;
              End;
            
              If Nvl(n_Count, 0) = 0 Then
                Select 临床出诊记录_Id.Nextval Into n_记录id From Dual;
                Insert Into 临床出诊记录
                  (ID, 安排id, 号源id, 出诊日期, 上班时段, 开始时间, 终止时间, 停诊开始时间, 停诊终止时间, 停诊原因, 缺省预约时间, 提前挂号时间, 限号数, 已挂数, 限约数, 已约数,
                   其中已接收, 是否序号控制, 是否分时段, 预约控制, 是否独占, 项目id, 科室id, 医生id, 医生姓名, 替诊医生id, 替诊医生姓名, 分诊方式, 诊室id, 是否锁定, 是否临时出诊,
                   登记人, 登记时间, 是否发布)
                Values
                  (n_记录id, c_记录.安排id, c_记录.号源id, c_记录.出诊日期, c_记录.上班时段, c_记录.开始时间, c_记录.终止时间, c_记录.停诊开始时间, c_记录.停诊终止时间,
                   c_记录.停诊原因, c_记录.缺省预约时间, c_记录.提前挂号时间, c_记录.限号数, c_记录.已挂数, c_记录.限约数, c_记录.已约数, c_记录.其中已接收, c_记录.是否序号控制,
                   c_记录.是否分时段, c_记录.预约控制, c_记录.是否独占, c_记录.项目id, c_号源.科室id, c_记录.医生id, c_记录.医生姓名, c_记录.替诊医生id,
                   c_记录.替诊医生姓名, c_记录.分诊方式, c_记录.诊室id, c_记录.是否锁定, c_记录.是否临时出诊, c_记录.操作员姓名, d_登记日期, 1);
              
                d_开始时间 := c_记录.开始时间;
                --插入临床出诊序号控制
                If Nvl(c_记录.是否分时段, 0) = 1 And Nvl(c_记录.是否序号控制, 0) = 1 Then
                  --分时段且启用序号控制，使用"预约顺序号"记录"是否预约"
                  Insert Into 临床出诊序号控制
                    (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 预约顺序号)
                    Select n_记录id, 序号,
                           To_Date(To_Char(c_记录.出诊日期, 'yyyy-mm-dd ') || To_Char(开始时间, 'hh24:mi:ss'),
                                    'yyyy-mm-dd hh24:mi:ss') + Case
                              When d_开始时间 > To_Date(To_Char(c_记录.出诊日期, 'yyyy-mm-dd ') || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') Then
                               1
                              Else
                               0
                            End,
                           To_Date(To_Char(c_记录.出诊日期, 'yyyy-mm-dd ') || To_Char(终止时间, 'hh24:mi:ss'),
                                    'yyyy-mm-dd hh24:mi:ss') + Case
                              When d_开始时间 >= To_Date(To_Char(c_记录.出诊日期, 'yyyy-mm-dd ') || To_Char(终止时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') Then
                               1
                              Else
                               0
                            End, 限制数量, 是否预约, 是否预约
                    From 临床出诊时段
                    Where 限制id = c_记录.限制id;
                Else
                  Insert Into 临床出诊序号控制
                    (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约)
                    Select n_记录id, 序号,
                           To_Date(To_Char(c_记录.出诊日期, 'yyyy-mm-dd ') || To_Char(开始时间, 'hh24:mi:ss'),
                                   'yyyy-mm-dd hh24:mi:ss') + Case
                             When d_开始时间 > To_Date(To_Char(c_记录.出诊日期, 'yyyy-mm-dd ') || To_Char(开始时间, 'hh24:mi:ss'),
                                                   'yyyy-mm-dd hh24:mi:ss') Then
                              1
                             Else
                              0
                           End,
                           To_Date(To_Char(c_记录.出诊日期, 'yyyy-mm-dd ') || To_Char(终止时间, 'hh24:mi:ss'),
                                   'yyyy-mm-dd hh24:mi:ss') + Case
                             When d_开始时间 >= To_Date(To_Char(c_记录.出诊日期, 'yyyy-mm-dd ') || To_Char(终止时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') Then
                              1
                             Else
                              0
                           End, 限制数量, 是否预约
                    From 临床出诊时段
                    Where 限制id = c_记录.限制id;
                End If;
              
                --插入合作单位挂号控制记录
                Insert Into 临床出诊挂号控制记录
                  (类型, 性质, 名称, 记录id, 序号, 控制方式, 数量)
                  Select 类型, 性质, 名称, n_记录id, 序号, 控制方式, 数量
                  From 临床出诊挂号控制
                  Where 限制id = c_记录.限制id;
              
                --插入临床出诊诊室记录
                Insert Into 临床出诊诊室记录
                  (记录id, 诊室id)
                  Select n_记录id, 诊室id From 临床出诊诊室 Where 限制id = c_记录.限制id;
              End If;
            End Loop;
          
            --根据停诊安排和法定节假日调整出诊记录的出诊/预约情况
            Zl_Clinicvisitmodify(c_号源.Id, n_安排id, c_日期.日期, v_操作员姓名, d_登记日期);
          End If;
        End If;
      End If;
      --一天一提交
      Commit;
    End Loop;
  End Loop;
End Zl1_Auto_Buildingregisterplan;
/

--110486:张德婷,2017-07-03,高值卫材销帐时，产生多余销帐数据
--104383:张德婷,2017-06-20,修正高值卫材销帐问题
--108821:李业庆,2017-05-15,退料后未向库存回写条码信息
CREATE OR REPLACE Procedure Zl_材料收发记录_部门退料
(
  收发id_In   In 药品收发记录.Id%Type,
  审核人_In   In 药品收发记录.审核人%Type,
  审核日期_In In 药品收发记录.审核日期%Type,
  批号_In     In 药品库存.上次批号%Type := Null,
  效期_In     In 药品库存.效期%Type := Null,
  产地_In     In 药品库存.上次产地%Type := Null,
  退料数量_In In 药品收发记录.实际数量%Type := Null,
  自动销帐_In Integer := 0,
  退料人_In   In 药品收发记录.领用人%Type := Null,
  是否销帐_In IN integer:=0
) Is
  Err_Item Exception;
  v_Err_Msg Varchar2(100);
  v_No      药品收发记录.No%Type;

  n_记录状态   药品收发记录.记录状态%Type;
  n_执行状态   住院费用记录.执行状态%Type;
  n_部分退料   Number;
  n_入出类别id Number(18);
  n_单据       药品收发记录.单据%Type;
  n_库房id     药品收发记录.库房id%Type;
  n_药品id     药品收发记录.药品id%Type;
  n_实际数量   药品收发记录.实际数量%Type;
  n_实际金额   药品收发记录.零售金额%Type;
  n_实际成本   药品收发记录.成本金额%Type;
  n_实际差价   药品收发记录.差价%Type;
  n_费用id     药品收发记录.费用id%Type;
  n_零售价     药品收发记录.零售价%Type;
  n_实价卫材   收费项目目录.是否变价%Type;

  --处理退料时，分批核算性质改变后的处理
  n_新批次       药品收发记录.批次%Type;
  n_批次         药品收发记录.批次%Type;
  n_分批         材料特性.在用分批%Type;
  n_小数         Number(2);
  n_上次供应商id 药品库存.上次供应商id%Type;
  n_成本价       药品收发记录.成本价%Type;
  d_上次生产日期 药品库存.上次生产日期%Type;
  d_灭菌效期     药品库存.灭菌效期%Type;
  v_批准文号     药品库存.批准文号%Type;
  v_产地         药品收发记录.产地%Type;
  v_费用no       住院费用记录.No%Type;
  v_Temp         Varchar2(255);
  v_人员编号     人员表.编号%Type;
  v_人员姓名     人员表.姓名%Type;
  n_主页id       住院费用记录.主页id%Type;
  n_序号         住院费用记录.序号%Type;
  v_病人来源     病人医嘱记录.病人来源%Type;

  v_备货id     药品收发记录.Id%Type;
  v_入库no     药品收发记录.No%Type;
  v_入库序号   Number(5) := 0;
  v_执行时间   药品收发记录.审核日期%Type;
  n_平均成本价 药品库存.平均成本价%Type;
  n_冲销记录id 药品收发记录.Id%Type;
  n_移库       Number(1) := 0;
  v_商品条码   药品库存.商品条码%Type;
  v_内部条码   药品库存.内部条码%Type;
Begin
  v_Temp     := Zl_Identity;
  v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);

  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into n_小数 From Dual;

  If 退料数量_In Is Not Null Then
    If 退料数量_In = 0 Then
      Return;
    End If;
  End If;

  --1、判断当前数据是否是备货卫材
  Begin
    Select 汇总发药号
    Into v_备货id
    From 药品收发记录
    Where 单据 = 21 And 审核日期 Is Not Null And
          汇总发药号 =
          (Select Max(a.Id)
           From 药品收发记录 A, 药品收发记录 B
           Where a.单据 = b.单据 And a.No = b.No And a.序号 = b.序号 And b.Id = 收发id_In And (Mod(a.记录状态, 3) = 0 Or a.记录状态 = 1)) And
          Rownum = 1;
  Exception
    When Others Then
      v_备货id := 0;
  End;

  --获取该收发记录的单据、药品ID、库房ID
  Select 单据, NO, 库房id, 药品id, 费用id, 入出类别id, 记录状态, Nvl(批次, 0), 生产日期, 灭菌效期, 批准文号, 供药单位id, 成本价, 产地, 零售价, 商品条码, 内部条码
  Into n_单据, v_No, n_库房id, n_药品id, n_费用id, n_入出类别id, n_记录状态, n_批次, d_上次生产日期, d_灭菌效期, v_批准文号, n_上次供应商id, n_成本价, v_产地,
       n_零售价, v_商品条码, v_内部条码
  From 药品收发记录
  Where ID = 收发id_In;

  --获取该笔记录剩余未退数量、金额及差价
  --尽量避免金额及差价未出完的现象
  Select Sum(Nvl(实际数量, 0) * Nvl(付数, 1)), Sum(Nvl(零售金额, 0)), Sum(Nvl(成本金额, 0)), Sum(Nvl(差价, 0))
  Into n_实际数量, n_实际金额, n_实际成本, n_实际差价
  From 药品收发记录
  Where 审核人 Is Not Null And NO = v_No And 单据 = n_单据 And 序号 = (Select 序号 From 药品收发记录 Where ID = 收发id_In);

  --如果允许退药数为零，表示已退药
  If n_实际数量 = 0 Then
    v_Err_Msg := '该单据已被其他操作员退料，请刷新后再试！';
    Raise Err_Item;
  End If;

  If Nvl(退料数量_In, 0) > n_实际数量 Then
    v_Err_Msg := '该单据已被其他操作员部分退料，请刷新后再试！';
    Raise Err_Item;
  End If;

  --获取该材料当前是否分批的信息
  Select Nvl(在用分批, 0) Into n_分批 From 材料特性 Where 材料id = n_药品id;

  --如果是部分退料，则重新计算零售金额及差价
  n_部分退料 := 0;
  If Not (退料数量_In Is Null Or Nvl(退料数量_In, 0) = n_实际数量) Then
    n_部分退料 := 1;
  End If;

  If n_部分退料 = 1 Then
    n_实际金额 := Round(n_实际金额 * 退料数量_In / n_实际数量, n_小数);
    n_实际成本 := Round(n_实际成本 * 退料数量_In / n_实际数量, n_小数);
    n_实际差价 := Round(n_实际差价 * 退料数量_In / n_实际数量, n_小数);
    n_实际数量 := 退料数量_In;
  End If;

  --n_分批:0-不分批;1-分批;2-原分批，现不分批，按不分批处理;3-原不分批，现分批，产生新批次
  If n_分批 = 0 And n_批次 <> 0 Then
    --原分批，现不分批，按不分批处理
    n_分批 := 2;
  Elsif n_分批 <> 0 And n_批次 = 0 Then
    --原不分批,现分批,产生新的批次，并在新产生的发药记录中使用
    n_分批 := 3;
  Else
    If n_批次 = 0 Then
      n_分批 := 0;
    Else
      n_分批 := 1;
    End If;
  End If;
  If 产地_In Is Not Null Then
    v_产地 := 产地_In;
  End If;
  --记录状态的含义有所变化
  --冲销的记录状态        :iif(n_记录状态=1,0,1)+1
  --被冲销的记录状态        :iif(n_记录状态=1,0,1)+2
  --等待发料的记录状态    :iif(n_记录状态=1,0,1)+3
  Select 药品收发记录_Id.Nextval Into n_冲销记录id From Dual;
  --产生冲销记录
  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 灭菌效期, 付数, 填写数量, 实际数量, 成本价, 成本金额, 扣率, 零售价,
     零售金额, 差价, 摘要, 填制人, 填制日期, 配药人, 审核人, 审核日期, 费用id, 单量, 频次, 用法, 发药窗口, 领用人, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
    Select n_冲销记录id, n_记录状态 + Decode(n_记录状态, 1, 0, 1) + 1, n_单据, v_No, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号,
           效期, 灭菌效期, 1, -n_实际数量, -n_实际数量, 成本价, -n_实际成本, 扣率, 零售价, -n_实际金额, -n_实际差价, 摘要, 审核人_In, 审核日期_In, 配药人, 审核人_In,
           审核日期_In, 费用id, 单量, 频次, 用法, 发药窗口, 退料人_In, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码
    From 药品收发记录
    Where ID = 收发id_In;

  --如果是部分冲销，则付数填为1，实际数量为付数与实际数量的积
  --产生正常记录以供继续发料
  Select 药品收发记录_Id.Nextval Into n_新批次 From Dual;

  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 灭菌效期, 付数, 填写数量, 实际数量, 成本价, 成本金额, 扣率, 零售价,
     零售金额, 差价, 摘要, 填制人, 填制日期, 配药人, 审核人, 审核日期, 费用id, 单量, 频次, 用法, 发药窗口, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
    Select n_新批次, n_记录状态 + Decode(n_记录状态, 1, 0, 1) + 3, n_单据, v_No, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id,
           Decode(n_分批, 1, 批次, 3, n_新批次, Null), Decode(n_分批, 3, 产地_In, 1, 产地, Null), Decode(n_分批, 3, 批号_In, 1, 批号, Null),
           Decode(n_分批, 3, 效期_In, 1, 效期, Null), 灭菌效期, 1, n_实际数量, n_实际数量, 成本价, n_实际成本, 扣率, 零售价, n_实际金额, n_实际差价, 摘要, 填制人,
           填制日期, Null, Null, Null, 费用id, 单量, 频次, 用法, 发药窗口, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码
    From 药品收发记录
    Where ID = 收发id_In;

  --更新病人费用记录的执行状态(0-未执行;1-完全执行;2-部分执行)
  Select Decode(Sum(Nvl(付数, 1) * 实际数量), Null, 0, 0, 0, 2)
  Into n_执行状态
  From 药品收发记录
  Where 单据 = n_单据 And NO = v_No And 费用id = n_费用id And 审核人 Is Not Null;

  If n_执行状态 = 0 Then
    Update 住院费用记录 Set 执行状态 = n_执行状态, 执行人 = Null, 执行时间 = Null Where ID = n_费用id;
    Update 门诊费用记录
    Set 执行状态 = n_执行状态, 执行人 = Null, 执行时间 = Null
    Where NO = v_No And
          序号 = (Select 序号 From 门诊费用记录 Where ID = (Select 费用id From 药品收发记录 Where ID = 收发id_In)) And
          (Mod(记录性质, 10) = 1 Or Mod(记录性质, 10) = 2) And 记录状态 <> 2 And 执行部门id = n_库房id;
  Else
    Update 住院费用记录 Set 执行状态 = n_执行状态 Where ID = n_费用id;
    Update 门诊费用记录
    Set 执行状态 = n_执行状态
    Where NO = v_No And
          序号 = (Select 序号 From 门诊费用记录 Where ID = (Select 费用id From 药品收发记录 Where ID = 收发id_In)) And
          (Mod(记录性质, 10) = 1 Or Mod(记录性质, 10) = 2) And 记录状态 <> 2 And 执行部门id = n_库房id;
  End If;

  --插入未发药品记录
  Begin
    Insert Into 未发药品记录
      (单据, NO, 病人id, 主页id, 姓名, 优先级, 对方部门id, 库房id, 发药窗口, 填制日期, 已收费, 配药人, 打印状态, 未发数)
      Select a.单据, a.No, a.病人id, a.主页id, a.姓名, Nvl(b.优先级, 0) 优先级, a.对方部门id, a.库房id, a.发药窗口, a.填制日期, a.已收费, Null, 1, 1
      From (Select b.单据, b.No, a.病人id, a.主页id, a.姓名, Decode(a.记录性质, 1, Decode(a.操作员姓名, Null, 0, 1), 1) 已收费, b.对方部门id,
                    b.库房id, b.发药窗口, b.填制日期, c.身份
             From 住院费用记录 A, 药品收发记录 B, 病人信息 C
             Where b.Id = 收发id_In And a.Id = b.费用id + 0 And a.病人id = c.病人id(+)
             Union All
             Select b.单据, b.No, a.病人id, Null As 主页id, a.姓名, Decode(a.记录性质, 1, Decode(a.操作员姓名, Null, 0, 1), 1) 已收费,
                    b.对方部门id, b.库房id, b.发药窗口, b.填制日期, c.身份
             From 门诊费用记录 A, 药品收发记录 B, 病人信息 C
             Where b.Id = 收发id_In And a.Id = b.费用id + 0 And a.病人id = c.病人id(+)) A, 身份 B
      Where b.名称(+) = a.身份;
  Exception
    When Others Then
      Null;
  End;

  --修改原记录为被冲销记录
  Update 药品收发记录 Set 记录状态 = n_记录状态 + Decode(n_记录状态, 1, 0, 1) + 2 Where ID = 收发id_In;

  --修改药品库存(反冲库存)
  Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = n_药品id;

  If n_分批 <> 3 Then

    Update 药品库存
    Set 实际数量 = Nvl(实际数量, 0) + n_实际数量, 实际金额 = Nvl(实际金额, 0) + n_实际金额, 实际差价 = Nvl(实际差价, 0) + n_实际差价,
        零售价 = Decode(n_实价卫材, 1, Decode(Nvl(n_批次, 0), 0, Null, Decode(Nvl(零售价, 0), 0, n_零售价, 零售价)), Null)
    Where 库房id + 0 = n_库房id And 药品id = n_药品id And 性质 = 1 And Nvl(批次, 0) = n_批次;

    If Sql%RowCount = 0 Then
      Insert Into 药品库存
        (库房id, 药品id, 批次, 性质, 实际数量, 实际金额, 实际差价, 效期, 灭菌效期, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 批准文号, 零售价, 平均成本价, 商品条码,
         内部条码)
      Values
        (n_库房id, n_药品id, Decode(n_分批, 2, Null, n_批次), 1, n_实际数量, n_实际金额, n_实际差价, Decode(n_分批, 1, 效期_In, Null), d_灭菌效期,
         n_上次供应商id, n_成本价, Decode(n_分批, 1, 批号_In, Null), d_上次生产日期, v_产地, v_批准文号,
         Decode(n_实价卫材, 1, Decode(Nvl(n_批次, 0), 0, Null, n_零售价), Null), n_成本价, v_商品条码, v_内部条码);
    End If;
  Else
    Insert Into 药品库存
      (库房id, 药品id, 批次, 性质, 实际数量, 实际金额, 实际差价, 效期, 灭菌效期, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 批准文号, 零售价, 平均成本价, 商品条码, 内部条码)
    Values
      (n_库房id, n_药品id, n_新批次, 1, n_实际数量, n_实际金额, n_实际差价, 效期_In, d_灭菌效期, n_上次供应商id, n_成本价, 批号_In, d_上次生产日期, v_产地, v_批准文号,
       Decode(n_实价卫材, 1, Decode(Nvl(n_新批次, 0), 0, Null, n_零售价), Null), n_成本价, v_商品条码, v_内部条码);
  End If;

  Delete 药品库存
  Where 库房id + 0 = n_库房id And 药品id = n_药品id And 性质 = 1 And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
        Nvl(实际差价, 0) = 0;

  If (自动销帐_In = 1 And n_单据 <> 24) or (v_备货id>1 and 是否销帐_In=0 And n_单据 <> 24) Then
    Begin
      Select 主页id, NO, 序号 Into n_主页id, v_费用no, n_序号 From 住院费用记录 Where ID = n_费用id;
    Exception
      When Others Then
        Begin
          Select Null, NO, 序号 Into n_主页id, v_费用no, n_序号 From 门诊费用记录 Where ID = n_费用id;
        Exception
          When Others Then
            n_主页id := Null;
        End;
    End;
    If n_主页id Is Null Then
      Zl_门诊记帐记录_Delete(v_费用no, n_序号, v_人员编号, v_人员姓名);
    Else
      Zl_住院记帐记录_Delete(v_费用no, n_序号, v_人员编号, v_人员姓名);
    End If;
  End If;

  --备货卫材处理
  If v_备货id > 0 Then
    --2、自动冲销已审核的其他出库单据
    Begin
      Select 1
      Into n_移库
      From 药品收发记录
      Where 单据 = 15 And 审核日期 Is Null And
            费用id In (Select Distinct 费用id From 药品收发记录 Where NO = v_No And 药品id = n_药品id And 批次 = n_批次);
    Exception
      When Others Then
        n_移库 := 0;
    End;

    If n_移库 <> 0 Then
      For v_出库冲销 In (Select 1 行次, 记录状态, NO, 序号, 药品id
                     From 药品收发记录
                     Where 单据 = 21 And 审核日期 Is Not Null And 汇总发药号 = v_备货id) Loop
        Zl_材料其他出库_Strike(v_出库冲销.行次, v_出库冲销.记录状态, v_出库冲销.No, v_出库冲销.序号, v_出库冲销.药品id, 退料数量_In, 审核人_In, 审核日期_In);
      End Loop;

      --3、删除未审核的外购入库单据（已审核则不管）
      if n_部分退料=1 then
        update 药品收发记录 set 填写数量=填写数量-退料数量_In,实际数量=实际数量-退料数量_In,零售金额=零售金额-n_实际金额,成本金额=成本金额-n_实际成本,差价=差价-n_实际差价
        Where 单据 = 15 And 药品id = n_药品id And Nvl(批次, 0) = n_批次 And 费用id = n_费用id And 审核日期 Is Null;
      else
        Delete 药品收发记录
        Where 单据 = 15 And 药品id = n_药品id And Nvl(批次, 0) = n_批次 And 费用id = n_费用id And 审核日期 Is Null;
      end if;
    End If;
  End If;
  --处理调价修正单据
  Zl_材料收发记录_调价修正(n_冲销记录id);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料收发记录_部门退料;
/


--101478:梁唐彬,2016-10-12,同一收费项目不同价格等级
Create Or Replace Function Zl_Getpathcharge
(
  病人id_In   病案主页.病人id%Type, --不确定病人时传入0
  主页id_In   病案主页.主页id%Type, --不确定病人时传入0
  路径id_In   临床路径项目.路径id%Type,
  版本号_In   临床路径项目.版本号%Type,
  阶段id_In   临床路径项目.阶段id%Type, --没有指定阶段时,根据当前天数来确定缺省的阶段
  天数_In     病人路径执行.天数%Type, --当前阶段正在执行的天数
  入院时间_In Date, --病人入院或入科时间,用于计算上次执行时间(频率为每n天m次时),不确定病人时传入当前系统时间
  分支ID_In   临床路径项目.分支ID%Type := Null    --用于分支路径的费用估算
) Return Number As
  v_Error Varchar2(255);
  Err_Custom Exception;

  v_Tmp Varchar2(1000);
  n_Tmp Number(8);

  v_费别         病案主页.费别%Type;
  n_实收金额     Number(16, 5);
  n_应收金额     Number(16, 5);
  n_主项金额     Number(16, 5);
  n_实收合计     Number(16, 5);
  n_计费总量     Number(16, 5);
  n_总量         Number(16, 5);
  n_汇总计算折扣 Number(1);
  n_主收入id     Number(8);
  n_次数         Number(8);
  n_Day          Number(8); --当前天数的星期数
  n_Lastday      Number(8);
  
  v_药品等级 收费价格等级.名称%Type;
  v_卫材等级 收费价格等级.名称%Type;
  v_普通等级 收费价格等级.名称%Type;
  v_Pricegrade  varchar2(1000);
  v_站点               部门表.站点%Type;
  n_病人科室ID 病人医嘱记录.病人科室ID%Type;

  l_采集方法 Boolean;
  l_中药煎法 Boolean;
  l_中药用法 Boolean;
  l_给药途径 Boolean;
  l_输血途径 Boolean;

  v_Lasttype   诊疗项目目录.类别%Type;
  n_Lastsum    路径医嘱内容.总给予量%Type;
  n_Last相关id 路径医嘱内容.相关id%Type;
  n_Lastid     路径医嘱内容.Id%Type;
  n_Lastamount Number(8);
  n_Last付数   Number(8);
  l_Last煎法   Boolean;
  l_Do         Boolean;
  l_Firstday   Boolean;

  n_阶段id     临床路径阶段.Id%Type;
  n_前一阶段id 临床路径阶段.Id%Type;
  l_Rate       t_Strlist;

  --取药品相关信息(未明确规格时,取其中一个规格)
  Cursor Mediinfo
  (
    诊疗项目id_In Number,
    收费细目id_In Number
  ) Is
    Select g.Id As 收费细目id, Nvl(f.剂量系数, 1) As 剂量系数, f.住院可否分零, Nvl(g.是否变价, 0) 是否变价, h.缺省价格, h.现价, g.屏蔽费别, h.收入项目id,
           Nvl(h.附术收费率, 1) 附术收费率
    From 药品规格 F, 收费项目目录 G, 收费价目 H
    Where f.药名id = 诊疗项目id_In And f.药品id = Nvl(收费细目id_In, f.药品id) 
    And ((Instr(';5;6;7;', ';' || G.类别 || ';') > 0 And H.价格等级 = v_药品等级) Or
      (Instr(';4;', ';' || G.类别 || ';') > 0 And H.价格等级 = v_卫材等级) Or
      (Instr(';4;5;6;7;', ';' || G.类别 || ';') = 0 And H.价格等级 = v_普通等级) Or
      (H.价格等级 Is Null And Not Exists
       (Select 1
         From 收费价目
         Where G.Id = 收费细目id And
               ((Instr(';5;6;7;', ';' || G.类别 || ';') > 0 And 价格等级 = v_药品等级) Or
               (Instr(';4;', ';' || G.类别 || ';') > 0 And 价格等级 = v_卫材等级) Or
               (Instr(';4;5;6;7;', ';' || G.类别 || ';') = 0 And 价格等级 = v_普通等级)))))
               And f.药品id = g.Id And g.Id = h.收费细目id And
          Sysdate Between h.执行日期 And Nvl(h.终止日期, Sysdate + 1)
    Order By g.编码;
  r_Medi Mediinfo%Rowtype;

  --功能:获取指天数所属的缺省时间阶段ID
  Function Getphaseid(n_Day Number) Return Number As
    n_Id 临床路径阶段.Id%Type;
  Begin
    For R In (Select ID
              From 临床路径阶段
              Where n_Day Between Nvl(开始天数, n_Day) And Nvl(结束天数, Nvl(开始天数, n_Day)) And 路径id = 路径id_In And 版本号 = 版本号_In And NVL(分支ID,0)=NVL(分支ID_In,0)
              Order By Decode(父id, Null, 0, 1), 序号) Loop
      n_Id := r.Id;
      Exit;
    End Loop;
    Return n_Id;
  End Getphaseid;

  --功能:获取指时间阶段(不能是分支)的前一时间阶段id
  Function Getprephaseid(n_阶段id 临床路径阶段.Id%Type) Return Number As
    n_Id 临床路径阶段.Id%Type;
    n_父ID 临床路径阶段.父ID%Type;
  Begin
    Select Nvl(Max(父ID), 0) into n_父ID From 临床路径阶段 Where ID=n_阶段id;
    If n_父ID = 0 Then
      n_父ID:=n_阶段id;
    End If;
    Select Nvl(Max(b.Id), 0)
    Into n_Id
    From 临床路径阶段 A, 临床路径阶段 B
    Where a.路径id = b.路径id And a.版本号 = b.版本号 And a.Id = n_父ID And b.序号 = a.序号 - 1 And b.父id Is Null;
    Return n_Id;
  End Getprephaseid;

  --功能:获取指定路径项目的开始执行天数(入院时间为第一天)
  Function Getitembeginday(n_路径项目id 临床路径项目.Id%Type) Return Number As
    n_Preday Number(8);
    n_Id     临床路径阶段.Id%Type;
    n_Preid  临床路径阶段.Id%Type;
    n_Tmp    Number(8);
    n_Return Number(8);
  Begin
    n_Preday := 天数_In - 1;
    If n_Preday = 0 Or n_前一阶段id = 0 Then
      --当前是第一天或第一个阶段
      n_Return := 1;
    Else
      n_Id    := n_阶段id;
      n_Preid := n_前一阶段id;
      Loop
        --检查前一阶段是否有相同的路径项目
        Select Nvl(Count(p.Id), 0)
        Into n_Tmp
        From 临床路径项目 T, 临床路径项目 P
        Where t.路径id = p.路径id And t.版本号 = p.版本号 And t.项目内容 = p.项目内容 And t.Id = n_路径项目id And p.阶段id = n_Preid;
        If n_Tmp = 0 Then
          Exit;
        End If;

        n_Id := n_Preid; --如果有,继续往前找
        Select Nvl(Max(b.Id), 0)
        Into n_Preid
        From 临床路径阶段 A, 临床路径阶段 B
        Where a.路径id = b.路径id And a.版本号 = b.版本号 And a.Id = n_Id And b.序号 = a.序号 - 1;
        If n_Preid = 0 Then
          Exit;
        End If;
      End Loop;

      Select Nvl(开始天数, 0) Into n_Tmp From 临床路径阶段 Where ID = n_Id;
      If n_Tmp = 0 Then
        --不定期间的两个阶段不可能连续,所以取前一个阶段的结束天数+1
        Select Nvl(Nvl(结束天数, 开始天数), 0) + 1 Into n_Tmp From 临床路径阶段 Where ID = n_Preid;
      End If;
      If n_Tmp <= 1 Then
        n_Return := 1;
      Else
        n_Return := n_Tmp;
      End If;
    End If;
    Return n_Return;
  End Getitembeginday;

  --功能:获取时价药品的应收金额(因为是估算,不管出库模式  )
  Function Get时价药品金额
  (
    n_总数量     In Number,
    n_执行科室id In Number,
    n_收费细目id In Number
  ) Return Number As
    n_总金额   Number(16, 5);
    n_可用数量 Number(16, 5);
    n_本次数量 Number(16, 5);
  Begin
    n_总金额   := 0;
    n_可用数量 := n_总数量;
    For D In (Select Nvl(可用数量, 0) As 库存, Nvl(零售价, Nvl(Decode(Nvl(实际数量, 0), 0, 0, 实际金额 / 实际数量), 0)) As 时价
              From 药品库存
              Where 库房id = n_执行科室id And 药品id = n_收费细目id And Nvl(可用数量, 0) > 0 And 性质 = 1 And
                    (Nvl(批次, 0) = 0 Or 效期 Is Null Or 效期 > Trunc(Sysdate))
              Order By Nvl(批次, 0)) Loop
      If n_可用数量 <= d.库存 Then
        n_本次数量 := n_可用数量;
      Else
        n_本次数量 := d.库存;
      End If;
      n_总金额   := n_总金额 + n_本次数量 * d.时价;
      n_可用数量 := n_可用数量 - n_本次数量;
      If n_可用数量 = 0 Then
        Exit;
      End If;
    End Loop;
    Return n_总金额;
  End Get时价药品金额;
Begin
  Select To_Char(Sysdate, 'D') - 1 Into n_Day From Dual;
  If n_Day = 0 Then
    n_Day := 7;
  End If;
  
  Select 入院科室ID into n_病人科室ID From 病案主页 Where 病人ID=病人ID_In And 主页ID=主页ID_in;
  Select Min(站点) Into v_站点 From 部门表 Where ID = n_病人科室ID;  
  v_Pricegrade := Zl_Get_Pricegrade(v_站点,病人ID_In,主页ID_in);
  v_药品等级   := Substr(v_Pricegrade, 1, Instr(v_Pricegrade, '|') - 1);
  v_Pricegrade := Substr(v_Pricegrade, Instr(v_Pricegrade, '|') + 1);
  v_卫材等级   := Substr(v_Pricegrade, 1, Instr(v_Pricegrade, '|') - 1);
  v_Pricegrade := Substr(v_Pricegrade, Instr(v_Pricegrade, '|') + 1);
  v_普通等级   := Substr(v_Pricegrade, 1, Instr(v_Pricegrade, '|') - 1);

  If Nvl(阶段id_In, 0) = 0 Then
    n_阶段id := Getphaseid(天数_In);
    n_Tmp    := n_阶段id;
  Else
    n_阶段id := 阶段id_In; --如果当前是分支,则求缺省分支
    Select Nvl(父id, ID) Into n_Tmp From 临床路径阶段 Where ID = n_阶段id;
  End If;
  n_前一阶段id := Getprephaseid(n_Tmp);

  l_Firstday := False;
  Select Nvl(开始天数, 0) Into n_Tmp From 临床路径阶段 Where ID = n_阶段id;
  If n_Tmp = 0 Then
    --不定期间的两个阶段不可能连续,所以取前一个阶段的结束天数+1
    Select Nvl(Nvl(结束天数, 开始天数), 0) + 1 Into n_Tmp From 临床路径阶段 Where ID = n_前一阶段id;
  End If;
  If n_Tmp = 天数_In Then
    l_Firstday := True;
  End If;

  If Nvl(病人id_In, 0) <> 0 Then
    Select 费别 Into v_费别 From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
  End If;
  n_汇总计算折扣 := Nvl(Zl_Getsysparameter(93), 0);
  n_实收合计     := 0;

  --院外执行和无执行的叮嘱除外,不计价的除外
  For R In (Select Nvl(c.相关id, c.Id) As 组id, Nvl(e.序号, c.序号) As 组号, c.序号, a.Id, c.相关id, c.期效, d.类别, c.诊疗项目id, c.收费细目id,
                   c.执行科室id, c.标本部位, c.检查方法, Nvl(c.单次用量, 1) As 单次用量, c.总给予量, c.执行频次, c.频率次数, c.频率间隔, c.间隔单位, c.执行性质,
                   c.时间方案, Nvl(d.计算规则, 0) As 计算规则, a.执行方式
            From 临床路径项目 A, 临床路径医嘱 B, 路径医嘱内容 C, 诊疗项目目录 D, 路径医嘱内容 E
            Where a.路径id = 路径id_In And a.版本号 = 版本号_In And NVL(a.分支id,0)=NVL(分支ID_In,0) And a.阶段id = n_阶段id And a.执行方式 Not In (0, 3) And a.Id = b.路径项目id And
                  b.医嘱内容id = c.Id And c.诊疗项目id = d.Id And c.执行性质 Not In (0, 5) And d.计价性质 <> 1 And c.相关id = e.Id(+)
            Order By a.项目序号, 组号, 组id, c.序号) Loop
    l_Do := True;
    If r.执行方式 = 2 Then
      l_Do := l_Firstday; --至少执行一次的项目,仅在本阶段的第一天时计算
    End If;
    If l_Do Then
      --1.计算总量
      n_次数     := 0;
      l_中药煎法 := False;
      l_输血途径 := False;
      l_中药用法 := False;
      l_采集方法 := False;
      l_给药途径 := False;
      If r.类别 = 'E' And r.相关id Is Not Null And r.相关id = n_Last相关id Then
        If v_Lasttype = '7' Then
          l_中药煎法 := True;
        Elsif v_Lasttype = 'K' Then
          l_输血途径 := True;
        End If;
      Elsif r.类别 = 'E' And r.相关id Is Null And r.Id = n_Last相关id Then
        If l_Last煎法 Or v_Lasttype = '7' Then
          l_中药用法 := True;
        Elsif v_Lasttype = 'C' Then
          l_采集方法 := True;
        Elsif v_Lasttype In ('5', '6') Then
          l_给药途径 := True;
        End If;
      End If;
      If r.类别 In ('5', '6', '7') Then
        Open Mediinfo(r.诊疗项目id, r.收费细目id);
        Fetch Mediinfo
          Into r_Medi;
        Close Mediinfo;
      End If;

      --长嘱
      If r.期效 = 0 Then
        --a.主要医嘱或一并采集的检验项目,或药品(因为是估算,不考虑动态分零对数量的影响)
        If (r.相关id Is Null And Not l_采集方法 And Not l_中药用法 And Not l_给药途径) Or (r.相关id Is Not Null And r.类别 = 'C') Or
           r.类别 In ('5', '6', '7') Then

          If r.时间方案 Is Null And (Nvl(r.频率次数, 0) = 0 Or Nvl(r.频率间隔, 0) = 0 Or r.间隔单位 Is Null) Then
            n_次数 := 1; --持续性项目 --因为是估算,简化为不考虑起止时间,按每天一次算
          Else
            Select Column_Value Bulk Collect Into l_Rate From Table(f_Str2list(r.时间方案, '-')); --执行频率为"可选频率"的项目
            Case r.间隔单位
              When '周' Then
                --例:每周三次： 1/8:00-3/8:00-5/8:00或1/8-3/8-5/8
                For I In 1 .. l_Rate.Count Loop
                  If n_Day = Substr(l_Rate(I), 1, Instr(l_Rate(I), '/') - 1) Then
                    n_次数 := n_次数 + 1;
                  End If;
                End Loop;
              When '天' Then
                --例:每天三次：8:00-12:00-16:00 或 8:12:16
                If r.频率间隔 = 1 Then
                  If 天数_In = 1 Then
                    For I In 1 .. l_Rate.Count Loop
                      If 入院时间_In <= To_Date(To_Char(入院时间_In, 'yyyy-mm-dd') || ' ' || l_Rate(I), 'yyyy-mm-dd hh24:mi') Then
                        n_次数 := n_次数 + 1; --入院当天
                      End If;
                    End Loop;
                  Else
                    n_次数 := r.频率次数;
                  End If;
                Else
                  n_Lastday := 天数_In - Getitembeginday(r.Id); --例:两天一次： 1/8 或 1/8:00
                  For I In 1 .. l_Rate.Count Loop
                    If n_Lastday = Substr(l_Rate(I), 1, Instr(l_Rate(I), '/') - 1) Then
                      n_次数 := n_次数 + 1;
                    End If;
                  End Loop;
                End If;
              When '小时' Then
                If 天数_In = 1 Then
                  n_次数 := Trunc(Trunc((Trunc(入院时间_In + 1) - 入院时间_In) * 24) / r.频率间隔); --入院当天
                Else
                  n_次数 := Trunc(24 / r.频率间隔);
                End If;
              When '分钟' Then
                If 天数_In = 1 Then
                  n_次数 := Trunc(Trunc((Trunc(入院时间_In + 1) - 入院时间_In) * 24 * 60) / r.频率间隔); --入院当天
                Else
                  n_次数 := Trunc((24 * 60) / r.频率间隔);
                End If;
            End Case;
          End If;
          If r.类别 = '7' Then
            n_次数 := r.总给予量 * n_次数;
            If r_Medi.住院可否分零 = 0 Then
              n_总量 := n_次数 * r.单次用量 / r_Medi.剂量系数;
            Else
              n_总量 := n_次数 * Ceil(r.单次用量 / r_Medi.剂量系数); --总给予量=付数
            End If;
            n_Last付数 := n_次数; --中药煎法、用法的总给予量为付数
          Elsif r.类别 = '5' Or r.类别 = '6' Then
            If r_Medi.住院可否分零 = 0 Then
              n_总量 := n_次数 * r.单次用量 / r_Medi.剂量系数; --可分零
            Elsif r_Medi.住院可否分零 = 1 Then
              n_总量 := Ceil(n_次数 * r.单次用量 / r_Medi.剂量系数); --不分零
            Elsif r_Medi.住院可否分零 = 2 Then
              n_总量 := n_次数 * Ceil(r.单次用量 / r_Medi.剂量系数); --一次性
            Else
              n_总量 := Ceil(n_次数 * r.单次用量 / r_Medi.剂量系数); --可否分零<0  :n天内分零使用有效,计算太复杂,按不可分零处理
            End If;
          Else
            If r.计算规则 = 1 Then
              n_总量 := Ceil(r.单次用量 * n_次数); --取最大整数--取整计算，适用于可选频率的计量、计时、计次长期医嘱。
            Else
              n_总量 := r.单次用量 * n_次数;
            End If;
          End If;
        Elsif l_中药煎法 Or l_中药用法 Then
          n_总量 := n_Last付数; --b.中药煎法、用法为付数
          n_次数 := n_Lastamount;
        Elsif l_给药途径 Then
          n_总量 := n_Lastamount; --c.给药途径
          n_次数 := n_Lastamount;
        Elsif l_输血途径 Then
          n_总量 := n_Lastamount; --d.输血途径的执行次数
          n_次数 := n_Lastamount;
        Elsif r.相关id Is Not Null Or l_采集方法 Then
          n_总量 := n_Lastsum; --e.附加医嘱或标本采集方法(检查组合和手术组合不可能为长嘱,所以此段不会执行)
          n_次数 := n_Lastamount;
        End If;
      Else
        --临嘱
        If r.类别 = '7' Then
          n_次数 := r.总给予量;
          If r_Medi.住院可否分零 = 0 Then
            n_总量 := r.总给予量 * r.单次用量 / r_Medi.剂量系数;
          Else
            n_总量 := r.总给予量 * Ceil(r.单次用量 / r_Medi.剂量系数); --总给予量=付数
          End If;
        Elsif r.类别 In ('5', '6') Then
          If Nvl(r.频率次数, 0) = 0 Or Nvl(r.频率间隔, 0) = 0 Then
            n_次数 := 1; --一次性的临嘱药品
            --因为没有天数,所以不按频率计算
          Elsif r_Medi.住院可否分零 = 0 And Nvl(r.单次用量, 0) <> 0 Then
            --可分零药品时,按总量对单量的倍数计算给药途径的次数,否则按一个频率周期的次数计算
            n_次数 := Trunc(r.总给予量 * r_Medi.剂量系数 / r.单次用量);
          Else
            n_次数 := r.频率次数;
          End If;
          n_总量 := r.总给予量;
        Elsif l_中药煎法 Or l_中药用法 Or l_给药途径 Then
          n_总量 := n_Lastamount; --给药途径,中药用法,煎法的次数
          n_次数 := n_Lastamount;
        Elsif (r.相关id Is Null And Not l_采集方法) Or (r.相关id Is Not Null And r.类别 = 'C') Then
          --主要医嘱或一并采集的检验项目
          n_总量 := Nvl(r.总给予量, 1);
          n_次数 := Ceil(n_总量 / r.单次用量);
        Elsif l_输血途径 Then
          n_总量 := n_Lastamount; --d.输血途径的执行次数
          n_次数 := n_Lastamount;
        Elsif r.相关id Is Not Null Or l_采集方法 Then
          n_总量 := n_Lastsum; --e.附加医嘱或标本采集方法
          n_次数 := n_Lastamount;
        End If;
      End If;
      n_Lastamount := n_次数;
      n_Lastsum    := n_总量;
      v_Lasttype   := r.类别;
      n_Last相关id := r.相关id;
      n_Lastid     := r.Id;
      l_Last煎法   := l_中药煎法;

      --2.计算实收金额(不考虑加班加价)
      n_实收金额 := 0;
      n_应收金额 := 0;
      n_主收入id := 0;
      n_主项金额 := 0;
      If r.类别 In ('4', '5', '6', '7') Then

        If r_Medi.是否变价 = 0 Then
          n_应收金额 := r_Medi.现价 * n_总量;
        Else
          n_应收金额 := Get时价药品金额(n_总量, r.执行科室id, r_Medi.收费细目id);
        End If;
        If Not (v_费别 Is Null Or r_Medi.屏蔽费别 = 1) Then
          v_Tmp      := Zl_Actualmoney(v_费别, r_Medi.收费细目id, r_Medi.收入项目id, n_应收金额, n_总量, r.执行科室id);
          n_实收金额 := Substr(v_Tmp, Instr(v_Tmp, ':') + 1);
        Else
          n_实收金额 := n_应收金额;
        End If;
        n_实收合计 := n_实收合计 + n_实收金额;

      Else
        For D In (Select c.类别, c.Id As 收费细目id, a.收费数量, b.收入项目id, Decode(c.是否变价, 1, b.缺省价格, b.现价) As 单价, c.是否变价,
                         Nvl(a.从属项目, 0) As 从项, d.跟踪在用, c.屏蔽费别, Nvl(a.费用性质, 0) As 费用性质, Nvl(a.收费方式, 0) As 收费方式, b.附术收费率
                  From 诊疗收费关系 A, 收费价目 B, 收费项目目录 C, 材料特性 D
                  Where a.诊疗项目id = r.诊疗项目id And (r.类别 <> 'D' Or r.类别 = 'D' And a.检查部位 = r.标本部位 And a.检查方法 = r.检查方法) 
                  And ((Instr(';5;6;7;', ';' || C.类别 || ';') > 0 And B.价格等级 = v_药品等级) Or
                    (Instr(';4;', ';' || C.类别 || ';') > 0 And B.价格等级 = v_卫材等级) Or
                    (Instr(';4;5;6;7;', ';' || C.类别 || ';') = 0 And B.价格等级 = v_普通等级) Or
                    (B.价格等级 Is Null And Not Exists
                     (Select 1
                       From 收费价目
                       Where C.Id = 收费细目id And
                             ((Instr(';5;6;7;', ';' || C.类别 || ';') > 0 And 价格等级 = v_药品等级) Or
                             (Instr(';4;', ';' || C.类别 || ';') > 0 And 价格等级 = v_卫材等级) Or
                             (Instr(';4;5;6;7;', ';' || C.类别 || ';') = 0 And 价格等级 = v_普通等级)))))
                  And  a.收费项目id = b.收费细目id And a.收费项目id = c.Id And a.收费项目id = d.材料id(+) And c.服务对象 In (2, 3) And
                        (c.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or c.撤档时间 Is Null) And Sysdate Between b.执行日期 And
                        Nvl(b.终止日期, Sysdate + 1) And
                        (a.收费方式 = 1 And c.类别 = '4' And a.收费项目id = r_Medi.收费细目id Or Not (a.收费方式 = 1 And c.类别 = '4'))
                  Order By 费用性质, 从项, a.收费项目id) Loop
          n_计费总量 := n_总量 * d.收费数量;

          If d.是否变价 = 1 And (d.类别 In ('5', '6', '7') Or (d.类别 = '4' And d.跟踪在用 = 1)) Then
            n_应收金额 := Get时价药品金额(n_计费总量, r.执行科室id, d.收费细目id); --时价非药嘱药品或跟踪在用的卫材
          Elsif r.类别 = 'F' And r.相关id Is Not Null Then
            n_应收金额 := d.单价 * Nvl(d.附术收费率, 100) / 100 * n_计费总量;
          Else
            n_应收金额 := d.单价 * n_计费总量;
          End If;
          If n_应收金额 <> 0 Then
            If d.从项 = 0 And n_汇总计算折扣 = 1 And n_主收入id = 0 Then
              n_主收入id := d.收入项目id; --SQL中主项排在前面,只取主项目的第一个收入
            End If;

            If n_主收入id <> 0 Then
              n_主项金额 := n_主项金额 + n_应收金额;
              n_实收金额 := n_应收金额;
            Elsif v_费别 Is Null Or d.屏蔽费别 = 1 Then
              n_实收金额 := n_应收金额;
            Else
              v_Tmp      := Zl_Actualmoney(v_费别, d.收费细目id, d.收入项目id, n_应收金额, n_计费总量, r.执行科室id);
              n_实收金额 := Substr(v_Tmp, Instr(v_Tmp, ':') + 1);
            End If;
            n_实收合计 := n_实收合计 + n_实收金额;
          End If;
        End Loop;
        If n_主收入id <> 0 And n_主项金额 <> 0 Then
          v_Tmp      := Zl_Actualmoney(v_费别, 0, n_主收入id, n_主项金额);
          n_实收金额 := Substr(v_Tmp, Instr(v_Tmp, ':') + 1);
          n_实收合计 := n_实收合计 + n_实收金额;
        End If;
      End If;
    End If;
  End Loop;
  Return n_实收合计;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_Getpathcharge;
/

--98682:梁唐彬,2017-06-17,校对时自动确认停止护理等级医嘱
--101478:梁唐彬,2016-10-12,同一收费项目不同价格等级
CREATE OR REPLACE Procedure Zl_病人医嘱记录_校对
(
  --功能：校对指定的医嘱
  --参数：医嘱ID_IN=Nvl(相关ID,ID)
  --      状态_IN=校对通过3或校对疑问2
  --      自动校对_IN=保存之后调用自动校对,自动填写计价内容
  --说明：一组医嘱只能调用一次,过程同时完成处理一组医嘱的校对
  医嘱id_In     病人医嘱记录.Id%Type,
  状态_In       病人医嘱记录.医嘱状态%Type,
  校对时间_In   病人医嘱状态.操作时间%Type,
  校对说明_In   病人医嘱状态.操作说明%Type := Null,
  自动校对_In   Number := Null,
  操作员编号_In 人员表.编号%Type := Null,
  操作员姓名_In 人员表.姓名%Type := Null
) Is
  --用于医嘱检查
  v_状态       病人医嘱记录.医嘱状态%Type;
  v_期效       病人医嘱记录.医嘱期效%Type;
  v_病人id     病人医嘱记录.病人id%Type;
  v_主页id     病人医嘱记录.主页id%Type;
  v_婴儿       病人医嘱记录.婴儿%Type;
  v_医嘱内容   病人医嘱记录.医嘱内容%Type;
  v_开嘱时间   病人医嘱记录.开嘱时间%Type;
  v_开始时间   病人医嘱记录.开始执行时间%Type;
  v_开嘱医生   病人医嘱记录.开嘱医生%Type;
  v_前提id     病人医嘱记录.前提id%Type;
  v_执行标记   病人医嘱记录.执行标记%Type;
  v_执行科室id 病人医嘱记录.执行科室id%Type;
  v_标本部位   病人医嘱记录.标本部位%Type;
  v_停止时间   病人医嘱记录.开嘱时间%Type;
  v_开嘱科室id 病人医嘱记录.开嘱科室id%Type;
  n_病人科室ID 病人医嘱记录.病人科室ID%Type;

  --用于变更护理等级
  v_诊疗类别   病人医嘱记录.诊疗类别%Type;
  v_诊疗项目id 病人医嘱记录.诊疗项目id%Type;
  v_操作类型   诊疗项目目录.操作类型%Type;
  v_护理等级id 病案主页.护理等级id%Type;
  v_紧急标志   病人医嘱记录.紧急标志%Type;
  v_入院方式   入院方式.名称%Type;

  v_药品等级 收费价格等级.名称%Type;
  v_卫材等级 收费价格等级.名称%Type;
  v_普通等级 收费价格等级.名称%Type;
  v_Pricegrade  varchar2(1000);
  v_站点               部门表.站点%Type;

  v_Stopadviceids 病人医嘱记录.医嘱内容%Type;
  n_Adviceid      病人医嘱记录.病人id%Type;
  n_标记          Number(18);
  --与该项目同一自动停止互斥组的项目:组中应该都是长嘱(包括当前医嘱),程序应已检查。
  --注意应加婴儿条件,同时也应停止除当前医嘱外的其它相同诊疗项目的医嘱。
  Cursor c_Exclude Is
    Select Distinct b.Id As 医嘱id, b.开始执行时间, b.执行终止时间, b.上次执行时间, b.开嘱医生, b.执行时间方案, b.频率间隔, b.频率次数, b.间隔单位
    From 诊疗互斥项目 A, 病人医嘱记录 B
    Where a.类型 = 3 And a.项目id = b.诊疗项目id And b.Id <> 医嘱id_In And Nvl(b.医嘱期效, 0) = 0 And b.医嘱状态 In (3, 5, 6, 7) And
          b.病人id = v_病人id And Nvl(b.主页id, 0) = Nvl(v_主页id, 0) And Nvl(b.婴儿, 0) = Nvl(v_婴儿, 0) And
          a.组编号 In (Select Distinct 组编号 From 诊疗互斥项目 Where 类型 = 3 And 项目id = v_诊疗项目id)
    Order By b.Id;
  v_终止时间 病人医嘱记录.执行终止时间%Type;

  --护理等级互斥
  Cursor c_Nurse Is
    Select a.Id As 医嘱id, a.开始执行时间, a.执行终止时间, a.上次执行时间, a.开嘱医生
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id And a.诊疗类别 = 'H' And b.操作类型 = '1' And a.病人id = v_病人id And Nvl(a.主页id, 0) = Nvl(v_主页id, 0) And
          Nvl(a.婴儿, 0) = Nvl(v_婴儿, 0) And Nvl(a.医嘱期效, 0) = 0 And a.医嘱状态 In (3, 5, 6, 7) And a.Id <> 医嘱id_In;

  --记录入出量互斥
  Cursor c_Patiio Is
    Select a.Id As 医嘱id, a.开始执行时间, a.执行终止时间, a.上次执行时间, a.开嘱医生
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id And a.诊疗类别 = 'Z' And b.操作类型 = '12' And a.病人id = v_病人id And Nvl(a.主页id, 0) = Nvl(v_主页id, 0) And
          Nvl(a.婴儿, 0) = Nvl(v_婴儿, 0) And Nvl(a.医嘱期效, 0) = 0 And a.医嘱状态 In (3, 5, 6, 7) And a.Id <> 医嘱id_In;

  --记录病情互斥
  Cursor c_Patistate Is
    Select a.Id As 医嘱id, a.开始执行时间, a.执行终止时间, a.上次执行时间, a.开嘱医生
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id And a.诊疗类别 = 'Z' And b.操作类型 In ('9', '10') And a.病人id = v_病人id And
          Nvl(a.主页id, 0) = Nvl(v_主页id, 0) And Nvl(a.婴儿, 0) = Nvl(v_婴儿, 0) And Nvl(a.医嘱期效, 0) = 0 And
          a.医嘱状态 In (3, 5, 6, 7) And a.Id <> 医嘱id_In;
  --变动有效记录
  Cursor c_Oldinfo Is
    Select b.*
    From (Select c.*
           From 病人变动记录 C
           Where c.病人id = v_病人id And c.主页id = v_主页id And
                 c.开始时间 = (Select Min(开始时间)
                           From 病人变动记录
                           Where 病人id = v_病人id And 主页id = v_主页id And 开始时间 > v_开始时间) And
                 NVL(c.终止时间|| '','空') = (Select  NVL(Min(终止时间)|| '','空')
                           From 病人变动记录
                           Where 病人id = v_病人id And 主页id = v_主页id And 开始时间 > v_开始时间)) A, 病人变动记录 B

    Where b.病人id = v_病人id And b.主页id = v_主页id And a.开始时间 = b.终止时间 And a.开始原因 = b.终止原因 And a.附加床位 = b.附加床位
    Union
    Select *
    From 病人变动记录
    Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 Is Null And 开始时间 <= v_开始时间;

  Cursor c_Endinfo Is
    Select * From 病人变动记录 Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 Is Null;
  r_Oldinfo      c_Oldinfo%RowType;
  r_Endinfo      c_Endinfo%RowType;
  v_变动终止原因 病人变动记录.终止原因%Type;
  v_变动终止时间 病人变动记录.终止时间%Type;
  v_变动终止人员 病人变动记录.终止人员%Type;

  --包含病人(婴儿)的所有未停长嘱(含配方长嘱)
  Cursor c_Needstop
  (
    v_病人id   病人医嘱记录.病人id%Type,
    v_主页id   病人医嘱记录.主页id%Type,
    v_婴儿     病人医嘱记录.婴儿%Type,
    v_Stoptime Date
  ) Is
    Select a.Id, a.诊疗类别, b.操作类型, b.执行频率
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id(+) And a.病人id = v_病人id And a.主页id = v_主页id And (v_婴儿 = -1 Or Nvl(a.婴儿, 0) = Nvl(v_婴儿, 0)) And
          Nvl(a.医嘱期效, 0) = 0 And a.医嘱状态 Not In (1, 2, 4, 8, 9) And a.开始执行时间 < v_Stoptime
    Order By a.序号;
  --包含病人(婴儿)的已停但未确认的长嘱,终止执行时间在指定时间之后
  Cursor c_Havestop
  (
    v_病人id   病人医嘱记录.病人id%Type,
    v_主页id   病人医嘱记录.主页id%Type,
    v_婴儿     病人医嘱记录.婴儿%Type,
    v_Stoptime Date
  ) Is
    Select ID
    From 病人医嘱记录
    Where 病人id = v_病人id And 主页id = v_主页id And (v_婴儿 = -1 Or Nvl(婴儿, 0) = Nvl(v_婴儿, 0)) And Nvl(医嘱期效, 0) = 0 And
          医嘱状态 = 8 And 执行终止时间 > v_Stoptime And 开始执行时间 < v_Stoptime
    Order By 序号;

  --取一组医嘱的计价内容
  Cursor c_Price Is
    Select a.Id, b.收费项目id, b.收费数量, b.从属项目, b.费用性质, b.收费方式, c.类别 As 收费类别, a.诊疗类别, e.操作类型, e.试管编码,
           Sum(Decode(Nvl(c.是否变价, 0), 1, Nvl(d.缺省价格, d.原价), Null)) As 单价
    From 病人医嘱记录 A, 诊疗收费关系 B, 收费项目目录 C, 收费价目 D, 诊疗项目目录 E
    Where a.诊疗项目id = b.诊疗项目id And b.收费项目id = c.Id And c.Id = d.收费细目id
      And ((Instr(';5;6;7;', ';' || C.类别 || ';') > 0 And D.价格等级 = v_药品等级) Or
      (Instr(';4;', ';' || C.类别 || ';') > 0 And D.价格等级 = v_卫材等级) Or
      (Instr(';4;5;6;7;', ';' || C.类别 || ';') = 0 And D.价格等级 = v_普通等级) Or
      (D.价格等级 Is Null And Not Exists
       (Select 1
         From 收费价目
         Where C.Id = 收费细目id And
               ((Instr(';5;6;7;', ';' || C.类别 || ';') > 0 And 价格等级 = v_药品等级) Or
               (Instr(';4;', ';' || C.类别 || ';') > 0 And 价格等级 = v_卫材等级) Or
               (Instr(';4;5;6;7;', ';' || C.类别 || ';') = 0 And 价格等级 = v_普通等级)))))
          And (a.相关id Is Null And a.执行标记 In (1, 2) And b.费用性质 = 1 Or
          a.标本部位 = b.检查部位 And a.检查方法 = b.检查方法 And Nvl(b.费用性质, 0) = 0 Or
          a.检查方法 Is Null And Nvl(b.费用性质, 0) = 0 And b.检查部位 Is Null And b.检查方法 Is Null) And
          a.诊疗类别 Not In ('5', '6', '7') And Nvl(a.计价特性, 0) = 0 And Nvl(a.执行性质, 0) Not In (0, 5) And c.服务对象 In (2, 3) And
          (c.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or c.撤档时间 Is Null) And Sysdate Between d.执行日期 And
          Nvl(d.终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')) And Nvl(b.收费数量, 0) <> 0 And
          Not (Nvl(c.是否变价, 0) = 1 And Nvl(Nvl(d.缺省价格, d.原价), 0) = 0) And a.诊疗项目id = e.Id And
          (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In)
    Group By a.Id, b.收费项目id, b.收费数量, b.从属项目, b.费用性质, b.收费方式, c.类别, a.诊疗类别, e.操作类型, e.试管编码;

  Cursor c_Pati(v_病人id 病人信息.病人id%Type) Is
    Select * From 病人信息 Where 病人id = v_病人id;
  r_Pati c_Pati%RowType;

  v_材料id 采血管类型.材料id%Type;

  --其它临时变量
  v_Count    Number;
  v_Date     Date;
  v_Temp     Varchar2(255);
  v_Par停嘱  Varchar2(255);
  v_人员编号 人员表.编号%Type;
  v_人员姓名 人员表.姓名%Type;

  v_Error Varchar2(255);
  Err_Custom Exception;

  Function Getadvicetext(v_医嘱id 病人医嘱记录.Id%Type) Return Varchar2 Is
    v_Text 病人医嘱记录.医嘱内容%Type;
    v_类别 病人医嘱记录.诊疗类别%Type;
    v_配方 Number;
  Begin
    Select 诊疗类别, 医嘱内容 Into v_类别, v_Text From 病人医嘱记录 Where ID = v_医嘱id;
    If v_类别 = 'E' Then
      --西药，中成药的医嘱内容
      Begin
        Select 诊疗类别, Decode(诊疗类别, '7', v_Text, 医嘱内容)
        Into v_类别, v_Text
        From 病人医嘱记录
        Where 相关id = v_医嘱id And 诊疗类别 In ('5', '6', '7') And Rownum = 1;
      Exception
        When Others Then
          Null;
      End;
      If v_类别 = '7' Then
        v_配方 := 1;
      End If;
    End If;
    If Length(v_Text) > 30 Then
      v_Text := Substr(v_Text, 1, 30) || '...';
    End If;
    If Length(v_Text) > 20 Then
      v_Text := '"' || v_Text || '"' || Chr(13) || Chr(10);
    Else
      v_Text := '"' || v_Text || '"';
    End If;
    If v_配方 = 1 Then
      v_Text := '中药配方' || v_Text;
    End If;
    Return(v_Text);
  End;
Begin
  --检查医嘱状态是否正确:并发操作
  Begin
    Select a.医嘱期效, a.医嘱状态, a.开嘱时间, a.开嘱医生, a.开始执行时间, a.病人id, a.主页id, a.婴儿, a.医嘱内容, a.诊疗类别, a.诊疗项目id, a.前提id,
           Nvl(b.操作类型, '0'), Nvl(a.执行标记, 0), a.执行科室id, a.标本部位, a.开嘱科室id, Nvl(a.紧急标志, 0) As 紧急标志,A.病人科室ID
    Into v_期效, v_状态, v_开嘱时间, v_开嘱医生, v_开始时间, v_病人id, v_主页id, v_婴儿, v_医嘱内容, v_诊疗类别, v_诊疗项目id, v_前提id, v_操作类型, v_执行标记,
         v_执行科室id, v_标本部位, v_开嘱科室id, v_紧急标志,n_病人科室ID
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id(+) And a.Id = 医嘱id_In;
  Exception
    When Others Then
      Begin
        v_Error := '医嘱已被删除，不能进行校对。' || Chr(13) || Chr(10) || '这可能是并发操作引起的，请重新读取校对数据。';
        Raise Err_Custom;
      End;
  End;
  If v_状态 <> 1 Then
    v_Error := '医嘱"' || Getadvicetext(医嘱id_In) || '"不是新开的医嘱，不能通过校对。' || Chr(13) || Chr(10) || '这可能是并发操作引起的，请重新读取校对数据。';
    Raise Err_Custom;
  End If;
  --再次检查校对时间的有效性:并发操作
  If To_Char(v_开嘱时间, 'YYYY-MM-DD HH24:MI') <= To_Char(v_开始时间, 'YYYY-MM-DD HH24:MI') Then
    If To_Char(校对时间_In, 'YYYY-MM-DD HH24:MI') < To_Char(v_开嘱时间, 'YYYY-MM-DD HH24:MI') Then
      v_Error := '医嘱"' || Getadvicetext(医嘱id_In) || '"的校对时间不能小于开嘱时间 ' || To_Char(v_开嘱时间, 'YYYY-MM-DD HH24:MI') || '。' ||
                 Chr(13) || Chr(10) || '这可能是并发操作引起的，请重新读取校对数据。';
      Raise Err_Custom;
    End If;
  Else
    If To_Char(校对时间_In, 'YYYY-MM-DD HH24:MI') < To_Char(v_开始时间, 'YYYY-MM-DD HH24:MI') Then
      v_Error := '医嘱"' || Getadvicetext(医嘱id_In) || '"的校对时间不能小于开始执行时间 ' || To_Char(v_开始时间, 'YYYY-MM-DD HH24:MI') || '。' ||
                 Chr(13) || Chr(10) || '这可能是并发操作引起的，请重新读取校对数据。';
      Raise Err_Custom;
    End If;
  End If;

  --如果要求签名，检查校对时是否有签名(并发取消签名)
  If 状态_In = 3 Then
    Select Zl_Fun_Getsignpar(Decode(v_前提id, Null, 1, 3), v_开嘱科室id) Into v_Count From Dual;
    If v_Count = 1 Then
      --证书停用或未注册证书不进入签名环节只判断一条数据即可
      For C In (Select a.是否停用
                From 人员证书记录 A, 人员表 B
                Where a.人员id = b.Id And b.姓名 = v_开嘱医生
                Order By a.注册时间 Desc) Loop
        If Nvl(c.是否停用, 0) = 0 Then
          Select Count(*)
          Into v_Count
          From 病人医嘱状态 A
          Where 操作类型 = 1 And 医嘱id = 医嘱id_In And
                (签名id Is Null And Exists
                 (Select 1
                  From 人员表 R, 人员性质说明 X
                  Where r.Id = x.人员id And r.姓名 = a.操作人员 And x.人员性质 = '护士') And Not Exists
                 (Select 1
                  From 人员表 R, 人员性质说明 Y
                  Where r.Id = y.人员id And r.姓名 = a.操作人员 And y.人员性质 = '医生') Or 签名id Is Not Null Or a.操作人员 <> v_开嘱医生);
          If Nvl(v_Count, 0) = 0 Then
            v_Error := '医嘱"' || Getadvicetext(医嘱id_In) || '"还没有电子签名，不能通过校对。';
            Raise Err_Custom;
          End If;
        End If;
        Exit;
      End Loop;
    End If;
  End If;

  --当前操作人员
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
    v_人员编号 := 操作员编号_In;
    v_人员姓名 := 操作员姓名_In;
  Else
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;

  --因为可能同时：新开->自动校对->互斥自动停止,因此分别-2,-1秒
  Select Sysdate - 1 / 60 / 60 / 24 Into v_Date From Dual;

  Update 病人医嘱记录
  Set 医嘱状态 = 状态_In, 校对护士 = v_人员姓名, 校对时间 = 校对时间_In
  Where ID = 医嘱id_In Or 相关id = 医嘱id_In;

  Insert Into 病人医嘱状态
    (医嘱id, 操作类型, 操作人员, 操作时间, 操作说明)
    Select ID, 状态_In, v_人员姓名, v_Date, 校对说明_In From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;

  --校对通过时的其它处理
  If 状态_In = 3 Then
    --自动校对时，自动填写缺省的计价内容
    If Nvl(自动校对_In, 0) = 1 Then
      --1.变价的计价项目,如果最低限价不为0,则缺省为最低限价,否则不加入;可再手工计价.
      --2.对于非药嘱药品和在用卫材未定执行科室,发送时会取缺省的,可再手工设置。
      Select Min(站点) Into v_站点 From 部门表 Where ID = n_病人科室ID;

      v_Pricegrade := Zl_Get_Pricegrade(v_站点,v_病人id,v_主页ID);
      v_药品等级   := Substr(v_Pricegrade, 1, Instr(v_Pricegrade, '|') - 1);
      v_Pricegrade := Substr(v_Pricegrade, Instr(v_Pricegrade, '|') + 1);
      v_卫材等级   := Substr(v_Pricegrade, 1, Instr(v_Pricegrade, '|') - 1);
      v_Pricegrade := Substr(v_Pricegrade, Instr(v_Pricegrade, '|') + 1);
      v_普通等级   := Substr(v_Pricegrade, 1, Instr(v_Pricegrade, '|') - 1);
      For r_Price In c_Price Loop
        --取(检验)医嘱的管码和材料,采集方式以检验项目的为准
        v_材料id := Null;
        If r_Price.诊疗类别 = 'E' And r_Price.操作类型 = '6' Then
          Begin
            Select c.材料id
            Into v_材料id
            From 病人医嘱记录 A, 诊疗项目目录 B, 采血管类型 C
            Where a.诊疗项目id = b.Id And b.试管编码 = c.编码 And a.相关id = r_Price.Id And Rownum = 1;
          Exception
            When Others Then
              Null;
          End;
        Elsif r_Price.诊疗类别 = 'C' And r_Price.试管编码 Is Not Null Then
          Begin
            Select 材料id Into v_材料id From 采血管类型 Where 编码 = r_Price.试管编码;
          Exception
            When Others Then
              Null;
          End;
        End If;

        --判断处理检验试管费用的收取
        If (Nvl(r_Price.收费方式, 0) = 1 And r_Price.收费类别 = '4' And r_Price.收费项目id = Nvl(v_材料id, 0) Or
           Not (Nvl(r_Price.收费方式, 0) = 1 And r_Price.收费类别 = '4' And Nvl(v_材料id, 0) <> 0)) Then
          Insert Into 病人医嘱计价
            (医嘱id, 收费细目id, 数量, 单价, 从项, 执行科室id, 费用性质, 收费方式)
          Values
            (r_Price.Id, r_Price.收费项目id, r_Price.收费数量, r_Price.单价, r_Price.从属项目, Null, r_Price.费用性质, r_Price.收费方式);
        End If;
      End Loop;
    End If;

    --自由录入的临嘱医嘱标记为停止
    If Nvl(v_期效, 0) = 1 And v_诊疗项目id Is Null Then
      Update 病人医嘱记录
      Set 医嘱状态 = 8, 停嘱时间 = 校对时间_In, 停嘱医生 = v_开嘱医生
      Where ID = 医嘱id_In Or 相关id = 医嘱id_In;

      Insert Into 病人医嘱状态
        (医嘱id, 操作类型, 操作人员, 操作时间)
        Select ID, 8, v_人员姓名, Sysdate From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
    End If;
    
    v_Par停嘱 := zl_GetSysParameter(271);
    
    --将同一自动停止互斥组中的病人其它医嘱停止(如果尚未停止)
    For r_Exclude In c_Exclude Loop
      Select Decode(Sign(r_Exclude.开始执行时间 - v_开始时间), 1, r_Exclude.开始执行时间, v_开始时间)
      Into v_终止时间
      From Dual;
      Select Decode(Sign(r_Exclude.执行终止时间 - v_开始时间), -1, r_Exclude.执行终止时间, v_开始时间)
      Into v_终止时间
      From Dual;
      If v_Par停嘱 = '1' Then
        v_Temp := '自动停止：医嘱互斥。';
      Else
        v_Temp := Null;
      End If;
      Zl_病人医嘱记录_停止(r_Exclude.医嘱id, v_终止时间, v_开嘱医生, 1, 0, 0, Null, Null, v_Temp);
      v_Stopadviceids := v_Stopadviceids || ',' || r_Exclude.医嘱id;
    End Loop;

    --对一些特殊医嘱的处理
    If v_诊疗类别 = 'H' And v_操作类型 = '1' And Nvl(v_期效, 0) = 0 Then
      --校对护理等级时,同步更改病人护理等级
      If Nvl(v_婴儿, 0) = 0 Then
        --病人当前应处于正常住院状态
        v_Temp := Null;
        Begin
          Select Decode(状态, 1, '等待入科', 2, '正在转科', 3, '已预出院', Null)
          Into v_Temp
          From 病案主页
          Where 病人id = v_病人id And 主页id = v_主页id;
        Exception
          When Others Then
            Null;
        End;
        If v_Temp Is Not Null Then
          v_Error := '病人当前处于' || v_Temp || '状态,医嘱"' || v_医嘱内容 || '"不能通过校对。';
          Raise Err_Custom;
        End If;

        Begin
          --根据收费对照处理，当前医嘱计价表还没有填写
          --未设置时,不处理；相同时,不处理；有多个时,只取一个。
          Select a.收费项目id
          Into v_护理等级id
          From 诊疗收费关系 A, 收费项目目录 B
          Where a.收费项目id = b.Id And b.类别 = 'H' And Nvl(b.项目特性, 0) <> 0 And a.诊疗项目id = v_诊疗项目id And Rownum = 1 And
                Not Exists
           (Select 1 From 病案主页 Where 病人id = v_病人id And 主页id = v_主页id And 护理等级id = a.收费项目id);
        Exception
          When Others Then
            Null;
        End;
      End If;

      --变动记录的时间加上秒，以便回退操作时区分同一分种的校对、停止等操作
      v_开始时间 := To_Date(To_Char(v_开始时间, 'yyyy-mm-dd hh24:mi') || To_Char(Sysdate, 'ss'), 'yyyy-mm-dd hh24:mi:ss');
      If v_护理等级id Is Not Null Then
        Zl_病人变动记录_Nurse(v_病人id, v_主页id, v_护理等级id, v_开始时间, v_人员编号, v_人员姓名);
      End If;

      --并停止其它护理等级医嘱(护理等级应该都为"持续性"长嘱,且只有一个未停)
      For r_Nurse In c_Nurse Loop
        Select Decode(Sign(r_Nurse.开始执行时间 - v_开始时间), 1, r_Nurse.开始执行时间, v_开始时间)
        Into v_终止时间
        From Dual;
        Select Decode(Sign(r_Nurse.执行终止时间 - v_开始时间), -1, r_Nurse.执行终止时间, v_开始时间)
        Into v_终止时间
        From Dual;
        If v_Par停嘱 = '1' Then
          v_Temp := '自动停止：护理等级。';
        Else
          v_Temp := Null;
        End If;
        Zl_病人医嘱记录_停止(r_Nurse.医嘱id, v_终止时间, v_开嘱医生, 1, 0, 0, Null, Null, v_Temp);
		Zl_病人医嘱记录_确认停止(r_Nurse.医嘱id, v_终止时间, v_人员姓名,1);
        v_Stopadviceids := v_Stopadviceids || ',' || r_Nurse.医嘱id;
      End Loop;
    Elsif v_诊疗类别 = 'Z' And v_操作类型 In ('9', '10') And Nvl(v_期效, 0) = 0 And Nvl(v_婴儿, 0) = 0 Then
      --病重病危医嘱：9-病重;10-病危
      --停止相同医嘱
      For r_Patistate In c_Patistate Loop
        Select Decode(Sign(r_Patistate.开始执行时间 - v_开始时间), 1, r_Patistate.开始执行时间, v_开始时间)
        Into v_终止时间
        From Dual;
        Select Decode(Sign(r_Patistate.执行终止时间 - v_开始时间), -1, r_Patistate.执行终止时间, v_开始时间)
        Into v_终止时间
        From Dual;
        If v_Par停嘱 = '1' Then
          If v_操作类型 = '9' Then
            v_Temp := '自动停止：病重医嘱。';
          Else
            v_Temp := '自动停止：病危医嘱。';
          End If;
        Else
          v_Temp := Null;
        End If;      
        Zl_病人医嘱记录_停止(r_Patistate.医嘱id, v_终止时间, v_开嘱医生, 1, 0, 0, Null, Null, v_Temp);
        v_Stopadviceids := v_Stopadviceids || ',' || r_Patistate.医嘱id;
      End Loop;

      --产生病情变动
      Open c_Oldinfo; --必须在处理之前先打开
      Fetch c_Oldinfo
        Into r_Oldinfo;
      Open c_Endinfo;
      Fetch c_Endinfo
        Into r_Endinfo;
      If c_Endinfo%RowCount = 0 Then
        Close c_Endinfo;
        v_Error := '未发现该病人当前有效的变动记录！';
        Raise Err_Custom;
      End If;
      Select Count(*)
      Into v_Count
      From 病人变动记录
      Where 病人id = v_病人id And 主页id = v_主页id And 开始时间 Is Null And 终止时间 Is Null;
      If v_Count > 0 Then
        v_Error := '病人当前处于转科状态，请先办理转科确认或者取消转科状态。';
        Raise Err_Custom;
      End If;

      Update 病案主页
      Set 当前病况 = Decode(v_操作类型, '9', '重', '10', '危')
      Where 病人id = v_病人id And 主页id = v_主页id;

      --取消上次变动
      If r_Oldinfo.终止时间 Is Not Null Then
        v_变动终止时间 := r_Oldinfo.终止时间;
        v_变动终止原因 := r_Oldinfo.终止原因;
        v_变动终止人员 := r_Oldinfo.终止人员;
        --取消上次变动
        Update 病人变动记录
        Set 终止时间 = v_开始时间, 终止原因 = 13, 终止人员 = v_人员姓名, 上次计算时间 = Null
        Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 = v_变动终止时间 And 终止原因 = v_变动终止原因;
        --更新将来的记录如果有停止到将来的则删除上次计算时间
        Update 病人变动记录
        Set 病情 = Decode(v_操作类型, '9', '重', '10', '危'), 上次计算时间 = Null
        Where 病人id = v_病人id And 主页id = v_主页id And 开始时间 > v_开始时间;
      Else
        Update 病人变动记录
        Set 终止时间 = v_开始时间, 终止原因 = 13, 终止人员 = v_人员姓名,
            上次计算时间 = Decode(Sign(Nvl(上次计算时间, v_开始时间) - v_开始时间), 1, Null, 上次计算时间)
        Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 Is Null;
      End If;

      While c_Oldinfo%Found Loop
        Insert Into 病人变动记录
          (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号, 操作员姓名,
           终止时间, 终止原因, 终止人员)
        Values
          (病人变动记录_Id.Nextval, v_病人id, v_主页id, v_开始时间, 13, r_Oldinfo.附加床位, r_Oldinfo.病区id, r_Oldinfo.科室id,
           r_Oldinfo.护理等级id, r_Oldinfo.床位等级id, r_Oldinfo.床号, r_Oldinfo.责任护士, r_Oldinfo.经治医师, r_Oldinfo.主治医师,
           r_Oldinfo.主任医师, Decode(v_操作类型, '9', '重', '10', '危'), v_人员编号, v_人员姓名, v_变动终止时间, v_变动终止原因, v_变动终止人员);

        Fetch c_Oldinfo
          Into r_Oldinfo;
      End Loop;

      Close c_Oldinfo;
      Close c_Endinfo;
    Elsif v_诊疗类别 = 'Z' And v_操作类型 = '12' And Nvl(v_期效, 0) = 0 And Nvl(v_婴儿, 0) = 0 Then
      --记录入出量的医嘱，互斥
      For r_Patiio In c_Patiio Loop
        Select Decode(Sign(r_Patiio.开始执行时间 - v_开始时间), 1, r_Patiio.开始执行时间, v_开始时间)
        Into v_终止时间
        From Dual;
        Select Decode(Sign(r_Patiio.执行终止时间 - v_开始时间), -1, r_Patiio.执行终止时间, v_开始时间)
        Into v_终止时间
        From Dual;
        Zl_病人医嘱记录_停止(r_Patiio.医嘱id, v_终止时间, v_开嘱医生, 1);
        v_Stopadviceids := v_Stopadviceids || ',' || r_Patiio.医嘱id;
      End Loop;
    Elsif (v_诊疗类别 = 'Z' And v_操作类型 In ('3', '4', '5', '6', '11', '14') And
          (v_操作类型 <> '14' Or v_操作类型 = '14' And v_执行标记 = 1)) Or (v_诊疗类别 = 'F' And v_执行标记 = 1) Then
      v_Count := 0;
      If v_操作类型 = '4' Or v_操作类型 = '14' Or v_诊疗类别 = 'F' Then
        --保持与以前校对时相同的处理
        If Nvl(v_婴儿, 0) = 0 Then
          v_Count := 1;
        End If;
      Else
        --这几个特殊医嘱在校对中停止医嘱是新加的内容，保持与发送中相同的处理
        v_Count := 1;
        If Nvl(v_婴儿, 0) = 0 Then
          v_婴儿 := -1;
        Else
          v_婴儿 := Nvl(v_婴儿, 0);
        End If;
      End If;
      If v_Count = 1 Then
        If v_诊疗类别 = 'F' And v_执行标记 = 1 Then
          --在手术当天(取整)停止
          v_开始时间 := Trunc(To_Date(v_标本部位, 'yyyy-mm-dd hh24:mi:ss'));
        End If;

        --几个特殊医嘱校对时停止前面的长嘱,在医嘱开始时终止：3-转科;4-术后;5-出院;6-转院,11-死亡,14-术前
        For r_Needstop In c_Needstop(v_病人id, v_主页id, v_婴儿, v_开始时间) Loop
          Select Decode(Sign(开始执行时间 - v_开始时间), 1, 开始执行时间, v_开始时间)
          Into v_停止时间
          From 病人医嘱记录
          Where ID = r_Needstop.Id;
          Update 病人医嘱记录
          Set 医嘱状态 = 8, 执行终止时间 = v_停止时间, 停嘱时间 = 校对时间_In, 停嘱医生 = v_开嘱医生
          Where ID = r_Needstop.Id;

          Insert Into 病人医嘱状态
            (医嘱id, 操作类型, 操作人员, 操作时间)
            Select ID, 8, v_人员姓名, 校对时间_In From 病人医嘱记录 Where ID = r_Needstop.Id;
          v_Stopadviceids := v_Stopadviceids || ',' || r_Needstop.Id;
        End Loop;
        --已停止未确认的长嘱,终止时间在医嘱开始后的,调前其终止时间(同时多个特殊医嘱的情况)
        For r_Havestop In c_Havestop(v_病人id, v_主页id, v_婴儿, v_开始时间) Loop
          Update 病人医嘱记录
          Set 执行终止时间 = Decode(Sign(开始执行时间 - v_开始时间), 1, 开始执行时间, v_开始时间), 停嘱时间 = 校对时间_In, 停嘱医生 = v_开嘱医生
          Where ID = r_Havestop.Id;

          --不修改停止医嘱的操作人员，因为停止时，医生可能已进行电子签名
          Update 病人医嘱状态 Set 操作时间 = 校对时间_In Where 医嘱id = r_Havestop.Id And 操作类型 = 8;
          v_Stopadviceids := v_Stopadviceids || ',' || r_Havestop.Id;
        End Loop;
        --处理长期备用医嘱(没有执行（发送）过的标记未用）
        Update 病人医嘱记录
        Set 执行标记 = -1
        Where 病人id = v_病人id And 主页id = v_主页id And 医嘱期效 = 0 And 执行频次 = '必要时' And 上次执行时间 Is Null And 医嘱状态 In (3, 5, 6, 7) And
              执行标记 <> -1;
        --如果是转院转科死亡出院医嘱同时处理临时备用医嘱。
        If v_操作类型 In ('3', '5', '6', '11') Then
          Update 病人医嘱记录
          Set 执行标记 = -1
          Where 病人id = v_病人id And 主页id = v_主页id And 医嘱期效 = 1 And 执行频次 = '需要时' And 医嘱状态 = 3 And 执行标记 <> -1;
        End If;
      End If;
    Elsif v_诊疗类别 = 'Z' And v_操作类型 = '2' Then
      --对留观病人下达入院通知;
      --预约登记的条件：1.当前无预约,2.当前是门诊留观病人（在院时也允许，因为需要先预约,入院接收时检查了必须出院后才能接收）
      Select Count(*) Into v_Count From 病案主页 Where 病人id = v_病人id And Nvl(主页id, 0) = 0;
      If v_Count = 0 Then
        Select Count(*) Into v_Count From 病案主页 Where 病人id = v_病人id And 主页id = v_主页id And 病人性质 <> 1;
      End If;
      If v_Count = 0 Then
        Open c_Pati(v_病人id);
        Fetch c_Pati
          Into r_Pati;
        Close c_Pati;

        v_入院方式 := Null;
        If v_紧急标志 = 1 Then
          v_入院方式 := '急诊';
        End If;

        Zl_入院病案主页_Insert(1, 0, r_Pati.病人id, r_Pati.住院号, Null, r_Pati.姓名, r_Pati.性别, r_Pati.年龄, r_Pati.费别, r_Pati.出生日期,
                         r_Pati.国籍, r_Pati.民族, r_Pati.学历, r_Pati.婚姻状况, r_Pati.职业, r_Pati.身份, r_Pati.身份证号, r_Pati.出生地点,
                         r_Pati.家庭地址, r_Pati.家庭地址邮编, r_Pati.家庭电话, r_Pati.户口地址, r_Pati.户口地址邮编, r_Pati.联系人姓名, r_Pati.联系人关系,
                         r_Pati.联系人地址, r_Pati.联系人电话, r_Pati.工作单位, r_Pati.合同单位id, r_Pati.单位电话, r_Pati.单位邮编, r_Pati.单位开户行,
                         r_Pati.单位帐号, r_Pati.担保人, r_Pati.担保额, r_Pati.担保性质, v_执行科室id, Null, Null, v_入院方式, Null, Null,
                         v_开嘱医生, r_Pati.籍贯, r_Pati.区域, v_开始时间, Null, Null, r_Pati.医疗付款方式, Null, Null, Null, Null, Null,
                         Null, r_Pati.险类, v_人员编号, v_人员姓名, 0, Null, Null, 0);
      End If;
    End If;
    --医嘱停止消息的处理
    If v_Stopadviceids Is Not Null Then
      v_Stopadviceids := Substr(v_Stopadviceids, 2);
      Select Max(a.Id)
      Into n_标记
      From 病人医嘱记录 A
      Where a.Id In (Select Column_Value From Table(f_Num2list(v_Stopadviceids))) And a.医嘱期效 = 0 And a.医嘱状态 = 8 And
            Nvl(a.执行标记, 0) <> -1 And a.病人来源 <> 3;
      If n_标记 Is Not Null Then
        Select Max(a.Id)
        Into n_Adviceid
        From 病人医嘱记录 A
        Where a.Id In (Select Column_Value From Table(f_Num2list(v_Stopadviceids))) And a.紧急标志 = 1 And a.医嘱期效 = 0 And
              a.医嘱状态 = 8 And Nvl(a.执行标记, 0) <> -1 And a.病人来源 <> 3;
        If n_Adviceid Is Not Null Then
          n_Adviceid := n_标记;
          Select Nvl(Max(0), 2)
          Into n_标记
          From 业务消息清单 A
          Where a.病人id = v_病人id And a.就诊id = v_主页id And a.类型编码 = 'ZLHIS_CIS_002' And a.优先程度 = 2 And a.是否已阅 = 0;
        Else
          Select Nvl(Max(0), 1)
          Into n_标记
          From 业务消息清单 A
          Where a.病人id = v_病人id And a.就诊id = v_主页id And a.类型编码 = 'ZLHIS_CIS_002' And a.是否已阅 = 0;
        End If;
        If n_标记 > 0 Then
          For R In (Select a.病人性质 As 性质, a.出院科室id As 科室id, a.当前病区id As 病区id
                    From 病案主页 A
                    Where a.病人id = v_病人id And a.主页id = v_主页id) Loop
            Zl_业务消息清单_Insert(v_病人id, v_主页id, r.科室id, r.病区id, r.性质, '有新停止医嘱。', '0010', 'ZLHIS_CIS_002', n_Adviceid, n_标记,
                             0, Null, r.病区id);
          End Loop;
        End If;
      End If;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱记录_校对;
/

--111026:李业庆,2017-07-06,无库存冲销调价修正问题
--110853:李业庆,2017-07-03,发药无库存时库存成本价为空处理
--92837:李业庆,2017-06-07,出库单据库房信息中入库时间处理
--109818:李业庆,2017-06-08,调价时同步调整药品批号对照
Create Or Replace Procedure Zl_药品库存_Update
(
  Id_In       In 药品收发记录.Id%Type,
  业务类型_In In Number := 0,
  入出类型_In In Number := 0,
  操作类型_In In Number := 0
) Is
  --功能：
  --      根据业务类型处理库存表，处理业务药品所有业务和卫材发料业务，卫材内部流通业务不处理
  --id_in  需要处理收发记录单
  --业务类型_in  业务类型，0-新增、1-删除、2-审核、3-冲销
  --入出类型_in  0-入库，1-出库
  --操作类型：根据业务情况确定
  ----外购入库中，表示财务审核：  0-不是财务审核，1-财务审核，目前只有外购入库有财务审核
  ----申领，移库中冲销流程：0-正常冲销流程，1-申请，审核冲销流程

  n_可用数量 药品库存.实际数量%Type;
  n_实际数量 药品库存.实际数量%Type;
  n_零售金额 药品库存.实际金额%Type;
  n_差价     药品库存.实际差价%Type;
  n_时价     Number(1);
  n_成本价   药品收发记录.成本价%Type;
  n_零售价   药品库存.零售价%Type;

  n_库存数量   药品库存.实际数量%Type;
  n_库存平均价 药品库存.平均成本价%Type;
  n_库存售价   药品库存.零售价%Type;
  n_总数量     药品收发记录.实际数量%Type;
  n_总成本价   药品收发记录.成本价%Type;
  n_总售价     药品收发记录.零售价%Type;
  n_库房分批   药品规格.药库分批%Type;
  n_申请冲销   Number(1);
  n_更新库存   Number(1) := 0;
  v_现价       药品收发记录.零售价%Type;
  v_执行新价格 Number(1) := 0;
  n_有库存     Number(1) := 0;
  v_审核日期   药品收发记录.审核日期%Type;
  --业务明细数据，把库存数据更新需要的数据都列出来
  Cursor c_Detail Is
    Select a.Id, a.记录状态, a.单据, a.No, a.序号, a.库房id, a.供药单位id, a.入出类别id, a.对方部门id, a.入出系数, Nvl(a.发药方式, 0) As 发药方式, a.药品id,
           Nvl(a.批次, 0) 批次, a.产地, a.批号, a.生产日期, a.效期, a.付数, Nvl(a.填写数量, 0) As 填写数量, a.实际数量, a.成本价, a.成本金额, a.扣率, a.零售价,
           Nvl(a.零售金额, 0) As 零售金额, Nvl(a.差价, 0) As 差价, a.配药人, a.配药日期, a.审核人, a.审核日期, a.灭菌日期, a.灭菌效期, a.批准文号, a.商品条码,
           a.内部条码, b.是否变价, a.单量, a.频次, a.摘要, Nvl(a.费用id, 0) As 费用id
    From 药品收发记录 A, 收费项目目录 B
    Where a.药品id = b.Id And a.Id = Id_In;

  r_Detail c_Detail%RowType;
Begin
  For r_Detail In c_Detail Loop
    n_实际数量 := r_Detail.入出系数 * r_Detail.实际数量 * Nvl(r_Detail.付数, 1);
    If n_实际数量 Is Null Then
      n_实际数量 := 0;
    End If;
    n_可用数量 := 0;
    n_零售价   := r_Detail.零售价;
    If r_Detail.单据 = 12 Then
      n_成本价 := r_Detail.单量;
    Else
      n_成本价 := r_Detail.成本价;
    End If;
    n_零售金额 := r_Detail.入出系数 * r_Detail.零售金额;
    n_差价     := r_Detail.入出系数 * r_Detail.差价;
  
    --先取库存和单据的数量和成本价
    Begin
      Select Nvl(实际数量, 0), Nvl(平均成本价, 0), Decode(Nvl(零售价, 0), 0, Decode(Nvl(实际数量, 0), 0, n_零售价, 实际金额 / 实际数量), 零售价)
      Into n_库存数量, n_库存平均价, n_库存售价
      From 药品库存
      Where 性质 = 1 And 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次;
    Exception
      When Others Then
        n_库存数量   := 0;
        n_库存平均价 := 0;
        n_库存售价   := 0;
    End;
  
    --时价药品都需要更新库存表零售价字段
    If r_Detail.是否变价 = 1 Then
      n_时价 := 1;
    Else
      n_时价 := 0;
    End If;
  
    --特殊业务处理库存
    --包含业务--5-差价调整；13-调价变动
    --单据5，13都是业务类型_in，2-审核、入出类型_in  0-入库
    If r_Detail.单据 = 5 Or r_Detail.单据 = 13 Then
      --这种类型的单据收发记录成本价字段不是保存的真正成本价而是存储的其他数据
      If r_Detail.单据 = 5 Then
        If r_Detail.填写数量 <> 0 Then
          n_零售价 := Nvl(r_Detail.零售价, 0) / r_Detail.填写数量;
        Else
          n_零售价 := 0;
        End If;
        --审核
        If r_Detail.记录状态 = 1 Then
          --差价调整发药方式=0；主动调价、退货、发药产生的调价修正发药方式=1
          n_成本价 := r_Detail.单量;
        Else
          --冲销 还原原始成本价
          Begin
            --成本价=(金额-差价)/数量
            n_成本价 := (Nvl(r_Detail.零售价, 0) - Nvl(r_Detail.成本价, 0)) / r_Detail.填写数量;
          Exception
            When Others Then
              Select 成本价 Into n_成本价 From 药品规格 Where 药品id = r_Detail.药品id;
          End;
        End If;
      Else
        n_成本价 := Nvl(r_Detail.单量, 0) - Nvl(r_Detail.频次, 0);
      End If;
    
      If r_Detail.单据 = 5 Then
        --单据=5 的成本价修正记录 平均成本价不需要重算，因为保存了最新价格的
        If r_Detail.摘要 = '外购退库差价误差自动修正' Or r_Detail.摘要 = '财务审核价格变动修正' Then
          --这一步肯定是外购退库，外购退库只更新成本价,且肯定有库存
          Update 药品库存
          Set 实际差价 = Nvl(实际差价, 0) + n_差价
          Where 性质 = 1 And 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次;
        Else
          Update 药品库存
          Set 平均成本价 = n_成本价, 上次采购价 = n_成本价, 实际金额 = Nvl(实际金额, 0) + n_零售金额, 实际差价 = Nvl(实际差价, 0) + n_差价
          Where 性质 = 1 And 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次;
          If Sql%NotFound Then
            Insert Into 药品库存
              (库房id, 药品id, 批次, 性质, 实际差价, 上次批号, 效期, 上次产地, 上次供应商id, 上次生产日期, 批准文号, 实际金额, 上次采购价, 平均成本价)
            Values
              (r_Detail.库房id, r_Detail.药品id, r_Detail.批次, 1, n_差价, r_Detail.批号, r_Detail.效期, r_Detail.产地,
               r_Detail.供药单位id, r_Detail.生产日期, r_Detail.批准文号, n_零售金额, n_成本价, n_成本价);
          
            Insert Into 药品入库信息
              (药品id, 库房id, 批次, 入库日期)
              Select r_Detail.药品id, r_Detail.库房id, r_Detail.批次, r_Detail.审核日期
              From Dual
              Where Not Exists (Select 1
                     From 药品入库信息
                     Where 药品id = r_Detail.药品id And 库房id = r_Detail.库房id And 批次 = r_Detail.批次);
          End If;
          
          --调整药品批号对照表中的价格
          If r_Detail.摘要 ='成本价调价' Then
            Update 药品批号对照 Set 成本价=n_成本价 Where 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次;
          End If;
        End If;
      Elsif r_Detail.单据 = 13 Then
        --单据=13 的售价修正记录 同步更新的金额和差价，所以不需要重算平均成本价
        If r_Detail.费用id = 0 Then
          Update 药品库存
          Set 零售价 = Decode(n_时价, 1, n_零售价, Null), 实际金额 = Nvl(实际金额, 0) + n_零售金额, 实际差价 = Nvl(实际差价, 0) + n_差价
          Where 性质 = 1 And 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次;
        Else
          Update 药品库存
          Set 实际金额 = Nvl(实际金额, 0) + n_零售金额, 实际差价 = Nvl(实际差价, 0) + n_差价
          Where 性质 = 1 And 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次;
        End If;
      
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 零售价)
          Values
            (r_Detail.库房id, r_Detail.药品id, r_Detail.批次, 1, 0, 0, n_零售金额, n_零售金额, Decode(n_时价, 1, n_零售价, Null));
        
          Insert Into 药品入库信息
            (药品id, 库房id, 批次, 入库日期)
            Select r_Detail.药品id, r_Detail.库房id, r_Detail.批次, r_Detail.审核日期
            From Dual
            Where Not Exists (Select 1
                   From 药品入库信息
                   Where 药品id = r_Detail.药品id And 库房id = r_Detail.库房id And 批次 = r_Detail.批次);
        End If;
        
        --调整药品批号对照表中的价格
        If r_Detail.摘要 ='药品调价' Then
          Update 药品批号对照 Set 售价=n_零售价 Where 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次;
        End If;
      End If;
    Else
      --一般业务处理库存
      --包含业务--1-外购入库；2-自制入库；3-协药入库；4-其他入库；6-库房移出；
      --7-部门领用；8-收费处方发药；9-记帐单处方发药；10-记帐表处方发药；11-其他出库；
      --12-盘点；14-药品盘点记录单
      --21-材料其他出库；24-收费处方发料；25-记帐单处方发料；26-记帐表处方发料
      If 业务类型_In = 0 Or 业务类型_In = 1 Then
        --新增，删除
        If r_Detail.单据 = 8 Or r_Detail.单据 = 9 Or r_Detail.单据 = 10 Or r_Detail.单据 = 21 Or r_Detail.单据 = 24 Or
           r_Detail.单据 = 25 Or r_Detail.单据 = 26 Or r_Detail.单据 = 7 Or r_Detail.单据 = 11 Or
           ((r_Detail.单据 = 2 Or r_Detail.单据 = 3 Or r_Detail.单据 = 12) And r_Detail.入出系数 = -1) Or
           (r_Detail.单据 = 1 And r_Detail.发药方式 = 1) Or (r_Detail.单据 = 6 And r_Detail.入出系数 = -1 And r_Detail.记录状态 = 1) Or
           (r_Detail.单据 = 6 And Mod(r_Detail.记录状态, 3) = 2 And r_Detail.入出系数 = 1) Then
          --需要在新增/删除单据时减少/增加可用数量的单据类型
          ----1.发药/发料单据(收费处方，记账单，记账表)
          ----2.普通出库（领用、其他出库、移库中出的那笔(r_Detail.单据 = 6 And r_Detail.入出系数 = -1 And r_Detail.记录状态 = 1)、盘点单中盘亏那笔）
          ----3.退库单（r_Detail.单据 = 1 And r_Detail.发药方式 = 1）
          ----4.移库申请冲销单（原入库那笔的冲销记录，r_Detail.单据 = 6 And Mod(r_Detail.记录状态, 3) = 2 And r_Detail.入出系数 = 1）
        
          --新增，删除单据时，因为没有审核所以只处理数量不处理金额和差价
        
          If 业务类型_In = 0 Then
            --新增时正常处理可用数量
            n_可用数量 := n_实际数量;
          Else
            --删除时按相反数计算可用数量
            n_可用数量 := -1 * n_实际数量;
          End If;
        
          n_实际数量 := 0;
          n_零售金额 := 0;
          n_差价     := 0;
        
          --处理库存
          Update 药品库存
          Set 可用数量 = 可用数量 + n_可用数量
          Where 药品id = r_Detail.药品id And 库房id = r_Detail.库房id And Nvl(批次, 0) = r_Detail.批次 And 性质 = 1;
        
          n_更新库存 := 1;
        End If;
      Elsif 业务类型_In = 2 Then
        --审核
        --10.35开始，理论上所有的出库类单据在审核时都不再处理可用数量
        If r_Detail.单据 = 8 Or r_Detail.单据 = 9 Or r_Detail.单据 = 10 Or r_Detail.单据 = 21 Or r_Detail.单据 = 24 Or
           r_Detail.单据 = 25 Or r_Detail.单据 = 26 Or r_Detail.单据 = 7 Or r_Detail.单据 = 11 Or
           ((r_Detail.单据 = 2 Or r_Detail.单据 = 3 Or r_Detail.单据 = 12) And r_Detail.入出系数 = -1) Or
           (r_Detail.单据 = 1 And r_Detail.发药方式 = 1) Or (r_Detail.单据 = 6 And r_Detail.入出系数 = -1 And r_Detail.记录状态 = 1) Or
           (r_Detail.单据 = 6 And Mod(r_Detail.记录状态, 3) = 2 And r_Detail.入出系数 = 1) Then
          n_可用数量 := 0;
        Else
          n_可用数量 := n_实际数量;
        End If;
      
        --处理库存
        If 入出类型_In = 0 Then
          --入库审核
          Update 药品库存
          Set 可用数量 = Nvl(可用数量, 0) + n_可用数量, 实际数量 = Nvl(实际数量, 0) + n_实际数量, 实际金额 = Nvl(实际金额, 0) + n_零售金额,
              实际差价 = Nvl(实际差价, 0) + n_差价, 上次供应商id = r_Detail.供药单位id,
              上次采购价 = Decode(r_Detail.单据, 1, Decode(r_Detail.发药方式, 1, 上次采购价, n_成本价), n_成本价),
              上次批号 = Nvl(r_Detail.批号, 上次批号), 上次生产日期 = Nvl(r_Detail.生产日期, 上次生产日期), 上次产地 = Nvl(r_Detail.产地, 上次产地),
              灭菌效期 = Nvl(r_Detail.灭菌效期, 灭菌效期), 效期 = Nvl(r_Detail.效期, 效期), 批准文号 = Nvl(r_Detail.批准文号, 批准文号),
              上次扣率 = Decode(r_Detail.单据, 12, 上次扣率, r_Detail.扣率), 商品条码 = Nvl(r_Detail.商品条码, 商品条码),
              内部条码 = Nvl(r_Detail.内部条码, 内部条码)
          Where 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次 And 性质 = 1;
        Else
          --出库审核，只需要下数量和金额
          Update 药品库存
          Set 可用数量 = Nvl(可用数量, 0) + n_可用数量, 实际数量 = Nvl(实际数量, 0) + n_实际数量, 实际金额 = Nvl(实际金额, 0) + n_零售金额,
              实际差价 = Nvl(实际差价, 0) + n_差价, 平均成本价 = Decode(平均成本价, Null, n_成本价, 平均成本价),
              上次采购价 = Decode(上次采购价, Null, n_成本价, 上次采购价)
          Where 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次 And 性质 = 1;
        End If;
      
        n_更新库存 := 1;
      Elsif 业务类型_In = 3 Then
        --冲销
        If r_Detail.单据 = 8 Or r_Detail.单据 = 9 Or r_Detail.单据 = 10 Or r_Detail.单据 = 21 Or r_Detail.单据 = 24 Or
           r_Detail.单据 = 25 Or r_Detail.单据 = 26 Then
          --发药/发料单退药/退料时同时又产生了未发单据，所以就不处理可用数量
          n_可用数量 := 0;
        Elsif r_Detail.单据 = 6 And Mod(r_Detail.记录状态, 3) = 2 And r_Detail.入出系数 = 1 Then
          --药库单的冲销单据，要判断是否需要申请
          n_申请冲销 := 操作类型_In;
          If n_申请冲销 = 0 Then
            --不需要申请的在冲销时处理可用数量
            n_可用数量 := n_实际数量;
          Else
            --需要申请的，已经在申请时处理了可用数量
            n_可用数量 := 0;
          End If;
        Else
          n_可用数量 := n_实际数量;
        End If;
      
        Begin
          Select 1
          Into n_有库存
          From 药品库存
          Where 性质 = 1 And 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次;
        Exception
          When Others Then
            n_有库存 := 0;
        End;
      
        --冲销时如果原来无库存，由于需要重新插入数据，则需要取最新成本价格，因为后面可能还要触发调价修正
        If n_有库存 = 0 Then
          --取原始单据的审核时间
          Select a.审核日期
          Into v_审核日期
          From 药品收发记录 A, 药品收发记录 B
          Where b.Id = r_Detail.Id And a.单据 = b.单据 And a.No = b.No And a.库房id = b.库房id And a.药品id + 0 = b.药品id And
                a.序号 = b.序号 And (a.记录状态 = 1 Or Mod(a.记录状态, 3) = 0);
        
          --成本价取最新价格
          Begin
            Select 1, 新成本价
            Into v_执行新价格, v_现价
            From 成本价调价信息
            Where 库房id + 0 = r_Detail.库房id And 药品id + 0 = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次 And 执行日期 > v_审核日期 And
                  Rownum = 1
            Order By 执行日期 Desc;
          Exception
            When Others Then
              v_执行新价格 := 0;
            
              --可能是无库存调价，那么不需要库房id和批次判断，只需要用药品id
              Begin
                Select 1, 新成本价
                Into v_执行新价格, v_现价
                From 成本价调价信息
                Where 库房id Is Null And Nvl(批次, 0) = 0 And 药品id + 0 = r_Detail.药品id And 执行日期 > v_审核日期 And Rownum = 1
                Order By 执行日期 Desc;
              Exception
                When Others Then
                  v_执行新价格 := 0;
              End;
          End;
        
          If v_执行新价格 = 1 Then
            n_成本价 := v_现价;
          End If;
        End If;
      
        --处理库存
        If 入出类型_In = 0 Then
          --出库单据冲销需要将入库库房数据都更新
          Update 药品库存
          Set 可用数量 = Nvl(可用数量, 0) + n_可用数量, 实际数量 = Nvl(实际数量, 0) + n_实际数量, 实际金额 = Nvl(实际金额, 0) + n_零售金额,
              实际差价 = Nvl(实际差价, 0) + n_差价, 上次供应商id = r_Detail.供药单位id,
              上次采购价 = Decode(r_Detail.单据, 1, Decode(r_Detail.发药方式, 1, 上次采购价, n_成本价), 上次采购价),
              上次批号 = Nvl(r_Detail.批号, 上次批号), 上次生产日期 = Nvl(r_Detail.生产日期, 上次生产日期), 上次产地 = Nvl(r_Detail.产地, 上次产地),
              灭菌效期 = Nvl(r_Detail.灭菌效期, 灭菌效期), 效期 = Nvl(r_Detail.效期, 效期), 批准文号 = Nvl(r_Detail.批准文号, 批准文号),
              上次扣率 = Decode(r_Detail.单据, 12, 上次扣率, r_Detail.扣率), 商品条码 = Nvl(r_Detail.商品条码, 商品条码),
              内部条码 = Nvl(r_Detail.内部条码, 内部条码)
          Where 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次 And 性质 = 1;
        Else
          --入库单据冲销只需要下数量和金额
          Update 药品库存
          Set 可用数量 = Nvl(可用数量, 0) + n_可用数量, 实际数量 = Nvl(实际数量, 0) + n_实际数量, 实际金额 = Nvl(实际金额, 0) + n_零售金额,
              实际差价 = Nvl(实际差价, 0) + n_差价
          Where 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次 And 性质 = 1;
        End If;
      
        n_更新库存 := 1;
      End If;
    
      --新增/删除/审核/冲销业务时，库存表未找到数据则需要产生库存表所有信息
      If Sql%RowCount = 0 And n_更新库存 = 1 Then
        Insert Into 药品库存
          (库房id, 药品id, 批次, 效期, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 灭菌效期, 批准文号, 零售价, 上次扣率,
           商品条码, 内部条码, 平均成本价)
        Values
          (r_Detail.库房id, r_Detail.药品id, r_Detail.批次, r_Detail.效期, 1, n_可用数量, n_实际数量, n_零售金额, n_差价, r_Detail.供药单位id,
           n_成本价, r_Detail.批号, r_Detail.生产日期, r_Detail.产地, r_Detail.灭菌效期, r_Detail.批准文号, Decode(n_时价, 1, n_零售价, Null),
           r_Detail.扣率, r_Detail.商品条码, r_Detail.内部条码, n_成本价);
      
        Insert Into 药品入库信息
          (药品id, 库房id, 批次, 入库日期)
          Select r_Detail.药品id, r_Detail.库房id, r_Detail.批次, r_Detail.审核日期
          From Dual
          Where Not Exists (Select 1
                 From 药品入库信息
                 Where 药品id = r_Detail.药品id And 库房id = r_Detail.库房id And 批次 = r_Detail.批次);
      End If;
    
      --重算平均成本价，入库审核需要重算平均成本价和零售价，注意只限于不分批药品，分批药品不用重算（确保和之前库存的数据一致）
      If 入出类型_In = 0 And 业务类型_In = 2 And r_Detail.批次 = 0 Then
        --按总金额/总数量方式计算平均成本价而不用（金额-差价）/数量是为了数据的准确性
        n_总数量 := (n_库存数量 + n_实际数量);
        If n_总数量 <> 0 Then
          n_总成本价 := (n_库存数量 * n_库存平均价 + n_实际数量 * n_成本价) / n_总数量;
        
          If n_总成本价 < 0 Then
            n_总成本价 := n_成本价;
          End If;
        
          Update 药品库存
          Set 平均成本价 = n_总成本价
          Where 性质 = 1 And 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次;
        
          --更新时价零售价
          If n_时价 = 1 Then
            n_总售价 := (n_库存数量 * n_库存售价 + n_实际数量 * n_零售价) / n_总数量;
            Update 药品库存
            Set 零售价 = n_总售价
            Where 性质 = 1 And 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次 And
                  Nvl(实际数量, 0) <> 0;
            If Sql%NotFound Then
              Update 药品库存
              Set 零售价 = n_零售价
              Where 性质 = 1 And 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次;
            End If;
          End If;
        End If;
      End If;
    End If;
  
    --删除多余的库存数据，外购入库财务审核为了确保库存不变产生修正数据必须保证不删除库存
    If Not (r_Detail.单据 = 1 And 操作类型_In = 1) Then
      Delete From 药品库存
      Where 性质 = 1 And 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次 And Nvl(可用数量, 0) = 0 And
            Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0;
    End If;
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品库存_Update;
/

---------------------------------------------------------------------------------------------------
--更改系统及部件的版本号
-------------------------------------------------------------------------------------------------------
--100150:黄捷,2017-05-27,zl9pacsimagecap部件改成强制覆盖
--110716:刘飞,2017-07-04,增加zlPublicDrug.dll
--111205:刘硕,2017-07-06,部件清单重新整理
--删除的数据
Delete Zltools.Zlfilesupgrade A
Where Upper(a.文件名) In
      ('7CACKY16.DLL', '7CACKY95.DLL', '7CADSBNT.DLL', 'ADODB.DLL', 'ANIGIF.OCX', 'AVI.BMP', 'AVIDOWNLOAD.BMP',
       'AXINTEROP.DICOMOBJECTS.DLL', 'AXINTEROP.ZLPACSRICHPAGESCALE.DLL', 'BEIJING_TAX.DLL', 'C1REGSVR.EXE', 'CKY32.DLL',
       'CKY95H.DLL', 'CM.DLL', 'CMCT3CHS.DLL', 'CMCTLCHS.DLL', 'CMDLGCHS.DLL', 'CODEJOCK.CALENDAR.V16.3.1.LIC',
       'CODEJOCK.COMMANDBARS.9600.LIC', 'CODEJOCK.COMMANDBARS.9600.OCX', 'CODEJOCK.COMMANDBARS.UNICODE.9600.OCX',
       'CODEJOCK.DOCKINGPANE.9600.LIC', 'CODEJOCK.DOCKINGPANE.9600.OCX', 'CODEJOCK.DOCKINGPANE.UNICODE.9600.OCX',
       'CODEJOCK.PROPERTYGRID.9600.LIC', 'CODEJOCK.PROPERTYGRID.9600.OCX', 'CODEJOCK.PROPERTYGRID.UNICODE.9600.OCX',
       'CODEJOCK.REPORTCONTROL.9600.LIC', 'CODEJOCK.REPORTCONTROL.9600.OCX', 'CODEJOCK.REPORTCONTROL.UNICODE.9600.OCX',
       'CODEJOCK.SUITECTRLS.9600.LIC', 'CODEJOCK.SUITECTRLS.9600.OCX', 'CODEJOCK.SUITECTRLS.UNICODE.9600.OCX',
       'CODEJOCK.SYNTAXEDIT.V15.3.1.LIC', 'COMCT332.OCX', 'COMCTL32.OCX', 'COMDLG32.DLL', 'CRCDES.DLL', 'CRWICC.DLL',
       'CTS2R.DLL', 'CTSVR.EXE', 'DATGDCHS.DLL', 'DEVEXPRESS.DATA.V12.2.DLL', 'DEVEXPRESS.DATA.V12.2.RESOURCES.DLL',
       'DEVEXPRESS.OFFICE.V12.2.CORE.DLL', 'DEVEXPRESS.OFFICE.V12.2.CORE.RESOURCES.DLL',
       'DEVEXPRESS.PIVOTGRID.V12.2.CORE.RESOURCES.DLL', 'DEVEXPRESS.PRINTING.V12.2.CORE.DLL',
       'DEVEXPRESS.PRINTING.V12.2.CORE.RESOURCES.DLL', 'DEVEXPRESS.RICHEDIT.V12.2.CORE.DLL',
       'DEVEXPRESS.RICHEDIT.V12.2.CORE.RESOURCES.DLL', 'DEVEXPRESS.UTILS.V12.2.DLL',
       'DEVEXPRESS.UTILS.V12.2.RESOURCES.DLL', 'DEVEXPRESS.UTILS.V12.2.UI.RESOURCES.DLL',
       'DEVEXPRESS.XPF.CORE.V12.2.RESOURCES.DLL', 'DEVEXPRESS.XPF.GRID.V12.2.CORE.RESOURCES.DLL',
       'DEVEXPRESS.XPF.LAYOUTCONTROL.V12.2.RESOURCES.DLL', 'DEVEXPRESS.XPF.NAVBAR.V12.2.RESOURCES.DLL',
       'DEVEXPRESS.XPF.PRINTING.V12.2.RESOURCES.DLL', 'DEVEXPRESS.XPO.V12.2.RESOURCES.DLL',
       'DEVEXPRESS.XTRABARS.V12.2.DLL', 'DEVEXPRESS.XTRABARS.V12.2.RESOURCES.DLL',
       'DEVEXPRESS.XTRACHARTS.V12.2.RESOURCES.DLL', 'DEVEXPRESS.XTRACHARTS.V12.2.WIZARD.RESOURCES.DLL',
       'DEVEXPRESS.XTRAEDITORS.V12.2.DLL', 'DEVEXPRESS.XTRAEDITORS.V12.2.RESOURCES.DLL', 'DEVEXPRESS.XTRAGRID.V12.2.DLL',
       'DEVEXPRESS.XTRAGRID.V12.2.RESOURCES.DLL', 'DEVEXPRESS.XTRALAYOUT.V12.2.DLL',
       'DEVEXPRESS.XTRALAYOUT.V12.2.RESOURCES.DLL', 'DEVEXPRESS.XTRANAVBAR.V12.2.DLL',
       'DEVEXPRESS.XTRANAVBAR.V12.2.RESOURCES.DLL', 'DEVEXPRESS.XTRAPRINTING.V12.2.DLL',
       'DEVEXPRESS.XTRAPRINTING.V12.2.RESOURCES.DLL', 'DEVEXPRESS.XTRAREPORTS.V12.2.EXTENSIONS.RESOURCES.DLL',
       'DEVEXPRESS.XTRAREPORTS.V12.2.RESOURCES.DLL', 'DEVEXPRESS.XTRARICHEDIT.V12.2.DLL',
       'DEVEXPRESS.XTRARICHEDIT.V12.2.RESOURCES.DLL', 'DEVEXPRESS.XTRASCHEDULER.V12.2.CORE.RESOURCES.DLL',
       'DEVEXPRESS.XTRASCHEDULER.V12.2.EXTENSIONS.RESOURCES.DLL', 'DEVEXPRESS.XTRASCHEDULER.V12.2.RESOURCES.DLL',
       'DEVEXPRESS.XTRASPELLCHECKER.V12.2.RESOURCES.DLL', 'DEVEXPRESS.XTRATREELIST.V12.2.DLL',
       'DEVEXPRESS.XTRATREELIST.V12.2.RESOURCES.DLL', 'DEVEXPRESS.XTRAVERTICALGRID.V12.2.DLL',
       'DEVEXPRESS.XTRAVERTICALGRID.V12.2.RESOURCES.DLL', 'DEVEXPRESS.XTRAWIZARD.V12.2.DLL',
       'DEVEXPRESS.XTRAWIZARD.V12.2.RESOURCES.DLL', 'DHRICHCLIENT3.DLL', 'DICOMOBJECTS.LIC', 'DICOMOBJECTS.OCX',
       'DVDPROX2.DLL', 'DX7VB.DLL', 'ENGINE32.CAB', 'EUDC.EUF', 'EUDC.REG', 'EUDC.TTE', 'EZTW32.DLL', 'FINDFILE.AVI',
       'FLASH.OCX');
Delete Zltools.Zlfilesupgrade A
Where Upper(a.文件名) In
      ('FLASH9F.OCX', 'FTP_TRANS.DLL', 'GAPI32.DLL', 'GDIPLUS.DLL', 'HASHCTL.DLL', 'HOSP_INTERFACE_FYPROJ.OCX',
       'ICAPI.DLL', 'ICREAD.DLL', 'ICWRITE.DLL', 'IKVM.OPENJDK.CHARSETS.DLL', 'IKVM.OPENJDK.CORE.DLL',
       'IKVM.OPENJDK.TEXT.DLL', 'IKVM.OPENJDK.UTIL.DLL', 'IKVM.OPENJDK.XML.API.DLL', 'IKVM.RUNTIME.DLL', 'IME.EXE',
       'IMESHARE.DLL', 'IMGCMN.DLL', 'IMGSCAN.OCX', 'IMGSHL.DLL', 'IMGUTIL.DLL', 'INMONEYONLINE.DLL',
       'INTEROP.DICOMOBJECTS.DLL', 'INTEROP.ZLPACSRICHPAGESCALE.DLL', 'ISHF_EX.TLB', 'JPEG1X32.DLL', 'JPEG2X32.DLL',
       'LAME_ENC.DLL', 'LNCATOOLKITS.OCX', 'LSOUND.DIC', 'MCI32.OCX', 'MSCC2CHS.DLL', 'MSCH2CHS.DLL', 'MSCHRT20.OCX',
       'MSCMCCHS.DLL', 'MSCOMCHS.DLL', 'MSCOMCT2.OCX', 'MSCOMCTL.OCX', 'MSCOMM32.OCX', 'MSDATGRD.OCX', 'MSFLXGRD.OCX',
       'MSHFGCHS.DLL', 'MSHFLXGD.OCX', 'MSINET.OCX', 'MSMASK32.OCX', 'MSMSKCHS.DLL', 'MSPRPCHS.DLL', 'MSSCRIPT.OCX',
       'MSSTDFMT.DLL', 'MSSTKPRP.DLL', 'MSVCP60.DLL', 'MSVCRT.DLL', 'MSWINSCK.OCX', 'MSXML3.DLL', 'MSXML3A.DLL',
       'MSXML3R.DLL', 'MSXML5.DLL', 'MSXML6.DLL', 'OIADM400.DLL', 'OICOM400.DLL', 'OIDIS400.DLL', 'OIENG400.DLL',
       'OIFIL400.DLL', 'OIGFS400.DLL', 'OIPRT400.DLL', 'OISLB400.DLL', 'OISSQ400.DLL', 'OITWA400.DLL', 'OIUI400.DLL',
       'OLCH2X8.OCX', 'OLEGUIDS.TLB', 'OLELIB.TLB', 'ORACLE.MANAGEDDATAACCESS.DLL', 'PDFTOTEXT.DLL', 'QRMAKER.LIC',
       'RCHTXCHS.DLL', 'READBARCOMM.DLL', 'REGCOM.EXE', 'RICHED20.DLL', 'RICHED32.DLL', 'RICHTX32.OCX',
       'SAXON9HE-API.DLL', 'SAXON9HE.DLL', 'SCRRNCHS.DLL', 'SCRRUN.DLL', 'SDTAPI.DLL', 'SETUP.IBT', 'SHLEXT.TLB',
       'SQLITE3.DLL', 'SQLITE36_ENGINE.DLL', 'SSMDRAW.DLL', 'SSMG7.DLL', 'STDFTCHS.DLL', 'STDOLE.DLL', 'STRSOUND.DLL',
       'SYSINFO.OCX', 'TABCTCHS.DLL', 'TABCTL32.OCX', 'TTF16.OCX', 'UNZIP32.DLL');
Delete Zltools.Zlfilesupgrade A
Where Upper(a.文件名) In
      ( 'VB6CHS.DLL', 'VB6STKIT.DLL', 'VFPODBC.DLL', 'VSFLEX8.OCX', 'VSPRINT8.OCX', 'WAV.BMP',
       'WAVDOWNLOAD.BMP', 'WBX.TXT', 'WLTRS.DLL', 'XCDZIP35.OCX', 'XTPRESOURCEZHCN.DLL', 'XTXAPPCOM.DLL', 'ZIP32.DLL',
       'ZL9ANALYSIS.DLL', 'ZL9CISCORE.DLL', 'ZL9I_CONFIGURE.DLL', 'ZL9MEDICAL.DLL', 'ZL9OPS.DLL', 'ZL9PACSCAPTURE.EXE',
       'ZL9PEIS.CHM', 'ZL9PEISOUTERINTERFACE.DLL', 'ZL9RTFCREATOR.DLL', 'ZL9TAXBILL.DLL', 'ZL9TECHCORE.DLL',
       'ZL9WARDMONITOR.DLL', 'ZLCOMMUNITY.DLL', 'ZLDATAORACLE.DLL', 'ZLDATASQLITE.DLL', 'ZLFLAG.AVI', 'ZLGETIMAGEEX.EXE',
       'ZLGRANT.DLL', 'ZLMIPCLIENT.DLL', 'ZLMIPCLIENTCOMLIB.DLL', 'ZLMIPCLIENTMANAGE.EXE', 'ZLMIPCLIENTPOLL.EXE',
       'ZLMIPCLIENTSHELL.EXE', 'ZLPACSBROWSERSTATION.EXE', 'ZLPACSCOMMON.DLL', 'ZLPACSCONFIG.DLL', 'ZLPACSCONTROL.DLL',
       'ZLPACSEDITORBASE.DLL', 'ZLPACSEDITORCOMMON.DLL', 'ZLPACSEDITORCORE.DLL', 'ZLPACSEDITORMANAGE.DLL',
       'ZLPACSINTERFACEC.DLL', 'ZLPACSLOGVIEW.EXE', 'ZLPACSPLUGIN.DRAWINGBOARD.DLL', 'ZLPACSPLUGIN.IMAGEEDITOR.DLL',
       'ZLPACSPLUGIN.MEDICALSYMBOLS.DLL', 'ZLPACSPLUGIN.PACSCAPTURE.DLL', 'ZLPACSPLUGIN.REPORTHISTORY.DLL',
       'ZLPACSPLUGIN.SPECIALREPORT.DLL', 'ZLPACSPLUGIN.STUDYIMAGE.DLL', 'ZLPACSPLUGININTERFACE.DLL',
       'ZLPACSRICHPAGES.OCX', 'ZLPACSSERVERCENTER.EXE', 'ZLPACSSERVERMANAGE.EXE', 'ZLPACSSERVICES.DLL',
       'ZLRECIPEAUDITEX.DLL', 'ZLUZIP10.DLL', 'ZLVSFLEXGRID.DLL', 'ZLZIP11.DLL', '打印.AVI', '单病人宽屏深蓝.INI', '单病人宽屏深蓝.JPG',
       '单队列宽屏浅紫.INI', '单队列宽屏浅紫.JPG', '单队列宽屏深蓝.INI', '单队列宽屏深蓝.JPG', '单队列宽屏天蓝.INI', '单队列宽屏天蓝.JPG', '单队列竖屏天蓝.INI',
       '单队列竖屏天蓝.JPG', '多队列样式浅紫.INI', '多队列样式浅紫.JPG', '多队列样式深蓝.INI', '多队列样式深蓝.JPG', '多队列样式天蓝.INI', '多队列样式天蓝.JPG',
       '收费项目.XLSX', '卫材目录.XLSX', '药品目录.XLSX');

--重新生成的数据，方便处理先删除
Update ZLTOOLS.zlFilesUpgrade Set 文件名 = 'zl9WizardInvoice.dll' Where Upper(文件名) = Upper('zl9WizardInvoicePrint.dll');
Insert Into Zltools.Zlfilesexpired(文件名, 安装路径, 系统编号, 系统版本, 说明)Values('zl9WizardInvoicePrint.dll', '[APPSOFT]\APPLY', Null, '10.35.60', '自助票据打印，名称错误，正确名称为zl9WizardInvoice.dll');
Delete Zltools.Zlfilesupgrade A
Where Upper(a.文件名) In
      ('7Z.DLL', '7Z.EXE', 'AAMD532.DLL', 'CODEJOCK.SYNTAXEDIT.V15.3.1.OCX', 'QRMAKER.OCX', 'SYSTEM.WINDOWS.FORMS.TLB',
       'SYSTEM.WINDOWS.FORMS.DLL', 'WINCMP3.EXE', 'WINCMP3.INI', 'ZL9BILLEDIT.OCX', 'ZL9INSURE.DLL', 'ZL9LABWORK.DLL',
       'ZL9LISINSIDECOMM.DLL', 'ZL9PACSIMAGECAP.DLL', 'ZL9TEMPERATURECHARTSD.DLL', 'ZL9TEMPERATURECHARTYN.DLL',
       'ZL9XWINTERFACE.DLL', 'ZLDSVIDEOPROCESS.OCX', 'ZLHIS+.EXE', 'ZLHISCRUST.EXE', 'ZLLOGIN.DLL', 'ZLNEWQUERY.EXE',
       'ZLPUBLICDRUG.DLL', 'ZLREGISTER.DLL', 'ZLRPTSQLADJUST.EXE', 'ZLRUNAS.EXE', 'ZLSOFTSHOWHISFORMS.EXE',
       'ZLSOFT.BUSINESSHOME.CLIENTCONTROL.TIMELINEBASE.DLL', 'ZLSOFT.BUSINESSHOME.CLIENTCONTROL.TIMELINEBASE.TLB',
       'ZL9DRUGSTORE.DLL', 'ZL9LISCOMM.EXE', 'ZLBRW.DLL', 'ZLMDI.DLL', 'ZLPACSSRV.EXE', 'ZLPATIADDRESS.OCX', 'ZLWIN.DLL',
       '_SQL.SCHCLASS', 'CODEJOCK.CALENDAR.V16.3.1.OCX', 'GACUTIL.EXE', 'GACUTIL.EXE.CONFIG', 'MSCORLIB.DLL',
       'ZL9CASHBILL.DLL', 'ZL9APPTOOL.DLL', 'ZL9BASEITEM.DLL', 'ZL9BLOOD.DLL', 'ZL9BODYEDITOR.DLL', 'ZL9BODYEDITORGS.DLL',
       'ZL9BODYEDITORGX.DLL', 'ZL9BODYEDITORHEN.DLL', 'ZL9BODYEDITORHN.DLL', 'ZL9BODYEDITORHUN.DLL',
       'ZL9BODYEDITORQD.DLL', 'ZL9BODYEDITORSCDQ.DLL', 'ZL9BODYEDITORSXHZ.DLL', 'ZL9BODYEDITORSXET.DLL',
       'ZL9BODYEDITORYDEY.DLL', 'ZL9BODYEDITORYX.DLL', 'ZL9CISAUDIT.DLL', 'ZL9CISBASE.DLL', 'ZL9CISJOB.DLL',
       'ZL9CARDSQUARE.DLL', 'ZL9COMLIB.DLL', 'ZL9COMLIBPSS.DLL', 'ZL9COMMEVENTS.DLL', 'ZL9CUSTACC.DLL', 'ZL9DEVICE.DLL',
       'ZL9DISEASE.DLL', 'ZL9DRAWREPORT.DLL', 'ZL9DUE.DLL', 'ZL9ESIGN.DLL', 'ZL9FUNCTION.DLL', 'ZL9INEXSE.DLL',
       'ZL9INPATIENT.DLL', 'ZL9INFECT.DLL', 'ZL9LCDSHOW.DLL', 'ZL9LABPRINTSVR.EXE', 'ZL9LABRECEIV.EXE',
       'ZL9LABTCPSVR.EXE', 'ZL9LEDVOICE.DLL', 'ZL9LISQUERY_BASE.DLL', 'ZL9LISQUERY_DFN.DLL', 'ZL9LISWORK.DLL',
       'ZL9MATERIAL.DLL', 'ZL9MEDREC.DLL', 'ZL9MEDISTORE.DLL', 'ZL9OPER.DLL', 'ZL9OPSSTARAND.DLL', 'ZL9OUTEXSE.DLL',
       'ZL9PACSWORK.DLL', 'ZL9PACSCONTROL.OCX', 'ZL9PACSCORE.DLL', 'ZL9PARTOGRAM.DLL', 'ZL9PATIENT.DLL',
       'ZL9PEISBASE.DLL', 'ZL9PEISCOMLIB.DLL', 'ZL9PEISDEVANALYSE.DLL', 'ZL9PEISFLOW.DLL', 'ZL9PEISINNERINTERFACE.DLL',
       'ZL9PEISINSTRUMENT.DLL', 'ZL9PEISINTERFACE.DLL', 'ZL9PEISMANAGE.DLL', 'ZL9PEISPERSONPDF.DLL',
       'ZL9PEISPERSONREPORT.DLL', 'ZL9PEISPERSONRPT.DLL', 'ZL9PEISRPT.DLL', 'ZL9PRINTMODE.DLL', 'ZL9PURVEY.DLL',
       'ZL9RECIPEAUDIT.DLL', 'ZL9REGEVENT.DLL', 'ZL9REPORT.DLL', 'ZL9STUFF.DLL', 'ZL9TEMPERATURECHART.DLL',
       'ZL9TEMPERATURECHARTGD.DLL', 'ZL9TEMPERATURECHARTGS.DLL', 'ZL9TEMPERATURECHARTGX.DLL',
       'ZL9TEMPERATURECHARTGZJX.DLL', 'ZL9TEMPERATURECHARTHLJ.DLL', 'ZL9TEMPERATURECHARTHNNX.DLL',
       'ZL9TEMPERATURECHARTJX.DLL');

Delete Zltools.Zlfilesupgrade A
Where Upper(a.文件名) In
      ('ZL9TEMPERATURECHARTNJ.DLL', 'ZL9TEMPERATURECHARTS3201.DLL', 'ZL9TEMPERATURECHARTSC.DLL',
       'ZL9TEMPERATURECHARTSCZG.DLL', 'ZL9TEMPERATURECHARTSX.DLL', 'ZL9TEMPERATURECHARTYDEY.DLL', 'ZL9TENDFILE.DLL',
       'ZL9TRANSFUSION.DLL', 'ZL9WIZARDCARDS.DLL', 'ZL9WIZARDCONTROL.OCX', 'ZL9WIZARDDEPOSIT.DLL', 'ZL9WIZARDEMR.DLL',
       'ZL9WIZARDFEEQUERY.DLL', 'ZL9WIZARDINSURE.DLL', 'ZL9WIZARDINVOICE.DLL', 'ZL9WIZARDLABCALL.DLL',
       'ZL9WIZARDLABPRINT.DLL', 'ZL9WIZARDLIB.DLL', 'ZL9WIZARDMAIN.EXE', 'ZL9WIZARDMANAGE.DLL', 'ZL9WIZARDPAGE.DLL',
       'ZL9WIZARDPAYFEE.DLL', 'ZL9WIZARDPEISQUEUE.DLL', 'ZL9WIZARDPHARMACY.DLL', 'ZL9WIZARDPRICE.DLL',
       'ZL9WIZARDPROFICIENT.DLL', 'ZL9WIZARDPROOF.DLL', 'ZL9WIZARDREGEVENT.DLL', 'ZL9WIZARDTODAY.DLL', 'ZL9KEYBOARD.DLL',
       'ZL9PEISGROUPRPT.DLL', 'ZLACTMAIN.EXE', 'ZLCISKERNEL.DLL', 'ZLCISPATH.DLL', 'ZLCISAUDITPRINT.EXE',
       'ZLDISREPORTCARD.DLL', 'ZLGETIMAGE.EXE', 'ZLICCARD.DLL', 'ZLIDCARD.DLL', 'ZLIDKIND.OCX', 'ZLLISDEV.DLL',
       'ZLLISINTERFACE.DLL', 'ZLLISMESSAGE.EXE', 'ZLLISRECEIVESEND.EXE', 'ZLMEDRECPAGE.DLL', 'ZLOPERINTERFACE.DLL',
       'ZLORCLCONFIG.EXE', 'ZLPACSVBCOMMON.DLL', 'ZLPASSINTERFACE.DLL', 'ZLPEISAUTOANALYSE.EXE', 'ZLPICTUREEDITOR.DLL',
       'ZLPUBLICADVICE.DLL', 'ZLPUBLICBLOOD.DLL', 'ZLPUBLICEXPENSE.DLL', 'ZLPUBLICLIS.DLL', 'ZLPUBLICPACS.DLL',
       'ZLPUBLICPATH.DLL', 'ZLPUBLICPATIENT.DLL', 'ZLPUBLICPEIS.DLL', 'ZLQUEUEMANAGE.DLL', 'ZLQUEUEOPER.OCX',
       'ZLQUEUESHOW.EXE', 'ZLRISDUMPTOOL.EXE', 'ZLRICHEPR.DLL', 'ZLRICHEDITOR.OCX', 'ZLSCREENKEYBOARD.EXE',
       'ZLSUBCLASS.OCX', 'ZLSVGPROCESS.DLL', 'ZLSVRNOTICE.EXE', 'ZLSVRSTUDIO.EXE', 'ZLSWITCHEFFECT.DLL',
       'ZLSWITCHPAGE.DLL', 'ZLTABLE.OCX', 'ZLTABLEEPR.DLL', 'ZLUPGRADEREADER.EXE', 'ZLWIZARDNEWLABPRINT.DLL',
       'ZLWIZARDPACSPRINT.DLL', 'ZLWIZARDSTART.EXE');

--补充删除数据，从10.30.0升级到10.35.60获取的文件
Delete Zltools.Zlfilesupgrade a
Where Upper(a.文件名) In ('PTA.DLL',
                       'QEDIT.DLL',
                       'WINCMP3EXT.DLL',
                       'WINCMP3EXT64.DLL',
                       'WINCMPEXT.DLL',
                       'WINCMPEXT64.DLL',
                       'ZL9ACCOUNT.DLL',
                       'ZL9APP1.CHM',
                       'ZL9APP2.CHM',
                       'ZL9APP3.CHM',
                       'ZL9APP4.CHM',
                       'ZL9APP5.CHM',
                       'ZL9APP6.CHM',
                       'ZL9APP7.CHM',
                       'ZL9COST.DLL',
                       'ZL9DESIGN.OCX',
                       'ZL9EXCEL.DLL',
                       'ZL9FINANCEFUNC.DLL',
                       'ZL9HUMAN.DLL',
                       'ZL9PEISAUTOANALYSE.EXE',
                       'ZL9PRINTVOUCHER.DLL',
                       'ZL9SERVER.CHM',
                       'ZL9START.CHM',
                       'ZL9TRANSFUSION.CHM',
                       'ZL9VOUCHER.OCX',
                       'ZL9XLS.EXE',
                       'ZLLIS.CHM',
                       'ZL9CISWORK.DLL',
                       'ZL9IMGCAPTURE.DLL',
                       'ZLPBULICPEIS',
                       'ZLSOFTSHOWARCHIVE.EXE');
		    
--部分序号需要修正
Update ZLTOOLS.zlFilesUpgrade Set 序号=(To_Number(序号)+200) Where To_Number(序号)<200;
--删除所有的ZLFILES数据，以待后续重新生成
Delete  ZLTOOLS.ZLFILES;
--新数据插入
Insert Into Zltools.Zlfilesupgrade(序号, 加入日期, 安装路径, 文件类型, 文件名, 版本号, 修改日期, 所属系统, 业务部件, Md5, 文件说明, 自动注册, 强制覆盖, 附加安装路径, 文件版本号)
Select   '1', To_Date('2017-07-05 17:22:54','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 0, 'ZL9BillEdit.ocx', NULL, NULL, '1,3,4,6,21,22,23,24,25', NULL, NULL , '部件功能:单据编辑控件系统定位:提供表格控件缺失后果:用到此控件的界面不能正常打开，或者报错。', 1, 0, NULL, NULL From Dual Union All
Select   '2', To_Date('2017-07-05 17:22:54','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 0, 'ZL9Insure.dll', NULL, NULL, NULL, NULL, NULL , '部件功能:医保接口部件。使用原因:医保项目检查，医保记帐作废上传缺失后果:重打时出错', 1, 0, NULL, NULL From Dual Union All
Select   '3', To_Date('2017-07-05 17:22:54','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]', 0, 'ZLHIS+.exe', NULL, NULL, '1,3,4,6,21,22,23,24,25,26', NULL, NULL , '部件功能:ZLHIS+启动程序。系统定位:登录该程序才能进入导航台，进行业务操作。缺失后果:缺失该部件将无法进行各项业务。', 0, 0, NULL, NULL From Dual Union All
Select   '4', To_Date('2017-07-05 17:22:54','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]', 0, 'ZLHISCRUST.EXE', NULL, NULL, '1,3,4,6,21,22,23,24,25,26', NULL, NULL , '部件功能:客户端自动升级工具。系统定位:通过该工具对各个客户端进行文件升级。缺失后果:缺失该文件，将会导致需要升级的客户端无法进入导航台。', 0, 0, NULL, NULL From Dual Union All
Select   '5', To_Date('2017-07-05 17:24:19','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 0, 'ZLLOGIN.DLL', NULL, NULL, '1,3,4,6,21,22,23,24,25,26', NULL, NULL , '部件功能:公共登录部件，提供统一登录接口，以及登陆中的功能、授权、客户端控制、升级等处理。系统定位:各个Exe均通过该部件实现登录。缺失后果:缺失该部件将会导致启动Exe程序出错。', 1, 0, NULL, NULL From Dual Union All
Select   '6', To_Date('2017-07-05 17:24:19','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 0, 'ZLREGISTER.DLL', NULL, NULL, NULL, NULL, NULL , '部件功能:用到此控件的界面不能正常打开，或者报错。使用原因:统一的注册校验、用户加密解密部件。缺失后果:相关流程无法进行身份验证，流程终止，包含：配血审核身份验证、发血身份验证、血液接收登记身份验证、输血执行身份验证。', 1, 0, NULL, NULL From Dual Union All
Select   '7', To_Date('2017-07-05 18:50:52','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]', 0, 'ZLRPTSQLAdjust.exe', NULL, NULL, NULL, NULL, NULL , '部件功能:10.26病人费用表拆分配套工具。系统定位:进行大表拆分后的涉及病人费用记录的报表的调整。缺失后果:无法进行方便的进行大表拆分后的报表调整。', 0, 0, NULL, NULL From Dual Union All
Select   '8', To_Date('2017-07-05 17:22:54','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 0, 'ZlBrw.dll', NULL, NULL, '1,3,4,6,21,22,23,24,25,26', NULL, NULL , '部件功能:标准导航台样式，即双列表样式。系统定位:用来进行各个业务的导航，并提供一些基础的工具。缺失后果:缺失该部件，当选择的导航台样式为该样式时，无法进入整个系统。', 1, 0, NULL, NULL From Dual Union All
Select   '9', To_Date('2017-07-05 17:22:54','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 0, 'ZlMdi.dll', NULL, NULL, '1,3,4,6,21,22,23,24,25,26', NULL, NULL , '部件功能:Mdi样式导航台，即父窗体里面存在各个子窗体。系统定位:用来进行各个业务的导航，并提供一些基础的工具。缺失后果:缺失该部件，当选择的导航台样式为该样式时，无法进入整个系统。', 1, 0, NULL, NULL From Dual Union All
Select  '10', To_Date('2017-07-05 17:22:54','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 0, 'ZlWin.dll', NULL, NULL, '1,3,4,6,21,22,23,24,25,26', NULL, NULL , '部件功能:仿Window桌面样式导航台。系统定位:用来进行各个业务的导航，并提供一些基础的工具。缺失后果:缺失该部件，当选择的导航台样式为该样式时，无法进入整个系统。', 1, 0, NULL, NULL From Dual Union All
Select  '11', To_Date('2017-07-05 17:22:54','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 0, 'zl9AppTool.dll', NULL, NULL, '1,3,4,6,21,22,23,24,25,26', NULL, NULL , '部件功能:导航台的中提供的基础应用工具功能部件。系统定位:提供了个人系统级的个性化设置、系统基础字典数据管理、邮件收发管理等功能。缺失后果:缺失将会导致无法使用整个系统。', 1, 0, NULL, NULL From Dual Union All
Select  '12', To_Date('2017-07-05 17:22:54','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 0, 'zl9ComLib.dll', NULL, NULL, '1,3,4,6,21,22,23,24,25,26', NULL, NULL , '部件功能:公共的基础函数库，用来提供统一的SQL查询、一些系统常用API封装、常用控件处理、常用类型方法以及应用系统基础业务的常用查询。系统定位:ZLHIS的系统底层支持部件，一般部件均使用该部件提供的公共方法进行编码缺失后果:整个应用系统无法使用。', 1, 0, NULL, NULL From Dual Union All
Select  '13', To_Date('2017-07-05 17:22:55','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 0, 'zl9CommEvents.dll', NULL, NULL, '1,3,4,6,21,22,23,24,25,26', NULL, NULL , '部件功能:公共的基础事件部件：自动发卡、投币、键盘输入和自动读卡事件触发后，主程序能够响应。系统定位:三方程序触发事件,以便主程序接收数据。缺失后果:自助发卡、自助系统的现金支付功能调用就会出现错误，所有使用第三方接口自动读卡也会出现错误。', 1, 0, NULL, NULL From Dual Union All
Select  '14', To_Date('2017-07-05 17:22:54','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 0, 'zl9Function.dll', NULL, NULL, NULL, NULL, NULL , '部件功能:函数管理工具。系统定位:进行自定义报表函数的管理。缺失后果:无法进行自定义报表函数的管理。', 1, 0, NULL, NULL From Dual Union All
Select  '15', To_Date('2017-07-05 17:22:54','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 0, 'zl9PrintMode.dll', NULL, NULL, '1,3,4,6,21,22,23,24,25,26', NULL, NULL , '部件功能:打印表格控件内容、通过命令生成输出内容等系统定位:方便用户输出数据缺失后果:可以缺少，但无法输出数据', 1, 0, NULL, NULL From Dual Union All
Select  '16', To_Date('2017-07-05 17:22:54','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 0, 'zl9Report.dll', NULL, NULL, '1,3,4,6,21,22,23,24,25,26', NULL, NULL , '部件功能:支持业务系统输出自定义报表的内容，以及设计自定义报表系统定位:方便用户和技术人员缺失后果:缺少将无法输出报表和设计报表', 1, 0, NULL, NULL From Dual Union All
Select  '17', To_Date('2017-07-05 17:22:58','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]', 0, 'zlActMain.exe', NULL, NULL, '1,3,4,6,21,22,23,24,25,26', NULL, NULL , '部件功能:BH融合中的虚拟导航台。系统定位:BH调用各个模块均通过该程序进行导航。缺失后果:缺失时BH无法使用所有的业务模块。', 1, 0, NULL, NULL From Dual Union All
Select  '18', To_Date('2017-07-05 17:22:54','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 0, 'zlICCard.dll', NULL, NULL, '1,3,4,6,21,22,23,24,25,26', NULL, NULL , '部件功能:IC卡读卡的统一接口系统定位:IC卡读卡缺失后果:一卡通无法使用，部分会导致程序异常退出', 1, 0, NULL, NULL From Dual Union All
Select  '19', To_Date('2017-07-05 17:22:54','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 0, 'zlIDCard.dll', NULL, NULL, '1,3,4,6,21,22,23,24,25,26', NULL, NULL , '部件功能:身份证读卡的统一接口系统定位:读取身份证信息缺失后果:无法读取身份证信息', 1, 0, NULL, NULL From Dual Union All
Select  '20', To_Date('2017-07-05 17:22:54','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 0, 'zlIDKind.ocx', NULL, NULL, '1,3,4,6,21,22,23,24,25', NULL, NULL , '部件功能:病人身份识别控件系统定位:刷卡和读卡查询病人缺失后果:使用的地方应控件丢失出错', 1, 0, NULL, NULL From Dual Union All
Select  '21', To_Date('2017-07-05 17:22:55','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]', 0, 'zlOrclConfig.exe', NULL, NULL, NULL, NULL, NULL , '用于快速配置ORACLE配置文件的工具。', 0, 0, NULL, NULL From Dual Union All
Select  '22', To_Date('2017-07-05 17:22:54','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]', 0, 'zlSvrNotice.exe', NULL, NULL, NULL, NULL, NULL , '部件功能:自动提醒服务。系统定位:进行消息提醒的提示与阅读。缺失后果:无发处理消息提醒。', 0, 0, NULL, NULL From Dual Union All
Select  '23', To_Date('2017-07-05 17:22:54','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]', 0, 'zlSvrStudio.exe', NULL, NULL, NULL, NULL, NULL , '部件功能:ZLHIS系统的后台管理工具。系统定位:提供了系统的升级、安装、授权以及其他的实用功能，可以方便的进行后台管理。缺失后果:缺失该部件将会导致无法进行系统管理操作。', 0, 0, NULL, NULL From Dual Union All
Select  '24', To_Date('2017-07-05 18:50:52','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]', 0, 'zlUpgradeReader.exe', NULL, NULL, NULL, NULL, NULL , '部件功能:升级说明阅读器。系统定位:进行重大功能的核对以及培训事宜的处理。缺失后果:无法进行升级问题清单的阅读与核对。', 0, 0, NULL, NULL From Dual Union All
Select  '25', To_Date('2017-07-05 17:22:55','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'ZL9LABWork.dll', NULL, NULL, '25', NULL, NULL , '部件功能:新版LIS核心部件系统定位:处理新版LIS工作站，报告查询等缺失后果:新版LIS将不能正常使用', 1, 0, NULL, NULL From Dual Union All
Select  '26', To_Date('2017-07-05 17:22:55','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'ZL9LisInsideComm.dll', NULL, NULL, '1,25', 'ZL9Peis.dll,zl9PeisManage.dll,zl9CISAudit.dll,zl9Disease.dll,ZL9LabWork.dll,zl9LisWork.dll,zl9CISJob.dll,zl9Blood.dll', NULL , '部件功能:处理新版LIS与HIS之间数据交互系统定位:主要应用于LIS与HIS交互接口部分，以及临床申请单使用。检验申请单设置缺失后果:LIS与HIS的数据将不正常', 1, 0, NULL, NULL From Dual Union All
Select  '27', To_Date('2017-07-05 17:24:18','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'ZL9PACSIMAGECAP.DLL', NULL, NULL, '1', 'zl9PACSWork.dll', NULL , '部件功能:提供影像图像的采集与传输系统定位:影像检查图像采集支持缺失后果:影像采集病理系统不能运行。', 1, 0, NULL, NULL From Dual Union All
Select  '28', To_Date('2017-07-05 17:22:58','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'ZL9TEMPERATURECHARTSD.dll', NULL, NULL, '1', 'zl9CISJob.dll', NULL , '部件功能:新版护士工作站体温单相关功能(山东地区适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单', 1, 0, NULL, NULL From Dual Union All
Select  '29', To_Date('2017-07-05 17:22:58','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'ZL9TemperaTureChartYN.Dll', NULL, NULL, '1', 'zl9CISJob.dll', NULL , '部件功能:新版护士工作站体温单相关功能(云南大理专用体温部件)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单', 1, 0, NULL, NULL From Dual Union All
Select  '30', To_Date('2017-07-05 17:30:05','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'ZL9XWINTERFACE.DLL', NULL, NULL, '1', 'ZL9Peis.dll,zl9PeisManage.dll,zlWizardStart.exe,zl9CISAudit.dll,zl9CISJob.dll,zl9PACSWork.dll,zl9Patient.dll,zl9InPatient.dll,zl9CISBase.dll,zl9BaseItem.dll', NULL , '部件功能:提供ris与his系统数据交换接口系统定位:专业ris系统支持缺失后果:不能使用专业版ris系统', 1, 0, NULL, NULL From Dual Union All
Select  '31', To_Date('2017-07-05 17:22:55','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 1, 'ZLDSVIDEOPROCESS.OCX', NULL, NULL, '1', 'zl9RegEvent.dll,zl9CardSquare.dll,ZL9Peis.dll,zl9PeisManage.dll,zl9PACSWork.dll', NULL , '部件功能:视频采集相关功能封装使用原因:体检人员照片采集缺失后果:不能采集图像和录像', 1, 0, NULL, NULL From Dual Union All
Select  '32', To_Date('2017-07-05 17:22:58','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]', 1, 'ZLNewQuery.exe', NULL, NULL, '1', NULL, NULL , '部件功能:老版自助系统系统定位:自助挂号、Lis打印、费用查询缺失后果:老版自助系统不能使用', 0, 0, NULL, NULL From Dual Union All
Select  '33', To_Date('2017-07-05 17:32:16','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 1, 'ZLPUBLICDRUG.DLL', NULL, NULL, '1', 'zlCISKernel.dll,zl9InExse.DLL,zl9OutExse.dll', NULL , '部件功能:药品业务公共部件系统定位:其他业务调用药品公共功能接口缺失后果:其他业务调用药品公共功能错误', 1, 0, NULL, NULL From Dual Union All
Select  '34', To_Date('2017-07-05 17:30:05','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]', 1, 'ZLSOFTSHOWHISFORMS.EXE', NULL, NULL, '1', 'zl9XWInterface.dll', NULL , '部件功能:显示病历查阅,医嘱，pacs历史报告等系统定位:ris中调用查看病历内容。缺失后果:ris系统不能查看病历内容。', 0, 0, NULL, NULL From Dual Union All
Select  '35', To_Date('2017-07-05 17:22:57','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'Zl9DrugStore.dll', NULL, NULL, '1', NULL, NULL , '部件功能:药房事务系统定位:门诊、住院药房发药管理，输液配置中心管理缺失后果:无法使用门诊、住院药房管理功能，无法使用静配功能', 1, 0, NULL, NULL From Dual Union All
Select  '36', To_Date('2017-07-05 17:22:57','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]', 1, 'Zl9LISComm.exe', NULL, NULL, '1', 'zl9LisWork.dll', NULL , '部件功能:老版检验通讯程序系统定位:老版检验通讯程序，处理仪器回传数据，加工成检验系统能够认识的数据格式缺失后果:检验结果将不能正常回传给老版LIS系统', 0, 0, NULL, NULL From Dual Union All
Select  '37', To_Date('2017-07-05 17:22:58','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]', 1, 'ZlPacsSrv.exe', NULL, NULL, '1', 'zl9CISJob.dll', NULL , '部件功能:接受Dicom设备发送的检查图像系统定位:PACS网关服务，监听影像DICOM设备请求并进行处理缺失后果:不能与影像DICOM设备通讯，不能接受设备图像', 0, 0, NULL, NULL From Dual Union All
Select  '38', To_Date('2017-07-05 17:22:55','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 1, 'ZlPatiAddress.ocx', NULL, NULL, '1', 'zl9RegEvent.dll,zl9CardSquare.dll,zl9CISJob.dll,zl9InPatient.dll,zl9Patient.dll,zl9MedRec.dll,zl9InExse.DLL', NULL , '部件功能:结构化地址部件系统定位:支持系统中进行结构化地址填写缺失后果:无法使用入院、挂号、首页等相关程序', 1, 0, NULL, NULL From Dual Union All
Select  '39', To_Date('2017-07-05 17:22:55','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zL9CashBill.dll', NULL, NULL, '1', 'ZL9Peis.dll,zl9PeisManage.dll,zl9RegEvent.dll,zl9CardSquare.dll,zl9InExse.DLL,zl9OutExse.dll,zl9Patient.dll,zl9InPatient.dll,zl9CustAcc.dll', NULL , '部件功能:财务监控及票据管理系统定位:收费轧帐、财务组收款、收费财务监控、人员借款和票据的入库、领用和报损。缺失后果:相关功能不能使用', 1, 0, NULL, NULL From Dual Union All
Select  '40', To_Date('2017-07-05 17:22:55','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9BaseItem.dll', NULL, NULL, '1', 'zl9BaseItem.dll,zl9InExse.DLL,zl9OutExse.dll', NULL , '部件功能:基础数据管理系统定位:业务基础部件，包括部门，人员，收费项目，收入项目，各业务公共参数等基础设置缺失后果:无法进行基础数据设置', 1, 0, NULL, NULL From Dual Union All
Select  '41', To_Date('2017-07-05 17:22:56','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9Blood.dll', NULL, NULL, '22', NULL, NULL , '部件功能:血库系统核心框架部件系统定位:包含血库相关功能模块：血液目录管理、血液供应入出库、科室配血管理、科室发血管理、血袋回收、报废等缺失后果:血库系统将无法使用', 1, 0, NULL, NULL From Dual Union All
Select  '42', To_Date('2017-07-05 17:22:55','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9BodyEditor.dll', NULL, NULL, '1', 'zl9CISJob.dll', NULL , '部件功能:老版护士工作站中标准体温单相关功能调用,在未使用地区性体温部件时,均使用此部件系统定位:处理老版护士工作站中标准体温单相关业务缺失后果:无法使用老版护士工作站体温单的数据展示,编辑和打印功能', 1, 0, NULL, NULL From Dual Union All
Select  '43', To_Date('2017-07-05 17:22:56','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9BodyEditorGS.dll', NULL, NULL, '1', 'zl9CISJob.dll', NULL , '部件功能:甘肃中医院专用体温单部件系统定位:处理老版护士工作站中体温单的相关业务缺失后果:缺失后会使用标准版体温部件', 1, 0, NULL, NULL From Dual Union All
Select  '44', To_Date('2017-07-05 17:22:56','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9BodyEditorGX.dll', NULL, NULL, '1', 'zl9CISJob.dll', NULL , '部件功能:老版护士工作站中体温单(广西地区适用)系统定位:处理老版护士工作站中体温单相关业务缺失后果:缺失会自动使用标准版体温部件', 1, 0, NULL, NULL From Dual Union All
Select  '45', To_Date('2017-07-05 17:22:56','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9BodyEditorHEN.dll', NULL, NULL, '1', 'zl9CISJob.dll', NULL , '部件功能:老版护士工作站中体温单相关功能(河南地区适用)系统定位:处理老版护士工作站中体温单相关业务缺失后果:缺失会自动使用标准体温单', 1, 0, NULL, NULL From Dual Union All
Select  '46', To_Date('2017-07-05 17:22:56','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9BodyEditorHN.dll', NULL, NULL, '1', 'zl9CISJob.dll', NULL , '部件功能:老版护士工作站中体温单相关功能(河南地区适用)系统定位:处理老版护士工作站中体温单相关业务缺失后果:缺失会自动使用标准体温单', 1, 0, NULL, NULL From Dual Union All
Select  '47', To_Date('2017-07-05 17:22:56','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9BodyEditorHun.dll', NULL, NULL, '1', 'zl9CISJob.dll', NULL , '部件功能:老版护士工作站中体温单相关功能(湖南省通适用)系统定位:处理老版护士工作站中体温单相关业务缺失后果:缺失会自动使用标准体温单', 1, 0, NULL, NULL From Dual Union All
Select  '48', To_Date('2017-07-05 17:22:56','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9BodyEditorQD.dll', NULL, NULL, '1', 'zl9CISJob.dll', NULL , '部件功能:老版护士工作站中体温单相关功能(青岛地区适用)系统定位:处理老版护士工作站中体温单相关业务缺失后果:缺失会自动使用标准体温单', 1, 0, NULL, NULL From Dual Union All
Select  '49', To_Date('2017-07-05 17:22:56','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9BodyEditorSCDQ.dll', NULL, NULL, '1', 'zl9CISJob.dll', NULL , '部件功能:老版护士工作站中体温单相关功能(四川地区通用)系统定位:处理老版护士工作站中体温单相关业务缺失后果:缺失会自动使用标准体温单', 1, 0, NULL, NULL From Dual Union All
Select  '50', To_Date('2017-07-05 17:22:57','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9BodyEditorSXHZ.dll', NULL, NULL, '1', 'zl9CISJob.dll', NULL , '部件功能:老版护士工作站中体温单相关功能(陕西省汉中市适用)系统定位:处理老版护士工作站中体温单相关业务缺失后果:缺失会自动使用标准体温单', 1, 0, NULL, NULL From Dual Union All
Select  '51', To_Date('2017-07-05 17:22:57','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9BodyEditorSxet.dll', NULL, NULL, '1', 'zl9CISJob.dll', NULL , '部件功能:老版护士工作站中体温单相关功能(陕西西安儿童医院适用)系统定位:处理老版护士工作站中体温单相关业务缺失后果:缺失会自动使用标准体温单', 1, 0, NULL, NULL From Dual Union All
Select  '52', To_Date('2017-07-05 17:22:57','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9BodyEditorYDEY.dll', NULL, NULL, '1', 'zl9CISJob.dll', NULL , '部件功能:老版护士工作站中体温单相关功能(医大二院适用)系统定位:处理老版护士工作站中体温单相关业务缺失后果:缺失会自动使用标准体温单', 1, 0, NULL, NULL From Dual Union All
Select  '53', To_Date('2017-07-05 17:22:57','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9BodyEditorYX.dll', NULL, NULL, '1', 'zl9CISJob.dll', NULL , '部件功能:老版护士工作站中体温单相关功能(云南省玉溪市人民医院适用)系统定位:处理老版护士工作站中体温单相关业务缺失后果:缺失会自动使用标准体温单', 1, 0, NULL, NULL From Dual Union All
Select  '54', To_Date('2017-07-05 17:22:57','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9CISAudit.dll', NULL, NULL, '1', NULL, NULL , '部件功能:电子病案审查归档系统定位:包含模块：病案评分标准、病案审查标准、电子病案审查、电子病案借阅、电子病案评分、病历质量查阅、电子病案接收；以电子病历质控为核心业务的应用模块集中于该部件中。缺失后果:质控相关模块窗口无法使用。', 1, 0, NULL, NULL From Dual Union All
Select  '55', To_Date('2017-07-05 17:22:57','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9CISBase.dll', NULL, NULL, '1', 'zl9CISAudit.dll,zl9InExse.DLL,zl9LisWork.dll,zl9PACSWork.dll,zl9Oper.dll,zl9CISBase.dll,zl9Blood.dll,zl9CISJob.dll', NULL , '部件功能:临床基础部件系统定位:设置药品目录，诊疗项目及相关，检查、检验、影像等相关基础数据缺失后果:无法设置药品目录，诊疗项目及相关，检查、检验、影像等相关基础数据', 1, 0, NULL, NULL From Dual Union All
Select  '56', To_Date('2017-07-05 17:22:57','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9CISJob.dll', NULL, NULL, '1', 'Zl9DrugStore.dll', NULL , '部件功能:临床工作站框架部件系统定位:住院医生站，住院护士站，新版护士站，老版护士站，老版医技站，电子病案查阅。缺失后果:以上工作站无法使用。', 1, 0, NULL, NULL From Dual Union All
Select  '57', To_Date('2017-07-05 17:22:55','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9CardSquare.dll', NULL, NULL, '1', 'ZL9Peis.dll,zl9PeisManage.dll,zl9RegEvent.dll,zl9Transfusion.dll,zl9Blood.dll,zl9CISAudit.dll,zl9PACSWork.dll,zl9OutExse.dll,zl9Oper.dll,zl9LisWork.dll,ZL9LabWork.dll,zl9InPatient.dll,zl9InExse.DLL,Zl9DrugStore.dll,zl9Patient.dll,zl9CISJob.dll,zl9CardSquare.dll,zl9XWInterface.dll,zl9Stuff.dll,zl9CISBase.dll', NULL , '部件功能:结算卡管理部件系统定位:医疗卡、消费卡管理缺失后果:涉及一卡通的业务无法使用', 1, 0, NULL, NULL From Dual Union All
Select  '58', To_Date('2017-07-05 17:22:53','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 1, 'zl9ComLibpss.dll', NULL, NULL, '26', 'zlWizardStart.exe', NULL , '部件功能:导诊公共函数部件系统定位:提供公共方法函数（和导诊业务无关）缺失后果:系统不能运行', 1, 0, NULL, NULL From Dual Union All
Select  '59', To_Date('2017-07-05 17:22:57','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 1, 'zl9CustAcc.dll', NULL, NULL, '1', 'zl9BaseItem.dll,zl9InExse.DLL,zl9OutExse.dll', NULL , '部件功能:自定义记帐单部件系统定位:专项记帐和专项记账单设置缺失后果:不能使用专项记帐单', 1, 0, NULL, NULL From Dual Union All
Select  '60', To_Date('2017-07-05 17:22:55','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9Device.dll', NULL, NULL, '6', NULL, NULL , '部件功能:管理医院的设备系统定位:既可以独立存在，也可以共享标准系统存在缺失后果:缺少将无法管理设备', 1, 0, NULL, NULL From Dual Union All
Select  '61', To_Date('2017-07-05 17:26:44','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9Disease.dll', NULL, NULL, '1', 'zl9CISJob.dll', NULL , '部件功能:传染病管理系统相关功能系统定位:处理传染病管理系统相关业务缺失后果:无法使用传染病填写、上报相关功能', 1, 0, NULL, NULL From Dual Union All
Select  '62', To_Date('2017-07-05 17:22:55','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9DrawReport.dll', NULL, NULL, '21,24', 'ZL9Peis.dll,zl9PeisManage.dll,zl9Oper.dll', NULL , '部件功能:zl9DrawReport系统定位:实现固定报告格式的打印输出预览缺失后果:不能实现打印输出预览功能', 1, 0, NULL, NULL From Dual Union All
Select  '63', To_Date('2017-07-05 17:22:55','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9Due.dll', NULL, NULL, '1', NULL, NULL , '部件功能:付款管理部件系统定位:医院所有采购商品应付和已付的管理缺失后果:缺少将无法使用付款管理', 1, 0, NULL, NULL From Dual Union All
Select  '64', To_Date('2017-07-05 17:22:54','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 1, 'zl9ESign.dll', NULL, NULL, '1', 'zl9CISJob.dll', NULL , '部件功能:电子签名部件系统定位:集成不同CA厂商的电子签名接口并供各个业务模块调用。缺失后果:各个业务模块将无法启用电子签名功能', 1, 0, NULL, NULL From Dual Union All
Select  '65', To_Date('2017-07-05 17:22:57','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9InExse.DLL', NULL, NULL, '1', 'zl9CISJob.dll,zl9InPatient.dll,zl9OutExse.dll', NULL , '部件功能:住院费用部件系统定位:住院记帐、科室分散记帐、医技科室记帐、自动记帐计算、病人费用查询、费用审核、执行登记、病人结帐处理。缺失后果:住院费用业务不能运行。', 1, 0, NULL, NULL From Dual Union All
Select  '66', To_Date('2017-07-05 17:22:57','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9InPatient.dll', NULL, NULL, '1', 'zl9CISJob.dll,zl9InExse.DLL', NULL , '部件功能:住院病人部件系统定位:实现病人入院登记、病人入出管理、病区床位管理缺失后果:无法完成住院病人登记、病人入出管理、病区床位管理', 1, 0, NULL, NULL From Dual Union All
Select  '67', To_Date('2017-07-05 17:22:59','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9Infect.dll', NULL, NULL, '23', NULL, NULL , '部件功能:院感管理系统核心框架部件系统定位:院感系统核心功能窗体，含：病例监测管理、病例日报管理、人员监测管理、医院感染汇总表缺失后果:无法使用院感系统', 1, 0, NULL, NULL From Dual Union All
Select  '68', To_Date('2017-07-05 17:22:57','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9LCDShow.dll', NULL, NULL, '1', 'zl9Transfusion.dll', NULL , '部件功能:老版排队显示业务封装系统定位:老版排队情况封装缺失后果:不能显示排队情况', 1, 0, NULL, NULL From Dual Union All
Select  '69', To_Date('2017-07-05 17:22:55','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]', 1, 'zl9LabPrintSvr.exe', NULL, NULL, '25,26', 'ZL9LabWork.dll', NULL , '部件功能:新版LIS打印服务系统定位:主要处理 批量打印报告缺失后果:导诊和新版LIS打印报告部分将不能使用', 0, 0, NULL, NULL From Dual Union All
Select  '70', To_Date('2017-07-05 17:22:55','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]', 1, 'zl9LabReceiv.exe', NULL, NULL, '25', 'ZL9LabWork.dll', NULL , '部件功能:新版通讯程序部件系统定位:主要处理与仪器接口之间数据交互缺失后果:不能正常解析仪器数据', 0, 0, '[APPSOFT]\DEV_[*]', NULL From Dual Union All
Select  '71', To_Date('2017-07-05 17:22:55','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]', 1, 'zl9LabTcpSvr.exe', NULL, NULL, '25', 'ZL9LabWork.dll', NULL , '部件功能:新版LIS检验消息转发部件系统定位:处理实验室和通讯程序间的消息转发缺失后果:数据不能正常转发', 0, 0, NULL, NULL From Dual Union All
Select  '72', To_Date('2017-07-05 17:22:57','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 1, 'zl9LedVoice.dll', NULL, NULL, '1', 'zl9RegEvent.dll,zl9CardSquare.dll,zl9InExse.DLL,zl9OutExse.dll,zl9Patient.dll,zl9InPatient.dll', NULL , '部件功能:LED显示、语言报价部件系统定位:向病人显示收费信息缺失后果:不能支持语言半价或者在LED屏显示信息', 1, 0, NULL, NULL From Dual Union All
Select  '73', To_Date('2017-07-05 17:22:57','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9LisQuery_Base.dll', NULL, NULL, '1', 'zl9LisWork.dll', NULL , '部件功能:检验外挂接口部件系统定位:支持检验外挂接口。缺失后果:综合查询外挂不能加载', 1, 0, NULL, NULL From Dual Union All
Select  '74', To_Date('2017-07-05 17:22:57','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 1, 'zl9LisQuery_Dfn.dll', NULL, NULL, '1', 'zl9LisWork.dll', NULL , '部件功能:老版LIS外挂部件系统定位:加载渠道开发的外挂部件缺失后果:不能正常加载外挂', 1, 0, NULL, NULL From Dual Union All
Select  '75', To_Date('2017-07-05 17:22:57','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9LisWork.dll', NULL, NULL, '1', 'zl9CISJob.dll', NULL , '部件功能:老版LIS核心部件。系统定位:处理检验相关操作。包含检验技师工作站、检验采集工作站、检验登记。缺失后果:检验相关业务讲不能正常使用。', 1, 0, NULL, NULL From Dual Union All
Select  '76', To_Date('2017-07-05 17:22:56','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9Material.dll', NULL, NULL, '4', NULL, NULL , '部件功能:管理医院的物资系统定位:既可以独立存在，也可以共享标准系统存在缺失后果:缺少将无法管理物资', 1, 0, NULL, NULL From Dual Union All
Select  '77', To_Date('2017-07-05 17:22:53','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9MedRec.dll', NULL, NULL, '3', NULL, NULL , '部件功能:病案管理事务系统定位:病案系统管理、门诊日报、住院日报功能缺失后果:病案系统、门诊、住院日报功能失效。', 1, 0, NULL, NULL From Dual Union All
Select  '78', To_Date('2017-07-05 17:22:57','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9MediStore.dll', NULL, NULL, '1', NULL, NULL , '部件功能:zlMediStore系统定位:药品流通业务部件，如入库，出库，盘点等业务操作缺失后果:无法进行药品流通业务', 1, 0, NULL, NULL From Dual Union All
Select  '79', To_Date('2017-07-05 17:22:56','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9Oper.dll', NULL, NULL, '24', NULL, NULL , '部件功能:手术麻醉部件系统定位:实现手术安排及相关计费缺失后果:手麻产品不能运行', 1, 0, NULL, NULL From Dual Union All
Select  '80', To_Date('2017-07-05 17:22:56','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9OpsStarand.dll', NULL, NULL, '24', 'zl9Oper.dll', NULL , '部件功能:手术麻醉单打印预览系统定位:生成手术麻醉单，并进行打印或预览缺失后果:不能生成手术麻醉单', 1, 0, NULL, NULL From Dual Union All
Select  '81', To_Date('2017-07-05 17:22:57','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9OutExse.dll', NULL, NULL, '1', 'Zl9DrugStore.dll', NULL , '部件功能:门诊费用部件系统定位:门诊划价、门诊收费、门诊记账缺失后果:缺失上述功能', 1, 0, NULL, NULL From Dual Union All
Select  '82', To_Date('2017-07-05 17:22:57','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9PACSWork.dll', NULL, NULL, '1', NULL, NULL , '部件功能:进行影像系统基本业务处理系统定位:封装了对影像系统基本业务的处理，是业务系统的入库。缺失后果:不能进入对应的影像系统。', 1, 0, NULL, NULL From Dual Union All
Select  '83', To_Date('2017-07-05 17:22:57','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9PacsControl.ocx', NULL, NULL, '1', 'zl9PACSWork.dll', NULL , '部件功能:自定义控件封装系统定位:对常用的控件进行封装缺失后果:进入影像系统将产生异常', 1, 0, NULL, NULL From Dual Union All
Select  '84', To_Date('2017-07-05 17:22:55','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9PacsCore.dll', NULL, NULL, '1', 'zl9PACSWork.dll', NULL , '部件功能:PACS观片处理部件系统定位:查看PACS图像缺失后果:不能进行影像观片', 1, 0, NULL, NULL From Dual Union All
Select  '85', To_Date('2017-07-05 17:22:57','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9Partogram.dll', NULL, NULL, '1', 'zl9CISJob.dll', NULL , '部件功能:产程图管理相关功能系统定位:处理产程图相关业务缺失后果:无法使用产程图展示,编辑,打印功能', 1, 0, NULL, NULL From Dual Union All
Select  '86', To_Date('2017-07-05 17:22:57','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9Patient.dll', NULL, NULL, '1', 'zl9RegEvent.dll,zl9CardSquare.dll,zl9InExse.DLL,zl9OutExse.dll,zl9InPatient.dll', NULL , '部件功能:病人信息管理部件。系统定位:病人信息登记、修改、删除等操作。缺失后果:无法对病人信息进行维护。', 1, 0, NULL, NULL From Dual Union All
Select  '87', To_Date('2017-07-05 17:22:56','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9PeisBase.dll', NULL, NULL, '21', 'ZL9Peis.dll', NULL , '部件功能:体检基础业务系统定位:体检基础数据设置（增删改），包括体检相关的公共或系统参数设置，是体检产品运行必不可少的部件。缺失后果:不能维护体检基础数据；同时体检业务大部份功能也会不正常。', 1, 0, NULL, NULL From Dual Union All
Select  '88', To_Date('2017-07-05 17:22:56','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 1, 'zl9PeisComLib.dll', NULL, NULL, '21', 'ZL9Peis.dll,zl9PeisManage.dll,zl9PeisBase.dll', NULL , '部件功能:体检公共组件系统定位:给体检基础功能和业务功能提供公共的方法函数缺失后果:整个体检产品无法使用。', 1, 0, NULL, NULL From Dual Union All
Select  '89', To_Date('2017-07-05 17:22:56','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9PeisDevAnalyse.dll', NULL, NULL, '21', 'ZL9Peis.dll,zl9PeisManage.dll,zl9PeisBase.dll', NULL , '部件功能:体检非标准串口的接口程序系统定位:定时读取非标准串口仪器所产生的指标结果数据缺失后果:不能接收到非标准串口仪器的指标结果数据', 1, 0, NULL, NULL From Dual Union All
Select  '90', To_Date('2017-07-05 17:22:56','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9PeisFlow.dll', NULL, NULL, '21', 'ZL9Peis.dll,zl9PeisManage.dll,zl9PeisBase.dll', NULL , '部件功能:体检执行业务系统定位:实现体检分科、总检等业务功能缺失后果:体检产品不能使用', 1, 0, NULL, NULL From Dual Union All
Select  '91', To_Date('2017-07-05 17:22:56','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9PeisInnerInterface.dll', NULL, NULL, '21', 'ZL9Peis.dll,zl9PeisManage.dll,zl9PeisBase.dll', NULL , '部件功能:体检内部接口系统定位:实现费用、排队叫号、医嘱、票据等的数据交换缺失后果:体检产品不能正确运行', 1, 0, NULL, NULL From Dual Union All
Select  '92', To_Date('2017-07-05 17:22:56','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9PeisInstrument.dll', NULL, NULL, '21', 'ZL9Peis.dll,zl9PeisManage.dll,zl9PeisBase.dll', NULL , '部件功能:体检基本仪器数据接口系统定位:完成体检基本仪器数据传输接口缺失后果:不能接收到身高体重仪等基本仪器数据', 1, 0, NULL, NULL From Dual Union All
Select  '93', To_Date('2017-07-05 17:22:56','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9PeisInterface.dll', NULL, NULL, '21', 'ZL9Peis.dll,zl9PeisManage.dll,zl9PeisBase.dll', NULL , '部件功能:第三方体检接口部件系统定位:实现三方体检和ZLHIS的数据交换缺失后果:不能实现三方体检和ZLHIS的接口', 1, 0, NULL, NULL From Dual Union All
Select  '94', To_Date('2017-07-05 17:22:56','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9PeisManage.dll', NULL, NULL, '21', 'ZL9Peis.dll', NULL , '部件功能:体检管理业务系统定位:实现体检登记、报到、填写结果、打印报告、指引单等业务缺失后果:体检产品不能使用。', 1, 0, NULL, NULL From Dual Union All
Select  '95', To_Date('2017-07-05 17:22:56','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9PeisPersonPDF.dll', NULL, NULL, '21', 'ZL9Peis.dll,zl9PeisManage.dll,zl9PeisBase.dll', NULL , '部件功能:体检报告PDF输出接口系统定位:体检报告打印三方生成的PDF文件缺失后果:不能完整输出体检报告内容', 1, 0, NULL, NULL From Dual Union All
Select  '96', To_Date('2017-07-05 17:22:56','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9PeisPersonReport.dll', NULL, NULL, '21', 'ZL9Peis.dll,zl9PeisManage.dll,zl9PeisBase.dll', NULL , '部件功能:体检个人报告自定义报表系统定位:体检报告中需要调用自定义报表进行打印缺失后果:体检报告中自定义报表时不能输出完整的体检报告', 1, 0, NULL, NULL From Dual Union All
Select  '97', To_Date('2017-07-05 17:22:56','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9PeisPersonRpt.dll', NULL, NULL, '21', 'ZL9Peis.dll,zl9PeisManage.dll,zl9PeisBase.dll', NULL , '部件功能:个人体检报告输出系统定位:按固定的格式生成报告打印数据缺失后果:不能输出个人体检报告', 1, 0, NULL, NULL From Dual Union All
Select  '98', To_Date('2017-07-05 17:22:56','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9PeisRpt.dll', NULL, NULL, '21', 'ZL9Peis.dll,zl9PeisManage.dll,zl9PeisBase.dll', NULL , '部件功能:体检报告格式系统定位:个人体检报告的内容生成缺失后果:不能生成报告内容', 1, 0, NULL, NULL From Dual Union All
Select  '99', To_Date('2017-07-05 17:22:56','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9Purvey.dll', NULL, NULL, '4', 'zl9Material.dll', NULL , '部件功能:管理供应室的器械包系统定位:属于物资系统的子系统缺失后果:缺少将无法管理器械包', 1, 0, NULL, NULL From Dual Union All
Select '100', To_Date('2017-07-05 17:22:57','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9RecipeAudit.dll', NULL, NULL, '1', 'zl9CISJob.dll', NULL , '部件功能:药剂师对门诊和住院的用药处方审查系统定位:控制有问题的处方，提升处方合格率缺失后果:缺少将无法使用处方审查系统', 1, 0, NULL, NULL From Dual Union All
Select '101', To_Date('2017-07-05 17:22:57','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9RegEvent.dll', NULL, NULL, '1', 'zl9CISJob.dll,zl9OutExse.dll', NULL , '部件功能:门诊挂号部件系统定位:设置挂号安排和临床出诊，提供挂号、预约、分诊等功能，提供患者服务中心对病人预约进行管理缺失后果:与挂号相关的功能不能使用', 1, 0, NULL, NULL From Dual Union All
Select '102', To_Date('2017-07-05 17:22:57','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9Stuff.dll', NULL, NULL, '1', 'Zl9DrugStore.dll', NULL , '部件功能:zl9Stuff系统定位:卫材业务部件，包括卫材目录，卫材入出流通管理，卫材发放管理等缺失后果:不能开展卫材流通，发放等业务', 1, 0, NULL, NULL From Dual Union All
Select '103', To_Date('2017-07-05 17:22:57','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9TemperatureChart.dll', NULL, NULL, '1', 'zl9CISJob.dll', NULL , '部件功能:新版护士工作站体温单相关功能(标准体温单,未启用地区性体温单时均使用此体温单)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:无法进行体温单的展示和数据编辑功能', 1, 0, NULL, NULL From Dual Union All
Select '104', To_Date('2017-07-05 17:22:57','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9TemperatureChartGD.dll', NULL, NULL, '1', 'zl9CISJob.dll', NULL , '部件功能:新版护士工作站体温单相关功能(广东省地区适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单', 1, 0, NULL, NULL From Dual Union All
Select '105', To_Date('2017-07-05 17:22:58','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9TemperatureChartGS.dll', NULL, NULL, '1', 'zl9CISJob.dll', NULL , '部件功能:新版护士工作站体温单相关功能(甘肃中医院适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单', 1, 0, NULL, NULL From Dual Union All
Select '106', To_Date('2017-07-05 17:22:58','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9TemperatureChartGX.dll', NULL, NULL, '1', 'zl9CISJob.dll', NULL , '部件功能:新版护士工作站体温单相关功能(广西省适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单', 1, 0, NULL, NULL From Dual Union All
Select '107', To_Date('2017-07-05 18:50:52','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9TemperatureChartGZJX.dll', NULL, NULL, '1', 'zl9CISJob.dll', NULL , '部件功能:新版护士工作站体温单相关功能(广州揭西适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单', 1, 0, NULL, NULL From Dual Union All
Select '108', To_Date('2017-07-05 18:50:52','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9TemperatureChartHLJ.dll', NULL, NULL, '1', 'zl9CISJob.dll', NULL , '部件功能:新版护士工作站体温单相关功能(黑龙江地区适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单', 1, 0, NULL, NULL From Dual Union All
Select '109', To_Date('2017-07-05 17:22:58','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9TemperatureChartHnnx.dll', NULL, NULL, '1', 'zl9CISJob.dll', NULL , '部件功能:新版护士工作站体温单相关功能(湖南宁乡人民医院适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单', 1, 0, NULL, NULL From Dual Union All
Select '110', To_Date('2017-07-05 18:50:52','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9TemperatureChartJX.dll', NULL, NULL, '1', 'zl9CISJob.dll', NULL , '部件功能:新版护士工作站体温单相关功能(江西省适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单', 1, 0, NULL, NULL From Dual Union All
Select '111', To_Date('2017-07-05 17:22:58','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9TemperatureChartNJ.dll', NULL, NULL, '1', 'zl9CISJob.dll', NULL , '部件功能:新版护士工作站体温单相关功能(江苏地区适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单', 1, 0, NULL, NULL From Dual Union All
Select '112', To_Date('2017-07-05 17:22:58','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9TemperatureChartS3201.dll', NULL, NULL, '1', 'zl9CISJob.dll', NULL , '部件功能:新版护士工作站体温单相关功能(陕西3201医院适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温部件', 1, 0, NULL, NULL From Dual Union All
Select '113', To_Date('2017-07-05 17:22:58','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9TemperatureChartSC.dll', NULL, NULL, '1', 'zl9CISJob.dll', NULL , '部件功能:新版护士工作站体温单相关功能(四川地区通用体温部件)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单', 1, 0, NULL, NULL From Dual Union All
Select '114', To_Date('2017-07-05 17:22:58','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9TemperatureChartSCZG.dll', NULL, NULL, '1', 'zl9CISJob.dll', NULL , '部件功能:新版护士工作站体温单相关功能(四川自贡市适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单', 1, 0, NULL, NULL From Dual Union All
Select '115', To_Date('2017-07-05 17:22:58','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9TemperatureChartSX.dll', NULL, NULL, '1', 'zl9CISJob.dll', NULL , '部件功能:新版护士工作站体温单相关功能(山西地区适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单', 1, 0, NULL, NULL From Dual Union All
Select '116', To_Date('2017-07-05 17:22:58','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9TemperatureChartYDEY.dll', NULL, NULL, '1', 'zl9CISJob.dll', NULL , '部件功能:新版护士工作站体温单相关功能(医大二院适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单', 1, 0, NULL, NULL From Dual Union All
Select '117', To_Date('2017-07-05 17:22:55','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9TendFile.dll', NULL, NULL, '1', 'zl9CISAudit.dll,zl9CISJob.dll,zl9Oper.dll', NULL , '部件功能:处理护士工作站记录单相关业务系统定位:护士工作站中记录单相关业务流程缺失后果:无法在护士工作站中进行记录单的查看和操作', 1, 0, NULL, NULL From Dual Union All
Select '118', To_Date('2017-07-05 17:22:58','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9Transfusion.dll', NULL, NULL, '1', NULL, NULL , '部件功能:门诊输液系统部件系统定位:处理门诊输液执行、附费相关业务缺失后果:无法使用门诊输液工作站', 1, 0, NULL, NULL From Dual Union All
Select '119', To_Date('2017-07-05 17:22:53','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9WizardCards.dll', NULL, NULL, '26', 'zlWizardStart.exe', NULL , '部件功能:自助发卡与签约系统定位:提供自助设备上进行发卡和绑定卡操作缺失后果:自助发卡与签约功能缺失', 1, 0, NULL, NULL From Dual Union All
Select '120', To_Date('2017-07-05 17:22:53','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 1, 'zl9WizardControl.ocx', NULL, NULL, '26', 'zlWizardStart.exe', NULL , '部件功能:提供自助系统所需要的控件系统定位:完成自助系统的控件统一效果及功能实现缺失后果:不能运行自助系统并报错', 1, 0, NULL, NULL From Dual Union All
Select '121', To_Date('2017-07-05 17:22:53','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9WizardDeposit.dll', NULL, NULL, '26', 'zlWizardStart.exe', NULL , '部件功能:自助充值管理系统定位:提供门诊预交和住院预交以及历史充值记录查询缺失后果:自助充值及查询功能缺失', 1, 0, NULL, NULL From Dual Union All
Select '122', To_Date('2017-07-05 17:22:53','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9WizardEMR.dll', NULL, NULL, '26', 'zlWizardStart.exe', NULL , '部件功能:zl9WizardEMR系统定位:门诊电子病历缺失后果:无法使用自助服务系统门诊电子病历相关功能', 1, 0, NULL, NULL From Dual Union All
Select '123', To_Date('2017-07-05 17:22:53','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9WizardFeeQuery.dll', NULL, NULL, '26', 'zlWizardStart.exe', NULL , '部件功能:自助费用查询系统定位:自助设备上查询病人门诊和住院费用缺失后果:自助费用查询功能缺失', 1, 0, NULL, NULL From Dual Union All
Select '125', To_Date('2017-07-05 17:22:53','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9WizardInvoice.dll', NULL, NULL, '26', 'zlWizardStart.exe', NULL , '部件功能:自助票据打印系统定位:自助设备上对未打印票据的缴费和挂号单据打印票据缺失后果:挂号和收费票据打印功能缺失', 1, 0, NULL, NULL From Dual Union All
Select '126', To_Date('2017-07-05 17:22:53','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9WizardLABCall.dll', NULL, NULL, '26', 'zlWizardStart.exe', NULL , '部件功能:zl9WizardLABCall系统定位:检验叫号缺失后果:暂无', 1, 0, NULL, NULL From Dual Union All
Select '127', To_Date('2017-07-05 17:22:53','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9WizardLabPrint.dll', NULL, NULL, '25', 'zlWizardStart.exe', NULL , '部件功能:导诊打印老版LIS报告系统定位:在导诊系统中，打印老版LIS相关报告缺失后果:不能正常打印老版LIS报告', 1, 0, NULL, NULL From Dual Union All
Select '128', To_Date('2017-07-05 17:22:53','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 1, 'zl9WizardLib.dll', NULL, NULL, '26', 'zlWizardStart.exe', NULL , '部件功能:病人自助系统公共库系统定位:提供自助系统中需要使用的方法函数缺失后果:系统不能运行', 1, 0, NULL, NULL From Dual Union All
Select '129', To_Date('2017-07-05 17:22:53','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]', 1, 'zl9WizardMain.exe', NULL, NULL, '26', NULL, NULL , '部件功能:病人自助系统后台管理程序系统定位:完成自助系统的所有后台设置，包括资源配置、动态页面设计、静态页面参数等缺失后果:系统不能正常运行', 0, 0, NULL, NULL From Dual Union All
Select '130', To_Date('2017-07-05 17:22:53','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9WizardManage.dll', NULL, NULL, '26', 'zl9WizardMain.exe', NULL , '部件功能:自助系统后台管理系统定位:配置自助系统的资源、页面、参数等缺失后果:不能启动后台管理', 1, 0, NULL, NULL From Dual Union All
Select '131', To_Date('2017-07-05 17:22:53','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9WizardPage.dll', NULL, NULL, '26', 'zlWizardStart.exe', NULL , '部件功能:自助动态页面显示系统定位:根据动态页面的设计显示最终的页面展示效果缺失后果:自助系统不能使用', 1, 0, NULL, NULL From Dual Union All
Select '132', To_Date('2017-07-05 17:22:53','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9WizardPayFee.dll', NULL, NULL, '26', 'zlWizardStart.exe', NULL , '部件功能:自助缴费管理系统定位:自助设备上对划价单据进行缴费缺失后果:自助缴费功能缺失', 1, 0, NULL, NULL From Dual Union All
Select '133', To_Date('2017-07-05 17:22:53','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9WizardPeisQueue.dll', NULL, NULL, '26', 'zlWizardStart.exe', NULL , '部件功能:体检自助排队系统定位:体检人员通过病人自助系统提供体检自助排队功能进行自助体检排队缺失后果:体检人员无法自助排队', 1, 0, NULL, NULL From Dual Union All
Select '134', To_Date('2017-07-05 17:26:44','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9WizardPharmacy.dll', NULL, NULL, '26', 'zlWizardStart.exe', NULL , '部件功能:自助系统中的门诊药房病人签到管理系统定位:作为自助系统的一部分存在缺失后果:缺少将无法使用门诊药房签到', 1, 0, NULL, NULL From Dual Union All
Select '135', To_Date('2017-07-05 17:22:53','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9WizardPrice.dll', NULL, NULL, '26', 'zlWizardStart.exe', NULL , '部件功能:提供收费项目的价格自助查询系统定位:通过简码等实现收费项目价格的自助查询缺失后果:不能自助查询价格', 1, 0, NULL, NULL From Dual Union All
Select '136', To_Date('2017-07-05 17:22:53','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9WizardProficient.dll', NULL, NULL, '26', 'zlWizardStart.exe', NULL , '部件功能:实现医院专家介绍自助查询系统定位:实现医院专家介绍自助查询缺失后果:不能实现专家介绍查询', 1, 0, NULL, NULL From Dual Union All
Select '137', To_Date('2017-07-05 17:22:53','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9WizardProof.dll', NULL, NULL, '26', 'zlWizardStart.exe', NULL , '部件功能:自助凭条打印系统定位:自助设备上打印缴费和挂号凭条缺失后果:缴费和挂号凭条打印功能缺失', 1, 0, NULL, NULL From Dual Union All
Select '138', To_Date('2017-07-05 17:22:53','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9WizardRegEvent.dll', NULL, NULL, '26', 'zlWizardStart.exe', NULL , '部件功能:自助挂号和预约系统定位:自助设备上病人进行挂号和预约以及取号缺失后果:挂号和预约以及取号功能缺失，今日就诊也不能进行挂号', 1, 0, NULL, NULL From Dual Union All
Select '139', To_Date('2017-07-05 17:22:53','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9WizardToday.dll', NULL, NULL, '26', 'zlWizardStart.exe', NULL , '部件功能:今日就诊系统定位:查询挂号安排，进行挂号/预约，查看挂号科室上班时间缺失后果:挂号、预约以及查询功能缺失', 1, 0, NULL, NULL From Dual Union All
Select '140', To_Date('2017-07-05 17:22:55','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 1, 'zl9keyboard.dll', NULL, NULL, '1', 'zl9RegEvent.dll,zl9CardSquare.dll,zl9Patient.dll,zl9InPatient.dll', NULL , '部件功能:密码键盘部件系统定位:使用密码键盘设备缺失后果:密码键盘无法使用', 1, 0, NULL, NULL From Dual Union All
Select '141', To_Date('2017-07-05 17:22:56','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zl9peisgrouprpt.dll', NULL, NULL, '21', 'ZL9Peis.dll,zl9PeisManage.dll,zl9PeisBase.dll', NULL , '部件功能:体检团体报告预览及打印输出。系统定位:实现体检团体报告预览及打印输出。缺失后果:不能实现团体报告预览及打印输出', 1, 0, NULL, NULL From Dual Union All
Select '142', To_Date('2017-07-05 17:22:55','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zlCISKernel.dll', NULL, NULL, '1,22,24,25', 'zl9CISAudit.dll,zl9InExse.DLL,zl9LisWork.dll,zl9PACSWork.dll,zl9Oper.dll,zl9CISBase.dll,zl9Blood.dll', NULL , '部件功能:临床核心部件，提供医嘱相关操作封装等接口，提供DOCK页签等。系统定位:提供医嘱核功能缺失后果:临床医嘱相关功能丢失，各大工作站的医嘱信息页签丢失。', 1, 0, NULL, NULL From Dual Union All
Select '143', To_Date('2017-07-05 17:22:58','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zlCISPath.dll', NULL, NULL, '1', 'zl9CISAudit.dll,zl9CISJob.dll', NULL , '部件功能:临床路径部件系统定位:临床路径应用、临床路径管理、临床路径跟踪缺失后果:临床路径应用、临床路径管理、临床路径跟踪将无法正常运行', 1, 0, NULL, NULL From Dual Union All
Select '144', To_Date('2017-07-05 17:22:58','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zlCisAuditPrint.EXE', NULL, NULL, '1', 'zl9CISAudit.dll', NULL , '部件功能:用于电子病案审查中,文件-输出到PDF系统定位:避免连续PDF输出引起系统GDI超量，导致系统假死缺失后果:无法进行PDF输出', 1, 0, NULL, NULL From Dual Union All
Select '145', To_Date('2017-07-05 17:22:58','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zlDisReportCard.DLL', NULL, NULL, '1', 'zl9Disease.dll', NULL , '部件功能:传染病固定格式报告卡控件系统定位:用于填写传染病报告卡缺失后果:无法使用固定格式传染病报告卡', 1, 0, NULL, NULL From Dual Union All
Select '146', To_Date('2017-07-05 17:22:58','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zlGetImage.exe', NULL, NULL, '1', 'zl9PACSWork.dll', NULL , '部件功能:提供影像检查图像下载支持系统定位:后台下载影像检查图像缺失后果:不能观片', 0, 0, NULL, NULL From Dual Union All
Select '147', To_Date('2017-07-05 17:22:55','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zlLISDev.dll', NULL, NULL, '1,25', 'zlWizardStart.exe,zl9LisWork.dll,ZL9LabWork.dll', NULL , '部件功能:处理检验仪器的数据、图片解析系统定位:让仪器数据，能够保存为我们认识的检验结果。缺失后果:检验仪器数据将不能正常解析到我们系统。', 1, 0, NULL, NULL From Dual Union All
Select '148', To_Date('2017-07-05 17:22:58','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zlLISInterface.DLL', NULL, NULL, '1', 'zl9LisWork.dll', NULL , '部件功能:三方检验接口部件系统定位:支持三方检验接入到HIS系统中缺失后果:三方检验不能正常接入到his系统，该部件未正常发布。', 1, 0, NULL, NULL From Dual Union All
Select '149', To_Date('2017-07-05 18:50:52','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]', 1, 'zlLisMessage.exe', NULL, NULL, '25', 'ZL9LabWork.dll', NULL , '部件功能:LIS消息部件系统定位:在大屏幕上显示某些检验科内部的情况缺失后果:无法再大屏幕上显示检验科内部的情况', 0, 0, NULL, NULL From Dual Union All
Select '150', To_Date('2017-07-05 17:22:58','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]', 1, 'zlLisReceiveSend.exe', NULL, NULL, '1', 'zl9LisWork.dll', NULL , '部件功能:主要与检验仪器直接通讯系统定位:记录仪器回传的检验结果，并保存文本为LIS认识的检验结果。缺失后果:如果缺失,老版LIS将不能正常解析检验数据', 0, 0, NULL, NULL From Dual Union All
Select '151', To_Date('2017-07-05 17:22:54','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 1, 'zlMedRecPage.dll', NULL, NULL, '1', 'zl9CISJob.dll,zl9MedRec.dll', NULL , '部件功能:住院首页、病案首页程序系统定位:处理病人住院首页、病案首页相关业务缺失后果:临床工作站、病案系统等业务模块无法使用', 1, 0, NULL, NULL From Dual Union All
Select '152', To_Date('2017-07-05 17:22:56','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zlOperInterface.dll', NULL, NULL, '24', 'zl9Oper.dll', NULL , '部件功能:三方手麻软件接口ZLHIS系统定位:实现三方手麻产品和ZLHIS产品之间的功能接口缺失后果:无法实现和ZLHIS的数据交换。', 1, 0, NULL, NULL From Dual Union All
Select '153', To_Date('2017-07-05 17:22:56','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 1, 'zlPacsVBCommon.dll', NULL, NULL, '1', 'zl9PACSWork.dll', NULL , '部件功能:封装zlpacs与pacs智能报告编辑器之间的数据交换系统定位:zlpacs整合pacs智能报告编辑器缺失后果:不能使用pacs智能报告编辑器', 1, 0, NULL, NULL From Dual Union All
Select '154', To_Date('2017-07-05 17:22:56','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 1, 'zlPassInterface.dll', NULL, NULL, '1', 'zl9CISJob.dll', NULL , '部件功能:合理用药监测部件：集成了美康、大通、太元通、药卫士等合理用药监测接口。系统定位:供临床医生工作站、药品发药组件调用。缺失后果:合理用药监测功能无法启用。', 1, 0, NULL, NULL From Dual Union All
Select '155', To_Date('2017-07-05 17:22:56','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]', 1, 'zlPeisAutoAnalyse.exe', NULL, NULL, '21', 'ZL9Peis.dll,zl9PeisManage.dll,zl9PeisBase.dll', NULL , '部件功能:体检自动分析服务系统定位:实现非标准的仪器数据接口缺失后果:不能接收到非标准串口的体检仪器数据', 0, 0, NULL, NULL From Dual Union All
Select '156', To_Date('2017-07-05 17:22:55','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 1, 'zlPictureEditor.dll', NULL, NULL, '1', 'ZL9Peis.dll,zl9PeisManage.dll,zlWizardStart.exe,zl9Blood.dll,zl9CISJob.dll,zl9PACSWork.dll,zl9Oper.dll,zl9LisWork.dll,zl9Disease.dll,zl9CISAudit.dll', NULL , '部件功能:用于对图片进行压缩处理系统定位:在病历标记图管理、电子病历编辑、保存过程中对图片进行压缩处理，以便优化处理后存入数据库缺失后果:因固定引用，缺少将无法使用电子病历所有模块', 1, 0, NULL, NULL From Dual Union All
Select '157', To_Date('2017-07-05 17:22:54','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 1, 'zlPublicAdvice.dll', NULL, NULL, '1,21,22,24,25', 'zl9CISJob.dll', NULL , '部件功能:封装医嘱核心业务功能，提供公共接口，DOCK页签等。系统定位:封装工作站和医嘱核心业务功能缺失后果:通过该部件去使用临床功能会报错或者失效。', 1, 0, NULL, NULL From Dual Union All
Select '159', To_Date('2017-07-05 17:22:54','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 1, 'zlPublicExpense.dll', NULL, NULL, '1', 'zl9InExse.DLL,zl9OutExse.dll', NULL , '部件功能:费用公共部件。系统定位:提供医生站预约、挂号，医嘱附费等功能，提供公共接口。缺失后果:费用相关功能无法使用', 1, 0, NULL, NULL From Dual Union All
Select '158', To_Date('2017-07-05 17:22:54','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 1, 'zlPacsRichPages.ocx', NULL, NULL, '1', 'zlPublicPacs.dll', NULL , '部件功能:封装pacs智能文档编辑器相关处理。系统定位:使用Pacs智能文档编辑器编辑需要。缺失后果:不能使用pacs智能文档编辑器', 1, 0, NULL, NULL From Dual Union All
Select '160', To_Date('2017-07-05 17:22:54','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 1, 'zlPublicLIS.dll', NULL, NULL, '25', 'ZL9LabWork.dll', NULL , '部件功能:检验公共部件系统定位:检验业务中的公共部件。主要处理检验相关的业务缺失后果:目前影响输血申请单的使用', 1, 0, NULL, NULL From Dual Union All
Select '161', To_Date('2017-07-05 17:22:54','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 1, 'zlPublicPacs.dll', NULL, NULL, '1', 'zl9PACSWork.dll', NULL , '部件功能:封装PACS依赖业务调用接口系统定位:调用pacs相关的处理功能缺失后果:如临床不能进行pacs观片等', 1, 0, NULL, NULL From Dual Union All
Select '162', To_Date('2017-07-05 17:22:54','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 1, 'zlPublicPath.dll', NULL, NULL, '1', 'zl9CISJob.dll', NULL , '部件功能:临床路径公共接口部件系统定位:提供临床路径开放接口缺失后果:临床路径功能无法正常运行', 1, 0, NULL, NULL From Dual Union All
Select '163', To_Date('2017-07-05 17:22:54','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 1, 'zlPublicPatient.dll', NULL, NULL, '1', 'zl9CISJob.dll,zl9Patient.dll,zl9InPatient.dll', NULL , '部件功能:病人信息公共部件,封装了病人信息相关的公共方法：病人基本信息调整、身份证号反算年龄等。系统定位:供各个业务模块调用。如首页、病人信息管理、病人入院管理的基本信息调整功能。缺失后果:程序无法正常运行', 1, 0, NULL, NULL From Dual Union All
Select '164', To_Date('2017-07-05 17:22:54','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 1, 'zlPublicPeis.dll', NULL, NULL, '21', 'ZL9Peis.dll,zl9PeisManage.dll', NULL , '部件功能:体检公共接口系统定位:提供其他业务或三方调用体检功能的接口（如生成PDF，查阅体检报告）缺失后果:该接口不能正常工作。', 1, 0, NULL, NULL From Dual Union All
Select '165', To_Date('2017-07-05 17:22:55','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zlQueueManage.dll', NULL, NULL, '1', 'ZL9Peis.dll,zl9PeisManage.dll,zl9RegEvent.dll,zlWizardStart.exe,zl9CISJob.dll,zl9Transfusion.dll', NULL , '部件功能:老板排队业务封装系统定位:老板排队支持缺失后果:不能进行排队管理', 1, 0, NULL, NULL From Dual Union All
Select '166', To_Date('2017-07-05 17:22:56','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 1, 'zlQueueOper.ocx', NULL, NULL, '1', 'zl9Oper.dll,zl9PACSWork.dll', NULL , '部件功能:排队叫号业务封装系统定位:pacs排队管理支持缺失后果:不能进行排队操作', 1, 0, NULL, NULL From Dual Union All
Select '167', To_Date('2017-07-05 17:22:58','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\ZLQUEUESHOW', 1, 'zlQueueShow.exe', NULL, NULL, '1', NULL, NULL , '部件功能:新版排队显示系统定位:pacs排队情况显示缺失后果:不能显示pacs排队状态', 0, 0, NULL, NULL From Dual Union All
Select '168', To_Date('2017-07-05 18:50:52','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zlRISDumpTool.exe', NULL, NULL, '1', NULL, NULL , '部件功能:基础数据，用户，诊疗项目，数据字典等初始化系统定位:初始化ris接口数据缺失后果:不能使用ris系统。', 0, 0, NULL, NULL From Dual Union All
Select '169', To_Date('2017-07-05 17:22:55','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zlRichEPR.DLL', NULL, NULL, '1', 'ZL9Peis.dll,zl9PeisManage.dll,zlWizardStart.exe,zl9Blood.dll,zl9CISJob.dll,zl9PACSWork.dll,zl9Oper.dll,zl9LisWork.dll,zl9Disease.dll,zl9CISAudit.dll,zl9Disease.dll', NULL , '部件功能:病历编辑窗口及业务处理程序系统定位:提供模块：病历标记图形管理、护理记录项目管理、病历文件管理、病历范文管理、诊疗单据设置、移动护士站基础设置、病人病历检索、疾病申报管理缺失后果:病历相关业务无法开展，医生工作站因直接引用，将无法打开。', 1, 0, NULL, NULL From Dual Union All
Select '170', To_Date('2017-07-05 17:22:55','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 1, 'zlRichEditor.ocx', NULL, NULL, '1', 'ZL9Peis.dll,zl9PeisManage.dll,zlWizardStart.exe,zl9Blood.dll,zl9CISJob.dll,zl9PACSWork.dll,zl9Oper.dll,zl9LisWork.dll,zl9Disease.dll,zl9CISAudit.dll,zl9Disease.dll', NULL , '部件功能:病历编辑核心部件系统定位:提供病历编辑、打印输出功能缺失后果:无法编辑、打印病历', 1, 0, NULL, NULL From Dual Union All
Select '171', To_Date('2017-07-05 17:22:58','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zlScreenKeyboard.exe', NULL, NULL, '1', 'zl9CISJob.dll', NULL , '部件功能:屏幕键盘小程序系统定位:在门诊医生工作站中用到，强制续诊，门诊医嘱下达缺失后果:强制续诊，门诊医嘱下达不能用使用键盘功能。', 1, 0, NULL, NULL From Dual Union All
Select '172', To_Date('2017-07-05 17:22:55','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 1, 'zlSubclass.ocx', NULL, NULL, '1', 'ZL9Peis.dll,zl9PeisManage.dll,zlWizardStart.exe,zl9Blood.dll,zl9CISJob.dll,zl9PACSWork.dll,zl9Oper.dll,zl9LisWork.dll,zl9Disease.dll,zl9CISAudit.dll,zl9Disease.dll', NULL , '部件功能:鼠标、键盘勾子系统定位:用于向病历编辑相关模块提供鼠标、键盘勾子，以便在病历编辑过程中对界面内容进行鼠标控制、控件原有快捷键屏蔽。缺失后果:无法编辑病历', 1, 0, NULL, NULL From Dual Union All
Select '173', To_Date('2017-07-05 17:22:56','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 1, 'zlSvgProcess.dll', NULL, NULL, '1', 'zl9PACSWork.dll', NULL , '部件功能:svg图像转换使用原因:影像PACS智能报告编辑器检查图像转换缺失后果:不能查看报告图像', 1, 0, NULL, NULL From Dual Union All
Select '174', To_Date('2017-07-05 17:22:53','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zlSwitchEffect.dll', NULL, NULL, '26', 'zlWizardStart.exe', NULL , '部件功能:实现自助页面切换效果系统定位:实现自助页面切换效果缺失后果:自助页面切换时没有切换变换效果，直接切换。', 1, 0, NULL, NULL From Dual Union All
Select '175', To_Date('2017-07-05 17:22:53','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zlSwitchPage.dll', NULL, NULL, '26', 'zlWizardStart.exe', NULL , '部件功能:实现自助页面切换效果系统定位:实现自助页面切换效果缺失后果:没有切换效果', 1, 0, NULL, NULL From Dual Union All
Select '176', To_Date('2017-07-05 17:22:55','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 1, 'zlTable.ocx', NULL, NULL, '1', 'ZL9Peis.dll,zl9PeisManage.dll,zlWizardStart.exe,zl9Blood.dll,zl9CISJob.dll,zl9PACSWork.dll,zl9Oper.dll,zl9LisWork.dll,zl9Disease.dll,zl9CISAudit.dll,zl9Disease.dll', NULL , '部件功能:向病历编辑过程中提供自定义内嵌表格支持系统定位:全文式病历编辑过程中，插入表格后编辑生成对应的表格图，以及后续编辑时再次进行编辑转换、以提供检查报告图组缺失后果:无法进行内嵌表格编辑', 1, 0, NULL, NULL From Dual Union All
Select '177', To_Date('2017-07-05 17:22:55','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zlTableEPR.dll', NULL, NULL, '1', 'ZL9Peis.dll,zl9PeisManage.dll,zlWizardStart.exe,zl9Blood.dll,zl9CISJob.dll,zl9PACSWork.dll,zl9Oper.dll,zl9LisWork.dll,zl9Disease.dll,zl9CISAudit.dll,zl9Disease.dll', NULL , '部件功能:表格式病历核心编辑器系统定位:用于以表格式病历进行编辑的主窗口、表格式病历的打印缺失后果:无法进行表格式病历编辑', 1, 0, NULL, NULL From Dual Union All
Select '178', To_Date('2017-07-05 17:22:53','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zlWizardNewLabPrint.dll', NULL, NULL, '25,26', 'zlWizardStart.exe', NULL , '部件功能:导诊新版LIS打印部件系统定位:在导诊系统中，进行新版LIS报告打印缺失后果:新版LIS报告将不能正常打印', 1, 0, NULL, NULL From Dual Union All
Select '179', To_Date('2017-07-05 17:22:53','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]\APPLY', 1, 'zlWizardPacsPrint.dll', NULL, NULL, '26', 'zlWizardStart.exe', NULL , '部件功能:pacs报告自助打印系统定位:提供患者自助服务系统支持缺失后果:不能进行pacs自助打印', 1, 0, NULL, NULL From Dual Union All
Select '180', To_Date('2017-07-05 17:22:53','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]', 1, 'zlWizardStart.exe', NULL, NULL, '26', NULL, NULL , '部件功能:自助系统前台查询启动程序系统定位:启动自助系统前台功能缺失后果:不能运行自助系统前台查询', 0, 0, NULL, NULL From Dual Union All
Select '181', To_Date('2017-07-05 17:22:59','yyyy-mm-dd hh24:mi:ss'), '[SYSTEM]', 4, '7Z.DLL', '900200000', To_Date('2011-03-30 11:44:26','yyyy-mm-dd hh24:mi:ss'), NULL, NULL, NULL , '7-ZIP压缩程序', 0, 0, NULL, NULL From Dual Union All
Select '182', To_Date('2017-07-05 17:22:59','yyyy-mm-dd hh24:mi:ss'), '[SYSTEM]', 4, '7Z.EXE', '900200000', To_Date('2011-03-30 11:44:26','yyyy-mm-dd hh24:mi:ss'), NULL, NULL, NULL , '7-ZIP压缩程序', 0, 0, NULL, NULL From Dual Union All
Select '183', To_Date('2017-07-05 17:22:59','yyyy-mm-dd hh24:mi:ss'), '[SYSTEM]', 4, 'AAMD532.DLL', '100000001', To_Date('2011-09-27 11:15:40','yyyy-mm-dd hh24:mi:ss'), NULL, NULL, NULL , '部件功能:三方的MD5计算接口。使用原因:当不能使用VB进行MD5计算时，使用该三方部件进行Md5计算。缺失后果:常规无影响。但是自动升级检查该文件存在性，当不存在时不能自动升级。', 0, 0, NULL, NULL From Dual Union All
Select '184', To_Date('2017-07-05 17:22:54','yyyy-mm-dd hh24:mi:ss'), '[SYSTEM]', 4, 'Codejock.SyntaxEdit.v15.3.1.ocx', NULL, NULL, NULL, NULL, NULL , '部件功能:美化SQL语句使用原因:方便用户使用缺失后果:无法正常升级以及使用自定义过程管理。', 1, 0, NULL, NULL From Dual Union All
Select '185', To_Date('2017-07-05 17:22:55','yyyy-mm-dd hh24:mi:ss'), '[SYSTEM]', 4, 'QRMAKER.OCX', '100310000', To_Date('2013-04-15 14:06:16','yyyy-mm-dd hh24:mi:ss'), NULL, NULL, NULL , '部件功能:输出2D条码使用原因:用户需求缺失后果:体检报告输出不完整', 1, 0, NULL, NULL From Dual Union All
Select '186', To_Date('2017-07-05 18:50:52','yyyy-mm-dd hh24:mi:ss'), '[SYSTEM]', 4, 'SYSTEM.WINDOWS.FORMS.TLB', NULL, NULL, NULL, NULL, NULL , '部件功能:住院一览时间轴控件需要使用原因:缺失后果:', 0, 0, NULL, NULL From Dual Union All
Select '187', To_Date('2017-07-05 18:50:52','yyyy-mm-dd hh24:mi:ss'), '[SYSTEM]', 4, 'System.Windows.Forms.dll', NULL, NULL, NULL, NULL, NULL , '部件功能:住院一览时间轴控件需要使用原因:缺失后果:', 0, 0, NULL, NULL From Dual Union All
Select '188', To_Date('2017-07-05 17:22:54','yyyy-mm-dd hh24:mi:ss'), '[SYSTEM]', 4, 'WINCMP3.EXE', '400022221', To_Date('2010-11-13 18:40:46','yyyy-mm-dd hh24:mi:ss'), NULL, NULL, NULL , NULL, 0, 0, NULL, NULL From Dual Union All
Select '189', To_Date('2017-07-05 18:50:52','yyyy-mm-dd hh24:mi:ss'), '[SYSTEM]', 4, 'WINCMP3.INI', NULL, NULL, NULL, NULL, NULL , NULL, 0, 0, NULL, NULL From Dual Union All
Select '190', To_Date('2017-07-05 17:22:54','yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]', 4, 'ZLRUNAS.exe', NULL, NULL, NULL, NULL, NULL , '该文件在自动升级zlhisCrust.exe中使用。主要功能,在USER权限下可以使用管理员权限来进行登录执行管理操作', 0, 0, NULL, NULL From Dual Union All
Select '191', To_Date('2017-07-05 17:30:05','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 4, 'ZLSoft.BusinessHome.ClientControl.TimeLineBase.dll', NULL, NULL, NULL, NULL, NULL , '部件功能:ZLSoft_BusinessHome_ClientControl_TimeLineBase使用原因:住院工作诊疗一览功能。缺失后果:住院诊疗一览功能不能使用，进入工作站时报错。', 1, 0, NULL, NULL From Dual Union All
Select '192', To_Date('2017-07-05 17:30:05','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 4, 'ZLSoft.BusinessHome.ClientControl.TimeLineBase.tlb', NULL, NULL, NULL, NULL, NULL , '部件功能:ZLSoft_BusinessHome_ClientControl_TimeLineBase使用原因:住院工作诊疗一览功能。缺失后果:住院诊疗一览功能不能使用，进入工作站时报错。', 1, 0, NULL, NULL From Dual Union All
Select '193', To_Date('2017-07-05 17:22:54','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 4, '_sql.schclass', NULL, NULL, NULL, NULL, NULL , 'SyntaxEdit控件SQL颜色方案配置文件。', 0, 0, NULL, NULL From Dual Union All
Select '194', To_Date('2017-07-05 17:26:44','yyyy-mm-dd hh24:mi:ss'), '[SYSTEM]', 4, 'codejock.calendar.v16.3.1.ocx', NULL, NULL, NULL, NULL, NULL , '部件功能:提供日期控件使用原因:使用日期控件缺失后果:程序无法使用', 1, 0, NULL, NULL From Dual Union All
Select '195', To_Date('2017-07-05 17:27:51','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 4, 'gacutil.exe', NULL, NULL, NULL, NULL, NULL , '.net gac注册命令文件', 0, 0, NULL, NULL From Dual Union All
Select '196', To_Date('2017-07-05 17:27:51','yyyy-mm-dd hh24:mi:ss'), '[PUBLIC]', 4, 'gacutil.exe.config', NULL, NULL, NULL, NULL, NULL , '.net gac注册命令文件', 0, 0, NULL, NULL From Dual Union All
Select '197', To_Date('2017-07-05 18:50:52','yyyy-mm-dd hh24:mi:ss'), '[SYSTEM]', 4, 'mscorlib.dll', NULL, NULL, NULL, NULL, NULL , '部件功能:mscorlib.dll使用原因:缺失后果:', 0, 0, NULL, NULL From Dual;

EXECUTE Zlfiles_Autoupdate('7Z.DLL','E3C7BC97672CDEB280DD43F2A69776BB','9.20.0.0',To_Date('2011-03-30 11:44:26', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:59', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'7-ZIP压缩程序',0,0,Null);
EXECUTE Zlfiles_Autoupdate('7Z.EXE','7083BA03D91F9D76CC659F973F14F839','9.20.0.0',To_Date('2011-03-30 11:44:26', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:59', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'7-ZIP压缩程序',0,0,Null);
EXECUTE Zlfiles_Autoupdate('AAMD532.DLL','CEFD956A1EF122CDA4D53007BAB6C694','1.0.0.1',To_Date('2011-09-27 11:15:40', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:59', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'部件功能:三方的MD5计算接口。使用原因:当不能使用VB进行MD5计算时，使用该三方部件进行Md5计算。缺失后果:常规无影响。但是自动升级检查该文件存在性，当不存在时不能自动升级。',0,0,Null);
EXECUTE Zlfiles_Autoupdate('Codejock.SyntaxEdit.v15.3.1.ocx','7010CEB71C0AEAFFE49A16EF5A27E582','15.3.1.0',To_Date('2014-09-10 16:33:04', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:54', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'部件功能:美化SQL语句使用原因:方便用户使用缺失后果:无法正常升级以及使用自定义过程管理。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('QRMAKER.OCX','C00A0B76BC515DAA01060F7F9A230D0D','1.31.0.0',To_Date('2013-04-15 14:06:16', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:55', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'部件功能:输出2D条码使用原因:用户需求缺失后果:体检报告输出不完整',1,0,Null);
EXECUTE Zlfiles_Autoupdate('SYSTEM.WINDOWS.FORMS.TLB','90803CB6E1C454DEE4FD6871035569A4','4.6.1586.0',To_Date('2017-02-06 15:47:30', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 18:50:52', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'部件功能:住院一览时间轴控件需要使用原因:缺失后果:',0,0,Null);
EXECUTE Zlfiles_Autoupdate('System.Windows.Forms.dll','E2D397787188C560BE487028A191A89F','4.6.1586.0',To_Date('2017-02-06 15:47:30', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 18:50:52', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'部件功能:住院一览时间轴控件需要使用原因:缺失后果:',0,0,Null);
EXECUTE Zlfiles_Autoupdate('WINCMP3.EXE','4A8C0E6B9E9537418FAADAB1223376AE','4.2.0.2221',To_Date('2010-11-13 18:40:46', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:54', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,Null,0,0,Null);
EXECUTE Zlfiles_Autoupdate('WINCMP3.INI','5C19E599CAEECC87381FC5EB7DAE4A9F',Null,To_Date('2016-04-14 14:29:00', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 18:50:52', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,Null,0,0,Null);
EXECUTE Zlfiles_Autoupdate('ZL9BillEdit.ocx','CC511060F1C590C24E658AD362D48165','10.35.60',To_Date('2017-07-12 09:24:22', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:54', 'yyyy-mm-dd HH24:mi:ss'),0,'[PUBLIC]',Null,'1,3,4,6,21,22,23,24,25','部件功能:单据编辑控件系统定位:提供表格控件缺失后果:用到此控件的界面不能正常打开，或者报错。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZL9Insure.dll','4FA250AACE755A187E41FA5572EE052B','10.35.60',To_Date('2017-07-12 09:29:24', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:54', 'yyyy-mm-dd HH24:mi:ss'),0,'[PUBLIC]',Null,Null,'部件功能:医保接口部件。使用原因:医保项目检查，医保记帐作废上传缺失后果:重打时出错',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZL9LABWork.dll','4B6104E9F3A5000AB159A1EB5084FA90','10.35.60',To_Date('2017-07-12 10:10:48', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:55', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'25','部件功能:新版LIS核心部件系统定位:处理新版LIS工作站，报告查询等缺失后果:新版LIS将不能正常使用',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZL9LisInsideComm.dll','FC0B80C54403624EA13FDCCC33F87599','10.35.60',To_Date('2017-07-12 10:08:14', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:55', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll,zl9PeisManage.dll,zl9CISAudit.dll,zl9Disease.dll,ZL9LabWork.dll,zl9LisWork.dll,zl9CISJob.dll,zl9Blood.dll','1,25','部件功能:处理新版LIS与HIS之间数据交互系统定位:主要应用于LIS与HIS交互接口部分，以及临床申请单使用。检验申请单设置缺失后果:LIS与HIS的数据将不正常',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZL9PACSIMAGECAP.DLL','1D0F6C6B1A9F74CDB0563192300331F4','10.35.60',To_Date('2017-07-12 10:04:00', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:24:18', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9PACSWork.dll','1','部件功能:提供影像图像的采集与传输系统定位:影像检查图像采集支持缺失后果:影像采集病理系统不能运行。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZL9TEMPERATURECHARTSD.dll','21A12EAC3DD8C4AFF7A97CD405444C49','10.35.60',To_Date('2017-07-12 10:18:16', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:58', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:新版护士工作站体温单相关功能(山东地区适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZL9TemperaTureChartYN.Dll','71461B17E97D2A7982A225ECBECC8754','10.35.60',To_Date('2017-07-12 10:17:08', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:58', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:新版护士工作站体温单相关功能(云南大理专用体温部件)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZL9XWINTERFACE.DLL','983FDC7B82C4D9A6CCBDD11F2C4822C4','10.35.60',To_Date('2017-07-12 10:19:00', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:30:05', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll,zl9PeisManage.dll,zlWizardStart.exe,zl9CISAudit.dll,zl9CISJob.dll,zl9PACSWork.dll,zl9Patient.dll,zl9InPatient.dll,zl9CISBase.dll,zl9BaseItem.dll','1','部件功能:提供ris与his系统数据交换接口系统定位:专业ris系统支持缺失后果:不能使用专业版ris系统',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLDSVIDEOPROCESS.OCX','915B1465C101552783EF186341BDA99A','1.2.74',To_Date('2016-08-03 14:10:50', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:55', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zl9RegEvent.dll,zl9CardSquare.dll,ZL9Peis.dll,zl9PeisManage.dll,zl9PACSWork.dll','1','部件功能:视频采集相关功能封装使用原因:体检人员照片采集缺失后果:不能采集图像和录像',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLHIS+.exe','C3EB445778B88282938BE98B37A5FAAF','10.35.60',To_Date('2017-07-12 09:28:04', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:54', 'yyyy-mm-dd HH24:mi:ss'),0,'[APPSOFT]',Null,'1,3,4,6,21,22,23,24,25,26','部件功能:ZLHIS+启动程序。系统定位:登录该程序才能进入导航台，进行业务操作。缺失后果:缺失该部件将无法进行各项业务。',0,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLHISCRUST.EXE','49D3A258803D802A1129DA2021B29183','10.35.60',To_Date('2017-07-12 09:26:26', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:54', 'yyyy-mm-dd HH24:mi:ss'),0,'[APPSOFT]',Null,'1,3,4,6,21,22,23,24,25,26','部件功能:客户端自动升级工具。系统定位:通过该工具对各个客户端进行文件升级。缺失后果:缺失该文件，将会导致需要升级的客户端无法进入导航台。',0,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLLOGIN.DLL','C8B0306B5F4EB253017B0BA17043FF2B','10.35.60',To_Date('2017-07-12 10:18:30', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:24:19', 'yyyy-mm-dd HH24:mi:ss'),0,'[PUBLIC]',Null,'1,3,4,6,21,22,23,24,25,26','部件功能:公共登录部件，提供统一登录接口，以及登陆中的功能、授权、客户端控制、升级等处理。系统定位:各个Exe均通过该部件实现登录。缺失后果:缺失该部件将会导致启动Exe程序出错。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLNewQuery.exe','B64AAD0AB1F0D9980E3FA43BE1B61EDE','10.35.60',To_Date('2017-07-12 09:32:48', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:58', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]',Null,'1','部件功能:老版自助系统系统定位:自助挂号、Lis打印、费用查询缺失后果:老版自助系统不能使用',0,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLPUBLICDRUG.DLL','17BA0B098F579BBC9B99A42940D43A4B','10.35.60',To_Date('2017-07-12 10:20:00', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:32:16', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zlCISKernel.dll,zl9InExse.DLL,zl9OutExse.dll','1','部件功能:药品业务公共部件系统定位:其他业务调用药品公共功能接口缺失后果:其他业务调用药品公共功能错误',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLREGISTER.DLL','8729BE72F1C1F13574D89019CC8B42B1','10.35.50',To_Date('2017-05-31 10:34:40', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:24:19', 'yyyy-mm-dd HH24:mi:ss'),0,'[PUBLIC]',Null,Null,'部件功能:用到此控件的界面不能正常打开，或者报错。使用原因:统一的注册校验、用户加密解密部件。缺失后果:相关流程无法进行身份验证，流程终止，包含：配血审核身份验证、发血身份验证、血液接收登记身份验证、输血执行身份验证。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLRPTSQLAdjust.exe','25C13BB1838E09E9D6694FEE01B5B6EA','10.35.60',To_Date('2017-07-12 10:05:20', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 18:50:52', 'yyyy-mm-dd HH24:mi:ss'),0,'[APPSOFT]',Null,Null,'部件功能:10.26病人费用表拆分配套工具。系统定位:进行大表拆分后的涉及病人费用记录的报表的调整。缺失后果:无法进行方便的进行大表拆分后的报表调整。',0,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLRUNAS.exe','CACE237C26F0699C63828FF3D79B8566','9.43.0',To_Date('2013-11-04 10:14:23', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:54', 'yyyy-mm-dd HH24:mi:ss'),4,'[APPSOFT]',Null,Null,'该文件在自动升级zlhisCrust.exe中使用。主要功能,在USER权限下可以使用管理员权限来进行登录执行管理操作',0,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLSOFTSHOWHISFORMS.EXE','FE97BF728282361800C89BA0207EFE40','10.35.60',To_Date('2017-07-12 10:20:06', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:30:05', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]','zl9XWInterface.dll','1','部件功能:显示病历查阅,医嘱，pacs历史报告等系统定位:ris中调用查看病历内容。缺失后果:ris系统不能查看病历内容。',0,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLSoft.BusinessHome.ClientControl.TimeLineBase.dll','E7181C04903EA3430C6C1630785867AB','1.0.0',To_Date('2017-04-18 09:20:32', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:30:05', 'yyyy-mm-dd HH24:mi:ss'),4,'[PUBLIC]',Null,Null,'部件功能:ZLSoft_BusinessHome_ClientControl_TimeLineBase使用原因:住院工作诊疗一览功能。缺失后果:住院诊疗一览功能不能使用，进入工作站时报错。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLSoft.BusinessHome.ClientControl.TimeLineBase.tlb','E72ACA5C9B83B3A1DA3CDC057DB70039',Null,To_Date('2017-07-12 17:47:35', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:30:05', 'yyyy-mm-dd HH24:mi:ss'),4,'[PUBLIC]',Null,Null,'部件功能:ZLSoft_BusinessHome_ClientControl_TimeLineBase使用原因:住院工作诊疗一览功能。缺失后果:住院诊疗一览功能不能使用，进入工作站时报错。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('Zl9DrugStore.dll','36BCC7921A4611680C8AE0040F5EAD02','10.35.60',To_Date('2017-07-12 09:31:26', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:57', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'1','部件功能:药房事务系统定位:门诊、住院药房发药管理，输液配置中心管理缺失后果:无法使用门诊、住院药房管理功能，无法使用静配功能',1,0,Null);
EXECUTE Zlfiles_Autoupdate('Zl9LISComm.exe','B35A25511EFF9EFFA2393484DD54781E','10.35.60',To_Date('2017-07-12 09:58:24', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:57', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]','zl9LisWork.dll','1','部件功能:老版检验通讯程序系统定位:老版检验通讯程序，处理仪器回传数据，加工成检验系统能够认识的数据格式缺失后果:检验结果将不能正常回传给老版LIS系统',0,0,Null);
EXECUTE Zlfiles_Autoupdate('ZlBrw.dll','8F5AEA114A7CDAC04A00CAE21CC20D65','10.35.60',To_Date('2017-07-12 09:28:06', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:54', 'yyyy-mm-dd HH24:mi:ss'),0,'[APPSOFT]\APPLY',Null,'1,3,4,6,21,22,23,24,25,26','部件功能:标准导航台样式，即双列表样式。系统定位:用来进行各个业务的导航，并提供一些基础的工具。缺失后果:缺失该部件，当选择的导航台样式为该样式时，无法进入整个系统。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZlMdi.dll','53EBBCF6CE02667EBDCDFEFBA3C7904D','10.35.60',To_Date('2017-07-12 09:28:40', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:54', 'yyyy-mm-dd HH24:mi:ss'),0,'[APPSOFT]\APPLY',Null,'1,3,4,6,21,22,23,24,25,26','部件功能:Mdi样式导航台，即父窗体里面存在各个子窗体。系统定位:用来进行各个业务的导航，并提供一些基础的工具。缺失后果:缺失该部件，当选择的导航台样式为该样式时，无法进入整个系统。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZlPacsSrv.exe','EE5F6C86948AD04681CC36DA0CD1EA8A','10.35.60',To_Date('2017-07-12 10:01:04', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:58', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]','zl9CISJob.dll','1','部件功能:接受Dicom设备发送的检查图像系统定位:PACS网关服务，监听影像DICOM设备请求并进行处理缺失后果:不能与影像DICOM设备通讯，不能接受设备图像',0,0,Null);
EXECUTE Zlfiles_Autoupdate('ZlPatiAddress.ocx','573E71EDEB22742E308630FD2CF239FA','10.35.60',To_Date('2017-07-12 09:29:32', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:55', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zl9RegEvent.dll,zl9CardSquare.dll,zl9CISJob.dll,zl9InPatient.dll,zl9Patient.dll,zl9MedRec.dll,zl9InExse.DLL','1','部件功能:结构化地址部件系统定位:支持系统中进行结构化地址填写缺失后果:无法使用入院、挂号、首页等相关程序',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZlWin.dll','0F12BBB4E9251BAE1EA3FC5A4D7FD7AA','10.35.60',To_Date('2017-07-12 09:29:00', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:54', 'yyyy-mm-dd HH24:mi:ss'),0,'[APPSOFT]\APPLY',Null,'1,3,4,6,21,22,23,24,25,26','部件功能:仿Window桌面样式导航台。系统定位:用来进行各个业务的导航，并提供一些基础的工具。缺失后果:缺失该部件，当选择的导航台样式为该样式时，无法进入整个系统。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('_sql.schclass','DB00476956C307C75B75808662F482BE',Null,To_Date('2014-09-10 16:33:01', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:54', 'yyyy-mm-dd HH24:mi:ss'),4,'[PUBLIC]',Null,Null,'SyntaxEdit控件SQL颜色方案配置文件。',0,0,Null);
EXECUTE Zlfiles_Autoupdate('codejock.calendar.v16.3.1.ocx','78ED7FE2F2076E79AE2E8FA2D40B44CF','16.3.1.0',To_Date('2016-06-28 11:33:16', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:26:44', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'部件功能:提供日期控件使用原因:使用日期控件缺失后果:程序无法使用',1,0,Null);
EXECUTE Zlfiles_Autoupdate('gacutil.exe','CB9A5FE7A8ACE0C5513DF6065F55F6F2','4.6.1055.0',To_Date('2016-10-27 15:08:12', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:27:51', 'yyyy-mm-dd HH24:mi:ss'),4,'[PUBLIC]',Null,Null,'.net gac注册命令文件',0,0,Null);
EXECUTE Zlfiles_Autoupdate('gacutil.exe.config','7033A6FA2F8A457716F6D642137CC7DB',Null,To_Date('2016-10-27 15:08:12', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:27:51', 'yyyy-mm-dd HH24:mi:ss'),4,'[PUBLIC]',Null,Null,'.net gac注册命令文件',0,0,Null);
EXECUTE Zlfiles_Autoupdate('mscorlib.dll','4DAC0BEFB5E8D1F6A837F9306D92A643','4.6.1586.0',To_Date('2017-02-06 15:47:30', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 18:50:52', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'部件功能:mscorlib.dll使用原因:缺失后果:',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zL9CashBill.dll','721D2461F090D1DA6A911BA39F7CFAB8','10.35.60',To_Date('2017-07-12 09:30:12', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:55', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll,zl9PeisManage.dll,zl9RegEvent.dll,zl9CardSquare.dll,zl9InExse.DLL,zl9OutExse.dll,zl9Patient.dll,zl9InPatient.dll,zl9CustAcc.dll','1','部件功能:财务监控及票据管理系统定位:收费轧帐、财务组收款、收费财务监控、人员借款和票据的入库、领用和报损。缺失后果:相关功能不能使用',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9AppTool.dll','E72E593228CC8DE26855745EEEC28B7A','10.35.60',To_Date('2017-07-12 09:25:30', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:54', 'yyyy-mm-dd HH24:mi:ss'),0,'[PUBLIC]',Null,'1,3,4,6,21,22,23,24,25,26','部件功能:导航台的中提供的基础应用工具功能部件。系统定位:提供了个人系统级的个性化设置、系统基础字典数据管理、邮件收发管理等功能。缺失后果:缺失将会导致无法使用整个系统。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BaseItem.dll','51C997F1CF0A61F64EB636C3E22C08A6','10.35.60',To_Date('2017-07-12 09:30:36', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:55', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9BaseItem.dll,zl9InExse.DLL,zl9OutExse.dll','1','部件功能:基础数据管理系统定位:业务基础部件，包括部门，人员，收费项目，收入项目，各业务公共参数等基础设置缺失后果:无法进行基础数据设置',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Blood.dll','FFD6D6B3171414835644A8C8BA15326B','10.35.60',To_Date('2017-07-12 10:01:04', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:56', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'22','部件功能:血库系统核心框架部件系统定位:包含血库相关功能模块：血液目录管理、血液供应入出库、科室配血管理、科室发血管理、血袋回收、报废等缺失后果:血库系统将无法使用',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BodyEditor.dll','AE82A8CD1F99C66C2883B5A1AE30DDC2','10.35.60',To_Date('2017-07-12 10:04:34', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:55', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:老版护士工作站中标准体温单相关功能调用,在未使用地区性体温部件时,均使用此部件系统定位:处理老版护士工作站中标准体温单相关业务缺失后果:无法使用老版护士工作站体温单的数据展示,编辑和打印功能',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BodyEditorGS.dll','E4B92FD7C4BEE4572C8935566C49C959','10.35.60',To_Date('2017-07-12 10:06:26', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:56', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:甘肃中医院专用体温单部件系统定位:处理老版护士工作站中体温单的相关业务缺失后果:缺失后会使用标准版体温部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BodyEditorGX.dll','F92E22533AD0C7A08CA16BB306B611CF','10.35.60',To_Date('2017-07-12 10:06:36', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:56', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:老版护士工作站中体温单(广西地区适用)系统定位:处理老版护士工作站中体温单相关业务缺失后果:缺失会自动使用标准版体温部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BodyEditorHEN.dll','ED3E34B35E8F4E590B0D068D0EB8A6A4','10.35.60',To_Date('2017-07-12 10:07:24', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:56', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:老版护士工作站中体温单相关功能(河南地区适用)系统定位:处理老版护士工作站中体温单相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BodyEditorHN.dll','792B688766FCBEEEAFD65B94448D01D5','10.35.60',To_Date('2017-07-12 10:06:14', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:56', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:老版护士工作站中体温单相关功能(河南地区适用)系统定位:处理老版护士工作站中体温单相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BodyEditorHun.dll','A2E047B0B2EC79CACF5AAED667729F35','10.35.60',To_Date('2017-07-12 10:07:46', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:56', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:老版护士工作站中体温单相关功能(湖南省通适用)系统定位:处理老版护士工作站中体温单相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BodyEditorQD.dll','6C6F5058ADF31447B414A2E2B03EF45F','10.35.60',To_Date('2017-07-12 10:06:48', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:56', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:老版护士工作站中体温单相关功能(青岛地区适用)系统定位:处理老版护士工作站中体温单相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BodyEditorSCDQ.dll','2DD0AACAF3A37D6ADB23B3960DCDB045','10.35.60',To_Date('2017-07-12 10:05:14', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:56', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:老版护士工作站中体温单相关功能(四川地区通用)系统定位:处理老版护士工作站中体温单相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BodyEditorSXHZ.dll','C1B21C738974D60E4874B5BFB3630548','10.35.60',To_Date('2017-07-12 10:06:02', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:57', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:老版护士工作站中体温单相关功能(陕西省汉中市适用)系统定位:处理老版护士工作站中体温单相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BodyEditorSxet.dll','ABED0DED7146C6EA8796DFFF55D7ADF2','10.35.60',To_Date('2017-07-12 10:07:34', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:57', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:老版护士工作站中体温单相关功能(陕西西安儿童医院适用)系统定位:处理老版护士工作站中体温单相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BodyEditorYDEY.dll','E654A78758F2AA4832E495771C387874','10.35.60',To_Date('2017-07-12 10:05:26', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:57', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:老版护士工作站中体温单相关功能(医大二院适用)系统定位:处理老版护士工作站中体温单相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BodyEditorYX.dll','DB393872C9B84F16C59A11052E342DB7','10.35.60',To_Date('2017-07-12 10:04:54', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:57', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:老版护士工作站中体温单相关功能(云南省玉溪市人民医院适用)系统定位:处理老版护士工作站中体温单相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9CISAudit.dll','2E17E2606DE43DB2E507F86657E0E859','10.35.60',To_Date('2017-07-12 10:01:52', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:57', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'1','部件功能:电子病案审查归档系统定位:包含模块：病案评分标准、病案审查标准、电子病案审查、电子病案借阅、电子病案评分、病历质量查阅、电子病案接收；以电子病历质控为核心业务的应用模块集中于该部件中。缺失后果:质控相关模块窗口无法使用。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9CISBase.dll','C0A55CAA184CAC1CC93AEA9644707464','10.35.60',To_Date('2017-07-12 14:24:38', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:57', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISAudit.dll,zl9InExse.DLL,zl9LisWork.dll,zl9PACSWork.dll,zl9Oper.dll,zl9CISBase.dll,zl9Blood.dll,zl9CISJob.dll','1','部件功能:临床基础部件系统定位:设置药品目录，诊疗项目及相关，检查、检验、影像等相关基础数据缺失后果:无法设置药品目录，诊疗项目及相关，检查、检验、影像等相关基础数据',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9CISJob.dll','5373E26A362DE85AFCFF3C0D58F5E3F5','10.35.60',To_Date('2017-07-12 09:58:26', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:57', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','Zl9DrugStore.dll','1','部件功能:临床工作站框架部件系统定位:住院医生站，住院护士站，新版护士站，老版护士站，老版医技站，电子病案查阅。缺失后果:以上工作站无法使用。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9CardSquare.dll','0CC70837E49D64236FC730EE10AACE75','10.35.60',To_Date('2017-07-12 09:34:46', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:55', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll,zl9PeisManage.dll,zl9RegEvent.dll,zl9Transfusion.dll,zl9Blood.dll,zl9CISAudit.dll,zl9PACSWork.dll,zl9OutExse.dll,zl9Oper.dll,zl9LisWork.dll,ZL9LabWork.dll,zl9InPatient.dll,zl9InExse.DLL,Zl9DrugStore.dll,zl9Patient.dll,zl9CISJob.dll,zl9CardSquare.dll,zl9XWInterface.dll,zl9Stuff.dll,zl9CISBase.dll','1','部件功能:结算卡管理部件系统定位:医疗卡、消费卡管理缺失后果:涉及一卡通的业务无法使用',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9ComLib.dll','AC88A214F1A87BCE6A926910E25FE92F','10.35.60',To_Date('2017-07-12 09:24:24', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:54', 'yyyy-mm-dd HH24:mi:ss'),0,'[PUBLIC]',Null,'1,3,4,6,21,22,23,24,25,26','部件功能:公共的基础函数库，用来提供统一的SQL查询、一些系统常用API封装、常用控件处理、常用类型方法以及应用系统基础业务的常用查询。系统定位:ZLHIS的系统底层支持部件，一般部件均使用该部件提供的公共方法进行编码缺失后果:整个应用系统无法使用。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9ComLibpss.dll','0CC094950FBB43898394683F497B4582','10.35.60',To_Date('2017-07-12 10:10:36', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:53', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zlWizardStart.exe','26','部件功能:导诊公共函数部件系统定位:提供公共方法函数（和导诊业务无关）缺失后果:系统不能运行',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9CommEvents.dll','0FFD3225963AD31401AD0157BDAD0A3A','10.35.60',To_Date('2017-07-12 10:11:00', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:55', 'yyyy-mm-dd HH24:mi:ss'),0,'[PUBLIC]',Null,'1,3,4,6,21,22,23,24,25,26','部件功能:公共的基础事件部件：自动发卡、投币、键盘输入和自动读卡事件触发后，主程序能够响应。系统定位:三方程序触发事件,以便主程序接收数据。缺失后果:自助发卡、自助系统的现金支付功能调用就会出现错误，所有使用第三方接口自动读卡也会出现错误。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9CustAcc.dll','E47AD0278BBB9EAD88BB90DDDA203CD6','10.35.60',To_Date('2017-07-12 09:30:12', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:57', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zl9BaseItem.dll,zl9InExse.DLL,zl9OutExse.dll','1','部件功能:自定义记帐单部件系统定位:专项记帐和专项记账单设置缺失后果:不能使用专项记帐单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Device.dll','6DDEB04343A04B4706C1950BAD733FE1','10.35.60',To_Date('2017-07-12 10:00:04', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:55', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'6','部件功能:管理医院的设备系统定位:既可以独立存在，也可以共享标准系统存在缺失后果:缺少将无法管理设备',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Disease.dll','DA74D0E025B38FD66105B94BEA949FC4','10.35.60',To_Date('2017-07-12 09:37:54', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:26:44', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:传染病管理系统相关功能系统定位:处理传染病管理系统相关业务缺失后果:无法使用传染病填写、上报相关功能',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9DrawReport.dll','901978E3E772B7FB58B1323583557295','10.35.60',To_Date('2017-07-12 10:02:10', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:55', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll,zl9PeisManage.dll,zl9Oper.dll','21,24','部件功能:zl9DrawReport系统定位:实现固定报告格式的打印输出预览缺失后果:不能实现打印输出预览功能',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Due.dll','F540F26706F0C8715A0288DA6F69D89E','10.35.60',To_Date('2017-07-12 09:30:52', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:55', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'1','部件功能:付款管理部件系统定位:医院所有采购商品应付和已付的管理缺失后果:缺少将无法使用付款管理',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9ESign.dll','6FB08F8F0E3EE7896CA36950D3D0BEAE','10.35.60',To_Date('2017-07-12 09:25:44', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:54', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zl9CISJob.dll','1','部件功能:电子签名部件系统定位:集成不同CA厂商的电子签名接口并供各个业务模块调用。缺失后果:各个业务模块将无法启用电子签名功能',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Function.dll','B863E7E716C9D6DB8360B9CCD31B74E1','10.35.60',To_Date('2017-07-12 09:24:34', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:54', 'yyyy-mm-dd HH24:mi:ss'),0,'[PUBLIC]',Null,Null,'部件功能:函数管理工具。系统定位:进行自定义报表函数的管理。缺失后果:无法进行自定义报表函数的管理。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9InExse.DLL','84B078FE906B7464C7F1348B9466C474','10.35.60',To_Date('2017-07-12 09:37:08', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:57', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll,zl9InPatient.dll,zl9OutExse.dll','1','部件功能:住院费用部件系统定位:住院记帐、科室分散记帐、医技科室记帐、自动记帐计算、病人费用查询、费用审核、执行登记、病人结帐处理。缺失后果:住院费用业务不能运行。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9InPatient.dll','A92A7563392D6BF098E9D48633F1DF3E','10.35.60',To_Date('2017-07-12 09:31:54', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:57', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll,zl9InExse.DLL','1','部件功能:住院病人部件系统定位:实现病人入院登记、病人入出管理、病区床位管理缺失后果:无法完成住院病人登记、病人入出管理、病区床位管理',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Infect.dll','6FC0389DE3F9469B0BC015FBC542067B','10.35.60',To_Date('2017-07-12 10:01:22', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:59', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'23','部件功能:院感管理系统核心框架部件系统定位:院感系统核心功能窗体，含：病例监测管理、病例日报管理、人员监测管理、医院感染汇总表缺失后果:无法使用院感系统',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9LCDShow.dll','8B830186B7534E61D25C991B3DA8119C','10.35.60',To_Date('2017-07-12 09:59:02', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:57', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9Transfusion.dll','1','部件功能:老版排队显示业务封装系统定位:老版排队情况封装缺失后果:不能显示排队情况',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9LabPrintSvr.exe','43E16A949D7D38987DE58C756453073E','10.35.20',To_Date('2016-08-17 13:41:50', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:55', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]','ZL9LabWork.dll','25,26','部件功能:新版LIS打印服务系统定位:主要处理 批量打印报告缺失后果:导诊和新版LIS打印报告部分将不能使用',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9LabReceiv.exe','896522858436E22A62581F2EA3AFB640','10.35.60',To_Date('2017-07-12 10:09:04', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:55', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]','ZL9LabWork.dll','25','部件功能:新版通讯程序部件系统定位:主要处理与仪器接口之间数据交互缺失后果:不能正常解析仪器数据',0,0,'[APPSOFT]\DEV_[*]');
EXECUTE Zlfiles_Autoupdate('zl9LabTcpSvr.exe','96ADDFB20DE9CAD357CE0C56F215E4E1','10.35.0',To_Date('2015-12-01 09:20:47', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:55', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]','ZL9LabWork.dll','25','部件功能:新版LIS检验消息转发部件系统定位:处理实验室和通讯程序间的消息转发缺失后果:数据不能正常转发',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9LedVoice.dll','30444390ABFCD2985D4CEDB2E56E8027','10.35.60',To_Date('2017-07-12 09:24:38', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:57', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zl9RegEvent.dll,zl9CardSquare.dll,zl9InExse.DLL,zl9OutExse.dll,zl9Patient.dll,zl9InPatient.dll','1','部件功能:LED显示、语言报价部件系统定位:向病人显示收费信息缺失后果:不能支持语言半价或者在LED屏显示信息',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9LisQuery_Base.dll','141288CD68561A5C81B3E36B813807FC','10.35.60',To_Date('2017-07-12 10:05:50', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:57', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9LisWork.dll','1','部件功能:检验外挂接口部件系统定位:支持检验外挂接口。缺失后果:综合查询外挂不能加载',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9LisQuery_Dfn.dll','0BE8EEAD6D6EB47F9C63E2685EE955AF','10.35.0',To_Date('2015-12-01 09:06:50', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:57', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zl9LisWork.dll','1','部件功能:老版LIS外挂部件系统定位:加载渠道开发的外挂部件缺失后果:不能正常加载外挂',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9LisWork.dll','BC4C0500CBE9CEE1FE3E569632ADA8D5','10.35.60',To_Date('2017-07-12 11:18:56', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:57', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:老版LIS核心部件。系统定位:处理检验相关操作。包含检验技师工作站、检验采集工作站、检验登记。缺失后果:检验相关业务讲不能正常使用。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Material.dll','3814D7BEDB871B729F0F95CE2736BFD2','10.35.60',To_Date('2017-07-12 10:00:00', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:56', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'4','部件功能:管理医院的物资系统定位:既可以独立存在，也可以共享标准系统存在缺失后果:缺少将无法管理物资',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9MedRec.dll','D8DD1FC8D52A3C5BA5A9FF930E3BC859','10.35.60',To_Date('2017-07-12 10:00:30', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:53', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'3','部件功能:病案管理事务系统定位:病案系统管理、门诊日报、住院日报功能缺失后果:病案系统、门诊、住院日报功能失效。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9MediStore.dll','5BCDF78ED9AA228BF5D308F2F19E0EDD','10.35.60',To_Date('2017-07-12 09:32:42', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:57', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'1','部件功能:zlMediStore系统定位:药品流通业务部件，如入库，出库，盘点等业务操作缺失后果:无法进行药品流通业务',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Oper.dll','B8DEAFC3B059F07876E7403B1C4FED87','10.35.60',To_Date('2017-07-12 10:02:56', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:56', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'24','部件功能:手术麻醉部件系统定位:实现手术安排及相关计费缺失后果:手麻产品不能运行',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9OpsStarand.dll','AAD1D5655A992C395F9E168EA6096804','10.35.60',To_Date('2017-07-12 10:02:54', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:56', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9Oper.dll','24','部件功能:手术麻醉单打印预览系统定位:生成手术麻醉单，并进行打印或预览缺失后果:不能生成手术麻醉单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9OutExse.dll','BA3E3719C08FFB1C0706DF498915C132','10.35.60',To_Date('2017-07-12 09:33:12', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:57', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','Zl9DrugStore.dll','1','部件功能:门诊费用部件系统定位:门诊划价、门诊收费、门诊记账缺失后果:缺失上述功能',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PACSWork.dll','2579BEA5B504C917641B35AFB587CCDF','10.35.60',To_Date('2017-07-12 11:44:46', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:57', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'1','部件功能:进行影像系统基本业务处理系统定位:封装了对影像系统基本业务的处理，是业务系统的入库。缺失后果:不能进入对应的影像系统。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PacsControl.ocx','08C988CA52032372E2FC69EC778D23C1','10.35.60',To_Date('2017-07-12 10:03:42', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:57', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9PACSWork.dll','1','部件功能:自定义控件封装系统定位:对常用的控件进行封装缺失后果:进入影像系统将产生异常',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PacsCore.dll','54EFFCB3B7715D5FD57781BFAAFE2DBB','10.35.60',To_Date('2017-07-12 11:19:02', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:55', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9PACSWork.dll','1','部件功能:PACS观片处理部件系统定位:查看PACS图像缺失后果:不能进行影像观片',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Partogram.dll','DBA82ED5C43B0D24EE74E75023A9F2F2','10.35.60',To_Date('2017-07-12 10:08:56', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:57', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:产程图管理相关功能系统定位:处理产程图相关业务缺失后果:无法使用产程图展示,编辑,打印功能',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Patient.dll','31632271E92B967DA8FF5F5BF9F182CF','10.35.60',To_Date('2017-07-12 09:33:00', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:57', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9RegEvent.dll,zl9CardSquare.dll,zl9InExse.DLL,zl9OutExse.dll,zl9InPatient.dll','1','部件功能:病人信息管理部件。系统定位:病人信息登记、修改、删除等操作。缺失后果:无法对病人信息进行维护。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PeisBase.dll','F38A9E6E18EC855D1907B5D29738095E','10.35.60',To_Date('2017-07-12 10:16:52', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:56', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll','21','部件功能:体检基础业务系统定位:体检基础数据设置（增删改），包括体检相关的公共或系统参数设置，是体检产品运行必不可少的部件。缺失后果:不能维护体检基础数据；同时体检业务大部份功能也会不正常。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PeisComLib.dll','8FBE865BB617827F34B3F80A4E965B1C','10.35.60',To_Date('2017-07-12 10:23:00', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:56', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','ZL9Peis.dll,zl9PeisManage.dll,zl9PeisBase.dll','21','部件功能:体检公共组件系统定位:给体检基础功能和业务功能提供公共的方法函数缺失后果:整个体检产品无法使用。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PeisDevAnalyse.dll','191FB33503B62F5F44588EFB0B4606E6','10.35.0',To_Date('2015-12-01 09:22:53', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:56', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll,zl9PeisManage.dll,zl9PeisBase.dll','21','部件功能:体检非标准串口的接口程序系统定位:定时读取非标准串口仪器所产生的指标结果数据缺失后果:不能接收到非标准串口仪器的指标结果数据',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PeisFlow.dll','A574B0DE09F6300423EDAEE2871DCFCC','10.35.60',To_Date('2017-07-12 10:16:00', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:56', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll,zl9PeisManage.dll,zl9PeisBase.dll','21','部件功能:体检执行业务系统定位:实现体检分科、总检等业务功能缺失后果:体检产品不能使用',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PeisInnerInterface.dll','05765F2102630D1A33E7DEBD3F994CA6','10.35.60',To_Date('2017-07-12 10:15:00', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:56', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll,zl9PeisManage.dll,zl9PeisBase.dll','21','部件功能:体检内部接口系统定位:实现费用、排队叫号、医嘱、票据等的数据交换缺失后果:体检产品不能正确运行',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PeisInstrument.dll','E72B4A469D1F491BB4DA1E110169A4E2','10.35.0',To_Date('2015-12-01 09:20:44', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:56', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll,zl9PeisManage.dll,zl9PeisBase.dll','21','部件功能:体检基本仪器数据接口系统定位:完成体检基本仪器数据传输接口缺失后果:不能接收到身高体重仪等基本仪器数据',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PeisInterface.dll','042367CC14BC3F703D450C661F468A8D','10.35.60',To_Date('2017-07-12 10:05:44', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:56', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll,zl9PeisManage.dll,zl9PeisBase.dll','21','部件功能:第三方体检接口部件系统定位:实现三方体检和ZLHIS的数据交换缺失后果:不能实现三方体检和ZLHIS的接口',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PeisManage.dll','21493663215BEE9779EB77C9CDBA83A2','10.35.60',To_Date('2017-07-12 10:16:56', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:56', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll','21','部件功能:体检管理业务系统定位:实现体检登记、报到、填写结果、打印报告、指引单等业务缺失后果:体检产品不能使用。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PeisPersonPDF.dll','0811016C0CDFDA9B1123A310444E2FD5','10.35.60',To_Date('2017-07-12 10:17:40', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:56', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll,zl9PeisManage.dll,zl9PeisBase.dll','21','部件功能:体检报告PDF输出接口系统定位:体检报告打印三方生成的PDF文件缺失后果:不能完整输出体检报告内容',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PeisPersonReport.dll','3BA0B9459D2E1D3EC641B260131A141A','10.35.60',To_Date('2017-07-12 10:17:34', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:56', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll,zl9PeisManage.dll,zl9PeisBase.dll','21','部件功能:体检个人报告自定义报表系统定位:体检报告中需要调用自定义报表进行打印缺失后果:体检报告中自定义报表时不能输出完整的体检报告',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PeisPersonRpt.dll','29228D1E3462FB68B21185B423DBB6B2','10.35.60',To_Date('2017-07-12 10:07:00', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:56', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll,zl9PeisManage.dll,zl9PeisBase.dll','21','部件功能:个人体检报告输出系统定位:按固定的格式生成报告打印数据缺失后果:不能输出个人体检报告',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PeisRpt.dll','F6DD037437CB09E6EFCE84EE93DF4E0E','10.35.60',To_Date('2017-07-12 10:03:02', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:56', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll,zl9PeisManage.dll,zl9PeisBase.dll','21','部件功能:体检报告格式系统定位:个人体检报告的内容生成缺失后果:不能生成报告内容',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PrintMode.dll','A8EC034AD403D1DAF60FD844F0199420','10.35.60',To_Date('2017-07-12 09:24:50', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:54', 'yyyy-mm-dd HH24:mi:ss'),0,'[PUBLIC]',Null,'1,3,4,6,21,22,23,24,25,26','部件功能:打印表格控件内容、通过命令生成输出内容等系统定位:方便用户输出数据缺失后果:可以缺少，但无法输出数据',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Purvey.dll','2567B99381837FE89050BC18F7E46CDF','10.35.60',To_Date('2017-07-12 10:02:00', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:56', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9Material.dll','4','部件功能:管理供应室的器械包系统定位:属于物资系统的子系统缺失后果:缺少将无法管理器械包',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9RecipeAudit.dll','BFA8BE0FA0E1C1C4E2F3B775A73C7DE1','10.35.60',To_Date('2017-07-12 10:18:26', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:57', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:药剂师对门诊和住院的用药处方审查系统定位:控制有问题的处方，提升处方合格率缺失后果:缺少将无法使用处方审查系统',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9RegEvent.dll','DE6A0FE1DB1EA575452CCFD5524EAEA8','10.35.60',To_Date('2017-07-12 18:37:19', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:57', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll,zl9OutExse.dll','1','部件功能:门诊挂号部件系统定位:设置挂号安排和临床出诊，提供挂号、预约、分诊等功能，提供患者服务中心对病人预约进行管理缺失后果:与挂号相关的功能不能使用',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Report.dll','8647A85EA671AB15AB6467F3CE3296BE','10.35.60',To_Date('2017-07-12 09:25:40', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:54', 'yyyy-mm-dd HH24:mi:ss'),0,'[PUBLIC]',Null,'1,3,4,6,21,22,23,24,25,26','部件功能:支持业务系统输出自定义报表的内容，以及设计自定义报表系统定位:方便用户和技术人员缺失后果:缺少将无法输出报表和设计报表',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Stuff.dll','183DAD09D28EA064CDFB1004F70F573D','10.35.60',To_Date('2017-07-12 09:35:00', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:57', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','Zl9DrugStore.dll','1','部件功能:zl9Stuff系统定位:卫材业务部件，包括卫材目录，卫材入出流通管理，卫材发放管理等缺失后果:不能开展卫材流通，发放等业务',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChart.dll','085D2B7221E4573918EEDA0CB1A06D18','10.35.60',To_Date('2017-07-12 13:20:46', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:57', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:新版护士工作站体温单相关功能(标准体温单,未启用地区性体温单时均使用此体温单)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:无法进行体温单的展示和数据编辑功能',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChartGD.dll','DACCE6C508D6A82BC23101DF48C274F6','10.35.60',To_Date('2017-07-12 10:15:02', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:57', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:新版护士工作站体温单相关功能(广东省地区适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChartGS.dll','AAC4592059E5A51A32102BFBD7ACC5C6','10.35.60',To_Date('2017-07-12 09:45:40', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:58', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:新版护士工作站体温单相关功能(甘肃中医院适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChartGX.dll','6DF18679CCD99096DE38898E2E2BE9EE','10.35.60',To_Date('2017-07-12 09:45:08', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:58', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:新版护士工作站体温单相关功能(广西省适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChartGZJX.dll','683B5A20CB6776189CA7C0D5076743F6','10.35.60',To_Date('2017-07-12 10:19:46', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 18:50:52', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:新版护士工作站体温单相关功能(广州揭西适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChartHLJ.dll','8237391FEF28808D2A4433EB8FD7E604','10.35.60',To_Date('2017-07-12 14:24:00', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 18:50:52', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:新版护士工作站体温单相关功能(黑龙江地区适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChartHnnx.dll','6A5BA3B8AE59CE5DBC121B77A55ED29F','10.35.60',To_Date('2017-07-12 10:14:16', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:58', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:新版护士工作站体温单相关功能(湖南宁乡人民医院适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChartJX.dll','A95FF27114257D13346A44778D61431D','10.35.60',To_Date('2017-07-12 10:19:18', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 18:50:52', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:新版护士工作站体温单相关功能(江西省适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChartNJ.dll','83082D68A4A2B6A8FDF8E71C74DEF667','10.35.60',To_Date('2017-07-12 10:18:00', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:58', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:新版护士工作站体温单相关功能(江苏地区适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChartS3201.dll','809B825CFDA8770A167B749EB896CD9B','10.35.60',To_Date('2017-07-12 09:45:24', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:58', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:新版护士工作站体温单相关功能(陕西3201医院适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChartSC.dll','0D0D8B8EF2F7985B8C5719E1FEE875B9','10.35.60',To_Date('2017-07-12 09:29:18', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:58', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:新版护士工作站体温单相关功能(四川地区通用体温部件)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChartSCZG.dll','BF6CE330CEF4E088DEB29CCE71A0A99E','10.35.60',To_Date('2017-07-12 09:29:32', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:58', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:新版护士工作站体温单相关功能(四川自贡市适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChartSX.dll','DAC15848845F9905A4FAD7B1BFB3BA71','10.35.60',To_Date('2017-07-12 10:12:16', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:58', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:新版护士工作站体温单相关功能(山西地区适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChartYDEY.dll','C45A7B49672FDAA1E79FF842A8F92C3B','10.35.60',To_Date('2017-07-12 10:14:44', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:58', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:新版护士工作站体温单相关功能(医大二院适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TendFile.dll','4E0B4DB1DA3864526A7D1818AF81D7C1','10.35.60',To_Date('2017-07-12 09:46:02', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:55', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISAudit.dll,zl9CISJob.dll,zl9Oper.dll','1','部件功能:处理护士工作站记录单相关业务系统定位:护士工作站中记录单相关业务流程缺失后果:无法在护士工作站中进行记录单的查看和操作',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Transfusion.dll','AA39AE83B652BE008CF07197B07FDED5','10.35.60',To_Date('2017-07-12 10:00:20', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:58', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'1','部件功能:门诊输液系统部件系统定位:处理门诊输液执行、附费相关业务缺失后果:无法使用门诊输液工作站',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardCards.dll','4FA46B3DAF8E15D6DB322A3504873B52','10.35.60',To_Date('2017-07-12 10:14:04', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:53', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','26','部件功能:自助发卡与签约系统定位:提供自助设备上进行发卡和绑定卡操作缺失后果:自助发卡与签约功能缺失',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardControl.ocx','E6B089B5E9F65B4F5B922FB4B3ED90BE','10.35.60',To_Date('2017-07-12 10:10:56', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:53', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zlWizardStart.exe','26','部件功能:提供自助系统所需要的控件系统定位:完成自助系统的控件统一效果及功能实现缺失后果:不能运行自助系统并报错',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardDeposit.dll','56BE4AACD7375A8DB8C9FE405D5287C8','10.35.60',To_Date('2017-07-12 10:12:44', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:53', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','26','部件功能:自助充值管理系统定位:提供门诊预交和住院预交以及历史充值记录查询缺失后果:自助充值及查询功能缺失',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardEMR.dll','39F942A6A924402242CD9544382E5F90','10.35.60',To_Date('2017-07-12 10:17:10', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:53', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','26','部件功能:zl9WizardEMR系统定位:门诊电子病历缺失后果:无法使用自助服务系统门诊电子病历相关功能',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardFeeQuery.dll','163ED5231B3477A2E86C3A754734E981','10.35.60',To_Date('2017-07-12 10:12:54', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:53', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','26','部件功能:自助费用查询系统定位:自助设备上查询病人门诊和住院费用缺失后果:自助费用查询功能缺失',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardInvoice.dll','953E741C53778121B1EEB1169E1D76B7','10.35.60',To_Date('2017-07-12 10:13:06', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:53', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','26','部件功能:自助票据打印系统定位:自助设备上对未打印票据的缴费和挂号单据打印票据缺失后果:挂号和收费票据打印功能缺失',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardLABCall.dll','10A08A93F9F1B9798563672314CADD2E','10.35.60',To_Date('2017-07-12 10:13:46', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:53', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','26','部件功能:zl9WizardLABCall系统定位:检验叫号缺失后果:暂无',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardLabPrint.dll','16EC42494082228525F788A8A04A18CA','10.35.60',To_Date('2017-07-12 10:13:12', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:53', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','25','部件功能:导诊打印老版LIS报告系统定位:在导诊系统中，打印老版LIS相关报告缺失后果:不能正常打印老版LIS报告',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardLib.dll','692CA769B2B4219940407C1D0B3351E2','10.35.60',To_Date('2017-07-12 10:10:42', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:53', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zlWizardStart.exe','26','部件功能:病人自助系统公共库系统定位:提供自助系统中需要使用的方法函数缺失后果:系统不能运行',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardMain.exe','D7AD8D23125E23D3F1FF377AF6B69417','10.35.60',To_Date('2017-07-12 10:13:50', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:53', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]',Null,'26','部件功能:病人自助系统后台管理程序系统定位:完成自助系统的所有后台设置，包括资源配置、动态页面设计、静态页面参数等缺失后果:系统不能正常运行',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardManage.dll','D406D86AF9545FD92B58CA0024B0703E','10.35.60',To_Date('2017-07-12 10:11:58', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:53', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9WizardMain.exe','26','部件功能:自助系统后台管理系统定位:配置自助系统的资源、页面、参数等缺失后果:不能启动后台管理',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardPage.dll','56B38BFA8D1957B1E0FF47E133B10E54','10.35.60',To_Date('2017-07-12 10:11:14', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:53', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','26','部件功能:自助动态页面显示系统定位:根据动态页面的设计显示最终的页面展示效果缺失后果:自助系统不能使用',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardPayFee.dll','8A7EC228E4814C526EB930E138993B8C','10.35.60',To_Date('2017-07-12 10:13:32', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:53', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','26','部件功能:自助缴费管理系统定位:自助设备上对划价单据进行缴费缺失后果:自助缴费功能缺失',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardPeisQueue.dll','07CC9EE153E88C582DE635936C10EE2C','10.35.60',To_Date('2017-07-12 10:14:26', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:53', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','26','部件功能:体检自助排队系统定位:体检人员通过病人自助系统提供体检自助排队功能进行自助体检排队缺失后果:体检人员无法自助排队',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardPharmacy.dll','1ADD179C4C108A7184AFB04E274DBBDF','10.35.60',To_Date('2017-07-12 10:19:28', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:26:44', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','26','部件功能:自助系统中的门诊药房病人签到管理系统定位:作为自助系统的一部分存在缺失后果:缺少将无法使用门诊药房签到',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardPrice.dll','58441DC4A02BCFE53B0533006EE3DE1C','10.35.60',To_Date('2017-07-12 10:11:22', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:53', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','26','部件功能:提供收费项目的价格自助查询系统定位:通过简码等实现收费项目价格的自助查询缺失后果:不能自助查询价格',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardProficient.dll','0CD138592CF09D3149551BC6107BB306','10.35.60',To_Date('2017-07-12 10:11:32', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:53', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','26','部件功能:实现医院专家介绍自助查询系统定位:实现医院专家介绍自助查询缺失后果:不能实现专家介绍查询',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardProof.dll','4C92C43099AA627C10D0A0B83B9BFF93','10.35.60',To_Date('2017-07-12 10:17:34', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:53', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','26','部件功能:自助凭条打印系统定位:自助设备上打印缴费和挂号凭条缺失后果:缴费和挂号凭条打印功能缺失',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardRegEvent.dll','11695AAED02FAFA7836976EFFC114268','10.35.60',To_Date('2017-07-12 10:13:54', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:53', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','26','部件功能:自助挂号和预约系统定位:自助设备上病人进行挂号和预约以及取号缺失后果:挂号和预约以及取号功能缺失，今日就诊也不能进行挂号',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardToday.dll','3C8405DDDA496784702B8EED06B8937F','10.35.60',To_Date('2017-07-12 10:11:44', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:53', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','26','部件功能:今日就诊系统定位:查询挂号安排，进行挂号/预约，查看挂号科室上班时间缺失后果:挂号、预约以及查询功能缺失',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9keyboard.dll','94EFD2A89C9714355BDC7BB8EA7F8143','10.35.0',To_Date('2015-12-01 09:01:40', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:55', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zl9RegEvent.dll,zl9CardSquare.dll,zl9Patient.dll,zl9InPatient.dll','1','部件功能:密码键盘部件系统定位:使用密码键盘设备缺失后果:密码键盘无法使用',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9peisgrouprpt.dll','AAF2B874670A0C5BFDA23B1C504ECD2E','10.35.60',To_Date('2017-07-12 10:07:10', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:56', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll,zl9PeisManage.dll,zl9PeisBase.dll','21','部件功能:体检团体报告预览及打印输出。系统定位:实现体检团体报告预览及打印输出。缺失后果:不能实现团体报告预览及打印输出',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlActMain.exe','4C43929EB9F52C2097D977245267A84A','10.35.60',To_Date('2017-07-12 10:14:58', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:58', 'yyyy-mm-dd HH24:mi:ss'),0,'[APPSOFT]',Null,'1,3,4,6,21,22,23,24,25,26','部件功能:BH融合中的虚拟导航台。系统定位:BH调用各个模块均通过该程序进行导航。缺失后果:缺失时BH无法使用所有的业务模块。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlCISKernel.dll','6BD222FE0997FA4F00C115FC9DFACB0D','10.35.60',To_Date('2017-07-12 09:37:32', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:55', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISAudit.dll,zl9InExse.DLL,zl9LisWork.dll,zl9PACSWork.dll,zl9Oper.dll,zl9CISBase.dll,zl9Blood.dll','1,22,24,25','部件功能:临床核心部件，提供医嘱相关操作封装等接口，提供DOCK页签等。系统定位:提供医嘱核功能缺失后果:临床医嘱相关功能丢失，各大工作站的医嘱信息页签丢失。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlCISPath.dll','589B6B056400C47C8C8930EC2B9ABE90','10.35.60',To_Date('2017-07-12 09:38:32', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:58', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISAudit.dll,zl9CISJob.dll','1','部件功能:临床路径部件系统定位:临床路径应用、临床路径管理、临床路径跟踪缺失后果:临床路径应用、临床路径管理、临床路径跟踪将无法正常运行',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlCisAuditPrint.EXE','42FC48B7F514259D9DBC0496F9BC2E42','10.35.60',To_Date('2017-07-12 10:17:30', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:58', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISAudit.dll','1','部件功能:用于电子病案审查中,文件-输出到PDF系统定位:避免连续PDF输出引起系统GDI超量，导致系统假死缺失后果:无法进行PDF输出',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlDisReportCard.DLL','244907EEF7CA08893469FD0ADEB001F8','10.35.60',To_Date('2017-07-12 10:17:30', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:58', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9Disease.dll','1','部件功能:传染病固定格式报告卡控件系统定位:用于填写传染病报告卡缺失后果:无法使用固定格式传染病报告卡',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlGetImage.exe','95BA911ADCBD666566B8B85474985F61','10.35.60',To_Date('2017-07-12 10:07:52', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:58', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9PACSWork.dll','1','部件功能:提供影像检查图像下载支持系统定位:后台下载影像检查图像缺失后果:不能观片',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zlICCard.dll','0BC3E52BCBA8D6206CC5C4DB7D0B724C','10.35.60',To_Date('2017-07-12 09:25:54', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:54', 'yyyy-mm-dd HH24:mi:ss'),0,'[PUBLIC]',Null,'1,3,4,6,21,22,23,24,25,26','部件功能:IC卡读卡的统一接口系统定位:IC卡读卡缺失后果:一卡通无法使用，部分会导致程序异常退出',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlIDCard.dll','788EAF0F0E7387240CB8052497A4E8DC','10.35.60',To_Date('2017-07-12 09:25:46', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:54', 'yyyy-mm-dd HH24:mi:ss'),0,'[PUBLIC]',Null,'1,3,4,6,21,22,23,24,25,26','部件功能:身份证读卡的统一接口系统定位:读取身份证信息缺失后果:无法读取身份证信息',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlIDKind.ocx','E0E1C483755148A65DD0EF7D0E1ACC84','10.35.60',To_Date('2017-07-12 09:24:02', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:54', 'yyyy-mm-dd HH24:mi:ss'),0,'[PUBLIC]',Null,'1,3,4,6,21,22,23,24,25','部件功能:病人身份识别控件系统定位:刷卡和读卡查询病人缺失后果:使用的地方应控件丢失出错',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlLISDev.dll','E31A4AF897463A0CAC341B60F840351E','10.35.0',To_Date('2015-12-01 09:16:26', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:55', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe,zl9LisWork.dll,ZL9LabWork.dll','1,25','部件功能:处理检验仪器的数据、图片解析系统定位:让仪器数据，能够保存为我们认识的检验结果。缺失后果:检验仪器数据将不能正常解析到我们系统。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlLISInterface.DLL','D36E9D384605B13092EDC3AC9987FEE7','10.35.60',To_Date('2017-07-12 10:17:04', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:58', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9LisWork.dll','1','部件功能:三方检验接口部件系统定位:支持三方检验接入到HIS系统中缺失后果:三方检验不能正常接入到his系统，该部件未正常发布。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlLisMessage.exe','5A9DFCDD8BA7C02F90E18753D89B33E1','10.35.60',To_Date('2017-07-12 10:20:08', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 18:50:52', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]','ZL9LabWork.dll','25','部件功能:LIS消息部件系统定位:在大屏幕上显示某些检验科内部的情况缺失后果:无法再大屏幕上显示检验科内部的情况',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zlLisReceiveSend.exe','1A7E194151478D9BE76375DBF4890389','10.35.0',To_Date('2015-12-01 09:12:48', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:58', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]','zl9LisWork.dll','1','部件功能:主要与检验仪器直接通讯系统定位:记录仪器回传的检验结果，并保存文本为LIS认识的检验结果。缺失后果:如果缺失,老版LIS将不能正常解析检验数据',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zlMedRecPage.dll','9166AF654060B70CE93E08457230E492','10.35.60',To_Date('2017-07-12 09:26:24', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:54', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zl9CISJob.dll,zl9MedRec.dll','1','部件功能:住院首页、病案首页程序系统定位:处理病人住院首页、病案首页相关业务缺失后果:临床工作站、病案系统等业务模块无法使用',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlOperInterface.dll','AF1D1EE0232D32435A8BB44E103403AA','10.35.60',To_Date('2017-07-12 10:05:38', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:56', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9Oper.dll','24','部件功能:三方手麻软件接口ZLHIS系统定位:实现三方手麻产品和ZLHIS产品之间的功能接口缺失后果:无法实现和ZLHIS的数据交换。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlOrclConfig.exe','BFC1E7171D907BB30B5A82FAAC4BED0F','10.35.0',To_Date('2015-12-01 09:23:20', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:55', 'yyyy-mm-dd HH24:mi:ss'),0,'[APPSOFT]',Null,Null,'用于快速配置ORACLE配置文件的工具。',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zlPacsRichPages.ocx','1AECE8FE5ABB73B5DC04BE911A46D289','1.3520.345',To_Date('2016-08-08 15:17:06', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:54', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zlPublicPacs.dll','1','部件功能:封装pacs智能文档编辑器相关处理。系统定位:使用Pacs智能文档编辑器编辑需要。缺失后果:不能使用pacs智能文档编辑器',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlPacsVBCommon.dll','20053050339E704C7A3892B7E7167D1A','10.35.60',To_Date('2017-07-12 11:43:38', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:56', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zl9PACSWork.dll','1','部件功能:封装zlpacs与pacs智能报告编辑器之间的数据交换系统定位:zlpacs整合pacs智能报告编辑器缺失后果:不能使用pacs智能报告编辑器',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlPassInterface.dll','FA31DE179C6538BEA643F5EDB51E0C08','10.35.60',To_Date('2017-07-12 09:35:44', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:56', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zl9CISJob.dll','1','部件功能:合理用药监测部件：集成了美康、大通、太元通、药卫士等合理用药监测接口。系统定位:供临床医生工作站、药品发药组件调用。缺失后果:合理用药监测功能无法启用。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlPeisAutoAnalyse.exe','438B6155E3C5A49B69E029180620D9E3','10.35.60',To_Date('2017-07-12 10:14:52', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:56', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]','ZL9Peis.dll,zl9PeisManage.dll,zl9PeisBase.dll','21','部件功能:体检自动分析服务系统定位:实现非标准的仪器数据接口缺失后果:不能接收到非标准串口的体检仪器数据',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zlPictureEditor.dll','5BF1A349A6B56F62A98B78C568703EC7','10.35.60',To_Date('2017-07-12 09:35:04', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:55', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','ZL9Peis.dll,zl9PeisManage.dll,zlWizardStart.exe,zl9Blood.dll,zl9CISJob.dll,zl9PACSWork.dll,zl9Oper.dll,zl9LisWork.dll,zl9Disease.dll,zl9CISAudit.dll','1','部件功能:用于对图片进行压缩处理系统定位:在病历标记图管理、电子病历编辑、保存过程中对图片进行压缩处理，以便优化处理后存入数据库缺失后果:因固定引用，缺少将无法使用电子病历所有模块',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlPublicAdvice.dll','1DDDA14D651ECB212AD90A9B432F2E50','10.35.60',To_Date('2017-07-12 09:38:50', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:54', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zl9CISJob.dll','1,21,22,24,25','部件功能:封装医嘱核心业务功能，提供公共接口，DOCK页签等。系统定位:封装工作站和医嘱核心业务功能缺失后果:通过该部件去使用临床功能会报错或者失效。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlPublicExpense.dll','EF65B69216C08A43ADCEE554792AF0D4','10.35.60',To_Date('2017-07-12 09:28:06', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:54', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zl9InExse.DLL,zl9OutExse.dll','1','部件功能:费用公共部件。系统定位:提供医生站预约、挂号，医嘱附费等功能，提供公共接口。缺失后果:费用相关功能无法使用',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlPublicLIS.dll','82F09AAB4D403A30A240DFFA3A1262DE','10.35.60',To_Date('2017-07-12 09:38:54', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:54', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','ZL9LabWork.dll','25','部件功能:检验公共部件系统定位:检验业务中的公共部件。主要处理检验相关的业务缺失后果:目前影响输血申请单的使用',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlPublicPacs.dll','FB291D929A6FF65D1E3CF0CFFC35128A','10.35.60',To_Date('2017-07-12 09:44:32', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:54', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zl9PACSWork.dll','1','部件功能:封装PACS依赖业务调用接口系统定位:调用pacs相关的处理功能缺失后果:如临床不能进行pacs观片等',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlPublicPath.dll','97F3F79134D9CC39BBAB344D3105D964','10.35.60',To_Date('2017-07-12 09:44:34', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:54', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zl9CISJob.dll','1','部件功能:临床路径公共接口部件系统定位:提供临床路径开放接口缺失后果:临床路径功能无法正常运行',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlPublicPatient.dll','44C2E394BAA9A05AEE96C77DD1AF440A','10.35.60',To_Date('2017-07-12 09:38:58', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:54', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zl9CISJob.dll,zl9Patient.dll,zl9InPatient.dll','1','部件功能:病人信息公共部件,封装了病人信息相关的公共方法：病人基本信息调整、身份证号反算年龄等。系统定位:供各个业务模块调用。如首页、病人信息管理、病人入院管理的基本信息调整功能。缺失后果:程序无法正常运行',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlPublicPeis.dll','D06D09AE0E7BCFDC603F14AD704BDD65','10.35.0',To_Date('2015-12-01 09:03:42', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:54', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','ZL9Peis.dll,zl9PeisManage.dll','21','部件功能:体检公共接口系统定位:提供其他业务或三方调用体检功能的接口（如生成PDF，查阅体检报告）缺失后果:该接口不能正常工作。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlQueueManage.dll','346378750A3DED47F020459BF2E4EC5F','10.35.60',To_Date('2017-07-12 09:33:14', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:55', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll,zl9PeisManage.dll,zl9RegEvent.dll,zlWizardStart.exe,zl9CISJob.dll,zl9Transfusion.dll','1','部件功能:老板排队业务封装系统定位:老板排队支持缺失后果:不能进行排队管理',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlQueueOper.ocx','FE42E03A328CAE0B8D6606DA7CED6732','10.35.60',To_Date('2017-07-12 10:03:08', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:56', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zl9Oper.dll,zl9PACSWork.dll','1','部件功能:排队叫号业务封装系统定位:pacs排队管理支持缺失后果:不能进行排队操作',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlQueueShow.exe','43EF7141B68BC68C80C4E09C9879A603','10.35.60',To_Date('2017-07-12 10:18:38', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:58', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\ZLQUEUESHOW',Null,'1','部件功能:新版排队显示系统定位:pacs排队情况显示缺失后果:不能显示pacs排队状态',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zlRISDumpTool.exe','6D8EDC1985B9DEE1B6E854F3590CD68B','10.35.60',To_Date('2017-07-12 10:19:18', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 18:50:52', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'1','部件功能:基础数据，用户，诊疗项目，数据字典等初始化系统定位:初始化ris接口数据缺失后果:不能使用ris系统。',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zlRichEPR.DLL','DAD6A3E72B7A42811EBFF520FDCFE68B','10.35.60',To_Date('2017-07-12 11:23:08', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:55', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll,zl9PeisManage.dll,zlWizardStart.exe,zl9Blood.dll,zl9CISJob.dll,zl9PACSWork.dll,zl9Oper.dll,zl9LisWork.dll,zl9Disease.dll,zl9CISAudit.dll,zl9Disease.dll','1','部件功能:病历编辑窗口及业务处理程序系统定位:提供模块：病历标记图形管理、护理记录项目管理、病历文件管理、病历范文管理、诊疗单据设置、移动护士站基础设置、病人病历检索、疾病申报管理缺失后果:病历相关业务无法开展，医生工作站因直接引用，将无法打开。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlRichEditor.ocx','4449F2D6D25CF7AD1A54C9D6C5F8E5FC','10.35.60',To_Date('2017-07-12 09:35:58', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:55', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','ZL9Peis.dll,zl9PeisManage.dll,zlWizardStart.exe,zl9Blood.dll,zl9CISJob.dll,zl9PACSWork.dll,zl9Oper.dll,zl9LisWork.dll,zl9Disease.dll,zl9CISAudit.dll,zl9Disease.dll','1','部件功能:病历编辑核心部件系统定位:提供病历编辑、打印输出功能缺失后果:无法编辑、打印病历',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlScreenKeyboard.exe','B8C3E47A26784CA912ADD4C91B43A991','10.35.0',To_Date('2015-12-01 09:23:05', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:58', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:屏幕键盘小程序系统定位:在门诊医生工作站中用到，强制续诊，门诊医嘱下达缺失后果:强制续诊，门诊医嘱下达不能用使用键盘功能。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlSubclass.ocx','306CC10F864D703B1BE3BA23E8641121','10.35.60',To_Date('2017-07-12 09:35:06', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:55', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','ZL9Peis.dll,zl9PeisManage.dll,zlWizardStart.exe,zl9Blood.dll,zl9CISJob.dll,zl9PACSWork.dll,zl9Oper.dll,zl9LisWork.dll,zl9Disease.dll,zl9CISAudit.dll,zl9Disease.dll','1','部件功能:鼠标、键盘勾子系统定位:用于向病历编辑相关模块提供鼠标、键盘勾子，以便在病历编辑过程中对界面内容进行鼠标控制、控件原有快捷键屏蔽。缺失后果:无法编辑病历',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlSvgProcess.dll','9E00926BA33C621864432B114DF8CE93','1.0.3',To_Date('2015-09-29 16:24:43', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:56', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zl9PACSWork.dll','1','部件功能:svg图像转换使用原因:影像PACS智能报告编辑器检查图像转换缺失后果:不能查看报告图像',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlSvrNotice.exe','2F49E8E5A024578558AD5E63E424D5F2','10.35.60',To_Date('2017-07-12 15:31:48', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:54', 'yyyy-mm-dd HH24:mi:ss'),0,'[APPSOFT]',Null,Null,'部件功能:自动提醒服务。系统定位:进行消息提醒的提示与阅读。缺失后果:无发处理消息提醒。',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zlSvrStudio.exe','153A6BB1200738EF3441A61BFAD65CFD','10.35.60',To_Date('2017-07-12 09:27:24', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:54', 'yyyy-mm-dd HH24:mi:ss'),0,'[APPSOFT]',Null,Null,'部件功能:ZLHIS系统的后台管理工具。系统定位:提供了系统的升级、安装、授权以及其他的实用功能，可以方便的进行后台管理。缺失后果:缺失该部件将会导致无法进行系统管理操作。',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zlSwitchEffect.dll','55968705B856B2947F168E114D35309C','10.35.0',To_Date('2015-12-01 09:22:27', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:53', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','26','部件功能:实现自助页面切换效果系统定位:实现自助页面切换效果缺失后果:自助页面切换时没有切换变换效果，直接切换。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlSwitchPage.dll','EDB7BEA3A23946049A12248AC02AD01E','10.35.0',To_Date('2015-12-01 09:22:25', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:53', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','26','部件功能:实现自助页面切换效果系统定位:实现自助页面切换效果缺失后果:没有切换效果',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlTable.ocx','A700E527297F3B63CCEE7B9CD6AC4937','10.35.60',To_Date('2017-07-12 09:35:36', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:55', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','ZL9Peis.dll,zl9PeisManage.dll,zlWizardStart.exe,zl9Blood.dll,zl9CISJob.dll,zl9PACSWork.dll,zl9Oper.dll,zl9LisWork.dll,zl9Disease.dll,zl9CISAudit.dll,zl9Disease.dll','1','部件功能:向病历编辑过程中提供自定义内嵌表格支持系统定位:全文式病历编辑过程中，插入表格后编辑生成对应的表格图，以及后续编辑时再次进行编辑转换、以提供检查报告图组缺失后果:无法进行内嵌表格编辑',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlTableEPR.dll','6C32AD9871B32AF8E33955F48B006D39','10.35.60',To_Date('2017-07-12 09:35:34', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:55', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll,zl9PeisManage.dll,zlWizardStart.exe,zl9Blood.dll,zl9CISJob.dll,zl9PACSWork.dll,zl9Oper.dll,zl9LisWork.dll,zl9Disease.dll,zl9CISAudit.dll,zl9Disease.dll','1','部件功能:表格式病历核心编辑器系统定位:用于以表格式病历进行编辑的主窗口、表格式病历的打印缺失后果:无法进行表格式病历编辑',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlUpgradeReader.exe','2DF57EB30F1214EE268EEE008E7B61F4','10.35.60',To_Date('2017-07-12 15:31:50', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 18:50:52', 'yyyy-mm-dd HH24:mi:ss'),0,'[APPSOFT]',Null,Null,'部件功能:升级说明阅读器。系统定位:进行重大功能的核对以及培训事宜的处理。缺失后果:无法进行升级问题清单的阅读与核对。',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zlWizardNewLabPrint.dll','BE6EF93F7126B2FCF17B7DDE98BCFFD1','10.35.60',To_Date('2017-07-12 10:12:24', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:53', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','25,26','部件功能:导诊新版LIS打印部件系统定位:在导诊系统中，进行新版LIS报告打印缺失后果:新版LIS报告将不能正常打印',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlWizardPacsPrint.dll','1857665077DF661235E16FE669785B12','10.35.60',To_Date('2017-07-12 11:11:30', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:53', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','26','部件功能:pacs报告自助打印系统定位:提供患者自助服务系统支持缺失后果:不能进行pacs自助打印',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlWizardStart.exe','14029204C6A739B289740B2C11DE733E','10.35.60',To_Date('2017-07-12 15:31:50', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:53', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]',Null,'26','部件功能:自助系统前台查询启动程序系统定位:启动自助系统前台功能缺失后果:不能运行自助系统前台查询',0,0,Null);

--系统版本号
Update zlSystems Set 版本号='10.35.60' Where 编号=&n_System;
--部件版本号
Commit;
