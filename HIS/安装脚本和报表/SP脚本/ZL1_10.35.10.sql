--[连续升级]1
--[管理工具版本号]10.35.0
--本脚本支持从ZLHIS+ v10.35.0 升级到 v10.35.10
--请以系统所有者登录PLSQL并执行下列脚本
--脚本执行后，请手工升级导出报表
Define n_System=100;
-------------------------------------------------------------------------------
--结构修正部份
------------------------------------------------------------------------------- 
--92384:胡俊勇,2016-04-15,医嘱待执行消息
alter table 业务消息清单 modify 业务标识 VARCHAR2(4000);
--95281:王振涛,2016-04-15,字段值不一致
alter table 检验细菌 modify 默认结果 VARCHAR2(200);
--94399:李小东,2016-04-08,部门、人员扩展信息维护
Create Table 部门扩展项目
(
  编码 Number(3),
  名称 Varchar2(20),
  是否图片  Number(1)
)TABLESPACE zl9BaseItem
 Cache Storage(Buffer_Pool Keep);

Create Table 部门扩展信息
(
  部门id Number(18),
  项目 Varchar2(20),
  内容 Varchar2(1000),
  图片 Blob
)TABLESPACE zl9BaseItem;

Create Table 人员扩展项目
(
  编码 Number(3),
  名称 Varchar2(20),
  是否图片  Number(1)
)TABLESPACE zl9BaseItem
 Cache Storage(Buffer_Pool Keep);

Create Table 人员扩展信息
(
  人员id Number(18),
  项目 Varchar2(20),
  内容 Varchar2(1000),
  图片 Blob
)TABLESPACE zl9BaseItem;

Alter Table 部门表 Add 顺序 Number(3);

Alter Table 人员表 Add 顺序 Number(3);

Alter Table 部门扩展项目 Add Constraint 部门扩展项目_PK Primary Key (编码) Using Index Tablespace zl9indexhis;

Alter Table 部门扩展信息 Add Constraint 部门扩展信息_FK_部门id Foreign Key (部门id) References 部门表(id) On Delete Cascade;

Alter Table 部门扩展项目 Add Constraint 部门扩展项目_UQ_名称 Unique (名称) Using Index Tablespace zl9indexhis;

Alter Table 部门扩展信息 Add Constraint 部门扩展信息_FK_项目 Foreign Key (项目) References 部门扩展项目(名称) On Delete Cascade;

Alter Table 部门扩展信息 Add Constraint 部门扩展信息_UQ_部门id Unique (部门id,项目) Using Index Tablespace zl9indexhis;

Alter Table 部门扩展信息 Modify 项目 Constraint 部门扩展信息_NN_项目 Not Null;

Alter Table 人员扩展项目 Add Constraint 人员扩展项目_PK Primary Key (编码) Using Index Tablespace zl9indexhis;

Alter Table 人员扩展信息 Add Constraint 人员扩展信息_FK_人员id Foreign Key (人员id) References 人员表(id) On Delete Cascade;

Alter Table 人员扩展项目 Add Constraint 人员扩展项目_UQ_名称 Unique (名称) Using Index Tablespace zl9indexhis;

Alter Table 人员扩展信息 Add Constraint 人员扩展信息_FK_项目 Foreign Key (项目) References 人员扩展项目(名称) On Delete Cascade;

Alter Table 人员扩展信息 Add Constraint 人员扩展信息_UQ_人员id Unique (人员id,项目) Using Index Tablespace zl9indexhis;

Alter Table 人员扩展信息 Modify 项目 Constraint 人员扩展信息_NN_项目 Not Null;

Create Index 部门扩展信息_IX_项目 On 部门扩展信息(项目) Tablespace zl9Indexhis;

Create Index 人员扩展信息_IX_项目 On 人员扩展信息(项目) Tablespace zl9Indexhis;

--93444:刘尔旋,2016-04-06,机器名字段大小调整
Alter Table 挂号序号状态 Modify 机器名 varchar2(200);

--94851:涂建华,2016-04-05,Pacs文档编辑器词句或插件加载时机
Alter Table 影像报告原型清单 Add 词句加载时机 Number(1);
Alter Table 影像报告原型清单 Add 插件加载时机 Number(1);

--94427:刘尔旋,2016-03-29,医嘱发送生成条码接口
Alter Table 医疗卡类别 Add 发送调用接口 Number(3) Default 0;

--94337:刘尔旋,2016-03-22,是否持卡消费
Alter Table 医疗卡类别 Add 是否持卡消费 Number(3) Default 1;

--90040:梁经伙,2016-03-17,增加身份证未录原因，如果存在 身份证号状态 表，则改名为 身份证未录原因   
Declare
Begin
    If Zl_Checkobject(1, '身份证号状态') > 0 Then
		Execute Immediate 'ALTER TABLE 身份证号状态 RENAME TO 身份证未录原因';
		Execute Immediate 'alter table 身份证未录原因 drop Constraint 身份证号状态_PK Cascade Drop Index';
		Execute Immediate 'alter table 身份证未录原因 drop Constraint 身份证号状态_UQ_名称 Cascade Drop Index';  
    End If;
  Exception
    When Others Then
      Null;
End;
/

--不用动态SQL，避免对象修正检查功能的识别问题
Create Table 身份证未录原因(
    编码 VARCHAR2(2),
    名称 VARCHAR2(50),
    简码 VARCHAR2(10),
    缺省标志 NUMBER(1) default 0,
    说明 VARCHAR2(50))
    TABLESPACE zl9BaseItem;

Alter Table 身份证未录原因 Add Constraint 身份证未录原因_PK Primary Key (编码) Using Index Tablespace zl9Indexcis;
Alter Table 身份证未录原因 Add Constraint 身份证未录原因_UQ_名称 Unique (名称) Using Index Tablespace zl9Indexhis;

--91660:梁经伙,2016-02-03,病人抗生素记录，将唯一键增加“使用阶段”字段。

Alter table 病人抗生素记录 drop constraint 病人抗生素记录_UQ_病人ID Cascade Drop Index;

Alter Table 病人抗生素记录 Add Constraint 病人抗生素记录_UQ_病人ID Unique (病人Id,主页Id,药名id,药品名称,用药目的,使用阶段) Using Index Tablespace zl9Indexhis;

--92729:胡俊勇,2016-01-26,专业版RIS接口处理
Create Table RIS检查预约 (
医嘱ID  NUMBER(18),
预约ID   NUMBER(18),
预约日期  DATE,
检查设备ID  NUMBER(18),
检查设备名称  VARCHAR2(64),
预约开始时间  DATE,
预约结束时间  DATE,
预约开始时间段  DATE,
预约结束时间段  DATE,
待转出  NUMBER(3))     
TABLESPACE zl9CisRec;

Alter Table RIS检查预约 Add Constraint RIS检查预约_PK Primary Key(医嘱ID) Using Index Tablespace zl9Indexhis;
Alter Table RIS检查预约 Add Constraint RIS检查预约_FK_医嘱ID Foreign Key (医嘱ID) References 病人医嘱记录(ID) On Delete Cascade;
Create Index RIS检查预约_IX_待转出 On RIS检查预约(待转出) Tablespace zl9Indexcis;

--91776:蔡青松,2016-01-21,新增序列 病人医嘱发送_标本发送批号
Create Sequence 病人医嘱发送_标本发送批号 Start With 1;

--92373:刘硕,2016-01-04,病人诊断记录增加外键
Alter Table 病人诊断记录 Add Constraint 病人诊断记录_FK_疾病id Foreign Key (疾病id) References 疾病编码目录(ID) novalidate;
Alter Table 病人诊断记录 Add Constraint 病人诊断记录_FK_诊断id Foreign Key (诊断id) References 疾病诊断目录(ID) novalidate;
Alter Table 病人诊断记录 Add Constraint 病人诊断记录_FK_证候id Foreign Key (证候id) References 疾病编码目录(ID) novalidate;
--92373:刘硕,2016-01-04,病人诊断记录增加外键
Create Index 病人诊断记录_IX_疾病id On 病人诊断记录(疾病id) Pctfree 5 Tablespace zl9Indexcis Nologging;
Create Index 病人诊断记录_IX_诊断id On 病人诊断记录(诊断id) Pctfree 5 Tablespace zl9Indexcis Nologging;
Create Index 病人诊断记录_IX_证候id On 病人诊断记录(证候id) Pctfree 5 Tablespace zl9Indexcis Nologging;

--92840:李业庆,2016-01-19,疾病诊断参考增加停用/启用功能
Alter Table 疾病诊断目录 Add(建档时间 DATE ,撤档时间 DATE);

--91780:刘尔旋,2015-12-28,相同发票号轧帐
Alter Table 人员收缴票据 Add 批次 Varchar2(20);

--91427:马政,2015-12-22,新增药品验收系统
create table 药品验收记录
(
id number(18),
NO varchar2(8),
库房id number(18),
供药单位id number(18),
验收人 varchar2(200),
验收日期 date,
复核人 varchar2(200),
复核日期 date,
是否合格 number(1),
备注  varchar2(1000)
) TABLESPACE zl9MedLst;

create table 药品验收明细 
(
验收id number(18),
药品id number(18),
成本价 number(16,7),
零售价 number(16,7),
进药数量 number(16,5),
批号 varchar2(20),
生产日期 date,
效期 date,
产地 varchar2(60),
批准文号 varchar2(40),
进药日期 date,
是否合格 number(1)
) TABLESPACE zl9MedLst;

Create Sequence 药品验收记录_ID Start With 1; 

Alter Table 药品验收记录 Add Constraint 药品验收记录_PK Primary Key (ID) Using Index Tablespace zl9indexhis;

Alter Table 药品验收明细 Add Constraint 药品验收明细_UQ_验收ID Unique (验收id,药品id) Using Index Tablespace zl9indexhis;

Alter Table 药品验收明细 Modify 验收id Constraint 药品验收明细_NN_验收id Not Null;   

Create Index 药品验收记录_IX_供药单位id On 药品验收记录(供药单位id) Tablespace zl9Indexhis;   

Create Index 药品验收记录_IX_NO On 药品验收记录(NO) Tablespace zl9Indexhis;  

Create Index 药品验收明细_IX_药品id On 药品验收明细(药品id) Tablespace zl9Indexhis;  

--91225:梁经伙,2015-12-16,传染病管理系统 基本数据
create table 传染病目录(
   编码 VARCHAR2(20),
   名称 VARCHAR2(200), 
   简码 VARCHAR2(200), 
   说明 VARCHAR2(500)
) TABLESPACE zl9EprDat;

create table 疾病阳性记录(
   ID    Number(18),
   病人ID number(18), 
   主页id NUMBER(5),
   挂号单 VARCHAR2(8),
   医嘱ID NUMBER(18),
   送检时间 date,
   送检科室ID number(18), 
   送检医生 VARCHAR2(201), 
   标本名称 VARCHAR2(64),
   反馈结果 VARCHAR2(1000),
   传染病名称 VARCHAR2(200),
   检查时间 date,
   登记时间 date,
   登记人 VARCHAR2(100),
   登记科室ID number(18), 
   记录状态 number(2),
   处理人 VARCHAR2(100),
   处理时间 date,
   处理情况说明 VARCHAR2(1000),
   文件ID number(18),
   待转出 Number(3)
) TABLESPACE zl9EprDat;

create table 疾病报告反馈(
   文件ID NUMBER(18),
   登记时间 date, 
   登记人 VARCHAR2(100),
   记录状态 NUMBER(3),
   反馈内容 VARCHAR2 (500),
   处理人 VARCHAR2(100),
   处理时间 date,
   处理情况说明 VARCHAR2(500),
   待转出 Number(3)
) TABLESPACE zl9EprDat;

alter table 疾病申报记录 Add(报卡类型 VARCHAR2(50),报告医生 VARCHAR2(100),撤档人 VARCHAR2(100),撤档时间 Date,病人ID NUMBER(18),主页ID NUMBER(18),病人来源 NUMBER(3));

Create Sequence 疾病阳性记录_ID Start With 1;

Alter Table 传染病目录 Add Constraint 传染病目录_PK Primary Key (编码) Using Index Tablespace zl9Indexcis;

Alter Table 传染病目录 Add Constraint 传染病目录_UQ_名称 Unique (名称) Using Index Tablespace zl9Indexhis;

Alter Table 疾病阳性记录 Add Constraint 疾病阳性记录_PK Primary Key (ID) Using Index Tablespace zl9Indexcis;

Alter Table 疾病报告反馈 Add Constraint 疾病报告反馈_PK Primary Key (文件ID,登记时间) Using Index Tablespace zl9Indexcis;

Create Index 疾病阳性记录_IX_病人ID On 疾病阳性记录(病人ID,主页ID)  Tablespace zl9Indexcis;

Create Index 疾病阳性记录_IX_登记时间 On 疾病阳性记录(登记时间)  Tablespace zl9Indexcis;

Create Index 疾病阳性记录_IX_挂号单 On 疾病阳性记录(挂号单)  Tablespace zl9Indexcis;

Create Index 疾病阳性记录_IX_待转出 On 疾病阳性记录(待转出) Tablespace zl9Indexcis;

Create Index 疾病阳性记录_IX_文件ID On 疾病阳性记录(文件ID) Tablespace zl9Indexcis;

Create Index 疾病申报记录_IX_姓名 On 疾病申报记录(姓名) Tablespace zl9Indexcis;

Create Index 疾病申报记录_IX_病人ID On 疾病申报记录(病人ID,主页ID)  Tablespace zl9Indexcis;

Create Index 疾病报告反馈_IX_待转出 On 疾病报告反馈(待转出) Tablespace zl9Indexcis;

Create Index 疾病报告反馈_IX_登记时间 On 疾病报告反馈(登记时间) Tablespace zl9Indexcis;

Create Index 疾病阳性记录_IX_医嘱ID On 疾病阳性记录(医嘱ID) Tablespace zl9Indexcis;

--91687:余智勇,2015-12-15,增加索引
Create Index 门诊穿刺台_Ix_待穿病人id On 门诊穿刺台(待穿病人id) Pctfree 5 Tablespace Zl9indexcis Nologging;

--91712:涂建华,2015-12-16,病理玻片信息外键索引修正
Create Index 病理玻片信息_IX_病理医嘱ID On 病理玻片信息(病理医嘱ID) Tablespace zl9Indexcis nologging;

--91225:梁经伙,2015-12-16,传染病管理系统 基本数据
Alter Table 疾病阳性记录 Add Constraint 疾病阳性记录_FK_病人ID Foreign Key (病人ID) References 病人信息(病人ID);
Alter Table 疾病阳性记录 Add Constraint 疾病阳性记录_FK_主页ID Foreign Key (病人ID,主页ID) References 病案主页(病人ID,主页ID);
Alter Table 疾病阳性记录 Add Constraint 疾病阳性记录_FK_送检科室ID Foreign Key (送检科室ID) References 部门表(ID);
Alter Table 疾病阳性记录 Add Constraint 疾病阳性记录_FK_登记科室ID Foreign Key (登记科室ID) References 部门表(ID);
Alter Table 疾病阳性记录 Add Constraint 疾病阳性记录_FK_医嘱ID Foreign Key (医嘱ID) References 病人医嘱记录(ID);
Alter Table 疾病报告反馈 Add Constraint 疾病报告反馈_FK_文件ID Foreign Key (文件ID) References 疾病申报记录 (文件ID) On Delete Cascade;
Alter Table 疾病申报记录 Add Constraint 疾病申报记录_FK_病人ID Foreign Key (病人ID) References 病人信息 (病人ID);

--91427:马政,2015-12-22,新增药品验收系统
Alter Table 药品验收记录 Add Constraint 药品验收记录_FK_库房id Foreign Key (库房id) References 部门表(ID) On Delete Cascade;
Alter Table 药品验收记录 Add Constraint 药品验收记录_FK_供药单位id Foreign Key (供药单位id) References 供应商(ID) On Delete Cascade;
Alter Table 药品验收明细 Add Constraint 药品验收明细_FK_验收id Foreign Key (验收id) References 药品验收记录(ID) On Delete Cascade;
Alter Table 药品验收明细 Add Constraint 药品验收明细_FK_药品id Foreign Key (药品id) References 收费项目目录(ID) On Delete Cascade;

--91225:梁经伙,2016-3-7,修改 疾病阳性记录，传染病记录表里面的字段长度
alter table 传染病目录 modify  编码  VARCHAR2(20);
alter table 疾病阳性记录 modify  标本名称 varchar2(64);
alter table 疾病阳性记录 modify  送检医生 VARCHAR2(100);
alter table 传染病目录 modify  (名称 varchar2(150),简码 VARCHAR2(20),说明 VARCHAR2(200));

-------------------------------------------------------------------------------
--数据修正部份
-------------------------------------------------------------------------------
--94980:余智勇,2016-04-08,移动循环呼叫病人
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1264, 0, 1, 0, 0, -null, -null, 13, '移动呼叫', '0', '0',
         '此参数开启后，门诊输液管理定时循环呼叫移动业务的病人', '0-不呼叫，1-呼叫', Null, Null, Null
  From Dual;

--94399:李小东,2016-04-08,部门、人员扩展信息维护
Insert Into zlBaseCode(系统, 表名, 固定, 说明, 分类) Values (&n_System, '部门扩展项目', 0, '部门扩展项目说明', '部门属性');

Insert Into zlBaseCode(系统, 表名, 固定, 说明, 分类) Values (&n_System, '人员扩展项目', 0, '人员扩展项目说明', '人员属性');

--94456:马政,2016-04-06,卫材领用不明确批次领用改进
Insert Into zlParameters
  (ID, 系统, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 0, 0, 258, '按批次领用卫生材料', '0', '1', '当该参数启用之后，领用时要确定具体批次，否则不用确定具体批次',
         '0-不启用，1-启用。', Null, Null, Null
  From Dual;

--90040:梁经伙,2016-03-10,增加身份证未录原因字典表的默认数据
Insert Into 身份证未录原因
  (编码, 名称, 简码)
  Select '01', '未带', 'WD' From Dual Where Not Exists (Select 1 From 身份证未录原因 Where 编码 = '01');
Insert Into 身份证未录原因
  (编码, 名称, 简码)
  Select '02', '遗失待办', 'YSDB' From Dual Where Not Exists (Select 1 From 身份证未录原因 Where 编码 = '02');
Insert Into 身份证未录原因
  (编码, 名称, 简码)
  Select '03', '未办', 'WB' From Dual Where Not Exists (Select 1 From 身份证未录原因 Where 编码 = '03');

--90040:梁经伙,2016-03-17,如果zlBaseCode表里面已经存在身份证号状态表的数据就直接修改
update zlBaseCode set 表名 = '身份证未录原因' where 系统 = &n_System and 表名 = '身份证号状态';
--90040:梁经伙,2016-03-10,增加身份证未录原因字典表
Insert Into zlBaseCode
  (系统, 表名, 固定, 说明, 分类)
  Select &n_System, '身份证未录原因', 0, '病人身份证号码未录入的原因', '人员属性'
  From Dual;

--93917:许华峰,2016-03-07,与RIS的数据交换接口脚本
Insert Into zlComponent(部件,名称,主版本,次版本,附版本,系统,注册产品名称,注册产品简名,注册产品版本) Values('zl9XWInterface','影像信息系统工作部件',10,35,10,&n_System,'中联医学影像系统','ZLPACS','10.9.0'); 
Insert Into zlPrograms(序号,标题,说明,系统,部件) Values( 1287,'医学影像信息系统专业版','影像RIS和PACS系统',&n_System,'zl9XWInterface'); 

Insert Into zlMenus(组别,ID,上级ID,标题,快键,系统,模块,短标题,图标,说明)
	Select 组别,Zlmenus_Id.Nextval,ID,'医学影像信息系统专业版' ,'B' ,&n_System,-NULL ,'医学影像信息系统专业版' ,99 ,'影像RIS和PACS系统' 
         From zlMenus Where 标题 = '医学影像系统' And 组别 = '缺省' And 系统 = &n_System And 模块 Is Null;                 

Insert Into zlMenus(组别,ID,上级ID,标题,快键,系统,模块,短标题,图标,说明) 
	Select A.组别,ZlMenus_ID.Nextval,A.ID,B.* From (
	     Select 组别,ID From zlMenus Where 标题 = '医学影像信息系统专业版' And 组别 = '缺省' And 系统 = &n_System And 模块 Is Null) A,
	    (Select 标题,快键,系统,模块,短标题,图标,说明 From zlMenus Where 1 = 0 Union All
	Select '医学影像信息系统专业版' ,'R'  ,&n_System, 1287, '影像信息工作站' ,99, '影像RIS和PACS工作站'  From Dual Union All						
                 Select 标题,快键,系统,模块,短标题,图标,说明 From zlMenus Where 1 = 0) B; 

--93311:张德婷,2016-02-24,发送医嘱的时候不允许置换药房到静配
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1345, 0, 0, 0, 0, 0, 0, 34, '不允许置换药房到输液配置中心', '0', '0',
         '此参数开启后，发送医嘱的时候不允许置换药房到输液配置中心', '0-不是，1-是', Null, Null, Null
  From Dual;

--92384:胡俊勇,2016-02-24,医嘱待执行消息
Insert Into 业务消息类型(编码,名称,说明,保留天数)  Select 'ZLHIS_CIS_034','待执行医嘱提醒','医嘱发送后有需要执行登记的医嘱，产生的一个待执行通消息。',7 From Dual;

--91331:张德婷,2016-02-22,界面按照批次药品进行排序
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1345, 0, 0, 0, 0, 0, 0, 28, '按批次，药品排序', '0',
         '0', '此参数勾选之后，界面上的所有药品按批次，药品进行排序。', '0-不启用，1-启用。', Null, Null, Null
  From Dual;

--92537:梁经伙,2016-02-17,增加参数 诊断手术名称自由调整 控制诊断手术的自由调整
Insert Into Zlparameters
  (Id, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, -NULL, 0, 0, 0, 0, 0, 0, 257, '诊断手术名称自由调整', '0', '0',
         '控制是否启用诊断和手术的自由调整功能，启用后，住院，门诊和诊断选择器的诊断描述和手术名称可以自由修改。', '0-未启用;1-启用', NULL, NULL, Null
  From Dual;

--92729:胡俊勇,2016-01-26,专业版RIS接口处理
Insert Into zlBakTables(系统,组号,表名,序号,直接转出,停用触发器)
Select &n_System,8,A.* From (
Select 表名,序号,直接转出,停用触发器 From zlBakTables Where 1 = 0 Union All
Select 'RIS检查预约',21,1,-NULL From Dual Union All
Select 表名,序号,直接转出,停用触发器 From zlBakTables Where 1 = 0) A;

--91265:张德婷,2015-01-21
update 诊疗检查部位 set 方法=substr(方法,1,instr(方法,chr(9),1)) || replace(substr(方法,instr(方法,chr(9),1)+1),';',chr(9))   where  instr(方法,chr(9),1)>0;


-- 92718:黄捷,2016-1-14,启用影像信息系统接口控制
--92718:许华峰,2016-02-26,启用影像信息系统接口控制
Insert Into Zlparameters
  (Id, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, -null, -null, -null, -null, -null, 0, 0, 255, '启用医学影像信息系统专业版接口', '0', '0',
         '控制是否启用影像信息系统接口。', '0-未启用;1-启用', '必须安装影像信息系统的才生效。', '适用于安装了影像信息系统，但不想启用影像信息系统流程的方式。', Null
  From Dual;


--89717:余伟节,2016-01-14,出院后不允许取消完成路径
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1256, 0, 0, 0, 0, 0, 0, 13, '出院后不允许取消完成路径', '0', '0',
         '如果启用此参数，出院的病人不允许取消完成的路径。', '0-不启用，1-启用。', Null, Null, Null
  From Dual;

--91956:张德婷,2015-12-16,当不启用常用药品时按药品对应的输液单数量进行排序
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1345, 0, 0, 0, 0, 0, 0, 32, '是否按设置的常用药品进行药品过滤操作', '0', '1',
         '不根据设置的常用药品过滤输液单的时候，药品是根据当天输液单的汇总数量确定', '0-不是，1-是',Null, Null, Null
  From Dual;

--88843:刘硕,2016-01-11,自定义过程管理
Declare
  v_Procs1 Varchar2(4000);
  v_Procs2 Varchar2(4000);
Begin
  v_Procs1 := 'Zl_Get_Queuedate^获得排队时间oracle函数，渠道技术人员可以通过修改该函数，来获得用户需要的排队时间规则#' ||
              'Zlgetnextqueue^获得排队号码的oracle函数，渠道技术人员可以通过修改该函数，来获得用户需要的排队号码规则#' ||
              'ZLgetSequenceNum^获得排队序号的oracle函数，渠道技术人员可以通过修改该函数，来获得用户需要的排队序号规则#' ||
              'zl_GetSequenceBeforPerons^获取当前队列前面还有多少人数在排队#Zl_Billclass^根据病人获取发票的使用类别#' ||
              'Zl_Custom_Invoice_Autoallot^票据分配规则(根据医院的特殊要求,分配票据)#' ||
              'ZL_ADVICESENDCHECK^门诊医嘱发送时，对医嘱的相关内容进行检查，并返回提示及处理结果。#' ||
              'ZL_ADVICECHECK^门诊和住院医嘱新开和修改时，保存数据之前对医嘱的相关内容进行检查，并返回提示及处理结果。#' ||
              'Zl_Fun_Bloodapplyrate^输血申中，根据自定义的方式显示指标结果#' ||
              'zl_fun_CustomExpenses^医嘱发送时，如果收费对照为自定义的，则会调用此过程，决定该收费项目是否收取，收取的次数#' ||
              'zl_fun_PIVACustom^获取配置中心每个输液单应该收取的材料费的材料id， 渠道可根据具体的业务定制业务规则#' || 'zl_PatiWarnScheme^记账报警方案选择函数#' ||
              'Zl_Third_GetDeptList^获取可挂号科室。具体入参、出参、返回值说明，详见《vssData/DataStructure/中联三方接口说明(Oracle).xlsx》#' ||
              'Zl_Third_GetNoList^获取号源列表。具体入参、出参、返回值说明，详见《vssData/DataStructure/中联三方接口说明(Oracle).xlsx》#' ||
              'Zl_Third_LockNO^HIS锁号。具体入参、出参、返回值说明，详见《vssData/DataStructure/中联三方接口说明(Oracle).xlsx》#' ||
              'Zl_Third_Regist^HIS挂号。具体入参、出参、返回值说明，详见《vssData/DataStructure/中联三方接口说明(Oracle).xlsx》#' ||
              'Zl_Third_RegHistory^获取挂号历史数据。具体入参、出参、返回值说明，详见《vssData/DataStructure/中联三方接口说明(Oracle).xlsx》#' ||
              'Zl_Third_RegistDelCheck^取消挂号检查。具体入参、出参、返回值说明，详见《vssData/DataStructure/中联三方接口说明(Oracle).xlsx》#' ||
              'Zl_Third_RegistDel^取消挂号。具体入参、出参、返回值说明，详见《vssData/DataStructure/中联三方接口说明(Oracle).xlsx》#' ||
              'Zl_Third_DocArrange^获取医生排班计划。具体入参、出参、返回值说明，详见《vssData/DataStructure/中联三方接口说明(Oracle).xlsx》#' ||
              'Zl_Third_GetMoney^获取项目的实收金额。具体入参、出参、返回值说明，详见《vssData/DataStructure/中联三方接口说明(Oracle).xlsx》#' ||
              'Zl_Third_SaleRegInfo^获取病人费别与项目的实收金额。具体入参、出参、返回值说明，详见《vssData/DataStructure/中联三方接口说明(Oracle).xlsx》#' ||
              'zl_Third_Custom_FindCards^zl_Third_FindCards过程中调用，渠道自定义过程，用以获取需要的病人卡信息。具体入参、出参、返回值说明，详见《vssData/DataStructure/中联三方接口说明(Oracle).xlsx》#' ||
              'zl_Third_Custom_GetPati^zl_Third_GetPati_Unique过程中调用，渠道自定义函数，用以获取需要的病人ID。具体入参、出参、返回值说明，详见《vssData/DataStructure/中联三方接口说明(Oracle).xlsx》#' ||
              'zl_Third_GetVisitDetails^根据挂号单号获取该次就诊详情(费用为准)。具体入参、出参、返回值说明，详见《vssData/DataStructure/中联三方接口说明(Oracle).xlsx》#' ||
              'zl_Third_GetVisitInfo^根据挂号单号获取该次就诊详情(医嘱为准)。具体入参、出参、返回值说明，详见《vssData/DataStructure/中联三方接口说明(Oracle).xlsx》';

  v_Procs2 := 'zl_Third_waitingpay^获取待付款单据。具体入参、出参、返回值说明，详见《vssData/DataStructure/中联三方接口说明(Oracle).xlsx》#' ||
              'Zl_Third_Payment^收费结算接口。具体入参、出参、返回值说明，详见《vssData/DataStructure/中联三方接口说明(Oracle).xlsx》#' ||
              'Zl_Third_PaymentInfo^获取指定单据交易信息。具体入参、出参、返回值说明，详见《vssData/DataStructure/中联三方接口说明(Oracle).xlsx》#' ||
              'Zl_Third_Charge_DelCheck^单据进行退款前的检查。具体入参、出参、返回值说明，详见《vssData/DataStructure/中联三方接口说明(Oracle).xlsx》#' ||
              'Zl_Third_Charge_Del^根据指定单据的指费用来进行退款。具体入参、出参、返回值说明，详见《vssData/DataStructure/中联三方接口说明(Oracle).xlsx》#' ||
              'ZL_Third_Deposit_ReCharge^预交款充值接口。具体入参、出参、返回值说明，详见《vssData/DataStructure/中联三方接口说明(Oracle).xlsx》#' ||
              'zl_Third_GetAlarmline^获取记帐报警信息。具体入参、出参、返回值说明，详见《vssData/DataStructure/中联三方接口说明(Oracle).xlsx》#' ||
              'ZL_Third_GetSettlement^获取住院结帐详情。具体入参、出参、返回值说明，详见《vssData/DataStructure/中联三方接口说明(Oracle).xlsx》#' ||
              'ZL_Third_Settlement^结帐费用结算。具体入参、出参、返回值说明，详见《vssData/DataStructure/中联三方接口说明(Oracle).xlsx》';
  For Rs In (Select a.名称, a.说明, b.Id
             From (Select Upper(C1) 名称, C2 说明
                    From Table(f_Str2list2(v_Procs1, '#', '^'))
                    Union All
                    Select Upper(C1) 名称, C2 说明
                    From Table(f_Str2list2(v_Procs2, '#', '^'))) a, Zlprocedure b
             Where a.名称 = Upper(b.名称(+))) Loop
    If Rs.Id Is Null Then
      Insert Into Zlprocedure
        (Id, 类型, 名称, 状态, 所有者, 说明)
        Select Zltools.Zlprocedure_Id.Nextval, 2, Upper(Rs.名称), 3, User, Rs.说明 From Dual;
    Else
      Update Zltools.Zlprocedure Set 说明 = Rs.说明, 类型 = 2 Where Id = Rs.Id;
    End If;
  End Loop;
End;
/

--92373:刘硕,2016-01-04,病人诊断记录增加外键
Declare
  --测试数据700W,修正数据3W,耗时35s
  Cursor c_Pati Is
    Select a.Id, b.Id 疾病id, c.Id 诊断id, d.Id 证候id
    From 病人诊断记录 a, 疾病编码目录 b, 疾病诊断目录 c, 疾病编码目录 d
    Where a.疾病id = b.Id(+) And a.诊断id = c.Id(+) And a.证候id = d.Id(+) And
          (Nvl(a.疾病id, 0) <> Nvl(b.Id, 0) Or Nvl(a.诊断id, 0) <> Nvl(c.Id, 0) Or Nvl(a.证候id, 0) <> Nvl(d.Id, 0));
  t_Id         t_Numlist := t_Numlist();
  t_疾病id     t_Numlist := t_Numlist();
  t_诊断id     t_Numlist := t_Numlist();
  t_证候id     t_Numlist := t_Numlist();
  n_Array_Size Number := 10000;
Begin
  Begin
    Execute Immediate ' Create Table 病人诊断记录_Bak92373 As
    Select a.Id, a.疾病id, a.诊断id, a.证候id
    From 病人诊断记录 a, 疾病编码目录 b, 疾病诊断目录 c, 疾病编码目录 d
    Where a.疾病id = b.Id(+) And a.诊断id = c.Id(+) And a.证候id = d.Id(+) And
          (Nvl(a.疾病id, 0) <> Nvl(b.Id, 0) Or Nvl(a.诊断id, 0) <> Nvl(c.Id, 0) Or Nvl(a.证候id, 0) <> Nvl(d.Id, 0))';
  Exception
    When Others Then
      Null;
  End;

  Open c_Pati;
  Loop
    Fetch c_Pati Bulk Collect
      Into t_Id, t_疾病id, t_诊断id, t_证候id Limit n_Array_Size;
    Exit When t_Id.Count = 0;
    Forall i In 1 .. t_Id.Count
      Update 病人诊断记录 Set 疾病id = t_疾病id(i), 诊断id = t_诊断id(i), 证候id = t_证候id(i) Where Id = t_Id(i);
  End Loop;
  Close c_Pati;
End;
/

--92840:李业庆,2016-01-19,更新建档时间
Declare
  d_Time 疾病编码目录.建档时间%Type;
Begin

  Begin
    Select 安装日期 Into d_Time From zlSystems Where Upper(所有者) = Zl_Owner And 编号 = '100';
  Exception
    When Others Then
      d_Time := Sysdate;
  End;

  Update 疾病诊断目录 Set 建档时间 = d_Time , 撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD')  Where 建档时间 Is Null;
End;
/

--91671:胡俊勇,2015-12-30,主刀医师达到手术等级无需审核
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, -Null, -Null, -Null, -Null, -Null,-Null, -Null, 254, '主刀医师达到手术等级无需审核', '0', '0',
  '启用参数后控制：下达手术医嘱时，如果主刀医师满足手术等级要求（手术授权管理未启动就是按医生手术等级来）；则无需审核，可直接校对；'|| Chr(13) ||'如果主刀医师不满足(低于)手术项目等级时，才需要审核；','0-不启用，1-启用。', Null, Null, Null
  From Dual;

--91225:梁经伙,2015-12-29,疾病报告设置中新增加参数 传染病报告身份证号码必填
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1277, 0, 0, 0, 0, 0, 0, 2, '传染病报告身份证号码必填', '0', '0',
         '中华人民共和国传染病报告卡 中身份证号码是否必填。', 
         '0-身份证号码不是必填，1-身份证号码必填。',
         NULL, Null, Null
  From Dual;

--91665:冉俊明,2015-12-29,增加多单据分单据结算时医保结算失败时只对结算成功单据收费的模式。
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1121, 0, 0, 0, 0, 0, 0, 104, '只对医保结算成功单据收费', '0', '0',
         '多单据分单据结算模式下，当医保结算失败，但部分单据结算成功时是否对结算成功的单据进行收费。', 
         '0-只有所有单据都进行医保结算成功后才能继续收费，1-医保结算失败，但部分单据结算成功时只对结算成功的单据进行收费。',
         '该参数只有在医保参数“多单据分单据结算”启用时才有效，否则无效。', Null, Null
  From Dual;

--91427:马政,2015-12-22,新增药品验收系统
Insert Into zlPrograms(序号,标题,说明,系统,部件) Values( 1348,'药品入库验收管理','药品入库前检查入库单药品基本信息是否合格',&n_System,'zl9MediStore'); 

Insert Into zlMenus(组别,ID,上级ID,标题,快键,系统,模块,短标题,图标,说明)
  Select 组别,Zlmenus_Id.Nextval,id,'药品入库验收管理' ,'I' ,&n_System,1348 ,'入库验收' ,114 ,'药品入库前检查入库单药品基本信息是否合格' 
         From zlMenus Where 标题 = '药库管理与药品会计系统' And 组别 = '缺省' And 系统 = &n_System And 模块 is null;          

Insert Into zlMenus(组别,ID,上级ID,标题,快键,系统,模块,短标题,图标,说明)
  Select 组别,Zlmenus_Id.Nextval,id,'药品入库验收管理' ,'I' ,&n_System,1348 ,'入库验收' ,114 ,'药品入库前检查入库单药品基本信息是否合格' 
         From zlMenus Where 标题 = '门诊中西药房管理系统' And 组别 = '缺省' And 系统 = &n_System And 模块 is null;          

Insert Into 号码控制表
  (项目序号, 项目名称, 自动补缺, 编号规则)
  Select 148, '药品入库验收', 0, 0
  From Dual
  Where Not Exists (Select 1 From 号码控制表 Where 项目序号 = 148 And 项目名称 = '药品入库验收');

--89983:陈刘,2015-12-22,呼吸表格呼吸机输出方式,增加参数值
Update zlParameters
Set 影响控制说明 = '当呼吸设置为表格项目，此参数决定呼吸机的输出方式。1.参数值为0，则在呼吸机对应的呼吸表格栏内显示R符号。2.参数值为1，则在每段连续呼吸机开始对应的呼吸表格栏上方纵向输出"呼吸机"，且用"↑"标识开始，在结束对应的呼吸表格栏上方用"↓"标识终止。3.当参数值为2,则在呼吸机对应的呼吸表格栏内显示A+呼吸值'
Where 系统 = &n_System And 模块=1255 And 参数名 ='呼吸表格呼吸机输出方式';

Update zlParameters
Set 参数值含义 = '0-表格栏填写呼吸机符号;1-表格栏填写频次,相应时间呼吸栏横线上方输出呼吸机,用↑标识开始↓标识终止;2-表格栏填写A+呼吸值'
Where 系统 = &n_System And 模块=1255 And 参数名 ='呼吸表格呼吸机输出方式';

--91225:梁经伙,2015-12-22,传染病管理系统添加模块号和菜单
Insert Into zlComponent(部件,名称,主版本,次版本,附版本,系统,注册产品名称,注册产品简名,注册产品版本) Values('zl9Disease','传染病系统部件',10,35,0,&n_System,'中联医院信息系统','ZLHIS+','10');
Insert Into zlPrograms(序号,标题,说明,系统,部件) Values( 1278,'传染病管理工作站','用于对传染病的接收、审核、上报等管理工作',&n_System,'zl9Disease');
update zlPrograms set 部件 = 'zl9Disease' where 系统 = &n_System and 序号 = 1277 and 部件 = 'zl9CISJob';

Delete zlMenus Where 标题='疾病报告设置' And 组别='缺省' And 系统=&n_System; 

Insert Into zlMenus
  (组别, ID, 上级id, 标题, 快键, 说明, 系统, 模块, 短标题, 图标)
  Select 组别, Zlmenus_Id.Nextval, ID, '传染病管理系统', 'D', ' 用于对传染病报告的设置和传染病报告的接收、审核、上报等管理工作 ', &n_System, -null, '传染病管理', 99
  From zlMenus
  Where 标题 = '临床信息系统' And 组别 = '缺省' And 系统 = &n_System And 模块 Is Null;

Insert Into zlMenus
  (组别, ID, 上级id, 标题, 快键, 说明, 系统, 模块, 短标题, 图标)
  Select a.组别, Zlmenus_Id.Nextval, a.Id, b.*
  From (Select 组别, ID From zlMenus Where 标题 = '传染病管理系统' And 组别 = '缺省' And 系统 = &n_System And 模块 Is Null) A,
       (Select 标题, 快键, 说明, 系统, 模块, 短标题, 图标
         From zlMenus
         Where 1 = 0
         Union All
         Select '疾病报告设置', 'S', '对需要申报的疾病与报告卡对应关系进行设置', &n_System, 1277, '疾病申报', 210
         From Dual
         Union All
         Select '传染病管理工作站', 'D', ' 用于对传染病报告的接收、审核、上报等管理工作', &n_System, 1278, '传染病管理', 130
         From Dual
         Union All
         Select 标题, 快键, 说明, 系统, 模块, 短标题, 图标
         From zlMenus
         Where 1 = 0) B;

--91225:胡俊勇,2015-12-21,传染病系统
Update zlParameters
Set 参数值含义 = '每位数分别代表不同消息类型：1病历审阅、2医嘱安排、3危急值、4报告撤销、5医嘱审核、6处方审查、7传染病报告'
Where 参数名 = '自动刷新内容' And 模块 = 1261 and 系统 = &n_System;

Update zlParameters
Set 参数值含义 = '每位数分别代表不同消息类型：1危急值、2医嘱安排、3处方审查、4传染病报告'
Where 参数名 = '自动刷新内容' And 模块 = 1260 and 系统 = &n_System;

--91225:梁经伙,2015-12-22,传染病系统添加参数
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1278, a.*
  From (Select 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明 From zlParameters Where 1 = 0 Union All
         Select 1, 0, 0, 0, 0, 0, 1, '本工作站可管理文件', NULL, NULL, '传染病工作站可管理的文件。', '病历文件列表中的文件ID', Null, Null, Null From Dual Union All
         Select 1, 0, 0, 0, 0, 0, 2, '审核与上报工作状态下查看最近天数的报告', '7', '7', '审核与上报工作状态下查看最近多少天的报告', Null, Null, Null, Null From Dual Union All
         Select 1, 0, 0, 0, 0, 0, 3, '审核与上报工作状态下查看指定天数的报告的起始天数', Null, Null, '审核与上报工作状态下查看指定时间段的报告的起始日期', Null, Null, Null, Null From Dual Union All
         Select 1, 0, 0, 0, 0, 0, 4, '审核与上报工作状态下查看指定天数的报告的结束天数', Null, Null, '审核与上报工作状态下查看指定时间段的报告的结束日期', Null, Null, Null, Null From Dual Union All
         Select 1, 0, 0, 0, 0, 0, 5, '传染病系统查看状态范围', '1,1,1,1,0,1,0', '1,1,1,1,0,1,0', '选择查看状态范围的的报告。',
                '所在的位为1的话代表启用查看该状态都报告，为0的话代表不查看；第1位-待审核,第2位-待返修,第3位-返修待审核,第4位-待上报,第5位-已上报,第6位-待填写报告卡,第7位-非传染病', Null, Null, Null From Dual Union All
         Select 1, 0, 0, 0, 0, 0, 6, '未填写状态下查看最近天数的报告', '0', '0', '未填写状态下查看最近多少天的报告', Null, Null, Null, Null From Dual Union All
         Select 1, 0, 0, 0, 0, 0, 7, '未填写状态下查看指定天数的报告的起始天数', Null, Null, '未填写状态下查看指定时间段的报告的起始日期', Null, Null, Null, Null From Dual Union All
         Select 1, 0, 0, 0, 0, 0, 8, '未填写状态下查看指定天数的报告的结束天数', Null, Null, '未填写状态下查看指定时间段的报告的结束日期', Null, Null, Null, Null From Dual Union All
         Select 1, 0, 0, 0, 0, 0, 9, '已删除状态下查看最近天数的报告', '7', '7', '已删除状态下查看最近多少天的报告', Null, Null, Null, Null From Dual Union All
         Select 1, 0, 0, 0, 0, 0, 10, '已删除状态下查看指定天数的报告的起始天数', Null, Null, '已删除状态下查看指定时间段的报告的起始日期', Null, Null, Null, Null From Dual Union All
         Select 1, 0, 0, 0, 0, 0, 11, '已删除状态下查看指定天数的报告的结束天数', Null, Null, '已删除状态下查看指定时间段的报告的结束日期', Null, Null, Null, Null From Dual Union All
         Select 1, 0, 0, 0, 0, 0, 12, '当前查看报告的工作状态', '1', '1', '0-待填写,1-审核工作，2-上报工作，3-已删除，4-查重工作', Null, Null, Null, Null From Dual Union All
         Select 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明 From zlParameters Where 1 = 0) A;
		 
Insert Into 业务消息类型(编码,名称,说明,保留天数) 
Select 'ZLHIS_CIS_032','传染病阳性结果提醒','技师站填写传染病阳性录时，产生的一个通知消息。',7 From Dual Union All
Select 'ZLHIS_CIS_033','传染病报告返修提醒','传染病报告填写不符合要求，产生的一个返修通知消息。',7 From Dual;

--91225:梁经伙,2015-12-16,传染病管理系统 基本数据
Insert Into zlBaseCode(系统,表名,固定,说明,分类) Values( &n_System,'传染病目录',0,'法定传染病目录','医疗工作' ); 

Insert Into 传染病目录(编码,名称,简码) 
Select '01','鼠疫','SY' From Dual Union All
Select '02','霍乱','HL' From Dual Union All
Select '03','传染性非典型肺炎','CRXFDXFY' From Dual Union All
Select '04','艾滋病(HIV)','AZBHIV' From Dual Union All
Select '05','艾滋病(AIDS)','AZBAIDS' From Dual Union All
Select '06','病毒性肝炎(甲型)','BDXGYJX' From Dual Union All
Select '07','病毒性肝炎(乙型)','BDXGYYX' From Dual Union All
Select '08','病毒性肝炎(丙型)','BDXGYBX' From Dual Union All
Select '09','病毒性肝炎(戊型)','BDXGYWX' From Dual Union All
Select '10','病毒性肝炎(未分型)','BDXGYWFX' From Dual Union All
Select '11','脊髓灰质炎','GSHZY' From Dual Union All
Select '12','人感染高致病性禽流感','RGRGZBXQLG' From Dual Union All
Select '13','甲型H1N1流感','JXH1N1LG' From Dual Union All
Select '14','麻疹','MZ' From Dual Union All
Select '15','流行性出血热','LXXCXR' From Dual Union All
Select '16','狂犬病','KQB' From Dual Union All
Select '17','流行性乙型脑炎','LXXYXGY' From Dual Union All
Select '18','登革热','DGR' From Dual Union All
Select '19','炭疽(肺炭疽)','TJFTJ' From Dual Union All
Select '20','炭疽(未分型)','TJWFX' From Dual Union All
Select '21','痢疾(细菌性)','LJXJX' From Dual Union All
Select '22','痢疾(阿米巴性)','LJAMBX' From Dual Union All
Select '23','肺结核(涂阳)','FJHTY' From Dual Union All
Select '24','肺结核(仅培阳)','FJHJPY' From Dual Union All
Select '25','肺结核(菌阴)','FJHJY' From Dual Union All
Select '26','肺结核(未痰检)','FJHWTJ' From Dual Union All
Select '27','伤寒(伤寒)','SHSH' From Dual Union All
Select '28','伤寒(副伤寒)','SHFSH' From Dual Union All
Select '29','流行性脑脊髓膜炎','LXXLJSMY' From Dual Union All
Select '30','百日咳','BRK' From Dual Union All
Select '31','白喉','BH' From Dual Union All
Select '32','新生儿破伤风','XSEPSF' From Dual Union All
Select '33','猩红热','XHR' From Dual Union All
Select '34','布鲁氏菌病','BLSJB' From Dual Union All
Select '35','淋病、梅毒(Ⅰ期)','LBMDYQ' From Dual Union All
Select '36','淋病、梅毒(Ⅱ期)','LBMDEQ' From Dual Union All
Select '37','淋病、梅毒(Ⅲ期)','LBMDSQ' From Dual Union All
Select '38','淋病、梅毒(胎传)','LBMDTC' From Dual Union All
Select '39','淋病、梅毒(隐性)','LBMDYX' From Dual Union All
Select '40','钩端螺旋体病','GDLXTB' From Dual Union All
Select '41','血吸虫病','XXCB' From Dual Union All
Select '42','疟疾(间日疟)','LJJRL' From Dual Union All
Select '43','疟疾(恶性疟)','LJEXL' From Dual Union All
Select '44','疟疾(未分型)','LJWFX' From Dual Union All
Select '45','流行性感冒','LXXGM' From Dual Union All
Select '46','流行性腮腺炎','LXXSXY' From Dual Union All
Select '47','风疹','FZ' From Dual Union All
Select '48','急性出血性结膜炎','JXCXXJMY' From Dual Union All
Select '49','麻风病','MFB' From Dual Union All
Select '50','流行性和地方性斑疹伤寒','LXXHDFXBZSH' From Dual Union All
Select '51','黑热病','HRB' From Dual Union All
Select '52','包虫病','BCB' From Dual Union All
Select '53','丝虫病','SCB' From Dual Union All
Select '54','除霍乱、细菌性和阿米巴性痢疾、伤寒和副伤寒以外的感染性腹泻病','CHLXJXHAMBX' From Dual Union All
Select '55','手足口病','SZKB' From Dual;

--91225:梁经伙,2015-12-16,传染病管理系统添加疾病报告反馈表
Insert Into zlBakTables(系统,组号,表名,序号,直接转出,停用触发器)
Select &n_System,6,A.* From (
Select 表名,序号,直接转出,停用触发器 From zlBakTables Where 1 = 0 Union All
Select '疾病报告反馈',4,1,-NULL From Dual Union All
Select 表名,序号,直接转出,停用触发器 From zlBakTables Where 1 = 0) A;

--91064:刘硕,2015-12-08,外院医生输入控制
Insert Into Zlparameters
  (Id, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, -null, -null, -null, -null, -null, 0, 0, 253, '外院医生必须先建档', '0', '0',
         '在选择医生的信息域是否可以自由录入外院医生', '0-可以自由录入外院医生；1-不能自由录入外院医生，外院医生必须先建档', Null, Null, Null
  From Dual;

--91641:余伟节,2015-12-25,路径匹配时加入期效
Insert Into zlParameters(ID,系统,模块,私有,本机,授权,固定,部门,性质,参数号,参数名,参数值,缺省值,影响控制说明,参数值含义,关联说明,适用说明,警告说明)
Select zlParameters_ID.Nextval,&n_System,1256,A.* From (
Select 私有,本机,授权,固定,部门,性质,参数号,参数名,参数值,缺省值,影响控制说明,参数值含义,关联说明,适用说明,警告说明 From zlParameters Where 1 = 0 Union All
Select 0,0,0,0,0,0,12,'匹配时期效不同算路径外项目','0','0','如果启用此参数，医嘱自动匹配时医嘱的诊疗项目相同但期效不相同则将该医嘱当作路径外项目处理。','0-诊疗项目相同时,期效不相同当作路径内项目,但优先匹配相同期效,1-诊疗项目和期效都相同时才算作路径内项目',NULL,NULL,NULL From Dual Union All
Select 私有,本机,授权,固定,部门,性质,参数号,参数名,参数值,缺省值,影响控制说明,参数值含义,关联说明,适用说明,警告说明 From zlParameters Where 1 = 0) A;

--92725:李业庆,2016-01-21,增加配药单打印显示方式参数
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1341, 0, 1, 0, 0, 55, '待配药单据打印显示方式', '0', '0', '待配药列表中根据该参数确定显示未打印或已打印的配药单',
         '0-显示所有配药单,1-只显示未打印的待配药单据,2-只显示已打印的待配药单据', Null, Null, Null
  From Dual;

--92725:李业庆,2016-01-21,增加待发药单据扫描后自动呼叫参数
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1341, 0, 1, 0, 0, 56, '待发药单据扫描后自动呼叫', '0', '0', '勾选时在待发药状态时，扫描病人就诊信息确认后自动进行叫号呼叫',
         '0-不自动呼叫,1-扫描后自动语音呼叫', Null, Null, Null
  From Dual;

-------------------------------------------------------------------------------
--权限修正部份
-------------------------------------------------------------------------------
--95076:余伟节,2016-04-11,病人地址信息结构化
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1101, '基本', User, '病人地址信息', 'SELECT'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1101, '基本', User, 'ZL_病人地址信息_UPDATE', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1101, '基本', User, 'Zl_Adderss_Structure', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1131, '基本', User, '病人地址信息', 'SELECT'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1131, '基本', User, 'ZL_病人地址信息_UPDATE', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1131, '基本', User, 'Zl_Adderss_Structure', 'EXECUTE'
  From Dual;

--95041:李南春,2016-04-11,病人地址信息查询权限
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1107, '基本', User, '病人地址信息', 'SELECT'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1111, '基本', User, '病人地址信息', 'SELECT'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1113, '病案修改', User, '病人地址信息', 'SELECT'
  From Dual;

--94399:李小东,2016-04-08,部门、人员扩展信息维护
Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select &n_System, 1001, '扩展信息维护', 3, '有此权限时能对部门扩展信息进行维护', 1
  From Dual;

Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select &n_System, 1002, '扩展信息维护', 7, '有此权限时能对人员扩展信息进行维护', 1
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1001, '基本', User, '部门扩展项目', 'SELECT'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1001, '基本', User, '部门扩展信息', 'SELECT'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1001, '基本', User, 'Zl_Lob_Read', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1002, '基本', User, '人员扩展项目', 'SELECT'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1002, '基本', User, '人员扩展信息', 'SELECT'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1002, '基本', User, 'Zl_Lob_Read', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1001,'扩展信息维护',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
Select 'Zl_Lob_Append','EXECUTE' From Dual Union All
Select 'Zl_Lob_Read','EXECUTE' From Dual Union All
Select 'Zl_部门扩展信息_Insert','EXECUTE' From Dual Union All
Select 'Zl_部门扩展信息_Delete','EXECUTE' From Dual Union All
Select '部门扩展信息','UPDATE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1002,'扩展信息维护',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
Select 'Zl_Lob_Append','EXECUTE' From Dual Union All
Select 'Zl_Lob_Read','EXECUTE' From Dual Union All
Select 'Zl_人员扩展信息_Insert','EXECUTE' From Dual Union All
Select 'Zl_人员扩展信息_Delete','EXECUTE' From Dual Union All
Select '人员扩展信息','UPDATE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--94941:李南春,2016-04-07,医疗卡发卡是否允许修改病人门诊号
Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select &n_System, 1107, '允许修改门诊号', 16, '对病人门诊号进行修改的权限。', 1
  From Dual;

--90696:余伟节,2016-04-05,允许修改门诊号
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,1101,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
Select '允许修改门诊号',21,'新增、修改病人信息时允许修改门诊号',1 From Dual Union All
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

--94400:余伟节,2016-03-30,入院管理增加全院预约权限
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,1131,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
Select '全院预约',26,'如果没有权限则只能对当前操作员所在科室/病区对应的科室进行预约',1 From Dual Union All
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

--94311:张德婷,2016-03-22,对出院病人和已结账病人操作进行权限控制
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,1345,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
Select '发退出院病人处方',2,'已经出院的病人还可以发退药',0 From Dual Union All
Select '退已结帐处方',2,'已经结账的病人可以退药',0 From Dual Union All
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

--94102:李小东,2016-03-14,对应处方权限更正
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1023, '对应处方', User, '病历单据应用', 'SELECT'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1023, '对应处方', User, '病历文件列表', 'SELECT'
  From Dual;

--93675:梁经伙,2016-03-14,诊断选择器怎加了存储过程增加权限
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1252,'医嘱下达',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select 'Zl_病案主页_首页整理EX','EXECUTE' From Dual Union All 
    Select 'Zl_病案主页从表_首页整理','EXECUTE' From Dual Union All 
    Select '分化程度','SELECT' From Dual Union All 
    Select '最高诊断依据','SELECT' From Dual Union All 
	Select '住院死亡原因','SELECT' From Dual Union All 
	Select '病案项目','SELECT' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1253,'医嘱下达',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select 'Zl_病案主页_首页整理EX','EXECUTE' From Dual Union All 
    Select 'Zl_病案主页从表_首页整理','EXECUTE' From Dual Union All 
    Select '分化程度','SELECT' From Dual Union All 
    Select '最高诊断依据','SELECT' From Dual Union All 
	Select '住院死亡原因','SELECT' From Dual Union All 
	Select '病案项目','SELECT' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--90040:梁经伙,2016-03-17,如果zlProgPrivs表里面已经存在身份证号状态的数据就直接修改
update zlProgPrivs set 对象 = '身份证未录原因' where 系统 = &n_System  and 对象 = '身份证号状态';

--90040:梁经伙,2016-03-10,为表 身份证未录原因 添加权限
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1261,'首页整理',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select '身份证未录原因','SELECT' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1260,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select '身份证未录原因','SELECT' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--93917:许华峰,2016-03-08,与RIS的数据交换接口脚本
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
	Select &n_System,1287,A.* From (
	Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
	Select '基本',-NULL,NULL,1 From Dual Union All       
	Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;
       
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
	Select &n_System,1287,'基本',User,A.* From (
	Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
	Select '费别','SELECT' From Dual Union All
	Select '民族','SELECT' From Dual Union All
	Select '职业','SELECT' From Dual Union All
	Select '性别','SELECT' From Dual Union All
	Select '部门表','SELECT' From Dual Union All
	Select '人员表','SELECT' From Dual Union All
	Select '病人信息','SELECT' From Dual Union All
	Select '病案主页','SELECT' From Dual Union All
	Select '婚姻状况','SELECT' From Dual Union All
	Select '上机人员表','SELECT' From Dual Union All
	Select '人员证书记录','SELECT' From Dual Union All
	Select '部门性质说明','SELECT' From Dual Union All
	Select '病人挂号记录','SELECT' From Dual Union All
	Select '病人医嘱记录','SELECT' From Dual Union All
	Select '病人医嘱发送','SELECT' From Dual Union All
	Select '病人医嘱附费','SELECT' From Dual Union All
	Select '病人医嘱报告','SELECT' From Dual Union All
	Select '病人诊断医嘱','SELECT' From Dual Union All
	Select '病人诊断记录','SELECT' From Dual Union All
	Select '影像检查项目','SELECT' From Dual Union All
	Select '收费项目目录','SELECT' From Dual Union All
	Select '门诊费用记录','SELECT' From Dual Union All
	Select '住院费用记录','SELECT' From Dual Union All
	Select '诊疗项目目录','SELECT' From Dual Union All
	Select '诊疗项目部位','SELECT' From Dual Union All
	Select '诊疗执行科室','SELECT' From Dual Union All
	Select '诊疗收费关系','SELECT' From Dual Union All
	Select '保险支付项目','SELECT' From Dual Union All
	Select '体检任务人员','SELECT' From Dual Union All
	Select '体检任务发送','SELECT' From Dual Union All
	Select '医疗付款方式','SELECT' From Dual Union All
	Select 'ZlComponent','SELECT' From Dual Union All
	Select 'Zl_Lob_Append','EXECUTE' From Dual Union All 
	Select 'Zl_Lob_Read','EXECUTE' From Dual Union All
	Select 'Zl_Fun_Getsignpar','EXECUTE' From Dual Union All
	Select 'zl_影像消息_XML内容获取','EXECUTE' From Dual Union All
	Select 'zl_挂号病人病案_INSERT','EXECUTE' From Dual Union All
	Select 'ZL_病人医嘱记录_Insert','EXECUTE' From Dual Union All
	Select 'ZL_病人医嘱发送_Insert','EXECUTE' From Dual Union All
	Select 'Zl_Ris检查预约_Delete','EXECUTE' From Dual Union All
	Select 'Zl_Ris检查预约_Insert','EXECUTE' From Dual Union All
	Select 'b_zlXWInterface','EXECUTE' From Dual Union All
	Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--93871:刘尔旋,2016-03-04,医生站挂号权限问题
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 9000, '基本', User, 'Zl_Age_Check', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 9000, '基本', User, 'Zl_Age_Calc', 'EXECUTE'
  From Dual;


--93758:陈振原,2016-03-01,脚本oracle对象权限访问错误
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1075, '基本', User, '病历范文内容', 'SELECT'
  From Dual;

--91225:梁经伙,2016-02-18,医生站使用传染病反馈单添加的授权
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select  &n_System,1260,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select '疾病阳性记录','SELECT' From Dual Union All 
    Select '疾病报告反馈','SELECT' From Dual Union All   
	Select '疾病申报记录','SELECT' From Dual Union All     
    Select 'Zl_疾病阳性检测记录_Update','EXECUTE' From Dual Union All 
    Select 'Zl_疾病申报记录_Update','EXECUTE' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select  &n_System,1261,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select '疾病阳性记录','SELECT' From Dual Union All 
    Select '疾病报告反馈','SELECT' From Dual Union All 
	Select '疾病申报记录','SELECT' From Dual Union All    
    Select 'Zl_疾病阳性检测记录_Update','EXECUTE' From Dual Union All 
    Select 'Zl_疾病申报记录_Update','EXECUTE' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--93336:胡俊勇,2016-02-16,输血执行登记
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1252, '基本', User, 'Zl_Fun_Get输血执行登记', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1253, '基本', User, 'Zl_Fun_Get输血执行登记', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1254, '基本', User, 'Zl_Fun_Get输血执行登记', 'EXECUTE'
  From Dual;    

--92729:胡俊勇,2016-01-26,专业版RIS接口处理
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select  &n_System,9001,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select 'RIS检查预约','SELECT' From Dual Union All    
    Select 'Zl_Ris检查预约_Insert','EXECUTE' From Dual Union All 
    Select 'Zl_Ris检查预约_Delete','EXECUTE' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--92699:刘鹏飞,2016-01-22,病区标记设置权限增加
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1265,'病区标记设置',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
Select 'zl_病区标记内容_update','EXECUTE' From Dual Union All
Select 'zl_病区标记内容_insert','EXECUTE' From Dual Union All
Select 'zl_病区标记内容_delete','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--89620:余伟节,2016-01-15,提前完成临床路径执行的权限
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,1256,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
Select '提前完成',11,'提前完成临床路径执行的权限。',1 From Dual Union All
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

--91487:冉俊明,2016-01-05,保险补充结算多笔退费。
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1124, '医保结算', User, '三方退款信息', 'SELECT'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1124, '结算退费', User, '三方退款信息', 'SELECT'
  From Dual;        

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1124, '医保结算', User, 'Zl_三方退款信息_Insert', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1124, '结算退费', User, 'Zl_三方退款信息_Insert', 'EXECUTE'
  From Dual;

--91427:马政,2015-12-22,新增药品验收系统
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,1348,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All 
    Select '基本',-Null,NULL,1 From Dual Union All      
    Select '新增',2,'增加药品入库验收管理的操作权限。有该权限时，允许增加入库验收单',1 From Dual Union All 
    Select '修改',4,'对未审核的药品进行修改的操作权限。有该权限时，允许对未审核的入库验收单进行修改',1 From Dual Union All 
    Select '删除',5,'删除药品入库验收管理记录的操作权限。有该权限时，允许对未审核的入库验收单进行删除',1 From Dual Union All 
    Select '审核',6,'增加药品外购放库记录审核的操作权限。有该权限时，允许对入库验收单进行审核',1 From Dual Union All     
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1348,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select 'NextNO','EXECUTE' From Dual Union All 
    Select '号码控制表','SELECT' From Dual Union All 
    Select '号码控制表','UPDATE' From Dual Union All 
    Select '科室号码表','SELECT' From Dual Union All 
    Select '科室号码表','UPDATE' From Dual Union All
    Select '部门表','SELECT' From Dual Union All 
    Select '部门人员','SELECT' From Dual Union All 
    Select '部门性质分类','SELECT' From Dual Union All 
    Select '部门性质说明','SELECT' From Dual Union All 
    Select '供应商','SELECT' From Dual Union All 
    Select '药品生产商','SELECT' From Dual Union All 
    Select '人员表','SELECT' From Dual Union All 
    Select '上机人员表','SELECT' From Dual Union All 
    Select '收费价目','SELECT' From Dual Union All 
    Select '收费细目','SELECT' From Dual Union All 
    Select '收费项目别名','SELECT' From Dual Union All 
    Select '收费项目目录','SELECT' From Dual Union All 
    Select '收费执行科室','SELECT' From Dual Union All 
    Select '药品别名','SELECT' From Dual Union All 
    Select '药品材质分类','SELECT' From Dual Union All 
    Select '药品出库检查','SELECT' From Dual Union All 
    Select '药品单据性质','SELECT' From Dual Union All 
    Select '药品规格','SELECT' From Dual Union All 
    Select '药品剂型','SELECT' From Dual Union All     
    Select '药品目录','SELECT' From Dual Union All 
    Select '药品入出类别','SELECT' From Dual Union All    
    Select '药品特性','SELECT' From Dual Union All 
    Select '药品外观','SELECT' From Dual Union All 
    Select '药品卫材精度','SELECT' From Dual Union All     
    Select '诊疗分类目录','SELECT' From Dual Union All 
    Select '诊疗项目类别','SELECT' From Dual Union All 
    Select '诊疗项目目录','SELECT' From Dual Union All 
    Select '诊疗执行科室','SELECT' From Dual Union All 
    Select '药品验收记录','SELECT' From Dual Union All 
    Select '药品验收明细','SELECT' From Dual Union All 
    Select '药品储备限额','SELECT' From Dual Union All
    Select '药品验收记录_ID','SELECT' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1348,'新增',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
Select 'Zl_药品验收记录_Insert','EXECUTE' From Dual Union All
Select 'Zl_药品验收明细_Insert','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1348,'修改',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
Select 'Zl_药品验收记录_Insert','EXECUTE' From Dual Union All
Select 'ZL_药品验收记录_Delete','EXECUTE' From Dual Union All
Select 'Zl_药品验收明细_Insert','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1348,'删除',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
Select 'ZL_药品验收记录_Delete','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1348,'审核',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
Select 'ZL_药品验收记录_Verify','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--91225:梁经伙,2015-12-22,传染病管理系统添加权限
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,1278,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
Select '基本',-NULL,NULL,1 From Dual Union All
Select '范围设置',1,'设置工作站可管理的疾病报告范围。有该权限时，允许设置本工作站可管理的文件',1 From Dual Union All
Select '报送',2,'疾病报告的对外报送信息登记。有该权限时，允许对疾病报告的对外报送信息进行登记',1 From Dual Union All
Select '接收',3,'接收或拒绝临床发现填写的疾病报告。有该权限时，允许对疾病报告进行按收或拒绝',1 From Dual Union All
Select '回退',4,'取消错误的报送登记或接收拒绝操作。有该权限时，允许对疾病报告的登记接收拒绝操作进行回退',1 From Dual Union All
Select '审核',5,'审核填写了的疾病报告。有该权限时，允许对疾病报告的进行审核',1 From Dual Union All
Select '删除',6,'删除重复的疾病报告。有该权限时，允许对疾病报告进行删除',1 From Dual Union All
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

--91225:梁经伙,2015-12-22,传染病管理系统添加权限
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1278,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
Select 'ZL_Replace_Element_Value','EXECUTE' From Dual Union All
Select 'Zl_Lob_Read','EXECUTE' From Dual Union All
Select 'Zl_电子病历打印_Insert','EXECUTE' From Dual Union All
Select 'Zl_疾病申报对应_UPDATE','EXECUTE' From Dual Union All
Select '病案主页','SELECT' From Dual Union All
Select '病历常用样式','SELECT' From Dual Union All
Select '病历文件结构','SELECT' From Dual Union All
Select '病历文件列表','SELECT' From Dual Union All
Select '病历页面格式','SELECT' From Dual Union All
Select '病人信息','SELECT' From Dual Union All
Select '病人医疗卡属性','SELECT' From Dual Union All
Select '病人医疗卡信息','SELECT' From Dual Union All
Select '部门性质说明','SELECT' From Dual Union All
Select '电子病历附件','SELECT' From Dual Union All
Select '电子病历记录','SELECT' From Dual Union All
Select '电子病历内容','SELECT' From Dual Union All
Select '疾病报送单位','SELECT' From Dual Union All
Select '疾病申报对应','SELECT' From Dual Union All
Select '疾病申报记录','SELECT' From Dual Union All
Select '卡消费接口目录','SELECT' From Dual Union All
Select '人员性质说明','SELECT' From Dual Union All
Select '消费卡目录','SELECT' From Dual Union All
Select '医疗卡挂失方式','SELECT' From Dual Union All
Select '医疗卡类别','SELECT' From Dual Union All
Select '疾病报告反馈','SELECT' From Dual Union All
Select '病人照片','SELECT' From Dual Union All
Select '疾病阳性记录','SELECT' From Dual Union All
Select '病人挂号记录','SELECT' From Dual Union All
Select '部门表','SELECT' From Dual Union All
Select '人员表','SELECT' From Dual Union All
Select '部门人员','SELECT' From Dual Union All
Select '职业','SELECT' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1278,'报送',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
Select 'Zl_疾病申报记录_Send','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1278,'审核',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
Select 'Zl_疾病申报记录_Update','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1278,'回退',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
Select 'Zl_疾病申报记录_Untread','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1278,'接收',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
Select 'ZL_病案反馈记录_Finish','EXECUTE' From Dual Union All
Select 'ZL_病案反馈记录_UPDATE','EXECUTE' From Dual Union All
Select 'Zl_疾病申报记录_Incept','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1278,'删除',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
Select 'Zl_疾病申报记录_Delete','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;


--91866:许华峰,2015-12-21,传染病管理系统阳性结果反馈单登记、查询功能
Insert Into zlModuleRelas(系统,模块,功能,相关系统,相关模块,相关类型,相关功能,缺省值)
Select &n_System,1290,A.* From (
Select 功能,相关系统,相关模块,相关类型,相关功能,缺省值 From zlModuleRelas Where 1 = 0 Union All
Select NULL,&n_System,9001,1,'基本',1 From Dual Union All
Select 功能,相关系统,相关模块,相关类型,相关功能,缺省值 From zlModuleRelas Where 1 = 0) A;

Insert Into zlModuleRelas(系统,模块,功能,相关系统,相关模块,相关类型,相关功能,缺省值)
Select &n_System,1291,A.* From (
Select 功能,相关系统,相关模块,相关类型,相关功能,缺省值 From zlModuleRelas Where 1 = 0 Union All
Select NULL,&n_System,9001,1,'基本',1 From Dual Union All
Select 功能,相关系统,相关模块,相关类型,相关功能,缺省值 From zlModuleRelas Where 1 = 0) A;

Insert Into zlModuleRelas(系统,模块,功能,相关系统,相关模块,相关类型,相关功能,缺省值)
Select &n_System,1294,A.* From (
Select 功能,相关系统,相关模块,相关类型,相关功能,缺省值 From zlModuleRelas Where 1 = 0 Union All
Select NULL,&n_System,9001,1,'基本',1 From Dual Union All
Select 功能,相关系统,相关模块,相关类型,相关功能,缺省值 From zlModuleRelas Where 1 = 0) A;

--91225:梁经伙,2015-12-21,传染病管理系统新增加表
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select  &n_System,9001,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
Select '传染病阳性结果登记',2,'有此权限时，允许调用接口对传染病阳性结果进行登记',1 From Dual Union All
Select '传染病阳性结果查询',3,'有此权限时，允许调用接口对传染病阳性结果进行查询',1 From Dual Union All
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select  &n_System,9001,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select '疾病阳性记录','SELECT' From Dual Union All 
    Select '传染病目录','SELECT' From Dual Union All 
    Select '疾病报告前提','SELECT' From Dual Union All     
    Select '诊疗检验标本','SELECT' From Dual Union All 
    Select 'Zl_疾病阳性检测记录_Insert','EXECUTE' From Dual Union All 
    Select 'Zl_疾病阳性检测记录_Update','EXECUTE' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--91225:梁经伙,2015-12-21,传染病阳性结果反馈单查询
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,9001,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select '病人照片','SELECT' From Dual Union All    
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--91738:张险华,2015-12-17,电子病案审查访问新版PACS报告
Insert Into zlModuleRelas(系统,模块,功能,相关系统,相关模块,相关类型,相关功能,缺省值)
Select &n_System,1560,A.* From (
Select 功能,相关系统,相关模块,相关类型,相关功能,缺省值 From zlModuleRelas Where 1 = 0 Union All
Select '基本',&n_System,9004,1,'基本',1 From Dual Union All
Select 功能,相关系统,相关模块,相关类型,相关功能,缺省值 From zlModuleRelas Where 1 = 0) A;

Insert Into Zltools.Zlrolegrant
 (系统, 序号, 角色, 功能)
 Select Distinct &n_System, 9004, 角色, '基本'
 From Zltools.Zlrolegrant A
 Where 序号 = 1560 And Not Exists (Select 1 From Zltools.Zlrolegrant Where 序号 = 9004 And 角色 = a.角色);

--89242:李南春,2015-12-08,使用结构化地址控件
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1107, '基本', User, 'zl_病人地址信息_update', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1111, '基本', User, 'zl_病人地址信息_update', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1113, '病案修改', User, 'zl_病人地址信息_update', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1107, '基本', User, 'Zl_Adderss_Structure', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1111, '基本', User, 'Zl_Adderss_Structure', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1113, '病案修改', User, 'Zl_Adderss_Structure', 'EXECUTE'
  From Dual;

--89620:余伟节,2016-01-15,提前完成临床路径执行的权限
Insert Into zlProgRelas(系统,序号,组号,功能,关系,主项,主项关系)
Select &n_System,1256,2,A.* From (
Select 功能,关系,主项,主项关系 From zlProgRelas Where 1 = 0 Union All
Select '结束路径',2,1,0 From Dual Union All
Select '提前完成',2,0,0 From Dual Union All
Select 功能,关系,主项,主项关系 From zlProgRelas Where 1 = 0) A;

--92840:李业庆,2016-01-19,新增过程权限
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1051, '基本', User, 'Zl_疾病诊断目录_Stop', 'EXECUTE'
  From Dual;

--92840:李业庆,2016-01-19,新增过程权限
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1051, '基本', User, 'Zl_疾病诊断目录_Reuse', 'EXECUTE'
  From Dual;

--95040:余伟节,2016-04-11,预约登记权限调整
Delete From Zlprogrelas Where Nvl(系统, 0) = &n_System And 序号 = 1131 And 组号 = 1 And 功能 = '保险病人登记';
Delete From Zlprogrelas Where Nvl(系统, 0) = &n_System And 序号 = 1131 And 组号 = 1 And 功能 = '允许非医保病人';
Insert Into zlProgRelas(系统,序号,组号,功能,关系,主项,主项关系)
Select  &n_System,1131,3,A.* From (
Select 功能,关系,主项,主项关系 From zlProgRelas Where 1 = 0 Union All
Select '预约登记',2,1,0 From Dual Union All
Select '办理登记',2,1,0 From Dual Union All
Select '保险病人登记',2,0,0 From Dual Union All
Select '允许非医保病人',2,0,0 From Dual Union All
Select 功能,关系,主项,主项关系 From zlProgRelas Where 1 = 0) A;




-------------------------------------------------------------------------------
--报表修正部份
-------------------------------------------------------------------------------

--91225:梁唐彬,2016-01-19,传染病管理系统
--报表：ZL1_REPORT_1280/法定传染病报告登记表
Insert Into zlReports(ID,编号,名称,说明,密码,打印机,进纸,票据,打印方式,系统,程序ID,功能,修改时间,发布时间,禁止开始时间,禁止结束时间) Values(zlReports_ID.NextVal,'ZL1_REPORT_1280','法定传染病报告登记表','查询并展示传染病报告登记记录','H`;~@e`~{( PlscuZ,\L','Microsoft XPS Document Writer',15,0,0,100,1280,'基本',Sysdate,Sysdate,Null,Null);
Insert Into zlRPTFmts(报表ID,序号,说明,W,H,纸张,纸向,动态纸张,图样) Values(zlReports_ID.CurrVal,1,'法定传染病报告登记表',11906,16838,9,2,0,0);
Insert Into zlRPTDatas(ID,报表ID,名称,字段,对象,类型,说明) Values(zlRPTDatas_ID.NextVal,zlReports_ID.CurrVal,'登记记录','ROWNUM,139|姓名,202|性别,202|出生日期,202|职业,202|家庭地址,202|电话,202|发病日期,202|确诊日期,202|实验,130|临床,130|携带,130|疑似,130|诊断,202|报告科室,202|填报日期,202|填报人,202|收卡日期,202|收卡人,202|网络报告日期,202|备注,202',User||'.电子病历记录,'||User||'.疾病申报记录,'||User||'.病人信息,'||User||'.部门表',0,Null);
Insert Into zlRPTSQLs(源ID,行号,内容)  Select zlRPTDatas_ID.CurrVal,a.* From (
  Select 1,'Select Rownum, 姓名, 性别, 出生日期, 职业, 家庭地址, 电话, 发病日期, 确诊日期, 实验, 临床, 携带, 疑似, 诊断, 报告科室, 填报日期, 填报人, 收卡日期, 收卡人, 网络报告日期, 备注' From Dual Union All
  Select 2,'From (Select p.姓名, p.性别, to_char(p.出生日期,''yyyy-mm-dd'') 出生日期, p.职业, p.家庭地址, p.联系人电话 电话, to_char(s.发病日期,''yyyy-mm-dd'') 发病日期, to_char(s.确诊日期,''yyyy-mm-dd'')确诊日期, '''' 实验, '''' 临床, '''' 携带, '''' 疑似,' From Dual Union All
  Select 3,'              s.诊断描述1 || s.诊断描述2 诊断, d.名称 报告科室, to_char(l.完成时间,''yyyy-mm-dd'') 填报日期, l.保存人 填报人, to_char(Trunc(s.收拒时间),''yyyy-mm-dd'') 收卡日期, s.收拒人 收卡人,' From Dual Union All
  Select 4,'              to_char(Trunc(s.报送时间),''yyyy-mm-dd'') 网络报告日期, s.填报备注 备注' From Dual Union All
  Select 5,'       From 电子病历记录 L, 疾病申报记录 S, 病人信息 P, 部门表 D' From Dual Union All
  Select 6,'       Where l.病历种类 = 5 And l.文件id In ([0]) And l.完成时间 Between [1] And [2] And' From Dual Union All
  Select 7,'             l.Id = s.文件id(+) And s.处理状态(+) <> -1 And l.病人id = p.病人id And l.科室id = d.Id' From Dual Union All
  Select 8,'       Order By p.姓名)' From Dual Union All
  Select 9,Null From Dual) a;
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,0,'文件',0,'选择器定义…',0,Null,Null,'select id ,名称 From 病历文件列表 where 种类=5',Null,'ID,131,'||CHR(38)||'S'||CHR(38)||'B|名称,202,'||CHR(38)||'D'||CHR(38)||'S',User||'.病历文件列表|',Null);
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,1,'开始时间',2,CHR(38)||'上月初时间',0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,2,'结束时间',2,CHR(38)||'上月末时间',0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签2',2,Null,0,'任意表1',11,'统计时间:[=开始时间]  -  [=结束时间]',Null,90,615,3780,210,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签1',2,Null,0,'任意表1',12,'法定传染病报告登记表',Null,6720,120,3300,330,0,0,1,'宋体',16,1,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'任意表1',4,Null,0,Null,0,'登记记录',Null,90,975,16560,10470,450,0,1,'宋体',9,0,0,0,0,16777215,1,Null,Null,Null,1,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-1,0,Null,Null,'[登记记录.ROWNUM]','4^450^编号',0,0,315,0,0,2,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-2,1,Null,Null,'[登记记录.姓名]','4^450^姓名',0,0,1005,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-3,2,Null,Null,'[登记记录.性别]','4^450^性别',0,0,315,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-4,3,Null,Null,'[登记记录.出生日期]','4^450^出生日期',0,0,990,0,0,1,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-5,4,Null,Null,'[登记记录.职业]','4^450^职业',0,0,1005,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-6,5,Null,Null,'[登记记录.家庭地址]','4^450^家庭地址',0,0,1245,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-7,6,Null,Null,'[登记记录.电话]','4^450^电话',0,0,1005,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-8,7,Null,Null,'[登记记录.发病日期]','4^450^发病日期',0,0,1005,0,0,1,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-9,8,Null,Null,'[登记记录.确诊日期]','4^450^确诊日期',0,0,1065,0,0,1,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-10,9,Null,Null,'[登记记录.实验]','4^450^实验',0,0,285,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-11,10,Null,Null,'[登记记录.临床]','4^450^临床',0,0,270,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-12,11,Null,Null,'[登记记录.携带]','4^450^携带',0,0,255,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-13,12,Null,Null,'[登记记录.疑似]','4^450^疑似',0,0,285,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-14,13,Null,Null,'[登记记录.诊断]','4^450^诊断',0,0,1005,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-15,14,Null,Null,'[登记记录.报告科室]','4^450^报告科室',0,0,825,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-16,15,Null,Null,'[登记记录.填报日期]','4^450^填报日期',0,0,990,0,0,1,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-17,16,Null,Null,'[登记记录.填报人]','4^450^填报人',0,0,840,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-18,17,Null,Null,'[登记记录.收卡日期]','4^450^收卡日期',0,0,990,0,0,1,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-19,18,Null,Null,'[登记记录.收卡人]','4^450^收卡人',0,0,1005,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-20,19,Null,Null,'[登记记录.网络报告日期]','4^450^网络报告日期',0,0,810,0,0,1,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-21,20,Null,Null,'[登记记录.备注]','4^450^备注',0,0,1005,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);

--报表：ZL1_REPORT_1280/法定传染病报告登记表
Insert into zlPrograms(序号,标题,说明,系统,部件) Values(1280,'法定传染病报告登记表','查询并展示传染病报告登记记录',100,'zl9Report');
Insert into zlProgFuncs(系统,序号,功能,说明) Values(100,1280,'基本',Null);
Insert into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
  Select 100,1280,'基本',User,'病历文件列表','SELECT' From Dual Union All
  Select 100,1280,'基本',User,'病人信息','SELECT' From Dual Union All
  Select 100,1280,'基本',User,'部门表','SELECT' From Dual Union All
  Select 100,1280,'基本',User,'电子病历记录','SELECT' From Dual Union All
  Select 100,1280,'基本',User,'疾病申报记录','SELECT' From Dual;
Insert into zlMenus(组别,ID,上级ID,标题,短标题,快键,图标,说明,系统,模块) Select '缺省',zlMenus_ID.Nextval,ID,'法定传染病报告登记表','法定传染病报告登记表',Null,105,'查询并展示传染病报告登记记录',100,1280 From zlMenus Where 系统=100 And 组别='缺省' And 标题='传染病管理系统' And 模块 is NULL;

--报表：ZL1_REPORT_1281/传染病阳性检测结果一览表
Insert Into zlReports(ID,编号,名称,说明,密码,打印机,进纸,票据,打印方式,系统,程序ID,功能,修改时间,发布时间,禁止开始时间,禁止结束时间) Values(zlReports_ID.NextVal,'ZL1_REPORT_1281','传染病阳性检测结果一览表','查询传染病阳性检测结果','Mv:uZldpv3%Fmxx}^"QW',Null,15,0,0,100,1281,'基本',Sysdate,Sysdate,To_Date('2016-01-01 00:00:00','YYYY-MM-DD HH24:MI:SS'),To_Date('2016-01-01 00:00:00','YYYY-MM-DD HH24:MI:SS'));
Insert Into zlRPTFmts(报表ID,序号,说明,W,H,纸张,纸向,动态纸张,图样) Values(zlReports_ID.CurrVal,1,'传染病阳性检测结果一览表1',11904,16832,256,1,0,0);
Insert Into zlRPTDatas(ID,报表ID,名称,字段,对象,类型,说明) Values(zlRPTDatas_ID.NextVal,zlReports_ID.CurrVal,'疾病阳性记录_数据','ID,131|来源,130|病人ID,131|姓名,202|性别,202|年龄,202|科室,202|标识号,131|送检时间,202|送检医生,202|送检科室,202|标本名称,202|反馈结果,202|疑似疾病,202|登记人,202|登记时间,202|处理人,202|处理时间,202|处理情况说明,202',User||'.疾病阳性记录,'||User||'.病案主页,'||User||'.病人挂号记录,'||User||'.部门表',0,Null);
Insert Into zlRPTSQLs(源ID,行号,内容)  Select zlRPTDatas_ID.CurrVal,a.* From (
  Select 1,'select A.Id, A.来源, 病人id, A.姓名, A.性别,A.年龄,e.名称 as 科室, A.标识号,A.送检时间, A.送检医生,f.名称 As 送检科室,A.标本名称, A.反馈结果,  A.疑似疾病, A.登记人,A.登记时间,A.处理人, A.处理时间, A.处理情况说明' From Dual Union All
  Select 2,'from ' From Dual Union All
  Select 3,'(Select a.Id,  ''住院'' As 来源, a.病人id, c.姓名, c.性别,c.年龄,' From Dual Union All
  Select 4,'      C.出院科室id as 科室ID, c.住院号 As 标识号,To_Char(a.送检时间, ''yyyy-MM-dd hh24:mi'')  送检时间, a.送检医生, a.送检科室id, a.标本名称, a.反馈结果, a.传染病名称 As 疑似疾病, a.登记人,' From Dual Union All
  Select 5,'       To_Char(a.登记时间, ''yyyy-MM-dd hh24:mi'') 登记时间, a.处理人, To_Char(a.处理时间, ''yyyy-MM-dd hh24:mi'')  处理时间, a.处理情况说明' From Dual Union All
  Select 6,'From 疾病阳性记录 A, 病案主页 C' From Dual Union All
  Select 7,'Where a.病人id = c.病人id And a.主页id = c.主页id and a.登记时间 Between [0] And [1]' From Dual Union All
  Select 8,'union all' From Dual Union All
  Select 9,'Select a.Id,  ''门诊'' As 来源, a.病人id,  b.姓名 , b.性别 , b.年龄,' From Dual Union All
  Select 10,'        b.执行部门id as 科室ID , b.门诊号 As 标识号,To_Char(a.送检时间, ''yyyy-MM-dd hh24:mi'')  送检时间, a.送检医生, a.送检科室ID, a.标本名称, a.反馈结果, a.传染病名称 As 疑似疾病, a.登记人,' From Dual Union All
  Select 11,'       To_Char(a.登记时间, ''yyyy-MM-dd hh24:mi'') 登记时间, a.处理人, To_Char(a.处理时间, ''yyyy-MM-dd hh24:mi'')  处理时间, a.处理情况说明' From Dual Union All
  Select 12,'From 疾病阳性记录 A, 病人挂号记录 B' From Dual Union All
  Select 13,'Where  a.病人id = b.病人id And a.挂号单 = b.No And a.登记时间 Between [0] And [1]) A ,部门表 E, 部门表 F' From Dual Union All
  Select 14,'where  a.送检科室id = f.Id(+) And  A.科室ID = e.Id(+)' From Dual Union All
  Select 15,'Order By a.Id' From Dual Union All
  Select 16,Null From Dual) a;
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,0,'开始日期',2,CHR(38)||'本月初时间',0,Null,Null,Null,Null,Null,Null,0);
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,1,'结束日期',2,CHR(38)||'本月末时间',0,Null,Null,Null,Null,Null,Null,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'操作员',2,Null,0,'任意表1',21,'统计人：[操作员姓名]',Null,435,14685,2100,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'报表名称',2,Null,0,'任意表1',12,'[单位名称]传染病阳性检测结果一览表',Null,2778,390,6120,375,0,0,1,'宋体',18,0,0,0,0,16777215,0,Null,Null,Null,1,0,1,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'打印时间',2,Null,0,'任意表1',23,'打印时间：[yyyy-MM-dd hh:mm:ss]',Null,7985,14670,3255,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签1',2,Null,0,'任意表1',13,'日期：[=开始日期]至[=结束日期]',Null,8090,1080,3150,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'任意表1',4,Null,0,Null,0,'疾病阳性记录_数据',Null,435,1500,10805,12960,255,0,0,'宋体',10.5,0,0,0,0,16777215,1,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-1,0,Null,Null,'[疾病阳性记录_数据.来源]','4^225^来源',0,0,1005,0,0,1,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-2,1,Null,Null,'[疾病阳性记录_数据.姓名]','4^225^姓名',0,0,1005,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-3,2,Null,Null,'[疾病阳性记录_数据.性别]','4^225^性别',0,0,1005,0,0,1,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-4,3,Null,Null,'[疾病阳性记录_数据.年龄]','4^225^年龄',0,0,1005,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-5,4,Null,Null,'[疾病阳性记录_数据.科室]','4^225^科室',0,0,1005,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-6,5,Null,Null,'[疾病阳性记录_数据.标识号]','4^225^标识号',0,0,1005,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-7,6,Null,Null,'[疾病阳性记录_数据.送检时间]','4^225^送检时间',0,0,2040,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-8,7,Null,Null,'[疾病阳性记录_数据.送检医生]','4^225^送检医生',0,0,1005,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-9,8,Null,Null,'[疾病阳性记录_数据.送检科室]','4^225^送检科室',0,0,1005,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-10,9,Null,Null,'[疾病阳性记录_数据.标本名称]','4^225^标本名称',0,0,1155,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-11,10,Null,Null,'[疾病阳性记录_数据.反馈结果]','4^225^反馈结果',0,0,1785,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-12,11,Null,Null,'[疾病阳性记录_数据.疑似疾病]','4^225^疑似疾病',0,0,1365,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-13,12,Null,Null,'[疾病阳性记录_数据.登记人]','4^225^登记人',0,0,1005,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-14,13,Null,Null,'[疾病阳性记录_数据.登记时间]','4^225^登记时间',0,0,2010,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-15,14,Null,Null,'[疾病阳性记录_数据.处理人]','4^225^处理人',0,0,1005,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-16,15,Null,Null,'[疾病阳性记录_数据.处理时间]','4^225^处理时间',0,0,2010,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-17,16,Null,Null,'[疾病阳性记录_数据.处理情况说明]','4^225^处理情况说明',0,0,2205,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);

--报表：ZL1_REPORT_1281/传染病阳性检测结果一览表
Insert into zlPrograms(序号,标题,说明,系统,部件) Values(1281,'传染病阳性检测结果一览表','查询传染病阳性检测结果',100,'zl9Report');
Insert into zlProgFuncs(系统,序号,功能,说明) Values(100,1281,'基本',Null);
Insert into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
  Select 100,1281,'基本',User,'病案主页','SELECT' From Dual Union All
  Select 100,1281,'基本',User,'病人挂号记录','SELECT' From Dual Union All
  Select 100,1281,'基本',User,'部门表','SELECT' From Dual Union All
  Select 100,1281,'基本',User,'疾病阳性记录','SELECT' From Dual;
Insert into zlMenus(组别,ID,上级ID,标题,短标题,快键,图标,说明,系统,模块) Select '缺省',zlMenus_ID.Nextval,ID,'传染病阳性检测结果一览表','传染病阳性检测结果一览表',Null,105,'查询传染病阳性检测结果',100,1281 From zlMenus Where 系统=100 And 组别='缺省' And 标题='传染病管理系统' And 模块 is NULL;

--报表：ZL1_REPORT_1282/传染病分年龄汇总表
Insert Into zlReports(ID,编号,名称,说明,密码,打印机,进纸,票据,打印方式,系统,程序ID,功能,修改时间,发布时间,禁止开始时间,禁止结束时间) Values(zlReports_ID.NextVal,'ZL1_REPORT_1282','传染病分年龄汇总表','分年龄对传染病进行汇总','Mv:jLio`s)4ViooG*U\',Null,15,0,0,100,1282,'基本',Sysdate,Sysdate,To_Date('2016-01-01 00:00:00','YYYY-MM-DD HH24:MI:SS'),To_Date('2016-01-01 00:00:00','YYYY-MM-DD HH24:MI:SS'));
Insert Into zlRPTFmts(报表ID,序号,说明,W,H,纸张,纸向,动态纸张,图样) Values(zlReports_ID.CurrVal,1,'传染病分年龄性别汇总表1',11904,16832,9,1,0,0);
Insert Into zlRPTDatas(ID,报表ID,名称,字段,对象,类型,说明) Values(zlRPTDatas_ID.NextVal,zlReports_ID.CurrVal,'疾病申报记录_数据','年龄,202|传染病名称,202|男,139|女,139|计,139',User||'.疾病申报记录,'||User||'.疾病阳性记录,'||User||'.疾病报告反馈',1,Null);
Insert Into zlRPTSQLs(源ID,行号,内容)  Select zlRPTDatas_ID.CurrVal,a.* From (
  Select 1,'Select nvl(a.年龄, ''未知年龄'') as 年龄,  b.传染病名称, sum(decode(A.性别, ''男'',1,0)) as 男,sum(decode(A.性别, ''女'',1,0)) as 女,sum(decode(A.性别,''男'',1,1)) as 计 ' From Dual Union All
  Select 2,'From 疾病申报记录 A, 疾病阳性记录 B,疾病报告反馈 C ' From Dual Union All
  Select 3,'Where a.文件id = b.文件id  and A.文件ID = C.文件ID  and c.登记时间 Between [0] And [1]' From Dual Union All
  Select 4,'Group By nvl(a.年龄, ''未知年龄''),b.传染病名称' From Dual) a;
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,0,'开始日期',2,CHR(38)||'本月初时间',0,Null,Null,Null,Null,Null,Null,0);
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,1,'结束日期',2,CHR(38)||'本月末时间',0,Null,Null,Null,Null,Null,Null,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'统计人',2,Null,0,'汇总表1',21,'统计人：[操作员姓名]',Null,825,15790,2100,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标题',2,Null,0,'汇总表1',12,'[单位名称]传染病分年龄汇总表',Null,2975,615,6105,450,0,0,1,'宋体',22,0,0,0,0,16777215,0,Null,Null,Null,1,0,1,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'统计时间',2,Null,0,'汇总表1',23,'统计时间：[yyyy-mm-dd HH:MM:SS]',Null,7975,15790,3255,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'日期',2,Null,0,'汇总表1',13,'日期：[=开始日期]至[=结束日期]',Null,8080,1575,3150,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'汇总表1',5,Null,0,Null,0,'疾病申报记录_数据',Null,825,1965,10405,13605,255,0,0,'宋体',10.5,0,0,0,0,16777215,1,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,7,zlRPTItems_ID.CurrVal-1,0,Null,Null,'年龄',Null,0,0,1005,0,255,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,1,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,8,zlRPTItems_ID.CurrVal-2,0,Null,Null,'传染病名称',Null,0,0,1000,0,255,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,1,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,9,zlRPTItems_ID.CurrVal-3,0,Null,Null,'男',Null,0,0,1005,0,255,2,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,1,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,9,zlRPTItems_ID.CurrVal-4,1,Null,Null,'女',Null,0,0,1005,0,255,2,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,1,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,9,zlRPTItems_ID.CurrVal-5,2,Null,Null,'计',Null,0,0,1005,0,255,2,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,1,0,Null,Null,Null,Null,Null,Null,Null,Null);

--报表：ZL1_REPORT_1282/传染病分年龄汇总表
Insert into zlPrograms(序号,标题,说明,系统,部件) Values(1282,'传染病分年龄汇总表','分年龄对传染病进行汇总',100,'zl9Report');
Insert into zlProgFuncs(系统,序号,功能,说明) Values(100,1282,'基本',Null);
Insert into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
  Select 100,1282,'基本',User,'疾病报告反馈','SELECT' From Dual Union All
  Select 100,1282,'基本',User,'疾病申报记录','SELECT' From Dual Union All
  Select 100,1282,'基本',User,'疾病阳性记录','SELECT' From Dual;
Insert into zlMenus(组别,ID,上级ID,标题,短标题,快键,图标,说明,系统,模块) Select '缺省',zlMenus_ID.Nextval,ID,'传染病分年龄汇总表','传染病分年龄汇总表',Null,105,'分年龄对传染病进行汇总',100,1282 From zlMenus Where 系统=100 And 组别='缺省' And 标题='传染病管理系统' And 模块 is NULL;

--报表：ZL1_REPORT_1283/传染病分职业汇总表
Insert Into zlReports(ID,编号,名称,说明,密码,打印机,进纸,票据,打印方式,系统,程序ID,功能,修改时间,发布时间,禁止开始时间,禁止结束时间) Values(zlReports_ID.NextVal,'ZL1_REPORT_1283','传染病分职业汇总表','分职业对传染病进行汇总','Mv:jX}o`s)4Vi{{G*U\',Null,15,0,0,100,1283,'基本',Sysdate,Sysdate,To_Date('2016-01-01 00:00:00','YYYY-MM-DD HH24:MI:SS'),To_Date('2016-01-01 00:00:00','YYYY-MM-DD HH24:MI:SS'));
Insert Into zlRPTFmts(报表ID,序号,说明,W,H,纸张,纸向,动态纸张,图样) Values(zlReports_ID.CurrVal,1,'传染病分职业汇总表1',11904,16832,9,1,0,0);
Insert Into zlRPTDatas(ID,报表ID,名称,字段,对象,类型,说明) Values(zlRPTDatas_ID.NextVal,zlReports_ID.CurrVal,'病人医嘱记录_数据','职业,202|传染病名称,202|男,139|女,139|计,139',User||'.疾病申报记录,'||User||'.疾病阳性记录,'||User||'.疾病报告反馈',1,Null);
Insert Into zlRPTSQLs(源ID,行号,内容)  Select zlRPTDatas_ID.CurrVal,a.* From (
  Select 1,'Select nvl(a.职业,''其他'') as 职业,  b.传染病名称, sum(decode(A.性别, ''男'',1,0)) as 男,sum(decode(A.性别, ''女'',1,0)) as 女,sum(decode(A.性别,''男'',1,1)) as 计 ' From Dual Union All
  Select 2,'From 疾病申报记录 A, 疾病阳性记录 B,疾病报告反馈 C ' From Dual Union All
  Select 3,'Where a.文件id = b.文件id  and A.文件ID = C.文件ID  and c.登记时间 Between [0] And [1]' From Dual Union All
  Select 4,'Group By nvl(a.职业,''其他''),b.传染病名称' From Dual) a;
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,0,'开始日期',2,CHR(38)||'本月初时间',0,Null,Null,Null,Null,Null,Null,0);
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,1,'结束日期',2,CHR(38)||'本月末时间',0,Null,Null,Null,Null,Null,Null,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'操作员',2,Null,0,'汇总表1',21,'统计人：[操作员姓名]',Null,645,15600,2100,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签1',2,Null,0,'汇总表1',12,'[单位名称]传染病分职业汇总表',Null,2705,570,6105,450,0,0,1,'宋体',22,0,0,0,0,16777215,0,Null,Null,Null,1,0,1,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'日期',2,Null,0,'汇总表1',13,'日期：[=开始日期]至[=结束日期]',Null,7720,1350,3150,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签2',2,Null,0,'汇总表1',23,'打印时间:[yyyy-mm-dd HH:MM]',Null,8035,15585,2835,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'汇总表1',5,Null,0,Null,0,'病人医嘱记录_数据',Null,645,1740,10225,13470,255,0,0,'宋体',10.5,0,0,0,0,16777215,1,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,7,zlRPTItems_ID.CurrVal-1,0,Null,Null,'职业',Null,0,0,1005,0,255,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,'SUM',1,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,8,zlRPTItems_ID.CurrVal-2,0,Null,Null,'传染病名称',Null,0,0,1000,0,255,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,'SUM',1,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,9,zlRPTItems_ID.CurrVal-3,0,Null,Null,'男',Null,0,0,1335,0,255,2,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,1,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,9,zlRPTItems_ID.CurrVal-4,1,Null,Null,'女',Null,0,0,1005,0,255,2,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,1,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,9,zlRPTItems_ID.CurrVal-5,2,Null,Null,'计',Null,0,0,1005,0,255,2,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,1,0,Null,Null,Null,Null,Null,Null,Null,Null);

--报表：ZL1_REPORT_1283/传染病分职业汇总表
Insert into zlPrograms(序号,标题,说明,系统,部件) Values(1283,'传染病分职业汇总表','分职业对传染病进行汇总',100,'zl9Report');
Insert into zlProgFuncs(系统,序号,功能,说明) Values(100,1283,'基本',Null);
Insert into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
  Select 100,1283,'基本',User,'疾病报告反馈','SELECT' From Dual Union All
  Select 100,1283,'基本',User,'疾病申报记录','SELECT' From Dual Union All
  Select 100,1283,'基本',User,'疾病阳性记录','SELECT' From Dual;
Insert into zlMenus(组别,ID,上级ID,标题,短标题,快键,图标,说明,系统,模块) Select '缺省',zlMenus_ID.Nextval,ID,'传染病分职业汇总表','传染病分职业汇总表',Null,105,'分职业对传染病进行汇总',100,1283 From zlMenus Where 系统=100 And 组别='缺省' And 标题='传染病管理系统' And 模块 is NULL;






-------------------------------------------------------------------------------
--过程修正部份
-------------------------------------------------------------------------------

--00000:张险华,2016-04-15,处理安装脚本与升级脚本不一致，源于祝庆在2012-03-20错误修改10.30.0.SQL
Create Or Replace Procedure ZL_病案审查方案_Insert
(	ID_in IN 病案审查方案.ID%Type,
	名称_in IN 病案审查方案.名称%Type,
	总分_in IN 病案审查方案.总分%Type,
	分段线_in IN 病案审查方案.分段线%Type,
	选用_in IN Number,
  说明_in IN 病案审查方案.说明%Type
)
IS
Begin
  if 选用_in=1 then
     update 病案审查方案
     Set 停用时间 =Sysdate
     Where 启用时间 Is Not Null;
  
     update 病案审查方案
     set 启用时间=Null;
  end if;
  
  if 选用_in=1 then
    INSERT INTO 病案审查方案
      (ID,名称,总分,分段线,启用时间,停用时间,说明)
    VALUES
      (ID_in,名称_in,总分_in,分段线_in,Sysdate,Null,说明_in);
  else
     INSERT INTO 病案审查方案
      (ID,名称,总分,分段线,启用时间,停用时间,说明)
    VALUES
      (ID_in,名称_in,总分_in,分段线_in,Null,Null,说明_in);
  end if;
Exception
	When Others Then
		ZL_ErrorCenter (SQLCODE, SQLERRM);
End  ZL_病案审查方案_Insert;
/

--00000:刘鹏飞,2016-04-15,处理安装脚本与升级脚本不一致问题
Create Or Replace Procedure Zl_病人变动记录_转住院
(
  病人id_In 病案主页.病人id%Type,
  主页id_In 病案主页.主页id%Type,
  住院号_In 病人信息.住院号%Type
) Is
  --功能：将住院留观病人转为住院病人
  v_Count      Number;
  v_出院科室id Number;
  v_Date       Date;
  v_Temp       Varchar2(255);
  v_人员编号   住院费用记录.操作员编号%Type;
  v_人员姓名   住院费用记录.操作员姓名%Type;
  Cursor c_Oldinfo Is
    Select b.*
    From (Select c.*
           From 病人变动记录 c
           Where c.病人id = 病人id_In And c.主页id = 主页id_In And
                 c.开始时间 = (Select Min(开始时间)
                           From 病人变动记录
                           Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > v_Date)) a, 病人变动记录 b
    
    Where b.病人id = 病人id_In And b.主页id = 主页id_In And a.开始时间 = b.终止时间 And a.开始原因 = b.终止原因 And a.附加床位 = b.附加床位
    Union
    Select *
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And 开始时间 <= v_Date;

  Cursor c_Endinfo Is
    Select * From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
  r_Oldinfo c_Oldinfo%Rowtype;
  r_Endinfo c_Endinfo%Rowtype;

  v_终止原因 病人变动记录.终止原因%Type;
  v_终止时间 病人变动记录.终止时间%Type;
  v_终止人员 病人变动记录.终止人员%Type;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --并发操作检查
  Select Nvl(状态, 0), 出院科室id
  Into v_Count, v_出院科室id
  From 病案主页
  Where 病人id = 病人id_In And 主页id = 主页id_In And 病人性质 = 2;
  If v_Count = 1 Then
    v_Error := '病人当前尚未入科,不能转为住院病人。请先将病人入科后再试。';
    Raise Err_Custom;
  Elsif v_Count = 2 Then
    v_Error := '病人当前正在转科,不能转为住院病人。请先将病人转科或取消转科后再试。';
    Raise Err_Custom;
  End If;

  Select Zl_住院日报_Count(v_出院科室id, Trunc(Sysdate)) Into v_Count From Dual;
  If v_Count > 0 Then
    v_Error := '已产生业务时间内的住院日报,不能办理该业务!';
    Raise Err_Custom;
  End If;

  Select Sysdate Into v_Date From Dual;
  v_Temp     := Zl_Identity;
  v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);

  Open c_Oldinfo; --必须先打开
  Fetch c_Oldinfo
    Into r_Oldinfo;
  Open c_Endinfo;
  Fetch c_Endinfo
    Into r_Endinfo;
  If c_Endinfo%Rowcount = 0 Then
    Close c_Endinfo;
    v_Error := '未发现该病人当前有效的变动记录！';
    Raise Err_Custom;
  End If;
  Select Count(*)
  Into v_Count
  From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 Is Null And 终止时间 Is Null;
  If v_Count > 0 Then
    v_Error := '该病人正在转科或转病区，不能进行其他变动！';
    Raise Err_Custom;
  End If;

  --取消上次变动
  If r_Oldinfo.终止时间 Is Not Null Then
    v_终止时间 := r_Oldinfo.终止时间;
    v_终止原因 := r_Oldinfo.终止原因;
    v_终止人员 := r_Oldinfo.终止人员;
    --取消上次变动
    Update 病人变动记录
    Set 终止时间 = v_Date, 终止原因 = 9, 终止人员 = v_人员姓名, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_终止时间 And 终止原因 = v_终止原因;
    --更新将来的记录如果有停止到将来的则删除上次计算时间
    Update 病人变动记录 Set 上次计算时间 = Null Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > v_Date;
  Else
    Update 病人变动记录
    Set 终止时间 = v_Date, 终止原因 = 9, 终止人员 = v_人员姓名
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
  End If;

  --产生变动记录
  While c_Oldinfo%Found Loop
    Insert Into 病人变动记录
      (Id, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号,
       操作员姓名, 终止时间, 终止原因, 终止人员)
    Values
      (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, v_Date, 9, r_Oldinfo.附加床位, r_Oldinfo.病区id, r_Oldinfo.科室id, r_Oldinfo.医疗小组id,
       r_Oldinfo.护理等级id, r_Oldinfo.床位等级id, r_Oldinfo.床号, r_Oldinfo.责任护士, r_Oldinfo.经治医师, r_Oldinfo.主治医师, r_Oldinfo.主任医师,
       r_Oldinfo.病情, v_人员编号, v_人员姓名, v_终止时间, v_终止原因, v_终止人员);
    If Nvl(r_Oldinfo.附加床位, 0) = 0 Then
      --产生病历书写时机
      Zl_电子病历时机_Insert(病人id_In, 主页id_In, 2, '入院', r_Oldinfo.科室id, r_Oldinfo.经治医师, v_Date, v_Date);
    End If;
    Fetch c_Oldinfo
      Into r_Oldinfo;
  End Loop;

  Close c_Oldinfo;
  Close c_Endinfo;

  Update 病案主页 Set 病人性质 = 0, 住院号 = 住院号_In Where 病人id = 病人id_In And 主页id = 主页id_In;
  Update 病人信息 Set 住院号 = 住院号_In, 住院次数 = Nvl(住院次数, 0) + 1 Where 病人id = 病人id_In;

  --并发操作检查
  Select Count(*)
  Into v_Count
  From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(附加床位, 0) = 0 And 开始时间 Is Not Null And 终止时间 Is Null;

  If v_Count > 1 Then
    v_Error := '发现病人存在非法的变动记录,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人变动记录_转住院;
/

--95278:涂建华,2016-04-15,处理安装脚本与升级脚本不一致问题
Create Or Replace Procedure Zl_影像检查_Set
(
  医嘱id_In  影像检查记录.医嘱id%Type,
  发送号_In  影像检查记录.发送号%Type,
  检查uid_In 影像检查记录.检查uid%Type
) Is
  Pos1         影像检查记录.位置一%Type;
  Pos2         影像检查记录.位置二%Type;
  Pos3         影像检查记录.位置三%Type;
  Receiveddate 影像检查记录.接收日期%Type;
  v_Error      Varchar2(255);
  Irowcount    Number;
  Err_Custom Exception;
  Cursor c_Advice Is
    Select a.医嘱id
    From 病人医嘱发送 a, 病人医嘱记录 b
    Where (b.Id = 医嘱id_In Or (b.相关id = 医嘱id_In And b.诊疗类别 In ('F', 'G', 'D'))) And a.医嘱id = b.Id And
          a.发送号 + 0 = 发送号_In;
Begin
  Select Count(*) Into Irowcount From 影像检查记录 b Where b.医嘱id = 医嘱id_In And b.发送号 = 发送号_In;
  If Irowcount = 0 Then
    v_Error := '该检查未正常开始，请取消后重新开始。';
    Raise Err_Custom;
  End If;

  Select 位置一, 位置二, 位置三, 接收日期
  Into Pos1, Pos2, Pos3, Receiveddate
  From 影像临时记录
  Where 检查uid = 检查uid_In;

  Update 影像检查记录
  Set 检查uid = Decode(检查uid, Null, 检查uid_In, 检查uid), 位置一 = Decode(位置一, Null, Pos1, 位置一),
      位置二 = Decode(位置二, Null, Pos2, 位置二), 位置三 = Decode(位置三, Null, Pos3, 位置三),
      接收日期 = Decode(接收日期, Null, Receiveddate, 接收日期)
  Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In;
  
  Insert Into 影像检查序列
    (序列uid, 检查uid, 序列号, 序列描述, 采集时间)
    Select a.序列uid, b.检查uid, Nvl(b.序列号, 0) + a.序列号, a.序列描述, a.采集时间
    From 影像临时序列 a,
         (Select b.检查uid, Max(c.序列号) As 序列号
           From 影像检查记录 b, 影像检查序列 c
           Where b.医嘱id = 医嘱id_In And b.发送号 = 发送号_In And b.检查uid = c.检查uid(+)
           Group By b.检查uid) b
    Where a.检查uid = 检查uid_In And Not Exists (Select a.序列UID From 影像检查序列 Where 序列UID= a.序列UID);
    
  Insert Into 影像检查图象
    (图像uid, 序列uid, 图像号, 图像描述, 采集时间, 图像时间, 层厚, 图像位置病人, 图像方向病人, 参考帧uid, 切片位置,
     行数, 列数, 像素距离, 动态图)
    Select a.图像uid, a.序列uid, a.图像号, a.图像描述, a.采集时间, a.图像时间, a.层厚, a.图像位置病人, a.图像方向病人,
           a.参考帧uid, a.切片位置, a.行数, a.列数, a.像素距离, a.动态图
    From 影像临时图象 a, 影像临时序列 b
    Where a.序列uid = b.序列uid And b.检查uid = 检查uid_In;

  Delete From 影像临时记录 Where 检查uid = 检查uid_In;

	For r_Advice In c_Advice Loop
		Update 病人医嘱发送
		Set 执行状态 = 3, 执行过程 = Decode(Sign(执行过程 - 2), 1, 执行过程, 3)
		Where 医嘱id = r_Advice.医嘱id And 发送号 = 发送号_In;
	End Loop;
Exception
	When Err_Custom Then
		Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
	When Others Then
		Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_影像检查_Set;
/
--95278:涂建华,2016-04-15,处理安装脚本与升级脚本不一致问题
CREATE OR REPLACE Procedure ZL_排队清除
(
       业务类型_IN 排队叫号队列.业务类型%Type,
       有效时间_IN Number := 1
)
Is
       v_当前有效时间 number;
Begin
     --清除当前业务类型，而且时间在有效时间之前的排队信息
     v_当前有效时间 := 有效时间_IN;
     if v_当前有效时间 = 0 then
       v_当前有效时间 := 1;
     end if;

     Delete From 排队叫号队列 Where 业务类型 = 业务类型_IN And 排队时间 < trunc(sysdate) -(v_当前有效时间-1);
     update 排队叫号队列 set 排队状态=2 where 排队时间 < trunc(sysdate);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End ZL_排队清除;
/

--95281:王振涛,2016-04-15,过程不一致
Create Or Replace Procedure ZL_检验标本销毁_edit(
	Type_IN	IN number,			--0=保存标本 1=取消标本
	标本ID串_IN IN Varchar2,
	销毁人_IN IN 检验标本记录.保存人%Type,
	销毁方式_IN IN 检验标本记录.销毁方式%Type
)
IS
Begin
	IF Type_IN = 0 THEN
		UPDATE 检验标本记录 SET 销毁人 = 销毁人_IN,销毁时间 = sysdate,销毁方式 = 销毁方式_IN
		WHERE id IN  (Select * From Table(Cast(F_Num2list(标本ID串_IN) As Zltools.T_Numlist)));
	ELSE
		UPDATE 检验标本记录 SET 销毁人 = null,销毁时间 = null,销毁方式 = null
		WHERE id IN  (Select * From Table(Cast(F_Num2list(标本ID串_IN) As Zltools.T_Numlist)));
	End if;
Exception
	When Others Then Zl_ErrorCenter (SQLCODE, SQLERRM);
End ZL_检验标本销毁_edit;
/
--95281:王振涛,2016-04-15,过程不一致
Create Or Replace Procedure ZL_检验标本保存_edit(
	Type_IN	IN number,			--0=保存标本 1=取消标本
	标本ID串_IN IN Varchar2,
	保存人_IN IN 检验标本记录.保存人%Type,
	保存位置_IN IN 检验标本记录.保存位置%Type,
	保存环境_IN IN 检验标本记录.保存环境%Type
)
IS
Begin
	IF Type_IN = 0 THEN
		UPDATE 检验标本记录 SET 保存人 = 保存人_IN,保存时间 = sysdate,保存位置 = 保存位置_IN,保存环境 = 保存环境_IN
		WHERE id IN  (Select * From Table(Cast(F_Num2list(标本ID串_IN) As Zltools.T_Numlist)));
	ELSE
		UPDATE 检验标本记录 SET 保存人 = null,保存时间 = null,保存位置 = null,保存环境 = null
		WHERE id IN  (Select * From Table(Cast(F_Num2list(标本ID串_IN) As Zltools.T_Numlist)));
	End if;
Exception
	When Others Then Zl_ErrorCenter (SQLCODE, SQLERRM);
End ZL_检验标本保存_edit;
/
--94399:李小东,2016-04-08,部门、人员扩展信息维护
Create Or Replace Procedure Zl_部门扩展信息_Insert
(
  部门id_In In 部门扩展信息.部门id%Type,
  项目_In   In 部门扩展信息.项目%Type,
  内容_In   In 部门扩展信息.内容%Type
) Is
Begin
  Insert Into 部门扩展信息 (部门id, 项目, 内容) Values (部门id_In, 项目_In, 内容_In);

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_部门扩展信息_Insert;
/

--94399:李小东,2016-04-08,部门、人员扩展信息维护
Create Or Replace Procedure Zl_部门扩展信息_Delete
(
  部门id_In In 部门扩展信息.部门id%Type,
  项目_In   In 部门扩展信息.项目%Type
) Is
Begin
  Delete From 部门扩展信息 Where 部门id = 部门id_In And 项目 = 项目_In;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_部门扩展信息_Delete;
/

--94399:李小东,2016-04-08,部门、人员扩展信息维护
Create Or Replace Procedure Zl_人员扩展信息_Insert
(
  人员id_In In 人员扩展信息.人员id%Type,
  项目_In   In 人员扩展信息.项目%Type,
  内容_In   In 人员扩展信息.内容%Type
) Is
Begin
  Insert Into 人员扩展信息 (人员id, 项目, 内容) Values (人员id_In, 项目_In, 内容_In);

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_人员扩展信息_Insert;
/

--94399:李小东,2016-04-08,部门、人员扩展信息维护
Create Or Replace Procedure Zl_人员扩展信息_Delete
(
  人员id_In In 人员扩展信息.人员id%Type,
  项目_In   In 人员扩展信息.项目%Type
) Is
Begin
  Delete From 人员扩展信息 Where 人员id = 人员id_In And 项目 = 项目_In;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_人员扩展信息_Delete;
/

--94399:李小东,2016-04-08,部门、人员扩展信息维护
Create Or Replace Procedure Zl_人员表_新增
(
  Id_In           In 人员表.Id%Type,
  编号_In         In 人员表.编号%Type,
  姓名_In         In 人员表.姓名%Type,
  简码_In         In 人员表.简码%Type,
  身份证号_In     In 人员表.身份证号%Type,
  出生日期_In     In 人员表.出生日期%Type,
  性别_In         In 人员表.性别%Type,
  民族_In         In 人员表.民族%Type,
  工作日期_In     In 人员表.工作日期%Type,
  办公室电话_In   In 人员表.办公室电话%Type,
  电子邮件_In     In 人员表.电子邮件%Type,
  执业类别_In     In 人员表.执业类别%Type,
  执业范围_In     In 人员表.执业范围%Type,
  管理职务_In     In 人员表.管理职务%Type,
  专业技术职务_In In 人员表.专业技术职务%Type,
  聘任技术职务_In In 人员表.聘任技术职务%Type,
  学历_In         In 人员表.学历%Type,
  所学专业_In     In 人员表.所学专业%Type,
  留学时间_In     In 人员表.留学时间%Type,
  留学渠道_In     In 人员表.留学渠道%Type,
  接受培训_In     In 人员表.接受培训%Type,
  科研课题_In     In 人员表.科研课题%Type,
  个人简介_In     In 人员表.个人简介%Type,
  部门列表_In     In Varchar2, --部门列表_IN参数的填写方式如下："12:1;23:0;" 
  人员性质_In     In Varchar2, --人员性质_IN参数的填写方式如下："门诊挂号员;医生;护士;" 
  别名_In         In 人员表.别名%Type := Null,
  站点_In         In 人员表.站点%Type := Null,
  签名_In         In 人员表.签名%Type := Null,
  执业证号_In     In 人员表.执业证号%Type := Null,
  资格证书号_In   In 人员表.资格证书号%Type := Null,
  执业开始日期_In In 人员表.执业开始日期%Type := Null,
  处方权标志_In   In 人员表.处方权标志%Type := Null,
  手术等级_In     In 人员表.手术等级%Type := Null,
  移动电话_In     In 人员表.移动电话%Type := Null,
  顺序_In         In 人员表.顺序%Type := Null
) Is
  Intpos    Pls_Integer;
  Int缺省   Number(1);
  Strtemp   Varchar2(2000);
  Str性质   Varchar2(10);
  Lng部门id 部门表.Id%Type;
Begin
  --首先插入记录 
  Insert Into 人员表
    (ID, 编号, 姓名, 简码, 身份证号, 出生日期, 性别, 民族, 工作日期, 办公室电话, 电子邮件, 执业类别, 执业范围, 管理职务, 专业技术职务, 聘任技术职务, 学历, 所学专业, 留学时间, 留学渠道,
     接受培训, 科研课题, 个人简介, 站点, 别名, 建档时间, 撤档时间, 签名, 执业证号, 资格证书号, 执业开始日期, 处方权标志, 手术等级, 移动电话, 顺序)
  Values
    (Id_In, 编号_In, 姓名_In, 简码_In, 身份证号_In, 出生日期_In, 性别_In, 民族_In, 工作日期_In, 办公室电话_In, 电子邮件_In, 执业类别_In, 执业范围_In, 管理职务_In,
     专业技术职务_In, 聘任技术职务_In, 学历_In, 所学专业_In, 留学时间_In, 留学渠道_In, 接受培训_In, 科研课题_In, 个人简介_In, 站点_In, 别名_In, Sysdate,
     To_Date('3000-01-01', 'YYYY-MM-DD'), 签名_In, 执业证号_In, 资格证书号_In, 执业开始日期_In, 处方权标志_In, 手术等级_In, 移动电话_In, 顺序_In);

  --接着修改所属部门 
  Strtemp := 部门列表_In;

  While Strtemp Is Not Null Loop
    Intpos := Instr(Strtemp, ':');
  
    If Intpos = 0 Then
      Strtemp := '';
    Else
      --得到部门ID 
      Str性质   := Substr(Strtemp, 1, Intpos - 1);
      Lng部门id := To_Number(Str性质);
      Strtemp   := Substr(Strtemp, Intpos + 1);
      --得到是否缺省 
      Intpos  := Instr(Strtemp, ';');
      Int缺省 := To_Number(Substr(Strtemp, 1, Intpos - 1));
      Strtemp := Substr(Strtemp, Intpos + 1);
    
      Insert Into 部门人员 (部门id, 人员id, 缺省) Values (Lng部门id, Id_In, Int缺省);
    End If;
  End Loop;

  --接着修改人员性质说明 
  Strtemp := 人员性质_In;

  While Strtemp Is Not Null Loop
    Intpos := Instr(Strtemp, ';');
  
    If Intpos = 0 Then
      Strtemp := '';
    Else
      --得到工作性质 
      Str性质 := Substr(Strtemp, 1, Intpos - 1);
      Strtemp := Substr(Strtemp, Intpos + 1);
    
      Insert Into 人员性质说明 (人员性质, 人员id) Values (Str性质, Id_In);
    End If;
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_人员表_新增;
/

--94399:李小东,2016-04-08,部门、人员扩展信息维护
Create Or Replace Procedure Zl_人员表_修改
(
  Id_In           In 人员表.Id%Type,
  编号_In         In 人员表.编号%Type,
  姓名_In         In 人员表.姓名%Type,
  简码_In         In 人员表.简码%Type,
  身份证号_In     In 人员表.身份证号%Type,
  出生日期_In     In 人员表.出生日期%Type,
  性别_In         In 人员表.性别%Type,
  民族_In         In 人员表.民族%Type,
  工作日期_In     In 人员表.工作日期%Type,
  办公室电话_In   In 人员表.办公室电话%Type,
  电子邮件_In     In 人员表.电子邮件%Type,
  执业类别_In     In 人员表.执业类别%Type,
  执业范围_In     In 人员表.执业范围%Type,
  管理职务_In     In 人员表.管理职务%Type,
  专业技术职务_In In 人员表.专业技术职务%Type,
  聘任技术职务_In In 人员表.聘任技术职务%Type,
  学历_In         In 人员表.学历%Type,
  所学专业_In     In 人员表.所学专业%Type,
  留学时间_In     In 人员表.留学时间%Type,
  留学渠道_In     In 人员表.留学渠道%Type,
  接受培训_In     In 人员表.接受培训%Type,
  科研课题_In     In 人员表.科研课题%Type,
  个人简介_In     In 人员表.个人简介%Type,
  部门列表_In     In Varchar2, --部门列表_IN参数的填写方式如下："12:1;23:0;" 
  人员性质_In     In Varchar2, --人员性质_IN参数的填写方式如下："门诊挂号员;医生;护士;" 
  别名_In         In 人员表.别名%Type := Null,
  站点_In         In 人员表.站点%Type := Null,
  签名_In         In 人员表.签名%Type := Null,
  执业证号_In     In 人员表.执业证号%Type := Null,
  资格证书号_In   In 人员表.资格证书号%Type := Null,
  执业开始日期_In In 人员表.执业开始日期%Type := Null,
  处方权标志_In   In 人员表.处方权标志%Type := Null,
  手术等级_In     In 人员表.手术等级%Type := Null,
  移动电话_In     In 人员表.移动电话%Type := Null,
  顺序_In         In 人员表.顺序%Type := Null
) Is
  Intpos    Pls_Integer;
  Int缺省   Number(1);
  Strtemp   Varchar2(2000);
  Str性质   Varchar2(10);
  Lng部门id 部门表.Id%Type;
Begin
  --首先插入修改记录 
  Update 人员表
  Set 编号 = 编号_In, 姓名 = 姓名_In, 简码 = 简码_In, 身份证号 = 身份证号_In, 出生日期 = 出生日期_In, 性别 = 性别_In, 民族 = 民族_In, 工作日期 = 工作日期_In,
      办公室电话 = 办公室电话_In, 电子邮件 = 电子邮件_In, 执业类别 = 执业类别_In, 执业范围 = 执业范围_In, 管理职务 = 管理职务_In, 专业技术职务 = 专业技术职务_In,
      聘任技术职务 = 聘任技术职务_In, 学历 = 学历_In, 所学专业 = 所学专业_In, 留学时间 = 留学时间_In, 留学渠道 = 留学渠道_In, 接受培训 = 接受培训_In, 科研课题 = 科研课题_In,
      个人简介 = 个人简介_In, 站点 = 站点_In, 别名 = 别名_In, 签名 = 签名_In, 执业证号 = 执业证号_In, 资格证书号 = 资格证书号_In, 执业开始日期 = 执业开始日期_In,
      处方权标志 = 处方权标志_In, 手术等级 = 手术等级_In, 移动电话 = 移动电话_In, 顺序 = 顺序_In
  Where ID = Id_In;

  --接着删除已有的所属部门 
  Delete From 部门人员 Where 人员id = Id_In;

  --接着修改所属部门 
  Strtemp := 部门列表_In;

  While Strtemp Is Not Null Loop
    Intpos := Instr(Strtemp, ':');
  
    If Intpos = 0 Then
      Strtemp := '';
    Else
      --得到部门ID 
      Str性质   := Substr(Strtemp, 1, Intpos - 1);
      Lng部门id := To_Number(Str性质);
      Strtemp   := Substr(Strtemp, Intpos + 1);
      --得到是否缺省 
      Intpos  := Instr(Strtemp, ';');
      Int缺省 := To_Number(Substr(Strtemp, 1, Intpos - 1));
      Strtemp := Substr(Strtemp, Intpos + 1);
    
      Insert Into 部门人员 (部门id, 人员id, 缺省) Values (Lng部门id, Id_In, Int缺省);
    End If;
  End Loop;

  --接着删除已有的性质说明 
  Delete From 人员性质说明 Where 人员id = Id_In;

  --最后修改人员性质说明 
  Strtemp := 人员性质_In;

  While Strtemp Is Not Null Loop
    Intpos := Instr(Strtemp, ';');
  
    If Intpos = 0 Then
      Strtemp := '';
    Else
      --得到人员性质 
      Str性质 := Substr(Strtemp, 1, Intpos - 1);
      Strtemp := Substr(Strtemp, Intpos + 1);
    
      Insert Into 人员性质说明 (人员性质, 人员id) Values (Str性质, Id_In);
    End If;
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_人员表_修改;
/

--94399:李小东,2016-04-08,部门、人员扩展信息维护
Create Or Replace Procedure Zl_部门表_Insert
(
  Id_In       In 部门表.Id%Type,
  上级id_In   In 部门表.上级id%Type,
  编码_In     In 部门表.编码%Type,
  名称_In     In 部门表.名称%Type,
  简码_In     In 部门表.简码%Type,
  位置_In     In 部门表.位置%Type,
  部门性质_In In Varchar2,
  临床性质_In In Varchar2, --部门性质_IN参数的填写方式如下： "临床:3:护理:3:产科:0:" 
  环境类别_In In 部门表.环境类别%Type := Null,
  站点_In     In 部门表.站点%Type := Null,
  顺序_In     In 部门表.顺序%Type := Null
) Is
  Intpos  Pls_Integer;
  Int对象 Number(1);
  Strtemp Varchar2(2000);
  Str性质 Varchar2(20);
Begin
  --首先插入记录 
  Insert Into 部门表
    (ID, 上级id, 编码, 名称, 简码, 位置, 建档时间, 撤档时间, 站点, 环境类别, 顺序)
  Values
    (Id_In, 上级id_In, 编码_In, 名称_In, 简码_In, 位置_In, Sysdate, To_Date('3000-01-01', 'yyyy-mm-dd'), 站点_In, 环境类别_In, 顺序_In);

  --接着修改部门性质说明 
  Strtemp := 部门性质_In;

  While Strtemp Is Not Null Loop
    Intpos := Instr(Strtemp, ':');
  
    If Intpos = 0 Then
      Str性质 := '';
    Else
      --得到工作性质 
      Str性质 := Substr(Strtemp, 1, Intpos - 1);
      Strtemp := Substr(Strtemp, Intpos + 1);
      --得到服务对象 
      Intpos  := Instr(Strtemp, ':');
      Int对象 := To_Number(Substr(Strtemp, 1, Intpos - 1));
      Strtemp := Substr(Strtemp, Intpos + 1);
    
      Insert Into 部门性质说明 (工作性质, 服务对象, 部门id) Values (Str性质, Int对象, Id_In);
    End If;
  End Loop;

  If 临床性质_In Is Not Null Then
    Insert Into 临床部门 (工作性质, 部门id) Values (临床性质_In, Id_In);
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_部门表_Insert;
/

--94399:李小东,2016-04-08,部门、人员扩展信息维护
Create Or Replace Procedure Zl_部门表_Update
(
  Id_In       In 部门表.Id%Type,
  上级id_In   In 部门表.上级id%Type,
  编码_In     In 部门表.编码%Type,
  名称_In     In 部门表.名称%Type,
  简码_In     In 部门表.简码%Type,
  位置_In     In 部门表.位置%Type,
  原长度_In   In Number,
  部门性质_In In Varchar2,
  临床性质_In In Varchar2, --部门性质_IN参数的填写方式如下："临床:3:护理:3:产科:0:" 
  环境类别_In In 部门表.环境类别%Type := Null,
  负责人_In   In 部门表.部门负责人%Type := Null,
  站点_In     In 部门表.站点%Type := Null,
  顺序_In     In 部门表.顺序%Type := Null
) Is
  Intpos  Pls_Integer;
  Int对象 Number(1);
  Strtemp Varchar2(2000);
  Str性质 Varchar2(20);
Begin
  --首先插入修改记录 
  Update 部门表
  Set 上级id = 上级id_In, 编码 = 编码_In, 名称 = 名称_In, 简码 = 简码_In, 位置 = 位置_In, 站点 = 站点_In, 环境类别 = 环境类别_In, 部门负责人 = 负责人_In,
      撤档时间 = To_Date('3000-1-1', 'yyyy-mm-dd'), 顺序 = 顺序_In
  Where ID = Id_In;

  --对它的下级也要修改编码 
  Update 部门表
  Set 编码 = 编码_In || Substr(编码, 原长度_In)
  Where ID In (Select ID From 部门表 Start With 上级id = Id_In Connect By Prior ID = 上级id);

  --接着删除已有的性质说明 
  Delete From 部门性质说明 Where 部门id = Id_In;

  --接着修改部门性质说明 
  Strtemp := 部门性质_In;

  While Strtemp Is Not Null Loop
    Intpos := Instr(Strtemp, ':');
  
    If Intpos = 0 Then
      Str性质 := '';
    Else
      --得到工作性质 
      Str性质 := Substr(Strtemp, 1, Intpos - 1);
      Strtemp := Substr(Strtemp, Intpos + 1);
      --得到服务对象 
      Intpos  := Instr(Strtemp, ':');
      Int对象 := To_Number(Substr(Strtemp, 1, Intpos - 1));
      Strtemp := Substr(Strtemp, Intpos + 1);
    
      Insert Into 部门性质说明 (工作性质, 服务对象, 部门id) Values (Str性质, Int对象, Id_In);
    End If;
  End Loop;

  --删除可能有的临床性质 
  Delete From 临床部门 Where 部门id = Id_In;

  If 临床性质_In Is Not Null Then
    Insert Into 临床部门 (工作性质, 部门id) Values (临床性质_In, Id_In);
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_部门表_Update;
/
--94399:李小东,2016-04-08,部门、人员扩展信息维护
Create Or Replace Procedure Zl_Lob_Append
(
  Tab_In     In Number,
  Key_In     In Varchar2,
  Txt_In     In Varchar2, --16进制的文件片段或文字片段
  Cls_In     In Number := 0, --是否清除原来的内容，第一片段传递时为1，以后为0
  Lobtype_In In Number := 0 --0-BLOB;1-CLOB
  --参数说明：
  --Tab_In：包含LOB的数据表
  --        0-病历标记图形;1-病历文件格式;2-病历文件图形;3-病历范文格式;4-病历范文图形;
  --        5-电子病历格式;6-电子病历图形;7-病历页面格式；8-电子病历附件;9-体温重叠标记
  --        10-临床路径文件,11-临床路径图标;14-人员证书记录;15-人员表;16-人员照片;
  --        19-部门扩展信息;20-人员扩展信息;
  --Key_In：数据记录的关键字
  --Txt_In：16进制的文件片段或文字片段
  --Cls_In：是否清除原来的内容，第一片段传递时为1，以后为0
  --Lobtype_In:--0-BLOB;1-CLOB
) Is
  l_Blob Blob;
  l_Clob Clob;
  t_Key  t_Strlist;

Begin
  If Tab_In = 0 Then
    If Cls_In = 1 Then
      Update 病历标记图形 Set 图形 = Empty_Blob() Where 编码 = Key_In;
    End If;
    Select 图形 Into l_Blob From 病历标记图形 Where 编码 = Key_In For Update;
  Elsif Tab_In = 1 Then
    If Cls_In = 1 Then
      Update 病历文件格式 Set 内容 = Empty_Blob() Where 文件id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 病历文件格式 (文件id, 内容) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 内容 Into l_Blob From 病历文件格式 Where 文件id = To_Number(Key_In) For Update;
  Elsif Tab_In = 2 Then
    If Cls_In = 1 Then
      Update 病历文件图形 Set 图形 = Empty_Blob() Where 对象id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 病历文件图形 (对象id, 图形) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 图形 Into l_Blob From 病历文件图形 Where 对象id = To_Number(Key_In) For Update;
  Elsif Tab_In = 3 Then
    If Cls_In = 1 Then
      Update 病历范文格式 Set 内容 = Empty_Blob() Where 文件id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 病历范文格式 (文件id, 内容) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 内容 Into l_Blob From 病历范文格式 Where 文件id = To_Number(Key_In) For Update;
  Elsif Tab_In = 4 Then
    If Cls_In = 1 Then
      Update 病历范文图形 Set 图形 = Empty_Blob() Where 对象id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 病历范文图形 (对象id, 图形) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 图形 Into l_Blob From 病历范文图形 Where 对象id = To_Number(Key_In) For Update;
  Elsif Tab_In = 5 Then
    If Cls_In = 1 Then
      Update 电子病历格式 Set 内容 = Empty_Blob() Where 文件id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 电子病历格式 (文件id, 内容) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 内容 Into l_Blob From 电子病历格式 Where 文件id = To_Number(Key_In) For Update;
  Elsif Tab_In = 6 Then
    If Cls_In = 1 Then
      Update 电子病历图形 Set 图形 = Empty_Blob() Where 对象id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 电子病历图形 (对象id, 图形) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 图形 Into l_Blob From 电子病历图形 Where 对象id = To_Number(Key_In) For Update;
  Elsif Tab_In = 7 Then
    If Cls_In = 1 Then
      Update 病历页面格式
      Set 图形 = Empty_Blob()
      Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
    End If;
    Select 图形
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3)
    For Update;
  Elsif Tab_In = 8 Then
    If Cls_In = 1 Then
      Update 电子病历附件
      Set 内容 = Empty_Blob()
      Where 病历id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 序号 = Substr(Key_In, Instr(Key_In, ',') + 1);
    End If;
    Select 内容
    Into l_Blob
    From 电子病历附件
    Where 病历id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 序号 = Substr(Key_In, Instr(Key_In, ',') + 1)
    For Update;
  Elsif Tab_In = 9 Then
    If Cls_In = 1 Then
      Update 体温重叠标记 Set 标记图形 = Empty_Blob() Where 序号 = To_Number(Key_In);
    End If;
    Select 标记图形 Into l_Blob From 体温重叠标记 Where 序号 = To_Number(Key_In) For Update;
  Elsif Tab_In = 10 Then
    If Cls_In = 1 Then
      Update 临床路径文件
      Set 内容 = Empty_Blob()
      Where 路径id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And
            文件名 = Substr(Key_In, Instr(Key_In, ',') + 1);
    End If;
    Select 内容
    Into l_Blob
    From 临床路径文件
    Where 路径id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 文件名 = Substr(Key_In, Instr(Key_In, ',') + 1)
    For Update;
  Elsif Tab_In = 11 Then
    If Cls_In = 1 Then
      Update 临床路径图标 Set 图标 = Empty_Blob() Where ID = To_Number(Key_In);
    End If;
    Select 图标 Into l_Blob From 临床路径图标 Where ID = To_Number(Key_In) For Update;
  Elsif Tab_In = 12 Then
    If Cls_In = 1 Then
      Update 病历页面格式
      Set 页眉文件 = Empty_Blob()
      Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
    End If;
    Select 页眉文件
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3)
    For Update;
  Elsif Tab_In = 13 Then
    If Cls_In = 1 Then
      Update 病历页面格式
      Set 页脚文件 = Empty_Blob()
      Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
    End If;
    Select 页脚文件
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3)
    For Update;
  Elsif Tab_In = 14 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    If Cls_In = 1 Then
      Update 人员证书记录 Set 签章信息 = Empty_Clob() Where 人员id = To_Number(t_Key(1)) And Certsn = t_Key(2);
    End If;
    Select 签章信息 Into l_Clob From 人员证书记录 Where 人员id = To_Number(t_Key(1)) And Certsn = t_Key(2) For Update;
  Elsif Tab_In = 15 Then
    If Cls_In = 1 Then
      Update 人员表 Set 签名图片 = Empty_Blob() Where ID = To_Number(Key_In);
    End If;
    Select 签名图片 Into l_Blob From 人员表 Where ID = To_Number(Key_In) For Update;
  Elsif Tab_In = 16 Then
    If Cls_In = 1 Then
      Update 人员照片 Set 照片 = Empty_Blob() Where 人员id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 人员照片 (人员id, 照片) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 照片 Into l_Blob From 人员照片 Where 人员id = To_Number(Key_In) For Update;
  Elsif Tab_In = 19 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    If Cls_In = 1 Then
      Update 部门扩展信息 Set 图片 = Empty_Blob() Where 部门id = To_Number(t_Key(1)) And 项目 = t_Key(2);
    End If;
    Select 图片 Into l_Blob From 部门扩展信息 Where 部门id = To_Number(t_Key(1)) And 项目 = t_Key(2) For Update;
  Elsif Tab_In = 20 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    If Cls_In = 1 Then
      Update 人员扩展信息 Set 图片 = Empty_Blob() Where 人员id = To_Number(t_Key(1)) And 项目 = t_Key(2);
    End If;
    Select 图片 Into l_Blob From 人员扩展信息 Where 人员id = To_Number(t_Key(1)) And 项目 = t_Key(2) For Update;
  End If;

  If Lobtype_In = 1 Then
    Dbms_Lob.Writeappend(l_Clob, Length(Txt_In), Txt_In);
  Else
    Dbms_Lob.Writeappend(l_Blob, Length(Hextoraw(Txt_In)) / 2, Hextoraw(Txt_In));
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Lob_Append;
/

--94399:李小东,2016-04-08,部门、人员扩展信息维护
Create Or Replace Function Zl_Lob_Read
(
  Tab_In     In Number,
  Key_In     In Varchar2,
  Pos_In     In Number,
  Moved_In   In Number := 0,
  Lobtype_In In Number := 0
  --参数说明：
  --Tab_In：包含LOB的数据表
  --        0-病历标记图形;1-病历文件格式;2-病历文件图形;3-病历范文格式;4-病历范文图形;
  --        5-电子病历格式;6-电子病历图形;7-病历页面格式(图形);8-电子病历附件;9-体温重叠标记;
  --        10-临床路径文件;11-临床路径图标;12-病历页面格式(页眉文件);13-病历页面格式(页脚文件);
  --        14-人员证书记录;15-人员表;16-人员照片;19-部门扩展信息;20-人员扩展信息;
  --Key_In：数据记录的关键字
  --Pos_In：从0开始不断读取，直到返回为空
  --Moved_In: 0正常记录,1读取转储后备表记录
  --LobType_IN:0-BLOb,1-CLOB
) Return Varchar2 Is
  l_Blob   Blob;
  l_Clob   Clob;
  v_Buffer Varchar2(32767);
  n_Amount Number := 2000;
  n_Offset Number := 1;
  t_Key    t_Strlist;
Begin
  If Tab_In = 0 Then
    Select 图形 Into l_Blob From 病历标记图形 Where 编码 = Key_In;
  Elsif Tab_In = 1 Then
    Select 内容 Into l_Blob From 病历文件格式 Where 文件id = To_Number(Key_In);
  Elsif Tab_In = 2 Then
    Select 图形 Into l_Blob From 病历文件图形 Where 对象id = To_Number(Key_In);
  Elsif Tab_In = 3 Then
    Select 内容 Into l_Blob From 病历范文格式 Where 文件id = To_Number(Key_In);
  Elsif Tab_In = 4 Then
    Select 图形 Into l_Blob From 病历范文图形 Where 对象id = To_Number(Key_In);
  Elsif Tab_In = 5 Then
    If Moved_In = 0 Then
      Select 内容 Into l_Blob From 电子病历格式 Where 文件id = To_Number(Key_In);
    Else
      Select 内容 Into l_Blob From H电子病历格式 Where 文件id = To_Number(Key_In);
    End If;
  Elsif Tab_In = 6 Then
    If Moved_In = 0 Then
      Select 图形 Into l_Blob From 电子病历图形 Where 对象id = To_Number(Key_In);
    Else
      Select 图形 Into l_Blob From H电子病历图形 Where 对象id = To_Number(Key_In);
    End If;
  Elsif Tab_In = 7 Then
    Select 图形
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
  Elsif Tab_In = 8 Then
    If Moved_In = 0 Then
      Select 内容
      Into l_Blob
      From 电子病历附件
      Where 病历id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 序号 = Substr(Key_In, Instr(Key_In, ',') + 1);
    Else
      Select 内容
      Into l_Blob
      From H电子病历附件
      Where 病历id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 序号 = Substr(Key_In, Instr(Key_In, ',') + 1);
    End If;
  Elsif Tab_In = 9 Then
    Select 标记图形 Into l_Blob From 体温重叠标记 Where 序号 = To_Number(Key_In);
  Elsif Tab_In = 10 Then
    Select 内容
    Into l_Blob
    From 临床路径文件
    Where 路径id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 文件名 = Substr(Key_In, Instr(Key_In, ',') + 1);
  Elsif Tab_In = 11 Then
    Select 图标 Into l_Blob From 临床路径图标 Where ID = To_Number(Key_In);
  Elsif Tab_In = 12 Then
    Select 页眉文件
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
  Elsif Tab_In = 13 Then
    Select 页脚文件
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
  Elsif Tab_In = 14 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    Select 签章信息 Into l_Clob From 人员证书记录 Where 人员id = To_Number(t_Key(1)) And Certsn = t_Key(2);
  Elsif Tab_In = 15 Then
    Select 签名图片 Into l_Blob From 人员表 Where ID = To_Number(Key_In);
  Elsif Tab_In = 16 Then
    Select 照片 Into l_Blob From 人员照片 Where 人员id = To_Number(Key_In);
  Elsif Tab_In = 19 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    Select 图片 Into l_Blob From 部门扩展信息 Where 部门id = To_Number(t_Key(1)) And 项目 = t_Key(2);
  Elsif Tab_In = 20 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    Select 图片 Into l_Blob From 人员扩展信息 Where 人员id = To_Number(t_Key(1)) And 项目 = t_Key(2);
  End If;

  n_Offset := n_Offset + Pos_In * n_Amount;
  If Lobtype_In = 1 Then
    If l_Clob Is Null Then
      v_Buffer := Null;
    Else
      Dbms_Lob.Read(l_Clob, n_Amount, n_Offset, v_Buffer);
    End If;
  Else
    If l_Blob Is Null Then
      v_Buffer := Null;
    Else
      Dbms_Lob.Read(l_Blob, n_Amount, n_Offset, v_Buffer);
    End If;
  End If;
  Return v_Buffer;
Exception
  When No_Data_Found Then
    Return Null;
End Zl_Lob_Read;
/

--94404:张德婷,2016-04-08,静配中心性能问题
--94311:张德婷,2016-04-08,静配中心性能问题
CREATE OR REPLACE Procedure Zl_输液配药记录_销帐审核
(
  配药id_In   In Varchar2, --ID串:ID1,审核标志1,ID2,审核标志2....
  操作人员_In In 输液配药记录.操作人员%Type,
  操作时间_In In 输液配药记录.操作时间%Type
) Is
  v_Tansid     Varchar2(20);
  v_Tmp        Varchar2(4000);
  v_Usercode   Varchar2(100);
  v_发药id     药品收发记录.Id%Type;
  n_Count      Number(1);
  d_审核时间   药品收发记录.审核日期%Type;
  v_No         药品收发记录.No%Type;
  v_上次no     药品收发记录.No%Type;
  n_审核标志   Number(1);
  n_操作状态   Number(2);
  v_收发ids    Varchar2(4000);
  v_退药待发id 药品收发记录.Id%Type;
  v_原始id     药品收发记录.Id%Type;
  v_Error    Varchar2(255);
  Err_Custom Exception;

  Cursor c_销帐记录 Is
    Select Distinct a.费用id, b.操作时间
    From 药品收发记录 A, 输液配药记录 B, 输液配药内容 C
    Where a.Id = c.收发id And b.Id = c.记录id And b.Id = v_Tansid And b.操作状态 = 9;

  v_销帐记录 c_销帐记录%RowType;

  Cursor c_退药记录 Is
    Select Distinct a.Id As 退药id, c.收发id, c.数量
    From 药品收发记录 A, 药品收发记录 B, 输液配药内容 C
    Where c.记录id = v_Tansid And b.Id = c.收发id And a.单据 = b.单据 And a.No = b.No And a.库房id + 0 = b.库房id And
          a.药品id + 0 = b.药品id And a.序号 = b.序号 And (a.记录状态 = 1 Or Mod(a.记录状态, 3) = 0);

  v_退药记录 c_退药记录%RowType;

  Cursor c_费用销帐 Is
    Select a.No, a.序号 || ':' || c.数量 || ':' || c.记录id As 费用序号
    From 住院费用记录 A, 药品收发记录 B, 输液配药内容 C
    Where a.Id = b.费用id And b.Id = c.收发id And  Mod(b.记录状态, 3) = 1 and c.记录id = v_Tansid;

  v_费用销帐 c_费用销帐%RowType;

Begin
  If 配药id_In Is Null Then
    v_Tmp := Null;
  Else
    v_Tmp := 配药id_In || ',';
  End If;

  v_Usercode := Zl_Identity;
  v_Usercode := Substr(v_Usercode, Instr(v_Usercode, ';') + 1);
  v_Usercode := Substr(v_Usercode, Instr(v_Usercode, ',') + 1);
  v_Usercode := Substr(v_Usercode, 1, Instr(v_Usercode, ',') - 1);

  While v_Tmp Is Not Null Loop
    --分解单据ID串
    v_Tansid   := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
    v_Tmp      := Substr(v_Tmp, Instr(v_Tmp, ',') + 1);
    n_审核标志 := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
    v_Tmp      := Substr(v_Tmp, Instr(v_Tmp, ',') + 1);

    v_收发ids := Null;

    --检查当前输液单的状态是否为待摆药状态
    Begin
      Select 操作状态 Into n_操作状态 From 输液配药记录 Where ID = v_Tansid;

      if n_操作状态<>9 then
        v_Error := '该数据已被操作，不能进行销帐审核！';
        Raise Err_Custom;
      end if;
    Exception
      When Others Then
        v_Error := '该数据已被操作！';
        Raise Err_Custom;
    End;

    If n_审核标志 = 1 Then
      n_操作状态 := 10;
    Elsif n_审核标志 = 2 Then
      n_操作状态 := 11;
    End If;

    --查找输液单对应的收发NO
    Begin
      Select NO
      Into v_No
      From 药品收发记录
      Where ID In (Select 收发id From 输液配药内容 Where 记录id In (Select ID From 输液配药记录 Where ID = v_Tansid)) And Rownum < 2;
    Exception
      When Others Then
        v_No := '';
    End;

    --收发NO相同的配药ID，审核时间以此设置为延长1秒
    If v_No = v_上次no Then
      d_审核时间 := d_审核时间 + 1 / 24 / 60 / 60;
    Else
      d_审核时间 := 操作时间_In;
      v_上次no   := v_No;
    End If;

    --销帐记录处理
    For v_销帐记录 In c_销帐记录 Loop
      Zl_病人费用销帐_Audit(v_销帐记录.费用id, v_销帐记录.操作时间, 操作人员_In, d_审核时间, n_审核标志);
    End Loop;

    Select Count(*) Into n_Count From 输液配药状态 Where 配药id = v_Tansid And 操作时间 = 操作时间_In;

    If n_Count <> 1 Then
      Insert Into 输液配药状态
        (配药id, 操作类型, 操作人员, 操作时间)
      Values
        (v_Tansid, n_操作状态, 操作人员_In, 操作时间_In);
    End If;
    Update 输液配药记录 Set 操作人员 = 操作人员_In, 操作时间 = 操作时间_In, 操作状态 = n_操作状态 Where ID = v_Tansid;

    --退药处理
    If n_审核标志 = 1 Then
      For v_退药记录 In c_退药记录 Loop
        Zl_药品收发记录_部门退药(v_退药记录.退药id, 操作人员_In, 操作时间_In, Null, Null, Null, v_退药记录.数量, Null, 操作人员_In);

        --取退药待发id
        Select a.Id
        Into v_发药id
        From 药品收发记录 A, 药品收发记录 B
        Where b.Id = v_退药记录.退药id And a.单据 = b.单据 And a.No = b.No And a.库房id + 0 = b.库房id And a.药品id + 0 = b.药品id And
              a.序号 = b.序号 And Mod(a.记录状态, 3) = 1 And a.审核日期 Is Null;
              
        --输液配药内容中的收发ID更新为退药待发的收发ID
        Update 输液配药内容 Set 收发id = v_发药id Where 记录id = v_Tansid And 收发id = v_退药记录.收发id;

        If v_收发ids Is Null Then
          v_收发ids := v_发药id;
        Else
          v_收发ids := v_收发ids || ',' || v_发药id;
        End If;

        --取原始id
        Select a.Id
        Into v_原始id
        From 药品收发记录 A, 药品收发记录 B
        Where b.Id = v_退药记录.退药id And a.单据 = b.单据 And a.No = b.No And a.库房id + 0 = b.库房id And a.药品id + 0 = b.药品id And
              a.序号 = b.序号 And Mod(a.记录状态, 3) = 0 And a.审核日期 Is Not Null;
              
        insert into 输液配药内容(记录id,收发id,数量) select 记录id,v_原始id ,数量 from 输液配药内容 where 记录id=v_Tansid and 收发id=v_发药id;
        
        v_收发ids := v_收发ids || ',' || v_原始id;
      End Loop;
      
      --费用销帐
      For v_费用销帐 In c_费用销帐 Loop
        Zl_住院记帐记录_Delete(v_费用销帐.No, v_费用销帐.费用序号, v_Usercode, Zl_Username, 2, 1, 1, d_审核时间);
      End Loop;
    End If;
  End Loop;
Exception
   When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_输液配药记录_销帐审核;
/

--94759:刘尔旋,2016-04-08,结帐误差费问题
Create Or Replace Procedure Zl_病人结帐记录_Cancel
(
  No_In         病人结帐记录.No%Type,
  冲销id_In     病人结帐记录.Id%Type,
  操作员编号_In 病人结帐记录.操作员编号%Type,
  操作员姓名_In 病人结帐记录.操作员姓名%Type,
  作废时间_In   病人结帐记录.收费时间%Type := Null
) As
  Err_Item Exception;
  v_Err_Msg Varchar2(255);

  --该游标用于预交记录相关信息

  --该游标用于处理费用相关汇总表
  Cursor c_Money(v_Id 病人预交记录.结帐id%Type) Is
    Select NO, 开单部门id, 病人科室id, 执行部门id, 病人病区id, 病人id, 主页id, 收入项目id, 门诊标志, 结帐金额
    From 住院费用记录
    Where 结帐id = v_Id
    Union All
    Select NO, 开单部门id, 病人科室id, 执行部门id, 0 As 病人病区id, 病人id, 0 As 主页id, 收入项目id, 门诊标志, 结帐金额
    From 门诊费用记录
    Where 结帐id = v_Id;

  r_Moneyrow c_Money%RowType;

  --该游标包含病人的相关信息
  Cursor c_Pati(n_病人id 病人信息.病人id%Type) Is
    Select a.姓名, a.性别, a.年龄, a.住院号, a.门诊号, b.主页id, b.出院病床, b.当前病区id, b.出院科室id, Nvl(b.费别, a.费别) As 费别, a.险类, c.编码 As 付款方式
    From 病人信息 A, 病案主页 B, 医疗付款方式 C
    Where a.病人id = n_病人id And a.病人id = b.病人id(+) And Nvl(a.主页id, 0) = b.主页id(+) And a.医疗付款方式 = c.名称(+);
  r_Pati c_Pati%RowType;

  --过程变量
  v_实际票号 病人预交记录.实际票号%Type;
  n_预交id   病人预交记录.Id%Type;
  n_病人id   病人信息.病人id%Type;

  n_原id    病人结帐记录.Id%Type;
  n_结帐id  病人结帐记录.Id%Type;
  v_打印ids Varchar2(5000);

  n_来源     Number; --1-门诊;2-住院;3-门诊和住院
  n_返回值   病人余额.预交余额%Type;
  n_组id     财务缴款分组.Id%Type;
  n_预交类别 Number;
  d_Date     Date;

Begin
  n_组id := Zl_Get组id(操作员姓名_In);
  Begin
    Select ID, 病人id, 实际票号 Into n_原id, n_病人id, v_实际票号 From 病人结帐记录 Where 记录状态 = 1 And NO = No_In;
    --打印的内容
    For r_打印 In (Select b.Id
                 From 票据使用明细 A, 票据打印内容 B
                 Where a.打印id = b.Id And a.性质 = 1 And a.原因 In (1, 3) And b.数据性质 = 3 And b.No = No_In
                 Order By a.使用时间 Desc) Loop
      v_打印ids := v_打印ids || ',' || r_打印.Id;
    End Loop;
    If v_打印ids Is Not Null Then
      v_打印ids := Substr(v_打印ids, 2);
    End If;
  Exception
    When Others Then
      Begin
        v_Err_Msg := '没有发现要作废的结帐单据,可能已经作废！';
        Raise Err_Item;
      End;
  End;

  Open c_Pati(n_病人id);
  Fetch c_Pati
    Into r_Pati; --体检系统调用此过程,团体结帐时没有病人信息
  d_Date := 作废时间_In;
  If d_Date Is Null Then
    Select Sysdate Into d_Date From Dual;
  End If;
  n_结帐id := 冲销id_In;
  If Nvl(n_结帐id, 0) = 0 Then
    Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  End If;

  --病人结帐记录
  Insert Into 病人结帐记录
    (ID, NO, 实际票号, 记录状态, 中途结帐, 病人id, 操作员编号, 操作员姓名, 开始日期, 结束日期, 收费时间, 备注, 原因, 缴款组id, 结帐类型, 结算状态, 主页id, 住院次数, 结帐金额)
    Select n_结帐id, NO, 实际票号, 2, 中途结帐, 病人id, 操作员编号_In, 操作员姓名_In, 开始日期, 结束日期, d_Date, 备注, 原因, n_组id, 结帐类型, 1, 主页id, 住院次数,
           -1 * 结帐金额
    From 病人结帐记录
    Where ID = n_原id;

  Update 病人结帐记录 Set 记录状态 = 3 Where ID = n_原id;

  --作废收回票据(可能以前没有使用票据,无法收回)
  If v_打印ids Is Not Null Then
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
      Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
      From 票据使用明细
      Where 打印id In (Select Column_Value From Table(f_Str2list(v_打印ids))) And 票种 = 3 And 性质 = 1;
  End If;

  Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
  --插入结算方式为NULL的结算方式
  Insert Into 病人预交记录
    (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交, 结帐id,
     缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质, 校对标志)
    Select n_预交id, No_In, v_实际票号, 12, 1, n_病人id, r_Pati.主页id, r_Pati.出院科室id, Null, Null, Null, Null, Null, Null, Null,
           d_Date, 操作员姓名_In, 操作员编号_In, -1 * Sum(冲预交), n_结帐id, n_组id, Null, Null, Null, Null As 卡号, Null As 交易流水号,
           Null As 交易说明, Null As 合作单位, 2, 1
    From 病人预交记录
    Where 结帐id = n_原id;

  --确定结帐的费用记录来源
  Begin
    Select Case
             When Nvl(Max(住院), 0) = 1 And Nvl(Max(门诊), 0) = 1 Then
              3
             When Nvl(Max(住院), 0) = 1 Then
              2
             Else
              1
           End
    Into n_来源
    From (Select 1 As 住院, 0 As 门诊
           From 住院费用记录
           Where 结帐id = n_原id And Rownum = 1
           Union All
           Select 0 As 住院, 1 As 门诊 From 门诊费用记录 Where 结帐id = n_原id And Rownum = 1);
  
  Exception
    When Others Then
      n_来源 := 3;
  End;

  If n_来源 = 2 Or n_来源 = 3 Then
    --作废结帐对应的费用记录:不包含原始结帐产生的误差项目
    Insert Into 住院费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 记帐单id, 病人id, 主页id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 床号, 病人病区id,
       病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 划价人, 开单部门id,
       开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 执行人, 执行时间, 操作员姓名, 操作员编号, 结帐金额, 结帐id, 保险项目否, 保险大类id, 统筹金额, 是否急诊, 保险编码, 费用类型, 摘要,
       缴款组id, 医疗小组id)
      Select 病人费用记录_Id.Nextval, NO, 实际票号, To_Number('1' || Substr(记录性质, Length(记录性质), 1)), 记录状态, 序号, 从属父号, 价格父号, 多病人单,
             记帐单id, 病人id, 主页id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 床号, 病人病区id, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次,
             加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, Null, Null, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 执行人,
             执行时间, 操作员姓名, 操作员编号, -1 * 结帐金额, n_结帐id, 保险项目否, 保险大类id, 统筹金额, 是否急诊, 保险编码, 费用类型, 摘要, 缴款组id, 医疗小组id
      From 住院费用记录
      Where 结帐id = n_原id;
  End If;

  If n_来源 = 1 Or n_来源 = 3 Then
    Insert Into 门诊费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 记帐单id, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 病人科室id, 费别, 收费类别,
       收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 划价人, 开单部门id, 开单人, 发生时间, 登记时间,
       执行部门id, 执行状态, 执行人, 执行时间, 操作员姓名, 操作员编号, 结帐金额, 结帐id, 保险项目否, 保险大类id, 统筹金额, 是否急诊, 保险编码, 费用类型, 摘要, 缴款组id, 主页id)
      Select 病人费用记录_Id.Nextval, NO, 实际票号, To_Number('1' || Substr(记录性质, Length(记录性质), 1)), 记录状态, 序号, 从属父号, 价格父号, 记帐单id,
             病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费,
             记帐费用, 收入项目id, 收据费目, 标准单价, Null, Null, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 执行人, 执行时间, 操作员姓名, 操作员编号,
             -1 * 结帐金额, n_结帐id, 保险项目否, 保险大类id, 统筹金额, 是否急诊, 保险编码, 费用类型, 摘要, 缴款组id, 主页id
      From 门诊费用记录
      Where 结帐id = n_原id;
  End If;

  For r_Moneyrow In c_Money(n_结帐id) Loop
    --病人余额 ,所以不需要更新这两个汇总表
  
    If Nvl(r_Moneyrow.门诊标志, 0) = 1 Or Nvl(r_Moneyrow.门诊标志, 0) = 2 Then
      n_预交类别 := r_Moneyrow.门诊标志;
    Elsif Nvl(r_Moneyrow.主页id, 0) = 0 Or Nvl(r_Moneyrow.门诊标志, 0) = 4 Then
      --体检:门诊病人
      n_预交类别 := 1;
    Else
      n_预交类别 := 2;
    End If;
  
    If Nvl(r_Moneyrow.门诊标志, 0) <> 4 Then
      Update 病人余额
      Set 费用余额 = Nvl(费用余额, 0) - r_Moneyrow.结帐金额 --注:新的结帐ID产生的是负数金额
      Where 病人id = r_Moneyrow.病人id And 类型 = n_预交类别 And 性质 = 1
      Returning 费用余额 Into n_返回值;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 预交余额, 费用余额)
        Values
          (r_Moneyrow.病人id, 1, n_预交类别, 0, -1 * r_Moneyrow.结帐金额);
        n_返回值 := -1 * r_Moneyrow.结帐金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete 病人余额
        Where 病人id = r_Moneyrow.病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
      End If;
    End If;
  
    --病人未结费用
    Update 病人未结费用
    Set 金额 = Nvl(金额, 0) - r_Moneyrow.结帐金额
    Where 病人id = r_Moneyrow.病人id And Nvl(主页id, 0) = Nvl(r_Moneyrow.主页id, 0) And
          Nvl(病人病区id, 0) = Nvl(r_Moneyrow.病人病区id, 0) And Nvl(病人科室id, 0) = Nvl(r_Moneyrow.病人科室id, 0) And
          Nvl(开单部门id, 0) = Nvl(r_Moneyrow.开单部门id, 0) And Nvl(执行部门id, 0) = Nvl(r_Moneyrow.执行部门id, 0) And
          收入项目id + 0 = r_Moneyrow.收入项目id And 来源途径 + 0 = r_Moneyrow.门诊标志;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人未结费用
        (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
      Values
        (r_Moneyrow.病人id, Decode(r_Moneyrow.主页id, Null, Null, 0, Null, r_Moneyrow.主页id),
         Decode(r_Moneyrow.病人病区id, Null, Null, 0, Null, r_Moneyrow.病人病区id), r_Moneyrow.病人科室id, r_Moneyrow.开单部门id,
         r_Moneyrow.执行部门id, r_Moneyrow.收入项目id, r_Moneyrow.门诊标志, -1 * r_Moneyrow.结帐金额);
    End If;
  
  End Loop;
  Close c_Pati;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人结帐记录_Cancel;
/

--94920:许华峰,2016-04-06,依赖性接口获取报告内容
CREATE OR REPLACE Function Zlpub_Pacs_获取报告文本
(
  Ids_In In Varchar2
) Return Xmltype
--Ids_In规则是以 '|' 分隔的ID串，开始/结尾无 '|'
  --根所给定的病历文件ID串生成内容XML并返回XMLType
 Is
  File_Id Varchar2(32);
  Docxml  Xmltype;
  --标记变量
  v_Mark     Varchar2(500);
  v_Marks    Varchar2(2500);
  Makxml     Xmltype;
  Maksxml    Xmltype;
  n_Adviceid Number(18);
  v_Ftppath  Varchar2(200);

  n_Count Number(1);
  --标记变量
  n_i       Number(2);
  n_Len     Number(3);
  n_Width   Number(4);
  n_Height  Number(4);
  v_Id      Varchar2(100);
  v_Ftppath Varchar2(500);
  v_Title   Varchar2(100);
  v_Newline Varchar2(2);
  v_Text    Varchar2(4000);
  v_Name    Varchar2(100);
  v_Type    Varchar2(20);

  x_Content    Xmltype;
  Section_Node Xmldom.Domnode;
  Element_Node Xmldom.Domnode;
  Xcdom        Xmldom.Domdocument;
  Node_List    Xmldom.Domnodelist;
  Section_List Xmldom.Domnodelist;

  Function Getorigpic(Pic_Id In 电子病历记录.Id%Type) Return Xmltype Is
    --读取病历图形，以多个 <OrigPic>节点返回，每个节点<=2000长度
    l_Blob   Blob;
    v_Buffer Varchar2(32767);
    n_Amount Number := 2000;
    n_Offset Number := 1;
    Pos_In   Number := 0;
    Origpic  Xmltype;
    Origpics Xmltype;
  Begin
    Select 图形 Into l_Blob From 电子病历图形 Where 对象id = Pic_Id;
    While True Loop
      n_Offset := 1 + Pos_In * n_Amount;
      n_Amount := 2000;
      v_Buffer := '';
      Begin
        Dbms_Lob.Read(l_Blob, n_Amount, n_Offset, v_Buffer);
      Exception
        When No_Data_Found Then
          Exit;
      End;
    
      If Length(v_Buffer) = 0 Then
        Exit;
      Else
        Select Xmlelement("OrigPic", Xmlattributes(Pos_In As "序号"), v_Buffer) Into Origpic From Dual;
      End If;
      Select Xmlconcat(Origpics, Origpic) Into Origpics From Dual;
      Pos_In := Pos_In + 1;
    End Loop;
    Return Origpics;
  End Getorigpic;
Begin
  Select Xmltype('<?xml version="1.0" encoding="' || Value || '"?><ZlEPR></ZlEPR>')
  Into Docxml
  From Nls_Database_Parameters
  Where Parameter = 'NLS_CHARACTERSET';

  For J In 1 .. 1000 Loop
    File_Id := 0;
    Select Zl_Eprsplit(Ids_In, '|', J) Into File_Id From Dual;
    If File_Id Is Null Then
      Exit;
    Else
      --判断是新版报告还是老版报告,有记录则是新版报告
      Select Count(1)
      Into n_Count
      From 影像报告记录 A, 病人医嘱报告 B
      Where a.Id = Hextoraw(File_Id) And a.Id = b.检查报告id;
    
      If n_Count > 0 Then
        --开始某个文件读取
        Begin
          Select a.医嘱id,
                 Appendchildxml(Docxml, '/ZlEPR',
                                 Xmlelement("Document",
                                             Xmlattributes(b.姓名 As "姓名", b.病人id As "病人ID", b.主页id As "主页ID", a.文档标题 As "文件名",
                                                            Rawtohex(a.Id) As "文件ID")))
          Into n_Adviceid, Docxml
          From 影像报告记录 A, 病人医嘱记录 B
          Where a.Id = Hextoraw(File_Id) And a.医嘱id = b.Id;
        Exception
          --给定的文件ID无效
          When Others Then
            Return Null;
        End;
        Select Insertchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]', 'Compend',
                               Xmlelement("Compend", Xmlattributes('0' As "ID", '内容' As "Name")))
        Into Docxml
        From Dual;
      
        --开始读取内容
        Select b.报告内容 Into x_Content From 影像报告记录 B Where b.Id || '' = File_Id;
      
        Xcdom := Xmldom.Newdomdocument(x_Content);
      
        n_i := -1;
      
        Section_List := Xmldom.Getelementsbytagname(Xcdom, 'zlxml');
        Section_Node := Xmldom.Item(Section_List, 0);
        Node_List    := Xmldom.Getelementsbytagname(Xmldom.Makeelement(Section_Node), '*');
        n_Len        := Xmldom.Getlength(Node_List);
      
        For I In 0 .. n_Len - 1 Loop
          Element_Node := Xmldom.Item(Node_List, I);
        
          v_Name    := Xmldom.Getnodename(Element_Node);
          v_Newline := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'br');
        
          If v_Newline Is Null Then
            v_Newline := '1';
          End If;
        
          If v_Name = 'section' Then
            --提纲
            v_Title := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'title');
            v_Id    := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'sid');
          
            Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]',
                                   Xmlelement("Compend", Xmlattributes(v_Title As "Name", v_Id As "ID")))
            Into Docxml
            From Dual;
          Elsif v_Name = 'utext' Then
            --文本
            v_Text := LTrim(LTrim(Xmldom.Getnodevalue(Xmldom.Getfirstchild(Element_Node)), ':'), '：');
          
            If Nvl(v_Id, ' ') = ' ' Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/Compend[@ID=0]',
                                     Xmlelement("Text", Xmlattributes(v_Newline As "NewLine"), v_Text))
              Into Docxml
              From Dual;
            Else
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID="' || File_Id || '"]/descendant::Compend[@ID="' || v_Id || '"]',
                                     Xmlelement("Text", Xmlattributes(v_Newline As "NewLine"), v_Text))
              Into Docxml
              From Dual;
            End If;
          Elsif v_Name = 'element' Then
            --要素
            v_Title := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'title');
            v_Text  := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'value') ||
                       Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'unit');
          
            If Nvl(v_Id, ' ') = ' ' Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/Compend[@ID=0]',
                                     Xmlelement("Element", Xmlattributes(v_Title As "Name", v_Newline As "NewLine"),
                                                 v_Text))
              Into Docxml
              From Dual;
            Else
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID="' || File_Id || '"]/descendant::Compend[@ID="' || v_Id || '"]',
                                     Xmlelement("Element", Xmlattributes(v_Title As "Name", v_Newline As "NewLine"),
                                                 v_Text))
              Into Docxml
              From Dual;
            End If;
          Elsif v_Name = 'image' Then
            --图片
            n_Width  := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'width');
            n_Height := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'height');
            v_Name   := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'key');
            v_Type   := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'class');
          
            If Nvl(v_Name, ' ') <> ' ' Then
              If Nvl(v_Id, ' ') = ' ' Then
                Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/Compend[@ID=0]',
                                       Xmlelement("Picture",
                                                   Xmlattributes(n_Width As "OrigWidth", n_Height As "OrigHeight",
                                                                  n_Width As "ShowWidth", n_Height As "ShowHeight",
                                                                  v_Name As "PicName", n_Adviceid As "AdviceID",
                                                                  v_Type As "Type")))
                Into Docxml
                From Dual;
              Else
                Select Appendchildxml(Docxml,
                                       '/ZlEPR/Document[@文件ID="' || File_Id || '"]/descendant::Compend[@ID="' || v_Id || '"]',
                                       Xmlelement("Picture",
                                                   Xmlattributes(n_Width As "OrigWidth", n_Height As "OrigHeight",
                                                                  n_Width As "ShowWidth", n_Height As "ShowHeight",
                                                                  v_Name As "PicName", n_Adviceid As "AdviceID",
                                                                  v_Type As "Type")))
                Into Docxml
                From Dual;
              End If;
            End If;
          
          Elsif v_Name = 'signature' Then
            --签名
            v_Text := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'displayinfo');
          
            If Nvl(v_Id, ' ') = ' ' Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/Compend[@ID=0]',
                                     Xmlelement("Sign", Xmlattributes(v_Newline As "NewLine"), Zl_Eprsplit(v_Text, ';', 1)))
              Into Docxml
              From Dual;
            Else
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID="' || File_Id || '"]/descendant::Compend[@ID="' || v_Id || '"]',
                                     Xmlelement("Sign", Xmlattributes(v_Newline As "NewLine"), Zl_Eprsplit(v_Text, ';', 1)))
              Into Docxml
              From Dual;
            End If;
          End If;
        End Loop;
      
        For Aa In (Select '/' || a.Ftp目录 || '/ReportImages/' || To_Char(b.创建时间, 'YYYYMMDD') || '/' || b.Id || '/' As v_Ftppath
                   From 影像设备目录 A, 影像报告记录 B
                   Where a.设备号 = b.设备号 And b.Id = File_Id) Loop
        
          Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/Compend[@ID=0]',
                                 Xmlelement("FtpPath", Xmlattributes(v_Newline As "NewLine"), Aa.v_Ftppath))
          Into Docxml
          From Dual;
        End Loop;
      Else
        --开始某个病历文件读取
        Begin
          Select Appendchildxml(Docxml, '/ZlEPR',
                                 Xmlelement("Document",
                                             Xmlattributes(b.姓名 As "姓名", a.病人id As "病人ID", a.主页id As "主页ID", a.病历名称 As "文件名",
                                                            a.Id As "文件ID")))
          Into Docxml
          From 电子病历记录 A, 病人信息 B
          Where a.Id = File_Id And a.编辑方式 = 0 And a.病人id = b.病人id;
        
          Select 医嘱id Into n_Adviceid From 病人医嘱报告 Where 病历id = File_Id;
        Exception
          --给定的病历文件ID无效
          When Others Then
            Return Null;
        End;
        Select Insertchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]', 'Compend',
                               Xmlelement("Compend", Xmlattributes('0' As "ID", '内容' As "Name")))
        Into Docxml
        From Dual;
      
        Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                               Xmlelement("Text", Xmlattributes(Nvl(Null, 0) As "NewLine"), '内容文本'))
        Into Docxml
        From Dual;
      
        For Rs In (Select ID, 父id, 对象序号, 对象类型, 对象属性, 内容行次, 内容文本, 是否换行, 要素名称
                   From (Select ID, 父id, 对象序号, 对象类型, 对象属性, 内容行次, 内容文本, 是否换行, 要素名称
                          From 电子病历内容
                          Where 文件id = File_Id And 对象序号 > 0 And 对象序号 <> ID And 终止版 = 0)
                   Start With 父id Is Null
                   Connect By Prior ID = 父id
                   Order Siblings By 对象序号, 内容行次) Loop
          If Rs.对象类型 = 1 Then
            --提纲
            If Rs.父id Is Null Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']',
                                     Xmlelement("Compend", Xmlattributes(Rs.内容文本 As "Name", Rs.Id As "ID")))
              Into Docxml
              From Dual;
            Else
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                     Xmlelement("Compend", Xmlattributes(Rs.内容文本 As "Name", Rs.Id As "ID")))
              Into Docxml
              From Dual;
            End If;
          Elsif Rs.对象类型 = 2 Then
            --文本
            If Rs.父id Is Null Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                     Xmlelement("Text", Xmlattributes(Nvl(Rs.是否换行, 0) As "NewLine"), Rs.内容文本))
              Into Docxml
              From Dual;
            Else
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                     Xmlelement("Text", Xmlattributes(Nvl(Rs.是否换行, 0) As "NewLine"), Rs.内容文本))
              Into Docxml
              From Dual;
            End If;
          Elsif Rs.对象类型 = 3 Then
            --表格
            If Rs.父id Is Null Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                     Xmlelement("Table",
                                                 Xmlattributes(Zl_Eprsplit(Rs.对象属性, ';', 1) As "Rows",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 2) As "Cols",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 3) As "Width",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 4) As "Height",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 5) As "ColWidthString",
                                                                Nvl(Rs.是否换行, 0) As "NewLine", Rs.Id As "ID"), Rs.内容文本))
              Into Docxml
              From Dual;
            Else
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                     Xmlelement("Table",
                                                 Xmlattributes(Zl_Eprsplit(Rs.对象属性, ';', 1) As "Rows",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 2) As "Cols",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 3) As "Width",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 4) As "Height",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 5) As "ColWidthString",
                                                                Nvl(Rs.是否换行, 0) As "NewLine", Rs.Id As "ID"), Rs.内容文本))
              Into Docxml
              From Dual;
            End If;
          
            ---对表格的单元格进行填充
            For Rs_Cell In (Select ID, 父id, 对象序号, 对象类型, 对象属性, 内容行次, 内容文本, 是否换行, 要素名称
                            From 电子病历内容
                            Where 文件id = File_Id And 父id = Rs.Id And 终止版 = 0
                            Order By 内容行次, ID) Loop
              If Rs_Cell.对象类型 = 2 Or Rs_Cell.对象类型 = 4 Then
                If Zl_Eprsplit(Rs_Cell.对象属性, '|', 26) Is Null Then
                  --兼容历史病历
                  Select Appendchildxml(Docxml,
                                         '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Table[@ID=' || Rs.Id || ']',
                                         Xmlelement("Cell",
                                                     Xmlattributes(Zl_Eprsplit(Rs_Cell.对象属性, '|', 2) As "Row",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '|', 3) As "Col",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '|', 2) || '_' ||
                                                                     Zl_Eprsplit(Rs_Cell.对象属性, '|', 3) As "Row_Col",
                                                                    Decode(Rs_Cell.对象类型, 2, 0, 4, 1) As "Type",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '|', 5) As "Width",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '|', 6) As "Height",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '|', 4) As "MergeNo",
                                                                    Nvl(Rs.是否换行, 0) As "NewLine", Rs_Cell.Id As "ID"),
                                                     Rs_Cell.内容文本))
                  Into Docxml
                  From Dual;
                Else
                  Select Appendchildxml(Docxml,
                                         '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Table[@ID=' || Rs.Id || ']',
                                         Xmlelement("Cell",
                                                     Xmlattributes(Zl_Eprsplit(Rs_Cell.对象属性, '|', 3) As "Row",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '|', 4) As "Col",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '|', 3) || '_' ||
                                                                     Zl_Eprsplit(Rs_Cell.对象属性, '|', 4) As "Row_Col",
                                                                    Decode(Rs_Cell.对象类型, 2, 0, 4, 1) As "Type",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '', 6) As "Width",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '|', 7) As "Height",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '|', 5) As "MergeNo",
                                                                    Nvl(Rs.是否换行, 0) As "NewLine", Rs_Cell.Id As "ID"),
                                                     Rs_Cell.内容文本))
                  Into Docxml
                  From Dual;
                End If;
              Elsif Rs_Cell.对象类型 = 5 And Zl_Eprsplit(Rs_Cell.对象属性, ';', 1) = 2 Then
                --单元格图
                /*Picxml := Getorigpic(Rs_Cell.Id); --由Webservice直接读取BLOB之后直接写文件以提高速度*/
                Select Appendchildxml(Docxml,
                                       '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Table[@ID=' || Rs.Id || ']',
                                       Xmlelement("Picture",
                                                   Xmlattributes(Zl_Eprsplit(Rs_Cell.对象属性, ';', 2) As "Row",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 3) As "Col",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 8) As "OrigWidth",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 9) As "OrigHeight",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 6) As "ShowWidth",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 7) As "ShowHeight",
                                                                  Nvl(Zl_Eprsplit(Rs_Cell.对象属性, ';', 12), ' ') As "PicName",
                                                                  Nvl(Zl_Eprsplit(Rs_Cell.对象属性, ';', 13), '0') As "AdviceID",
                                                                  Rs_Cell.Id As "ID"), Rs_Cell.Id))
                Into Docxml
                From Dual;
              
                If Nvl(n_Adviceid, 0) = 0 Then
                  n_Adviceid := Nvl(Zl_Eprsplit(Rs_Cell.对象属性, ';', 13), '0');
                End If;
              Elsif Rs_Cell.对象类型 = 5 And Zl_Eprsplit(Rs_Cell.对象属性, ';', 1) <> 2 Then
                --单元格图
                /*Picxml := Getorigpic(Rs_Cell.Id); --由Webservice直接读取BLOB之后直接写文件以提高速度*/
                Select Appendchildxml(Docxml,
                                       '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Table[@ID=' || Rs.Id ||
                                        ']/Cell[@Row_Col="' || Zl_Eprsplit(Rs_Cell.对象属性, ';', 2) || '_' ||
                                        Zl_Eprsplit(Rs_Cell.对象属性, ';', 3) || '"]',
                                       Xmlelement("Picture",
                                                   Xmlattributes(Zl_Eprsplit(Rs_Cell.对象属性, ';', 2) As "Row",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 3) As "Col",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 8) As "OrigWidth",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 9) As "OrigHeight",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 6) As "ShowWidth",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 7) As "ShowHeight",
                                                                  Nvl(Zl_Eprsplit(Rs_Cell.对象属性, ';', 12), ' ') As "PicName",
                                                                  Nvl(Zl_Eprsplit(Rs_Cell.对象属性, ';', 13), '0') As "AdviceID",
                                                                  Rs_Cell.Id As "ID"), Rs_Cell.Id))
                Into Docxml
                From Dual;
                --制作标记子节点集
                v_Mark  := '';
                Makxml  := Null;
                Maksxml := Null;
                For Rs_Mark In (Select ID, 父id, 内容文本, 内容行次
                                From 电子病历内容
                                Where 父id = Rs_Cell.Id
                                Order By 内容行次) Loop
                  v_Marks := v_Mark || Rs_Mark.内容文本;
                  v_Marks := Replace(v_Marks, '||', '^');
                  For I In 1 .. 100 Loop
                    v_Mark := Zl_Eprsplit(v_Marks, '^', I);
                    If Zl_Eprsplit(v_Mark, '|', 15) Is Null Then
                      --最后一个标记信息不全，存在下一行中
                      Exit;
                    Else
                      Select Xmlelement("Mark",
                                         Xmlforest(Zl_Eprsplit(v_Mark, '|', 2) As "类型",
                                                    Zl_Eprsplit(v_Mark, '|', 3) As "内容", Zl_Eprsplit(v_Mark, '|', 4) As "点集",
                                                    Zl_Eprsplit(v_Mark, '|', 5) As "X1", Zl_Eprsplit(v_Mark, '|', 6) As "Y1",
                                                    Zl_Eprsplit(v_Mark, '|', 7) As "X2", Zl_Eprsplit(v_Mark, '|', 8) As "Y2",
                                                    Zl_Eprsplit(v_Mark, '|', 9) As "填充色",
                                                    Zl_Eprsplit(v_Mark, '|', 10) As "填充方式",
                                                    Zl_Eprsplit(v_Mark, '|', 11) As "线条色",
                                                    Zl_Eprsplit(v_Mark, '|', 12) As "字体色",
                                                    Zl_Eprsplit(v_Mark, '|', 13) As "线型",
                                                    Zl_Eprsplit(v_Mark, '|', 14) As "线宽",
                                                    Zl_Eprsplit(v_Mark, '|', 15) As "字体"))
                      Into Makxml
                      From Dual;
                      Select Xmlconcat(Maksxml, Makxml) Into Maksxml From Dual;
                    End If;
                  End Loop;
                End Loop;
                --向Picture插入标记子节点
                Select Appendchildxml(Docxml,
                                       '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Picture[@ID=' || Rs_Cell.Id || ']',
                                       Maksxml)
                Into Docxml
                From Dual;
              End If;
            End Loop;
          Elsif Rs.对象类型 = 4 Then
            --要素
            If Rs.父id Is Null Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                     Xmlelement("Element", Xmlattributes(Rs.要素名称 As "Name", Nvl(Rs.是否换行, 0) As "NewLine"),
                                                 Rs.内容文本))
              Into Docxml
              From Dual;
            Else
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                     Xmlelement("Element", Xmlattributes(Rs.要素名称 As "Name", Nvl(Rs.是否换行, 0) As "NewLine"),
                                                 Rs.内容文本))
              Into Docxml
              From Dual;
            End If;
          Elsif Rs.对象类型 = 5 And Nvl(Rs.内容行次, 0) = 0 Then
            --图片
            /*Picxml := Getorigpic(Rs.Id);--由Webservice直接读取BLOB之后直接写文件以提高速度*/
            If Rs.父id Is Null Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                     Xmlelement("Picture",
                                                 Xmlattributes(Zl_Eprsplit(Rs.对象属性, ';', 8) As "OrigWidth",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 9) As "OrigHeight",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 6) As "ShowWidth",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 7) As "ShowHeight",
                                                                Nvl(Zl_Eprsplit(Rs.对象属性, ';', 12), ' ') As "PicName",
                                                                Nvl(Zl_Eprsplit(Rs.对象属性, ';', 13), '0') As "AdviceID",
                                                                Nvl(Rs.是否换行, 0) As "NewLine", Rs.Id As "ID"), Rs.Id))
              Into Docxml
              From Dual;
            Else
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                     Xmlelement("Picture",
                                                 Xmlattributes(Zl_Eprsplit(Rs.对象属性, ';', 8) As "OrigWidth",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 9) As "OrigHeight",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 6) As "ShowWidth",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 7) As "ShowHeight",
                                                                Nvl(Zl_Eprsplit(Rs.对象属性, ';', 12), ' ') As "PicName",
                                                                Nvl(Zl_Eprsplit(Rs.对象属性, ';', 13), '0') As "AdviceID",
                                                                Nvl(Rs.是否换行, 0) As "NewLine", Rs.Id As "ID"), Rs.Id))
              Into Docxml
              From Dual;
            End If;
            --制作标记子节点集
            v_Mark  := '';
            Makxml  := Null;
            Maksxml := Null;
            For Rs_Mark In (Select ID, 父id, 内容文本, 内容行次 From 电子病历内容 Where 父id = Rs.Id Order By 内容行次) Loop
              v_Marks := v_Mark || Rs_Mark.内容文本;
              v_Marks := Replace(v_Marks, '||', '^');
              For I In 1 .. 100 Loop
                v_Mark := Zl_Eprsplit(v_Marks, '^', I);
                If Zl_Eprsplit(v_Mark, '|', 15) Is Null Then
                  --最后一个标记信息不全，存在下一行中
                  Exit;
                Else
                  Select Xmlelement("Mark",
                                     Xmlforest(Zl_Eprsplit(v_Mark, '|', 2) As "类型", Zl_Eprsplit(v_Mark, '|', 3) As "内容",
                                                Zl_Eprsplit(v_Mark, '|', 4) As "点集", Zl_Eprsplit(v_Mark, '|', 5) As "X1",
                                                Zl_Eprsplit(v_Mark, '|', 6) As "Y1", Zl_Eprsplit(v_Mark, '|', 7) As "X2",
                                                Zl_Eprsplit(v_Mark, '|', 8) As "Y2", Zl_Eprsplit(v_Mark, '|', 9) As "填充色",
                                                Zl_Eprsplit(v_Mark, '|', 10) As "填充方式",
                                                Zl_Eprsplit(v_Mark, '|', 11) As "线条色", Zl_Eprsplit(v_Mark, '|', 12) As "字体色",
                                                Zl_Eprsplit(v_Mark, '|', 13) As "线型", Zl_Eprsplit(v_Mark, '|', 14) As "线宽",
                                                Zl_Eprsplit(v_Mark, '|', 15) As "字体"))
                  Into Makxml
                  From Dual;
                  Select Xmlconcat(Maksxml, Makxml) Into Maksxml From Dual;
                End If;
              End Loop;
            End Loop;
            --向Picture插入标记子节点
            Select Appendchildxml(Docxml,
                                   '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Picture[@ID=' || Rs.Id || ']',
                                   Maksxml)
            Into Docxml
            From Dual;
          Elsif Rs.对象类型 = 7 Then
            --诊断
            If Rs.父id Is Null Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                     Xmlelement("Diagnosise", Xmlattributes(Nvl(Rs.是否换行, 0) As "NewLine"), Rs.内容文本))
              Into Docxml
              From Dual;
            Else
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                     Xmlelement("Diagnosise", Xmlattributes(Nvl(Rs.是否换行, 0) As "NewLine"), Rs.内容文本))
              Into Docxml
              From Dual;
            End If;
          Elsif Rs.对象类型 = 8 Then
            --签名
            If Rs.父id Is Null Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                     Xmlelement("Sign", Xmlattributes(Nvl(Rs.是否换行, 0) As "NewLine"),
                                                 Zl_Eprsplit(Rs.内容文本, ';', 1)))
              Into Docxml
              From Dual;
            Else
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                     Xmlelement("Sign", Xmlattributes(Nvl(Rs.是否换行, 0) As "NewLine"),
                                                 Zl_Eprsplit(Rs.内容文本, ';', 1)))
              Into Docxml
              From Dual;
            End If;
          End If;
        End Loop;
      
        For Aa In (Select A1.Ftp目录 || '/' || To_Char(l.接收日期, 'yyyymmdd') || '/' || l.检查uid As v_Ftppath
                   From 影像检查记录 L, 影像设备目录 A1
                   Where l.位置一 = A1.设备号(+) And l.医嘱id = n_Adviceid) Loop
        
          Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/Compend[@ID=0]',
                                 Xmlelement("FtpPath", Xmlattributes(v_Newline As "NewLine"), Aa.v_Ftppath))
          Into Docxml
          From Dual;
        End Loop;
      End If;
    End If;
  End Loop;

  Return Docxml;
Exception
  When Others Then
    Return Null;
End Zlpub_Pacs_获取报告文本;
/

--94539:刘尔旋,2016-04-05,三方机构退号处理预交缴款挂号记录的问题
Create Or Replace Procedure Zl_三方机构挂号_Delete
(
  单据号_In     门诊费用记录.No%Type,
  交易流水号_In 病人预交记录.交易流水号%Type,
  交易说明_In   病人预交记录.交易说明%Type,
  退号时间_In   门诊费用记录.登记时间%Type := Null,
  预交id_In     病人预交记录.Id%Type := Null
) As
  v_Error Varchar(255);
  Err_Custom Exception;

  --该游标用于判断是否单独收病历费,及挂号汇总表处理
  Cursor c_Registinfo
  (
    v_状态     病人挂号记录.记录状态%Type,
    v_性质     病人挂号记录.记录性质%Type,
    v_无效单据 Number := 0
  ) Is
    Select a.发生时间, a.登记时间, b.项目id, b.科室id, b.医生姓名, b.医生id, b.号码
    From 病人挂号记录 A, 挂号安排 B
    Where a.记录性质 = Decode(v_无效单据, 0, v_性质, a.记录性质) And a.记录状态 = v_状态 And a.No = 单据号_In And a.号别 = b.号码 And Rownum = 1;

  r_Registrow c_Registinfo%RowType;

  --该光标用于处理人员缴款余额中退的不同结算方式的金额
  Cursor c_Opermoney Is
    Select Distinct b.结算方式, b.冲预交
    From 门诊费用记录 A, 病人预交记录 B
    Where a.结帐id = b.结帐id And a.No = 单据号_In And a.记录性质 = 4 And a.记录状态 = 3 And b.记录性质 = 4 And b.记录状态 = 3 And
          Nvl(b.冲预交, 0) <> 0;

  n_执行状态       病人挂号记录.执行状态%Type;
  n_打印id         票据打印内容.Id%Type;
  n_结帐id         门诊费用记录.结帐id%Type;
  n_原结帐id       病人预交记录.结帐id%Type;
  n_病人id         病人信息.病人id%Type;
  n_返回值         病人余额.预交余额%Type;
  n_分诊台签到排队 Number;
  n_预交id         病人预交记录.Id%Type;
  n_预约挂号       Number;
  n_无效单据       Number; --无效单据没有产生费用单据
  n_挂号生成队列   Number;
  n_Count          Number;
  n_组id           财务缴款分组.Id%Type;
  d_退号时间       Date;
  v_操作员编号     人员表.编号%Type;
  v_操作员姓名     人员表.姓名%Type;
  v_合作单位       合作单位挂号汇总.合作单位%Type;
  n_预约状态       病人挂号记录.预约%Type;
  v_Temp           Varchar2(100);
  d_登记时间       病人挂号记录.登记时间%Type;
  v_号别           病人挂号记录.号别%Type;
  n_号序           病人挂号记录.号序%Type;
  n_启用分时段     Number;
  d_预约时间       病人挂号记录.预约时间%Type;
  n_合作单位限制   Number(18);
  n_预约生成队列   Number;
  n_记录性质       Number;
  n_状态           Number;
  n_退号重用       Number(3);
  n_预交支付       Number(3);
  n_正常支付       Number(3);
  Function Zl_操作员
  (
    Type_In     Integer,
    Splitstr_In Varchar2
  ) Return Varchar2 As
    n_Step Number(18);
    v_Sub  Varchar2(1000);
    --Type_In:0-获取缺省部门ID;1-获取操作员编号;2-获取操作员姓名
    -- SplitStr:格式为:部门ID,部门名称;人员ID,人员编号,人员姓名(用Zl_Identity获取的)
  Begin
    If Type_In = 0 Then
      --缺省部门
      n_Step := Instr(Splitstr_In, ',');
      v_Sub  := Substr(Splitstr_In, 1, n_Step - 1);
      Return v_Sub;
    End If;
    If Type_In = 1 Then
      --操作员编码
      n_Step := Instr(Splitstr_In, ';');
      v_Sub  := Substr(Splitstr_In, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, 1, n_Step - 1);
      Return v_Sub;
    End If;
    If Type_In = 2 Then
      --操作员姓名
      n_Step := Instr(Splitstr_In, ';');
      v_Sub  := Substr(Splitstr_In, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      Return v_Sub;
    End If;
  End;
Begin
  --部门ID,部门名称;人员ID,人员编号,人员姓名
  v_Temp := Zl_Identity(0);
  If Nvl(v_Temp, ' ') = ' ' Then
    v_Error := '当前操作人员未设置对应的人员关系,不能继续。';
    Raise Err_Custom;
  End If;
  v_操作员编号 := Zl_操作员(1, v_Temp);
  v_操作员姓名 := Zl_操作员(2, v_Temp);

  n_组id := Zl_Get组id(v_操作员姓名);

  d_退号时间 := 退号时间_In;
  If d_退号时间 Is Null Then
    d_退号时间 := Sysdate;
  End If;

  --首先判断要退号/取消预约的记录是否存在
  Begin
    Select Decode(记录性质, 2, 1, 0), 记录性质, 登记时间, 号别, 号序, Nvl(预约时间, 发生时间), Nvl(合作单位, ''), Nvl(预约, 0), Decode(记录状态, 0, 1, 0)
    Into n_预约挂号, n_记录性质, d_登记时间, v_号别, n_号序, d_预约时间, v_合作单位, n_预约状态, n_无效单据
    From 病人挂号记录
    Where NO = 单据号_In And 记录状态 In (0, 1) And Rownum <= 1;
  Exception
    When Others Then
      n_预约挂号 := -1;
  End;

  If n_预约挂号 = -1 Then
    v_Error := '单据可能已经被退号或单据输入错误!';
    Raise Err_Custom;
  End If;

  Begin
    Select 1
    Into n_启用分时段
    From 挂号安排 A, 挂号安排时段 B
    Where a.号码 = v_号别 And a.Id = b.安排id And Rownum <= 1;
  Exception
    When Others Then
      n_启用分时段 := 0;
  End;

  --预约检查是否添加合作单位控制
  --如果设置了合作单位控制 则
  Select Count(0) Into n_合作单位限制 From 合作单位安排控制 Where Rownum = 1;
  --更新挂号序号状态
  n_退号重用 := Zl_To_Number(zl_GetSysParameter('已退序号允许挂号', 1111));
  If n_退号重用 = 0 Then
    Update 挂号序号状态
    Set 状态 = 4
    Where 号码 = v_号别 And 序号 = n_号序 And 日期 Between Trunc(d_预约时间) And Trunc(d_预约时间 + 1) - 1 / 24 / 60 / 60;
  Else
    Delete 挂号序号状态
    Where 号码 = v_号别 And 序号 = n_号序 And 日期 Between Trunc(d_预约时间) And Trunc(d_预约时间 + 1) - 1 / 24 / 60 / 60;
  End If;
  If Nvl(n_预约挂号, 0) = 1 Or Nvl(n_无效单据, 0) = 1 Then
    If Nvl(n_无效单据, 0) = 0 Then
      --N天内不能取消预约号
      n_Count := Zl_To_Number(zl_GetSysParameter('N天内不能取消预约号', 1111));
      If n_Count <> 0 Then
        If Trunc(Sysdate - n_Count) < d_登记时间 Then
          v_Error := '不能退掉预约在' || To_Char(Trunc(Sysdate - n_Count), 'yyyy-mm-dd') || '以前的预约单!';
          Raise Err_Custom;
        End If;
      End If;
    End If;
  
    n_状态 := Case n_无效单据
              When 1 Then
               0
              Else
               1
            End;
    --减少已约数
    Open c_Registinfo(n_状态, 2, n_无效单据);
    Fetch c_Registinfo
      Into r_Registrow;
  
    Update 病人挂号汇总
    Set 已约数 = Nvl(已约数, 0) - n_预约状态, 已挂数 = Nvl(已挂数, 0) - Decode(n_预约状态, 0, 1, 0)
    Where 日期 = Trunc(r_Registrow.发生时间) And 科室id = r_Registrow.科室id And 项目id = r_Registrow.项目id And
          Nvl(医生姓名, '医生') = Nvl(r_Registrow.医生姓名, '医生') And Nvl(医生id, 0) = Nvl(r_Registrow.医生id, 0) And
          (号码 = r_Registrow.号码 Or 号码 Is Null);
  
    If Sql%RowCount = 0 Then
      Insert Into 病人挂号汇总
        (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已约数, 已挂数)
      Values
        (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
         Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, -n_预约状态, Decode(n_预约状态, 0, 1, 0));
    End If;
  
    If Nvl(n_合作单位限制, 0) <> 0 And Nvl(v_合作单位, '') <> '' And Nvl(n_预约状态, 0) <> 0 Then
      Update 合作单位挂号汇总
      Set 已约数 = Nvl(已约数, 0) - n_预约状态, 已接数 = Nvl(已接数, 0) - Decode(n_预约状态, 0, 1, 0)
      Where 日期 = Trunc(r_Registrow.发生时间) And (号码 = r_Registrow.号码 Or 号码 Is Null) And 合作单位 = Nvl(v_合作单位, '') And
            序号 = Nvl(n_号序, 0);
      If Sql%RowCount = 0 Then
        Insert Into 合作单位挂号汇总
          (日期, 号码, 已约数, 合作单位, 序号, 已接数)
        Values
          (Trunc(r_Registrow.发生时间), r_Registrow.号码, -n_预约状态, v_合作单位, Nvl(n_号序, 0), -decode(n_预约状态, 0, 1, 0));
      End If;
    End If;
    Close c_Registinfo;
  
    If Nvl(n_无效单据, 0) = 0 Then
      --删除门诊费用记录
      Delete From 门诊费用记录 Where NO = 单据号_In And 记录性质 = 4 And 记录状态 = 0;
      --如果预约生成队列时需要清除队列
      n_挂号生成队列 := Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113));
      If Nvl(n_挂号生成队列, 0) = 1 Then
        n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
        If Nvl(n_预约生成队列, 0) = 1 Then
          --要删除队列
          For v_挂号 In (Select ID, 诊室, 执行部门id, 执行人 From 病人挂号记录 Where NO = 单据号_In) Loop
            Zl_排队叫号队列_Delete(v_挂号.执行部门id, v_挂号.Id);
          End Loop;
        End If;
      End If;
    End If;
  Else
    Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  
    --更新挂号序号状态
  
    --病人就诊状态
    Select 病人id Into n_病人id From 门诊费用记录 Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And 序号 = 1;
  
    If n_病人id Is Not Null Then
      Update 病人信息 Set 就诊状态 = 0, 就诊诊室 = Null Where 病人id = n_病人id;
      --删除门诊号相关处理,只有当只有一条挂号记录并且病人建档日期与挂号日期近似时才会处理
    End If;
  
    --门诊费用记录
    Insert Into 门诊费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别, 收费细目id, 计算单位, 付数,
       数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 执行人, 操作员编号, 操作员姓名, 发生时间, 登记时间,
       结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 缴款组id)
      Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别,
             收费细目id, 计算单位, 付数, -数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, -应收金额, -实收金额, 开单部门id, 开单人, 执行部门id, 执行人,
             v_操作员编号, v_操作员姓名, 发生时间, d_退号时间, n_结帐id, -1 * 结帐金额, 保险项目否, 保险大类id, -1 * 统筹金额, 摘要,
             Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, n_组id
      From 门诊费用记录
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In;
  
    Update 门诊费用记录 Set 记录状态 = 3 Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In;
    Select 结帐id
    Into n_原结帐id
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 = 3 And NO = 单据号_In And Rownum = 1;
  
    Select Count(Distinct 结算方式) Into n_Count From 病人预交记录 Where 结帐id = n_原结帐id;
    If n_Count > 1 Then
      v_Error := '不能处理多种结算方式,请检查传入的退号单据是否正确!';
      Raise Err_Custom;
    End If;
    n_预交id := 预交id_In;
    If Nvl(预交id_In, 0) = 0 Then
      Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
    End If;
    Begin
      Select 1
      Into n_预交支付
      From 病人预交记录
      Where Mod(记录性质, 10) = 1 And 记录状态 = 1 And 结帐id = n_原结帐id And Rownum < 2;
    Exception
      When Others Then
        n_预交支付 := 0;
    End;
    Begin
      Select 1
      Into n_正常支付
      From 病人预交记录
      Where Mod(记录性质, 10) = 4 And 记录状态 = 1 And 结帐id = n_原结帐id And Rownum < 2;
    Exception
      When Others Then
        n_正常支付 := 0;
    End;
    If n_预交支付 = 1 And n_正常支付 = 1 Then
      v_Error := '不能处理多种结算方式,请检查传入的退号单据是否正确!';
      Raise Err_Custom;
    End If;
    If n_预交支付 = 1 Then
      --原样退回预交
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
        Select n_预交id, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, d_退号时间, v_操作员姓名,
               v_操作员编号, -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
        From 病人预交记录
        Where 记录性质 In (1, 11) And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0;
      --处理病人预交余额 
      For c_预交 In (Select 病人id, 预交类别, -1 * Sum(Nvl(冲预交, 0)) As 冲预交
                   From 病人预交记录
                   Where 记录性质 In (1, 11) And 结帐id = n_结帐id
                   Group By 病人id, 预交类别) Loop
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) + Nvl(c_预交.冲预交, 0)
        Where 病人id = c_预交.病人id And 类型 = Nvl(c_预交.预交类别, 2) And 性质 = 1
        Returning 预交余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 病人余额
            (病人id, 预交余额, 性质, 类型)
          Values
            (c_预交.病人id, Nvl(c_预交.冲预交, 0), 1, Nvl(c_预交.预交类别, 2));
          n_返回值 := Nvl(c_预交.冲预交, 0);
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 病人余额
          Where 病人id = c_预交.病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
        End If;
      End Loop;
    Else
    
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 交易流水号, 交易说明, 合作单位,
         结算序号, 卡类别id, 结算性质)
        Select n_预交id, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_退号时间, v_操作员编号, v_操作员姓名, -冲预交, n_结帐id, n_组id,
               交易流水号_In, 交易说明_In, 合作单位, n_结帐id, 卡类别id, 结算性质
        From 病人预交记录
        Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_原结帐id;
    
      Update 病人预交记录 Set 记录状态 = 3 Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_原结帐id;
    End If;
    --退卡收回票据(可能上次挂号使用票据,不能收回)
    Begin
      --从最后一次的打印内容中取
      Select ID
      Into n_打印id
      From (Select b.Id
             From 票据使用明细 A, 票据打印内容 B
             Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 4 And b.No = 单据号_In
             Order By a.使用时间 Desc)
      Where Rownum < 2;
    Exception
      When Others Then
        Null;
    End;
    If n_打印id Is Not Null Then
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
        Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_退号时间, v_操作员姓名
        From 票据使用明细
        Where 打印id = n_打印id And 性质 = 1;
    End If;
  
    --相关汇总表的处理
  
    --病人挂号汇总
    Open c_Registinfo(1, 1);
    Fetch c_Registinfo
      Into r_Registrow;
  
    If c_Registinfo%RowCount = 0 Then
      --只收病历费时无号别,不处理
      Close c_Registinfo;
    Else
    
      --需要确定是否预约挂号
      --1.如果是退预约挂号产生的挂号记录,则需要减已挂数和其中已接数
      --2.如果是正常挂号,则只减已挂数
      Begin
        Select Decode(预约, Null, 0, 0, 0, 1), 执行状态
        Into n_预约挂号, n_执行状态
        From 病人挂号记录
        Where NO = 单据号_In And 记录状态 = 1 And Rownum = 1;
      Exception
        When Others Then
          n_预约挂号 := 0;
      End;
      --0-等待接诊,1-完成就诊,2-正在就诊,-1标记为不就诊
      If n_执行状态 > 0 Then
        If n_执行状态 = 1 Then
          v_Error := '该病人已经完成就诊,不能再退号!';
        Else
          v_Error := '该病人正在就诊, 不能退号!';
        End If;
        Raise Err_Custom;
      End If;
    
      Update 病人挂号汇总
      Set 已挂数 = Nvl(已挂数, 0) - 1, 其中已接收 = Nvl(其中已接收, 0) - n_预约状态, 已约数 = Nvl(已约数, 0) - n_预约状态
      Where 日期 = Trunc(r_Registrow.发生时间) And 科室id = r_Registrow.科室id And 项目id = r_Registrow.项目id And
            Nvl(医生姓名, '医生') = Nvl(r_Registrow.医生姓名, '医生') And Nvl(医生id, 0) = Nvl(r_Registrow.医生id, 0) And
            (号码 = r_Registrow.号码 Or 号码 Is Null);
    
      If Sql%RowCount = 0 Then
        Insert Into 病人挂号汇总
          (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 其中已接收)
        Values
          (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
           Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, -1, -1 * n_预约挂号);
      End If;
      If Nvl(n_合作单位限制, 0) <> 0 And Nvl(v_合作单位, '') <> '' And Nvl(n_预约状态, 0) <> 0 Then
        Update 合作单位挂号汇总
        Set 已接数 = Nvl(已接数, 0) - 1, 已约数 = Nvl(已约数, 0) - n_预约挂号
        Where 日期 = Trunc(r_Registrow.发生时间) And (号码 = r_Registrow.号码 Or 号码 Is Null) And 合作单位 = Nvl(v_合作单位, '') And
              序号 = Nvl(n_号序, 0);
        If Sql%RowCount = 0 Then
          Insert Into 合作单位挂号汇总
            (日期, 号码, 已约数, 合作单位, 已接数)
          Values
            (Trunc(r_Registrow.发生时间), r_Registrow.号码, -1, v_合作单位, -1 * n_预约挂号);
        End If;
      End If;
      Close c_Registinfo;
    End If;
  
    --人员缴款余额(包括个人帐户等的结算金额,不含退冲预交款)
    For r_Opermoney In c_Opermoney Loop
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + (-1 * r_Opermoney.冲预交)
      Where 收款员 = v_操作员姓名 And 结算方式 = r_Opermoney.结算方式 And 性质 = 1
      Returning 余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (v_操作员姓名, r_Opermoney.结算方式, 1, -1 * r_Opermoney.冲预交);
        n_返回值 := r_Opermoney.冲预交;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = v_操作员姓名 And 结算方式 = r_Opermoney.结算方式 And 性质 = 1 And Nvl(余额, 0) = 0;
      End If;
    End Loop;
  
    n_挂号生成队列 := Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113));
    If n_挂号生成队列 <> 0 Then
      n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
      If Nvl(n_分诊台签到排队, 0) = 0 Then
        --要删除队列
        For v_挂号 In (Select ID, 诊室, 执行部门id, 执行人 From 病人挂号记录 Where NO = 单据号_In) Loop
          Zl_排队叫号队列_Delete(v_挂号.执行部门id, v_挂号.Id);
        End Loop;
      End If;
    End If;
  
    --医保产生的就诊登记记录
    Delete From 就诊登记记录
    Where (病人id, 主页id, 就诊时间) In (Select 病人id, 主页id, 发生时间 From 病人挂号记录 Where NO = 单据号_In);
  End If;

  If Nvl(n_无效单据, 0) = 0 Then
    Update 病人挂号记录 Set 记录状态 = 3 Where NO = 单据号_In And 记录状态 = 1;
    If Sql%NotFound Then
      v_Error := '未找到挂号单据,请检查!';
      Raise Err_Custom;
    End If;
    Insert Into 病人挂号记录
      (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 操作员编号, 操作员姓名,
       复诊, 号序, 预约, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位)
      Select 病人挂号记录_Id.Nextval, NO, 记录性质, 2, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, d_退号时间,
             发生时间, v_操作员编号, v_操作员姓名, 复诊, 号序, 预约, 接收人, 接收时间, 交易流水号_In, 交易说明_In, 合作单位
      From 病人挂号记录
      Where NO = 单据号_In And 记录状态 = 3;
  End If;
  --消息推送
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 2, 单据号_In;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]+' || v_Error || '+[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_三方机构挂号_Delete;
/

--94851:涂建华,2016-04-05,Pacs文档编辑器词句或插件加载时机
CREATE OR REPLACE Package b_PACS_RptAntetype Is
  --Create By Hwei;
  --2014/11/25
  Type t_Refcur Is Ref Cursor;

  --1.获取文件原型类别
  Procedure p_Get_Antetypelistkind(
    Val Out t_Refcur
	);
  --2.根据文档类型获取文档信息
  Procedure p_Get_Antetypelis_By_Kind(
	Val           Out t_Refcur,
	种类_In      影像报告原型清单.种类%Type,
	Stop_Flag    Number,
	Condition_In Varchar2
	);
  --3.添加一个文档原型
  Procedure p_Add_Antetypelist(
    Id_In           影像报告原型清单.ID%Type,
	种类_In         影像报告原型清单.种类%Type,
	编码_In         影像报告原型清单.编码%Type,
	名称_In         影像报告原型清单.名称%Type,
    设备号_In		影像设备目录.设备号%Type,
	说明_In         影像报告原型清单.说明%Type,
	可否重置页面_In 影像报告原型清单.可否重置页面%Type,
	可否重置格式_In 影像报告原型清单.可否重置格式%Type,
    可否书写多份_In 影像报告原型清单.可否书写多份%Type,
	是否禁用_In     影像报告原型清单.是否禁用%Type,
	创建人_In       影像报告原型清单.创建人%Type,
	内容_In         影像报告原型清单.内容%Type,
	控制选项_In     影像报告原型清单.控制选项%Type,
	词句加载时机_In 影像报告原型清单.词句加载时机%Type,
	插件加载时机_In 影像报告原型清单.插件加载时机%Type,
	专用插件_In     影像报告原型清单.专用插件%Type,
	Copy_Id_In      影像报告原型清单.ID%Type,
	Only_Head_In    Varchar2,
	分组_In         影像报告原型清单.分组%Type
	);
  --4.修改一个文档原型
  Procedure p_Edit_Antetypelist(
    Id_In           影像报告原型清单.ID%Type,
    种类_In         影像报告原型清单.种类%Type,
    编码_In         影像报告原型清单.编码%Type,
    名称_In         影像报告原型清单.名称%Type,
    设备号_In		影像设备目录.设备号%Type,
    说明_In         影像报告原型清单.说明%Type,
    可否重置页面_In 影像报告原型清单.可否重置页面%Type,
    可否重置格式_In 影像报告原型清单.可否重置格式%Type,
    可否书写多份_In 影像报告原型清单.可否书写多份%Type,
    是否禁用_In     影像报告原型清单.是否禁用%Type,
    修改人_In       影像报告原型清单.修改人%Type,
    内容_In         影像报告原型清单.内容%Type,
    控制选项_In     影像报告原型清单.控制选项%Type,
	词句加载时机_In 影像报告原型清单.词句加载时机%Type,
	插件加载时机_In 影像报告原型清单.插件加载时机%Type,
    专用插件_In     影像报告原型清单.专用插件%Type,
    Copy_Id_In      影像报告原型清单.ID%Type,
    Only_Head_In    Varchar2,
    分组_In         影像报告原型清单.分组%Type
	);
  --5.删除一个文件原型
  Procedure p_Del_Antetypelist(
    Id_In 影像报告原型清单.Id%Type
	);
  --6.根据ID获取文件原型
  Procedure p_Get_Antetypelist_By_Id(
	Val           Out t_Refcur,
	Id_In 影像报告原型清单.Id%Type
	);
  --7.获取原型XML内容
  Procedure p_Get_Antetypelist_Content(
	Val           Out t_Refcur,
	Id_In 影像报告原型清单.Id%Type
	);
  --8.停用或启用文件原型
  Procedure p_Stop_Antetypelist(
    Id_In 影像报告原型清单.Id%Type
	);

  --9.新增文档种类信息
  Procedure p_Add_Doc_Kind(
    编码_In 影像报告种类.编码%Type,
    名称_In 影像报告种类.名称%Type,
    说明_In 影像报告种类.说明%Type
	);
  --10.删除文档种类信息
  Procedure p_Del_Doc_Kind;
  --11.获取预备提纲信息
  Procedure p_Get_Pre_Outline(
    Val Out t_Refcur
	);
  --12.添加预备提纲信息
  Procedure p_Add_Pre_Outline(
    ID_In   影像报告预备提纲.ID%Type,
	编码_In 影像报告预备提纲.编码%Type,
	名称_In 影像报告预备提纲.名称%Type,
	说明_In 影像报告预备提纲.说明%Type
	);
  --13.删除预备提纲信息
  Procedure p_Del_Pre_Outline;
  --14.获取导出的文档原型信息
  Procedure p_Output_Antetypelist(
    Val Out t_Refcur
	);
  --15.添加原型片段
  Procedure p_Add_Antetype_Fragments(
    原型ID_In 影像报告原型片段.原型ID%Type,
	片段ID_In 影像报告原型片段.片段ID%Type
	);
  --16.删除原型片段
  Procedure p_Del_Antetype_Fragments(
    原型ID_In 影像报告原型片段.原型ID%Type
	);
  --17.获取原型片段
  Procedure p_Get_Antetype_Fragments(
    Val           Out t_Refcur,
	原型ID_In 影像报告原型片段.原型ID%Type
	);
  --18.获取某个原型关联的某个片段分类
  Procedure p_Get_Antetype_f_Byaidfid(
    Val           Out t_Refcur,		
	原型ID_In 影像报告原型片段.原型ID%Type,
    片段ID_In 影像报告原型片段.片段ID%Type
	);
  --19.插入文档原型XML内容
  Procedure p_Edit_Antetypelist_Content(
    Id_In     影像报告原型清单.Id%Type,
	内容_In   影像报告原型清单.内容%Type,
	修改人_In 影像报告原型清单.修改人%Type
	);
  --20.获取所有原型
  Procedure p_Get_All_Antetype_Lists(
    Val Out t_Refcur
	);
  --21.获取已经设置了关联的原型片段类别的信息

  Procedure p_Get_Antetype_Fragments_Info(
	Val           Out t_Refcur,
	原型ID_In 影像报告原型片段.原型ID%Type
	);
  --22.获取选择的类别下面的短语名称
  Procedure p_Get_Selected_Fragments(
	Val           Out t_Refcur,
	原型id_In Varchar2
	);
  --23.获取能复制的原型名称

  Procedure p_Get_Copy_Antetype(
	Val           Out t_Refcur,
	种类_In 影像报告原型清单.种类%Type
	);
  --24.获取原型的分组信息
  Procedure p_Get_Antetype_Category(
	Val           Out t_Refcur,
	种类_In 影像报告原型清单.种类%Type
	);
  --25.根据原型同步范文提纲
  Procedure p_Synchronous_Sample(
    原型id_In 影像报告原型清单.Id%Type
	);
  --26.获取导出的原型列表
  Procedure p_Get_Out_Antetypelist(
    Val Out t_Refcur
	);
  --27.通过编码获取原型种类信息
  Procedure p_Get_Antetype_Kind_By_Code(
	Val           Out t_Refcur,
	编码_In 影像报告种类.编码%Type
	);
  --28.获取事件信息，不包含固定事件
  Procedure p_Get_Doc_Event(
    Val Out t_Refcur
	);
  --29.获取关于原型导出的重复信息

  Procedure p_Get_Antetypelist_Same_Info(
	Val           Out t_Refcur,
	Tablename_In Varchar2,
    Id_In        影像报告原型清单.Id%Type,
    编码_In      Varchar2,
    名称_In      Varchar2
	);
  --30.获取事件重复的信息
  Procedure p_Event_Same_Info(
	Val           Out t_Refcur,	
	Id_In      影像报告事件.Id%Type,
    原型ID_In  影像报告事件.原型ID%Type,
    元素IID_In 影像报告事件.元素IID%Type,
    种类_In    影像报告事件.种类%Type,
    名称_In    影像报告事件.名称%Type,
    编号_In    影像报告事件.编号%Type
	);
  --31.获取原型校验的类别集合
  Procedure p_Get_Process_Kind(
    Val Out t_Refcur
	);

  ----32.获取元素或者提纲的名称集合
  --Procedure p_Get_Antetype_Ele_Section(
  --原型ID_In  影像报告原型清单.Id%Type,
  --Val     Out t_Refcur);

  --33.获取指定原型的文档处理
  Procedure p_Get_Doc_Process_Of_Antetype(
	Val           Out t_Refcur,
	原型id_In 影像报告动作.原型id%Type
	);

  --34. 根据字典名称获取相应子项
  Procedure p_Get_Dictitems_By_Title(
	Val           Out t_Refcur,
	名称_In 影像字典清单.名称%Type
	);
  --35.获得所有的预备提纲
  Procedure p_Get_All_Phr_Onlines(
    Val Out t_Refcur
	);
  --36.获取所有词句信息
  Procedure p_Get_All_Fragment(
	Val           Out t_Refcur,
	学科_In Varchar2
	);

  --37.获取词句信息
  Procedure p_Get_Fragment_Filter(
	Val           Out t_Refcur,
	原型id_In 影像报告原型片段.原型ID%Type,
    作者_In   影像报告片段清单.作者%Type,
    学科_In   影像报告片段清单.学科%Type,
    Type_In   Varchar2
	);
  --38.根据原型获取关联的片段标签值
  Procedure p_Get_Label_By_Aid(
	Val           Out t_Refcur,
	原型ID_In 影像报告原型片段.原型ID%Type
	);
  --39.获取所有词句分类
  Procedure p_Get_All_Fragment_Class(
    Val Out t_Refcur
	);
  --40.获取表名对应的最后编辑时间
  Procedure p_Get_Data_Last_Edit_Time(
	Val           Out t_Refcur,
	Table_Name_In Varchar2
	);
  --41.添加文档事件
  Procedure p_Add_Doc_Event(
    ID_In       影像报告事件.ID%Type,
    种类_In     影像报告事件.种类%Type,
    原型ID_In   影像报告事件.原型ID%Type,
    编号_In     影像报告事件.编号%Type,
    名称_In     影像报告事件.名称%Type,
    说明_In     影像报告事件.说明%Type,
    元素IID_In  影像报告事件.元素IID%Type,
    扩展标记_In 影像报告事件.扩展标记%Type);
  --42.修改文档事件
  Procedure p_Update_Doc_Event(
    Id_In       影像报告事件.Id%Type,
    种类_In     影像报告事件.种类%Type,
    名称_In     影像报告事件.名称%Type,
    说明_In     影像报告事件.说明%Type,
    元素IID_In  影像报告事件.元素IID%Type,
    扩展标记_In 影像报告事件.扩展标记%Type);
  --43.删除文档事件
  Procedure p_Delete_Doc_Event(
    Id_In 影像报告事件.Id%Type
	);
  --44.删除所有未被使用的文档事件
  Procedure p_Delete_Unused_Doc_Events(
    Count_Out Out Number
	);
  --45.获取指定原型的文档事件
  Procedure p_Get_Doc_Event_Of_Antetype(
	Val           Out t_Refcur,
	原型ID_In       影像报告事件.原型ID%Type,
	Include_Base_In Number
	);
  --46.修改文档处理编号
  Procedure p_Update_Doc_Process_Seqnum(
    Id_In   影像报告动作.Id%Type,
	序号_In 影像报告动作.序号%Type
	);
  --47.添加文档处理
  Procedure p_Add_Doc_Process(
    Id_In           影像报告动作.Id%Type,
    原型ID_In       影像报告动作.原型ID%Type,
    事件ID_In       影像报告动作.事件ID%Type,
    动作类型_In     影像报告动作.动作类型%Type,
    名称_In         影像报告动作.名称%Type,
    说明_In         影像报告动作.说明%Type,
    可否手工执行_In 影像报告动作.可否手工执行%Type,
    序号_In         影像报告动作.序号%Type,
    内容_In         影像报告动作.内容%Type
	);
  --48.修改文档处理
  Procedure p_Update_Doc_Process(
    Id_In           影像报告动作.Id%Type,
    事件ID_In       影像报告动作.事件ID%Type,
    动作类型_In     影像报告动作.动作类型%Type,
    名称_In         影像报告动作.名称%Type,
    说明_In         影像报告动作.说明%Type,
    可否手工执行_In 影像报告动作.可否手工执行%Type,
    内容_In         影像报告动作.内容%Type
	);
  --49.获取元素或者提纲的名称集合
  Procedure p_Get_Antetype_Ele_Section(
	Val           Out t_Refcur,
	原型ID_In 影像报告原型清单.Id%Type,
	Type_In   Varchar2
	);
  --50.删除文档处理
  Procedure p_Del_Doc_Process(
    Id_In        影像报告动作.ID%Type,
	Del_Event_In Number
	);

  --51.查询元素值域类别的覆盖情况
  Procedure p_Get_Ele_Same_Info(
	Val           Out t_Refcur,
	Id_In    影像报告值域清单.Id%Type,
	Code_In  Varchar2,
	Title_In Varchar2,
	Flag_In  Varchar2
	);
  --52.获得所有的插件信息
  Procedure p_Get_DocPluginList(
    Val Out t_Refcur
	);
  --53.该ID的插件是否被原型使用过
  Procedure p_IsExit_DocPluginByID(
	Val           Out t_Refcur,
	ID_In Varchar2
	);
  --54.新增报告插件信息
  Procedure p_AddDocPlugin(
    ID_In       影像报告插件.ID%Type,
    编码_In     影像报告插件.编码%Type,
    名称_In     影像报告插件.名称%Type,
    说明_In     影像报告插件.说明%Type,
    显示样式_In 影像报告插件.显示样式%Type,
    种类_In     影像报告插件.种类%Type,
    类名_In     影像报告插件.类名%Type,
    库名_In     影像报告插件.库名%Type,
    是否禁用_In 影像报告插件.是否禁用%Type
	);
  --55.修改报告插件信息
  Procedure p_EditDocPlugin(
    ID_In       影像报告插件.ID%Type,
    编码_In     影像报告插件.编码%Type,
    名称_In     影像报告插件.名称%Type,
    说明_In     影像报告插件.说明%Type,
    显示样式_In 影像报告插件.显示样式%Type,
    种类_In     影像报告插件.种类%Type,
    类名_In     影像报告插件.类名%Type,
    库名_In     影像报告插件.库名%Type,
    是否禁用_In 影像报告插件.是否禁用%Type
	);
  --56.删除报告插件信息
  Procedure p_DelDocPlugin(
    ID_In 影像报告插件.ID%Type
	);
  --57.改变插件的可用状态
  Procedure p_IsEnableDocPlugin(
    ID_In 影像报告插件.ID%Type
	);
  --58.通过ID获得对应的插件信息
  Procedure p_GetDocPluginByID(
	Val           Out t_Refcur,
	ID_In 影像报告插件.ID%type
	);
  --59.判断编码和名称是否已存在
  Procedure p_IsExitDocPlugin(
	Val           Out t_Refcur,
	ID_In   影像报告插件.ID%Type,
    编码_In 影像报告插件.编码%Type,
    名称_In 影像报告插件.名称%Type
	);
  --60.通过ID获得对应的专用插件信息
  Procedure p_GetDocSpecPluginByID(
	Val           Out t_Refcur,
	ID_In 影像报告插件.ID%Type
	);
  --61.获得诊疗列表信息
  Procedure p_GetDiagnosisList(
	Val           Out t_Refcur,
	类别_In Varchar2,
    条件_In Varchar2
	);
  --62.获得诊疗类别列表
  Procedure p_GetDiagnosisClass(
    Val Out t_Refcur
	);
  --63.添加影像报告原型应用信息
  Procedure p_AddMedicalAntetype(
    诊疗项目ID_In 影像报告原型应用.诊疗项目ID%Type,
	应用场合_In   影像报告原型应用.应用场合%Type,
	报告原型ID_In 影像报告原型应用.报告原型ID%Type
	);
  --64.删除原型ID对应的病历单据应用信息
  Procedure p_DelMedicalAntetype(
    报告原型ID_In 影像报告原型应用.报告原型ID%Type
	);
  --65.通过原型ID获得对应的病历单据应用信息
  Procedure p_GetMedicalByAID(
	Val           Out t_Refcur,
	报告原型ID_In 影像报告原型应用.报告原型ID%Type
	);
  --66.根据原型ID删除动作信息
  Procedure p_DelDocProcessByAid(
    报告原型ID_In 影像报告原型应用.报告原型ID%Type
	);
  --67.获取ID对应的原型的树形结构
  Procedure p_GetAntetypeTreeByID(
	Val           Out t_Refcur,
	ID_In 影像报告原型清单.ID%Type
	);
  --68.原型是否存在对应的编码或名称
  procedure p_IsExitAntetype(
	Val           Out t_Refcur,
	编码_In 影像报告原型清单.编码%Type,
    名称_In 影像报告原型清单.名称%Type,
    ID_In  影像报告原型清单.ID%Type
	);

  --69  获取影像存储设备
  Procedure p_GetStorageDevice(
		Val           Out t_Refcur);

End b_PACS_RptAntetype;
/

--影像报告原型管理(---实现部分---)***************************************************
CREATE OR REPLACE Package Body b_PACS_RptAntetype Is
  --Create By Hwei;
  --2014/11/25

  --1.获取文件原型类别
  Procedure p_Get_Antetypelistkind(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select 编码, a.名称, a.编码 || '-' || a.名称 As 标题
        From 影像报告种类 A
       Order By 编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetypelistkind;

  --2.根据文档类型获取文档信息
  Procedure p_Get_Antetypelis_By_Kind(
	Val           Out t_Refcur,
	种类_In      影像报告原型清单.种类%Type,
    Stop_Flag    Number,
    Condition_In Varchar2
	) As
  Begin
    Open Val For
      Select ID, 编码, 名称, 标题, 分组, 是否禁用, 说明, Imageindex
        From (Select Distinct 分组 As ID,
                              (Select Min(b.编码)
                                 From 影像报告原型清单 B
                                Where b.分组 = a.分组) As 编码,
                              a.分组 As 名称,
                              a.分组 As 标题,
                              null As 分组,
                              0 As 是否禁用,
                              null As 说明,
                              0 As Imageindex
                From 影像报告原型清单 A
               Where a.种类 = 种类_In
                 And ((a.是否禁用 <> 1 And Stop_Flag = 1) Or (Stop_Flag = 0))
                 And ((a.名称 Like '%' || Condition_In || '%' And
                     Condition_In Is Not Null) Or Condition_In Is Null)
                 And a.分组 Is Not Null
              Union
              Select RawtoHex(ID) ID,
                     a.编码,
                     名称 As 名称,
                     编码 || '-' || 名称 As 标题,
                     分组,
                     a.是否禁用,
                     a.说明,
                     Decode(a.是否禁用, 1, 2, 1) Imageindex
                From 影像报告原型清单 A
               Where a.
               种类 = 种类_In
                 And ((a.是否禁用 <> 1 And Stop_Flag = 1) Or (Stop_Flag = 0))
                 And ((a.名称 Like '%' || Condition_In || '%' And
                     Condition_In Is Not Null) Or Condition_In Is Null)) A
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetypelis_By_Kind;

  --3.添加一个文档原型
  Procedure p_Add_Antetypelist(
    ID_In           影像报告原型清单.ID%Type,
    种类_In         影像报告原型清单.种类%Type,
    编码_In         影像报告原型清单.编码%Type,
    名称_In         影像报告原型清单.名称%Type,
	设备号_In		影像设备目录.设备号%Type,
    说明_In         影像报告原型清单.说明%Type,
    可否重置页面_In 影像报告原型清单.可否重置页面%Type,
    可否重置格式_In 影像报告原型清单.可否重置格式%Type,
	可否书写多份_In 影像报告原型清单.可否书写多份%Type,
    是否禁用_In     影像报告原型清单.是否禁用%Type,
    创建人_In       影像报告原型清单.创建人%Type,
    内容_In         影像报告原型清单.内容%Type,
    控制选项_In     影像报告原型清单.控制选项%Type,
	词句加载时机_In 影像报告原型清单.词句加载时机%Type,
	插件加载时机_In 影像报告原型清单.插件加载时机%Type,
    专用插件_In     影像报告原型清单.专用插件%Type,
    Copy_ID_In      影像报告原型清单.ID%Type,
    Only_Head_In    Varchar2,
    分组_In         影像报告原型清单.分组%Type
	) As
    x_Str Xmltype;
  Begin
    Begin
      If Copy_ID_In Is Null or Copy_ID_In = 0 Then
        x_Str := 内容_In;
      Else
        Select Decode(Only_Head_In,
                      1,
                      Deletexml(a.内容, '/zlxml/document/node()'),
                      a.内容)
          Into x_Str
          From 影像报告原型清单 A
         Where a.id = Copy_ID_In;
      End If;
    Exception
      When Others Then
        x_Str := 内容_In;
    End;
  
    Insert Into 影像报告原型清单
      (ID,
       种类,
       编码,
       名称,
	   设备号,
       说明,
       可否重置页面,
       可否重置格式,
	   可否书写多份,
       是否禁用,
       创建人,
       创建时间,
       内容,
       控制选项,
	   词句加载时机,
	   插件加载时机,
       专用插件,
       分组)
    Values
      (ID_In,
       种类_In,
       编码_In,
       名称_In,
	   设备号_In,
       说明_In,
       可否重置页面_In,
       可否重置格式_In,
	   可否书写多份_In,
       是否禁用_In,
       创建人_In,
       sysdate,
       x_Str,
       控制选项_In,
	   词句加载时机_In,
	   插件加载时机_In,
       专用插件_In,
       分组_In);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Add_Antetypelist;

  --4.修改一个文档原型
  Procedure p_Edit_Antetypelist(
    ID_In           影像报告原型清单.ID%Type,
    种类_In         影像报告原型清单.种类%Type,
    编码_In         影像报告原型清单.编码%Type,
    名称_In         影像报告原型清单.名称%Type,
	设备号_In		影像设备目录.设备号%Type,
    说明_In         影像报告原型清单.说明%Type,
    可否重置页面_In 影像报告原型清单.可否重置页面%Type,
    可否重置格式_In 影像报告原型清单.可否重置格式%Type,
	可否书写多份_In 影像报告原型清单.可否书写多份%Type,
    是否禁用_In     影像报告原型清单.是否禁用%Type,
    修改人_In       影像报告原型清单.修改人%Type,
    内容_In         影像报告原型清单.内容%Type,
    控制选项_In     影像报告原型清单.控制选项%Type,
	词句加载时机_In 影像报告原型清单.词句加载时机%Type,
	插件加载时机_In 影像报告原型清单.插件加载时机%Type,
    专用插件_In     影像报告原型清单.专用插件%Type,
    Copy_ID_In      影像报告原型清单.ID%Type,
    Only_Head_In    Varchar2,
    分组_In         影像报告原型清单.分组%Type
	) As
    x_Str     Xmltype;
    n_Num     Number;
    v_Err_Msg Varchar2(200);
    Err_Item Exception;
  Begin
    Select Count(a.Id)
      Into n_Num
      From 影像报告原型清单 A
     Where (a.编码 = 编码_In Or a.名称 = 名称_In)
       And ID <> ID_In;
  
    If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]存在相同的文档编码或者名称，请重新填写！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    If Copy_ID_In Is Null or Copy_ID_In = 0 Then
      x_Str := 内容_In;
    Else
      Select Decode(Only_Head_In,
                    1,
                    Deletexml(a.内容, '/zlxml/document/node()'),
                    a.内容)
        Into x_Str
        From 影像报告原型清单 A
       Where a.id = Copy_ID_In;
    End If;
  
    Update 影像报告原型清单
       Set 种类         = 种类_In,
           编码         = 编码_In,
           名称         = 名称_In,
		   设备号		= 设备号_In,
           说明         = 说明_In,
           可否重置页面 = 可否重置页面_In,
           可否重置格式 = 可否重置格式_In,
		   可否书写多份 = 可否书写多份_In,
           是否禁用     = NVL(是否禁用_In, 是否禁用),
           修改人       = 修改人_In,
           修改时间     = sysdate,
           内容         = x_Str,
           控制选项     = 控制选项_In,
		   词句加载时机 =词句加载时机_In,
		   插件加载时机 =插件加载时机_In,
           专用插件     = 专用插件_In,
           分组         = 分组_In
     Where ID = ID_In;
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Antetypelist;

  --5.删除一个文件原型
  Procedure p_Del_Antetypelist(
    ID_In 影像报告原型清单.Id%Type
	) As
    n_Num     Number;
    v_Err_Msg Varchar2(200);
    Err_Item Exception;
  Begin
    Select Count(ID) Into n_Num From 影像报告记录 A Where a.原型id = ID_In;
  
    If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]该原型已经被文档使用，不允许删除！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Select Count(原型ID)
      Into n_Num
      From 影像报告原型片段
     Where 影像报告原型片段.原型ID = ID_In;
  
    If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]该文档下存在词句关联，不允许删除！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Select Count(ID)
      Into n_Num
      From 影像报告范文清单
     Where 影像报告范文清单.原型ID = ID_In;
  
    If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]存在以此原型建立的范文信息，不允许删除！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Delete From 影像报告原型清单 C Where c.Id = ID_In;
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Del_Antetypelist;

  --6.根据ID获取文件原型
  Procedure p_Get_Antetypelist_By_Id(
	Val           Out t_Refcur,
	ID_In 影像报告原型清单.Id%Type
	) As
  Begin
    Open Val For
      Select rawtohex(a.ID) ID,
             a.种类,
             a.编码,
             a.名称,
			 a.设备号,
             a.说明,
             a.可否重置页面,
             a.可否重置格式,
			 a.可否书写多份,
             Extractvalue(b.Column_Value, '/root/print_hf_mode') Printhfmode,
             Extractvalue(b.Column_Value, '/root/print_follow_pages') Printfollowpages,
             Nvl(Extractvalue(b.Column_Value, '/root/print_limit'), 0) Printlimit,
             Nvl(a.控制选项.GetClobVal(), '<NULL/>') as 控制选项,
			 a.词句加载时机,
			 a.插件加载时机,
             a.是否禁用,
             Nvl(a.专用插件.GetClobVal(), '<NULL/>') as 专用插件,
             a.创建人,
             a.创建时间,
             a.修改人,
             a.修改时间,
             a.分组
        From 影像报告原型清单 A,
             Table(Xmlsequence(Extract(a.控制选项, '/root'))) B
       Where a.Id = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetypelist_By_Id;

  --7.获取原型XML内容
  Procedure p_Get_Antetypelist_Content(
	Val           Out t_Refcur,
	ID_In 影像报告原型清单.Id%Type
	) As
  Begin
    Open Val For
      Select Nvl(a.内容.GetClobVal(), '<ZLXML/>') As 内容
        From 影像报告原型清单 A
       Where a.Id = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetypelist_Content;

  --8.停用或启用文件原型
  Procedure p_Stop_Antetypelist(
    ID_In 影像报告原型清单.Id%Type
	) As
  Begin
    Update 影像报告原型清单
       Set 是否禁用 = Decode(是否禁用, 1, 0, 0, 1)
     Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Stop_Antetypelist;

  --9.新增文档种类信息
  Procedure p_Add_Doc_Kind(
    编码_In 影像报告种类.编码%Type,
    名称_In 影像报告种类.名称%Type,
    说明_In 影像报告种类.说明%Type
	) As
    n_Num     Number;
    v_Err_Msg Varchar2(200);
    Err_Item Exception;
  Begin
    Select Count(a.编码)
      Into n_Num
      From 影像报告种类 A
     Where a.编码 = 编码_In
        Or a.名称 = 名称_In;
  
    If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]种类的编码或者名称不能相同！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    If 编码_In Is Null Or 编码_In Is Null Then
      v_Err_Msg := '[ZLSOFT]种类的编码或者名称不能为空！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Insert Into 影像报告种类
      (编码, 名称, 说明)
    Values
      (编码_In, 名称_In, 说明_In);
  
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Add_Doc_Kind;

  --10.删除文档种类信息
  Procedure p_Del_Doc_Kind As
  Begin
    Delete From 影像报告种类;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Del_Doc_Kind;

  --11.获取预备提纲信息
  Procedure p_Get_Pre_Outline(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select RawtoHex(ID) ID, 编码, 名称, 说明, 最后编辑时间
        From 影像报告预备提纲 A
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Pre_Outline;

  --12.添加预备提纲信息
  Procedure p_Add_Pre_Outline(
    ID_In   影像报告预备提纲.ID%Type,
    编码_In 影像报告预备提纲.编码%Type,
    名称_In 影像报告预备提纲.名称%Type,
    说明_In 影像报告预备提纲.说明%Type
	) As
    n_Num     Number;
    v_Err_Msg Varchar2(200);
    Err_Item Exception;
  Begin
    Select Count(a.编码)
      Into n_Num
      From 影像报告预备提纲 A
     Where a.编码 = 编码_In
        Or a.名称 = 名称_In;
  
    If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]种类的编码或者名称不能相同！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    If 编码_In Is Null Or 名称_In Is Null Then
      v_Err_Msg := '[ZLSOFT]种类的编码或者名称不能为空！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Insert Into 影像报告预备提纲
      (ID, 编码, 名称, 说明, 最后编辑时间)
    Values
      (ID_In, 编码_In, 名称_In, 说明_In, sysdate);
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Add_Pre_Outline;

  --13.删除预备提纲信息
  Procedure p_Del_Pre_Outline As
  Begin
    Delete From 影像报告预备提纲;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Del_Pre_Outline;

  --14.获取导出的文档原型信息
  Procedure p_Output_Antetypelist(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select '类别' As 类别,
             b.编码 As ID,
             Null As 种类,
             b.名称 As 种类名称,
             b.编码 As 编码,
             b.名称 As 名称,
             b.说明 As 说明,
             Null As 可否重置页面,
             Null As 可否重置格式,
             Null As 是否禁用,
             Null As 创建人,
             Null As 创建时间,
             Null As 修改人,
             Null As 修改时间,
             Null As 内容
        From 影像报告种类 B
      Union All
      Select '原型' 类别,
             RawToHex(a.Id) ID,
             a.种类,
             b.名称 种类名称,
             a.编码,
             a.名称,
             a.说明,
             a.可否重置页面,
             a.可否重置格式,
             a.是否禁用,
             a.创建人,
             a.创建时间,
             a.修改人,
             a.修改时间,
             Null As 内容
        From 影像报告原型清单 A, 影像报告种类 B
       Where a.种类 = b.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Output_Antetypelist;

  --15.添加原型片段
  Procedure p_Add_Antetype_Fragments(
    原型ID_In 影像报告原型片段.原型ID%Type,
	片段ID_In 影像报告原型片段.片段ID%Type) As
  Begin
    Insert Into 影像报告原型片段
      (原型ID, 片段ID)
    Values
      (原型ID_In, 片段ID_In);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Add_Antetype_Fragments;

  --16.删除原型片段
  Procedure p_Del_Antetype_Fragments(
    原型ID_In 影像报告原型片段.原型ID%Type
	) As
  Begin
    Delete From 影像报告原型片段 Where 原型ID = 原型ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Del_Antetype_Fragments;

  --17.获取原型片段
  Procedure p_Get_Antetype_Fragments(
	Val           Out t_Refcur,
	原型ID_In 影像报告原型片段.原型ID%Type
	) As
  Begin
    Open Val For
      Select RawtoHex(片段ID) 片段ID
        From 影像报告原型片段 A
       Where a.原型ID = 原型ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetype_Fragments;

  --18.获取某个原型关联的某个片段分类
  Procedure p_Get_Antetype_f_Byaidfid(
	Val           Out t_Refcur,
	原型ID_In 影像报告原型片段.原型ID%Type,
	片段ID_In 影像报告原型片段.片段ID%Type
	) As
  Begin
    Open Val For
      Select RawtoHex(片段ID) 片段ID
        From 影像报告原型片段 A
       Where a.原型ID = 原型ID_In
         And a.片段ID = 片段ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetype_f_Byaidfid;

  --19.插入文档原型XML内容
  Procedure p_Edit_Antetypelist_Content(
    ID_In     影像报告原型清单.Id%Type,
	内容_In   影像报告原型清单.内容%Type,
	修改人_In 影像报告原型清单.修改人%Type
	) As
  Begin
    Update 影像报告原型清单
       Set 内容 = 内容_In, 修改人 = 修改人_In, 修改时间 = Sysdate
     Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Antetypelist_Content;

  --20.获取所有原型
  Procedure p_Get_All_Antetype_Lists(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select RawtoHex(ID) ID,
             a.编码,
             编码 || '-' || 名称 As 名称,
             分组,
             a.种类,
             a.是否禁用,
             a.说明,
             Decode(a.是否禁用, 1, 2, 1) Imageindex,
             Nvl(a.内容.GetClobVal(), '<ZLXML/>') As 内容
        From 影像报告原型清单 A
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_All_Antetype_Lists;

  --21.获取已经设置了关联的原型片段类别的信息
  Procedure p_Get_Antetype_Fragments_Info(
	Val           Out t_Refcur,
	原型ID_In 影像报告原型片段.原型ID%Type
	) As
  Begin
    Open Val For
      Select RawtoHex(ID) ID,
             a.编码,
             a.名称,
             a.编码 || '-' || a.名称 标题,
             a.说明
        From 影像报告片段清单 A
       Where a.Id In (Select b.片段id
                        From 影像报告原型片段 B
                       Where b.原型id = 原型ID_In)
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetype_Fragments_Info;

  --22.获取选择的类别下面的短语名称
  Procedure p_Get_Selected_Fragments(
	Val           Out t_Refcur,
	原型ID_In Varchar2
	) As
    v_Sql  Varchar2(4000);
    v_Aids Varchar2(4000);
    v_Msg  Varchar2(4000);
    Err Exception;
  Begin
    For Myrow In (Select RawtoHex(a.片段id) ID
                    From 影像报告原型片段 A
                   Where a.原型id = 原型ID_In) Loop
      If v_Aids Is Null Then
        v_Aids := '''' || Myrow.Id || '''';
      Else
        v_Aids := v_Aids || ',''' || Myrow.Id || '''';
      End If;
    End Loop;
  
    If v_Aids Is Null Then
      If Substr(原型ID_In, 0, 1) <> '''' Then
        v_Aids := '''' || 原型ID_In || '''';
      Else
        v_Aids := 原型ID_In;
      End If;
    End If;
  
    v_Sql := 'Select Distinct  RawtoHex(a.id) ID,  RawtoHex(a.上级ID) 上级ID , a.编码, a.编码 || ''-'' || a.名称 标题,Decode(a.节点类型, 0, 0, 1) 节点类型
      From 影像报告片段清单 A
      Start With a.Id In (' || v_Aids || ')
      Connect By Prior a.Id = a.上级ID
      Order By a.编码';
  
    Open Val For v_Sql;
  Exception
    When Err Then
      Raise_Application_Error(-20101, v_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Selected_Fragments;

  --23.获取能复制的原型名称
  Procedure p_Get_Copy_Antetype(
	Val           Out t_Refcur,
	种类_In 影像报告原型清单.种类%Type
	) As
  Begin
    Open Val For
      Select RawtoHex(a.id) ID, a.编码 || '-' || a.名称 标题
        From 影像报告原型清单 A
       Where a.种类 = 种类_In
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Copy_Antetype;

  --24.获取原型的分组信息
  Procedure p_Get_Antetype_Category(
	Val           Out t_Refcur,
	种类_In 影像报告原型清单.种类%Type
	) As
  Begin
    Open Val For
      Select Distinct a.分组 As 分组
        From 影像报告原型清单 A
       Where a.种类 = 种类_In
         and a.分组 Is Not Null;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetype_Category;

  --25.根据原型同步范文提纲
  Procedure p_Synchronous_Sample(
    原型ID_In 影像报告原型清单.Id%Type
	) As
    x_Content Xmltype;
    x_Result  Xmltype;
    Cursor c_Antetype Is
      Select Extractvalue(c.Column_Value, '/section/@iid') Iid,
             Extractvalue(c.Column_Value, '/section/@title') Title,
             c.Column_Value As Content
        From 影像报告原型清单 A,
             Table(Xmlsequence(Extract(a.内容, '/zlxml//section'))) C
       Where a.Id = 原型ID_In;
    n_i               Number;
    n_j               Number;
    n_Count           Number;
    x_Subdocuments    Xmltype;
    x_Docparameters   Xmltype;
    x_Antetypecontent Xmltype;
    v_Textstyleno     Varchar2(10);
    v_Parastyleno     Varchar2(10);
    x_Acontent        Xmltype;
  Begin
    For Mysample In (Select b.id, b.内容
                       From 影像报告范文清单 B
                      Where b.原型id = 原型ID_In) Loop
      x_Content := Mysample.内容;
      n_i       := 1;
      If x_Content Is Null Then
        Select a.内容
          Into x_Result
          From 影像报告原型清单 A
         Where a.Id = 原型ID_In;
      Else
        Begin
          Select Extractvalue(c.Column_Value, '/section/@textstyleno') Textstyleno,
                 Extractvalue(c.Column_Value, '/section/@parastyleno') Parastyleno
            Into v_Textstyleno, v_Parastyleno
            From Table(Xmlsequence(Extract(x_Content, '/zlxml//section'))) C
           Where Rownum = 1;
        Exception
          When Others Then
            v_Textstyleno := '1';
            v_Parastyleno := '1';
        End;
      
        For Myantetype In c_Antetype Loop
          For I In 1 .. 1 Loop
            If n_i <> 1 Or n_Count <> 0 Or n_Count Is Null Then
              Select Count(*)
                Into n_Count
                From Table(Xmlsequence(Extract(x_Content, '/zlxml//section'))) C;
            End If;
            If n_Count < n_i Then
              Select Updatexml(Myantetype.Content,
                               '//section/@textstyleno',
                               v_Textstyleno)
                Into x_Acontent
                From Dual;
              Select Updatexml(x_Acontent,
                               '//section/@parastyleno',
                               v_Parastyleno)
                Into x_Acontent
                From Dual;
              Select Appendchildxml(x_Content,
                                    '/zlxml/document',
                                    x_Acontent)
                Into x_Content
                From Dual;
              Exit;
            End If;
            n_j := 1;
            For Mysample In (Select Extractvalue(c.Column_Value,
                                                 '/section/@iid') Iid,
                                    Extractvalue(c.Column_Value,
                                                 '/section/@title') Title
                               From Table(Xmlsequence(Extract(x_Content,
                                                              '/zlxml//section'))) C) Loop
              If n_i = n_j Then
                If Myantetype.Iid <> Mysample.Iid Then
                  Select Updatexml(Myantetype.Content,
                                   '//section/@textstyleno',
                                   v_Textstyleno)
                    Into x_Acontent
                    From Dual;
                  Select Updatexml(x_Acontent,
                                   '//section/@parastyleno',
                                   v_Parastyleno)
                    Into x_Acontent
                    From Dual;
                  Select Deletexml(x_Content,
                                   '//section[@iid="' || Myantetype.Iid || '"]')
                    Into x_Content
                    From Dual;
                  Select Insertxmlbefore(x_Content,
                                         '//section[@iid="' || Mysample.Iid || '"]',
                                         x_Acontent)
                    Into x_Content
                    From Dual;
                  n_j := n_j + 1;
                  Exit;
                Else
                  n_j := n_j + 1;
                  Exit;
                End If;
              End If;
              n_j := n_j + 1;
            End Loop;
            n_i := n_i + 1;
          End Loop;
        End Loop;
        x_Result := x_Content;
        For Mysample2 In (Select Iid
                            From (Select Extractvalue(c.Column_Value,
                                                      '/section/@iid') Iid
                                    From Table(Xmlsequence(Extract(x_Content,
                                                                   '/zlxml//section'))) C) C
                           Where c.Iid Not In
                                 (Select Extractvalue(c.Column_Value,
                                                      '/section/@iid') Iid
                                    From 影像报告原型清单 A,
                                         Table(Xmlsequence(Extract(a.内容,
                                                                   '/zlxml//section'))) C
                                   Where a.Id = 原型ID_In)) Loop
          Select Deletexml(x_Result,
                           '//section[@iid="' || Mysample2.Iid || '"]')
            Into x_Result
            From Dual;
        End Loop;
      End If;
    
      Update 影像报告范文清单 X
         Set x.内容 = x_Result
       Where x.Id = Mysample.Id;
    End Loop;
  
    Select a.内容
      Into x_Antetypecontent
      From 影像报告原型清单 A
     Where a.Id = 原型ID_In;
    Select Extract(x_Antetypecontent, 'zlxml/subdocuments')
      Into x_Subdocuments
      From Dual;
    Select Extract(x_Antetypecontent, 'zlxml/docparameters')
      Into x_Docparameters
      From Dual;
    Update 影像报告范文清单
       Set 内容 = Updatexml(内容, '/zlxml/subdocuments', x_Subdocuments)
     Where 原型ID = 原型ID_In;
    Update 影像报告范文清单
       Set 内容 = Updatexml(内容, '/zlxml/docparameters', x_Docparameters)
     Where 原型ID = 原型ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Synchronous_Sample;

  --26.获取导出的原型列表
  Procedure p_Get_Out_Antetypelist(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select ID,
             编码,
             标题,
             Parentid,
             种类,
             是否禁用,
             说明,
             Imageindex,
             名称
        From (Select a.编码 As ID,
                     a.编码 As 编码,
                     a.名称 As 标题,
                     '' As Parentid,
                     '-1' As 种类,
                     0 As 是否禁用,
                     a.说明 As 说明,
                     4 As Imageindex,
                     a.名称 名称
                From 影像报告种类 A
              Union
              Select Distinct a.种类 || '-' || a.分组 As ID,
                              (Select Min(编码)
                                 From 影像报告原型清单 B
                                Where b.分组 = a.分组) As 编码,
                              Max(a.分组) As 名称,
                              a.种类 As Parentid,
                              '0' As 种类,
                              0 As 是否禁用,
                              '' As 说明,
                              4 As Imageindex,
                              a.分组
                From 影像报告原型清单 A
               Where a.分组 Is Not Null
               Group By a.种类, a.分组
              Union
              Select RawTohex(ID),
                     a.编码,
                     编码 || '-' || 名称 As 标题,
                     Decode(a.分组, Null, a.种类, a.种类 || '-' || a.分组) Parentid,
                     a.种类 As 种类,
                     a.是否禁用,
                     a.说明,
                     Decode(a.是否禁用, 1, 1, 0, 2),
                     a.名称
                From 影像报告原型清单 A) A
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Out_Antetypelist;

  --27.通过编码获取原型种类信息
  Procedure p_Get_Antetype_Kind_By_Code(
	Val           Out t_Refcur,
	编码_In 影像报告种类.编码%Type
	) As
  Begin
    Open Val For
      Select a.编码, a.名称, a.说明
        From 影像报告种类 A
       Where a.编码 = 编码_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetype_Kind_By_Code;
  --28.获取事件信息，不包含固定事件
  Procedure p_Get_Doc_Event(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select RawtoHex(a.id) ID,
             a.种类,
             a.原型id,
             a.编号,
             a.名称,
             a.说明,
             a.元素iid,
             a.扩展标记
        From 影像报告事件 A
       Where a.种类 <> 1;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Doc_Event;

  --29.获取关于原型导出的重复信息
  Procedure p_Get_Antetypelist_Same_Info(
	Val           Out t_Refcur,
	Tablename_In Varchar2,
	ID_In        影像报告原型清单.Id%Type,
	编码_In      Varchar2,
	名称_In      Varchar2
	) As
    n_Num    Number;
    v_Result Varchar2(100);
    v_Sql    Varchar2(4000);
  Begin
    If ID_In Is Not Null Then
      v_Sql := 'select count(*) from ' || Tablename_In || ' where id=' ||
               ID_In;
      Execute Immediate v_Sql
        Into n_Num;
      If n_Num > 0 Then
        v_Result := 'ID重复';
      End If;
    End If;
    If 编码_In Is Not Null Then
      v_Sql := 'select count(*) from ' || Tablename_In || ' where 编码=''' ||
               编码_In || '''';
      Execute Immediate v_Sql
        Into n_Num;
      If n_Num > 0 Then
        If v_Result Is Not Null Then
          v_Result := v_Result || ',编码重复';
        Else
          v_Result := '编码重复';
        End If;
      End If;
    End If;
    If 名称_In Is Not Null Then
      v_Sql := 'select count(*) from ' || Tablename_In || ' where 名称=''' ||
               名称_In || '''';
      Execute Immediate v_Sql
        Into n_Num;
      If n_Num > 0 Then
        If v_Result Is Not Null Then
          v_Result := v_Result || ',名称重复';
        Else
          v_Result := '名称重复';
        End If;
      End If;
    End If;
    Open Val For
      Select v_Result Result From Dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetypelist_Same_Info;

  --30.获取事件重复的信息
  Procedure p_Event_Same_Info(
	Val           Out t_Refcur,
	ID_In      影像报告事件.Id%Type,
    原型ID_In  影像报告事件.原型ID%Type,
    元素IID_In 影像报告事件.元素IID%Type,
    种类_In    影像报告事件.种类%Type,
    名称_In    影像报告事件.名称%Type,
    编号_In    影像报告事件.编号%Type
	) As
    v_Same_Antetype Varchar2(50);
    n_Same_Id       Number;
    n_Same_Title    Number;
    n_Same_Seqnum   Number;
    n_Maxnum        Number;
  Begin
    Select Count(*)
      Into n_Same_Title
      From 影像报告事件 A
     Where a.原型ID = 原型ID_In
       And a.种类 = 种类_In
       And a.名称 = 名称_In;
    Select Count(*)
      Into n_Same_Seqnum
      From 影像报告事件 A
     Where a.原型ID = 原型ID_In
       And a.种类 = 种类_In
       And a.编号 = 编号_In;
    Begin
      Select a.Id
        Into v_Same_Antetype
        From 影像报告事件 A
       Where a.原型ID = 原型ID_In
         And a.元素IID = 元素IID_In;
    Exception
      When Others Then
        v_Same_Antetype := '';
    End;
  
    Select Count(*) Into n_Same_Id From 影像报告事件 A Where a.Id = ID_In;
    Select Max(a.编号) Into n_Maxnum From 影像报告事件 A;
  
    Open Val For
      Select v_Same_Antetype As Sameaid,
             n_Same_Id       As Sameid,
             n_Same_Title    As Sametitle,
             n_Same_Seqnum   As Sameseqnum,
             n_Maxnum        As Maxnum
        From Dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Event_Same_Info;

  --31.获取原型校验的类别集合
  Procedure p_Get_Process_Kind(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select Distinct 动作类型
        From (Select Extractvalue(c.Column_Value, '/step/kind') As 动作类型
                From 影像报告动作 A,
                     Table(Xmlsequence(Extract(a.内容, '/root/step'))) C) B
       Where b.动作类型 Is Not Null;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Process_Kind;


  --33.获取指定原型的文档处理
  Procedure p_Get_Doc_Process_Of_Antetype(
	Val           Out t_Refcur,
	原型ID_In 影像报告动作.原型id%Type
	) As
  Begin
    Open Val For
      Select RawtoHex(p.id) ID,
             p.名称,
             p.动作类型,
             p.序号,
             p.说明,
             p.可否手工执行,
             To_Clob(Nvl(p.内容.GetClobVal(), '<NULL/>')) As 内容, --Nvl(p.内容,'<NULL/>') As 内容,
             RawtoHex(p.事件ID) 事件ID,
             0 Is_Event
        From 影像报告动作 P
       Where p.原型ID = 原型ID_In
      Union All
      Select RawtoHex(e.id) ID,
             e.名称,
             e.种类,
             e.编号,
             e.说明,
             Null,
             To_CLOB('<Null/>') As 内容, --(Null,'<NULL/>') As 内容,
             Null,
             1
        From 影像报告事件 E
       Where e.Id In (Select RawtoHex(事件ID) 事件ID
                        From 影像报告动作
                       Where 原型ID = 原型ID_In)
       Order By Is_Event, 动作类型, 序号;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Doc_Process_Of_Antetype;

  --34. 根据字典名称获取相应子项
  Procedure p_Get_Dictitems_By_Title(
	Val           Out t_Refcur,
	名称_In 影像字典清单.名称%Type
	) As
  Begin
    Open Val For
      Select a.编号, a.名称, Rawtohex(a.字典id) As 字典ID
        From 影像字典内容 A
       Where a.字典id In (Select id From 影像字典清单 b Where b.名称 = 名称_In);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Dictitems_By_Title;

  --35.获得所有的预备提纲
  Procedure p_Get_All_Phr_Onlines(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select Rawtohex(ID) ID, a.编码, a.名称
        From 影像报告预备提纲 a
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_All_Phr_Onlines;

  --36.获取所有词句信息
  Procedure p_Get_All_Fragment(
	Val           Out t_Refcur,
	学科_In Varchar2
	) As
  Begin
    If 学科_In <> '' Then
      Open Val For
        Select RawToHex(a.id) ID,
               RawToHex(a.上级id) 上级id,
               a.编码,
               a.名称,
               a.说明,
               a.节点类型,
               Nvl(a.组成.GetClobVal(), '<NULL/>') As 组成,
               a.学科,
               a.标签,
               a.是否私有,
               a.作者
          From 影像报告片段清单 A
         Where (a.学科 In
               (Select /*+rule*/
                  Column_Value As Lable
                   From Table(b_PACS_RptPublic.f_Str2list(学科_In, ','))
                 Intersect
                 Select /*+rule*/
                  Column_Value As Lable
                   From Table(b_PACS_RptPublic.f_Str2list(a.学科, ','))) And
               a.节点类型 <> 0)
            Or a.节点类型 = 0
            Or a.学科 Is Null
         Order By a.编码, a.上级id;
    Else
      Open Val For
        Select RawToHex(a.id) ID,
               RawToHex(a.上级id) 上级id,
               a.编码,
               a.名称,
               a.说明,
               a.节点类型,
               Nvl(a.组成.GetClobVal(), '<NULL/>') As 组成,
               a.学科,
               a.标签,
               a.是否私有,
               a.作者
          From 影像报告片段清单 A
         Order By a.上级id, a.节点类型, a.编码, a.名称;
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_All_Fragment;

  --37. 获取词句信息
  Procedure p_Get_Fragment_Filter(
	Val           Out t_Refcur,
	原型id_In 影像报告原型片段.原型ID%Type,
    作者_In   影像报告片段清单.作者%Type,
    学科_In   影像报告片段清单.学科%Type,
    Type_In   Varchar2
	) As
  Begin
    If Type_In = '1' Then
      Open Val For
        Select Rawtohex(b.Id) ID,
               Rawtohex(b.上级id) 上级id,
               b.编码,
               b.名称,
               b.说明,
               b.节点类型,
               Nvl(b.组成.GetClobVal(), '<NULL/>') As 组成,
               b.学科,
               b.标签,
               b.是否私有,
               b.作者,
               b.最后编辑时间
          From 影像报告原型片段 A, 影像报告片段清单 B
         Where a.片段id = b.id
           And a.原型id = 原型id_In;
    Else
      Open Val For
        Select /*+ rule*/
         Rawtohex(b.Id) ID,
         Rawtohex(b.上级id) 上级id,
         b.编码,
         b.名称,
         b.说明,
         b.节点类型,
         Nvl(b.组成.GetClobVal(), '<NULL/>') As 组成,
         b.学科,
         b.标签,
         b.是否私有,
         b.作者,
         b.最后编辑时间
          From 影像报告片段清单 B
         Where b.上级id = 原型id_In
           And (b.是否私有 = 0 Or (b.是否私有 = 1 And b.作者 = 作者_In))
           And (b.学科 Is Null Or
               (b.学科 Is Not Null And
               b_PACS_RptPublic.f_If_Intersect(b.学科, 学科_In) > 0));
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Fragment_Filter;

  --38.根据原型获取关联的片段标签值
  Procedure p_Get_Label_By_Aid(
	Val           Out t_Refcur,
	原型ID_In 影像报告原型片段.原型ID%Type
	) As
  Begin
    Open Val For
      Select Distinct b.标签
        From 影像报告片段清单 B
       Start With b.上级id In (Select a.片段id
                               From 影像报告原型片段 A
                              Where a.原型id = 原型ID_In)
      Connect By Prior b.Id = b.上级id;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Label_By_Aid;

  --39.获取所有词句分类
  Procedure p_Get_All_Fragment_Class(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select Rawtohex(a.Id) ID,
             Rawtohex(a.上级id) 上级id,
             a.编码,
             a.名称,
             a.说明,
             a.节点类型
        From 影像报告片段清单 A
       Where a.节点类型 = 0
       Start With 上级id Is Null
      Connect By Prior id = 上级id
       Order By 编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_All_Fragment_Class;

  --40.获取表名对应的最后编辑时间
  Procedure p_Get_Data_Last_Edit_Time(
	Val           Out t_Refcur,
	Table_Name_In Varchar2
	) As
    v_sql Varchar2(4000);
  Begin
    v_sql := 'select max(最后编辑时间) maxvalue from ' || Table_Name_In;
    Open val For v_sql;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Data_Last_Edit_Time;

  --41.添加文档事件
  Procedure p_Add_Doc_Event(
    ID_In       影像报告事件.ID%Type,
    种类_In     影像报告事件.种类%Type,
    原型ID_In   影像报告事件.原型ID%Type,
    编号_In     影像报告事件.编号%Type,
    名称_In     影像报告事件.名称%Type,
    说明_In     影像报告事件.说明%Type,
    元素IID_In  影像报告事件.元素IID%Type,
    扩展标记_In 影像报告事件.扩展标记%Type
	) As
    n_Seq_Num  影像报告事件.编号%Type;
    n_Is_Exist Number(1) := 0;
    v_Err_Msg  Varchar2(100);
    Err_Item Exception;
  Begin
    Select Count(*)
      Into n_Is_Exist
      From 影像报告事件
     Where 原型ID = 原型ID_In
       And 种类 = 种类_In
       And 名称 = 名称_In;
  
    If n_Is_Exist > 0 Then
      v_Err_Msg := '[ZLSOFT]原型上已存在相同命名的事件[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    If (编号_In Is Null Or 编号_In = 0) Then
      Select Nvl(Max(编号), 0) + 1 Into n_Seq_Num From 影像报告事件;
    Else
      Select Count(*)
        Into n_Is_Exist
        From 影像报告事件
       Where 原型ID = 原型ID_In
         And 种类 = 种类_In
         And 编号 = 编号_In;
      If n_Is_Exist > 0 Then
        v_Err_Msg := '[ZLSOFT]原型上已存在相同编号的事件[ZLSOFT]';
        Raise Err_Item;
      End If;
      n_Seq_Num := 编号_In;
    End If;
  
    Insert Into 影像报告事件
      (ID, 种类, 原型ID, 编号, 名称, 说明, 元素IID, 扩展标记)
    Values
      (ID_In,
       种类_In,
       原型ID_In,
       n_Seq_Num,
       名称_In,
       说明_In,
       元素IID_In,
       扩展标记_In);
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Add_Doc_Event;

  --42.修改文档事件
  Procedure p_Update_Doc_Event(
    Id_In       影像报告事件.Id%Type,
    种类_In     影像报告事件.种类%Type,
    名称_In     影像报告事件.名称%Type,
    说明_In     影像报告事件.说明%Type,
    元素IID_In  影像报告事件.元素IID%Type,
    扩展标记_In 影像报告事件.扩展标记%Type
	) As
    r_Aid      影像报告事件.原型ID%Type;
    n_Is_Exist Number(1) := 0;
    v_Err_Msg  Varchar2(100);
    Err_Item Exception;
  Begin
    Select 原型ID Into r_Aid From 影像报告事件 Where ID = Id_In;
  
    Select Count(*)
      Into n_Is_Exist
      From 影像报告事件
     Where 原型ID = r_Aid
       And 种类 = 种类_In
       And 名称 = 名称_In
       And ID <> Id_In;
  
    If n_Is_Exist > 0 Then
      v_Err_Msg := '[ZLSOFT]原型上存在相同命名的事件[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Update 影像报告事件
       Set 种类     = 种类_In,
           名称     = 名称_In,
           说明     = 说明_In,
           元素IID  = 元素IID_In,
           扩展标记 = 扩展标记_In
     Where ID = Id_In;
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Update_Doc_Event;

  --43.删除文档事件
  Procedure p_Delete_Doc_Event(
    Id_In 影像报告事件.Id%Type
	) As
    n_Kind     影像报告事件.种类%Type;
    n_Is_Exist Number(1) := 0;
    v_Err_Msg  Varchar2(100);
    Err_Item Exception;
  Begin
    Select 种类 Into n_Kind From 影像报告事件 Where ID = Id_In;
  
    If n_Kind = 1 Then
      v_Err_Msg := '[ZLSOFT]不允许删除固定事件[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Select Count(*) Into n_Is_Exist From 影像报告动作 Where 事件ID = Id_In;
  
    If n_Is_Exist > 0 Then
      v_Err_Msg := '[ZLSOFT]事件已经被使用,不能被删除！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Delete From 影像报告事件 Where ID = Id_In;
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Delete_Doc_Event;

  --44.删除所有未被使用的文档事件
  Procedure p_Delete_Unused_Doc_Events(
    Count_Out Out Number
	) As
  Begin
    Delete From 影像报告事件
     Where 种类 <> 1
       And ID Not In
           (Select 事件ID From 影像报告动作 Where 事件ID Is Not Null);
    Count_Out := Sql%RowCount;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Delete_Unused_Doc_Events;

  --45.获取指定原型的文档事件
  Procedure p_Get_Doc_Event_Of_Antetype(
	Val           Out t_Refcur,
	原型ID_In       影像报告事件.原型ID%Type,
	Include_Base_In Number
	) As
  Begin
    If Include_Base_In = 1 Then
      Open Val For
        Select Rawtohex(t.Id) ID,
               t.种类,
               t.名称,
               t.说明,
               t.元素iid,
               t.扩展标记,
               Nvl(p.Used_Count, 0) Used_Count
          From 影像报告事件 T,
               (Select Count(*) Used_Count, Max(事件ID) 事件ID
                  From 影像报告动作
                 Where 事件ID Is Not Null
                 Group By 事件ID) P
         Where (t.种类 = 1 Or t.原型id = 原型ID_In)
           And t.Id = p.事件ID(+)
         Order By t.编号;
    Else
      Open Val For
        Select Rawtohex(t.Id) ID,
               t.种类,
               t.名称,
               t.说明,
               t.元素iid,
               t.扩展标记,
               Nvl(p.Used_Count, 0) Used_Count
          From 影像报告事件 T,
               (Select Count(*) Used_Count, Max(事件ID) 事件ID
                  From 影像报告动作
                 Where 事件ID Is Not Null
                 Group By 事件ID) P
         Where t.原型id = 原型ID_In
           And t.种类 <> 1
           And t.Id = p.事件ID(+)
         Order By t.编号;
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Doc_Event_Of_Antetype;

  --46.修改文档处理编号
  Procedure p_Update_Doc_Process_Seqnum(
    Id_In   影像报告动作.Id%Type,
	序号_In 影像报告动作.序号%Type) As
  Begin
    Update 影像报告动作 Set 序号 = 序号_In Where ID = Id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Update_Doc_Process_Seqnum;

  --47.添加文档处理
  Procedure p_Add_Doc_Process(
    Id_In           影像报告动作.Id%Type,
    原型ID_In       影像报告动作.原型ID%Type,
    事件ID_In       影像报告动作.事件ID%Type,
    动作类型_In     影像报告动作.动作类型%Type,
    名称_In         影像报告动作.名称%Type,
    说明_In         影像报告动作.说明%Type,
    可否手工执行_In 影像报告动作.可否手工执行%Type,
    序号_In         影像报告动作.序号%Type,
    内容_In         影像报告动作.内容%Type
	) As
    n_Seq_Num  影像报告动作.序号%Type;
    n_Is_Exist Number(1) := 0;
    v_Err_Msg  Varchar2(100);
    Err_Item Exception;
  Begin
    Select Count(*)
      Into n_Is_Exist
      From 影像报告动作
     Where 原型ID = 原型ID_In
       And 名称 = 名称_In;
    If (序号_In Is Null Or 序号_In = 0) Then
      If (事件ID_In Is Null) Then
        Select Nvl(Max(序号), 0) + 1
          Into n_Seq_Num
          From 影像报告动作
         Where 原型ID = 原型ID_In
           And 事件ID Is Null;
      Else
        Select Nvl(Max(序号), 0) + 1
          Into n_Seq_Num
          From 影像报告动作
         Where 原型ID = 原型ID_In
           And 事件ID = 事件ID_In;
      End If;
    Else
      n_Seq_Num := 序号_In;
    End If;
    If n_Is_Exist > 0 Then
      v_Err_Msg := '[ZLSOFT]原型上存在相同命名的动作[ZLSOFT]';
      Raise Err_Item;
    End If;
    Insert Into 影像报告动作
      (ID, 原型ID, 事件ID, 动作类型, 名称, 说明, 可否手工执行, 序号, 内容)
    Values
      (Id_In,
       原型ID_In,
       事件ID_In,
       动作类型_In,
       名称_In,
       说明_In,
       可否手工执行_In,
       n_Seq_Num,
       内容_In);
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Add_Doc_Process;

  --48.修改文档处理
  Procedure p_Update_Doc_Process(
    Id_In           影像报告动作.Id%Type,
    事件ID_In       影像报告动作.事件ID%Type,
    动作类型_In     影像报告动作.动作类型%Type,
    名称_In         影像报告动作.名称%Type,
    说明_In         影像报告动作.说明%Type,
    可否手工执行_In 影像报告动作.可否手工执行%Type,
    内容_In         影像报告动作.内容%Type
	) As
    r_Aid          影像报告事件.原型ID%Type;
    r_Old_Event_Id 影像报告动作.事件ID%Type;
    n_Seq_Num      影像报告事件.编号%Type;
    n_Is_Exist     Number(1) := 0;
    v_Err_Msg      Varchar2(100);
    Err_Item Exception;
  Begin
    Select 原型ID Into r_Aid From 影像报告动作 Where ID = Id_In;
    If (事件ID_In Is Not Null) Then
      Select Count(*)
        Into n_Is_Exist
        From 影像报告事件
       Where (原型ID Is Null Or 原型ID = r_Aid)
         And ID = 事件ID_In;
    
      If n_Is_Exist = 0 Then
        v_Err_Msg := '[ZLSOFT]关联的事件不存在[ZLSOFT]';
        Raise Err_Item;
      End If;
    
    End If;
  
    Select Count(*)
      Into n_Is_Exist
      From 影像报告动作
     Where 原型ID = r_Aid
       And 名称 = 名称_In
       And ID <> Id_In;
  
    If n_Is_Exist > 0 Then
      v_Err_Msg := '[ZLSOFT]原型上存在相同命名的动作[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    If (r_Old_Event_Id <> 事件ID_In Or
       (事件ID_In Is Null And r_Old_Event_Id Is Not Null)) Then
      If (事件ID_In Is Null) Then
        Select Nvl(Max(序号), 0) + 1
          Into n_Seq_Num
          From 影像报告动作
         Where 原型ID = r_Aid
           And 事件ID Is Null;
      Else
        Select Nvl(Max(序号), 0) + 1
          Into n_Seq_Num
          From 影像报告动作
         Where 原型ID = r_Aid
           And 事件ID = 事件ID_In;
      End If;
    Else
      n_Seq_Num := 0;
    End If;
  
    If n_Seq_Num > 0 Then
      Update 影像报告动作
         Set 事件id       = 事件ID_In,
             动作类型     = 动作类型_In,
             名称         = 名称_In,
             说明         = 说明_In,
             可否手工执行 = 可否手工执行_In,
             内容         = 内容_In,
             序号         = n_Seq_Num
       Where ID = Id_In;
    Else
      Update 影像报告动作
         Set 事件id       = 事件ID_In,
             动作类型     = 动作类型_In,
             名称         = 名称_In,
             说明         = 说明_In,
             可否手工执行 = 可否手工执行_In,
             内容         = 内容_In
       Where ID = Id_In;
    End If;
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Update_Doc_Process;

  --49.获取元素或者提纲的名称集合
  Procedure p_Get_Antetype_Ele_Section(
	Val           Out t_Refcur,
	原型ID_In 影像报告原型清单.Id%Type,
	Type_In   Varchar2
	) As
    c_Content Clob;
  Begin
    /*Select To_Clob(a.内容)*/
    Select a.内容.getclobval()
      Into c_Content
      From 影像报告原型清单 A
     Where a.Id = 原型ID_In;
  
    If Type_In = '1' Then
      Open Val For
        Select Distinct Name
          From (Select Extractvalue(c.Column_Value, '/*/@title') As Name
                  From Table(Xmlsequence(Extract(Xmltype(c_Content),
                                                 '/zlxml/document//element[@sid and @title]|/zlxml/document//e_list[@sid and @title]|/zlxml/document//e_enum[@sid and @title]|/zlxml/document//e_etree[@sid and @title]|/zlxml/document//e_utree[@sid and @title]'))) C) A
         Where a.Name Is Not Null;
    Else
      Open Val For
        Select Distinct Name
          From (Select Extractvalue(c.Column_Value, '/section/@title') As Name
                  From Table(Xmlsequence(Extract(Xmltype(c_Content),
                                                 '//section'))) C) A
         Where a.Name Is Not Null;
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetype_Ele_Section;

  --50.删除文档处理
  Procedure p_Del_Doc_Process(Id_In        影像报告动作.ID%Type,
                              Del_Event_In Number) As
    r_Event_Id   影像报告动作.事件ID%Type := Null;
    n_Event_Kind 影像报告事件.种类%Type;
    n_Is_Exist   Number(1) := 0;
  Begin
    If Del_Event_In = 1 Then
      Select Max(e.Id), Max(e.种类)
        Into r_Event_Id, n_Event_Kind
        From 影像报告动作 P, 影像报告事件 E
       Where p.Id = Id_In
         And p.事件id = e.Id;
    End If;
  
    Delete From 影像报告动作 Where ID = Id_In;
  
    If Del_Event_In = 1 Then
      If (r_Event_Id Is Not Null And n_Event_Kind <> 1) Then
        Select Count(*)
          Into n_Is_Exist
          From 影像报告动作
         Where 事件id = r_Event_Id;
        If n_Is_Exist = 0 Then
          Delete From 影像报告事件
           Where ID = r_Event_Id
             And 种类 <> 1;
        End If;
      End If;
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Del_Doc_Process;

  --51.查询元素值域类别的覆盖情况
  Procedure p_Get_Ele_Same_Info(
	Val           Out t_Refcur,
	Id_In    影像报告值域清单.Id%Type,
	Code_In  Varchar2,
	Title_In Varchar2,
	Flag_In  Varchar2
	) As
    v_Result  Varchar2(50);
    v_Id      Varchar2(50);
    v_Code_Id Varchar2(50);
    n_Num     Number;
  Begin
    If Flag_In = 1 Then
      Select Count(ID)
        Into n_Num
        From 影像报告元素分类 A
       Where a.Id = Id_In;
    
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Id
          From 影像报告元素分类 A
         Where a.Id = Id_In;
        If v_Id Is Not Null Then
          v_Result := 'ID重复';
        End If;
      End If;
    
      Select Count(ID)
        Into n_Num
        From 影像报告元素分类 A
       Where a.编码 = Code_In;
    
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Code_Id
          From 影像报告元素分类 A
         Where a.编码 = Code_In;
        If v_Code_Id Is Not Null Then
          If v_Result Is Not Null Then
            v_Result := v_Result || ',编码重复';
          Else
            v_Result := '编码重复';
          End If;
        End If;
      End If;
    
      Select Count(ID)
        Into n_Num
        From 影像报告元素分类 A
       Where a.名称 = Title_In;
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Id
          From 影像报告元素分类 A
         Where a.名称 = Title_In;
        If v_Id Is Not Null Then
          If v_Result Is Not Null Then
            v_Result := v_Result || ',名称重复';
          Else
            v_Result := '名称重复';
          End If;
        End If;
      End If;
    
    End If;
  
    If Flag_In = 2 Then
      Select Count(ID)
        Into n_Num
        From 影像报告元素清单 A
       Where a.Id = Id_In;
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Id
          From 影像报告元素清单 A
         Where a.Id = Id_In;
        If v_Id Is Not Null Then
          v_Result := 'ID重复';
        End If;
      End If;
    
      Select Count(ID)
        Into n_Num
        From 影像报告元素清单 A
       Where a.编码 = Code_In;
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Code_Id
          From 影像报告元素清单 A
         Where a.编码 = Code_In;
        If v_Code_Id Is Not Null Then
          If v_Result Is Not Null Then
            v_Result := v_Result || ',编码重复';
          Else
            v_Result := '编码重复';
          End If;
        End If;
      End If;
    
      Select Count(ID)
        Into n_Num
        From 影像报告元素清单 A
       Where a.名称 = Title_In;
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Id
          From 影像报告元素清单 A
         Where a.名称 = Title_In;
        If v_Id Is Not Null Then
          If v_Result Is Not Null Then
            v_Result := v_Result || ',名称重复';
          Else
            v_Result := '名称重复';
          End If;
        End If;
      End If;
    
    End If;
  
    If Flag_In = 3 Then
      Select Count(ID)
        Into n_Num
        From 影像报告值域清单 A
       Where a.Id = Id_In;
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Id
          From 影像报告值域清单 A
         Where a.Id = Id_In;
        If v_Id Is Not Null Then
          v_Result := 'ID重复';
        End If;
      End If;
    
      Select Count(ID)
        Into n_Num
        From 影像报告值域清单 A
       Where a.编码 = Code_In;
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Code_Id
          From 影像报告值域清单 A
         Where a.编码 = Code_In;
        If v_Code_Id Is Not Null Then
          If v_Result Is Not Null Then
            v_Result := v_Result || ',编码重复';
          Else
            v_Result := '编码重复';
          End If;
        End If;
      End If;
    
      Select Count(ID)
        Into n_Num
        From 影像报告值域清单 A
       Where a.名称 = Title_In;
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Id
          From 影像报告值域清单 A
         Where a.名称 = Title_In;
        If v_Id Is Not Null Then
          If v_Result Is Not Null Then
            v_Result := v_Result || ',名称重复';
          Else
            v_Result := '名称重复';
          End If;
        End If;
      End If;
    
    End If;
  
    Open Val For
      Select v_Result As Result, v_Id As ID, v_Code_Id As Codesameid
        From Dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Ele_Same_Info;

  --52.获得所有的插件信息
  Procedure p_Get_DocPluginList(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select Rawtohex(Id) ID,
             编码,
             名称,
             说明,
             显示样式,
             种类,
             Decode(显示样式, '1', '嵌入式', '弹出式') 显示样式II,
             Decode(种类, '1', '专用插件', '共享插件') 种类II,
             类名,
             库名,
             是否禁用,
             Decode(是否禁用, '1', '停用', '启用') IsEnable
        From 影像报告插件;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_DocPluginList;

  --53.该ID的插件是否被原型使用过
  Procedure p_IsExit_DocPluginByID(
    Val           Out t_Refcur,
	ID_In Varchar2
	) As
    CURSOR C_EVENT Is
      Select t.专用插件.getclobval() 专用插件 From 影像报告原型清单 t;
    anum Int := 0;
    sult Varchar2(6666);
  Begin
    For temp In C_EVENT Loop
      If instr(temp.专用插件, ID_In) > 0 Then
        anum := anum + 1;
      End If;
    End Loop;
    Open Val For
      Select anum From dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_IsExit_DocPluginByID;

  --54.新增报告插件信息
  Procedure p_AddDocPlugin(
    ID_In       影像报告插件.ID%Type,
    编码_In     影像报告插件.编码%Type,
    名称_In     影像报告插件.名称%Type,
    说明_In     影像报告插件.说明%Type,
    显示样式_In 影像报告插件.显示样式%Type,
    种类_In     影像报告插件.种类%Type,
    类名_In     影像报告插件.类名%Type,
    库名_In     影像报告插件.库名%Type,
    是否禁用_In 影像报告插件.是否禁用%Type
	) As
  Begin
    Insert Into 影像报告插件
      (ID, 编码, 名称, 说明, 显示样式, 种类, 类名, 库名, 是否禁用)
    Values
      (ID_In,
       编码_In,
       名称_In,
       说明_In,
       显示样式_In,
       种类_In,
       类名_In,
       库名_In,
       是否禁用_In);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_AddDocPlugin;

  --55.修改报告插件信息
  Procedure p_EditDocPlugin(
    ID_In       影像报告插件.ID%Type,
    编码_In     影像报告插件.编码%Type,
    名称_In     影像报告插件.名称%Type,
    说明_In     影像报告插件.说明%Type,
    显示样式_In 影像报告插件.显示样式%Type,
    种类_In     影像报告插件.种类%Type,
    类名_In     影像报告插件.类名%Type,
    库名_In     影像报告插件.库名%Type,
    是否禁用_In 影像报告插件.是否禁用%Type
	) As
  Begin
    Update 影像报告插件
       Set 编码     = 编码_In,
           名称     = 名称_In,
           说明     = 说明_In,
           显示样式 = 显示样式_In,
           种类     = 种类_In,
           类名     = 类名_In,
           库名     = 库名_In,
           是否禁用 = 是否禁用_In
     Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_EditDocPlugin;

  --56.删除报告插件信息
  Procedure p_DelDocPlugin(
    ID_In 影像报告插件.ID%Type
	) As
  Begin
    Delete From 影像报告插件 Where id = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_DelDocPlugin;

  --57.改变插件的可用状态
  Procedure p_IsEnableDocPlugin(
    ID_In 影像报告插件.ID%Type
	) As
  Begin
    Update 影像报告插件 a
       Set 是否禁用 = Decode(a.是否禁用, 1, 0, 1)
     Where id = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_IsEnableDocPlugin;

  --58.通过ID获得对应的插件信息
  Procedure p_GetDocPluginByID(
	Val           Out t_Refcur,
	ID_In 影像报告插件.ID%type
	) As
  Begin
    Open Val For
      Select Rawtohex(Id) ID,
             编码,
             名称,
             说明,
             显示样式,
             种类,
             类名,
             库名,
             是否禁用
        From 影像报告插件
       Where id = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetDocPluginByID;

  --59.判断编码和名称是否已存在
  Procedure p_IsExitDocPlugin(
	Val           Out t_Refcur,
	ID_In   影像报告插件.ID%Type,
	编码_In 影像报告插件.编码%Type,
	名称_In 影像报告插件.名称%Type
	) As
  Begin
    Open Val For
      Select Count(id)
        From 影像报告插件 a
       Where (a.编码 = 编码_In Or a.名称 = 名称_In)
         and a.id <> ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_IsExitDocPlugin;

  --60.通过ID获得对应的专用插件信息
  Procedure p_GetDocSpecPluginByID(
	Val           Out t_Refcur,
	ID_In 影像报告插件.ID%Type
	) As
  Begin
    Open Val For
      Select Rawtohex(Id) ID,
             编码,
             名称,
             说明,
             显示样式,
             种类,
             类名,
             库名,
             是否禁用
        From 影像报告插件
       Where id = ID_In
         And 种类 = 1;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetDocSpecPluginByID;

  --61.获得诊疗列表信息
  Procedure p_GetDiagnosisList(
	Val           Out t_Refcur,
	类别_In Varchar2,
	条件_In Varchar2
	) As
  Begin
    Open Val For
      Select to_char(a.id) ID,
             a.编码,
             a.名称,
             (Select b.名称 From 诊疗项目类别 b Where b.编码 = a.类别) 类别
        From 诊疗项目目录 a
       Where (a.id In (Select t.诊疗项目id From 影像检查项目 t) And a.类别 = 类别_In)
         And (a.编码 Like 条件_In || '%' Or a.名称 Like 条件_In || '%');
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetDiagnosisList;

  --62.获得诊疗类别列表
  Procedure p_GetDiagnosisClass(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select t.编码, t.名称, t.简码 From 诊疗项目类别 t;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetDiagnosisClass;

  --63.添加影像报告原型应用信息
  Procedure p_AddMedicalAntetype(
    诊疗项目ID_In 影像报告原型应用.诊疗项目ID%Type,
    应用场合_In   影像报告原型应用.应用场合%Type,
    报告原型ID_In 影像报告原型应用.报告原型ID%Type
	) As
  Begin
    Insert Into 影像报告原型应用
      (诊疗项目ID, 应用场合, 报告原型ID)
    Values
      (诊疗项目ID_In, 应用场合_In, 报告原型ID_In);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_AddMedicalAntetype;

  --64.删除原型ID对应的病历单据应用信息
  Procedure p_DelMedicalAntetype(
    报告原型ID_In 影像报告原型应用.报告原型ID%Type
	) As
  Begin
    Delete From 影像报告原型应用 Where 报告原型ID = 报告原型ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_DelMedicalAntetype;

  --65.通过原型ID获得对应的病历单据应用信息
  Procedure p_GetMedicalByAID(
	Val           Out t_Refcur,
	报告原型ID_In 影像报告原型应用.报告原型ID%Type
	) As
  Begin
    Open Val For
      Select id,
             x.编码,
             x.名称,
             x.类别,
             Sum(x.门诊) 门诊,
             Sum(x.住院) 住院,
             Sum(x.外诊) 外诊,
             Sum(x.体检) 体检
        From (Select id,
                     编码,
                     名称,
                     类别,
                     Decode(应用场合, '1', 1, 0) as 门诊,
                     Decode(应用场合, '2', 1, 0) as 住院,
                     Decode(应用场合, '3', 1, 0) as 外诊,
                     Decode(应用场合, '4', 1, 0) as 体检
                From (Select to_Char(a.诊疗项目id) ID,
                             (Select b.编码
                                From 诊疗项目目录 b
                               Where b.id = a.诊疗项目id) as 编码,
                             (Select b.名称
                                From 诊疗项目目录 b
                               Where b.id = a.诊疗项目id) as 名称,
                             (Select c.名称
                                From 诊疗项目类别 c
                               Where c.编码 = (Select b.类别
                                               From 诊疗项目目录 b
                                              Where b.id = a.诊疗项目id)) As 类别,
                             a.应用场合
                        From 影像报告原型应用 a
                       Where a.报告原型id = 报告原型ID_In)) x
       Group By x.id, x.编码, x.名称, x.类别;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetMedicalByAID;

  --66.根据原型ID删除动作信息
  Procedure p_DelDocProcessByAid(
    报告原型ID_In 影像报告原型应用.报告原型ID%Type
	) As
  Begin
    Delete From 影像报告动作 t Where t.原型id = 报告原型ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;
  --67.获取ID对应的原型的树形结构
  Procedure p_GetAntetypeTreeByID(
	Val           Out t_Refcur,
	ID_In 影像报告原型清单.ID%Type
	) As
  Begin
    Open Val For
      Select ID, 编码, 名称, 标题, 分组, 是否禁用, 说明, Imageindex
        From (Select Distinct 分组 As ID,
                              (Select Min(b.编码)
                                 From 影像报告原型清单 B
                                Where b.分组 = a.分组) As 编码,
                              a.分组 As 名称,
                              a.分组 As 标题,
                              null As 分组,
                              0 As 是否禁用,
                              null As 说明,
                              0 As Imageindex
                From 影像报告原型清单 A
               Where a.id = ID_In
              Union
              Select RawtoHex(ID) ID,
                     a.编码,
                     a.名称 As 名称,
                     编码 || '-' || 名称 As 标题,
                     分组,
                     a.是否禁用,
                     a.说明,
                     Decode(a.是否禁用, 1, 2, 1) Imageindex
                From 影像报告原型清单 A
               Where a.id = ID_In) A
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetAntetypeTreeByID;

  --68.原型是否存在对应的编码或名称
  procedure p_IsExitAntetype(
	Val           Out t_Refcur,
	编码_In 影像报告原型清单.编码%Type,
	名称_In 影像报告原型清单.名称%Type,
	ID_In  影像报告原型清单.ID%Type
	) As
  begin
    Open Val For
      Select Count(*) AS num
        From 影像报告原型清单 t
       where (t.编码 = 编码_In
          or t.名称 = 名称_In) and t.id<>ID_In;
  End p_IsExitAntetype;

  --7  获取影像存储设备
  Procedure p_GetStorageDevice(
	Val           Out t_Refcur
	) Is 
  Begin 
	Open Val For
		Select 设备号||' - '||设备名 As 存储设备, 设备号, IP地址, FTP目录, FTP用户名, FTP密码, 共享目录用户名, 共享目录密码, 共享目录  
		From 影像设备目录 Where 类型 = 1;
	Exception
	  When Others Then
	  Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetStorageDevice;
End b_PACS_RptAntetype;
/

--93761:梁经伙,2016-04-06,限制预出院，转科，转病区情况下首页修改了住院医师，主治医师等
Create Or Replace Procedure Zl_病案主页_首页整理
(
  病人id_In       病案主页.病人id%Type,
  主页id_In       病案主页.主页id%Type,
  年龄_In         病案主页.年龄%Type,
  国籍_In         病案主页.国籍%Type,
  区域_In         病案主页.区域%Type,
  职业_In         病案主页.职业%Type,
  身高_In         病案主页.身高%Type,
  体重_In         病案主页.体重%Type,
  血型_In         病案主页.血型%Type,
  婚姻状况_In     病案主页.婚姻状况%Type,
  医疗付款方式_In 病案主页.医疗付款方式%Type,
  家庭地址_In     病案主页.家庭地址%Type,
  家庭电话_In     病案主页.家庭电话%Type,
  家庭邮编_In     病案主页.家庭地址邮编%Type,
  户口地址_In     病案主页.户口地址%Type,
  户口邮编_In     病案主页.户口地址邮编%Type,
  单位地址_In     病案主页.单位地址%Type,
  单位电话_In     病案主页.单位电话%Type,
  单位邮编_In     病案主页.单位邮编%Type,
  联系人姓名_In   病案主页.联系人姓名%Type,
  联系人关系_In   病案主页.联系人关系%Type,
  联系人电话_In   病案主页.联系人电话%Type,
  联系人地址_In   病案主页.联系人地址%Type,
  入院病况_In     病案主页.入院病况%Type,
  入院方式_In     病案主页.入院方式%Type,
  出院方式_In     病案主页.出院方式%Type,
  再入院_In       病案主页.再入院%Type,
  是否确诊_In     病案主页.是否确诊%Type,
  确诊日期_In     病案主页.确诊日期%Type,
  尸检标志_In     病案主页.尸检标志%Type,
  随诊标志_In     病案主页.随诊标志%Type,
  随诊期限_In     病案主页.随诊期限%Type,
  新发肿瘤_In     病案主页.新发肿瘤%Type,
  中医治疗类别_In 病案主页.中医治疗类别%Type,
  抢救次数_In     病案主页.抢救次数%Type,
  成功次数_In     病案主页.成功次数%Type,
  门诊医师_In     病案主页.门诊医师%Type,
  住院医师_In     病案主页.住院医师%Type,
  主治医师_In     病案主页.住院医师%Type,
  主任医师_In     病案主页.住院医师%Type,
  责任护士_In     病案主页.责任护士%Type,
  操作员编号_In   病案主页.编目员编号%Type := Null,
  操作员姓名_In   病案主页.编目员姓名%Type := Null
) As
  --功能：用于住院医护工作站对病人进行首页整理
  v_住院医师 病案主页.住院医师%Type;
  v_主治医师 病案主页.住院医师%Type;
  v_主任医师 病案主页.住院医师%Type;
  v_责任护士 病案主页.责任护士%Type;
  v_病人性质 病案主页.病人性质%Type;
  v_原因     病人变动记录.开始原因%Type;
  v_出院科室 病案主页.出院科室id%Type;
  v_Curdate  Date;
  v_Count    Number;
  v_Change   Varchar2(500);
  n_出院     Number(1);
  v_Info     Varchar2(100);
  Cursor c_Oldinfo Is
    Select b.*
    From (Select c.*
           From 病人变动记录 C
           Where c.病人id = 病人id_In And c.主页id = 主页id_In And
                 c.开始时间 = (Select Min(开始时间)
                           From 病人变动记录
                           Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > v_Curdate)) A, 病人变动记录 B
    Where b.病人id = 病人id_In And b.主页id = 主页id_In And a.开始时间 = b.终止时间 And a.开始原因 = b.终止原因 And a.附加床位 = b.附加床位
    Union
    Select *
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And 开始时间 <= v_Curdate;

  Cursor c_Endinfo Is
    Select * From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
  r_Oldinfo  c_Oldinfo%RowType;
  r_Endinfo  c_Endinfo%RowType;
  v_终止原因 病人变动记录.终止原因%Type;
  v_终止时间 病人变动记录.终止时间%Type;
  v_终止人员 病人变动记录.终止人员%Type;

  v_Error Varchar2(255);
  Err_Custom Exception;

Begin
  --取更改前的内容(用NoneData和新的比较)
  Select 病人性质, Nvl(住院医师, 'NoneData'), Nvl(出院科室id, 入院科室id), Nvl(责任护士, 'NoneData')
  Into v_病人性质, v_住院医师, v_出院科室, v_责任护士
  From 病案主页
  Where 病人id = 病人id_In And 主页id = 主页id_In;

  Begin
    Select Nvl(信息值, 'NoneData')
    Into v_主治医师
    From 病案主页从表
    Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主治医师';
  
  Exception
    When Others Then
      v_主治医师 := 'NoneData';
    
  End;

  Begin
    Select Nvl(信息值, 'NoneData')
    Into v_主任医师
    From 病案主页从表
    Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主任医师';
  
  Exception
    When Others Then
      v_主任医师 := 'NoneData';
    
  End;

  Update 病案主页
  Set 婚姻状况 = 婚姻状况_In, 年龄 = 年龄_In, 职业 = 职业_In, 国籍 = 国籍_In, 区域 = 区域_In, 医疗付款方式 = 医疗付款方式_In, 家庭地址 = 家庭地址_In, 家庭电话 = 家庭电话_In,
      家庭地址邮编 = 家庭邮编_In, 单位地址 = 单位地址_In, 单位电话 = 单位电话_In, 单位邮编 = 单位邮编_In, 联系人姓名 = 联系人姓名_In, 联系人关系 = 联系人关系_In,
      联系人电话 = 联系人电话_In, 联系人地址 = 联系人地址_In, 再入院 = 再入院_In, 入院病况 = 入院病况_In, 是否确诊 = 是否确诊_In, 确诊日期 = 确诊日期_In, 抢救次数 = 抢救次数_In,
      成功次数 = 成功次数_In, 尸检标志 = 尸检标志_In, 随诊标志 = 随诊标志_In, 随诊期限 = 随诊期限_In, 血型 = 血型_In, 门诊医师 = 门诊医师_In, 住院医师 = 住院医师_In,
      新发肿瘤 = 新发肿瘤_In, 中医治疗类别 = 中医治疗类别_In, 身高 = 身高_In, 体重 = 体重_In, 出院方式 = 出院方式_In, 入院方式 = 入院方式_In, 责任护士 = 责任护士_In,
      户口地址 = 户口地址_In, 户口地址邮编 = 户口邮编_In
  Where 病人id = 病人id_In And 主页id = 主页id_In;

  Select Decode(出院日期, Null, 0, 1) Into n_出院 From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
  If n_出院 = 0 Then
    If v_住院医师 <> Nvl(住院医师_In, 'NoneData') Or v_主治医师 <> Nvl(主治医师_In, 'NoneData') Or v_主任医师 <> Nvl(主任医师_In, 'NoneData') Or
       v_责任护士 <> Nvl(责任护士_In, 'NoneData') Then
    
      v_原因 := Null;
      Select Max(Decode(开始原因, 10, '预出院', Null))
      Into v_Info
      From 病人变动记录
      Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
    
      If v_Info Is Null Then
        Select Max(Decode(开始原因, 3, '转科待入科', 15, '转病区待接收', Null))
        Into v_Info
        From 病人变动记录
        Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 Is Null And 终止时间 Is Null;
      End If;
    
      If v_Info Is Not Null Then
        Select f_List2str(Cast(Collect(a.信息) As t_Strlist))
        Into v_Change
        From (Select 姓名 信息
               From 人员表
               Where 0 = 1
               Union All
               Select '住院医师(原:' || v_住院医师 || ')' 信息
               From Dual
               Where v_住院医师 <> Nvl(住院医师_In, 'NoneData')
               Union All
               Select '主治医师(原:' || v_主治医师 || ')'
               From Dual
               Where v_主治医师 <> Nvl(主治医师_In, 'NoneData')
               Union All
               Select '主任医师(原:' || v_主任医师 || ')'
               From Dual
               Where v_主任医师 <> Nvl(主任医师_In, 'NoneData')
               Union All
               Select '责任护士(原:' || v_责任护士 || ')'
               From Dual
               Where v_责任护士 <> Nvl(责任护士_In, 'NoneData')) A;
        v_Error := '该病人正在' || v_Info || '，不能进行如下变动：' || v_Change || '！';
        Raise Err_Custom;
      End If;
      Select Sysdate Into v_Curdate From Dual;
      Open c_Oldinfo;
      Fetch c_Oldinfo
        Into r_Oldinfo;
      Open c_Endinfo;
      Fetch c_Endinfo
        Into r_Endinfo;
      If c_Endinfo%RowCount = 0 Then
        --出院病人不进行变动处理
        Close c_Endinfo;
      Else
        --如果终止时间<>NULL ，就记录下终止时间和终止原因。
        If r_Oldinfo.终止时间 Is Not Null Then
          v_终止时间 := r_Oldinfo.终止时间;
          v_终止原因 := r_Oldinfo.终止原因;
          v_终止人员 := r_Oldinfo.终止人员;
        End If;
        --如果是待入住的病人，则不产生变动，直接修改已有变动
        If r_Oldinfo.开始原因 = 1 And r_Oldinfo.终止时间 Is Null Then
          Update 病人变动记录
          Set 经治医师 = 住院医师_In, 主治医师 = 主治医师_In, 责任护士 = 责任护士_In, 主任医师 = 主任医师_In
          Where ID = r_Oldinfo.Id;
        Else
          If v_住院医师 <> Nvl(住院医师_In, 'NoneData') Then
            v_原因 := 7;
            If v_终止时间 Is Null Then
              Update 病人变动记录
              Set 终止时间 = v_Curdate, 终止原因 = v_原因, 终止人员 = 操作员姓名_In
              Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
            Else
              Update 病人变动记录
              Set 终止时间 = v_Curdate, 终止原因 = v_原因, 终止人员 = 操作员姓名_In, 上次计算时间 = Null
              Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_终止时间 And 终止原因 = v_终止原因;
              --更新将来的记录如果有停止到将来的则删除上次计算时间
              Update 病人变动记录
              Set 经治医师 = 住院医师_In, 上次计算时间 = Null
              Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > v_Curdate;
            End If;
          
            --产生病历书写时机
            Zl_电子病历时机_Insert(病人id_In, 主页id_In, 2, '交班', r_Oldinfo.科室id, 住院医师_In, v_Curdate, v_Curdate);
          
            While c_Oldinfo%Found Loop
              --注意:有附加床位时有多条记录
              Insert Into 病人变动记录
                (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情,
                 操作员编号, 操作员姓名, 终止时间, 终止原因, 终止人员)
              Values
                (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, v_Curdate, v_原因, r_Oldinfo.附加床位, r_Oldinfo.病区id, r_Oldinfo.科室id,
                 r_Oldinfo.医疗小组id, r_Oldinfo.护理等级id, r_Oldinfo.床位等级id, r_Oldinfo.床号, r_Oldinfo.责任护士, 住院医师_In,
                 r_Oldinfo.主治医师, r_Oldinfo.主任医师, r_Oldinfo.病情, 操作员编号_In, 操作员姓名_In, v_终止时间, v_终止原因, v_终止人员);
            
              Fetch c_Oldinfo
                Into r_Oldinfo;
            End Loop;
          
            --如果存在停止到将来的变动就更新终止原因
            If v_终止时间 Is Not Null Then
              v_终止原因 := v_原因;
              v_终止时间 := v_Curdate;
              v_终止人员 := 操作员姓名_In;
            End If;
          
            Close c_Oldinfo;
            Open c_Oldinfo; --重新打开,以便取最新信息
            Fetch c_Oldinfo
              Into r_Oldinfo;
          End If;
        
          If v_主治医师 <> Nvl(主治医师_In, 'NoneData') Then
            Update 病案主页从表
            Set 信息值 = 主治医师_In
            Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主治医师';
          
            If Sql%RowCount = 0 Then
              Insert Into 病案主页从表
                (病人id, 主页id, 信息名, 信息值)
              Values
                (病人id_In, 主页id_In, '主治医师', 主治医师_In);
            
            End If;
          
            v_原因 := 11;
            If v_终止时间 Is Null Then
              Update 病人变动记录
              Set 终止时间 = v_Curdate, 终止原因 = v_原因, 终止人员 = 操作员姓名_In
              Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
            
            Else
              Update 病人变动记录
              Set 终止时间 = v_Curdate, 终止原因 = v_原因, 终止人员 = 操作员姓名_In, 上次计算时间 = Null
              Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_终止时间 And 终止原因 = v_终止原因;
              --更新将来的记录如果有停止到将来的则删除上次计算时间
              Update 病人变动记录
              Set 主治医师 = 主治医师_In, 上次计算时间 = Null
              Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > v_Curdate;
            End If;
          
            While c_Oldinfo%Found Loop
              Insert Into 病人变动记录
                (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情,
                 操作员编号, 操作员姓名, 终止时间, 终止原因, 终止人员)
              Values
                (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, v_Curdate, v_原因, r_Oldinfo.附加床位, r_Oldinfo.病区id, r_Oldinfo.科室id,
                 r_Oldinfo.医疗小组id, r_Oldinfo.护理等级id, r_Oldinfo.床位等级id, r_Oldinfo.床号, r_Oldinfo.责任护士, r_Oldinfo.经治医师,
                 主治医师_In, r_Oldinfo.主任医师, r_Oldinfo.病情, 操作员编号_In, 操作员姓名_In, v_终止时间, v_终止原因, v_终止人员);
            
              Fetch c_Oldinfo
                Into r_Oldinfo;
            End Loop;
          
            --如果存在停止到将来的变动就更新终止原因
            If v_终止时间 Is Not Null Then
              v_终止原因 := v_原因;
              v_终止时间 := v_Curdate;
              v_终止人员 := 操作员姓名_In;
            End If;
          
            Close c_Oldinfo;
            Open c_Oldinfo;
            Fetch c_Oldinfo
              Into r_Oldinfo;
          End If;
        
          If v_责任护士 <> Nvl(责任护士_In, 'NoneData') Then
            v_原因 := 8;
            If v_终止时间 Is Null Then
              Update 病人变动记录
              Set 终止时间 = v_Curdate, 终止原因 = v_原因, 终止人员 = 操作员姓名_In
              Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
            Else
              Update 病人变动记录
              Set 终止时间 = v_Curdate, 终止原因 = v_原因, 终止人员 = 操作员姓名_In, 上次计算时间 = Null
              Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_终止时间 And 终止原因 = v_终止原因;
              --更新将来的记录，如果有停止到将来的则删除上次计算时间
              Update 病人变动记录
              Set 责任护士 = 责任护士_In, 上次计算时间 = Null
              Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > v_Curdate;
            End If;
            While c_Oldinfo%Found Loop
              Insert Into 病人变动记录
                (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情,
                 操作员编号, 操作员姓名, 终止时间, 终止原因, 终止人员)
              Values
                (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, v_Curdate, v_原因, r_Oldinfo.附加床位, r_Oldinfo.病区id, r_Oldinfo.科室id,
                 r_Oldinfo.医疗小组id, r_Oldinfo.护理等级id, r_Oldinfo.床位等级id, r_Oldinfo.床号, 责任护士_In, r_Oldinfo.经治医师,
                 r_Oldinfo.主治医师, r_Oldinfo.主任医师, r_Oldinfo.病情, 操作员编号_In, 操作员姓名_In, v_终止时间, v_终止原因, v_终止人员);
              Fetch c_Oldinfo
                Into r_Oldinfo;
            End Loop;
            --如果存在停止到将来的变动就更新终止原因
            If v_终止时间 Is Not Null Then
              v_终止原因 := v_原因;
              v_终止时间 := v_Curdate;
              v_终止人员 := 操作员姓名_In;
            End If;
            Close c_Oldinfo;
            Open c_Oldinfo;
            Fetch c_Oldinfo
              Into r_Oldinfo;
          End If;
        
          If v_主任医师 <> Nvl(主任医师_In, 'NoneData') Then
            Update 病案主页从表
            Set 信息值 = 主任医师_In
            Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主任医师';
          
            If Sql%RowCount = 0 Then
              Insert Into 病案主页从表
                (病人id, 主页id, 信息名, 信息值)
              Values
                (病人id_In, 主页id_In, '主任医师', 主任医师_In);
            
            End If;
          
            v_原因 := 12;
            If v_终止时间 Is Null Then
              Update 病人变动记录
              Set 终止时间 = v_Curdate, 终止原因 = v_原因, 终止人员 = 操作员姓名_In
              Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
            
            Else
              Update 病人变动记录
              Set 终止时间 = v_Curdate, 终止原因 = v_原因, 终止人员 = 操作员姓名_In, 上次计算时间 = Null
              Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_终止时间 And 终止原因 = v_终止原因;
              --更新将来的记录如果有停止到将来的则删除上次计算时间
              Update 病人变动记录
              Set 主任医师 = 主任医师_In, 上次计算时间 = Null
              Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > v_Curdate;
            End If;
          
            While c_Oldinfo%Found Loop
              Insert Into 病人变动记录
                (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情,
                 操作员编号, 操作员姓名, 终止时间, 终止原因, 终止人员)
              Values
                (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, v_Curdate, v_原因, r_Oldinfo.附加床位, r_Oldinfo.病区id, r_Oldinfo.科室id,
                 r_Oldinfo.医疗小组id, r_Oldinfo.护理等级id, r_Oldinfo.床位等级id, r_Oldinfo.床号, r_Oldinfo.责任护士, r_Oldinfo.经治医师,
                 r_Oldinfo.主治医师, 主任医师_In, r_Oldinfo.病情, 操作员编号_In, 操作员姓名_In, v_终止时间, v_终止原因, v_终止人员);
            
              Fetch c_Oldinfo
                Into r_Oldinfo;
            End Loop;
          
            Close c_Oldinfo;
            Open c_Oldinfo;
            Fetch c_Oldinfo
              Into r_Oldinfo;
          End If;
        
          Close c_Oldinfo;
          Close c_Endinfo;
          Select Count(*)
          Into v_Count
          From 病人变动记录
          Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(附加床位, 0) = 0 And 开始时间 Is Not Null And 终止时间 Is Null;
        
          If v_Count > 1 Then
            v_Error := '发现病人存在非法的变动记录,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
            Raise Err_Custom;
          End If;
        
        End If;
      
      End If;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
  
End Zl_病案主页_首页整理;
/

--94761:李南春,2016-03-31,检查卡号是否重复使用
CREATE OR REPLACE Procedure Zl_医疗卡变动_Insert
(
  变动类型_In   Number,
  病人id_In     住院费用记录.病人id%Type,
  卡类别id_In   病人医疗卡信息.卡类别id%Type,
  原卡号_In     病人医疗卡信息.卡号%Type,
  医疗卡号_In   病人医疗卡信息.卡号%Type,
  变动原因_In   病人医疗卡变动.变动原因%Type,
  密码_In       病人信息.卡验证码%Type,
  操作员姓名_In 住院费用记录.操作员姓名%Type,
  变动时间_In   住院费用记录.登记时间%Type,
  Ic卡号_In     病人信息.Ic卡号%Type := Null,
  挂失方式_In   病人医疗卡变动.挂失方式%Type := Null
) As
  --参数：发卡类型=1-发卡(或11绑定卡);2-换卡;3-补卡(13-补卡停用);4-退卡(或14取消绑定); ５-密码调整(只记录);6-挂失(16取消挂失)
  --变动原因_In:如果密码调整，变动原因为密码.加密的
  Err_Item Exception;
  v_Err_Msg        Varchar2(500);
  n_医疗卡重复使用 Number(3);
  n_一卡通         Number(1);
  n_Count          Number;
  n_Bound          Number(2);
  n_Id             病人医疗卡变动.ID%Type;
  v_原密码         病人医疗卡信息.密码%Type;

  Cursor c_医疗卡(Id_In 病人医疗卡信息.卡类别id%Type) Is
    Select ID, 编码, 名称, 短名, 前缀文本, 卡号长度, 缺省标志, 是否固定, 是否严格控制,
           Nvl(是否自制, 0) As 是否自制, Nvl(是否存在帐户, 0) As 是否存在帐户, Nvl(是否全退, 0) As 是否全退, 部件, 备注,
           特定项目, 结算方式, 是否启用, 卡号密文, Nvl(是否重复使用, 0) As 是否重复使用
    From 医疗卡类别
    Where ID = Id_In;
  r_医疗卡 c_医疗卡%Rowtype;

Begin
  If 变动类型_In <> 14 Then
    Open c_医疗卡(卡类别id_In);
    Fetch c_医疗卡
      Into r_医疗卡;
    If c_医疗卡%Rowcount = 0 Then
      Close c_医疗卡;
      v_Err_Msg := '[ZLSOFT]没有发现原医疗卡的相应类别,不能继续操作！[ZLSOFT]';
      Raise Err_Item;
    End If;

    n_医疗卡重复使用 := Nvl(r_医疗卡.是否重复使用, 0);
  End If;
  If Instr('1,11,2,3', 变动类型_In) > 0 Then
    Select Count(*)
    Into n_Count
    From 病人医疗卡信息
    Where 卡类别id = 卡类别id_In And 卡号 = 医疗卡号_In And 病人id <> 病人id_In And 状态 In (0, 1, 2);
    If n_Count > 0 Then
      v_Err_Msg := '[ZLSOFT]新卡号:' || 医疗卡号_In || ' 正在使用，请换一张新卡,请检查![ZLSOFT]';
      Raise Err_Item;
    End If;
    If n_医疗卡重复使用 = 0 Then
      Begin
        Select 1 Into n_Count From 病人医疗卡变动 Where 卡类别id = 卡类别id_In And 卡号 = 医疗卡号_In And Rownum = 1;
      Exception
        When Others Then
          n_Count := -1;
      End;
      If n_Count = 1 Then
        Close c_医疗卡;
        v_Err_Msg := '[ZLSOFT]卡号:' || 医疗卡号_In || '不能重复使用,不能继续操作！[ZLSOFT]';
        Raise Err_Item;
      End If;
    End If;
  End If;
  If Mod(变动类型_In, 10) = 1 Then
    --发卡和绑定卡
    Insert Into 病人医疗卡信息
      (病人id, 卡类别id, 卡号, 密码, 状态, 发卡日期, 发卡人, 挂失时间, 挂失方式, 挂失人)
    Values
      (病人id_In, 卡类别id_In, 医疗卡号_In, 密码_In, 0, 变动时间_In, 操作员姓名_In, Null, Null, Null);
    Insert Into 病人医疗卡变动
      (ID, 病人id, 卡类别id, 卡号, 变动id, 变动类别, 变动时间, 变动原因, 挂失方式, 原密码, 操作员姓名, 登记时间)
    Values
      (病人医疗卡变动_Id.Nextval, 病人id_In, 卡类别id_In, 医疗卡号_In, Null, 变动类型_In, 变动时间_In, 变动原因_In,
       Null, 密码_In, 操作员姓名_In, 变动时间_In);
  End If;

  If 变动类型_In = 2 Then
    --换卡
    v_Err_Msg := Null;
    Begin
      Select 密码
      Into v_原密码
      From 病人医疗卡信息
      Where 卡类别id = 卡类别id_In And 病人id = 病人id_In And 卡号 = 原卡号_In;
    Exception
      When Others Then
        v_Err_Msg := '[ZLSOFT]卡号:' || 原卡号_In || '未找到,不能换卡！[ZLSOFT]';
    End;
    If v_Err_Msg Is Not Null Then
      Close c_医疗卡;
      Raise Err_Item;
    End If;

    Select 病人医疗卡变动_Id.Nextval Into n_Id From Dual;

    Delete 病人医疗卡信息 Where 卡类别id = 卡类别id_In And 病人id = 病人id_In And 卡号 = 原卡号_In;
    Insert Into 病人医疗卡信息
      (病人id, 卡类别id, 卡号, 密码, 状态, 发卡日期, 发卡人, 挂失时间, 挂失方式, 挂失人)
    Values
      (病人id_In, 卡类别id_In, 医疗卡号_In, 密码_In, 0, 变动时间_In, 操作员姓名_In, Null, Null, Null);

    Insert Into 病人医疗卡变动
      (ID, 病人id, 卡类别id, 卡号, 变动id, 变动类别, 变动时间, 变动原因, 现密码, 挂失方式, 操作员姓名, 登记时间)
    Values
      (n_Id, 病人id_In, 卡类别id_In, 医疗卡号_In, Null, 变动类型_In, 变动时间_In, 变动原因_In, 密码_In, Null,
       操作员姓名_In, 变动时间_In);

    Insert Into 病人医疗卡变动
      (ID, 病人id, 卡类别id, 卡号, 变动id, 变动类别, 变动时间, 变动原因, 挂失方式, 原密码, 操作员姓名, 登记时间)
    Values
      (病人医疗卡变动_Id.Nextval, 病人id_In, 卡类别id_In, 原卡号_In, n_Id, 变动类型_In, 变动时间_In, 变动原因_In, Null,
       v_原密码, 操作员姓名_In, 变动时间_In);
  End If;

  If 变动类型_In = 3 Then
    --补卡/
    --全部停用,发新卡
    Select 病人医疗卡变动_Id.Nextval Into n_Id From Dual;

    Insert Into 病人医疗卡变动
      (ID, 病人id, 卡类别id, 卡号, 变动id, 变动类别, 变动时间, 变动原因, 挂失方式, 操作员姓名, 登记时间)
    Values
      (n_Id, 病人id_In, 卡类别id_In, 医疗卡号_In, Null, 3, 变动时间_In, 变动原因_In, Null, 操作员姓名_In, 变动时间_In);

    Insert Into 病人医疗卡变动
      (ID, 病人id, 卡类别id, 卡号, 变动id, 变动类别, 变动时间, 变动原因, 挂失方式, 原密码, 操作员姓名, 登记时间)
      Select 病人医疗卡变动_Id.Nextval, 病人id, 卡类别id, 卡号, n_Id, 13, 变动时间_In, '补卡停用', Null, 密码_In,
             操作员姓名_In, 变动时间_In
      From 病人医疗卡信息
      Where 卡类别id = 卡类别id_In And 病人id = 病人id_In And Nvl(状态, 0) = 0;

    Update 病人医疗卡信息 Set 状态 = 2 Where 卡类别id = 卡类别id_In And 病人id = 病人id_In And Nvl(状态, 0) = 0;

    Insert Into 病人医疗卡信息
      (病人id, 卡类别id, 卡号, 密码, 状态, 发卡日期, 发卡人, 挂失时间, 挂失方式, 挂失人)
    Values
      (病人id_In, 卡类别id_In, 医疗卡号_In, 密码_In, 0, 变动时间_In, 操作员姓名_In, Null, Null, Null);
  End If;

  If 变动类型_In = 4 Then
    -- 退卡
    Delete 病人医疗卡信息 Where 卡类别id = 卡类别id_In And 病人id = 病人id_In And 卡号 = 医疗卡号_In;
    Insert Into 病人医疗卡变动
      (ID, 病人id, 卡类别id, 卡号, 变动id, 变动类别, 变动时间, 变动原因, 挂失方式, 操作员姓名, 登记时间)
    Values
      (病人医疗卡变动_Id.Nextval, 病人id_In, 卡类别id_In, 医疗卡号_In, Null, 变动类型_In, 变动时间_In, 变动原因_In,
       Null, 操作员姓名_In, 变动时间_In);
       Delete 病人医疗卡属性 Where 病人id=病人id_In;
  End If;
  If 变动类型_In = 14 Then
    -- 取消绑定卡
    --处理宁波一卡通的发卡数据,根据启用=2来判断.
    Begin
      Select 1 Into n_一卡通 From 一卡通目录 Where 启用 = 2 And Rownum <= 1;
    Exception
      When Others Then
        n_一卡通 := 0;
    End;

    n_Count := 0;
    For v_医疗卡 In (Select A.卡号, A.病人id, A.卡类别id, Nvl(B.是否重复使用, 0) As 是否重复使用,
                            Decode(B.名称, '就诊卡', Decode(Nvl(B.是否固定, 0), 1, B.ID, 0), 0) As 就诊卡id
                     From 病人医疗卡信息 A, 医疗卡类别 B
                     Where A.卡类别id = B.ID And A.病人id = 病人id_In And Nvl(A.状态, 0) = 0 And
                           (A.卡类别id = 卡类别id_In Or Nvl(卡类别id_In, 0) = 0) And
                           (A.卡号 = 医疗卡号_In Or 医疗卡号_In Is Null)) Loop
      n_医疗卡重复使用 := Nvl(r_医疗卡.是否重复使用, 0);
      ---只有在住院费用记录中不存在时,才会进行取消绑定操作
      Begin
        Select 1
        Into n_Bound
        From 住院费用记录
        Where 病人id = 病人id_In And 记录性质 = 5 And
              Decode(结论, Null, v_医疗卡.就诊卡id, To_Number(结论)) = v_医疗卡.卡类别id And 实际票号 = v_医疗卡.卡号 And
              Rownum = 1;
      Exception
        When Others Then
          n_Bound := 0;
      End;
      If n_Bound = 0 Then
        Delete 病人医疗卡信息 Where 卡类别id = v_医疗卡.卡类别id And 病人id = 病人id_In And 卡号 = v_医疗卡.卡号;
        Insert Into 病人医疗卡变动
          (ID, 病人id, 卡类别id, 卡号, 变动id, 变动类别, 变动时间, 变动原因, 挂失方式, 操作员姓名, 登记时间)
        Values
          (病人医疗卡变动_Id.Nextval, 病人id_In, 卡类别id_In, 医疗卡号_In, Null, 变动类型_In, 变动时间_In, 变动原因_In,
           Null, 操作员姓名_In, 变动时间_In);

        --就诊卡处理
        If Nvl(v_医疗卡.就诊卡id, 0) <> 0 And n_一卡通 = 1 Then
          Update 病人信息
          Set 就诊卡号 = Null, 卡验证码 = Null, Ic卡号 = Decode(Ic卡号, 就诊卡号, Null, Ic卡号)
          Where 病人id = 病人id_In;
        End If;
        n_Count := n_Count + 1;
      End If;
      --检查是否成功更新
      If n_Count = 0 Then
        v_Err_Msg := '[ZLSOFT]未找到绑定的卡号,不能取消绑定！[ZLSOFT]';
        Raise Err_Item;
      End If;
    End Loop;
    Delete 病人医疗卡属性 Where 病人id=病人id_In;
  End If;

  If Mod(变动类型_In, 10) = 5 Then
    -- ５-密码调整(只记录)
    v_Err_Msg := Null;
    Begin
      Select 密码
      Into v_原密码
      From 病人医疗卡信息
      Where 卡类别id = 卡类别id_In And 病人id = 病人id_In And 卡号 = 医疗卡号_In;
    Exception
      When Others Then
        v_Err_Msg := '[ZLSOFT]卡号:' || 医疗卡号_In || '未找到,不能密码调整！[ZLSOFT]';
    End;
    If v_Err_Msg Is Not Null Then
      Close c_医疗卡;
      Raise Err_Item;
    End If;

    Select 病人医疗卡变动_Id.Nextval Into n_Id From Dual;
    Insert Into 病人医疗卡变动
      (ID, 病人id, 卡类别id, 卡号, 变动id, 变动类别, 变动时间, 变动原因, 原密码, 现密码, 操作员姓名, 登记时间)
    Values
      (n_Id, 病人id_In, 卡类别id_In, 医疗卡号_In, Null, 变动类型_In, 变动时间_In, 变动原因_In, v_原密码, 密码_In,
       操作员姓名_In, 变动时间_In);

    Update 病人医疗卡信息
    Set 密码 = 密码_In
    Where 卡类别id = 卡类别id_In And 病人id = 病人id_In And 卡号 = 医疗卡号_In;
    If r_医疗卡.名称 = '就诊卡' And Nvl(r_医疗卡.是否固定, 0) = 1 Then
      Update 病人信息 Set 卡验证码 = 密码_In Where 病人id = 病人id_In;
    End If;

    Return;
  End If;
  If Mod(变动类型_In, 10) = 6 Then
    -- 6挂失(16取消挂失)
    v_Err_Msg := Null;
    Begin
      Select 1
      Into n_Count
      From 病人医疗卡信息
      Where 卡类别id = 卡类别id_In And 病人id = 病人id_In And 卡号 = 医疗卡号_In;
    Exception

      When Others Then
        v_Err_Msg := '[ZLSOFT]卡号:' || 医疗卡号_In || '未找到,不能' || Case When 变动类型_In = 6 Then '挂失' Else '取消挂失' End || '！[ZLSOFT]';
    End;
    If v_Err_Msg Is Not Null Then
      Close c_医疗卡;
      Raise Err_Item;
    End If;

    Insert Into 病人医疗卡变动
      (ID, 病人id, 卡类别id, 卡号, 变动id, 变动类别, 变动时间, 变动原因, 挂失方式, 操作员姓名, 登记时间)
    Values
      (病人医疗卡变动_Id.Nextval, 病人id_In, 卡类别id_In, 医疗卡号_In, n_Id, 变动类型_In, 变动时间_In, 变动原因_In,
       挂失方式_In, 操作员姓名_In, 变动时间_In);

    If 变动类型_In = 6 Then
      Update 病人医疗卡信息
      Set 挂失方式 = 挂失方式_In, 状态 = 1, 挂失时间 = Sysdate, 挂失人 = 操作员姓名_In
      Where 卡类别id = 卡类别id_In And 病人id = 病人id_In And 卡号 = 医疗卡号_In;
     else
  Update 病人医疗卡信息
  Set 挂失方式 = NULL, 状态 = 0, 挂失时间 = NULL, 挂失人 =NULL
  Where 卡类别id = 卡类别id_In And 病人id = 病人id_In And 卡号 = 医疗卡号_In;
     End if;

    Return;

  End If;

  If r_医疗卡.名称 = '就诊卡' And Nvl(r_医疗卡.是否固定, 0) = 1 Then
    --处理宁波一卡通的发卡数据,根据启用=2来判断.
    Begin
      Select 1 Into n_一卡通 From 一卡通目录 Where 启用 = 2 And Rownum <= 1;
    Exception
      When Others Then
        n_一卡通 := 0;
    End;
    If n_一卡通 = 1 Then

      If Mod(变动类型_In, 10) = 4 Then
        --退卡或取消绑定卡
        Update 病人信息
        Set 就诊卡号 = Null, 卡验证码 = Null, Ic卡号 = Decode(Ic卡号, 就诊卡号, Null, Ic卡号)
        Where 病人id = 病人id_In;
        --处理规则:
        --  如果上传了卡号的，则不能退卡
        --  如果未上传,则将新卡号更新为NULL
        --如果本身未存在病人发卡记录,则允许退卡
        If 变动类型_In = 4 Then
          Update 病人发卡记录
          Set 新卡号 = Null
          Where 病人id = 病人id_In And 发卡时间 In (Select Max(发卡时间) From 病人发卡记录 Where 病人id = 病人id_In) And
                Nvl(上传标志, 0) = 0;
          If Sql%NotFound Then
            Begin
              Select 1 Into n_一卡通 From 病人发卡记录 Where 病人id = 病人id_In;
            Exception
              When Others Then
                n_一卡通 := 0;
            End;
            If n_一卡通 = 1 Then
              v_Err_Msg := '[ZLSOFT]没有发现要退卡的记录,该记录可能已经退除！[ZLSOFT]';
              Raise Err_Item;
            End If;
          End If;
        End If;
        Return;

      End If;
      If 变动类型_In = 11 Then
        --绑定卡
        Update 病人信息
        Set 就诊卡号 = 医疗卡号_In, 卡验证码 = 密码_In,
            Ic卡号 = Decode(Ic卡号_In, Null, Nvl(Ic卡号, 医疗卡号_In), Ic卡号_In)
        Where 病人id = 病人id_In;
        If 医疗卡号_In Is Not Null Then
          Update 病人发卡记录 Set 新卡号 = 医疗卡号_In, 发卡时间 = Sysdate Where 病人id = 病人id_In And 新卡号 Is Null;
        End If;
      End If;

      If Ic卡号_In Is Null Then
        If n_医疗卡重复使用 = 1 Then
          Update 病人信息 Set 就诊卡号 = Null Where 病人id <> 病人id_In And 就诊卡号 = 医疗卡号_In;
        End If;
        Update 病人信息 Set 就诊卡号 = 医疗卡号_In, 卡验证码 = 密码_In Where 病人id = 病人id_In;
      Else
        --档案号以IC卡号传入
        Update 病人信息 Set Ic卡号 = Ic卡号_In Where 病人id = 病人id_In;
      End If;

      --处理发卡数据
      --病人发卡记录表中至少存在一条记录，当该病人第一次在本院医疗时由zlICCard部件在ReadCard 后产生，此时的数据没有新卡号
      --发卡程序检查病人发卡记录，如果存在新卡号为空的记录（最多只有一条），则更新新卡号字段；否则产生一条新记录，插入旧卡号，新卡号，过程如下：
      Update 病人发卡记录 Set 新卡号 = 医疗卡号_In, 发卡时间 = Sysdate Where 病人id = 病人id_In And 新卡号 Is Null;
      If Sql%NotFound Then
        Insert Into 病人发卡记录
          (病人id, 旧卡号, 旧卡类型, 旧卡发卡医院, 新卡号, 发卡时间)
          Select 病人id_In, Nvl(原卡号_In, ' '), 2, 医院编码, 医疗卡号_In, Sysdate
          From 一卡通目录
          Where 启用 = 2 And Rownum <= 1 And Not Exists
           (Select 1 From 病人发卡记录 Where 病人id = 病人id_In And 旧卡号 = Nvl(原卡号_In, ' '));
      End If;
    Else
       --更新病人信息
       If Mod(变动类型_In, 10) = 4  then
           Update 病人信息
           Set 就诊卡号 = Null, 卡验证码 = Null, Ic卡号 = Decode(Ic卡号, 就诊卡号, Null, Ic卡号)
           Where 病人id = 病人id_In;
       Else
        --病人医疗卡信息变化
        If n_医疗卡重复使用 = 1 Then
          --需要检查其他病人是否使用了该卡号，如果使用了，则将医疗卡号设置为NULL
          Update 病人信息
          Set 就诊卡号 = Null, Ic卡号 = Decode(Ic卡号, 就诊卡号, Null, Ic卡号)
          Where 病人id <> 病人id_In And 就诊卡号 = 医疗卡号_In;
        End If;
        Update 病人信息
        Set 就诊卡号 = 医疗卡号_In, 卡验证码 = 密码_In, Ic卡号 = Decode(Ic卡号, 就诊卡号, 医疗卡号_In, Ic卡号)
        Where 病人id = 病人id_In;
      End if;
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_医疗卡变动_Insert;
/

--94658:梁唐彬,2016-04-06,先作废后退药处理
CREATE OR REPLACE Procedure Zl_病人医嘱记录_作废
(
  Id_In         病人医嘱记录.Id%Type,
  操作员编号_In 人员表.编号%Type := Null,
  操作员姓名_In 人员表.姓名%Type := Null,
  护理医嘱id_In 病人医嘱记录.Id%Type := Null,
  作废时间_In   病人医嘱状态.操作时间%Type := Null
) Is
  --功能：作废指定的医嘱(未发送的长嘱或临嘱)
  --说明：一并给药的只能调用一次(界面显示有多行)
  --参数：ID_IN=组医嘱ID
  --      护理医嘱id_In 取除开本次作废的护理等级医嘱外的最近的自动停止的护理等级医嘱id

  v_发送号       病人医嘱发送.发送号%Type;
  v_费用no       门诊费用记录.No%Type;
  v_记录性质     门诊费用记录.记录性质%Type;
  v_费用序号     Varchar2(255);
  n_自动取消执行 Number(1) := 0;
  n_先作废后退药 Number(1) := 0;

  v_Date     Date;
  v_Count    Number;
  v_Temp     Varchar2(255);
  v_人员编号 人员表.编号%Type;
  v_人员姓名 人员表.姓名%Type;

  --包含医嘱相关信息
  Cursor c_Advice Is
    Select a.病人id, a.挂号单, a.主页id, a.婴儿, a.医嘱状态, a.上次执行时间, a.医嘱内容, a.诊疗类别, b.操作类型, a.病人来源, a.执行科室id, b.执行频率, a.诊疗项目id,
           a.开始执行时间
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id And a.Id = Id_In;

  r_Advice c_Advice%RowType;

  --门诊医嘱作废时，取对应的费用销帐或作废(收费划价单)：
  --根据医嘱及发送NO求出本次回退要销帐或退费的记录
  --一组医嘱并不是都填写了发送记录,也不一定都计费了,且可能NO不同
  --只管记录状态为1的记录,如果已经销帐或部份销帐的记录,不再处理
  --费用只求价格父号为空的,以便取序号销帐
  --如果"门诊药嘱先作废后退药",则不对相应费用(包括给药途径的)进行检查和处理,除非是还没有执行的记帐单,或未执行、收费的划价单，可以先删了。


  Cursor c_Rollmoney(v_发送号 病人医嘱发送.发送号%Type) Is
    Select a.记录性质, a.记录状态, a.No, a.序号, a.执行状态 As 费用执行, c.执行状态 As 医嘱执行, c.执行部门id, b.病人科室id,B.诊疗类别,I.操作类型
    From 门诊费用记录 A, 病人医嘱记录 B, 病人医嘱发送 C, 诊疗项目目录 I
    Where c.医嘱id = b.Id And c.发送号 = v_发送号 And (b.Id = Id_In Or b.相关id = Id_In) And a.医嘱序号 = b.Id And a.记录状态 In (0, 1) And
          a.No = c.No And a.记录性质 = c.记录性质 And b.诊疗项目id = i.Id And a.价格父号 Is Null And
          (n_先作废后退药 = 0 Or n_先作废后退药 = 1 And Not (Exists (Select 1
                                                         From 门诊费用记录 D
                                                         Where d.医嘱序号 = b.Id And d.记录状态 In (0, 1) And d.No = c.No And
                                                               d.记录性质 = c.记录性质 And d.收费类别 In ('5', '6', '7'))
       ) Or Nvl(a.执行状态, 0) = 0 And Not (a.记录性质 = 1 And a.记录状态 <> 0))
    Order By a.记录性质, a.No, a.序号, a.收费细目id;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --检查医嘱状态是否正确:并发操作
  Open c_Advice;
  Fetch c_Advice
    Into r_Advice;

  --当前操作人员
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
    v_人员编号 := 操作员编号_In;
    v_人员姓名 := 操作员姓名_In;
  Else
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;

  --检查是否已经出了报告单，已经出报告单的医嘱不能够作废
  Select Count(1) Into v_Count From 病人医嘱报告  Where 医嘱ID = Id_In;
  If v_Count > 0  Then
    v_Error := '医嘱"' || r_Advice.医嘱内容 || '"已出报告，不能作废。';
    Raise Err_Custom;
  End If;

  --检查是否是输液配液记录，并是否已经锁定
  Select Count(1) Into v_Count From 输液配药记录 Where 是否锁定 = 1 And 医嘱id = Id_In;
  If v_Count > 0 Then
    v_Error := '医嘱"' || r_Advice.医嘱内容 || '"是输液药品，已经被输液配置中心锁定，不能作废。';
    Raise Err_Custom;
  End If;

  If r_Advice.挂号单 Is Null And r_Advice.病人来源 <> 3 Then
    If r_Advice.医嘱状态 In (4, 8, 9) Then
      v_Error := '医嘱"' || r_Advice.医嘱内容 || '"已经被作废或停止，不能再作废。';
      Raise Err_Custom;
    Elsif r_Advice.上次执行时间 Is Not Null Then
      v_Error := '医嘱"' || r_Advice.医嘱内容 || '"已经发送，不能被作废。';
      Raise Err_Custom;
    End If;

    --持续性护理等级无须发送，校对后就可能已自动计费，作废及回退作废都应按停止流程处理。
    If r_Advice.诊疗类别 = 'H' And r_Advice.操作类型 = '1' And r_Advice.执行频率 = '2' And Nvl(r_Advice.婴儿, 0) = 0 Then
      --(已取消，由于存在无费退院的情况，问题号：45977)a.开始时间是当天之前的，说明已生效（自动费用计算），不允许作废。
      --医嘱的时间只精确到了分钟，所以变动记录的开始时间要去掉秒来比较。
      v_Count := 0;
      Begin
        Select b.终止时间
        Into v_Date
        From 病人变动记录 B, 病人医嘱计价 C
        Where b.病人id = r_Advice.病人id And b.主页id = r_Advice.主页id And c.医嘱id = Id_In And c.收费细目id = b.护理等级id And
              b.开始原因 = 6 And b.附加床位 = 0 And
              To_Char(b.开始时间, 'yyyy-mm-dd hh24:mi') = To_Char(r_Advice.开始执行时间, 'yyyy-mm-dd hh24:mi');
      Exception
        When Others Then
          v_Count := 1;
      End;
      If v_Count = 0 Then
        --d.后续有其他变动发生
        If v_Date Is Not Null Then
          v_Error := '由于护理等级医嘱生效后已经产生了其他变动记录,不能作废该医嘱。';
          Raise Err_Custom;
        Else
          --本次有要自动启用的护理等级，如果和原来护理等级相同则不用撤消护理变动记录
          If Nvl(护理医嘱id_In, 0) <> 0 Then
            Delete 病人医嘱状态 Where 医嘱id = 护理医嘱id_In And 操作类型 In (8, 9);
            Select 操作类型
            Into v_Count
            From (Select 操作类型 From 病人医嘱状态 Where 医嘱id = 护理医嘱id_In Order By 操作时间 Desc)
            Where Rownum < 2;
            Update 病人医嘱记录
            Set 医嘱状态 = v_Count, 执行终止时间 = Null, 停嘱医生 = Null, 停嘱时间 = Null, 确认停嘱时间 = Null, 确认停嘱护士 = Null
            Where ID = 护理医嘱id_In;
            --排除过于频繁的操作
            Select Count(a.Id)
            Into v_Count
            From 病人医嘱记录 A, 诊疗收费关系 B, 病案主页 C
            Where a.诊疗项目id = b.诊疗项目id And c.护理等级id = b.收费项目id And c.病人id = a.病人id And c.主页id = a.主页id And
                  a.Id = 护理医嘱id_In;
          End If;
          If v_Count = 0 Then
            --c.护理等级是最后一条变动
            Zl_病人变动记录_Undo(r_Advice.病人id, r_Advice.主页id, v_人员编号, v_人员姓名, '1', Null, Null, '护理等级变动');
          End If;
        End If;
      Else
        --恢复最近一次被自动停止的护理等级
        If Nvl(护理医嘱id_In, 0) <> 0 Then
          Delete 病人医嘱状态 Where 医嘱id = 护理医嘱id_In And 操作类型 In (8, 9);
          Select 操作类型
          Into v_Count
          From (Select 操作类型 From 病人医嘱状态 Where 医嘱id = 护理医嘱id_In Order By 操作时间 Desc)
          Where Rownum < 2;
          Update 病人医嘱记录
          Set 医嘱状态 = v_Count, 执行终止时间 = Null, 停嘱医生 = Null, 停嘱时间 = Null, 确认停嘱时间 = Null, 确认停嘱护士 = Null
          Where ID = 护理医嘱id_In;
        Else
          --病人入院时指定的护理级产生的变动记录和医嘱新开产生的变动记录不同，这里要先判断
          Select Count(a.Id)
          Into v_Count
          From 病人变动记录 A
          Where a.病人id = r_Advice.病人id And a.主页id = r_Advice.主页id And a.开始原因 = 6;
          If v_Count <> 0 Then
            --b.如果与以前的护理等级相同，则校对时没有产生护理等级变动,产生护理等级停止变动
            Zl_病人变动记录_Nurse(r_Advice.病人id, r_Advice.主页id, Null, Sysdate, v_人员编号, v_人员姓名);
          End If;
        End If;
      End If;
    End If;
  Else
    If r_Advice.医嘱状态 <> 8 Then
      v_Error := '医嘱"' || r_Advice.医嘱内容 || '"尚未发送或已经作废。';
      Raise Err_Custom;
    End If;

    Begin
      --医嘱ID为传入值的这条医嘱不一定发送了的,甚至无发送。
      Select Distinct 发送号
      Into v_发送号
      From 病人医嘱发送
      Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = Id_In Or 相关id = Id_In);
    Exception
      When Others Then
        v_发送号 := Null;
    End;

    Select Zl_To_Number(Nvl(zl_GetSysParameter(68), 0)) Into n_先作废后退药 From Dual;
    Select Zl_To_Number(Nvl(zl_GetSysParameter('门诊本科自动执行', '1252'), 0)) Into n_自动取消执行 From Dual;
    If n_自动取消执行 = 1 And v_发送号 Is Not Null Then
      --先更新医嘱和费用的执行状态，因为后续的判断，以及过程Zl_门诊记帐记录_Delete中有检查
      For Rc In (Select a.医嘱id, a.执行部门id
                 From 病人医嘱发送 A, 病人医嘱记录 B
                 Where a.医嘱id = b.Id And (b.Id = Id_In Or b.相关id = Id_In) And a.执行部门id = b.病人科室id) Loop
        Zl_病人医嘱执行_Cancel(Rc.医嘱id, v_发送号, Null, 1, Rc.执行部门id);
      End Loop;
    End If;

    --门诊医嘱只可能发送一次
    --后面退费时还有检查，因为可能医嘱没有费用，所以要检查一次执行状态
    Select Count(*)
    Into v_Count
    From 病人医嘱发送 A, 病人医嘱记录 B, 诊疗项目目录 I
    Where a.医嘱id = b.Id And b.诊疗项目id = i.Id And a.执行状态 In (1, 3) And (b.Id = Id_In Or b.相关id = Id_In) And
          (n_先作废后退药 = 0 Or
          n_先作废后退药 = 1 And Not (b.诊疗类别 In ('5', '6', '7') Or b.诊疗类别 = 'E' And i.操作类型 In ('2', '3', '4')));
    If v_Count > 0 Then
      v_Error := '该医嘱已经执行或正在执行，不能作废。';
      Raise Err_Custom;
    End If;
  End If;

  If 作废时间_In Is Null Then
    Select Sysdate Into v_Date From Dual;
  Else
    v_Date := 作废时间_In;
  End If;

  Update 病人医嘱记录 Set 医嘱状态 = 4 Where ID = Id_In Or 相关id = Id_In;

  Insert Into 病人医嘱状态
    (医嘱id, 操作类型, 操作人员, 操作时间)
    Select ID, 4, v_人员姓名, v_Date From 病人医嘱记录 Where ID = Id_In Or 相关id = Id_In;

  --住院医嘱作废时,未打印的情况下,缺省设置为屏蔽打印
  If r_Advice.挂号单 Is Null Then
    Select Count(*)
    Into v_Count
    From 病人医嘱打印
    Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = Id_In Or 相关id = Id_In);
    If Nvl(v_Count, 0) = 0 Then
      Zl_病人医嘱记录_屏蔽打印(Id_In, 1);
    End If;
  Else
    --门诊医嘱(临嘱)作废时还需要回退相关内容:只有一次发送
    --回退划价或记帐费用
    If v_发送号 Is Not Null Then
      --将该组医嘱的费用删除或销帐(按一组医嘱可能有不同NO处理)
      --门诊记帐：如果原始费用已被销帐(或部分销帐),调用过程中有判断
      --门诊划价：如果已收费，则不允许删除
      v_费用no   := Null;
      v_费用序号 := Null;
      For r_Rollmoney In c_Rollmoney(v_发送号) Loop
        If Nvl(r_Rollmoney.医嘱执行, 0) In (1, 3) Then
          --1-完全执行;3-正在执行
          v_Error := '医嘱"' || r_Advice.医嘱内容 || '"已经执行或正在执行，不能作废。';
          Raise Err_Custom;
        End If;
        If Nvl(r_Rollmoney.费用执行, 0) In (1, 2) Then
          --1-完全执行;2-部份执行
          v_Error := '医嘱费用单据"' || r_Rollmoney.No || '"中的内容已经全部或部分执行，不能作废。';
          Raise Err_Custom;
        End If;
        If r_Rollmoney.费用执行 = 9 Then
          v_Error := '医嘱费用单据"' || r_Rollmoney.No || '"中的收费结算产生异常，不能作废。';
          Raise Err_Custom;
        End If;
        If (n_先作废后退药 = 0 or Not(r_Rollmoney.诊疗类别='E' And r_Rollmoney.操作类型 IN('2','3','4'))) Then
          If r_Rollmoney.记录性质 = 1 And r_Rollmoney.记录状态 <> 0 Then
            v_Error := '医嘱费用单据"' || r_Rollmoney.No || '"已经收费，不能作废。';
            Raise Err_Custom;
          End If;

          If Nvl(v_费用no, '空') <> r_Rollmoney.No Then
            If v_费用序号 Is Not Null And v_费用no Is Not Null Then
              v_费用序号 := Substr(v_费用序号, 2);
              If v_记录性质 = 1 Then
                Zl_门诊划价记录_Delete(v_费用no, v_费用序号);
              Elsif v_记录性质 = 2 Then
                Zl_门诊记帐记录_Delete(v_费用no, v_费用序号, v_人员编号, v_人员姓名);
              End If;
            End If;
            v_费用序号 := Null;
          End If;
          v_记录性质 := r_Rollmoney.记录性质;
          v_费用no   := r_Rollmoney.No;
          v_费用序号 := v_费用序号 || ',' || r_Rollmoney.序号;
        End If;
      End Loop;
      If v_费用序号 Is Not Null And v_费用no Is Not Null Then
        v_费用序号 := Substr(v_费用序号, 2);
        If v_记录性质 = 1 Then
          Zl_门诊划价记录_Delete(v_费用no, v_费用序号);
        Elsif v_记录性质 = 2 Then
          Zl_门诊记帐记录_Delete(v_费用no, v_费用序号, v_人员编号, v_人员姓名);
        End If;
      End If;

      --如果"门诊药嘱先作废后退药"，则对应的给药途径费用设置为未执行，以便退费
      If n_先作废后退药 = 1 Then
        Update 门诊费用记录
        Set 执行状态 = 0
        Where 执行状态 = 1 And 医嘱序号 = Id_In And Exists
         (Select 1
               From 病人医嘱记录 A, 诊疗项目目录 B
               Where a.诊疗项目id = b.Id And b.类别 = 'E' And b.操作类型 In ('2', '3', '4') And a.Id = Id_In);
      End If;

      --回退医嘱发送记录(及执行记录)
      Delete From 病人医嘱执行 Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = Id_In Or 相关id = Id_In);
      Delete From 病人医嘱发送 Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = Id_In Or 相关id = Id_In);

      --回退特殊医嘱的处理
      If r_Advice.诊疗类别 = 'Z' And Nvl(r_Advice.操作类型, '0') <> '0' And Nvl(r_Advice.婴儿, 0) = 0 Then
        If r_Advice.操作类型 = '1' And r_Advice.执行科室id Is Not Null Then
          --留观医嘱
          Select Count(*)
          Into v_Count
          From 病案主页
          Where 病人id = r_Advice.病人id And Nvl(主页id, 0) = 0 And 入院科室id = r_Advice.执行科室id And 病人性质 In (1, 2);
          If v_Count = 1 Then
            Zl_入院病案主页_Delete(r_Advice.病人id, 0);
          End If;
        Elsif r_Advice.操作类型 = '2' And r_Advice.执行科室id Is Not Null Then
          --住院医嘱
          Select Count(*)
          Into v_Count
          From 病案主页
          Where 病人id = r_Advice.病人id And Nvl(主页id, 0) = 0 And 入院科室id = r_Advice.执行科室id And Nvl(病人性质, 0) = 0;
          If v_Count = 1 Then
            Zl_入院病案主页_Delete(r_Advice.病人id, 0);
          End If;
        End If;
      End If;
    End If;
  End If;

  --删除过敏登记记录
  If r_Advice.诊疗类别 = 'E' And r_Advice.操作类型 = '1' Then
    --Update 病人医嘱记录 Set 皮试结果=Null Where ID=ID_IN; --保留最后的皮试结果
    --删除不过敏的记录，过敏记录保留，因为不管医嘱是否作废，病人对该药过敏
    For r_Test In (Select 操作时间 From 病人医嘱状态 Where 医嘱id = Id_In And 操作类型 = 10) Loop
      Delete From 病人过敏记录
      Where 病人id = r_Advice.病人id And 记录来源 = 2 And Nvl(主页id, 0) = Nvl(r_Advice.主页id, 0) And 记录时间 = r_Test.操作时间 And Nvl(结果,0) = 0;
    End Loop;
  End If;

  Close c_Advice;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱记录_作废;
/

--94604:陈刘,2016-03-29,体温单不能同步应用方式为1(单独使用)之外的护理项目值
CREATE OR REPLACE Procedure Zl_病人护理数据_Update
(
  文件id_In   In 病人护理数据.文件id%Type,
  发生时间_In In 病人护理数据.发生时间%Type,
  记录类型_In In 病人护理明细.记录类型%Type, --护理项目=1，签名记录=5，审签记录=15
  项目序号_In In 病人护理明细.项目序号%Type, --护理项目的序号，非护理项目固定为0
  记录内容_In In 病人护理明细.记录内容%Type := Null, --记录内容，如果内容为空，即清除以前的内容；37或38/37
  体温部位_In In 病人护理明细.体温部位%Type := Null,
  他人记录_In In Number := 1,
  数据来源_In In 病人护理明细.数据来源%Type := 0,
  审签_In     In Number := 0,
  操作员_In   In 病人护理数据.保存人%Type := Null,
  记录组号_In In 病人护理明细.记录组号%Type := Null, --适用分类汇总(一条数据对应多条相同项目的明细)
  相关序号_In In 病人护理明细.相关序号%Type := Null, --适用分类汇总(记录汇总项目关联的名称项目序号)
  未记说明_In In 病人护理明细.未记说明%Type := Null --入量导入存储医嘱ID:发送号
) Is
  Intins      Number(18);
  Int共用     Number(1);
  n_Newid     病人护理数据.Id%Type;
  n_Oldid     病人护理数据.Id%Type;
  n_行数      病人护理打印.行数%Type;
  n_Mutilbill Number(1);
  n_Synchro   Number(1);

  n_汇总类别     病人护理数据.汇总类别%Type;
  v_科室id       部门表.Id%Type;
  v_保存人       人员表.姓名%Type;
  v_记录人       人员表.姓名%Type;
  n_文件id       病人护理数据.文件id%Type;
  n_记录id       病人护理数据.Id%Type;
  n_明细id       病人护理明细.Id%Type;
  n_来源id       病人护理明细.来源id%Type;
  v_数据来源     病人护理明细.数据来源%Type;
  n_最高版本     病人护理明细.开始版本%Type;
  n_项目性质     护理记录项目.项目性质%Type;
  n_病人id       病人护理文件.病人id%Type;
  n_主页id       病人护理文件.主页id%Type;
  n_婴儿         病人护理文件.婴儿%Type;
  d_婴儿出院时间 病人医嘱记录.开始执行时间%Type;
  d_文件开始时间 病人护理文件.开始时间%Type;
  --提取该病人当前科室所有未结束的护理文件，且文件开始时间小于等于记录发生时间的文件列表供同步数据使用
  Cursor Cur_Fileformats Is
    Select a.Id As 格式id, b.Id As 文件id, a.保留, a.子类, b.婴儿
    From 病历文件列表 a, 病人护理文件 b, 病人护理文件 c, 病人护理数据 d
    Where a.种类 = 3 And a.保留 <> 1 And a.Id = b.格式id And b.Id <> c.Id And b.结束时间 Is Null And b.开始时间 <= d.发生时间 And
          (a.通用 = 1 Or (a.通用 = 2 And b.科室id = c.科室id)) And c.病人id = b.病人id And c.主页id = b.主页id And c.婴儿 = b.婴儿 And
          c.Id = d.文件id And d.Id = n_记录id And c.Id = 文件id_In
    Order By a.编号;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --取记录ID
  Int共用     := 0;
  n_记录id    := 0;
  n_Mutilbill := 0;
  If 操作员_In Is Null Then
    v_保存人 := Zl_Username;
  Else
    v_保存人 := 操作员_In;
  End If;

  --如果是对应多份护理文件值为1，表示需同步其它护理文件；否则不处理文件同步
  n_Mutilbill := Zl_To_Number(Zl_Getsysparameter('对应多份护理文件', 1255));

  Begin
    Select Id, 汇总类别
    Into n_记录id, n_汇总类别
    From 病人护理数据
    Where 文件id = 文件id_In And 发生时间 = 发生时间_In;
  Exception
    When Others Then
      n_记录id := 0;
  End;

  --检查是不是本人的记录
  ---------------------------------------------------------------------------------------------------------------------
  If 他人记录_In = 0 And n_记录id > 0 And 审签_In = 0 Then
    v_记录人 := '';
    Begin
      Select 记录人
      Into v_记录人
      From 病人护理明细
      Where 记录id = n_记录id And 项目序号 = 项目序号_In And Nvl(体温部位, 'TWBW') = Nvl(体温部位_In, 'TWBW') And
            Nvl(记录组号, 0) = Nvl(记录组号_In, 0) And 终止版本 Is Null;
    Exception
      When Others Then
        v_记录人 := '';
    End;
    If v_记录人 Is Not Null And v_记录人 <> v_保存人 Then
      v_Error := '你无权修改他人登记的护理数据！';
      Raise Err_Custom;
    End If;
  End If;

  --检查是否入科
  Select 病人id, 主页id, Nvl(婴儿, 0), 开始时间
  Into n_病人id, n_主页id, n_婴儿, d_文件开始时间
  From 病人护理文件
  Where Id = 文件id_In;
  d_婴儿出院时间 := Null;
  If n_婴儿 <> 0 Then
    Begin
      Select 开始执行时间
      Into d_婴儿出院时间
      From 病人医嘱记录 b, 诊疗项目目录 c
      Where b.诊疗项目id + 0 = c.Id And b.医嘱状态 = 8 And Nvl(b.婴儿, 0) <> 0 And c.类别 = 'Z' And
            Instr(',3,5,11,', ',' || c.操作类型 || ',', 1) > 0 And b.病人id = n_病人id And b.主页id = n_主页id And b.婴儿 = n_婴儿;
    Exception
      When Others Then
        d_婴儿出院时间 := Null;
    End;
  End If;
  If d_婴儿出院时间 Is Null Then
    v_科室id := 0;
    Begin
      Select a.科室id
      Into v_科室id
      From 病人变动记录 a, 病人护理文件 b
      Where a.科室id Is Not Null And a.病人id = b.病人id And a.主页id = b.主页id And b.Id = 文件id_In And
            (To_Date(To_Char(发生时间_In, 'YYYY-MM-DD HH24:MI') || '59', 'YYYY-MM-DD HH24:MI:SS') >= a.开始时间 And
            (To_Date(To_Char(发生时间_In, 'YYYY-MM-DD HH24:MI') || '00', 'YYYY-MM-DD HH24:MI:SS') < =
            Nvl(a.终止时间, Sysdate) Or a.终止时间 Is Null)) And Rownum < 2;
    Exception
      When Others Then
        v_科室id := 0;
    End;
    If v_科室id = 0 Then
      v_Error := '数据发生时间 ' || To_Char(发生时间_In, 'YYYY-MM-DD HH24:MI:SS') || ' 不在病人有效变动时间范围内，不能操作！';
      Raise Err_Custom;
    End If;
  Else
    If 发生时间_In < d_文件开始时间 Or 发生时间_In > d_婴儿出院时间 Then
      v_Error := '数据发生时间 ' || To_Char(发生时间_In, 'YYYY-MM-DD HH24:MI:SS') || ' 不在病人有效变动时间范围内，不能操作！';
      Raise Err_Custom;
    End If;
  End If;

  --如果数据来源<>0则退出
  n_来源id := 0;
  If n_记录id > 0 Then
    Begin
      Select 数据来源, Nvl(来源id, 0)
      Into v_数据来源, n_来源id
      From 病人护理明细
      Where 记录id = n_记录id And Nvl(项目序号, 0) = 项目序号_In And Nvl(体温部位, 'TWBW') = Nvl(体温部位_In, 'TWBW') And
            Nvl(记录组号, 0) = Nvl(记录组号_In, 0);
    Exception
      When Others Then
        v_数据来源 := 0;
    End;
    If v_数据来源 > 0 And n_来源id > 0 Then
      Return;
    End If;
  End If;

  --取最高版本
  Select Nvl(Max(Nvl(a.开始版本, 1)), 0) + 1, Count(b.Id)
  Into n_最高版本, Intins
  From 病人护理明细 a, 病人护理数据 b
  Where b.Id = n_记录id And a.记录id = b.Id And Mod(a.记录类型, 10) = 5;

  --目前已经签名的数据不能修改，只有在审签模式下进行修改，即审签_In=1
  If 审签_In <> 1 And Intins > 0 Then
    v_Error := '发生时间 ' || To_Char(发生时间_In, 'YYYY-MM-DD HH24:MI:SS') || ' 所对应的数据已经签名或审签，不能继续操作！' || Chr(13) || Chr(10) ||
               '这可能是由于网络并发操作引起的，请刷新后再试！';
    Raise Err_Custom;
  End If;
  Intins := 0;

  --无内容时,要清除数据（审签回退时会自动清除审签过程中修改的数据，所以此处只需考虑普签即可）
  If 记录内容_In Is Null Then
    Begin
      Select Id
      Into n_明细id
      From 病人护理明细
      Where 记录id = n_记录id And Nvl(项目序号, 0) = 项目序号_In And Nvl(体温部位, 'TWBW') = Nvl(体温部位_In, 'TWBW') And
            Nvl(记录组号, 0) = Nvl(记录组号_In, 0) And 终止版本 Is Null;
    Exception
      --无数据退出
      When Others Then
        Return;
    End;

    --查找除了本条要删除的数据，是否还存其他有效的数据，如果存在只删除本条数据，否则删除此发生时间对应的所有数据。
    Select Count(Id)
    Into Intins
    From 病人护理明细
    Where 记录id = n_记录id And Mod(记录类型, 10) <> 5 And 终止版本 Is Null And Id <> n_明细id;
    If Intins = 0 Then
      Delete From 病人护理明细 Where 记录id = n_记录id;
    Else
      Delete From 病人护理明细 Where Id = n_明细id;
    End If;

    Delete From 病人护理数据 a
    Where a.Id = n_记录id And Not Exists (Select 1 From 病人护理明细 b Where b.记录id = a.Id);

    --如果是删除签名后修改产生的最后一条数据,则应将签名记录的终止版本清为空
    Begin
      Select 1
      Into Intins
      From 病人护理明细
      Where 开始版本 = n_最高版本 And 终止版本 Is Null And 记录类型 = 1 And 记录id = n_记录id;
    Exception
      When Others Then
        Intins := 0;
    End;
    If Intins = 0 Then
      Update 病人护理明细 Set 终止版本 = Null Where 记录类型 = 5 And 开始版本 = n_最高版本 - 1 And 记录id = n_记录id;
    End If;
    If Nvl(n_汇总类别, 0) <> 0 Then
      Return;
    End If;

    --############
    --清除共用数据
    --############
    For Rsdel In (Select Distinct 记录id From 病人护理明细 Where 来源id = n_明细id) Loop

      Delete 病人护理明细 Where 来源id = n_明细id And 记录id = Rsdel.记录id;
      --删除对应的打印数据
      Begin
        Select Count(*) Into Intins From 病人护理明细 Where 记录id = Rsdel.记录id;
      Exception
        When Others Then
          Intins := 0;
      End;
      If Intins = 0 Then
        --提取清除数据对应的文件ID
        Begin
          Select b.Id, a.保留
          Into n_文件id, Intins
          From 病历文件列表 a, 病人护理文件 b, 病人护理数据 c
          Where a.Id = b.格式id And b.Id = c.文件id And c.Id = Rsdel.记录id;
        Exception
          When Others Then
            n_文件id := 0;
        End;
        Delete 病人护理数据 Where Id = Rsdel.记录id;
        If Intins <> -1 Then
          Zl_病人护理打印_Update(n_文件id, 发生时间_In, 1, 1);
        End If;
      End If;
    End Loop;
  Else
    --检查录入的项目是否属于该记录单
    Begin
      Select 1
      Into Intins
      From (Select b.项目序号
             From 病历文件结构 a, 护理记录项目 b
             Where a.要素名称 = b.项目名称 And b.项目序号 = 项目序号_In And
                   父id = (Select b.Id
                          From 病人护理文件 a, 病历文件结构 b
                          Where a.Id = 文件id_In And a.格式id = b.文件id And b.父id Is Null And b.对象序号 = 4)
             Union
             Select 项目序号
             From 护理记录项目
             Where 项目性质 = 2 And 项目序号 = 项目序号_In);
    Exception
      When Others Then
        Intins := 0;
    End;
    If Intins = 0 Then
      Return;
    End If;
    If n_记录id = 0 Then
      Select 病人护理数据_Id.Nextval Into n_记录id From Dual;

      Insert Into 病人护理数据
        (Id, 文件id, 发生时间, 最后版本, 保存人, 保存时间)
      Values
        (n_记录id, 文件id_In, 发生时间_In, n_最高版本, v_保存人, Sysdate);
    End If;

    --插入本次登记的病人护理明细
    Update 病人护理明细
    Set 记录内容 = 记录内容_In, 数据来源 = 数据来源_In, 未记说明 = 未记说明_In, 记录人 = v_保存人, 记录时间 = Sysdate
    Where 记录id = n_记录id And 项目序号 = 项目序号_In And Nvl(体温部位, 'TWBW') = Nvl(体温部位_In, 'TWBW') And
          Nvl(记录组号, 0) = Nvl(记录组号_In, 0) And 开始版本 = n_最高版本 And 终止版本 Is Null;
    If Sql%Rowcount = 0 Then
      Select 病人护理明细_Id.Nextval Into n_明细id From Dual;
      Insert Into 病人护理明细
        (Id, 记录id, 记录类型, 项目分组, 项目id, 相关序号, 项目序号, 项目名称, 项目类型, 记录内容, 项目单位, 记录标记, 记录组号, 体温部位, 数据来源, 共用, 未记说明, 开始版本, 终止版本,
         记录人, 记录时间)
        Select n_明细id, n_记录id, 记录类型_In, a.分组名, a.项目id, 相关序号_In, a.项目序号, Upper(a.项目名称), a.项目类型, 记录内容_In, a.项目单位, 0,
               记录组号_In, 体温部位_In, 数据来源_In, Nvl(b.共用, 0), 未记说明_In, n_最高版本, Null, v_保存人, Sysdate
        From 护理记录项目 a, 病人护理明细 b
        Where a.项目序号 = b.项目序号(+) And b.终止版本(+) Is Null And b.记录id(+) = n_记录id And a.项目序号 = 项目序号_In And Rownum < 2;
    End If;
    Select Id
    Into n_明细id
    From 病人护理明细
    Where 记录id = n_记录id And 项目序号 = 项目序号_In And Nvl(体温部位, 'TWBW') = Nvl(体温部位_In, 'TWBW') And
          Nvl(记录组号, 0) = Nvl(记录组号_In, 0) And 开始版本 = n_最高版本 And 终止版本 Is Null;
    --填写历史数据及签名记录的终止版本
    Update 病人护理明细
    Set 终止版本 = n_最高版本
    Where 记录id = n_记录id And ((Mod(记录类型, 10) <> 5 And 项目序号 = 项目序号_In And Nvl(体温部位, 'TWBW') = Nvl(体温部位_In, 'TWBW') And
          Nvl(记录组号, 0) = Nvl(记录组号_In, 0)) Or 记录类型 = Decode(审签_In, 1, 15, 5)) And 开始版本 <= n_最高版本 - 1 And 终止版本 Is Null;

    --如果是未签名数据，最后修改操作员做为该记录的保存人更新
    If n_最高版本 = 1 Then
      Update 病人护理数据 Set 保存人 = v_保存人, 保存时间 = Sysdate Where Id = n_记录id;
    End If;

    If Nvl(n_汇总类别, 0) <> 0 Then
      Return;
    End If;

    --############
    --同步共用数据
    --############
    --1\先处理体温单（一个病人始终只存在一份有效的体温单文件）
    --如果体温表存在相同发生时间的数据，使用它的ID
    --CL,2015-12-30,记录单同步文字项目到体温单
    For Row_Format In Cur_Fileformats Loop
      If Row_Format.保留 = -1 Then
        If Row_Format.子类 = '1' Then
          Begin
            Select 1, h.项目性质
            Into Intins, n_项目性质
            From (Select To_Char(f.项目序号) As 序号, g.项目性质
                   From 体温记录项目 f, 护理记录项目 g
                   Where f.项目序号 = g.项目序号 And g.项目性质 = 2 And
                         (g.适用科室 = 1 Or
                         (g.适用科室 = 2 And Exists
                          (Select 1 From 护理适用科室 d Where g.项目序号 = d.项目序号 And d.科室id = v_科室id))) And Nvl(g.应用方式, 0) <> 0 And
                         (Nvl(g.适用病人, 0) = 0 Or Nvl(g.适用病人, 0) = Decode(Nvl(Row_Format.婴儿, 0), 0, 1, 2))
                   Union All
                   Select b.内容文本 As 序号, 1 As 项目性质
                   From 病历文件结构 a, 病历文件结构 b
                   Where a.文件id = Row_Format.格式id And a.父id Is Null And a.对象序号 In (2, 3) And b.父id = a.Id) h
            Where Instr(',' || h.序号 || ',', ',' || 项目序号_In || ',', 1) > 0;
          Exception
            When Others Then
              Intins := 0;
          End;
        Else
          Begin
            Select 1, g.项目性质
            Into Intins, n_项目性质
            From 体温记录项目 f, 护理记录项目 g
            Where f.项目序号 = g.项目序号 And Nvl(g.应用方式, 0) <> 0 And g.护理等级 >= 0 And
                  (Nvl(g.适用病人, 0) = 0 Or Nvl(g.适用病人, 0) = Decode(Nvl(Row_Format.婴儿, 0), 0, 1, 2)) And f.项目序号 = 项目序号_In And
                  (g.适用科室 = 1 Or (g.适用科室 = 2 And Exists
                   (Select 1 From 护理适用科室 d Where g.项目序号 = d.项目序号 And d.科室id = v_科室id)));
          Exception
            When Others Then
              Intins := 0;
          End;
        End If;

        If Intins > 0 Then
          --LPF,2013-01-23,检查此项目是否需要进行同步(对于以前已经同步过的数据，为了保证记录单和体温单数据一直将不根据此函数判断。)
          n_Synchro := Zl_Temperatureprogram(文件id_In, v_科室id, 项目序号_In, 发生时间_In);
          Begin
            Select b.Id
            Into n_Newid
            From 病人护理文件 a, 病人护理数据 b
            Where a.Id = Row_Format.文件id And b.文件id = a.Id And b.发生时间 = 发生时间_In;
          Exception
            When Others Then
              n_Newid := 0;
          End;
          n_Oldid := n_Newid;
          If n_Newid = 0 And n_Synchro = 1 Then
            Select 病人护理数据_Id.Nextval Into n_Newid From Dual;
            --产生体温单主记录
            Insert Into 病人护理数据
              (Id, 文件id, 保存人, 保存时间, 发生时间, 最后版本)
            Values
              (n_Newid, Row_Format.文件id, v_保存人, Sysdate, 发生时间_In, 1);
          End If;

          If n_Newid > 0 Then
            --插入未同步的体温单数据(仍然要联接多表查询)
            Select Count(*)
            Into v_数据来源
            From 病人护理明细
            Where 记录id = n_Newid And 项目序号 = 项目序号_In And
                  Decode(n_项目性质, 2, Nvl(体温部位, '无'), Nvl(体温部位_In, '无')) = Nvl(体温部位_In, '无');
            If v_数据来源 = 0 Then
              --说明在同步开始已经进行过检查
              If n_Synchro = 1 Then
                --没有检查此项目是否需要同步
                Insert Into 病人护理明细
                  (Id, 记录id, 记录类型, 项目分组, 项目id, 项目序号, 项目名称, 项目类型, 记录内容, 项目单位, 记录标记, 体温部位, 数据来源, 来源id, 开始版本, 终止版本, 记录人,
                   记录时间, 记录组号)
                  Select 病人护理明细_Id.Nextval, n_Newid, b.记录类型, b.项目分组, b.项目id, b.项目序号, b.项目名称, b.项目类型, b.记录内容, b.项目单位,
                         b.记录标记, b.体温部位, 1, b.Id, 1, Null, b.记录人, Sysdate, 1
                  From (Select 项目序号_In As 项目序号, Nvl(体温部位_In, '无') As 体温部位
                         From Dual
                         Minus
                         Select f.项目序号, Decode(Nvl(f.项目性质, 1), 2, Nvl(体温部位, '无'), Nvl(体温部位_In, '无'))
                         From 病人护理明细 e, 护理记录项目 f
                         Where e.记录id = n_Newid And e.项目序号 = f.项目序号) a, 病人护理明细 b
                  Where a.项目序号 = b.项目序号 And b.记录id = n_记录id And b.Id = n_明细id;
                If Sql%Rowcount > 0 Then
                  Int共用 := 1;
                End If;
              End If;
            Else
              Update 病人护理明细
              Set 记录内容 = 记录内容_In, 来源id = n_明细id
              Where 记录id = n_Newid And 项目序号 = 项目序号_In And
                    Decode(n_项目性质, 2, Nvl(体温部位, '无'), Nvl(体温部位_In, '无')) = Nvl(体温部位_In, '无') And 数据来源 > 0;
              If Sql%Rowcount > 0 Then
                Int共用 := 1;
              End If;
            End If;
          End If;
        End If;
        --2\再循环处理记录单
      Else
        If n_Mutilbill = 1 Then
          --提取记录单与当前记录单存在重叠的且有数据的固定项目
          Select Count(*)
          Into Intins
          From (Select b.项目序号
                 From 病历文件结构 a, 护理记录项目 b
                 Where a.要素名称 = b.项目名称 And b.项目表示 In (0, 4, 5) And
                       父id =
                       (Select Id From 病历文件结构 Where 文件id = Row_Format.格式id And 父id Is Null And 对象序号 = 4)
                 Intersect
                 Select b.项目序号
                 From 病历文件结构 a, 护理记录项目 b, 病人护理文件 c, 病人护理数据 d, 病人护理明细 g
                 Where c.Id = d.文件id And a.文件id = c.格式id And d.Id = g.记录id And d.Id = n_记录id And g.Id = n_明细id And
                       b.项目序号 = g.项目序号 And b.项目表示 In (0, 4, 5) And g.记录类型 = 1 And a.要素名称 = b.项目名称 And
                       a.父id = (Select Id From 病历文件结构 e Where e.文件id = c.格式id And 父id Is Null And 对象序号 = 4));

          If Intins > 0 Then
            n_Newid := 0;
            --可能指定文件已经存在相同发生时间的数据，直接用它的ID即可
            Begin
              Select c.Id
              Into n_Newid
              From 病人护理数据 c
              Where c.文件id = Row_Format.文件id And c.发生时间 = 发生时间_In;
            Exception
              When Others Then
                n_Newid := 0;
            End;

            If n_Newid = 0 Then
              --产生记录单主记录
              Select 病人护理数据_Id.Nextval Into n_Newid From Dual;

              Insert Into 病人护理数据
                (Id, 文件id, 保存人, 保存时间, 发生时间, 最后版本)
                Select n_Newid, Row_Format.文件id, c.保存人, c.保存时间, c.发生时间, 1
                From 病人护理数据 c
                Where c.Id = n_记录id;
            End If;

            If n_Newid > 0 Then
              --插入未同步的记录单数据
              Select Count(*) Into v_数据来源 From 病人护理明细 Where 记录id = n_Newid And 项目序号 = 项目序号_In;
              If v_数据来源 = 0 Then
                Insert Into 病人护理明细
                  (Id, 记录id, 记录类型, 项目分组, 项目id, 项目序号, 项目名称, 项目类型, 记录内容, 项目单位, 记录标记, 体温部位, 数据来源, 来源id, 未记说明, 开始版本, 终止版本,
                   记录人, 记录时间)
                  Select 病人护理明细_Id.Nextval, n_Newid, b.记录类型, b.项目分组, b.项目id, b.项目序号, b.项目名称, b.项目类型, b.记录内容, b.项目单位,
                         b.记录标记, b.体温部位, 1, b.Id, b.未记说明, 1, Null, b.记录人, Sysdate
                  From (Select b.项目序号
                         From 病历文件结构 a, 护理记录项目 b
                         Where a.要素名称 = b.项目名称 And b.项目表示 In (0, 4, 5) And
                               父id = (Select Id
                                      From 病历文件结构
                                      Where 文件id = Row_Format.格式id And 父id Is Null And 对象序号 = 4)
                         Intersect
                         Select b.项目序号
                         From 病历文件结构 a, 护理记录项目 b, 病人护理文件 c, 病人护理数据 d, 病人护理明细 g
                         Where c.Id = d.文件id And a.文件id = c.格式id And d.Id = g.记录id And d.Id = n_记录id And g.Id = n_明细id And
                               b.项目序号 = g.项目序号 And b.项目表示 In (0, 4, 5) And g.记录类型 = 1 And a.要素名称 = b.项目名称 And
                               a.父id =
                               (Select Id From 病历文件结构 e Where e.文件id = c.格式id And 父id Is Null And 对象序号 = 4)) a, 病人护理明细 b
                  Where a.项目序号 = b.项目序号 And b.记录id = n_记录id And b.Id = n_明细id;
                If Sql%Rowcount > 0 Then
                  Int共用 := 1;
                  --原行数不要动
                  Begin
                    Select 行数 Into n_行数 From 病人护理打印 Where 文件id = Row_Format.文件id And 记录id = n_Newid;
                  Exception
                    When Others Then
                      n_行数 := 1;
                  End;
                  Zl_病人护理打印_Update(Row_Format.文件id, 发生时间_In, n_行数, 0);
                End If;
              Else
                Update 病人护理明细
                Set 记录内容 = 记录内容_In, 未记说明 = 未记说明_In, 来源id = n_明细id
                Where 记录id = n_Newid And 项目序号 = 项目序号_In And 数据来源 > 0;
                If Sql%Rowcount > 0 Then
                  Int共用 := 1;
                End If;
              End If;
            End If;
          End If;
        End If;
      End If;
    End Loop;

    If Int共用 = 1 Then
      Update 病人护理明细 Set 共用 = 1 Where Id = n_明细id;
      --将历史数据的共用标志设置为NULL
      Update 病人护理明细 Set 共用 = Null Where 记录id = n_记录id And 项目序号 = 项目序号_In And Id <> n_明细id;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人护理数据_Update;
/

--94427:刘尔旋,2016-03-29,医嘱发送生成条码接口
--94337:刘尔旋,2016-03-22,是否持卡消费
Create Or Replace Procedure Zl_医疗卡类别_Update
(
  Id_In             In 医疗卡类别.Id%Type,
  编码_In           In 医疗卡类别.编码%Type,
  名称_In           In 医疗卡类别.名称%Type,
  短名_In           In 医疗卡类别.短名%Type,
  前缀文本_In       In 医疗卡类别.前缀文本%Type,
  卡号长度_In       In 医疗卡类别.卡号长度%Type,
  缺省标志_In       In 医疗卡类别.缺省标志%Type,
  是否固定_In       In 医疗卡类别.是否固定%Type,
  是否严格控制_In   In 医疗卡类别.是否严格控制%Type,
  是否自制_In       In 医疗卡类别.是否自制%Type,
  是否存在帐户_In   In 医疗卡类别.是否存在帐户%Type,
  是否全退_In       In 医疗卡类别.是否全退%Type,
  部件_In           In 医疗卡类别.部件%Type,
  备注_In           In 医疗卡类别.备注%Type,
  特定项目_In       In 医疗卡类别.特定项目%Type,
  收费细目id_In     In 收费项目目录.Id%Type,
  结算方式_In       In 医疗卡类别.结算方式%Type,
  是否启用_In       In 医疗卡类别.是否启用%Type,
  卡号密文_In       In 医疗卡类别.卡号密文%Type,
  是否重复使用_In   In 医疗卡类别.是否重复使用%Type,
  密码长度_In       In 医疗卡类别.密码长度%Type,
  密码长度限制_In   In 医疗卡类别.密码长度限制%Type,
  密码规则_In       In 医疗卡类别.密码规则%Type,
  是否退现_In       In 医疗卡类别.是否退现%Type,
  操作方式_In       In Integer := 0,
  是否模糊查找_In   In 医疗卡类别.是否模糊查找%Type := 0,
  密码输入限制_In   In 医疗卡类别.密码输入限制%Type := 0,
  是否缺省密码_In   In 医疗卡类别.是否缺省密码%Type := 0,
  是否制卡_In       In 医疗卡类别.是否制卡%Type := 0,
  是否发卡_In       In 医疗卡类别.是否发卡%Type := 0,
  是否写卡_In       In 医疗卡类别.是否写卡%Type := 0,
  险类_In           In 医疗卡类别.险类%Type := 0,
  发卡性质_In       In 医疗卡类别.发卡性质%Type := 0,
  是否转帐及代扣_In In 医疗卡类别.是否转帐及代扣%Type := 0,
  读卡性质_In       In 医疗卡类别.读卡性质%Type := '1000',
  键盘控制方式_In   In 医疗卡类别.键盘控制方式%Type := 0,
  是否持卡消费_In   In 医疗卡类别.是否持卡消费%Type := 0,
  发送调用接口_In   In 医疗卡类别.发送调用接口%Type := 0
) Is
  v_Err_Msg Varchar2(200);
  Err_Item Exception;
Begin
  If Nvl(是否自制_In, 0) = 1 And Nvl(是否存在帐户_In, 0) = 1 Then
    v_Err_Msg := '[ZLSOFT]是否存在帐户只有非自制卡才会存在,请检查![ZLSOFT]';
    Raise Err_Item;
  End If;
  If Nvl(是否自制_In, 0) = 0 And Nvl(是否存在帐户_In, 0) = 1 And 结算方式_In Is Null Then
    v_Err_Msg := '[ZLSOFT]第三方机构的卡结算，必须要设置结算方式,请检查![ZLSOFT]';
    Raise Err_Item;
  End If;
  If Nvl(是否自制_In, 0) = 1 And 特定项目_In Is Null Then
    v_Err_Msg := '[ZLSOFT]特定项目必须输入,请检查![ZLSOFT]';
    Raise Err_Item;
  End If;

  If 操作方式_In = 0 Then
    Insert Into 医疗卡类别
      (ID, 编码, 名称, 短名, 前缀文本, 卡号长度, 缺省标志, 是否固定, 是否严格控制, 是否自制, 是否存在帐户, 是否全退, 部件, 备注, 特定项目, 结算方式, 是否启用, 卡号密文, 是否重复使用, 密码长度,
       密码长度限制, 密码规则, 是否退现, 是否模糊查找, 密码输入限制, 是否缺省密码, 是否制卡, 是否发卡, 是否写卡, 险类, 发卡性质, 是否转帐及代扣, 读卡性质, 键盘控制方式, 是否持卡消费, 发送调用接口)
    Values
      (Id_In, 编码_In, 名称_In, 短名_In, 前缀文本_In, 卡号长度_In, 缺省标志_In, 是否固定_In, 是否严格控制_In, 是否自制_In, 是否存在帐户_In, 是否全退_In, 部件_In,
       备注_In, 特定项目_In, 结算方式_In, 是否启用_In, 卡号密文_In, 是否重复使用_In, 密码长度_In, 密码长度限制_In, 密码规则_In, 是否退现_In, 是否模糊查找_In, 密码输入限制_In,
       是否缺省密码_In, 是否制卡_In, 是否发卡_In, 是否写卡_In, 险类_In, 发卡性质_In, 是否转帐及代扣_In, 读卡性质_In, 键盘控制方式_In, 是否持卡消费_In, 发送调用接口_In);
  
  Else
  
    Delete 收费特定项目 Where 特定项目 = (Select Max(特定项目) From 医疗卡类别 Where ID = Id_In);
  
    Update 医疗卡类别
    Set 编码 = 编码_In, 名称 = 名称_In, 短名 = 短名_In, 前缀文本 = 前缀文本_In, 卡号长度 = 卡号长度_In, 缺省标志 = 缺省标志_In, 是否严格控制 = 是否严格控制_In,
        是否自制 = 是否自制_In, 是否存在帐户 = 是否存在帐户_In, 是否全退 = 是否全退_In, 部件 = 部件_In, 备注 = 备注_In, 特定项目 = 特定项目_In, 结算方式 = 结算方式_In,
        是否启用 = 是否启用_In, 卡号密文 = 卡号密文_In, 是否重复使用 = 是否重复使用_In, 密码长度 = 密码长度_In, 密码长度限制 = 密码长度限制_In, 密码规则 = 密码规则_In,
        是否退现 = 是否退现_In, 是否模糊查找 = 是否模糊查找_In, 密码输入限制 = 密码输入限制_In, 是否缺省密码 = 是否缺省密码_In, 是否制卡 = 是否制卡_In, 是否发卡 = 是否发卡_In,
        是否写卡 = 是否写卡_In, 险类 = 险类_In, 发卡性质 = 发卡性质_In, 是否转帐及代扣 = 是否转帐及代扣_In, 读卡性质 = 读卡性质_In, 键盘控制方式 = 键盘控制方式_In,
        是否持卡消费 = 是否持卡消费_In, 发送调用接口 = 发送调用接口_In
    Where ID = Id_In;
    If Nvl(缺省标志_In, 0) = 1 Then
      Update 医疗卡类别 Set 缺省标志 = 0 Where ID <> Id_In;
    End If;
  
  End If;
  If Not 特定项目_In Is Null And Nvl(收费细目id_In, 0) <> 0 Then
    Insert Into 收费特定项目 (特定项目, 收费细目id) Values (特定项目_In, 收费细目id_In);
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_医疗卡类别_Update;
/

--93917:许华峰,2016-03-20,与RIS的数据交换接口脚本
Create Or Replace Function Zlpub_Pacs_获取提纲内容
(
  医嘱id_In   In 病人医嘱报告.医嘱id%Type,
  报告提纲_In In 电子病历内容.内容文本%Type
) Return Varchar2 Is

  v_Result        Varchar2(4000);
  v_Singleresult  Varchar2(4000);
  v_Reportcontent 影像报告记录.报告内容%Type;
  n_Count         Number(2);

  Cursor Cur_Report_Contents Is
    Select 报告内容 From 影像报告记录 Where 医嘱id = 医嘱id_In;

Begin
  v_Result       := '';
  v_Singleresult := '';

  Select Count(1) Into n_Count From 影像报告记录 Where 医嘱id = 医嘱id_In;

  If n_Count > 0 Then
    For Row_Report_Contents In Cur_Report_Contents Loop
      v_Reportcontent := Row_Report_Contents.报告内容;
      Select Zlpub_Pacs_取提纲内容byxml(v_Reportcontent, 报告提纲_In) Into v_Singleresult From Dual;
      If v_Result Is Null And Not v_Singleresult Is Null Then
        v_Result := v_Singleresult;
      Elsif Not v_Singleresult Is Null Then
        v_Result := v_Result || ';' || v_Singleresult;
      End If;
    End Loop;
    Return v_Result;
  Else
    Select Count(1)
    Into n_Count
    From 电子病历内容 A, 电子病历内容 B, 病人医嘱报告 C
    Where a.对象类型 = 1 And a.Id = b.父id And b.对象类型 = 2 And b.开始版 = 0 And a.文件id = c.病历id And c.医嘱id = 医嘱id_In And
          a.内容文本 = 报告提纲_In;
  
    If n_Count > 0 Then
      Select b.内容文本
      Into v_Result
      From 电子病历内容 A, 电子病历内容 B, 病人医嘱报告 C
      Where a.对象类型 = 1 And a.Id = b.父id And b.对象类型 = 2 And b.开始版 = 0 And a.文件id = c.病历id And c.医嘱id = 医嘱id_In And
            a.内容文本 = 报告提纲_In;
    Else
      Select b.内容文本
      Into v_Result
      From 电子病历内容 A, 电子病历内容 B, 病人医嘱报告 C
      Where a.对象类型 = 3 And a.Id = b.父id And b.对象类型 = 2 And b.终止版 = 0 And a.文件id = c.病历id And c.医嘱id = 医嘱id_In And
            a.内容文本 = 报告提纲_In;
    End If;
  
    Return v_Result;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zlpub_Pacs_获取提纲内容;
/

--94241:陈刘,2016-03-22,删除打印记录时,如果明细数据还存在,则不删除
Create Or Replace Procedure Zl_病人护理打印_Update
(
  文件id_In   In 病人护理打印.文件id%Type,
  发生时间_In In 病人护理打印.发生时间%Type,
  行数_In     In 病人护理打印.行数%Type,
  删除_In     Number := 0
) Is
  n_Actives   Number;
  n_Rows      Number; --0-新增,>0表示修改 
  n_Startpage Number; --开始页 
  n_Startrow  Number; --开始行 
  n_Endpage   Number; --结束页 
  n_Endrow    Number; --结束行 
  n_Count     Number; --发生时间之后的数据条数 
  n_Pagerows  Number; --每页有效数据行 
  n_Del       Number;
  n_行数      病人护理打印.行数%Type;
  n_Firstdata Number; --是否是录入的第一条数据 
  n_记录id    病人护理数据.Id%Type;
  n_记录oldid 病人护理打印.记录id%Type;
  n_格式id    病人护理文件.格式id%Type;
  d_发生时间  病人护理打印.发生时间%Type;
  v_Username  人员表.姓名%Type;

  Err_Item Exception;
  v_Err_Msg Varchar2(1000);
  v_Print   Varchar2(800);
Begin
  n_Del      := 删除_In;
  n_行数     := 行数_In;
  v_Username := Zl_Username;
  Select 格式id Into n_格式id From 病人护理文件 Where ID = 文件id_In;

  If n_行数 = 0 Then
    v_Err_Msg := '有效数据行不能等于零，请记录本次错误的操作过程！';
    Raise Err_Item;
  End If;

  Begin
    Select 记录id, 行数, 开始页号, 开始行号, 结束页号, 结束行号
    Into n_记录oldid, n_Rows, n_Startpage, n_Startrow, n_Endpage, n_Endrow
    From 病人护理打印
    Where 文件id = 文件id_In And 发生时间 = 发生时间_In;
  Exception
    When Others Then
      n_Rows := 0;
  End;

  --提取该护理文件格式每页有效数据行（不加错误处理） 
  Select To_Number(内容文本)
  Into n_Pagerows
  From 病历文件结构
  Where 对象属性 = '有效数据行' And 父id = (Select ID From 病历文件结构 Where 文件id = n_格式id And 对象序号 = 1 And 父id Is Null);

  Select Count(*) Into n_Count From 病人护理数据 Where 文件id = 文件id_In And 发生时间 = 发生时间_In;

  --修改数据时,也可能删除 
  If n_Del = 0 Then
    Begin
      If n_Count = 0 Then
        n_Del := 1;
      End If;
      If n_Count > 1 Then
        v_Err_Msg := '在发生时间【' || To_Char(发生时间_In, 'YYYY-MM-DD hh24:mi:ss') || '】已经存在相应的数据，您不能再次录入或修改数据的时间为此发生时间！';
        Raise Err_Item;
      End If;
    End;
  Elsif n_Del = 1 And n_Count > 0 Then
    n_Del  := 0;
    n_行数 := 1;
  End If;

  n_Firstdata := 0;
  If n_Del = 1 Then
    Delete 病人护理打印 Where 文件id = 文件id_In And 发生时间 = 发生时间_In;
    n_Rows := n_Rows * -1;
  Else
    Select ID Into n_记录id From 病人护理数据 Where 文件id = 文件id_In And 发生时间 = 发生时间_In;
  
    If n_Rows = 0 Then
      --根据现有打印数据及将要插入的数据，计算出开始页号，行号，结束页号，行号 
      Select Min(发生时间) Into d_发生时间 From 病人护理打印 Where 文件id = 文件id_In And 发生时间 > 发生时间_In;
      If d_发生时间 Is Null Then
        Select Max(发生时间) Into d_发生时间 From 病人护理打印 Where 文件id = 文件id_In And 发生时间 < 发生时间_In;
        If d_发生时间 Is Null Then
          n_Startpage := 1;
          n_Startrow  := 1;
          n_Firstdata := 1;
        Else
          Select 结束页号, 结束行号
          Into n_Startpage, n_Startrow
          From 病人护理打印
          Where 文件id = 文件id_In And 发生时间 = d_发生时间;
          n_Startrow := n_Startrow + 1;
        End If;
      Else
        Select 开始页号, 开始行号
        Into n_Startpage, n_Startrow
        From 病人护理打印
        Where 文件id = 文件id_In And 发生时间 = d_发生时间;
      End If;
    
      --校正页号,行号 
      If n_Startrow > n_Pagerows Then
        n_Startpage := n_Startpage + 1;
        n_Startrow  := n_Startrow - n_Pagerows;
      
        --翻页时，自动依据当前页的设置产生新页的活动项目设置 
        Begin
          Select 1 Into n_Actives From 病人护理活动项目 Where 文件id = 文件id_In And 页号 = n_Startpage And Rownum < 2;
        Exception
          When Others Then
            n_Actives := 0;
        End;
      
        If n_Actives = 0 Then
          Insert Into 病人护理活动项目
            (文件id, 页号, 列号, 列头名称, 序号, 项目序号, 部位, 操作员, 操作时间)
            Select 文件id, n_Startpage, 列号, 列头名称, 序号, 项目序号, 部位, v_Username, Sysdate
            From 病人护理活动项目
            Where 文件id = 文件id_In And 页号 = n_Startpage - 1;
        End If;
      End If;
      n_Endpage := n_Startpage;
      n_Endrow  := n_Startrow + n_行数 - 1;
      If n_Endrow > n_Pagerows Then
        --不考虑输入的数据超过一页的情况 
        n_Endpage := n_Endpage + 1;
        n_Endrow  := n_Endrow - n_Pagerows;
      
        --翻页时，自动依据当前页的设置产生新页的活动项目设置 
        Begin
          Select 1 Into n_Actives From 病人护理活动项目 Where 文件id = 文件id_In And 页号 = n_Endpage And Rownum < 2;
        Exception
          When Others Then
            n_Actives := 0;
        End;
      
        If n_Actives = 0 Then
          Insert Into 病人护理活动项目
            (文件id, 页号, 列号, 列头名称, 序号, 项目序号, 部位, 操作员, 操作时间)
            Select 文件id, n_Endpage, 列号, 列头名称, 序号, 项目序号, 部位, v_Username, Sysdate
            From 病人护理活动项目
            Where 文件id = 文件id_In And 页号 = n_Endpage - 1;
        End If;
      End If;
      --不允许录入跨两页的数据 
      If n_Endrow > n_Pagerows Or n_Endpage - n_Startpage > 1 Then
        v_Err_Msg := '您在发生时间【' || To_Char(发生时间_In, 'YYYY-MM-DD hh24:mi:ss') || '】录入的数据存在错误，录入的数据不能连续跨一页以上！';
        Raise Err_Item;
      End If;
    
      Insert Into 病人护理打印
        (记录id, 文件id, 发生时间, 行数, 开始页号, 开始行号, 结束页号, 结束行号)
      Values
        (n_记录id, 文件id_In, 发生时间_In, n_行数, n_Startpage, n_Startrow, n_Endpage, n_Endrow);
      --新插入的数据的行数就是差值 
      n_Rows := n_行数;
    Else
      --计算与原行数的差值 
      n_Rows := n_行数 - n_Rows;
      --校正页号,行号 
      n_Endrow := n_Endrow + n_Rows;
      If n_Endrow <= 0 Then
        n_Endrow  := n_Pagerows + n_Endrow;
        n_Endpage := n_Endpage - 1;
      End If;
      If n_Endrow > n_Pagerows Then
        --不考虑输入的数据超过一页的情况 
        n_Endpage := n_Endpage + 1;
        n_Endrow  := n_Endrow - n_Pagerows;
      End If;
    
      --不允许录入跨两页的数据 
      If n_Endrow > n_Pagerows Or n_Endpage - n_Startpage > 1 Then
        v_Err_Msg := '您在发生时间【' || To_Char(发生时间_In, 'YYYY-MM-DD hh24:mi:ss') || '】录入的数据存在错误，录入的数据不能连续跨一页以上！';
        Raise Err_Item;
      End If;
    
      --更新打印数据（当前数据的打印人与打印时间更新为NULL，其后数据不动） 
      Update 病人护理打印
      Set 文件id = 文件id_In, 记录id = n_记录id, 发生时间 = 发生时间_In, 行数 = n_行数, 开始页号 = n_Startpage, 开始行号 = n_Startrow,
          结束页号 = n_Endpage, 结束行号 = n_Endrow, 行差 = Decode(打印人, Null, 0, n_Rows),
          --只有打印过的数据才记录行差 
          打印人 = Null, 打印时间 = Null
      Where 记录id = n_记录oldid;
    End If;
  End If;
  --无行差，退出 
  If n_Rows = 0 Then
    Return;
  End If;

  --之后是否存在数据？ 
  Begin
    Select 1 Into n_Count From 病人护理打印 Where 文件id = 文件id_In And 发生时间 > 发生时间_In And Rownum < 2;
  Exception
    When Others Then
      n_Count := 0;
  End;

  If n_Count = 1 Then
    --更新之后数据的打印相关数据（除打印人与打印时间） 
    If n_Rows > 0 Then
      Update 病人护理打印
      Set 开始页号 = 开始页号 + Decode(Sign(开始行号 + n_Rows - n_Pagerows), 1, 1, 0),
          结束页号 = 结束页号 + Decode(Sign(结束行号 + n_Rows - n_Pagerows), 1, 1, 0),
          开始行号 = Decode(Mod(开始行号 + n_Rows, n_Pagerows), 0, n_Pagerows, Mod(开始行号 + n_Rows, n_Pagerows)),
          结束行号 = Decode(Mod(结束行号 + n_Rows, n_Pagerows), 0, n_Pagerows, Mod(结束行号 + n_Rows, n_Pagerows)), 打印人 = Null,
          打印时间 = Null
      Where 文件id = 文件id_In And 发生时间 > 发生时间_In;
    Else
      --新的行号小于1则页号-1 
      --新的行号+每页的有效行后再进行判断 
      Update 病人护理打印
      Set 开始页号 = 开始页号 - Decode(Sign(开始行号 + n_Rows - 1), -1, 1, 0),
          结束页号 = 结束页号 - Decode(Sign(结束行号 + n_Rows - 1), -1, 1, 0),
          开始行号 = Decode(Mod(开始行号 + n_Pagerows + n_Rows, n_Pagerows), 0, n_Pagerows,
                         Mod(开始行号 + n_Pagerows + n_Rows, n_Pagerows)),
          结束行号 = Decode(Mod(结束行号 + n_Pagerows + n_Rows, n_Pagerows), 0, n_Pagerows,
                         Mod(结束行号 + n_Pagerows + n_Rows, n_Pagerows)), 打印人 = Null, 打印时间 = Null
      Where 文件id = 文件id_In And 发生时间 > 发生时间_In;
      --程序应该是先删除了数据才更新的，所以不会存在页号为零的，页号为零的肯定已经删除了。 
      --DELETE 病人护理打印 WHERE 开始页号=0; 
    End If;
    --检查更新之后的打印数据是否存在连续跨一页以上，如果存在则禁止。 
    v_Print := '';
    For r_Print In (Select 发生时间, 开始页号
                    From 病人护理打印
                    Where 文件id = 文件id_In And 发生时间 > 发生时间_In And 结束页号 - 开始页号 > 1
                    Order By 发生时间) Loop
      If Lengthb(v_Print || Chr(13) || Chr(10) || '页号【' || r_Print.开始页号 || '】    发生时间【' ||
                 To_Char(r_Print.发生时间, 'YYYY-MM-DD hh24:mi:ss') || '】') < 800 Then
        v_Print := v_Print || Chr(13) || Chr(10) || '页号【' || r_Print.开始页号 || '】    发生时间【' ||
                   To_Char(r_Print.发生时间, 'YYYY-MM-DD hh24:mi:ss') || '】';
      End If;
    End Loop;
    If v_Print Is Not Null Then
      v_Err_Msg := '您在发生时间【' || To_Char(发生时间_In, 'YYYY-MM-DD hh24:mi:ss') || '】录入的数据影响了后续数据位置，导致以下数据连续跨了一页以上：';
      v_Err_Msg := v_Err_Msg || v_Print || Chr(13) || Chr(10) || '目前产品暂不支持对跨一页以上的数据进行展示和打印，操作终止！';
      Raise Err_Item;
    End If;
  End If;
  --进行关联文件的页号修正 
  Zl_病人护理打印_Batchretrypage(文件id_In, n_Firstdata || ';' || n_Firstdata);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人护理打印_Update;
/

--93675:梁经伙,2016-03-11,该存储过程只用于诊断选择器中病案首页某个字段的改变用的
CREATE OR REPLACE Procedure Zl_病案主页_首页整理EX
(
  病人id_In  In 病案主页.病人id%Type,
  主页id_In  In 病案主页.主页id%Type,
  信息名_In  In varchar2,     /*病案主页的字段名*/
  信息值_In  In varchar2      /*病案主页某字段的值*/
) Is
/*该存储过程只用于诊断选择器中病案首页某个字段的改变用的*/
Begin
  If 信息名_In = '出院方式' Then
    update 病案主页 set 出院方式 = 信息值_In where 病人id = 病人id_In And 主页id = 主页id_In;
  elsif 信息名_In = '尸检标志' Then
     update 病案主页 set 尸检标志 = to_number(信息值_In) where 病人id = 病人id_In And 主页id = 主页id_In;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病案主页_首页整理EX;
/

--93706:余伟节,2016-02-29,解决计算年龄天数大于31天
Create Or Replace Function Zl_Age_Calc
(
  病人id_In   病人信息.病人id%Type,
  出生日期_In Date := Null,
  计算日期_In Date := Null
) Return Varchar2
--功能:根据出生日期计算年龄.当天登记病人,保持年龄不变.
  --返回:1天以内：X小时[X分钟],1天至1月以内：X天,1月至1岁以内：X月[X天],1岁至儿童年龄上限：X岁[X月],>=儿童年龄上限：X岁
  --说明:1天以内，是指按出生日期24小时算;1月以内，是指对天计算；比如7.8日出生，8.8日才算1月;1岁以内，也是对天计算。;“以内”都是指“<”。
 As
  d_出生日期      Date;
  d_计算日期      Date;
  n_Days          Number;
  n_Months        Number;
  v_年龄          病人信息.年龄%Type;
  n_Upperagelimit Number; --参数:年龄上限

  v_Return Varchar2(20); --由于病人信息等相关表的年龄字段为10个字符，所以最大允许10个字符或5个汉字
Begin
  --当天登记的病人不用重算年龄
  If Nvl(病人id_In, 0) <> 0 Then
    Begin
      Select 年龄
      Into v_年龄
      From 病人信息
      Where 病人id = 病人id_In And Floor(Sysdate - 登记时间) = 0 And 年龄 Is Not Null;
    Exception
      When Others Then
        Null;
    End;
    If v_年龄 Is Not Null Then
      v_Return := v_年龄;
      Return v_Return;
    End If;
  End If;

  If 出生日期_In Is Null Then
    If Nvl(病人id_In, 0) <> 0 Then
      Select 出生日期 Into d_出生日期 From 病人信息 Where 病人id = 病人id_In;
    End If;
    If d_出生日期 Is Null Then
      Return Null;
    End If;
  Else
    d_出生日期 := 出生日期_In;
  End If;
  If 计算日期_In Is Null Then
    Select Sysdate Into d_计算日期 From Dual;
  Else
    d_计算日期 := 计算日期_In;
  End If;
  --如果出生日期大于计算日期,则直接为0小时
  If (d_计算日期 - d_出生日期) < 0 Then
    v_Return := '0小时';
    Return v_Return;
  End If;
  --获取儿童年龄的上限
  Select Nvl(zl_GetSysParameter(147, 0, 1), 14) Into n_Upperagelimit From Dual;

  n_Months := Trunc(Months_Between(d_计算日期, d_出生日期));
  If n_Months < 12 * n_Upperagelimit Then
    --小于1岁的情况
    If n_Months < 12 Then
      --小于1月
      If n_Months < 1 Then
        n_Days := Trunc(d_计算日期 - d_出生日期);
        --一天以内
        If n_Days = 0 Then
          n_Days := Trunc((d_计算日期 - d_出生日期) * 24 * 60);
          If Mod(n_Days, 60) = 0 Then
            v_Return := n_Days / 60 || '小时';
          Else
            v_Return := Floor(n_Days / 60) || '小时' || Mod(n_Days, 60) || '分钟';
          End If;
        Else
          --一天至一月
          v_Return := n_Days || '天';
        End If;
      Else
        --大于1月
        n_Days := Trunc(Add_Months(d_计算日期, -1 * n_Months) - d_出生日期);
        If n_Days >= 31 Then
          --针对计算日期是2月份最后一天,出生日期刚好大于2月份最后一天且当天不是本月的最后一天
          --如：计算日期：2016-02-29   出生日期：2015-01-30
          n_Months := n_Months + 1;
          n_Days   := n_Days - 31;
        End If;
        If n_Days = 0 Then
          v_Return := n_Months || '月';
        Else
          v_Return := n_Months || '月' || n_Days || '天';
        End If;
      End If;
    Else
      --1岁到小于婴儿年龄上限的情况
      If Mod(n_Months, 12) = 0 Then
        v_Return := n_Months / 12 || '岁';
      Else
        v_Return := Floor(n_Months / 12) || '岁' || Mod(n_Months, 12) || '月';
      End If;
    End If;
  Else
    --大于等于婴儿年龄上限(直接X岁)
    v_Return := Floor(n_Months / 12) || '岁';
  End If;
  Return v_Return;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Age_Calc;
/

--93964:胡俊勇,2016-03-25,变动记录错误问题

--93964:梁唐彬,2016-03-08,变动记录错误
Create Or Replace Procedure Zl_病人医嘱记录_停止
(
  --功能：停止指定的医嘱 
  --说明：一并给药的只能调用一次 
  --参数：ID_IN=相关ID为NULL的医嘱的ID(给药途径,中药用法,检查项目,主要手术,及独立医嘱) 
  --      内部调用_IN=是否其他过程内部在调用，主要区分是否手工调用停止护理等级 
  Id_In         病人医嘱记录.Id%Type,
  终止时间_In   病人医嘱记录.执行终止时间%Type,
  停嘱医生_In   病人医嘱记录.停嘱医生%Type,
  内部调用_In   Number := 0,
  医师资格_In   Number := 0,
  停嘱审核_In   Number := 0,
  操作员编号_In 人员表.编号%Type := Null,
  操作员姓名_In 人员表.姓名%Type := Null
) Is
  v_状态       病人医嘱记录.医嘱状态%Type;
  v_医嘱内容   病人医嘱记录.医嘱内容%Type;
  v_护理等级id 病案主页.护理等级id%Type;
  v_病人id     病案主页.病人id%Type;
  v_主页id     病案主页.主页id%Type;
  v_婴儿       病人医嘱记录.婴儿%Type;
  v_诊疗类别   病人医嘱记录.诊疗类别%Type;
  v_操作类型   诊疗项目目录.操作类型%Type;

  Cursor c_Oldinfo Is
    Select b.*
    From (Select c.*
           From 病人变动记录 C
           Where c.病人id = v_病人id And c.主页id = v_主页id And
                 c.开始时间 = (Select Min(开始时间)
                           From 病人变动记录
                           Where 病人id = v_病人id And 主页id = v_主页id And 开始时间 > 终止时间_In) And
                 NVL(c.终止时间|| '','空') = (Select  NVL(Min(终止时间)|| '','空')
                           From 病人变动记录
                           Where 病人id = v_病人id And 主页id = v_主页id And 开始时间 > 终止时间_In)) A, 病人变动记录 B
    
    Where b.病人id = v_病人id And b.主页id = v_主页id And a.开始时间 = b.终止时间 And a.开始原因 = b.终止原因 And a.附加床位 = b.附加床位
    Union
    Select *
    From 病人变动记录
    Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 Is Null And 开始时间 <= 终止时间_In;

  Cursor c_Endinfo Is
    Select * From 病人变动记录 Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 Is Null;
  r_Oldinfo  c_Oldinfo%Rowtype;
  r_Endinfo  c_Endinfo%Rowtype;
  v_终止原因 病人变动记录.终止原因%Type;
  v_终止时间 病人变动记录.终止时间%Type;
  v_终止人员 病人变动记录.终止人员%Type;

  v_Date     Date;
  v_Count    Number;
  v_Temp     Varchar2(255);
  v_人员编号 病人变动记录.操作员编号%Type;
  v_人员姓名 病人变动记录.操作员姓名%Type;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --检查医嘱状态是否正确:并发操作 
  Select a.医嘱状态, a.医嘱内容, a.病人id, a.主页id, Nvl(a.婴儿, 0), Nvl(a.诊疗类别, '*') As 诊疗类别, b.操作类型
  Into v_状态, v_医嘱内容, v_病人id, v_主页id, v_婴儿, v_诊疗类别, v_操作类型
  From 病人医嘱记录 A, 诊疗项目目录 B
  Where a.诊疗项目id = b.Id(+) And a.Id = Id_In;
  If v_状态 In (4, 8, 9) Then
    v_Error := '医嘱"' || v_医嘱内容 || '"已经被作废或停止，不能再停止。';
    Raise Err_Custom;
  End If;

  --检查是否是输液配液记录，并是否已经锁定 
  Select Count(1) Into v_Count From 输液配药记录 Where 是否锁定 = 1 And 医嘱id = Id_In And 执行时间 > 终止时间_In;
  If v_Count > 0 Then
    v_Error := '医嘱"' || v_医嘱内容 || '"是输液药品，已经被输液配置中心锁定，不能停止。';
    Raise Err_Custom;
  End If;

  --当前操作人员 
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
    v_人员编号 := 操作员编号_In;
    v_人员姓名 := 操作员姓名_In;
  Else
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;

  Select Sysdate Into v_Date From Dual;

  --判断是否具有执业医师或助理医师的资格和参数是否勾选 
  If 医师资格_In > 0 Or 停嘱审核_In = 0 Then
    Update 病人医嘱记录
    Set 医嘱状态 = 8, 执行终止时间 = 终止时间_In, 停嘱医生 = Decode(审核标记, 2, 停嘱医生_In || Decode(停嘱医生, Null, '', '/' || 停嘱医生), 停嘱医生_In),
        停嘱时间 = v_Date, 审核标记 = Decode(审核标记, 2, 3, 审核标记)
    Where ID = Id_In Or 相关id = Id_In;
  
    Insert Into 病人医嘱状态
      (医嘱id, 操作类型, 操作人员, 操作时间)
      Select ID, 8, v_人员姓名, v_Date --护士停时记录为护士 
      From 病人医嘱记录
      Where ID = Id_In Or 相关id = Id_In;
  Else
    --否则只修改审核标记，产生新的状态,实习医生名字填写 
    Update 病人医嘱记录 Set 审核标记 = 2, 停嘱医生 = 停嘱医生_In Where ID = Id_In Or 相关id = Id_In;
  
    Insert Into 病人医嘱状态
      (医嘱id, 操作类型, 操作人员, 操作时间, 操作说明)
      Select ID, 13, v_人员姓名, v_Date, To_Char(终止时间_In, 'YYYY-MM-DD HH24:MI:SS') --护士停时记录为护士 
      From 病人医嘱记录
      Where ID = Id_In Or 相关id = Id_In;
  End If;

  --其他特殊处理 
  If Nvl(内部调用_In, 0) = 0 And (医师资格_In > 0 Or 停嘱审核_In = 0) Then
    --停止病情医嘱时，变动病人病情 
    If v_诊疗类别 = 'Z' And v_操作类型 In ('9', '10') Then
      Open c_Oldinfo; --必须在处理之前先打开 
      Fetch c_Oldinfo
        Into r_Oldinfo;
      Open c_Endinfo;
      Fetch c_Endinfo
        Into r_Endinfo;
      If c_Endinfo%Rowcount = 0 Then
        Close c_Endinfo;
        v_Error := '未发现该病人当前有效的变动记录！';
        Raise Err_Custom;
      End If;
      Select Count(*)
      Into v_Count
      From 病人变动记录
      Where 病人id = v_病人id And 主页id = v_主页id And 开始时间 Is Null And 终止时间 Is Null;
      If v_Count > 0 Then
        v_Error := '病人当前处于转科状态，请先办理转科确认或者取消转科状态。';
        Raise Err_Custom;
      End If;
    
      Update 病案主页 Set 当前病况 = '一般' Where 病人id = v_病人id And 主页id = v_主页id;
    
      --取消上次变动 
      If r_Oldinfo.终止时间 Is Not Null Then
        v_终止时间 := r_Oldinfo.终止时间;
        v_终止原因 := r_Oldinfo.终止原因;
        v_终止人员 := r_Oldinfo.终止人员;
        --取消上次变动 
        Update 病人变动记录
        Set 终止时间 = 终止时间_In, 终止原因 = 13, 终止人员 = v_人员姓名, 上次计算时间 = Null
        Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 = v_终止时间 And 终止原因 = v_终止原因;
        --更新将来的记录如果有停止到将来的则删除上次计算时间 
        Update 病人变动记录
        Set 病情 = '一般', 上次计算时间 = Null
        Where 病人id = v_病人id And 主页id = v_主页id And 开始时间 > 终止时间_In;
      Else
        Update 病人变动记录
        Set 终止时间 = 终止时间_In, 终止原因 = 13, 终止人员 = v_人员姓名
        Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 Is Null;
      End If;
    
      While c_Oldinfo%Found Loop
        Insert Into 病人变动记录
          (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号, 操作员姓名,
           终止时间, 终止原因, 终止人员)
        Values
          (病人变动记录_Id.Nextval, v_病人id, v_主页id, 终止时间_In, 13, r_Oldinfo.附加床位, r_Oldinfo.病区id, r_Oldinfo.科室id,
           r_Oldinfo.护理等级id, r_Oldinfo.床位等级id, r_Oldinfo.床号, r_Oldinfo.责任护士, r_Oldinfo.经治医师, r_Oldinfo.主治医师,
           r_Oldinfo.主任医师, '一般', v_人员编号, v_人员姓名, v_终止时间, v_终止原因, v_终止人员);
      
        Fetch c_Oldinfo
          Into r_Oldinfo;
      End Loop;
    
      Close c_Oldinfo;
      Close c_Endinfo;
    Elsif v_诊疗类别 = 'H' And v_操作类型 = '1' And v_婴儿 = 0 Then
      --停止护理等级时，同时取消病人的护理等级费用 
      Begin
        Select c.收费细目id
        Into v_护理等级id
        From 病人医嘱记录 A, 病人医嘱计价 C, 收费项目目录 D
        Where a.Id = c.医嘱id And c.收费细目id = d.Id And d.类别 = 'H' And Nvl(d.项目特性, 0) <> 0 And a.Id = Id_In And Rownum = 1 And
              Exists
         (Select 1 From 病案主页 Where 病人id = v_病人id And 主页id = v_主页id And 护理等级id = c.收费细目id);
      Exception
        When Others Then
          Null;
      End;
      If v_护理等级id Is Not Null Then
        --变动记录的时间加上秒，以便回退操作时区分同一分种的校对、停止等操作 
        v_Date := To_Date(To_Char(终止时间_In, 'yyyy-mm-dd hh24:mi') || To_Char(v_Date, 'ss'), 'yyyy-mm-dd hh24:mi:ss');
        Zl_病人变动记录_Nurse(v_病人id, v_主页id, Null, v_Date, v_人员编号, v_人员姓名);
      End If;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人医嘱记录_停止;
/

--93964:胡俊勇,2016-03-25,变动记录错误问题

--93964:梁唐彬,2016-03-08,变动记录错误问题
Create Or Replace Procedure Zl_病人医嘱记录_校对
(
  --功能：校对指定的医嘱
  --参数：医嘱ID_IN=Nvl(相关ID,ID)
  --      状态_IN=校对通过3或校对疑问2
  --      自动校对_IN=保存之后调用自动校对,自动填写计价内容
  --说明：一组医嘱只能调用一次,过程同时完成处理一组医嘱的校对
  医嘱id_In     病人医嘱记录.Id%Type,
  状态_In       病人医嘱记录.医嘱状态%Type,
  校对时间_In   病人医嘱状态.操作时间%Type,
  校对说明_In   病人医嘱状态.操作说明%Type := Null,
  自动校对_In   Number := Null,
  操作员编号_In 人员表.编号%Type := Null,
  操作员姓名_In 人员表.姓名%Type := Null
) Is
  --用于医嘱检查
  v_状态       病人医嘱记录.医嘱状态%Type;
  v_期效       病人医嘱记录.医嘱期效%Type;
  v_病人id     病人医嘱记录.病人id%Type;
  v_主页id     病人医嘱记录.主页id%Type;
  v_婴儿       病人医嘱记录.婴儿%Type;
  v_医嘱内容   病人医嘱记录.医嘱内容%Type;
  v_开嘱时间   病人医嘱记录.开嘱时间%Type;
  v_开始时间   病人医嘱记录.开始执行时间%Type;
  v_开嘱医生   病人医嘱记录.开嘱医生%Type;
  v_前提id     病人医嘱记录.前提id%Type;
  v_执行标记   病人医嘱记录.执行标记%Type;
  v_执行科室id 病人医嘱记录.执行科室id%Type;
  v_标本部位   病人医嘱记录.标本部位%Type;
  v_停止时间   病人医嘱记录.开嘱时间%Type;
  v_开嘱科室id 病人医嘱记录.开嘱科室id%Type;

  --用于变更护理等级
  v_诊疗类别   病人医嘱记录.诊疗类别%Type;
  v_诊疗项目id 病人医嘱记录.诊疗项目id%Type;
  v_操作类型   诊疗项目目录.操作类型%Type;
  v_护理等级id 病案主页.护理等级id%Type;
  v_紧急标志   病人医嘱记录.紧急标志%Type;
  v_入院方式   入院方式.名称%Type;

  v_Stopadviceids 病人医嘱记录.医嘱内容%Type;
  n_Adviceid      病人医嘱记录.病人id%Type;
  n_标记          Number(18);
  --与该项目同一自动停止互斥组的项目:组中应该都是长嘱(包括当前医嘱),程序应已检查。
  --注意应加婴儿条件,同时也应停止除当前医嘱外的其它相同诊疗项目的医嘱。
  Cursor c_Exclude Is
    Select Distinct b.Id As 医嘱id, b.开始执行时间, b.执行终止时间, b.上次执行时间, b.开嘱医生, b.执行时间方案, b.频率间隔, b.频率次数, b.间隔单位
    From 诊疗互斥项目 A, 病人医嘱记录 B
    Where a.类型 = 3 And a.项目id = b.诊疗项目id And b.Id <> 医嘱id_In And Nvl(b.医嘱期效, 0) = 0 And b.医嘱状态 In (3, 5, 6, 7) And
          b.病人id = v_病人id And Nvl(b.主页id, 0) = Nvl(v_主页id, 0) And Nvl(b.婴儿, 0) = Nvl(v_婴儿, 0) And
          a.组编号 In (Select Distinct 组编号 From 诊疗互斥项目 Where 类型 = 3 And 项目id = v_诊疗项目id)
    Order By b.Id;
  v_终止时间 病人医嘱记录.执行终止时间%Type;

  --护理等级互斥
  Cursor c_Nurse Is
    Select a.Id As 医嘱id, a.开始执行时间, a.执行终止时间, a.上次执行时间, a.开嘱医生
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id And a.诊疗类别 = 'H' And b.操作类型 = '1' And a.病人id = v_病人id And Nvl(a.主页id, 0) = Nvl(v_主页id, 0) And
          Nvl(a.婴儿, 0) = Nvl(v_婴儿, 0) And Nvl(a.医嘱期效, 0) = 0 And a.医嘱状态 In (3, 5, 6, 7) And a.Id <> 医嘱id_In;

  --记录入出量互斥
  Cursor c_Patiio Is
    Select a.Id As 医嘱id, a.开始执行时间, a.执行终止时间, a.上次执行时间, a.开嘱医生
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id And a.诊疗类别 = 'Z' And b.操作类型 = '12' And a.病人id = v_病人id And Nvl(a.主页id, 0) = Nvl(v_主页id, 0) And
          Nvl(a.婴儿, 0) = Nvl(v_婴儿, 0) And Nvl(a.医嘱期效, 0) = 0 And a.医嘱状态 In (3, 5, 6, 7) And a.Id <> 医嘱id_In;

  --记录病情互斥
  Cursor c_Patistate Is
    Select a.Id As 医嘱id, a.开始执行时间, a.执行终止时间, a.上次执行时间, a.开嘱医生
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id And a.诊疗类别 = 'Z' And b.操作类型 In ('9', '10') And a.病人id = v_病人id And
          Nvl(a.主页id, 0) = Nvl(v_主页id, 0) And Nvl(a.婴儿, 0) = Nvl(v_婴儿, 0) And Nvl(a.医嘱期效, 0) = 0 And
          a.医嘱状态 In (3, 5, 6, 7) And a.Id <> 医嘱id_In;
  --变动有效记录
  Cursor c_Oldinfo Is
    Select b.*
    From (Select c.*
           From 病人变动记录 C
           Where c.病人id = v_病人id And c.主页id = v_主页id And
                 c.开始时间 = (Select Min(开始时间)
                           From 病人变动记录
                           Where 病人id = v_病人id And 主页id = v_主页id And 开始时间 > v_开始时间) And
                 NVL(c.终止时间|| '','空') = (Select  NVL(Min(终止时间)|| '','空')
                           From 病人变动记录
                           Where 病人id = v_病人id And 主页id = v_主页id And 开始时间 > v_开始时间)) A, 病人变动记录 B
    
    Where b.病人id = v_病人id And b.主页id = v_主页id And a.开始时间 = b.终止时间 And a.开始原因 = b.终止原因 And a.附加床位 = b.附加床位
    Union
    Select *
    From 病人变动记录
    Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 Is Null And 开始时间 <= v_开始时间;

  Cursor c_Endinfo Is
    Select * From 病人变动记录 Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 Is Null;
  r_Oldinfo      c_Oldinfo%RowType;
  r_Endinfo      c_Endinfo%RowType;
  v_变动终止原因 病人变动记录.终止原因%Type;
  v_变动终止时间 病人变动记录.终止时间%Type;
  v_变动终止人员 病人变动记录.终止人员%Type;

  --包含病人(婴儿)的所有未停长嘱(含配方长嘱)
  Cursor c_Needstop
  (
    v_病人id   病人医嘱记录.病人id%Type,
    v_主页id   病人医嘱记录.主页id%Type,
    v_婴儿     病人医嘱记录.婴儿%Type,
    v_Stoptime Date
  ) Is
    Select a.Id, a.诊疗类别, b.操作类型, b.执行频率
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id(+) And a.病人id = v_病人id And a.主页id = v_主页id And (v_婴儿 = -1 Or Nvl(a.婴儿, 0) = Nvl(v_婴儿, 0)) And
          Nvl(a.医嘱期效, 0) = 0 And a.医嘱状态 Not In (1, 2, 4, 8, 9) And a.开始执行时间 < v_Stoptime
    Order By a.序号;
  --包含病人(婴儿)的已停但未确认的长嘱,终止执行时间在指定时间之后
  Cursor c_Havestop
  (
    v_病人id   病人医嘱记录.病人id%Type,
    v_主页id   病人医嘱记录.主页id%Type,
    v_婴儿     病人医嘱记录.婴儿%Type,
    v_Stoptime Date
  ) Is
    Select ID
    From 病人医嘱记录
    Where 病人id = v_病人id And 主页id = v_主页id And (v_婴儿 = -1 Or Nvl(婴儿, 0) = Nvl(v_婴儿, 0)) And Nvl(医嘱期效, 0) = 0 And
          医嘱状态 = 8 And 执行终止时间 > v_Stoptime And 开始执行时间 < v_Stoptime
    Order By 序号;

  --取一组医嘱的计价内容
  Cursor c_Price Is
    Select a.Id, b.收费项目id, b.收费数量, b.从属项目, b.费用性质, b.收费方式, c.类别 As 收费类别, a.诊疗类别, e.操作类型, e.试管编码,
           Sum(Decode(Nvl(c.是否变价, 0), 1, Nvl(d.缺省价格, d.原价), Null)) As 单价
    From 病人医嘱记录 A, 诊疗收费关系 B, 收费项目目录 C, 收费价目 D, 诊疗项目目录 E
    Where a.诊疗项目id = b.诊疗项目id And b.收费项目id = c.Id And c.Id = d.收费细目id And
          (a.相关id Is Null And a.执行标记 In (1, 2) And b.费用性质 = 1 Or
          a.标本部位 = b.检查部位 And a.检查方法 = b.检查方法 And Nvl(b.费用性质, 0) = 0 Or
          a.检查方法 Is Null And Nvl(b.费用性质, 0) = 0 And b.检查部位 Is Null And b.检查方法 Is Null) And
          a.诊疗类别 Not In ('5', '6', '7') And Nvl(a.计价特性, 0) = 0 And Nvl(a.执行性质, 0) Not In (0, 5) And c.服务对象 In (2, 3) And
          (c.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or c.撤档时间 Is Null) And Sysdate Between d.执行日期 And
          Nvl(d.终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')) And Nvl(b.收费数量, 0) <> 0 And
          Not (Nvl(c.是否变价, 0) = 1 And Nvl(Nvl(d.缺省价格, d.原价), 0) = 0) And a.诊疗项目id = e.Id And
          (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In)
    Group By a.Id, b.收费项目id, b.收费数量, b.从属项目, b.费用性质, b.收费方式, c.类别, a.诊疗类别, e.操作类型, e.试管编码;

  Cursor c_Pati(v_病人id 病人信息.病人id%Type) Is
    Select * From 病人信息 Where 病人id = v_病人id;
  r_Pati c_Pati%RowType;

  v_材料id 采血管类型.材料id%Type;

  --其它临时变量
  v_参数值   Zlparameters.参数值%Type;
  v_Count    Number;
  v_Date     Date;
  v_Temp     Varchar2(255);
  v_人员编号 人员表.编号%Type;
  v_人员姓名 人员表.姓名%Type;

  v_Error Varchar2(255);
  Err_Custom Exception;

  Function Getadvicetext(v_医嘱id 病人医嘱记录.Id%Type) Return Varchar2 Is
    v_Text 病人医嘱记录.医嘱内容%Type;
    v_类别 病人医嘱记录.诊疗类别%Type;
    v_配方 Number;
  Begin
    Select 诊疗类别, 医嘱内容 Into v_类别, v_Text From 病人医嘱记录 Where ID = v_医嘱id;
    If v_类别 = 'E' Then
      --西药，中成药的医嘱内容
      Begin
        Select 诊疗类别, Decode(诊疗类别, '7', v_Text, 医嘱内容)
        Into v_类别, v_Text
        From 病人医嘱记录
        Where 相关id = v_医嘱id And 诊疗类别 In ('5', '6', '7') And Rownum = 1;
      Exception
        When Others Then
          Null;
      End;
      If v_类别 = '7' Then
        v_配方 := 1;
      End If;
    End If;
    If Length(v_Text) > 30 Then
      v_Text := Substr(v_Text, 1, 30) || '...';
    End If;
    If Length(v_Text) > 20 Then
      v_Text := '"' || v_Text || '"' || Chr(13) || Chr(10);
    Else
      v_Text := '"' || v_Text || '"';
    End If;
    If v_配方 = 1 Then
      v_Text := '中药配方' || v_Text;
    End If;
    Return(v_Text);
  End;
Begin
  --检查医嘱状态是否正确:并发操作
  Begin
    Select a.医嘱期效, a.医嘱状态, a.开嘱时间, a.开嘱医生, a.开始执行时间, a.病人id, a.主页id, a.婴儿, a.医嘱内容, a.诊疗类别, a.诊疗项目id, a.前提id,
           Nvl(b.操作类型, '0'), Nvl(a.执行标记, 0), a.执行科室id, a.标本部位, a.开嘱科室id, Nvl(a.紧急标志, 0) As 紧急标志
    Into v_期效, v_状态, v_开嘱时间, v_开嘱医生, v_开始时间, v_病人id, v_主页id, v_婴儿, v_医嘱内容, v_诊疗类别, v_诊疗项目id, v_前提id, v_操作类型, v_执行标记,
         v_执行科室id, v_标本部位, v_开嘱科室id, v_紧急标志
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id(+) And a.Id = 医嘱id_In;
  Exception
    When Others Then
      Begin
        v_Error := '医嘱已被删除，不能进行校对。' || Chr(13) || Chr(10) || '这可能是并发操作引起的，请重新读取校对数据。';
        Raise Err_Custom;
      End;
  End;
  If v_状态 <> 1 Then
    v_Error := '医嘱"' || Getadvicetext(医嘱id_In) || '"不是新开的医嘱，不能通过校对。' || Chr(13) || Chr(10) || '这可能是并发操作引起的，请重新读取校对数据。';
    Raise Err_Custom;
  End If;
  --再次检查校对时间的有效性:并发操作
  If To_Char(v_开嘱时间, 'YYYY-MM-DD HH24:MI') <= To_Char(v_开始时间, 'YYYY-MM-DD HH24:MI') Then
    If To_Char(校对时间_In, 'YYYY-MM-DD HH24:MI') < To_Char(v_开嘱时间, 'YYYY-MM-DD HH24:MI') Then
      v_Error := '医嘱"' || Getadvicetext(医嘱id_In) || '"的校对时间不能小于开嘱时间 ' || To_Char(v_开嘱时间, 'YYYY-MM-DD HH24:MI') || '。' ||
                 Chr(13) || Chr(10) || '这可能是并发操作引起的，请重新读取校对数据。';
      Raise Err_Custom;
    End If;
  Else
    If To_Char(校对时间_In, 'YYYY-MM-DD HH24:MI') < To_Char(v_开始时间, 'YYYY-MM-DD HH24:MI') Then
      v_Error := '医嘱"' || Getadvicetext(医嘱id_In) || '"的校对时间不能小于开始执行时间 ' || To_Char(v_开始时间, 'YYYY-MM-DD HH24:MI') || '。' ||
                 Chr(13) || Chr(10) || '这可能是并发操作引起的，请重新读取校对数据。';
      Raise Err_Custom;
    End If;
  End If;

  --如果要求签名，检查校对时是否有签名(并发取消签名)
  If 状态_In = 3 Then
    Select zl_GetSysParameter(25) Into v_参数值 From Dual;
    If Nvl(v_参数值, '0') <> '0' Then
      Select zl_GetSysParameter(26) Into v_参数值 From Dual;
      If v_前提id Is Null Then
        Select Count(*) Into v_Count From 电子签名启用部门 Where 部门id = v_开嘱科室id And 场合 = 1;
      Else
        Select Count(*) Into v_Count From 电子签名启用部门 Where 部门id = v_开嘱科室id And 场合 = 3;
      End If;
      If Nvl(Substr(v_参数值, 2, 1), '0') = '1' And v_前提id Is Null And v_Count > 0 Or
         Nvl(Substr(v_参数值, 3, 1), '0') = '1' And v_前提id Is Not Null And v_Count > 0 Then
        Select Nvl(Max(是否停用), 0)
        Into v_Count
        From (Select a.是否停用, a.注册时间
               From 人员证书记录 A, 人员表 B
               Where a.人员id = b.Id And b.姓名 = v_开嘱医生
               Order By a.注册时间 Desc)
        Where Rownum < 2;
        If v_Count = 0 Then
          Select Count(*)
          Into v_Count
          From 病人医嘱状态 A
          Where 操作类型 = 1 And 医嘱id = 医嘱id_In And
                (签名id Is Null And Exists
                 (Select 1
                  From 人员表 R, 人员性质说明 X
                  Where r.Id = x.人员id And r.姓名 = a.操作人员 And x.人员性质 = '护士') And Not Exists
                 (Select 1
                  From 人员表 R, 人员性质说明 Y
                  Where r.Id = y.人员id And r.姓名 = a.操作人员 And y.人员性质 = '医生') Or 签名id Is Not Null Or a.操作人员 <> v_开嘱医生);
          If Nvl(v_Count, 0) = 0 Then
            v_Error := '医嘱"' || Getadvicetext(医嘱id_In) || '"还没有电子签名，不能通过校对。';
            Raise Err_Custom;
          End If;
        End If;
      End If;
    End If;
  End If;

  --当前操作人员
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
    v_人员编号 := 操作员编号_In;
    v_人员姓名 := 操作员姓名_In;
  Else
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;

  --因为可能同时：新开->自动校对->互斥自动停止,因此分别-2,-1秒
  Select Sysdate - 1 / 60 / 60 / 24 Into v_Date From Dual;

  Update 病人医嘱记录
  Set 医嘱状态 = 状态_In, 校对护士 = v_人员姓名, 校对时间 = 校对时间_In
  Where ID = 医嘱id_In Or 相关id = 医嘱id_In;

  Insert Into 病人医嘱状态
    (医嘱id, 操作类型, 操作人员, 操作时间, 操作说明)
    Select ID, 状态_In, v_人员姓名, v_Date, 校对说明_In From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;

  --校对通过时的其它处理
  If 状态_In = 3 Then
    --自动校对时，自动填写缺省的计价内容
    If Nvl(自动校对_In, 0) = 1 Then
      --1.变价的计价项目,如果最低限价不为0,则缺省为最低限价,否则不加入;可再手工计价.
      --2.对于非药嘱药品和在用卫材未定执行科室,发送时会取缺省的,可再手工设置。
      For r_Price In c_Price Loop
        --取(检验)医嘱的管码和材料,采集方式以检验项目的为准
        v_材料id := Null;
        If r_Price.诊疗类别 = 'E' And r_Price.操作类型 = '6' Then
          Begin
            Select c.材料id
            Into v_材料id
            From 病人医嘱记录 A, 诊疗项目目录 B, 采血管类型 C
            Where a.诊疗项目id = b.Id And b.试管编码 = c.编码 And a.相关id = r_Price.Id And Rownum = 1;
          Exception
            When Others Then
              Null;
          End;
        Elsif r_Price.诊疗类别 = 'C' And r_Price.试管编码 Is Not Null Then
          Begin
            Select 材料id Into v_材料id From 采血管类型 Where 编码 = r_Price.试管编码;
          Exception
            When Others Then
              Null;
          End;
        End If;
      
        --判断处理检验试管费用的收取
        If (Nvl(r_Price.收费方式, 0) = 1 And r_Price.收费类别 = '4' And r_Price.收费项目id = Nvl(v_材料id, 0) Or
           Not (Nvl(r_Price.收费方式, 0) = 1 And r_Price.收费类别 = '4' And Nvl(v_材料id, 0) <> 0)) Then
          Insert Into 病人医嘱计价
            (医嘱id, 收费细目id, 数量, 单价, 从项, 执行科室id, 费用性质, 收费方式)
          Values
            (r_Price.Id, r_Price.收费项目id, r_Price.收费数量, r_Price.单价, r_Price.从属项目, Null, r_Price.费用性质, r_Price.收费方式);
        End If;
      End Loop;
    End If;
  
    --自由录入的临嘱医嘱标记为停止
    If Nvl(v_期效, 0) = 1 And v_诊疗项目id Is Null Then
      Update 病人医嘱记录
      Set 医嘱状态 = 8, 停嘱时间 = 校对时间_In, 停嘱医生 = v_开嘱医生
      Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
    
      Insert Into 病人医嘱状态
        (医嘱id, 操作类型, 操作人员, 操作时间)
        Select ID, 8, v_人员姓名, Sysdate From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
    End If;
  
    --将同一自动停止互斥组中的病人其它医嘱停止(如果尚未停止)
    For r_Exclude In c_Exclude Loop
      Select Decode(Sign(r_Exclude.开始执行时间 - v_开始时间), 1, r_Exclude.开始执行时间, v_开始时间)
      Into v_终止时间
      From Dual;
      Select Decode(Sign(r_Exclude.执行终止时间 - v_开始时间), -1, r_Exclude.执行终止时间, v_开始时间)
      Into v_终止时间
      From Dual;
      Zl_病人医嘱记录_停止(r_Exclude.医嘱id, v_终止时间, v_开嘱医生, 1);
      v_Stopadviceids := v_Stopadviceids || ',' || r_Exclude.医嘱id;
    End Loop;
  
    --对一些特殊医嘱的处理
    If v_诊疗类别 = 'H' And v_操作类型 = '1' And Nvl(v_期效, 0) = 0 Then
      --校对护理等级时,同步更改病人护理等级
      If Nvl(v_婴儿, 0) = 0 Then
        --病人当前应处于正常住院状态
        v_Temp := Null;
        Begin
          Select Decode(状态, 1, '等待入科', 2, '正在转科', 3, '已预出院', Null)
          Into v_Temp
          From 病案主页
          Where 病人id = v_病人id And 主页id = v_主页id;
        Exception
          When Others Then
            Null;
        End;
        If v_Temp Is Not Null Then
          v_Error := '病人当前处于' || v_Temp || '状态,医嘱"' || v_医嘱内容 || '"不能通过校对。';
          Raise Err_Custom;
        End If;
      
        Begin
          --根据收费对照处理，当前医嘱计价表还没有填写
          --未设置时,不处理；相同时,不处理；有多个时,只取一个。
          Select a.收费项目id
          Into v_护理等级id
          From 诊疗收费关系 A, 收费项目目录 B
          Where a.收费项目id = b.Id And b.类别 = 'H' And Nvl(b.项目特性, 0) <> 0 And a.诊疗项目id = v_诊疗项目id And Rownum = 1 And
                Not Exists
           (Select 1 From 病案主页 Where 病人id = v_病人id And 主页id = v_主页id And 护理等级id = a.收费项目id);
        Exception
          When Others Then
            Null;
        End;
      End If;
    
      --变动记录的时间加上秒，以便回退操作时区分同一分种的校对、停止等操作
      v_开始时间 := To_Date(To_Char(v_开始时间, 'yyyy-mm-dd hh24:mi') || To_Char(Sysdate, 'ss'), 'yyyy-mm-dd hh24:mi:ss');
      If v_护理等级id Is Not Null Then
        Zl_病人变动记录_Nurse(v_病人id, v_主页id, v_护理等级id, v_开始时间, v_人员编号, v_人员姓名);
      End If;
    
      --并停止其它护理等级医嘱(护理等级应该都为"持续性"长嘱,且只有一个未停)
      For r_Nurse In c_Nurse Loop
        Select Decode(Sign(r_Nurse.开始执行时间 - v_开始时间), 1, r_Nurse.开始执行时间, v_开始时间)
        Into v_终止时间
        From Dual;
        Select Decode(Sign(r_Nurse.执行终止时间 - v_开始时间), -1, r_Nurse.执行终止时间, v_开始时间)
        Into v_终止时间
        From Dual;
        Zl_病人医嘱记录_停止(r_Nurse.医嘱id, v_终止时间, v_开嘱医生, 1);
        v_Stopadviceids := v_Stopadviceids || ',' || r_Nurse.医嘱id;
      End Loop;
    Elsif v_诊疗类别 = 'Z' And v_操作类型 In ('9', '10') And Nvl(v_期效, 0) = 0 And Nvl(v_婴儿, 0) = 0 Then
      --病重病危医嘱：9-病重;10-病危
      --停止相同医嘱
      For r_Patistate In c_Patistate Loop
        Select Decode(Sign(r_Patistate.开始执行时间 - v_开始时间), 1, r_Patistate.开始执行时间, v_开始时间)
        Into v_终止时间
        From Dual;
        Select Decode(Sign(r_Patistate.执行终止时间 - v_开始时间), -1, r_Patistate.执行终止时间, v_开始时间)
        Into v_终止时间
        From Dual;
        Zl_病人医嘱记录_停止(r_Patistate.医嘱id, v_终止时间, v_开嘱医生, 1);
        v_Stopadviceids := v_Stopadviceids || ',' || r_Patistate.医嘱id;
      End Loop;
    
      --产生病情变动
      Open c_Oldinfo; --必须在处理之前先打开
      Fetch c_Oldinfo
        Into r_Oldinfo;
      Open c_Endinfo;
      Fetch c_Endinfo
        Into r_Endinfo;
      If c_Endinfo%RowCount = 0 Then
        Close c_Endinfo;
        v_Error := '未发现该病人当前有效的变动记录！';
        Raise Err_Custom;
      End If;
      Select Count(*)
      Into v_Count
      From 病人变动记录
      Where 病人id = v_病人id And 主页id = v_主页id And 开始时间 Is Null And 终止时间 Is Null;
      If v_Count > 0 Then
        v_Error := '病人当前处于转科状态，请先办理转科确认或者取消转科状态。';
        Raise Err_Custom;
      End If;
    
      Update 病案主页
      Set 当前病况 = Decode(v_操作类型, '9', '重', '10', '危')
      Where 病人id = v_病人id And 主页id = v_主页id;
    
      --取消上次变动
      If r_Oldinfo.终止时间 Is Not Null Then
        v_变动终止时间 := r_Oldinfo.终止时间;
        v_变动终止原因 := r_Oldinfo.终止原因;
        v_变动终止人员 := r_Oldinfo.终止人员;
        --取消上次变动
        Update 病人变动记录
        Set 终止时间 = v_开始时间, 终止原因 = 13, 终止人员 = v_人员姓名, 上次计算时间 = Null
        Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 = v_变动终止时间 And 终止原因 = v_变动终止原因;
        --更新将来的记录如果有停止到将来的则删除上次计算时间
        Update 病人变动记录
        Set 病情 = Decode(v_操作类型, '9', '重', '10', '危'), 上次计算时间 = Null
        Where 病人id = v_病人id And 主页id = v_主页id And 开始时间 > v_开始时间;
      Else
        Update 病人变动记录
        Set 终止时间 = v_开始时间, 终止原因 = 13, 终止人员 = v_人员姓名
        Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 Is Null;
      End If;
    
      While c_Oldinfo%Found Loop
        Insert Into 病人变动记录
          (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号, 操作员姓名,
           终止时间, 终止原因, 终止人员)
        Values
          (病人变动记录_Id.Nextval, v_病人id, v_主页id, v_开始时间, 13, r_Oldinfo.附加床位, r_Oldinfo.病区id, r_Oldinfo.科室id,
           r_Oldinfo.护理等级id, r_Oldinfo.床位等级id, r_Oldinfo.床号, r_Oldinfo.责任护士, r_Oldinfo.经治医师, r_Oldinfo.主治医师,
           r_Oldinfo.主任医师, Decode(v_操作类型, '9', '重', '10', '危'), v_人员编号, v_人员姓名, v_变动终止时间, v_变动终止原因, v_变动终止人员);
      
        Fetch c_Oldinfo
          Into r_Oldinfo;
      End Loop;
    
      Close c_Oldinfo;
      Close c_Endinfo;
    Elsif v_诊疗类别 = 'Z' And v_操作类型 = '12' And Nvl(v_期效, 0) = 0 And Nvl(v_婴儿, 0) = 0 Then
      --记录入出量的医嘱，互斥
      For r_Patiio In c_Patiio Loop
        Select Decode(Sign(r_Patiio.开始执行时间 - v_开始时间), 1, r_Patiio.开始执行时间, v_开始时间)
        Into v_终止时间
        From Dual;
        Select Decode(Sign(r_Patiio.执行终止时间 - v_开始时间), -1, r_Patiio.执行终止时间, v_开始时间)
        Into v_终止时间
        From Dual;
        Zl_病人医嘱记录_停止(r_Patiio.医嘱id, v_终止时间, v_开嘱医生, 1);
        v_Stopadviceids := v_Stopadviceids || ',' || r_Patiio.医嘱id;
      End Loop;
    Elsif (v_诊疗类别 = 'Z' And v_操作类型 In ('3', '4', '5', '6', '11', '14') And
          (v_操作类型 <> '14' Or v_操作类型 = '14' And v_执行标记 = 1)) Or (v_诊疗类别 = 'F' And v_执行标记 = 1) Then
      v_Count := 0;
      If v_操作类型 = '4' Or v_操作类型 = '14' Or v_诊疗类别 = 'F' Then
        --保持与以前校对时相同的处理
        If Nvl(v_婴儿, 0) = 0 Then
          v_Count := 1;
        End If;
      Else
        --这几个特殊医嘱在校对中停止医嘱是新加的内容，保持与发送中相同的处理
        v_Count := 1;
        If Nvl(v_婴儿, 0) = 0 Then
          v_婴儿 := -1;
        Else
          v_婴儿 := Nvl(v_婴儿, 0);
        End If;
      End If;
      If v_Count = 1 Then
        If v_诊疗类别 = 'F' And v_执行标记 = 1 Then
          --在手术当天(取整)停止
          v_开始时间 := Trunc(To_Date(v_标本部位, 'yyyy-mm-dd hh24:mi:ss'));
        End If;
      
        --几个特殊医嘱校对时停止前面的长嘱,在医嘱开始时终止：3-转科;4-术后;5-出院;6-转院,11-死亡,14-术前
        For r_Needstop In c_Needstop(v_病人id, v_主页id, v_婴儿, v_开始时间) Loop
          Select Decode(Sign(开始执行时间 - v_开始时间), 1, 开始执行时间, v_开始时间)
          Into v_停止时间
          From 病人医嘱记录
          Where ID = r_Needstop.Id;
          Update 病人医嘱记录
          Set 医嘱状态 = 8, 执行终止时间 = v_停止时间, 停嘱时间 = 校对时间_In, 停嘱医生 = v_开嘱医生
          Where ID = r_Needstop.Id;
        
          Insert Into 病人医嘱状态
            (医嘱id, 操作类型, 操作人员, 操作时间)
            Select ID, 8, v_人员姓名, 校对时间_In From 病人医嘱记录 Where ID = r_Needstop.Id;
          v_Stopadviceids := v_Stopadviceids || ',' || r_Needstop.Id;
        End Loop;
        --已停止未确认的长嘱,终止时间在医嘱开始后的,调前其终止时间(同时多个特殊医嘱的情况)
        For r_Havestop In c_Havestop(v_病人id, v_主页id, v_婴儿, v_开始时间) Loop
          Update 病人医嘱记录
          Set 执行终止时间 = Decode(Sign(开始执行时间 - v_开始时间), 1, 开始执行时间, v_开始时间), 停嘱时间 = 校对时间_In, 停嘱医生 = v_开嘱医生
          Where ID = r_Havestop.Id;
        
          --不修改停止医嘱的操作人员，因为停止时，医生可能已进行电子签名
          Update 病人医嘱状态 Set 操作时间 = 校对时间_In Where 医嘱id = r_Havestop.Id And 操作类型 = 8;
          v_Stopadviceids := v_Stopadviceids || ',' || r_Havestop.Id;
        End Loop;
        --处理长期备用医嘱(没有执行（发送）过的标记未用）
        Update 病人医嘱记录
        Set 执行标记 = -1
        Where 病人id = v_病人id And 主页id = v_主页id And 医嘱期效 = 0 And 执行频次 = '必要时' And 上次执行时间 Is Null And 医嘱状态 In (3, 5, 6, 7) And
              执行标记 <> -1;
        --如果是转院转科死亡出院医嘱同时处理临时备用医嘱。
        If v_操作类型 In ('3', '5', '6', '11') Then
          Update 病人医嘱记录
          Set 执行标记 = -1
          Where 病人id = v_病人id And 主页id = v_主页id And 医嘱期效 = 1 And 执行频次 = '需要时' And 医嘱状态 = 3 And 执行标记 <> -1;
        End If;
      End If;
    Elsif v_诊疗类别 = 'Z' And v_操作类型 = '2' Then
      --对留观病人下达入院通知;
      --预约登记的条件：1.当前无预约,2.当前是门诊留观病人（在院时也允许，因为需要先预约,入院接收时检查了必须出院后才能接收）
      Select Count(*) Into v_Count From 病案主页 Where 病人id = v_病人id And Nvl(主页id, 0) = 0;
      If v_Count = 0 Then
        Select Count(*) Into v_Count From 病案主页 Where 病人id = v_病人id And 主页id = v_主页id And 病人性质 <> 1;
      End If;
      If v_Count = 0 Then
        Open c_Pati(v_病人id);
        Fetch c_Pati
          Into r_Pati;
        Close c_Pati;
      
        v_入院方式 := Null;
        If v_紧急标志 = 1 Then
          v_入院方式 := '急诊';
        End If;
      
        Zl_入院病案主页_Insert(1, 0, r_Pati.病人id, r_Pati.住院号, Null, r_Pati.姓名, r_Pati.性别, r_Pati.年龄, r_Pati.费别, r_Pati.出生日期,
                         r_Pati.国籍, r_Pati.民族, r_Pati.学历, r_Pati.婚姻状况, r_Pati.职业, r_Pati.身份, r_Pati.身份证号, r_Pati.出生地点,
                         r_Pati.家庭地址, r_Pati.家庭地址邮编, r_Pati.家庭电话, r_Pati.户口地址, r_Pati.户口地址邮编, r_Pati.联系人姓名, r_Pati.联系人关系,
                         r_Pati.联系人地址, r_Pati.联系人电话, r_Pati.工作单位, r_Pati.合同单位id, r_Pati.单位电话, r_Pati.单位邮编, r_Pati.单位开户行,
                         r_Pati.单位帐号, r_Pati.担保人, r_Pati.担保额, r_Pati.担保性质, v_执行科室id, Null, Null, v_入院方式, Null, Null,
                         v_开嘱医生, r_Pati.籍贯, r_Pati.区域, v_开始时间, Null, Null, r_Pati.医疗付款方式, Null, Null, Null, Null, Null,
                         Null, r_Pati.险类, v_人员编号, v_人员姓名, 0, Null, Null, 0);
      End If;
    End If;
    --医嘱停止消息的处理
    If v_Stopadviceids Is Not Null Then
      v_Stopadviceids := Substr(v_Stopadviceids, 2);
      Select Max(a.Id)
      Into n_标记
      From 病人医嘱记录 A
      Where a.Id In (Select Column_Value From Table(f_Num2list(v_Stopadviceids))) And a.医嘱期效 = 0 And a.医嘱状态 = 8 And
            Nvl(a.执行标记, 0) <> -1 And a.病人来源 <> 3;
      If n_标记 Is Not Null Then
        Select Max(a.Id)
        Into n_Adviceid
        From 病人医嘱记录 A
        Where a.Id In (Select Column_Value From Table(f_Num2list(v_Stopadviceids))) And a.紧急标志 = 1 And a.医嘱期效 = 0 And
              a.医嘱状态 = 8 And Nvl(a.执行标记, 0) <> -1 And a.病人来源 <> 3;
        If n_Adviceid Is Not Null Then
          n_Adviceid := n_标记;
          Select Nvl(Max(0), 2)
          Into n_标记
          From 业务消息清单 A
          Where a.病人id = v_病人id And a.就诊id = v_主页id And a.类型编码 = 'ZLHIS_CIS_002' And a.优先程度 = 2 And a.是否已阅 = 0;
        Else
          Select Nvl(Max(0), 1)
          Into n_标记
          From 业务消息清单 A
          Where a.病人id = v_病人id And a.就诊id = v_主页id And a.类型编码 = 'ZLHIS_CIS_002' And a.是否已阅 = 0;
        End If;
        If n_标记 > 0 Then
          For R In (Select a.病人性质 As 性质, a.出院科室id As 科室id, a.当前病区id As 病区id
                    From 病案主页 A
                    Where a.病人id = v_病人id And a.主页id = v_主页id) Loop
            Zl_业务消息清单_Insert(v_病人id, v_主页id, r.科室id, r.病区id, r.性质, '有新停止医嘱。', '0010', 'ZLHIS_CIS_002', n_Adviceid, n_标记,
                             0, Null, r.病区id);
          End Loop;
        End If;
      End If;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱记录_校对;
/

--93964:梁唐彬,2016-03-07,病况变动记录停止错误问题
Create Or Replace Procedure Zl_病人医嘱记录_回退
(
  医嘱id_In     病人医嘱记录.Id%Type,
  Flag_In       Number := 0,
  医嘱内容_In   病人医嘱记录.医嘱内容%Type := Null,
  操作类型_In   病人医嘱状态.操作类型%Type := Null,
  操作员编号_In 人员表.编号%Type := Null,
  操作员姓名_In 人员表.姓名%Type := Null
  --功能：回退住院医嘱的状态操作或发送操作(回退重整操作通过调用Zl_病人医嘱记录_批量回退来进行)
  --参数：医嘱ID_IN=一组医嘱ID
  --      FLAG_IN=附加数据。回退停止：0=清除执行终止时间,1=保留现有的执行终止时间。
  --      医嘱内容_IN=该过程被批量回退调用时才用，用于错误提示。
  --      操作类型_IN=该过程被批量回退调用时才用，用于核对回退数据。0-回退发送,n=回退具体医嘱操作
) Is
  --包含指定医嘱的操作记录,第一条为要回退的内容(状态操作优先)
  --临嘱不回退发送后的自动停止,在回退发送时自动回退停止操作
  Cursor c_Rolladvice Is
    Select b.操作人员, b.操作时间, 0 As 发送号, b.操作类型, 0 As 执行状态, Sysdate + Null As 首次时间, Sysdate + Null As 末次时间, a.上次执行时间, a.医嘱期效,
           a.诊疗类别 As 类别, a.诊疗项目id, Null As 类型, a.病人id, a.主页id, a.婴儿, 0 As 记录性质, 0 As 门诊记帐, 0 As 开嘱科室id, a.审核标记, a.开嘱医生,
           a.执行科室id
    From 病人医嘱记录 A, 病人医嘱状态 B
    Where a.Id = b.医嘱id And (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In) And
          (Nvl(a.医嘱期效, 0) = 0 And b.操作类型 Not In (1, 2, 3) Or Nvl(a.医嘱期效, 0) = 1 And b.操作类型 Not In (1, 2, 3, 8))
    Union
    Select b.发送人 As 操作人员, b.发送时间 As 操作时间, b.发送号, -null As 操作类型, b.执行状态, b.首次时间, b.末次时间, a.上次执行时间, a.医嘱期效, c.类别, a.诊疗项目id,
           c.操作类型 As 类型, a.病人id, a.主页id, a.婴儿, b.记录性质, b.门诊记帐, a.开嘱科室id, a.审核标记, a.开嘱医生, a.执行科室id
    From 病人医嘱记录 A, 病人医嘱发送 B, 诊疗项目目录 C
    Where a.Id = b.医嘱id And a.诊疗项目id = c.Id And (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In)
    Order By 操作时间 Desc, 发送号;
  r_Rolladvice c_Rolladvice%RowType;

  --方式同c_Rolladvice，只取发送部份用了自动回退处理
  Cursor c_Rollsend(v_发送号 病人医嘱发送.发送号%Type) Is
    Select Distinct b.医嘱id, b.发送时间 As 操作时间, b.发送号, b.执行状态, a.诊疗类别 As 类别, c.当前病区id As 病人病区id, a.病人科室id,
                    b.执行部门id As 执行科室id
    From 病人医嘱记录 A, 病人医嘱发送 B, 病案主页 C
    Where a.Id = b.医嘱id And b.发送号 = v_发送号 And a.病人id = c.病人id And a.主页id = c.主页id And
          (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In)
    Order By b.发送时间 Desc, b.发送号;

  --根据医嘱及发送NO求出本次回退要销帐的费用记录
  --一组医嘱并不是都填写了发送记录,且可能NO不同(药品有,用法煎法不一定有)
  --不管发送记录的计费状态(可能无需计费),有费用记录自然关联出来
  --费用只求价格父号为空的,以便取序号销帐
  --只管记录状态为1的费用,对于已销帐或部份销帐的记录,不再处理；其中"记录状态=3"的读取出来仅用于判断，不处理。
  Cursor c_Rollmoneyout
  (
    v_发送号    病人医嘱发送.发送号%Type,
    v_医嘱id    病人医嘱记录.Id%Type,
    t_Adviceids t_Numlist
  ) Is
    Select /*+ Rule*/
     a.Id, a.记录状态, a.No, a.序号, a.收费类别, a.执行状态, d.跟踪在用, a.执行部门id, a.记录性质
    From 门诊费用记录 A, Table(t_Adviceids) B, 病人医嘱发送 C, 材料特性 D
    Where c.医嘱id = b.Column_Value And c.发送号 = v_发送号 And a.医嘱序号 = b.Column_Value And
          (a.医嘱序号 = v_医嘱id Or Nvl(v_医嘱id, 0) = 0) And a.记录状态 In (0, 1, 3) And a.No = c.No And a.记录性质 = c.记录性质 And
          a.价格父号 Is Null And a.收费细目id = d.材料id(+)
    Order By a.No, a.序号;

  Cursor c_Rollmoneyin
  (
    v_发送号    病人医嘱发送.发送号%Type,
    v_医嘱id    病人医嘱记录.Id%Type,
    t_Adviceids t_Numlist
  ) Is
    Select /*+ Rule*/
     a.Id, a.记录状态, a.No, a.序号, a.收费类别, a.执行状态, d.跟踪在用, a.执行部门id, a.记录性质
    From 住院费用记录 A, Table(t_Adviceids) B, 病人医嘱发送 C, 材料特性 D
    Where c.医嘱id = b.Column_Value And c.发送号 = v_发送号 And a.医嘱序号 = b.Column_Value And
          (a.医嘱序号 = v_医嘱id Or Nvl(v_医嘱id, 0) = 0) And a.记录状态 In (0, 1, 3) And a.No = c.No And a.记录性质 = c.记录性质 And
          a.价格父号 Is Null And a.收费细目id = d.材料id(+)
    Order By a.No, a.序号;

  --取发送住院记帐时自动发放的卫材(还没有退料的)
  Cursor c_Stuff_Drug(v_费用id 药品收发记录.费用id%Type) Is
    Select ID
    From 药品收发记录
    Where 费用id = v_费用id And (记录状态 = 1 Or Mod(记录状态, 3) = 0) And 审核人 Is Not Null
    Order By 药品id;

  --用于处理特殊医嘱的回退
  Cursor c_Patilog
  (
    v_病人id 病人变动记录.病人id%Type,
    v_主页id 病人变动记录.主页id%Type
  ) Is
    Select *
    From 病人变动记录
    Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 Is Null
    Order By 开始时间 Desc;
  r_Patilog c_Patilog%RowType;

  Cursor c_Adviceids Is
    Select ID From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
  t_Adviceids t_Numlist;

  v_医嘱状态     病人医嘱记录.医嘱状态%Type;
  v_医嘱期效     病人医嘱记录.医嘱期效%Type;
  v_费用no       病人医嘱发送.No%Type;
  v_费用序号     Varchar2(255);
  v_末次时间     病人医嘱发送.末次时间%Type;
  v_重整时间     病人医嘱状态.操作时间%Type;
  v_操作类型     诊疗项目目录.操作类型%Type;
  v_执行频率     诊疗项目目录.执行频率%Type;
  v_上次时间     病人医嘱记录.上次执行时间%Type;
  v_执行时间     病人医嘱记录.执行时间方案%Type;
  v_开始执行时间 病人医嘱记录.开始执行时间%Type;
  v_上次打印时间 病人医嘱记录.上次打印时间%Type;
  v_频率间隔     病人医嘱记录.频率间隔%Type;
  v_间隔单位     病人医嘱记录.间隔单位%Type;
  v_发送号       病人医嘱发送.发送号%Type;
  n_护理等级id   病人变动记录.护理等级id%Type;
  d_开始时间     病人变动记录.开始时间%Type;
  d_操作时间     病人医嘱状态.操作时间%Type;
  v_Tmp发送号    病人医嘱发送.发送号%Type;
  n_执行         Number;

  Intdigit   Number(3);
  v_Update   Number(1);
  v_Count    Number(5);
  v_Temp     Varchar2(2000);
  v_人员编号 人员表.编号%Type;
  v_人员姓名 人员表.姓名%Type;
  v_Time     Varchar2(4000);
  n_Blndo    Number;

  v_Error Varchar2(2000);
  Err_Custom Exception;

  Function Checkmoneyundo
  (
    v_No       住院费用记录.No%Type,
    v_记录性质 住院费用记录.记录性质%Type,
    v_序号     住院费用记录.序号%Type,
    n_场合     Number := 0 --0住院，1门诊
  ) Return Number Is
    n_Num      Number;
    n_执行状态 Number;
  Begin
    n_Num := 0;
    If n_场合 = 0 Then
      Select Nvl(Sum(Nvl(付数, 1) * 数次), 0) As 数量
      Into n_Num
      From 住院费用记录
      Where NO = v_No And 记录性质 = v_记录性质 And 序号 = v_序号 And 记录状态 In (2, 3);
      Select Nvl(执行状态, 0)
      Into n_执行状态
      From 住院费用记录
      Where NO = v_No And 记录性质 = v_记录性质 And 序号 = v_序号 And 记录状态 = 3;
    Else
      Select Nvl(Sum(Nvl(付数, 1) * 数次), 0) As 数量
      Into n_Num
      From 门诊费用记录
      Where NO = v_No And 记录性质 = v_记录性质 And 序号 = v_序号 And 记录状态 In (2, 3);
      Select Nvl(执行状态, 0)
      Into n_执行状态
      From 门诊费用记录
      Where NO = v_No And 记录性质 = v_记录性质 And 序号 = v_序号 And 记录状态 = 3;
    End If;
    If n_Num <> 0 Then
      n_Num := 1;
    End If;
    --如果主记录是已执行（部分执行的）则不自动退。
    If n_执行状态 <> 0 Then
      n_Num := 0;
    End If;
    Return(n_Num);
  End;
Begin
  v_Tmp发送号 := -1;
  Open c_Rolladvice;
  Loop
    Fetch c_Rolladvice
      Into r_Rolladvice;
    If c_Rolladvice%RowCount = 0 Then
      Close c_Rolladvice;
      v_Error := Nvl(医嘱内容_In, '该医嘱') || '当前没有可以回退的内容。';
      Raise Err_Custom;
    End If;
    Exit When c_Rolladvice%NotFound;
    Exit When d_操作时间 <> r_Rolladvice.操作时间 And d_操作时间 Is Not Null;
    d_操作时间 := r_Rolladvice.操作时间;
  
    --批量回退调用时判断
    If 医嘱内容_In Is Not Null Then
      If Nvl(r_Rolladvice.操作类型, 0) <> Nvl(操作类型_In, 0) Then
        v_Error := Nvl(医嘱内容_In, '该医嘱') || '不能与当前医嘱一起回退，可能该医嘱已经执行了其他操作。';
        Raise Err_Custom;
      End If;
    End If;
  
    --一组发送号只执行一次
    If v_Tmp发送号 <> r_Rolladvice.发送号 Then
      v_Tmp发送号 := r_Rolladvice.发送号;
      n_执行      := 1;
    Else
      n_执行 := 0;
    End If;
  
    If n_执行 = 1 Then
      Open c_Adviceids;
      Fetch c_Adviceids Bulk Collect
        Into t_Adviceids;
      Close c_Adviceids;
    
      If r_Rolladvice.发送号 = 0 Then
        --回退医嘱状态操作(以时间关键字)
        --4-作废；5-重整；6-暂停；7-启用；8-停止；9-确认停止；10-皮试结果;13-停嘱申请
        ------------------------------------------------------------------
        --最多只能退回到校对状态
        If r_Rolladvice.操作类型 = 3 Then
          v_Error := Nvl(医嘱内容_In, '该医嘱') || '当前处于通过校对状态，不能再回退。';
          Raise Err_Custom;
        Elsif r_Rolladvice.操作类型 = 4 And Nvl(r_Rolladvice.婴儿, 0) = 0 Then
          If r_Rolladvice.类别 = 'H' Then
            Select 操作类型, 执行频率 Into v_操作类型, v_执行频率 From 诊疗项目目录 Where ID = r_Rolladvice.诊疗项目id;
            If v_操作类型 = '1' And v_执行频率 = '2' Then
              v_Error := '护理等级作废后不能再回退。';
              Raise Err_Custom;
            End If;
          End If;
        End If;
      
        --检查是否回退最近次重整之前的操作
        If r_Rolladvice.操作类型 <> 5 Then
          --取最后重整时间
          Select Nvl(医嘱重整时间, To_Date('1900-01-01', 'YYYY-MM-DD'))
          Into v_重整时间
          From 病案主页
          Where 病人id = r_Rolladvice.病人id And 主页id = r_Rolladvice.主页id;
        
          If r_Rolladvice.操作时间 < v_重整时间 Then
            v_Error := '该病人最近次重整之前的操作不能再回退。';
            Raise Err_Custom;
          End If;
        End If;
      
        --删除(该组医嘱)最近的状态操作记录
        Delete /*+ Rule*/
        From 病人医嘱状态
        Where 医嘱id In (Select Column_Value From Table(t_Adviceids)) And 操作时间 = r_Rolladvice.操作时间;
      
        --取删除后应恢复的医嘱状态
        Select 操作类型
        Into v_医嘱状态
        From 病人医嘱状态
        Where 操作时间 = (Select Max(操作时间) From 病人医嘱状态 Where 医嘱id = 医嘱id_In) And 医嘱id = 医嘱id_In;
      
        --恢复(该组医嘱)回退后的状态
        Update 病人医嘱记录 Set 医嘱状态 = v_医嘱状态 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
      
        --其它额外的处理
        If r_Rolladvice.操作类型 = 8 Then
          --被超期发送收回过的医嘱 ，如果是销帐申请模式，则判断对应的“病人费用销帐”申请是否取消，是则允许回退，否则不允许，
          --                       如果是产生负数费用模式，则不允许再回退。
          --可能超期发送收回时被全部收回(无上次执行时间)
          Select /*+ Rule*/
           Nvl(Count(*), 0)
          Into v_Count
          From 病人医嘱记录 A, 病人医嘱发送 B
          Where b.医嘱id = a.Id And (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In) And
                b.发送号 =
                (Select Max(发送号) From 病人医嘱发送 Where 医嘱id In (Select Column_Value From Table(t_Adviceids))) And
                a.执行终止时间 Is Not Null And ((a.上次执行时间 < b.末次时间) Or (a.上次执行时间 Is Null And b.末次时间 Is Not Null));
          If v_Count > 0 Then
            If zl_GetSysParameter('超期收回产生负数费用', 1254) = '1' Then
              v_Error := Nvl(医嘱内容_In, '该医嘱') || '已被超期发送收回，不能再撤消停止操作。';
              Raise Err_Custom;
            Else
              --如果已经取消销帐申请，则允许回退.
              Select Count(1)
              Into v_Count
              From 病人费用销帐 A, 住院费用记录 B, 病人医嘱记录 C
              Where a.费用id = b.Id And c.Id = b.医嘱序号 And (c.Id = 医嘱id_In Or c.相关id = 医嘱id_In);
              If v_Count > 0 Then
                v_Error := Nvl(医嘱内容_In, '该医嘱') || '已被超期发送收回，不能再撤消停止操作。';
                Raise Err_Custom;
              Else
                --得到上次执行时间等信息
                Select 上次执行时间, 执行时间方案, 开始执行时间, 上次打印时间, 频率间隔, 间隔单位
                Into v_上次时间, v_执行时间, v_开始执行时间, v_上次打印时间, v_频率间隔, v_间隔单位
                From 病人医嘱记录
                Where ID = 医嘱id_In;
                v_上次时间 := To_Date(To_Char(v_上次时间 + 1 / 24 / 60 / 60, 'yyyy-MM-dd hh24:mi:ss'), 'yyyy-MM-dd hh24:mi:ss');
              
                --修改上次执行时间为收回后的末次执行时间。
                v_末次时间 := Null;
                Begin
                  --一组医嘱的发送首末时间相同,一并给药是取最小的
                  --取相关ID为NULL的医嘱的发送记录的时间
                  --但给药途径或中药用法可能未填写发送记录
                  Select /*+ Rule*/
                   末次时间, 发送号
                  Into v_末次时间, v_发送号
                  From 病人医嘱发送
                  Where 医嘱id In (Select Column_Value From Table(t_Adviceids)) And
                        发送号 = (Select Max(发送号)
                               From 病人医嘱发送
                               Where 医嘱id In (Select Column_Value From Table(t_Adviceids))) And Rownum = 1;
                Exception
                  When Others Then
                    Null;
                End;
                Update 病人医嘱记录 Set 上次执行时间 = v_末次时间 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
              
                --还原医嘱执行时间
                Select Zl_Adviceexetimes(医嘱id_In, v_上次时间, v_末次时间, v_执行时间, v_开始执行时间, v_上次打印时间, v_频率间隔, v_间隔单位, 0)
                Into v_Time
                From Dual;
                Insert Into 医嘱执行时间
                  (要求时间, 医嘱id, 发送号)
                  Select To_Date(Column_Value, 'yyyy-mm-dd hh24:mi:ss'), 医嘱id_In, v_发送号
                  From Table(f_Str2list(v_Time));
              End If;
            End If;
          End If;
        
          --护理等级变动，后续有其他变动时，不允许回退
          If r_Rolladvice.类别 = 'H' And Nvl(r_Rolladvice.婴儿, 0) = 0 Then
            Select 操作类型, 执行频率 Into v_操作类型, v_执行频率 From 诊疗项目目录 Where ID = r_Rolladvice.诊疗项目id;
            If v_操作类型 = '1' And v_执行频率 = '2' Then
              Select Count(*), Max(a.护理等级id), Max(a.开始时间)
              Into v_Count, n_护理等级id, d_开始时间
              From 病人变动记录 A
              Where a.病人id = r_Rolladvice.病人id And a.主页id = r_Rolladvice.主页id And a.开始原因 = 6 And a.终止时间 Is Null And
                    a.附加床位 = 0;
              --如果没有找到最后一条是护理等级变动则禁止
              If v_Count = 0 Then
                --医嘱护理等级和入住时候的护理等级一致时要单独判断
                Select Count(*)
                Into v_Count
                From 病人变动记录 A
                Where a.病人id = r_Rolladvice.病人id And a.主页id = r_Rolladvice.主页id And a.开始原因 = 6;
                If v_Count > 0 Then
                  v_Error := '由于护理等级医嘱停止后该病人已经产生了其他变动记录,不能回退该医嘱的停止操作。';
                  Raise Err_Custom;
                End If;
              Else
                --如果n_护理等级ID为Null，则检查是否是当前回退的医嘱对应的变动记录,目的是有多个护理等级医嘱时要求按顺序回退。
                --如果n_护理等级ID不为Null，则有可能是校对下一条护理等级时，自动停止的，未产生变动记录，
                --     则需要检查当前最后一条变动的护理等级ID是否是当前医嘱的护理等级ID,目的是有多个护理等级医嘱时要求按顺序回退，如果是则不需要再撤销最后一次变动，直接回退医嘱即可。
                If n_护理等级id Is Null Then
                  Select Count(*)
                  Into v_Count
                  From 病人变动记录 B, 病人医嘱计价 C
                  Where b.病人id = r_Rolladvice.病人id And b.主页id = r_Rolladvice.主页id And c.医嘱id = 医嘱id_In And
                        c.收费细目id = b.护理等级id And b.终止时间 = d_开始时间 And b.终止原因 = 6 And b.附加床位 = 0;
                Else
                  --开始时间只取分钟对比，校对的时候护理等级的开始时间是医嘱开始时间+当前时间的秒钟
                  Select Count(*)
                  Into v_Count
                  From 病人医嘱计价 C, 病人医嘱记录 A
                  Where a.Id = c.医嘱id And a.Id = 医嘱id_In And c.收费细目id = n_护理等级id And
                        a.开始执行时间 = To_Date(To_Char(d_开始时间, 'yyyy-mm-dd hh24:mi'), 'yyyy-mm-dd hh24:mi');
                End If;
                If v_Count = 0 Then
                  v_Error := '您回退的医嘱不是最后一条护理等级医嘱，请将后面的护理等级医嘱作废后再回退本条医嘱。';
                  Raise Err_Custom;
                End If;
              
                If n_护理等级id Is Null Then
                  --当前操作人员
                  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
                    v_人员编号 := 操作员编号_In;
                    v_人员姓名 := 操作员姓名_In;
                  Else
                    v_Temp     := Zl_Identity;
                    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
                    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
                    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
                    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
                  End If;
                
                  Zl_病人变动记录_Undo(r_Rolladvice.病人id, r_Rolladvice.主页id, v_人员编号, v_人员姓名, '1', Null, Null, '护理等级变动');
                End If;
              End If;
            End If;
          End If;
          
          If r_Rolladvice.类别 = 'Z' And  Instr(',9,10,', Nvl(r_Rolladvice.类型, '0')) > 0 And Nvl(r_Rolladvice.婴儿, 0) = 0 Then 
            --回退病况医嘱时，调用变动记录回退
            Zl_病人变动记录_Undo(r_Rolladvice.病人id, r_Rolladvice.主页id, v_人员编号, v_人员姓名, Null, Null, Null, '病况变动'); 
          End If;
        
          --回退医嘱停止时,清空停嘱医生和时间,如果是实习医师申请后审核的，则恢复待审核状态
          Update 病人医嘱记录
          Set 执行终止时间 = Decode(Flag_In, 1, 执行终止时间, Null), 停嘱医生 = Null, 停嘱时间 = Null,
              审核标记 = Decode(r_Rolladvice.审核标记, 3, 2, r_Rolladvice.审核标记)
          Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
        Elsif r_Rolladvice.操作类型 = 9 Then
          --回退医嘱确认停止时,检查是否已打印停嘱时间
          Select /*+ Rule*/
           Count(*)
          Into v_Count
          From 病人医嘱打印
          Where 打印标记 = 1 And 医嘱id In (Select Column_Value From Table(t_Adviceids));
          If v_Count > 0 Then
            v_Error := Nvl(医嘱内容_In, '该医嘱') || '的停嘱时间已经打印，不能再撤消确认停止操作。';
            Raise Err_Custom;
          End If;
        
          --回退医嘱确认停止时,清空停嘱医生和时间
          Update 病人医嘱记录 Set 确认停嘱时间 = Null, 确认停嘱护士 = Null Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
        Elsif r_Rolladvice.操作类型 = 10 Then
          --回退标注皮试结果,同时删除过敏登记(+)或(-),根据记录时间
    --过敏的记录与医嘱操作无观，不需要处理
          Delete From 病人过敏记录
          Where 病人id = r_Rolladvice.病人id And Nvl(主页id, 0) = Nvl(r_Rolladvice.主页id, 0) And 记录时间 = r_Rolladvice.操作时间 And Nvl(结果,0)=0;
        
          Update 病人医嘱记录 Set 皮试结果 = Null Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
        Elsif r_Rolladvice.操作类型 = 13 Then
          If Instr(r_Rolladvice.开嘱医生, '/') > 0 Then
            Update 病人医嘱记录 Set 审核标记 = 1 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
          Else
            Update 病人医嘱记录 Set 审核标记 = Null Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
          End If;
        End If;
      Else
        --回退医嘱发送(以发送号关键字)
        ------------------------------------------------------------------
        --当前操作人员
        v_Temp     := Zl_Identity;
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
        v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
        v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
      
        --检查是否是输液配液记录，并是否已经锁定，如果查询有数据说明是配液记录
        Begin
          Select Decode(Max(是否锁定), 1, 1, 0)
          Into v_Count
          From 输液配药记录
          Where 医嘱id = 医嘱id_In And 发送号 = r_Rolladvice.发送号;
        Exception
          When Others Then
            v_Count := -1;
        End;
      
        If v_Count = 1 Then
          v_Error := '医嘱"' || 医嘱内容_In || '"是输液药品，已经被输液配置中心锁定，不能回退发送。';
          Raise Err_Custom;
        Elsif v_Count = 0 Then
          Zl_输液配药记录_医嘱回退(医嘱id_In, r_Rolladvice.发送号, v_人员姓名, Sysdate);
        End If;
        
        --检查是否存在未审核的销帐申请
        Select Count(*) 
        into v_Count
        From 病人医嘱记录 A, 病人医嘱发送 B, 住院费用记录 C, 病人费用销帐 D
        Where (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In) And a.Id = b.医嘱id And b.医嘱id = c.医嘱序号 And c.Id = d.费用id And c.记录状态 In (0, 1, 3) And
              d.状态 = 0;
              
        If v_Count > 0 Then
          v_Error := '医嘱"' || 医嘱内容_In || '"存在未审核的销帐申请，请取消或审核销帐申请后再回退发送。';
          Raise Err_Custom;
        End If;
      
        --检查医嘱是否存在有效的医嘱附费
        Select Count(*)
        Into v_Count
        From 病人医嘱附费 A, 住院费用记录 B
        Where a.医嘱id = b.医嘱序号 And a.No = b.No And b.记录状态 = 1 And b.实收金额 <> 0 And a.发送号 = r_Rolladvice.发送号;
        If v_Count > 0 Then
          v_Error := '该医嘱下还存在附费项目，请先冲销。';
          Raise Err_Custom;
        End If;
      
        --本科发送自动执行时，回退也自动回退执行(仅护士站有此功能)
        --非跟踪在用的卫材医嘱，同普通医嘱执行处理
        Select 医嘱期效 Into v_医嘱期效 From 病人医嘱记录 Where ID = 医嘱id_In;
        If Substr(zl_GetSysParameter('本科执行自动完成', 1254), v_医嘱期效 + 1, 1) = '1' Then
          Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into Intdigit From Dual;
        
          For r_Rollsend In c_Rollsend(r_Rolladvice.发送号) Loop
            If Nvl(r_Rollsend.执行状态, 0) = 1 And
               (Nvl(r_Rollsend.执行科室id, 0) = Nvl(r_Rollsend.病人病区id, 0) Or
                Nvl(r_Rollsend.执行科室id, 0) = Nvl(r_Rollsend.病人科室id, 0)) Then
            
              --医嘱的执行状态
              Update 病人医嘱发送 Set 执行状态 = 0 Where 发送号 = r_Rollsend.发送号 And 医嘱id = r_Rollsend.医嘱id;
              v_Update := 1;
            
              If r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 0 Then
                --费用的执行状态
                For r_Rollmoney In c_Rollmoneyin(r_Rollsend.发送号, r_Rollsend.医嘱id, t_Adviceids) Loop
                  n_Blndo := 0;
                  If r_Rollmoney.记录状态 <> 3 Then
                    n_Blndo := 1;
                  Else
                    n_Blndo := Checkmoneyundo(r_Rollmoney.No, r_Rollmoney.记录性质, r_Rollmoney.序号);
                  End If;
                  If n_Blndo > 0 Then
                    If Not (r_Rollmoney.收费类别 = '4' And Nvl(r_Rollmoney.跟踪在用, 0) = 1) And
                       Not r_Rollmoney.收费类别 In ('5', '6', '7') Then
                      --普通费用直接取消执行状态，不含药品和跟踪在用的卫材
                      Update 住院费用记录
                      Set 执行状态 = 0, 执行时间 = Null, 执行人 = Null
                      Where NO = r_Rollmoney.No And 记录性质 = r_Rolladvice.记录性质 And 记录状态 = r_Rollmoney.记录状态 And
                            Nvl(价格父号, 序号) = r_Rollmoney.序号 And 医嘱序号 = r_Rollsend.医嘱id;
                    Elsif r_Rollmoney.收费类别 = '4' And Nvl(r_Rollmoney.跟踪在用, 0) = 1 Then
                      --跟踪在用的卫材，才自动退料
                        For r_Stuff In c_Stuff_Drug(r_Rollmoney.Id) Loop
                          Zl_材料收发记录_部门退料(r_Stuff.Id, v_人员姓名, Sysdate, Null, Null, Null, Null, 0, v_人员姓名);
                        End Loop;
                    Elsif r_Rollmoney.收费类别 In ('5', '6', '7') Then
                      --住院科室发药的药品自动退药
                      If r_Rollmoney.执行部门id = r_Rollsend.病人病区id Or r_Rollmoney.执行部门id = r_Rollsend.病人科室id Then
                        For r_Drug In c_Stuff_Drug(r_Rollmoney.Id) Loop
                          Zl_药品收发记录_部门退药(r_Drug.Id, v_人员姓名, Sysdate, Null, Null, Null, Null, Null, Null, Intdigit, 2);
                        End Loop;
                      End If;
                    End If;
                  End If;
                End Loop;
              Else
                --住院病人费用发送到门诊的情况，病人来源都是住院的
                For r_Rollmoney In c_Rollmoneyout(r_Rollsend.发送号, r_Rollsend.医嘱id, t_Adviceids) Loop
                  n_Blndo := 0;
                  If r_Rollmoney.记录状态 <> 3 Then
                    n_Blndo := 1;
                  Else
                    n_Blndo := Checkmoneyundo(r_Rollmoney.No, r_Rollmoney.记录性质, r_Rollmoney.序号, 1);
                  End If;
                  If n_Blndo > 0 Then
                    If Not (r_Rollmoney.收费类别 = '4' And Nvl(r_Rollmoney.跟踪在用, 0) = 1) And
                       Not r_Rollmoney.收费类别 In ('5', '6', '7') Then
                      --普通费用直接取消执行状态，不含药品和跟踪在用的卫材
                      Update 门诊费用记录
                      Set 执行状态 = 0, 执行时间 = Null, 执行人 = Null
                      Where NO = r_Rollmoney.No And 记录性质 = r_Rolladvice.记录性质 And 记录状态 = r_Rollmoney.记录状态 And
                            Nvl(价格父号, 序号) = r_Rollmoney.序号 And 医嘱序号 = r_Rollsend.医嘱id;
                    Elsif r_Rollmoney.收费类别 = '4' And Nvl(r_Rollmoney.跟踪在用, 0) = 1 Then
                        --跟踪在用的卫材，才自动退料
                        For r_Stuff In c_Stuff_Drug(r_Rollmoney.Id) Loop
                          Zl_材料收发记录_部门退料(r_Stuff.Id, v_人员姓名, Sysdate, Null, Null, Null, Null, 0, v_人员姓名);
                        End Loop;
                    Elsif r_Rollmoney.收费类别 In ('5', '6', '7') Then
                      --本科室发药的药品自动退药
                      If r_Rollmoney.执行部门id = r_Rollsend.病人病区id Or r_Rollmoney.执行部门id = r_Rollsend.病人科室id Then
                        For r_Drug In c_Stuff_Drug(r_Rollmoney.Id) Loop
                          Zl_药品收发记录_部门退药(r_Drug.Id, v_人员姓名, Sysdate, Null, Null, Null, Null, Null, Null, Intdigit, 1);
                        End Loop;
                      End If;
                    End If;
                  End If;
                End Loop;
              End If;
            End If;
          End Loop;
        End If;
        ------------------------------------------------------------------
        --被超期收回的长期药品医嘱不允许回退(再退费用就多退了)
        If Nvl(r_Rolladvice.医嘱期效, 0) = 0 Then
          If r_Rolladvice.上次执行时间 Is Not Null And r_Rolladvice.末次时间 Is Not Null Then
            If r_Rolladvice.上次执行时间 < r_Rolladvice.末次时间 Then
              v_Error := Nvl(医嘱内容_In, '该医嘱') || '最近超期发送的内容已被收回，不能再回退。';
              Raise Err_Custom;
            End If;
          Elsif r_Rolladvice.上次执行时间 Is Null And r_Rolladvice.末次时间 Is Not Null Then
            --长嘱可能被全部超期收回
            v_Error := Nvl(医嘱内容_In, '该医嘱') || '未被发送，或发送的内容已被全部超期收回，不能再回退。';
            Raise Err_Custom;
          End If;
        End If;
      
        If Nvl(r_Rolladvice.执行状态, 0) In (1, 3) And v_Update <> 1 Then
          --1-完全执行;3-正在执行
          v_Error := Nvl(医嘱内容_In, '该医嘱') || '最近发送的内容已经执行或正在执行，不能回退。';
          Raise Err_Custom;
        Else
          --如果相关医嘱已执行，则也要限制回退（例如：检验的采集方式）
          Select /*+ Rule*/
           Count(1)
          Into v_Count
          From 病人医嘱发送
          Where 医嘱id In (Select Column_Value From Table(t_Adviceids)) And 执行状态 In (1, 3) And
                发送号 =
                (Select Max(发送号) From 病人医嘱发送 Where 医嘱id In (Select Column_Value From Table(t_Adviceids)));
          If v_Count > 0 Then
            v_Error := Nvl(医嘱内容_In, '该医嘱') || '最近发送的内容已经执行或正在执行，不能回退。';
            Raise Err_Custom;
          End If;
        End If;
      
        ------------------------------------------------------------------
        --将该组医嘱的费用销帐(按一组医嘱可能有不同NO处理)
        --如果原始费用已被销帐(或部分销帐),调用过程中有判断
        v_费用no   := Null;
        v_费用序号 := Null;
        If r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 0 Then
          For r_Rollmoney In c_Rollmoneyin(r_Rolladvice.发送号, Null, t_Adviceids) Loop
            --对应的费用已执行
            If Nvl(r_Rollmoney.执行状态, 0) <> 0 Then
              v_Error := Nvl(医嘱内容_In, '该医嘱') || '发送的费用单据"' || r_Rollmoney.No || '"中的内容已被部分或完全执行，不能回退。';
              Raise Err_Custom;
            End If;
            n_Blndo := 0;
            If r_Rollmoney.记录状态 <> 3 Then
              n_Blndo := 1;
            Else
              n_Blndo := Checkmoneyundo(r_Rollmoney.No, r_Rollmoney.记录性质, r_Rollmoney.序号);
            End If;
            If n_Blndo > 0 Then
              --这种仅用于判断部分退药
              If v_费用no <> r_Rollmoney.No And v_费用序号 Is Not Null Then
                Zl_住院记帐记录_Delete(v_费用no, Substr(v_费用序号, 2), v_人员编号, v_人员姓名, 2, 0, 0);
                v_费用序号 := Null;
              End If;
              v_费用no   := r_Rollmoney.No;
              v_费用序号 := v_费用序号 || ',' || r_Rollmoney.序号;
            End If;
          End Loop;
        Else
          For r_Rollmoney In c_Rollmoneyout(r_Rolladvice.发送号, Null, t_Adviceids) Loop
            --对应的费用已执行
            If Nvl(r_Rollmoney.执行状态, 0) <> 0 And Not (Nvl(r_Rollmoney.执行状态, 0) = -1 And Nvl(r_Rollmoney.记录状态, 0) = 0) Then
              v_Error := Nvl(医嘱内容_In, '该医嘱') || '发送的费用单据"' || r_Rollmoney.No || '"中的内容已被部分或完全执行，不能回退。';
              Raise Err_Custom;
            End If;
            --收费单据已收费
            If r_Rollmoney.记录状态 = 1 And Not (r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 1) Then
              v_Error := Nvl(医嘱内容_In, '该医嘱') || '发送的门诊单据"' || r_Rollmoney.No || '"已收费，不能回退。';
              Raise Err_Custom;
            End If;
            n_Blndo := 0;
            If r_Rollmoney.记录状态 <> 3 Then
              n_Blndo := 1;
            Else
              n_Blndo := Checkmoneyundo(r_Rollmoney.No, r_Rollmoney.记录性质, r_Rollmoney.序号, 1);
            End If;
            If n_Blndo > 0 Then
              --这种仅用于判断部分退药
              If v_费用no <> r_Rollmoney.No And v_费用序号 Is Not Null Then
                If r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 1 Then
                  --住院发送为门诊记帐(如果是门诊医生发送为门诊记帐，门诊医嘱没有回退功能)
                  Zl_门诊记帐记录_Delete(v_费用no, v_费用序号, v_人员编号, v_人员姓名);
                Else
                  Zl_门诊划价记录_Delete(v_费用no, Substr(v_费用序号, 2));
                End If;
                v_费用序号 := Null;
              End If;
              v_费用no   := r_Rollmoney.No;
              v_费用序号 := v_费用序号 || ',' || r_Rollmoney.序号;
            End If;
          End Loop;
        End If;
        If v_费用序号 Is Not Null And v_费用no Is Not Null Then
          v_费用序号 := Substr(v_费用序号, 2);
          If r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 0 Then
            Zl_住院记帐记录_Delete(v_费用no, v_费用序号, v_人员编号, v_人员姓名, 2, 0, 0);
          Elsif r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 1 Then
            --住院发送为门诊记帐(如果是门诊医生发送为门诊记帐，门诊医嘱没有回退功能)
            Zl_门诊记帐记录_Delete(v_费用no, v_费用序号, v_人员编号, v_人员姓名);
          Else
            Zl_门诊划价记录_Delete(v_费用no, v_费用序号);
          End If;
        End If;
        --输血医嘱先删除病人医嘱附费
        Delete From 病人医嘱附费 Where 发送号 = r_Rolladvice.发送号 And 医嘱id = 医嘱id_In;
      
        --删除医嘱执行时间 (仅主医嘱ID才产生了记录)
        Delete From 医嘱执行时间 Where 发送号 = r_Rolladvice.发送号 And 医嘱id = 医嘱id_In;
      
        --删除发送记录(该组医嘱的)
        Delete /*+ Rule*/
        From 病人医嘱发送
        Where 发送号 = r_Rolladvice.发送号 And 医嘱id In (Select Column_Value From Table(t_Adviceids));
      
        --标记(该组医嘱)上次执行时间(以上次发送的末次执行时间)
        --所有长嘱(包括持续性长嘱)发送时都填写了末次时间
        --临嘱可能没有，且只可能发送了一次。
        v_末次时间 := Null;
        Begin
          --一组医嘱的发送首末时间相同,一并给药是取最小的
          --取相关ID为NULL的医嘱的发送记录的时间
          --但给药途径或中药用法可能未填写发送记录
          Select /*+ Rule*/
           末次时间
          Into v_末次时间
          From 病人医嘱发送
          Where 医嘱id In (Select Column_Value From Table(t_Adviceids)) And
                发送号 =
                (Select Max(发送号) From 病人医嘱发送 Where 医嘱id In (Select Column_Value From Table(t_Adviceids))) And
                Rownum = 1;
        Exception
          When Others Then
            Null;
        End;
        Update 病人医嘱记录 Set 上次执行时间 = v_末次时间 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
      
        --回退临嘱发送时，同时自动回退停止
        If Nvl(r_Rolladvice.医嘱期效, 0) = 1 Then
          --删除(该组临嘱)最近的停止状态操作记录
          Delete /*+ Rule*/
          From 病人医嘱状态
          Where 医嘱id In (Select Column_Value From Table(t_Adviceids)) And
                操作时间 = (Select Max(操作时间) From 病人医嘱状态 Where 医嘱id = 医嘱id_In) And 操作类型 = 8;
          --r_RollAdvice.操作时间:因发送时间可能不与自动停止时间相同。
        
          --取删除后应恢复的医嘱状态
          Select 操作类型
          Into v_医嘱状态
          From 病人医嘱状态
          Where 操作时间 = (Select Max(操作时间) From 病人医嘱状态 Where 医嘱id = 医嘱id_In) And 医嘱id = 医嘱id_In;
        
          --恢复(该组医嘱)回退后的状态
          Update 病人医嘱记录
          Set 医嘱状态 = v_医嘱状态, 执行终止时间 = Null, 停嘱医生 = Null, 停嘱时间 = Null
          Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
        End If;
      
        --住院特殊医嘱发送后的回退(3-转科;5-出院;6-转院,11-死亡)
        If r_Rolladvice.类别 = 'Z' And Instr(',3,5,6,11,', Nvl(r_Rolladvice.类型, '0')) > 0 And Nvl(r_Rolladvice.婴儿, 0) = 0 Then
          Open c_Patilog(r_Rolladvice.病人id, r_Rolladvice.主页id);
          Fetch c_Patilog
            Into r_Patilog;
          If c_Patilog%Found Then
            If r_Rolladvice.类型 = '3' And r_Patilog.开始原因 = 3 Then
              --取消病人转科状态
              If r_Patilog.开始时间 Is Null Then
                --转科医嘱的特殊处理，当一个病人有两条转科医嘱时，只能回退最近的一条,70443
                Select Count(1)
                Into v_Count
                From 病人医嘱记录 A, 诊疗项目目录 B
                Where a.诊疗项目id = b.Id And a.病人id = r_Rolladvice.病人id And a.主页id = r_Rolladvice.主页id And a.诊疗类别 = 'Z' And
                      b.操作类型 = '3' And a.医嘱状态 = 8 And
                      a.开始执行时间 > (Select 开始执行时间 From 病人医嘱记录 Where ID = 医嘱id_In);
                If v_Count = 0 Then
                  Zl_病人变动记录_Undo(r_Rolladvice.病人id, r_Rolladvice.主页id, v_人员编号, v_人员姓名, Null, Null, Null, '转科');
                Else
                  v_Error := '病人转科已经入科，不能再回退。';
                  Raise Err_Custom;
                End If;
              Else
                v_Error := '病人转科已经入科，不能再回退。';
                Raise Err_Custom;
              End If;
            Elsif r_Rolladvice.类型 In ('5', '6', '11') And r_Patilog.开始原因 = 10 Then
              --取消病人预出院状态
              Zl_病人变动记录_Undo(r_Rolladvice.病人id, r_Rolladvice.主页id, v_人员编号, v_人员姓名, Null, Null, Null, '预出院');
            End If;
          End If;
          Close c_Patilog;
        End If;
      
        --回退病历时机
        --1.特殊事件(只有一条医嘱记录)：手术，7-会诊,8-抢救,11-死亡
        If r_Rolladvice.类别 = 'F' Or r_Rolladvice.类别 = 'Z' And Instr('7,8,11', r_Rolladvice.类型) > 0 Then
          Zl_电子病历时机_Delete(r_Rolladvice.病人id, r_Rolladvice.主页id, '医嘱', r_Rolladvice.开嘱科室id, 医嘱id_In);
        End If;
      
        --2.额外处理：知情同意书(手术相关的知情同意需再次调用，因为附加手术或麻醉项目可能有关联的知情同意书)
        If Instr('C,D,E,F,G,K,L', r_Rolladvice.类别) > 0 Then
          For R In (Select a.Id, a.诊疗类别 From 病人医嘱记录 A Where a.Id = 医嘱id_In Or a.相关id = 医嘱id_In) Loop
            --相关id的一组医嘱不一定是这个类别的，所以要再判断一次类别
            If Instr('C,D,E,F,G,K,L', r.诊疗类别) > 0 Then
              Zl_电子病历时机_Delete(r_Rolladvice.病人id, r_Rolladvice.主页id, '医嘱', r_Rolladvice.开嘱科室id, r.Id);
            End If;
          End Loop;
        End If;
      End If;
    End If;
    Exit When r_Rolladvice.发送号 = 0;
  End Loop;
  Close c_Rolladvice;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱记录_回退;
/

--93964:梁唐彬,2016-03-07,两条相同时间变动记录无法回退问题
Create Or Replace Procedure Zl_病人变动记录_Undo
(
  病人id_In     病案主页.病人id%Type,
  主页id_In     病案主页.主页id%Type,
  操作员编号_In 病人变动记录.操作员编号%Type,
  操作员姓名_In 病人变动记录.操作员姓名%Type,
  数据_In       Varchar2 := Null, --a.转为住院时,清除住院号,b-检查自动记帐费用是否已结帐
  床号_In       Varchar2 := Null, --传入时表示撤销出院时安排到新的床号，原床位被占用在程序中判断
  主床位_In     Varchar2 := Null, --传入时表示撤销出院时安排到新的主床位，原床位被占用在程序中判断
  撤销方式_In   Varchar2 := Null --指明具体撤销操作，如撤销出院、转科等必须输入
) As
  -----------------------------------------------------------
  --说明：1.撤消病人最近一次的变动
  --        2.前提：当病人包床时,对其中一张床位作变动,则所有床位相应产生变动
  -----------------------------------------------------------
  --要撤消的变动记录(如果包床,可能多条)
  Cursor c_Curlog Is
    Select *
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And (终止时间 Is Null Or 终止原因 = 1)
    Order By 终止时间 Desc, 开始时间 Desc;
  r_Curlogrow c_Curlog%Rowtype;

  --撤消后要恢复的变动记录(如果包床,可能多条)
  Cursor c_Prelog
  (
    v_终止时间 病人变动记录.终止时间%Type,
    v_终止原因 病人变动记录.终止原因%Type
  ) Is
    Select *
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_终止时间 And 终止原因 = v_终止原因
    Order By 终止时间 Desc, 开始时间 Desc;
  r_Prelogrow c_Prelog%Rowtype;

  --获取病人原床位所住病人信息
  Cursor c_Prebed
  (
    v_病人id 病案主页.病人id%Type,
    v_主页id 病案主页.主页id%Type
  ) Is
    Select a.床号, c.出院病床, c.出院科室id, c.当前病区id
    From 病人变动记录 a, 床位状况记录 b, 病案主页 c
    Where a.病人id = 病人id_In And a.主页id = 主页id_In And 终止原因 = 4 And a.病区id = b.病区id And a.病人id = c.病人id And
          a.主页id = c.主页id And a.床号 = b.床号
    Order By 终止时间 Desc, 开始时间 Desc;
  r_Prebedrow c_Prebed%Rowtype;

  Cursor c_Prebedpati
  (
    v_出院科室id 病人变动记录.科室id%Type,
    v_病区id     病人变动记录.病区id%Type,
    v_原床号     病人变动记录.床号%Type
  ) Is
    Select a.病人id, c.主页id, a.床号, c.出院病床
    From 病人变动记录 a, 病案主页 c,
         (Select 病人id
           From 床位状况记录
           Where (科室id Is Null Or 科室id = v_出院科室id Or 共用 = 1) And 病区id = v_病区id And 床号 = v_原床号) d
    Where a.病人id = d.病人id And a.主页id = (Select 主页id From 病人信息 Where 病人id = d.病人id) And a.终止原因 = 4 And a.病人id = c.病人id And
          a.主页id = c.主页id
    Order By 终止时间 Desc, 开始时间 Desc;
  r_Prebedpati c_Prebedpati%Rowtype;

  v_开始时间 病人变动记录.开始时间%Type;
  v_开始原因 病人变动记录.开始原因%Type;
  v_终止人员 病人变动记录.终止人员%Type;

  v_Count       Number;
  v_Countcurlog Number;
  v_Countprelog Number;

  Err_Custom Exception;
  v_Error Varchar2(255);

  v_撤销方式     Varchar2(100);
  v_共享号       Zlsystems.共享号%Type;
  v_病案状态     Number(3);
  v_床号串       Varchar2(255);
  v_床号         病人变动记录.床号%Type;
  v_病人id       病人变动记录.病人id%Type;
  v_主页id       病人变动记录.主页id%Type;
  v_病区id       病人变动记录.病区id%Type;
  v_原床号1      病人变动记录.床号%Type;
  v_原床号2      病人变动记录.床号%Type;
  v_当前床号1    病人变动记录.床号%Type;
  v_当前床号2    病人变动记录.床号%Type;
  v_出院科室id   病人变动记录.科室id%Type;
  v_床位等级id   病人变动记录.床位等级id%Type;
  v_险类         病案主页.险类%Type;
  v_姓名         病人信息.姓名%Type;
  n_原科室id     病案主页.出院科室id%Type;
  n_原病区id     病案主页.当前病区id%Type;
  v_母婴转科标志 病案主页.母婴转科标志%Type;
  v_Tmp          Varchar2(100);
  d_开始时间     Date;
Begin
  If 撤销方式_In Is Null Then
    v_Error := '[ZLSOFT]没有指明具体的撤销操作！[ZLSOFT]';
    Raise Err_Custom;
  Else
    v_撤销方式 := 撤销方式_In;
  End If;

  Open c_Curlog;
  Fetch c_Curlog
    Into r_Curlogrow;
  If c_Curlog%Rowcount = 0 Then
    v_Error := '[ZLSOFT]病人当前没有可以撤消的操作！[ZLSOFT]';
    Close c_Curlog;
    Raise Err_Custom;
  End If;
  
  Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id > 主页id_In;
  If v_Count > 0 Then
    v_Error := '[ZLSOFT]您只能对病人的最后一次住院进行撤销操作,本次撤销操作终止![ZLSOFT]';
    Raise Err_Custom;
  End If;
  
  Select Count(Id)
  Into v_Countcurlog
  From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And (终止时间 Is Null Or 终止原因 = 1)
  Order By 终止时间 Desc, 开始时间 Desc;

  Select Count(a.床号)
  Into v_Countprelog
  From 病人变动记录 a, 床位状况记录 b, 病案主页 c
  Where a.病人id = 病人id_In And a.主页id = 主页id_In And 终止原因 = 4 And a.病区id = b.病区id And a.病人id = c.病人id And a.主页id = c.主页id And
        a.床号 = b.床号
  Order By 终止时间 Desc, 开始时间 Desc;

  --判断是否撤消床位对换
  If v_撤销方式 = '换床' And v_Countcurlog <= 1 And v_Countprelog <= 1 Then
    Open c_Prebed(病人id_In, 主页id_In);
    Fetch c_Prebed
      Into r_Prebedrow;
  
    v_出院科室id := r_Prebedrow.出院科室id;
    v_病区id     := r_Prebedrow.当前病区id;
    v_原床号1    := r_Prebedrow.床号;
    v_当前床号1  := r_Prebedrow.出院病床;
  
    For r_Prebedpati In c_Prebedpati(v_出院科室id, v_病区id, v_原床号1) Loop
      v_病人id    := r_Prebedpati.病人id;
      v_主页id    := r_Prebedpati.主页id;
      v_原床号2   := r_Prebedpati.床号;
      v_当前床号2 := r_Prebedpati.出院病床;
    
      If v_病人id <> 0 And v_主页id <> 0 And v_原床号1 = v_当前床号2 And v_原床号2 = v_当前床号1 Then
        v_撤销方式 := '床位对换';
        Select 险类 Into v_险类 From 病案主页 Where 病人id = v_病人id And 主页id = v_主页id;
        If v_险类 Is Null Then
          Zl_病人变动记录_Undo(v_病人id, v_主页id, 操作员编号_In, 操作员姓名_In, Null, 床号_In, 主床位_In, v_撤销方式);
        Else
          Zl_病人变动记录_Undo(v_病人id, v_主页id, 操作员编号_In, 操作员姓名_In, '1', 床号_In, 主床位_In, v_撤销方式);
        End If;
      End If;
    
      --只对最近一次床位是对方床位的记录进行处理
      Exit;
    End Loop;
  End If;

  If r_Curlogrow.终止时间 Is Null And r_Curlogrow.开始时间 Is Null And r_Curlogrow.开始原因 = 3 And v_撤销方式 = '转科' Then
    --撤消转科(标志)
    Delete From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 Is Null And 终止时间 Is Null And 开始原因 = 3;
  
    Update 病案主页 Set 状态 = 0 Where 病人id = 病人id_In And 主页id = 主页id_In;
  
    Close c_Curlog;
  Elsif r_Curlogrow.终止时间 Is Null And r_Curlogrow.开始时间 Is Null And r_Curlogrow.开始原因 = 15 And v_撤销方式 = '转病区' Then
    --撤消转科(标志)
    Delete From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 Is Null And 终止时间 Is Null And 开始原因 = 15;
  
    Update 病案主页 Set 状态 = 0 Where 病人id = 病人id_In And 主页id = 主页id_In;
  
    Close c_Curlog;
  Elsif r_Curlogrow.终止时间 Is Not Null And r_Curlogrow.终止原因 = 1 And v_撤销方式 = '出院' Then
    --撤消出院
    v_开始时间 := r_Curlogrow.终止时间; --新增的变动记录的开始时间
  
    Select Zl_住院日报_Count(r_Curlogrow.科室id, r_Curlogrow.终止时间) Into v_Count From Dual;
    If v_Count > 0 Then
      v_Error := '[ZLSOFT]已产生业务时间内的住院日报,不能办理该业务![ZLSOFT]';
      Raise Err_Custom;
    End If;
    --是否进行过电子病案审查
    Select Nvl(病案状态, 0) Into v_病案状态 From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
    If v_病案状态 Not In (0, 2) Then
      v_Error := '[ZLSOFT]病人的电子病案已提交审查，不能再撤消出院。[ZLSOFT]';
      Close c_Curlog;
      Raise Err_Custom;
    End If;
  
    --删除病历书写时机
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '出院', r_Curlogrow.科室id);
  
    --恢复入院
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Not Null And 终止原因 = 1;
  
    Select 开始原因
    Into v_开始原因
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And Nvl(附加床位, 0) = 0;
  
    Update 病案主页
    Set 状态 = Decode(v_开始原因, 10, 3, 状态), 出院日期 = Null, 出院方式 = Null, 随诊标志 = Null, 随诊期限 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In;
    --处理床位
    If 床号_In Is Null Then
      --原床位没有被占用,家庭病床也不会被占用(程序中已判断被占用情况,占用会传入床号_In)
      Close c_Curlog;
      For r_Curlogrow In c_Curlog Loop
        If r_Curlogrow.床号 Is Not Null Then
          --检查床位
          Select Count(*)
          Into v_Count
          From 床位状况记录
          Where 病区id = r_Curlogrow.病区id And 床号 = r_Curlogrow.床号 And 状态 = '空床';
          If v_Count = 0 Then
            v_Error := '[ZLSOFT]操作失败,床位 ' || r_Curlogrow.床号 || ' 不是空床！[ZLSOFT]';
            Raise Err_Custom;
          End If;
          --重新占用床位
          Update 床位状况记录
          Set 状态 = '占用', 病人id = 病人id_In, 等级id = r_Curlogrow.床位等级id, 科室id = r_Curlogrow.科室id --强行恢复以前的科室,共用床也不用处理了。
          Where 病区id = r_Curlogrow.病区id And 床号 = r_Curlogrow.床号;
        End If;
      
        If Nvl(r_Curlogrow.附加床位, 0) = 0 Then
          Update 病人信息
          Set 出院时间 = Null, 当前病区id = r_Curlogrow.病区id, 当前科室id = r_Curlogrow.科室id, 当前床号 = r_Curlogrow.床号, 在院 = 1
          Where 病人id = 病人id_In;
        
          --更新在院病人
          Begin
            Update 在院病人
            Set 病区id = Nvl(r_Curlogrow.病区id, 0), 科室id = r_Curlogrow.科室id
            Where 病人id = 病人id_In;
            If Sql%Rowcount = 0 Then
              Insert Into 在院病人
                (病人id, 科室id, 病区id)
              Values
                (病人id_In, r_Curlogrow.科室id, Nvl(r_Curlogrow.病区id, 0));
            End If;
          Exception
            When Others Then
              Null;
          End;
        
        End If;
      End Loop;
    Else
      --原床位被占用，传入新安排的床位,入住一张或多张病床病床
      v_床号串 := 床号_In || ',';
      --如果病人出院前状态为预出院，则撤消预出院
      If v_开始原因 = 10 Then
        --撤消预出院
        Update 病案主页 Set 状态 = 0 Where 病人id = 病人id_In And 主页id = 主页id_In;
        --恢复变动
        Delete From 病人变动记录
        Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 10 And 终止时间 Is Null;
      
        Update 病人变动记录
        Set 终止时间 = v_开始时间, 终止原因 = 4, 终止人员 = 操作员姓名_In
        Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 10 And 终止时间 = r_Curlogrow.开始时间;
      Else
        Update 病人变动记录
        Set 终止时间 = v_开始时间, 终止原因 = 4, 终止人员 = 操作员姓名_In
        Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
      End If;
    
      While v_床号串 Is Not Null Loop
        v_床号 := Substr(v_床号串, 1, Instr(v_床号串, ',') - 1);
        --原始床位等级与新床位等级及数量在程序中判断
        --检查床位
        Select Count(*)
        Into v_Count
        From 床位状况记录
        Where 病区id = r_Curlogrow.病区id And 床号 = v_床号 And 状态 = '空床';
        If v_Count = 0 Then
          v_Error := '操作失败,床位 ' || v_床号 || ' 不是空床！';
          Close c_Curlog;
          Raise Err_Custom;
        End If;
        --更新床位状况记录
        Update 床位状况记录
        Set 状态 = '占用', 病人id = 病人id_In, 科室id = r_Curlogrow.科室id
        Where 病区id = r_Curlogrow.病区id And 床号 = v_床号;
      
        Select 等级id Into v_床位等级id From 床位状况记录 Where 病区id = r_Curlogrow.病区id And 床号 = v_床号;
        ----新增原因为4
        Insert Into 病人变动记录
          (Id, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号,
           操作员姓名)
        Values
          (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, v_开始时间, 4, Decode(主床位_In, v_床号, 0, 1), r_Curlogrow.病区id,
           r_Curlogrow.科室id, r_Curlogrow.医疗小组id, r_Curlogrow.护理等级id, v_床位等级id, v_床号, r_Curlogrow.责任护士, r_Curlogrow.经治医师,
           r_Curlogrow.主治医师, r_Curlogrow.主任医师, r_Curlogrow.病情, 操作员编号_In, 操作员姓名_In);
      
        v_床号串 := Substr(v_床号串, Instr(v_床号串, ',') + 1);
      End Loop;
      --更新病人信息
      Update 病人信息
      Set 出院时间 = Null, 当前病区id = r_Curlogrow.病区id, 当前科室id = r_Curlogrow.科室id, 当前床号 = 主床位_In, 在院 = 1
      Where 病人id = 病人id_In;
    
      --更新在院病人
      Begin
        Update 在院病人 Set 病区id = Nvl(r_Curlogrow.病区id, 0), 科室id = r_Curlogrow.科室id Where 病人id = 病人id_In;
        If Sql%Rowcount = 0 Then
          Insert Into 在院病人
            (病人id, 科室id, 病区id)
          Values
            (病人id_In, r_Curlogrow.科室id, Nvl(r_Curlogrow.病区id, 0));
        End If;
      Exception
        When Others Then
          Null;
      End;
    
      --更新病案主页出院病床
      Update 病案主页 Set 出院病床 = 主床位_In Where 病人id = 病人id_In And 主页id = 主页id_In;
      Close c_Curlog;
    End If;
    --删除出院诊断 保留该诊断信息
    --Delete From 病人诊断记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 诊断类型 in (3,13) And 记录来源 = 2;
  
    Begin
      Select 共享号 Into v_共享号 From Zlsystems Where Floor(编号 / 100) = 3;
    Exception
      When Others Then
        Null;
    End;
    --删除该病人的随诊记录
    If v_共享号 = 100 Then
      Execute Immediate 'Delete From 随诊记录 Where 病人id =:1 And 主页id =:2'
        Using 病人id_In, 主页id_In;
    End If;
  Elsif r_Curlogrow.开始原因 = 1 And v_撤销方式 = '入院入住' Then
    --撤消入科(入院同时入科)
    v_开始时间 := r_Curlogrow.开始时间;
    Select Zl_住院日报_Count(r_Curlogrow.科室id, v_开始时间) Into v_Count From Dual;
    If v_Count > 0 Then
      v_Error := '[ZLSOFT]已产生业务时间内的住院日报,不能办理该业务![ZLSOFT]';
      Raise Err_Custom;
    End If;
  
    Select Count(1)
    Into v_Count
    From 病人护理文件 a, 病人护理数据 b
    Where a.Id = b.文件id And 病人id = 病人id_In And 主页id = 主页id_In And 科室id = r_Curlogrow.科室id And Rownum < 2;
    If v_Count > 0 Then
      v_Error := '[ZLSOFT]病人已产生有数据的护理文件，不能办理该业务！[ZLSOFT]';
      Raise Err_Custom;
    End If;
    Delete From 病人护理文件 Where 病人id = 病人id_In And 主页id = 主页id_In And 科室id = r_Curlogrow.科室id;
  
    Close c_Curlog;
  
    If 数据_In = '1' Then
      For r_Fee In (Select No
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 登记时间 >= v_开始时间
                    Group By No, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        v_Error := '[ZLSOFT]该病人的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
    --退除当前床位
    For r_Curlogrow In c_Curlog Loop
      If r_Curlogrow.床号 Is Not Null Then
        Update 床位状况记录
        Set 状态 = '空床', 病人id = Null, 科室id = Decode(共用, 1, Null, 科室id)
        Where 病区id = r_Curlogrow.病区id And 床号 = r_Curlogrow.床号;
      End If;
    End Loop;
    --相关信息还原
    Update 病案主页 Set 入院病床 = Null, 出院病床 = Null, 状态 = 1 Where 病人id = 病人id_In And 主页id = 主页id_In;
  
    Update 病人信息 Set 当前床号 = Null Where 病人id = 病人id_In;
  
    --恢复变动(入院同时入科不会有包床)
    --因为是同一条记录中的撤消,所以不处理人员
    Update 病人变动记录
    Set 床位等级id = Null, 床号 = Null, 责任护士 = Null, 经治医师 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 1 And 终止时间 Is Null;
  Elsif r_Curlogrow.开始原因 = 2 And v_撤销方式 = '入住' Then
    --撤消入院入科
    v_开始时间 := r_Curlogrow.开始时间;
    Select Zl_住院日报_Count(r_Curlogrow.科室id, v_开始时间) Into v_Count From Dual;
    If v_Count > 0 Then
      v_Error := '[ZLSOFT]已产生业务时间内的住院日报,不能办理该业务![ZLSOFT]';
      Raise Err_Custom;
    End If;
  
    Select Count(1)
    Into v_Count
    From 病人护理文件 a, 病人护理数据 b
    Where a.Id = b.文件id And 病人id = 病人id_In And 主页id = 主页id_In And 科室id = r_Curlogrow.科室id And Rownum < 2;
    If v_Count > 0 Then
      v_Error := '[ZLSOFT]病人已产生有数据的护理文件，不能办理该业务！[ZLSOFT]';
      Raise Err_Custom;
    End If;
    Delete From 病人护理文件 Where 病人id = 病人id_In And 主页id = 主页id_In And 科室id = r_Curlogrow.科室id;
  
    If 数据_In = '1' Then
      For r_Fee In (Select No
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 登记时间 >= v_开始时间
                    Group By No, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        v_Error := '[ZLSOFT]该病人的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
    --删除病历书写时机
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '入院', r_Curlogrow.科室id);
    Close c_Curlog;
    --退除当前床位
    For r_Curlogrow In c_Curlog Loop
      If r_Curlogrow.床号 Is Not Null Then
        Update 床位状况记录
        Set 状态 = '空床', 病人id = Null, 科室id = Decode(共用, 1, Null, 科室id)
        Where 病区id = r_Curlogrow.病区id And 床号 = r_Curlogrow.床号;
      End If;
    End Loop;
    --相关信息还原
    Open c_Prelog(v_开始时间, 2);
    Fetch c_Prelog
      Into r_Prelogrow;
    Update 病案主页
    Set 入院病床 = Null, 出院病床 = Null, 状态 = 1, 当前病况 = r_Prelogrow.病情, 入院病况 = r_Prelogrow.病情, 医疗小组id = r_Prelogrow.医疗小组id,
        护理等级id = r_Prelogrow.护理等级id
    Where 病人id = 病人id_In And 主页id = 主页id_In;
    Close c_Prelog;
  
    Update 病人信息 Set 当前床号 = Null Where 病人id = 病人id_In;
    Delete 病案主页从表
    Where 病人id = 病人id_In And 主页id = 主页id_In And (信息名 = '主治医师' Or 信息名 = '主任医师');
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 2 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 2 And 终止时间 = v_开始时间;
  Elsif r_Curlogrow.开始原因 = 3 And v_撤销方式 = '转科入住' Then
    --撤消转科入科
    v_开始时间 := r_Curlogrow.开始时间;
    Select Zl_住院日报_Count(r_Curlogrow.科室id, v_开始时间) Into v_Count From Dual;
    If v_Count > 0 Then
      v_Error := '[ZLSOFT]已产生业务时间内的住院日报,不能办理该业务![ZLSOFT]';
      Raise Err_Custom;
    End If;
  
    Select Count(1)
    Into v_Count
    From 病人护理文件
    Where 病人id = 病人id_In And 主页id = 主页id_In And 科室id = r_Curlogrow.科室id And 创建时间 >= r_Curlogrow.开始时间;
    If v_Count > 0 Then
      v_Error := '[ZLSOFT]病人已产生护理文件，不能办理该业务！[ZLSOFT]';
      Raise Err_Custom;
    End If;
  
    If 数据_In = '1' Then
      For r_Fee In (Select No
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 登记时间 >= v_开始时间
                    Group By No, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        v_Error := '[ZLSOFT]该病人的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
  
    --删除病历书写时机
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '转科', r_Curlogrow.科室id);
    Close c_Curlog;
    --退除当前床位
    For r_Curlogrow In c_Curlog Loop
      If r_Curlogrow.床号 Is Not Null Then
        Update 床位状况记录
        Set 状态 = '空床', 病人id = Null, 科室id = Decode(共用, 1, Null, 科室id)
        Where 病区id = r_Curlogrow.病区id And 床号 = r_Curlogrow.床号;
      End If;
    End Loop;
    --检查及还原原床位
    For r_Prelogrow In c_Prelog(v_开始时间, 3) Loop
      d_开始时间 := r_Prelogrow.开始时间;
      If r_Prelogrow.床号 Is Not Null Then
        Select Count(*)
        Into v_Count
        From 床位状况记录
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号 And 状态 = '空床';
        If v_Count = 0 Then
          v_Error := '[ZLSOFT]病人转入该科室前的床位 ' || r_Prelogrow.床号 || ' 当前非空床或已经撤消！[ZLSOFT]';
          Raise Err_Custom;
        End If;
      
        Update 床位状况记录
        Set 状态 = '占用', 病人id = 病人id_In, 等级id = r_Prelogrow.床位等级id, 科室id = r_Prelogrow.科室id --强行恢复以前的科室,共用床也不用处理了。
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号;
      End If;
      --相关信息还原
      If Nvl(r_Prelogrow.附加床位, 0) = 0 Then
        --判断是否有婴儿
        Select Count(1) Into v_Count From 病人新生儿记录 Where 病人id = 病人id_In And 主页id = 主页id_In;
        If v_Count > 0 Then
          Select 母婴转科标志 Into v_母婴转科标志 From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
          If v_母婴转科标志 Is Not Null Then
            If Substr(v_母婴转科标志, Length(v_母婴转科标志)) = '1' Then
              --如果是1表示母亲和婴儿未分开，则清空“病案主页.婴儿科室ID”和”病案主页.婴儿病区ID”；
              Update 病案主页 Set 婴儿科室id = Null, 婴儿病区id = Null Where 病人id = 病人id_In And 主页id = 主页id_In;
              If Length(v_母婴转科标志) > 1 Then
                v_母婴转科标志 := Substr(v_母婴转科标志, 1, Length(v_母婴转科标志) - 1);
              Else
                v_母婴转科标志 := '';
              End If;
            Else
              --如果是0，表示是上次转科是母亲单独转走的，则重新将原产科科室和病区填写到“病案主页.婴儿科室ID”和”病案主页.婴儿病区ID”（从病人变动记录中取），并清除最后一位标识
              If Length(v_母婴转科标志) > 1 Then
                v_母婴转科标志 := Substr(v_母婴转科标志, 1, Length(v_母婴转科标志) - 1);
                --查看上一次转科的标识
                If Substr(v_母婴转科标志, Length(v_母婴转科标志)) = '1' Then
                  Update 病案主页
                  Set 婴儿科室id = Null, 婴儿病区id = Null
                  Where 病人id = 病人id_In And 主页id = 主页id_In;
                Else
                  --取出转科前的婴儿科室病区ID
                  v_Tmp   := v_母婴转科标志;
                  v_Count := 1;
                  While v_Tmp Is Not Null Loop
                    v_Count := v_Count + 1;
                    If Substr(v_Tmp, Length(v_Tmp)) = '1' Then
                      Select Max(a.科室id) As 科室id, Max(a.病区id) As 科室id
                      Into n_原科室id, n_原病区id
                      From (Select 科室id, 病区id, Rownum As 序号
                             From (Select 科室id, 病区id
                                    From 病人变动记录
                                    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 3 And 附加床位 = 0
                                    Order By 开始时间 Desc)) a
                      Where 序号 = v_Count;
                    End If;
                    If Length(v_Tmp) = 1 Then
                      v_Tmp := '';
                    Else
                      v_Tmp := Substr(v_Tmp, 1, Length(v_Tmp) - 1);
                    End If;
                  End Loop;
                  If Nvl(n_原科室id, 0) = 0 Then
                    --如果没有找到，则取入院科室
                    Select Max(b.科室id), Max(b.病区id)
                    Into n_原科室id, n_原病区id
                    From 病人变动记录 b
                    Where b.病人id = 病人id_In And b.主页id = 主页id_In And b.科室id Is Not Null And b.病区id Is Not Null And
                          b.开始时间 = (Select Min(a.开始时间)
                                    From 病人变动记录 a
                                    Where a.病人id = b.病人id And a.主页id = b.主页id And a.科室id Is Not Null And
                                          a.病区id Is Not Null And a.附加床位 = 0);
                  End If;
                
                  If Nvl(n_原科室id, 0) <> 0 Then
                    Update 病案主页
                    Set 婴儿科室id = n_原科室id, 婴儿病区id = n_原病区id
                    Where 病人id = 病人id_In And 主页id = 主页id_In;
                  Else
                    --之前没有转科记录,清空婴儿科室ID和婴儿病区ID
                    Update 病案主页
                    Set 婴儿科室id = Null, 婴儿病区id = Null
                    Where 病人id = 病人id_In And 主页id = 主页id_In;
                  End If;
                End If;
              Else
                --只有这一次转科,回退后清空婴儿科室病区ID
                v_母婴转科标志 := '';
                Update 病案主页
                Set 婴儿科室id = Null, 婴儿病区id = Null
                Where 病人id = 病人id_In And 主页id = 主页id_In;
              End If;
            End If;
            --去除最后一位标识
            Update 病案主页 Set 母婴转科标志 = v_母婴转科标志 Where 病人id = 病人id_In And 主页id = 主页id_In;
          End If;
        
        End If;
      
        Update 病案主页
        Set 状态 = 2, 当前病区id = r_Prelogrow.病区id, 出院科室id = r_Prelogrow.科室id, 医疗小组id = r_Prelogrow.医疗小组id,
            出院病床 = r_Prelogrow.床号, 护理等级id = r_Prelogrow.护理等级id, 责任护士 = r_Prelogrow.责任护士, 住院医师 = r_Prelogrow.经治医师,
            当前病况 = r_Curlogrow.病情
        Where 病人id = 病人id_In And 主页id = 主页id_In;
      
        Update 病案主页从表
        Set 信息值 = r_Prelogrow.主治医师
        Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主治医师';
        Update 病案主页从表
        Set 信息值 = r_Prelogrow.主任医师
        Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主任医师';
      
        Update 病人信息
        Set 当前病区id = r_Prelogrow.病区id, 当前科室id = r_Prelogrow.科室id, 当前床号 = r_Prelogrow.床号
        Where 病人id = 病人id_In;
      
        --更新在院病人
        Update 在院病人 Set 病区id = Nvl(r_Prelogrow.病区id, 0), 科室id = r_Prelogrow.科室id Where 病人id = 病人id_In;
      
      End If;
    End Loop;
    --恢复变动(恢复到临时转科标记状态)
    Delete From 病人变动记录
    Where 附加床位 = 1 And 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 3 And 终止时间 Is Null;
  
    Select 终止人员
    Into v_终止人员
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 3 And 终止时间 = v_开始时间 And Nvl(附加床位, 0) = 0;
    --临时记录的操作员信息记录的是终止人员,因为没有记录终止人员编号,就不恢复
    Update 病人变动记录
    Set 开始时间 = Null, 医疗小组id = Null, 护理等级id = Null, 床位等级id = Null, 床号 = Null, 责任护士 = Null, 经治医师 = Null, 操作员编号 = Null,
        操作员姓名 = v_终止人员, 上次计算时间 = Null, 病区id = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 3 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 3 And 终止时间 = v_开始时间 And 开始时间 = d_开始时间;
  
  Elsif r_Curlogrow.开始原因 = 4 And v_撤销方式 = '换床' Then
    --撤消换床
    v_开始时间 := r_Curlogrow.开始时间;
    Close c_Curlog;
    If 数据_In = '1' Then
      For r_Fee In (Select No
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 登记时间 >= v_开始时间
                    Group By No, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        v_Error := '[ZLSOFT]该病人的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
    --退除当前床位
    For r_Curlogrow In c_Curlog Loop
      If r_Curlogrow.床号 Is Not Null Then
        Update 床位状况记录
        Set 状态 = '空床', 病人id = Null, 科室id = Decode(共用, 1, Null, 科室id)
        Where 病区id = r_Curlogrow.病区id And 床号 = r_Curlogrow.床号;
      End If;
    End Loop;
    --检查及还原原床位
    For r_Prelogrow In c_Prelog(v_开始时间, 4) Loop
      d_开始时间 := r_Prelogrow.开始时间;
      If r_Prelogrow.床号 Is Not Null Then
        Select Count(*)
        Into v_Count
        From 床位状况记录
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号 And 状态 = '空床';
        If v_Count = 0 Then
          v_Error := '[ZLSOFT]病人最近一次换床前所入住的床位 ' || r_Prelogrow.床号 || ' 当前非空床或已经撤消！[ZLSOFT]';
          Raise Err_Custom;
        End If;
      
        Update 床位状况记录
        Set 状态 = '占用', 病人id = 病人id_In, 等级id = r_Prelogrow.床位等级id, 科室id = Decode(共用, 1, r_Prelogrow.科室id, 科室id)
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号;
      End If;
      --病人信息、病案主页,仅当病区与科室独立时,换床才可以换病区,此处为简化判断,统一还原病区
      If Nvl(r_Prelogrow.附加床位, 0) = 0 Then
        Update 病案主页
        Set 出院病床 = r_Prelogrow.床号, 当前病区id = r_Prelogrow.病区id
        Where 病人id = 病人id_In And 主页id = 主页id_In;
      
        Update 病人信息 Set 当前床号 = r_Prelogrow.床号, 当前病区id = r_Prelogrow.病区id Where 病人id = 病人id_In;
        --更新在院病人
        Update 在院病人 Set 病区id = Nvl(r_Prelogrow.病区id, 0) Where 病人id = 病人id_In;
      End If;
    End Loop;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 4 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 4 And 终止时间 = v_开始时间 And 开始时间 = d_开始时间;
  Elsif r_Curlogrow.开始原因 = 4 And v_撤销方式 = '床位对换' Then
    --撤消床位对换
    v_开始时间 := r_Curlogrow.开始时间;
    Select 姓名 Into v_姓名 From 病人信息 Where 病人id = 病人id_In;
    Close c_Curlog;
    If 数据_In = '1' Then
      For r_Fee In (Select No
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 登记时间 >= v_开始时间
                    Group By No, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        v_Error := '[ZLSOFT]病人 ' || v_姓名 || ' 的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
    --退除当前床位
    --检查及还原原床位
    For r_Prelogrow In c_Prelog(v_开始时间, 4) Loop
      d_开始时间 := r_Prelogrow.开始时间;
      If r_Prelogrow.床号 Is Not Null Then
        Update 床位状况记录
        Set 状态 = '占用', 病人id = 病人id_In, 等级id = r_Prelogrow.床位等级id, 科室id = Decode(共用, 1, r_Prelogrow.科室id, 科室id)
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号;
      End If;
      --病人信息、病案主页,仅当病区与科室独立时,换床才可以换病区,此处为简化判断,统一还原病区
      If Nvl(r_Prelogrow.附加床位, 0) = 0 Then
        Update 病案主页
        Set 出院病床 = r_Prelogrow.床号, 当前病区id = r_Prelogrow.病区id
        Where 病人id = 病人id_In And 主页id = 主页id_In;
      
        Update 病人信息 Set 当前床号 = r_Prelogrow.床号, 当前病区id = r_Prelogrow.病区id Where 病人id = 病人id_In;
        --更新在院病人
        Update 在院病人 Set 病区id = Nvl(r_Prelogrow.病区id, 0) Where 病人id = 病人id_In;
      End If;
    End Loop;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 4 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 4 And 终止时间 = v_开始时间 And 开始时间 = d_开始时间;
  Elsif r_Curlogrow.开始原因 = 5 And v_撤销方式 = '床位等级变动' Then
    --撤消床位等级变动
    If 数据_In = '1' Then
      For r_Fee In (Select No
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 收费细目id = r_Curlogrow.床位等级id And
                          登记时间 >= r_Curlogrow.开始时间
                    Group By No, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        Close c_Curlog;
        v_Error := '[ZLSOFT]该病人的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
    --还原原床位的等级
    For r_Prelogrow In c_Prelog(r_Curlogrow.开始时间, 5) Loop
      d_开始时间 := r_Prelogrow.开始时间;
      If r_Prelogrow.床号 Is Not Null Then
        Update 床位状况记录
        Set 等级id = r_Prelogrow.床位等级id
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号;
      End If;
    End Loop;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 5 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 5 And 终止时间 = r_Curlogrow.开始时间 And 开始时间 = d_开始时间;
  
    Close c_Curlog;
  Elsif r_Curlogrow.开始原因 = 6 And v_撤销方式 = '护理等级变动' Then
    --撤消护理等级变动
    If 数据_In = '1' Then
      For r_Fee In (Select No
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 收费细目id = r_Curlogrow.护理等级id And
                          登记时间 >= r_Curlogrow.开始时间
                    Group By No, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        Close c_Curlog;
        v_Error := '[ZLSOFT]该病人的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
  
    Open c_Prelog(r_Curlogrow.开始时间, 6);
    Fetch c_Prelog
      Into r_Prelogrow;
    --恢复原护理等级
    Update 病案主页 Set 护理等级id = r_Prelogrow.护理等级id Where 病人id = 病人id_In And 主页id = 主页id_In;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 6 And 终止时间 Is Null;
  
    --医嘱产生的护理等级变动没有记录秒，可能前一等级的停止时间与当前等级的开始时间是同一分钟，所以要取max(id)
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 6 And 终止时间 = r_Curlogrow.开始时间  And 开始时间 = r_Prelogrow.开始时间;
  
    Close c_Prelog;
    Close c_Curlog;
  Elsif r_Curlogrow.开始原因 = 7 And v_撤销方式 = '经治医师改变' Then
    --删除病历书写时机
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '交班', r_Curlogrow.科室id);
    --撤消经治医师改变
    Open c_Prelog(r_Curlogrow.开始时间, 7);
    Fetch c_Prelog
      Into r_Prelogrow;
    --恢复原医师
    Update 病案主页 Set 住院医师 = r_Prelogrow.经治医师 Where 病人id = 病人id_In And 主页id = 主页id_In;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 7 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 7 And 终止时间 = r_Curlogrow.开始时间  And 开始时间 = r_Prelogrow.开始时间;
  
    Close c_Prelog;
    Close c_Curlog;
  Elsif r_Curlogrow.开始原因 = 8 And v_撤销方式 = '责任护士改变' Then
    --撤消责任护士改变
    Open c_Prelog(r_Curlogrow.开始时间, 8);
    Fetch c_Prelog
      Into r_Prelogrow;
    --恢复原责任护士
    Update 病案主页 Set 责任护士 = r_Prelogrow.责任护士 Where 病人id = 病人id_In And 主页id = 主页id_In;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 8 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 8 And 终止时间 = r_Curlogrow.开始时间  And 开始时间 = r_Prelogrow.开始时间;
  
    Close c_Prelog;
    Close c_Curlog;
  Elsif r_Curlogrow.开始原因 = 9 And v_撤销方式 = '转为住院病人' Then
    --撤消转为住院病人
    --删除病历书写时机
    Open c_Prelog(r_Curlogrow.开始时间, 9);
    Fetch c_Prelog
      Into r_Prelogrow;
      
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '入院', r_Curlogrow.科室id);
    Update 病案主页 Set 病人性质 = 2 Where 病人id = 病人id_In And 主页id = 主页id_In;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 9 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 9 And 终止时间 = r_Curlogrow.开始时间 And 开始时间 = r_Prelogrow.开始时间;
  
    If 主页id_In = 1 And Nvl(数据_In, '0') = '1' Then
      Update 病人信息 Set 住院号 = Null Where 病人id = 病人id_In;
      Update 病案主页 Set 住院号 = Null Where 病人id = 病人id_In;
    End If;
  
    Close c_Curlog;
    Close c_Prelog;
  Elsif r_Curlogrow.开始原因 = 10 And v_撤销方式 = '预出院' Then
    --撤消预出院
    --删除病历书写时机
    Open c_Prelog(r_Curlogrow.开始时间, 10);
    Fetch c_Prelog
      Into r_Prelogrow;
      
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '出院', r_Curlogrow.科室id);
    --恢复住院状态
    Update 病案主页 Set 状态 = 0 Where 病人id = 病人id_In And 主页id = 主页id_In;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 10 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 上次计算时间 = Null, 终止人员 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 10 And 终止时间 = r_Curlogrow.开始时间 And 开始时间 = r_Prelogrow.开始时间;
  
    Close c_Curlog;
    Close c_Prelog;
  Elsif r_Curlogrow.开始原因 = 11 And v_撤销方式 = '主治医师变动' Then
    --撤消主治医师改变
    Open c_Prelog(r_Curlogrow.开始时间, 11);
    Fetch c_Prelog
      Into r_Prelogrow;
    --恢复原主治医师
    Update 病案主页从表
    Set 信息值 = r_Prelogrow.主治医师
    Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主治医师';
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 11 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 11 And 终止时间 = r_Curlogrow.开始时间  And 开始时间 = r_Prelogrow.开始时间;
  
    Close c_Prelog;
    Close c_Curlog;
  Elsif r_Curlogrow.开始原因 = 12 And v_撤销方式 = '主任医师变动' Then
    --撤消主任医师改变
    Open c_Prelog(r_Curlogrow.开始时间, 12);
    Fetch c_Prelog
      Into r_Prelogrow;
    --恢复原主任医师
    Update 病案主页从表
    Set 信息值 = r_Prelogrow.主任医师
    Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主任医师';
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 12 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 12 And 终止时间 = r_Curlogrow.开始时间  And 开始时间 = r_Prelogrow.开始时间;
  
    Close c_Prelog;
    Close c_Curlog;
  Elsif r_Curlogrow.开始原因 = 13 And v_撤销方式 = '病况变动' Then
    --撤消病情改变
    Open c_Prelog(r_Curlogrow.开始时间, 13);
    Fetch c_Prelog
      Into r_Prelogrow;
    --恢复原病情
    Update 病案主页 Set 当前病况 = r_Prelogrow.病情 Where 病人id = 病人id_In And 主页id = 主页id_In;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 13 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 13 And 终止时间 = r_Curlogrow.开始时间 And 开始时间 = r_Prelogrow.开始时间;
  
    Close c_Prelog;
    Close c_Curlog;
  
  Elsif r_Curlogrow.开始原因 = 14 And v_撤销方式 = '转医疗小组' Then
    --删除病历书写时机
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '交班', r_Curlogrow.科室id);
  
    --撤消医疗小组改变
    Open c_Prelog(r_Curlogrow.开始时间, 14);
    Fetch c_Prelog
      Into r_Prelogrow;
    --恢复原医疗小组
    Update 病案主页
    Set 医疗小组id = r_Prelogrow.医疗小组id, 住院医师 = r_Prelogrow.经治医师
    Where 病人id = 病人id_In And 主页id = 主页id_In;
    --恢复原主治医师
    Update 病案主页从表
    Set 信息值 = r_Prelogrow.主治医师
    Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主治医师';
  
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 14 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 14 And 终止时间 = r_Curlogrow.开始时间  And 开始时间 = r_Prelogrow.开始时间;
  
    Close c_Prelog;
    Close c_Curlog;
  Elsif r_Curlogrow.开始原因 = 15 And v_撤销方式 = '转病区入住' Then
    --撤消入病区
    v_开始时间 := r_Curlogrow.开始时间;
  
    If 数据_In = '1' Then
      For r_Fee In (Select No
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 登记时间 >= v_开始时间
                    Group By No, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        v_Error := '[ZLSOFT]该病人的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
  
    Open c_Prelog(v_开始时间, 15);
    Fetch c_Prelog
      Into r_Prelogrow;
  
    d_开始时间 := r_Prelogrow.开始时间;
    --对有效的医嘱(未停止、作废的长嘱，未发送的临嘱)，为原病区执行的，将执行科室自动更换为新的病区
    Update 病人医嘱记录
    Set 执行科室id = r_Prelogrow.病区id
    Where 病人id = 病人id_In And 主页id = 主页id_In And 执行科室id = r_Curlogrow.病区id And 医嘱状态 Not In (4, 8, 9) And 开嘱时间 < v_开始时间;
    --对未审核的记帐划价单，为原病区执行的，将执行科室自动更换为新的病区
    Update 住院费用记录
    Set 执行部门id = r_Prelogrow.病区id
    Where 病人id = 病人id_In And 主页id = 主页id_In And 执行部门id = r_Curlogrow.病区id And 记录状态 = 0;
    Close c_Prelog;
    Close c_Curlog;
  
    --退除当前床位
    For r_Curlogrow In c_Curlog Loop
      If r_Curlogrow.床号 Is Not Null Then
        Update 床位状况记录
        Set 状态 = '空床', 病人id = Null, 科室id = Decode(共用, 1, Null, 科室id)
        Where 病区id = r_Curlogrow.病区id And 床号 = r_Curlogrow.床号;
      End If;
    End Loop;
    --检查及还原原床位
    For r_Prelogrow In c_Prelog(v_开始时间, 15) Loop
      If r_Prelogrow.床号 Is Not Null Then
        Select Count(*)
        Into v_Count
        From 床位状况记录
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号 And 状态 = '空床';
        If v_Count = 0 Then
          v_Error := '[ZLSOFT]病人转入该病区前的床位 ' || r_Prelogrow.床号 || ' 当前非空床或已经撤消！[ZLSOFT]';
          Raise Err_Custom;
        End If;
      
        Update 床位状况记录
        Set 状态 = '占用', 病人id = 病人id_In, 等级id = r_Prelogrow.床位等级id, 科室id = r_Prelogrow.科室id --强行恢复以前的科室,共用床也不用处理了。
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号;
      End If;
      --相关信息还原
      If Nvl(r_Prelogrow.附加床位, 0) = 0 Then
        Update 病案主页
        Set 状态 = 2, 当前病区id = r_Prelogrow.病区id, 出院科室id = r_Prelogrow.科室id, 医疗小组id = r_Prelogrow.医疗小组id,
            出院病床 = r_Prelogrow.床号, 护理等级id = r_Prelogrow.护理等级id, 责任护士 = r_Prelogrow.责任护士, 住院医师 = r_Prelogrow.经治医师,
            当前病况 = r_Curlogrow.病情
        Where 病人id = 病人id_In And 主页id = 主页id_In;
      
        Update 病人信息 Set 当前病区id = r_Prelogrow.病区id, 当前床号 = r_Prelogrow.床号 Where 病人id = 病人id_In;
      
        --更新在院病人
        Update 在院病人 Set 病区id = Nvl(r_Prelogrow.病区id, 0) Where 病人id = 病人id_In;
      
      End If;
    End Loop;
  
    --恢复变动(恢复到临时转科标记状态)
    Delete From 病人变动记录
    Where 附加床位 = 1 And 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 15 And 终止时间 Is Null;
  
    Select 终止人员
    Into v_终止人员
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 15 And 终止时间 = v_开始时间 And Nvl(附加床位, 0) = 0;
    --临时记录的操作员信息记录的是终止人员,因为没有记录终止人员编号,就不恢复
    Update 病人变动记录
    Set 开始时间 = Null, 医疗小组id = Null, 护理等级id = Null, 床位等级id = Null, 床号 = Null, 责任护士 = Null, 经治医师 = Null, 操作员编号 = Null,
        操作员姓名 = v_终止人员, 上次计算时间 = Null, 附加床位 = Null, 主治医师 = Null, 病情 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 15 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 15 And 终止时间 = v_开始时间  And 开始时间 = d_开始时间;
  Else
    Close c_Curlog;
    v_Error := '[ZLSOFT]你执行的撤销' || v_撤销方式 || '操作已经被其他人执行,请刷新界面！[ZLSOFT]';
    Raise Err_Custom;
  End If;
  --并发操作检查
  Select Count(*)
  Into v_Count
  From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(附加床位, 0) = 0 And 开始时间 Is Not Null And 终止时间 Is Null;
  If v_Count > 1 Then
    v_Error := '发现病人存在非法的变动记录,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;

  Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In And 出院日期 Is Null;
  If v_Count = 0 Then
    v_Error := '操作失败,该病人已出院,不能进行当前操作' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态！';
    Raise Err_Custom;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, v_Error);
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人变动记录_Undo;
/

--93917:许华峰,2016-03-16,与RIS的数据交换接口脚本
Create Or Replace Package b_zlXWInterface Is
  Type t_Refcur Is Ref Cursor;

  --1、接收RIS状态改变
  Procedure ReceiveRisState
  (
    医嘱id_In   病人医嘱发送.医嘱id%Type,
    状态_In     Number,
    操作人员_In 病人医嘱发送.完成人%Type,
    执行时间_In 病人医嘱发送.完成时间%Type := Null,
    执行说明_In 病人医嘱发送.执行说明%Type := Null,
    单独执行_In Number := 0
  );

  --2、费用确认
  Procedure 影像费用执行
  (
    医嘱id_In     影像检查记录.医嘱id%Type,
    单独执行_In   Number := 0,
    操作员编号_In 人员表.编号%Type := Null,
    操作员姓名_In 人员表.姓名%Type := Null,
    执行部门id_In 门诊费用记录.执行部门id%Type := Null
  );

  --3、取消费用确认
  Procedure 影像费用执行_Cancel
  (
    医嘱id_In     影像检查记录.医嘱id%Type,
    单独执行_In   Number := 0,
    操作员编号_In 人员表.编号%Type := Null,
    操作员姓名_In 人员表.姓名%Type := Null,
    执行部门id_In 门诊费用记录.执行部门id%Type := Null
  );

  --4、接收RIS的报告
  Procedure ReceiveReport
  (
    医嘱id_In   病人医嘱发送.医嘱id%Type,
    报告所见_In 电子病历内容.内容文本%Type,
    报告意见_In 电子病历内容.内容文本%Type,
    报告建议_In 电子病历内容.内容文本%Type,
    报告医生_In 电子病历记录.创建人%Type
  );

  --5、修改申请单信息
  Procedure 影像病人信息_修改
  (
    医嘱id_In       病人医嘱记录.Id%Type,
    姓名_In         病人信息.姓名%Type,
    性别_In         病人信息.性别%Type,
    年龄_In         病人信息.年龄%Type,
    费别_In         病人信息.费别%Type,
    医疗付款方式_In 病人信息.医疗付款方式%Type,
    民族_In         病人信息.民族%Type,
    婚姻_In         病人信息.婚姻状况%Type,
    职业_In         病人信息.职业%Type,
    身份证号_In     病人信息.身份证号%Type,
    家庭地址_In     病人信息.家庭地址%Type,
    家庭电话_In     病人信息.家庭电话%Type,
    家庭地址邮编_In 病人信息.家庭地址邮编%Type,
    出生日期_In     病人信息.出生日期%Type := Null
  );

  --6、取消申请单信息
  Procedure 取消检查申请单
  (
    医嘱id_In     病人医嘱执行.医嘱id%Type,
    操作员编号_In 人员表.编号%Type := Null,
    操作员姓名_In 人员表.姓名%Type := Null,
    执行部门id_In 门诊费用记录.执行部门id%Type := 0,
    拒绝原因_In   病人医嘱发送.执行说明%Type := Null
  );

End b_zlXWInterface;
/

Create Or Replace Package Body b_zlXWInterface Is

  --1、接收RIS状态改变
  Procedure ReceiveRisState
  (
    医嘱id_In   病人医嘱发送.医嘱id%Type,
    状态_In     Number,
    操作人员_In 病人医嘱发送.完成人%Type,
    执行时间_In 病人医嘱发送.完成时间%Type := Null,
    执行说明_In 病人医嘱发送.执行说明%Type := Null,
    单独执行_In Number := 0
  ) Is
  
    --参数：医嘱ID_IN - 单独执行的医嘱ID。
    --      状态_IN - -1-删除；0-预约；1-登记；3-检查完成；4-检查中止；9-初步报告；12-报告审核；15-发放
    --     单独执行_In -0-全部执行；1-单独执行；检查医嘱组合是否采用对每个项目分散单独执行的方式
  
    Cursor c_Adviceinfo Is
      Select ID, 相关id, Nvl(相关id, ID) As 组id, 诊疗类别, 病人来源, 执行科室id
      From 病人医嘱记录
      Where ID = 医嘱id_In;
    r_Adviceinfo c_Adviceinfo%RowType;
  
    v_Count Number;
    v_Error Varchar2(255);
    Err_Custom Exception;
    v_执行状态 病人医嘱发送.执行状态%Type;
    v_执行过程 病人医嘱发送.执行过程%Type;
  
  Begin
  
    v_执行状态 := 0;
    v_执行过程 := 0;
  
    --提取医嘱的主医嘱ID，及组ID
    Open c_Adviceinfo;
    Fetch c_Adviceinfo
      Into r_Adviceinfo;
    Close c_Adviceinfo;
  
    --先检查是否已经出院的住院病人，已经预出院或者出院的检查申请，不允许开始检查和审核费用
    Select Count(*)
    Into v_Count
    From 病人医嘱记录 A, 病案主页 B
    Where a.病人id = b.病人id And a.主页id = b.主页id And (b.出院日期 Is Not Null Or b.状态 = 3) And a.Id = r_Adviceinfo.组id;
  
    If v_Count > 0 Then
      v_Error := '住院病人已经出院或者预出院，无法开始检查。';
      Raise Err_Custom;
    End If;
  
    --根据状态_IN执行医嘱
    ---1-删除；0-预约；1-登记；3-检查完成；4-检查中止；9-初步报告；12-报告审核；15-发放
  
    If 状态_In = -1 Or 状态_In = 0 Then
      v_执行状态 := 0; --未执行
      v_执行过程 := 0;
    Elsif 状态_In = 1 Then
      v_执行状态 := 3; --正在执行
      v_执行过程 := 2; --已报到
    Elsif 状态_In = 3 Then
      v_执行状态 := 3; --正在执行
      v_执行过程 := 3; --已检查
    Elsif 状态_In = 4 Then
      --不改变
      v_执行状态 := v_执行状态;
    Elsif 状态_In = 9 Then
      v_执行状态 := 3; --正在执行
      v_执行过程 := 4; --已报告
    Elsif 状态_In = 12 Then
      v_执行状态 := 3; --正在执行
      v_执行过程 := 5; --已审核
    Elsif 状态_In = 15 Then
      v_执行状态 := 1; --完全执行
      v_执行过程 := 6; --已完成
    End If;
  
    --开始执行医嘱
    If Nvl(单独执行_In, 0) = 1 Then
      -- 单个部位医嘱单独执行
      Update 病人医嘱发送
      Set 执行状态 = v_执行状态, 执行过程 = v_执行过程, 执行说明 = 执行说明_In
      Where 医嘱id = 医嘱id_In;
    Else
      Update 病人医嘱发送
      Set 执行状态 = v_执行状态, 执行过程 = v_执行过程, 执行说明 = 执行说明_In
      Where 医嘱id In (Select ID From 病人医嘱记录 Where (ID = r_Adviceinfo.组id Or 相关id = r_Adviceinfo.组id));
    End If;
  
  Exception
    When Err_Custom Then
      Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End Receiverisstate;

  --2、费用确认
  Procedure 影像费用执行
  (
    医嘱id_In     影像检查记录.医嘱id%Type,
    单独执行_In   Number := 0,
    操作员编号_In 人员表.编号%Type := Null,
    操作员姓名_In 人员表.姓名%Type := Null,
    执行部门id_In 门诊费用记录.执行部门id%Type := Null
  ) Is
    --参数：医嘱ID_IN=单独执行的医嘱ID。
    --      单独执行_In=检查医嘱组合是否采用对每个项目分散单独执行的方式,0-不单独执行
    Cursor c_Advice Is
      Select ID, 相关id, Nvl(相关id, ID) As 组id, 诊疗类别, 病人来源 From 病人医嘱记录 Where ID = 医嘱id_In;
    r_Advice c_Advice%RowType;
  
    v_Temp     Varchar2(255);
    v_人员编号 人员表.编号%Type;
    v_人员姓名 人员表.姓名%Type;
    v_部门id   部门表.Id%Type;
    v_费用性质 病人医嘱发送.记录性质%Type;
    v_发送号   病人医嘱发送.发送号%Type;
    v_执行过程 病人医嘱发送.执行过程%Type;
  Begin
  
    Select 发送号, 执行过程 Into v_发送号, v_执行过程 From 病人医嘱发送 Where 医嘱id = 医嘱id_In;
  
    --登记和完成才执行费用  2-登记，3-检查，4-报告，5-审核，6-完成
    If v_执行过程 >= 2 Or v_执行过程 <= 6 Then
    
      --取当前操作人员
      If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null And 执行部门id_In Is Not Null Then
        v_人员编号 := 操作员编号_In;
        v_人员姓名 := 操作员姓名_In;
        v_部门id   := 执行部门id_In;
      Else
        v_Temp     := Zl_Identity;
        v_部门id   := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
        v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
        v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
      End If;
    
      --取主医嘱ID
      Open c_Advice;
      Fetch c_Advice
        Into r_Advice;
      Close c_Advice;
    
      If r_Advice.病人来源 = 2 Then
        Select Decode(记录性质, 1, 1, Decode(门诊记帐, 1, 1, 2))
        Into v_费用性质
        From 病人医嘱发送
        Where 发送号 = v_发送号 And 医嘱id = 医嘱id_In;
      Else
        v_费用性质 := 1;
      End If;
    
      --执行费用和自动发料
      If v_费用性质 = 1 Then
        Zl_门诊医嘱执行_Finish(医嘱id_In, v_发送号, 单独执行_In, v_人员编号, v_人员姓名, r_Advice.组id, r_Advice.诊疗类别, v_部门id);
      Else
        Zl_住院医嘱执行_Finish(医嘱id_In, v_发送号, 单独执行_In, v_人员编号, v_人员姓名, r_Advice.组id, r_Advice.诊疗类别, v_部门id);
      End If;
    End If;
  
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End 影像费用执行;

  --3、取消费用确认
  Procedure 影像费用执行_Cancel
  (
    医嘱id_In     影像检查记录.医嘱id%Type,
    单独执行_In   Number := 0,
    操作员编号_In 人员表.编号%Type := Null,
    操作员姓名_In 人员表.姓名%Type := Null,
    执行部门id_In 门诊费用记录.执行部门id%Type := Null
  ) Is
    --参数：
    --      医嘱ID_IN=单独执行的医嘱ID。
    --      单独执行_In=检查医嘱组合是否采用对每个项目分散单独执行的方式,0-不单独执行
  
    v_发送号 病人医嘱发送.发送号%Type;
  Begin
  
    Select 发送号 Into v_发送号 From 病人医嘱发送 Where 医嘱id = 医嘱id_In;
  
    --调用统一的医嘱执行Cancel过程
    Zl_病人医嘱执行_Cancel(医嘱id_In, v_发送号, Null, 单独执行_In, 执行部门id_In, 操作员编号_In, 操作员姓名_In);
  
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End 影像费用执行_Cancel;

  --4、接收RIS的报告
  Procedure ReceiveReport
  (
    医嘱id_In   病人医嘱发送.医嘱id%Type,
    报告所见_In 电子病历内容.内容文本%Type,
    报告意见_In 电子病历内容.内容文本%Type,
    报告建议_In 电子病历内容.内容文本%Type,
    报告医生_In 电子病历记录.创建人%Type
  ) Is
  
    --提取病人医嘱及报告的相关信息
    Cursor c_Advice(v_组id Number) Is
      Select e.Id, e.病人来源, e.病人id, e.主页id, e.婴儿, e.病人科室id, e.文件id, e.病历种类, e.病历名称, f.病历id, e.执行科室id
      From (Select c.Id, c.病人来源, c.病人id, c.主页id, c.婴儿, c.病人科室id, c.文件id, d.种类 病历种类, d.名称 病历名称, c.执行科室id
             From (Select a.Id, a.病人来源, a.病人id, a.主页id, a.婴儿, a.病人科室id, b.病历文件id 文件id, a.执行科室id
                    From 病人医嘱记录 A, 病历单据应用 B
                    Where a.Id = v_组id And a.诊疗项目id = b.诊疗项目id(+) And b.应用场合(+) = Decode(a.病人来源, 2, 2, 4, 4, 1)) C,
                  病历文件列表 D
             Where c.文件id = d.Id(+)) E, 病人医嘱报告 F
      Where e.Id = f.医嘱id(+);
  
    --查找文件的组成元素
    Cursor c_File(v_File Number) Is
      Select a.Id, a.文件id, a.父id, a.对象序号, a.对象类型, a.对象标记, a.保留对象, a.对象属性, a.内容行次, a.内容文本, a.是否换行, a.预制提纲id, a.复用提纲,
             a.使用时机, a.诊治要素id, a.替换域, a.要素名称, a.要素类型, a.要素长度, a.要素小数, a.要素单位, a.要素表示, a.输入形态, a.要素值域
      From 病历文件结构 A
      Where a.文件id = v_File
      Order By a.对象序号;
  
    Cursor c_Report(v_电子病历记录id Number) Is
      Select /*+ rule */
       b.Id, a.内容文本
      From 电子病历内容 A, 电子病历内容 B
      Where a.文件id = v_电子病历记录id And Nvl(a.定义提纲id, 0) <> 0 And (a.内容文本 Like '%所见%' Or a.内容文本 Like '%意见%' Or a.内容文本 Like '%建议%') And
            b.父id = a.Id And b.是否换行 = 1;
  
    r_Advice        c_Advice%RowType;
    v_病历id        电子病历内容.文件id%Type;
    v_病历内容id    电子病历内容.Id%Type;
    v_病历内容idnew 电子病历内容.Id%Type;
    v_对象序号      电子病历内容.对象序号%Type;
    v_父id          电子病历内容.父id%Type;
    v_内容文本      电子病历内容.内容文本%Type;
    v_定义提纲id    电子病历内容.定义提纲id%Type;
    --v_格式内容    电子病历格式.内容%Type;
    v_Error Varchar2(255);
    Err_Custom Exception;
    v_主医嘱id 病人医嘱发送.医嘱id%Type;
  Begin
  
    -- 提取主医嘱ID ，防止因为传入部位医嘱，导致报告保存出错
    Select Nvl(相关id, ID) As 组id Into v_主医嘱id From 病人医嘱记录 Where ID = 医嘱id_In;
  
    Open c_Advice(v_主医嘱id);
    Fetch c_Advice
      Into r_Advice;
  
    If Nvl(r_Advice.文件id, 0) = 0 Then
      v_Error := '本次检查项目没有对应相关的检查报告，请与管理员联系！';
      Raise Err_Custom;
    Else
      If Nvl(r_Advice.病历id, 0) > 0 Then
        ----产生过报告
        --找出检查已填写的报告提纲中含有"%所见%","%描述%","%建议%","%意见%",并用传入的参数更新
        For r_Report In c_Report(r_Advice.病历id) Loop
          If r_Report.内容文本 Like '%所见%' Then
            Update 电子病历内容 Set 内容文本 = 报告所见_In Where ID = r_Report.Id;
          Elsif r_Report.内容文本 Like '%意见%' Then
            Update 电子病历内容 Set 内容文本 = 报告意见_In Where ID = r_Report.Id;
          Elsif r_Report.内容文本 Like '%建议%' Then
            Update 电子病历内容 Set 内容文本 = 报告建议_In Where ID = r_Report.Id;
          End If;
        End Loop;
        --更新保存时间
        Update 电子病历记录
        Set 完成时间 = Sysdate, 保存人 = 报告医生_In, 保存时间 = Sysdate
        Where ID = r_Advice.病历id;
      Else
        --产生电子病历记录
        Select 电子病历记录_Id.Nextval Into v_病历id From Dual;
        Insert Into 电子病历记录
          (ID, 病人来源, 病人id, 主页id, 婴儿, 科室id, 病历种类, 文件id, 病历名称, 创建人, 创建时间, 完成时间, 保存人, 保存时间, 最后版本, 签名级别)
        Values
          (v_病历id, r_Advice.病人来源, r_Advice.病人id, r_Advice.主页id, r_Advice.婴儿, r_Advice.病人科室id, r_Advice.病历种类,
           r_Advice.文件id, r_Advice.病历名称, 报告医生_In, Sysdate, Sysdate, 报告医生_In, Sysdate, 1, 2);
      
        --产生医嘱报告记录
        Insert Into 病人医嘱报告 (医嘱id, 病历id) Values (v_主医嘱id, v_病历id);
      
	    v_对象序号 := 0;

        --新产生报告内容
        For r_File In c_File(r_Advice.文件id) Loop
          Select 电子病历内容_Id.Nextval Into v_病历内容id From Dual;
        
          If Nvl(r_File.父id, 0) <> 0 And (r_File.内容文本 Like '%所见%') Then
            --所见定义行(非提纲)
            v_内容文本   := 报告所见_In || Chr(13) || Chr(13);
            v_定义提纲id := 0;
          Elsif Nvl(r_File.父id, 0) <> 0 And (r_File.内容文本 Like '%意见%') Then
            --意见定义行(非提纲)
            v_内容文本   := 报告意见_In || Chr(13) || Chr(13);
            v_定义提纲id := 0;
          Elsif Nvl(r_File.父id, 0) <> 0 And (r_File.内容文本 Like '%建议%') Then
            --建议定义行(非提纲)
            v_内容文本   := 报告建议_In || Chr(13) || Chr(13);
            v_定义提纲id := 0;
          Elsif Nvl(r_File.对象类型, 0) = 1 And Nvl(r_File.父id, 0) = 0 Then
            --提纲定义行
            v_父id       := v_病历内容id;
            v_内容文本   := r_File.内容文本;
            v_定义提纲id := r_File.Id;
          Elsif Nvl(r_File.对象类型, 0) = 4 And r_File.要素名称 Is Not Null Then
            --自动替换要素
            v_内容文本   := Zl_Replace_Element_Value(r_File.要素名称, r_Advice.病人id, r_Advice.主页id, r_Advice.病人来源, r_Advice.Id);
            v_定义提纲id := 0;
          Else
            v_内容文本   := r_File.内容文本;
            v_定义提纲id := 0;
          End If;
        
          --报告内容单独写一行
          If Nvl(r_File.父id, 0) <> 0 And (r_File.内容文本 Like '%所见%' Or r_File.内容文本 Like '%意见%' Or r_File.内容文本 Like '%建议%') Then
            --先写提纲显示名称，再写内容，同时对象序号发生变化
            Select 电子病历内容_Id.Nextval Into v_病历内容idnew From Dual;
            v_对象序号 := v_对象序号 + 1;
            Insert Into 电子病历内容
              (ID, 文件id, 开始版, 终止版, 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行, 预制提纲id, 复用提纲, 使用时机, 诊治要素id, 替换域,
               要素名称, 要素类型, 要素长度, 要素小数, 要素单位, 要素表示, 输入形态, 要素值域, 定义提纲id)
            Values
              (v_病历内容idnew, v_病历id, 0, 0, Decode(v_定义提纲id, 0, v_父id, Null), v_对象序号, r_File.对象类型, r_File.对象标记,
               r_File.保留对象, 0, Null, v_内容文本, r_File.是否换行, r_File.预制提纲id, r_File.复用提纲, r_File.使用时机, r_File.诊治要素id,
               r_File.替换域, r_File.要素名称, r_File.要素类型, r_File.要素长度, r_File.要素小数, r_File.要素单位, r_File.要素表示, r_File.输入形态,
               r_File.要素值域, Decode(v_定义提纲id, 0, Null, v_定义提纲id));
            
            v_内容文本 := r_File.内容文本;
          End If;
          
		  v_对象序号 := v_对象序号 + 1;

          Insert Into 电子病历内容
            (ID, 文件id, 开始版, 终止版, 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行, 预制提纲id, 复用提纲, 使用时机, 诊治要素id, 替换域,
             要素名称, 要素类型, 要素长度, 要素小数, 要素单位, 要素表示, 输入形态, 要素值域, 定义提纲id)
          Values
            (v_病历内容id, v_病历id, 1, 0, Decode(v_定义提纲id, 0, v_父id, Null), v_对象序号, r_File.对象类型, r_File.对象标记, r_File.保留对象,
             r_File.对象属性, Null, v_内容文本, r_File.是否换行, r_File.预制提纲id, r_File.复用提纲, r_File.使用时机, r_File.诊治要素id, r_File.替换域,
             r_File.要素名称, r_File.要素类型, r_File.要素长度, r_File.要素小数, r_File.要素单位, r_File.要素表示, r_File.输入形态, r_File.要素值域,
             Decode(v_定义提纲id, 0, Null, v_定义提纲id));
        End Loop;
      
        --因电子病历格式中含了内容文字格式，此种方法导入之后内容文字将不可见
        --Select 内容 Into v_格式内容 From 病历文件格式 Where 文件ID=r_Advice.文件ID;
        --Insert Into 电子病历格式 (文件ID,内容) Values (v_病历id,v_格式内容);
      
      End If;
    End If;
    Close c_Advice;
  Exception
    When Err_Custom Then
      Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End Receivereport;

  --5、修改申请单信息
  Procedure 影像病人信息_修改
  (
    医嘱id_In       病人医嘱记录.Id%Type,
    姓名_In         病人信息.姓名%Type,
    性别_In         病人信息.性别%Type,
    年龄_In         病人信息.年龄%Type,
    费别_In         病人信息.费别%Type,
    医疗付款方式_In 病人信息.医疗付款方式%Type,
    民族_In         病人信息.民族%Type,
    婚姻_In         病人信息.婚姻状况%Type,
    职业_In         病人信息.职业%Type,
    身份证号_In     病人信息.身份证号%Type,
    家庭地址_In     病人信息.家庭地址%Type,
    家庭电话_In     病人信息.家庭电话%Type,
    家庭地址邮编_In 病人信息.家庭地址邮编%Type,
    出生日期_In     病人信息.出生日期%Type := Null
  ) As
  
    v_年龄     Varchar2(20);
    v_年龄单位 Varchar2(20);
    v_出生日期 Date;
    v_病人来源 病人医嘱记录.病人来源%Type;
    v_病人id   病人医嘱记录.病人id%Type;
  Begin
    Begin
      Select 病人来源, 病人id Into v_病人来源, v_病人id From 病人医嘱记录 Where ID = 医嘱id_In;
    Exception
      When Others Then
        Return;
    End;
  
    If 出生日期_In Is Null And 年龄_In Is Not Null Then
      --根据年龄求出生日期
      v_年龄单位 := Substr(年龄_In, Length(年龄_In), 1);
      If Instr('岁,月,天', v_年龄单位) <= 0 Then
        v_年龄单位 := Null;
      Else
        v_年龄 := Replace(年龄_In, v_年龄单位, '');
      End If;
      Begin
        v_年龄 := To_Number(v_年龄);
      Exception
        When Others Then
          v_年龄 := Null;
      End;
      If v_年龄 Is Not Null And v_年龄单位 Is Not Null Then
        Select Decode(v_年龄单位, '岁', Add_Months(Sysdate, -12 * v_年龄), '月', Add_Months(Sysdate, -1 * v_年龄), '天',
                       Sysdate - v_年龄)
        Into v_出生日期
        From Dual;
      End If;
    Else
      v_出生日期 := 出生日期_In;
    End If;
  
    If v_病人来源 = 3 Then
      Update 病人信息
      Set 姓名 = 姓名_In, 性别 = Nvl(性别_In, 性别), 年龄 = 年龄_In, 出生日期 = v_出生日期, 费别 = Nvl(费别_In, 费别),
          医疗付款方式 = Nvl(医疗付款方式_In, 医疗付款方式), 民族 = Nvl(民族_In, 民族), 婚姻状况 = Nvl(婚姻_In, 婚姻状况), 职业 = Nvl(职业_In, 职业),
          身份证号 = 身份证号_In, 家庭地址 = 家庭地址_In, 家庭电话 = 家庭电话_In, 家庭地址邮编 = 家庭地址邮编_In
      Where 病人id = v_病人id;
    
      --修改对应的医嘱记录
      Update 病人医嘱记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In
      Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
    Else
      Update 病人信息
      Set 民族 = Nvl(民族_In, 民族), 婚姻状况 = Nvl(婚姻_In, 婚姻状况), 职业 = Nvl(职业_In, 职业), 家庭地址 = 家庭地址_In, 家庭电话 = 家庭电话_In,
          家庭地址邮编 = 家庭地址邮编_In
      Where 病人id = v_病人id;
    End If;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End 影像病人信息_修改;

  --6、取消申请单信息
  Procedure 取消检查申请单
  (
    医嘱id_In     病人医嘱执行.医嘱id%Type,
    操作员编号_In 人员表.编号%Type := Null,
    操作员姓名_In 人员表.姓名%Type := Null,
    执行部门id_In 门诊费用记录.执行部门id%Type := 0,
    拒绝原因_In   病人医嘱发送.执行说明%Type := Null
  ) As
    --参数：医嘱ID_IN=单独执行的医嘱ID
  
    v_发送号 病人医嘱执行.发送号%Type;
  
  Begin
  
    Begin
      Select 发送号 Into v_发送号 From 病人医嘱发送 Where 医嘱id = 医嘱id_In;
    Exception
      When Others Then
        Return;
    End;
  
    Zl_病人医嘱执行_拒绝执行(医嘱id_In, v_发送号, 操作员编号_In, 操作员姓名_In, 执行部门id_In, 拒绝原因_In);
  
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End 取消检查申请单;
end b_zlXWInterface;
/

--93623:梁唐彬,2016-03-04,检查医嘱计费状态调整
CREATE OR REPLACE Procedure Zl_病人医嘱发送_Insert
( 
  医嘱id_In     病人医嘱发送.医嘱id%Type, 
  发送号_In     病人医嘱发送.发送号%Type, 
  记录性质_In   病人医嘱发送.记录性质%Type, 
  No_In         病人医嘱发送.No%Type, 
  记录序号_In   病人医嘱发送.记录序号%Type, 
  发送数次_In   病人医嘱发送.发送数次%Type, 
  首次时间_In   病人医嘱发送.首次时间%Type, 
  末次时间_In   病人医嘱发送.末次时间%Type, 
  发送时间_In   病人医嘱发送.发送时间%Type, 
  执行状态_In   病人医嘱发送.执行状态%Type, 
  执行部门id_In 病人医嘱发送.执行部门id%Type, 
  计费状态_In   病人医嘱发送.计费状态%Type, 
  First_In      Number := 0, 
  样本条码_In   病人医嘱发送.样本条码%Type := Null, 
  操作员编号_In 人员表.编号%Type := Null, 
  操作员姓名_In 人员表.姓名%Type := Null, 
  领药号_In     未发药品记录.领药号%Type := Null, 
  门诊记帐_In   病人医嘱发送.门诊记帐%Type := Null, 
  分解时间_In   Varchar2 := Null 
  --功能：填写病人医嘱发送记录 
  --参数： 
  --      医嘱id_In=要发送的每个医嘱ID 
  --      First_IN=表示是否一组医嘱的第一医嘱行,以便处理医嘱相关内容(如成药,配方的第一行,因为给药途径,配方煎法,用法可能为叮嘱不发送) 
  --      发送数次_IN,首次时间_IN,末次时间_IN:对"持续性"长嘱,不填写发送数次,可填写首末次时间(用于回退)。 
  --      门诊记帐_In,住院临嘱发送到门诊记帐时才填写为1（因为记录性质是2，用于区分住院记帐），其余情况均填空。 
) Is 
  --包含病人及医嘱(一组医嘱中第一行)相关信息的游标 
  Cursor c_Advice Is 
    Select Nvl(a.相关id, a.Id) As 组id, a.序号, a.病人id, a.主页id, a.婴儿, a.姓名, a.病人科室id, c.操作类型, a.诊疗类别, a.医嘱期效, a.医嘱状态, a.医嘱内容, 
           a.开嘱医生, a.开嘱时间, a.开始执行时间, a.上次执行时间, a.执行终止时间, a.执行时间方案, a.频率次数, a.频率间隔, a.间隔单位, a.开嘱科室id, a.标本部位, a.执行科室id, 
           a.相关id, a.诊疗项目id 
    From 病人医嘱记录 A, 诊疗项目目录 C 
    Where a.诊疗项目id = c.Id And a.Id = 医嘱id_In; 
  r_Advice c_Advice%RowType; 
 
  --包含病人(婴儿)的所有未停长嘱(含配方长嘱),婴儿传入-1表示都处理 
  Cursor c_Needstop 
  ( 
    v_病人id   病人医嘱记录.病人id%Type, 
    v_主页id   病人医嘱记录.主页id%Type, 
    v_婴儿     病人医嘱记录.婴儿%Type, 
    v_Stoptime Date 
  ) Is 
    Select a.Id, a.诊疗类别, b.操作类型, b.执行频率 
    From 病人医嘱记录 A, 诊疗项目目录 B 
    Where a.诊疗项目id = b.Id(+) And a.病人id = v_病人id And a.主页id = v_主页id And (v_婴儿 = -1 Or Nvl(a.婴儿, 0) = Nvl(v_婴儿, 0)) And 
          Nvl(a.医嘱期效, 0) = 0 And a.医嘱状态 Not In (1, 2, 4, 8, 9) And a.开始执行时间 < v_Stoptime 
    Order By a.序号; 
  --包含病人(婴儿)的已停但未确认的长嘱,终止执行时间在指定时间之后,婴儿传入-1表示都处理 
  Cursor c_Havestop 
  ( 
    v_病人id   病人医嘱记录.病人id%Type, 
    v_主页id   病人医嘱记录.主页id%Type, 
    v_婴儿     病人医嘱记录.婴儿%Type, 
    v_Stoptime Date 
  ) Is 
    Select ID 
    From 病人医嘱记录 
    Where 病人id = v_病人id And 主页id = v_主页id And (v_婴儿 = -1 Or Nvl(婴儿, 0) = Nvl(v_婴儿, 0)) And Nvl(医嘱期效, 0) = 0 And 
          医嘱状态 = 8 And 执行终止时间 > v_Stoptime And 开始执行时间 < v_Stoptime 
    Order By 序号; 
 
  --其它临时变量 
  v_婴儿     病人医嘱记录.婴儿%Type; 
  v_持续性   Number(1); --是否持续性长嘱 
  v_Autostop Number(1); 
  v_Date     Date; 
  v_Temp     Varchar2(255); 
  v_人员编号 人员表.编号%Type; 
  v_人员姓名 人员表.姓名%Type; 
  v_停止时间 病人医嘱记录.开嘱时间%Type; 
  n_执行状态 病人医嘱发送.执行状态%Type; 
  d_开始时间 病人医嘱记录.开始执行时间%Type; 
 
  v_Stopadviceids 病人医嘱记录.医嘱内容%Type; 
  n_Adviceid      病人医嘱记录.病人id%Type; 
  n_标记          Number(18); 
  v_Error         Varchar2(255); 
  Err_Custom Exception; 
Begin 
  --当前操作人员 
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then 
    v_人员编号 := 操作员编号_In; 
    v_人员姓名 := 操作员姓名_In; 
  Else 
    v_Temp     := Zl_Identity; 
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1); 
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1); 
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1); 
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1); 
  End If; 
  --如果首次时间为空则填入开始执行时间 
  If 首次时间_In Is Null Or 分解时间_In Is Null Or 末次时间_In Is Null Then 
    Select 开始执行时间 Into d_开始时间 From 病人医嘱记录 Where ID = 医嘱id_In; 
  End If; 
 
  Open c_Advice; 
  Fetch c_Advice 
    Into r_Advice; 
  Close c_Advice; 
 
  --是一组医嘱的第一行时处理医嘱内容 
  If Nvl(First_In, 0) = 1 Then 
    --并发操作检查 
    --------------------------------------------------------------------------------------- 
    If Nvl(r_Advice.医嘱状态, 0) = 4 Then 
      --检查要发送的医嘱是否被作废 
      v_Error := '"' || r_Advice.姓名 || '"的医嘱"' || r_Advice.医嘱内容 || '"已经被其他人作废。' || Chr(13) || Chr(10) || 
                 '该病人的医嘱发送失败。请重新读取发送清单再试。'; 
      Raise Err_Custom; 
    End If; 
 
    If Nvl(r_Advice.医嘱期效, 0) = 0 Then 
      --长嘱：含成药长嘱,配方长嘱,非药"可选频率"长嘱,非药"持续性"长嘱 
 
      --检查长嘱是否已被发送 
      If r_Advice.上次执行时间 Is Not Null Then 
        If r_Advice.上次执行时间 >= 首次时间_In Then 
          v_Error := '"' || r_Advice.姓名 || '"的医嘱"' || r_Advice.医嘱内容 || '"已经被其他人发送。' || Chr(13) || Chr(10) || 
                     '该病人的医嘱发送失败。请重新读取发送清单再试。'; 
          Raise Err_Custom; 
        End If; 
      End If; 
 
      --检查长嘱发送前是否已被自动停止(如术后) 
      If r_Advice.执行终止时间 Is Not Null Then 
        If 首次时间_In > r_Advice.执行终止时间 Then 
          v_Error := '"' || r_Advice.姓名 || '"的医嘱"' || r_Advice.医嘱内容 || '"已经被停止。' || Chr(13) || Chr(10) || 
                     '该病人的医嘱发送失败。请重新读取发送清单再试。'; 
          Raise Err_Custom; 
        End If; 
      End If; 
    Elsif Nvl(r_Advice.医嘱状态, 0) In (8, 9) Then 
      --临嘱：含配方临嘱 
 
      --检查是否已被发送(或因其它原因自动停止) 
      v_Error := '"' || r_Advice.姓名 || '"的医嘱"' || r_Advice.医嘱内容 || '"已经被其他人发送。' || Chr(13) || Chr(10) || 
                 '该病人的医嘱发送失败。请重新读取发送清单再试。'; 
      Raise Err_Custom; 
    End If; 
 
    --发送后的医嘱处理 
    --------------------------------------------------------------------------------------- 
    If Nvl(r_Advice.医嘱期效, 0) = 0 Then 
      --长期医嘱:更新上次执行时间 
      Update 病人医嘱记录 Set 上次执行时间 = 末次时间_In Where ID = r_Advice.组id Or 相关id = r_Advice.组id; 
 
      --判断是否持续性长嘱 
      v_持续性 := 0; 
      If r_Advice.执行时间方案 Is Null And (Nvl(r_Advice.频率次数, 0) = 0 Or Nvl(r_Advice.频率间隔, 0) = 0 Or r_Advice.间隔单位 Is Null) Then 
        v_持续性 := 1; 
      End If; 
 
      --预定了终止时间且未停止的自动停止 
      If r_Advice.执行终止时间 Is Not Null And Nvl(r_Advice.医嘱状态, 0) Not In (8, 9) Then 
        v_Autostop := 0; 
        If v_持续性 = 1 Then 
          --非药"持续性"长嘱 
          If Trunc(末次时间_In) = Trunc(r_Advice.执行终止时间 - 1) Then 
            v_Autostop := 1; --终止这天不执行 
          End If; 
        Elsif Zl_Advicenexttime(医嘱id_In) > r_Advice.执行终止时间 Then 
          --成药长嘱或非药"可选频率"长嘱 
          v_Autostop := 1; --如果是等于,还可以执行一次 
        End If; 
 
        If v_Autostop = 1 Then 
          Update 病人医嘱记录 
          Set 医嘱状态 = 8, 停嘱时间 = 末次时间_In, 停嘱医生 = r_Advice.开嘱医生 
          Where ID = r_Advice.组id Or 相关id = r_Advice.组id; 
 
          Insert Into 病人医嘱状态 
            (医嘱id, 操作类型, 操作人员, 操作时间) 
            Select ID, 8, r_Advice.开嘱医生, 发送时间_In 
            From 病人医嘱记录 
            Where ID = r_Advice.组id Or 相关id = r_Advice.组id; 
          v_Stopadviceids := v_Stopadviceids || ',' || r_Advice.组id; 
        End If; 
      End If; 
    Else 
      --临嘱停止。 
      --住院医生发送时自动校对、停止：校对是以Sysdate取的,为避免重复,停止时间也取Sysdate 
      Select Sysdate Into v_Date From Dual; 
      Update 病人医嘱记录 
      Set 医嘱状态 = 8, 执行终止时间 = 末次时间_In, 
          --为一次性临嘱时没有 
          上次执行时间 = 末次时间_In, 
          --为一次性临嘱时没有 
          停嘱时间 = v_Date, 
          --发送时间_IN, 
          停嘱医生 = r_Advice.开嘱医生 
      Where ID = r_Advice.组id Or 相关id = r_Advice.组id; 
 
      Insert Into 病人医嘱状态 
        (医嘱id, 操作类型, 操作人员, 操作时间) 
        Select ID, 8, v_人员姓名, v_Date --发送时间_IN 
        From 病人医嘱记录 
        Where ID = r_Advice.组id Or 相关id = r_Advice.组id; 
    End If; 
 
    --特殊医嘱的处理 
    --------------------------------------------------------------------------------------- 
    If r_Advice.诊疗类别 = 'Z' And Nvl(r_Advice.操作类型, '0') <> '0' Then 
      --(1-留观;2-住院;)3-转科;4-术后(不发送);5-出院;6-转院,7-会诊,11-死亡 
 
      --几种特殊医嘱要自动停止病人该医嘱之前(按时间算)所有未停的长嘱 
      If r_Advice.操作类型 In ('3', '5', '6', '11') Then 
        If Nvl(r_Advice.婴儿, 0) = 0 Then 
          v_婴儿 := -1; 
        Else 
          v_婴儿 := Nvl(r_Advice.婴儿, 0); 
        End If; 
        For r_Needstop In c_Needstop(r_Advice.病人id, r_Advice.主页id, v_婴儿, r_Advice.开始执行时间) Loop 
          Select Decode(Sign(开始执行时间 - r_Advice.开始执行时间), 1, 开始执行时间, r_Advice.开始执行时间) 
          Into v_停止时间 
          From 病人医嘱记录 
          Where ID = r_Needstop.Id; 
          Update 病人医嘱记录 
          Set 医嘱状态 = 8, 执行终止时间 = v_停止时间, 停嘱时间 = 发送时间_In, 停嘱医生 = r_Advice.开嘱医生 
          Where ID = r_Needstop.Id; 
 
          Insert Into 病人医嘱状态 
            (医嘱id, 操作类型, 操作人员, 操作时间) 
            Select ID, 8, v_人员姓名, 发送时间_In From 病人医嘱记录 Where ID = r_Needstop.Id; 
          v_Stopadviceids := v_Stopadviceids || ',' || r_Needstop.Id; 
        End Loop; 
        --已停止未确认的长嘱,终止时间在医嘱开始后的,调前其终止时间(同时多个特殊医嘱的情况) 
        For r_Havestop In c_Havestop(r_Advice.病人id, r_Advice.主页id, v_婴儿, r_Advice.开始执行时间) Loop 
          Update 病人医嘱记录 
          Set 执行终止时间 = Decode(Sign(开始执行时间 - r_Advice.开始执行时间), 1, 开始执行时间, r_Advice.开始执行时间), 停嘱时间 = 发送时间_In, 
              停嘱医生 = r_Advice.开嘱医生 
          Where ID = r_Havestop.Id; 
 
          --不修改停止医嘱的操作人员，因为停止时，医生可能已进行电子签名 
          Update 病人医嘱状态 Set 操作时间 = 发送时间_In Where 医嘱id = r_Havestop.Id And 操作类型 = 8; 
          v_Stopadviceids := v_Stopadviceids || ',' || r_Havestop.Id; 
        End Loop; 
        --处理长期备用医嘱(没有执行（发送）过的标记未用）,同时处理临嘱 
        Update 病人医嘱记录 
        Set 执行标记 = -1 
        Where 病人id = r_Advice.病人id And 主页id = r_Advice.主页id And 
              (医嘱期效 = 0 And 执行频次 = '必要时' And 上次执行时间 Is Null And 医嘱状态 In (3, 5, 6, 7) Or 
              医嘱期效 = 1 And 执行频次 = '需要时' And 医嘱状态 = 3) And 执行标记 <> -1; 
      End If; 
 
      --具体的特殊处理 
      If Nvl(r_Advice.婴儿, 0) = 0 Then 
        If r_Advice.操作类型 = '3' And 执行部门id_In Is Not Null And r_Advice.病人科室id Is Not Null And 
           Nvl(r_Advice.病人科室id, 0) <> Nvl(执行部门id_In, 0) Then 
          --转科医嘱,将病人登记转科到"执行科室ID"(在院病人且当前科室与转入科室不同才处理) 
          Zl_病人变动记录_Change(r_Advice.病人id, r_Advice.主页id, 执行部门id_In, v_人员编号, v_人员姓名); 
        Elsif r_Advice.操作类型 In ('5', '6', '11') Then 
          --出院、转院、死亡医嘱,将病人标记为预出院 
          Begin 
            Select 开始时间 
            Into v_Date 
            From 病人变动记录 
            Where 开始时间 Is Not Null And 终止时间 Is Null And 病人id = r_Advice.病人id And 主页id = r_Advice.主页id; 
          Exception 
            When Others Then 
              v_Date := To_Date('1900-01-01', 'YYYY-MM-DD'); 
          End; 
          If r_Advice.开始执行时间 <= v_Date Then 
            v_Error := '医嘱"' || r_Advice.医嘱内容 || '"的开始时间应大于该病人上次变动时间 ' || To_Char(v_Date, 'YYYY-MM-DD HH24:Mi') || ' 。'; 
            Raise Err_Custom; 
          End If; 
          Zl_病人变动记录_Preout(r_Advice.病人id, r_Advice.主页id, r_Advice.开始执行时间); 
        End If; 
      End If; 
    End If; 
    --12小时未执行的备用临嘱处理为标记未用 
    If r_Advice.医嘱期效 = 1 Then 
      Update 病人医嘱记录 
      Set 执行标记 = -1 
      Where 病人id = r_Advice.病人id And 主页id = r_Advice.主页id And 执行标记 <> -1 And 医嘱期效 = 1 And 执行频次 = '需要时' And 
            Sysdate - 开始执行时间 > 0.5 And 医嘱状态 = 3; 
    End If; 
  End If; 
 
  --填写发送记录 
  --------------------------------------------------------------------------------------- 
  n_执行状态 := 执行状态_In; 
  If 执行状态_In = 1 Then 
    v_Temp := zl_GetSysParameter(186); 
    If v_Temp = '11' Then 
      If r_Advice.诊疗类别 = 'E' And r_Advice.操作类型 in ('1','8') Or r_Advice.诊疗类别 = 'K' Then 
        n_执行状态 := 0; 
      End If; 
    Elsif v_Temp = '01' Then 
      If r_Advice.诊疗类别 = 'E' And r_Advice.操作类型 = '1' Then 
        n_执行状态 := 0; 
      End If; 
    Elsif v_Temp = '10' Then 
      If r_Advice.诊疗类别 = 'E' And r_Advice.操作类型 = '8' Or r_Advice.诊疗类别 = 'K' Then 
        n_执行状态 := 0; 
      End If; 
    End If; 
  End If; 
 
  Insert Into 病人医嘱发送 
    (医嘱id, 发送号, 记录性质, NO, 记录序号, 发送数次, 发送人, 发送时间, 执行状态, 执行部门id, 计费状态, 首次时间, 末次时间, 样本条码, 门诊记帐) 
  Values 
    (医嘱id_In, 发送号_In, 记录性质_In, No_In, 记录序号_In, 发送数次_In, v_人员姓名, 发送时间_In, n_执行状态, 执行部门id_In, 计费状态_In, 
     Nvl(首次时间_In, d_开始时间), Nvl(末次时间_In, d_开始时间), 样本条码_In, 门诊记帐_In); 
     
  --手术和检查医嘱同步更新主医嘱的计费状态   
  If 计费状态_In = 1 And  r_Advice.组ID <> 医嘱id_In  And (r_Advice.诊疗类别 = 'D' Or r_Advice.诊疗类别 = 'F') Then   
     Update 病人医嘱发送 Set 计费状态 = 1 Where 医嘱ID = r_Advice.组ID And 发送号 = 发送号_In;
  End If;
 
  --领药号的填写 
  If 领药号_In Is Not Null Then 
    Update 未发药品记录 Set 领药号 = 领药号_In Where NO = No_In And 单据 = 9 And 领药号 Is Null; 
    Update 药品收发记录 Set 产品合格证 = 领药号_In Where NO = No_In And 单据 = 9 And 产品合格证 Is Null; 
  End If; 
 
  --自动填为已执行时，需要同步处理费用执行状态及审核划价状态 
  If 执行状态_In = 1 Then 
    Zl_病人医嘱执行_Finish(医嘱id_In, 发送号_In, Null, Null, v_人员编号, v_人员姓名, 执行部门id_In); 
  End If; 
 
  --产生医嘱执行时间记录(只产生主记录的) 
  If Nvl(分解时间_In, To_Char(d_开始时间, 'yyyy-mm-dd hh24:mi:ss')) Is Not Null Then 
    If r_Advice.相关id Is Null Then 
      Insert Into 医嘱执行时间 
        (要求时间, 医嘱id, 发送号) 
        Select To_Date(Column_Value, 'yyyy-mm-dd hh24:mi:ss'), 医嘱id_In, 发送号_In 
        From Table(f_Str2list(Nvl(分解时间_In, To_Char(d_开始时间, 'yyyy-mm-dd hh24:mi:ss')))); 
    End If; 
  End If; 
 
  --病历书写时机的填写 
  If r_Advice.诊疗类别 = 'F' Then 
    --一组手术只调一次 
    If r_Advice.相关id Is Null Then 
      If Not r_Advice.标本部位 Is Null Then 
        v_Date := To_Date(r_Advice.标本部位, 'yyyy-mm-dd hh24:mi:ss'); 
      Else 
        v_Date := r_Advice.开始执行时间; 
      End If; 
      Zl_电子病历时机_Insert(r_Advice.病人id, r_Advice.主页id, 2, '手术', r_Advice.开嘱科室id, r_Advice.开嘱医生, v_Date, v_Date, 
                       r_Advice.执行科室id); 
    End If; 
  Elsif r_Advice.诊疗类别 = 'Z' And r_Advice.操作类型 = '7' Then 
    Zl_电子病历时机_Insert(r_Advice.病人id, r_Advice.主页id, 2, '会诊', r_Advice.开嘱科室id, r_Advice.开嘱医生, r_Advice.开始执行时间, 
                     r_Advice.开始执行时间, r_Advice.执行科室id); 
  Elsif r_Advice.诊疗类别 = 'Z' And r_Advice.操作类型 = '8' Then 
    Zl_电子病历时机_Insert(r_Advice.病人id, r_Advice.主页id, 2, '抢救', r_Advice.开嘱科室id, r_Advice.开嘱医生, r_Advice.开始执行时间, 
                     r_Advice.开始执行时间, r_Advice.执行科室id); 
  Elsif r_Advice.诊疗类别 = 'Z' And r_Advice.操作类型 = '11' Then 
    Zl_电子病历时机_Insert(r_Advice.病人id, r_Advice.主页id, 2, '死亡', r_Advice.开嘱科室id, r_Advice.开嘱医生, r_Advice.开始执行时间, 
                     r_Advice.开始执行时间, r_Advice.执行科室id); 
  End If; 
  --额外调用(知情文件允许的诊疗类别才调用) 
  If Instr('C,D,E,F,G,K,L', r_Advice.诊疗类别) > 0 Then 
    Zl_电子病历时机_Insert(r_Advice.病人id, r_Advice.主页id, 2, '知情文书', r_Advice.开嘱科室id, r_Advice.开嘱医生, r_Advice.开始执行时间, 
                     r_Advice.开始执行时间, r_Advice.执行科室id, r_Advice.诊疗项目id, r_Advice.医嘱内容); 
  End If; 
  --医嘱停止消息的处理 
  If v_Stopadviceids Is Not Null Then 
    v_Stopadviceids := Substr(v_Stopadviceids, 2); 
    Select Max(a.Id) 
    Into n_标记 
    From 病人医嘱记录 A 
    Where a.Id In (Select Column_Value From Table(f_Num2list(v_Stopadviceids))) And a.医嘱期效 = 0 And a.医嘱状态 = 8 And 
          Nvl(a.执行标记, 0) <> -1 And a.病人来源 <> 3; 
    If n_标记 Is Not Null Then 
      Select Max(a.Id) 
      Into n_Adviceid 
      From 病人医嘱记录 A 
      Where a.Id In (Select Column_Value From Table(f_Num2list(v_Stopadviceids))) And a.紧急标志 = 1 And a.医嘱期效 = 0 And 
            a.医嘱状态 = 8 And Nvl(a.执行标记, 0) <> -1 And a.病人来源 <> 3; 
      If n_Adviceid Is Not Null Then 
        Select Nvl(Max(0), 2) 
        Into n_标记 
        From 业务消息清单 A 
        Where a.病人id = r_Advice.病人id And a.就诊id = r_Advice.主页id And a.类型编码 = 'ZLHIS_CIS_002' And a.优先程度 = 2 And 
              a.是否已阅 = 0; 
      Else 
        n_Adviceid := n_标记; 
        Select Nvl(Max(0), 1) 
        Into n_标记 
        From 业务消息清单 A 
        Where a.病人id = r_Advice.病人id And a.就诊id = r_Advice.主页id And a.类型编码 = 'ZLHIS_CIS_002' And a.是否已阅 = 0; 
      End If; 
      If n_标记 > 0 Then 
        For R In (Select a.病人性质 As 性质, a.出院科室id As 科室id, a.当前病区id As 病区id 
                  From 病案主页 A 
                  Where a.病人id = r_Advice.病人id And a.主页id = r_Advice.主页id) Loop 
          Zl_业务消息清单_Insert(r_Advice.病人id, r_Advice.主页id, r.科室id, r.病区id, r.性质, '有新停止医嘱。', '0010', 'ZLHIS_CIS_002', 
                           n_Adviceid, n_标记, 0, Null, r.病区id); 
        End Loop; 
      End If; 
    End If; 
  End If; 
Exception 
  When Err_Custom Then 
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]'); 
  When Others Then 
    zl_ErrorCenter(SQLCode, SQLErrM); 
End Zl_病人医嘱发送_Insert;
/

--93623:梁唐彬,2016-03-04,检查计费状态调整
CREATE OR REPLACE Procedure Zl_门诊医嘱发送_Insert
( 
  医嘱id_In     病人医嘱发送.医嘱id%Type, 
  发送号_In     病人医嘱发送.发送号%Type, 
  记录性质_In   病人医嘱发送.记录性质%Type, 
  No_In         病人医嘱发送.No%Type, 
  记录序号_In   病人医嘱发送.记录序号%Type, 
  发送数次_In   病人医嘱发送.发送数次%Type, 
  首次时间_In   病人医嘱发送.首次时间%Type, 
  末次时间_In   病人医嘱发送.末次时间%Type, 
  发送时间_In   病人医嘱发送.发送时间%Type, 
  执行状态_In   病人医嘱发送.执行状态%Type, 
  执行部门id_In 病人医嘱发送.执行部门id%Type, 
  计费状态_In   病人医嘱发送.计费状态%Type, 
  First_In      Number := 0, 
  样本条码_In   病人医嘱发送.样本条码%Type := Null, 
  操作员编号_In 人员表.编号%Type := Null, 
  操作员姓名_In 人员表.姓名%Type := Null 
  --功能：填写病人医嘱发送记录 
  --参数：First_IN=表示是否一组医嘱的第一医嘱行,以便处理医嘱相关内容(如成药,配方的第一行,因为给药途径,配方煎法,用法可能为叮嘱不发送) 
) Is 
  --包含病人及医嘱(一组医嘱中第一行)相关信息的游标 
  Cursor c_Advice Is 
    Select Nvl(a.相关id, a.Id) As 组id, a.序号, a.病人id, a.挂号单, a.婴儿, b.姓名, c.操作类型, a.诊疗类别, a.医嘱状态, a.医嘱内容, a.开嘱医生, a.开始执行时间, 
           a.执行时间方案, a.频率次数, a.频率间隔, a.间隔单位, Nvl(a.紧急标志, 0) As 紧急标志 
    From 病人医嘱记录 A, 病人信息 B, 诊疗项目目录 C 
    Where a.病人id = b.病人id And a.诊疗项目id = c.Id And a.Id = 医嘱id_In 
    Group By Nvl(a.相关id, a.Id), a.序号, a.病人id, a.挂号单, a.婴儿, b.姓名, c.操作类型, a.诊疗类别, a.医嘱状态, a.医嘱内容, a.开嘱医生, a.开始执行时间, 
             a.执行时间方案, a.频率次数, a.频率间隔, a.间隔单位, a.紧急标志; 
  r_Advice c_Advice%RowType; 
 
  Cursor c_Pati(v_病人id 病人信息.病人id%Type) Is 
    Select * From 病人信息 Where 病人id = v_病人id; 
  r_Pati c_Pati%RowType; 
 
  --其它临时变量 
  v_Temp     Varchar2(255); 
  v_Count    Number; 
  v_病人性质 病案主页.病人性质%Type; 
  v_人员编号 人员表.编号%Type; 
  v_人员姓名 人员表.姓名%Type; 
  v_入院方式 入院方式.名称%Type; 
  d_开始时间 病人医嘱记录.开始执行时间%Type; 
 
  v_Error Varchar2(255); 
  Err_Custom Exception; 
Begin 
  --当前操作人员 
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then 
    v_人员编号 := 操作员编号_In; 
    v_人员姓名 := 操作员姓名_In; 
  Else 
    v_Temp     := Zl_Identity; 
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1); 
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1); 
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1); 
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1); 
  End If; 
  --如果首次时间为空则填入开始执行时间 
  If 首次时间_In Is Null Then 
    Select 开始执行时间 Into d_开始时间 From 病人医嘱记录 Where ID = 医嘱id_In; 
  End If; 
  
  Open c_Advice; 
    Fetch c_Advice 
  Into r_Advice; 
  --是一组医嘱的第一行时处理医嘱内容 
  If Nvl(First_In, 0) = 1 Then 
    --并发操作检查 
    --------------------------------------------------------------------------------------- 
    If Nvl(r_Advice.医嘱状态, 0) <> 1 Then 
      v_Error := '"' || r_Advice.姓名 || '"的医嘱"' || r_Advice.医嘱内容 || '"已经被其他人发送。' || Chr(13) || Chr(10) || 
                 '该病人的医嘱发送失败。请重新读取发送清单再试。'; 
      Raise Err_Custom; 
    End If; 
 
    --发送后的医嘱处理:临嘱发送后自动停止 
    --------------------------------------------------------------------------------------- 
    Update 病人医嘱记录 
    Set 医嘱状态 = 8, 执行终止时间 = 末次时间_In, 
        --可能没有 
        停嘱时间 = 发送时间_In, 
        --要作为发送时间显示 
        停嘱医生 = v_人员姓名 --要作为发送人显示,不同于住院,门诊医嘱无护士操作 
    Where ID = r_Advice.组id Or 相关id = r_Advice.组id; 
 
    Insert Into 病人医嘱状态 
      (医嘱id, 操作类型, 操作人员, 操作时间) 
      Select ID, 8, v_人员姓名, 发送时间_In From 病人医嘱记录 Where ID = r_Advice.组id Or 相关id = r_Advice.组id; 
 
    --特殊医嘱的处理 
    --------------------------------------------------------------------------------------- 
    If r_Advice.诊疗类别 = 'Z' And Nvl(r_Advice.操作类型, '0') <> '0' And Nvl(r_Advice.婴儿, 0) = 0 Then 
      --1-留观;2-住院; 
      If Instr(',1,2,', r_Advice.操作类型) > 0 And 执行部门id_In Is Not Null Then 
        --满足产生新的预约登记的条件：1.当前无预约,2.当前不在院,3-无要求预约时间内的住院记录 
 
        --删除超过挂号有效天数的预约登记 
        Begin 
          Select Count(*) Into v_Count From 病案主页 Where 病人id = r_Advice.病人id And Nvl(主页id, 0) = 0; 
        Exception 
          When Others Then 
            v_Count := 0; 
        End; 
        If Nvl(v_Count, 0) > 0 Then 
          Zl_入院病案主页_Delete(r_Advice.病人id, 0, 0, 0); 
          v_Count := 0; 
        End If; 
 
        If v_Count = 0 Then 
          Select Count(*) Into v_Count From 病案主页 Where 病人id = r_Advice.病人id And 出院日期 Is Null; 
        End If; 
        If v_Count = 0 Then 
          Select Count(*) 
          Into v_Count 
          From 病案主页 
          Where 病人id = r_Advice.病人id And (入院日期 >= r_Advice.开始执行时间 Or 出院日期 >= r_Advice.开始执行时间); 
        End If; 
        If v_Count = 0 Then 
          If r_Advice.操作类型 = '1' Then 
            --留观医嘱,将病人在"开始时间"留观到临床执行科室 
            Begin 
              v_病人性质 := 2; 
              Select Decode(服务对象, 1, 1, 2) 
              Into v_病人性质 
              From 部门性质说明 
              Where 工作性质 = '临床' And 部门id = 执行部门id_In; 
            Exception 
              When Others Then 
                Null; 
            End; 
          Elsif r_Advice.操作类型 = '2' Then 
            --住院医嘱,将病人在"开始时间"登记到临床执行科室 
            v_病人性质 := 0; 
          End If; 
 
          Open c_Pati(r_Advice.病人id); 
          Fetch c_Pati 
            Into r_Pati; 
 
          v_入院方式 := Null; 
          If r_Advice.紧急标志 = 1 Then 
            v_入院方式 := '急诊'; 
          Else 
            Select Decode(急诊, 1, '急诊', Null) 
            Into v_入院方式 
            From 病人挂号记录 
            Where NO = r_Advice.挂号单 And 记录性质 = 1 And 记录状态 = 1; 
          End If; 
 
          If v_病人性质 = 1 Then 
            Zl_入院病案主页_Insert(1, v_病人性质, r_Pati.病人id, r_Pati.门诊号, Null, r_Pati.姓名, r_Pati.性别, r_Pati.年龄, r_Pati.费别, 
                             r_Pati.出生日期, r_Pati.国籍, r_Pati.民族, r_Pati.学历, r_Pati.婚姻状况, r_Pati.职业, r_Pati.身份, 
                             r_Pati.身份证号, r_Pati.出生地点, r_Pati.家庭地址, r_Pati.家庭地址邮编, r_Pati.家庭电话, r_Pati.户口地址, 
                             r_Pati.户口地址邮编, r_Pati.联系人姓名, r_Pati.联系人关系, r_Pati.联系人地址, r_Pati.联系人电话, r_Pati.工作单位, 
                             r_Pati.合同单位id, r_Pati.单位电话, r_Pati.单位邮编, r_Pati.单位开户行, r_Pati.单位帐号, r_Pati.担保人, r_Pati.担保额, 
                             r_Pati.担保性质, 执行部门id_In, Null, Null, v_入院方式, Null, Null, r_Advice.开嘱医生, r_Pati.籍贯, r_Pati.区域, 
                             r_Advice.开始执行时间, Null, Null, r_Pati.医疗付款方式, Null, Null, Null, Null, Null, Null, r_Pati.险类, 
                             v_人员编号, v_人员姓名, 0, Null, Null, 0); 
          Else 
            Zl_入院病案主页_Insert(1, v_病人性质, r_Pati.病人id, r_Pati.住院号, Null, r_Pati.姓名, r_Pati.性别, r_Pati.年龄, r_Pati.费别, 
                             r_Pati.出生日期, r_Pati.国籍, r_Pati.民族, r_Pati.学历, r_Pati.婚姻状况, r_Pati.职业, r_Pati.身份, 
                             r_Pati.身份证号, r_Pati.出生地点, r_Pati.家庭地址, r_Pati.家庭地址邮编, r_Pati.家庭电话, r_Pati.户口地址, 
                             r_Pati.户口地址邮编, r_Pati.联系人姓名, r_Pati.联系人关系, r_Pati.联系人地址, r_Pati.联系人电话, r_Pati.工作单位, 
                             r_Pati.合同单位id, r_Pati.单位电话, r_Pati.单位邮编, r_Pati.单位开户行, r_Pati.单位帐号, r_Pati.担保人, r_Pati.担保额, 
                             r_Pati.担保性质, 执行部门id_In, Null, Null, v_入院方式, Null, Null, r_Advice.开嘱医生, r_Pati.籍贯, r_Pati.区域, 
                             r_Advice.开始执行时间, Null, Null, r_Pati.医疗付款方式, Null, Null, Null, Null, Null, Null, r_Pati.险类, 
                             v_人员编号, v_人员姓名, 0, Null, Null, 0); 
          End If; 
          Close c_Pati; 
        End If; 
      End If; 
    End If; 
  End If; 
  Close c_Advice; 
 
  --填写发送记录 
  --------------------------------------------------------------------------------------- 
  Insert Into 病人医嘱发送 
    (医嘱id, 发送号, 记录性质, NO, 记录序号, 发送数次, 发送人, 发送时间, 执行状态, 执行部门id, 计费状态, 首次时间, 末次时间, 样本条码, 门诊记帐) 
  Values 
    (医嘱id_In, 发送号_In, 记录性质_In, No_In, 记录序号_In, 发送数次_In, v_人员姓名, 发送时间_In, 执行状态_In, 执行部门id_In, 计费状态_In, 
     Nvl(首次时间_In, d_开始时间), Nvl(末次时间_In, d_开始时间), 样本条码_In, Decode(记录性质_In, 2, 1, Null)); 
     
  --手术和检查医嘱同步更新主医嘱的计费状态   
  If 计费状态_In = 1 And  r_Advice.组ID <> 医嘱id_In  And (r_Advice.诊疗类别 = 'D' Or r_Advice.诊疗类别 = 'F') Then   
     Update 病人医嘱发送 Set 计费状态 = 1 Where 医嘱ID = r_Advice.组ID And 发送号 = 发送号_In;
  End If;
  
  --自动填为已执行时，需要同步处理费用执行状态及审核划价状态 
  If 执行状态_In = 1 Then 
    Zl_病人医嘱执行_Finish(医嘱id_In, 发送号_In, Null, Null, v_人员编号, v_人员姓名, 执行部门id_In); 
  End If; 
  --消息推送 
  Begin 
    Execute Immediate 'Begin zl_服务窗消息_发送(:1,:2); End;' 
      Using 3, 发送号_In; 
  Exception 
    When Others Then 
      Null; 
  End; 
Exception 
  When Err_Custom Then 
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]'); 
  When Others Then 
    zl_ErrorCenter(SQLCode, SQLErrM); 
End Zl_门诊医嘱发送_Insert;
/

--93868:刘尔旋,2016-03-04,清除失效预约问题
Create Or Replace Procedure Zl_挂号序号状态_Delete
(
  操作方式_In Number := 0,
  号别_In     病人挂号记录.号别%Type := Null
) As
  n_预约有效时间 Number(5);
  n_失约用于挂号 Number(2);
  n_挂号有效天数 Number(5);
Begin
  If 操作方式_In = 0 Then
    --清除历史记录
    Delete 挂号序号状态 Where 日期 < Trunc(Sysdate);
  Else
    --清除失约号
    n_预约有效时间 := Nvl(zl_GetSysParameter('预约有效时间', 1111), 0);
    n_失约用于挂号 := Nvl(zl_GetSysParameter('失约用于挂号', 1111), 0);
    n_挂号有效天数 := Nvl(zl_GetSysParameter('挂号有效天数'), 7);
    If n_预约有效时间 <> 0 And n_失约用于挂号 <> 0 Then
      If 号别_In Is Null Then
        For c_失效预约 In (Select b.号码, b.日期, b.序号
                       From 病人挂号记录 A, 挂号序号状态 B
                       Where a.预约时间 - 1 / 24 / 60 * n_预约有效时间 < Sysdate And a.预约时间 > Sysdate - n_挂号有效天数 And a.记录性质 = 2 And
                             a.号别 = b.号码 And a.号序 = b.序号) Loop
          Delete From 挂号序号状态
          Where 日期 = c_失效预约.日期 And 序号 = c_失效预约.序号 And 状态 = 2 And 号码 = c_失效预约.号码;
        End Loop;
      Else
        For c_失效预约 In (Select b.号码, b.日期, b.序号
                       From 病人挂号记录 A, 挂号序号状态 B
                       Where a.预约时间 - 1 / 24 / 60 * n_预约有效时间 < Sysdate And a.预约时间 > Sysdate - n_挂号有效天数 And a.记录性质 = 2 And
                             a.号别 = b.号码 And a.号序 = b.序号 And a.号别 = 号别_In) Loop
          Delete From 挂号序号状态
          Where 日期 = c_失效预约.日期 And 序号 = c_失效预约.序号 And 状态 = 2 And 号码 = c_失效预约.号码;
        End Loop;
      End If;
    End If;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_挂号序号状态_Delete;
/

--93820:马政,2016-03-03,主动调售价后原价字段处理
Create Or Replace Procedure Zl_药品收发记录_Adjust
(
  Adjustid    In Number, --调价记录的ID
  Bln定价     In Number := 0, --是否转为定价销售（更新2004-06-08、收费细目中的变价）
  Billinfo_In In Varchar2 := Null, --用于时价药品按批次调价。格式:"批次1,现价1|批次2,现价2|....."
  药品id_In   In Number := 0 --当不为0时表示是成本价调价，不处理售价相关内容
) As
  Classid      Number(18); --入出类别
  v_Billno     药品收发记录.No%Type; --调价单号
  Rundate      Date; --调价生效时间
  Blnrun       Number(1); --调价时刻到了
  Blncurprice  Number(1); --时价药品
  Lng细目id    Number(18); --收费细目ID
  Adjustdate   Date; --调价时间
  n_批次       Number(18);
  n_现价       收费价目.现价%Type;
  n_原价       收费价目.原价%Type;
  v_Infotmp    Varchar2(4000);
  v_Fields     Varchar2(4000);
  n_序号       Number(8);
  n_原价id     收费价目.原价id%Type;
  n_收入项目id 收费价目.收入项目id%Type;
  n_零售金额   药品库存.实际金额%Type;
  n_零售价     药品库存.零售价%Type;
  n_收发id     药品收发记录.Id%Type;
  n_变动原因   收费价目.变动原因%Type;

  Cursor c_Price --普通调价
  Is
    Select 1 记录状态, 13 单据, v_Billno NO, Rownum 序号, Classid 入出类别id, m.Id As 药品id, s.批次, Null 批号, Null 效期, m.产地 As 产地, 1 付数,
           s.上次供应商id As 供应商id, s.实际数量 填写数量, 0 实际数量, a.原价 成本价, 0 成本金额, s.零售价 As 原售价, a.现价 零售价, 0 扣率, '药品调价' 摘要,
           Zl_Username 填制人, Sysdate 填制日期, s.库房id 库房id, 1 入出系数, a.Id 价格id, Nvl(m.是否变价, 0) As 时价, s.实际金额 As 库存金额,
           s.实际差价 As 库存差价
    From 药品库存 S, 收费项目目录 M, 收费价目 A
    Where s.药品id = m.Id And m.Id = a.收费细目id And s.性质 = 1 And a.变动原因 = 0 And a.Id = Adjustid And a.执行日期 <= Sysdate;

  v_Data c_Price%RowType;

  Cursor c_时价按批次调价 --时价药品按批次调价
  Is
    Select 1 记录状态, 13 单据, v_Billno NO, n_序号 + Rownum 序号, Classid 入出类别id, m.药品id 药品id, s.批次 批次, Null 批号, Null 效期,
           m.产地 As 产地, s.上次供应商id As 供应商id, 1 付数, Nvl(s.实际数量, 0) 填写数量, 0 实际数量, s.零售价 As 原售价, a.原价 成本价, 0 成本金额, n_现价 零售价,
           0 扣率, '药品调价' 摘要, Zl_Username 填制人, Sysdate 填制日期, s.库房id 库房id, 1 入出系数, a.Id 价格id, Nvl(b.是否变价, 0) As 时价,
           s.实际金额 As 库存金额, s.实际差价 As 库存差价
    From 药品库存 S, 药品目录 M, 收费价目 A, 收费项目目录 B
    Where s.药品id = b.Id And s.药品id = m.药品id And m.药品id = a.收费细目id And s.性质 = 1 And a.变动原因 = 0 And a.Id = Adjustid And
          a.执行日期 <= Sysdate And Nvl(s.批次, 0) = n_批次;

  v_时价按批次调价 c_时价按批次调价%RowType;
Begin
  If 药品id_In <> 0 Then
    --成本价调价
    Zl_药品收发记录_成本价调价(药品id_In);
  Else
    n_变动原因 := 0;
    --取调价记录生效日期
    Select 收费细目id, 执行日期, 收入项目id Into Lng细目id, Rundate, n_收入项目id From 收费价目 Where ID = Adjustid;
  
    If Sysdate >= Rundate Then
      Blnrun := 1;
    Else
      Blnrun := 0;
    End If;
  
    If Blnrun = 1 Then
      --取入出类别ID
      Select 类别id Into Classid From 药品单据性质 Where 单据 = 13;
    
      --取序列
      Select Nextno(147) Into v_Billno From Dual;
    
      --取该药品是否是时价药品
      Select Nvl(是否变价, 0) Into Blncurprice From 收费项目目录 Where ID = Lng细目id;
    
      --检查是否存在原价和现价相同的情况，相同时不执行调售价功能，并且删除这条收费价目记录，恢复原来的收费价目
      Begin
        Select 原价id Into n_原价id From 收费价目 Where ID = Adjustid And 原价 = 现价 And 原价id Is Not Null;
      Exception
        When Others Then
          n_原价id := 0;
      End;
    
      If n_原价id > 0 Then
        --如果现价=原价，这种情况下是单独调整收入项目，更新收入项目ID，删除调价记录
        Delete 收费价目 Where ID = Adjustid;
        Update 收费价目
        Set 收入项目id = n_收入项目id, 终止日期 = To_Date('3000-01-01', 'yyyy-mm-dd')
        Where ID = n_原价id;
      Else
        Adjustdate := Sysdate;
      
        Begin
          Select 变动原因 Into n_变动原因 From 收费价目 Where ID = Adjustid And 变动原因 = 1;
        Exception
          When Others Then
            n_变动原因 := 0;
        End;
        If n_变动原因 = 0 Then
          If Billinfo_In = '' Or Billinfo_In Is Null Then
            For v_Data In c_Price Loop
              Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
              If Nvl(v_Data.填写数量, 0) = 0 And (Nvl(v_Data.库存金额, 0) <> 0 Or Nvl(v_Data.库存差价, 0) <> 0) Then
                --数量=0 金额或差价<>0时只更新库存表中对应的零售价,并产生售价修正数据但是金额差=0，只记录最新售价，金额差和差价差不填数据
                --产生调价影响记录
                Insert Into 药品收发记录
                  (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 摘要, 填制人,
                   填制日期, 库房id, 入出系数, 价格id, 审核人, 审核日期, 单量, 频次, 供药单位id)
                Values
                  (n_收发id, v_Data.记录状态, v_Data.单据, v_Data.No, v_Data.序号, v_Data.入出类别id, v_Data.药品id, v_Data.批次,
                   v_Data.批号, v_Data.效期, v_Data.产地, v_Data.付数, v_Data.填写数量, v_Data.实际数量,
                   Decode(Blncurprice, 1, v_Data.原售价, v_Data.成本价), v_Data.成本金额, v_Data.零售价, v_Data.扣率, v_Data.摘要,
                   v_Data.填制人, v_Data.填制日期, v_Data.库房id, v_Data.入出系数, v_Data.价格id, Zl_Username, Adjustdate, v_Data.库存金额,
                   v_Data.库存差价, v_Data.供应商id);
              
                --更新库存零售价,只有时价分批药品才能更新零售价字段
                Zl_药品库存_Update(n_收发id, 2, 0);
              Else
                If Blncurprice = 1 Then
                  n_零售价 := v_Data.库存金额 / v_Data.填写数量;
                Else
                  n_零售价 := v_Data.成本价;
                End If;
                n_零售金额 := Round((v_Data.零售价 - n_零售价) * v_Data.填写数量, 2);
              
                --产生调价影响记录
                Insert Into 药品收发记录
                  (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 零售金额, 差价, 摘要,
                   填制人, 填制日期, 库房id, 入出系数, 价格id, 审核人, 审核日期, 单量, 频次, 供药单位id)
                Values
                  (n_收发id, v_Data.记录状态, v_Data.单据, v_Data.No, v_Data.序号, v_Data.入出类别id, v_Data.药品id, v_Data.批次,
                   v_Data.批号, v_Data.效期, v_Data.产地, v_Data.付数, v_Data.填写数量, v_Data.实际数量,
                   Decode(Blncurprice, 1, v_Data.原售价, v_Data.成本价), v_Data.成本金额, v_Data.零售价, v_Data.扣率, n_零售金额, n_零售金额,
                   v_Data.摘要, v_Data.填制人, v_Data.填制日期, v_Data.库房id, v_Data.入出系数, v_Data.价格id, Zl_Username, Adjustdate,
                   v_Data.库存金额, v_Data.库存差价, v_Data.供应商id);
              
                --更新药品库存
                Zl_药品库存_Update(n_收发id, 2, 0);
              End If;
            End Loop;
          Else
            n_序号 := 0;
            --时价药品按批次调价
            v_Infotmp := Billinfo_In || '|';
            While v_Infotmp Is Not Null Loop
              --分解单据ID串
              v_Fields  := Substr(v_Infotmp, 1, Instr(v_Infotmp, '|') - 1);
              n_批次    := Substr(v_Fields, 1, Instr(v_Fields, ',') - 1);
              n_现价    := Substr(v_Fields, Instr(v_Fields, ',') + 1);
              v_Infotmp := Replace('|' || v_Infotmp, '|' || v_Fields || '|');
            
              For v_时价按批次调价 In c_时价按批次调价 Loop
                If v_时价按批次调价.填写数量 <> 0 Then
                  n_原价 := Nvl(v_时价按批次调价.库存金额, 0) / v_时价按批次调价.填写数量;
                Else
                  n_原价 := v_时价按批次调价.成本价;
                End If;
              
                Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
                If Nvl(v_时价按批次调价.填写数量, 0) = 0 And (Nvl(v_时价按批次调价.库存金额, 0) <> 0 Or Nvl(v_时价按批次调价.库存差价, 0) <> 0) Then
                  --数量=0 金额或差价<>0时只更新库存表中对应的零售价,并产生售价修正数据但是金额差=0，只记录最新售价，金额差和差价差不填数据
                  --产生调价影响记录
                  Insert Into 药品收发记录
                    (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 摘要, 填制人,
                     填制日期, 库房id, 入出系数, 价格id, 审核人, 审核日期, 单量, 频次, 供药单位id)
                  Values
                    (n_收发id, v_时价按批次调价.记录状态, v_时价按批次调价.单据, v_时价按批次调价.No, v_时价按批次调价.序号, v_时价按批次调价.入出类别id, v_时价按批次调价.药品id,
                     v_时价按批次调价.批次, v_时价按批次调价.批号, v_时价按批次调价.效期, v_时价按批次调价.产地, v_时价按批次调价.付数, v_时价按批次调价.填写数量,
                     v_时价按批次调价.实际数量, Decode(Blncurprice, 1, v_时价按批次调价.原售价, v_时价按批次调价.成本价), v_时价按批次调价.成本金额, v_时价按批次调价.零售价,
                     v_时价按批次调价.扣率, v_时价按批次调价.摘要, v_时价按批次调价.填制人, v_时价按批次调价.填制日期, v_时价按批次调价.库房id, v_时价按批次调价.入出系数,
                     v_时价按批次调价.价格id, Zl_Username, Adjustdate, v_时价按批次调价.库存金额, v_时价按批次调价.库存差价, v_时价按批次调价.供应商id);
                  n_序号 := n_序号 + 1;
                
                  --更新库存零售价,只有时价分批药品才能更新零售价字段
                  Zl_药品库存_Update(n_收发id, 2, 0);
                Else
                  n_零售价   := v_时价按批次调价.库存金额 / v_时价按批次调价.填写数量;
                  n_零售金额 := Round((n_现价 - n_零售价) * v_时价按批次调价.填写数量, 2);
                
                  --产生调价影响记录
                  Insert Into 药品收发记录
                    (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 零售金额, 差价,
                     摘要, 填制人, 填制日期, 库房id, 入出系数, 价格id, 审核人, 审核日期, 单量, 频次, 供药单位id)
                  Values
                    (n_收发id, v_时价按批次调价.记录状态, v_时价按批次调价.单据, v_时价按批次调价.No, v_时价按批次调价.序号, v_时价按批次调价.入出类别id, v_时价按批次调价.药品id,
                     v_时价按批次调价.批次, v_时价按批次调价.批号, v_时价按批次调价.效期, v_时价按批次调价.产地, v_时价按批次调价.付数, v_时价按批次调价.填写数量,
                     v_时价按批次调价.实际数量, Decode(Blncurprice, 1, v_时价按批次调价.原售价, v_时价按批次调价.成本价), v_时价按批次调价.成本金额, v_时价按批次调价.零售价,
                     v_时价按批次调价.扣率, n_零售金额, n_零售金额, v_时价按批次调价.摘要, v_时价按批次调价.填制人, v_时价按批次调价.填制日期, v_时价按批次调价.库房id,
                     v_时价按批次调价.入出系数, v_时价按批次调价.价格id, Zl_Username, Adjustdate, v_时价按批次调价.库存金额, v_时价按批次调价.库存差价,
                     v_时价按批次调价.供应商id);
                  n_序号 := n_序号 + 1;
                
                  --更新库存
                  Zl_药品库存_Update(n_收发id, 2, 0);
                End If;
              End Loop;
            End Loop;
          End If;
        
          Update 收费价目 Set 变动原因 = 1 Where ID = Adjustid;
          --更新药品目录、收费细目中的变价
          If Bln定价 = 1 Then
            Update 收费项目目录 Set 是否变价 = 0 Where ID = Lng细目id;
            Update 收费细目 Set 是否变价 = 0 Where ID = Lng细目id;
          End If;
        End If;
      End If;
    
      If n_变动原因 = 0 Then
        --成本价调价
        Zl_药品收发记录_成本价调价(Lng细目id, Rundate);
      End If;
    End If;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_Adjust;
/


--93911:李南春,2016-03-04,费用清单打印转出问题
--93853:张永康,2016-03-03,历史数据抽回错误修正
Create Or Replace Procedure Zl_Retu_Exes
(
  v_No   In Varchar2,
  n_Type In Number
) As
  --------------------------------------------
  --参数:v_No,单据号码
  --     n_Type,单据类型:1-收费,2-记帐,3-自动记帐,4-挂号,5-就诊卡,6-预交,7-结帐,8-未结费用的病人id,主页ID
  --------------------------------------------
  n_Allow  Number(1); --是否能够单据返回
  n_Patiid Number(18);
  n_Pageid Number(5);
  Err_Item Exception;
  v_Err_Msg Varchar2(100);
  n_System  Number(5);
  n_只读    Number(2);

  v_Table  Varchar2(100);
  v_Field  Varchar2(100);
  v_Sql    Varchar2(4000);
  v_Fields Varchar2(4000);

  --功能：获取表的字段字符串
  Function Getfields(v_Table In Varchar2) Return Varchar2 As
    v_Colstr Varchar2(4000);
  Begin
    Select f_List2str(Cast(Collect(Column_Name) As t_Strlist)) As Colsstr
    Into v_Colstr
    From (Select Column_Name From User_Tab_Columns Where Table_Name = v_Table Order By Column_Id);
  
    Return v_Colstr;
  End Getfields;

  --------------------------------------------
  --返回指定ID的病人预交记录子过程
  --------------------------------------------
  Procedure Zl_Retu_Prepay(n_Settle_Id H病人预交记录.结帐id%Type) As
  Begin
    For r_Rec In (Select * From H病人预交记录 Where 结帐id = n_Settle_Id) Loop
      v_Table  := '病人卡结算对照';
      v_Fields := Getfields(v_Table);
      v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || replace(v_Fields,'待转出','Null as 待转出') || ' From H' || v_Table ||
                  ' Where 预交id = :1';
      Execute Immediate v_Sql
        Using r_Rec.Id;
    
      v_Table  := '三方结算交易';
      v_Fields := Getfields(v_Table);
      v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || replace(v_Fields,'待转出','Null as 待转出') || ' From H' || v_Table ||
                  ' Where 交易ID = :1';
      Execute Immediate v_Sql
        Using r_Rec.Id;
    
      v_Table  := '三方退款信息';
      v_Fields := Getfields(v_Table);
      v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || replace(v_Fields,'待转出','Null as 待转出') || ' From H' || v_Table ||
                  ' Where 记录ID = :1 And 结帐ID = :2';
      Execute Immediate v_Sql
        Using r_Rec.Id, n_Settle_Id;
    
      v_Table  := '病人卡结算记录';
      v_Fields := Getfields(v_Table);
      v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || replace(v_Fields,'待转出','Null as 待转出') || ' From H' || v_Table ||
                  ' Where ID In(Select 卡结算id From H病人卡结算对照 Where 预交id = :1)';
      Execute Immediate v_Sql
        Using r_Rec.Id;
    
      Delete H病人卡结算记录 Where ID In (Select Distinct 卡结算id From H病人卡结算对照 Where 预交id = r_Rec.Id);
      Delete From H病人卡结算对照 Where 预交id = r_Rec.Id;
      Delete From H三方结算交易 Where 交易id = r_Rec.Id;
      Delete From H三方退款信息 Where 记录id = r_Rec.Id And 结帐id = n_Settle_Id;
    End Loop;
  
    v_Table  := '病人预交记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || replace(v_Fields,'待转出','Null as 待转出') || ' From H' || v_Table ||
                ' Where 结帐id = :1';
    Execute Immediate v_Sql
      Using n_Settle_Id;
  
    Delete H病人预交记录 Where 结帐id = n_Settle_Id;
  End Zl_Retu_Prepay;

  --------------------------------------------
  --返回指定ID的病人费用记录子过程
  --------------------------------------------
  Procedure Zl_Retu_Fee(n_Settle_Id H住院费用记录.结帐id%Type) As
  Begin
    --返回病人费用记录
    v_Table  := '住院费用记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || replace(v_Fields,'待转出','Null as 待转出') || ' From H' || v_Table ||
                ' Where 结帐id = :1';
    Execute Immediate v_Sql
      Using n_Settle_Id;
  
    v_Table  := '门诊费用记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || replace(v_Fields,'待转出','Null as 待转出') || ' From H' || v_Table ||
                ' Where 结帐id = :1';
    Execute Immediate v_Sql
      Using n_Settle_Id;
  
    v_Table  := '费用补充记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || replace(v_Fields,'待转出','Null as 待转出') || ' From H' || v_Table ||
                ' Where 结算id = :1';
    Execute Immediate v_Sql
      Using n_Settle_Id;
  
    v_Table  := '医保结算明细';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || replace(v_Fields,'待转出','Null as 待转出') || ' From H' || v_Table ||
                ' Where 结帐id = :1';
    Execute Immediate v_Sql
      Using n_Settle_Id;
  
    --删除已返回的费用记录
    Delete H门诊费用记录 Where 结帐id = n_Settle_Id;
    Delete H住院费用记录 Where 结帐id = n_Settle_Id;
    Delete H费用补充记录 Where 结算id = n_Settle_Id;
    Delete H医保结算明细 Where 结帐id = n_Settle_Id;
  End Zl_Retu_Fee;

  --------------------------------------------
  --返回指定ID的药品收发记录子过程
  --------------------------------------------
  Procedure Zl_Retu_Medilist(n_Rec_Id H药品收发记录.Id%Type) As
  Begin
    --按外键引用顺序返回药品收发相关表的数据     
    v_Table  := '药品收发记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || replace(v_Fields,'待转出','Null as 待转出') || ' From H' || v_Table ||
                ' Where ID = :1';
    Execute Immediate v_Sql
      Using n_Rec_Id;
  
    v_Table  := '输液配药记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || replace(v_Fields,'待转出','Null as 待转出') || ' From H' || v_Table ||
                ' Where ID In(Select 记录ID From H输液配药内容 Where 收发ID =:1)';
    Execute Immediate v_Sql
      Using n_Rec_Id;
  
    For P In (Select ID From H输液配药记录 Where ID In (Select 记录id From H输液配药内容 Where 收发id = n_Rec_Id)) Loop
      For R In (Select Column_Value From Table(f_Str2list('输液配药附费,输液配药状态'))) Loop
        v_Table := r.Column_Value;
        v_Field := 'ID';
      
        v_Fields := Getfields(v_Table);
        v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || replace(v_Fields,'待转出','Null as 待转出') || ' From H' || v_Table ||
                    ' Where ' || v_Field || ' = :1';
        Execute Immediate v_Sql
          Using p.Id;
      
        v_Sql := 'Delete H' || v_Table || ' Where ' || v_Field || ' = :1';
        Execute Immediate v_Sql
          Using p.Id;
      End Loop;
    End Loop;
  
    Delete H输液配药记录 Where ID In (Select 记录id From H输液配药内容 Where 收发id = n_Rec_Id);
  
    v_Table  := '药品签名记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || replace(v_Fields,'待转出','Null as 待转出') || ' From H' || v_Table ||
                ' Where ID In(Select 签名ID From H药品签名明细 Where 收发ID =:1)';
    Execute Immediate v_Sql
      Using n_Rec_Id;
    Delete H药品签名记录 Where ID In (Select 签名id From H药品签名明细 Where 收发id = n_Rec_Id);
  
    For R In (Select Column_Value From Table(f_Str2list('收发记录补充信息,输液配药内容,药品签名明细,药品留存计划'))) Loop
      v_Table := r.Column_Value;
      If v_Table = '药品留存计划' Then
        v_Field := '留存ID';
      Else
        v_Field := '收发ID';
      End If;
    
      v_Fields := Getfields(v_Table);
      v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || replace(v_Fields,'待转出','Null as 待转出') || ' From H' || v_Table ||
                  ' Where ' || v_Field || ' = :1';
      Execute Immediate v_Sql
        Using n_Rec_Id;
    
      v_Sql := 'Delete From H' || v_Table || ' Where ' || v_Field || ' = :1';
      Execute Immediate v_Sql
        Using n_Rec_Id;
    End Loop;
  
    --删除已返回的药品收发记录
    Delete H药品收发记录 Where ID = n_Rec_Id;
  End Zl_Retu_Medilist;

  --------------------------------------------
  --以下为主程序体
  --------------------------------------------
Begin
  ----------------------------------------------------------------------------------------------------------
  --刘兴宏:主要是对基于视图的视图的转储方案进行了只读判断.
  Select 编号 Into n_System From zlSystems Where Upper(所有者) = Zl_Owner And 编号 Like '1%';
  Begin
    Select Nvl(只读, 0) Into n_只读 From zlBakSpaces Where 系统 = n_System And 当前 = 1;
  Exception
    When Others Then
      v_Err_Msg := '[ZLSOFT]当前没有可用的历史数据空间,不能继续![ZLSOFT]';
      Raise Err_Item;
  End;
  If n_只读 = 1 Then
    v_Err_Msg := '[ZLSOFT]历史数据空间目前的状态为只读,不能继续![ZLSOFT]';
    Raise Err_Item;
  End If;

  If n_Type = 8 Then
    --8-抽回指定病人的未结记帐费用
    --排除：结帐作废后，记帐单销帐的记录（记录状态为2的没有结帐ID，记录状态为3的有结帐ID的) 
    If Instr(v_No, ',') = 0 Then
      --a.按病人ID抽回门诊病人的未结记帐费用
      For Rno In (Select NO, 记录性质
                  From H门诊费用记录 A
                  Where 病人id = To_Number(v_No) And a.记帐费用 = 1 And 结帐id Is Null And Not Exists
                   (Select 1
                         From H门诊费用记录 B
                         Where a.No = b.No And a.记录性质 = b.记录性质 And a.序号 = b.序号 And b.记录状态 = 3 And b.结帐id Is Not Null)) Loop
        v_Table  := '门诊费用记录';
        v_Fields := Getfields(v_Table);
        v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                    Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table || ' Where NO = :1 And 记录性质 = :2';
        Execute Immediate v_Sql
          Using Rno.No, Rno.记录性质;
      
        For r_Rxlist In (Select m.Id
                         From H药品收发记录 M, H门诊费用记录 E
                         Where e.No = Rno.No And e.记录性质 = Rno.记录性质 And e.收费类别 In ('4', '5', '6', '7') And m.费用id = e.Id And
                               m.单据 In (9, 10, 25, 26)) Loop
          Zl_Retu_Medilist(r_Rxlist.Id);
        End Loop;
        Delete H门诊费用记录 Where NO = Rno.No And 记录性质 = Rno.记录性质;
      End Loop;
    Else
      --b.按病人ID,主页ID抽回住院病人的未结记帐费用
      n_Patiid := Substr(v_No, 1, Instr(v_No, ',') - 1);
      n_Pageid := Substr(v_No, Instr(v_No, ',') + 1);
    
      For Rno In (Select NO, 记录性质
                  From H住院费用记录 A
                  Where 病人id = n_Patiid And 主页id = n_Pageid And a.记帐费用 = 1 And 结帐id Is Null And Not Exists
                   (Select 1
                         From H住院费用记录 B
                         Where a.No = b.No And a.记录性质 = b.记录性质 And a.序号 = b.序号 And b.记录状态 = 3 And b.结帐id Is Not Null)) Loop
        v_Table  := '住院费用记录';
        v_Fields := Getfields(v_Table);
        v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                    Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table || ' Where NO = :1 And 记录性质 = :2';
        Execute Immediate v_Sql
          Using Rno.No, Rno.记录性质;
      
        For r_Rxlist In (Select m.Id
                         From H药品收发记录 M, H住院费用记录 E
                         Where e.No = Rno.No And e.记录性质 = Rno.记录性质 And e.收费类别 In ('4', '5', '6', '7') And m.费用id = e.Id And
                               m.单据 In (9, 10, 25, 26)) Loop
          Zl_Retu_Medilist(r_Rxlist.Id);
        End Loop;
        Delete H住院费用记录 Where NO = Rno.No And 记录性质 = Rno.记录性质;
      End Loop;
    End If;
  Else
    --判断是否能按照单据返回
    Select Decode(Sum(Nvl(p.金额, 0)) - Sum(Nvl(p.冲预交, 0)), Null, 1, 0, 1, 0)
    Into n_Allow
    From H病人预交记录 P,
         (Select 结帐id
           From H门诊费用记录
           Where NO = v_No And (1 = n_Type And 记录性质 = 1 Or 2 = n_Type And 记录性质 = 2 Or 3 = n_Type And 记录性质 = 3 Or
                 4 = n_Type And 记录性质 = 4 Or 5 = n_Type And 记录性质 = 5)
           Union
           Select 结帐id
           From H住院费用记录
           Where NO = v_No And (1 = n_Type And 记录性质 = 1 Or 2 = n_Type And 记录性质 = 2 Or 3 = n_Type And 记录性质 = 3 Or
                 4 = n_Type And 记录性质 = 4 Or 5 = n_Type And 记录性质 = 5)
           Union
           Select 结帐id
           From H病人预交记录
           Where NO = v_No And 6 = n_Type And 记录性质 In (1, 11)
           Union
           Select ID
           From H病人结帐记录
           Where NO = v_No And 7 = n_Type) L
    Where p.结帐id = l.结帐id And p.记录性质 In (1, 11);
    If n_Allow = 1 Then
      Select Decode(Sum(Nvl(e.实收金额, 0)) - Sum(Nvl(e.结帐金额, 0)), Null, 1, 0, 1, 0)
      Into n_Allow
      From (Select e.实收金额, e.结帐金额
             From H门诊费用记录 E,
                  (Select 结帐id
                    From H门诊费用记录
                    Where NO = v_No And (1 = n_Type And 记录性质 = 1 Or 2 = n_Type And 记录性质 = 2 Or 3 = n_Type And 记录性质 = 3 Or
                          4 = n_Type And 记录性质 = 4 Or 5 = n_Type And 记录性质 = 5)
                    Union
                    Select 结帐id
                    From H病人预交记录
                    Where NO = v_No And 6 = n_Type And 记录性质 In (1, 11)
                    Union
                    Select ID
                    From H病人结帐记录
                    Where NO = v_No And 7 = n_Type) L
             Where e.结帐id = l.结帐id
             Union All
             Select e.实收金额, e.结帐金额
             From H住院费用记录 E,
                  (Select 结帐id
                    From H住院费用记录
                    Where NO = v_No And (1 = n_Type And 记录性质 = 1 Or 2 = n_Type And 记录性质 = 2 Or 3 = n_Type And 记录性质 = 3 Or
                          4 = n_Type And 记录性质 = 4 Or 5 = n_Type And 记录性质 = 5)
                    Union
                    Select 结帐id
                    From H病人预交记录
                    Where NO = v_No And 6 = n_Type And 记录性质 In (1, 11)
                    Union
                    Select ID
                    From H病人结帐记录
                    Where NO = v_No And 7 = n_Type) L
             Where e.结帐id = l.结帐id) E;
    End If;
  
    --按照单据或病人获取结帐游标返回
    If n_Allow = 1 Then
      For r_Settle In (Select 结帐id
                       From H门诊费用记录
                       Where NO = v_No And
                             (1 = n_Type And 记录性质 = 1 Or 2 = n_Type And 记录性质 = 2 Or 3 = n_Type And 记录性质 = 3 Or
                             4 = n_Type And 记录性质 = 4 Or 5 = n_Type And 记录性质 = 5)
                       Union
                       Select 结帐id
                       From H住院费用记录
                       Where NO = v_No And
                             (1 = n_Type And 记录性质 = 1 Or 2 = n_Type And 记录性质 = 2 Or 3 = n_Type And 记录性质 = 3 Or
                             4 = n_Type And 记录性质 = 4 Or 5 = n_Type And 记录性质 = 5)
                       Union
                       Select 结帐id
                       From H病人预交记录
                       Where NO = v_No And 6 = n_Type And 记录性质 In (1, 11)
                       Union All
                       Select ID
                       From H病人结帐记录
                       Where NO = v_No And 7 = n_Type) Loop
      
        v_Table  := '病人结帐记录';
        v_Fields := Getfields(v_Table);
        v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || replace(v_Fields,'待转出','Null as 待转出') || ' From H' || v_Table ||
                    ' Where id = :1';
        Execute Immediate v_Sql
          Using r_Settle.结帐id;
      
        Zl_Retu_Prepay(r_Settle.结帐id);
        For r_Rxlist In (Select m.Id
                         From H药品收发记录 M,
                              (Select ID, NO, 序号, 记录性质
                                From H门诊费用记录
                                Where 结帐id = r_Settle.结帐id And 收费类别 In ('4', '5', '6', '7') And 记录性质 In (1, 2)) E
                         Where m.No = e.No And m.费用id = e.Id And
                               (e.记录性质 = 1 And m.单据 In (8, 24) Or e.记录性质 <> 1 And m.单据 In (9, 10, 25, 26))
                         Union All
                         Select m.Id
                         From H药品收发记录 M,
                              (Select ID, NO, 序号, 记录性质
                                From H住院费用记录
                                Where 结帐id = r_Settle.结帐id And 收费类别 In ('4', '5', '6', '7') And 记录性质 In (1, 2)) E
                         Where m.No = e.No And m.费用id = e.Id And
                               (e.记录性质 = 1 And m.单据 In (8, 24) Or e.记录性质 <> 1 And m.单据 In (9, 10, 25, 26))) Loop
          Zl_Retu_Medilist(r_Rxlist.Id);
        End Loop;

        --费用清单打印
        For r_FeePrint In (
               Select NO,Mod(记录性质,10) as 记录性质,Decode(记录状态,3,1,记录状态) as 记录状态,序号
                 From H门诊费用记录
                Where 结帐id = r_Settle.结帐id
                 Union
               Select  NO,Mod(记录性质,10) as 记录性质,Decode(记录状态,3,1,记录状态) as 记录状态,序号
                 From H住院费用记录
                Where  结帐id = r_Settle.结帐id) Loop

            v_Table  := '费用清单打印';
            v_Fields := Getfields(v_Table);
            v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || replace(v_Fields,'待转出','Null as 待转出') || ' From H' || v_Table ||
                  ' Where NO = :1 And Mod(记录性质,10) = :2 And Decode(记录状态,3,1,记录状态) = :3 And 序号 = :4';
            Execute Immediate v_Sql
              Using r_FeePrint.NO,r_FeePrint.记录性质,r_FeePrint.记录状态,r_FeePrint.序号;
            Delete H费用清单打印 Where NO = r_FeePrint.NO And Mod(记录性质,10) = r_FeePrint.记录性质 And Decode(记录状态,3,1,记录状态) = r_FeePrint.记录状态 And 序号 = r_FeePrint.序号;
        End Loop;

        Zl_Retu_Fee(r_Settle.结帐id);
      
        Delete H病人结帐记录 Where ID = r_Settle.结帐id;
      End Loop;
    Else
      Begin
        --n_Type,单据类型:1-收费,2-记帐,3-自动记帐,4-挂号,5-就诊卡,6-预交,7-结帐
        If n_Type = 7 Then
          Select Distinct 病人id Into n_Patiid From H病人结帐记录 Where NO = v_No;
        Elsif n_Type = 6 Then
          Select Distinct 病人id
          Into n_Patiid
          From H病人预交记录
          Where NO = v_No And 6 = n_Type And 记录性质 In (1, 11);
        Elsif n_Type = 5 Or n_Type = 3 Then
          Select Distinct 病人id
          Into n_Patiid
          From H住院费用记录
          Where NO = v_No And (1 = n_Type And 记录性质 = 1 Or 2 = n_Type And 记录性质 = 2 Or 3 = n_Type And 记录性质 = 3 Or
                4 = n_Type And 记录性质 = 4 Or 5 = n_Type And 记录性质 = 5);
        Elsif n_Type = 4 Or n_Type = 1 Then
          If n_Type = 1 Then
            Select Distinct 病人id
            Into n_Patiid
            From (Select Distinct 病人id
                   From H门诊费用记录
                   Where NO = v_No And 记录性质 = 1
                   Union All
                   Select Distinct 病人id
                   From H费用补充记录
                   Where NO = v_No And 记录性质 = 1)
            Where Rownum < 2;
          
          Else
            Select Distinct 病人id
            Into n_Patiid
            From H门诊费用记录
            Where NO = v_No And (1 = n_Type And 记录性质 = 1 Or 2 = n_Type And 记录性质 = 2 Or 3 = n_Type And 记录性质 = 3 Or
                  4 = n_Type And 记录性质 = 4 Or 5 = n_Type And 记录性质 = 5);
          End If;
        Else
          Begin
            Select Distinct 病人id
            Into n_Patiid
            From H住院费用记录
            Where NO = v_No And (1 = n_Type And 记录性质 = 1 Or 2 = n_Type And 记录性质 = 2 Or 3 = n_Type And 记录性质 = 3 Or
                  4 = n_Type And 记录性质 = 4 Or 5 = n_Type And 记录性质 = 5);
          Exception
            When Others Then
              n_Patiid := -1;
          End;
          If Nvl(n_Patiid, 0) <= 0 Then
            Select Distinct 病人id
            Into n_Patiid
            From H门诊费用记录
            Where NO = v_No And (1 = n_Type And 记录性质 = 1 Or 2 = n_Type And 记录性质 = 2 Or 3 = n_Type And 记录性质 = 3 Or
                  4 = n_Type And 记录性质 = 4 Or 5 = n_Type And 记录性质 = 5);
          End If;
        End If;
      Exception
        When Others Then
          n_Patiid := Null;
      End Zl_Patiid;
    
      For r_Settle In (Select Distinct 结帐id
                       From H门诊费用记录
                       Where 病人id = n_Patiid
                       Union
                       Select Distinct 结帐id
                       From H住院费用记录
                       Where 病人id = n_Patiid
                       Union
                       Select Distinct 结算id
                       From H费用补充记录
                       Where 病人id = n_Patiid) Loop
      
        v_Table  := '病人结帐记录';
        v_Fields := Getfields(v_Table);
        v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || replace(v_Fields,'待转出','Null as 待转出') || ' From H' || v_Table ||
                    ' Where id = :1';
        Execute Immediate v_Sql
          Using r_Settle.结帐id;
      
        Zl_Retu_Prepay(r_Settle.结帐id);
        For r_Rxlist In (Select m.Id
                         From H药品收发记录 M,
                              (Select ID, NO, 序号, 记录性质
                                From H门诊费用记录
                                Where 结帐id = r_Settle.结帐id And 收费类别 In ('4', '5', '6', '7') And 记录性质 In (1, 2)) E
                         Where m.No = e.No And m.费用id = e.Id And
                               (e.记录性质 = 1 And m.单据 In (8, 24) Or e.记录性质 <> 1 And m.单据 In (9, 10, 25, 26))
                         Union All
                         Select m.Id
                         From H药品收发记录 M,
                              (Select ID, NO, 序号, 记录性质
                                From H住院费用记录
                                Where 结帐id = r_Settle.结帐id And 收费类别 In ('4', '5', '6', '7') And 记录性质 In (1, 2)) E
                         Where m.No = e.No And m.费用id = e.Id And
                               (e.记录性质 = 1 And m.单据 In (8, 24) Or e.记录性质 <> 1 And m.单据 In (9, 10, 25, 26))
                         
                         ) Loop
          Zl_Retu_Medilist(r_Rxlist.Id);
        End Loop;

        --费用清单打印
        For r_FeePrint In (
               Select NO,Mod(记录性质,10) as 记录性质,Decode(记录状态,3,1,记录状态) as 记录状态,序号
                 From H门诊费用记录
                Where 结帐id = r_Settle.结帐id
                 Union
               Select  NO,Mod(记录性质,10) as 记录性质,Decode(记录状态,3,1,记录状态) as 记录状态,序号
                 From H住院费用记录
                Where  结帐id = r_Settle.结帐id) Loop

            v_Table  := '费用清单打印';
            v_Fields := Getfields(v_Table);
            v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || replace(v_Fields,'待转出','Null as 待转出') || ' From H' || v_Table ||
                  ' Where NO = :1 And Mod(记录性质,10) = :2 And Decode(记录状态,3,1,记录状态) = :3 And 序号 = :4';
            Execute Immediate v_Sql
              Using r_FeePrint.NO,r_FeePrint.记录性质,r_FeePrint.记录状态,r_FeePrint.序号;
            Delete H费用清单打印 Where NO = r_FeePrint.NO And Mod(记录性质,10) = r_FeePrint.记录性质 And Decode(记录状态,3,1,记录状态) = r_FeePrint.记录状态 And 序号 = r_FeePrint.序号;
        End Loop;

        Zl_Retu_Fee(r_Settle.结帐id);
        Delete H病人结帐记录 Where ID = r_Settle.结帐id;
      
      End Loop;
    End If;
  End If;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM || ':' || v_Sql);
End Zl_Retu_Exes;
/

--93846:刘尔旋,2016-03-03,诊间支付判断
Create Or Replace Function Zl_Get_Threecardtypeid
(
  模块号_In Number,
  病人id_In 门诊费用记录.病人id%Type,
  医嘱id_In 病人医嘱记录.Id%Type
) Return Number Is
  ------------------------------------------------------------------------------------------- 
  --功能:获取当前三方接口支付的卡类别ID 
  --入参: 模块号_IN-调整的模块号 
  --      病人ID_In-当前就诊的病人ID 
  --      医嘱id_In-医嘱ID
  --返回:三方帐户支付的卡类别ID,如果返回了卡类别ID,则不再进入刷卡界面,而直接调用三方支付接口 
  --说明: 
  --  1.门诊医生站调用: 目前暂时在门诊医生工作站调用,需要配合诊间支付的参数设置才有效 
  --  2.其他执行科室:暂未调用该过程,如期需要可以扩展 
  --  3.此过程,需根据用户的具体业务需求进行返回 
  ------------------------------------------------------------------------------------------- 
Begin
  If Nvl(模块号_In, 0) = 1260 Then
    --门诊医生工作站 
    If Nvl(病人id_In, 0) = 0 And Nvl(医嘱id_In, 0) = 0 Then
      Return Null;
    End If;
    Return Null;
  End If;
  Return Null;
End Zl_Get_Threecardtypeid;
/

--93719:胡俊勇,2016-03-02,易用性改进
Create Or Replace Procedure Zl_成套方案项目_Update
(
  Id_In       诊疗项目目录.Id%Type,
  分类id_In   诊疗项目目录.分类id%Type,
  编码_In     诊疗项目目录.编码%Type,
  名称_In     诊疗项目目录.名称%Type,
  名称拼音_In 诊疗项目别名.简码%Type,
  名称五笔_In 诊疗项目别名.简码%Type,
  别名_In     诊疗项目目录.名称%Type,
  别名拼音_In 诊疗项目别名.简码%Type,
  别名五笔_In 诊疗项目别名.简码%Type,
  说明_In     诊疗项目目录.标本部位%Type,
  人员id_In   诊疗项目目录.人员id%Type := Null, --如果传入，表示个人使用的成套项目 
  科室id_In   Varchar2 := Null, --如果传入，表示可以使用的科室，格式为"ID1,ID2,..." 
  服务对象_In 诊疗项目目录.服务对象%Type := 3,
  站点_In     In 诊疗项目目录.站点%Type := Null,
  建档人_In   In 诊疗项目目录.建档人%Type := Null,
  全选_In     In 诊疗项目目录.执行分类%Type := Null --为1时医嘱下达调用本方案时默认全选所有项目，否则不选任何项目。
) Is
  v_科室串 Varchar2(4000);
  v_科室id 诊疗适用科室.科室id%Type;
Begin
  --配方名称修改或增加 
  Update 诊疗项目目录
  Set 分类id = 分类id_In, 编码 = 编码_In, 名称 = 名称_In, 标本部位 = 说明_In, 适用性别 = 0, 组合项目 = 1, 服务对象 = Nvl(服务对象_In, 3), 单独应用 = 1,
      人员id = 人员id_In, 站点 = 站点_In, 执行分类 = 全选_In
  Where ID = Id_In;
  If Sql%RowCount = 0 Then
    Insert Into 诊疗项目目录
      (类别, 分类id, ID, 编码, 名称, 标本部位, 适用性别, 组合项目, 服务对象, 单独应用, 建档时间, 撤档时间, 人员id, 站点, 建档人, 执行分类)
    Values
      ('9', 分类id_In, Id_In, 编码_In, 名称_In, 说明_In, 0, 1, Nvl(服务对象_In, 3), 1, Sysdate, To_Date('3000-01-01', 'YYYY-MM-DD'),
       人员id_In, 站点_In, 建档人_In, 全选_In);
  End If;
  --填写适用科室 
  Delete From 诊疗适用科室 Where 项目id = Id_In;
  If 科室id_In Is Not Null Then
    v_科室串 := 科室id_In || ',';
    While v_科室串 Is Not Null Loop
      v_科室id := To_Number(Substr(v_科室串, 1, Instr(v_科室串, ',') - 1));
      v_科室串 := Substr(v_科室串, Instr(v_科室串, ',') + 1);
    
      Insert Into 诊疗适用科室 (项目id, 科室id) Values (Id_In, v_科室id);
    End Loop;
  End If;
  --名称简码处理 
  If 名称_In Is Null Or 名称拼音_In Is Null Then
    Delete 诊疗项目别名 Where 诊疗项目id = Id_In And 性质 = 1 And 码类 = 1;
  Else
    Update 诊疗项目别名 Set 名称 = 名称_In, 简码 = 名称拼音_In Where 诊疗项目id = Id_In And 性质 = 1 And 码类 = 1;
    If Sql%RowCount = 0 Then
      Insert Into 诊疗项目别名 (诊疗项目id, 名称, 性质, 简码, 码类) Values (Id_In, 名称_In, 1, 名称拼音_In, 1);
    End If;
  End If;

  If 名称_In Is Null Or 名称五笔_In Is Null Then
    Delete 诊疗项目别名 Where 诊疗项目id = Id_In And 性质 = 1 And 码类 = 2;
  Else
    Update 诊疗项目别名 Set 名称 = 名称_In, 简码 = 名称五笔_In Where 诊疗项目id = Id_In And 性质 = 1 And 码类 = 2;
    If Sql%RowCount = 0 Then
      Insert Into 诊疗项目别名 (诊疗项目id, 名称, 性质, 简码, 码类) Values (Id_In, 名称_In, 1, 名称五笔_In, 2);
    End If;
  End If;

  --别名处理 
  If 别名_In Is Null Or 别名拼音_In Is Null Then
    Delete 诊疗项目别名 Where 诊疗项目id = Id_In And 性质 = 9 And 码类 = 1;
  Else
    Update 诊疗项目别名 Set 名称 = 别名_In, 简码 = 别名拼音_In Where 诊疗项目id = Id_In And 性质 = 9 And 码类 = 1;
    If Sql%RowCount = 0 Then
      Insert Into 诊疗项目别名 (诊疗项目id, 名称, 性质, 简码, 码类) Values (Id_In, 别名_In, 9, 别名拼音_In, 1);
    End If;
  End If;

  If 别名_In Is Null Or 别名五笔_In Is Null Then
    Delete 诊疗项目别名 Where 诊疗项目id = Id_In And 性质 = 9 And 码类 = 2;
  Else
    Update 诊疗项目别名 Set 名称 = 别名_In, 简码 = 别名五笔_In Where 诊疗项目id = Id_In And 性质 = 9 And 码类 = 2;
    If Sql%RowCount = 0 Then
      Insert Into 诊疗项目别名 (诊疗项目id, 名称, 性质, 简码, 码类) Values (Id_In, 别名_In, 9, 别名五笔_In, 2);
    End If;
  End If;

  --删除已有的方案内容 
  Delete From 诊疗项目组合 Where 诊疗组合id = Id_In;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_成套方案项目_Update;
/

--93696:马政,2016-03-03,无库存冲销数据修正处理
Create Or Replace Procedure Zl_药品收发记录_调价修正(收发id_In In 药品收发记录.Id%Type) Is
  v_单据         药品收发记录.单据%Type;
  v_入出类别id   药品收发记录.入出类别id%Type;
  v_售价精度     Number;
  v_金额精度     Number;
  v_收发id       药品收发记录.Id%Type;
  v_原价         药品收发记录.零售价%Type;
  v_现价         药品收发记录.零售价%Type;
  v_是否变价     收费项目目录.是否变价%Type;
  v_价格id       收费价目.Id%Type;
  v_库房id       药品收发记录.库房id%Type;
  v_药品id       药品收发记录.药品id%Type;
  v_批次         药品收发记录.批次%Type;
  v_实际数量     药品收发记录.实际数量%Type;
  v_修正金额     药品收发记录.零售金额%Type;
  v_入出系数     药品收发记录.入出系数%Type;
  v_执行修正     Number;
  v_审核日期     药品收发记录.审核日期%Type;
  v_零售金额     药品收发记录.零售金额%Type;
  v_差价         药品收发记录.差价%Type;
  v_No           药品收发记录.No%Type;
  n_平均成本价   药品库存.平均成本价%Type;
  n_费用单价精度 Number;
  d_填制日期     药品收发记录.填制日期%Type;
  d_日期         药品收发记录.填制日期%Type;
  n_记录状态     药品收发记录.记录状态%Type;
  n_当前数量     药品库存.实际数量%Type;

  v_Billno 药品收发记录.No%Type;
Begin
  --修正规则
  --售价：
  --定价：以收费价目现价与冲销价格判断，如果不等产生修正
  --时价：时价无库存不修正有库存则判断当前价格与冲销价格是否不同，不同则处理否则不处理

  --成本价：
  --有调价则修正，无调价检查库存与冲销价格是否不同，不同则修正，否则不修正  

  --1、售价调剂处理
  --提取单据信息，原价，现价及药价属性
  Select a.单据, a.记录状态, a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, Nvl(a.实际数量, 0) * Nvl(a.付数, 1) As 实际数量, a.入出系数,
         Nvl(a.零售价, 0) 原价, b.现价, Nvl(c.是否变价, 0) 是否变价, b.Id As 价格id
  Into v_单据, n_记录状态, v_库房id, v_药品id, v_批次, v_实际数量, v_入出系数, v_原价, v_现价, v_是否变价, v_价格id
  From 药品收发记录 A, 收费价目 B, 收费项目目录 C
  Where a.药品id = b.收费细目id And a.药品id = c.Id And
        (Sysdate Between b.执行日期 And b.终止日期 Or Sysdate >= b.执行日期 And b.终止日期 Is Null) And a.Id = 收发id_In;

  --获取金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(157), '5')) Into n_费用单价精度 From Dual;
  If v_单据 = 8 Or v_单据 = 9 Or v_单据 = 10 Then
    --发药应该取费用精度，其他业务应该取药品卫材精度中精度
    Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into v_金额精度 From Dual;
  Else
    Select Nvl(精度, 2) Into v_金额精度 From 药品卫材精度 Where 性质 = 0 And 类别 = 1 And 内容 = 4 And 单位 = 5;
  End If;
  --定价直接取收费价目中现价
  v_执行修正 := 0;
  If v_是否变价 = 0 Then
    v_执行修正 := 1;
  Else
    --时价药品的现售价，不能从收费价目中取，因为时价调价可能是按库房和批次来调整的
    v_现价 := 0;
  
    --从库存记录中取现价
    Begin
      Select Nvl(零售价, 0)
      Into v_现价
      From 药品库存
      Where 性质 = 1 And 库房id + 0 = v_库房id And 药品id = v_药品id And Nvl(批次, 0) = v_批次;
    Exception
      When Others Then
        v_现价 := 0;
    End;
    If v_现价 > 0 Then
      v_执行修正 := 1;
    End If;
  End If;

  If v_执行修正 = 1 Then
    --发药类单据售价精度为5，其他流通类单据为7
    If v_单据 = 8 Or v_单据 = 9 Or v_单据 = 10 Then
      v_售价精度 := n_费用单价精度;
    Else
      v_售价精度 := 7;
    End If;
  
    --比较原价和现价，不同则处理
    If v_原价 <> Round(v_现价, v_售价精度) Then
      Select 药品收发记录_Id.Nextval Into v_收发id From Dual;
      Select Nextno(147) Into v_Billno From Dual;
    
      Select 类别id Into v_入出类别id From 药品单据性质 Where 单据 = 13;
    
      v_修正金额 := Round(v_入出系数 * (Round(v_现价, v_售价精度) - v_原价) * v_实际数量, v_金额精度);
    
      --产生调价修正记录
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 零售金额, 差价, 摘要, 填制人,
         填制日期, 库房id, 入出系数, 价格id, 审核人, 审核日期, 费用id)
        Select v_收发id, 1, 13, v_Billno, 序号, v_入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, Abs(v_实际数量), 0, v_原价, 0,
               Round(v_现价, v_售价精度), 扣率, v_修正金额, v_修正金额, '自动修正调价变动', 审核人, 审核日期, 库房id, 1, v_价格id, 审核人, 审核日期, 收发id_In
        From 药品收发记录
        Where ID = 收发id_In;
    
      --更新药品库存
      Zl_药品库存_Update(v_收发id, 2, 0);
    
    End If;
  End If;

  --2、成本价调价，只有冲销业务才修正
  If Mod(n_记录状态, 3) = 2 Then
    Select 库房id, 药品id, Nvl(批次, 0) 批次, 入出系数 * Nvl(实际数量, 0) * Nvl(付数, 1) As 实际数量, 入出系数 * 零售金额, 入出系数 * 差价, 成本价
    Into v_库房id, v_药品id, v_批次, v_实际数量, v_零售金额, v_差价, v_原价
    From 药品收发记录
    Where ID = 收发id_In;
  
    --取原始单据的审核时间
    Select a.审核日期
    Into v_审核日期
    From 药品收发记录 A, 药品收发记录 B
    Where b.Id = 收发id_In And a.单据 = b.单据 And a.No = b.No And a.库房id = b.库房id And a.药品id + 0 = b.药品id And a.序号 = b.序号 And
          (a.记录状态 = 1 Or Mod(a.记录状态, 3) = 0);
  
    v_执行修正 := 0;
    Begin
      Select 1, 新成本价
      Into v_执行修正, v_现价
      From 成本价调价信息
      Where 库房id + 0 = v_库房id And 药品id + 0 = v_药品id And Nvl(批次, 0) = v_批次 And 执行日期 > v_审核日期 And Rownum = 1
      Order By 执行日期 Desc;
    
    Exception
      When Others Then
        v_执行修正 := 0;
        v_现价     := 0;
      
        --可能是无库存调价，那么不需要库房id和批次判断，只需要用药品id和批次
        Begin
          Select 1, 新成本价
          Into v_执行修正, v_现价
          From 成本价调价信息
          Where 药品id + 0 = v_药品id And 执行日期 > v_审核日期 And Rownum = 1
          Order By 执行日期 Desc;
        
        Exception
          When Others Then
            --可能出现冲销或者退库很久以前的数据,这个时候价格可能已经发生变化,所以需要修正
            Begin
              Select 平均成本价, Nvl(实际数量, 0) As 实际数量
              Into v_现价, n_当前数量
              From 药品库存
              Where 库房id = v_库房id And 药品id = v_药品id And Nvl(批次, 0) = v_批次 And 性质 = 1;
            
              --无库存不处理，有库存可能有两种情况，1.原始有库存，冲销抵消后还有数量，2、原始无数量，新库存数据来源于冲销单据
              --如果是1情况那么则通过库存表原价格与冲销价格比较即可
              --如果是2情况那么则需要判断当前库存数量与冲销数量*入出系数是否相等，如果相等则说明肯定是原始无库存然后冲销根据产生的
              --这个时候需要粗略判断，只能通过规格来，另加一下价格判断，如价格为负数
              If n_当前数量 = v_实际数量 Then
                --说明是第二种情况产生的库存数据，这个时候可能产生的数据很离谱，则需要简单判断
                --93696问题需要将此语句屏蔽掉，及无库存退库时不再处理离谱数据
                /*Select 成本价 Into v_现价 From 药品规格 Where 药品id = v_药品id;
                If Abs(Abs(v_现价) - Abs(v_原价)) > 1 Then
                  v_执行修正 := 1;
                End If;*/
                Null;
              Else
                --说明是第一种情况产生的数据，直接用当前库存与冲销单据价格比较即可
                If Round(v_现价, 2) <> Round(v_原价, 2) Then
                  v_执行修正 := 1;
                End If;
              End If;
            Exception
              When Others Then
                v_执行修正 := 0;
              
            End;
        End;
    End;
  
    If v_执行修正 = 1 Then
      v_修正金额 := (v_零售金额 - v_差价) - Round(Round(v_现价, 3) * v_实际数量, v_金额精度);
    
      If v_修正金额 <> 0 Then
        Select 药品收发记录_Id.Nextval Into v_收发id From Dual;
        Select b.Id, b.系数
        Into v_入出类别id, v_入出系数
        From 药品单据性质 A, 药品入出类别 B
        Where a.类别id = b.Id And a.单据 = 5 And Rownum < 2;
      
        v_No := Nextno(25, v_库房id);
      
        --产生库存差价调整单
        Insert Into 药品收发记录
          (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 供药单位id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 零售价, 成本价, 差价, 摘要, 填制人, 填制日期,
           审核人, 审核日期, 生产日期, 批准文号, 单量, 发药方式, 扣率, 灭菌效期, 费用id)
          Select v_收发id, 1, 5, v_No, 1, 库房id, v_入出类别id, 供药单位id, v_入出系数, 药品id, 批次, 产地, 批号, 效期, v_实际数量, v_零售金额, v_差价,
                 v_修正金额, '自动修正调价变动', 审核人, 审核日期, 审核人, 审核日期, 生产日期, 批准文号, v_现价, 1, 成本价, 灭菌效期, 收发id_In
          From 药品收发记录
          Where ID = 收发id_In;
      
        --更新库存
        Zl_药品库存_Update(v_收发id, 2, 0);
      
      End If;
    End If;
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_调价修正;
/

--94654:冉俊明,2016-03-31,医嘱作废后无法退费。
--93623:刘兴洪,2016-02-26,更改医嘱发送的计费状态
Create Or Replace Procedure Zl_门诊收费记录_销帐
(
  No_In         门诊费用记录.No%Type,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  序号_In       Varchar2 := Null,
  退费时间_In   门诊费用记录.登记时间%Type := Null,
  退费摘要_In   门诊费用记录.摘要%Type := Null,
  结帐id_In     病人预交记录.结帐id%Type := Null,
  回收票据_In   Number := 0
) As
  --功能：删除一张门诊收费单据
  --参数：
  --        序号_IN           =要退费的项目序号,格式为"1,3,5,6...",缺省NULL表示退"未退的"所有行。
  --        回收票据_In       =0:全退或最后一次全退时,收回票据。
  --                           1:部份退费不处理票据,通过重打调用单独处理。
  --该游标为要退费单据的所有原始记录

  --医保全退但某种结算退现金从而产生了新的误差时,排开此处的误差处理,执行完本过程后,界面程序中单独处理新误差
  Cursor c_Bill Is
    Select a.Id, a.No, a.附加标志, a.收费细目id, a.序号, a.价格父号, a.执行状态, a.收费类别, a.付数, a.数次, a.医嘱序号, j.诊疗类别, m.跟踪在用,
           Nvl(a.附加标志, 0) As 误差, Nvl(j.医嘱状态, 0) As 医嘱状态
    From 门诊费用记录 A, 病人医嘱记录 J, 材料特性 M
    Where a.医嘱序号 = j.Id(+) And a.No = No_In And a.记录性质 = 1 And a.记录状态 In (1, 3) And a.收费细目id + 0 = m.材料id(+)
    Order By a.收费细目id, a.序号;

  --:不管原始单据误差,都应该根据当前退费产生的误差项进行处理
  -- Decode(Sign(误差_In), 0, 999, 9)

  --该光标用于处理人员缴款余额中退的不同结算方式的金额

  n_结帐id 门诊费用记录.结帐id%Type;
  n_打印id 票据打印内容.Id%Type;

  --部分退费计算变量
  n_剩余数量 Number;
  n_剩余应收 Number;
  n_剩余实收 Number;
  n_剩余统筹 Number;
  n_准退数量 Number;
  n_退费次数 Number;

  n_应收金额 Number;
  n_实收金额 Number;
  n_统筹金额 Number;
  n_总金额   Number;
  n_正常退费 Number; --是否第一次退费且全部退费,在每行退费过程中判断得到。
  n_组id     财务缴款分组.Id%Type;

  l_使用id   t_Numlist := t_Numlist();
  l_序号     t_Numlist := t_Numlist();
  l_执行状态 t_Numlist := t_Numlist();

  n_Dec   Number;
  d_Date  Date;
  n_Count Number;

  Err_Item Exception;
  v_Err_Msg      Varchar2(255);
  n_启用模式     Number(3);
  v_Para         Varchar2(1000);
  n_医属执行计价 Number;

Begin
  n_组id := Zl_Get组id(操作员姓名_In);
  --是否已经全部完全执行(只是该单据整张单据的检查)
  Select Nvl(Count(*), 0)
  Into n_Count
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1;
  If n_Count = 0 Then
    v_Err_Msg := '该单据中的项目已经全部完全执行！';
    Raise Err_Item;
  End If;

  --未完全执行的项目是否有剩余数量(只是整张单据的检查)
  --执行状态在原始记录上判断
  Select Nvl(Count(*), 0)
  Into n_Count
  From (Select 序号, Sum(数量) As 剩余数量
         From (Select 记录状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量, 结帐id
                From 门诊费用记录
                Where NO = No_In And Mod(记录性质, 10) = 1 And Nvl(附加标志, 0) <> 9 And
                      Nvl(价格父号, 序号) In
                      (Select Nvl(价格父号, 序号)
                       From 门诊费用记录
                       Where NO = No_In And Mod(记录性质, 10) = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1)
                Group By 记录状态, Nvl(价格父号, 序号), 结帐id)
         Group By 序号
         Having Sum(数量) <> 0);
  If n_Count = 0 Then
    v_Err_Msg := '该单据中未完全执行部分项目剩余数量为零,没有可以退费的费用！';
    Raise Err_Item;
  End If;

  --确定是否在医嘱执行计价中存在数据,如果存在数据,则根据医嘱执行计价进行退费,否则按旧方式进行处理
  Select Count(1)
  Into n_医属执行计价
  From 门诊费用记录 A, 医嘱执行计价 B
  Where a.医嘱序号 = b.医嘱id And Mod(a.记录性质, 10) = 1 And a.No = No_In And a.记录状态 In (1, 3) And Rownum = 1;

  ---------------------------------------------------------------------------------
  --公用变量
  If 退费时间_In Is Not Null Then
    d_Date := 退费时间_In;
  Else
    Select Sysdate Into d_Date From Dual;
  End If;

  If 结帐id_In Is Null Then
    Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  Else
    n_结帐id := 结帐id_In;
  End If;

  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into n_Dec From Dual;

  --循环处理每行费用(收入项目行)
  n_总金额 := 0;
  For r_Bill In c_Bill Loop
    If Instr(',' || 序号_In || ',', ',' || Nvl(r_Bill.价格父号, r_Bill.序号) || ',') > 0 Or 序号_In Is Null Then
      If Nvl(r_Bill.执行状态, 0) <> 1 Then
        --求剩余数量,剩余应收,剩余实收
        Select Sum(Nvl(付数, 1) * 数次), Sum(应收金额), Sum(实收金额), Sum(统筹金额)
        Into n_剩余数量, n_剩余应收, n_剩余实收, n_剩余统筹
        From 门诊费用记录
        Where NO = No_In And Mod(记录性质, 10) = 1 And 序号 = r_Bill.序号;
      
        If n_剩余数量 = 0 Then
          If 序号_In Is Not Null Then
            v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经全部退费！';
            Raise Err_Item;
          End If;
        Else
          --准退数量(非药品项目为剩余数量,原始数量)
          If Instr(',4,5,6,7,', r_Bill.收费类别) = 0 Or (r_Bill.收费类别 = '4' And Nvl(r_Bill.跟踪在用, 0) = 0) Then
            --@@@
            --非药品部分(以具体医嘱执行为准进行检查)
            --: 1.存在医嘱发送的,则以医嘱执行为准(但不能包含:检查;检验;手术;麻醉及输血)
            --: 2.不存在医嘱的,则以剩余数量为准
            --: 3.医嘱作废了的,则以剩余数量为准(病人医嘱记录.医嘱状态=4表示作废医嘱，会删除"病人医嘱发送",门诊药嘱先作废后退药)
            n_Count := 0;
            If Instr(',C,D,F,G,K,', ',' || r_Bill.诊疗类别 || ',') = 0 And r_Bill.诊疗类别 Is Not Null And r_Bill.医嘱状态 <> 4 Then
              If n_医属执行计价 = 1 Then
                Select Decode(Sign(Sum(数量)), -1, 0, Sum(数量)), Count(*)
                Into n_准退数量, n_Count
                From (Select Max(Decode(a.记录状态, 2, 0, a.Id)) As ID, Max(a.医嘱序号) As 医嘱id, Max(a.收费细目id) As 收费细目id,
                              Sum(Nvl(a.付数, 1) * Nvl(a.数次, 1)) As 数量,
                              Sum(Decode(a.记录状态, 2, 0, Nvl(a.付数, 1) * Nvl(a.数次, 1))) As 原始数量
                       From 门诊费用记录 A, 病人医嘱记录 M
                       Where a.医嘱序号 = m.Id And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                             Instr('5,6,7', a.收费类别) = 0 And a.No = No_In And a.序号 = r_Bill.序号 And Mod(a.记录性质, 10) = 1 And
                             a.记录状态 In (1, 2, 3) And a.价格父号 Is Null
                       Group By a.序号
                       Union All
                       Select a.Id, a.医嘱序号 As 医嘱id, a.收费细目id, -1 * b.数量 As 已执行, 0 原始数量
                       From 门诊费用记录 A, 医嘱执行计价 B, 病人医嘱记录 M
                       Where a.医嘱序号 = b.医嘱id And a.收费细目id = b.收费细目id + 0 And a.医嘱序号 = m.Id And
                             Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Instr('5,6,7', a.收费类别) = 0 And
                             (Exists
                              (Select 1
                               From 病人医嘱执行
                               Where b.医嘱id = 医嘱id And b.发送号 = 发送号 And b.要求时间 = 要求时间 And Nvl(执行结果, 0) = 1) Or Exists
                              (Select 1
                               From 病人医嘱发送
                               Where b.医嘱id = 医嘱id And b.发送号 = 发送号 And Nvl(执行状态, 0) = 1)) And Not Exists
                        (Select 1
                              From 病人医嘱附费
                              Where a.医嘱序号 = 医嘱id And a.No = NO And Mod(a.记录性质, 10) = 记录性质) And a.No = No_In And
                             a.序号 = r_Bill.序号 And Mod(a.记录性质, 10) = 1 And a.记录状态 In (1, 3) And a.价格父号 Is Null) Q1
                Where Not Exists (Select 1
                       From 药品收发记录
                       Where 费用id = Q1.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0) Having
                 Max(ID) <> 0;
              Else
              
                Select Nvl(Sum(数量), 0), Count(*)
                Into n_准退数量, n_Count
                From (Select a.医嘱id, a.收费细目id, Nvl(a.数量, 1) * Nvl(b.发送数次, 1) As 数量
                       From 病人医嘱计价 A, 病人医嘱发送 B, 门诊费用记录 J, 病人医嘱记录 M
                       Where a.医嘱id = b.医嘱id And a.医嘱id = m.Id And Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And
                             a.收费细目id = j.收费细目id And j.No = No_In And Mod(j.记录性质, 10) = 1 And j.序号 = r_Bill.序号 And
                             j.记录状态 In (1, 3) And j.价格父号 Is Null And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                             Exists
                        (Select 1
                              From 病人医嘱计价 A
                              Where a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And Nvl(a.收费方式, 0) = 0) And Not Exists
                        (Select 1
                              From 药品收发记录
                              Where 费用id = j.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0)
                       Union All
                       Select a.医嘱id, a.收费细目id, -1 * Nvl(a.数量, 1) * Nvl(c.本次数次, 1) As 数量
                       From 病人医嘱计价 A, 病人医嘱发送 B, 病人医嘱执行 C, 门诊费用记录 J, 病人医嘱记录 M
                       Where a.医嘱id = b.医嘱id And b.医嘱id = c.医嘱id And b.发送号 = c.发送号 And a.医嘱id = m.Id And
                             Nvl(c.执行结果, 1) = 1 And Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And
                             j.No = No_In And Mod(j.记录性质, 10) = 1 And Nvl(a.收费方式, 0) = 0 And j.序号 = r_Bill.序号 And
                             j.记录状态 In (1, 3) And j.价格父号 Is Null And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                             Not Exists
                        (Select 1
                              From 药品收发记录
                              Where 费用id = j.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0) And Not Exists
                        (Select 1 From 材料特性 Where 材料id = j.收费细目id And Nvl(跟踪在用, 0) = 1)
                       Union All
                       Select a.医嘱序号 As 医嘱id, a.收费细目id, Nvl(a.付数, 1) * a.数次 As 数量
                       From 门诊费用记录 A, 病人医嘱记录 M
                       Where a.医嘱序号 = m.Id And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And a.No = No_In And
                             Mod(a.记录性质, 10) = 1 And a.序号 = r_Bill.序号 And a.记录状态 = 2 And a.价格父号 Is Null And Not Exists
                        (Select 1 From 药品收发记录 Where NO = No_In And 单据 In (8, 24) And 药品id = a.收费细目id));
              End If;
            End If;
            If Nvl(n_Count, 0) <> 0 And n_准退数量 = 0 Then
              v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已执行,不允许退费！';
              Raise Err_Item;
            End If;
          
            If Nvl(n_Count, 0) = 0 Then
              n_准退数量 := n_剩余数量;
            End If;
          
          Else
            Select Nvl(Sum(Nvl(付数, 1) * 实际数量), 0), Count(*)
            Into n_准退数量, n_Count
            From 药品收发记录
            Where NO = No_In And 单据 In (8, 24) And Mod(记录状态, 3) = 1 --@@@
                  And 审核人 Is Null And 费用id = r_Bill.Id;
          
            --有剩余数量无准退数量的有两种情况：
            --1.不跟踪在用的卫材无对应的收发记录,这时使用剩余数量
            --2.并发操作,此时已发药或发料
            If n_准退数量 = 0 Then
              If r_Bill.收费类别 = '4' Then
                If n_Count > 0 Then
                  v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发料,须退料后再退费！';
                  Raise Err_Item;
                Else
                  n_准退数量 := n_剩余数量;
                End If;
              Else
                v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发药,须退药后再退费！';
                Raise Err_Item;
              End If;
            End If;
          End If;
        
          If n_准退数量 > n_剩余数量 Then
            v_Err_Msg := '单据[' || No_In || '] 中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用的退费数量(' || n_准退数量 ||
                         ')大于了剩余数量(' || n_剩余数量 || ')，不允许退费！';
            Raise Err_Item;
          End If;
          If n_准退数量 < 0 Then
            v_Err_Msg := '单据[' || No_In || '] 中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用的退费数量(' || n_准退数量 ||
                         ')小于了零，不允许退费！';
            Raise Err_Item;
          End If;
        
          --是否部分退费
          If r_Bill.执行状态 = 2 Or n_准退数量 <> Nvl(r_Bill.付数, 1) * r_Bill.数次 Then
            n_正常退费 := 0;
          End If;
        
          --该笔项目第几次退费
          Select Nvl(Max(Abs(执行状态)), 0) + 1
          Into n_退费次数
          From 门诊费用记录
          Where NO = No_In And Mod(记录性质, 10) = 1 And 记录状态 = 2 And Nvl(执行状态, 0) < 0 And 序号 = r_Bill.序号;
        
          --金额=剩余金额*(准退数/剩余数)
          n_应收金额 := Round(n_剩余应收 * (n_准退数量 / n_剩余数量), n_Dec);
          n_实收金额 := Round(n_剩余实收 * (n_准退数量 / n_剩余数量), n_Dec);
          n_统筹金额 := Round(n_剩余统筹 * (n_准退数量 / n_剩余数量), n_Dec);
          n_总金额   := n_总金额 + n_实收金额;
        
          --插入退费记录
          Insert Into 门诊费用记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别,
             收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人,
             执行状态, 费用状态, 执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 结论,
             缴款组id)
            Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别,
                   病人科室id, 收费类别, 收费细目id, 计算单位, Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, 付数, 1), 发药窗口,
                   Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, -1 * 数次, -1 * n_准退数量), 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价,
                   -1 * n_应收金额, -1 * n_实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, -1 * n_退费次数, 1, 执行时间, 操作员编号_In, 操作员姓名_In,
                   发生时间, d_Date, n_结帐id, -1 * n_实收金额, 保险项目否, 保险大类id, -1 * n_统筹金额, Nvl(退费摘要_In, 摘要),
                   Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, 结论, n_组id
            From 门诊费用记录
            Where ID = r_Bill.Id;
        
          --标记原费用记录
          l_序号.Extend;
          l_序号(l_序号.Count) := r_Bill.序号;
          l_执行状态.Extend;
          l_执行状态(l_执行状态.Count) := Case
                                    When Sign(n_准退数量 - n_剩余数量) = 0 Then
                                     0
                                    Else
                                     1
                                  End;
        
          --          Update 门诊费用记录 Set 记录状态 = 3 Where ID = r_Bill.Id;
        
        End If;
      Else
        If 序号_In Is Not Null Then
          v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经完全执行,不能退费！';
          Raise Err_Item;
        End If;
        --情况:没限定行号,原始单据中包括已经完全执行的
        n_正常退费 := 0;
      End If;
    Else
      n_正常退费 := 0; --未指定该笔,属于部分退费
    End If;
  End Loop;
  --标记原费用记录
  Forall I In 1 .. l_序号.Count
    Update 门诊费用记录
    Set 记录状态 = 3, 执行状态 = l_执行状态(I)
    Where Mod(记录性质, 10) = 1 And NO = No_In And 序号 = l_序号(I) And 记录状态 In (1, 3);

  l_序号.Delete;
  For c_结帐 In (Select Distinct b.结帐id
               From 门诊费用记录 A, 病人预交记录 B
               Where a.结帐id = b.结帐id And a.No = No_In And Mod(a.记录性质, 10) = 1 And a.记录状态 In (1, 3) And
                     Nvl(b.记录状态, 0) = 1) Loop
    l_序号.Extend;
    l_序号(l_序号.Count) := c_结帐.结帐id;
  End Loop;

  Forall I In 1 .. l_序号.Count
    Update 病人预交记录 Set 记录状态 = 3 Where 结帐id = l_序号(I) And Mod(记录性质, 10) <> 1;

  ---------------------------------------------------------------------------------
  --退费票据回收(仅全退时才回退,部分退是在重打过程中回收)
  If 回收票据_In = 1 Then
  
    --启用标志||NO;执行科室(条数);收据费目(首页汇总,条数);收费细目(条数)
    v_Para     := Nvl(zl_GetSysParameter('票据分配规则', 1121), '0||0;0;0,0;0');
    n_启用模式 := Zl_To_Number(Substr(v_Para, 1, 1));
    If n_启用模式 <> 0 Then
      --收回票据
      Select 使用id Bulk Collect
      Into l_使用id
      From (Select Distinct b.使用id From 票据打印明细 B Where b.No = No_In And Nvl(b.票种, 0) = 1);
    
      n_启用模式 := l_使用id.Count;
      If l_使用id.Count <> 0 Then
        --插入回收记录
        Forall I In 1 .. l_使用id.Count
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 操作员姓名_In, d_Date
            From 票据使用明细 A
            Where ID = l_使用id(I) And 性质 = 1 And Not Exists
             (Select 1 From 票据使用明细 Where 号码 = a.号码 And 票种 = a.票种 And Nvl(性质, 0) <> 1);
      
        Forall I In 1 .. l_使用id.Count
          Update 票据打印明细 Set 是否回收 = 1 Where 使用id = l_使用id(I) And Nvl(是否回收, 0) = 0;
      
      End If;
    End If;
    If n_启用模式 = 0 Then
      --获取单据最后一次的打印ID(可能是多张单据收费打印)
      Begin
        Select ID
        Into n_打印id
        From (Select b.Id
               From 票据使用明细 A, 票据打印内容 B
               Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 1 And b.No = No_In
               Order By a.使用时间 Desc)
        Where Rownum < 2;
      Exception
        When Others Then
          Null;
      End;
      --可能以前没有打印,无收回
      If n_打印id Is Not Null Then
        --a.多张单据循环调用时只能收回一次
        Select Count(*) Into n_Count From 票据使用明细 Where 票种 = 1 And 性质 = 2 And 打印id = n_打印id;
        If n_Count = 0 Then
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
            From 票据使用明细
            Where 打印id = n_打印id And 票种 = 1 And 性质 = 1;
        Else
          --b.部分退费多次收回时,最后一次全退收回要排开已收回的
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
            From 票据使用明细 A
            Where 打印id = n_打印id And 票种 = 1 And 性质 = 1 And Not Exists
             (Select 1 From 票据使用明细 B Where a.号码 = b.号码 And 打印id = n_打印id And 票种 = 1 And 性质 = 2);
        End If;
      End If;
    End If;
  End If;

  ---------------------------------------------------------------------------------
  --药品卫材相关内容
  For r_Expenses In (Select ID
                     From 门诊费用记录
                     Where NO = No_In And Mod(记录性质, 10) = 1 And 记录状态 In (1, 3) And 收费类别 In ('4', '5', '6', '7') And
                           (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null)) Loop
    Zl_药品收发记录_销售退费(r_Expenses.Id);
  End Loop;

  --医嘱处理
  --场合_In    Integer:=0, --0:门诊;1-住院
  --性质_In    Integer:=1, --1-收费单;2-记帐单
  --操作_In    Integer:=0, --0:删除划价单;1-收费或记帐;2-退费或销帐
  --No_In      门诊费用记录.No%Type,
  --医嘱ids_In Varchar2 := Null
  Zl_医嘱发送_计费状态_Update(0, 1, 2, No_In);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费记录_销帐;
/

--92736:刘尔旋,2016-02-25,退费申请模式服务窗处理
Create Or Replace Procedure Zl_Third_Charge_Delcheck
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is

  -------------------------------------------------------------------------------------------------- 
  --功能:三方退费检查 
  --入参:Xml_In: 
  --<IN>
  --    <BRID>病人ID</BRID>
  --    <JE></JE> //退款总金额
  --    <JSKLB></JSKLB>     //结算卡类别
  --    <TFZY>退费摘要</TFZY>
  --    <JCFP>1</JCFP>      //检查发票,0-不检查;1-检查;为1时，打印了发票的单据不能退费
  --    <FYLIST>
  --        <FY>
  --           <DJH>退款单据号</DJH>
  --           <XH>退款序号(格式:1,2,3..为空代表退剩余数量)</DJH>
  --        <FY>
  --    </FYLIST>
  --    <TKLIST>
  --        <TK>
  --            <TKKLB>退款卡类别</TKKLB>
  --            <TKKH>退款卡号</TKKH>
  --            <TKFS>退款方式</TKFS> //退款方式:现金;支票,如果是三方卡,可以传空
  --            <TKJE>支付金额</TKJE>
  --            <JYLSH>交易流水号</JYLSH>
  --            <TKZY>摘要</TKZY>
  --            <TYJK>退回预交款</TYJK> //允冲预交时,只填JSJE节点:1-冲预交
  --            <SFXFK>是否消费卡</SFXFK>   //(1-是消费卡),消费卡时,传入结算卡类别,结算卡号,结算金额等接点
  --            <EXPENDLIST>  //扩展交易信息
  --                <EXPEND>
  --                    <JYMC>交易名称</JYMC>
  --                    <JYLR>交易内容</JYLR>
  --                </EXPEND>
  --            </EXPENDLIST>
  --        </TK>
  --    </TKLIST>
  --</IN>

  --出参:Xml_Out 
  --  <OUT> 
  --    DD如无下列错误结点则说明通过检查
  --    <ERROR> 
  --      <MSG>错误信息</MSG> 
  --    </ERROR> 
  --  </OUT> 
  -------------------------------------------------------------------------------------------------- 
  n_退款总额 门诊费用记录.实收金额%Type;

  n_病人id     门诊费用记录.病人id%Type;
  n_单据病人id 门诊费用记录.病人id%Type;
  v_操作员编码 门诊费用记录.操作员编号%Type;
  v_操作员姓名 门诊费用记录.操作员姓名%Type;
  n_结帐id     门诊费用记录.结帐id%Type;
  n_原结算序号 病人预交记录.结算序号%Type;
  v_结算卡类别 Varchar2(100);
  v_结算方式   医疗卡类别.结算方式%Type;
  n_卡类别id   医疗卡类别.Id%Type;

  v_摘要     门诊费用记录.摘要%Type;
  n_Count    Number(18);
  n_Temp     Number(18);
  n_检查发票 Number(3);
  n_是否打印 Number(3);
  n_退费模式 Number(3);

  v_Temp    Varchar2(32767); --临时XML 
  x_Templet Xmltype; --模板XML 

  v_Err_Msg Varchar2(200);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  --0.获取入参中的病人ID等信息
  Select To_Number(Extractvalue(Value(A), 'IN/BRID')), To_Number(Extractvalue(Value(A), 'IN/JE')),
         Extractvalue(Value(A), 'IN/TFZY'), To_Number(Extractvalue(Value(A), 'IN/JCFP')),
         Extractvalue(Value(A), 'IN/JSKLB')
  Into n_病人id, n_退款总额, v_摘要, n_检查发票, v_结算卡类别
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  --0.相关检查
  If Nvl(n_病人id, 0) = 0 Then
    v_Err_Msg := '不能有效识别病人身份,不允许退费操作!';
    Raise Err_Item;
  End If;

  n_退费模式 := zl_GetSysParameter('门诊退费须先申请');
  If Nvl(n_退费模式, 0) = 1 Then
    v_Err_Msg := '当前为退费申请模式,不允许服务窗退费!';
    Raise Err_Item;
  End If;

  If v_结算卡类别 Is Not Null Then
    Begin
      n_卡类别id := To_Number(v_结算卡类别);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
    If n_卡类别id = 0 Then
      Begin
        Select ID Into n_卡类别id From 医疗卡类别 Where 名称 = v_结算卡类别;
      Exception
        When Others Then
          v_Err_Msg := '无法确认传入的结算卡！';
          Raise Err_Item;
      End;
    End If;
  Else
    n_卡类别id := 0;
  End If;
  
  If Nvl(n_卡类别id, 0) <> 0 Then
    Select 结算方式 Into v_结算方式 From 医疗卡类别 Where ID = n_卡类别id;
  End If;

  --人员id,人员编号,人员姓名 
  v_Temp := Zl_Identity(1);
  If Nvl(v_Temp, '0') = '0' Or Nvl(v_Temp, '_') = '_' Then
    v_Err_Msg := '系统不能认别有效的操作员,不允许退费!';
    Raise Err_Item;
  End If;
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员编码 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员姓名 := v_Temp;
  v_Err_Msg    := Null;

  --1.退费检查

  n_Count      := 0;
  n_原结算序号 := 0;
  For c_费用 In (Select Extractvalue(b.Column_Value, '/FY/DJH') As 单据号, Extractvalue(b.Column_Value, '/FY/XH') As 退款序号
               From Table(Xmlsequence(Extract(Xml_In, '/IN/FYLIST/FY'))) B) Loop
  
    If c_费用.单据号 Is Null Then
      v_Err_Msg := '未确定指定退费的单据号,不能退费!';
      Raise Err_Item;
    End If;
    Begin
      Select a.结算序号, a.结帐id, a.病人id
      Into n_Temp, n_结帐id, n_单据病人id
      From 病人预交记录 A, 门诊费用记录 B
      Where a.结帐id = b.结帐id And b.No = c_费用.单据号 And b.记录性质 = 1 And Nvl(b.费用状态, 0) = 0 And b.记录状态 In (1, 3) And
            Rownum < 2;
    Exception
      When Others Then
        n_Temp := Null;
    End;
  
    If n_Temp Is Null Then
      v_Err_Msg := '指定的单据号:' || c_费用.单据号 || '未找到,不能退费!';
      Raise Err_Item;
    End If;
  
    If Nvl(n_单据病人id, 0) = 0 Then
      Begin
        Select 病人id
        Into n_单据病人id
        From 门诊费用记录
        Where NO = c_费用.单据号 And 记录性质 = 1 And Nvl(费用状态, 0) = 0 And 记录状态 In (1, 3) And Rownum < 2;
      Exception
        When Others Then
          n_单据病人id := 0;
      End;
    End If;
  
    If Nvl(n_病人id, 0) <> Nvl(n_单据病人id, 0) Then
      v_Err_Msg := '本次退费的收费单:' || c_费用.单据号 || '不是当前病人的收费单,不能退费!';
      Raise Err_Item;
    End If;
  
    If n_原结算序号 <> 0 And n_原结算序号 <> n_Temp Then
      v_Err_Msg := '本次退费的单据号不是一次收费结算,不能退费!';
      Raise Err_Item;
    End If;
    n_原结算序号 := n_Temp;
  
    Select Count(*) Into n_Temp From 费用补充记录 Where 收费结帐id = n_结帐id;
    If Nvl(n_Temp, 0) <> 0 Then
      v_Err_Msg := '本次退费的单据号已经进行了保险补充结算,不能退费!';
      Raise Err_Item;
    End If;
  
    If v_结算卡类别 Is Not Null Then
      Select Count(*) Into n_Temp From 病人预交记录 Where 结帐id = n_结帐id And 结算方式 = v_结算方式;
      If Nvl(n_Temp, 0) = 0 Then
        v_Err_Msg := '本次退费的单据不是' || v_结算方式 || '结算的,不能退费!';
        Raise Err_Item;
      End If;
    End If;
  
    If Nvl(n_检查发票, 0) = 1 Then
      Select Max(Decode(a.实际票号, Null, 0, 1))
      Into n_是否打印
      From 门诊费用记录 A
      Where NO = c_费用.单据号 And 记录性质 = 1;
      If Nvl(n_是否打印, 0) = 1 Then
        v_Err_Msg := '本次退费的单据号已开发票,不能退费!';
        Raise Err_Item;
      End If;
    End If;
  
    n_Count := n_Count + 1;
  End Loop;

  If n_Count = 0 Then
    v_Err_Msg := '未确定本次需要退费的单据,不能退费!';
    Raise Err_Item;
  End If;

  --2.支付方式检查
  n_Count := 0;
  For c_结算方式 In (Select Extractvalue(b.Column_Value, '/TK/TKKLB') As 卡类别, Extractvalue(b.Column_Value, '/TK/TKKH') As 卡号,
                        Extractvalue(b.Column_Value, '/TK/TKFS') As 结算方式,
                        -1 * To_Number(Extractvalue(b.Column_Value, '/TK/TKJE')) As 退款金额,
                        Extractvalue(b.Column_Value, '/TK/JYLSH') As 交易流水号,
                        Extractvalue(b.Column_Value, '/TK/JYSM') As 交易说明, Extractvalue(b.Column_Value, '/TK/TKZY') As 摘要,
                        Extractvalue(b.Column_Value, '/TK/TYJK') As 是否退预交,
                        Extractvalue(b.Column_Value, '/TK/SFXFK') As 是否消费卡,
                        Extract(b.Column_Value, '/TK/EXPENDLIST') As Expend
                 From Table(Xmlsequence(Extract(Xml_In, '/IN/TKLIST/TK'))) B) Loop
  
    --1.退回三方卡
    If c_结算方式.卡类别 Is Not Null And Nvl(c_结算方式.是否消费卡, 0) = 0 Then
      --1.三方卡结算
      Null;
    Elsif c_结算方式.卡类别 Is Not Null And Nvl(c_结算方式.是否消费卡, 0) = 1 Then
      --2.消费卡结算
      Null;
    Elsif Nvl(c_结算方式.是否退预交, 0) = 1 Then
      --3.退预交款
      Null;
    Else
      --4.普通结算
      If c_结算方式.结算方式 Is Null Then
        v_Err_Msg := '未指定支付方式,不能退费!';
        Raise Err_Item;
      End If;
    End If;
    n_Count := n_Count + 1;
  End Loop;

  If n_Count = 0 Then
    v_Err_Msg := '不能有效确认当前的支付方式,不能退费!';
    Raise Err_Item;
  End If;

  Xml_Out := x_Templet;

Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Charge_Delcheck;
/

--94674:刘兴洪,2016-03-31,普通治疗类在收费后没有更新计费状态
--93623:刘兴洪,2016-02-26,调整医嘱发送的计费状态
CREATE OR REPLACE Procedure Zl_医嘱发送_计费状态_Update
(
  场合_In    Integer := 0, --0:门诊;1-住院
  性质_In    Integer := 1, --1-收费单;2-记帐单
  操作_In    Integer := 0, --0:删除划价单;1-收费或记帐;2-退费或销帐
  No_In      门诊费用记录.No%Type,
  医嘱ids_In Varchar2 := Null
) As
  Err_Item Exception;
  v_Err_Msg Varchar2(255);

  l_医嘱id   t_Numlist := t_Numlist();
  l_医嘱id1  t_Numlist := t_Numlist();
  l_计费状态 t_Numlist := t_Numlist();
  n_Count    Number(18);
  v_医嘱ids  Varchar2(4000);

Begin
  v_医嘱ids := 医嘱ids_In;

  If 医嘱ids_In Is Null Then
    If 场合_In = 0 Then
      Select ID Bulk Collect
      Into l_医嘱id1
      From (Select Distinct 医嘱序号 As ID
             From 门诊费用记录
             Where NO = No_In And 记录性质 = 性质_In And 记录状态 In (0, 1, 3) And 医嘱序号 Is Not Null);
    Else
      Select ID Bulk Collect
      Into l_医嘱id1
      From (Select Distinct 医嘱序号 As ID
             From 住院费用记录
             Where NO = No_In And 记录性质 = 性质_In And 记录状态 In (0, 1, 3) And 医嘱序号 Is Not Null);
    End If;
  Else
    Select ID Bulk Collect
    Into l_医嘱id1
    From (Select Distinct Column_Value As ID From Table(f_Str2list(医嘱ids_In)) B);
  End If;
  If l_医嘱id1.Count = 0 Then
    Return;
  End If;
  If v_医嘱ids Is Null And Nvl(操作_In, 0) = 1 Then
    For I In 1 .. l_医嘱id1.Count Loop
      v_医嘱ids := Nvl(v_医嘱ids, '') || ',' || l_医嘱id1(I);
    End Loop;
    If Not v_医嘱ids Is Null Then
      v_医嘱ids := ',' || v_医嘱ids || ',';
    End If;
  Elsif Not v_医嘱ids Is Null Then
    v_医嘱ids := ',' || v_医嘱ids || ',';
  End If;

  For c_医嘱 In (With c_医嘱信息 As
                  (Select Column_Value As 医嘱id From Table(l_医嘱id1))
                 Select ID, 相关id, 诊疗类别
                 From 病人医嘱记录 A
                 Where a.Id In (Select 医嘱id
                                From c_医嘱信息
                                Union All
                                Select Distinct 相关id
                                From 病人医嘱记录 A1, c_医嘱信息 B1
                                Where A1.Id = B1.医嘱id And 相关id Is Not Null)) Loop
    --1.划价单删除
    If Nvl(操作_In, 0) = 0 Then
      --D    检查       JC
      --F    手术       SS
      --:-1-无须计费(通常无执行和院外执行的都无须计费);0-未计费;1-已计费，2-部分退费(销帐)，3-全部收费(仅门诊收费有)，4-全部退费(销帐)
      If c_医嘱.相关id Is Null And Instr(',D,F,', ',' || c_医嘱.诊疗类别 || ',') > 0 Then
        If 场合_In = 0 Then
          Select Nvl(Count(*), 0)
          Into n_Count
          From 门诊费用记录 A, (Select ID From 病人医嘱记录 A Where ID = c_医嘱.Id Or 相关id = c_医嘱.Id) B, 病人医嘱发送 C
          Where a.医嘱序号 = b.Id And a.No = No_In And a.记录性质 = 性质_In And a.No = c.No And a.记录性质 = c.记录性质 And c.计费状态 = 1 And
                Nvl(a.附加标志, 0) <> 9;
        Else
          Select Nvl(Count(*), 0)
          Into n_Count
          From 住院费用记录 A, (Select ID From 病人医嘱记录 A Where ID = c_医嘱.Id Or 相关id = c_医嘱.Id) B, 病人医嘱发送 C
          Where a.医嘱序号 = b.Id And a.No = No_In And a.记录性质 = 性质_In And a.No = c.No And a.记录性质 = c.记录性质 And c.计费状态 = 1 And
                Nvl(a.附加标志, 0) <> 9;
        End If;
      Else
        If 场合_In = 0 Then
          Select Nvl(Count(*), 0)
          Into n_Count
          From 门诊费用记录 A, (Select ID From 病人医嘱记录 A Where ID = c_医嘱.Id) B, 病人医嘱发送 C
          Where a.医嘱序号 = b.Id And a.No = No_In And a.记录性质 = 性质_In And a.No = c.No And a.记录性质 = c.记录性质 And c.计费状态 = 1 And
                Nvl(a.附加标志, 0) <> 9;
        Else
          Select Nvl(Count(*), 0)
          Into n_Count
          From 住院费用记录 A, (Select ID From 病人医嘱记录 A Where ID = c_医嘱.Id Or 相关id = c_医嘱.Id) B, 病人医嘱发送 C
          Where a.医嘱序号 = b.Id And a.No = No_In And a.记录性质 = 性质_In And a.No = c.No And a.记录性质 = c.记录性质 And c.计费状态 = 1 And
                Nvl(a.附加标志, 0) <> 9;
        End If;
      End If;
      If Nvl(n_Count, 0) = 0 Then
        l_医嘱id.Extend;
        l_医嘱id(l_医嘱id.Count) := c_医嘱.Id;
        l_计费状态.Extend;
        l_计费状态(l_计费状态.Count) := 0; --未计费
      
      End If;
    End If;
  
    --1.收费或记帐
    If Nvl(操作_In, 0) = 1 Then
      --:-1-无须计费(通常无执行和院外执行的都无须计费);0-未计费;1-已计费，2-部分退费(销帐)，3-全部收费(仅门诊收费有)，4-全部退费(销帐)
      n_Count := 0;
      If c_医嘱.相关id Is Null And Instr(',D,F,', ',' || c_医嘱.诊疗类别 || ',') = 0 And
         Instr(Nvl(v_医嘱ids, '-'), ',' || c_医嘱.Id || ',') = 0 Then
        n_Count := 1;
      End If;
    
      If Nvl(n_Count, 0) = 0 Then
        l_医嘱id.Extend;
        l_医嘱id(l_医嘱id.Count) := c_医嘱.Id;
        l_计费状态.Extend;
        l_计费状态(l_计费状态.Count) := 3; --全部收费
      
      End If;
    End If;
  
    --2.退费或销帐
    If Nvl(操作_In, 0) = 2 Then
      --:-1-无须计费(通常无执行和院外执行的都无须计费);0-未计费;1-已计费，2-部分退费(销帐)，3-全部收费(仅门诊收费有)，4-全部退费(销帐)
      If c_医嘱.相关id Is Null And Instr(',D,F,', ',' || c_医嘱.诊疗类别 || ',') > 0 Then
        If 场合_In = 0 Then
          Select Case
                   When Min(状态) = Max(状态) Then
                    Max(状态)
                   Else
                    3
                 End
          Into n_Count
          From (
                 
                 Select Case
                            When 剩余数量 = 原始数量 And 原始数量 <> 0 Then
                             0
                            When 剩余数量 = 0 Then
                             2
                            Else
                             3
                          End As 状态
                 
                 From (Select 序号, Sum(Nvl(Nvl(付数, 1) * 数次, 0)) As 剩余数量,
                                Nvl(Sum(Decode(记录状态, 1, 1, 3, 1, 0) * Decode(记录性质, 11, 0, 1) * Nvl(Nvl(付数, 1) * 数次, 0)), 0) As 原始数量
                         From 门诊费用记录
                         Where Decode(性质_In, 2, 记录性质, Mod(记录性质, 10)) = 性质_In And NO = No_In And 价格父号 Is Null And
                               Nvl(附加标志, 0) <> 9 And
                               医嘱序号 + 0 In (Select ID From 病人医嘱记录 Where ID = c_医嘱.Id Or 相关id = c_医嘱.Id)
                         Group By 序号));
        Else
          Select Case
                   When Min(状态) = Max(状态) Then
                    Max(状态)
                   Else
                    3
                 End
          Into n_Count
          From (
                 
                 Select Case
                           When 剩余数量 = 原始数量 And 原始数量 <> 0 Then
                            0
                           When 剩余数量 = 0 Then
                            2
                           Else
                            3
                         End As 状态
                 
                 From (Select 序号, Sum(Nvl(Nvl(付数, 1) * 数次, 0)) As 剩余数量,
                                Nvl(Sum(Decode(记录状态, 1, 1, 3, 1, 0) * Decode(记录性质, 11, 0, 1) * Nvl(Nvl(付数, 1) * 数次, 0)), 0) As 原始数量
                         From 住院费用记录
                         Where Decode(性质_In, 2, 记录性质, Mod(记录性质, 10)) = 性质_In And NO = No_In And 价格父号 Is Null And
                               Nvl(附加标志, 0) <> 9 And
                               医嘱序号 + 0 In (Select ID From 病人医嘱记录 Where ID = c_医嘱.Id Or 相关id = c_医嘱.Id)
                         Group By 序号));
        
        End If;
      Else
        If 场合_In = 0 Then
          Select Case
                   When Min(状态) = Max(状态) Then
                    Max(状态)
                   Else
                    3
                 End
          Into n_Count
          From (
                 
                 Select Case
                            When 剩余数量 = 原始数量 And 原始数量 <> 0 Then
                             0
                            When 剩余数量 = 0 Then
                             2
                            Else
                             3
                          End As 状态
                 From (Select 序号, Sum(Nvl(Nvl(付数, 1) * 数次, 0)) As 剩余数量,
                                Nvl(Sum(Decode(记录状态, 1, 1, 3, 1, 0) * Decode(记录性质, 11, 0, 1) * Nvl(Nvl(付数, 1) * 数次, 0)), 0) As 原始数量
                         From 门诊费用记录
                         Where Decode(性质_In, 2, 记录性质, Mod(记录性质, 10)) = 性质_In And NO = No_In And 价格父号 Is Null And
                               Nvl(附加标志, 0) <> 9 And 医嘱序号 + 0 = c_医嘱.Id
                         Group By 序号));
        Else
        
          Select Case
                   When Min(状态) = Max(状态) Then
                    Max(状态)
                   Else
                    3
                 End
          Into n_Count
          From (
                 
                 Select Case
                           When 剩余数量 = 原始数量 And 原始数量 <> 0 Then
                            0
                           When 剩余数量 = 0 Then
                            2
                           Else
                            3
                         End As 状态
                 From (Select 序号, Sum(Nvl(Nvl(付数, 1) * 数次, 0)) As 剩余数量,
                                Nvl(Sum(Decode(记录状态, 1, 1, 3, 1, 0) * Decode(记录性质, 11, 0, 1) * Nvl(Nvl(付数, 1) * 数次, 0)), 0) As 原始数量
                         From 住院费用记录
                         Where Decode(性质_In, 2, 记录性质, Mod(记录性质, 10)) = 性质_In And NO = No_In And 价格父号 Is Null And
                               Nvl(附加标志, 0) <> 9 And 医嘱序号 + 0 = c_医嘱.Id
                         Group By 序号));
        
        End If;
      
      End If;
    
      If n_Count <> 0 Then
      
        l_医嘱id.Extend;
        l_医嘱id(l_医嘱id.Count) := c_医嘱.Id;
        l_计费状态.Extend;
        l_计费状态(l_计费状态.Count) := Case
                                  When Nvl(n_Count, 0) = 2 Then
                                   4
                                  Else
                                   2
                                End;
      End If;
    End If;
  End Loop;

  Forall I In 1 .. l_医嘱id.Count
    Update 病人医嘱发送 A
    Set a.计费状态 = l_计费状态(I)
    Where 医嘱id = l_医嘱id(I) And 记录性质 = 性质_In And NO = No_In;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_医嘱发送_计费状态_Update;
/

--93623:刘兴洪,2016-02-25,更改医嘱发送的计费状态
Create Or Replace Procedure Zl_门诊划价记录_Delete
(
  No_In   门诊费用记录.No%Type,
  序号_In Varchar2 := Null --主要用于门诊医生站作废单个药品
) As
  --功能：删除一张门诊划价单据
  --该游标用于处理费用记录序号
  Cursor c_Serial Is
    Select ID, 价格父号 From 门诊费用记录 Where NO = No_In And 记录性质 = 1 And 记录状态 = 0 Order By 序号;

  l_医嘱id t_Numlist := t_Numlist();
  v_医嘱id 病人医嘱记录.Id%Type;

  n_父号         门诊费用记录.序号%Type;
  n_Count        Number;
  n_医嘱数       Number(5);
  n_已执行_Count Number;
  v_医嘱ids      Varchar2(4000);

  Err_Item Exception;
  v_Err_Msg Varchar2(255);
Begin

  --是否已经删除或收费
  Select Nvl(Count(ID), 0), Sum(Decode(医嘱序号, Null, 0, 1)), Max(医嘱序号), Sum(Decode(Nvl(执行状态, 0), 1, 1, 2, 1, 0))
  Into n_Count, n_医嘱数, v_医嘱id, n_已执行_Count
  From 门诊费用记录
  Where 记录性质 = 1 And 记录状态 = 0 And NO = No_In And
        (Instr(',' || 序号_In || ',', ',' || Nvl(价格父号, 序号) || ',') > 0 Or 序号_In Is Null);

  If n_Count = 0 Then
    v_Err_Msg := '要删除的费用记录不存在，可能已经删除或已经收费。';
    Raise Err_Item;
  End If;
  --是否已经执行
  If Nvl(n_已执行_Count, 0) > 0 Then
    v_Err_Msg := '要删除的费用记录中包含已执行的内容！';
    Raise Err_Item;
  End If;

  --医嘱费用：检查正在执行的医嘱(注意已执行的情况在下面检查,因为不传 序号_IN 这种情况费用界面已限制)
  Select Nvl(Count(*), 0)
  Into n_Count
  From 病人医嘱发送
  Where 执行状态 = 3 And (NO, 记录性质, 医嘱id) In
        (Select NO, 记录性质, 医嘱序号
                      From 门诊费用记录
                      Where NO = No_In And 记录性质 = 1 And 记录状态 = 0 And 医嘱序号 Is Not Null And
                            (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null));
  If n_Count > 0 Then
    v_Err_Msg := '要删除的费用中存在对应的医嘱正在执行的情况，不能删除！';
    Raise Err_Item;
  End If;

  --药品相关内容
  For r_Expenses In (Select ID
                     From 门诊费用记录
                     Where NO = No_In And 记录性质 = 1 And 记录状态 = 0 And 收费类别 In ('4', '5', '6', '7') And
                           (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null)) Loop
    Zl_药品收发记录_销售退费(r_Expenses.Id);
  End Loop;

  --删除病人医嘱附费(最后一次删除时)
  If 序号_In Is Null Then
    --Begin
    --  Select 医嘱序号
    --  Into v_医嘱id
    --  From 门诊费用记录
    --  Where 记录性质 = 1 And 记录状态 = 0 And NO = No_In And Rownum = 1;
    -- Exception
    --  When Others Then
    --    Null;
    -- End;
  
    If v_医嘱id Is Not Null Then
      Delete From 病人医嘱附费 Where 医嘱id = v_医嘱id And NO = No_In And 记录性质 = 1;
    End If;
  End If;

  If n_医嘱数 > 0 Then
    If n_医嘱数 = 1 Then
      l_医嘱id.Extend;
      l_医嘱id(l_医嘱id.Count) := v_医嘱id;
    Else
      Select Distinct 医嘱序号 Bulk Collect
      Into l_医嘱id
      From 门诊费用记录
      Where 记录性质 = 1 And 记录状态 = 0 And NO = No_In And 医嘱序号 Is Not Null And
            (Instr(',' || 序号_In || ',', ',' || Nvl(价格父号, 序号) || ',') > 0 Or 序号_In Is Null);
    End If;
  End If;

  --门诊费用记录
  Delete From 门诊费用记录
  Where 记录性质 = 1 And 记录状态 = 0 And NO = No_In And
        (Instr(',' || 序号_In || ',', ',' || Nvl(价格父号, 序号) || ',') > 0 Or 序号_In Is Null);
  If Sql%RowCount = 0 Then
    v_Err_Msg := '要删除的费用记录不存在，可能已经删除或已经收费。';
    Raise Err_Item;
  End If;

  v_医嘱ids := Null;
  For I In 1 .. l_医嘱id.Count Loop
    v_医嘱ids := Nvl(v_医嘱ids, '') || ',' || l_医嘱id(I);
  End Loop;
  If v_医嘱ids Is Not Null Then
    v_医嘱ids := Substr(v_医嘱ids, 2);
    --场合_In    Integer, --0:门诊;1-住院
    --性质_In    Integer, --1-收费单;2-记帐单
    --操作_In    Integer, --0:删除划价单;1-收费或记帐;2-退费或销帐
    --No_In      门诊费用记录.No%Type,
    --医嘱ids_In Varchar2
    Zl_医嘱发送_计费状态_Update(0, 1, 0, No_In, v_医嘱ids);
  End If;

  If 序号_In Is Not Null Then
    --重新调整剩余费用费用记录的序号
    n_Count := 1;
    For r_Serial In c_Serial Loop
      If r_Serial.价格父号 Is Null Then
        n_父号 := n_Count;
      End If;
      Update 门诊费用记录 Set 序号 = n_Count, 价格父号 = Decode(价格父号, Null, Null, n_父号) Where ID = r_Serial.Id;
      n_Count := n_Count + 1;
    End Loop;
  End If;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊划价记录_Delete;
/

--93623:刘兴洪,2016-02-25,更改医嘱发送的计费状态
Create Or Replace Procedure Zl_门诊简单收费_Delete
(
  No_In         门诊费用记录.No%Type,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type
) As
  --功能：删除一张门诊简单收费单据

  --该游标为要退费单据的所有原始记录
  Cursor c_Bill Is
    Select a.Id, a.No, a.附加标志, a.收费细目id, a.序号, a.价格父号, a.执行状态, a.收费类别, a.付数, a.数次, a.医嘱序号, j.诊疗类别, m.跟踪在用
    From 门诊费用记录 A, 病人医嘱记录 J, 材料特性 M
    Where a.医嘱序号 = j.Id(+) And a.No = No_In And a.记录性质 = 1 And a.记录状态 In (1, 3) And a.收费细目id + 0 = m.材料id(+)
    Order By a.收费细目id, a.序号;

  --该光标用于处理人员缴款余额中退的不同结算方式的金额
  Cursor c_Money(冲销id_In 病人预交记录.结帐id%Type) Is
    Select 结算方式, 冲预交
    From 病人预交记录
    Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = 冲销id_In And 结算方式 Is Not Null And Nvl(冲预交, 0) <> 0 And Nvl(校对标志, 0) = 0;

  --该游标用于查找收费时使用过的冲预交款记录
  Cursor c_Deposit(V结帐id 病人预交记录.结帐id%Type) Is
    Select ID, 病人id, 冲预交 As 金额, 预交类别
    From 病人预交记录
    Where 记录性质 In (1, 11) And 记录状态 In (1, 3) And 结帐id = V结帐id And Nvl(冲预交, 0) <> 0
    Order By ID Desc;

  n_病人id   病人信息.病人id%Type;
  n_结帐id   门诊费用记录.结帐id%Type;
  n_结算序号 病人预交记录.结算序号%Type;
  n_打印id   票据打印内容.Id%Type;

  n_预交金额 病人预交记录.冲预交%Type;
  n_返回值   病人预交记录.冲预交%Type;
  --部分退费计算变量
  n_剩余数量 Number;
  n_剩余应收 Number;
  n_剩余实收 Number;
  n_剩余统筹 Number;
  n_准退数量 Number;
  n_退费次数 Number;

  n_应收金额 Number;
  n_实收金额 Number;
  n_统筹金额 Number;
  n_总金额   Number;
  n_费用状态 门诊费用记录.费用状态%Type;
  n_正常退费 Number; --是否第一次退费且全部退费,在每行退费过程中判断得到。
  n_组id     财务缴款分组.Id%Type;

  v_退费结算 结算方式.名称%Type;
  l_使用id   t_Numlist := t_Numlist();
  n_Dec      Number;
  d_Date     Date;
  n_Count    Number;
  n_原结帐id Number;

  Err_Item Exception;
  v_Err_Msg      Varchar2(255);
  n_启用模式     Number(3);
  v_Para         Varchar2(1000);
  n_医属执行计价 Number;
Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  --是否已经全部完全执行(只是该单据整张单据的检查)
  Select Nvl(Count(*), 0)
  Into n_Count
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1;
  If n_Count = 0 Then
    v_Err_Msg := '该单据中的项目已经全部完全执行！';
    Raise Err_Item;
  End If;

  --未完全执行的项目是否有剩余数量(只是整张单据的检查)
  --执行状态在原始记录上判断
  Select Nvl(Count(*), 0)
  Into n_Count
  From (Select 序号, Sum(数量) As 剩余数量
         From (Select 记录状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                From 门诊费用记录
                Where NO = No_In And 记录性质 = 1 And Nvl(附加标志, 0) <> 9 And
                      Nvl(价格父号, 序号) In
                      (Select Nvl(价格父号, 序号)
                       From 门诊费用记录
                       Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1)
                Group By 记录状态, Nvl(价格父号, 序号))
         Group By 序号
         Having Sum(数量) <> 0);
  If n_Count = 0 Then
    v_Err_Msg := '该单据中未完全执行部分项目剩余数量为零,没有可以退费的费用！';
    Raise Err_Item;
  End If;
  --确定是否在医嘱执行计价中存在数据,如果存在数据,则根据医嘱执行计价进行退费,否则按旧方式进行处理
  Select Count(1)
  Into n_医属执行计价
  From 门诊费用记录 A, 医嘱执行计价 B
  Where a.医嘱序号 = b.医嘱id And a.记录性质 = 1 And a.No = No_In And a.记录状态 In (1, 3) And Rownum = 1;

  ---------------------------------------------------------------------------------
  --公用变量
  Select Sysdate Into d_Date From Dual;
  Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  n_结算序号 := Null;

  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into n_Dec From Dual;

  --获取结算方式名称
  Begin
    Select 名称 Into v_退费结算 From 结算方式 Where 性质 = 1;
  Exception
    When Others Then
      v_退费结算 := '现金';
  End;

  ---------------------------------------------------------------------------------
  --循环处理每行费用(收入项目行)
  n_总金额   := 0;
  n_正常退费 := 1;
  For r_Bill In c_Bill Loop
    If Nvl(r_Bill.执行状态, 0) <> 1 Then
      --求剩余数量,剩余应收,剩余实收
      Select Sum(Nvl(付数, 1) * 数次), Sum(应收金额), Sum(实收金额), Sum(统筹金额)
      Into n_剩余数量, n_剩余应收, n_剩余实收, n_剩余统筹
      From 门诊费用记录
      Where NO = No_In And 记录性质 = 1 And 序号 = r_Bill.序号;
    
      If n_剩余数量 = 0 Then
        --情况：未限定行号,原始单据中的该笔已经全部退费(执行状态=0的一种可能)
        n_正常退费 := 0;
      Else
        --准退数量(非药品项目为剩余数量,原始数量)
        If Instr(',4,5,6,7,', r_Bill.收费类别) = 0 Or (r_Bill.收费类别 = '4' And Nvl(r_Bill.跟踪在用, 0) = 0) Then
          --@@@
          --非药品部分(以具体医嘱执行为准进行检查)
          --: 1.存在医嘱发送的,则以医嘱执行为准(但不能包含:检查;检验;手术;麻醉及输血)
          --: 2.不存在医嘱的,则以剩余数量为准
          n_Count := 0;
          If Instr(',C,D,F,G,K,', ',' || r_Bill.诊疗类别 || ',') = 0 And r_Bill.诊疗类别 Is Not Null Then
            If n_医属执行计价 = 1 Then
              Select Decode(Sign(Sum(数量)), -1, 0, Sum(数量)), Count(*)
              Into n_准退数量, n_Count
              From (Select Max(Decode(a.记录状态, 2, 0, a.Id)) As ID, Max(a.医嘱序号) As 医嘱id, Max(a.收费细目id) As 收费细目id,
                            Sum(Nvl(a.付数, 1) * Nvl(a.数次, 1)) As 数量,
                            Sum(Decode(a.记录状态, 2, 0, Nvl(a.付数, 1) * Nvl(a.数次, 1))) As 原始数量
                     From 门诊费用记录 A, 病人医嘱记录 M
                     Where a.医嘱序号 = m.Id And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                           Instr('5,6,7', a.收费类别) = 0 And a.No = No_In And a.序号 = r_Bill.序号 And a.记录性质 = 1 And
                           a.记录状态 In (1, 2, 3) And a.价格父号 Is Null
                     Group By a.序号
                     Union All
                     Select a.Id, a.医嘱序号 As 医嘱id, a.收费细目id, -1 * b.数量 As 已执行, 0 原始数量
                     From 门诊费用记录 A, 医嘱执行计价 B, 病人医嘱记录 M
                     Where a.医嘱序号 = b.医嘱id And a.收费细目id = b.收费细目id + 0 And a.医嘱序号 = m.Id And
                           Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Instr('5,6,7', a.收费类别) = 0 And
                           (Exists
                            (Select 1
                             From 病人医嘱执行
                             Where b.医嘱id = 医嘱id And b.发送号 = 发送号 And b.要求时间 = 要求时间 And Nvl(执行结果, 0) = 1) Or Exists
                            (Select 1
                             From 病人医嘱发送
                             Where b.医嘱id = 医嘱id And b.发送号 = 发送号 And Nvl(执行状态, 0) = 1)) And Not Exists
                      (Select 1
                            From 病人医嘱附费
                            Where a.医嘱序号 = 医嘱id And a.No = NO And Mod(a.记录性质, 10) = 记录性质) And a.No = No_In And
                           a.序号 = r_Bill.序号 And a.记录性质 = 1 And a.记录状态 In (1, 3) 　and a.价格父号 Is Null) Q1
              Where Not Exists (Select 1 From 药品收发记录 Where 费用id = Q1.Id) Having Max(ID) <> 0;
            Else
              Select Nvl(Sum(数量), 0), Count(*)
              Into n_准退数量, n_Count
              From (Select a.医嘱id, a.收费细目id, Nvl(a.数量, 1) * Nvl(b.发送数次, 1) As 数量
                     From 病人医嘱计价 A, 病人医嘱发送 B, 门诊费用记录 J, 病人医嘱记录 M
                     Where a.医嘱id = b.医嘱id And a.医嘱id = m.Id And Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And
                           a.收费细目id = j.收费细目id And j.No = No_In And j.记录性质 = 1 And j.序号 = r_Bill.序号 And j.记录状态 In (1, 3) And
                           j.价格父号 Is Null And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Exists
                      (Select 1
                            From 病人医嘱计价 A
                            Where a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And Nvl(a.收费方式, 0) = 0) And Not Exists
                      (Select 1 From 药品收发记录 Where 费用id = j.Id)
                     Union All
                     Select a.医嘱id, a.收费细目id, -1 * Nvl(a.数量, 1) * Nvl(c.本次数次, 1) As 数量
                     From 病人医嘱计价 A, 病人医嘱发送 B, 病人医嘱执行 C, 门诊费用记录 J, 病人医嘱记录 M
                     Where a.医嘱id = b.医嘱id And b.医嘱id = c.医嘱id And b.发送号 = c.发送号 And a.医嘱id = m.Id And Nvl(c.执行结果, 1) = 1 And
                           Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And j.No = No_In And
                           j.记录性质 = 1 And Nvl(a.收费方式, 0) = 0 And j.序号 = r_Bill.序号 And j.记录状态 In (1, 3) And j.价格父号 Is Null And
                           Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Not Exists
                      (Select 1 From 药品收发记录 Where 费用id = j.Id) And Not Exists
                      (Select 1 From 材料特性 Where 材料id = j.收费细目id And Nvl(跟踪在用, 0) = 1)
                     Union All
                     Select a.医嘱序号 As 医嘱id, a.收费细目id, Nvl(a.付数, 1) * a.数次 As 数量
                     From 门诊费用记录 A, 病人医嘱记录 M
                     Where a.医嘱序号 = m.Id And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And a.No = No_In And
                           a.记录性质 = 1 And a.序号 = r_Bill.序号 And a.记录状态 = 2 And a.价格父号 Is Null And Not Exists
                      (Select 1 From 药品收发记录 Where NO = No_In And 单据 In (8, 24) And 药品id = a.收费细目id));
            End If;
          End If;
          If Nvl(n_Count, 0) <> 0 And n_准退数量 = 0 Then
            v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已执行,不允许退费！';
            Raise Err_Item;
          End If;
        
          If Nvl(n_Count, 0) = 0 Then
            n_准退数量 := n_剩余数量;
          End If;
        
        Else
          Select Nvl(Sum(Nvl(付数, 1) * 实际数量), 0), Count(*)
          Into n_准退数量, n_Count
          From 药品收发记录
          Where NO = No_In And 单据 In (8, 24) And Mod(记录状态, 3) = 1 --@@@
                And 审核人 Is Null And 费用id = r_Bill.Id;
        
          --有剩余数量无准退数量的有两种情况：
          --1.不跟踪在用的卫材无对应的收发记录,这时使用剩余数量
          --2.并发操作,此时已发药或发料
          If n_准退数量 = 0 Then
            If r_Bill.收费类别 = '4' Then
              If n_Count > 0 Then
                v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发料,须退料后再退费！';
                Raise Err_Item;
              Else
                n_准退数量 := n_剩余数量;
              End If;
            Else
              v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发药,须退药后再退费！';
              Raise Err_Item;
            End If;
          End If;
        End If;
      
        --是否部分退费
        If r_Bill.执行状态 = 2 Or n_准退数量 <> Nvl(r_Bill.付数, 1) * r_Bill.数次 Then
          n_正常退费 := 0;
        End If;
      
        --处理门诊费用记录
        n_费用状态 := 0;
        --该笔项目第几次退费
        Select Nvl(Max(Abs(执行状态)), 0) + 1
        Into n_退费次数
        From 门诊费用记录
        Where NO = No_In And 记录性质 = 1 And 记录状态 = 2 And Nvl(执行状态, 0) < 0 And 序号 = r_Bill.序号;
      
        n_应收金额 := Round(n_剩余应收 * (n_准退数量 / n_剩余数量), n_Dec);
        n_实收金额 := Round(n_剩余实收 * (n_准退数量 / n_剩余数量), n_Dec);
        n_统筹金额 := Round(n_剩余统筹 * (n_准退数量 / n_剩余数量), n_Dec);
        n_总金额   := n_总金额 + n_实收金额;
      
        --插入退费记录
        Insert Into 门诊费用记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别, 收费细目id,
           计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, 执行状态,
           费用状态, 执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 结论, 缴款组id)
          Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别,
                 病人科室id, 收费类别, 收费细目id, 计算单位, Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, 付数, 1), 发药窗口,
                 Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, -1 * 数次, -1 * n_准退数量), 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价,
                 -1 * n_应收金额, -1 * n_实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, -1 * n_退费次数, n_费用状态, 执行时间, 操作员编号_In, 操作员姓名_In,
                 发生时间, d_Date, n_结帐id, -1 * n_实收金额, 保险项目否, 保险大类id, -1 * n_统筹金额, 摘要, Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码,
                 费用类型, 结论, n_组id
          From 门诊费用记录
          Where ID = r_Bill.Id;
      
        --标记原费用记录
        --执行状态:全部退完(准退数=剩余数)标记为0,否则标记为1,异常收费单,还是标明9
        Update 门诊费用记录
        Set 记录状态 = 3, 执行状态 = Decode(Nvl(执行状态, 0), 9, 9, Decode(Sign(n_准退数量 - n_剩余数量), 0, 0, 1))
        Where ID = r_Bill.Id;
      End If;
    Else
      --情况:没限定行号,原始单据中包括已经完全执行的
      n_正常退费 := 0;
    End If;
  End Loop;

  ---------------------------------------------------------------------------------
  --处理病人预交记录
  --自动产生误差费,默认保留一位
  n_总金额 := Round(n_总金额, 1);
  --原单据的结帐ID
  Select 结帐id, 病人id
  Into n_原结帐id, n_病人id
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Rownum = 1;

  If n_正常退费 = 1 Then
    --单据第一次退费且全部退完
    --冲预交部分记录
    Insert Into 病人预交记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交, 结帐id,
       缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
      Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, d_Date,
             操作员姓名_In, 操作员编号_In, -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 0, n_结算序号, 3
      From 病人预交记录
      Where 记录性质 In (1, 11) And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0;
    --处理病人预交余额
    For v_预交 In (Select 预交类别, Nvl(Sum(Nvl(冲预交, 0)), 0) As 预交金额, 病人id
                 From 病人预交记录
                 Where 记录性质 In (1, 11) And 结帐id = n_原结帐id
                 Group By 预交类别, 病人id
                 Having Sum(Nvl(冲预交, 0)) <> 0) Loop
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + Nvl(v_预交.预交金额, 0)
      Where 病人id = v_预交.病人id And 性质 = 1 And 类型 = Nvl(v_预交.预交类别, 2)
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 类型, 预交余额, 性质)
        Values
          (v_预交.病人id, Nvl(v_预交.预交类别, 2), Nvl(v_预交.预交金额, 0), 1);
        n_返回值 := n_预交金额;
      End If;
      If n_返回值 = 0 Then
        Delete From 病人余额
        Where 病人id = v_预交.病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
      End If;
    End Loop;
  
    --原样退回(冲预交在前面已处理)
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
       卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
      Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, d_Date, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
             -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 0, n_结算序号, 3
      From 病人预交记录 A, (Select 名称 From 结算方式 Where 性质 In (3, 4)) J,
           (Select m.Id As 预交id From 病人预交记录 M Where m.结帐id = n_原结帐id And m.记录性质 = 3 And m.记录状态 = 1) Q
      Where a.记录性质 = 3 And a.记录状态 = 1 And a.结帐id = n_原结帐id And a.Id = q.预交id(+) And a.结算方式 = j.名称(+);
  Else
    --部分退费直接退为指定结算方式
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
       结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
      Select 病人预交记录_Id.Nextval, 3, No_In, 2, 病人id, 主页id, '部分退费结算', v_退费结算, d_Date, Null, Null, Null, 操作员编号_In, 操作员姓名_In,
             -1 * n_总金额, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 0, n_结算序号, 3
      
      From 病人预交记录
      Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id And Rownum = 1;
  
    --如果收费时只使用了预交款,则要退预交,并且可能有多笔冲预交
    If Sql%RowCount = 0 Then
      n_预交金额 := n_总金额;
    
      For r_Deposit In c_Deposit(n_原结帐id) Loop
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 d_Date, 操作员姓名_In, 操作员编号_In, Decode(Sign(r_Deposit.金额 - n_预交金额), -1, -1 * r_Deposit.金额, -1 * n_预交金额),
                 n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 0, n_结算序号, 3
          From 病人预交记录
          Where ID = r_Deposit.Id;
      
        --更新病人预交余额
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) + n_总金额
        Where 病人id = r_Deposit.病人id And 性质 = 1 And 类型 = 1
        Returning 预交余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (r_Deposit.病人id, 1, n_总金额, 1);
          n_返回值 := n_总金额;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 病人余额
          Where 病人id = r_Deposit.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
        End If;
      
        --检查是否已经处理完
        If r_Deposit.金额 < n_预交金额 Then
          n_预交金额 := n_预交金额 - r_Deposit.金额;
        Else
          n_预交金额 := 0;
        End If;
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
    
    End If;
  End If;
  --更新原记录
  Update 病人预交记录 Set 记录状态 = 3 Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id;

  Select Nvl(Sum(Nvl(结帐金额, 0)), 0) Into n_实收金额 From 门诊费用记录 Where 结帐id = n_结帐id;
  Select Nvl(Sum(Nvl(冲预交, 0)), 0) Into n_返回值 From 病人预交记录 Where 结帐id = n_结帐id;

  n_实收金额 := n_实收金额 - n_返回值;

  If n_实收金额 <> 0 Then
    --未找到，新产生误差项
    Zl_简单收费误差_Insert(No_In, n_病人id, n_结帐id, n_实收金额, d_Date, 操作员编号_In, 操作员姓名_In, 1);
  End If;

  --人员缴款余额(注意是预交记录处理后才处理，包括个人帐户等的结算金额,不含退冲预交款)
  For r_Moneyrow In c_Money(n_结帐id) Loop
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + r_Moneyrow.冲预交
    Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Moneyrow.结算方式
    Returning 余额 Into n_返回值;
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额
        (收款员, 结算方式, 性质, 余额)
      Values
        (操作员姓名_In, r_Moneyrow.结算方式, 1, r_Moneyrow.冲预交);
      n_返回值 := r_Moneyrow.冲预交;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 人员缴款余额
      Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Moneyrow.结算方式 And Nvl(余额, 0) = 0;
    End If;
  End Loop;

  ---------------------------------------------------------------------------------
  --退费票据回收(仅全退时才回退,部分退是在重打过程中回收)
  --启用标志||NO;执行科室(条数);收据费目(首页汇总,条数);收费细目(条数)
  v_Para     := Nvl(zl_GetSysParameter('票据分配规则', 1121), '0||0;0;0,0;0');
  n_启用模式 := Zl_To_Number(Substr(v_Para, 1, 1));
  If n_启用模式 <> 0 Then
    --收回票据
    Select 使用id Bulk Collect
    Into l_使用id
    From (Select Distinct b.使用id From 票据打印明细 B Where b.No = No_In And Nvl(b.票种, 0) = 1);
  
    n_启用模式 := l_使用id.Count;
    If l_使用id.Count <> 0 Then
      --插入回收记录
      Forall I In 1 .. l_使用id.Count
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 操作员姓名_In, d_Date
          From 票据使用明细 A
          Where ID = l_使用id(I) And 性质 = 1 And Not Exists
           (Select 1 From 票据使用明细 Where 号码 = a.号码 And 票种 = a.票种 And Nvl(性质, 0) <> 1);
    
      Forall I In 1 .. l_使用id.Count
        Update 票据打印明细 Set 是否回收 = 1 Where 使用id = l_使用id(I) And Nvl(是否回收, 0) = 0;
    
    End If;
  End If;
  If n_启用模式 = 0 Then
    --获取单据最后一次的打印ID(可能是多张单据收费打印)
    Begin
      Select ID
      Into n_打印id
      From (Select b.Id
             From 票据使用明细 A, 票据打印内容 B
             Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 1 And b.No = No_In
             Order By a.使用时间 Desc)
      Where Rownum < 2;
    Exception
      When Others Then
        Null;
    End;
    --可能以前没有打印,无收回
    If n_打印id Is Not Null Then
      --a.多张单据循环调用时只能收回一次
      Select Count(*) Into n_Count From 票据使用明细 Where 票种 = 1 And 性质 = 2 And 打印id = n_打印id;
      If n_Count = 0 Then
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
          From 票据使用明细
          Where 打印id = n_打印id And 票种 = 1 And 性质 = 1;
      Else
        --b.部分退费多次收回时,最后一次全退收回要排开已收回的
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
          From 票据使用明细 A
          Where 打印id = n_打印id And 票种 = 1 And 性质 = 1 And Not Exists
           (Select 1 From 票据使用明细 B Where a.号码 = b.号码 And 打印id = n_打印id And 票种 = 1 And 性质 = 2);
      End If;
    End If;
  End If;

  ---------------------------------------------------------------------------------
  --药品卫材相关内容
  For r_Expenses In (Select ID
                     From 门诊费用记录
                     Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And 收费类别 In ('4', '5', '6', '7')) Loop
    Zl_药品收发记录_销售退费(r_Expenses.Id);
  End Loop;

  --医嘱处理
  --场合_In    Integer:=0, --0:门诊;1-住院
  --性质_In    Integer:=1, --1-收费单;2-记帐单
  --操作_In    Integer:=0, --0:删除划价单;1-收费或记帐;2-退费或销帐
  --No_In      门诊费用记录.No%Type,
  --医嘱ids_In Varchar2 := Null
  Zl_医嘱发送_计费状态_Update(0, 1, 2, No_In);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊简单收费_Delete;
/

--93623:刘兴洪,2016-02-25,更改医嘱发送的计费状态
Create Or Replace Procedure Zl_门诊划价记录_Clear(Day_In Number) As
  --功能：自动清除划价单
  --参数：Day_IN=删除划价后超过Day_IN天未收费的单据
  Cursor c_Price Is
    Select a.Id, a.No, a.序号, a.医嘱序号, a.收费类别, a.执行部门id, a.收费细目id, Nvl(a.付数, 1) * a.数次 As 数量
    From 门诊费用记录 A, 未发药品记录 B
    Where a.记录性质 = 1 And a.记录状态 = 0 And a.执行状态 Not In (1, 2) And a.划价人 Is Not Null And a.操作员姓名 Is Null And
          b.单据 In (8, 24) And Nvl(b.已收费, 0) = 0 And a.No = b.No And Nvl(a.执行部门id, 0) = Nvl(b.库房id, 0) And
          Sysdate - b.填制日期 >= Day_In;

  l_No t_Strlist := t_Strlist();

Begin
  For r_Price In c_Price Loop
    --费用部份
    Delete From 门诊费用记录 Where ID = r_Price.Id;
    If Sql%RowCount <> 0 Then
      --药品部份
      If Instr(',4,5,6,7,', ',' || r_Price.收费类别 || ',') > 0 Then
        Zl_药品收发记录_销售退费(r_Price.Id);
      End If;
    End If;
    --病人医嘱附费
    If r_Price.序号 = 1 And r_Price.医嘱序号 Is Not Null Then
      Delete From 病人医嘱附费 Where 医嘱id = r_Price.医嘱序号 And NO = r_Price.No And 记录性质 = 1;
    End If;

    l_No.Extend;
    l_No(l_No.Count) := r_Price.No;
  End Loop;
  For c_No In (Select Distinct Column_Value As NO From Table(l_No)) Loop
    --医嘱处理
    --场合_In    Integer:=0, --0:门诊;1-住院
    --性质_In    Integer:=1, --1-收费单;2-记帐单
    --操作_In    Integer:=0, --0:删除划价单;1-收费或记帐;2-退费或销帐
    --No_In      门诊费用记录.No%Type,
    --医嘱ids_In Varchar2 := Null
    Zl_医嘱发送_计费状态_Update(0, 1, 0, c_No.No);
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊划价记录_Clear;
/

--93623:刘兴洪,2016-02-25,更改医嘱发送的计费状态
Create Or Replace Procedure Zl_病人划价收费_Insert
(
  No_In         门诊费用记录.No%Type,
  病人id_In     门诊费用记录.病人id%Type,
  病人来源_In   Number,
  付款方式_In   门诊费用记录.付款方式%Type,
  姓名_In       门诊费用记录.姓名%Type,
  性别_In       门诊费用记录.性别%Type,
  年龄_In       门诊费用记录.年龄%Type,
  病人科室id_In 门诊费用记录.病人科室id%Type,
  开单部门id_In 门诊费用记录.开单部门id%Type,
  开单人_In     门诊费用记录.开单人%Type,
  结帐id_In     门诊费用记录.结帐id%Type,
  发生时间_In   门诊费用记录.发生时间%Type,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  发药窗口_In   Varchar2 := Null,
  是否急诊_In   门诊费用记录.是否急诊%Type := 0,
  登记时间_In   门诊费用记录.登记时间%Type := Null
) As
  --功能：用于收费时收取划价单费用
  --参数：
  --      发药窗口_In:执行部门ID1|发药窗口1;...;执行部门IDn|发药窗口n

  --        病人来源_IN:1-门诊;2-住院
  --说明：
  --        1.收取划价费用时,才计算费用相关汇总,在划价时不处理;但药品相关汇总(姓名除外)划价时已经计算。
  --        2.收取划价费用时,目前界面及过程中未处理加收工本费,由划价时直接处理。
  --该游标为划价原单据内容
  Cursor c_Price Is
    Select ID
    From 门诊费用记录
    Where NO = No_In And 记录性质 = 1 And 记录状态 = 0 And 操作员姓名 Is Null
    Order By 序号;

  n_Array_Size Number := 200;
  t_费用id     t_Numlist;
  v_部门名称   部门表.名称%Type;

  v_标识号   门诊费用记录.标识号%Type;
  v_付款方式 医疗付款方式.名称%Type;

  --临时变量
  n_Count      Number;
  n_新病人模式 Number;
  v_出库no     药品收发记录.No%Type;
  v_Date       Date;
  v_Err_Msg    Varchar2(255);
  Err_Item Exception;
  n_组id 财务缴款分组.Id%Type;

Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  Select Count(ID)
  Into n_Count
  From 门诊费用记录
  Where 记录性质 = 1 And 记录状态 = 0 And NO = No_In And 操作员姓名 Is Null;
  If n_Count = 0 Then
    v_Err_Msg := '不能读取划价单内容,该单据可能已经删除或已经收费！';
    Raise Err_Item;
  End If;
  v_Date := 登记时间_In;
  If v_Date Is Null Then
    Select Sysdate Into v_Date From Dual;
  End If;
  If Nvl(病人id_In, 0) <> 0 Then
    Select Decode(当前科室id, Null, 门诊号, 住院号) Into v_标识号 From 病人信息 Where 病人id = 病人id_In;
  End If;

  ------------------------------------------------------------------------------------------------------------------------
  --批量更新
  Open c_Price;
  Loop
    Fetch c_Price Bulk Collect
      Into t_费用id Limit n_Array_Size;
    Exit When t_费用id.Count = 0;
  
    --循环处理门诊费用记录
    Forall I In 1 .. t_费用id.Count
    --执行状态相关字段不处理,在划价时处理;因为可能未收费发药,这种已执行的划价单是允许收费操作的。
    --为保证与预交结算记录的时间相同,重新填写登记时间,但药品部分不变动。
      Update 门诊费用记录
      Set 记录状态 = 1, 病人id = Decode(病人id_In, 0, Null, 病人id_In), 标识号 = v_标识号, 付款方式 = 付款方式_In, 姓名 = 姓名_In, 年龄 = 年龄_In,
          性别 = 性别_In,
          --可能保持医嘱发送的内容
          病人科室id = Nvl(病人科室id_In, 病人科室id), 开单部门id = Nvl(开单部门id_In, 开单部门id), 开单人 = Nvl(开单人_In, 开单人), 结帐金额 = 实收金额,
          结帐id = 结帐id_In, 发生时间 = 发生时间_In, 登记时间 = v_Date, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In, 是否急诊 = 是否急诊_In,
          缴款组id = n_组id, 费用状态 = 1, 执行状态 = Decode(Nvl(执行状态, 0), -1, Null, Nvl(执行状态, 0))
      Where ID = t_费用id(I) And 记录状态 = 0;
  
    If Sql%RowCount <> t_费用id.Count Then
      v_Err_Msg := '由于并发操作,该单据可能已经删除或已经收费！';
      Raise Err_Item;
    End If;
  
  End Loop;

  Close c_Price;

  --相关汇总表的处理
  --药品部分非费用信息的修改
  --药品未发记录(如果已发药则修改不到),分离发药时无库房ID
  --可能存在材料和药品库房相同，但材料无发药窗口
  Update 未发药品记录
  Set 病人id = Decode(病人id_In, 0, Null, 病人id_In), 姓名 = 姓名_In, 对方部门id = 开单部门id_In, 已收费 = 1, 填制日期 = v_Date
  Where 单据 = 24 And NO = No_In And
        Nvl(库房id, 0) In (Select Distinct Nvl(执行部门id, 0)
                         From 门诊费用记录
                         Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 = '4');

  Update 未发药品记录
  Set 病人id = Decode(病人id_In, 0, Null, 病人id_In), 姓名 = 姓名_In, 对方部门id = 开单部门id_In, 已收费 = 1, 填制日期 = v_Date
  Where 单据 = 8 And NO = No_In And
        Nvl(库房id, 0) In (Select Distinct Nvl(执行部门id, 0)
                         From 门诊费用记录
                         Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 In ('5', '6', '7'));

  --药品收发记录(可能已经发药或取消发药,所有记录更改)
  Update 药品收发记录
  Set 对方部门id = 开单部门id_In, 填制日期 = Decode(Sign(Nvl(审核日期, v_Date) - v_Date), -1, 填制日期, v_Date)
  Where 单据 = 24 And NO = No_In And
        费用id + 0 In (Select ID From 门诊费用记录 Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 = '4');

  -------------------------------------------------------------------------------------------
  --处理备货卫材
  n_Count := Null;
  Begin
    Select Count(*), Max(a.No)
    Into n_Count, v_出库no
    From 药品收发记录 A, 门诊费用记录 B
    Where a.费用id = b.Id And b.收费类别 = '4' And b.记录性质 = 1 And b.记录状态 = 1 And b.No = No_In And
          Instr(',8,9,10,21,24,25,26,', ',' || a.单据 || ',') > 0 And Rownum <= 1;
  Exception
    When Others Then
      Null;
  End;
  If Nvl(n_Count, 0) > 0 Then
    If Nvl(病人科室id_In, 0) <> 0 Then
      Select 名称 Into v_部门名称 From 部门表 Where ID = 病人科室id_In;
    End If;
    v_Err_Msg := LPad(' ', 4);
    v_Err_Msg := Substr('病人姓名:' || 姓名_In || v_Err_Msg || '性别:' || 性别_In || v_Err_Msg || '年龄' || 年龄_In || v_Err_Msg ||
                        '门诊号:' || Nvl(v_标识号, '') || v_Err_Msg || '病人科室:' || v_部门名称, 1, 100);
  
    Update 药品收发记录
    Set 对方部门id = 开单部门id_In, 填制日期 = Decode(Sign(Nvl(审核日期, v_Date) - v_Date), -1, 填制日期, v_Date), 摘要 = v_Err_Msg
    Where 单据 = 21 And NO = v_出库no And
          费用id + 0 In (Select ID From 门诊费用记录 Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 = '4');
  End If;

  Update 药品收发记录
  Set 对方部门id = 开单部门id_In, 填制日期 = Decode(Sign(Nvl(审核日期, v_Date) - v_Date), -1, 填制日期, v_Date)
  Where 单据 = 8 And NO = No_In And
        费用id + 0 In
        (Select ID From 门诊费用记录 Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 In ('5', '6', '7'));

  If Not 发药窗口_In Is Null Then
    --更新发药窗口
    For v_窗口 In (Select To_Number(C1) As C1, C2 From Table(f_Str2list2(发药窗口_In, ';', '|'))) Loop
    
      Update 门诊费用记录
      Set 发药窗口 = Nvl(v_窗口.C2, 发药窗口)
      Where NO = No_In And 记录性质 = 1 And 记录状态 = 1 And 执行部门id = Nvl(v_窗口.C1, 执行部门id) And 收费类别 In ('5', '6', '7');
    
      Update 药品收发记录
      Set 发药窗口 = Nvl(v_窗口.C2, 发药窗口)
      Where 单据 = 8 And NO = No_In And 库房id = Nvl(v_窗口.C1, 库房id) And
            费用id + 0 In (Select ID
                         From 门诊费用记录
                         Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 In ('5', '6', '7'));
    
      Update 未发药品记录
      Set 发药窗口 = Nvl(v_窗口.C2, 发药窗口)
      Where 单据 = 8 And NO = No_In And 库房id = Nvl(v_窗口.C1, 库房id) And
            Nvl(库房id, 0) In (Select Distinct Nvl(执行部门id, 0)
                             From 门诊费用记录
                             Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 In ('5', '6', '7'));
    
    End Loop;
  End If;

  --更新部份病人信息
  If 病人id_In Is Not Null Then
    If 付款方式_In Is Not Null And 病人来源_In = 1 Then
      Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In;
    End If;
    --通过划价单收费时不允许改费别,因为费用不允许变
    Update 病人信息
    Set 性别 = Decode(姓名, '新病人', Nvl(性别_In, 性别), 性别), 年龄 = Decode(姓名, '新病人', Nvl(年龄_In, 年龄), 年龄),
        姓名 = Decode(姓名, '新病人', 姓名_In, 姓名), 医疗付款方式 = Nvl(v_付款方式, 医疗付款方式)
    Where 病人id = 病人id_In;
    Select Zl_To_Number(Nvl(zl_GetSysParameter('自动产生姓名', '1111'), '0')) Into n_新病人模式 From Dual;
    If n_新病人模式 = 1 Then
    
      Update 病人挂号记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In
      Where 病人id = 病人id_In And 姓名 = '新病人';
    
      Update 门诊费用记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In, 付款方式 = 付款方式_In
      Where 病人id = 病人id_In And 姓名 = '新病人';
    End If;
  End If;

  --医嘱处理
  --场合_In    Integer:=0, --0:门诊;1-住院
  --性质_In    Integer:=1, --1-收费单;2-记帐单
  --操作_In    Integer:=0, --0:删除划价单;1-收费或记帐;2-退费或销帐
  --No_In      门诊费用记录.No%Type,
  --医嘱ids_In Varchar2 := Null
  Zl_医嘱发送_计费状态_Update(0, 1, 1, No_In);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人划价收费_Insert;
/

--94248:刘兴洪,2016-03-21,并发引起的预交余额不正确
--93623:刘兴洪,2016-02-25,更改医嘱发送的计费状态
Create Or Replace Procedure Zl_划价收费记录_Insert
(
  No_In            门诊费用记录.No%Type,
  病人id_In        门诊费用记录.病人id%Type,
  病人来源_In      Number,
  付款方式_In      门诊费用记录.付款方式%Type,
  姓名_In          门诊费用记录.姓名%Type,
  性别_In          门诊费用记录.性别%Type,
  年龄_In          门诊费用记录.年龄%Type,
  病人科室id_In    门诊费用记录.病人科室id%Type,
  开单部门id_In    门诊费用记录.开单部门id%Type,
  开单人_In        门诊费用记录.开单人%Type,
  收费结算_In      Varchar2,
  冲预交额_In      病人预交记录.冲预交%Type,
  保险结算_In      Varchar2,
  结帐id_In        门诊费用记录.结帐id%Type,
  发生时间_In      门诊费用记录.发生时间%Type,
  操作员编号_In    门诊费用记录.操作员编号%Type,
  操作员姓名_In    门诊费用记录.操作员姓名%Type,
  发药窗口_In      Varchar2,
  是否急诊_In      门诊费用记录.是否急诊%Type := 0,
  缴款_In          病人预交记录.缴款%Type := Null,
  找补_In          病人预交记录.找补%Type := Null,
  三方卡结算_In    Varchar2 := Null,
  登记时间_In      门诊费用记录.登记时间%Type := Null,
  结算序号_In      病人预交记录.结算序号%Type := Null,
  交易流水号_In    病人预交记录.交易流水号%Type := Null,
  交易说明_In      病人预交记录.交易说明%Type := Null,
  简单收费_In      Number := 0,
  冲预交病人ids_In Varchar2 := Null
) As
  --功能：用于收费时收取划价单费用
  --参数：
  --      发药窗口_In:执行部门ID1|发药窗口1;...;执行部门IDn|发药窗口n
  --        病人来源_IN:1-门诊;2-住院
  --        收费结算_IN:格式="结算方式|结算金额|结算号码|结算摘要||.....",注意无结算号码和摘要时要用空格填充
  --        保险结算_IN:格式="结算方式|结算金额||....."
  --        三方卡结算_In:格式=卡类别Id|是否消费卡|结算金额|卡号|备注||...
  --        交易流水号_In和交易说明_In:收费结算_IN时有效.
  --        冲预交病人ids_In:多个用逗分分离,冲预交时有效(冲预交类别与业务操作保持一致),主要是使用家属的预交款
  --说明：
  --        1.收取划价费用时,才计算费用相关汇总,在划价时不处理;但药品相关汇总(姓名除外)划价时已经计算。
  --        2.收取划价费用时,目前界面及过程中未处理加收工本费,由划价时直接处理。
  --该游标为划价原单据内容

  --=================================
  --备注：该过程目前只有简单收费使用！
  --=================================

  Cursor c_Price Is
    Select ID
    From 门诊费用记录
    Where NO = No_In And 记录性质 = 1 And 记录状态 = 0 And 操作员姓名 Is Null
    Order By 序号;

  n_Array_Size Number := 200;
  t_费用id     t_Numlist;
  v_部门名称   部门表.名称%Type;
  --该游标用于收费冲预交的可用预交列表(该SQL参考住院结帐)
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit
  (
    v_病人id        病人信息.病人id%Type,
    v_冲预交病人ids Varchar2
  ) Is
    Select *
    From (Select a.Id, a.病人id, a.记录状态, Nvl(a.预交类别, 2) As 预交类别, a.No, Nvl(a.金额, 0) As 金额
           From 病人预交记录 A,
                (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                  From 病人预交记录 A
                  Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And
                        a.病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And Nvl(预交类别, 2) = 1
                  Group By NO
                  Having Sum(Nvl(a.金额, 0)) <> 0) B
           Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.No = b.No And
                 a.病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And Nvl(a.预交类别, 2) = 1
           Union All
           Select 0 As ID, Max(病人id) As 病人id, 记录状态, Nvl(预交类别, 2) As 预交类别, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
           From 病人预交记录
           Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(预交类别, 2) = 1 And Nvl(金额, 0) <> Nvl(冲预交, 0) And
                 病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) Having
            Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
           Group By 记录状态, NO, Nvl(预交类别, 2))
    Order By Decode(病人id, Nvl(v_病人id, 0), 0, 1), ID, 预交类别 Desc, NO;

  --预交与结算相关变量
  n_预交金额 病人预交记录.冲预交%Type;
  v_结算内容 Varchar2(3000);
  v_当前结算 Varchar2(150);
  v_结算方式 病人预交记录.结算方式%Type;
  n_结算金额 病人预交记录.冲预交%Type;
  v_结算号码 病人预交记录.结算号码%Type;
  v_结算摘要 病人预交记录.摘要%Type;

  v_标识号        门诊费用记录.标识号%Type;
  v_付款方式      医疗付款方式.名称%Type;
  n_返回值        病人余额.预交余额%Type;
  v_冲预交病人ids Varchar2(4000);

  --临时变量
  n_Count      Number;
  n_新病人模式 Number;
  v_出库no     药品收发记录.No%Type;
  v_Date       Date;
  v_Err_Msg    Varchar2(255);
  Err_Item Exception;
  n_组id     财务缴款分组.Id%Type;
  n_卡类别id 医疗卡类别.Id%Type;
  n_消费卡   Number;
  v_卡号     病人预交记录.卡号%Type;
  v_卡名称   Varchar2(100);
  n_自制卡   Number;
  n_预交id   病人预交记录.Id%Type;
  n_消费卡id 消费卡目录.Id%Type;
  n_金额     病人预交记录.金额%Type;
Begin
  n_组id          := Zl_Get组id(操作员姓名_In);
  v_冲预交病人ids := Nvl(冲预交病人ids_In, 病人id_In);

  Select Count(ID)
  Into n_Count
  From 门诊费用记录
  Where 记录性质 = 1 And 记录状态 = 0 And NO = No_In And 操作员姓名 Is Null;
  If n_Count = 0 Then
    v_Err_Msg := '不能读取划价单内容,该单据可能已经删除或已经收费！';
    Raise Err_Item;
  End If;
  v_Date := 登记时间_In;
  If v_Date Is Null Then
    Select Sysdate Into v_Date From Dual;
  End If;
  If Nvl(病人id_In, 0) <> 0 Then
    Select Decode(当前科室id, Null, 门诊号, 住院号) Into v_标识号 From 病人信息 Where 病人id = 病人id_In;
  End If;

  ------------------------------------------------------------------------------------------------------------------------
  --批量更新
  Open c_Price;
  Loop
    Fetch c_Price Bulk Collect
      Into t_费用id Limit n_Array_Size;
    Exit When t_费用id.Count = 0;
  
    --循环处理门诊费用记录
    Forall I In 1 .. t_费用id.Count
    --执行状态相关字段不处理,在划价时处理;因为可能未收费发药,这种已执行的划价单是允许收费操作的。
    --为保证与预交结算记录的时间相同,重新填写登记时间,但药品部分不变动。
      Update 门诊费用记录
      Set 记录状态 = 1, 病人id = Decode(病人id_In, 0, Null, 病人id_In), 标识号 = v_标识号, 付款方式 = 付款方式_In, 姓名 = 姓名_In, 年龄 = 年龄_In,
          性别 = 性别_In,
          --可能保持医嘱发送的内容
          病人科室id = Nvl(病人科室id_In, 病人科室id), 开单部门id = Nvl(开单部门id_In, 开单部门id), 开单人 = Nvl(开单人_In, 开单人), 结帐金额 = 实收金额,
          结帐id = 结帐id_In, 发生时间 = 发生时间_In, 登记时间 = v_Date, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In, 是否急诊 = 是否急诊_In,
          缴款组id = n_组id
      Where ID = t_费用id(I) And 记录状态 = 0;
  
    If Sql%RowCount <> t_费用id.Count Then
      v_Err_Msg := '由于并发操作,该单据可能已经删除或已经收费！';
      Raise Err_Item;
    End If;
  
  End Loop;
  Close c_Price;
  ------------------------------------------------------------------------------------------------------------------------

  --预交款相关结算
  --收费结算
  If 收费结算_In Is Not Null Then
    v_结算内容 := 收费结算_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If Nvl(n_结算金额, 0) <> 0 Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款, 找补, 缴款组id, 结算序号, 交易流水号,
           交易说明, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, No_In, 1, Decode(病人id_In, 0, Null, 病人id_In), Null, v_结算摘要, v_结算方式, v_结算号码, v_Date,
           操作员编号_In, 操作员姓名_In, n_结算金额, 结帐id_In, Decode(v_结算内容, 收费结算_In || '||', 缴款_In, Null),
           Decode(v_结算内容, 收费结算_In || '||', 找补_In, Null), n_组id, 结算序号_In, 交易流水号_In, 交易说明_In, 3);
      End If;
    
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If 保险结算_In Is Not Null Then
    --各个保险结算
    v_结算内容 := 保险结算_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
    
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If Nvl(n_结算金额, 0) <> 0 Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, No_In, 1, Decode(病人id_In, 0, Null, 病人id_In), '保险结算', v_结算方式, v_Date, 操作员编号_In,
           操作员姓名_In, n_结算金额, 结帐id_In, n_组id, 结算序号_In, 3);
      End If;
    
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If 三方卡结算_In Is Not Null Then
    v_结算内容 := 三方卡结算_In || '||';
    While v_结算内容 Is Not Null Loop
      --卡类别Id|是否消费卡|结算金额|卡号|备注||...
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      n_卡类别id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_消费卡   := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_卡号     := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算摘要 := v_当前结算;
    
      If n_消费卡 = 1 Then
        Select 结算方式, 名称, Nvl(自制卡, 0)
        Into v_结算方式, v_卡名称, n_自制卡
        From 卡消费接口目录
        Where 编号 = n_卡类别id;
        If v_结算方式 Is Null Then
          v_Err_Msg := v_卡名称 || '未设置结算方式对照,请在消费卡中进行设置,结算失败！';
          Raise Err_Item;
        End If;
      Else
        Select 结算方式, 名称 Into v_结算方式, v_卡名称 From 医疗卡类别 Where ID = n_卡类别id;
        If v_结算方式 Is Null Then
          v_Err_Msg := v_卡名称 || '未设置结算方式对照,请在医疗卡管理中进行设置,结算失败！';
          Raise Err_Item;
        End If;
      End If;
      If Nvl(n_结算金额, 0) <> 0 Then
        Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 卡类别id, 结算卡序号, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款, 找补, 缴款组id,
           结算序号, 卡号, 结算性质)
        Values
          (n_预交id, 3, No_In, 1, Decode(病人id_In, 0, Null, 病人id_In), Null, v_结算摘要, Decode(n_消费卡, 1, Null, n_卡类别id),
           Decode(n_消费卡, 0, Null, n_卡类别id), v_结算方式, v_结算号码, v_Date, 操作员编号_In, 操作员姓名_In, n_结算金额, 结帐id_In, Null, Null,
           n_组id, 结算序号_In, v_卡号, 3);
      
        --卡结算对照
        If n_消费卡 = 1 Then
          n_消费卡id := Null;
          If n_自制卡 = 1 Then
            Select ID
            Into n_消费卡id
            From 消费卡目录
            Where 接口编号 = n_卡类别id And 卡号 = v_卡号 And
                  序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = n_卡类别id And 卡号 = v_卡号);
          End If;
          Zl_病人卡结算记录_Insert(n_卡类别id, n_消费卡id, v_结算方式, n_结算金额, v_卡号, Null, Null, v_结算摘要, 结帐id_In, n_预交id);
        End If;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --预交结算
  If Nvl(冲预交额_In, 0) <> 0 Then
    If Nvl(病人id_In, 0) = 0 Then
      v_Err_Msg := '不能确定病人信息,收费使用预交款结算失败！';
      Raise Err_Item;
    End If;
    --病人余额检查
    Begin
      Select Sum(Nvl(预交余额, 0) - Nvl(费用余额, 0))
      Into n_预交金额
      From 病人余额
      Where 病人id = 病人id_In And Nvl(性质, 0) = 1 And 类型 = 1;
    Exception
      When Others Then
        n_预交金额 := 0;
    End;
  
    If n_预交金额 < 冲预交额_In Then
      v_Err_Msg := '病人的当前预交余额为 ' || LTrim(To_Char(n_预交金额, '9999999990.00')) || '，小于本次支付金额 ' ||
                   LTrim(To_Char(冲预交额_In, '9999999990.00')) || '，支付失败！';
      Raise Err_Item;
    End If;
  
    n_预交金额 := 冲预交额_In;
    For r_Deposit In c_Deposit(病人id_In, v_冲预交病人ids) Loop
    
      n_金额 := Case
                When r_Deposit.金额 - n_预交金额 < 0 Then
                 r_Deposit.金额
                Else
                 n_预交金额
              End;
      If r_Deposit.Id <> 0 Then
        --第一次冲预交(填上结帐ID,金额为0)
        Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 3 Where ID = r_Deposit.Id;
      End If;
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 登记时间_In,
               操作员姓名_In, 操作员编号_In, n_金额, 结帐id_In, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 3
        From 病人预交记录
        Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
    
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - n_金额
      Where 病人id = r_Deposit.病人id And 性质 = 1 And 类型 = Nvl(r_Deposit.预交类别, 2)
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 预交余额, 类型, 性质)
        Values
          (r_Deposit.病人id, -n_金额, Nvl(r_Deposit.预交类别, 2), 1);
        n_返回值 := -n_金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Deposit.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --检查是否已经处理完
      If r_Deposit.金额 < n_预交金额 Then
        n_预交金额 := n_预交金额 - r_Deposit.金额;
      Else
        n_预交金额 := 0;
      End If;
      If n_预交金额 = 0 Then
        Exit;
      End If;
    End Loop;
    --检查金额是否足够
    If n_预交金额 > 0 Then
      v_Err_Msg := '病人的当前预交余额不足金额 ' || LTrim(To_Char(冲预交额_In, '9999999990.00')) || ' ！';
      Raise Err_Item;
    End If;
  
  End If;

  --相关汇总表的处理

  --汇总"人员缴款余额"
  --收费结算
  n_返回值 := 0;
  If 收费结算_In Is Not Null Then
    v_结算内容 := 收费结算_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      If Nvl(n_结算金额, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + Nvl(n_结算金额, 0)
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
        Returning Nvl(余额, 0) + n_返回值 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (操作员姓名_In, v_结算方式, 1, Nvl(n_结算金额, 0));
          n_返回值 := Nvl(n_返回值, 0) + Nvl(n_结算金额, 0);
        End If;
      
      End If;
    
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --各个保险结算
  If 保险结算_In Is Not Null Then
    v_结算内容 := 保险结算_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
    
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If Nvl(n_结算金额, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + Nvl(n_结算金额, 0)
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
        Returning Nvl(余额, 0) + n_返回值 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (操作员姓名_In, v_结算方式, 1, Nvl(n_结算金额, 0));
          n_返回值 := Nvl(n_返回值, 0) + Nvl(n_结算金额, 0);
        End If;
      End If;
    
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If 三方卡结算_In Is Not Null Then
    v_结算内容 := 三方卡结算_In || '||';
    While v_结算内容 Is Not Null Loop
      --卡类别Id|是否消费卡|结算金额|卡号|备注||...
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      n_卡类别id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_消费卡   := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_卡号     := Substr(v_当前结算, 1, Instr(v_当前结算, '|') + 1);
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算摘要 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    
      If n_消费卡 = 1 Then
        Select 结算方式, 名称, Nvl(自制卡, 0)
        Into v_结算方式, v_卡名称, n_自制卡
        From 卡消费接口目录
        Where 编号 = n_卡类别id;
        If v_结算方式 Is Null Then
          v_Err_Msg := v_卡名称 || '未设置结算方式对照,请在消费卡中进行设置,结算失败！';
          Raise Err_Item;
        End If;
      Else
        Select 结算方式, 名称 Into v_结算方式, v_卡名称 From 医疗卡类别 Where ID = n_卡类别id;
        If v_结算方式 Is Null Then
          v_Err_Msg := v_卡名称 || '未设置结算方式对照,请在医疗卡管理中进行设置,结算失败！';
          Raise Err_Item;
        End If;
      End If;
    
      If Nvl(n_结算金额, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + Nvl(n_结算金额, 0)
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
        Returning Nvl(余额, 0) + n_返回值 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (操作员姓名_In, v_结算方式, 1, Nvl(n_结算金额, 0));
          n_返回值 := Nvl(n_返回值, 0) + Nvl(n_结算金额, 0);
        End If;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If Nvl(n_返回值, 0) = 0 Then
    Delete From 人员缴款余额 Where 性质 = 1 And 收款员 = 操作员姓名_In And Nvl(余额, 0) = 0;
  End If;

  --药品部分非费用信息的修改
  --药品未发记录(如果已发药则修改不到),分离发药时无库房ID
  --可能存在材料和药品库房相同，但材料无发药窗口
  Update 未发药品记录
  Set 病人id = Decode(病人id_In, 0, Null, 病人id_In), 姓名 = 姓名_In, 对方部门id = 开单部门id_In, 已收费 = 1, 填制日期 = v_Date
  Where 单据 = 24 And NO = No_In And
        Nvl(库房id, 0) In (Select Distinct Nvl(执行部门id, 0)
                         From 门诊费用记录
                         Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 = '4');

  Update 未发药品记录
  Set 病人id = Decode(病人id_In, 0, Null, 病人id_In), 姓名 = 姓名_In, 对方部门id = 开单部门id_In, 已收费 = 1, 填制日期 = v_Date
  Where 单据 = 8 And NO = No_In And
        Nvl(库房id, 0) In (Select Distinct Nvl(执行部门id, 0)
                         From 门诊费用记录
                         Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 In ('5', '6', '7'));

  --药品收发记录(可能已经发药或取消发药,所有记录更改)
  Update 药品收发记录
  Set 对方部门id = 开单部门id_In, 填制日期 = Decode(Sign(Nvl(审核日期, v_Date) - v_Date), -1, 填制日期, v_Date)
  Where 单据 = 24 And NO = No_In And
        费用id + 0 In (Select ID From 门诊费用记录 Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 = '4');

  -------------------------------------------------------------------------------------------
  --处理备货卫材
  n_Count := Null;
  Begin
    Select Count(*), Max(a.No)
    Into n_Count, v_出库no
    From 药品收发记录 A, 门诊费用记录 B
    Where a.费用id = b.Id And b.收费类别 = '4' And b.记录性质 = 1 And b.记录状态 = 1 And
          Instr(',8,9,10,21,24,25,26,', ',' || a.单据 || ',') > 0 And b.No = No_In And Rownum <= 1;
  Exception
    When Others Then
      Null;
  End;
  If Nvl(n_Count, 0) > 0 Then
    If Nvl(病人科室id_In, 0) <> 0 Then
      Select 名称 Into v_部门名称 From 部门表 Where ID = 病人科室id_In;
    End If;
    v_Err_Msg := LPad(' ', 4);
    v_Err_Msg := Substr('病人姓名:' || 姓名_In || v_Err_Msg || '性别:' || 性别_In || v_Err_Msg || '年龄' || 年龄_In || v_Err_Msg ||
                        '门诊号:' || Nvl(v_标识号, '') || v_Err_Msg || '病人科室:' || v_部门名称, 1, 100);
  
    Update 药品收发记录
    Set 对方部门id = 开单部门id_In, 填制日期 = Decode(Sign(Nvl(审核日期, v_Date) - v_Date), -1, 填制日期, v_Date), 摘要 = v_Err_Msg
    Where 单据 = 21 And NO = v_出库no And
          费用id + 0 In (Select ID From 门诊费用记录 Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 = '4');
  End If;

  Update 药品收发记录
  Set 对方部门id = 开单部门id_In, 填制日期 = Decode(Sign(Nvl(审核日期, v_Date) - v_Date), -1, 填制日期, v_Date)
  Where 单据 = 8 And NO = No_In And
        费用id + 0 In
        (Select ID From 门诊费用记录 Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 In ('5', '6', '7'));
  If Not 发药窗口_In Is Null Then
    --更新发药窗口
    If Nvl(简单收费_In, 0) <> 0 Then
      Update 门诊费用记录
      Set 发药窗口 = 发药窗口_In
      Where NO = No_In And 记录性质 = 1 And 记录状态 = 1 And 收费类别 = 'Z';
    Else
      For v_窗口 In (Select To_Number(C1) As C1, C2 From Table(f_Str2list2(发药窗口_In, ';', '|'))) Loop
        Update 门诊费用记录
        Set 发药窗口 = Nvl(v_窗口.C2, 发药窗口)
        Where NO = No_In And 记录性质 = 1 And 记录状态 = 1 And 执行部门id = Nvl(v_窗口.C1, 执行部门id) And 收费类别 In ('5', '6', '7');
      
        Update 药品收发记录
        Set 发药窗口 = Nvl(v_窗口.C2, 发药窗口)
        Where 单据 = 8 And NO = No_In And 库房id = Nvl(v_窗口.C1, 库房id) And
              费用id + 0 In (Select ID
                           From 门诊费用记录
                           Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 In ('5', '6', '7'));
      
        Update 未发药品记录
        Set 发药窗口 = Nvl(v_窗口.C2, 发药窗口)
        Where 单据 = 8 And NO = No_In And 库房id = Nvl(v_窗口.C1, 库房id) And
              Nvl(库房id, 0) In (Select Distinct Nvl(执行部门id, 0)
                               From 门诊费用记录
                               Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 In ('5', '6', '7'));
      End Loop;
    End If;
  End If;

  --更新部份病人信息
  If 病人id_In Is Not Null Then
    If 付款方式_In Is Not Null And 病人来源_In = 1 Then
      Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In;
    End If;
    --通过划价单收费时不允许改费别,因为费用不允许变
    Update 病人信息
    Set 性别 = Nvl(性别_In, 性别), 年龄 = Nvl(年龄_In, 年龄), 姓名 = Decode(姓名, '新病人', 姓名_In, 姓名), 医疗付款方式 = Nvl(v_付款方式, 医疗付款方式)
    Where 病人id = 病人id_In;
    Select Zl_To_Number(Nvl(zl_GetSysParameter('自动产生姓名', '1111'), '0')) Into n_新病人模式 From Dual;
    If n_新病人模式 = 1 Then
    
      Update 病人挂号记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In
      Where 病人id = 病人id_In And 姓名 = '新病人';
    
      Update 门诊费用记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In, 付款方式 = 付款方式_In
      Where 病人id = 病人id_In And 姓名 = '新病人';
    End If;
  End If;
  --医嘱处理
  --场合_In    Integer:=0, --0:门诊;1-住院
  --性质_In    Integer:=1, --1-收费单;2-记帐单
  --操作_In    Integer:=0, --0:删除划价单;1-收费或记帐;2-退费或销帐
  --No_In      门诊费用记录.No%Type,
  --医嘱ids_In Varchar2 := Null
  Zl_医嘱发送_计费状态_Update(0, 1, 1, No_In);

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_划价收费记录_Insert;
/

--93623:刘兴洪,2016-02-25,更改医嘱发送的计费状态
Create Or Replace Procedure Zl_门诊记帐记录_Delete
(
  No_In         门诊费用记录.No%Type,
  序号_In       Varchar2,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type
) As
  --功能：冲销一张门诊记帐单据中指定序号行
  --序号：格式如"1,3,5,7,8",为空表示冲销所有可冲销行
  --该光标用于销帐指定费用行

  --该游标为要退费单据的所有原始记录
  Cursor c_Bill(n_标志 Number) Is
    Select a.Id, a.价格父号, a.序号, a.执行状态, a.收费类别, a.医嘱序号, a.病人id, a.收入项目id, a.开单部门id, a.执行部门id, a.病人科室id, a.实收金额,
           Decode(a.记录状态, 0, 1, 0) As 划价, j.诊疗类别, m.跟踪在用
    From 门诊费用记录 A, 病人医嘱记录 J, 材料特性 M
    Where a.医嘱序号 = j.Id(+) And a.收费细目id + 0 = m.材料id(+) And a.No = No_In And a.记录性质 = 2 And a.记录状态 In (0, 1, 3) And
          a.门诊标志 = n_标志
    Order By a.收费细目id, a.序号;

  --该游标用于处理费用记录序号
  Cursor c_Serial Is
    Select 序号, 价格父号 From 门诊费用记录 Where NO = No_In And 记录性质 = 2 And 记录状态 In (0, 1, 3) Order By 序号;
  l_划价 t_Numlist := t_Numlist();

  n_医嘱id   病人医嘱记录.Id%Type;
  v_医嘱ids  Varchar2(4000);
  n_父号     门诊费用记录.价格父号%Type;
  n_门诊标志 门诊费用记录.门诊标志%Type;

  --部分退费计算变量
  n_剩余数量 Number;
  n_剩余应收 Number;
  n_剩余实收 Number;
  n_剩余统筹 Number;

  n_准退数量 Number;
  n_退费次数 Number;

  n_应收金额 Number;
  n_实收金额 Number;
  n_统筹金额 Number;

  n_Dec Number;

  n_Count   Number;
  d_Curdate Date;
  Err_Item Exception;
  v_Err_Msg Varchar2(255);
Begin
  --是否已经全部完全执行(只是整张单据的检查)
  Select Nvl(Count(*), 0), Max(Nvl(门诊标志, 1))
  Into n_Count, n_门诊标志
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 2 And 记录状态 In (0, 1, 3) And Nvl(执行状态, 0) <> 1;
  If n_Count = 0 Then
    v_Err_Msg := '该单据中的项目已经全部完全执行！';
    Raise Err_Item;
  End If;

  If Nvl(n_门诊标志, 0) = 0 Then
    n_门诊标志 := 1;
  End If;

  --未完全执行的项目是否有剩余数量(只是整张单据的检查)
  Select Nvl(Count(*), 0)
  Into n_Count
  From (Select 序号, Sum(数量) As 剩余数量
         From (Select 记录状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                From 门诊费用记录
                Where NO = No_In And 记录性质 = 2 And 门诊标志 = n_门诊标志 And
                      Nvl(价格父号, 序号) In
                      (Select Nvl(价格父号, 序号)
                       From 门诊费用记录
                       Where NO = No_In And 记录性质 = 2 And 门诊标志 = n_门诊标志 And 记录状态 In (0, 1, 3) And Nvl(执行状态, 0) <> 1)
                Group By 记录状态, Nvl(价格父号, 序号))
         Group By 序号
         Having Sum(数量) <> 0);
  If n_Count = 0 Then
    v_Err_Msg := '该单据中未完全执行部分项目剩余数量为零,没有可以销帐的费用！';
    Raise Err_Item;
  End If;

  ---------------------------------------------------------------------------------
  --公用变量
  Select Sysdate Into d_Curdate From Dual;

  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into n_Dec From Dual;

  --循环处理每行费用(收入项目行)
  For r_Bill In c_Bill(n_门诊标志) Loop
    If Instr(',' || 序号_In || ',', ',' || Nvl(r_Bill.价格父号, r_Bill.序号) || ',') > 0 Or 序号_In Is Null Then
    
      If r_Bill.划价 = 0 Then
        If Nvl(r_Bill.执行状态, 0) <> 1 Then
          --求剩余数量,剩余应收,剩余实收
          Select Sum(Nvl(付数, 1) * 数次), Sum(应收金额), Sum(实收金额), Sum(统筹金额)
          Into n_剩余数量, n_剩余应收, n_剩余实收, n_剩余统筹
          From 门诊费用记录
          Where NO = No_In And 记录性质 = 2 And 序号 = r_Bill.序号;
        
          If n_剩余数量 = 0 Then
            If 序号_In Is Not Null Then
              v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经全部销帐！';
              Raise Err_Item;
            End If;
            --情况：未限定行号,原始单据中的该笔已经全部销帐(执行状态=0的一种可能)
          Else
            --准销数量(非药品项目为剩余数量,原始数量)
            If Instr(',4,5,6,7,', r_Bill.收费类别) = 0 Or (r_Bill.收费类别 = '4' And Nvl(r_Bill.跟踪在用, 0) = 0) Then
            
              --@@@
              --非药品部分(以具体医嘱执行为准进行检查)
              --: 1.存在医嘱发送的,则以医嘱执行为准(但不能包含:检查;检验;手术;麻醉及输血)
              --: 2.对于病人医吃计价中的收费方式为:0-正常收取 的,才支持部分退;如果是其他的,则只能全退
              --: 3.不存在医嘱的,则以剩余数量为准
              n_Count := 0;
              If Instr(',C,D,F,G,K,', ',' || r_Bill.诊疗类别 || ',') = 0 And r_Bill.诊疗类别 Is Not Null Then
              
                Select Nvl(Sum(数量), 0), Count(*)
                Into n_准退数量, n_Count
                From (Select j.医嘱序号 As 医嘱id, j.收费细目id, Nvl(j.付数, 1) * Nvl(j.数次, 1) As 数量
                       From 门诊费用记录 J, 病人医嘱记录 M
                       Where j.医嘱序号 = m.Id And j.No = No_In And j.记录性质 = 2 And j.序号 = r_Bill.序号 And j.记录状态 In (1, 3) And
                             Exists
                        (Select 1
                              From 病人医嘱发送 A
                              Where a.医嘱id = j.医嘱序号 And Nvl(a.执行状态, 0) <> 1 And a.No || '' = No_In) And Exists
                        (Select 1
                              From 病人医嘱计价 A
                              Where a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And Nvl(a.收费方式, 0) = 0) And j.价格父号 Is Null And
                             Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                             (j.记录状态 In (1, 3) And Not Exists
                              (Select 1
                               From 药品收发记录
                               Where 费用id = j.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0) Or
                              j.记录状态 = 2 And Not Exists
                              (Select 1 From 药品收发记录 Where NO = No_In And 单据 In (8, 24) And 药品id = j.收费细目id))
                       Union All
                       Select a.医嘱id, a.收费细目id, -1 * Nvl(a.数量, 1) * Nvl(c.本次数次, 1) As 数量
                       From 病人医嘱计价 A, 病人医嘱发送 B, 病人医嘱执行 C, 门诊费用记录 J, 病人医嘱记录 M
                       Where a.医嘱id = b.医嘱id And b.医嘱id = c.医嘱id And Nvl(a.收费方式, 0) = 0 And b.发送号 = c.发送号 And
                             a.医嘱id = m.Id And Nvl(c.执行结果, 1) = 1 And Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And
                             a.收费细目id = j.收费细目id And j.No = No_In And j.记录性质 = 2 And j.序号 = r_Bill.序号 And
                             j.记录状态 In (1, 3) And j.价格父号 Is Null And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                             Not Exists
                        (Select 1
                              From 药品收发记录
                              Where 费用id = j.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0) And Not Exists
                        (Select 1 From 材料特性 Where 材料id = j.收费细目id And Nvl(跟踪在用, 0) = 1)
                       Union All
                       Select a.医嘱id, a.收费细目id, 0 As 数量
                       From 病人医嘱计价 A, 门诊费用记录 J, 病人医嘱记录 M
                       Where a.医嘱id = m.Id And a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And Nvl(a.收费方式, 0) <> 0 And
                             j.No = No_In And j.记录性质 = 2 And Nvl(j.执行状态, 0) = 2 And Not Exists
                        (Select 1 From 材料特性 Where 材料id = j.收费细目id And Nvl(跟踪在用, 0) = 1) And
                             Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0);
              
              End If;
            
              If Nvl(n_Count, 0) = 0 Then
                n_准退数量 := n_剩余数量;
              End If;
            
            Else
              Select Sum(Nvl(付数, 1) * 实际数量)
              Into n_准退数量
              From 药品收发记录
              Where NO = No_In And 单据 In (9, 25) And Mod(记录状态, 3) = 1 And 审核人 Is Null And 费用id = r_Bill.Id;
            
              --不跟踪在用的卫生材料
              If r_Bill.收费类别 = '4' And Nvl(n_准退数量, 0) = 0 Then
                n_准退数量 := n_剩余数量;
              End If;
            End If;
          
            --处理门诊费用记录
          
            --该笔项目第几次销帐
            Select Nvl(Max(Abs(执行状态)), 0) + 1
            Into n_退费次数
            From 门诊费用记录
            Where NO = No_In And 记录性质 = 2 And 记录状态 = 2 And 序号 = r_Bill.序号;
          
            --金额=剩余金额*(准退数/剩余数)
            n_应收金额 := Round(n_剩余应收 * (n_准退数量 / n_剩余数量), n_Dec);
            n_实收金额 := Round(n_剩余实收 * (n_准退数量 / n_剩余数量), n_Dec);
            n_统筹金额 := Round(n_剩余统筹 * (n_准退数量 / n_剩余数量), n_Dec);
          
            --插入退费记录
            Insert Into 门诊费用记录
              (ID, NO, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 婴儿费, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别,
               收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人,
               执行人, 执行状态, 执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 保险项目否, 保险大类id, 统筹金额, 记帐单id, 摘要, 保险编码, 是否急诊, 结论)
              Select 病人费用记录_Id.Nextval, NO, 记录性质, 2, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 婴儿费, 姓名, 性别, 年龄, 标识号, 付款方式, 费别,
                     病人科室id, 收费类别, 收费细目id, 计算单位, Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, 付数, 1), 发药窗口,
                     Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, -1 * 数次, -1 * n_准退数量), 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用,
                     标准单价, -1 * n_应收金额, -1 * n_实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, -1 * n_退费次数, 执行时间, 操作员编号_In,
                     操作员姓名_In, 发生时间, d_Curdate, 保险项目否, 保险大类id, -1 * n_统筹金额, 记帐单id, 摘要, 保险编码, 是否急诊, 结论
              From 门诊费用记录
              Where ID = r_Bill.Id;
          
            --记录病人医嘱附费对应的医嘱ID(不是主费用)
            If n_医嘱id Is Null And r_Bill.医嘱序号 Is Not Null Then
              n_医嘱id := r_Bill.医嘱序号;
            End If;
          
            --病人余额
            If n_门诊标志 <> 4 Then
              Update 病人余额
              Set 费用余额 = Nvl(费用余额, 0) - n_实收金额
              Where 病人id = r_Bill.病人id And 性质 = 1 And 类型 = 1;
              If Sql%RowCount = 0 Then
                Insert Into 病人余额
                  (病人id, 性质, 类型, 费用余额, 预交余额)
                Values
                  (r_Bill.病人id, 1, 1, -1 * n_实收金额, 0);
              End If;
            End If;
          
            --病人未结费用
            Update 病人未结费用
            Set 金额 = Nvl(金额, 0) - n_实收金额
            Where 病人id = r_Bill.病人id And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And
                  Nvl(病人科室id, 0) = Nvl(r_Bill.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(r_Bill.开单部门id, 0) And
                  Nvl(执行部门id, 0) = Nvl(r_Bill.执行部门id, 0) And 收入项目id + 0 = r_Bill.收入项目id And 来源途径 + 0 = n_门诊标志;
            If Sql%RowCount = 0 Then
              Insert Into 病人未结费用
                (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
              Values
                (r_Bill.病人id, Null, Null, r_Bill.病人科室id, r_Bill.开单部门id, r_Bill.执行部门id, r_Bill.收入项目id, n_门诊标志,
                 -1 * n_实收金额);
            End If;
          
            --标记原费用记录
            --执行状态:全部退完(准退数=剩余数)标记为0,否则标记为1
            Update 门诊费用记录
            Set 记录状态 = 3, 执行状态 = Decode(Sign(n_准退数量 - n_剩余数量), 0, 0, 1)
            Where ID = r_Bill.Id;
          End If;
        Else
          If 序号_In Is Not Null Then
            v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经完全执行,不能销帐！';
            Raise Err_Item;
          End If;
          --情况:没限定行号,原始单据中包括已经完全执行的
        End If;
      End If;
    End If;
  End Loop;

  ---------------------------------------------------------------------------------
  --药品相关内容
  For r_Expenses In (Select ID
                     From 门诊费用记录
                     Where NO = No_In And 记录性质 = 2 And 记录状态 In (0, 1, 3) And 收费类别 In ('4', '5', '6', '7') And
                           门诊标志 = n_门诊标志 And (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null)) Loop
    Zl_药品收发记录_销售退费(r_Expenses.Id);
  End Loop;

  ---------------------------------------------------------------------------------
  --如果是划价,直接删除费用记录(药品处理后)
  n_Count   := 0;
  v_医嘱ids := Null;
  For r_Bill In c_Bill(n_门诊标志) Loop
    If Instr(',' || 序号_In || ',', ',' || Nvl(r_Bill.价格父号, r_Bill.序号) || ',') > 0 Or 序号_In Is Null Then
      If r_Bill.划价 = 1 Then
        If Nvl(r_Bill.执行状态, 0) <> 1 Then
          l_划价.Extend;
          l_划价(l_划价.Count) := r_Bill.Id;
        
          --Delete From 门诊费用记录 Where ID = r_Bill.ID;
          n_Count := n_Count + 1; --记录是否有删除行
        
          If r_Bill.医嘱序号 Is Not Null Then
            If Instr(',' || Nvl(v_医嘱ids, '') || ',', ',' || r_Bill.医嘱序号 || ',') = 0 Then
              v_医嘱ids := Nvl(v_医嘱ids, '') || ',' || r_Bill.医嘱序号;
            End If;
          
            --记录病人医嘱附费对应的医嘱ID(不是主费用)
            If n_医嘱id Is Null Then
              n_医嘱id := r_Bill.医嘱序号;
            End If;
          End If;
        Else
          If 序号_In Is Not Null Then
            v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经完全执行,不能销帐！';
            Raise Err_Item;
          End If;
          --情况:没限定行号,原始单据中包括已经完全执行的
        End If;
      End If;
    End If;
  End Loop;

  --删除划价记录
  Forall I In 1 .. l_划价.Count
    Delete From 门诊费用记录 Where ID = l_划价(I);

  --删除之后再统一调整序号
  If n_Count > 0 Then
    n_Count := 1;
    For r_Serial In c_Serial Loop
      If r_Serial.价格父号 Is Null Then
        n_父号 := n_Count;
      End If;
    
      Update 门诊费用记录
      Set 序号 = n_Count, 价格父号 = Decode(价格父号, Null, Null, n_父号)
      Where NO = No_In And 记录性质 = 2 And 序号 = r_Serial.序号;
    
      Update 门诊费用记录 Set 从属父号 = n_Count Where NO = No_In And 记录性质 = 2 And 从属父号 = r_Serial.序号;
    
      n_Count := n_Count + 1;
    End Loop;
  End If;

  --整张单据全部冲完时，删除病人医嘱附费
  If 序号_In Is Null And n_医嘱id Is Not Null Then
    Select Nvl(Count(*), 0)
    Into n_Count
    From (Select 序号, Sum(数量) As 剩余数量
           From (Select 记录状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                  From 门诊费用记录
                  Where NO = No_In And 记录性质 = 2 And 医嘱序号 + 0 = n_医嘱id
                  Group By 记录状态, Nvl(价格父号, 序号))
           Group By 序号
           Having Nvl(Sum(数量), 0) <> 0);
    If n_Count = 0 Then
      Delete From 病人医嘱附费 Where 医嘱id = n_医嘱id And 记录性质 = 2 And NO = No_In;
    End If;
  End If;

  If v_医嘱ids Is Not Null Then
    --医嘱处理
    --场合_In    Integer:=0, --0:门诊;1-住院
    --性质_In    Integer:=1, --1-收费单;2-记帐单
    --操作_In    Integer:=0, --0:删除划价单;1-收费或记帐;2-退费或销帐
    --No_In      门诊费用记录.No%Type,
    --医嘱ids_In Varchar2 := Null
    v_医嘱ids := Substr(v_医嘱ids, 2);
    Zl_医嘱发送_计费状态_Update(0, 2, 0, No_In, v_医嘱ids);
  Else
    Zl_医嘱发送_计费状态_Update(0, 2, 2, No_In, v_医嘱ids);
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊记帐记录_Delete;
/

--93623:刘兴洪,2016-02-25,更改医嘱发送的计费状态
Create Or Replace Procedure Zl_门诊收费记录_Delete
(
  No_In           门诊费用记录.No%Type,
  操作员编号_In   门诊费用记录.操作员编号%Type,
  操作员姓名_In   门诊费用记录.操作员姓名%Type,
  医保结算方式_In Varchar2 := Null,
  序号_In         Varchar2 := Null,
  结算方式_In     病人预交记录.结算方式%Type := Null,
  误差_In         门诊费用记录.实收金额%Type := 0,
  退费时间_In     门诊费用记录.登记时间%Type := Null,
  回收票据_In     Number := 0,
  退费摘要_In     门诊费用记录.摘要%Type := Null,
  校对标志_In     Number := 0,
  结帐id_In       病人预交记录.结帐id%Type := Null,
  结算序号_In     病人预交记录.结算序号%Type := Null,
  一卡通结算_In   Varchar2 := Null,
  退款操作_In     Number := 0,
  多单据全退_In   Number := 0
) As
  --功能：删除一张门诊收费单据
  --参数：
  --        医保结算方式_IN   =医保退费时,不支持结算作废的结算方式,如果为空表示非医保退费或医保退费全部结算允许作废。
  --        序号_IN           =要退费的项目序号,格式为"1,3,5,6...",缺省NULL表示退"未退的"所有行。
  --        结算方式_IN       =当为部分退费时,退费金额的结算方式。
  --        误差_IN           =指退费时新产生的误差金额,部份退费或医保全退但某种结算退现金时才会产生新的误差。
  --                           此时传入仅用于计算本次退费的结算金额,误差费用记录的处理在本过程执行完后调用Zl_门诊收费误差_Insert产生
  --        回收票据_In       =0:单张全退或多张一起全退时收回票据,注意,多张单据退费循环调本过程时只收回一次。
  --                           1:部份退费不处理票据,通过重打调用单独处理。
  --        校对标志_IN:0-不需要较对;1-需较对(不处理人员缴款余额,不回收票据,不处理预交余额)
  --        退款操作_In:1-进行部分退(将退款方式退到指定的结算方式<结算方式_In>中,0-不指定退款方式)
  --        多单据全退_IN=1-多单据全退(多张单据全退,原样退);0-非原样退
  --该游标为要退费单据的所有原始记录

  --医保全退但某种结算退现金从而产生了新的误差时,排开此处的误差处理,执行完本过程后,界面程序中单独处理新误差
  Cursor c_Bill Is
    Select a.Id, a.No, a.附加标志, a.收费细目id, a.序号, a.价格父号, a.执行状态, a.收费类别, a.付数, a.数次, a.医嘱序号, j.诊疗类别, m.跟踪在用,
           Nvl(a.附加标志, 0) As 误差
    From 门诊费用记录 A, 病人医嘱记录 J, 材料特性 M
    Where a.医嘱序号 = j.Id(+) And a.No = No_In And a.记录性质 = 1 And a.记录状态 In (1, 3) And a.收费细目id + 0 = m.材料id(+) And
          Nvl(a.附加标志, 0) <> Decode(多单据全退_In, 1, 999, 9)
    Order By a.收费细目id, a.序号;
  --:不管原始单据误差,都应该根据当前退费产生的误差项进行处理
  -- Decode(Sign(误差_In), 0, 999, 9)

  --该光标用于处理人员缴款余额中退的不同结算方式的金额
  Cursor c_Money(冲销id_In 病人预交记录.结帐id%Type) Is
    Select 结算方式, 冲预交
    From 病人预交记录
    Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = 冲销id_In And 结算方式 Is Not Null And Nvl(冲预交, 0) <> 0 And Nvl(校对标志, 0) = 0;

  --该游标用于查找收费时使用过的冲预交款记录
  Cursor c_Deposit(V结帐id 病人预交记录.结帐id%Type) Is
    Select ID, 病人id, 冲预交 As 金额, 预交类别
    From 病人预交记录
    Where 记录性质 In (1, 11) And 记录状态 In (1, 3) And 结帐id = V结帐id And Nvl(冲预交, 0) <> 0
    Order By ID Desc;

  n_病人id   病人信息.病人id%Type;
  n_结帐id   门诊费用记录.结帐id%Type;
  n_结算序号 病人预交记录.结算序号%Type;
  n_打印id   票据打印内容.Id%Type;

  n_已退金额 病人预交记录.冲预交%Type;
  n_预交金额 病人预交记录.冲预交%Type;
  n_返回值   病人预交记录.冲预交%Type;
  n_原误差费 门诊费用记录.实收金额%Type;
  --部分退费计算变量
  n_剩余数量 Number;
  n_剩余应收 Number;
  n_剩余实收 Number;
  n_剩余统筹 Number;
  n_准退数量 Number;
  n_退费次数 Number;

  n_应收金额 Number;
  n_实收金额 Number;
  n_统筹金额 Number;
  n_总金额   Number;
  n_费用状态 门诊费用记录.费用状态%Type;
  n_正常退费 Number; --是否第一次退费且全部退费,在每行退费过程中判断得到。
  n_组id     财务缴款分组.Id%Type;

  v_退费结算 结算方式.名称%Type;
  v_结算内容 Varchar2(500);
  n_部分退   Number(2);

  l_使用id   t_Numlist := t_Numlist();
  n_Dec      Number;
  d_Date     Date;
  n_Count    Number;
  n_原结帐id Number;

  Err_Item Exception;
  v_Err_Msg      Varchar2(255);
  n_启用模式     Number(3);
  v_Para         Varchar2(1000);
  n_医属执行计价 Number;

  Procedure Zl_Square_Update
  (
    原结帐id_In 病人预交记录.结帐id%Type,
    现结帐id_In 病人预交记录.结帐id%Type,
    缴款组id_In 病人预交记录.缴款组id%Type,
    退款时间_In 病人预交记录.收款时间%Type,
    结算序号_In 病人预交记录.结算序号%Type,
    结算内容_In Varchar2 := Null
  ) As
    n_记录状态 病人卡结算记录.记录状态%Type;
    n_预交id   病人预交记录.Id%Type;
    v_卡号     病人卡结算记录.卡号%Type;
    n_存在卡片 Number;
    d_停用日期 消费卡目录.停用日期%Type;
    n_最大序号 病人卡结算记录.序号%Type;
    n_序号     病人卡结算记录.序号%Type;
    n_余额     消费卡目录.余额%Type;
    n_接口编号 病人卡结算记录.接口编号%Type;
    d_回收时间 消费卡目录.回收时间%Type;
    n_Id       病人预交记录.Id%Type;
  Begin
    n_预交id := 0;
    --处理消费卡,结算卡在上面就已经处理了
    For v_校对 In (Select a.Id As 预交id, c.消费卡id, c.结算金额, c.接口编号, c.卡号, c.序号, c.Id
                 From 病人预交记录 A, 病人卡结算对照 B, 病人卡结算记录 C
                 Where a.Id = b.预交id And b.卡结算id = c.Id And a.记录性质 = 3 And a.记录状态 = 1 And
                       Instr(Nvl(结算内容_In, '_LXH'), ',' || a.结算方式 || ',') = 0 And a.结帐id = 原结帐id_In) Loop
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id = Nvl(v_校对.消费卡id, 0) And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      Else
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id Is Null And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      End If;
    
      If n_记录状态 = 1 Then
        n_记录状态 := 2;
      Else
        n_记录状态 := n_记录状态 + 2;
      End If;
      --多条时,只更新一条
      If n_预交id = 0 Then
        Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id,
           预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
          Select n_预交id, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, 退款时间_In, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
                 -1 * 冲预交, 现结帐id_In, 缴款组id_In, 预交类别, 卡类别id, Nvl(结算卡序号, v_校对.接口编号), 卡号, 交易流水号, 交易说明, 合作单位,
                 Decode(Nvl(校对标志_In, 0), 0, 0, Decode(Nvl(v_校对.消费卡id, 0), 0, 1, 2)), 结算序号_In, 3
          From 病人预交记录 A
          Where ID = v_校对.预交id;
      End If;
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        --消费卡,直接退回卡数据中
        Begin
          Select 卡号, 1, 停用日期, (Select Max(序号) From 消费卡目录 B Where a.卡号 = b.卡号 And a.接口编号 = b.接口编号), 序号, 余额, 接口编号, 回收时间
          Into v_卡号, n_存在卡片, d_停用日期, n_最大序号, n_序号, n_余额, n_接口编号, d_回收时间
          From 消费卡目录 A
          Where ID = v_校对.消费卡id;
        Exception
          When Others Then
            n_存在卡片 := 0;
        End;
      
        --取消停用
        If n_存在卡片 = 0 Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡被他人删除，不能再启用该卡片,请检查！';
          Raise Err_Item;
        End If;
        If Nvl(n_序号, 0) < Nvl(n_最大序号, 0) Then
          v_Err_Msg := '不能启用历史发卡记录(卡号为"' || v_卡号 || '"),请检查！';
          Raise Err_Item;
        End If;
        If Nvl(d_停用日期, To_Date('3000-01-01', 'yyyy-mm-dd')) < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经被他人停用，不能再进行退费,请检查！';
          Raise Err_Item;
        End If;
      
        If d_回收时间 < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经回收，不能退费,请检查！';
          Raise Err_Item;
        End If;
        Update 消费卡目录 Set 余额 = Nvl(余额, 0) + v_校对.结算金额 Where ID = Nvl(v_校对.消费卡id, 0);
      End If;
    
      Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      Insert Into 病人卡结算记录
        (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Select n_Id, 接口编号, 消费卡id, 序号, n_记录状态, 结算方式, -1 * v_校对.结算金额, 卡号, 交易流水号, 交易时间, 备注,
               Decode(消费卡id, Null, 0, 0, 0, 1) As 标志
        From 病人卡结算记录
        Where ID = v_校对.Id;
      Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
    
      If n_记录状态 <> 2 And n_记录状态 <> 1 Then
        Update 病人卡结算记录 Set 记录状态 = 3 Where ID = v_校对.Id;
      End If;
    End Loop;
  End;

Begin
  n_组id   := Zl_Get组id(操作员姓名_In);
  n_部分退 := 0;
  --是否已经全部完全执行(只是该单据整张单据的检查)
  Select Nvl(Count(*), 0)
  Into n_Count
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1;
  If n_Count = 0 Then
    v_Err_Msg := '该单据中的项目已经全部完全执行！';
    Raise Err_Item;
  End If;

  --未完全执行的项目是否有剩余数量(只是整张单据的检查)
  --执行状态在原始记录上判断
  Select Nvl(Count(*), 0)
  Into n_Count
  From (Select 序号, Sum(数量) As 剩余数量
         From (Select 记录状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                From 门诊费用记录
                Where NO = No_In And 记录性质 = 1 And Nvl(附加标志, 0) <> 9 And
                      Nvl(价格父号, 序号) In
                      (Select Nvl(价格父号, 序号)
                       From 门诊费用记录
                       Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1)
                Group By 记录状态, Nvl(价格父号, 序号))
         Group By 序号
         Having Sum(数量) <> 0);
  If n_Count = 0 Then
    v_Err_Msg := '该单据中未完全执行部分项目剩余数量为零,没有可以退费的费用！';
    Raise Err_Item;
  End If;
  --确定是否在医嘱执行计价中存在数据,如果存在数据,则根据医嘱执行计价进行退费,否则按旧方式进行处理
  Select Count(1)
  Into n_医属执行计价
  From 门诊费用记录 A, 医嘱执行计价 B
  Where a.医嘱序号 = b.医嘱id And a.记录性质 = 1 And a.No = No_In And a.记录状态 In (1, 3) And Rownum = 1;

  ---------------------------------------------------------------------------------
  --公用变量
  If 退费时间_In Is Not Null Then
    d_Date := 退费时间_In;
  Else
    Select Sysdate Into d_Date From Dual;
  End If;
  If 结帐id_In Is Null Then
    Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  Else
    n_结帐id := 结帐id_In;
  End If;
  n_结算序号 := 结算序号_In;
  If n_结算序号 Is Null Then
    n_结算序号 := 结帐id_In;
  End If;
  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into n_Dec From Dual;

  --获取结算方式名称
  v_退费结算 := 结算方式_In;
  If v_退费结算 Is Null Then
    Begin
      Select 名称 Into v_退费结算 From 结算方式 Where 性质 = 1;
    Exception
      When Others Then
        v_退费结算 := '现金';
    End;
  End If;
  --循环处理每行费用(收入项目行)
  n_总金额   := 0;
  n_正常退费 := 1;
  For r_Bill In c_Bill Loop
    If Instr(',' || 序号_In || ',', ',' || Nvl(r_Bill.价格父号, r_Bill.序号) || ',') > 0 Or 序号_In Is Null Then
      If Nvl(r_Bill.执行状态, 0) <> 1 Then
        --求剩余数量,剩余应收,剩余实收
        Select Sum(Nvl(付数, 1) * 数次), Sum(应收金额), Sum(实收金额), Sum(统筹金额)
        Into n_剩余数量, n_剩余应收, n_剩余实收, n_剩余统筹
        From 门诊费用记录
        Where NO = No_In And 记录性质 = 1 And 序号 = r_Bill.序号;
      
        If n_剩余数量 = 0 Then
          If 序号_In Is Not Null Then
            v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经全部退费！';
            Raise Err_Item;
          End If;
          --情况：未限定行号,原始单据中的该笔已经全部退费(执行状态=0的一种可能)
          n_正常退费 := 0;
        Else
          --准退数量(非药品项目为剩余数量,原始数量)
          If Instr(',4,5,6,7,', r_Bill.收费类别) = 0 Or (r_Bill.收费类别 = '4' And Nvl(r_Bill.跟踪在用, 0) = 0) Then
            --@@@
            --非药品部分(以具体医嘱执行为准进行检查)
            --: 1.存在医嘱发送的,则以医嘱执行为准(但不能包含:检查;检验;手术;麻醉及输血)
            --: 2.不存在医嘱的,则以剩余数量为准
            n_Count := 0;
            If Instr(',C,D,F,G,K,', ',' || r_Bill.诊疗类别 || ',') = 0 And r_Bill.诊疗类别 Is Not Null Then
              If n_医属执行计价 = 1 Then
                Select Decode(Sign(Sum(数量)), -1, 0, Sum(数量)), Count(*)
                Into n_准退数量, n_Count
                From (Select Max(Decode(a.记录状态, 2, 0, a.Id)) As ID, Max(a.医嘱序号) As 医嘱id, Max(a.收费细目id) As 收费细目id,
                              Sum(Nvl(a.付数, 1) * Nvl(a.数次, 1)) As 数量,
                              Sum(Decode(a.记录状态, 2, 0, Nvl(a.付数, 1) * Nvl(a.数次, 1))) As 原始数量
                       From 门诊费用记录 A, 病人医嘱记录 M
                       Where a.医嘱序号 = m.Id And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                             Instr('5,6,7', a.收费类别) = 0 And a.No = No_In And a.序号 = r_Bill.序号 And a.记录性质 = 1 And
                             a.记录状态 In (1, 2, 3) And a.价格父号 Is Null
                       Group By a.序号
                       Union All
                       Select a.Id, a.医嘱序号 As 医嘱id, a.收费细目id, -1 * b.数量 As 已执行, 0 原始数量
                       From 门诊费用记录 A, 医嘱执行计价 B, 病人医嘱记录 M
                       Where a.医嘱序号 = b.医嘱id And a.收费细目id = b.收费细目id + 0 And a.医嘱序号 = m.Id And
                             Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Instr('5,6,7', a.收费类别) = 0 And
                             (Exists
                              (Select 1
                               From 病人医嘱执行
                               Where b.医嘱id = 医嘱id And b.发送号 = 发送号 And b.要求时间 = 要求时间 And Nvl(执行结果, 0) = 1) Or Exists
                              (Select 1
                               From 病人医嘱发送
                               Where b.医嘱id = 医嘱id And b.发送号 = 发送号 And Nvl(执行状态, 0) = 1)) And Not Exists
                        (Select 1
                              From 病人医嘱附费
                              Where a.医嘱序号 = 医嘱id And a.No = NO And Mod(a.记录性质, 10) = 记录性质) And a.No = No_In And
                             a.序号 = r_Bill.序号 And a.记录性质 = 1 And a.记录状态 In (1, 3) 　and a.价格父号 Is Null) Q1
                Where Not Exists (Select 1
                       From 药品收发记录
                       Where 费用id = Q1.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0) Having
                 Max(ID) <> 0;
              Else
              
                Select Nvl(Sum(数量), 0), Count(*)
                Into n_准退数量, n_Count
                From (Select a.医嘱id, a.收费细目id, Nvl(a.数量, 1) * Nvl(b.发送数次, 1) As 数量
                       From 病人医嘱计价 A, 病人医嘱发送 B, 门诊费用记录 J, 病人医嘱记录 M
                       Where a.医嘱id = b.医嘱id And a.医嘱id = m.Id And Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And
                             a.收费细目id = j.收费细目id And j.No = No_In And j.记录性质 = 1 And j.序号 = r_Bill.序号 And
                             j.记录状态 In (1, 3) And j.价格父号 Is Null And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                             Exists
                        (Select 1
                              From 病人医嘱计价 A
                              Where a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And Nvl(a.收费方式, 0) = 0) And Not Exists
                        (Select 1
                              From 药品收发记录
                              Where 费用id = j.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0)
                       Union All
                       Select a.医嘱id, a.收费细目id, -1 * Nvl(a.数量, 1) * Nvl(c.本次数次, 1) As 数量
                       From 病人医嘱计价 A, 病人医嘱发送 B, 病人医嘱执行 C, 门诊费用记录 J, 病人医嘱记录 M
                       Where a.医嘱id = b.医嘱id And b.医嘱id = c.医嘱id And b.发送号 = c.发送号 And a.医嘱id = m.Id And
                             Nvl(c.执行结果, 1) = 1 And Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And
                             j.No = No_In And j.记录性质 = 1 And Nvl(a.收费方式, 0) = 0 And j.序号 = r_Bill.序号 And j.记录状态 In (1, 3) And
                             j.价格父号 Is Null And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Not Exists
                        (Select 1
                              From 药品收发记录
                              Where 费用id = j.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0) And Not Exists
                        (Select 1 From 材料特性 Where 材料id = j.收费细目id And Nvl(跟踪在用, 0) = 1)
                       Union All
                       Select a.医嘱序号 As 医嘱id, a.收费细目id, Nvl(a.付数, 1) * a.数次 As 数量
                       From 门诊费用记录 A, 病人医嘱记录 M
                       Where a.医嘱序号 = m.Id And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And a.No = No_In And
                             a.记录性质 = 1 And a.序号 = r_Bill.序号 And a.记录状态 = 2 And a.价格父号 Is Null And Not Exists
                        (Select 1 From 药品收发记录 Where NO = No_In And 单据 In (8, 24) And 药品id = a.收费细目id));
              End If;
            End If;
            If Nvl(n_Count, 0) <> 0 And n_准退数量 = 0 Then
              v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已执行,不允许退费！';
              Raise Err_Item;
            End If;
          
            If Nvl(n_Count, 0) = 0 Then
              n_准退数量 := n_剩余数量;
            End If;
          
          Else
            Select Nvl(Sum(Nvl(付数, 1) * 实际数量), 0), Count(*)
            Into n_准退数量, n_Count
            From 药品收发记录
            Where NO = No_In And 单据 In (8, 24) And Mod(记录状态, 3) = 1 --@@@
                  And 审核人 Is Null And 费用id = r_Bill.Id;
          
            --有剩余数量无准退数量的有两种情况：
            --1.不跟踪在用的卫材无对应的收发记录,这时使用剩余数量
            --2.并发操作,此时已发药或发料
            If n_准退数量 = 0 Then
              If r_Bill.收费类别 = '4' Then
                If n_Count > 0 Then
                  v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发料,须退料后再退费！';
                  Raise Err_Item;
                Else
                  n_准退数量 := n_剩余数量;
                End If;
              Else
                v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发药,须退药后再退费！';
                Raise Err_Item;
              End If;
            End If;
          End If;
        
          --是否部分退费
          If r_Bill.执行状态 = 2 Or n_准退数量 <> Nvl(r_Bill.付数, 1) * r_Bill.数次 Then
            n_正常退费 := 0;
          End If;
        
          --处理门诊费用记录
          n_费用状态 := 0;
          --该笔项目第几次退费
          If Nvl(校对标志_In, 0) <> 0 Then
            n_退费次数 := -9; --先标明,固定为9
            n_费用状态 := 1;
          Else
            Select Nvl(Max(Abs(执行状态)), 0) + 1
            Into n_退费次数
            From 门诊费用记录
            Where NO = No_In And 记录性质 = 1 And 记录状态 = 2 And Nvl(执行状态, 0) < 0 And 序号 = r_Bill.序号;
          End If;
        
          --金额=剩余金额*(准退数/剩余数)
          If Nvl(r_Bill.误差, 0) = 9 Then
            --误差可以超过设置的小数位(比如:医保结算超过小数位后,误差就可能超过小数位
            n_应收金额 := Round(n_剩余应收 * (n_准退数量 / n_剩余数量), 5);
            n_实收金额 := Round(n_剩余实收 * (n_准退数量 / n_剩余数量), 5);
            n_统筹金额 := Round(n_剩余统筹 * (n_准退数量 / n_剩余数量), 5);
          Else
            n_应收金额 := Round(n_剩余应收 * (n_准退数量 / n_剩余数量), n_Dec);
            n_实收金额 := Round(n_剩余实收 * (n_准退数量 / n_剩余数量), n_Dec);
            n_统筹金额 := Round(n_剩余统筹 * (n_准退数量 / n_剩余数量), n_Dec);
          End If;
          n_总金额 := n_总金额 + n_实收金额;
        
          --插入退费记录
          Insert Into 门诊费用记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别,
             收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人,
             执行状态, 费用状态, 执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 结论,
             缴款组id)
            Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别,
                   病人科室id, 收费类别, 收费细目id, 计算单位, Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, 付数, 1), 发药窗口,
                   Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, -1 * 数次, -1 * n_准退数量), 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价,
                   -1 * n_应收金额, -1 * n_实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, -1 * n_退费次数, n_费用状态, 执行时间, 操作员编号_In,
                   操作员姓名_In, 发生时间, d_Date, n_结帐id, -1 * n_实收金额, 保险项目否, 保险大类id, -1 * n_统筹金额, Nvl(退费摘要_In, 摘要),
                   Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, 结论, n_组id
            From 门诊费用记录
            Where ID = r_Bill.Id;
        
          --标记原费用记录
          --执行状态:全部退完(准退数=剩余数)标记为0,否则标记为1,异常收费单,还是标明9
          Update 门诊费用记录
          Set 记录状态 = 3, 执行状态 = Decode(Nvl(执行状态, 0), 9, 9, Decode(Sign(n_准退数量 - n_剩余数量), 0, 0, 1))
          Where ID = r_Bill.Id;
        End If;
      Else
        If 序号_In Is Not Null Then
          v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经完全执行,不能退费！';
          Raise Err_Item;
        End If;
        --情况:没限定行号,原始单据中包括已经完全执行的
        n_正常退费 := 0;
      End If;
    Else
      n_正常退费 := 0; --未指定该笔,属于部分退费
    End If;
  End Loop;
  ---------------------------------------------------------------------------------
  --处理病人预交记录

  --原单据的结帐ID
  Select 结帐id, 病人id
  Into n_原结帐id, n_病人id
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Rownum = 1;

  If n_正常退费 = 1 And Nvl(退款操作_In, 0) = 0 Then
    --单据第一次退费且全部退完
    --冲预交部分记录
    Insert Into 病人预交记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交, 结帐id,
       缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
      Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, d_Date,
             操作员姓名_In, 操作员编号_In, -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
             Decode(校对标志_In, 1, 2, 校对标志_In), n_结算序号, 3
      From 病人预交记录
      Where 记录性质 In (1, 11) And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0;
    If Nvl(校对标志_In, 0) = 0 Then
      --处理病人预交余额
      For v_预交 In (Select 预交类别, Nvl(Sum(Nvl(冲预交, 0)), 0) As 预交金额, 病人id
                   From 病人预交记录
                   Where 记录性质 In (1, 11) And 结帐id = n_原结帐id
                   Group By 预交类别, 病人id
                   Having Sum(Nvl(冲预交, 0)) <> 0) Loop
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) + Nvl(v_预交.预交金额, 0)
        Where 病人id = v_预交.病人id And 性质 = 1 And 类型 = Nvl(v_预交.预交类别, 2)
        Returning 预交余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 病人余额
            (病人id, 类型, 预交余额, 性质)
          Values
            (v_预交.病人id, Nvl(v_预交.预交类别, 2), Nvl(v_预交.预交金额, 0), 1);
          n_返回值 := n_预交金额;
        End If;
        If n_返回值 = 0 Then
          Delete From 病人余额
          Where 病人id = v_预交.病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
        End If;
      End Loop;
    End If;
    --非医保全退,和医保所有结算方式都允许回退,原样退回(冲预交在前面已处理)
    If 医保结算方式_In Is Null Then
      v_结算内容 := ',' || Nvl(一卡通结算_In, '-Lxh') || ',' || Nvl(一卡通结算_In, 'Lxh') || ',';
    
      --一卡通或消费卡或银行卡的相关数据需要特殊处理,需要最后较对.
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
         卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
        Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, d_Date, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
               -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
               Case
                 When Nvl(卡类别id, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(结算卡序号, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(q.预交id, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(j.名称, '-') <> '-' Then
                  Decode(校对标志_In, 1, 1, 0)
                 Else
                  Decode(校对标志_In, 1, 2, 0)
               End As 校对标志, n_结算序号, 3
        From 病人预交记录 A, (Select 名称 From 结算方式 Where 性质 In (3, 4)) J,
             (Select m.Id As 预交id
               From 病人预交记录 M, 一卡通目录 C
               Where m.结帐id = n_原结帐id And m.结算方式 = c.结算方式 And m.记录性质 = 3 And m.记录状态 = 1) Q
        Where a.记录性质 = 3 And a.记录状态 = 1 And a.结帐id = n_原结帐id And a.Id = q.预交id(+) And a.结算方式 = j.名称(+) And
              Instr(v_结算内容, ',' || 结算方式 || ',') = 0 And
              (Not Exists (Select 1 From 病人卡结算对照 Where a.Id = 预交id) Or Nvl(结算卡序号, 0) = 0);
    
      --处理消费卡,结算卡在上面就已经处理了
      Zl_Square_Update(n_原结帐id, n_结帐id, n_组id, d_Date, n_结算序号, v_结算内容);
      --b.余下的就是三方接口支持的退现了,不允许作废的结算方式,加上到指定的结算方式上,加上误差(因为界面程序会在这之后退误差)
      If 一卡通结算_In Is Not Null Then
        Begin
          Select -1 * Nvl(Sum(冲预交), 0) Into n_已退金额 From 病人预交记录 Where 结帐id = n_结帐id;
        Exception
          When Others Then
            n_已退金额 := 0;
        End;
      
        If (n_总金额 - n_已退金额) <> 0 Then
          --此时的总金额还没有包含误差,因为界面程序中在调用本过程后才产生误差费用记录
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号,
             交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
            Select 病人预交记录_Id.Nextval, 3, NO, 2, 病人id, 主页id, '门诊退费结算', v_退费结算, d_Date, 操作员编号_In, 操作员姓名_In,
                   -1 * (n_总金额 - n_已退金额), n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
                   Decode(校对标志_In, 1, 2, 0), n_结算序号, 3
            From 病人预交记录
            Where 记录性质 = 3 And 记录状态 = 1 And 结帐id = n_原结帐id And Rownum = 1;
          n_部分退 := 1;
        End If;
      End If;
      --医保按允许作废的结算方式退,不允许的,退到指定的结算方式上
      --需要处理误差金额
    Else
      --a.原样退回
      v_结算内容 := ',' || 医保结算方式_In || ',' || Nvl(一卡通结算_In, '-Lxh') || ',' || v_退费结算 || ',';
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
        Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, d_Date, 操作员编号_In, 操作员姓名_In, -1 * 冲预交, n_结帐id,
               n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
               
               Case
                 When Nvl(卡类别id, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(结算卡序号, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(q.预交id, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(j.名称, '-') <> '-' Then
                  Decode(校对标志_In, 1, 1, 0)
                 Else
                  Decode(校对标志_In, 1, 2, 0)
               End As 校对标志, n_结算序号, 3
        From 病人预交记录 A, (Select 名称 From 结算方式 Where 性质 In (3, 4)) J,
             (Select m.Id As 预交id
               From 病人预交记录 M, 一卡通目录 C
               Where m.结帐id = n_原结帐id And m.结算方式 = c.结算方式 And m.记录性质 = 3 And m.记录状态 = 1) Q
        Where a.记录性质 = 3 And a.记录状态 = 1 And a.结算方式 = j.名称(+) And a.结帐id = n_原结帐id And
              Instr(v_结算内容, ',' || a.结算方式 || ',') = 0 And a.Id = q.预交id(+) And
              (Not Exists (Select 1 From 病人卡结算对照 Where a.Id = 预交id) Or Nvl(结算卡序号, 0) = 0);
    
      --处理消费卡,结算卡在上面就已经处理了
      Zl_Square_Update(n_原结帐id, n_结帐id, n_组id, d_Date, n_结算序号, v_结算内容);
    
      --b.余下的就是医保不允许作废的结算方式,加上到指定的结算方式上,加上误差(因为界面程序会在这之后退误差)
      Begin
        Select -1 * Nvl(Sum(冲预交), 0) Into n_已退金额 From 病人预交记录 Where 结帐id = n_结帐id;
      Exception
        When Others Then
          n_已退金额 := 0;
      End;
    
      If (n_总金额 - n_已退金额) <> 0 Then
        --此时的总金额还没有包含误差,因为界面程序中在调用本过程后才产生误差费用记录
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
          Select 病人预交记录_Id.Nextval, 3, NO, 2, 病人id, 主页id, Decode(一卡通结算_In, Null, '门诊医保接口退费', '门诊医保接口和三方接口退费'), v_退费结算,
                 d_Date, 操作员编号_In, 操作员姓名_In, -1 * (n_总金额 - n_已退金额), n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
                 合作单位, Decode(校对标志_In, 1, 2, 0), n_结算序号, 3
          From 病人预交记录
          Where 记录性质 = 3 And 记录状态 = 1 And 结帐id = n_原结帐id And Rownum = 1;
        n_部分退 := 1;
      End If;
    
    End If;
  Else
    -------------------------------------------------
    --部分退费直接退为指定结算方式
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
       结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
      Select 病人预交记录_Id.Nextval, 3, No_In, 2, 病人id, 主页id, '部分退费结算', v_退费结算, d_Date, Null, Null, Null, 操作员编号_In, 操作员姓名_In,
             -1 * (n_总金额 + Nvl(误差_In, 0)), n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
             Decode(校对标志, 1, 2, 0), n_结算序号, 3
      From 病人预交记录
      Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id And Rownum = 1;
  
    --如果收费时只使用了预交款,则要退预交,并且可能有多笔冲预交
    If Sql%RowCount = 0 Then
      n_预交金额 := n_总金额 + Nvl(误差_In, 0);
    
      For r_Deposit In c_Deposit(n_原结帐id) Loop
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 d_Date, 操作员姓名_In, 操作员编号_In, Decode(Sign(r_Deposit.金额 - n_预交金额), -1, -1 * r_Deposit.金额, -1 * n_预交金额),
                 n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, Decode(校对标志_In, 1, 2, 0), n_结算序号, 3
          From 病人预交记录
          Where ID = r_Deposit.Id;
      
        If Nvl(校对标志_In, 0) = 0 Then
          --更新病人预交余额
          Update 病人余额
          Set 预交余额 = Nvl(预交余额, 0) + n_总金额 + Nvl(误差_In, 0)
          Where 病人id = r_Deposit.病人id And 性质 = 1 And 类型 = 1
          Returning 预交余额 Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 病人余额
              (病人id, 类型, 预交余额, 性质)
            Values
              (r_Deposit.病人id, 1, n_总金额 + Nvl(误差_In, 0), 1);
            n_返回值 := n_总金额 + Nvl(误差_In, 0);
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 病人余额
            Where 病人id = r_Deposit.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
          End If;
        End If;
      
        --检查是否已经处理完
        If r_Deposit.金额 < n_预交金额 Then
          n_预交金额 := n_预交金额 - r_Deposit.金额;
        Else
          n_预交金额 := 0;
        End If;
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
    End If;
  End If;

  --更新原记录
  Update 病人预交记录 Set 记录状态 = 3 Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id;

  If 多单据全退_In <> 1 Then
    --处理误差项,多单据全退时 ,按原样退无误差处理
    --将误差项的记录状态调整为3
    If Nvl(误差_In, 0) <> 0 Then
      n_Count := 1;
      If n_正常退费 = 1 And Nvl(退款操作_In, 0) = 0 Then
        n_原误差费 := 0;
        --原样退,但存在误差
        If n_部分退 = 0 Then
          Select -1 * Nvl(Sum(实收金额), 0)
          Into n_原误差费
          From 门诊费用记录 A
          Where NO = No_In And a.记录性质 = 1 And a.记录状态 In (1, 3) And Nvl(a.附加标志, 0) = 9;
        End If;
        If Nvl(n_原误差费, 0) <> 0 Or Nvl(误差_In, 0) <> 0 Then
          Update 病人预交记录
          Set 冲预交 = 冲预交 - n_原误差费 - Nvl(误差_In, 0)
          Where 结算方式 = v_退费结算 And 结帐id = n_结帐id;
          If Sql%NotFound Then
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
               卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
              Select 病人预交记录_Id.Nextval, 3, No_In, 2, 病人id, 主页id, '误差费', v_退费结算, d_Date, Null, Null, Null, 操作员编号_In,
                     操作员姓名_In, -1 * n_原误差费 - Nvl(误差_In, 0), n_结帐id, n_组id, 预交类别, Null, Null, Null, Null, Null, Null, 0,
                     n_结算序号, 3
              From 病人预交记录
              Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id And Rownum = 1;
          End If;
        End If;
      End If;
    Elsif n_正常退费 = 1 And Nvl(退款操作_In, 0) = 0 Then
      --原样退时,需要处理预交记录不足的情况
      Select Nvl(Sum(Nvl(结帐金额, 0)), 0) Into n_实收金额 From 门诊费用记录 Where 结帐id = n_结帐id;
      Select Nvl(Sum(Nvl(冲预交, 0)), 0) Into n_返回值 From 病人预交记录 Where 结帐id = n_结帐id;
      If Abs(n_实收金额) <> Abs(n_返回值) Then
        n_实收金额 := n_实收金额 - n_返回值;
        Update 病人预交记录 Set 冲预交 = 冲预交 + Nvl(n_实收金额, 0) Where 结算方式 = v_退费结算 And 结帐id = n_结帐id;
        If Sql%NotFound Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
             卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
            Select 病人预交记录_Id.Nextval, 3, No_In, 2, 病人id, 主页id, '误差费', v_退费结算, d_Date, Null, Null, Null, 操作员编号_In,
                   操作员姓名_In, Nvl(n_实收金额, 0), n_结帐id, n_组id, 预交类别, Null, Null, Null, Null, Null, Null, 0, n_结算序号, 3
            From 病人预交记录
            Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id And Rownum = 1;
        End If;
      End If;
    End If;
  
    Select Nvl(Sum(Nvl(结帐金额, 0)), 0) Into n_实收金额 From 门诊费用记录 Where 结帐id = n_结帐id;
    Select Nvl(Sum(Nvl(冲预交, 0)), 0) Into n_返回值 From 病人预交记录 Where 结帐id = n_结帐id;
  
    n_实收金额 := n_实收金额 - n_返回值;
  
    If n_实收金额 <> 0 Then
      --未找到，新产生误差项
      Zl_门诊收费误差_Insert(No_In, n_实收金额, 1);
    End If;
  End If;
  ---------------------------------------------------------------------------------
  --人员缴款余额(注意是预交记录处理后才处理，包括个人帐户等的结算金额,不含退冲预交款)
  --如果是需要校对的,暂不处理人员缴款余额
  If Nvl(校对标志_In, 0) = 0 Then
    For r_Moneyrow In c_Money(n_结帐id) Loop
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + r_Moneyrow.冲预交
      Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Moneyrow.结算方式
      Returning 余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (操作员姓名_In, r_Moneyrow.结算方式, 1, r_Moneyrow.冲预交);
        n_返回值 := r_Moneyrow.冲预交;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Moneyrow.结算方式 And Nvl(余额, 0) = 0;
      End If;
    End Loop;
  End If;

  ---------------------------------------------------------------------------------
  --退费票据回收(仅全退时才回退,部分退是在重打过程中回收)
  If 回收票据_In = 0 Then
  
    --启用标志||NO;执行科室(条数);收据费目(首页汇总,条数);收费细目(条数)
    v_Para     := Nvl(zl_GetSysParameter('票据分配规则', 1121), '0||0;0;0,0;0');
    n_启用模式 := Zl_To_Number(Substr(v_Para, 1, 1));
    If n_启用模式 <> 0 Then
      --收回票据
      Select 使用id Bulk Collect
      Into l_使用id
      From (Select Distinct b.使用id From 票据打印明细 B Where b.No = No_In And Nvl(b.票种, 0) = 1);
    
      n_启用模式 := l_使用id.Count;
      If l_使用id.Count <> 0 Then
        --插入回收记录
        Forall I In 1 .. l_使用id.Count
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 操作员姓名_In, d_Date
            From 票据使用明细 A
            Where ID = l_使用id(I) And 性质 = 1 And Not Exists
             (Select 1 From 票据使用明细 Where 号码 = a.号码 And 票种 = a.票种 And Nvl(性质, 0) <> 1);
      
        Forall I In 1 .. l_使用id.Count
          Update 票据打印明细 Set 是否回收 = 1 Where 使用id = l_使用id(I) And Nvl(是否回收, 0) = 0;
      
      End If;
    End If;
    If n_启用模式 = 0 Then
      --获取单据最后一次的打印ID(可能是多张单据收费打印)
      Begin
        Select ID
        Into n_打印id
        From (Select b.Id
               From 票据使用明细 A, 票据打印内容 B
               Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 1 And b.No = No_In
               Order By a.使用时间 Desc)
        Where Rownum < 2;
      Exception
        When Others Then
          Null;
      End;
      --可能以前没有打印,无收回
      If n_打印id Is Not Null Then
        --a.多张单据循环调用时只能收回一次
        Select Count(*) Into n_Count From 票据使用明细 Where 票种 = 1 And 性质 = 2 And 打印id = n_打印id;
        If n_Count = 0 Then
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
            From 票据使用明细
            Where 打印id = n_打印id And 票种 = 1 And 性质 = 1;
        Else
          --b.部分退费多次收回时,最后一次全退收回要排开已收回的
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
            From 票据使用明细 A
            Where 打印id = n_打印id And 票种 = 1 And 性质 = 1 And Not Exists
             (Select 1 From 票据使用明细 B Where a.号码 = b.号码 And 打印id = n_打印id And 票种 = 1 And 性质 = 2);
        End If;
      End If;
    End If;
  End If;

  ---------------------------------------------------------------------------------
  --药品卫材相关内容
  For r_Expenses In (Select ID
                     From 门诊费用记录
                     Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And 收费类别 In ('4', '5', '6', '7') And
                           (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null)) Loop
    Zl_药品收发记录_销售退费(r_Expenses.Id);
  End Loop;

  --医嘱处理
  --场合_In    Integer:=0, --0:门诊;1-住院
  --性质_In    Integer:=1, --1-收费单;2-记帐单
  --操作_In    Integer:=0, --0:删除划价单;1-收费或记帐;2-退费或销帐
  --No_In      门诊费用记录.No%Type,
  --医嘱ids_In Varchar2 := Null
  Zl_医嘱发送_计费状态_Update(0, 1, 2, No_In);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费记录_Delete;
/

--93623:刘兴洪,2016-02-25,更改医嘱发送的计费状态
Create Or Replace Procedure Zl_住院记帐记录_Delete
(
  No_In           住院费用记录.No%Type,
  序号_In         Varchar2,
  操作员编号_In   住院费用记录.操作员编号%Type,
  操作员姓名_In   住院费用记录.操作员姓名%Type,
  记录性质_In     住院费用记录.记录性质%Type := 2,
  操作状态_In     Number := 0,
  输液配药检查_In Number := 1,
  登记时间_In     住院费用记录.登记时间%Type := Sysdate
) As
  --功能：冲销一张住院记帐单据中指定序号行
  --序号：格式如"1,3,5,7,8",或"1:2:33456,3:2,5:2,7:2,8:2",冒号前面的数字表示行号,中间的数字表示退的数量,后面的数字表示配药记录的ID,目前仅在销帐审核时才传入
  --      为空表示冲销所有可冲销行
  --记录性质:    2-人工记帐单,3-自动记帐单
  --输液配药检查:    0-医嘱调用，不检查药品是否进入输液配药中心；1-非医嘱调用，检查药品是否进入配药中心
  --该光标用于销帐指定费用行
  --操作状态_In:0-表示直接销帐;1-表示审核销帐(通过销帐申请-->销帐审核流程)
  --该游标为要退费单据的所有原始记录
  Cursor c_Bill Is
    Select ID, 价格父号, 序号, 执行状态, 记录性质, 收费类别, 医嘱序号, 收费细目id, 病人id, 主页id, 收入项目id, 开单部门id, 病人科室id, 执行部门id, 病人病区id, 付数, 数次
    From 住院费用记录
    Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 In (0, 1, 3) And 门诊标志 = 2
    Order By 收费细目id, 序号;

  --该游标用于处理药品库存可用数量
  --不要管费用的执行状态,因为先于此步处理
  Cursor c_Stock(v_序号_In Varchar2) Is
    Select ID, 单据, NO, 库房id, 药品id, 批次, 发药方式, 付数, 实际数量, 灭菌效期, 效期, 产地, 批号, 填制日期, 费用id, 商品条码, 内部条码
    From 药品收发记录
    Where NO = No_In And 单据 In (9, 10, 25, 26) And Mod(记录状态, 3) = 1 And 审核人 Is Null And
          费用id In (Select ID
                   From 住院费用记录
                   Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 In (0, 1, 3) And 收费类别 In ('4', '5', '6', '7') And
                         门诊标志 = 2 And (Instr(',' || v_序号_In || ',', ',' || 序号 || ',') > 0 Or v_序号_In Is Null))
    Order By 药品id, 填制日期 Desc;

  r_Stock c_Stock%RowType;
  --该游标用于处理费用记录序号
  Cursor c_Serial Is
    Select 序号, 价格父号
    From 住院费用记录
    Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 In (0, 1, 3)
    Order By 序号;

  Cursor Cr_药品 Is
    Select ID, 单据, NO, 库房id, 药品id, 批次, 发药方式, 0 As 数量, 灭菌效期, 效期, 产地, 批号, 填制日期, 费用id
    From 药品收发记录
    Where Rownum <= 1;
  v_药品 Cr_药品%RowType;

  v_医嘱id     病人医嘱记录.Id%Type;
  n_划价       Number;
  v_父号       住院费用记录.价格父号%Type;
  v_序号       Varchar2(2000);
  v_Tmp        Varchar2(4000);
  v_医嘱ids    Varchar2(4000);
  l_药品收发   t_Numlist := t_Numlist();
  l_划价       t_Numlist := t_Numlist();
  l_费用id     t_Numlist := t_Numlist();
  n_付数       Number;
  n_虚拟库房id 药品收发记录.库房id%Type;
  n_其他出库id 药品收发记录.Id%Type;
  n_库房id     药品收发记录.库房id%Type;
  n_返回值     Number;
  --部分退费计算变量
  v_剩余数量 Number;
  v_剩余应收 Number;
  v_剩余实收 Number;
  v_剩余统筹 Number;

  v_准退数量 Number;
  v_退费次数 Number;
  v_应收金额 Number;
  v_实收金额 Number;
  v_统筹金额 Number;
  n_Temp     Number;
  n_部分销帐 Number;
  v_Dec      Number;
  n_Count    Number;
  v_Curdate  Date;
  Err_Item Exception;
  v_Err_Msg        Varchar2(255);
  n_备货卫材       Number;
  n_病人id         病案主页.病人id%Type;
  n_主页id         病案主页.主页id%Type;
  n_审核标志       病案主页.审核标志%Type;
  n_住院状态       病案主页.状态%Type;
  n_病人审核方式   Number(2);
  n_未入科禁止记账 Number(2);
  v_配药id         Varchar2(4000);
  Type Ty_药品 Is Ref Cursor;
  c_药品 Ty_药品; --游标变量

Begin
  --销帐审核时,非药品会传入行号的销帐数量
  If Not 序号_In Is Null Then
    If Instr(序号_In, ':') > 0 Then
      v_Tmp := 序号_In || ',';
      While Not v_Tmp Is Null Loop
        v_序号 := v_序号 || ',' || Substr(v_Tmp, 1, Instr(v_Tmp, ':') - 1);
        If Instr(Substr(v_Tmp, Instr(v_Tmp, ':') + 1, Instr(v_Tmp, ',') - Instr(v_Tmp, ':') - 1), ':') > 0 Then
          v_配药id := v_配药id || ',' ||
                    Substr(v_Tmp, Instr(v_Tmp, ':', 1, 2) + 1, Instr(v_Tmp, ',') - Instr(v_Tmp, ':', 1, 2) - 1);
        End If;
        v_Tmp := Substr(v_Tmp, Instr(v_Tmp, ',') + 1);
      End Loop;
      v_序号 := Substr(v_序号, 2);
      If v_配药id Is Not Null Then
        v_配药id := Substr(v_配药id, 2);
      End If;
    Else
      v_序号 := 序号_In;
    End If;
  End If;

  --是否已经全部完全执行(只是整张单据的检查)
  Select Nvl(Count(*), 0), Nvl(Max(病人id), 0), Nvl(Max(主页id), 0)
  Into n_Count, n_病人id, n_主页id
  From 住院费用记录
  Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 In (0, 1, 3) And Nvl(执行状态, 0) <> 1 And 门诊标志 = 2;
  If n_Count = 0 Then
    v_Err_Msg := '该单据中的项目已经全部完全执行！';
    Raise Err_Item;
  End If;

  n_病人审核方式   := Nvl(zl_GetSysParameter(185), 0);
  n_未入科禁止记账 := Nvl(zl_GetSysParameter(215), 0);
  If n_病人审核方式 = 1 Or n_未入科禁止记账 = 1 Then
  
    Begin
      Select 审核标志, 状态 Into n_审核标志, n_住院状态 From 病案主页 Where 病人id = n_病人id And 主页id = n_主页id;
    Exception
      When Others Then
        n_审核标志 := 0;
        n_住院状态 := 0;
    End;
    If n_未入科禁止记账 = 1 And n_住院状态 = 1 Then
      v_Err_Msg := '病人未入科,禁止对病人相关费用的操作!';
      Raise Err_Item;
    End If;
  
    If n_病人审核方式 = 1 Then
    
      If Nvl(n_审核标志, 0) = 1 Then
        v_Err_Msg := '该病人目前正在审核费用,不能进行费用相关调整!';
        Raise Err_Item;
      End If;
      If Nvl(n_审核标志, 0) = 2 Then
        v_Err_Msg := '该病人目前已经完成了费用审核,不能进行费用相关调整!';
        Raise Err_Item;
      End If;
    End If;
  End If;

  --未完全执行的项目是否有剩余数量(只是整张单据的检查)
  Select Nvl(Count(*), 0)
  Into n_Count
  From (Select 序号, Sum(数量) As 剩余数量
         From (Select 记录状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                From 住院费用记录
                Where NO = No_In And 记录性质 = 记录性质_In And 门诊标志 = 2 And
                      Nvl(价格父号, 序号) In
                      (Select Nvl(价格父号, 序号)
                       From 住院费用记录
                       Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 In (0, 1, 3) And Nvl(执行状态, 0) <> 1)
                Group By 记录状态, Nvl(价格父号, 序号))
         Group By 序号
         Having Sum(数量) <> 0);
  If n_Count = 0 Then
    v_Err_Msg := '该单据中未完全执行部分项目剩余数量为零,没有可以销帐的费用！';
    Raise Err_Item;
  End If;

  --医嘱费用：检查正在执行的医嘱(注意已执行的情况在下面检查,因为不传 序号_IN 这种情况费用界面已限制)
  If Nvl(操作状态_In, 0) <> 1 Then
    --走销帐申请流程的，不检查医保执行状态
    Select Nvl(Count(*), 0)
    Into n_Count
    From 病人医嘱发送
    Where 执行状态 = 3 And (NO, 记录性质, 医嘱id) In
          (Select NO, 记录性质, 医嘱序号
                        From 住院费用记录
                        Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 In (0, 1, 3) And 医嘱序号 Is Not Null And
                              (Instr(',' || v_序号 || ',', ',' || 序号 || ',') > 0 Or v_序号 Is Null));
    If n_Count > 0 Then
      v_Err_Msg := '要销帐的费用中存在对应的医嘱正在执行的情况，不能销帐！';
      Raise Err_Item;
    End If;
  End If;

  ---------------------------------------------------------------------------------
  --先打开药品对应数据集,以确保当前条件下有数据,为了处理并发判断
  --不能在游标条件中取消"审核人 is Null"条件，因为多次退药可能部份又已发
  Open c_Stock(v_序号);

  --公用变量
  Select 登记时间_In Into v_Curdate From Dual;

  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into v_Dec From Dual;

  For c_编目病案 In (Select a.姓名
                 From 病人信息 A, 病案主页 B
                 Where a.病人id = b.病人id And b.编目日期 Is Not Null And
                       (b.病人id, b.主页id) In
                       (Select Distinct 病人id, 主页id
                        From 住院费用记录
                        Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 In (0, 1, 3) And 门诊标志 = 2)) Loop
    v_Err_Msg := '病人『' || c_编目病案.姓名 || '』 已经被病案编目,不能被销帐！';
    Raise Err_Item;
  End Loop;
  v_医嘱ids := Null;
  --循环处理每行费用(收入项目行)
  For r_Bill In c_Bill Loop
    --检查已经存在病案编目的,则不能进行销帐处理
    If Instr(',' || v_序号 || ',', ',' || Nvl(r_Bill.价格父号, r_Bill.序号) || ',') > 0 Or v_序号 Is Null Then
      Select Decode(记录状态, 0, 1, 0) Into n_划价 From 住院费用记录 Where ID = r_Bill.Id;
      If Nvl(r_Bill.执行状态, 0) <> 1 Then
        --求剩余数量,剩余应收,剩余实收
        Select Sum(Nvl(付数, 1) * 数次), Sum(应收金额), Sum(实收金额), Sum(统筹金额)
        Into v_剩余数量, v_剩余应收, v_剩余实收, v_剩余统筹
        From 住院费用记录
        Where NO = No_In And 记录性质 = 记录性质_In And 序号 = r_Bill.序号;
        n_部分销帐 := 0;
        If v_剩余数量 = 0 Then
          If v_序号 Is Not Null Then
            v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经全部销帐！';
            Raise Err_Item;
          End If;
          --情况：未限定行号,原始单据中的该笔已经全部销帐(执行状态=0的一种可能)
        Else
        
          If Instr(序号_In, ':') > 0 Then
            v_Tmp := ',' || 序号_In;
            v_Tmp := Substr(v_Tmp, Instr(v_Tmp, ',' || r_Bill.序号 || ':') + Length(',' || r_Bill.序号 || ':'));
            v_Tmp := Substr(v_Tmp, 1, Instr(v_Tmp || ',', ',') - 1);
            If Instr(v_Tmp, ':') > 0 Then
              v_Tmp := Substr(v_Tmp, 1, Instr(v_Tmp, ':') - 1);
            End If;
            v_准退数量 := v_Tmp;
            n_部分销帐 := 1;
          End If;
        
          --准销数量(非药品项目为剩余数量,原始数量)
          If Instr(',4,5,6,7,', r_Bill.收费类别) = 0 Then
            If Instr(序号_In, ':') = 0 Or 序号_In Is Null Then
              v_准退数量 := v_剩余数量;
            End If;
          Else
            --医嘱超期收回时,卫材可能没有发放,但申请销帐的是部分数量,所以要以申请的为准
            If Instr(序号_In, ':') = 0 Or 序号_In Is Null Then
              Select Nvl(Sum(Nvl(付数, 1) * 实际数量), 0), Count(*)
              Into v_准退数量, n_Count
              From 药品收发记录
              Where NO = No_In And 单据 In (9, 10, 25, 26) And Mod(记录状态, 3) = 1 And 审核人 Is Null And 费用id = r_Bill.Id;
            End If;
          
            --有剩余数量无准退数量的有两种情况：
            --1.不跟踪在用的卫材无对应的收发记录,这时使用剩余数量
            --2.并发操作,此时已发药或发料
            If v_准退数量 = 0 Then
              If r_Bill.收费类别 = '4' Then
                If n_Count > 0 Then
                  v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发料,须退料后再退费！';
                  Raise Err_Item;
                Else
                  v_准退数量 := v_剩余数量;
                End If;
              Else
                v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发药,须退药后再退费！';
                Raise Err_Item;
              End If;
            End If;
          End If;
        
          --处理住院费用记录
          If Nvl(n_划价, 0) = 0 Then
            --划价时,直接更改数量,所以不须查划冲销次数
            --该笔项目第几次销帐
            Select Nvl(Max(Abs(执行状态)), 0) + 1
            Into v_退费次数
            From 住院费用记录
            Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 = 2 And 序号 = r_Bill.序号 And 门诊标志 = 2;
          End If;
        
          --金额=剩余金额*(准退数/剩余数)
          v_应收金额 := Round(v_剩余应收 * (v_准退数量 / v_剩余数量), v_Dec);
          v_实收金额 := Round(v_剩余实收 * (v_准退数量 / v_剩余数量), v_Dec);
          v_统筹金额 := Round(v_剩余统筹 * (v_准退数量 / v_剩余数量), v_Dec);
          If Nvl(n_划价, 0) = 1 Then
            If Nvl(n_部分销帐, 0) = 0 Then
              l_划价.Extend;
              l_划价(l_划价.Count) := r_Bill.Id;
              n_返回值 := 0;
            Else
              --更新数量
              --划价的,先将相关的数据处理在内部表集中
              n_付数 := 0;
              If r_Bill.付数 > 1 Then
                --如果是中药,超期回收肯定是回收的付数,而不是次数.因此,需要检查准退数量是否可以整 除
                If Trunc(v_准退数量 / r_Bill.数次) <> (v_准退数量 / r_Bill.数次) Then
                  v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用为中药,请按付数进行退费！';
                  Raise Err_Item;
                End If;
                n_付数 := Trunc(v_准退数量 / r_Bill.数次);
                If Nvl(r_Bill.付数, 0) - n_付数 < 0 Then
                  v_准退数量 := r_Bill.数次;
                Else
                  v_准退数量 := 0;
                End If;
              End If;
              Update 住院费用记录
              Set 付数 = 付数 - n_付数, 数次 = 数次 - v_准退数量, 应收金额 = Nvl(应收金额, 0) - v_应收金额, 实收金额 = Nvl(实收金额, 0) - v_实收金额,
                  登记时间 = v_Curdate, 统筹金额 = Nvl(统筹金额, 0) - v_统筹金额
              Where ID = r_Bill.Id
              Returning Nvl(数次, 0) * Nvl(付数, 0) Into n_返回值;
            End If;
            If Nvl(n_返回值, 0) <= 0 Then
              l_划价.Extend;
              l_划价(l_划价.Count) := r_Bill.Id;
            End If;
            If r_Bill.医嘱序号 Is Not Null Then
              If Instr(',' || Nvl(v_医嘱ids, '') || ',', ',' || r_Bill.医嘱序号 || ',') = 0 Then
                v_医嘱ids := Nvl(v_医嘱ids, '') || ',' || r_Bill.医嘱序号;
              End If;
              --记录病人医嘱附费对应的医嘱ID(不是主费用)
              If v_医嘱id Is Null Then
                v_医嘱id := r_Bill.医嘱序号;
              End If;
            End If;
          
          End If;
        
          If Nvl(n_划价, 0) = 0 Then
            --划价时,直接更改数量,所以不须查划冲销次数
            --插入退费记录
            Insert Into 住院费用记录
              (ID, NO, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 主页id, 病人id, 医嘱序号, 门诊标志, 多病人单, 婴儿费, 姓名, 性别, 年龄, 标识号, 床号, 费别, 病人病区id,
               病人科室id, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人,
               执行部门id, 划价人, 执行人, 执行状态, 执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 保险项目否, 保险大类id, 统筹金额, 保险编码, 记帐单id, 摘要, 费用类型, 是否急诊,
               结论, 医疗小组id)
              Select 病人费用记录_Id.Nextval, NO, 记录性质, 2, 序号, 从属父号, 价格父号, 主页id, 病人id, 医嘱序号, 门诊标志, 多病人单, 婴儿费, 姓名, 性别, 年龄, 标识号,
                     床号, 费别, 病人病区id, 病人科室id, 收费类别, 收费细目id, 计算单位, Decode(Sign(v_准退数量 - Nvl(付数, 1) * 数次), 0, 付数, 1), 发药窗口,
                     Decode(Sign(v_准退数量 - Nvl(付数, 1) * 数次), 0, -1 * 数次, -1 * v_准退数量), 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用,
                     标准单价, -1 * v_应收金额, -1 * v_实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, -1 * v_退费次数, 执行时间, 操作员编号_In,
                     操作员姓名_In, 发生时间, v_Curdate, 保险项目否, 保险大类id, -1 * v_统筹金额, 保险编码, 记帐单id, 摘要, 费用类型, 是否急诊, 结论, 医疗小组id
              From 住院费用记录
              Where ID = r_Bill.Id;
          
            --记录病人医嘱附费对应的医嘱ID(不是主费用)
            If v_医嘱id Is Null And r_Bill.医嘱序号 Is Not Null Then
              v_医嘱id := r_Bill.医嘱序号;
            End If;
          
            Update 病人审批项目
            Set 已用数量 = Nvl(已用数量, 0) - v_准退数量
            Where 病人id = r_Bill.病人id And 主页id = r_Bill.主页id And 项目id = r_Bill.收费细目id And Nvl(使用限量, 0) <> 0;
          
            --病人余额
            Update 病人余额
            Set 费用余额 = Nvl(费用余额, 0) - v_实收金额
            Where 病人id = r_Bill.病人id And 类型 = 2 And 性质 = 1;
            If Sql%RowCount = 0 Then
              Insert Into 病人余额
                (病人id, 类型, 性质, 费用余额, 预交余额)
              Values
                (r_Bill.病人id, 2, 1, -1 * v_实收金额, 0);
            End If;
          
            --病人未结费用
            Update 病人未结费用
            Set 金额 = Nvl(金额, 0) - v_实收金额
            Where 病人id = r_Bill.病人id And Nvl(主页id, 0) = Nvl(r_Bill.主页id, 0) And Nvl(病人病区id, 0) = Nvl(r_Bill.病人病区id, 0) And
                  Nvl(病人科室id, 0) = Nvl(r_Bill.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(r_Bill.开单部门id, 0) And
                  Nvl(执行部门id, 0) = Nvl(r_Bill.执行部门id, 0) And 收入项目id + 0 = r_Bill.收入项目id And 来源途径 + 0 = 2;
            If Sql%RowCount = 0 Then
              Insert Into 病人未结费用
                (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
              Values
                (r_Bill.病人id, r_Bill.主页id, r_Bill.病人病区id, r_Bill.病人科室id, r_Bill.开单部门id, r_Bill.执行部门id, r_Bill.收入项目id, 2,
                 -1 * v_实收金额);
            End If;
          
            --标记原费用记录
            --执行状态:全部退完(准退数=剩余数)标记为0,否则保持原状态
            If Instr(',4,5,6,7,', r_Bill.收费类别) = 0 Then
              --一般情况非药品和卫材的项目,不存在部分销帐的情况,只有销帐申请和销帐审核时,才会出现部分销帐,所以
              --执行状态只有两种:0.未执行;1已执行;
              --由于在销帐审核过程中将已执行强制改为了2部分执行,因此需要在此处改为1已执行.未执行的不变.
              Update 住院费用记录
              Set 记录状态 = 3, 执行状态 = Decode(Sign(v_准退数量 - v_剩余数量), 0, 0, Decode(执行状态, 2, 1, 执行状态))
              Where ID = r_Bill.Id;
            Else
              Update 住院费用记录
              Set 记录状态 = 3, 执行状态 = Decode(Sign(v_准退数量 - v_剩余数量), 0, 0, 执行状态)
              Where ID = r_Bill.Id;
            End If;
          End If;
        End If;
      Else
        If v_序号 Is Not Null Then
          v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经完全执行,不能销帐！';
          Raise Err_Item;
        End If;
        --情况:没限定行号,原始单据中包括已经完全执行的
      End If;
    End If;
  End Loop;

  --不存在配药ID,检查该药品是否在输液配药中心
  If v_配药id Is Null And 输液配药检查_In = 1 Then
    For v_费用 In (Select ID
                 From 住院费用记录
                 Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 In (0, 1, 3) And 收费类别 In ('4', '5', '6', '7') And 门诊标志 = 2 And
                       (Instr(',' || v_序号 || ',', ',' || 序号 || ',') > 0 Or v_序号 Is Null)) Loop
      Begin
        Select Count(1)
        Into n_Count
        From 输液配药内容 A, 药品收发记录 B
        Where a.收发id = b.Id And b.费用id = v_费用.Id And Instr(',8,9,10,21,24,25,26,', ',' || b.单据 || ',') > 0;
      Exception
        When Others Then
          n_Count := 0;
      End;
      If n_Count <> 0 Then
        v_Err_Msg := '存在已经进入输液配药中心的待销帐药品，无法完成销帐！';
        Raise Err_Item;
      End If;
    End Loop;
  End If;

  n_部分销帐 := 0;
  ---------------------------------------------------------------------------------
  --药品相关处理:主要是对销帐审核有效.(可以是部分)
  For v_费用 In (Select ID, 序号, 收费类别
               From 住院费用记录
               Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 In (0, 1, 3) And 收费类别 In ('4', '5', '6', '7') And 门诊标志 = 2 And
                     (Instr(',' || v_序号 || ',', ',' || 序号 || ',') > 0 Or v_序号 Is Null)) Loop
    --根据费用ID来进行相关的处理
    v_准退数量 := 0;
    If Instr(序号_In, ':') > 0 Then
      v_Tmp := ',' || 序号_In;
      v_Tmp := Substr(v_Tmp, Instr(v_Tmp, ',' || v_费用.序号 || ':') + Length(',' || v_费用.序号 || ':'));
      v_Tmp := Substr(v_Tmp, 1, Instr(v_Tmp || ',', ',') - 1);
      If Instr(v_Tmp, ':') > 0 Then
        v_Tmp := Substr(v_Tmp, 1, Instr(v_Tmp, ':') - 1);
      End If;
      v_准退数量 := v_Tmp;
    End If;
    If v_准退数量 <> 0 Then
      n_部分销帐 := 1;
      n_Temp     := 0;
      --------------------------------------------------------------------------------------
      --检查是否备货记帐卫材,规则如下
      -- a.如果存在存在未审核的其他出库且部分销帐时,直接在原来的基础上更改其他出库数量
      -- b.如果存在存在未审核的其他出库且完全销帐时,直接删除
      -- c.库存处理:还原为虚拟库房的可用数量;发料部门不处理
      -- d.如果已经发了料,这个时间由于其他出库单已经审核,因此就按正常情况流转,库存恢复到发料部门中
      n_虚拟库房id := Null;
      n_其他出库id := Null;
      If v_费用.收费类别 = '4' Then
        Begin
          Select 1, 库房id, ID
          Into n_备货卫材, n_虚拟库房id, n_其他出库id
          From 药品收发记录
          Where 费用id = v_费用.Id And 审核日期 Is Null And 单据 = 21 And Rownum = 1;
        Exception
          When Others Then
            n_备货卫材 := 0;
        End;
      Else
        n_备货卫材 := 0;
      End If;
      --------------------------------------------------------------------------------------
      If v_配药id Is Not Null Then
        Open c_药品 For
          Select /*+ rule*/
           a.Id, a.单据, a.No, a.库房id, a.药品id, a.批次, a.发药方式,
           Decode(a.发药方式, Null, 1, -1, 0, 1) * Nvl(a.付数, 1) * Nvl(a.实际数量, 0) As 数量, a.灭菌效期, a.效期, a.产地, a.批号, a.填制日期,
           a.费用id
          From 药品收发记录 A, Table(f_Str2list(v_配药id)) B, 输液配药内容 C
          Where a.No = No_In And a.单据 In (9, 10, 25, 26) And Mod(a.记录状态, 3) = 1 And a.审核人 Is Null And a.费用id = v_费用.Id And
                a.Id = c.收发id And c.记录id = b.Column_Value
          Order By 填制日期;
      Else
        Open c_药品 For
          Select ID, 单据, NO, 库房id, 药品id, 批次, 发药方式, Decode(发药方式, Null, 1, -1, 0, 1) * Nvl(付数, 1) * Nvl(实际数量, 0) As 数量,
                 灭菌效期, 效期, 产地, 批号, 填制日期, 费用id
          From 药品收发记录
          Where NO = No_In And 单据 In (9, 10, 25, 26) And Mod(记录状态, 3) = 1 And 审核人 Is Null And 费用id = v_费用.Id
          Order By 填制日期;
      End If;
      Loop
        Fetch c_药品
          Into v_药品;
        Exit When c_药品%NotFound;
        n_Temp := v_药品.数量;
        If v_准退数量 >= n_Temp Then
          l_药品收发.Extend;
          l_药品收发(l_药品收发.Count) := v_药品.Id;
          If Nvl(n_其他出库id, 0) > 0 Then
            l_药品收发.Extend;
            l_药品收发(l_药品收发.Count) := n_其他出库id;
          End If;
          v_准退数量 := v_准退数量 - n_Temp;
        Else
          If v_费用.收费类别 = '7' Then
            --当前行的数量要大
            Update 药品收发记录
            Set 付数 = 1, 实际数量 = Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - v_准退数量,
                填写数量 = Decode(付数, Null, 1, 0, 1, 付数) * Nvl(填写数量, 0) - v_准退数量,
                成本金额 =
                 (Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - v_准退数量) * 成本价,
                零售金额 =
                 (Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - v_准退数量) * 零售价,
                差价 = Round((Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - v_准退数量) * 零售价 -
                            (Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - v_准退数量) * 成本价, 5)
            Where ID = v_药品.Id;
          Else
            Update 药品收发记录
            Set 实际数量 = Nvl(实际数量, 0) - v_准退数量, 填写数量 = Nvl(填写数量, 0) - v_准退数量,
                成本金额 =
                 (Nvl(实际数量, 0) - v_准退数量) * 成本价,
                零售金额 =
                 (Nvl(实际数量, 0) - v_准退数量) * 零售价,
                差价 = Round((Nvl(实际数量, 0) - v_准退数量) * 零售价 - (Nvl(实际数量, 0) - v_准退数量) * 成本价, 5)
            Where ID = v_药品.Id;
          End If;
          --更新其他出库单
          If Nvl(n_其他出库id, 0) <> 0 Then
            If v_费用.收费类别 = '7' Then
              Update 药品收发记录
              Set 付数 = 1, 实际数量 = Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - v_准退数量,
                  填写数量 = Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - v_准退数量,
                  成本金额 =
                   (Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - v_准退数量) * 成本价,
                  零售金额 =
                   (Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - v_准退数量) * 零售价,
                  差价 = Round((Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - v_准退数量) * 零售价 -
                              (Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - v_准退数量) * 成本价, 5)
              Where ID = Nvl(n_其他出库id, 0);
            Else
              Update 药品收发记录
              Set 实际数量 = Nvl(实际数量, 0) - v_准退数量, 填写数量 = Nvl(实际数量, 0) - v_准退数量,
                  成本金额 =
                   (Nvl(实际数量, 0) - v_准退数量) * 成本价,
                  零售金额 =
                   (Nvl(实际数量, 0) - v_准退数量) * 零售价,
                  差价 = Round((Nvl(实际数量, 0) - v_准退数量) * 零售价 - (Nvl(实际数量, 0) - v_准退数量) * 成本价, 5)
              Where ID = Nvl(n_其他出库id, 0);
            End If;
          End If;
          n_Temp     := v_准退数量;
          v_准退数量 := 0;
        End If;
        If Nvl(n_备货卫材, 0) = 1 Then
          n_库房id := n_虚拟库房id;
        Else
          n_库房id := v_药品.库房id;
        End If;
      
        If n_库房id Is Not Null Then
          Update 药品库存
          Set 可用数量 = Nvl(可用数量, 0) + n_Temp
          Where 库房id = n_库房id And 药品id = v_药品.药品id And Nvl(批次, 0) = Nvl(v_药品.批次, 0) And 性质 = 1;
          If Sql%RowCount = 0 Then
            Insert Into 药品库存
              (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期)
            Values
              (n_库房id, v_药品.药品id, 1, v_药品.批次, v_药品.效期, n_Temp, v_药品.批号, v_药品.产地, v_药品.灭菌效期);
          End If;
          Delete 药品库存
          Where 库房id = n_库房id And 药品id = v_药品.药品id And Nvl(批次, 0) = Nvl(v_药品.批次, 0) And 性质 = 1 And Nvl(可用数量, 0) = 0 And
                Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0;
        End If;
      
        If Nvl(n_备货卫材, 0) = 1 Then
          Update 药品库存
          Set 可用数量 = Nvl(可用数量, 0) + n_Temp
          Where 库房id = v_药品.库房id And 药品id = v_药品.药品id And Nvl(批次, 0) = Nvl(v_药品.批次, 0) And 性质 = 1;
          If Sql%RowCount = 0 Then
            Insert Into 药品库存
              (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期)
            Values
              (v_药品.库房id, v_药品.药品id, 1, v_药品.批次, v_药品.效期, n_Temp, v_药品.批号, v_药品.产地, v_药品.灭菌效期);
          End If;
        End If;
      
        If v_准退数量 = 0 Then
          Exit;
        End If;
      End Loop;
      --不跟踪卫材的,不检查:因为不跟噻的话,不会在药品收发记录中存在
      If Nvl(v_准退数量, 0) <> 0 And Not (v_费用.收费类别 = '4' And n_Temp = 0) Then
        --未分配完成,表示此药品可能已经执行.
        v_Err_Msg := '要销帐的费用中存在已发的药品或卫材，或已被其他人销帐；这可能是并发操作引起的。';
        Raise Err_Item;
      End If;
    End If;
  End Loop;

  If n_部分销帐 = 0 Then
    ------------------------------------------------------------------------------------------------------------------------
    --先处理备货材料
    For v_出库 In (Select ID, 单据, NO, 库房id, 药品id, 批次, 发药方式, 付数, 实际数量, 灭菌效期, 效期, 产地, 批号, 填制日期, 费用id, 商品条码, 内部条码
                 From 药品收发记录
                 Where 单据 = 21 And Mod(记录状态, 3) = 1 And 审核人 Is Null And
                       费用id In (Select ID
                                From 住院费用记录
                                Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 In (0, 1, 3) And 收费类别 = '4' And 门诊标志 = 2 And
                                      (Instr(',' || v_序号 || ',', ',' || 序号 || ',') > 0 Or v_序号 Is Null))
                 Order By 药品id, 填制日期 Desc) Loop
      --处理药品库存
      If v_出库.库房id Is Not Null Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) + Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0)
        Where 库房id = v_出库.库房id And 药品id = v_出库.药品id And Nvl(批次, 0) = Nvl(v_出库.批次, 0) And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码)
          Values
            (v_出库.库房id, v_出库.药品id, 1, v_出库.批次, v_出库.效期,
             Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0), v_出库.批号, v_出库.产地, v_出库.灭菌效期,
             v_出库.商品条码, v_出库.内部条码);
        End If;
        Delete 药品库存
        Where 库房id = v_出库.库房id And 药品id = v_出库.药品id And Nvl(批次, 0) = Nvl(v_出库.批次, 0) And 性质 = 1 And Nvl(可用数量, 0) = 0 And
              Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0;
      End If;
      l_费用id.Extend;
      l_费用id(l_费用id.Count) := v_出库.费用id;
      l_药品收发.Extend;
      l_药品收发(l_药品收发.Count) := v_出库.Id;
    End Loop;
  
    --药品相关内容
    Fetch c_Stock
      Into r_Stock;
    While c_Stock%Found Loop
    
      --处理药品库存
      If r_Stock.库房id Is Not Null Then
      
        Select Decode(Count(Column_Value), Null, 0, 0, 0, 1)
        Into n_备货卫材
        From Table(l_费用id)
        Where Column_Value = r_Stock.费用id;
      
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) + Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0)
        Where 库房id = r_Stock.库房id And 药品id = r_Stock.药品id And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期)
          Values
            (r_Stock.库房id, r_Stock.药品id, 1, r_Stock.批次, r_Stock.效期,
             Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0), r_Stock.批号, r_Stock.产地,
             r_Stock.灭菌效期);
        End If;
        Delete 药品库存
        Where 库房id = r_Stock.库房id And 药品id = r_Stock.药品id And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1 And
              Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0;
      End If;
    
      --删除药品收发记录(加上并发操作检查:审核人 Is Null)
      --Delete From 药品收发记录 Where ID = r_Stock.ID And 审核人 Is Null;
    
      l_药品收发.Extend;
      l_药品收发(l_药品收发.Count) := r_Stock.Id;
      Fetch c_Stock
        Into r_Stock;
    End Loop;
    Close c_Stock;
  
    --删除药品收发记录
    Forall I In 1 .. l_药品收发.Count
      Delete From 药品收发记录 Where ID = l_药品收发(I) And 审核人 Is Null;
    If Sql%RowCount <> l_药品收发.Count And l_药品收发.Count <> 0 Then
      v_Err_Msg := '要销帐的费用中存在已发的药品或卫材，或已被其他人销帐；这可能是并发操作引起的。';
      Raise Err_Item;
    End If;
  Else
    --删除药品收发记录
    Forall I In 1 .. l_药品收发.Count
      Delete From 药品收发记录 Where ID = l_药品收发(I) And 审核人 Is Null;
  End If;
  --未发药品记录
  Delete From 未发药品记录 A
  Where NO = No_In And 单据 In (9, 10, 25, 26) And Not Exists
   (Select 1
         From 药品收发记录
         Where 单据 = a.单据 And Nvl(库房id, 0) = Nvl(a.库房id, 0) And NO = No_In And Mod(记录状态, 3) = 1 And 审核人 Is Null);

  ---------------------------------------------------------------------------------
  --如果是划价,直接删除费用记录(药品处理后)
  n_Count := l_划价.Count;
  --删除划价记录
  Forall I In 1 .. l_划价.Count
    Delete From 住院费用记录 Where ID = l_划价(I);

  --删除之后再统一调整序号
  If n_Count > 0 Then
    n_Count := 1;
    For r_Serial In c_Serial Loop
      If r_Serial.价格父号 Is Null Then
        v_父号 := n_Count;
      End If;
    
      Update 住院费用记录
      Set 序号 = n_Count, 价格父号 = Decode(价格父号, Null, Null, v_父号)
      Where NO = No_In And 记录性质 = 记录性质_In And 序号 = r_Serial.序号;
    
      Update 住院费用记录
      Set 从属父号 = n_Count
      Where NO = No_In And 记录性质 = 记录性质_In And 从属父号 = r_Serial.序号;
    
      n_Count := n_Count + 1;
    End Loop;
  
  End If;
  --整张单据全部冲完时，删除病人医嘱附费
  If v_序号 Is Null And v_医嘱id Is Not Null Then
    Select Nvl(Count(*), 0)
    Into n_Count
    From (Select 序号, Sum(数量) As 剩余数量
           From (Select 记录状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                  From 住院费用记录
                  Where NO = No_In And 记录性质 = 2 And 医嘱序号 + 0 = v_医嘱id
                  Group By 记录状态, Nvl(价格父号, 序号))
           Group By 序号
           Having Nvl(Sum(数量), 0) <> 0);
    If n_Count = 0 Then
      Delete From 病人医嘱附费 Where 医嘱id = v_医嘱id And 记录性质 = 2 And NO = No_In;
    End If;
  End If;

  If v_医嘱ids Is Not Null Then
    --医嘱处理
    --场合_In    Integer:=0, --0:门诊;1-住院
    --性质_In    Integer:=1, --1-收费单;2-记帐单
    --操作_In    Integer:=0, --0:删除划价单;1-收费或记帐;2-退费或销帐
    --No_In      门诊费用记录.No%Type,
    --医嘱ids_In Varchar2 := Null
    v_医嘱ids := Substr(v_医嘱ids, 2);
    Zl_医嘱发送_计费状态_Update(1, 2, 0, No_In, v_医嘱ids);
  Else
    Zl_医嘱发送_计费状态_Update(1, 2, 2, No_In);
  End If;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_住院记帐记录_Delete;
/


--93827:刘尔旋,2016-03-03,结帐填写票号问题
--93235:刘尔旋,2016-02-24,结帐推送消息
Create Or Replace Procedure Zl_病人结帐记录_Insert
(
  Id_In           病人结帐记录.Id%Type,
  单据号_In       病人结帐记录.No%Type,
  病人id_In       病人结帐记录.病人id%Type,
  收费时间_In     病人结帐记录.收费时间%Type,
  开始日期_In     病人结帐记录.开始日期%Type,
  结束日期_In     病人结帐记录.结束日期%Type,
  中途结帐_In     病人结帐记录.中途结帐%Type := 0,
  多病人结帐_In   Number := 0,
  最大结帐次数_In Number := 0,
  备注_In         病人结帐记录.备注%Type := Null,
  来源_In         Number := 1,
  原因_In         病人结帐记录.原因%Type := Null,
  结帐类型_In     病人结帐记录.结帐类型%Type := 2,
  结算状态_In     病人结帐记录.结算状态%Type := 0,
  住院次数_In     病人结帐记录.住院次数%Type := Null,
  结帐金额_In     病人结帐记录.结帐金额%Type := Null,
  票据号_In       病人结帐记录.实际票号%Type := Null
  --功能：插入一条病人结帐记录
  --1.来源_In:1-门诊;2-住院
) As
  v_Temp     Varchar2(255);
  v_人员编号 人员表.编号%Type;
  v_人员姓名 人员表.姓名%Type;
  v_Error    Varchar2(255);
  Err_Custom Exception;
  n_组id 财务缴款分组.Id%Type;
Begin
  --操作员信息:部门ID,部门名称;人员ID,人员编号,人员姓名
  v_Temp     := Zl_Identity;
  v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  n_组id     := Zl_Get组id(v_人员姓名);

  --病人结帐记录
  Insert Into 病人结帐记录
    (ID, NO, 实际票号, 记录状态, 中途结帐, 病人id, 开始日期, 结束日期, 收费时间, 操作员编号, 操作员姓名, 备注, 原因, 缴款组id, 结帐类型, 结算状态, 主页id, 住院次数, 结帐金额)
  Values
    (Id_In, 单据号_In, 票据号_In, 1, 中途结帐_In, Decode(多病人结帐_In, 1, Null, 病人id_In), 开始日期_In, 结束日期_In, 收费时间_In, v_人员编号, v_人员姓名,
     备注_In, 原因_In, n_组id, 结帐类型_In, Decode(结算状态_In, Null, Null, 0, Null, 结算状态_In), 最大结帐次数_In, 住院次数_In, 结帐金额_In);

  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 15, Id_In;
  Exception
    When Others Then
      Null;
  End;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人结帐记录_Insert;
/

--93333:王振涛,2016-02-24,取消参数控制发料
Create Or Replace Procedure Zl_检验标本记录_标本核收
(
  Id_In         In 检验标本记录.Id%Type,
  医嘱id_In     In 检验标本记录.医嘱id%Type,
  多个医嘱_In   In Varchar2, --用于更新多个医嘱的执行状态
  复盖标本id_In In 检验标本记录.Id%Type := 0, --补填时指向另一个标本时复盖指向的标本
  标本序号_In   In 检验标本记录.标本序号%Type,
  采样时间_In   In 检验标本记录.采样时间%Type,
  采样人_In     In 检验标本记录.采样人%Type,
  仪器id_In     In 检验标本记录.仪器id%Type,
  核收时间_In   In 检验标本记录.核收时间%Type,
  标本形态_In   In 检验标本记录.标本形态%Type,
  检验人_In     In 检验标本记录.检验人%Type := Null,
  检验时间_In   In 检验标本记录.检验时间%Type := Null,
  微生物标本_In In 检验标本记录.微生物标本%Type := Null,
  标本类别_In   In 检验标本记录.标本类别%Type := 0,
  检验备注_In   In 检验标本记录.检验备注%Type := Null,
  姓名_In       In 检验标本记录.姓名%Type := Null,
  性别_In       In 检验标本记录.性别%Type := Null,
  年龄_In       In 检验标本记录.年龄%Type := Null,
  No_In         In 检验标本记录.No%Type := Null,
  标本类型_In   In 检验标本记录.标本类型%Type := Null,
  申请科室id_In In 检验标本记录.申请科室id%Type := Null,
  申请人_In     In 检验标本记录.申请人%Type := Null,
  标识号_In     In 检验标本记录.标识号%Type := Null,
  床号_In       In 检验标本记录.床号%Type := Null,
  病人科室_In   In 检验标本记录.病人科室%Type := Null,
  检验项目_In   In 检验标本记录.检验项目%Type := Null,
  申请类型_In   In 检验标本记录.申请类型%Type := Null,
  病人id_In     In 检验标本记录.病人id%Type := Null,
  执行科室_In   In 检验标本记录.执行科室id%Type := Null,
  人员编号_In   In 人员表.编号%Type := Null,
  人员姓名_In   In 人员表.姓名%Type := Null
) Is

  Cursor v_Advice Is
    Select /*+ Rule */
    Distinct a.Id, a.开嘱时间, a.标本部位, f.样本条码, a.执行科室id, a.诊疗项目id, a.开嘱科室id, a.开嘱医生, a.病人id, a.病人来源, a.婴儿, a.紧急标志 As 紧急,
             b.门诊号, b.住院号, b.出生日期, a.挂号单, Decode(c.主页id, 0, Null, c.主页id) As 主页id, d.操作类型, f.接收人, f.接收时间
    From 病人医嘱记录 A, 病人医嘱发送 F, 病人信息 B, 病案主页 C, 诊疗项目目录 D
    Where a.相关id In (Select * From Table(Cast(f_Num2list(多个医嘱_In) As Zltools.t_Numlist))) And a.Id = f.医嘱id And
          a.病人id = b.病人id And a.病人id = c.病人id(+) And a.主页id = c.主页id(+) And a.诊疗项目id = d.Id(+);

  Cursor v_Advice_1 Is
    Select /*+ Rule */
    Distinct b.No As 单据号
    From 病人医嘱记录 A, 病人医嘱发送 B
    Where a.Id = b.医嘱id And a.相关id In (Select * From Table(Cast(f_Num2list(多个医嘱_In) As Zltools.t_Numlist)))
    Union All
    Select /*+ Rule */
    Distinct b.No As 单据号
    From 病人医嘱记录 A, 病人医嘱发送 B
    Where a.Id = b.医嘱id And a.Id In (Select * From Table(Cast(f_Num2list(多个医嘱_In) As Zltools.t_Numlist)));

  Cursor v_Patient Is
    Select 病人id, 住院号, 门诊号, 出生日期 From 病人信息 Where 病人id = 病人id_In;

  --未审核的费用行(不包含药品)
  Cursor c_Verify(v_医嘱id In Number) Is
    Select /*+ Rule */
    Distinct a.记录性质, a.No, a.序号, a.医嘱序号, a.门诊标志
    From 住院费用记录 A, 病人医嘱发送 B,
         (Select ID
           From 病人医嘱记录
           Where ID In (Select * From Table(Cast(f_Num2list(多个医嘱_In) As Zltools.t_Numlist)))
           Union All
           Select ID
           From 病人医嘱记录
           Where 相关id In (Select * From Table(Cast(f_Num2list(多个医嘱_In) As Zltools.t_Numlist)))) C
    Where a.收费类别 Not In ('5', '6', '7') And a.医嘱序号 = c.Id And a.记录状态 = 0 And 价格父号 Is Null And a.医嘱序号 = b.医嘱id And
          a.记录性质 = b.记录性质 And a.No = b.No And a.记帐费用 = 1
    Union All
    Select /*+ Rule */
    Distinct a.记录性质, a.No, a.序号, a.医嘱序号, a.门诊标志
    From 住院费用记录 A, 病人医嘱附费 B,
         (Select ID
           From 病人医嘱记录
           Where ID In (Select * From Table(Cast(f_Num2list(多个医嘱_In) As Zltools.t_Numlist)))
           Union All
           Select ID
           From 病人医嘱记录
           Where 相关id In (Select * From Table(Cast(f_Num2list(多个医嘱_In) As Zltools.t_Numlist)))) C
    Where a.收费类别 Not In ('5', '6', '7') And a.医嘱序号 = c.Id And a.记录状态 = 0 And 价格父号 Is Null And a.医嘱序号 = b.医嘱id And
          a.记录性质 = b.记录性质 And a.No = b.No And a.记帐费用 = 1
    Union All
    Select /*+ Rule */
    Distinct a.记录性质, a.No, a.序号, a.医嘱序号, a.门诊标志
    From 门诊费用记录 A, 病人医嘱发送 B,
         (Select ID
           From 病人医嘱记录
           Where ID In (Select * From Table(Cast(f_Num2list(多个医嘱_In) As Zltools.t_Numlist)))
           Union All
           Select ID
           From 病人医嘱记录
           Where 相关id In (Select * From Table(Cast(f_Num2list(多个医嘱_In) As Zltools.t_Numlist)))) C
    Where a.收费类别 Not In ('5', '6', '7') And a.医嘱序号 = c.Id And a.记录状态 = 0 And 价格父号 Is Null And a.医嘱序号 = b.医嘱id And
          a.记录性质 = b.记录性质 And a.No = b.No And a.记帐费用 = 1
    Union All
    Select /*+ Rule */
    Distinct a.记录性质, a.No, a.序号, a.医嘱序号, a.门诊标志
    From 门诊费用记录 A, 病人医嘱附费 B,
         (Select ID
           From 病人医嘱记录
           Where ID In (Select * From Table(Cast(f_Num2list(多个医嘱_In) As Zltools.t_Numlist)))
           Union All
           Select ID
           From 病人医嘱记录
           Where 相关id In (Select * From Table(Cast(f_Num2list(多个医嘱_In) As Zltools.t_Numlist)))) C
    Where a.收费类别 Not In ('5', '6', '7') And a.医嘱序号 = c.Id And a.记录状态 = 0 And 价格父号 Is Null And a.医嘱序号 = b.医嘱id And
          a.记录性质 = b.记录性质 And a.No = b.No And a.记帐费用 = 1
    Order By 记录性质, NO, 序号;

  --查找当前标本的相关申请
  Cursor c_Samplequest(v_微生物 In Number) Is
    Select Distinct 医嘱id, 病人来源
    From (Select Decode(a.医嘱id, Null, b.医嘱id, a.医嘱id) As 医嘱id, b.病人来源
           From 检验项目分布 A, 检验标本记录 B
           Where Nvl(v_微生物, 0) = 0 And a.标本id = b.Id And b.医嘱id In (Select 医嘱id From 检验标本记录 Where ID = Id_In) And
                 a.医嘱id Is Not Null
           Union
           Select Decode(a.医嘱id, Null, b.医嘱id, a.医嘱id) As 医嘱id, b.病人来源
           From 检验项目分布 A, 检验标本记录 B
           Where 1 = v_微生物 And b.Id = a.标本id And b.Id = Id_In
           Union
           Select b.Id As 医嘱id, b.病人来源
           From 检验标本记录 A, 病人医嘱记录 B
           Where a.Id = Id_In And a.医嘱id In (b.Id, b.相关id));

  Cursor c_Stuff
  (
    v_No     Varchar2,
    v_主页id Number
  ) Is
    Select NO As 单据号, 单据, 库房id
    From 未发药品记录
    Where NO = v_No And 单据 In (24, 25, 26) And 库房id Is Not Null And Not Exists
     (Select 1 From Dual Where Zl_Getsysparameter(Decode(v_主页id, Null, 92, 63)) = '1') And Exists
     (Select a.序号
           From 住院费用记录 A, 材料特性 B
           Where a.记录性质 = 2 And a.No = v_No And a.收费细目id = b.材料id And b.跟踪在用 = 1
           Union All
           Select a.序号
           From 门诊费用记录 A, 材料特性 B
           Where a.记录性质 = 2 And a.No = v_No And a.收费细目id = b.材料id And b.跟踪在用 = 1)
    Order By 库房id;

  r_Advice   v_Advice%Rowtype;
  r_Advice_1 v_Advice_1%Rowtype;
  r_Patient  v_Patient%Rowtype;

  Err_Custom Exception;
  v_Error Varchar2(1000);
  v_Flag  Number(18);

  v_Temp      Varchar2(255);
  v_Seq       Number;
  v_Union     Number;
  v_Patientid Number;
  v_Itemid    Number;
  v_Count     Number;
  v_No        病人医嘱发送.No%Type;
  v_性质      病人医嘱发送.记录性质%Type;
  v_序号      Varchar2(1000);
  v_主页id    Number(18);
  v_门诊标志  住院费用记录.门诊标志%Type;
  n_Count     Number;
  v_姓名      病人医嘱记录.姓名%Type;
  v_性别      病人医嘱记录.性别%Type;
  v_年龄      病人医嘱记录.年龄%Type;
  v_病人来源  病人医嘱记录.病人来源%Type;
  v_婴儿      病人医嘱记录.婴儿%Type;
  v_婴儿姓名  病人医嘱记录.姓名%Type;
  v_婴儿性别  病人医嘱记录.性别%Type;
Begin

  If Nvl(复盖标本id_In, 0) > 0 Then
    Begin
      Select 姓名 Into v_Temp From 检验标本记录 Where ID = 复盖标本id_In And 姓名 Is Null;
    Exception
      When Others Then
        v_Error := '指定复盖的标本已被核收或已删除，请重新指定！';
        Raise Err_Custom;
    End;
  End If;

  If Nvl(医嘱id_In, 0) > 0 Then
    Select 姓名, 性别, 年龄, 病人来源, 婴儿
    Into v_姓名, v_性别, v_年龄, v_病人来源, v_婴儿
    From 病人医嘱记录
    Where ID = 医嘱id_In;
  
    If v_病人来源 <> 3 Then
      If Nvl(v_婴儿, 0) = 0 Then
        If v_姓名 <> 姓名_In Or v_性别 <> 性别_In  Then
          v_Error := '病人姓名、性别、年龄和医嘱不符不能保存，请检查或修改病人信息后再进行保存！';
          Raise Err_Custom;
        End If;
      Else
        Select b.婴儿姓名, b.婴儿性别
        Into v_婴儿姓名, v_婴儿性别
        From 病人医嘱记录 A, 病人新生儿记录 B
        Where a.病人id = b.病人id And a.主页id = b.主页id And a.婴儿 = b.序号 And
              a.相关id In (Select * From Table(Cast(f_Num2list(多个医嘱_In) As Zltools.t_Numlist))) And Rownum = 1;
      
        If v_婴儿姓名 <> 姓名_In Or v_婴儿性别 <> 性别_In Then
          v_Error := '病人姓名、性别、年龄和医嘱不符不能保存，请检查或修改病人信息后再进行保存！';
          Raise Err_Custom;
        End If;
      End If;
    End If;
  
    Select Count(ID) Into v_Flag From 检验标本记录 Where 医嘱id = 医嘱id_In And ID <> Id_In;
    If v_Flag > 0 Then
      Select Count(Distinct b.报告项目id)
      Into v_Flag
      From 病人医嘱记录 A, 检验报告项目 B
      Where a.诊疗项目id = b.诊疗项目id And a.相关id In (Select * From Table(Cast(f_Num2list(多个医嘱_In) As Zltools.t_Numlist)));
    
      Select Count(a.项目id)
      Into n_Count
      From 检验项目分布 A
      Where a.医嘱id In (Select * From Table(Cast(f_Num2list(多个医嘱_In) As Zltools.t_Numlist))) And a.标本id <> Id_In;
      If (v_Flag - n_Count) <= 0 Then
        v_Error := '当前医嘱已被核收，不能重复核收！';
        Raise Err_Custom;
      End If;
    End If;
  End If;

  If 医嘱id_In = 0 Then
    Open v_Patient;
    Fetch v_Patient
      Into r_Patient;
  
    If v_Patient%Found Then
      Zl_病人信息_锁定检查(r_Patient.病人id);
    End If;
  
    Update 检验标本记录
    Set 采样时间 = Decode(采样时间_In, Null, 采样时间, 采样时间_In), 采样人 = Decode(采样人_In, Null, 采样人, 采样人_In), 标本类型 = Nvl(标本类型_In, 标本类型),
        检验时间 = 检验时间_In, 姓名 = Decode(姓名_In, Null, 姓名, 姓名_In), 性别 = Decode(性别_In, Null, 性别, 性别_In),
        年龄 = Decode(年龄_In, Null, 年龄, 年龄_In), 年龄数字 = Decode(年龄_In, Null, Null, Zl_Val(年龄_In)),
        年龄单位 = Decode(年龄_In, Null, 年龄单位,
                       Decode(年龄_In, Null, Null, '成人', '成人', '婴儿', '婴儿',
                               Decode(Sign(Instr(年龄_In, '岁')), 1, '岁',
                                       Decode(Sign(Instr(年龄_In, '月')), 1, '月',
                                               Decode(Sign(Instr(年龄_In, '天')), 1, '天',
                                                       Decode(Sign(Instr(年龄_In, '小时')), 1, '小时', Null)))))),
        申请科室id = Decode(申请科室id_In, Null, 申请科室id, 申请科室id_In), 申请人 = Decode(申请人_In, Null, 申请人, 申请人_In),
        标本形态 = Decode(标本形态_In, Null, 标本形态, 标本形态_In), 标识号 = Decode(标识号_In, Null, 标识号, 标识号_In),
        床号 = Decode(床号_In, Null, 床号, 床号_In), 病人科室 = Decode(病人科室_In, Null, 病人科室, 病人科室_In),
        检验项目 = Decode(检验项目_In, Null, 检验项目, 检验项目_In), 病人id = Decode(病人id_In, Null, 病人id, 病人id_In),
        医嘱id = Decode(医嘱id_In, Null, 医嘱id, 0, 医嘱id, 医嘱id_In)
    Where ID = Id_In;
    If Sql%NotFound Then
      Insert Into 检验标本记录
        (ID, 医嘱id, 标本序号, 采样时间, 采样人, 标本类型, 核收人, 核收时间, 样本状态, 申请类型, 仪器id, 样本条码, 申请时间, 标本形态, 报告结果, 执行科室id, 检验人, 检验时间, 微生物标本,
         标本类别, 检验备注, 申请科室id, 申请人, 姓名, 性别, 年龄, 年龄数字, 年龄单位, 病人id, 病人来源, 婴儿, NO, 合并id, 标识号, 床号, 病人科室, 紧急, 门诊号, 住院号, 出生日期,
         挂号单, 主页id, 检验项目, 操作类型, 接收人, 接收时间)
      Values
        (Id_In, Decode(医嘱id_In, 0, Null, 医嘱id_In), 标本序号_In, 采样时间_In, 采样人_In, 标本类型_In, 人员姓名_In, 核收时间_In, 1, 申请类型_In,
         Decode(仪器id_In, 0, Null, 仪器id_In), Null, Null, 标本形态_In, 0, 执行科室_In, 检验人_In, 检验时间_In, 微生物标本_In, 标本类别_In, 检验备注_In,
         申请科室id_In, 申请人_In, 姓名_In, 性别_In, 年龄_In, Zl_Val(年龄_In),
         Decode(年龄_In, Null, Null, '成人', '成人', '婴儿', '婴儿',
                 Decode(Sign(Instr(年龄_In, '岁')), 1, '岁',
                         Decode(Sign(Instr(年龄_In, '月')), 1, '月',
                                 Decode(Sign(Instr(年龄_In, '天')), 1, '天', Decode(Sign(Instr(年龄_In, '小时')), 1, '小时', Null))))),
         病人id_In, Decode(r_Patient.住院号, Null, Decode(r_Patient.门诊号, Null, 3, 1), 2), 0, Null, Null, 标识号_In, 床号_In,
         病人科室_In, 标本类别_In, r_Patient.门诊号, r_Patient.住院号, r_Patient.出生日期, Null, Null, 检验项目_In, Null, Null, Null);
    End If;
    If Nvl(复盖标本id_In, 0) > 0 Then
      Zl_检验标本记录_Union(Id_In, 复盖标本id_In);
    End If;
    --记录核收和补填操作
    Insert Into 检验操作记录
      (ID, 标本id, 操作类型, 操作员, 操作时间)
    Values
      (检验操作记录_Id.Nextval, Id_In, 2, 人员姓名_In, Sysdate);
    Close v_Patient;
  Else
    Open v_Advice;
    Fetch v_Advice
      Into r_Advice;
  
    If v_Advice%Found Then
      Zl_病人信息_锁定检查(r_Advice.病人id);
    End If;
  
    Update 检验标本记录
    Set 医嘱id = Decode(医嘱id_In, Null, 医嘱id, 0, 医嘱id, 医嘱id_In), 采样时间 = Decode(采样时间_In, Null, 采样时间, 采样时间_In),
        采样人 = Decode(采样人_In, Null, 采样人, 采样人_In), 标本序号 = Decode(标本序号_In, Null, 标本序号, 标本序号_In),
        标本类型 = Decode(标本类型_In, Null, Decode(标本类型, Null, r_Advice.标本部位, 标本类型), 标本类型_In),
        申请时间 = Decode(r_Advice.开嘱时间, Null, 申请时间, r_Advice.开嘱时间), 核收人 = Decode(核收人, Null, 人员姓名_In, 核收人),
        样本条码 = Decode(r_Advice.样本条码, Null, 样本条码, r_Advice.样本条码), 申请类型 = Decode(申请类型_In, Null, 申请类型, 申请类型_In),
        执行科室id = Decode(执行科室_In, Null, 执行科室id, 执行科室_In), 检验人 = Decode(检验人_In, Null, 检验人, 检验人_In),
        检验时间 = Decode(检验时间_In, Null, 检验时间, 检验时间_In), 检验备注 = Decode(检验备注_In, Null, 检验备注, 检验备注_In),
        申请科室id = Decode(申请科室id_In, Null, 申请科室id, 申请科室id_In), 申请人 = Decode(申请人_In, Null, 申请人, 申请人_In),
        姓名 = Decode(姓名_In, Null, 姓名, 姓名_In), 性别 = Decode(性别_In, Null, 性别, 性别_In), 年龄 = Decode(年龄_In, Null, 年龄, 年龄_In),
        年龄数字 = Decode(年龄_In, Null, 年龄数字, Zl_Val(年龄_In)),
        年龄单位 = Decode(年龄_In, Null, 年龄单位,
                       Decode(年龄_In, Null, Null, '成人', '成人', '婴儿', '婴儿',
                               Decode(Sign(Instr(年龄_In, '岁')), 1, '岁',
                                       Decode(Sign(Instr(年龄_In, '月')), 1, '月',
                                               Decode(Sign(Instr(年龄_In, '天')), 1, '天',
                                                       Decode(Sign(Instr(年龄_In, '小时')), 1, '小时', Null)))))),
        病人id = Decode(r_Advice.病人id, Null, 病人id, r_Advice.病人id), 病人来源 = Decode(r_Advice.病人来源, Null, 病人来源, r_Advice.病人来源),
        婴儿 = Decode(r_Advice.婴儿, 婴儿, r_Advice.婴儿), NO = Decode(No_In, Null, NO, No_In), 合并id = v_Union,
        标本形态 = Decode(标本形态_In, Null, 标本形态, 标本形态_In), 标识号 = Decode(标识号_In, Null, 标识号, 标识号_In),
        床号 = Decode(床号_In, Null, 床号, 床号_In), 病人科室 = Decode(病人科室_In, Null, 病人科室, 病人科室_In), 标本类别 = 标本类别_In,
        门诊号 = r_Advice.门诊号, 住院号 = r_Advice.住院号, 出生日期 = r_Advice.出生日期, 挂号单 = r_Advice.挂号单, 主页id = r_Advice.主页id,
        检验项目 = Decode(检验项目_In, Null, 检验项目, 检验项目_In), 操作类型 = r_Advice.操作类型, 接收人 = r_Advice.接收人, 接收时间 = r_Advice.接收时间
    Where ID = Id_In;
  
    If Sql%NotFound Then
      Insert Into 检验标本记录
        (ID, 医嘱id, 标本序号, 采样时间, 采样人, 标本类型, 核收人, 核收时间, 样本状态, 申请类型, 仪器id, 样本条码, 申请时间, 标本形态, 报告结果, 执行科室id, 检验人, 检验时间, 微生物标本,
         标本类别, 检验备注, 申请科室id, 申请人, 姓名, 性别, 年龄, 年龄数字, 年龄单位, 病人id, 病人来源, 婴儿, NO, 合并id, 标识号, 床号, 病人科室, 紧急, 门诊号, 住院号, 出生日期,
         挂号单, 主页id, 检验项目, 操作类型, 接收人, 接收时间)
      Values
        (Id_In, Decode(医嘱id_In, 0, Null, 医嘱id_In), 标本序号_In, 采样时间_In, 采样人_In, Nvl(标本类型_In, r_Advice.标本部位), 人员姓名_In,
         核收时间_In, 1, 申请类型_In, Decode(仪器id_In, 0, Null, 仪器id_In), r_Advice.样本条码, r_Advice.开嘱时间, 标本形态_In, 0, 执行科室_In,
         检验人_In, 检验时间_In, 微生物标本_In, 标本类别_In, 检验备注_In, 申请科室id_In, 申请人_In, 姓名_In, 性别_In, 年龄_In, Zl_Val(年龄_In),
         Decode(年龄_In, Null, Null, '成人', '成人', '婴儿', '婴儿',
                 Decode(Sign(Instr(年龄_In, '岁')), 1, '岁',
                         Decode(Sign(Instr(年龄_In, '月')), 1, '月',
                                 Decode(Sign(Instr(年龄_In, '天')), 1, '天', Decode(Sign(Instr(年龄_In, '小时')), 1, '小时', Null))))),
         r_Advice.病人id, r_Advice.病人来源, r_Advice.婴儿, No_In, v_Union, 标识号_In, 床号_In, 病人科室_In, r_Advice.紧急, r_Advice.门诊号,
         r_Advice.住院号, r_Advice.出生日期, r_Advice.挂号单, r_Advice.主页id, 检验项目_In, r_Advice.操作类型, r_Advice.接收人, r_Advice.接收时间);
    End If;
    If Nvl(复盖标本id_In, 0) > 0 Then
      Zl_检验标本记录_Union(Id_In, 复盖标本id_In);
    End If;
    Insert Into 检验操作记录
      (ID, 标本id, 操作类型, 操作员, 操作时间)
    Values
      (检验操作记录_Id.Nextval, Id_In, 2, 人员姓名_In, Sysdate);
  
    --查找主项目有时填写合并ID
    Begin
      Select a.Id
      Into v_Union
      From 检验标本记录 A, 检验标本记录 B, 病人医嘱记录 C, 检验合并规则 D, 病人医嘱记录 E
      Where a.病人id = b.病人id And b.Id = Id_In And a.样本状态 = 1 And Nvl(a.病人id, 0) <> 0 And a.医嘱id = c.相关id And
            d.主项目id = c.诊疗项目id And d.合并项目id = e.诊疗项目id And e.Id = r_Advice.Id And Rownum = 1
      Order By a.核收时间 Desc;
    Exception
      When Others Then
        v_Union := Null;
    End;
    If Nvl(v_Union, 0) <> 0 Then
      Update 检验标本记录 Set 合并id = v_Union Where (ID = Id_In Or 医嘱id = r_Advice.Id);
    End If;
    --查找有了主项目时填写合并项目
    Begin
      Select a.Id, a.病人id, c.主项目id
      Into v_Union, v_Patientid, v_Itemid
      From 检验标本记录 A, 病人医嘱记录 B, 检验合并规则 C
      Where a.医嘱id = b.相关id And b.诊疗项目id = c.主项目id And a.Id = Id_In And Rownum = 1;
    Exception
      When Others Then
        v_Union := Null;
    End;
    If Nvl(v_Union, 0) <> 0 Then
      Update 检验标本记录
      Set 合并id = v_Union
      Where ID In (Select a.Id
                   From 检验标本记录 A, 病人医嘱记录 B, 检验合并规则 C
                   Where a.医嘱id = b.相关id And b.诊疗项目id = c.合并项目id And c.主项目id = v_Itemid And a.病人id = v_Patientid And
                         a.样本状态 = 1);
    End If;
  
    v_Seq := 1;
    Close v_Advice;
    v_Flag := 0;
    Begin
      Select Nvl(Max(1), 0) Into v_Flag From 检验申请项目 Where 标本id = Id_In;
    Exception
      When Others Then
        v_Flag := 0;
    End;
    If v_Flag = 0 Then
      For r_Advice In v_Advice Loop
        Update 检验申请项目
        Set 标本id = Id_In, 诊疗项目id = r_Advice.诊疗项目id
        Where 标本id = Id_In And 诊疗项目id = r_Advice.诊疗项目id;
        If Sql%Rowcount = 0 Then
          Insert Into 检验申请项目 (标本id, 诊疗项目id, 序号) Values (Id_In, r_Advice.诊疗项目id, v_Seq);
        End If;
        v_Seq := v_Seq + 1;
      End Loop;
    End If;
  
  End If;

  --根据参数来判断是否发料
    For r_Advice_1 In v_Advice_1 Loop
      --如果记帐没有自动发料,则自动发料,否则不处理
      For r_Stuff In c_Stuff(r_Advice_1.单据号, v_主页id) Loop
      
        Zl_材料收发记录_处方发料(r_Stuff.库房id, r_Stuff.单据, r_Stuff.单据号, 人员姓名_In, 人员姓名_In, 人员姓名_In, 1, Sysdate);
      End Loop;
    End Loop;

  Update /*+ Rule */ 病人医嘱发送
  Set 执行状态 = 3
  Where 执行状态 = 0 And
        医嘱id In (Select ID
                 From 病人医嘱记录
                 Where ID In (Select * From Table(Cast(f_Num2list(多个医嘱_In) As Zltools.t_Numlist)))
                 Union All
                 Select ID
                 From 病人医嘱记录
                 Where 相关id In (Select * From Table(Cast(f_Num2list(多个医嘱_In) As Zltools.t_Numlist))));


  --2.检查当前标本相关的申请的相关标本是否完成审核
  For r_Samplequest In c_Samplequest(微生物标本_In) Loop
  
    v_Count := 0;
  
    --r_SampleQuest.医嘱id申请已经完成,处理后续环节
    If v_Count = 0 Then
    
      If r_Samplequest.病人来源 = 2 Then
        Update 住院费用记录
        Set 执行状态 = 1, 执行时间 = Sysdate, 执行人 = 人员姓名_In
        Where 收费类别 Not In ('5', '6', '7') And
              (医嘱序号, 记录性质, NO) In
              (Select 医嘱id, 记录性质, NO
               From 病人医嘱附费
               Where 医嘱id = r_Samplequest.医嘱id
               Union All
               Select 医嘱id, 记录性质, NO
               From 病人医嘱发送
               Where 医嘱id In (Select ID From 病人医嘱记录 Where r_Samplequest.医嘱id In (ID, 相关id)));
      Else
        Update 门诊费用记录
        Set 执行状态 = 1, 执行时间 = Sysdate, 执行人 = 人员姓名_In
        Where 收费类别 Not In ('5', '6', '7') And
              (医嘱序号, 记录性质, NO) In
              (Select 医嘱id, 记录性质, NO
               From 病人医嘱附费
               Where 医嘱id = r_Samplequest.医嘱id
               Union All
               Select 医嘱id, 记录性质, NO
               From 病人医嘱发送
               Where 医嘱id In (Select ID From 病人医嘱记录 Where r_Samplequest.医嘱id In (ID, 相关id)));
      End If;
      --3.自动审核记帐
        For r_Verify In c_Verify(r_Samplequest.医嘱id) Loop
          If r_Verify.No || ',' || r_Verify.记录性质 <> v_No || ',' || v_性质 Then
            If v_序号 Is Not Null Then
              If r_Verify.门诊标志 = 1 Then
                Zl_门诊记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
              Elsif r_Verify.门诊标志 = 2 Then
                Zl_住院记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
              End If;
            End If;
            v_序号 := Null;
          End If;
          v_门诊标志 := r_Verify.门诊标志;
          v_No       := r_Verify.No;
          v_性质     := r_Verify.记录性质;
          v_序号     := v_序号 || ',' || r_Verify.序号;
        End Loop;
        If v_序号 Is Not Null Then
          If v_门诊标志 = 1 Then
            Zl_门诊记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
          Elsif v_门诊标志 = 2 Then
            Zl_住院记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
          End If;
        End If;
    
    End If;
  End Loop;

  If Nvl(申请类型_In, 0) = 1 Then
    Zl_病人医嘱记录_屏蔽打印(医嘱id_In, 1);
  End If;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_检验标本记录_标本核收;
/

--93144:李南春,2016-02-29,预交退款金额检查
Create Or Replace Procedure Zl_病人预交记录_Insert
(
  Id_In         病人预交记录.Id%Type,
  单据号_In     病人预交记录.No%Type,
  票据号_In     票据使用明细.号码%Type,
  病人id_In     病人预交记录.病人id%Type,
  主页id_In     病人预交记录.主页id%Type,
  科室id_In     病人预交记录.科室id%Type,
  金额_In       病人预交记录.金额%Type,
  结算方式_In   病人预交记录.结算方式%Type,
  结算号码_In   病人预交记录.结算号码%Type,
  缴款单位_In   病人预交记录.缴款单位%Type,
  单位开户行_In 病人预交记录.单位开户行%Type,
  单位帐号_In   病人预交记录.单位帐号%Type,
  摘要_In       病人预交记录.摘要%Type,
  操作员编号_In 病人预交记录.操作员编号%Type,
  操作员姓名_In 病人预交记录.操作员姓名%Type,
  领用id_In     票据使用明细.领用id%Type,
  预交类别_In   病人预交记录.预交类别%Type := Null,
  卡类别id_In   病人预交记录.卡类别id%Type := Null,
  结算卡序号_In 病人预交记录.结算卡序号%Type := Null,
  卡号_In       病人预交记录.卡号%Type := Null,
  交易流水号_In 病人预交记录.交易流水号%Type := Null,
  交易说明_In   病人预交记录.交易说明%Type := Null,
  合作单位_In   病人预交记录.合作单位%Type := Null,
  收款时间_In   病人预交记录.收款时间%Type := Null,
  操作类型_In   Integer := 0,
  结帐id_In     病人预交记录.结帐id%Type := Null,
  结算性质_In   病人预交记录.结算性质%Type := Null,
  退款方式_In   Number := 0
) As
  ----------------------------------------------
  --操作类型_In:0-正常缴预交;1-存为划价单;3-余额退款
  --结帐ID_IN:>0时,表示某次结帐时,同步产生的预交记录
  --退款方式_In;0-提示;1-禁止；2-忽略

  v_Err_Msg Varchar2(200);
  n_Err_Num Number;
  Err_Item Exception;

  v_性质   结算方式.性质%Type;
  v_打印id 票据打印内容.Id%Type;
  v_担保   病人信息.担保性质%Type;
  v_Date   Date;
  n_返回值 病人余额.预交余额%Type;
  n_组id   财务缴款分组.Id%Type;
  n_病人余额 病人余额.预交余额%Type;
  n_三方预交 病人余额.预交余额%Type;
Begin
  v_Date := 收款时间_In;
  If v_Date Is Null Then
    Select Sysdate Into v_Date From Dual;
  End If;
  n_组id := Zl_Get组id(操作员姓名_In);

  --插入预交缴款记录
  Insert Into 病人预交记录
    (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要, 缴款组id, 预交类别,
     卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 冲预交, 结算性质)
  Values
    (Id_In, 单据号_In, 票据号_In, 1, Decode(操作类型_In, 1, 0, 1), 病人id_In, Decode(主页id_In, 0, Null, 主页id_In),
     Decode(科室id_In, 0, Null, 科室id_In), 金额_In, 结算方式_In, 结算号码_In, v_Date, 缴款单位_In, 单位开户行_In, 单位帐号_In, 操作员编号_In, 操作员姓名_In,
     摘要_In, n_组id, 预交类别_In, 卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, 合作单位_In, 结帐id_In,
     Decode(结帐id_In, Null, Null, 0), 结算性质_In);
  If 操作类型_In = 1 Then
    --暂不处理汇总表
    Return;
  End If;

  --处理票据
  If 票据号_In Is Not Null Then
    Select 票据打印内容_Id.Nextval Into v_打印id From Dual;
  
    --发出票据
    Insert Into 票据打印内容 (ID, 数据性质, NO) Values (v_打印id, 2, 单据号_In);
  
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
    Values
      (票据使用明细_Id.Nextval, 2, 票据号_In, 1, 1, 领用id_In, v_打印id, v_Date, 操作员姓名_In);
  
    --状态改动
    Update 票据领用记录
    Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
    Where ID = Nvl(领用id_In, 0);
  End If;

  --相关汇总表处理

  --病人余额(预交余额现收)
  Begin
    Select 性质 Into v_性质 From 结算方式 Where 名称 = 结算方式_In;
  Exception
    When Others Then
      Null;
  End;
  If Nvl(v_性质, 1) <> 5 Then
    Update 病人余额
    Set 预交余额 = Nvl(预交余额, 0) + 金额_In
    Where 性质 = 1 And 病人id = 病人id_In And Nvl(类型, 0) = Nvl(预交类别_In, 0)
    Returning 预交余额 Into n_返回值;
    If Sql%RowCount = 0 Then
      Insert Into 病人余额
        (病人id, 性质, 类型, 预交余额, 费用余额)
      Values
        (病人id_In, 1, Nvl(预交类别_In, 0), 金额_In, 0);
      n_返回值 := 金额_In;
    End If;
    If Nvl(金额_In, 0) = 0 Then
      Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
    End If;
  End If;
  
  If 金额_In<0 then
    Begin
      Select Nvl(预交余额,0)-Nvl(费用余额,0) into n_病人余额 From 病人余额 Where 性质 = 1 And 病人id = 病人id_In And Nvl(类型, 0) = Nvl(预交类别_In, 0);
    Exception
      When Others Then
        Null;
    End;
    --余额退款要考虑三方预交是否支持退现
    IF 操作类型_In = 3 then
      For c_三方预交 In (Select A.预交ID,A.预交类别,A.卡类别ID,A.结算卡序号 as 消费接口ID,nvl(B.编码,C.编号) as 编码,nvl(B.名称,C.名称) as 名称,
                              Decode(B.编码,NULL,C.是否全退,B.是否全退) as 是否全退,Decode(B.编码,NULL,C.是否退现,B.是否退现) as 是否退现,
                              A.卡号,A.交易流水号,A.交易说明,          A.预交余额
                              From (   Select A.预交类别,nvl(A.卡类别ID,0) as 卡类别ID,nvl(A.结算卡序号,0) as 结算卡序号,
                              A.卡号,A.交易流水号,A.交易说明,           max(decode(sign(金额),-1, decode(A.记录状态,1,0,2,0,ID),ID)) as 预交ID,
                              nvl(sum(金额),0)-nvl(sum(nvl(冲预交,0)),0) as 预交余额    From 病人预交记录 A    Where   A.病人ID=病人id_In and (nvl(A.结算卡序号,0)<>0 or nvl(卡类别ID,0)<>0)
                              Group by A.预交类别,nvl(A.卡类别ID,0),nvl(A.结算卡序号,0),A.卡号,A.交易流水号,A.交易说明
                              Having nvl(sum(金额),0)-nvl(sum(nvl(冲预交,0)),0)  <>0 ) A,医疗卡类别 B,卡消费接口目录 C
                              Where A.预交类别 =Nvl(预交类别_In, 0) And  A.卡类别ID=B.ID(+)  and A.结算卡序号=C.编号(+)  and nvl(A.预交余额,0)<>0   Order by 编码,A.卡号,A.交易流水号,A.交易说明) Loop

        IF instr(',7,8,',','|| v_性质 || ',') =0 And Nvl(c_三方预交.是否退现,0) = 0 And Nvl(c_三方预交.预交余额,0) > 0 Then
          n_三方预交:= Nvl(n_三方预交,0) + Nvl(c_三方预交.预交余额,0);
        ElsIf instr(',7,8,',','|| v_性质 || ',') >0 Then
              If Nvl(c_三方预交.卡号,'0') = Nvl(卡号_In,'0') And Nvl(c_三方预交.交易流水号,'0')= Nvl(交易流水号_In,'0') And Nvl(c_三方预交.交易说明,'0') = Nvl(交易说明_In,'0') then
                n_三方预交:= Nvl(n_三方预交,0) + Nvl(c_三方预交.预交余额,0);
              End if;
        End IF;
      End Loop;
    End if;
    
    If instr(',7,8,',','|| v_性质 || ',') > 0 And Nvl(n_三方预交,0) < 0 And 操作类型_In = 3 Then
        n_Err_Num := -20101;
        v_Err_Msg :='退款金额大于病人三方预交金额，不能继续！';
        Raise Err_Item;
    ElsIf Nvl(n_病人余额,0) < 0 And 退款方式_In <> 2 Then
        n_Err_Num := -20101;
        v_Err_Msg :='退款金额大于病人剩余预交余额，不能继续！';
        If 退款方式_In = 0 Then
          n_Err_Num := -20111;
          v_Err_Msg :='退款金额大于病人剩余预交余额，是否忽略？';
        End If;
        Raise Err_Item;
    ElsIf instr(',7,8,',','|| v_性质 || ',') = 0 And Nvl(n_病人余额,0) - Nvl(n_三方预交,0) < 0 And 操作类型_In = 3 And 退款方式_In <> 2 then
        n_Err_Num := -20101;
        v_Err_Msg :='退款金额大于病人剩余预交余额，不能继续！';
        If 退款方式_In = 0 Then
          n_Err_Num := -20111;
          v_Err_Msg :='退款金额大于病人剩余预交余额，是否忽略？';
        End If;
        Raise Err_Item;
    End if;
  End if;

  --人员缴款余额(现收)
  Update 人员缴款余额
  Set 余额 = Nvl(余额, 0) + 金额_In
  Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = 结算方式_In
  Returning 余额 Into n_返回值;

  If Sql%RowCount = 0 Then
    Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, 结算方式_In, 1, 金额_In);
    n_返回值 := 金额_In;
  End If;
  If Nvl(n_返回值, 0) = 0 Then
    Delete From 人员缴款余额 Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = 结算方式_In And Nvl(余额, 0) = 0;
  End If;
  --对临时担保的处理
  Select Nvl(担保性质, 0) Into v_担保 From 病人信息 Where 病人id = 病人id_In;
  If v_担保 = 1 And Nvl(金额_In, 0) > 0 Then
    Update 病人信息
    Set 担保额 = Decode(Sign(Nvl(担保额, 0) - Nvl(金额_In, 0)), 1, Nvl(担保额, 0) - Nvl(金额_In, 0), Null),
        担保人 = Decode(Sign(Nvl(担保额, 0) - Nvl(金额_In, 0)), 1, 担保人, Null),
        担保性质 = Decode(Sign(Nvl(担保额, 0) - Nvl(金额_In, 0)), 1, 担保性质, Null)
    Where 病人id = 病人id_In;
  End If;
  If 操作类型_In <> 1 And 结帐id_In Is Null Then
    --消息推送;
    Begin
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 11, Id_In;
    Exception
      When Others Then
        Null;
    End;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(n_Err_Num, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人预交记录_Insert;
/

--94041:马政,2016-03-10,材料售价调价成本价字段修正
--92931:马政,2016-01-21,材料调价生效过程升级脚本和安装脚本不同修正
Create Or Replace Procedure Zl_材料收发记录_Adjust
(
  调价id_In   In Number, --调价记录的ID
  定价_In     In Number := 0, --是否转为定价销售（更新材料特性、收费细目中的变价）
  材料id_In   In Number := 0, --当不为0时表示是成本价调价，不处理售价相关内容
  Billinfo_In In Varchar2 := Null --用于时价卫材按批次调价。格式:"批次1,现价1|批次2,现价2|....."
) As
  n_入出类别id 药品收发记录.入出类别id%Type; --入出类别
  v_调价单据号 药品收发记录.No%Type; --调价单号
  d_生效日期   Date; --调价生效时间
  n_执行调价   Number(1); --调价时刻到了
  n_实价材料   Number(1); --时价药品
  n_收费细目id Number(18); --收费细目ID
  d_审核日期   药品收发记录.审核日期%Type;
  n_零售金额   药品库存.实际金额%Type;
  n_零售价     药品库存.零售价%Type;
  n_序号       Integer(8);
  v_Infotmp    Varchar2(4000);
  v_Fields     Varchar2(4000);
  n_批次       Number(18);
  n_现价       收费价目.现价%Type;
  n_原价       收费价目.原价%Type;
  n_收发id     药品收发记录.Id%Type;
  n_时价分批   Number(1);

  Cursor c_Price --普通调价
  Is
    Select 1 记录状态, 13 单据, v_调价单据号 NO, Rownum 序号, n_入出类别id 入出类别id, m.材料id 药品id, s.批次 批次, Null 批号, s.效期,
           Decode(s.上次产地, Null, q.产地, s.上次产地) 产地, 1 付数, s.实际数量 填写数量, 0 实际数量, a.原价 成本价, 0 成本金额, a.现价 零售价, 0 扣率,
           Nvl(s.零售价, 0) As 库存零售价, s.实际金额 As 库存金额, s.实际差价 As 库存差价, '卫材调价' 摘要, User 填制人, Sysdate 填制日期, s.库房id 库房id,
           1 入出系数, a.Id 价格id, s.上次生产日期, s.灭菌效期, s.批准文号, s.上次供应商id,
           Nvl(s.零售价, Decode(Nvl(s.实际数量, 0), 0, a.原价, Nvl(s.实际金额, 0) / s.实际数量)) As 原售价
    From 药品库存 S, 材料特性 M, 收费价目 A, 收费项目目录 Q
    Where s.药品id = m.材料id And m.材料id = q.Id And m.材料id = a.收费细目id And s.性质 = 1 And a.变动原因 = 0 And a.Id = 调价id_In And
          a.执行日期 <= Sysdate;

  Cursor c_时价按批次调价 --时价卫材按批次调价
  Is
    Select 1 记录状态, 13 单据, v_调价单据号 NO, n_序号 + Rownum 序号, n_入出类别id 入出类别id, s.药品id 药品id, s.批次 批次, Null 批号, s.效期,
           Decode(s.上次产地, Null, b.产地, s.上次产地) 产地, 1 付数, Nvl(s.实际数量, 0) 填写数量, 0 实际数量, a.原价 成本价, 0 成本金额, n_现价 零售价, 0 扣率,
           '卫材调价' 摘要, User 填制人, Sysdate 填制日期, s.库房id 库房id, 1 入出系数, a.Id 价格id, Nvl(b.是否变价, 0) As 时价, s.实际金额 As 库存金额,
           s.实际差价 As 库存差价, Nvl(s.零售价, Decode(Nvl(s.实际数量, 0), 0, a.原价, Nvl(s.实际金额, 0) / s.实际数量)) As 原售价
    From 药品库存 S, 材料特性 M, 收费价目 A, 收费项目目录 B
    Where s.药品id = m.材料id And m.材料id = a.收费细目id And a.收费细目id = b.Id And s.性质 = 1 And a.变动原因 = 0 And a.Id = 调价id_In And
          a.执行日期 <= Sysdate And Nvl(s.批次, 0) = n_批次;
Begin

  If 材料id_In <> 0 Then
    --成本价调价
    Zl_材料收发记录_成本价调价(材料id_In);
    Return;
  End If;

  --取入出类别ID
  Select 类别id Into n_入出类别id From 药品单据性质 Where 单据 = 13;

  --取序列
  Select Nextno(147) Into v_调价单据号 From Dual;
  --取调价记录生效日期
  Select 收费细目id, 执行日期 Into n_收费细目id, d_生效日期 From 收费价目 Where ID = 调价id_In;
  --取该材料是否是时价药品
  Select Nvl(是否变价, 0) Into n_实价材料 From 收费项目目录 Where ID = n_收费细目id;

  If Sysdate >= d_生效日期 Then
    n_执行调价 := 1;
  Else
    n_执行调价 := 0;
  End If;

  If n_执行调价 = 1 Then
    d_审核日期 := Sysdate;
    --普通调价处理
    If Billinfo_In = '' Or Billinfo_In Is Null Then
      --非时价药品调价
      For c_调价 In c_Price Loop
        If Nvl(c_调价.填写数量, 0) = 0 And Nvl(c_调价.库存金额, 0) = 0 And Nvl(c_调价.库存差价, 0) = 0 Then
          Null;
        Elsif Nvl(c_调价.填写数量, 0) = 0 And (Nvl(c_调价.库存金额, 0) <> 0 Or Nvl(c_调价.库存差价, 0) <> 0) Then
          --数量=0 金额或差价<>0时只更新库存表中对应的零售价,并产生售价修正数据但是金额差=0，只记录最新售价，金额差和差价差不填数据



        
          --产生调价影响记录
          Insert Into 药品收发记录
            (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 摘要, 填制人, 填制日期,
             库房id, 入出系数, 价格id, 审核人, 审核日期, 生产日期, 灭菌效期, 批准文号, 供药单位id, 单量, 频次)
          Values
            (药品收发记录_Id.Nextval, c_调价.记录状态, c_调价.单据, c_调价.No, c_调价.序号, c_调价.入出类别id, c_调价.药品id, c_调价.批次, c_调价.批号, c_调价.效期,
             c_调价.产地, c_调价.付数, c_调价.填写数量, c_调价.实际数量, Decode(n_实价材料, 1, c_调价.原售价, c_调价.成本价), c_调价.成本金额, c_调价.零售价, c_调价.扣率,
             c_调价.摘要, c_调价.填制人, c_调价.填制日期, c_调价.库房id, c_调价.入出系数, c_调价.价格id, User, d_审核日期, c_调价.上次生产日期, c_调价.灭菌效期,
             c_调价.批准文号, c_调价.上次供应商id, c_调价.库存金额, c_调价.库存差价);
        
          --更新材料库存 ，只有时价卫材才更新零售价
          Update 药品库存
          Set 零售价 = Decode(n_实价材料, 1, Decode(Nvl(c_调价.批次, 0), 0, Null, c_调价.零售价), Null)
          Where 库房id = c_调价.库房id And 药品id = c_调价.药品id And 性质 = 1 And Nvl(批次, 0) = Nvl(c_调价.批次, 0);
        Else
          If n_实价材料 = 1 Then
            If c_调价.库存零售价 = 0 Then
              n_零售价 := c_调价.库存金额 / c_调价.填写数量;
            Else
              n_零售价 := c_调价.库存零售价;
            End If;
          Else
            n_零售价 := c_调价.成本价;
          End If;
          n_零售金额 := Round((c_调价.零售价 - n_零售价) * c_调价.填写数量, 2);
        
          --产生调价影响记录
          Insert Into 药品收发记录
            (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 零售金额, 差价, 摘要, 填制人,
             填制日期, 库房id, 入出系数, 价格id, 审核人, 审核日期, 生产日期, 灭菌效期, 批准文号, 供药单位id, 单量, 频次)
          Values
            (药品收发记录_Id.Nextval, c_调价.记录状态, c_调价.单据, c_调价.No, c_调价.序号, c_调价.入出类别id, c_调价.药品id, c_调价.批次, c_调价.批号, c_调价.效期,
             c_调价.产地, c_调价.付数, c_调价.填写数量, c_调价.实际数量, Decode(n_实价材料, 1, c_调价.原售价, c_调价.成本价), c_调价.成本金额, c_调价.零售价, c_调价.扣率,
             n_零售金额, n_零售金额, c_调价.摘要, c_调价.填制人, c_调价.填制日期, c_调价.库房id, c_调价.入出系数, c_调价.价格id, User, d_审核日期, c_调价.上次生产日期,
             c_调价.灭菌效期, c_调价.批准文号, c_调价.上次供应商id, c_调价.库存金额, c_调价.库存差价);
        
          --更新材料库存
          Update 药品库存
          Set 实际金额 = Nvl(实际金额, 0) + n_零售金额, 实际差价 = Nvl(实际差价, 0) + n_零售金额,
              零售价 = Decode(n_实价材料, 1, Decode(Nvl(c_调价.批次, 0), 0, Null, c_调价.零售价), Null)
          Where 库房id = c_调价.库房id And 药品id = c_调价.药品id And 性质 = 1 And Nvl(批次, 0) = Nvl(c_调价.批次, 0);
        
          If Sql%RowCount = 0 Then
            Insert Into 药品库存
              (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 效期, 灭菌效期, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 批准文号, 零售价)
            Values
              (c_调价.库房id, c_调价.药品id, c_调价.批次, 1, 0, 0, n_零售金额, n_零售金额, c_调价.效期, c_调价. 灭菌效期, c_调价.上次供应商id, c_调价.成本价,
               c_调价.批号, c_调价.上次生产日期, c_调价.产地, c_调价.批准文号,
               Decode(n_实价材料, 1, Decode(Nvl(c_调价.批次, 0), 0, Null, c_调价.零售价), Null));
          End If;
        End If;
      End Loop;
    Else
      --时价分批调价处理
      n_序号 := 0;
      --时价药品按批次调价
      v_Infotmp := Billinfo_In || '|';
      While v_Infotmp Is Not Null Loop
        --分解单据ID串
        v_Fields  := Substr(v_Infotmp, 1, Instr(v_Infotmp, '|') - 1);
        n_批次    := Substr(v_Fields, 1, Instr(v_Fields, ',') - 1);
        n_现价    := Substr(v_Fields, Instr(v_Fields, ',') + 1);
        v_Infotmp := Replace('|' || v_Infotmp, '|' || v_Fields || '|');
      
        For v_时价按批次调价 In c_时价按批次调价 Loop
          If v_时价按批次调价.填写数量 <> 0 Then
            n_原价 := Nvl(v_时价按批次调价.库存金额, 0) / v_时价按批次调价.填写数量;
          Else
            n_原价 := v_时价按批次调价.成本价;
          End If;
        
          Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
          If Nvl(v_时价按批次调价.填写数量, 0) = 0 And Nvl(v_时价按批次调价.库存金额, 0) = 0 And Nvl(v_时价按批次调价.库存差价, 0) = 0 Then
            Null;
          Elsif Nvl(v_时价按批次调价.填写数量, 0) = 0 And (Nvl(v_时价按批次调价.库存金额, 0) <> 0 Or Nvl(v_时价按批次调价.库存差价, 0) <> 0) Then
            --数量=0 金额或差价<>0时只更新库存表中对应的零售价,并产生售价修正数据但是金额差=0，只记录最新售价，金额差和差价差不填数据



          
            --产生调价影响记录
            Insert Into 药品收发记录
              (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 摘要, 填制人, 填制日期,
               库房id, 入出系数, 价格id, 审核人, 审核日期, 单量, 频次)
            Values
              (n_收发id, v_时价按批次调价.记录状态, v_时价按批次调价.单据, v_时价按批次调价.No, v_时价按批次调价.序号, v_时价按批次调价.入出类别id, v_时价按批次调价.药品id,
               v_时价按批次调价.批次, v_时价按批次调价.批号, v_时价按批次调价.效期, v_时价按批次调价.产地, v_时价按批次调价.付数, v_时价按批次调价.填写数量, v_时价按批次调价.实际数量,
               Decode(n_实价材料, 1, v_时价按批次调价.原售价, v_时价按批次调价.成本价), v_时价按批次调价.成本金额, v_时价按批次调价.零售价, v_时价按批次调价.扣率,
               v_时价按批次调价.摘要, v_时价按批次调价.填制人, v_时价按批次调价.填制日期, v_时价按批次调价.库房id, v_时价按批次调价.入出系数, v_时价按批次调价.价格id, User, d_审核日期,
               v_时价按批次调价.库存金额, v_时价按批次调价.库存差价);
            n_序号 := n_序号 + 1;
            --处理库存
            --更新库存零售价,只有时价分批药品才能更新零售价字段
            Update 药品库存
            Set 零售价 = Decode(v_时价按批次调价.时价, 1, Decode(Nvl(v_时价按批次调价.批次, 0), 0, Null, v_时价按批次调价.零售价), Null)
            Where 库房id = v_时价按批次调价.库房id And 药品id = v_时价按批次调价.药品id And 性质 = 1 And Nvl(批次, 0) = Nvl(v_时价按批次调价.批次, 0);
          Else
            n_零售价   := v_时价按批次调价.库存金额 / v_时价按批次调价.填写数量;
            n_零售金额 := Round((n_现价 - n_零售价) * v_时价按批次调价.填写数量, 2);
            --产生调价影响记录
            Insert Into 药品收发记录
              (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 零售金额, 差价, 摘要,
               填制人, 填制日期, 库房id, 入出系数, 价格id, 审核人, 审核日期, 单量, 频次)
            Values
              (n_收发id, v_时价按批次调价.记录状态, v_时价按批次调价.单据, v_时价按批次调价.No, v_时价按批次调价.序号, v_时价按批次调价.入出类别id, v_时价按批次调价.药品id,
               v_时价按批次调价.批次, v_时价按批次调价.批号, v_时价按批次调价.效期, v_时价按批次调价.产地, v_时价按批次调价.付数, v_时价按批次调价.填写数量, v_时价按批次调价.实际数量,
               Decode(n_实价材料, 1, v_时价按批次调价.原售价, v_时价按批次调价.成本价), v_时价按批次调价.成本金额, v_时价按批次调价.零售价, v_时价按批次调价.扣率, n_零售金额,
               n_零售金额, v_时价按批次调价.摘要, v_时价按批次调价.填制人, v_时价按批次调价.填制日期, v_时价按批次调价.库房id, v_时价按批次调价.入出系数, v_时价按批次调价.价格id, User,
               d_审核日期, v_时价按批次调价.库存金额, v_时价按批次调价.库存差价);
            n_序号 := n_序号 + 1;
            --处理库存
            If v_时价按批次调价.时价 = 1 And Nvl(v_时价按批次调价.批次, 0) > 0 Then
              n_时价分批 := 1;
            Else
              n_时价分批 := 0;
            End If;
          
            If Nvl(v_时价按批次调价.批次, 0) = 0 Then
              Update 药品库存
              Set 实际金额 = Nvl(实际金额, 0) + n_零售金额, 实际差价 = Nvl(实际差价, 0) + n_零售金额
              Where 库房id = v_时价按批次调价.库房id And 药品id = v_时价按批次调价.药品id And 性质 = 1 And (批次 Is Null Or 批次 = 0);
            Else
              Update 药品库存
              Set 实际金额 = Nvl(实际金额, 0) + n_零售金额, 实际差价 = Nvl(实际差价, 0) + n_零售金额,
                  零售价 = Decode(n_时价分批, 1, v_时价按批次调价.零售价, 零售价)
              Where 库房id = v_时价按批次调价.库房id And 药品id = v_时价按批次调价.药品id And 性质 = 1 And 批次 = v_时价按批次调价.批次;
            End If;
          
            If Sql%RowCount = 0 Then
              Insert Into 药品库存
                (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 零售价)
              Values
                (v_时价按批次调价.库房id, v_时价按批次调价.药品id, v_时价按批次调价.批次, 1, 0, 0, n_零售金额, n_零售金额,
                 Decode(n_时价分批, 1, v_时价按批次调价.零售价, Null));
            End If;
          End If;
        End Loop;
      End Loop;
    End If;
  
    Update 药品收发记录 Set 审核人 = User, 审核日期 = Sysdate Where 价格id = 调价id_In;
    Update 收费价目 Set 变动原因 = 1 Where ID = 调价id_In;
  
    --更新药品目录、收费细目中的变价
    If 定价_In = 1 Then
      Update 收费项目目录 Set 是否变价 = 0 Where ID = n_收费细目id;
    End If;
    --成本价调价
    Zl_材料收发记录_成本价调价(n_收费细目id);
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料收发记录_Adjust;
/


--93336:胡俊勇,2016-02-16,输血执行登记
Create Or Replace Function Zl_Fun_Get输血执行登记(医嘱id_In In 病人医嘱记录.Id%Type) Return Varchar2 Is
  n_Count 病人医嘱执行.本次数次%Type;
  n_Boold Number; --是否用血库系统
  v_Tmp   Varchar2(4000);
  n_Bags  Number; --血库配血袋数
  --功能：对 输血途径 医嘱执行登记
  --参数：医嘱id_In 主医嘱ID
  --返回：固定格式字符串， 登记一次所填写的数量，是否启用血库，血袋总数。例：0.33333<SPLIT>1<SPLIT>3
  --说明：后台数据以5位小数四舍五入保存，界面提示和判断时要乘上血袋总数四舍五入取整进行比较
Begin
  Select Count(1) Into n_Boold From zlSystems Where 编号 = 2200;
  If n_Boold = 1 Then
    n_Boold := Nvl(zl_GetSysParameter(236), 0);
  End If;
  If n_Boold = 1 Then
    v_Tmp := 'Select Zl_Get_输血执行次数(:1) as 数量 From Dual';
    Execute Immediate v_Tmp
      Into n_Bags
      Using 医嘱id_In;
  End If;
  If n_Bags Is Null Then
    n_Count := 1;
  Else
    n_Count := Round(1 / n_Bags, 5);
  End If;
  v_Tmp := To_Char(n_Count, '0.99999') || '<SPLIT>' || Nvl(n_Boold, 0) || '<SPLIT>' || Nvl(n_Bags, 0);
  Return v_Tmp;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Fun_Get输血执行登记;
/         

--92898:梁经伙,2016-02-03,过敏时间允许为空，不输入过敏时间的话不以当前时间替换
CREATE OR REPLACE Procedure Zl_病人过敏记录_Insert
( 
  病人id_In     病人过敏记录.病人id%Type, 
  主页id_In     病人过敏记录.主页id%Type, 
  来源_In       病人过敏记录.记录来源%Type, 
  药物id_In     病人过敏记录.药物id%Type, 
  药物名_In     病人过敏记录.药物名%Type, 
  结果_In       病人过敏记录.结果%Type := 1, 
  过敏时间_In   病人过敏记录.过敏时间%Type := Null, 
  记录时间_In   病人过敏记录.记录时间%Type := Null, 
  过敏反应_In   病人过敏记录.过敏反应%Type := Null, 
  过敏源编码_In 病人过敏记录.过敏源编码%Type := Null 
) Is 
  V_Date     Date; 
  V_Temp     Varchar2(255); 
  V_人员姓名 病人过敏记录.记录人%Type; 
  N_Count    Number; 
Begin 
  V_Temp     := Zl_Identity; 
  V_Temp     := Substr(V_Temp, Instr(V_Temp, ';') + 1); 
  V_Temp     := Substr(V_Temp, Instr(V_Temp, ',') + 1); 
  V_人员姓名 := Substr(V_Temp, Instr(V_Temp, ',') + 1); 
 
  If 记录时间_In Is Not Null Then 
    V_Date := 记录时间_In; 
  Else 
    Select Sysdate Into V_Date From Dual; 
  End If; 
 
  Insert Into 病人过敏记录 
    (ID, 病人id, 主页id, 记录来源, 药物id, 药物名, 结果, 过敏时间, 记录时间, 记录人, 过敏反应,过敏源编码) 
  Values 
    (病人过敏记录_Id.Nextval, 病人id_In, 主页id_In, 来源_In, 药物id_In, 药物名_In, 结果_In, 过敏时间_In, V_Date, V_人员姓名, 过敏反应_In,过敏源编码_In); 
 
  Select Count(1) Into N_Count From 病人过敏药物 Where 病人id = 病人id_In And 过敏药物 = 药物名_In; 
  If N_Count = 0 Then 
    Insert Into 病人过敏药物 
      (病人id, 过敏药物id, 过敏药物, 过敏反应) 
    Values 
      (病人id_In, 药物id_In, 药物名_In, 过敏反应_In); 
  Else 
    Update 病人过敏药物 
    Set 过敏药物id = 药物id_In, 过敏反应 = 过敏反应_In 
    Where 病人id = 病人id_In And 过敏药物 = 药物名_In; 
  End If; 
Exception 
  When Others Then 
    zl_ErrorCenter(SQLCode, SQLErrM); 
End Zl_病人过敏记录_Insert;
/

--93209:蔡青松,2016-02-01,调整条码长度,当医嘱ID长度大于8时,将条码由原来的12位调整为13位
Create Or Replace Function Nextno
(
  序号_In     In 号码控制表.项目序号%Type,
  科室id_In   In 部门表.Id%Type := Null,
  v_Tag       In Varchar2 := Null,
  号码个数_In In Integer := 1
) Return Varchar2
--    功能：根据特定规则产生新的号码,规则如下：
  --    一、项目序号：
  --       1   病人ID         数字
  --       2   住院号         数字
  --       3   门诊号         数字
  --       6   留观号         数字
  --       10  医嘱发送号     数字,顺序递增编号
  --       x   其它单据号     字符,根据编号规则顺序递增编号,不自动补缺
  --    二、年度位确定原则：
  --       以1990为基数，随年度增长，按“0～9/A～Z”顺序作为年度编码
  --
  --    说明：最大号码-10存入号码控制表,用于并发情况下补缺号(取了号,但未使用)
  --          For Update在并发情况下锁定行,不用Wait选项以避免向调用者返回空
  --          v_Tag 可用其它未指明的参数,目前 有影像检查类别(编码)
  --    返回：最大号码
 Is
  Pragma Autonomous_Transaction;
  v_No     号码控制表.最大号码%Type;
  v_Maxno  号码控制表.最大号码%Type;
  n_Maxno  Number;
  n_Amt    Number;
  n_Mod    号码控制表.编号规则%Type;
  v_Deptno Varchar2(20);
  v_Year   Varchar2(1);
  v_Tmp    Varchar2(10);

  v_试管编码   Number;
  v_生成条码   Varchar2(20);
  v_编码       Varchar2(10);
  v_医嘱       Varchar2(18);
  v_Error      Varchar2(255);
  n_Checkmaxno Number;

  Err_Custom Exception;
Begin

  --1.病人ID
  If 序号_In = 1 Then
    Select Nvl(编号规则, 0) Into n_Mod From 号码控制表 Where 项目序号 = 序号_In;
  
    --从序列取值，用于不要求病人ID必须连续的用户减少并发争用
    If n_Mod = 1 Then
      Select 病人信息_Id.Nextval Into v_No From Dual;
    Else
      Select Nvl(最大号码, '0') Into v_Maxno From 号码控制表 Where 项目序号 = 序号_In For Update;
    
      Select Nvl(Max(病人id), 0) + 1 Into n_Maxno From 病人信息 Where 病人id >= To_Number(v_Maxno);
    
      Update 号码控制表 Set 最大号码 = Decode(Sign(n_Maxno - 10), 1, n_Maxno - 10, 1) Where 项目序号 = 序号_In;
      v_No := To_Char(n_Maxno);
    End If;
    --2.住院号
  Elsif 序号_In = 2 Then
    Select Nvl(最大号码, '0'), Nvl(编号规则, 0)
    Into v_Maxno, n_Mod
    From 号码控制表
    Where 项目序号 = 序号_In
    For Update;
  
    If n_Mod = 0 Then
      --0.顺序编号
      Select Nvl(Max(住院号), 0) + 1 Into n_Maxno From 病人信息 Where 住院号 >= To_Number(v_Maxno);
    
      Update 号码控制表 Set 最大号码 = Decode(Sign(n_Maxno - 10), 1, n_Maxno - 10, 1) Where 项目序号 = 序号_In;
    Elsif n_Mod = 1 Then
      --1.年月(YYMM)+顺序号(0000)
      v_Tmp := To_Char(Sysdate, 'YYMM');
    
      Select Nvl(Max(住院号), To_Number(v_Tmp || '0000')) + 1
      Into n_Maxno
      From 病人信息
      Where 住院号 Like To_Number(v_Tmp) || '%' And 住院号 >= To_Number(v_Maxno);
      Update 号码控制表
      Set 最大号码 = Decode(Sign(n_Maxno - 10 - To_Number(v_Tmp || '0000')), 1, n_Maxno - 10, To_Number(v_Tmp || '0001'))
      Where 项目序号 = 序号_In;
    
    Elsif n_Mod = 2 Then
      --2.年(YYYY)+顺序号(00000)
      v_Tmp := To_Char(Sysdate, 'YYYY');
    
      Select Nvl(Max(住院号), To_Number(v_Tmp || '00000')) + 1
      Into n_Maxno
      From 病人信息
      Where 住院号 Like To_Number(v_Tmp) || '%' And 住院号 >= To_Number(v_Maxno);
      Update 号码控制表
      Set 最大号码 = Decode(Sign(n_Maxno - 10 - To_Number(v_Tmp || '00000')), 1, n_Maxno - 10, To_Number(v_Tmp || '00001'))
      Where 项目序号 = 序号_In;
    
    End If;
    v_No := To_Char(n_Maxno);
  
    --3.门诊号
  Elsif 序号_In = 3 Then
    Select Nvl(最大号码, '0'), Nvl(编号规则, 0)
    Into v_Maxno, n_Mod
    From 号码控制表
    Where 项目序号 = 序号_In
    For Update;
  
    If n_Mod = 0 Then
      --0.顺序编号
    
      Select Nvl(Max(门诊号), 0) + 1 Into n_Maxno From 病人信息 Where 门诊号 >= To_Number(v_Maxno);
    
      Update 号码控制表 Set 最大号码 = Decode(Sign(n_Maxno - 10), 1, n_Maxno - 10, 1) Where 项目序号 = 序号_In;
    Elsif n_Mod = 1 Then
      --1.日期编号YYMMDD
      v_Tmp := To_Char(Sysdate, 'YYMMDD');
    
      Select Nvl(Max(门诊号), To_Number(v_Tmp || '0000')) + 1
      Into n_Maxno
      From 病人信息
      Where 门诊号 Like To_Number(v_Tmp) || '%' And 门诊号 >= To_Number(v_Maxno);
      Update 号码控制表
      Set 最大号码 = Decode(Sign(n_Maxno - 10 - To_Number(v_Tmp || '0000')), 1, n_Maxno - 10, To_Number(v_Tmp || '0001'))
      Where 项目序号 = 序号_In;
    
    End If;
    v_No := To_Char(n_Maxno);
    --6.留观号
  Elsif 序号_In = 6 Then
    Select Nvl(最大号码, '0'), Nvl(编号规则, 0)
    Into v_Maxno, n_Mod
    From 号码控制表
    Where 项目序号 = 序号_In
    For Update;
  
    If n_Mod = 0 Then
      --0.顺序编号
      Select Nvl(Max(留观号), 0) + 1 Into n_Maxno From 病案主页 Where 留观号 >= To_Number(v_Maxno);

    
      Update 号码控制表 Set 最大号码 = Decode(Sign(n_Maxno - 10), 1, n_Maxno - 10, 1) Where 项目序号 = 序号_In;
    Elsif n_Mod = 1 Then
      --1.年月(YYMM)+顺序号(0000)
      v_Tmp := To_Char(Sysdate, 'YYMM');
    
      Select Nvl(Max(留观号), To_Number(v_Tmp || '0000')) + 1
      Into n_Maxno
      From 病案主页
      Where 留观号 Like To_Number(v_Tmp) || '%' And 留观号 >= To_Number(v_Maxno);
      Update 号码控制表
      Set 最大号码 = Decode(Sign(n_Maxno - 10 - To_Number(v_Tmp || '0000')), 1, n_Maxno - 10, To_Number(v_Tmp || '0001'))
      Where 项目序号 = 序号_In;
    
    Elsif n_Mod = 2 Then
      --2.年(YYYY)+顺序号(00000)
      v_Tmp := To_Char(Sysdate, 'YYYY');
    
      Select Nvl(Max(留观号), To_Number(v_Tmp || '00000')) + 1
      Into n_Maxno
      From 病案主页
      Where 留观号 Like To_Number(v_Tmp) || '%' And 留观号 >= To_Number(v_Maxno);
      Update 号码控制表
      Set 最大号码 = Decode(Sign(n_Maxno - 10 - To_Number(v_Tmp || '00000')), 1, n_Maxno - 10, To_Number(v_Tmp || '00001'))
      Where 项目序号 = 序号_In;
    
    End If;
    v_No := To_Char(n_Maxno);
    --10.医嘱发送号
  Elsif 序号_In = 10 Then
    Select Nvl(最大号码, '0') Into v_Maxno From 号码控制表 Where 项目序号 = 序号_In For Update;
    v_Maxno := To_Char(To_Number(v_Maxno) + 1);
    Update 号码控制表 Set 最大号码 = v_Maxno Where 项目序号 = 序号_In;
    v_No := v_Maxno;
  
    --汇总发药号
  Elsif 序号_In = 20 Then
    --YYYYMMDD+5位顺序号(00000)
    Select To_Char(Sysdate, 'yyyymmdd') Into v_Tmp From Dual;
    Select Nvl(最大号码, '0') Into v_Maxno From 号码控制表 Where 项目序号 = 序号_In For Update;
  
    If v_Maxno = '0' Then
      v_Maxno := v_Tmp || '00001';
    Else
      If Substr(v_Maxno, 1, 8) = v_Tmp Then
        If To_Number(Substr(v_Maxno, 9, 5)) = 99999 Then
          v_Maxno := v_Tmp || '00001';
        Else
          v_Maxno := v_Tmp || Trim(To_Char(To_Number(Substr(v_Maxno, 9, 5)) + 1, '00000'));
        End If;
      Else
        v_Maxno := v_Tmp || '00001';
      End If;
    End If;
    Update 号码控制表 Set 最大号码 = v_Maxno Where 项目序号 = 序号_In;
  
    v_No := v_Maxno;
  
  Elsif 序号_In = 123 Then
  
    Select Nvl(Max(参数值), 0) Into n_Mod From 影像流程参数 Where 科室id = 科室id_In And 参数名 = '检查号生成方式';
    Select Nvl(Max(参数值), 1)
    Into n_Checkmaxno
    From 影像流程参数
    Where 科室id = 科室id_In And 参数名 = '提取实际最大号码';
  
    If n_Mod = 1 Then
      --影像检查号按科室递增
      --从号码表提取最大号码
      Select Nvl(Max(最大号码), 0) Into n_Maxno From 科室号码表 Where 项目序号 = 序号_In And 科室id = 科室id_In;
      If n_Maxno = 0 Then
        --没有记录，则自动增加科室号码表
        Insert Into 科室号码表 (项目序号, 科室id, 编号, 最大号码) Values (序号_In, 科室id_In, 'A', '1');
      End If;
    
      --提取实际最大号码,如果有实际最大号码，这个号码会比号码表中的大10
      If n_Checkmaxno = 1 Then
      
        Select Nvl(Max(检查号), 0) + 1 Into n_Amt From 影像检查记录 Where 执行科室id = 科室id_In And 检查号 >= n_Maxno;
      
        If n_Amt > n_Maxno Then
          n_Maxno := n_Amt;
        End If;
      Else
        -- 如果不提取实际最大号码，加上10
        n_Maxno := n_Maxno + 10 + 1;
      End If;
    
      -- 回填最大号码
      If (n_Checkmaxno = 0 And 号码个数_In = n_Maxno) Or n_Checkmaxno = 1 Then
        Update 科室号码表
        Set 最大号码 = Decode(Sign(n_Maxno - 10), 1, n_Maxno - 10, 1)
        Where 项目序号 = 序号_In And 科室id = 科室id_In;
      End If;
    Else
      --影像检查号按类别递增
      Select Nvl(Max(最大号码), 0) Into n_Maxno From 影像检查类别 Where 编码 = v_Tag;
      --提取实际最大号码，如果有实际最大号码，这个号码会比号码表中的大10
      If n_Checkmaxno = 1 Then
      
        Select Nvl(Max(检查号), 0) + 1 Into n_Amt From 影像检查记录 Where 影像类别 = v_Tag And 检查号 >= n_Maxno;
      
        If n_Amt > n_Maxno Then
          n_Maxno := n_Amt;
        End If;
      Else
        -- 如果不提取实际最大号码，加上10
        n_Maxno := n_Maxno + 10 + 1;
      End If;
    
      -- 回填最大号码
      If (n_Checkmaxno = 0 And 号码个数_In = n_Maxno) Or n_Checkmaxno = 1 Then
        Update 影像检查类别 Set 最大号码 = Decode(Sign(n_Maxno - 10), 1, n_Maxno - 10, 1) Where 编码 = v_Tag;
      End If;
    End If;
    v_No := To_Char(n_Maxno);
  
  Elsif 序号_In = 124 Then
    ----------------------------------------------------------------------------------------------------------------------------
    --体检健康号
  
    Begin
      Select Nvl(编号规则, 0) Into n_Mod From 号码控制表 Where 项目序号 = 序号_In;
    Exception
      When Others Then
        v_Error := '号码控制表中不存在序号为' || 序号_In || '的号码';
        Raise Err_Custom;
    End;
  
    If n_Mod = 0 Then
      --顺序编号
      Select Nvl(Zl_To_Number(最大号码), 0) + 号码个数_In
      Into v_Maxno
      From 号码控制表
      Where 项目序号 = 序号_In
      For Update;
      Update 号码控制表 Set 最大号码 = v_Maxno Where 项目序号 = 序号_In;
    Else
      --前缀+顺序号
      Update 号码编号表 Set 最大号码 = 最大号码 Where 项目序号 = 序号_In And 号码前缀 = v_Tag;
      If Sql%Rowcount = 0 Then
        Insert Into 号码编号表
          (项目序号, 号码前缀, 日期, 最大号码)
          Select 序号_In, v_Tag, Sysdate, '' From Dual;
      End If;
    
      Select Nvl(Zl_To_Number(最大号码), 0) + 号码个数_In
      Into n_Maxno
      From 号码编号表 a
      Where a.项目序号 = 序号_In And a.号码前缀 = v_Tag;
    
      If Substr(n_Maxno, 1, Length(v_Tag)) <> v_Tag Then
        --进位了
        Select Nvl(Zl_To_Number(Substr(最大号码, Length(v_Tag) + 1)), 0) + 号码个数_In
        Into n_Maxno
        From 号码编号表 a
        Where a.项目序号 = 序号_In And a.号码前缀 = v_Tag;
        Select v_Tag || n_Maxno Into v_Maxno From Dual;
      Else
        If n_Maxno = 号码个数_In Then
          v_Maxno := v_Tag || To_Char(号码个数_In);
        Else
          v_Maxno := n_Maxno;
        End If;
      End If;
    
      Update 号码编号表 Set 最大号码 = v_Maxno Where 项目序号 = 序号_In And 号码前缀 = v_Tag;
    End If;
    v_No := v_Maxno;
  
  Elsif 序号_In = 125 Then
    --这里是为了减少号码控制表的锁定时间
    If n_Mod = 0 Then
      Begin
        Select 试管编码
        Into v_试管编码
        From 病人医嘱记录 a, 诊疗项目目录 b
        Where a.诊疗项目id = b.Id And a.Id = 科室id_In And 试管编码 Is Not Null;
      Exception
        When Others Then
          v_Error := '没有找到检验项目对应的管码！';
          Raise Err_Custom;
      End;
    Else
      Begin
        Select 试管编码, c.编码
        Into v_试管编码, v_编码
        From 病人医嘱记录 a, 诊疗项目目录 b, 诊疗检验类型 c
        Where a.诊疗项目id = b.Id And a.Id = 科室id_In And b.操作类型 = c.名称 And 试管编码 Is Not Null;
      
      Exception
        When Others Then
          v_Error := '没有找到检验项目对应的管码和编码！';
          Raise Err_Custom;
      End;
    End If;
  
    Select Nvl(最大号码, '0'), Nvl(编号规则, 0)
    Into v_Maxno, n_Mod
    From 号码控制表
    Where 项目序号 = 序号_In
    For Update;
  
    If n_Mod = 0 Then
      --按医嘱生成
    
      v_医嘱 := 科室id_In;
      If Length(v_医嘱) > 12 Then
        v_医嘱 := Substr(v_医嘱, Length(v_医嘱) - 11);
      Else
        v_医嘱 := Lpad(v_医嘱, 12, '0');
      End If;
      if Length(ltrim(v_医嘱,'0'))>8 then
         Select v_试管编码 || LPad(Substr(v_医嘱, Length(v_医嘱) - (13 - Length(v_试管编码) - 2)), (13 - Length(v_试管编码)), '0')
          Into v_生成条码
         From Dual;
      else
         Select v_试管编码 || LPad(Substr(v_医嘱, Length(v_医嘱) - (12 - Length(v_试管编码) - 2)), (12 - Length(v_试管编码)), '0')
         Into v_生成条码
         From Dual;
      end if;
      v_No := v_生成条码;
    Else
      --按"小组编号（1位）+管码(2位)+日期(6位)+顺序号(3)位"生成条码
      Begin
        Select 最大号码
        Into v_Maxno
        From 号码编号表
        Where 项目序号 = 序号_In And 号码前缀 = v_编码 || v_试管编码 And Trunc(日期) = Trunc(Sysdate)
        For Update;
        v_Maxno := v_Maxno + 1;
        If Length(v_Maxno) <= 3 Then
          v_Maxno := Lpad(v_Maxno, 3, '0');
        End If;
        v_No := v_编码 || v_试管编码 || To_Char(Trunc(Sysdate), 'yymmdd') || v_Maxno;
        Update 号码编号表
        Set 日期 = Trunc(Sysdate), 最大号码 = v_Maxno
        Where 号码前缀 = v_编码 || v_试管编码 And Trunc(日期) = Trunc(Sysdate);
      Exception
        When Others Then
          Update 号码编号表 Set 日期 = Trunc(Sysdate), 最大号码 = 1 Where 号码前缀 = v_编码 || v_试管编码;
          If Sql%Rowcount = 0 Then
            Insert Into 号码编号表
              (项目序号, 号码前缀, 日期, 最大号码)
            Values
              (序号_In, v_编码 || v_试管编码, Trunc(Sysdate), 1);
          End If;
          v_No := v_编码 || v_试管编码 || To_Char(Trunc(Sysdate), 'yymmdd') || '001';
      End;
    End If;
    --卫材条码序号
  Elsif 序号_In = 126 Then
    --12位顺序号
    Select Nvl(最大号码, '0') Into v_Maxno From 号码控制表 Where 项目序号 = 序号_In For Update;
  
    If v_Maxno = '0' Then
      v_Maxno := '000000000001';
    Else
      v_Maxno := Trim(To_Char(To_Number(v_Maxno) + 1, '000000000000'));
    End If;
    Update 号码控制表 Set 最大号码 = v_Maxno Where 项目序号 = 序号_In;
  
    v_No := v_Maxno;
  Elsif 序号_In = 135 Then
    --药品卫材调价
    Begin
      Select Nvl(编号规则, 0) Into n_Mod From 号码控制表 Where 项目序号 = 序号_In;
    Exception
      When Others Then
        v_Error := '号码控制表中不存在序号为' || 序号_In || '的号码';
        Raise Err_Custom;
    End;
    --1.年月(YYYYMM)+顺序号(0000)
    v_Tmp := To_Char(Sysdate, 'YYYYMM');
    Select Nvl(最大号码, '0') Into v_Maxno From 号码控制表 Where 项目序号 = 序号_In For Update;
  
    If v_Maxno = '0' Then
      v_Maxno := v_Tmp || '0001';
    Else
      If Substr(v_Maxno, 1, 6) = v_Tmp Then
        v_Maxno := v_Tmp || Trim(To_Char(To_Number(Substr(v_Maxno, 7, 4)) + 1, '0000'));
      Else
        v_Maxno := v_Tmp || '0001';
      End If;
    End If;
    Update 号码控制表 Set 最大号码 = v_Maxno Where 项目序号 = 序号_In;
    v_No := v_Maxno;
  Elsif 序号_In = 136 Then
    --YYMMDD+5位顺序号(00000)
    Select To_Char(Sysdate, 'yymmdd') Into v_Tmp From Dual;
    Select Nvl(最大号码, '0') Into v_Maxno From 号码控制表 Where 项目序号 = 序号_In For Update;
  
    If v_Maxno = '0' Then
      v_Maxno := v_Tmp || '00001';
    Else
      If Substr(v_Maxno, 1, 6) = v_Tmp Then
        If To_Number(Substr(v_Maxno, 7, 5)) = 99999 Then
          v_Maxno := v_Tmp || '00001';
        Else
          v_Maxno := v_Tmp || Trim(To_Char(To_Number(Substr(v_Maxno, 7, 5)) + 1, '00000'));
        End If;
      Else
        v_Maxno := v_Tmp || '00001';
      End If;
    End If;
    Update 号码控制表 Set 最大号码 = v_Maxno Where 项目序号 = 序号_In;
    v_No := v_Maxno;
  Elsif 序号_In = 131 Then
    --体检报到号
    Select Nvl(最大号码, '0') Into v_Maxno From 号码控制表 Where 项目序号 = 序号_In For Update;
    v_Maxno := To_Char(To_Number(v_Maxno) + 1);
    Update 号码控制表 Set 最大号码 = v_Maxno Where 项目序号 = 序号_In;
    v_No := v_Maxno;
    --其它单据号
  Else
    Begin
      Select Nvl(编号规则, 0) Into n_Mod From 号码控制表 Where 项目序号 = 序号_In;
    Exception
      When Others Then
        v_Error := '号码控制表中不存在序号为' || 序号_In || '的号码';
        Raise Err_Custom;
    End;
  
    --如果规则是按科室编号顺序产生，但又未设置科室编码，则采取按年顺序编号
    If n_Mod = 2 And 序号_In <> 122 Then
      Begin
        Select 编号 Into v_Deptno From 科室号码表 Where 科室id = 科室id_In And 项目序号 = 序号_In;
      Exception
        When Others Then
          Null;
      End;
      If v_Deptno Is Null Then
        n_Mod := 0;
      End If;
    End If;
  
    Select Decode(Sign(Intyear - 10), -1, To_Char(Intyear, '9'), Chr(55 + Intyear))
    Into v_Year
    From (Select To_Number(To_Char(Sysdate, 'yyyy'), '9999') - 1990 As Intyear From Dual);
  
    If n_Mod = 0 Then
      --0.按年顺序编号
      Select Nvl(最大号码, '0') Into v_No From 号码控制表 Where 项目序号 = 序号_In For Update;
    
      --第2位增长方式:0-9,A-Z
      Select Bit1 || Decode(Sign(Ascii(Bit2) - Ascii('9')),
                             -1,
                             Lpad(To_Number(Bit28) + 1, 7, '0'),
                             Decode(Bit38,
                                    '999999',
                                    Decode(Bit2, '9', 'A', Chr(Ascii(Bit2) + 1)) || '000000',
                                    Bit2 || Lpad(To_Number(Bit38) + 1, 6, '0')))
      Into v_No
      From (Select Substr(Maxno, 1, 1) As Bit1, Substr(Maxno, 2, 1) As Bit2, Substr(Maxno, 2) As Bit28,
                    Substr(Maxno, 3) As Bit38
             From (Select Decode(v_No,
                                   '0',
                                   v_Year || '0000000',
                                   Decode(Sign(Ascii(Substr(v_No, 1, 1)) - Ascii(v_Year)), -1, v_Year || '0000000', v_No)) As Maxno
                    From Dual));
    
      Update 号码控制表 Set 最大号码 = v_No Where 项目序号 = 序号_In;
    
    Elsif n_Mod = 1 Then
      --1.按年+日顺序编号:YDDD0000
      Select Nvl(最大号码, '0') Into v_No From 号码控制表 Where 项目序号 = 序号_In For Update;
      Select v_Year || Lpad(Trunc(Sysdate - Trunc(Sysdate, 'YYYY') + 1, 0), 3, '0') || '0000' Into v_Maxno From Dual;
      If v_No < v_Maxno Then
        v_No := v_Maxno;
      End If;
      v_No := Substr(v_No, 1, 4) || Lpad(To_Number(Substr(v_No, 5, 4)) + 1, 4, '0');
      Update 号码控制表 Set 最大号码 = v_No Where 项目序号 = 序号_In;
    
    Elsif n_Mod = 2 Then
      If 序号_In = 122 Then
        --2.按科室编码+YYMMDD+3位顺序号:2201090728001
        Select Count(*) Into n_Maxno From 科室号码表 Where 项目序号 = 序号_In And 科室id = 科室id_In;
        If Nvl(n_Maxno, 0) = 0 Then
          Insert Into 科室号码表 (项目序号, 科室id, 最大号码, 编号) Values (序号_In, 科室id_In, Null, Null);
          Commit;
        End If;
      
        Select 编码 Into v_Deptno From 部门表 Where Id = 科室id_In;
        Select Nvl(最大号码, '-') Into v_No From 科室号码表 Where 项目序号 = 序号_In And 科室id = 科室id_In For Update;
        v_Tmp := To_Char(Sysdate, 'YYMMDD');
      
        If Substr(v_No, 1, Length(v_Deptno || v_Tmp)) = v_Deptno || v_Tmp Then
          v_No := v_Deptno || v_Tmp || Lpad(To_Number(Substr(v_No, Length(v_Deptno || v_Tmp) + 1)) + 1, 3, '0');
        Else
          v_No := v_Deptno || v_Tmp || Lpad('1', 3, '0');
        End If;
        Update 科室号码表 Set 最大号码 = v_No Where 项目序号 = 序号_In And 科室id = 科室id_In;
      
      Else
        --2.按年+科室编号+月+顺序号:YKDD0000
        Begin
          --符号-的asscii为45,用于和year比较(0的ascii为48)
          Select 编号, Nvl(最大号码, '-')
          Into v_Deptno, v_No
          From 科室号码表
          Where 项目序号 = 序号_In And Nvl(科室id, 0) = Nvl(科室id_In, 0)
          For Update;
        Exception
          When Others Then
            Null;
        End;
        If v_Deptno Is Null Then
          v_Error := '科室未设置编号，无法产生号码！';
          Raise Err_Custom;
        Else
          v_Tmp := To_Char(Sysdate, 'MM');
          Select Substr(Maxno, 1, 4) || Lpad(To_Number(Substr(Maxno, 5, 4)) + 1, 4, '0')
          Into v_No
          From (Select Decode(Sign(Ascii(Substr(v_No, 1, 1)) - Ascii(v_Year)),
                                -1,
                                v_Year || v_Deptno || v_Tmp || '0000',
                                Decode(Sign(To_Number(Substr(v_No, 3, 2)) - To_Number(v_Tmp)),
                                       -1,
                                       v_Year || v_Deptno || v_Tmp || '0000',
                                       v_No)) As Maxno
                 From Dual);
          Update 科室号码表 Set 最大号码 = v_No Where 项目序号 = 序号_In And Nvl(科室id, 0) = Nvl(科室id_In, 0);
        
        End If;
      End If;
    Elsif n_Mod = 3 Then
    
      --按年月日+000001生成
      Select Substr(To_Char(Sysdate, 'yyyymmdd'), 3, 6) Into v_Tmp From Dual;
      Select Nvl(最大号码, '0') Into v_Maxno From 号码控制表 Where 项目序号 = 序号_In For Update;
    
      If v_Maxno = '0' Then
        v_Maxno := v_Tmp || '000001';
      Else
        If Substr(v_Maxno, 1, 6) = v_Tmp Then
          v_Maxno := v_Tmp || Trim(To_Char(To_Number(Substr(v_Maxno, 7, 6)) + 1, '000000'));
        Else
          v_Maxno := v_Tmp || '000001';
        End If;
      End If;
      Update 号码控制表 Set 最大号码 = v_Maxno Where 项目序号 = 序号_In;
      v_No := v_Maxno;
    
    Elsif n_Mod = 5 Then
      --1.年月(YYYYMM)+顺序号(000000)
      v_Tmp := To_Char(Sysdate, 'YYYYMM');
      Select Nvl(最大号码, '0') Into v_Maxno From 号码控制表 Where 项目序号 = 序号_In For Update;
    
      If v_Maxno = '0' Then
        v_Maxno := v_Tmp || '000001';
      Else
        If Substr(v_Maxno, 1, 6) = v_Tmp Then
          v_Maxno := v_Tmp || Trim(To_Char(To_Number(Substr(v_Maxno, 7, 6)) + 1, '000000'));
        Else
          v_Maxno := v_Tmp || '000001';
        End If;
      End If;
      Update 号码控制表 Set 最大号码 = v_Maxno Where 项目序号 = 序号_In;
      v_No := v_Maxno;
    Else
      v_Error := '序号为' || 序号_In || '的号码,其规则值:' || n_Mod || ',当前系统不支持！';
      Raise Err_Custom;
    End If;
  End If;

  Commit;
  Return v_No;
Exception
  When Err_Custom Then
    Rollback;
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Rollback;
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Nextno;
/

--93146:刘尔旋,2016-01-27,获取号源剩余数量问题
Create Or Replace Procedure Zl_Third_Docarrange
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:医生排班计划
  --入参:Xml_In:
  --<IN>
  --   <YSID>870</YSID>    //医生ID
  --   <KDID>870</KSID>    //科室ID
  --   <KSSJ>2014-10-29 </KSSJ>    //开始时间
  --   <CXTS>14</CXTS>    //查询天数
  --   <HZDW>支付宝</HZDW> //合作单位
  --   <HL>号类</HL>      //号类，可传多个，用逗号分隔，格式:普通,专家,...
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  --   <PBLIST>       //未返回该节点表示没有数据
  --    <PB>
  --     <RQ>2014-10-29</RQ>     //日期
  --     <SYHS>5</SYHS>    //剩余号数
  --     <SBSJ>全日</SBSJ>             //上班时间
  --     <YGS>5</YGS>    //已挂号数
  --    </PB>
  --   <PBLIST>
  --   <ERROR><MSG></MSG></ERROR> //错误情况返回
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  d_日期         Date;
  v_排班         挂号安排.周日%Type;
  n_限号数       挂号安排限制.限号数%Type;
  n_已挂数       挂号安排限制.限号数%Type;
  n_总已挂数     挂号安排限制.限号数%Type;
  n_限约数       挂号安排限制.限号数%Type;
  n_已约数       挂号安排限制.限号数%Type;
  n_剩余数       挂号安排限制.限号数%Type;
  v_上班时间     Varchar2(300);
  n_医生id       人员表.Id%Type;
  n_科室id       部门表.Id%Type;
  n_查询天数     Number(4);
  n_合作单位数量 Number(5);
  n_合约已挂数   Number(4);
  n_合约存在     Number(3);
  n_安排存在     Number(3);
  v_号码         挂号安排.号码%Type;
  n_安排id       挂号安排计划.安排id%Type;
  n_计划id       挂号安排计划.Id%Type;
  v_合作单位     挂号合作单位.名称%Type;
  n_Daycount     Number(4);
  d_开始时间     Date;
  d_原始时间     Date;
  n_禁用         Number(3);
  v_Temp         Varchar2(32767); --临时XML
  x_Templet      Xmltype; --模板XML
  v_Err_Msg      Varchar2(200);
  v_号类         Varchar2(200);
  n_Exists       Number(2);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/YSID'), Extractvalue(Value(A), 'IN/KSID'), Extractvalue(Value(A), 'IN/CXTS'),
         To_Date(Extractvalue(Value(A), 'IN/KSSJ'), 'YYYY-MM-DD hh24:mi:ss'), Extractvalue(Value(A), 'IN/HZDW'),
         Extractvalue(Value(A), 'IN/HL')
  Into n_医生id, n_科室id, n_查询天数, d_开始时间, v_合作单位, v_号类
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  n_查询天数 := Nvl(n_查询天数, 14);
  d_原始时间 := Trunc(d_开始时间);
  d_开始时间 := Trunc(d_开始时间);
  n_Daycount := 0;
  If Nvl(n_科室id, 0) = 0 Then
    While (n_Daycount < n_查询天数) Loop
      If Trunc(d_开始时间 + n_Daycount) = Trunc(Sysdate) Then
        d_开始时间 := Sysdate - n_Daycount;
      Else
        d_开始时间 := d_原始时间;
      End If;
      n_安排存在 := 0;
      v_上班时间 := Null;
      n_总已挂数 := 0;
      n_已挂数   := 0;
      n_剩余数   := 0;
      n_限号数   := 0;
      n_已约数   := 0;
      n_限约数   := 0;
      For r_排班 In (Select d_开始时间 + n_Daycount As 日期, a.排班, a.限号数, a.限约数, Nvl(Hz.已挂数, 0) As 已挂数, Nvl(Hz.已约数, 0) As 已约数,
                          a.安排id, a.计划id, a.号码, a.号类
                   
                   From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Nvl(Ap.医生id, 0) As 医生id, Ry.专业技术职务 As 职称, Ap.号码,
                                 Ap.安排id, Ap.计划id, Ap.排班, Ap.项目id, Fy.名称 As 项目名称, Ap.序号控制, Ap.限号数, Ap.限约数


                          
                          From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Ap.医生id, Ap.号码, Ap.Id As 安排id, 0 As 计划id,
                                        Ap.项目id, Nvl(Ap.序号控制, 0) As 序号控制,
                                        Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', Ap.周日, '2', Ap.周一, '3', Ap.周二, '4',
                                                Ap.周三, '5', Ap.周四, '6', Ap.周五, '7', Ap.周六, Null) As 排班,
                                        Nvl(Xz.限约数, Xz.限号数) As 限约数, Nvl(Xz.限号数, 0) As 限号数
                                 From 挂号安排 Ap, 部门表 Bm, 挂号安排限制 Xz
                                 Where Ap.科室id = Bm.Id(+) And Ap.医生id = n_医生id And Ap.停用日期 Is Null And
                                       d_开始时间 + n_Daycount Between Nvl(Ap.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                       Nvl(Ap.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.安排id(+) = Ap.Id And
                                       Xz.限制项目(+) = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二',
                                                           '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                  (Select Rownum
                                        From 挂号安排停用状态 Ty
                                        Where Ty.安排id = Ap.Id And d_开始时间 + n_Daycount Between Ty.开始停止时间 And Ty.结束停止时间) And
                                       Not Exists
                                  (Select Rownum
                                        From 挂号安排计划 Jh
                                        Where Jh.安排id = Ap.Id And Jh.审核时间 Is Not Null And
                                              d_开始时间 + n_Daycount Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                              Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')))
                                 Union All
                                 Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Jh.医生姓名, Jh.医生id, Ap.号码, Ap.Id As 安排id, Jh.Id As 计划id,
                                        Jh.项目id, Nvl(Jh.序号控制, 0) As 序号控制,
                                        Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', Jh.周日, '2', Jh.周一, '3', Jh.周二, '4',
                                                Jh.周三, '5', Jh.周四, '6', Jh.周五, '7', Jh.周六, Null) As 排班,
                                        Nvl(Xz.限约数, Xz.限号数) As 限约数, Nvl(Xz.限号数, 0) As 限号数
                                 From 挂号安排计划 Jh, 挂号安排 Ap, 部门表 Bm, 挂号计划限制 Xz
                                 Where Jh.安排id = Ap.Id And Ap.科室id = Bm.Id(+) And Ap.停用日期 Is Null And Jh.医生id = n_医生id And
                                       d_开始时间 + n_Daycount Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                       Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.计划id(+) = Jh.Id And
                                       Xz.限制项目(+) = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二',
                                                           '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                  (Select Rownum
                                        From 挂号安排停用状态 Ty
                                        Where Ty.安排id = Ap.Id And d_开始时间 + n_Daycount Between Ty.开始停止时间 And Ty.结束停止时间) And
                                       (Jh.生效时间, Jh.安排id) =
                                       (Select Max(Sxjh.生效时间) As 生效时间, 安排id
                                        From 挂号安排计划 Sxjh
                                        Where Sxjh.审核时间 Is Not Null And
                                              d_开始时间 + n_Daycount Between Nvl(Sxjh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                              Nvl(Sxjh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Sxjh.安排id = Jh.安排id
                                        Group By Sxjh.安排id)) Ap, 部门表 Bm, 人员表 Ry, 收费项目目录 Fy
                          Where Ap.科室id = Bm.Id(+) And Ap.医生id = Ry.Id(+) And Ap.项目id = Fy.Id And 排班 Is Not Null) A,
                        病人挂号汇总 Hz, 收费价目 B
                   Where a.号码 = Hz.号码(+) And Hz.日期(+) = Trunc(d_开始时间 + n_Daycount) And a.项目id = b.收费细目id And
                         b.终止日期 > d_开始时间 + n_Daycount And b.执行日期 <= d_开始时间 + n_Daycount
                   
                   ) Loop
        If v_号类 Is Null Or Instr(',' || v_号类 || ',', ',' || r_排班.号类 || ',') > 0 Then
          v_上班时间 := v_上班时间 || '+' || r_排班.排班;
          n_总已挂数 := n_总已挂数 + r_排班.已挂数;
          n_已挂数   := r_排班.已挂数;
          n_限号数   := r_排班.限号数;
          n_已约数   := r_排班.已约数;
          n_限约数   := r_排班.限约数;
          n_安排id   := Nvl(r_排班.安排id, 0);
          n_计划id   := Nvl(r_排班.计划id, 0);
          v_号码     := r_排班.号码;
          n_安排存在 := 1;
          If v_上班时间 Is Not Null Then
            If v_合作单位 Is Not Null Then
              If n_计划id <> 0 Then
                Begin
                  Select 1
                  Into n_合约存在
                  From 合作单位计划控制
                  Where 计划id = n_计划id And 合作单位 = v_合作单位 And Rownum < 2;
                Exception
                  When Others Then
                    n_合约存在 := 0;
                End;
              Else
                Begin
                  Select 1
                  Into n_合约存在
                  From 合作单位安排控制
                  Where 安排id = n_安排id And 合作单位 = v_合作单位 And Rownum < 2;
                Exception
                  When Others Then
                    n_合约存在 := 0;
                End;
              End If;
            End If;
          
            If v_合作单位 Is Null Or Nvl(n_合约存在, 0) = 0 Then
              If n_计划id <> 0 Then
                Begin
                  Select Sum(数量)
                  Into n_合作单位数量
                  From 合作单位计划控制
                  Where 计划id = n_计划id And
                        限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                      '周四', '6', '周五', '7', '周六', Null);
                Exception
                  When Others Then
                    n_合作单位数量 := 0;
                End;
              Else
                Begin
                  Select Sum(数量)
                  Into n_合作单位数量
                  From 合作单位安排控制
                  Where 安排id = n_安排id And
                        限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                      '周四', '6', '周五', '7', '周六', Null);
                Exception
                  When Others Then
                    n_合作单位数量 := 0;
                End;
              End If;
              Begin
                Select Count(1)
                Into n_合约已挂数
                From 病人挂号记录
                Where 号别 = v_号码 And 记录状态 = 1 And 合作单位 Is Not Null And 发生时间 Between Trunc(d_开始时间 + n_Daycount) And
                      Trunc(d_开始时间 + n_Daycount + 1) - 1 / 60 / 60 / 24;
              Exception
                When Others Then
                  n_合约已挂数 := 0;
              End;
              If n_合作单位数量 = 0 Then
                n_合作单位数量 := Null;
              End If;
              If Trunc(d_开始时间 + n_Daycount) > Trunc(Sysdate) Then
                n_剩余数 := Nvl(n_剩余数, 0) + n_限约数 - n_已约数 - Nvl(n_合作单位数量, n_合约已挂数) + Nvl(n_合约已挂数, 0);
              Else
                n_剩余数 := Nvl(n_剩余数, 0) + n_限号数 - n_已挂数 - Nvl(n_合作单位数量, n_合约已挂数) + Nvl(n_合约已挂数, 0);
              End If;
            Else
              --合约单位
              If n_计划id <> 0 Then
                Begin
                  Select 1
                  Into n_禁用
                  From 合作单位计划控制
                  Where 计划id = n_计划id And
                        限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                      '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
                Exception
                  When Others Then
                    n_禁用 := 0;
                End;
              Else
                Begin
                  Select 1
                  Into n_禁用
                  From 合作单位安排控制
                  Where 安排id = n_安排id And
                        限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                      '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
                Exception
                  When Others Then
                    n_禁用 := 0;
                End;
              End If;
              If Nvl(n_禁用, 0) = 0 Then
                Begin
                  Select Count(1)
                  Into n_合约已挂数
                  From 病人挂号记录
                  Where 号别 = v_号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_开始时间 + n_Daycount) And
                        Trunc(d_开始时间 + n_Daycount + 1) - 1 / 60 / 60 / 24;
                Exception
                  When Others Then
                    n_合约已挂数 := 0;
                End;
                If n_计划id <> 0 Then
                  Begin
                    Select Sum(数量)
                    Into n_合作单位数量
                    From 合作单位计划控制
                    Where 计划id = n_计划id And
                          限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                        '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
                  Exception
                    When Others Then
                      n_合作单位数量 := 0;
                  End;
                Else
                  Begin
                    Select Sum(数量)
                    Into n_合作单位数量
                    From 合作单位安排控制
                    Where 安排id = n_安排id And
                          限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                        '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
                  Exception
                    When Others Then
                      n_合作单位数量 := 0;
                  End;
                End If;
                If n_合作单位数量 = 0 Then
                  n_合作单位数量 := Null;
                End If;
                n_剩余数 := Nvl(n_剩余数, 0) + Nvl(n_合作单位数量, n_合约已挂数) - Nvl(n_合约已挂数, 0);
              
              End If;
            End If;
          End If;
          n_合作单位数量 := 0;
          n_合约存在     := 0;
          n_禁用         := 0;
        End If;
      End Loop;
      v_上班时间 := Substr(v_上班时间, 2);
      If n_安排存在 = 1 Then
        v_Temp := v_Temp || '<PB>' || '<RQ>' || To_Char(Trunc(d_开始时间 + n_Daycount), 'YYYY-MM-DD') || '</RQ>' ||
                  '<SYHS>' || n_剩余数 || '</SYHS>' || '<SBSJ>' || v_上班时间 || '</SBSJ>' || '<YGS>' || n_总已挂数 || '</YGS>' ||
                  '</PB>';
      End If;
      n_Daycount := n_Daycount + 1;
    End Loop;
  Else
    While (n_Daycount < n_查询天数) Loop
      If Trunc(d_开始时间 + n_Daycount) = Trunc(Sysdate) Then
        d_开始时间 := Sysdate - n_Daycount;
      Else
        d_开始时间 := d_原始时间;
      End If;
      v_上班时间 := Null;
      n_总已挂数 := 0;
      n_已挂数   := 0;
      n_剩余数   := 0;
      n_限号数   := 0;
      n_已约数   := 0;
      n_限约数   := 0;
      n_安排存在 := 0;
      For r_排班 In (Select d_开始时间 + n_Daycount As 日期, a.排班, a.限号数, a.限约数, Nvl(Hz.已挂数, 0) As 已挂数, Nvl(Hz.已约数, 0) As 已约数,
                          a.安排id, a.计划id, a.号码, a.号类
                   
                   From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Nvl(Ap.医生id, 0) As 医生id, Ry.专业技术职务 As 职称, Ap.号码,
                                 Ap.安排id, Ap.计划id, Ap.排班, Ap.项目id, Fy.名称 As 项目名称, Ap.序号控制, Ap.限号数, Ap.限约数


                          
                          From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Ap.医生id, Ap.号码, Ap.Id As 安排id, 0 As 计划id,
                                        Ap.项目id, Nvl(Ap.序号控制, 0) As 序号控制,
                                        Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', Ap.周日, '2', Ap.周一, '3', Ap.周二, '4',
                                                Ap.周三, '5', Ap.周四, '6', Ap.周五, '7', Ap.周六, Null) As 排班,
                                        Nvl(Xz.限约数, Xz.限号数) As 限约数, Nvl(Xz.限号数, 0) As 限号数
                                 From 挂号安排 Ap, 部门表 Bm, 挂号安排限制 Xz
                                 Where Ap.科室id = Bm.Id(+) And Ap.医生id = n_医生id And Ap.科室id = n_科室id And Ap.停用日期 Is Null And
                                       d_开始时间 + n_Daycount Between Nvl(Ap.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                       Nvl(Ap.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.安排id(+) = Ap.Id And
                                       Xz.限制项目(+) = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二',
                                                           '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                  (Select Rownum
                                        From 挂号安排停用状态 Ty
                                        Where Ty.安排id = Ap.Id And d_开始时间 + n_Daycount Between Ty.开始停止时间 And Ty.结束停止时间) And
                                       Not Exists
                                  (Select Rownum
                                        From 挂号安排计划 Jh
                                        Where Jh.安排id = Ap.Id And Jh.审核时间 Is Not Null And
                                              d_开始时间 + n_Daycount Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                              Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')))
                                 Union All
                                 Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Jh.医生姓名, Jh.医生id, Ap.号码, Ap.Id As 安排id, Jh.Id As 计划id,
                                        Jh.项目id, Nvl(Jh.序号控制, 0) As 序号控制,
                                        Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', Jh.周日, '2', Jh.周一, '3', Jh.周二, '4',
                                                Jh.周三, '5', Jh.周四, '6', Jh.周五, '7', Jh.周六, Null) As 排班,
                                        Nvl(Xz.限约数, Xz.限号数) As 限约数, Nvl(Xz.限号数, 0) As 限号数
                                 From 挂号安排计划 Jh, 挂号安排 Ap, 部门表 Bm, 挂号计划限制 Xz
                                 Where Jh.安排id = Ap.Id And Ap.科室id = Bm.Id(+) And Ap.停用日期 Is Null And Jh.医生id = n_医生id And
                                       Ap.科室id = n_科室id And
                                       d_开始时间 + n_Daycount Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                       Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.计划id(+) = Jh.Id And
                                       Xz.限制项目(+) = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二',
                                                           '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                  (Select Rownum
                                        From 挂号安排停用状态 Ty
                                        Where Ty.安排id = Ap.Id And d_开始时间 + n_Daycount Between Ty.开始停止时间 And Ty.结束停止时间) And
                                       (Jh.生效时间, Jh.安排id) =
                                       (Select Max(Sxjh.生效时间) As 生效时间, 安排id
                                        From 挂号安排计划 Sxjh
                                        Where Sxjh.审核时间 Is Not Null And
                                              d_开始时间 + n_Daycount Between Nvl(Sxjh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                              Nvl(Sxjh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Sxjh.安排id = Jh.安排id
                                        Group By Sxjh.安排id)) Ap, 部门表 Bm, 人员表 Ry, 收费项目目录 Fy
                          Where Ap.科室id = Bm.Id(+) And Ap.医生id = Ry.Id(+) And Ap.项目id = Fy.Id And 排班 Is Not Null) A,
                        病人挂号汇总 Hz, 收费价目 B
                   Where a.号码 = Hz.号码(+) And Hz.日期(+) = Trunc(d_开始时间 + n_Daycount) And a.项目id = b.收费细目id And
                         b.终止日期 > d_开始时间 + n_Daycount And b.执行日期 <= d_开始时间 + n_Daycount
                   
                   ) Loop
        If v_号类 Is Null Or Instr(',' || v_号类 || ',', ',' || r_排班.号类 || ',') > 0 Then
          v_上班时间 := v_上班时间 || '+' || r_排班.排班;
          n_总已挂数 := n_总已挂数 + r_排班.已挂数;
          n_已挂数   := r_排班.已挂数;
          n_限号数   := r_排班.限号数;
          n_已约数   := r_排班.已约数;
          n_限约数   := r_排班.限约数;
          n_安排id   := Nvl(r_排班.安排id, 0);
          n_计划id   := Nvl(r_排班.计划id, 0);
          v_号码     := r_排班.号码;
          n_安排存在 := 1;
        
          If v_上班时间 Is Not Null Then
            If v_合作单位 Is Not Null Then
              If n_计划id <> 0 Then
                Begin
                  Select 1
                  Into n_合约存在
                  From 合作单位计划控制
                  Where 计划id = n_计划id And 合作单位 = v_合作单位 And Rownum < 2;
                Exception
                  When Others Then
                    n_合约存在 := 0;
                End;
              Else
                Begin
                  Select 1
                  Into n_合约存在
                  From 合作单位安排控制
                  Where 安排id = n_安排id And 合作单位 = v_合作单位 And Rownum < 2;
                Exception
                  When Others Then
                    n_合约存在 := 0;
                End;
              End If;
            End If;
          
            If v_合作单位 Is Null Or Nvl(n_合约存在, 0) = 0 Then
              If n_计划id <> 0 Then
                Begin
                  Select Sum(数量)
                  Into n_合作单位数量
                  From 合作单位计划控制
                  Where 计划id = n_计划id And
                        限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                      '周四', '6', '周五', '7', '周六', Null);
                Exception
                  When Others Then
                    n_合作单位数量 := 0;
                End;
              Else
                Begin
                  Select Sum(数量)
                  Into n_合作单位数量
                  From 合作单位安排控制
                  Where 安排id = n_安排id And
                        限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                      '周四', '6', '周五', '7', '周六', Null);
                Exception
                  When Others Then
                    n_合作单位数量 := 0;
                End;
              End If;
              Begin
                Select Count(1)
                Into n_合约已挂数
                From 病人挂号记录
                Where 号别 = v_号码 And 记录状态 = 1 And 合作单位 Is Not Null And 发生时间 Between Trunc(d_开始时间 + n_Daycount) And
                      Trunc(d_开始时间 + n_Daycount + 1) - 1 / 60 / 60 / 24;
              Exception
                When Others Then
                  n_合约已挂数 := 0;
              End;
              If n_合作单位数量 = 0 Then
                n_合作单位数量 := Null;
              End If;
              If Trunc(d_开始时间 + n_Daycount) > Trunc(Sysdate) Then
                n_剩余数 := Nvl(n_剩余数, 0) + n_限约数 - n_已约数 - Nvl(n_合作单位数量, n_合约已挂数) + Nvl(n_合约已挂数, 0);
              Else
                n_剩余数 := Nvl(n_剩余数, 0) + n_限号数 - n_已挂数 - Nvl(n_合作单位数量, n_合约已挂数) + Nvl(n_合约已挂数, 0);
              End If;
            Else
              --合约单位
              If n_计划id <> 0 Then
                Begin
                  Select 1
                  Into n_禁用
                  From 合作单位计划控制
                  Where 计划id = n_计划id And
                        限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                      '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
                Exception
                  When Others Then
                    n_禁用 := 0;
                End;
              Else
                Begin
                  Select 1
                  Into n_禁用
                  From 合作单位安排控制
                  Where 安排id = n_安排id And
                        限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                      '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
                Exception
                  When Others Then
                    n_禁用 := 0;
                End;
              End If;
              If Nvl(n_禁用, 0) = 0 Then
                Begin
                  Select Count(1)
                  Into n_合约已挂数
                  From 病人挂号记录
                  Where 号别 = v_号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_开始时间 + n_Daycount) And
                        Trunc(d_开始时间 + n_Daycount + 1) - 1 / 60 / 60 / 24;
                Exception
                  When Others Then
                    n_合约已挂数 := 0;
                End;
                If n_计划id <> 0 Then
                  Begin
                    Select Sum(数量)
                    Into n_合作单位数量
                    From 合作单位计划控制
                    Where 计划id = n_计划id And
                          限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                        '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
                  Exception
                    When Others Then
                      n_合作单位数量 := 0;
                  End;
                Else
                  Begin
                    Select Sum(数量)
                    Into n_合作单位数量
                    From 合作单位安排控制
                    Where 安排id = n_安排id And
                          限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                        '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
                  Exception
                    When Others Then
                      n_合作单位数量 := 0;
                  End;
                End If;
                If n_合作单位数量 = 0 Then
                  n_合作单位数量 := Null;
                End If;
                n_剩余数 := Nvl(n_剩余数, 0) + Nvl(n_合作单位数量, n_合约已挂数) - Nvl(n_合约已挂数, 0);
              
              End If;
            End If;
          End If;
          n_合作单位数量 := 0;
          n_合约存在     := 0;
          n_禁用         := 0;
        End If;
      End Loop;
      v_上班时间 := Substr(v_上班时间, 2);
      If n_安排存在 = 1 Then
        v_Temp := v_Temp || '<PB>' || '<RQ>' || To_Char(Trunc(d_开始时间 + n_Daycount), 'YYYY-MM-DD') || '</RQ>' ||
                  '<SYHS>' || n_剩余数 || '</SYHS>' || '<SBSJ>' || v_上班时间 || '</SBSJ>' || '<YGS>' || n_总已挂数 || '</YGS>' ||
                  '</PB>';
      End If;
      n_Daycount := n_Daycount + 1;
    End Loop;
  End If;
  v_Temp := '<PBLIST>' || v_Temp || '</PBLIST>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Docarrange;
/

--92729:胡俊勇,2016-02-16,专业版RIS接口
Create Or Replace Procedure Zl_Ris检查预约_Insert
(
  医嘱id_In     In Ris检查预约.医嘱id%Type,
  预约id_In     In Ris检查预约.预约id%Type,
  预约日期_In   In Ris检查预约.预约日期%Type,
  设备id_In     In Ris检查预约.检查设备id%Type,
  设备名称_In   In Ris检查预约.检查设备名称%Type,
  开始时间_In   In Ris检查预约.预约开始时间%Type,
  结束时间_In   In Ris检查预约.预约结束时间%Type,
  开始时间段_In In Ris检查预约.预约开始时间段%Type,
  结束时间段_In In Ris检查预约.预约结束时间段%Type
) Is
Begin
  Insert Into Ris检查预约
    (医嘱id, 预约id, 预约日期, 检查设备id, 检查设备名称, 预约开始时间, 预约结束时间, 预约开始时间段, 预约结束时间段)
  Values
    (医嘱id_In, 预约id_In, 预约日期_In, 设备id_In, 设备名称_In, 开始时间_In, 结束时间_In, 开始时间段_In, 结束时间段_In);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Ris检查预约_Insert;
/

--92729:胡俊勇,2016-01-26,专业版RIS接口处理
Create Or Replace Procedure Zl_Ris检查预约_Delete(医嘱id_In In Ris检查预约.医嘱id%Type) Is
Begin
  Delete Ris检查预约 Where 医嘱id = 医嘱id_In;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Ris检查预约_Delete;
/


--93853:张永康,2016-03-03,历史数据抽回错误修正
--93801:吴涛,2016-03-02,历史数据抽回的错误
--92729:胡俊勇,2016-01-26,专业版RIS接口处理
--91225:梁经伙,2015-12-16,传染病管理系统新增加 疾病报告反馈 表
Create Or Replace Procedure Zl_Retu_Clinic
(
  n_Patiid In Number,
  v_Times  In Varchar2,
  n_Flag   In Number
) As
  --------------------------------------------
  --参数:n_Patiid,病人id
  --     v_Times,挂号单号或住院主页id（体检时，挂号单是体检单号）
  --     n_Flag,门诊或住院标志:0-门诊,1-住院,2-体检（此时，只有n_Patiid参数无效）
  --------------------------------------------
  Err_Item Exception;
  v_Err_Msg    Varchar2(100);
  n_System     Number(5);
  n_Opersystem Number(5);
  n_只读       Number(2);

  v_Table    Varchar2(100);
  v_Subtable Varchar2(100);
  v_Field    Varchar2(100);
  v_Subfield Varchar2(100);
  v_Sql      Varchar2(4000);
  v_Sqlchild Varchar2(4000);
  v_Fields   Varchar2(4000);

  --功能：获取表的字段字符串
  Function Getfields(v_Table In Varchar2) Return Varchar2 As
    v_Colstr Varchar2(4000);
  Begin
    Select f_List2str(Cast(Collect(Column_Name) As t_Strlist)) As Colsstr
    Into v_Colstr
    From (Select Column_Name From User_Tab_Columns Where Table_Name = v_Table Order By Column_Id);
  
    Return v_Colstr;
  End Getfields;

  --------------------------------------------
  --返回指定病人ID和主页的相关表的子过程
  --------------------------------------------
  Procedure Zl_Retu_Other
  (
    n_Pati_Id 病案主页.病人id%Type,
    n_Page_Id 病案主页.主页id%Type
  ) As
  
  Begin
  
    For R In (Select Column_Value From Table(f_Str2list('病人过敏记录,病人诊断记录,病人手麻记录'))) Loop
      v_Table  := r.Column_Value;
      v_Fields := Getfields(v_Table);
      v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                  Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table || ' Where 病人id = :1 And 主页id = :2';
      Execute Immediate v_Sql
        Using n_Pati_Id, n_Page_Id;
    
      v_Sql := 'Delete From H' || v_Table || ' Where 病人id = :1 And 主页id = :2';
      Execute Immediate v_Sql
        Using n_Pati_Id, n_Page_Id;
    End Loop;
  End Zl_Retu_Other;

  --------------------------------------------
  --返回指定病人ID和主页的临床路径相关表的子过程
  --------------------------------------------
  Procedure Zl_Retu_Path
  (
    n_Pati_Id 病案主页.病人id%Type,
    n_Page_Id 病案主页.主页id%Type
  ) As
  Begin
    v_Table  := '病人临床路径';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                ' From H' || v_Table || ' Where 病人id = :1 And 主页id = :2 ';
    Execute Immediate v_Sql
      Using n_Pati_Id, n_Page_Id;
  
    --病人路径医嘱，在病人医嘱记录转出之后执行
    For P In (Select ID As 路径记录id From H病人临床路径 Where 病人id = n_Pati_Id And 主页id = n_Page_Id) Loop
      For R In (Select Column_Value
                From Table(f_Str2list('病人路径执行,病人合并路径,病人路径评估,病人路径变异,病人路径指标,病人合并路径评估,病人出径记录'))) Loop
        v_Table := r.Column_Value;
        If v_Table = '病人合并路径' Then
          v_Field := '首要路径记录id';
        Else
          v_Field := '路径记录id';
        End If;
      
        v_Fields := Getfields(v_Table);
        v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                    Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table || ' Where ' || v_Field || ' = :1';
        Execute Immediate v_Sql
          Using p.路径记录id;
      
        v_Sql := 'Delete H' || v_Table || ' Where ' || v_Field || ' = :1';
        Execute Immediate v_Sql
          Using p.路径记录id;
      End Loop;
    End Loop;
  
    Delete H病人临床路径 Where 病人id = n_Pati_Id And 主页id = n_Page_Id;
  End Zl_Retu_Path;

  --------------------------------------------
  --返回指定病人ID和主页的护理相关表的子过程
  --------------------------------------------
  Procedure Zl_Retu_Tend
  (
    n_Pati_Id 病案主页.病人id%Type,
    n_Page_Id 病案主页.主页id%Type
  ) As
  Begin
  
    v_Table  := '病人护理文件';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                ' From H' || v_Table || ' Where 病人id = :1 And 主页id = :2 ';
    Execute Immediate v_Sql
      Using n_Pati_Id, n_Page_Id;
  
    For P In (Select ID As 文件id From H病人护理文件 Where 病人id = n_Pati_Id And 主页id = n_Page_Id) Loop
      For R In (Select Column_Value
                From Table(f_Str2list('病人护理数据,病人护理打印,病人护理活动项目,病人护理要素内容,产程要素内容'))) Loop
        v_Table  := r.Column_Value;
        v_Fields := Getfields(v_Table);
        v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                    Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table || ' Where 文件id = :1';
        Execute Immediate v_Sql
          Using p.文件id;
      
        If v_Table = '病人护理数据' Then
          v_Fields := Getfields('病人护理明细');
          v_Sql    := 'Insert Into 病人护理明细(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                      ' From H病人护理明细 Where 记录id In (Select ID From H病人护理数据 Where 文件id = :1)';
          Execute Immediate v_Sql
            Using p.文件id;
        
          v_Sql := 'Delete H病人护理明细 Where 记录id In (Select ID From H病人护理数据 Where 文件id = :1)';
          Execute Immediate v_Sql
            Using p.文件id;
        End If;
      
        v_Sql := 'Delete H' || v_Table || ' Where 文件id = :1';
        Execute Immediate v_Sql
          Using p.文件id;
      End Loop;
    End Loop;
  
    Delete H病人护理文件 Where 病人id = n_Pati_Id And 主页id = n_Page_Id;
  
    --老版护理系统数据
    ------------------------------------------------------------------------
    v_Table  := '病人护理记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                ' From H' || v_Table || ' Where 病人id = :1 And 主页id = :2 ';
    Execute Immediate v_Sql
      Using n_Pati_Id, n_Page_Id;
  
    For P In (Select ID From H病人护理记录 Where 病人id = n_Pati_Id And 主页id = n_Page_Id) Loop
      v_Table  := '病人护理内容';
      v_Fields := Getfields(v_Table);
      v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                  Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table || ' Where 记录ID = :1';
      Execute Immediate v_Sql
        Using p.Id;
    
      v_Sql := 'Delete H' || v_Table || ' Where 记录ID = :1';
      Execute Immediate v_Sql
        Using p.Id;
    End Loop;
  
    Delete H病人护理记录 Where 病人id = n_Pati_Id And 主页id = n_Page_Id;
  End Zl_Retu_Tend;

  --------------------------------------------
  --返回指定ID的病人新版电子病历记录子过程
  --------------------------------------------
  Procedure Zl_Retu_Epr(n_Rec_Id H电子病历记录.Id%Type) As
    v_Field Varchar(100);
  Begin
    v_Table  := '电子病历记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                ' From H' || v_Table || ' Where id = :1';
    Execute Immediate v_Sql
      Using n_Rec_Id;
  
    --病人诊断记录在Zl_Retu_Other中已转回（无病历ID外键）
    --影像报告驳回,病人医嘱报告,报告查阅记录,这几张表的数据在Zl_Retu_Order中转回医嘱后再处理
    For R In (Select Column_Value
              From Table(f_Str2list('电子病历附件,电子病历格式,电子病历内容,疾病申报记录,疾病报告反馈'))) Loop
      v_Table := r.Column_Value;
      If v_Table = '电子病历附件' Then
        v_Field := '病历id';
      Else
        v_Field := '文件id';
      End If;
      v_Fields := Getfields(v_Table);
      v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                  Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table || ' Where ' || v_Field || ' = :1';
      Execute Immediate v_Sql
        Using n_Rec_Id;
    
      If v_Table = '电子病历内容' Then
        v_Fields := Getfields('电子病历图形');
        v_Sql    := 'Insert Into 电子病历图形(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                    ' From H电子病历图形 Where 对象id In (Select ID From H电子病历内容 Where 文件id = :1 And 对象类型 = 5)';
        Execute Immediate v_Sql
          Using n_Rec_Id;
      
        Delete H电子病历图形 Where 对象id In (Select ID From H电子病历内容 Where 文件id = n_Rec_Id And 对象类型 = 5);
      End If;
    
      v_Sql := 'Delete H' || v_Table || ' Where ' || v_Field || ' = :1';
      Execute Immediate v_Sql
        Using n_Rec_Id;
    End Loop;
  
    Delete H电子病历记录 Where ID = n_Rec_Id;
  End Zl_Retu_Epr;
  --------------------------------------------
  --返回指定ID的病人医嘱记录子过程，必须在病历、临床路径转出之后执行(病人医嘱报告,影像报告驳回，病人路径医嘱)
  --在Zl_Retu_Other中已转回了"病人诊断记录",转回"病人诊断医嘱"时不用再转
  --------------------------------------------
  Procedure Zl_Retu_Order(n_Rec_Id H病人医嘱记录.Id%Type) As
  Begin
    v_Table  := '病人医嘱记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                ' From H' || v_Table || ' Where id = :1';
    Execute Immediate v_Sql
      Using n_Rec_Id;
  
    --以"医嘱ID,发送号"为外键的，都按医嘱ID直接转回，只需要排在"病人医嘱发送"之后即可
    --由于外键关系，"报告查阅记录"须在"病人医嘱报告"后面
    For P In (Select Column_Value
              From Table(f_Str2list('病人医嘱计价,病人医嘱状态,病人医嘱发送,病人医嘱附费,病人医嘱附件,病人医嘱执行,病人医嘱打印,输血申请记录,输血检验结果,' ||
                                     '医嘱执行打印,医嘱执行时间,医嘱执行计价,执行打印记录,病人诊断医嘱,病人路径医嘱,病人医嘱报告,报告查阅记录,' ||
                                     '影像报告驳回,影像报告记录,影像报告操作记录,影像检查记录,影像申请单图像,影像收藏内容,影像危急值记录,检验标本记录,检验试剂记录,检验拒收记录,RIS检查预约'))) Loop
      v_Table := p.Column_Value;
      If Instr('病人路径医嘱', v_Table) > 0 Then
        v_Field := '病人医嘱ID';
      Else
        v_Field := '医嘱ID';
      End If;
    
      v_Fields := Getfields(v_Table);
      v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                  Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table || ' Where ' || v_Field || ' = :1';
      If v_Table = '病人医嘱状态' Then
        v_Sqlchild := v_Sql;
      Else
        Execute Immediate v_Sql
          Using n_Rec_Id;
      End If;
    
      If v_Table = '病人医嘱状态' Then
        v_Fields := Getfields('医嘱签名记录');
        v_Sql    := 'Insert Into 医嘱签名记录(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                    ' From H医嘱签名记录 Where ID In (Select 签名id From H病人医嘱状态 Where 医嘱id = :1 And 签名id Is Not Null)';
        Execute Immediate v_Sql
          Using n_Rec_Id;
        Delete H医嘱签名记录
        Where ID In (Select 签名id From H病人医嘱状态 Where 医嘱id = n_Rec_Id And 签名id Is Not Null);
      
        Execute Immediate v_Sqlchild
          Using n_Rec_Id;
      
      Elsif v_Table = '病人医嘱发送' Then
        v_Fields := Getfields('诊疗单据打印');
        v_Sql    := 'Insert Into 诊疗单据打印(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                    ' From H诊疗单据打印 Where (NO, 记录性质) In (Select NO, 记录性质 From H病人医嘱发送 Where 医嘱id = :1)';
        Execute Immediate v_Sql
          Using n_Rec_Id;
        Delete H诊疗单据打印 Where (NO, 记录性质) In (Select NO, 记录性质 From H病人医嘱发送 Where 医嘱id = n_Rec_Id);
      
      Elsif v_Table = '影像检查记录' Then
        v_Fields := Getfields('影像检查序列');
        v_Sql    := 'Insert Into 影像检查序列(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                    ' From H影像检查序列 Where 检查uid In (Select 检查uid From H影像检查记录 Where 医嘱id = :1)';
        Execute Immediate v_Sql
          Using n_Rec_Id;
      
        v_Fields := Getfields('影像检查图象');
        v_Sql    := 'Insert Into 影像检查图象(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                    ' From H影像检查图象 Where 序列uid In (Select b.序列uid From H影像检查记录 A, H影像检查序列 B Where a.医嘱id = :1 And a.检查uid = b.检查uid)';
        Execute Immediate v_Sql
          Using n_Rec_Id;
      
        Delete H影像检查图象
        Where 序列uid In (Select b.序列uid
                        From H影像检查记录 A, H影像检查序列 B
                        Where a.医嘱id = n_Rec_Id And a.检查uid = b.检查uid);
        Delete H影像检查序列 Where 检查uid In (Select 检查uid From H影像检查记录 Where 医嘱id = n_Rec_Id);
      
      Elsif v_Table = '检验标本记录' Then
        For R In (Select Column_Value
                  From Table(f_Str2list('检验申请项目,检验分析记录,检验项目分布,检验质控记录,检验操作记录,检验签名记录,检验图像结果'))) Loop
          v_Subtable := r.Column_Value;
          If v_Subtable = '检验签名记录' Then
            v_Subfield := '检验标本ID';
          Else
            v_Subfield := '标本ID';
          End If;
          v_Fields := Getfields(v_Subtable);
          v_Sql    := 'Insert Into ' || v_Subtable || '(' || v_Fields || ') Select ' ||
                      Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Subtable || ' Where ' || v_Subfield ||
                      ' In (Select ID From H检验标本记录 Where 医嘱id = :1)';
          Execute Immediate v_Sql
            Using n_Rec_Id;
        
          v_Sql := 'Delete H' || v_Subtable || ' Where ' || v_Subfield ||
                   ' In (Select ID From H检验标本记录 Where 医嘱id = :1)';
          Execute Immediate v_Sql
            Using n_Rec_Id;
        End Loop;
      
        v_Fields := Getfields('检验普通结果');
        v_Sql    := 'Insert Into 检验普通结果(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                    ' From H检验普通结果 Where 检验标本id In (Select ID From H检验标本记录 Where 医嘱id = :1)';
        Execute Immediate v_Sql
          Using n_Rec_Id;
      
        v_Fields := Getfields('检验药敏结果');
        v_Sql    := 'Insert Into 检验药敏结果(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                    ' From H检验药敏结果 Where 细菌结果id In (Select ID From H检验普通结果 Where 检验标本id In (Select ID From H检验标本记录 Where 医嘱id = :1))';
        Execute Immediate v_Sql
          Using n_Rec_Id;
      
        v_Fields := Getfields('检验质控报告');
        v_Sql    := 'Insert Into 检验质控报告(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                    ' From H检验质控报告 Where 结果ID In (Select ID From H检验普通结果 Where 检验标本id In (Select ID From H检验标本记录 Where 医嘱id = :1))';
        Execute Immediate v_Sql
          Using n_Rec_Id;
      
        Delete H检验药敏结果
        Where 细菌结果id In
              (Select ID From H检验普通结果 Where 检验标本id In (Select ID From H检验标本记录 Where 医嘱id = n_Rec_Id));
        Delete H检验质控报告
        Where 结果id In
              (Select ID From H检验普通结果 Where 检验标本id In (Select ID From H检验标本记录 Where 医嘱id = n_Rec_Id));
      
        Delete H检验普通结果 Where 检验标本id In (Select ID From H检验标本记录 Where 医嘱id = n_Rec_Id);
      End If;
    
      v_Sql := 'Delete H' || v_Table || ' Where ' || v_Field || ' = :1';
      Execute Immediate v_Sql
        Using n_Rec_Id;
    End Loop;
  
    --手麻数据
    If n_Opersystem > 0 Then
      Execute Immediate 'Call zl24_Retu_Oper(:1)'
        Using n_Rec_Id;
    End If;
  
    Delete H病人医嘱记录 Where ID = n_Rec_Id;
  End Zl_Retu_Order;

  --------------------------------------------
  --以下为主程序体
  --------------------------------------------
Begin
  ----------------------------------------------------------------------------------------------------------
  --对基于视图的转储方案进行了只读判断.
  Select 编号 Into n_System From zlSystems Where Upper(所有者) = Zl_Owner And 编号 Like '1%';
  Begin
    Select Nvl(只读, 0) Into n_只读 From zlBakSpaces Where 系统 = n_System And 当前 = 1;
  Exception
    When Others Then
      v_Err_Msg := '[ZLSOFT]当前没有可用的历史数据空间,不能继续![ZLSOFT]';
      Raise Err_Item;
  End;
  If n_只读 = 1 Then
    v_Err_Msg := '[ZLSOFT]历史数据空间目前的状态为只读,不能继续![ZLSOFT]';
    Raise Err_Item;
  End If;

  --对基于视图的转储方案进行了只读判断.
  n_Opersystem := 0;
  Select 编号 Into n_Opersystem From zlSystems Where Upper(所有者) = Zl_Owner And 编号 Like '24%';
  If n_Opersystem > 0 Then
    Begin
      Select Nvl(只读, 0) Into n_只读 From zlBakSpaces Where 系统 = n_Opersystem And 当前 = 1;
    Exception
      When Others Then
        v_Err_Msg := '[ZLSOFT]当前没有可用的手麻子系统历史数据空间,不能继续![ZLSOFT]';
        Raise Err_Item;
    End;
    If n_只读 = 1 Then
      v_Err_Msg := '[ZLSOFT]手麻子系统历史数据空间目前的状态为只读,不能继续![ZLSOFT]';
      Raise Err_Item;
    End If;
  End If;

  --1.门诊病人，按挂号单抽回
  If n_Flag = 0 Then
    --抽回未结记帐费用
    Zl_Retu_Exes(n_Patiid, 8);
  
    v_Table  := '病人挂号记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                ' From H' || v_Table || ' Where NO =:1 ';
    Execute Immediate v_Sql
      Using v_Times;
  
    For r_Other In (Select ID, 病人id From H病人挂号记录 Where NO = v_Times) Loop
      Zl_Retu_Other(r_Other.病人id, r_Other.Id);
    End Loop;
  
    For r_Epr In (Select /*+ Rule*/
                   b.Id
                  From H病人挂号记录 A, H电子病历记录 B
                  Where a.No = v_Times And a.病人id = n_Patiid And b.病人id = a.病人id And b.主页id = a.Id) Loop
      Zl_Retu_Epr(r_Epr.Id);
    End Loop;
  
    For r_Order In (Select ID From H病人医嘱记录 Where 病人来源 <> 4 And 病人id = n_Patiid And 挂号单 = v_Times) Loop
      Zl_Retu_Order(r_Order.Id);
    End Loop;
  
    --转诊记录
    v_Table  := '病人转诊记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                ' From H' || v_Table || ' Where NO =:1';
    Execute Immediate v_Sql
      Using v_Times;
  
    Delete H病人转诊记录 Where NO = v_Times;
    Delete H病人挂号记录 Where NO = v_Times;
  
    --2.住院病人，按病人ID和主页ID抽回
  Elsif n_Flag = 1 Then
    --抽回未结记帐费用
    Zl_Retu_Exes(n_Patiid || ',' || v_Times, 8);
  
    Zl_Retu_Other(n_Patiid, To_Number(v_Times));
    Zl_Retu_Path(n_Patiid, To_Number(v_Times));
  
    --先转病历，再转医嘱（影像报告驳回，病人医嘱报告这类又有病历又有医嘱的子表，在医嘱转回后处理）
    For r_Epr In (Select ID From H电子病历记录 Where 病人id = n_Patiid And 主页id = To_Number(v_Times)) Loop
      Zl_Retu_Epr(r_Epr.Id);
    End Loop;
  
    Zl_Retu_Tend(n_Patiid, To_Number(v_Times));
  
    For r_Order In (Select ID From H病人医嘱记录 Where 病人id = n_Patiid And 主页id = To_Number(v_Times)) Loop
      Zl_Retu_Order(r_Order.Id);
    End Loop;
    Update 病案主页 Set 数据转出 = 0 Where 病人id = n_Patiid And 主页id = To_Number(v_Times);
  
    --3.体检病人
  Elsif n_Flag = 2 Then
    Zl_Retu_Other(n_Patiid, v_Times);
  
    For r_Cpr In (Select ID From H病人医嘱记录 Where 病人来源 = 4 And 挂号单 = v_Times) Loop
      Zl_Retu_Order(r_Cpr.Id);
    End Loop;
  
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM || ':' || v_Sql);
End Zl_Retu_Clinic;
/

--92729:胡俊勇,2016-01-26,专业版RIS接口处理
--91225:梁经伙,2015-12-16,传染病管理系统新增表 疾病报告反馈
Create Or Replace Procedure Zl1_Datamove_Reb
(
  System_In    In Number,
  Speedmode_In In Number,
  Func_In      In Number,
  Enable_In    In Number := 0,
  Parallel_In  In Number := 0,
  Rebscope_In  In Number := 0
) As
  --功能：在历史数据转出之前，禁用触发器、自动作业、约束、索引，转出之后启用这些对象，以及重建待转出索引，收回标记转出所用索引的空间 
  --参数： 
  --System_In:    应用系统编号,100=标准版 
  --speedmode_in：数据转出模式，0-在线模式，1-离线模式（在客户端停用时，转出期间禁用转出表的主键、唯一键、外键约束和索引，以加快已转数据的删除操作） 
  --func_in:      1=触发器，2=自动作业，3=约束，4=索引，5=重建待转出索引，6-收回标记转出所用索引的空间，7-重组表的存储空间（move），并恢复被禁用的约束和索引 ,8-重建标记转出查询所需索引以外的其他索引 
  --Enable_in:    0-禁用，1=启用，对func_in值为1-4有效 
  --rebScope_in:   Func_In=6时，指重建索引的范围(0-经济核算类,1-经济核算类及医嘱类,2-全部)，Func_In=7时指Move表的范围(0-经济核算类，1-全部) 

  v_Sql      Varchar2(4000);
  n_Do       Number(1);
  n_Parallel Number(1);
  v_Tbs      Varchar2(100);

  --转出标记中的SQL查询所需的索引
  v_Indexeswithtag Varchar2(4000) := '门诊费用记录_IX_结帐ID,住院费用记录_IX_结帐ID,费用补充记录_IX_结算ID,费用补充记录_IX_登记时间,病人预交记录_IX_主页ID,病人预交记录_IX_结帐ID,病人预交记录_IX_收款时间,门诊费用记录_IX_登记时间,门诊费用记录_IX_医嘱序号,住院费用记录_IX_登记时间,病人结帐记录_IX_收费时间,病人结帐记录_IX_病人id' ||
                                     ',药品收发记录_IX_费用ID,收发记录补充信息_IX_收发ID,输液配药内容_IX_收发ID,药品留存计划_IX_留存ID,药品签名明细_IX_收发ID' ||
                                     ',人员借款记录_IX_借出时间,人员收缴记录_IX_登记时间,人员暂存记录_IX_收缴ID,人员暂存记录_IX_登记时间,票据领用记录_IX_登记时间,票据使用明细_IX_领用ID,票据打印明细_IX_使用ID' ||
                                     ',病人挂号记录_IX_登记时间,病人医嘱发送_IX_发送时间,病人医嘱记录_IX_挂号单,病人医嘱记录_IX_主页ID,病人医嘱记录_IX_相关ID' ||
                                     ',病案主页_IX_出院日期,住院费用记录_IX_病人ID,病人过敏记录_IX_病人ID,病人诊断记录_IX_病人ID,病人手麻记录_IX_主页ID' ||
                                     ',病人护理记录_IX_主页ID,病人护理内容_IX_记录id,病人护理文件_IX_主页ID,病人护理数据_IX_文件ID,病人护理明细_IX_记录ID,病人护理打印_IX_文件ID' ||
                                     ',电子病历记录_IX_病人ID,病人医嘱报告_IX_病历ID,影像报告驳回_IX_医嘱ID,报告查阅记录_IX_病历ID,病人诊断记录_IX_病历ID' ||
                                     ',病人临床路径_IX_病人ID,病人合并路径_IX_首要路径记录ID,病人路径执行_IX_路径记录ID,病人出径记录_IX_路径记录ID,病人诊断医嘱_IX_医嘱ID' ||
                                     ',影像报告记录_IX_医嘱ID,影像报告操作记录_IX_医嘱ID,影像申请单图像_IX_医嘱ID,影像收藏内容_IX_医嘱ID,检验标本记录_IX_医嘱ID,检验项目分布_IX_标本ID,检验分析记录_IX_标本ID' ||
                                     ',检验操作记录_IX_标本ID,检验图像结果_IX_标本ID,检验拒收记录_IX_医嘱ID,检验普通结果_IX_检验标本ID,处方审查明细_IX_医嘱ID';

  --转出标记中的SQL查询所需的索引(主键及唯一键对应的索引)
  v_Constraintswithtag Varchar2(4000) := '病人预交记录_UQ_NO,病人结帐记录_UQ_NO,病人结帐记录_PK,门诊费用记录_UQ_NO,住院费用记录_UQ_NO,医保结算明细_PK' ||
                                         ',病人卡结算对照_PK,费用补充记录_PK,病人卡结算记录_PK,三方结算交易_PK,三方退款信息_PK,输液配药记录_PK,药品签名记录_PK,票据打印内容_PK,病人挂号记录_PK,病人挂号汇总_UQ_日期,病人转诊记录_UQ_NO' ||
                                         ',病人护理活动项目_UQ_页号,病人护理要素内容_UQ_页号,产程要素内容_PK,电子病历记录_PK,电子病历附件_PK,电子病历格式_PK,电子病历内容_UQ_对象序号,电子病历图形_PK,疾病申报记录_PK,疾病报告反馈_PK' ||
                                         ',病人合并路径评估_PK,病人路径评估_PK,病人路径变异_PK,病人路径指标_UQ_评估指标,病人路径医嘱_PK' ||
                                         ',病人医嘱记录_PK,病人医嘱报告_PK,病人医嘱计价_UQ_收费细目ID,病人医嘱附费_PK,病人医嘱附件_PK,病人医嘱执行_PK,医嘱执行时间_PK,医嘱执行打印_PK,病人医嘱打印_UQ_医嘱ID,输血申请记录_PK,输血检验结果_PK' ||
                                         ',病人诊断记录_PK,病人医嘱状态_PK,医嘱签名记录_PK,病人医嘱发送_PK,诊疗单据打印_PK,医嘱执行计价_PK,执行打印记录_PK' ||
                                         ',影像检查记录_PK,影像检查序列_UQ_序列号,影像检查图象_UQ_图像号,影像危急值记录_UQ_医嘱ID' ||
                                         ',检验申请项目_PK,检验质控记录_PK,检验签名记录_PK,检验试剂记录_PK,检验质控报告_PK,检验药敏结果_PK,人员收缴记录_PK,人员收缴明细_PK,人员收缴票据_PK,人员收缴对照_PK' ||
                                         ',处方审查记录_PK,处方审查结果_UQ_审方ID,费用清单打印_UQ_NO,RIS检查预约_PK';

  --功能：1.禁用或启用引用转出表主键的他表外键,避免删除主表记录时对子表每行记录执行一次SQL查询或删除 
  --      2.禁用或启用主键或唯一键约束（禁用时会自动删除对应的索引，启用时自动创建），以提高数据删除性能 
  --例如：病人医嘱发送_FK_医嘱ID，如果这些外键所在的表，数据未转出（未在zlbaktables表中定义），执行前会检查并限制转出。 
  Procedure Setconstraintstatus As
    v_Pcol Varchar2(50);
    v_Fcol Varchar2(50);
    v_Del  Varchar2(4000);
  Begin
    --禁用时，先禁用引用转出表主键的他表外键，再禁用转出表的主键 
    If Enable_In = 0 Then
      --1.在线模式转出时，由于有业务产生删除操作，所以，对于级联删除的外键，用触发器来替代对子表数据的删除操作
      If Speedmode_In = 0 Then
        For Rp In (Select Distinct a.Table_Name As Ptable_Name, a.Constraint_Name
                   From User_Constraints A, User_Constraints C, zlBakTables B
                   Where a.Table_Name = b.表名 And b.直接转出 = 1 And b.系统 = System_In And a.Constraint_Type In ('P', 'U') And
                         c.r_Constraint_Name = a.Constraint_Name And c.Constraint_Type = 'R' And
                         c.Delete_Rule = 'CASCADE'
                   Order By a.Table_Name) Loop
        
          Select f_List2str(Cast(Collect(Column_Name Order By Position) As t_Strlist))
          Into v_Pcol
          From User_Cons_Columns
          Where Constraint_Name = Rp.Constraint_Name;
        
    v_Del := '';
          For Rf In (Select b.Table_Name, b.Constraint_Name,
                            f_List2str(Cast(Collect(b.Column_Name Order By b.Position) As t_Strlist)) As r_Col
                     From User_Constraints A, User_Cons_Columns B
                     Where a.r_Constraint_Name = Rp.Constraint_Name And a.Constraint_Name = b.Constraint_Name
                     Group By b.Table_Name, b.Constraint_Name) Loop
            If Instr(v_Pcol, ',') > 0 Then
              v_Del := v_Del || Chr(10) || '        Delete ' || Rf.Table_Name || ' Where (' || Rf.r_Col ||
                       ') in ((:Old.' || Replace(v_Pcol, ',', ',:Old.') || '));';
            Else
              v_Del := v_Del || Chr(10) || '        Delete ' || Rf.Table_Name || ' Where ' || Rf.r_Col || ' = :Old.' ||
                       v_Pcol || ';';
            End If;
          End Loop;
        
          v_Sql := 'Create Or Replace Trigger ' || Rp.Ptable_Name || '_Cascade_Del' || Chr(10) ||
                   '    After Delete On ' || Rp.Ptable_Name || Chr(10) || '    For Each Row' || Chr(10) || 'Begin' ||
                   Chr(10) || '    If :Old.待转出 Is Null Then ' || v_Del || Chr(10) || '    End If; ' || Chr(10) ||
                   'End ' || Rp.Ptable_Name || '_Cascade_Del;';
          Execute Immediate v_Sql;
        End Loop;
      End If;
    
      --2.禁用引用转出表主键的他表外键
      For R In (Select c.Table_Name, c.Constraint_Name, a.Table_Name As Ptable_Name
                From User_Constraints A, User_Constraints C, zlBakTables B
                Where a.Table_Name = b.表名 And b.直接转出 = 1 And b.系统 = System_In And a.Constraint_Type In ('P', 'U') And
                      c.r_Constraint_Name = a.Constraint_Name And c.Constraint_Type = 'R' And c.Status = 'ENABLED'
                Order By a.Table_Name) Loop
        v_Sql := 'Alter Table ' || r.Table_Name || ' Disable Constraint ' || r.Constraint_Name;
        Execute Immediate v_Sql;
      End Loop;
    
      --3.禁用主键或唯一键索引(离线转出时)
      If Speedmode_In = 1 Then
        --必须删除索引，否则即使skip_unusable_indexes为true，也无法删除存在Unusable状态的唯一性索引的表中的记录
        --保留转出标记中的SQL查询所需的索引(主键和唯一键对应的索引) 
        For R In (Select a.Table_Name, a.Constraint_Name
                  From User_Constraints A, zlBakTables T, User_Tables B
                  Where a.Table_Name = t.表名 And t.直接转出 = 1 And t.系统 = System_In And a.Status = 'ENABLED' And
                        a.Constraint_Type In ('P', 'U') And a.Table_Name = b.Table_Name And b.Iot_Type Is Null And
                        a.Constraint_Name Not In
                        (Select Upper(Column_Value) As Constraint_Name From Table(f_Str2list(v_Constraintswithtag)))
                  Order By Constraint_Name) Loop
          v_Sql := 'Alter Table ' || r.Table_Name || ' Disable Constraint ' || r.Constraint_Name ||
                   ' Cascade Drop Index';
          Execute Immediate v_Sql;
        End Loop;
      End If;
    Else
      --启用时
      --1.先启用主键和唯一键，再启用引用转出表主键的他表外键 
      If Speedmode_In = 1 Then
        --先重建索引，再启用约束，以便重建索引时利用并行执行缩短时间，并且启用约束时也可以采用novalidate方式 
        For R In (Select d.Table_Name, d.Constraint_Name,
                         f_List2str(Cast(Collect(d.Column_Name Order By d.Position) As t_Strlist)) Colstr
                  From User_Cons_Columns D,
                       (Select a.Table_Name, a.Constraint_Name
                         From User_Constraints A, zlBakTables T
                         Where a.Table_Name = t.表名 And t.直接转出 = 1 And t.系统 = System_In And a.Status = 'DISABLED' And
                               a.Constraint_Type In ('P', 'U')) A
                  Where a.Constraint_Name = d.Constraint_Name And a.Table_Name = d.Table_Name
                  Group By d.Table_Name, d.Constraint_Name
                  Order By Constraint_Name) Loop
          Update Zldatamovelog
          Set 当前进度 = '正在恢复约束:' || r.Constraint_Name
          Where 系统 = System_In And 批次 = (Select Max(批次) From Zldatamovelog Where 系统 = System_In);
        
          Select Tablespace_Name Into v_Tbs From User_Indexes Where Table_Name = r.Table_Name And Rownum < 2;
        
          --禁用主键或唯一键时，索引是被删除了的，所以这里要用Create 
          v_Sql := 'Create Unique Index ' || r.Constraint_Name || ' On ' || r.Table_Name || '(' || r.Colstr ||
                   ') Tablespace ' || v_Tbs || ' Nologging';
          Begin
            Execute Immediate v_Sql;
          Exception
            When Others Then
              Null; --可能有些主键或唯一键不是本次转出期间被禁用的，之前就存在不唯一数据，创建唯一索引会出错 
          End;
        
          --会自动建立约束与索引的关联 
          v_Sql := 'Alter Table ' || r.Table_Name || ' Enable Novalidate Constraint ' || r.Constraint_Name;
          Execute Immediate v_Sql;
        End Loop;
      End If;
    
      --2.启用引用转出表主键的他表外键 
      For R In (Select c.Table_Name, c.Constraint_Name
                From User_Constraints A, User_Constraints C, zlBakTables B
                Where a.Table_Name = b.表名 And b.直接转出 = 1 And b.系统 = System_In And a.Constraint_Type In ('P', 'U') And
                      c.r_Constraint_Name = a.Constraint_Name And c.Constraint_Type = 'R' And c.Status = 'DISABLED'
                Order By a.Table_Name) Loop
        --为了加快速度，采用novalidate，不验证已有数据 
        --可能引用转出表主键的他表，在zlbaktables中定义了，但没有编写对应的数据转出脚本，未验证的数据可能有违反约束的情况。 
        v_Sql := 'Alter Table ' || r.Table_Name || ' Enable Novalidate Constraint ' || r.Constraint_Name;
        Execute Immediate v_Sql;
      End Loop;
    
      --3.在线模式转出时，删除之前创建的用来替代级联删除外键的触发器
      If Speedmode_In = 0 Then
        For R In (Select a.Trigger_Name
                  From User_Triggers A, zlBakTables B
                  Where a.Table_Name = b.表名 And b.直接转出 = 1 And b.系统 = System_In And
                        Trigger_Name = Table_Name || '_CASCADE_DEL' And Triggering_Event = 'DELETE') Loop
          v_Sql := 'Drop Trigger ' || r.Trigger_Name;
          Execute Immediate v_Sql;
        End Loop;
      End If;
    End If;
  End Setconstraintstatus;

  --功能：高速模式时禁用LOB以外的所有索引，在线模式时仅禁用转出表引用非转出表的外键索引(例如：病人医嘱计价_IX_收费细目ID) 
  --说明：禁用索引是为了提高删除数据的性能 
  Procedure Setindexstatus As
  Begin
    If Speedmode_In = 1 Then
      --保留转出标记中的SQL查询所需的索引 
      For R In (Select /*+ rule*/
                 a.Index_Name
                From User_Indexes A, zlBakTables T
                Where a.Table_Name = t.表名 And t.直接转出 = 1 And t.系统 = System_In And t.直接转出 = 1 And
                      a.Index_Name <> a.Table_Name || '_IX_待转出' And
                      a.Index_Name Not In
                      (Select Upper(Column_Value) As Index_Name From Table(f_Str2list(v_Indexeswithtag))) And
                      a.Status = Decode(Enable_In, 0, 'VALID', 'UNUSABLE') And a.Index_Type = 'NORMAL' And Not Exists
                 (Select 1
                       From User_Constraints C
                       Where c.Index_Name = a.Index_Name And c.Constraint_Type In ('P', 'U'))
                Order By Index_Name) Loop
      
        If Enable_In = 0 Then
          v_Sql := 'Alter Index ' || r.Index_Name || ' Unusable';
          Execute Immediate v_Sql;
        Else
          Update Zldatamovelog
          Set 当前进度 = '正在重建索引:' || r.Index_Name
          Where 系统 = System_In And 批次 = (Select Max(批次) From Zldatamovelog Where 系统 = System_In);
        
          v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Nologging';
          Begin
            Execute Immediate v_Sql;
            --在线重建比较慢，不在线重建则需要锁表，如果有其他并发事务，则会出错：ORA-00054: 资源正忙, 但指定以 NOWAIT 方式获取资源 
          
          Exception
            When Others Then
              If SQLErrM Like 'ORA-00054%' Then
                v_Sql := Replace(v_Sql, 'Rebuild', 'Rebuild Online');
                Execute Immediate v_Sql;
              End If;
          End;
        End If;
      End Loop;
    Else
      For R In (Select a.Index_Name
                From (Select d.Table_Name, d.Index_Name,
                              f_List2str(Cast(Collect(d.Column_Name Order By d.Column_Position) As t_Strlist)) Colstr
                       From User_Ind_Columns D, zlBakTables T, User_Indexes C
                       Where c.Table_Name = t.表名 And t.直接转出 = 1 And t.系统 = System_In And c.Uniqueness = 'NONUNIQUE' And
                             c.Index_Type = 'NORMAL' And c.Status = Decode(Enable_In, 0, 'VALID', 'UNUSABLE') And
                             c.Index_Name = d.Index_Name And c.Table_Name = d.Table_Name
                       Group By d.Table_Name, d.Index_Name) A,
                     (Select e.Table_Name,
                              f_List2str(Cast(Collect(e.Column_Name Order By e.Position) As t_Strlist)) Colstr
                       From User_Cons_Columns E, User_Constraints F, zlBakTables T, User_Constraints C
                       Where e.Table_Name = t.表名 And t.直接转出 = 1 And t.系统 = System_In And
                             e.Constraint_Name = f.Constraint_Name And f.Constraint_Type = 'R' And
                             c.Constraint_Name = f.r_Constraint_Name And c.Table_Name Not In ('病案主页', '病人信息') And
                             Not Exists
                        (Select 1 From zlBakTables G Where g.表名 = c.Table_Name And g.系统 = System_In)
                       Group By e.Table_Name, e.Constraint_Name) B
                Where a.Table_Name = b.Table_Name And a.Colstr = b.Colstr
                Order By Index_Name) Loop
      
        If Enable_In = 0 Then
          --特殊处理：以下两个索引不禁用，是由于药品目录修改规格，财务缴款需要使用 
          If r.Index_Name Not In ('病人医嘱记录_IX_收费细目ID', '药品收发记录_IX_药品ID', '药品收发记录_IX_价格ID') Then
            v_Sql := 'Alter Index ' || r.Index_Name || ' Unusable';
            Execute Immediate v_Sql;
          End If;
        Else
          Update Zldatamovelog
          Set 当前进度 = '正在重建索引:' || r.Index_Name
          Where 系统 = System_In And 批次 = (Select Max(批次) From Zldatamovelog Where 系统 = System_In);
        
          v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Online Nologging';
          Execute Immediate v_Sql;
          --在线重建比较慢，不在线重建则需要锁表，如果有其他并发事务，则会出错：ORA-00054: 资源正忙, 但指定以 NOWAIT 方式获取资源 
        End If;
      End Loop;
    End If;
  End Setindexstatus;

  --功能：转出数据期间，停用转出表上的所有触发器，转出后再恢复 
  Procedure Settriggerstatus As
  Begin
    For R In (Select Distinct a.Table_Name, t.停用触发器
              From User_Triggers A, zlBakTables T
              Where a.Status = Decode(Enable_In, 0, 'ENABLED', 'DISABLED') And a.Table_Name = t.表名 And t.直接转出 = 1 And
                    t.系统 = System_In) Loop
      If Enable_In = 0 Then
        v_Sql := 'Alter Table ' || r.Table_Name || ' DISABLE ALL TRIGGERS';
        Update zlBakTables Set 停用触发器 = 1 Where 系统 = System_In And 表名 = r.Table_Name;
      Elsif Nvl(r.停用触发器, 0) = 1 Then
        v_Sql := 'Alter Table ' || r.Table_Name || ' ENABLE ALL TRIGGERS';
        Update zlBakTables Set 停用触发器 = Null Where 系统 = System_In And 表名 = r.Table_Name;
      End If;
      Execute Immediate v_Sql;
    End Loop;
    Commit;
  End Settriggerstatus;

  --功能：转出数据期间，停用当前所有者的所有自动作业，转出后再启用 
  Procedure Setjobstatus As
    v_Jobs Varchar2(4000);
  Begin
    --停用 
    If Enable_In = 0 Then
      For R In (Select Job From User_Jobs Where Broken = 'N') Loop
        Dbms_Job.Broken(r.Job, True);
        v_Jobs := v_Jobs || ',' || r.Job;
      End Loop;
    
      If v_Jobs Is Not Null Then
        v_Jobs := Substr(v_Jobs, 2);
        Update zlDataMove Set 停用作业号 = v_Jobs Where 系统 = System_In And 组号 = 1;
      End If;
    Else
      --启用 
      Select 停用作业号 Into v_Jobs From zlDataMove Where 系统 = System_In And 组号 = 1;
      If v_Jobs Is Not Null Then
        For R In (Select Job
                  From User_Jobs
                  Where Broken = 'Y' And Job In (Select Column_Value From Table(f_Num2list(v_Jobs)))) Loop
          Dbms_Job.Broken(r.Job, False);
        End Loop;
        Update zlDataMove Set 停用作业号 = Null Where 系统 = System_In And 组号 = 1;
      End If;
    End If;
    --作业设置后必须提交事务才生效 
    Commit;
  End Setjobstatus;
Begin
  If Parallel_In < 2 Then
    Execute Immediate 'Alter Session DISABLE PARALLEL DDL';
  Else
    If Func_In In (6, 7, 8) Or Func_In In (3, 4) And Enable_In = 1 Then
      --为重建索引设置并行执行（由于通常受限于IO设备的性能，设置太高的并行度反而会降低性能，如有高性能存储设备，可加大并行度） 
      --执行重建索引后会自动为索引加上并行度属性，如果不取消，会影响相关SQL的执行计划(全表扫描+并行查询，巨慢),在后面取消索引的并行度 
      --恢复在线库的约束和索引时，不管是不是在线模式，都加上并行，否则太慢
      Execute Immediate 'Alter Session FORCE PARALLEL DDL PARALLEL ' || Parallel_In;
      n_Parallel := 1;
    End If;
  End If;

  If Func_In = 1 Then
    --1.设置触发器 
    Settriggerstatus;
  Elsif Func_In = 2 Then
    --2.设置自动作业 
    Setjobstatus;
  Elsif Func_In = 3 Then
    --3.设置约束状态 
    Setconstraintstatus;
  Elsif Func_In = 4 Then
    --4.设置索引状态 
    Setindexstatus;
  Elsif Func_In = 5 Then
    --5.重建"待转出"索引 
    For R In (Select b.Index_Name
              From zlBakTables A, User_Indexes B
              Where a.表名 = b.Table_Name And a.直接转出 = 1 And a.系统 = System_In And b.Index_Name = b.Table_Name || '_IX_待转出'
              Union All
              Select '病案主页_IX_待转出'
              From Dual
              Where System_In = 100) Loop
      Update Zldatamovelog
      Set 当前进度 = '正在重建索引:' || r.Index_Name
      Where 系统 = System_In And 批次 = (Select Max(批次) From Zldatamovelog Where 系统 = System_In);
    
      --耗时太短，无须并行DDL 
      --在线转出时如果重建索引会锁表，如果有其他并发事务，则会出错：ORA-00054: 资源正忙, 但指定以 NOWAIT 方式获取资源 
      --在线重建索引太慢，所以，即使在线转出模式也不用在线重建
      v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Nologging';
      Begin
        Execute Immediate v_Sql;
      Exception
        When Others Then
          If SQLErrM Like 'ORA-00054%' Then
            v_Sql := Replace(v_Sql, 'Rebuild', 'Rebuild Online');
            Execute Immediate v_Sql;
          End If;
      End;
    End Loop;
  
  Elsif Func_In = 6 Then
    --6.重建标记转出查询所用到的索引（测试表明重建后最多可缩短一半的查询时间） 
    --根据业务的启用阶段来决定重建哪些索引，以避免一些不必要的重建耗时 
    For R In (Select b.Index_Name, a.组号
              From User_Indexes B, zlBakTables A
              Where a.系统 = System_In And a.表名 = b.Table_Name And
                    b.Index_Name In (Select Upper(Column_Value)
                                     From Table(f_Str2list(v_Indexeswithtag))
                                     Union
                                     Select Upper(Column_Value)
                                     From Table(f_Str2list(v_Constraintswithtag)))
              Order By Index_Name) Loop
      n_Do := 0;
      If Rebscope_In = 0 Then
        If r.组号 < 5 Then
          n_Do := 1; --仅经济核算类 
        End If;
      Elsif Rebscope_In = 1 Then
        If r.组号 < 5 Or r.组号 = 8 Then
          n_Do := 1; --仅经济核算类、医嘱类 
        End If;
      Else
        n_Do := 1;
      End If;
    
      If n_Do = 1 Then
        Update Zldatamovelog
        Set 当前进度 = '正在重建索引:' || r.Index_Name
        Where 系统 = System_In And 批次 = (Select Max(批次) From Zldatamovelog Where 系统 = System_In);
      
        --v_Sql := 'Alter Index ' || r.Index_Name || ' shrink Space'; 
        --使用shrink方式不能并行执行,试验表明速度比rebuild PARALLEL 8 慢6倍 
        If Speedmode_In = 1 Then
          v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Nologging';
        Else
          v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Online Nologging';
        End If;
        Begin
          Execute Immediate v_Sql;
          --在线重建比较慢，不在线重建则需要锁表，如果有其他并发事务，则会出错：ORA-00054: 资源正忙, 但指定以 NOWAIT 方式获取资源 
        
        Exception
          When Others Then
            If SQLErrM Like 'ORA-00054%' Then
              v_Sql := Replace(v_Sql, 'Rebuild', 'Rebuild Online');
              Execute Immediate v_Sql;
            End If;
        End;
      End If;
    End Loop;
  
    --重组表的数据
  Elsif Func_In = 7 Then
    --rebScope_in=0,只重组组号小于5的经济核算类表（费用、药品、票据），否则全部重组 
    For R In (Select a.表名 As Table_Name
              From zlBakTables A
              Where a.直接转出 = 1 And (组号 < Decode(Rebscope_In, 0, 5, 100))
              Order By 组号, 序号) Loop
    
      Update Zldatamovelog
      Set 当前进度 = '正在重组表:' || r.Table_Name
      Where 系统 = System_In And 批次 = (Select Max(批次) From Zldatamovelog Where 系统 = System_In);
    
      --如果有空闲的空间，最好移到其他表空间，只有这样才能绝对移动文件尾部的数据块，以便进行表空间文件的收缩 
      --在前面设置了会话级的强制并行 
      v_Sql := 'Alter Table ' || r.Table_Name || ' Move Nologging';
      Execute Immediate v_Sql;
    
      --单独移动Lob对象 
      For L In (Select Column_Name, Tablespace_Name From User_Lobs Where Table_Name = r.Table_Name) Loop
        v_Sql := 'Alter Table ' || r.Table_Name || ' Move Lob(' || l.Column_Name || ') Store as (Tablespace ' ||
                 l.Tablespace_Name || ') Nologging';
        Execute Immediate v_Sql;
      End Loop;
    
      v_Sql := 'Alter Table ' || r.Table_Name || ' Noparallel';
      Execute Immediate v_Sql;
    
      --move后，表相关的索引会全部失效，需要全部重建 
      For S In (Select Index_Name
                From User_Indexes
                Where Table_Name = r.Table_Name And Status = 'UNUSABLE'
                Order By Index_Name) Loop
        Update Zldatamovelog
        Set 当前进度 = '正在恢复失效索引:' || s.Index_Name
        Where 系统 = System_In And 批次 = (Select Max(批次) From Zldatamovelog Where 系统 = System_In);
      
        --在前面设置了会话级的强制并行 
        v_Sql := 'Alter Index ' || s.Index_Name || ' Rebuild Nologging';
        Execute Immediate v_Sql;
      End Loop;
    End Loop;
    --重建转出表上标记转出以外的其他索引（用于转出完成后收回空闲空间）
    --失效的索引不重建，因为转出完后有单独的重建功能
  Elsif Func_In = 8 Then
    For R In (Select b.Index_Name, a.组号
              From User_Indexes B, zlBakTables A
              Where a.系统 = System_In And a.表名 = b.Table_Name And b.Status = 'VALID' And b.Index_Type = 'NORMAL' And
                    b.Index_Name Not Like 'BIN$%' And
                    b.Index_Name Not In (Select Upper(Column_Value)
                                         From Table(f_Str2list(v_Indexeswithtag))
                                         Union
                                         Select Upper(Column_Value)
                                         From Table(f_Str2list(v_Constraintswithtag)))
              Order By Index_Name) Loop
      Update Zldatamovelog
      Set 当前进度 = '正在重建索引:' || r.Index_Name
      Where 系统 = System_In And 批次 = (Select Max(批次) From Zldatamovelog Where 系统 = System_In);
    
      If Speedmode_In = 1 Then
        v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Nologging';
      Else
        v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Online Nologging';
      End If;
      Begin
        Execute Immediate v_Sql;
        --在线重建比较慢，不在线重建则需要锁表，如果有其他并发事务，则会出错：ORA-00054: 资源正忙, 但指定以 NOWAIT 方式获取资源    
      Exception
        When Others Then
          If SQLErrM Like 'ORA-00054%' Then
            v_Sql := Replace(v_Sql, 'Rebuild', 'Rebuild Online');
            Execute Immediate v_Sql;
          End If;
      End;
    End Loop;
  End If;

  --执行重建索引后会自动为索引加上并行度属性，如果不取消，会影响相关SQL的执行计划(全表扫描+并行查询，巨慢) 
  --------------------------------------------------------------------------------------------------- 
  If n_Parallel = 1 Then
    Execute Immediate 'ALTER Session DISABLE PARALLEL DDL';
  
    For R In (Select Index_Name From User_Indexes Where Degree Not In ('1', '0')) Loop
      v_Sql := 'Alter Index ' || r.Index_Name || ' Noparallel';
      Execute Immediate v_Sql;
    End Loop;
  End If;

  Update Zldatamovelog
  Set 当前进度 = '重建完成'
  Where 系统 = System_In And 批次 = (Select Max(批次) From Zldatamovelog Where 系统 = System_In);
  Commit;
  --本过程不进行错误处理，错误由调用过程处理 
End Zl1_Datamove_Reb;
/

--93911:李南春,2016-03-04,费用清单打印转出问题
--92729:胡俊勇,2016-01-26,专业版RIS接口处理
--91225:梁经伙,2015-12-16,传染病管理系统新增加 疾病报告反馈表
Create Or Replace Procedure Zl1_Datamove_Tag
(
  d_End    In Date,
  n_批次   In Number,
  n_System In Number
) As
  --功能：标记待转出的数据 
  --说明：为避免Undo表空间膨胀过大，分段提交 
Begin
  --1.经济核算（费用,药品,收款和票据等）  
  --新加子查询注意性能优化，把能够将数据过滤到最小的条件放到最后，Exists类条件放前面
  Update /*+ rule*/ 病人预交记录 L
  Set 待转出 = n_批次
  Where 结帐id In
        (Select Distinct a.结帐id --1.门诊收费和挂号的收费结算记录(排除之后退号和退费的,一张单据中只要其中一行退了) 
         From 门诊费用记录 A
         Where (a.记录状态 In (1, 2) Or a.记录状态 = 3 And Not Exists
                (Select 1
                 From 门诊费用记录 B
                 Where a.No = b.No And a.记录性质 = b.记录性质 And b.记录状态 = 2 And b.登记时间 >= d_End))
     And a.待转出 Is Null And a.记录性质 In (1, 4) And a.登记时间 < d_End
         Union All
         Select Distinct a.结算id --2.医保补结算 
         From 费用补充记录 A
         Where (a.记录状态 In (1, 2) Or a.记录状态 = 3 And Not Exists
                (Select 1
                 From 费用补充记录 B
                 Where a.No = b.No And a.记录性质 = b.记录性质 And b.记录状态 In (1, 2) And b.登记时间 >= d_End))
     And a.待转出 Is Null And a.记录性质 = 1 And a.登记时间 < d_End
         Union All
         Select Distinct a.结帐id --3.就诊卡的收费结算记录(排除之后退卡费的,一张单据中只要其中一行退了) 
         From 住院费用记录 A
         Where (a.记录状态 In (1, 2) Or a.记录状态 = 3 And Not Exists
                (Select 1
                 From 住院费用记录 B
                 Where a.No = b.No And a.记录性质 = b.记录性质 And b.记录状态 = 2 And b.登记时间 >= d_End))
    And a.待转出 Is Null And a.记帐费用 = 0 And a.记录性质 = 5 And a.登记时间 < d_End
         Union All --4.门诊(记帐单)和住院的结帐结算记录 
         Select 结帐id
         From (With Settle As (Select Distinct a.Id As 结帐id, a.病人id --3.门诊(记帐单)和住院的结帐结算记录(排除之后结帐作废的) 
                               From 病人结帐记录 A
                               Where (a.记录状态 In (1, 2) Or a.记录状态 = 3 And Not Exists
                                      (Select 1 From 病人结帐记录 B Where a.No = b.No And b.记录状态 = 2 And b.收费时间 >= d_End))
              And a.待转出 Is Null And a.收费时间 < d_End)
                Select 结帐id
                From Settle
                Minus
                --以下结帐ID要整体排除,避免部分费用明细被转出后影响后续的计算是否冲完 
                --1.一张预交款被多笔结帐冲完（结帐ID不同）
                --2.费用单据的结帐ID相关的可能还有其他NO的其他结帐ID(结帐作废后分多次结帐结清，可能部分在转出时间之后)
                --考虑到这情况的复杂性，为简化逻辑，提升查询性能，按病人ID来排除 
                Select Distinct d.Id
                From 病人结帐记录 D,
                     (Select Distinct c.病人id --多次住院可以一起结，以及门诊记帐和住院记帐可以一起结且冲同一笔预交，所以这里不加主页ID 
                       From 住院费用记录 C,
                            (Select Distinct d.No, d.序号, Mod(d.记录性质, 10) As 记录性质
                              From 住院费用记录 D,
                                   (Select s.结帐id From Settle S, 病人结帐记录 E --没有结清且该病人之后没有再结过就成了呆帐，这种就不排除 
                                     Where s.病人id = e.病人id And (e.收费时间 > d_End Or Exists (Select 1 From 在院病人 F Where s.病人id = f.病人id))) S 
                              Where d.结帐id = s.结帐id) D
                       Where c.No = d.No And Mod(c.记录性质, 10) = d.记录性质 And c.序号 = d.序号 --结帐后作废后，再对包含记帐单销帐的结帐ID为空的记录,一起汇总计算是否结清,这种结帐ID为空的数据转出在后面单独转出 
                       Group By c.No, Mod(c.记录性质, 10), c.病人id --一张单据中的一行可部分结帐，以单据为对象来判断，避免一张单据的其中一部分被转出 
                       Having Nvl(Sum(c.实收金额), 0) <> Nvl(Sum(c.结帐金额), 0) Or Exists (Select 1 --排除转出时间之后再次结帐的(作废后再次结帐)，避免原始单据转走后，后续结帐时无法正确判断 
                                                                                   From 住院费用记录 E, 病人结帐记录 S
                                                                                   Where e.No = c.No And Mod(e.记录性质, 10) = Mod(c.记录性质, 10) And
                                                                                         e.记录性质 In (12, 13, 15) And e.结帐id = s.Id  And s.待转出 Is Null And s.收费时间 >= d_End)
                       Union All
                       Select Distinct c.病人id
                       From 门诊费用记录 C,
                            (Select Distinct d.No, d.序号, Mod(d.记录性质, 10) As 记录性质
                              From 门诊费用记录 D, Settle S
                              Where d.结帐id = s.结帐id) D --因为是门诊病人，所以，只要没有结清,该病人的都不转出 
                       Where c.No = d.No And Mod(c.记录性质, 10) = d.记录性质 And c.序号 = d.序号
                       Group By c.No, Mod(c.记录性质, 10), c.病人id
                       Having Nvl(Sum(c.实收金额), 0) <> Nvl(Sum(c.结帐金额), 0) Or Exists (Select 1
                                                                                   From 门诊费用记录 E, 病人结帐记录 S
                                                                                   Where e.No = c.No And Mod(e.记录性质, 10) = Mod(c.记录性质, 10) And
                                                                                         e.记录性质 In (12, 13, 15) And e.结帐id = s.Id And s.待转出 Is Null And s.收费时间 >= d_End)) N
                Where d.病人id = n.病人id)
         );

  --排除预交款未冲完的
  --为了降低逻辑的复杂性，不排除在转出时间之后发药或未发药的费用记录对应的结帐ID，将这种情况的结算数据和费用数据强制转走 
  --因为前面的SQL查出的结帐ID可能不全是冲预交的(门诊收费和住院结帐补费等)，所以，需要单独一个SQL来排除 
  --由于可能存在数据异常(住院费用结帐冲预交类别为1的门诊预交)，所以没有加预交类别条件限定 
  Update /*+ rule*/ 病人预交记录
  Set 待转出 = Null
  Where 待转出 = n_批次 And
        结帐id In (Select Distinct d.结帐id
                 From 病人预交记录 D,
                      --连接D表是为了查冲同一预交单据的其他结帐ID（退预交款，冲预交作废的，再次冲同一预交单据） 
                      --该预交或冲预交单据涉及的所有结帐ID的都不转出，避免部分冲预交的结帐ID被排除后，原始预交单被转走，或者其他结帐ID将费用单据的一部分(原始结帐、结帐作废、再次结一部分、再次结全部)转走 
                      (Select Distinct l.No
                        From 病人预交记录 L, 病人预交记录 P --可能本次结帐冲的只是剩余款，所以需要连接L表，查原始交预交的单据，以及记录性质为11的可能还有转出时间之后其他冲剩余款的结帐ID 
                        Where l.记录性质 = p.记录性质 And l.No = p.No And p.记录性质 In (1, 11) And p.待转出 = n_批次
                        Group By l.No, l.病人id
                        Having Nvl(Sum(l.金额), 0) <> Nvl(Sum(l.冲预交), 0) And (Exists (Select 1
                                                                                  From 病人预交记录 E --没有冲完且之后没有再冲过或结算过就成了呆帐（以及存在用负的结帐补款来表示冲预交当成冲完的清况），这种就不排除
                                                                                  Where l.病人id = e.病人id And e.待转出 Is Null And e.收款时间 > d_End)
                                                                                  Or Exists (Select 1 From 在院病人 E Where l.病人id =e.病人id)
                                                                                  Or Exists (Select 1 From 病人未结费用 E Where l.病人id =e.病人id))  
                        Or Nvl(Sum(l.金额), 0) = Nvl(Sum(l.冲预交), 0) And Exists (Select 1
                                                                                  From 病人预交记录 E --排除转出时间之后的其他结帐ID冲的,10.34.20后，冲预交全部单独增加了一条记录，收费时间就是冲预交时间(以前是在原始交预交款的记录上填冲预交字段，不能直接查到冲预交款的时间)
                                                                                  Where e.No = l.No And e.记录性质 = 11 And e.待转出 Is Null And e.收款时间 >= d_End)) N
                 Where d.No = n.No And d.记录性质 In (1, 11));

  --预交款没有使用就直接退了的记录(结帐ID为空) 
  Update /*+ rule*/ 病人预交记录
  Set 待转出 = n_批次
  Where 记录性质 = 1 And
        NO In (Select a.No
               From 病人预交记录 A
               Where a.结帐id Is Null And a.记录性质 = 1 And a.记录状态 In (2, 3) And a.待转出 Is Null And a.收款时间 < d_End
               Group By a.No
               Having Sum(a.金额) = 0);

  --冲预交款作废的记录（记录性质为2），没有结帐ID 
  Update /*+ rule*/ 病人预交记录
  Set 待转出 = n_批次
  Where 结帐id Is Null And 记录性质 = 2 And NO In (Select a.No From 病人预交记录 A Where a.待转出 = n_批次 And a.记录性质 = 3);

  Update Zldatamovelog
  Set 当前进度 = '(1/10)结算数据标记完成，正在标记费用数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  Update /*+ rule*/ 病人结帐记录
  Set 待转出 = n_批次
  Where ID In (Select 结帐id From 病人预交记录 Where 待转出 = n_批次);

  --结帐无结算的记录(为了提升性能，不判断费用，只要结了帐且无预交记录就当成是零费用结帐) 
  Update /*+ rule*/ 病人结帐记录 L
  Set 待转出 = n_批次
  Where 收费时间 < d_End And 待转出 Is Null And Not Exists (Select 1 From 病人预交记录 P Where l.Id = p.结帐id);

  Update /*+ rule*/ 病人卡结算对照
  Set 待转出 = n_批次
  Where 预交id In (Select a.Id From 病人预交记录 A Where 待转出 = n_批次);

  Update /*+ rule*/ 病人卡结算记录
  Set 待转出 = n_批次
  Where ID In (Select 卡结算id From 病人卡结算对照 Where 待转出 = n_批次);

  Update /*+ rule*/ 三方结算交易
  Set 待转出 = n_批次
  Where 交易id In (Select a.Id From 病人预交记录 A Where 待转出 = n_批次);

  Update /*+ rule*/ 三方退款信息
  Set 待转出 = n_批次
  Where (记录id,结帐ID) In (Select a.Id,A.结帐ID From 病人预交记录 A Where 待转出 = n_批次);

  --1.挂号打折后实收金额为0的(没有对应的预交记录),即使之后有退号费用也不管，因为金额为零不影响计算),而卡费即使为零也有预交记录 
  --结帐ID为空的是异常数据（德阳医院仅有3笔此类数据）
  --根据挂号记录再找门诊费用，比直接按时间查门诊费用要快 
  Update /*+ rule*/ 门诊费用记录
  Set 待转出 = n_批次
  Where NO In (Select NO From 病人挂号记录 Where 待转出 Is Null And 登记时间 < d_End) And 记录性质 = 4 And (实收金额 = 0 Or 结帐id Is Null);

  --2.直接收费的和结帐无结算（预交）记录的，Union不加all去掉重复以减少in的数量 
  Update /*+ rule*/ 门诊费用记录
  Set 待转出 = n_批次
  Where 结帐id In
        (Select 结帐id From 病人预交记录 Where 待转出 = n_批次 Union Select ID From 病人结帐记录 Where 待转出 = n_批次);

  --3.没有结帐id的数据(按登记时间)
  --1)未结帐的门诊记帐费用(赖账)，该病人没有预交记录或冲预交记录，并且该时间之后无门诊费用发生
  --2)未结帐的划价记录
  --3)未收费（也没有冲预交）的零费用
  --加条件"待转出 Is Null"是为了处理连续多次标记转出的情况 
  Update /*+ rule*/ 门诊费用记录 A
  Set 待转出 = n_批次
  Where (Not Exists (Select 1 From 病人预交记录 B Where a.病人id = b.病人id And b.待转出 Is Null And 记录性质 In (1, 11)) And Not Exists
         (Select 1 From 门诊费用记录 B Where a.病人id = b.病人id And b.待转出 Is Null And 登记时间 > d_End) And 记录性质 = 2 Or 记录状态 = 0 Or
         记录性质 = 1 And 实收金额 = 0 And 结帐金额 = 0) And 结帐id Is Null And 待转出 Is Null And 登记时间 < d_End;

  --4.没有结帐id的数据(按发生时间)
  --冲销产生的记帐记录（记录状态为2），登记时间可能在当前指定转出时间之后，而原始记帐记录（记录状态为3），登记时间在指定转出时间之前。前后两者的发生时间是相同的。
  --1)未结帐的零记帐费用或打折后实收金额为零的（结帐模块参数没有勾选对零费用结帐）
  --2)结帐作废后，记帐单销帐的记录（结帐ID为空且记录状态为2的），记录状态为3的且有结帐ID的在最前面已转出. 
  Update /*+ rule*/ 门诊费用记录 A
  Set 待转出 = n_批次
  Where (Exists (Select 1
                 From 门诊费用记录 B
                 Where a.No = b.No And a.记录性质 = b.记录性质 And a.序号 = b.序号 And b.记录状态 = 3 And b.结帐id Is Not Null And
                       b.待转出 + 0 = n_批次) And 记录状态 = 2 Or Exists
         (Select 1
          From 门诊费用记录 B
          Where a.No = b.No And a.记录性质 = b.记录性质 And a.序号 = b.序号 And b.结帐id Is Null
          Group By b.No, b.记录性质, b.序号
          Having Nvl(Sum(b.实收金额), 0) = 0)) And 记录性质 = 2 And 结帐id Is Null And 待转出 Is Null And 发生时间 < d_End;

  --5.有结帐id的零费用(按发生时间)
  --按费别打折后结帐金额为零的收费记录,或者一张单据相同结帐ID的结帐金额之和为0(冲销后为零)
  --即使在转出时间之后发药的，也强制转出（为了减少逻辑复杂性，提高查询性能）
  Update /*+ rule*/ 门诊费用记录 A
  Set 待转出 = n_批次
  Where (结帐金额 = 0 Or Exists
         (Select 1 From 门诊费用记录 C Where a.结帐id = c.结帐id Group By c.结帐id, c.No Having Sum(c.结帐金额) = 0)) And Not Exists
   (Select 1 From 病人预交记录 B Where a.结帐id = b.结帐id And b.待转出 Is Null) And 记录性质 = 1 And 结帐id Is Not Null And
        待转出 Is Null And 发生时间 < d_End;

  Update /*+ rule*/ 医保结算明细
  Set 待转出 = n_批次
  Where 结帐id In (Select 结帐id From 病人预交记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 费用补充记录
  Set 待转出 = n_批次
  Where 结算id In (Select 结帐id From 病人预交记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 凭条打印记录
  Set 待转出 = n_批次
  Where (NO, 记录性质) In (Select NO, 记录性质 From 门诊费用记录 Where 待转出 = n_批次);

   --1.从预交记录读是为了取就诊卡直接收费的（无结帐ID）,再加结帐记录是为了取结帐无结算（预交）记录的 
  Update /*+ rule*/ 住院费用记录
  Set 待转出 = n_批次
  Where 结帐id In
        (Select 结帐id From 病人预交记录 Where 待转出 = n_批次 Union Select ID From 病人结帐记录 Where 待转出 = n_批次);

  --2.没有结帐id的数据(按发生时间)
  --冲销产生的记帐记录（记录状态为2），登记时间可能在当前指定转出时间之后，而原始记帐记录（记录状态为3），登记时间在指定转出时间之前。前后两者的发生时间是相同的。
  --1)转出结帐作废后，记帐单销帐的记录（记帐状态为2且没有结帐ID且(记录状态为3的有结帐ID的)在最前面已转出） 
  --2)未结帐的零费用(已冲销的记帐单或打折后实收金额为零) 
  --3)没有结帐ID的划价记录处理为转出 
  
  Update /*+ rule*/ 住院费用记录 A
  Set 待转出 = n_批次
  Where ((Exists (Select 1
                  From 住院费用记录 B
                  Where a.No = b.No And a.记录性质 = b.记录性质 And a.序号 = b.序号 And b.记录状态 = 3 And b.结帐id Is Not Null And
                        b.待转出 + 0 = n_批次) And 记录状态 = 2 Or Exists
         (Select 1
           From 住院费用记录 B
           Where a.No = b.No And a.记录性质 = b.记录性质 And a.序号 = b.序号 And b.结帐id Is Null
           Group By b.No, b.记录性质, b.序号
           Having Nvl(Sum(b.实收金额), 0) = 0)) And 记录性质 = 2 Or 记录状态 = 0) And 结帐id Is Null And 待转出 Is Null And 发生时间 < d_End;

  --3.离院未结帐的（赖帐病人），因为是很久以前的这些数据，如果预交已冲完，则处理为要转出 
  Update /*+ rule*/ 住院费用记录 A
  Set 待转出 = n_批次
  Where 待转出 Is Null And 结帐id Is Null And
        (病人id, 主页id) In (Select 病人id, 主页id
                         From 病案主页 C
                         Where 出院日期 < d_End And 待转出 Is Null And 数据转出 Is Null And Not Exists
                          (Select 1
                                From 病人预交记录 B
                                Where b.病人id = c.病人id And b.待转出 Is Null And b.预交类别 = 2 And b.记录性质 In (1, 11)
                                Having Nvl(Sum(b.金额), 0) - Nvl(Sum(b.冲预交), 0) <> 0));

  Update /*+ rule*/ 费用清单打印
  Set 待转出 = n_批次
  Where (NO, Mod(记录性质,10),Decode(记录状态,3,1,记录状态),序号) In 
        (Select NO, Mod(记录性质,10) as 记录性质,Decode(记录状态,3,1,记录状态) as 记录状态,序号 From 门诊费用记录 Where 待转出 = n_批次
        Union
        Select NO, Mod(记录性质,10) as 记录性质,Decode(记录状态,3,1,记录状态) as 记录状态,序号 From 住院费用记录 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(2/10)费用数据标记完成，正在标记药品数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  Update /*+ Rule*/ 药品收发记录 A
  Set 待转出 = n_批次
  Where Rowid In (Select m.Rowid
                  From 药品收发记录 M, 门诊费用记录 E
                  Where m.费用id = e.Id And (e.记录性质 = 1 And m.单据 In (8, 24) Or e.记录性质 = 2 And m.单据 In (9, 25)) And
                        e.收费类别 In ('4', '5', '6', '7') And e.待转出 = n_批次
                  Union All
                  Select m.Rowid
                  From 药品收发记录 M, 住院费用记录 E
                  Where m.费用id = e.Id And m.单据 In (9, 10, 25, 26) And e.记录性质 = 2 And e.收费类别 In ('4', '5', '6', '7') And
                        e.待转出 = n_批次);

  Update /*+ rule*/ 收发记录补充信息
  Set 待转出 = n_批次
  Where 收发id In (Select ID From 药品收发记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 输液配药内容
  Set 待转出 = n_批次
  Where 收发id In (Select ID From 药品收发记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 输液配药记录
  Set 待转出 = n_批次
  Where ID In (Select 记录id From 输液配药内容 Where 待转出 = n_批次);

  Update /*+ rule*/ 输液配药附费
  Set 待转出 = n_批次
  Where 配药id In (Select ID From 输液配药记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 输液配药状态
  Set 待转出 = n_批次
  Where 配药id In (Select ID From 输液配药记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 药品留存计划
  Set 待转出 = n_批次
  Where 留存id In (Select ID From 药品收发记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 药品签名明细
  Set 待转出 = n_批次
  Where 收发id In (Select ID From 药品收发记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 药品签名记录
  Set 待转出 = n_批次
  Where ID In (Select 签名id From 药品签名明细 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(3/10)药品数据标记完成，正在标记缴款与票据数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  Update /*+ rule*/ 人员借款记录 Set 待转出 = n_批次 Where 待转出 Is Null And 借出时间 < d_End;

  Update /*+ rule*/ 人员收缴记录 Set 待转出 = n_批次 Where 待转出 Is Null And 登记时间 < d_End;

  Update /*+ rule*/ 人员收缴对照
  Set 待转出 = n_批次
  Where 收缴id In (Select ID From 人员收缴记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 人员收缴明细
  Set 待转出 = n_批次
  Where 收缴id In (Select ID From 人员收缴记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 人员收缴票据
  Set 待转出 = n_批次
  Where 收缴id In (Select ID From 人员收缴记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 人员暂存记录
  Set 待转出 = n_批次
  Where 收缴id In (Select ID From 人员收缴记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 人员暂存记录 Set 待转出 = n_批次 Where 待转出 Is Null And 记录性质 = 1 And 登记时间 < d_End;

  Update /*+ rule*/ 票据领用记录 A
  Set 待转出 = n_批次
  Where Not Exists
   (Select 1 From 票据使用明细 B Where b.领用id = a.Id And b.使用时间 >= d_End) And 待转出 Is Null And 剩余数量 = 0 And 登记时间 < d_End;

  Update /*+ rule*/ 票据使用明细
  Set 待转出 = n_批次
  Where 领用id In (Select ID From 票据领用记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 票据打印内容
  Set 待转出 = n_批次
  Where ID In (Select 打印id From 票据使用明细 Where 待转出 = n_批次);

  Update /*+ rule*/ 票据打印明细
  Set 待转出 = n_批次
  Where 使用id In (Select ID From 票据使用明细 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(4/10)缴款与票据数据标记完成，正在标记就诊及诊治数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  --2.就诊及诊治数据 
  --不转出的条件：挂号费用未转出的，转出时间之后存在医嘱，医嘱对应的费用未转出的 
  --即使正在就诊(r.执行状态 <> 2 )的也强制转出 
  Update /*+ rule*/ 病人挂号记录 T
  Set 待转出 = n_批次
  Where Rowid In
        (Select Rowid
         From 病人挂号记录 R
         Where Not Exists (Select 1
                From 门诊费用记录 A
                Where r.No = a.No And a.登记时间 < d_End And a.记录性质 = 4 And a.待转出 Is Null) And Not Exists
          (Select 1
                From 病人医嘱记录 A
                Where a.挂号单 = r.No And a.待转出 Is Null And a.病人来源 <> 4 And Nvl(a.停嘱时间, a.开嘱时间) >= d_End) And Not Exists
          (Select 1
                From 门诊费用记录 E, 病人医嘱记录 A
                Where r.No = a.挂号单 And a.Id = e.医嘱序号 And a.病人来源 <> 4 And e.待转出 Is Null) And r.待转出 Is Null And
               r.登记时间 < d_End);

  --由于有一部分挂号数据未转出，所以，汇总表的数据可能与挂号数据不匹配 
  Update 病人挂号汇总 Set 待转出 = n_批次 Where 待转出 Is Null And 日期 < d_End;
  Update /*+ rule*/ 病人转诊记录 Set 待转出 = n_批次 Where NO In (Select NO From 病人挂号记录 Where 待转出 = n_批次);

  --通过"住院费用记录"来查询，而不是"病人结帐记录",因为离院未结的赖帐病人也转出了费用 
  --出院日期条件仍然需要，因为可能某次结帐转出了，但病人当时并未出院(一次住院多次结帐)。 
  --通过指定索引方式进行特殊优化（缺省采用"病案主页IX_出院日期"索引的效率太低） 
  Update /*+ rule*/ 病案主页 P
  Set 待转出 = n_批次
  Where Not Exists (Select 1 From 住院费用记录 A Where a.病人id = p.病人id And a.主页id = p.主页id And a.待转出 Is Null) And 待转出 Is Null And
        数据转出 Is Null And 出院日期 < d_End And
        (病人id, 主页id) In (Select Distinct 病人id, 主页id From 住院费用记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人过敏记录
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, ID
                         From 病人挂号记录
                         Where 待转出 = n_批次
                         Union All
                         Select 病人id, 主页id
                         From 病案主页
                         Where 待转出 = n_批次);

  Update /*+ rule*/ 病人诊断记录
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, ID
                         From 病人挂号记录
                         Where 待转出 = n_批次
                         Union All
                         Select 病人id, 主页id
                         From 病案主页
                         Where 待转出 = n_批次);

  Update /*+ rule*/ 病人手麻记录
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, ID
                         From 病人挂号记录
                         Where 待转出 = n_批次
                         Union All
                         Select 病人id, 主页id
                         From 病案主页
                         Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(5/10)就诊及诊治数据标记完成，正在标记护理数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  --3.护理数据 
  Update /*+ rule*/ 病人护理文件
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, 主页id From 病案主页 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人护理数据
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 病人护理文件 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人护理明细
  Set 待转出 = n_批次
  Where 记录id In (Select ID From 病人护理数据 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人护理打印
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 病人护理文件 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人护理活动项目
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 病人护理文件 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人护理要素内容
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 病人护理文件 Where 待转出 = n_批次);
  Update /*+ rule*/ 产程要素内容
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 病人护理文件 Where 待转出 = n_批次);

  --老版护理系统数据 
  Update /*+ rule*/ 病人护理记录
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, 主页id From 病案主页 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人护理内容
  Set 待转出 = n_批次
  Where 记录id In (Select ID From 病人护理记录 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(6/10)护理数据标记完成，正在标记病历数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  --4.病历数据 
  Update /*+ rule*/ 电子病历记录
  Set 待转出 = n_批次
  Where 病人来源 <> 4 And (病人id, 主页id) In (Select 病人id, ID
                                       From 病人挂号记录
                                       Where 待转出 = n_批次
                                       Union All
                                       Select 病人id, 主页id
                                       From 病案主页
                                       Where 待转出 = n_批次);

  --自登记类病人(无挂号单号) 
  --病历ID可能重复是因为检验报告之类的，如肝功、肾功共打一张报告，即在病人医嘱报告表中，多个医嘱id对应同一报告ID 
  --为提升性能，不从医嘱发送记录的发送时间查询，不采用精确的时间，因为直接登记的检验医嘱，一般开嘱时间与发送时间相差不大
  Update /*+ rule*/ 电子病历记录
  Set 待转出 = N_批次
  Where ID In (Select C.病历id
             From 病人医嘱记录 B, 病人医嘱报告 C
             Where C.医嘱id = B.Id And Nvl(B.主页id, 0) = 0 And B.挂号单 Is Null And B.相关id Is Null And B.待转出 Is Null And
                   B.开嘱时间 < d_End);

  Update /*+ rule*/ 电子病历附件
  Set 待转出 = n_批次
  Where 病历id In (Select ID From 电子病历记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 电子病历格式
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 电子病历记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 电子病历内容
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 电子病历记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 电子病历图形
  Set 待转出 = n_批次
  Where 对象id In (Select ID From 电子病历内容 Where 待转出 = n_批次 And 对象类型 = 5);

  Update /*+ rule*/ 病人医嘱报告
  Set 待转出 = n_批次
  Where 病历id In (Select ID From 电子病历记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 影像报告驳回
  Set 待转出 = n_批次
  Where (医嘱id, 病历id) In (Select 医嘱id, 病历id From 病人医嘱报告 Where 待转出 = n_批次);

  Update /*+ rule*/ 报告查阅记录
  Set 待转出 = n_批次
  Where 病历id In (Select ID From 电子病历记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 疾病申报记录
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 电子病历记录 Where 待转出 = n_批次);
  
  Update /*+ rule*/ 疾病报告反馈
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 电子病历记录 Where 待转出 = n_批次);
  
  Update /*+ rule*/ 病人诊断记录
  Set 待转出 = n_批次
  Where 病历id In (Select ID From 电子病历记录 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(7/10)病历数据标记完成，正在标记临床路径数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  --5.临床路径 
  Update /*+ rule*/ 病人临床路径
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, 主页id From 病案主页 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人合并路径
  Set 待转出 = n_批次
  Where 首要路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人合并路径评估
  Set 待转出 = n_批次
  Where 路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人出径记录
  Set 待转出 = n_批次
  Where 路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人路径执行
  Set 待转出 = n_批次
  Where 路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人路径评估
  Set 待转出 = n_批次
  Where 路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人路径变异
  Set 待转出 = n_批次
  Where 路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人路径指标
  Set 待转出 = n_批次
  Where 路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人路径医嘱
  Set 待转出 = n_批次
  Where 路径执行id In (Select ID From 病人路径执行 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(8/10)临床路径数据标记完成，正在标记医嘱数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  --6.医嘱，检验，检查 
  Update /*+ rule*/ 病人医嘱记录
  Set 待转出 = n_批次
  Where 挂号单 In (Select NO From 病人挂号记录 Where 待转出 = n_批次) And 病人来源 <> 4;
  Update /*+ rule*/ 病人医嘱记录
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, 主页id From 病案主页 Where 待转出 = n_批次);

  --自登记类病人(无挂号单)，病人医嘱报告在前面转病历时已转出 
  Update /*+ rule*/ 病人医嘱记录
  Set 待转出 = n_批次
  Where Rowid In (Select b.Rowid
                  From 病人医嘱记录 B, 病人医嘱报告 C
                  Where (b.相关id = c.医嘱id Or b.Id = c.医嘱id) And c.待转出 = n_批次);

  Update /*+ rule*/ 病人医嘱计价
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人医嘱附费
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人医嘱附件
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 输血申请记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 输血检验结果
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人医嘱执行
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人医嘱打印
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 医嘱执行打印
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人诊断医嘱
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人诊断记录
  Set 待转出 = n_批次
  Where ID In (Select 诊断id From 病人诊断医嘱 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人医嘱状态
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 医嘱签名记录
  Set 待转出 = n_批次
  Where ID In (Select 签名id From 病人医嘱状态 Where 待转出 = n_批次 And 签名id Is Not Null);

  Update /*+ rule*/ 病人医嘱发送
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 诊疗单据打印
  Set 待转出 = n_批次
  Where (NO, 记录性质) In (Select NO, 记录性质 From 病人医嘱发送 Where 待转出 = n_批次);

  Update /*+ rule*/ 医嘱执行时间
  Set 待转出 = n_批次
  Where (医嘱id, 发送号) In (Select 医嘱id, 发送号 From 病人医嘱发送 Where 待转出 = n_批次);

  Update /*+ rule*/ 医嘱执行计价
  Set 待转出 = n_批次
  Where (医嘱id, 发送号) In (Select 医嘱id, 发送号 From 病人医嘱发送 Where 待转出 = n_批次);

  Update /*+ rule*/ 执行打印记录
  Set 待转出 = n_批次
  Where (医嘱id, 发送号) In (Select 医嘱id, 发送号 From 病人医嘱发送 Where 待转出 = n_批次);

  Update /*+ rule*/ 处方审查明细
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 处方审查记录
  Set 待转出 = n_批次
  Where ID In (Select 审方id From 处方审查明细 Where 待转出 = n_批次);

  Update /*+ rule*/ 处方审查结果
  Set 待转出 = n_批次
  Where 审方id In (Select ID From 处方审查记录 Where 待转出 = n_批次);
  
  Update /*+ rule*/ RIS检查预约
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  
  Update Zldatamovelog
  Set 当前进度 = '(9/10)医嘱数据标记完成，正在标记检查检验数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  Update /*+ rule*/ 影像检查记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 影像报告记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 影像报告操作记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 影像检查序列
  Set 待转出 = n_批次
  Where 检查uid In (Select 检查uid From 影像检查记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 影像检查图象
  Set 待转出 = n_批次
  Where 序列uid In (Select 序列uid From 影像检查序列 Where 待转出 = n_批次);

  Update /*+ rule*/ 影像申请单图像
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 影像收藏内容
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 影像危急值记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(10/10)影像数据标记完成，正在标记检验数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  Update /*+ rule*/ 检验标本记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验申请项目
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验项目分布
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验分析记录
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验质控记录
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 检验操作记录
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 检验签名记录
  Set 待转出 = n_批次
  Where 检验标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 检验图像结果
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 检验试剂记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验拒收记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 检验普通结果
  Set 待转出 = n_批次
  Where 检验标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验质控报告
  Set 待转出 = n_批次
  Where 结果id In (Select ID From 检验普通结果 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验药敏结果
  Set 待转出 = n_批次
  Where 细菌结果id In (Select ID From 检验普通结果 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验流水线标本
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验流水线指标
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);

  Commit;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl1_Datamove_Tag;
/

--93052:刘尔旋,2016-01-25,支付宝结帐校对标志问题
Create Or Replace Procedure Zl_Third_Settlement
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is

  --------------------------------------------------------------------------------------------------
  --功能:三方接口支付
  --入参:Xml_In:
  --<IN>
  --        <BRID>病人ID</BRID>         //病人ID
  --        <ZYID>主页ID</ZYID>         //主页ID
  --        <JSLX>2</JSLX>         //结算类型,1-门诊,2-住院.目前固定传2
  --        <JE></JE>         //本次结算总金额
  --       <JSLIST>
  --         <JS>
  --              <JSKLB>支付卡类别</JSKLB >
  --              <JSKH>支付卡号</ JSKH >
  --              <JSFS>支付方式</JSFS> //支付方式:现金;支票,如果是三方卡,可以传空
  --              <JSJE>结算金额</JSJE> //结算金额(正金额：个人补款，负金额：医院退款)<SFCYJ>为1时为冲预交金额
  --              <JYLSH>交易流水号</JYLSH>
  --              <ZY>摘要</ZY>
  --              <SFCYJ>是否冲预交</SFCYJ>  //是否冲预交，0-结算，1-冲预交.允冲预交时,只填JSJE节点
  --              <SFXFK>是否消费卡</SFXFK>  //(1-是消费卡),消费卡时,传入结算卡类别,结算卡号,结算金额等接点
  --              <EXPENDLIST>  //扩展交易信息
  --                  <EXPEND>
  --                        <JYMC>交易名称</JYMC> //交易名称   退款时,传入冲预交的流水号
  --                        <JYLR>交易内容</JYLR> //交易内容   退款时,传入冲预交的金额
  --                  </EXPEND>
  --              </EXPENDLIST>
  --         </JS>
  --       </JSLIST >
  --</IN>

  --出参:Xml_Out
  --  <OUT>
  --    <CZSJ>操作时间</CZSJ>          //HIS的登记时间
  --    DD如无下列错误结点则说明正确执行
  --    <ERROR>
  --      <MSG>错误信息</MSG>
  --    </ERROR>
  --  </OUT>
  --------------------------------------------------------------------------------------------------
  n_主页id     病案主页.主页id%Type;
  n_病人id     病案主页.病人id%Type;
  n_结帐总额   病人预交记录.冲预交%Type;
  n_待结帐金额 病人预交记录.冲预交%Type;
  n_结算类型   Number(3);
  v_操作员编码 病人结帐记录.操作员编号%Type;
  v_操作员姓名 病人结帐记录.操作员姓名%Type;
  n_结帐id     病人结帐记录.Id%Type;
  n_冲预交金额 病人预交记录.冲预交%Type;
  d_结帐时间   Date;
  d_开始日期   Date;
  d_结束日期   Date;
  n_存在       Number(3);
  n_结算卡序号 卡消费接口目录.编号%Type;
  n_时间类型   Number(3);
  v_No         病人结帐记录.No%Type;
  n_卡类别id   医疗卡类别.Id%Type;
  v_结算卡号   病人预交记录.卡号%Type;
  v_结算方式   病人预交记录.结算方式%Type;
  v_Temp       Varchar2(500);
  v_Ids        Varchar2(20000);
  x_Templet    Xmltype; --模板XML
  v_Err_Msg    Varchar2(200);
  Err_Item Exception;
  n_Count Number(18);

Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/ZYID'), To_Number(Extractvalue(Value(A), 'IN/BRID')),
         To_Number(Extractvalue(Value(A), 'IN/JE')), To_Number(Extractvalue(Value(A), 'IN/JSLX'))
  Into n_主页id, n_病人id, n_结帐总额, n_结算类型
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  n_结算类型 := Nvl(n_结算类型, 2);

  --0.相关检查
  If Nvl(n_病人id, 0) = 0 Then
    v_Err_Msg := '不能有效识别病人身份,不允许缴费!';
    Raise Err_Item;
  End If;

  --人员id,人员编号,人员姓名
  v_Temp := Zl_Identity(1);
  If Nvl(v_Temp, '0') = '0' Or Nvl(v_Temp, '_') = '_' Then
    v_Err_Msg := '系统不能认别有效的操作员,不允许结算!';
    Raise Err_Item;
  End If;
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员编码 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员姓名 := v_Temp;
  v_Err_Msg    := Null;
  If n_结算类型 = 2 Then
    Begin
      Select Sum(Nvl(实收金额, 0)) - Sum(Nvl(结帐金额, 0))
      Into n_待结帐金额
      From 住院费用记录
      Where 病人id = n_病人id And 记录状态 <> 0 And 主页id = n_主页id And 记帐费用 = 1;
    Exception
      When Others Then
        n_待结帐金额 := 0;
    End;
  
    If n_待结帐金额 <> n_结帐总额 Then
      v_Err_Msg := '传入的结帐金额与实际结帐金额不符,不允许结算!';
      Raise Err_Item;
    End If;
  
    Select 病人结帐记录_Id.Nextval, Sysdate, Nextno(15) Into n_结帐id, d_结帐时间, v_No From Dual;
  
    n_时间类型 := zl_GetSysParameter('结帐费用时间', 1137);
    If n_时间类型 = 0 Then
      --按登记时间
      Select Trunc(Min(登记时间)), Trunc(Max(登记时间))
      Into d_开始日期, d_结束日期
      From (Select NO, 序号, 登记时间, 发生时间
             From 住院费用记录
             Where 病人id = n_病人id And 记录状态 <> 0 And 主页id = n_主页id And 记帐费用 = 1
             Group By NO, 序号, 登记时间, 发生时间, Mod(记录性质, 10)
             Having Sum(Nvl(实收金额, 0)) - Sum(Nvl(结帐金额, 0)) <> 0);
    Else
      --按发生时间  
      Select Trunc(Min(发生时间)), Trunc(Max(发生时间))
      Into d_开始日期, d_结束日期
      From (Select NO, 序号, 登记时间, 发生时间
             From 住院费用记录
             Where 病人id = n_病人id And 记录状态 <> 0 And 主页id = n_主页id And 记帐费用 = 1
             Group By NO, 序号, 登记时间, 发生时间, Mod(记录性质, 10)
             Having Sum(Nvl(实收金额, 0)) - Sum(Nvl(结帐金额, 0)) <> 0);
    End If;
  
    Zl_病人结帐记录_Insert(n_结帐id, v_No, n_病人id, d_结帐时间, d_开始日期, d_结束日期, 0, 0, n_主页id, Null, 2, Null, 2, 0, n_主页id, n_结帐总额);
  
    For r_费用 In (Select Min(ID) As ID, Mod(记录性质, 10) As 记录性质, NO, 序号, 记录状态, 执行状态,
                        Sum(Nvl(实收金额, 0)) - Sum(Nvl(结帐金额, 0)) As 金额, Sum(Nvl(结帐金额, 0)) As 结帐金额
                 From 住院费用记录
                 Where 病人id = n_病人id And 记录状态 <> 0 And 主页id = n_主页id And 记帐费用 = 1
                 Group By Mod(记录性质, 10), NO, 序号, 记录状态, 执行状态
                 Having Sum(Nvl(实收金额, 0)) - Sum(Nvl(结帐金额, 0)) <> 0
                 Order By NO, 序号) Loop
      If Nvl(r_费用.结帐金额, 0) = 0 Then
        Begin
          Select 1 Into n_存在 From 住院费用记录 Where ID = r_费用.Id And 结帐id Is Null;
        Exception
          When Others Then
            n_存在 := 0;
        End;
        If n_存在 = 1 Then
          v_Ids := v_Ids || ',' || r_费用.Id;
        Else
          Zl_结帐费用记录_Insert(0, r_费用.No, r_费用.记录性质, r_费用.记录状态, r_费用.执行状态, r_费用.序号, r_费用.金额, n_结帐id);
        End If;
      Else
        Zl_结帐费用记录_Insert(0, r_费用.No, r_费用.记录性质, r_费用.记录状态, r_费用.执行状态, r_费用.序号, r_费用.金额, n_结帐id);
      End If;
    End Loop;
    
    If v_Ids Is Not Null Then
      v_Ids := Substr(v_Ids, 2);
      Zl_结帐费用记录_Batch(v_Ids, n_病人id, n_结帐id);
    End If;
  
    n_Count := 0;
    For r_结算方式 In (Select Extractvalue(b.Column_Value, '/JS/JSKLB') As 结算卡类别,
                          Extractvalue(b.Column_Value, '/JS/JSKH') As 结算卡号,
                          Extractvalue(b.Column_Value, '/JS/JSFS') As 结算方式,
                          Extractvalue(b.Column_Value, '/JS/JSJE') As 结算金额,
                          Extractvalue(b.Column_Value, '/JS/JYLSH') As 交易流水号,
                          Extractvalue(b.Column_Value, '/JS/JYSM') As 交易说明, Extractvalue(b.Column_Value, '/JS/ZY') As 摘要,
                          Extractvalue(b.Column_Value, '/JS/SFCYJ') As 是否冲预交,
                          Extractvalue(b.Column_Value, '/JS/SFXFK') As 是否消费卡,
                          Xmlsequence(Extract(b.Column_Value, '/JS/EXPENDLIST')) As Expend
                   From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B) Loop
      If Nvl(r_结算方式.是否冲预交, 0) = 0 Then
        --付款
        If n_Count = 1 Then
          v_Err_Msg := '结帐结算暂不支持多种结算方式!';
          Raise Err_Item;
        End If;
        If Nvl(r_结算方式.是否消费卡, 0) = 1 Then
          Begin
            n_结算卡序号 := To_Number(r_结算方式.结算卡类别);
          Exception
            When Others Then
              n_结算卡序号 := 0;
          End;
          If n_结算卡序号 = 0 Then
            Begin
              Select 编号
              Into n_结算卡序号
              From 卡消费接口目录
              Where 名称 = r_结算方式.结算卡类别 And Nvl(启用, 0) = 1;
            Exception
              When Others Then
                v_Err_Msg := '未找到对应的消费卡!';
                Raise Err_Item;
            End;
          End If;
          If v_结算方式 Is Null Then
            Select 结算方式 Into v_结算方式 From 卡消费接口目录 Where 编号 = n_结算卡序号;
          End If;
        Else
          Begin
            n_卡类别id := To_Number(r_结算方式.结算卡类别);
          Exception
            When Others Then
              n_卡类别id := 0;
          End;
          If n_卡类别id = 0 Then
            Begin
              Select ID Into n_卡类别id From 医疗卡类别 Where 名称 = r_结算方式.结算卡类别 And Nvl(是否启用, 0) = 1;
            Exception
              When Others Then
                v_Err_Msg := '未找到对应的医疗卡!';
                Raise Err_Item;
            End;
          End If;
          If v_结算方式 Is Null Then
            Select 结算方式 Into v_结算方式 From 医疗卡类别 Where ID = n_卡类别id;
          End If;
        End If;
      
        If n_卡类别id Is Not Null Then
          --三方卡
          v_结算方式 := v_结算方式 || '|' || r_结算方式.结算金额 || '|';
          Zl_病人结帐结算_Modify(1, n_病人id, n_结帐id, v_结算方式, Null, 0, n_卡类别id, r_结算方式.结算卡号, r_结算方式.交易流水号, r_结算方式.交易说明, 0, 0, 0,
                           2, Null, v_操作员编码, v_操作员姓名, d_结帐时间, Null, 0);
        Else
          If n_结算卡序号 Is Not Null Then
            --消费卡
            v_结算卡号 := r_结算方式.结算卡号;
            v_结算方式 := n_结算卡序号 || '|' || r_结算方式.结算卡号 || '|0|' || r_结算方式.结算金额 || '||';
            Zl_病人结帐结算_Modify(3, n_病人id, n_结帐id, v_结算方式, Null, 0, n_卡类别id, r_结算方式.结算卡号, r_结算方式.交易流水号, r_结算方式.交易说明, 0, 0,
                             0, 2, Null, v_操作员编码, v_操作员姓名, d_结帐时间, Null, 0);
          Else
            --其他结算
            v_结算方式 := r_结算方式.结算方式 || '|' || r_结算方式.结算金额 || '||';
            Zl_病人结帐结算_Modify(0, n_病人id, n_结帐id, v_结算方式, Null, 0, n_卡类别id, r_结算方式.结算卡号, r_结算方式.交易流水号, r_结算方式.交易说明, 0, 0,
                             0, 2, Null, v_操作员编码, v_操作员姓名, d_结帐时间, Null, 0);
          End If;
        End If;
      
        n_Count := 1;
      Else
        --冲预交,目前默认全冲
        n_冲预交金额 := r_结算方式.结算金额;
        For r_预交 In (Select Min(ID) As ID, NO, 结算方式, Sum(Nvl(金额, 0)) - Sum(Nvl(冲预交, 0)) As 金额, 交易流水号
                     From 病人预交记录
                     Where 病人id = n_病人id And Mod(记录性质, 10) = 1 And Nvl(预交类别, 2) = 2 And (主页id = n_主页id Or 主页id Is Null)
                     Group By NO, 结算方式, 交易流水号
                     Having Sum(Nvl(金额, 0)) - Sum(Nvl(冲预交, 0)) <> 0) Loop
          Zl_结帐预交记录_Insert(r_预交.Id, r_预交.No, 1, r_预交.金额, n_结帐id, n_病人id, v_操作员编码, v_操作员姓名, d_结帐时间);
          n_冲预交金额 := n_冲预交金额 - Nvl(r_预交.金额, 0);
        End Loop;
        If n_冲预交金额 <> 0 Then
          v_Err_Msg := '传入的预交冲销金额与实际不符,请检查!';
          Raise Err_Item;
        End If;
      End If;
    End Loop;
  
    --处理扩展信息
    If Nvl(n_卡类别id, 0) <> 0 Then
      For c_扩展信息 In (Select Extractvalue(b.Column_Value, '/EXPEND/JYMC') As 交易名称,
                            Extractvalue(b.Column_Value, '/EXPEND/JYLR') As 交易内容
                     From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS/EXPENDLIST/EXPEND'))) B) Loop
        Zl_三方结算交易_Insert(n_卡类别id, 0, v_结算卡号, n_结帐id, c_扩展信息.交易名称 || '|' || c_扩展信息.交易内容, 0);
      End Loop;
    End If;
    If Nvl(n_结算卡序号, 0) <> 0 Then
      For c_扩展信息 In (Select Extractvalue(b.Column_Value, '/EXPEND/JYMC') As 交易名称,
                            Extractvalue(b.Column_Value, '/EXPEND/JYLR') As 交易内容
                     From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS/EXPENDLIST/EXPEND'))) B) Loop
        Zl_三方结算交易_Insert(n_结算卡序号, 1, v_结算卡号, n_结帐id, c_扩展信息.交易名称 || '|' || c_扩展信息.交易内容, 0);
      End Loop;
    End If;
  
    Zl_病人结帐结算_Modify(0, n_病人id, n_结帐id, '', Null, 0, Null, Null, Null, Null, 0, 0, 0, 2, Null, v_操作员编码, v_操作员姓名, d_结帐时间,
                     Null, 1);
  End If;
  Update 病人预交记录 Set 校对标志 = 0 Where 结帐id = n_结帐id And Nvl(校对标志, 0) <> 0;
  v_Temp := '<CZSJ>' || To_Char(d_结帐时间, 'YYYY-MM-DD hh24:mi:ss') || '</CZSJ>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Settlement;
/

--94132:刘尔旋,2016-03-14,支付宝换诊号源问题
--93006:刘尔旋,2016-01-22,禁止预约号源处理
Create Or Replace Procedure Zl_Third_Getnolist
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取号源列表
  --入参:Xml_In:
  --<IN>
  --  <RQ>日期</RQ>
  --  <KSID>科室ID</KSID>
  --  <YSID>医生ID</YSID>
  --  <YSXM>医生姓名</YSXM>
  --  <HZDW>支付宝</HZDW>    //合作单位，传入了的时候，只取合作单位的号;为空时，只取非合作单位的号
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  --  <GROUP>
  --    <RQ>日期</RQ>
  --    <HBLIST>
  --     <HB>
  --        <HM>235</HM>       //号码
  --        <YSID>549</YSID>      //医生ID
  --        <YS>张锐</YS>       //医生姓名
  --        <KSID>123</KSID>   //科室ID
  --        <KSMC>内科</KSMC>   //科室名称
  --        <ZC>主治医师</ZC> //职称
  --        <XMID>10086<XMID> //挂号项目的ID
  --        <XMMC>挂号费</XMMC> //挂号项目的名称
  --        <YGHS>0</YGHS>      //已挂号数
  --        <SYHS>99</SYHS>   //剩余号数
  --        <PRICE>15</PRICE>      //价格
  --        <HL>普通</HL>       //挂号类型
  --        <HCXH>1</HCXH>    //是否存在缓冲序号时间段，1-存在 0或者空-不存在
  --        <FSD>0</FSD>      //是否分时段
  --        <FWMC>白天</FWMC>     //号别时段
  --        <HBTIME>(08:00-17:59)</HBTIME> //可挂时间
  --     <SPANLIST>
  --            <SPAN>
  --                  <SJD/>      //时间段
  --                  <SL/>      //数量
  --            </SPAN>
  --            ……
  --          </SPANLIST>
  --      </HB>
  --      <HB>
  --      ……
  --      </HB>
  --    </HBLIST>
  --  </GROUP>
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  d_日期         Date;
  n_科室id       病人挂号记录.执行部门id%Type;
  n_医生id       人员表.Id%Type;
  v_医生姓名     人员表.姓名%Type;
  v_星期         挂号安排限制.限制项目%Type;
  v_时间段       Varchar2(100);
  v_合作单位     挂号合作单位.名称%Type;
  n_分时段       Number(3);
  n_单个剩余     Number(5);
  n_已挂数       Number(5);
  n_合约已挂数   Number(5);
  n_合计金额     收费价目.现价%Type;
  n_合约总数量   Number(5);
  n_合约剩余数量 Number(5);
  n_最大可用数量 Number(5);
  n_合约模式     Number(3); --合约模式:1-合约单位限数量模式 0-合约单位指定序号模式
  n_非合约       Number(3);
  n_是否预留     Number(3);
  d_加号时间     Date;
  n_缓冲序号     Number(3);
  n_时段数量     Number(5);
  n_预留数量     Number(5);
  n_特殊预约     Number(3);
  n_禁用         Number(3);
  v_剩余数量     Varchar2(100);
  v_Timetemp     Varchar2(100);
  v_Temp         Varchar2(32767); --临时XML
  v_Xmlmain      Clob; --临时XML
  c_Xmlmain      Clob; --临时XML
  x_Templet      Xmltype; --模板XML
  v_Err_Msg      Varchar2(200);
  n_Exists       Number(2);
  v_Sql          Varchar2(20000);
  Type c_Main Is Ref Cursor;
  r_科室id   挂号安排.科室id%Type;
  r_号类     挂号安排.号类%Type;
  r_科室名称 部门表.名称%Type;
  r_医生姓名 挂号安排.医生姓名%Type;
  r_医生id   挂号安排.医生id%Type;
  r_职称     人员表.专业技术职务%Type;
  r_号码     挂号安排.号码%Type;
  r_安排id   挂号安排.Id%Type;
  r_计划id   挂号安排计划.Id%Type;
  r_排班     挂号安排.周日%Type;
  r_项目id   挂号安排.项目id%Type;
  r_项目名称 收费项目目录.名称%Type;
  r_序号控制 挂号安排.序号控制%Type;
  r_限号数   挂号安排限制.限号数%Type;
  r_限约数   挂号安排限制.限约数%Type;
  r_已挂数   病人挂号汇总.已挂数%Type;
  r_已约数   病人挂号汇总.已约数%Type;
  r_已接收   病人挂号汇总.其中已接收%Type;
  r_价格     收费价目.现价%Type;
  r_No       c_Main;
  n_Curcount Number(3);

  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select To_Date(Extractvalue(Value(A), 'IN/RQ'), 'YYYY-MM-DD hh24:mi:ss'), Extractvalue(Value(A), 'IN/KSID'),
         Extractvalue(Value(A), 'IN/YSID'), Extractvalue(Value(A), 'IN/YSXM'), Extractvalue(Value(A), 'IN/HZDW')
  Into d_日期, n_科室id, n_医生id, v_医生姓名, v_合作单位
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  --日期节点为空的情况
  If d_日期 Is Null Then
    d_日期 := Trunc(Sysdate);
  End If;

  Select Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null)
  Into v_星期
  From Dual;
  n_合约剩余数量 := 0;

  v_Sql := 'Select a.*, Nvl(Hz.已挂数, 0) As 已挂数, Nvl(Hz.已约数, 0) As 已约数, Nvl(Hz.其中已接收, 0) As 已接收, b.现价 As 价格 ';
  v_Sql := v_Sql ||
           'From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Nvl(Ap.医生id, 0) As 医生id, Ry.专业技术职务 As 职称, Ap.号码, ';
  v_Sql := v_Sql || ' Ap.安排id, Ap.计划id, Ap.排班, Ap.项目id, Fy.名称 As 项目名称, Ap.序号控制, Ap.限号数, Ap.限约数 ';
  v_Sql := v_Sql || 'From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Ap.医生id, Ap.号码, Ap.Id As 安排id, 0 As 计划id, ';
  v_Sql := v_Sql || 'Ap.项目id, Nvl(Ap.序号控制, 0) As 序号控制, ';
  v_Sql := v_Sql || 'Decode(To_Char(:1, ''D''), ''1'', Ap.周日, ''2'', Ap.周一, ''3'', Ap.周二, ''4'', Ap.周三, ''5'', Ap.周四, ';
  v_Sql := v_Sql || ' ''6'', Ap.周五, ''7'', Ap.周六, Null) As 排班, Xz.限约数, Xz.限号数 ';
  v_Sql := v_Sql || 'From 挂号安排 Ap, 部门表 Bm, 挂号安排限制 Xz ';
  v_Sql := v_Sql || 'Where Ap.科室id = Bm.Id(+) ';

  n_Curcount := 2;
  If Nvl(n_科室id, 0) <> 0 Then
    v_Sql      := v_Sql || 'And Ap.科室id = :2 ';
    n_Curcount := n_Curcount + 1;
  End If;
  If Nvl(n_医生id, 0) <> 0 Then
    If n_Curcount = 2 Then
      v_Sql := v_Sql || 'And Ap.医生id = :2 ';
    Else
      v_Sql := v_Sql || 'And Ap.医生id = :3 ';
    End If;
    n_Curcount := n_Curcount + 1;
  End If;
  If Nvl(v_医生姓名, '_') <> '_' Then
    If n_Curcount = 2 Then
      v_Sql := v_Sql || 'And Ap.医生姓名 = :2 ';
    End If;
    If n_Curcount = 3 Then
      v_Sql := v_Sql || 'And Ap.医生姓名 = :3 ';
    End If;
    If n_Curcount = 4 Then
      v_Sql := v_Sql || 'And Ap.医生姓名 = :4 ';
    End If;
    n_Curcount := n_Curcount + 1;
  End If;

  v_Sql      := v_Sql || 'And Ap.停用日期 Is Null And :' || n_Curcount ||
                ' Between Nvl(Ap.开始时间, To_Date(''1900-01-01'', ''YYYY-MM-DD'')) And ';
  n_Curcount := n_Curcount + 1;
  v_Sql      := v_Sql || 'Nvl(Ap.终止时间, To_Date(''3000 - 01 - 01'', ''YYYY-MM-DD'')) And Xz.安排id(+) = Ap.Id And ';
  v_Sql      := v_Sql || ' Xz.限制项目(+) = Decode(To_Char(:' || n_Curcount ||
                ', ''D''), ''1'', ''周日'', ''2'', ''周一'', ''3'', ''周二'', ''4'', ''周三'', ''5'', ';
  n_Curcount := n_Curcount + 1;
  v_Sql      := v_Sql || ' ''周四'', ''6'', ''周五'', ''7'', ''周六'', Null) And Not Exists ';
  v_Sql      := v_Sql || '(Select Rownum ';
  v_Sql      := v_Sql || 'From 挂号安排停用状态 Ty ';
  v_Sql      := v_Sql || 'Where Ty.安排id = Ap.Id And :' || n_Curcount ||
                ' Between Ty.开始停止时间 And Ty.结束停止时间) And Not Exists ';
  n_Curcount := n_Curcount + 1;
  v_Sql      := v_Sql || '(Select Rownum ';
  v_Sql      := v_Sql || 'From 挂号安排计划 Jh Where Jh.安排id = Ap.Id And Jh.审核时间 Is Not Null And ';
  v_Sql      := v_Sql || ':' || n_Curcount ||
                ' Between Nvl(Jh.生效时间, To_Date(''1900-01-01'', ''YYYY-MM-DD'')) And Nvl(Jh.失效时间, To_Date(''3000-01-01'', ''YYYY-MM-DD''))) ';
  n_Curcount := n_Curcount + 1;
  v_Sql      := v_Sql || 'Union All ';
  v_Sql      := v_Sql ||
                'Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Jh.医生姓名, Jh.医生id, Ap.号码, Ap.Id As 安排id, Jh.Id As 计划id, ';
  v_Sql      := v_Sql || 'Jh.项目id, Nvl(Jh.序号控制, 0) As 序号控制,Decode(To_Char(:' || n_Curcount ||
                ', ''D''), ''1'', Jh.周日, ''2'', Jh.周一, ''3'', Jh.周二, ''4'', Jh.周三, ''5'', Jh.周四, ';
  n_Curcount := n_Curcount + 1;
  v_Sql      := v_Sql || ' ''6'', Jh.周五, ''7'', Jh.周六, Null) As 排班, Xz.限约数, Xz.限号数 ';
  v_Sql      := v_Sql || 'From 挂号安排计划 Jh, 挂号安排 Ap, 部门表 Bm, 挂号计划限制 Xz ';
  v_Sql      := v_Sql || 'Where Jh.安排id = Ap.Id And Ap.科室id = Bm.Id(+) And Ap.停用日期 Is Null ';

  If Nvl(n_科室id, 0) <> 0 Then
    v_Sql      := v_Sql || 'And Ap.科室id = :' || n_Curcount || ' ';
    n_Curcount := n_Curcount + 1;
  End If;
  If Nvl(n_医生id, 0) <> 0 Then
    v_Sql      := v_Sql || 'And Jh.医生id = :' || n_Curcount || ' ';
    n_Curcount := n_Curcount + 1;
  End If;
  If Nvl(v_医生姓名, '_') <> '_' Then
    v_Sql      := v_Sql || 'And Jh.医生姓名 = :' || n_Curcount || ' ';
    n_Curcount := n_Curcount + 1;
  End If;

  v_Sql      := v_Sql || ' And :' || n_Curcount ||
                ' Between Nvl(Jh.生效时间, To_Date(''1900-01-01'', ''YYYY-MM-DD'')) And Nvl(Jh.失效时间, To_Date(''3000-01-01'', ''YYYY-MM-DD'')) And Xz.计划id(+) = Jh.Id And ';
  n_Curcount := n_Curcount + 1;
  v_Sql      := v_Sql || 'Xz.限制项目(+) = Decode(To_Char(:' || n_Curcount ||
                ', ''D''), ''1'', ''周日'', ''2'', ''周一'', ''3'', ''周二'', ''4'', ''周三'', ''5'', ''周四'', ''6'', ''周五'', ''7'', ''周六'', Null) And Not Exists ';
  n_Curcount := n_Curcount + 1;
  v_Sql      := v_Sql || '(Select Rownum From 挂号安排停用状态 Ty Where Ty.安排id = Ap.Id And :' || n_Curcount ||
                ' Between Ty.开始停止时间 And Ty.结束停止时间) And ';
  n_Curcount := n_Curcount + 1;
  v_Sql      := v_Sql || '(Jh.生效时间, Jh.安排id) = (Select Max(Sxjh.生效时间) As 生效时间, 安排id From 挂号安排计划 Sxjh ';
  v_Sql      := v_Sql || ' Where Sxjh.审核时间 Is Not Null And :' || n_Curcount ||
                ' Between Nvl(Sxjh.生效时间, To_Date(''1900-01-01'', ''YYYY-MM-DD'')) And ';
  n_Curcount := n_Curcount + 1;
  v_Sql      := v_Sql || 'Nvl(Sxjh.失效时间, To_Date(''3000-01-01'', ''YYYY-MM-DD'')) And Sxjh.安排id = Jh.安排id ';
  v_Sql      := v_Sql || 'Group By Sxjh.安排id)) Ap, 部门表 Bm, 人员表 Ry, 收费项目目录 Fy ';
  v_Sql      := v_Sql || 'Where Ap.科室id = Bm.Id(+) And Ap.医生id = Ry.Id(+) And Ap.项目id = Fy.Id And 排班 Is Not Null) A, ';
  v_Sql      := v_Sql || '病人挂号汇总 Hz, 收费价目 B ';
  v_Sql      := v_Sql || 'Where a.号码 = Hz.号码(+) And Hz.日期(+) = Trunc(:' || n_Curcount || ') And a.项目id = b.收费细目id And ';
  n_Curcount := n_Curcount + 1;
  v_Sql      := v_Sql || 'Nvl(b.终止日期, To_Date(''3000-1-1'', ''YYYY-Mm-DD'')) > :' || n_Curcount || ' ';
  n_Curcount := n_Curcount + 1;
  v_Sql      := v_Sql || 'And b.执行日期 <= :' || n_Curcount || ' ';
  If Nvl(n_科室id, 0) <> 0 And Nvl(n_医生id, 0) <> 0 And Nvl(v_医生姓名, '_') <> '_' Then
    Open r_No For v_Sql
      Using d_日期, n_科室id, n_医生id, v_医生姓名, d_日期, d_日期, d_日期, d_日期, d_日期, n_科室id, n_医生id, v_医生姓名, d_日期, d_日期, d_日期, d_日期, d_日期, d_日期, d_日期;
  End If;
  If Nvl(n_科室id, 0) <> 0 And Nvl(n_医生id, 0) = 0 And Nvl(v_医生姓名, '_') = '_' Then
    Open r_No For v_Sql
      Using d_日期, n_科室id, d_日期, d_日期, d_日期, d_日期, d_日期, n_科室id, d_日期, d_日期, d_日期, d_日期, d_日期, d_日期, d_日期;
  End If;
  If Nvl(n_科室id, 0) = 0 And Nvl(n_医生id, 0) <> 0 And Nvl(v_医生姓名, '_') = '_' Then
    Open r_No For v_Sql
      Using d_日期, n_医生id, d_日期, d_日期, d_日期, d_日期, d_日期, n_医生id, d_日期, d_日期, d_日期, d_日期, d_日期, d_日期, d_日期;
  End If;
  If Nvl(n_科室id, 0) = 0 And Nvl(n_医生id, 0) = 0 And Nvl(v_医生姓名, '_') <> '_' Then
    Open r_No For v_Sql
      Using d_日期, v_医生姓名, d_日期, d_日期, d_日期, d_日期, d_日期, v_医生姓名, d_日期, d_日期, d_日期, d_日期, d_日期, d_日期, d_日期;
  End If;
  If Nvl(n_科室id, 0) <> 0 And Nvl(n_医生id, 0) <> 0 And Nvl(v_医生姓名, '_') = '_' Then
    Open r_No For v_Sql
      Using d_日期, n_科室id, n_医生id, d_日期, d_日期, d_日期, d_日期, d_日期, n_科室id, n_医生id, d_日期, d_日期, d_日期, d_日期, d_日期, d_日期, d_日期;
  End If;
  If Nvl(n_科室id, 0) <> 0 And Nvl(n_医生id, 0) = 0 And Nvl(v_医生姓名, '_') <> '_' Then
    Open r_No For v_Sql
      Using d_日期, n_科室id, v_医生姓名, d_日期, d_日期, d_日期, d_日期, d_日期, n_科室id, v_医生姓名, d_日期, d_日期, d_日期, d_日期, d_日期, d_日期, d_日期;
  End If;
  If Nvl(n_科室id, 0) = 0 And Nvl(n_医生id, 0) <> 0 And Nvl(v_医生姓名, '_') <> '_' Then
    Open r_No For v_Sql
      Using d_日期, n_医生id, v_医生姓名, d_日期, d_日期, d_日期, d_日期, d_日期, n_医生id, v_医生姓名, d_日期, d_日期, d_日期, d_日期, d_日期, d_日期, d_日期;
  End If;
  Loop
    Fetch r_No
      Into r_科室id, r_号类, r_科室名称, r_医生姓名, r_医生id, r_职称, r_号码, r_安排id, r_计划id, r_排班, r_项目id, r_项目名称, r_序号控制, r_限号数, r_限约数,
           r_已挂数, r_已约数, r_已接收, r_价格;
    Exit When r_No%NotFound;
    If r_计划id <> 0 Then
      Select Sign(Count(Rownum))
      Into n_分时段
      From 挂号安排计划 Jh, 挂号计划时段 Sd
      Where Jh.Id = Sd.计划id And Jh.Id = r_计划id And
            Sd.星期 =
            Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null) And
            Rownum < 2;
    Else
      Select Sign(Count(Rownum))
      Into n_分时段
      From 挂号安排 Ap, 挂号安排时段 Sd
      Where Ap.Id = Sd.安排id And Ap.Id = r_安排id And
            Sd.星期 =
            Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null) And
            Rownum < 2;
    End If;
    If n_分时段 = 0 Then
      v_Temp := '';
      If v_合作单位 Is Not Null And r_序号控制 = 1 Then
        If r_计划id <> 0 Then
          Select Nvl(Sum(数量), 0)
          Into n_合约总数量
          From 合作单位计划控制
          Where 计划id = r_计划id And 合作单位 = v_合作单位 And
                限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7',
                              '周六', Null);
          Select Count(1)
          Into n_合约模式
          From 合作单位计划控制
          Where 计划id = r_计划id And 合作单位 = v_合作单位 And
                限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7',
                              '周六', Null) And 序号 = 0;
        Else
          Select Nvl(Sum(数量), 0)
          Into n_合约总数量
          From 合作单位安排控制
          Where 安排id = r_安排id And 合作单位 = v_合作单位 And
                限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7',
                              '周六', Null);
          Select Count(1)
          Into n_合约模式
          From 合作单位安排控制
          Where 安排id = r_安排id And 合作单位 = v_合作单位 And
                限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7',
                              '周六', Null) And 序号 = 0;
        End If;
        If n_合约模式 = 0 Then
          If r_计划id <> 0 Then
            Select Count(1)
            Into n_合约已挂数
            From 病人挂号记录 A
            Where 号别 = r_号码 And 记录状态 = 1 And 发生时间 Between Trunc(d_日期) And Trunc(d_日期 + 1) - 1 / 60 / 60 / 24 And Exists
             (Select 1
                   From 合作单位计划控制
                   Where 计划id = r_计划id And 合作单位 = v_合作单位 And
                         限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                       '周五', '7', '周六', Null) And 序号 = a.号序 And 数量 <> 0);
          Else
            Select Count(1)
            Into n_合约已挂数
            From 病人挂号记录 A
            Where 号别 = r_号码 And 记录状态 = 1 And 发生时间 Between Trunc(d_日期) And Trunc(d_日期 + 1) - 1 / 60 / 60 / 24 And Exists
             (Select 1
                   From 合作单位安排控制
                   Where 安排id = r_安排id And 合作单位 = v_合作单位 And
                         限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                       '周五', '7', '周六', Null) And 序号 = a.号序 And 数量 <> 0);
          End If;
        Else
          Begin
            Select Count(1)
            Into n_合约已挂数
            From 病人挂号记录
            Where 号别 = r_号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                  Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
          Exception
            When Others Then
              n_合约已挂数 := 0;
          End;
        End If;
        If n_合约总数量 = 0 Then
          n_合约剩余数量 := 0;
        Else
          n_合约剩余数量 := n_合约总数量 - n_合约已挂数;
          If n_合约剩余数量 > (Nvl(r_限号数, 0) - r_已挂数) Then
            n_合约剩余数量 := Nvl(r_限号数, 0) - r_已挂数;
          End If;
        End If;
      End If;
    Else
      v_Temp := '<SPANLIST>';
      If r_计划id <> 0 Then
        Select Max(结束时间)
        Into d_加号时间
        From 挂号计划时段
        Where 计划id = r_计划id And 星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四',
                                            '6', '周五', '7', '周六', Null);
        If r_序号控制 = 1 Then
          If Trunc(d_日期) = Trunc(Sysdate) Then
            n_特殊预约 := 0;
          Else
            Select Nvl(Max(Jh.是否预约), 0)
            Into n_特殊预约
            From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                          To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                   'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                          To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                   'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                   From 挂号安排计划 Jh, 挂号计划时段 Sd
                   Where Jh.Id = Sd.计划id And Jh.Id = r_计划id And
                         Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                        '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
            Where Zt.日期(+) = Jh.开始时间 And Zt.号码(+) = Jh.号码 And Zt.序号(+) = Jh.序号 And
                  Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) <> 1;
          End If;
        
          For r_Time In (Select Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约, 0 As 已约数,
                                Decode(Nvl(Zt.序号, 0), 0, 1, 0) As 剩余数, Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) As 失效时段










                         From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                                       To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                       To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                From 挂号安排计划 Jh, 挂号计划时段 Sd
                                Where Jh.Id = Sd.计划id And Jh.Id = r_计划id And
                                      Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                     '周四', '6', '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                         Where Zt.日期(+) = Jh.开始时间 And Zt.号码(+) = Jh.号码 And Zt.序号(+) = Jh.序号 And
                               Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) <> 1
                         Order By 序号) Loop
            If v_合作单位 Is Not Null Then
              Begin
                Select 1
                Into n_合约模式
                From 合作单位计划控制
                Where 限制项目 = r_Time.星期 And 计划id = r_计划id And 序号 = 0 And 合作单位 = v_合作单位;
              Exception
                When Others Then
                  n_合约模式 := 0;
              End;
            Else
              n_合约模式 := 0;
            End If;
            If r_Time.剩余数 = 0 Then
              n_单个剩余 := 0;
            Else
              n_单个剩余 := r_Time.限制数量;
            End If;
            If v_合作单位 Is Null Or n_合约模式 = 1 Then
              Begin
                Select 1
                Into n_Exists
                From 合作单位计划控制
                Where 限制项目 = r_Time.星期 And 计划id = r_计划id And 序号 = r_Time.序号 And Rownum < 2;
              Exception
                When Others Then
                  n_Exists := 0;
              End;
              If n_Exists = 0 Then
                If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                  Null;
                Else
                  Begin
                    Select 1
                    Into n_是否预留
                    From 挂号序号状态
                    Where 状态 In (3, 4) And 号码 = r_号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                  Exception
                    When Others Then
                      n_是否预留 := 0;
                  End;
                  If n_是否预留 = 0 Then
                    v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                  '</SPAN>';
                    n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                  End If;
                End If;
              End If;
            Else
              Begin
                Select 1
                Into n_Exists
                From 合作单位计划控制
                Where 限制项目 = r_Time.星期 And 计划id = r_计划id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
              Exception
                When Others Then
                  n_Exists := 0;
              End;
              Begin
                Select 0
                Into n_非合约
                From 合作单位计划控制
                Where 计划id = r_计划id And 合作单位 = v_合作单位 And Rownum < 2;
              Exception
                When Others Then
                  n_非合约 := 1;
              End;
              If n_Exists = 1 Or n_非合约 = 1 Then
                If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                  Null;
                Else
                  Begin
                    Select 1
                    Into n_是否预留
                    From 挂号序号状态
                    Where 状态 In (3, 4) And 号码 = r_号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                  Exception
                    When Others Then
                      n_是否预留 := 0;
                  End;
                  If n_是否预留 = 0 Then
                    v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                      '</SPAN>';
                    n_合约剩余数量 := n_合约剩余数量 + 1;
                  End If;
                End If;
              End If;
            End If;
          End Loop;
        Else
          n_最大可用数量 := Nvl(r_限约数, Nvl(r_限号数, 0)) - Nvl(r_已约数, 0);
          For r_Time In (Select Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约,
                                Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 已约数,
                                Jh.限制数量 - Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 剩余数,
                                Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) As 失效时段
                         From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                                       To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                       To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                From 挂号安排计划 Jh, 挂号计划时段 Sd
                                Where Jh.Id = Sd.计划id And Jh.Id = r_计划id And
                                      Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                     '周四', '6', '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                         Where Jh.号码 = Zt.号码(+) And Jh.开始时间 = Zt.日期(+) And
                               Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) <> 1
                         Group By Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约
                         Order By Jh.序号) Loop
            If v_合作单位 Is Not Null Then
              Begin
                Select 1
                Into n_合约模式
                From 合作单位计划控制
                Where 限制项目 = r_Time.星期 And 计划id = r_计划id And 序号 = 0 And 合作单位 = v_合作单位;
              Exception
                When Others Then
                  n_合约模式 := 0;
              End;
            Else
              n_合约模式 := 0;
            End If;
            n_单个剩余 := r_Time.剩余数;
            If v_合作单位 Is Null Or n_合约模式 = 1 Then
              Begin
                Select 1
                Into n_Exists
                From 合作单位计划控制
                Where 限制项目 = r_Time.星期 And 计划id = r_计划id And 序号 = r_Time.序号 And Rownum < 2;
              Exception
                When Others Then
                  n_Exists := 0;
              End;
              If n_Exists = 0 Then
                If n_最大可用数量 < n_单个剩余 Then
                  v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                '</SPAN>';
                  n_时段数量 := Nvl(n_时段数量, 0) + n_最大可用数量;
                Else
                  v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                '</SPAN>';
                  n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                End If;
              End If;
            Else
              Begin
                Select 1
                Into n_Exists
                From 合作单位计划控制
                Where 限制项目 = r_Time.星期 And 计划id = r_计划id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
              Exception
                When Others Then
                  n_Exists := 0;
              End;
              Begin
                Select 0
                Into n_非合约
                From 合作单位计划控制
                Where 计划id = r_计划id And 合作单位 = v_合作单位 And Rownum < 2;
              Exception
                When Others Then
                  n_非合约 := 1;
              End;
              If n_Exists = 1 Or n_非合约 = 1 Then
                If n_最大可用数量 < n_单个剩余 Then
                  v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                    '</SPAN>';
                  n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                Else
                  v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                    '</SPAN>';
                  n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                End If;
              End If;
            End If;
          End Loop;
        End If;
      Else
        Select Max(结束时间)
        Into d_加号时间
        From 挂号安排时段
        Where 安排id = r_安排id And 星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四',
                                            '6', '周五', '7', '周六', Null);
        If r_序号控制 = 1 Then
          If Trunc(d_日期) = Trunc(Sysdate) Then
            n_特殊预约 := 0;
          Else
            Select Nvl(Max(Ap.是否预约), 0)
            Into n_特殊预约
            From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                          To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                   'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                          To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                   'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                   From 挂号安排 Ap, 挂号安排时段 Sd
                   Where Ap.Id = Sd.安排id And Ap.Id = r_安排id And
                         Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                        '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
            Where Zt.日期(+) = Ap.开始时间 And Zt.号码(+) = Ap.号码 And Zt.序号(+) = Ap.序号 And
                  Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) <> 1;
          End If;
          For r_Time In (Select Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约, 0 As 已约数,
                                Decode(Nvl(Zt.序号, 0), 0, 1, 0) As 剩余数, Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) As 失效时段










                         From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                                       To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                       To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                From 挂号安排 Ap, 挂号安排时段 Sd
                                Where Ap.Id = Sd.安排id And Ap.Id = r_安排id And
                                      Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                     '周四', '6', '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                         Where Zt.日期(+) = Ap.开始时间 And Zt.号码(+) = Ap.号码 And Zt.序号(+) = Ap.序号 And
                               Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) <> 1
                         Order By 序号) Loop
            If v_合作单位 Is Not Null Then
              Begin
                Select 1
                Into n_合约模式
                From 合作单位安排控制
                Where 限制项目 = r_Time.星期 And 安排id = r_安排id And 序号 = 0 And 合作单位 = v_合作单位;
              Exception
                When Others Then
                  n_合约模式 := 0;
              End;
            Else
              n_合约模式 := 0;
            End If;
            If r_Time.剩余数 = 0 Then
              n_单个剩余 := 0;
            Else
              n_单个剩余 := r_Time.限制数量;
            End If;
            If v_合作单位 Is Null Or n_合约模式 = 1 Then
              Begin
                Select 1
                Into n_Exists
                From 合作单位安排控制
                Where 限制项目 = r_Time.星期 And 安排id = r_安排id And 序号 = r_Time.序号 And Rownum < 2;
              Exception
                When Others Then
                  n_Exists := 0;
              End;
              If n_Exists = 0 Then
                If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                  Null;
                Else
                  Begin
                    Select 1
                    Into n_是否预留
                    From 挂号序号状态
                    Where 状态 In (3, 4) And 号码 = r_号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                  Exception
                    When Others Then
                      n_是否预留 := 0;
                  End;
                  If n_是否预留 = 0 Then
                    v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                  '</SPAN>';
                    n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                  End If;
                End If;
              End If;
            Else
              Begin
                Select 1
                Into n_Exists
                From 合作单位安排控制
                Where 限制项目 = r_Time.星期 And 安排id = r_安排id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
              Exception
                When Others Then
                  n_Exists := 0;
              End;
              Begin
                Select 0
                Into n_非合约
                From 合作单位安排控制
                Where 安排id = r_安排id And 合作单位 = v_合作单位 And Rownum < 2;
              Exception
                When Others Then
                  n_非合约 := 1;
              End;
              If n_Exists = 1 Or n_非合约 = 1 Then
                If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                  Null;
                Else
                  Begin
                    Select 1
                    Into n_是否预留
                    From 挂号序号状态
                    Where 状态 In (3, 4) And 号码 = r_号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                  Exception
                    When Others Then
                      n_是否预留 := 0;
                  End;
                  If n_是否预留 = 0 Then
                    v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                      '</SPAN>';
                    n_合约剩余数量 := n_合约剩余数量 + 1;
                  End If;
                End If;
              End If;
            End If;
          End Loop;
        Else
          n_最大可用数量 := Nvl(r_限约数, Nvl(r_限号数, 0)) - Nvl(r_已约数, 0);
          For r_Time In (Select Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约,
                                Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 已约数,
                                Ap.限制数量 - Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 剩余数,
                                Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) As 失效时段
                         From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                                       To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                       To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                From 挂号安排 Ap, 挂号安排时段 Sd
                                Where Ap.Id = Sd.安排id And Ap.Id = r_安排id And
                                      Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                     '周四', '6', '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                         Where Ap.号码 = Zt.号码(+) And Ap.开始时间 = Zt.日期(+) And
                               Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) <> 1
                         Group By Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约
                         Order By Ap.序号) Loop
            If v_合作单位 Is Not Null Then
              Begin
                Select 1
                Into n_合约模式
                From 合作单位安排控制
                Where 限制项目 = r_Time.星期 And 安排id = r_安排id And 序号 = 0 And 合作单位 = v_合作单位;
              Exception
                When Others Then
                  n_合约模式 := 0;
              End;
            Else
              n_合约模式 := 0;
            End If;
            n_单个剩余 := r_Time.剩余数;
            If v_合作单位 Is Null Or n_合约模式 = 1 Then
              Begin
                Select 1
                Into n_Exists
                From 合作单位安排控制
                Where 限制项目 = r_Time.星期 And 安排id = r_安排id And 序号 = r_Time.序号 And Rownum < 2;
              Exception
                When Others Then
                  n_Exists := 0;
              End;
              If n_Exists = 0 Then
                If n_最大可用数量 < n_单个剩余 Then
                  v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                '</SPAN>';
                  n_时段数量 := Nvl(n_时段数量, 0) + n_最大可用数量;
                Else
                  v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                '</SPAN>';
                  n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                End If;
              End If;
            Else
              Begin
                Select 1
                Into n_Exists
                From 合作单位安排控制
                Where 限制项目 = r_Time.星期 And 安排id = r_安排id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
              Exception
                When Others Then
                  n_Exists := 0;
              End;
              Begin
                Select 0
                Into n_非合约
                From 合作单位安排控制
                Where 安排id = r_安排id And 合作单位 = v_合作单位 And Rownum < 2;
              Exception
                When Others Then
                  n_非合约 := 1;
              End;
              If n_Exists = 1 Or n_非合约 = 1 Then
                If n_最大可用数量 < n_单个剩余 Then
                  v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                    '</SPAN>';
                  n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                Else
                  v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                    '</SPAN>';
                  n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                End If;
              End If;
            End If;
          End Loop;
        End If;
      End If;
    End If;
    If v_合作单位 Is Not Null Then
      If Nvl(r_计划id, 0) <> 0 Then
        Begin
          Select 0
          Into n_非合约
          From 合作单位计划控制
          Where 计划id = r_计划id And 合作单位 = v_合作单位 And Rownum < 2;
        Exception
          When Others Then
            n_非合约 := 1;
        End;
      Else
        Begin
          Select 0
          Into n_非合约
          From 合作单位安排控制
          Where 安排id = r_安排id And 合作单位 = v_合作单位 And Rownum < 2;
        Exception
          When Others Then
            n_非合约 := 1;
        End;
      End If;
    End If;
    If v_合作单位 Is Null Or n_非合约 = 1 Then
      If r_限号数 = 0 Then
        v_剩余数量 := '';
      Else
        If Nvl(r_计划id, 0) <> 0 Then
          Select Sum(数量)
          Into n_合约总数量
          From 合作单位计划控制
          Where 计划id = r_计划id And 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                '周四', '6', '周五', '7', '周六', Null);
        Else
          Select Sum(数量)
          Into n_合约总数量
          From 合作单位安排控制
          Where 安排id = r_安排id And 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                '周四', '6', '周五', '7', '周六', Null);
        End If;
        Begin
          Select Count(1)
          Into n_合约已挂数
          From 病人挂号记录
          Where 号别 = r_号码 And 记录状态 = 1 And 合作单位 Is Not Null And 发生时间 Between Trunc(d_日期) And
                Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
        Exception
          When Others Then
            n_合约已挂数 := 0;
        End;
        Select Count(1)
        Into n_预留数量
        From 挂号序号状态
        Where 状态 = 3 And 号码 = r_号码 And Trunc(日期) = Trunc(d_日期);
        If Trunc(d_日期) = Trunc(Sysdate) Then
          If Nvl(n_合约总数量, 0) = 0 Then
            v_剩余数量 := r_限号数 - r_已挂数 - r_已约数 + r_已接收 - n_预留数量;
          Else
            v_剩余数量 := r_限号数 - r_已挂数 - r_已约数 + r_已接收 - n_合约总数量 + n_合约已挂数 - n_预留数量;
          End If;
          n_已挂数 := r_已挂数;
          If Nvl(n_时段数量, 0) < v_剩余数量 And n_分时段 <> 0 Then
            n_缓冲序号 := 1;
            v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_加号时间, 'hh24:mi:ss') || '-' || '</SJD>' || '<SL>' ||
                          To_Number(v_剩余数量 - Nvl(n_时段数量, 0)) || '</SL>' || '</SPAN>';
          Else
            n_缓冲序号 := 0;
          End If;
        Else
          If Nvl(n_合约总数量, 0) = 0 Then
            v_剩余数量 := r_限约数 - r_已约数 - n_预留数量;
            If v_剩余数量 Is Null Then
              v_剩余数量 := r_限号数 - r_已挂数 - r_已约数 + r_已接收 - n_预留数量;
            End If;
          Else
            v_剩余数量 := r_限约数 - r_已约数 - n_合约总数量 + n_合约已挂数 - n_预留数量;
            If v_剩余数量 Is Null Then
              v_剩余数量 := r_限号数 - r_已挂数 - r_已约数 + r_已接收 - n_合约总数量 + n_合约已挂数 - n_预留数量;
            End If;
          End If;
          n_已挂数 := r_已挂数;
        End If;
      End If;
    Else
      If Nvl(r_计划id, 0) <> 0 Then
        If v_合作单位 Is Not Null Then
          Begin
            Select 1
            Into n_合约模式
            From 合作单位计划控制
            Where 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                '7', '周六', Null) And 计划id = r_计划id And 序号 = 0 And 合作单位 = v_合作单位;
          Exception
            When Others Then
              n_合约模式 := 0;
          End;
        Else
          n_合约模式 := 0;
        End If;
        Select Sum(数量)
        Into n_合约总数量
        From 合作单位计划控制
        Where 计划id = r_计划id And 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四',
                                              '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
      Else
        If v_合作单位 Is Not Null Then
          Begin
            Select 1
            Into n_合约模式
            From 合作单位安排控制
            Where 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                '7', '周六', Null) And 安排id = r_安排id And 序号 = 0 And 合作单位 = v_合作单位;
          Exception
            When Others Then
              n_合约模式 := 0;
          End;
        Else
          n_合约模式 := 0;
        End If;
        Select Sum(数量)
        Into n_合约总数量
        From 合作单位安排控制
        Where 安排id = r_安排id And 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四',
                                              '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
      End If;
      If n_合约模式 = 0 Then
        v_剩余数量   := n_合约剩余数量;
        n_已挂数     := r_已挂数;
        n_合约已挂数 := Nvl(n_合约总数量, 0) - n_合约剩余数量;
      Else
        n_已挂数 := r_已挂数;
        Begin
          Select Count(1)
          Into n_合约已挂数
          From 病人挂号记录
          Where 号别 = r_号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
        Exception
          When Others Then
            n_合约已挂数 := 0;
        End;
        If Nvl(n_合约总数量, 0) = 0 Then
          v_剩余数量 := '0';
        Else
          v_剩余数量 := n_合约总数量 - n_合约已挂数;
        End If;
      End If;
    End If;
    Select To_Char(开始时间, 'hh24:mi') Into v_Timetemp From 时间段 Where 时间段 = r_排班;
    v_时间段 := v_Timetemp || '-';
    Select To_Char(终止时间, 'hh24:mi') Into v_Timetemp From 时间段 Where 时间段 = r_排班;
    v_时间段 := v_时间段 || v_Timetemp;
    If v_Temp Is Not Null Then
      v_Temp := v_Temp || '</SPANLIST>';
    End If;
    If v_合作单位 Is Not Null Then
      If Nvl(r_计划id, 0) <> 0 Then
        Begin
          Select 1
          Into n_禁用
          From 合作单位计划控制
          Where 计划id = r_计划id And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
        Exception
          When Others Then
            n_禁用 := 0;
        End;
      Else
        Begin
          Select 1
          Into n_禁用
          From 合作单位安排控制
          Where 安排id = r_安排id And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
        Exception
          When Others Then
            n_禁用 := 0;
        End;
      End If;
    End If;
	--限约数=0的预约禁止
    If Trunc(d_日期) <> Trunc(Sysdate) Then
      If r_限约数 = 0 Then
        n_禁用 := 1;
      End If;
    End If;
    If Nvl(n_禁用, 0) = 0 Then
      --从项金额计算
      n_合计金额 := r_价格;
      For r_Subfee In (Select 现价, 从项数次
                       From 收费从属项目 A, 收费价目 B
                       Where a.主项id = r_项目id And a.从项id = b.收费细目id And Sysdate Between b.执行日期 And
                             Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))) Loop
        n_合计金额 := n_合计金额 + r_Subfee.现价 * r_Subfee.从项数次;
      End Loop;
      If Trunc(Sysdate) = Trunc(d_日期) Then
        Begin
          Select 1
          Into n_Exists
          From (Select 时间段
                 From 时间段
                 Where ('3000-01-10 ' || To_Char(Sysdate, 'HH24:MI:SS') < '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS')) Or
                       ('3000-01-10 ' || To_Char(Sysdate, 'HH24:MI:SS') <
                       Decode(Sign(开始时间 - 终止时间), 1, '3000-01-11 ' || To_Char(终止时间, 'HH24:MI:SS'),
                               '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS'))))
          Where 时间段 = r_排班;
        Exception
          When Others Then
            n_Exists := 0;
        End;
      Else
        n_Exists := 1;
      End If;
      If n_Exists = 1 Then
        If v_剩余数量 > 0 Then
          c_Xmlmain := '<HB>' || '<HM>' || r_号码 || '</HM>' || '<YSID>' || r_医生id || '</YSID>' || '<YS>' || r_医生姓名 ||
                       '</YS>' || '<KSID>' || r_科室id || '</KSID>' || '<KSMC>' || r_科室名称 || '</KSMC>' || '<ZC>' || r_职称 ||
                       '</ZC>' || '<XMID>' || r_项目id || '</XMID>' || '<XMMC>' || r_项目名称 || '</XMMC>' || '<YGHS>' ||
                       n_已挂数 || '</YGHS>' || '<SYHS>' || v_剩余数量 || '</SYHS>' || '<PRICE>' || n_合计金额 || '</PRICE>' ||
                       '<HCXH>' || n_缓冲序号 || '</HCXH>' || '<HL>' || r_号类 || '</HL>' || '<FSD>' || n_分时段 || '</FSD>' ||
                       '<HBTIME>' || v_时间段 || '</HBTIME>' || '<FWMC>' || r_排班 || '</FWMC>' || v_Temp || '</HB>';
          v_Xmlmain := v_Xmlmain || c_Xmlmain;
        Else
          c_Xmlmain := '<HB>' || '<HM>' || r_号码 || '</HM>' || '<YSID>' || r_医生id || '</YSID>' || '<YS>' || r_医生姓名 ||
                       '</YS>' || '<KSID>' || r_科室id || '</KSID>' || '<KSMC>' || r_科室名称 || '</KSMC>' || '<ZC>' || r_职称 ||
                       '</ZC>' || '<XMID>' || r_项目id || '</XMID>' || '<XMMC>' || r_项目名称 || '</XMMC>' || '<YGHS>' ||
                       n_已挂数 || '</YGHS>' || '<SYHS>' || v_剩余数量 || '</SYHS>' || '<PRICE>' || n_合计金额 || '</PRICE>' ||
                       '<HL>' || r_号类 || '</HL>' || '<FSD>' || n_分时段 || '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' ||
                       '<FWMC>' || r_排班 || '</FWMC>' || '</HB>';
          v_Xmlmain := v_Xmlmain || c_Xmlmain;
        End If;
      End If;
    End If;
    n_合约剩余数量 := 0;
    n_合约总数量   := 0;
    n_时段数量     := 0;
    n_禁用         := 0;
    n_非合约       := 0;
  End Loop;
  Close r_No;
  v_Xmlmain := '<GROUP>' || '<RQ>' || To_Char(d_日期, 'yyyy-mm-dd') || '</RQ>' || '<HBLIST>' || v_Xmlmain || '</HBLIST>' ||
               '</GROUP>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Xmlmain)) Into x_Templet From Dual;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getnolist;
/



--91776:蔡青松,2016-01-21,新增一个入参 标本发送批号_In 用于在采集工作站送检标本时处理批号
CREATE OR REPLACE Procedure Zl_Lis预置条码_标本送出
( 
  医嘱内容_In Varchar2, --内容包括多个|医嘱ID,医嘱ID,医嘱ID...| 
  Type_In     Number := 0, --0为送检 1为取消送检 
  送检人_In   病人医嘱发送.送检人%Type := '' ,
  标本发送批号_In 病人医嘱发送.标本发送批号%type
) Is 
  V_Nowdate Date; 
Begin 
  If Type_In = 0 Then 
    V_Nowdate := Sysdate; 
    Update /*+ rule */ 病人医嘱发送 
    Set 标本送出时间 = Decode(标本送出时间, Null, V_Nowdate, 标本送出时间), 送检人 = 送检人_In ,标本发送批号 = 标本发送批号_In
    Where 医嘱id In (Select A.Id 
                   From 病人医嘱记录 A, (Select * From Table(Cast(F_Num2list(医嘱内容_In) As Zltools.T_Numlist))) B 
                   Where B.Column_Value In (A.Id, A.相关id)); 
  Else 
    Update /*+ rule */ 病人医嘱发送 
    Set 标本送出时间 = Null, 送检人 = Null ,标本发送批号 = Null
    Where 医嘱id In (Select A.Id 
                   From 病人医嘱记录 A, (Select * From Table(Cast(F_Num2list(医嘱内容_In) As Zltools.T_Numlist))) B 
                   Where B.Column_Value In (A.Id, A.相关id)); 
  End If; 
Exception 
 
  When Others Then 
    Zl_Errorcenter(Sqlcode, Sqlerrm); 
End Zl_Lis预置条码_标本送出;
/

--93052:刘尔旋,2016-01-26,服务窗结帐问题
--92736:刘尔旋,2016-01-19,结帐接口修改
Create Or Replace Procedure Zl_Third_Getsettlement
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取HIS结帐数据
  --入参:Xml_In:
  --<IN>
  -- <BRID></BRID>       //病人ID 
  -- <ZYID></ZYID>         //主页ID
  -- <JSLX></JSLX>       //结算类型。1-门诊,2-住院。固定传2
  -- <JSKLB></JSKLB>       //结算卡类别
  --</IN>
  --出参:Xml_Out
  --<OUTPUT>
  --<JBXX>              //基本信息
  --   <XM></XM>           //姓名
  --   <XB></XB>           //性别
  --   <NL></NL>         //年龄
  --   <ZYH></ ZYH>        //住院号
  --   <ZYKS></ ZYKS>          //住院科室  
  --   <KSID></KSID>         //科室ID
  --   <ZZYS></ ZZYS>          //主治医生  
  --   <RYSJ></ RYSJ>          //入院时间
  --   <CYSJ></ CYSJ >         //出院时间 
  --   <JZSJ></JZSJ>         //结帐时间(未结帐为空)
  --   <DJH></DJH>         //单据号(未结帐为空)
  --   <JSZFY></JSZFY>         //结算总费用
  --</JBXX>
  --<YJKLIST>              //冲抵预缴款集合
  --   <ITEM>
  --     <DJH><DJH>        //预交款单据号
  --     <JSFS></JSFS>     //结算方式（为名称，返回什么就取什么）
  --     <JE></JE>           //预缴款金额
  --     <JYLSH></JYLSH>       //交易流水号（便于冲销使用）
  --     <SFJSK></SFJSK>       //是否结算卡，1-是，0-否。如果是由传入的卡类别缴费，返回1，否则返回0
  --   </ITEM>
  --</YJKLIST >
  --<TBQK>               //退补情况
  --   <TBLX></TBLX>         //退补类型(1:个人补款，2:医院退款)
  --   <TBJE></TBJE>         //退补金额
  --</TBQK>
  -- <ERROR><MSG></MSG></ERROR>    //出现错误时返回具体原因，error节点为空表示成功
  --</OUTPUT>  

  --------------------------------------------------------------------------------------------------
  n_病人id     病人信息.病人id%Type;
  n_主页id     病人信息.主页id%Type;
  n_结算类型   Number(3);
  n_卡类别id   医疗卡类别.Id%Type;
  v_结算卡类别 Varchar2(200);
  n_是否结清   Number(3); -- 1-未结清,0-结清
  n_结帐金额   住院费用记录.结帐金额%Type;
  v_Temp       Varchar2(32767); --临时XML
  v_Subtemp    Varchar2(32767);
  v_结帐ids    Varchar2(5000);
  n_退补金额   病人预交记录.冲预交%Type;
  n_病人余额   病人预交记录.金额%Type;
  n_结帐id     病人预交记录.结帐id%Type;
  x_Templet    Xmltype; --模板XML
  v_Err_Msg    Varchar2(200);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/BRID'), Extractvalue(Value(A), 'IN/ZYID'), Extractvalue(Value(A), 'IN/JSLX'),
         Extractvalue(Value(A), 'IN/JSKLB')
  Into n_病人id, n_主页id, n_结算类型, v_结算卡类别
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  --默认住院结帐
  n_结算类型 := Nvl(n_结算类型, 2);
  Begin
    Select ID Into n_卡类别id From 医疗卡类别 Where 名称 = v_结算卡类别;
  Exception
    When Others Then
      v_Err_Msg := '无法确认传入的结算卡,请检查!';
      Raise Err_Item;
  End;
  If n_结算类型 = 2 Then
    Begin
      Select Distinct 1
      Into n_是否结清
      From 住院费用记录
      Where 病人id = n_病人id And 记录状态 <> 0 And 主页id = n_主页id And 记帐费用 = 1 Having
       Sum(Nvl(实收金额, 0)) - Sum(Nvl(结帐金额, 0)) <> 0;
    Exception
      When Others Then
        n_是否结清 := 0;
    End;
    If n_是否结清 = 0 Then
      --结清,读取结帐数据
      For r_结帐 In (Select 姓名, 性别, 年龄, 住院号, 住院科室, 科室id, 主治医生, To_Char(入院时间, 'yyyy-mm-dd') As 入院时间,
                          To_Char(出院时间, 'yyyy-mm-dd') As 出院时间, To_Char(结帐时间, 'yyyy-mm-dd') As 结帐时间, 单据号, 结算总费用, 结帐id
                   From (Select c.姓名, c.性别, c.年龄, c.住院号, d.名称 As 住院科室, c.入院科室id As 科室id, c.住院医师 As 主治医生, c.入院日期 As 入院时间,
                                 c.出院日期 As 出院时间, a.收费时间 As 结帐时间, a.No As 单据号, a.结帐金额 As 结算总费用, a.Id As 结帐id
                          From 病人结帐记录 A, 病案主页 C, 部门表 D
                          Where a.记录状态 = 1 And Nvl(a.结算状态, 0) In (0, 2) And a.病人id = c.病人id And a.病人id = n_病人id And
                                a.主页id = n_主页id And a.主页id = c.主页id And c.入院科室id = d.Id(+) And Exists
                           (Select 1 From 病人预交记录 Where 结帐id = a.Id And 结算方式 = v_结算卡类别)
                          Order By 结帐时间 Desc)
                   Where Rownum < 2) Loop
        v_Temp := '<XM>' || r_结帐.姓名 || '</XM>';
        v_Temp := v_Temp || '<XB>' || r_结帐.性别 || '</XB>';
        v_Temp := v_Temp || '<NL>' || r_结帐.年龄 || '</NL>';
        v_Temp := v_Temp || '<ZYH>' || r_结帐.住院号 || '</ZYH>';
        v_Temp := v_Temp || '<ZYKS>' || r_结帐.住院科室 || '</ZYKS>';
        v_Temp := v_Temp || '<KSID>' || r_结帐.科室id || '</KSID>';
        v_Temp := v_Temp || '<ZZYS>' || r_结帐.主治医生 || '</ZZYS>';
        v_Temp := v_Temp || '<RYSJ>' || r_结帐.入院时间 || '</RYSJ>';
        v_Temp := v_Temp || '<CYSJ>' || r_结帐.出院时间 || '</CYSJ>';
        v_Temp := v_Temp || '<JZSJ>' || r_结帐.结帐时间 || '</JZSJ>';
        v_Temp := v_Temp || '<DJH>' || r_结帐.单据号 || '</DJH>';
        v_Temp := v_Temp || '<JSZFY>' || r_结帐.结算总费用 || '</JSZFY>';
        v_Temp := '<JBXX>' || v_Temp || '</JBXX>';
        Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
        n_结帐id := r_结帐.结帐id;
      End Loop;
      If n_结帐id Is Null Then
        v_Err_Msg := '该病人没有结帐数据!';
        Raise Err_Item;
      End If;
      v_Temp := '';
      For r_预交 In (Select NO As 单据号, 结算方式, Sum(冲预交) As 金额, 交易流水号, Max(卡类别id) As 卡类别id
                   From 病人预交记录
                   Where 结帐id = n_结帐id And Mod(记录性质, 10) = 1
                   Group By NO, 结算方式, 交易流水号
                   Order By 单据号 Desc) Loop
        v_Temp := '<DJH>' || r_预交.单据号 || '</DJH>';
        v_Temp := v_Temp || '<JSFS>' || r_预交.结算方式 || '</JSFS>';
        v_Temp := v_Temp || '<JE>' || r_预交.金额 || '</JE>';
        v_Temp := v_Temp || '<JYLSH>' || r_预交.交易流水号 || '</JYLSH>';
        If n_卡类别id = r_预交.卡类别id Then
          v_Temp := v_Temp || '<SFJSK>' || 1 || '</SFJSK>';
        Else
          v_Temp := v_Temp || '<SFJSK>' || 0 || '</SFJSK>';
        End If;
        v_Temp    := '<ITEM>' || v_Temp || '</ITEM>';
        v_Subtemp := v_Subtemp || v_Temp;
      End Loop;
      v_Subtemp := '<YJKLIST>' || v_Subtemp || '</YJKLIST>';
      Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Subtemp)) Into x_Templet From Dual;
      Select Nvl(Sum(冲预交), 0)
      Into n_退补金额
      From 病人预交记录
      Where 结帐id = n_结帐id And Mod(记录性质, 10) = 2 And Nvl(校对标志, 0) = 0;
      If n_退补金额 < 0 Then
        v_Temp := '<TBLX>' || 2 || '</TBLX>';
      Else
        v_Temp := '<TBLX>' || 1 || '</TBLX>';
      End If;
      v_Temp := v_Temp || '<TBJE>' || Abs(n_退补金额) || '</TBJE>';
      v_Temp := '<TBQK>' || v_Temp || '</TBQK>';
      Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Else
      --未结清，读取未结数据
      For r_Info In (Select c.姓名, c.性别, c.年龄, c.住院号, d.名称 As 住院科室, c.入院科室id As 科室id, c.住院医师 As 主治医生,
                            To_Char(c.入院日期, 'yyyy-mm-dd') As 入院时间, To_Char(c.出院日期, 'yyyy-mm-dd') As 出院时间
                     From 病案主页 C, 部门表 D
                     Where c.病人id = n_病人id And c.入院科室id = d.Id(+) And c.主页id = n_主页id And Rownum < 2) Loop
        v_Temp := '<XM>' || r_Info.姓名 || '</XM>';
        v_Temp := v_Temp || '<XB>' || r_Info.性别 || '</XB>';
        v_Temp := v_Temp || '<NL>' || r_Info.年龄 || '</NL>';
        v_Temp := v_Temp || '<ZYH>' || r_Info.住院号 || '</ZYH>';
        v_Temp := v_Temp || '<ZYKS>' || r_Info.住院科室 || '</ZYKS>';
        v_Temp := v_Temp || '<KSID>' || r_Info.科室id || '</KSID>';
        v_Temp := v_Temp || '<ZZYS>' || r_Info.主治医生 || '</ZZYS>';
        v_Temp := v_Temp || '<RYSJ>' || r_Info.入院时间 || '</RYSJ>';
        v_Temp := v_Temp || '<CYSJ>' || r_Info.出院时间 || '</CYSJ>';
        v_Temp := v_Temp || '<JZSJ>' || '' || '</JZSJ>';
        v_Temp := v_Temp || '<DJH>' || '' || '</DJH>';
      End Loop;
      Begin
        Select Sum(Nvl(实收金额, 0)) - Sum(Nvl(结帐金额, 0))
        Into n_结帐金额
        From 住院费用记录
        Where 病人id = n_病人id And 记录状态 <> 0 And 主页id = n_主页id And 记帐费用 = 1;
      Exception
        When Others Then
          n_结帐金额 := 0;
      End;
      v_Temp := v_Temp || '<JSZFY>' || n_结帐金额 || '</JSZFY>';
      v_Temp := '<JBXX>' || v_Temp || '</JBXX>';
      Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
      v_Subtemp := '';
      For r_预交 In (Select NO As 单据号, 结算方式, Sum(Nvl(金额, 0)) - Sum(Nvl(冲预交, 0)) As 金额, 交易流水号, Max(卡类别id) As 卡类别id
                   From 病人预交记录
                   Where 病人id = n_病人id And Mod(记录性质, 10) = 1 And Nvl(预交类别, 2) = 2 And (主页id = n_主页id Or 主页id Is Null)
                   Group By NO, 结算方式, 交易流水号
                   Having Sum(Nvl(金额, 0)) - Sum(Nvl(冲预交, 0)) <> 0) Loop
        v_Temp := '<DJH>' || r_预交.单据号 || '</DJH>';
        v_Temp := v_Temp || '<JSFS>' || r_预交.结算方式 || '</JSFS>';
        v_Temp := v_Temp || '<JE>' || r_预交.金额 || '</JE>';
        v_Temp := v_Temp || '<JYLSH>' || r_预交.交易流水号 || '</JYLSH>';
        If n_卡类别id = r_预交.卡类别id Then
          v_Temp := v_Temp || '<SFJSK>' || 1 || '</SFJSK>';
        Else
          v_Temp := v_Temp || '<SFJSK>' || 0 || '</SFJSK>';
        End If;
        v_Temp     := '<ITEM>' || v_Temp || '</ITEM>';
        v_Subtemp  := v_Subtemp || v_Temp;
        n_病人余额 := Nvl(n_病人余额, 0) + Nvl(r_预交.金额, 0);
      End Loop;
      v_Subtemp := '<YJKLIST>' || v_Subtemp || '</YJKLIST>';
      Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Subtemp)) Into x_Templet From Dual;
      If Nvl(n_病人余额,0) - Nvl(n_结帐金额,0) > 0 Then
        v_Temp := '<TBLX>' || 2 || '</TBLX>';
      Else
        v_Temp := '<TBLX>' || 1 || '</TBLX>';
      End If;
      v_Temp := v_Temp || '<TBJE>' || Abs(Nvl(n_病人余额,0) - Nvl(n_结帐金额,0)) || '</TBJE>';
      v_Temp := '<TBQK>' || v_Temp || '</TBQK>';
      Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    End If;
  End If;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getsettlement;
/

--92818:刘硕,2016-01-18,最后一次入院更新主页ID=NUll的结构化地址
Create Or Replace Procedure Zl_病人地址信息_Update
(
  功能_In     Number,
  病人id_In   病人地址信息.病人id%Type,
  主页id_In   病人地址信息.主页id%Type,
  地址类别_In 病人地址信息.地址类别%Type,
  省_In       病人地址信息.省%Type := Null,
  市_In       病人地址信息.市%Type := Null,
  县_In       病人地址信息.县%Type := Null,
  乡镇_In     病人地址信息.乡镇%Type := Null,
  其他_In     病人地址信息.其他%Type := Null,
  区划代码_In 病人地址信息.区划代码%Type := Null
) Is
  --功能：首页整理中结构化病人地址信息管理 
  --参数：功能_In 1-新增,修改   2-删除 
  d_出院日期 病案主页.出院日期%Type;
  n_Count    Number(3);
Begin
  If 功能_In = 1 Then
    Update 病人地址信息
    Set 省 = 省_In, 市 = 市_In, 县 = 县_In, 乡镇 = 乡镇_In, 其他 = 其他_In, 区划代码 = 区划代码_In
    Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0) And 地址类别 = 地址类别_In;
    If Sql%Rowcount = 0 Then
      Insert Into 病人地址信息
        (病人id, 主页id, 地址类别, 省, 市, 县, 乡镇, 其他, 区划代码)
      Values
        (病人id_In, 主页id_In, 地址类别_In, 省_In, 市_In, 县_In, 乡镇_In, 其他_In, 区划代码_In);
    End If;
    --若主页ID是病人最后一次在该院就诊，则更新主页ID=Null的数据
    If Not 主页id_In Is Null Then
      Select 出院日期 Into d_出院日期 From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
      --存在出院时间，则判断该出院后是否存在就诊或住院数据
      If Not d_出院日期 Is Null Then
        --先判断住院
        Select Count(1) Into n_Count From 病案主页 Where 病人id = 病人id_In And 入院日期 >= d_出院日期;
        If n_Count = 0 Then
          Begin
            --该过程病案、标准版均有。病案系统若单独安装没有病人挂号记录
            Execute Immediate 'Select Count(1) From 病人挂号记录 Where 病人id =:1  And 登记时间 >=:2 '
              Into n_Count
              Using 病人id_In, d_出院日期;
          Exception
            When Others Then
              Null;
          End;
        End If;
      End If;
      If d_出院日期 Is Null Or Nvl(n_Count, 0) = 0 Then
        Update 病人地址信息
        Set 省 = 省_In, 市 = 市_In, 县 = 县_In, 乡镇 = 乡镇_In, 其他 = 其他_In, 区划代码 = 区划代码_In
        Where 病人id = 病人id_In And 主页id Is Null And 地址类别 = 地址类别_In;
      End If;
    End If;
  Else
    Delete From 病人地址信息
    Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0) And 地址类别 = 地址类别_In;
  End If;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人地址信息_Update;
/
--92776:梁经伙,2016-01-15,删除传染病报告卡时，清除报告卡关联的反馈单的文件ID
CREATE OR REPLACE Procedure Zl_电子病历记录_Delete(Id_In In 电子病历记录.Id%Type) Is
  n_处理状态 电子病历记录.处理状态%Type; 
  e_Submit Exception; 
Begin 
  Select Nvl(处理状态, 0) Into n_处理状态 From 电子病历记录 Where ID = Id_In; 
  If n_处理状态 > 0 Then 
    Raise e_Submit; 
  End If; 
  Delete 病人诊断记录 T 
  Where t.Id In (Select a.Id 
                 From 病人诊断记录 A, 电子病历记录 C 
                 Where a.病历id = c.Id And a.病人id = c.病人id And a.主页id = c.主页id And c.Id = Id_In); 
  Update 电子病历时机 
  Set 完成记录id = Null, 完成时间 = Null 
  Where (病人id, 主页id, 文件id) = (Select 病人id, 主页id, 文件id From 电子病历记录 Where ID = Id_In) And 完成记录id = Id_In; 
  update 疾病阳性记录 set 文件ID = NULL where 文件ID = Id_In;  --传染病管理系统清除关联的反馈单的文件ID
  Delete 电子病历打印 Where 文件id = Id_In; 
  Delete 电子病历记录 Where ID = Id_In; 
  Delete 疾病申报记录 Where 文件id = Id_In; --为支持新版病历，删除了外键 
Exception 
  When e_Submit Then 
    Raise_Application_Error(-20101, '[ZLSOFT]不能删除被后续接收的病历！[ZLSOFT]'); 
  When Others Then 
    zl_ErrorCenter(SQLCode, SQLErrM); 
End Zl_电子病历记录_Delete;
/

--92527:刘尔旋,2016-01-15,重算费用病人余额问题
Create Or Replace Procedure Zl_病人未结门诊费用_Recalc(病人id_In 住院费用记录.病人id%Type) As
  v_费别     费别.名称%Type;
  v_No       门诊费用记录.No%Type;
  n_实收金额 门诊费用记录.实收金额%Type;
  n_费用余额 病人余额.费用余额%Type;
  n_小数位数 Number(2);
  v_Counter  Number(5);
  d_Sysdate  Date;
  v_Thisinfo Varchar(100);
  v_Lastinfo Varchar(100);

  Err_Custom Exception;
  v_Error Varchar2(255);
Begin
  Select 费别 Into v_费别 From 病人信息 Where 病人id = 病人id_In;

  --条件判断
  --a.当前不是按主从项汇总计算折扣模式
  v_Counter := To_Number(Nvl(zl_GetSysParameter(93), 0));
  If v_Counter = 1 Then
    v_Error := '当前费别使用主从项汇总计算折扣模式,不支持费用重算!';
    Raise Err_Custom;
  End If;

  --b.当前费别不是使用药品按成本价加收打折的费别
  v_Counter := 0;
  Select Count(费别) Into v_Counter From 费别明细 Where 费别 = v_费别 And 计算方法 = 1;
  If v_Counter > 0 Then
    v_Error := '当前费别使用药品按成本价加收打折模式,不支持费用重算!';
    Raise Err_Custom;
  End If;

  --c.没有未结费用
  Begin
    Select 费用余额 Into n_费用余额 From 病人余额 Where 病人id = 病人id_In And 类型 = 1 And 性质 = 1;
  Exception
    When Others Then
      n_费用余额 := 0;
  End;
  --可能有未结费用，但不是本次住院发生的，在后面执行时再判断本次是否有未结明细
  If n_费用余额 = 0 Then
    v_Counter := 0;
    --费用余额为0时，也可能有费用（所有费用都不收费）
    Select Count(ID) Into v_Counter From 门诊费用记录 Where 病人id = 病人id_In And Rownum < 2;
    If v_Counter = 0 Then
      v_Error := '病人不存在未结费用,不用进行费用重算!';
      Raise Err_Custom;
    End If;
  End If;

  --d.不存在与本次住院费别不同的费用明细
  v_Counter := 0;
  Select Count(ID) Into v_Counter From 门诊费用记录 Where 病人id = 病人id_In And 费别 <> v_费别;
  If v_Counter = 0 Then
    v_Error := '病人不存在与本次住院费别不同的费用明细 ,不用进行费用重算!';
    Raise Err_Custom;
  End If;

  --执行
  v_Counter  := 0;
  d_Sysdate  := Sysdate;
  n_小数位数 := To_Number(Nvl(zl_GetSysParameter(9), 2));
  For r_Fee In (Select 病人id, 门诊标志, 记帐费用, 姓名, 性别, 年龄, 标识号, 病人科室id, 收费类别, 收费细目id, 计算单位, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目,
                       开单部门id, 开单人, 执行部门id, 发生时间, 操作员编号, 操作员姓名, Nvl(Sum(应收金额), 0) 应收金额, Nvl(Sum(实收金额), 0) 实收金额
                From (Select ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 记帐单id, 病人id, 医嘱序号, 门诊标志, 记帐费用, 姓名, 性别, 年龄, 标识号,
                              0 As 病人病区id, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目,
                              标准单价, 应收金额, 实收金额, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 执行状态, 执行时间, 结论, 操作员编号, 操作员姓名,
                              结帐id, 结帐金额, 保险大类id, 保险项目否, 保险编码, 费用类型, 统筹金额, 是否上传, 摘要, 是否急诊
                       From 门诊费用记录
                       Union All
                       Select ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 记帐单id, 病人id, 医嘱序号, 门诊标志, 记帐费用, 姓名, 性别, 年龄, 标识号,
                              0 As 病人病区id, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目,
                              标准单价, 应收金额, 实收金额, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 执行状态, 执行时间, 结论, 操作员编号, 操作员姓名,
                              结帐id, 结帐金额, 保险大类id, 保险项目否, 保险编码, 费用类型, 统筹金额, 是否上传, 摘要, 是否急诊
                       From H门诊费用记录)
                Where 病人id = 病人id_In And 记录状态 <> 0 And 记帐费用 = 1
                Group By 病人id, 门诊标志, 记帐费用, 姓名, 性别, 年龄, 标识号, 病人科室id, 收费类别, 收费细目id, 计算单位, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目,
                         开单部门id, 开单人, 执行部门id, 发生时间, 操作员编号, 操作员姓名
                Having(Nvl(Sum(实收金额), 0) <> Nvl(Sum(结帐金额), 0) Or Nvl(Sum(结帐金额), 0) = 0) And Not(Nvl(Sum(应收金额), 0) = 0 And Nvl(Sum(实收金额), 0) = 0)
                Order By 开单部门id, 开单人, 操作员姓名) Loop
    --          包括从未结的费用,费用明细部分结帐,以及结帐后作废,这些记录有可能已转入后备表
    --          1.排开了已全部结帐的记录(Sum(应收金额)=Sum(应收金额))
    --          2.排开了无打折冲减的记帐后已销帐的记录(Sum(应收金额)=0,Sum(应收金额)=0)
    --          3.不排开打折冲减后发生了单据销帐的记录，要将原冲减记录一并汇总重算(Sum(应收金额)=0,Sum(应收金额)<>0)
    --          4.不排开打折冲减后产生的实收和结帐都为零的记录，因为改回原来的费别时，要重算回去
    If r_Fee.应收金额 <> 0 Then
      Begin
        Select 实收金额
        Into n_实收金额
        From (Select Round(r_Fee.应收金额 * Nvl(实收比率, 0) / 100, n_小数位数) 实收金额
               From 费别明细
               Where 收费细目id = r_Fee.收费细目id And 费别 = v_费别 And Abs(r_Fee.应收金额) Between 应收段首值 And 应收段尾值 And Nvl(计算方法, 0) = 0
               Union All
               Select Round(r_Fee.应收金额 * Nvl(实收比率, 0) / 100, n_小数位数) 实收金额
               From 费别明细 A
               Where 收入项目id = r_Fee.收入项目id And 费别 = v_费别 And Abs(r_Fee.应收金额) Between 应收段首值 And 应收段尾值 And Nvl(计算方法, 0) = 0 And
                     Not Exists (Select 1 From 费别明细 B Where b.费别 = a.费别 And b.收费细目id = r_Fee.收费细目id));
      Exception
        When Others Then
          n_实收金额 := r_Fee.应收金额;
      End;
    Else
      n_实收金额 := 0;
    End If;
    --计算用来冲减原实收的差额
    n_实收金额 := -1 * (r_Fee.实收金额 - n_实收金额);
  
    If n_实收金额 <> 0 Then
      --一张单据的开单部门id,开单人,操作员姓名,床号要求相同，如果其中之一变了则产生新单据，如果都没有变，一张单据最多100条明细
      v_Thisinfo := r_Fee.开单部门id || r_Fee.开单人 || r_Fee.操作员姓名 || ' ';
      If v_Counter = 0 Or v_Counter = 100 Or v_Thisinfo <> v_Lastinfo Then
        v_No       := Nextno(14);
        v_Counter  := 1;
        v_Lastinfo := v_Thisinfo;
      Else
        v_Counter := v_Counter + 1;
      End If;
    
      Insert Into 门诊费用记录
        (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 记帐单id, 门诊标志, 病人id, 标识号, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否,
         保险大类id, 付数, 数次, 发药窗口, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用, 划价人, 开单部门id, 开单人, 发生时间, 登记时间,
         执行部门id, 执行状态, 结帐id, 结帐金额, 操作员编号, 操作员姓名, 摘要, 是否急诊, 医嘱序号)
      Values
        (病人费用记录_Id.Nextval, 2, v_No, 1, v_Counter, Null, Null, Null, r_Fee.门诊标志, r_Fee.病人id, r_Fee.标识号, r_Fee.姓名,
         r_Fee.性别, r_Fee.年龄, r_Fee.病人科室id, v_费别, r_Fee.收费类别, r_Fee.收费细目id, r_Fee.计算单位, Null, Null, 0, 0, Null,
         r_Fee.加班标志, r_Fee.附加标志, r_Fee.婴儿费, r_Fee.收入项目id, r_Fee.收据费目, 0, 0, n_实收金额, Null, 1, Null, r_Fee.开单部门id,
         r_Fee.开单人, r_Fee.发生时间, d_Sysdate, r_Fee.执行部门id, 0, Null, Null, r_Fee.操作员编号, r_Fee.操作员姓名,
         Decode(v_Counter, 1, '实收重算冲减', ''), 0, Null);
    End If;
  End Loop;

  If v_Counter = 0 Then
    v_Error := '由于以下原因之一,没有进行费用重算:' || Chr(13) || Chr(13) || 'a.没有发现病人本次住院的未结费用.' || Chr(13) || 'b.所有未结费用已进行了费用重算.' ||
               Chr(13) || 'c.按当前费别重算的实收冲减金额都为零.';
    Raise Err_Custom;
  Else
    --病人余额
    n_实收金额 := 0;
    Select Sum(实收金额)
    Into n_实收金额
    From 门诊费用记录
    Where 病人id = 病人id_In And 记录性质 = 2 And Nvl(门诊标志, 0) <> 4 And 登记时间 = d_Sysdate;
    Update 病人余额 Set 费用余额 = Nvl(费用余额, 0) + n_实收金额 Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1;
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 性质, 费用余额, 预交余额, 类型) Values (病人id_In, 1, n_实收金额, 0, 1);
    End If;
  
    --病人未结费用
    For r_Fee In (Select Null As 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, Sum(实收金额) 实收金额
                  From 门诊费用记录
                  Where 病人id = 病人id_In And 记录性质 = 2 And 登记时间 = d_Sysdate
                  Group By 病人科室id, 开单部门id, 执行部门id, 收入项目id) Loop
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) + r_Fee.实收金额
      Where 病人id = 病人id_In And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = Nvl(r_Fee.病人病区id, 0) And
            Nvl(病人科室id, 0) = Nvl(r_Fee.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(r_Fee.开单部门id, 0) And
            Nvl(执行部门id, 0) = Nvl(r_Fee.执行部门id, 0) And 收入项目id + 0 = Nvl(r_Fee.收入项目id, 0) And 来源途径 + 0 = 2;
      If Sql%RowCount = 0 Then
        Insert Into 病人未结费用
          (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
        Values
          (病人id_In, Null, r_Fee.病人病区id, r_Fee.病人科室id, r_Fee.开单部门id, r_Fee.执行部门id, r_Fee.收入项目id, 2, r_Fee.实收金额);
      End If;
    End Loop;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人未结门诊费用_Recalc;
/

--92527:刘尔旋,2016-01-14,费别重算后病人余额问题
Create Or Replace Procedure Zl_病人未结费用_Recalc
(
  病人id_In 住院费用记录.病人id%Type,
  主页id_In 住院费用记录.主页id%Type
) As
  v_费别     费别.名称%Type;
  v_No       住院费用记录.No%Type;
  n_实收金额 住院费用记录.实收金额%Type;
  n_费用余额 病人余额.费用余额%Type;
  n_小数位数 Number(2);
  v_Counter  Number(5);
  d_Sysdate  Date;
  v_Thisinfo Varchar(100);
  v_Lastinfo Varchar(100);

  Err_Custom Exception;
  v_Error Varchar2(255);
Begin
  Select 费别 Into v_费别 From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;

  --条件判断
  --a.当前不是按主从项汇总计算折扣模式
  v_Counter := To_Number(Nvl(zl_GetSysParameter(93), 0));
  If v_Counter = 1 Then
    v_Error := '当前费别使用主从项汇总计算折扣模式,不支持费用重算!';
    Raise Err_Custom;
  End If;

  --b.当前费别不是使用药品按成本价加收打折的费别
  v_Counter := 0;
  Select Count(费别) Into v_Counter From 费别明细 Where 费别 = v_费别 And 计算方法 = 1;
  If v_Counter > 0 Then
    v_Error := '当前费别使用药品按成本价加收打折模式,不支持费用重算!';
    Raise Err_Custom;
  End If;

  --c.没有未结费用
  Begin
    Select 费用余额 Into n_费用余额 From 病人余额 Where 病人id = 病人id_In And 类型 = 2 And 性质 = 1;
  Exception
    When Others Then
      n_费用余额 := 0;
  End;
  --可能有未结费用，但不是本次住院发生的，在后面执行时再判断本次是否有未结明细
  If n_费用余额 = 0 Then
    v_Counter := 0;
    --费用余额为0时，也可能有费用（所有费用都不收费）
    Select Count(ID) Into v_Counter From 住院费用记录 Where 病人id = 病人id_In And 主页id = 主页id_In And Rownum < 2;
    If v_Counter = 0 Then
      v_Error := '病人不存在未结费用,不用进行费用重算!';
      Raise Err_Custom;
    End If;
  End If;

  --d.不存在与本次住院费别不同的费用明细
  v_Counter := 0;
  Select Count(ID) Into v_Counter From 住院费用记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 费别 <> v_费别;
  If v_Counter = 0 Then
    v_Error := '病人不存在与本次住院费别不同的费用明细 ,不用进行费用重算!';
    Raise Err_Custom;
  End If;

  --执行
  v_Counter  := 0;
  d_Sysdate  := Sysdate;
  n_小数位数 := To_Number(Nvl(zl_GetSysParameter(9), 2));
  For r_Fee In (Select 病人id, 主页id, 门诊标志, 记帐费用, 姓名, 性别, 年龄, 标识号, 床号, 病人病区id, 病人科室id, 收费类别, 收费细目id, 计算单位, 加班标志, 附加标志, 婴儿费,
                       收入项目id, 收据费目, 开单部门id, 开单人, 执行部门id, 发生时间, 操作员编号, 操作员姓名, 医疗小组id, Nvl(Sum(应收金额), 0) 应收金额,
                       Nvl(Sum(实收金额), 0) 实收金额
                From (Select ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 记帐单id, 病人id, 主页id, 医嘱序号, 门诊标志, 记帐费用, 姓名, 性别,
                              年龄, 标识号, 床号, 病人病区id, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id,
                              收据费目, 标准单价, 应收金额, 实收金额, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 执行状态, 执行时间, 结论, 操作员编号,
                              操作员姓名, 结帐id, 结帐金额, 保险大类id, 保险项目否, 保险编码, 费用类型, 统筹金额, 是否上传, 摘要, 是否急诊, 医疗小组id
                       From 住院费用记录
                       Union All
                       Select ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 记帐单id, 病人id, 主页id, 医嘱序号, 门诊标志, 记帐费用, 姓名, 性别,
                              年龄, 标识号, 床号, 病人病区id, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id,
                              收据费目, 标准单价, 应收金额, 实收金额, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 执行状态, 执行时间, 结论, 操作员编号,
                              操作员姓名, 结帐id, 结帐金额, 保险大类id, 保险项目否, 保险编码, 费用类型, 统筹金额, 是否上传, 摘要, 是否急诊, 医疗小组id
                       From H住院费用记录)
                Where 病人id = 病人id_In And 主页id = 主页id_In And 记录状态 <> 0 And 记帐费用 = 1
                Group By 病人id, 主页id, 门诊标志, 记帐费用, 姓名, 性别, 年龄, 标识号, 床号, 病人病区id, 病人科室id, 收费类别, 收费细目id, 计算单位, 加班标志, 附加标志, 婴儿费,
                         收入项目id, 收据费目, 开单部门id, 开单人, 执行部门id, 发生时间, 操作员编号, 操作员姓名, 医疗小组id
                Having(Nvl(Sum(实收金额), 0) <> Nvl(Sum(结帐金额), 0) Or Nvl(Sum(结帐金额), 0) = 0) And Not(Nvl(Sum(应收金额), 0) = 0 And Nvl(Sum(实收金额), 0) = 0)
                Order By 开单部门id, 开单人, 操作员姓名) Loop
    --          包括从未结的费用,费用明细部分结帐,以及结帐后作废,这些记录有可能已转入后备表
    --          1.排开了已全部结帐的记录(Sum(应收金额)=Sum(应收金额))
    --          2.排开了无打折冲减的记帐后已销帐的记录(Sum(应收金额)=0,Sum(应收金额)=0)
    --          3.不排开打折冲减后发生了单据销帐的记录，要将原冲减记录一并汇总重算(Sum(应收金额)=0,Sum(应收金额)<>0)
    --          4.不排开打折冲减后产生的实收和结帐都为零的记录，因为改回原来的费别时，要重算回去
    If r_Fee.应收金额 <> 0 Then
      Begin
        Select 实收金额
        Into n_实收金额
        From (Select Round(r_Fee.应收金额 * Nvl(实收比率, 0) / 100, n_小数位数) 实收金额
               From 费别明细
               Where 收费细目id = r_Fee.收费细目id And 费别 = v_费别 And Abs(r_Fee.应收金额) Between 应收段首值 And 应收段尾值 And Nvl(计算方法, 0) = 0
               Union All
               Select Round(r_Fee.应收金额 * Nvl(实收比率, 0) / 100, n_小数位数) 实收金额
               From 费别明细 A
               Where 收入项目id = r_Fee.收入项目id And 费别 = v_费别 And Abs(r_Fee.应收金额) Between 应收段首值 And 应收段尾值 And Nvl(计算方法, 0) = 0 And
                     Not Exists (Select 1 From 费别明细 B Where b.费别 = a.费别 And b.收费细目id = r_Fee.收费细目id));
      Exception
        When Others Then
          n_实收金额 := r_Fee.应收金额;
      End;
    Else
      n_实收金额 := 0;
    End If;
    --计算用来冲减原实收的差额
    n_实收金额 := -1 * (r_Fee.实收金额 - n_实收金额);
  
    If n_实收金额 <> 0 Then
      --一张单据的开单部门id,开单人,操作员姓名,床号要求相同，如果其中之一变了则产生新单据，如果都没有变，一张单据最多100条明细
      v_Thisinfo := r_Fee.开单部门id || r_Fee.开单人 || r_Fee.操作员姓名 || r_Fee.床号;
      If v_Counter = 0 Or v_Counter = 100 Or v_Thisinfo <> v_Lastinfo Then
        v_No       := Nextno(14);
        v_Counter  := 1;
        v_Lastinfo := v_Thisinfo;
      Else
        v_Counter := v_Counter + 1;
      End If;
    
      Insert Into 住院费用记录
        (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 记帐单id, 门诊标志, 病人id, 主页id, 标识号, 床号, 姓名, 性别, 年龄, 病人病区id, 病人科室id, 费别,
         收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 付数, 数次, 发药窗口, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用,
         划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 结帐id, 结帐金额, 操作员编号, 操作员姓名, 摘要, 是否急诊, 医嘱序号, 医疗小组id)
      Values
        (病人费用记录_Id.Nextval, 2, v_No, 1, v_Counter, Null, Null, 0, Null, r_Fee.门诊标志, r_Fee.病人id, r_Fee.主页id, r_Fee.标识号,
         r_Fee.床号, r_Fee.姓名, r_Fee.性别, r_Fee.年龄, r_Fee.病人病区id, r_Fee.病人科室id, v_费别, r_Fee.收费类别, r_Fee.收费细目id, r_Fee.计算单位,
         Null, Null, 0, 0, Null, r_Fee.加班标志, r_Fee.附加标志, r_Fee.婴儿费, r_Fee.收入项目id, r_Fee.收据费目, 0, 0, n_实收金额, Null, 1,
         Null, r_Fee.开单部门id, r_Fee.开单人, r_Fee.发生时间, d_Sysdate, r_Fee.执行部门id, 0, Null, Null, r_Fee.操作员编号, r_Fee.操作员姓名,
         Decode(v_Counter, 1, '实收重算冲减', ''), 0, Null, r_Fee.医疗小组id);
    End If;
  End Loop;

  If v_Counter = 0 Then
    v_Error := '由于以下原因之一,没有进行费用重算:' || Chr(13) || Chr(13) || 'a.没有发现病人本次住院的未结费用.' || Chr(13) || 'b.所有未结费用已进行了费用重算.' ||
               Chr(13) || 'c.按当前费别重算的实收冲减金额都为零.';
    Raise Err_Custom;
  Else
    --病人余额
    n_实收金额 := 0;
    Select Sum(实收金额)
    Into n_实收金额
    From 住院费用记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 2 And 登记时间 = d_Sysdate;
  
    Update 病人余额 Set 费用余额 = Nvl(费用余额, 0) + n_实收金额 Where 病人id = 病人id_In And 性质 = 1 And 类型 = 2;
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 性质, 费用余额, 预交余额, 类型) Values (病人id_In, 1, n_实收金额, 0, 2);
    End If;
  
    --病人未结费用
    For r_Fee In (Select 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, Sum(实收金额) 实收金额
                  From 住院费用记录
                  Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 2 And 登记时间 = d_Sysdate
                  Group By 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id) Loop
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) + r_Fee.实收金额
      Where 病人id = 病人id_In And Nvl(主页id, 0) = 主页id_In And Nvl(病人病区id, 0) = r_Fee.病人病区id And
            Nvl(病人科室id, 0) = r_Fee.病人科室id And Nvl(开单部门id, 0) = r_Fee.开单部门id And Nvl(执行部门id, 0) = r_Fee.执行部门id And
            收入项目id + 0 = r_Fee.收入项目id And 来源途径 + 0 = 2;
      If Sql%RowCount = 0 Then
        Insert Into 病人未结费用
          (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
        Values
          (病人id_In, 主页id_In, r_Fee.病人病区id, r_Fee.病人科室id, r_Fee.开单部门id, r_Fee.执行部门id, r_Fee.收入项目id, 2, r_Fee.实收金额);
      End If;
    End Loop;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人未结费用_Recalc;
/

--89717:余伟节,2016-01-14,出院后不允许取消完成路径
CREATE OR REPLACE Procedure Zl_病人路径结束_Delete
(
  路径记录id_In 病人临床路径.Id%Type,
  结束类型_In   病人临床路径.状态%Type
) Is
  v_阶段id     病人路径评估.阶段id%Type;
  v_前一阶段id 病人路径评估.阶段id%Type;
  v_日期       病人路径评估.日期%Type;
  v_天数       病人路径评估.天数%Type;

  v_病人id       病人临床路径.病人id%Type;
  v_主页id       病人临床路径.主页id%Type;
  d_登记时间     病人路径评估.登记时间%Type;
  d_出院日期     病案主页.出院日期%Type;
  n_当前阶段id   病人合并路径.当前阶段id%Type;
  v_是否检查出院 Varchar2(20);
  v_Error        Varchar2(255);
  Err_Custom Exception;
Begin
  --出院病人不允许取消完成路径
  Select zl_GetSysParameter('出院后不允许取消完成路径', 1256) Into v_是否检查出院 From Dual;
  If v_是否检查出院 = '1' Then
    Select b.出院日期
    Into d_出院日期
    From 病人临床路径 A, 病案主页 B
    Where a.病人id = b.病人id And a.主页id = b.主页id And a.Id = 路径记录id_In;
    If d_出院日期 Is Not Null Then
      If d_出院日期 <= Sysdate Then
        v_Error := '该病人已经出院,不允许取消完成路径！';
        Raise Err_Custom;
      End If;
    End If;
  End If;
  --
  Select 前一阶段id Into v_阶段id From 病人临床路径 Where ID = 路径记录id_In;
  Select Max(日期), Max(天数)
  Into v_日期, v_天数
  From 病人路径执行
  Where 路径记录id = 路径记录id_In And 阶段id = v_阶段id;

  Select 结束时间 Into d_登记时间 From 病人临床路径 Where ID = 路径记录id_In;

  --如果取消结束登记时间结束的合并路径
  For c_Merge In (Select ID
                  From 病人合并路径
                  Where 结束时间 = d_登记时间 And 首要路径记录id = 路径记录id_In And 结束时间 Is Not Null) Loop
    Select b.合并路径阶段id
    Into n_当前阶段id
    From 病人合并路径评估 B
    Where b.登记时间 = (Select Max(c.登记时间)
                    From 病人合并路径评估 C
                    Where c.路径记录id = b.路径记录id And c.合并路径记录id = b.合并路径记录id) And b.合并路径记录id = c_Merge.Id And
          b.路径记录id = 路径记录id_In;
  
    Update 病人合并路径
    Set 结束时间 = Null, 前一阶段id = n_当前阶段id, 当前阶段id = 前一阶段id
    Where 结束时间 = d_登记时间 And 首要路径记录id = 路径记录id_In And 结束时间 Is Not Null;
  End Loop;

  If 结束类型_In = 3 Then
    --评估结果为变异时自动结束的,取消结束自动取消评估
    Delete 病人路径评估 Where 路径记录id = 路径记录id_In And 阶段id = v_阶段id And 日期 = v_日期;
    Delete 病人路径指标 Where 路径记录id = 路径记录id_In And 阶段id = v_阶段id And 日期 = v_日期;
  End If;

  --b.回退到前一个阶段
  Select Max(阶段id)
  Into v_前一阶段id
  From 病人路径执行
  Where 路径记录id = 路径记录id_In And
        登记时间 = (Select Max(登记时间) From 病人路径执行 Where 路径记录id = 路径记录id_In And 阶段id <> v_阶段id);

  Update 病人临床路径
  Set 结束时间 = Null, 状态 = 1, 前一阶段id = v_前一阶段id, 当前阶段id = v_阶段id, 当前天数 = v_天数
  Where ID = 路径记录id_In
  Returning 病人id, 主页id Into v_病人id, v_主页id;

  --更新病案主页当前路径的状态
  Update 病案主页 Set 路径状态 = 1 Where 病人id = v_病人id And 主页id = v_主页id;

  Delete 病人出径记录 Where 病人id = v_病人id And 主页id = v_主页id;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人路径结束_Delete;
/

--92557:李小东,2016-01-12,相关金额和价格变量类型改成number类型
Create Or Replace Function Zl_Fun_Getprice
(
  药品id_In     In 药品库存.药品id%Type,
  库房id_In     In 药品库存.库房id%Type,
  总出库数量_In In 药品库存.实际数量%Type,
  备货材料_In   In Number := 0,
  备货批次_In   In Number := Null
) Return Varchar2 Is
  ----------------------------------
  --功能：根据传过来的参数返回出库药品、卫材的售价|原售价|成本价|剩余数量，中间用“|”隔断；剩余数量等于0表示数量足够，大于0则表示数量不够
  --规则：
  --      1、循环游标判断总出库数量与游标中每条记录数量是否充足，如果充足就是总数量，不充足挨个遍历直到数量直到遍历完并退出
  --      2、售价计算方式：定价取收费价目表现价，时价取药品库存表中零售价，取到的售价为平均价格
  --      3、成本价计算方式：库房等于0，则表示没有明确库房或者发药分离模式，那么成本价直接取规格里面价格，如果有库房id，则取药品库存表中平均成本价
  --参数：
  --      药品id_In：药品id、卫材id
  --      库房id_In：发药库房
  --      总出库数量_In；总出库数量
  --      备货材料_In：只有高值卫材才需要传入，非0表示是高值卫材
  --      备货材料批次_In：只有高值卫材才需要传入，非空表示是高值卫材的批次
  -----------------------------------
  n_Outmode    Number;
  n_类别       Number;
  n_分批       药品规格.药房分批%Type;
  n_时价       收费项目目录.是否变价%Type;
  v_名称       收费项目目录.名称%Type;
  n_当前单价   收费价目.现价%Type;
  n_标准单价   收费价目.现价%Type;
  n_成本价     药品规格.成本价%Type;
  n_当前成本价 药品规格.成本价%Type;
  n_总金额     Number;
  n_总成本     Number;
  n_总出库数量 药品库存.实际数量%Type;
  n_当前数量   药品库存.实际数量%Type;
  n_数量       药品库存.实际数量%Type;

  Err_Custom Exception;
  v_Error Varchar2(255);

  Cursor c_Stock Is
    Select 库房id, 药品id, 批次, Nvl(可用数量, 0) As 可用数量, Nvl(实际数量, 0) As 实际数量, Nvl(实际金额, 0) As 实际金额, Nvl(实际差价, 0) As 实际差价,
           零售价, Nvl(平均成本价, 0) As 平均成本价
    From 药品库存
    Where 药品id = 药品id_In And 库房id = 库房id_In And 性质 = 1 And
          Decode(备货材料_In, 0, 0, Nvl(批次, 0)) = Decode(备货材料_In, 0, 0, Nvl(备货批次_In, 0)) And
          (Nvl(批次, 0) = 0 Or 效期 Is Null Or 效期 > Trunc(Sysdate))
    Order By Decode(n_Outmode, 1, 效期, Null), Nvl(批次, 0);
Begin
  --药品分批出库方式 
  Select Zl_To_Number(Nvl(Zl_Getsysparameter(150), 0)) Into n_Outmode From Dual;
  --判断是药品还是卫材，0是卫材，1是药品，2是其他
  Select Decode(类别, '4', 0, '5', 1, '6', 1, '7', 1, 2) As 类别 Into n_类别 From 收费项目目录 Where ID = 药品id_In;

  If n_类别 = 2 Then
    --只有药品和卫材才允许取值，其他不允许调用该函数
    Raise Err_Custom;
  End If;
  --取基本信息
  If n_类别 = 0 Then
    --卫材
    Select Nvl(a.在用分批, 0) As 分批, Nvl(b.是否变价, 0), b.名称, c.现价, a.成本价
    Into n_分批, n_时价, v_名称, n_标准单价, n_成本价
    From 材料特性 A, 收费项目目录 B, 收费价目 C
    Where a.材料id = b.Id And b.Id = c.收费细目id And b.Id = 药品id_In And Sysdate Between c.执行日期 And c.终止日期;
  Elsif n_类别 = 1 Then
    --药品
    Select Nvl(a.药房分批, 0) As 分批, Nvl(b.是否变价, 0), b.名称, c.现价, a.成本价
    Into n_分批, n_时价, v_名称, n_标准单价, n_成本价
    From 药品规格 A, 收费项目目录 B, 收费价目 C
    Where a.药品id = b.Id And b.Id = c.收费细目id And b.Id = 药品id_In And Sysdate Between c.执行日期 And c.终止日期;
  End If;

  n_总出库数量 := 总出库数量_In;
  n_总金额     := 0;
  n_总成本     := 0;
  n_数量       := 0;

  If 库房id_In = 0 Then
    --库房id等于0这种不确定库房的情况，随便显示一个价格给用户看
    n_当前成本价 := n_成本价;
    --售价,取售价库房id不为0的情况没有，随便取的一个价格
    n_当前单价 := n_标准单价;
    Return n_当前单价 || '|' || n_当前成本价 || '|' || n_总出库数量;
  End If;

  For r_Stock In c_Stock Loop
    If n_分批 = 1 Or n_时价 = 1 Then
      --对于不分批的时价只可能分解一次,分解不完上面判断了.它分解是为了计算单价. 
      --每次分解取小者,库存不够分解不完在上面判断. 
      If n_总出库数量 <= Nvl(r_Stock.可用数量, 0) Then
        n_当前数量 := n_总出库数量;
      Else
        n_当前数量 := Nvl(r_Stock.可用数量, 0);
      End If;
    
      --售价
      If n_时价 = 1 Then
        If r_Stock.实际数量 <> 0 Then
          n_当前单价 := Nvl(r_Stock.零售价, Nvl(r_Stock.实际金额 / r_Stock.实际数量, 0));
        Else
          n_当前单价 := Nvl(r_Stock.零售价, n_标准单价);
        End If;
      Elsif n_分批 = 1 Then
        n_当前单价 := n_标准单价;
      End If;
    
      --成本价
      n_当前成本价 := r_Stock.平均成本价;
    
    Else
      --定价不分批
      n_当前数量 := n_总出库数量;
      --售价
      n_当前单价 := n_标准单价;
      --成本价
      n_当前成本价 := r_Stock.平均成本价;
    End If;
  
    n_数量       := n_数量 + n_当前数量;
    n_总出库数量 := n_总出库数量 - n_当前数量;
    n_总金额     := n_总金额 + n_当前数量 * n_当前单价;
    n_总成本     := n_总成本 + n_当前数量 * n_当前成本价;
    If n_总出库数量 = 0 Then
      Exit;
    End If;
  End Loop;

  If n_数量 <> 0 Then
    n_当前单价   := n_总金额 / n_数量;
    n_当前成本价 := n_总成本 / n_数量;
  Else
    --无库存价格直接从收费价目取现价和直接从规格表取成本价
    n_当前单价   := n_标准单价;
    n_当前成本价 := n_成本价;
    n_总出库数量 := 总出库数量_In;
  End If;
  Return n_当前单价 || '|' || n_当前成本价 || '|' || n_总出库数量;

Exception
  When Err_Custom Then
    Return Null;
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Fun_Getprice;
/

--94030:胡俊勇,2016-03-16,危机值消息阅读
--92384:胡俊勇,2016-02-24,医嘱待执行消息
--92518:胡俊勇,2016-01-11,传染病阳性结果消息
CREATE OR REPLACE Procedure Zl_业务消息清单_Read
(
  病人id_In     In 业务消息清单.病人id%Type,
  就诊id_In     In 业务消息清单.就诊id%Type,
  类型编码_In   In 业务消息清单.类型编码%Type,
  阅读场合_In   In 业务消息状态.阅读场合%Type,
  阅读人_In     In 业务消息状态.阅读人%Type,
  阅读部门id_In In 业务消息状态.阅读部门id%Type,
  阅读时间_In   In 业务消息状态.阅读时间%Type := Null,
  消息id_In     In 业务消息状态.消息id%Type := Null,
  业务标识_In   In 业务消息清单.业务标识 %Type := Null
) Is
  d_Cur   Date;
  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  If 阅读时间_In Is Null Then
    Select Sysdate Into d_Cur From Dual;
  Else
    d_Cur := 阅读时间_In;
  End If;
  If Nvl(消息id_In, 0) <> 0 Then
    Insert Into 业务消息状态
      (消息id, 阅读场合, 阅读人, 阅读时间, 阅读部门id)
    Values
      (消息id_In, 阅读场合_In, 阅读人_In, d_Cur, 阅读部门id_In);
    Update 业务消息清单 Set 是否已阅 = 1 Where ID = 消息id_In;
  Elsif 业务标识_In Is Not Null Then
    For R In (Select a.Id
              From 业务消息清单 A
              Where a.病人id = 病人id_In And a.就诊id = 就诊id_In And a.类型编码 = 类型编码_In And a.业务标识 = 业务标识_In And
                    Nvl(a.是否已阅, 0) = 0) Loop
      Insert Into 业务消息状态
        (消息id, 阅读场合, 阅读人, 阅读时间, 阅读部门id)
      Values
        (r.Id, 阅读场合_In, 阅读人_In, d_Cur, 阅读部门id_In);
    End Loop;
    Update 业务消息清单
    Set 是否已阅 = 1
    Where 病人id = 病人id_In And 就诊id = 就诊id_In And 类型编码 = 类型编码_In And Nvl(是否已阅, 0) = 0 And 业务标识 = 业务标识_In;
  Elsif 类型编码_In = 'ZLHIS_CIS_034' Then
    --待执行消息特殊处理
    For R In (Select ID
              From 业务消息清单 A, 业务消息提醒部门 B
              Where a.Id = b.消息id And a.病人id = 病人id_In And a.就诊id = 就诊id_In And a.类型编码 = 类型编码_In And Nvl(a.是否已阅, 0) = 0 And
                    b.部门id = 阅读部门id_In
              Group By ID) Loop
      Insert Into 业务消息状态
        (消息id, 阅读场合, 阅读人, 阅读时间, 阅读部门id)
      Values
        (r.Id, 阅读场合_In, 阅读人_In, d_Cur, 阅读部门id_In);
      Update 业务消息清单 Set 是否已阅 = 1 Where ID = r.Id;
    End Loop;
  Else
    For R In (Select a.Id
              From 业务消息清单 A
              Where a.病人id = 病人id_In And a.就诊id = 就诊id_In And a.类型编码 = 类型编码_In And Nvl(a.是否已阅, 0) = 0) Loop
      Insert Into 业务消息状态
        (消息id, 阅读场合, 阅读人, 阅读时间, 阅读部门id)
      Values
        (r.Id, 阅读场合_In, 阅读人_In, d_Cur, 阅读部门id_In);
    End Loop;
    Update 业务消息清单
    Set 是否已阅 = 1
    Where 病人id = 病人id_In And 就诊id = 就诊id_In And 类型编码 = 类型编码_In And Nvl(是否已阅, 0) = 0;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_业务消息清单_Read;
/

--91752:刘鹏飞,2016-01-09,记录签名后新增数据在签名数据错误处理
Create Or Replace Procedure Zl_电子护理记录_Update
(
  病人id_In   In 病人护理记录.病人id%Type,
  主页id_In   In 病人护理记录.主页id%Type,
  婴儿_In     In 病人护理记录.婴儿%Type,
  开始时间_In In 病人护理记录.发生时间%Type, --本记录有效跨度的开始时间 
  结束时间_In In 病人护理记录.发生时间%Type, --本记录有效跨度的终止时间，单独记录为每分钟，体温表为4小时,时间跨度内的相同项目记录要删除 
  记录类型_In In 病人护理内容.记录类型%Type, --护理项目=1，上标说明=2，入出转标记=3，手术日标记=4,签名记录=5,下标说明=6 
  项目序号_In In 病人护理内容.项目序号%Type, --护理项目的序号，非护理项目固定为0 
  记录标记_In In 病人护理内容.记录标记%Type, --记录内容的特殊标志 
  记录内容_In In 病人护理内容.记录内容%Type := Null, --记录内容，如果内容为空，即清除以前的内容 
  体温部位_In In 病人护理内容.体温部位%Type := Null,
  他人记录_In In Number := 1,
  项目首次_In In Number := 1,
  复试合格_In In Number := 0,
  是否说明_In In Number := 0, --是说明,则不填写单位 
  发生时间_In In 病人护理记录.发生时间%Type := Null, --护理记录的发生时间 
  未记说明_In In 病人护理内容.未记说明%Type := Null,	--未记说明
  操作员_IN	  IN 病人护理记录.保存人%Type:=null
) Is
  v_保存人   病人护理记录.保存人%Type;
  v_记录人   病人护理内容.记录人%Type;
  v_记录内容 病人护理内容.记录内容%Type;
  n_护理级别 病人护理记录.护理级别%Type;
  d_结束时间 病人护理记录.发生时间%Type;
  d_发生时间 病人护理记录.发生时间%Type;
  n_记录id   病人护理内容.记录id%Type;
  v_科室id   病人护理记录.科室id%Type;
  v_组号     病人护理内容.记录组号%Type;
  v_活动项目 护理记录项目.项目性质%Type;
  n_项目类型 护理记录项目.项目类型%Type;
  n_项目表示 护理记录项目.项目表示%Type;
  n_开始版本 病人护理内容.开始版本%Type;
  n_当前版本 病人护理内容.开始版本%Type;
  v_Records  Number;
  n_Add      Number;
  --主过程 

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  Begin
    Select p.姓名 Into v_保存人 From 上机人员表 O, 人员表 P Where o.人员id = p.Id And 用户名 = User;
  Exception
    When Others Then
      v_保存人 := User;
  End;
  if 操作员_IN is not null then 
	v_保存人 := 操作员_IN;
  end if ;

  d_发生时间 := 发生时间_In;

  If d_发生时间 Is Null Then
    d_发生时间 := 开始时间_In;
  End If;

  If 结束时间_In Is Null Then
    d_结束时间 := 开始时间_In;
  Else
    d_结束时间 := 结束时间_In;
  End If;

  n_项目类型 := 1;
  Begin
    Select 项目类型, 项目表示, 项目性质
    Into n_项目类型, n_项目表示, v_活动项目
    From 护理记录项目
    Where 项目序号 = 项目序号_In;
  Exception
    When Others Then
      v_活动项目 := 1;
  End;
  --检查病人在本次记录时间跨度内，包含相同记录项目，但发生时间不相同的护理记录，进行清理 
  --------------------------------------------------------------------------------------------------------------------- 
  If (项目首次_In = 1) Or (记录内容_In Is Null And 未记说明_In Is Null) Then
    For r_List In (Select l.Id, Count(*) As 记录数
                   From 病人护理记录 L, 病人护理内容 D
                   Where l.Id = d.记录id And l.病人id = 病人id_In And l.主页id = 主页id_In And Nvl(l.婴儿, 0) = Nvl(婴儿_In, 0) And
                         l.病人来源 = 2 And d.终止版本 Is Null And d.项目序号 = 项目序号_In And d.记录类型 <> 5 And
                         (记录内容_In Is Null And l.发生时间 >= 开始时间_In Or 记录内容_In Is Not Null And l.发生时间 >= 开始时间_In) And
                         l.发生时间 <= d_结束时间
                   Group By l.Id) Loop
      n_当前版本 := 0;
      n_记录id   := r_List.Id;
      Begin
        Select Nvl(开始版本, 1)
        Into n_当前版本
        From 病人护理内容
        Where 记录id = n_记录id And 项目序号 = 项目序号_In And Nvl(记录标记, 0) = 记录标记_In And 记录类型 = 记录类型_In And
              Decode(v_活动项目, 2, Nvl(体温部位, '无'), Nvl(体温部位_In, '无')) = Nvl(体温部位_In, '无') And 终止版本 Is Null;
      Exception
        When Others Then
          n_当前版本 := 0;
      End;
    
      If 记录类型_In = 2 Or 记录类型_In = 6 Then
        Delete 病人护理内容
        Where 记录id = n_记录id And 记录类型 = 记录类型_In And 项目序号 = 项目序号_In And 终止版本 Is Null;
      Else
        If 体温部位_In Is Not Null Then
          Delete 病人护理内容
          Where 记录id = n_记录id And 记录类型 = 记录类型_In And 项目序号 = 项目序号_In And Nvl(体温部位, '无') = Nvl(体温部位_In, '无') And
                Nvl(记录标记, 0) = Nvl(记录标记_In, 0) And 终止版本 Is Null;
        Else
          Delete 病人护理内容
          Where 记录id = n_记录id And 记录类型 = 记录类型_In And 项目序号 = 项目序号_In And Nvl(记录标记, 0) = Nvl(记录标记_In, 0) And 终止版本 Is Null;
        End If;
      End If;
    
      --处理版本 
      Update 病人护理内容
      Set 终止版本 = Null
      Where 终止版本 = n_当前版本 And 记录id = n_记录id And 项目序号 = 项目序号_In And 记录类型 = 记录类型_In And Nvl(记录标记, 0) = 记录标记_In And
            Decode(v_活动项目, 2, Nvl(体温部位, '无'), Nvl(体温部位_In, '无')) = Nvl(体温部位_In, '无');
    
      --检查是否还存在上次签名后修改的记录,如果不存在,则将签名记录的终止版本清为空 
      Begin
        Select 1
        Into v_Records
        From 病人护理内容
        Where 终止版本 = n_当前版本 And 记录id = n_记录id And 记录类型 <> 5 And Rownum < 2;
      Exception
        When Others Then
          v_Records := 0;
      End;
    
      If v_Records = 0 Then
        Update 病人护理内容 Set 终止版本 = Null Where 终止版本 = n_当前版本 And 记录类型 = 5 And 记录id = n_记录id;
      End If;
    
      Update 病人护理记录
      Set 最后版本 = 最后版本 - 1
      Where ID = n_记录id And 最后版本 Not In (Select 终止版本 From 病人护理内容 Where 记录类型 <> 5 And 记录id = n_记录id);
    
      Delete From 病人护理内容
      Where 记录id = n_记录id And 记录类型 = 5 And
            Nvl(开始版本, 1) Not In
            (Select Nvl(开始版本, 1) From 病人护理内容 A Where a.记录类型 <> 5 And a.记录id = n_记录id);
    
      Delete From 病人护理记录 A
      Where a.Id = n_记录id And Not Exists (Select 1 From 病人护理内容 B Where b.记录id = a.Id);
    End Loop;
  End If;

  If 记录内容_In Is Null And 未记说明_In Is Null Then
    Return;
  End If;
  --------------------------------------------------------------------------------------------------------------------- 
  n_记录id := 0;
  Begin
    Select ID
    Into n_记录id
    From 病人护理记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = Nvl(婴儿_In, 0) And 病人来源 = 2 And 发生时间 = d_发生时间 And
          Rownum < 2;
  Exception
    When Others Then
      n_记录id := 0;
  End;

  n_护理级别 := Zl_Patittendgrade(病人id_In, 主页id_In, 开始时间_In);

  --------------------------------------------------------------------------------------------------------------------- 
  v_科室id := 0;
  Begin
    Select 科室id
    Into v_科室id
    From 病人变动记录
    Where 科室id Is Not Null And 病人id = 病人id_In And 主页id = 主页id_In And
          (开始时间 Between 开始时间_In And d_结束时间 Or 开始时间 <= 开始时间_In) And (开始时间_In <= 终止时间 Or 终止时间 Is Null) And Rownum < 2;
  Exception
    When Others Then
      v_科室id := 0;
  End;
  If v_科室id = 0 Then
    v_Error := '在' || To_Char(开始时间_In, 'yyyy-mm-dd hh24:mi:ss') || '至' || To_Char(d_结束时间, 'yyyy-mm-dd hh24:mi:ss') ||
               '段内无对应科室，不能操作！';
    Raise Err_Custom;
  End If;

  --确认开始版本号 
  --------------------------------------------------------------------------------------------------------------------- 
  Select Nvl(Max(Nvl(a.开始版本, 1)), 0) + 1
  Into n_开始版本
  From 病人护理内容 A, 病人护理记录 B
  Where b.病人id = 病人id_In And b.主页id = 主页id_In And Nvl(b.婴儿, 0) = Nvl(婴儿_In, 0) And b.病人来源 = 2 And b.发生时间 = d_发生时间 And
        a.记录id = b.Id And a.记录类型 = 5;

  n_当前版本 := n_开始版本;

  --检查是不是本人的记录 
  n_Add      := 1;
  v_记录人   := '';
  v_记录内容 := '';
  Begin
    Select 记录人, 记录内容, Nvl(开始版本, 1)
    Into v_记录人, v_记录内容, n_当前版本
    From 病人护理内容
    Where 记录id = n_记录id And 记录类型 = 记录类型_In And 项目序号 = 项目序号_In And Nvl(记录标记, 0) = Nvl(记录标记_In, 0) And
          Decode(v_活动项目, 2, Nvl(体温部位, '无'), Nvl(体温部位_In, '无')) = Nvl(体温部位_In, '无') And 终止版本 Is Null;
  Exception
    When Others Then
      v_记录人 := '';
      n_Add    := 1;
  End;
  --------------------------------------------------------------------------------------------------------------------- 
  If 他人记录_In = 0 Then
    If v_记录人 Is Not Null And v_记录人 <> v_保存人 Then
      v_Error := '在' || To_Char(开始时间_In, 'yyyy-mm-dd hh24:mi:ss') || '至' || To_Char(d_结束时间, 'yyyy-mm-dd hh24:mi:ss') ||
                 '段内记录人不是当前人，你无权修改！';
      Raise Err_Custom;
    End If;
  End If;
  --改写病人护理记录：如果已经存在与病人、科室和发生时间相同的记录则修改，否则增加新的记录 
  --------------------------------------------------------------------------------------------------------------------- 
  If n_记录id = 0 Then
    Select 病人护理记录_Id.Nextval Into n_记录id From Dual;
    n_Add := 1;
  Else
    If n_项目类型 = 0 And n_项目表示 = 0 Then
      If n_Add = 1 And Zl_To_Number(v_记录内容) = Zl_To_Number(记录内容_In) Then
        n_Add := 0;
      End If;
    Else
      If n_Add = 1 And v_记录内容 = 记录内容_In Then
        n_Add := 0;
      End If;
    End If;
  End If;

  If n_Add = 0 And n_开始版本 > n_当前版本 And n_开始版本 > 1 Then
    n_开始版本 := n_开始版本 - 1;
  End If;

  Update 病人护理记录 Set 保存人 = v_保存人, 保存时间 = Sysdate, 最后版本 = n_开始版本 Where ID = n_记录id;

  If Sql%RowCount = 0 Then
    Insert Into 病人护理记录
      (ID, 病人来源, 病人id, 主页id, 婴儿, 科室id, 护理级别, 发生时间, 保存人, 保存时间, 最后版本)
    Values
      (n_记录id, 2, 病人id_In, 主页id_In, 婴儿_In, v_科室id, n_护理级别, d_发生时间, v_保存人, Sysdate, n_开始版本);
  End If;

  --处理版本问题 
  --------------------------------------------------------------------------------------------------------------------- 
  Update 病人护理内容
  Set 终止版本 = n_开始版本, 开始版本 = Nvl(开始版本, 1)
  Where 记录id = n_记录id And 记录类型 = 5 And 终止版本 Is Null And n_Add = 1;

  If 记录类型_In = 1 Then
    Update 病人护理内容
    Set 终止版本 = n_开始版本, 开始版本 = Nvl(开始版本, 1)
    Where 记录id = n_记录id And 记录类型 = 记录类型_In And 项目序号 = 项目序号_In And 终止版本 Is Null And n_Add = 1 And
          Decode(v_活动项目, 2, Nvl(体温部位, '无'), Nvl(体温部位_In, '无')) = Nvl(体温部位_In, '无') And Nvl(开始版本, 1) <> n_开始版本;
  Else
    Update 病人护理内容
    Set 终止版本 = n_开始版本, 开始版本 = Nvl(开始版本, 1)
    Where 记录id = n_记录id And 记录类型 = 记录类型_In And n_Add = 1 And
          项目名称 = Decode(记录类型_In, 2, '上标说明', 6, '下标说明', 3, '入出转', 4, 记录内容_In) And 终止版本 Is Null And
          Nvl(开始版本, 1) <> n_开始版本;
  End If;

  --删除已经登记的该区间的病人护理内容 
  --------------------------------------------------------------------------------------------------------------------- 
  If 记录类型_In = 2 Or 记录类型_In = 6 Then
    Delete 病人护理内容
    Where 记录id = n_记录id And 记录类型 = 记录类型_In And 项目序号 = 项目序号_In And 终止版本 Is Null;
  Else
    Delete 病人护理内容
    Where 记录id = n_记录id And 记录类型 = 记录类型_In And 项目序号 = 项目序号_In And
          Decode(v_活动项目, 2, Nvl(体温部位, '无'), Nvl(体温部位_In, '无')) = Nvl(体温部位_In, '无') And Nvl(记录标记, 0) = Nvl(记录标记_In, 0) And
          终止版本 Is Null;
  End If;

  --插入本次登记的病人护理内容 
  If 记录类型_In = 1 Then
    --如果是活动项目则根据当前记录的项目序号,取最大组号(活动项目存在不同部位的数据,需要自动更新组号以便保存多条数据) 
    v_组号 := 1;
    If v_活动项目 = 2 Then
      Begin
        Select Nvl(Max(记录组号), 0) + 1
        Into v_组号
        From 病人护理内容
        Where 记录id = n_记录id And 项目序号 = 项目序号_In;
      Exception
        When Others Then
          v_组号 := 1;
      End;
    End If;
  
    Insert Into 病人护理内容
      (ID, 记录id, 记录类型, 项目分组, 项目id, 项目序号, 项目名称, 项目类型, 记录内容, 项目单位, 记录标记, 记录人, 体温部位, 复试合格, 开始版本, 终止版本, 记录组号, 未记说明)
      Select 病人护理内容_Id.Nextval, n_记录id, 记录类型_In, 分组名, 项目id, 项目序号, 项目名称, 项目类型, 记录内容_In, Decode(是否说明_In, 1, Null, 项目单位),
             记录标记_In, v_保存人, 体温部位_In, 复试合格_In, n_开始版本, Null, v_组号, 未记说明_In
      From 护理记录项目
      Where 项目序号 = 项目序号_In;
  Else
    Insert Into 病人护理内容
      (ID, 记录id, 记录类型, 项目分组, 项目id, 项目序号, 项目名称, 项目类型, 记录内容, 项目单位, 记录标记, 记录人, 体温部位, 复试合格, 开始版本, 终止版本, 记录组号, 未记说明)
    Values
      (病人护理内容_Id.Nextval, n_记录id, 记录类型_In, Null, Null, 0, Decode(记录类型_In, 2, '上标说明', 6, '下标说明', 3, '入出转', 4, 记录内容_In),
       Decode(记录类型_In, 3, 0, 1), Decode(记录类型_In, 4, '1', 记录内容_In), '', 记录标记_In, v_保存人, 体温部位_In, 复试合格_In, n_开始版本, Null, 1,
       未记说明_In);
  End If;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_电子护理记录_Update;
/

--93606:冉俊明,2016-02-25,医保病人部分退费时重结费用的误差费的记录状态填为了2，应该是1
--92457:冉俊明,2016-01-08,在完成收费、退费时对实收金额和结算金额进行检查。
Create Or Replace Procedure Zl_门诊退费结算_Modify
(
  操作类型_In      Number,
  病人id_In        门诊费用记录.病人id%Type,
  冲销id_In        病人预交记录.结帐id%Type,
  结算方式_In      Varchar2,
  冲预交_In        病人预交记录.冲预交%Type := Null,
  卡类别id_In      病人预交记录.卡类别id%Type := Null,
  卡号_In          病人预交记录.卡号%Type := Null,
  交易流水号_In    病人预交记录.交易流水号%Type := Null,
  交易说明_In      病人预交记录.交易说明%Type := Null,
  缴款_In          病人预交记录.缴款%Type := Null,
  找补_In          病人预交记录.找补%Type := Null,
  误差金额_In      门诊费用记录.实收金额%Type := Null,
  完成退费_In      Number := 0,
  原结帐id_In      病人预交记录.结帐id%Type := Null,
  剩余转预交_In    Number := 0,
  缺省结算方式_In  结算方式.名称%Type := Null,
  冲预交病人ids_In Varchar2 := Null
) As
  ------------------------------------------------------------------------------------------------------------------------------
  --功能:收费结算时,修改结算的相关信息
  --操作类型_In:
  --   0-原样退
  --      原样结算一起全退,所有校对标志都为1,医保调用成功后,调整为2,完成后变成0
  --   1-普通退费方式:
  --     ①结算方式_IN:允许传入多个,格式为:"结算方式|结算金额|结算号码|结算摘要||.." ;也允许传入空.
  --   2.三方卡退费结算:
  --     ①结算方式_IN:只能传入一个结算方式,但允许包含一些辅助信息,格式为:"结算方式|结算金额|结算号码|结算摘要"
  --     ②卡类别ID_IN,卡号_IN,交易流水号_IN,交易说明_In:需要传入
  --   3-医保结算(如果存在医保的结算,则要先删除原医保结算,后按新传入的更新)
  --     ①结算方式_IN:允许传入多个,格式为:结算方式|结算金额||.."
  --     ②退支票额_In:传入零
  --   4-消费卡结算:
  --     ①结算方式_IN:允许一次刷多张卡,格式为:卡类别ID|卡号|消费卡ID|消费金额||."
  --     ②退支票额_In:传入零

  -- 冲预交_In:如果涉及预交款,则传入本次的退预交 传入零<0时 表示退预交款或充值;>0 时:表示冲预交款
  -- 剩余转预交_In: 1表示将剩余退款额转换为充值金额;0表示退预交
  -- 误差金额_In:存在误差费时,传入
  -- 完成退费_In:0-未完成退费;1-异常完成退费;2-完成退费
  -- 原结帐ID_IN:原样退时,传入(如果原样退未传入时,则以最后一次结帐为准)
  -- 冲预交病人ids_In:多个用逗分分离,冲预交时有效(冲预交类别与业务操作保持一致),主要是使用家属的预交款
  ------------------------------------------------------------------------------------------------------------------------------
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_结算内容 Varchar2(500);
  v_当前结算 Varchar2(50);
  v_卡号     病人医疗卡信息.卡号%Type;
  n_消费卡id 消费卡目录.Id%Type;
  n_卡类别id 病人预交记录.结算卡序号%Type;
  v_名称     Varchar2(100);
  n_自制卡   卡消费接口目录.自制卡%Type;
  n_序号     病人卡结算记录.序号%Type;
  n_Id       病人卡结算记录.Id%Type;
  n_预交id   病人预交记录.Id%Type;
  v_结算方式 病人预交记录.结算方式%Type;
  n_结算金额 病人预交记录.冲预交%Type;
  n_返回值   人员缴款余额.余额%Type;
  n_预交金额 病人预交记录.冲预交%Type;
  n_冲预交   病人预交记录.冲预交%Type;
  v_结算号码 病人预交记录.结算号码%Type;
  v_结算摘要 病人预交记录.摘要%Type;
  v_误差费   结算方式.名称%Type;
  n_记录状态 病人预交记录.记录状态%Type;

  v_退费结算 结算方式.名称%Type;
  v_No       病人预交记录.No%Type;
  n_Dec      Number; --金额小数位数 

  n_Count         Number;
  n_Havenull      Number;
  l_预交id        t_Numlist := t_Numlist();
  n_原结帐id      病人预交记录.结帐id%Type;
  n_重结id        病人预交记录.结帐id%Type;
  n_结帐id        病人预交记录.结帐id%Type;
  n_结算序号      病人预交记录.结帐id%Type;
  v_冲预交病人ids Varchar2(4000);
  v_Msg           Varchar2(500);

  Cursor c_Feedata Is
    Select Max(NO) As NO, Max(m.病人id) As 病人id, Max(m.登记时间) As 登记时间, Max(m.操作员编号) As 操作员编号, Max(m.操作员姓名) As 操作员姓名,
           Sum(结帐金额) As 结算金额, Max(m.缴款组id) As 缴款组id
    From 门诊费用记录 M
    Where m.结帐id = 冲销id_In;
  r_Feedata c_Feedata%RowType;

  Cursor c_Balancedata Is
    Select 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号
    From 病人预交记录
    Where 结帐id = 冲销id_In And 结算方式 Is Null;
  r_Balancedata c_Balancedata%RowType;

  Procedure Zl_Square_Update
  (
    原结帐id_In 病人预交记录.结帐id%Type,
    现结帐id_In 病人预交记录.结帐id%Type,
    缴款组id_In 病人预交记录.缴款组id%Type,
    退款时间_In 病人预交记录.收款时间%Type,
    结算序号_In 病人预交记录.结算序号%Type,
    结算内容_In Varchar2 := Null
  ) As
    n_记录状态 病人卡结算记录.记录状态%Type;
    n_预交id   病人预交记录.Id%Type;
    v_卡号     病人卡结算记录.卡号%Type;
    n_存在卡片 Number;
    d_停用日期 消费卡目录.停用日期%Type;
    n_最大序号 病人卡结算记录.序号%Type;
    n_序号     病人卡结算记录.序号%Type;
    n_余额     消费卡目录.余额%Type;
    n_接口编号 病人卡结算记录.接口编号%Type;
    d_回收时间 消费卡目录.回收时间%Type;
    n_Id       病人预交记录.Id%Type;
  Begin
    n_预交id := 0;
  
    --处理消费卡,结算卡在上面就已经处理了
    For v_校对 In (Select a.Id As 预交id, c.消费卡id, c.结算金额, c.接口编号, c.卡号, c.序号, c.Id
                 From 病人预交记录 A, 病人卡结算对照 B, 病人卡结算记录 C
                 Where a.Id = b.预交id And b.卡结算id = c.Id And a.记录性质 = 3 And a.记录状态 In (1, 3) And
                       Instr(Nvl(结算内容_In, '_LXH'), ',' || a.结算方式 || ',') = 0 And a.结帐id = 原结帐id_In) Loop
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id = Nvl(v_校对.消费卡id, 0) And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      Else
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id Is Null And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      End If;
    
      If n_记录状态 = 1 Then
        n_记录状态 := 2;
      Else
        n_记录状态 := n_记录状态 + 2;
      End If;
      --多条时,只更新一条
      If n_预交id = 0 Then
        Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id,
           预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
          Select n_预交id, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, 退款时间_In, 缴款单位, 单位开户行, 单位帐号, r_Balancedata.操作员编号,
                 r_Balancedata.操作员姓名, -1 * 冲预交, 现结帐id_In, 缴款组id_In, 预交类别, 卡类别id, Nvl(结算卡序号, v_校对.接口编号), 卡号, 交易流水号, 交易说明,
                 合作单位, 2, 结算序号_In, Mod(记录性质, 10)
          From 病人预交记录 A
          Where ID = v_校对.预交id;
      End If;
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        --消费卡,直接退回卡数据中
        Begin
          Select 卡号, 1, 停用日期, (Select Max(序号) From 消费卡目录 B Where a.卡号 = b.卡号 And a.接口编号 = b.接口编号), 序号, 余额, 接口编号, 回收时间
          Into v_卡号, n_存在卡片, d_停用日期, n_最大序号, n_序号, n_余额, n_接口编号, d_回收时间
          From 消费卡目录 A
          Where ID = v_校对.消费卡id;
        Exception
          When Others Then
            n_存在卡片 := 0;
        End;
      
        --取消停用
        If n_存在卡片 = 0 Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡被他人删除，不能再启用该卡片,请检查！';
          Raise Err_Item;
        End If;
        If Nvl(n_序号, 0) < Nvl(n_最大序号, 0) Then
          v_Err_Msg := '不能启用历史发卡记录(卡号为"' || v_卡号 || '"),请检查！';
          Raise Err_Item;
        End If;
        If Nvl(d_停用日期, To_Date('3000-01-01', 'yyyy-mm-dd')) < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经被他人停用，不能再进行退费,请检查！';
          Raise Err_Item;
        End If;
      
        If d_回收时间 < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经回收，不能退费,请检查！';
          Raise Err_Item;
        End If;
        Update 消费卡目录 Set 余额 = Nvl(余额, 0) + v_校对.结算金额 Where ID = Nvl(v_校对.消费卡id, 0);
      End If;
    
      Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      Insert Into 病人卡结算记录
        (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Select n_Id, 接口编号, 消费卡id, 序号, n_记录状态, 结算方式, -1 * v_校对.结算金额, 卡号, 交易流水号, 交易时间, 备注,
               Decode(消费卡id, Null, 0, 0, 0, 1) As 标志
        From 病人卡结算记录
        Where ID = v_校对.Id;
      Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
    
      If n_记录状态 <> 2 And n_记录状态 <> 1 Then
        Update 病人卡结算记录 Set 记录状态 = 3 Where ID = v_校对.Id;
      End If;
    End Loop;
  End;

Begin
  v_冲预交病人ids := Nvl(冲预交病人ids_In, 病人id_In);

  Begin
    Select 名称 Into v_退费结算 From 结算方式 Where 性质 = 1;
  Exception
    When Others Then
      v_退费结算 := '现金';
  End;

  Open c_Feedata;
  Fetch c_Feedata
    Into r_Feedata;

  If r_Feedata.No Is Null Then
    v_Err_Msg := '未找到指定的退费记录！';
    Raise Err_Item;
  End If;

  --金额小数位数 
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into n_Dec From Dual;

  --0.正式结算
  Select Count(1), Max(Decode(结算方式, Null, 1, 0)), Max(结算序号)
  Into n_Count, n_Havenull, n_结算序号
  From 病人预交记录
  Where 结帐id = 冲销id_In;

  If Nvl(n_Count, 0) = 0 Or Nvl(误差金额_In, 0) <> 0 Then
    --增加结算方式为NULL的记录
    Begin
      Select 名称 Into v_误差费 From 结算方式 Where Nvl(性质, 0) = 9;
    Exception
      When Others Then
        v_误差费 := '误差费';
    End;
  End If;

  --1.增加结算方式为空的结算数据
  If Nvl(n_Havenull, 0) = 0 Then
    n_Count := 0;
    Begin
      n_结算金额 := Round(Nvl(r_Feedata.结算金额, 0), n_Dec);
    
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 2, Decode(病人id_In, 0, Null, 病人id_In), Null, r_Feedata.登记时间, r_Feedata.操作员编号,
         r_Feedata.操作员姓名, n_结算金额, 冲销id_In, r_Feedata.缴款组id, -1 * 冲销id_In, 1, 3);
      --误差费(先汇总后生成误差费
      If n_结算金额 <> Nvl(r_Feedata.结算金额, 0) Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, Decode(病人id_In, 0, Null, 病人id_In), v_误差费, r_Feedata.登记时间, r_Feedata.操作员编号,
           r_Feedata.操作员姓名, Nvl(r_Feedata.结算金额, 0) - n_结算金额, 冲销id_In, r_Feedata.缴款组id, -1 * 冲销id_In, 1, 3);
      End If;
      n_结算序号 := -1 * 冲销id_In;
    Exception
      When Others Then
        n_Count := 1;
    End;
    If n_Count = 1 Then
      v_Err_Msg := '未找到指定的退费明细数据,结算操作失败！';
      Raise Err_Item;
    End If;
  End If;

  Open c_Balancedata;
  Fetch c_Balancedata
    Into r_Balancedata;

  If 操作类型_In = 0 Then
    --0.原样退
    n_原结帐id := 原结帐id_In;
    If Nvl(n_原结帐id, 0) = 0 Then
      Select Max(结帐id)
      Into n_原结帐id
      From 门诊费用记录 A,
           (Select 登记时间 From 门诊费用记录 Where NO = r_Feedata.No And Mod(记录性质, 10) = 1 And 记录状态 In (1, 3)) B
      Where a.No = r_Feedata.No And Mod(a.记录性质, 10) = 1 And a.登记时间 = b.登记时间;
    End If;
    If Nvl(n_原结帐id, 0) = 0 Then
      v_Err_Msg := '未找到原结帐数据,不能原样退！';
      Raise Err_Item;
    End If;
  
    --1.先处理预交款
    For v_退预交 In (Select a.Id, a.病人id, Nvl(a.冲预交, 0) As 金额
                  From 病人预交记录 A
                  Where Mod(记录性质, 10) = 1 And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0
                  Order By 收款时间 Desc) Loop
    
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
         卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 结算性质)
        Select 病人预交记录_Id.Nextval, 11, NO, 实际票号, 记录状态, 病人id, Null, 摘要, 结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
               r_Balancedata.操作员姓名, -1 * v_退预交.金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
               Null, 卡号, 交易流水号, 交易说明, Null, 预交类别, 3
        From 病人预交记录
        Where ID = v_退预交.Id;
    
      --更新病人余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + v_退预交.金额
      Where 病人id = v_退预交.病人id And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (v_退预交.病人id, 1, v_退预交.金额, 1);
        n_返回值 := (-1 * v_退预交.金额);
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = v_退预交.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      Update 病人预交记录 Set 冲预交 = 冲预交 - v_退预交.金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
        Raise Err_Item;
      End If;
    End Loop;
  
    --2.处理消费卡部分
    Zl_Square_Update(n_原结帐id, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.收款时间, r_Balancedata.结算序号, v_结算内容);
    --3.处理其他结算部分
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号,
       交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
      Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, r_Balancedata.收款时间, r_Balancedata.操作员编号,
             r_Balancedata.操作员姓名, -1 * 冲预交, r_Balancedata.结帐id, r_Balancedata.缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
             合作单位,
             Case
               When Nvl(a.卡类别id, 0) <> 0 Then
                1
               When Nvl(a.结算卡序号, 0) <> 0 Then
                1
               When Nvl(q.预交id, 0) <> 0 Then
                1
               When Nvl(j.名称, '-') <> '-' Then
               --医保
                1
               Else
                2
             End As 校对标志, r_Balancedata.结算序号, Mod(记录性质, 10)
      From 病人预交记录 A, (Select 名称 From 结算方式 Where 性质 In (3, 4)) J,
           (Select m.Id As 预交id
             From 病人预交记录 M, 一卡通目录 C
             Where m.结帐id = n_原结帐id And m.结算方式 = c.结算方式 And m.记录性质 = 3 And m.记录状态 In (1, 3)) Q
      Where Mod(a.记录性质, 10) <> 1 And a.记录状态 In (1, 3) And a.结算方式 = j.名称(+) And a.结算方式 Is Not Null And a.结帐id = n_原结帐id And
            a.Id = q.预交id(+) And (Not Exists (Select 1 From 病人卡结算对照 Where a.Id = 预交id) Or Nvl(结算卡序号, 0) = 0);
  
    --更新结算方式为NULL 的记录
    Select Sum(冲预交) Into n_返回值 From 病人预交记录 Where 结帐id = r_Balancedata.结帐id And 结算方式 Is Not Null;
    Select Sum(结帐金额)
    Into n_结算金额
    From 门诊费用记录
    Where 结帐id = r_Balancedata.结帐id And Mod(记录性质, 10) = 1;
  
    Update 病人预交记录
    Set 冲预交 = Nvl(n_结算金额, 0) - Nvl(n_返回值, 0)
    Where 结帐id = 冲销id_In And 结算方式 Is Null;
    If Sql%NotFound Then
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
      Raise Err_Item;
    End If;
  
  End If;

  n_重结id := 0;
  If 操作类型_In <> 0 Then
    --不是全退时,检查是否产生了重新收费数据的
    Begin
      Select 结帐id Into n_重结id From 病人预交记录 Where 结算序号 = n_结算序号 And 结帐id <> 冲销id_In And Rownum < 2;
    Exception
      When Others Then
        n_重结id := 0;
    End;
  End If;

  --需要处理误差金额
  If Nvl(误差金额_In, 0) <> 0 Then
    --误差费放在重收的结算记录中
    n_结帐id   := 冲销id_In;
    n_记录状态 := 2;
    If Nvl(n_重结id, 0) <> 0 Then
      n_结帐id   := n_重结id;
      n_记录状态 := 1;
    End If;
  
    Update 病人预交记录
    Set 冲预交 = Nvl(冲预交, 0) + Nvl(误差金额_In, 0)
    Where 结帐id = n_结帐id And 结算方式 = v_误差费;
    If Sql%NotFound Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 3, Null, n_记录状态, r_Balancedata.病人id, Null, Null, v_误差费, r_Balancedata.收款时间,
         r_Balancedata.操作员编号, r_Balancedata.操作员姓名, 误差金额_In, n_结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
         Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3);
    End If;
  
    Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(误差金额_In, 0) Where 结帐id = n_结帐id And 结算方式 Is Null;
    If Sql%NotFound Then
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
      Raise Err_Item;
    End If;
  End If;

  --预交款处理:如果是冲预交,需要先处理冲预交款
  If Nvl(冲预交_In, 0) <> 0 Then
    If Nvl(r_Balancedata.病人id, 0) = 0 Then
      v_Err_Msg := '不能确定病人信息,不能使用预交款结算！';
      Raise Err_Item;
    End If;
  
    n_预交金额 := 冲预交_In;
    If n_预交金额 < 0 And Nvl(剩余转预交_In, 0) = 1 Then
    
      --     ②冲预交_In:如果涉及预交款,则传入本次的退预交 传入零<0时 表示退预交款或充值;>0 时:表示冲预交款
      --     ③剩余转预交_In: 1表示将剩余退款额转换为充值金额;0表示退预交
    
      --1.先生成冲值预交:
      v_No := Nextno(11);
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 金额, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 预交类别, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 1, v_No, 1, r_Balancedata.病人id, Null, '退费生成预交', v_退费结算, r_Balancedata.收款时间,
         r_Balancedata.操作员编号, r_Balancedata.操作员姓名, -1 * n_预交金额, r_Balancedata.结帐id, r_Balancedata.缴款组id,
         r_Balancedata.结算序号, 0, Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 1, Null);
    
      --更新病人余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + (-1 * n_预交金额)
      Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (病人id_In, 1, -1 * n_预交金额, 1);
        n_返回值 := -1 * n_预交金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Balancedata.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --2.生成退费记录
      If Nvl(n_重结id, 0) <> 0 Then
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
        If Nvl(n_返回值, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 结算号码, 结算性质)
          Values
            (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_退费结算, r_Balancedata.收款时间,
             r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_返回值, 冲销id_In, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
             Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3);
        
          Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
        End If;
        n_结算金额 := n_结算金额 - Nvl(n_返回值, 0);
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, v_结算摘要, v_退费结算, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, n_重结id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
           Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3);
        Update 病人预交记录 Set 冲预交 = 冲预交 + n_预交金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
        If Sql%NotFound Then
          v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
          Raise Err_Item;
        End If;
      Else
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, -1 * n_预交金额, r_Balancedata.结帐id, r_Balancedata.缴款组id,
           r_Balancedata.结算序号, 2, Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3);
        Update 病人预交记录 Set 冲预交 = 冲预交 + n_预交金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
        If Sql%NotFound Then
          v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  
    If Nvl(n_预交金额, 0) < 0 And Nvl(剩余转预交_In, 0) = 0 Then
      n_原结帐id := 原结帐id_In;
      If Nvl(n_原结帐id, 0) = 0 Then
        Select Max(b.结帐id)
        Into n_原结帐id
        From 门诊费用记录 A, 门诊费用记录 B
        Where a.结帐id = 冲销id_In And a.No = b.No And b.记录性质 = 1 And b.记录状态 In (1, 3);
      End If;
    
      If Nvl(n_原结帐id, 0) = 0 Then
        v_Err_Msg := '未找到原结帐数据,不能原样退！';
        Raise Err_Item;
      End If;
      If Nvl(n_重结id, 0) <> 0 Then
        --1.退预交款
        For v_退预交 In (Select Max(a.Id) As ID, a.病人id, Max(a.收款时间) As 收款时间, Sum(Nvl(a.冲预交, 0)) As 金额
                      From 病人预交记录 A,
                           (Select Distinct a.结帐id
                             From 门诊费用记录 A, 门诊费用记录 B
                             Where a.No = b.No And Mod(b.记录性质, 10) = 1 And b.结帐id = n_原结帐id) B
                      Where a.结帐id = b.结帐id And Mod(a.记录性质, 10) = 1 And Nvl(a.预交类别, 0) = 1
                      Group By NO, 病人id
                      Having Sum(Nvl(a.冲预交, 0)) > 0
                      Order By 收款时间 Desc) Loop
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id,
             结算卡序号, 卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 结算性质)
            Select 病人预交记录_Id.Nextval, 11, NO, 实际票号, 记录状态, 病人id, Null, 摘要, 结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
                   r_Balancedata.操作员姓名, -1 * v_退预交.金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2,
                   Null, Null, 卡号, 交易流水号, 交易说明, Null, 预交类别, 3
            From 病人预交记录
            Where ID = v_退预交.Id;
        
          --更新病人余额
          Update 病人余额
          Set 预交余额 = Nvl(预交余额, 0) + v_退预交.金额
          Where 病人id = v_退预交.病人id And 性质 = 1 And 类型 = 1
          Returning 预交余额 Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (v_退预交.病人id, 1, v_退预交.金额, 1);
            n_返回值 := v_退预交.金额;
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 病人余额
            Where 病人id = v_退预交.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
          End If;
        
          Update 病人预交记录 Set 冲预交 = 冲预交 - (-1 * v_退预交.金额) Where 结帐id = 冲销id_In And 结算方式 Is Null;
          If Sql%NotFound Then
            v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
            Raise Err_Item;
          End If;
          n_预交金额 := n_预交金额 - (-1 * v_退预交.金额);
        End Loop;
      
        --2.冲预交款
        If n_预交金额 <> 0 Then
          For v_退预交 In (Select Max(a.Id) As ID, a.病人id, Max(a.收款时间) As 收款时间, Sum(Nvl(a.冲预交, 0)) As 金额
                        From 病人预交记录 A,
                             (Select Distinct a.结帐id
                               From 门诊费用记录 A, 门诊费用记录 B
                               Where a.No = b.No And Mod(b.记录性质, 10) = 1 And b.结帐id = n_原结帐id) B
                        Where a.结帐id = b.结帐id And Mod(a.记录性质, 10) = 1 And Nvl(a.预交类别, 0) = 1 And a.结帐id <> 冲销id_In
                        Group By NO, 病人id
                        Having Sum(Nvl(a.冲预交, 0)) > 0
                        Order By 收款时间 Desc) Loop
          
            If v_退预交.金额 - n_预交金额 < 0 Then
              n_结算金额 := v_退预交.金额;
              n_预交金额 := n_预交金额 - v_退预交.金额;
            Else
              n_结算金额 := n_预交金额;
              n_预交金额 := 0;
            End If;
          
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id,
               结算卡序号, 卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 结算性质)
              Select 病人预交记录_Id.Nextval, 11, NO, 实际票号, 记录状态, 病人id, Null, 摘要, 结算方式, r_Balancedata.收款时间,
                     r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, n_重结id, r_Balancedata.缴款组id, r_Balancedata.结算序号,
                     2, Null, Null, 卡号, 交易流水号, 交易说明, Null, 预交类别, 3
              From 病人预交记录
              Where ID = v_退预交.Id;
          
            --更新病人余额
            Update 病人余额
            Set 预交余额 = Nvl(预交余额, 0) + (-1 * n_结算金额)
            Where 病人id = v_退预交.病人id And 性质 = 1 And 类型 = 1
            Returning 预交余额 Into n_返回值;
            If Sql%RowCount = 0 Then
              Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (v_退预交.病人id, 1, -1 * n_结算金额, 1);
              n_返回值 := -1 * n_结算金额;
            End If;
            If Nvl(n_返回值, 0) = 0 Then
              Delete From 病人余额
              Where 病人id = v_退预交.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
            End If;
          
            Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = n_重结id And 结算方式 Is Null;
            n_返回值 := 1;
            If Sql%NotFound Then
              v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
              Raise Err_Item;
            End If;
            If n_预交金额 = 0 Then
              Exit;
            End If;
          End Loop;
        End If;
      Else
        --退预交款
        n_返回值   := 0;
        n_预交金额 := -1 * n_预交金额;
      
        For v_退预交 In (Select Max(a.Id) As ID, a.病人id, Max(a.收款时间) As 收款时间, Sum(Nvl(a.冲预交, 0)) As 金额
                      From 病人预交记录 A,
                           (Select Distinct a.结帐id
                             From 门诊费用记录 A, 门诊费用记录 B
                             Where a.No = b.No And Mod(b.记录性质, 10) = 1 And b.结帐id = n_原结帐id) B
                      Where a.结帐id = b.结帐id And Mod(a.记录性质, 10) = 1 And Nvl(a.预交类别, 0) = 1
                      Group By NO, 病人id
                      Having Sum(Nvl(a.冲预交, 0)) > 0
                      Order By 收款时间 Desc) Loop
        
          If v_退预交.金额 - n_预交金额 < 0 Then
            n_结算金额 := -1 * v_退预交.金额;
            n_预交金额 := n_预交金额 - v_退预交.金额;
          Else
            n_结算金额 := -1 * n_预交金额;
            n_预交金额 := 0;
          End If;
        
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id,
             结算卡序号, 卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 结算性质)
            Select 病人预交记录_Id.Nextval, 11, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
                   r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
                   Null, 卡号, 交易流水号, 交易说明, Null, 预交类别, 3
            From 病人预交记录
            Where ID = v_退预交.Id;
        
          --更新病人余额
          Update 病人余额
          Set 预交余额 = Nvl(预交余额, 0) + (-1 * n_结算金额)
          Where 病人id = v_退预交.病人id And 性质 = 1 And 类型 = 1
          Returning 预交余额 Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (v_退预交.病人id, 1, -1 * n_结算金额, 1);
            n_返回值 := -1 * n_结算金额;
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 病人余额
            Where 病人id = v_退预交.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
          End If;
        
          Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
          n_返回值 := 1;
          If Sql%NotFound Then
            v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
            Raise Err_Item;
          End If;
          If n_预交金额 = 0 Then
            Exit;
          End If;
        End Loop;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        v_Err_Msg := '未找到原始的冲预交记录,不能回退预交款！';
        Raise Err_Item;
      End If;
    
      If Nvl(n_预交金额, 0) <> 0 Then
        v_Err_Msg := '当前退预交超过了收费结算中的冲预交款,不能回退预交款！';
        Raise Err_Item;
      End If;
    
    End If;
  
    n_预交金额 := 冲预交_In;
    If Nvl(n_预交金额, 0) > 0 Then
      --冲预交款
      --病人余额检查
      Begin
        Select Sum(Nvl(预交余额, 0) - Nvl(费用余额, 0))
        Into n_预交金额
        From 病人余额
        Where 病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And Nvl(性质, 0) = 1 And 类型 = 1;
      Exception
        When Others Then
          n_预交金额 := 0;
      End;
      If n_预交金额 < 冲预交_In Then
        v_Err_Msg := '病人的当前预交余额为 ' || LTrim(To_Char(n_预交金额, '9999999990.00')) || '，小于本次支付金额 ' ||
                     LTrim(To_Char(冲预交_In, '9999999990.00')) || ' ！';
        Raise Err_Item;
      End If;
    
      n_预交金额 := 冲预交_In;
      n_结帐id   := 冲销id_In;
      If Nvl(n_重结id, 0) <> 0 Then
        n_结帐id := n_重结id;
      End If;
    
      For c_冲预交 In (Select *
                    From (Select a.Id, a.记录状态, a.病人id, a.No, Nvl(a.金额, 0) As 金额
                           From 病人预交记录 A,
                                (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                                  From 病人预交记录 A
                                  Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And
                                        a.病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And 预交类别 = 1
                                  Group By NO
                                  Having Sum(Nvl(a.金额, 0)) <> 0) B
                           Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.No = b.No And
                                 a.病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And a.预交类别 = 1
                           Union All
                           Select 0 As ID, 记录状态, Max(病人id) As 病人id, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
                           From 病人预交记录
                           Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(金额, 0) <> Nvl(冲预交, 0) And
                                 病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And 预交类别 = 1 Having
                            Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
                           Group By 记录状态, NO)
                    Order By Decode(病人id, Nvl(病人id_In, 0), 0, 1), ID, NO) Loop
      
        If c_冲预交.金额 - n_预交金额 < 0 Then
          n_冲预交 := c_冲预交.金额;
        Else
          n_冲预交 := n_预交金额;
        End If;
      
        If c_冲预交.Id <> 0 Then
          --第一次冲预交(填上结帐ID，金额为0)
          Update 病人预交记录
          Set 冲预交 = 0, 结帐id = n_结帐id, 结算序号 = n_结算序号, 结算性质 = 3
          Where ID = c_冲预交.Id;
        End If;
        --冲上次剩余额
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 r_Balancedata.收款时间, r_Balancedata.操作员姓名, r_Balancedata.操作员编号, n_冲预交, n_结帐id, r_Balancedata.缴款组id, 预交类别,
                 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, n_结算序号, 3
          From 病人预交记录
          Where NO = c_冲预交.No And 记录状态 = c_冲预交.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
      
        --更新数据(结算方式为NULL的)
        Update 病人预交记录
        Set 冲预交 = 冲预交 - n_冲预交
        Where 结帐id = n_结帐id And 结算方式 Is Null
        Returning Nvl(冲预交, 0) Into n_返回值;
      
        --更新病人预交余额
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) - n_冲预交
        Where 病人id = c_冲预交.病人id And 性质 = 1 And 类型 = 1
        Returning 预交余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (c_冲预交.病人id, 1, -1 * n_冲预交, 1);
          n_返回值 := -1 * n_冲预交;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 病人余额
          Where 病人id = c_冲预交.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
        End If;
      
        --检查是否已经处理完
        If c_冲预交.金额 < n_预交金额 Then
          n_预交金额 := n_预交金额 - c_冲预交.金额;
        Else
          n_预交金额 := 0;
        End If;
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
    
      --检查金额是否足够
      If Abs(n_预交金额) > 0 Then
        v_Err_Msg := '病人的当前预交余额小于本次支付金额 ' || LTrim(To_Char(冲预交_In, '9999999990.00')) || ' ！';
        Raise Err_Item;
      End If;
    End If;
  End If;

  If 操作类型_In = 1 Then
    --   1-普通退费方式:
    --各个收费结算 :格式为:"结算方式|结算金额|结算号码|结算摘要||.."
    v_结算内容 := 结算方式_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
    
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If v_结算方式 Is Null Then
        v_结算方式 := 缺省结算方式_In;
      End If;
      If Nvl(n_结算金额, 0) <> 0 Then
        n_结算金额 := Nvl(n_结算金额, 0);
        If Nvl(n_重结id, 0) <> 0 Then
          --肯定是收款
          --1.先按此种方式全退
          --2.再按此种方式收款
          --3:1+2=本次退款
          --1.先将退费的全部作废掉
          Select Sum(冲预交)
          Into n_返回值
          From 病人预交记录
          Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
        
          If Nvl(n_返回值, 0) <> 0 Then
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
               卡号, 交易流水号, 交易说明, 结算号码, 结算性质)
            Values
              (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
               r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_返回值, 冲销id_In, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2,
               Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3);
            Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
          End If;
          n_结算金额 := n_结算金额 - Nvl(n_返回值, 0);
          --2.退款
          If Nvl(n_结算金额, 0) <> 0 Then
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
               卡号, 交易流水号, 交易说明, 结算号码, 结算性质)
            Values
              (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
               r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, n_重结id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2,
               Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3);
            Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = n_重结id And 结算方式 Is Null;
          End If;
        Else
          --退款
          If Nvl(n_结算金额, 0) <> 0 Then
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
               卡号, 交易流水号, 交易说明, 结算号码, 结算性质)
            Values
              (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
               r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id,
               r_Balancedata.结算序号, 2, Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3);
          
            Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
            If Sql%NotFound Then
              v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
              Raise Err_Item;
            End If;
          End If;
        End If;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If 操作类型_In = 2 Then
    --   2.三方卡退费结算:
    v_当前结算 := 结算方式_In;
    v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
  
    If Nvl(n_结算金额, 0) <> 0 Then
      If Nvl(n_重结id, 0) <> 0 Then
        --1.先按此种方式全退
        --2.再按此种方式收款
        --3:1+2=本次退款
        --1.先将退费的全部作废掉
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
        If Nvl(n_返回值, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 结算号码, 结算性质)
          Values
            (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
             r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_返回值, 冲销id_In, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2,
             卡类别id_In, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3);
          Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
        End If;
        n_结算金额 := n_结算金额 - Nvl(n_返回值, 0);
      
        --2.退款
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, n_重结id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2,
           卡类别id_In, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3);
        Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = n_重结id And 结算方式 Is Null;
      
      Else
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号,
           2, 卡类别id_In, Null, 卡号_In, 交易流水号_In, 交易说明_In, v_结算号码, 3);
      
        Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
        If Sql%NotFound Then
          v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  End If;

  If 操作类型_In = 3 Then
    --   3-医保结算(如果存在医保的结算,则要先删除原医保结算,后按新传入的更新)
    --3.1检查是否已经存在医保结算数据,存在先删除
    n_结算金额 := 0;
    For v_医保 In (Select ID, 结算方式, 冲预交
                 From 病人预交记录 A
                 Where 结帐id = 冲销id_In And Exists
                  (Select 1 From 结算方式 Where a.结算方式 = 名称 And 性质 In (3, 4)) And Mod(记录性质, 10) <> 1) Loop
      n_结算金额 := n_结算金额 + Nvl(v_医保.冲预交, 0);
      l_预交id.Extend;
      l_预交id(l_预交id.Count) := v_医保.Id;
    End Loop;
    If Nvl(n_结算金额, 0) <> 0 Then
      Update 病人预交记录
      Set 冲预交 = Nvl(冲预交, 0) + Nvl(n_结算金额, 0)
      Where 结帐id = 冲销id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
        Raise Err_Item;
      End If;
    End If;
    If l_预交id.Count <> 0 Then
      Forall I In 1 .. l_预交id.Count
        Delete 病人预交记录 Where ID = l_预交id(I);
    End If;
  
    If 结算方式_In Is Not Null Then
      v_结算内容 := 结算方式_In || '||';
    End If;
  
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      For c_结算信息 In (Select 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号
                     From 病人预交记录
                     Where 结帐id = 冲销id_In And 结算方式 Is Null) Loop
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 2, c_结算信息.病人id, Null, '保险结算', v_结算方式, c_结算信息.收款时间, c_结算信息.操作员编号, c_结算信息.操作员姓名,
           n_结算金额, c_结算信息.结帐id, c_结算信息.缴款组id, c_结算信息.结算序号, 1, 3);
      End Loop;
      --更新数据(结算方式为NULL的)
      Update 病人预交记录
      Set 冲预交 = 冲预交 - n_结算金额
      Where 结帐id = 冲销id_In And 结算方式 Is Null
      Returning Nvl(冲预交, 0) Into n_返回值;
    
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --4-消费卡批量结算
  If 操作类型_In = 4 Then
    v_结算内容 := 结算方式_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      --卡类别ID|卡号|消费卡ID|消费金额
      n_卡类别id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_卡号     := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_消费卡id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(v_当前结算);
      Begin
        Select 名称, 自制卡, 结算方式 Into v_名称, n_自制卡, v_结算方式 From 卡消费接口目录 Where 编号 = n_卡类别id;
      Exception
        When Others Then
          v_名称 := Null;
      End;
      If v_名称 Is Null Then
        v_Err_Msg := '未找到对应的结算卡接口,本次刷卡消费失败!';
        Raise Err_Item;
      End If;
      If v_结算方式 Is Null Then
        v_Err_Msg := v_名称 || '未设置对应的结算方式,本次刷卡消费失败!';
        Raise Err_Item;
      End If;
      If Nvl(n_结算金额, 0) <> 0 Then
        n_结帐id := 冲销id_In;
      
        If Nvl(n_重结id, 0) <> 0 Then
        
          Select Sum(冲预交)
          Into n_返回值
          From 病人预交记录
          Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
          If Nvl(n_返回值, 0) <> 0 Then
          
            Update 病人预交记录
            Set 冲预交 = Nvl(冲预交, 0) + Nvl(n_返回值, 0)
            Where 结帐id = 冲销id_In And 结算方式 = v_结算方式 And 结算卡序号 = n_卡类别id
            Returning ID Into n_预交id;
          
            If Sql%NotFound Then
              Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
              Insert Into 病人预交记录
                (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算卡序号, 校对标志,
                 结算性质)
              Values
                (n_预交id, 3, Null, 2, r_Balancedata. 病人id, Null, Null, v_结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
                 r_Balancedata. 操作员姓名, n_返回值, r_Balancedata.结帐id, r_Balancedata. 缴款组id, r_Balancedata.结算序号, n_卡类别id, 2,
                 3);
            End If;
            Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
          
            --插入卡结算记录
            --检查消费卡是否正确
            n_序号 := Zl_消费卡目录_Check(n_卡类别id, v_卡号, n_消费卡id, v_Err_Msg);
            If Nvl(n_序号, 0) = 0 Then
              Raise Err_Item;
            End If;
            Begin
              Select Nvl(Max(Nvl(序号, 0)), 0) + 1
              Into n_序号
              From 病人卡结算记录
              Where 接口编号 = n_卡类别id And Nvl(消费卡id, 0) = Nvl(n_消费卡id, 0) And 卡号 = v_卡号;
            Exception
              When Others Then
                n_序号 := 1;
            End;
          
            Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
          
            Insert Into 病人卡结算记录
              (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
            Values
              (n_Id, n_卡类别id, n_消费卡id, n_序号, 1, v_结算方式, n_返回值, v_卡号, Null, r_Balancedata.收款时间, Null, 0);
          
            --如果消费卡,需同时更改其余额
            If Nvl(n_消费卡id, 0) <> 0 Then
              Update 消费卡目录 Set 余额 = 余额 - n_返回值 Where ID = n_消费卡id;
              If Sql%NotFound Then
                v_Err_Msg := '卡号为' || v_卡号 || '的' || v_名称 || '未找到!';
                Raise Err_Item;
              End If;
            End If;
            Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
            n_结算金额 := n_结算金额 - Nvl(n_返回值, 0);
          End If;
          n_结帐id := n_重结id;
        
        End If;
      
        Update 病人预交记录
        Set 冲预交 = Nvl(冲预交, 0) + n_结算金额
        Where 结帐id = n_结帐id And 结算方式 = v_结算方式 And 结算卡序号 = n_卡类别id
        Returning ID Into n_预交id;
      
        If Sql%NotFound Then
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算卡序号, 校对标志, 结算性质)
          Values
            (n_预交id, 3, Null, Decode(Nvl(n_重结id, 0), 0, 2, 1), r_Balancedata. 病人id, Null, Null, v_结算方式,
             r_Balancedata. 收款时间, r_Balancedata. 操作员编号, r_Balancedata. 操作员姓名, n_结算金额, n_结帐id, r_Balancedata. 缴款组id,
             r_Balancedata. 结算序号, n_卡类别id, 2, 3);
        End If;
      
        --插入卡结算记录
        n_序号 := Zl_消费卡目录_Check(n_卡类别id, v_卡号, n_消费卡id, v_Err_Msg);
        If Nvl(n_序号, 0) = 0 Then
          Raise Err_Item;
        End If;
      
        Begin
          Select Nvl(Max(Nvl(序号, 0)), 0) + 1
          Into n_序号
          From 病人卡结算记录
          Where 接口编号 = n_卡类别id And Nvl(消费卡id, 0) = Nvl(n_消费卡id, 0) And 卡号 = v_卡号;
        Exception
          When Others Then
            n_序号 := 1;
        End;
      
        Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      
        Insert Into 病人卡结算记录
          (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Values
          (n_Id, n_卡类别id, n_消费卡id, n_序号, 1, v_结算方式, n_结算金额, v_卡号, Null, r_Balancedata.收款时间, Null, 0);
        --如果消费卡,需同时更改其余额
        If Nvl(n_消费卡id, 0) <> 0 Then
          Update 消费卡目录 Set 余额 = 余额 - n_结算金额 Where ID = n_消费卡id;
          If Sql%NotFound Then
            v_Err_Msg := '卡号为' || v_卡号 || '的' || v_名称 || '未找到!';
            Raise Err_Item;
          End If;
        End If;
        Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
      
        --更新数据(结算方式为NULL的)
        Update 病人预交记录
        Set 冲预交 = 冲预交 - n_结算金额
        Where 结帐id = n_结帐id And 结算方式 Is Null
        Returning Nvl(冲预交, 0) Into n_返回值;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If Nvl(完成退费_In, 0) = 0 Then
    Return;
  End If;

  -----------------------------------------------------------------------------------------
  --完成收费,需要处理人员缴款余额,预交记录(结算方式=NULL)
  If Nvl(完成退费_In, 0) = 1 Then
    Update 病人预交记录 Set 缴款 = 缴款_In, 找补 = 找补_In, 校对标志 = 0 Where 结帐id = 冲销id_In;
    Return;
  End If;

  --1.删除结算方式为NULL的预交记录
  --结算方式为NULL的冲销记录和重结记录的金额之和为零，说明已完成全部结算
  If Nvl(n_重结id, 0) <> 0 Then
    Select Sum(Nvl(冲预交, 0))
    Into n_冲预交
    From 病人预交记录
    Where 结帐id In (冲销id_In, n_重结id) And 结算方式 Is Null;
    If Nvl(n_冲预交, 0) <> 0 Then
      v_Err_Msg := '还存在未缴款的数据,不能完成结算!';
      Raise Err_Item;
    Else
      Delete 病人预交记录 Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) = 0;
      If Sql%NotFound Then
        Update 病人预交记录 Set 结算方式 = v_退费结算 Where 结帐id = 冲销id_In And 结算方式 Is Null;
        If Sql%NotFound Then
          v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！!';
          Raise Err_Item;
        End If;
      End If;
    
      Delete 病人预交记录 Where 结帐id = n_重结id And 结算方式 Is Null And Nvl(冲预交, 0) = 0;
      If Sql%NotFound Then
        Update 病人预交记录 Set 结算方式 = v_退费结算 Where 结帐id = n_重结id And 结算方式 Is Null;
        If Sql%NotFound Then
          v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！!';
          Raise Err_Item;
        End If;
      End If;
    End If;
    Update 病人预交记录 Set 缴款 = 缴款_In, 找补 = 找补_In, 校对标志 = 0 Where 结帐id = n_重结id;
  Else
    Delete 病人预交记录 Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) = 0;
    If Sql%NotFound Then
      Select Count(*) Into n_Count From 病人预交记录 A Where 结帐id = 冲销id_In And 结算方式 Is Null;
      If n_Count <> 0 Then
        v_Err_Msg := '还存在未缴款的数据,不能完成结算!';
      Else
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！!';
      End If;
      Raise Err_Item;
    End If;
  End If;

  --检查门诊费用记录与病人预交记录的金额是否相等
  n_结算金额 := 0;
  n_冲预交   := 0;
  Select Nvl(Sum(实收金额), 0)
  Into n_结算金额
  From 门诊费用记录
  Where 结帐id In (Select 结帐id From 病人预交记录 Where 结算序号 = n_结算序号);
  Select Nvl(Sum(冲预交), 0) Into n_冲预交 From 病人预交记录 Where 结算序号 = n_结算序号;
  If n_结算金额 <> n_冲预交 Then
    v_Err_Msg := '结算信息有误，实收金额(' || n_结算金额 || ')与结算金额(' || n_冲预交 || ')不一致，不能完成结算！';
    Raise Err_Item;
  End If;

  --结算金额为零时，增加一条金额为0的病人预交记录
  Select Count(*) Into n_Count From 病人预交记录 A Where 结帐id = 冲销id_In;

  If n_Count = 0 Then
    v_结算方式 := 缺省结算方式_In;
    If v_结算方式 Is Null Then
      Begin
        Select 结算方式 Into v_结算方式 From 结算方式应用 Where 应用场合 = '收费' And Nvl(缺省标志, 0) = 1;
      Exception
        When Others Then
          v_结算方式 := Null;
      End;
      If v_结算方式 Is Null Then
        Begin
          Select 名称 Into v_结算方式 From 结算方式 Where Nvl(性质, 0) = 1;
        Exception
          When Others Then
            v_结算方式 := '现金';
        End;
      End If;
    End If;
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
       交易流水号, 交易说明, 结算号码, 结算性质)
    Values
      (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, Null, v_结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
       r_Balancedata.操作员姓名, 0, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null, Null, Null, Null,
       交易说明_In, Null, 3);
  End If;

  --2.处理缴款数据和找补数据及校对标志更新为0
  Update 病人预交记录 Set 缴款 = 缴款_In, 找补 = 找补_In, 校对标志 = 0 Where 结帐id = 冲销id_In;

  --3.更新费用状态
  Update 门诊费用记录 Set 费用状态 = 0 Where 结帐id = 冲销id_In;
  If Nvl(n_重结id, 0) <> 0 Then
    Update 门诊费用记录 Set 费用状态 = 0 Where 结帐id = n_重结id;
  End If;

  --4.更新人员缴款数据
  If n_重结id <> 0 Then
    For c_缴款 In (Select 结算方式, 操作员姓名, Sum(Nvl(a.冲预交, 0)) As 冲预交
                 From 病人预交记录 A
                 Where a.结帐id In (冲销id_In, n_重结id) And Mod(a.记录性质, 10) <> 1
                 Group By 结算方式, 操作员姓名) Loop
    
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + Nvl(c_缴款.冲预交, 0)
      Where 收款员 = c_缴款.操作员姓名 And 性质 = 1 And 结算方式 = c_缴款.结算方式;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (c_缴款.操作员姓名, c_缴款.结算方式, 1, Nvl(c_缴款.冲预交, 0));
      End If;
    End Loop;
  
  Else
    For c_缴款 In (Select 结算方式, 操作员姓名, Sum(Nvl(a.冲预交, 0)) As 冲预交
                 From 病人预交记录 A
                 Where a.结帐id = 冲销id_In And Mod(a.记录性质, 10) <> 1
                 Group By 结算方式, 操作员姓名) Loop
    
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + Nvl(c_缴款.冲预交, 0)
      Where 收款员 = c_缴款.操作员姓名 And 性质 = 1 And 结算方式 = c_缴款.结算方式;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (c_缴款.操作员姓名, c_缴款.结算方式, 1, Nvl(c_缴款.冲预交, 0));
      End If;
    End Loop;
  End If;
  --消息推送
  Select 病人id_In || ',' || 冲销id_In || ',' || Decode(完成退费_In, 2, 0, 0, 0, 1) Into v_Msg From Dual;
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 5, v_Msg;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊退费结算_Modify;
/

--91225:胡俊勇,2016-01-11,传染病管理系统
Create Or Replace Procedure Zl_电子病历记录_Update
(
  Id_In       In 电子病历记录.Id%Type,
  病人来源_In In 电子病历记录.病人来源%Type,
  病人id_In   In 电子病历记录.病人id%Type,
  主页id_In   In 电子病历记录.主页id%Type,
  婴儿_In     In 电子病历记录.婴儿%Type,
  科室id_In   In 电子病历记录.科室id%Type,
  文件id_In   In 电子病历记录.文件id%Type,
  医嘱id_In   In 病人医嘱报告.医嘱id%Type := Null,
  创建时间_In In 电子病历记录.创建时间%Type := Null
) Is
  v_保存人     电子病历记录.保存人%Type;
  d_创建时间   电子病历记录.创建时间%Type;
  d_保存时间   电子病历记录.保存时间%Type;
  d_完成时间   电子病历记录.完成时间%Type := Null;
  n_最后版本   电子病历记录.最后版本%Type := 1;
  n_预制提纲id 电子病历内容.预制提纲id%Type;
  n_定义提纲id 电子病历内容.定义提纲id%Type;
  v_对象属性   电子病历内容.对象属性%Type;
  n_处理状态   电子病历记录.处理状态%Type;
  e_Submit Exception;
  e_Nofile Exception;
  e_Repeat Exception;

  n_种类 病历文件列表.种类%Type;
  v_名称 病历文件列表.名称%Type;
  v_事件 病历时限要求.事件%Type;
  n_唯一 病历时限要求.唯一%Type;
  n_表格 Number(1);
  n_Num  Number;
  n_Lab  Number;

  --传送病人诊断记录 
  Procedure Put_Pati_Diag
  (
    v_Kind_Emr  In Varchar2,
    n_Kind_Base In 病人诊断记录.诊断类型%Type,
    n_Del_Old   In Number
  ) Is
    n_类型      病人诊断记录.诊断类型%Type;
    n_中医      Number(1); --是否中医：0-西医;1-中医 
    n_疾病id    病人诊断记录.疾病id%Type; --对应疾病编码目录(ICD或中医疾病)的ID 
    n_诊断id    病人诊断记录.诊断id%Type; --对应疾病诊断目录的ID 
    n_证候id    病人诊断记录.证候id%Type; --对应疾病诊断目录的ID 
    n_疑诊      病人诊断记录.是否疑诊%Type; --是否疑诊：0-确诊;1-疑诊 
    d_日期      病人诊断记录.记录日期%Type; --诊断次序 
    n_次序      病人诊断记录.诊断次序%Type; --诊断次序 
    v_入院病情  病人诊断记录.入院病情%Type;
    v_出院情况  病人诊断记录.出院情况%Type;
    n_Syncpage  Number(1); --是否同步更新病案首页 0-不同步 1-同步 
    n_西医order Number(2); --首页诊断次序 
    n_中医order Number(2); --首页诊断次序 
  Begin
    --取得是否同步更新病案首页参数 
    n_Syncpage := Nvl(zl_GetSysParameter('SyncPage', 1070), 0);
  
    If n_Del_Old = 1 Then
      n_次序      := 0;
      n_西医order := 0;
      n_中医order := 0;
    Else
      Select Nvl(Max(诊断次序), 0)
      Into n_次序
      From 病人诊断记录
      Where 病人id = 病人id_In And 主页id = 主页id_In And 记录来源 = 1 And 病历id + 0 = Id_In And Nvl(医嘱id, 0) = Nvl(医嘱id_In, 0);
      If n_Syncpage = 1 Then
        Select Nvl(Max(诊断次序), 0)
        Into n_西医order
        From 病人诊断记录
        Where 病人id = 病人id_In And 主页id = 主页id_In And 记录来源 = 3;
      End If;
    End If;
  
    For r_Temp In (Select Rownum As 次序, 对象属性 As 属性, 内容文本 As 描述
                   From 临时病历内容
                   Where 对象类型 = 7 And Substr(对象属性, 1, 2) = v_Kind_Emr And Nvl(终止版, 0) = 0) Loop
      If n_Del_Old = 1 And r_Temp.次序 = 1 Then
        Delete 病人诊断记录
        Where 病人id = 病人id_In And 主页id = 主页id_In And 记录来源 = 1 And 病历id + 0 = Id_In And
              诊断类型 In (n_Kind_Base, n_Kind_Base + 10) And Nvl(医嘱id, 0) = Nvl(医嘱id_In, 0);
        If n_Syncpage = 1 And (n_Kind_Base = 2 Or n_Kind_Base = 3) Then
          --只处理入院诊断和出院诊断 
          Delete 病人诊断记录
          Where 病人id = 病人id_In And 主页id = 主页id_In And 记录来源 = 3 And 诊断类型 In (n_Kind_Base, n_Kind_Base + 10);
        End If;
      End If;
      n_中医   := To_Number(Substr(r_Temp.属性, Instr(r_Temp.属性, ';', 1, 1) + 1,
                                 Instr(r_Temp.属性, ';', 1, 2) - Instr(r_Temp.属性, ';', 1, 1) - 1));
      n_疾病id := To_Number(Substr(r_Temp.属性, Instr(r_Temp.属性, ';', 1, 2) + 1,
                                 Instr(r_Temp.属性, ';', 1, 3) - Instr(r_Temp.属性, ';', 1, 2) - 1));
      n_诊断id := To_Number(Substr(r_Temp.属性, Instr(r_Temp.属性, ';', 1, 3) + 1,
                                 Instr(r_Temp.属性, ';', 1, 4) - Instr(r_Temp.属性, ';', 1, 3) - 1));
      n_证候id := To_Number(Substr(r_Temp.属性, Instr(r_Temp.属性, ';', 1, 4) + 1,
                                 Instr(r_Temp.属性, ';', 1, 5) - Instr(r_Temp.属性, ';', 1, 4) - 1));
      n_疑诊   := To_Number(Substr(r_Temp.属性, Instr(r_Temp.属性, ';', 1, 5) + 1,
                                 Instr(r_Temp.属性, ';', 1, 6) - Instr(r_Temp.属性, ';', 1, 5) - 1));
      d_日期   := To_Date(Substr(r_Temp.属性, Instr(r_Temp.属性, ';', 1, 6) + 1,
                               Instr(r_Temp.属性, ';', 1, 7) - Instr(r_Temp.属性, ';', 1, 6) - 1), 'yyyy-mm-dd hh24:mi:ss');
      If n_Kind_Base <> 1 And n_Kind_Base <> 2 And n_Kind_Base <> 3 Then
        n_中医 := 0;
      End If;
      If n_中医 = 1 Then
        n_类型 := n_Kind_Base + 10;
      Else
        n_类型 := n_Kind_Base;
      End If;
      Insert Into 病人诊断记录
        (ID, 病人id, 主页id, 医嘱id, 记录来源, 诊断次序, 病历id, 诊断类型, 疾病id, 诊断id, 证候id, 诊断描述, 是否疑诊, 记录日期, 记录人)
      Values
        (病人诊断记录_Id.Nextval, 病人id_In, 主页id_In, 医嘱id_In, 1, r_Temp.次序 + n_次序, Id_In, n_类型,
         Decode(n_疾病id, 0, Null, n_疾病id), Decode(n_诊断id, 0, Null, n_诊断id), Decode(n_证候id, 0, Null, n_证候id), r_Temp.描述,
         n_疑诊, d_日期, v_保存人);
      If n_Syncpage = 1 And (n_Kind_Base = 2 Or n_Kind_Base = 3) Then
        If n_Kind_Base = 3 Then
          v_入院病情 := Substr(r_Temp.属性, Instr(r_Temp.属性, ';', 1, 7) + 1,
                           Instr(r_Temp.属性, ';', 1, 8) - Instr(r_Temp.属性, ';', 1, 7) - 1);
          v_出院情况 := Substr(r_Temp.属性, Instr(r_Temp.属性, ';', 1, 8) + 1);
        End If;
        --如果需要同步首页诊断，只处理入院诊断和出院诊断 
        If n_中医 = 1 Then
          n_中医order := n_中医order + 1;
        Else
          n_西医order := n_西医order + 1;
        End If;
        Insert Into 病人诊断记录
          (ID, 病人id, 主页id, 记录来源, 诊断次序, 编码序号, 诊断类型, 疾病id, 诊断id, 证候id, 诊断描述, 入院病情, 出院情况, 是否疑诊, 记录日期, 记录人)
        Values
          (病人诊断记录_Id.Nextval, 病人id_In, 主页id_In, 3, Decode(n_中医, 1, n_中医order, n_西医order), 1, n_类型,
           Decode(n_疾病id, 0, Null, n_疾病id), Decode(n_诊断id, 0, Null, n_诊断id), Decode(n_证候id, 0, Null, n_证候id),
           Replace(r_Temp.描述, '(?)', ''), v_入院病情, v_出院情况, n_疑诊, d_日期, v_保存人);
      End If;
    End Loop;
  End Put_Pati_Diag;

Begin
  Begin
    Select p.姓名 Into v_保存人 From 上机人员表 O, 人员表 P Where o.人员id = p.Id And 用户名 = User;
  Exception
    When Others Then
      v_保存人 := User;
  End;
  d_保存时间 := Sysdate;
  d_创建时间 := Nvl(创建时间_In, Sysdate);

  Select Greatest(Nvl(Max(开始版), 1), Nvl(Max(终止版), 1) + 1) Into n_最后版本 From 临时病历内容;
  If n_最后版本 <= 0 Then
    n_最后版本 := 1;
  End If;

  Select Count(*) Into n_Num From 病历文件列表 Where ID = 文件id_In;
  If n_Num = 0 Then
    Raise e_Nofile;
  End If;

  Select l.种类, l.名称, q.事件, q.唯一
  Into n_种类, v_名称, v_事件, n_唯一
  From 病历文件列表 L, 病历时限要求 Q
  Where l.Id = q.文件id(+) And l.Id = 文件id_In;

  Update 电子病历记录
  Set 病人来源 = 病人来源_In, 病人id = 病人id_In, 主页id = 主页id_In, 婴儿 = 婴儿_In, 科室id = 科室id_In, 文件id = 文件id_In, 保存时间 = d_保存时间
  Where ID = Id_In;
  If Sql%RowCount = 0 Then
    Insert Into 电子病历记录
      (ID, 病人来源, 病人id, 主页id, 婴儿, 科室id, 病历种类, 文件id, 病历名称, 最后版本, 创建人, 创建时间, 保存人, 保存时间)
    Values
      (Id_In, 病人来源_In, 病人id_In, 主页id_In, 婴儿_In, 科室id_In, n_种类, 文件id_In, v_名称, n_最后版本, v_保存人, d_创建时间, v_保存人, d_保存时间);
  
    If n_种类 = 2 And Nvl(医嘱id_In, 0) <> 0 And Instr(v_名称, '会诊') > 0 Then
      Insert Into 病人医嘱报告 (医嘱id, 病历id) Values (医嘱id_In, Id_In);
    Elsif n_种类 = 7 And Nvl(医嘱id_In, 0) <> 0 Then
      --检查报告的重复性 
      Select Count(*)
      Into n_Num
      From 电子病历记录 L, 病人医嘱报告 R
      Where l.Id = r.病历id And r.医嘱id = 医嘱id_In And l.文件id = 文件id_In;
      If n_Num > 0 Then
        Raise e_Repeat;
      End If;
      --单独处理检验有多个单独下的医嘱合并为一个核收的情况 
      Begin
        Select a.Id
        Into n_Lab
        From 检验标本记录 A, 病人医嘱记录 B
        Where a.医嘱id = b.相关id And Rownum <= 1 And a.医嘱id = 医嘱id_In;
      Exception
        When Others Then
          n_Lab := 0;
      End;
      If n_Lab = 0 Then
        --其他项目还是正常处理 
        Insert Into 病人医嘱报告 (医嘱id, 病历id) Values (医嘱id_In, Id_In);
      Else
        --单独处理检验项目 
        Insert Into 病人医嘱报告
          (医嘱id, 病历id)
          Select Distinct b.医嘱id, Id_In
          From 检验标本记录 A, 检验项目分布 B
          Where a.Id = b.标本id And a.医嘱id = 医嘱id_In And b.医嘱id Is Not Null;
      End If;
    End If;
  Else
    Select Nvl(处理状态, 0) Into n_处理状态 From 电子病历记录 Where ID = Id_In;
    Select Max(处理状态) Into n_Num From 疾病申报记录 Where 文件id = Id_In;
    If Nvl(n_Num, 0) <> 4 and Nvl(n_Num, 0) <> 5 Then
      If n_处理状态 > 0 Then
        Raise e_Submit;
      End If;
    End If;
  End If;

  Update 电子病历内容
  Set 对象序号 = -1 * 对象序号, 内容行次 = -1 * 内容行次, 终止版 = Decode(Nvl(终止版, 0), 0, n_最后版本, 终止版)
  Where 文件id = Id_In;
  For r_Temp In (Select ID, 父id, 开始版, 终止版, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行, 定义提纲id, 预制提纲id, 复用提纲, 使用时机,
                        诊治要素id, 替换域, 要素名称, 要素类型, 要素长度, 要素小数, 要素单位, 要素表示, 输入形态, 要素值域
                 From 临时病历内容
                 Order By ID) Loop
  
    --清理预制提纲id：对以前文件(XML或历史文件)，可能预制提纲与当前系统不符合。 
    n_预制提纲id := r_Temp.预制提纲id;
    If r_Temp.对象类型 = 1 And Nvl(n_预制提纲id, 0) <> 0 Then
      Select Max(ID) Into n_预制提纲id From 病历文件结构 Where ID = n_预制提纲id And 文件id Is Null;
      If n_预制提纲id = 0 Then
        n_预制提纲id := Null;
      End If;
    End If;
    --修复定义提纲id：如果定义提纲id不存在，则根据提纲名称查找对应的定义提纲id 
    n_定义提纲id := r_Temp.定义提纲id;
    If r_Temp.对象类型 = 1 Then
      If Nvl(n_定义提纲id, 0) <> 0 Then
        Select Max(ID) Into n_定义提纲id From 病历文件结构 Where ID = n_定义提纲id And 文件id = 文件id_In;
      End If;
      If Nvl(n_定义提纲id, 0) = 0 Then
        Select Max(ID)
        Into n_定义提纲id
        From 病历文件结构
        Where 文件id = 文件id_In And 内容文本 || 预制提纲id = r_Temp.内容文本 || n_预制提纲id;
      End If;
      If n_定义提纲id = 0 Then
        n_定义提纲id := Null;
      End If;
    End If;
  
    v_对象属性 := r_Temp.对象属性;
    --从签名对象获得保存人和完成时间 
    If r_Temp.对象类型 = 8 Then
      If Instr(v_对象属性, ';', 1, 5) = 0 Then
        v_对象属性 := v_对象属性 || ';';
      End If;
      If Instr(v_对象属性, ';', 1, 5) - Instr(v_对象属性, ';', 1, 4) = 1 Then
        v_对象属性 := Substr(v_对象属性, 1, Instr(v_对象属性, ';', 1, 4) - 1) || ';' || To_Char(d_保存时间, 'yyyy-mm-dd hh24:mi:ss') ||
                  Substr(v_对象属性, Instr(v_对象属性, ';', 1, 5));
      End If;
      If r_Temp.开始版 >= n_最后版本 Then
        If Nvl(Instr(r_Temp.内容文本, ';'), 0) = 0 Then
          v_保存人 := r_Temp.内容文本;
        Else
          --内容文本中存放有签名人;ID,有可能签名同名所以必须使用ID,同时确保历史数据的回退正常。 
          Begin
            Select 姓名 Into v_保存人 From 人员表 Where ID = Substr(r_Temp.内容文本, Instr(r_Temp.内容文本, ';') + 1);
          Exception
            When Others Then
              v_保存人 := Substr(r_Temp.内容文本, 1, Instr(r_Temp.内容文本, ';') - 1);
          End;
        End If;
      End If;
      If d_完成时间 Is Null And r_Temp.开始版 = 1 Then
        d_完成时间 := To_Date(Substr(v_对象属性, Instr(v_对象属性, ';', 1, 4) + 1,
                                 Instr(v_对象属性, ';', 1, 5) - Instr(v_对象属性, ';', 1, 4) - 1), 'yyyy-mm-dd hh24:mi:ss');
      End If;
    End If;
  
    Update 电子病历内容
    Set 父id = r_Temp.父id, 开始版 = r_Temp.开始版, 终止版 = r_Temp.终止版, 对象序号 = r_Temp.对象序号, 对象类型 = r_Temp.对象类型, 对象标记 = r_Temp.对象标记,
        保留对象 = r_Temp.保留对象, 对象属性 = v_对象属性, 内容行次 = r_Temp.内容行次, 内容文本 = r_Temp.内容文本, 是否换行 = r_Temp.是否换行, 定义提纲id = n_定义提纲id,
        预制提纲id = n_预制提纲id, 复用提纲 = r_Temp.复用提纲, 使用时机 = r_Temp.使用时机, 诊治要素id = r_Temp.诊治要素id, 替换域 = r_Temp.替换域,
        要素名称 = r_Temp.要素名称, 要素类型 = r_Temp.要素类型, 要素长度 = r_Temp.要素长度, 要素小数 = r_Temp.要素小数, 要素单位 = r_Temp.要素单位,
        要素表示 = r_Temp.要素表示, 输入形态 = r_Temp.输入形态, 要素值域 = r_Temp.要素值域
    Where ID = r_Temp.Id And 文件id + 0 = Id_In;
    If Sql%RowCount = 0 Then
      Insert Into 电子病历内容
        (ID, 文件id, 父id, 开始版, 终止版, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行, 定义提纲id, 预制提纲id, 复用提纲, 使用时机, 诊治要素id,
         替换域, 要素名称, 要素类型, 要素长度, 要素小数, 要素单位, 要素表示, 输入形态, 要素值域)
      Values
        (r_Temp.Id, Id_In, r_Temp.父id, r_Temp.开始版, r_Temp.终止版, r_Temp.对象序号, r_Temp.对象类型, r_Temp.对象标记, r_Temp.保留对象,
         v_对象属性, r_Temp.内容行次, r_Temp.内容文本, r_Temp.是否换行, n_定义提纲id, n_预制提纲id, r_Temp.复用提纲, r_Temp.使用时机, r_Temp.诊治要素id,
         r_Temp.替换域, r_Temp.要素名称, r_Temp.要素类型, r_Temp.要素长度, r_Temp.要素小数, r_Temp.要素单位, r_Temp.要素表示, r_Temp.输入形态,
         r_Temp.要素值域);
    Else
      --普通表格：由于编辑时没有痕迹，按单元保存；因此需要恢复子单元，保证版本记录 
      If r_Temp.对象类型 = 3 Then
        n_表格 := 0;
        If Instr(v_对象属性, ';', 1, 18) = 0 Then
          n_表格 := 1;
        Elsif Substr(v_对象属性, Instr(v_对象属性, ';', 1, 18) + 1, 1) = '0' Then
          n_表格 := 1;
        End If;
        If n_表格 = 1 Then
          Update 电子病历内容
          Set 对象序号 = Abs(对象序号), 内容行次 = Abs(内容行次)
          Where 文件id = Id_In And 父id = r_Temp.Id And 开始版 <= n_最后版本 And 对象类型 <> 5;
        End If;
      End If;
    End If;
  End Loop;
  Delete 电子病历内容
  Where (Nvl(对象序号, 0) < 0 Or Nvl(内容行次, 0) < 0 Or Nvl(开始版, 1) > n_最后版本) And 文件id = Id_In;

  Update 电子病历记录
  Set 完成时间 = d_完成时间, 保存人 = v_保存人, 最后版本 = n_最后版本,
      签名级别 =
       (Select Nvl(Sum(Power(2, 要素表示 - 1)), 0)
        From (Select Distinct 要素表示 From 临时病历内容 Where 对象类型 = 8 And 开始版 >= n_最后版本))
  Where ID = Id_In;

  --先删除原有诊断，因为有可能原有诊断被删除或更改 
  Delete 病人诊断记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 病历id + 0 = Id_In;
  --填写病人诊断记录 
  If n_种类 = 1 Then
    Put_Pati_Diag('11', 1, 1);
  Elsif n_种类 = 2 And (v_事件 = '入院' Or v_事件 = '首次入院' Or v_事件 = '再次入院') And n_唯一 = 1 Then
    Put_Pati_Diag('21', 2, 1);
    Put_Pati_Diag('22', 2, 1);
    Put_Pati_Diag('23', 2, 1);
    Put_Pati_Diag('24', 2, 0);
  Elsif n_种类 = 2 And (v_事件 = '24小时出院' Or v_事件 = '24小时死亡') Then
    Put_Pati_Diag('21', 2, 1);
    Put_Pati_Diag('22', 2, 1);
    Put_Pati_Diag('23', 2, 1);
    Put_Pati_Diag('24', 2, 0);
    Put_Pati_Diag('31', 3, 1);
  Elsif n_种类 = 2 And (v_事件 = '出院' Or v_事件 = '死亡') Then
    Put_Pati_Diag('31', 3, 1);
  Elsif n_种类 = 2 And v_事件 = '手术' Then
    Put_Pati_Diag('41', 8, 1);
    Put_Pati_Diag('42', 9, 1);
  Elsif n_种类 = 7 And (医嘱id_In Is Not Null) Then
    Put_Pati_Diag('51', 6, 1);
    Put_Pati_Diag('52', 22, 1);
    --只处理阳性标志 
    --Update 病人医嘱发送 Set 结果阳性 = 0 Where 医嘱id = 医嘱id_In; 
    Update 病人医嘱发送
    Set 结果阳性 = 1
    Where 医嘱id = 医嘱id_In And Exists
     (Select 内容文本
           From 临时病历内容
           Where 对象类型 = 7 And (Substr(对象属性, 1, 2) = '51' Or Substr(对象属性, 1, 2) = '52') And Nvl(终止版, 0) = 0);
  End If;

  --处理电子病历时机 
  If d_完成时间 Is Null Then
    Update 电子病历时机 Set 完成时间 = Null Where 病人id = 病人id_In And 主页id = 主页id_In And 完成记录id = Id_In;
    If Sql%RowCount = 0 Then
      Zl_电子病历时机_Update(病人id_In, 主页id_In, 病人来源_In, 科室id_In, 文件id_In, Id_In, Null, v_保存人);
    End If;
  Else
    Zl_电子病历时机_Update(病人id_In, 主页id_In, 病人来源_In, 科室id_In, 文件id_In, Id_In, d_完成时间, v_保存人);
  End If;
Exception
  When e_Submit Then
    Raise_Application_Error(-20101, '[ZLSOFT]不能更改被后续接收的病历！[ZLSOFT]');
  When e_Nofile Then
    Raise_Application_Error(-20101, '[ZLSOFT]病历文件定义丢失，请联系系统管理员！[ZLSOFT]');
  When e_Repeat Then
    Raise_Application_Error(-20101, '[ZLSOFT]其他人已经书写并保存了报告，不能再保存！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_电子病历记录_Update;
/

--91844:陈刘,2016-01-07,体温单没有护理明细,护理文件可以正确删除
CREATE OR REPLACE Procedure ZL_病人护理文件_DELETE(
	ID_IN IN 病人护理文件.ID%Type 
) 
IS 
	ERR_ITEM Exception; 
	V_ERR_MSG  VARCHAR2(500); 
	LNGSIGNED NUMBER ; 
Begin 
	--如果有数据则不允许删除 
	Begin 
		SELECT 1 INTO LNGSIGNED 
		FROM 病人护理数据 A,病人护理文件 B,病人护理明细 C
		WHERE B.ID=ID_IN And A.文件ID=B.ID And C.记录ID = a.id And RowNum<2; 
	Exception 
		When Others Then LNGSIGNED:=0; 
	End ; 
 
	IF LNGSIGNED=1 THEN 
		V_ERR_MSG := '该文件已经产生护理数据不允许删除,请检查！'; 
		RAISE ERR_ITEM; 
	End IF ; 
 
	--删除打印解析 
	DELETE 病人护理打印 WHERE 文件ID=ID_IN; 
	--删除明细数据 
	DELETE 病人护理明细 WHERE 记录ID IN (SELECT ID FROM 病人护理数据 WHERE 文件ID=ID_IN); 
	--删除行记录 
	DELETE 病人护理数据 WHERE 文件ID=ID_IN; 
	--删除护理文件 
	DELETE 病人护理文件 WHERE ID=ID_IN; 
	--将上级数据的续打ID设置为空 
	UPDATE 病人护理文件 SET 续打ID=NULL WHERE 续打ID=ID_IN; 
Exception 
	WHEN ERR_ITEM THEN 
		RAISE_APPLICATION_ERROR(-20101, '[ZLSOFT]' || V_ERR_MSG || '[ZLSOFT]'); 
	When Others Then 
		ZL_ERRORCENTER (SQLCODE, SQLERRM); 
End ZL_病人护理文件_DELETE;
/

--92469:蔡青松,2016-01-07,去掉一个参数 送检人_In
Create Or Replace Procedure Zl_病人医嘱发送_Sampleinput
(
  医嘱id      In Varchar2,
  接收人_In   In 病人医嘱发送.接收人%Type := Null,
  接收批次_In In 病人医嘱发送.接收批次%Type := 0,
  人员编号_In In 人员表.编号%Type := Null,
  人员姓名_In In 人员表.姓名%Type := Null
) Is
  --未审核的费用行(不包含药品)
  Cursor c_Verify(v_医嘱id In Number) Is
    Select Distinct 记录性质, NO, 序号
    From 住院费用记录
    Where 收费类别 Not In ('5', '6', '7') And 医嘱序号 + 0 = v_医嘱id And 记帐费用 = 1 And 记录状态 = 0 And 价格父号 Is Null And
          (记录性质, NO) In (Select 记录性质, NO
                         From 病人医嘱附费
                         Where 医嘱id = v_医嘱id
                         Union All
                         Select 记录性质, NO
                         From 病人医嘱发送
                         Where 医嘱id In (Select ID From 病人医嘱记录 Where v_医嘱id In (ID, 相关id)))
    Union All
    Select Distinct 记录性质, NO, 序号
    From 门诊费用记录
    Where 收费类别 Not In ('5', '6', '7') And 医嘱序号 + 0 = v_医嘱id And 记帐费用 = 1 And 记录状态 = 0 And 价格父号 Is Null And
          (记录性质, NO) In (Select 记录性质, NO
                         From 病人医嘱附费
                         Where 医嘱id = v_医嘱id
                         Union All
                         Select 记录性质, NO
                         From 病人医嘱发送
                         Where 医嘱id In (Select ID From 病人医嘱记录 Where v_医嘱id In (ID, 相关id)))
    Order By 记录性质, NO, 序号;

  --查找当前标本的相关申请
  Cursor c_Samplequest(v_医嘱id In Number) Is
    Select Distinct ID As 医嘱id, 病人来源 From 病人医嘱记录 Where v_医嘱id In (ID, 相关id);

  v_No   病人医嘱发送.No%Type;
  v_性质 病人医嘱发送.记录性质%Type;
  v_序号 Varchar2(1000);

  v_医嘱id   病人医嘱发送.医嘱id%Type;
  v_相关id   病人医嘱记录.相关id%Type;
  v_费用性质 病人医嘱发送.记录性质%Type;
  v_样本条码 病人医嘱发送.样本条码%Type;
  v_Records  Varchar2(2000);
  v_Currrec  Varchar2(50);
  v_Fields   Varchar2(50);
  v_Count    Number(18);
  v_病人id   病人医嘱记录.病人id%Type;
  v_主页id   病人医嘱记录.主页id%Type;
  v_是否出院 Number; --0=出院,1=在院
  v_记录状态 Number;
  v_病人来源 病人医嘱记录.病人来源%Type;
  v_Date     Date;
  Err_Custom Exception;
  v_Error Varchar2(100);
Begin
  Select Sysdate Into v_Date From Dual;

  v_Records := 医嘱id || '|';

  While v_Records Is Not Null Loop
  
    v_Currrec := Substr(v_Records, 1, Instr(v_Records, '|') - 1);
    v_Fields  := v_Currrec;
    v_医嘱id  := Substr(v_Fields, 1, Instr(v_Fields, ',') - 1);
    v_相关id  := Substr(v_Fields, Instr(v_Fields, ',') + 1);
    If 接收人_In Is Null Then
      Update 病人医嘱发送
      Set 接收人 = Null, 接收时间 = Null, 接收批次 = Null
      Where 医嘱id In (v_医嘱id, v_相关id);
      Update 病人医嘱发送
      Set 执行状态 = Decode(样本条码, Null, 0, 1)
      Where 医嘱id In (Select ID From 病人医嘱记录 Where ID In (v_医嘱id, v_相关id) And 相关id Is Null);
      For r_Samplequest In c_Samplequest(v_相关id) Loop
        If r_Samplequest.病人来源 = 2 Then
          Select Decode(记录性质, 1, 1, Decode(门诊记帐, 1, 1, 2))
          Into v_费用性质
          From 病人医嘱发送
          Where 医嘱id = r_Samplequest.医嘱id;
        Else
          v_费用性质 := 1;
        End If;
        If v_费用性质 = 2 Then
          --2.费用执行处理
          Update 住院费用记录
          Set 执行状态 = 0, 执行时间 = Null, 执行人 = 接收人_In
          Where 收费类别 Not In ('5', '6', '7') And
                (医嘱序号, 记录性质, NO) In
                (Select 医嘱id, 记录性质, NO
                 From 病人医嘱附费
                 Where 医嘱id = r_Samplequest.医嘱id
                 Union All
                 Select 医嘱id, 记录性质, NO
                 From 病人医嘱发送
                 Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = r_Samplequest.医嘱id And 相关id Is Not Null)
                 Union All
                 Select 医嘱id, 记录性质, NO
                 From 病人医嘱发送
                 Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = r_Samplequest.医嘱id And 相关id Is Null) And 采样人 Is Null);
        Else
          Update 门诊费用记录
          Set 执行状态 = 0, 执行时间 = Null, 执行人 = 接收人_In
          Where 收费类别 Not In ('5', '6', '7') And
                (医嘱序号, 记录性质, NO) In
                (Select 医嘱id, 记录性质, NO
                 From 病人医嘱附费
                 Where 医嘱id = r_Samplequest.医嘱id
                 Union All
                 Select 医嘱id, 记录性质, NO
                 From 病人医嘱发送
                 Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = r_Samplequest.医嘱id And 相关id Is Not Null)
                 Union All
                 Select 医嘱id, 记录性质, NO
                 From 病人医嘱发送
                 Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = r_Samplequest.医嘱id And 相关id Is Null) And 采样人 Is Null);
        End If;
      End Loop;
    Else
      --判断是否已出院，如果已出院负不完成登记
      Begin
        If v_主页id Is Null Then
          Select a.病人id, a.主页id, a.病人来源
          Into v_病人id, v_主页id, v_病人来源
          From 病人医嘱记录 A, 病案主页 B
          Where a.病人id = b.病人id And a.主页id = b.主页id(+) And a.Id = v_医嘱id;
        End If;
      Exception
        When Others Then
          v_病人来源 := 1;
      End;
      If v_病人来源 = 2 Then
        If Nvl(v_主页id, 0) > 0 Then
          Select Decode(出院日期, Null, 1, 0)
          Into v_是否出院
          From 病案主页
          Where 病人id = v_病人id And 主页id = v_主页id;
        Else
          v_是否出院 := 0;
        End If;
      
        If v_是否出院 = 0 Then
          --出院的才处理
          Begin
            Select Nvl(记录状态, 0)
            Into v_记录状态
            From 住院费用记录
            Where 医嘱序号 = v_医嘱id And Nvl(记录状态, 0) = 0 And Rownum = 1;
          Exception
            When Others Then
              v_记录状态 := 1;
          End;
        
          Select Nvl(样本条码, 0) Into v_样本条码 From 病人医嘱发送 Where 医嘱id = v_医嘱id;
          If v_样本条码 = 0 Then
            v_Error := '病人已出院不能完成登记!';
            Raise Err_Custom;
          End If;
        
        End If;
      End If;
    
      Update 病人医嘱发送
      Set 接收人 = 接收人_In, 接收时间 = v_Date, 接收批次 = 接收批次_In,  重采标本 = Null
      Where 医嘱id In (v_医嘱id, v_相关id);
      Update 病人医嘱发送
      Set 执行状态 = 1
      Where 医嘱id In (Select ID From 病人医嘱记录 Where ID In (v_医嘱id, v_相关id) And 相关id Is Null);
      --记帐划价单是否转为记帐单
      --2.检查当前标本相关的申请的相关标本是否完成审核
      For r_Samplequest In c_Samplequest(v_相关id) Loop
        v_Count := 0;
        --r_SampleQuest.医嘱id申请已经完成,处理后续环节
        If v_Count = 0 Then
          If r_Samplequest.病人来源 = 2 Then
            Select Decode(记录性质, 1, 1, Decode(门诊记帐, 1, 1, 2))
            Into v_费用性质
            From 病人医嘱发送
            Where 医嘱id = r_Samplequest.医嘱id;
          Else
            v_费用性质 := 1;
          End If;
          If v_费用性质 = 2 Then
            --2.费用执行处理
            Update 住院费用记录
            Set 执行状态 = 1, 执行时间 = Sysdate, 执行人 = 人员姓名_In
            Where 收费类别 Not In ('5', '6', '7') And
                  (医嘱序号, 记录性质, NO) In
                  (Select 医嘱id, 记录性质, NO
                   From 病人医嘱附费
                   Where 医嘱id = r_Samplequest.医嘱id
                   Union All
                   Select 医嘱id, 记录性质, NO
                   From 病人医嘱发送
                   Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = r_Samplequest.医嘱id And 相关id Is Not Null)
                   Union All
                   Select 医嘱id, 记录性质, NO
                   From 病人医嘱发送
                   Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = r_Samplequest.医嘱id And 相关id Is Null) And 采样人 Is Null);
          Else
            Update 门诊费用记录
            Set 执行状态 = 1, 执行时间 = Sysdate, 执行人 = 人员姓名_In
            Where 收费类别 Not In ('5', '6', '7') And
                  (医嘱序号, 记录性质, NO) In
                  (Select 医嘱id, 记录性质, NO
                   From 病人医嘱附费
                   Where 医嘱id = r_Samplequest.医嘱id
                   Union All
                   Select 医嘱id, 记录性质, NO
                   From 病人医嘱发送
                   Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = r_Samplequest.医嘱id And 相关id Is Not Null)
                   Union All
                   Select 医嘱id, 记录性质, NO
                   From 病人医嘱发送
                   Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = r_Samplequest.医嘱id And 相关id Is Null) And 采样人 Is Null);
          End If;
          --3.自动审核记帐
            For r_Verify In c_Verify(r_Samplequest.医嘱id) Loop
              If r_Verify.No || ',' || r_Verify.记录性质 <> v_No || ',' || v_性质 Then
                If v_序号 Is Not Null Then
                  If v_费用性质 = 1 Then
                    Zl_门诊记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
                  Elsif v_费用性质 = 2 Then
                    Zl_住院记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
                  End If;
                End If;
                v_序号 := Null;
              End If;
              v_No   := r_Verify.No;
              v_性质 := r_Verify.记录性质;
              v_序号 := v_序号 || ',' || r_Verify.序号;
            End Loop;
            If v_序号 Is Not Null Then
              If v_费用性质 = 1 Then
                Zl_门诊记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
              Elsif v_费用性质 = 2 Then
                Zl_住院记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
              End If;
            End If;
        End If;
      End Loop;
    End If;
    v_Records := Substr('|' || v_Records, Length('|' || v_Currrec || '|') + 1);
  End Loop;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人医嘱发送_Sampleinput;
/

--92402:冉俊明,2016-01-06,药品按成本价加收计算出的实收金额不正确。
Create Or Replace Function Zl_Actualmoney
(
  费别_In       Varchar2,
  收费细目id_In 费别明细.收费细目id%Type,
  收入项目id_In 费别明细.收入项目id%Type,
  应收金额_In   门诊费用记录.应收金额%Type,
  数量_In       门诊费用记录.数次%Type := 0,
  药房id_In     药品库存.库房id%Type := 0
) Return Varchar2 As
  --功能:根据应收金额按费别进行打折计算
  --参数:
  --     费别_In:病人当前费别，如果是动态费别，值为'费别1,费别2,...'
  --     应收金额_In:应传入加班加价计算之前的真实应收金额
  --     数量_In:售价数量，药品才需传入
  --     药房id_in:药品才需传入
  --返回:费别:实收金额

  n_实收金额 门诊费用记录.实收金额%Type;
  v_费别     门诊费用记录.费别%Type;

  n_Money 门诊费用记录.实收金额%Type;
  n_Rate  Number;

  n_Cnt0     Number;
  n_Cnt1     Number;
  v_Temp     Varchar2(1000);
  n_售价     Number;
  n_成本价   Number;
  n_剩余数量 Number;
Begin
  n_实收金额 := 应收金额_In;
  If Instr(费别_In, ',') = 0 Then
    v_费别 := 费别_In;
  Else
    v_费别 := Substr(费别_In, 1, Instr(费别_In, ',') - 1);
  End If;

  For Rs In (Select 费别, 实收比率, 实收金额, 计算方法
             From (Select a.费别, Nvl(a.实收比率, 0) As 实收比率, 应收金额_In * Nvl(a.实收比率, 0) / 100 As 实收金额, Nvl(a.计算方法, 0) As 计算方法,
                           b.属性, b.编码
                    From 费别明细 A, 费别 B
                    Where a.费别 = b.名称 And a.收费细目id = 收费细目id_In And Instr(',' || 费别_In || ',', ',' || b.名称 || ',') > 0 And
                          Abs(应收金额_In) Between a.应收段首值 And a.应收段尾值
                    Union All
                    Select a.费别, Nvl(a.实收比率, 0) As 实收比率, 应收金额_In * Nvl(a.实收比率, 0) / 100 As 实收金额, Nvl(a.计算方法, 0) As 计算方法,
                           b.属性, b.编码
                    From 费别明细 A, 费别 B
                    Where a.费别 = b.名称 And a.收入项目id = 收入项目id_In And Instr(',' || 费别_In || ',', ',' || b.名称 || ',') > 0 And
                          Abs(应收金额_In) Between a.应收段首值 And a.应收段尾值 And Not Exists
                     (Select 1 From 费别明细 C Where c.费别 = a.费别 And c.收费细目id = 收费细目id_In))
             Order By 计算方法, 实收比率, 属性, 编码) Loop
  
    If Rs.计算方法 = 0 And Nvl(n_Cnt0, 0) = 0 Then
      n_Cnt0     := 1; --一种计算方法只取最优惠的一行记录
      n_实收金额 := Rs.实收金额;
      v_费别     := Rs.费别;
    Elsif Rs.计算方法 = 1 And 数量_In <> 0 And Nvl(n_Cnt1, 0) = 0 Then
      n_Cnt1 := 1; --一种计算方法只取最优惠的一行记录
      --药品按成本价加收方式
      n_Rate := Rs.实收比率 / 100;
    
      v_Temp := Zl_Fun_Getprice(收费细目id_In, 药房id_In, 数量_In);
      --分解
      n_售价     := To_Number(Substr(v_Temp, 1, Instr(v_Temp, '|') - 1));
      v_Temp     := Substr(v_Temp, Instr(v_Temp, '|') + 1);
      n_成本价   := To_Number(Substr(v_Temp, 1, Instr(v_Temp, '|') - 1));
      v_Temp     := Substr(v_Temp, Instr(v_Temp, '|') + 1);
      n_剩余数量 := To_Number(v_Temp);
    
      If n_剩余数量 = 0 Then
        n_Money := n_成本价 * (1 + n_Rate) * 数量_In;
        If n_Money < n_实收金额 Then
          n_实收金额 := n_Money;
          v_费别     := Rs.费别;
        End If;
      End If;
    End If;
  End Loop;

  Return v_费别 || ':' || n_实收金额;
Exception
  When Others Then
    Return v_费别 || ':' || n_实收金额;
End Zl_Actualmoney;
/

--92410:刘尔旋,2016-01-05,费用状态调整
Create Or Replace Procedure Zl_门诊转住院_三方卡结算
(
  No_In         住院费用记录.No%Type,
  操作员编号_In 住院费用记录.操作员编号%Type,
  操作员姓名_In 住院费用记录.操作员姓名%Type,
  退费时间_In   住院费用记录.发生时间%Type,
  门诊退费_In   Number := 0,
  入院科室id_In 住院费用记录.开单部门id%Type := Null,
  主页id_In     住院费用记录.主页id%Type := Null,
  三方退费_In   Number := 0,
  结帐id_In     病人预交记录.结帐id%Type := Null
) As
  v_结帐ids    Varchar2(3000);
  n_组id       财务缴款分组.Id%Type;
  n_退现       Number;
  v_预交no     病人预交记录.No%Type;
  n_结帐id     门诊费用记录.结帐id%Type;
  v_Nos        Varchar2(3000);
  v_Info       Varchar2(5000);
  v_当前结算   Varchar2(3000);
  v_原结帐ids  Varchar2(5000);
  n_Tempid     病人预交记录.Id%Type;
  v_流水号     病人预交记录.交易流水号%Type;
  v_说明       病人预交记录.交易说明%Type;
  n_预交id     病人预交记录.Id%Type;
  n_原预交id   病人预交记录.Id%Type;
  n_病人id     病人信息.病人id%Type;
  n_原结帐id   病人预交记录.结帐id%Type;
  n_冲销金额   病人预交记录.冲预交%Type;
  n_卡序号     病人预交记录.卡类别id%Type;
  n_三方卡     Number;
  n_返回值     人员缴款余额.余额%Type;
  v_结算方式   病人预交记录.结算方式%Type;
  n_卡类别id   医疗卡类别.Id%Type;
  v_卡号       病人预交记录.卡号%Type;
  v_交易流水号 病人预交记录.交易流水号%Type;
  v_交易说明   病人预交记录.交易说明%Type;
  n_原样退     Number;
  Err_Item Exception;
  v_Err_Msg Varchar2(200);
  Procedure Zl_Square_Update
  (
    结帐ids_In    Varchar2,
    现结帐id_In   病人预交记录.结帐id%Type,
    缴款组id_In   病人预交记录.缴款组id%Type,
    退款时间_In   病人预交记录.收款时间%Type,
    结算序号_In   病人预交记录.结算序号%Type,
    结算内容_In   Varchar2 := Null,
    退费金额_In   病人预交记录.冲预交%Type := Null,
    结算卡序号_In 病人预交记录.结算卡序号%Type := Null
  ) As
    n_记录状态 病人卡结算记录.记录状态%Type;
    n_预交id   病人预交记录.Id%Type;
    v_卡号     病人卡结算记录.卡号%Type;
    n_存在卡片 Number;
    d_停用日期 消费卡目录.停用日期%Type;
    n_最大序号 病人卡结算记录.序号%Type;
    n_序号     病人卡结算记录.序号%Type;
    n_余额     消费卡目录.余额%Type;
    n_接口编号 病人卡结算记录.接口编号%Type;
    d_回收时间 消费卡目录.回收时间%Type;
    n_Id       病人预交记录.Id%Type;
  Begin
    n_预交id := 0;
  
    --处理消费卡,结算卡在上面就已经处理了
    For v_校对 In (Select Min(a.Id) As 预交id, c.消费卡id, Sum(c.结算金额) As 结算金额, c.接口编号, c.卡号, Min(c.序号) As 序号, Min(c.Id) As ID
                 From 病人预交记录 A, 病人卡结算对照 B, 病人卡结算记录 C
                 Where a.Id = b.预交id And a.结算卡序号 = 结算卡序号_In And b.卡结算id = c.Id And a.记录性质 = 3 And
                       Instr(Nvl(结算内容_In, '_LXH'), ',' || a.结算方式 || ',') = 0 And
                       a.结帐id In (Select Column_Value From Table(f_Str2list(结帐ids_In)))
                 Group By c.消费卡id, c.接口编号, c.卡号) Loop
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id = Nvl(v_校对.消费卡id, 0) And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      Else
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id Is Null And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      End If;
    
      If n_记录状态 = 1 Then
        n_记录状态 := 2;
      Else
        n_记录状态 := n_记录状态 + 2;
      End If;
      --多条时,只更新一条
      If n_预交id = 0 Then
        Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id,
           预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
          Select n_预交id, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, 退款时间_In, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
                 -1 * 退费金额_In, 现结帐id_In, 缴款组id_In, 预交类别, 卡类别id, Nvl(结算卡序号, v_校对.接口编号), 卡号, 交易流水号, 交易说明, 合作单位, 2, 结算序号_In,
                 结算性质
          From 病人预交记录 A
          Where ID = v_校对.预交id;
      End If;
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        --消费卡,直接退回卡数据中
        Begin
          Select 卡号, 1, 停用日期, (Select Max(序号) From 消费卡目录 B Where a.卡号 = b.卡号 And a.接口编号 = b.接口编号), 序号, 余额, 接口编号, 回收时间
          Into v_卡号, n_存在卡片, d_停用日期, n_最大序号, n_序号, n_余额, n_接口编号, d_回收时间
          From 消费卡目录 A
          Where ID = v_校对.消费卡id;
        Exception
          When Others Then
            n_存在卡片 := 0;
        End;
      
        --取消停用
        If n_存在卡片 = 0 Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡被他人删除，不能再启用该卡片,请检查！';
          Raise Err_Item;
        End If;
        If Nvl(n_序号, 0) < Nvl(n_最大序号, 0) Then
          v_Err_Msg := '不能启用历史发卡记录(卡号为"' || v_卡号 || '"),请检查！';
          Raise Err_Item;
        End If;
        If Nvl(d_停用日期, To_Date('3000-01-01', 'yyyy-mm-dd')) < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经被他人停用，不能再进行退费,请检查！';
          Raise Err_Item;
        End If;
      
        If d_回收时间 < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经回收，不能退费,请检查！';
          Raise Err_Item;
        End If;
        Update 消费卡目录 Set 余额 = Nvl(余额, 0) + 退费金额_In Where ID = Nvl(v_校对.消费卡id, 0);
      End If;
    
      Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      Insert Into 病人卡结算记录
        (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Select n_Id, 接口编号, 消费卡id, 序号, n_记录状态, 结算方式, -1 * 退费金额_In, 卡号, 交易流水号, 交易时间, 备注,
               Decode(消费卡id, Null, 0, 0, 0, 1) As 标志
        From 病人卡结算记录
        Where ID = v_校对.Id;
      Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
    
      If n_记录状态 <> 2 And n_记录状态 <> 1 Then
        Update 病人卡结算记录 Set 记录状态 = 3 Where ID = v_校对.Id;
      End If;
    End Loop;
  End;
Begin
  n_组id := Zl_Get组id(操作员姓名_In);
  If 结帐id_In Is Null Then
    Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  Else
    n_结帐id := 结帐id_In;
  End If;

  Select 结帐id, 病人id
  Into n_原结帐id, n_病人id
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Rownum < 2;

  For r_结账id In (Select Distinct 结帐id
                 From 门诊费用记录
                 Where NO In (Select Distinct NO
                              From 门诊费用记录
                              Where 结帐id In (Select 结帐id
                                             From 病人预交记录
                                             Where 结算序号 In (Select b.结算序号
                                                            From 门诊费用记录 A, 病人预交记录 B
                                                            Where a.No = No_In And b.结算序号 < 0 And Mod(a.记录性质, 10) = 1 And
                                                                  a.记录状态 <> 0 And a.结帐id = b.结帐id))) And
                       Mod(记录性质, 10) = 1 And 记录状态 <> 0
                 Union
                 Select Distinct 结帐id
                 From 门诊费用记录
                 Where NO In (Select Distinct NO
                              From 门诊费用记录
                              Where 结帐id In (Select a.结帐id
                                             From 门诊费用记录 A, 病人预交记录 B
                                             Where a.No = No_In And b.结算序号 > 0 And Mod(a.记录性质, 10) = 1 And a.记录状态 <> 0 And
                                                   a.结帐id = b.结帐id))) Loop
    v_原结帐ids := v_原结帐ids || ',' || r_结账id.结帐id;
  End Loop;
  v_原结帐ids := Substr(v_原结帐ids, 2);

  Begin
    Select 摘要
    Into v_Info
    From 病人预交记录
    Where 结算方式 Is Null And 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id;
  Exception
    When Others Then
      v_Info := '';
  End;
  --处理卡结算信息
  If v_Info Is Not Null Then
    While v_Info Is Not Null Loop
      v_当前结算 := Substr(v_Info, 1, Instr(v_Info, '|') - 1);
      n_三方卡   := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
      n_卡序号   := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
      n_冲销金额 := -1 * To_Number(v_当前结算);
    
      If n_三方卡 = 0 Then
        --消费卡
        Select 结算方式
        Into v_结算方式
        From 病人预交记录
        Where 结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And 结算卡序号 = n_卡序号 And Rownum < 2;
        Zl_Square_Update(v_原结帐ids, n_结帐id, n_组id, 退费时间_In, -1 * n_结帐id, Null, n_冲销金额, n_卡序号);
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) - n_冲销金额
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
        Returning 余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (操作员姓名_In, v_结算方式, 1, -1 * n_冲销金额);
          n_返回值 := n_冲销金额;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式 And Nvl(余额, 0) = 0;
        End If;
      Else
        --结算卡
        Select 结算方式, 卡类别id, 卡号, 交易流水号, 交易说明
        Into v_结算方式, n_卡类别id, v_卡号, v_交易流水号, v_交易说明
        From 病人预交记录
        Where 结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And 卡类别id = n_卡序号 And Rownum < 2;
        If Nvl(门诊退费_In, 0) = 1 Then
          If 三方退费_In = 0 Then
            v_Err_Msg := '存在无法退现的三方账户,无法进行退费!';
            Raise Err_Item;
          End If;
          Update 病人预交记录
          Set 冲预交 = 冲预交 - n_冲销金额
          Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 = v_结算方式;
          If Sql%RowCount = 0 Then
            Insert Into 病人预交记录
              (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
               缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
            Values
              (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * n_冲销金额, v_结算方式, Null, 退费时间_In,
               Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, n_卡类别id, Null, v_卡号, v_交易流水号, v_交易说明, Null, n_结帐id,
               -1 * n_结帐id, 0, 3);
          End If;
          Update 人员缴款余额
          Set 余额 = Nvl(余额, 0) - n_冲销金额
          Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
          Returning 余额 Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 人员缴款余额
              (收款员, 结算方式, 性质, 余额)
            Values
              (操作员姓名_In, v_结算方式, 1, -1 * n_冲销金额);
            n_返回值 := -1 * n_冲销金额;
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 人员缴款余额
            Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式 And Nvl(余额, 0) = 0;
          End If;
        Else
          Begin
            Select 1 Into n_退现 From 医疗卡类别 Where ID = n_卡类别id And 是否退现 = 1;
          Exception
            When Others Then
              n_退现 := 0;
          End;
        
          If 三方退费_In = 1 Or n_退现 = 0 Then
            v_结算方式 := v_结算方式;
            n_原样退   := 1;
          Else
            n_原样退 := 0;
            Begin
              Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And 名称 Like '%现金%' And Rownum < 2;
            Exception
              When Others Then
                Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
            End;
          End If;
        
          If 三方退费_In = 0 Then
            If n_原样退 = 1 Then
              Select 交易流水号, 交易说明, ID
              Into v_流水号, v_说明, n_原预交id
              From 病人预交记录
              Where 结帐id = n_原结帐id And 结算方式 = v_结算方式 And Rownum < 2;
            
              Update 病人预交记录
              Set 冲预交 = 冲预交 - n_冲销金额
              Where 记录性质 = 3 And 记录状态 = 2 And 收款时间 = 退费时间_In And 病人id + 0 = n_病人id And 结算方式 = v_结算方式 And 结帐id = n_结帐id;
              If Sql%RowCount = 0 Then
                Insert Into 病人预交记录
                  (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                   摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
                Values
                  (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * n_冲销金额, v_结算方式, Null, 退费时间_In,
                   Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, n_卡类别id, Null, v_卡号, v_交易流水号, v_交易说明, Null, n_结帐id,
                   -1 * n_结帐id, 0, 3);
              End If;
            
              Update 病人预交记录
              Set 金额 = 金额 + n_冲销金额
              Where 记录性质 = 1 And 记录状态 = 1 And 收款时间 = 退费时间_In And 病人id + 0 = n_病人id And 结算方式 = v_结算方式;
              If Sql%RowCount = 0 Then
                v_预交no := Nextno(11);
                Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
                Insert Into 病人预交记录
                  (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                   摘要, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位)
                Values
                  (n_预交id, v_预交no, Null, 1, 1, n_病人id, 主页id_In, 入院科室id_In, n_冲销金额, v_结算方式, Null, 退费时间_In, Null, Null,
                   Null, 操作员编号_In, 操作员姓名_In, '门诊转住院预交', n_组id, 2, n_卡类别id, Null, v_卡号, v_流水号, v_说明, Null);
                Update 三方结算交易 Set 交易id = n_预交id Where 交易id = n_原预交id;
              End If;
            Else
              Update 病人预交记录
              Set 冲预交 = 冲预交 - n_冲销金额
              Where 记录性质 = 3 And 记录状态 = 2 And 收款时间 = 退费时间_In And 病人id + 0 = n_病人id And 结算方式 = v_结算方式 And 结帐id = n_结帐id;
              If Sql%RowCount = 0 Then
                Insert Into 病人预交记录
                  (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                   摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
                Values
                  (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * n_冲销金额, v_结算方式, Null, 退费时间_In,
                   Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, Null, Null, Null, Null, Null, Null, n_结帐id,
                   -1 * n_结帐id, 0, 3);
              End If;
            
              Update 病人预交记录
              Set 金额 = 金额 + n_冲销金额
              Where 记录性质 = 1 And 记录状态 = 1 And 收款时间 = 退费时间_In And 病人id + 0 = n_病人id And 结算方式 = v_结算方式;
              If Sql%RowCount = 0 Then
                v_预交no := Nextno(11);
                Insert Into 病人预交记录
                  (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                   摘要, 缴款组id, 预交类别)
                Values
                  (病人预交记录_Id.Nextval, v_预交no, Null, 1, 1, n_病人id, 主页id_In, 入院科室id_In, n_冲销金额, v_结算方式, Null, 退费时间_In,
                   Null, Null, Null, 操作员编号_In, 操作员姓名_In, '门诊转住院预交', n_组id, 2);
              End If;
            End If;
          
            --病人余额
            Update 病人余额
            Set 预交余额 = Nvl(预交余额, 0) + n_冲销金额
            Where 性质 = 1 And 病人id = n_病人id And 类型 = 2
            Returning 预交余额 Into n_返回值;
            If Sql%RowCount = 0 Then
              Insert Into 病人余额 (病人id, 性质, 类型, 预交余额, 费用余额) Values (n_病人id, 1, 2, n_冲销金额, 0);
              n_返回值 := n_冲销金额;
            End If;
            If Nvl(n_返回值, 0) = 0 Then
              Delete From 病人余额
              Where 病人id = n_病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
            End If;
          End If;
          --4.2缴款数据处理
          --   因为没有实际收病人的钱,所以不处理
          --部分退费情况，退原预交记录
          If 三方退费_In = 1 Then
            Update 人员缴款余额
            Set 余额 = Nvl(余额, 0) - n_冲销金额
            Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
            Returning 余额 Into n_返回值;
            If Sql%RowCount = 0 Then
              Insert Into 人员缴款余额
                (收款员, 结算方式, 性质, 余额)
              Values
                (操作员姓名_In, v_结算方式, 1, -1 * n_冲销金额);
              n_返回值 := -1 * n_冲销金额;
            End If;
            If Nvl(n_返回值, 0) = 0 Then
              Delete From 人员缴款余额
              Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式 And Nvl(余额, 0) = 0;
            End If;
            Update 病人预交记录
            Set 冲预交 = 冲预交 + (-1 * n_冲销金额)
            Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 = v_结算方式;
            If Sql%RowCount = 0 Then
              Insert Into 病人预交记录
                (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
                 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
              Values
                (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * n_冲销金额, v_结算方式, Null, 退费时间_In,
                 Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, n_卡类别id, Null, v_卡号, v_交易流水号, v_交易说明, Null, n_结帐id,
                 -1 * n_结帐id, 0, 3);
            End If;
          End If;
        End If;
      End If;
      v_Info := Substr(v_Info, Instr(v_Info, '|') + 1);
    End Loop;
  End If;

  Delete From 病人预交记录 Where 结帐id = n_结帐id And 记录状态 = 2 And 结算方式 Is Null;
  Update 门诊费用记录 Set 费用状态 = 0 Where 结帐id = n_结帐id;
  Update 门诊费用记录 Set 费用状态 = 0 Where NO = No_In And Mod(记录性质, 10) = 1 And 记录状态 = 2;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊转住院_三方卡结算;
/

--91903:蔡青松,2015-12-28,将已审核但未采样的微生物医嘱的执行状态改为已执行
CREATE OR REPLACE Procedure Zl_检验标本记录_报告审核
(
  Id_In       检验标本记录.Id%Type,
  审核人_In   检验标本记录.审核人%Type := Null,
  人员编号_In 人员表.编号%Type := Null,
  人员姓名_In 人员表.姓名%Type := Null
) Is

  --未审核的费用行(不包含药品)
  Cursor c_Verify(v_医嘱id In Number) Is
    Select Distinct 记录性质, NO, 序号
    From 住院费用记录
    Where 收费类别 Not In ('5', '6', '7') And 记帐费用 = 1 And 价格父号 Is Null And
          (记录性质, NO) In (Select 记录性质, NO
                         From 病人医嘱附费
                         Where 医嘱id = v_医嘱id
                         Union All
                         Select 记录性质, NO
                         From 病人医嘱发送
                         Where 医嘱id In (Select ID From 病人医嘱记录 Where v_医嘱id In (ID, 相关id))) And 医嘱序号 = v_医嘱id
    Union All
    Select Distinct 记录性质, NO, 序号
    From 门诊费用记录
    Where 收费类别 Not In ('5', '6', '7') And 记帐费用 = 1 And 价格父号 Is Null And
          (记录性质, NO) In (Select 记录性质, NO
                         From 病人医嘱附费
                         Where 医嘱id = v_医嘱id
                         Union All
                         Select 记录性质, NO
                         From 病人医嘱发送
                         Where 医嘱id In (Select ID From 病人医嘱记录 Where v_医嘱id In (ID, 相关id))) And 医嘱序号 = v_医嘱id
    Order By 记录性质, NO, 序号;

  --查找当前标本的相关申请
  Cursor c_Samplequest(v_微生物 In Number) Is
    Select Distinct 医嘱id, 病人来源
    From (Select a.医嘱id, b.病人来源
           From 检验项目分布 A, 检验标本记录 B
           Where 0 = v_微生物 And a.标本id = Id_In And a.医嘱id Is Not Null And a.标本id = b.Id
           Union
           Select a.医嘱id, b.病人来源
           From 检验项目分布 A, 检验标本记录 B
           Where 1 = v_微生物 And a.标本id = Id_In And a.医嘱id Is Not Null And a.标本id = b.Id
           Union
           Select b.Id As 医嘱id, a.病人来源
           From 检验标本记录 A, 病人医嘱记录 B
           Where a.Id = Id_In And a.医嘱id = b.相关id);

  Cursor c_Stuff
  (
    v_No     Varchar2,
    v_主页id Number
  ) Is
    Select NO, 单据, 库房id
    From 未发药品记录
    Where NO = v_No And 单据 In (24, 25, 26) And 库房id Is Not Null And Not Exists
     (Select 1 From Dual Where zl_GetSysParameter(Decode(v_主页id, Null, 92, 63)) = '1') And Exists
     (Select a.序号
           From 住院费用记录 A, 材料特性 B
           Where a.记录性质 = 2 And a.记录状态 = 1 And a.No = v_No And a.收费细目id = b.材料id And b.跟踪在用 = 1
           Union All
           Select a.序号
           From 门诊费用记录 A, 材料特性 B
           Where a.记录性质 = 2 And a.记录状态 = 1 And a.No = v_No And a.收费细目id = b.材料id And b.跟踪在用 = 1)
    Order By 库房id;

  v_执行 Number(1);
  v_No   病人医嘱发送.No%Type;
  v_性质 病人医嘱发送.记录性质%Type;
  v_序号 Varchar2(1000);

  v_Count Number(18);

  v_微生物标本 Number(1) := 0;
  v_主页id     Number(18);
  v_婴儿       Number(1);
  v_年龄       Varchar2(100);
  v_仪器       Number(18);
  v_Intloop    Number;
  Err_Custom Exception;
  v_Error Varchar2(100);
Begin
  Select Nvl(婴儿, 0), 年龄 Into v_婴儿, v_年龄 From 检验标本记录 Where ID = Id_In;

  --执行后自动审核对应的记帐划价单(不包含药品)
  Select Zl_To_Number(Nvl(zl_GetSysParameter(81), '0')) Into v_执行 From Dual;

  v_微生物标本 := 0;
  Begin
    Select 1 Into v_微生物标本 From 检验标本记录 Where 微生物标本 = 1 And ID = Id_In;
  Exception
    When Others Then
      v_微生物标本 := 0;
  End;

  --1.置本标本的状态及审核人和时间
  Update 检验标本记录
  Set 审核人 = Decode(审核人_In, Null, 人员姓名_In, 审核人_In), 审核时间 = Sysdate, 样本状态 = 2
  Where ID = Id_In;

  --记录审核过程
  Insert Into 检验操作记录
    (ID, 标本id, 操作类型, 操作员, 操作时间)
  Values
    (检验操作记录_Id.Nextval, Id_In, 0, Decode(审核人_In, Null, 人员姓名_In, 审核人_In), Sysdate);

  --2.检查当前标本相关的申请的相关标本是否完成审核
  For r_Samplequest In c_Samplequest(v_微生物标本) Loop

    v_Count := 0;

    If v_微生物标本 = 0 Then
      Begin
        Select Nvl(Count(1), 0)
        Into v_Count
        From 检验标本记录
        Where 样本状态 < 2 And ID In (Select 标本id From 检验项目分布 Where 医嘱id = r_Samplequest.医嘱id);
      Exception
        When Others Then
          v_Count := 0;
      End;
    End If;

    --r_SampleQuest.医嘱id申请已经完成,处理后续环节
    If v_Count = 0 Then

      --1.置申请单的执行状态
      Update 病人医嘱发送
      Set 执行状态 = 1, 完成人 = 人员姓名_In, 完成时间 = Sysdate
      Where 医嘱id In (Select ID From 病人医嘱记录 Where r_Samplequest.医嘱id In (ID, 相关id));
      
      update 病人医嘱发送
      Set 执行状态 = 1, 完成人 = 人员姓名_In, 完成时间 = Sysdate
      Where 医嘱id In (select 相关ID from 病人医嘱记录 where ID in(Select ID From 病人医嘱记录 Where r_Samplequest.医嘱id In (ID, 相关id)));

      If r_Samplequest.病人来源 = 2 Then
        --2.费用执行处理
        Update 住院费用记录
        Set 执行状态 = 1, 执行时间 = Sysdate, 执行人 = 人员姓名_In
        Where 收费类别 Not In ('5', '6', '7') And
              (医嘱序号, 记录性质, NO) In
              (Select 医嘱id, 记录性质, NO
               From 病人医嘱附费
               Where 医嘱id = r_Samplequest.医嘱id
               Union All
               Select 医嘱id, 记录性质, NO
               From 病人医嘱发送
               Where 医嘱id In (Select ID From 病人医嘱记录 Where r_Samplequest.医嘱id In (ID, 相关id)));
      Else
        Update 门诊费用记录
        Set 执行状态 = 1, 执行时间 = Sysdate, 执行人 = 人员姓名_In
        Where 收费类别 Not In ('5', '6', '7') And
              (医嘱序号, 记录性质, NO) In
              (Select 医嘱id, 记录性质, NO
               From 病人医嘱附费
               Where 医嘱id = r_Samplequest.医嘱id
               Union All
               Select 医嘱id, 记录性质, NO
               From 病人医嘱发送
               Where 医嘱id In (Select ID From 病人医嘱记录 Where r_Samplequest.医嘱id In (ID, 相关id)));
      End If;

      --3.自动审核记帐
      If v_执行 = 1 Then
        For r_Verify In c_Verify(r_Samplequest.医嘱id) Loop
          If r_Verify.No || ',' || r_Verify.记录性质 <> v_No || ',' || v_性质 Then
            If v_序号 Is Not Null Then
              If v_性质 = 1 Then
                Zl_门诊记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
              Elsif v_性质 = 2 Then
                Zl_住院记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
              End If;
            End If;
            v_序号 := Null;
          End If;
          v_No   := r_Verify.No;
          v_性质 := r_Verify.记录性质;
          v_序号 := v_序号 || ',' || r_Verify.序号;
        End Loop;
        If v_序号 Is Not Null Then
          If v_性质 = 1 Then
            Zl_门诊记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
          Elsif v_性质 = 2 Then
            Zl_住院记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
          End If;
          v_序号 := Null;
        End If;
      End If;

      --审核试剂消耗单
      v_Intloop := 1;
      v_No      := Null;
      Select 仪器id Into v_仪器 From 检验标本记录 Where ID = Id_In;
      For r_检验试剂 In (Select c.材料id, c.数量
                     From 病人医嘱记录 A, 检验报告项目 B, 检验试剂关系 C
                     Where a.相关id = r_Samplequest.医嘱id And a.诊疗项目id = b.诊疗项目id And b.报告项目id = c.项目id And c.仪器id = v_仪器) Loop
        Zl_检验试剂记录_Insert(r_Samplequest.医嘱id, v_Intloop, r_检验试剂.材料id, r_检验试剂.数量);
        v_Intloop := v_Intloop + 1;
      End Loop;
      Select Count(*) Into v_Intloop From 检验试剂记录 Where 医嘱id = r_Samplequest.医嘱id And NO Is Null;
      If v_Intloop > 1 Then
        v_No := Nextno(14);
        Update 检验试剂记录 Set NO = v_No Where 医嘱id = r_Samplequest.医嘱id;
      End If;
      If v_No Is Not Null Then

        Zl_检验试剂记录_Bill(r_Samplequest.医嘱id, v_No);

        v_主页id := Null;
        Select 主页id Into v_主页id From 病人医嘱记录 A Where ID = r_Samplequest.医嘱id;

        If v_主页id Is Null Then
          Zl_门诊记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In);
        Else
          Zl_住院记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In);
        End If;

        --如果记帐没有自动发料,则自动发料,否则不处理
        For r_Stuff In c_Stuff(v_No, v_主页id) Loop
          Zl_材料收发记录_处方发料(r_Stuff.库房id, 25, v_No, 人员姓名_In, 人员姓名_In, 人员姓名_In, 1, Sysdate);
        End Loop;
      End If;
    End If;
  End Loop;
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 9, 0 || ',' || Id_In;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_检验标本记录_报告审核;
/

--92258:许华峰,2015-12-31,缩略图插件中显示报告图象
--92392:许华峰,2016-01-05,将缩略图插件中的sql查询语句写入包中，同一管理
--影像报告插件管理(---定义部分---)***************************************************
CREATE OR REPLACE Package b_PACS_RptPluginOriginal Is
  Type t_Refcur Is Ref Cursor;

  -- 功    能：获取历史报告记录
  Procedure p_GetReportHistory(
    Val                   Out t_Refcur,
    医嘱id_In             In 病人医嘱记录.ID%Type,
    人员id_In             In 部门人员.人员id%Type,
    当前科室id_In         In 部门人员.部门ID%Type,
    查看其他科历史报告_In In number := 0
  );

  --功    能：获取对应报告内容
  Procedure p_GetReportContent(
    Val           Out t_Refcur,
    报告ID_In     In varchar2,
    EditorType_In Number := 0 --0:PACS报告编辑器，1--电子病历编辑器，2--报告文档编辑器
    );

  --功    能：根据医嘱ID获取检查信息
  Procedure p_GetStudyInfoByAdviceId(
    Val       Out t_Refcur,
    医嘱id_In In 影像检查记录.医嘱id%Type
  );

  --功    能：获取报告图像总数
  Procedure p_GetReportImageCount(
    Val Out t_Refcur,
    查询条件_In In varchar2
  );

  --功    能：获取报告图像数据
  Procedure p_GetReportImageData(
    Val         Out t_Refcur,
    查询条件_In In varchar2,
    开始位置_In In number,
    结束位置_In In number
  );

  --功    能：获取预览图像总数
  Procedure p_GetStudyImageCount(
    Val Out t_Refcur,
    查询条件_In In varchar2,
    是否临时_In In number:=0
  );

  --功    能：获取预览图像数据
  Procedure p_GetStudyImageData(
    Val         Out t_Refcur,
    查询方式_In In varchar2,
    查询条件_In In varchar2,
    开始位置_In In number,
    结束位置_In In number,
    是否临时_In In number
  );

  --功能：获取临时图像序列
  Procedure p_Get_TempImageSeries(
    Val         Out t_Refcur,
    时间范围_In In Number,
    姓名_In In 影像临时记录.姓名%Type:=null
  );

  --功能;获取图像备注
  procedure P_Get_NormalNote(
    Val         Out t_Refcur
  );

  --功能：插入常用图像备注
  Procedure p_Insert_Normalnote(
    note_in in 影像字典内容.名称%Type,
    code_In 影像字典内容.简码%Type
  );

  --功能：修改常用图像备注
  Procedure p_Edit_Normalnote(
    note_in In 影像字典内容.名称%Type,
    num_In  影像字典内容.编号%Type
  );

  --功能：删除常用图像备注
  Procedure p_Del_Normalnote(
    num_In 影像字典内容.编号%Type
  );

  --功能：获取备注的下一个编码
  Procedure p_Get_NormalNum(
    Val Out t_Refcur
  );
  --功能：获取插件ID
  Procedure p_Get_PlugID(
    Val     Out t_Refcur,
    类名_In In 影像报告插件.类名%Type
  );

  --功能：插入编辑器字体参数
  Procedure p_SetFontParam(
    font_In nvarchar2,
    user_In nvarchar2
  );

  --功能：获取编辑器字体参数
  Procedure p_GetFontParam(
    Val Out t_Refcur,
    user_In nvarchar2
  );

  --功能：插入编辑器窗体参数
  Procedure p_SetFormParam(
    form_In nvarchar2,
    user_In nvarchar2
  );

  --功能：获取编辑器字体参数
  Procedure p_GetFormParam(
    Val Out t_Refcur,
    user_In nvarchar2
  );
  
  --功能：根据图像UID获取检查信息
  Procedure p_GetStudyInfoByImageUID(
    Val Out t_Refcur,
    医嘱ID_In In 影像检查记录.医嘱ID%Type,
    图像UID_In In 影像检查图象.图像UID%Type
  );
  
  --功能：根据检查UID获取FTP信息
  Procedure p_GetFtpinfoByStudyUID(
    Val Out t_Refcur,
    检查UID_In In 影像检查记录.检查UID%Type
  );
  
  --功能：根据科室ID获取FTP信息
  Procedure p_GetFtpinfoByDeptId(
    Val Out t_Refcur,
    科室ID_In In 影像流程参数.科室ID%Type
  );
  
  --功能：根据医嘱ID获取FTP信息
  Procedure p_GetFtpinfoByAdvicetId(
    Val Out t_Refcur,
    医嘱ID_In In 影像检查记录.医嘱ID%Type
  );
  
  --功能：获取检查UID
  Procedure p_GetStudyUID(
    Val Out t_Refcur,
    检查UID_In In 影像检查记录.检查UID%Type
  );
  
  --功能：获取序列UID
  Procedure p_GetSeriesUID(
    Val Out t_Refcur,
    序列UID_In In 影像检查序列.序列UID%Type
  );
  
  --功能：根据设备号获取设备信息
  Procedure p_GetDeviceInfo(
    Val Out t_Refcur,
    设备号_In In 影像设备目录.设备号%Type
  );
  
  --获取医技站存储设备号
  Procedure p_GetDeviceIdByAdviceId(
    Val Out t_Refcur,
    医嘱ID_In In 病人医嘱发送.医嘱ID%Type
  );
End b_PACS_RptPluginOriginal;
/

--影像报告范文管理(---实现部分---)***************************************************
CREATE OR REPLACE Package Body b_PACS_RptPluginOriginal Is

  --功    能：获取历史报告记录
  Procedure p_GetReportHistory(
    Val                   Out t_Refcur,
    医嘱id_In             In 病人医嘱记录.ID%Type,
    人员id_In             In 部门人员.人员id%Type,
    当前科室id_In         In 部门人员.部门ID%Type,
    查看其他科历史报告_In In number := 0
  ) Is
    strSql     varchar2(4000);
    strSqlBack varchar2(4000);
    strFilter  varchar2(400);
  Begin
    If 查看其他科历史报告_In = 1 Then
      strFilter := ' ';
    Else
      strFilter := ' And c.执行科室id+0 in (select 部门id from 部门人员 where 人员id = '|| 人员id_In ||
                   ' union all select to_Number(' || 当前科室id_In || ') from dual) ';
    End If;

    strSql := 'Select 2 as 报告类型, f.编码'||'||''-''||'||'f.名称 As 科室名称, c.Id As 医嘱id, a.影像类别 as 类别,b.创建人 as 报告人,' ||
              'to_char(b.创建时间,''yyyy-mm-dd hh24:mi:ss'') as 创建时间,b.文档标题 报告名称, c.医嘱内容, TO_CHAR(RAWTOHEX(b.id)) 报告ID ' ||
              'From 影像检查记录 A, 影像报告记录 B, 病人医嘱记录 C, 影像检查记录 D, 病人医嘱记录 E, 部门表 F ' ||
              'Where a.医嘱id = b.医嘱id And d.医嘱id = e.Id And e.Id =' ||
              医嘱id_In || ' And e.执行科室ID = F.ID And b.医嘱id = c.Id And ' ||
              '(c.病人id = e.病人id Or a.关联id = d.关联id) And c.相关id Is Null ' || strFilter ||
              ' union all ' ||
              'Select 1 as 报告类型, g.编码'||'||''-''||'||'g.名称 As 科室名称, c.Id As 医嘱id, a.影像类别 as 类别, a.报告人, ' ||
              'to_char(f.创建时间,''yyyy-mm-dd hh24:mi:ss'') as 创建时间, a.影像类别||''报告'' 报告名称, c.医嘱内容,TO_CHAR( b.病历id) as 报告ID ' ||
              'From 影像检查记录 A, 病人医嘱报告 B, 病人医嘱记录 C, 影像检查记录 D, 病人医嘱记录 E, 电子病历记录 F, 部门表 G ' ||
              'Where a.医嘱id = b.医嘱id And d.医嘱id = e.Id And e.Id = ' ||
              医嘱id_In || ' And e.执行科室ID = g.ID And b.医嘱id = c.Id And b.病历ID Is Not Null And ' ||
              '(c.病人id = e.病人id Or a.关联id = d.关联id) And c.相关id Is Null And b.病历id = f.id ' || strFilter;

    strSqlBack := strSql;
    strSqlBack := replace(strSqlBack, '影像检查记录', 'H影像检查记录');
    strSqlBack := replace(strSqlBack, '病人医嘱报告', 'H病人医嘱报告');
    strSqlBack := replace(strSqlBack, '病人医嘱记录', 'H病人医嘱记录');

    strSql := strSql || ' UNION ALL ' || strSQLBack || ' Order By 创建时间 Asc';

    Open Val For strSql;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetReportHistory;

  --功    能：获取对应报告内容
  Procedure p_GetReportContent(
    Val           Out t_Refcur,
    报告ID_In     varchar2,
    EditorType_In Number := 0 --0:电子病历编辑器，1--PACS报告编辑器，2--报告文档编辑器
    ) Is
    strSql varchar2(1000);
  Begin
    If EditorType_In = 1 Then
      strSql := 'Select a.内容文本 As 标题, b.对象属性, b.内容文本 As 正文,b.开始版 as 版本 From 电子病历内容 a,电子病历内容 b ' ||
                'Where a.文件id = ' || 报告ID_In ||
                ' And a.对象类型 = 3 And a.Id = b.父ID And b.对象类型 = 2 and b.终止版=0 ';
    ElsIf EditorType_In = 0 Then
      strSql := 'select 内容 from 电子病历格式 where 文件ID=' || 报告ID_In;
    Else
      strSql := 'Select 报告内容 As 内容 From 影像报告记录 Where ID=HexToRaw(''' ||
                报告ID_In || ''')';
    End If;

    Open Val For strSql;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetReportContent;

  --功    能：根据医嘱ID获取检查信息
  Procedure p_GetStudyInfoByAdviceId(
    Val       Out t_Refcur,
    医嘱id_In In 影像检查记录.医嘱id%Type
  ) Is
    strSql varchar2(100);
  Begin
    strSql := 'Select 检查UID,报告图象,接收日期,检查号,姓名,性别,年龄 from 影像检查记录 where 医嘱ID =' || 医嘱id_In;
    Open Val For strSql;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetStudyInfoByAdviceId;

  --功    能：获取报告图像总数
  Procedure p_GetReportImageCount(
    Val Out t_Refcur,
    查询条件_In In varchar2
  ) Is
  Begin
    Open Val For
      Select Count(B.Column_Value) 返回值
      From 影像检查记录 A, Table(Cast(f_Str2list(Replace(A.报告图象,';',',')) As zlTools.t_Strlist)) B Where 医嘱ID = 查询条件_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetReportImageCount;

  --功    能：获取报告图像数据
  Procedure p_GetReportImageData(
    Val         Out t_Refcur,
    查询条件_In In varchar2,
    开始位置_In In number,
    结束位置_In In number
  ) Is
  Begin
    Open Val For
         Select * from (Select rownum as 顺序号, rownum as 图像号, B.FTP用户名 As User1,B.FTP密码 As Pwd1,B.IP地址 As Host1,'/'||B.Ftp目录||'/' As Root1,
          Decode(A.接收日期,Null,'',to_Char(A.接收日期,'YYYYMMDD')||'/')||A.检查UID||'/'||Replace(D.Column_Value,'.jpg','') As URL,B.设备号 as 设备号1,
          C.FTP用户名 As User2,C.FTP密码 As Pwd2,C.IP地址 As Host2,'/'||C.Ftp目录||'/' As Root2,
          C.设备号 as 设备号2,Replace(D.Column_Value,'.jpg','') AS 图像UID,A.检查UID,'' 序列UID,0 动态图,'' 编码名称,'' 采集时间, '' 录制长度
          From 影像检查记录 A, 影像设备目录 B, 影像设备目录 C, Table(Cast(f_Str2list(Replace(A.报告图象,';',',')) As zlTools.t_Strlist)) D
          Where A.位置一 = B.设备号(+) And A.位置二 = C.设备号(+) And A.医嘱id = 查询条件_In)
          Where 顺序号 >= 开始位置_In and 顺序号<=结束位置_In;

  End p_GetReportImageData;

  --功    能：获取预览图像总数
  Procedure p_GetStudyImageCount(
    Val Out t_Refcur,
    查询条件_In In varchar2,
    是否临时_In In number:=0
  ) Is
    strSql varchar2(2000);
  Begin
    if 是否临时_In = 0 then
      strSql := 'select T1.返回值+T2.返回值 as 返回值 from ' ||
              '(select count(1) as 返回值 from 影像检查图象 a, 影像检查序列 b, 影像检查记录 c ' ||
              'where a.序列UID=b.序列UID and b.检查UID=c.检查UID and c.医嘱ID=''' ||
              查询条件_In || ''') T1,' ||
              '(select count(1) as 返回值 from H影像检查图象 a, H影像检查序列 b, 影像检查记录 c ' ||
              'where a.序列UID=b.序列UID and b.检查UID=c.检查UID and c.医嘱ID=''' ||
              查询条件_In || ''') T2';
    else
      strSql := 'select count(1)  as 返回值 from 影像临时图象  where  序列UID='''||查询条件_In || '''';
    end if;

    Open Val For strSql;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetStudyImageCount;

  --功    能：获取预览图像数据
  Procedure p_GetStudyImageData(
    Val         Out t_Refcur,
    查询方式_In In varchar2,
    查询条件_In In varchar2,
    开始位置_In In number,
    结束位置_In In number,
    是否临时_In In number
  ) Is
    strSql    varchar2(2000);
    strFilter varchar2(100);
  Begin
    if 查询方式_In = 0 then
      strFilter := 'and c.医嘱ID=''' || 查询条件_In || '''';
    elsif 查询方式_In = 1 then
      strFilter := 'and B.序列UID=''' || 查询条件_In || '''';
    else
      strFilter := 'and A.图像UID=''' || 查询条件_In || '''';
    end if;

    strSql := 'Select * from (Select rownum as 顺序号, T.* from(' ||
              'Select A.图像号,D.FTP用户名 As User1,D.FTP密码 As Pwd1,D.IP地址 As Host1,''/''||D.Ftp目录||''/'' As Root1,' ||
              'Decode(C.接收日期,Null,'''',to_Char(C.接收日期,''YYYYMMDD'')||''/'')||C.检查UID||''/''||A.图像UID As URL,d.设备号 as 设备号1,' ||
              'E.FTP用户名 As User2,E.FTP密码 As Pwd2,E.IP地址 As Host2,''/''||E.Ftp目录||''/'' As Root2,' ||
              'e.设备号 as 设备号2, A.图像UID,C.检查UID,B.序列UID,A.动态图,A.编码名称,A.采集时间, A.录制长度 ' ||
              'From 影像检查图象 A,影像检查序列 B,影像检查记录 C,影像设备目录 D,影像设备目录 E ' ||
              'Where A.序列UID=B.序列UID And B.检查UID=C.检查UID And C.位置一=D.设备号(+) And C.位置二=E.设备号(+) ' ||
              strFilter || ' '|| 'Order by 序列UID, 图像号) T ) ' ||
              'Where 顺序号>=' || 开始位置_In || ' and 顺序号<=' || 结束位置_In || '';

    if 是否临时_In = 1 then
      strSql:= replace(strSql,'影像检查','影像临时');
    end if;

    Open Val For strSql;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetStudyImageData;

  --功能：获取临时图像序列
  Procedure p_Get_TempImageSeries(
    Val Out t_Refcur,
    时间范围_In In Number,
    姓名_In In 影像临时记录.姓名%Type:=null
  ) As
  Begin
    If 姓名_In Is Null Then
      Open Val For
        select B.序列UID,A.姓名,A.检查号 As 序号, A.接收日期 from 影像临时记录 A,影像临时序列 B
        where A.检查uid = B.检查uid And A.接收日期 Between Sysdate-时间范围_In And Sysdate
        order by 序号;
    Else
      Open Val For
        select B.序列UID,A.姓名,A.检查号 As 序号, A.接收日期 from 影像临时记录 A,影像临时序列 B
        where A.检查uid = B.检查uid And A.接收日期 Between Sysdate-时间范围_In And Sysdate and a.姓名 = 姓名_In
        order by 序号;
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --功能：获取图像备注
  Procedure p_Get_Normalnote(
    Val Out t_Refcur
  ) As
  Begin
    Open Val For
      Select b.编号 As 编号, b.名称 As 名称
        From 影像字典清单 A, 影像字典内容 B
       Where a.Id = b.字典id
         And a.名称 = '影像图像备注';
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --功能：插入常用图像备注
  Procedure p_Insert_Normalnote(
    note_in In 影像字典内容.名称%Type,
    code_In 影像字典内容.简码%Type
  ) As
    n_Num         Number;
    dictionary_id Varchar2(36);
  Begin
    Select id
      Into dictionary_id
      From 影像字典清单
     Where 说明 = '影像图像备注';
    Select Decode(Max(to_number(编号)), Null, 0, Max(to_number(编号)))
      Into n_Num
      From 影像字典内容
     Where 字典id = dictionary_id;
    n_Num := n_Num + 1;
    Insert Into 影像字典内容
      (字典id, 编号, 名称, 说明)
    Values
      (dictionary_id, to_char(n_Num), note_in, '影像图像备注');
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Insert_Normalnote;

  --功能：修改常用图像备注
  Procedure p_Edit_Normalnote(
    note_in In 影像字典内容.名称%Type,
    num_In  影像字典内容.编号%Type
  ) As
    dictionary_id Varchar2(36);
  Begin
    Select id
      Into dictionary_id
      From 影像字典清单
     Where 说明 = '影像图像备注';
    Update 影像字典内容 t
       Set t.名称 = note_in
     Where t.字典id = dictionary_id
       And t.编号 = num_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Normalnote;

  --功能：删除常用图像备注
  Procedure p_Del_Normalnote(
    num_In 影像字典内容.编号%Type
  ) As
    dictionary_id Varchar2(36);
  Begin
    Select id
      Into dictionary_id
      From 影像字典清单
     Where 说明 = '影像图像备注';
    Delete 影像字典内容 t
     Where t.字典id = dictionary_id
       And t.编号 = num_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Del_Normalnote;

  --功能：获取备注的下一个编码
  Procedure p_Get_NormalNum(
    Val Out t_Refcur
  ) As
    n_Num         Number;
    dictionary_id Varchar2(36);
  Begin
    Select id
      Into dictionary_id
      From 影像字典清单
     Where 说明 = '影像图像备注';
    Open Val For
      Select Decode(Max(to_number(编号)), Null, 1, Max(to_number(编号) + 1)) 编号
        From 影像字典内容 t
       Where t.字典id = dictionary_id;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_NormalNum;

  --功能：获取插件ID
  Procedure p_Get_PlugID(
    Val     Out t_Refcur,
    类名_In In 影像报告插件.类名%Type
  ) Is
  Begin
    Open Val For
      Select RawToHex(ID) ID From 影像报告插件 Where 类名 = 类名_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_PlugID;

  --功能：插入编辑器字体参数
  Procedure p_SetFontParam(
    font_In nvarchar2,
    user_In nvarchar2
  ) As
    m_ID     nvarchar2(36);
    numcount int;
  Begin
    Select RawToHex(ID)
      Into m_ID
      From 影像参数说明
     Where 模块 = 'ImageEditor'
       And 参数名 = '字体设置';
    Select Count(*)
      Into numcount
      From 影像参数取值 t
     Where t.参数id = m_ID
       And t.参数标识 = user_In;
    If numcount > 0 then
      Update 影像参数取值 a
         Set a.参数值 = font_In
       Where a.参数标识 = user_In
         And a.参数id = m_ID;
    Else
      Insert Into 影像参数取值 a
        (ID, 参数ID, 参数标识, 参数值)
      Values
        (sys_Guid(), m_ID, user_In, font_In);
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_SetFontParam;

  --功能：获取编辑器字体参数
  Procedure p_GetFontParam(
    Val Out t_Refcur,
    user_In nvarchar2
  ) As
    m_ID nvarchar2(36);
  Begin
    Select RawToHex(ID)
      Into m_ID
      From 影像参数说明
     Where 模块 = 'ImageEditor'
       And 参数名 = '字体设置';
    Open Val For
      Select a.参数值
        From 影像参数取值 a
       Where a.参数id = m_ID
         And a.参数标识 = user_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetFontParam;

  --功能：插入编辑器窗体参数
  Procedure p_SetFormParam(
    form_In nvarchar2,
    user_In nvarchar2
  ) As
    m_ID     nvarchar2(36);
    numcount int;
  Begin
    Select RawToHex(ID)
      Into m_ID
      From 影像参数说明
     Where 模块 = 'ImageEditor'
       And 参数名 = '窗口设置';
    Select Count(*)
      Into numcount
      From 影像参数取值 t
     Where t.参数id = m_ID
       And t.参数标识 = user_In;
    If numcount > 0 then
      Update 影像参数取值 a
         Set a.参数值 = form_In
       Where a.参数标识 = user_In
         And a.参数id = m_ID;
    Else
      Insert Into 影像参数取值 a
        (ID, 参数ID, 参数标识, 参数值)
      Values
        (sys_Guid(), m_ID, user_In, form_In);
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_SetFormParam;

  --功能：获取编辑器字体参数
  Procedure p_GetFormParam(
    Val Out t_Refcur,
    user_In nvarchar2
  ) As
    m_ID nvarchar2(36);
  Begin
    Select RawToHex(ID)
      Into m_ID
      From 影像参数说明
     Where 模块 = 'ImageEditor'
       And 参数名 = '窗口设置';
    Open Val For
      Select a.参数值
        From 影像参数取值 a
       Where a.参数id = m_ID
         And a.参数标识 = user_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetFormParam;
  
  --功能：根据图像UID获取检查信息
  Procedure p_GetStudyInfoByImageUID(
    Val Out t_Refcur,
    医嘱ID_In In 影像检查记录.医嘱ID%Type,
    图像UID_In In 影像检查图象.图像UID%Type
  )As
  Begin
    Open Val For
      Select D.检查UID From 影像检查图象 A,影像检查序列 B,影像检查记录 C,影像临时序列 D
      Where C.医嘱ID=医嘱ID_In And A.图像UID=图像UID_In And A.序列UID=B.序列UID And B.检查UID=C.检查UID And A.序列UID = D.序列UID;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetStudyInfoByImageUID;
  
  --功能：根据检查UID获取FTP信息
  Procedure p_GetFtpinfoByStudyUID(
    Val Out t_Refcur,
    检查UID_In In 影像检查记录.检查UID%Type
  )As
  Begin
    Open Val For
      Select D.FTP用户名 As FtpUser,D.FTP密码 As FtpPwd,C.位置一,C.位置二,C.位置三,C.接收日期,
      D.IP地址 As Host,'/'||D.Ftp目录||'/' As Root,Decode(C.接收日期,Null,'',to_Char(C.接收日期,'YYYYMMDD')||'/')||C.检查UID As URL
      From 影像检查记录 C,影像设备目录 D Where Decode(C.位置一,Null,C.位置二,C.位置一)=D.设备号(+) And C.检查UID= 检查UID_In Union All
      Select D.FTP用户名 As FtpUser,D.FTP密码 As FtpPwd,C.位置一,C.位置二,C.位置三,C.接收日期,
      D.IP地址 As Host,'/'||D.Ftp目录||'/' As Root,Decode(C.接收日期,Null,'',to_Char(C.接收日期,'YYYYMMDD')||'/')||C.检查UID As URL
      From 影像临时记录 C,影像设备目录 D Where Decode(C.位置一,Null,C.位置二,C.位置一)=D.设备号(+) And C.检查UID= 检查UID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetFtpinfoByStudyUID;
  
  --功能：根据科室ID获取FTP信息
  Procedure p_GetFtpinfoByDeptId(
    Val Out t_Refcur,
    科室ID_In In 影像流程参数.科室ID%Type
  )As
  Begin
    Open Val For
      Select a.设备号, a.ip地址, a.ftp用户名, a.ftp密码 From 影像设备目录 a, 影像流程参数 b
      Where a.设备号 = b.参数值 And b.参数名 = '存储设备号' And b.科室id=科室ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetFtpinfoByDeptId;
  
  --功能：根据医嘱ID获取FTP信息
  Procedure p_GetFtpinfoByAdvicetId(
    Val Out t_Refcur,
    医嘱ID_In In 影像检查记录.医嘱ID%Type
  )As
  Begin
    Open Val For
      Select a.设备号, a.ip地址, a.ftp用户名, a.ftp密码 From 影像设备目录 a, 影像检查记录 b 
      Where b.位置一 = a.设备号(+) And b.医嘱id =医嘱ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetFtpinfoByAdvicetId;
  
  --功能：获取检查UID
  Procedure p_GetStudyUID(
    Val Out t_Refcur,
    检查UID_In In 影像检查记录.检查UID%Type
  )As
  Begin
    Open Val For
      Select 检查UID from 影像检查记录 where 检查UID = 检查UID_In Union All Select 检查UID from 影像临时记录 where 检查UID = 检查UID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetStudyUID;
  
  --功能：获取序列UID
  Procedure p_GetSeriesUID(
    Val Out t_Refcur,
    序列UID_In In 影像检查序列.序列UID%Type
  )As
  Begin
    Open Val For
      Select 序列UID from 影像检查序列 where 序列UID = 序列UID_In Union All Select 序列UID from 影像临时序列 where 序列UID = 序列UID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetSeriesUID;
  
  --功能：根据设备号获取设备信息
  Procedure p_GetDeviceInfo(
    Val Out t_Refcur,
    设备号_In In 影像设备目录.设备号%Type
  )As
  Begin
    Open Val For
      Select 设备号,设备名,'/'||Decode(Ftp目录,Null,'',Ftp目录||'/') As URL,FTP用户名,FTP密码,IP地址
      From 影像设备目录 Where 类型=1 and 设备号=设备号_In and NVL(状态,0)=1;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetDeviceInfo;
  
  --获取医技站存储设备号
  Procedure p_GetDeviceIdByAdviceId(
    Val Out t_Refcur,
    医嘱ID_In In 病人医嘱发送.医嘱ID%Type
  )As
  Begin
    Open Val For
      Select d.参数值 From 医技执行房间 a, 病人医嘱发送 b, 影像DICOM服务对 c, 影像DICOM服务参数 d
      Where a.科室ID = b.执行部门id And a.执行间 = b.执行间 And a.检查设备 = c.设备号
      And c.服务功能='图像接收' And c.服务ID=d.服务ID And d.参数名称='存储设备' And b.医嘱id=医嘱ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetDeviceIdByAdviceId;
End b_PACS_RptPluginOriginal;
/


--92225:余伟节,2016-02-18,未生效补录医嘱删除
--92157:余伟节,2015-12-29,避免住院医嘱编辑界面生成路径医嘱时将病人临床路径的当前阶段和当前天数置为空
Create Or Replace Procedure Zl_病人路径生成_Delete
(
  执行记录id_In 病人路径执行.Id%Type,
  调用模式_In   Number := 0,
  调用场合_In   Number := 0
) Is
  --参数:调用模式_in=0:取消路径项目时调用,=1:重新生成医嘱时调用,=2：取消生成必须生成的项目时,
  --               =3:ZL_病人医嘱记录_Delete调用,防止住院医嘱编辑界面删除路径医嘱时将病人临床路径的当前阶段和当前天数置为空。
  --     调用场合_In =0:医生站  ;1-护士站
  t_Id   t_Numlist;
  t_时间 t_Strlist;
  --长期医嘱,其它阶段存在时不删除,未校对时才删除医嘱(界面已限制已校对但未作废的不允许删除路径项目)
  Cursor c_Advice(导入时间_In 病人临床路径.导入时间%Type) Is
    Select a.病人医嘱id
    From 病人路径医嘱 A, 病人医嘱记录 C
    Where 路径执行id = 执行记录id_In And a.病人医嘱id = c.Id And c.医嘱状态 = 1 And
          To_Date(To_Char(c.开嘱时间 + 59 / 24 / 60 / 60, 'yyyy-mm-dd hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') > 导入时间_In And
          Not Exists
     (Select 1 From 病人路径医嘱 B Where a.病人医嘱id = b.病人医嘱id And a.路径执行id <> b.路径执行id);

  Cursor c_Doc Is
    Select ID, To_Char(创建时间, 'yyyy-MM-dd hh24:mi:ss') From 电子病历记录 Where 路径执行id = 执行记录id_In;

  --删除最后一个项目时，检查前面是否有提前跳过的阶段。
  Cursor c_Turn
  (
    路径记录id_In 病人路径执行.路径记录id%Type,
    天数_In       病人路径执行.天数%Type,
    阶段id_In     病人路径执行.阶段id%Type
  ) Is
    Select a.阶段id
    From 病人路径执行 A
    Where a.路径记录id = 路径记录id_In And a.天数 = 天数_In And a.阶段id <> 阶段id_In And a.项目内容 = '未生成任何项目' And Exists
     (Select 1
           From 病人路径评估 B
           Where a.路径记录id = b.路径记录id And a.阶段id = b.阶段id And a.天数 = b.天数 And b.时间进度 = 1)
    Order By a.登记时间 Desc;
  t_阶段id t_Numlist;

  Cursor c_Merge
  (
    路径记录id_In 病人路径执行.路径记录id%Type,
    阶段id_In     病人路径执行.阶段id%Type
  ) Is
    Select a.Id, Max(b.合并路径阶段id) As 阶段id
    From 病人合并路径 A, 病人合并路径评估 B
    Where a.Id = b.合并路径记录id(+) And a.首要路径记录id = b.路径记录id(+) And b.阶段id(+) <> 阶段id_In And a.首要路径记录id = 路径记录id_In And
          (b.登记时间 = (Select Max(登记时间)
                     From 病人合并路径评估 C
                     Where c.路径记录id = b.路径记录id And c.合并路径记录id = b.合并路径记录id And c.阶段id = b.阶段id) Or b.登记时间 Is Null)
    Group By a.Id;
  t_合并路径阶段id t_Numlist;
  t_合并路径记录id t_Numlist;

  r_Pp_Item 病人路径执行%RowType;

  v_阶段id          病人路径执行.阶段id%Type;
  v_前一阶段id      病人路径执行.阶段id%Type;
  v_路径记录id      病人路径执行.路径记录id%Type;
  v_天数            病人路径执行.天数%Type;
  v_Last天数        病人路径执行.天数%Type;
  v_相关id          病人医嘱记录.相关id%Type;
  v_Other路径执行id 病人路径执行.Id%Type;
  v_变异原因        病人路径执行.变异原因%Type;
  n_Count           Number(5);
  n_变化天数        Number(5);
  d_导入时间        病人临床路径.导入时间%Type;
  n_时间进度        Number(5);

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin

  --如果路径内外项目是一并给药的，删除其中一个路径项目后，要该将其中的给药途径的执行ID更改为一并给药中其他药品的执行ID
  Select Nvl(Max(b.相关id), 0)
  Into v_相关id
  From 病人路径医嘱 A, 病人医嘱记录 B
  Where a.路径执行id = 执行记录id_In And a.病人医嘱id = b.Id And b.诊疗类别 In ('5', '6');

  If v_相关id <> 0 Then
    Select Nvl(Max(c.Id), 0)
    Into v_Other路径执行id
    From 病人路径医嘱 A, 病人医嘱记录 B, 病人路径执行 C
    Where c.Id = a.路径执行id And b.相关id = v_相关id And a.病人医嘱id = b.Id And a.路径执行id <> 执行记录id_In And
          c.登记时间 = (Select Max(d.登记时间)
                    From 病人路径执行 D, 病人医嘱记录 E, 病人路径医嘱 F
                    Where e.Id = f.病人医嘱id And d.Id = f.路径执行id And e.相关id = v_相关id And f.路径执行id <> 执行记录id_In);
  
    If v_Other路径执行id <> 0 Then
      Select Count(1)
      Into n_Count
      From 病人路径执行 A, 病人路径执行 B
      Where a.Id = v_Other路径执行id And b.Id = 执行记录id_In And a.阶段id = b.阶段id And a.天数 = b.天数;
    
      If n_Count > 0 Then
        --如果是两个项目有相同医嘱，对应不同的路径项目（合并路径和首要路径不重复生成的医嘱）时，不修改路径执行ID
        Select Count(1) Into n_Count From 病人路径医嘱 Where 路径执行id = v_Other路径执行id And 病人医嘱id = v_相关id;
        If n_Count = 0 Then
          Update 病人路径医嘱
          Set 路径执行id = v_Other路径执行id
          Where 病人医嘱id = v_相关id And 路径执行id = 执行记录id_In;
        End If;
      End If;
    End If;
  End If;

  --导入时间之前的路径项目对应的病历医嘱不删除
  Select b.导入时间
  Into d_导入时间
  From 病人路径执行 A, 病人临床路径 B
  Where a.路径记录id = b.Id And a.Id = 执行记录id_In;
  If d_导入时间 Is Not Null Then
    --是否允许取消的逻辑规则在界面程序中检查
    Open c_Advice(d_导入时间);
    Fetch c_Advice Bulk Collect
      Into t_Id;
    Close c_Advice;
  
    Delete 病人路径医嘱 Where 路径执行id = 执行记录id_In;
    If t_Id.Count > 0 Then
      Forall I In 1 .. t_Id.Count
        Delete From 病人医嘱记录 Where ID = t_Id(I) And 医嘱状态 = 1;
    End If;
  
    If 调用模式_In = 0 Or 调用模式_In = 2 Then
      Open c_Doc;
      Fetch c_Doc Bulk Collect
        Into t_Id, t_时间;
      Close c_Doc;
      If t_Id.Count > 0 Then
        For I In 1 .. t_Id.Count Loop
          If To_Date(t_时间(I), 'yyyy-MM-dd hh24:mi:ss') > d_导入时间 Then
            Zl_电子病历记录_Delete(t_Id(I));
          Else
            Update 电子病历记录 Set 路径执行id = Null Where ID = t_Id(I);
          End If;
        End Loop;
      End If;
    End If;
  End If;

  --如果是取消生成必须生成的项目时，不删除执行记录
  If 调用模式_In <> 2 Then
    If 调用模式_In = 3 Or 调用模式_In = 0 Then
      Select * Into r_Pp_Item From 病人路径执行 T Where ID = 执行记录id_In;
    End If;
    Delete 病人路径执行
    Where ID = 执行记录id_In
    Returning 路径记录id, 阶段id, 天数 Into v_路径记录id, v_阶段id, v_天数;
  End If;
  --避免医嘱下达界面时,删除所有医嘱导致临床路径项目都删除,当前天数和当前阶段被设置为空。
  If 调用模式_In = 3 Then
    Select Count(1)
    Into n_Count
    From 病人路径执行
    Where 路径记录id = r_Pp_Item.路径记录id And 阶段id = r_Pp_Item.阶段id And 天数 = r_Pp_Item.天数;
  
    If n_Count = 0 Then
      --增加一个特殊项目[未生成任何项目]
      Insert Into 病人路径执行
        (ID, 路径记录id, 阶段id, 日期, 天数, 分类, 项目id, 登记人, 登记时间, 项目序号, 项目内容, 执行者, 生成者, 项目结果)
      Values
        (病人路径执行_Id.Nextval, r_Pp_Item.路径记录id, r_Pp_Item.阶段id, r_Pp_Item.日期, r_Pp_Item.天数, r_Pp_Item.分类, Null,
         Zl_Username, Sysdate, Null, '未生成任何项目', Null, 1, '已经执行|1' || Chr(9) || '已经执行');
    End If;
  End If;

  --取消补录的路径外项目时，如果存在阶段评估,自动更新 评估结果及 变异原因
  If (调用模式_In = 0 Or 调用模式_In = 3) And Nvl(r_Pp_Item.生成时间性质, 0) = 1 And Nvl(r_Pp_Item.项目id, 0) = 0 And 调用场合_In = 0 Then
    Select Count(1)
    Into n_Count
    From 病人路径评估
    Where 路径记录id = r_Pp_Item.路径记录id And 阶段id = r_Pp_Item.阶段id And 天数 = r_Pp_Item.天数;
    If n_Count > 0 Then
      Select Count(1)
      Into n_Count
      From 病人路径执行
      Where 路径记录id = r_Pp_Item.路径记录id And 阶段id + 0 = r_Pp_Item.阶段id And 天数 = r_Pp_Item.天数 And 变异原因 = r_Pp_Item.变异原因 And
            ID <> r_Pp_Item.Id;
      If n_Count = 0 Then
        Select 时间进度
        Into n_时间进度
        From 病人路径评估
        Where 路径记录id = r_Pp_Item.路径记录id And 阶段id = r_Pp_Item.阶段id And 日期 = r_Pp_Item.日期;
        Select Count(1)
        Into n_Count
        From 病人路径变异
        Where 路径记录id = r_Pp_Item.路径记录id And 阶段id = r_Pp_Item.阶段id And 日期 = r_Pp_Item.日期;
        --当前阶段有且仅有一个变异原因且评估时的时间进度非正常时,不允许调整变异原因
        If Not (n_Count = 1 And n_时间进度 <> 0) Then
          Delete 病人路径变异
          Where 路径记录id = r_Pp_Item.路径记录id And 阶段id = r_Pp_Item.阶段id And 日期 = r_Pp_Item.日期 And 变异原因 = r_Pp_Item.变异原因;
          Select Count(1)
          Into n_Count
          From 病人路径变异
          Where 路径记录id = r_Pp_Item.路径记录id And 阶段id = r_Pp_Item.阶段id And 日期 = r_Pp_Item.日期;
          If n_Count > 0 Then
            Select 变异原因
            Into v_变异原因
            From 病人路径变异
            Where 路径记录id = r_Pp_Item.路径记录id And 阶段id = r_Pp_Item.阶段id And 日期 = r_Pp_Item.日期 And Rownum < 2;
            Update 病人路径评估
            Set 变异原因 = v_变异原因
            Where 路径记录id = r_Pp_Item.路径记录id And 阶段id = r_Pp_Item.阶段id And 日期 = r_Pp_Item.日期;
          Else
            Update 病人路径评估
            Set 变异原因 = Null, 评估结果 = 1
            Where 路径记录id = r_Pp_Item.路径记录id And 阶段id = r_Pp_Item.阶段id And 日期 = r_Pp_Item.日期;
          End If;
        End If;
      End If;
    End If;
  End If;
  If 调用模式_In = 0 And 调用场合_In = 0 Then
    Select Count(1)
    Into n_Count
    From 病人路径执行
    Where 路径记录id = v_路径记录id And 阶段id = v_阶段id And 天数 = v_天数;
    If n_Count = 0 Then
      Select Max(天数) Into v_天数 From 病人路径执行 Where 路径记录id = v_路径记录id And 阶段id = v_阶段id;
      Select Max(天数) Into v_Last天数 From 病人路径执行 Where 路径记录id = v_路径记录id;
      --记录变化的天数
      Select 当前天数 Into n_变化天数 From 病人临床路径 Where ID = v_路径记录id;
      --如果当前阶段的最后一个执行记录被删除(全部都是非必须执行的情况下)
      --由于路径跳转，一个阶段的天数可能与另一个路径的阶段交叉（例如：a路径第3阶段:3-5天,先执行第3天，跳转到其他路径后跳回来执行第5天）
      If v_天数 Is Null Or v_天数 <> v_Last天数 Then
        --a.如果当前没有任何执行记录
        If v_Last天数 Is Null Then
          Update 病人临床路径
          Set 前一阶段id = Null, 当前阶段id = Null, 当前天数 = Null, 状态 = 1
          Where ID = v_路径记录id;
          Update 病人合并路径
          Set 前一阶段id = Null, 当前阶段id = Null, 当前天数 = Null
          Where 首要路径记录id = v_路径记录id;
        Else
          --b.回退到前一个阶段
          --如果前一阶段是跳过的阶段，则直接删除
          Open c_Turn(v_路径记录id, v_Last天数, v_阶段id);
          Fetch c_Turn Bulk Collect
            Into t_阶段id;
          Close c_Turn;
          If t_阶段id.Count > 0 Then
            Forall I In 1 .. t_阶段id.Count
              Delete From 病人路径评估 Where 路径记录id = v_路径记录id And 阶段id = t_阶段id(I) And 天数 = v_Last天数;
            Forall I In 1 .. t_阶段id.Count
              Delete From 病人路径执行 Where 路径记录id = v_路径记录id And 阶段id = t_阶段id(I) And 天数 = v_Last天数;
            --删除后取最后一个阶段为前一阶段ID
            Select Max(阶段id)
            Into v_前一阶段id
            From 病人路径执行
            Where 路径记录id = v_路径记录id And 登记时间 = (Select Max(登记时间) From 病人路径执行 Where 路径记录id = v_路径记录id);
            Update 病人临床路径 Set 前一阶段id = v_前一阶段id Where ID = v_路径记录id;
          End If;
          --修改病人临床路径信息
          Select Max(阶段id)
          Into v_阶段id
          From 病人路径执行
          Where 路径记录id = v_路径记录id And
                登记时间 = (Select Max(登记时间)
                        From 病人路径执行
                        Where 路径记录id = v_路径记录id And 阶段id <> (Select 前一阶段id From 病人临床路径 Where ID = v_路径记录id));
          --重新获取当前天数
          --当前一阶段评估为：下一阶段提前至明天（时间进度=2）且第二天生成时在可选阶段中又跳过中间阶段生成后面的阶段时,
          --这种场景生成的路径表单执行取消本次生成时，v_Last天数需要重新获取）
          Select Max(天数) Into v_Last天数 From 病人路径执行 Where 路径记录id = v_路径记录id;
          --
          Update 病人临床路径
          Set 当前阶段id = 前一阶段id, 前一阶段id = v_阶段id, 当前天数 = v_Last天数, 状态 = 1
          Where ID = v_路径记录id;
        
          n_变化天数 := n_变化天数 - v_Last天数;
          --修改病人临床合并路径信息
          Select Nvl(当前阶段id, 0) Into v_阶段id From 病人临床路径 Where ID = v_路径记录id;
          Open c_Merge(v_路径记录id, v_阶段id);
          Fetch c_Merge Bulk Collect
            Into t_合并路径记录id, t_合并路径阶段id;
          Close c_Merge;
          If t_合并路径阶段id.Count > 0 Then
            Forall I In 1 .. t_合并路径阶段id.Count
              Update 病人合并路径
              Set 当前天数 = Decode(前一阶段id, Null, Null, Nvl(当前天数, 0) - Nvl(n_变化天数, 0)), 当前阶段id = 前一阶段id,
                  前一阶段id = t_合并路径阶段id(I)
              Where 首要路径记录id = v_路径记录id And ID = t_合并路径记录id(I);
          End If;
        End If;
      Else
        --如果一个阶段有多天，取消最后一个项目时，只更新天数
        Update 病人临床路径 Set 当前天数 = v_天数 Where ID = v_路径记录id And 当前天数 <> v_天数;
        n_变化天数 := n_变化天数 - v_天数;
        If n_变化天数 <> 0 Then
          --修改病人临床合并路径信息
          Select Nvl(当前阶段id, 0) Into v_阶段id From 病人临床路径 Where ID = v_路径记录id;
          Open c_Merge(v_路径记录id, v_阶段id);
          Fetch c_Merge Bulk Collect
            Into t_合并路径记录id, t_合并路径阶段id;
          Close c_Merge;
          If t_合并路径阶段id.Count > 0 Then
            Forall I In 1 .. t_合并路径阶段id.Count
              Update 病人合并路径
              Set 当前天数 = Decode(前一阶段id, Null, Null, Nvl(当前天数, 0) - Nvl(n_变化天数, 0)), 当前阶段id = 前一阶段id,
                  前一阶段id = t_合并路径阶段id(I)
              Where 首要路径记录id = v_路径记录id And ID = t_合并路径记录id(I);
          End If;
        End If;
      End If;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人路径生成_Delete;
/

--92225:余伟节,2016-02-18,未生效补录医嘱删除
--92157:余伟节,2015-12-29,避免住院医嘱编辑界面生成路径医嘱时将病人临床路径的当前阶段和当前天数置为空
Create Or Replace Procedure Zl_病人医嘱记录_Delete
(
  --功能：删除指定医嘱,适用于门诊和住院。
  --参数：
  --      医嘱ID_IN：当前要删除的医嘱的ID(是可见行的单条医嘱ID，不是组ID)
  --      删相关_IN=0时,只删除指定ID的医嘱(医嘱编辑程序调用)。
  --          1.相关医嘱的同步删除及删除之后的序号调整由程序处理后调用对应过程。
  --          2.被删除的医嘱应该未校对,程序应已控制。
  --          3.病人医嘱状态的内容会自动删除；病人医嘱计价，病人医嘱发送未校对的没有记录。
  --      删相关_IN=1时,删除整条医嘱(管理界面调用)，如给药途径，检查组合，手术附项，中药配方。
  --          1.需要在过程中同时调整相关记录的序号。
  --          2.一并给药的只删除当前药品记录(不包括给药途径)。
  医嘱id_In 病人医嘱记录.Id%Type,
  删相关_In Number := 0
) Is
  v_状态            病人医嘱记录.医嘱状态%Type;
  v_相关id          病人医嘱记录.相关id%Type;
  v_病人id          病人医嘱记录.病人id%Type;
  v_挂号单          病人医嘱记录.挂号单%Type;
  v_主页id          病人医嘱记录.主页id%Type;
  v_婴儿            病人医嘱记录.婴儿%Type;
  v_序号            病人医嘱记录.序号%Type;
  v_内容            病人医嘱记录.医嘱内容%Type;
  v_路径执行id      病人路径执行.Id%Type;
  v_Other路径执行id 病人路径执行.Id%Type;
  v_路径执行方式    临床路径项目.执行方式%Type;
  v_内容要求        临床路径项目.内容要求%Type;
  n_Count           Number(5);
  v_路径记录id      病人临床路径.Id%Type;
  v_变异原因        病人路径执行.变异原因%Type;
  n_是否评估        Number(5);
  n_路径项目id      病人路径执行.项目id%Type;
  n_Islast          Number(5);
  n_Del_Count       Number(5);
  n_Del类型         Number(2); --0-只删除指定ID的医嘱，1-删除整条医嘱
  n_紧急标志        Number(2); --2-补录医嘱
  v_处方审查锁定ids Varchar2(4000);
  v_诊疗类别        病人医嘱记录.诊疗类别%Type;
  v_审核状态        病人医嘱记录.审核状态%Type;
  v_诊疗项目id      病人医嘱记录.诊疗项目id%Type;
  v_启用血库        Zlparameters.参数值%Type;
  v_执行分类        诊疗项目目录.执行分类%Type;
  n_路径记录id      病人临床路径.Id%Type;
  n_阶段id          临床路径阶段.Id%Type;
  d_日期            Date;
  n_时间进度        Number(5);

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --检查医嘱状态:并发操作
  Begin
    Select 病人id, 挂号单, 主页id, 婴儿, 医嘱状态, 相关id, 医嘱内容, 诊疗类别, 审核状态, 诊疗项目id, 紧急标志
    Into v_病人id, v_挂号单, v_主页id, v_婴儿, v_状态, v_相关id, v_内容, v_诊疗类别, v_审核状态, v_诊疗项目id, n_紧急标志
    From 病人医嘱记录
    Where ID = 医嘱id_In;
  Exception
    When Others Then
      Begin
        v_Error := '未发现要删除的医嘱记录，可能已被其他人删除。';
        Raise Err_Custom;
      End;
  End;
  If v_挂号单 Is Null Then
    If Not v_状态 In (1, 2, -1) Then
      v_Error := '医嘱"' || v_内容 || '"已经过校对，不能再删除。';
      Raise Err_Custom;
    End If;
  Else
    If v_状态 <> 1 Then
      v_Error := '医嘱"' || v_内容 || '"已经被发送或作废，不能删除。';
      Raise Err_Custom;
    End If;
  End If;

  --输血医嘱并发处理
  If v_诊疗类别 = 'K' And v_审核状态 In (2, 5) Then
    --是否安装了血库系统
    Select Count(1) Into n_Count From zlSystems Where 编号 = 2200;
    If Nvl(n_Count, 0) > 0 Then
      Select 执行分类 Into v_执行分类 From 诊疗项目目录 Where ID = v_诊疗项目id;
      If Not (Nvl(v_执行分类, 0) = 1) Then
        --是否启用了血库管理系统
        Select zl_GetSysParameter(236) Into v_启用血库 From Dual;
        If Nvl(v_启用血库, '0') <> '0' Then
          If v_审核状态 = 5 Then
            v_Error := '正在配血，';
          Else
            v_Error := '并且已完成配血，';
          End If;
          v_Error := '医嘱"' || v_内容 || '"已被血库接收，' || v_Error || '不能删除，若需删除请与输血科联系。';
          Raise Err_Custom;
        End If;
      End If;
    End If;
  End If;

  Select Count(*)
  Into n_Count
  From 病人医嘱状态
  Where 医嘱id = 医嘱id_In And 操作类型 In (1, 11) And 签名id Is Not Null;
  If Nvl(n_Count, 0) > 0 Then
    v_Error := '医嘱"' || v_内容 || '"已经电子签名,不能删除。';
    Raise Err_Custom;
  End If;

  --处方审查撤销
  If v_相关id Is Null Then
    Zl_处方审查_Cancel(医嘱id_In, v_处方审查锁定ids);
  Else
    Zl_处方审查_Cancel(v_相关id, v_处方审查锁定ids);
  End If;

  If v_处方审查锁定ids Is Not Null Then
    v_Error := '医嘱"' || v_内容 || '"已锁定，正在进行处方审查，不能再删除。';
    Raise Err_Custom;
  End If;

  --判断删整组还是指定ID的医嘱
  If Nvl(删相关_In, 0) = 0 Then
    n_Del类型 := 0;
  Else
    If v_相关id Is Null Then
      --检查组合,手术及附加,中药配方,检验组合,以及独立医嘱
      Select Max(序号), Count(*) Into v_序号, n_Del_Count From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
      n_Del类型 := 1;
    Else
      --成药一并给药的情况(无申请)
      --先判断是否一并给药
      Select Count(*) Into n_Del_Count From 病人医嘱记录 Where 相关id = v_相关id;
      If n_Del_Count = 1 Then
        --单独给药:同时删除其给药途径
        Select Max(序号), Count(*) Into v_序号, n_Del_Count From 病人医嘱记录 Where ID = 医嘱id_In Or ID = v_相关id;
        n_Del类型 := 1;
      Else
        --一并给药:只删除当前药品
        n_Del_Count := 1;
        Select 序号 Into v_序号 From 病人医嘱记录 Where ID = 医嘱id_In;
        n_Del类型 := 0;
      End If;
    End If;
  End If;
  --
  Begin
    --如果不是路径的医嘱，则不查询路径执行表
    Select Count(1) Into n_Count From 病人路径医嘱 Where 病人医嘱id = 医嘱id_In;
  
    If n_Count > 0 Then
      --外连接是因为路径外项目的项目id是空
      --游标循环处理：存在同一天，同一条医嘱对应多个路径项目的情况。
      --必须生成的项目需要填写变异原因，不删项目，只删医嘱；非必须生成的项目，直接删除医嘱和对应项目
      For Rs In (Select a.Id, d.执行方式, d.内容要求, a.路径记录id, a.变异原因, a.项目id
                 From 病人路径执行 A, 病人路径医嘱 B, 临床路径项目 D
                 Where b.病人医嘱id = 医嘱id_In And b.路径执行id = a.Id And a.项目id = d.Id(+)) Loop
        v_路径执行id   := Rs.Id;
        v_路径执行方式 := Rs.执行方式;
        v_内容要求     := Rs.内容要求;
        v_路径记录id   := Rs.路径记录id;
        v_变异原因     := Rs.变异原因;
        n_路径项目id   := Rs.项目id;
        --92225未生效的补录医嘱删除时不做路径检查
        If n_紧急标志 <> 2 Then
          Select Count(1)
          Into n_是否评估
          From 病人路径执行 A, 病人路径评估 B
          Where a.路径记录id = b.路径记录id And a.阶段id = b.阶段id And a.天数 = b.天数 And a.Id = v_路径执行id;
        
          If n_是否评估 > 0 Then
            v_Error := '该医嘱对应的临床路径项目已经评估，请取消评估再删除。';
            Raise Err_Custom;
          End If;
        
          --生成时填了变异原因的必须适用的项目允许删除
          If Not v_路径执行方式 Is Null And v_变异原因 Is Null Then
            If v_路径执行方式 <> 3 Then
              --如果必须生成的项目，选择生成的医嘱还剩最后一个，则不允许删除
              If v_内容要求 = 1 Then
                --路径内外的医嘱进行一并给药时，可以删除原有的给药途径
                If Nvl(删相关_In, 0) = 0 And v_相关id Is Null Then
                  Select Count(*)
                  Into n_Count
                  From 病人路径医嘱 A
                  Where a.路径执行id = v_路径执行id And a.病人医嘱id <> 医嘱id_In;
                Else
                  Select Count(*)
                  Into n_Count
                  From 病人路径医嘱 A
                  Where a.路径执行id = v_路径执行id And
                        a.病人医嘱id Not In
                        (Select ID From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In Or ID = v_相关id);
                End If;
                If n_Count = 0 Then
                  v_Error := '该医嘱对应的临床路径项目不是必要时生成的，不能删除。';
                  Raise Err_Custom;
                End If;
              Else
                --执行方式：0-无须执行(也可用于实现标签)，1-每天执行，2-至少执行一次，3-必要时执行,4-必须执行一次（所在阶段必须且仅执行一次）


                If v_路径执行方式 = 2 Or v_路径执行方式 = 4 Then
                  --程序界面已经处理（当阶段为多天的情况下,当前天数不是阶段最后一天时,执行方式为2或4时，是允许不添加变异原因就删除医嘱的）
                  Null;
                Else
                  v_Error := '该医嘱对应的临床路径项目是必须生成的，需要添加变异原因才能删除。';
                  Raise Err_Custom;
                End If;
              End If;
            End If;
          End If;
        End If;
        --判断是否是最后一条医嘱，分几种情况，一组医嘱，一条医嘱
        If n_Del类型 = 0 Then
          Select Count(1)
          Into n_Islast
          From 病人临床路径 A, 病人路径执行 B, 病人路径医嘱 C
          Where a.Id = b.路径记录id And a.当前阶段id = b.阶段id And a.当前天数 = b.天数 And b.Id = c.路径执行id And a.Id = v_路径记录id;
        Else
          --n_Del类型=1的都是删整组医嘱，有可能传入的是相关ID=null的也有可能是传入的相关ID<>null的
          If v_相关id Is Null Then
            Select Decode(Count(1), 0, 1, 0)
            Into n_Islast
            From 病人临床路径 A, 病人路径执行 B, 病人路径医嘱 C, 病人医嘱记录 D
            Where a.Id = b.路径记录id And a.当前阶段id = b.阶段id And a.当前天数 = b.天数 And a.Id = v_路径记录id And c.病人医嘱id = d.Id And
                  c.路径执行id = b.Id And (d.Id <> 医嘱id_In And d.相关id <> 医嘱id_In);
          Else
            Select Decode(Count(1), 0, 1, 0)
            Into n_Islast
            From 病人临床路径 A, 病人路径执行 B, 病人路径医嘱 C
            Where a.Id = b.路径记录id And a.当前阶段id = b.阶段id And a.当前天数 = b.天数 And c.路径执行id = b.Id And a.Id = v_路径记录id And
                  (c.病人医嘱id <> 医嘱id_In And c.病人医嘱id <> v_相关id);
          End If;
        End If;
      
        If n_Islast = 1 Then
          --是最后一条项目的最后一条医嘱，就调用路径项目删除的过程
          If v_变异原因 Is Null Or Nvl(n_路径项目id, 0) = 0 Then
            Zl_病人路径生成_Delete(v_路径执行id, 3);
          Else
            --必须生成但没有生成填写过变异原因的不删除项目
            Zl_病人路径生成_Delete(v_路径执行id, 2);
          End If;
        Else
          If n_Del类型 = 0 Then
            Delete From 病人路径医嘱 Where 病人医嘱id = 医嘱id_In And 路径执行id = v_路径执行id;
          
            --如果当前药品删除后，该执行id下只剩给药途径，则要该执行ID更改为一并给药中其他药品的执行ID
            If v_相关id Is Not Null Then
              Select Nvl(Max(c.Id), 0)
              Into v_Other路径执行id
              From 病人路径医嘱 A, 病人医嘱记录 B, 病人路径执行 C
              Where c.Id = a.路径执行id And b.相关id = v_相关id And b.Id <> 医嘱id_In And a.病人医嘱id = b.Id And
                    a.路径执行id <> v_路径执行id And c.登记时间 = (Select Max(d.登记时间)
                                                       From 病人路径执行 D, 病人医嘱记录 E, 病人路径医嘱 F
                                                       Where e.Id = f.病人医嘱id And d.Id = f.路径执行id And e.相关id = v_相关id And
                                                             f.路径执行id <> v_路径执行id);
            
              If v_Other路径执行id <> 0 Then
                Select Count(1)
                Into n_Count
                From 病人路径执行 A, 病人路径执行 B
                Where a.Id = v_Other路径执行id And b.Id = v_路径执行id And a.阶段id = b.阶段id And a.天数 = b.天数;
              
                If n_Count > 0 Then
                  Update 病人路径医嘱
                  Set 路径执行id = v_Other路径执行id
                  Where 病人医嘱id = v_相关id And 路径执行id = v_路径执行id And Not Exists
                   (Select 1 From 病人路径医嘱 C Where 路径执行id = v_路径执行id And 病人医嘱id <> v_相关id);
                End If;
              End If;
            End If;
          Else
            If v_相关id Is Null Then
              Delete From 病人路径医嘱
              Where 路径执行id = v_路径执行id And
                    病人医嘱id In (Select ID From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In);
            Else
              --单独给药:同时删除其给药途径
              Delete From 病人路径医嘱
              Where 路径执行id = v_路径执行id And 病人医嘱id In (Select ID From 病人医嘱记录 Where ID = 医嘱id_In Or ID = v_相关id);
            End If;
          End If;
          --该项目对应的医嘱删除完后，则删除路径项目，如果变异原因不为空且不是路径外项目则不删除项目，只删医嘱
          If v_变异原因 Is Null Or Nvl(n_路径项目id, 0) = 0 Then
            Delete From 病人路径执行
            Where ID = v_路径执行id And Not Exists (Select 1 From 病人路径医嘱 Where 路径执行id = v_路径执行id)
            Returning 路径记录id, 阶段id, 日期 Into n_路径记录id, n_阶段id, d_日期;
            --删除补录医嘱时,同时更新评估结果及变异原因
            If Nvl(n_路径项目id, 0) = 0 And n_紧急标志 = 2 And n_路径记录id <> 0 Then
              Select Count(1)
              Into n_Count
              From 病人路径评估
              Where 路径记录id = n_路径记录id And 阶段id = n_阶段id And 日期 = d_日期;
              If n_Count > 0 Then
                Select Count(1)
                Into n_Count
                From 病人路径执行
                Where 路径记录id = n_路径记录id And 阶段id + 0 = n_阶段id And 日期 = d_日期 And 变异原因 || '' = v_变异原因 And ID <> v_路径执行id;
                If n_Count = 0 Then
                  Select 时间进度
                  Into n_时间进度
                  From 病人路径评估
                  Where 路径记录id = n_路径记录id And 阶段id = n_阶段id And 日期 = d_日期;
                  Select Count(1)
                  Into n_Count
                  From 病人路径变异
                  Where 路径记录id = n_路径记录id And 阶段id = n_阶段id And 日期 = d_日期;
                  --当前阶段有且仅有一个变异原因且评估时的时间进度非正常时,不允许调整变异原因
                  If Not (n_Count = 1 And n_时间进度 <> 0) Then
                    Delete 病人路径变异
                    Where 路径记录id = n_路径记录id And 阶段id = n_阶段id And 日期 = d_日期 And 变异原因 = v_变异原因;
                    Select Count(1)
                    Into n_Count
                    From 病人路径变异
                    Where 路径记录id = n_路径记录id And 阶段id = n_阶段id And 日期 = d_日期;
                    If n_Count > 0 Then
                      Select 变异原因
                      Into v_变异原因
                      From 病人路径变异
                      Where 路径记录id = n_路径记录id And 阶段id = n_阶段id And 日期 = d_日期 And Rownum < 2;
                      Update 病人路径评估
                      Set 变异原因 = v_变异原因
                      Where 路径记录id = n_路径记录id And 阶段id = n_阶段id And 日期 = d_日期;
                    Else
                      Update 病人路径评估
                      Set 变异原因 = Null, 评估结果 = 1
                      Where 路径记录id = n_路径记录id And 阶段id = n_阶段id And 日期 = d_日期;
                    End If;
                  End If;
                End If;
              End If;
            End If;
          End If;
        
        End If;
      End Loop;
    End If;
  End;

  --删除关联诊断后删除医嘱
  If n_Del类型 = 0 Then
    Delete From 病人诊断医嘱 Where 医嘱id = 医嘱id_In;
    Delete From 病人医嘱记录 Where ID = 医嘱id_In;
  Else
    If v_相关id Is Null Then
      Delete From 病人诊断医嘱
      Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In);
      Delete From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
    Else
      --单独给药:同时删除其给药途径
      Delete From 病人诊断医嘱 Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = 医嘱id_In Or ID = v_相关id);
      Delete From 病人医嘱记录 Where ID = 医嘱id_In Or ID = v_相关id;
    End If;
  End If;

  If Nvl(删相关_In, 0) <> 0 Then
    --调整序号
    Update 病人医嘱记录
    Set 序号 = 序号 - n_Del_Count
    Where 病人id = v_病人id And Nvl(主页id, 0) = Nvl(v_主页id, 0) And Nvl(挂号单, '空') = Nvl(v_挂号单, '空') And
          Nvl(婴儿, 0) = Nvl(v_婴儿, 0) And 序号 > v_序号;
  End If;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱记录_Delete;
/

--91385:冉俊明,2015-12-29,修改“角币二舍八入，三七做五”的误差计算规则.
Create Or Replace Procedure Zl_病人结算记录_Update
(
  结帐id_In        病人预交记录.结帐id%Type,
  保险结算_In      Varchar2, --"结算方式|结算金额||....."
  结帐_In          Number := 0,
  缺省结算方式_In  Varchar2 := Null,
  缺省冲预交_In    Number := 0, --0-用现金缴款,1:剩于款项用冲预交支付(门诊预交),2-剩于款项用冲预交支付(住院预交)
  卡类别id_In      病人预交记录.卡类别id%Type := Null,
  结算卡序号_In    病人预交记录.结算卡序号%Type := Null,
  卡号_In          病人预交记录.卡号%Type := Null,
  交易流水号_In    病人预交记录.交易流水号%Type := Null,
  交易说明_In      病人预交记录.交易说明%Type := Null,
  合作单位_In      病人预交记录.合作单位%Type := Null,
  冲预交病人ids_In Varchar2 := Null
) As
  --该游标为要删除的由费用记录产生的结算记录

  Cursor c_Del Is
    Select a.Id, a.记录性质, a.冲预交, a.结算方式, b.性质, a.预交类别
    From 病人预交记录 A, 结算方式 B
    Where a.结算方式 = b.名称 And a.结帐id = 结帐id_In;

  --相关信息
  v_No         病人预交记录.No%Type;
  v_病人id     住院费用记录.病人id%Type;
  v_主页id     住院费用记录.主页id%Type;
  v_发生时间   住院费用记录.发生时间%Type;
  v_登记时间   住院费用记录.登记时间%Type;
  v_操作员编号 住院费用记录.操作员编号%Type;
  v_操作员姓名 住院费用记录.操作员姓名%Type;

  v_冲预交病人ids Varchar2(4000);

  --本次结算变量
  v_金额合计 病人预交记录.冲预交%Type;

  --保险结算
  v_保险结算 Varchar2(255);
  v_当前结算 Varchar2(50);
  v_结算方式 病人预交记录.结算方式%Type;
  v_结算金额 病人预交记录.冲预交%Type;

  v_记录性质 病人预交记录.记录性质%Type;
  v_缺省     病人预交记录.结算方式%Type;

  --分币处理及误差变量
  v_现金金额   病人预交记录.冲预交%Type;
  v_Cashcented 病人预交记录.冲预交%Type;
  v_误差金额   病人预交记录.冲预交%Type;
  v_费用id     住院费用记录.Id%Type;
  v_序号       住院费用记录.序号%Type;
  v_收费类别   住院费用记录.收费类别%Type;
  v_收费细目id 住院费用记录.收费细目id%Type;
  v_收入项目id 住院费用记录.收入项目id%Type;
  v_收据费目   住院费用记录.收据费目%Type;
  n_Noexists   Number(3);
  n_医疗小组id 住院费用记录.医疗小组id%Type;
  n_结算序号   病人预交记录.结算序号%Type;
  n_费用状态   门诊费用记录.费用状态%Type;
  n_预交金额   病人预交记录.金额%Type;
  n_当前金额   病人预交记录.金额%Type;
  v_误差项     结算方式.名称%Type;

  --临时变量
  Err_Item Exception;
  v_Err_Msg  Varchar2(255);
  n_组id     财务缴款分组.Id%Type;
  n_执行状态 门诊费用记录.执行状态%Type;
Begin
  --如果缺省结算方式为空，则取现金结算方式
  If 缺省结算方式_In Is Null Then
    Begin
      Select 名称 Into v_缺省 From 结算方式 Where 性质 = 1 And Rownum < 2;
    Exception
      When Others Then
        v_缺省 := '现金';
    End;
  Else
    v_缺省 := 缺省结算方式_In;
  End If;

  --取得本次结算的相关信息
  If Nvl(结帐_In, 0) = 1 Then
    Select NO, 病人id, 收费时间, 操作员编号, 操作员姓名, 缴款组id, 0
    Into v_No, v_病人id, v_登记时间, v_操作员编号, v_操作员姓名, n_组id, n_执行状态
    From 病人结帐记录
    Where ID = 结帐id_In;
  Else
    Begin
      n_Noexists := 0;
      Select NO, 病人id, 登记时间, 操作员编号, 操作员姓名, 缴款组id, 执行状态, 费用状态
      Into v_No, v_病人id, v_登记时间, v_操作员编号, v_操作员姓名, n_组id, n_执行状态, n_费用状态
      From 门诊费用记录
      Where 结帐id = 结帐id_In And Rownum < 2;
    Exception
      When Others Then
        n_Noexists := 1;
    End;
    If n_Noexists = 1 Then
      --费用记录不存在，从补充记录中找
      Select NO, 病人id, 登记时间, 操作员编号, 操作员姓名, 缴款组id, 费用状态
      Into v_No, v_病人id, v_登记时间, v_操作员编号, v_操作员姓名, n_组id, n_费用状态
      From 费用补充记录
      Where 结算id = 结帐id_In And Rownum < 2;
    End If;
    If Nvl(n_费用状态, 0) = 1 Then
      --异常单据为空:
      v_缺省 := Null;
    End If;
  
    Begin
      --20051027 陈东
      Select 记录性质
      Into v_记录性质
      From 病人预交记录
      Where 结帐id = 结帐id_In And Rownum = 1 And Mod(记录性质, 10) <> 1;
    Exception
      When Others Then
        v_记录性质 := -1;
    End;
    If v_记录性质 = -1 Then
      Begin
        Select Decode(记录性质, 1, 3, 11, 3, 4, 4, 记录性质)
        Into v_记录性质
        From 门诊费用记录
        Where 结帐id = 结帐id_In And Rownum = 1;
      Exception
        When Others Then
          --可能是卡费
          Select 记录性质 Into v_记录性质 From 住院费用记录 Where 结帐id = 结帐id_In And Rownum = 1;
      End;
    End If;
  End If;

  If Nvl(v_病人id, 0) <> 0 And Nvl(结帐_In, 0) = 1 Then
    Select 主页id Into v_主页id From 病人信息 Where 病人id = v_病人id;
  End If;
  Select 结算序号 Into n_结算序号 From 病人预交记录 Where 结帐id = 结帐id_In And Rownum = 1;

  v_冲预交病人ids := Nvl(冲预交病人ids_In, v_病人id);

  ----回退缴款,预交不动,因为没有改冲预交的
  --收费未最未最终完成的,代表按异常单据修正,不处理人员缴款余额
  v_金额合计 := 0;
  For r_Del In c_Del Loop
    If r_Del.记录性质 Not In (1, 11) Then
      If Nvl(n_费用状态, 0) <> 1 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) - r_Del.冲预交
        Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = r_Del.结算方式;
      
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (v_操作员姓名, r_Del.结算方式, 1, -1 * r_Del.冲预交);
        End If;
      End If;
      v_金额合计 := v_金额合计 + r_Del.冲预交;
      Delete From 病人预交记录 Where ID = r_Del.Id;
    Else
      --检查是否冲预交
      If Nvl(缺省冲预交_In, 0) <> 0 Then
        v_金额合计 := v_金额合计 + r_Del.冲预交;
        If Nvl(n_费用状态, 0) <> 1 Then
          Update 病人余额
          Set 预交余额 = Nvl(预交余额, 0) + Nvl(r_Del.冲预交, 0)
          Where 病人id = v_病人id And 类型 = Nvl(r_Del.预交类别, 2);
          If Sql%NotFound Then
            Insert Into 病人余额
              (病人id, 性质, 预交余额, 费用余额, 类型)
            Values
              (v_病人id, 1, Nvl(r_Del.冲预交, 0), 0, Nvl(r_Del.预交类别, 2));
          End If;
        End If;
        If r_Del.记录性质 = 1 Then
          Update 病人预交记录 Set 冲预交 = 0 Where ID = r_Del.Id;
        Else
          Delete 病人预交记录 Where ID = r_Del.Id;
        End If;
      End If;
    End If;
  End Loop;

  --------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------
  --产生医保支付结算
  If 保险结算_In Is Not Null Then
    --各个保险结算
    v_保险结算 := 保险结算_In || '||';
    While v_保险结算 Is Not Null Loop
      v_当前结算 := Substr(v_保险结算, 1, Instr(v_保险结算, '||') - 1);
    
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算性质)
      Values
        (病人预交记录_Id.Nextval, Decode(结帐_In, 1, 2, v_记录性质), v_No, 1, v_病人id, v_主页id, '保险部份', v_结算方式, v_登记时间, v_操作员编号,
         v_操作员姓名, v_结算金额, 结帐id_In, n_组id, n_结算序号, Mod(Decode(结帐_In, 1, 2, v_记录性质), 10));
    
      v_金额合计 := v_金额合计 - v_结算金额;
    
      v_保险结算 := Substr(v_保险结算, Instr(v_保险结算, '||') + 2);
    End Loop;
  End If;
  --剩余部分用预交
  If Nvl(缺省冲预交_In, 0) <> 0 And v_金额合计 <> 0 Then
  
    n_预交金额 := v_金额合计;
    For c_预交 In (Select *
                 From (Select a.Id, a.病人id, a.记录状态, a.预交类别, a.No, Nvl(a.金额, 0) As 金额
                        From 病人预交记录 A,
                             (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                               From 病人预交记录 A
                               Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And
                                     a.病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And
                                     Nvl(a.预交类别, 2) = 缺省冲预交_In
                               Group By NO
                               Having Sum(Nvl(a.金额, 0)) <> 0) B
                        Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And
                              a.结算方式 Not In (Select 名称 From 结算方式 Where 性质 = 5) And a.No = b.No And
                              a.病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And
                              Nvl(a.预交类别, 2) = 缺省冲预交_In
                        Union All
                        Select 0 As ID, Max(病人id) As 病人id, 记录状态, 预交类别, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额


                        
                        From 病人预交记录
                        Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(金额, 0) <> Nvl(冲预交, 0) And
                              病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And Nvl(预交类别, 2) = 缺省冲预交_In
                         Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
                        Group By 记录状态, NO, 预交类别)
                 Order By Decode(病人id, Nvl(v_病人id, 0), 0, 1), ID, NO) Loop
    
      n_当前金额 := Case
                  When c_预交.金额 - n_预交金额 < 0 Then
                   c_预交.金额
                  Else
                   n_预交金额
                End;
    
      If c_预交.Id <> 0 Then
        --第一次冲预交(填上结帐ID,金额为0)
        Update 病人预交记录
        Set 冲预交 = 0, 结帐id = 结帐id_In, 结算序号 = n_结算序号, 结算性质 = Mod(Decode(结帐_In, 1, 2, v_记录性质), 10)
        Where ID = c_预交.Id;
      End If;
      --冲上次剩余额
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 预交类别, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号,
         冲预交, 结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 预交类别, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
               v_登记时间, v_操作员姓名, v_操作员编号, n_当前金额, 结帐id_In, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, n_结算序号,
               Mod(Decode(结帐_In, 1, 2, v_记录性质), 10)
        From 病人预交记录
        Where NO = c_预交.No And 记录状态 = c_预交.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
    
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - n_当前金额
      Where 病人id = c_预交.病人id And 性质 = 1 And 类型 = Nvl(c_预交.预交类别, 2);
    
      --检查是否已经处理完
      If c_预交.金额 < n_预交金额 Then
        n_预交金额 := n_预交金额 - c_预交.金额;
      Else
        n_预交金额 := 0;
      End If;
    
      If n_预交金额 = 0 Then
        Exit;
      End If;
    End Loop;
    If n_预交金额 <> 0 Then
      v_Err_Msg := '[ZLSOFT]预交余不够支付本次支付金额,不能继续操作！[ZLSOFT]';
      Raise Err_Item;
    End If;
    Delete From 病人余额 Where 病人id = v_病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
    v_金额合计 := n_预交金额;
  End If;

  --剩余部份全部用缺省结算方式结算，(小于零也不进行额外处理)
  If v_金额合计 <> 0 Then
    Update 病人预交记录
    Set 冲预交 = 冲预交 + v_金额合计, 卡类别id = 卡类别id_In, 结算卡序号 = 结算卡序号_In, 卡号 = 卡号_In, 交易流水号 = 交易流水号_In, 交易说明 = 交易说明_In,
        合作单位 = 合作单位_In, 结算序号 = n_结算序号
    
    Where 结帐id = 结帐id_In And Nvl(结算方式, 'LXH_Test') = Nvl(v_缺省, 'LXH_Test') And 记录性质 = Decode(结帐_In, 1, 2, v_记录性质);
    If Sql%RowCount = 0 Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 卡类别id, 结算卡序号, 卡号, 交易流水号,
         交易说明, 合作单位, 结算性质)
      Values
        (病人预交记录_Id.Nextval, Decode(结帐_In, 1, 2, v_记录性质), v_No, 1, v_病人id, v_主页id, '保险结算修正', v_缺省, v_登记时间, v_操作员编号,
         v_操作员姓名, v_金额合计, 结帐id_In, n_组id, n_结算序号, 卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, 合作单位_In,
         Mod(Decode(结帐_In, 1, 2, v_记录性质), 10));
    End If;
  
    --挂号结算,分币处理(由于挂号界面没有预结算,所以在此过程中根据分币处理规则来修正)
    If v_记录性质 = 4 Then
    
      Begin
        Select a.冲预交
        Into v_现金金额
        From 病人预交记录 A, 结算方式 B
        Where a.结算方式 = b.名称 And b.性质 = 1 And a.结帐id = 结帐id_In;
      Exception
        When Others Then
          v_现金金额 := 0;
      End;
      If Floor(Abs(v_现金金额) * 10) <> Abs(v_现金金额) * 10 Then
        --误差处理
        v_Cashcented := Zl_Cent_Money(v_现金金额);
      
        v_误差金额 := v_Cashcented - v_现金金额;
        If v_误差金额 <> 0 Then
          If n_结算序号 < 0 Then
            --10.34之后误差数据
            Begin
              Select 名称 Into v_误差项 From 结算方式 Where 性质 = 9;
            Exception
              When Others Then
                v_Err_Msg := '不能正确读取误差项的信息，请先检查结算方式中误差费是否设置正确。';
                Raise Err_Item;
            End;
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算性质)
            Values
              (病人预交记录_Id.Nextval, Decode(结帐_In, 1, 2, v_记录性质), v_No, 1, v_病人id, v_主页id, '误差费', v_误差项, v_登记时间, v_操作员编号,
               v_操作员姓名, v_误差金额, 结帐id_In, n_组id, n_结算序号, Mod(Decode(结帐_In, 1, 2, v_记录性质), 10));
          Else
            --1.更新预交记录(一定存在记录)
            Update 病人预交记录
            Set 冲预交 = v_Cashcented
            Where 结算方式 = (Select 名称 From 结算方式 Where 性质 = 1 And Rownum = 1) And 结帐id = 结帐id_In;
          
            --2.生成误差费用记录(注:计算单位记录的是号别,所以不取误差项的)
            Begin
              Select a.类别, a.Id, c.Id, c.收据费目
              Into v_收费类别, v_收费细目id, v_收入项目id, v_收据费目
              From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费特定项目 D
              Where d.特定项目 = '误差项' And d.收费细目id = a.Id And a.Id = b.收费细目id And b.收入项目id = c.Id And
                    Sysdate Between b.执行日期 And Nvl(b.终止日期, To_Date('3000-01-01', 'YYYY-MM-DD'));
            Exception
              When Others Then
                v_Err_Msg := '不能正确读取收费误差项的信息，请先检查该项目是否设置正确。';
                Raise Err_Item;
            End;
            If Nvl(结帐_In, 0) = 1 Then
              Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
              Select Max(序号) + 1, Max(发生时间) Into v_序号, v_发生时间 From 住院费用记录 Where 结帐id = 结帐id_In;
              n_医疗小组id := Zl_医疗小组_Get(0, v_操作员姓名, v_病人id, v_主页id, v_发生时间);
            
              Insert Into 住院费用记录
                (ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 床号, 姓名, 性别, 年龄, 病人病区id, 病人科室id, 费别, 收费类别,
                 收费细目id, 计算单位, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 记帐费用, 划价人, 开单部门id, 开单人, 发生时间,
                 登记时间, 执行部门id, 执行人, 执行状态, 结帐id, 结帐金额, 操作员编号, 操作员姓名, 是否上传, 缴款组id, 医疗小组id)
                Select v_费用id, 记录性质, NO, 实际票号, 记录状态, v_序号, Null, Null, 门诊标志, 病人id, 标识号, 床号, 姓名, 性别, 年龄, 病人病区id, 病人科室id,
                       费别, v_收费类别, v_收费细目id, 计算单位, 发药窗口, 1, 1, 加班标志, 9, v_收入项目id, v_收据费目, v_误差金额, v_误差金额, v_误差金额, 记帐费用,
                       划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 执行状态, 结帐id_In, v_误差金额, 操作员编号, 操作员姓名, 1, 缴款组id,
                       Decode(n_医疗小组id, Null, 医疗小组id, n_医疗小组id)
                From 住院费用记录
                Where 结帐id = 结帐id_In And Rownum = 1;
            Else
              Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
              Select Max(序号) + 1 Into v_序号 From 门诊费用记录 Where 结帐id = 结帐id_In;
              Insert Into 门诊费用记录
                (ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id,
                 计算单位, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 记帐费用, 划价人, 开单部门id, 开单人, 发生时间, 登记时间,
                 执行部门id, 执行人, 执行状态, 费用状态, 结帐id, 结帐金额, 操作员编号, 操作员姓名, 是否上传, 缴款组id)
                Select v_费用id, 记录性质, NO, 实际票号, 记录状态, v_序号, Null, Null, 门诊标志, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 病人科室id, 费别,
                       v_收费类别, v_收费细目id, 计算单位, 发药窗口, 1, 1, 加班标志, 9, v_收入项目id, v_收据费目, v_误差金额, v_误差金额, v_误差金额, 记帐费用, 划价人,
                       开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 执行状态, 费用状态, 结帐id_In, v_误差金额, 操作员编号, 操作员姓名, 1, 缴款组id
                From 门诊费用记录
                Where 结帐id = 结帐id_In And Rownum = 1;
            End If;
          End If;
          --3.更新汇总表
          --只可能产生误差金额的变化.仅为了变量处理方便而用游标
        End If;
      End If;
    End If;
  End If;

  --最后再处理"人员缴款余额"(没有动冲预交那部分,所以"病人余额"的预交余额不用更新)
  For r_Del In c_Del Loop
    If r_Del.记录性质 Not In (1, 11) Then
      If Nvl(n_费用状态, 0) <> 1 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + r_Del.冲预交
        Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = r_Del.结算方式;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (v_操作员姓名, r_Del.结算方式, 1, r_Del.冲预交);
        End If;
      End If;
    End If;
  End Loop;
  Delete From 人员缴款余额 Where 性质 = 1 And 收款员 = v_操作员姓名 And Nvl(余额, 0) = 0;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人结算记录_Update;
/

--91385:冉俊明,2015-12-29,修改“角币二舍八入，三七做五”的误差计算规则.
Create Or Replace Function Zl_Cent_Money
(
  Money_In In Number,
  Type_In  In Number := 2
) Return Number As
  n_Sign Integer;
  n_Temp Number(16, 5);
  n_金额 Number(16, 5);
  n_Mode Number(1);
Begin
  --         0.不处理
  --         1.采取四舍五入法,eg:0.51=0.50;0.56=0.60
  --         2.补整收法,eg:0.51=0.60,0.56=0.60
  --         3.舍分收法,eg:0.51=0.50,0.56=0.50
  --        4.四舍六入五成双,eg:0.14=0.10,0.16=0.20,0.151=0.20,0.15=0.20,0.25=0.20
  --           四舍六入五成双,详见我国科学技术委员会正式颁布的《数字修约规则》,但根据vb的Round函数,若被舍弃的数字包括几位数字时，不对该数字进行连续修约 
  --           即银行家舍入法:四舍六入五考虑，五后非零就进一，五后皆零看奇偶，五前为偶应舍去，五前为奇要进一
  --         5.三七作五、二舍八入,对角进行处理，不需要先对分币进行舍入,即0.24(含)以下都舍掉角，0.75(含)以上都进角，0.25-0.74处理为0.5。
  --         6.五舍六入:eg:0.15=0.10:0.16=0.2:   刘兴洪 问题:34519  日期:2010-12-06 09:58:02

  n_Mode := To_Number(Substr(Nvl(zl_GetSysParameter(14) || '000', '000'), Type_In, 1));
  n_Sign := Sign(Money_In);
  n_金额 := Abs(Money_In);
  If n_Mode = 1 Then
    --1.四舍五入法,eg:0.51=0.50;0.56=0.60
    n_Temp := n_Sign * Round(n_金额, 1);
    Return n_Temp;
  End If;
  If n_Mode = 2 Then
    ----2.补整收法,eg:0.51=0.60,0.56=0.60
    n_Temp := n_Sign * Ceil(n_金额 * 10) / 10;
    Return n_Temp;
  End If;
  If n_Mode = 3 Then
    ----3.舍分收法,eg:0.51=0.50,0.56=0.50
    n_Temp := n_Sign * Floor(n_金额 * 10) / 10;
    Return n_Temp;
  End If;
  If n_Mode = 4 Then
    ----4.四舍六入五成双,由于Oracle没有相关函数,算法复杂,暂不支持
    n_Temp := n_Sign * n_金额;
    Return n_Temp;
  End If;
  If n_Mode = 5 Then
    ----5.三七作五、二舍八入,eg:0.29=0,0.30=0.50,0.79=0.50,0.80=1.00
    n_Temp := Round(n_金额 - Floor(n_金额), 1);
    If n_Temp >= 0.8 Then
      n_Temp := 1;
    Elsif n_Temp < 0.3 Then
      n_Temp := 0;
    Else
      n_Temp := 0.5;
    End If;
    n_Temp := Floor(n_金额) + n_Temp; --5.三七作五、二舍八入,eg:0.24=0,0.25=0.50,0.74=0.50,0.75=1.00
    n_Temp := n_Sign * n_Temp;
    Return n_Temp;
  End If;
  If n_Mode = 6 Then
    ----6.五舍六入
    n_Temp := n_Sign * Round(n_金额 - 0.01, 1);
    Return n_Temp;
  End If;
  Return Money_In;
Exception
  When Others Then
    Return Null;
End Zl_Cent_Money;
/

--91665:冉俊明,2015-12-29,增加多单据分单据结算时医保结算失败时只对结算成功单据收费的模式。
Create Or Replace Procedure Zl_门诊收费票据_Insert
(
  No_In           Varchar2,
  票据号_In       票据使用明细.号码%Type,
  领用id_In       票据使用明细.领用id%Type,
  使用人_In       票据使用明细.使用人%Type,
  使用时间_In     票据使用明细.使用时间%Type,
  打印id_In       票据打印内容.Id%Type := 0,
  票据张数_In     Number := 1,
  Next领用id_In   票据使用明细.领用id%Type := 0,
  Next票据号_In   票据使用明细.号码%Type := Null,
  医保接口打印_In Number := 0
) As
  --功能：处理门诊收费票据的发出
  --参数：
  --      NO_IN       =     收费的单据号,可能是多张单据同时收费。格式为：A0000001,A0000002,....
  --      票据号_IN   =     要使用的开始票据号。该票据号应该不为空，否则不用处理票据，也不能区分多张一起收费的单据。
  --      领用ID_IN   =     严格控制票据时，为使用票据的领用批次。非严格控制时，为NULL。
  --      打印ID_IN   =     当修改多单据中的一张时,为了便于整体重打,将该单据的打印内容填写为与退费单据相同,不单独新发出票据,由退费重打发出
  --      票据张数_In =     实际所需的票据打印张数
  --      医保接口打印_In = 是否医保接口打印先存入票据数据，若是将传入打印id_In

  --该游标用于票据范围判断
  Cursor c_Fact Is
    Select 开始号码, 终止号码, 剩余数量 From 票据领用记录 Where ID = Nvl(领用id_In, 0);
  r_Factrow c_Fact%RowType;

  Cursor c_Nextfact Is
    Select 开始号码, 终止号码, 剩余数量 From 票据领用记录 Where ID = Nvl(Next领用id_In, 0);
  r_Nextfactrow c_Nextfact%RowType;

  v_票据号 票据使用明细.号码%Type;
  n_领用id 票据使用明细.领用id%Type;
  v_打印id 票据打印内容.Id%Type;

  v_当前号 门诊费用记录.No%Type;
  v_单据号 Varchar2(1000);

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  If Nvl(打印id_In, 0) = 0 Or Nvl(医保接口打印_In, 0) = 1 Then
    --无票据号时,不用处理票据
    If 票据号_In Is Null Then
      Return;
    End If;
    v_打印id := Nvl(打印id_In, 0);
    If Nvl(v_打印id, 0) = 0 Then
      Select 票据打印内容_Id.Nextval Into v_打印id From Dual;
    End If;
  
    --生成单据的票据打印内容
    v_单据号 := No_In || ',';
    While v_单据号 Is Not Null Loop
      v_当前号 := Substr(v_单据号, 1, Instr(v_单据号, ',') - 1);
      --票据打印内容
      Insert Into 票据打印内容 (ID, 数据性质, NO) Values (v_打印id, 1, v_当前号);
      --门诊费用记录中填写开始票据号以便显示
      Update 门诊费用记录 Set 实际票号 = 票据号_In Where 记录性质 = 1 And NO = v_当前号;
      v_单据号 := Substr(v_单据号, Instr(v_单据号, ',') + 1);
    End Loop;
  
    --并发出票据
    v_票据号 := 票据号_In;
    If Nvl(领用id_In, 0) <> 0 Then
      Open c_Fact;
      Fetch c_Fact
        Into r_Factrow;
      If c_Fact%RowCount = 0 Then
        v_Error := '无效的票据领用批次，无法完成收费票据分配操作。';
        Close c_Fact;
        Raise Err_Custom;
      Elsif Nvl(r_Factrow.剩余数量, 0) < Nvl(票据张数_In, 0) Then
        Open c_Nextfact;
        Fetch c_Nextfact
          Into r_Nextfactrow;
        If c_Nextfact%RowCount = 0 Then
          v_Error := '当前批次的剩余数量不足' || 票据张数_In || '张，下一个票据领用批次也无效，无法完成收费票据分配操作。';
          Close c_Nextfact;
          Close c_Fact;
          Raise Err_Custom;
        Elsif Nvl(r_Factrow.剩余数量, 0) + Nvl(r_Nextfactrow.剩余数量, 0) < 票据张数_In Then
          v_Error := '当前批次以及下一个批次的剩余数量之和不足' || 票据张数_In || '张，无法完成收费票据分配操作。';
          Close c_Nextfact;
          Close c_Fact;
          Raise Err_Custom;
        End If;
      End If;
    End If;
    n_领用id := 领用id_In;
    For I In 1 .. 票据张数_In Loop
      If Nvl(n_领用id, 0) <> 0 Then
        --检查票据范围是否正确
        If n_领用id = 领用id_In Then
          If Not (Upper(v_票据号) >= Upper(r_Factrow.开始号码) And Upper(v_票据号) <= Upper(r_Factrow.终止号码) And
              Length(v_票据号) = Length(r_Factrow.终止号码)) Then
            If Nvl(Next领用id_In, 0) <> 0 And n_领用id <> Nvl(Next领用id_In, 0) Then
              n_领用id := Nvl(Next领用id_In, 0);
              v_票据号 := Next票据号_In;
            Else
              v_Error := '单据需要打印多张票据,但票据号"' || v_票据号 || '"超出票据领用的号码范围！';
              Close c_Fact;
              Raise Err_Custom;
            End If;
          End If;
        End If;
        If n_领用id = Nvl(Next领用id_In, 0) Then
          If Not (Upper(v_票据号) >= Upper(r_Nextfactrow.开始号码) And Upper(v_票据号) <= Upper(r_Nextfactrow.终止号码) And
              Length(v_票据号) = Length(r_Nextfactrow.终止号码)) Then
            v_Error := '单据需要打印多张票据,但票据号"' || v_票据号 || '"超出票据领用的号码范围！';
            Close c_Nextfact;
            Raise Err_Custom;
          End If;
        End If;
      End If;
    
      --发出票据
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
      Values
        (票据使用明细_Id.Nextval, 1, v_票据号, 1, 1, 领用id_In, v_打印id, 使用人_In, 使用时间_In);
    
      Update 票据领用记录
      Set 当前号码 = v_票据号, 剩余数量 = Decode(Sign(Nvl(剩余数量, 0) - 1), -1, 0, Nvl(剩余数量, 0) - 1), 使用时间 = 使用时间_In
      Where ID = Nvl(n_领用id, 0);
    
      --下一个票据号
      v_票据号 := Zl_Incstr(v_票据号);
    End Loop;
  
    If Nvl(领用id_In, 0) <> 0 Then
      Close c_Fact;
      If Nvl(Next领用id_In, 0) <> 0 And Nvl(r_Factrow.剩余数量, 0) < Nvl(票据张数_In, 0) Then
        Close c_Nextfact;
      End If;
    End If;
  Else
    Insert Into 票据打印内容 (ID, 数据性质, NO) Values (打印id_In, 1, No_In);
    If 票据号_In Is Null Then
      Return;
    End If;
    --门诊费用记录中填写开始票据号以便显示
    Update 门诊费用记录 Set 实际票号 = 票据号_In Where 记录性质 = 1 And NO = No_In;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费票据_Insert;
/

--93564:冉俊明,2016-02-24,费用金额为0时未成功插入结算方式为NULL的病人预交记录。
--92457:冉俊明,2016-01-08,在完成收费、退费时对实收金额和结算金额进行检查。
--91665:冉俊明,2015-12-29,增加多单据分单据结算时医保结算失败时只对结算成功单据收费的模式。
Create Or Replace Procedure Zl_门诊收费结算_Modify
(
  操作类型_In      Number,
  病人id_In        门诊费用记录.病人id%Type,
  结帐id_In        病人预交记录.结帐id%Type,
  结算方式_In      Varchar2,
  冲预交_In        病人预交记录.冲预交%Type := Null,
  退支票额_In      病人预交记录.冲预交%Type := Null,
  卡类别id_In      病人预交记录.卡类别id%Type := Null,
  卡号_In          病人预交记录.卡号%Type := Null,
  交易流水号_In    病人预交记录.交易流水号%Type := Null,
  交易说明_In      病人预交记录.交易说明%Type := Null,
  缴款_In          病人预交记录.缴款%Type := Null,
  找补_In          病人预交记录.找补%Type := Null,
  误差金额_In      门诊费用记录.实收金额%Type := Null,
  完成结算_In      Number := 0,
  缺省结算方式_In  结算方式.名称%Type := Null,
  冲预交病人ids_In Varchar2 := Null
) As
  ------------------------------------------------------------------------------------------------------------------------------
  --功能:收费结算时,修改结算的相关信息
  --操作类型_In:
  --   0-普通收费方式:
  --     ①结算方式_IN:允许传入多个,格式为:"结算方式|结算金额|结算号码|结算摘要||.." ;也允许传入空.
  --     ②退支票额_In:如果涉及退支票,则传入本次的退支票额,非正常收费时,传入零
  --   1.三方卡结算:
  --     ①结算方式_IN:只能传入一个结算方式,但允许包含一些辅助信息,格式为:"结算方式|结算金额|结算号码|结算摘要"
  --     ②退支票额_In:传入零
  --     ③卡类别ID_IN,卡号_IN,交易流水号_IN,交易说明_In:需要传入
  --   2-医保结算(如果存在医保的结算,则要先删除原医保结算,后按新传入的更新)
  --     ①结算方式_IN:允许传入多个,格式为:结算方式|结算金额||.." 
  --     ②退支票额_In:传入零
  --   3-消费卡结算:
  --     ①结算方式_IN:允许一次刷多张卡,格式为:卡类别ID|卡号|消费卡ID|消费金额||."  消费卡ID:为零时,根据卡号自动定位
  --     ②冲预交_In: 传入零
  --     ②退支票额_In:传入零
  -- 冲预交_In: 存在冲预交时,传入
  -- 误差金额_In:存在误差费时,传入
  -- 完成结算_In:1-完成收费;0-未完成收费
  -- 冲预交病人ids_In:多个用逗分分离,冲预交时有效(冲预交类别与业务操作保持一致),主要是使用家属的预交款
  ------------------------------------------------------------------------------------------------------------------------------
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_结算内容      Varchar2(500);
  v_当前结算      Varchar2(50);
  v_卡号          病人医疗卡信息.卡号%Type;
  n_消费卡id      消费卡目录.Id%Type;
  n_卡类别id      病人预交记录.结算卡序号%Type;
  v_名称          Varchar2(100);
  n_自制卡        卡消费接口目录.自制卡%Type;
  n_序号          病人卡结算记录.序号%Type;
  n_Id            病人卡结算记录.Id%Type;
  n_预交id        病人预交记录.Id%Type;
  v_结算方式      病人预交记录.结算方式%Type;
  n_结算金额      病人预交记录.冲预交%Type;
  n_返回值        人员缴款余额.余额%Type;
  n_预交金额      病人预交记录.冲预交%Type;
  n_冲预交        病人预交记录.冲预交%Type;
  v_退支票        病人预交记录.结算方式%Type;
  v_结算号码      病人预交记录.结算号码%Type;
  v_结算摘要      病人预交记录.摘要%Type;
  v_误差费        结算方式.名称%Type;
  n_Count         Number;
  n_Havenull      Number;
  l_预交id        t_Numlist := t_Numlist();
  v_冲预交病人ids Varchar2(4000);

  Cursor c_Feedata Is
    Select Max(m.病人id) As 病人id, Max(m.登记时间) As 登记时间, Max(m.操作员编号) As 操作员编号, Max(m.操作员姓名) As 操作员姓名, Sum(结帐金额) As 结算金额,
           Max(m.缴款组id) As 缴款组id
    From 门诊费用记录 M
    Where m.结帐id = 结帐id_In;
  r_Feedata c_Feedata%RowType;

  Cursor c_Balancedata Is
    Select 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号
    From 病人预交记录
    Where 结帐id = 结帐id_In And 结算方式 Is Null;
  r_Balancedata c_Balancedata%RowType;

Begin
  Begin
    Select 名称 Into v_误差费 From 结算方式 Where Nvl(性质, 0) = 9;
  Exception
    When Others Then
      v_误差费 := '误差费';
  End;

  v_冲预交病人ids := Nvl(冲预交病人ids_In, 病人id_In);

  --0.正式结算
  Select Count(1), Max(Decode(结算方式, Null, 1, 0))
  Into n_Count, n_Havenull
  From 病人预交记录
  Where 结帐id = 结帐id_In;

  --1.增加结算方式为空的结算数据
  n_结算金额 := 0;
  n_Count    := 0;
  Open c_Feedata;
  Begin
    Fetch c_Feedata
      Into r_Feedata;
    --修正或新增结算方式为null的记录
    Select Nvl(Sum(冲预交), 0) Into n_结算金额 From 病人预交记录 Where 结帐id = 结帐id_In;
    If Nvl(n_Havenull, 0) = 0 Or Round(Nvl(r_Feedata.结算金额, 0), 6) <> Round(Nvl(n_结算金额, 0), 6) Then
      --先删除存在的结算方式为null的记录
      Delete From 病人预交记录 Where 结帐id = 结帐id_In And 结算方式 Is Null;
      Select Nvl(Sum(冲预交), 0) Into n_结算金额 From 病人预交记录 Where 结帐id = 结帐id_In;
    
      n_结算金额 := Round(Nvl(r_Feedata.结算金额, 0) - n_结算金额, 6);
    
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 1, Decode(病人id_In, 0, Null, 病人id_In), Null, r_Feedata.登记时间, r_Feedata.操作员编号,
         r_Feedata.操作员姓名, n_结算金额, 结帐id_In, r_Feedata.缴款组id, -1 * 结帐id_In, 1, 3);
    End If;
  Exception
    When Others Then
      n_Count := 1;
  End;
  Close c_Feedata;
  If n_Count = 1 Then
    v_Err_Msg := '未找到指定的收费明细数据,结算操作失败！';
    Raise Err_Item;
  End If;

  If 操作类型_In = 0 And Nvl(退支票额_In, 0) <> 0 Then
    Begin
      Select b.名称
      Into v_退支票
      From 结算方式应用 A, 结算方式 B
      Where a.应用场合 = '收费' And b.名称 = a.结算方式 And Nvl(b.应付款, 0) = 1 And Rownum <= 1;
    Exception
      When Others Then
        v_退支票 := '无';
    End;
    If v_退支票 = '无' Then
      v_Err_Msg := '在结算场合中,不存在结算性质为应付款的结算方式,请在[结算方式]中设置！';
      Raise Err_Item;
    End If;
  End If;

  Open c_Balancedata;
  Fetch c_Balancedata
    Into r_Balancedata;

  If Nvl(误差金额_In, 0) <> 0 Then
    Update 病人预交记录
    Set 冲预交 = Nvl(冲预交, 0) + Nvl(误差金额_In, 0)
    Where 结帐id = 结帐id_In And 结算方式 = v_误差费;
    If Sql%NotFound Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, Null, v_误差费, r_Balancedata.收款时间, r_Balancedata.操作员编号,
         r_Balancedata.操作员姓名, 误差金额_In, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null, Null, 卡号_In,
         交易流水号_In, 交易说明_In, Null, 3);
    End If;
    Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(误差金额_In, 0) Where 结帐id = 结帐id_In And 结算方式 Is Null;
    If Sql%NotFound Then
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
      Raise Err_Item;
    End If;
  End If;

  --预交款处理
  If Nvl(冲预交_In, 0) <> 0 Then
    If Nvl(病人id_In, 0) = 0 Then
      v_Err_Msg := '不能确定病人的病人ID,收费不能使用预交款结算,结算操作失败！';
      Raise Err_Item;
    End If;
  
    --病人余额检查
    Begin
      Select Sum(Nvl(预交余额, 0) - Nvl(费用余额, 0))
      Into n_预交金额
      From 病人余额
      Where 病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And Nvl(性质, 0) = 1 And 类型 = 1;
    Exception
      When Others Then
        n_预交金额 := 0;
    End;
    If n_预交金额 < 冲预交_In Then
      v_Err_Msg := '病人的当前预交余额为 ' || LTrim(To_Char(n_预交金额, '9999999990.00')) || '，小于本次支付金额 ' ||
                   LTrim(To_Char(冲预交_In, '9999999990.00')) || '，支付失败！';
      Raise Err_Item;
    End If;
  
    n_预交金额 := 冲预交_In;
  
    For c_冲预交 In (Select *
                  From (Select a.Id, a.记录状态, a.病人id, a.No, Nvl(a.金额, 0) As 金额
                         From 病人预交记录 A,
                              (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                                From 病人预交记录 A
                                Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And
                                      a.病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And 预交类别 = 1
                                Group By NO
                                Having Sum(Nvl(a.金额, 0)) <> 0) B
                         Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.No = b.No And
                               a.病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And a.预交类别 = 1
                         Union All
                         Select 0 As ID, 记录状态, Max(病人id) As 病人id, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
                         From 病人预交记录
                         Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(金额, 0) <> Nvl(冲预交, 0) And
                               病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And 预交类别 = 1 Having
                          Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
                         Group By 记录状态, NO)
                  Order By Decode(病人id, Nvl(病人id_In, 0), 0, 1), ID, NO) Loop
    
      If c_冲预交.金额 - n_预交金额 < 0 Then
        n_冲预交 := c_冲预交.金额;
      Else
        n_冲预交 := n_预交金额;
      End If;
    
      If c_冲预交.Id <> 0 Then
        --第一次冲预交(填上结帐ID,金额为0)
        Update 病人预交记录
        Set 冲预交 = 0, 结帐id = 结帐id_In, 结算序号 = -1 * 结帐id_In, 结算性质 = 3
        Where ID = c_冲预交.Id;
      End If;
      --冲上次剩余额
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
               r_Balancedata.收款时间, r_Balancedata.操作员姓名, r_Balancedata.操作员编号, n_冲预交, 结帐id_In, r_Balancedata.缴款组id, 预交类别,
               卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, -1 * 结帐id_In, 3
        From 病人预交记录
        Where NO = c_冲预交.No And 记录状态 = c_冲预交.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
    
      --更新数据(结算方式为NULL的)
      Update 病人预交记录
      Set 冲预交 = 冲预交 - n_冲预交
      Where 结帐id = 结帐id_In And 结算方式 Is Null
      Returning Nvl(冲预交, 0) Into n_返回值;
    
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - n_冲预交
      Where 病人id = c_冲预交.病人id And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (c_冲预交.病人id, 1, -1 * n_冲预交, 1);
        n_返回值 := -1 * n_冲预交;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = c_冲预交.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --检查是否已经处理完
      If c_冲预交.金额 < n_预交金额 Then
        n_预交金额 := n_预交金额 - c_冲预交.金额;
      Else
        n_预交金额 := 0;
      End If;
      If n_预交金额 = 0 Then
        Exit;
      End If;
    
    End Loop;
    --检查金额是否足够
    If Abs(n_预交金额) > 0 Then
      v_Err_Msg := '病人的当前预交余额小于本次支付金额 ' || LTrim(To_Char(冲预交_In, '9999999990.00')) || '，支付失败！';
      Raise Err_Item;
    End If;
  End If;

  If 操作类型_In = 0 Then
  
    If Nvl(退支票额_In, 0) <> 0 Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, Null, v_退支票, r_Balancedata.收款时间, r_Balancedata.操作员编号,
         r_Balancedata.操作员姓名, 退支票额_In, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null, Null, 卡号_In,
         交易流水号_In, 交易说明_In, Null, 3);
    
      Update 病人预交记录 Set 冲预交 = 冲预交 - 退支票额_In Where 结帐id = 结帐id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
        Raise Err_Item;
      End If;
    End If;
  
    --各个收费结算 :格式为:"结算方式|结算金额|结算号码|结算摘要||.."
    v_结算内容 := 结算方式_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
    
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If Nvl(n_结算金额, 0) <> 0 Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号,
           2, Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, v_结算号码, 3);
      
        Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 结帐id_In And 结算方式 Is Null;
        If Sql%NotFound Then
          v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
          Raise Err_Item;
        End If;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If 操作类型_In = 1 Then
    --三方卡结算交易
  
    v_当前结算 := 结算方式_In;
  
    v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
  
    If Nvl(n_结算金额, 0) <> 0 Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
         r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号,
         2, 卡类别id_In, Null, 卡号_In, 交易流水号_In, 交易说明_In, v_结算号码, 3);
    
      Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 结帐id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
        Raise Err_Item;
      End If;
    End If;
  End If;

  --2.医保结算(调用此过程,采取平均分摊的方式分摊结算情况):这种情况医保结处后,必须全退
  If 操作类型_In = 2 Then
    --2.1检查是否已经存在医保结算数据,存在先删除
    n_结算金额 := 0;
    For v_医保 In (Select ID, 结算方式, 冲预交
                 From 病人预交记录 A
                 Where 结帐id = 结帐id_In And Exists
                  (Select 1 From 结算方式 Where a.结算方式 = 名称 And 性质 In (3, 4)) And Mod(记录性质, 10) <> 1)
    
     Loop
      n_结算金额 := n_结算金额 + Nvl(v_医保.冲预交, 0);
      l_预交id.Extend;
      l_预交id(l_预交id.Count) := v_医保.Id;
    End Loop;
    If Nvl(n_结算金额, 0) <> 0 Then
      Update 病人预交记录
      Set 冲预交 = Nvl(冲预交, 0) + Nvl(n_结算金额, 0)
      Where 结帐id = 结帐id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
        Raise Err_Item;
      End If;
    End If;
    If l_预交id.Count <> 0 Then
      Forall I In 1 .. l_预交id.Count
        Delete 病人预交记录 Where ID = l_预交id(I);
    End If;
  
    If 结算方式_In Is Not Null Then
      v_结算内容 := 结算方式_In || '||';
    End If;
  
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      For c_结算信息 In (Select 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号
                     From 病人预交记录
                     Where 结帐id = 结帐id_In And 结算方式 Is Null) Loop
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, c_结算信息.病人id, Null, '保险结算', v_结算方式, c_结算信息.收款时间, c_结算信息.操作员编号, c_结算信息.操作员姓名,
           n_结算金额, c_结算信息.结帐id, c_结算信息.缴款组id, c_结算信息.结算序号, 1, 3);
      End Loop;
      --更新数据(结算方式为NULL的)
      Update 病人预交记录
      Set 冲预交 = 冲预交 - n_结算金额
      Where 结帐id = 结帐id_In And 结算方式 Is Null
      Returning Nvl(冲预交, 0) Into n_返回值;
    
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --3-消费卡批量结算
  If 操作类型_In = 3 Then
    v_结算内容 := 结算方式_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      --卡类别ID|卡号|消费卡ID|消费金额
      n_卡类别id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_卡号     := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_消费卡id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(v_当前结算);
      Begin
        Select 名称, 自制卡, 结算方式 Into v_名称, n_自制卡, v_结算方式 From 卡消费接口目录 Where 编号 = 卡类别id_In;
      Exception
        When Others Then
          v_名称 := Null;
      End;
      If v_名称 Is Null Then
        v_Err_Msg := '未找到对应的结算卡接口,本次刷卡消费失败!';
        Raise Err_Item;
      End If;
      If v_结算方式 Is Null Then
        v_Err_Msg := v_名称 || '未设置对应的结算方式,本次刷卡消费失败!';
        Raise Err_Item;
      End If;
      If Nvl(n_消费卡id, 0) = 0 Then
        --未传入消费卡ID时,以卡号为准进行查找(卡号的合法性,在程序中有判断)
        Begin
          Select ID
          Into n_消费卡id
          From 消费卡目录
          Where 接口编号 = n_卡类别id And 卡号 = v_卡号 And
                序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = n_卡类别id And 卡号 = v_卡号);
        Exception
          When Others Then
            n_消费卡id := 0;
        End;
        If Nvl(n_消费卡id, 0) = 0 Then
          v_Err_Msg := '未找到卡号为:' || v_卡号 || '的' || v_名称 || '.,本次刷卡消费失败!';
          Raise Err_Item;
        End If;
      End If;
    
      If Nvl(n_结算金额, 0) <> 0 Then
      
        Update 病人预交记录
        Set 冲预交 = Nvl(冲预交, 0) + n_结算金额
        Where 结帐id = r_Balancedata. 结帐id And 结算方式 = v_结算方式 And 结算卡序号 = n_卡类别id
        Returning ID Into n_预交id;
        If Sql%NotFound Then
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算卡序号, 校对标志, 结算性质)
          Values
            (n_预交id, 3, Null, 1, r_Balancedata. 病人id, Null, Null, v_结算方式, r_Balancedata. 收款时间, r_Balancedata. 操作员编号,
             r_Balancedata. 操作员姓名, n_结算金额, r_Balancedata. 结帐id, r_Balancedata. 缴款组id, r_Balancedata. 结算序号, n_卡类别id, 2, 3);
        End If;
      
        --插入卡结算记录
        Begin
          Select Nvl(Max(Nvl(序号, 0)), 0) + 1
          Into n_序号
          From 病人卡结算记录
          Where 接口编号 = n_卡类别id And Nvl(消费卡id, 0) = Nvl(n_消费卡id, 0) And 卡号 = v_卡号;
        Exception
          When Others Then
            n_序号 := 1;
        End;
      
        Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      
        Insert Into 病人卡结算记录
          (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Values
          (n_Id, n_卡类别id, n_消费卡id, n_序号, 1, v_结算方式, n_结算金额, v_卡号, Null, r_Balancedata. 收款时间, Null, 0);
        --如果消费卡,需同时更改其余额
        If Nvl(n_消费卡id, 0) <> 0 Then
          Update 消费卡目录 Set 余额 = 余额 - n_结算金额 Where ID = n_消费卡id;
          If Sql%NotFound Then
            v_Err_Msg := '卡号为' || v_卡号 || '的' || v_名称 || '未找到!';
            Raise Err_Item;
          End If;
        End If;
        Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
      
        --更新数据(结算方式为NULL的)
        Update 病人预交记录
        Set 冲预交 = 冲预交 - n_结算金额
        Where 结帐id = r_Balancedata. 结帐id And 结算方式 Is Null And Nvl(校对标志, 0) = 1
        Returning Nvl(冲预交, 0) Into n_返回值;
      
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If Nvl(完成结算_In, 0) = 0 Then
    Return;
  End If;

  -----------------------------------------------------------------------------------------
  --完成收费,需要处理人员缴款余额,预交记录(结算方式=NULL)

  --1.删除结算方式为NULL的预交记录
  Delete 病人预交记录 Where 结帐id = 结帐id_In And 结算方式 Is Null And Nvl(冲预交, 0) = 0;
  If Sql%NotFound Then
    Select Count(*) Into n_Count From 病人预交记录 A Where 结帐id = 结帐id_In And 结算方式 Is Null;
    If n_Count <> 0 Then
      v_Err_Msg := '还存在未缴款的数据,不能完成结算!';
    Else
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！!';
    End If;
    Raise Err_Item;
  End If;

  --检查门诊费用记录与病人预交记录的金额是否相等
  n_结算金额 := 0;
  n_冲预交   := 0;
  Select Nvl(Sum(实收金额), 0) Into n_结算金额 From 门诊费用记录 Where 结帐id = 结帐id_In;
  Select Nvl(Sum(冲预交), 0) Into n_冲预交 From 病人预交记录 Where 结帐id = 结帐id_In;
  If n_结算金额 <> n_冲预交 Then
    v_Err_Msg := '结算信息有误，实收金额(' || n_结算金额 || ')与结算金额(' || n_冲预交 || ')不一致，不能完成结算！';
    Raise Err_Item;
  End If;

  --结算金额为零时，增加一条金额为0的病人预交记录
  Select Count(*) Into n_Count From 病人预交记录 A Where 结帐id = 结帐id_In;

  If n_Count = 0 Then
    v_结算方式 := 缺省结算方式_In;
    If v_结算方式 Is Null Then
      Begin
        Select 结算方式 Into v_结算方式 From 结算方式应用 Where 应用场合 = '收费' And Nvl(缺省标志, 0) = 1;
      Exception
        When Others Then
          v_结算方式 := Null;
      End;
      If v_结算方式 Is Null Then
        Begin
          Select 名称 Into v_结算方式 From 结算方式 Where Nvl(性质, 0) = 1;
        Exception
          When Others Then
            v_结算方式 := '现金';
        End;
      End If;
    End If;
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
       交易流水号, 交易说明, 结算号码, 结算性质)
    Values
      (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, Null, v_结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
       r_Balancedata.操作员姓名, 0, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null, Null, Null, Null,
       交易说明_In, Null, 3);
  End If;

  --2.处理缴款数据和找补数据及校对标志更新为0
  Update 病人预交记录 Set 缴款 = 缴款_In, 找补 = 找补_In, 校对标志 = 0 Where 结帐id = 结帐id_In;

  --3.更新费用状态
  Update 门诊费用记录 Set 费用状态 = 0 Where 结帐id = 结帐id_In;

  --4.更新人员缴款数据
  For c_缴款 In (Select 结算方式, 操作员姓名, Sum(Nvl(a.冲预交, 0)) As 冲预交
               From 病人预交记录 A
               Where a.结帐id = 结帐id_In And Mod(a.记录性质, 10) <> 1
               Group By 结算方式, 操作员姓名) Loop
  
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + Nvl(c_缴款.冲预交, 0)
    Where 收款员 = c_缴款.操作员姓名 And 性质 = 1 And 结算方式 = c_缴款.结算方式;
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额
        (收款员, 结算方式, 性质, 余额)
      Values
        (c_缴款.操作员姓名, c_缴款.结算方式, 1, Nvl(c_缴款.冲预交, 0));
    End If;
  End Loop;
  --收费后产生导引
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 4, 结帐id_In;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费结算_Modify;
/

--91225:梁经伙,2015-12-28,在疾病申报记录里面处理状态是1才可报送，但是在传染病管理系统里面处理状态是3才能报送
Create Or Replace Procedure Zl_疾病申报记录_Send
(
  文件id_In   In Varchar2,
  报送人_In   In 疾病申报记录.报送人%Type,
  报送时间_In In 疾病申报记录.报送时间%Type,
  报送单位_In In 疾病申报记录.报送单位%Type,
  报送备注_In In 疾病申报记录.报送备注%Type
) Is
  v_姓名   人员表.姓名%Type;
  n_文件id Number;
  e_Changed Exception;
Begin

  If Length(文件id_In) <> 32 Then
    n_文件id := To_Number(文件id_In); --新病历ID是32位GUID
  End If;

  Select 姓名 Into v_姓名 From 人员表 P, 上机人员表 U Where p.Id = u.人员id And u.用户名 = User And Rownum < 2;
  If Length(文件id_In) <> 32 Then
    --如果没有归档，则将其归档 
    Update 电子病历记录 Set 归档人 = v_姓名, 归档日期 = Sysdate Where ID = 文件id_In And 归档人 Is Null;
  End If;

  Update 疾病申报记录
  Set 处理状态 = 2, 报送人 = 报送人_In, 报送时间 = 报送时间_In, 报送单位 = 报送单位_In, 报送备注 = 报送备注_In, 登记人 = v_姓名, 登记时间 = Sysdate
  Where Decode(Length(文件id_In), 32, 文档id, 文件id) = Decode(Length(文件id_In), 32, 文件id_In, n_文件id) And (处理状态 = 1 or 处理状态 = 3);
  If Sql%RowCount = 0 Then
    Raise e_Changed;
  End If;
Exception
  When No_Data_Found Then
    Raise_Application_Error(-20101, '[ZLSOFT]用户身份不明确！[ZLSOFT]');
  When e_Changed Then
    Raise_Application_Error(-20101, '[ZLSOFT]疾病报告已经被其他用户改变！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_疾病申报记录_Send;
/

--91780:刘尔旋,2015-12-28,相同发票号轧帐
Create Or Replace Procedure Zl_收费员轧帐票据_Insert
(
  收缴id_In   In 人员收缴票据.收缴id%Type,
  票据信息_In Varchar2
) Is
  --------------------------------------------------------------------------------------------------------------------
  --功能:收费员轧帐明细写入
  --参数:结算信息_IN:票种,性质,序号,票据张数,开始票号,终止票号,金额,发生时间|票种,性质,序号,票据张数,开始票号,终止票号,金额,发生时间|...
  --                 票种:1-收费收据,2-预交收据,3-结帐收据,4-挂号收据,5-就诊卡
  --         性质:1-正常票据;2-退费收回票据;3-重打收回票据
  --                 发生时间:yyyy-mm-dd hh24:mi:ss
  --
  --------------------------------------------------------------------------------------------------------------------
  v_结算内容 Varchar2(4000);
  v_当前结算 Varchar2(500);

  n_票种     人员收缴票据.票种%Type;
  n_性质     人员收缴票据.性质%Type;
  n_序号     人员收缴票据.序号%Type;
  n_票据张数 人员收缴票据.票据张数%Type;
  v_开始票号 人员收缴票据.开始票号%Type;
  v_终止票号 人员收缴票据.终止票号%Type;
  n_金额     人员收缴票据.金额%Type;
  v_发生时间 Varchar2(20);
  v_批次     人员收缴票据.批次%Type;

  t_开始票号 t_Strlist := t_Strlist();
  t_终止票号 t_Strlist := t_Strlist();
  t_发生时间 t_Strlist := t_Strlist();
  t_批次     t_Strlist := t_Strlist();
  t_票种     t_Numlist := t_Numlist();
  t_性质     t_Numlist := t_Numlist();
  t_序号     t_Numlist := t_Numlist();
  t_金额     t_Numlist := t_Numlist();
  t_票据张数 t_Numlist := t_Numlist();
Begin

  v_结算内容 := 票据信息_In || '|'; --以空格分开以|结尾,没有结算号码的
  While v_结算内容 Is Not Null Loop
  
    v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '|') - 1);
    n_票种     := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1));
    t_票种.Extend;
    t_票种(t_票种.Count) := n_票种;
  
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
    n_性质     := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1));
    t_性质.Extend;
    t_性质(t_性质.Count) := n_性质;
  
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
    n_序号     := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1));
    t_序号.Extend;
    t_序号(t_序号.Count) := n_序号;
  
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
    n_票据张数 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1));
    t_票据张数.Extend;
    t_票据张数(t_票据张数.Count) := n_票据张数;
  
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
    v_开始票号 := Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1);
    t_开始票号.Extend;
    t_开始票号(t_开始票号.Count) := v_开始票号;
  
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
    v_终止票号 := Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1);
    t_终止票号.Extend;
    t_终止票号(t_终止票号.Count) := v_终止票号;
  
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
    n_金额     := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1));
    t_金额.Extend;
    t_金额(t_金额.Count) := n_金额;
  
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
    v_发生时间 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1));
    t_发生时间.Extend;
    If Nvl(v_发生时间, '-') = '-' Then
      t_发生时间(t_发生时间.Count) := Null;
    Else
      t_发生时间(t_发生时间.Count) := v_发生时间;
    End If;
  
    v_批次 := LTrim(Substr(v_当前结算, Instr(v_当前结算, ',') + 1));
    t_批次.Extend;
    If Nvl(v_批次, '-') = '-' Then
      t_批次(t_批次.Count) := Null;
    Else
      t_批次(t_批次.Count) := v_批次;
    End If;
  
    v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '|') + 1);
  End Loop;
  --批量插入数据
  Forall I In 1 .. t_票种.Count
    Insert Into 人员收缴票据
      (收缴id, 票种, 性质, 序号, 票据张数, 开始票号, 终止票号, 金额, 发生时间, 批次)
    Values
      (收缴id_In, t_票种(I), t_性质(I), t_序号(I), t_票据张数(I), t_开始票号(I), t_终止票号(I), t_金额(I),
       To_Date(t_发生时间(I), 'yyyy-mm-dd hh24:mi:ss'), t_批次(I));
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_收费员轧帐票据_Insert;
/

--91225:梁经伙,2016-01-04,传染病管理系统在疾病申报记录表中添加了字段
CREATE OR REPLACE Procedure Zl_疾病申报记录_Incept
(
  文件id_In     In 疾病申报记录.文件id%Type,
  Incept_In     In Number, --接收还是拒绝
  说明_In       In 疾病申报记录.收拒说明%Type,
  文档id_In     In Varchar2,
  病人id_In     In 疾病申报记录.病人ID%Type,
  主页ID_In     In 疾病申报记录.主页ID%Type,
  病人来源_In   In 疾病申报记录.病人来源%Type,
  Emrcontent_In In Varchar2   --新病历诊断串
) Is
  v_收拒人   人员表.姓名%Type;

  v_姓名      疾病申报记录.姓名%Type;
  v_性别      疾病申报记录.性别%Type;
  v_年龄      疾病申报记录.年龄%Type;
  v_职业      疾病申报记录.职业%Type;
  v_家庭地址  疾病申报记录.家庭地址%Type;
  v_家庭电话  疾病申报记录.家庭电话%Type;
  v_发病日期  疾病申报记录.发病日期%Type;
  v_确诊日期  疾病申报记录.确诊日期%Type;
  v_诊断描述1 疾病申报记录.诊断描述1%Type;
  v_诊断描述2 疾病申报记录.诊断描述2%Type;
  v_填报备注  疾病申报记录.填报备注%Type;
  v_内容文本  电子病历内容.内容文本%Type;
  v_报卡类型  疾病申报记录.报卡类型%Type;
  v_报告医生  疾病申报记录.报告医生%Type;

  v_Count Number;
  e_Changed Exception;

  Function Trimlen
  (
    Str_In Varchar2,
    Len_In Number
  ) Return Varchar2 Is
    v_Temp Varchar2(4000);
  Begin
    If Str_In Is Not Null Then
      For I In 1 .. Length(Str_In) Loop
        If Lengthb(v_Temp || Substr(Str_In, I, 1)) <= Len_In Then
          v_Temp := v_Temp || Substr(Str_In, I, 1);
        Else
          Exit;
        End If;
      End Loop;
    End If;
    Return v_Temp;
  End Trimlen;
Begin

  Select 姓名 Into v_收拒人 From 人员表 P, 上机人员表 U Where p.Id = u.人员id And u.用户名 = User And Rownum < 2;

  If Length(文档id_In) <> 32 Then
    --新病历ID是32位GUID
    Update 电子病历记录 Set 处理状态 = Decode(Incept_In, 1, 1, -1) Where ID = 文件id_In;
    If Sql%RowCount = 0 Then
      Raise e_Changed;
    End If;
  End If;

  --自动提取申报病历中的项目内容
  If Incept_In = 1 Then
    If Length(文档id_In) <> 32 Then
      --固定对应要素
      v_Count := 0;
      For r_Item In (Select 要素名称, 要素类型, 内容行次, 内容文本
                     From 电子病历内容
                     Where (对象类型 = 4 or 对象类型 = 8 )And 文件id = 文件id_In
                     Order By 对象序号, 内容行次) Loop

        If r_Item.要素名称 = '姓名' Then
          v_姓名 := Trimlen(r_Item.内容文本, 20);
        Elsif r_Item.要素名称 = '性别' Then
          v_性别 := Trimlen(r_Item.内容文本, 4);
        Elsif r_Item.要素名称 = '年龄' Then
          v_年龄 := Trimlen(r_Item.内容文本, 10);
        Elsif r_Item.要素名称 = '职业' Or r_Item.要素名称 = '患者职业' Then
          v_职业 := Trimlen(r_Item.内容文本, 80);
        Elsif r_Item.要素名称 = '家庭地址' Then
          v_家庭地址 := Trimlen(r_Item.内容文本, 100);
        Elsif r_Item.要素名称 = '住址' Then
          v_家庭地址 := Trimlen(Replace(r_Item.内容文本, ';', ''), 100);
        Elsif r_Item.要素名称 = '家庭电话' Or r_Item.要素名称 = '联系电话' Then
          v_家庭电话 := Trimlen(r_Item.内容文本, 20);
        Elsif r_Item.要素名称 = '当前日期' Or r_Item.要素名称 = '发病日期' Or r_Item.要素名称 = '诊断日期' Then
          v_Count := v_Count + 1;
          If (v_Count = 1 And r_Item.要素名称 = '当前日期') Or r_Item.要素名称 = '发病日期' Then
            --病历中第1个"当前日期"作为发病日期
            Begin
              v_发病日期 := To_Date(Replace(Replace(Replace(r_Item.内容文本, '年', '-'), '月', '-'), '日', ''), 'YYYY-MM-DD');
            Exception
              When Others Then
                Null;
            End;
          Elsif (v_Count = 2 And r_Item.要素名称 = '当前日期') Or r_Item.要素名称 = '诊断日期' Then
            --病历中第2个"当前日期"作为确诊日期
            Begin
              v_确诊日期 := To_Date(Replace(Replace(Replace(r_Item.内容文本, '年', '-'), '月', '-'), '日', ''), 'YYYY-MM-DD');
            Exception
              When Others Then
                Null;
            End;
          End If;
        Elsif r_Item.要素名称 = '常见传染病' Then
          v_诊断描述1 := Trimlen(r_Item.内容文本, 150);
        Elsif (r_Item.要素名称 = '甲类传染病' Or r_Item.要素名称 = '乙类传染病' Or r_Item.要素名称 = '丙类传染病') And r_Item.内容文本 Is Not Null Then
          If v_诊断描述1 Is Null Then
            v_诊断描述1 := Trimlen(r_Item.内容文本, 150);
          Else
            v_诊断描述1 := Trimlen(v_诊断描述1 || ';' || r_Item.内容文本, 150);
          End If;
        Elsif r_Item.要素名称 = '报卡类别' Then
          v_报卡类型 :=Trimlen(r_Item.内容文本, 20);
        Elsif r_Item.要素名称 = '填卡医生' Then
           v_报告医生:=Trimlen(r_Item.内容文本, 20);
        End If;
		if  instr(v_诊断描述1,';') = 1 then
            v_诊断描述1:=substr(v_诊断描述1,2);
        end if;
      End Loop;
        --其他临时要素对应
      For r_Item In (Select 申报项目, 对应要素 From 疾病申报对应) Loop
        Begin
          Select 内容文本
          Into v_内容文本
          From 电子病历内容
          Where 对象类型 = 4 And 诊治要素id Is Null And 要素名称 = r_Item.对应要素 And 文件id = 文件id_In;
        Exception
          When Others Then
            v_内容文本 := Null;
        End;

        If r_Item.申报项目 = '诊断描述2' Then
          v_诊断描述2 := Trimlen(v_内容文本, 150);
		  if  instr(v_诊断描述2,';') = 1 then
            v_诊断描述2:=substr(v_诊断描述2,2);
          end if;
        Elsif r_Item.申报项目 = '填报备注' Then
          v_填报备注 := Trimlen(v_内容文本, 100);
        End If;
      End Loop;
    Else
      Select 姓名, 性别, 年龄, 职业, 家庭地址, 家庭电话, 家庭电话
      Into v_姓名, v_性别, v_年龄, v_职业, v_家庭地址, v_家庭电话, v_家庭电话
      From 病人信息
      Where 病人id = 病人id_In;
      v_发病日期  := '';
      v_确诊日期  := '';
      v_诊断描述1 := Substr(Emrcontent_In, 1, Instr(Emrcontent_In, '|') - 1);
      v_诊断描述2 := '';
      v_填报备注  := Substr(Emrcontent_In, Instr(Emrcontent_In, '|') + 1,Instr(Emrcontent_In, '|',1,2)-1-Instr(Emrcontent_In, '|'));
      v_报卡类型  := '1 初次报告';
      v_报告医生  := Substr(Emrcontent_In, Instr(Emrcontent_In, '|',1,2) + 1);
    End If;
  End If;

  --接收数据
  Update 疾病申报记录
  Set 处理状态 = Decode(Incept_In, 1, 1, -1), 收拒人 = v_收拒人, 收拒时间 = Sysdate, 收拒说明 = 说明_In, 姓名 = v_姓名, 性别 = v_性别, 年龄 = v_年龄,
      职业 = v_职业, 家庭地址 = v_家庭地址, 家庭电话 = v_家庭电话, 发病日期 = v_发病日期, 确诊日期 = v_确诊日期, 诊断描述1 = v_诊断描述1, 诊断描述2 = v_诊断描述1,
      填报备注 = v_填报备注, 报告医生 = v_报告医生,报卡类型 = v_报卡类型,病人id= 病人id_In,主页ID = 主页ID_In,病人来源 = 病人来源_In
  Where 文件id = 文件id_In;
  If Sql%RowCount = 0 Then
    Insert Into 疾病申报记录
      (文件id, 处理状态, 收拒人, 收拒时间, 收拒说明, 姓名, 性别, 年龄, 职业, 家庭地址, 家庭电话, 发病日期, 确诊日期, 诊断描述1, 诊断描述2, 填报备注, 文档id, 报告医生, 报卡类型,病人id,主页ID,病人来源)
    Values
      (文件id_In, Decode(Incept_In, 1, 1, -1), v_收拒人, Sysdate, 说明_In, v_姓名, v_性别, v_年龄, v_职业, v_家庭地址, v_家庭电话, v_发病日期,
       v_确诊日期, v_诊断描述1, v_诊断描述2, v_填报备注, 文档id_In, v_报告医生, v_报卡类型,病人id_In,主页ID_In,病人来源_In);
  End If;
Exception
  When No_Data_Found Then
    Raise_Application_Error(-20101, '[ZLSOFT]用户身份不明确！[ZLSOFT]');
  When e_Changed Then
    Raise_Application_Error(-20101, '[ZLSOFT]疾病报告已经被其他用户改变！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_疾病申报记录_Incept;
/

--92454:刘尔旋,2016-01-07,三方挂号排队问题
--92007:刘尔旋,2015-12-25,三方预约填写预约操作员
Create Or Replace Procedure Zl_三方机构挂号_Insert
(
  操作方式_In      Integer,
  病人id_In        门诊费用记录.病人id%Type,
  号码_In          挂号安排.号码%Type,
  号序_In          挂号序号状态.序号%Type,
  单据号_In        门诊费用记录.No%Type,
  票据号_In        门诊费用记录.实际票号%Type,
  结算方式_In      病人预交记录.结算方式%Type, --现金的结算名称
  摘要_In          门诊费用记录.摘要%Type, --预约挂号摘要信息
  发生时间_In      门诊费用记录.发生时间%Type,
  登记时间_In      门诊费用记录.登记时间%Type,
  合作单位_In      挂号合作单位.名称%Type,
  挂号金额合计_In  门诊费用记录.实收金额%Type,
  领用id_In        票据使用明细.领用id%Type,
  收费票据_In      Number := 0, --挂号是否使用收费票据
  交易流水号_In    病人预交记录.交易流水号%Type,
  交易说明_In      病人预交记录.交易说明%Type,
  预约方式_In      预约方式.名称%Type := Null,
  预交id_In        病人预交记录.Id%Type := Null,
  卡类别id_In      病人预交记录.卡类别id%Type := Null,
  加入序号状态_In  Number := 0,
  是否自助设备_In  Number := 0,
  结帐id_In        门诊费用记录.结帐id%Type := Null,
  锁定类型_In      Number := 0,
  保险结算_In      Varchar2 := Null,
  冲预交_In        Number := Null,
  支付卡号_In      病人预交记录.卡号%Type := Null,
  退号重用_In      Number := 1,
  费别_In          门诊费用记录.费别%Type := Null,
  冲预交病人ids_In Varchar2 := Null,
  机器名_In        挂号序号状态.机器名%Type := Null,
  更新年龄_In      Number := 0,
  购买病历_In      Number := 0
) As
  --功能：三方机构进行挂号(包含预约;预约挂号不扣款;预约挂号扣款)
  --入参:操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
  --      加入序号状态_In:1-表示强制加入挂号序号状态表中;否则根据启用序号或启用时段时才加入.
  --      是否自助设备_In:1-表示是医院的自助设备进行此函数的调用,自助设备调用此函数 允许加号,否则不允许
  --      锁定类型_In :0-产生正常数据 1-表示对单据进行锁定,产生未生效的单据信息;2-对锁定的记录进行解锁-生成正常数据:未生效的单据在银行扣款完成后进行解锁
  --      保险结算_IN:格式="结算方式|结算金额||....."
  --      冲预交病人ids_In:多个用逗分分离,冲预交时有效(冲预交类别与业务操作保持一致),主要是使用家属的预交款
  Err_Item Exception;
  v_Err_Msg  Varchar2(255);
  n_打印id   票据打印内容.Id%Type;
  n_返回值   病人预交记录.金额%Type;
  v_排队号码 Varchar2(20);
  v_队列名称 排队叫号队列.队列名称%Type;
  n_预交id   病人预交记录.Id%Type;
  n_挂号id   病人挂号记录.Id%Type;
  v_结算内容 Varchar2(3000);
  v_当前结算 Varchar2(150);

  v_结算方式       病人预交记录.结算方式%Type;
  n_结算金额       病人预交记录.冲预交%Type;
  n_结算合计       Number(16, 5);
  n_预交金额       病人预交记录.冲预交%Type;
  n_组id           财务缴款分组.Id%Type;
  d_排队时间       Date;
  n_锁定           Number;
  n_同科限约一个号 Number(18);
  n_病人预约科室数 Number(18);
  n_已约科室       Number(18);

  n_合作单位限制       Number(18);
  n_是否开放           Number(1);
  n_Count              Number(18);
  n_行号               Number(18);
  n_序号               病人挂号记录.号序%Type;
  n_费用id             门诊费用记录.Id%Type;
  n_价格父号           Number(18);
  n_原项目id           收费项目目录.Id%Type;
  n_原收入项目id       收费项目目录.Id%Type;
  v_诊室               病人挂号记录.诊室%Type;
  n_安排id             挂号安排.Id%Type;
  n_实收金额合计       门诊费用记录.实收金额%Type;
  n_开单部门id         门诊费用记录.开单部门id%Type;
  n_实收金额           门诊费用记录.实收金额%Type;
  n_应收金额           门诊费用记录.实收金额%Type;
  n_结帐id             病人结帐记录.Id%Type;
  v_Temp               Varchar2(500);
  n_预约时段序号       Number;
  n_预约总数           Number;
  d_时段开始时间       Date;
  v_收费项目ids        Varchar2(300);
  n_预约数量           合作单位挂号汇总.已约数%Type;
  n_号序               病人挂号记录.号序%Type;
  d_登记时间           Date;
  v_操作员编号         人员表.编号%Type;
  v_操作员姓名         人员表.姓名%Type;
  n_预约               Integer;
  v_星期               挂号安排时段.星期%Type;
  n_启用分时段         Integer;
  n_已挂数             病人挂号汇总.已挂数%Type;
  n_已约数             病人挂号汇总.已约数%Type;
  n_其中已接收         病人挂号汇总.已约数%Type;
  n_预约生成队列       Number;
  d_Date               Date;
  n_挂号序号           Number;
  v_排队标记           排队叫号队列.排队标记%Type;
  v_排队序号           排队叫号队列.排队序号%Type;
  v_机器名             挂号序号状态.机器名%Type;
  v_序号操作员         挂号序号状态.操作员姓名%Type;
  v_序号机器名         挂号序号状态.机器名%Type;
  n_序号锁定           Number := 0;
  n_病历费id           收费特定项目.收费细目id%Type;
  v_付款方式           病人挂号记录.医疗付款方式%Type;
  v_费别               门诊费用记录.费别%Type;
  n_屏蔽费别           Number(3) := 0;
  v_冲预交病人ids      Varchar2(4000);
  n_Tmp安排id          挂号安排.Id%Type;
  n_计划id             挂号安排计划.Id%Type;
  v_年龄               病人信息.年龄%Type;
  n_合作单位限数量模式 Number;

  Cursor c_Pati(n_病人id 病人信息.病人id%Type) Is
    Select a.病人id, a.姓名, a.性别, a.年龄, a.住院号, a.门诊号, a.费别, a.险类, c.编码 As 付款方式
    From 病人信息 A, 医疗付款方式 C
    Where a.病人id = n_病人id And a.医疗付款方式 = c.名称(+);

  r_Pati c_Pati%RowType;

  --该游标用于收费冲预交的可用预交列表
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit
  (
    n_病人id        病人信息.病人id%Type,
    v_冲预交病人ids Varchar2
  ) Is
    Select *
    From (Select a.Id, a.病人id, a.记录状态, a.预交类别, a.No, Nvl(a.金额, 0) As 金额
           From 病人预交记录 A,
                (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                  From 病人预交记录 A
                  Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And
                        a.病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And Nvl(a.预交类别, 2) = 1
                  Group By NO
                  Having Sum(Nvl(a.金额, 0)) <> 0) B
           Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.结算方式 Not In (Select 名称 From 结算方式 Where 性质 = 5) And
                 a.No = b.No And a.病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And
                 Nvl(a.预交类别, 2) = 1
           Union All
           Select 0 As ID, Max(病人id) As 病人id, 记录状态, 预交类别, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
           From 病人预交记录
           Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(金额, 0) <> Nvl(冲预交, 0) And
                 病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And Nvl(预交类别, 2) = 1 Having
            Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
           Group By 记录状态, NO, 预交类别)
    Order By Decode(病人id, Nvl(n_病人id, 0), 0, 1), ID, NO;

  Cursor c_安排
  (
    v_号码        挂号安排.号码%Type,
    d_发生时间_In Date
  ) Is
    Select *
    From (With 安排时间段 As (Select 时间段
                         From (Select 时间段,
                                       To_Date(Decode(Sign(开始时间 - 终止时间), 1, '3000-01-09 ' || To_Char(开始时间, 'HH24:MI:SS'),
                                                       '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS')), 'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                       To_Date(Decode(Sign(开始时间 - 终止时间), 1, '3000-01-11 ' || To_Char(终止时间, 'HH24:MI:SS'),
                                                       '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS')), 'yyyy-mm-dd hh24:mi:ss') As 终止时间,
                                       To_Date('3000-01-10 ' || To_Char(d_发生时间_In, 'HH24:MI:SS'), 'yyyy-mm-dd hh24:mi:ss') As 当前时间,
                                       To_Date('3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS'), 'yyyy-mm-dd hh24:mi:ss') As 开始时间1,
                                       To_Date('3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS'), 'yyyy-mm-dd hh24:mi:ss') As 终止时间1
                                From 时间段)
                         Where 当前时间 Between 开始时间 And 终止时间1 Or 当前时间 Between 开始时间1 And 终止时间)
           Select Distinct p.Id, p.号类, p.号码, p.科室id, b.编码 As 科室编码, b.名称 As 科室名称, p.项目id, c.编码 As 项目编码, c.名称 As 项目名称,
                           p.医生id, d.编号 As 医生编号, p.医生姓名, p.限号数, p.限约数, p.周日 As 日, p.周一 As 一, p.周二 As 二, p.周三 As 三,
                           p.周四 As 四, p.周五 As 五, p.周六 As 六, p.序号控制, p.计划id
           From (Select p.Id, p.号码, p.号类, p.科室id, p.项目id, p.医生id, p.医生姓名, b.限号数, b.限约数, Nvl(p.病案必须, 0) As 病案必须, p.周日, p.周一,
                         p.周二, p.周三, p.周四, p.周五, p.周六, p.分诊方式, p.序号控制,
                         Decode(To_Char(d_发生时间_In, 'D'), '1', p.周日, '2', p.周一, '3', p.周二, '4', p.周三, '5', p.周四, '6', p.周五,
                                 '7', p.周六, Null) As 排班, Null As 计划id
                  From 挂号安排 P, 挂号安排限制 B
                  Where p.停用日期 Is Null And p.Id = b.安排id(+) And
                        b.限制项目(+) = Decode(To_Char(d_发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四',
                                           '6', '周五', '7', '周六', Null) And
                        d_发生时间_In Between Nvl(p.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                        Nvl(p.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Not Exists
                   (Select 1
                         From 挂号安排计划
                         Where 安排id = p.Id And (d_发生时间_In Between 生效时间 And 失效时间) And 审核时间 Is Not Null) And Not Exists
                   (Select 1
                         From 挂号安排停用状态
                         Where 安排id = p.Id And d_发生时间_In Between 开始停止时间 And 结束停止时间) And p.号码 = v_号码
                  Union All
                  Select c.Id, c.号码, c.号类, c.科室id, p.项目id, p.医生id, p.医生姓名, b.限号数, b.限约数, Nvl(c.病案必须, 0) As 病案必须, p.周日, p.周一,
                         p.周二, p.周三, p.周四, p.周五, p.周六, p.分诊方式, p.序号控制,
                         Decode(To_Char(d_发生时间_In, 'D'), '1', p.周日, '2', p.周一, '3', p.周二, '4', p.周三, '5', p.周四, '6', p.周五,
                                 '7', p.周六, Null) As 排班, p.Id As 计划id
                  From 挂号安排计划 P, 挂号安排 C, 挂号计划限制 B,
                       (Select Max(a.生效时间) As 生效, 安排id
                         From 挂号安排计划 A, 挂号安排 B
                         Where a.安排id = b.Id And a.审核时间 Is Not Null And
                               发生时间_In Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                               Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) And b.号码 = 号码_In
                         Group By 安排id) E
                  Where p.安排id = c.Id And p.Id = b.计划id(+) And p.生效时间 = e.生效 And p.安排id = e.安排id And
                        Nvl(p.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) = Nvl(e.生效, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                        b.限制项目(+) = Decode(To_Char(d_发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四',
                                           '6', '周五', '7', '周六', Null) And (d_发生时间_In Between p.生效时间 And p.失效时间) And
                        p.审核时间 Is Not Null And Not Exists
                   (Select 1
                         From 挂号安排停用状态
                         Where 安排id = c.Id And d_发生时间_In Between 开始停止时间 And 结束停止时间) And p.号码 = v_号码) P, 部门表 B, 收费项目目录 C,
                人员表 D
           Where p.科室id = b.Id And p.医生id = d.Id(+) And p.项目id = c.Id And
                 (c.撤档时间 Is Null Or c.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD')) And
                 (Nvl(p.医生id, 0) = 0 Or Exists
                  (Select 1
                   From 人员表 Q
                   Where p.医生id = q.Id And (q.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or q.撤档时间 Is Null))) And Exists
            (Select 1 From 安排时间段 Where 时间段 = p.排班))
           Order By 号码;


  r_安排 c_安排%RowType;

  Function Zl_诊室(号码_In 挂号安排.号码%Type) Return Varchar2 As
    n_分诊方式 挂号安排.分诊方式%Type;
    n_安排id   挂号安排.Id%Type;
    v_诊室     病人挂号记录.诊室%Type;
    v_Rowid    Varchar2(500);
    n_Next     Integer;
    n_First    Integer;
  Begin
  
    If 锁定类型_In = 2 Then
      --对单据进行解锁,首先检查是否存在锁定
      Select Count(Rowid) Into n_锁定 From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
      If n_锁定 = 0 Then
        v_Err_Msg := '单据号为(' || 单据号_In || ')的单据,不存在或者已经被解锁!';
        Raise Err_Item;
      End If;
      Select Max(号序) Into n_号序 From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
    End If;
  
    Begin
      Select ID, Nvl(分诊方式, 0) Into n_安排id, n_分诊方式 From 挂号安排 Where 号码 = 号码_In;
    Exception
      When Others Then
        n_安排id := -1;
    End;
  
    If n_安排id = -1 Then
      v_Err_Msg := '号码(' || 号码_In || ')未找到!';
      Raise Err_Item;
    End If;
    --0-不分诊、1-指定诊室、2-动态分诊、3-平均分诊,对应门诊诊室设置
    v_诊室 := Null;
    If n_分诊方式 = 1 Then
      --1-指定诊室
      Begin
        Select 门诊诊室 Into v_诊室 From 挂号安排诊室 Where 号表id = n_安排id;
      Exception
        When Others Then
          v_诊室 := Null;
      End;
    End If;
    If n_分诊方式 = 2 Then
      --2-动态分诊:该个号别当天挂号未诊数最少的诊室
      For c_诊室 In (Select 门诊诊室, Sum(Num) As Num
                   From (Select 门诊诊室, 0 As Num
                          From 挂号安排诊室
                          Where 号表id = n_安排id
                          Union All
                          Select 诊室, Count(诊室) As Num
                          From 病人挂号记录
                          Where Nvl(执行状态, 0) = 0 And 发生时间 Between Trunc(Sysdate) And Sysdate And 号别 = 号码_In And
                                诊室 In (Select 门诊诊室 From 挂号安排诊室 Where 号表id = n_安排id)
                          Group By 诊室)
                   Group By 门诊诊室
                   Order By Num) Loop
        v_诊室 := c_诊室.门诊诊室;
        Exit;
      End Loop;
    End If;
    If n_分诊方式 = 3 Then
    
      --平均分诊：当前分配=1表示下次应取的当前诊室
      n_Next  := 0;
      n_First := 1;
      For c_诊室 In (Select Rowid As Rid, 号表id, 门诊诊室, 当前分配 From 挂号安排诊室 Where 号表id = n_安排id) Loop
        If n_First = 1 Then
          v_Rowid := c_诊室.Rid;
        End If;
        If n_Next = 1 Then
          v_诊室 := c_诊室.门诊诊室;
          Update 挂号安排诊室 Set 当前分配 = 1 Where Rowid = c_诊室.Rid;
          Exit;
        End If;
        If Nvl(c_诊室.当前分配, 0) = 1 Then
          Update 挂号安排诊室 Set 当前分配 = 0 Where Rowid = c_诊室.Rid;
          n_Next := 1;
        End If;
      End Loop;
      If v_诊室 Is Null Then
        Update 挂号安排诊室 Set 当前分配 = 1 Where Rowid = v_Rowid Returning 门诊诊室 Into v_诊室;
      End If;
    End If;
  
    Return v_诊室;
  End;

  Function Zl_操作员
  (
    Type_In     Integer,
    Splitstr_In Varchar2
  ) Return Varchar2 As
    n_Step Number(18);
    v_Sub  Varchar2(1000);
    --Type_In:0-获取缺省部门ID;1-获取操作员编号;2-获取操作员姓名
    -- SplitStr:格式为:部门ID,部门名称;人员ID,人员编号,人员姓名(用Zl_Identity获取的)
  Begin
    If Type_In = 0 Then
      --缺省部门
      n_Step := Instr(Splitstr_In, ',');
      v_Sub  := Substr(Splitstr_In, 1, n_Step - 1);
      Return v_Sub;
    End If;
    If Type_In = 1 Then
      --操作员编码
      n_Step := Instr(Splitstr_In, ';');
      v_Sub  := Substr(Splitstr_In, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, 1, n_Step - 1);
      Return v_Sub;
    End If;
    If Type_In = 2 Then
      --操作员姓名
      n_Step := Instr(Splitstr_In, ';');
      v_Sub  := Substr(Splitstr_In, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      Return v_Sub;
    End If;
  End;

Begin
  v_冲预交病人ids := Nvl(冲预交病人ids_In, 病人id_In);

  If 费别_In Is Null Then
    Select Zl_Custom_Getpatifeetype(1, 病人id_In) Into v_费别 From Dual;
  Else
    v_费别 := 费别_In;
  End If;
  If v_费别 Is Null Then
    n_屏蔽费别 := 1;
    Select 名称 Into v_费别 From 费别 Where 缺省标志 = 1 And Rownum < 2;
  End If;
  Update 病人信息 Set 费别 = v_费别 Where 病人id = 病人id_In;

  If 更新年龄_In = 1 Then
    Select Zl_Age_Calc(病人id_In) Into v_年龄 From Dual;
    If v_年龄 Is Not Null Then
      Update 病人信息 Set 年龄 = v_年龄 Where 病人id = 病人id_In;
    End If;
  End If;
  --获取当前机器名称
  If 机器名_In Is Not Null Then
    v_机器名 := 机器名_In;
  Else
    Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
  End If;
  n_实收金额合计 := 0;
  Select Count(*) + 1
  Into n_挂号序号
  From 病人挂号记录
  Where 号别 = 号码_In And 登记时间 Between Trunc(发生时间_In) And Trunc(发生时间_In + 1) - 1 / 24 / 60 / 60;
  --Begin
  --部门ID,部门名称;人员ID,人员编号,人员姓名
  v_Temp := Zl_Identity(0);
  If Nvl(v_Temp, ' ') = ' ' Then
    v_Err_Msg := '当前操作人员未设置对应的人员关系,不能继续。';
    Raise Err_Item;
  End If;

  If 登记时间_In Is Null Then
    d_登记时间 := Sysdate;
  Else
    d_登记时间 := 登记时间_In;
  End If;
  If Trunc(Sysdate) > Trunc(发生时间_In) Then
    v_Err_Msg := '不能挂以前的号(' || To_Char(发生时间_In, 'yyyy-mm-dd') || ')。';
    Raise Err_Item;
  End If;
  n_同科限约一个号 := Nvl(zl_GetSysParameter('病人同科限约一个号', 1111), 0);
  n_病人预约科室数 := Nvl(zl_GetSysParameter('病人预约科室数', 1111), 0);
  n_开单部门id     := To_Number(Zl_操作员(0, v_Temp));
  v_操作员编号     := Zl_操作员(1, v_Temp);
  v_操作员姓名     := Zl_操作员(2, v_Temp);
  n_组id           := Zl_Get组id(v_操作员姓名);

  If 操作方式_In <> 1 Then
    --预约检查是否添加合作单位控制
    --如果设置了合作单位控制 则
    Begin
      Select ID
      Into n_计划id
      From 挂号安排计划
      Where 号码 = 号码_In And 发生时间_In Between Nvl(生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
            Nvl(失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Rownum < 2
      Order By 生效时间 Desc;
    Exception
      When Others Then
        Select ID Into n_Tmp安排id From 挂号安排 Where 号码 = 号码_In;
    End;
    If Nvl(n_计划id, 0) <> 0 Then
      Select Count(0)
      Into n_合作单位限制
      From 合作单位计划控制
      Where 合作单位 = 合作单位_In And 计划id = n_计划id And Rownum < 2;
    Else
      Select Count(0)
      Into n_合作单位限制
      From 合作单位安排控制
      Where 合作单位 = 合作单位_In And 安排id = n_Tmp安排id And Rownum < 2;
    End If;
  End If;

  If 操作方式_In <> 2 Then
    v_诊室 := Zl_诊室(号码_In);
  End If;
  If 操作方式_In <> 2 And 结算方式_In Is Not Null Then
    --检查结算方式是否完备
    Select Count(*) Into n_Count From 结算方式 Where 名称 = Nvl(结算方式_In, 'Lxh') And 性质 In (2, 7, 8);
    If Nvl(卡类别id_In, 0) <> 0 And n_Count = 0 Then
      Select Count(1)
      Into n_Count
      From 医疗卡类别
      Where ID = Nvl(卡类别id_In, 0) And 结算方式 = Nvl(结算方式_In, 'lxh');
    End If;
    If n_Count = 0 Then
      v_Err_Msg := '结算方式(' || 结算方式_In || ')未设置,请在结算方式管理中设置。';
      Raise Err_Item;
    End If;
  End If;

  --因为现在有按日编单据号规则,日挂号量不能超过10000次,所以要检查唯一约束。
  Select Count(*) Into n_Count From 门诊费用记录 Where 记录性质 = 4 And 记录状态 In (1, 3) And NO = 单据号_In;
  If n_Count <> 0 Then
    v_Err_Msg := '挂号单据号重复,不能保存！' || Chr(13) || '如果使用了按日顺序编号,当日挂号量不能超过10000人次。';
    Raise Err_Item;
  End If;

  Open c_Pati(病人id_In);
  n_Count := 0;
  Begin
    Fetch c_Pati
      Into r_Pati;
  Exception
    When Others Then
      n_Count := -1;
  End;
  If n_Count = -1 Then
    v_Err_Msg := '病人未找到，不能继续。';
    Raise Err_Item;
  End If;

  Open c_安排(号码_In, 发生时间_In);
  Begin
    Fetch c_安排
      Into r_安排;
  Exception
    When Others Then
      n_Count := -1;
  End;
  If n_Count = -1 Then
    v_Err_Msg := '该号别没有在' || To_Char(发生时间_In, 'yyyy-mm-dd hh24:mi:ss') || '中进行安排。';
    Raise Err_Item;
  End If;

  Select Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六', '周日')
  Into v_星期
  From Dual;
  Begin
    If r_安排.计划id Is Null Then
      Select 1 Into n_启用分时段 From 挂号安排时段 Where 安排id = r_安排.Id And 星期 = v_星期 And Rownum < 2;
    Else
      Select 1 Into n_启用分时段 From 挂号计划时段 Where 计划id = r_安排.计划id And 星期 = v_星期 And Rownum < 2;
    End If;
  Exception
    When Others Then
      n_启用分时段 := 0;
  End;

  --对参数控制进行检查
  --仅在预约不扣款时进行检查
  If 操作方式_In = 2 Then
    If Nvl(n_同科限约一个号, 0) <> 0 Or Nvl(n_病人预约科室数, 0) <> 0 Then
      n_已约科室 := 0;
      For c_Chkitem In (Select Count(1) As 已约, a.执行部门id As 科室id, Nvl(k.名称, '') As 科室
                        From 病人挂号记录 A, 病人信息 B, 部门表 K
                        Where a.病人id = b.病人id And a.病人id = 病人id_In And a.执行部门id = k.Id(+) And a.记录性质 = 2 And 记录状态 = 1 And
                              a.预约时间 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60
                        Group By a.执行部门id, k.名称) Loop
        If Nvl(n_同科限约一个号, 0) <> 0 And c_Chkitem.科室id = r_安排.科室id Then
        
          v_Err_Msg := '该病人已经在科室[' || c_Chkitem.科室 || ']进行了预约,不能再预约！';
          Raise Err_Item;
        
          If Nvl(n_病人预约科室数, 0) > 0 And c_Chkitem.科室id <> r_安排.科室id Then
            n_已约科室 := n_已约科室 + 1;
          End If;
        End If;
      End Loop;
      If n_已约科室 >= Nvl(n_病人预约科室数, 0) And Nvl(n_病人预约科室数, 0) > 0 Then
        v_Err_Msg := '同一病人在最多同时预约[' || Nvl(n_病人预约科室数, 0) || ']个科室,不能再预约！';
        Raise Err_Item;
      End If;
    End If;
  End If;

  d_Date         := Null;
  d_时段开始时间 := Null;

  If Nvl(r_安排.限号数, 0) >= 0 Or r_安排.限号数 Is Null Then
  
    Select Nvl(Sum(Nvl(b.已挂数, 0)), 0), Nvl(Sum(Nvl(b.其中已接收, 0)), 0), Nvl(Sum(Nvl(b.已约数, 0)), 0)
    Into n_已挂数, n_其中已接收, n_已约数
    From 挂号安排 A, 病人挂号汇总 B
    Where a.科室id = b.科室id And a.项目id = b.项目id And a.号码 = 号码_In And b.日期 Between Trunc(发生时间_In) And
          Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And (a.号码 = b.号码 Or b.号码 Is Null) And Nvl(a.医生id, 0) = Nvl(b.医生id, 0) And
          Nvl(a.医生姓名, '医生') = Nvl(b.医生姓名, '医生');
  
    If n_启用分时段 = 1 Then
      If Nvl(r_安排.序号控制, 0) = 1 Then
        If Nvl(是否自助设备_In, 0) = 0 Then
          If r_安排.计划id Is Null Then
            Select Count(*), Max(开始时间)
            Into n_Count, d_时段开始时间
            From 挂号安排时段
            Where 安排id = r_安排.Id And 星期 = v_星期 And 序号 = Nvl(号序_In, 0);
          Else
            Select Count(*), Max(开始时间)
            Into n_Count, d_时段开始时间
            From 挂号计划时段
            Where 计划id = r_安排.计划id And 星期 = v_星期 And 序号 = Nvl(号序_In, 0);
          End If;
          v_Temp := '挂号';
          If 操作方式_In > 1 Then
            v_Temp := '预约挂号';
          End If;
        
          If n_Count = 0 Then
            v_Err_Msg := '号别为' || 号码_In || '的挂号安排中不存在序号为' || Nvl(号序_In, 0) || '的安排,不能再' || v_Temp || '！';
            Raise Err_Item;
          End If;
        End If;
        --过点的,不能选择挂号
        If Trunc(Sysdate) = Trunc(发生时间_In) Then
          --挂当天的号
          v_Temp := To_Char(Sysdate, 'yyyy-mm-dd') || ' ';
          If r_安排.计划id Is Null Then
            For v_时段 In (Select To_Date(v_Temp || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                To_Date(To_Char(Sysdate + Decode(Sign(开始时间 - 结束时间), 1, 1, 0), 'yyyy-mm-dd') || ' ' ||
                                         To_Char(结束时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 结束时间, 限制数量, 是否预约
                         From 挂号安排时段
                         Where 安排id = r_安排.Id And 星期 = v_星期 And 序号 = Nvl(号序_In, 0)) Loop
              If Sysdate > v_时段.结束时间 Then
                v_Err_Msg := '号别为' || 号码_In || '及号序为' || Nvl(号序_In, 0) || '的安排,已经超过时点,不能再' || v_Temp || '！';
                Raise Err_Item;
              End If;
            End Loop;
          Else
            For v_时段 In (Select To_Date(v_Temp || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                To_Date(To_Char(Sysdate + Decode(Sign(开始时间 - 结束时间), 1, 1, 0), 'yyyy-mm-dd') || ' ' ||
                                         To_Char(结束时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 结束时间, 限制数量, 是否预约
                         From 挂号计划时段
                         Where 计划id = r_安排.计划id And 星期 = v_星期 And 序号 = Nvl(号序_In, 0)) Loop
              If Sysdate > v_时段.结束时间 Then
                v_Err_Msg := '号别为' || 号码_In || '及号序为' || Nvl(号序_In, 0) || '的安排,已经超过时点,不能再' || v_Temp || '！';
                Raise Err_Item;
              End If;
            End Loop;
          End If;
        End If;
      Elsif 操作方式_In > 1 Then
        --未启用序号的,需要检查预约的情况
        n_Count := 0;
        If r_安排.计划id Is Null Then
          For v_时段 In (Select 序号, 开始时间, 结束时间, 限制数量, 是否预约
                       From 挂号安排时段
                       Where 安排id = r_安排.Id And 星期 = v_星期 And
                             (('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                             Decode(Sign(开始时间 - 结束时间 - 1 / 24 / 60 / 60), 1,
                                      '3000-01-09 ' || To_Char(开始时间, 'HH24:MI:SS'),
                                      '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS')) And
                             '3000-01-10 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS')) Or
                             ('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                             '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS') And
                             Decode(Sign(开始时间 - 结束时间 - 1 / 24 / 60 / 60), 1,
                                      '3000-01-11 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'),
                                      '3000-01-10 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'))))) Loop
            n_预约时段序号 := v_时段.序号;
            d_时段开始时间 := v_时段.开始时间;
          
            Select Count(*), Max(序号)
            Into n_Count, n_预约总数
            From 挂号序号状态
            Where 号码 = 号码_In And 日期 = 发生时间_In And 状态 Not In (4, 5);
          
            If Nvl(n_Count, 0) > Nvl(v_时段.限制数量, 0) And 锁定类型_In <> 2 Then
              v_Err_Msg := '号别为' || 号码_In || '的挂号安排中在' || To_Char(v_时段.开始时间, 'hh24:mi:ss') || '至' ||
                           To_Char(v_时段.结束时间, 'hh24:mi:ss') || '最多只能预约' || Nvl(v_时段.限制数量, 0) || '人,不能再进行预约挂号！';
              Raise Err_Item;
            End If;
            n_Count := 1;
          End Loop;
        Else
          For v_时段 In (Select 序号, 开始时间, 结束时间, 限制数量, 是否预约
                       From 挂号计划时段
                       Where 计划id = r_安排.计划id And 星期 = v_星期 And
                             (('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                             Decode(Sign(开始时间 - 结束时间 - 1 / 24 / 60 / 60), 1,
                                      '3000-01-09 ' || To_Char(开始时间, 'HH24:MI:SS'),
                                      '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS')) And
                             '3000-01-10 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS')) Or
                             ('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                             '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS') And
                             Decode(Sign(开始时间 - 结束时间 - 1 / 24 / 60 / 60), 1,
                                      '3000-01-11 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'),
                                      '3000-01-10 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'))))) Loop
            n_预约时段序号 := v_时段.序号;
            d_时段开始时间 := v_时段.开始时间;
          
            Select Count(*), Max(序号)
            Into n_Count, n_预约总数
            From 挂号序号状态
            Where 号码 = 号码_In And 日期 = 发生时间_In And 状态 Not In (4, 5);
          
            If Nvl(n_Count, 0) > Nvl(v_时段.限制数量, 0) And 锁定类型_In <> 2 Then
              v_Err_Msg := '号别为' || 号码_In || '的挂号安排中在' || To_Char(v_时段.开始时间, 'hh24:mi:ss') || '至' ||
                           To_Char(v_时段.结束时间, 'hh24:mi:ss') || '最多只能预约' || Nvl(v_时段.限制数量, 0) || '人,不能再进行预约挂号！';
              Raise Err_Item;
            End If;
            n_Count := 1;
          End Loop;
        End If;
      
        If n_Count = 0 Then
          v_Err_Msg := '号别为' || 号码_In || '的挂号安排中没有相关的安排计划(' || To_Char(发生时间_In, 'YYYY-mm-dd HH24:MI:SS') ||
                       '),不能进行预约挂号！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  End If;

  If 操作方式_In = 1 And 锁定类型_In <> 2 Then
    --挂号规则:
    --  已挂数不能大于限号数
    If n_已挂数 >= Nvl(r_安排.限号数, 0) And r_安排.限号数 Is Not Null Then
      v_Err_Msg := '该号别今天已达到限号数 ' || Nvl(r_安排.限号数, 0) || '不能再挂号！';
      Raise Err_Item;
    End If;
  End If;

  If 操作方式_In > 1 Then
    --预约的相关检查
    --规则:
    --   1.已限约不能超过限约数
    --   2.检查是否启用时段的
    If n_已约数 >= Nvl(r_安排.限约数, 0) And Nvl(r_安排.限约数, 0) <> 0 And r_安排.限约数 Is Not Null And 锁定类型_In <> 2 Then
      v_Err_Msg := '该号别已达到限约数 ' || Nvl(r_安排.限约数, 0) || '不能再预约挂号！';
      Raise Err_Item;
    End If;
  End If;
  If n_合作单位限制 > 0 And 操作方式_In <> 1 And 合作单位_In Is Not Null Then
  
    If Nvl(r_安排.序号控制, 0) = 1 And Nvl(号序_In, 0) = 0 Then
      v_Err_Msg := '当前安排使用了序号控制,请确认所需要预约的序号,不能继续。';
      Raise Err_Item;
    End If; --Nvl(r_安排.序号控制, 0) =0
  
    n_序号 := Case
              When Nvl(r_安排.序号控制, 0) = 1 Or n_启用分时段 = 1 And 操作方式_In > 1 Then
               Nvl(号序_In, 0)
              Else
               0
            End;
  
    --合作单位限数量模式
    Begin
      If Nvl(n_计划id, 0) <> 0 Then
        Select 0
        Into n_序号
        From 合作单位计划控制
        Where 合作单位 = 合作单位_In And 计划id = n_计划id And
              限制项目 = Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7',
                            '周六', Null) And 数量 <> 0 And 序号 = 0 And Rownum < 2;
      Else
        Select 0
        Into n_序号
        From 合作单位安排控制
        Where 合作单位 = 合作单位_In And 安排id = n_Tmp安排id And
              限制项目 = Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7',
                            '周六', Null) And 数量 <> 0 And 序号 = 0 And Rownum < 2;
      End If;
      n_合作单位限数量模式 := 1;
    Exception
      When Others Then
        n_合作单位限数量模式 := 0;
    End;
    --开放序号检查
    For c_合作单位 In (Select c.序号, 数量
                   From 挂号安排 A, 合作单位安排控制 C
                   Where a.号码 = 号码_In And Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                 '周四', '6', '周五', '7', '周六', Null) = c.限制项目(+) And a.Id = c.安排id And
                         c.合作单位 = 合作单位_In And c.序号 = n_序号 And Not Exists
                    (Select 1
                          From 挂号安排计划 D
                          Where d.安排id = a.Id And d.审核时间 Is Not Null And
                                发生时间_In Between Nvl(d.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                                Nvl(d.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')))
                   Union All
                   Select c.序号, 数量
                   From 挂号安排计划 A, 挂号安排 D, 合作单位计划控制 C,
                        (Select Max(a.生效时间) As 生效, 安排id
                          From 挂号安排计划 A, 挂号安排 B
                          Where a.安排id = b.Id And a.审核时间 Is Not Null And
                                发生时间_In Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                                Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) And b.号码 = 号码_In
                          Group By 安排id) E
                   Where a.安排id = d.Id And a.审核时间 Is Not Null And d.号码 = 号码_In And a.安排id = e.安排id And
                         Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) =
                         Nvl(e.生效, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                         Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                '7', '周六', Null) = c.限制项目(+) And a.Id = c.计划id And c.合作单位 = 合作单位_In And c.序号 = n_序号 And
                         发生时间_In Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                         Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd'))) Loop
    
      If Nvl(r_安排.序号控制, 0) = 1 And c_合作单位.序号 = n_序号 And n_合作单位限数量模式 = 0 Then
        n_是否开放 := 1;
        Exit;
      Elsif (Nvl(r_安排.序号控制, 0) = 0 And c_合作单位.序号 = n_序号) Or n_合作单位限数量模式 = 1 Then
        Begin
          Select Nvl(已约数, 0)
          Into n_预约数量
          From 合作单位挂号汇总
          Where 合作单位 = 合作单位_In And 日期 = Trunc(发生时间_In) And 号码 = 号码_In;
        Exception
          When Others Then
            n_预约数量 := 0;
        End;
        If c_合作单位.数量 <= n_预约数量 And Nvl(c_合作单位.数量, 0) > 0 And 锁定类型_In <> 2 Then
          v_Err_Msg := '该号别已达到限约数 ' || Nvl(c_合作单位.数量, 0) || '不能再预约挂号！';
          Raise Err_Item;
        End If;
        n_是否开放 := 1;
        Exit;
      End If;
    
    End Loop;
  
    If Nvl(n_是否开放, 0) = 0 Then
      v_Err_Msg := '当前序号(' || Nvl(号序_In, 0) || '未开放,不能继续。';
      Raise Err_Item;
    End If;
  End If;

  --检查限号数和限约数
  n_行号         := 1;
  n_原项目id     := 0;
  n_原收入项目id := 0;
  n_实收金额合计 := 0;
  If 锁定类型_In <> 1 Then
    If 操作方式_In <> 2 Then
      If Nvl(结帐id_In, 0) = 0 Then
        --这里应该程序传入
        Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
      Else
        n_结帐id := 结帐id_In;
      End If;
    Else
      n_结帐id := Null;
    End If;
  End If;

  If Nvl(购买病历_In, 0) = 1 Then
    Begin
      Select 收费细目id Into n_病历费id From 收费特定项目 Where 特定项目 = '病历费';
      v_收费项目ids := r_安排.项目id || ',' || n_病历费id;
    Exception
      When Others Then
        v_Err_Msg := '不能确定病历费,挂号失败!';
        Raise Err_Item;
    End;
  Else
    v_收费项目ids := r_安排.项目id;
  End If;

  For c_Item In (Select 1 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次, c.Id As 收入项目id,
                        c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, Null As 从属父号
                 From 收费项目目录 A, 收费价目 B, 收入项目 C
                 Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = r_安排.项目id And Sysdate Between b.执行日期 And
                       Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                 Union All
                 Select 2 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次, c.Id As 收入项目id,
                        c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, Null As 从属父号
                 From 收费项目目录 A, 收费价目 B, 收入项目 C
                 Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = n_病历费id And Sysdate Between b.执行日期 And
                       Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                 Union All
                 Select 3 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, d.从项数次 As 数次,
                        c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, 1 As 从属父号
                 From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费从属项目 D
                 Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = d.从项id And
                       d.主项id In (Select Column_Value From Table(f_Str2list(v_收费项目ids))) And Sysdate Between b.执行日期 And
                       Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                 Order By 性质, 项目编码, 收入编码) Loop
    n_价格父号 := Null;
    If n_原项目id = c_Item.项目id Then
      If n_原收入项目id <> c_Item.收入项目id Then
        n_价格父号 := n_行号;
      End If;
      n_原收入项目id := c_Item.收入项目id;
    End If;
    n_原项目id := c_Item.项目id;
    n_应收金额 := Round(c_Item.数次 * c_Item.单价, 5);
    n_实收金额 := n_应收金额;
    If Nvl(c_Item.屏蔽费别, 0) <> 1 And n_屏蔽费别 = 0 Then
      --打折:
      v_Temp     := Zl_Actualmoney(r_Pati.费别, c_Item.项目id, c_Item.收入项目id, n_应收金额);
      v_Temp     := Substr(v_Temp, Instr(v_Temp, ':') + 1);
      n_实收金额 := Zl_To_Number(v_Temp);
    End If;
    n_实收金额合计 := Nvl(n_实收金额合计, 0) + n_实收金额;
  
    --锁定单据不产生费用
    If 锁定类型_In <> 1 Then
      --产生病人挂号费用(可能单独是或包括病历费用)
      Select 病人费用记录_Id.Nextval Into n_费用id From Dual;
      --:操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
      Insert Into 门诊费用记录
        (ID, 记录性质, 记录状态, 序号, 价格父号, 从属父号, NO, 实际票号, 门诊标志, 加班标志, 附加标志, 发药窗口, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 病人科室id,
         收费类别, 计算单位, 收费细目id, 收入项目id, 收据费目, 付数, 数次, 标准单价, 应收金额, 实收金额, 结帐金额, 结帐id, 记帐费用, 开单部门id, 开单人, 划价人, 执行部门id, 执行人,
         操作员编号, 操作员姓名, 发生时间, 登记时间, 保险大类id, 保险项目否, 保险编码, 统筹金额, 摘要, 结论, 缴款组id)
      Values
        (n_费用id, 4, Decode(操作方式_In, 2, 0, 1), n_行号, n_价格父号, c_Item.从属父号, 单据号_In, 票据号_In, 1, Null, Null,
         Decode(操作方式_In, 2, To_Char(号序_In), v_诊室), r_Pati.病人id, r_Pati.门诊号, r_Pati.付款方式, r_Pati.姓名, r_Pati.性别, r_Pati.年龄,
         r_Pati.费别, r_安排.科室id, c_Item.类别, 号码_In, c_Item.项目id, c_Item.收入项目id, c_Item.收据费目, 1, c_Item.数次, c_Item.单价,
         n_应收金额, n_实收金额, Decode(操作方式_In, 2, Null, n_实收金额), n_结帐id, 0, n_开单部门id, v_操作员姓名,
         Decode(操作方式_In, 2, v_操作员姓名, Null), r_安排.科室id, r_安排.医生姓名, v_操作员编号, v_操作员姓名, 发生时间_In, d_登记时间, Null, 0, Null, Null,
         摘要_In, 预约方式_In, Decode(操作方式_In, 2, Null, n_组id));
    End If;
    n_行号 := n_行号 + 1;
  
  End Loop;

  If Round(Nvl(挂号金额合计_In, 0), 5) <> Round(Nvl(n_实收金额合计, 0), 5) Then
    v_Err_Msg := '本次挂号金额不正确,可能是因为医院调整了价格,请重新获取挂号收费项目的价格,不能继续。';
    Raise Err_Item;
  End If;

  If n_启用分时段 = 1 Then
    d_Date := To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(d_时段开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss');
  Else
    d_Date := Trunc(发生时间_In);
  End If;

  --更新挂号序号状态
  If 锁定类型_In <> 2 Then
    n_号序 := 号序_In;
  End If;
  Begin
    Select 1
    Into n_Count
    From 挂号序号状态
    Where Trunc(日期) = Trunc(发生时间_In) And 号码 = 号码_In And 序号 = n_号序 And 状态 <> 5;
  Exception
    When Others Then
      n_Count := 0;
  End;
  If n_Count = 1 Then
    If n_启用分时段 = 0 And Nvl(r_安排.序号控制, 0) = 1 Then
      n_号序 := Null;
    End If;
    If n_启用分时段 = 1 And Nvl(r_安排.序号控制, 0) = 1 Then
      v_Err_Msg := '当前序号已被使用，请重新选择一个序号！';
      Raise Err_Item;
    End If;
  End If;
  n_Count := 0;
  If n_启用分时段 = 0 And Nvl(r_安排.序号控制, 0) = 1 And n_号序 Is Null And 锁定类型_In <> 2 Then
    If 退号重用_In = 1 Then
      Select Nvl(Max(序号), 0) + 1
      Into n_号序
      From 挂号序号状态
      Where 日期 = Trunc(发生时间_In) And 号码 = r_安排.号码 And 状态 Not In (4, 5);
    Else
      Select Nvl(Max(序号), 0) + 1
      Into n_号序
      From 挂号序号状态
      Where 日期 = Trunc(发生时间_In) And 号码 = r_安排.号码 And 状态 <> 5;
    End If;
  End If;
  If n_启用分时段 = 1 And 锁定类型_In <> 2 Then
  
    If 操作方式_In > 1 And Nvl(r_安排.序号控制, 0) = 0 Then
      --规则:预约时段序号||预约数
      If Nvl(n_预约总数, 0) = 0 Then
        v_Temp := Nvl(r_安排.限约数, 0);
        v_Temp := LTrim(RTrim(v_Temp));
        v_Temp := LPad(Nvl(n_预约总数, 0) + 1, Length(v_Temp), '0');
        v_Temp := n_预约时段序号 || v_Temp;
        n_号序 := To_Number(v_Temp);
      Else
        n_号序 := n_预约总数 + 1;
      End If;
    End If;
  End If;

  If Nvl(r_安排.序号控制, 0) = 1 Or (操作方式_In > 1 And n_启用分时段 = 1) Or 加入序号状态_In = 1 Then
    --锁定序号的处理
    Begin
      Select 操作员姓名, 机器名
      Into v_序号操作员, v_序号机器名
      From 挂号序号状态
      Where 状态 = 5 And 号码 = 号码_In And Trunc(日期) = Trunc(d_Date) And 序号 = n_号序;
      n_序号锁定 := 1;
    Exception
      When Others Then
        v_序号操作员 := Null;
        v_序号机器名 := Null;
        n_序号锁定   := 0;
    End;
    If n_序号锁定 = 0 Then
      Update 挂号序号状态
      Set 状态 = Decode(操作方式_In, 2, 2, 1), 预约 = Decode(操作方式_In, 1, 0, 1), 登记时间 = Sysdate
      Where 号码 = 号码_In And 日期 = d_Date And 序号 = n_号序 And 操作员姓名 = v_操作员姓名;
      If Sql%RowCount = 0 Then
        Begin
          Insert Into 挂号序号状态
            (号码, 日期, 序号, 状态, 操作员姓名, 预约, 登记时间)
          Values
            (号码_In, d_Date, n_号序, Decode(操作方式_In, 2, 2, 1), v_操作员姓名, Decode(操作方式_In, 1, 0, 1), Sysdate);
        
          If n_合作单位限制 > 0 And 操作方式_In > 1 And Nvl(n_是否开放, 0) = 1 Then
            Update 合作单位挂号汇总
            Set 已约数 = 已约数 + Decode(操作方式_In, 2, 1, 0), 已接数 = 已接数 + Decode(操作方式_In, 3, 1, 0)
            Where 号码 = 号码_In And 日期 = d_Date And 序号 = n_号序 And 合作单位 = 合作单位_In;
            If Sql%NotFound Then
              Insert Into 合作单位挂号汇总
                (号码, 日期, 序号, 合作单位, 已约数, 已接数)
              Values
                (号码_In, d_Date, n_号序, 合作单位_In, Decode(操作方式_In, 1, 0, 1), Decode(操作方式_In, 3, 1, 0));
            End If;
          End If;
        Exception
          When Others Then
            v_Err_Msg := '序号' || n_号序 || '已被使用,请重新选择一个序号.';
            Raise Err_Item;
        End;
      End If;
    Else
      If v_操作员姓名 <> v_序号操作员 Or v_机器名 <> v_序号机器名 Then
        v_Err_Msg := '序号' || n_号序 || '已被自助机' || v_机器名 || '锁定,请重新选择一个序号.';
        Raise Err_Item;
      Else
        Update 挂号序号状态
        Set 状态 = Decode(操作方式_In, 2, 2, 1), 预约 = Decode(操作方式_In, 1, 0, 1), 登记时间 = Sysdate
        Where 号码 = 号码_In And Trunc(日期) = Trunc(d_Date) And 序号 = n_号序 And 状态 = 5 And 操作员姓名 = v_操作员姓名 And 机器名 = v_机器名;
      End If;
    End If;
  End If;

  --锁定单据不产生任何 费用
  If 操作方式_In <> 2 And 锁定类型_In <> 1 Then
    --挂号,预约挂号已经扣款部分
    n_预交id := 预交id_In;
    If Nvl(n_预交id, 0) = 0 Then
      Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
    End If;
    n_结算合计 := 0;
    If 保险结算_In Is Not Null Then
      --各个保险结算
      v_结算内容 := 保险结算_In || '||';
      n_结算合计 := 0;
      While v_结算内容 Is Not Null Loop
        v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
        v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
        n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
        If Nvl(n_结算金额, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算性质)
          Values
            (n_预交id, 4, 单据号_In, 1, Decode(病人id_In, 0, Null, 病人id_In), '保险结算', v_结算方式, d_登记时间, v_操作员编号, v_操作员姓名, n_结算金额,
             n_结帐id, n_组id, n_结帐id, 4);
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
        End If;
        n_结算合计 := Nvl(n_结算合计, 0) + Nvl(n_结算金额, 0);
        v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
      End Loop;
    End If;
  
    If Nvl(冲预交_In, 0) <> 0 Then
      --处理总预交
      n_结算合计 := n_结算合计 + Nvl(冲预交_In, 0);
      n_预交金额 := 冲预交_In;
      For r_Deposit In c_Deposit(病人id_In, v_冲预交病人ids) Loop
        n_结算金额 := Case
                    When r_Deposit.金额 - n_预交金额 < 0 Then
                     r_Deposit.金额
                    Else
                     n_预交金额
                  End;
        If r_Deposit.Id <> 0 Then
          --第一次冲预交(填上结帐ID,金额为0)
          Update 病人预交记录 Set 冲预交 = 0, 结帐id = n_结帐id, 结算性质 = 4 Where ID = r_Deposit.Id;
        End If;
        --冲上次剩余额
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 预交类别, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号,
           冲预交, 结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 预交类别, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 d_登记时间, v_操作员姓名, v_操作员编号, n_结算金额, n_结帐id, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, n_结帐id, 4
          From 病人预交记录
          Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
      
        --更新病人预交余额
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) - n_结算金额
        Where 病人id = r_Deposit.病人id And 性质 = 1 And 类型 = Nvl(r_Deposit.预交类别, 2)
        Returning 预交余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 病人余额 (病人id, 预交余额, 性质, 类型) Values (r_Deposit.病人id, -1 * n_结算金额, 1, 1);
          n_返回值 := -1 * n_结算金额;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 病人余额
          Where 病人id = r_Deposit.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
        End If;
      
        --检查是否已经处理完
        If r_Deposit.金额 <= n_结算金额 Then
          n_预交金额 := n_预交金额 - r_Deposit.金额;
        Else
          n_预交金额 := 0;
        End If;
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
      If n_预交金额 > 0 Then
        v_Err_Msg := '预交余额不够支付本次支付金额,不能继续操作！';
        Raise Err_Item;
      End If;
    End If;
    --剩余款项,用指定结算方支付
    n_结算金额 := Nvl(n_实收金额合计, 0) - Nvl(n_结算合计, 0);
    If Nvl(n_结算金额, 0) < 0 Then
      v_Err_Msg := '挂号的相关结算金额超出了当前实结金额,不能继续操作！';
      Raise Err_Item;
    End If;
    If Nvl(n_结算金额, 0) <> 0 Or (Nvl(n_结算金额, 0) = 0 And Nvl(冲预交_In, 0) = 0) Then
      If 结算方式_In Is Null Then
        v_Err_Msg := '未传入指定的结算方式,不能继续操作！';
        Raise Err_Item;
      End If;
    
      If Nvl(预交id_In, 0) <> 0 Then
        --传入的预交ID_In主要是为了解决三方交易,如果医保结算站用了该ID,需要用新的ID进行更新,三方交易用转入的ID
        Update 病人预交记录 Set ID = n_预交id Where ID = Nvl(预交id_In, 0);
        n_预交id := Nvl(预交id_In, 0);
      End If;
    
      Insert Into 病人预交记录
        (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 交易流水号, 交易说明, 结算序号, 合作单位, 卡类别id, 卡号,
         结算性质)
      Values
        (n_预交id, 4, 1, 单据号_In, r_Pati.病人id, 结算方式_In, Nvl(n_结算金额, 0), d_登记时间, v_操作员编号, v_操作员姓名, n_结帐id, 合作单位_In || '缴款',
         n_组id, 交易流水号_In, 交易说明_In, n_结帐id, 合作单位_In, 卡类别id_In, 支付卡号_In, 4);
    End If;
  
    --更新人员缴款数据
  
    For v_缴款 In (Select 结算方式, Sum(Nvl(a.冲预交, 0)) As 冲预交
                 From 病人预交记录 A
                 Where a.结帐id = n_结帐id And Mod(a.记录性质, 10) <> 1 And Nvl(病人id, 0) = Nvl(病人id_In, 0)
                 Group By 结算方式) Loop
    
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + Nvl(v_缴款.冲预交, 0)
      Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = v_缴款.结算方式
      Returning 余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (v_操作员姓名, v_缴款.结算方式, 1, Nvl(v_缴款.冲预交, 0));
        n_返回值 := Nvl(v_缴款.冲预交, 0);
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = v_操作员姓名 And 结算方式 = 结算方式_In And 性质 = 1 And Nvl(余额, 0) = 0;
      End If;
    
    End Loop;
  
  End If;

  --处理挂号记录
  If 锁定类型_In = 2 Then
    Begin
      Select ID Into n_挂号id From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
    Exception
      When Others Then
        Null;
    End;
  Else
    Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
  End If;

  Update 病人挂号记录
  Set 记录性质 = Decode(操作方式_In, 2, 2, 1), 记录状态 = Decode(锁定类型_In, 1, 0, 1), 门诊号 = r_Pati.门诊号, 操作员姓名 = v_操作员姓名,
      操作员编号 = v_操作员编号, 预约 = Decode(操作方式_In, 1, 0, 1), 接收人 = Decode(锁定类型_In, 1, Null, Decode(操作方式_In, 2, Null, v_操作员姓名)),
      接收时间 = Case 锁定类型_In
                When 1 Then
                 Null
                Else
                 Case 操作方式_In
                   When 2 Then
                    Null
                   Else
                    d_登记时间
                 End
              End, 交易流水号 = Nvl(交易流水号_In, 交易流水号), 交易说明 = Nvl(交易说明_In, 交易说明), 合作单位 = Nvl(合作单位_In, 合作单位),
      预约操作员 = Decode(操作方式_In, 1, Nvl(预约操作员, Null), Nvl(预约操作员, v_操作员姓名)),
      预约操作员编号 = Decode(操作方式_In, 1, Nvl(预约操作员编号, Null), Nvl(预约操作员编号, v_操作员编号))
  Where ID = n_挂号id;
  If Sql%NotFound Then
    Begin
      Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = r_Pati.付款方式 And Rownum < 2;
    Exception
      When Others Then
        v_付款方式 := Null;
    End;
    Insert Into 病人挂号记录
      (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 预约时间, 操作员编号,
       操作员姓名, 复诊, 号序, 预约, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 医疗付款方式, 预约操作员, 预约操作员编号)
    Values
      (n_挂号id, 单据号_In, Decode(操作方式_In, 2, 2, 1), Decode(锁定类型_In, 1, 0, 1), r_Pati.病人id, r_Pati.门诊号, r_Pati.姓名,
       r_Pati.性别, r_Pati.年龄, 号码_In, 0, v_诊室, Null, r_安排.科室id, r_安排.医生姓名, 0, Null, d_登记时间, 发生时间_In,
       Case When(Nvl(操作方式_In, 0)) = 1 Then Null Else 发生时间_In End, v_操作员编号, v_操作员姓名, 0, n_号序, Decode(操作方式_In, 1, 0, 1),
       Decode(操作方式_In, 2, Null, v_操作员姓名), Decode(操作方式_In, 2, To_Date(Null), d_登记时间), 交易流水号_In, 交易说明_In, 合作单位_In, v_付款方式,
       Decode(操作方式_In, 1, Null, v_操作员姓名), Decode(操作方式_In, 1, Null, v_操作员编号));
  End If;
  --锁定单据不能产生队列
  If 锁定类型_In <> 1 Then
    n_预约生成队列 := 0;
    If 操作方式_In > 1 Then
      n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
    End If;
    --挂号和收费的预约都直接进入队列(收费预约缺少接收过程,所以直接和挂号一样直接进入队列)
    If 操作方式_In <> 2 Or n_预约生成队列 = 1 Then
      If Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113)) <> 0 Then
        --排队叫号模式:-0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站      
        If Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113)) = 0 Or n_预约生成队列 = 1 Then
          --产生队列
          --.按”执行部门” 的方式生成队列
          v_队列名称 := r_安排.科室id;
          v_排队号码 := Zlgetnextqueue(r_安排.科室id, n_挂号id, 号码_In || '|' || 号序_In);
          --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)
          v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
          --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)  
          d_排队时间 := Zl_Get_Queuedate(n_挂号id, 号码_In, 号序_In, d_Date);
          --  队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,v_排队标记,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In, 排队时间_In
          Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, r_安排.科室id, v_排队号码, Null, r_Pati.姓名, r_Pati.病人id, v_诊室, r_安排.医生姓名,
                           d_排队时间, 预约方式_In, n_启用分时段, v_排队序号);
        End If;
      End If;
    End If;
  
    If Nvl(操作方式_In, 0) = 1 Then
      --处理票据使用情况
      If 票据号_In Is Not Null Then
        Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
        --发出票据
        Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 4, 单据号_In);
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
        Values
          (票据使用明细_Id.Nextval, Decode(收费票据_In, 1, 1, 4), 票据号_In, 1, 1, 领用id_In, n_打印id, d_登记时间, v_操作员姓名);
        --状态改动
        Update 票据领用记录
        Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
        Where ID = Nvl(领用id_In, 0);
      End If;
      --病人本次就诊(以发生时间为准)
      If Nvl(r_Pati.病人id, 0) <> 0 Then
        Update 病人信息 Set 就诊时间 = 发生时间_In, 就诊状态 = 1, 就诊诊室 = v_诊室 Where 病人id = r_Pati.病人id;
      End If;
    End If;
  End If;
  --病人挂号汇总
  --解锁单据时不用再对汇总单据进行统计了 在锁定单据时已经进行了汇总
  If 锁定类型_In <> 2 Then
    --操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
    --是否为预约接收:0-非预约挂号; 1-预约挂号,2-预约接收;3-收费预约
    n_预约 := Case
              When Nvl(操作方式_In, 0) = 1 Then
               0
              When Nvl(操作方式_In, 0) = 2 Then
               1
              When Nvl(操作方式_In, 0) = 3 Then
               3
              Else
               0
            End;
    Zl_病人挂号汇总_Update(r_安排.医生姓名, r_安排.医生id, r_安排.项目id, r_安排.科室id, 发生时间_In, n_预约, 号码_In);
  End If;
  --消息推送
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 1, n_挂号id;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]+' || v_Err_Msg || '+[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_三方机构挂号_Insert;
/

--91633:余伟节,2015-12-25,临床路径取消特殊项目【未生成任何项目】
Create Or Replace Procedure Zl_病人路径生成_Insert
(
  序号_In           Number, --医嘱界面产生路径项目时，序号为0
  病人id_In         病人临床路径.病人id%Type,
  主页id_In         病人临床路径.主页id%Type,
  婴儿_In           电子病历记录.婴儿%Type,
  科室id_In         病人临床路径.科室id%Type,
  路径记录id_In     病人路径执行.路径记录id%Type,
  阶段id_In         病人路径执行.阶段id%Type,
  日期_In           病人路径执行.日期%Type,
  天数_In           病人路径执行.天数%Type,
  分类_In           病人路径执行.分类%Type,
  项目id_In         病人路径执行.项目id%Type,
  医嘱ids_In        Varchar2,
  病历文件ids_In    Varchar2,
  病人病历ids_In    Varchar2,
  登记人_In         病人路径执行.登记人%Type,
  登记时间_In       病人路径执行.登记时间%Type,
  项目内容_In       病人路径执行.项目内容%Type := Null,
  执行者_In         病人路径执行.执行者%Type := Null,
  项目结果_In       病人路径执行.项目结果%Type := Null,
  图标id_In         病人路径执行.图标id%Type := Null,
  添加原因_In       病人路径执行.添加原因%Type := Null,
  变异原因_In       病人路径执行.变异原因%Type := Null,
  自动执行_In       Number := 0,
  电子病历id_In     电子病历记录.Id%Type := Null,
  合并路径阶段s_In  Varchar2 := Null, --用于修改合并路径的当前阶段ID，格式：合并路径记录ID:阶段ID,合并路径记录ID:阶段ID。。。。
  合并路径记录id_In 病人路径执行.合并路径记录id%Type := Null,
  合并路径阶段id_In 病人路径执行.合并路径阶段id%Type := Null,
  插入位置id_In     病人路径执行.Id%Type := 0,
  生成者_In         病人路径执行.生成者 %Type := 1,
  任务ids_In        Varchar2 := Null,
  生成时间性质_In   病人路径执行.生成时间性质%Type := Null --1-补录,2-暂存,Null-正常情况
) Is
  v_当前阶段id 病人临床路径.当前阶段id%Type;
  v_路径执行id 病人路径执行.Id%Type;
  v_病历id     电子病历记录.Id%Type;
  t_Advice     t_Numlist;
  t_File       t_Numlist;
  t_Doc        t_Numlist;

  v_Id             电子病历内容.Id%Type;
  v_父id           电子病历内容.父id%Type;
  v_当前父id       电子病历内容.父id%Type;
  v_原对象序号     电子病历内容.父id%Type;
  v_内容文本       电子病历内容.内容文本%Type;
  v_执行环节       Varchar2(20);
  n_当前天数       病人临床路径.当前天数%Type;
  n_合并路径记录id 病人路径执行.合并路径记录id%Type;
  n_合并路径阶段id 病人路径执行.合并路径阶段id%Type;
  n_天数           病人临床路径.当前天数%Type;
  v_合并路径阶段s  Varchar2(255);

  v_项目序号 病人路径执行.项目序号%Type;
  n_Count    Number;
  n_Minnum   Number;
  v_Error    Varchar2(255);
  Err_Custom Exception;

  --项目序号处理
  Procedure p_Sort_项目序号
  (
    项目序号_In In 病人路径执行.项目序号%Type,
    执行id_In   In 病人路径执行.Id%Type
  ) Is
    n_Num Number;
  Begin
    n_Num := 项目序号_In;
    For r_Outpathitem In (Select a.Id, Nvl(a.项目序号, b.项目序号) As 项目序号
                          From 病人路径执行 A, 临床路径项目 B
                          Where a.路径记录id = 路径记录id_In And a.阶段id = 阶段id_In And a.天数 = 天数_In And a.分类 = 分类_In And
                                a.项目id = b.Id(+) And Nvl(a.项目序号, b.项目序号) >= 项目序号_In
                          Order By Nvl(a.项目序号, b.项目序号)) Loop
      n_Num := n_Num + 1;
      --1-从插入位置处之后的所有路径外项目序号加 1
      Update 病人路径执行 A Set a.项目序号 = n_Num Where a.Id = r_Outpathitem.Id;
    End Loop;
    Update 病人路径执行 A Set a.项目序号 = 项目序号_In Where a.Id = 执行id_In;
  Exception
    When Others Then
      Null;
  End p_Sort_项目序号;
Begin
  If 序号_In = 1 And (项目内容_In Is Null Or 项目内容_In = '未生成任何项目' Or 项目内容_In = '路径外项目') Then
    --合并路径
    If 合并路径阶段s_In Is Not Null Then
      Select Nvl(当前天数, 1) Into n_当前天数 From 病人临床路径 Where ID = 路径记录id_In;
      --求出增量(首要路径提前合并路径就提前，首要路径延后，合并路径就延后)
      n_天数          := 天数_In - n_当前天数;
      v_合并路径阶段s := 合并路径阶段s_In || ',';
      While v_合并路径阶段s Is Not Null Loop
        n_合并路径记录id := To_Number(Substr(v_合并路径阶段s, 1, Instr(v_合并路径阶段s, ':') - 1));
        n_合并路径阶段id := To_Number(Substr(v_合并路径阶段s, Instr(v_合并路径阶段s, ':') + 1,
                                       Instr(v_合并路径阶段s, ',') - Instr(v_合并路径阶段s, ':') - 1));
        Select Nvl(当前阶段id, 0) Into v_当前阶段id From 病人合并路径 Where ID = n_合并路径记录id;
        If v_当前阶段id <> n_合并路径阶段id Then
          Update 病人合并路径 Set 前一阶段id = 当前阶段id, 当前阶段id = n_合并路径阶段id Where ID = n_合并路径记录id;
        End If;
        Update 病人合并路径 Set 当前天数 = Nvl(当前天数, 1) + n_天数 Where ID = n_合并路径记录id;
      
        v_合并路径阶段s := Substr(v_合并路径阶段s, Instr(v_合并路径阶段s, ',') + 1);
      End Loop;
    End If;
    --首要路径
    If 生成者_In = 1 Then
      Select Nvl(当前阶段id, 0) Into v_当前阶段id From 病人临床路径 Where ID = 路径记录id_In;
      If v_当前阶段id <> 阶段id_In Then
        Update 病人临床路径 Set 前一阶段id = 当前阶段id, 当前阶段id = 阶段id_In Where ID = 路径记录id_In;
      End If;
      Update 病人临床路径 Set 当前天数 = 天数_In Where ID = 路径记录id_In;
    End If;
  End If;

  --添加的路径外项目:即使有可选的项目可能还未生成,序号占用见后面补充项目调序处理
  If 项目内容_In Is Not Null Then
    Select Max(Nvl(a.项目序号, b.项目序号)) + 1
    Into v_项目序号
    From 病人路径执行 A, 临床路径项目 B
    Where a.路径记录id = 路径记录id_In And a.阶段id = 阶段id_In And a.天数 = 天数_In And a.分类 = 分类_In And a.项目id = b.Id(+);
  End If;

  v_路径执行id := 0;
  If 序号_In = 0 And 项目内容_In Is Null Then
    --加max是为了容错以前的数据，实际上同一项目在当天只有一条执行记录
    Select Nvl(Max(ID), 0)
    Into v_路径执行id
    From 病人路径执行
    Where 路径记录id = 路径记录id_In And 阶段id = 阶段id_In And 天数 = 天数_In And 项目id = 项目id_In;
  End If;

  --医嘱界面添加的非路径外项目
  If v_路径执行id = 0 Then
    Select Count(1)
    Into n_Count
    From 病人路径执行
    Where 路径记录id = 路径记录id_In And 阶段id = 阶段id_In And 日期 = 日期_In;
    If n_Count = 0 Then
      --首次生成路径项目，转存前一天的暂存项目
      Update 病人路径执行
      Set 阶段id = 阶段id_In, 日期 = 日期_In, 天数 = 天数_In, 项目序号 = Null
      Where ID In (Select ID From 病人路径执行 Where 路径记录id = 路径记录id_In And 生成时间性质 = 2);
      --修改暂存标识
      Update 病人路径执行
      Set 生成时间性质 = Null
      Where ID In (Select a.Id
                   From 病人路径执行 A, 病人路径医嘱 B, 病人医嘱记录 C
                   Where a.Id = b.路径执行id And b.病人医嘱id = c.Id And a.路径记录id = 路径记录id_In And a.生成时间性质 = 2 And
                         a.日期 = Trunc(c.开始执行时间));
    End If;
    Select 病人路径执行_Id.Nextval Into v_路径执行id From Dual;
    Insert Into 病人路径执行
      (ID, 路径记录id, 阶段id, 日期, 天数, 分类, 项目id, 登记人, 登记时间, 项目序号, 项目内容, 执行者, 生成者, 项目结果, 图标id, 添加原因, 变异原因, 合并路径记录id, 合并路径阶段id,
       生成时间性质)
    Values
      (v_路径执行id, 路径记录id_In, 阶段id_In, 日期_In, 天数_In, 分类_In, 项目id_In, 登记人_In, 登记时间_In, v_项目序号, 项目内容_In, 执行者_In, 生成者_In,
       项目结果_In, 图标id_In, 添加原因_In, 变异原因_In, 合并路径记录id_In, 合并路径阶段id_In, 生成时间性质_In);
  
    --路径外项目序号插入 排序
    If 插入位置id_In <> 0 Then
      --获取要插入的序号
      Select Nvl(a.项目序号, b.项目序号)
      Into v_项目序号
      From 病人路径执行 A, 临床路径项目 B
      Where a.Id = 插入位置id_In And a.项目id = b.Id(+);
      --序号调整
      p_Sort_项目序号(v_项目序号, v_路径执行id);
    End If;
    --路径项目补充生成时,序号重整:假如临床路径项目存在A1,A2,A3这3个项目,首次生成A1,A2后,再生成路径外项目B1,B2,同时将B1,B2插入到A1的位置
    --         那么此时病人路径执行中的序号变为:B1(1),B2(2),A1(3),A2(4),如果再补充生成A3时,路径显示顺序变为：B1(1),B2(2),A1(3),A3(3),A2(4)
    --         这样就会出现路径项目中补充生成的A3不能按照临床路径项目的顺序A1,A2,A3 正确排序。
  
    --当前阶段，当前天数，当前分类下，存在路径内项目且路径内的项目序号被重新调整过。（未添加路径外项目时，路径内项目的序号为空）
    Select Nvl(Count(ID), 0)
    Into n_Count
    From 病人路径执行
    Where 路径记录id = 路径记录id_In And 阶段id = 阶段id_In And 天数 = 天数_In And 分类 = 分类_In And 项目id Is Not Null And 项目序号 Is Not Null;
    --补充生成的路径项目序号重整
    If n_Count > 0 And 项目id_In Is Not Null Then
      --查找补充生成的路径项目,应该插入的位置
      Select Min(b.项目序号)
      Into n_Minnum
      From 病人路径执行 A, 临床路径项目 B
      Where a.路径记录id = 路径记录id_In And a.阶段id = 阶段id_In And a.天数 = 天数_In And a.分类 = 分类_In And a.项目id = b.Id;
    
      Select 项目序号 Into v_项目序号 From 临床路径项目 Where ID = 项目id_In;
      --确定该路径项目序号插入的位置：
      If v_项目序号 = n_Minnum Then
        --v_项目序号 = n_Minnum：病人路径执行记录已在此排序前插入到数据库，插入的这天数据就是最小的这条数据
        Select 项目序号
        Into v_项目序号
        From (Select Nvl(a.项目序号, b.项目序号) As 项目序号
               From 病人路径执行 A, 临床路径项目 B
               Where a.路径记录id = 路径记录id_In And a.阶段id = 阶段id_In And a.天数 = 天数_In And a.分类 = 分类_In And a.项目id = b.Id And
                     b.项目序号 > n_Minnum
               Order By b.项目序号)
        Where Rownum = 1;
      Else
        Select 项目序号
        Into v_项目序号
        From (Select Nvl(a.项目序号, b.项目序号) As 项目序号
               
               From 病人路径执行 A, 临床路径项目 B
               Where a.路径记录id = 路径记录id_In And a.阶段id = 阶段id_In And a.天数 = 天数_In And a.分类 = 分类_In And a.项目id = b.Id And
                     b.项目序号 < v_项目序号
               Order By b.项目序号 Desc)
        Where Rownum = 1;
        v_项目序号 := v_项目序号 + 1;
      End If;
      p_Sort_项目序号(v_项目序号, v_路径执行id);
    End If;
  
    --如果是自动执行模式（连续提前多个阶段时调用）;补录路径外项目
    If 自动执行_In = 1 Then
      Select zl_GetSysParameter('是否启用路径执行环节', 1256) Into v_执行环节 From Dual;
      If v_执行环节 = '1' Then
        Select zl_GetSysParameter('路径执行环节启用场合', 1256) Into v_执行环节 From Dual;
      
        Select Nvl(Nvl(a.执行者, b.执行者), 0)
        Into n_Count
        From 病人路径执行 A, 临床路径项目 B
        Where a.项目id = b.Id(+) And a.Id = v_路径执行id;
        --当前执行者符合启用场合自动执行,当执行者取不到值时,统一处理。
        If n_Count = 0 Or Substr(v_执行环节, n_Count, 1) = '1' Then
          Update 病人路径执行
          Set 执行人 = 登记人_In, 执行时间 = 登记时间_In, 执行结果 = '已经执行', 执行说明 = '自动执行。'
          Where ID = v_路径执行id;
        End If;
      End If;
    End If;
  End If;
  --删除特殊项目：未生成任何项目（如果当前阶段，当前日期存在其他项目，需删除“未生成任何项目”）
  Select Count(ID)
  Into n_Count
  From 病人路径执行 T
  Where t.路径记录id = 路径记录id_In And t.阶段id = 阶段id_In And t.天数 = 天数_In And NVL(t.项目内容,'路径内项目') = '未生成任何项目';

  If n_Count > 0 Then
    Select Count(ID)
    Into n_Count
    From 病人路径执行 T
    Where t.路径记录id = 路径记录id_In And t.阶段id = 阶段id_In And t.天数 = 天数_In And NVL(t.项目内容,'路径内项目') <> '未生成任何项目';
    If n_Count > 0 Then
      Delete From 病人路径执行 T
      Where t.路径记录id = 路径记录id_In And t.阶段id = 阶段id_In And t.天数 = 天数_In And NVL(t.项目内容,'路径内项目') = '未生成任何项目';
    End If;
  End If;

  If 医嘱ids_In Is Not Null Then
    Select Column_Value Bulk Collect Into t_Advice From Table(f_Num2list(医嘱ids_In));
    Forall I In 1 .. t_Advice.Count
      Insert Into 病人路径医嘱 (路径执行id, 病人医嘱id) Values (v_路径执行id, t_Advice(I));
  End If;

  If 病人病历ids_In Is Not Null Then
    Select Column_Value Bulk Collect Into t_Doc From Table(f_Num2list(病人病历ids_In));
    Select Column_Value Bulk Collect Into t_File From Table(f_Num2list(病历文件ids_In));
    For I In 1 .. t_Doc.Count Loop
      v_病历id := t_Doc(I);
    
      Insert Into 电子病历记录
        (ID, 病人来源, 病人id, 主页id, 婴儿, 科室id, 病历种类, 文件id, 病历名称, 创建人, 创建时间, 保存人, 保存时间, 最后版本, 签名级别, 编辑方式, 路径执行id)
        Select v_病历id, 2, 病人id_In, 主页id_In, 婴儿_In, 科室id_In, 种类, ID, 名称, 登记人_In, 登记时间_In, 登记人_In, 登记时间_In, 1, 0, decode(保留,2,1,0),
               v_路径执行id
        From 病历文件列表
        Where ID = t_File(I);

      For Rs In (Select ID, 文件id, Nvl(父id, 0) As 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行, 预制提纲id, 复用提纲, 使用时机,
                        诊治要素id, 替换域, 要素名称, 要素类型, 要素长度, 要素小数, 要素单位, 要素表示, 输入形态, 要素值域
                 From 病历文件结构
                 Where 文件id = t_File(I)
                 Order By 对象序号) Loop
      
        Select 电子病历内容_Id.Nextval Into v_Id From Dual;
      
        If Rs.父id = 0 Then
          v_当前父id := v_Id;
          v_父id     := Null;
        Else
          --对象序号为空的时候，父ID就不是按照顺序的了，需要重新查找
          If Rs.对象序号 Is Null Then
            Select 对象序号 Into v_原对象序号 From 病历文件结构 Where ID = Rs.父id;
            If v_原对象序号 Is Null Then
              v_父id := Null;
            Else
              Select ID Into v_父id From 电子病历内容 Where 文件id = v_病历id And 对象序号 = v_原对象序号;
            End If;
          Else
            v_父id := v_当前父id;
          End If;
        End If;
      
        If Rs.对象类型 = 4 And Rs.替换域 = 1 Then
          v_内容文本 := Zl_Replace_Element_Value(Rs.要素名称, 病人id_In, 主页id_In, 2, Null, 婴儿_In);
        Else
          v_内容文本 := Rs.内容文本;
        End If;
      
        Insert Into 电子病历内容
          (ID, 文件id, 开始版, 终止版, 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行, 预制提纲id, 定义提纲id, 复用提纲, 使用时机, 诊治要素id,
           替换域, 要素名称, 要素类型, 要素长度, 要素小数, 要素单位, 要素表示, 输入形态, 要素值域)
        Values
          (v_Id, v_病历id, 1, 0, v_父id, rs.对象序号, Rs.对象类型, Rs.对象标记, Rs.保留对象, rs.对象属性, Rs.内容行次, v_内容文本, Rs.是否换行, Rs.预制提纲id,
           Decode(Rs.父id, 0, Rs.Id, Null), Rs.复用提纲, Rs.使用时机, Rs.诊治要素id, Rs.替换域, Rs.要素名称, Rs.要素类型, Rs.要素长度, Rs.要素小数,
           Rs.要素单位, Rs.要素表示, Rs.输入形态, Rs.要素值域);
      
        If Rs.对象类型 = 5 Then
          Insert Into 电子病历图形 (对象id, 图形) Values (v_Id, (Select 图形 From 病历文件图形 Where 对象id = Rs.Id));
        End If;
      
      End Loop;
    
      Insert Into 电子病历格式
        (文件id, 内容)
      Values
        (v_病历id, (Select 内容 From 病历文件格式 Where 文件id = t_File(I)));
    End Loop;
  End If;

  If Nvl(电子病历id_In, 0) <> 0 Then
    Update 电子病历记录 Set 路径执行id = v_路径执行id Where ID = 电子病历id_In;
  End If;
  If 任务ids_In Is Not Null Then
    For Rs In (Select /*+ Rule*/
                Column_Value As 任务id
               From Table(Cast(f_Str2list(任务ids_In, ',') As Zltools.t_Strlist))) Loop
      Insert Into 病人路径病历 (路径执行id, 任务id) Values (v_路径执行id, Rs.任务id);
    End Loop;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人路径生成_Insert;
/

--92410:刘尔旋,2016-01-05,费用状态调整
--91842:刘尔旋,2016-01-18,门诊转住院处理
Create Or Replace Procedure Zl_门诊转住院_收费转出
(
  No_In         住院费用记录.No%Type,
  操作员编号_In 住院费用记录.操作员编号%Type,
  操作员姓名_In 住院费用记录.操作员姓名%Type,
  退费时间_In   住院费用记录.发生时间%Type,
  门诊退费_In   Number := 0,
  入院科室id_In 住院费用记录.开单部门id%Type := Null,
  主页id_In     住院费用记录.主页id%Type := Null,
  结算方式_In   病人预交记录.结算方式%Type := Null,
  结帐id_In     病人预交记录.结帐id%Type := Null,
  原结帐id_In   病人预交记录.结帐id%Type := Null,
  误差费_In     病人预交记录.冲预交%Type := Null
) As
  --门诊退费_In:0-门诊转住院立即销帐;1-门诊退费模式
  -- 门诊退费_In为1时:入院科室id_In和主页ID_IN可以不传入
  n_Count      Number(5);
  n_原结帐id   住院费用记录.结帐id%Type;
  n_实收金额   门诊费用记录.实收金额%Type;
  n_预交使用额 病人预交记录.冲预交%Type;
  n_实际冲销   病人预交记录.冲预交%Type;
  n_组id       财务缴款分组.Id%Type;
  n_病人id     病人信息.病人id%Type;
  v_预交no     病人预交记录.No%Type;
  n_预交金额   病人预交记录.冲预交%Type;
  n_打印id     票据使用明细.打印id%Type;
  n_开单部门id 住院费用记录.开单部门id%Type;
  v_开单人     门诊费用记录.开单人%Type;
  n_结帐id     门诊费用记录.结帐id%Type;
  n_误差费     病人预交记录.冲预交%Type;
  v_误差费     结算方式.名称%Type;
  n_返回值     病人余额.费用余额%Type;
  v_结算方式   结算方式.名称%Type;
  v_Nos        Varchar2(3000);
  v_结帐ids    Varchar2(3000);
  v_原结帐ids  Varchar2(3000);
  n_Tempid     病人预交记录.Id%Type;
  n_预交id     病人预交记录.Id%Type;
  n_医保       Number;
  n_存在       Number;
  n_退现       Number;
  n_部分退费   Number;
  n_退费条数   Number;
  n_异常标志   Number;
  n_计算误差   Number;
  n_费用状态   门诊费用记录.费用状态%Type;

  Err_Item Exception;
  v_Err_Msg Varchar2(200);

  Procedure Zl_Square_Update
  (
    结帐ids_In    Varchar2,
    现结帐id_In   病人预交记录.结帐id%Type,
    缴款组id_In   病人预交记录.缴款组id%Type,
    退款时间_In   病人预交记录.收款时间%Type,
    结算序号_In   病人预交记录.结算序号%Type,
    结算内容_In   Varchar2 := Null,
    退费金额_In   病人预交记录.冲预交%Type := Null,
    结算卡序号_In 病人预交记录.结算卡序号%Type := Null
  ) As
    n_记录状态 病人卡结算记录.记录状态%Type;
    n_预交id   病人预交记录.Id%Type;
    v_卡号     病人卡结算记录.卡号%Type;
    n_存在卡片 Number;
    d_停用日期 消费卡目录.停用日期%Type;
    n_最大序号 病人卡结算记录.序号%Type;
    n_序号     病人卡结算记录.序号%Type;
    n_余额     消费卡目录.余额%Type;
    n_接口编号 病人卡结算记录.接口编号%Type;
    d_回收时间 消费卡目录.回收时间%Type;
    n_Id       病人预交记录.Id%Type;
  Begin
    n_预交id := 0;
  
    --处理消费卡,结算卡在上面就已经处理了
    For v_校对 In (Select Min(a.Id) As 预交id, c.消费卡id, Sum(c.结算金额) As 结算金额, c.接口编号, c.卡号, Max(c.序号) As 序号, Max(c.Id) As ID
                 From 病人预交记录 A, 病人卡结算对照 B, 病人卡结算记录 C
                 Where a.Id = b.预交id And a.结算卡序号 = 结算卡序号_In And b.卡结算id = c.Id And a.记录性质 = 3 And
                       Instr(Nvl(结算内容_In, '_LXH'), ',' || a.结算方式 || ',') = 0 And
                       a.结帐id In (Select Column_Value From Table(f_Str2list(结帐ids_In)))
                 Group By c.消费卡id, c.接口编号, c.卡号) Loop
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id = Nvl(v_校对.消费卡id, 0) And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      Else
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id Is Null And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      End If;
    
      If n_记录状态 = 1 Then
        n_记录状态 := 2;
      Else
        n_记录状态 := n_记录状态 + 2;
      End If;
      --多条时,只更新一条
      If n_预交id = 0 Then
        Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id,
           预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
          Select n_预交id, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, 退款时间_In, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
                 -1 * 退费金额_In, 现结帐id_In, 缴款组id_In, 预交类别, 卡类别id, Nvl(结算卡序号, v_校对.接口编号), 卡号, 交易流水号, 交易说明, 合作单位, 2, 结算序号_In,
                 结算性质
          From 病人预交记录 A
          Where ID = v_校对.预交id;
      End If;
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        --消费卡,直接退回卡数据中
        Begin
          Select 卡号, 1, 停用日期, (Select Max(序号) From 消费卡目录 B Where a.卡号 = b.卡号 And a.接口编号 = b.接口编号), 序号, 余额, 接口编号, 回收时间
          Into v_卡号, n_存在卡片, d_停用日期, n_最大序号, n_序号, n_余额, n_接口编号, d_回收时间
          From 消费卡目录 A
          Where ID = v_校对.消费卡id;
        Exception
          When Others Then
            n_存在卡片 := 0;
        End;
      
        --取消停用
        If n_存在卡片 = 0 Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡被他人删除，不能再启用该卡片,请检查！';
          Raise Err_Item;
        End If;
        If Nvl(n_序号, 0) < Nvl(n_最大序号, 0) Then
          v_Err_Msg := '不能启用历史发卡记录(卡号为"' || v_卡号 || '"),请检查！';
          Raise Err_Item;
        End If;
        If Nvl(d_停用日期, To_Date('3000-01-01', 'yyyy-mm-dd')) < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经被他人停用，不能再进行退费,请检查！';
          Raise Err_Item;
        End If;
      
        If d_回收时间 < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经回收，不能退费,请检查！';
          Raise Err_Item;
        End If;
        Update 消费卡目录 Set 余额 = Nvl(余额, 0) + 退费金额_In Where ID = Nvl(v_校对.消费卡id, 0);
      End If;
    
      Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      Insert Into 病人卡结算记录
        (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Select n_Id, 接口编号, 消费卡id, 序号, n_记录状态, 结算方式, -1 * 退费金额_In, 卡号, 交易流水号, 交易时间, 备注,
               Decode(消费卡id, Null, 0, 0, 0, 1) As 标志
        From 病人卡结算记录
        Where ID = v_校对.Id;
      Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
    
      If n_记录状态 <> 2 And n_记录状态 <> 1 Then
        Update 病人卡结算记录 Set 记录状态 = 3 Where ID = v_校对.Id;
      End If;
    End Loop;
  End;
Begin
  n_组id := Zl_Get组id(操作员姓名_In);
  --误差费
  Begin
    Select 名称 Into v_误差费 From 结算方式 Where 性质 = 9 And Rownum < 2;
  Exception
    When Others Then
      v_Err_Msg := '没有发现误差结算方式，请检查是否正确设置！';
      Raise Err_Item;
  End;

  If 原结帐id_In Is Null Then
  
    Select Count(NO), Sum(实收金额) Into n_Count, n_实收金额 From 门诊费用记录 Where NO = No_In And 记录性质 = 1;
    If n_Count = 0 Or n_实收金额 = 0 Then
      v_Err_Msg := '单据' || No_In || '不是收费单据或因并发原因他人操作了该单据,不能转为住院费用.';
      Raise Err_Item;
    End If;
  
    Select 结帐id, 病人id, 开单部门id, 开单人
    Into n_原结帐id, n_病人id, n_开单部门id, v_开单人
    From 门诊费用记录
    Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Rownum < 2;
  
    --1.1作废费用记录
    If 结帐id_In Is Null Then
      Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
    Else
      n_结帐id := 结帐id_In;
    End If;
  
    Insert Into 门诊费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别, 收费细目id,
       计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, 执行状态, 执行时间,
       操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 缴款组id, 费用状态)
      Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id,
             收费类别, 收费细目id, 计算单位, 付数, 发药窗口, -1 * 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, -1 * 应收金额, -1 * 实收金额, 开单部门id,
             开单人, 执行部门id, 划价人, 执行人, -1, 执行时间, 操作员编号_In, 操作员姓名_In, 发生时间, 退费时间_In, n_结帐id, -1 * 结帐金额, 保险项目否, 保险大类id, 统筹金额,
             摘要, Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, n_组id, 0
      From 门诊费用记录
      Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;
  
    --Update 门诊费用记录 Set 记录状态 = 3 Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;
  
    --1.2作废预交记录
    --作废冲预交部分
    For r_结账id In (Select Distinct 结帐id
                   From 门诊费用记录
                   Where NO In (Select Distinct NO
                                From 门诊费用记录
                                Where 结帐id In (Select 结帐id
                                               From 病人预交记录
                                               Where 结算序号 In (Select b.结算序号
                                                              From 门诊费用记录 A, 病人预交记录 B
                                                              Where a.No = No_In And b.结算序号 < 0 And Mod(a.记录性质, 10) = 1 And
                                                                    a.记录状态 <> 0 And a.结帐id = b.结帐id))) And
                         Mod(记录性质, 10) = 1 And 记录状态 <> 0
                   Union
                   Select Distinct 结帐id
                   From 门诊费用记录
                   Where NO In (Select Distinct NO
                                From 门诊费用记录
                                Where 结帐id In (Select a.结帐id
                                               From 门诊费用记录 A, 病人预交记录 B
                                               Where a.No = No_In And b.结算序号 > 0 And Mod(a.记录性质, 10) = 1 And a.记录状态 <> 0 And
                                                     a.结帐id = b.结帐id))) Loop
      v_原结帐ids := v_原结帐ids || ',' || r_结账id.结帐id;
    End Loop;
    v_原结帐ids := Substr(v_原结帐ids, 2);
  
    Begin
      Select 1
      Into n_医保
      From 保险结算记录
      Where 记录id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And Rownum < 2;
    Exception
      When Others Then
        n_医保 := 0;
    End;
  
    If n_医保 = 1 Then
      Begin
        Select 1
        Into n_存在
        From 医保结算明细
        Where NO = No_In And 结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And Rownum < 2;
      Exception
        When Others Then
          v_Err_Msg := '当前单据' || No_In || '不存在医保结算明细,无法进行门诊转住院!';
          Raise Err_Item;
      End;
    End If;
  
    --医保退款
    For r_医保 In (Select 结帐id, NO, 结算方式, 金额, 备注
                 From 医保结算明细
                 Where NO = No_In And 结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids)))) Loop
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) - r_医保.金额
      Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_医保.结算方式
      Returning 余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (操作员姓名_In, r_医保.结算方式, 1, -1 * r_医保.金额);
        n_返回值 := r_医保.金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_医保.结算方式 And Nvl(余额, 0) = 0;
      End If;
    
      Update 病人预交记录
      Set 冲预交 = 冲预交 + (-1 * r_医保.金额)
      Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 = r_医保.结算方式;
      If Sql%RowCount = 0 Then
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
           缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
        Values
          (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * r_医保.金额, r_医保.结算方式, Null, 退费时间_In,
           Null, Null, Null, 操作员编号_In, 操作员姓名_In, r_医保.备注, n_组id, Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id,
           0, 3);
      End If;
    
      Update 病人预交记录
      Set 记录状态 = 3
      Where 记录性质 = 3 And 记录状态 = 1 And 结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And
            结算方式 = r_医保.结算方式;
    
      Update 医保结算明细
      Set 金额 = 金额 + (-1 * r_医保.金额)
      Where NO = No_In And 结帐id = n_结帐id And 结算方式 = r_医保.结算方式;
      If Sql%RowCount = 0 Then
        Insert Into 医保结算明细
          (结帐id, NO, 结算方式, 金额)
        Values
          (n_结帐id, No_In, r_医保.结算方式, -1 * r_医保.金额);
      End If;
      n_实收金额 := n_实收金额 - r_医保.金额;
    End Loop;
  
    Begin
      Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And 名称 Like '%现金%' And Rownum < 2;
    Exception
      When Others Then
        Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
    End;
  
    If n_实收金额 <> 0 Then
      For r_Prepay In (Select NO, 实际票号, 病人id, 主页id, 科室id, 结算方式, 结算号码, 缴款单位, 单位开户行, 单位帐号, Sum(冲预交) As 冲预交, 卡类别id, 结算卡序号,
                              卡号, 交易流水号, 交易说明, 合作单位
                       From 病人预交记录 A
                       Where 记录性质 In (1, 11) And a.结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids)))
                       Group By n_Tempid, NO, 实际票号, 病人id, 主页id, 科室id, 结算方式, 结算号码, 缴款单位, 单位开户行, 单位帐号, 卡类别id, 结算卡序号, 卡号,
                                交易流水号, 交易说明, 合作单位) Loop
        If n_实收金额 <> 0 Then
          If r_Prepay.冲预交 >= n_实收金额 Then
            Select 病人预交记录_Id.Nextval Into n_Tempid From Dual;
            Insert Into 病人预交记录
              (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号,
               冲预交, 结帐id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结算序号, 缴款组id)
              Select n_Tempid, r_Prepay.No, r_Prepay.实际票号, 11, 1, r_Prepay.病人id, r_Prepay.主页id, r_Prepay.科室id, Null,
                     r_Prepay.结算方式, r_Prepay.结算号码, Null, r_Prepay.缴款单位, r_Prepay.单位开户行, r_Prepay.单位帐号, 退费时间_In, 操作员姓名_In,
                     操作员编号_In, -1 * n_实收金额, n_结帐id, r_Prepay.卡类别id, r_Prepay.结算卡序号, r_Prepay.卡号, r_Prepay.交易流水号,
                     r_Prepay.交易说明, r_Prepay.合作单位, 1, -1 * n_结帐id, n_组id
              From Dual;
            Update 病人余额
            Set 预交余额 = Nvl(预交余额, 0) + Nvl(n_实收金额, 0)
            Where 病人id = n_病人id And 类型 = 1 And 性质 = 1
            Returning 预交余额 Into n_返回值;
            If Sql%RowCount = 0 Then
              Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (n_病人id, 1, n_实收金额, 1);
              n_返回值 := n_实收金额;
            End If;
            If Nvl(n_返回值, 0) = 0 Then
              Delete From 病人余额
              Where 病人id = n_病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
            End If;
            n_实收金额 := 0;
          Else
            Select 病人预交记录_Id.Nextval Into n_Tempid From Dual;
            Insert Into 病人预交记录
              (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号,
               冲预交, 结帐id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结算序号, 缴款组id)
              Select n_Tempid, r_Prepay.No, r_Prepay.实际票号, 11, 1, r_Prepay.病人id, r_Prepay.主页id, r_Prepay.科室id, Null,
                     r_Prepay.结算方式, r_Prepay.结算号码, Null, r_Prepay.缴款单位, r_Prepay.单位开户行, r_Prepay.单位帐号, 退费时间_In, 操作员姓名_In,
                     操作员编号_In, -1 * r_Prepay.冲预交, n_结帐id, r_Prepay.卡类别id, r_Prepay.结算卡序号, r_Prepay.卡号, r_Prepay.交易流水号,
                     r_Prepay.交易说明, r_Prepay.合作单位, 1, -1 * n_结帐id, n_组id
              From Dual;
            Update 病人余额
            Set 预交余额 = Nvl(预交余额, 0) + Nvl(r_Prepay.冲预交, 0)
            Where 病人id = n_病人id And 类型 = 1 And 性质 = 1
            Returning 预交余额 Into n_返回值;
            If Sql%RowCount = 0 Then
              Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (n_病人id, 1, r_Prepay.冲预交, 1);
              n_返回值 := r_Prepay.冲预交;
            End If;
            If Nvl(n_返回值, 0) = 0 Then
              Delete From 病人余额
              Where 病人id = n_病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
            End If;
            n_实收金额 := n_实收金额 - r_Prepay.冲预交;
          End If;
        End If;
      End Loop;
    End If;
    --2.票据收回
    --可能以前没有打印,无收回
    Select Nvl(Max(ID), 0)
    Into n_打印id
    From (Select b.Id
           From 票据使用明细 A, 票据打印内容 B
           Where a.打印id = b.Id And a.性质 = 1 And a.原因 In (1, 3) And b.数据性质 = 1 And b.No = No_In
           Order By a.使用时间 Desc)
    Where Rownum < 2;
    If n_打印id > 0 Then
      --多张单据循环调用时只能收回一次
      Select Count(打印id) Into n_Count From 票据使用明细 Where 票种 = 1 And 性质 = 2 And 打印id = n_打印id;
      If n_Count = 0 Then
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 退费时间_In, 操作员姓名_In
          From 票据使用明细
          Where 打印id = n_打印id And 票种 = 1 And 性质 = 1;
      End If;
    End If;
  
    --3.缴款数据处理(
    --   现有两种情况:
    --    1. 转出过程直接销帐的,则缴款数据不增加;
    --    2. 先转出,再到门诊退款退票,则需要进行缴款数据处理
    If Nvl(门诊退费_In, 0) = 1 Then
      For c_预交 In (Select a.结算方式, Sum(a.冲预交) As 冲预交, 2 As 预交类别, a.卡类别id, a.结算卡序号, a.卡号, Min(a.交易流水号) As 交易流水号,
                          Min(a.交易说明) As 交易说明, Min(a.合作单位) As 合作单位, b.性质
                   From 病人预交记录 A, 结算方式 B
                   Where a.记录性质 = 3 And a.结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And
                         a.结算方式 = b.名称 And b.性质 In (1, 2, 7, 8) And a.结算方式 Is Not Null
                   Group By a.结算方式, 预交类别, a.卡类别id, a.结算卡序号, a.卡号, b.性质
                   Having Sum(a.冲预交) <> 0
                   Order By a.卡类别id, 性质 Desc) Loop
        If n_实收金额 <> 0 Then
          Begin
            Select 是否退现 Into n_退现 From 医疗卡类别 Where ID = c_预交.卡类别id;
          Exception
            When Others Then
              n_退现 := 0;
          End;
          If (c_预交.性质 = 7 Or (c_预交.性质 = 8 And c_预交.卡类别id Is Not Null)) And n_退现 = 0 Then
            If c_预交.冲预交 > n_实收金额 Then
              Update 病人预交记录
              Set 冲预交 = 冲预交 + (-1 * n_实收金额), 摘要 = 摘要 || '1' || ',' || c_预交.卡类别id || ',' || -1 * n_实收金额 || '|'
              Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 Is Null;
              If Sql%RowCount = 0 Then
                Insert Into 病人预交记录
                  (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                   摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 结算性质, 校对标志)
                Values
                  (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * n_实收金额, Null, Null, 退费时间_In,
                   Null, Null, Null, 操作员编号_In, 操作员姓名_In, '1' || ',' || c_预交.卡类别id || ',' || -1 * n_实收金额 || '|', n_组id,
                   Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id, 3, 1);
              End If;
              Update 病人预交记录
              Set 记录状态 = 3
              Where 记录性质 = 3 And 记录状态 = 1 And 结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And
                    结算方式 = c_预交.结算方式;
              n_费用状态 := 1;
              n_实收金额 := 0;
            Else
              Update 病人预交记录
              Set 冲预交 = 冲预交 + (-1 * c_预交.冲预交), 摘要 = 摘要 || '1' || ',' || c_预交.卡类别id || ',' || -1 * c_预交.冲预交 || '|'
              Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 Is Null;
              If Sql%RowCount = 0 Then
                Insert Into 病人预交记录
                  (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                   摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 结算性质, 校对标志)
                Values
                  (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * c_预交.冲预交, Null, Null, 退费时间_In,
                   Null, Null, Null, 操作员编号_In, 操作员姓名_In, '1' || ',' || c_预交.卡类别id || ',' || -1 * c_预交.冲预交 || '|', n_组id,
                   Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id, 3, 1);
              End If;
            
              Update 病人预交记录
              Set 记录状态 = 3
              Where 记录性质 = 3 And 记录状态 = 1 And 结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And
                    结算方式 = c_预交.结算方式;
              n_费用状态 := 1;
              n_实收金额 := n_实收金额 - c_预交.冲预交;
            End If;
          Else
            n_实际冲销 := 0;
            If c_预交.性质 In (3, 4) Or (c_预交.性质 = 8 And c_预交.结算卡序号 Is Not Null) Then
              v_结算方式 := c_预交.结算方式;
            Else
              If 结算方式_In Is Null Then
                Begin
                  Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And 名称 Like '%现金%' And Rownum < 2;
                Exception
                  When Others Then
                    Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
                End;
              Else
                v_结算方式 := 结算方式_In;
              End If;
            End If;
          
            If c_预交.性质 = 8 And c_预交.结算卡序号 Is Not Null Then
              If n_实收金额 >= c_预交.冲预交 Then
                --Zl_Square_Update(v_原结帐ids, n_结帐id, n_组id, 退费时间_In, -1 * n_结帐id, Null, c_预交.冲预交, c_预交.结算卡序号);
                Update 病人预交记录
                Set 冲预交 = 冲预交 + (-1 * c_预交.冲预交), 摘要 = 摘要 || '0' || ',' || c_预交.结算卡序号 || ',' || -1 * c_预交.冲预交 || '|'
                Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 Is Null;
                If Sql%RowCount = 0 Then
                  Insert Into 病人预交记录
                    (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                     摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 结算性质, 校对标志)
                  Values
                    (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * c_预交.冲预交, Null, Null,
                     退费时间_In, Null, Null, Null, 操作员编号_In, 操作员姓名_In,
                     '0' || ',' || c_预交.结算卡序号 || ',' || -1 * c_预交.冲预交 || '|', n_组id, Null, Null, Null, Null, Null, Null,
                     n_结帐id, -1 * n_结帐id, 3, 1);
                End If;
                n_费用状态 := 1;
                n_实际冲销 := c_预交.冲预交;
              Else
                --Zl_Square_Update(v_原结帐ids, n_结帐id, n_组id, 退费时间_In, -1 * n_结帐id, Null, n_实收金额, c_预交.结算卡序号);
                Update 病人预交记录
                Set 冲预交 = 冲预交 + (-1 * n_实收金额), 摘要 = 摘要 || '0' || ',' || c_预交.结算卡序号 || ',' || -1 * n_实收金额 || '|'
                Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 Is Null;
                If Sql%RowCount = 0 Then
                  Insert Into 病人预交记录
                    (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                     摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 结算性质, 校对标志)
                  Values
                    (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * n_实收金额, Null, Null, 退费时间_In,
                     Null, Null, Null, 操作员编号_In, 操作员姓名_In, '0' || ',' || c_预交.结算卡序号 || ',' || -1 * n_实收金额 || '|', n_组id,
                     Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id, 3, 1);
                End If;
                n_费用状态 := 1;
                n_实际冲销 := n_实收金额;
              End If;
            Else
              If c_预交.冲预交 > n_实收金额 Then
                n_实际冲销 := n_实收金额;
              Else
                n_实际冲销 := c_预交.冲预交;
              End If;
            End If;
          
            If c_预交.结算卡序号 Is Null Then
              Update 人员缴款余额
              Set 余额 = Nvl(余额, 0) - n_实际冲销
              Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
              Returning 余额 Into n_返回值;
              If Sql%RowCount = 0 Then
                Insert Into 人员缴款余额
                  (收款员, 结算方式, 性质, 余额)
                Values
                  (操作员姓名_In, v_结算方式, 1, -1 * n_实际冲销);
                n_返回值 := n_实际冲销;
              End If;
              If Nvl(n_返回值, 0) = 0 Then
                Delete From 人员缴款余额
                Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式 And Nvl(余额, 0) = 0;
              End If;
            
              --退原预交记录
              Update 病人预交记录
              Set 冲预交 = 冲预交 + (-1 * n_实际冲销)
              Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 = v_结算方式;
              If Sql%RowCount = 0 Then
                Insert Into 病人预交记录
                  (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                   摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
                Values
                  (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * n_实际冲销, v_结算方式, Null, 退费时间_In,
                   Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, Null, Null, Null, Null, Null, c_预交.合作单位, n_结帐id,
                   -1 * n_结帐id, 0, 3);
              End If;
            End If;
            Update 病人预交记录
            Set 记录状态 = 3
            Where 记录性质 = 3 And 记录状态 = 1 And 结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And
                  结算方式 = c_预交.结算方式;
            n_实收金额 := n_实收金额 - n_实际冲销;
          End If;
        End If;
      End Loop;
    
      --更新费用审核记录
      Update 费用审核记录
      Set 记录状态 = 2
      Where 费用id In (Select ID From 门诊费用记录 Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3)) And 性质 = 1;
      --作废门诊记录
      Update 门诊费用记录 Set 记录状态 = 3 Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;
      For r_Clinic In (Select 序号, 从属父号, 价格父号, 病人id, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型,
                              发药窗口, 付数, Sum(数次) As 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, Sum(应收金额) As 应收金额,
                              Sum(实收金额) As 实收金额, Sum(统筹金额) As 统筹金额, 开单部门id, 开单人, 执行部门id, 划价人, Max(记帐单id) As 记帐单id, 发生时间,
                              实际票号
                       From 门诊费用记录
                       Where NO = No_In And 记录性质 = 1 And 记录状态 In (2, 3) And Nvl(附加标志, 0) Not In (8, 9)
                       Group By 序号, 从属父号, 价格父号, 病人id, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码,
                                费用类型, 发药窗口, 付数, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 开单部门id, 开单人, 执行部门id, 划价人, 发生时间, 实际票号
                       Having Sum(数次) <> 0) Loop
        Insert Into 门诊费用记录
          (ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否,
           保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用, 开单部门id, 开单人, 发生时间,
           登记时间, 执行部门id, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 缴款组id, 结帐id, 结帐金额, 费用状态)
        Values
          (病人费用记录_Id.Nextval, 1, No_In, r_Clinic.实际票号, 2, r_Clinic.序号, r_Clinic.从属父号, r_Clinic.价格父号, 1, r_Clinic.病人id,
           '', r_Clinic.姓名, r_Clinic.性别, r_Clinic.年龄, r_Clinic.病人科室id, r_Clinic.费别, r_Clinic.收费类别, r_Clinic.收费细目id,
           r_Clinic.计算单位, r_Clinic.保险项目否, r_Clinic.保险大类id, r_Clinic.保险编码, r_Clinic.费用类型, r_Clinic.发药窗口, r_Clinic.付数,
           -1 * r_Clinic.数次, r_Clinic.加班标志, r_Clinic.附加标志, r_Clinic.收入项目id, r_Clinic.收据费目, r_Clinic.标准单价,
           -1 * r_Clinic.应收金额, -1 * r_Clinic.实收金额, -1 * r_Clinic.统筹金额, 0, r_Clinic.开单部门id, r_Clinic.开单人, r_Clinic.发生时间,
           退费时间_In, r_Clinic.执行部门id, r_Clinic.划价人, 操作员编号_In, 操作员姓名_In, r_Clinic.记帐单id, '', n_组id, n_结帐id,
           -1 * r_Clinic.实收金额, 0);
      End Loop;
    Else
      --4.退款转预交(不产生票据,由操作员通过重打进行)
      For r_Pay In (Select Min(a.Id) As 预交id, a.结算方式, Sum(a.冲预交) As 冲预交, 2 As 预交类别, a.卡类别id, a.结算卡序号, a.卡号, a.交易流水号,
                           a.交易说明, a.合作单位, b.性质
                    From 病人预交记录 A, 结算方式 B
                    Where a.记录性质 = 3 And a.结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And
                          a.结算方式 = b.名称 And (b.性质 In (1, 2, 7, 8)) And a.结算方式 Is Not Null
                    Group By a.结算方式, 预交类别, a.卡类别id, a.结算卡序号, a.卡号, b.性质, a.交易流水号, a.交易说明, a.合作单位



                    
                    Having Sum(a.冲预交) <> 0
                    Order By a.卡类别id, 性质 Desc) Loop
        --4.1产生预交款单据 (不存在部分退费的情况)
        --所有单据,按规则生成预交款单据
        --因为收款后立即缴款,所以人员缴款余额无变化
        If n_实收金额 <> 0 Then
          If r_Pay.性质 = 7 Or (r_Pay.性质 = 8 And r_Pay.卡类别id Is Not Null) Then
            If r_Pay.冲预交 > n_实收金额 Then
              Update 病人预交记录
              Set 冲预交 = 冲预交 + (-1 * n_实收金额), 摘要 = 摘要 || '1' || ',' || r_Pay.卡类别id || ',' || -1 * n_实收金额 || '|'
              Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 Is Null;
              If Sql%RowCount = 0 Then
                Insert Into 病人预交记录
                  (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                   摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 结算性质, 校对标志)
                Values
                  (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * n_实收金额, Null, Null, 退费时间_In,
                   Null, Null, Null, 操作员编号_In, 操作员姓名_In, '1' || ',' || r_Pay.卡类别id || ',' || -1 * n_实收金额 || '|', n_组id,
                   Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id, 3, 1);
              End If;
            
              Update 病人预交记录
              Set 记录状态 = 3
              Where 记录性质 = 3 And 记录状态 = 1 And 结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And
                    结算方式 = r_Pay.结算方式;
              n_费用状态 := 1;
              n_实收金额 := 0;
            Else
              Update 病人预交记录
              Set 冲预交 = 冲预交 + (-1 * r_Pay.冲预交), 摘要 = 摘要 || '1' || ',' || r_Pay.卡类别id || ',' || -1 * r_Pay.冲预交 || '|'
              Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 Is Null;
              If Sql%RowCount = 0 Then
                Insert Into 病人预交记录
                  (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                   摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 结算性质, 校对标志)
                Values
                  (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * r_Pay.冲预交, Null, Null, 退费时间_In,
                   Null, Null, Null, 操作员编号_In, 操作员姓名_In, '1' || ',' || r_Pay.卡类别id || ',' || -1 * r_Pay.冲预交 || '|',
                   n_组id, Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id, 3, 1);
              End If;
            
              Update 病人预交记录
              Set 记录状态 = 3
              Where 记录性质 = 3 And 记录状态 = 1 And 结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And
                    结算方式 = r_Pay.结算方式;
              n_费用状态 := 1;
              n_实收金额 := n_实收金额 - r_Pay.冲预交;
            End If;
          Else
            n_实际冲销 := 0;
            If r_Pay.性质 In (3, 4) Or (r_Pay.性质 = 8 And r_Pay.结算卡序号 Is Not Null) Then
              v_结算方式 := r_Pay.结算方式;
            Else
              If 结算方式_In Is Null Then
                Begin
                  Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And 名称 Like '%现金%' And Rownum < 2;
                Exception
                  When Others Then
                    Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
                End;
              Else
                v_结算方式 := 结算方式_In;
              End If;
            End If;
          
            If r_Pay.性质 = 8 And r_Pay.结算卡序号 Is Not Null Then
              If n_实收金额 >= r_Pay.冲预交 Then
                --Zl_Square_Update(v_原结帐ids, n_结帐id, n_组id, 退费时间_In, -1 * n_结帐id, Null, r_Pay.冲预交, r_Pay.结算卡序号);
                Update 病人预交记录
                Set 冲预交 = 冲预交 + (-1 * r_Pay.冲预交), 摘要 = 摘要 || '0' || ',' || r_Pay.结算卡序号 || ',' || -1 * r_Pay.冲预交 || '|'
                Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 Is Null;
                If Sql%RowCount = 0 Then
                  Insert Into 病人预交记录
                    (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                     摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 结算性质, 校对标志)
                  Values
                    (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * r_Pay.冲预交, Null, Null,
                     退费时间_In, Null, Null, Null, 操作员编号_In, 操作员姓名_In,
                     '0' || ',' || r_Pay.结算卡序号 || ',' || -1 * r_Pay.冲预交 || '|', n_组id, Null, Null, Null, Null, Null,
                     Null, n_结帐id, -1 * n_结帐id, 3, 1);
                End If;
                n_费用状态 := 1;
                n_实际冲销 := r_Pay.冲预交;
              Else
                --Zl_Square_Update(v_原结帐ids, n_结帐id, n_组id, 退费时间_In, -1 * n_结帐id, Null, n_实收金额, r_Pay.结算卡序号);
                Update 病人预交记录
                Set 冲预交 = 冲预交 + (-1 * n_实收金额), 摘要 = 摘要 || '0' || ',' || r_Pay.结算卡序号 || ',' || -1 * n_实收金额 || '|'
                Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 Is Null;
                If Sql%RowCount = 0 Then
                  Insert Into 病人预交记录
                    (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                     摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 结算性质, 校对标志)
                  Values
                    (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * n_实收金额, Null, Null, 退费时间_In,
                     Null, Null, Null, 操作员编号_In, 操作员姓名_In, '0' || ',' || r_Pay.结算卡序号 || ',' || -1 * n_实收金额 || '|', n_组id,
                     Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id, 3, 1);
                End If;
                n_费用状态 := 1;
                n_实际冲销 := n_实收金额;
              End If;
            Else
              If r_Pay.冲预交 > n_实收金额 Then
                n_实际冲销 := n_实收金额;
              Else
                n_实际冲销 := r_Pay.冲预交;
              End If;
            End If;
          
            If r_Pay.性质 Not In (3, 4, 7, 8) Then
              Update 病人预交记录
              Set 金额 = 金额 + n_实际冲销
              Where 记录性质 = 1 And 记录状态 = 1 And 收款时间 = 退费时间_In And 病人id + 0 = n_病人id And 结算方式 = v_结算方式;
              If Sql%RowCount = 0 Then
                v_预交no := Nextno(11);
                Insert Into 病人预交记录
                  (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                   摘要, 缴款组id, 预交类别)
                Values
                  (病人预交记录_Id.Nextval, v_预交no, Null, 1, 1, n_病人id, 主页id_In, 入院科室id_In, n_实际冲销, v_结算方式, Null, 退费时间_In,
                   Null, Null, Null, 操作员编号_In, 操作员姓名_In, '门诊转住院预交', n_组id, r_Pay.预交类别);
              End If;
            
              --病人余额
              Update 病人余额
              Set 预交余额 = Nvl(预交余额, 0) + n_实际冲销
              Where 性质 = 1 And 病人id = n_病人id And 类型 = 2
              Returning 预交余额 Into n_返回值;
              If Sql%RowCount = 0 Then
                Insert Into 病人余额 (病人id, 性质, 类型, 预交余额, 费用余额) Values (n_病人id, 1, 2, n_实际冲销, 0);
                n_返回值 := n_实际冲销;
              End If;
              If Nvl(n_返回值, 0) = 0 Then
                Delete From 病人余额
                Where 病人id = n_病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
              End If;
            End If;
            --4.2缴款数据处理
            --   因为没有实际收病人的钱,所以不处理
            --部分退费情况，退原预交记录
            If r_Pay.性质 In (3, 4) Then
              Update 人员缴款余额
              Set 余额 = Nvl(余额, 0) - n_实际冲销
              Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Pay.结算方式
              Returning 余额 Into n_返回值;
              If Sql%RowCount = 0 Then
                Insert Into 人员缴款余额
                  (收款员, 结算方式, 性质, 余额)
                Values
                  (操作员姓名_In, r_Pay.结算方式, 1, -1 * n_实际冲销);
                n_返回值 := n_实际冲销;
              End If;
              If Nvl(n_返回值, 0) = 0 Then
                Delete From 人员缴款余额
                Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Pay.结算方式 And Nvl(余额, 0) = 0;
              End If;
            End If;
          
            If r_Pay.性质 <> 8 Then
              Update 病人预交记录
              Set 冲预交 = 冲预交 + (-1 * n_实际冲销)
              Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 = v_结算方式;
              If Sql%RowCount = 0 Then
                Insert Into 病人预交记录
                  (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                   摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
                Values
                  (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * n_实际冲销, v_结算方式, Null, 退费时间_In,
                   Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, r_Pay.卡类别id, r_Pay.结算卡序号, r_Pay.卡号, r_Pay.交易流水号,
                   r_Pay.交易说明, r_Pay.合作单位, n_结帐id, -1 * n_结帐id, 0, 3);
              End If;
            End If;
          
            Update 病人预交记录
            Set 记录状态 = 3
            Where 记录性质 = 3 And 记录状态 = 1 And 结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And
                  结算方式 = v_结算方式;
            n_实收金额 := n_实收金额 - n_实际冲销;
          
          End If;
        End If;
      End Loop;
    End If;
  
    If 误差费_In Is Not Null Then
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要, 缴款组id,
         卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
      Values
        (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, 误差费_In, v_误差费, Null, 退费时间_In, Null, Null,
         Null, 操作员编号_In, 操作员姓名_In, '', n_组id, Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id, 0, 3);
    End If;
    Delete From 病人预交记录
    Where 结帐id = n_结帐id And 记录性质 = 3 And 记录状态 = 2 And 冲预交 = 0 And 结算方式 Is Not Null;
    Delete From 病人预交记录 Where 结帐id = n_原结帐id And 摘要 = '预交临时记录' And 记录性质 = 3;
    Update 门诊费用记录 Set 费用状态 = Nvl(n_费用状态, 0) Where NO = No_In And Mod(记录性质, 10) = 1 And 记录状态 = 2;
  Else
    --医保按结算转出
    For r_Nos In (Select Distinct a.No
                  From 门诊费用记录 A
                  Where Mod(a.记录性质, 10) = 1 And a.记录状态 In (1, 3) And a.结帐id = 原结帐id_In) Loop
      v_Nos := v_Nos || ',' || r_Nos.No;
    End Loop;
    v_Nos := Substr(v_Nos, 2);
  
    For r_结帐ids In (Select Distinct a.结帐id
                    From 门诊费用记录 A
                    Where a.No In (Select Column_Value From Table(f_Str2list(v_Nos))) And Mod(a.记录性质, 10) = 1 And
                          a.记录状态 <> 0) Loop
      v_结帐ids := v_结帐ids || ',' || r_结帐ids.结帐id;
    End Loop;
    v_结帐ids := Substr(v_结帐ids, 2);
    Select Count(a.No), Sum(a.实收金额)
    Into n_Count, n_实收金额
    From 门诊费用记录 A
    Where a.No In (Select Column_Value From Table(f_Str2list(v_Nos))) And Mod(a.记录性质, 10) = 1;
    If n_Count = 0 Or n_实收金额 = 0 Then
      v_Err_Msg := '本次结算不是收费或因并发原因他人操作了该结算,不能转为住院费用.';
      Raise Err_Item;
    End If;
  
    Select 结帐id, 病人id, 开单部门id, 开单人
    Into n_原结帐id, n_病人id, n_开单部门id, v_开单人
    From 门诊费用记录
    Where 结帐id = 原结帐id_In And Mod(记录性质, 10) = 1 And 记录状态 In (1, 3) And Rownum < 2;
  
    Begin
      Select 1
      Into n_部分退费
      From 门诊费用记录 A
      Where Mod(a.记录性质, 10) = 1 And a.记录状态 = 2 And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And
            Rownum < 2;
    Exception
      When Others Then
        n_部分退费 := 0;
    End;
  
    Begin
      Select 0
      Into n_部分退费
      From 门诊费用记录 A
      Where 记录性质 = 11 And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And Rownum < 2;
    Exception
      When Others Then
        Null;
    End;
    Begin
      Select Count(Avg(1))
      Into n_退费条数
      From 病人预交记录 A
      Where a.记录性质 = 3 And a.记录状态 <> 0 And 结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids)))
      Group By a.结算方式;
    Exception
      When Others Then
        n_退费条数 := 0;
    End;
    --1.1作废费用记录
    If 结帐id_In Is Null Then
      Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
    Else
      n_结帐id := 结帐id_In;
    End If;
    Insert Into 门诊费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别, 收费细目id,
       计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, 执行状态, 执行时间,
       操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 缴款组id, 费用状态)
      Select 病人费用记录_Id.Nextval, a.No, a.实际票号, a.记录性质, 2, a.序号, a.从属父号, a.价格父号, a.病人id, a.医嘱序号, a.门诊标志, a.姓名, a.性别, a.年龄,
             a.标识号, a.付款方式, a.费别, a.病人科室id, a.收费类别, a.收费细目id, a.计算单位, a.付数, a.发药窗口, -1 * a.数次, a.加班标志, a.附加标志, a.收入项目id,
             a.收据费目, a.记帐费用, a.标准单价, -1 * a.应收金额, -1 * a.实收金额, a.开单部门id, a.开单人, a.执行部门id, a.划价人, a.执行人, -1, a.执行时间,
             操作员编号_In, 操作员姓名_In, a.发生时间, 退费时间_In, n_结帐id, -1 * a.结帐金额, a.保险项目否, a.保险大类id, a.统筹金额, a.摘要,
             Decode(Nvl(a.附加标志, 0), 9, 1, 0), a.保险编码, a.费用类型, n_组id, 0
      From 门诊费用记录 A
      Where a.No In (Select Column_Value From Table(f_Str2list(v_Nos))) And Mod(a.记录性质, 10) = 1 And a.记录状态 = 1;
  
    --作废医保
    For r_医保 In (Select 结帐id, NO, 结算方式, 金额, 备注
                 From 医保结算明细
                 Where NO In (Select Column_Value From Table(f_Str2list(v_Nos))) And
                       结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids)))) Loop
      Update 医保结算明细
      Set 金额 = 金额 + (-1 * r_医保.金额)
      Where NO = r_医保.No And 结帐id = r_医保.结帐id And 结算方式 = r_医保.结算方式;
      If Sql%RowCount = 0 Then
        Insert Into 医保结算明细
          (结帐id, NO, 结算方式, 金额)
        Values
          (r_医保.结帐id, r_医保.No, r_医保.结算方式, -1 * r_医保.金额);
      End If;
    End Loop;
  
    --Update 门诊费用记录 Set 记录状态 = 3 Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;
    --1.2作废预交记录
    --作废冲预交部分
    If n_部分退费 = 0 And Nvl(门诊退费_In, 0) = 0 Then
      For r_Prepay In (Select NO, 实际票号, 病人id, 主页id, 科室id, 结算方式, 结算号码, 缴款单位, 单位开户行, 单位帐号, 收款时间, -1 * Sum(冲预交) As 冲预交,
                              卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质
                       From 病人预交记录 A
                       Where 记录性质 In (1, 11) And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And
                             Nvl(冲预交, 0) <> 0
                       Group By n_Tempid, NO, 实际票号, 病人id, 主页id, 科室id, 结算方式, 结算号码, 缴款单位, 单位开户行, 单位帐号, 收款时间, 卡类别id, 结算卡序号,
                                卡号, 交易流水号, 交易说明, 合作单位, 结算性质) Loop
        Select 病人预交记录_Id.Nextval Into n_Tempid From Dual;
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 预交类别, 结算性质)
          Select n_Tempid, r_Prepay.No, r_Prepay.实际票号, 11, 1, r_Prepay.病人id, r_Prepay.主页id, r_Prepay.科室id, Null,
                 r_Prepay.结算方式, r_Prepay.结算号码, Null, r_Prepay.缴款单位, r_Prepay.单位开户行, r_Prepay.单位帐号, 退费时间_In, 操作员姓名_In,
                 操作员编号_In, r_Prepay.冲预交, n_结帐id, n_组id, r_Prepay.卡类别id, r_Prepay.结算卡序号, r_Prepay.卡号, r_Prepay.交易流水号,
                 r_Prepay.交易说明, r_Prepay.合作单位, -1 * n_结帐id, 1, r_Prepay.结算性质
          From Dual;
      End Loop;
    
      For v_预交 In (Select 病人id, Nvl(预交类别, 2) As 预交类别, Nvl(Sum(Nvl(冲预交, 0)), 0) As 预交金额
                   From 病人预交记录 A
                   Where 记录性质 In (1, 11) And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And
                         a.结帐id <> n_结帐id
                   Group By 病人id, Nvl(预交类别, 2)
                   Having Sum(Nvl(冲预交, 0)) <> 0) Loop
      
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) + Nvl(v_预交.预交金额, 0)
        Where 病人id = v_预交.病人id And 类型 = Nvl(v_预交.预交类别, 2) And 性质 = 1
        Returning 预交余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 病人余额
            (病人id, 类型, 预交余额, 性质)
          Values
            (v_预交.病人id, Nvl(v_预交.预交类别, 2), v_预交.预交金额, 1);
          n_返回值 := v_预交.预交金额;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 病人余额
          Where 病人id = v_预交.病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
        End If;
      End Loop;
    Else
      If n_退费条数 = 0 And Nvl(门诊退费_In, 0) = 0 Then
        --只使用了预交，原样退回预交
        For r_Prepay In (Select NO, 实际票号, 病人id, 主页id, 科室id, Max(结算方式) As 结算方式, 结算号码, 缴款单位, 单位开户行, 单位帐号, 收款时间,
                                -1 * Sum(冲预交) As 冲预交, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质
                         From 病人预交记录 A
                         Where 记录性质 In (1, 11) And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And
                               Nvl(冲预交, 0) <> 0
                         Group By n_Tempid, NO, 实际票号, 病人id, 主页id, 科室id, 结算号码, 缴款单位, 单位开户行, 单位帐号, 收款时间, 卡类别id, 结算卡序号, 卡号,
                                  交易流水号, 交易说明, 合作单位, 结算性质) Loop
          Select 病人预交记录_Id.Nextval Into n_Tempid From Dual;
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
             结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 预交类别, 结算性质)
            Select n_Tempid, r_Prepay.No, r_Prepay.实际票号, 11, 1, r_Prepay.病人id, r_Prepay.主页id, r_Prepay.科室id, Null,
                   r_Prepay.结算方式, r_Prepay.结算号码, Null, r_Prepay.缴款单位, r_Prepay.单位开户行, r_Prepay.单位帐号, 退费时间_In, 操作员姓名_In,
                   操作员编号_In, r_Prepay.冲预交, n_结帐id, n_组id, r_Prepay.卡类别id, r_Prepay.结算卡序号, r_Prepay.卡号, r_Prepay.交易流水号,
                   r_Prepay.交易说明, r_Prepay.合作单位, -1 * n_结帐id, 1, r_Prepay.结算性质
            From Dual;
          Select -1 * 冲预交 Into n_预交金额 From 病人预交记录 Where ID = n_Tempid;
          Update 病人余额
          Set 预交余额 = Nvl(预交余额, 0) + Nvl(n_预交金额, 0)
          Where 病人id = r_Prepay.病人id And 类型 = 1 And 性质 = 1
          Returning 预交余额 Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (n_病人id, 1, n_预交金额, 1);
            n_返回值 := n_预交金额;
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 病人余额
            Where 病人id = r_Prepay.病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
          End If;
        End Loop;
      Else
        Begin
          Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And 名称 Like '%现金%' And Rownum < 2;
        Exception
          When Others Then
            Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
        End;
        Select 病人预交记录_Id.Nextval Into n_Tempid From Dual;
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
          Select n_Tempid, Max(NO), Max(实际票号), 3, 3, 病人id, 主页id, 科室id, Null, v_结算方式, Max(结算号码), '预交临时记录', Null, Null,
                 Null, Max(收款时间), 操作员姓名_In, 操作员编号_In, Sum(冲预交), n_原结帐id, Null, Null, Null, Null, Null, Null,
                 -1 * n_原结帐id, 3
          From 病人预交记录 A
          Where 记录性质 In (1, 11) And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And
                Nvl(冲预交, 0) <> 0
          Group By n_Tempid, 3, 3, 病人id, 主页id, 科室id, Null, v_结算方式, '预交临时记录', 操作员姓名_In, 操作员编号_In, n_原结帐id;
      End If;
    End If;
  
    --作废门诊缴费及医保部分
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
       卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
      Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, 退费时间_In, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
             0, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, -1 * n_结帐id, 结算性质
      From 病人预交记录 A, 结算方式 B
      Where a.记录性质 = 3 And a.记录状态 = 1 And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And
            a.结算方式 = b.名称 And b.性质 Not In (7, 8);
  
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
       卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质, 校对标志)
      Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, 退费时间_In, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
             0, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, -1 * n_结帐id, 结算性质, 1
      From 病人预交记录 A, 结算方式 B
      Where a.记录性质 = 3 And a.记录状态 = 1 And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And
            a.结算方式 = b.名称 And b.性质 = 7;
    If Sql%RowCount <> 0 Then
      n_费用状态 := 1;
    End If;
  
    Update 病人预交记录
    Set 记录状态 = 3
    Where 记录性质 = 3 And 记录状态 = 1 And 结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids)));
  
    --2.票据收回
    --可能以前没有打印,无收回
    For r_Nos In (Select Distinct a.No
                  From 门诊费用记录 A
                  Where Mod(a.记录性质, 10) = 1 And a.记录状态 In (1, 3) And
                        a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids)))) Loop
    
      Select Nvl(Max(ID), 0)
      Into n_打印id
      From (Select b.Id
             From 票据使用明细 A, 票据打印内容 B
             Where a.打印id = b.Id And a.性质 = 1 And a.原因 In (1, 3) And b.数据性质 = 1 And b.No = r_Nos.No
             Order By a.使用时间 Desc)
      Where Rownum < 2;
      If n_打印id > 0 Then
        --多张单据循环调用时只能收回一次
        Select Count(打印id) Into n_Count From 票据使用明细 Where 票种 = 1 And 性质 = 2 And 打印id = n_打印id;
        If n_Count = 0 Then
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 退费时间_In, 操作员姓名_In
            From 票据使用明细
            Where 打印id = n_打印id And 票种 = 1 And 性质 = 1;
        End If;
      End If;
    End Loop;
  
    --3.缴款数据处理(
    --   现有两种情况:
    --    1. 转出过程直接销帐的,则缴款数据不增加;
    --    2. 先转出,再到门诊退款退票,则需要进行缴款数据处理
    If Nvl(门诊退费_In, 0) = 1 Then
      For c_预交 In (Select a.结算方式, Sum(a.冲预交) As 冲预交, 2 As 预交类别, a.卡类别id, a.结算卡序号, a.卡号, Min(a.交易流水号) As 交易流水号,
                          Min(a.交易说明) As 交易说明, Min(a.合作单位) As 合作单位, b.性质
                   From 病人预交记录 A, 结算方式 B
                   Where a.记录性质 = 3 And a.记录状态 In (2, 3) And
                         a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And a.结算方式 = b.名称 And
                         b.性质 In (1, 2, 3, 4, 7, 8) And a.结算方式 Is Not Null
                   Group By a.结算方式, 预交类别, a.卡类别id, a.结算卡序号, a.卡号, b.性质
                   Having Sum(a.冲预交) <> 0) Loop
        Begin
          Select 是否退现 Into n_退现 From 医疗卡类别 Where ID = c_预交.卡类别id;
        Exception
          When Others Then
            n_退现 := 0;
        End;
        If (c_预交.性质 = 7 Or (c_预交.性质 = 8 And c_预交.卡类别id Is Not Null)) And n_退现 = 0 Then
          Update 病人预交记录
          Set 冲预交 = 冲预交 + (-1 * c_预交.冲预交), 摘要 = 摘要 || '1' || ',' || c_预交.卡类别id || ',' || -1 * c_预交.冲预交 || '|'
          Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 Is Null;
          If Sql%RowCount = 0 Then
            Insert Into 病人预交记录
              (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
               缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 结算性质, 校对标志)
            Values
              (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * c_预交.冲预交, Null, Null, 退费时间_In,
               Null, Null, Null, 操作员编号_In, 操作员姓名_In, '1' || ',' || c_预交.卡类别id || ',' || -1 * c_预交.冲预交 || '|', n_组id,
               Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id, 3, 1);
          End If;
          n_费用状态 := 1;
        Else
          If c_预交.性质 In (3, 4) Or (c_预交.性质 = 8 And c_预交.结算卡序号 Is Not Null) Then
            v_结算方式 := c_预交.结算方式;
          Else
            If 结算方式_In Is Null Then
              Begin
                Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And 名称 Like '%现金%' And Rownum < 2;
              Exception
                When Others Then
                  Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
              End;
            Else
              v_结算方式 := 结算方式_In;
            End If;
          End If;
        
          If c_预交.性质 = 8 And c_预交.结算卡序号 Is Not Null Then
            --Zl_Square_Update(v_结帐ids, n_结帐id, n_组id, 退费时间_In, -1 * n_结帐id, Null, c_预交.冲预交, c_预交.结算卡序号);
            Update 病人预交记录
            Set 冲预交 = 冲预交 + (-1 * c_预交.冲预交), 摘要 = 摘要 || '0' || ',' || c_预交.结算卡序号 || ',' || -1 * c_预交.冲预交 || '|'
            Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 Is Null;
            If Sql%RowCount = 0 Then
              Insert Into 病人预交记录
                (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
                 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 结算性质, 校对标志)
              Values
                (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * c_预交.冲预交, Null, Null, 退费时间_In,
                 Null, Null, Null, 操作员编号_In, 操作员姓名_In, '0' || ',' || c_预交.结算卡序号 || ',' || -1 * c_预交.冲预交 || '|', n_组id,
                 Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id, 3, 1);
            End If;
            n_费用状态 := 1;
          End If;
          If c_预交.结算卡序号 Is Null Then
            Update 人员缴款余额
            Set 余额 = Nvl(余额, 0) - c_预交.冲预交
            Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
            Returning 余额 Into n_返回值;
            If Sql%RowCount = 0 Then
              Insert Into 人员缴款余额
                (收款员, 结算方式, 性质, 余额)
              Values
                (操作员姓名_In, v_结算方式, 1, -1 * c_预交.冲预交);
              n_返回值 := c_预交.冲预交;
            End If;
            If Nvl(n_返回值, 0) = 0 Then
              Delete From 人员缴款余额
              Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式 And Nvl(余额, 0) = 0;
            End If;
            --部分退费情况，退原预交记录
            Update 病人预交记录
            Set 冲预交 = 冲预交 + (-1 * c_预交.冲预交)
            Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 = v_结算方式;
            If Sql%RowCount = 0 Then
              Insert Into 病人预交记录
                (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
                 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
              Values
                (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * c_预交.冲预交, v_结算方式, Null, 退费时间_In,
                 Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, Null, Null, Null, Null, Null, c_预交.合作单位, n_结帐id,
                 -1 * n_结帐id, 0, 3);
            End If;
          End If;
        End If;
      End Loop;
    
      --更新费用审核记录
      Update 费用审核记录
      Set 记录状态 = 2
      Where 费用id In (Select a.Id
                     From 门诊费用记录 A
                     Where a.No In (Select Column_Value From Table(f_Str2list(v_Nos))) And Mod(a.记录性质, 10) = 1 And
                           a.记录状态 In (1, 3)) And 性质 = 1;
      --作废门诊记录
      For r_Nos In (Select Distinct NO
                    From 门诊费用记录
                    Where Mod(记录性质, 10) = 1 And 记录状态 In (1, 3) And
                          结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids)))) Loop
        Update 门诊费用记录 Set 记录状态 = 3 Where NO = r_Nos.No And Mod(记录性质, 10) = 1 And 记录状态 = 1;
      End Loop;
      For r_Clinic In (Select Min(a.记录性质) As 记录性质, a.No, a.序号, a.从属父号, a.价格父号, a.病人id, a.姓名, a.性别, a.年龄, a.病人科室id, a.费别,
                              a.收费类别, a.收费细目id, a.计算单位, a.保险项目否, a.保险大类id, a.保险编码, a.费用类型, a.发药窗口, a.付数, Sum(a.数次) As 数次,
                              a.加班标志, a.附加标志, a.收入项目id, a.收据费目, a.标准单价, Sum(a.应收金额) As 应收金额, Sum(a.实收金额) As 实收金额,
                              Sum(a.统筹金额) As 统筹金额, a.开单部门id, a.开单人, a.执行部门id, a.划价人, Max(a.记帐单id) As 记帐单id,
                              Max(a.是否急诊) As 是否急诊, a.发生时间, Min(a.实际票号) As 实际票号
                       From 门诊费用记录 A
                       Where a.No In (Select Column_Value From Table(f_Str2list(v_Nos))) And Mod(a.记录性质, 10) = 1 And
                             a.记录状态 In (2, 3) And Nvl(a.附加标志, 0) Not In (8, 9)
                       Group By a.No, a.序号, a.从属父号, a.价格父号, a.病人id, a.姓名, a.性别, a.年龄, a.病人科室id, a.费别, a.收费类别, a.收费细目id,
                                a.计算单位, a.保险项目否, a.保险大类id, a.保险编码, a.费用类型, a.发药窗口, a.付数, a.加班标志, a.附加标志, a.收入项目id, a.收据费目,
                                a.标准单价, a.开单部门id, a.开单人, a.执行部门id, a.划价人, a.发生时间
                       Having Sum(a.数次) <> 0) Loop
        Insert Into 门诊费用记录
          (ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否,
           保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用, 开单部门id, 开单人, 发生时间,
           登记时间, 执行部门id, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 是否急诊, 缴款组id, 结帐id, 结帐金额, 执行状态, 费用状态)
        Values
          (病人费用记录_Id.Nextval, r_Clinic.记录性质, r_Clinic.No, r_Clinic.实际票号, 2, r_Clinic.序号, r_Clinic.从属父号, r_Clinic.价格父号,
           1, r_Clinic.病人id, '', r_Clinic.姓名, r_Clinic.性别, r_Clinic.年龄, r_Clinic.病人科室id, r_Clinic.费别, r_Clinic.收费类别,
           r_Clinic.收费细目id, r_Clinic.计算单位, r_Clinic.保险项目否, r_Clinic.保险大类id, r_Clinic.保险编码, r_Clinic.费用类型, r_Clinic.发药窗口,
           r_Clinic.付数, -1 * r_Clinic.数次, r_Clinic.加班标志, r_Clinic.附加标志, r_Clinic.收入项目id, r_Clinic.收据费目, r_Clinic.标准单价,
           -1 * r_Clinic.应收金额, -1 * r_Clinic.实收金额, -1 * r_Clinic.统筹金额, 0, r_Clinic.开单部门id, r_Clinic.开单人, r_Clinic.发生时间,
           退费时间_In, r_Clinic.执行部门id, r_Clinic.划价人, 操作员编号_In, 操作员姓名_In, r_Clinic.记帐单id, '', r_Clinic.是否急诊, n_组id, n_结帐id,
           -1 * r_Clinic.实收金额, -1, 0);
      End Loop;
    Else
      --4.退款转预交(不产生票据,由操作员通过重打进行)
    
      For r_Pay In (Select Min(a.Id) As 预交id, a.结算方式, Sum(a.冲预交) As 冲预交, 2 As 预交类别, a.卡类别id, a.结算卡序号, a.卡号, a.交易流水号,
                           a.交易说明, a.合作单位, b.性质
                    From 病人预交记录 A, 结算方式 B
                    Where a.记录性质 = 3 And a.记录状态 In (2, 3) And
                          a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And a.结算方式 = b.名称 And
                          b.性质 In (1, 2, 3, 4, 7, 8) And a.结算方式 Is Not Null
                    Group By a.结算方式, 预交类别, a.卡类别id, a.结算卡序号, a.卡号, b.性质, a.交易流水号, a.交易说明, a.合作单位



                    
                    Having Sum(a.冲预交) <> 0) Loop
        --4.1产生预交款单据 (不存在部分退费的情况)
        --所有单据,按规则生成预交款单据
        --因为收款后立即缴款,所以人员缴款余额无变化
        If r_Pay.性质 = 7 Or (r_Pay.性质 = 8 And r_Pay.卡类别id Is Not Null) Then
          Update 病人预交记录
          Set 冲预交 = 冲预交 + (-1 * r_Pay.冲预交), 摘要 = 摘要 || '1' || ',' || r_Pay.卡类别id || ',' || -1 * r_Pay.冲预交 || '|'
          Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 Is Null;
          If Sql%RowCount = 0 Then
            Insert Into 病人预交记录
              (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
               缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 结算性质, 校对标志)
            Values
              (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * r_Pay.冲预交, Null, Null, 退费时间_In,
               Null, Null, Null, 操作员编号_In, 操作员姓名_In, '1' || ',' || r_Pay.卡类别id || ',' || -1 * r_Pay.冲预交 || '|', n_组id,
               Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id, 3, 1);
          End If;
          n_费用状态 := 1;
        Else
          If r_Pay.性质 In (3, 4) Or (r_Pay.性质 = 8 And r_Pay.结算卡序号 Is Not Null) Then
            v_结算方式 := r_Pay.结算方式;
          Else
            Begin
              Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And 名称 Like '%现金%' And Rownum < 2;
            Exception
              When Others Then
                Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
            End;
          End If;
        
          If r_Pay.性质 = 8 Then
            --Zl_Square_Update(v_结帐ids, n_结帐id, n_组id, 退费时间_In, -1 * n_结帐id, Null, r_Pay.冲预交, r_Pay.结算卡序号);
            Update 病人预交记录
            Set 冲预交 = 冲预交 + (-1 * r_Pay.冲预交), 摘要 = 摘要 || '0' || ',' || r_Pay.结算卡序号 || ',' || -1 * r_Pay.冲预交 || '|'
            Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 Is Null;
            If Sql%RowCount = 0 Then
              Insert Into 病人预交记录
                (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
                 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 结算性质, 校对标志)
              Values
                (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * r_Pay.冲预交, Null, Null, 退费时间_In,
                 Null, Null, Null, 操作员编号_In, 操作员姓名_In, '0' || ',' || r_Pay.结算卡序号 || ',' || -1 * r_Pay.冲预交 || '|', n_组id,
                 Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id, 3, 1);
            End If;
            n_费用状态 := 1;
          End If;
          If r_Pay.性质 Not In (3, 4, 7, 8) Then
            Update 病人预交记录
            Set 金额 = 金额 + r_Pay.冲预交
            Where 记录性质 = 1 And 记录状态 = 1 And 收款时间 = 退费时间_In And 病人id + 0 = n_病人id And 结算方式 = v_结算方式;
            If Sql%RowCount = 0 Then
              v_预交no := Nextno(11);
              Insert Into 病人预交记录
                (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
                 缴款组id, 预交类别)
              Values
                (病人预交记录_Id.Nextval, v_预交no, Null, 1, 1, n_病人id, 主页id_In, 入院科室id_In, r_Pay.冲预交, v_结算方式, Null, 退费时间_In,
                 Null, Null, Null, 操作员编号_In, 操作员姓名_In, '门诊转住院预交', n_组id, r_Pay.预交类别);
            End If;
          
            --病人余额
            Update 病人余额
            Set 预交余额 = Nvl(预交余额, 0) + r_Pay.冲预交
            Where 性质 = 1 And 病人id = n_病人id And 类型 = 2
            Returning 预交余额 Into n_返回值;
            If Sql%RowCount = 0 Then
              Insert Into 病人余额 (病人id, 性质, 类型, 预交余额, 费用余额) Values (n_病人id, 1, 2, r_Pay.冲预交, 0);
              n_返回值 := r_Pay.冲预交;
            End If;
            If Nvl(n_返回值, 0) = 0 Then
              Delete From 病人余额
              Where 病人id = n_病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
            End If;
          End If;
          --4.2缴款数据处理
          --   因为没有实际收病人的钱,所以不处理
          --部分退费情况，退原预交记录
          If r_Pay.性质 In (3, 4) Then
            Update 人员缴款余额
            Set 余额 = Nvl(余额, 0) - r_Pay.冲预交
            Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Pay.结算方式
            Returning 余额 Into n_返回值;
            If Sql%RowCount = 0 Then
              Insert Into 人员缴款余额
                (收款员, 结算方式, 性质, 余额)
              Values
                (操作员姓名_In, r_Pay.结算方式, 1, -1 * r_Pay.冲预交);
              n_返回值 := r_Pay.冲预交;
            End If;
            If Nvl(n_返回值, 0) = 0 Then
              Delete From 人员缴款余额
              Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Pay.结算方式 And Nvl(余额, 0) = 0;
            End If;
          End If;
        
          If r_Pay.结算卡序号 Is Null Then
            Update 病人预交记录
            Set 冲预交 = 冲预交 + (-1 * r_Pay.冲预交)
            Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 = v_结算方式;
            If Sql%RowCount = 0 Then
              Insert Into 病人预交记录
                (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
                 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
              Values
                (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * r_Pay.冲预交, v_结算方式, Null, 退费时间_In,
                 Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, r_Pay.卡类别id, r_Pay.结算卡序号, r_Pay.卡号, r_Pay.交易流水号,
                 r_Pay.交易说明, r_Pay.合作单位, n_结帐id, -1 * n_结帐id, 0, 3);
            End If;
          End If;
        End If;
      End Loop;
    End If;
    If 误差费_In Is Not Null Then
      Begin
        Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And 名称 Like '%现金%' And Rownum < 2;
      Exception
        When Others Then
          Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
      End;
      Update 病人预交记录
      Set 冲预交 = 冲预交 - 误差费_In
      Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 = v_结算方式;
      Update 病人预交记录
      Set 冲预交 = 冲预交 + 误差费_In
      Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 = v_误差费;
      If Sql%RowCount = 0 Then
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
           缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
        Values
          (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, 误差费_In, v_误差费, Null, 退费时间_In, Null, Null,
           Null, 操作员编号_In, 操作员姓名_In, '', n_组id, Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id, 0, 3);
      End If;
    End If;
    Delete From 病人预交记录 Where 结帐id = n_原结帐id And 摘要 = '预交临时记录' And 记录性质 = 3;
    Delete From 病人预交记录
    Where 结帐id = n_结帐id And 记录性质 = 3 And 记录状态 = 2 And 冲预交 = 0 And 结算方式 Is Not Null;
    Update 门诊费用记录
    Set 费用状态 = Nvl(n_费用状态, 0)
    Where NO In (Select Column_Value From Table(f_Str2list(v_Nos))) And Mod(记录性质, 10) = 1 And 记录状态 = 2;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊转住院_收费转出;
/

--91427:马政,2015-12-22,新增药品验收系统
Create Or Replace Procedure Zl_药品验收记录_Insert
(
  Id_In         In 药品验收记录.Id%Type,
  No_In         In 药品验收记录.No%Type,
  库房id_In     In 药品验收记录.库房id%Type,
  供药单位id_In In 药品验收记录.供药单位id%Type,
  验收人_In     In 药品验收记录.验收人%Type,
  验收日期_In   In 药品验收记录.验收日期%Type,
  是否合格_In   In 药品验收记录.是否合格%Type :=0,
  备注_in     in 药品验收记录.备注%type :=null
) Is
Begin
  Insert Into 药品验收记录
    (ID, NO, 库房id, 供药单位id, 验收人, 验收日期,  是否合格,备注)
  Values
    (Id_In, No_In, 库房id_In, 供药单位id_In, 验收人_In, 验收日期_In, 是否合格_In,备注_in);

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End;
/

--91427:马政,2015-12-22,新增药品验收系统
Create Or Replace Procedure Zl_药品验收明细_Insert
(
  验收id_In   In 药品验收明细.验收id%Type,
  药品id_In   In 药品验收明细.药品id%Type,
  成本价_In   In 药品验收明细.成本价%Type :=null,
  零售价_In   In 药品验收明细.零售价%Type :=null,
  进药数量_In In 药品验收明细.进药数量%Type:=null,
  批号_In     In 药品验收明细.批号%Type:=null,
  生产日期_In In 药品验收明细.生产日期%Type:=null,
  效期_In     In 药品验收明细.效期%Type:=null,
  产地_In     In 药品验收明细.产地%Type:=null,
  批准文号_In In 药品验收明细.批准文号%Type:=null,
  进药日期_In In 药品验收明细.进药日期%Type:=null,
  是否合格_In In 药品验收明细.是否合格%Type:=0
) Is
Begin
  Insert Into 药品验收明细
    (验收id, 药品id, 成本价, 零售价, 进药数量, 批号, 生产日期, 效期, 产地, 批准文号, 进药日期, 是否合格)
  Values
    (验收id_In, 药品id_In, 成本价_In, 零售价_In, 进药数量_In, 批号_In, 生产日期_In, 效期_In, 产地_In, 批准文号_In, 进药日期_In, 是否合格_In);

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End;
/

--91427:马政,2015-12-22,新增药品验收系统
Create Or Replace Procedure Zl_药品验收记录_Delete(验收id_In In 药品验收记录.Id%Type) Is
  Err_Isverified Exception;
Begin
  Delete From 药品验收记录 Where ID = 验收id_In And 复核人 Is Null;

  If Sql%RowCount = 0 Then
    Raise Err_Isverified;
  End If;
Exception
  When Err_Isverified Then
    Raise_Application_Error(-20101, '[ZLSOFT]该单据已经被他人删除或已被人审核！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End;
/

--91427:马政,2015-12-22,新增药品验收系统
Create Or Replace Procedure Zl_药品验收记录_Verify
(
  验收id_In   In 药品验收记录.Id%Type,
  复核人_In   In 药品验收记录.复核人%Type,
  复核日期_In In 药品验收记录.复核日期%Type
) Is
  Err_Isverified Exception;
Begin
  Update 药品验收记录 Set 复核人 = 复核人_In, 复核日期 = 复核日期_In Where ID = 验收id_In And 复核人 Is Null;

  If Sql%RowCount = 0 Then
    Raise Err_Isverified;
  End If;
Exception
  When Err_Isverified Then
    Raise_Application_Error(-20101, '[ZLSOFT]该单据已被人审核！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End;
/

--91225:梁经伙,2016-01-15,传染病报告卡取消审核时清空最近的疾病报告反馈记录
CREATE OR REPLACE Procedure Zl_疾病申报记录_Untread
(
  文件id_In   In Varchar2,
  IsStation_In   in Number:=NULL      --是否是传染病工作站调用，0，不是，1是传染病工作站调用
) Is
  n_处理状态 疾病申报记录.处理状态%Type;
  n_文件id   Number;
  n_Count    Number;
Begin
  If Length(文件id_In) <> 32 Then
    n_文件id := To_Number(文件id_In); --新病历ID是32位GUID
  End If;

  Select count(1)
  Into n_Count
  From 疾病申报记录
  Where 撤档人 Is Not Null And 撤档时间 Is Not Null And
        Decode(Length(文件id_In), 32, 文档id, 文件id) = Decode(Length(文件id_In), 32, 文件id_In, n_文件id);

  If n_Count > 0 Then      --取消删除
    Update 疾病申报记录
    Set 撤档人 = Null, 撤档时间 = Null
    Where 撤档人 Is Not Null And 撤档时间 Is Not Null And
          Decode(Length(文件id_In), 32, 文档id, 文件id) = Decode(Length(文件id_In), 32, 文件id_In, n_文件id);
  Else
    Select 处理状态
    Into n_处理状态
    From 疾病申报记录
    Where Decode(Length(文件id_In), 32, 文档id, 文件id) = Decode(Length(文件id_In), 32, 文件id_In, n_文件id);
    If n_处理状态 = 2 Then         --取消上报
      --如果是申报登记时进行的归档（归档人和申报登记人是否相同），则取消归档
      If Length(文件id_In) <> 32 Then
        Update 电子病历记录
        Set 归档人 = Null, 归档日期 = Null
        Where ID = n_文件id And 归档人 = (Select 登记人 From 疾病申报记录 Where 文件id = n_文件id);
      End If;
      if IsStation_In =1 then
        Update 疾病申报记录
        Set 处理状态 = 3, 报送人 = '', 报送时间 = Null, 报送单位 = Null, 报送备注 = '', 登记人 = '', 登记时间 = ''
        Where Decode(Length(文件id_In), 32, 文档id, 文件id) = Decode(Length(文件id_In), 32, 文件id_In, n_文件id);
      else
        Update 疾病申报记录
        Set 处理状态 = 1, 报送人 = '', 报送时间 = Null, 报送单位 = Null, 报送备注 = '', 登记人 = '', 登记时间 = ''
        Where Decode(Length(文件id_In), 32, 文档id, 文件id) = Decode(Length(文件id_In), 32, 文件id_In, n_文件id);
      end if;
    Elsif n_处理状态 = 1 Or n_处理状态 = -1 Then   --取消接收和拒绝
      If Length(文件id_In) <> 32 Then
        Update 电子病历记录 Set 处理状态 = 0 Where ID = n_文件id;
      End If;
      Delete 疾病申报记录
      Where Decode(Length(文件id_In), 32, 文档id, 文件id) = Decode(Length(文件id_In), 32, 文件id_In, n_文件id);
    Elsif n_处理状态 = 3 Or n_处理状态 = 4 Then  --取消审核
      If Length(文件id_In) <> 32 Then
        Update 电子病历记录 Set 处理状态 = 0 Where ID = n_文件id;
		Delete 疾病报告反馈 Where  文件id =  n_文件id And 登记时间 = (Select Max(登记时间) From 疾病报告反馈 Where 文件id =  n_文件id);
      End If;
          
      Update 疾病申报记录 Set 处理状态 = 1
      Where Decode(Length(文件id_In), 32, 文档id, 文件id) = Decode(Length(文件id_In), 32, 文件id_In, n_文件id);
    End If;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_疾病申报记录_Untread;
/

--91225:梁经伙,2015-12-22,传染病管理系统新增过程
CREATE OR REPLACE Procedure Zl_疾病申报记录_Delete(Id_In In Varchar2) Is
  v_撤档人 疾病申报记录.撤档人%Type;
  n_文件id Number;
  e_Changed Exception;
Begin

  If Length(Id_In) <> 32 Then
    n_文件id := To_Number(Id_In); --新病历ID是32位GUID 
  End If;
  Select b.姓名 Into v_撤档人 From 上机人员表 A, 人员表 B Where a.人员id = b.Id And a.用户名 = User And Rownum < 2;

  Update 疾病申报记录
  Set 撤档人 = v_撤档人, 撤档时间 = Sysdate
  Where Decode(Length(Id_In), 32, 文档id, 文件id) = Decode(Length(Id_In), 32, Id_In, n_文件id);
  If Sql%RowCount = 0 Then
    Raise e_Changed;
  End If;

Exception
  When e_Changed Then
    Raise_Application_Error(-20101, '[ZLSOFT]疾病报告已经被其他用户改变！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_疾病申报记录_Delete;
/

--91225:梁经伙,2015-12-24,传染病管理系统
CREATE OR REPLACE Procedure Zl_疾病申报记录_Update
(
  文件id_In     In 疾病申报记录.文件id%Type,
  Aduitstate_In In Number,
  登记时间_In   In 疾病报告反馈.登记时间%Type,
  登记人_In     In 疾病报告反馈.登记人%Type,
  反馈内容_In   In 疾病报告反馈.反馈内容%Type,
  处理人_In     In 疾病报告反馈.处理人%Type,
  处理时间_In   In 疾病报告反馈.处理时间%Type,
  处理内容_In   In 疾病报告反馈.处理情况说明%Type
) Is
Begin
  If Aduitstate_In = 3 Then
    Update 疾病申报记录 Set 处理状态 = Aduitstate_In Where 文件id = 文件id_In;
    Insert Into 疾病报告反馈
      (文件id, 登记时间, 登记人, 记录状态, 反馈内容)
    Values
      (文件id_In, 登记时间_In, 登记人_In, 3, 反馈内容_In);
  Elsif Aduitstate_In = 4 Then
    Update 疾病申报记录 Set 处理状态 = Aduitstate_In Where 文件id = 文件id_In;
    Insert Into 疾病报告反馈
      (文件id, 登记时间, 登记人, 记录状态, 反馈内容)
    Values
      (文件id_In, 登记时间_In, 登记人_In, 1, 反馈内容_In);
  Elsif Aduitstate_In = 5 Then
      Update 疾病申报记录 Set 处理状态 = Aduitstate_In, 报卡类型='2 订正报告' Where 文件id = 文件id_In;
    
      Update 疾病报告反馈
      Set 记录状态 = 2, 处理人 = 处理人_In, 处理时间 = 处理时间_In, 处理情况说明 = 处理内容_In
      Where 文件id = 文件id_In And 登记时间 = (Select Max(登记时间) From 疾病报告反馈 Where 文件id = 文件id_In);
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_疾病申报记录_Update;
/

--91225:梁经伙,2015-12-18,阳性检测结果插入和更新的过程
CREATE OR REPLACE Procedure Zl_疾病阳性检测记录_Insert
(
  Id_In         In 疾病阳性记录.Id%Type,
  病人id_In     In 疾病阳性记录.病人id%Type,
  主页id_In     In 疾病阳性记录.主页id%Type,
  挂号单_In     In 疾病阳性记录.挂号单%Type,
  医嘱ID_In     In 疾病阳性记录.医嘱ID%Type,
  送检时间_In   In 疾病阳性记录.送检时间%Type,
  送检科室id_In In 疾病阳性记录.送检科室id%Type,
  送检医生_In   In 疾病阳性记录.送检医生%Type,
  标本名称_In   In 疾病阳性记录.标本名称%Type,
  反馈结果_In   In 疾病阳性记录.反馈结果%Type,
  传染病_In     In 疾病阳性记录.传染病名称%Type,
  检查时间_In   In 疾病阳性记录.检查时间%Type,
  登记时间_In   In 疾病阳性记录.登记时间%Type,
  登记人_In     In 疾病阳性记录.登记人%Type,
  登记科室id_In In 疾病阳性记录.登记科室id%Type,
  记录状态_In   In 疾病阳性记录.记录状态%Type
) Is
Begin
  Insert Into 疾病阳性记录
    (ID, 病人id, 主页id, 挂号单, 医嘱ID,送检时间, 送检科室id, 送检医生, 标本名称, 反馈结果, 传染病名称, 检查时间, 登记时间, 登记人, 登记科室id, 记录状态)
  Values
    (Id_In, 病人id_In, 主页id_In, 挂号单_In, 医嘱ID_In,送检时间_In, 送检科室id_In, 送检医生_In, 标本名称_In, 反馈结果_In, 传染病_In, 检查时间_In, 登记时间_In, 登记人_In,
     登记科室id_In, 记录状态_In);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_疾病阳性检测记录_Insert;
/

--93886:梁经伙,2016-03-04,确认传染病的时候，可以和报告卡关联
--91225:梁经伙,2016-01-11,阳性检测结果，关联和取消关联报告卡
CREATE OR REPLACE Procedure Zl_疾病阳性检测记录_Update
(
  Operate_in         In  number,
  Id_In           In 疾病阳性记录.Id%Type,
  文件ID_In       In 疾病阳性记录.文件ID%Type,
  记录状态_In     In 疾病阳性记录.记录状态%Type,
  处理人_In       In 疾病阳性记录.处理人%Type,
  处理时间_In     In 疾病阳性记录.处理时间%Type,
  处理情况说明_In In 疾病阳性记录.处理情况说明%Type
) Is
Begin
  if Operate_in = 1 then      /*设置处理说明 */
      Update 疾病阳性记录
      Set 处理人 = 处理人_In, 处理时间 = 处理时间_In, 处理情况说明 = 处理情况说明_In,记录状态 = 记录状态_In,文件ID = 文件ID_In 
      Where ID = Id_In;
  elsif Operate_in = 2 then   /*关联报告单和阳性结果反馈单*/
    if  文件ID_In is not null then
        Update 疾病阳性记录 Set 文件ID = 文件ID_In Where ID = Id_In;
    end if;
  elsif Operate_in = 3 then   /*取消报告单和阳性结果反馈单的关联*/
    if  文件ID_In is not null then
        Update 疾病阳性记录 Set 文件ID = NULL Where 文件ID = 文件ID_In;
    end if;
  end if;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_疾病阳性检测记录_Update;
/

--91561:刘尔旋,2015-12-14,预约接收免费号产生预交记录
Create Or Replace Procedure Zl_预约挂号接收_Insert
(
  No_In            门诊费用记录.No%Type,
  票据号_In        门诊费用记录.实际票号%Type,
  领用id_In        票据使用明细.领用id%Type,
  结帐id_In        门诊费用记录.结帐id%Type,
  诊室_In          门诊费用记录.发药窗口%Type,
  病人id_In        门诊费用记录.病人id%Type,
  门诊号_In        门诊费用记录.标识号%Type,
  姓名_In          门诊费用记录.姓名%Type,
  性别_In          门诊费用记录.性别%Type,
  年龄_In          门诊费用记录.年龄%Type,
  付款方式_In      门诊费用记录.付款方式%Type, --用于存放病人的医疗付款方式编号
  费别_In          门诊费用记录.费别%Type,
  结算方式_In      病人预交记录.结算方式%Type, --现金的结算名称
  现金支付_In      病人预交记录.冲预交%Type, --挂号时现金支付部份金额
  预交支付_In      病人预交记录.冲预交%Type, --挂号时使用的预交金额
  个帐支付_In      病人预交记录.冲预交%Type, --挂号时个人帐户支付金额
  发生时间_In      门诊费用记录.发生时间%Type,
  号序_In          挂号序号状态.序号%Type,
  操作员编号_In    门诊费用记录.操作员编号%Type,
  操作员姓名_In    门诊费用记录.操作员姓名%Type,
  生成队列_In      Number := 0,
  登记时间_In      门诊费用记录.登记时间%Type := Null,
  卡类别id_In      病人预交记录.卡类别id%Type := Null,
  结算卡序号_In    病人预交记录.结算卡序号%Type := Null,
  卡号_In          病人预交记录.卡号%Type := Null,
  交易流水号_In    病人预交记录.交易流水号%Type := Null,
  交易说明_In      病人预交记录.交易说明%Type := Null,
  险类_In          病人挂号记录.险类%Type := Null,
  结算模式_In      Number := 0,
  记帐费用_In      Number := 0,
  冲预交病人ids_In Varchar2 := Null,
  三方调用_In      Number := 0
) As
  --该游标用于收费冲预交的可用预交列表
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit
  (
    v_病人id        病人信息.病人id%Type,
    v_冲预交病人ids Varchar2
  ) Is
    Select *
    From (Select a.Id, a.病人id, a.记录状态, a.预交类别, a.No, Nvl(a.金额, 0) As 金额
           From 病人预交记录 A,
                (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                  From 病人预交记录 A
                  Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And
                        a.病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And Nvl(a.预交类别, 2) = 1
                  Group By NO
                  Having Sum(Nvl(a.金额, 0)) <> 0) B
           Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.结算方式 Not In (Select 名称 From 结算方式 Where 性质 = 5) And
                 a.No = b.No And a.病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And
                 Nvl(a.预交类别, 2) = 1
           Union All
           Select 0 As ID, Max(病人id) As 病人id, 记录状态, 预交类别, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
           From 病人预交记录
           Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(金额, 0) <> Nvl(冲预交, 0) And
                 病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And Nvl(预交类别, 2) = 1 Having
            Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
           Group By 记录状态, 预交类别, NO)
    Order By Decode(病人id, Nvl(v_病人id, 0), 0, 1), ID, NO, 预交类别;

  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_现金     结算方式.名称%Type;
  v_个人帐户 结算方式.名称%Type;
  v_队列名称 排队叫号队列.队列名称%Type;
  v_号别     门诊费用记录.计算单位%Type;
  v_号序     门诊费用记录.发药窗口%Type;
  v_排队号码 排队叫号队列.排队号码 %Type;
  v_预约方式 病人挂号记录.预约方式 %Type;

  n_打印id        票据打印内容.Id%Type;
  n_预交金额      病人预交记录.金额%Type;
  n_返回值        病人预交记录.金额%Type;
  v_冲预交病人ids Varchar2(4000);

  n_挂号id         病人挂号记录.Id%Type;
  n_分诊台签到排队 Number;
  n_组id           财务缴款分组.Id%Type;
  n_Count          Number(18);
  n_排队           Number;
  n_当天排队       Number;
  n_当前金额       病人预交记录.金额%Type;
  n_预交id         病人预交记录.Id%Type;
  n_消费卡id       消费卡目录.Id%Type;
  n_自制卡         Number;

  d_Date     Date;
  d_预约时间 门诊费用记录.发生时间%Type;
  d_发生时间 Date;
  d_排队时间 Date;
  n_时段     Number := 0;
  n_存在     Number := 0;
  v_排队序号 排队叫号队列.排队序号%Type;
  n_结算模式 病人信息.结算模式%Type;
  n_票种     票据使用明细.票种%Type;
  v_付款方式 病人挂号记录.医疗付款方式%Type;
  n_接收模式 Number := 0;
Begin
  n_组id          := Zl_Get组id(操作员姓名_In);
  v_冲预交病人ids := Nvl(冲预交病人ids_In, 病人id_In);
  n_接收模式      := Nvl(zl_GetSysParameter('预约接收模式', 1111), 0);

  --获取结算方式名称
  Begin
    Select 名称 Into v_现金 From 结算方式 Where 性质 = 1;
  Exception
    When Others Then
      v_现金 := '现金';
  End;
  Begin
    Select 名称 Into v_个人帐户 From 结算方式 Where 性质 = 3;
  Exception
    When Others Then
      v_个人帐户 := '个人帐户';
  End;
  If 登记时间_In Is Null Then
    Select Sysdate Into d_Date From Dual;
  Else
    d_Date := 登记时间_In;
  End If;

  --更新挂号序号状态
  Begin
    Select 号别, 号序, Trunc(发生时间), 发生时间, 预约方式
    Into v_号别, v_号序, d_预约时间, d_发生时间, v_预约方式
    From 病人挂号记录
    Where 记录性质 = 2 And 记录状态 = 1 And Rownum = 1 And NO = No_In;
  Exception
    When Others Then
      v_Err_Msg := '当前预约挂号单已被其它人接收';
      Raise Err_Item;
  End;

  --判断是否分时段
  Begin
    Select 1
    Into n_时段
    From Dual
    Where Exists (Select 1
           From 挂号安排时段 A, 挂号安排 B
           Where a.安排id = b.Id And b.号码 = v_号别 And Rownum < 2
           Union All
           Select 1
           From 挂号计划时段 C, 挂号安排计划 D 　
           Where c.计划id = d.Id And d.号码 = v_号别 And d.生效时间 > Sysdate And Rownum < 2);
  Exception
    When Others Then
      n_时段 := 0;
  End;

  If n_时段 = 0 And 三方调用_In = 0 Then
    If n_接收模式 = 0 Then
      If Trunc(发生时间_In) = Trunc(Sysdate) Then
        d_发生时间 := 发生时间_In;
      Else
        d_发生时间 := Sysdate;
      End If;
    Else
      d_发生时间 := 发生时间_In;
    End If;
  Else
    If Not 发生时间_In Is Null Then
      d_发生时间 := 发生时间_In;
    End If;
  End If;
  If Not v_号序 Is Null Then
    If 号序_In Is Null Then
      Delete 挂号序号状态 Where 号码 = v_号别 And Trunc(日期) = Trunc(d_预约时间) And 序号 = v_号序;
    Else
      If Trunc(d_预约时间) <> Trunc(Sysdate) And n_接收模式 = 0 Then
      
        If n_时段 = 0 And 三方调用_In = 0 Then
          --提前接收或延迟接收
          Delete 挂号序号状态 Where 号码 = v_号别 And Trunc(日期) = Trunc(d_预约时间) And 序号 = v_号序;
          Begin
            Select 1 Into n_存在 From 挂号序号状态 Where 号码 = v_号别 And 日期 = Trunc(Sysdate) And 序号 = v_号序;
          Exception
            When Others Then
              n_存在 := 0;
          End;
          If n_存在 = 0 Then
            Insert Into 挂号序号状态
              (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
            Values
              (v_号别, Trunc(Sysdate), v_号序, 1, 操作员姓名_In, Sysdate);
          Else
            --号码已被使用的情况
            Begin
              v_号序 := 1;
              Insert Into 挂号序号状态
                (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
              Values
                (v_号别, Trunc(Sysdate), v_号序, 1, 操作员姓名_In, Sysdate);
            Exception
              When Others Then
                Select Min(序号 + 1)
                Into v_号序
                From 挂号序号状态 A
                Where 号码 = v_号别 And 日期 = Trunc(Sysdate) And Not Exists
                 (Select 1 From 挂号序号状态 Where 号码 = a.号码 And 日期 = a.日期 And 序号 = a.序号 + 1);
                Insert Into 挂号序号状态
                  (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
                Values
                  (v_号别, Trunc(Sysdate), v_号序, 1, 操作员姓名_In, Sysdate);
            End;
          End If;
        Else
          Update 挂号序号状态
          Set 状态 = 1, 登记时间 = Sysdate
          Where Trunc(日期) = Trunc(d_预约时间) And 序号 = v_号序 And 号码 = v_号别 And 状态 = 2;
          If Sql% NotFound Then
            Begin
              Insert Into 挂号序号状态
                (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
              Values
                (v_号别, Trunc(Sysdate), v_号序, 1, 操作员姓名_In, Sysdate);
            Exception
              When Others Then
                v_Err_Msg := '序号' || v_号序 || '已被其它人使用,请重新选择一个序号.';
                Raise Err_Item;
            End;
          End If;
        
        End If;
      
      Else
        Update 挂号序号状态
        Set 序号 = 号序_In, 状态 = 1, 登记时间 = Sysdate
        Where 号码 = v_号别 And Trunc(日期) = Trunc(d_预约时间) And 序号 = v_号序;
        If Sql%RowCount = 0 Then
          Begin
            Insert Into 挂号序号状态
              (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
            Values
              (v_号别, Trunc(d_发生时间), v_号序, 1, 操作员姓名_In, Sysdate);
          Exception
            When Others Then
              v_Err_Msg := '序号' || v_号序 || '已被其它人使用,请重新选择一个序号.';
              Raise Err_Item;
          End;
        End If;
      End If;
    End If;
  Else
    If Not 号序_In Is Null Then
      Begin
        Insert Into 挂号序号状态
          (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
        Values
          (v_号别, Trunc(Sysdate), 号序_In, 1, 操作员姓名_In, Sysdate);
      Exception
        When Others Then
          v_Err_Msg := '序号' || 号序_In || '已被其它人使用,请重新选择一个序号.';
          Raise Err_Item;
      End;
      v_号序 := 号序_In;
    Else
      v_号序 := Null;
    End If;
  End If;

  --更新门诊费用记录
  Update 门诊费用记录
  Set 记录状态 = 1, 实际票号 = Decode(Nvl(记帐费用_In, 0), 1, Null, 票据号_In), 结帐id = Decode(Nvl(记帐费用_In, 0), 1, Null, 结帐id_In),
      结帐金额 = Decode(Nvl(记帐费用_In, 0), 1, Null, 实收金额), 发药窗口 = 诊室_In, 病人id = 病人id_In, 标识号 = 门诊号_In, 姓名 = 姓名_In, 年龄 = 年龄_In,
      性别 = 性别_In, 付款方式 = 付款方式_In, 费别 = 费别_In, 发生时间 = d_发生时间, 登记时间 = d_Date, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In,
      缴款组id = n_组id, 记帐费用 = Decode(Nvl(记帐费用_In, 0), 1, 1, 0)
  Where 记录性质 = 4 And 记录状态 = 0 And NO = No_In;

  --病人挂号记录
  Update 病人挂号记录
  Set 接收人 = 操作员姓名_In, 接收时间 = d_Date, 记录性质 = 1, 病人id = 病人id_In, 门诊号 = 门诊号_In, 发生时间 = d_发生时间, 姓名 = 姓名_In, 性别 = 性别_In,
      年龄 = 年龄_In, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In, 险类 = Decode(Nvl(险类_In, 0), 0, Null, 险类_In), 号序 = v_号序, 诊室 = 诊室_In
  Where 记录状态 = 1 And NO = No_In And 记录性质 = 2
  Returning ID Into n_挂号id;
  If Sql%NotFound Then
    Begin
      Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
      Begin
        Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In And Rownum < 2;
      Exception
        When Others Then
          v_付款方式 := Null;
      End;
      Insert Into 病人挂号记录
        (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 操作员编号, 操作员姓名,
         摘要, 号序, 预约, 预约方式, 接收人, 接收时间, 预约时间, 险类, 医疗付款方式)
        Select n_挂号id, No_In, 1, 1, 病人id_In, 门诊号_In, 姓名_In, 性别_In, 年龄_In, 计算单位, 加班标志, 诊室_In, Null, 执行部门id, 执行人, 0, Null,
               登记时间, 发生时间, 操作员编号, 操作员姓名, 摘要, v_号序, 1, Substr(结论, 1, 10) As 预约方式, 操作员姓名_In, Nvl(登记时间_In, Sysdate), 发生时间,
               Decode(Nvl(险类_In, 0), 0, Null, 险类_In), v_付款方式
        From 门诊费用记录
        Where 记录性质 = 4 And 记录状态 = 1 And Rownum = 1 And NO = No_In;
    Exception
      When Others Then
        v_Err_Msg := '由于并发原因,单据号为【' || No_In || '】的病人' || 姓名_In || '已经被接收';
        Raise Err_Item;
    End;
  End If;

  --0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站
  If Nvl(生成队列_In, 0) <> 0 Then
    n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
    If Nvl(n_分诊台签到排队, 0) = 0 Then
      For v_挂号 In (Select ID, 姓名, 诊室, 执行人, 执行部门id, 发生时间, 号别, 号序 From 病人挂号记录 Where NO = No_In) Loop
      
        Begin
          Select 1,
                 Case
                   When 排队时间 < Trunc(Sysdate) Then
                    1
                   Else
                    0
                 End
          Into n_排队, n_当天排队
          From 排队叫号队列
          Where 业务类型 = 0 And 业务id = v_挂号.Id And Rownum <= 1;
        Exception
          When Others Then
            n_排队 := 0;
        End;
        If n_排队 = 0 Then
          --产生队列
          --按”执行部门”产生队列
          n_挂号id   := v_挂号.Id;
          v_队列名称 := v_挂号.执行部门id;
          v_排队号码 := Zlgetnextqueue(v_挂号.执行部门id, n_挂号id, v_挂号.号别 || '|' || v_挂号.号序);
          v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
        
          --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)
          d_排队时间 := Zl_Get_Queuedate(n_挂号id, v_挂号.号别, v_挂号.号序, v_挂号.发生时间);
          --   队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,排队标记_In,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In,
          Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, v_挂号.执行部门id, v_排队号码, Null, 姓名_In, 病人id_In, v_挂号.诊室, v_挂号.执行人, d_排队时间,
                           v_预约方式, Null, v_排队序号);
        Elsif Nvl(n_当天排队, 0) = 1 Then
          --更新队列号
          v_排队号码 := Zlgetnextqueue(v_挂号.执行部门id, v_挂号.Id, v_挂号.号别 || '|' || Nvl(v_挂号.号序, 0));
          v_排队序号 := Zlgetsequencenum(0, v_挂号.Id, 1);
          --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In, 医生姓名_In ,排队号码_In
          Zl_排队叫号队列_Update(v_挂号.执行部门id, 0, v_挂号.Id, v_挂号.执行部门id, v_挂号.姓名, v_挂号.诊室, v_挂号.执行人, v_排队号码, v_排队序号);
        
        Else
          --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In, 医生姓名_In ,排队号码_In
          Zl_排队叫号队列_Update(v_挂号.执行部门id, 0, v_挂号.Id, v_挂号.执行部门id, v_挂号.姓名, v_挂号.诊室, v_挂号.执行人);
        End If;
      End Loop;
    End If;
  End If;

  --汇总结算到病人预交记录
  If (Nvl(现金支付_In, 0) <> 0 Or (Nvl(现金支付_In, 0) = 0 And Nvl(个帐支付_In, 0) = 0 And Nvl(预交支付_In, 0) = 0)) And
     Nvl(记帐费用_In, 0) = 0 Then
    Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
    Insert Into 病人预交记录
      (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 结算序号,
       结算性质)
    Values
      (n_预交id, 4, 1, No_In, 病人id_In, Nvl(结算方式_In, v_现金), 现金支付_In, d_Date, 操作员编号_In, 操作员姓名_In, 结帐id_In, '挂号收费', n_组id,
       卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, 结帐id_In, 4);
  
    If Nvl(结算卡序号_In, 0) <> 0 And Nvl(现金支付_In, 0) <> 0 Then
    
      n_消费卡id := Null;
      Begin
        Select Nvl(自制卡, 0), 1 Into n_自制卡, n_Count From 卡消费接口目录 Where 编号 = 结算卡序号_In;
      Exception
        When Others Then
          n_Count := 0;
      End;
      If n_Count = 0 Then
        v_Err_Msg := '[ZLSOFT]没有发现原结算卡的相应类别,不能继续操作！[ZLSOFT]';
        Raise Err_Item;
      End If;
      If n_自制卡 = 1 Then
        Select ID
        Into n_消费卡id
        From 消费卡目录
        Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In And
              序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In);
      End If;
      Zl_病人卡结算记录_Insert(结算卡序号_In, n_消费卡id, 结算方式_In, 现金支付_In, 卡号_In, Null, 登记时间_In, Null, 结帐id_In, n_预交id);
    End If;
  
  End If;

  --对于就诊卡通过预交金挂号
  If Nvl(预交支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 Then
    n_预交金额 := 预交支付_In;
    For r_Deposit In c_Deposit(病人id_In, v_冲预交病人ids) Loop
      n_当前金额 := Case
                  When r_Deposit.金额 - n_预交金额 < 0 Then
                   r_Deposit.金额
                  Else
                   n_预交金额
                End;
      If r_Deposit.Id <> 0 Then
        --第一次冲预交(填上结帐ID,金额为0)
        Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 4 Where ID = r_Deposit.Id;
      End If;
      --冲上次剩余额
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结算序号, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 登记时间_In,
               操作员姓名_In, 操作员编号_In, n_当前金额, 结帐id_In, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结帐id_In, 4
        From 病人预交记录
        Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
    
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - n_当前金额
      Where 病人id = r_Deposit.病人id And 性质 = 1 And 类型 = Nvl(r_Deposit.预交类别, 2)
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 类型, 预交余额, 性质)
        Values
          (r_Deposit.病人id, Nvl(r_Deposit.预交类别, 2), -1 * n_当前金额, 1);
        n_返回值 := -1 * n_当前金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Deposit.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --检查是否已经处理完
      If r_Deposit.金额 < n_预交金额 Then
        n_预交金额 := n_预交金额 - r_Deposit.金额;
      Else
        n_预交金额 := 0;
      End If;
    
      If n_预交金额 = 0 Then
        Exit;
      End If;
    End Loop;
  End If;

  --对于医保挂号
  If Nvl(个帐支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 Then
    Insert Into 病人预交记录
      (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
       预交类别, 结算序号, 结算性质)
    Values
      (病人预交记录_Id.Nextval, 4, 1, No_In, 病人id_In, v_个人帐户, 个帐支付_In, d_Date, 操作员编号_In, 操作员姓名_In, 结帐id_In, '医保挂号', n_组id,
       卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, Null, Null, 结帐id_In, 4);
  End If;

  --相关汇总表的处理
  --人员缴款余额
  If Nvl(现金支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 Then
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + 现金支付_In
    Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = Nvl(结算方式_In, v_现金)
    Returning 余额 Into n_返回值;
  
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额
        (收款员, 结算方式, 性质, 余额)
      Values
        (操作员姓名_In, Nvl(结算方式_In, v_现金), 1, 现金支付_In);
      n_返回值 := 现金支付_In;
    
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 人员缴款余额
      Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = Nvl(结算方式_In, v_现金) And Nvl(余额, 0) = 0;
    End If;
  End If;

  If Nvl(个帐支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 Then
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + 个帐支付_In
    Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = v_个人帐户
    Returning 余额 Into n_返回值;
  
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, v_个人帐户, 1, 个帐支付_In);
      n_返回值 := 个帐支付_In;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 人员缴款余额 Where 收款员 = 操作员姓名_In And 性质 = 1 And Nvl(余额, 0) = 0;
    End If;
  End If;

  --处理票据使用情况
  If 票据号_In Is Not Null And Nvl(记帐费用_In, 0) = 0 Then
    Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
  
    --当前票据的票种
    Select 票种 Into n_票种 From 票据领用记录 Where ID = Nvl(领用id_In, 0);
    --发出票据
    Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 4, No_In);
  
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
    Values
      (票据使用明细_Id.Nextval, n_票种, 票据号_In, 1, 1, 领用id_In, n_打印id, d_Date, 操作员姓名_In);
  
    --状态改动
    Update 票据领用记录
    Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = d_Date
    Where ID = Nvl(领用id_In, 0);
  End If;

  If Nvl(记帐费用_In, 0) = 1 Then
    --记帐
    If Nvl(病人id_In, 0) = 0 Then
      v_Err_Msg := '要针对病人的挂号费进行记帐，必须是建档病人才能记帐挂号。';
      Raise Err_Item;
    End If;
    For c_费用 In (Select 实收金额, 病人科室id, 开单部门id, 执行部门id, 收入项目id
                 From 门诊费用记录
                 Where 记录性质 = 4 And 记录状态 = 1 And NO = No_In And Nvl(记帐费用, 0) = 1) Loop
      --病人余额
      Update 病人余额
      Set 费用余额 = Nvl(费用余额, 0) + Nvl(c_费用.实收金额, 0)
      Where 病人id = Nvl(病人id_In, 0) And 性质 = 1 And 类型 = 1;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 费用余额, 预交余额)
        Values
          (病人id_In, 1, 1, Nvl(c_费用.实收金额, 0), 0);
      End If;
    
      --病人未结费用
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) + Nvl(c_费用.实收金额, 0)
      Where 病人id = 病人id_In And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(c_费用.病人科室id, 0) And
            Nvl(开单部门id, 0) = Nvl(c_费用.开单部门id, 0) And Nvl(执行部门id, 0) = Nvl(c_费用.执行部门id, 0) And 收入项目id + 0 = c_费用.收入项目id And
            来源途径 + 0 = 1;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人未结费用
          (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
        Values
          (病人id_In, Null, Null, c_费用.病人科室id, c_费用.开单部门id, c_费用.执行部门id, c_费用.收入项目id, 1, Nvl(c_费用.实收金额, 0));
      End If;
    End Loop;
  End If;
  If Nvl(病人id_In, 0) <> 0 Then
    n_结算模式 := 0;
    Update 病人信息
    Set 就诊时间 = d_发生时间, 就诊状态 = 1, 就诊诊室 = 诊室_In
    Where 病人id = 病人id_In
    Returning Nvl(结算模式, 0) Into n_结算模式;
    --取参数:
    If Nvl(n_结算模式, 0) <> Nvl(结算模式_In, 0) Then
      --结算模式的确定
      If n_结算模式 = 1 And Nvl(结算模式_In, 0) = 0 Then
        --病人已经是"先诊疗后结算的",本次是"先结算后诊疗的",则检查是否存在未结数据
        Select Count(1)
        Into n_Count
        From 病人未结费用
        Where 病人id = 病人id_In And (来源途径 In (1, 4) Or 来源途径 = 3 And Nvl(主页id, 0) = 0) And Nvl(金额, 0) <> 0 And Rownum < 2;
        If Nvl(n_Count, 0) <> 0 Then
          --存在未结算数据，必须先结算后才允许执行
          v_Err_Msg := '当前病人的就诊模式为先诊疗后结算且存在未结费用，不允许调整该病人的就诊模式,你可以先对未结费用结帐后再挂号或不调整病人的就诊模式!';
          Raise Err_Item;
        End If;
        --检查
        --未发生医嘱业务的（即当时就挂号的,需要保证同一次的就诊模式是一至的(程序已经检查，不用再处理)
      End If;
      Update 病人信息 Set 结算模式 = 结算模式_In Where 病人id = 病人id_In;
    End If;
  End If;

  --病人担保信息
  If 病人id_In Is Not Null Then
    Update 病人信息
    Set 担保人 = Null, 担保额 = Null, 担保性质 = Null
    Where 病人id = 病人id_In And Exists (Select 1
           From 病人担保记录
           Where 病人id = 病人id_In And 主页id Is Not Null And
                 登记时间 = (Select Max(登记时间) From 病人担保记录 Where 病人id = 病人id_In));
    If Sql%RowCount > 0 Then
      Update 病人担保记录
      Set 到期时间 = d_Date
      Where 病人id = 病人id_In And 主页id Is Not Null And Nvl(到期时间, d_Date) > d_Date;
    End If;
  End If;
  --消息推送
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 1, n_挂号id;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_预约挂号接收_Insert;
/

--92557:李小东,2016-01-12,相关金额和价格变量类型改成number类型
--91540:马政,2015-12-11,费用和药品流通精度统一
Create Or Replace Procedure Zl_药品收发记录_销售出库
(
  Id_In           In 门诊费用记录.Id%Type,
  药品摘要_In     药品收发记录.摘要%Type := Null,
  频次_In         药品收发记录.频次%Type := Null,
  单量_In         药品收发记录.单量%Type := Null,
  用法_In         药品收发记录.用法%Type := Null,
  煎法_In         药品收发记录.外观%Type := Null,
  期效_In         药品收发记录.扣率%Type := Null,
  计价特性_In     药品收发记录.扣率%Type := Null,
  主页id_In       未发药品记录.主页id%Type := Null,
  备货材料_In     Number := 0,
  备货材料批次_In 药品收发记录.批次%Type := Null
) Is
  ----------------------------------
  --功能：收费、划价时按照参数设置分解药品并产生相应的收发记录
  --规则：
  --      1、循环游标判断总出库数量与游标中每条记录数量是否充足，如果充足就是总数量，不充足挨个遍历直到数量直到遍历完并退出
  --      2、金额计算方式：定价取收费价目表现价，时价分批取库存表零售价，时价不分批，零售金额/实际数量，并将所有批次的金额累加起来为总出库金额
  --参数：
  --      Id_In：门诊费用记录或者住院费用记录ID
  --      备货材料_In：只有高值卫材才需要传入，非0表示是高值卫材
  --      备货材料批次_In：只有高值卫材才需要传入，非空表示是高值卫材的批次
  --      药品摘要_In：可选参数
  --      频次_In；单量_In；用法_In；煎法_In；期效_In；计价特性_In，可选参数，医嘱记录产生
  -----------------------------------
  Cursor c_Stock
  (
    n_Outmode  Number,
    n_库房id   药品收发记录.库房id%Type,
    n_药品id   药品收发记录.药品id%Type,
    n_备货材料 Number,
    n_备货批次 药品收发记录.批次%Type
  ) Is
    Select 库房id, 药品id, 批次, 效期, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 灭菌效期, 批准文号, 平均成本价, 零售价,
           上次扣率, 商品条码, 内部条码
    From 药品库存
    Where 药品id = n_药品id And 库房id = n_库房id And 性质 = 1 And
          Decode(n_备货材料, 0, 0, Nvl(n_备货批次, 0)) = Decode(n_备货材料, 0, 0, Nvl(n_备货批次, 0)) And
          (Nvl(批次, 0) = 0 Or 效期 Is Null Or 效期 > Trunc(Sysdate)) And Nvl(可用数量, 0) > 0
    Order By Decode(n_Outmode, 1, 效期, Null), Nvl(批次, 0);
  r_Stock c_Stock%RowType;

  n_Outmode      Number;
  n_分批         药品规格.药房分批%Type;
  n_时价         收费项目目录.是否变价%Type;
  n_当前数量     药品库存.实际数量%Type;
  n_费用金额小数 Number;
  n_费用单价小数 Number;
  n_流通金额小数 Number;
  n_流通单价小数 Number;
  n_标准单价     收费价目.现价%Type;
  n_当前单价     收费价目.现价%Type;
  n_类别         药品单据性质.类别id%Type;
  n_总金额       Number;
  n_总数量       药品库存.实际数量%Type;
  n_单据         药品单据性质.单据%Type;
  n_跟踪在用     材料特性.跟踪在用%Type;
  n_序号         门诊费用记录.序号%Type;
  v_名称         收费项目目录.名称%Type;
  n_虚拟库房id   部门表.Id%Type;
  n_库房id       部门表.Id%Type;
  n_优先级       身份.优先级%Type;
  n_Count        Number;
  Err_Custom Exception;
  v_Rust     Varchar2(300);
  v_Error    Varchar2(255);
  v_部门名称 部门表.名称%Type;

  v_单据类别   Varchar2(10);
  v_No         药品收发记录.No%Type;
  n_对方部门id 药品收发记录.对方部门id%Type;
  n_收费细目id 药品收发记录.药品id%Type;
  n_总出库数量 药品库存.实际数量%Type;
  n_发药库房id 药品收发记录.库房id%Type;
  n_记录性质   门诊费用记录.记录性质%Type;
  v_收费类别   门诊费用记录.收费类别%Type;
  n_多病人单   住院费用记录.多病人单%Type;
  n_医嘱序号   门诊费用记录.医嘱序号%Type;
  v_姓名       门诊费用记录.姓名%Type;
  n_付数       门诊费用记录.付数%Type;
  v_操作员     门诊费用记录.操作员姓名%Type;
  d_登记时间   门诊费用记录.登记时间%Type;
  n_门诊标志   门诊费用记录.门诊标志%Type;
  n_病人科室id 门诊费用记录.病人科室id%Type;
  n_标识号     门诊费用记录.标识号%Type;
  v_性别       门诊费用记录.性别%Type;
  n_年龄       门诊费用记录.年龄%Type;
  n_病人id     门诊费用记录.病人id%Type;
  v_发药窗口   门诊费用记录.发药窗口%Type;
  n_记录状态   门诊费用记录.记录状态%Type;

  --药品收发记录
  n_收发id   药品收发记录.Id%Type;
  n_扣率     药品收发记录.扣率%Type;
  d_灭菌效期 药品收发记录.灭菌效期%Type;
  d_灭菌日期 药品收发记录.灭菌日期%Type;

  v_其他出库no 药品收发记录.No%Type;
  n_出库序号   药品收发记录.序号%Type;
Begin
  Begin
    Select 类别, NO, 序号, 对方部门id, 收费细目id, 总出库数量, 发药库房id, 记录性质, 收费类别, 多病人单, 医嘱序号, 姓名, 付数, 划价人, 登记时间, 门诊标志, 病人科室id, 标识号, 性别,
           年龄, 病人id, 发药窗口, 记录状态, 标准单价
    Into v_单据类别, v_No, n_序号, n_对方部门id, n_收费细目id, n_总出库数量, n_发药库房id, n_记录性质, v_收费类别, n_多病人单, n_医嘱序号, v_姓名, n_付数, v_操作员,
         d_登记时间, n_门诊标志, n_病人科室id, n_标识号, v_性别, n_年龄, n_病人id, v_发药窗口, n_记录状态, n_标准单价
    From (Select '门诊' As 类别, NO, 序号, 病人科室id As 对方部门id, 收费细目id, 付数 * 数次 As 总出库数量, 执行部门id As 发药库房id, 记录性质, 收费类别, 0 As 多病人单,
                  医嘱序号, 姓名, 付数, 划价人, 登记时间, 门诊标志, 病人科室id, 标识号, 性别, 年龄, 病人id, 发药窗口, 记录状态, 标准单价
           From 门诊费用记录
           Where ID = Id_In
           Union All
           Select '住院' As 类别, NO, 序号, 病人科室id As 对方部门id, 收费细目id, 付数 * 数次 As 总出库数量, 执行部门id As 发药库房id, 记录性质, 收费类别, 多病人单, 医嘱序号,
                  姓名, 付数, 划价人, 登记时间, 门诊标志, 病人科室id, 标识号, 性别, 年龄, 病人id, 发药窗口, 记录状态, 标准单价
           From 住院费用记录
           Where ID = Id_In);
  Exception
    When Others Then
      v_No         := Null;
      n_对方部门id := 0;
      n_总出库数量 := 0;
  End;

  n_跟踪在用 := 0;
  --只处理有数量的
  If n_总出库数量 <> 0 Then
    --药品分批出库方式
    Select Zl_To_Number(Nvl(zl_GetSysParameter(150), 0)) Into n_Outmode From Dual;
    --金额小数位数
    Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')), Zl_To_Number(Nvl(zl_GetSysParameter(157), '5'))
    Into n_费用金额小数, n_费用单价小数
    From Dual;
  
    --取流通业务精度位数
    --类别:1-药品 2-卫材
    --内容：2-零售价 4-金额
    --单位：药品:1-售价 5-金额单位
    If v_收费类别 = '4' Then
      Select 精度 Into n_流通单价小数 From 药品卫材精度 Where 类别 = 2 And 内容 = 2 And 单位 = 1;
      Select 精度 Into n_流通金额小数 From 药品卫材精度 Where 类别 = 2 And 内容 = 4 And 单位 = 5;
    Else
      Select 精度 Into n_流通单价小数 From 药品卫材精度 Where 类别 = 1 And 内容 = 2 And 单位 = 1;
      Select 精度 Into n_流通金额小数 From 药品卫材精度 Where 类别 = 1 And 内容 = 4 And 单位 = 5;
    End If;
  
    n_总数量 := n_总出库数量;
  
    If v_收费类别 = '4' Then
      --收费类别=4表示是卫材单据
      If v_单据类别 = '门诊' Then
        If n_记录性质 = 1 Then
          n_单据 := 24;
        Else
          n_单据 := 25;
        End If;
      Elsif v_单据类别 = '住院' Then
        If n_多病人单 = 1 Then
          n_单据 := 26;
        Else
          n_单据 := 25;
        End If;
      End If;
    
      Select Nvl(a.在用分批, 0), Nvl(b.是否变价, 0), b.名称
      Into n_分批, n_时价, v_名称
      From 材料特性 A, 收费项目目录 B
      Where a.材料id = b.Id And b.Id = n_收费细目id;
      --跟踪在用
      Select 跟踪在用 Into n_跟踪在用 From 材料特性 Where 材料id = n_收费细目id;
      --备货卫材需要判断是否设置了虚拟库房对照
      If Nvl(备货材料_In, 0) = 1 Then
        Begin
          Select 虚拟库房id Into n_虚拟库房id From 虚拟库房对照 Where 科室id = n_发药库房id And Rownum <= 1;
        Exception
          When Others Then
            n_虚拟库房id := 0;
        End;
        If Nvl(n_虚拟库房id, 0) = 0 Then
          Begin
            Select 名称 Into v_Error From 部门表 Where ID = n_发药库房id;
          Exception
            When Others Then
              v_Error := '';
          End;
          v_Error := '执行部门"' || Nvl(v_Error, '') || '"未设置虚拟部门,请在卫材参数设置中设置.';
          Raise Err_Custom;
        End If;
      End If;
    Else
      --收费类别<>4表示是药品单据，收费类别有"5，6，7"
      If v_单据类别 = '门诊' Then
        If n_记录性质 = 1 Then
          n_单据 := 8;
        Else
          n_单据 := 9;
        End If;
      Elsif v_单据类别 = '住院' Then
        If n_多病人单 = 1 Then
          n_单据 := 10;
        Else
          n_单据 := 9;
        End If;
      End If;
    
      Select Nvl(a.药房分批, 0), Nvl(b.是否变价, 0), b.名称
      Into n_分批, n_时价, v_名称
      From 药品规格 A, 收费项目目录 B
      Where a.药品id = b.Id And b.Id = n_收费细目id;
    End If;
  
    --可能分批时价药品分解的批次变了
    If n_时价 = 1 Then
      --只有一个批次时,直接取该批次的单价
      --按照最小单位进行格式化
      v_Rust     := Zl_Fun_Getprice(n_收费细目id, n_发药库房id, n_总出库数量, 备货材料_In, 备货材料批次_In);
      n_当前单价 := Round(To_Number(Substr(v_Rust, 1, Instr(v_Rust, '|') - 1)), n_费用单价小数);
      n_标准单价 := Round(n_标准单价, n_费用单价小数);
    
      If n_当前单价 <> n_标准单价 Then
        If n_医嘱序号 Is Null Then
          If v_收费类别 = '4' Then
            v_Error := '第 ' || n_序号 || ' 行的时价卫生材料"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
          Else
            v_Error := '第 ' || n_序号 || ' 行的时价药品"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
          End If;
        Else
          If v_收费类别 = '4' Then
            v_Error := '在处理病人"' || v_姓名 || '"时发现时价卫生材料"' || v_名称 || '"当前计算的单价发生变化。' || Chr(13) || Chr(10) ||
                       '请检查该病人是否同时使用了两笔相同的"' || v_名称 || '"！';
          Else
            v_Error := '在处理病人"' || v_姓名 || '"时发现时价药品"' || v_名称 || '"当前计算的单价发生变化。' || Chr(13) || Chr(10) ||
                       '请检查该病人是否同时使用了两笔相同的"' || v_名称 || '"！';
          End If;
        End If;
        Raise Err_Custom;
      End If;
    End If;
  
    If v_收费类别 In ('5', '6', '7') Or (v_收费类别 = '4' And Nvl(n_跟踪在用, 0) = 1) Then
      If Nvl(备货材料_In, 0) = 1 And v_收费类别 = '4' Then
        n_库房id := n_虚拟库房id;
      Else
        n_库房id := n_发药库房id;
      End If;
    
      If v_收费类别 = '4' Then
        Select 类别id Into n_类别 From 药品单据性质 Where 单据 = n_单据 + 16;
      Else
        Select 类别id Into n_类别 From 药品单据性质 Where 单据 = n_单据;
      End If;
    
      n_总金额 := 0;
      --打开游标
      Open c_Stock(n_Outmode, n_库房id, n_收费细目id, 备货材料_In, 备货材料批次_In);
      --循环遍历
      While n_总出库数量 <> 0 Loop
        Fetch c_Stock
          Into r_Stock;
        If c_Stock%NotFound Then
          --第一次就没有库存,分批或时价都不允许。
          --分批药品数量分解不完,也就是库存不足。
          If n_分批 = 1 Or n_时价 = 1 Then
            Close c_Stock;
            If n_单据 = 8 Or n_单据 = 24 Then
              If v_收费类别 = '4' Then
                v_Error := '第 ' || n_序号 || ' 行的分批或时价卫生材料"' || v_名称 || '"没有可用的库存！';
              Else
                v_Error := '第 ' || n_序号 || ' 行的分批或时价药品"' || v_名称 || '"没有可用的药品库存！';
              End If;
            Else
              --单据=9，10，25，26是记账单提示不一样
              If n_医嘱序号 Is Null Then
                If v_收费类别 = '4' Then
                  If Nvl(备货材料_In, 0) = 1 And Not (n_分批 = 1 Or n_时价 = 1) Then
                    v_Error := '第 ' || n_序号 || ' 行的卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
                  Else
                    v_Error := '第 ' || n_序号 || ' 行的分批或时价卫生材料"' || v_名称 || '"没有足够的材料库存' || Case
                                 When Nvl(备货材料_In, 0) = 0 Then
                                  '！'
                                 Else
                                  ',不能进行备货记帐！'
                               End;
                  End If;
                Else
                  v_Error := '第 ' || n_序号 || ' 行的分批或时价药品"' || v_名称 || '"没有足够的库存！';
                End If;
              Else
                If v_收费类别 = '4' Then
                  If Nvl(备货材料_In, 0) = 1 And Not (n_分批 = 1 Or n_时价 = 1) Then
                    v_Error := '在处理病人"' || v_姓名 || '"时发现卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
                  Else
                    v_Error := '在处理病人"' || v_姓名 || '"时发现分批或时价卫生材料"' || v_名称 || '"没有足够的材料库存' || Case
                                 When Nvl(备货材料_In, 0) = 0 Then
                                  '！'
                                 Else
                                  ',不能进行备货记帐！'
                               End;
                  End If;
                Else
                  v_Error := '在处理病人"' || v_姓名 || '"时发现分批或时价药品"' || v_名称 || '"没有足够的库存！';
                End If;
              End If;
            End If;
            Raise Err_Custom;
          End If;
        Elsif (n_分批 = 1 And Nvl(r_Stock.批次, 0) = 0) Or (n_分批 = 0 And Nvl(r_Stock.批次, 0) <> 0) Then
          Close c_Stock;
          If n_医嘱序号 Is Null Then
            If v_收费类别 = '4' Then
              v_Error := '第 ' || n_序号 || ' 行卫生材料"' || v_名称 || '"的在用分批属性与库存记录不相符,请检查材料数据的正确性！';
            Else
              v_Error := '第 ' || n_序号 || ' 行药品"' || v_名称 || '"的分批属性与库存记录不相符,请检查药品数据的正确性！';
            End If;
          Else
            If v_收费类别 = '4' Then
              v_Error := '在处理病人"' || v_姓名 || '"时发现卫生材料"' || v_名称 || '"的分批属性与库存记录不相符,请检查材料数据的正确性！';
            Else
              v_Error := '在处理病人"' || v_姓名 || '"时发现药品"' || v_名称 || '"的分批属性与库存记录不相符,请检查药品数据的正确性！';
            End If;
          End If;
          Raise Err_Custom;
        End If;
      
        If c_Stock%Found Then
          If Nvl(r_Stock.实际数量, 0) = 0 And (n_总出库数量 > 0 Or n_时价 = 1) Then
            --实际数量为零时，不正常，不允许出库
            --实际数量不为零，金额为零，可能是正常的零价格管理。
            --负数的情况相当于入库,这种情况应是允许的；但时价需要计算价格，必须要有实际数量。
            Close c_Stock;
            If n_医嘱序号 Is Null Then
              If v_收费类别 = '4' Then
                v_Error := '第 ' || n_序号 || ' 行的卫生材料"' || v_名称 || '"当前无库存实际数量，可能存在尚未退料的记录，当前不能出库。';
              Else
                v_Error := '第 ' || n_序号 || ' 行药品"' || v_名称 || '"当前无库存实际数量，可能存在尚未退药的记录，当前不能出库。';
              End If;
            Else
              If v_收费类别 = '4' Then
                v_Error := '在处理病人"' || v_姓名 || '"时发现卫生材料"' || v_名称 || '"当前无库存实际数量，可能存在尚未退料的记录，当前不能出库。';
              Else
                v_Error := '在处理病人"' || v_姓名 || '"时发现药品"' || v_名称 || '"当前无库存实际数量，可能存在尚未退药的记录，当前不能出库。';
              End If;
            End If;
            Raise Err_Custom;
          End If;
        End If;
      
        If n_分批 = 1 Or n_时价 = 1 Then
          --对于不分批的时价只可能分解一次,分解不完上面判断了.它分解是为了计算单价.
          --每次分解取小者,库存不够分解不完在上面判断.
          If n_总出库数量 <= Nvl(r_Stock.可用数量, 0) Then
            n_当前数量 := n_总出库数量;
          Else
            n_当前数量 := Nvl(r_Stock.可用数量, 0);
          End If;
          If n_时价 = 1 Then
            n_当前单价 := Nvl(r_Stock.零售价, Nvl(r_Stock.实际金额 / r_Stock.实际数量, 0));
          Elsif n_分批 = 1 Then
            n_当前单价 := n_标准单价;
          End If;
        Else
          --定价不分批
          --非门诊单据且是高值卫材需要检查库存
          If n_单据 <> 8 Or n_单据 <> 24 Then
            If Nvl(备货材料_In, 0) = 1 And v_收费类别 = '4' Then
              If n_总出库数量 > Nvl(r_Stock.可用数量, 0) Then
                --不分批, 但又是备货卫材方式出库的,则需要检查当前库存是否充足.
                v_Error := '第 ' || n_序号 || ' 行的卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
                Raise Err_Custom;
              End If;
            End If;
          End If;
          n_当前数量 := n_总出库数量;
          n_当前单价 := n_标准单价;
        End If;
      
        --药品收发记录
        If c_Stock%Found Then
          --卫材灭菌效期:一次性材料且有效期
          If v_收费类别 = '4' Then
            n_Count := 0;
            Begin
              Select 灭菌效期 Into n_Count From 材料特性 Where Nvl(一次性材料, 0) = 1 And 材料id = n_收费细目id;
            Exception
              When Others Then
                Null;
            End;
            If Nvl(n_Count, 0) > 0 Then
              d_灭菌效期 := r_Stock.灭菌效期;
              d_灭菌日期 := d_灭菌效期 - n_Count * 30;
            End If;
          End If;
        End If;
      
        Select Nvl(Max(序号), 0) + 1 Into n_序号 From 药品收发记录 Where 单据 = n_单据 And 记录状态 = 1 And NO = v_No;
      
        n_扣率 := Null;
        If 期效_In Is Not Null Or 计价特性_In Is Not Null Then
          n_扣率 := Nvl(期效_In, 0) || Nvl(计价特性_In, 0);
        End If;
      
        --分批药品,如果是只使用了一个批次,则要填写付数
        If n_分批 = 1 And n_当前数量 <> n_总数量 Then
          n_Count := 1;
        Else
          n_Count := 0;
        End If;
      
        Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
        --修改的原单据号存放在摘要中
        Insert Into 药品收发记录
          (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人,
           填制日期, 费用id, 频次, 单量, 用法, 外观, 扣率, 灭菌效期, 灭菌日期, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
        Values
          (n_收发id, 1, n_单据, v_No, n_序号, n_发药库房id, n_对方部门id, n_类别, -1, n_收费细目id, r_Stock.批次, r_Stock.上次产地, r_Stock.上次批号,
           r_Stock.效期, Decode(n_Count, 1, 1, n_付数), Decode(n_Count, 1, n_当前数量, n_当前数量 / n_付数),
           Decode(n_Count, 1, n_当前数量, n_当前数量 / n_付数), Round(n_当前单价, n_流通单价小数), Round(n_当前单价 * n_当前数量, n_流通金额小数), 药品摘要_In,
           v_操作员, d_登记时间, Id_In, 频次_In, 单量_In, 用法_In, 煎法_In, n_扣率, d_灭菌效期, d_灭菌日期, r_Stock.上次供应商id, r_Stock.上次生产日期,
           r_Stock.批准文号, r_Stock.商品条码, r_Stock.内部条码);
      
        --药品库存(普通情况可能没有记录)
        Zl_药品库存_Update(n_收发id, 0, 1);
      
        --产生其他出库单 ，只有高值卫材才需要处理
        If v_收费类别 = '4' And Nvl(备货材料_In, 0) = 1 Then
          Begin
            Select Max(a.No), Max(a.序号)
            Into v_其他出库no, n_出库序号
            From 药品收发记录 A, 住院费用记录 B
            Where a.费用id = b.Id And b.No = v_No And 记录性质 = 2 And b.门诊标志 = n_门诊标志 And
                  Instr(',8,9,10,21,24,25,26,', ',' || a.单据 || ',') > 0;
          Exception
            When Others Then
              v_其他出库no := Null;
          End;
          If v_其他出库no Is Null Then
            v_其他出库no := Nextno(74, n_虚拟库房id, Null, 1);
          End If;
          If v_其他出库no Is Null Then
            v_Error := '在生成卫生材料的其他出库单时,获取相关的出库NO有误,请检查出库单的规则是否有误!';
            Raise Err_Custom;
          End If;
          If Nvl(n_病人科室id, 0) <> 0 Then
            Select 名称 Into v_部门名称 From 部门表 Where ID = n_病人科室id;
          End If;
          v_Error := LPad(' ', 4);
          v_Error := Substr('病人姓名:' || v_姓名 || v_Error || '性别:' || v_性别 || v_Error || '年龄' || n_年龄 || v_Error || '门诊号:' ||
                            Nvl(n_标识号, '') || v_Error || '病人科室:' || v_部门名称, 1, 100);
        
          n_出库序号 := Nvl(n_出库序号, 0) + 1;
          Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
        
          --高值卫材类别id默认19是为了方便统计，因为其他出库可以设置很多类别，所以默认19
          Insert Into 药品收发记录
            (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人,
             填制日期, 费用id, 频次, 发药窗口, 单量, 用法, 外观, 扣率, 灭菌效期, 灭菌日期, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
          Values
            (n_收发id, 1, 21, v_其他出库no, n_出库序号, n_虚拟库房id, n_对方部门id, 19, -1, n_收费细目id, r_Stock.批次, r_Stock.上次产地,
             r_Stock.上次批号, r_Stock.效期, 1, n_当前数量, n_当前数量, Round(n_当前单价, n_流通单价小数), Round(n_当前单价 * n_当前数量, n_流通金额小数),
             v_Error, v_操作员, d_登记时间, Id_In, 频次_In, v_发药窗口, 单量_In, 用法_In, 煎法_In, n_扣率, d_灭菌效期, d_灭菌日期, r_Stock.上次供应商id,
             r_Stock.上次生产日期, r_Stock.批准文号, r_Stock.商品条码, r_Stock.内部条码);
        
          --药品库存(普通情况可能没有记录)
          Zl_药品库存_Update(n_收发id, 0, 1);
        End If;
      
        v_Error      := '';
        n_总出库数量 := n_总出库数量 - n_当前数量;
        n_总金额     := n_总金额 + n_当前数量 * n_当前单价;
      End Loop;
    
      --未发药品记录
      Update 未发药品记录
      Set 病人id = n_病人id, 姓名 = v_姓名, 发药窗口 = v_发药窗口, 主页id = 主页id_In
      Where 单据 = n_单据 And NO = v_No And Nvl(库房id, 0) = Nvl(n_发药库房id, 0);
      If Sql%RowCount = 0 Then
        --取身份优先级
        Begin
          Select b.优先级 Into n_优先级 From 病人信息 A, 身份 B Where a.身份 = b.名称(+) And a.病人id = n_病人id;
        Exception
          When Others Then
            Null;
        End;
        Insert Into 未发药品记录
          (单据, NO, 病人id, 主页id, 姓名, 优先级, 库房id, 对方部门id, 填制日期, 已收费, 打印状态, 发药窗口)
        Values
          (n_单据, v_No, n_病人id, 主页id_In, v_姓名, n_优先级, n_发药库房id, n_对方部门id, d_登记时间, n_记录状态, 0, v_发药窗口);
      End If;
    
      --处理未发药记录状态
      Zl_Prescription_Type_Update(v_No, n_记录性质, n_收费细目id, v_收费类别);
    
      Close c_Stock;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_销售出库;
/


--91085:王振涛,2015-12-08,取消审核，同步取消提示
Create Or Replace Procedure Zl_检验标本记录_审核取消(Id_In 检验标本记录.Id%Type) Is
  --查找当前标本的相关申请
  Cursor c_Samplequest Is
    Select Distinct 医嘱id
    From (Select 医嘱id
           From 检验标本记录
           Where ID = Id_In
           Union
           Select 医嘱id From 检验项目分布 Where 标本id = Id_In);

  v_主页id Number(18);
  v_No     Varchar2(20);
  v_Temp   Varchar2(255);
  v_Fileid Number(18);

  v_人员编号 人员表.编号%Type;
  v_人员姓名 人员表.姓名%Type;
  v_当前时间 Date;
Begin
  --操作员信息:部门ID,部门名称;人员ID,人员编号,人员姓名
  v_Temp     := Zl_Identity;
  v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_当前时间 := Sysdate;


  --1.取消标本审核
  Update 检验标本记录
  Set 审核人 = Null, 审核时间 = Null, 打印次数 = Null, 审核未通过 = Null, 样本状态 = 1
  Where ID = Id_In;
  --Delete 检验签名记录 Where 检验标本id = Id_In;
  --记录审核过程
  Insert Into 检验操作记录
    (ID, 标本id, 操作类型, 操作员, 操作时间)
  Values
    (检验操作记录_Id.Nextval, Id_In, 1, v_人员姓名, Sysdate);

  --2.检查当前标本相关的申请的相关标本
  For r_Samplequest In c_Samplequest Loop
  
    --1.置申请单的正在执行状态
    Update 病人医嘱发送
    Set 执行状态 = 3, 完成人 = Null, 完成时间 = Null
    Where 医嘱id In (Select ID From 病人医嘱记录 Where r_Samplequest.医嘱id = 相关id);
  
    Update 病人医嘱发送
    Set 执行状态 = 3, 完成人 = Null, 完成时间 = Null
    Where 医嘱id In (Select ID From 病人医嘱记录 Where r_Samplequest.医嘱id = ID) And Nvl(采样人, '空空') = '空空';
  
    Begin
      Select 病历id Into v_Fileid From 病人医嘱报告 Where 医嘱id = r_Samplequest.医嘱id;
      Zl_报告查阅记录_Cancel(r_Samplequest.医嘱id, v_Fileid, Null);
      Delete 病人医嘱报告 Where 医嘱id = r_Samplequest.医嘱id;
    Exception
      When Others Then
        v_Fileid := 0;
    End;
    If v_Fileid <> 0 Then
      Delete 电子病历记录 Where ID = v_Fileid;
      Delete 电子病历内容 Where 文件id = v_Fileid;
    End If;
  
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_检验标本记录_审核取消;
/

--91259:刘硕,2015-12-08,地址复制，缓冲区过小问题处理
Create Or Replace Function Zl_Adderss_Structure(v_Addressinfo Varchar2) Return Varchar2 Is
  --返回结构：省,省编码,是否虚拟,是否不显示,是否只有虚拟级|市,市编码,是否虚拟,是否不显示,是否只有虚拟级
  --          |区县,区县编码,是否虚拟,是否不显示,是否只有虚拟级|乡镇,乡镇编码,是否虚拟,是否不显示,是否只有虚拟级
  --          |街道,街道编码,是否虚拟,是否不显示,是否只有虚拟级
  v_省       Varchar2(100);
  v_Code省   Varchar2(15);
  v_Info省   Varchar2(150);
  v_市       Varchar2(100);
  v_Code市   Varchar2(15);
  v_Info市   Varchar2(150);
  v_区县     Varchar2(100);
  v_Code区县 Varchar2(15);
  v_Info区县 Varchar2(150);
  v_乡镇     Varchar2(100);
  v_Code乡镇 Varchar2(15);
  v_Info乡镇 Varchar2(150);
  v_街道     Varchar2(500);
  v_Code街道 Varchar2(15);
  v_Info街道 Varchar2(550);
  v_Tmp      Varchar2(100);
  v_Adrstmp  Varchar2(500);
  n_Pos      Number(5);
  n_虚拟     Number(1);
  n_不显示   Number(1);
  n_Count    Number(3);
  v_Return   Varchar2(700);
Begin
  --传入结构化的地址，不用进行地址标准化分割解析
  v_Adrstmp := v_Addressinfo;
  If v_Addressinfo Like '%,%,%,%,%' Then
    n_Pos     := Instr(v_Adrstmp, ',');
    v_省      := Substr(v_Adrstmp, 1, n_Pos - 1);
    v_Adrstmp := Substr(v_Adrstmp, n_Pos + 1);
    n_Pos     := Instr(v_Adrstmp, ',');
    v_市      := Substr(v_Adrstmp, 1, n_Pos - 1);
    v_Adrstmp := Substr(v_Adrstmp, n_Pos + 1);
    n_Pos     := Instr(v_Adrstmp, ',');
    v_区县    := Substr(v_Adrstmp, 1, n_Pos - 1);
    v_Adrstmp := Substr(v_Adrstmp, n_Pos + 1);
    n_Pos     := Instr(v_Adrstmp, ',');
    v_乡镇    := Substr(v_Adrstmp, 1, n_Pos - 1);
    v_街道    := Substr(v_Adrstmp, n_Pos + 1);
    Select Max(编码) Into v_Code省 From 区域 Where 名称 = v_省 And Nvl(级数, 0) = 0;
    --省级地址都没有，就不做处理
    If v_Code省 Is Not Null Then
      Select Max(编码), Max(是否虚拟), Max(是否不显示)
      Into v_Code市, n_虚拟, n_不显示
      From 区域
      Where 名称 = v_市 And Nvl(级数, 0) = 1 And 上级编码 = v_Code省;
      If v_Code市 Is Not Null Then
        v_Info市 := v_市 || ',' || v_Code市 || ',' || n_虚拟 || ',' || n_不显示;
        Select Max(编码), Max(是否虚拟), Max(是否不显示)
        Into v_Code区县, n_虚拟, n_不显示
        From 区域
        Where 名称 = v_区县 And Nvl(级数, 0) = 2 And 上级编码 = v_Code市;
        --可能是虚拟地址
      Else
        Select Max(编码), Max(上级编码)
        Into v_Code区县, v_Code市
        From 区域
        Where 名称 = v_区县 And Nvl(级数, 0) = 2 And 上级编码 In (Select 编码 From 区域 Where 上级编码 = v_Code省);
        If v_Code市 Is Not Null Then
          Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示)
          Into v_市, v_Code市, n_虚拟, n_不显示
          From 区域
          Where 编码 = v_Code市;
        End If;
        v_Info市 := v_市 || ',' || v_Code市 || ',' || n_虚拟 || ',' || n_不显示;
        Select Max(编码), Max(是否虚拟), Max(是否不显示)
        Into v_Code区县, n_虚拟, n_不显示
        From 区域
        Where 编码 = v_Code区县;
      End If;
      v_Info区县 := v_区县 || ',' || v_Code区县 || ',' || n_虚拟 || ',' || n_不显示;
      If v_Code区县 Is Not Null Then
        --可能乡镇在详细地址中，关联参数乡镇地址结构化录入
        If v_乡镇 Is Null And Not v_街道 Is Null Then
          --先截取乡镇级的两个字做关键字，来匹配
          v_Tmp := Substr(v_街道, 1, 2);
          Select Max(名称)
          Into v_乡镇
          From 区域
          Where 名称 Like v_Tmp || '%' And Nvl(级数, 0) = 3 And 上级编码 = v_Code区县;
          --存在多行匹配，则继续增加长度，暂时从2个字增加到3个字匹配
          If n_Count > 1 Then
            v_Tmp := Substr(v_街道, 1, 3);
            Select Max(名称)
            Into v_乡镇
            From 区域
            Where 名称 Like v_Tmp || '%' And Nvl(级数, 0) = 3 And 上级编码 = v_Code区县;
          End If;
          If Not v_乡镇 Is Null Then
            v_街道 := Substr(v_街道, Length(v_乡镇) + 1);
          End If;
        End If;
        Select Max(编码), Max(是否虚拟), Max(是否不显示)
        Into v_Code乡镇, n_虚拟, n_不显示
        From 区域
        Where 名称 = v_乡镇 And Nvl(级数, 0) = 3 And 上级编码 = v_Code区县;
        --可能是虚拟地址
        If v_Code乡镇 Is Null Then
          Select Max(编码), Max(上级编码)
          Into v_Code街道, v_Code乡镇
          From 区域
          Where 名称 = v_街道 And Nvl(级数, 0) = 4 And 上级编码 In (Select 编码 From 区域 Where 上级编码 = v_Code区县);
          If v_Code乡镇 Is Not Null Then
            Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示)
            Into v_乡镇, v_Code乡镇, n_虚拟, n_不显示
            From 区域
            Where 编码 = v_Code乡镇;
          End If;
        End If;
        v_Info乡镇 := v_乡镇 || ',' || v_Code乡镇 || ',' || n_虚拟 || ',' || n_不显示;
        If v_Code乡镇 Is Not Null Then
          Select Max(编码), Max(是否虚拟), Max(是否不显示)
          Into v_Code街道, n_虚拟, n_不显示
          From 区域
          Where 名称 = v_街道 And Nvl(级数, 0) = 4 And 上级编码 = v_Code乡镇;
          v_Info街道 := v_街道 || ',' || v_Code街道 || ',' || n_虚拟 || ',' || n_不显示;
        End If;
      End If;
    End If;
    --非标准地址，是完整地址，需要分割省，市，县,
  Else
    v_Adrstmp := v_Addressinfo;
    v_Tmp     := Substr(v_Adrstmp, 1, 2);
    Select Max(名称), Max(编码) Into v_省, v_Code省 From 区域 Where 名称 Like v_Tmp || '%' And Nvl(级数, 0) = 0;
    --有省级地址，说明可以结构化
    If v_Code省 Is Not Null Then
      --省级地址是标准的
      If Substr(v_Adrstmp, 1, Length(v_省)) = v_省 Then
        v_Adrstmp := Substr(v_Adrstmp, Length(v_省) + 1);
        --省级地址不标准,可能新疆省略自治区等,此时，市级地址可能是标准化的。
      Else
        --先判断二级地址是否存在虚拟地址与不显示的地址
        If v_Tmp = '内蒙' Then
          v_Tmp := '内蒙古';
        Elsif v_Tmp = '黑龙' Then
          v_Tmp := '黑龙江';
        End If;
        v_Adrstmp := Substr(v_Adrstmp, Length(v_Tmp) + 1);
      End If;
      --先截取市级的两个字做关键字，来匹配
      v_Tmp := Substr(v_Adrstmp, 1, 2);
      Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示), Count(1)
      Into v_市, v_Code市, n_虚拟, n_不显示, n_Count
      From 区域
      Where 名称 Like v_Tmp || '%' And Nvl(级数, 0) = 1 And 上级编码 = v_Code省;
      --存在多行匹配，则继续增加长度，暂时从2个字增加到3个字匹配
      If n_Count > 1 Then
        v_Tmp := Substr(v_Adrstmp, 1, 3);
        Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示)
        Into v_市, v_Code市, n_虚拟, n_不显示
        From 区域
        Where 名称 Like v_Tmp || '%' And Nvl(级数, 0) = 1 And 上级编码 = v_Code省;
      End If;
      --判断是否存在虚拟地址或不显示的地址导致的,如果存在，则根据第三级地址来确定虚拟地址
      If v_Code市 Is Null Then
        Select Max(是否虚拟), Max(是否不显示) Into n_虚拟, n_不显示 From 区域 Where 上级编码 = v_Code省;
        If Nvl(n_虚拟, 0) = 1 Or Nvl(n_不显示, 0) = 1 Then
          Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示), Count(1), Max(上级编码)
          Into v_区县, v_Code区县, n_虚拟, n_不显示, n_Count, v_Code市
          From 区域
          Where 名称 Like v_Tmp || '%' And Nvl(级数, 0) = 2 And 上级编码 In (Select 编码 From 区域 Where 上级编码 = v_Code省);
          --存在多行匹配，则继续增加长度，暂时从2个字增加到3个字匹配
          If n_Count > 1 Then
            v_Tmp := Substr(v_Adrstmp, 1, 3);
            Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示), Max(上级编码)
            Into v_区县, v_Code区县, n_虚拟, n_不显示, v_Code市
            From 区域
            Where 名称 Like v_Tmp || '%' And Nvl(级数, 0) = 2 And 上级编码 In (Select 编码 From 区域 Where 上级编码 = v_Code省);
          End If;
          If v_Code市 Is Not Null Then
            v_Info区县 := v_区县 || ',' || v_Code区县 || ',' || n_虚拟 || ',' || n_不显示;
            v_Adrstmp  := Substr(v_Adrstmp, Length(v_区县) + 1);
            Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示)
            Into v_市, v_Code市, n_虚拟, n_不显示
            From 区域
            Where 编码 = v_Code市;
            v_Info市 := v_市 || ',' || v_Code市 || ',' || n_虚拟 || ',' || n_不显示;
          End If;
        End If;
      Else
        v_Info市  := v_市 || ',' || v_Code市 || ',' || n_虚拟 || ',' || n_不显示;
        v_Adrstmp := Substr(v_Adrstmp, Length(v_市) + 1);
      End If;
      --没有区县，则解析区县
      If Not v_Code市 Is Null And v_Code区县 Is Null Then
        --先截取县级的两个字做关键字，来匹配
        v_Tmp := Substr(v_Adrstmp, 1, 2);
        Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示), Count(1)
        Into v_区县, v_Code区县, n_虚拟, n_不显示, n_Count
        From 区域
        Where 名称 Like v_Tmp || '%' And Nvl(级数, 0) = 2 And 上级编码 = v_Code市;
        --存在多行匹配，则继续增加长度，暂时从2个字增加到3个字匹配
        If n_Count > 1 Then
          v_Tmp := Substr(v_Adrstmp, 1, 3);
          Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示)
          Into v_区县, v_Code区县, n_虚拟, n_不显示
          From 区域
          Where 名称 Like v_Tmp || '%' And Nvl(级数, 0) = 2 And 上级编码 = v_Code市;
        End If;
        If v_Code区县 Is Null Then
          Select Max(是否虚拟), Max(是否不显示) Into n_虚拟, n_不显示 From 区域 Where 上级编码 = v_Code市;
          If Nvl(n_虚拟, 0) = 1 Or Nvl(n_不显示, 0) = 1 Then
            Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示), Count(1), Max(上级编码)
            Into v_乡镇, v_Code乡镇, n_虚拟, n_不显示, n_Count, v_Code区县
            From 区域
            Where 名称 Like v_Tmp || '%' And Nvl(级数, 0) = 3 And 上级编码 In (Select 编码 From 区域 Where 上级编码 = v_Code市);
            --存在多行匹配，则继续增加长度，暂时从2个字增加到3个字匹配
            If n_Count > 1 Then
              v_Tmp := Substr(v_Adrstmp, 1, 3);
              Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示), Max(上级编码)
              Into v_乡镇, v_Code乡镇, n_虚拟, n_不显示, v_Code区县
              From 区域
              Where 名称 Like v_Tmp || '%' And Nvl(级数, 0) = 3 And 上级编码 In (Select 编码 From 区域 Where 上级编码 = v_Code市);
            End If;
          
            If v_Code乡镇 Is Not Null Then
              v_Info乡镇 := v_乡镇 || ',' || v_Code乡镇 || ',' || n_虚拟 || ',' || n_不显示;
              v_Adrstmp  := Substr(v_Adrstmp, Length(v_乡镇) + 1);
              Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示)
              Into v_区县, v_Code区县, n_虚拟, n_不显示
              From 区域
              Where 编码 = v_Code区县;
              v_Info区县 := v_区县 || ',' || v_Code区县 || ',' || n_虚拟 || ',' || n_不显示;
            End If;
          End If;
        Else
          v_Info区县 := v_区县 || ',' || v_Code区县 || ',' || n_虚拟 || ',' || n_不显示;
          v_Adrstmp  := Substr(v_Adrstmp, Length(v_区县) + 1);
        End If;
      End If;
      If v_Code区县 Is Not Null And v_Code乡镇 Is Null Then
        --先截取乡镇级的两个字做关键字，来匹配
        v_Tmp := Substr(v_Adrstmp, 1, 2);
        Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示), Count(1)
        Into v_乡镇, v_Code乡镇, n_虚拟, n_不显示, n_Count
        From 区域
        Where 名称 Like v_Tmp || '%' And Nvl(级数, 0) = 3 And 上级编码 = v_Code区县;
        --存在多行匹配，则继续增加长度，暂时从2个字增加到3个字匹配
        If n_Count > 1 Then
          v_Tmp := Substr(v_Adrstmp, 1, 3);
          Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示), Count(1)
          Into v_乡镇, v_Code乡镇, n_虚拟, n_不显示, n_Count
          From 区域
          Where 名称 Like v_Tmp || '%' And Nvl(级数, 0) = 3 And 上级编码 = v_Code区县;
        End If;
        If v_Code乡镇 Is Null Then
          Select Max(是否虚拟), Max(是否不显示) Into n_虚拟, n_不显示 From 区域 Where 上级编码 = v_Code区县;
          If Nvl(n_虚拟, 0) = 1 Or Nvl(n_不显示, 0) = 1 Then
            Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示), Count(1), Max(上级编码)
            Into v_街道, v_Code街道, n_虚拟, n_不显示, n_Count, v_Code乡镇
            From 区域
            Where 名称 = v_Adrstmp And 上级编码 In (Select 编码 From 区域 Where 上级编码 = v_Code区县);
          End If;
          If v_Code乡镇 Is Not Null Then
            v_Info街道 := v_街道 || ',' || v_Code街道 || ',' || n_虚拟 || ',' || n_不显示;
            Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示)
            Into v_乡镇, v_Code乡镇, n_虚拟, n_不显示
            From 区域
            Where 编码 = v_Code乡镇;
            v_Info乡镇 := v_乡镇 || ',' || v_Code乡镇 || ',' || n_虚拟 || ',' || n_不显示;
          End If;
        Else
          v_Info乡镇 := v_乡镇 || ',' || v_Code乡镇 || ',' || n_虚拟 || ',' || n_不显示;
          v_Adrstmp  := Substr(v_Adrstmp, Length(v_乡镇) + 1);
        End If;
        If v_Code乡镇 Is Not Null And v_Code街道 Is Null Then
          Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示)
          Into v_街道, v_Code街道, n_虚拟, n_不显示
          From 区域
          Where 名称 = v_Adrstmp And Nvl(级数, 0) = 4 And 上级编码 = v_Code乡镇;
          If v_Code街道 Is Not Null Then
            v_Info街道 := v_街道 || ',' || v_Code街道 || ',' || n_虚拟 || ',' || n_不显示;
          End If;
        End If;
      End If;
    End If;
    If v_街道 Is Null Then
      v_街道 := v_Adrstmp;
    End If;
  End If;
  v_Info省 := v_省 || ',' || v_Code省 || ',,,';
  If v_Info市 Is Null Then
    v_Info市 := v_市 || ',,,';
  End If;
  --只有省没有市，判断市是否只有虚拟级
  If Not v_Code省 Is Null And v_市 Is Null Then
    Select Count(1)
    Into n_Count
    From 区域
    Where 上级编码 = v_Code省 And Nvl(是否虚拟, 0) = 0 And Nvl(是否不显示, 0) = 0 And Rownum < 2;
    If n_Count = 0 Then
      Select Count(1) Into n_Count From 区域 Where 上级编码 = v_Code省 And Rownum < 2;
      If n_Count = 0 Then
        v_Info市 := v_Info市 || ',';
      Else
        v_Info市 := v_Info市 || ',1';
      End If;
    Else
      v_Info市 := v_Info市 || ',';
    End If;
  Else
    v_Info市 := v_Info市 || ',';
  End If;
  If v_Info区县 Is Null Then
    v_Info区县 := v_区县 || ',,,';
  End If;
  --只有市没有区县，判断区县只有虚拟级
  If Not v_Code市 Is Null And v_区县 Is Null Then
    Select Count(1)
    Into n_Count
    From 区域
    Where 上级编码 = v_Code市 And Nvl(是否虚拟, 0) = 0 And Nvl(是否不显示, 0) = 0 And Rownum < 2;
    If n_Count = 0 Then
      Select Count(1) Into n_Count From 区域 Where 上级编码 = v_Code市 And Rownum < 2;
      If n_Count = 0 Then
        v_Info区县 := v_Info区县 || ',';
      Else
        v_Info区县 := v_Info区县 || ',1';
      End If;
    Else
      v_Info区县 := v_Info区县 || ',';
    End If;
  Else
    v_Info区县 := v_Info区县 || ',';
  End If;
  If v_Info乡镇 Is Null Then
    v_Info乡镇 := v_乡镇 || ',,,';
  End If;
  --只有区县没有乡镇，判断乡镇是否只有虚拟的下级
  If Not v_Code区县 Is Null And v_乡镇 Is Null Then
    Select Count(1)
    Into n_Count
    From 区域
    Where 上级编码 = v_Code区县 And Nvl(是否虚拟, 0) = 0 And Nvl(是否不显示, 0) = 0 And Rownum < 2;
    If n_Count = 0 Then
      Select Count(1) Into n_Count From 区域 Where 上级编码 = v_Code区县 And Rownum < 2;
      If n_Count = 0 Then
        v_Info乡镇 := v_Info乡镇 || ',';
      Else
        v_Info乡镇 := v_Info乡镇 || ',1';
      End If;
    Else
      v_Info乡镇 := v_Info乡镇 || ',';
    End If;
  Else
    v_Info乡镇 := v_Info乡镇 || ',';
  End If;
  If v_Info街道 Is Null Then
    v_Info街道 := v_街道 || ',,,,';
  Else
    v_Info街道 := v_Info街道 || ',';
  End If;
  v_Return := v_Info省 || '|' || v_Info市 || '|' || v_Info区县 || '|' || v_Info乡镇 || '|' || v_Info街道;
  Return(v_Return);
End;
/

--89666:许华峰,2015-12-03,显示报告创建时间和审核时间
--影像报告业务(---定义部分---)***************************************************
CREATE OR REPLACE Package b_PACS_RptManage Is
  Type t_Refcur Is Ref Cursor;

  --1、锁定报告人
  Procedure p_Edit_Doc_Lockinfo(
    报告_Id_In 影像报告记录.Id%Type,
	锁定人_In  影像报告记录.锁定人%Type
	);

  --2、评定报告质量
  Procedure p_Edit_Doc_EvaluatRptQuality(
    报告Id_In 影像报告记录.Id%Type,
	质量等级_In 影像报告记录.报告质量%Type
	);
                                
  --3、评定阴阳性
  Procedure p_Edit_Doc_EvaluatResult(
    报告Id_In 影像报告记录.Id%Type,
	检查结果_In 影像报告记录.结果阳性%Type
	);
                                
  --4、报告发放/回收
  Procedure p_Edit_Doc_ReportRelease(
    报告Id_In 影像报告记录.Id%Type,
	当前操作人_In 影像报告记录.报告发放人%Type
	);

 --5、新增，修改报告
  Procedure p_影像报告记录_新增(
    原型ID_In     影像报告记录.原型ID%Type,
    报告内容_In   影像报告记录.报告内容%Type,
    记录人_In     影像报告记录.记录人%Type,
    最后编辑人_In 影像报告记录.最后编辑人%Type,
    Id_In         影像报告记录.Id%Type,
    医嘱ID_In     影像报告记录.医嘱ID%Type 
	);

  --6、获取书写的文档内容
  Procedure p_Get_Doc_Content(
    Val           Out t_Refcur,
	DocID_In 影像报告记录.Id%Type
	);

  --7、设置报告打印作废信息
  Procedure p_Checkrejectsignature(Signdate_In Date,
                                   报告ID_In   影像报告操作记录.报告Id%Type,
                                   作废人_In   影像报告操作记录.作废人%Type,
                                   作废说明_In 影像报告操作记录.作废说明%Type,
                                   Val         Out Sys_Refcursor);

  --8、查询相应原型下的最大序号
  Procedure p_Get_Samplelist_Maxseqnum(
    Val           Out t_Refcur,
	原型ID_In 影像报告范文清单.原型ID%Type
	);

  --9、删除文档范文
  Procedure p_Del_影像报告范文清单(
    Id_In 影像报告范文清单.Id%Type
	);

 --10、添加文档的操作日志
 Procedure p_影像报告操作记录_Add(Id_In       影像报告操作记录.Id%Type,
                               报告ID_In   影像报告操作记录.报告ID%Type,                               
                               操作人_In   影像报告操作记录.操作人%Type,                               
                               操作类型_In 影像报告操作记录.操作类型%Type);

  --11、删除报告
  Procedure p_影像报告记录_删除(
    报告_Id_In 影像报告记录.Id%Type
	);

  --12、获取签名类型
  Procedure p_Get_SysConfigSignature(
    Val           Out t_Refcur,
	科室ID_In		In 部门表.ID%Type
	);

--13、获取账户签名印章
Procedure p_Get_PersonSignImg(
  Val           Out t_Refcur,
  ID_In		In 人员表.ID%Type
  );


--14、获取签名的证书信息
Procedure p_Get_SignCertInfo(
  Val           Out t_Refcur,
  证书ID_In		人员证书记录.ID%Type
  );

--15、更新报告状态
Procedure p_Update_ReportState(
  报告Id_In  影像报告记录.ID%Type,
  报告状态_In  影像报告记录.报告状态%Type,
  审核人_In   影像报告记录.最后审核人%Type
  );

--16、获取报告状态
Procedure p_Get_ReportState(
  Val           Out t_Refcur,
  报告Id_In	影像报告记录.ID%Type
  );

--17、报告驳回
Procedure p_Reject_Report(
  医嘱ID_In	影像报告驳回.医嘱ID%Type, 
  报告ID_In	影像报告驳回.检查报告ID%Type, 
  驳回理由_In 影像报告驳回.驳回理由%Type, 
  驳回时间_In 影像报告驳回.驳回时间%Type, 
  驳回人_In   影像报告驳回.驳回人%Type,
  待处理人_In  影像报告记录.待处理人%Type,
  报告状态_In 影像报告记录.报告状态%Type
  );

--17.1、撤销报告驳回
Procedure p_Reject_Cancel(
  ID_In       影像报告驳回.ID%Type,
  报告ID_In    影像报告驳回.检查报告ID%Type,
  报告状态_In   影像报告记录.报告状态%Type
  );

--18、获取报告驳回信息
Procedure p_Get_RejectInfo(
  Val           Out t_Refcur,
  报告ID_In	影像报告驳回.检查报告ID%Type
  );

--19、获取原型动作
Procedure p_Get_Doc_Process(
  Val           Out t_Refcur,
  原型id_In 影像报告动作.原型id%Type
  );

--20、通过学科筛选获得相应的范文信息
  Procedure p_Get_Samplelist_By_Conditions(
    Val           Out t_Refcur,
    原型id_In       Varchar2,
    学科_In  Varchar2,
    Condition_In Varchar2, --过滤筛选
    作者_In    Varchar2
    );

  --21、通过部门ID获取部门名称
  Procedure p_Get_部门名称_By_ID(
    Val           Out t_Refcur,
    ID_IN 部门表.ID%TYPE
    );

  --22、提取所有预备提纲
  Procedure p_Get_AllPreOutlines(
    Val           Out t_Refcur
    );

  --23、提取文档标题
  Procedure p_Get_reportTitle_By_ID(
    Val           Out t_Refcur,
    ID_IN  影像报告记录.id%TYPE   
    );
  
  --24、提取报告锁定人
  Procedure p_Get_报告锁定人_By_ID(
    Val           Out t_Refcur,
    ID_IN  影像报告记录.id%TYPE   
    );

  --25、通过医嘱ID获取报告列表
  Procedure p_Get_影像报告记录_By_医嘱ID(
    Val           Out t_Refcur,
    医嘱ID_IN  影像报告记录.医嘱ID%TYPE   
    );
  
  --26、查询影像流程参数值
  Procedure p_Get_影像流程参数值(
    Val           Out t_Refcur,  
    科室ID_IN  影像流程参数.科室ID%TYPE
    );

  --27、根据医嘱ID，查询对应的原型列表
  Procedure p_Get_影像原型列表_By_医嘱ID(
    Val           Out t_Refcur,
    医嘱_IN  影像检查记录.医嘱ID%TYPE   
    );

  --28、根据报告ID查询打印记录
  procedure p_Get_ReportPrintLog_By_报告ID
  (
       val out sys_refcursor  ,
       报告_IN  影像报告操作记录.报告ID%TYPE
  );

  --29、根据医嘱ID查询报告发放列表
  Procedure p_Get_ReportReleaseList(
    Val           Out t_Refcur,
    医嘱_IN  影像报告记录.医嘱ID%TYPE   
    );

  --30、根据报告ID查询驳回记录数量
  Procedure p_Get_RejectedCount(
    Val           Out t_Refcur,
    报告_IN  影像报告驳回.检查报告ID%TYPE
    );

  --31、根据医嘱ID查询报告动作需要的一些ID们
  Procedure p_Get_DocProcess_IDs(
    Val           Out t_Refcur,
    医嘱_IN  病人医嘱记录.ID%TYPE
    );

  --32、根据医嘱ID和报告ID查询报告的一些参数
  Procedure p_Get_DocInfo(
    Val           Out t_Refcur,
    医嘱ID_IN  影像检查记录.医嘱ID%TYPE,
    报告ID_IN  影像报告记录.ID%TYPE
    );
  
  --33、查询一个检查中相同原型ID的报告数量
   Procedure p_Get_SameAntetypeDocCounts(
       Val           Out t_Refcur,
       医嘱ID_IN  影像报告记录.医嘱ID%TYPE,
       原型ID_IN  影像报告记录.原型ID%TYPE
  );

  --34、提取报告图存储信息
  Procedure p_Get_DocImageSaveInof_By_ID(
    Val           Out t_Refcur,
	  ID_IN  影像报告记录.id%TYPE
    );

end b_PACS_RptManage;
/

--影像报告业务(---实现部分---)***************************************************

CREATE OR REPLACE Package Body b_PACS_RptManage Is

  --1、锁定报告人
  Procedure p_Edit_Doc_Lockinfo(
    报告_Id_In 影像报告记录.Id%Type,
	锁定人_In  影像报告记录.锁定人%Type
	) Is
  Begin
  
    --  报告ID为空，则清空所有“锁定人_In”正在锁定的标记
    If 报告_Id_In Is Null Then
      Update 影像报告记录 A Set a.锁定人 = '' Where a.锁定人 = 锁定人_In;
    Else
      Update 影像报告记录 A
         Set a.锁定人 = 锁定人_In
       Where a.Id = 报告_Id_In;
    End If;
  
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Doc_Lockinfo;

  --2、评定报告质量
  Procedure p_Edit_Doc_EvaluatRptQuality(
    报告Id_In 影像报告记录.Id%Type,
	质量等级_In  影像报告记录.报告质量%Type
	) Is
  Begin
    Update 影像报告记录 Set 报告质量 = 质量等级_In Where Id = 报告Id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Doc_EvaluatRptQuality;
  
  --3、评定阴阳性
  Procedure p_Edit_Doc_EvaluatResult(
    报告Id_In 影像报告记录.Id%Type,
	检查结果_In 影像报告记录.结果阳性%Type
	) Is
  Begin
     Update 影像报告记录 Set 结果阳性 = 检查结果_In Where Id = 报告Id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Doc_EvaluatResult;
  
  --4、报告发放/回收
  Procedure p_Edit_Doc_ReportRelease(
    报告Id_In 影像报告记录.Id%Type,
	当前操作人_In 影像报告记录.报告发放人%Type
	) Is
    v_报告发放     影像报告记录.报告发放%Type; 
  Begin
    
    Begin 
		  Select nvl(报告发放,0) Into v_报告发放 From 影像报告记录 where ID=报告Id_In; 
    Exception 
      When Others Then 
        v_报告发放 :=0; 
    End; 
     
    Update 影像报告记录 Set 报告发放 =decode(v_报告发放,0,1,0),报告发放人=decode(v_报告发放,0,当前操作人_In,'') Where ID=报告Id_In; 
     
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Doc_ReportRelease; 

 --5、新增，修改报告
  Procedure p_影像报告记录_新增(
    原型ID_In     影像报告记录.原型ID%Type,
    报告内容_In   影像报告记录.报告内容%Type,
    记录人_In     影像报告记录.记录人%Type,
    最后编辑人_In 影像报告记录.最后编辑人%Type,
    Id_In         影像报告记录.Id%Type,
    医嘱ID_In     影像报告记录.医嘱ID%Type
  ) As
    --原型ID_In 原型ID
    --保存文档书写记录
    --1 处理匿名数据
    --2 保存文档书写记录、状态
    --3 处理编辑日志
    --4 更新文档任务
    v_报告id    影像报告记录.Id%Type;
    v_原型名称  影像报告原型清单.名称%Type;
    v_设备号    影像报告原型清单.设备号%Type;
    v_报告序号  number;
    x_Editlog   Xmltype;
    Cur_Time    Date;
    To_Editlist t_Editlist;
    Tn_Editlist t_Editlist;
    v_Msg       Varchar2(200);
    v_New       number;
    Err_Custom  Exception;
    v_Result    影像报告记录.诊断意见%Type;
    v_操作ID    影像报告操作记录.ID%Type;

    Function Elist_Filter(
    Source_t t_Editlist
    ) Return t_Editlist Is
      Target_t t_Editlist := t_Editlist();
    Begin

      --对独立文档来说，这个函数只是将 Source_t按照编辑时间排序后输出
      For Rs In (Select /*+rule*/
                  *
                   From Table(Cast(Source_t As t_Editlist)) A
                  Order By a.编辑时间) Loop
        Target_t.Extend;
        Target_t(Target_t.Count) := t_Edits(Rs.编辑人,
                                            Rs.编辑时间,
                                            Rs.签名,
                                            Rs.审订签名);
      End Loop;
      Return Target_t;
    End;

    Function Build_Editlog(
    Tn_Edit t_Editlist,
    To_Edit t_Editlist,
    v_Did   影像报告记录.Id%Type) Return Xmltype Is
      --Tn_Edit 本次保存的新编辑记录；To_Edit上次保存的旧编辑记录
      --将两次编辑记录，组合成一个编辑记录

      x_Return Xmltype;
      r_Saveid Raw(16);
      n_Class  Number;
      --n_Class 编辑日志中的操作类别： 1-创建、2-删除、3-编辑、4-签名、5-审订、6-审签、7-撤签
      v_Signor  影像报告记录.创建人%Type;
      v_Adjunct 影像报告记录.创建人%Type;
      Tns_Edit  t_Editlist;
      Tos_Edit  t_Editlist;

      Function Atitle(原型ID 影像报告原型清单.Id%Type) Return Varchar2 Is
        v_原型名称 影像报告原型清单.名称%Type;
      Begin
        --根据原型ID，返回原型名称
        If 原型ID Is Null Then
          Return Null;
        Else
          Select 名称 Into v_原型名称 From 影像报告原型清单 Where ID = 原型ID;
          Return v_原型名称;
        End If;
      End;

    Begin
      x_Return := Xmltype('<root></root>');
      If v_Did Is Null Then
        --表明是新增文档，新增文档传null进来
        Select Sys_Guid() Into r_Saveid From Dual;

        --PACS报告没有子文档，但是下面构造XML的语句保留成跟EMR相同，这里的v_Subiid赋值为空
        Tns_Edit := Elist_Filter(Tn_Edit);
        Select Decode(Tns_Edit(Tns_Edit.Count).签名, 0, 1, 4)
          Into n_Class
          From Dual;
        Select Appendchildxml(x_Return,
                              '/root',
                              Xmlelement("operate",
                                         Xmlforest(r_Saveid As "saving_id",
                                                   n_Class As "class",
                                                   To_Char(Cur_Time,
                                                           'yyyy-mm-dd hh24:mi:ss') As
                                                   "cur_time",
                                                   最后编辑人_In As "operator",
                                                   Decode(n_Class,
                                                          4,
                                                          Tns_Edit(Tns_Edit.Count).编辑人,
                                                          '') As "signer",
                                                   '' As Adjunct)))
          Into x_Return
          From Dual;
      Else
        --不是新增的文档？
        Select Sys_Guid() Into r_Saveid From Dual;

        v_Signor  := '';
        v_Adjunct := '';
        Tns_Edit  := Elist_Filter(Tn_Edit);
        Tos_Edit  := Elist_Filter(To_Edit);
        If Tns_Edit(Tns_Edit.Count)
         .签名 = 1 And Tns_Edit(Tns_Edit.Count).审订签名 = 0 Then
          --最近一次是签名
          If Tos_Edit.Count = 0 Then
            --新增子文档直接签名
            n_Class  := 4;
            v_Signor := Tns_Edit(Tns_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count).编辑人 Is Null Then
            --之前没签名
            n_Class  := 4;
            v_Signor := Tns_Edit(Tns_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count)
           .签名 = 1 And Tns_Edit(Tns_Edit.Count)
                .编辑时间 > Tos_Edit(Tos_Edit.Count).编辑时间 Then
            --多次普通签名
            n_Class  := 4;
            v_Signor := Tns_Edit(Tns_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count)
           .签名 = 1 And Tns_Edit(Tns_Edit.Count)
                .编辑时间 < Tos_Edit(Tos_Edit.Count).编辑时间 Then
            --撤消多次签名
            n_Class   := 7;
            v_Adjunct := Tos_Edit(Tos_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count)
           .签名 = 1 And Tns_Edit(Tns_Edit.Count)
                .编辑时间 = Tos_Edit(Tos_Edit.Count).编辑时间 Then
            --无变化
            n_Class := -1;
          End If;
        Elsif Tns_Edit(Tns_Edit.Count)
         .签名 = 1 And Tns_Edit(Tns_Edit.Count).审订签名 = 1 Then
          --审订签名
          If Tos_Edit(Tos_Edit.Count).审订签名 = 0 Then
            --之前没审签，可能是已签名或已审订
            n_Class  := 6;
            v_Signor := Tns_Edit(Tns_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count)
           .审订签名 = 1 And Tns_Edit(Tns_Edit.Count)
                .编辑时间 > Tos_Edit(Tos_Edit.Count).编辑时间 Then
            --多次审签
            n_Class  := 6;
            v_Signor := Tns_Edit(Tns_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count)
           .审订签名 = 1 And Tns_Edit(Tns_Edit.Count)
                .编辑时间 < Tos_Edit(Tos_Edit.Count).编辑时间 Then
            --撤消多次审签
            n_Class   := 7;
            v_Adjunct := Tos_Edit(Tos_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count)
           .审订签名 = 1 And Tns_Edit(Tns_Edit.Count)
                .编辑时间 = Tos_Edit(Tos_Edit.Count).编辑时间 Then
            --无变化
            n_Class := -1;
          End If;
        Elsif Tns_Edit(Tns_Edit.Count).编辑人 Is Null And Tos_Edit.Count = 0 Then
          n_Class := 1;
        Elsif Tns_Edit(Tns_Edit.Count)
         .编辑人 Is Null And Tos_Edit(Tos_Edit.Count).签名 = 1 Then
          n_Class   := 7;
          v_Adjunct := Tos_Edit(Tos_Edit.Count).编辑人;
        Elsif Tns_Edit(Tns_Edit.Count)
         .编辑人 Is Null And Tos_Edit(Tos_Edit.Count).编辑人 Is Null Then
          n_Class := 3;
        Elsif Tns_Edit(Tns_Edit.Count)
         .审订签名 = 0 And Tos_Edit(Tos_Edit.Count).审订签名 = 0 Then
          n_Class := 5;
        Elsif Tns_Edit(Tns_Edit.Count)
         .审订签名 = 0 And Tos_Edit(Tos_Edit.Count).审订签名 = 1 Then
          n_Class   := 7;
          v_Adjunct := Tos_Edit(Tos_Edit.Count).编辑人;
        End If;

        If n_Class <> -1 Then
          Select Appendchildxml(x_Return,
                                '/root',
                                Xmlelement("operate",
                                           Xmlforest(r_Saveid As "saving_id",
                                                     n_Class As "class",
                                                     To_Char(Cur_Time,
                                                             'yyyy-mm-dd hh24:mi:ss') As
                                                     "cur_time",
                                                     最后编辑人_In As "operator",
                                                     Decode(n_Class,
                                                            4,
                                                            v_Signor,
                                                            6,
                                                            v_Signor,
                                                            '') As "signer",
                                                     v_Adjunct As Adjunct)))
            Into x_Return
            From Dual;
        End If;

      End If;
      Return x_Return;
    End Build_Editlog;

    Function Get_NextRPTNum(
    AntetypeName 影像报告原型清单.名称%Type,
    Order_ID 影像报告记录.医嘱Id%Type
    )
      Return Number Is
        v_序号 Number;
        v_count Number;
        v_num Number;
      Begin

        v_count :=0;
        v_num :=1;
        loop
             select count(*)+v_num into v_序号 from 影像报告记录 where 医嘱ID=Order_ID;
             select count(*) into v_count from 影像报告记录 where 医嘱ID=Order_ID and 文档标题=AntetypeName||'_'||v_序号;

             if v_count =0 then
               exit;
             end if;

             v_num := v_num +1;
         end loop;

         return v_序号;
     End;

  Begin

    Select 名称, 设备号,Sysdate
      Into v_原型名称,v_设备号, Cur_Time
      From 影像报告原型清单
     Where ID = 原型ID_In;

    --------------------1 保存文档书写记录、状态--------------------
    --提取文档的签名和编辑（新增、修改）记录
    Tn_Editlist := b_PACS_RptPublic.f_Geteditlist(报告内容_In);

    --------------------2 处理编辑日志--------------------
    select count(*) into v_New from 影像报告记录 where ID=Id_In;

    v_报告id := Id_In;
    select zlpub_pacs_取提纲内容byxml (报告内容_In,'诊断意见') into v_Result from dual;
    If v_New=0 Then
      --新增报告
      To_Editlist := t_Editlist();
      x_Editlog   := Build_Editlog(Tn_Editlist, To_Editlist, Null);

      --取报告序号
      v_报告序号 := Get_NextRPTNum(v_原型名称,医嘱ID_In);

      Insert Into 影像报告记录
        (ID,
         原型ID,
         文档标题,
         报告内容,
         创建时间,
         创建人,
         报告状态,
         最后编辑时间,
         最后编辑人,
         编辑日志,
         医嘱ID,
         记录人,
         诊断意见,
         设备号)
      Values
        (v_报告id,
         原型ID_In,
         v_原型名称||'_'||v_报告序号,
         报告内容_In,
         Cur_Time,
         最后编辑人_In,
         1,
         Cur_Time,
         最后编辑人_In,
         x_Editlog,
         医嘱ID_In,
         记录人_In,
         v_Result,
         v_设备号);
      Insert Into 病人医嘱报告(医嘱ID,检查报告ID)Values(医嘱ID_In,v_报告id);
      
      Select Sys_Guid() Into v_操作ID From Dual;
      Insert Into 影像报告操作记录(ID, 报告ID,医嘱ID,文档标题,操作人,操作时间,操作类型) 
             Values(v_操作ID,v_报告id,医嘱ID_In,v_原型名称||'_'||v_报告序号,最后编辑人_In,sysdate,6);

    Else
      --提取文件原始编辑记录,必需在更新之前提取
      Select b_PACS_RptPublic.f_Geteditlist(报告内容)
        Into To_Editlist
        From 影像报告记录
       Where ID = v_报告id;

      x_Editlog := Build_Editlog(Tn_Editlist, To_Editlist, v_报告id);
      Select Appendchildxml(编辑日志,
                            '/root',
                            Extract(x_Editlog, '/root/*'))
             Into x_Editlog From 影像报告记录 Where ID = v_报告id;

       Update 影像报告记录
                Set 报告内容     = 报告内容_In,
                最后编辑时间 = Cur_Time,
                最后编辑人   = 最后编辑人_In,
                编辑日志     = x_Editlog,
                记录人       =记录人_In,
                诊断意见     =v_Result
                Where ID = v_报告id;
       end if;

  Exception
    When Err_Custom Then
      Raise_Application_Error(-20101, v_Msg);
    When Others Then
      Zl_Errorcenter(SQLCode, SQLErrM);
  End p_影像报告记录_新增;

  --6、获取书写的文档内容
  Procedure p_Get_Doc_Content(
    Val           Out t_Refcur,
	DocID_In 影像报告记录.Id%Type
	) As
  Begin
    Open Val For
      Select  Nvl(a.报告内容.GetClobVal(), '<ZLXML/>') As 报告内容 From 影像报告记录 A Where a.Id = DocID_In;
  End;

  --7、设置报告打印作废信息
  Procedure p_Checkrejectsignature(Signdate_In Date,
                                   报告ID_In   影像报告操作记录.报告Id%Type,
                                   作废人_In   影像报告操作记录.作废人%Type,
                                   作废说明_In 影像报告操作记录.作废说明%Type,
                                   Val         Out Sys_Refcursor) As
  Begin
    Open Val For
      Select 操作人, 操作时间
        From 影像报告操作记录
       Where 报告ID = 报告ID_In
         And 操作类型=1
         And 操作时间 >= Signdate_In
         And 作废时间 Is Null
       Order By 操作时间 Asc;
    --作废打印记录
    Update 影像报告操作记录 B
       Set 作废人 = 作废人_In, 作废时间 = Sysdate, b.作废说明 = 作废说明_In
     Where 报告ID = 报告ID_In And 操作类型=1
       And 操作时间 >= Signdate_In;

  End p_Checkrejectsignature;

  --8、查询相应原型下的最大序号
  Procedure p_Get_Samplelist_Maxseqnum(
    Val           Out t_Refcur,
	原型ID_In 影像报告范文清单.原型ID%Type
	) As
  Begin
    Open Val For
      Select Nvl(Max(a.编号), 0) + 1 As Num
        From 影像报告范文清单 A
       Where a.原型ID = 原型ID_In;
  End;

  --9、删除文档范文
  Procedure p_Del_影像报告范文清单(
    Id_In 影像报告范文清单.Id%Type
	) As
  Begin
    Delete From 影像报告范文清单 Where Id = Id_In;
  End;
  
 --10、添加文档的操作日志
  Procedure p_影像报告操作记录_Add(Id_In       影像报告操作记录.Id%Type,
                               报告ID_In   影像报告操作记录.报告ID%Type,
                               操作人_In   影像报告操作记录.操作人%Type,
                               操作类型_In 影像报告操作记录.操作类型%Type) As
  n_医嘱ID 影像报告操作记录.医嘱ID%Type;
  n_文档标题 影像报告记录.文档标题%Type;
  Begin

  Begin
    Select 医嘱ID,文档标题 Into n_医嘱ID,n_文档标题 From 影像报告记录 Where ID = 报告ID_In;
  Exception
    When Others Then
      null;
  End;
  if n_医嘱ID is not null then
    Insert Into 影像报告操作记录
      (ID, 报告ID,医嘱ID,文档标题,操作人,操作时间,操作类型)
    Values
      (Id_In, 报告ID_In, n_医嘱ID,n_文档标题,操作人_In, sysdate,操作类型_In);
    if 操作类型_In=1 then
        update 影像报告记录 set 报告打印=1 where ID=报告ID_In;
    end if;
  end if;
  Exception
    When Others Then
      Zl_Errorcenter(SQLCode, SQLErrM);
  End;

  --11、删除报告
  Procedure p_影像报告记录_删除(
    报告_Id_In 影像报告记录.Id%Type
	) As
  Begin    

    Delete From 影像报告记录 Where 影像报告记录.Id = Hextoraw(报告_Id_In);

    Delete From 病人医嘱报告 Where 检查报告ID =hextoraw(报告_Id_In);

  Exception   
    When Others Then
      Zl_Errorcenter(SQLCode, SQLErrM);
  End p_影像报告记录_删除;


--12、获取签名类型
Procedure p_Get_SysConfigSignature(
  Val           Out t_Refcur,
  科室ID_In		In 部门表.ID%Type
  )Is
Begin
    --返回用户, 模块号,功能
	Open  Val For 
	    select Zl_Fun_Getsignpar(7, 科室ID_In) as 签名类型 from dual;
Exception
  When Others Then
  Zl_Errorcenter(Sqlcode, Sqlerrm); 
End;


--13、获取账户签名印章
Procedure p_Get_PersonSignImg(
  Val           Out t_Refcur,
  ID_In		In 人员表.ID%Type
  )Is
  v_sql Varchar2(1000);
  n_count Number(5);
Begin                
  Select Count(*) Into n_Count From user_tables Where table_name =Upper('影像签名图片');
  
  If n_Count > 0 Then
     v_sql := 'Truncate Table 影像签名图片';
     Execute Immediate v_sql;   
     
     v_sql := 'Insert Into 影像签名图片 Select a.id, to_lob(a.签名图片) as 签名图片 From 人员表 a Where a.ID=' || ID_In;
     Execute Immediate v_sql;  
  Else
     v_sql := 'Create GLOBAL TEMPORARY TABLE 影像签名图片 ON COMMIT PRESERVE ROWS AS Select a.id, to_lob(a.签名图片) as 签名图片 From 人员表 a Where a.ID=' || ID_In;  
     Execute Immediate v_sql;    
  End If; 
    
  v_sql := 'Select 签名图片 From 影像签名图片 Where Id=:ID';
    --返回用户, 模块号,功能
	Open  Val For v_sql Using ID_In;  

Exception
  When Others Then
  Zl_Errorcenter(Sqlcode, Sqlerrm); 
End;


--14、获取签名的证书信息
Procedure p_Get_SignCertInfo(
  Val           Out t_Refcur,
  证书ID_In		人员证书记录.ID%Type
  )Is
Begin
	Open  Val For 
	    Select ID, CertDN,CertSN,SignCert,EncCert From 人员证书记录 Where ID=证书ID_In;
Exception
  When Others Then
		Zl_Errorcenter(Sqlcode, Sqlerrm); 
End;

--15、更新报告状态
Procedure p_Update_ReportState(
  报告Id_In  影像报告记录.ID%Type,
  报告状态_In  影像报告记录.报告状态%Type,
  审核人_In   影像报告记录.最后审核人%Type
  )Is
Begin
  --报告状态1-未签名；2-已诊断；3-已审核；4-已终审；5-诊断驳回；6-审核驳回
  --如果报告状态是1-未签名；2-已诊断;5-诊断驳回，此时是没有审核人的
  if (报告状态_In=1) or (报告状态_In=2) or (报告状态_In=5) then 
    Update 影像报告记录 Set 报告状态=报告状态_In,最后审核人=null,最后审核时间=null Where ID=报告Id_In;
  elsif (报告状态_In=3) or (报告状态_In=4) then 
    Update 影像报告记录 Set 报告状态=报告状态_In,最后审核人=审核人_In,最后审核时间=sysdate Where ID=报告Id_In;
  else
    Update 影像报告记录 Set 报告状态=报告状态_In Where ID=报告Id_In;
  end if;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End;

--16、获取报告状态
Procedure p_Get_ReportState(
  Val           Out t_Refcur,
  报告Id_In	影像报告记录.ID%Type
  )Is
Begin
	Open  Val For 
	    Select 报告状态 From 影像报告记录 Where ID=报告Id_In;
Exception
  When Others Then
		Zl_Errorcenter(Sqlcode, Sqlerrm); 
End;



--17、报告驳回
Procedure p_Reject_Report(
  医嘱ID_In  影像报告驳回.医嘱ID%Type,
  报告ID_In  影像报告驳回.检查报告ID%Type,
  驳回理由_In 影像报告驳回.驳回理由%Type,
  驳回时间_In 影像报告驳回.驳回时间%Type,
  驳回人_In   影像报告驳回.驳回人%Type,
  待处理人_In  影像报告记录.待处理人%Type,
  报告状态_In 影像报告记录.报告状态%Type
  )Is
Begin
  Insert Into 影像报告驳回(ID, 医嘱ID,检查报告ID,驳回理由,驳回时间,驳回人)
  Values(影像报告驳回_ID.NEXTVAL, 医嘱ID_IN, 报告ID_In, 驳回理由_IN, 驳回时间_IN, 驳回人_IN);

  Update 影像报告记录 Set 报告状态=报告状态_In,待处理人=待处理人_In Where ID=报告ID_In;

  --Update 病人医嘱发送 Set 执行过程=-1 Where 医嘱ID= 医嘱ID_IN;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End;

--17.1、撤销报告驳回
Procedure p_Reject_Cancel(
  ID_In       影像报告驳回.ID%Type,
  报告ID_In    影像报告驳回.检查报告ID%Type,
  报告状态_In   影像报告记录.报告状态%Type
  )Is
Begin
  Update 影像报告驳回 Set 是否撤销=1 Where ID=ID_In;
  Update 影像报告记录 Set 报告状态=报告状态_In,待处理人='' Where ID=报告ID_In;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End;

--18、获取报告驳回信息
Procedure p_Get_RejectInfo(
  Val           Out t_Refcur,
  报告ID_In  影像报告驳回.检查报告ID%Type
  )Is
Begin
  Open  Val For
    Select A.ID, A.驳回理由, A.驳回时间, A.驳回人, Nvl( A.是否撤销,0) As 驳回状态, B.报告状态
    From 影像报告驳回 A, 影像报告记录 B Where A.检查报告ID=报告Id_In And A.检查报告ID = B.ID Order by 驳回时间;
End;

--19、获取原型动作
Procedure p_Get_Doc_Process(
  Val           Out t_Refcur,
  原型ID_In 影像报告动作.原型id%Type
  ) As
  Begin
    Open Val For
      Select RawtoHex(p.id) ID,
             p.名称 As 动作名称,
			 e.名称 As 事件名称,
			 e.种类 As 事件种类,
			 e.元素IID As 元素IID,
             p.动作类型,
             p.序号,
             p.说明,
             p.可否手工执行,
             To_Clob(Nvl(p.内容.GetClobVal(),'<NULL/>')) As 内容, 
             RawtoHex(p.事件ID) 事件ID
        From 影像报告动作 P, 影像报告事件 E
       Where p.事件ID = e.Id(+) And p.原型ID=原型ID_In
       Order By 动作类型, 序号;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Doc_Process;

  --20、通过学科筛选获得相应的范文信息
  Procedure p_Get_Samplelist_By_Conditions(
    Val           Out t_Refcur,
    原型id_In       Varchar2,
    学科_In          Varchar2,
    Condition_In Varchar2, --过滤筛选
    作者_In          Varchar2
  ) As
  Begin

    Open Val For
      Select /*+ rule*/ Rawtohex(a.Id) ID, a.名称, a.作者, a.说明,
             Nvl2(a.说明, a.说明 || '作者:' || a.作者, '作者:' || a.作者) Content, a.标签, a.学科
      From 影像报告范文清单 A
      Where a.原型ID = Hextoraw(原型id_In) And
            ((a.学科 Is Null And a.是否私有 = 0) Or 学科_In Is Null Or a.作者 = 作者_In Or
            (a.学科 Is Not Null And  b_PACS_RptPublic.f_If_Intersect(a.学科, 学科_In) > 0 And a.是否私有 = 0)) And
            (Condition_In Is Null Or
            (a.标签 Is Not Null And Condition_In Is Not Null And b_PACS_RptPublic.f_If_Intersect(a.标签, Condition_In) > 0))
      Order By a.编号;

  End p_Get_Samplelist_By_Conditions;

  --21、通过部门ID获取部门名称
  Procedure p_Get_部门名称_By_ID(
    Val           Out t_Refcur,
    ID_IN 部门表.ID%TYPE
    )Is
  begin
       open val for
       select 名称 from 部门表 where id=ID_IN;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  end p_Get_部门名称_By_ID;
    

 --22、提取所有预备提纲
  Procedure p_Get_AllPreOutlines(
    Val           Out t_Refcur
  )Is
  begin
       open val for
       Select Rawtohex(ID) ID, a.编码, a.名称 From 影像报告预备提纲 a Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  end p_Get_AllPreOutlines;

  --23、提取文档标题
  Procedure p_Get_reportTitle_By_ID(
    Val           Out t_Refcur,
	ID_IN  影像报告记录.id%TYPE   
    )Is
  begin
       open val for
       select 文档标题 from 影像报告记录 where id=ID_IN;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  end p_Get_reportTitle_By_ID;

  --24、提取报告锁定人
  Procedure p_Get_报告锁定人_By_ID(
    Val           Out t_Refcur,
	ID_IN  影像报告记录.id%TYPE   
    )Is
  Begin
       Open Val For
         Select 锁定人 From 影像报告记录 Where id =ID_IN;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  end p_Get_报告锁定人_By_ID;

 --25、通过医嘱ID获取报告列表
  Procedure p_Get_影像报告记录_By_医嘱ID(
    Val           Out t_Refcur,
	医嘱ID_IN  影像报告记录.医嘱ID%TYPE
    )Is
  Begin
       Open Val For
       Select RawToHex(ID) As REPORTID, RawToHex(原型ID) As ANTETYPEID, 医嘱ID As ORDERID,文档标题 As REPORTNAME,
              创建时间 As REPORTDATE, Decode(Nvl(报告状态,0),1,'编辑中',2,'已诊断',3,'已审核',4,'已终审',5,'诊断驳回','审核驳回') As REPORTSTATE,
              创建人 As CreateUser,最后审核时间 As ExamineyDate,最后审核人 As ExamineyUser,Decode(Nvl(结果阳性,0),1,'阳性','') As RESULTPOSITIVE,
              Nvl(报告质量,0) As INNERQUALITY,' ' As REPORTQUALITY, Decode(Nvl(报告打印,0),0,'未打印','已打印') As ReportPrint,
              Decode(Nvl(报告发放,0),0,'未发放','已发放') As REPORTRELEASE ,记录人 as RECDOCTOR From 影像报告记录 Where 医嘱ID =医嘱ID_IN
              order by REPORTDATE desc;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_影像报告记录_By_医嘱ID;
  
  --26、查询影像流程参数值
  Procedure p_Get_影像流程参数值(
    Val           Out t_Refcur,
	科室ID_IN  影像流程参数.科室ID%TYPE
    )Is
  Begin
       Open val For
       Select 参数名,参数值 From 影像流程参数 Where 科室ID=科室ID_IN;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_影像流程参数值;

  --27、根据医嘱ID，查询对应的原型列表
  Procedure p_Get_影像原型列表_By_医嘱ID(
    Val           Out t_Refcur,
    医嘱_IN  影像检查记录.医嘱ID%TYPE   
    )Is
  Begin
       Open Val For
       Select rawtohex(c.id) As ANTETYPEID , c.名称 As ANTETYPENAME,c.说明 
       From 病人医嘱记录 a,影像报告原型应用 b,影像报告原型清单 c 
       Where a.id=医嘱_IN And a.诊疗项目id=b.诊疗项目ID And b.报告原型ID=c.id And a.病人来源 =b.应用场合;
       
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_影像原型列表_By_医嘱ID;

  --28、根据报告ID查询打印记录
  procedure p_Get_ReportPrintLog_By_报告ID
  (
       val out sys_refcursor  ,
       报告_IN  影像报告操作记录.报告ID%TYPE
  )is
  begin
       open val for
       Select  c.文档标题 , b.操作人, To_Char(b.操作时间, 'yyyy-MM-dd HH24:mi') 打印时间, b.作废人,
               To_Char(b.作废时间, 'yyyy-MM-dd HH24:mi') 作废时间, b.作废说明
               From 影像报告操作记录 B, 影像报告记录 C
               Where c.Id = 报告_IN And b.报告ID = c.Id And 操作类型=1 Order By b.操作时间;

  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  end p_Get_ReportPrintLog_By_报告ID;

  --29、根据医嘱ID查询报告发放列表
  Procedure p_Get_ReportReleaseList(
    Val           Out t_Refcur,
    医嘱_IN  影像报告记录.医嘱ID%TYPE   
    )Is
  Begin
       Open val For
       Select rawtohex(ID) As 报告ID, 文档标题 As 报告名称,最后编辑时间 as 报告日期,
              decode(nvl(报告发放,0),0,'未发放','已发放') As 报告发放 
              From 影像报告记录 Where 报告状态 Between 2 And 4 And 医嘱ID =医嘱_IN;
       
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_ReportReleaseList;

  --30、根据报告ID查询驳回记录数量
  Procedure p_Get_RejectedCount(
    Val           Out t_Refcur,
    报告_IN  影像报告驳回.检查报告ID%TYPE
    )Is
  Begin
       Open val For
       Select count(*) As 驳回数量 From 影像报告驳回 Where 检查报告ID=报告_IN;

  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_RejectedCount;

   --31、根据医嘱ID查询报告动作需要的一些ID们
  Procedure p_Get_DocProcess_IDs(
    Val           Out t_Refcur,
    医嘱_IN  病人医嘱记录.ID%TYPE
    )Is
  Begin
       open val for
       select ID as 医嘱ID,主页ID,挂号单 from 病人医嘱记录 where ID=医嘱_IN;

  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_DocProcess_IDs;

  --32、根据医嘱ID和报告ID查询报告的一些参数
  Procedure p_Get_DocInfo(
       Val           Out t_Refcur,
       医嘱ID_IN  影像检查记录.医嘱ID%TYPE,
       报告ID_IN  影像报告记录.ID%TYPE
  )Is
  Begin
      If 报告ID_IN Is Null Then 
        Open Val For 
        Select 执行科室ID,'创建人' As 创建人 From 影像检查记录 Where 医嘱ID=医嘱ID_IN;
      Else
        Open Val For
        Select 执行科室ID,创建人 From 影像检查记录 A,影像报告记录 b Where a.医嘱ID=B.医嘱ID and b.id=报告ID_IN;
      End if;
       

  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_DocInfo;

  --33、查询一个检查中相同原型ID的报告数量
   Procedure p_Get_SameAntetypeDocCounts(
       Val           Out t_Refcur,
       医嘱ID_IN  影像报告记录.医嘱ID%TYPE,
       原型ID_IN  影像报告记录.原型ID%TYPE
  )Is
  Begin      
        Open Val For
        Select count(id) as DocCounts From 影像报告记录 Where 医嘱ID=医嘱ID_IN and 原型ID=原型ID_IN;    
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_SameAntetypeDocCounts;

  --34、提取报告图存储信息
  Procedure p_Get_DocImageSaveInof_By_ID(
    Val           Out t_Refcur,
	  ID_IN  影像报告记录.id%TYPE
    )Is
  begin
       open val for
       select 设备号,创建时间 from 影像报告记录 where id=ID_IN;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  end p_Get_DocImageSaveInof_By_ID;

End b_PACS_RptManage;
/

CREATE OR REPLACE Package b_PACS_RptFragments Is
  Type t_Refcur Is Ref Cursor;


  --功能：获取所有预备提纲
  Procedure p_Get_All_Phr_Onlines(
    Val Out t_Refcur
	);
  --功能：获取所有短语分类
  Procedure p_Get_All_Fragment_Class(
    Val Out t_Refcur
	);
  --功能：获取当前用户学科所有短语包括父节点
  Procedure p_Get_All_Fragment(
    Val           Out t_Refcur,
    Subjects_In 影像报告片段清单.学科%Type
	) ;


  --功能：根据分类ID查找短语
  Procedure p_Get_Fragment_By_Typeid(
    Val           Out t_Refcur,
    Id_In 影像报告片段清单.ID%Type
	) ;


   Procedure p_Get_Label_By_Typeid(
     Val           Out t_Refcur,
	 Id_In 影像报告片段清单.ID%Type
	 ) ;

  --功能：新增短语分类
  Procedure p_Add_Fragmenttype(
    Id_In     影像报告片段清单.ID%Type,
    Pid_In    影像报告片段清单.上级ID%Type,
    Code_In   影像报告片段清单.编码%Type,
    Title_In  影像报告片段清单.名称%Type,
    Note_In   影像报告片段清单.说明%Type,
    Leaf_In   影像报告片段清单.节点类型%Type,
    Author_In 影像报告片段清单.作者%Type
    ) ;

  --功能：修改短语分类
  Procedure p_Edit_Fragmenttype(
    Id_In     影像报告片段清单.ID%Type,
    Pid_In    影像报告片段清单.上级ID%Type,
    Code_In   影像报告片段清单.编码%Type,
    Title_In  影像报告片段清单.名称%Type,
    Note_In   影像报告片段清单.说明%Type,
    Leaf_In   影像报告片段清单.节点类型%Type,
    Author_In 影像报告片段清单.作者%Type
    ) ;

  --功能：删除短语分类
   Procedure p_Del_Fragmenttype(
     Id_In 影像报告片段清单.ID%Type
	 );

    --功能：添加短语
  Procedure p_Add_Fragment(
     Id_In      影像报告片段清单.ID%Type,
    Pid_In      影像报告片段清单.上级ID%Type,
    Code_In     影像报告片段清单.编码%Type,
    Title_In    影像报告片段清单.名称%Type,
    Note_In     影像报告片段清单.说明%Type,
    Leaf_In     影像报告片段清单.节点类型%Type,
    Content_In  影像报告片段清单.组成%Type,
    Subjects_In 影像报告片段清单.学科%Type,
    Label_In    影像报告片段清单.标签%Type,
    Private_In  影像报告片段清单.是否私有%Type,
    Author_In   影像报告片段清单.作者%Type
    ) ;

   --功能：修改短语
  Procedure p_Edit_Fragment(
    Id_In       影像报告片段清单.ID%Type,
    Pid_In      影像报告片段清单.上级ID%Type,
    Code_In     影像报告片段清单.编码%Type,
    Title_In    影像报告片段清单.名称%Type,
    Note_In     影像报告片段清单.说明%Type,
    Leaf_In     影像报告片段清单.节点类型%Type,
    Content_In  影像报告片段清单.组成%Type,
    Subjects_In 影像报告片段清单.学科%Type,
    Label_In    影像报告片段清单.标签%Type,
    Private_In  影像报告片段清单.是否私有%Type,
    Author_In   影像报告片段清单.作者%Type
    );
   --功能：删除短语
  Procedure p_Del_Fragment(
    Id_In 影像报告片段清单.ID%Type
	);

  procedure p_Get_All_Fragment_List(
    Val Out t_Refcur
	);

  --功能：导入短语
  Procedure p_Import_Fragment(
    Id_In       影像报告片段清单.ID%Type,
    Pid_In      影像报告片段清单.上级ID%Type,
    Code_In     影像报告片段清单.编码%Type,
    Title_In    影像报告片段清单.名称%Type,
    Note_In     影像报告片段清单.说明%Type,
    Leaf_In     影像报告片段清单.节点类型%Type,
    Content_In  影像报告片段清单.组成%Type,
    Subjects_In 影像报告片段清单.学科%Type,
    Label_In    影像报告片段清单.标签%Type,
    Private_In  影像报告片段清单.是否私有%Type,
    Author_In   影像报告片段清单.作者%Type
    ) ;

procedure p_Get_Data_Last_Edit_Time(
  Val           Out t_Refcur,
  Table_Name_In varchar2
  );

   --功能：判断片段分类能否删除
  Procedure p_IsCanDel_FragmentType(
    Val           Out t_Refcur,
	Id_In 影像报告片段清单.Id%Type
	);

  --功能：根据片段ID，设置当前片段的适应条件
  Procedure p_Edit_FragmentConditionById
  (
    ID_In      In 影像报告片段清单.ID%Type,
    适应条件_In In 影像报告片段清单.适应条件%Type
  );
  
  --功能：根据片段的父ID，设置整个目录或子目录片段的适应条件
  Procedure p_Edit_FragmentConditionByPid
  (
    上级ID_In      In 影像报告片段清单.ID%Type,
    适应条件_In    In 影像报告片段清单.适应条件%Type
  );

  --功能：获取当前检查的片段适应条件
  Procedure p_Get_FraConditionByOrderId
  (
    Val           Out t_Refcur,
	医嘱ID_In    影像检查记录.医嘱ID%Type
  );

  --功能：获取影像检查类别
  Procedure p_Get_CheckLueKind
  (
    Val           Out t_Refcur
  );
  
  --功能：根据类别获取诊疗检查部位
  Procedure p_Get_CheckPartList
  (
    Val           Out t_Refcur,
    Kind_In       Varchar2
  );
  
  --功能：根据类别获取影像检查项目
  Procedure p_Get_CheckRadListByKind
  (
    Val           Out t_Refcur,
    Kind_In       Varchar2
  );
  
  --功能：根据诊疗编码获取影像检查项目
  Procedure p_Get_CheckRadListByCode
  (
    Val           Out t_Refcur,
    Code_In       Varchar2
  );

  --判断是否有相同的代码
  Procedure p_Get_HasSameCode
  (
  Val      Out t_Refcur,
  ID_In      In 影像报告片段清单.ID%Type,
  Code_In  影像报告片段清单.编码%Type
  );

  --判断是否有相同的名称
  Procedure p_Get_HasSameName
  (
  Val      Out t_Refcur,
  ID_In    In 影像报告片段清单.ID%Type,
  PID_In    In 影像报告片段清单.上级ID%Type,
  Name_In  In 影像报告片段清单.名称%Type,
  Author_In In  影像报告片段清单.作者%Type
  );

  End  b_PACS_RptFragments;
/
CREATE OR REPLACE Package Body b_PACS_RptFragments Is

  ------------------------------------------------------------------------
  --片段模块
  ------------------------------------------------------------------------

  --功能：获取所有预备提纲
  Procedure p_Get_All_Phr_Onlines(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select Rawtohex(ID) ID, 编码, 名称 From 影像报告预备提纲 Order By 编码;
  End p_Get_All_Phr_Onlines;

  --功能：获取所有短语分类
  Procedure p_Get_All_Fragment_Class(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select Rawtohex(a.Id) As ID, Rawtohex(a.上级id) As 上级id, a.编码, a.名称, a.说明, a.节点类型
      From 影像报告片段清单 A
      Where a.节点类型 = 0
      Start With 上级id Is Null
      Connect By Prior ID = 上级id
      Order By 编码;
  End p_Get_All_Fragment_Class;

  --功能：获取当前用户学科所有短语包括父节点
  Procedure p_Get_All_Fragment(
    Val           Out t_Refcur,
    Subjects_In 影像报告片段清单.学科%Type
	) As
  Begin
    If Subjects_In <> '' Then
      Open Val For
        Select Rawtohex(a.Id) As ID, Rawtohex(a.上级id) As 上级id, a.编码, a.名称, a.说明, a.节点类型, Nvl(a.组成.GetClobVal(), '<NULL/>') As 组成, 
			a.学科, a.标签, a.是否私有, a.作者, Nvl(a.适应条件.GetClobVal(), '<NULL/>') As 适应条件,a.最后编辑时间, a.节点类型 As Image
        From 影像报告片段清单 A
        Where (a.学科 In (Select /*+rule*/
                         Column_Value As Lable
                        From Table(b_Pacs_Common.f_Str2list(Subjects_In, ','))
                        Intersect
                        Select /*+rule*/
                         Column_Value As Lable
                        From Table(b_Pacs_Common.f_Str2list(a.学科, ','))) And a.节点类型 <> 0) Or a.节点类型 = 0 Or a.学科 Is Null
        Order By 编码, 上级id;
    Else
      Open Val For
        Select Rawtohex(a.Id) As ID, Rawtohex(a.上级id) As 上级id, a.编码, a.名称, a.说明, a.节点类型, Nvl(a.组成.GetClobVal(), '<NULL/>') As 组成, 
			a.学科, a.标签, a.是否私有, a.作者, Nvl(a.适应条件.GetClobVal(), '<NULL/>') As 适应条件,a.最后编辑时间, a.节点类型 As Image
        From 影像报告片段清单 A
        Order By 上级id, 节点类型, 编码, 名称;
    End If;
  End p_Get_All_Fragment;

  --功能：根据分类ID查找短语
  Procedure p_Get_Fragment_By_Typeid(
    Val           Out t_Refcur,
    Id_In 影像报告片段清单.Id%Type
  ) As
  Begin
    Open Val For
      Select Rawtohex(a.Id) As ID, a.上级ID,a.编码, a.名称, a.说明, a.节点类型, Nvl(a.组成.GetClobVal(), '<NULL/>') As 组成, 
				a.学科, a.标签, a.是否私有, a.作者, Nvl(a.适应条件.GetClobVal(), '<NULL/>') As 适应条件, a.最后编辑时间,a.节点类型 As Image
      From 影像报告片段清单 A
      Where a.上级id = Hextoraw(Id_In) And a.节点类型 <> 0;
  End p_Get_Fragment_By_Typeid;

  --功能：查找某分类下所有短语标签
  Procedure p_Get_Label_By_Typeid(
    Val           Out t_Refcur,
    Id_In 影像报告片段清单.Id%Type
    ) As
  Begin
    Open Val For
      Select Distinct 标签 From 影像报告片段清单 Where 上级id = Hextoraw(Id_In) And 标签 Is Not Null;
  End p_Get_Label_By_Typeid;

  --功能：新增短语分类
  Procedure p_Add_Fragmenttype(
    Id_In     影像报告片段清单.Id%Type,
    Pid_In    影像报告片段清单.上级id%Type,
    Code_In   影像报告片段清单.编码%Type,
    Title_In  影像报告片段清单.名称%Type,
    Note_In   影像报告片段清单.说明%Type,
    Leaf_In   影像报告片段清单.节点类型%Type,
    Author_In 影像报告片段清单.作者%Type
    ) As
    n_Num     Number;
    v_Err_Msg Varchar2(100);
    Err_Item Exception;
  Begin
    Select Count(ID)
    Into n_Num
    From 影像报告片段清单
    Where 编码 = Code_In Or 名称 = Title_In And 节点类型 = 0 And 上级id = Hextoraw(Pid_In);

    If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]分类名称或编码已经存在！[ZLSOFT]';
      Raise Err_Item;
    Else
      Insert Into 影像报告片段清单
        (ID, 上级id, 编码, 名称, 说明, 节点类型, 作者, 最后编辑时间)
      Values
        (Hextoraw(Id_In), Hextoraw(Pid_In), Code_In, Title_In, Note_In, Leaf_In, Author_In, Sysdate);
    End If;

  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Add_Fragmenttype;

  --功能：修改短语分类
  Procedure p_Edit_Fragmenttype(
    Id_In     影像报告片段清单.Id%Type,
    Pid_In    影像报告片段清单.上级id%Type,
    Code_In   影像报告片段清单.编码%Type,
    Title_In  影像报告片段清单.名称%Type,
    Note_In   影像报告片段清单.说明%Type,
    Leaf_In   影像报告片段清单.节点类型%Type,
    Author_In 影像报告片段清单.作者%Type
    ) As
    n_Num     Number;
    v_Err_Msg Varchar2(100);
    Err_Item Exception;
  Begin
    Select Count(ID)
    Into n_Num
    From 影像报告片段清单
    Where (编码 = Code_In Or 名称 = Title_In) And 节点类型 = 0 And 上级id = Hextoraw(Pid_In) And ID <> Hextoraw(Id_In);

	If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]分类名称或编码已经存在！[ZLSOFT]';
      Raise Err_Item;
    Else
      Update 影像报告片段清单
      Set 上级id = Hextoraw(Pid_In), 编码 = Code_In, 名称 = Title_In, 说明 = Note_In, 节点类型 = Leaf_In, 作者 = Author_In,
          最后编辑时间 = Sysdate
      Where ID = Hextoraw(Id_In);
    End If;
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Edit_Fragmenttype;

  --功能：删除短语分类
  Procedure p_Del_Fragmenttype(
    Id_In 影像报告片段清单.Id%Type
	) As
    n_Num     Number;
    v_Err_Msg Varchar2(100);
    Err_Item Exception;
  Begin
    Select Count(ID)
    Into n_Num
    From 影像报告片段清单
    Where 节点类型 <> 0 And
          ID In (Select ID From 影像报告片段清单 Connect By Prior ID = 上级id Start With ID = Hextoraw(Id_In));

	If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]该分类下存在短语，暂不能删除！[ZLSOFT]';
      Raise Err_Item;
    Else
      Delete 影像报告片段清单 Where ID = Hextoraw(Id_In);
    End If;

  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Del_Fragmenttype;

  --功能：添加短语
  Procedure p_Add_Fragment(
    Id_In       影像报告片段清单.Id%Type,
    Pid_In      影像报告片段清单.上级id%Type,
    Code_In     影像报告片段清单.编码%Type,
    Title_In    影像报告片段清单.名称%Type,
    Note_In     影像报告片段清单.说明%Type,
    Leaf_In     影像报告片段清单.节点类型%Type,
    Content_In  影像报告片段清单.组成%Type,
    Subjects_In 影像报告片段清单.学科%Type,
    Label_In    影像报告片段清单.标签%Type,
    Private_In  影像报告片段清单.是否私有%Type,
    Author_In   影像报告片段清单.作者%Type
    ) As
  Begin

      Insert Into 影像报告片段清单
        (ID, 上级id, 编码, 名称, 说明, 节点类型, 组成, 学科, 标签, 是否私有, 作者, 最后编辑时间)
      Values
        (Hextoraw(Id_In), Hextoraw(Pid_In), Code_In, Title_In, Note_In, Leaf_In, Content_In, Subjects_In, Label_In,
         Private_In, Author_In, Sysdate);

  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Add_Fragment;

  --功能：修改短语
  Procedure p_Edit_Fragment(
    Id_In       影像报告片段清单.Id%Type,
    Pid_In      影像报告片段清单.上级id%Type,
    Code_In     影像报告片段清单.编码%Type,
    Title_In    影像报告片段清单.名称%Type,
    Note_In     影像报告片段清单.说明%Type,
    Leaf_In     影像报告片段清单.节点类型%Type,
    Content_In  影像报告片段清单.组成%Type,
    Subjects_In 影像报告片段清单.学科%Type,
    Label_In    影像报告片段清单.标签%Type,
    Private_In  影像报告片段清单.是否私有%Type,
    Author_In   影像报告片段清单.作者%Type
    ) As
    n_Num     Number;
    v_Err_Msg Varchar2(100);
    Err_Item Exception;
  Begin
    Select Count(ID)
    Into n_Num
    From 影像报告片段清单
    Where (编码 = Code_In Or 名称 = Title_In) And 节点类型 <> 0 And 上级id = Hextoraw(Pid_In) And ID <> Hextoraw(Id_In);

	If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]短语的名称或编码已经存在！[ZLSOFT]';
      Raise Err_Item;
    Else
      Update 影像报告片段清单
      Set 上级id = Hextoraw(Pid_In), 编码 = Code_In, 名称 = Title_In, 说明 = Note_In, 节点类型 = Leaf_In, 组成 = Content_In,
          学科 = Subjects_In, 标签 = Label_In, 是否私有 = Private_In, 作者 = Author_In, 最后编辑时间 = Sysdate
      Where ID = Hextoraw(Id_In);
    End If;

  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Edit_Fragment;

  --
  Procedure p_Get_All_Fragment_List(Val Out t_Refcur) As
  Begin
    Open Val For
      Select Rawtohex(t.Id) As ID, Rawtohex(t.上级id) As 上级id, t.编码, t.名称, t.说明, t.节点类型, Nvl(t.组成.GetClobVal(), '<NULL/>') As 组成, t.学科, t.标签, t.是否私有, t.作者,
             t.最后编辑时间
      From 影像报告片段清单 T;
  End p_Get_All_Fragment_List;

  --功能：删除短语
  Procedure p_Del_Fragment(
    Id_In 影像报告片段清单.Id%Type
	) As
  Begin
    Delete 影像报告片段清单 Where ID = Hextoraw(Id_In);
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Del_Fragment;

  --功能：导入短语
  Procedure p_Import_Fragment(
    Id_In       影像报告片段清单.Id%Type,
    Pid_In      影像报告片段清单.上级id%Type,
    Code_In     影像报告片段清单.编码%Type,
    Title_In    影像报告片段清单.名称%Type,
    Note_In     影像报告片段清单.说明%Type,
    Leaf_In     影像报告片段清单.节点类型%Type,
    Content_In  影像报告片段清单.组成%Type,
    Subjects_In 影像报告片段清单.学科%Type,
    Label_In    影像报告片段清单.标签%Type,
    Private_In  影像报告片段清单.是否私有%Type,
    Author_In   影像报告片段清单.作者%Type
    ) As
    v_Num Number(2);
  Begin
    Select Count(ID)
    Into v_Num
    From 影像报告片段清单
    Where ((编码 = Code_In Or 名称 = Title_In) And 上级id = Hextoraw(Pid_In)) Or
          (上级id Is Null And (编码 = Code_In Or 名称 = Title_In));

    If v_Num > 0 Then
      Update 影像报告片段清单
      Set 组成 = Content_In, 最后编辑时间 = Sysdate, 是否私有 = 0
      Where ((编码 = Code_In Or 名称 = Title_In) And 上级id = Hextoraw(Pid_In)) Or
            (上级id Is Null And (编码 = Code_In Or 名称 = Title_In));
    Else
      Insert Into 影像报告片段清单
        (ID, 上级id, 编码, 名称, 说明, 节点类型, 组成, 学科, 标签, 是否私有, 作者, 最后编辑时间)
      Values
        (Hextoraw(Id_In), Hextoraw(Pid_In), Code_In, Title_In, Note_In, Leaf_In, Content_In, Subjects_In, Label_In,
         Private_In, Author_In, Sysdate);
    End If;

  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Import_Fragment;

  --
  Procedure p_Get_Data_Last_Edit_Time(
    Val           Out t_Refcur,
    Table_Name_In Varchar2
    ) As
    v_Sql Varchar2(4000);
  Begin
    v_Sql := 'select max(最后编辑时间) maxvalue from ' || Table_Name_In;
    Open Val For v_Sql;
  End p_Get_Data_Last_Edit_Time;
  
   --功能：判断片段分类能否删除
  Procedure p_IsCanDel_FragmentType(
    Val           Out t_Refcur,
	Id_In 影像报告片段清单.Id%Type
	) As
  Begin
    Open Val For
      Select Count(t.id) Count
        From 影像报告片段清单 t
       Where 上级id = Hextoraw(Id_In);
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_IsCanDel_FragmentType;
  
  --功能：根据片段ID，设置当前片段的适应条件
  Procedure p_Edit_FragmentConditionById
  (
    ID_In      In 影像报告片段清单.ID%Type,
    适应条件_In In 影像报告片段清单.适应条件%Type
  )As
  Begin
    Update 影像报告片段清单 Set 适应条件 = 适应条件_In Where ID = Hextoraw(ID_In) And 节点类型 != 0;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Edit_FragmentConditionById;
  
  --功能：根据片段的父ID，设置整个目录或子目录片段的适应条件
  Procedure p_Edit_FragmentConditionByPid
  (
    上级ID_In      In 影像报告片段清单.ID%Type,
    适应条件_In In 影像报告片段清单.适应条件%Type
  )As
  Begin
    Update 影像报告片段清单 Set 适应条件 = 适应条件_In Where 上级ID = Hextoraw(上级ID_In) And 节点类型 != 0;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Edit_FragmentConditionByPid;

  --功能：获取当前检查的片段适应条件
  Procedure p_Get_FraConditionByOrderId(
    Val           Out t_Refcur,
	  医嘱ID_In    影像检查记录.医嘱ID%Type
	) As
  Begin
    Open Val For
	  Select a.id, a.性别,c.影像类别, d.编码||' - '||d.名称 检查类别, c.影像类别||' - '||e.编码||' - '||e.名称 检查项目, A.医嘱内容
      From 病人医嘱记录 a, 病人医嘱发送 b, 影像检查记录 c, 影像检查类别 d, 诊疗项目目录 e
      Where a.id = b.医嘱id and b.医嘱id=c.医嘱id and c.影像类别 = d.编码 and a.诊疗项目id = e.id and a.id = 医嘱ID_In;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Get_FraConditionByOrderId;

  --功能：获取影像检查类别
  Procedure p_Get_CheckLueKind
  (
    Val           Out t_Refcur
  ) As
  Begin
    Open Val For
      Select 编码||' - '||名称 检查类别 From 影像检查类别;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Get_CheckLueKind;
  
  --功能：根据类别获取诊疗检查部位
  Procedure p_Get_CheckPartList
  (
    Val           Out t_Refcur,
    Kind_In       Varchar2
  ) As
  Begin
    Open Val For
      Select Distinct 类型||分组 IID, '' 上级ID, 类型||' - '||分组 诊疗部位 From 诊疗检查部位 a,
      Table(Cast(f_Str2list(''||Kind_In||'') As zlTools.t_Strlist)) b Where a.类型 = b.Column_Value
      Union Select 类型||分组||名称 IID, 类型||分组 上级ID, 类型||' - '||名称 诊疗部位 From 诊疗检查部位 c,
      Table(Cast(f_Str2list(''||Kind_In||'') As zlTools.t_Strlist)) d Where c.类型 = d.Column_Value;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Get_CheckPartList;
  
  --功能：根据类别获取影像检查项目
  Procedure p_Get_CheckRadListByKind
  (
    Val           Out t_Refcur,
    Kind_In       Varchar2
  ) As
  Begin
    Open Val For
      Select I.编码, r.影像类别||' - '||I.编码||' - '||I.名称 检查项目
      From 诊疗项目目录 I, 影像检查项目 R, Table(Cast(f_Str2list(''||Kind_In||'') As zlTools.t_Strlist)) M
      Where I.ID = R.诊疗项目id And R.影像类别=M.Column_Value;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Get_CheckRadListByKind;
  
  --功能：根据诊疗编码获取影像检查项目
  Procedure p_Get_CheckRadListByCode
  (
    Val           Out t_Refcur,
    Code_In       Varchar2
  ) As
  Begin
    Open Val For
      Select I.编码, r.影像类别||' - '||I.编码||' - '||I.名称 检查项目
      From 诊疗项目目录 I, 影像检查项目 R, Table(Cast(f_Str2list(''||Code_In||'') As zlTools.t_Strlist)) M
      Where I.ID = R.诊疗项目id And I.编码=M.Column_Value;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Get_CheckRadListByCode;

  --判断是否有相同的代码
  Procedure p_Get_HasSameCode
  (
  Val      Out t_Refcur,
  ID_In      In 影像报告片段清单.ID%Type,
  Code_In  影像报告片段清单.编码%Type
  ) As
  Begin
  Open Val For
    Select Count(1) From 影像报告片段清单 Where ID<>ID_In And 编码=Code_In;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Get_HasSameCode;

  --判断是否有相同的名称
  Procedure p_Get_HasSameName
  (
  Val      Out t_Refcur,
  ID_In    In 影像报告片段清单.ID%Type,
  PID_In    In 影像报告片段清单.上级ID%Type,
  Name_In  In 影像报告片段清单.名称%Type,
  Author_In In  影像报告片段清单.作者%Type
  ) As
  Begin
  Open Val For
    Select Count(1) From 影像报告片段清单 Where 上级ID=PID_In And 作者=Author_In And ID<>ID_In And 名称=Name_In;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Get_HasSameName;

End  b_PACS_RptFragments;
/

--92840:李业庆,2016-01-19,增加建档时间
Create Or Replace Procedure Zl_疾病诊断目录_Insert
(
  Id_In       疾病诊断目录.Id%Type,
  诊断编码_In 疾病诊断目录.编码%Type,
  诊断名称_In 疾病诊断目录.名称%Type,
  名称拼音_In 疾病诊断别名.简码%Type,
  名称五笔_In 疾病诊断别名.简码%Type,
  英文名称_In 疾病诊断别名.名称%Type,
  其他别名_In 疾病诊断别名.名称%Type,
  别名拼音_In 疾病诊断别名.简码%Type,
  别名五笔_In 疾病诊断别名.简码%Type,
  诊断说明_In 疾病诊断目录.说明%Type,
  诊断类别_In 疾病诊断目录.类别%Type,
  v_Classes   Varchar2, --所属分类和对应的标准编码
  v_Collates  Varchar2,
  分类id_In   疾病诊断属类.分类id%Type,
  对应科室_In In Varchar2 := Null, --科室ID串:科室ID1,科室ID2,科室ID3...
  应用_In     In Number := 0 --应用范围:0-应用于当前项目;1-应用于同级项目;2-应用于当前分类
  
) As
  v_String  Varchar2(100); --临时记录的字符串
  v_Current Varchar2(20); --包含在单项目中的一个项目
  v_Infotmp Varchar2(4000);
  n_科室id  疾病诊断科室.科室id%Type;
  n_上级id  Number;
Begin
  Insert Into 疾病诊断目录
    (ID, 编码, 名称, 类别, 说明, 建档时间)
  Values
    (Id_In, 诊断编码_In, 诊断名称_In, 诊断类别_In, 诊断说明_In, Sysdate);

  If 名称拼音_In Is Not Null Then
    Insert Into 疾病诊断别名 (诊断id, 名称, 性质, 简码, 码类) Values (Id_In, 诊断名称_In, 1, 名称拼音_In, 1);
  End If;
  If 名称五笔_In Is Not Null Then
    Insert Into 疾病诊断别名 (诊断id, 名称, 性质, 简码, 码类) Values (Id_In, 诊断名称_In, 1, 名称五笔_In, 2);
  End If;
  If 英文名称_In Is Not Null Then
    Insert Into 疾病诊断别名 (诊断id, 名称, 性质, 简码, 码类) Values (Id_In, 英文名称_In, 2, '', 9);
  End If;
  If 其他别名_In Is Not Null And 别名拼音_In Is Not Null Then
    Insert Into 疾病诊断别名 (诊断id, 名称, 性质, 简码, 码类) Values (Id_In, 其他别名_In, 9, 别名拼音_In, 1);
  End If;
  If 其他别名_In Is Not Null And 别名五笔_In Is Not Null Then
    Insert Into 疾病诊断别名 (诊断id, 名称, 性质, 简码, 码类) Values (Id_In, 其他别名_In, 9, 别名五笔_In, 2);
  End If;

  v_String := v_Classes || ',';
  While v_String Is Not Null Loop
    v_Current := Substr(v_String, 1, Instr(v_String, ',') - 1);
    Insert Into 疾病诊断属类 (分类id, 诊断id) Values (To_Number(v_Current), Id_In);
    v_String := Replace(',' || v_String, ',' || v_Current || ',');
  End Loop;

  If v_Collates Is Null Then
    v_String := Null;
  Else
    v_String := v_Collates || ',';
  End If;
  While v_String Is Not Null Loop
    v_Current := Substr(v_String, 1, Instr(v_String, ',') - 1);
    Insert Into 疾病诊断对照 (疾病id, 诊断id) Values (To_Number(v_Current), Id_In);
    v_String := Replace(',' || v_String, ',' || v_Current || ',');
  End Loop;

  --设置疾病诊断科室
  Delete 疾病诊断科室 Where 诊断id = Id_In;

  If 对应科室_In Is Null Then
    v_Infotmp := Null;
  Else
    v_Infotmp := 对应科室_In || ',';
  End If;

  While v_Infotmp Is Not Null Loop
    --分解单据ID串
    n_科室id  := Substr(v_Infotmp, 1, Instr(v_Infotmp, ',') - 1);
    v_Infotmp := Replace(',' || v_Infotmp, ',' || n_科室id || ',');
    Insert Into 疾病诊断科室 (诊断id, 科室id) Values (Id_In, n_科室id);
  End Loop;

  If 应用_In = 1 Then
    --应用于同级项目
    Delete 疾病诊断科室
    Where 诊断id In (Select Distinct 诊断id From 疾病诊断属类 Where 分类id = 分类id_In) And 诊断id <> Id_In;
  
    Insert Into 疾病诊断科室
      (诊断id, 科室id)
      Select a.诊断id, b.科室id
      From 疾病诊断属类 A, 疾病诊断科室 B
      Where b.诊断id = Id_In And a.分类id = 分类id_In And a.诊断id <> Id_In;
  Elsif 应用_In = 2 Then
    --应用于当前分类
    Select ID
    Into n_上级id
    From 疾病诊断分类
    Where 类别 = 诊断类别_In And 上级id Is Null
    Start With ID = 分类id_In
    Connect By ID = Prior 上级id;
  
    Delete 疾病诊断科室
    Where 诊断id In (Select 诊断id
                   From 疾病诊断属类
                   Where 分类id In (Select ID
                                  From 疾病诊断分类
                                  Where 类别 = 诊断类别_In
                                  Start With ID = n_上级id
                                  Connect By Prior ID = 上级id)) And 诊断id <> Id_In;
  
    Insert Into 疾病诊断科室
      (诊断id, 科室id)
      Select a.诊断id, b.科室id
      From (Select 诊断id
             From 疾病诊断属类
             Where 分类id In (Select ID
                            From 疾病诊断分类
                            Where 类别 = 诊断类别_In
                            Start With ID = n_上级id
                            Connect By Prior ID = 上级id)) A, 疾病诊断科室 B
      Where b.诊断id = Id_In And a.诊断id <> Id_In;
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_疾病诊断目录_Insert;
/


--92840:李业庆,2016-01-19,增加停用功能
Create Or Replace Procedure Zl_疾病诊断目录_Stop(Id_In In 疾病诊断目录.Id%Type) Is
  v_Err_Msg Varchar2(100);
  Err_Item Exception;
Begin
  Update 疾病诊断目录
  Set 撤档时间 = Sysdate
  Where ID = Id_In And (撤档时间 Is Null Or 撤档时间 >= To_Date('3000-01-01', 'yyyy-mm-dd'));
  If Sql%NotFound Then
    v_Err_Msg := '[ZLSOFT]该项目已经被他人删除或停用,不能再停用![ZLSOFT]';
    Raise Err_Item;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_疾病诊断目录_Stop;
/

--92840:李业庆,2016-01-19,增加启用功能
Create Or Replace Procedure Zl_疾病诊断目录_Reuse(Id_In In 疾病诊断目录.Id%Type) Is
  v_Err_Msg Varchar2(100);
  Err_Item Exception;
Begin
  Update 疾病诊断目录
  Set 撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')
  Where ID = Id_In And 撤档时间 Is Not Null And 撤档时间 < To_Date('3000-01-01', 'yyyy-mm-dd');
  If Sql%NotFound Then
    v_Err_Msg := '[ZLSOFT]该项目已经被他人删除或启用,不能再启用![ZLSOFT]';
    Raise Err_Item;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_疾病诊断目录_Reuse;
/

--00000:梁唐彬,2016-02-19,门诊执行一卡通未收费的情况兼容检查
CREATE OR REPLACE Procedure Zl_门诊医嘱执行_Finish
( 
  医嘱id_In     病人医嘱执行.医嘱id%Type, 
  发送号_In     病人医嘱执行.发送号%Type, 
  单独执行_In   Number, 
  操作员编号_In 人员表.编号%Type, 
  操作员姓名_In 人员表.姓名%Type, 
  组id_In       病人医嘱执行.医嘱id%Type, 
  诊疗类别_In   病人医嘱记录.诊疗类别%Type, 
  执行部门id_In 门诊费用记录.执行部门id%Type 
  --参数：医嘱ID_IN=单独执行的医嘱ID，检验组合为显示的检验项目的ID。 
  --      单独执行_In=检验医嘱组合是否采用对每个项目分散单独执行的方式 
  --执行部门id_In=仅处理指定执行部门的费用，不传或传入0时不限制执行部门 
) Is 
  --医嘱相关的费用单据 
  Cursor c_No Is 
    Select a.No || ':' || a.记录性质 
    From 病人医嘱附费 A, 病人医嘱记录 B 
    Where a.发送号 + 0 = 发送号_In And a.医嘱id = b.Id And b.诊疗类别 = 诊疗类别_In And (b.Id = 组id_In Or b.相关id = 组id_In) 
    Union 
    Select NO || ':' || 记录性质 From 病人医嘱发送 Where 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In; 
 
  Cursor c_Noone Is 
    Select NO || ':' || 记录性质 
    From 病人医嘱附费 
    Where 发送号 + 0 = 发送号_In And 医嘱id = 医嘱id_In 
    Union 
    Select NO || ':' || 记录性质 From 病人医嘱发送 Where 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In; 
 
  r_No       t_Strlist; 
  r_No_Stuff t_Strlist; 
  r_Finish   t_Numlist; 
  v_Error Varchar2(2000); 
  Err_Custom Exception; 
  v_执行前先结算 Varchar2(500);
 
  Cursor c_Finish(r_No t_Strlist) Is 
    Select /*+ RULE */ 
     a.Id 
    From (Select Distinct a.Id, a.收费类别, a.收费细目id 
           From 门诊费用记录 A, 病人医嘱记录 B, 
                (Select Substr(Column_Value, 1, Instr(Column_Value, ':') - 1) As NO, 
                         To_Number(Substr(Column_Value, Instr(Column_Value, ':') + 1)) As 记录性质 
                  From Table(r_No)) N 
           Where a.医嘱序号 = b.Id And (b.Id = 组id_In Or b.相关id = 组id_In) And a.No = n.No And MOD(a.记录性质,10) = n.记录性质 And a.记录状态 In (0, 1, 3) And a.执行状态 <> 1 And 
                 (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In)) A, 材料特性 B 
    Where a.收费细目id = b.材料id(+) And Not a.收费类别 In ('5', '6', '7') And Not (a.收费类别 = '4' And Nvl(b.跟踪在用, 0) = 1); 
 
  Cursor c_Finishone(r_No t_Strlist) Is 
    Select /*+ RULE */ 
     a.Id 
    From (Select a.Id, a.收费类别, a.收费细目id 
           From 门诊费用记录 A, 
                (Select Substr(Column_Value, 1, Instr(Column_Value, ':') - 1) As NO, 
                         To_Number(Substr(Column_Value, Instr(Column_Value, ':') + 1)) As 记录性质 
                  From Table(r_No)) N 
           Where a.医嘱序号 = 医嘱id_In And a.No = n.No And MOD(a.记录性质,10) = n.记录性质 And a.记录状态 In (0, 1, 3)  And a.执行状态 <> 1 And 
                 (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In)) A, 材料特性 B 
    Where a.收费细目id = b.材料id(+) And Not a.收费类别 In ('5', '6', '7') And Not (a.收费类别 = '4' And Nvl(b.跟踪在用, 0) = 1); 
 
  --执行中包含跟踪在用的未发卫料时，根据参数设置是否自动发料 
  --卫生材料医嘱目前不存在单独和组合执行的情况 
  Cursor c_Stuff(r_No t_Strlist) Is 
    Select /*+ RULE */ 
     b.Id, Decode(d.高值材料, 1, a.执行部门id, b.库房id) As 库房id 
    From 门诊费用记录 A, 药品收发记录 B, 病人医嘱记录 C, 材料特性 D, 
         (Select Substr(Column_Value, 1, Instr(Column_Value, ':') - 1) As NO, 
                  To_Number(Substr(Column_Value, Instr(Column_Value, ':') + 1)) As 记录性质 
           From Table(r_No)) N 
    Where d.材料id = a.收费细目id And a.Id = b.费用id And Mod(b.记录状态, 3) = 1 And b.审核人 Is Null And b.库房id Is Not Null And 
          a.收费类别 = '4' And a.记录状态 = 1 And a.医嘱序号 = c.Id And c.诊疗类别 = 诊疗类别_In And (c.Id = 组id_In Or c.相关id = 组id_In) And 
          a.No = n.No And MOD(a.记录性质,10) = n.记录性质 And b.单据 = 24 And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In) 
    Order By b.库房id, b.药品id; 
 
  --未审核的费用行(包含药品和卫材) 
  Cursor c_Verify(r_No t_Strlist,记帐费用_In Number := 1) Is 
    Select /*+ RULE */ 
    Distinct a.No, a.序号 
    From 门诊费用记录 A, 病人医嘱记录 C, 
         (Select Substr(Column_Value, 1, Instr(Column_Value, ':') - 1) As NO, 
                  To_Number(Substr(Column_Value, Instr(Column_Value, ':') + 1)) As 记录性质 
           From Table(r_No)) N 
    Where NVL(a.记帐费用,0) = 记帐费用_In And a.记录状态 = 0 And a.价格父号 Is Null And a.医嘱序号 = c.Id And (c.Id = 组id_In Or c.相关id = 组id_In) And 
          a.No = n.No And MOD(a.记录性质,10) = n.记录性质 And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In) 
    Order By NO, 序号; 
 
  Cursor c_Verifyone(r_No t_Strlist,记帐费用_In Number := 1) Is 
    Select /*+ RULE */ 
     a.No, a.序号 
    From 门诊费用记录 A, 
         (Select Substr(Column_Value, 1, Instr(Column_Value, ':') - 1) As NO, 
                  To_Number(Substr(Column_Value, Instr(Column_Value, ':') + 1)) As 记录性质 
           From Table(r_No)) N 
    Where NVL(a.记帐费用,0) = 记帐费用_In And a.记录状态 = 0 And a.价格父号 Is Null And a.医嘱序号 + 0 = 医嘱id_In And a.No = n.No And MOD(a.记录性质,10) = n.记录性质 And 
          (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In) 
    Order By NO, 序号; 
 
  v_No   病人医嘱发送.No%Type; 
  v_序号 Varchar2(1000); 
 
  v_发料号  药品收发记录.汇总发药号%Type; 
  v_库房id  药品收发记录.库房id%Type; 
  v_收发ids Varchar2(4000); 
Begin 
  Open c_Noone; 
  Fetch c_Noone Bulk Collect 
    Into r_No_Stuff; 
  Close c_Noone; 
 
  If Nvl(单独执行_In, 0) = 0 Then 
    Open c_No; 
    Fetch c_No Bulk Collect 
      Into r_No; 
    Close c_No; 
  Else 
    r_No := r_No_Stuff; 
  End If; 
 
  --主费用可能需要限制医嘱序号 
  --不包含药品和跟踪在用的卫材，因为这些都要发放才表示执行 
  If Nvl(单独执行_In, 0) = 0 Then 
    Open c_Finish(r_No); 
    Fetch c_Finish Bulk Collect 
      Into r_Finish; 
    Close c_Finish; 
  Else 
    Open c_Finishone(r_No); 
    Fetch c_Finishone Bulk Collect 
      Into r_Finish; 
    Close c_Finishone; 
  End If; 
  Select Zl_Getsysparameter(163) Into v_执行前先结算 From Dual;
    
  Forall I In 1 .. r_Finish.Count   
    Update 门诊费用记录 Set 执行状态 = 1, 执行时间 = Sysdate, 执行人 = 操作员姓名_In Where ID = r_Finish(I); 
    
  --执行时自动审核对应的记帐划价单费用 
  --包含医嘱对应的药品及卫材费用，因为医嘱已执行，费用应该生效。 
    If nvl(单独执行_In,0) = 0 Then 
      If NVL(v_执行前先结算,'0') <> '0'   Then 
        For r_Verify In c_Verify(r_No,0) Loop 
          v_Error :=  '当前执行的医嘱还存在未收取的费用。'; 
          Raise Err_Custom; 
        End Loop; 
      End if;
      For r_Verify In c_Verify(r_No) Loop 
        If r_Verify.No <> v_No And v_序号 Is Not Null Then 
          Zl_门诊记帐记录_Verify(v_No, 操作员编号_In, 操作员姓名_In, Substr(v_序号, 2)); 
          v_序号 := Null; 
        End If; 
        v_No   := r_Verify.No; 
        v_序号 := v_序号 || ',' || r_Verify.序号; 
      End Loop; 
    Else 
      If NVL(v_执行前先结算,'0') <> '0'   Then 
        For r_Verify In c_Verifyone(r_No,0) Loop 
          v_Error :=  '当前执行的医嘱还存在未收取的费用。'; 
          Raise Err_Custom; 
        End Loop; 
      End if;
      For r_Verify In c_Verifyone(r_No) Loop 
        If r_Verify.No <> v_No And v_序号 Is Not Null Then 
          Zl_门诊记帐记录_Verify(v_No, 操作员编号_In, 操作员姓名_In, Substr(v_序号, 2)); 
          v_序号 := Null; 
        End If; 
        v_No   := r_Verify.No; 
        v_序号 := v_序号 || ',' || r_Verify.序号; 
      End Loop; 
    End If; 
    If v_序号 Is Not Null Then 
      Zl_门诊记帐记录_Verify(v_No, 操作员编号_In, 操作员姓名_In, Substr(v_序号, 2)); 
    End If; 
 
  --处理跟踪在用卫材自动发料 
    For r_Stuff In c_Stuff(r_No_Stuff) Loop 
      If v_发料号 Is Null Then 
        v_发料号 := Nextno(20); 
      End If; 
 
      If r_Stuff.库房id <> Nvl(v_库房id, 0) Then 
        If Nvl(v_库房id, 0) <> 0 And v_收发ids Is Not Null Then 
          v_收发ids := Substr(v_收发ids, 2); 
          Zl_药品收发记录_批量发料(v_收发ids, v_库房id, 操作员姓名_In, Sysdate, 1, 操作员姓名_In, v_发料号, 操作员姓名_In); 
        End If; 
        v_库房id  := r_Stuff.库房id; 
        v_收发ids := Null; 
      End If; 
 
      v_收发ids := v_收发ids || '|' || r_Stuff.Id || ',0'; 
    End Loop; 
    If Nvl(v_库房id, 0) <> 0 And v_收发ids Is Not Null Then 
      v_收发ids := Substr(v_收发ids, 2); 
      Zl_药品收发记录_批量发料(v_收发ids, v_库房id, 操作员姓名_In, Sysdate, 1, 操作员姓名_In, v_发料号, 操作员姓名_In); 
    End If; 
Exception 
  When Err_Custom Then 
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]'); 
  When Others Then 
    Zl_Errorcenter(Sqlcode, Sqlerrm); 
End Zl_门诊医嘱执行_Finish;
/

--93587:李业庆,2016-02-25,费用执行状态空值处理
Create Or Replace Procedure Zl_药品收发记录_处方发药
(
  Partid_In        In 药品收发记录.库房id%Type,
  Bill_In          In 药品收发记录.单据%Type,
  No_In            In 药品收发记录.No%Type,
  People_In        In 药品收发记录.审核人%Type,
  配药人_In        In 药品收发记录.配药人%Type := Null,
  校验人_In        In 药品收发记录.填制人%Type := Null,
  发药方式_In      In 药品收发记录.发药方式%Type := 1,
  发药时间_In      In 药品收发记录.审核日期%Type := Null,
  操作员编号_In    In 人员表.编号%Type := Null,
  操作员姓名_In    In 人员表.姓名%Type := Null,
  Intdigit_In      In Number := 2,
  Intautoverify_In In Number := 0,
  门诊_In          In Number := 1,
  核查人_In        In 药品收发记录.核查人%Type := Null,
  未取药_In        In 药品收发记录.是否未取药%Type := Null,
  汇总发药号_In    In 药品收发记录.汇总发药号%Type := Null
) Is
  --住院病人
  Cursor c_Modifybillin Is
    Select a.Id, a.药品id, a.入出类别id, a.入出系数, a.费用id, Nvl(a.实际数量, 0) * Nvl(a.付数, 1) 数量, Nvl(a.零售金额, 0) 金额, Nvl(a.批次, 0) 批次,
           a.供药单位id, a.成本价, a.批号, a.产地, a.效期, a.生产日期, a.批准文号, b.病人id, b.序号, Nvl(c.处方类型, Nvl(a.注册证号, 0)) 处方类型,
           Nvl(a.零售价, 0) As 零售价
    From 药品收发记录 A, 住院费用记录 B, 未发药品记录 C
    Where a.单据 = c.单据 And a.No = c.No And Nvl(a.库房id, 0) = Nvl(c.库房id, 0) And a.No = No_In And a.单据 = Bill_In And
          (a.库房id + 0 = Partid_In Or a.库房id Is Null) And Nvl(a.摘要, '小宝') <> '拒发' And a.费用id = b.Id And
          Nvl(b.执行状态, 0) <> 1 And Mod(a.记录状态, 3) = 1 And a.审核人 Is Null;

  --门诊病人
  Cursor c_Modifybillout Is
    Select a.Id, a.药品id, a.入出类别id, a.入出系数, a.费用id, Nvl(a.实际数量, 0) * Nvl(a.付数, 1) 数量, Nvl(a.零售金额, 0) 金额, Nvl(a.批次, 0) 批次,
           a.供药单位id, a.成本价, a.批号, a.产地, a.效期, a.生产日期, a.批准文号, b.病人id, b.序号, Nvl(c.处方类型, Nvl(a.注册证号, 0)) 处方类型,
           Nvl(a.零售价, 0) As 零售价, b.No, b.记录性质
    From 药品收发记录 A, 门诊费用记录 B, 未发药品记录 C
    Where a.单据 = c.单据 And a.No = c.No And Nvl(a.库房id, 0) = Nvl(c.库房id, 0) And a.No = No_In And a.单据 = Bill_In And
          (a.库房id + 0 = Partid_In Or a.库房id Is Null) And Nvl(a.摘要, '小宝') <> '拒发' And a.费用id = b.Id And
          Nvl(b.执行状态, 0) <> 1 And Mod(a.记录状态, 3) = 1 And a.审核人 Is Null
    Order By 药品id;

  v_Modifybillin  c_Modifybillin%RowType;
  v_Modifybillout c_Modifybillout%RowType;

  --只读变量
  Dbl差价率  Number;
  v_核查日期 药品收发记录.核查日期%Type;
  --可写变量
  Dbl实际金额       药品收发记录.零售金额%Type;
  Dbl成本金额       药品收发记录.成本金额%Type;
  Dbl实际差价       药品收发记录.差价%Type;
  Date操作时间      药品收发记录.审核日期%Type;
  Bln收费与发药分离 Number(1);
  n_平均成本价      药品库存.平均成本价%Type;
  v_填制人          药品收发记录.填制人%Type;
  v_Error           Varchar2(4000);
  Err_Custom Exception;
Begin
  --取发药时间
  If 发药时间_In Is Null Then
    Select Sysdate Into Date操作时间 From Dual;
  Else
    Date操作时间 := 发药时间_In;
  End If;

  v_核查日期 := Date操作时间;
  Begin
    Select 0 Into Bln收费与发药分离 From 未发药品记录 Where 单据 = Bill_In And NO = No_In And 库房id + 0 = Partid_In;
  Exception
    When Others Then
      Bln收费与发药分离 := 1;
  End;

  --重写已发药处方的配药人和汇总发药号
  Update 药品收发记录
  Set 配药人 = Decode(配药人_In, Null, 配药人, 配药人_In), 配药日期 = Decode(配药人_In, Null, 配药日期, Date操作时间), 汇总发药号 = 汇总发药号_In
  Where NO = No_In And 单据 = Bill_In And (库房id + 0 = Partid_In Or 库房id Is Null) And Mod(记录状态, 3) = 1 And 审核人 Is Not Null;

  Begin
    Select 填制人
    Into v_填制人
    From 药品收发记录
    Where NO = No_In And 单据 = Bill_In And 库房id + 0 = Partid_In And 审核日期 Is Null And Rownum = 1
    For Update Nowait;
  Exception
    When Others Then
      v_Error := '已有其他用户在执行发药，不能重复操作！';
      Raise Err_Custom;
  End;

  --重新计算成本价、成本金额、零售金额及差价
  If 门诊_In = 1 Then
    --处理门诊数据
    For v_Modifybillout In c_Modifybillout Loop
      n_平均成本价 := Round(Zl_Fun_Getoutcost(v_Modifybillout.药品id, v_Modifybillout.批次, Partid_In), 5);
      Dbl成本金额  := Round(n_平均成本价 * Nvl(v_Modifybillout.数量, 0), Intdigit_In);
      --零售金额
      Dbl实际金额 := Nvl(v_Modifybillout.金额, 0);
      --差价
      Dbl实际差价 := Round(Dbl实际金额 - Dbl成本金额, Intdigit_In);
    
      --更新药品收发记录的零售金额、成本金额、差价、审核人等信息
      Update 药品收发记录
      Set 成本价 = n_平均成本价, 成本金额 = Dbl成本金额, 差价 = Dbl实际差价, 库房id = Partid_In, 配药人 = Decode(配药人_In, Null, 配药人, 配药人_In),
          核查人 = 核查人_In, 核查日期 = v_核查日期, 配药日期 = Decode(配药人_In, Null, 配药日期, Date操作时间),
          填制人 = Decode(校验人_In, Null, 填制人, 校验人_In), 审核人 = Decode(People_In, Null, Zl_Username, People_In),
          审核日期 = Date操作时间, 发药方式 = 发药方式_In, 注册证号 = v_Modifybillout.处方类型, 是否未取药 = 未取药_In, 汇总发药号 = 汇总发药号_In
      Where ID = v_Modifybillout.Id;
    
      --处理库存
      Zl_药品库存_Update(v_Modifybillout.Id, 2, 1);
    
      --更新费用记录的执行状态(已执行)
      Update 门诊费用记录
      Set 执行状态 = 1, 执行人 = Decode(People_In, Null, Zl_Username, People_In), 执行部门id = Partid_In, 执行时间 = Date操作时间

      Where NO = v_Modifybillout.No And Mod(记录性质, 10) = v_Modifybillout.记录性质 And 记录状态 <> 2 And 序号 = v_Modifybillout.序号;
    
      --费用审核（重复审核也没有关系）
      If Intautoverify_In = 1 Then
        If Bill_In = 9 Then
          Zl_门诊记帐记录_Verify(No_In, 操作员编号_In, 操作员姓名_In, v_Modifybillout.序号, 发药时间_In);
        End If;
      End If;
    
      --处理调价修正
      Zl_药品收发记录_调价修正(v_Modifybillout.Id);
    End Loop;
  Else
    --处理住院数据
    For v_Modifybillin In c_Modifybillin Loop
      n_平均成本价 := Round(Zl_Fun_Getoutcost(v_Modifybillin.药品id, v_Modifybillin.批次, Partid_In), 5);
      Dbl成本金额  := Round(n_平均成本价 * Nvl(v_Modifybillin.数量, 0), Intdigit_In);
      --零售金额
      Dbl实际金额 := Nvl(v_Modifybillin.金额, 0);
      --差价
      Dbl实际差价 := Round(Dbl实际金额 - Dbl成本金额, Intdigit_In);
    
      --更新药品收发记录的零售金额、成本金额、差价、审核人等信息
      Update 药品收发记录
      Set 成本价 = n_平均成本价, 成本金额 = Dbl成本金额, 差价 = Dbl实际差价, 库房id = Partid_In, 配药人 = Decode(配药人_In, Null, 配药人, 配药人_In),
          核查人 = 核查人_In, 核查日期 = v_核查日期, 配药日期 = Decode(配药人_In, Null, 配药日期, Date操作时间),
          填制人 = Decode(校验人_In, Null, 填制人, 校验人_In), 审核人 = Decode(People_In, Null, Zl_Username, People_In),
          审核日期 = Date操作时间, 发药方式 = 发药方式_In, 注册证号 = v_Modifybillout.处方类型, 汇总发药号 = 汇总发药号_In
      Where ID = v_Modifybillin.Id;
    
      --处理库存
      Zl_药品库存_Update(v_Modifybillin.Id, 2, 1);
    
      --更新费用记录的执行状态(已执行)
      Update 住院费用记录
      Set 执行状态 = 1, 执行人 = Decode(People_In, Null, Zl_Username, People_In), 执行部门id = Partid_In, 执行时间 = Date操作时间

      
      Where ID = v_Modifybillin.费用id;
    
      --费用审核（重复审核也没有关系）
      If Intautoverify_In = 1 Then
        If Bill_In = 9 Then
          Zl_住院记帐记录_Verify(No_In, 操作员编号_In, 操作员姓名_In, v_Modifybillin.序号, v_Modifybillin.病人id, 发药时间_In);
        End If;
      End If;
    
      --处理调价修正
      Zl_药品收发记录_调价修正(v_Modifybillin.Id);
    End Loop;
  End If;

  --更新或删除未发药品记录
  Delete 未发药品记录 Where NO = No_In And 单据 = Bill_In And (库房id + 0 = Partid_In Or 库房id Is Null);

  If Bill_In = 8 Then
    Begin
      --移动支付宝项目在发药后动态调用生成推送信息的过程
      Execute Immediate 'Begin zl_服务窗消息_发送(:1,:2); End;'
        Using 6, No_In || ',' || Partid_In;
    Exception
      When Others Then
        Null;
    End;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_处方发药;
/

--93587:李业庆,2016-02-25,费用执行状态空值处理
Create Or Replace Procedure Zl_药品收发记录_更改库房
(
  Partid_In       In 药品收发记录.库房id%Type,
  Bill_In         In 药品收发记录.单据%Type,
  No_In           In 药品收发记录.No%Type,
  Otherstockid_In In 药品收发记录.库房id%Type,
  门诊_In         In Number := 1,
  Date_In         In 药品收发记录.填制日期%Type := Null
) Is
  --重新计算用
  Cursor c_Modifybillout Is
    Select a.Id, a.药品id, a.入出类别id, a.入出系数, a.费用id, Nvl(a.实际数量, 0) * Nvl(a.付数, 1) 数量, Nvl(a.零售金额, 0) 金额, Nvl(a.批次, 0) 批次,
           a.供药单位id, a.成本价, a.批号, a.产地, a.效期, a.生产日期, a.批准文号
    From 药品收发记录 A, 门诊费用记录 B
    Where a.No = No_In And a.单据 = Bill_In And (a.库房id + 0 = Otherstockid_In Or a.库房id Is Null) And
          Nvl(a.摘要, '小宝') <> '拒发' And a.费用id = b.Id And Nvl(b.执行状态, 0) <> 1 And a.审核人 Is Null;

  Cursor c_Modifybillin Is
    Select a.Id, a.药品id, a.入出类别id, a.入出系数, a.费用id, Nvl(a.实际数量, 0) * Nvl(a.付数, 1) 数量, Nvl(a.零售金额, 0) 金额, Nvl(a.批次, 0) 批次,
           a.供药单位id, a.成本价, a.批号, a.产地, a.效期, a.生产日期, a.批准文号
    From 药品收发记录 A, 住院费用记录 B
    Where a.No = No_In And a.单据 = Bill_In And (a.库房id + 0 = Otherstockid_In Or a.库房id Is Null) And
          Nvl(a.摘要, '小宝') <> '拒发' And a.费用id = b.Id And Nvl(b.执行状态, 0) <> 1 And a.审核人 Is Null;

  --用于修正病人未结费用
  Cursor c_Billout Is
    Select b.实收金额, b.病人id, 0 主页id, 0 病人病区id, b.病人科室id, b.开单部门id, b.执行部门id, b.收入项目id, b.门诊标志
    From 药品收发记录 A, 门诊费用记录 B
    Where a.费用id = b.Id And Nvl(b.执行状态, 0) <> 1 And a.No = No_In And a.单据 = Bill_In And
          (a.库房id + 0 = Otherstockid_In Or a.库房id Is Null) And Nvl(a.摘要, '小宝') <> '拒发' And a.审核人 Is Null And b.记录性质 = 2 And
          b.记录状态 = 1;

  Cursor c_Billin Is
    Select b.实收金额, b.病人id, b.主页id, b.病人病区id, b.病人科室id, b.开单部门id, b.执行部门id, b.收入项目id, b.门诊标志
    From 药品收发记录 A, 住院费用记录 B
    Where a.费用id = b.Id And Nvl(b.执行状态, 0) <> 1 And a.No = No_In And a.单据 = Bill_In And
          (a.库房id + 0 = Otherstockid_In Or a.库房id Is Null) And Nvl(a.摘要, '小宝') <> '拒发' And a.审核人 Is Null And b.记录性质 = 2 And
          b.记录状态 = 1;

  r_Modifybillout   c_Modifybillout%RowType;
  r_Modifybillin    c_Modifybillin%RowType;
  r_Billout         c_Billout%RowType;
  r_Billin          c_Billin%RowType;
  Bln收费与发药分离 Number(1);
  v_Count           Number;
Begin
  Begin
    Select 0
    Into Bln收费与发药分离
    From 未发药品记录
    Where 单据 = Bill_In And NO = No_In And 库房id + 0 = Otherstockid_In;
  Exception
    When Others Then
      Bln收费与发药分离 := 1;
  End;

  --增加原库房的可以库存，减现库房的可用库存
  If 门诊_In = 1 Then
    --处理门诊
    For r_Modifybillout In c_Modifybillout Loop
      If Bln收费与发药分离 = 0 Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) + Nvl(r_Modifybillout.数量, 0)
        Where 库房id + 0 = Otherstockid_In And 药品id = r_Modifybillout.药品id And 性质 = 1 And Nvl(批次, 0) = r_Modifybillout.批次;
      
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - Nvl(r_Modifybillout.数量, 0)
        Where 库房id + 0 = Partid_In And 药品id = r_Modifybillout.药品id And 性质 = 1 And Nvl(批次, 0) = r_Modifybillout.批次;
      
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 可用数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次产地, 效期, 上次生产日期, 批准文号)
          Values
            (Partid_In, r_Modifybillout.药品id, r_Modifybillout.批次, 1, 0 - Nvl(r_Modifybillout.数量, 0), 0, 0,
             r_Modifybillout.供药单位id, r_Modifybillout.成本价, r_Modifybillout.批号, r_Modifybillout.产地, r_Modifybillout.效期,
             r_Modifybillout.生产日期, r_Modifybillout.批准文号);
        End If;
      End If;
    End Loop;
  Else
    --处理住院
    For r_Modifybillin In c_Modifybillin Loop
      If Bln收费与发药分离 = 0 Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) + Nvl(r_Modifybillin.数量, 0)
        Where 库房id + 0 = Otherstockid_In And 药品id = r_Modifybillin.药品id And 性质 = 1 And Nvl(批次, 0) = r_Modifybillin.批次;
      
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - Nvl(r_Modifybillin.数量, 0)
        Where 库房id + 0 = Partid_In And 药品id = r_Modifybillin.药品id And 性质 = 1 And Nvl(批次, 0) = r_Modifybillin.批次;
      
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 可用数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次产地, 效期, 上次生产日期, 批准文号)
          Values
            (Partid_In, r_Modifybillin.药品id, r_Modifybillin.批次, 1, 0 - Nvl(r_Modifybillin.数量, 0), 0, 0,
             r_Modifybillin.供药单位id, r_Modifybillin.成本价, r_Modifybillin.批号, r_Modifybillin.产地, r_Modifybillin.效期,
             r_Modifybillin.生产日期, r_Modifybillin.批准文号);
        End If;
      End If;
    End Loop;
  End If;

  --处理发其它药房处方情况，改变库房ID
  If 门诊_In = 1 Then
    --处理门诊
    For r_Billout In c_Billout Loop
      --减原库房的未结费用
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) - Nvl(r_Billout.实收金额, 0)
      Where 病人id = r_Billout.病人id And Nvl(主页id, 0) = Nvl(r_Billout.主页id, 0) And
            Nvl(病人病区id, 0) = Nvl(r_Billout.病人病区id, 0) And Nvl(病人科室id, 0) = Nvl(r_Billout.病人科室id, 0) And
            Nvl(开单部门id, 0) = Nvl(r_Billout.开单部门id, 0) And Nvl(执行部门id, 0) = Nvl(r_Billout.执行部门id, 0) And
            收入项目id + 0 = r_Billout.收入项目id And 来源途径 + 0 = r_Billout.门诊标志;
    
      If Sql%RowCount <> 0 Then
        --增加现库房的未结费用
        Update 病人未结费用
        Set 金额 = Nvl(金额, 0) + Nvl(r_Billout.实收金额, 0)
        Where 病人id = r_Billout.病人id And Nvl(主页id, 0) = Nvl(r_Billout.主页id, 0) And
              Nvl(病人病区id, 0) = Nvl(r_Billout.病人病区id, 0) And Nvl(病人科室id, 0) = Nvl(r_Billout.病人科室id, 0) And
              Nvl(开单部门id, 0) = Nvl(r_Billout.开单部门id, 0) And Nvl(执行部门id, 0) = Partid_In And
              收入项目id + 0 = r_Billout.收入项目id And 来源途径 + 0 = r_Billout.门诊标志;
      
        If Sql%RowCount = 0 Then
          Insert Into 病人未结费用
            (病人id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
          Values
            (r_Billout.病人id, r_Billout.病人科室id, r_Billout.开单部门id, Partid_In, r_Billout.收入项目id, r_Billout.门诊标志,
             Nvl(r_Billout.实收金额, 0));
        End If;
      End If;
    End Loop;
  Else
    --处理住院
    For r_Billin In c_Billin Loop
      --减原库房的未结费用
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) - Nvl(r_Billin.实收金额, 0)
      Where 病人id = r_Billin.病人id And Nvl(主页id, 0) = Nvl(r_Billin.主页id, 0) And Nvl(病人病区id, 0) = Nvl(r_Billin.病人病区id, 0) And
            Nvl(病人科室id, 0) = Nvl(r_Billin.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(r_Billin.开单部门id, 0) And
            Nvl(执行部门id, 0) = Nvl(r_Billin.执行部门id, 0) And 收入项目id + 0 = r_Billin.收入项目id And 来源途径 + 0 = r_Billin.门诊标志;
    
      If Sql%RowCount <> 0 Then
        --增加现库房的未结费用
        Update 病人未结费用
        Set 金额 = Nvl(金额, 0) + Nvl(r_Billin.实收金额, 0)
        Where 病人id = r_Billin.病人id And Nvl(主页id, 0) = Nvl(r_Billin.主页id, 0) And
              Nvl(病人病区id, 0) = Nvl(r_Billin.病人病区id, 0) And Nvl(病人科室id, 0) = Nvl(r_Billin.病人科室id, 0) And
              Nvl(开单部门id, 0) = Nvl(r_Billin.开单部门id, 0) And Nvl(执行部门id, 0) = Partid_In And 收入项目id + 0 = r_Billin.收入项目id And
              来源途径 + 0 = r_Billin.门诊标志;
      
        If Sql%RowCount = 0 Then
          Insert Into 病人未结费用
            (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
          Values
            (r_Billin.病人id, r_Billin.主页id, r_Billin.病人病区id, r_Billin.病人科室id, r_Billin.开单部门id, Partid_In,
             r_Billin.收入项目id, r_Billin.门诊标志, Nvl(r_Billin.实收金额, 0));
        End If;
      End If;
    End Loop;
  End If;

  Delete From 病人未结费用 Where 金额 = 0;

  If 门诊_In = 1 Then
    Update 门诊费用记录
    Set 执行部门id = Partid_In
    Where ID In
          (Select Distinct 费用id From 药品收发记录 Where NO = No_In And 单据 = Bill_In And 库房id + 0 = Otherstockid_In);
  Else
    Update 住院费用记录
    Set 执行部门id = Partid_In
    Where ID In
          (Select Distinct 费用id From 药品收发记录 Where NO = No_In And 单据 = Bill_In And 库房id + 0 = Otherstockid_In);
  End If;

  --修改该单据所有记录(退药后再代发的情况)
  Update 药品收发记录 Set 库房id = Partid_In Where NO = No_In And 单据 = Bill_In And 库房id + 0 = Otherstockid_In;

  --修改未发药品记录
  Begin
    Select 1 Into v_Count From 未发药品记录 Where 库房id + 0 = Partid_In And NO = No_In And 单据 = Bill_In;
  Exception
    When Others Then
      v_Count := 0;
  End;

  If v_Count = 0 Then
    Update 未发药品记录 Set 库房id = Partid_In Where NO = No_In And 单据 = Bill_In And 库房id + 0 = Otherstockid_In;
  Else
    Delete 未发药品记录 Where NO = No_In And 单据 = Bill_In And 库房id + 0 = Otherstockid_In;
  End If;

  If Date_In Is Not Null Then
    Delete From 病人费用汇总 Where 日期 >= Date_In;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_更改库房;
/

--00000:梁唐彬,2016-03-09,脚本问题
Create Or Replace Function Zl_Dispensechspecs
(
  药名id_In   药品规格.药名id%Type,
  形态_In     药品规格.中药形态%Type, --0-散装，1-中药饮片，2-免煎剂
  数量_In     药品库存.可用数量%Type, --按剂量单位传入
  付数_In     药品库存.可用数量%Type,
  药房_In     药品库存.库房id%Type,
  分离发药_In Integer := 0, --分离分药模式,只能处理定价.不能处理实价药品
  场合_In     Number := 1, -- 1-门诊 ，2-住院
  药品ids_In  Varchar2 := Null --指定药品的分配
) Return Varchar2 As
  --返回:药品id,数量;药品id,数量;...(散装只选择一个规格)
  --                             不能完全分配时返回:剂量为6和10的情况下,17克的分配=23755,6;23756,10|1
  --                             不能分配时返回空,例如:剂量为6和10的情况下,3克的分配
  n_本次数量     药品库存.可用数量%Type;
  n_总数量       药品库存.可用数量%Type;
  n_包数         药品库存.可用数量%Type;
  n_总包数       药品库存.可用数量%Type;
  n_剩余数量     药品库存.可用数量%Type := 0;
  v_分配结果     Varchar2(1000);
  n_可用数量     药品库存.可用数量%Type;
  n_总数量tmp    药品库存.可用数量%Type;
  n_上次总数量   药品库存.可用数量%Type;
  n_本次数量tmp  药品库存.可用数量%Type;
  n_减少数量     药品库存.可用数量%Type;
  n_上次计量系数 药品库存.可用数量%Type;
  n_方式         药品出库检查.检查方式%Type;
  --Select Zl_Dispensechspecs(7366,2,28,1,76) as txt From dual
  --可能存在不同批次的,所以要汇总
  Cursor c_Medi(v_药品ids Varchar) Is
    Select a.药品id, b.剂量系数, Decode(场合_In, 2, b.住院可否分零, b.门诊可否分零) As 可否分零, Sum(a.可用数量) * b.剂量系数 可用数量
    From 药品库存 A, 药品规格 B, 收费项目目录 C
    Where a.药品id = b.药品id And b.药名id = 药名id_In And a.药品id = c.Id And Decode(分离发药_In, 1, c.是否变价, 0) = 0 And 库房id = 药房_In And
          a.性质 = 1 And b.中药形态 = 形态_In And (Nvl(a.批次, 0) = 0 Or a.效期 Is Null Or a.效期 > Trunc(Sysdate)) And
          (b.药品id In (Select Column_Value From Table(f_Num2list(v_药品ids))) Or v_药品ids Is Null)
    Group By a.药品id, b.剂量系数, Decode(场合_In, 2, b.住院可否分零, b.门诊可否分零)
    Having Nvl(Sum(a.可用数量), 0) > 0
    Order By b.剂量系数 Desc, 可用数量;
  --不限定库存的时候
  Cursor c_Medi_Nostock Is
    Select b.药品id, b.剂量系数, Decode(场合_In, 2, b.住院可否分零, b.门诊可否分零) As 可否分零, 数量_In As 可用数量
    From 药品规格 B, 收费项目目录 C
    Where b.药名id = 药名id_In And b.药品id = c.Id And b.中药形态 = 形态_In And
          (b.药品id In (Select Column_Value From Table(f_Num2list(药品ids_In))) Or 药品ids_In Is Null)
    Order By b.剂量系数 Desc;

  Type t_Medi Is Table Of c_Medi%Rowtype;
  r_Medi t_Medi;
Begin
  Open c_Medi(Null);
  Fetch c_Medi Bulk Collect
    Into r_Medi;
  Close c_Medi;
  n_可用数量 := 0;
  For J In 1 .. r_Medi.Count Loop
    n_可用数量 := n_可用数量 + r_Medi(J).可用数量;
  End Loop;

  If n_可用数量 < 数量_In Then
    Select Nvl(Max(检查方式), 0) Into n_方式 From 药品出库检查 Where 库房id = 药房_In;
    If n_方式 <> 2 Then
      Open c_Medi_Nostock;
      Fetch c_Medi_Nostock Bulk Collect
        Into r_Medi;
      Close c_Medi_Nostock;
      n_可用数量 := 0;
      For J In 1 .. r_Medi.Count Loop
        n_可用数量 := n_可用数量 + r_Medi(J).可用数量;
      End Loop;
    End If;
  Elsif 药品ids_In Is Not Null Then
    Open c_Medi(药品ids_In);
    Fetch c_Medi Bulk Collect
      Into r_Medi;
    Close c_Medi;
  End If;

  If Not r_Medi Is Null Then
    For J In 0 .. r_Medi.Count - 1 Loop
      --第二层循环是为了处理"大规格"优先时不能完成分配的情况,例如:剂量为6和10的情况下,12克的分配
      v_分配结果 := Null;
      n_总数量   := 数量_In;
      n_总包数   := 0;
      n_剩余数量 := 0;
      For I In 1 + J .. r_Medi.Count Loop
        --按剂量大小的倒序分配满足了"最少用包原则"
        --总数量(3)可能小于剂量系数(5),存在不能分零的情况
        --如果总数量刚好等于所有规格的库存之和,但大于任何一种规格的库存,这种特殊情况因处理复杂,实用价值不高,不处理(返回空)
        n_本次数量 := 0;
        n_包数     := 0;
        If n_总数量 <= r_Medi(I).可用数量 Then
          If n_总数量 >= r_Medi(I).剂量系数 Then
            If r_Medi(I).可否分零 = 1 Then
              --不分零
              n_包数     := Floor(n_总数量 / r_Medi(I).剂量系数);
              n_本次数量 := n_包数 * r_Medi(I).剂量系数;
            Else
              n_包数     := n_总数量 / r_Medi(I).剂量系数;
              n_本次数量 := n_总数量;
            End If;
          End If;
        
          --这里处理连续的两种规格分配时，大包用后，小包不能用的情况。比如：规格为小包为6g/包，大包为10g/包，现在总量是22g，如果是原来的方式，则是大包2包，余2g 分不尽，
          --                                                   现修改为在大包分了两包后，小包分不尽的时候，则将已分的大包循环减一个计量系数，这里大包的计量系数为10g，
          --                                                  已分了20g，现在减10g，就余下12g，然后小包就可以分尽了。最后结果就为大包 1包10g，小包2包12g。
          --如果中间隔了一个规格，本分支不能解决。比如：三个规格，前两种分不尽，后两种也分不尽，只有第一种和第三种才分的尽的，这种情况应该不多。
          If ((n_总数量 < r_Medi(I).剂量系数 And n_总数量 > 0) Or n_总数量 - n_本次数量 <> 0) And I <> 1 + J And v_分配结果 Is Not Null Then
            n_减少数量 := 0;
            --每次减上次的总量，都将减的数量累加起来。
            n_总数量tmp := n_总数量 + n_上次计量系数;
            n_减少数量  := n_减少数量 + n_上次计量系数;
            Loop
              --循环减，直到将上次分配的减完。
              Exit When n_总数量tmp >= n_上次总数量;
              If r_Medi(I).可否分零 = 1 Then
                --不分零的才会出现这种
                n_本次数量tmp := Floor(n_总数量tmp / r_Medi(I).剂量系数) * r_Medi(I).剂量系数;
              End If;
              --如果能够分尽，则更新本次的数量，并将上次的数量重新修改。
              If n_总数量tmp = n_本次数量tmp Then
                n_包数     := Floor(n_总数量tmp / r_Medi(I).剂量系数);
                n_本次数量 := n_本次数量tmp;
                If n_上次总数量 - n_总数量 - n_减少数量 = 0 Then
                  --如果上次分配的被减完了，则删除上次分配的结果。
                  v_分配结果 := Substr(v_分配结果, 1, Instr(v_分配结果, ';', -1) - 1);
                Else
                  v_分配结果 := Substr(v_分配结果, 1, Instr(v_分配结果, ',', -1)) || (n_上次总数量 - n_总数量 - n_减少数量);
                End If;
                --这里由于上次的数量发生了变化，所以总数量也要修改。
                n_总数量 := n_总数量 + n_减少数量;
                Exit;
              End If;
              n_总数量tmp := n_总数量tmp + n_上次计量系数;
              n_减少数量  := n_减少数量 + n_上次计量系数;
            End Loop;
          End If;
        
          If n_总数量 >= r_Medi(I).剂量系数 Then
            If 付数_In * n_本次数量 <= r_Medi(I).可用数量 Then
              If v_分配结果 Is Null Then
                v_分配结果 := r_Medi(I).药品id || ',' || n_本次数量;
              Else
                v_分配结果 := v_分配结果 || ';' || r_Medi(I).药品id || ',' || n_本次数量;
              End If;
            
              n_上次总数量   := n_总数量;
              n_总包数       := n_总包数 + n_包数;
              n_总数量       := n_总数量 - n_本次数量;
              n_上次计量系数 := r_Medi(I).剂量系数;
              If 形态_In = 0 Then
                Exit; --散装只能使用一种规格
              End If;
            End If;
          End If;
        Elsif n_总数量 >= r_Medi(I).剂量系数 And n_总数量 > r_Medi(I).可用数量 And n_总数量 <= n_可用数量 Then
          --处理了单个规格库存不足，但是所有规格的总数量够用的情况。（这里处理为如果某一个规格数量不足，就能用多少用多少）
          If r_Medi(I).可否分零 = 1 Then
            --不分零
            n_包数     := Floor(r_Medi(I).可用数量 / r_Medi(I).剂量系数);
            n_本次数量 := n_包数 * r_Medi(I).剂量系数;
          Else
            n_包数     := r_Medi(I).可用数量 / r_Medi(I).剂量系数;
            n_本次数量 := r_Medi(I).可用数量;
          End If;
        
          If 付数_In * n_本次数量 <= n_可用数量 Then
            If v_分配结果 Is Null Then
              v_分配结果 := r_Medi(I).药品id || ',' || n_本次数量;
            Else
              v_分配结果 := v_分配结果 || ';' || r_Medi(I).药品id || ',' || n_本次数量;
            End If;
            n_上次总数量   := n_总数量;
            n_总包数       := n_总包数 + n_包数;
            n_总数量       := n_总数量 - n_本次数量;
            n_可用数量     := n_可用数量 - n_本次数量;
            n_上次计量系数 := r_Medi(I).剂量系数;
            If 形态_In = 0 Then
              Exit; --散装只能使用一种规格
            End If;
          End If;
        End If;
      End Loop;
      If n_总数量 = 0 Then
        n_剩余数量 := 0;
        Exit;
      Elsif n_剩余数量 = 0 And v_分配结果 Is Not Null Then
        n_剩余数量 := n_总数量;
      End If;
    End Loop;
  End If;

  If n_总数量 = 0 Or n_剩余数量 <> 0 Then
    --检查是否适用"倍量优先原则"
    If n_剩余数量 <> 0 Then
      n_总数量 := 数量_In - n_剩余数量;
    Else
      n_总数量 := 数量_In;
    End If;
    For I In 1 .. r_Medi.Count Loop
      If n_总数量 >= r_Medi(I).剂量系数 And n_总数量 <= r_Medi(I).可用数量 Then
        n_包数     := Floor(n_总数量 / r_Medi(I).剂量系数);
        n_本次数量 := n_包数 * r_Medi(I).剂量系数;
        If n_总数量 = n_本次数量 And 付数_In * n_本次数量 <= r_Medi(I).可用数量 Then
          If n_包数 <= n_总包数 Then
            If n_剩余数量 <> 0 Then
              v_分配结果 := r_Medi(I).药品id || ',' || n_本次数量 || '|' || n_剩余数量;
            Else
              v_分配结果 := r_Medi(I).药品id || ',' || n_本次数量;
            End If;
          End If;
          Exit;
        End If;
      End If;
    End Loop;
  
    Return v_分配结果;
  Else
    Return Null;
  End If;
End Zl_Dispensechspecs;
/


--脚本
Delete from zlFilesUpgrade Where UPPER(文件名)='ZL9PACSIMAGECAP.DLL';
Insert Into zlFilesUpgrade (文件类型,文件名,版本号,修改日期,所属系统,业务部件,安装路径,文件说明,强制覆盖,自动注册,加入日期,序号) select 1,'ZL9PACSIMAGECAP.DLL','', Null ,'1','','[Appsoft]\Apply','','0','1',sysdate,序号 from Dual a,(Select max(to_number(序号))+1 序号 from zlfilesupgrade) b where not exists (select 1 from zlfilesupgrade where upper(文件名)='ZL9PACSIMAGECAP.DLL');

Delete from zlFilesUpgrade Where UPPER(文件名)='ZLLOGIN.DLL';
Insert Into zlFilesUpgrade (文件类型,文件名,版本号,修改日期,所属系统,业务部件,安装路径,文件说明,强制覆盖,自动注册,加入日期,序号) select 0,'ZLLOGIN.DLL','', Null ,'1','','[Appsoft]\Public','','0','1',sysdate,序号 from Dual a,(Select max(to_number(序号))+1 序号 from zlfilesupgrade) b where not exists (select 1 from zlfilesupgrade where upper(文件名)='ZLLOGIN.DLL');


Delete from zlFilesUpgrade Where UPPER(文件名)='ZLREGISTER.DLL';
Insert Into zlFilesUpgrade (文件类型,文件名,版本号,修改日期,所属系统,业务部件,安装路径,文件说明,强制覆盖,自动注册,加入日期,序号) select 0,'ZLREGISTER.DLL','', Null ,'1','','[Appsoft]\Public','','0','1',sysdate,序号 from Dual a,(Select max(to_number(序号))+1 序号 from zlfilesupgrade) b where not exists (select 1 from zlfilesupgrade where upper(文件名)='ZLREGISTER.DLL');

Delete from zlFilesUpgrade Where UPPER(文件名)='REGCOM.DLL';
Insert Into zlFilesUpgrade (文件类型,文件名,版本号,修改日期,所属系统,业务部件,安装路径,文件说明,强制覆盖,自动注册,加入日期,序号) select 0,'REGCOM.DLL','', Null ,'','','[SYSTEM]','自动升级文件','0','1',sysdate,序号 from Dual a,(Select max(to_number(序号))+1 序号 from zlfilesupgrade) b where not exists (select 1 from zlfilesupgrade where upper(文件名)='REGCOM.DLL');



---------------------------------------------------------------------------------------------------
--更改系统及部件的版本号
-------------------------------------------------------------------------------------------------------
--系统版本号
Update zlSystems Set 版本号='10.35.10' Where 编号=&n_System;
--部件版本号
Commit;
