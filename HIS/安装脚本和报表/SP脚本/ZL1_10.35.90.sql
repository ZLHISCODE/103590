--[连续升级]1
--[管理工具版本号]10.35.90
--本脚本支持从ZLHIS+ v10.35.80 升级到 v10.35.90
--请以系统所有者登录PLSQL并执行下列脚本
--脚本执行后，请手工升级导出报表
Define n_System=100;
-------------------------------------------------------------------------------
--结构修正部份
-------------------------------------------------------------------------------
--121281:蒋廷中,2018-02-11,病人医嘱发送增加状态说明字段
Alter Table 病人医嘱发送 Add 状态说明 Varchar2(200);

--121369:冉俊明,2018-02-07,停诊安排可以对医生的多个号源进行选择停诊
Alter Table 临床出诊停诊记录 Add 停诊号码 Varchar2(600);

--121419:刘鹏飞,2018-02-06,用血申请医生确定血液信息
Alter table 输血申请项目 add 血液信息 varchar2(200);

--121587:冉俊明,2018-02-06,临床出诊号源安排分站点进行维护
Alter Table 临床出诊表 Add 站点 Varchar2(1);
Alter Table 临床出诊表 Drop Constraint 临床出诊表_UQ_出诊表名 Cascade drop Index;
Alter Table 临床出诊表 Add Constraint 临床出诊表_UQ_年份 Unique(年份, 月份, 周数, 出诊表名, 排班方式, 站点) Using Index Tablespace Zl9indexhis;

--121076:秦龙,2018-02-05,增加生产商长度
Alter Table 药品生产商 Modify 名称 Varchar2(200);

Alter Table 药品生产商对照 Modify 厂家名称 Varchar2(200);

Alter Table 收费项目目录 Modify 产地 Varchar2(200);

Alter Table 药品收发记录 Modify 产地 Varchar2(200);

Alter Table 药品库存 Modify 上次产地 Varchar2(200);

Alter Table 药品规格 Modify 上次产地 Varchar2(200);

Alter Table 药品批号对照 Modify 生产厂家 Varchar2(200);

Alter Table 药品计划内容 Modify 上次生产商 Varchar2(200);

Alter Table 药品价格记录 Modify 产地 Varchar2(200);

Alter Table 药品退药计划 Modify 产地 Varchar2(200);

--117750:殷瑞,2018-01-29,新增按给药途径的配置费收取方案
alter table 配置收费方案 add 诊疗ID number(18);
ALTER TABLE 配置收费方案 ADD CONSTRAINT 配置收费方案_FK_诊疗ID FOREIGN KEY (诊疗ID) REFERENCES 诊疗项目目录(ID)  On Delete Cascade;
alter table 配置收费方案 drop constraint 配置收费方案_PK Cascade Drop index;
alter table 配置收费方案 add constraint  配置收费方案_UQ_项目ID Unique (项目ID,诊疗ID,配药类型) Using Index Tablespace zl9Indexhis;
alter table 配置收费方案 Modify 项目ID Constraint 配置收费方案_NN_项目ID Not Null;
Create Index 配置收费方案_IX_诊疗ID On 配置收费方案(诊疗ID) Tablespace zl9Indexhis;

--118584:刘兴洪,2018-01-24,增加免挂号模式
ALTER TABLE 病人挂号记录 ADD 取号标志 NUMBER(2);

--94246:胡俊勇,2018-01-23,将开单人字段变长，可以储存实习医生与审核医生
Alter table 门诊费用记录 modify 开单人 varchar2(41);
Alter table 住院费用记录 modify 开单人 varchar2(41);

--105001:胡俊勇,2018-01-22,医嘱中药医嘱内容多行打印
Alter Table 病人医嘱打印 Add 医嘱内容 VARCHAR2(1000);

--110624:刘涛,2018-01-22,药品收发记录增加修改人（日期）字段
Alter Table 药品收发记录 Add(修改人 VARCHAR2(20),修改日期 DATE);

--113951:蒋廷中,2018-01-17,手术授权管理模块增加权限授权审核
Create Table 人员手术权限申请(
    ID number(18),
    申请人 VARCHAR2(20),
    申请时间 Date,
    授权人员ID number(18),
    诊疗项目ID number(18),
    权限 number(1),
    审核状态 number(1),
    审批人 VARCHAR2(20),
    审批时间 Date
)
TABLESPACE zl9BaseItem;

Create Sequence 人员手术权限申请_ID Start With 1;

Alter Table 人员手术权限申请 Add Constraint 人员手术权限申请_Pk Primary Key(ID) Using Index Tablespace zl9Indexhis;

Create Index 人员手术权限申请_IX_诊疗项目ID On 人员手术权限申请(诊疗项目ID) Tablespace zl9Indexhis;

Create Index 人员手术权限申请_IX_授权人员ID On 人员手术权限申请(授权人员ID) Tablespace zl9Indexhis;

--119743:刘兴洪,2018-01-12,根据挂号单生成划价记录
ALTER TABLE 病人挂号记录 MODIFY 收费单 varchar2(2000);

--109990:刘涛,2018-01-12,药品批号对照修改
alter table 药品批号对照 add 供应商ID Number(18);

Alter Table 药品批号对照 Add Constraint 药品批号对照_FK_供应商ID Foreign Key (供应商ID) References 供应商(ID);
Create Index 药品批号对照_IX_供应商ID on 药品批号对照(供应商ID) Tablespace zl9Indexhis;

--118402:秦龙,2018-01-09,新增字段加成率
Alter Table 材料特性 Add(加成率 Number(16, 5));

--119449:刘硕,2018-01-04,消息集成修改完善
alter table zlMsg_Lists add using number(1) default 0;
alter table Zlmsg_Todo drop constraint Zlmsg_Todo_FK_Msg_Code;
--111037:余伟节,2018-01-04,婴儿死亡增加死亡时间录入
Alter Table 病人新生儿记录 Add 死亡时间 Date;

--117676:胡俊勇,2017-12-27,病人危急值结构相关
Drop Index 病人危急值记录_IX_报告科室ID;
Drop Index 病人危急值记录_IX_确认时间;
Drop Index 病人危急值记录_IX_确认科室ID;

--116247:秦龙,2017-12-26,新增属性“性质”
Alter table 药品用法用量 add (性质 number(1));

--118197:董露露,2017-12-25，过敏源结构化录入
CREATE TABLE 过敏源(
  编码 VARCHAR2(5),
  名称 VARCHAR2(100),
  简码 VARCHAR2(10),
  缺省标志 NUMBER(1) default 0
)TABLESPACE zl9BaseItem;

Alter Table 过敏源 Add Constraint 过敏源_PK Primary Key (编码) Using Index Tablespace zl9Indexhis;

Alter Table 过敏源 Add Constraint 过敏源_UQ_名称 Unique (名称) Using Index Tablespace zl9Indexhis;

--00000:余伟节,2017-12-25,脚步检查门诊临床路径
Create Sequence 门诊路径报表目录_ID Start With 1;

--118837:刘鹏飞,2017-12-22,输血申请新增输血同意书和评估选项
alter table 输血申请记录 add 是否签订同意书 number(1);

alter table 输血申请记录 add 是否已评估 number(1);

--118802:刘涛,2017-12-21,药品卫材验收结论处理
create table 入库验收结论
(
  编码   VARCHAR2(3),
  名称   VARCHAR2(100),
  缺省标志 NUMBER(1) default 0
)
tablespace ZL9BASEITEM;

alter table 药品收发记录 add 验收结论 varchar2(100);

alter table 药品验收明细 add 验收结论 varchar2(100);

alter table 入库验收结论 add constraint 入库验收结论_PK primary key (编码) using index tablespace ZL9INDEXHIS;

alter table 入库验收结论 add constraint 入库验收结论_UQ_名称 unique (名称) using index tablespace ZL9INDEXHIS;

--116073:黄捷,2017-12-15,RIS接口支持多HIS库
create table RIS分院设置
(
  id     NUMBER(18),
  医院名称   VARCHAR2(100),
  医院代码   VARCHAR2(20),
  用户名    VARCHAR2(30),
  密码     VARCHAR2(20),
  数据库服务名 VARCHAR2(30)
)
tablespace ZL9CISREC;

alter table RIS分院设置 add constraint RIS分院设置_PK primary key (ID) using index tablespace ZL9INDEXHIS;
alter table RIS分院设置 add constraint RIS分院设置_UQ_医院代码 unique (医院代码) using index tablespace ZL9INDEXHIS;

--116339:陈刘,2017-12-14,记录项目管理√符号设置修改
alter table 护理记录项目 add 缺省值 VARCHAR2(100);

--113016:胡俊勇,2017-12-13,门诊常用诊断
Alter Table 医生常用诊断 Add 诊断类型 number(2);

Alter Table 医生常用诊断 Drop Constraint 医生常用诊断_UQ_人员ID Cascade drop Index;

Alter Table 医生常用诊断 Add Constraint 医生常用诊断_UQ_人员ID Unique (人员ID,科室ID,诊断名称,疾病ID,诊断ID,诊断类型) Using Index Tablespace zl9Indexcis;

--116632:刘涛,2017-12-08,增加药品结存汇总表
CREATE TABLE 药品结存汇总
(
  结存id NUMBER(18),
  入出系数 NUMBER(2),
  入出类别id NUMBER(18),
  库房id NUMBER(18),
  药品id NUMBER(18),
  批次 NUMBER(18),
  数量 NUMBER(16,5),
  金额 NUMBER(16,5),
  差价 NUMBER(16,5))
  TABLESPACE zl9MedLst
  PCTFREE 5;

Alter Table 药品结存汇总 Add Constraint 药品结存汇总_PK Primary Key (结存id,入出类别id,库房id,药品id,批次) Using Index Tablespace zl9indexhis;

--115082:董露露,2017-12-06,解决病区床位管理和护士站床位排序的问题
alter table 床位状况记录 add 顺序号 NUMBER(10,1);

--101765:秦龙,2017-12-06,增加属性“是否辅助用药”
Alter table 药品特性 add (是否辅助用药 number(1));

--117919:蒋敏,2017-12-05,将Long Raw类型转换为BLOB或者CLOB类型
Alter Table 咨询图片元素 Modify 图形 Blob;
Alter Table 咨询段落目录 Modify 段落文本 Clob;
Alter Table 病人照片 Modify 照片 Blob;

Declare  
  Cursor c_失效索引 Is
    Select 'alter index ' || Index_Name || ' rebuild' As 索引
    From User_Indexes
    Where Table_Name In ('咨询图片元素','咨询段落目录', '病人照片') And Status = 'UNUSABLE';
Begin
For r_失效索引 In c_失效索引 Loop
    Execute Immediate r_失效索引.索引;
  End Loop;
End;
/

--117770:董露露,2017-12-05,解决重症监护器械及导管使用情况登记的问题
Alter Table 器械导管使用情况 Drop Constraint 器械导管使用情况_PK Cascade Drop Index;
Alter Table 器械导管使用情况 Add Constraint 器械导管使用情况_PK Primary Key (病人ID, 主页ID, 序号, 器械及导管, 开始使用时间) Using Index Tablespace ZL9INDEXHIS;

--113098:余伟节,2017-12-04,路径医嘱变动双审核
Alter Table 路径医嘱变动 Add 药剂审核人 VARCHAR2(100);

Alter Table 路径医嘱变动 Add 药剂审核时间 date;

--116632:刘涛,2017-12-08,增加药品结存汇总表
Alter Table 药品结存汇总 Add Constraint 药品结存汇总_FK_结存id Foreign Key (结存id) References 药品结存记录(ID) On Delete Cascade;
Alter Table 药品结存汇总 Add Constraint 药品结存汇总_FK_库房id Foreign Key (库房id) References 部门表(ID);
Alter Table 药品结存汇总 Add Constraint 药品结存汇总_FK_药品ID Foreign Key (药品ID) References 收费项目目录(ID);
Alter Table 药品结存汇总 Add Constraint 药品结存汇总_FK_入出类别id Foreign Key (入出类别id) References 药品入出类别(ID);

Create Index 药品结存汇总_IX_药品id On 药品结存汇总(药品id) Tablespace zl9Indexhis;
Create Index 药品结存汇总_IX_结存id On 药品结存汇总(结存id) Tablespace zl9Indexhis;
Create Index 药品结存汇总_IX_库房id On 药品结存汇总(库房id) Tablespace zl9Indexhis;
Create Index 药品结存汇总_IX_入出类别id On 药品结存汇总(入出类别id) Tablespace zl9Indexhis;

--000000:刘硕,2017-12-11,删除无用索引
Drop index ZLMSG_TODO_IX_CREATE_MSG_CODE;

--119638:陈福容,2018-01-08，更改段落文本为CLOB，需要增加字段进行处理
Alter Table 咨询段落目录 Add 段落类型 Number(3);

--113951:蒋廷中,2018-01-17,手术授权管理模块增加权限授权审核
Alter Table 人员手术权限申请 Add Constraint 人员手术权限申请_Fk_授权人员ID Foreign Key(授权人员ID) References 人员表(ID) On Delete Cascade;
Alter Table 人员手术权限申请 Add Constraint 人员手术权限申请_FK_诊疗项目ID Foreign Key (诊疗项目ID) References 诊疗项目目录(ID) On Delete Cascade;
-------------------------------------------------------------------------------
--数据修正部份
-------------------------------------------------------------------------------
--121952:殷瑞,2018-02-08,修正表的分类
Update Zltables Set 表空间 = 'ZL9BASEITEM', 分类 = 'A2' Where 表名 = '配液台' And 系统 = 100;

--121366:刘涛,2018-02-08,入库产地信息取值方式
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
Values
  (Zlparameters_Id.Nextval, &n_System, -null, -null, -null, -null, -null, 0, 0, 294, '优先取目录中产地信息', '0', '0',
   '在药品入库时，根据该参数值确定药品是否需要优选取目录中的产地和批准文号', '0-不优先取目录中的产地、批准文号,1-优先取目录中的产地、批准文号', Null, Null, Null);

--121393:刘兴洪,2018-02-07,增加住院预交票据相关设置
UPDATE zlparameters SET 参数值含义='格式:使用类别1,格式1|使用类别2,格式2'||CHR(13)||'预交类别:1-门诊预交,2-住院预交'||CHR(13)||'其中的格式值为:0-使用本地缺省格式,>0:票据格式序号',
影响控制说明 ='控制在完成缴预交或转预交时,根据预交类别决定打印哪种格式的票据',
关联说明='需要结合参数"预交发票打印方式"中是否打印来进行控制:'||CHR(13)||'a)如果打印或提示选择打印,则本参数有效'||CHR(13)||'b)如果不打印或提示选择不打印,则本参数无效.',
适用说明='一般应用于门诊预交或住院预交格式不同的情况。'
WHERE 模块=1107 AND 参数名='预交发票格式' AND 系统=&n_System;

UPDATE zlparameters SET 参数值含义='格式:预交类别1,打印方式1|预交类别2,打印方式2|...'||CHR(13)||'预交类别:1-门诊预交,2-住院预交'||CHR(13)||'打印方式:0-不打印,1-自动打印,2-选择是否打印',
影响控制说明 ='在预交发票打印方式中当缴预交完成后控制门诊(或住院)预交收据的打印:'||CHR(13)||'a)如果本参数设置为不打印,则不打印预交收据'||CHR(13)||'b)如果本参数设置为自动打印,则预交完成后将自动打印预交收据'||CHR(13)||'c)如果本参数设置为选择是否打印,则预交完成后,提示用户是否打印预交收据,选择"是"将打印,否则不打印',
关联说明='需要结合参数"票号严格控制"中收费是否严格控制来进行控制:'||CHR(13)||'a.如果严格控制,则打印的门诊或住院预交收据必须先进行领用,然后才能正常打印.'||CHR(13)||'b.如果为不严格控制,则在预交时,必须输入一个票号才能正常打印'
WHERE 模块=1107 AND 参数名='预交发票打印方式' AND 系统=&n_System;

--121419:刘鹏飞,2018-02-06,用血申请医生确定血液信息
Insert Into Zlparameters
  (Id, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
Values
  (Zlparameters_Id.Nextval, &n_System, -null, -null, -null, -null, -null, 0, 0, 293, '下达用血申请时确定发血信息', Null, '0',
   '启用血库系统且通过申请单下达输血用血申请时，决定是否要确定具体发放的血液信息才能下达申请', '0-选择品种输入申请量即可,1-选择品种必须确定具体的血液信息，且不能修改申请量',
   '只有启用236号参数[启用血库管理系统]，才允许设置此参数，以及控制用血申请下达的模式', '此模式在院内管理不严格的情况下，可正确保证用血申请量和发血信息的一致性', Null);

--121694:焦博,2018-02-06,调整私有模块参数变价输入数次的关联说明
update zlParameters set 关联说明='只有在录入收费类别为非药品和非跟踪卫材才有效' where 系统=&n_System and 模块=1257 and 参数名='变价输入数次';

--118987:焦博,2018-02-06,公共参数挂号排班模式的参数值含义
update zlParameters set 参数值含义='格式:模式|启用日期'||chr(10)||'模式:0-计划排班模式,1-出诊表排班模式'||chr(10)||'启用日期:yyyy-mm-dd hh24:mi:ss' where 系统=&n_System and 模块 is null and 参数号=256;

--121587:冉俊明,2018-02-06,临床出诊号源安排分站点进行维护
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1114, 0, 0, 0, 0, 0, 0, 10, '未区分站点的号源的维护站点', Null, Null,
         '未区分院区的科室的号源由哪个院区来维护出诊安排', '设置的维护未区分院区的科室的号源的院区编号', Null, '适用于临床出诊安排不同院区的号源维护个性化', Null
  From Dual;

--121587:冉俊明,2018-02-06,临床出诊号源安排分站点进行维护
--根据站点拆分临床出诊表 ,每个站点的号源及安排各自独立维护
Declare
  n_出诊id 临床出诊表.Id%Type;

  n_无站点   Number;
  n_有站点   Number;
  v_最小站点 部门表.站点%Type;
Begin
  --1.升级已有出诊表的站点为该出诊表中的号源站点编号最小的站点
  For r_出诊表 In (Select m.Id, Min(d.站点) As 站点
                From 临床出诊表 M, 临床出诊安排 A, 临床出诊号源 B, 部门表 D
                Where a.号源id = b.Id And b.科室id = d.Id And a.出诊id = m.Id And m.站点 Is Null
                Group By m.Id) Loop
    Update 临床出诊表 Set 站点 = r_出诊表.站点 Where ID = r_出诊表.Id;
  End Loop;

  --2.拆分出诊表
  For r_出诊表 In (Select ID, 排班方式, 出诊表名, 年份, 月份, 周数, 应用范围, 科室id, 备注, 发布人, 发布时间, 模板类型, Nvl(站点, '-') As 站点
                From 临床出诊表) Loop
    --2.1将不分站点的号源保留在已有出诊表中进行维护
    For r_安排 In (Select a.Id, d.站点
                 From 临床出诊安排 A, 临床出诊号源 B, 部门表 D
                 Where a.号源id = b.Id And b.科室id = d.Id And a.出诊id = r_出诊表.Id And d.站点 Is Not Null) Loop
      /*--2.1将不分站点的号源放在编号为2的站点进行维护
      For r_安排 In (Select a.Id, Nvl(d.站点, '2') As 站点
                   From 临床出诊安排 A, 临床出诊号源 B, 部门表 D
                   Where a.号源id = b.Id And b.科室id = d.Id And a.出诊id = r_出诊表.Id) Loop*/
      If r_安排.站点 <> r_出诊表.站点 Then
        Begin
          Select ID
          Into n_出诊id
          From 临床出诊表
          Where 排班方式 = r_出诊表.排班方式 And 出诊表名 = r_出诊表.出诊表名 And Nvl(年份, 0) = Nvl(r_出诊表.年份, 0) And
                Nvl(月份, 0) = Nvl(r_出诊表.月份, 0) And Nvl(周数, 0) = Nvl(r_出诊表.周数, 0) And 站点 = r_安排.站点;
        Exception
          When Others Then
            n_出诊id := Null;
        End;
      
        If Nvl(n_出诊id, 0) = 0 Then
          Select 临床出诊表_Id.Nextval Into n_出诊id From Dual;
          Insert Into 临床出诊表
            (ID, 排班方式, 出诊表名, 年份, 月份, 周数, 应用范围, 科室id, 备注, 发布人, 发布时间, 模板类型, 站点)
          Values
            (n_出诊id, r_出诊表.排班方式, r_出诊表.出诊表名, r_出诊表.年份, r_出诊表.月份, r_出诊表.周数, r_出诊表.应用范围, r_出诊表.科室id, r_出诊表.备注, r_出诊表.发布人,
             r_出诊表.发布时间, r_出诊表.模板类型, r_安排.站点);
        End If;
      
        Update 临床出诊安排 Set 出诊id = n_出诊id Where ID = r_安排.Id;
      End If;
    End Loop;
  End Loop;

  --如果出诊表既有分站点的，又有不分站点的，则将不分站点的修正为最小站点
  Select Sum(Decode(站点, Null, 1, 0)), Sum(Decode(站点, Null, 0, 1)), Min(站点)
  Into n_无站点, n_有站点, v_最小站点
  From 临床出诊表;
  If Nvl(n_有站点, 0) > 0 And Nvl(n_无站点, 0) > 0 Then
    Update 临床出诊表 Set 站点 = v_最小站点 Where 站点 Is Null;
  End If;
End;
/

--121591:冉俊明,2018-02-06,临床出诊号源的号码排序方式调整
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1114, 0, 0, 0, 0, 0, 0, 11, '号码排序比较方式', Null, '1', '该参数设置后将影响临床出诊号源及临床出诊安排中根据号码排序后的显示结果',
         '号源号码按哪种比较方式进行排序：0-按字符比较，1-按数值比较', Null, '适用于临床出诊安排中号源号码的排序个性化设置', Null
  From Dual;

--121059:李业庆,2018-02-05,部门发药时检查项目
Insert Into Zlparameters
  (Id, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System,1342, 1, 1,0,0, 0, 0, 30, '发药时检查存储库房', '0', '0',
         '在发药时检查药品是否设置了存储库房', '0-不检查，1-检查', '', '正常业务模式不需要检查，因为上游业务能开药品已经检查了存储库房；特殊情况如果药品经常要改进存储库房则要检查',null
  From Dual;  

Insert Into Zlparameters
  (Id, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System,1342, 1, 1,0,0, 0, 0, 31, '发药时检查销帐申请数据', '0', '0',
         '在发药时检查药品是否有销帐申请数据', '0-不检查，1-检查', '', '正常业务模式不需要检查；如果要控制发药药品没有销帐申请数据时需要检查',null
  From Dual;  

--119449:刘硕,2018-01-04,消息集成修改完善
Insert Into zlAutoJobs(系统,类型,序号,名称,说明,内容,参数,执行时间,间隔时间,时间单位,作业号) Values( &n_System,1,13,'集成平台消息清理','用于自动清理过期的集成平台业务消息。','Zl1_Auto_Clear_Zlmsg_To',NULL,Trunc(Sysdate)+1/24,1,'天',-NULL ); 

--119643:李南春,2018-02-02,消息发送内容调整
update Zlmsg_Lists set Note ='病人信息管理:修改病人信息时;门诊医生工作站:首页编辑，修改病人信息时;住院医生工作站:首页编辑，修改病人信息时;体检中心管理:新病人登记体检任务时;检验技师工作站:登记病人;门诊挂号管理:门诊病人挂号修改信息时'
Where code ='ZLHIS_PATIENT_016';

update Zlmsg_Lists set Note ='病人收费管理:门诊收费结算完成时;病人补充结算:补充结算完成时' Where code ='ZLHIS_CHARGE_002';

update Zlmsg_Lists set Note ='病人收费管理:门诊收费单进行退费后;病人补充结算:补结算进行退费后' Where code ='ZLHIS_CHARGE_004';

--121505:李业庆,2018-01-22,可用数量动态计算
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, -null, -null, -null, -null, -null, 0, 0, 292, '可用数量动态计算', '0', '0',
         '药品开处方或记账时计算可用数量的方式。', '0-按库存可用数量计算，>0按指定月数动态计算(不统计指定月数前的可用数量占用)', Null,
         '正常选择默认方式，如果存在较多的可用数量占用情况，可以选择1-3个月动态计算。', Null
  From Dual;

--117049:余伟节,2018-02-01,病案查询打印
Update zlPrograms
Set 标题 = '病案查询打印', 说明 = '支持单个病人或多个病人的病案查询、预览、打印输出。'
Where 系统 = &n_System And 序号 = 1566;

Update zlMenus A
Set a.标题 = '病案查询打印', 说明 = '支持单个病人或多个病人的病案查询、预览、打印输出。', a.短标题 = '病案查询打印'
Where (a.组别, a.上级id) In
      (Select 组别, ID From zlMenus Where 组别 = '缺省' And 标题 = '病案质控与评分系统' And 系统 = &n_System And 模块 Is Null) And a.标题 = '电子病案打印' And
      a.系统 = &n_System;

--119643:李南春,2018-01-30,消息发送内容调整
Update Zlmsg_Lists set NAME = '门诊收费结算', NOTE = '病人收费管理:门诊收费结算完成时;病人补充结算:针对补结算完成时' where code = 'ZLHIS_CHARGE_002';

Update Zlmsg_Lists set NAME = '门诊收费退费' where code = 'ZLHIS_CHARGE_004';

--120005:廖思奇,2018-01-30,同步调整Zlmsg_Lists中Pacs部分的内容
Update Zlmsg_Lists Set Key_Define= '<root><医嘱ID></医嘱ID><报告ID></报告ID><报告类型></报告类型></root>',Note='影像医技、采集、病理工作站:检查完成时' Where Code='ZLHIS_PACS_001';
Update Zlmsg_Lists Set Key_Define= '<root><医嘱ID></医嘱ID><原状态></原状态><新状态></新状态></root>',Note='影像医技、采集、病理工作站:取消检查报到后;影像采集工作站:删除所有图像' Where Code='ZLHIS_PACS_003';
Update Zlmsg_Lists Set Key_Define= '<root><医嘱ID></医嘱ID><报告ID></报告ID><报告类型></报告类型></root>',Note='影像医技、采集、病理工作站:撤销检查完成时(取消完成)' Where Code='ZLHIS_PACS_004';
Update Zlmsg_Lists Set Key_Define= '<root><医嘱ID></医嘱ID></root>',Note='影像医技、采集、病理工作站:检查登记危急值时' Where Code='ZLHIS_PACS_005';
Update Zlmsg_Lists Set Note='门诊医生工作站:发送的医嘱为检查医嘱时;住院医生工作站:发送的医嘱为检查医嘱时;住院护士工作站:发送的医嘱为检查医嘱时;体检中心管理:体检报到时;体检护士工作站:体检签到时;影像医技、采集、病理工作站:新开检查申请后（外院病人登记）' Where Code='ZLHIS_CIS_017';

Delete From Zlmsg_Lists Where Code = 'ZLHIS_QUEUE_001';
Delete From Zlmsg_Lists Where Code = 'ZLHIS_QUEUE_002';
Delete From Zlmsg_Lists Where Code = 'ZLHIS_QUEUE_003';
Delete From Zlmsg_Lists Where Code = 'ZLHIS_QUEUE_004';

--120719:王振涛,2018-01-30,消息处理
Update Zlmsg_Lists Set Key_Define= '<root><诊疗ID></诊疗ID><编码></编码><中文名></中文名><英文名></英文名><系统></系统> </root>' Where Code='ZLHIS_DICT_019';
Update Zlmsg_Lists Set NAME= '检验报告审核', NOTE='检验技师工作站:检验报告审核完成后;临床实验室管理:检验报告审核完成后'   Where Code='ZLHIS_LIS_001';
Update Zlmsg_Lists Set NAME= '检验报告审核撤消', NOTE='检验技师工作站:取消已审核的检验报告后;临床实验室管理:取消已审核的检验报告后'   Where Code='ZLHIS_LIS_002';

--121012:娄经平,2018-01-30,消息触发更改
--120005:廖思奇,2018-01-30,修改ZLHIS_CIS_037 说明
delete from Zlmsg_Lists where Code='ZLHIS_OPER_001';

update  Zlmsg_Lists set Note='门诊医生工作站:作废检验医嘱时;住院医生工作站/住院护士工作站:回退检验医嘱发送时;体检中心管理:取消体检报到,作废检验医嘱时;体检护士工作站:取消体检签到作废检验医嘱时' where Code='ZLHIS_CIS_036';

update  Zlmsg_Lists set Note='门诊医生工作站:作废检查医嘱时;住院医生工作站/住院护士工作站:回退检查医嘱发送时;体检中心管理:取消体检报到,作废检查医嘱时;体检护士工作站:取消体检签到作废检查医嘱时;影像医技、采集、病理工作站:撤消新开的检查申请后（取消登记）' where Code='ZLHIS_CIS_037';

--114183:陈刘,2018-01-26,皮试结果在体温作图栏输出
Insert Into Zlparameters
  (Id, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System,1255, 0, 1,0,0, 0, 0, 92, '皮试结果显示位置', '0', '0',
         '皮试结果显示的位置在体温作图栏(42度-40度之间)还是显示在体温表格栏下方', '0-显示在下方，1-显示在上方（42-40度之间)', '', '适用于需要在体温上作图栏输出皮试结果的用户',null
  From Dual;  

Insert Into Zlparameters
  (Id, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System,1255, 0, 1,0,0, 0, 0, 93, '皮试结果显示结果内容', '0', '0',
         '皮试结果显示药物过敏结果,只显示阴性皮试结果还是只显示阳性皮试结果或者显示所有皮试结果', '0-所有，1-仅显示阳性皮试结果，2-仅显示阴性皮试结果', '', '适用于需要区分显示皮试结果的用户',null
  From Dual; 

--118685:曾杰,2017-01-26,缩略图大图显示参数调整
Insert Into 影像流程参数
  (Id, 科室id, 参数名, 参数值)
  Select 影像流程参数_Id.Nextval, 科室id, '缩略图预览方式', 参数值
  From 影像流程参数
  Where 参数名 = '报告中显示大图';

Delete From 影像流程参数 Where 参数名 = '报告中显示大图';
Delete From 影像流程参数 Where 参数名 = '报告大图放大倍数';

Delete From Zlparameters Where 参数名 = '鼠标移动时显示大图' And 系统 = &n_System And (模块 = 1291 or 模块 = 1294);
Delete From Zlparameters Where 参数名 = '采集大图放大倍数' And 系统 = &n_System And (模块 = 1291 or 模块 = 1294);
Delete From Zlparameters Where 参数名 = '大图显示范围限制' And 系统 = &n_System And (模块 = 1291 or 模块 = 1294);
Delete From Zlparameters Where 参数名 = '大图显示最大分辨率' And 系统 = &n_System And (模块 = 1291 or 模块 = 1294);

--120700:李业庆,2018-01-23,消息描点调整
Update Zlmsg_Lists Set Key_Define= '<root><类型></类型><ID></ID><编码></编码><名称></名称></root>' Where Code='ZLHIS_DICT_027';
Update Zlmsg_Lists Set Key_Define= '<root><类型></类型><ID></ID><编码></编码><名称></名称></root>' Where Code='ZLHIS_DICT_032';
Update Zlmsg_Lists Set Key_Define= '<root><类型></类型><ID></ID><编码></编码><名称></名称><规格></规格><产地></产地></root>' Where Code='ZLHIS_DICT_037';
Update Zlmsg_Lists Set Key_Define= '<root><类型></类型><ID></ID><编码></编码><名称></名称><规格></规格><产地></产地></root>' Where Code='ZLHIS_DICT_045';
Update Zlmsg_Lists Set Key_Define= '<root><价格ID></价格ID></root>', Name='药品调成本价',note='药品调价管理:药品调成本价时' Where Code='ZLHIS_DRUG_007';

Insert Into Zlmsg_Lists(Bz_Type, Code, Name, Key_Define, Note)
Select '字典', 'ZLHIS_DICT_050', '新增卫材分类', '<root><类型></类型><ID></ID></root>', '卫材目录管理:新增分类时'  From Dual Union All 
Select '字典', 'ZLHIS_DICT_051', '修改卫材分类', '<root><类型></类型><ID></ID></root>', '卫材目录管理:修改分类时'  From Dual Union All 
Select '字典', 'ZLHIS_DICT_052', '删除卫材分类', '<root><类型></类型><ID></ID><编码></编码><名称></名称></root>', '卫材目录管理:删除分类时'  From Dual Union All 
Select '药品', 'ZLHIS_DRUG_008', '静配发送', '<root><记录IDS><记录ID></记录ID></记录IDS></root>', '输液配置中心管理:当静配中心完成配液并发送到病区时'  From Dual Union All
Select '药品', 'ZLHIS_DRUG_009', '药品调售价', '<root><价格ID></价格ID><时价></时价></root>', '药品调价管理:药品调售价时'  From Dual Union All
Select '药品', 'ZLHIS_DRUG_010', '卫材调成本价', '<root><价格ID></价格ID></root>', '卫材调价管理:卫材调成本价时'  From Dual Union All
Select '药品', 'ZLHIS_DRUG_011', '卫材调售价', '<root><价格ID></价格ID><时价></时价></root>', '卫材调价管理:卫材调售价时'  From Dual;

Delete From Zlmsg_Lists Where Code='ZLHIS_TRANSFUSION_001';

--105001:胡俊勇,2018-01-22,医嘱中药医嘱内容多行打印
Insert Into Zlparameters
  (Id, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System,1254, 0, 0,1,1, 0, 0, 82, '长嘱单中药医嘱单行显示字数', '0', '0',
         '打印长嘱单时，如果设制了此参数，对于中药医嘱内容过长的时候会自动分行打印，将中药医嘱内容全部显示在医嘱单。', '0-只显示一行，>0-大于零表示每一行显示的字数，例：10即每行显示10个汉字标点符号也算一个字', Null, '医嘱单在院期间需要续打，且医嘱内容长度单行打印不下时自动打为多行时，请设置报表中医嘱内容列单行可打印的字符数。',null
  From Dual;  

Insert Into Zlparameters
  (Id, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System,1254, 0, 0,1,1, 0, 0, 83, '临嘱单中药医嘱单行显示字数', '0', '0',
         '打印临嘱单时，如果设制了此参数，对于中药医嘱内容过长的时候会自动分行打印，将中药医嘱内容全部显示在医嘱单。', '0-只显示一行，>0-大于零表示每一行显示的字数，例：10即每行显示10个汉字标点符号也算一个字', Null, '医嘱单在院期间需要续打，且医嘱内容长度单行打印不下时自动打为多行时，请设置报表中医嘱内容列单行可打印的字符数。',null
  From Dual;   

--95325:李南春,2016-04-18,自助补充结算
Insert Into Zlprograms(序号,标题,说明,系统,部件,资源id) Values(1809,'自助补充结算','自助机进行医保补充结算操作',&n_System,'zl9WizardInsure',Null);

Insert Into zlparameters(系统,模块,id,私有,本机,授权,固定,部门,性质,参数号,参数名,参数值,缺省值,影响控制说明,参数值含义,关联说明,适用说明,警告说明)
Select &n_System,1809,Zlparameters_Id.Nextval,A.* From (
Select 私有,本机,授权,固定,部门,性质,参数号,参数名,参数值,缺省值,影响控制说明,参数值含义,关联说明,适用说明,警告说明 From zlparameters Where 1 = 0 Union All 
  Select 0, 1, 0, 0, 0, 0, 1,'自动返回时间',NULL,'10|0','正常页面自动返回时间：主要是控制在自助挂号的除错误页面之外的界面中无任何操作时,自动返回到首页的秒数.'||CHR(13)||'错误页面自动返回时间：主要是控制在自助挂号的错误界面中无任何操作时,自动返回到首页的秒数.',
         '格式：正常页面自动返回时间|错误页面自动返回时间'||CHR(13)||'>0:表示自动返回的秒数'||CHR(13)||'=0:表示不自动返回',NULL,'适用于控制不同页面无任何操作时的停留时间',NULL From Dual Union All 
  Select 0, 0, 0, 0, 0, 0, 2,'身份识别图标对照',NULL,NULL,'主要控制在自助挂号模块的身份识别方式页面中的识别方式的显示图像(包含按下和显示的图像控制)','格式:卡类别ID;图像ID(显示图像;按下图像)||…'||CHR(13)||'卡类别ID:>0为医疗卡类别.ID;-97-身份证;-96-IC卡'||CHR(13)||
         '图像标识：图像资源的标识，即导诊资源目录.标识(显示图像：卡在界面上正常显示的图像;按下图像：卡在界面上按下时显示图像)','主要控制在自助挂号模块的支付方式页面中的支付方式的显示图像(包含按下和显示的图像控制) 只有启用参数"身份识别设置"后,本参数才会在自助系统中生效。',
         '适用于医院自助机的不同个性化业务',NULL From Dual Union All 
  Select 0, 1, 0, 0, 0, 0, 3,'身份识别设置',NULL,NULL,'主要控制在自助挂号模块时在本自助机的身份识别方式,根据卡类型的不同有三种识别方式:'||CHR(13)||'一是刷卡:键卡从刷卡槽划过自动读卡'||CHR(13)||'二是接触式读卡:需要将卡插入读卡口，点击确认进行读卡'||CHR(13)||
         '三是非接触式读卡：将卡放在扫描器下方就能自动读卡','格式:卡类别ID;图像ID(显示图像;按下图像)||…'||CHR(13)||'卡类别ID:类别为医疗卡时,为医疗卡类别.ID;-97-身份证;-96-IC卡'||CHR(13)||'图像标识：图像资源的标识，即导诊资源目录.标识(显示图像：卡在界面上正常显示的图像;按下图像：卡在界面上按下时显示图像)'||CHR(13)||
         '是否启用:1-启用;0-不启用'||CHR(13)||'是否自动:1-自动;0-手动'||CHR(13)||'自动：表示不需按任何按钮或刷卡自动读取卡上的信息；手动：表示需要完成指定的操作才能读卡。',
         '如果是读卡:需要编制和站点部署三方接口支持部件,如:zlCard_XXX','适用于医院自助机的不同个性化业务',NULL From Dual Union All 
  Select 0, 0, 0, 0, 0, 0, 4,'结算方式图标对照',NULL,NULL,'主要控制在自助补充结算模块的补充界面中的结算方式的显示图像','格式:结算方式名称;图像ID||…',
         '需要自助机支持这次结算方式，本参数才会在自助系统中生效。','适用于医院自助机的不同个性化业务',NULL From Dual Union All 
  Select 0, 0, 0, 0, 0, 0, 5,'允许进行补结算的结算方式',NULL,NULL,'主要控制允许收费时的结算方式是否可以在自助补充结算模块的中进行补结算','格式:结算方式名称;是否允许补结算||…(是否允许补结算:0-不允许;1-允许)',
         '','适用于医院自助机的不同个性化业务',NULL From Dual Union All 
  Select 0, 0, 0, 0, 0, 0, 6,'自助支付图标对照',NULL,NULL,'主要控制在自助挂号模块的身份识别方式页面中的识别方式的显示图像(包含按下和显示的图像控制)','格式:卡类别ID,图像ID(显示图像;按下图像)||…'||CHR(13)||'卡类别ID:类别为医疗卡时,为医疗卡类别.ID'||CHR(13)||
         '图像标识：图像资源的标识，即导诊资源目录.标识(显示图像：卡在界面上正常显示的图像;按下图像：卡在界面上按下时显示图像)','主要控制在自助补充结算模块的支付方式页面中的支付方式的显示图像(包含按下和显示的图像控制) 只有启用参数"自助支付模式"后,本参数才会在自助系统中生效。',
         '适用于医院自助机的不同个性化业务',NULL From Dual Union All 
  Select 0, 1, 0, 0, 0, 0, 7,'自助支付模式',NULL,NULL,'主要控制在自助补充结算模块时支持转账的的支付方式','格式:类别,卡类别ID,是否启用||…'||CHR(13)||'类别:2-三方接口(暂时只支持三方转账)'||CHR(13)||'卡类别ID:类别为医疗卡时,医疗卡类别.ID;'||CHR(13)||'是否启用:1-启用;0-不启用',
         '需要编制和站点部署三方接口支持部件,如:zlCard_XXX','适用于医院自助机的不同个性化业务',NULL From Dual Union All
  Select 0, 0, 0, 0, 0, 0, 8,'补结算有效天数',NULL,'1','主要是针对收费或挂号数据允许自助补结算的有效天数.','>0:单位:天数',NULL,'适用于医院对收费或挂号存在补结算业务时同时对补结算时间有限制的用户.',NULL From Dual Union All
  Select 0, 1, 0, 0, 0, 0, 9,'启用热敏打印',NULL,'0|0','1.在自助补结算时,设置费用收据为启用热敏打印进行打印,则在补结算后,调用"热敏打印部件"设置的部件名所对应接口来打印收据,不启用热敏打印机时,则调用自定义报表来打印,调用的报表名为:zl1_BILL_1124'||CHR(13)||
        '2.在自助补结算时,费用凭条为启用热敏打印进行打印,则在补结算后,调用"热敏打印部件"设置的部件所名对应接口来打印收费的凭条,不启用热敏打印机时,则调用自定义报表来打印,调用的报表名为:zl1_BILL_1809','分两项,用|分隔,格式为:收费收据|收费凭条'||CHR(13)||
        'a.补结算收据:1-启用热敏打印机打印补结算收据;0-不启用热敏打印机打印,使用报表打印补结算收据'||CHR(13)|| 'b.补结算凭条:1-启用热敏打印机打印补结算凭条;0-不启用热敏打印机打印,使用报表打印补结算凭条','如果启用热敏打印,则需要配合设置"热敏打印部件"才有效','自助机有热敏打印设备',NULL From Dual Union All
  Select 0, 1, 0, 0, 0, 0, 10,'热敏打印部件',NULL,'zl9WizardInterface.clsPrintInterface','在启用热敏打印时,在完成自助补结算保存后,调用本参数所设置的部件进行打印补结算收据或凭条.','格式: 部件名.接口类名'||CHR(13)||'比如:zl9WizardInterface.clsPrintInterface','1.该参数必须设置"启用热敏打印"才有效'||CHR(13)||
        '2.需要编制热敏打印部件','自助机有热敏打印设备',NULL From Dual Union All
  Select 0, 1, 0, 0, 0, 0, 11,'收费发票打印方式',NULL,'普通病人,1|医保病人,1','在自助补结算管理中当补结算完成后控制不同病人类型的门诊医疗收据的打印:'||CHR(13)||'a)如果本参数设置为不打印,则不打印门诊医疗收据'||CHR(13)||
        'b)如果本参数设置为自动打印,则自助缴费完成后将自动打印门诊医疗收据'||CHR(13)||'c)如果本参数设置为选择是否打印,则自助缴费完成后,提示用户是否打印门诊医疗收据,选择"是"将打印,否则不打印',
        '格式:使用类别1,方式1|使用类别2,方式2|...,'||CHR(13)||'使用类别:普通病人,医保病人… '||CHR(13)||'方式:0-不打印,1-自动打印,2-选择是否打印','1.需要结合参数"票号严格控制"中收费是否严格控制来进行控制:'||CHR(13)||
        'a.如果严格控制,则打印的门诊医疗收据必须先进行领用,然后才能正常打印.'||CHR(13)||'b.如果为不严格控制,则在收费时,必须输入一个票号才能正常打印'||CHR(13)||'2.需要结合参数"收费发票格式"来控制票据的打印格式','医院控制自助机是否支持打印',NULL From Dual Union All
  Select 0, 1, 0, 0, 0, 0, 12,'收费发票格式',NULL,'普通病人,1|医保病人,1','1)在自助补结算管理管理中完成补结算后,根据病人类型决定打印哪种门诊医疗票据'||CHR(13)||'2)在补结算完成后,如果需要打印门诊医疗收据,则调用报表:zl1_BILL_1124',
         '格式:使用类别1,格式1|使用类别2,格式2|...'||CHR(13)||'使用类别:普通病人,医保病人或… '||CHR(13)||'格式:0或NULL:使用本地缺省格式,'||CHR(13)||'>0:票据格式序号','1)需要结合参数[收费发票打印方式]中是否打印来进行控制:'||CHR(13)||
         'a)如果打印或提示选择打印,则本参数有效'||CHR(13)|| 'b)如果不打印或提示选择不打印,则本参数无效.'||CHR(13)||'2)需要结合[启用热敏打印]参数来控制,如果启用,则本参数无效;否则按本参数所设置的格式来打印票据','适应与医院采用不同的打印格式',NULL From Dual Union All
  Select 0, 1, 0, 0, 0, 0, 13,'凭条打印方式',NULL,NULL,'在自助补结算管理中当补结算完成后控制补结算凭条的打印:'||CHR(13)||'a)如果本参数设置为不打印,则不打印补结算凭条'||CHR(13)||'b)如果本参数设置为自动打印,则补结算完成后将自动打印补结算凭条'||CHR(13)||
         'c)如果本参数设置为选择是否打印,则挂号完成后,提示用户是否打印补结算凭条,选择"是"将打印,否则不打印'||CHR(13)||
         '2. 在补结算完成时,如果需要补结算凭条,则按如下规则打印:'||CHR(13)||'a) 如果启用热敏打印,则调用参数[热敏打印部件]设置的部件进行打印'||CHR(13)||'b)如果未启用热敏打印,则调用报表:zl1_BILL_1809','0-不打印 1-自动打印 2-选择打印',
         '如果要使用热敏打印机,则需要启用[启用热敏打印],同时需要设置参数[热敏打印部件]的打印部件才能正常使用热敏打印机打印补结算凭条.','医院控制自助机是否支持打印',NULL From Dual Union All
  Select 0, 1, 0, 0, 0, 0, 14,'共用收费票据批次',NULL,NULL,'1.需要满足条件:收费票据严格控制且操作员没有自用票据且需要打印发票时本参数设置才有效'||CHR(13)||'2.在自助补结算管理中进行补结算时,在满足上面条件下,根据本参数获取或确定本次所要使用的收费票据批次.'||CHR(13)||
         '3.在严格控制票据的情况下,获取票据使用批次的规则:'||CHR(13)||'1)如果操作员有自用的的票据,则先使用自用的票据((存在多批次时,按先领用先用的原则进行使用)).'||CHR(13)||'2)如果不存在自用票据时,则根据本参数设置的共用批次来获取本次需要使用票据批次(存在多批次时,按先领用先用的原则进行使用)',
         '格式:领用ID1,使用类别1|领用ID2,使用类别2|....,'||CHR(13)||'领用ID:票据领用的批次,即票据领用记录.ID','1.需要结合参数"票号严格控制"中收费是否严格控制来进行控制:如果为严格控制且操作员无自用票据,则按本参数设置来读取该使用的票据批次'||CHR(13)||
         '2.需要结合参数"收费发票打印方式"来控制，如果要打印，则按本参数来获取某批次的未使用的发票号。','适用于多台自助机使用同一工作站且共用发票的业务模式。',NULL From Dual Union All
  Select 0, 1, 0, 0, 0, 0, 15,'当前收费票据号',NULL,NULL,'1.在自助补结算管理中进行补结算操作时:'||CHR(13)||' 如果收费票据为非严格控制的情况和需要打印发票的情况下，获取当前已经使用的发票号来产生新发票号（规则是获取已经使用的最后一张发票号+1的方式)'||CHR(13)||
         '2.初次使用时,需要在参数设置中设置启始的发票号',NULL,'1.需要结合参数"票号严格控制"中预交是否严格控制来进行控制:如果为不严格控制,则在存为预交款时,则根据本参数来获取新的发票号'||CHR(13)||
         '2.需要结合参数"预存打印方式"来控制，如果要打印，则按本参数来获取新的发票号。','适用于打印的票据不严格按票据领用来进行分配票号。',NULL From Dual Union All
  Select 0, 0, 0, 0, 0, 0, 16,'允许病人选择补结算日期',NULL,'0','在自助补结算管理中进行补结算操作时,是否允许病人选择补结算日期,获取日期范围内的费用单据。','0-不允许病人调整日期;1-允许调整。',NULL,'适用于病人自行调整补结算日期',NULL From Dual Union All
  Select 0, 0, 0, 0, 0, 0, 17,'必须先进行挂号保险结算',NULL,'0','在自助补结算管理中进行补结算操作时,控制病人在进行收费结算前先进行挂号结算。','0-不限制;1-必须先进行挂号结算才能收费结算。','必须是挂号有效天数内的挂号结算','根据医保规则控制业务流程',NULL From Dual Union All
  Select 0, 1, 0, 0, 0, 0, 18,'显示病人信息页面',Null,'1','控制在自助补结算管理中，病人在通过身份识别后，是否需要显示身份信息确认页面，以展示当前的病人信息。','0-表示不显示病人信息确认页面，1-表示显示病人信息确认页面',NULL,'适用于医院减少自助操作流程。',NULL From Dual Union All
Select 私有,本机,授权,固定,部门,性质,参数号,参数名,参数值,缺省值,影响控制说明,参数值含义,关联说明,适用说明,警告说明 From zlparameters Where 1 = 0) A;

--115771:李南春,2018-01-18,Metro风格调整
Insert Into zlParameters(ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
Select zlParameters_ID.Nextval,&n_System,-NULL,A.* From (
Select 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明 From zlParameters Where 1 = 0 Union All 
  Select 0,0,1,0,0,0,291,'自助号类图标对照',NULL, '普通|11009198|11009198|11009832|11009833||特诊|11009199|11009199|11009834|11009835||专家|11009200|11009200|11009836|11009837||专科|11009201|11009201|11009838|11009839||急诊|11009225|11009225',
  '控制自助挂号在号类选择页面的各号类及号类的图标设置','格式:号类|缺省钮图像|按下钮图像|缺省图标小||缺省图标大||..。',NULL,'使用调整自助上号类图标',NULL From Dual Union All
Select 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明 From zlParameters Where 1 = 0) A;

DECLARE 
v_启用类别 Varchar2(4000);
  v_号类图像 Varchar2(4000);
  Function Get_参数值
  (
    参数值_In    In Zlparameters.参数值%Type,
    启用号类_Out Out Zlparameters.参数值%Type
  ) Return Varchar2 Is
    v_参数值        Zlparameters.参数值%Type;
    v_当前参数值    Zlparameters.参数值%Type;
    v_类别          Zlparameters.参数值%Type;
    v_显示图像      Zlparameters.参数值%Type;
    v_按下图像      Zlparameters.参数值%Type;
    v_启用状态      Zlparameters.参数值%Type;
    v_Temp          Varchar2(4000);
    v_Ico           Varchar2(50);
    v_启用类别_Temp Varchar2(500);
  Begin
    If 参数值_In Is Null Then
      启用号类_Out := Null;
      Return Null;
    End If;
    v_参数值        := 参数值_In || '||';
    v_启用类别_Temp := Null;
    v_Temp          := Null;
    While v_参数值 Is Not Null Loop
      v_当前参数值 := Substr(v_参数值, 1, Instr(v_参数值, '||') - 1);
      v_类别       := Substr(v_当前参数值, 1, Instr(v_当前参数值, '|') - 1);
      v_当前参数值 := Substr(v_当前参数值, Instr(v_当前参数值, '|') + 1);
      v_显示图像   := Substr(v_当前参数值, 1, Instr(v_当前参数值, '|') - 1);
      v_当前参数值 := Substr(v_当前参数值, Instr(v_当前参数值, '|') + 1);
      v_按下图像   := Substr(v_当前参数值, 1, Instr(v_当前参数值, '|') - 1);
      v_当前参数值 := Substr(v_当前参数值, Instr(v_当前参数值, '|') + 1);
      v_启用状态   := Substr(v_当前参数值, Instr(v_当前参数值, '|') + 1);
      v_Ico := Case
                 When v_类别 = '普通' Then
                  '11009832|11009833'
                 When v_类别 = '特诊' Then
                  '11009834|11009835'
                 When v_类别 = '专家' Then
                  '11009836|11009837'
                 When v_类别 = '专科' Then
                  '11009838|11009839'
                 Else
                  '11009832|11009833'
               End;
      v_Temp       := Nvl(v_Temp, '') || '||' || v_类别 || '|' || v_显示图像 || '|' || v_按下图像 || '|' || v_Ico;
    
      v_启用类别_Temp := Nvl(v_启用类别_Temp, '') || '||' || v_类别 || '|' || v_启用状态;
      v_参数值        := Substr(v_参数值, Instr(v_参数值, '||') + 2);
    End Loop;
    If v_Temp Is Not Null Then
      v_Temp := Substr(v_Temp, 3);
    End If;
    If v_启用类别_Temp Is Not Null Then
      v_启用类别_Temp := Substr(v_启用类别_Temp, 3);
    End If;
    启用号类_Out := v_启用类别_Temp;
    Return v_Temp;
  End;

Begin
  For c_参数 In (Select ID, 参数值, 缺省值
               From zlParameters
               Where 参数名 = '自助挂号类别对照' And 模块 In (1539, 1802, 1803) And Exists
                (Select 1 From zlParameters Where 参数名 = '自助号类图标对照' And 模块 Is Null And 参数值 Is Null)) Loop
    v_号类图像 := Get_参数值(c_参数.参数值, v_启用类别);
    Update zlParameters Set 参数值 = v_启用类别, 缺省值 = Null Where ID = c_参数.Id;
    Update zlParameters Set 参数值 = v_号类图像 Where 参数名 = '自助号类图标对照' And 模块 Is Null And 参数值 Is Null;
    For c_本机参数 In (Select 参数id, 用户名, 机器名, 参数值 From zlUserParas Where 参数id = c_参数.Id) Loop
      v_号类图像 := Get_参数值(c_参数.参数值, v_启用类别);
      Update zlUserParas
      Set 参数值 = v_启用类别
      Where 参数id = c_本机参数.参数id And Nvl(机器名, 'LXH-PC-1~') = Nvl(c_本机参数.机器名, 'LXH-PC-1~') And
            Nvl(用户名, 'LXH-PC-1~') = Nvl(c_本机参数.用户名, 'LXH-PC-1~');
    End Loop;
  End Loop;
End;
/

DECLARE 
  v_更新参数 Varchar2(4000);
  Function Get_参数值
  (
    参数名_In    In Zlparameters.参数名%Type,
    参数值_In    In Zlparameters.参数值%Type
  ) Return Varchar2 Is
    v_参数值        Zlparameters.参数值%Type;
    v_当前参数值    Zlparameters.参数值%Type;
    v_类别          Zlparameters.参数值%Type;
    v_分值1         Zlparameters.参数值%Type;
    v_分值2         Zlparameters.参数值%Type;
    v_分值3         Zlparameters.参数值%Type;
    v_显示图像      Zlparameters.参数值%Type;
    v_按下图像      Zlparameters.参数值%Type;
    v_Temp          Varchar2(4000);
    v_Ico           Varchar2(50);
  Begin
    v_参数值        := 参数值_In || '||';
    v_Temp          := Null;
    While v_参数值 Is Not Null Loop
      If 参数名_In <> '身份识别图标对照' Then
        v_当前参数值 := Substr(v_参数值, 1, Instr(v_参数值, '||') - 1);
        v_分值1      := Substr(v_当前参数值, 1, Instr(v_当前参数值, ',') - 1);
        v_当前参数值 := Substr(v_当前参数值, Instr(v_当前参数值, ',') + 1);
        v_分值2      := Substr(v_当前参数值, 1, Instr(v_当前参数值, ',') - 1);
      Else
        v_当前参数值 := Substr(v_参数值, 1, Instr(v_参数值, '||') - 1);
        v_分值2      := Substr(v_当前参数值, 1, Instr(v_当前参数值, ',') - 1);
      End if;
      
      v_当前参数值 := Substr(v_当前参数值, Instr(v_当前参数值, ',') + 1);
      v_显示图像   := Substr(v_当前参数值, 1, Instr(v_当前参数值, ';') - 1);
      v_当前参数值 := Substr(v_当前参数值, Instr(v_当前参数值, ';') + 1);
      If Instr(v_当前参数值,';')>0 then
        v_按下图像   := Substr(v_当前参数值, 1, Instr(v_当前参数值, ';') - 1);
      ElsIf Instr(v_当前参数值,',')>0 then
        v_按下图像   := Substr(v_当前参数值, 1, Instr(v_当前参数值, ',') - 1);
        v_分值3 := Substr(v_当前参数值, Instr(v_当前参数值, ',') + 1);
      Else
        v_按下图像   := Substr(v_当前参数值, Instr(v_当前参数值, ';') + 1);
      End if;

      v_参数值        := Substr(v_参数值, Instr(v_参数值, '||') + 2);
      
      If Nvl(v_分值2,0) > 0 Then
        Select Max(名称) Into v_类别 From 医疗卡类别 Where ID = v_分值2;
      End if;
      
      v_Ico := Case
                 When Nvl(v_分值1,-1) = 0 Then
                  '11009905;11009904'
                 When Nvl(v_分值1,-1) = 3 Then
                  '11009907;11009906'
                 When v_类别 Like '%身份证%' Then
                  '11009899;11009775'
                 When v_类别 Like 'IC%' Then
                  '11009895;11009771'
                 When v_类别 Like '%就诊卡' Then
                  '11009898;11009774'
                 When v_类别 Like '%招商%' or v_类别 Like '%招行%' Then
                  '11009902;11009778'
                 When v_类别 Like '%工商%' or v_类别 Like '%工行%' Then
                  '11009896;11009772'
                 When v_类别 Like '%建设%' or v_类别 Like '%建行%' Then
                  '11009897;11009773'
                 When v_类别 Like '中国银行%' Then
                  '11009903;11009779'
                 When v_类别 Like '%银行%' Then
                  '11009901;11009777'
                 Else
                  '11009900;11009776'
               End;
      If 参数名_In = '身份识别图标对照' Then
        v_Temp := Nvl(v_Temp, '') || '||' || v_分值2 || ',' || v_显示图像 || ';' || v_按下图像 || ';' || v_Ico;
      ElsIf v_分值3 is Null Then
        v_Temp := Nvl(v_Temp, '') || '||' || v_分值1 || ',' || v_分值2 || ',' || v_显示图像 || ';' || v_按下图像 || ';' || v_Ico;
      Else
        v_Temp := Nvl(v_Temp, '') || '||' || v_分值1 || ',' || v_分值2 || ',' || v_显示图像 || ';' || v_按下图像 || ';' || v_Ico || ',' || v_分值3;
      End If;
    End Loop;
    
    If v_Temp Is Not Null Then
      v_Temp := Substr(v_Temp, 3);
    End If;
    Return v_Temp;
  End;

Begin
  For c_参数 In (Select ID, 参数名, 参数值, 缺省值
               From zlParameters
               Where 参数名 in ('自助发卡图标对照','身份识别图标对照','自助支付图标对照') 
                 And 模块 in(1801,1802,1803,1804,1805,1806,1807,1808,1809) And 参数值 is Not Null ) Loop
    v_更新参数 := Get_参数值(c_参数.参数名, c_参数.参数值);
    Update zlParameters Set 参数值 = v_更新参数 Where ID = c_参数.Id;
  End Loop;
End;
/

DECLARE 
  v_参数值        Zlparameters.参数值%Type;
  v_当前参数值    Zlparameters.参数值%Type;
  v_类别          Zlparameters.参数值%Type;
  v_显示图像      Zlparameters.参数值%Type;
  v_按下图像      Zlparameters.参数值%Type;
  v_Temp          Varchar2(4000);
  v_Ico           Varchar2(50);
Begin
  Select Nvl(参数值,'-') INTO v_参数值 From Zlparameters Where 模块 = 1808 And 参数名 = '凭条功能图标对照';
  If v_参数值 <> '-' Then
    v_参数值        := v_参数值 || '||';
    v_Temp          := Null;
    
    While v_参数值 Is Not Null Loop
      v_当前参数值 := Substr(v_参数值, 1, Instr(v_参数值, '||') - 1);
      v_类别       := Substr(v_当前参数值, 1, Instr(v_当前参数值, ';') - 1);
      
      v_当前参数值 := Substr(v_当前参数值, Instr(v_当前参数值, ';') + 1);
      v_显示图像   := Substr(v_当前参数值, 1, Instr(v_当前参数值, ';') - 1);
      v_当前参数值 := Substr(v_当前参数值, Instr(v_当前参数值, ';') + 1);
      If Instr(v_当前参数值,';')>0 then
        v_按下图像   := Substr(v_当前参数值, 1, Instr(v_当前参数值, ';') - 1);
      Else
        v_按下图像   := Substr(v_当前参数值, Instr(v_当前参数值, ';') + 1);
      End if;
      
      v_参数值        := Substr(v_参数值, Instr(v_参数值, '||') + 2);

      v_Ico := Case
                 When Nvl(v_类别,0) = 1 Then
                  '11009919;11009918'
                 Else
                  '11009923;11009922'
               End;

      v_Temp := Nvl(v_Temp, '') || '||' || v_类别 || ';' || v_显示图像 || ';' || v_按下图像 || ';' || v_Ico;
    End Loop;
    
    If v_Temp Is Not Null Then
      v_Temp := Substr(v_Temp, 3);
    End If;
    
    Update zlParameters Set 参数值 = v_Temp Where 模块 = 1808 And 参数名 = '凭条功能图标对照';
  End If;
End;
/

--115771:李南春,2018-01-18,Metro风格调整
Insert Into zlPrograms(序号,标题,说明,系统,部件) Values(1811,'自助退号管理','管理病人在自助机上对挂号单和预约单进行退号。',&n_System,'zl9WizardBackReg'); 

Insert Into zlPrograms(序号,标题,说明,系统,部件) Values(1812,'自助轧帐管理','完成自助系统在一定的时间范围内收取的款项进行轧帐清算处理,包含对历史轧帐记录的查询。',&n_System,'zl9WizardRollAcc'); 

Insert Into zlParameters(ID,系统,模块,私有,本机,授权,固定,部门,性质,参数号,参数名,参数值,缺省值,影响控制说明,参数值含义,关联说明,适用说明,警告说明)
Select zlParameters_ID.Nextval,&n_System,1811,A.* From (
Select 私有,本机,授权,固定,部门,性质,参数号,参数名,参数值,缺省值,影响控制说明,参数值含义,关联说明,适用说明,警告说明 From zlParameters Where 1 = 0 Union All 
    Select 0,1,0,0,0,0,1,'凭条打印方式',NULL,NULL,'在自助退号管理中当退号完成后控制退号凭条的打印:'||CHR(13)||'a)如果本参数设置为不打印,则不打印退号凭条'||CHR(13)||'b)如果本参数设置为自动打印,则退号完成后将自动打印退号凭条'||CHR(13)||'c)如果本参数设置为选择是否打印,则退号完成后,提示用户是否打印退号凭条,选择"是"将打印,否则不打印'||CHR(13)||'2. 在退号完成时,如果需要退号凭条,则按如下规则打印:'||CHR(13)||'a) 如果启用热敏打印,则调用参数"热敏打印部件"设置的部件进行打印'||CHR(13)||'b)如果未启用热敏打印,则调用报表:zl1_BILL_1802','0-不打印 1-自动打印 2-选择打印','如果要使用热敏打印机,则需要启用"启用热敏打印",同时需要设置参数"热敏打印部件"的打印部件才能正常使用热敏打印机打印退号凭条.','适用于医院自助机的不同个性化业务',NULL From Dual Union All 
    Select 0,1,0,0,0,0,2,'预存打印方式',NULL,NULL,'在自助退号管理中当退号完成后控制预交款收据的打印:'||CHR(13)||'a)如果本参数设置为不打印,则不打印预交款收据'||CHR(13)||'b)如果本参数设置为自动打印,则退号完成后将自动打印预交款收据'||CHR(13)||'c)如果本参数设置为选择是否打印,则退号完成后,提示用户是否打印预交款收据,选择"是"将打印,否则不打印'||CHR(13)||'2. 在退号完成时,如果需要预交款收据,则按如下规则打印:'||CHR(13)||'a) 如果启用热敏打印,则调用参数"热敏打印部件"设置的部件进行打印'||CHR(13)||'b)如果未启用热敏打印,则调用报表:zl1_BILL_1103','0-不打印 1-自动打印 2-选择打印','如果要使用热敏打印机,则需要启用"启用热敏打印",同时需要设置参数"热敏打印部件"的打印部件才能正常使用热敏打印机打印预交款收据','适用于医院自助机的不同个性化业务',NULL From Dual Union All 
    Select 0,1,0,0,0,0,3,'自动返回时间',NULL,'10|0|0','正常页面自动返回时间：主要是控制在自助退号的除错误页面之外的界面中无任何操作时,自动返回到首页的秒数.'||CHR(13)||'错误页面自动返回时间：主要是控制在自助退号的错误界面中无任何操作时,自动返回到首页的秒数.'||CHR(13)||'成功页面自动返回时间：主要是控制在自助退号的成功界面中无任何操作时,自动返回到首页的秒数.','格式：正常页面自动返回时间|错误页面自动返回时间|成功页面自动返回时间'||CHR(13)||'>0:表示自动返回的秒数'||CHR(13)||'=0:表示不自动返回',NULL,'适用于医院自助机的不同个性化业务',NULL From Dual Union All 
    Select 0,0,0,0,0,0,4,'身份识别图标对照',NULL,NULL,'主要控制在自助退号模块的身份识别方式页面中的识别方式的显示图像(包含按下和显示的图像控制)','格式:卡类别ID；图像ID(显示图像；按下图像)||…'||CHR(13)||'卡类别ID:>0为医疗卡类别.ID；-97-身份证；-96-IC卡'||CHR(13)||'图像标识：图像资源的标识，即导诊资源目录.标识(显示图像：卡在界面上正常显示的图像；按下图像：卡在界面上按下时显示图像)','主要控制在自助退号模块的支付方式页面中的支付方式的显示图像(包含按下和显示的图像控制) 只有启用参数"身份识别设置"后,本参数才会在自助系统中生效。','适用于医院自助机的不同个性化业务',NULL From Dual Union All 
    Select 0,1,0,0,0,0,5,'身份识别设置',NULL,NULL,'主要控制在自助退号模块时在本自助机的身份识别方式,根据卡类型的不同有三种识别方式:'||CHR(13)||'一是刷卡:键卡从刷卡槽划过自动读卡'||CHR(13)||'二是接触式读卡:需要将卡插入读卡口，点击确认进行读卡'||CHR(13)||'三是非接触式读卡：将卡放在扫描器下方就能自动读卡',''||CHR(13)||'格式:卡类别ID；图像ID(显示图像；按下图像)||…'||CHR(13)||'卡类别ID:类别为医疗卡时,为医疗卡类别.ID；-97-身份证；-96-IC卡'||CHR(13)||'图像标识：图像资源的标识，即导诊资源目录.标识(显示图像：卡在界面上正常显示的图像；按下图像：卡在界面上按下时显示图像)'||CHR(13)||'是否启用:1-启用；0-不启用'||CHR(13)||'是否自动:1-自动；0-手动'||CHR(13)||'自动：表示不需按任何按钮或刷卡自动读取卡上的信息；手动：表示需要完成指定的操作才能读卡。'||CHR(13)||'','如果是读卡:需要编制和站点部署三方接口支持部件,如:zlCard_XXX '||CHR(13)||'','适用于医院自助机的不同个性化业务',NULL From Dual Union All 
    Select 0,0,0,0,0,0,6,'自助支付图标对照',NULL,NULL,'主要控制在自助退号模块的支付方式页面中的支付方式的显示图像(包含按下和显示的图像控制)','格式:类别,卡类别ID,图像ID(显示图像；按下图像)||…'||CHR(13)||'类别:1-消费卡,2-医疗卡'||CHR(13)||'卡类别ID:类别为消费卡时,为卡消费接口目录.编号；类别为医疗卡时,为医疗卡类别.ID'||CHR(13)||'图像标识：图像资源的标识，即导诊资源目录.标识(显示图像：卡在界面上正常显示的图像；按下图像：卡在界面上按下时显示图像)'||CHR(13)||'','主要控制在自助退号模块的支付方式页面中的支付方式的显示图像(包含按下和显示的图像控制) 只有启用参数"自助支付模式"后,本参数才会在自助系统中生效。','适用于医院自助机的不同个性化业务',NULL From Dual Union All 
    Select 0,1,0,0,0,0,7,'自助支付模式',NULL,NULL,'主要控制在自助退号模块时确定退号费在本自助机的支付方式,目前可以设置三种支付方式:'||CHR(13)||'一是现金:采用投币方式'||CHR(13)||'二是三方帐户:自助机与三方机构(银行卡)等连接扣款的'||CHR(13)||'三是帐户支付:即预交款扣款'||CHR(13)||'','格式:类别,卡类别ID,是否启用||…'||CHR(13)||'类别:0-现金；1-消费卡,2-三方接口；3-帐户支付'||CHR(13)||'卡类别ID:类别为消费卡时,为卡消费接口目录.编号；类别为三方接口时,为医疗卡类别.ID；类别为现金和类别为帐户支付的为0；'||CHR(13)||'是否启用:1-启用；0-不启用','1)设置为现金(投币的),需要配置参数"自助现金支付部件"和"自助机支持面额"和"自助机支持找零"'||CHR(13)||'2)设置为三方帐户支付的:需要编制和站点部署三方接口支持部件,如:zlCard_XXX '||CHR(13)||'','1)投币(现金):适用于自助机支持投币业务'||CHR(13)||'2)三方帐户:适用于与三方机构有专线连接或Pos连接'||CHR(13)||'3)帐户支付:适用于医院采用了一卡通结算的(启用了门诊预存款的)'||CHR(13)||'',NULL From Dual Union All 
    Select 0,1,0,0,0,0,8,'自助现金支付部件',NULL,NULL,'如果在参数"自助支付模式"设置为投币方式,设置投币驱动的部件.','部件名称.类名称'||CHR(13)||'比如:zlCard_ZH.ClsZH'||CHR(13)||'','必须将参数"自助支付模式"设置为现金(即投币方式),本参数才有效.','适用于自助机支持投币业务.',NULL From Dual Union All 
    Select 0,1,0,0,0,0,9,'自助机支持找零',NULL,NULL,'在参数"自助支付模式"设置为投币方式时,控制本台自助是否支持找零钱.'||CHR(13)||'如果支持找零,则本机支持找零钱,需要在参数"自助现金支付部件"设置的部件编制找零接口'||CHR(13)||'如果不支持找零,则为将投币多余的部分存为门诊预交款'||CHR(13)||'','1-支持；0或空-不支持','必须将参数"自助支付模式"设置为现金(即投币方式),本参数才有效','适用于自助机支持投币业务',NULL From Dual Union All 
    Select 0,1,0,0,0,0,10,'共用预交票据批次',NULL,NULL,'1.需要满足条件:预交票据严格控制且操作员没有自用票据且需要打印发票时本参数设置才有效'||CHR(13)||'2.在自助退号管理中进行退号,采用投币方式进行支付退号费时,如果投币总额大于缴费总额,超出部分存为预交款时,在满足上面条件下,根据本参数获取或确定本次所要使用的预交票据批次.'||CHR(13)||'3.在严格控制票据的情况下,获取票据使用批次的规则:'||CHR(13)||' 1)如果操作员有自用的的票据,则先使用自用的票据(存在多批次时,按先领用先用的原则进行使用).'||CHR(13)||' 2)如果不存在自用票据时,则根据本参数设置的共用批次来获取本次需要使用票据批次(存在多批次时,按先领用先用的原则进行使用)','格式:领用ID1,预交类别1|领用ID2,预交类别2|....,'||CHR(13)||'领用ID:票据领用的批次,即票据领用记录.ID','1.需要结合参数"票号严格控制"中预交是否严格控制来进行控制:如果为严格控制且操作员无自用票据,则按本参数设置来读取该使用的票据批次'||CHR(13)||'2.需要结合参数"预存打印方式"来控制，如果要打印，则按本参数来获取某批次的未使用的发票号。'||CHR(13)||' '||CHR(13)||' ','适用于多人在同一工作站使用同一批次收据的业务模式。',NULL From Dual Union All 
    Select 0,1,0,0,0,0,11,'当前预交票据号',NULL,NULL,'1.在自助退号管理中进行退号操作时,如果自助投币的超过退号费,则超出部分存为预交款时发生:'||CHR(13)||' 如果预交票据为非严格控制的情况和需要打印发票的情况下，获取当前已经使用的发票号来产生新发票号（规则是获取已经使用的最后一张发票号+1的方式)'||CHR(13)||'2.初次使用时,需要在参数设置中设置启始的发票号',NULL,'1.需要结合参数"票号严格控制"中预交是否严格控制来进行控制:如果为不严格控制,则在存为预交款时,则根据本参数来获取新的发票号'||CHR(13)||'2.需要结合参数"预存打印方式"来控制，如果要打印，则按本参数来获取新的发票号。'||CHR(13)||' '||CHR(13)||' ','医院不采用严格票据管理',NULL From Dual Union All 
    Select 0,1,0,0,0,0,12,'热敏打印部件',NULL,'zl9WizardInterface.clsPrintInterface','在启用热敏打印时,在完成退号或预交金保存后,调用本参数所设置的部件进行打印退号收据或凭条或预交收据.','格式: 部件名.接口类名'||CHR(13)||'比如:zl9WizardInterface.clsPrintInterface','1.该参数必须设置"启用热敏打印"才有效'||CHR(13)||'2.需要编制热敏打印部件','自助机有热敏打印设备的.',NULL From Dual Union All 
    Select 0,1,0,0,0,0,13,'启用热敏打印',NULL,'0|0','1.在自助退号,设置为退号凭条为启用热敏打印进行打印,则在退号后,调用"热敏打印部件"设置的部件名对应接口来打印退号的凭条,不启用热敏打印机时,则调用自定义报表来打印,调用的报表名为:zl1_BILL_1811'||CHR(13)||'2.在自助退号时,设置为预交收据为启用热敏打印进行打印时,如果采用的是找零方式退费,当找零总额小于退号费后,将剩余款交为预交时,则在保存预交金后,调用"热敏打印部件"设置的部件名所对应的接口来打印预交收据,不启用热敏打印机时,则调用自定义报表来打印,调用的报表名为:zl1_BILL_1103','用|分隔,格式为:退号凭条|预交收据'||CHR(13)||' a.退号凭条:1-启用热敏打印机打印退号凭条；0-不启用热敏打印机打印,使用报表打印退号凭条 '||CHR(13)||' b.预交收据:1-启用热敏打印机打印预交收据；0-不启用热敏打印机打印,使用报表打印预交收据','如果启用热敏打印,则需要配合设置"热敏打印部件"才有效','自助机有热敏打印设备的.',NULL From Dual Union All 
	Select 0,1,0,0,0,0,14,'显示病人信息页面',Null,'1','控制在自助退号管理中，病人在通过身份识别后，是否需要显示身份信息确认页面，以展示当前的病人信息。','0-表示不显示病人信息确认页面，1-表示显示病人信息确认页面',NULL,'适用于医院减少自助操作流程。',NULL From Dual Union All 
Select 私有,本机,授权,固定,部门,性质,参数号,参数名,参数值,缺省值,影响控制说明,参数值含义,关联说明,适用说明,警告说明 From zlParameters Where 1 = 0) A;

Insert Into zlParameters(ID,系统,模块,私有,本机,授权,固定,部门,性质,参数号,参数名,参数值,缺省值,影响控制说明,参数值含义,关联说明,适用说明,警告说明)
Select zlParameters_ID.Nextval,&n_System,1812,A.* From (
Select 私有,本机,授权,固定,部门,性质,参数号,参数名,参数值,缺省值,影响控制说明,参数值含义,关联说明,适用说明,警告说明 From zlParameters Where 1 = 0 Union All  
    Select 0,1,0,0,0,0,1,'自动返回时间',NULL,'10|0|10','正常页面自动返回时间：主要是控制在自助扎帐的除错误页面和成功之外的界面中无任何操作时,自动返回到首页的秒数.'||CHR(13)||'错误页面自动返回时间：主要是控制在自助扎帐的错误界面中无任何操作时,自动返回到首页的秒数.'||CHR(13)||'成功页面自动返回时间：主要是控制在自助扎帐的成功界面中无任何操作时,自动返回到首页的秒数.','格式：正常页面自动返回时间|错误页面自动返回时间|成功页面自动返回时间'||CHR(13)||'>0:表示自动返回的秒数'||CHR(13)||'=0:表示不自动返回',NULL,'适用于医院自助机的不同个性化业务',NULL From Dual Union All  
    Select 0,1,0,0,0,0,2,'自助现金支付部件',NULL,NULL,'设置钱盒驱动部件,在扎帐时调用接口操作钱盒.','部件名称.类名称'||CHR(13)||'比如:zl9WizardInterface.clsCashPay',NULL,'如果钱盒支持程序驱动,则可以编制接口进行控制;如果不支持,则不用设置,扎帐时手动打开钱盒.',NULL From Dual Union All 
    Select 0,1,0,0,0,0,3,'自助扎帐启动部件',NULL,NULL,'工作人员身份牌读卡接口,读取成功后,自动跳转到自助扎帐模块.','部件名称.类名称'||CHR(13)||'比如:zl9WizardInterface.clsRollAcc',NULL,'目前必须编制接口才能启动自助扎帐程序',NULL From Dual Union All  
    Select 0,1,0,0,0,0,4,'热敏打印部件',NULL,'zl9WizardInterface.clsPrintInterface','在启用热敏打印时,完成自助扎帐后,调用本参数所设置的部件进行打印扎帐缴款书.','格式: 部件名.接口类名'||CHR(13)||'比如:zl9WizardInterface.clsPrintInterface','1.该参数必须设置"启用热敏打印"才有效'||CHR(13)||'2.需要编制热敏打印部件','自助机有热敏打印设备的.',NULL From Dual Union All 
    Select 0,1,0,0,0,0,5,'启用热敏打印',NULL,'0','在自助扎帐中,设置缴款书为启用热敏打印进行打印,则在扎帐完成后,调用"热敏打印部件"设置的部件所对应接口来打印缴款书,不启用热敏打印机时,则调用自定义报表来打印,调用的报表名为:zl1_INSIDE_1506','1-启用热敏打印机打印缴款书;0-不启用热敏打印机打印,使用报表打印退号凭条','如果启用热敏打印,则需要配合设置"热敏打印部件"才有效','自助机有热敏打印设备的.',NULL From Dual Union All 
Select 私有,本机,授权,固定,部门,性质,参数号,参数名,参数值,缺省值,影响控制说明,参数值含义,关联说明,适用说明,警告说明 From zlParameters Where 1 = 0) A;

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1801, 0, 0, 0, 0, 0, 0, 23, '是否短信验证', '0', '0', '主要控制自助发卡时，通过对绑定的手机号发送短信验证',
         '0-不发送短信验证,1-发送短信验证', '', '确保手机号的有效性以及是否是病人本人在操作。', Null
  From Dual;

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1805, 0, 0, 0, 0, 0, 0, 25, '允许病人选择划价单', '1', '1', '控制自助缴费管理中，病人能否自行选择要缴费的划价单', 
  '0-不允许显示要缴费的划价单,1-允许显示要缴费的划价单', '', '适用于控制医院的缴费规则。', Null
  From Dual;

UPDATE zlParameters SET 影响控制说明='控制自助挂号在号类选择页面中可选择的号类,格式:号类|启用标志||...',缺省值=NULL WHERE 系统 = &n_System And 参数名='自助挂号类别对照' AND    模块 In (1539, 1802, 1803);

--94713:李业庆,2016-11-30,药品处方发药增加“查找时系统自动回车方式”
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1341, 0, 1, 0, 0, 0, 0, 60, '查找时系统自动回车方式', '0', '0', '通过录入扫描刷卡等方式查找时系统自动添加回车处理的方式',
         '通过录入扫描刷卡等方式查找时系统自动添加回车处理的方式，0-系统不自动回车,1-当录入达到项目或卡号长度时自动回车', Null, '如果要使用读卡设备自带的回车选择0方式，卡号位数固定时', Null
  From Dual;

--115746:李南春,2018-01-17,删除无效参数零卡费走票号
Delete From Zlparameters where 系统 = &n_System And 模块 = 1111 And  参数名 ='零卡费走票号';

--113951:蒋廷中,2018-01-17,手术授权管理模块增加权限授权审核
Insert into zlTables(系统,表名,表空间,分类) Values(100,'人员手术权限申请','ZL9BASEITEM','A2');

--119822:殷瑞,2018-01-16,删除系统无效参数
Delete from Zlparameters Where 系统 = &n_System And  模块 = 1345 and 参数名 = '启用条码扫描设备';

--118197,118296:董露露,2018-01-16
Insert into zlTables(系统,表名,表空间,分类) Values(100,'过敏源','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'医疗机构','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'切口部位','ZL9BASEITEM','A2');
--111164:陈刘,2018-01-15,增加骑线体温
 Insert Into zlParameters
   (ID, 系统, 模块, 私有, 本机, 授权, 固定 , 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
   Select Zlparameters_Id.Nextval, &n_System, 1255, 0, 0, 0, 0, 91, '曲线项目骑线显示', '0', '0',
          ' 体温单中曲线项目是否启用骑线显示，当相邻时点之间，当病人出现发热情况，则该点的曲线则压在右边的竖线上显示。', '0-仅以常规方式显示,1-存在以骑线方式显示','', '适用于需要记录骑线体温的用户', Null
   From Dual;

--119208:焦博,2018-01-19,增加参数剩余款缺省处理方式来设置操作员对病人缴医疗卡费后余额的缺省处理方式
Insert Into zlParameters
   (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
   Select Zlparameters_Id.Nextval, 100, 1107, 1, 0, 0, 0, 0, 0, 25, '剩余款缺省处理方式', Null, Null,
          '缴款金额大于卡费时，多余部分(即:缴款金额-卡费合计)的缺省控制', '0-找补给病人;1-存为预交款', Null, '适用于某些用户在医疗卡发卡时减少找零操作,将找补给病人部分的零钱自动存储为预交款业务', Null
   From Dual;

--119743:刘兴洪,2018-01-12,根据挂号单生成划价记录
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, NULL, 0, 0, 0, 1, 0, 0, 290, '免挂号模式', '', '0', '主要控制医院的就诊流程，如是为免挂号模式，则就诊流程为分诊台进行取号，然后接诊时产生划价收费单,然后到收费窗口统一收费。（即无挂号窗口)',
         '0-按正常的挂号流程进行就诊,1-免挂号模式', '', '主要适用于没有挂号窗口，在门诊直接取号就诊的用户。', Null
  From Dual;

--119216:刘兴洪,2018-02-01,增加立即支付或窗口支付模式
UPDATE  zlParameters SET 参数值含义='0-立即支付模式;1-窗口支付模式;2-立即支付或窗口支付模式',
                         影响控制说明='控制医生站或分诊台挂号时挂号费的支付方式：1.立即支付模式:挂号时，立即进行付款，通常只能使用三方卡或预交款进行支付;2.窗口支付模式:挂号时生成划价单，然后在窗口进行付款；2-立即及窗口支付模式:表示即可扣款，与可以产生划价单在窗口支付。',
			 适用说明='立即支付模式：适用于启用了一卡通消费模式的用户;窗口支付模式适用于未启用一卡通消费的用户;立即支付或窗口支付模式适用于某些用户即启用了一卡通业务，但又存在未使用一卡通的业务。'
WHERE 模块=9000 AND 参数名='挂号模式' AND 系统=&n_system;

--109990:刘涛,2018-01-12,药品批号对照修改
Declare
Begin
  For c_药品批号对照 In (Select a.药品id, a.批次, a.供药单位id 供应商id
                   From (Select a.药品id, a.批次, a.供药单位id, Row_Number() Over(Partition By 药品id, 批次 Order By 审核日期 Desc) Top
                          From 药品收发记录 A
                          Where 单据 = 1 And Mod(记录状态, 3) <> 2 And 审核日期 Is Not Null And Exists
                           (Select 1 From 药品批号对照 B Where a.药品id = b.药品id And a.批次 = b.批次)) A
                   Where a.Top = 1) Loop
    --期间数据
    Update 药品批号对照
    Set 供应商id = c_药品批号对照.供应商id
    Where 药品id = c_药品批号对照.药品id And 批次 = c_药品批号对照.批次;
  
  End Loop;
  Commit;
End;
/

--119578:黄捷,2018-01-12,ZLHIS锚点消息,增加取消检查预约的消息
Update Zlmsg_Lists set Note='影像信息系统:检查预约时' WHERE Code='ZLHIS_PACS_006';
Insert Into Zlmsg_Lists(Bz_Type, Code, Name, Key_Define, Note)
Select 'PACS', 'ZLHIS_PACS_007', '取消检查预约', '<root><医嘱ID></医嘱ID><预约ID></预约ID><预约日期></预约日期><预约序号></预约序号><检查设备名称></检查设备名称></root>', '影像信息系统:取消预约时'  From Dual;

--116486:蔡青松,2018-01-10,添加护士站标本拒收消息提醒
insert into 业务消息类型(编码,名称,说明,保留天数) values('ZLHIS_LIS_004','检验标本拒收','检验技师拒收标本之后产生的通知消息',7);

--118203:董露露,2018-01-10,住院医生站首页录入门诊诊断后不作为导入临床路径的诊断依据
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1261,0, 0, 0, 0, 0, 0, 54, '门诊诊断不作为导入临床路径的诊断依据', '0', '0', '启用改参数后，住院首页编辑门诊诊断保存数据后，不根据门诊诊断导入相应的临床路径，否则可以导入相应诊断的临床路径。',
         '0-不启用，1-启用', '', '适用于住院医生站', Null
  From Dual;

--118402:秦龙,2018-01-10,修正加成率数据
Update 材料特性 A Set a.加成率 =(1/(1-a.指导差价率/100)-1)*100 Where a.加成率 Is Null;

--119437:胡俊勇,2018-01-09,临床相关消息修改
Delete From Zlmsg_Lists where Code in ('ZLHIS_CIS_001','ZLHIS_CIS_004','ZLHIS_CIS_005','ZLHIS_CIS_006','ZLHIS_CIS_007','ZLHIS_CIS_008','ZLHIS_CIS_009','ZLHIS_CIS_013','ZLHIS_CIS_015','ZLHIS_CIS_024','ZLHIS_CIS_035');

Update Zlmsg_Lists set NAME = '病区执行医嘱作废',Note='住院医生工作站/住院护士工作站:作废住院病人病区执行医嘱时' where code = 'ZLHIS_CIS_003';
Update Zlmsg_Lists set NAME = '撤消患者检验申请',KEY_DEFINE = '<root><病人ID></病人ID><主页ID></主页ID><挂号单></挂号单><发送号></发送号><ID></ID><NO></NO><病人来源></病人来源></root>' where code = 'ZLHIS_CIS_036';
Update Zlmsg_Lists set NAME = '撤消患者检查申请', KEY_DEFINE = '<root><病人ID></病人ID><主页ID></主页ID><挂号单></挂号单><发送号></发送号><ID></ID><NO></NO><病人来源></病人来源></root>' where code = 'ZLHIS_CIS_037';
Update Zlmsg_Lists set NAME = '撤消患者手术申请',KEY_DEFINE = '<root><病人ID></病人ID><主页ID></主页ID><挂号单></挂号单><发送号></发送号><ID></ID><NO></NO></root>' where code = 'ZLHIS_CIS_038';
Update Zlmsg_Lists set KEY_DEFINE = '<root><病人ID></病人ID><就诊ID></就诊ID><ID></ID><疾病ID></疾病ID><诊断ID></诊断ID><诊断描述></诊断描述></root>' where code = 'ZLHIS_CIS_011';

Insert Into Zlmsg_Lists(Bz_Type, Code, Name, Key_Define, Note)
Select '临床', 'ZLHIS_CIS_012', '病区执行医嘱校对', '<root><病人ID></病人ID><主页ID></主页ID><ID></ID><NO></NO></root>', '住院护士工作站:校对病区执行医嘱时'  From Dual union all
Select '临床', 'ZLHIS_CIS_026', '病区执行医嘱发送', '<root><病人ID></病人ID><主页ID></主页ID><发送号></发送号><ID></ID><NO></NO></root>', '住院医生工作站/住院护士工作站:发送病区执行医嘱时'  From Dual union all
Select '临床', 'ZLHIS_CIS_039', '撤消患者输血申请', '<root><病人ID></病人ID><主页ID></主页ID><挂号单></挂号单><发送号></发送号><ID></ID><NO></NO></root>', '门诊医生工作站:作废输血医嘱时;住院医生工作站/住院护士工作站:回退输血医嘱发送时'  From Dual union all
Select '临床', 'ZLHIS_CIS_040', '撤消患者会诊申请', '<root><病人ID></病人ID><主页ID></主页ID><发送号></发送号><ID></ID><NO></NO></root>', '住院医生工作站/住院护士工作站:回退会诊医嘱发送时'  From Dual union all
Select '临床', 'ZLHIS_CIS_041', '撤消患者抢救医嘱', '<root><病人ID></病人ID><主页ID></主页ID><发送号></发送号><ID></ID><NO></NO></root>', '住院医生工作站/住院护士工作站:回退抢救医嘱发送时'  From Dual union all
Select '临床', 'ZLHIS_CIS_042', '撤消患者死亡医嘱', '<root><病人ID></病人ID><主页ID></主页ID><发送号></发送号><ID></ID><NO></NO></root>', '住院医生工作站/住院护士工作站:回退死亡医嘱发送时'  From Dual union all
Select '临床', 'ZLHIS_CIS_043', '撤消特殊治疗医嘱', '<root><病人ID></病人ID><主页ID></主页ID><发送号></发送号><ID></ID><NO></NO></root>', '住院医生工作站/住院护士工作站:回退特殊治疗医嘱发送时'  From Dual union all
Select '临床', 'ZLHIS_CIS_044', '撤消病区执行医嘱', '<root><病人ID></病人ID><主页ID></主页ID><发送号></发送号><ID></ID><NO></NO><发送数次></发送数次><首次时间></首次时间><末次时间></末次时间><样本条码></样本条码></root>', '住院医生工作站/住院护士工作站:回退病区执行医嘱发送时'  From Dual union all
Select '临床', 'ZLHIS_CIS_050', '患者医嘱执行登记', '<root><病人ID></病人ID><主页ID></主页ID><挂号单></挂号单><发送号></发送号><ID></ID><要求时间></要求时间><执行时间></root>', '医生/护士/医技:对医嘱进行执行登记时'  From Dual union all
Select '临床', 'ZLHIS_CIS_051', '患者医嘱取消执行登记', '<root><病人ID></病人ID><主页ID></主页ID><挂号单></挂号单><发送号></发送号><ID></ID><要求时间></要求时间><执行时间><本次数次></本次数次><执行结果></执行结果><执行摘要></执行摘要><执行科室ID></执行科室ID><执行人></执行人><核对人></核对人><记录来源></记录来源></root>', '医生/护士/医技:删除医嘱执行登记时'  From Dual union all
Select '临床', 'ZLHIS_CIS_052', '患者医嘱执行完成', '<root><病人ID></病人ID><主页ID></主页ID><挂号单></挂号单><发送号></发送号><ID></ID></root>', '医生/护士/医技:医嘱执行完成时'  From Dual union all
Select '临床', 'ZLHIS_CIS_053', '患者医嘱撤消执行完成', '<root><病人ID></病人ID><主页ID></主页ID><挂号单></挂号单><发送号></发送号><ID></ID></root>', '医生/护士/医技:取消医嘱执行完成时'  From Dual;
            

--119475:刘鹏飞,2018-01-08,输血申请单预览打印前调用检查函数
Insert Into Zlprocedure(Id, 类型, 名称, 状态, 所有者, 说明) Values(Zlprocedure_Id.Nextval,2,'Zl1_Fun_BloodApplyPrint',3,User,'申请单预览打印时对医嘱的相关内容进行检查，并返回提示及处理结果。');

--119212:殷瑞,2018-01-08,该新增参数用于控制输液配置中心的药品名称显示
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1345, 1, 0, 0, 0, 0, 0, 43, '药品名称显示方式', '', '0', '在明细界面中,用于显示药品名称列的显示方式',
         '根据操作员的设置,显示药品名称列的显示方式。0-药品编码+药品名称;1-药品名称;2-药品编码', '', '适用于操作员查看药品名称列显示方式', Null
  From Dual;

--119643:李南春,2018-01-08,消息发送内容调整
Update Zlmsg_Lists set KEY_DEFINE = '<root><险类></险类><收费细目ID></收费细目ID><项目编码></项目编码><项目名称></项目名称><医保编码></医保编码><医保名称></医保名称></root>' where code = 'ZLHIS_DICT_049';

Delete From Zlmsg_Lists where Code in ('ZLHIS_CHARGE_001','ZLHIS_CHARGE_003');

--116367:刘涛,2018-01-08,分批出库时允许修改产地批号 处理
Update zlParameters
Set 参数名 = '移库时分批药品允许补录产地批号', 影响控制说明 = '药品编辑移库单时，分批药品明确批次是否允许补录产地批号信息', 参数值含义 = '药品在编辑移库单时，分批药品明确批次是否允许补录产地批号信息，0-不允许补录,1-允许补录'
Where 参数名 = '分批出库时允许修改产地批号' And 模块 = 1304 And 系统 = &n_System;

--119434:梁唐彬,2018-01-04,集成平台消息处理
Delete From Zlmsg_Lists
Where Code In ('ZLHIS_PATIENT_003', 'ZLHIS_PATIENT_021', 'ZLHIS_PATIENT_022', 'ZLHIS_PATIENT_023', 'ZLHIS_PATIENT_024',
               'ZLHIS_PATIENT_025', 'ZLHIS_PATIENT_027');
Update Zlmsg_Lists set Key_Define='<root><病人ID></病人ID><主页ID></主页ID><撤销方式></撤销方式><科室ID></科室ID><病区ID></病区ID><护理等级ID></护理等级ID><医疗小组ID></医疗小组ID><床号></床号><责任护士></责任护士><主任医师></主任医师><主治医师></主治医师><经治医师></经治医师><病情></病情></root>' WHERE Code='ZLHIS_PATIENT_006';
Insert Into Zlmsg_Lists(Bz_Type, Code, Name, Key_Define, Note)
Select '病人', 'ZLHIS_PATIENT_028', '删除患者信息', '<root><病人ID></病人ID><姓名></姓名><性别></性别><年龄></年龄><出生日期></出生日期><门诊号></门诊号><身份证号></身份证号></root>', '病人信息管理:对病人信息删除时'  From Dual;

--121298:梁唐彬,2018-01-30,新病理系统集成平台消息
Insert Into Zlmsg_Lists(Bz_Type, Code, Name, Key_Define, Note)
Select '临床', 'ZLHIS_CIS_054', '患者病理申请', '<root><病人ID></病人ID><主页ID></主页ID><挂号单></挂号单><发送号></发送号><ID></ID><NO></NO><病人来源></病人来源></root>', '门诊/住院医嘱发送病理医嘱时'  From Dual Union All
Select '临床', 'ZLHIS_CIS_055', '撤消患者病理申请', '<root><病人ID></病人ID><主页ID></主页ID><挂号单></挂号单><发送号></发送号><ID></ID><NO></NO><病人来源></病人来源</root>', '门诊病理医嘱作废时/住院医嘱回退发送病理医嘱时'  From Dual;


--117882:陈龙,2017-12-06,取血完成消息提示护士站
insert into 业务消息类型(编码,名称,说明,保留天数) values ('ZLHIS_BLOOD_003','取血完成提醒','护士取血完成，提醒护士站',1);

--91654:秦龙,2018-01-04,药品计划管理列设置
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1330, 1, 0, 0, 1, 0, 0, 11, '选择列', '', '', '在单据编辑界面中，按参数的列顺序显示计划单表格内容',
         '为空表示按默认列顺序并且所有列都显示;有内容表示按用户所选列及顺序显示。格式为:C1|C2|…', '与参数"屏蔽列"相关', '用户自定义编辑界面的列的显示', Null
  From Dual;

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1330, 1, 0, 0, 1, 0, 0, 12, '屏蔽列', '', '', '在单据编辑界面中，该参数的列不显示在表格中',
         '为空表示没有屏蔽列;有内容表示这些列不在单据界面显示。格式为:C1|C2|…',  '与参数"选择列"相关', '用户自定义编辑界面的列的隐藏', Null
  From Dual;

--112257:胡俊勇,2018-01-03,新版执行单打印
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1254, 0, 0, 0, 0, 1, 0, 81, '执行单可用报表', Null, Null,
         '启用参数后，当前病区打印执行单界面只能打印勾选的病区报表。', '报表编号1|报表编号2・・・', '新版执行单打印界面使用。', '新版执行单打印界面使用', Null
  From Dual;

--91287:秦龙,2017-12-29,药品目录管理导入项目设计
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1023, 0, 0, 0, 0, 0, 0, 12, '列的显示隐藏', '',
         '类别,0,0|上级名称,0,0|编码,0,0|名称,0,0||类别,0,0|分类,0,0|品种编码,0,0|品种名称,0,0|规格编码,0,0|药品规格,0,0|生产商,0,0|剂型,0,0|剂量单位,0,0|售价单位,0,0|售价换算系数,0,0|门诊单位,0,0|门诊换算系数,0,0|住院单位,0,0|住院换算系数,0,0|药库单位,0,0|药库换算系数,0,0|是否变价,0,0|成本价,0,0|售价,0,0|收入项目,0,0|住院可否分零,0,0|门诊可否分零,0,0|服务对象,1,0|药库分批,1,0|药房分批,1,0|效期(月),1,0|供应商名称,1,0|供应商许可证号,1,0|供应商许可证效期,1,0|',
         '设置列的显示和隐藏', '设置列的显示和隐藏(列名,0-必选1-可选,0-显示1-隐藏|...||列名,0-必选1-可选,0-显示1-隐藏|...),双竖线“||”分开分类和明细', Null,
         '可用于调整导入项目文件的列', Null
  From Dual;

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1023, 0, 0, 0, 0, 0, 0, 13, '导入文件检查方式', '',
         '0/0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0', '导入文件时需要对数据做的检查和判断',
         '导入文件时需要对数据做的检查和判断(0-错误提示1-错误禁止/0-提示1-禁止|...)', Null, '适用于导入文件的检查判断', Null
  From Dual;

--116247:秦龙,2017-12-26,修正药品用法用量的性质
Update 药品用法用量 Set 性质 = 1 Where 性质 Is Null;

--118197:董露露,2017-12-25，过敏源结构化录入
Insert Into zlBaseCode(系统,表名,固定,说明,分类) Values(&n_System,'过敏源',0,'首页录入过敏源时的过敏源信息','医疗工作' ); 

--115785:焦博,2017-12-21,调整参数允许出院病人缴预交,增加公共模块参数禁止在院病人缴门诊预交
Update zlParameters
Set 参数名 = '允许出院病人缴住院预交'
Where 系统 = &n_System And 模块 = 1103 And 参数名 = '允许出院病人缴预交';

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1103, 0, 0, 0, 0, 0, 0, 24, '禁止在院病人缴门诊预交', Null, '0',
         '如果启用了本参数,则针对在院病人禁止缴门诊预交款,否则允许在院病人缴门诊预交', '0-禁止，1-允许', Null, '适用于个别医院针对在院病人禁止缴门诊预交业务', Null
  From Dual;

--118802:刘涛,2017-12-21,药品卫材验收结论处理
Insert Into zlBaseCode(系统, 表名, 固定, 说明, 分类) Values (&n_System, '入库验收结论', 0, '对入库产品检查验收的记录', '药品管理');

--118802:刘涛,2017-12-21,药品卫材验收结论处理
Insert into zlTables(系统,表名,表空间,分类) Values(100,'入库验收结论','ZL9BASEITEM','A2');

--118748:李业庆,2017-12-20,退药，销帐消息锚点修改
Update Zlmsg_Lists
Set Key_Define = '<root><冲销记录ID></冲销记录ID><待发记录ID></待发记录ID><数量></数量><费用ID></费用ID></root>'
Where Code = 'ZLHIS_DRUG_006';

Update Zlmsg_Lists
Set Key_Define =  '<root> <收费类别></收费类别><费用ID></费用ID><收发IDS><收发ID></收发ID><数量></数量></收发IDS></root>'
Where Code = 'ZLHIS_CHARGE_008';

--116297:胡俊勇,2017-12-20,临嘱单术后医嘱换页
Insert Into Zlparameters
  (Id, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System,1254, 0, 0,1,1, 0, 0, 80, '临嘱单术后换页', '0', '0',
         '打印临嘱单时，如果启用了此参数，术后医嘱会在临嘱单上显示并且会进行换页打印。', '0-不启用，1-启用', Null, '适用换页打印，控制临嘱单术后换页。',null
  From Dual;   

--118156:李业庆,2017-12-20,库存和价格表批次为空和0的问题处理
--适用范围：10.35.70-35.80
--修正内容:药品库存中药品不分批的数据出现了既有批次=0，又有批次=null
--修正范围：修正药品库存,药品价格记录
--耗时说明: 药品收发记录数据共3541034条，修正未审核的明细数据8562条，该数据修正脚本在1分钟内执行完成，测试环境如下:
--1.硬件环境：PC机
Declare
  n_可用数量 药品库存.可用数量%Type;
  n_数量     药品库存.实际数量%Type;
  n_金额     药品库存.实际金额%Type;
  n_差价     药品库存.实际差价%Type;
  n_时价售价 药品库存.零售价%Type;
  n_成本价   药品库存.平均成本价%Type;
  n_Count      Number(18) := 0;
Begin
  --1.库房不分批，只有一个批次，且批次=null
  --修正库存记录
  --写更新日志
  Update Zlupgradeconfig Set 内容 = Null Where 项目 = User || '_药品库存批次修正_20190312_1';
  If Sql%NotFound Then
    Insert Into Zlupgradeconfig (项目, 内容) Values (User || '_药品库存批次修正_20190312_1', Null);
  End If;

  Update 药品库存
  Set 批次 = 0
  Where 性质 = 1 And 批次 Is Null And
        (库房id, 药品id) In (Select b.库房id, b.药品id
                         From 药品库存 B,
                              (Select a.药品id, a.库房id
                                From 药品库存 A, 药品规格 B
                                Where a.性质 = 1 And a.药品id = b.药品id And Zl_Fun_Getbatchpro(a.库房id, b.药品id) = 0
                                Group By a.库房id, a.药品id
                                Having Count(Nvl(a.批次, 0)) = 1) A
                         Where b.性质 = 1 And b.库房id = a.库房id And b.药品id = a.药品id And b.批次 Is Null);

  Commit;

  Update Zlupgradeconfig Set 内容 = '已处理批次为null库存' Where 项目 = User || '_药品库存批次修正_20190312_1';
  Commit;

  --2.库房不分批，至少有2个批次，可能既有批次为null的，也有批次=0的  
  --修正药品库存  
  --写更新日志
  Update Zlupgradeconfig Set 内容 = Null Where 项目 = User || '_药品库存批次修正_20190312_2';
  If Sql%NotFound Then
    Insert Into Zlupgradeconfig (项目, 内容) Values (User || '_药品库存批次修正_20190312_2', Null);
  End If;
  For r_库存批次调整 In (Select Distinct b.库房id, b.药品id, Nvl(c.是否变价, 0) As 是否时价, Nvl(d.上次售价, e.现价) As 时价售价, d.成本价
                   From 药品库存 B, 收费项目目录 C, 药品规格 D, 收费价目 E,
                        (Select a.药品id, a.库房id
                          From 药品库存 A, 药品规格 B
                          Where a.性质 = 1 And a.药品id = b.药品id And Zl_Fun_Getbatchpro(a.库房id, b.药品id) = 0
                          Group By a.库房id, a.药品id
                          Having Count(Nvl(a.批次, 0)) > 1) A
                   Where b.性质 = 1 And b.库房id = a.库房id And b.药品id = a.药品id And c.Id = a.药品id And d.药品id = c.Id And
                         e.收费细目id = c.Id And Sysdate Between e.执行日期 And Nvl(e.终止日期, Sysdate)
                   Order By b.库房id, b.药品id) Loop
  
    --库存中合并批次的数量，金额，差价，并重算零售价（时价）和平均成本价，合并后批次=0
    Select Sum(Nvl(可用数量, 0)), Sum(Nvl(实际数量, 0)), Sum(Nvl(实际金额, 0)), Sum(Nvl(实际差价, 0))
    Into n_可用数量, n_数量, n_金额, n_差价
    From 药品库存
    Where 性质 = 1 And 库房id = r_库存批次调整.库房id And 药品id = r_库存批次调整.药品id And Nvl(批次, 0) = 0;
  
    --计算时价售价        
    If r_库存批次调整.是否时价 = 1 Then
      If n_数量 <> 0 Then
        n_时价售价 := n_金额 / n_数量;
      End If;
    
      If n_数量 = 0 Or Nvl(n_时价售价, 0) <= 0 Then
        n_时价售价 := r_库存批次调整.时价售价;
      End If;
    End If;
  
    --计算成本价
    If n_数量 <> 0 Then
      n_成本价 := (n_金额 - n_差价) / n_数量;
    End If;
  
    If n_数量 = 0 Or Nvl(n_成本价, 0) <= 0 Then
      n_成本价 := r_库存批次调整.成本价;
    End If;
  
    --更新批次=0的记录
    Update 药品库存
    Set 可用数量 = n_可用数量, 实际数量 = n_数量, 实际金额 = n_金额, 实际差价 = n_差价, 零售价 = Decode(r_库存批次调整.是否时价, 1, n_时价售价, Null),
        平均成本价 = n_成本价
    Where 性质 = 1 And 库房id = r_库存批次调整.库房id And 药品id = r_库存批次调整.药品id And 批次 = 0;
  End Loop;

  --删除批次=null的记录
  Delete From 药品库存 A
  Where a.性质 = 1 And a.批次 Is Null And Exists
   (Select 1 From 药品规格 B Where a.药品id = b.药品id) And Zl_Fun_Getbatchpro(a.库房id, a.药品id) = 0;

  Commit;

  Update Zlupgradeconfig Set 内容 = '已处理批次为0和null库存' Where 项目 = User || '_药品库存批次修正_20190312_2';
  Commit;

  --写更新日志
  Update Zlupgradeconfig Set 内容 = Null Where 项目 = User || '_药品库存批次修正_20190312_3';
  If Sql%NotFound Then
    Insert Into Zlupgradeconfig (项目, 内容) Values (User || '_药品库存批次修正_20190312_3', Null);
  End If;

  --3.1删除价格表中批次为空的记录
  Delete From 药品价格记录 A Where a.批次 Is Null And Not Exists (Select 1 From 药品价格记录 B Where b.原价id = a.Id);
  Commit;
  
  --3.2价格表中批次为空，但有子记录的，先修改批次=0，再停用
  For r_价格为空 In (Select ID, 记录状态, 执行日期
                 From 药品价格记录 A
                 Where a.批次 Is Null And Exists (Select 1 From 药品价格记录 B Where b.原价id = a.Id)) Loop
    Update 药品价格记录 Set 批次 = 0 Where ID = r_价格为空.Id;
  
    If r_价格为空.记录状态 = 1 Then
      Update 药品价格记录 Set 记录状态 = 2, 终止日期 = r_价格为空.执行日期 Where ID = r_价格为空.Id;
    End If;
  End Loop;
  Commit;

  --4.根据库存记录批次=0的数据检查对应的价格表
  For r_价格调整 In (Select a.库房id, a.药品id, a.批次, Nvl(c.是否变价, 0) As 时价, Nvl(a.零售价, 0) As 零售价, a.平均成本价
                 From 药品库存 A, 药品规格 B, 收费项目目录 C
                 Where a.药品id = b.药品id And a.药品id = c.Id And a.性质 = 1 And a.批次 = 0
                 Order By a.库房id, a.药品id) Loop
  
    --处理时价售价
    If r_价格调整.时价 = 1 Then
      Begin
        Select Count(ID)
        Into n_Count
        From 药品价格记录
        Where 价格类型 = 1 And 记录状态 = 1 And 库房id = r_价格调整.库房id And 药品id = r_价格调整.药品id And 批次 = 0;
      Exception
        When Others Then
          n_Count := 0;
      End;
    
      --如果批次=0的生效的价格存在2条或以上，则删除只保留1条
      If n_Count > 1 Then
        Delete From 药品价格记录
        Where 价格类型 = 1 And 记录状态 = 1 And 库房id = r_价格调整.库房id And 药品id = r_价格调整.药品id And 批次 = 0 And
              ID < (Select Max(ID)
                    From 药品价格记录
                    Where 价格类型 = 1 And 记录状态 = 1 And 库房id = r_价格调整.库房id And 药品id = r_价格调整.药品id And 批次 = 0);
      End If;
    
      --停止价格表中的价格，并新产生批次=0的价格
      Update 药品价格记录
      Set 终止日期 = Sysdate - 1 / 24 / 60 / 60, 记录状态 = 2
      Where 库房id = r_价格调整.库房id And 药品id = r_价格调整.药品id And 批次 = 0 And 记录状态 = 1 And 价格类型 = 1;
    
      --产生时价售价价格
      Insert Into 药品价格记录
        (ID, 原价id, 价格类型, 药品id, 库房id, 批次, 原价, 现价, 供药单位id, 批号, 效期, 产地, 灭菌效期, 发票号, 发票日期, 发票金额, 应付款变动, 执行日期, 终止日期, 记录状态,
         调价类型, 调价说明, 调价人, 调价汇总号, 收发id)
        Select 药品价格记录_Id.Nextval, Null, 1, 药品id, 库房id, 批次, 0, r_价格调整.零售价, 上次供应商id, 上次批号, 效期, 上次产地, 灭菌效期, Null, Null,
               Null, Null, Sysdate, To_Date('3000-01-01', 'yyyy-mm-dd'), 1, 0, '批次合并', 'ZLHIS', Null, Null
        From 药品库存
        Where 性质 = 1 And 库房id = r_价格调整.库房id And 药品id = r_价格调整.药品id And 批次 = 0;
    End If;
  
    --处理成本价
    Begin
      Select Count(ID)
      Into n_Count
      From 药品价格记录
      Where 价格类型 = 2 And 记录状态 = 1 And 库房id = r_价格调整.库房id And 药品id = r_价格调整.药品id And 批次 = 0;
    Exception
      When Others Then
        n_Count := 0;
    End;
  
    --如果批次=0的生效的价格存在2条或以上，则删除只保留1条
    If n_Count > 1 Then
      Delete From 药品价格记录
      Where 价格类型 = 2 And 记录状态 = 1 And 库房id = r_价格调整.库房id And 药品id = r_价格调整.药品id And 批次 = 0 And
            ID < (Select Max(ID)
                  From 药品价格记录
                  Where 价格类型 = 2 And 记录状态 = 1 And 库房id = r_价格调整.库房id And 药品id = r_价格调整.药品id And 批次 = 0);
    End If;
  
    --停止价格表中的价格，并新产生批次=0的价格
    Update 药品价格记录
    Set 终止日期 = Sysdate - 1 / 24 / 60 / 60, 记录状态 = 2
    Where 库房id = r_价格调整.库房id And 药品id = r_价格调整.药品id And 批次 = 0 And 记录状态 = 1 And 价格类型 = 2;
  
    --产生时价售价价格
    Insert Into 药品价格记录
      (ID, 原价id, 价格类型, 药品id, 库房id, 批次, 原价, 现价, 供药单位id, 批号, 效期, 产地, 灭菌效期, 发票号, 发票日期, 发票金额, 应付款变动, 执行日期, 终止日期, 记录状态, 调价类型,
       调价说明, 调价人, 调价汇总号, 收发id)
      Select 药品价格记录_Id.Nextval, Null, 2, 药品id, 库房id, 批次, 0, r_价格调整.平均成本价, 上次供应商id, 上次批号, 效期, 上次产地, 灭菌效期, Null, Null,
             Null, Null, Sysdate, To_Date('3000-01-01', 'yyyy-mm-dd'), 1, 0, '批次合并', 'ZLHIS', Null, Null
      From 药品库存
      Where 性质 = 1 And 库房id = r_价格调整.库房id And 药品id = r_价格调整.药品id And 批次 = 0;
  End Loop;
  Commit;

  Update Zlupgradeconfig Set 内容 = '已处理批次为0价格' Where 项目 = User || '_药品库存批次修正_20190312_3';
  Commit;

  --5.处理价格表中可能有多个现生效的批次=0但没有库存记录的价格
  --写更新日志
  Update Zlupgradeconfig Set 内容 = Null Where 项目 = User || '_药品库存批次修正_20190312_4';
  If Sql%NotFound Then
    Insert Into Zlupgradeconfig (项目, 内容) Values (User || '_药品库存批次修正_20190312_4', Null);
  End If;
  For r_无库存价格 In (Select a.库房id, a.药品id, a.价格类型
                  From 药品价格记录 A
                  Where a.记录状态 = 1 And a.批次 = 0 And Not Exists
                   (Select 1
                         From 药品库存 B
                         Where b.性质 = 1 And b.库房id = a.库房id And b.药品id = a.药品id And b.批次 = a.批次)
                  Group By a.库房id, a.药品id, a.价格类型
                  Having Count(a.批次) > 1
                  Order By a.价格类型, a.库房id, a.药品id) Loop
  
    --删除多余的价格，只保留1个
    Delete From 药品价格记录
    Where 价格类型 = r_无库存价格.价格类型 And 记录状态 = 1 And 库房id = r_无库存价格.库房id And 药品id = r_无库存价格.药品id And 批次 = 0 And
          ID < (Select Max(ID)
                From 药品价格记录
                Where 价格类型 = r_无库存价格.价格类型 And 记录状态 = 1 And 库房id = r_无库存价格.库房id And 药品id = r_无库存价格.药品id And 批次 = 0);
  End Loop;
  Commit;

  Update Zlupgradeconfig Set 内容 = '已处理多个批次为0价格' Where 项目 = User || '_药品库存批次修正_20190312_4';
  Commit;
End;
/

--117628:董露露,2017-12-18,解决首页诊断录入附码自动提取的问题
Insert Into zlParameters(ID,系统,模块,私有,本机,授权,固定,部门,性质,参数号,参数名,参数值,缺省值,影响控制说明,参数值含义,关联说明,适用说明,警告说明)
Select zlParameters_ID.Nextval,100,-Null,-Null,-Null,-Null,-Null,A.* From (
Select 部门,性质,参数号,参数名,参数值,缺省值,影响控制说明,参数值含义,关联说明,适用说明,警告说明 From zlParameters Where 1 = 0 Union All  
    Select 0,0,289,'诊断自动提取附码','0','0','启用参数时：首页中诊断录入时附码自动提取，否则就手动填写。','0-不启用，1-启用。',Null,'首页诊断录入',Null From Dual Union All 
Select 部门,性质,参数号,参数名,参数值,缺省值,影响控制说明,参数值含义,关联说明,适用说明,警告说明 From zlParameters Where 1 = 0) A;

--117147:冉俊明,2017-12-18,消费卡管理误差费处理
Update zlParameters
Set 影响控制说明 = '1.在挂号收费操作时，针对零钱的处理规则；如果针对医保病人进行挂号时，医保参数25-分币处理为False时，该参数失效。' || Chr(13) ||
              '2.在病人收费或医保补结算管理中进行收费或退费时或自助缴费管理中自助缴费时，针对零钱的处理规则；如果是针对医保病人收费或退费时，医保参数25-分币处理为False时，该参数失效。' || Chr(13) ||
              '3.在病人结帐管理中进行结帐或作废时，针对零钱的处理规则；如果是针对医保病人结帐或作废时，医保参数25-分币处理为False时，该参数失效。' || Chr(13) ||
              '4.在消费卡管理中进行缴款或退款时，针对零钱的处理规则。',
    参数值含义 = '1.四位数分别表示，第一位挂号;第二位收费;第三位结帐;第四位消费卡' || Chr(13) ||
             '2.每位用不同数字代表:0-不处理,1-分币四舍五入,2-分币补整收取,3-分币舍分收取,4-分币四舍六入五成双,5-角币三七作五、二舍八入,6-分币五舍六入'
Where 系统 = &n_System And 模块 Is Null And 参数号 = 14;

--116073:黄捷,2017-12-15,RIS接口支持多HIS库
Insert into zlTables(系统,表名,表空间,分类) Values(100,'RIS分院设置','ZL9BASEITEM','A2');

--101301:陈龙,2017-12-06,取血完成消息提示护士站
insert into 业务消息类型(编码,名称,说明,保留天数) values ('ZLHIS_BLOOD_003','取血完成提醒','护士取血完成，提醒护士站',1);

--116339:陈刘,2017-12-14,记录项目管理√符号设置修改
Declare
  v_Data Varchar2(1000);
  v_Pre  Varchar2(1000);
  v_Text Varchar2(30);
  Cursor Cur_Item Is
    Select 项目序号, 项目值域, 缺省值 From 护理记录项目 Where 项目表示 In (2, 3);
Begin

  For Row_Format In Cur_Item Loop
    v_Data := Row_Format.项目值域;
    v_Pre  := '';
    While v_Data Is Not Null Loop
      If Instr(v_Data, ';', 1) > 0 Then
        v_Text := Substr(v_Data, 1, Instr(v_Data, ';', 1) - 1);
      Else
        v_Text := v_Data;
        v_Data := '';
      End If;
      If Instr(v_Text, '√', 1) = 1 Then
        If v_Pre Is Null Then
          v_Pre := Substr(v_Text, 2);
        Else
          v_Pre := v_Pre || ';' || Substr(v_Text, 2);
        End If;
        v_Text := Substr(v_Text, 2);
        v_Data := Substr(v_Data, Instr(v_Data, ';', 1) + 1);
        v_Data := v_Pre || ';' || v_Data;
        Update 护理记录项目 Set 缺省值 = v_Text, 项目值域 = v_Data Where 项目序号 = Row_Format.项目序号;
        Exit;
      Else
        If v_Pre Is Null Then
          v_Pre := v_Text;
        Else
          v_Pre := v_Pre || ';' || v_Text;
        End If;
        v_Data := Substr(v_Data, Instr(v_Data, ';', 1) + 1);
      End If;
    End Loop;
  End Loop;
  Update 护理记录项目 Set 缺省值 = '√', 项目值域 = '√;√(异)' Where 项目名称 = '生产' And 保留项目 = 1;
End;
/

--116846:刘鹏飞,2017-12-14,输血申请保存自定义函数检查
Insert Into Zlprocedure(Id, 类型, 名称, 状态, 所有者, 说明) Values(Zlprocedure_Id.Nextval,2,'Zl1_EX_BloodApplyCheck',3,User,'新开和修改输血申请时，保存数据之前对申请的相关内容进行检查，并返回提示及处理结果。');

--115748:焦博,2017-12-13,修改挂号模块和费用虚拟模块本机参数"缺省预约方式"加上该参数的参数值含义和适用说明
Update zlParameters
Set 影响控制说明 = '门诊预约时默认选择的预约方式', 参数值含义 = '预约方式.名称', 适用说明 = '适用于病人预约业务'
Where 系统 = &n_System And 模块 = 1111 And 参数名 = '缺省预约方式';
Update zlParameters
Set 影响控制说明 = '医生工作站预约时默认选择的预约方式', 参数值含义 = '预约方式.名称', 适用说明 = '适用于病人预约业务'
Where 系统 = &n_System And 模块 = 9000 And 参数名 = '缺省预约方式';

--117641:李南春,2017-12-11,删除无效参数
Delete from Zlparameters Where 系统 = &n_System And  模块 = 1111 and 参数名 = '退号显示详细信息';

--117047:蒋廷中,2017-12-11,医生站是否打印诊疗单据
Update zlParameters Set 私有 = 1, 本机 = 1 Where 参数名 = '门诊发送单据打印' And 模块 = 1252 And 系统 = &n_System;

Update zlParameters Set 私有 = 1, 本机 = 1 Where 参数名 = '指引单打印方式' And 模块 = 1252 And 系统 = &n_System;

Update zlParameters Set 私有 = 1, 本机 = 1 Where 参数名 = '住院发送单据打印' And 模块 = 1254 And 系统 = &n_System;


--118130:蒋敏,2017-12-11,将报表没有权限的添加权限
Declare
Begin
  For R In (Select 报表id, f_List2str(Cast(Collect(对象) As t_Strlist), ',', 1) As 对象
            From (Select 报表id, Replace(Replace(对象, 'ZLHIS.', ''), 'ZLTOOLS.', '') 对象 From zlRPTDatas)
            Group By 报表id) Loop
    For P In (Select Distinct Column_Value
              From Table(f_Str2list(R.对象))
              Where Exists
               (Select 1 From zltables Where 表名 = Column_Value And 系统 <> 0) And
                    instr(',部门表,人员表,部门人员,人员上机表,人员性质说明,人员性质分类,', ',' || column_value || ',') = 0) Loop
      Insert Into zlProgPrivs
        (系统, 序号, 功能, 所有者, 对象, 权限)
        Select c.*
        From (Select a.系统, a.程序id, a.功能, User, P.Column_Value, 'SELECT'
               From zlReports a, zlProgFuncs d
               Where a.id = r.报表id And a.程序id Is Not Null
               Union
               Select b.系统, b.程序id, b.功能, User, P.Column_Value, 'SELECT' From zlRPTPuts b Where b.报表id = r.报表id) c
        Where Exists (Select 1 From zlProgFuncs Where 系统 = c.系统 And 序号 = c.程序id And 功能 = c.功能) And Not Exists
         (Select 1
               From zlProgPrivs
               Where 系统 = c.系统 And 序号 = c.程序id And 功能 = c.功能 And 对象 = P.Column_Value And 所有者 = User And 权限 = 'SELECT');
    End Loop;
  End Loop;
End;
/
--94173:胡俊勇,2017-12-08,校对疑问消息
Insert Into 业务消息类型(编码,名称,说明,保留天数) 
Select 'ZLHIS_CIS_035','校对疑问提醒','护士校对医嘱时设为疑问时产生的一个通知消息。',7 From Dual;

--116632:刘涛,2017-12-08,增加药品结存汇总表
Insert into zlTables(系统,表名,表空间,分类) Values(100,'药品结存汇总','ZL9MEDLST','C2');

--116632:刘涛,2017-12-08,药品结存汇总表历史数据修正
Declare
Begin
  For c_结存记录 In (Select ID, 库房id, 期初日期, 期末日期 From 药品结存记录 Order By ID, 库房id) Loop
    --期间数据
    Insert Into 药品结存汇总
      (结存id, 入出系数, 入出类别id, 库房id, 药品id, 批次, 数量, 金额, 差价)
      Select c_结存记录.Id, c.系数, c.id, a.库房id, a.药品id, Nvl(a.批次, 0), Sum(Nvl(a.实际数量, 0) * Nvl(a.付数, 1)) 实际数量,
             Sum(Nvl(a.零售金额, 0)) 零售金额, Sum(Nvl(a.差价, 0)) As 差价
      From 药品收发记录 A, 药品规格 B, 药品入出类别 C
      Where a.药品id = b.药品id And a.入出类别id = c.Id And a.库房id = c_结存记录.库房id And a.审核日期 Between c_结存记录.期初日期 And c_结存记录.期末日期
      Group By a.库房id, a.药品id, c.id, c.系数, Nvl(a.批次, 0);
  
  End Loop;
  Commit;
End;
/

--000000:蒋敏,2017-12-6,报表中发布时间为空的进行调整并同步处理安装脚本
update zlReports set 发布时间=修改时间 where 发布时间 is null and 系统 is not null;

--000000:蒋敏,2017-12-06，期间表数据添加（标准版）
Insert Into 期间表(期间,开始日期,终止日期) 
Select '201802',to_date('2018-02-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2018-02-28 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '201803',to_date('2018-03-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2018-03-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '201804',to_date('2018-04-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2018-04-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '201805',to_date('2018-05-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2018-05-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '201806',to_date('2018-06-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2018-06-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '201807',to_date('2018-07-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2018-07-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '201808',to_date('2018-08-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2018-08-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '201809',to_date('2018-09-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2018-09-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '201810',to_date('2018-10-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2018-10-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '201811',to_date('2018-11-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2018-11-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '201812',to_date('2018-12-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2018-12-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '201901',to_date('2019-01-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2019-01-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '201902',to_date('2019-02-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2019-02-28 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '201903',to_date('2019-03-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2019-03-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '201904',to_date('2019-04-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2019-04-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '201905',to_date('2019-05-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2019-05-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '201906',to_date('2019-06-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2019-06-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '201907',to_date('2019-07-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2019-07-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '201908',to_date('2019-08-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2019-08-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '201909',to_date('2019-09-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2019-09-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '201910',to_date('2019-10-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2019-10-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '201911',to_date('2019-11-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2019-11-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '201912',to_date('2019-12-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2019-12-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202001',to_date('2020-01-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2020-01-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202002',to_date('2020-02-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2020-02-29 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202003',to_date('2020-03-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2020-03-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202004',to_date('2020-04-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2020-04-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202005',to_date('2020-05-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2020-05-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202006',to_date('2020-06-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2020-06-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202007',to_date('2020-07-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2020-07-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202008',to_date('2020-08-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2020-08-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202009',to_date('2020-09-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2020-09-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202010',to_date('2020-10-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2020-10-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202011',to_date('2020-11-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2020-11-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202012',to_date('2020-12-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2020-12-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202101',to_date('2021-01-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2021-01-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202102',to_date('2021-02-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2021-02-28 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202103',to_date('2021-03-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2021-03-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202104',to_date('2021-04-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2021-04-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202105',to_date('2021-05-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2021-05-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202106',to_date('2021-06-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2021-06-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202107',to_date('2021-07-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2021-07-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202108',to_date('2021-08-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2021-08-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202109',to_date('2021-09-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2021-09-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202110',to_date('2021-10-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2021-10-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202111',to_date('2021-11-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2021-11-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202112',to_date('2021-12-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2021-12-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202201',to_date('2022-01-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2022-01-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202202',to_date('2022-02-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2022-02-28 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202203',to_date('2022-03-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2022-03-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202204',to_date('2022-04-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2022-04-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202205',to_date('2022-05-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2022-05-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202206',to_date('2022-06-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2022-06-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202207',to_date('2022-07-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2022-07-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202208',to_date('2022-08-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2022-08-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202209',to_date('2022-09-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2022-09-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202210',to_date('2022-10-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2022-10-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202211',to_date('2022-11-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2022-11-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202212',to_date('2022-12-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2022-12-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202301',to_date('2023-01-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2023-01-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202302',to_date('2023-02-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2023-02-28 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202303',to_date('2023-03-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2023-03-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202304',to_date('2023-04-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2023-04-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202305',to_date('2023-05-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2023-05-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202306',to_date('2023-06-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2023-06-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202307',to_date('2023-07-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2023-07-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202308',to_date('2023-08-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2023-08-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202309',to_date('2023-09-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2023-09-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202310',to_date('2023-10-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2023-10-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202311',to_date('2023-11-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2023-11-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202312',to_date('2023-12-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2023-12-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202401',to_date('2024-01-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2024-01-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202402',to_date('2024-02-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2024-02-29 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202403',to_date('2024-03-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2024-03-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202404',to_date('2024-04-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2024-04-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202405',to_date('2024-05-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2024-05-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202406',to_date('2024-06-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2024-06-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202407',to_date('2024-07-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2024-07-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202408',to_date('2024-08-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2024-08-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202409',to_date('2024-09-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2024-09-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202410',to_date('2024-10-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2024-10-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202411',to_date('2024-11-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2024-11-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202412',to_date('2024-12-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2024-12-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202501',to_date('2025-01-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2025-01-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202502',to_date('2025-02-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2025-02-28 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202503',to_date('2025-03-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2025-03-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202504',to_date('2025-04-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2025-04-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202505',to_date('2025-05-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2025-05-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202506',to_date('2025-06-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2025-06-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202507',to_date('2025-07-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2025-07-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202508',to_date('2025-08-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2025-08-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202509',to_date('2025-09-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2025-09-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202510',to_date('2025-10-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2025-10-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202511',to_date('2025-11-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2025-11-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202512',to_date('2025-12-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2025-12-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202601',to_date('2026-01-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2026-01-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202602',to_date('2026-02-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2026-02-28 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202603',to_date('2026-03-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2026-03-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202604',to_date('2026-04-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2026-04-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202605',to_date('2026-05-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2026-05-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202606',to_date('2026-06-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2026-06-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202607',to_date('2026-07-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2026-07-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202608',to_date('2026-08-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2026-08-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202609',to_date('2026-09-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2026-09-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202610',to_date('2026-10-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2026-10-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202611',to_date('2026-11-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2026-11-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202612',to_date('2026-12-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2026-12-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202701',to_date('2027-01-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2027-01-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202702',to_date('2027-02-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2027-02-28 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202703',to_date('2027-03-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2027-03-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202704',to_date('2027-04-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2027-04-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202705',to_date('2027-05-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2027-05-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202706',to_date('2027-06-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2027-06-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202707',to_date('2027-07-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2027-07-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202708',to_date('2027-08-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2027-08-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202709',to_date('2027-09-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2027-09-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202710',to_date('2027-10-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2027-10-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202711',to_date('2027-11-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2027-11-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202712',to_date('2027-12-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2027-12-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202801',to_date('2028-01-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2028-01-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202802',to_date('2028-02-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2028-02-29 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202803',to_date('2028-03-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2028-03-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202804',to_date('2028-04-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2028-04-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202805',to_date('2028-05-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2028-05-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202806',to_date('2028-06-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2028-06-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202807',to_date('2028-07-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2028-07-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202808',to_date('2028-08-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2028-08-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202809',to_date('2028-09-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2028-09-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202810',to_date('2028-10-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2028-10-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202811',to_date('2028-11-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2028-11-30 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual Union All
Select '202812',to_date('2028-12-01 00:00:00','yyyy-mm-dd hh24:mi:ss'),to_date('2028-12-31 00:00:00','yyyy-mm-dd hh24:mi:ss') From Dual;

--114920:刘兴洪,2017-12-05,增加条码输入框,主要解决多段条码的问题
Insert Into zlParameters(ID,系统,模块,私有,本机,授权,固定,部门,性质,参数号,参数名,参数值,缺省值,影响控制说明,参数值含义,关联说明,适用说明,警告说明)
Select zlParameters_ID.Nextval,&n_System,1257,A.* From (
Select 私有,本机,授权,固定,部门,性质,参数号,参数名,参数值,缺省值,影响控制说明,参数值含义,关联说明,适用说明,警告说明 From zlParameters Where 1 = 0 Union All 
    Select 1,1,0,0,0,0,18,'上次选择条码控制','0','0','用于控制上次是否选择了显示条码输入框，以便再次进入时默认。','1-上次选择了条码显示,0-上次未选择条码显示',Null,'主要是适用于个性化操作业务',Null From Dual Union All 
Select 私有,本机,授权,固定,部门,性质,参数号,参数名,参数值,缺省值,影响控制说明,参数值含义,关联说明,适用说明,警告说明 From zlParameters Where 1 = 0) A;

Insert Into zlParameters(ID,系统,模块,私有,本机,授权,固定,部门,性质,参数号,参数名,参数值,缺省值,影响控制说明,参数值含义,关联说明,适用说明,警告说明)
Select zlParameters_ID.Nextval,&n_System,1150,A.* From (
Select 私有,本机,授权,固定,部门,性质,参数号,参数名,参数值,缺省值,影响控制说明,参数值含义,关联说明,适用说明,警告说明 From zlParameters Where 1 = 0 Union All 
    Select 1,1,0,0,0,0,43,'上次选择条码控制','0','0','用于控制上次是否选择了显示条码输入框，以便再次进入时默认。','1-上次选择了条码显示,0-上次未选择条码显示',Null,'主要是适用于个性化操作业务',Null From Dual Union All 
Select 私有,本机,授权,固定,部门,性质,参数号,参数名,参数值,缺省值,影响控制说明,参数值含义,关联说明,适用说明,警告说明 From zlParameters Where 1 = 0) A;

--115640:廖思奇,2017-12-05,zlParameters 1290 增加55号参数
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1290, 1, 0, 0, 0, 0, 0, 55, '查看他科历史报告', null,
         '1', '控制是否查看他科历史报告', '0-不查看，1-查看。',  '相关权限:PACS报告他科报告', '影像工作站,Pacs报告编辑器', '无'
  From Dual;

--117756:胡俊勇,2017-12-04,候诊列表显示预约病人
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1260, 1, 1, 0, 0, 0, 0, 38, '显示预约病人', null,
         '1', '控制门诊医生工作站界面候诊列表中预约病人的显示，', '0-不显示，1-显示。',  '门诊医生工作站病人列表显示', '门诊医生工作站主界面候诊列表显示', '当参数设为不显示时，预约病人要收费取挂号费后或者经分诊台处理变为正常挂号病人后才会显示到候诊表中。'
  From Dual;

--115806:刘涛,2017-12-04,修改参数影响控制说明
Update zlParameters
Set 影响控制说明 = '外购（其他）入库时，对于时价药品的售价计算，如果勾选该参数则取该药品上次入库的售价；如果不勾选则按界面成本价*加成率的默认方式计算'
Where 参数名 = '时价药品入库时取上次售价';

--119638:陈福容,2018-01-08，更改段落文本为CLOB，需要增加字段进行处理
Begin
	For r_Data In (Select 页面序号,段落序号,段落文本,插图序号,插表序号 From 咨询段落目录) Loop
		If r_Data.段落文本 Is Not Null And r_Data.插图序号 Is Null And r_Data.插表序号 Is Null Then
			Update 咨询段落目录 Set 段落类型=0 Where 页面序号=r_Data.页面序号 And 段落序号=r_Data.段落序号;
		ElsIf r_Data.段落文本 Is Null And r_Data.插图序号 Is Null And r_Data.插表序号 Is Not Null Then
			Update 咨询段落目录 Set 段落类型=1 Where 页面序号=r_Data.页面序号 And 段落序号=r_Data.段落序号;
		ElsIf r_Data.段落文本 Is Null And r_Data.插图序号 Is Not Null And r_Data.插表序号 Is Null Then
			Update 咨询段落目录 Set 段落类型=2 Where 页面序号=r_Data.页面序号 And 段落序号=r_Data.段落序号;
		ElsIf r_Data.段落文本 Is Null And r_Data.插图序号 Is Null And r_Data.插表序号 Is Null Then
			Update 咨询段落目录 Set 段落类型=3 Where 页面序号=r_Data.页面序号 And 段落序号=r_Data.段落序号;
		ElsIf r_Data.段落文本 Is Not Null And r_Data.插图序号 Is Null And r_Data.插表序号 Is Not Null Then
			Update 咨询段落目录 Set 段落类型=4 Where 页面序号=r_Data.页面序号 And 段落序号=r_Data.段落序号;	
		ElsIf r_Data.段落文本 Is Not Null And r_Data.插图序号 Is Not Null And r_Data.插表序号 Is Null Then
			Update 咨询段落目录 Set 段落类型=5 Where 页面序号=r_Data.页面序号 And 段落序号=r_Data.段落序号;			
		End If;
	End Loop;
End;
/

-------------------------------------------------------------------------------
--权限修正部份
-------------------------------------------------------------------------------
--122273:李业庆,2018-02-26,卫材参数设置增加表访问权限
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1710,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select '未审药品记录','SELECT' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--120885:刘兴洪,2018-02-05,增加显示序号
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 9000, '基本', User, 'Zl_Fun_挂号安排_传统_Nextsn', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 9000, '基本', User, 'Zl_Fun_挂号安排_出诊表_Nextsn', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1111, '基本', User, 'Zl_Fun_挂号安排_传统_Nextsn', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1111, '基本', User, 'Zl_Fun_挂号安排_出诊表_Nextsn', 'EXECUTE'
  From Dual;


--117049:余伟节,2018-02-01,病案查询打印
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,1566,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All 
    Select '全院病人',1,'可以对全院所有病人操作的权限。有该权限时，允许对全院所有病人进行操作',1 From Dual Union All 
    Select '本科病人',2,'可以对本科所有病人操作的权限。有该权限时，允许对本科所有病人进行操作',1 From Dual Union All 
    Select 'ICU病人',3,'可以对ICU室病人操作的权限。有该权限时，允许对ICU室的病人进行操作',1 From Dual Union All
    Select '打印',4,'有该权限时，允许打印文档',1 From Dual Union All 
    Select 'PDF',5,'有该权限时，允许文档PDF格式输出',1 From Dual Union All   
    Select '参数设置',6,'设置本模块相关的全局参数',1 From Dual Union All    
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1566,'基本',user,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select '医嘱报告内容','SELECT' From Dual Union All
    Select '病人挂号记录','SELECT' From Dual Union All
    Select '部门人员','SELECT' From Dual Union All
    Select '在院病人','SELECT' From Dual Union All
    Select '病人社区信息','SELECT' From Dual Union All
    Select '病案主页从表','SELECT' From Dual Union All
    Select '收费项目目录','SELECT' From Dual Union All
    Select '病人变动记录','SELECT' From Dual Union All
    Select '床位状况记录','SELECT' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--120890:刘兴洪,2018-01-29,药品组可用数量封装
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1257, '基本', User, 'Zl_Fun_Getprice', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1150, '基本', User, 'Zl_Fun_Getprice', 'EXECUTE'
  From Dual;

--117106:董露露,2018-01-25,解决标准路径参考模块添加一个导入功能的问题
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select 100,1078,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
  Select 'zl_标准路径目录_insert','EXECUTE' From Dual Union All
  Select 'zl_标准路径目录_delete','EXECUTE' From Dual Union All
  Select 'zl_标准路径目录_update','EXECUTE' From Dual Union All
  Select 'zl_标准路径病种_update','EXECUTE' From Dual Union All
  Select 'zl_标准路径表单_contentclear','EXECUTE' From Dual Union All
  Select 'zl_标准路径表单_contentinsert','EXECUTE' From Dual Union All
  Select 'zl_标准路径表单_delete','EXECUTE' From Dual Union All
  Select 'zl_标准路径表单_update','EXECUTE' From Dual Union All
  Select 'zl_标准路径流程_delete','EXECUTE' From Dual Union All
  Select 'zl_标准路径流程_insert','EXECUTE' From Dual Union All
  Select 'zl_标准路径流程_update','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select 100,1276,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
  Select 'zl_标准路径目录_insert','EXECUTE' From Dual Union All
  Select 'zl_标准路径目录_delete','EXECUTE' From Dual Union All
  Select 'zl_标准路径目录_update','EXECUTE' From Dual Union All
  Select 'zl_标准路径病种_update','EXECUTE' From Dual Union All
  Select 'zl_标准路径表单_contentclear','EXECUTE' From Dual Union All
  Select 'zl_标准路径表单_contentinsert','EXECUTE' From Dual Union All
  Select 'zl_标准路径表单_delete','EXECUTE' From Dual Union All
  Select 'zl_标准路径表单_update','EXECUTE' From Dual Union All
  Select 'zl_标准路径流程_delete','EXECUTE' From Dual Union All
  Select 'zl_标准路径流程_insert','EXECUTE' From Dual Union All
  Select 'zl_标准路径流程_update','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--118584:刘兴洪,2018-01-22,增加免挂号模式
--122106:刘兴洪,2018-02-11,删除多余空格
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select  &n_System,1113,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
	Select 'Zl_门诊分诊取号_Insert','EXECUTE' From Dual Union All 
	Select 'Zl_分诊预约接收_取号','EXECUTE' From Dual Union All 
	Select 'zl_挂号病人病案_INSERT','EXECUTE' From Dual Union All 
	Select 'Zl_病人免疫记录_Delete','EXECUTE' From Dual Union All 
	Select 'Zl_病人免疫记录_Update','EXECUTE' From Dual Union All 
	Select 'ZL_病人信息从表_UPDATE','EXECUTE'  From dual Union all
	Select 'ZL_挂号序号状态_DELETE','EXECUTE'  From dual Union all
	Select 'Zl_Paticardcheck','Execute'  From dual Union all
	Select 'Zl_Regist_AutoIntoblacklist','Execute'  From dual Union all
	Select 'Zl_病人过敏药物_DELETE','EXECUTE'  From dual Union all
	Select 'Zl_病人过敏药物_UPDATE','EXECUTE'  From dual Union all
	Select 'Zl_病人社区信息_Insert','EXECUTE'  From dual Union all
	Select 'Zl_挂号安排_AutoUPDATE','EXECUTE'  From dual Union all
	Select 'zl_病人地址信息_update','EXECUTE'  From dual Union all
	Select 'Zl_Adderss_Structure','EXECUTE'  From dual Union all
	Select 'Zl1_Fun_Getreturnvisit','EXECUTE'  From dual Union all
	Select 'Zl1_Auto_Buildingregisterplan','EXECUTE'  From dual Union all
	Select 'Zl_Fun_Regcustomname','EXECUTE'  From dual Union all
	Select 'Zl_Fun_Customregexpenses','EXECUTE'  From dual Union all
	Select 'Zl_Fun_Getappointmentdays','EXECUTE'  From dual Union all
	Select 'ZL_CUSTOM_GETREGEVENTITEM','EXECUTE'  From dual Union ALL 
	Select 'Zl_Fun_挂号安排_传统_NextSN','EXECUTE'  From dual Union ALL 
	Select '保险病种','SELECT'  From dual Union all
	Select '保险参数','SELECT'  From dual Union all
	Select '保险结算记录','SELECT'  From dual Union all
	Select '保险特准项目','SELECT'  From dual Union all
	Select '保险项目','SELECT'  From dual Union all
	Select '保险帐户','SELECT'  From dual Union all
	Select '保险支付大类','SELECT'  From dual Union all
	Select '保险支付项目','SELECT'  From dual Union all
	Select '保险中心目录','SELECT'  From dual Union all
	Select '病案主页','SELECT'  From dual Union all
	Select '病案主页从表','SELECT'  From dual Union all
	Select '病人免疫记录','SELECT'  From dual Union all
	Select '病人社区信息','SELECT'  From dual Union all
	Select '病人信息从表','SELECT'  From dual Union all
	Select '病人医疗卡变动','SELECT'  From dual Union all
	Select '病人余额','SELECT'  From dual Union all
	Select '病人预交记录','SELECT'  From dual Union all
	Select '病人照片','SELECT'  From dual Union all
	Select '部门表_ID','SELECT'  From dual Union all
	Select '大类档次比例','SELECT'  From dual Union all
	Select '费别明细','SELECT'  From dual Union all
	Select '挂号安排计划','SELECT'  From dual Union all
	Select '挂号安排时段','SELECT'  From dual Union all
	Select '挂号安排停用状态','SELECT'  From dual Union all
	Select '挂号安排限制','SELECT'  From dual Union all
	Select '挂号合作单位','SELECT'  From dual Union all
	Select '挂号计划时段','SELECT'  From dual Union all
	Select '挂号计划限制','SELECT'  From dual Union all
	Select '挂号序号状态','SELECT'  From dual Union all
	Select '号类','SELECT'  From dual Union all
	Select '合作单位安排控制','SELECT'  From dual Union all
	Select '合作单位计划控制','SELECT'  From dual Union all
	Select '区域','SELECT'  From dual Union all
	Select '社区参数','SELECT'  From dual Union all
	Select '社区目录','SELECT'  From dual Union all
	Select '收费从属项目','SELECT'  From dual Union all
	Select '收费价目','SELECT'  From dual Union all
	Select '收费特定项目','SELECT'  From dual Union all
	Select '收费细目','SELECT'  From dual Union all
	Select '收费执行部门','SELECT'  From dual Union all
	Select '收费执行科室','SELECT'  From dual Union all
	Select '收入项目','SELECT'  From dual Union all
	Select '特殊病人','SELECT'  From dual Union all
	Select '血型','SELECT'  From dual Union all
	Select '一卡通目录','SELECT'  From dual Union all
	Select '医保对照类别','SELECT'  From dual Union all
	Select '医保对照明细','SELECT'  From dual Union all
	Select '医学警示','SELECT'  From dual Union all
	Select '预约方式','SELECT'  From dual Union all
	Select '帐户年度信息','SELECT'  From dual Union all
	Select '证件类型','SELECT'  From dual Union all
	Select '凭条打印记录','SELECT'  From dual Union all
	Select '费别适用科室','SELECT'  From dual Union all
	Select '社会关系','SELECT'  From dual Union all
	Select '病人地址信息','SELECT'  From dual Union all
	Select '收费项目类别','SELECT'  From dual Union all
	Select 对象,权限 From zlProgPrivs Where 1 = 0) A;


--118584:刘兴洪,2018-02-11,增加免挂号模式删除多余权限
DELETE  FROM zlprogprivs WHERE 功能='病案修改' AND upper(对象)=upper('病人信息从表')  AND 序号=1113 AND 系统 =&n_System;
DELETE  FROM zlprogprivs WHERE 功能='病案修改' AND upper(对象)=upper('病人地址信息')  AND 序号=1113   AND 系统 =&n_System;
DELETE  FROM zlprogprivs WHERE 功能='病案修改' AND upper(对象)=upper('zl_病人地址信息_update')  AND 序号=1113 AND 系统 =&n_System;
DELETE  FROM zlprogprivs WHERE 功能='病案修改' AND upper(对象)=upper('Zl_Adderss_Structure')  AND 序号=1113   AND 系统 =&n_System;


--119913:涂建华,2018-01-22,pacs Lob读取相关权限设置
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,9004,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select 'Zl_Lob_Append','EXECUTE' From Dual Union All 
    Select 'Zl_Lob_Read','EXECUTE' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--95325:李南春,2016-04-18,自助补充结算
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,1809,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All 
    Select '基本',-Null,NULL,1 From Dual Union All 
    Select '参数设置',2,'设置相关参数设置',1 From Dual Union All 
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1809,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
Select 'NextNO','EXECUTE' From Dual Union All 
Select '病人信息','SELECT' From Dual Union All
Select '人员表','SELECT' From Dual Union All
Select '部门表','SELECT' From Dual Union All
Select '部门性质说明','SELECT' From Dual Union All
Select '部门人员','SELECT' From Dual Union All
Select '上机人员表','SELECT' From Dual Union All
Select '病人余额','SELECT' From Dual Union All
Select '费别','SELECT' From Dual Union All
Select '票据使用类别','SELECT' From Dual Union All
Select '结算方式应用','SELECT' From Dual Union All
Select '结算方式','SELECT' From Dual Union All
Select '卡消费接口目录','SELECT' From Dual Union All
Select '医疗卡类别','SELECT' From Dual Union All
Select '病人医疗卡信息','SELECT' From Dual Union All
Select '医疗付款方式','SELECT' From Dual Union All
Select '收费项目目录','SELECT' From Dual Union All
Select '收费价目','SELECT' From Dual Union All
Select '收入项目','SELECT' From Dual Union All
Select '收费特定项目','SELECT' From Dual Union All
Select '票据领用记录','SELECT' From Dual Union All
Select '收费执行科室','SELECT' From Dual Union All
Select '病人卡结算记录','SELECT' From Dual Union All
Select '消费卡目录','SELECT' From Dual Union All
Select '收费项目类别','SELECT' From Dual Union All
Select '门诊费用记录','SELECT' From Dual Union All
Select '病人预交记录','SELECT' From Dual Union All
Select '三方退款信息','SELECT' From Dual Union All
Select '费用补充记录','SELECT' From Dual Union All
Select '票据使用明细','SELECT' From Dual Union All
Select '药品规格','SELECT' From Dual Union All
Select '保险帐户','SELECT' From Dual Union All
Select '保险结算记录','SELECT' From Dual Union All
Select '保险结算明细','SELECT' From Dual Union All
Select '保险类别','SELECT' From Dual Union All
Select '保险特准项目','SELECT' From Dual Union All
Select '保险支付项目','SELECT' From Dual Union All
Select '保险支付大类','SELECT' From Dual Union All
Select '医保病人档案','SELECT' From Dual Union All
Select '医保病人关联表','SELECT' From Dual Union All
Select '医保对照类别','SELECT' From Dual Union All
Select '医保对照明细','SELECT' From Dual Union All
Select '医保核对表','SELECT' From Dual Union All
Select 'Zl_医疗卡记录_Insert','EXECUTE' From Dual Union All 
Select 'Zl_病人预交记录_Insert','EXECUTE' From Dual Union All
Select 'Zl_三方接口更新_Update','EXECUTE' From Dual Union All
Select 'Zl_三方结算交易_Insert','EXECUTE' From Dual Union All
Select 'Zl_Billclass','EXECUTE' From Dual Union All
Select 'Zl_票据起始号_Update','EXECUTE' From Dual Union All
Select 'Zl_医疗卡变动_Insert','EXECUTE' From Dual Union All
Select 'Zl_费用补充记录_补结算','EXECUTE' From Dual Union All
Select 'Zl_补充结算票据_Insert','EXECUTE' From Dual Union All
Select 'Zl_三方退款信息_Insert','EXECUTE' From Dual Union All
Select 'Zl_病人预交记录_冲预交','EXECUTE' From Dual Union All
Select 'Zl_门诊收费记录_Update','EXECUTE' From Dual Union All
Select 'Zl_费用补充结算_Modify','EXECUTE' From Dual Union All
Select 'Zl_补充结算票据_Reprint','EXECUTE' From Dual Union All
Select 'Zl_医保结算校对_UPDATE','EXECUTE' From Dual Union All
Select 'Zl_医保收费异常_UPDATE','EXECUTE' From Dual Union All
Select 'ZL_帐户年度信息_Insert','EXECUTE' From Dual Union All
Select 'ZL_医保核对表_Insert','EXECUTE' From Dual Union All
Select 'ZL_保险帐户_Insert','EXECUTE' From Dual Union All
Select 'ZL_保险帐户_更新信息','EXECUTE' From Dual Union All
Select 'ZL_保险结算记录_确认','EXECUTE' From Dual Union All
Select 'ZL_保险结算记录_作废','EXECUTE' From Dual Union All
Select 'ZL_保险帐户_修改医保号','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--118582:李南春,2018-01-22,自助免挂号模式
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1802,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select 'Zl_门诊分诊取号_Insert','EXECUTE' From Dual Union All 
    Select 'Zl_分诊预约接收_取号','EXECUTE' From Dual Union All 
    Select '临床性质','SELECT' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1803,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select 'Zl_门诊分诊取号_Insert','EXECUTE' From Dual Union All 
    Select 'Zl_分诊预约接收_取号','EXECUTE' From Dual Union All 
	  Select '临床性质','SELECT' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--118124:李南春,2018-01-19,根据病人信息获取卡费
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1801, '基本', User, 'Zl1_Ex_CardFee', 'EXECUTE'
  From Dual;

--113020:焦博,2018-01-19,如果门诊号为NULL,则调用自动生成门诊号,生成门诊号
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select  &n_System,1107,'基本',User,A.* From (
    Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select 'Zl_病人信息_绑定门诊号','EXECUTE' From Dual Union All 
    Select 对象,权限 From zlProgPrivs Where 1 = 0
    ) A;

--118124:李南春,2018-01-18,根据病人信息获取卡费
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1111, '基本', User, 'Zl1_Ex_CardFee', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1111, '基本', User, 'zl1_EX_ReFundCard_Check', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1101, '发卡事务', User, 'Zl1_Ex_CardFee', 'EXECUTE'
  From Dual; 

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1101, '绑定卡号', User, 'Zl1_Ex_CardFee', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1131, '基本', User, 'Zl1_Ex_CardFee', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1107, '发卡', User, 'Zl1_Ex_CardFee', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1107, '绑定卡', User, 'Zl1_Ex_CardFee', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1107, '退卡', User, 'zl1_EX_ReFundCard_Check', 'EXECUTE'
  From Dual; 

--113615:李南春,2018-01-18,充值时身份检查
Insert Into zlProgPrivs(系统,序号,所有者,功能,对象,权限) values(&n_System,1804,User,'基本','zl1_EX_ReFill_Check','EXECUTE');

--91700:秦龙,2018-01-18,新增权限控制上次供应商列的显示
Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select &n_System, 1725, '查看供应商', 11, '有此权限时在卫材申购管理中新增、修改、审核、查看中都能看到上次供应商列，无此权限时不能看到此列', 1
  From Dual;

--120450:刘兴洪,2018-01-18,免挂号模式,则将发卡的卡费存为划价单

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1107, '发卡', User, 'zl_门诊划价记录_Insert', 'EXECUTE' From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1107, '换卡', User, 'zl_门诊划价记录_Insert', 'EXECUTE' From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1107, '补卡', User, 'zl_门诊划价记录_Insert', 'EXECUTE' From Dual;

--115771:李南春,2018-01-18,Metro风格调整
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,1811,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
Select '基本',-NULL,NULL,1 From Dual Union All
Select '参数设置',2,'设置相关参数设置',2 From Dual Union All
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,1812,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
Select '基本',-NULL,NULL,1 From Dual Union All
Select '参数设置',2,'设置相关参数设置',2 From Dual Union All
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1811,'基本',User,A.* From (
  Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
  Select 'Zl_Incstr','EXECUTE' From Dual Union All 
  Select 'Zl_Incstr_Pre','EXECUTE' From Dual Union All
  Select 'Zl_Billclass','EXECUTE' From Dual Union All
  Select 'zl_Fun_RegCustomName','EXECUTE' From Dual Union All
  Select '病案主页','SELECT' From Dual Union All 
  Select '病人结帐记录','SELECT' From Dual Union All 
  Select '病人信息','SELECT' From Dual Union All 
  Select '临床出诊记录','SELECT' From Dual Union All
  Select '临床出诊号源','SELECT' From Dual Union All
  Select '挂号安排','SELECT' From Dual Union All
  Select '收费项目目录','SELECT' From Dual Union All
  Select '病人挂号记录','SELECT' From Dual Union All
  Select '病人预交记录','SELECT' From Dual Union All 
  Select '病人医嘱记录','SELECT' From Dual Union All
  Select '病人未结费用','SELECT' From Dual Union All
  Select '医疗卡类别','SELECT' From Dual Union All
  Select '消费卡类别目录','SELECT' From Dual Union All
  Select '一卡通目录','SELECT' From Dual Union All
  Select '保险类别','SELECT' From Dual Union All
  Select '部门表','SELECT' From Dual Union All 
  Select '部门人员','SELECT' From Dual Union All 
  Select '财务缴款分组','SELECT' From Dual Union All 
  Select '缴款成员组成','SELECT' From Dual Union All 
  Select '结算方式','SELECT' From Dual Union All
  Select '结算方式应用','SELECT' From Dual Union All
  Select '门诊费用记录','SELECT' From Dual Union All 
  Select '票据使用类别','SELECT' From Dual Union All
  Select '票据领用记录','SELECT' From Dual Union All
  Select '票据打印明细','SELECT' From Dual Union All 
  Select '票据打印内容','SELECT' From Dual Union All 
  Select '票据使用明细','SELECT' From Dual Union All 
  Select '人民币面额','SELECT' From Dual Union All 
  Select '人员表','SELECT' From Dual Union All 
  Select '人员缴款余额','SELECT' From Dual Union All 
  Select '人员借款记录','SELECT' From Dual Union All 
  Select '人员收缴对照','SELECT' From Dual Union All 
  Select '人员收缴记录','SELECT' From Dual Union All 
  Select '人员收缴明细','SELECT' From Dual Union All 
  Select '人员收缴票据','SELECT' From Dual Union All 
  Select '人员性质说明','SELECT' From Dual Union All 
  Select '人员暂存记录','SELECT' From Dual Union All 
  Select '上机人员表','SELECT' From Dual Union All 
  Select '收入项目','SELECT' From Dual Union All 
  Select '病人卡结算记录','SELECT' From Dual Union All 
  Select '消费卡信息','SELECT' From Dual Union All 
  Select '住院费用记录','SELECT' From Dual Union All 
  Select '费用补充记录','SELECT' From Dual Union All
  Select 'Zl_三方接口更新_Update','EXECUTE' From Dual Union All
  Select 'Zl_三方结算交易_Insert','EXECUTE' From Dual Union All
  Select 'Zl_病人预交记录_Insert','EXECUTE' From Dual Union All
  Select 'zl_人员缴款余额_Update','EXECUTE' From Dual Union All
  Select 'Zl_Invoice_Autoallot','EXECUTE' From Dual Union All
  Select 'zl_门诊划价记录_DELETE','EXECUTE' From Dual Union All
  Select 'zl_病人挂号记录_DELETE','EXECUTE' From Dual Union All
  Select '病人结帐记录_ID','SELECT' From Dual Union All
  Select 'NEXTNO','EXECUTE' From Dual Union All
  Select 'ZL_AGE_CALC','EXECUTE' From Dual Union All
  Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1812,'基本',User,A.* From (
  Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
  Select 'Zl_Incstr','EXECUTE' From Dual Union All 
  Select 'Zl_Incstr_Pre','EXECUTE' From Dual Union All 
  Select '病案主页','SELECT' From Dual Union All 
  Select '病人结帐记录','SELECT' From Dual Union All 
  Select '病人信息','SELECT' From Dual Union All 
  Select '病人预交记录','SELECT' From Dual Union All 
  Select '部门表','SELECT' From Dual Union All 
  Select '部门人员','SELECT' From Dual Union All 
  Select '财务缴款分组','SELECT' From Dual Union All 
  Select '缴款成员组成','SELECT' From Dual Union All 
  Select '结算方式','SELECT' From Dual Union All
  Select '结算方式应用','SELECT' From Dual Union All
  Select '医疗卡类别','SELECT' From Dual Union All
  Select '消费卡类别目录','SELECT' From Dual Union All
  Select '保险类别','SELECT' From Dual Union All
  Select '门诊费用记录','SELECT' From Dual Union All 
  Select '票据打印明细','SELECT' From Dual Union All 
  Select '票据打印内容','SELECT' From Dual Union All 
  Select '票据使用明细','SELECT' From Dual Union All 
  Select '人民币面额','SELECT' From Dual Union All 
  Select '人员表','SELECT' From Dual Union All 
  Select '人员缴款余额','SELECT' From Dual Union All 
  Select '人员借款记录','SELECT' From Dual Union All 
  Select '人员收缴对照','SELECT' From Dual Union All 
  Select '人员收缴记录','SELECT' From Dual Union All 
  Select '人员收缴明细','SELECT' From Dual Union All 
  Select '人员收缴票据','SELECT' From Dual Union All 
  Select '人员性质说明','SELECT' From Dual Union All 
  Select '人员暂存记录','SELECT' From Dual Union All 
  Select '上机人员表','SELECT' From Dual Union All 
  Select '收入项目','SELECT' From Dual Union All 
  Select '病人卡结算记录','SELECT' From Dual Union All 
  Select '消费卡信息','SELECT' From Dual Union All 
  Select '住院费用记录','SELECT' From Dual Union All 
  Select '费用补充记录','SELECT' From Dual Union All 
  Select 'Zl_Rollingcurtain_Lastdate','EXECUTE' From Dual Union All 
  Select '财务组组长构成','SELECT' From Dual Union All 
  Select 'Zl_收费员轧帐记录_Insert','EXECUTE' From Dual Union All
  Select 'Zl_收费员轧帐明细_Insert','EXECUTE' From Dual Union All
  Select 'Zl_收费员轧帐票据_Insert','EXECUTE' From Dual Union All
  Select '人员收缴记录_ID','SELECT' From Dual Union All
  Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--110000:曾杰,2018-01-18,变更影像检查记录待处理人
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1290,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select 'Zl_影像检查记录_变更待处理人','EXECUTE' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1291,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select 'Zl_影像检查记录_变更待处理人','EXECUTE' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1294,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select 'Zl_影像检查记录_变更待处理人','EXECUTE' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--119427:蒋廷中,2018-01-17,临床模块授读取照片权限
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1260,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select 'Zl_Lob_Append','EXECUTE' From Dual Union All 
    Select 'Zl_Lob_Read','EXECUTE' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1101,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select 'Zl_Lob_Append','EXECUTE' From Dual Union All 
    Select 'Zl_Lob_Read','EXECUTE' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;


Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1284,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select 'Zl_Lob_Read','EXECUTE' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1566,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select 'Zl_Lob_Read','EXECUTE' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;


--119441:焦博,2018-01-17,对系统中存在的Long、Long Raw类型字段进行统一清理，改成了CLOB、BLOB类型
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select  &n_System,1107,'基本',User,A.* From (
    Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select 'Zl_Lob_Append','EXECUTE' From Dual Union All 
    Select 'Zl_Lob_Read','EXECUTE' From Dual Union All 
    Select 对象,权限 From zlProgPrivs Where 1 = 0
    ) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select  &n_System,1111,'基本',User,A.* From (
    Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select 'Zl_Lob_Append','EXECUTE' From Dual Union All 
    Select 'Zl_Lob_Read','EXECUTE' From Dual Union All 
    Select 对象,权限 From zlProgPrivs Where 1 = 0
    ) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select  &n_System,9000,'基本',User,A.* From (
    Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select 'Zl_Lob_Append','EXECUTE' From Dual Union All 
    Select 'Zl_Lob_Read','EXECUTE' From Dual Union All 
    Select 对象,权限 From zlProgPrivs Where 1 = 0
    ) A;

--113951:蒋廷中,2018-01-17,手术授权管理模块增加权限授权审核
Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select &n_System, 1080, '授权审核', 3, '拥有该权限时，直接授权后就即可生效，也可对待审核的授权进行审核。未拥有该权限时，进行手术授权需要审核',1
  From Dual;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1080,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select '人员手术权限申请','SELECT' From Dual Union All 
    Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--103954:曾杰,2018-01-16,影像工作站增加插件配置的权限
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select  &n_System,1290,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
Select '插件配置管理',40,'配置第三方插件',0 From Dual Union All 
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select  &n_System,1291,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
Select '插件配置管理',37,'配置第三方插件',0 From Dual Union All 
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select  &n_System,1294,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
Select '插件配置管理',60,'配置第三方插件',0 From Dual Union All 
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

--119743:刘兴洪,2018-01-12,根据挂号单生成划价记录
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select  &n_System,9000,'基本',User,A.* 
From (
    Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select 'Zl_门诊划价记录_Buliding','EXECUTE' From Dual Union All 
    Select 对象,权限 From zlProgPrivs Where 1 = 0
    ) A;

--119825:胡俊勇,2018-01-10,护士站权限修正
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select  &n_System,1254,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
	Select '处方审查记录','SELECT' From Dual Union All
	Select '处方审查明细','SELECT' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--119475:刘鹏飞,2018-01-08,输血申请单预览打印前调用检查函数
Insert Into zlProgPrivs(系统,序号,所有者,功能,对象,权限) values(&n_System,1252,User,'基本','Zl1_Fun_BloodApplyPrint','EXECUTE');

Insert Into zlProgPrivs(系统,序号,所有者,功能,对象,权限) values(&n_System,1253,User,'基本','Zl1_Fun_BloodApplyPrint','EXECUTE');

--119638:陈福容,2018-01-08，更改图形为BLOB
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限) Select &n_System,1536,'信息维护',User, 'zl_咨询图片元素_Insert','EXECUTE' From Dual;

--118982:李业庆,2018-01-08,药品参数设置增加表访问权限
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1022,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select '未审药品记录','SELECT' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--118189:胡俊勇,2018-01-04,允许置换药房权限
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,1254,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All  
    Select '允许置换药房',34,'临床护士有此权限时在发送医嘱可以置换药房，否则不能置换。',1 From Dual Union All 
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

--119290:廖思奇,2018-01-03,Pacs排队叫号增加预呼功能。增加预呼权限
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select  &n_System,1160,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
Select '预呼',20,'对排队中的患者进行预先呼叫，提示患者即将正式呼叫',1 From Dual Union All 
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

--118942:冉俊明,2017-12-28,权限对象名称修正
Update zlProgPrivs Set 对象 = '消费卡类别目录' Where 系统 = &n_System And 对象 = '卡消费接口目录';

Update zlProgPrivs Set 对象 = '消费卡信息' Where 系统 = &n_System And 对象 = '消费卡目录';

Delete From zlProgPrivs Where 系统 = &n_System And 对象 = '病人卡结算对照';

--118197:董露露,2017-12-25，过敏源结构化录入
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1261,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select '过敏源','SELECT' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1260,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select '过敏源','SELECT' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--118802:刘涛,2017-12-21,药品卫材验收结论处理
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1300, '基本', User, '入库验收结论', 'SELECT'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1348, '基本', User, '入库验收结论', 'SELECT'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1712, '基本', User, '入库验收结论', 'SELECT'
  From Dual;

--116073:黄捷,2017-12-15,RIS接口支持多HIS库
Insert Into zlProgPrivs
  (系统, 序号, 所有者, 功能, 对象, 权限)
Values
  (&n_System, 1011, User, '基本', 'RIS分院设置', 'SELECT');

Insert Into zlProgPrivs
  (系统, 序号, 所有者, 功能, 对象, 权限)
Values
  (&n_System, 1287, User, '基本', 'RIS分院设置', 'SELECT');

Insert Into zlProgPrivs
  (系统, 序号, 所有者, 功能, 对象, 权限)
Values
  (&n_System, 1252, User, '基本', 'RIS分院设置', 'SELECT');

Insert Into zlProgPrivs
  (系统, 序号, 所有者, 功能, 对象, 权限)
Values
  (&n_System, 1253, User, '基本', 'RIS分院设置', 'SELECT');

Insert Into zlProgPrivs
  (系统, 序号, 所有者, 功能, 对象, 权限)
Values
  (&n_System, 1254, User, '基本', 'RIS分院设置', 'SELECT');

--116846:刘鹏飞,2017-12-14,输血申请保存自定义函数检查
Insert Into zlProgPrivs(系统,序号,所有者,功能,对象,权限) values(&n_System,1252,User,'医嘱下达','Zl1_EX_BloodApplyCheck','EXECUTE');

Insert Into zlProgPrivs(系统,序号,所有者,功能,对象,权限) values(&n_System,1253,User,'医嘱下达','Zl1_EX_BloodApplyCheck','EXECUTE');

--116632:刘涛,2017-12-08,增加药品结存汇总表
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1332, '基本', User, '药品结存汇总', 'SELECT'
  From Dual;

--113611:李南春,2018-01-18,自助禁用支付方式
Insert Into zlProgPrivs(系统,序号,所有者,功能,对象,权限) values(&n_System,1801,User,'基本','zl1_EX_ForbidPlayTypes','EXECUTE');

Insert Into zlProgPrivs(系统,序号,所有者,功能,对象,权限) values(&n_System,1802,User,'基本','zl1_EX_ForbidPlayTypes','EXECUTE');

Insert Into zlProgPrivs(系统,序号,所有者,功能,对象,权限) values(&n_System,1803,User,'基本','zl1_EX_ForbidPlayTypes','EXECUTE');

Insert Into zlProgPrivs(系统,序号,所有者,功能,对象,权限) values(&n_System,1804,User,'基本','zl1_EX_ForbidPlayTypes','EXECUTE');

Insert Into zlProgPrivs(系统,序号,所有者,功能,对象,权限) values(&n_System,1805,User,'基本','zl1_EX_ForbidPlayTypes','EXECUTE');

Insert Into zlProgPrivs(系统,序号,所有者,功能,对象,权限) values(&n_System,1809,User,'基本','zl1_EX_ForbidPlayTypes','EXECUTE');

Insert Into zlProgPrivs(系统,序号,所有者,功能,对象,权限) values(&n_System,1811,User,'基本','zl1_EX_ForbidPlayTypes','EXECUTE');

--117676:胡俊勇,2017-12-05,外来病人危急值处理
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select  &n_System,9001,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
	Select 'Zl_病人危急值记录_处理','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;


--120541:蒋敏,2017-12-6,公共表的多余权限删除,删除普通功能模块中的权限在'基本'功能中存在的多余权限
Delete Zlprogprivs Where 对象 in('部门表','人员表','人员上机表','部门人员','人员性质说明','人员性质分类') and 权限='SELECT';

Delete zlProgPrivs B
Where b.功能 <> '基本' And Exists
 (Select 1
       From zlProgPrivs A
       Where a.功能 = '基本' And a.系统 = b.系统 And a.序号 = b.序号 And a.对象 = b.对象 And a.所有者 = b.所有者 And a.权限 = b.权限);

--91700:秦龙,2018-01-18,新增权限控制上次供应商列的显示
Insert Into zlRoleGrant
  (系统, 序号, 角色, 功能)
  Select Distinct 系统, 序号, 角色, '查看供应商' 功能 From zlRoleGrant Where 系统 = &n_System And 序号 = 1725;

-------------------------------------------------------------------------------
--报表修正部份
-------------------------------------------------------------------------------
--95325:李南春,2016-04-26,自助补充结算
--报表：ZL1_BILL_1809/自助补结算凭条
Insert Into zlReports(ID,编号,名称,说明,密码,打印机,进纸,票据,打印方式,系统,程序ID,功能,修改时间,发布时间,禁止开始时间,禁止结束时间,执行开始时间,执行结束时间) Values(zlReports_ID.NextVal,'ZL1_BILL_1809','自助补结算凭条','自助补结算凭条','T~:fAkwhg*.Kwqg}_"E^','Star AR-3200+',15,1,0,100,1809,'自助补结算凭条',Sysdate,Sysdate,To_Date('2016-04-01 00:00:00','YYYY-MM-DD HH24:MI:SS'),To_Date('2016-04-01 00:00:00','YYYY-MM-DD HH24:MI:SS'),Null,Null);
Insert Into zlRPTPuts(报表ID,系统,程序ID,功能) Values(zlReports_ID.CurrVal,100,1809,'自助补结算凭条');
Insert Into zlRPTFmts(报表ID,序号,说明,W,H,纸张,纸向,动态纸张,图样) Values(zlReports_ID.CurrVal,1,'自助补结算凭条',10319,8875,256,1,0,0);
Insert Into zlRPTDatas(ID,报表ID,名称,字段,对象,类型,说明) Values(zlRPTDatas_ID.NextVal,zlReports_ID.CurrVal,'病人信息','姓名,202|性别,202|年龄,202|门诊号,131|费别,202|收费人,202|登记时间,202',User||'.费用补充记录,'||User||'.病人信息',1,Null);
Insert Into zlRPTSQLs(源ID,行号,内容)  Select zlRPTDatas_ID.CurrVal,a.* From (
  Select 1,'--固为部分退费后可能要打印,所以不管记录状态' From Dual Union All
  Select 2,'--支持多单据收费方式(参数传入了多个NO)' From Dual Union All
  Select 3,'Select  B.姓名,B.性别,B.年龄,B.门诊号,B.费别,A.操作员姓名 as 收费人, ' From Dual Union All
  Select 4,'  To_Char(A.登记时间,''YYYY-MM-DD HH24:MI:SS'') as 登记时间' From Dual Union All
  Select 5,'From 费用补充记录 A ,病人信息 B' From Dual Union All
  Select 6,'Where A.病人ID=B.病人ID And A.记录性质=1 And A.NO IN([0]) and A.费用状态 = 0 And rownum<=1' From Dual Union All
  Select 7,Null From Dual) a;
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,0,'费用单据',3,'''Q0000001''',0,Null,Null,Null,Null,Null,Null,0);
Insert Into zlRPTDatas(ID,报表ID,名称,字段,对象,类型,说明) Values(zlRPTDatas_ID.NextVal,zlReports_ID.CurrVal,'返回金额','返还金额,139',User||'.费用补充记录,'||User||'.病人预交记录',0,Null);
Insert Into zlRPTSQLs(源ID,行号,内容)  Select zlRPTDatas_ID.CurrVal,a.* From (
  Select 1,'Select   sum(-1 * A.冲预交) as 返还金额' From Dual Union All
  Select 2,'from  病人预交记录 A' From Dual Union All
  Select 3,'where A.记录性质=6 and A.记录状态=1 And A.结算序号 In (Select 结算序号 From 费用补充记录 Where No IN([0]))' From Dual Union All
  Select 4,'And A.冲预交<0' From Dual) a;
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,0,'费用单据',3,'''Q0000001''',0,Null,Null,Null,Null,Null,Null,0);
Insert Into zlRPTDatas(ID,报表ID,名称,字段,对象,类型,说明) Values(zlRPTDatas_ID.NextVal,zlReports_ID.CurrVal,'明细','NO,202|类别,202|编码,202|项目,202|规格,202|单位,202|数量,139|单价,202|应收,202|实收,202|执行部门,202|类型,202',User||'.门诊费用记录,'||User||'.收费项目类别,'||User||'.收费项目目录,'||User||'.费用补充记录,'||User||'.部门表,'||User||'.药品规格',0,Null);
Insert Into zlRPTSQLs(源ID,行号,内容)  Select zlRPTDatas_ID.CurrVal,a.* From (
  Select 1,'--固为部分退费后可能要打印,所以不管记录状态' From Dual Union All
  Select 2,'--支持多单据收费方式(参数传入了多个NO)，这里加入NO把明细分开，但是一次性打印' From Dual Union All
  Select 3,' Select A.NO,' From Dual Union All
  Select 4,'       A.类别,' From Dual Union All
  Select 5,'       A.编码,' From Dual Union All
  Select 6,'       A.名称 as 项目,' From Dual Union All
  Select 7,'       A.规格,' From Dual Union All
  Select 8,'       LTrim(Decode(X.药品ID,NULL,A.计算单位,Decode([1],0,A.计算单位,Decode(A.门诊标志, 2, X.住院单位, X.门诊单位)))) as 单位,' From Dual Union All
  Select 9,'       Avg(Nvl(A.付数, 1) * A.数次 /Decode(X.药品ID,NULL,1,Decode([1],0,1,Decode(A.门诊标志,2,Nvl(X.住院包装, 1),Nvl(X.门诊包装, 1))))) as 数量,' From Dual Union All
  Select 10,'       RTrim(Ltrim(To_Char(Sum(A.标准单价 *Decode(X.药品ID,NULL,1,decode([1],0,1,Decode(A.门诊标志,2,Nvl(X.住院包装, 1),Nvl(X.门诊包装, 1))))),''9999999990.0000''))) as 单价,' From Dual Union All
  Select 11,'       RTrim(Ltrim(To_Char(Sum(A.应收金额), ''9999999990.00''))) as 应收,' From Dual Union All
  Select 12,'       RTrim(Ltrim(To_Char(Sum(A.实收金额), ''9999999990.00''))) as 实收,' From Dual Union All
  Select 13,'       D.名称 as 执行部门,' From Dual Union All
  Select 14,'       A.费用类型 as 类型' From Dual Union All
  Select 15,'  From (SELECT A.NO,A.计算单位,A.门诊标志,A.付数,A.数次,A.标准单价,A.应收金额,A.实收金额,A.执行部门ID,A.收费细目ID,A.价格父号,A.序号,A.收费类别,' From Dual Union All
  Select 16,'    B.名称 AS 类别,C.编码,C.名称,C.规格,C.费用类型 ' From Dual Union All
  Select 17,'               FROM 门诊费用记录 A,收费项目类别 B,收费项目目录 C, 费用补充记录 D' From Dual Union All
  Select 18,'               WHERE A.收费类别=B.编码 ' From Dual Union All
  Select 19,'                     AND C.ID=A.收费细目ID' From Dual Union All
  Select 20,'                     AND (A.记录性质 = 1 or A.记录性质 = 4) and A.记录状态<>0 And Nvl(A.执行状态,0)<>9' From Dual Union All
  Select 21,'					 And A.结帐ID = D.收费结帐ID And D.记录性质 = 1 And D.记录状态 = 1' From Dual Union All
  Select 22,'                     AND D.NO IN ([0])) A, ' From Dual Union All
  Select 23,'       部门表 D,        ' From Dual Union All
  Select 24,'       药品规格 X' From Dual Union All
  Select 25,' Where A.执行部门ID = D.ID(+) ' From Dual Union All
  Select 26,'       And A.收费细目ID = X.药品ID(+) ' From Dual Union All
  Select 27,' Having Sum(A.应收金额) <> 0' From Dual Union All
  Select 28,' Group by A.NO,' From Dual Union All
  Select 29,'          Nvl(A.价格父号, A.序号),' From Dual Union All
  Select 30,'          A.类别,' From Dual Union All
  Select 31,'          A.编码,' From Dual Union All
  Select 32,'          A.名称,' From Dual Union All
  Select 33,'          A.规格,' From Dual Union All
  Select 34,'          A.计算单位,' From Dual Union All
  Select 35,'          A.收费类别,' From Dual Union All
  Select 36,'          D.名称,' From Dual Union All
  Select 37,'          A.费用类型,' From Dual Union All
  Select 38,'          X.药品ID,' From Dual Union All
  Select 39,'          A.门诊标志,' From Dual Union All
  Select 40,'          X.门诊单位,' From Dual Union All
  Select 41,'          X.住院单位' From Dual Union All
  Select 42,' Order by A.NO, Nvl(A.价格父号, A.序号)' From Dual) a;
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,0,'费用单据',3,'''Q0000001''',0,Null,Null,Null,Null,Null,Null,0);
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,1,'药品单位',1,'固定值列表…',1,'√售价单位,0|药房单位,1',Null,Null,Null,Null,Null,0);
Insert Into zlRPTDatas(ID,报表ID,名称,字段,对象,类型,说明) Values(zlRPTDatas_ID.NextVal,zlReports_ID.CurrVal,'医保结算','结算方式,202|冲预交,139',User||'.费用补充记录,'||User||'.病人预交记录',0,Null);
Insert Into zlRPTSQLs(源ID,行号,内容)  Select zlRPTDatas_ID.CurrVal,a.* From (
  Select 1,'Select   B.结算方式,Sum(B.冲预交) as 冲预交' From Dual Union All
  Select 2,'From 病人预交记录 B' From Dual Union All
  Select 3,'where B.记录性质=6 and B.记录状态=1 And B.结算序号 In (Select 结算序号 From 费用补充记录 Where No IN([0]))' From Dual Union All
  Select 4,'And B.冲预交 > 0' From Dual Union All
  Select 5,'Group by  B.结算方式' From Dual Union All
  Select 6,' ' From Dual) a;
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,0,'费用单据',3,'''Q0000001''',0,Null,Null,Null,Null,Null,Null,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号,表格线加粗) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'任意表1',4,Null,0,Null,0,'结算信息_数据',Null,90,1410,3365,1110,255,0,0,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,16777215,Null,Null,Null,0,0,0,0,0,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号,表格线加粗) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-1,0,Null,Null,'[医保结算.结算方式]','4^30^#',0,0,1650,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号,表格线加粗) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-2,1,Null,Null,'[医保结算.冲预交]','4^30^#',0,0,1650,0,0,2,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号,表格线加粗) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签4',2,Null,0,'表格',11,'姓名:[病人信息.姓名]  性别:[病人信息.性别]  年龄:[病人信息.年龄]  费别:[病人信息.费别]',Null,88,825,7740,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号,表格线加粗) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签6',2,Null,0,'表格',11,'本次费用明细',Null,88,2640,1080,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号,表格线加粗) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签5',2,Null,0,Null,0,'本次返还金额:[返回金额.返还金额]',Null,90,1155,2880,180,0,2,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号,表格线加粗) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标题',2,Null,0,'表格',12,'[单位名称]自助补结算凭条',Null,3243,225,3600,300,0,1,1,'黑体',15,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号,表格线加粗) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签7',2,Null,0,'表格',23,'打印时间:[yyyy-mm-dd HH:MM:SS]',Null,7298,8365,2700,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号,表格线加粗) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'表格',4,Null,0,Null,0,'明细',Null,88,2940,9910,5325,255,0,0,'宋体',9,0,0,0,0,16777215,1,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号,表格线加粗) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-1,0,Null,Null,'[明细.类别]','4^195^类别',0,0,630,0,255,1,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号,表格线加粗) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-2,1,Null,Null,'[明细.项目]','4^195^项目',0,0,1800,0,255,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号,表格线加粗) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-3,2,Null,Null,'[明细.规格]','4^195^规格',0,0,1845,0,255,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号,表格线加粗) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-4,3,Null,Null,'[明细.单位]','4^195^单位',0,0,525,0,255,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号,表格线加粗) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-5,4,Null,Null,'[明细.数量]','4^195^数量',0,0,705,0,255,2,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号,表格线加粗) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-6,5,Null,Null,'[明细.单价]','4^195^单价',0,0,930,0,255,2,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号,表格线加粗) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-7,6,Null,Null,'[明细.应收]','4^195^应收',0,0,915,0,255,2,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号,表格线加粗) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-8,7,Null,Null,'[明细.实收]','4^195^实收',0,0,855,0,255,2,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号,表格线加粗) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-9,8,Null,Null,'[明细.执行部门]','4^195^执行部门',0,0,810,0,255,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号,表格线加粗) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-10,9,Null,Null,'[明细.类型]','4^195^类型',0,0,825,0,255,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null,Null);

--报表：ZL1_BILL_1809/自助补结算凭条
Insert into zlProgFuncs(系统,序号,功能,说明) Values(100,1809,'自助补结算凭条','自助补结算凭条');
Insert into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
  Select 100,1809,'自助补结算凭条',User,'病人信息','SELECT' From Dual Union All
  Select 100,1809,'自助补结算凭条',User,'病人预交记录','SELECT' From Dual Union All
  Select 100,1809,'自助补结算凭条',User,'部门表','SELECT' From Dual Union All
  Select 100,1809,'自助补结算凭条',User,'费用补充记录','SELECT' From Dual Union All
  Select 100,1809,'自助补结算凭条',User,'门诊费用记录','SELECT' From Dual Union All
  Select 100,1809,'自助补结算凭条',User,'收费项目类别','SELECT' From Dual Union All
  Select 100,1809,'自助补结算凭条',User,'收费项目目录','SELECT' From Dual Union All
  Select 100,1809,'自助补结算凭条',User,'药品规格','SELECT' From Dual;




-------------------------------------------------------------------------------
--过程修正部份
-------------------------------------------------------------------------------
--122480:冉俊明,2018-03-02,增加Oracle接口函数
Create Or Replace Procedure Zl_Third_Getexesoverview
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取住院病人费用概况
  --入参:Xml_In
  -- <IN>
  --  <PATIID></PATIID>         --病人ID
  --  <PAGEID></PAGEID>     --主页ID
  --</IN>
  --出参:Xml_Out
  --<OUTPUT>
  --  <FY>
  --    <YJZE></YJZE> --预交总额
  --    <YJYE></YJYE> --预交余额
  --    <ZJE></ZJE>  --总金额
  --    <WJJE></WJJE> --未结金额
  --    <YJJE></YJJE> --预结金额
  --    <FYYE></FYYE> --费用余额
  --  <FY>
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  n_病人id 病人信息.病人id%Type;
  n_主页id 病案主页.主页id%Type;

  n_预交总额 病人预交记录.金额%Type;
  n_预交余额 病人余额.预交余额%Type;
  n_费用余额 病人余额.费用余额%Type;

  n_总金额   住院费用记录.实收金额%Type;
  n_未结金额 住院费用记录.实收金额%Type;
  n_预结金额 住院费用记录.实收金额%Type;

  x_Templet Xmltype; --模板XML
Begin
  --获取入参
  Select Extractvalue(Value(A), 'IN/PATIID'),
         Decode(Extractvalue(Value(A), 'IN/PAGEID'), 0, Null, Extractvalue(Value(A), 'IN/PAGEID'))
  Into n_病人id, n_主页id
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  Select Nvl(Sum(金额), 0) Into n_预交总额 From 病人预交记录 Where 记录性质 = 1 And 预交类别 = 2 And 病人id = n_病人id;

  Select Nvl(预交余额, 0) Into n_预交余额 From 病人余额 Where 性质 = 1 And 类型 = 2 And 病人id = n_病人id;

  Select Nvl(Sum(金额), 0) Into n_预结金额 From 保险模拟结算 A Where a.病人id = n_病人id And a.主页id = n_主页id;

  Select Nvl(Sum(a.实收金额), 0), Nvl(Sum(a.实收金额), 0) - Nvl(Sum(a.结帐金额), 0)
  Into n_总金额, n_未结金额
  From 住院费用记录 A
  Where a.病人id = n_病人id And a.主页id = n_主页id And Nvl(a.门诊标志, 0) = 2;

  n_费用余额 := n_预交余额 - n_未结金额 + n_预结金额;

  Select Xmlelement("OUTPUT",
                     Xmlelement("FY",
                                 Xmlforest(n_预交总额 As "YJZE", n_预交余额 As "YJYE", n_总金额 As "ZJE", n_未结金额 As "WJJE",
                                            n_预结金额 As "YJJE", n_费用余额 As "FYYE")))
  Into x_Templet
  From Dual;
  Xml_Out := x_Templet;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getexesoverview;
/

--122480:冉俊明,2018-03-02,增加Oracle接口函数
Create Or Replace Procedure Zl_Third_Getexessort
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取住院病人费用分类汇总
  --入参:Xml_In
  -- <IN>
  --  <PATIID></PATIID>         --病人ID
  --  <PAGEID></PAGEID>     --主页ID
  --</IN>
  --出参:Xml_Out
  --<OUTPUT>
  --  <ZFY></ZFY>    --总费用
  --  <FYLIST>
  --    <ITEM>
  --      <XM></XM> --收据费目
  --      <JE></JE> --金额
  --    </ITEM>
  --  <FYLIST>
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  n_病人id 病人信息.病人id%Type;
  n_主页id 病案主页.主页id%Type;
  n_总费用 住院费用记录.实收金额%Type;

  x_Templet Xmltype; --模板XML
Begin
  --获取入参
  Select Extractvalue(Value(A), 'IN/PATIID'),
         Decode(Extractvalue(Value(A), 'IN/PAGEID'), 0, Null, Extractvalue(Value(A), 'IN/PAGEID'))
  Into n_病人id, n_主页id
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  Select Nvl(Sum(a.实收金额), 0)
  Into n_总费用
  From 住院费用记录 A
  Where a.病人id = n_病人id And a.主页id = n_主页id And Nvl(a.门诊标志, 0) = 2;

  Select Xmlelement("OUTPUT",
                     Xmlforest(n_总费用 As "ZFY",
                                Xmlagg(Xmlelement("ITEM", Xmlforest(a.收据费目 As "XM", Nvl(Sum(a.实收金额), 0) As "JE"))) As
                                 "FYLIST"))
  Into x_Templet
  From 住院费用记录 A
  Where a.病人id = n_病人id And a.主页id = n_主页id And Nvl(a.门诊标志, 0) = 2
  Group By a.收据费目;
  Xml_Out := x_Templet;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getexessort;
/

--122468:殷瑞,2018-03-02,修正sql条件中参数ID写死的情况
Create Or Replace Procedure Zl_发药窗口_业务调整
(
  药房id_In In Number,
  旧窗口_In In Varchar2,
  新窗口_In In Varchar2
) Is

  Cursor c_未发数据 Is
    Select 单据, NO, 库房id
    From 未发药品记录
    Where 填制日期 Between Sysdate - 3 And Sysdate And 发药窗口 = 旧窗口_In And 库房id = 药房id_In;

  --药房参数 
  Cursor c_药房参数 Is
    Select a.参数值
    From (Select 机器名, 参数值
           From zlUserParas
           Where 参数id In (Select ID From zlParameters Where 系统 = 100 And 模块 = 1341 And 参数名 = '发药窗口')) A,
         (Select 机器名, 参数值
           From zlUserParas
           Where 参数id In (Select ID From zlParameters Where 系统 = 100 And 模块 = 1341 And 参数名 = '发药药房')) B
    Where a.机器名 = b.机器名 And b.参数值 = 药房id_In;

  v_未发数据 c_未发数据%RowType;
  v_药房参数 c_药房参数%RowType;
Begin
  --费用参数 
  Update zlUserParas
  Set 参数值 = 药房id_In || ':' || 新窗口_In
  Where 参数值 = 药房id_In || ':' || 旧窗口_In And
        参数id In (Select ID From zlParameters Where 参数名 In ('西药房窗口', '中药房窗口', '成药房窗口'));

  --业务数据 
  For v_未发数据 In c_未发数据 Loop
    Update 药品收发记录
    Set 发药窗口 = 新窗口_In
    Where 单据 = v_未发数据.单据 And NO = v_未发数据.No And 库房id = v_未发数据.库房id And 发药窗口 = 旧窗口_In;
    Update 门诊费用记录
    Set 发药窗口 = 新窗口_In
    Where NO = v_未发数据.No And 执行部门id = v_未发数据.库房id And 发药窗口 = 旧窗口_In;
    Update 住院费用记录
    Set 发药窗口 = 新窗口_In
    Where NO = v_未发数据.No And 执行部门id = v_未发数据.库房id And 发药窗口 = 旧窗口_In;
  End Loop;

  Update 未发药品记录
  Set 发药窗口 = 新窗口_In
  Where 填制日期 Between Sysdate - 3 And Sysdate And 发药窗口 = 旧窗口_In And 库房id = 药房id_In;

  --药品参数 
  Update zlUserParas
  Set 参数值 = Replace(参数值, 旧窗口_In, 新窗口_In)
  Where 参数id In (Select ID From zlParameters Where 系统 = 100 And 模块 = 1341 And 参数名 = '发药窗口') And
        机器名 In (Select 机器名
                From zlUserParas
                Where 参数值 = 药房id_In And
                      参数id In (Select ID From zlParameters Where 系统 = 100 And 模块 = 1341 And 参数名 = '发药药房'));

  --叫号窗口 
  Update 发药窗口 Set 叫号窗口 = 新窗口_In Where 药房id = 药房id_In And 叫号窗口 = 旧窗口_In;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_发药窗口_业务调整;
/

--121873:冉俊明,2018-02-26,门诊退费时，原使用预交款进行结算的，冲销成了挂号的结算数据
Create Or Replace Procedure Zl_门诊退费结算_Modify
(
  操作类型_In      Number,
  病人id_In        门诊费用记录.病人id%Type,
  冲销id_In        病人预交记录.结帐id%Type,
  结算方式_In      Varchar2,
  冲预交_In        病人预交记录.冲预交%Type := Null,
  卡类别id_In      病人预交记录.卡类别id%Type := Null,
  卡号_In          病人预交记录.卡号%Type := Null,
  交易流水号_In    病人预交记录.交易流水号%Type := Null,
  交易说明_In      病人预交记录.交易说明%Type := Null,
  缴款_In          病人预交记录.缴款%Type := Null,
  找补_In          病人预交记录.找补%Type := Null,
  误差金额_In      门诊费用记录.实收金额%Type := Null,
  完成退费_In      Number := 0,
  原结帐id_In      病人预交记录.结帐id%Type := Null,
  剩余转预交_In    Number := 0,
  缺省结算方式_In  结算方式.名称%Type := Null,
  冲预交病人ids_In Varchar2 := Null
) As
  ------------------------------------------------------------------------------------------------------------------------------
  --功能:收费结算时,修改结算的相关信息
  --操作类型_In:
  --   0-原样退
  --      原样结算一起全退,所有校对标志都为1,医保调用成功后,调整为2,完成后变成0
  --   1-普通退费方式:
  --     ①结算方式_IN:允许传入多个,格式为:"结算方式|结算金额|结算号码|结算摘要||.." ;也允许传入空.
  --   2.三方卡退费结算:
  --     ①结算方式_IN:只能传入一个结算方式,但允许包含一些辅助信息,格式为:"结算方式|结算金额|结算号码|结算摘要"
  --     ②卡类别ID_IN,卡号_IN,交易流水号_IN,交易说明_In:需要传入
  --   3-医保结算(如果存在医保的结算,则要先删除原医保结算,后按新传入的更新)
  --     ①结算方式_IN:允许传入多个,格式为:结算方式|结算金额||.."
  --     ②退支票额_In:传入零
  --   4-消费卡结算:
  --     ①结算方式_IN:允许一次刷多张卡,格式为:卡类别ID|卡号|消费卡ID|消费金额||."
  --     ②退支票额_In:传入零

  -- 冲预交_In:如果涉及预交款,则传入本次的退预交 传入零<0时 表示退预交款或充值;>0 时:表示冲预交款
  -- 剩余转预交_In: 1表示将剩余退款额转换为充值金额;0表示退预交
  -- 误差金额_In:存在误差费时,传入
  -- 完成退费_In:0-未完成退费;1-异常完成退费;2-完成退费
  -- 原结帐ID_IN:原样退时,传入(如果原样退未传入时,则以最后一次结帐为准)
  -- 冲预交病人ids_In:多个用逗分分离,冲预交时有效(冲预交类别与业务操作保持一致),主要是使用家属的预交款
  ------------------------------------------------------------------------------------------------------------------------------
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_结算内容 Varchar2(500);
  v_当前结算 Varchar2(50);
  v_卡号     病人医疗卡信息.卡号%Type;
  n_消费卡id 消费卡信息.Id%Type;
  v_名称     消费卡类别目录.名称%Type;
  n_卡类别id 病人预交记录.结算卡序号%Type;
  n_原预交id 病人预交记录.Id%Type;
  n_预交id   病人预交记录.Id%Type;
  v_结算方式 病人预交记录.结算方式%Type;
  n_结算金额 病人预交记录.冲预交%Type;
  n_返回值   人员缴款余额.余额%Type;
  n_预交金额 病人预交记录.冲预交%Type;
  n_冲预交   病人预交记录.冲预交%Type;
  v_结算号码 病人预交记录.结算号码%Type;
  v_结算摘要 病人预交记录.摘要%Type;
  v_误差费   结算方式.名称%Type;
  n_记录状态 病人预交记录.记录状态%Type;

  v_退费结算 结算方式.名称%Type;
  v_No       病人预交记录.No%Type;
  n_Dec      Number; --金额小数位数

  n_Count         Number;
  n_Havenull      Number;
  l_预交id        t_Numlist := t_Numlist();
  n_原结帐id      病人预交记录.结帐id%Type;
  n_重结id        病人预交记录.结帐id%Type;
  n_结帐id        病人预交记录.结帐id%Type;
  n_结算序号      病人预交记录.结帐id%Type;
  v_冲预交病人ids Varchar2(4000);
  v_Msg           Varchar2(500);
  n_会话号        病人预交记录.会话号%Type; --格式：SID+'_'+SERIAL#

  Cursor c_Feedata Is
    Select Max(NO) As NO, Max(m.病人id) As 病人id, Max(m.登记时间) As 登记时间, Max(m.操作员编号) As 操作员编号, Max(m.操作员姓名) As 操作员姓名,
           Sum(结帐金额) As 结算金额, Max(m.缴款组id) As 缴款组id
    From 门诊费用记录 M
    Where m.结帐id = 冲销id_In;
  r_Feedata c_Feedata%RowType;

  Cursor c_Balancedata Is
    Select 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号
    From 病人预交记录
    Where 结帐id = 冲销id_In And 结算方式 Is Null;
  r_Balancedata c_Balancedata%RowType;

Begin
  v_冲预交病人ids := Nvl(冲预交病人ids_In, 病人id_In);
  Begin
    Select Sid || '_' || Serial# Into n_会话号 From V$session Where Audsid = Userenv('sessionid');
  Exception
    When Others Then
      n_会话号 := Null;
  End;

  Begin
    Select 名称 Into v_退费结算 From 结算方式 Where 性质 = 1;
  Exception
    When Others Then
      v_退费结算 := '现金';
  End;

  Open c_Feedata;
  Fetch c_Feedata
    Into r_Feedata;

  If r_Feedata.No Is Null Then
    v_Err_Msg := '未找到指定的退费记录！';
    Raise Err_Item;
  End If;

  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into n_Dec From Dual;

  --0.正式结算
  Select Count(1), Max(Decode(结算方式, Null, 1, 0)), Max(结算序号)
  Into n_Count, n_Havenull, n_结算序号
  From 病人预交记录
  Where 结帐id = 冲销id_In;

  If Nvl(n_Count, 0) = 0 Or Nvl(误差金额_In, 0) <> 0 Then
    --增加结算方式为NULL的记录
    Begin
      Select 名称 Into v_误差费 From 结算方式 Where Nvl(性质, 0) = 9;
    Exception
      When Others Then
        v_误差费 := '误差费';
    End;
  End If;

  --1.增加结算方式为空的结算数据
  If Nvl(n_Havenull, 0) = 0 Then
    n_Count := 0;
    Begin
      n_结算金额 := Round(Nvl(r_Feedata.结算金额, 0), n_Dec);
    
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质, 会话号)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 2, Decode(病人id_In, 0, Null, 病人id_In), Null, r_Feedata.登记时间, r_Feedata.操作员编号,
         r_Feedata.操作员姓名, n_结算金额, 冲销id_In, r_Feedata.缴款组id, -1 * 冲销id_In, 1, 3, n_会话号);
      --误差费(先汇总后生成误差费
      If n_结算金额 <> Nvl(r_Feedata.结算金额, 0) Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质, 会话号)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, Decode(病人id_In, 0, Null, 病人id_In), v_误差费, r_Feedata.登记时间, r_Feedata.操作员编号,
           r_Feedata.操作员姓名, Nvl(r_Feedata.结算金额, 0) - n_结算金额, 冲销id_In, r_Feedata.缴款组id, -1 * 冲销id_In, 1, 3, n_会话号);
      End If;
      n_结算序号 := -1 * 冲销id_In;
    Exception
      When Others Then
        n_Count := 1;
    End;
    If n_Count = 1 Then
      v_Err_Msg := '未找到指定的退费明细数据,结算操作失败！';
      Raise Err_Item;
    End If;
  End If;

  Open c_Balancedata;
  Fetch c_Balancedata
    Into r_Balancedata;

  n_原结帐id := 原结帐id_In;
  If Nvl(n_原结帐id, 0) = 0 Then
    Select Max(b.结帐id)
    Into n_原结帐id
    From 门诊费用记录 A, 门诊费用记录 B
    Where a.结帐id = 冲销id_In And a.No = b.No And b.记录性质 = 1 And b.记录状态 In (1, 3);
  End If;

  If Nvl(n_原结帐id, 0) = 0 Then
    v_Err_Msg := '未找到原结帐数据,不能原样退！';
    Raise Err_Item;
  End If;

  If 操作类型_In = 0 Then
    --0.原样退
    --1.先处理预交款
    For v_退预交 In (Select a.Id, a.病人id, Nvl(a.冲预交, 0) As 金额
                  From 病人预交记录 A
                  Where Mod(记录性质, 10) = 1 And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0
                  Order By 收款时间 Desc) Loop
    
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
         卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 结算性质, 会话号)
        Select 病人预交记录_Id.Nextval, 11, NO, 实际票号, 记录状态, 病人id, Null, 摘要, 结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
               r_Balancedata.操作员姓名, -1 * v_退预交.金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, 卡类别id,
               结算卡序号, 卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 3, n_会话号
        From 病人预交记录
        Where ID = v_退预交.Id;
    
      --更新病人余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + v_退预交.金额
      Where 病人id = v_退预交.病人id And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (v_退预交.病人id, 1, v_退预交.金额, 1);
        n_返回值 := (-1 * v_退预交.金额);
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = v_退预交.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      Update 病人预交记录 Set 冲预交 = 冲预交 - v_退预交.金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
        Raise Err_Item;
      End If;
    End Loop;
  
    --2.处理消费卡部分
    Select Count(1)
    Into n_Count
    From 病人预交记录 A, 病人卡结算记录 B
    Where a.Id = b.结算id And a.记录性质 = 3 And a.结帐id = n_原结帐id And Rownum < 2;
    If n_Count <> 0 Then
      Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
    
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
         卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
        Select n_预交id, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, r_Balancedata. 收款时间, 缴款单位, 单位开户行, 单位帐号,
               r_Balancedata.操作员编号, r_Balancedata.操作员姓名, -1 * 冲预交, r_Balancedata.结帐id, r_Balancedata.缴款组id, 预交类别, 卡类别id,
               结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 2, r_Balancedata.结算序号, Mod(记录性质, 10), n_会话号
        From 病人预交记录 A
        Where a.记录性质 = 3 And a.结帐id = n_原结帐id And Exists (Select 1 From 病人卡结算记录 Where 结算id = a.Id);
    
      --收费时可能使用了多张消费卡
      For c_记录 In (Select a.Id, c.接口编号, c.消费卡id, c.卡号, -1 * Sum(c.应收金额) As 结算金额
                   From 病人预交记录 A, 病人卡结算记录 C
                   Where a.Id = c.结算id And a.记录性质 = 3 And a.记录状态 In (1, 3) And a.结帐id = n_原结帐id
                   Group By a.Id, c.接口编号, c.消费卡id, c.卡号) Loop
      
        Zl_病人卡结算记录_退款(c_记录.接口编号, c_记录.卡号, c_记录.消费卡id, c_记录.结算金额, c_记录.Id, n_预交id, r_Balancedata. 操作员编号,
                      r_Balancedata. 操作员姓名, r_Balancedata. 收款时间);
      End Loop;
    End If;
  
    --3.处理其他结算部分
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号,
       交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
      Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, r_Balancedata.收款时间, r_Balancedata.操作员编号,
             r_Balancedata.操作员姓名, -1 * 冲预交, r_Balancedata.结帐id, r_Balancedata.缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
             合作单位,
             Case
               When Nvl(a.卡类别id, 0) <> 0 Then
                1
               When Nvl(a.结算卡序号, 0) <> 0 Then
                1
               When Nvl(q.预交id, 0) <> 0 Then
                1
               When Nvl(j.名称, '-') <> '-' Then
               --医保
                1
               Else
                2
             End As 校对标志, r_Balancedata.结算序号, Mod(记录性质, 10), n_会话号
      From 病人预交记录 A, (Select 名称 From 结算方式 Where 性质 In (3, 4)) J,
           (Select m.Id As 预交id
             From 病人预交记录 M, 一卡通目录 C
             Where m.结帐id = n_原结帐id And m.结算方式 = c.结算方式 And m.记录性质 = 3 And m.记录状态 In (1, 3)) Q
      Where Mod(a.记录性质, 10) <> 1 And a.记录状态 In (1, 3) And a.结算方式 = j.名称(+) And a.结算方式 Is Not Null And a.结帐id = n_原结帐id And
            a.Id = q.预交id(+) And (Not Exists (Select 1 From 病人卡结算记录 Where 结算id = a.Id) Or Nvl(a.结算卡序号, 0) = 0);
  
    --更新结算方式为NULL 的记录
    Select Sum(冲预交) Into n_返回值 From 病人预交记录 Where 结帐id = r_Balancedata.结帐id And 结算方式 Is Not Null;
    Select Sum(结帐金额)
    Into n_结算金额
    From 门诊费用记录
    Where 结帐id = r_Balancedata.结帐id And Mod(记录性质, 10) = 1;
  
    Update 病人预交记录
    Set 冲预交 = Nvl(n_结算金额, 0) - Nvl(n_返回值, 0)
    Where 结帐id = 冲销id_In And 结算方式 Is Null;
    If Sql%NotFound Then
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
      Raise Err_Item;
    End If;
  
  End If;

  n_重结id := 0;
  If 操作类型_In <> 0 Then
    --不是全退时,检查是否产生了重新收费数据的
    Begin
      Select 结帐id Into n_重结id From 病人预交记录 Where 结算序号 = n_结算序号 And 结帐id <> 冲销id_In And Rownum < 2;
    Exception
      When Others Then
        n_重结id := 0;
    End;
  End If;

  --需要处理误差金额
  If Nvl(误差金额_In, 0) <> 0 Then
    --误差费放在重收的结算记录中
    n_结帐id   := 冲销id_In;
    n_记录状态 := 2;
    If Nvl(n_重结id, 0) <> 0 Then
      n_结帐id   := n_重结id;
      n_记录状态 := 1;
    End If;
  
    Update 病人预交记录
    Set 冲预交 = Nvl(冲预交, 0) + Nvl(误差金额_In, 0)
    Where 结帐id = n_结帐id And 结算方式 = v_误差费;
    If Sql%NotFound Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
      Values
        (病人预交记录_Id.Nextval, 3, Null, n_记录状态, r_Balancedata.病人id, Null, Null, v_误差费, r_Balancedata.收款时间,
         r_Balancedata.操作员编号, r_Balancedata.操作员姓名, 误差金额_In, n_结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
         Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3, n_会话号);
    End If;
  
    Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(误差金额_In, 0) Where 结帐id = n_结帐id And 结算方式 Is Null;
    If Sql%NotFound Then
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
      Raise Err_Item;
    End If;
  End If;

  --预交款处理:如果是冲预交,需要先处理冲预交款
  If Nvl(冲预交_In, 0) <> 0 Then
    If Nvl(r_Balancedata.病人id, 0) = 0 Then
      v_Err_Msg := '不能确定病人信息,不能使用预交款结算！';
      Raise Err_Item;
    End If;
  
    n_预交金额 := 冲预交_In;
    If n_预交金额 < 0 And Nvl(剩余转预交_In, 0) = 1 Then
    
      --     ②冲预交_In:如果涉及预交款,则传入本次的退预交 传入零<0时 表示退预交款或充值;>0 时:表示冲预交款
      --     ③剩余转预交_In: 1表示将剩余退款额转换为充值金额;0表示退预交
    
      --1.先生成冲值预交:
      v_No := Nextno(11);
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 金额, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 预交类别, 结算性质, 会话号)
      Values
        (病人预交记录_Id.Nextval, 1, v_No, 1, r_Balancedata.病人id, Null, '退费生成预交', v_退费结算, r_Balancedata.收款时间,
         r_Balancedata.操作员编号, r_Balancedata.操作员姓名, -1 * n_预交金额, r_Balancedata.结帐id, r_Balancedata.缴款组id,
         r_Balancedata.结算序号, 0, Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 1, Null, n_会话号);
    
      --更新病人余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + (-1 * n_预交金额)
      Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (病人id_In, 1, -1 * n_预交金额, 1);
        n_返回值 := -1 * n_预交金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Balancedata.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --2.生成退费记录
      If Nvl(n_重结id, 0) <> 0 Then
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
        If Nvl(n_返回值, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
          Values
            (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_退费结算, r_Balancedata.收款时间,
             r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_返回值, 冲销id_In, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
             Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3, n_会话号);
        
          Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
        End If;
        n_结算金额 := n_结算金额 - Nvl(n_返回值, 0);
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, v_结算摘要, v_退费结算, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, n_重结id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
           Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3, n_会话号);
        Update 病人预交记录 Set 冲预交 = 冲预交 + n_预交金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
        If Sql%NotFound Then
          v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
          Raise Err_Item;
        End If;
      Else
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, -1 * n_预交金额, r_Balancedata.结帐id, r_Balancedata.缴款组id,
           r_Balancedata.结算序号, 2, Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3, n_会话号);
        Update 病人预交记录 Set 冲预交 = 冲预交 + n_预交金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
        If Sql%NotFound Then
          v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  
    If Nvl(n_预交金额, 0) < 0 And Nvl(剩余转预交_In, 0) = 0 Then
      If Nvl(n_重结id, 0) <> 0 Then
        --1.退预交款
        For v_退预交 In (Select Max(a.Id) As ID, a.病人id, Max(a.收款时间) As 收款时间, Sum(Nvl(a.冲预交, 0)) As 金额
                      From 病人预交记录 A,
                           (Select Distinct a.结帐id
                             From 门诊费用记录 A, 门诊费用记录 B
                             Where a.No = b.No And Mod(a.记录性质, 10) = 1 And b.结帐id = n_原结帐id) B
                      Where a.结帐id = b.结帐id And Mod(a.记录性质, 10) = 1 And Nvl(a.预交类别, 0) = 1
                      Group By NO, 病人id
                      Having Sum(Nvl(a.冲预交, 0)) > 0
                      Order By 收款时间 Desc) Loop
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id,
             结算卡序号, 卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 结算性质, 会话号)
            Select 病人预交记录_Id.Nextval, 11, NO, 实际票号, 记录状态, 病人id, Null, 摘要, 结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
                   r_Balancedata.操作员姓名, -1 * v_退预交.金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2,
                   卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 3, n_会话号
            From 病人预交记录
            Where ID = v_退预交.Id;
        
          --更新病人余额
          Update 病人余额
          Set 预交余额 = Nvl(预交余额, 0) + v_退预交.金额
          Where 病人id = v_退预交.病人id And 性质 = 1 And 类型 = 1
          Returning 预交余额 Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (v_退预交.病人id, 1, v_退预交.金额, 1);
            n_返回值 := v_退预交.金额;
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 病人余额
            Where 病人id = v_退预交.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
          End If;
        
          Update 病人预交记录 Set 冲预交 = 冲预交 - (-1 * v_退预交.金额) Where 结帐id = 冲销id_In And 结算方式 Is Null;
          If Sql%NotFound Then
            v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
            Raise Err_Item;
          End If;
          n_预交金额 := n_预交金额 - (-1 * v_退预交.金额);
        End Loop;
      
        --2.冲预交款
        If n_预交金额 <> 0 Then
          For v_退预交 In (Select Max(a.Id) As ID, a.病人id, Max(a.收款时间) As 收款时间, Sum(Nvl(a.冲预交, 0)) As 金额
                        From 病人预交记录 A,
                             (Select Distinct a.结帐id
                               From 门诊费用记录 A, 门诊费用记录 B
                               Where a.No = b.No And Mod(a.记录性质, 10) = 1 And b.结帐id = n_原结帐id) B
                        Where a.结帐id = b.结帐id And Mod(a.记录性质, 10) = 1 And Nvl(a.预交类别, 0) = 1 And a.结帐id <> 冲销id_In
                        Group By NO, 病人id
                        Having Sum(Nvl(a.冲预交, 0)) > 0
                        Order By 收款时间 Desc) Loop
          
            If v_退预交.金额 - n_预交金额 < 0 Then
              n_结算金额 := v_退预交.金额;
              n_预交金额 := n_预交金额 - v_退预交.金额;
            Else
              n_结算金额 := n_预交金额;
              n_预交金额 := 0;
            End If;
          
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id,
               结算卡序号, 卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 结算性质, 会话号)
              Select 病人预交记录_Id.Nextval, 11, NO, 实际票号, 记录状态, 病人id, Null, 摘要, 结算方式, r_Balancedata.收款时间,
                     r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, n_重结id, r_Balancedata.缴款组id, r_Balancedata.结算序号,
                     2, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 3, n_会话号
              From 病人预交记录
              Where ID = v_退预交.Id;
          
            --更新病人余额
            Update 病人余额
            Set 预交余额 = Nvl(预交余额, 0) + (-1 * n_结算金额)
            Where 病人id = v_退预交.病人id And 性质 = 1 And 类型 = 1
            Returning 预交余额 Into n_返回值;
            If Sql%RowCount = 0 Then
              Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (v_退预交.病人id, 1, -1 * n_结算金额, 1);
              n_返回值 := -1 * n_结算金额;
            End If;
            If Nvl(n_返回值, 0) = 0 Then
              Delete From 病人余额
              Where 病人id = v_退预交.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
            End If;
          
            Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = n_重结id And 结算方式 Is Null;
            n_返回值 := 1;
            If Sql%NotFound Then
              v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
              Raise Err_Item;
            End If;
            If n_预交金额 = 0 Then
              Exit;
            End If;
          End Loop;
        End If;
      Else
        --退预交款
        n_返回值   := 0;
        n_预交金额 := -1 * n_预交金额;
      
        For v_退预交 In (Select Max(a.Id) As ID, a.病人id, Max(a.收款时间) As 收款时间, Sum(Nvl(a.冲预交, 0)) As 金额
                      From 病人预交记录 A,
                           (Select Distinct a.结帐id
                             From 门诊费用记录 A, 门诊费用记录 B
                             Where a.No = b.No And Mod(a.记录性质, 10) = 1 And b.结帐id = n_原结帐id) B
                      Where a.结帐id = b.结帐id And Mod(a.记录性质, 10) = 1 And Nvl(a.预交类别, 0) = 1
                      Group By NO, 病人id
                      Having Sum(Nvl(a.冲预交, 0)) > 0
                      Order By 收款时间 Desc) Loop
        
          If v_退预交.金额 - n_预交金额 < 0 Then
            n_结算金额 := -1 * v_退预交.金额;
            n_预交金额 := n_预交金额 - v_退预交.金额;
          Else
            n_结算金额 := -1 * n_预交金额;
            n_预交金额 := 0;
          End If;
        
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id,
             结算卡序号, 卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 结算性质, 会话号)
            Select 病人预交记录_Id.Nextval, 11, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
                   r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, 卡类别id,
                   结算卡序号, 卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 3, n_会话号
            From 病人预交记录
            Where ID = v_退预交.Id;
        
          --更新病人余额
          Update 病人余额
          Set 预交余额 = Nvl(预交余额, 0) + (-1 * n_结算金额)
          Where 病人id = v_退预交.病人id And 性质 = 1 And 类型 = 1
          Returning 预交余额 Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (v_退预交.病人id, 1, -1 * n_结算金额, 1);
            n_返回值 := -1 * n_结算金额;
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 病人余额
            Where 病人id = v_退预交.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
          End If;
        
          Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
          n_返回值 := 1;
          If Sql%NotFound Then
            v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
            Raise Err_Item;
          End If;
          If n_预交金额 = 0 Then
            Exit;
          End If;
        End Loop;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        v_Err_Msg := '未找到原始的冲预交记录,不能回退预交款！';
        Raise Err_Item;
      End If;
    
      If Nvl(n_预交金额, 0) <> 0 Then
        v_Err_Msg := '当前退预交超过了收费结算中的冲预交款,不能回退预交款！';
        Raise Err_Item;
      End If;
    
    End If;
  
    n_预交金额 := 冲预交_In;
    If Nvl(n_预交金额, 0) > 0 Then
      --冲预交款
      --病人余额检查
      Begin
        Select Sum(Nvl(预交余额, 0) - Nvl(费用余额, 0))
        Into n_预交金额
        From 病人余额
        Where 病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And Nvl(性质, 0) = 1 And 类型 = 1;
      Exception
        When Others Then
          n_预交金额 := 0;
      End;
      If n_预交金额 < 冲预交_In Then
        v_Err_Msg := '病人的当前预交余额为 ' || LTrim(To_Char(n_预交金额, '9999999990.00')) || '，小于本次支付金额 ' ||
                     LTrim(To_Char(冲预交_In, '9999999990.00')) || ' ！';
        Raise Err_Item;
      End If;
    
      n_预交金额 := 冲预交_In;
      n_结帐id   := 冲销id_In;
      If Nvl(n_重结id, 0) <> 0 Then
        n_结帐id := n_重结id;
      End If;
    
      --先缴先用，且先用自己的
      --不包含结算方式为代收款项的预交款。
      For c_冲预交 In (Select a.No, Sum(Nvl(a.金额, 0) - Nvl(a.冲预交, 0)) As 金额, Nvl(Max(a.结帐id), 0) As 结帐id, Max(病人id) As 病人id,
                           Max(Decode(a.记录性质, 1, a.记录状态, 1)) As 记录状态,
                           Max(Decode(a.记录性质, 1, Decode(a.记录状态, 1, a.Id, 3, a.Id, 0), 0)) As ID,
                           Max(Decode(a.记录性质, 1, Decode(a.记录状态, 1, a.收款时间, 3, a.收款时间, Null, Null))) As 收款时间
                    From 病人预交记录 A
                    Where a.记录性质 In (1, 11) And a.病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And
                          Nvl(a.预交类别, 2) = 1 And a.结算方式 Not In (Select 名称 From 结算方式 Where 性质 = 5)
                    Group By a.No
                    Having Sum(Nvl(a.金额, 0) - Nvl(a.冲预交, 0)) <> 0
                    Order By Decode(病人id, Nvl(病人id_In, 0), 0, 1), 收款时间) Loop
      
        If c_冲预交.金额 - n_预交金额 < 0 Then
          n_冲预交 := c_冲预交.金额;
        Else
          n_冲预交 := n_预交金额;
        End If;
      
        If c_冲预交.结帐id = 0 Then
          --第一次冲预交(填上结帐ID，金额为0)
          Update 病人预交记录
          Set 冲预交 = 0, 结帐id = n_结帐id, 结算序号 = n_结算序号, 结算性质 = 3, 会话号 = n_会话号
          Where ID = c_冲预交.Id;
        End If;
        --冲上次剩余额
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质, 会话号)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 r_Balancedata.收款时间, r_Balancedata.操作员姓名, r_Balancedata.操作员编号, n_冲预交, n_结帐id, r_Balancedata.缴款组id, 预交类别,
                 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, n_结算序号, 3, n_会话号
          From 病人预交记录
          Where NO = c_冲预交.No And 记录状态 = c_冲预交.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
      
        --更新数据(结算方式为NULL的)
        Update 病人预交记录
        Set 冲预交 = 冲预交 - n_冲预交
        Where 结帐id = n_结帐id And 结算方式 Is Null
        Returning Nvl(冲预交, 0) Into n_返回值;
      
        --更新病人预交余额
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) - n_冲预交
        Where 病人id = c_冲预交.病人id And 性质 = 1 And 类型 = 1
        Returning 预交余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (c_冲预交.病人id, 1, -1 * n_冲预交, 1);
          n_返回值 := -1 * n_冲预交;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 病人余额
          Where 病人id = c_冲预交.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
        End If;
      
        --检查是否已经处理完
        If c_冲预交.金额 < n_预交金额 Then
          n_预交金额 := n_预交金额 - c_冲预交.金额;
        Else
          n_预交金额 := 0;
        End If;
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
    
      --检查金额是否足够
      If Abs(n_预交金额) > 0 Then
        v_Err_Msg := '病人的当前预交余额小于本次支付金额 ' || LTrim(To_Char(冲预交_In, '9999999990.00')) || ' ！';
        Raise Err_Item;
      End If;
    End If;
  End If;

  If 操作类型_In = 1 Then
    --   1-普通退费方式:
    --各个收费结算 :格式为:"结算方式|结算金额|结算号码|结算摘要||.."
    v_结算内容 := 结算方式_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
    
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If v_结算方式 Is Null Then
        v_结算方式 := 缺省结算方式_In;
      End If;
      If Nvl(n_结算金额, 0) <> 0 Then
        n_结算金额 := Nvl(n_结算金额, 0);
        If Nvl(n_重结id, 0) <> 0 Then
          --肯定是收款
          --1.先按此种方式全退
          --2.再按此种方式收款
          --3:1+2=本次退款
          --1.先将退费的全部作废掉
          Select Sum(冲预交)
          Into n_返回值
          From 病人预交记录
          Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
        
          If Nvl(n_返回值, 0) <> 0 Then
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
               卡号, 交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
            Values
              (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
               r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_返回值, 冲销id_In, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2,
               Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3, n_会话号);
            Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
          End If;
          n_结算金额 := n_结算金额 - Nvl(n_返回值, 0);
          --2.退款
          If Nvl(n_结算金额, 0) <> 0 Then
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
               卡号, 交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
            Values
              (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
               r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, n_重结id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2,
               Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3, n_会话号);
            Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = n_重结id And 结算方式 Is Null;
          End If;
        Else
          --退款
          If Nvl(n_结算金额, 0) <> 0 Then
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
               卡号, 交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
            Values
              (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
               r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id,
               r_Balancedata.结算序号, 2, Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3, n_会话号);
          
            Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
            If Sql%NotFound Then
              v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
              Raise Err_Item;
            End If;
          End If;
        End If;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If 操作类型_In = 2 Then
    --   2.三方卡退费结算:
    v_当前结算 := 结算方式_In;
    v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
  
    If Nvl(n_结算金额, 0) <> 0 Then
      If Nvl(n_重结id, 0) <> 0 Then
        --1.先按此种方式全退
        --2.再按此种方式收款
        --3:1+2=本次退款
        --1.先将退费的全部作废掉
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
        If Nvl(n_返回值, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
          Values
            (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
             r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_返回值, 冲销id_In, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2,
             卡类别id_In, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3, n_会话号);
          Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
        End If;
        n_结算金额 := n_结算金额 - Nvl(n_返回值, 0);
      
        --2.退款
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, n_重结id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2,
           卡类别id_In, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3, n_会话号);
        Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = n_重结id And 结算方式 Is Null;
      
      Else
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号,
           2, 卡类别id_In, Null, 卡号_In, 交易流水号_In, 交易说明_In, v_结算号码, 3, n_会话号);
      
        Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
        If Sql%NotFound Then
          v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  End If;

  If 操作类型_In = 3 Then
    --   3-医保结算(如果存在医保的结算,则要先删除原医保结算,后按新传入的更新)
    --3.1检查是否已经存在医保结算数据,存在先删除
    n_结算金额 := 0;
    For v_医保 In (Select ID, 结算方式, 冲预交
                 From 病人预交记录 A
                 Where 结帐id = 冲销id_In And Exists
                  (Select 1 From 结算方式 Where a.结算方式 = 名称 And 性质 In (3, 4)) And Mod(记录性质, 10) <> 1) Loop
      n_结算金额 := n_结算金额 + Nvl(v_医保.冲预交, 0);
      l_预交id.Extend;
      l_预交id(l_预交id.Count) := v_医保.Id;
    End Loop;
    If Nvl(n_结算金额, 0) <> 0 Then
      Update 病人预交记录
      Set 冲预交 = Nvl(冲预交, 0) + Nvl(n_结算金额, 0)
      Where 结帐id = 冲销id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
        Raise Err_Item;
      End If;
    End If;
    If l_预交id.Count <> 0 Then
      Forall I In 1 .. l_预交id.Count
        Delete 病人预交记录 Where ID = l_预交id(I);
    End If;
  
    If 结算方式_In Is Not Null Then
      v_结算内容 := 结算方式_In || '||';
    End If;
  
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      For c_结算信息 In (Select 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号
                     From 病人预交记录
                     Where 结帐id = 冲销id_In And 结算方式 Is Null) Loop
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质, 会话号)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 2, c_结算信息.病人id, Null, '保险结算', v_结算方式, c_结算信息.收款时间, c_结算信息.操作员编号, c_结算信息.操作员姓名,
           n_结算金额, c_结算信息.结帐id, c_结算信息.缴款组id, c_结算信息.结算序号, 1, 3, n_会话号);
      End Loop;
      --更新数据(结算方式为NULL的)
      Update 病人预交记录
      Set 冲预交 = 冲预交 - n_结算金额
      Where 结帐id = 冲销id_In And 结算方式 Is Null
      Returning Nvl(冲预交, 0) Into n_返回值;
    
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --4-消费卡批量结算
  If 操作类型_In = 4 Then
    v_结算内容 := 结算方式_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      --卡类别ID|卡号|消费卡ID|消费金额
      n_卡类别id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_卡号     := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_消费卡id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(v_当前结算);
    
      Begin
        Select 名称, 结算方式 Into v_名称, v_结算方式 From 消费卡类别目录 Where 编号 = n_卡类别id;
      Exception
        When Others Then
          v_名称 := Null;
      End;
      If v_名称 Is Null Then
        v_Err_Msg := '未找到对应的结算卡接口,本次刷卡消费失败!';
        Raise Err_Item;
      End If;
      If v_结算方式 Is Null Then
        v_Err_Msg := v_名称 || '未设置对应的结算方式,本次刷卡消费失败!';
        Raise Err_Item;
      End If;
      If Nvl(n_结算金额, 0) <> 0 Then
        n_结帐id := 冲销id_In;
      
        If Nvl(n_重结id, 0) <> 0 Then
          For c_记录 In (Select a.Id, c.接口编号, c.消费卡id, c.卡号, c.应收金额 As 结算金额
                       From 病人预交记录 A, 病人卡结算记录 C
                       Where a.Id = c.结算id And a.记录性质 = 3 And a.记录状态 In (1, 3) And a.结帐id = n_原结帐id And c.接口编号 = n_卡类别id And
                             c.消费卡id = n_消费卡id) Loop
          
            If Nvl(c_记录.结算金额, 0) <> 0 Then
              Update 病人预交记录
              Set 冲预交 = Nvl(冲预交, 0) + c_记录.结算金额
              Where 结帐id = 冲销id_In And 结算方式 = v_结算方式 And 结算卡序号 = n_卡类别id
              Returning ID Into n_预交id;
              If Sql%NotFound Then
                Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
                Insert Into 病人预交记录
                  (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算卡序号, 校对标志,
                   结算性质, 会话号)
                Values
                  (n_预交id, 3, Null, 2, r_Balancedata. 病人id, Null, Null, v_结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
                   r_Balancedata. 操作员姓名, c_记录.结算金额, r_Balancedata.结帐id, r_Balancedata. 缴款组id, r_Balancedata.结算序号,
                   n_卡类别id, 2, 3, n_会话号);
              End If;
            
              Update 病人预交记录 Set 冲预交 = 冲预交 - c_记录.结算金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
            
              --插入卡结算记录
              Zl_病人卡结算记录_退款(c_记录.接口编号, c_记录.卡号, c_记录.消费卡id, -1 * c_记录.结算金额, c_记录.Id, n_预交id, r_Balancedata. 操作员编号,
                            r_Balancedata. 操作员姓名, r_Balancedata. 收款时间);
            
              n_结算金额 := n_结算金额 - c_记录.结算金额;
            End If;
          End Loop;
          n_结帐id := n_重结id;
        End If;
      
        Update 病人预交记录
        Set 冲预交 = Nvl(冲预交, 0) + n_结算金额
        Where 结帐id = n_结帐id And 结算方式 = v_结算方式 And 结算卡序号 = n_卡类别id
        Returning ID Into n_预交id;
        If Sql%NotFound Then
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算卡序号, 校对标志, 结算性质,
             会话号)
          Values
            (n_预交id, 3, Null, Decode(Nvl(n_重结id, 0), 0, 2, 1), r_Balancedata. 病人id, Null, Null, v_结算方式,
             r_Balancedata. 收款时间, r_Balancedata. 操作员编号, r_Balancedata. 操作员姓名, n_结算金额, n_结帐id, r_Balancedata. 缴款组id,
             r_Balancedata. 结算序号, n_卡类别id, 2, 3, n_会话号);
        End If;
      
        If Nvl(n_重结id, 0) = 0 Then
          Begin
            Select ID Into n_原预交id From 病人预交记录 A Where 结帐id = n_原结帐id And 结算卡序号 = n_卡类别id;
          Exception
            When Others Then
              v_Err_Msg := '未找到原结算记录！';
              Raise Err_Item;
          End;
        
          Zl_病人卡结算记录_退款(n_卡类别id, v_卡号, n_消费卡id, -1 * n_结算金额, n_原预交id, n_预交id, r_Balancedata. 操作员编号,
                        r_Balancedata. 操作员姓名, r_Balancedata. 收款时间);
        Else
          Zl_病人卡结算记录_支付(n_卡类别id, v_卡号, n_消费卡id, n_结算金额, n_预交id, r_Balancedata. 操作员编号, r_Balancedata. 操作员姓名,
                        r_Balancedata. 收款时间);
        End If;
      
        --更新数据(结算方式为NULL的)
        Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = n_结帐id And 结算方式 Is Null;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If Nvl(完成退费_In, 0) = 0 Then
    Return;
  End If;

  -----------------------------------------------------------------------------------------
  --完成收费,需要处理人员缴款余额,预交记录(结算方式=NULL)
  If Nvl(完成退费_In, 0) = 1 Then
    Update 病人预交记录 Set 缴款 = 缴款_In, 找补 = 找补_In, 校对标志 = 0, 会话号 = Null Where 结帐id = 冲销id_In;
    Return;
  End If;

  --1.删除结算方式为NULL的预交记录
  --结算方式为NULL的冲销记录和重结记录的金额之和为零，说明已完成全部结算
  If Nvl(n_重结id, 0) <> 0 Then
    Select Sum(Nvl(冲预交, 0))
    Into n_冲预交
    From 病人预交记录
    Where 结帐id In (冲销id_In, n_重结id) And 结算方式 Is Null;
    If Nvl(n_冲预交, 0) <> 0 Then
      v_Err_Msg := '还存在未缴款的数据,不能完成结算!';
      Raise Err_Item;
    Else
      Delete 病人预交记录 Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) = 0;
      If Sql%NotFound Then
        Update 病人预交记录 Set 结算方式 = v_退费结算 Where 结帐id = 冲销id_In And 结算方式 Is Null;
        If Sql%NotFound Then
          v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[退费结算窗口]中重新收费！!';
          Raise Err_Item;
        End If;
      End If;
    
      Delete 病人预交记录 Where 结帐id = n_重结id And 结算方式 Is Null And Nvl(冲预交, 0) = 0;
      If Sql%NotFound Then
        Update 病人预交记录 Set 结算方式 = v_退费结算 Where 结帐id = n_重结id And 结算方式 Is Null;
        If Sql%NotFound Then
          v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[退费结算窗口]中重新收费！!';
          Raise Err_Item;
        End If;
      End If;
    End If;
    Update 病人预交记录 Set 缴款 = 缴款_In, 找补 = 找补_In, 校对标志 = 0 Where 结帐id = n_重结id;
  Else
    Delete 病人预交记录 Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) = 0;
    If Sql%NotFound Then
      Select Count(1) Into n_Count From 病人预交记录 A Where 结帐id = 冲销id_In And 结算方式 Is Null;
      If n_Count <> 0 Then
        v_Err_Msg := '还存在未缴款的数据,不能完成结算!';
      Else
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[退费结算窗口]中重新收费！!';
      End If;
      Raise Err_Item;
    End If;
  End If;

  --检查门诊费用记录与病人预交记录的金额是否相等
  n_结算金额 := 0;
  n_冲预交   := 0;
  Select Nvl(Sum(实收金额), 0)
  Into n_结算金额
  From 门诊费用记录
  Where 结帐id In (Select 结帐id From 病人预交记录 Where 结算序号 = n_结算序号);
  Select Nvl(Sum(冲预交), 0) Into n_冲预交 From 病人预交记录 Where 结算序号 = n_结算序号;
  If n_结算金额 <> n_冲预交 Then
    v_Err_Msg := '结算信息有误，实收金额(' || n_结算金额 || ')与结算金额(' || n_冲预交 || ')不一致，不能完成结算！';
    Raise Err_Item;
  End If;

  --结算金额为零时，增加一条金额为0的病人预交记录
  Select Count(1) Into n_Count From 病人预交记录 A Where 结帐id = 冲销id_In;
  If n_Count = 0 Then
    v_结算方式 := 缺省结算方式_In;
    If v_结算方式 Is Null Then
      Begin
        Select 结算方式 Into v_结算方式 From 结算方式应用 Where 应用场合 = '收费' And Nvl(缺省标志, 0) = 1;
      Exception
        When Others Then
          v_结算方式 := Null;
      End;
      If v_结算方式 Is Null Then
        Begin
          Select 名称 Into v_结算方式 From 结算方式 Where Nvl(性质, 0) = 1;
        Exception
          When Others Then
            v_结算方式 := '现金';
        End;
      End If;
    End If;
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
       交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
    Values
      (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, Null, v_结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
       r_Balancedata.操作员姓名, 0, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null, Null, Null, Null,
       交易说明_In, Null, 3, n_会话号);
  End If;

  --2.处理缴款数据和找补数据及校对标志更新为0，会话号更新为NULL
  Update 病人预交记录
  Set 缴款 = 缴款_In, 找补 = 找补_In, 校对标志 = 0, 会话号 = Null
  Where 结帐id In (冲销id_In, n_重结id);

  --3.更新费用状态
  Update 门诊费用记录 Set 费用状态 = 0 Where 结帐id In (冲销id_In, n_重结id);

  --4.更新人员缴款数据
  For c_缴款 In (Select 结算方式, 操作员姓名, Sum(Nvl(a.冲预交, 0)) As 冲预交
               From 病人预交记录 A
               Where a.结帐id In (冲销id_In, n_重结id) And Mod(a.记录性质, 10) <> 1
               Group By 结算方式, 操作员姓名) Loop
  
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + Nvl(c_缴款.冲预交, 0)
    Where 收款员 = c_缴款.操作员姓名 And 性质 = 1 And 结算方式 = c_缴款.结算方式;
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额
        (收款员, 结算方式, 性质, 余额)
      Values
        (c_缴款.操作员姓名, c_缴款.结算方式, 1, Nvl(c_缴款.冲预交, 0));
    End If;
  End Loop;

  --消息集成处理
  b_Message.Zlhis_Charge_004(1, 冲销id_In);
  If Nvl(n_重结id, 0) <> 0 Then
    b_Message.Zlhis_Charge_002(1, n_重结id);
  End If;
  --消息推送
  Select 病人id_In || ',' || 冲销id_In || ',' || Decode(完成退费_In, 2, 0, 0, 0, 1) Into v_Msg From Dual;
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 5, v_Msg;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊退费结算_Modify;
/

--122203:冉俊明,2018-02-13,增加保存费用的三方调用接口(Oracle)
Create Or Replace Procedure Zl_Third_Saveexes
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:保存费用记录
  --入参:Xml_In:
  --<IN>
  --  <PATIID></PATIID>  //病人ID
  --  <PAGEID></PAGEID>  //主页ID
  --  <MZBZ></MZBZ>   //门诊标志，1-门诊，2-住院，3-就诊卡
  --  <JZBZ></JZBZ>   //记帐标志，0-收费，1-记帐
  --  <CZY></CZY>   //操作员
  --  <CZSJ></CZSJ>   //操作时间
  --  <KDR></KDR>  //开单人
  --  <KDKSID></KDKSID>  //开单科室ID
  --  <YQBH></YQBH>  //院区编号
  --  <MXLIST>
  --    <MX>
  --      <SFXMID></SFXMID>  //收费细目ID
  --      <SL></SL>   //数次
  --      <ZXR></ZXR>  //执行人,表示完全执行
  --      <ZXKSID></ZXKSID>  //执行科室ID
  --    </MX>
  --    ...
  --  </MXLIST>
  --</IN>
  --出参:Xml_Out
  --成功：
  --<OUTPUT>
  --   <RESULT>true</RESULT>
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  n_病人id     病人信息.病人id%Type;
  n_主页id     病案主页.主页id%Type;
  n_门诊标志   门诊费用记录.门诊标志%Type; --1-门诊，2-住院，3-就诊卡
  n_记帐标志   Number(2); --0-收费，1-记帐
  v_操作员姓名 门诊费用记录.操作员姓名%Type;
  d_操作时间   门诊费用记录.登记时间%Type;
  v_开单人     门诊费用记录.开单人%Type;
  n_开单部门id 门诊费用记录.开单部门id%Type;
  v_站点       部门表.站点%Type;
  Xml_明细列表 Xmltype;

  v_No           门诊费用记录.No%Type;
  v_卡费no       住院费用记录.No%Type;
  n_标识号       门诊费用记录.标识号%Type;
  v_姓名         门诊费用记录.姓名%Type;
  v_性别         门诊费用记录.性别%Type;
  v_年龄         门诊费用记录.年龄%Type;
  v_费别         门诊费用记录.费别%Type;
  v_付款方式编码 门诊费用记录.付款方式%Type;
  v_付款方式名称 病人信息.医疗付款方式%Type;
  n_病区id       住院费用记录.病人病区id%Type;
  n_科室id       门诊费用记录.病人科室id%Type;
  v_床号         住院费用记录.床号%Type;
  v_操作员编号   门诊费用记录.操作员编号%Type;

  Type Ty_Rec_Bill Is Record(
    序号       门诊费用记录.序号%Type,
    价格父号   门诊费用记录.价格父号%Type,
    收费细目id 门诊费用记录.收费细目id%Type,
    收费类别   门诊费用记录.收费类别%Type,
    计算单位   门诊费用记录.计算单位%Type,
    收入项目id 门诊费用记录.收入项目id%Type,
    收据费目   门诊费用记录.收据费目%Type,
    数次       门诊费用记录.数次%Type,
    标准单价   门诊费用记录.标准单价%Type,
    应收金额   门诊费用记录.应收金额%Type,
    实收金额   门诊费用记录.实收金额%Type,
    执行人     门诊费用记录.执行人%Type,
    执行部门id 门诊费用记录.执行部门id%Type,
    费用摘要   门诊费用记录.摘要%Type);

  Type Ty_Tb_Bill Is Table Of Ty_Rec_Bill;
  c_Bill Ty_Tb_Bill := Ty_Tb_Bill();

  n_单价小数 Number;
  n_金额小数 Number;

  v_Temp     Varchar2(4000);
  v_价格等级 收费价目.价格等级%Type;
  v_普通等级 收费价目.价格等级%Type;
  v_药品等级 收费价目.价格等级%Type;
  v_卫材等级 收费价目.价格等级%Type;

  n_序号         门诊费用记录.序号%Type;
  n_价格父号     门诊费用记录.价格父号%Type;
  n_当前价格父号 门诊费用记录.价格父号%Type;
  n_返回值       病人余额.费用余额%Type;
  n_价格         门诊费用记录.标准单价%Type;
  n_剩余数       门诊费用记录.数次%Type;
  n_实收金额     门诊费用记录.实收金额%Type;
  d_登记时间     门诊费用记录.登记时间%Type;

  v_Err_Msg Varchar2(255);
  Err_Item Exception;
Begin
  --获取入参
  Select Extractvalue(Value(A), 'IN/PATIID'),
         Decode(Extractvalue(Value(A), 'IN/PAGEID'), 0, Null, Extractvalue(Value(A), 'IN/PAGEID')),
         Nvl(Extractvalue(Value(A), 'IN/MZBZ'), 0), Nvl(Extractvalue(Value(A), 'IN/JZBZ'), 0),
         Extractvalue(Value(A), 'IN/CZY'), To_Date(Extractvalue(Value(A), 'IN/CZSJ'), 'yyyy-mm-dd hh24:mi:ss'),
         Extractvalue(Value(A), 'IN/KDR'),
         Decode(Extractvalue(Value(A), 'IN/KDKSID'), 0, Null, Extractvalue(Value(A), 'IN/KDKSID')),
         Extractvalue(Value(A), 'IN/YQBH'), Extract(Value(A), 'IN/MXLIST')
  Into n_病人id, n_主页id, n_门诊标志, n_记帐标志, v_操作员姓名, d_操作时间, v_开单人, n_开单部门id, v_站点, Xml_明细列表
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  Begin
    Select a.编号 Into v_操作员编号 From 人员表 A Where a.姓名 = v_操作员姓名;
  Exception
    When Others Then
      v_Err_Msg := '未查找到操作员信息，单据保存失败！';
      Raise Err_Item;
  End;

  Begin
    If n_门诊标志 = 2 Then
      Select a.姓名, a.性别, a.年龄, a.费别, a.住院号, a.当前病区id, Nvl(a.出院科室id, n_开单部门id), a.出院病床, c.编码, c.名称
      Into v_姓名, v_性别, v_年龄, v_费别, n_标识号, n_病区id, n_科室id, v_床号, v_付款方式编码, v_付款方式名称
      From 病案主页 A, 病人信息 B, 医疗付款方式 C
      Where a.病人id = b.病人id And b.病人id = n_病人id And a.主页id = n_主页id And a.医疗付款方式 = c.名称(+);
    Else
      Select a.姓名, a.性别, a.年龄, a.费别, a.门诊号, n_开单部门id, b.编码, b.名称
      Into v_姓名, v_性别, v_年龄, v_费别, n_标识号, n_科室id, v_付款方式编码, v_付款方式名称
      From 病人信息 A, 医疗付款方式 B
      Where a.病人id = n_病人id And a.医疗付款方式 = b.名称(+);
    End If;
  Exception
    When Others Then
      v_Err_Msg := '未查找到病人信息，单据保存失败！';
      Raise Err_Item;
  End;

  If v_费别 Is Null Then
    Select Max(名称) Into v_费别 From 费别 Where 缺省标志 = 1 And Rownum < 2;
    If v_费别 Is Null Then
      v_Err_Msg := '无法确定病人费别，请检查缺省费别是否正确设置！';
      Raise Err_Item;
    End If;
  End If;

  --金额及单价小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')), Zl_To_Number(Nvl(zl_GetSysParameter(157), '5'))
  Into n_金额小数, n_单价小数
  From Dual;

  --价格等级
  v_Temp := Zl_Get_Pricegrade(v_站点, n_病人id, n_主页id, v_付款方式名称);
  For c_价格等级 In (Select Rownum As 序号, Column_Value As 价格等级 From Table(f_Str2list(v_Temp, '|'))) Loop
    If c_价格等级.序号 = 1 Then
      v_普通等级 := c_价格等级.价格等级;
    End If;
    If c_价格等级.序号 = 2 Then
      v_药品等级 := c_价格等级.价格等级;
    End If;
    If c_价格等级.序号 = 3 Then
      v_卫材等级 := c_价格等级.价格等级;
    End If;
  End Loop;

  n_序号 := 1;
  For c_明细 In (Select a.收费细目id, a.数次, a.执行人, a.执行科室id, a.摘要, b.类别, b.名称, b.计算单位, b.是否变价, b.屏蔽费别, b.撤档时间
               From (Select Extractvalue(Value(J), '/MX/SFXMID') As 收费细目id, Extractvalue(Value(J), '/MX/SL') As 数次,
                             Extractvalue(Value(J), '/MX/ZXR') As 执行人, Extractvalue(Value(J), '/MX/ZXKSID') As 执行科室id,
                             Extractvalue(Value(J), '/MX/FYZY') As 摘要
                      From Table(Xmlsequence(Extract(Xml_明细列表, '/MXLIST/MX'))) J) A, 收费项目目录 B
               Where a.收费细目id = b.Id) Loop
  
    If Nvl(c_明细.撤档时间, Sysdate + 1) < Sysdate Then
      v_Err_Msg := '“' || c_明细.名称 || '”已停用，单据保存失败！';
      Raise Err_Item;
    End If;
  
    n_价格父号 := n_序号;
    If c_明细.类别 = '4' Then
      v_价格等级 := v_卫材等级;
    Elsif Instr(',5,6,7,', ',' || c_明细.类别 || ',') > 0 Then
      v_价格等级 := v_药品等级;
    Else
      v_价格等级 := v_普通等级;
    End If;
  
    For c_收费价目 In (Select a.收入项目id, b.收据费目, a.现价, a.缺省价格
                   From 收费价目 A, 收入项目 B
                   Where a.收入项目id = b.Id And Sysdate Between a.执行日期 And Nvl(a.终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')) And
                         a.收费细目id = c_明细.收费细目id And
                         (a.价格等级 = v_价格等级 Or
                         (a.价格等级 Is Null And Not Exists
                          (Select 1
                            From 收费价目
                            Where a.收费细目id = 收费细目id And 价格等级 = v_价格等级 And Sysdate Between 执行日期 And
                                  Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')))))) Loop
    
      If n_价格父号 = n_序号 Then
        n_当前价格父号 := Null;
      Else
        n_当前价格父号 := n_价格父号;
      End If;
    
      If Instr(',4,5,6,7,', ',' || c_明细.类别 || ',') = 0 Then
        --普通收费项目
        If Nvl(c_明细.是否变价, 0) = 0 Then
          n_价格 := Nvl(c_收费价目.现价, 0);
        Else
          n_价格 := Nvl(c_收费价目.缺省价格, 0);
        End If;
      Else
        --药品卫材
        v_Temp   := Zl_Get_Retailprice(c_明细.收费细目id, v_价格等级, c_明细.执行科室id, c_明细.数次) || '||';
        n_价格   := Nvl(Substr(v_Temp, 1, Instr(v_Temp, '|') - 1), 0);
        v_Temp   := Substr(v_Temp, Instr(v_Temp, '|') + 1);
        n_剩余数 := Substr(v_Temp, 1, Instr(v_Temp, '|') - 1);
      
        If Nvl(n_剩余数, 0) <> 0 And Nvl(c_明细.是否变价, 0) = 1 Then
          --数量未分解完毕
          If Instr(',5,6,7,', ',' || c_明细.类别 || ',') > 0 Then
            v_Err_Msg := '时价药品"' || c_明细.名称 || '"库存不足，无法计算价格！';
          Else
            v_Err_Msg := '时价卫生材料"' || c_明细.名称 || '"库存不足，无法计算价格！';
          End If;
          Raise Err_Item;
        End If;
      End If;
    
      c_Bill.Extend;
      c_Bill(c_Bill.Count).序号 := n_序号;
      c_Bill(c_Bill.Count).价格父号 := n_当前价格父号;
      c_Bill(c_Bill.Count).收费细目id := c_明细.收费细目id;
      c_Bill(c_Bill.Count).收费类别 := c_明细.类别;
      c_Bill(c_Bill.Count).计算单位 := c_明细.计算单位;
      c_Bill(c_Bill.Count).收入项目id := c_收费价目.收入项目id;
      c_Bill(c_Bill.Count).收据费目 := c_收费价目.收据费目;
      c_Bill(c_Bill.Count).数次 := c_明细.数次;
      c_Bill(c_Bill.Count).标准单价 := Round(n_价格, n_单价小数);
      c_Bill(c_Bill.Count).应收金额 := Round(c_Bill(c_Bill.Count).标准单价 * c_Bill(c_Bill.Count).数次, n_金额小数);
      If Nvl(c_明细.屏蔽费别, 0) = 1 Or c_Bill(c_Bill.Count).应收金额 = 0 Then
        c_Bill(c_Bill.Count).实收金额 := c_Bill(c_Bill.Count).应收金额;
      Else
        v_Temp := Zl_Actualmoney(v_费别, c_明细.收费细目id, c_收费价目.收入项目id, c_Bill(c_Bill.Count).应收金额, c_明细.数次, c_明细.执行科室id) || '::';
        v_Temp := Substr(v_Temp, Instr(v_Temp, ':') + 1);
        n_实收金额 := Substr(v_Temp, 1, Instr(v_Temp, ':') - 1);
        c_Bill(c_Bill.Count).实收金额 := Round(Nvl(n_实收金额, 0), n_金额小数);
      End If;
      c_Bill(c_Bill.Count).执行人 := c_明细.执行人;
      c_Bill(c_Bill.Count).执行部门id := c_明细.执行科室id;
      c_Bill(c_Bill.Count).费用摘要 := c_明细.摘要;
    
      n_序号 := n_序号 + 1;
    End Loop;
  End Loop;

  --单据号
  If (n_门诊标志 = 1 And n_记帐标志 = 1) Or n_门诊标志 = 2 Then
    v_No := Nextno(14);
  Elsif n_门诊标志 = 1 Or (n_门诊标志 = 3 And n_记帐标志 = 0) Then
    v_No := Nextno(13);
  End If;
  If n_门诊标志 = 3 Then
    v_卡费no := Nextno(16);
  End If;

  --保存单据
  d_登记时间 := Sysdate;
  For I In 1 .. c_Bill.Count Loop
    If n_门诊标志 = 1 Then
      If n_记帐标志 = 0 Then
        --门诊划价
        Zl_门诊划价记录_Insert(v_No, c_Bill(I).序号, n_病人id, n_主页id, n_标识号, v_付款方式编码, v_姓名, v_性别, v_年龄, v_费别, 0, n_科室id,
                         n_开单部门id, v_开单人, Null, c_Bill(I).收费细目id, c_Bill(I).收费类别, c_Bill(I).计算单位, Null, 1, c_Bill(I).数次,
                         0, c_Bill(I).执行部门id, c_Bill(I).价格父号, c_Bill(I).收入项目id, c_Bill(I).收据费目, c_Bill(I).标准单价,
                         c_Bill(I).应收金额, c_Bill(I).实收金额, d_操作时间, d_登记时间, Null, v_操作员姓名, c_Bill(I).费用摘要);
      
        If c_Bill(I).执行人 Is Not Null Then
          --标记为完全执行
          Update 门诊费用记录
          Set 执行状态 = 1, 执行人 = c_Bill(I).执行人, 执行时间 = Sysdate
          Where 记录性质 = 1 And NO = v_No And 序号 = c_Bill(I).序号;
        End If;
      Else
        --门诊记帐
        Zl_门诊记帐记录_Insert(v_No, c_Bill(I).序号, n_病人id, n_标识号, v_姓名, v_性别, v_年龄, v_费别, 0, 0, n_科室id, n_开单部门id, v_开单人, Null,
                         c_Bill(I).收费细目id, c_Bill(I).收费类别, c_Bill(I).计算单位, 1, c_Bill(I).数次, 0, c_Bill(I).执行部门id,
                         c_Bill(I).价格父号, c_Bill(I).收入项目id, c_Bill(I).收据费目, c_Bill(I).标准单价, c_Bill(I).应收金额,
                         c_Bill(I).实收金额, d_操作时间, d_登记时间, Null, 0, v_操作员编号, v_操作员姓名, Null, c_Bill(I).费用摘要);
      
        If c_Bill(I).执行人 Is Not Null Then
          --标记为完全执行
          Update 门诊费用记录
          Set 执行状态 = 1, 执行人 = c_Bill(I).执行人, 执行时间 = Sysdate
          Where 记录性质 = 2 And NO = v_No And 序号 = c_Bill(I).序号;
        End If;
      End If;
    Elsif n_门诊标志 = 2 Then
      --住院记帐
      Zl_住院记帐记录_Insert(v_No, c_Bill(I).序号, n_病人id, n_主页id, n_标识号, v_姓名, v_性别, v_年龄, v_床号, v_费别, n_病区id, n_科室id, 0, 0,
                       n_开单部门id, v_开单人, Null, c_Bill(I).收费细目id, c_Bill(I).收费类别, c_Bill(I).计算单位, 0, Null, Null, 1,
                       c_Bill(I).数次, 0, c_Bill(I).执行部门id, c_Bill(I).价格父号, c_Bill(I).收入项目id, c_Bill(I).收据费目,
                       c_Bill(I).标准单价, c_Bill(I).应收金额, c_Bill(I).实收金额, Null, d_操作时间, d_登记时间, Null, 0, v_操作员编号, v_操作员姓名,
                       0, Null, Null, c_Bill(I).费用摘要);
    
      If c_Bill(I).执行人 Is Not Null Then
        --标记为完全执行
        Update 住院费用记录
        Set 执行状态 = 1, 执行人 = c_Bill(I).执行人, 执行时间 = Sysdate
        Where 记录性质 = 2 And NO = v_No And 序号 = c_Bill(I).序号;
      End If;
    Elsif n_门诊标志 = 3 Then
      --就诊卡卡费
      If n_记帐标志 = 0 Then
        --就诊卡费保存为划价单时需要生成门诊划价记录，且住院费用记录的应收金额和实收金额均为0
        Zl_门诊划价记录_Insert(v_No, c_Bill(I).序号, n_病人id, n_主页id, n_标识号, v_付款方式编码, v_姓名, v_性别, v_年龄, v_费别, 0, n_科室id,
                         n_开单部门id, v_开单人, Null, c_Bill(I).收费细目id, c_Bill(I).收费类别, c_Bill(I).计算单位, Null, 1, c_Bill(I).数次,
                         0, c_Bill(I).执行部门id, c_Bill(I).价格父号, c_Bill(I).收入项目id, c_Bill(I).收据费目, c_Bill(I).标准单价,
                         c_Bill(I).应收金额, c_Bill(I).实收金额, d_操作时间, d_登记时间, Null, v_操作员姓名, c_Bill(I).费用摘要);
      
        c_Bill(I).应收金额 := 0;
        c_Bill(I).实收金额 := 0;
        c_Bill(I).费用摘要 := v_No;
      End If;
    
      Insert Into 住院费用记录
        (ID, 记录性质, 记录状态, NO, 序号, 价格父号, 病人id, 主页id, 病人科室id, 标识号, 姓名, 性别, 年龄, 费别, 记帐费用, 门诊标志, 加班标志, 开单部门id, 开单人, 操作员编号,
         操作员姓名, 发生时间, 登记时间, 收费细目id, 收费类别, 计算单位, 付数, 数次, 附加标志, 执行部门id, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 摘要)
      Values
        (病人费用记录_Id.Nextval, 5, 1, v_卡费no, c_Bill(I).序号, Decode(c_Bill(I).价格父号, 0, Null, c_Bill(I).价格父号), n_病人id, n_主页id,
         n_科室id, n_标识号, v_姓名, v_性别, v_年龄, v_费别, Decode(n_记帐标志, 0, 0, 1), 3, 0, n_开单部门id, v_开单人, v_操作员编号, v_操作员姓名, d_操作时间,
         d_登记时间, c_Bill(I).收费细目id, c_Bill(I).收费类别, c_Bill(I).计算单位, 1, c_Bill(I).数次, 0, c_Bill(I).执行部门id,
         c_Bill(I).收入项目id, c_Bill(I).收据费目, c_Bill(I).标准单价, c_Bill(I).应收金额, c_Bill(I).实收金额, c_Bill(I).费用摘要);
    
      If c_Bill(I).实收金额 <> 0 Then
        --汇总 病人余额
        Update 病人余额
        Set 费用余额 = Nvl(费用余额, 0) + c_Bill(I).实收金额
        Where 性质 = 1 And 病人id = n_病人id And Nvl(类型, 2) = Decode(Nvl(n_主页id, 0), 0, 1, 2)
        Returning 费用余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 病人余额
            (病人id, 性质, 类型, 预交余额, 费用余额)
          Values
            (n_病人id, 1, Decode(Nvl(n_主页id, 0), 0, 1, 2), 0, c_Bill(I).实收金额);
          n_返回值 := c_Bill(I).实收金额;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 病人余额 Where 性质 = 1 And 病人id = n_病人id And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
        End If;
      
        --汇总 病人未结费用
        Update 病人未结费用
        Set 金额 = Nvl(金额, 0) + c_Bill(I).实收金额
        Where 病人id = n_病人id And Nvl(主页id, 0) = Nvl(n_主页id, 0) And Nvl(病人病区id, 0) = Nvl(n_病区id, 0) And
              Nvl(病人科室id, 0) = Nvl(n_科室id, 0) And Nvl(开单部门id, 0) = Nvl(n_开单部门id, 0) And
              Nvl(执行部门id, 0) = Nvl(c_Bill(I).执行部门id, 0) And 收入项目id + 0 = c_Bill(I).收入项目id And 来源途径 = 3;
        If Sql%RowCount = 0 Then
          Insert Into 病人未结费用
            (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
          Values
            (n_病人id, n_主页id, n_病区id, n_科室id, n_开单部门id, c_Bill(I).执行部门id, c_Bill(I).收入项目id, 3, c_Bill(I).实收金额);
        End If;
      End If;
    End If;
  End Loop;

  Xml_Out := Xmltype('<OUTPUT><RESULT>true</RESULT></OUTPUT>');
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Saveexes;
/

--121460:蒋廷中,2018-2-13,医嘱保存检查增加传入收费细目id
Create Or Replace Function Zl_Advicecheck
(
  调用场合_In   Number,
  病人id_In     病人医嘱记录.病人id%Type,
  就诊id_In     病人挂号记录.Id%Type,
  险类_In       病人信息.险类%Type,
  医嘱期效_In   病人医嘱记录.医嘱期效%Type,
  诊疗类别_In   病人医嘱记录.诊疗类别%Type,
  诊疗项目id_In 病人医嘱记录.诊疗项目id%Type,
  开嘱科室id_In 病人医嘱记录.开嘱科室id%Type,
  开嘱医生_In   病人医嘱记录.开嘱医生%Type,
  执行科室id_In 病人医嘱记录.执行科室id%Type,
  执行性质_In   病人医嘱记录.执行性质%Type,
  执行标记_In   病人医嘱记录.执行标记%Type,
  单量_In       病人医嘱记录.单次用量%Type,
  摘要_In       病人医嘱记录.摘要%Type,
  收费细目id_In 病人医嘱记录.收费细目id%Type := 0
) Return Varchar2
--功能:门诊和住院医嘱新开和修改时，保存数据之前对医嘱的相关内容进行检查，并返回提示及处理结果。
  --参数：
  --调用场合_in=1-门诊,2-住院
  --就诊id_In=门诊时传挂号记录id,住院时传入主页id
  --医嘱期效_In=0-长期;1-临时
  --执行性质_in=0-无执行的叮嘱；1-病人所在科室；2-病人所在病区；3-开单人所在科室；4-指定科室;5-院外执行；药品医嘱界面表现为正常、外购药、出院带药。 
  --执行标记_in=-1表示未用医嘱；对检查:0-常规,1-床旁,2-术中；对药品，根据医嘱录入为：0-常规,1-自取药；
  --开嘱医生_in=如果是实习医生开嘱后经审核的医嘱,填写为"审核医生/实习医生"形式。
  --摘要_In=调用医保GetItemInfo返回的信息||给药途径执行性质(没有时为0)||麻醉诊疗项目ID(没有时为0)||部位1:方法1,部位1:方法2,部位2:方法1...(没有时为一个空格)
  --     执行性质_in<>5 And 给药途径执行性质=5时表示院外执行；执行性质_in=5 And 给药途径执行性质<>5时表示自备药 || 收费细目ID（如果诊疗类别是药品类5，6，7，则对应的是药品ID）
  --返回："处理结果|提示信息",处理结果=0-正常,1-询问提示,2-禁止；处理结果为0时，无需返回提示信息及分隔符。
 As
  v_Return Varchar2(200);
Begin
  v_Return := Null;
  Return v_Return;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Advicecheck;
/






--122111:陈刘,2018-2-12,获取一定范围的护理记录数据
Create Or Replace Procedure Zl_Third_Tendfile_GetTempHData
(
  Xmlfilelist_In  Xmltype,
  Xmlfilelist_Out Out Xmltype
) Is
  ---------------------------------------------------------------------------------------------------------------------------
  --功能:获取某病人指定范围内的体温单历史数据
  --入参:Xml_In
  --<IN>
  --<BQ></BQ>       --病区ID
  --<PATIID></PATIID>     --病人ID
  --<PAGEID></PAGEID>     --主页ID
  --<BABY></BABY>      --婴儿
  -- <FW></FW>   --范围：当天、三天、 一周
  --</IN>
  -- 出参:Xml_Out
  --<OUTPUT>
  -- <GROUPS>
  --  <GROUP>
  --   <SJ></SJ>   --发生时间
  --   <CZY></CZY>  --操作员
  --   <ITEMS>
  --    <ITEM>
  --     <XH></XH>   --序号
  --     <MC></MC>   --名称
  --     <NR></NR>   --内容
  --     <WJ />     --未记说明
  --     <BW />     --部位
  --    </ITEM>
  --   </ITEMS>
  --  </GROUP>
  -- </GROUPS>
  --</OUTPUT>
  ----------------------------------------------------------------------------------------------------------------------------
  n_Patiid   Number(18);
  n_Pageid   Number(18);
  n_Baby     Number(18);
  n_Areaid   Number(18);
  n_Fw       Number(18);
  d_开始时间 Date;
  d_结束时间 Date;
  v_Temp     Varchar2(32767);
  x_Templet  Xmltype; --模板XML
Begin
  Select To_Number(Extractvalue(Value(A), 'IN/BQ'))
  Into n_Areaid
  From Table(Xmlsequence(Extract(Xmlfilelist_In, 'IN'))) A;

  Select To_Number(Extractvalue(Value(A), 'IN/PATIID'))
  Into n_Patiid
  From Table(Xmlsequence(Extract(Xmlfilelist_In, 'IN'))) A;

  Select To_Number(Extractvalue(Value(A), 'IN/PAGEID'))
  Into n_Pageid
  From Table(Xmlsequence(Extract(Xmlfilelist_In, 'IN'))) A;

  Select To_Number(Extractvalue(Value(A), 'IN/BABY'))
  Into n_Baby
  From Table(Xmlsequence(Extract(Xmlfilelist_In, 'IN'))) A;

  Select To_Number(Extractvalue(Value(A), 'IN/FW'))
  Into n_Fw
  From Table(Xmlsequence(Extract(Xmlfilelist_In, 'IN'))) A;
  d_结束时间 := Sysdate;
  d_开始时间 := d_结束时间 - n_Fw;

  x_Templet := Xmltype('<OUTPUT><GROUPS></GROUPS></OUTPUT>');
  For r_File In (Select a.Id
                 From 病人护理文件 A, 病历文件列表 B
                 Where 病人id = n_Patiid And 主页id = n_Pageid And 婴儿 = n_Baby And a.格式id = b.Id And 保留 = -1 And
                       a.开始时间 < d_开始时间 And (a.结束时间 > d_结束时间 Or a.结束时间 Is Null)) Loop
    For r_Twd In (Select ID, to_char(发生时间,'yyyy-mm-dd hh24:mi:ss') 发生时间, 保存人
                  From 病人护理数据
                  Where 文件id = r_File.Id And 发生时间 Between d_开始时间 And d_结束时间
                  Order By 发生时间 Desc) Loop
      v_Temp := '<GROUP><SJ>' || r_Twd.发生时间 || '</SJ><CZY>' || r_Twd.保存人 || '</CZY><ITEMS></ITEMS></GROUP>';
      Select Appendchildxml(x_Templet, '/OUTPUT/GROUPS', Xmltype(v_Temp)) Into x_Templet From Dual;
      For r_Nr In (Select 项目序号, 项目名称, 记录内容, 未记说明, 体温部位 From 病人护理明细 Where 记录id = r_Twd.Id) Loop
        v_Temp := '<ITEM><XH>' || r_Nr.项目序号 || '</XH><MC>' || r_Nr.项目名称 || '</MC><NR>' || r_Nr.记录内容 || '</NR><WJ>' ||
                  r_Nr.未记说明 || '</WJ><BW>' || r_Nr.体温部位 || '</BW></ITEM>';
        Select Appendchildxml(x_Templet, '/OUTPUT/GROUPS/GROUP/ITEMS', Xmltype(v_Temp)) Into x_Templet From Dual;
      End Loop;
    End Loop;
  End Loop;

  Xmlfilelist_Out := x_Templet;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Tendfile_GetTempHData;
/

--122111:陈刘,2018-2-12,获取所有活动项目
Create Or Replace Procedure Zl_Third_Tendfile_GetMItems
(
  Xmlfilelist_In  Xmltype,
  Xmlfilelist_Out Out Xmltype
) Is
  ---------------------------------------------------------------------------------------------------------------------------
  --功能:获取体温单/护理记录单中的可用活动项目
  --入参:Xml_In
  --无
  -- 出参:Xml_Out
  --<OUTPUT>
  -- <ITEMLIST>
  --  <ITEM>
  --    <XH/>      --序号
  --    <MC/>      --名称
  --    <LX/>      --项目类型
  --    <BS/>      --项目表示
  --    <CD/>      --项目长度
  --    <XS/>      --项目小数
  --    <DW/>     --项目单位
  --    <ZY/>      --项目值域
  --    <SYBR/>      --适用病人
  --    <YYFS/>      --应用方式
  --    <BW/>       --活动项目部位
  --  <ITEM/>
  -- </ITEMLIST>
  --</OUTPUT>
  ----------------------------------------------------------------------------------------------------------------------------
  v_Temp    Varchar2(32767);
  v_Bw      Varchar2(100);
  x_Templet Xmltype; --模板XML
Begin

  x_Templet := Xmltype('<OUTPUT><ITEMLIST></ITEMLIST></OUTPUT>');

  For r_Hdxm In (Select a.项目序号, a.项目名称, a.项目类型, a.项目表示, a.项目长度, a.项目小数, a.项目单位, a.项目值域, a.适用病人, a.应用方式
                 From 护理记录项目 A
                 Where a.项目性质 = 2 And Nvl(a.应用场合, 0) <> 1) Loop
    Select f_List2str(Cast(Collect(部位) As t_Strlist)) Into v_Bw From 体温部位 Where 项目序号 = r_Hdxm.项目序号;
  
    v_Temp := '<ITEM><XH>' || r_Hdxm.项目序号 || '</XH><MC>' || r_Hdxm.项目名称 || '</MC><LX>' || r_Hdxm.项目类型 || '</LX><BS>' ||
              r_Hdxm.项目表示 || '</BS><CD>' || r_Hdxm.项目长度 || '</CD><XS>' || r_Hdxm.项目小数 || '</XS><DW>' || r_Hdxm.项目单位 ||
              '</DW><ZY>' || r_Hdxm.项目值域 || '</ZY><SYBR>' || r_Hdxm.适用病人 || '</SYBR><YYFS>' || r_Hdxm.项目表示 ||
              '</YYFS><BW>' || v_Bw || '</BW></ITEM>';
    Select Appendchildxml(x_Templet, '/OUTPUT/ITEMLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
  End Loop;

  Xmlfilelist_Out := x_Templet;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Tendfile_GetMItems;
/

--122111:陈刘,2018-2-12,绑定活动项目
Create Or Replace Procedure Zl_Third_Tendfile_BindMItems
(
  Xmlfilelist_In  Xmltype,
  Xmlfilelist_Out Out Xmltype
) Is
  ---------------------------------------------------------------------------------------------------------------------------
  --功能:绑定活动项目
  --入参:Xml_In
  --<IN>
  -- <FILE></ FILE >      --护理文件ID
  -- <YH></YH>            --页号
  -- <LH></LH>            --列号
  -- <MC></MC>            --名称
  -- <XH></XH >           --序号
  -- <CZY></CZY>          --操作员
  --</IN>
  --出参:Xml_Out
  --成功：
  --<OUTPUT>
  -- <RESULT>true</RESULT>
  --</OUTPUT>
  --失败：
  --<OUTPUT>
  -- <RESULT>false</RESULT>
  -- <ERROR>
  --   <MSG>详细错误提示</MSG>
  -- </ERROR>
  --</OUTPUT>
  ----------------------------------------------------------------------------------------------------------------------------
  n_Fileid  Number(18);
  n_Yh      Number(18);
  n_Lh      Number(18);
  n_Xh      Number(18);
  v_Mc      Varchar2(4000);
  v_Czy     Varchar2(20);
  v_Temp    Varchar2(32767);
  x_Templet Xmltype; --模板XML
Begin
  Select To_Number(Extractvalue(Value(A), 'IN/FILE'))
  Into n_Fileid
  From Table(Xmlsequence(Extract(Xmlfilelist_In, 'IN'))) A;

  Select To_Number(Extractvalue(Value(A), 'IN/YH'))
  Into n_Yh
  From Table(Xmlsequence(Extract(Xmlfilelist_In, 'IN'))) A;

  Select To_Char(Extractvalue(Value(A), 'IN/LH'))
  Into n_Lh
  From Table(Xmlsequence(Extract(Xmlfilelist_In, 'IN'))) A;

  Select To_Char(Extractvalue(Value(A), 'IN/XH'))
  Into n_Xh
  From Table(Xmlsequence(Extract(Xmlfilelist_In, 'IN'))) A;

  Select To_Char(Extractvalue(Value(A), 'IN/MC'))
  Into v_Mc
  From Table(Xmlsequence(Extract(Xmlfilelist_In, 'IN'))) A;

  Select To_Char(Extractvalue(Value(A), 'IN/CZY'))
  Into v_Czy
  From Table(Xmlsequence(Extract(Xmlfilelist_In, 'IN'))) A;

  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Zl_病人护理页面_Update(n_Fileid, n_Yh, n_Lh, v_Mc||'|'||n_Xh, v_Czy);
  v_Temp := '<RESULT>Ture</RESULT>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Xmlfilelist_Out := x_Templet;
Exception
  When Others Then
    v_Temp := '<RESULT>False</RESULT>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    v_Temp := '<ERROR><MSG>' || SQLErrM || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Xmlfilelist_Out := x_Templet;
End Zl_Third_Tendfile_BindMItems;
/

--122111:陈刘,2018-2-12,获取一定数量的护理文件数据
Create Or Replace Procedure Zl_Third_Tendfile_Getdetail
(
  Xmlfilelist_In  Xmltype,
  Xmlfilelist_Out Out Xmltype
) Is
  ---------------------------------------------------------------------------------------------------------------------------
  --功能:获取指定的护理记录单中，某一个护理项目最近若干次的记录内容，按时间由近到远排序
  --入参:Xml_In
  --<IN>
  -- <FILE></FILE>       --文件id
  -- <XH></XH>   --项目序号
  -- <FW></FW>   --范围数值，传3，表示最近3次
  --</IN>
  --出参:Xml_Out
  --<OUTPUT>
  -- <LISTS>
  --  <ITEM>
  --   <TIME></TIME>   --发生时间
  --   <DATA></DATA>   --内容
  --  </ITEM>
  -- </LISTS>
  --</OUTPUT>
  ----------------------------------------------------------------------------------------------------------------------------
  n_Fileid  Number(18);
  n_Xh      Number(18);
  n_Fw      Number(18);
  v_Temp    Varchar2(32767);
  x_Templet Xmltype; --模板XML
Begin
  Select To_Number(Extractvalue(Value(A), 'IN/FILE'))
  Into n_Fileid
  From Table(Xmlsequence(Extract(Xmlfilelist_In, 'IN'))) A;
  Select To_Number(Extractvalue(Value(A), 'IN/XH'))
  Into n_Xh
  From Table(Xmlsequence(Extract(Xmlfilelist_In, 'IN'))) A;
  Select To_Number(Extractvalue(Value(A), 'IN/FW'))
  Into n_Fw
  From Table(Xmlsequence(Extract(Xmlfilelist_In, 'IN'))) A;

  x_Templet := Xmltype('<OUTPUT><LISTS></LISTS></OUTPUT>');
  For r_Hljl In (Select to_char(时间, 'YYYY-MM-DD hh24:mi:ss') 时间, 内容
                 From (Select b.发生时间 时间, Decode(c.记录内容, Null, c.未记说明, c.记录内容) 内容,
                               Row_Number() Over(Partition By b.文件id Order By b.发生时间 Desc) As Top
                        From 病人护理数据 B, 病人护理明细 C
                        Where b.Id = c.记录id And 项目序号 = n_Xh And 文件id = n_Fileid And 记录类型 = 1)
                 Where Top <= n_Fw) Loop
    v_Temp := '<ITEM><TIME>' || r_Hljl.时间 || '</TIME><DATA>' || r_Hljl.内容 || '</DATA></ITEM>';
    Select Appendchildxml(x_Templet, '/OUTPUT/LISTS', Xmltype(v_Temp)) Into x_Templet From Dual;
  End Loop;
  Xmlfilelist_Out := x_Templet;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Tendfile_Getdetail;
/

--122111:陈刘,2018-2-12,保存记录单/体温单数据
Create Or Replace Procedure Zl_Third_Tendfile_Save
(
  Xmlfilelist_In  Xmltype,
  Xmlfilelist_Out Out Xmltype
) Is
  ---------------------------------------------------------------------------------------------------------------------------
  --功能:体温单/护理记录单填写的数据保存
  --入参:Xml_In
  --<IN>
  -- <FILELIST>
  --  <FILEINFO>
  --   <CZY></CZY>   --操作员
  --   <CZSJ></CZSJ>   --操作时间
  --   <FILE></FILE>       --文件ID
  --   <LX/>         --0-新增;1-修改或删除
  --   <FZ></FZ>          --分组标志，未分组传0
  --   <LY></LY>   --来源，3，表示移动端？
  --   <ITEMLIST>
  --    <ITEM>
  --     <TIME></TIME>   --发生时间
  --     <XH></XH>   --项目序号
  --     <MC></MC>   --项目名称
  --     <NR></NR>   --项目内容
  --     <BW></BW>   --部位，如果有就传
  --     <WJ></WJ>   --未记说明，如果有就传
  --    </ITEM>
  --   </ITEMLIST>
  --  </FILEINFO>
  -- </FILELIST>
  --</IN>
  --出参:Xml_Out
  --成功：
  --<OUTPUT>
  -- <RESULT>true</RESULT>
  --</OUTPUT>
  --失败：
  --<OUTPUT>
  -- <RESULT>false</RESULT>
  -- <ERROR>
  --   <MSG>详细错误提示</MSG>
  -- </ERROR>
  --</OUTPUT>
  ----------------------------------------------------------------------------------------------------------------------------
  n_Fileid  Number(18);
  v_Czy     Varchar2(20);
  d_Czsj    Date;
  n_Newadd  Number(1);
  n_Fz      Number(1);
  n_Ly      Number(2);
  n_Kind    Number(1);
  n_Exist   Number(1);
  v_Temp    Varchar2(32767);
  x_Templet Xmltype; --模板XML
Begin
  n_Exist := 0;

  Select To_Number(Extractvalue(Value(A), 'IN/FILELIST/FILEINFO/FILE'))
  Into n_Fileid
  From Table(Xmlsequence(Extract(Xmlfilelist_In, 'IN'))) A;

  Select To_Char(Extractvalue(Value(A), 'IN/FILELIST/FILEINFO/CZY'))
  Into v_Czy
  From Table(Xmlsequence(Extract(Xmlfilelist_In, 'IN'))) A;

  Select To_Date(Extractvalue(Value(A), 'IN/FILELIST/FILEINFO/CZSJ'), 'yyyy-MM-dd hh24:mi:ss')
  Into d_Czsj
  From Table(Xmlsequence(Extract(Xmlfilelist_In, 'IN'))) A;

  Select To_Number(Extractvalue(Value(A), 'IN/FILELIST/FILEINFO/LX'))
  Into n_Newadd
  From Table(Xmlsequence(Extract(Xmlfilelist_In, 'IN'))) A;

  Select To_Number(Extractvalue(Value(A), 'IN/FILELIST/FILEINFO/FZ'))
  Into n_Fz
  From Table(Xmlsequence(Extract(Xmlfilelist_In, 'IN'))) A;

  Select To_Number(Extractvalue(Value(A), 'IN/FILELIST/FILEINFO/LY'))
  Into n_Ly
  From Table(Xmlsequence(Extract(Xmlfilelist_In, 'IN'))) A;

  For r_Input In (Select 发生时间, Xh, Mc, Nr, Bw, Wj
                  From Xmltable('$a/IN/FILELIST/FILEINFO/ITEMLIST/ITEM' Passing Xmlfilelist_In As "a" Columns 发生时间
                                 Varchar2(20) Path 'TIME', Xh Number(18) Path 'XH', Mc Varchar2(20) Path 'MC',
                                 Nr Varchar2(20) Path 'NR', Bw Varchar2(10) Path 'BW', Wj Varchar2(4000) Path 'Wj') B) Loop
    x_Templet := Xmltype('<OUTPUT></OUTPUT>');
    Select Max(种类) Into n_Kind From 病历文件列表 A, 病人护理文件 B Where a.Id = b.格式id And b.Id = n_Fileid;
    If n_Newadd = 0 Then
      Select Max(1)
      Into n_Exist
      From 病人护理文件 A, 病人护理数据 B, 病人护理明细 C
      Where a.Id = b.文件id And b.Id = c.记录id And a.Id = n_Fileid And
            b.发生时间 = To_Date(r_Input.发生时间, 'yyyy-mm-dd hh24:mi:ss') And c.项目序号 = r_Input.Xh;
    End If;
    If n_Newadd = 0 And n_Exist = 1 Then
      v_Temp := '<RESULT>False</RESULT>';
      Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
      v_Temp := '<ERROR><MSG>您录入的时点已经存在历史数据！</MSG></ERROR>';
      Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
      Xmlfilelist_Out := x_Templet;
    Else
      If n_Kind = 1 Then
        Zl_病人护理数据_Update(n_Fileid, To_Date(r_Input.发生时间, 'yyyy-mm-dd hh24:mi:ss'), 1, r_Input.Xh, r_Input.Nr,
                         r_Input.Bw, 1, n_Ly, 0, v_Czy, n_Fz, Null, r_Input.Wj);
      Else
        Zl_体温单数据_Update(n_Fileid, To_Date(r_Input.发生时间, 'yyyy-mm-dd hh24:mi:ss'), 1, r_Input.Xh, r_Input.Nr, r_Input.Bw,
                        0, r_Input.Wj, 1, n_Ly);
      End If;
      v_Temp := '<RESULT>True</RESULT>';
      Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
      Xmlfilelist_Out := x_Templet;
    End If;
  End Loop;
Exception
  When Others Then
    v_Temp := '<RESULT>False</RESULT>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    v_Temp := '<ERROR><MSG>' || SQLErrM || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Xmlfilelist_Out := x_Templet;
End Zl_Third_Tendfile_Save;
/

--122111:陈刘,2018-2-12,获取记录单体温单项目
CREATE OR REPLACE Procedure Zl_Third_Tendfile_Getitems
(
  Xmlfilelist_In  Xmltype,
  Xmlfilelist_Out Out Xmltype
) Is
  ---------------------------------------------------------------------------------------------------------------------------
  --功能:获取可填写的护理项目（含活动项目及空项目）
  --入参:Xml_In
  --<IN>
  -- <BQ></BQ>       --病区ID
  -- <PATIID></PATIID>     --病人ID
  -- <PAGEID></PAGEID>     --主页ID
  -- <BABY></BABY>      --婴儿
  -- <FILE></FILE>   --传空表示获取在用体温单项目，否则获取id对应的护理记录单项目
  --</IN>
  --出参:Xml_Out
  --<OUTPUT />
  -- <YH></YH>      --页号，用于绑定活动项目
  -- <FILE></FILE>   --文件id
  -- <ITEMLIST>
  --  <ITEM>
  --   <LH></LH>     --列号，用于绑定活动项目
  --   <XH></XH>     --项目序号
  --   <MC></MC>     --项目名称
  --   <LX></LX>     --项目类型0数值1-文本
  --   <BS></BS>     --项目表示
  --   <CD></CD>     --项目长度
  --   <XS></XS>     --项目小数
  --   <DW</DW>      --单位
  --   <ZY></ZY>     --值域
  --   <SYBR></SYBR>    --适用病人0所有1病人本人2婴儿
  --   <YYFS></YYFS>    --应用方式0禁止使用1单独使用2与脉搏共用
  --   <BW></BW>   --部位
  --   <XMXZ></XMXZ>  --项目性质1-普通2-活动项目,表示该项目为预留的活动项目位置
  --  </ITEM>
  -- </ITEMLIST>
  --<OUTPUT/>
  ----------------------------------------------------------------------------------------------------------------------------
  n_Patiid  Number(18);
  n_Pageid  Number(18);
  n_Baby    Number(18);
  n_Areaid  Number(18);
  n_Fileid  Number(18);
  n_Format  Number(18);
  n_Yh      Number(18);
  v_Nnit    Varchar2(100);
  v_Hdlh    Varchar2(40);
  v_Temp    Varchar2(32767);
  v_Temp2   Varchar2(32767);
  x_Templet Xmltype; --模板XML
Begin
  Select To_Number(Extractvalue(Value(A), 'IN/BQ'))
  Into n_Areaid
  From Table(Xmlsequence(Extract(Xmlfilelist_In, 'IN'))) A;

  Select To_Number(Extractvalue(Value(A), 'IN/PATIID'))
  Into n_Patiid
  From Table(Xmlsequence(Extract(Xmlfilelist_In, 'IN'))) A;

  Select To_Number(Extractvalue(Value(A), 'IN/PAGEID'))
  Into n_Pageid
  From Table(Xmlsequence(Extract(Xmlfilelist_In, 'IN'))) A;

  Select To_Number(Extractvalue(Value(A), 'IN/BABY'))
  Into n_Baby
  From Table(Xmlsequence(Extract(Xmlfilelist_In, 'IN'))) A;

  Select To_Number(Extractvalue(Value(A), 'IN/FILE'))
  Into n_Fileid
  From Table(Xmlsequence(Extract(Xmlfilelist_In, 'IN'))) A;

  x_Templet := Xmltype('<OUTPUT><ITEMLIST></ITEMLIST></OUTPUT>');
  If Nvl(n_Fileid, 0) = 0 Then
    Select a.格式id
    Into n_Format
    From 病人护理文件 A, 病历文件列表 B
    Where a.格式id = b.Id And b.种类 = 3 And b.保留 = -1 And a.病人id = n_Patiid And a.主页id = n_Pageid And a.婴儿 = n_Baby And
          a.结束时间 Is Null;
    If n_Format = 30 Then
      For r_Twd In (Select b.项目序号, b.项目名称, b.项目类型, b.项目表示, b.项目长度, b.项目小数, b.项目单位, b.项目值域, b.适用病人, b.应用方式, b.项目性质
                    From 体温记录项目 F, 护理记录项目 B
                    Where f.项目序号 = b.项目序号) Loop
        Select f_List2str(Cast(Collect(部位) As t_Strlist)) Into v_Nnit From 体温部位 Where 项目序号 = r_Twd.项目序号;
        v_Temp2 := '<ITEM><XH>' || r_Twd.项目序号 || '</XH><MC>' || r_Twd.项目名称 || '</MC><LX>' || r_Twd.项目类型 || '</LX><BS>' ||
                   r_Twd.项目表示 || '</BS><CD>' || r_Twd.项目长度 || '</CD><XS>' || r_Twd.项目小数 || '</XS><DW>' || r_Twd.项目单位 ||
                   '</DW><ZY>' || r_Twd.项目值域 || '</ZY><SYBR>' || r_Twd.适用病人 || '</SYBR><YYFS>' || r_Twd.应用方式 ||
                   '</YYFS><BW>' || v_Nnit || '</BW><XMXZ>' || r_Twd.项目性质 || '</XMXZ></ITEM>';
        Select Appendchildxml(x_Templet, '/OUTPUT/ITEMLIST', Xmltype(v_Temp2)) Into x_Templet From Dual;
      End Loop;
    Else
      For r_Twd In (Select d.对象序号 列号, b.项目序号, b.项目名称, b.项目类型, b.项目表示, b.项目长度, b.项目小数, b.项目单位, b.项目值域, b.适用病人, b.应用方式,
                           b.项目性质
                    From 病历文件结构 C, 病历文件结构 D, 护理记录项目 B
                    Where c.文件id = n_Format And c.父id Is Null And c.对象序号 In (2, 3) And d.父id = c.Id And b.项目名称 = d.要素名称) Loop
        Select f_List2str(Cast(Collect(部位) As t_Strlist)) Into v_Nnit From 体温部位 Where 项目序号 = r_Twd.项目序号;
        v_Temp2 := '<ITEM><XH>' || r_Twd.项目序号 || '</XH><MC>' || r_Twd.项目名称 || '</MC><LX>' || r_Twd.项目类型 || '</LX><BS>' ||
                   r_Twd.项目表示 || '</BS><CD>' || r_Twd.项目长度 || '</CD><XS>' || r_Twd.项目小数 || '</XS><DW>' || r_Twd.项目单位 ||
                   '</DW><ZY>' || r_Twd.项目值域 || '</ZY><SYBR>' || r_Twd.适用病人 || '</SYBR><YYFS>' || r_Twd.应用方式 ||
                   '</YYFS><BW>' || v_Nnit || '</BW><XMXZ>' || r_Twd.项目性质 || '</XMXZ></ITEM>';
        Select Appendchildxml(x_Templet, '/OUTPUT/ITEMLIST', Xmltype(v_Temp2)) Into x_Templet From Dual;
      End Loop;

    End If;
  Else
    Select Max(结束页号) Into n_Yh From 病人护理打印 Where 文件id = n_Fileid;
    v_Temp := '<YH>' || n_Yh || '</YH>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    v_Temp := ' <FILE>' || n_Fileid || '</FILE>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    For r_Jld In (Select a.页号, a.文件id, a.列号, b.项目序号, b.项目名称, b.项目类型, b.项目表示, b.项目长度, b.项目小数, b.项目单位, b.项目值域, b.适用病人,
                         b.应用方式, b.项目性质
                  From 病人护理活动项目 A, 护理记录项目 B
                  Where b.项目序号 = a.项目序号 And b.项目序号 = a.项目序号 And a.文件id = n_Fileid And a.页号 = n_Yh) Loop

      v_Temp2 := '<ITEM><LH>' || r_Jld.列号 || '</LH><XH>' || r_Jld.项目序号 || '</XH><MC>' || r_Jld.项目名称 || '</MC><LX>' ||
                 r_Jld.项目类型 || '</LX><BS>' || r_Jld.项目表示 || '</BS><CD>' || r_Jld.项目长度 || '</CD><XS>' || r_Jld.项目小数 ||
                 '</XS><DW>' || r_Jld.项目单位 || '</DW><ZY>' || r_Jld.项目值域 || '</ZY><SYBR>' || r_Jld.适用病人 ||
                 '</SYBR><YYFS>' || r_Jld.应用方式 || '</YYFS><BW>' || v_Nnit || '</BW><XMXZ>' || r_Jld.项目性质 ||
                 '</XMXZ></ITEM>';
      Select Appendchildxml(x_Templet, '/OUTPUT/ITEMLIST', Xmltype(v_Temp2)) Into x_Templet From Dual;
      v_Hdlh := v_Hdlh || ',' || r_Jld.列号;
    End Loop;

    --记录单已绑定的项目
    For r_Jldb In (Select d.对象序号 列号, b.项目序号, b.项目名称, b.项目类型, b.项目表示, b.项目长度, b.项目小数, b.项目单位, b.项目值域, b.适用病人, b.应用方式,
                          b.项目性质
                   From 护理记录项目 B, 病历文件结构 C, 病历文件结构 D, 病人护理文件 E
                   Where c.文件id = e.格式id And e.Id = n_Fileid And c.内容文本 = '表列集合' And d.父id = c.Id And b.项目名称(+) = d.要素名称) Loop
      Select f_List2str(Cast(Collect(部位) As t_Strlist)) Into v_Nnit From 体温部位 Where 项目序号 = r_Jldb.项目序号;
      If Not Instr(v_Hdlh || ',', ',' || r_Jldb.列号 || ',') > 0 Then
        v_Temp2 := '<ITEM><LH>' || r_Jldb.列号 || '</LH><XH>' || r_Jldb.项目序号 || '</XH><MC>' || r_Jldb.项目名称 || '</MC><LX>' ||
                   r_Jldb.项目类型 || '</LX><BS>' || r_Jldb.项目表示 || '</BS><CD>' || r_Jldb.项目长度 || '</CD><XS>' ||
                   r_Jldb.项目小数 || '</XS><DW>' || r_Jldb.项目单位 || '</DW><ZY>' || r_Jldb.项目值域 || '</ZY><SYBR>' ||
                   r_Jldb.适用病人 || '</SYBR><YYFS>' || r_Jldb.应用方式 || '</YYFS><BW>' || v_Nnit || '</BW><XMXZ>' ||
                   r_Jldb.项目性质 || '</XMXZ></ITEM>';
        Select Appendchildxml(x_Templet, '/OUTPUT/ITEMLIST', Xmltype(v_Temp2)) Into x_Templet From Dual;
      End If;
    End Loop;

  End If;
  Xmlfilelist_Out := x_Templet;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Tendfile_Getitems;
/

--122111:陈刘,2018-2-12,添加护理文件
CREATE OR REPLACE Procedure Zl_Third_Tendfile_Add
(
  Xmlfilelist_In  Xmltype,
  Xmlfilelist_Out Out Xmltype
) Is
  ---------------------------------------------------------------------------------------------------------------------------
  --功能:创建护理记录单
  --入参:Xml_In
  --<IN>
  -- <BQ></BQ>        --病区ID
  -- <PATIID></PATIID>      --病人ID
  -- <PAGEID></PAGEID>      --主页ID
  -- <BABY></BABY>       --婴儿
  -- <FORMAT></ FORMAT >    --护理文件格式ID
  -- <CZY></CZY>   --操作员
  -- <CZSJ></CZSJ>   --操作时间
  --</IN>
  --出参:Xml_Out
  --成功：
  --<OUTPUT>
  -- <RESULT>true</RESULT>
  -- <DATA><FILE>文件ID</FILE></DATA>   --创建成功，返回生成的文件id
  --</OUTPUT>
  --失败：
  --<OUTPUT>
  -- <RESULT>false</RESULT>
  -- <ERROR>
  --  <MSG>详细错误提示</MSG>
  -- </ERROR>
  --</OUTPUT>
  ----------------------------------------------------------------------------------------------------------------------------
  n_Patiid   Number(18);
  n_Pageid   Number(18);
  n_Baby     Number(18);
  n_Areaid   Number(18);
  n_Format   Number(18);
  v_Czy      Varchar2(20);
  d_Czsj     Date;
  v_Deptname Varchar2(100);
  v_Filename Varchar2(20);
  n_Fileid   Number(18);
  v_Temp     Varchar2(32767);
  x_Templet  Xmltype; --模板XML
Begin
  Select To_Number(Extractvalue(Value(A), 'IN/BQ'))
  Into n_Areaid
  From Table(Xmlsequence(Extract(Xmlfilelist_In, 'IN'))) A;

  Select To_Number(Extractvalue(Value(A), 'IN/PATIID'))
  Into n_Patiid
  From Table(Xmlsequence(Extract(Xmlfilelist_In, 'IN'))) A;

  Select To_Number(Extractvalue(Value(A), 'IN/PAGEID'))
  Into n_Pageid
  From Table(Xmlsequence(Extract(Xmlfilelist_In, 'IN'))) A;

  Select To_Number(Extractvalue(Value(A), 'IN/BABY'))
  Into n_Baby
  From Table(Xmlsequence(Extract(Xmlfilelist_In, 'IN'))) A;

  Select To_Number(Extractvalue(Value(A), 'IN/FORMAT'))
  Into n_Format
  From Table(Xmlsequence(Extract(Xmlfilelist_In, 'IN'))) A;

  Select To_Char(Extractvalue(Value(A), 'IN/CZY'))
  Into v_Czy
  From Table(Xmlsequence(Extract(Xmlfilelist_In, 'IN'))) A;

  Select To_Date(Extractvalue(Value(A), 'IN/CZSJ'), 'yyyy-MM-dd hh24:mi:ss')
  Into d_Czsj
  From Table(Xmlsequence(Extract(Xmlfilelist_In, 'IN'))) A;

  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select b.名称
  Into v_Deptname
  From 病案主页 A, 部门表 B
  Where a.病人id = n_Patiid And a.主页id = n_Pageid And a.出院科室id = b.Id(+);

  Select 名称 Into v_Filename From 病历文件列表 Where 种类 = 3 And ID = n_Format;
  
  Select 病人护理文件_Id.Nextval Into n_Fileid From Dual;
  Zl_病人护理文件_Update(n_Fileid, n_Areaid, n_Patiid, n_Pageid, n_Baby, n_Format, '[' || v_Deptname || ']' || v_Filename,
                   d_Czsj, 0, v_Czy);
  v_Temp := '<RESULT>True</RESULT>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  v_Temp := '<DATA><FILE>' || n_Fileid || '</FILE></DATA>';

  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Xmlfilelist_Out := x_Templet;
Exception
  When Others Then
    v_Temp := '<RESULT>False</RESULT>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    v_Temp := '<ERROR><MSG>' || SQLErrM || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Xmlfilelist_Out := x_Templet;
End Zl_Third_Tendfile_Add;
/

--122111:陈刘,2018-2-12,获取所有护理文件,包括可以创建的
CREATE OR REPLACE Procedure Zl_Third_TendFile_Getall
(
  Xmlfilelist_In  Xmltype,
  Xmlfilelist_Out Out Xmltype
) Is
  ---------------------------------------------------------------------------------------------------------------------------
  --功能:获取所选病人当前已创建的护理记录单和可创建的护理记录单列表
  --入参:Xml_In
  --<IN>
  -- <BQ></BQ>        --病区ID
  -- <PATIID></PATIID>      --病人ID
  -- <PAGEID></PAGEID>      --主页ID
  -- <BABY></BABY>       --婴儿
  --</IN>
  --出参:Xml_Out
  --<OUTPUT>
  -- <ITEMLIST>
  --  <ITEM>
  --   <ID></ID>   --已创建的为文件ID，未创建的为格式ID
  --   <MC></MC>
  --   <TYPE></TYPE>   --0表示未创建，1表示已创建
  --  </ITEM>
  -- </ITEMLIST>
  --<OUTPUT/>
  ----------------------------------------------------------------------------------------------------------------------------
  n_Patiid  Number(18);
  n_Pageid  Number(18);
  n_Baby    Number(18);
  n_Areaid  Number(18);
  v_Temp    Varchar2(32767);
  x_Templet Xmltype; --模板XML
Begin
  Select To_Number(Extractvalue(Value(A), 'IN/BQ'))
  Into n_Areaid
  From Table(Xmlsequence(Extract(Xmlfilelist_In, 'IN'))) A;

  Select To_Number(Extractvalue(Value(A), 'IN/PATIID'))
  Into n_Patiid
  From Table(Xmlsequence(Extract(Xmlfilelist_In, 'IN'))) A;

  Select To_Number(Extractvalue(Value(A), 'IN/PAGEID'))
  Into n_Pageid
  From Table(Xmlsequence(Extract(Xmlfilelist_In, 'IN'))) A;

  Select To_Number(Extractvalue(Value(A), 'IN/BABY'))
  Into n_Baby
  From Table(Xmlsequence(Extract(Xmlfilelist_In, 'IN'))) A;

  x_Templet := Xmltype('<OUT><ITEMLIST></ITEMLIST></OUT>');

  For r_Ycj In (Select a.Id, a.格式id, a.科室id, c.名称 As 科室, a.文件名称, a.开始时间, a.创建时间, b.保留, b.编号
                From 病人护理文件 A, 病历文件列表 B, 部门表 C
                Where a.格式id = b.Id And a.科室id = c.Id And a.病人id = n_Patiid And a.主页id = n_Pageid And a.婴儿 = n_Baby
                Order By b.保留, a.开始时间) Loop
    v_Temp := '<ITEM><ID>' || r_Ycj.Id || '</ID><MC>' || r_Ycj.文件名称 || '</MC><TYPE>1</TYPE></ITEM>';
    Select Appendchildxml(x_Templet, '/OUT/ITEMLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
  End Loop;

  For r_Kcj In (Select ID, 保留, 编号, 格式
                From (Select ID, 保留, 编号, 名称 As 格式
                       From 病历文件列表
                       Where 种类 = 3 And 保留 <> 1 And
                             (通用 = 1 Or (通用 = 2 And ID In (Select 文件id From 病历应用科室 Where 科室id = n_Areaid))))
                Order By 保留, 编号) Loop
    v_Temp := '<ITEM><ID>' || r_Kcj.Id || '</ID><MC>' || r_Kcj.格式 || '</MC><TYPE>0</TYPE></ITEM>';
    Select Appendchildxml(x_Templet, '/OUT/ITEMLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
  End Loop;

  Xmlfilelist_Out := x_Templet;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_TendFile_Getall;
/

--122046:焦博,2018-02-12,调整Oracle过程Zl_Third_Getvisitinfo删除外连接
CREATE OR REPLACE Procedure Zl_Third_Getvisitinfo
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  -------------------------------------------------------------------------------------------------- 
  --功能:根据挂号单号获取该次就诊详情(医嘱为主要显示) 
  --入参:Xml_In: 
  --<IN> 
  --    <GHDH>挂号单号</GHDH> 
  --    <JSKLB>结算卡类别</JSKLB> 
  --    <MXGL>明细过滤</MXGL> 0-不过滤,明细包含治疗 1-过滤,明细不包含治疗,默认为1 
  --</IN> 
  --出参:Xml_Out 
  --<OUTPUT> 
  --  <GH> 
  --     <GHDH>挂号单号</GHDH> //本次查询的挂号单号 
  --     <YYSJ>预约时间</YYSJ> //yyyy-mm-dd hh24:mi:ss 
  --     <JZSJ></JZSJ>      //实际就诊时间 
  --     <DJH></DJH>        //单据号 
  --     <JE></JE>          //金额 
  --     <DJLX></DJLX>      //单据类型,1-收费单，4-挂号单 
  --     <KDSJ></KDSJ>      //开单时间 
  --     <JKFS></JKFS>      //缴款方式,0-挂号或预约缴款;1-预约不缴款 
  --     <ZFZT></ZFZT>  //支付状态,0-待支付，1-已支付，2-已退费 
  --     <SFJSK></SFJSK>    //是否结算卡支付，0-否，1-是 
  --  </GH> 
  --  <YZLIST> 
  --     <YZ>                   //医嘱返回与HIS中显示的内容相同 
  --        <YZID><YZID>        //医嘱ID，返回组医嘱ID 
  --        <YZLX><YZLX>        //医嘱类型,如处方、检查、检验 
  --         <YZMC></YZMC>        //医嘱名称 
  --        <ZXKS></ZXKS>       //执行科室 
  --        <ZXKSID></ZXKSID>   //执行科室ID 
  --        <FYCK></FYCK>       //发药窗口 
  --        <YZMX> 
  --           <MX> 
  --              <YZNR></YZNR>        //医嘱内容 
  --              <ZXZT></ZXZT>        //医嘱执行状态 
  --              <SFFY>是否发药</SFFY> // 0-否 ，1-是 
  --              <GG>规格</GG> 
  --              <SL>数量</SL> 
  --              <DW>计算单位</DW> 
  --              <BZDJ>标准单价</BZDJ> 
  --              <YSJE>应收金额</YSJE> 
  --              <SSJE>实收金额</SSJE> 
  --           </MX> 
  --           <MX/> 
  --        </YZMX> 
  --        <BG></BG>                   //是否已出报告，是否签名 
  --        <BGLY></BGLY>               //是否外检项目,1-院内项目，2-外检项目 
  --        <BGLYSM></BGLYSM>           //外检项目说明 
  --        <JZBG></JZBG>                //禁止显示报告。0-允许，1-禁止 
  --        <JZTS></JZTS>                 //提示文字。对于禁止查看的报告，可返回用于提示病人的信息 
  --        <BLID></BLID>              //病历ID，如果<BG>字段为1，该值不为空 
  --        <DJLIST> 
  --           <DJ>                //费用单据信息 
  --              <DJH></DJH>      //费用单据号 
  --              <DJLX></DJLX>    //单据类型 
  --              <JE></JE>        //单据总金额 
  --              <KDSJ></KDSJ>    //开单时间 
  --              <ZFZT></ZFZT>    //支付状态,0-待支付，1-已支付，2-已退费,3-退费申请中,4-审核通过,5-审核未通过 
  --              <SHSM></SHSM>    //审核说明,审核未通过原因 
  --              <SFJSK></SFJSK>  //是否结算卡支付，0-否，1-是 
  --           </DJ> 
  --           <DJ/> 
  --        </DJLIST> 
  --     </YZ> 
  --  </YZLIST> 
  --    <ERROR><MSG></MSG></ERROR>                      //如果错误返回 
  --</OUTPUT> 

  -------------------------------------------------------------------------------------------------- 
  v_Err_Msg Varchar2(200);
  Err_Item Exception;
  x_Templet Xmltype; --模板XML 

  v_卡类别   Varchar2(100);
  n_卡类别id Number(18);
  v_挂号单   Varchar2(10);
  v_排队号码 Varchar2(10);
  n_Temp     Number(18);
  v_队列名称 排队叫号队列.队列名称%Type;

  n_Count Number(18);

  v_Temp       Varchar2(32767); --临时XML 
  v_队列       Varchar2(32767);
  v_No         Varchar2(50);
  n_Add_Djlist Number(1); --是否增加了DJLIST的 
  n_性质       Number(2);
  n_组医嘱id   Number(18);
  n_独立医嘱   Number(8);
  n_执行科室id Number(18);
  v_执行科室   Varchar2(50);
  n_退款金额   病人预交记录.冲预交%Type;
  n_明细过滤   Number(3);
  n_退费状态   病人退费申请.状态%Type;
  v_申请原因   病人退费申请.申请原因%Type;
  v_审核原因   病人退费申请.审核原因%Type;
  v_发药窗口   门诊费用记录.发药窗口%Type;

Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/GHDH'), Extractvalue(Value(A), 'IN/JSKLB'), Extractvalue(Value(A), 'IN/MXGL')
  Into v_挂号单, v_卡类别, n_明细过滤
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  If v_挂号单 Is Null Then
    v_Err_Msg := '不能找到指定的挂号单号(当前挂号单号为空)';
    Raise Err_Item;
  End If;
  If n_明细过滤 Is Null Then
    n_明细过滤 := 1;
  End If;
  n_Add_Djlist := 0;

  v_Err_Msg := Null;
  If v_卡类别 Is Not Null Then
    Begin
      n_卡类别id := To_Number(v_卡类别);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
  
    If n_卡类别id = 0 Then
      Begin
        Select ID, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_卡类别id, v_Err_Msg
        From 医疗卡类别
        Where 名称 = v_卡类别;
      Exception
        When Others Then
          v_Err_Msg := '卡类别:' || v_卡类别 || '不存在!';
      End;
    
    Else
    
      Begin
        Select ID, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_卡类别id, v_Err_Msg
        From 医疗卡类别
        Where ID = n_卡类别id;
      Exception
        When Others Then
          v_Err_Msg := '未找到指定的结算支付信息!';
      End;
    
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
  End If;
  n_性质 := 4;
  --1.获取挂号数据 
  Begin
    Select 收费单 Into v_No From 病人挂号记录 Where NO = v_挂号单;
  Exception
    When Others Then
      v_No := Null;
  End;

  If v_No Is Not Null Then
    Select Count(*) Into n_Count From 门诊费用记录 Where NO = v_No And 记录性质 = 1;
    If n_Count <> 0 Then
      n_性质 := 1;
    End If;
  End If;
  If n_性质 = 4 Then
    v_No := v_挂号单;
  End If;

  n_Count := 0;
  For c_挂号 In (Select a.Id, v_No As NO, n_性质 As 记录性质, a.执行部门id, c.名称 As 执行部门,
                      To_Char(a.登记时间, 'yyyy-mm-dd hh24:mi:ss') As 登记时间, To_Char(a.预约时间, 'yyyy-mm-dd hh24:mi:ss') As 预约时间,
                      a.接收时间, To_Char(a.发生时间, 'yyyy-mm-dd HH24:mi:ss') As 就诊时间, a.号别, a.号序, b.金额, a.记录状态,
                      Decode(Nvl(a.执行状态, 0), 0, '等待接诊', 1, '完成就诊', 2, '正在就诊', -1, '取消就诊') As 执行状态,
                      Decode(Nvl(b.结帐id, 0), 0, 0, 1) As 支付标志, Decode(Nvl(a.记录性质, 0), 2, 1, 0) As 缴款方式, b.结帐id As 结帐id
               From 病人挂号记录 A,
                    (Select Max(Decode(记录状态, 0, 0, 2, 0, Nvl(结帐id, 0))) As 结帐id, Sum(实收金额) As 金额
                      From 门诊费用记录 B
                      Where 记录性质 = n_性质 And NO = v_No) B, 部门表 C
               Where a.No = v_挂号单 And a.执行部门id = c.Id) Loop
  
    If Nvl(c_挂号.记录状态, 0) <> 1 Then
      v_Err_Msg := '单据号:' || v_挂号单 || '已经被退号!';
      Raise Err_Item;
    End If;
  
    Begin
      Select 排队号码, 队列名称
      Into v_排队号码, v_队列名称
      From 排队叫号队列
      Where 业务id = c_挂号.Id And Nvl(业务类型, 0) = 0;
    Exception
      When Others Then
        v_排队号码 := Null;
    End;
    If v_排队号码 Is Not Null Then
      --业务id_In ,业务类型_In 排队号码_In Number := Null 
      n_Temp := Zl_Getsequencebeforperons(c_挂号.Id, 0, v_排队号码, v_队列名称);
      v_队列 := v_队列 || '<DL><XH>' || v_排队号码 || '</XH><QMRS>' || n_Temp || '</QMRS></DL>';
    End If;
    n_Temp := 0;
    If Nvl(n_卡类别id, 0) <> 0 Then
      Begin
        Select 1
        Into n_Temp
        From 病人预交记录
        Where 结帐id = c_挂号.结帐id And 记录性质 = 4 And 记录状态 In (1, 3) And 卡类别id = n_卡类别id And Rownum < 2;
      Exception
        When Others Then
          Null;
      End;
    End If;
  
    v_Temp := '<GHDH>' || v_挂号单 || '</GHDH>';
    v_Temp := v_Temp || '<DJH>' || c_挂号.No || '</DJH>';
    v_Temp := v_Temp || '<YYSJ>' || c_挂号.预约时间 || '</YYSJ>';
    v_Temp := v_Temp || '<JZSJ>' || c_挂号.就诊时间 || '</JZSJ>';
    v_Temp := v_Temp || '<KDSJ>' || c_挂号.登记时间 || '</KDSJ>';
    v_Temp := v_Temp || '<JKFS>' || c_挂号.缴款方式 || '</JKFS>';
    v_Temp := v_Temp || '<JE>' || c_挂号.金额 || '</JE>';
    v_Temp := v_Temp || '<DJLX>' || n_性质 || '</DJLX>';
    v_Temp := v_Temp || '<ZFZT>' || c_挂号.支付标志 || '</ZFZT>';
    v_Temp := v_Temp || '<SFJSK>' || n_Temp || '</SFJSK>';
    If v_队列 Is Not Null Then
      v_Temp := v_Temp || v_队列;
    End If;
    v_Temp := '<GH>' || v_Temp || '</GH>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    n_Count := n_Count + 1;
  End Loop;

  If Nvl(n_Count, 0) = 0 Then
    v_Err_Msg := '未找到指定的挂号单据:' || v_挂号单 || '!';
    Raise Err_Item;
  End If;

  --2.组建医嘱及费用相关数据 
  n_组医嘱id := 0;

  For c_医嘱 In (With 医嘱费用 As
                  (Select 医嘱id, 发送号, 记录性质, NO, Max(Nvl(执行状态, 0)) As 执行状态
                  From (Select b.医嘱id, b.发送号, b.记录性质, b.No, Nvl(b.执行状态, 0) As 执行状态
                         From 病人医嘱记录 A, 病人医嘱发送 B
                         Where a.挂号单 = v_挂号单 And a.Id = b.医嘱id
                         Union All
                         Select b.医嘱id, b.发送号, b.记录性质, b.No, Nvl(c.执行状态, 0) As 执行状态
                         From 病人医嘱记录 A, 病人医嘱发送 C, 病人医嘱附费 B
                         Where a.挂号单 = v_挂号单 And a.Id = b.医嘱id And b.医嘱id = c.医嘱id And b.发送号 = c.发送号)
                  Group By 医嘱id, 发送号, 记录性质, NO)
                 
                 Select Nvl(a.相关id, a.Id) As 组id, Decode(a.相关id, Null, 0, 1) As 附医嘱, a.Id, a.相关id, e.发药窗口,
                        Max(Decode(a.诊疗类别, 'E', Decode(q.操作类型, '2', '处方', '4', '处方', '6', '检验', m.名称), m.名称)) As 医嘱类型,
                        a.执行科室id, d.名称 As 执行科室, Decode(a.相关id, Null, a.医嘱内容, Null) As 组医嘱内容,
                        Max(Decode(a.诊疗类别, '5', 1, '6', 1, '7', 1, 0) * Decode(Nvl(e.执行状态, 0), 1, 1, 3, 1, 0)) As 发药状态,
                        Decode(a.相关id, Null, Null, q.名称) As 明细医嘱内容, s.规格, (e.数次 * e.付数) As 数量, e.计算单位 As 单位,
                        Decode(Nvl(b.执行状态, 0), 0, '未执行', 1, '完全执行', 2, '拒绝执行', 3, '正在执行', '正在执行') As 执行状态,
                        Max(Decode(p.审核时间, Null, Decode(C1.完成时间, Null, 0, 1), 1)) As 是否已出报告, c.病历id, e.No, e.记录性质 As 单据类型,
                        Max(e.标准单价) As 标准单价, Sum(e.应收金额) As 应收金额, Sum(e.实收金额) As 实收金额,
                        To_Char(e.登记时间, 'yyyy-mm-dd hh24:mi:ss') As 开单时间, Decode(Nvl(e.记录状态, 0), 0, 0, 3, 2, 1) As 支付状态,
                        a.病人id
                 
                 From 病人医嘱记录 A, 医嘱费用 B, 病人医嘱报告 C, 电子病历记录 C1, 部门表 D, 门诊费用记录 E, 诊疗项目类别 M, 诊疗项目目录 Q, 收费项目目录 S, 检验标本记录 P
                 Where a.Id = b.医嘱id(+) And a.执行科室id = d.Id(+) And c.病历id = C1.Id(+) And a.Id = c.医嘱id(+) And
                       a.Id = p.医嘱id(+) And b.医嘱id = e.医嘱序号(+) And e.收费细目id = s.Id(+) And b.No = e.No(+) And
                       b.记录性质 = e.记录性质(+) And e.记录状态(+) <> 2 And a.挂号单 = v_挂号单 And a.诊疗类别 = m.编码(+) And
                       a.诊疗项目id = q.Id(+) And a.医嘱状态 In (3, 8)
                 Group By a.Id, a.婴儿, a.序号, a.相关id, e.发药窗口, a.诊疗类别, a.执行科室id, d.名称, a.医嘱内容, q.名称, s.规格, e.数次 * e.付数,
                          e.计算单位, Decode(Nvl(b.执行状态, 0), 0, '未执行', 1, '完全执行', 2, '拒绝执行', 3, '正在执行', '正在执行'), C1.完成时间,
                          Decode(c.病历id, Null, 0, 1), c.病历id, e.No, e.记录性质, e.登记时间, Decode(Nvl(e.记录状态, 0), 0, 0, 3, 2, 1),
                          p.审核时间, a.病人id
                 Order By 组id, 附医嘱, Nvl(a.婴儿, 0), a.序号) Loop
    If Nvl(n_Add_Djlist, 0) = 0 Then
      --增加DJList节点 
      Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype('<YZLIST></YZLIST>')) Into x_Templet From Dual;
      n_Add_Djlist := 1;
    End If;
  
    If n_组医嘱id <> Nvl(c_医嘱.组id, 0) Then
      n_组医嘱id := Nvl(c_医嘱.组id, 0);
    
      Zl_Third_Custom_Getdeptinfo(n_组医嘱id, n_执行科室id, v_执行科室);
    
      If Nvl(n_执行科室id, 0) = 0 Then
        If c_医嘱.医嘱类型 = '检验' Then
          --检验医嘱以显示采集科室 
          n_执行科室id := c_医嘱.执行科室id;
          v_执行科室   := c_医嘱.执行科室;
        Else
          Begin
            Select b.Id, b.名称, c.发药窗口
            Into n_执行科室id, v_执行科室, v_发药窗口
            From 病人医嘱记录 A, 部门表 B, 门诊费用记录 C
            Where a.Id = c.医嘱序号 And a.相关id = n_组医嘱id And a.执行科室id = b.Id And Rownum <= 1;
          Exception
            When Others Then
              n_执行科室id := c_医嘱.执行科室id;
              v_执行科室   := c_医嘱.执行科室;
              v_发药窗口   := c_医嘱.发药窗口;
          End;
        End If;
      End If;
    
      v_Temp := '<YZID>' || n_组医嘱id || '</YZID>';
      v_Temp := v_Temp || '<YZLX>' || c_医嘱.医嘱类型 || '</YZLX>';
      v_Temp := v_Temp || '<YZMC>' || c_医嘱.组医嘱内容 || '</YZMC>';
      v_Temp := v_Temp || '<ZXKS>' || v_执行科室 || '</ZXKS>';
      v_Temp := v_Temp || '<ZXKSID>' || n_执行科室id || '</ZXKSID>';
      v_Temp := v_Temp || '<FYCK>' || v_发药窗口 || '</FYCK>';
      v_Temp := v_Temp || '<BG>' || c_医嘱.是否已出报告 || '</BG>';
      v_Temp := v_Temp || Zl_Third_Custom_Getrptfrom(n_组医嘱id);
      v_Temp := v_Temp || Zl_Third_Custom_Rptlimit(c_医嘱.病人id, n_组医嘱id);
      If Nvl(c_医嘱.是否已出报告, 0) = 1 And c_医嘱.病历id Is Not Null Then
        v_Temp := v_Temp || '<BLID>' || c_医嘱.病历id || '</BLID>';
      End If;
      v_Temp := '<YZ 医嘱ID="' || n_组医嘱id || '">' || v_Temp || '<YZMX></YZMX><DJLIST></DJLIST></YZ>';
      Select Appendchildxml(x_Templet, '/OUTPUT/YZLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
    
      For v_费用 In (
                   
                   Select a.No, Mod(a.记录性质, 10) As 单据类型, To_Char(a.登记时间, 'yyyy-mm-dd hh24:mi:ss') As 开单时间,
                           Max(Decode(Nvl(a.记录状态, 0), 0, 0, 3, 2, 1)) As 支付状态, Sum(a.实收金额) As 单据金额, Max(a.结帐id) As 结算卡支付
                   From 门诊费用记录 A
                   Where (a.No, a.记录性质) In
                         (Select Distinct q.No, q.记录性质
                          From 病人医嘱记录 M, 病人医嘱发送 Q
                          Where m.Id = q.医嘱id And (m.Id = n_组医嘱id Or m.相关id = n_组医嘱id)
                          Union All
                          Select Distinct q.No, q.记录性质
                          From 病人医嘱记录 M, 病人医嘱附费 Q
                          Where m.Id = q.医嘱id And (m.Id = n_组医嘱id Or m.相关id = n_组医嘱id)) And Nvl(a.记录状态, 0) In (0, 1, 3)
                   Group By a.No, Mod(a.记录性质, 10), To_Char(a.登记时间, 'yyyy-mm-dd hh24:mi:ss')) Loop
        Begin
          Select 1
          Into n_Temp
          From 病人预交记录 A, 门诊费用记录 B
          Where a.结帐id = b.结帐id And b.No = v_费用.No And Mod(b.记录性质, 10) = 1 And b.记录状态 In (1, 3) And a.卡类别id = n_卡类别id And
                Rownum < 2;
        Exception
          When Others Then
            n_Temp := 0;
        End;
        Begin
          Select -1 * Sum(结帐金额)
          Into n_退款金额
          From 门诊费用记录 B
          Where b.No = v_费用.No And Mod(b.记录性质, 10) = 1 And b.记录状态 = 2;
        Exception
          When Others Then
            n_退款金额 := 0;
        End;
        Begin
          Select 状态, 申请原因, 审核原因
          Into n_退费状态, v_申请原因, v_审核原因
          From 病人退费申请
          Where NO = v_费用.No And Mod(记录性质, 10) = Mod(v_费用.单据类型, 10);
        Exception
          When Others Then
            n_退费状态 := -1;
            v_申请原因 := '';
            v_审核原因 := '';
        End;
      
        v_Temp := '<DJH>' || v_费用.No || '</DJH>';
        v_Temp := v_Temp || '<DJLX>' || v_费用.单据类型 || '</DJLX>';
        v_Temp := v_Temp || '<JE>' || v_费用.单据金额 || '</JE>';
        v_Temp := v_Temp || '<KDSJ>' || v_费用.开单时间 || '</KDSJ>';
        If n_退费状态 = -1 Then
          v_Temp := v_Temp || '<ZFZT>' || v_费用.支付状态 || '</ZFZT>';
        Else
          If n_退费状态 = 0 Then
            v_Temp := v_Temp || '<ZFZT>3</ZFZT>';
          End If;
          If n_退费状态 = 1 Then
            If v_费用.支付状态 = 2 Then
              v_Temp := v_Temp || '<ZFZT>2</ZFZT>';
            Else
              v_Temp := v_Temp || '<ZFZT>4</ZFZT>';
            End If;
          End If;
          If n_退费状态 = 2 Then
            v_Temp := v_Temp || '<ZFZT>5</ZFZT>';
          End If;
        End If;
      
        If n_退费状态 = -1 Then
          v_Temp := v_Temp || '<SHSM>' || '' || '</SHSM>';
        Else
          If n_退费状态 = 0 Then
            v_Temp := v_Temp || '<SHSM>' || v_申请原因 || '</SHSM>';
          End If;
          If n_退费状态 = 1 Then
            v_Temp := v_Temp || '<SHSM>' || v_审核原因 || '</SHSM>';
          End If;
          If n_退费状态 = 2 Then
            v_Temp := v_Temp || '<SHSM>' || v_审核原因 || '</SHSM>';
          End If;
        End If;
      
        v_Temp := v_Temp || '<YTJE>' || Nvl(n_退款金额, 0) || '</YTJE>';
        v_Temp := v_Temp || '<SFJSK>' || n_Temp || '</SFJSK>';
        v_Temp := '<DJ>' || v_Temp || '</DJ>';
        Select Appendchildxml(x_Templet, '/OUTPUT/YZLIST/YZ[@医嘱ID="' || n_组医嘱id || '"]/DJLIST', Xmltype(v_Temp))
        Into x_Templet
        From Dual;
      End Loop;
    End If;
  
    --只有一条记录的医嘱，在明细中增加该条医嘱，以获取执行状态 
    Select Decode(Count(*), 0, 1, 0) Into n_独立医嘱 From 病人医嘱记录 Where 相关id = n_组医嘱id;
    If n_独立医嘱 = 1 Then
      v_Temp := '<YZNR>' || c_医嘱.组医嘱内容 || '</YZNR>';
      v_Temp := v_Temp || '<GG>' || c_医嘱.规格 || '</GG>';
      v_Temp := v_Temp || '<SFFY>' || c_医嘱.发药状态 || '</SFFY>';
      v_Temp := v_Temp || '<SL>' || c_医嘱.数量 || '</SL>';
      v_Temp := v_Temp || '<DW>' || c_医嘱.单位 || '</DW>';
      v_Temp := v_Temp || '<BZDJ>' || Nvl(c_医嘱.标准单价, 0) || '</BZDJ>';
      v_Temp := v_Temp || '<YSJE>' || Nvl(c_医嘱.应收金额, 0) || '</YSJE>';
      v_Temp := v_Temp || '<SSJE>' || Nvl(c_医嘱.实收金额, 0) || '</SSJE>';
      v_Temp := v_Temp || '<ZXZT>' || c_医嘱.执行状态 || '</ZXZT>';
      v_Temp := '<MX>' || v_Temp || '</MX>';
      Select Appendchildxml(x_Templet, '/OUTPUT/YZLIST/YZ[@医嘱ID="' || n_组医嘱id || '"]/YZMX', Xmltype(v_Temp))
      Into x_Templet
      From Dual;
    End If;
  
    If Nvl(c_医嘱.附医嘱, 0) = 1 Then
      If n_明细过滤 = 0 Or (n_明细过滤 = 1 And c_医嘱.医嘱类型 <> '治疗') Then
        v_Temp := '<YZNR>' || c_医嘱.明细医嘱内容 || '</YZNR>';
        v_Temp := v_Temp || '<GG>' || c_医嘱.规格 || '</GG>';
        v_Temp := v_Temp || '<SL>' || c_医嘱.数量 || '</SL>';
        v_Temp := v_Temp || '<DW>' || c_医嘱.单位 || '</DW>';
        v_Temp := v_Temp || '<SFFY>' || c_医嘱.发药状态 || '</SFFY>';
        v_Temp := v_Temp || '<ZXZT>' || c_医嘱.执行状态 || '</ZXZT>';
        v_Temp := v_Temp || '<BZDJ>' || Nvl(c_医嘱.标准单价, 0) || '</BZDJ>';
        v_Temp := v_Temp || '<YSJE>' || Nvl(c_医嘱.应收金额, 0) || '</YSJE>';
        v_Temp := v_Temp || '<SSJE>' || Nvl(c_医嘱.实收金额, 0) || '</SSJE>';
        v_Temp := '<MX>' || v_Temp || '</MX>';
        Select Appendchildxml(x_Templet, '/OUTPUT/YZLIST/YZ[@医嘱ID="' || n_组医嘱id || '"]/YZMX', Xmltype(v_Temp))
        Into x_Templet
        From Dual;
      End If;
    End If;
  
  End Loop;
  Xml_Out := x_Templet;

Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getvisitinfo;
/

--121281:蒋廷中,2018-02-11,增加存储过程用于调用外部调用更新状态说明
Create Or Replace Procedure Zl_医嘱状态说明_Update
(
  医嘱id_In   病人医嘱发送.医嘱id%Type,
  状态说明_In 病人医嘱发送.状态说明%Type,
  发送号_In   病人医嘱发送.发送号%Type := Null
) Is
Begin
  If 发送号_In Is Not Null Then
    Update 病人医嘱发送 Set 状态说明 = 状态说明_In Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In;
  Else
    Update 病人医嘱发送 Set 状态说明 = 状态说明_In Where 医嘱id = 医嘱id_In;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_医嘱状态说明_Update;
/


--122017:殷瑞,2018-02-11,新增静配的第三方接口过程
Create Or Replace Procedure Zl_Third_Getsign
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能：获取输液单信息/查询
  --参数：
  --入参数 Xml_In
  --<IN>
  --  <ID></ID>   --输液配药记录.ID
  --</IN>

  --出参 Xml_Out
  --<OUTPUT>
  --  <YZID></YZID>   --输液配药记录.医嘱ID
  --  <FSH></FSH>   --输液配药记录.发送号
  --  <YQSJ></YQSJ>   --医嘱的要求时间
  --  <PYSJ></PYSJ>   --输液配药记录.配药时间_BAK
  --  <PYR></PYR>   --输液配药记录.配药人_BAK
  --  <PQH></PQH>   --输液配药记录.瓶签号
  --  <PC></PC>   --输液配药记录.配药批次
  --  <PCRQ></PCRQ>   --输液配药记录.执行时间
  --  <BQ></BQ>   --输液配药记录.病人病区id
  --  <XM></XM>   --输液配药记录.姓名
  --  <XB></XB>   --输液配药记录.性别
  --  <NL></NL>   --输液配药记录.年龄
  --  <CH></CH>   --输液配药记录.床号
  --  <ZT></ZT>   --输液配药记录.操作状态(实际数值)
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  n_Id      输液配药记录.Id%Type;
  x_Templet Xmltype; --模板XML
  v_Temp    Varchar2(32767);

  n_医嘱id     输液配药记录.医嘱id%Type;
  n_发送号     输液配药记录.发送号%Type;
  v_要求时间   输液配药记录.执行时间%Type;
  v_配药时间   输液配药状态.操作时间%Type;
  v_配药人     输液配药状态.操作人员%Type;
  v_瓶签号     输液配药记录.瓶签号%Type;
  n_配药批次   输液配药记录.配药批次%Type;
  v_执行时间   输液配药记录.执行时间%Type;
  n_病人病区id 输液配药记录.病人病区id%Type;
  v_姓名       输液配药记录.姓名%Type;
  v_性别       输液配药记录.性别%Type;
  v_年龄       输液配药记录.年龄%Type;
  v_床号       输液配药记录.床号%Type;
  n_操作状态   输液配药记录.操作状态%Type;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  --获取输液单ID
  Select Extractvalue(Value(A), 'IN/ID') Into n_Id From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  --获取对应输液单的信息
  Select a.医嘱id, a.发送号, a.执行时间, a.瓶签号, a.配药批次, a.执行时间, a.病人病区id, a.姓名, a.性别, a.年龄, a.床号, a.操作状态
  Into n_医嘱id, n_发送号, v_要求时间, v_瓶签号, n_配药批次, v_执行时间, n_病人病区id, v_姓名, v_性别, v_年龄, v_床号, n_操作状态
  From 输液配药记录 A
  Where a.Id = n_Id;

  Begin
    Select 操作人员, 操作时间
    Into v_配药人, v_配药时间
    From (Select b.操作人员, b.操作时间
           From 输液配药状态 B
           Where b.操作类型 = 4 And b.配药id = n_Id
           Order By b.操作时间 Desc)
    Where Rownum < 2;

  Exception
    When Others Then
      v_配药人   := '';
      v_配药时间 := '';
  End;

  v_Temp := '<YZID>' || n_医嘱id || '</YZID>';
  v_Temp := v_Temp || '<FSH>' || n_发送号 || '</FSH>';
  v_Temp := v_Temp || '<YQSJ>' || v_要求时间 || '</YQSJ>';
  v_Temp := v_Temp || '<PYSJ>' || v_配药时间 || '</PYSJ>';
  v_Temp := v_Temp || '<PYR>' || v_配药人 || '</PYR>';
  v_Temp := v_Temp || '<PQH>' || v_瓶签号 || '</PQH>';
  v_Temp := v_Temp || '<PC>' || n_配药批次 || '</PC>';
  v_Temp := v_Temp || '<PCRQ>' || v_执行时间 || '</PCRQ>';
  v_Temp := v_Temp || '<BQ>' || n_病人病区id || '</BQ>';
  v_Temp := v_Temp || '<XM>' || v_姓名 || '</XM>';
  v_Temp := v_Temp || '<XB>' || v_性别 || '</XB>';
  v_Temp := v_Temp || '<NL>' || v_年龄 || '</NL>';
  v_Temp := v_Temp || '<CH>' || v_床号 || '</CH>';
  v_Temp := v_Temp || '<ZT>' || n_操作状态 || '</ZT>';

  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;

  Xml_Out := x_Templet;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getsign;
/

--122017:殷瑞,2018-02-11,新增静配的第三方接口过程
Create Or Replace Procedure Zl_Third_Signedit
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能：签收/拒收  /写入
  --参数：
  --入参数 Xml_In
  --<IN>
  --  <TYPE>1</TYPE>   --1：签收；0：拒收
  --  <YZID>1162695</YZID>   --医嘱id
  --  <FSH>202704</FSH>   --发送号
  --  <YQSJ>2017-12-05 10:00:00</YQSJ>   --要求时间
  --  <CZY></CZY>   --操作员
  --  <CZSJ>2017-12-05 16:26:54</CZSJ>   --操作时间
  --  <JSYY><JSYY>   --拒收原因，拒收时可传入
  --</IN>

  --出参 Xml_Out
  --成功：
  --<OUTPUT>
  --  <RESULT>true</RESULT>
  --</OUTPUT>

  --失败：
  --<OUTPUT>
  --  <RESULT>false</RESULT>
  --  <ERROR>
  --    <MSG>详细错误提示</MSG>
  --  </ERROR>
  --</OUTPUT>

  --------------------------------------------------------------------------------------------------
  n_签收     输液配药记录.操作状态%Type;
  n_医嘱id   输液配药记录.医嘱id%Type;
  n_发送号   输液配药记录.发送号%Type;
  v_要求时间 Varchar2(2000);
  v_操作人员 输液配药记录.操作人员%Type;
  v_操作时间 Varchar2(2000);
  v_拒收原因 Varchar2(2000);

  x_Templet Xmltype; --模板XML
  v_Temp    Varchar2(32767);
  Err_Custom Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/TYPE'), Extractvalue(Value(A), 'IN/YZID'), Extractvalue(Value(A), 'IN/FSH'),
         Extractvalue(Value(A), 'IN/YQSJ'), Extractvalue(Value(A), 'IN/CZY'), Extractvalue(Value(A), 'CZSJ'),
         Extractvalue(Value(A), 'JSYY')
  Into n_签收, n_医嘱id, n_发送号, v_要求时间, v_操作人员, v_操作时间, v_拒收原因
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  --根据签收状态来更新输液配记录
  For r_Bill In (Select ID, 操作状态
                 From 输液配药记录
                 Where 医嘱id = n_医嘱id And 发送号 = n_发送号 And 执行时间 = To_Date(v_要求时间, 'yyyy-mm-dd hh24:mi:ss') And
                       操作人员 = v_操作人员 And 操作时间 = To_Date(v_操作时间, 'yyyy-mm-dd hh24:mi:ss')) Loop

    --判断当前单据的状态是否满足签收或拒签
    If r_Bill.操作状态 = 5 Then
      If n_签收 = 1 Then
        Update 输液配药记录
        Set 操作状态 = 6, 操作人员 = v_操作人员, 操作时间 = To_Date(v_操作时间, 'yyyy-mm-dd hh24:mi:ss')
        Where ID = r_Bill.Id;

        Insert Into 输液配药状态
          (配药id, 操作类型, 操作人员, 操作时间, 操作说明)
        Values
          (r_Bill.Id, 6, v_操作人员, To_Date(v_操作时间, 'yyyy-mm-dd hh24:mi:ss'), Null);
      Else
        Update 输液配药记录
        Set 操作状态 = 7, 操作人员 = v_操作人员, 操作时间 = To_Date(v_操作时间, 'yyyy-mm-dd hh24:mi:ss')
        Where ID = r_Bill.Id;

        Insert Into 输液配药状态
          (配药id, 操作类型, 操作人员, 操作时间, 操作说明)
        Values
          (r_Bill.Id, 7, v_操作人员, To_Date(v_操作时间, 'yyyy-mm-dd hh24:mi:ss'), v_拒收原因);
      End If;
    Else
      Raise Err_Custom;
    End If;
  End Loop;

  v_Temp := '<RESULT>' || 'true' || '</RESULT>';

  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;

  Xml_Out := x_Templet;
Exception
  When Err_Custom Then
    v_Temp := '<RESULT>' || 'false' || '</RESULT>';
    v_Temp := v_Temp || '<ERROR><MSG>' || '当前输液单状态不允许签收或拒签！' || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Xml_Out := x_Templet;
  When Others Then
    v_Temp := '<RESULT>' || 'false' || '</RESULT>';
    v_Temp := v_Temp || '<ERROR><MSG>' || SQLErrM || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Xml_Out := x_Templet;
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Signedit;
/

--122017:殷瑞,2018-02-11,新增静配的第三方接口过程
Create Or Replace Procedure Zl_Third_Signedit_Cancel
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能：取消签收/取消拒收  /写入
  --参数：
  --入参数 Xml_In
  --<IN>
  --  <TYPE>1</TYPE>   --1：取消签收；0：取消拒收
  --  <YZID>1162695</YZID>   --医嘱id
  --  <FSH>202704</FSH>   --发送号
  --  <YQSJ>2017-12-05 10:00:00</YQSJ>   --要求时间
  --  <CZY></CZY>   --操作员
  --  <CZSJ>2017-12-05 16:26:54</CZSJ>   --操作时间
  --</IN>

  --出参 Xml_Out
  --成功：
  --<OUTPUT>
  --  <RESULT>true</RESULT>
  --</OUTPUT>

  --失败：
  --<OUTPUT>
  --  <RESULT>false</RESULT>
  --  <ERROR>
  --    <MSG>详细错误提示</MSG>
  --  </ERROR>
  --</OUTPUT>

  --------------------------------------------------------------------------------------------------
  n_签收     输液配药记录.操作状态%Type;
  n_医嘱id   输液配药记录.医嘱id%Type;
  n_发送号   输液配药记录.发送号%Type;
  v_要求时间 Varchar2(2000);
  v_操作人员 输液配药记录.操作人员%Type;
  v_操作时间 Varchar2(2000);

  x_Templet Xmltype; --模板XML
  v_Temp    Varchar2(32767);
  v_Error   Varchar2(255);
  Err_Custom Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/TYPE'), Extractvalue(Value(A), 'IN/YZID'), Extractvalue(Value(A), 'IN/FSH'),
         Extractvalue(Value(A), 'IN/YQSJ'), Extractvalue(Value(A), 'IN/CZY'), Extractvalue(Value(A), 'CZSJ')
  Into n_签收, n_医嘱id, n_发送号, v_要求时间, v_操作人员, v_操作时间
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  --根据传入类型来回退输液配记录的操作状态
  For r_Bill In (Select ID, 操作状态
                 From 输液配药记录
                 Where 医嘱id = n_医嘱id And 发送号 = n_发送号 And 执行时间 = To_Date(v_要求时间, 'yyyy-mm-dd hh24:mi:ss') And
                       操作人员 = v_操作人员 And 操作时间 = To_Date(v_操作时间, 'yyyy-mm-dd hh24:mi:ss')) Loop

    If n_签收 = 1 Then
      If r_Bill.操作状态 = 6 Then
        --更新记录
        Update 输液配药记录
        Set 操作状态 = 5, 操作人员 = v_操作人员, 操作时间 = To_Date(v_操作时间, 'yyyy-mm-dd hh24:mi:ss')
        Where ID = r_Bill.Id;

        Insert Into 输液配药状态
          (配药id, 操作类型, 操作人员, 操作时间, 操作说明)
        Values
          (r_Bill.Id, 5, v_操作人员, To_Date(v_操作时间, 'yyyy-mm-dd hh24:mi:ss'), '取消签收');
      Else
        v_Error := '当前输液单状态不是签收状态，不能进行取消签收！';
        Raise Err_Custom;
      End If;
    Else
      If r_Bill.操作状态 = 7 Then
        --更新记录
        Update 输液配药记录
        Set 操作状态 = 5, 操作人员 = v_操作人员, 操作时间 = To_Date(v_操作时间, 'yyyy-mm-dd hh24:mi:ss')
        Where ID = r_Bill.Id;

        Insert Into 输液配药状态
          (配药id, 操作类型, 操作人员, 操作时间, 操作说明)
        Values
          (r_Bill.Id, 5, v_操作人员, To_Date(v_操作时间, 'yyyy-mm-dd hh24:mi:ss'), '取消拒收');
      Else
        v_Error := '当前输液单状态不是拒签状态，不能进行取消拒收！';
        Raise Err_Custom;
      End If;
    End If;

  End Loop;

  v_Temp := '<RESULT>' || 'true' || '</RESULT>';

  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;

  Xml_Out := x_Templet;
Exception
  When Err_Custom Then
    v_Temp := '<RESULT>' || 'false' || '</RESULT>';
    v_Temp := v_Temp || '<ERROR><MSG>' || v_Error || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Xml_Out := x_Templet;
  When Others Then
    v_Temp := '<RESULT>' || 'false' || '</RESULT>';
    v_Temp := v_Temp || '<ERROR><MSG>' || SQLErrM || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Xml_Out := x_Templet;
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Signedit_Cancel;
/

--117106:董露露,2018-02-07,标准路径参考增加导入路径的功能
Create Or Replace Procedure Zl_标准路径病种_Update
(
  Id_In       标准路径目录.Id%Type,
  疾病编码_In 标准路径病种.疾病编码%Type,
  手术编码_In 标准路径病种.手术编码%Type
) Is
Begin
  Update 标准路径病种 Set 疾病编码 = 疾病编码_In, 手术编码 = 手术编码_In Where 标准路径id = Id_In;
Exception 
  When Others Then 
    zl_ErrorCenter(SQLCode, SQLErrM); 
End Zl_标准路径病种_Update;
/

--118705:李小东,2018-02-07,技师站审核标本后能改变该标本下所有医嘱状态
Create Or Replace Procedure Zl_检验普通结果_Write
(
  检验标本id_In In 检验普通结果.检验标本id%Type,
  仪器id_In     In 检验普通结果.仪器id%Type,
  检验指标_In   In Varchar2, --格式：医嘱ID^项目ID^值^标志^参考^诊疗项目ID|。。。 
  是否覆盖_In   In Number,
  微生物_In     In Number := 0,
  医嘱id_In     In Varchar2 := Null
) Is
  Err_Custom Exception;
  v_Flag      Number(1);
  v_Records   Varchar2(4000);
  v_Currrec   Varchar2(500);
  v_Item      Varchar2(200);
  v_医嘱id    检验项目分布.医嘱id%Type;
  v_项目id    检验普通结果.检验项目id%Type;
  v_检验结果  检验普通结果.检验结果%Type;
  v_检验结果1 检验普通结果.检验结果%Type;

  v_结果标志   检验普通结果.结果标志%Type;
  v_结果参考   检验普通结果.结果参考%Type;
  v_结果参考1  检验普通结果.结果参考%Type;
  v_诊疗项目id 检验普通结果.诊疗项目id%Type;
  v_排列序号   检验普通结果.排列序号%Type;
  v_Pos1       Number;
  v_Pos2       Number;
  v_标本类型   检验标本记录.标本类型%Type;
  v_性别       检验标本记录.性别%Type;
  v_年龄       检验标本记录.年龄%Type;
  v_出生日期   病人信息.出生日期%Type;

  v_糖耐量id  检验普通结果.检验项目id%Type;
  v_糖耐量id1 检验普通结果.检验项目id%Type;

  v_多参考 Number;

  Function Zlval(Vstr In Varchar2) Return Number Is
    Result Number(16, 6);
    Intbit Number(8);
    Strnum Varchar2(10);
    Function Sub_Is_Number(v_In In Varchar2) Return Boolean Is
      n_Tmp Number;
    Begin
      n_Tmp := To_Number(v_In);
      If n_Tmp Is Not Null Then
        Return True;
      Else
        Return False;
      End If;
    Exception
      When Others Then
        Return False;
    End Sub_Is_Number;
  Begin
    Strnum := '';
    If Sub_Is_Number(Vstr) = True Then
      Result := To_Number(Nvl(Vstr, 0));
      Return(Result);
    Else
      For Intbit In 1 .. 10 Loop
        If Instr('0123456789.', Substr(Vstr, Intbit, 1)) = 0 Then
          Exit;
        End If;
        Strnum := Strnum || Substr(Vstr, Intbit, 1);
        Null;
      End Loop;
      Result := To_Number(Nvl(Strnum, 0));
      Return(Result);
    End If;
  End Zlval;
  -- >>>>>>>>>>>>>>>>>>  检查是否数字的函数  <<<<<<<<<<<<<<<<<< 
  Function Sub_Is_Number(v_In In Varchar2) Return Boolean Is
    n_Tmp Number;
  Begin
    n_Tmp := To_Number(v_In);
    If n_Tmp Is Not Null Then
      Return True;
    Else
      Return False;
    End If;
  Exception
    When Others Then
      Return False;
  End Sub_Is_Number;
Begin
  v_Records := 检验指标_In || '|';
  --已审核不能覆盖 
  v_Flag := 0;
  Begin
    Select 1 Into v_Flag From 检验标本记录 Where ID = 检验标本id_In And 样本状态 = 2;
  Exception
    When Others Then
      v_Flag := 0;
  End;
  If v_Flag = 1 Then
    Return;
  End If;

  If 是否覆盖_In = 1 Then
    Delete From 检验普通结果 Where 检验标本id = 检验标本id_In;
    Delete 检验项目分布 Where 标本id = 检验标本id_In;
  End If;
  --没有找到数据后退出 
  Begin
    Select a.标本类型, a.性别, a.年龄, b.出生日期
    Into v_标本类型, v_性别, v_年龄, v_出生日期
    From 检验标本记录 A, 病人信息 B
    Where a.病人id = b.病人id(+) And a.Id = 检验标本id_In;
  Exception
    When Others Then
      Return;
  End;

  If 检验指标_In Is Not Null Then
    While v_Records Is Not Null Loop
      v_Currrec    := Substr(v_Records, 1, Instr(v_Records, '|') - 1);
      v_Pos1       := Instr(v_Currrec, '^', 1);
      v_医嘱id     := To_Number(Substr(v_Currrec, 1, v_Pos1 - 1));
      v_Pos2       := Instr(v_Currrec, '^', v_Pos1 + 1);
      v_项目id     := To_Number(Substr(v_Currrec, v_Pos1 + 1, v_Pos2 - v_Pos1 - 1));
      v_Pos1       := Instr(v_Currrec, '^', v_Pos2 + 1);
      v_检验结果   := Substr(v_Currrec, v_Pos2 + 1, v_Pos1 - v_Pos2 - 1);
      v_Pos2       := Instr(v_Currrec, '^', v_Pos1 + 1);
      v_结果标志   := To_Number(Substr(v_Currrec, v_Pos1 + 1, v_Pos2 - v_Pos1 - 1));
      v_Pos1       := Instr(v_Currrec, '^', v_Pos2 + 1);
      v_结果参考   := To_Number(Substr(v_Currrec, v_Pos1 + 1, v_Pos2 - v_Pos1 - 1));
      v_Pos2       := Instr(v_Currrec, '^', v_Pos1 + 1);
      v_诊疗项目id := To_Number(Substr(v_Currrec, v_Pos1 + 1, v_Pos2 - v_Pos1 - 1));
      v_排列序号   := Substr(v_Currrec, v_Pos2 + 1);
    
      v_Flag := 0;
      If 是否覆盖_In <> 1 Then
        v_检验结果1 := v_检验结果;
        Begin
          If 微生物_In = 0 Then
            --新增2005-5-26 
            Select 1, 检验结果
            Into v_Flag, v_检验结果
            From 检验普通结果
            Where 检验标本id = 检验标本id_In And 检验项目id = v_项目id;
          Else
            Select 1, 检验结果
            Into v_Flag, v_检验结果
            From 检验普通结果
            Where 检验标本id = 检验标本id_In And 细菌id = v_项目id;
          End If;
        Exception
          When Others Then
            v_Flag     := 0;
            v_检验结果 := v_检验结果1;
        End;
      End If;
      If v_Flag = 0 Then
        If 微生物_In = 0 Then
          Insert Into 检验普通结果
            (ID, 检验标本id, 检验项目id, 检验结果, 记录类型, 仪器id, 结果标志, 结果参考, 诊疗项目id, 排列序号)
          Values
            (检验普通结果_Id.Nextval, 检验标本id_In, v_项目id, v_检验结果, 0, Decode(仪器id_In, 0, Null, 仪器id_In),
             Decode(v_多参考, 0, v_结果标志, 1), Decode(v_多参考, 0, v_结果参考, v_结果参考1), v_诊疗项目id, v_排列序号);
          Insert Into 检验流水线指标 (ID, 标本id, 项目id) Values (检验流水线指标_Id.Nextval, 检验标本id_In, v_项目id);
        Else
          If Instr(v_检验结果, ';') > 0 Then
            If Instr(v_检验结果, v_标本类型) > 0 Then
              --找到标本 
              v_Item := Substr(v_检验结果, Instr(v_检验结果, v_标本类型));
              v_Item := Substr(v_Item, Instr(v_Item, ',') + 1);
              If Instr(v_Item, ';') > 0 Then
                v_检验结果 := Substr(v_Item, 1, Instr(v_Item, ';') - 1);
              Else
                v_检验结果 := v_Item;
              End If;
            Else
              --没有找到相同的标本类型时使用第一个 
              v_Item := Substr(v_检验结果, Instr(v_检验结果, ',') + 1);
              If Instr(v_Item, ';') > 0 Then
                v_检验结果 := Substr(v_Item, 1, Instr(v_Item, ';') - 1);
              Else
                v_检验结果 := v_Item;
              End If;
            End If;
          End If;
        
          Insert Into 检验普通结果
            (ID, 检验标本id, 细菌id, 检验结果, 记录类型, 仪器id, 结果标志, 结果参考, 诊疗项目id, 排列序号)
          Values
            (检验普通结果_Id.Nextval, 检验标本id_In, v_项目id, v_检验结果, 0, Decode(仪器id_In, 0, Null, 仪器id_In), v_结果标志, v_结果参考,
             v_诊疗项目id, v_排列序号);
        
          Insert Into 检验药敏结果
            (细菌结果id, 抗生素id, 修改者, 修改时间, 结果, 结果类型, 记录类型, 仪器id)
            Select 检验普通结果_Id.Currval, b.抗生素id, '', Null, '', c.默认药敏, 0, Decode(仪器id_In, 0, Null, 仪器id_In)
            From (Select 抗生素分组id, 细菌id
                   From (Select 抗生素分组id, 细菌id
                          From 检验细菌抗生素 A
                          Where a.细菌id = v_项目id
                          Order By Nvl(缺省标志, 0) Desc)
                   Where Rownum = 1) A, 检验抗生素用药 B, 检验细菌 C
            Where a.抗生素分组id = b.抗生素分组id And c.Id = v_项目id;
        End If;
      End If;
      If v_医嘱id = 0 Then
        v_医嘱id := Null;
      End If;
      If 微生物_In = 0 Then
        Update 检验项目分布
        Set 医嘱id = Decode(v_医嘱id, Null, 医嘱id, v_医嘱id)
        Where 标本id = 检验标本id_In And 项目id + 0 = v_项目id And 医嘱id Is Null;
        If Sql%RowCount = 0 Then
          Insert Into 检验项目分布
            (ID, 标本id, 项目id, 医嘱id, 范围)
          Values
            (检验项目分布_Id.Nextval, 检验标本id_In, v_项目id, v_医嘱id, 1);
        End If;
      Else
        Update 检验项目分布
        Set 医嘱id = Decode(v_医嘱id, Null, 医嘱id, v_医嘱id)
        Where 标本id = 检验标本id_In And 细菌id + 0 = v_项目id And 医嘱id Is Null;
        If Sql%RowCount = 0 Then
          Insert Into 检验项目分布
            (ID, 标本id, 细菌id, 医嘱id, 范围)
          Values
            (检验项目分布_Id.Nextval, 检验标本id_In, v_项目id, v_医嘱id, 1);
        End If;
      End If;
    
      v_Records := Replace('|' || v_Records, '|' || v_Currrec || '|');
    End Loop;
  Else
    If 医嘱id_In Is Not Null Then
      v_Records := 医嘱id_In || ',';
      While v_Records Is Not Null Loop
        v_医嘱id  := Substr(v_Records, 1, Instr(v_Records, ',') - 1);
        v_Records := Substr(v_Records, Instr(v_Records, ',') + 1);
        v_Pos1    := To_Number(v_医嘱id);
        Select Nvl(Max(1), 0) Into v_Pos2 From 检验项目分布 Where 标本id = 检验标本id_In And 医嘱id = v_Pos1;
        If v_Pos2 = 0 Then
          Insert Into 检验项目分布
            (ID, 标本id, 医嘱id, 范围)
          Values
            (检验项目分布_Id.Nextval, 检验标本id_In, v_医嘱id, 1);
        End If;
      End Loop;
    End If;
  End If;

  If 微生物_In = 0 Then
    --通过医嘱来自动合并糖耐量项目 
    Begin
      Select b.检验项目id
      Into v_糖耐量id
      From 检验标本记录 A, 检验普通结果 B, 检验仪器项目 C
      Where a.Id = b.检验标本id And b.检验项目id = c.项目id And a.仪器id = c.仪器id And c.糖耐量项目 = -1 And a.Id = 检验标本id_In And
            b.检验结果 Is Not Null;
    
      Select e.项目id
      Into v_糖耐量id1
      From 检验标本记录 A, 检验项目分布 B, 病人医嘱记录 C, 检验报告项目 D, 检验仪器项目 E
      Where a.Id = b.标本id And b.医嘱id = c.相关id And c.诊疗项目id = d.诊疗项目id And a.仪器id = e.仪器id And d.报告项目id = e.项目id And
            e.糖耐量项目 = -1 And a.Id = 检验标本id_In;
    
      Update 检验普通结果 Set 检验项目id = v_糖耐量id1 Where 检验标本id = 检验标本id_In And 检验项目id = v_糖耐量id;
      Delete 检验普通结果
      Where 检验标本id = 检验标本id_In And 检验结果 Is Null And
            检验项目id In
            (Select b.检验项目id
             From 检验标本记录 A, 检验普通结果 B, 检验仪器项目 C
             Where a.Id = b.检验标本id And b.检验项目id = c.项目id And a.仪器id = c.仪器id And c.糖耐量项目 = -1 And a.Id = 检验标本id_In);
    Exception
      When Others Then
        Null;
    End;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]||v_Error||[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_检验普通结果_Write;
/

--121369:冉俊明,2018-02-07,停诊安排可以对医生的多个号源进行选择停诊
Create Or Replace Procedure Zl_临床出诊停诊_Apply
(
  操作类型_In Number,
  Id_In       临床出诊停诊记录.Id%Type,
  停诊号码_In 临床出诊停诊记录.停诊号码%Type := Null,
  开始时间_In 临床出诊停诊记录.开始时间%Type := Null,
  终止时间_In 临床出诊停诊记录.终止时间%Type := Null,
  停诊原因_In 临床出诊停诊记录.停诊原因%Type := Null,
  申请人_In   临床出诊停诊记录.申请人%Type := Null,
  申请时间_In 临床出诊停诊记录.申请时间%Type := Null,
  登记人_In   临床出诊停诊记录.登记人%Type := Null
) As
  --功能：退费申请以及取消申请 
  --参数： 
  --        操作类型_In：0-申请，else-取消申请 
  --说明： 
  n_Count    Number;
  v_已停号码 临床出诊停诊记录.停诊号码%Type;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  If 操作类型_In = 0 Then
    --申请 
    If 开始时间_In <= Sysdate Then
      v_Error := '停诊时间的开始时间必须大于当前时间！';
      Raise Err_Custom;
    End If;
  
    If 开始时间_In >= 终止时间_In Then
      v_Error := '停诊时间的结束时间必须大于开始时间！';
      Raise Err_Custom;
    End If;
  
    Select Count(1)
    Into n_Count
    From 临床出诊停诊记录
    Where 记录id Is Null And Not (开始时间 > 终止时间_In Or Nvl(失效时间, 终止时间) < 开始时间_In) And 申请人 = 申请人_In And 停诊号码 Is Null And
          Rownum < 2;
    If n_Count <> 0 Then
      v_Error := '当前停诊时间与已申请停诊时间范围存在重叠，请检查！';
      Raise Err_Custom;
    End If;
  
    For c_已停号码 In (Select 停诊号码
                   From 临床出诊停诊记录
                   Where 记录id Is Null And Not (开始时间 > 终止时间_In Or Nvl(失效时间, 终止时间) < 开始时间_In) And 申请人 = 申请人_In And
                         停诊号码 Is Not Null) Loop
      If 停诊号码_In Is Null Then
        v_已停号码 := v_已停号码 || ',' || c_已停号码.停诊号码;
      Else
        For c_号码 In (Select Column_Value As 号码 From Table(f_Str2list(停诊号码_In))) Loop
          If Instr(',' || c_已停号码.停诊号码 || ',', ',' || c_号码.号码 || ',') > 0 Then
            v_已停号码 := v_已停号码 || ',' || c_号码.号码;
          End If;
        End Loop;
      End If;
    End Loop;
    If v_已停号码 Is Not Null Then
      v_已停号码 := Substr(v_已停号码, 2);
      v_Error    := ' 号码(' || v_已停号码 || ')当前停诊时间与已申请停诊时间范围存在重叠，请检查！';
      Raise Err_Custom;
    End If;
  
    Insert Into 临床出诊停诊记录
      (ID, 开始时间, 终止时间, 停诊原因, 申请人, 申请时间, 登记人, 停诊号码)
    Values
      (临床出诊停诊记录_Id.Nextval, 开始时间_In, 终止时间_In, 停诊原因_In, 申请人_In, 申请时间_In, 登记人_In, 停诊号码_In);
  
    Return;
  End If;

  --取消申请 
  Select Count(1) Into n_Count From 临床出诊停诊记录 Where ID = Id_In And 审批人 Is Not Null;
  If n_Count <> 0 Then
    v_Error := '该申请已被审批，不能取消申请。';
    Raise Err_Custom;
  End If;

  Delete 临床出诊停诊记录 Where ID = Id_In;
  If Sql%NotFound Then
    v_Error := '该申请可能已被他人取消申请，请刷新后查看...';
    Raise Err_Custom;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊停诊_Apply;
/

--121369:冉俊明,2018-02-07,停诊安排可以对医生的多个号源进行选择停诊
Create Or Replace Procedure Zl_临床出诊停诊_Audit
(
  操作类型_In Number,
  Id_In       临床出诊停诊记录.Id%Type,
  审批人_In   临床出诊停诊记录.审批人%Type := Null,
  审批时间_In 临床出诊停诊记录.审批时间%Type := Null
) As
  --功能：审批停诊安排 
  --参数： 
  --       状态_In：1-审批，2-取消审批 
  n_Count Number;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  If Nvl(操作类型_In, 0) = 1 Then
    --审批 
    Select Count(1) Into n_Count From 临床出诊停诊记录 Where ID = Id_In And 审批人 Is Not Null;
    If n_Count <> 0 Then
      v_Error := '该申请已被审批，不能再次审批！';
      Raise Err_Custom;
    End If;
  
    Update 临床出诊停诊记录 Set 审批人 = 审批人_In, 审批时间 = 审批时间_In Where ID = Id_In;
    If Sql%NotFound Then
      v_Error := '该申请可能已被取消申请，请刷新后查看...';
      Raise Err_Custom;
    End If;
  
    --对出诊记录进行停诊标记 
    For c_记录 In (Select a.Id, Greatest(a.开始时间, b.开始时间) As 停诊开始时间, Least(a.终止时间, b.终止时间) As 停诊终止时间, b.停诊原因, c.号码, a.是否序号控制,
                        a.是否分时段
                 From 临床出诊记录 A, 临床出诊停诊记录 B, 临床出诊号源 C
                 Where ((a.替诊医生姓名 Is Null And a.医生id Is Not Null And a.医生姓名 = b.申请人) Or
                       (a.替诊医生姓名 Is Not Null And a.替诊医生id Is Not Null And a.替诊医生姓名 = b.申请人)) And a.号源id = c.Id And
                       b.Id = Id_In And Not (a.开始时间 > b.终止时间 Or a.终止时间 < b.开始时间) And Nvl(a.是否发布, 0) = 1 And
                       (b.停诊号码 Is Null Or Instr(',' || b.停诊号码 || ',', ',' || c.号码 || ',') > 0)) Loop
    
      Update 临床出诊记录
      Set 停诊开始时间 = c_记录.停诊开始时间, 停诊终止时间 = c_记录.停诊终止时间, 停诊原因 = c_记录.停诊原因
      Where ID = c_记录.Id;
    
      --调整"临床出诊序号控制.是否停诊"为1 
      Update 临床出诊序号控制 A
      Set 是否停诊 = 1
      Where 记录id = c_记录.Id And 开始时间 Between c_记录.停诊开始时间 And c_记录.停诊终止时间 And Nvl(c_记录.是否序号控制, 0) = 1 And
            Nvl(c_记录.是否分时段, 0) = 1;
    
      Insert Into 病人服务信息记录
        (ID, 通知类型, 记录id, 挂号id, 号源id, 号码, 科室id, 项目id, 医生id, 医生姓名, 病人id, 登记人, 登记时间)
        Select 病人服务信息记录_Id.Nextval, 1, a.Id, b.Id, c.Id, c.号码, c.科室id, a.项目id, a.医生id, a.医生姓名, b.病人id, 审批人_In, 审批时间_In
        From 临床出诊记录 A, 病人挂号记录 B, 临床出诊号源 C
        Where a.Id = b.出诊记录id And a.号源id = c.Id And b.记录状态 = 1 And a.Id = c_记录.Id And
              (b.记录性质 = 1 And b.发生时间 Between a.停诊开始时间 And a.停诊终止时间 Or
              b.记录性质 = 2 And b.预约时间 Between a.停诊开始时间 And a.停诊终止时间);
    
      --消息推送 
      -- 停诊类型(1-停诊,2-取消停诊),出诊记录ID,停诊号码 
      Begin
        Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
          Using 17, 1 || ',' || c_记录.Id || ',' || c_记录.号码;
      Exception
        When Others Then
          Null;
      End;
    End Loop;
    Return;
  End If;

  --取消审批 
  Select Count(1) Into n_Count From 临床出诊停诊记录 Where ID = Id_In And 终止时间 < Sysdate;
  If n_Count <> 0 Then
    v_Error := '该停诊安排已失效，不能取消审批！';
    Raise Err_Custom;
  End If;

  Select Count(1) Into n_Count From 临床出诊停诊记录 Where ID = Id_In And 失效时间 Is Not Null;
  If n_Count <> 0 Then
    v_Error := '该停诊安排已被终止，不能取消审批！';
    Raise Err_Custom;
  End If;

  Select Count(1)
  Into n_Count
  From 临床出诊记录 A, 临床出诊停诊记录 B, 病人服务信息记录 C
  Where Nvl(a.替诊医生姓名, a.医生姓名) = b.申请人 And Nvl(a.替诊医生id, a.医生id) Is Not Null And a.Id = c.记录id And
        (a.开始时间 Between b.开始时间 And b.终止时间 Or a.终止时间 Between b.开始时间 And b.终止时间) And c.处理人 Is Not Null And b.Id = Id_In;
  If Nvl(n_Count, 0) <> 0 Then
    v_Error := '该停诊安排的部分停诊信息已被处理，不能取消审批！';
    Raise Err_Custom;
  End If;

  Update 临床出诊停诊记录 Set 审批人 = Null, 审批时间 = Null Where ID = Id_In And 审批时间 Is Not Null;
  If Sql%NotFound Then
    v_Error := '该安排可能已被他人取消审批，请刷新后查看...';
    Raise Err_Custom;
  End If;

  For c_记录 In (Select a.Id, c.号码
               From 临床出诊记录 A, 临床出诊停诊记录 B, 临床出诊号源 C
               Where ((a.替诊医生姓名 Is Null And a.医生id Is Not Null And a.医生姓名 = b.申请人) Or
                     (a.替诊医生姓名 Is Not Null And a.替诊医生id Is Not Null And a.替诊医生姓名 = b.申请人)) And a.号源id = c.Id And
                     b.Id = Id_In And (a.开始时间 Between b.开始时间 And b.终止时间 Or a.终止时间 Between b.开始时间 And b.终止时间) And
                     Nvl(a.是否发布, 0) = 1 And (b.停诊号码 Is Null Or Instr(',' || b.停诊号码 || ',', ',' || c.号码 || ',') > 0)) Loop
  
    Update 临床出诊记录 Set 停诊开始时间 = Null, 停诊终止时间 = Null, 停诊原因 = Null Where ID = c_记录.Id;
  
    --调整"临床出诊序号控制.是否停诊"为0 
    Update 临床出诊序号控制 Set 是否停诊 = 0 Where 记录id = c_记录.Id And Nvl(是否停诊, 0) = 1;
  
    Delete 病人服务信息记录 Where 记录id = c_记录.Id And 通知类型 = 1 And 处理人 Is Null;
  
    --消息推送 
    -- 停诊类型(1-停诊,2-取消停诊),出诊记录ID,停诊号码 
    Begin
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 17, 2 || ',' || c_记录.Id || ',' || c_记录.号码;
    Exception
      When Others Then
        Null;
    End;
  End Loop;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊停诊_Audit;
/

--121369:冉俊明,2018-02-07,停诊安排可以对医生的多个号源进行选择停诊
Create Or Replace Procedure Zl_临床出诊停诊_Stop
(
  Id_In       临床出诊停诊记录.Id%Type,
  终止人_In   临床出诊停诊记录.取消人%Type,
  终止时间_In 临床出诊停诊记录.失效时间%Type := Null
) As
  --功能：终止停诊安排 
  --参数： 
  --       终止时间_In：Null-立即终止，其它-具体的终止时间 
  v_Error Varchar2(255);
  Err_Custom Exception;

  n_Count Number;
Begin
  If 终止时间_In Is Not Null Then
    If 终止时间_In < Sysdate Then
      v_Error := '终止时间必须大于当前时间！';
      Raise Err_Custom;
    End If;
  End If;

  Select Count(1) Into n_Count From 临床出诊停诊记录 Where ID = Id_In And 终止时间 < Sysdate;
  If n_Count <> 0 Then
    v_Error := '该停诊安排已失效，不能终止！';
    Raise Err_Custom;
  End If;

  Select Count(1) Into n_Count From 临床出诊停诊记录 Where ID = Id_In And 失效时间 Is Not Null;
  If n_Count <> 0 Then
    v_Error := '该停诊安排已被终止，不能再终止！';
    Raise Err_Custom;
  End If;

  Update 临床出诊停诊记录
  Set 失效时间 = Nvl(终止时间_In, Sysdate), 取消人 = 终止人_In, 取消时间 = Sysdate
  Where ID = Id_In And 审批人 Is Not Null;
  If Sql%NotFound Then
    v_Error := '该停诊安排还未审批，不能终止！';
    Raise Err_Custom;
  End If;

  For c_记录 In (Select a.Id, c.号码, a.停诊终止时间, a.是否序号控制, a.是否分时段
               From 临床出诊记录 A, 临床出诊停诊记录 B, 临床出诊号源 C
               Where ((a.替诊医生姓名 Is Null And a.医生id Is Not Null And a.医生姓名 = b.申请人) Or
                     (a.替诊医生姓名 Is Not Null And a.替诊医生id Is Not Null And a.替诊医生姓名 = b.申请人)) And a.号源id = c.Id And
                     b.Id = Id_In And (a.开始时间 Between b.开始时间 And b.终止时间 Or a.终止时间 Between b.开始时间 And b.终止时间) And
                     Nvl(a.是否发布, 0) = 1 And a.停诊终止时间 > Nvl(终止时间_In, Sysdate) And
                     (b.停诊号码 Is Null Or Instr(',' || b.停诊号码 || ',', ',' || c.号码 || ',') > 0)) Loop
  
    Update 临床出诊记录
    Set 停诊开始时间 = Case
                   When 停诊开始时间 >= Nvl(终止时间_In, Sysdate) Then
                    Null
                   Else
                    停诊开始时间
                 End,
        停诊终止时间 = Case
                   When 停诊开始时间 >= Nvl(终止时间_In, Sysdate) Then
                    Null
                   Else
                    Nvl(终止时间_In, Sysdate)
                 End
    Where ID = c_记录.Id;
  
    --调整"临床出诊序号控制.是否停诊"为0 
    Update 临床出诊序号控制
    Set 是否停诊 = 0
    Where 记录id = c_记录.Id And Nvl(是否停诊, 0) = 1 And 开始时间 Between Nvl(终止时间_In, Sysdate) And c_记录.停诊终止时间 And
          Nvl(c_记录.是否序号控制, 0) = 1 And Nvl(c_记录.是否分时段, 0) = 1;
  
    --消息推送 
    -- 停诊类型(1-停诊,2-取消停诊),出诊记录ID,停诊号码 
    Begin
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 17, 2 || ',' || c_记录.Id || ',' || c_记录.号码;
    Exception
      When Others Then
        Null;
    End;
  End Loop;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊停诊_Stop;
/

--121369:冉俊明,2018-02-07,停诊安排可以对医生的多个号源进行选择停诊
Create Or Replace Procedure Zl_Clinicvisitmodify
(
  号源id_In     In 临床出诊记录.号源id%Type,
  安排id_In     In 临床出诊记录.号源id%Type,
  出诊日期_In   In 临床出诊记录.出诊日期%Type,
  登记人_In     In 临床出诊记录.登记人%Type,
  登记时间_In   In 临床出诊记录.登记时间%Type,
  是否已换休_In In Number := 0
) As
  --功能：根据停诊安排和法定节假日调整出诊记录的出诊/预约情况 
  --入参： 
  --     是否已换休_In 主要用于换休后进行停诊处理 
  --说明： 
  --     临床出诊号源.假日控制状态：0-不上班;1-上班且开放预约;2-上班但不开放预约;3-受节假日设置控制 
  --     1-停诊，在停诊安排时间范围内 
  --     2-停诊，在法定节假日内 
  --       2.1临床出诊号源.假日控制状态=0 
  --       2.2临床出诊号源.假日控制状态=3，且设置了允许预约/允许挂号，但该上班时段不在设置的允许预约/允许挂号的时间范围内 
  --     3-禁止预约，在法定节假日内， 
  --       3.1临床出诊号源.假日控制状态=2 
  --       3.3临床出诊号源.假日控制状态=3，设置了允许预约/允许挂号，且该上班时段在设置的允许挂号的时间范围内，但不在设置的允许预约时间范围内 
  --     else-正常出诊 

  n_假日控制状态 临床出诊号源.假日控制状态%Type;
  n_是否假日换休 临床出诊号源.是否假日换休%Type;
  v_号码         临床出诊号源.号码%Type;

  d_原上班日期 临床出诊记录.出诊日期%Type;
  d_调休日期   临床出诊记录.出诊日期%Type;

  d_停诊开始时间 临床出诊记录.停诊开始时间%Type;
  d_停诊终止时间 临床出诊记录.停诊终止时间%Type;
  v_停诊原因     临床出诊记录.停诊原因%Type;

  d_假日开始日期 法定假日表.开始日期%Type;
  d_假日终止日期 法定假日表.终止日期%Type;
  v_允许预约     法定假日表.允许预约日期%Type;
  v_允许挂号     法定假日表.允许挂号日期%Type;

  d_停止预约开始时间 临床出诊记录.停诊开始时间%Type;
  d_停止预约终止时间 临床出诊记录.停诊终止时间%Type;

  n_Count    Number(2);
  n_允许预约 Number(2);
  n_允许挂号 Number(2);

  Procedure Stopbespeak
  (
    记录id_In   In 临床出诊记录.Id%Type,
    开始时间_In In 临床出诊记录.开始时间%Type,
    终止时间_In In 临床出诊记录.终止时间%Type
  ) As
    --功能：禁止预约 
    --说明： 
    --      分时段且序号控制的，修改"临床出诊序号控制.是否预约"等于1的为0；取消发布时根据"预约顺序号"恢复 
    --      分时段且不序号控制的，修改"临床出诊序号控制.是否预约"为0；取消发布时根据恢复为1 
    --      不分时段的，提供公共函数在挂号预约时检查预约时间是否在不允许预约的时间范围内 
  Begin
    Update 临床出诊序号控制 Set 是否预约 = 0 Where 记录id = 记录id_In And 开始时间 Between 开始时间_In And 终止时间_In;
  End Stopbespeak;

  Procedure Stopvisit
  (
    记录id_In       In 临床出诊记录.Id%Type,
    停诊开始时间_In In 临床出诊记录.停诊开始时间%Type,
    停诊终止时间_In In 临床出诊记录.停诊终止时间%Type,
    停诊原因_In     In 临床出诊记录.停诊原因%Type
  ) As
    --功能：停诊 
    --说明： 
    --     同一条出诊记录可以存在多条停诊记录，临床出诊记录的停诊开始时间为多条停诊记录的最小开始时间，停诊终止时间为多条停诊记录的最大终止时间 
  
    d_停诊开始时间 临床出诊记录.停诊开始时间%Type;
    d_停诊终止时间 临床出诊记录.停诊终止时间%Type;
    v_停诊原因     临床出诊记录.停诊原因%Type;
  Begin
    If 停诊开始时间_In >= 停诊终止时间_In Then
      Return;
    End If;
  
    --产生停诊记录 
    Insert Into 临床出诊停诊记录
      (ID, 记录id, 开始时间, 终止时间, 停诊原因, 申请人, 申请时间, 审批人, 审批时间, 登记人)
      Select 临床出诊停诊记录_Id.Nextval, ID, 停诊开始时间_In, 停诊终止时间_In, 停诊原因_In, Nvl(医生姓名, 登记人_In), 登记时间_In, 登记人_In, 登记时间_In, 登记人_In
      From 临床出诊记录
      Where ID = 记录id_In;
  
    Begin
      Select Min(a.开始时间), Max(a.终止时间), Max(a.停诊原因)
      Into d_停诊开始时间, d_停诊终止时间, v_停诊原因
      From 临床出诊停诊记录 A
      Where a.记录id = 记录id_In And a.取消时间 Is Null;
    Exception
      When Others Then
        d_停诊开始时间 := Null;
        d_停诊终止时间 := Null;
        v_停诊原因     := Null;
    End;
  
    Update 临床出诊记录
    Set 停诊开始时间 = d_停诊开始时间, 停诊终止时间 = d_停诊终止时间, 停诊原因 = v_停诊原因
    Where ID = 记录id_In;
  
    --调整"临床出诊序号控制.是否停诊"为1 
    Update 临床出诊序号控制 A
    Set 是否停诊 = 1
    Where 记录id = 记录id_In And 开始时间 Between 停诊开始时间_In And 停诊终止时间_In And Exists
     (Select 1 From 临床出诊记录 Where ID = a.记录id And Nvl(是否序号控制, 0) = 1 And Nvl(是否分时段, 0) = 1);
  End Stopvisit;

  Procedure Changedaysoff
  (
    号源id_In     In 临床出诊记录.号源id%Type,
    安排id_In     In 临床出诊记录.安排id%Type,
    出诊日期_In   In 临床出诊记录.出诊日期%Type,
    原上班日期_In In 临床出诊记录.出诊日期%Type,
    调休日期_In   In 临床出诊记录.出诊日期%Type
  ) As
    --功能：换休处理 
    n_安排id 临床出诊记录.安排id%Type;
    l_记录id t_Numlist := t_Numlist();
    n_Count  Number(2);
  Begin
    --1.前面的安排换到今日 
    If 原上班日期_In Is Not Null Then
      --1.1.前面的日期没有安排则不处理 
      Select Count(1)
      Into n_Count
      From 临床出诊记录
      Where 号源id = 号源id_In And 出诊日期 = 原上班日期_In And Rownum < 2;
    
      If Nvl(n_Count, 0) > 0 Then
        --[1]删除今日现有的安排 
        Select ID Bulk Collect Into l_记录id From 临床出诊记录 Where 号源id = 号源id_In And 出诊日期 = 出诊日期_In;
        Zl_临床出诊记录_Batchdelete(l_记录id);
      
        --[2]复制安排 
        For c_换休记录 In (Select ID, 是否发布 From 临床出诊记录 Where 号源id = 号源id_In And 出诊日期 = 原上班日期_In) Loop
          Zl_临床出诊记录_Copy(c_换休记录.Id, 安排id_In, 出诊日期_In, 登记人_In, 登记时间_In, c_换休记录.是否发布);
        End Loop;
      
        --[3]重新对今日进行停诊安排和法定节假日调整 
        For c_记录 In (Select ID From 临床出诊记录 Where 号源id = 号源id_In And 出诊日期 = 出诊日期_In) Loop
          Zl_Clinicvisitmodify(号源id_In, 安排id_In, 出诊日期_In, 登记人_In, 登记时间_In, 1);
        End Loop;
      End If;
    End If;
  
    --2.今日的安排换到前面 
    If 调休日期_In Is Not Null Then
      --2.1.今日没有安排则不处理 
      Select Count(1)
      Into n_Count
      From 临床出诊记录
      Where 号源id = 号源id_In And 出诊日期 = 出诊日期_In And Rownum < 2;
    
      If Nvl(n_Count, 0) > 0 Then
        --2.2.前面那一天的安排已存在预约挂号记录则不替换(有漏洞) 
        Select Count(1)
        Into n_Count
        From 临床出诊记录 A, 病人挂号记录 B
        Where a.Id = b.出诊记录id And a.号源id = 号源id_In And a.出诊日期 = 调休日期_In And Rownum < 2;
      
        If Nvl(n_Count, 0) = 0 Then
          --[1]记录前面那一天的原安排ID,没有就不处理 
          Begin
            Select ID
            Into n_安排id
            From (Select Rownum As Rn, ID
                   From 临床出诊安排
                   Where 号源id = 号源id_In And 调休日期_In Between 开始时间 And 终止时间 And 审核时间 Is Not Null
                   Order By 登记时间 Desc)
            Where Rn < 2;
          Exception
            When Others Then
              n_安排id := 0;
          End;
        
          If Nvl(n_安排id, 0) <> 0 Then
            --[2]删除前面那一天现有的安排 
            Select ID Bulk Collect Into l_记录id From 临床出诊记录 Where 号源id = 号源id_In And 出诊日期 = 调休日期_In;
            Zl_临床出诊记录_Batchdelete(l_记录id);
          
            --[3]复制安排 
            For c_换休记录 In (Select ID From 临床出诊记录 Where 号源id = 号源id_In And 出诊日期 = 出诊日期_In) Loop
              --肯定是发布了的 
              Zl_临床出诊记录_Copy(c_换休记录.Id, n_安排id, 调休日期_In, 登记人_In, 登记时间_In, 1);
            
            End Loop;
          
            --[4]重新对前面那一天进行停诊安排和法定节假日调整 
            For c_记录 In (Select ID From 临床出诊记录 Where 号源id = 号源id_In And 出诊日期 = 调休日期_In) Loop
              Zl_Clinicvisitmodify(号源id_In, 安排id_In, 调休日期_In, 登记人_In, 登记时间_In, 1);
            End Loop;
          End If;
        End If;
      End If;
    End If;
  End Changedaysoff;
Begin
  Begin
    Select Nvl(b.假日控制状态, 0), Nvl(b.是否假日换休, 0), 号码
    Into n_假日控制状态, n_是否假日换休, v_号码
    From 临床出诊号源 B
    Where b.Id = 号源id_In;
  Exception
    When Others Then
      --没有找到号源，直接退出 
      Return;
  End;

  --================================================================================ 
  --【1】假日换休处理 
  --说明：只能用后面的日期向前面检查，因为后面的日期可能还没有制定安排 
  --================================================================================ 
  If Nvl(是否已换休_In, 0) = 0 Then
    --确定法定节假日是否需要换休 
    If Nvl(n_是否假日换休, 0) = 1 Then
      --1.前面的安排换到今日 
      Begin
        --开始日期：原本休息日(即调休日) ， 终止日期：原本上班日(即被调休日) 
        Select a.终止日期
        Into d_原上班日期
        From 法定假日表 A
        Where a.性质 = 1 And 出诊日期_In = a.开始日期 And a.终止日期 < 出诊日期_In And Rownum < 2;
      Exception
        When Others Then
          d_原上班日期 := Null;
      End;
    
      --2.今日的安排换到前面 
      Begin
        --开始日期：原本休息日(即调休日) ， 终止日期：原本上班日(即被调休日) 
        Select a.开始日期
        Into d_调休日期
        From 法定假日表 A
        Where a.性质 = 1 And 出诊日期_In = a.终止日期 And a.开始日期 < 出诊日期_In And Rownum < 2;
      Exception
        When Others Then
          d_调休日期 := Null;
      End;
    
      Changedaysoff(号源id_In, 安排id_In, 出诊日期_In, d_原上班日期, d_调休日期);
    End If;
  End If;

  For c_记录 In (Select ID, 出诊日期, 开始时间, 终止时间
               From 临床出诊记录
               Where 号源id = 号源id_In And 出诊日期 = 出诊日期_In And 上班时段 Is Not Null) Loop
    --================================================================================ 
    --【2】停诊安排停诊处理 
    --================================================================================ 
    For c_停诊 In (Select a.开始时间, Nvl(a.失效时间, a.终止时间) As 终止时间, a.停诊原因
                 From 临床出诊停诊记录 A, 临床出诊记录 B
                 Where a.申请人 = b.医生姓名 And a.记录id Is Null And a.审批时间 Is Not Null And b.医生id Is Not Null And
                       b.Id = c_记录.Id And c_记录.开始时间 < Nvl(a.失效时间, a.终止时间) And c_记录.终止时间 > a.开始时间 And
                       (a.停诊号码 Is Null Or Instr(',' || a.停诊号码 || ',', ',' || v_号码 || ',') > 0)
                 Order By a.审批时间) Loop
    
      d_停诊开始时间 := c_停诊.开始时间;
      d_停诊终止时间 := c_停诊.终止时间;
      If d_停诊开始时间 < c_记录.开始时间 Then
        d_停诊开始时间 := c_记录.开始时间;
      End If;
      If d_停诊终止时间 > c_记录.终止时间 Then
        d_停诊终止时间 := c_记录.终止时间;
      End If;
      Stopvisit(c_记录.Id, d_停诊开始时间, d_停诊终止时间, c_停诊.停诊原因);
    End Loop;
  
    --================================================================================ 
    --【3】法定节假日停诊及禁止预约处理 
    --================================================================================ 
    --1.查找含有上班时段时间的节假日，以第一个为准（开始时间升序排序），一般也只有一个 
    Begin
      Select 开始日期, 终止日期, 节日名称, 允许预约日期, 允许挂号日期
      Into d_假日开始日期, d_假日终止日期, v_停诊原因, v_允许预约, v_允许挂号
      From (Select a.开始日期, a.终止日期, a.节日名称, a.允许预约日期, a.允许挂号日期
             From 法定假日表 A
             Where a.性质 = 0 And c_记录.开始时间 < a.终止日期 And c_记录.终止时间 > a.开始日期
             Order By a.开始日期)
      Where Rownum < 2;
    Exception
      When Others Then
        d_假日开始日期 := Null;
        d_假日终止日期 := Null;
        v_停诊原因     := Null;
        v_允许预约     := Null;
        v_允许挂号     := Null;
    End;
  
    If v_停诊原因 Is Not Null Then
      --假日控制状态:0-不上班;1-上班且开放预约;2-上班但不开放预约;3-受节假日设置控制 
      If Nvl(n_假日控制状态, 0) = 0 Then
        --不上班，停诊 
        d_停诊开始时间 := d_假日开始日期;
        d_停诊终止时间 := d_假日终止日期 + 1 - 1 / 24 / 60 / 60;
        If d_停诊开始时间 < c_记录.开始时间 Then
          d_停诊开始时间 := c_记录.开始时间;
        End If;
        If d_停诊终止时间 > c_记录.终止时间 Then
          d_停诊终止时间 := c_记录.终止时间;
        End If;
        Stopvisit(c_记录.Id, d_停诊开始时间, d_停诊终止时间, v_停诊原因);
      Elsif Nvl(n_假日控制状态, 0) = 2 Then
        --允许挂号，但禁止预约 
        d_停止预约开始时间 := d_假日开始日期;
        d_停止预约终止时间 := d_假日终止日期 + 1 - 1 / 24 / 60 / 60;
        If d_停止预约开始时间 < c_记录.开始时间 Then
          d_停止预约开始时间 := c_记录.开始时间;
        End If;
        If d_停止预约终止时间 > c_记录.终止时间 Then
          d_停止预约终止时间 := c_记录.终止时间;
        End If;
        Stopbespeak(c_记录.Id, d_停止预约开始时间, d_停止预约终止时间);
      Elsif Nvl(n_假日控制状态, 0) = 3 Then
        --没有"允许挂号"的就一定没有"允许预约"的 
        If v_允许挂号 Is Not Null Then
          --2.检查是否有包含上班时段时间的"允许挂号" 
          --因为上班时段最多24小时，所以查出的结果最多两天，且这两天一定是连续的 
          n_允许挂号 := 0;
          For c_允许挂号 In (With 临时表 As
                            (Select To_Date(Column_Value, 'yyyy-mm-dd') As 开始时间,
                                   To_Date(Column_Value, 'yyyy-mm-dd') + 1 - 1 / 24 / 60 / 60 As 终止时间
                            From Table(f_Str2list(v_允许挂号, ';'))
                            Where c_记录.开始时间 < To_Date(Column_Value, 'yyyy-mm-dd') + 1 - 1 / 24 / 60 / 60 And
                                  c_记录.终止时间 > To_Date(Column_Value, 'yyyy-mm-dd')
                            Order By To_Date(Column_Value, 'yyyy-mm-dd'))
                           Select a.开始时间, Nvl(b.终止时间, a.终止时间) As 终止时间
                           From 临时表 A, 临时表 B
                           Where a.终止时间 = b.开始时间(+) - 1 / 24 / 60 / 60 And Rownum < 2) Loop
          
            n_允许挂号 := 1;
            n_允许预约 := 0;
            --3.检查是否有包含上班时段时间的"允许预约" 
            For c_允许预约 In (With 临时表 As
                              (Select To_Date(Column_Value, 'yyyy-mm-dd') As 开始时间,
                                     To_Date(Column_Value, 'yyyy-mm-dd') + 1 - 1 / 24 / 60 / 60 As 终止时间
                              From Table(f_Str2list(v_允许预约, ';'))
                              Where c_记录.开始时间 < To_Date(Column_Value, 'yyyy-mm-dd') + 1 - 1 / 24 / 60 / 60 And
                                    c_记录.终止时间 > To_Date(Column_Value, 'yyyy-mm-dd')
                              Order By To_Date(Column_Value, 'yyyy-mm-dd'))
                             Select a.开始时间, Nvl(b.终止时间, a.终止时间) As 终止时间
                             From 临时表 A, 临时表 B
                             Where a.终止时间 = b.开始时间(+) - 1 / 24 / 60 / 60 And Rownum < 2) Loop
            
              n_允许预约 := 1;
              --在"允许挂号","允许预约"时间范围内的不需要处理 
            
              --检查前后是否需要禁止预约 
              If c_记录.开始时间 < c_允许预约.开始时间 And c_允许挂号.开始时间 < c_允许预约.开始时间 Then
                If c_记录.开始时间 < c_允许挂号.开始时间 Then
                  d_停止预约开始时间 := c_允许挂号.开始时间;
                Else
                  d_停止预约开始时间 := c_记录.开始时间;
                End If;
                d_停止预约终止时间 := c_允许预约.开始时间;
                Stopbespeak(c_记录.Id, d_停止预约开始时间, d_停止预约终止时间);
              End If;
            
              If c_记录.终止时间 > c_允许预约.终止时间 And c_允许挂号.终止时间 > c_允许预约.终止时间 Then
                d_停止预约开始时间 := c_允许预约.终止时间;
                If c_记录.终止时间 > c_允许挂号.终止时间 Then
                  d_停止预约开始时间 := c_允许挂号.终止时间;
                Else
                  d_停止预约开始时间 := c_记录.终止时间;
                End If;
                Stopbespeak(c_记录.Id, d_停止预约开始时间, d_停止预约终止时间);
              End If;
            End Loop;
          
            --允许挂号，但禁止预约 
            If Nvl(n_允许预约, 0) = 0 Then
              d_停止预约开始时间 := c_允许挂号.开始时间;
              d_停止预约终止时间 := c_允许挂号.终止时间;
              If d_停止预约开始时间 < c_记录.开始时间 Then
                d_停止预约开始时间 := c_记录.开始时间;
              End If;
              If d_停止预约终止时间 > c_记录.终止时间 Then
                d_停止预约终止时间 := c_记录.终止时间;
              End If;
              Stopbespeak(c_记录.Id, d_停止预约开始时间, d_停止预约终止时间);
            End If;
          
            --检查前后是否需要停诊 
            If c_记录.开始时间 < c_允许挂号.开始时间 And d_假日开始日期 < c_允许挂号.开始时间 Then
              If c_记录.开始时间 < d_假日开始日期 Then
                d_停诊开始时间 := d_假日开始日期;
              Else
                d_停诊开始时间 := c_记录.开始时间;
              End If;
              d_停诊终止时间 := c_允许挂号.开始时间;
              Stopvisit(c_记录.Id, d_停诊开始时间, d_停诊终止时间, v_停诊原因);
            End If;
          
            If c_记录.终止时间 > c_允许挂号.终止时间 And d_假日终止日期 > c_允许挂号.终止时间 Then
              d_停诊开始时间 := c_允许挂号.终止时间;
              If c_记录.终止时间 > d_假日终止日期 Then
                d_停诊终止时间 := d_停诊终止时间;
              Else
                d_停诊终止时间 := c_记录.终止时间;
              End If;
              Stopvisit(c_记录.Id, d_停诊开始时间, d_停诊终止时间, v_停诊原因);
            End If;
          End Loop;
        
          --不在设置的允许挂号时间范围内，停诊 
          If Nvl(n_允许挂号, 0) = 0 Then
            d_停诊开始时间 := d_假日开始日期;
            d_停诊终止时间 := d_假日终止日期 + 1 - 1 / 24 / 60 / 60;
            If d_停诊开始时间 < c_记录.开始时间 Then
              d_停诊开始时间 := c_记录.开始时间;
            End If;
            If d_停诊终止时间 > c_记录.终止时间 Then
              d_停诊终止时间 := c_记录.终止时间;
            End If;
            Stopvisit(c_记录.Id, d_停诊开始时间, d_停诊终止时间, v_停诊原因);
          End If;
        Else
          --未设置允许挂号/允许预约，则停诊 
          d_停诊开始时间 := d_假日开始日期;
          d_停诊终止时间 := d_假日终止日期 + 1 - 1 / 24 / 60 / 60;
          If d_停诊开始时间 < c_记录.开始时间 Then
            d_停诊开始时间 := c_记录.开始时间;
          End If;
          If d_停诊终止时间 > c_记录.终止时间 Then
            d_停诊终止时间 := c_记录.终止时间;
          End If;
          Stopvisit(c_记录.Id, d_停诊开始时间, d_停诊终止时间, v_停诊原因);
        End If;
      End If;
    End If;
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Clinicvisitmodify;
/

--121883:董露露,2018-02-07,处理病人入院管理登记保存后，病人信息表中病人类型为空
Create Or Replace Procedure Zl_入院病案主页_Insert
(
  登记模式_In       Number,
  病人性质_In       病案主页.病人性质%Type,
  病人id_In         病人信息.病人id%Type,
  住院号_In         病人信息.住院号%Type,
  医保号_In         保险帐户.医保号%Type,
  姓名_In           病人信息.姓名%Type,
  性别_In           病人信息.性别%Type,
  年龄_In           病人信息.年龄%Type,
  费别_In           病人信息.费别%Type,
  出生日期_In       病人信息.出生日期%Type,
  国籍_In           病人信息.国籍%Type,
  民族_In           病人信息.民族%Type,
  学历_In           病人信息.学历%Type,
  婚姻状况_In       病人信息.婚姻状况%Type,
  职业_In           病人信息.职业%Type,
  身份_In           病人信息.身份%Type,
  身份证号_In       病人信息.身份证号%Type,
  出生地点_In       病人信息.出生地点%Type,
  家庭地址_In       病人信息.家庭地址%Type,
  家庭地址邮编_In   病人信息.家庭地址邮编%Type,
  家庭电话_In       病人信息.家庭电话%Type,
  户口地址_In       病人信息.户口地址%Type,
  户口地址邮编_In   病人信息.户口地址邮编%Type,
  联系人姓名_In     病人信息.联系人姓名%Type,
  联系人关系_In     病人信息.联系人关系%Type,
  联系人地址_In     病人信息.联系人地址%Type,
  联系人电话_In     病人信息.联系人电话%Type,
  工作单位_In       病人信息.工作单位%Type,
  合同单位id_In     病人信息.合同单位id%Type,
  单位电话_In       病人信息.单位电话%Type,
  单位邮编_In       病人信息.单位邮编%Type,
  单位开户行_In     病人信息.单位开户行%Type,
  单位帐号_In       病人信息.单位帐号%Type,
  担保人_In         病人信息.担保人%Type,
  担保额_In         病人信息.担保额%Type,
  担保性质_In       病人信息.担保性质%Type,
  入院科室id_In     病案主页.入院科室id%Type,
  护理等级id_In     病案主页.护理等级id%Type,
  入院病况_In       病案主页.入院病况%Type,
  入院方式_In       病案主页.入院方式%Type,
  住院目的_In       病案主页.住院目的%Type,
  二级院转入_In     病案主页.二级院转入%Type,
  门诊医师_In       病案主页.门诊医师%Type,
  籍贯_In           病人信息.籍贯%Type,
  区域_In           病案主页.区域%Type,
  入院时间_In       病案主页.入院日期%Type,
  是否陪伴_In       病案主页.是否陪伴%Type,
  床号_In           病案主页.入院病床%Type,
  付款方式_In       病案主页.医疗付款方式%Type,
  疾病id_In         病人诊断记录.疾病id%Type,
  诊断id_In         病人诊断记录.诊断id%Type,
  门诊诊断_In       病人诊断记录.诊断描述%Type,
  中医疾病id_In     病人诊断记录.疾病id%Type,
  中医诊断id_In     病人诊断记录.诊断id%Type,
  中医诊断_In       病人诊断记录.诊断描述%Type,
  险类_In           病案主页.险类%Type,
  操作员编号_In     病案主页.编目员编号%Type,
  操作员姓名_In     病案主页.编目员姓名%Type,
  新病人_In         Number := 1,
  备注_In           病案主页.备注%Type,
  入院病区id_In     病案主页.入院病区id%Type,
  再入院_In         病案主页.再入院%Type,
  入院属性_In       病案主页.入院属性%Type := Null,
  主页id_In         病案主页.主页id%Type := Null,
  住院次数_In       病人信息.住院次数%Type := Null,
  其他证件_In       病人信息.其他证件%Type := Null,
  病人类型_In       病案主页.病人类型%Type := Null,
  联系人身份证号_In 病人信息.联系人身份证号%Type := Null,
  手机号_In         病人信息.手机号%Type := Null
) As
  -----------------------------------------------------------
  --功能：对入院病人新增一张病案主页，同时可能处理入科。
  --参数：
  --      登记模式_IN=0-正常登记,1-预约登记,2-接收预约(新病人_IN=0)
  --      病人性质_IN=对应"病案主页.病人性质"
  --      床号_IN=Null:不同时入科;'家庭病床':分配家庭病床,填为空;其他:分配具体床位。
  --      新病人_IN=如果是已有档案的病人入院,则该参数为0；缺省为新病人
  --      入院病区ID_IN=只有当使用[病区管理病床]模式(参数号99)时,并且入院同时入科分床时,才有值
  --      住院号_In = 登记门诊留观病人时 住院号_In 为病人门诊号
  -----------------------------------------------------------
  v_主页id   病案主页.主页id%Type;
  v_等级id   床位状况记录.等级id%Type;
  n_住院次数 病人信息.住院次数%Type;

  v_费别      病案主页.费别%Type;
  v_Count     Number;
  n_Uniqueid  Number;
  v_Date      Date;
  d_Indeptime Date;
  v_Error     Varchar2(255);
  Err_Custom Exception;
Begin
  --判断病人是否锁定
  Select Count(病人id) Into v_Count From 病人信息 Where 病人id = 病人id_In;
  If v_Count <> 0 Then
    Zl_病人信息_锁定检查(病人id_In);
  End If;

  Select Sysdate Into v_Date From Dual;
  Zl_病区标记记录_Clear(病人id_In);
  
  --身份证号不等于空,根据系统参数判读是否唯一建档病人
  If 身份证号_In Is Not Null Then
    n_Uniqueid := Nvl(zl_GetSysParameter(279), 0);
    If n_Uniqueid = 1 Then
      Select Count(1) Into v_Count From 病人信息 Where 身份证号 = 身份证号_In And 病人id <> Nvl(病人id_In, 0);
      If v_Count <> 0 Then
        v_Error := '已经存在身份证号为' || 身份证号_In || '的病人,不能再录入相同的身份证号!';
        Raise Err_Custom;
      End If;
    End If;
  End If;

  --病人基本信息
  If 病人性质_In = 1 Then
    If 新病人_In = 1 Then
      Insert Into 病人信息
        (病人id, 门诊号, 住院号, 姓名, 性别, 年龄, 费别, 医疗付款方式, 出生日期, 国籍, 民族, 籍贯, 区域, 学历, 婚姻状况, 职业, 身份, 身份证号, 出生地点, 家庭地址, 家庭地址邮编, 家庭电话,
         户口地址, 户口地址邮编, 联系人姓名, 联系人关系, 联系人地址, 联系人电话, 工作单位, 合同单位id, 单位电话, 单位邮编, 单位开户行, 单位帐号, 担保人, 担保额, 担保性质, 险类, 登记时间, 其他证件, 病人类型,
         联系人身份证号, 手机号)
      Values
        (病人id_In, 住院号_In, Null, 姓名_In, 性别_In, 年龄_In, 费别_In, 付款方式_In, 出生日期_In, 国籍_In, 民族_In, 籍贯_In, 区域_In, 学历_In,
         婚姻状况_In, 职业_In, 身份_In, 身份证号_In, 出生地点_In, 家庭地址_In, 家庭地址邮编_In, 家庭电话_In, 户口地址_In, 户口地址邮编_In, 联系人姓名_In, 联系人关系_In,
         联系人地址_In, 联系人电话_In, 工作单位_In, Decode(合同单位id_In, 0, Null, 合同单位id_In), 单位电话_In, 单位邮编_In, 单位开户行_In, 单位帐号_In, 担保人_In,
         Decode(担保额_In, 0, Null, 担保额_In), 担保性质_In, 险类_In, v_Date, 其他证件_In, 病人类型_In, 联系人身份证号_In, 手机号_In);
    Else
      --老病人的门诊费别不变,除非是门诊留观病人
      Update 病人信息
      Set 门诊号 = 住院号_In, 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In, 费别 = Decode(病人性质_In, 1, 费别_In, 费别), 医疗付款方式 = 付款方式_In,
          出生日期 = 出生日期_In, 国籍 = 国籍_In, 民族 = 民族_In, 籍贯 = 籍贯_In, 区域 = 区域_In, 学历 = 学历_In, 婚姻状况 = 婚姻状况_In, 职业 = 职业_In,
          身份 = 身份_In, 身份证号 = 身份证号_In, 出生地点 = 出生地点_In, 家庭地址 = 家庭地址_In, 家庭地址邮编 = 家庭地址邮编_In, 家庭电话 = 家庭电话_In, 户口地址 = 户口地址_In,
          户口地址邮编 = 户口地址邮编_In, 联系人姓名 = 联系人姓名_In, 联系人关系 = 联系人关系_In, 联系人地址 = 联系人地址_In, 联系人电话 = 联系人电话_In, 工作单位 = 工作单位_In,
          合同单位id = Decode(合同单位id_In, 0, Null, 合同单位id_In), 单位电话 = 单位电话_In, 单位邮编 = 单位邮编_In, 单位开户行 = 单位开户行_In,
          单位帐号 = 单位帐号_In, 担保人 = 担保人_In, 担保额 = Decode(担保额_In, 0, Null, 担保额_In), 担保性质 = 担保性质_In, 险类 = 险类_In,
          其他证件 = 其他证件_In, 病人类型=病人类型_In, 联系人身份证号 = 联系人身份证号_In, 手机号 = Nvl(手机号_In, 手机号)
      Where 病人id = 病人id_In;
    End If;
  Else
    If 新病人_In = 1 Then
      Insert Into 病人信息
        (病人id, 住院号, 姓名, 性别, 年龄, 费别, 医疗付款方式, 出生日期, 国籍, 民族, 籍贯, 区域, 学历, 婚姻状况, 职业, 身份, 身份证号, 出生地点, 家庭地址, 家庭地址邮编, 家庭电话,
         户口地址, 户口地址邮编, 联系人姓名, 联系人关系, 联系人地址, 联系人电话, 工作单位, 合同单位id, 单位电话, 单位邮编, 单位开户行, 单位帐号, 担保人, 担保额, 担保性质, 险类, 登记时间, 其他证件, 病人类型,
         联系人身份证号, 手机号)
      Values
        (病人id_In, Decode(病人性质_In, 2, Null, 住院号_In), 姓名_In, 性别_In, 年龄_In, 费别_In, 付款方式_In, 出生日期_In, 国籍_In, 民族_In, 籍贯_In,
         区域_In, 学历_In, 婚姻状况_In, 职业_In, 身份_In, 身份证号_In, 出生地点_In, 家庭地址_In, 家庭地址邮编_In, 家庭电话_In, 户口地址_In, 户口地址邮编_In,
         联系人姓名_In, 联系人关系_In, 联系人地址_In, 联系人电话_In, 工作单位_In, Decode(合同单位id_In, 0, Null, 合同单位id_In), 单位电话_In, 单位邮编_In,
         单位开户行_In, 单位帐号_In, 担保人_In, Decode(担保额_In, 0, Null, 担保额_In), 担保性质_In, 险类_In, v_Date, 其他证件_In, 病人类型_In, 联系人身份证号_In, 手机号_In);
    Else
      --老病人的门诊费别不变,除非是门诊留观病人
      Update 病人信息
      Set 住院号 = Decode(病人性质_In, 2, 住院号, Decode(住院号_In, Null, 住院号, 住院号_In)), 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In,
          费别 = Decode(病人性质_In, 1, 费别_In, 费别), 医疗付款方式 = 付款方式_In, 出生日期 = 出生日期_In, 国籍 = 国籍_In, 民族 = 民族_In, 籍贯 = 籍贯_In,
          区域 = 区域_In, 学历 = 学历_In, 婚姻状况 = 婚姻状况_In, 职业 = 职业_In, 身份 = 身份_In, 身份证号 = 身份证号_In, 出生地点 = 出生地点_In, 家庭地址 = 家庭地址_In,
          家庭地址邮编 = 家庭地址邮编_In, 家庭电话 = 家庭电话_In, 户口地址 = 户口地址_In, 户口地址邮编 = 户口地址邮编_In, 联系人姓名 = 联系人姓名_In, 联系人关系 = 联系人关系_In,
          联系人地址 = 联系人地址_In, 联系人电话 = 联系人电话_In, 工作单位 = 工作单位_In, 合同单位id = Decode(合同单位id_In, 0, Null, 合同单位id_In),
          单位电话 = 单位电话_In, 单位邮编 = 单位邮编_In, 单位开户行 = 单位开户行_In, 单位帐号 = 单位帐号_In, 担保人 = 担保人_In,
          担保额 = Decode(担保额_In, 0, Null, 担保额_In), 担保性质 = 担保性质_In, 险类 = 险类_In, 其他证件 = 其他证件_In, 病人类型=病人类型_In, 联系人身份证号 = 联系人身份证号_In,
          手机号 = Nvl(手机号_In, 手机号)
      Where 病人id = 病人id_In;
    End If;
  End If;

  --病案信息
  Begin
    If 登记模式_In = 1 Then
      v_主页id := 0; --预约登记记录的主页ID=0
    Else
      If 主页id_In Is Null Then
        Select Nvl(Max(主页id), 0) + 1 Into v_主页id From 病案主页 Where 病人id = 病人id_In And Nvl(主页id, 0) <> 0;
      Else
        v_主页id := 主页id_In;
      End If;
    End If;
  Exception
    When Others Then
      Null;
  End;

  If 登记模式_In <> 1 Then
    Update 病人信息
    Set 主页id = v_主页id, 当前病区id = 入院病区id_In, 当前科室id = 入院科室id_In, 当前床号 = Decode(床号_In, '家庭病床', Null, 床号_In), 入院时间 = 入院时间_In,
        出院时间 = Null, 在院 = 1
    Where 病人id = 病人id_In;
  End If;

  --更新住院次数
  If 登记模式_In <> 1 And 病人性质_In = 0 Then
    If Nvl(住院次数_In, 0) = 0 Then
      Select Nvl(住院次数, 0) + 1 Into n_住院次数 From 病人信息 Where 病人id = 病人id_In;
    Else
      n_住院次数 := 住院次数_In;
    End If;
    Update 病人信息 Set 住院次数 = n_住院次数 Where 病人id = 病人id_In;
  End If;

  --取入科时间
  If 床号_In Is Null Then
    d_Indeptime := Null;
  Else
    d_Indeptime := 入院时间_In;
  End If;

  --状态：0-正常在院,1-等待入科,2-等待转科
  If 登记模式_In = 2 Then
    --处理病案主页从表
    Delete From 病案主页从表 Where 病人id = 病人id_In And Nvl(主页id, 0) = 0;
    --接收预约
    Update 病案主页
    Set 主页id = v_主页id, 病人性质 = 病人性质_In, 住院号 = Decode(病人性质_In, 1, Null, 2, Null, 住院号_In),
        留观号 = Decode(病人性质_In, 2, 住院号_In, Null),
        --主页ID变更,病人性质可能变更
        费别 = 费别_In, 入院病区id = 入院病区id_In, 入院科室id = 入院科室id_In, 入院日期 = 入院时间_In, 入科时间 = d_Indeptime, 入院病况 = 入院病况_In,
        入院方式 = 入院方式_In, 入院属性 = 入院属性_In, 二级院转入 = 二级院转入_In, 住院目的 = 住院目的_In, 入院病床 = Decode(床号_In, '家庭病床', Null, 床号_In),
        是否陪伴 = 是否陪伴_In, 当前病况 = 入院病况_In, 当前病区id = 入院病区id_In, 护理等级id = Decode(护理等级id_In, 0, Null, 护理等级id_In),
        出院科室id = 入院科室id_In, 出院病床 = Decode(床号_In, '家庭病床', Null, 床号_In), 门诊医师 = 门诊医师_In, 编目员编号 = 操作员编号_In,
        编目员姓名 = 操作员姓名_In, 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In, 婚姻状况 = 婚姻状况_In, 职业 = 职业_In, 国籍 = 国籍_In, 学历 = 学历_In,
        单位电话 = 单位电话_In, 单位邮编 = 单位邮编_In, 单位地址 = 工作单位_In, 区域 = 区域_In, 家庭地址 = 家庭地址_In, 家庭电话 = 家庭电话_In, 家庭地址邮编 = 家庭地址邮编_In,
        户口地址 = 户口地址_In, 户口地址邮编 = 户口地址邮编_In, 联系人姓名 = 联系人姓名_In, 联系人关系 = 联系人关系_In, 联系人地址 = 联系人地址_In, 联系人身份证号 = 联系人身份证号_In,
        联系人电话 = 联系人电话_In, 医疗付款方式 = 付款方式_In, 备注 = 备注_In, 险类 = 险类_In, 状态 = Decode(床号_In, Null, 1, 0), 登记人 = 操作员姓名_In,
        登记时间 = v_Date, 再入院 = 再入院_In, 病人类型 = 病人类型_In
    Where 病人id = 病人id_In And Nvl(主页id, 0) = 0;
    Update 病人预交记录
    Set 主页id = 主页id_In
    Where 病人id = 病人id_In And 主页id Is Null And 科室id = 入院科室id_In And 预交类别 = 2 And 冲预交 Is Null And
          Trunc(收款时间) = Trunc(Sysdate);
  Else
    --入院登记或预约登记
    Insert Into 病案主页
      (病人性质, 病人id, 主页id, 住院号, 留观号, 费别, 入院病区id, 入院科室id, 入院日期, 入科时间, 入院病况, 入院方式, 入院属性, 二级院转入, 住院目的, 入院病床, 是否陪伴, 当前病况,
       当前病区id, 护理等级id, 出院科室id, 出院病床, 门诊医师, 编目员编号, 编目员姓名, 状态, 姓名, 性别, 年龄, 婚姻状况, 职业, 国籍, 学历, 单位电话, 单位邮编, 单位地址, 区域, 家庭地址,
       家庭电话, 家庭地址邮编, 户口地址, 户口地址邮编, 联系人姓名, 联系人关系, 联系人地址, 联系人电话, 联系人身份证号, 医疗付款方式, 险类, 备注, 登记人, 登记时间, 再入院, 病人类型)
    Values
      (病人性质_In, 病人id_In, v_主页id, Decode(病人性质_In, 1, Null, 2, Null, 住院号_In), Decode(病人性质_In, 2, 住院号_In, Null), 费别_In,
       入院病区id_In, 入院科室id_In, 入院时间_In, d_Indeptime, 入院病况_In, 入院方式_In, 入院属性_In, 二级院转入_In, 住院目的_In,
       Decode(床号_In, '家庭病床', Null, 床号_In), 是否陪伴_In, 入院病况_In, 入院病区id_In, Decode(护理等级id_In, 0, Null, 护理等级id_In), 入院科室id_In,
       Decode(床号_In, '家庭病床', Null, 床号_In), 门诊医师_In, 操作员编号_In, 操作员姓名_In, Decode(床号_In, Null, 1, 0), 姓名_In, 性别_In, 年龄_In,
       婚姻状况_In, 职业_In, 国籍_In, 学历_In, 单位电话_In, 单位邮编_In, 工作单位_In, 区域_In, 家庭地址_In, 家庭电话_In, 家庭地址邮编_In, 户口地址_In, 户口地址邮编_In,
       联系人姓名_In, 联系人关系_In, 联系人地址_In, 联系人电话_In, 联系人身份证号_In, 付款方式_In, 险类_In, 备注_In, 操作员姓名_In, v_Date, 再入院_In, 病人类型_In);
  End If;

  Begin
    If 登记模式_In <> 1 Then
      Update 在院病人 Set 病区id = Nvl(入院病区id_In, 0), 科室id = 入院科室id_In Where 病人id = 病人id_In;
      If Sql%RowCount = 0 Then
        Insert Into 在院病人
          (病人id, 科室id, 病区id, 主页id)
        Values
          (病人id_In, 入院科室id_In, Nvl(入院病区id_In, 0), Nvl(v_主页id, 0));
      End If;
    End If;
  Exception
    When Others Then
      Null;
  End;

  Select 费别 Into v_费别 From 病人信息 Where 病人id = 病人id_In;
  If v_费别 Is Null Then
    Update 病人信息
    Set 费别 =
         (Select 费别 From 病案主页 Where 病人id = 病人id_In And 主页id = v_主页id)
    Where 病人id = 病人id_In;
  End If;

  --医保号
  If 登记模式_In <> 1 Then
    Select Zl_住院日报_Count(入院科室id_In, Trunc(入院时间_In)) Into v_Count From Dual;
    If v_Count > 0 Then
      v_Error := '已产生业务时间内的住院日报,不能办理该业务!';
      Raise Err_Custom;
    End If;
  
    If 医保号_In Is Not Null Then
      Insert Into 病案主页从表 (病人id, 主页id, 信息名, 信息值) Values (病人id_In, v_主页id, '医保号', 医保号_In);
    End If;
  
    --病人变动记录
    --同时入科且非家庭病床时有等级
    If 床号_In Is Not Null And 床号_In <> '家庭病床' Then
      Select 等级id Into v_等级id From 床位状况记录 Where 病区id = 入院病区id_In And 床号 = 床号_In;
    End If;
  
    --如果同时入科,则入院和入科填写到一条入院变动
    Insert Into 病人变动记录
      (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 护理等级id, 床位等级id, 床号, 病情, 操作员编号, 操作员姓名)
    Values
      (病人变动记录_Id.Nextval, 病人id_In, v_主页id, 入院时间_In, 1, 0, 入院病区id_In, 入院科室id_In, Decode(护理等级id_In, 0, Null, 护理等级id_In),
       v_等级id, Decode(床号_In, '家庭病床', Null, 床号_In), 入院病况_In, 操作员编号_In, 操作员姓名_In);
  
    Insert Into 病人自动计算
      (ID, 病人id, 主页id, 开始时间, 开始原因, 性质, 病区id, 科室id, 护理等级id, 操作员编号, 操作员姓名)
    Values
      (病人自动计算_Id.Nextval, 病人id_In, v_主页id, 入院时间_In, 1, 1, 入院病区id_In, 入院科室id_In, Decode(护理等级id_In, 0, Null, 护理等级id_In),
       操作员编号_In, 操作员姓名_In);
    Insert Into 病人自动计算
      (ID, 病人id, 主页id, 开始时间, 开始原因, 性质, 附加床位, 病区id, 科室id, 床位等级id, 床号, 操作员编号, 操作员姓名)
    Values
      (病人自动计算_Id.Nextval, 病人id_In, v_主页id, 入院时间_In, 1, 2, 0, 入院病区id_In, 入院科室id_In, v_等级id,
       Decode(床号_In, '家庭病床', Null, 床号_In), 操作员编号_In, 操作员姓名_In);
    Insert Into 病人自动计算
      (ID, 病人id, 主页id, 开始时间, 开始原因, 性质, 附加床位, 病区id, 科室id, 床位等级id, 床号, 操作员编号, 操作员姓名)
    Values
      (病人自动计算_Id.Nextval, 病人id_In, v_主页id, 入院时间_In, 1, 3, 0, 入院病区id_In, 入院科室id_In, v_等级id,
       Decode(床号_In, '家庭病床', Null, 床号_In), 操作员编号_In, 操作员姓名_In);
  
    --同时入科且非家庭病床时床位被占用
    If 床号_In Is Not Null And 床号_In <> '家庭病床' Then
      Select Count(*) Into v_Count From 床位状况记录 Where 病区id = 入院病区id_In And 床号 = 床号_In And 状态 = '空床';
    
      If v_Count = 0 Then
        v_Error := '操作失败,床位 ' || 床号_In || ' 不是空床！';
        Raise Err_Custom;
      End If;
    
      Update 床位状况记录
      Set 状态 = '占用', 病人id = 病人id_In, 科室id = Decode(共用, 1, 入院科室id_In, 科室id)
      Where 病区id = 入院病区id_In And 床号 = 床号_In;
    End If;
  
    --病人诊断记录
    If 门诊诊断_In Is Not Null Or 疾病id_In Is Not Null Then
      Insert Into 病人诊断记录
        (ID, 病人id, 主页id, 记录来源, 诊断类型, 诊断次序, 疾病id, 诊断id, 诊断描述, 记录日期, 记录人)
      Values
        (病人诊断记录_Id.Nextval, 病人id_In, v_主页id, 2, 1, 1, 疾病id_In, 诊断id_In, 门诊诊断_In, Sysdate, 操作员姓名_In);
    End If;
    If 中医诊断_In Is Not Null Or 中医疾病id_In Is Not Null Then
      Insert Into 病人诊断记录
        (ID, 病人id, 主页id, 记录来源, 诊断类型, 诊断次序, 疾病id, 诊断id, 诊断描述, 记录日期, 记录人)
      Values
        (病人诊断记录_Id.Nextval, 病人id_In, v_主页id, 2, 11, 1, 中医疾病id_In, 中医诊断id_In, 中医诊断_In, Sysdate, 操作员姓名_In);
    End If;
    --病人担保记录
    Update 病人担保记录
    Set 到期时间 = Sysdate
    Where 病人id = 病人id_In And 到期时间 Is Not Null And 到期时间 > Sysdate;
  
    --病人费用审批项目
    If 登记模式_In <> 1 Then
      Delete From 病人审批项目 Where 病人id = 病人id_In;
      b_Message.Zlhis_Patient_001(病人id_In, v_主页id);
    End If;
  
    If 登记模式_In = 0 And ((门诊诊断_In Is Not Null Or 疾病id_In Is Not Null) Or (中医诊断_In Is Not Null Or 中医疾病id_In Is Not Null)) Then
      --产生病历书写时机
      Zl_电子病历时机_Insert(病人id_In, 主页id_In, 2, '诊断', 入院科室id_In, Null, Sysdate, Sysdate);
    End If;
  
    If 登记模式_In = 0 And 床号_In Is Not Null Then
      If 再入院_In = 0 Then
        Zl_电子病历时机_Insert(病人id_In, 主页id_In, 2, '入院', 入院科室id_In, Null, 入院时间_In, 入院时间_In);
      Else
        Zl_电子病历时机_Insert(病人id_In, 主页id_In, 2, '再次入院', 入院科室id_In, Null, 入院时间_In, 入院时间_In);
      End If;
    End If;
  
    If 床号_In Is Not Null Then
      --添加首份体温单
      Zl_病人体温单_Newfirst(病人id_In, 主页id_In, 入院病区id_In);
    End If;
  
    --并发操作检查
    Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 出院日期 Is Null;
    If v_Count > 1 Then
      v_Error := '发现病人存在非法的病案记录,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
      Raise Err_Custom;
    End If;
  
    Select Count(*)
    Into v_Count
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = v_主页id And Nvl(附加床位, 0) = 0 And 开始时间 Is Not Null And 终止时间 Is Null;
    If v_Count > 1 Then
      v_Error := '发现病人存在非法的变动记录,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
      Raise Err_Custom;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_入院病案主页_Insert;
/

--121560:冉俊明,2018-02-07,如果消费卡的退卡(回收)记录已轧账，则不允许取消退卡(取消回收)
Create Or Replace Procedure Zl_消费卡信息_Callback
(
  Ids_In        Varchar2,
  操作员姓名_In 消费卡信息.回收人%Type,
  回收时间_In   消费卡信息.回收时间%Type,
  取消回收_In   Number := 0
) Is
  --回收、取消回收消费卡
  --说明：
  --        取消回收_In 0-回收，1-取消回收
  Err_Item Exception;
  v_Err_Msg Varchar2(500);

  v_Ids Varchar2(4000);
  n_Id  Number(18);

  n_接口编号 消费卡信息.接口编号%Type;
  n_存在卡片 Number(2);
  v_卡名称   消费卡类别目录.名称%Type;
  v_卡号     消费卡信息.卡号%Type;
  n_序号     消费卡信息.序号%Type;
  n_最大序号 消费卡信息.序号%Type;
  d_回收时间 消费卡信息.回收时间%Type;
  d_停用时间 消费卡信息.停用日期%Type;
  n_当前状态 消费卡信息.当前状态%Type;
  n_领用id   消费卡信息.领用id%Type;

  n_组id 财务缴款分组.Id%Type;

  n_Count Number(2);
Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  v_Ids := Ids_In || ',';
  While v_Ids Is Not Null Loop
    n_Id  := To_Number(Substr(v_Ids, 1, Instr(v_Ids, ',') - 1));
    v_Ids := Substr(v_Ids, Instr(v_Ids, ',') + 1);
  
    --检查当前卡号
    Begin
      Select b.名称, a.卡号, 1, a.回收时间, a.停用日期,
             (Select Max(序号) From 消费卡信息 B Where a.卡号 = b.卡号 And a.接口编号 = b.接口编号), a.序号, a.接口编号, a.当前状态, Nvl(a.领用id, 0)
      Into v_卡名称, v_卡号, n_存在卡片, d_回收时间, d_停用时间, n_最大序号, n_序号, n_接口编号, n_当前状态, n_领用id
      From 消费卡信息 A, 消费卡类别目录 B
      Where a.接口编号 = b.编号 And a.Id = n_Id;
    Exception
      When Others Then
        n_存在卡片 := 0;
    End;
    If Nvl(取消回收_In, 0) = 0 Then
      If n_存在卡片 = 0 Then
        v_Err_Msg := '未找到卡记录，可能已被他人删除，不能回收！';
        Raise Err_Item;
      End If;
      If Nvl(n_序号, 0) < Nvl(n_最大序号, 0) Then
        v_Err_Msg := '不能回收历史发放的' || v_卡名称 || '(卡号为“' || v_卡号 || '”)！';
        Raise Err_Item;
      End If;
      If Nvl(d_回收时间, To_Date('3000-01-01', 'yyyy-mm-dd')) < To_Date('3000-01-01', 'yyyy-mm-dd') Then
        v_Err_Msg := '卡号为“' || v_卡号 || '”的' || v_卡名称 || '已经回收，不能再回收！';
        Raise Err_Item;
      End If;
    
      Update 消费卡信息
      Set 回收时间 = 回收时间_In, 回收人 = 操作员姓名_In, 当前状态 = 2, 回收组id = n_组id
      Where ID = n_Id And (回收时间 Is Null Or 回收时间 >= To_Date('3000-01-01', 'yyyy-mm-dd'));
    
      Insert Into 消费卡使用记录
        (ID, 卡号, 性质, 原因, 领用id, 回收次数, 接口编号, 使用时间, 使用人)
        Select 消费卡使用记录_Id.Nextval, 卡号, 2, 2, 领用id, 回收次数, 接口编号, 回收时间_In, 操作员姓名_In
        From 消费卡使用记录 A
        Where 接口编号 = n_接口编号 And 卡号 = v_卡号 And
              Nvl(回收次数, 0) = (Select Nvl(Max(回收次数), 0)
                              From 消费卡使用记录
                              Where 接口编号 = a.接口编号 And 卡号 = a.卡号 And 性质 = 1) And Not Exists
         (Select 1
               From 消费卡使用记录
               Where 接口编号 = a.接口编号 And 卡号 = a.卡号 And Nvl(回收次数, 0) = Nvl(a.回收次数, 0) And 性质 = 2);
    
      --处理相关的变动信息 
      Zl_消费卡变动记录_Insert(5, n_Id, '回收卡', v_卡号, 操作员姓名_In, 回收时间_In);
    Else
    
      --取消回收 
      If n_存在卡片 = 0 Then
        v_Err_Msg := '未找到卡记录，可能已被他人删除，不能取消回收！';
        Raise Err_Item;
      End If;
      If Nvl(n_序号, 0) < Nvl(n_最大序号, 0) Then
        v_Err_Msg := '不能取消回收历史发放的' || v_卡名称 || '(卡号为“' || v_卡号 || '”)！';
        Raise Err_Item;
      End If;
      If Nvl(d_回收时间, To_Date('3000-01-01', 'yyyy-mm-dd')) >= To_Date('3000-01-01', 'yyyy-mm-dd') Then
        v_Err_Msg := '卡号为“' || v_卡号 || '”的' || v_卡名称 || '可能被他人取消回收(在用)，不能再取消回收！';
        Raise Err_Item;
      End If;
    
      --换卡回收的卡不能取消回收
      If Nvl(n_当前状态, 0) = 4 Then
        v_Err_Msg := '卡号为“' || v_卡号 || '”的' || v_卡名称 || '为换卡回收的卡，不能取消回收！';
        Raise Err_Item;
      End If;
    
      --已轧账的卡不允许再取消回收
      Select Count(1)
      Into n_Count
      From 消费卡使用记录 A, 消费卡领用记录 B, 人员收缴票据 C, 人员收缴记录 D
      Where a.领用id = b.Id(+) And c.收缴id = d.Id And a.使用时间 Between d.开始时间 And d.终止时间 And Nvl(c.批次, '-') = Nvl(b.批次, '-') And
            Length(c.开始票号) = Length(a.卡号) And a.卡号 Between c.开始票号 And c.终止票号 And d.作废时间 Is Null And c.票种 = 6 And
            c.性质 = 2 And a.接口编号 = n_接口编号 And a.卡号 = v_卡号 And a.性质 = 2 And Nvl(a.领用id, 0) = n_领用id And Rownum < 2;
      If Nvl(n_Count, 0) <> 0 Then
        v_Err_Msg := '卡号为“' || v_卡号 || '”的' || v_卡名称 || '已进行了轧账处理，不允许再取消回收！';
        Raise Err_Item;
      End If;
    
      Update 消费卡信息
      Set 回收时间 = Null, 回收人 = Null, 当前状态 = 1, 回收组id = Null
      Where ID = n_Id And 回收时间 Is Not Null;
    
      Delete From 消费卡使用记录 A
      Where 接口编号 = n_接口编号 And 卡号 = v_卡号 And
            Nvl(回收次数, 0) =
            (Select Nvl(Max(回收次数), 0) From 消费卡使用记录 Where 接口编号 = a.接口编号 And 卡号 = a.卡号 And 性质 = 1) And 性质 = 2 And 原因 = 2;
    
      --处理相关的变动信息 
      Zl_消费卡变动记录_Insert(15, n_Id, '取消回收卡', v_卡号, 操作员姓名_In, 回收时间_In);
    End If;
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_消费卡信息_Callback;
/

--121519:焦博,2018-02-07,调整Zl_病人预交记录_Delete,先作废回收票据,再打印预交红票
CREATE OR REPLACE Procedure Zl_病人预交记录_Delete
(
  Id_In         病人预交记录.Id%Type,
  摘要_In       病人预交记录.摘要%Type,
  操作员编号_In 病人预交记录.操作员编号%Type,
  操作员姓名_In 病人预交记录.操作员姓名%Type,
  帐户退费_In   Number := 1,
  冲预交id_In   病人预交记录.Id%Type := Null,
  票据号_In     病人预交记录.实际票号%Type := Null,
  领用id_In     票据领用记录.Id%Type := Null
) As
  Cursor c_Moneyinfo Is
    Select ID, NO, 金额, 结算方式, 病人id, 预交类别
    From 病人预交记录
    Where ID = Id_In And 记录性质 = 1 And 记录状态 = 1;
  r_Moneyrow c_Moneyinfo%RowType;

  v_打印id   票据打印内容.Id%Type;
  v_性质     结算方式.性质%Type;
  v_现金     结算方式.名称%Type;
  v_个人帐户 结算方式.名称%Type;
  n_返回值   病人余额.预交余额%Type;
  n_预交id   病人预交记录.Id%Type;
  v_No       病人预交记录.No%Type;
  v_Date     Date;
  Err_Custom Exception;
  n_组id 财务缴款分组.Id%Type;
  v_Msg  Varchar2(500);

Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  --获取结算方式名称
  Begin
    Select 名称 Into v_现金 From 结算方式 Where 性质 = 1;
  Exception
    When Others Then
      v_现金 := '现金';
  End;
  Begin
    Select 名称 Into v_个人帐户 From 结算方式 Where 性质 = 3;
  Exception
    When Others Then
      v_个人帐户 := '个人帐户';
  End;

  Open c_Moneyinfo;
  Fetch c_Moneyinfo
    Into r_Moneyrow;

  --首先判断要退款的记录是否存在
  If c_Moneyinfo%RowCount = 0 Then
    Close c_Moneyinfo;
    Raise Err_Custom;
  Else
    Select Sysdate Into v_Date From Dual;
    If 冲预交id_In Is Not Null Then
      n_预交id := 冲预交id_In;
    Else
      Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
    End If;
  
    --预交退款
    If Nvl(帐户退费_In, 0) = 1 Then
      --支持个人帐户退费,正常处理
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 金额, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 缴款单位, 单位开户行, 单位帐号, 缴款组id,
         预交类别, 卡类别id, 卡号, 交易流水号, 交易说明, 合作单位, 结算卡序号)
        Select n_预交id, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要_In, -1 * 金额, 结算方式, 结算号码, v_Date, 操作员编号_In, 操作员姓名_In, 缴款单位,
               单位开户行, 单位帐号, n_组id, 预交类别, 卡类别id, 卡号, 交易流水号, 交易说明, 合作单位, 结算卡序号
        From 病人预交记录
        Where ID = Id_In;
    Else
      --不支持时,处理成现金,记录性质为2的摘要填标志,为3的更新新输入的摘要
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 金额, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 缴款单位, 单位开户行, 单位帐号, 缴款组id,
         预交类别, 卡类别id, 卡号, 交易流水号, 交易说明, 合作单位, 结算卡序号)
        Select n_预交id, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, Nvl(摘要_In, '个人帐户退款'), -1 * 金额,
               Decode(结算方式, v_个人帐户, v_现金, 结算方式), 结算号码, v_Date, 操作员编号_In, 操作员姓名_In, Decode(结算方式, v_个人帐户, Null, 缴款单位),
               Decode(结算方式, v_个人帐户, Null, 单位开户行), Decode(结算方式, v_个人帐户, Null, 单位帐号), n_组id, 预交类别, 卡类别id, 卡号, 交易流水号, 交易说明,
               合作单位, 结算卡序号
        From 病人预交记录
        Where ID = Id_In;
    End If;
  
    Update 病人预交记录 Set 记录状态 = 3, 摘要 = 摘要_In Where ID = Id_In;
  
    --处理相关汇总表
    --人员缴款余额(注意包括处理个人帐户的结算方式)
    If Nvl(帐户退费_In, 0) = 1 Then
      --支持退个人帐户时的处理
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) - r_Moneyrow.金额
      Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = r_Moneyrow.结算方式
      Returning 余额 Into n_返回值;
    
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (操作员姓名_In, r_Moneyrow.结算方式, 1, -r_Moneyrow.金额);
        n_返回值 := -r_Moneyrow.金额;
      
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Moneyrow.结算方式 And Nvl(余额, 0) = 0;
      End If;
    Else
      --不支持时的处理
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) - r_Moneyrow.金额
      Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = Decode(r_Moneyrow.结算方式, v_个人帐户, v_现金, r_Moneyrow.结算方式)
      Returning 余额 Into n_返回值;
    
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (操作员姓名_In, Decode(r_Moneyrow.结算方式, v_个人帐户, v_现金, r_Moneyrow.结算方式), 1, -r_Moneyrow.金额);
        n_返回值 := -r_Moneyrow.金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = Decode(r_Moneyrow.结算方式, v_个人帐户, v_现金, r_Moneyrow.结算方式) And
              Nvl(余额, 0) = 0;
      End If;
    End If;
  
    --病人(预交)余额(不管是退现金还是个人帐户都应该减少)
    --判断要退款的性质
    Select b.性质 Into v_性质 From 病人预交记录 A, 结算方式 B Where a.结算方式 = b.名称(+) And a.Id = Id_In;
    If Nvl(v_性质, 1) <> 5 Then
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - r_Moneyrow.金额
      Where 性质 = 1 And 病人id = r_Moneyrow.病人id And Nvl(类型, 2) = Nvl(r_Moneyrow.预交类别, 2)
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 预交余额, 费用余额)
        Values
          (r_Moneyrow.病人id, 1, Nvl(r_Moneyrow.预交类别, 2), -r_Moneyrow.金额, 0);
        n_返回值 := -r_Moneyrow.金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Moneyrow.病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
      End If;
    End If;
  
    --作废收回票据(可能以前没有使用票据,无法收回)
    Begin
      Select ID
      Into v_打印id
      From (Select b.Id
             From 票据使用明细 A, 票据打印内容 B
             Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 2 And b.No = r_Moneyrow.No
             Order By a.使用时间 Desc)
      Where Rownum < 2;
    Exception
      When Others Then
        Null;
    End;
  
    If v_打印id Is Not Null Then
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人, 票据金额)
        Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, v_Date, 操作员姓名_In, 票据金额
        From 票据使用明细
        Where 打印id = v_打印id And 票种 = 2 And 性质 = 1;
    End If;
  
    --处理票据
    If 票据号_In Is Not Null Then
      Select 票据打印内容_Id.Nextval Into v_打印id From Dual;
    
      --发出票据
      Insert Into 票据打印内容 (ID, 数据性质, NO) Values (v_打印id, 2, r_Moneyrow.No);
    
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人, 票据金额)
      Values
        (票据使用明细_Id.Nextval, 2, 票据号_In, 1, 6, 领用id_In, v_打印id, v_Date, 操作员姓名_In, -1 * r_Moneyrow.金额);
    
      --状态改动
      Update 票据领用记录
      Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
      Where ID = Nvl(领用id_In, 0);
    End If;
  
    Close c_Moneyinfo;
  End If;
  --消息推送;
  Select NO Into v_No From 病人预交记录 Where ID = n_预交id;
  b_Message.Zlhis_Charge_006(n_预交id, v_No);
  Select Id_In || ',' || 帐户退费_In Into v_Msg From Dual;
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 12, v_Msg;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20999, '[ZLSOFT]没有发现要退款的预交记录,该记录可能已经退除！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人预交记录_Delete;
/

--121845:刘硕,2018-02-06,移动护理接口
CREATE OR REPLACE Procedure Zl_Third_Getperson
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取人员信息
  --入参:Xml_In:
  --<IN>
  --  <BMID></BMID>         --部门ID,传空时为获取所有人员
  --</IN>
  --出参:Xml_Out
  --<OUTPUT>
  --  <RYLIST>
  --    <ITEM>
  --      <ID></ID>  --ID
  --      <XM></XM>  --姓名
  --      <BH></BH>  --编号
  --      <JM></JM>  --简码
  --      <XB></XB>  --性别
  --      <CSRQ></CSRQ> --出生日期
  --      <SFZH></SFZH> --身份证号
  --      <MZ></MZ>  --民族
  --      <XL></XL>  --学历
  --      <ZYJSZW></ZYJSZW> --专业技术职务
  --      <XZ></XZ>  --人员性质，字符串“医生,护士,其他”
  --      <BMLIST>  --所属部门列表
  --        <ITEM>
  --          <ID></ID> --部门ID
  --          <MC></MC> --部门名称
  --        </ITEM>
  --      </BMLIST>
  --    </ITEM>
  --  <RYLIST>
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  n_部门id  部门表.Id%Type;
  x_Templet Xmltype; --模板XML
Begin
  --获取部门ID
  Select Max(b.Bmid)
  Into n_部门id
  From Xmltable('$a/IN' Passing Xml_In As "a" Columns Bmid Number(18) Path 'BMID') B;
  --获取所有部门人员
  If n_部门id Is Null Then
    Select Xmlelement("OUTPUT",
                       Xmlelement("RYLIST",
                                   Xmlagg(Xmlelement("ITEM",
                                                      Xmlforest(a.Id As "ID", Max(a.姓名) As "XM", Max(a.编号) As "BH",
                                                                 Max(a.简码) As "JM", Max(a.性别) As "XB",
                                                                 To_Char(Max(a.出生日期), 'YYYY-MM-DD HH24:MI:SS') As "CSRQ",
                                                                 Max(a.身份证号) As "SFZH", Max(a.民族) As "MZ", Max(a.学历) As "XL",
                                                                 Max(a.专业技术职务) As "ZYJSZW", Max(b.人员性质) As "XZ",
                                                                 Xmlagg(Xmlelement("ITEM", Xmlforest(g.Id As "ID", g.名称 As "MC"))) As
                                                                  "BMLIST")))))
    Into x_Templet
    From 人员表 A,
         (Select e.人员id, f_List2str(Cast(Collect(e.人员性质) As t_Strlist)) 人员性质
           From (Select c.Id 人员id, d.人员性质
                  From 人员表 C, 人员性质说明 D
                  Where d.人员id = c.Id And d.人员性质 In ('医生', '护士')
                  Union All
                  Select c.Id 人员id, '其他' 人员性质
                  From 人员表 C, 人员性质说明 D
                  Where d.人员id = c.Id And d.人员性质 Not In ('医生', '护士')
                  Group By c.Id) E
           Group By e.人员id) B, 部门人员 F, 部门表 G
    Where a.Id = b.人员id(+) And a.Id = f.人员id(+) And f.部门id = g.Id(+)
    Group By a.Id;
    --获取指定部门人员
  Else
    With People As
     (Select r.Id, r.姓名, r.编号, r.简码, r.性别, r.出生日期, r.身份证号, r.民族, r.学历, r.专业技术职务
      From 人员表 R
      Where r.Id In (Select 人员id From 部门人员 H Where h.部门id = n_部门id))
    Select Xmlelement("OUTPUT",
                       Xmlelement("RYLIST",
                                   Xmlagg(Xmlelement("ITEM",
                                                      Xmlforest(a.Id As "ID", Max(a.姓名) As "XM", Max(a.编号) As "BH",
                                                                 Max(a.简码) As "JM", Max(a.性别) As "XB",
                                                                 To_Char(Max(a.出生日期), 'YYYY-MM-DD HH24:MI:SS') As "CSRQ",
                                                                 Max(a.身份证号) As "SFZH", Max(a.民族) As "MZ", Max(a.学历) As "XL",
                                                                 Max(a.专业技术职务) As "ZYJSZW", Max(b.人员性质) As "XZ",
                                                                 Xmlagg(Xmlelement("ITEM", Xmlforest(g.Id As "ID", g.名称 As "MC"))) As
                                                                  "BMLIST")))))
    Into x_Templet
    From People A,
         (Select e.人员id, f_List2str(Cast(Collect(e.人员性质) As t_Strlist)) 人员性质
           From (Select c.Id 人员id, d.人员性质
                  From People C, 人员性质说明 D
                  Where d.人员id = c.Id And d.人员性质 In ('医生', '护士')
                  Union All
                  Select c.Id 人员id, '其他' 人员性质
                  From People C, 人员性质说明 D
                  Where d.人员id = c.Id And d.人员性质 Not In ('医生', '护士')
                  Group By c.Id) E
           Group By e.人员id) B, 部门人员 F, 部门表 G
    Where a.Id = b.人员id(+) And a.Id = f.人员id(+) And f.部门id = g.Id(+)
    Group By a.Id;
  End If;
  Xml_Out := x_Templet;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getperson;
/
--121845:刘硕,2018-02-06,移动护理接口
Create Or Replace Procedure Zl_Third_Getdept(Xml_Out Out Xmltype) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取部门信息
  --入参:无
  --出参:Xml_Out
  --<OUTPUT>
  --  <BMLIST>
  --    <ITEM>
  --      <ID></ID>  --ID
  --      <MC></MC>  --名称
  --      <BH></BH>  --编号
  --      <JM></JM>  --简码
  --      <ZD></ZD>  --站点
  --      <XZ></XZ>  --性质，多个性质用“,”号分隔
  --    </ITEM>
  --  <BMLIST>
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  x_Templet Xmltype; --模板XML
Begin
  --获取所有部门
  Select Xmlelement("OUTPUT",
                     Xmlelement("BMLIST",
                                 Xmlagg(Xmlelement("ITEM",
                                                    Xmlforest(a.Id As "ID", Max(a.名称) As "MC", Max(a.编码) As "BH",
                                                               Max(a.简码) As "JM", Max(a.站点) As "ZD",
                                                               f_List2str(Cast(Collect(b.工作性质) As t_Strlist)) As "XZ"))))) 部门性质
  
  Into x_Templet
  From 部门表 A, 部门性质说明 B
  Where a.Id = b.部门id
  Group By a.Id;
  Xml_Out := x_Templet;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getdept;
/
--121845:刘硕,2018-02-06,移动护理接口
Create Or Replace Procedure Zl_Third_Getdeptmatch
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:用于获取科室病区对照关系
  --入参:Xml_In:
  --<IN>
  --  <BMID></BMID>         --科室ID,传空时为获取所有对照关系
  --</IN>
  --出参:Xml_Out
  --<OUTPUT>
  --  <BMKSLIST>
  --    <ITEM>
  --      <BQID></BQID>  --病区ID
  --      <KSID></KSID>  --科室ID
  --    </ITEM>
  --  <BMKSLIST>
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  n_部门id  部门表.Id%Type;
  x_Templet Xmltype; --模板XML
Begin
  --获取部门ID
  Select Max(b.Bmid)
  Into n_部门id
  From Xmltable('$a/IN' Passing Xml_In As "a" Columns Bmid Number(18) Path 'BMID') B;

  --获取所有对应关系
  If n_部门id Is Null Then
  
    Select Xmlelement("OUTPUT",
                       Xmlelement("BMKSLIS", Xmlagg(Xmlelement("ITEM", Xmlforest(a.病区id As "BQID", a.科室id As "KSID"))))) 部门性质
    
    Into x_Templet
    From 病区科室对应 A;
    --获取指定科室对应的病区
  Else
    Select Xmlelement("OUTPUT",
                       Xmlelement("BMKSLIS", Xmlagg(Xmlelement("ITEM", Xmlforest(a.病区id As "BQID", a.科室id As "KSID"))))) 部门性质
    
    Into x_Templet
    From 病区科室对应 A
    Where a.病区id = n_部门id;
  End If;
  Xml_Out := x_Templet;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getdeptmatch;
/
--121845:刘硕,2018-02-06,移动护理接口
Create Or Replace Procedure Zl_Third_Getfeeitem
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取收费项目目录,用于在设置护理项目对应收费项目时，输入简码、名称查询HIS收费项目
  --入参:Xml_In:
  --<IN>
  --  <KEY></KEY>   //查询关键字，简码、名称、编码，简码为拼音简码，编码左匹配，名称与简码全匹配。为NULL则不进行匹配查询
  --  <PAGENOW></PAGENOW>  //当前页数，当PAGESIZE与PAGENOW为空或<1,则返回所有数据。否则返回指定页数的数据
  --  <PAGESIZE></PAGESIZE>  //记录条数，当PAGESIZE与PAGENOW为空或<1,则返回所有数据。否则返回指定页数的数据
  --</IN>
  --出参:Xml_Out--以类别与编码排序返回分页
  --<OUTPUT>
  --  <XMLIST>
  --    <XM>
  --      <LB></LB>   //类别，治疗、护理等
  --      <ID></ID>   //收费项目Id
  --      <BM></BM>   //收费项目编码
  --      <MC></MC>   //收费项目名称
  --      <GG></GG>   //规格
  --      <DW></DW>   //单位
  --      <DJ></DJ>   //单价
  --      <SM></SM>   //说明
  --    </XM>
  --  </XMLIST>
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  v_Key      收费项目目录.名称%Type;
  n_Cur_Page Number(5);
  n_Pagesize Number(5);
  x_Templet  Xmltype; --模板XML
Begin
  --获取查询参数
  Select Max(b.Key), Max(b.Pagenow), Max(Pagesize)
  Into v_Key, n_Cur_Page, n_Pagesize
  From Xmltable('$a/IN' Passing Xml_In As "a" Columns Key Varchar2(100) Path 'KEY', Pagenow Number(5) Path 'PAGENOW',
                 Pagesize Number(5) Path 'PAGESIZE') B;

  --获取所有的数据，不匹配
  --查询SQL来源于诊疗项目管理中设置收费项目时输入匹配，变动点为（将Sum修改为Max）
  If v_Key Is Null Then
    --不进行分页，直接返回所有数据
    If Nvl(n_Cur_Page, 0) < 1 Or Nvl(n_Pagesize, 0) < 1 Then
      Select Xmlelement("OUTPUT",
                         Xmlelement("XMLIST",
                                     Xmlagg(Xmlelement("XM",
                                                        Xmlforest(e.类别名称 As "LB", e.Id As "ID", e.编码 As "BM", e.名称 As "MC",
                                                                   e.规格 As "GG", e.计算单位 As "DW", e.售价 As "DJ", e.说明 As "SM"))))) 部门性质
      Into x_Templet
      From (Select b.名称 类别名称, a.Id, a.编码, a.名称, a.规格, a.产地, a.计算单位, a.说明,
                    Decode(Nvl(a.是否变价, 0), 0, LTrim(RTrim(To_Char(Sum(Nvl(d.现价, 0)), '9999999990.0000'))),
                            Decode(Instr('4567', a.类别), 0, LTrim(RTrim(To_Char(Sum(Nvl(d.缺省价格, 0)), '9999999990.0000'))),
                                    '时价')) As 售价
             From 收费项目目录 A, 收费项目类别 B, 收费价目 D
             Where a.类别 = b.编码 And a.Id = d.收费细目id(+) And a.类别 Not In ('1', 'J') And
                   (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD')) And
                   (a.服务对象 = 1 Or a.服务对象 = 2 Or a.服务对象 = 3) And d.执行日期 <= Sysdate And
                   (d.终止日期 > Sysdate Or d.终止日期 Is Null) And d.价格等级 Is Null
             Group By b.名称, a.Id, a.编码, a.名称, a.规格, a.产地, a.计算单位, a.说明, a.是否变价, a.类别) E;
      --分页查询
    Else
      Select Xmlelement("OUTPUT",
                         Xmlelement("XMLIST",
                                     Xmlagg(Xmlelement("XM",
                                                        Xmlforest(e.类别名称 As "LB", e.Id As "ID", e.编码 As "BM", e.名称 As "MC",
                                                                   e.规格 As "GG", e.计算单位 As "DW", e.售价 As "DJ", e.说明 As "SM"))))) 部门性质
      Into x_Templet
      From (Select b.名称 类别名称, a.Id, a.编码, a.名称, a.规格, a.产地, a.计算单位, a.说明,
                    Decode(Nvl(a.是否变价, 0), 0, LTrim(RTrim(To_Char(Sum(Nvl(d.现价, 0)), '9999999990.0000'))),
                            Decode(Instr('4567', a.类别), 0, LTrim(RTrim(To_Char(Sum(Nvl(d.缺省价格, 0)), '9999999990.0000'))),
                                    '时价')) As 售价, Row_Number() Over(Order By b.名称, a.编码) As Rn
             From 收费项目目录 A, 收费项目类别 B, 收费价目 D
             Where a.类别 = b.编码 And a.Id = d.收费细目id(+) And a.类别 Not In ('1', 'J') And
                   (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD')) And
                   (a.服务对象 = 1 Or a.服务对象 = 2 Or a.服务对象 = 3) And d.执行日期 <= Sysdate And
                   (d.终止日期 > Sysdate Or d.终止日期 Is Null) And d.价格等级 Is Null
             Group By b.名称, a.Id, a.编码, a.名称, a.规格, a.产地, a.计算单位, a.说明, a.是否变价, a.类别) E
      Where Rn Between n_Pagesize * (n_Cur_Page - 1) + 1 And n_Pagesize * n_Cur_Page;
    End If;
    --获取指定的匹配数据
  Else
    --不进行分页，直接返回所有数据
    If Nvl(n_Cur_Page, 0) < 1 Or Nvl(n_Pagesize, 0) < 1 Then
      Select Xmlelement("OUTPUT",
                         Xmlelement("XMLIST",
                                     Xmlagg(Xmlelement("XM",
                                                        Xmlforest(e.类别名称 As "LB", e.Id As "ID", e.编码 As "BM", e.名称 As "MC",
                                                                   e.规格 As "GG", e.计算单位 As "DW", e.售价 As "DJ", e.说明 As "SM"))))) 部门性质
      Into x_Templet
      From (Select f.类别名称, f.Id, f.编码, f.名称, f.规格, f.产地, f.计算单位, f.说明,
                    Decode(Nvl(f.是否变价, 0), 0, LTrim(RTrim(To_Char(Sum(Nvl(d.现价, 0)), '9999999990.0000'))),
                            Decode(Instr('4567', f.类别), 0, LTrim(RTrim(To_Char(Sum(Nvl(d.缺省价格, 0)), '9999999990.0000'))),
                                    '时价')) As 售价
             From (Select Distinct b.名称 类别名称, a.Id, a.编码, a.名称, a.规格, a.产地, a.计算单位, a.说明, a.是否变价, a.类别
                    
                    From 收费项目目录 A, 收费项目类别 B, 收费项目别名 C
                    Where a.类别 = b.编码 And a.Id = c.收费细目id And a.类别 Not In ('1', 'J') And
                          (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD')) And
                          (a.服务对象 = 1 Or a.服务对象 = 2 Or a.服务对象 = 3) And
                          (a.编码 Like v_Key || '%' Or c.名称 Like '%' || v_Key || '%' Or c.简码 Like '%' || v_Key || '%') And
                          c.码类 = '1') F,
                  
                  收费价目 D
             Where f.Id = d.收费细目id(+) And d.价格等级 Is Null And d.执行日期 <= Sysdate And (d.终止日期 > Sysdate Or d.终止日期 Is Null)
             Group By f.名称, f.Id, f.编码, f.名称, f.规格, f.产地, f.计算单位, f.说明, f.是否变价, f.类别名称, f.类别) E;
      --分页查询
    Else
      Select Xmlelement("OUTPUT",
                         Xmlelement("XMLIST",
                                     Xmlagg(Xmlelement("XM",
                                                        Xmlforest(e.类别名称 As "LB", e.Id As "ID", e.编码 As "BM", e.名称 As "MC",
                                                                   e.规格 As "GG", e.计算单位 As "DW", e.售价 As "DJ", e.说明 As "SM"))))) 部门性质
      Into x_Templet
      From (Select f.类别名称, f.Id, f.编码, f.名称, f.规格, f.产地, f.计算单位, f.说明,
                    Decode(Nvl(f.是否变价, 0), 0, LTrim(RTrim(To_Char(Sum(Nvl(d.现价, 0)), '9999999990.0000'))),
                            Decode(Instr('4567', f.类别), 0, LTrim(RTrim(To_Char(Sum(Nvl(d.缺省价格, 0)), '9999999990.0000'))),
                                    '时价')) As 售价, Row_Number() Over(Order By f.名称, f.编码) As Rn
             From (Select Distinct b.名称 类别名称, a.Id, a.编码, a.名称, a.规格, a.产地, a.计算单位, a.说明, a.是否变价, a.类别
                    From 收费项目目录 A, 收费项目类别 B, 收费项目别名 C
                    Where a.类别 = b.编码 And a.Id = c.收费细目id And a.类别 Not In ('1', 'J') And
                          (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD')) And
                          (a.服务对象 = 1 Or a.服务对象 = 2 Or a.服务对象 = 3) And
                          (a.编码 Like v_Key || '%' Or c.名称 Like '%' || v_Key || '%' Or c.简码 Like '%' || v_Key || '%') And
                          c.码类 = '1') F,
                  
                  收费价目 D
             Where f.Id = d.收费细目id(+) And d.价格等级 Is Null And d.执行日期 <= Sysdate And (d.终止日期 > Sysdate Or d.终止日期 Is Null)
             Group By f.名称, f.Id, f.编码, f.名称, f.规格, f.产地, f.计算单位, f.说明, f.是否变价, f.类别名称, f.类别) E
      Where Rn Between n_Pagesize * (n_Cur_Page - 1) + 1 And n_Pagesize * n_Cur_Page;
    End If;
  End If;
  Xml_Out := x_Templet;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getfeeitem;
/
--121587:冉俊明,2018-02-08,临床出诊号源安排分站点进行维护
Create Or Replace Procedure Zl_临床出诊表_导入
(
  号码_In 挂号安排.号码%Type := Null,
  开始_In Number := 1
) As
  -------------------------------------------------------------------------
  --功能说明：导放临床出诊表,主要是根据挂号安排，挂号计划安排等表进行数据导入
  --入参：
  --    开始_In:传入号码时有效，表示第一个
  -------------------------------------------------------------------------
  Err_Item Exception;
  v_Err_Msg Varchar2(200);

  l_限制id t_Numlist := t_Numlist();
  n_Count  Number(18);

  v_时间段           Varchar2(4000);
  n_出诊id           临床出诊表.Id%Type;
  v_全院号源归属站点 部门表.站点%Type;

  Procedure Zl_Register_Import
  (
    号码_In             挂号安排.号码%Type,
    出诊id_In           临床出诊表.Id%Type,
    全院号源归属站点_In 部门表.站点%Type
  ) As
    n_号源id   临床出诊号源.Id%Type;
    d_建档时间 临床出诊号源.建档时间%Type;
  
    n_出诊id 临床出诊表.Id%Type;
    n_安排id 临床出诊安排.Id%Type;
  
    n_限制id 临床出诊号源限制.Id%Type;
    n_诊室id 门诊诊室.Id%Type;
  
    n_是否导入     Number(2);
    n_是否临时安排 临床出诊安排.是否临时安排%Type;
  
    n_Count  Number(18);
    l_限制id t_Numlist := t_Numlist();
  Begin
    For c_号源 In (Select a.Id, a.号类, a.号码, a.科室id, a.项目id, a.医生姓名, Decode(a.医生id, 0, Null, a.医生id) As 医生id, a.序号, a.周日,
                        a.周一, a.周二, a.周三, a.周四, a.周五, a.周六, a.病案必须, a.分诊方式, a.序号控制, a.开始时间, a.终止时间, a.执行时间, a.执行计划id,
                        a.默认时段间隔, a.预约天数, Nvl(a.是否删除, 0) As 是否删除,
                        Nvl(a.停用日期, To_Date('3000-01-01', 'yyyy-mm-dd')) As 停用日期, Nvl(b.站点, 全院号源归属站点_In) As 站点
                 From 挂号安排 A, 部门表 B
                 Where a.科室id = b.Id And a.号码 = 号码_In
                      --科室，项目，医生相同的已经导入了一个号别就不再导入
                       And Not Exists (Select 1
                        From 临床出诊号源
                        Where 科室id = a.科室id And 项目id = a.项目id And Nvl(医生姓名, '-') = Nvl(a.医生姓名, '-') And
                              Nvl(医生id, 0) = Nvl(a.医生id, 0))) Loop
    
      n_是否导入 := 1;
      --对于科室，项目，医生三者都相同的多个号别，首先考虑导入有效号别中的第一个，如果没有，则导入失效号别中的第一个
      Select Count(1)
      Into n_Count
      From 挂号安排
      Where 科室id = c_号源.科室id And 项目id = c_号源.项目id And Nvl(医生姓名, '-') = Nvl(c_号源.医生姓名, '-') And
            Nvl(医生id, 0) = Nvl(c_号源.医生id, 0);
      If Nvl(n_Count, 0) = 1 Then
        --科室，项目，医生是唯一的
        n_是否导入 := 1;
      Else
        --是否存在未停用且未删除的号别
        Select Count(1)
        Into n_Count
        From 挂号安排
        Where 科室id = c_号源.科室id And 项目id = c_号源.项目id And Nvl(医生姓名, '-') = Nvl(c_号源.医生姓名, '-') And
              Nvl(医生id, 0) = Nvl(c_号源.医生id, 0) And c_号源.是否删除 = 0 And
              (停用日期 Is Null Or 停用日期 = To_Date('3000-01-01', 'yyyy-mm-dd'));
        If Nvl(n_Count, 0) = 0 Then
          --不存在未停用且未删除的号别，直接导入当前号别，即失效号别中的第一个
          n_是否导入 := 1;
        Elsif Nvl(n_Count, 0) = 1 Then
          --只存在一个未停用且未删除的号别，检查是不是当前号别
          If c_号源.是否删除 = 0 And c_号源.停用日期 = To_Date('3000-01-01', 'yyyy-mm-dd') Then
            n_是否导入 := 1;
          Else
            n_是否导入 := 0;
          End If;
        Else
          --检查当前号别是否已停用或已删除
          If Not (c_号源.是否删除 = 0 And c_号源.停用日期 = To_Date('3000-01-01', 'yyyy-mm-dd')) Then
            --已停用或已删除则不导入
            n_是否导入 := 0;
          Else
            --当前号别安排/计划是否有效
            Select Count(1)
            Into n_Count
            From 挂号安排计划
            Where 安排id = c_号源.Id And 审核时间 Is Not Null And Nvl(失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) > Sysdate And
                  Rownum < 2;
            If Nvl(n_Count, 0) = 0 Then
              --无计划
              Select Count(1)
              Into n_Count
              From 挂号安排 A
              Where a.Id = c_号源.Id And Nvl(a.终止时间, To_Date('3000-01-01', 'yyyy-mm-dd')) > Sysdate And
                    Not (a.周日 Is Null And a.周一 Is Null And a.周二 Is Null And a.周三 Is Null And a.周四 Is Null And
                     a.周五 Is Null And a.周六 Is Null);
            Else
              --只要生效时间大于当前时间或者不存在大于其生效时间小于当前时间的都是有效的，
              --因为1.生效时间和号码是唯一的，2.是以生效时间最近的来确定是有效的，
              --     即如果当前计划的生效时间小于等于当前时间且是所有生效时间小于等于当前时间的计划中生效时间最大的，则当前计划是有效的

              Select Count(1)
              Into n_Count
              From 挂号安排计划 A
              Where a.审核时间 Is Not Null And Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) > Sysdate And
                    a.安排id = c_号源.Id And
                    (Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) >= Sysdate Or
                    Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) < Sysdate And Not Exists
                     (Select 1
                      From 挂号安排计划
                      Where 安排id = a.安排id And 审核时间 Is Not Null And
                            Nvl(失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) > Sysdate And
                            Nvl(生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) < Sysdate And
                            Nvl(生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) >
                            Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')))) And
                    Not (a.周日 Is Null And a.周一 Is Null And a.周二 Is Null And a.周三 Is Null And a.周四 Is Null And
                     a.周五 Is Null And a.周六 Is Null);
            End If;
          
            If Nvl(n_Count, 0) <> 0 Then
              --当前号别安排有效
              n_是否导入 := 1;
            Else
              --当前号别安排无效
              n_是否导入 := 0;
            End If;
          End If;
        End If;
      End If;
    
      If Nvl(n_是否导入, 0) = 1 Then
        Select 临床出诊号源_Id.Nextval Into n_号源id From Dual;
      
        Select Nvl(Min(开始时间), Sysdate)
        Into d_建档时间
        From (Select Min(开始时间) As 开始时间
               From 挂号安排
               Where ID = c_号源.Id
               Union All
               Select Min(生效时间) As 开始时间
               From 挂号安排计划
               Where 审核时间 Is Not Null And Nvl(失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) > Sysdate And 安排id = c_号源.Id);
      
        --1.处理临床出诊号源
        Insert Into 临床出诊号源
          (ID, 号类, 号码, 科室id, 项目id, 医生id, 医生姓名, 是否建病案, 预约天数, 出诊频次, 假日控制状态, 是否临床排班, 排班方式, 是否删除, 建档时间, 撤档时间)
        Values
          (n_号源id, c_号源.号类, c_号源.号码, c_号源.科室id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, c_号源.病案必须, c_号源.预约天数, c_号源.默认时段间隔, 2,
           0, 0, c_号源.是否删除, d_建档时间, c_号源.停用日期);
      
        --2.处理临床出诊停诊记录
        --一个医生一个停诊计划只导入一个，可能存在一个医生多个号别的情况，他们的停诊计划一样
        Insert Into 临床出诊停诊记录
          (ID, 记录id, 开始时间, 终止时间, 停诊原因, 申请人, 申请时间, 审批人, 审批时间, 登记人)
          Select 临床出诊停诊记录_Id.Nextval, Null, a.开始停止时间, a.结束停止时间, a.备注, b.医生姓名, a.制订日期, a.制订人, a.制订日期, a.制订人
          From 挂号安排停用状态 A, 挂号安排 B
          Where a.安排id = b.Id And b.Id = c_号源.Id And b.医生id Is Not Null And Not Exists
           (Select 1
                 From 临床出诊停诊记录
                 Where 记录id Is Null And 申请人 = b.医生姓名 And 开始时间 = a.开始停止时间 And 终止时间 = a.结束停止时间);
      
        --3.处理相关的出诊表数据
        --3.1 固定出诊表
        If c_号源.站点 Is Null Then
          n_出诊id := 出诊id_In;
        Else
          Begin
            Select ID Into n_出诊id From 临床出诊表 Where 排班方式 = 0 And Nvl(站点, '-') = c_号源.站点;
          Exception
            When Others Then
              n_出诊id := 0;
          End;
          If n_出诊id = 0 Then
            Update 临床出诊表
            Set 站点 = c_号源.站点
            Where 排班方式 = 0 And Nvl(站点, '-') = '-'
            Returning ID Into n_出诊id;
            If Sql%NotFound Then
              Select 临床出诊表_Id.Nextval Into n_出诊id From Dual;
              Insert Into 临床出诊表
                (ID, 排班方式, 出诊表名, 年份, 站点)
              Values
                (n_出诊id, 0, '固定出诊表', To_Number(To_Char(Sysdate, 'yyyy')), c_号源.站点);
            End If;
          End If;
        End If;
      
        --3.2导入临床出诊安排
        --失效的安排和计划不导入
        --只要生效时间大于当前时间或者不存在大于其生效时间小于当前时间的都是有效的，
        --因为1.生效时间和号码是唯一的，2.是以生效时间最近的来确定是有效的，
        --     即如果当前计划的生效时间小于等于当前时间且是所有生效时间小于等于当前时间的计划中生效时间最大的，则当前计划是有效的

        For c_详情 In (
                     --1.无计划的安排
                     Select a.Id As 安排id, -1 * Null As 计划id, a.科室id, a.项目id, a.医生姓名,
                             Decode(a.医生id, 0, Null, a.医生id) As 医生id, a.周日, a.周一, a.周二, a.周三, a.周四, a.周五, a.周六, a.分诊方式,
                             a.序号控制, Nvl(a.开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')) As 开始时间,
                             Nvl(a.终止时间, To_Date('3000-01-01', 'yyyy-mm-dd')) As 终止时间
                     From 挂号安排 A
                     Where a.Id = c_号源.Id And Not Exists (Select 1
                            From 挂号安排计划
                            Where 安排id = a.Id And 审核时间 Is Not Null And
                                  Nvl(失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) > Sysdate) And
                           Nvl(a.终止时间, To_Date('3000-01-01', 'yyyy-mm-dd')) > Sysdate
                     Union All
                     --有计划的安排,只导入有效的
                     Select a.安排id, a.Id As 计划id, b.科室id, a.项目id, a.医生姓名, Decode(a.医生id, 0, Null, a.医生id) As 医生id, a.周日,
                            a.周一, a.周二, a.周三, a.周四, a.周五, a.周六, a.分诊方式, a.序号控制,
                            Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) As 开始时间,
                            Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) As 终止时间
                     From 挂号安排计划 A, 挂号安排 B
                     Where a.安排id = b.Id And a.审核时间 Is Not Null And
                           Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) > Sysdate And b.Id = c_号源.Id And
                           (Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) >= Sysdate Or
                           Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) < Sysdate And Not Exists
                            (Select 1
                             From 挂号安排计划
                             Where 安排id = a.安排id And 审核时间 Is Not Null And
                                   Nvl(失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) > Sysdate And
                                   Nvl(生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) < Sysdate And
                                   Nvl(生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) >
                                   Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd'))))) Loop
        
          Select 临床出诊安排_Id.Nextval Into n_安排id From Dual;
        
          n_诊室id := Null;
          If Nvl(c_详情.分诊方式, 0) = 1 Then
            Begin
              If Nvl(c_详情.计划id, 0) <> 0 Then
                Select a.Id
                Into n_诊室id
                From 门诊诊室 A, 挂号计划诊室 B
                Where a.名称 = b.门诊诊室 And b.计划id = c_详情.计划id And Rownum < 2;
              Else
                Select a.Id
                Into n_诊室id
                From 门诊诊室 A, 挂号安排诊室 B
                Where a.名称 = b.门诊诊室 And b.号表id = c_详情.安排id And Rownum < 2;
              End If;
            Exception
              When Others Then
                n_诊室id := Null;
            End;
          End If;
        
          --a.临床出诊安排
          Select Count(1)
          Into n_是否临时安排
          From 临床出诊安排
          Where 出诊id = n_出诊id And 号源id = n_号源id And Rownum < 2;
          Insert Into 临床出诊安排
            (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 开始时间, 终止时间, 操作员姓名, 登记时间, 是否临时安排)
          Values
            (n_安排id, n_出诊id, n_号源id, c_详情.项目id, c_详情.医生id, c_详情.医生姓名, c_详情.开始时间, c_详情.终止时间, Zl_Username, c_详情.开始时间,
             n_是否临时安排);
        
          --b.临床出诊限制
          --说明：限约数等于0表示禁止预约，限约数为空表示不限制预约
          If Nvl(c_详情.计划id, 0) <> 0 Then
            Select Count(1) Into n_Count From 挂号计划限制 Where 计划id = c_详情.计划id And Rownum < 2;
            If n_Count = 0 Then
              Insert Into 临床出诊限制
                (ID, 安排id, 限号数, 限约数, 是否序号控制, 是否分时段, 预约控制, 限制项目, 上班时段, 分诊方式, 诊室id)
                Select 临床出诊限制_Id.Nextval, n_安排id, Null, Null, c_详情.序号控制, Decode(b.星期, Null, 0, 1) As 是否分时段,
                       Nvl((Select 1
                            From 挂号计划限制
                            Where 计划id = c_详情.计划id And 限制项目 = a.限制项目 And 限约数 = 0 And Rownum < 2), 0), a.限制项目, a.上班时段,
                       c_详情.分诊方式, n_诊室id
                From (Select '周日' As 限制项目, c_详情.周日 As 上班时段
                       From Dual
                       Where c_详情.周日 Is Not Null
                       Union All
                       Select '周一', c_详情.周一
                       From Dual
                       Where c_详情.周一 Is Not Null
                       Union All
                       Select '周二', c_详情.周二
                       From Dual
                       Where c_详情.周二 Is Not Null
                       Union All
                       Select '周三', c_详情.周三
                       From Dual
                       Where c_详情.周三 Is Not Null
                       Union All
                       Select '周四', c_详情.周四
                       From Dual
                       Where c_详情.周四 Is Not Null
                       Union All
                       Select '周五', c_详情.周五
                       From Dual
                       Where c_详情.周五 Is Not Null
                       Union All
                       Select '周六', c_详情.周六 From Dual Where c_详情.周六 Is Not Null) A,
                     (Select Distinct 星期 From 挂号计划时段 Where 计划id = c_详情.计划id) B
                Where a.限制项目 = b.星期(+);
            Else
              Insert Into 临床出诊限制
                (ID, 安排id, 限制项目, 上班时段, 限号数, 限约数, 是否序号控制, 是否分时段, 预约控制, 分诊方式, 诊室id)
                Select 临床出诊限制_Id.Nextval, n_安排id, 限制项目,
                       Decode(限制项目, '周日', c_详情.周日, '周一', c_详情.周一, '周二', c_详情.周二, '周三', c_详情.周三, '周四', c_详情.周四, '周五',
                               c_详情.周五, '周六', c_详情.周六, Null), 限号数, 限约数, c_详情.序号控制, Decode(b.星期, Null, 0, 1) As 是否分时段,
                       Nvl((Select 1
                            From 挂号计划限制
                            Where 计划id = c_详情.计划id And 限制项目 = a.限制项目 And 限约数 = 0 And Rownum < 2), 0), c_详情.分诊方式, n_诊室id
                From 挂号计划限制 A, (Select Distinct 星期 From 挂号计划时段 Where 计划id = c_详情.计划id) B
                Where a.限制项目 = b.星期(+) And 计划id = c_详情.计划id;
            End If;
          Else
            Select Count(1) Into n_Count From 挂号安排限制 Where 安排id = c_详情.安排id And Rownum < 2;
            If n_Count = 0 Then
              Insert Into 临床出诊限制
                (ID, 安排id, 限号数, 限约数, 是否序号控制, 是否分时段, 预约控制, 限制项目, 上班时段, 分诊方式, 诊室id)
                Select 临床出诊限制_Id.Nextval, n_安排id, Null, Null, c_详情.序号控制, Decode(b.星期, Null, 0, 1) As 是否分时段,
                       Nvl((Select 1
                            From 挂号安排限制
                            Where 安排id = c_详情.安排id And 限制项目 = a.限制项目 And 限约数 = 0 And Rownum < 2), 0), a.限制项目, a.上班时段,
                       c_详情.分诊方式, n_诊室id
                From (Select '周日' As 限制项目, c_详情.周日 As 上班时段
                       From Dual
                       Where c_详情.周日 Is Not Null
                       Union All
                       Select '周一', c_详情.周一
                       From Dual
                       Where c_详情.周一 Is Not Null
                       Union All
                       Select '周二', c_详情.周二
                       From Dual
                       Where c_详情.周二 Is Not Null
                       Union All
                       Select '周三', c_详情.周三
                       From Dual
                       Where c_详情.周三 Is Not Null
                       Union All
                       Select '周四', c_详情.周四
                       From Dual
                       Where c_详情.周四 Is Not Null
                       Union All
                       Select '周五', c_详情.周五
                       From Dual
                       Where c_详情.周五 Is Not Null
                       Union All
                       Select '周六', c_详情.周六 From Dual Where c_详情.周六 Is Not Null) A,
                     (Select Distinct 星期 From 挂号安排时段 Where 安排id = c_详情.安排id) B
                Where a.限制项目 = b.星期(+);
            Else
              Insert Into 临床出诊限制
                (ID, 安排id, 限制项目, 上班时段, 限号数, 限约数, 是否序号控制, 是否分时段, 预约控制, 分诊方式, 诊室id)
                Select 临床出诊限制_Id.Nextval, n_安排id, 限制项目,
                       Decode(限制项目, '周日', c_详情.周日, '周一', c_详情.周一, '周二', c_详情.周二, '周三', c_详情.周三, '周四', c_详情.周四, '周五',
                               c_详情.周五, '周六', c_详情.周六, Null), 限号数, 限约数, c_详情.序号控制, Decode(b.星期, Null, 0, 1) As 是否分时段,
                       Nvl((Select 1
                            From 挂号安排限制
                            Where 安排id = c_详情.安排id And 限制项目 = a.限制项目 And 限约数 = 0 And Rownum < 2), 0), c_详情.分诊方式, n_诊室id
                From 挂号安排限制 A, (Select Distinct 星期 From 挂号安排时段 Where 安排id = c_详情.安排id) B
                Where a.限制项目 = b.星期(+) And 安排id = c_详情.安排id;
            End If;
          End If;
        
          --c.临床出诊诊室
          If Nvl(c_详情.分诊方式, 0) > 0 Then
            If Nvl(c_详情.计划id, 0) <> 0 Then
              Insert Into 临床出诊诊室
                (限制id, 诊室id)
                Select a.Id, b.诊室id
                From 临床出诊限制 A,
                     (Select Distinct a.Id As 诊室id
                       From 门诊诊室 A, 挂号计划诊室 B
                       Where a.名称 = b.门诊诊室 And b.计划id = c_详情.计划id) B
                Where a.安排id = n_安排id;
            Else
              Insert Into 临床出诊诊室
                (限制id, 诊室id)
                Select a.Id, b.诊室id
                From 临床出诊限制 A,
                     (Select Distinct a.Id As 诊室id
                       From 门诊诊室 A, 挂号安排诊室 B
                       Where a.名称 = b.门诊诊室 And b.号表id = c_详情.安排id) B
                Where a.安排id = n_安排id;
            End If;
          End If;
        
          --D.临床出诊时段
          If Nvl(c_详情.计划id, 0) <> 0 Then
            Insert Into 临床出诊时段
              (限制id, 序号, 开始时间, 终止时间, 限制数量, 是否预约)
              Select a.Id, b.序号, b.开始时间, b.结束时间, b.限制数量, b.是否预约
              From 临床出诊限制 A,
                   (Select n_安排id As 安排id, 星期,
                            Decode(星期, '周日', c_详情.周日, '周一', c_详情.周一, '周二', c_详情.周二, '周三', c_详情.周三, '周四', c_详情.周四, '周五',
                                    c_详情.周五, '周六', c_详情.周六, Null) As 上班时段, 序号, 开始时间, 结束时间, 限制数量, 是否预约

                     
                     From 挂号计划时段
                     Where 计划id = c_详情.计划id) B
              Where a.安排id = b.安排id And a.限制项目 = b.星期 And a.上班时段 = b.上班时段;
          
          Else
            Insert Into 临床出诊时段
              (限制id, 序号, 开始时间, 终止时间, 限制数量, 是否预约)
              Select a.Id, b.序号, b.开始时间, b.结束时间, b.限制数量, b.是否预约
              From 临床出诊限制 A,
                   (Select n_安排id As 安排id, 星期,
                            Decode(星期, '周日', c_详情.周日, '周一', c_详情.周一, '周二', c_详情.周二, '周三', c_详情.周三, '周四', c_详情.周四, '周五',
                                    c_详情.周五, '周六', c_详情.周六, Null) As 上班时段, 序号, 开始时间, 结束时间, 限制数量, 是否预约

                     
                     From 挂号安排时段
                     Where 安排id = c_详情.安排id) B
              Where a.安排id = b.安排id And a.限制项目 = b.星期 And a.上班时段 = b.上班时段;
          End If;
        
          --不分时段的序号控制号先生成序号
          --开始时间、终止时间填写时间段的开始时间和结束时间
          For c_限制项目 In (Select ID, 限号数, 上班时段
                         From 临床出诊限制
                         Where 安排id = n_安排id And Nvl(限号数, 0) <> 0 And Nvl(是否序号控制, 0) = 1 And Nvl(是否分时段, 0) = 0) Loop
            For I In 1 .. c_限制项目.限号数 Loop
              Insert Into 临床出诊时段
                (限制id, 序号, 开始时间, 终止时间, 限制数量, 是否预约)
                Select c_限制项目.Id, I, 开始时间, 终止时间, 1, 1
                From 时间段
                Where 站点 Is Null And 号类 Is Null And 时间段 = c_限制项目.上班时段;
            End Loop;
          End Loop;
        
          --任何一个都不允许预约时表示全部允许预约
          Update 临床出诊时段 A
          Set a.是否预约 = 1
          Where 限制id In (Select ID From 临床出诊限制 Where 安排id = n_安排id) And Not Exists
           (Select 1 From 临床出诊时段 B Where a.限制id = b.限制id And Nvl(b.是否预约, 0) = 1);
        
          --E.合作单位挂号控制
          If Nvl(c_详情.计划id, 0) <> 0 Then
            Insert Into 临床出诊挂号控制
              (限制id, 类型, 性质, 名称, 序号, 控制方式, 数量)
              Select a.Id, b.类型, b.性质, b.合作单位, b.序号, b.控制方式, b.数量
              From 临床出诊限制 A,
                   (Select 1 As 类型, 1 As 性质, 合作单位, n_安排id As 安排id, 限制项目,
                            Decode(限制项目, '周日', c_详情.周日, '周一', c_详情.周一, '周二', c_详情.周二, '周三', c_详情.周三, '周四', c_详情.周四, '周五',
                                    c_详情.周五, '周六', c_详情.周六, Null) As 上班时段, 序号,
                            Case
                               When Nvl(序号, 0) = 0 And Nvl(数量, 0) = 0 Then
                                0
                               When 序号 = 0 And Nvl(数量, 0) <> 0 Then
                                2
                               When Nvl(序号, 0) <> 0 And Nvl(数量, 0) <> 0 Then
                                3
                               Else
                                4
                             End As 控制方式, 数量
                     From 合作单位计划控制
                     Where 计划id = c_详情.计划id And
                           Decode(限制项目, '周日', c_详情.周日, '周一', c_详情.周一, '周二', c_详情.周二, '周三', c_详情.周三, '周四', c_详情.周四, '周五',
                                  c_详情.周五, '周六', c_详情.周六, Null) Is Not Null) B
              Where a.安排id = b.安排id And a.限制项目 = b.限制项目 And a.上班时段 = b.上班时段;
          Else
            Insert Into 临床出诊挂号控制
              (限制id, 类型, 性质, 名称, 序号, 控制方式, 数量)
              Select a.Id, b.类型, b.性质, b.合作单位, b.序号, b.控制方式, b.数量
              From 临床出诊限制 A,
                   (Select 1 As 类型, 1 As 性质, 合作单位, n_安排id As 安排id, 限制项目,
                            Decode(限制项目, '周日', c_详情.周日, '周一', c_详情.周一, '周二', c_详情.周二, '周三', c_详情.周三, '周四', c_详情.周四, '周五',
                                    c_详情.周五, '周六', c_详情.周六, Null) As 上班时段, 序号,
                            Case
                              When Nvl(序号, 0) = 0 And Nvl(数量, 0) = 0 Then
                               0
                              When 序号 = 0 And Nvl(数量, 0) <> 0 Then
                               2
                              When Nvl(序号, 0) <> 0 And Nvl(数量, 0) <> 0 Then
                               3
                              Else
                               4
                            End As 控制方式, 数量
                     From 合作单位安排控制
                     Where 安排id = c_详情.安排id And
                           Decode(限制项目, '周日', c_详情.周日, '周一', c_详情.周一, '周二', c_详情.周二, '周三', c_详情.周三, '周四', c_详情.周四, '周五',
                                  c_详情.周五, '周六', c_详情.周六, Null) Is Not Null) B
              Where a.安排id = b.安排id And a.限制项目 = b.限制项目 And a.上班时段 = b.上班时段;
          End If;
        End Loop;
      
        --4.停用没有有效安排的号源，并删除无效的安排
        --主要是处理所有计划已失效或者有效计划只有一个且这个计划周一到周日都没有上班时段的
        Select Count(1)
        Into n_Count
        From 临床出诊限制 A, 临床出诊安排 B, 临床出诊号源 C
        Where a.安排id = b.Id And b.号源id = c.Id And c.Id = n_号源id And a.上班时段 Is Not Null And Nvl(c.是否删除, 0) = 0 And
              Nvl(c.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And Rownum < 2;
        If n_Count = 0 Then
          --没有有效的安排，停用号源，删除安排
          Select a.Id Bulk Collect
          Into l_限制id
          From 临床出诊限制 A, 临床出诊安排 B
          Where a.安排id = b.Id And b.号源id = n_号源id;
        
          Forall I In 1 .. l_限制id.Count
            Delete From 临床出诊诊室 Where 限制id = l_限制id(I);
        
          Forall I In 1 .. l_限制id.Count
            Delete From 临床出诊时段 Where 限制id = l_限制id(I);
        
          Forall I In 1 .. l_限制id.Count
            Delete From 临床出诊挂号控制 Where 限制id = l_限制id(I);
        
          Forall I In 1 .. l_限制id.Count
            Delete From 临床出诊限制 Where ID = l_限制id(I);
        
          Delete From 临床出诊安排 Where 号源id = n_号源id;
        
          Update 临床出诊号源 Set 撤档时间 = Sysdate Where ID = n_号源id;
        End If;
      
        --5.拷贝一份出诊信息作为号源控制信息
        --说明：上班时段按安排的登记时间倒序取第一个
        For c_限制 In (Select ID, 上班时段, 限号数, 限约数, 是否序号控制, 是否分时段, 预约控制, 是否独占, 分诊方式, 诊室id
                     From (Select a.Id, a.上班时段, a.限号数, a.限约数, a.是否序号控制, a.是否分时段, a.预约控制, a.是否独占, a.分诊方式, a.诊室id,
                                   Row_Number() Over(Partition By a.上班时段 Order By b.登记时间 Desc) As 组号
                            From 临床出诊限制 A, 临床出诊安排 B
                            Where a.安排id = b.Id And b.号源id = n_号源id)
                     Where 组号 = 1) Loop
          --a.临床出诊号源限制
          Select 临床出诊号源限制_Id.Nextval Into n_限制id From Dual;
          Insert Into 临床出诊号源限制
            (ID, 号源id, 上班时段, 限号数, 限约数, 是否序号控制, 是否分时段, 预约控制, 是否独占, 分诊方式, 诊室id)
          Values
            (n_限制id, n_号源id, c_限制.上班时段, c_限制.限号数, c_限制.限约数, c_限制.是否序号控制, c_限制.是否分时段, c_限制.预约控制, c_限制.是否独占, c_限制.分诊方式,
             c_限制.诊室id);
          --b.临床出诊号源诊室
          Insert Into 临床出诊号源诊室
            (限制id, 诊室id)
            Select n_限制id, 诊室id From 临床出诊诊室 Where 限制id = c_限制.Id;
          --c.临床出诊号源时段
          Insert Into 临床出诊号源时段
            (限制id, 序号, 开始时间, 终止时间, 限制数量, 是否预约)
            Select n_限制id, 序号, 开始时间, 终止时间, 限制数量, 是否预约 From 临床出诊时段 Where 限制id = c_限制.Id;
          --d.临床出诊号源控制
          Insert Into 临床出诊号源控制
            (限制id, 类型, 性质, 名称, 序号, 控制方式, 数量)
            Select n_限制id, 类型, 性质, 名称, 序号, 控制方式, 数量 From 临床出诊挂号控制 Where 限制id = c_限制.Id;
        End Loop;
      End If;
    End Loop;
  End;
Begin
  If Nvl(开始_In, 0) = 1 Then
    Select Count(1) Into n_Count From 临床出诊表 A, 临床出诊安排 B Where a.Id = b.出诊id And Rownum < 2;
    If n_Count <> 0 Then
      v_Err_Msg := '当前已经存在临床出诊安排了，请先删除，否则不允许导入！';
      Raise Err_Item;
    End If;
  
    Begin
      Select f_List2str(Cast(Collect(s.时间段) As t_Strlist))
      Into v_时间段
      From (Select 时间段, Row_Number() Over(Partition By 时间段 Order By 时间段) As 组号
             From (Select Decode(b.行号, 1, a.周一, 2, a.周二, 3, a.周三, 4, a.周四, 5, a.周五, 6, a.周六, a.周日) As 时间段
                    From (Select 周一, 周二, 周三, 周四, 周五, 周六, 周日
                           From 挂号安排
                           Union All
                           Select 周一, 周二, 周三, 周四, 周五, 周六, 周日
                           From 挂号安排计划
                           Where 审核时间 Is Not Null And Nvl(失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) > Sysdate) A,
                         (Select Level As 行号 From Dual Connect By Level <= 7) B)
             Where 时间段 Is Not Null) S, 时间段 T
      Where s.时间段 = t.时间段(+) And t.时间段 Is Null And s.组号 = 1;
    Exception
      When Others Then
        v_时间段 := Null;
    End;
  
    If v_时间段 Is Not Null Then
      v_Err_Msg := '原挂号安排中的上班时间段【' || v_时间段 || '】不存在，请先在“基础设置>上班时间管理”中添加！';
      Raise Err_Item;
    End If;
  
    --删除现有所有号源，在调用之前已进行了提示
    Select a.Id Bulk Collect Into l_限制id From 临床出诊号源限制 A, 临床出诊号源 B Where a.号源id = b.Id;
  
    Forall I In 1 .. l_限制id.Count
      Delete From 临床出诊号源诊室 Where 限制id = l_限制id(I);
  
    Forall I In 1 .. l_限制id.Count
      Delete From 临床出诊号源时段 Where 限制id = l_限制id(I);
  
    Forall I In 1 .. l_限制id.Count
      Delete From 临床出诊号源控制 Where 限制id = l_限制id(I);
  
    Forall I In 1 .. l_限制id.Count
      Delete From 临床出诊号源限制 Where ID = l_限制id(I);
  
    Delete From 临床出诊号源;
  
    --删除所有停诊记录
    Delete From 临床出诊停诊记录;
  End If;

  --不分站点号源如果没有指定站点，则放入第一个出诊表中
  v_全院号源归属站点 := zl_GetSysParameter('未区分站点的号源的维护站点', 1114);
  Begin
    Select Min(ID) Into n_出诊id From 临床出诊表 Where 排班方式 = 0;
  Exception
    When Others Then
      n_出诊id := 0;
  End;
  If Nvl(n_出诊id, 0) = 0 Then
    Select 临床出诊表_Id.Nextval Into n_出诊id From Dual;
    Insert Into 临床出诊表
      (ID, 排班方式, 出诊表名, 年份, 站点)
    Values
      (n_出诊id, 0, '固定出诊表', To_Number(To_Char(Sysdate, 'yyyy')), Null);
  End If;

  If Not 号码_In Is Null Then
    Zl_Register_Import(号码_In, n_出诊id, v_全院号源归属站点);
    Return;
  End If;

  For c_号源 In (Select 号码 From 挂号安排 Order By ID Desc) Loop
    --删除以及停用的号源也全部导入
    Zl_Register_Import(c_号源.号码, n_出诊id, v_全院号源归属站点);
  End Loop;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊表_导入;
/

--121587:冉俊明,2018-02-06,临床出诊号源安排分站点进行维护
Create Or Replace Procedure Zl_临床出诊表_Totemplet
(
  出诊id_In   临床出诊表.Id%Type,
  模板id_In   临床出诊表.Id%Type,
  出诊表名_In 临床出诊表.出诊表名%Type,
  应用范围_In 临床出诊表.应用范围%Type,
  科室id_In   临床出诊表.科室id%Type,
  备注_In     临床出诊表.备注%Type,
  操作员_In   临床出诊安排.操作员姓名%Type,
  操作时间_In 临床出诊安排.登记时间%Type,
  站点_In     部门表.站点%Type,
  人员id_In   人员表.Id%Type := Null
) As
  --功能：由月/周出诊表生成模板 
  --参数： 
  --        出诊id_In 月/周出诊表的出诊ID 
  --        人员id_In 除固定安排外有效，不为0或null表示临床科室人员在添加 
  --说明： 
  v_Err_Msg Varchar2(255);
  Err_Item Exception;
  n_Count Number(8);

  n_模板id       临床出诊表.Id%Type;
  n_模板类型     临床出诊表.模板类型%Type;
  n_跨月周出诊id 临床出诊表.Id%Type;

  n_安排id 临床出诊安排.Id%Type;
Begin
  Select Count(1)
  Into n_Count
  From 临床出诊号源 A, 临床出诊安排 B, 临床出诊记录 C, 部门表 D, 人员表 E, 收费项目目录 F
  Where a.Id = b.号源id And b.Id = c.安排id And a.科室id = d.Id And a.医生id = e.Id(+) And a.项目id = f.Id And a.排班方式 In (1, 2) And
        Nvl(a.是否删除, 0) = 0 And (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
        Nvl(d.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
        Nvl(e.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
        Nvl(f.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd')
       --当前人员可操作的号源 
        And (Nvl(人员id_In, 0) = 0 Or
        (Nvl(a.是否临床排班, 0) = 1 And Exists (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
       --站点 
        And (d.站点 Is Null Or d.站点 = 站点_In) And b.出诊id = 出诊id_In And Rownum < 2;
  If Nvl(n_Count, 0) = 0 Then
    v_Err_Msg := '当前出诊表中无有效的安排，不能另存为模板！';
    Raise Err_Item;
  End If;

  --排班方式：0-固定排班;1-按月排班;2-按周排班;3-模板 
  Select Count(1)
  Into n_Count
  From 临床出诊表
  Where 出诊表名 = 出诊表名_In And 排班方式 = 3 And Nvl(站点, '-') = Nvl(站点_In, '-') And Rownum < 2;
  If Nvl(n_Count, 0) > 0 Then
    v_Err_Msg := '当前院区已存在名为“' || 出诊表名_In || '”的模板！';
    Raise Err_Item;
  End If;

  Begin
    Select Decode(排班方式, 1, 2, 0)
    Into n_模板类型
    From 临床出诊表
    Where ID = 出诊id_In And 排班方式 In (1, 2) And Rownum < 2;
  Exception
    When Others Then
      v_Err_Msg := '未发现当前出诊表！';
      Raise Err_Item;
  End;

  n_模板id := 模板id_In;
  If Nvl(n_模板id, 0) = 0 Then
    Select 临床出诊表_Id.Nextval Into n_模板id From Dual;
  End If;

  --模板，肯定是新出诊表 
  Insert Into 临床出诊表
    (ID, 排班方式, 出诊表名, 应用范围, 科室id, 备注, 发布人, 发布时间, 模板类型, 站点)
  Values
    (n_模板id, 3, 出诊表名_In, 应用范围_In, 科室id_In, 备注_In, 操作员_In, 操作时间_In, n_模板类型, 站点_In);

  --如果原周出诊表不是整周(不足7天)，则需要查找到另一个出诊表构成整周 
  If Nvl(n_模板类型, 0) = 0 Then
    n_跨月周出诊id := Zl_Get跨月周出诊id(出诊id_In);
  End If;

  --月/周出诊表保存为模板 
  For c_安排 In (Select b.Id As 安排id, b.号源id, a.项目id, a.医生id, a.医生姓名
               From 临床出诊号源 A, 临床出诊安排 B, 部门表 D, 人员表 E, 收费项目目录 F
               Where a.Id = b.号源id And a.科室id = d.Id And a.医生id = e.Id(+) And a.项目id = f.Id And a.排班方式 In (1, 2) And
                     Nvl(a.是否删除, 0) = 0 And (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
                     Nvl(d.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     Nvl(e.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     Nvl(f.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd')
                    --当前人员可操作的号源 
                     And (Nvl(人员id_In, 0) = 0 Or (Nvl(a.是否临床排班, 0) = 1 And Exists
                      (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
                    --站点 
                     And (d.站点 Is Null Or d.站点 = 站点_In) And (b.出诊id = 出诊id_In Or b.出诊id = n_跨月周出诊id)) Loop
  
    Begin
      Select ID Into n_安排id From 临床出诊安排 Where 出诊id = n_模板id And 号源id = c_安排.号源id;
    Exception
      When Others Then
        n_安排id := Null;
    End;
  
    If Nvl(n_安排id, 0) = 0 Then
      Select 临床出诊安排_Id.Nextval Into n_安排id From Dual;
    
      --1.临床出诊安排 
      --排班规则:1-星期排班;2-单日排班;3-双日排班;4-月内轮循;5-轮循不限制;6-特定日期 
      If Nvl(n_模板类型, 0) = 2 Then
        --按天安排出诊的月出诊表保存为特定日期的规则 
        Zl_临床出诊安排_Insert(n_安排id, n_模板id, c_安排.号源id, c_安排.项目id, c_安排.医生id, c_安排.医生姓名, 6, Null, Null, Null, Null, 操作员_In,
                         操作时间_In);
      Else
        Zl_临床出诊安排_Insert(n_安排id, n_模板id, c_安排.号源id, c_安排.项目id, c_安排.医生id, c_安排.医生姓名, 1, Null, Null, Null, Null, 操作员_In,
                         操作时间_In);
      End If;
    End If;
  
    For c_记录 In (Select 临床出诊限制_Id.Nextval As 限制id, Decode(b.Id, Null, a.Id, b.Id) As 记录id,
                        Decode(To_Char(a.出诊日期, 'D'), '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六',
                                '1', '周日') As 限制项目, To_Number(To_Char(a.出诊日期, 'dd')) || '日' As 出诊日期, a.上班时段,
                        Decode(b.Id, Null, a.限号数, b.限号数) As 限号数, Decode(b.Id, Null, a.限约数, b.限约数) As 限约数,
                        Decode(b.Id, Null, a.是否分时段, b.是否分时段) As 是否分时段, Decode(b.Id, Null, a.是否序号控制, b.是否序号控制) As 是否序号控制,
                        Decode(b.Id, Null, a.预约控制, b.预约控制) As 预约控制, Decode(b.Id, Null, a.是否独占, b.是否独占) As 是否独占,
                        Decode(b.Id, Null, a.分诊方式, b.分诊方式) As 分诊方式
                 From 临床出诊记录 A, 临床出诊记录 B
                 Where a.Id = b.相关id(+) And a.安排id = c_安排.安排id And a.相关id Is Null And Nvl(a.是否临时出诊, 0) = 0) Loop
    
      --2.临床出诊限制 
      If Nvl(n_模板类型, 0) = 2 Then
        Insert Into 临床出诊限制
          (ID, 安排id, 限制项目, 上班时段, 限号数, 限约数, 是否分时段, 是否序号控制, 预约控制, 是否独占, 分诊方式)
        Values
          (c_记录.限制id, n_安排id, c_记录.出诊日期, c_记录.上班时段, c_记录.限号数, c_记录.限约数, c_记录.是否分时段, c_记录.是否序号控制, c_记录.预约控制, c_记录.是否独占,
           c_记录.分诊方式);
      Else
        Insert Into 临床出诊限制
          (ID, 安排id, 限制项目, 上班时段, 限号数, 限约数, 是否分时段, 是否序号控制, 预约控制, 是否独占, 分诊方式)
        Values
          (c_记录.限制id, n_安排id, c_记录.限制项目, c_记录.上班时段, c_记录.限号数, c_记录.限约数, c_记录.是否分时段, c_记录.是否序号控制, c_记录.预约控制, c_记录.是否独占,
           c_记录.分诊方式);
      End If;
    
      --3.临床出诊诊室 
      Insert Into 临床出诊诊室
        (限制id, 诊室id)
        Select c_记录.限制id, 诊室id From 临床出诊诊室记录 Where 记录id = c_记录.记录id;
    
      --4.临床出诊时段 
      --分时段不分序号的，在预约挂号时会新增记录，填写预约顺序号 
      If Nvl(c_记录.是否分时段, 0) = 1 And Nvl(c_记录.是否序号控制, 0) = 1 Then
        Insert Into 临床出诊时段
          (限制id, 序号, 开始时间, 终止时间, 限制数量, 是否预约)
          Select c_记录.限制id, 序号, 开始时间, 终止时间, 数量, 是否预约
          From 临床出诊序号控制
          Where 记录id = c_记录.记录id;
      Else
        Insert Into 临床出诊时段
          (限制id, 序号, 开始时间, 终止时间, 限制数量, 是否预约)
          Select c_记录.限制id, 序号, 开始时间, 终止时间, 数量, 是否预约
          From 临床出诊序号控制
          Where 记录id = c_记录.记录id And 预约顺序号 Is Null;
      End If;
    
      --5.临床出诊挂号控制 
      Insert Into 临床出诊挂号控制
        (限制id, 类型, 性质, 名称, 序号, 控制方式, 数量)
        Select c_记录.限制id, 类型, 性质, 名称, 序号, 控制方式, 数量
        From 临床出诊挂号控制记录
        Where 记录id = c_记录.记录id;
    End Loop;
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊表_Totemplet;
/

--121587:冉俊明,2018-02-06,临床出诊号源安排分站点进行维护
Create Or Replace Procedure Zl_临床出诊表_Delete
(
  Id_In     临床出诊表.Id%Type,
  人员id_In 人员表.Id%Type := Null,
  站点_In   部门表.站点%Type
) As
  --功能：删除临床出诊表 
  --参数： 
  --        人员id_In 除固定安排外有效，不为0或null表示临床科室人员在删除 
  n_Count    Number;
  n_出诊id   临床出诊表.Id%Type;
  n_排班方式 临床出诊表.排班方式%Type;
  v_站点     临床出诊表.站点%Type;

  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  l_记录id t_Numlist := t_Numlist();
  l_限制id t_Numlist := t_Numlist();
Begin
  Select Count(1) Into n_Count From 临床出诊表 Where 排班方式 <> 3 And 发布人 Is Not Null And ID = Id_In;
  If n_Count <> 0 Then
    v_Err_Msg := '当前出诊表已发布，不能删除！';
    Raise Err_Item;
  End If;

  Begin
    Select 排班方式, Nvl(站点, '-') Into n_排班方式, v_站点 From 临床出诊表 Where ID = Id_In;
  Exception
    When Others Then
      v_Err_Msg := '出诊表信息未找到！';
      Raise Err_Item;
  End;

  If Nvl(n_排班方式, 0) In (0, 3) Then
    --固定安排/模板 
    --删除临床出诊限制 
    Select b.Id Bulk Collect
    Into l_限制id
    From 临床出诊安排 A, 临床出诊限制 B
    Where a.Id = b.安排id And a.出诊id = Id_In;
  
    Forall I In 1 .. l_限制id.Count
      Delete From 临床出诊时段 Where 限制id = l_限制id(I);
  
    Forall I In 1 .. l_限制id.Count
      Delete From 临床出诊诊室 Where 限制id = l_限制id(I);
  
    Forall I In 1 .. l_限制id.Count
      Delete From 临床出诊挂号控制 Where 限制id = l_限制id(I);
  
    Forall I In 1 .. l_限制id.Count
      Delete From 临床出诊限制 Where ID = l_限制id(I);
  
    --删除临床出诊安排 
    Delete From 临床出诊安排 Where 出诊id = Id_In;
  
    --删除临床出诊表 
    Delete 临床出诊表 Where ID = Id_In;
  
    Return;
  End If;

  --======================================================================================================== 
  --月出诊表/周出诊表 
  --月出诊表/周出诊表只能从最后一个开始删除 
  Begin
    Select ID
    Into n_出诊id
    From (Select a.Id
           From 临床出诊表 A, 临床出诊安排 B, 临床出诊号源 C, 部门表 D
           Where a.排班方式 = n_排班方式 And a.Id = b.出诊id(+) And b.号源id = c.Id(+) And c.科室id = d.Id(+)
                --当前人员可操作的号源 
                 And (Nvl(人员id_In, 0) = 0 Or (Nvl(c.是否临床排班, 0) = 1 And Exists
                  (Select 1 From 部门人员 Where 部门id = c.科室id And 人员id = 人员id_In)))
                --站点 
                 And Nvl(a.站点, '-') = v_站点
           Order By a.年份 Desc, a.月份 Desc, a.周数 Desc)
    Where Rownum < 2;
  Exception
    When Others Then
      n_出诊id := 0;
  End;
  If Nvl(n_出诊id, 0) <> 0 And Nvl(n_出诊id, 0) <> Id_In Then
    v_Err_Msg := '必须从最后一个出诊表开始删除！';
    Raise Err_Item;
  End If;

  If Nvl(人员id_In, 0) <> 0 Then
    --没有"所有科室"权限 
    Select Count(1)
    Into n_Count
    From 临床出诊安排 A, 临床出诊号源 B
    Where a.号源id = b.Id And a.出诊id = Id_In And
          Not (Nvl(b.是否临床排班, 0) = 1 And Exists (Select 1 From 部门人员 Where 部门id = b.科室id And 人员id = 人员id_In)) And
          Rownum < 2;
    If n_Count <> 0 Then
      v_Err_Msg := '当前出诊表中含有其它人员已经制定的安排，不能删除！';
      Raise Err_Item;
    End If;
  End If;

  --删除临床出诊记录 
  Select a.Id Bulk Collect
  Into l_记录id
  From 临床出诊记录 A, 临床出诊安排 B, 临床出诊号源 C, 部门表 D
  Where a.安排id = b.Id And a.号源id = c.Id And c.科室id = d.Id And b.出诊id = Id_In
       --当前人员可操作的号源 
        And (Nvl(人员id_In, 0) = 0 Or
        (Nvl(c.是否临床排班, 0) = 1 And Exists (Select 1 From 部门人员 Where c.科室id = 部门id And 人员id = 人员id_In)))
       --站点 
        And (d.站点 Is Null Or d.站点 = 站点_In);

  Zl_临床出诊记录_Batchdelete(l_记录id);

  --删除临床出诊安排 
  Delete From 临床出诊安排 A
  Where a.出诊id = Id_In And Exists
   (Select 1
         From 临床出诊号源 B, 部门表 D
         Where a.号源id = b.Id And b.科室id = d.Id
              --当前人员可操作的号源 
               And (Nvl(人员id_In, 0) = 0 Or (Nvl(b.是否临床排班, 0) = 1 And Exists
                (Select 1 From 部门人员 Where b.科室id = 部门id And 人员id = 人员id_In)))
              --站点 
               And (d.站点 Is Null Or d.站点 = 站点_In));

  --删除临床出诊表 
  Delete 临床出诊表 A
  Where a.Id = Id_In And Not Exists (Select 1 From 临床出诊安排 Where 出诊id = a.Id And 号源id Is Not Null);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊表_Delete;
/

--121587:冉俊明,2018-02-06,临床出诊号源安排分站点进行维护
Create Or Replace Procedure Zl_临床出诊安排_Publish
(
  Id_In       临床出诊表.Id%Type,
  发布人_In   临床出诊表.发布人%Type := Null,
  发布时间_In 临床出诊表.发布时间%Type := Null,
  取消发布_In Number := 0
) As
  --发布和取消发布安排 
  --参数： 
  --        取消发布_In 是否取消发布 
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  n_Count    Number(2);
  n_排班方式 临床出诊表.排班方式%Type;
  v_站点     临床出诊表.站点%Type;
  l_记录id   t_Numlist := t_Numlist();

  d_开始时间 临床出诊安排.开始时间%Type;
  d_终止时间 临床出诊安排.终止时间%Type;

  n_跨月周出诊id 临床出诊表.Id%Type;
Begin
  Begin
    Select Nvl(排班方式, 0), Nvl(站点, '-') Into n_排班方式, v_站点 From 临床出诊表 Where ID = Id_In;
  Exception
    When Others Then
      v_Err_Msg := '出诊表信息未找到！';
      Raise Err_Item;
  End;

  If Nvl(取消发布_In, 0) = 0 Then
    --发布安排 
    If Nvl(n_排班方式, 0) = 0 Then
      Select Max(1)
      Into n_Count
      From 临床出诊安排 A, 临床出诊限制 B, 临床出诊表 C
      Where a.Id = b.安排id And a.出诊id = c.Id And c.排班方式 = 0 And c.Id = Id_In And Rownum < 2;
      If Nvl(n_Count, 0) = 0 Then
        v_Err_Msg := '当前出诊表无有效的安排，不能发布！';
        Raise Err_Item;
      End If;
    Else
      If Nvl(n_排班方式, 0) = 2 Then
        n_跨月周出诊id := Zl_Get跨月周出诊id(Id_In);
      End If;
      Select Max(1)
      Into n_Count
      From 临床出诊安排 A, 临床出诊记录 B, 临床出诊表 C
      Where a.Id = b.安排id And a.出诊id = c.Id And c.排班方式 In (1, 2) And (c.Id = Id_In Or c.Id = n_跨月周出诊id) And Rownum < 2;
      If Nvl(n_Count, 0) = 0 Then
        v_Err_Msg := '当前出诊表无有效的安排，不能发布！';
        Raise Err_Item;
      End If;
    
      Select Max(1)
      Into n_Count
      From 临床出诊记录 A, 临床出诊安排 B
      Where a.号源id = b.号源id And a.出诊日期 Between b.开始时间 And b.终止时间 And a.安排id <> b.Id And b.出诊id = Id_In And Rownum < 2;
      If Nvl(n_Count, 0) <> 0 Then
        v_Err_Msg := '当前出诊表中的部分号源在当前出诊表的生效时间范围内已经存在有效的安排，不能发布！';
        Raise Err_Item;
      End If;
    End If;
  
    --如果存在多个未发布的安排表，则不允许发布后面日期的安排，必须按最小有效时间进行发布 
    Select Max(1)
    Into n_Count
    From (Select ID, 年份 || LPad(月份, 2, '0') || 周数 As 日期
           From 临床出诊表
           Where Nvl(排班方式, 0) = Nvl(n_排班方式, 0) And Nvl(站点, '-') = v_站点 And 发布人 Is Null) A,
         (Select ID, 年份 || LPad(月份, 2, '0') || 周数 As 日期 From 临床出诊表 Where ID = Id_In) B
    Where a.日期 < b.日期 And Rownum < 2;
    If Nvl(n_Count, 0) <> 0 Then
      If Nvl(n_排班方式, 0) = 0 Then
        v_Err_Msg := '当前出诊表前面还有未发布的固定出诊表，必须先将其发布或删除后才能发布该出诊表！';
      Elsif Nvl(n_排班方式, 0) = 1 Then
        v_Err_Msg := '当前出诊表前面还有未发布的月出诊表，必须先将其发布或删除后才能发布该出诊表！';
      Elsif Nvl(n_排班方式, 0) = 2 Then
        v_Err_Msg := '当前出诊表前面还有未发布的周出诊表，必须先将其发布或删除后才能发布该出诊表！';
      End If;
      Raise Err_Item;
    End If;
  
    Update 临床出诊表 Set 发布人 = 发布人_In, 发布时间 = 发布时间_In Where ID = Id_In;
    Update 临床出诊安排 Set 审核人 = 发布人_In, 审核时间 = 发布时间_In Where 出诊id = Id_In;
  
    --删除发布时有安排，但是号源已被停用的记录 
    For c_安排 In (Select a.Id
                 From 临床出诊安排 A, 临床出诊号源 B, 部门表 C, 人员表 D, 收费项目目录 E
                 Where a.号源id = b.Id And b.科室id = c.Id And a.医生id = d.Id(+) And b.项目id = e.Id And a.出诊id = Id_In And
                       Not (Nvl(b.是否删除, 0) = 0 And (b.撤档时间 Is Null Or b.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
                        Nvl(c.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                        Nvl(d.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                        Nvl(e.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd'))) Loop
      Zl_临床出诊安排_Delete(c_安排.Id, Nvl(n_排班方式, 0));
    End Loop;
  
    If Nvl(n_排班方式, 0) <> 0 Then
      --月安排/周安排根据停诊安排和法定节假日调整出诊记录的出诊/预约情况 
      Select 开始时间, 终止时间 Into d_开始时间, d_终止时间 From 临床出诊安排 Where 出诊id = Id_In And Rownum < 2;
      For c_安排 In (Select a.Id, a.号源id, b.日期
                   From 临床出诊安排 A,
                        (Select Trunc(d_开始时间) + Level - 1 As 日期
                          From Dual
                          Connect By Level <= Trunc(d_终止时间) - Trunc(d_开始时间) + 1) B
                   Where a.出诊id = Id_In
                   Order By 号源id, 日期) Loop
      
        Zl_Clinicvisitmodify(c_安排.号源id, c_安排.Id, c_安排.日期, 发布人_In, 发布时间_In);
      End Loop;
    
      --修改临床出诊记录中的"是否发布" 
      Select a.Id Bulk Collect
      Into l_记录id
      From 临床出诊记录 A, 临床出诊安排 B
      Where a.安排id = b.Id And b.出诊id = Id_In;
    
      Forall I In 1 .. l_记录id.Count
        Update 临床出诊记录 Set 是否发布 = 1 Where ID = l_记录id(I);
    End If;
    Return;
  End If;

  --================================================================================================================== 
  --取消发布 
  Select Max(1)
  Into n_Count
  From (Select ID, 年份 || LPad(月份, 2, '0') || 周数 As 日期
         From 临床出诊表
         Where Nvl(排班方式, 0) = Nvl(n_排班方式, 0) And Nvl(站点, '-') = v_站点 And 发布人 Is Not Null) A,
       (Select ID, 年份 || LPad(月份, 2, '0') || 周数 As 日期 From 临床出诊表 Where ID = Id_In) B
  Where a.日期 > b.日期 And Rownum < 2;
  If Nvl(n_Count, 0) <> 0 Then
    If Nvl(n_排班方式, 0) = 0 Then
      v_Err_Msg := '当前出诊后面还有已发布的固定出诊表，必须先将其取消发布后才能取消发布该出诊表！';
    Elsif Nvl(n_排班方式, 0) = 1 Then
      v_Err_Msg := '当前出诊后面还有已发布的月出诊表，必须先将其取消发布后才能取消发布该出诊表！';
    Elsif Nvl(n_排班方式, 0) = 2 Then
      v_Err_Msg := '当前出诊后面还有已发布的周出诊表，必须先将其取消发布后才能取消发布该出诊表！';
    End If;
    Raise Err_Item;
  End If;

  Select Max(1)
  Into n_Count
  From 病人挂号记录 C, 临床出诊记录 A, 临床出诊安排 B
  Where c.出诊记录id = a.Id And a.安排id = b.Id And b.出诊id = Id_In And Rownum < 2;
  If Nvl(n_Count, 0) <> 0 Then
    v_Err_Msg := '当前出诊表的安排已被使用，不允许取消发布！';
    Raise Err_Item;
  End If;

  Update 临床出诊表 Set 发布人 = Null, 发布时间 = Null Where ID = Id_In;
  If Sql%NotFound Then
    v_Err_Msg := '出诊表信息未找到！';
    Raise Err_Item;
  End If;
  Update 临床出诊安排 Set 审核人 = Null, 审核时间 = Null Where 出诊id = Id_In;

  --固定安排取消发布时删除出诊记录 
  If Nvl(n_排班方式, 0) = 0 Then
    --删除出诊记录 
    Select a.Id Bulk Collect
    Into l_记录id
    From 临床出诊记录 A, 临床出诊安排 B
    Where a.安排id = b.Id And b.出诊id = Id_In;
  
    Zl_临床出诊记录_Batchdelete(l_记录id);
  Else
    --删除备份的出诊记录 
    Select a.Id Bulk Collect
    Into l_记录id
    From 临床出诊记录 A, 临床出诊安排 B
    Where a.安排id = b.Id And b.出诊id = Id_In And a.相关id Is Not Null;
  
    Zl_临床出诊记录_Batchdelete(l_记录id);
  
    --月安排/周安排清除停诊信息，并修改是否发布 
    Select a.Id Bulk Collect
    Into l_记录id
    From 临床出诊记录 A, 临床出诊安排 B
    Where a.安排id = b.Id And b.出诊id = Id_In;
  
    Forall I In 1 .. l_记录id.Count
      Delete From 临床出诊停诊记录 Where 记录id = l_记录id(I);
  
    --修改临床出诊记录中的"是否发布" 
    Select a.Id Bulk Collect
    Into l_记录id
    From 临床出诊记录 A, 临床出诊安排 B
    Where a.安排id = b.Id And b.出诊id = Id_In;
  
    Forall I In 1 .. l_记录id.Count
      Update 临床出诊记录
      Set 停诊开始时间 = Null, 停诊终止时间 = Null, 停诊原因 = Null, 是否发布 = 0
      Where ID = l_记录id(I);
  
    --恢复临床出诊序号控制的"是否预约"及"是否停诊" 
    For c_记录 In (Select a.Id, a.是否分时段, a.是否序号控制
                 From 临床出诊记录 A, 临床出诊安排 B
                 Where a.安排id = b.Id And b.出诊id = Id_In) Loop
      If Nvl(c_记录.是否分时段, 0) = 1 Then
        If Nvl(c_记录.是否序号控制, 0) = 0 Then
          Update 临床出诊序号控制 Set 是否预约 = 1 Where 记录id = c_记录.Id;
        Else
          Update 临床出诊序号控制 Set 是否预约 = Nvl(预约顺序号, 0), 是否停诊 = 0 Where 记录id = c_记录.Id;
        End If;
      End If;
    End Loop;
  
    --换休的不再恢复 
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊安排_Publish;
/

--121587:冉俊明,2018-02-08,临床出诊号源安排分站点进行维护
Create Or Replace Procedure Zl_临床出诊表_Add
(
  操作类型_In         Number,
  出诊id_In           临床出诊表.Id%Type,
  出诊表名_In         临床出诊表.出诊表名%Type,
  站点_In             部门表.站点%Type,
  全院号源归属站点_In 部门表.站点%Type,
  操作员_In           临床出诊安排.操作员姓名%Type := Null,
  操作时间_In         临床出诊安排.登记时间%Type := Null,
  开始时间_In         临床出诊安排.开始时间%Type := Null,
  终止时间_In         临床出诊安排.终止时间%Type := Null,
  年份_In             临床出诊表.年份%Type := Null,
  月份_In             临床出诊表.月份%Type := Null,
  周数_In             临床出诊表.周数%Type := Null,
  应用范围_In         临床出诊表.应用范围%Type := Null,
  科室id_In           临床出诊表.科室id%Type := Null,
  备注_In             临床出诊表.备注%Type := Null,
  人员id_In           人员表.Id%Type := Null,
  删除安排_In         Number := 0,
  模板类型_In         临床出诊表.模板类型%Type := Null
) As
  --功能：增加出诊表或模板
  --参数：
  --        操作类型_In 1-模板，2-固定安排, 3-月安排，4-周安排
  --        全院号源归属站点_In 不区分站点的号源的归属站点
  --        人员id_In 除固定安排外有效，不为0或null表示临床科室人员在添加
  --        删除安排_In 固定排班转为月排班/周排班时，在制定月排班/周排班时是否删除新出诊表时间内未使用的出诊记录
  --说明：
  v_Err_Msg Varchar2(255);
  Err_Item Exception;
  n_Count Number(8);

  n_出诊id       临床出诊表.Id%Type;
  n_跨月周出诊id 临床出诊表.Id%Type;
  n_跨月周安排id 临床出诊安排.Id%Type;

  l_记录id t_Numlist := t_Numlist();
Begin
  n_出诊id := 出诊id_In;
  If Nvl(n_出诊id, 0) = 0 Then
    Select 临床出诊表_Id.Nextval Into n_出诊id From Dual;
  End If;

  --排班方式：0-固定排班;1-按月排班;2-按周排班;3-模板
  --============================================================================================================================================
  --1.模板
  If Nvl(操作类型_In, 0) = 1 Then
    Select Count(1)
    Into n_Count
    From 临床出诊表
    Where 出诊表名 = 出诊表名_In And 排班方式 = 3 And Nvl(站点, '-') = Nvl(站点_In, '-') And Rownum < 2;
    If n_Count > 0 Then
      v_Err_Msg := '当前院区已存在名为“' || 出诊表名_In || '”的模板！';
      Raise Err_Item;
    End If;
  
    --检查是否有可操作的有效号源
    Select Count(1)
    Into n_Count
    From 临床出诊号源 A, 部门表 D, 人员表 B, 收费项目目录 C
    Where a.科室id = d.Id And a.医生id = b.Id(+) And a.项目id = c.Id And a.排班方式 = Decode(Nvl(模板类型_In, 0), 0, 2, 1) And
          Nvl(a.是否删除, 0) = 0 And (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
          Nvl(d.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
          Nvl(b.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
          Nvl(c.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd')
         --当前人员可操作的号源
          And (Nvl(人员id_In, 0) = 0 Or
          (Nvl(a.是否临床排班, 0) = 1 And Exists (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
         --站点
          And Nvl(Nvl(d.站点, 全院号源归属站点_In), Nvl(站点_In, '-')) = Nvl(站点_In, '-') And Rownum < 2;
  
    If n_Count = 0 Then
      If Nvl(模板类型_In, 0) = 0 Then
        v_Err_Msg := '当前无可按周排班的号源，不能新增模板，请先到“基础设置>临床号源管理”中添加出诊号源！';
      Else
        v_Err_Msg := '当前无可按月排班的号源，不能新增模板，请先到“基础设置>临床号源管理”中添加出诊号源！';
      End If;
      Raise Err_Item;
    End If;
  
    --模板，肯定是新出诊表
    Insert Into 临床出诊表
      (ID, 排班方式, 出诊表名, 应用范围, 科室id, 备注, 发布人, 发布时间, 模板类型, 站点)
    Values
      (n_出诊id, 3, 出诊表名_In, 应用范围_In, 科室id_In, 备注_In, 操作员_In, 操作时间_In, 模板类型_In, 站点_In);
  
    --临床出诊安排
    For c_号源 In (Select 临床出诊安排_Id.Nextval As 安排id, n_出诊id As 出诊id, a.Id As 号源id, a.项目id, a.医生id, a.医生姓名
                 From 临床出诊号源 A, 部门表 D, 人员表 B, 收费项目目录 C
                 Where a.科室id = d.Id And a.医生id = b.Id(+) And a.项目id = c.Id And
                       a.排班方式 = Decode(Nvl(模板类型_In, 0), 0, 2, 1) And Nvl(a.是否删除, 0) = 0 And
                       (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
                       Nvl(d.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                       Nvl(b.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                       Nvl(c.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd')
                      --当前人员可操作的号源
                       And (Nvl(人员id_In, 0) = 0 Or (Nvl(a.是否临床排班, 0) = 1 And Exists
                        (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
                      --站点
                       And Nvl(Nvl(d.站点, 全院号源归属站点_In), Nvl(站点_In, '-')) = Nvl(站点_In, '-')) Loop
    
      If Nvl(模板类型_In, 0) = 2 Then
        --2-按天排班的月排班模板，排班规则缺省为6-特定日期
        Insert Into 临床出诊安排
          (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 排班规则, 操作员姓名, 登记时间)
        Values
          (c_号源.安排id, c_号源.出诊id, c_号源.号源id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, 6, 操作员_In, 操作时间_In);
      Else
        Insert Into 临床出诊安排
          (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 排班规则, 操作员姓名, 登记时间)
        Values
          (c_号源.安排id, c_号源.出诊id, c_号源.号源id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, 1, 操作员_In, 操作时间_In);
      End If;
    End Loop;
    Return;
  End If;

  --============================================================================================================================================
  --2.固定排班
  If Nvl(操作类型_In, 0) = 2 Then
    --进入临床出诊安排模块前检查，如果登录站点无固定出诊表记录，则自动生成临床出诊表记录
    Select Count(1)
    Into n_Count
    From 临床出诊表
    Where 排班方式 = 0 And 出诊表名 = 出诊表名_In And Nvl(站点, '-') = Nvl(站点_In, '-') And Rownum < 2;
    If n_Count = 0 Then
      Update 临床出诊表 Set 站点 = 站点_In Where 排班方式 = 0 And 出诊表名 = 出诊表名_In And Nvl(站点, '-') = '-';
      If Sql%NotFound Then
        Insert Into 临床出诊表
          (ID, 排班方式, 出诊表名, 年份, 站点)
        Values
          (n_出诊id, 0, 出诊表名_In, To_Number(To_Char(Sysdate, 'yyyy')), 站点_In);
      End If;
    End If;
    Return;
  End If;

  --============================================================================================================================================
  --月排班、周排班
  --检查是否有有效号源
  Select Count(1)
  Into n_Count
  From 临床出诊号源 A, 部门表 B, 人员表 C, 收费项目目录 D
  Where a.科室id = b.Id And a.医生id = c.Id(+) And a.项目id = d.Id
       --有效号源
        And Nvl(a.是否删除, 0) = 0 And (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
        Nvl(b.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
        Nvl(c.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
        Nvl(d.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
        (
        --月排班
         Nvl(操作类型_In, 0) = 3 And a.排班方式 = 1
        --周排班
         Or Nvl(操作类型_In, 0) = 4 And
         (
         --当前出诊表所在时间范围内不能有月排班
          a.排班方式 = 2 And Not Exists
          (Select 1
              From 临床出诊安排 P, 临床出诊表 Q
              Where p.出诊id = q.Id And p.号源id = a.Id And
                    Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 1)
         --当前已调整为了月排班,但是本月又用了周排班，则本月剩下的部分将继续按周进行排班
          Or a.排班方式 = 1 And Exists
          (Select 1
              From 临床出诊安排 P, 临床出诊表 Q
              Where p.出诊id = q.Id And p.号源id = a.Id And
                    Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 2)))
       --号源在该出诊表时间范围内无出诊记录
        And Not Exists
   (Select 1
         From 临床出诊记录 O, 临床出诊安排 P, 临床出诊表 Q
         Where o.安排id = p.Id And p.出诊id = q.Id And p.号源id = a.Id And o.出诊日期 Between 开始时间_In And 终止时间_In And
               (q.排班方式 In (1, 2)
               --原来为固定出诊安排
               Or q.排班方式 = 0 And (Nvl(删除安排_In, 0) = 0 Or Nvl(删除安排_In, 0) = 1 And Exists
                (Select 1 From 病人挂号记录 Where 出诊记录id = a.Id))))
       --当前人员可操作的号源
        And (Nvl(人员id_In, 0) = 0 Or
        (Nvl(a.是否临床排班, 0) = 1 And Exists (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
       --站点
        And Nvl(Nvl(b.站点, 全院号源归属站点_In), Nvl(站点_In, '-')) = Nvl(站点_In, '-') And Rownum < 2;
  If n_Count = 0 Then
    If Nvl(操作类型_In, 0) = 3 Then
      v_Err_Msg := '当前无可按月排班的号源，不能新增月出诊表，请先到“基础设置>临床号源管理”中添加出诊号源！';
    Else
      v_Err_Msg := '当前无可按周排班的号源，不能新增周出诊表，请先到“基础设置>临床号源管理”中添加出诊号源！';
    End If;
    Raise Err_Item;
  End If;

  --出诊表存在，则不再新增出诊表，直接向该出诊表添加上次有效号源安排即可
  --涉及到临床排班，当前操作员可能只能操作某一部分号源
  Select Count(1) Into n_Count From 临床出诊表 Where ID = n_出诊id;
  If n_Count = 0 Then
    Insert Into 临床出诊表
      (ID, 排班方式, 出诊表名, 年份, 月份, 周数, 站点)
    Values
      (n_出诊id,
       Case
          When Nvl(操作类型_In, 0) = 3 Then
           1
          Else
           2
        End, 出诊表名_In, 年份_In, 月份_In, 周数_In, 站点_In);
  End If;

  --如果当前出诊表时间范围内无挂号且无预约的出诊记录(固定安排)，则删除这部分出诊记录(在删除出诊表时可恢复)，程序中已询问
  If Nvl(删除安排_In, 0) = 1 Then
    For c_安排 In (Select b.Id As 安排id
                 From 临床出诊安排 B, 临床出诊表 C, 临床出诊号源 D, 部门表 E
                 Where b.出诊id = c.Id And b.号源id = d.Id And d.科室id = e.Id
                      --号源
                       And Nvl(d.是否删除, 0) = 0 And (d.撤档时间 Is Null Or d.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
                       Nvl(d.排班方式, 0) = Decode(Nvl(操作类型_In, 0), 3, 1, 2)
                      --安排有被使用了的出诊记录
                       And c.排班方式 = 0 And b.终止时间 >= 开始时间_In And Not Exists
                  (Select 1
                        From 临床出诊记录 M, 病人挂号记录 N
                        Where m.安排id = b.Id And m.Id = n.出诊记录id And m.出诊日期 >= 开始时间_In)
                      --当前人员可操作的号源
                       And (Nvl(人员id_In, 0) = 0 Or (Nvl(d.是否临床排班, 0) = 1 And Exists
                        (Select 1 From 部门人员 Where 部门id = d.科室id And 人员id = 人员id_In)))
                      --站点
                       And Nvl(Nvl(e.站点, 全院号源归属站点_In), Nvl(站点_In, '-')) = Nvl(站点_In, '-')) Loop
    
      For c_记录 In (Select ID As 记录id From 临床出诊记录 Where 安排id = c_安排.安排id And 出诊日期 >= 开始时间_In) Loop
        l_记录id.Extend();
        l_记录id(l_记录id.Count) := c_记录.记录id;
      End Loop;
    End Loop;
    Zl_临床出诊记录_Batchdelete(l_记录id);
  
  End If;

  --缺省加入上一次有效的出诊安排
  For c_号源 In (Select 临床出诊安排_Id.Nextval As 安排id, n_出诊id As 出诊id, 原安排id, 号源id, 项目id, 医生id, 医生姓名, 原出诊id
               From (Select a.Id As 原安排id, b.Id As 号源id, b.项目id, b.医生id, b.医生姓名, c.Id As 原出诊id,
                             Row_Number() Over(Partition By b.Id Order By a.开始时间 Desc) As 组号
                      From 临床出诊安排 A, 临床出诊号源 B, 临床出诊表 C, 部门表 D, 人员表 E, 收费项目目录 F
                      Where a.号源id = b.Id And a.出诊id = c.Id And b.科室id = d.Id And b.医生id = e.Id(+) And b.项目id = f.Id
                           --有效号源
                            And Nvl(b.是否删除, 0) = 0 And
                            Nvl(b.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                            Nvl(d.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                            Nvl(e.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                            Nvl(f.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                            (
                            --月排班
                             Nvl(操作类型_In, 0) = 3 And b.排班方式 = 1
                            --周排班
                             Or
                             Nvl(操作类型_In, 0) = 4 And
                             (
                             --当前出诊表所在时间范围内不能有月排班
                              b.排班方式 = 2 And Not Exists
                              (Select 1
                               From 临床出诊安排 P, 临床出诊表 Q
                               Where p.出诊id = q.Id And p.号源id = b.Id And
                                     Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 1)
                             --当前已调整为了月排班,但是本月又用了周排班，则本月剩下的部分将继续按周进行排班
                              Or b.排班方式 = 1 And Exists
                              (Select 1
                               From 临床出诊安排 P, 临床出诊表 Q
                               Where p.出诊id = q.Id And p.号源id = b.Id And
                                     Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 2)))
                           --上一次有效出诊安排
                            And c.发布人 Is Not Null And c.排班方式 = Decode(Nvl(操作类型_In, 0), 3, 1, 2)
                           --号源在该出诊表时间范围内无出诊记录
                            And Not Exists (Select 1
                             From 临床出诊记录 P
                             Where p.号源id = b.Id And p.出诊日期 Between 开始时间_In And 终止时间_In)
                           --当前人员可操作的号源
                            And (Nvl(人员id_In, 0) = 0 Or
                            (Nvl(b.是否临床排班, 0) = 1 And Exists
                             (Select 1 From 部门人员 Where 部门id = b.科室id And 人员id = 人员id_In)))
                           --站点
                            And Nvl(Nvl(d.站点, 全院号源归属站点_In), Nvl(站点_In, '-')) = Nvl(站点_In, '-'))
               Where 组号 = 1) Loop
  
    Insert Into 临床出诊安排
      (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 开始时间, 终止时间, 操作员姓名, 登记时间)
    Values
      (c_号源.安排id, c_号源.出诊id, c_号源.号源id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, 开始时间_In, 终止时间_In, 操作员_In, 操作时间_In);
  
    --整周跨月的周出诊表需要找到相邻的出诊表的安排
    n_跨月周安排id := 0;
    If Nvl(操作类型_In, 0) = 4 Then
      n_跨月周出诊id := Zl_Get跨月周出诊id(c_号源.原出诊id);
      If Nvl(n_跨月周出诊id, 0) <> 0 Then
        Begin
          Select a.Id
          Into n_跨月周安排id
          From 临床出诊安排 A, 临床出诊表 B
          Where a.出诊id = b.Id And b.Id = n_跨月周出诊id And a.号源id = c_号源.号源id And b.发布时间 Is Not Null;
        Exception
          When Others Then
            n_跨月周安排id := 0;
        End;
      End If;
    End If;
  
    --复制出诊安排
    For c_记录 In (Select Decode(b.Id, Null, a.Id, b.Id) As ID, c.日期
                 From 临床出诊记录 A, 临床出诊记录 B,
                      (Select Trunc(开始时间_In) + Level - 1 As 日期
                        From Dual
                        Connect By Level <= Trunc(终止时间_In) - Trunc(开始时间_In) + 1) C
                 Where a.Id = b.相关id(+) And (a.安排id = c_号源.原安排id Or a.安排id = n_跨月周安排id) And a.相关id Is Null And
                       Nvl(a.是否临时出诊, 0) = 0
                      --月排班
                       And (Nvl(操作类型_In, 0) = 3 And To_Char(a.出诊日期, 'dd') = To_Char(c.日期, 'dd')
                       --周排班
                       Or Nvl(操作类型_In, 0) = 4 And To_Char(a.出诊日期, 'D') = To_Char(c.日期, 'D'))) Loop
      Zl_临床出诊记录_Copy(c_记录.Id, c_号源.安排id, c_记录.日期, 操作员_In, 操作时间_In);
    End Loop;
  End Loop;

  --加入无上一次有效出诊安排的号源
  For c_号源 In (Select 临床出诊安排_Id.Nextval As 安排id, n_出诊id As 出诊id, a.Id As 号源id, a.项目id, a.医生id, a.医生姓名
               From 临床出诊号源 A, 部门表 D, 人员表 B, 收费项目目录 C
               Where a.科室id = d.Id And a.医生id = b.Id(+) And a.项目id = c.Id
                    --有效号源
                     And Nvl(a.是否删除, 0) = 0 And (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
                     Nvl(d.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     Nvl(b.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     Nvl(c.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     (
                     --月排班
                      Nvl(操作类型_In, 0) = 3 And a.排班方式 = 1
                     --周排班
                      Or Nvl(操作类型_In, 0) = 4 And
                      (
                      --当前出诊表所在时间范围内不能有月排班
                       a.排班方式 = 2 And Not Exists
                       (Select 1
                           From 临床出诊安排 P, 临床出诊表 Q
                           Where p.出诊id = q.Id And p.号源id = a.Id And
                                 Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 1)
                      --当前已调整为了月排班,但是本月又用了周排班，则本月剩下的部分将继续按周进行排班
                       Or a.排班方式 = 1 And Exists
                       (Select 1
                           From 临床出诊安排 P, 临床出诊表 Q
                           Where p.出诊id = q.Id And p.号源id = a.Id And
                                 Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 2)))
                    --号源在该出诊表时间范围内无出诊记录
                     And Not Exists
                (Select 1
                      From 临床出诊记录 P
                      Where p.号源id = a.Id And p.出诊日期 Between 开始时间_In And 终止时间_In)
                    --当前人员可操作的号源
                     And (Nvl(人员id_In, 0) = 0 Or (Nvl(a.是否临床排班, 0) = 1 And Exists
                      (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
                    --站点
                     And Nvl(Nvl(d.站点, 全院号源归属站点_In), Nvl(站点_In, '-')) = Nvl(站点_In, '-')
                    
                     And Not Exists (Select 1 From 临床出诊安排 Where 出诊id = n_出诊id And 号源id = a.Id)) Loop
  
    Insert Into 临床出诊安排
      (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 开始时间, 终止时间, 操作员姓名, 登记时间)
    Values
      (c_号源.安排id, c_号源.出诊id, c_号源.号源id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, 开始时间_In, 终止时间_In, 操作员_In, 操作时间_In);
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊表_Add;
/

--121587:冉俊明,2018-02-06,临床出诊号源安排分站点进行维护
Create Or Replace Procedure Zl_临床出诊表_Addbyrecord
(
  原出诊id_In         临床出诊表.Id%Type,
  新出诊id_In         临床出诊表.Id%Type,
  排班方式_In         临床出诊表.排班方式%Type,
  出诊表名_In         临床出诊表.出诊表名%Type,
  年份_In             临床出诊表.年份%Type,
  月份_In             临床出诊表.月份%Type,
  周数_In             临床出诊表.周数%Type,
  开始时间_In         临床出诊安排.开始时间%Type,
  终止时间_In         临床出诊安排.终止时间%Type,
  操作员姓名_In       临床出诊安排.操作员姓名%Type,
  登记时间_In         临床出诊安排.登记时间%Type,
  站点_In             部门表.站点%Type,
  全院号源归属站点_In 部门表.站点%Type,
  人员id_In           人员表.Id%Type := Null,
  删除安排_In         Number := 0
) As
  ------------------------------------------------------------------------- 
  --功能：根据出诊记录生成新的出诊记录（月安排/周安排） 
  --参数： 
  --        全院号源归属站点_In 不区分站点的号源的归属站点
  --        人员id_In 除固定安排外有效，不为0或null表示临床科室人员在添加 
  --        删除安排_In 固定排班转为月排班/周排班时，在制定月排班/周排班时是否删除新出诊表时间内未使用的出诊记录 
  --说明： 
  ------------------------------------------------------------------------- 
  n_Count Number;

  l_记录id t_Numlist := t_Numlist();
  n_安排id 临床出诊安排.Id%Type;

  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  n_跨月周出诊id 临床出诊表.Id%Type;
Begin
  Select Count(1)
  Into n_Count
  From 临床出诊号源 A, 部门表 B, 人员表 C, 收费项目目录 D
  Where a.科室id = b.Id And a.医生id = c.Id(+) And a.项目id = d.Id
       --有效号源 
        And Nvl(a.是否删除, 0) = 0 And (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
        Nvl(b.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
        Nvl(c.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
        Nvl(d.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
        (
        --月排班 
         Nvl(排班方式_In, 0) = 1 And a.排班方式 = 1
        --周排班 
         Or Nvl(排班方式_In, 0) = 2 And
         (
         --当前出诊表所在时间范围内不能有月排班 
          a.排班方式 = 2 And Not Exists
          (Select 1
              From 临床出诊安排 P, 临床出诊表 Q
              Where p.出诊id = q.Id And p.号源id = a.Id And
                    Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 1)
         --当前已调整为了月排班,但是本月又用了周排班，则本月剩下的部分将继续按周进行排班 
          Or a.排班方式 = 1 And Exists
          (Select 1
              From 临床出诊安排 P, 临床出诊表 Q
              Where p.出诊id = q.Id And p.号源id = a.Id And
                    Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 2)))
       --号源在该出诊表时间范围内无出诊记录 
        And Not Exists
   (Select 1
         From 临床出诊记录 O, 临床出诊安排 P, 临床出诊表 Q
         Where o.安排id = p.Id And p.出诊id = q.Id And p.号源id = a.Id And o.出诊日期 Between 开始时间_In And 终止时间_In And
               (q.排班方式 In (1, 2)
               --原来为固定出诊安排 
               Or q.排班方式 = 0 And (Nvl(删除安排_In, 0) = 0 Or Nvl(删除安排_In, 0) = 1 And Exists
                (Select 1 From 病人挂号记录 Where 出诊记录id = a.Id))))
       --当前人员可操作的号源 
        And (Nvl(人员id_In, 0) = 0 Or
        (Nvl(a.是否临床排班, 0) = 1 And Exists (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
       --站点 
        And Nvl(Nvl(b.站点, 全院号源归属站点_In), Nvl(站点_In, '-')) = Nvl(站点_In, '-') And Rownum < 2;
  If n_Count = 0 Then
    If Nvl(排班方式_In, 0) = 1 Then
      v_Err_Msg := '当前出诊表中已无可按月排班的号源，不能生成新的出诊表！';
    Else
      v_Err_Msg := '当前出诊表中已无可按周排班的号源，不能生成新的出诊表！';
    End If;
    Raise Err_Item;
  End If;

  --检查出诊表是否存在 
  Select Count(1) Into n_Count From 临床出诊表 Where ID = 新出诊id_In;
  If n_Count = 0 Then
    Insert Into 临床出诊表
      (ID, 排班方式, 出诊表名, 年份, 月份, 周数, 站点)
    Values
      (新出诊id_In, 排班方式_In, 出诊表名_In, 年份_In, 月份_In, 周数_In, 站点_In);
  End If;

  --如果当前出诊表时间范围内无挂号且无预约的出诊记录(固定安排)，则删除这部分出诊记录(在删除出诊表时可恢复)， 
  --并修改固定安排的终止时间，程序中已询问 
  If Nvl(删除安排_In, 0) = 1 Then
    For c_安排 In (Select b.Id As 安排id
                 From 临床出诊安排 B, 临床出诊表 C, 临床出诊号源 D, 部门表 E
                 Where b.出诊id = c.Id And b.号源id = d.Id And d.科室id = e.Id
                      --号源 
                       And Nvl(d.是否删除, 0) = 0 And (d.撤档时间 Is Null Or d.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
                       Nvl(d.排班方式, 0) = 排班方式_In
                      --安排有被使用了的出诊记录 
                       And c.排班方式 = 0 And b.终止时间 >= 开始时间_In And Not Exists
                  (Select 1
                        From 临床出诊记录 M, 病人挂号记录 N
                        Where m.安排id = b.Id And m.Id = n.出诊记录id And m.出诊日期 >= 开始时间_In)
                      --当前人员可操作的号源 
                       And (Nvl(人员id_In, 0) = 0 Or (Nvl(d.是否临床排班, 0) = 1 And Exists
                        (Select 1 From 部门人员 Where 部门id = d.科室id And 人员id = 人员id_In)))
                      --站点
                       And Nvl(Nvl(e.站点, 全院号源归属站点_In), Nvl(站点_In, '-')) = Nvl(站点_In, '-')) Loop
    
      For c_记录 In (Select ID As 记录id From 临床出诊记录 Where 安排id = c_安排.安排id And 出诊日期 >= 开始时间_In) Loop
        l_记录id.Extend();
        l_记录id(l_记录id.Count) := c_记录.记录id;
      End Loop;
    End Loop;
  
    Zl_临床出诊记录_Batchdelete(l_记录id);
  
  End If;

  --如果原周出诊表不是整周(不足7天)，则需要查找到另一个出诊表构成整周 
  If Nvl(排班方式_In, 0) = 2 Then
    n_跨月周出诊id := Zl_Get跨月周出诊id(原出诊id_In);
  End If;

  For c_号源 In (Select 新出诊id_In As 出诊id, b.Id As 原安排id, b.号源id, c.项目id, c.医生id, c.医生姓名
               From 临床出诊安排 B, 临床出诊号源 C, 部门表 D, 人员表 E, 收费项目目录 F
               Where b.号源id = c.Id And c.科室id = d.Id And b.医生id = e.Id(+) And c.项目id = f.Id And
                     (b.出诊id = 原出诊id_In Or b.出诊id = n_跨月周出诊id)
                    --有效号源 
                     And Nvl(c.是否删除, 0) = 0 And (c.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd') Or c.撤档时间 Is Null) And
                     Nvl(d.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     Nvl(e.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     Nvl(f.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     (
                     --月排班 
                      Nvl(排班方式_In, 0) = 1 And c.排班方式 = 1
                     -- 周排班 
                      Or Nvl(排班方式_In, 0) = 2 And
                      (
                      --当前出诊表所在时间范围内不能有月排班 
                       c.排班方式 = 2 And Not Exists
                       (Select 1
                           From 临床出诊安排 P, 临床出诊表 Q
                           Where p.出诊id = q.Id And p.号源id = c.Id And
                                 Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 1)
                      --当前已调整为了月排班,但是本月又用了周排班，则本月剩下的部分将继续按周进行排班 
                       Or c.排班方式 = 1 And Exists
                       (Select 1
                           From 临床出诊安排 P, 临床出诊表 Q
                           Where p.出诊id = q.Id And p.号源id = c.Id And
                                 Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 2)))
                    --号源在该出诊表时间范围内无出诊记录 
                     And Not Exists
                (Select 1
                      From 临床出诊记录 P
                      Where p.号源id = c.Id And p.出诊日期 Between 开始时间_In And 终止时间_In)
                    --当前人员可操作的号源 
                     And (Nvl(人员id_In, 0) = 0 Or (Nvl(c.是否临床排班, 0) = 1 And Exists
                      (Select 1 From 部门人员 Where 部门id = c.科室id And 人员id = 人员id_In)))
                    --站点 
                     And Nvl(Nvl(d.站点, 全院号源归属站点_In), Nvl(站点_In, '-')) = Nvl(站点_In, '-')) Loop
  
    Begin
      Select ID Into n_安排id From 临床出诊安排 Where 出诊id = c_号源.出诊id And 号源id = c_号源.号源id;
    Exception
      When Others Then
        n_安排id := Null;
    End;
  
    If Nvl(n_安排id, 0) = 0 Then
      Select 临床出诊安排_Id.Nextval Into n_安排id From Dual;
    
      Insert Into 临床出诊安排
        (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 开始时间, 终止时间, 操作员姓名, 登记时间)
      Values
        (n_安排id, c_号源.出诊id, c_号源.号源id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, 开始时间_In, 终止时间_In, 操作员姓名_In, 登记时间_In);
    End If;
  
    --出诊记录 
    For c_记录 In (Select Decode(b.Id, Null, a.Id, b.Id) As ID, c.日期
                 From 临床出诊记录 A, 临床出诊记录 B,
                      (Select Trunc(开始时间_In) + Level - 1 As 日期
                        From Dual
                        Connect By Level <= Trunc(终止时间_In) - Trunc(开始时间_In) + 1) C
                 Where a.Id = b.相关id(+) And a.安排id = c_号源.原安排id And a.相关id Is Null And Nvl(a.是否临时出诊, 0) = 0
                      --月排班 
                       And (Nvl(排班方式_In, 0) = 1 And To_Char(a.出诊日期, 'dd') = To_Char(c.日期, 'dd')
                       --周排班 
                       Or Nvl(排班方式_In, 0) = 2 And To_Char(a.出诊日期, 'D') = To_Char(c.日期, 'D'))) Loop
      Zl_临床出诊记录_Copy(c_记录.Id, n_安排id, c_记录.日期, 操作员姓名_In, 登记时间_In);
    End Loop;
  End Loop;

  --加入没有的出诊安排的号源 
  For c_号源 In (Select 临床出诊安排_Id.Nextval As 安排id, 新出诊id_In As 出诊id, a.Id As 号源id, a.项目id, a.医生id, a.医生姓名
               From 临床出诊号源 A, 部门表 D, 人员表 E, 收费项目目录 F
               Where a.科室id = d.Id And a.医生id = e.Id(+) And a.项目id = f.Id
                    --有效号源 
                     And Nvl(a.是否删除, 0) = 0 And (a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd') Or a.撤档时间 Is Null) And
                     Nvl(d.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     Nvl(e.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     Nvl(f.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     (
                     --月排班 
                      Nvl(排班方式_In, 0) = 1 And a.排班方式 = 1
                     -- 周排班 
                      Or Nvl(排班方式_In, 0) = 2 And
                      (
                      --当前出诊表所在时间范围内不能有月排班 
                       a.排班方式 = 2 And Not Exists
                       (Select 1
                           From 临床出诊安排 P, 临床出诊表 Q
                           Where p.出诊id = q.Id And p.号源id = a.Id And
                                 Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 1)
                      --当前已调整为了月排班,但是本月又用了周排班，则本月剩下的部分将继续按周进行排班 
                       Or a.排班方式 = 1 And Exists
                       (Select 1
                           From 临床出诊安排 P, 临床出诊表 Q
                           Where p.出诊id = q.Id And p.号源id = a.Id And
                                 Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 2)))
                    --号源在该出诊表时间范围内无出诊记录 
                     And Not Exists
                (Select 1
                      From 临床出诊记录 P
                      Where p.号源id = a.Id And p.出诊日期 Between 开始时间_In And 终止时间_In)
                    --当前人员可操作的号源 
                     And (Nvl(人员id_In, 0) = 0 Or (Nvl(a.是否临床排班, 0) = 1 And Exists
                      (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
                    --站点 
                     And Nvl(Nvl(d.站点, 全院号源归属站点_In), Nvl(站点_In, '-')) = Nvl(站点_In, '-')
                    
                     And Not Exists (Select 1 From 临床出诊安排 Where 出诊id = 新出诊id_In And 号源id = a.Id)) Loop
  
    Insert Into 临床出诊安排
      (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 开始时间, 终止时间, 操作员姓名, 登记时间)
    Values
      (c_号源.安排id, c_号源.出诊id, c_号源.号源id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, 开始时间_In, 终止时间_In, 操作员姓名_In, 登记时间_In);
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊表_Addbyrecord;
/

--121587:冉俊明,2018-02-06,临床出诊号源安排分站点进行维护
Create Or Replace Procedure Zl_临床出诊表_Addbytemplet
(
  模板id_In           临床出诊表.Id%Type,
  人员id_In           人员表.Id%Type,
  出诊id_In           临床出诊表.Id%Type,
  排班方式_In         临床出诊表.排班方式%Type,
  出诊表名_In         临床出诊表.出诊表名%Type,
  年份_In             临床出诊表.年份%Type,
  月份_In             临床出诊表.月份%Type,
  周数_In             临床出诊表.周数%Type,
  开始时间_In         临床出诊安排.开始时间%Type,
  终止时间_In         临床出诊安排.终止时间%Type,
  操作员_In           临床出诊安排.操作员姓名%Type,
  登记时间_In         临床出诊安排.登记时间%Type,
  站点_In             部门表.站点%Type,
  全院号源归属站点_In 部门表.站点%Type,
  删除安排_In         Number := 0
) As
  ------------------------------------------------------------------------- 
  --功能说明：根据模板自动生成临床出诊记录 
  --参数： 
  --        全院号源归属站点_In 不区分站点的号源的归属站点
  --        人员id_In 除固定安排外有效，不为0或null表示临床科室人员在添加 
  --        删除安排_In 固定排班转为月排班/周排班时，在制定月排班/周排班时是否删除新出诊表时间内未使用的出诊记录 
  --说明： 
  ------------------------------------------------------------------------- 
  Err_Item Exception;
  v_Err_Msg Varchar2(200);
  n_Count   Number(18);

  d_轮询日期 Date;
  n_轮询天数 Number;
  v_限制项目 临床出诊限制.限制项目%Type;

  n_是否出诊 Number(2);
  d_开始时间 临床出诊记录.开始时间%Type;

  l_记录id t_Numlist := t_Numlist();

  Procedure Isvisit
  (
    安排id_In       临床出诊安排.Id%Type,
    排班规则_In     临床出诊安排.排班规则%Type,
    出诊日期_In     临床出诊记录.出诊日期%Type,
    轮询开始时间_In 临床出诊安排.开始时间%Type,
    限制项目_In     Out 临床出诊限制.限制项目%Type,
    是否出诊_In     Out Number
  ) As
    --判断是否出诊，并获取出诊项目 
    d_轮询日期 Date;
    n_轮询天数 Number;
  Begin
    是否出诊_In := 1;
    --检查这天是否出诊 
    If 排班规则_In = 1 Then
      --星期排班 
      Select Decode(To_Char(出诊日期_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六',
                     Null)
      Into 限制项目_In
      From Dual;
      Select Count(1) Into n_Count From 临床出诊限制 Where 安排id = 安排id_In And 限制项目 = 限制项目_In;
      If Nvl(n_Count, 0) = 0 Then
        是否出诊_In := 0;
      End If;
    Elsif 排班规则_In = 2 Then
      --单日排班 
      限制项目_In := '单日';
      If Mod(To_Number(To_Char(出诊日期_In, 'dd')), 2) <> 1 Then
        是否出诊_In := 0;
      End If;
    Elsif 排班规则_In = 3 Then
      --双日排班 
      限制项目_In := '双日';
      If Mod(To_Number(To_Char(出诊日期_In, 'dd')), 2) <> 0 Then
        是否出诊_In := 0;
      End If;
    Elsif 排班规则_In = 4 Or 排班规则_In = 5 Then
      --4-月内轮循,5-轮循不限制 
      If 排班规则_In = 4 Then
        d_轮询日期 := To_Date(To_Char(出诊日期_In, 'yyyy-mm') || To_Char(轮询开始时间_In, '-dd'), 'yyyy-mm-dd');
      Else
        d_轮询日期 := 轮询开始时间_In;
      End If;
      Begin
        Select To_Number(Substr(限制项目, 1, Instr(限制项目, '天') - 1))
        Into n_轮询天数
        From 临床出诊限制
        Where 安排id = 安排id_In And Rownum < 2;
      Exception
        When Others Then
          n_轮询天数 := 0;
      End;
      If Nvl(n_轮询天数, 0) > 0 Then
        限制项目_In := n_轮询天数 || '天';
        If Mod(Trunc(出诊日期_In) - Trunc(d_轮询日期), n_轮询天数 + 1) <> 0 Then
          是否出诊_In := 0;
        End If;
      End If;
    Elsif 排班规则_In = 6 Then
      --特定日期 
      限制项目_In := To_Number(To_Char(出诊日期_In, 'dd')) || '日';
      Select Count(1) Into n_Count From 临床出诊限制 Where 安排id = 安排id_In And 限制项目 = 限制项目_In;
      If Nvl(n_Count, 0) = 0 Then
        是否出诊_In := 0;
      End If;
    End If;
  End;
Begin
  Select Count(1)
  Into n_Count
  From 临床出诊号源 A, 部门表 B, 人员表 C, 收费项目目录 D
  Where a.科室id = b.Id And a.医生id = c.Id(+) And a.项目id = d.Id
       --有效号源 
        And Nvl(a.是否删除, 0) = 0 And (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
        Nvl(b.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
        Nvl(c.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
        Nvl(d.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
        (
        --月排班 
         Nvl(排班方式_In, 0) = 1 And a.排班方式 = 1
        --周排班 
         Or Nvl(排班方式_In, 0) = 2 And
         (
         --当前出诊表所在时间范围内不能有月排班 
          a.排班方式 = 2 And Not Exists
          (Select 1
              From 临床出诊安排 P, 临床出诊表 Q
              Where p.出诊id = q.Id And p.号源id = a.Id And
                    Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 1)
         --当前已调整为了月排班,但是本月又用了周排班，则本月剩下的部分将继续按周进行排班 
          Or a.排班方式 = 1 And Exists
          (Select 1
              From 临床出诊安排 P, 临床出诊表 Q
              Where p.出诊id = q.Id And p.号源id = a.Id And
                    Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 2)))
       --号源在该出诊表时间范围内无出诊记录 
        And Not Exists
   (Select 1
         From 临床出诊记录 O, 临床出诊安排 P, 临床出诊表 Q
         Where o.安排id = p.Id And p.出诊id = q.Id And p.号源id = a.Id And o.出诊日期 Between 开始时间_In And 终止时间_In And
               (q.排班方式 In (1, 2)
               --原来为固定出诊安排 
               Or q.排班方式 = 0 And (Nvl(删除安排_In, 0) = 0 Or Nvl(删除安排_In, 0) = 1 And Exists
                (Select 1 From 病人挂号记录 Where 出诊记录id = a.Id))))
       --当前人员可操作的号源 
        And (Nvl(人员id_In, 0) = 0 Or
        (Nvl(a.是否临床排班, 0) = 1 And Exists (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
       --站点 
        And Nvl(Nvl(b.站点, 全院号源归属站点_In), Nvl(站点_In, '-')) = Nvl(站点_In, '-') And Rownum < 2;
  If n_Count = 0 Then
    If Nvl(排班方式_In, 0) = 1 Then
      v_Err_Msg := '当前出诊表中已无可按月排班的号源，不能生成新的出诊表！';
    Else
      v_Err_Msg := '当前出诊表中已无可按周排班的号源，不能生成新的出诊表！';
    End If;
    Raise Err_Item;
  End If;

  --检查出诊表是否存在 
  Select Count(1) Into n_Count From 临床出诊表 Where ID = 出诊id_In;
  If n_Count = 0 Then
    Insert Into 临床出诊表
      (ID, 排班方式, 出诊表名, 年份, 月份, 周数, 站点)
    Values
      (出诊id_In, 排班方式_In, 出诊表名_In, 年份_In, 月份_In, 周数_In, 站点_In);
  End If;

  --如果当前出诊表时间范围内无挂号且无预约的出诊记录(固定安排)，则删除这部分出诊记录(在删除出诊表时可恢复)， 
  --并修改固定安排的终止时间，程序中已询问 
  If Nvl(删除安排_In, 0) = 1 Then
    For c_安排 In (Select b.Id As 安排id
                 From 临床出诊安排 B, 临床出诊表 C, 临床出诊号源 D, 部门表 E
                 Where b.出诊id = c.Id And b.号源id = d.Id And d.科室id = e.Id
                      --号源 
                       And Nvl(d.是否删除, 0) = 0 And (d.撤档时间 Is Null Or d.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
                       Nvl(d.排班方式, 0) = 排班方式_In
                      --安排有被使用了的出诊记录 
                       And c.排班方式 = 0 And b.终止时间 >= 开始时间_In And Not Exists
                  (Select 1
                        From 临床出诊记录 M, 病人挂号记录 N
                        Where m.安排id = b.Id And m.Id = n.出诊记录id And m.出诊日期 >= 开始时间_In)
                      --当前人员可操作的号源 
                       And (Nvl(人员id_In, 0) = 0 Or (Nvl(d.是否临床排班, 0) = 1 And Exists
                        (Select 1 From 部门人员 Where 部门id = d.科室id And 人员id = 人员id_In)))
                      --站点
                       And Nvl(Nvl(e.站点, 全院号源归属站点_In), Nvl(站点_In, '-')) = Nvl(站点_In, '-')) Loop
    
      For c_记录 In (Select ID As 记录id From 临床出诊记录 Where 安排id = c_安排.安排id And 出诊日期 >= 开始时间_In) Loop
        l_记录id.Extend();
        l_记录id(l_记录id.Count) := c_记录.记录id;
      End Loop;
    End Loop;
  
    Zl_临床出诊记录_Batchdelete(l_记录id);
  End If;

  For c_号源 In (Select 临床出诊安排_Id.Nextval As 安排id, 出诊id_In As 出诊id, b.Id As 原安排id, b.号源id, c.科室id, c.项目id, c.医生id, c.医生姓名,
                      b.排班规则, b.是否周六出诊, b.是否周日出诊, b.开始时间, c.号类, Nvl(d.站点, '-') As 站点
               From 临床出诊安排 B, 临床出诊号源 C, 部门表 D, 人员表 E, 收费项目目录 F
               Where b.号源id = c.Id And c.科室id = d.Id And c.医生id = e.Id(+) And c.项目id = f.Id And b.出诊id = 模板id_In
                    --有效号源 
                     And Nvl(c.是否删除, 0) = 0 And (c.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd') Or c.撤档时间 Is Null) And
                     Nvl(d.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     Nvl(e.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     Nvl(f.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     (
                     --月排班 
                      Nvl(排班方式_In, 0) = 1 And c.排班方式 = 1
                     -- 周排班 
                      Or Nvl(排班方式_In, 0) = 2 And
                      (
                      --当前出诊表所在时间范围内不能有月排班 
                       c.排班方式 = 2 And Not Exists
                       (Select 1
                           From 临床出诊安排 P, 临床出诊表 Q
                           Where p.出诊id = q.Id And p.号源id = c.Id And
                                 Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 1)
                      --当前已调整为了月排班,但是本月又用了周排班，则本月剩下的部分将继续按周进行排班 
                       Or c.排班方式 = 1 And Exists
                       (Select 1
                           From 临床出诊安排 P, 临床出诊表 Q
                           Where p.出诊id = q.Id And p.号源id = c.Id And
                                 Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 2)))
                    --号源在该出诊表时间范围内无出诊记录 
                     And Not Exists
                (Select 1
                      From 临床出诊记录 P
                      Where p.号源id = c.Id And p.出诊日期 Between 开始时间_In And 终止时间_In)
                    --当前人员可操作的号源 
                     And (Nvl(人员id_In, 0) = 0 Or (Nvl(c.是否临床排班, 0) = 1 And Exists
                      (Select 1 From 部门人员 Where 部门id = c.科室id And 人员id = 人员id_In)))
                    --站点 
                     And Nvl(Nvl(d.站点, 全院号源归属站点_In), Nvl(站点_In, '-')) = Nvl(站点_In, '-')) Loop
  
    Insert Into 临床出诊安排
      (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 开始时间, 终止时间, 操作员姓名, 登记时间)
    Values
      (c_号源.安排id, c_号源.出诊id, c_号源.号源id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, 开始时间_In, 终止时间_In, 操作员_In, 登记时间_In);
  
    --临床出诊记录 
    For c_日期 In (Select Trunc(开始时间_In) + Level - 1 As 日期,
                        Decode(To_Char(Trunc(开始时间_In) + Level - 1, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                '周四', '6', '周五', '7', '周六', Null) As 星期
                 From Dual
                 Connect By Level <= Trunc(终止时间_In) - Trunc(开始时间_In) + 1) Loop
    
      Isvisit(c_号源.原安排id, c_号源.排班规则, c_日期.日期, c_号源.开始时间, v_限制项目, n_是否出诊);
    
      --是否周六、周日不出诊 
      --排班规则:1-星期排班;2-单日排班;3-双日排班;4-月内轮循;5-轮循不限制;6-特定日期 
      If Instr(',2,3,4,5,', c_号源.排班规则) > 0 And
         (Nvl(c_号源.是否周六出诊, 0) = 0 And c_日期.星期 = '周六' Or Nvl(c_号源.是否周日出诊, 0) = 0 And c_日期.星期 = '周日') Then
        n_是否出诊 := 0;
      End If;
    
      If Nvl(n_是否出诊, 0) = 1 Then
        For c_记录 In (With c_时间段 As
                        (Select 时间段, 开始时间, 终止时间, 号类, 站点, 缺省时间, 提前时间
                        From (Select 时间段, 开始时间, 终止时间, 号类, 站点, 缺省时间, 提前时间,
                                      Row_Number() Over(Partition By 时间段 Order By 时间段, 站点 Asc, 号类 Asc) As 组号
                               From 时间段
                               Where Nvl(站点, c_号源.站点) = c_号源.站点 And Nvl(号类, c_号源.号类) = c_号源.号类)
                        Where 组号 = 1)
                       Select 临床出诊记录_Id.Nextval As 记录id, m.Id As 限制id, m.上班时段,
                              To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') || To_Char(j.开始时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                              To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') || To_Char(j.终止时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') + Case
                                 When j.终止时间 <= j.开始时间 Then
                                  1
                                 Else
                                  0
                               End As 终止时间,
                              To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') || To_Char(Nvl(j.缺省时间, j.开始时间), 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') + Case
                                 When j.缺省时间 < j.开始时间 Then
                                  1
                                 Else
                                  0
                               End As 缺省预约时间,
                              To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') || To_Char(Nvl(j.提前时间, j.开始时间), 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') + Case
                                 When j.开始时间 < j.提前时间 Then
                                  -1
                                 Else
                                  0
                               End As 提前挂号时间, m.限号数, m.限约数, m.是否序号控制, m.是否分时段, m.预约控制, a.项目id, a.医生id, a.医生姓名, m.分诊方式,
                              m.诊室id, m.是否独占
                       From 临床出诊安排 A, 临床出诊限制 M, c_时间段 J
                       Where a.Id = m.安排id And m.上班时段 = j.时间段 And a.Id = c_号源.原安排id And m.限制项目 = v_限制项目) Loop
        
          Insert Into 临床出诊记录
            (ID, 安排id, 号源id, 出诊日期, 上班时段, 开始时间, 终止时间, 缺省预约时间, 提前挂号时间, 限号数, 限约数, 是否序号控制, 是否分时段, 预约控制, 项目id, 科室id, 医生id,
             医生姓名, 分诊方式, 诊室id, 登记人, 登记时间, 是否独占)
          Values
            (c_记录.记录id, c_号源.安排id, c_号源.号源id, c_日期.日期, c_记录.上班时段, c_记录.开始时间, c_记录.终止时间, c_记录.缺省预约时间, c_记录.提前挂号时间,
             c_记录.限号数, c_记录.限约数, c_记录.是否序号控制, c_记录.是否分时段, c_记录.预约控制, c_记录.项目id, c_号源.科室id, c_记录.医生id, c_记录.医生姓名,
             c_记录.分诊方式, c_记录.诊室id, 操作员_In, 登记时间_In, c_记录.是否独占);
        
          Begin
            Select 开始时间 Into d_开始时间 From 临床出诊时段 Where 限制id = c_记录.限制id And 序号 = 1;
          Exception
            When Others Then
              d_开始时间 := Null;
          End;
          --插入临床出诊序号控制 
          If Nvl(c_记录.是否分时段, 0) = 1 And Nvl(c_记录.是否序号控制, 0) = 1 Then
            --分时段且启用序号控制，使用"预约顺序号"记录"是否预约" 
            Insert Into 临床出诊序号控制
              (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 预约顺序号)
              Select c_记录.记录id, 序号,
                     To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') + Case
                        When Trunc(开始时间) > Trunc(d_开始时间) Then
                         1
                        Else
                         0
                      End,
                     To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') || To_Char(终止时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') + Case
                        When Trunc(终止时间) > Trunc(d_开始时间) Then
                         1
                        Else
                         0
                      End, 限制数量, 是否预约, 是否预约
              From 临床出诊时段
              Where 限制id = c_记录.限制id;
          Else
            Insert Into 临床出诊序号控制
              (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约)
              Select c_记录.记录id, 序号,
                     To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') + Case
                       When Trunc(开始时间) > Trunc(d_开始时间) Then
                        1
                       Else
                        0
                     End,
                     To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') || To_Char(终止时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') + Case
                       When Trunc(终止时间) > Trunc(d_开始时间) Then
                        1
                       Else
                        0
                     End, 限制数量, 是否预约
              From 临床出诊时段
              Where 限制id = c_记录.限制id;
          End If;
        
          --插入合作单位挂号控制记录 
          Insert Into 临床出诊挂号控制记录
            (类型, 性质, 名称, 记录id, 序号, 控制方式, 数量)
            Select 类型, 性质, 名称, c_记录.记录id, 序号, 控制方式, 数量
            From 临床出诊挂号控制
            Where 限制id = c_记录.限制id;
        
          --插入临床出诊诊室记录 
          Insert Into 临床出诊诊室记录
            (记录id, 诊室id)
            Select c_记录.记录id, 诊室id From 临床出诊诊室 Where 限制id = c_记录.限制id;
        End Loop;
      End If;
    End Loop;
  End Loop;

  --加入没有的出诊安排的号源 
  For c_号源 In (Select 临床出诊安排_Id.Nextval As 安排id, 出诊id_In As 出诊id, a.Id As 号源id, a.项目id, a.医生id, a.医生姓名
               From 临床出诊号源 A, 部门表 D, 人员表 E, 收费项目目录 F
               Where a.科室id = d.Id And a.医生id = e.Id(+) And a.项目id = f.Id
                    --有效号源 
                     And Nvl(a.是否删除, 0) = 0 And (a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd') Or a.撤档时间 Is Null) And
                     Nvl(d.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     Nvl(e.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     Nvl(f.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     (
                     --月排班 
                      Nvl(排班方式_In, 0) = 1 And a.排班方式 = 1
                     -- 周排班 
                      Or Nvl(排班方式_In, 0) = 2 And
                      (
                      --当前出诊表所在时间范围内不能有月排班 
                       a.排班方式 = 2 And Not Exists
                       (Select 1
                           From 临床出诊安排 P, 临床出诊表 Q
                           Where p.出诊id = q.Id And p.号源id = a.Id And
                                 Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 1)
                      --当前已调整为了月排班,但是本月又用了周排班，则本月剩下的部分将继续按周进行排班 
                       Or a.排班方式 = 1 And Exists
                       (Select 1
                           From 临床出诊安排 P, 临床出诊表 Q
                           Where p.出诊id = q.Id And p.号源id = a.Id And
                                 Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 2)))
                    --号源在该出诊表时间范围内无出诊记录 
                     And Not Exists
                (Select 1
                      From 临床出诊记录 P
                      Where p.号源id = a.Id And p.出诊日期 Between 开始时间_In And 终止时间_In)
                    --当前人员可操作的号源 
                     And (Nvl(人员id_In, 0) = 0 Or (Nvl(a.是否临床排班, 0) = 1 And Exists
                      (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
                    --站点 
                     And Nvl(Nvl(d.站点, 全院号源归属站点_In), Nvl(站点_In, '-')) = Nvl(站点_In, '-')
                    
                     And Not Exists (Select 1 From 临床出诊安排 Where 出诊id = 出诊id_In And 号源id = a.Id)) Loop
  
    Insert Into 临床出诊安排
      (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 开始时间, 终止时间, 操作员姓名, 登记时间)
    Values
      (c_号源.安排id, c_号源.出诊id, c_号源.号源id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, 开始时间_In, 终止时间_In, 操作员_In, 登记时间_In);
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊表_Addbytemplet;
/

--121587:冉俊明,2018-02-06,临床出诊号源安排分站点进行维护
Create Or Replace Function Zl_Get跨月周出诊id(出诊id_In 临床出诊表.Id%Type) Return 临床出诊表.Id%Type Is
  ----------------------------------------
  --如果原周出诊表不是整周(不足7天)，则需要查找到另一个出诊表构成整周
  ----------------------------------------
  n_出诊id 临床出诊表.Id%Type;
  n_年份   临床出诊表.年份%Type;
  n_月份   临床出诊表.月份%Type;
  n_周数   临床出诊表.周数%Type;
  v_站点   临床出诊表.站点%Type;

  d_开始时间 临床出诊安排.开始时间%Type;
  d_结束时间 临床出诊安排.终止时间%Type;

  --根据日期计算当月的周数，以及每一周的时间范围
  Cursor c_Weekrange(Date_In Date) Is
    Select Rownum As 周数, 开始日期, 结束日期
    From (With Month_Range As (Select Trunc(Date_In) As First_Day, Last_Day(Trunc(Date_In)) As Last_Day From Dual)
           Select Decode(To_Char(First_Day, 'day'), '星期日', First_Day, Null) As 开始日期,
                  Decode(To_Char(First_Day, 'day'), '星期日', First_Day, Null) As 结束日期
           From Month_Range
           Union All
           Select Decode(Sign(Trunc(First_Day + 7 * Week, 'day') + 1 - First_Day), 1,
                          Trunc(First_Day + 7 * Week, 'day') + 1, First_Day) As 开始日期,
                  Decode(Sign(Trunc(First_Day + 7 * Week, 'day') + 7 - Last_Day), 1, Last_Day,
                          Trunc(First_Day + 7 * Week, 'day') + 7) As 结束日期
           From Month_Range A, (Select Level - 1 As Week From Dual Connect By Level <= 6) B)
           Where 开始日期 <= 结束日期;


Begin
  Begin
    Select 年份, 月份, 周数, Nvl(站点, '-') Into n_年份, n_月份, n_周数, v_站点 From 临床出诊表 Where ID = 出诊id_In;
  Exception
    When Others Then
      Return 0;
  End;

  If n_年份 Is Null Or n_月份 Is Null Or n_周数 Is Null Then
    Return 0;
  End If;

  For r_Weekrange In c_Weekrange(To_Date(n_年份 || '-' || n_月份 || '-01', 'yyyy-mm-dd')) Loop
    If r_Weekrange.周数 = n_周数 Then
      d_开始时间 := r_Weekrange.开始日期;
      d_结束时间 := r_Weekrange.结束日期;
      Exit;
    End If;
  End Loop;

  If d_开始时间 Is Null Or d_结束时间 Is Null Then
    Return 0;
  End If;
  If Trunc(d_结束时间) - Trunc(d_开始时间) >= 6 Then
    Return 0;
  End If;

  --存在跨月的，查找另一个出诊表的年月周
  n_年份 := Null;
  n_月份 := Null;
  n_周数 := Null;
  If Trunc(d_开始时间 - 1, 'month') <> Trunc(d_开始时间, 'month') Then
    --当前是第一周,获取另一个出诊表的年月
    n_年份 := To_Number(To_Char(d_开始时间 - 1, 'yyyy'));
    n_月份 := To_Number(To_Char(d_开始时间 - 1, 'mm'));
  Elsif Trunc(d_结束时间 + 1, 'month') <> Trunc(d_结束时间, 'month') Then
    --当前是最后一周,获取另一个出诊表的年月
    n_年份 := To_Number(To_Char(d_结束时间 + 1, 'yyyy'));
    n_月份 := To_Number(To_Char(d_结束时间 + 1, 'mm'));
    n_周数 := 1;
  Else
    Return 0;
  End If;

  --获取跨月的另一个出诊表的ID
  Begin
    Select ID
    Into n_出诊id
    From (Select Rownum As 行号, ID
           From 临床出诊表
           Where Nvl(排班方式, 0) = 2 And 年份 = n_年份 And 月份 = n_月份 And (n_周数 Is Null Or 周数 = n_周数) And Nvl(站点, '-') = v_站点
           Order By 周数 Desc)
    Where 行号 < 2;
  Exception
    When Others Then
      Return 0;
  End;

  Return n_出诊id;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Get跨月周出诊id;
/

--120885:刘兴洪,2018-02-05,增加显示序号
Create Or Replace Function Zl_Fun_挂号安排_出诊表_Nextsn
(
  日期_In       In Date,
  记录id_In     In 临床出诊记录.Id%Type,
  操作员姓名_In 人员表.姓名%Type,
  是否加号_In   In Number := 0,
  是否预约_In   In Number := 0,
  是否锁号_In   In Number := 1,
  备注_In       In 挂号序号状态.备注%Type := Null,
  机器名_In     In 挂号序号状态.机器名%Type := Null,
  合作单位_In   In Varchar2 := Null
) Return Varchar2 Is
  --功能:根据指定安排，获取一下个序号(并进行相关的锁号操作)
  --入参:操作类型_In:0-挂号;1-预约
  --     是否加号_IN:0-不进行加号;1-进行加号处理
  --     是否锁号_In:是否进行相关的锁号操作,1-锁号;0-不进行锁号
  --返回:NULL:该挂号安排无需序号控制且不分时段或不启用序号控制且分时段但当前为挂号的
  --     非空:序号|序号开始时间(yyyy-mm-dd hh24:mm:ss)
  --     返回失败时，会抛出错误信息
  n_已挂数       临床出诊记录.已挂数%Type;
  n_已约数       临床出诊记录.已约数%Type;
  n_限号数       临床出诊记录.限号数%Type;
  n_限约数       临床出诊记录.限约数%Type;
  n_序号         临床出诊序号控制.序号%Type;
  n_其中已接收   临床出诊记录.其中已接收%Type;
  n_预约控制     临床出诊记录.预约控制%Type;
  n_是否独占     临床出诊记录.是否独占%Type;
  v_机器名       临床出诊序号控制.操作员姓名%Type;
  v_操作员姓名   人员表.姓名%Type;
  n_序号控制     Number(3);
  n_分时段       Number(3);
  n_启用合作单位 Number(3);
  v_号码         挂号安排.号码%Type;
  n_开始时间     Date;

  n_Count Number(18);
  n_Find  Number(3);
  v_Temp  Varchar2(300);
  Err_Item Exception;

Begin

  v_机器名 := 机器名_In;

  If v_机器名 Is Null Then
    Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
  End If;

  v_操作员姓名 := 操作员姓名_In;
  If v_操作员姓名 Is Null Then
    v_操作员姓名 := Zl_Username;
  End If;

  Select Max(是否序号控制), Max(是否分时段), Max(限号数), Max(限约数), Sum(已挂数), Sum(已约数), Sum(其中已接收), Max(预约控制), Max(是否独占)
  Into n_序号控制, n_分时段, n_限号数, n_限约数, n_已挂数, n_已约数, n_其中已接收, n_预约控制, n_是否独占
  From 临床出诊记录
  Where ID = 记录id_In;

  Select Nvl(Max(1), 0)
  Into n_启用合作单位
  From 临床出诊挂号控制记录
  Where 记录id = 记录id_In And 名称 = 合作单位_In And 类型 = 1 And 性质 = 1 And Rownum < 2;

  n_序号 := Null;
  If Nvl(n_序号控制, 0) = 0 And Nvl(n_分时段, 0) = 0 Then
    --未启用序号控制和未分时段的,直接返回
    Return n_序号;
  End If;

  --1.未启用序号控制处理
  If Nvl(n_序号控制, 0) = 0 Then
    --1.1 不是预约，无需返回序号
    If Nvl(是否预约_In, 0) = 0 Then
      Return n_序号;
    End If;
    --1.2 分时段且是预约的，需要取一下号(暂不处理,待以后扩展
    Return n_序号;
  End If;

  If Nvl(n_限约数, 0) = 0 Then
    n_限约数 := n_限号数;
  End If;

  If Nvl(是否加号_In, 0) = 0 Then
    --不存在加号权限，则不能操出已挂或已约数
    If Nvl(是否预约_In, 0) = 0 Then
      If Nvl(n_限约数, 0) <> 0 And Nvl(n_限约数, 0) <= Nvl(n_已约数, 0) Then
        v_Temp := '号别' || v_号码 || '当前已无余号';
        Raise Err_Item;
      End If;
    Else
      If Nvl(n_限号数, 0) <> 0 And Nvl(n_限号数, 0) <= Nvl(n_已挂数, 0) Then
        v_Temp := '号别' || v_号码 || '当前已无余号';
        Raise Err_Item;
      End If;
    End If;
  End If;

  --2.启用序号控制且分时段的处理
  If Nvl(n_分时段, 0) = 1 Then
    n_Find  := 0;
    n_Count := 0;
    While n_Find = 0 Loop
    
      Select Min(序号), Min(开始时间)
      Into n_序号, n_开始时间
      From 临床出诊序号控制
      Where 记录id = 记录id_In And 开始时间 >= 日期_In And Nvl(是否停诊, 0) <> 1 And
            Nvl(是否预约, 0) = Decode(Nvl(是否预约_In, 0), 0, Nvl(是否预约, 0), 1) And
            (Nvl(挂号状态, 0) = 0 Or
            (Nvl(挂号状态, 0) = 5 And Nvl(操作员姓名, '-') = Nvl(v_操作员姓名, '-') And Nvl(工作站名称, '-') = Nvl(v_机器名, '-')));
    
      If Nvl(n_序号, 0) <> 0 Then
        n_Find := 1;
        If Nvl(是否锁号_In, 0) = 1 Then
          Update 临床出诊序号控制
          Set 挂号状态 = 5, 锁号时间 = Sysdate
          Where 记录id = 记录id_In And Nvl(是否停诊, 0) <> 1 And 序号 = n_序号 And
                (Nvl(挂号状态, 0) = 0 Or
                (Nvl(挂号状态, 0) = 5 And Nvl(操作员姓名, '-') = Nvl(v_操作员姓名, '-') And Nvl(工作站名称, '-') = Nvl(v_机器名, '-')));
          If Sql%NotFound Then
            n_Find := 0;
          End If;
        End If;
        If n_Find = 1 Then
          v_Temp := n_序号 || '|' || To_Char(日期_In, 'yyyy-mm-dd') || ' ' || To_Char(n_开始时间, 'hh24:mi:ss');
          Return v_Temp;
        End If;
      Else
        Select Max(序号) + 1, Max(终止时间) Into n_序号, n_开始时间 From 临床出诊序号控制 Where 记录id = 记录id_In;
        n_Find := 1;
        If Nvl(是否锁号_In, 0) = 1 Then
          Begin
            Insert Into 临床出诊序号控制
              (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 锁号时间, 名称, 类型, 操作员姓名, 工作站名称, 预约顺序号, 备注)
              Select 记录id_In, n_序号,
                     To_Date(To_Char(n_开始时间, 'yyyy-mm-dd') || ' ' || To_Char(日期_In, 'hh24:mi:ss'),
                              'yyyy-mm-dd hh24:mi:ss'),
                     To_Date(To_Char(n_开始时间, 'yyyy-mm-dd') || ' ' || To_Char(日期_In, 'hh24:mi:ss'),
                              'yyyy-mm-dd hh24:mi:ss'), 1, 是否预约_In, 5, Sysdate, 合作单位_In, 1, v_操作员姓名, v_机器名, Null, 备注_In
              From Dual;
          Exception
            When Others Then
              n_Find := 0;
          End;
        End If;
      
        If n_Find = 1 Then
          v_Temp := n_序号 || '|' || To_Char(日期_In, 'yyyy-mm-dd') || ' ' || To_Char(n_开始时间, 'hh24:mi:ss');
          Return v_Temp;
        End If;
      End If;
      n_Count := n_Count + 1;
      If n_Count > 3 Then
        v_Temp := '号别' || v_号码 || '不能有效获取下一个序号';
        Raise Err_Item;
      End If;
    End Loop;
  End If;

  --3.启用序号控制但不分时段的处理
  n_序号 := Null;

  --3.1先判断未使用的序号
  Select Min(序号)
  Into n_序号
  From 临床出诊序号控制
  Where 记录id = 记录id_In And Nvl(挂号状态, 0) = 0 And
        (序号 <> 5 Or (序号 = 5 And Nvl(工作站名称, '-') <> Nvl(v_机器名, '-') And Nvl(操作员姓名, '-') <> Nvl(v_操作员姓名, '-'))) And
        Nvl(是否预约, 0) = Decode(Nvl(是否预约_In, 0), 0, Nvl(是否预约, 0), 1);
  If Nvl(n_序号, 0) <> 0 Then
  
    If Nvl(是否锁号_In, 0) = 1 Then
      Update 临床出诊序号控制
      Set 挂号状态 = 5, 锁号时间 = Sysdate, 操作员姓名 = 操作员姓名_In
      Where 记录id = 记录id_In And Nvl(是否停诊, 0) <> 1 And 序号 = n_序号 And
            (Nvl(挂号状态, 0) = 0 Or
            (Nvl(挂号状态, 0) = 5 And Nvl(操作员姓名, '-') = Nvl(v_操作员姓名, '-') And Nvl(工作站名称, '-') = Nvl(v_机器名, '-')));
      If Sql%NotFound Then
        v_Temp := '号别' || v_号码 || '的序号为' || n_序号 || '不能锁号，可能因为并发造成无法锁定，请重新挂号';
        Raise Err_Item;
      End If;
    
    End If;
    v_Temp := n_序号 || '|' || To_Char(Sysdate, 'yyyy-mm-dd hh24:mi:ss');
    Return v_Temp;
  End If;

  Select Nvl(Max(序号), 0) + 1 Into n_序号 From 临床出诊序号控制 Where 记录id = 记录id_In;
  Insert Into 临床出诊序号控制
    (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 锁号时间, 类型, 名称, 操作员姓名, 备注)
    Select 记录id_In, n_序号, 日期_In, 日期_In, 1, Decode(是否预约_In, 1, 1, 0), 5, Sysdate, Null, Null, 操作员姓名_In, 备注_In
    From Dual;

  v_Temp := n_序号 || '|' || To_Char(Sysdate, 'yyyy-mm-dd hh24:mi:ss');
  Return v_Temp;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Temp || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_Fun_挂号安排_出诊表_Nextsn;
/

--119449:刘硕,2018-01-04,消息集成修改完善
Create Or Replace Procedure Zl1_Auto_Clear_Zlmsg_To As
  --功能：用于清理过期的集成平台消息
  v_Limit Number(5);
Begin
  --删除过期的消息
  Select Max(Nvl(参数值, 缺省值)) Into v_Limit From Zltools.Zloptions Where 参数号 = 26;
  If Nvl(v_Limit, 0) = 0 Then
    v_Limit := 7;
  End If;
  Delete Zlmsg_Todo Where Create_Time < Sysdate - v_Limit;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl1_Auto_Clear_Zlmsg_To;
/
--118495:梁唐彬,2018-02-01,门诊免挂号流程改造
CREATE OR REPLACE Procedure Zl_病人接诊_Cancel
(
  病人id_In 病人信息.病人id%Type,
  No_In     病人挂号记录.No%Type,
  取消科室ID_in 病人挂号记录.执行部门ID%Type:= NULL,
  取消医生_In 病人挂号记录.执行人%Type := NULL
) As
  v_门诊号   病人信息.门诊号%Type;
  v_挂号id   病人挂号记录.Id%Type;
  v_分诊方式 挂号安排.分诊方式%Type;
  n_挂号模式 Number(3);

  n_转诊       Number(1);
  n_申请科室id 病人转诊记录.申请科室id%Type;
  v_申请医生   病人转诊记录.申请医生%Type;
  v_收费单 病人挂号记录.收费单%type;
Begin
  n_挂号模式 := To_Number(Nvl(Substr(zl_GetSysParameter(256), 1, 1), 0));

  Select 门诊号 Into v_门诊号 From 病人信息 Where 病人id = 病人id_In;
  Select ID,收费单 Into v_挂号id,v_收费单 From 病人挂号记录 Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;

  --确定原挂号号别的医生,用于还原
  Begin
    If Nvl(n_挂号模式, 0) = 0 Then
      Select Nvl(a.分诊方式, 0) Into v_分诊方式 From 挂号安排 A, 病人挂号记录 B Where a.号码 = b.号别 And b.No = No_In;
    Else
      Select Nvl(a.分诊方式, 0)
      Into v_分诊方式
      From 临床出诊记录 A, 病人挂号记录 B
      Where a.Id = b.出诊记录id And b.No = No_In;
    End If;
  Exception
    When Others Then
      Null;
  End;

  --判断病人是否是转诊方式(强制续诊/转诊),如果是该回恢到以前的 科室和医生 然后撤消转诊变动记录
  For R In (Select a.挂号id, a.申请科室id, a.申请医生, a.接收科室id, a.接收医生, a.接收时间
            From 病人转诊记录 A
            Where a.No = No_In
            Order By a.接收时间 Desc) Loop
    n_申请科室id := r.申请科室id;
    v_申请医生   := r.申请医生;
    n_转诊       := 1;
    Delete 病人转诊记录 Where 挂号id = r.挂号id And 接收时间 = r.接收时间;
    Exit;
  End Loop;

  --就诊状态
  Update 病人信息 Set 就诊时间 = Null, 就诊状态 = 1 Where 病人id = 病人id_In;

  Update 门诊费用记录
  Set 执行状态 = 0, 执行时间 = Null, 发药窗口 = Decode(v_分诊方式, 0, Null, 发药窗口), 结论 = Null
  Where NO = No_In And 记录性质 = 4 And 记录状态 In (1, 3);
  
  If not 取消科室ID_in is NULL And not 取消医生_In is NULL and Not v_收费单 is NULL Then
    Update 门诊费用记录
      Set 执行状态 = 0, 执行时间 = Null,执行人 = NULL
    Where NO In(select /*+cardinality(A,10)*/ column_value from Table(f_Str2list(v_收费单) ) A) And 记录性质 = 1
          And 执行人 = 取消医生_In And 执行部门ID = 取消科室ID_in;
  End If;

  If n_转诊 = 1 Then
    Update 病人挂号记录
    Set 执行部门id = n_申请科室id, 执行人 = v_申请医生, 执行状态 = 0, 执行时间 = Null, 诊室 = Decode(v_分诊方式, 0, Null, 诊室), 摘要 = Null
    Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;
  Else
    Update 病人挂号记录
    Set 执行状态 = 0, 执行时间 = Null, 诊室 = Decode(v_分诊方式, 0, Null, 诊室), 摘要 = Null
    Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;
  End If;

  --删除过敏，诊断信息
  Zl_病人过敏记录_Delete(病人id_In, v_挂号id);
  Zl_病人诊断记录_Delete(病人id_In, v_挂号id, Null, Null, '1,11');
  Update 排队叫号队列 Set 排队状态 = 0 Where 业务类型 = 0 And 业务id = v_挂号id;

  Delete From 病人医嘱记录 Where 病人id = 病人id_In And 挂号单 = No_In And 医嘱状态 = 1;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人接诊_Cancel;
/

--97338:冉俊明,2018-02-01,如果费别不在有效期范围内，则按全额收费，即按实收金额=应收金额返回
Create Or Replace Function Zl_Actualmoney
(
  费别_In       Varchar2,
  收费细目id_In 费别明细.收费细目id%Type,
  收入项目id_In 费别明细.收入项目id%Type,
  应收金额_In   门诊费用记录.应收金额%Type,
  数量_In       门诊费用记录.数次%Type := 0,
  药房id_In     药品库存.库房id%Type := 0
) Return Varchar2 As
  --功能:根据应收金额按费别进行打折计算
  --参数:
  --     费别_In:病人当前费别，如果是动态费别，值为'费别1,费别2,...'
  --     应收金额_In:应传入加班加价计算之前的真实应收金额
  --     数量_In:售价数量，药品才需传入
  --     药房id_in:药品才需传入
  --返回:费别:实收金额
  --说明：如果费别不在有效期范围内，则按全额收费，即按实收金额=应收金额返回

  n_实收金额 门诊费用记录.实收金额%Type;
  v_费别     门诊费用记录.费别%Type;

  n_Money 门诊费用记录.实收金额%Type;
  n_Rate  Number;

  n_Cnt0     Number;
  n_Cnt1     Number;
  v_Temp     Varchar2(1000);
  n_售价     Number;
  n_成本价   Number;
  n_剩余数量 Number;
Begin
  n_实收金额 := 应收金额_In;
  If Instr(费别_In, ',') = 0 Then
    v_费别 := 费别_In;
  Else
    v_费别 := Substr(费别_In, 1, Instr(费别_In, ',') - 1);
  End If;

  --费别的有效开始和有效结束都只是保存了日期，所以有效结束需要转换为日期+' 23:59:59'
  For Rs In (Select 费别, 实收比率, 实收金额, 计算方法
             From (Select a.费别, Nvl(a.实收比率, 0) As 实收比率, 应收金额_In * Nvl(a.实收比率, 0) / 100 As 实收金额, Nvl(a.计算方法, 0) As 计算方法,
                           b.属性, b.编码
                    From 费别明细 A, 费别 B
                    Where a.费别 = b.名称 And Sysdate Between Nvl(b.有效开始, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                          Nvl(b.有效结束, To_Date('3000-01-01', 'yyyy-mm-dd')) + 1 - 1 / 24 / 60 / 60 And a.收费细目id = 收费细目id_In And
                          Instr(',' || 费别_In || ',', ',' || b.名称 || ',') > 0 And Abs(应收金额_In) Between a.应收段首值 And a.应收段尾值
                    Union All
                    Select a.费别, Nvl(a.实收比率, 0) As 实收比率, 应收金额_In * Nvl(a.实收比率, 0) / 100 As 实收金额, Nvl(a.计算方法, 0) As 计算方法,
                           b.属性, b.编码
                    From 费别明细 A, 费别 B
                    Where a.费别 = b.名称 And Sysdate Between Nvl(b.有效开始, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                          Nvl(b.有效结束, To_Date('3000-01-01', 'yyyy-mm-dd')) + 1 - 1 / 24 / 60 / 60 And a.收入项目id = 收入项目id_In And
                          Instr(',' || 费别_In || ',', ',' || b.名称 || ',') > 0 And Abs(应收金额_In) Between a.应收段首值 And a.应收段尾值 And
                          Not Exists (Select 1 From 费别明细 C Where c.费别 = a.费别 And c.收费细目id = 收费细目id_In))
             Order By 计算方法, 实收比率, 属性, 编码) Loop
  
    If Rs.计算方法 = 0 And Nvl(n_Cnt0, 0) = 0 Then
      n_Cnt0     := 1; --一种计算方法只取最优惠的一行记录
      n_实收金额 := Rs.实收金额;
      v_费别     := Rs.费别;
    Elsif Rs.计算方法 = 1 And 数量_In <> 0 And Nvl(n_Cnt1, 0) = 0 Then
      n_Cnt1 := 1; --一种计算方法只取最优惠的一行记录
      --药品按成本价加收方式
      n_Rate := Rs.实收比率 / 100;
    
      v_Temp := Zl_Fun_Getprice(收费细目id_In, 药房id_In, 数量_In);
      --分解
      n_售价     := To_Number(Substr(v_Temp, 1, Instr(v_Temp, '|') - 1));
      v_Temp     := Substr(v_Temp, Instr(v_Temp, '|') + 1);
      n_成本价   := To_Number(Substr(v_Temp, 1, Instr(v_Temp, '|') - 1));
      v_Temp     := Substr(v_Temp, Instr(v_Temp, '|') + 1);
      n_剩余数量 := To_Number(v_Temp);
    
      If n_剩余数量 = 0 Then
        n_Money := n_成本价 * (1 + n_Rate) * 数量_In;
        If n_Money < n_实收金额 Then
          n_实收金额 := n_Money;
          v_费别     := Rs.费别;
        End If;
      End If;
    End If;
  End Loop;

  Return v_费别 || ':' || n_实收金额;
Exception
  When Others Then
    Return v_费别 || ':' || n_实收金额;
End Zl_Actualmoney;
/

--113841:陈刘,2018-01-31,护理数据报存时,占用大量共享池资源
Create Or Replace Procedure Zl_病人护理打印_Batchretrypage
(
  文件id_In In 病人护理打印.文件id%Type,
  标识_In   In varchar2 := '0;0',
  重算_In   In Number := 0
) As
  n_Startpage Number; --开始页 
  n_Startrow  Number; --开始行 
  n_Endpage   Number; --结束页 
  n_Endrow    Number; --结束行 
  n_Pagerows  Number; --每页有效数据行 
  n_Filerule  Number; --护理文件页码规则 
  n_Count     Number;
  n_标志      Number; --是否要重算该文件的页码 
  n_Firstadd  Number; --检查之前的编码规则是否不包含此文件(一般适用于首次新增记录的文件) 
  n_病人id    病人护理文件.病人id%Type;
  n_主页id    病人护理文件.主页id%Type;
  n_婴儿      病人护理文件.婴儿%Type;
  n_格式id    病人护理文件.格式id%Type;
  n_Fileid    病人护理文件.Id%Type;
  d_开始时间  病人护理文件.开始时间%Type;
  d_创建时间  病人护理文件.创建时间%Type;

  Err_Item Exception;
  v_Err_Msg varchar2(500);

  Cursor c_File1
  (
    病人id_In 病人护理文件.病人id%Type,
    主页id_In 病人护理文件.主页id%Type,
    婴儿_In   病人护理文件.婴儿%Type
  ) Is
    With 病人护理文件_F1 As
     (Select a.Id, a.续打id, 开始时间, 创建时间
      From 病人护理文件 A, 病历文件列表 B
      Where a.格式id = b.Id And b.种类 = 3 And b.保留 <> 1 And b.保留 <> -1 And a.病人id = 病人id_In And a.主页id = 主页id_In And
            Nvl(a.婴儿, 0) = 婴儿_In)
    Select a.Id
    From 病人护理文件_F1 A
    Where Not Exists (Select 1 From 病人护理文件_F1 Where a.Id = 续打id)
    Order By a.开始时间, 创建时间;

  Cursor c_File2(Id_In 病人护理文件.Id%Type) Is
    Select ID From 病人护理文件 Where ID = Id_In;
  t_Id t_Numlist;
Begin
  If Nvl(标识_In, '') = '' Then
    n_标志     := 0;
    n_Firstadd := 0;
  Else
    n_标志     := Substr(标识_In, 1, 1);
    n_Firstadd := Substr(标识_In, 3, 1);
  End If;
  If n_标志 <> 1 Then
    n_Firstadd := 0;
  End If;
  n_Fileid := 文件id_In;

  Select 病人id, 主页id, Nvl(婴儿, 0), 格式id
  Into n_病人id, n_主页id, n_婴儿, n_格式id
  From 病人护理文件
  Where ID = 文件id_In;

  If 重算_In = 1 Then
    n_标志 := 1;
    Open c_File1(n_病人id, n_主页id, n_婴儿);
    Fetch c_File1 Bulk Collect
      Into t_Id;
    Close c_File1;
  Else
    Open c_File2(文件id_In);
    Fetch c_File2 Bulk Collect
      Into t_Id;
    Close c_File2;
  End If;
  If t_Id.Count <= 0 Then
    Return;
  End If;

  --读取护理文件编码规则 
  n_Filerule := Zl_To_Number(zl_GetSysParameter('护理文件页码规则', 1255));

  Select To_Number(内容文本)
  Into n_Pagerows
  From 病历文件结构
  Where 对象属性 = '有效数据行' And 父id = (Select ID From 病历文件结构 Where 文件id = n_格式id And 对象序号 = 1 And 父id Is Null);

  If 重算_In = 0 Then
    --文件页码编号规则可以随便更改，此处需要根据文件页码情况，获知之前的文件页码规则 
    If n_Filerule <> 0 Then
      --文件顺序编号，如果存在1份以上的文件最小开始页码=1(合并文件只检查父文件)，则按照文件页码独立编号处理(之前老数据) 
      With 病人护理文件_F1 As
       (Select a.Id, a.续打id, 开始时间, 创建时间
        From 病人护理文件 A, 病历文件列表 B
        Where a.格式id = b.Id And b.种类 = 3 And b.保留 <> 1 And b.保留 <> -1 And a.病人id = n_病人id And a.主页id = n_主页id And
              Nvl(a.婴儿, 0) = n_婴儿)
      Select Count(1)
      Into n_Count
      From (Select Min(b.开始页号) 开始页号, a.Id
             From 病人护理文件_F1 A, 病人护理打印 B
             Where a.Id = b.文件id And Not Exists (Select 1 From 病人护理文件_F1 Where a.Id = 续打id)
             Group By a.Id)
      Where 开始页号 = 1 And Decode(n_Firstadd, 0, 1, Decode(ID, 文件id_In, 0, 1)) = 1;
      If n_Count > 1 Then
        n_Filerule := 0;
      End If;
    Else
      --文件独立编号，如果存在文件最小开始页码>1(合并文件只检查父文件)，则按照文件页码顺序编号处理(之前老数据) 
      With 病人护理文件_F1 As
       (Select a.Id, a.续打id, 开始时间, 创建时间
        From 病人护理文件 A, 病历文件列表 B
        Where a.格式id = b.Id And b.种类 = 3 And b.保留 <> 1 And b.保留 <> -1 And a.病人id = n_病人id And a.主页id = n_主页id And
              Nvl(a.婴儿, 0) = n_婴儿)
      Select Count(1)
      Into n_Count
      From (Select Min(b.开始页号) 开始页号, a.Id
             From 病人护理文件_F1 A, 病人护理打印 B
             Where a.Id = b.文件id And Not Exists (Select 1 From 病人护理文件_F1 Where a.Id = 续打id)
             Group By a.Id)
      Where 开始页号 > 1 And Decode(n_Firstadd, 0, 1, Decode(ID, 文件id_In, 0, 1)) = 1;
      If n_Count >= 1 Then
        n_Filerule := 1;
      End If;
    End If;
  End If;

  If n_Filerule <> 0 Then
    n_Fileid := t_Id(1);
    --文件顺序编号 
    --提取文件开始时间大于改文件父文件的所有父文件列表以及改文件(因为病人文件列表可能包含：独立文件和合并文件，而合并的文件有可能存在时间交叉的情况) 
    For r_List In (With 病人护理文件_F1 As
                      (Select a.Id, a.续打id, 开始时间, 创建时间
                      From 病人护理文件 A, 病历文件列表 B
                      Where a.格式id = b.Id And b.种类 = 3 And b.保留 <> 1 And b.保留 <> -1 And a.病人id = n_病人id And
                            a.主页id = n_主页id And Nvl(a.婴儿, 0) = n_婴儿)
                     Select ID, 续打id, 开始时间, 创建时间
                     From 病人护理文件_F1
                     Where ID = n_Fileid
                     Union All
                     Select ID, 续打id, 开始时间, 创建时间
                     From (Select ID, 续打id, 开始时间, 创建时间
                             From (Select a.Id, a.续打id, a.开始时间, a.创建时间
                                    From 病人护理文件_F1 A
                                    Where Not Exists (Select 1 From 病人护理文件_F1 Where a.Id = 续打id)) A
                             Where Exists (Select ID, 续打id, 开始时间, 创建时间
                                    From (Select ID, 续打id, 开始时间, 创建时间
                                           From (Select ID, 续打id, 开始时间, 创建时间
                                                  From 病人护理文件_F1
                                                  Start With ID = n_Fileid
                                                  Connect By Prior ID = 续打id
                                                  Order By Level Desc)
                                           Where Rownum < 2)
                                    Where a.Id <> ID And (a.开始时间 > 开始时间 Or (a.开始时间 = 开始时间 And a.创建时间 > 创建时间)))
                             Order By a.开始时间, a.创建时间)) Loop
      n_Endpage  := 0;
      d_开始时间 := r_List.开始时间;
      d_创建时间 := r_List.创建时间;
      --如果要重算该文件，需要注意该文件可能是子文件的情况 
      If n_标志 = 1 And n_Fileid = r_List.Id Then
        Select Nvl(Max(a.结束页号), 0) 结束页号, Nvl(Max(a.结束行号), 0) 结束行号
        Into n_Endpage, n_Endrow
        From 病人护理打印 A,
             (Select 文件id, 结束页号
               From (Select 文件id, Max(a.结束页号) 结束页号
                      From 病人护理打印 A,
                           (Select ID, 序号
                             From (Select ID, Rownum 序号, 续打id
                                    From 病人护理文件
                                    Where 病人id = n_病人id And 主页id = n_主页id And 婴儿 = n_婴儿) F
                             Start With f.续打id = r_List.Id
                             Connect By Prior f.Id = f.续打id) B
                      Where a.文件id = b.Id
                      Group By 文件id, b.序号
                      Order By 序号)
               Where Rownum < 2) B
        Where a.文件id = b.文件id And a.结束页号 = b.结束页号;
        If n_Endpage = 0 Then
          Select 开始时间, 创建时间
          Into d_开始时间, d_创建时间
          From (Select * From 病人护理文件 Start With ID = r_List.Id Connect By Prior ID = 续打id Order By Level Desc)
          Where Rownum < 2;
        Else
          n_Endrow := n_Endrow + 1;
          If n_Endrow > n_Pagerows Then
            n_Endpage := n_Endpage + 1;
            n_Endrow  := 1;
          End If;
          Zl_病人护理打印_Retrypage(r_List.Id, n_Endpage, n_Endrow, 重算_In);
        End If;
      End If;
      If n_Fileid <> r_List.Id Or (n_Endpage = 0 And n_标志 = 1 And n_Fileid = r_List.Id) Then
        --提取父文件的最大开始页码和开始行号 
        With 病人护理文件_F1 As
         (Select a.Id, a.续打id, 开始时间, 创建时间
          From 病人护理文件 A, 病历文件列表 B
          Where a.格式id = b.Id And b.种类 = 3 And b.保留 <> 1 And b.保留 <> -1 And a.病人id = n_病人id And a.主页id = n_主页id And
                Nvl(a.婴儿, 0) = n_婴儿)
        Select Nvl(Max(结束页号), 0)
        Into n_Endpage
        From (Select ID
               From 病人护理文件_F1
               Start With ID In (Select ID
                                 From (Select a.Id
                                        From 病人护理文件_F1 A
                                        Where Not Exists (Select 1 From 病人护理文件_F1 Where a.Id = 续打id))
                                 Where (开始时间 < d_开始时间 Or (开始时间 = d_开始时间 And 创建时间 < d_创建时间)))
               Connect By Prior 续打id = ID) A, 病人护理打印 B
        Where a.Id = b.文件id;
      
        n_Endpage := n_Endpage + 1;
        n_Endrow  := 1;
        Zl_病人护理打印_Retrypage(r_List.Id, n_Endpage, n_Endrow, 重算_In);
      End If;
      For r_File In (Select f.Id
                     From (Select a.Id, a.续打id
                            From 病人护理文件 A, 病历文件列表 B
                            Where a.格式id = b.Id And b.种类 = 3 And b.保留 <> 1 And b.保留 <> -1 And a.病人id = n_病人id And
                                  a.主页id = n_主页id And a.婴儿 = n_婴儿 And a.Id <> r_List.Id) F
                     Start With f.Id = r_List.Id
                     Connect By Prior f.续打id = f.Id) Loop
        --提取子文件开始页号和行号 
        Select Nvl(Max(a.结束页号), n_Endpage) 结束页号, Nvl(Max(a.结束行号), 0) 结束行号
        Into n_Startpage, n_Startrow
        From 病人护理打印 A,
             (Select 文件id, 结束页号
               From (Select 文件id, Max(a.结束页号) 结束页号
                      From 病人护理打印 A,
                           (Select ID, 序号
                             From (Select ID, Rownum 序号, 续打id
                                    From 病人护理文件
                                    Where 病人id = n_病人id And 主页id = n_主页id And 婴儿 = n_婴儿) F
                             Start With f.续打id = r_File.Id
                             Connect By Prior f.Id = f.续打id) B
                      Where a.文件id = b.Id
                      Group By 文件id, b.序号
                      Order By 序号)
               Where Rownum < 2) B
        Where a.文件id = b.文件id And a.结束页号 = b.结束页号;
        n_Startrow := n_Startrow + 1;
        If n_Startrow > n_Pagerows Then
          n_Startpage := n_Startpage + 1;
          n_Startrow  := 1;
        End If;
        Zl_病人护理打印_Retrypage(r_File.Id, n_Startpage, n_Startrow, 重算_In);
      End Loop;
    End Loop;
  Elsif n_Filerule = 0 Then
    For I In 1 .. t_Id.Count Loop
      n_Fileid := t_Id(I);
      --文件独立编号 
      For r_File In (Select f.Id
                     From (Select a.Id, a.续打id
                            From 病人护理文件 A, 病历文件列表 B
                            Where a.格式id = b.Id And b.种类 = 3 And b.保留 <> 1 And b.保留 <> -1 And a.病人id = n_病人id And
                                  a.主页id = n_主页id And a.婴儿 = n_婴儿) F
                     Start With f.Id = n_Fileid
                     Connect By Prior f.续打id = f.Id) Loop
        --提取子文件开始页号和行号 
        If n_Fileid <> r_File.Id Or (n_标志 = 1 And n_Fileid = r_File.Id) Then
          Select Nvl(Max(a.结束页号), 1) 结束页号, Nvl(Max(a.结束行号), 0) 结束行号
          Into n_Startpage, n_Startrow
          From 病人护理打印 A,
               (Select 文件id, 结束页号
                 From (Select 文件id, Max(a.结束页号) 结束页号
                        From 病人护理打印 A,
                             (Select ID, 序号
                               From (Select ID, Rownum 序号, 续打id
                                      From 病人护理文件
                                      Where 病人id = n_病人id And 主页id = n_主页id And 婴儿 = n_婴儿) F
                               Start With f.续打id = r_File.Id
                               Connect By Prior f.Id = f.续打id) B
                        Where a.文件id = b.Id
                        Group By 文件id, b.序号
                        Order By 序号)
                 Where Rownum < 2) B
          Where a.文件id = b.文件id And a.结束页号 = b.结束页号;
          n_Startrow := n_Startrow + 1;
          If n_Startrow > n_Pagerows Then
            n_Startpage := n_Startpage + 1;
            n_Startrow  := 1;
          End If;
          Zl_病人护理打印_Retrypage(r_File.Id, n_Startpage, n_Startrow, 重算_In);
        End If;
      End Loop;
    End Loop;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人护理打印_Batchretrypage;
/

--121143:胡俊勇,2018-01-29,移动护理和HIS相关的接口
Create Or Replace Procedure Zl_Third_Getadviceinfo
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --功能：获取医嘱基本信息/查询
  --参数：
  --入参数 Xml_In
  --<IN>
  --     <YZID>1156789</YZID>--主医嘱ID
  --</IN>

  --出参 Xml_Out
  --<OUTPUT>
  --    <YZ>
  --       <PATIID></PATIID>     --病人医嘱记录.病人ID
  --       <PAGEID></PAGEID>     --病人医嘱记录.主页ID
  --       <BABY></BABY>   --病人医嘱记录.婴儿
  --       <YZID>1145878</YZID>   --病人医嘱记录.医嘱ID， 主医嘱ID
  --       <RELATEDID></RELATEDID>   --病人医嘱记录.相关ID
  --       <ZXKSID></ZXKSID>   --病人医嘱记录.执行科室id
  --       <YZQX>0</YZQX>      --病人医嘱记录.医嘱期效
  --       <STATE>8</STATE>    --病人医嘱记录.医嘱状态
  --       <JJBZ>0</JJBZ>      --病人医嘱记录.紧急标志
  --       <KZYS>代翔</KZYS>   --病人医嘱记录.开嘱医生
  --       <KZSJ>2015-03-25 16:37:00</KZSJ>   --病人医嘱记录.开嘱时间
  --       <ZLXMID></ZLXMID>   --诊疗项目目录.ID
  --       <ZLLB>E</ZLLB>      --诊疗项目目录.类别
  --       <ZLXMMC></ZLXMMC>   --诊疗项目目录.名称 ，检查，检验(检验行 C)，手术(主手术行 F)，输血(K)，中药配方(服法行 E)，其它(本身)
  --       <ZLXMCZLX></<ZLXMCZLX>   --诊疗项目目录.操作类型
  --       <ZLXMZXFL></ZLXMZXFL>   --诊疗项目目录.执行分类
  --       <BZ>21</BZ> 诊疗项目目录.操作类型||诊疗项目目录.执行分类
  --       <YF>静脉滴注</YF>   --病人医嘱记录.医嘱内容 ，主医嘱行中的  医嘱内容
  --       <PC>BID</PC>   --诊疗频率项目.英文名称
  --       <ZXSJFY>18-20</ZXSJFY>   --病人医嘱记录.执行时间方案
  --       <PLCS>2</PLCS>   --病人医嘱记录.频率次数
  --       <PLJG>1</PLJG>   --病人医嘱记录.频率间隔
  --       <PSJG></PSJG>   --病人医嘱记录.皮试结果
  --       <YSZT></YSZT>   --病人医嘱记录.医生嘱托
  --       <KSZXSJ>2015-03-25 16:35:00</KSZXSJ>  --病人医嘱记录.开始执行时间
  --       <ZXZZSJ></ZXZZSJ>   --病人医嘱记录.执行终止时间
  --       <TZYS></TZYS>   --病人医嘱记录.停嘱医生
  --       <TZSJ></TZSJ>   --病人医嘱记录.停嘱时间
  --       <DW>次</DW>   --诊疗项目目录.计算单位
  --       <DL></DL>   --病人医嘱记录.单次用量
  --       <ZL></ZL>   --病人医嘱记录.总给予量 

  --       <ITEMLIST> 仅输血项目和西/成药医嘱项目明细相关信息；输血的血袋信息，药品行明细信息
  --        <ITEM>
  --         <YSZT></YSZT>   --病人医嘱记录.医生嘱托
  --         <YZID>1145878</YZID>   --病人医嘱记录.医嘱ID
  --         <RELATEDID></RELATEDID>   --病人医嘱记录.相关ID
  --         <ZLXMID></ZLXMID>   --诊疗项目目录.ID
  --         <SFXMID></SFXMID>   --收费项目目录.id
  --         <SFXMMC></SFXMMC>   --收费项目目录.名称
  --         <SFXMGG></SFXMGG>   --收费项目目录.规格
  --         <BM></BM>           --收费项目别名.名称（商品名）
  --         <ZL></ZL>           --病人医嘱记录.总给予量
  --         <DL>10</DL>         --病人医嘱记录.单次用量
  --         <DW>ml</DW>         --收费项目目录.计算单位
  --         <ZLDW>ml</ZLDW>   --诊疗项目目录.计算单位
  --         <ZXXZ></ZXXZ>   --病人医嘱记录.执行性质
  --         <ZXKS></ZXKS>   --诊疗项目目录.执行科室
  --         <XDBH></XDBH>   --血液收发记录.血袋编号
  --         <SXXH></SXXH>   --血液收发记录.序号
  --        </ITEM>
  --        <ITEM/>...
  --       </ITEMLIST>
  --      </YZ>
  --</OUTPUT>

  n_医嘱id  病人医嘱记录.Id%Type;
  x_医嘱    Xmltype;
  x_Item    Xmltype;
  v_Xtmp    Clob; --临时XML
  n_Cnt     Number;
  x_T1      Xmltype;
  x_T2      Xmltype;
  x_Templet Xmltype;

  v_英文名     诊疗频率项目.英文名称%Type;
  v_试管名称   采血管类型.名称%Type;
  v_添加剂     采血管类型.添加剂%Type;
  v_试管规格   采血管类型.规格%Type;
  n_试管颜色   采血管类型.颜色%Type;
  v_收费商品名 收费项目别名.名称%Type;
Begin

  Select Extractvalue(Value(A), 'IN/YZID') Into n_医嘱id From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  n_Cnt := 0;
  For R In (Select a.病人id, a.主页id, a.婴儿, a.Id As 医嘱id, a.相关id, a.执行科室id, a.医嘱期效, a.医嘱状态, a.紧急标志, a.开嘱医生, a.开嘱时间, a.诊疗项目id,
                   a.诊疗类别, a.医嘱内容, a.执行时间方案, a.执行频次, a.频率次数, a.频率间隔, a.皮试结果, a.医生嘱托, a.开始执行时间, a.执行终止时间, a.停嘱医生, a.停嘱时间,
                   b.名称 As 项目名称, b.操作类型, b.执行分类, b.计算单位 As 诊疗单位, a.单次用量, a.总给予量, a.标本部位, a.检查方法, a.收费细目id, c.名称 As 收费名称,
                   c.规格, Null As 收费商品名, c.计算单位 As 收费单位, a.执行性质, b.执行科室, b.试管编码
            From 病人医嘱记录 A, 诊疗项目目录 B, 收费项目目录 C
            Where a.诊疗项目id = b.Id And a.收费细目id = c.Id(+) And (a.Id = n_医嘱id Or a.相关id = n_医嘱id)
            Order By a.序号) Loop
    n_Cnt := n_Cnt + 1;
    If n_Cnt = 1 Then
      Select Max(a.英文名称) Into v_英文名 From 诊疗频率项目 A Where a.名称 = r.执行频次;
    End If;
    v_试管名称 := Null;
    v_添加剂   := Null;
    v_试管规格 := Null;
    n_试管颜色 := Null;
    If r.试管编码 Is Not Null Then
      Select Max(a.名称), Max(a.添加剂), Max(a.规格), Max(a.颜色)
      Into v_试管名称, v_添加剂, v_试管规格, n_试管颜色
      From 采血管类型 A
      Where a.编码 = r.试管编码;
    End If;
    --主医行
    If r.相关id Is Null Then
      v_Xtmp := '<YZ>';
      v_Xtmp := v_Xtmp || '<PATIID>' || r.病人id || '</PATIID>'; --病人医嘱记录.病人ID
      v_Xtmp := v_Xtmp || '<PAGEID>' || r.主页id || '</PAGEID>'; --病人医嘱记录.主页ID
      v_Xtmp := v_Xtmp || '<BABY>' || r.婴儿 || '</BABY>'; --病人医嘱记录.婴儿
      v_Xtmp := v_Xtmp || '<YZID>' || r.医嘱id || '</YZID>'; --病人医嘱记录.医嘱ID
      v_Xtmp := v_Xtmp || '<RELATEDID>' || r.相关id || '</RELATEDID>'; --病人医嘱记录.相关ID
      v_Xtmp := v_Xtmp || '<ZXKSID>' || r.执行科室id || '</ZXKSID>'; --病人医嘱记录.执行科室id
      v_Xtmp := v_Xtmp || '<YZQX>' || r.医嘱期效 || '</YZQX>'; --病人医嘱记录.医嘱期效
      v_Xtmp := v_Xtmp || '<STATE>' || r.医嘱状态 || '</STATE>'; --病人医嘱记录.医嘱状态
      v_Xtmp := v_Xtmp || '<JJBZ>' || r.紧急标志 || '</JJBZ>'; --病人医嘱记录.紧急标志
      v_Xtmp := v_Xtmp || '<KZYS>' || r.开嘱医生 || '</KZYS>'; --病人医嘱记录.开嘱医生
      v_Xtmp := v_Xtmp || '<KZSJ>' || To_Char(r.开嘱时间, 'yyyy-mm-dd hh24:mi:ss') || '</KZSJ>'; --病人医嘱记录.开嘱时间
      v_Xtmp := v_Xtmp || '<BZ>' || r.操作类型 || r.执行分类 || '</BZ>'; -- 诊疗项目目录.操作类型||诊疗项目目录.执行分类
      v_Xtmp := v_Xtmp || '<ZLXMID>' || r.诊疗项目id || '</ZLXMID>'; --诊疗项目目录.ID
      v_Xtmp := v_Xtmp || '<ZLLB>' || r.诊疗类别 || '</ZLLB>'; --诊疗项目目录.类别
      v_Xtmp := v_Xtmp || '<YZNR>' || r.医嘱内容 || '</YZNR>'; --医嘱内容
      v_Xtmp := v_Xtmp || '<YF>' || r.项目名称 || '</YF>'; --病人医嘱记录.医嘱内容
      v_Xtmp := v_Xtmp || '<PC>' || v_英文名 || '</PC>'; --诊疗频率项目.英文名称
      v_Xtmp := v_Xtmp || '<ZXSJFY>' || r.执行时间方案 || '</ZXSJFY>'; --病人医嘱记录.执行时间方案
      v_Xtmp := v_Xtmp || '<PLCS>' || r.频率次数 || '</PLCS>'; --病人医嘱记录.频率次数
      v_Xtmp := v_Xtmp || '<PLJG>' || r.频率间隔 || '</PLJG>'; --病人医嘱记录.频率间隔
      v_Xtmp := v_Xtmp || '<PSJG>' || r.皮试结果 || '</PSJG>'; --病人医嘱记录.皮试结果
      v_Xtmp := v_Xtmp || '<YSZT>' || r.医生嘱托 || '</YSZT>'; --病人医嘱记录.医生嘱托
      v_Xtmp := v_Xtmp || '<KSZXSJ>' || To_Char(r.开始执行时间, 'yyyy-mm-dd hh24:mi:ss') || '</KSZXSJ>'; --病人医嘱记录.开始执行时间
      v_Xtmp := v_Xtmp || '<ZXZZSJ>' || To_Char(r.执行终止时间, 'yyyy-mm-dd hh24:mi:ss') || '</ZXZZSJ>'; --病人医嘱记录.执行终止时间
      v_Xtmp := v_Xtmp || '<TZYS>' || r.停嘱医生 || '</TZYS>'; --病人医嘱记录.停嘱医生
      v_Xtmp := v_Xtmp || '<TZSJ>' || To_Char(r.停嘱时间, 'yyyy-mm-dd hh24:mi:ss') || '</TZSJ>'; --病人医嘱记录.停嘱时间
      v_Xtmp := v_Xtmp || '<ZLXMMC>' || r.项目名称 || '</ZLXMMC>'; --诊疗项目目录.名称
      v_Xtmp := v_Xtmp || '<ZLXMCZLX>' || r.操作类型 || '</ZLXMCZLX>'; --诊疗项目目录.操作类型
      v_Xtmp := v_Xtmp || '<ZLXMZXFL>' || r.执行分类 || '</ZLXMZXFL>'; --诊疗项目目录.执行分类
      --       (仅采血管返回)
      v_Xtmp := v_Xtmp || '<CXGMC>' || v_试管名称 || '</CXGMC>'; --采血管名称
      v_Xtmp := v_Xtmp || '<CXGTJJ>' || v_添加剂 || '</CXGTJJ>'; --采血管添加剂
      v_Xtmp := v_Xtmp || '<CXGGG>' || v_试管规格 || '</CXGGG>'; --采血管规格
      v_Xtmp := v_Xtmp || '<CXGYS>' || n_试管颜色 || '</CXGYS>'; --采血管颜色
      v_Xtmp := v_Xtmp || '<DW>' || r.诊疗单位 || '</DW>'; --诊疗项目目录.计算单位
      v_Xtmp := v_Xtmp || '<DL>' || r.单次用量 || '</DL>'; --病人医嘱记录.单次用量
      v_Xtmp := v_Xtmp || '<ZL>' || r.总给予量 || '</ZL>'; --病人医嘱记录.总给予量
      v_Xtmp := v_Xtmp || '</YZ>';
      x_医嘱 := Xmltype(v_Xtmp);
    End If;
  
    --输血和西药成药医嘱
    If r.诊疗类别 = 'K' And r.医嘱状态 = 8 Then
      --输血医嘱，只有发医嘱后才可能有血袋信息
      x_Item := Xmltype('<ITEMLIST></ITEMLIST>');
      -- for loop      --可能有多个ITEM
      v_Xtmp := '<ITEM>';
      v_Xtmp := v_Xtmp || '<YSZT>' || r.医生嘱托 || '</YSZT>'; --病人医嘱记录.医生嘱托
      v_Xtmp := v_Xtmp || '<YZID>' || r.医嘱id || '</YZID>'; --病人医嘱记录.医嘱ID
      v_Xtmp := v_Xtmp || '<RELATEDID>' || r.相关id || '</RELATEDID>'; --病人医嘱记录.相关ID
      v_Xtmp := v_Xtmp || '<ZLXMID>' || r.诊疗项目id || '</ZLXMID>'; --诊疗项目目录.ID
      v_Xtmp := v_Xtmp || '<ZL>' || r.总给予量 || '</ZL>'; --病人医嘱记录.总给予量
      v_Xtmp := v_Xtmp || '<DL>' || r.单次用量 || '</DL>'; --病人医嘱记录.单次用量
      v_Xtmp := v_Xtmp || '<ZLDW>' || r.诊疗单位 || '</ZLDW>'; --诊疗项目目录.计算单位
      v_Xtmp := v_Xtmp || '<ZXXZ>' || r.执行性质 || '</ZXXZ>'; --病人医嘱记录.执行性质
      v_Xtmp := v_Xtmp || '<ZXKS>' || r.执行科室 || '</ZXKS>'; --诊疗项目目录.执行科室
    
      ----其它信息来至血库系统，建议另外的接口
    
      --      Begin
      --        x_T1 := Xmltype('<IN><YZID>' || r.医嘱id || '</YZID></IN>');
      --        Execute Immediate 'Begin Zl_Thrid_get血库发血相关信息(:1,:2); End;'
      --          Using In x_T1, Out x_T2;
      --      Exception
      --        When Others Then
      --          Null;
      --      End;
      --      v_Xtmp := v_Xtmp || '<SFXMID></SFXMID>'; --收费项目目录.id
      --      v_Xtmp := v_Xtmp || '<SFXMMC></SFXMMC>'; --收费项目目录.名称
      --      v_Xtmp := v_Xtmp || '<SFXMGG></SFXMGG>'; --收费项目目录.规格
      --      v_Xtmp := v_Xtmp || '<BM></BM>'; --收费项目别名.名称（商品名）
      --      v_Xtmp := v_Xtmp || '<DW>ml</DW>'; --收费项目目录.计算单位
      --      v_Xtmp := v_Xtmp || '<XDBH></XDBH>'; --血液收发记录.血袋编号
      --      v_Xtmp := v_Xtmp || '<SXXH></SXXH>'; --血液收发记录.序号
    
      v_Xtmp := v_Xtmp || '</ITEM>';
      Select Appendchildxml(x_Item, '/ITEMLIST', Xmltype(v_Xtmp)) Into x_Item From Dual;
      --end loop;
    Elsif r.诊疗类别 = '5' Or r.诊疗类别 = '6' Then
      --西/成 药
      If x_Item Is Null Then
        --只初始化一次
        x_Item := Xmltype('<ITEMLIST></ITEMLIST>');
      End If;
      v_收费商品名 := Null;
      If r.收费细目id Is Not Null Then
        For Z In (Select a.名称, a.性质
                  From 收费项目别名 A
                  Where a.收费细目id = r.收费细目id
                  Group By a.名称, a.性质
                  Order By a.性质) Loop
          v_收费商品名 := z.名称;
          If z.性质 = 3 Then
            v_收费商品名 := z.名称;
            Exit;
          End If;
        End Loop;
      End If;
    
      v_Xtmp := '<ITEM>';
      v_Xtmp := v_Xtmp || '<YSZT>' || r.医生嘱托 || '</YSZT>'; --病人医嘱记录.医生嘱托
      v_Xtmp := v_Xtmp || '<YZID>' || r.医嘱id || '</YZID>'; --病人医嘱记录.医嘱ID
      v_Xtmp := v_Xtmp || '<RELATEDID>' || r.相关id || '</RELATEDID>'; --病人医嘱记录.相关ID
      v_Xtmp := v_Xtmp || '<ZLXMID>' || r.诊疗项目id || '</ZLXMID>'; --诊疗项目目录.ID
      v_Xtmp := v_Xtmp || '<SFXMID>' || r.收费细目id || '</SFXMID>'; --收费项目目录.id
      v_Xtmp := v_Xtmp || '<SFXMMC>' || r.收费名称 || '</SFXMMC>'; --收费项目目录.名称
      v_Xtmp := v_Xtmp || '<SFXMGG>' || r.规格 || '</SFXMGG>'; --收费项目目录.规格
      v_Xtmp := v_Xtmp || '<BM>' || v_收费商品名 || '</BM>'; --收费项目别名.名称（商品名）
      v_Xtmp := v_Xtmp || '<ZL>' || r.总给予量 || '</ZL>'; --病人医嘱记录.总给予量
      v_Xtmp := v_Xtmp || '<DL>' || r.单次用量 || '</DL>'; --病人医嘱记录.单次用量
      v_Xtmp := v_Xtmp || '<DW>' || r.收费单位 || '</DW>'; --收费项目目录.计算单位
      v_Xtmp := v_Xtmp || '<ZLDW>' || r.诊疗单位 || '</ZLDW>'; --诊疗项目目录.计算单位
      v_Xtmp := v_Xtmp || '<ZXXZ>' || r.执行性质 || '</ZXXZ>'; --病人医嘱记录.执行性质
      v_Xtmp := v_Xtmp || '<ZXKS>' || r.执行科室 || '</ZXKS>'; --诊疗项目目录.执行科室
      v_Xtmp := v_Xtmp || '<XDBH></XDBH>'; --血液收发记录.血袋编号
      v_Xtmp := v_Xtmp || '<SXXH></SXXH>'; --血液收发记录.序号
      v_Xtmp := v_Xtmp || '</ITEM>';
      Select Appendchildxml(x_Item, '/ITEMLIST', Xmltype(v_Xtmp)) Into x_Item From Dual;
    End If;
  End Loop;
  If x_Item Is Not Null Then
    Select Appendchildxml(x_医嘱, '/YZ', x_Item) Into x_医嘱 From Dual;
  End If;
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');
  Select Appendchildxml(x_Templet, '/OUTPUT', x_医嘱) Into x_Templet From Dual;
  Xml_Out := x_Templet;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getadviceinfo;
/

--121143:胡俊勇,2018-01-29,移动护理和HIS相关的接口
CREATE OR REPLACE Procedure Zl_Third_Getadvicesend
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --功能：获取医嘱发送信息/查询
  --用于监听表【病人医嘱发送】的变化后，通过医嘱ID查询医嘱发送详情
  --入参：Xml_In
  --<IN>
  --     <YZID>1162695</YZID>
  --</IN>
  --出参：Xml_Out
  --<OUTPUT>
  --     <YZSENDLIST>
  --           <ITEM>
  --                <YZID></YZID>   --病人医嘱发送.医嘱ID
  --                <FSH></FSH>   --病人医嘱发送.发送号
  --                <YBTM></YBTM>   --病人医嘱发送.样本条码
  --                <ZXZT></ZXZT>   --病人医嘱发送.执行状态
  --               <YQSJ></YQSJ>   --医嘱执行时间.要求时间
  --           </ITEM>
  --     </YZSENDLIST>
  --</OUTPUT>

  n_医嘱id  病人医嘱记录.Id%Type;
  v_Xtmp    Clob; --临时XML
  x_Templet Xmltype;
Begin
  x_Templet := Xmltype('<OUTPUT><YZSENDLIST></YZSENDLIST></OUTPUT>');
  Select Extractvalue(Value(A), 'IN/YZID') Into n_医嘱id From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  For R In (Select a.医嘱id, a.发送号, a.样本条码, a.执行状态, a.首次时间
            From 病人医嘱发送 A, 病人医嘱记录 B
            Where a.医嘱id = b.Id And (b.Id = n_医嘱id Or b.相关id = n_医嘱id)) Loop
    v_Xtmp := '<ITEM>';
    v_Xtmp := v_Xtmp || '<YZID>' || r.医嘱id || '</YZID>';
    v_Xtmp := v_Xtmp || '<FSH>' || r.发送号 || '</FSH>';
    v_Xtmp := v_Xtmp || '<YBTM>' || r.样本条码 || '</YBTM>';
    v_Xtmp := v_Xtmp || '<ZXZT>' || r.执行状态 || '</ZXZT>';
    v_Xtmp := v_Xtmp || '<YQSJ>' || To_Char(r.首次时间, 'yyyy-mm-dd hh24:mi:ss') || '</YQSJ>';
    v_Xtmp := v_Xtmp || '</ITEM>';
    Select Appendchildxml(x_Templet, '/OUTPUT/YZSENDLIST', Xmltype(v_Xtmp)) Into x_Templet From Dual;
  End Loop;
  Xml_Out := x_Templet;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getadvicesend;
/

--121143:胡俊勇,2018-01-29,移动护理和HIS相关的接口
CREATE OR REPLACE Procedure Zl_Third_Getadvicestop
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --功能：获取医嘱停止信息/查询
  --病人医嘱记录.状态=8时，表示停止
  --入参：Xml_In
  --<IN>
  --     <YZID>1162695</YZID>
  --</IN>
  --出参：Xml_Out
  --<OUTPUT>
  --     <YZ>
  --         <YZID></YZID>   --病人医嘱记录.医嘱ID
  --         <YZZT></YZZT>   --病人医嘱记录.医嘱状态
  --         <TZYS></TZYS>   --病人医嘱记录.停嘱医生
  --         <TZSJ></TZSJ>   --病人医嘱记录.停嘱时间
  --     </YZ>
  --</OUTPUT>

  n_医嘱id 病人医嘱记录.Id%Type;
  v_Xtmp   Varchar(5000); --临时XML
Begin

  Select Extractvalue(Value(A), 'IN/YZID') Into n_医嘱id From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  For R In (Select a.Id As 医嘱id, a.医嘱状态, a.停嘱医生, a.停嘱时间 From 病人医嘱记录 A Where a.Id = n_医嘱id) Loop
    v_Xtmp := '<OUTPUT>';
    v_Xtmp := v_Xtmp || '<YZID>' || r.医嘱id || '</YZID>';
    v_Xtmp := v_Xtmp || '<YZZT>' || r.医嘱状态 || '</YZZT>';
    v_Xtmp := v_Xtmp || '<TZYS>' || r.停嘱医生 || '</TZYS>';
    v_Xtmp := v_Xtmp || '<TZSJ>' || To_Char(r.停嘱时间, 'yyyy-mm-dd hh24:mi:ss') || '</TZSJ>';
    v_Xtmp := v_Xtmp || '</OUTPUT>';
  End Loop;

  If v_Xtmp Is Not Null Then
    Xml_Out := Xmltype(v_Xtmp);
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getadvicestop;
/

--121143:胡俊勇,2018-01-29,移动护理和HIS相关的接口
CREATE OR REPLACE Procedure Zl_Third_Adviceoperation
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --功能：医嘱执行登记/取消执行登记 /写入
  --1、用于每次医嘱执行时的执行登记，”来源“用于区分是否移动端执行
  --2、对已执行的医嘱取消执行操作
  --入参：xml_in
  --<IN>
  -- <TYPE>1</TYPE>   --操作类型：1、执行登记；0、取消执行登记
  -- <YZID>1162695</YZID>   --医嘱id
  -- <FSH>202704</FSH>   --发送号
  -- <YQSJ>2017-12-05 10:00:00</YQSJ>   --要求时间
  -- <CZY></CZY>   --操作员
  -- <CZSJ>2017-12-05 16:26:54</CZSJ>   --操作时间

  --以下节点取消执行时传空
  -- <ZXSM>PDA执行</ZXSM>   --执行摘要
  -- <ZXCS></ZXCS>   --执行次数
  -- <SYTD>左手背</SYTD>
  -- <LY></LY>   --来源
  --</IN>

  --出参：Xml_Out
  --<OUTPUT>
  --   <RESULT>true</RESULT>
  --</OUTPUT>

  --失败：
  --<OUTPUT>
  --   <RESULT>false</RESULT>
  --   <ERROR>
  --     <MSG>详细错误提示</MSG>
  --   </ERROR>
  --</OUTPUT>

  n_Type     Number;
  n_医嘱id   病人医嘱记录.Id%Type;
  n_发送号   病人医嘱发送.发送号%Type;
  d_要求时间 病人医嘱执行.要求时间%Type;
  d_执行时间 病人医嘱执行.执行时间%Type;
  v_执行摘要 病人医嘱执行.执行摘要%Type;
  n_本次数次 病人医嘱执行.本次数次%Type;
  v_输液通道 病人医嘱执行.输液通道%Type;
  n_记录来源 病人医嘱执行.记录来源%Type;
  v_执行人   病人医嘱执行.执行人%Type;
Begin
  Select Extractvalue(Value(A), 'IN/TYPE'), Extractvalue(Value(A), 'IN/YZID') As 医嘱id,
         Extractvalue(Value(A), 'IN/FSH') As 发送号,
         To_Date(Extractvalue(Value(A), 'IN/YQSJ'), 'yyyy-mm-dd hh24:mi:ss') As 要求时间,
         Extractvalue(Value(A), 'IN/CZY') As 执行人,
         To_Date(Extractvalue(Value(A), 'IN/CZSJ'), 'yyyy-mm-dd hh24:mi:ss') As 执行时间,
         Extractvalue(Value(A), 'IN/ZXSM') As 执行摘要, Extractvalue(Value(A), 'IN/ZXCS') As 本次数次,
         Extractvalue(Value(A), 'IN/SYTD') As 输液通道, Extractvalue(Value(A), 'IN/LY') As 记录来源
  Into n_Type, n_医嘱id, n_发送号, d_要求时间, v_执行人, d_执行时间, v_执行摘要, n_本次数次, v_输液通道, n_记录来源
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  If n_Type = 1 Then
    Zl_病人医嘱执行_Insert(n_医嘱id, n_发送号, d_要求时间, n_本次数次, v_执行摘要, v_执行人, d_执行时间, 0, 0, 1, Null, Null, Null, 0, 0, 0, v_输液通道,
                     n_记录来源);
  Else
    Zl_病人医嘱执行_Delete(n_医嘱id, n_发送号, d_执行时间, 0, 0, 0);
  End If;
  Xml_Out := Xmltype('<OUTPUT><RESULT>true</RESULT></OUTPUT>');
Exception
  When Others Then
    Xml_Out := Xmltype('<OUTPUT><RESULT>false</RESULT><ERROR><MSG>' || SQLCode || '***' || SQLErrM ||
                       '</MSG></ERROR></OUTPUT>');
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Adviceoperation;
/

--121143:胡俊勇,2018-01-29,移动护理和HIS相关的接口
CREATE OR REPLACE Procedure Zl_Third_Skintestoperation
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --功能：登记皮试结果/写入
  --入参：Xml_In
  --<IN>
  --   <YZID>1162695</YZID>   --医嘱id
  --   <PSBQ>(+)</PSBQ>   --皮试标签
  --   <PSJG>1</PSJG>     --皮试结果
  --   <CZY></CZY>        --操作员
  --   <CZSJ>2017-12-05 16:26:54</CZSJ>   --操作时间
  --</IN>
  --出参：Xml_Out
  --<OUTPUT>
  --   <RESULT>true</RESULT>
  --</OUTPUT>

  --失败：
  --<OUTPUT>
  --   <RESULT>false</RESULT>
  --   <ERROR>
  --     <MSG>详细错误提示</MSG>
  --   </ERROR>
  --</OUTPUT>

  n_医嘱id   病人医嘱记录.Id%Type;
  v_皮试标签 病人医嘱记录.皮试结果%Type;
  n_皮试结果 病人过敏记录.结果%Type;
  v_操作员   人员表.姓名%Type;
  d_操作时间 Date;
Begin
  Select Extractvalue(Value(A), 'IN/YZID') As 医嘱id, Extractvalue(Value(A), 'IN/PSBQ') As 皮试标签,
         Extractvalue(Value(A), 'IN/PSJG') As 皮试结果, Extractvalue(Value(A), 'IN/CZY') As 操作员,
         To_Date(Extractvalue(Value(A), 'IN/CZSJ'), 'yyyy-mm-dd hh24:mi:ss') As 操作时间
  Into n_医嘱id, v_皮试标签, n_皮试结果, v_操作员, d_操作时间
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  Zl_病人医嘱记录_皮试(n_医嘱id, v_皮试标签, n_皮试结果, v_操作员, d_操作时间, Null);
  Xml_Out := Xmltype('<OUTPUT><RESULT>true</RESULT></OUTPUT>');
Exception
  When Others Then
    Xml_Out := Xmltype('<OUTPUT><RESULT>false</RESULT><ERROR><MSG>' || SQLCode || '***' || SQLErrM ||
                       '</MSG></ERROR></OUTPUT>');
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Skintestoperation;
/

--121143:胡俊勇,2018-01-29,移动护理和HIS相关的接口
CREATE OR REPLACE Procedure Zl_Third_Advicestopaffirm
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --功能：医嘱确认停止/写入
  --入参数：Xml_In
  --<IN>
  --   <YZID>1162695</YZID>   --医嘱id 主医嘱ID
  --   <CZY></CZY>   --操作员
  --   <CZSJ>2017-12-05 16:26:54</CZSJ>   --操作时间
  --</IN>
  --出参：Xml_Out
  --<OUTPUT>
  --   <RESULT>true</RESULT>
  --</OUTPUT>

  --失败：
  --<OUTPUT>
  --   <RESULT>false</RESULT>
  --   <ERROR>
  --     <MSG>详细错误提示</MSG>
  --   </ERROR>
  --</OUTPUT>

  n_医嘱id   病人医嘱记录.Id%Type;
  v_操作员   人员表.姓名%Type;
  d_操作时间 Date;
Begin
  Select Extractvalue(Value(A), 'IN/YZID'), Extractvalue(Value(A), 'IN/CZY'),
         To_Date(Extractvalue(Value(A), 'IN/CZSJ'), 'yyyy-mm-dd hh24:mi:ss')
  Into n_医嘱id, v_操作员, d_操作时间
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  Zl_病人医嘱记录_确认停止(n_医嘱id, d_操作时间, v_操作员, 0);
  Xml_Out := Xmltype('<OUTPUT><RESULT>true</RESULT></OUTPUT>');
Exception
  When Others Then
    Xml_Out := Xmltype('<OUTPUT><RESULT>false</RESULT><ERROR><MSG>' || SQLCode || '***' || SQLErrM ||
                       '</MSG></ERROR></OUTPUT>');
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Advicestopaffirm;
/

--121143:胡俊勇,2018-01-29,移动护理和HIS相关的接口
CREATE OR REPLACE Procedure Zl_Third_Getpathway
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --功能：病人临床路径表单,阶段信息/查询
  --入参：Xml_In
  --<IN>
  --     <PATIID>29</PATIID>     --病人ID
  --     <PAGEID>1</PAGEID>     --主页ID
  --</IN>

  --出参：Xml_Out
  --<OUTPUT>
  --  <LJID>43</LJID>     --病人临床路径.路径ID
  --  <YSLJID></YSLJID>   --病人路径评估.原路径id
  --  <BBH></BBH>         --病人临床路径.版本号
  --  <YSBBH></YSBBH>     --病人路径评估.原路径版本
  --  <LJMC>急性单纯性阑尾炎临床路径</LJMC>   --临床路径目录.名称
  --  <ZXZT>执行中</ZXZT>   --病人临床路径.状态
  --  <BZZYR>6</BZZYR>   --临床路径版本.标准住院日
  --  <DQTS>5</DQTS>   --病人临床路径.当前天数

  --  <PHASELIST>
  --   <PHASES>
  --    <PHASE>
  --      <JDID>1</JDID>   --病人路径执行.阶段ID
  --      <JD>住院第1天 (住院日,手术日)</JD>   --临床路径阶段.名称
  --      <DQJD>0</DQJD>   --病人临床路径.当前阶段ID
  --      <DAYS>
  --        <DAY>
  --          <TS>1</TS>                     --病人路径执行.天数
  --          <RQ>2011-09-16 00:00:00</RQ>   --病人路径执行.日期
  --          <PGJG>正常</PGJG>              --病人路径评估.评估结果
  --          <PGSM>嘀咕</PGSM>              --病人路径评估.评估说明
  --          <PGR>代翔</PGR>                --病人路径评估.评估人
  --          <PGSJ>2011-09-16 10:51:40</PGSJ>   --病人路径评估.评估时间
  --          <BYYY></BYYY>                      --病人路径评估.变异原因（变异常见原因.名称）
  --          <ITEMLIST>
  --             <ITEM>
  --                <FL>主要诊疗工作</FL>   --临床路径分类.名称
  --                <TBID />   --病人路径执行.图标ID
  --                <ZXID>3366</ZXID>   --病人路径执行.ID
  --                <XMID>1</XMID>   --病人路径执行.项目ID    
  --                <XMXH>1</XMXH>   --临床路径项目.项目序号（XMID为空时，取病人路径执行 .项目序号）   
  --                <XMNR>询问病史体格检查</XMNR>   --临床路径项目.项目内容（XMID为空时，取病人路径执行 .项目内容）
  --                <ZXFS>1</ZXFS>   --临床路径项目.执行方式
  --                <ZXJG>已经执行</ZXJG>   --病人路径执行.执行结果
  --                <TJYY />   --病人路径执行.添加原因
  --                <ZXBYYY />  变异原因
  --              </ITEM>
  --           </ITEMLIST>
  --        </DAY>
  --        <DAY/>...
  --     </DAYS>
  --    </PHASE>
  --    <PHASE/>...
  --  </PHASES>
  -- </PHASELIST>
  --</OUTPUT>

  n_病人id     病人医嘱记录.病人id%Type;
  n_主页id     病人医嘱记录.主页id%Type;
  n_路径id     临床路径阶段.路径id%Type;
  n_版本号     临床路径阶段.版本号%Type;
  n_当前阶段id 病人临床路径.当前阶段id%Type;
  n_路径记录id 病人临床路径.Id%Type;
  v_Xtmp       Clob; --临时XML
  x_Templet    Xmltype;
  x_Phase      Xmltype;
  x_Day        Xmltype;
  x_Item       Xmltype;
  v_评估信息   Varchar2(4000);
  v_Err_Msg    Varchar2(255);
  Err_Item Exception;

  Cursor c_Main Is
    Select a.Id, a.路径id, c.原路径id, a.版本号, c.原路径版本, e.名称 As 路径名称,
           Decode(a.状态, 0, '不符合导入条件', 1, '执行中', 2, '正常结束', 3, '变异结束', Null) As 状态, f.标准住院日, a.当前天数, a.当前阶段id
    From 病人临床路径 A, 病人路径评估 C, 临床路径目录 E, 临床路径版本 F
    Where a.病人id = n_病人id And a.主页id = n_主页id And a.路径id = e.Id And a.当前阶段id = c.阶段id(+) And a.Id = c.路径记录id(+) And
          a.当前天数 = c.天数(+) And a.路径id = f.路径id And a.版本号 = f.版本号;

  Cursor c_定义阶段 Is
    Select a.Id As 阶段id, a.名称 As 阶段名称
    From 临床路径阶段 A
    Where a.路径id = n_路径id And a.版本号 = n_版本号 And a.父id Is Null
    Order By a.序号;

  Type t_定义阶段 Is Table Of c_定义阶段%RowType;
  r_定义阶段 t_定义阶段;

  --已生成的阶段
  Cursor c_Phase Is
    Select a.阶段id, a.天数, To_Char(a.日期, 'yyyy-mm-dd') 日期, To_Char(a.日期, 'day') 星期, b.名称 As 阶段名, b.序号, b.说明, b.父id,
           Decode(g.路径id, b.路径id, 1, 0) As 排序
    From (Select a.阶段id, a.天数, a.日期, a.路径记录id
           From 病人路径执行 A
           Where a.路径记录id = n_路径记录id
           Group By a.阶段id, a.天数, a.日期, a.路径记录id) A, 临床路径阶段 B, 临床路径阶段 C, 病人临床路径 G
    Where a.阶段id = b.Id And b.父id = c.Id(+) And g.Id = a.路径记录id
    Order By 日期, 排序, Nvl(c.序号, b.序号);

  Type t_Phase Is Table Of c_Phase%RowType;
  r_Phase t_Phase;

  --明细项目
  Cursor c_Item Is
    Select a.Id, Nvl(b.图标id, a.图标id) As 图标id, a.分类, To_Char(a.日期, 'yyyy-mm-dd') As 日期, a.天数, a.阶段id,
           Nvl(a.项目序号, b.项目序号) As 项目序号, Nvl(b.项目内容, a.项目内容) 项目内容, a.项目id, Decode(a.执行人, Null, 0, 1) 执行状态,
           Nvl(b.执行方式, 1) 执行方式, a.添加原因, Nvl(a.生成时间性质, 0) As 生成时间性质, c.名称 As 变异原因, Nvl(b.项目结果, a.项目结果) As 项目结果, a.执行结果,
           d.路径id, d.分支id, Nvl(Nvl(a.生成者, b.生成者), 1) As 生成者, d.名称 As 阶段名
    From 病人路径执行 A, 临床路径项目 B, 变异常见原因 C, 临床路径阶段 D
    Where a.路径记录id = n_路径记录id And a.项目id = b.Id(+) And a.变异原因 = c.编码(+) And a.阶段id + 0 = d.Id
    Order By a.日期, 分类, 项目序号;

  Type t_Item Is Table Of c_Item%RowType;
  r_Item t_Item;

  --阶段评估
  Cursor c_Eval Is
    Select a.阶段id, a.天数, Decode(a.评估结果, 1, '正常', -1, '变异', Null) As 评估结果, a.评估说明, a.评估人, a.评估时间, c.名称 As 变异原因, a.变异审核人,
           Nvl(a.时间进度, 0) 时间进度, a.跳转审核人, a.原路径id
    From 病人路径评估 A, 病人路径变异 B, 变异常见原因 C
    Where a.路径记录id = b.路径记录id(+) And a.阶段id = b.阶段id(+) And a.日期 = b.日期(+) And a.路径记录id = n_路径记录id And b.变异原因 = c.编码(+);
  Type t_Eval Is Table Of c_Eval%RowType;
  r_Eval t_Eval;
Begin
  Select Extractvalue(Value(A), 'IN/PATIID') As 病人id, Extractvalue(Value(A), 'IN/PAGEID') As 主页id
  Into n_病人id, n_主页id
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  For R In c_Main Loop
    v_Xtmp := '<LJID>' || r.路径id || '</LJID>'; --病人临床路径.路径ID
    v_Xtmp := v_Xtmp || '<YSLJID>' || r.原路径id || '</YSLJID>'; --病人路径评估.原路径id
    v_Xtmp := v_Xtmp || '<BBH>' || r.版本号 || '</BBH>'; --病人临床路径.版本号
    v_Xtmp := v_Xtmp || '<YSBBH>' || r.原路径版本 || '</YSBBH>'; --病人路径评估.原路径版本
    v_Xtmp := v_Xtmp || '<LJMC>' || r.路径名称 || '</LJMC>'; --临床路径目录.名称
    v_Xtmp := v_Xtmp || '<ZXZT>' || r.状态 || '</ZXZT>'; --病人临床路径.状态
    v_Xtmp := v_Xtmp || '<BZZYR>' || r.标准住院日 || '</BZZYR>'; --临床路径版本.标准住院日
    v_Xtmp := v_Xtmp || '<DQTS>' || r.当前天数 || '</DQTS>'; --病人临床路径.当前天数;
  
    n_路径id     := r.路径id;
    n_版本号     := r.版本号;
    n_当前阶段id := r.当前阶段id;
    n_路径记录id := r.Id;
  End Loop;
  x_Templet := Xmltype('<OUTPUT>' || v_Xtmp || '<PHASELIST></PHASELIST></OUTPUT>');

  If n_路径记录id Is Null Then
    v_Err_Msg := '未找到路径信息！';
    Raise Err_Item;
  End If;

  Open c_定义阶段;
  Fetch c_定义阶段 Bulk Collect
    Into r_定义阶段;
  Close c_定义阶段;

  Open c_Phase;
  Fetch c_Phase Bulk Collect
    Into r_Phase;
  Close c_Phase;

  Open c_Item;
  Fetch c_Item Bulk Collect
    Into r_Item;
  Close c_Item;

  Open c_Eval;
  Fetch c_Eval Bulk Collect
    Into r_Eval;
  Close c_Eval;

  For I In 1 .. r_定义阶段.Count Loop
    v_Xtmp  := '<PHASE><JDID>' || r_定义阶段(I).阶段id || '</JDID><JD>' || r_定义阶段(I).阶段名称 || '</JD><DQJD>' || n_当前阶段id ||
               '</DQJD><DAYS></DAYS></PHASE>';
    x_Phase := Xmltype(v_Xtmp);
  
    For J In 1 .. r_Phase.Count Loop
      If r_定义阶段(I).阶段id = r_Phase(J).阶段id Then
        --day 
        v_Xtmp     := '<DAY>';
        v_Xtmp     := v_Xtmp || '<TS>' || r_Phase(J).天数 || '</TS>'; --病人路径执行.天数
        v_Xtmp     := v_Xtmp || '<RQ>' || r_Phase(J).日期 || ' 00:00:00</RQ>'; --病人路径执行.日期      
        v_评估信息 := '<PGJG></PGJG><PGSM></PGSM><PGR></PGR><PGSJ></PGSJ><BYYY></BYYY>';
        For K In 1 .. r_Eval.Count Loop
          If r_Phase(J).阶段id = r_Eval(K).阶段id And r_Phase(J).天数 = r_Eval(K).天数 Then
            v_评估信息 := '<PGJG>' || r_Eval(K).评估结果 || '</PGJG>'; --病人路径评估.评估结果
            v_评估信息 := v_评估信息 || '<PGSM>' || r_Eval(K).评估说明 || '</PGSM>'; --病人路径评估.评估说明
            v_评估信息 := v_评估信息 || '<PGR>' || r_Eval(K).评估人 || '</PGR>'; --病人路径评估.评估人
            v_评估信息 := v_评估信息 || '<PGSJ>' || To_Char(r_Eval(K).评估时间, 'yyyy-mm-dd hh24:mi:ss') || '</PGSJ>'; --病人路径评估.评估时间
            v_评估信息 := v_评估信息 || '<BYYY>' || r_Eval(K).变异原因 || '</BYYY>'; --病人路径评估.变异原因（变异常见原因.名称）         
          End If;
        End Loop;
        v_Xtmp := v_Xtmp || v_评估信息;
        v_Xtmp := v_Xtmp || '</DAY>';
        x_Day  := Xmltype(v_Xtmp);
      
        --item
        x_Item := Xmltype('<ITEMLIST></ITEMLIST>');
        For K In 1 .. r_Item.Count Loop
          If r_Phase(J).阶段id = r_Item(K).阶段id And r_Phase(J).天数 = r_Item(K).天数 Then
            v_Xtmp := '<ITEM>';
            v_Xtmp := v_Xtmp || '<FL>' || r_Item(K).分类 || '</FL>'; --临床路径分类.名称
            v_Xtmp := v_Xtmp || '<TBID>' || r_Item(K).图标id || '</TBID>'; --病人路径执行.图标ID
            v_Xtmp := v_Xtmp || '<ZXID>' || r_Item(K).Id || '</ZXID>'; --病人路径执行.ID
            v_Xtmp := v_Xtmp || '<XMID>' || r_Item(K).项目id || '</XMID>'; --病人路径执行.项目ID    
            v_Xtmp := v_Xtmp || '<XMXH>' || r_Item(K).项目序号 || '</XMXH>'; --临床路径项目.项目序号（XMID为空时，取病人路径执行 .项目序号）   
            v_Xtmp := v_Xtmp || '<XMNR>' || r_Item(K).项目内容 || '</XMNR>'; --临床路径项目.项目内容（XMID为空时，取病人路径执行 .项目内容）
            v_Xtmp := v_Xtmp || '<ZXFS>' || r_Item(K).执行方式 || '</ZXFS>'; --临床路径项目.执行方式
            v_Xtmp := v_Xtmp || '<ZXJG>' || r_Item(K).执行结果 || '</ZXJG>'; --病人路径执行.执行结果
            v_Xtmp := v_Xtmp || '<TJYY>' || r_Item(K).添加原因 || '</TJYY>'; --病人路径执行.添加原因
            v_Xtmp := v_Xtmp || '<ZXBYYY>' || r_Item(K).变异原因 || '</ZXBYYY>'; --变异原因
            v_Xtmp := v_Xtmp || '</ITEM>';
            Select Appendchildxml(x_Item, '/ITEMLIST', Xmltype(v_Xtmp)) Into x_Item From Dual;
          End If;
        End Loop;
        Select Appendchildxml(x_Day, '/DAY', x_Item) Into x_Day From Dual;
        Select Appendchildxml(x_Phase, '/PHASE/DAYS', x_Day) Into x_Phase From Dual;
      End If;
    End Loop;
    Select Appendchildxml(x_Templet, '/OUTPUT/PHASELIST', x_Phase) Into x_Templet From Dual;
  End Loop;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getpathway;
/

--121143:胡俊勇,2018-01-29,移动护理和HIS相关的接口
CREATE OR REPLACE Procedure Zl_Third_Getpathwaydetail
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --功能：临床路径中某个项目具体的执行明细及医嘱信息/查询
  --入参：Xml_In
  --<IN>
  --     <ZXID>29</ZXID>     --病人路径执行.ID
  --</IN>
  --出参：Xml_Out
  --<OUTPUT>
  -- <LJEXEC>
  --  <ZXQK>
  --   <ZXZ />   --病人路径执行.执行者
  --   <ZXR>代翔</ZXR>   --病人路径执行.执行人
  --   <ZXSJ>2011-10-24 17:28:53</ZXSJ>   --病人路径执行.执行时间
  --   <ZXJG>已经执行</ZXJG>   --病人路径执行.执行结果
  --   <ZXSM />   --病人路径执行..执行说明
  --  </ZXQK>
  --  <YZLIST>
  --   <YZXX>
  --    <YZQX>0</YZQX>   --病人医嘱记录.医嘱期效
  --    <YZNR>注射用克林霉素 0.6g/支 苏州第壹制药有限公司</YZNR>   --病人医嘱记录.医嘱内容
  --    <DL>每次1.2g</DL>   -病人医嘱记录.单次用量
  --    <ZL />   --病人医嘱记录.总给予量
  --    <GYTJ>静脉滴注（门诊）</GYTJ>   --诊疗项目目录.名称
  --    <ZXPL>每天二次</ZXPL>   --病人医嘱记录.执行频次
  --    <ZXSJ>10-16</ZXSJ>   -病人医嘱记录.执行时间方案
  --    <YSZT />   --病人医嘱记录..医生嘱托
  --   </YZXX>
  --  </YZLIST>
  -- </LJEXEC>
  --</OUTPUT>

  n_执行id  病人路径执行.Id%Type;
  v_Xtmp    Clob; --临时XML
  x_Templet Xmltype;
Begin
  Select Extractvalue(Value(A), 'IN/ZXID') Into n_执行id From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  For R In (Select a.执行者, a.执行人, a.执行时间, a.执行结果, a.执行说明 From 病人路径执行 A Where a.Id = n_执行id) Loop
    v_Xtmp := '<ZXQK>';
    v_Xtmp := v_Xtmp || '<ZXZ>' || r.执行者 || '</ZXZ>';
    v_Xtmp := v_Xtmp || '<ZXR>' || r.执行人 || '</ZXR>';
    v_Xtmp := v_Xtmp || '<ZXSJ>' || To_Char(r.执行时间, 'yyyy-mm-dd hh24:mi:ss') || '</ZXSJ>';
    v_Xtmp := v_Xtmp || '<ZXJG>' || r.执行结果 || '</ZXJG>';
    v_Xtmp := v_Xtmp || '<ZXSM>' || r.执行说明 || '</ZXSM>';
    v_Xtmp := v_Xtmp || '</ZXQK>';
  End Loop;

  x_Templet := Xmltype('<OUTPUT><LJEXEC>' || v_Xtmp || '</LJEXEC><YZLIST></YZLIST></OUTPUT>');

  --(西/成药，返回药品行，其它医嘱返回主医嘱行)
  For R In (Select a.医嘱期效, a.医嘱内容, a.单量, a.总量, a.结药途径, a.执行频次, a.时间方案, a.医生嘱托
            From (Select a.Id, a.相关id, a.诊疗类别, d.诊疗类别 As 主类别, a.医嘱期效, a.医嘱内容, a.单次用量 As 单量, a.总给予量 As 总量, e.名称 As 结药途径,
                          a.执行频次, a.执行时间方案 As 时间方案, a.医生嘱托, c.操作类型
                   From 病人医嘱记录 A, 病人路径医嘱 B, 诊疗项目目录 C, 病人医嘱记录 D, 诊疗项目目录 E
                   Where b.路径执行id = n_执行id And a.Id = b.病人医嘱id And a.诊疗项目id = c.Id(+) And a.相关id = d.Id(+) And
                         d.诊疗项目id = e.Id(+)) A
            Where a.相关id Is Null And Not (a.诊疗类别 = 'E' And a.操作类型 = '2')) Loop
    v_Xtmp := '<YZXX>';
    v_Xtmp := v_Xtmp || '<YZQX>' || r.医嘱期效 || '</YZQX>';
    v_Xtmp := v_Xtmp || '<YZNR>' || r.医嘱内容 || '</YZNR>';
    v_Xtmp := v_Xtmp || '<DL>' || r.单量 || '</DL>';
    v_Xtmp := v_Xtmp || '<ZL>' || r.总量 || '</ZL>';
    v_Xtmp := v_Xtmp || '<GYTJ>' || r.结药途径 || '</GYTJ>';
    v_Xtmp := v_Xtmp || '<ZXPL>' || r.执行频次 || '</ZXPL>';
    v_Xtmp := v_Xtmp || '<ZXSJ>' || r.时间方案 || '</ZXSJ>';
    v_Xtmp := v_Xtmp || '<YSZT>' || r.医生嘱托 || '</YSZT>';
    v_Xtmp := v_Xtmp || '</YZXX>';
    Select Appendchildxml(x_Templet, '/OUTPUT/YZLIST', Xmltype(v_Xtmp)) Into x_Templet From Dual;
  End Loop;
  Xml_Out := x_Templet;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getpathwaydetail;
/

--121143:胡俊勇,2018-01-29,移动护理和HIS相关的接口
CREATE OR REPLACE Procedure Zl_Third_Getpatiinfo_Ydhl
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --功能：获取单个病人基本信息/查询
  --入参：Xml_In
  --<IN>
  --     <PATIID></PATIID>         --病人ID
  --     <PAGEID></PAGEID>     --主页ID
  --</IN>

  --出参：Xml_Out
  --<OUTPUT>
  --    <PATI>
  --      <JBXX>    --基本信息
  --        <PATIID></PATIID>         --病人ID
  --        <PAGEID></PAGEID>  --主页ID
  --        <BABY></BABY>  --婴儿序号
  --        <XM></XM>   --姓名
  --        <XB></XB>   --性别
  --        <NL></NL>   --年龄
  --        <CSRQ></CSRQ>  --出生日期
  --        <ZYH></ZYH>  --住院号
  --        <HY></HY>   --婚姻
  --        <GJ></GJ>   --国籍
  --        <MZ></MZ>   --民族
  --        <XL></XL>   --学历
  --        <SF></SF>   --身份
  --        <ZY></ZY>   --职业
  --        <SFZH></SFZH>  --身份证号
  --        <FKFS></FKFS>  --付款方式
  --        <LXFS></LXFS>  --联系方式
  --        <LXRXM></LXRXM>  --联系人姓名
  --        <LXRDH></LXRDH>  --联系人电话
  --        <LXRDZ></LXRDZ>  --联系人地址
  --        <JTDH></JTDH>  --家庭电话
  --        <JTDZ></JTDZ>  --家庭地址
  --        <CSDD></CSDD>  --出生地点
  --        <GMS></GMS>  --过敏史
  --      </JBXX>
  --      <ZYXX>    --住院信息
  --        <RYRQ></RYRQ>  --入院日期
  --        <RKRQ></RKRQ>  --入科日期
  --        <CYRQ></CYRQ>  --出院日期
  --        <ZYTS></ZYTS>  --住院天数
  --        <RYFS></RYFS>  --入院方式
  --        <KSID></KSID>  --科室ID
  --        <KSMC></KSMC>  --科室名称
  --        <BQID></BQID>  --病区ID
  --        <BQMC></BQMC>  --病区名称
  --        <CH></CH>   --床号
  --        <BQ></BQ>   --病情
  --        <ZZYS></ZZYS>  --主治医师
  --        <ZRYS></ZRYS>  --主任医师
  --        <ZYYS></ZYYS>  --住院医师
  --        <ZRHS></ZRHS>  --责任护士
  --        <HLDJ></HLDJ>  --护理等级
  --        <YLZ></YLZ>    --医疗小组id
  --        <YBH></YBH>    --医保号
  --        <YBMC></YBMC>  --医保名称
  --      </ZYXX>
  --    </PATI>
  --</OUTPUT>

  n_病人id 病人医嘱记录.Id%Type;
  n_主页id 病人医嘱记录.主页id%Type;
  v_Xtmp   Clob; --临时XML

  x_Templet Xmltype;

  v_过敏信息 Varchar2(5000);
  v_主治医师 Varchar2(500);
  v_主任医师 Varchar2(500);

  Cursor c_Pati Is
    Select a.病人id, b.主页id, 0 As 婴儿序号, Nvl(b.姓名, a.姓名) As 姓名, Nvl(b.性别, a.性别) As 性别, Nvl(b.年龄, a.年龄) As 年龄, a.出生日期, b.住院号,
           a.婚姻状况 As 婚姻, a.国籍, a.民族, a.学历, a.身份, a.职业, a.身份证号, a.医疗付款方式 As 付款方式, a.手机号 As 联系方式, a.联系人姓名, a.联系人电话,
           a.联系人地址, a.家庭电话, a.家庭地址, a.出生地点, '待定单独查询' As 过敏史, Decode(b.入科时间, Null, b.入院日期, b.入科时间) As 入院日期,
           b.入科时间 As 入科日期, b.出院日期, (Trunc(Nvl(b.出院日期, Sysdate)) - Trunc(Decode(b.入科时间, Null, b.入院日期, b.入科时间))) As 住院天数,
           b.入院方式, b.出院科室id As 科室id, c.名称 As 科室名称, b.当前病区id As 病区id, f.名称 As 病区名称, b.出院病床 As 床号, b.当前病况 As 病情,
           '待定病案主页从表' As 主治医师, '待定病案主页从表' As 主任医师, b.住院医师, b.责任护士, e.名称 As 护理等级, b.医疗小组id, a.医保号, d.名称 As 医保名称
    From 病人信息 A, 病案主页 B, 部门表 C, 保险类别 D, 收费项目目录 E, 部门表 F
    Where a.病人id = b.病人id And b.出院科室id = c.Id And b.险类 = d.序号(+) And b.护理等级id = e.Id(+) And b.当前病区id = f.Id And
          b.病人id = n_病人id And b.主页id = n_主页id;

  --放到循环中执行的，可能有性能问题
  Procedure p_Getother
  (
    病人id_In    In 病人信息.病人id%Type,
    主页id_In    In 病案主页.主页id%Type,
    过敏信息_Out Out Varchar2,
    主治医师_Out Out Varchar2,
    主任医师_Out Out Varchar2
  ) Is
  Begin

    过敏信息_Out := Null;
    主治医师_Out := Null;
    主任医师_Out := Null;

    For R In (Select a.信息名, a.信息值
              From 病案主页从表 A
              Where a.病人id = 病人id_In And a.主页id = 主页id_In And a.信息名 In ('主治医师', '主任医师')) Loop
      If r.信息名 = '主治医师' Then
        主治医师_Out := r.信息值;
      Elsif r.信息名 = '主任医师' Then
        主任医师_Out := r.信息值;
      End If;
    End Loop;

    For R In (Select a.药物名
              From 病人过敏记录 A, 病人挂号记录 B, 病案主页 C
              Where a.病人id = b.病人id(+) And a.主页id = b.Id(+) And b.记录性质(+) = 1 And b.记录状态(+) = 1 And a.病人id = c.病人id(+) And
                    a.主页id = c.主页id(+) And a.结果 = 1 And 药物名 Is Not Null And a.病人id = 202 And Not Exists
               (Select 药物id
                     From 病人过敏记录
                     Where (Nvl(药物id, 0) = Nvl(a.药物id, 0) Or Nvl(药物名, 'Null') = Nvl(a.药物名, 'Null')) And Nvl(结果, 0) = 0 And
                           记录时间 > a.记录时间 And 病人id = 202)
              Group By a.药物名
              Order By a.药物名) Loop
      过敏信息_Out := 过敏信息_Out || ',' || r.药物名;
    End Loop;
    过敏信息_Out := Substr(过敏信息_Out, 2);
  End;
Begin

  Select Extractvalue(Value(A), 'IN/PATIID') As 病人id, Extractvalue(Value(A), 'IN/PAGEID') As 主页id
  Into n_病人id, n_主页id
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  x_Templet := Xmltype('<OUTPUT></OUTPUT>');
  For R In c_Pati Loop
    p_Getother(r.病人id, r.主页id, v_过敏信息, v_主治医师, v_主任医师);
    v_Xtmp := '<PATI>';
    v_Xtmp := v_Xtmp || '<JBXX>';
    v_Xtmp := v_Xtmp || '<PATIID>' || r.病人id || '</PATIID>';
    v_Xtmp := v_Xtmp || '<PAGEID>' || r.主页id || '</PAGEID>';
    v_Xtmp := v_Xtmp || '<BABY>' || r.婴儿序号 || '</BABY>';
    v_Xtmp := v_Xtmp || '<XM>' || r.姓名 || '</XM>';
    v_Xtmp := v_Xtmp || '<XB>' || r.性别 || '</XB>';
    v_Xtmp := v_Xtmp || '<NL>' || r.年龄 || '</NL>';
    v_Xtmp := v_Xtmp || '<CSRQ>' || To_Char(r.出生日期, 'yyyy-mm-dd hh24:mi:ss') || '</CSRQ>';
    v_Xtmp := v_Xtmp || '<ZYH>' || r.住院号 || '</ZYH>';
    v_Xtmp := v_Xtmp || '<HY>' || r.婚姻 || '</HY>';
    v_Xtmp := v_Xtmp || '<GJ>' || r.国籍 || '</GJ>';
    v_Xtmp := v_Xtmp || '<MZ>' || r.民族 || '</MZ>';
    v_Xtmp := v_Xtmp || '<XL>' || r.学历 || '</XL>';
    v_Xtmp := v_Xtmp || '<SF>' || r.身份 || '</SF>';
    v_Xtmp := v_Xtmp || '<ZY>' || r.职业 || '</ZY>';
    v_Xtmp := v_Xtmp || '<SFZH>' || r.身份证号 || '</SFZH>';
    v_Xtmp := v_Xtmp || '<FKFS>' || r.付款方式 || '</FKFS>';
    v_Xtmp := v_Xtmp || '<LXFS>' || r.联系方式 || '</LXFS>';
    v_Xtmp := v_Xtmp || '<LXRXM>' || r.联系人姓名 || '</LXRXM>';
    v_Xtmp := v_Xtmp || '<LXRDH>' || r.联系人电话 || '</LXRDH>';
    v_Xtmp := v_Xtmp || '<LXRDZ>' || r.联系人地址 || '</LXRDZ>';
    v_Xtmp := v_Xtmp || '<JTDH>' || r.家庭电话 || '</JTDH>';
    v_Xtmp := v_Xtmp || '<JTDZ>' || r.家庭地址 || '</JTDZ>';
    v_Xtmp := v_Xtmp || '<CSDD>' || r.出生地点 || '</CSDD>';
    v_Xtmp := v_Xtmp || '<GMS>' || v_过敏信息 || '</GMS>'; -- r.过敏史
    v_Xtmp := v_Xtmp || '</JBXX>';
    v_Xtmp := v_Xtmp || '<ZYXX>';
    v_Xtmp := v_Xtmp || '<RYRQ>' || To_Char(r.入院日期, 'yyyy-mm-dd hh24:mi:ss') || '</RYRQ>';
    v_Xtmp := v_Xtmp || '<RKRQ>' || To_Char(r.入科日期, 'yyyy-mm-dd hh24:mi:ss') || '</RKRQ>';
    v_Xtmp := v_Xtmp || '<CYRQ>' || To_Char(r.出院日期, 'yyyy-mm-dd hh24:mi:ss') || '</CYRQ>';
    v_Xtmp := v_Xtmp || '<ZYTS>' || r.住院天数 || '</ZYTS>';
    v_Xtmp := v_Xtmp || '<RYFS>' || r.入院方式 || '</RYFS>';
    v_Xtmp := v_Xtmp || '<KSID>' || r.科室id || '</KSID>';
    v_Xtmp := v_Xtmp || '<KSMC>' || r.科室名称 || '</KSMC>';
    v_Xtmp := v_Xtmp || '<BQID>' || r.病区id || '</BQID>';
    v_Xtmp := v_Xtmp || '<BQMC>' || r.病区名称 || '</BQMC>';
    v_Xtmp := v_Xtmp || '<CH>' || r.床号 || '</CH>';
    v_Xtmp := v_Xtmp || '<BQ>' || r.病情 || '</BQ>';
    v_Xtmp := v_Xtmp || '<ZZYS>' || v_主治医师 || '</ZZYS>';
    v_Xtmp := v_Xtmp || '<ZRYS>' || v_主任医师 || '</ZRYS>';
    v_Xtmp := v_Xtmp || '<ZYYS>' || r.住院医师 || '</ZYYS>';
    v_Xtmp := v_Xtmp || '<ZRHS>' || r.责任护士 || '</ZRHS>';
    v_Xtmp := v_Xtmp || '<HLDJ>' || r.护理等级 || '</HLDJ>';
    v_Xtmp := v_Xtmp || '<YLZ>' || r.医疗小组id || '</YLZ>';
    v_Xtmp := v_Xtmp || '<YBH>' || r.医保号 || '</YBH>';
    v_Xtmp := v_Xtmp || '<YBMC>' || r.医保名称 || '</YBMC>';
    v_Xtmp := v_Xtmp || '</ZYXX>';
    v_Xtmp := v_Xtmp || '</PATI>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Xtmp)) Into x_Templet From Dual;
  End Loop;
  Xml_Out := x_Templet;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getpatiinfo_Ydhl;
/

--121143:胡俊勇,2018-01-29,移动护理和HIS相关的接口
CREATE OR REPLACE Procedure Zl_Third_Getdiagnosis
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --功能：获取病人诊断信息/查询
  --入参：Xml_In
  --<IN>
  --     <PATIID></PATIID>         --病人ID
  --     <PAGEID></PAGEID>     --主页ID
  --</IN>
  --出参：Xml_Out
  --<OUTPUT>
  --  <ZDLIST>
  --    <ZD>
  --      <ZDLX></ZDLX> --诊断类型。类型的名称，门诊诊断、入院诊断、出院诊断等
  --      <ZDCX></ZDCX> --诊断次序
  --      <ZDBM></ZDBM> --诊断编码
  --      <ZDMC></ZDMC> --诊断名称
  --    </ZD>
  --  </ZDLIST>
  --</OUTPUT>

  n_病人id   病人医嘱记录.病人id%Type;
  n_主页id   病人医嘱记录.主页id%Type;
  v_Xtmp     Varchar(5000); --临时XML
  v_Tmp      Varchar2(800);
  v_诊断编码 Varchar2(1000);
  v_诊断名称 Varchar2(1000);
  x_Templet  Xmltype;
Begin
  Select Extractvalue(Value(A), 'IN/PATIID'), Extractvalue(Value(A), 'IN/PAGEID')
  Into n_病人id, n_主页id
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  x_Templet := Xmltype('<OUTPUT><ZDLIST></ZDLIST></OUTPUT>');

  For R In (Select Decode(a.诊断类型, 1, '西医门诊诊断', 2, '西医入院诊断', 3, '西医出院诊断', 5, '院内感染', 6, '病理诊断', 7, '损伤中毒码', 8, '术前诊断', 9,
                           '术后诊断', 10, '并发症', 11, '中医门诊诊断', 12, '中医入院诊断', 13, '中医出院诊断', 21, '病原学诊断', 22, '影像学诊断') As 诊断类型,
                   a.诊断次序, a.诊断描述
            From 病人诊断记录 A
            Where a.病人id = n_病人id And a.主页id = n_主页id
            Order By a.诊断类型, a.诊断次序) Loop
  
    v_诊断编码 := Null;
    v_诊断名称 := r.诊断描述;
    v_Tmp      := r.诊断描述;
    If Substr(v_Tmp, 1, 1) = '(' Then
      v_诊断编码 := Substr(v_Tmp, 2, Instr(v_Tmp, ')') - 2);
      v_诊断名称 := Substr(v_Tmp, Instr(v_Tmp, ')') + 1);
    End If;
  
    v_Xtmp := '<ZD>';
    v_Xtmp := v_Xtmp || '<ZDLX>' || r.诊断类型 || '</ZDLX>';
    v_Xtmp := v_Xtmp || '<ZDCX>' || r.诊断次序 || '</ZDCX>';
    v_Xtmp := v_Xtmp || '<ZDBM>' || v_诊断编码 || '</ZDBM>';
    v_Xtmp := v_Xtmp || '<ZDMC>' || v_诊断名称 || '</ZDMC>';
    v_Xtmp := v_Xtmp || '</ZD>';
    
    Select Appendchildxml(x_Templet, '/OUTPUT/ZDLIST', Xmltype(v_Xtmp)) Into x_Templet From Dual;
  End Loop;
  Xml_Out := x_Templet;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getdiagnosis;
/

--121143:胡俊勇,2018-01-29,移动护理和HIS相关的接口
CREATE OR REPLACE Procedure Zl_Third_Getallergy
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --功能：获取病人过敏记录/查询
  --入参：Xml_In
  --<IN>
  --     <PATIID></PATIID>         --病人ID
  --     <PAGEID></PAGEID>     --主页ID
  --</IN>
  --出参：Xml_Out
  --<OUTPUT>
  --  <GMLIST>
  --    <GM>
  --      <GMYW></GMYW> --过敏药物
  --      <GMSJ></GMSJ> --过敏时间
  --      <JLSJ></JLSJ> --记录时间
  --      <JLR></JLR> --记录人
  --    </GM>
  --  </GMLIST>
  --</OUTPUT>
  n_病人id  病人医嘱记录.病人id%Type;
  n_主页id  病人医嘱记录.主页id%Type;
  v_Xtmp    Varchar(5000); --临时XML
  x_Templet Xmltype;
Begin
  Select Extractvalue(Value(A), 'IN/PATIID'), Extractvalue(Value(A), 'IN/PAGEID')
  Into n_病人id, n_主页id
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  x_Templet := Xmltype('<OUTPUT><GMLIST></GMLIST></OUTPUT>');
  For R In (Select a.药物名, a.过敏时间, a.记录时间, a.记录人
            From 病人过敏记录 A
            Where a.病人id = n_病人id And a.主页id = n_主页id
            Order By a.记录时间) Loop
    v_Xtmp := '<GM>';
    v_Xtmp := v_Xtmp || '<GMYW>' || r.药物名 || '</GMYW>'; --过敏药物
    v_Xtmp := v_Xtmp || '<GMSJ>' || To_Char(r.过敏时间, 'yyyy-mm-dd hh24:mi:ss') || '</GMSJ>'; --过敏时间
    v_Xtmp := v_Xtmp || '<JLSJ>' || To_Char(r.记录时间, 'yyyy-mm-dd hh24:mi:ss') || '</JLSJ>'; --记录时间
    v_Xtmp := v_Xtmp || '<JLR>' || r.记录人 || '</JLR>'; --记录人
    v_Xtmp := v_Xtmp || '</GM>';

    Select Appendchildxml(x_Templet, '/OUTPUT/GMLIST', Xmltype(v_Xtmp)) Into x_Templet From Dual;
  End Loop;
  Xml_Out := x_Templet;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getallergy;
/

--121143:胡俊勇,2018-01-29,移动护理和HIS相关的接口
Create Or Replace Procedure Zl_Third_Getpatichange
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --功能：获取病人变动记录/查询
  --入参：Xml_In
  --<IN>
  --     <PATIID></PATIID>         --病人ID
  --     <PAGEID></PAGEID>     --主页ID
  --</IN>
  --出参：Xml_Out
  --<OUTPUT>
  --  <BDLIST>--变动数据
  --    <ITEM>
  --      <SJ></SJ>--变动时间
  --      <LSXLIST>--变动类型列表
  --         <ITEM>
  --           <MC></MC>--变动类型名称（调整护理等级/调整住院医师/调整护士/留观转住院/调整主任医师/调整病况/调整医疗小组/调整病区/入院/入住/换床/调整床位等级/预出院/调整主治医师）
  --           <XXLIST>--变动信息列表
  --              <ITEM>
  --                <XXM></XXM>  ----信息名称（医疗小组/病区/科室/床号/床位等级/护理等级/护士/住院医师/主治医生/主任医生/当前病况/包床情况）         
  --                <YXX></YXX>  ----原信息值        
  --                <XXX></XXX>  ----现信息值             
  --              </ITEM> 
  --              ...
  --           </XXLIST>
  --         </ITEM>
  --         ...
  --      </LSXLIST>  
  --    </ITEM>
  --    ... 
  --  </BDLIST>
  --</OUTPUT>

  n_病人id 病人医嘱记录.病人id%Type;
  n_主页id 病人医嘱记录.主页id%Type;

  v_Tmp  Varchar(5000);
  v_Tmp1 Varchar(5000);

  v_Pre时间  Varchar(500);
  v_Cur时间  Varchar(500);
  v_变动名称 Varchar(500);

  n_Preidx Number;
  n_Curidx Number;

  v_Value    Varchar(500);
  x_Templet  Xmltype;
  x_变动时间 Xmltype;
  x_变动类型 Xmltype;

  Cursor c_Pati Is
    Select a.Id, f.名称 As 医疗小组名, b.名称 As 病区, c.名称 As 科室, a.附加床位, Decode(a.附加床位, 0, '主床', '包床') As 床位性质, a.床号,
           d.名称 As 床位等级, e.名称 As 护理等级, a.责任护士 As 护士, a.经治医师 As 住院医师, a.主治医师 As 主治医生, a.主任医师 As 主任医生, a.病情 As 当前病况,
           a.操作员姓名 As 开始操作员,
           Decode(a.开始原因, 1, '入院', 2, '入住', 3, '转科', 4, '换床', 5, '调整床位等级', 6, '调整护理等级', 7, '调整住院医师', 8, '调整护士', 9,
                   '留观转住院', 10, '预出院', 11, '调整主治医师', 12, '调整主任医师', 13, '调整病况', 14, '调整医疗小组', 15, '调整病区') As 开始原因,
           To_Char(a.开始时间, 'YYYY-MM-DD HH24:MI:SS') As 开始时间, a.终止人员 As 终止操作员,
           Decode(a.终止原因, 1, '出院', 2, '入住', 3, '转科', 4, '换床', 5, '调整床位等级', 6, '调整护理等级', 7, '调整住院医师', 8, '调整护士', 9,
                   '留观转住院', 10, '预出院', 11, '调整主治医师', 12, '调整主任医师', 13, '调整病况', 14, '调整医疗小组', 15, '调整病区') As 终止原因,
           To_Char(a.终止时间, 'YYYY-MM-DD HH24:MI:SS') As 终止时间
    From 病人变动记录 A, 部门表 B, 部门表 C, 收费项目目录 D, 收费项目目录 E, 临床医疗小组 F
    Where a.病区id = b.Id And a.科室id = c.Id And a.床位等级id = d.Id(+) And a.护理等级id = e.Id(+) And a.病人id = n_病人id And
          a.主页id = n_主页id And a.开始时间 Is Not Null And a.医疗小组id = f.Id(+)
    Order By a.终止时间, a.开始时间, a.附加床位, a.床号;

  Type t_Pati Is Table Of c_Pati%RowType;
  r_Pati t_Pati;
  r_Seek t_Pati;

Begin
  Select Extractvalue(Value(A), 'IN/PATIID') As 病人id, Extractvalue(Value(A), 'IN/PAGEID') As 主页id
  Into n_病人id, n_主页id
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  Open c_Pati;
  Fetch c_Pati Bulk Collect
    Into r_Pati;
  Close c_Pati;
  r_Seek := r_Pati;

  v_Pre时间 := '0';
  n_Preidx  := 0;
  n_Curidx  := 0;

  x_Templet := Xmltype('<OUTPUT><BDLIST></BDLIST></OUTPUT>');

  For I In 1 .. r_Pati.Count Loop
    --以时间点为一次变动
    If v_Pre时间 <> r_Pati(I).开始时间 And r_Pati(I).附加床位 = 0 Then
      v_Cur时间 := r_Pati(I).开始时间;
      --这中间查出变动情况
      x_变动时间 := Xmltype('<ITEM><SJ>' || v_Cur时间 || '</SJ><LSXLIST></LSXLIST></ITEM>');
    
      v_变动名称 := '0';
      For J In 1 .. r_Seek.Count Loop
        If r_Seek(J).开始时间 = v_Cur时间 And r_Seek(J).附加床位 = 0 Then
          If v_变动名称 <> r_Seek(J).开始原因 Then
            v_变动名称 := r_Seek(J).开始原因;
            n_Curidx   := J;
            x_变动类型 := Xmltype('<ITEM><MC>' || v_变动名称 || '</MC><XXLIST></XXLIST></ITEM>');
          
            --医疗小组名
            v_Value := Null;
            If n_Preidx <> 0 Then
              If Nvl(r_Seek(n_Preidx).医疗小组名, 'XXX') <> Nvl(r_Seek(n_Curidx).医疗小组名, 'XXX') Then
                v_Value := '<ITEM><XXM>医疗小组名</XXM><YXX>' || r_Seek(n_Preidx).医疗小组名 || '</YXX><XXX>' || r_Seek(n_Curidx)
                          .医疗小组名 || '</XXX></ITEM>';
              End If;
            Else
              If r_Seek(n_Curidx).医疗小组名 Is Not Null Then
                v_Value := '<ITEM><XXM>医疗小组名</XXM><YXX></YXX><XXX>' || r_Seek(n_Curidx).医疗小组名 || '</XXX></ITEM>';
              End If;
            End If;
            If v_Value Is Not Null Then
              Select Appendchildxml(x_变动类型, '/ITEM/XXLIST', Xmltype(v_Value)) Into x_变动类型 From Dual;
            End If;
          
            --病区
            v_Value := Null;
            If n_Preidx <> 0 Then
              If Nvl(r_Seek(n_Preidx).病区, 'XXX') <> Nvl(r_Seek(n_Curidx).病区, 'XXX') Then
                v_Value := '<ITEM><XXM>病区</XXM><YXX>' || r_Seek(n_Preidx).病区 || '</YXX><XXX>' || r_Seek(n_Curidx).病区 ||
                           '</XXX></ITEM>';
              End If;
            Else
              If r_Seek(n_Curidx).病区 Is Not Null Then
                v_Value := '<ITEM><XXM>病区</XXM><YXX></YXX><XXX>' || r_Seek(n_Curidx).病区 || '</XXX></ITEM>';
              End If;
            End If;
            If v_Value Is Not Null Then
              Select Appendchildxml(x_变动类型, '/ITEM/XXLIST', Xmltype(v_Value)) Into x_变动类型 From Dual;
            End If;
          
            --科室
            v_Value := Null;
            If n_Preidx <> 0 Then
              If Nvl(r_Seek(n_Preidx).科室, 'XXX') <> Nvl(r_Seek(n_Curidx).科室, 'XXX') Then
                v_Value := '<ITEM><XXM>科室</XXM><YXX>' || r_Seek(n_Preidx).科室 || '</YXX><XXX>' || r_Seek(n_Curidx).科室 ||
                           '</XXX></ITEM>';
              End If;
            Else
              If r_Seek(n_Curidx).科室 Is Not Null Then
                v_Value := '<ITEM><XXM>科室</XXM><YXX></YXX><XXX>' || r_Seek(n_Curidx).科室 || '</XXX></ITEM>';
              End If;
            End If;
            If v_Value Is Not Null Then
              Select Appendchildxml(x_变动类型, '/ITEM/XXLIST', Xmltype(v_Value)) Into x_变动类型 From Dual;
            End If;
          
            --床号
            v_Value := Null;
            If n_Preidx <> 0 Then
              If Nvl(r_Seek(n_Preidx).床号, 'XXX') <> Nvl(r_Seek(n_Curidx).床号, 'XXX') Then
                v_Value := '<ITEM><XXM>床号</XXM><YXX>' || r_Seek(n_Preidx).床号 || '</YXX><XXX>' || r_Seek(n_Curidx).床号 ||
                           '</XXX></ITEM>';
              End If;
            Else
              If r_Seek(n_Curidx).床号 Is Not Null Then
                v_Value := '<ITEM><XXM>床号</XXM><YXX></YXX><XXX>' || r_Seek(n_Curidx).床号 || '</XXX></ITEM>';
              End If;
            End If;
            If v_Value Is Not Null Then
              Select Appendchildxml(x_变动类型, '/ITEM/XXLIST', Xmltype(v_Value)) Into x_变动类型 From Dual;
            End If;
          
            --床位等级
            v_Value := Null;
            If n_Preidx <> 0 Then
              If Nvl(r_Seek(n_Preidx).床位等级, 'XXX') <> Nvl(r_Seek(n_Curidx).床位等级, 'XXX') Then
                v_Value := '<ITEM><XXM>床位等级</XXM><YXX>' || r_Seek(n_Preidx).床位等级 || '</YXX><XXX>' || r_Seek(n_Curidx).床位等级 ||
                           '</XXX></ITEM>';
              End If;
            Else
              If r_Seek(n_Curidx).床位等级 Is Not Null Then
                v_Value := '<ITEM><XXM>床位等级</XXM><YXX></YXX><XXX>' || r_Seek(n_Curidx).床位等级 || '</XXX></ITEM>';
              End If;
            End If;
            If v_Value Is Not Null Then
              Select Appendchildxml(x_变动类型, '/ITEM/XXLIST', Xmltype(v_Value)) Into x_变动类型 From Dual;
            End If;
          
            --护理等级
            v_Value := Null;
            If n_Preidx <> 0 Then
              If Nvl(r_Seek(n_Preidx).护理等级, 'XXX') <> Nvl(r_Seek(n_Curidx).护理等级, 'XXX') Then
                v_Value := '<ITEM><XXM>护理等级</XXM><YXX>' || r_Seek(n_Preidx).护理等级 || '</YXX><XXX>' || r_Seek(n_Curidx).护理等级 ||
                           '</XXX></ITEM>';
              End If;
            Else
              If r_Seek(n_Curidx).护理等级 Is Not Null Then
                v_Value := '<ITEM><XXM>护理等级</XXM><YXX></YXX><XXX>' || r_Seek(n_Curidx).护理等级 || '</XXX></ITEM>';
              End If;
            End If;
            If v_Value Is Not Null Then
              Select Appendchildxml(x_变动类型, '/ITEM/XXLIST', Xmltype(v_Value)) Into x_变动类型 From Dual;
            End If;
          
            --护士
            v_Value := Null;
            If n_Preidx <> 0 Then
              If Nvl(r_Seek(n_Preidx).护士, 'XXX') <> Nvl(r_Seek(n_Curidx).护士, 'XXX') Then
                v_Value := '<ITEM><XXM>护士</XXM><YXX>' || r_Seek(n_Preidx).护士 || '</YXX><XXX>' || r_Seek(n_Curidx).护士 ||
                           '</XXX></ITEM>';
              End If;
            Else
              If r_Seek(n_Curidx).护士 Is Not Null Then
                v_Value := '<ITEM><XXM>护士</XXM><YXX></YXX><XXX>' || r_Seek(n_Curidx).护士 || '</XXX></ITEM>';
              End If;
            End If;
            If v_Value Is Not Null Then
              Select Appendchildxml(x_变动类型, '/ITEM/XXLIST', Xmltype(v_Value)) Into x_变动类型 From Dual;
            End If;
          
            --住院医师
            v_Value := Null;
            If n_Preidx <> 0 Then
              If Nvl(r_Seek(n_Preidx).住院医师, 'XXX') <> Nvl(r_Seek(n_Curidx).住院医师, 'XXX') Then
                v_Value := '<ITEM><XXM>住院医师</XXM><YXX>' || r_Seek(n_Preidx).住院医师 || '</YXX><XXX>' || r_Seek(n_Curidx).住院医师 ||
                           '</XXX></ITEM>';
              End If;
            Else
              If r_Seek(n_Curidx).住院医师 Is Not Null Then
                v_Value := '<ITEM><XXM>住院医师</XXM><YXX></YXX><XXX>' || r_Seek(n_Curidx).住院医师 || '</XXX></ITEM>';
              End If;
            End If;
            If v_Value Is Not Null Then
              Select Appendchildxml(x_变动类型, '/ITEM/XXLIST', Xmltype(v_Value)) Into x_变动类型 From Dual;
            End If;
          
            --主治医生
            v_Value := Null;
            If n_Preidx <> 0 Then
              If Nvl(r_Seek(n_Preidx).主治医生, 'XXX') <> Nvl(r_Seek(n_Curidx).主治医生, 'XXX') Then
                v_Value := '<ITEM><XXM>主治医生</XXM><YXX>' || r_Seek(n_Preidx).主治医生 || '</YXX><XXX>' || r_Seek(n_Curidx).主治医生 ||
                           '</XXX></ITEM>';
              End If;
            Else
              If r_Seek(n_Curidx).主治医生 Is Not Null Then
                v_Value := '<ITEM><XXM>主治医生</XXM><YXX></YXX><XXX>' || r_Seek(n_Curidx).主治医生 || '</XXX></ITEM>';
              End If;
            End If;
            If v_Value Is Not Null Then
              Select Appendchildxml(x_变动类型, '/ITEM/XXLIST', Xmltype(v_Value)) Into x_变动类型 From Dual;
            End If;
          
            --主任医生
            v_Value := Null;
            If n_Preidx <> 0 Then
              If Nvl(r_Seek(n_Preidx).主任医生, 'XXX') <> Nvl(r_Seek(n_Curidx).主任医生, 'XXX') Then
                v_Value := '<ITEM><XXM>主任医生</XXM><YXX>' || r_Seek(n_Preidx).主任医生 || '</YXX><XXX>' || r_Seek(n_Curidx).主任医生 ||
                           '</XXX></ITEM>';
              End If;
            Else
              If r_Seek(n_Curidx).主任医生 Is Not Null Then
                v_Value := '<ITEM><XXM>主任医生</XXM><YXX></YXX><XXX>' || r_Seek(n_Curidx).主任医生 || '</XXX></ITEM>';
              End If;
            End If;
            If v_Value Is Not Null Then
              Select Appendchildxml(x_变动类型, '/ITEM/XXLIST', Xmltype(v_Value)) Into x_变动类型 From Dual;
            End If;
          
            --当前病况
            v_Value := Null;
            If n_Preidx <> 0 Then
              If Nvl(r_Seek(n_Preidx).当前病况, 'XXX') <> Nvl(r_Seek(n_Curidx).当前病况, 'XXX') Then
                v_Value := '<ITEM><XXM>当前病况</XXM><YXX>' || r_Seek(n_Preidx).当前病况 || '</YXX><XXX>' || r_Seek(n_Curidx).当前病况 ||
                           '</XXX></ITEM>';
              End If;
            Else
              If r_Seek(n_Curidx).当前病况 Is Not Null Then
                v_Value := '<ITEM><XXM>当前病况</XXM><YXX></YXX><XXX>' || r_Seek(n_Curidx).当前病况 || '</XXX></ITEM>';
              End If;
            End If;
            If v_Value Is Not Null Then
              Select Appendchildxml(x_变动类型, '/ITEM/XXLIST', Xmltype(v_Value)) Into x_变动类型 From Dual;
            End If;
          
            ----包床情况  用床号拼串即可（简单处理）
            v_Value := Null;
            v_Tmp   := Null;
            v_Tmp1  := Null;
            If n_Preidx <> 0 Then
              --检查之前的变动是否是包了床,用床号拼串即可（简单处理）
              For K In 1 .. r_Seek.Count Loop
                If v_变动名称 = r_Seek(K).终止原因 And v_Cur时间 = r_Seek(K).终止时间 And r_Seek(K).附加床位 = 1 Then
                  If v_Tmp Is Null Then
                    v_Tmp := r_Seek(K).床号;
                  Else
                    v_Tmp := v_Tmp || ',' || r_Seek(K).床号;
                  End If;
                End If;
              End Loop;
            End If;
            --检查当前的变动是否是包了床,用床号拼串即可（简单处理）
            For K In 1 .. r_Seek.Count Loop
              If v_变动名称 = r_Seek(K).开始原因 And v_Cur时间 = r_Seek(K).开始时间 And r_Seek(K).附加床位 = 1 Then
                If v_Tmp1 Is Null Then
                  v_Tmp1 := r_Seek(K).床号;
                Else
                  v_Tmp1 := v_Tmp1 || ',' || r_Seek(K).床号;
                End If;
              End If;
            End Loop;
            If Nvl(v_Tmp, 'XXX') <> Nvl(v_Tmp1, 'XXX') Then
              v_Value := '<ITEM><XXM>包床情况</XXM><YXX>' || v_Tmp || '</YXX><XXX>' || v_Tmp1 || '</XXX></ITEM>';
            End If;
            If v_Value Is Not Null Then
              Select Appendchildxml(x_变动类型, '/ITEM/XXLIST', Xmltype(v_Value)) Into x_变动类型 From Dual;
            End If;
          
            Select Appendchildxml(x_变动时间, '/ITEM/LSXLIST', x_变动类型) Into x_变动时间 From Dual;
          End If;
        End If;
      End Loop;
    
      v_Pre时间 := v_Cur时间;
      n_Preidx  := I;
    
      Select Appendchildxml(x_Templet, '/OUTPUT/BDLIST', x_变动时间) Into x_Templet From Dual;
    End If;
  End Loop;
  Xml_Out := x_Templet;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getpatichange;
/

--121143:胡俊勇,2018-01-29,移动护理和HIS相关的接口
CREATE OR REPLACE Procedure Zl_Third_Getoperation
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --功能：获取病人手术信息/查询
  --用于获取指定病人的手术信息
  --当监听到病人发送手术医嘱时调用
  --当监听到病人完成手术时调用
  --需要手动同步时调用
  --获取所有病人信息后调用
  --入参：Xml_In
  --<IN>
  --  <PATIID></PATIID>     --病人ID
  --  <PAGEID></PAGEID>     --主页ID
  --</IN>

  --出参：Xml_Out 
  --<OUTPUT>
  --  <SSLIST>
  --    <SS>
  --      <SSMC></SSMC>  //手术名称
  --      <SSSJ></SSSJ>  //手术时间,yyyy-mm-dd hh24:mi
  --      <MZFS></MZFS>  //麻醉方式
  --      <SSQK></SSQK>  //手术情况  择期、急诊、限期
  --      <ZXKSID></ZXKSID>   //执行科室ID
  --      <ZXKSMC></ZXKSMC>    //执行科室名称
  --      <FJSS></FJSS>     //附加手术   1-是，0-否
  --    <SS>
  --  <SSLIST>
  --</OUTPUT>

  n_病人id   病人医嘱记录.病人id%Type;
  n_主页id   病人医嘱记录.主页id%Type;
  n_主医嘱id 病人医嘱记录.Id%Type;
  v_麻醉     诊疗项目目录.名称%Type;
  v_Xtmp     Clob; --临时XML 

  Cursor c_医嘱 Is
    Select b.名称, a.标本部位 As 手术时间, Nvl(a.相关id, a.Id) As 主医嘱id, a.执行科室id, c.名称 As 执行科室名称,
           Decode(a.相关id, Null, 0, 1) As 附加手术, a.诊疗类别, Decode(a.手术情况, Null, '择期', 1, '急诊', 2, '限期', Null) As 手术情况
    From 病人医嘱记录 A, 诊疗项目目录 B, 部门表 C
    Where a.诊疗项目id = b.Id And a.执行科室id = c.Id And a.诊疗类别 In ('F', 'G') And a.医嘱状态 <> 4 And Nvl(a.执行标记, 0) <> -1 And
          a.病人id = n_病人id And a.主页id = n_主页id
    Order By a.诊疗类别 Desc, a.序号;
Begin

  Select Extractvalue(Value(A), 'IN/PATIID') As 病人id, Extractvalue(Value(A), 'IN/PAGEID') As 主页id
  Into n_病人id, n_主页id
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  n_主医嘱id := 0;

  For R In c_医嘱 Loop
    If n_主医嘱id <> r.主医嘱id Then
      n_主医嘱id := r.主医嘱id;
      If r.诊疗类别 = 'G' Then
        v_麻醉 := r.名称;
      End If;
    Else
      v_麻醉 := Null;
    End If;
  
    If r.诊疗类别 = 'F' Then
      v_Xtmp := v_Xtmp || '<SS>';
      v_Xtmp := v_Xtmp || '<SSMC>' || r.名称 || '</SSMC>'; --  //手术名称
      v_Xtmp := v_Xtmp || '<SSSJ>' || r.手术时间 || '</SSSJ>'; --  //手术时间,yyyy-mm-dd hh24:mi
      v_Xtmp := v_Xtmp || '<MZFS>' || v_麻醉 || '</MZFS>'; --  //麻醉方式
      v_Xtmp := v_Xtmp || '<SSQK>' || r.手术情况 || '</SSQK>'; --  //手术情况  择期、急诊、限期
      v_Xtmp := v_Xtmp || '<ZXKSID>' || r.执行科室id || '</ZXKSID>'; --   //执行科室ID
      v_Xtmp := v_Xtmp || '<ZXKSMC>' || r.执行科室名称 || '</ZXKSMC>'; --    //执行科室名称
      v_Xtmp := v_Xtmp || '<FJSS>' || r.附加手术 || '</FJSS>'; --    //附加手术   1-是，0-否    
      v_Xtmp := v_Xtmp || '</SS>';
    End If;
  End Loop;

  If v_Xtmp Is Not Null Then
    Xml_Out := Xmltype('<OUTPUT><SSLIST>' || v_Xtmp || '</SSLIST></OUTPUT>');
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getoperation;
/

--121143:胡俊勇,2018-01-29,移动护理和HIS相关的接口
CREATE OR REPLACE Procedure Zl_Third_Getallpatiinfo
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --功能：获取病区所有病人基本信息/查询
  --用于获取某病区所有病人的基本信息。
  --在第一次获取病人信息时调用
  --每天晚上自动同步时调用
  --需要手动同步时调用

  --入参：Xml_In
  --<INPUT>
  --  <BQID></BQID>      --病区ID
  --  <CYTS></CYTS>      --出院天数，获取多少天之内出院的病人
  --</INPUT>

  --出参：Xml_Out 
  --<OUTPUT>
  --  <PATILIST>
  --    <PATI>
  --      <JBXX>    --基本信息
  --        <PATIID></PATIID>         --病人ID
  --        <PAGEID></PAGEID>  --主页ID
  --        <BABY></BABY>  --婴儿序号
  --        <XM></XM>   --姓名
  --        <XB></XB>   --性别
  --        <NL></NL>   --年龄
  --        <CSRQ></CSRQ>  --出生日期
  --        <ZYH></ZYH>  --住院号
  --        <HY></HY>   --婚姻
  --        <GJ></GJ>   --国籍
  --        <MZ></MZ>   --民族
  --        <XL></XL>   --学历
  --        <SF></SF>   --身份
  --        <ZY></ZY>   --职业
  --        <SFZH></SFZH>  --身份证号
  --        <FKFS></FKFS>  --付款方式
  --        <LXFS></LXFS>  --联系方式
  --        <LXRXM></LXRXM>  --联系人姓名
  --        <LXRDH></LXRDH>  --联系人电话
  --        <LXRDZ></LXRDZ>  --联系人地址
  --        <JTDH></JTDH>  --家庭电话
  --        <JTDZ></JTDZ>  --家庭地址
  --        <CSDD></CSDD>  --出生地点
  --        <GMS></GMS>  --过敏史
  --      </JBXX>
  --      <ZYXX>    --住院信息
  --        <RYRQ></RYRQ>  --入院日期
  --        <RKRQ></RKRQ>  --入科日期
  --        <CYRQ></CYRQ>  --出院日期
  --        <ZYTS></ZYTS>  --住院天数
  --        <RYFS></RYFS>  --入院方式
  --        <KSID></KSID>  --科室ID
  --        <KSMC></KSMC>  --科室名称
  --        <BQID></BQID>  --病区ID
  --        <BQMC></BQMC>  --病区名称
  --        <CH></CH>   --床号
  --        <BQ></BQ>   --病情
  --        <ZZYS></ZZYS>  --主治医师
  --        <ZRYS></ZRYS>  --主任医师
  --        <ZYYS></ZYYS>  --住院医师
  --        <ZRHS></ZRHS>  --责任护士
  --        <HLDJ></HLDJ>  --护理等级
  --        <YLZ></YLZ>    --医疗小组id
  --        <YBH></YBH>    --医保号
  --        <YBMC></YBMC>  --医保名称
  --      </ZYXX>
  --    </PATI>
  --  </PATILIST>
  --</OUTPUT>

  n_病区id 部门表.Id%Type;
  v_病区   部门表.名称%Type;
  n_天数   Number;
  v_Xtmp   Clob; --临时XML 
  x_Item   Xmltype;
  d_开始   Date;
  d_结束   Date;

  v_过敏信息 Varchar2(5000);
  v_主治医师 Varchar2(500);
  v_主任医师 Varchar2(500);
  x_Templet  Xmltype;

  Cursor c_在院 Is
    Select a.病人id, b.主页id, 0 As 婴儿序号, Nvl(b.姓名, a.姓名) As 姓名, Nvl(b.性别, a.性别) As 性别, Nvl(b.年龄, a.年龄) As 年龄, a.出生日期, b.住院号,
           a.婚姻状况 As 婚姻, a.国籍, a.民族, a.学历, a.身份, a.职业, a.身份证号, a.医疗付款方式 As 付款方式, a.手机号 As 联系方式, a.联系人姓名, a.联系人电话,
           a.联系人地址, a.家庭电话, a.家庭地址, a.出生地点, '待定单独查询' As 过敏史, Decode(b.入科时间, Null, b.入院日期, b.入科时间) As 入院日期,
           b.入科时间 As 入科日期, Null As 出院日期, (Trunc(Sysdate) - Trunc(Decode(b.入科时间, Null, b.入院日期, b.入科时间))) As 住院天数, b.入院方式,
           b.出院科室id As 科室id, c.名称 As 科室名称, r.病区id, v_病区 As 病区名称, b.出院病床 As 床号, b.当前病况 As 病情, '待定病案主页从表' As 主治医师,
           '待定病案主页从表' As 主任医师, b.住院医师, b.责任护士, e.名称 As 护理等级, b.医疗小组id, a.医保号, d.名称 As 医保名称


    From 病人信息 A, 病案主页 B, 部门表 C, 保险类别 D, 收费项目目录 E, 在院病人 R
    Where a.病人id = b.病人id And a.主页id = b.主页id And b.出院科室id = c.Id And b.险类 = d.序号(+) And Nvl(b.状态, 0) <> 1 And
          b.护理等级id = e.Id(+) And (r.病区id = n_病区id Or b.婴儿病区id = n_病区id) And a.病人id = r.病人id And a.当前病区id + 0 = r.病区id And
          Nvl(b.病案状态, 0) <> 5 And b.封存时间 Is Null
    Order By b.出院病床;

  Cursor c_出院 Is
    Select a.病人id, b.主页id, 0 As 婴儿序号, Nvl(b.姓名, a.姓名) As 姓名, Nvl(b.性别, a.性别) As 性别, Nvl(b.年龄, a.年龄) As 年龄, a.出生日期, b.住院号,
           a.婚姻状况 As 婚姻, a.国籍, a.民族, a.学历, a.身份, a.职业, a.身份证号, a.医疗付款方式 As 付款方式, a.手机号 As 联系方式, a.联系人姓名, a.联系人电话,
           a.联系人地址, a.家庭电话, a.家庭地址, a.出生地点, '待定单独查询' As 过敏史, Decode(b.入科时间, Null, b.入院日期, b.入科时间) As 入院日期,
           b.入科时间 As 入科日期, b.出院日期, (Trunc(b.出院日期) - Trunc(Decode(b.入科时间, Null, b.入院日期, b.入科时间))) As 住院天数, b.入院方式,
           b.出院科室id As 科室id, c.名称 As 科室名称, b.当前病区id As 病区id, v_病区 As 病区名称, b.出院病床 As 床号, b.当前病况 As 病情,
           '待定病案主页从表' As 主治医师, '待定病案主页从表' As 主任医师, b.住院医师, b.责任护士, e.名称 As 护理等级, b.医疗小组id, a.医保号, d.名称 As 医保名称
    From 病人信息 A, 病案主页 B, 部门表 C, 保险类别 D, 收费项目目录 E
    Where a.病人id = b.病人id And Nvl(b.主页id, 0) <> 0 And b.状态 = 0 And b.出院科室id = c.Id And b.险类 = d.序号(+) And
          b.护理等级id = e.Id(+) And b.当前病区id + 0 = n_病区id And Nvl(b.病案状态, 0) <> 5 And b.封存时间 Is Null And
          b.出院日期 Between d_开始 And d_结束
    Order By b.出院病床;

  --放到循环中执行的，可能有性能问题
  Procedure p_Getother
  (
    病人id_In    In 病人信息.病人id%Type,
    主页id_In    In 病案主页.主页id%Type,
    过敏信息_Out Out Varchar2,
    主治医师_Out Out Varchar2,
    主任医师_Out Out Varchar2
  ) Is
  Begin
  
    过敏信息_Out := Null;
    主治医师_Out := Null;
    主任医师_Out := Null;
 
    For R In (Select a.信息名, a.信息值
              From 病案主页从表 A
              Where a.病人id = 病人id_In And a.主页id = 主页id_In And a.信息名 In ('主治医师', '主任医师')) Loop
      If r.信息名 = '主治医师' Then
        主治医师_Out := r.信息值;
      Elsif r.信息名 = '主任医师' Then
        主任医师_Out := r.信息值;
      End If;
    End Loop;
  
    For R In (Select a.药物名
              From 病人过敏记录 A, 病人挂号记录 B, 病案主页 C
              Where a.病人id = b.病人id(+) And a.主页id = b.Id(+) And b.记录性质(+) = 1 And b.记录状态(+) = 1 And a.病人id = c.病人id(+) And
                    a.主页id = c.主页id(+) And a.结果 = 1 And 药物名 Is Not Null And a.病人id = 202 And Not Exists
               (Select 药物id
                     From 病人过敏记录
                     Where (Nvl(药物id, 0) = Nvl(a.药物id, 0) Or Nvl(药物名, 'Null') = Nvl(a.药物名, 'Null')) And Nvl(结果, 0) = 0 And
                           记录时间 > a.记录时间 And 病人id = 202)
              Group By a.药物名
              Order By a.药物名) Loop
      过敏信息_Out := 过敏信息_Out || ',' || r.药物名;
    End Loop;
    过敏信息_Out := Substr(过敏信息_Out, 2);
  End;

Begin
  Select Extractvalue(Value(A), 'IN/BQID') As 病区id, Extractvalue(Value(A), 'IN/CYTS') As 天数
  Into n_病区id, n_天数
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  Select Sysdate Into d_结束 From Dual;

  d_开始 := Trunc(d_结束) - n_天数; --当天的 00:00:00  
  d_结束 := Trunc(d_结束) + 1 - 1 / 24 / 60; --当天的 23:59:59

  Select Max(a.名称) Into v_病区 From 部门表 A Where a.Id = n_病区id;

  x_Templet := Xmltype('<OUTPUT></OUTPUT>');
  x_Item    := Xmltype('<PATILIST></PATILIST>');

  For R In c_在院 Loop
    p_Getother(r.病人id, r.主页id, v_过敏信息, v_主治医师, v_主任医师);
    v_Xtmp := '<PATI>';
    v_Xtmp := v_Xtmp || '<JBXX>';
    v_Xtmp := v_Xtmp || '<PATIID>' || r.病人id || '</PATIID>';
    v_Xtmp := v_Xtmp || '<PAGEID>' || r.主页id || '</PAGEID>';
    v_Xtmp := v_Xtmp || '<BABY>' || r.婴儿序号 || '</BABY>';
    v_Xtmp := v_Xtmp || '<XM>' || r.姓名 || '</XM>';
    v_Xtmp := v_Xtmp || '<XB>' || r.性别 || '</XB>';
    v_Xtmp := v_Xtmp || '<NL>' || r.年龄 || '</NL>';
    v_Xtmp := v_Xtmp || '<CSRQ>' || To_Char(r.出生日期, 'yyyy-mm-dd hh24:mi:ss') || '</CSRQ>';
    v_Xtmp := v_Xtmp || '<ZYH>' || r.住院号 || '</ZYH>';
    v_Xtmp := v_Xtmp || '<HY>' || r.婚姻 || '</HY>';
    v_Xtmp := v_Xtmp || '<GJ>' || r.国籍 || '</GJ>';
    v_Xtmp := v_Xtmp || '<MZ>' || r.民族 || '</MZ>';
    v_Xtmp := v_Xtmp || '<XL>' || r.学历 || '</XL>';
    v_Xtmp := v_Xtmp || '<SF>' || r.身份 || '</SF>';
    v_Xtmp := v_Xtmp || '<ZY>' || r.职业 || '</ZY>';
    v_Xtmp := v_Xtmp || '<SFZH>' || r.身份证号 || '</SFZH>';
    v_Xtmp := v_Xtmp || '<FKFS>' || r.付款方式 || '</FKFS>';
    v_Xtmp := v_Xtmp || '<LXFS>' || r.联系方式 || '</LXFS>';
    v_Xtmp := v_Xtmp || '<LXRXM>' || r.联系人姓名 || '</LXRXM>';
    v_Xtmp := v_Xtmp || '<LXRDH>' || r.联系人电话 || '</LXRDH>';
    v_Xtmp := v_Xtmp || '<LXRDZ>' || r.联系人地址 || '</LXRDZ>';
    v_Xtmp := v_Xtmp || '<JTDH>' || r.家庭电话 || '</JTDH>';
    v_Xtmp := v_Xtmp || '<JTDZ>' || r.家庭地址 || '</JTDZ>';
    v_Xtmp := v_Xtmp || '<CSDD>' || r.出生地点 || '</CSDD>';
    v_Xtmp := v_Xtmp || '<GMS>' || v_过敏信息 || '</GMS>'; -- r.过敏史 
    v_Xtmp := v_Xtmp || '</JBXX>';
    v_Xtmp := v_Xtmp || '<ZYXX>';
    v_Xtmp := v_Xtmp || '<RYRQ>' || To_Char(r.入院日期, 'yyyy-mm-dd hh24:mi:ss') || '</RYRQ>';
    v_Xtmp := v_Xtmp || '<RKRQ>' || To_Char(r.入科日期, 'yyyy-mm-dd hh24:mi:ss') || '</RKRQ>';
    v_Xtmp := v_Xtmp || '<CYRQ>' || To_Char(r.出院日期, 'yyyy-mm-dd hh24:mi:ss') || '</CYRQ>';
    v_Xtmp := v_Xtmp || '<ZYTS>' || r.住院天数 || '</ZYTS>';
    v_Xtmp := v_Xtmp || '<RYFS>' || r.入院方式 || '</RYFS>';
    v_Xtmp := v_Xtmp || '<KSID>' || r.科室id || '</KSID>';
    v_Xtmp := v_Xtmp || '<KSMC>' || r.科室名称 || '</KSMC>';
    v_Xtmp := v_Xtmp || '<BQID>' || r.病区id || '</BQID>';
    v_Xtmp := v_Xtmp || '<BQMC>' || r.病区名称 || '</BQMC>';
    v_Xtmp := v_Xtmp || '<CH>' || r.床号 || '</CH>';
    v_Xtmp := v_Xtmp || '<BQ>' || r.病情 || '</BQ>';
    v_Xtmp := v_Xtmp || '<ZZYS>' || v_主治医师 || '</ZZYS>';
    v_Xtmp := v_Xtmp || '<ZRYS>' || v_主任医师 || '</ZRYS>';
    v_Xtmp := v_Xtmp || '<ZYYS>' || r.住院医师 || '</ZYYS>';
    v_Xtmp := v_Xtmp || '<ZRHS>' || r.责任护士 || '</ZRHS>';
    v_Xtmp := v_Xtmp || '<HLDJ>' || r.护理等级 || '</HLDJ>';
    v_Xtmp := v_Xtmp || '<YLZ>' || r.医疗小组id || '</YLZ>';
    v_Xtmp := v_Xtmp || '<YBH>' || r.医保号 || '</YBH>';
    v_Xtmp := v_Xtmp || '<YBMC>' || r.医保名称 || '</YBMC>';
    v_Xtmp := v_Xtmp || '</ZYXX>';
    v_Xtmp := v_Xtmp || '</PATI>';
    Select Appendchildxml(x_Item, '/PATILIST', Xmltype(v_Xtmp)) Into x_Item From Dual;
  End Loop;

  For R In c_出院 Loop
    p_Getother(r.病人id, r.主页id, v_过敏信息, v_主治医师, v_主任医师);
    v_Xtmp := '<PATI>';
    v_Xtmp := v_Xtmp || '<JBXX>';
    v_Xtmp := v_Xtmp || '<PATIID>' || r.病人id || '</PATIID>';
    v_Xtmp := v_Xtmp || '<PAGEID>' || r.主页id || '</PAGEID>';
    v_Xtmp := v_Xtmp || '<BABY>' || r.婴儿序号 || '</BABY>';
    v_Xtmp := v_Xtmp || '<XM>' || r.姓名 || '</XM>';
    v_Xtmp := v_Xtmp || '<XB>' || r.性别 || '</XB>';
    v_Xtmp := v_Xtmp || '<NL>' || r.年龄 || '</NL>';
    v_Xtmp := v_Xtmp || '<CSRQ>' || To_Char(r.出生日期, 'yyyy-mm-dd hh24:mi:ss') || '</CSRQ>';
    v_Xtmp := v_Xtmp || '<ZYH>' || r.住院号 || '</ZYH>';
    v_Xtmp := v_Xtmp || '<HY>' || r.婚姻 || '</HY>';
    v_Xtmp := v_Xtmp || '<GJ>' || r.国籍 || '</GJ>';
    v_Xtmp := v_Xtmp || '<MZ>' || r.民族 || '</MZ>';
    v_Xtmp := v_Xtmp || '<XL>' || r.学历 || '</XL>';
    v_Xtmp := v_Xtmp || '<SF>' || r.身份 || '</SF>';
    v_Xtmp := v_Xtmp || '<ZY>' || r.职业 || '</ZY>';
    v_Xtmp := v_Xtmp || '<SFZH>' || r.身份证号 || '</SFZH>';
    v_Xtmp := v_Xtmp || '<FKFS>' || r.付款方式 || '</FKFS>';
    v_Xtmp := v_Xtmp || '<LXFS>' || r.联系方式 || '</LXFS>';
    v_Xtmp := v_Xtmp || '<LXRXM>' || r.联系人姓名 || '</LXRXM>';
    v_Xtmp := v_Xtmp || '<LXRDH>' || r.联系人电话 || '</LXRDH>';
    v_Xtmp := v_Xtmp || '<LXRDZ>' || r.联系人地址 || '</LXRDZ>';
    v_Xtmp := v_Xtmp || '<JTDH>' || r.家庭电话 || '</JTDH>';
    v_Xtmp := v_Xtmp || '<JTDZ>' || r.家庭地址 || '</JTDZ>';
    v_Xtmp := v_Xtmp || '<CSDD>' || r.出生地点 || '</CSDD>';
    v_Xtmp := v_Xtmp || '<GMS>' || v_过敏信息 || '</GMS>'; -- r.过敏史 
    v_Xtmp := v_Xtmp || '</JBXX>';
    v_Xtmp := v_Xtmp || '<ZYXX>';
    v_Xtmp := v_Xtmp || '<RYRQ>' || To_Char(r.入院日期, 'yyyy-mm-dd hh24:mi:ss') || '</RYRQ>';
    v_Xtmp := v_Xtmp || '<RKRQ>' || To_Char(r.入科日期, 'yyyy-mm-dd hh24:mi:ss') || '</RKRQ>';
    v_Xtmp := v_Xtmp || '<CYRQ>' || To_Char(r.出院日期, 'yyyy-mm-dd hh24:mi:ss') || '</CYRQ>';
    v_Xtmp := v_Xtmp || '<ZYTS>' || r.住院天数 || '</ZYTS>';
    v_Xtmp := v_Xtmp || '<RYFS>' || r.入院方式 || '</RYFS>';
    v_Xtmp := v_Xtmp || '<KSID>' || r.科室id || '</KSID>';
    v_Xtmp := v_Xtmp || '<KSMC>' || r.科室名称 || '</KSMC>';
    v_Xtmp := v_Xtmp || '<BQID>' || r.病区id || '</BQID>';
    v_Xtmp := v_Xtmp || '<BQMC>' || r.病区名称 || '</BQMC>';
    v_Xtmp := v_Xtmp || '<CH>' || r.床号 || '</CH>';
    v_Xtmp := v_Xtmp || '<BQ>' || r.病情 || '</BQ>';
    v_Xtmp := v_Xtmp || '<ZZYS>' || v_主治医师 || '</ZZYS>';
    v_Xtmp := v_Xtmp || '<ZRYS>' || v_主任医师 || '</ZRYS>';
    v_Xtmp := v_Xtmp || '<ZYYS>' || r.住院医师 || '</ZYYS>';
    v_Xtmp := v_Xtmp || '<ZRHS>' || r.责任护士 || '</ZRHS>';
    v_Xtmp := v_Xtmp || '<HLDJ>' || r.护理等级 || '</HLDJ>';
    v_Xtmp := v_Xtmp || '<YLZ>' || r.医疗小组id || '</YLZ>';
    v_Xtmp := v_Xtmp || '<YBH>' || r.医保号 || '</YBH>';
    v_Xtmp := v_Xtmp || '<YBMC>' || r.医保名称 || '</YBMC>';
    v_Xtmp := v_Xtmp || '</ZYXX>';
    v_Xtmp := v_Xtmp || '</PATI>';
    Select Appendchildxml(x_Item, '/PATILIST', Xmltype(v_Xtmp)) Into x_Item From Dual;
  End Loop;

  Select Appendchildxml(x_Templet, '/OUTPUT', x_Item) Into x_Templet From Dual;
  Xml_Out := x_Templet;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getallpatiinfo;
/

--121143:胡俊勇,2018-01-29,移动护理和HIS相关的接口
Create Or Replace Procedure Zl_Third_Getkfcws
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is

  --功能：开放床位数/查询
  --开放床位数：每日夜晚12点开放病床数总和，不论该床是否被病人占用,都应计算在内。包括消毒和小修理等暂停使用的病床，
  --             以及超过半年的加床。不包括因病房扩建或大修而停用的病床及临时增设病床

  --平均开放床位数：每月平均开放床位数=当月每日开放床位数之和/当月天数
  --基于ZLHIS系统数据结构的理解：床位增减记录，中增加的床位记录
  --入参：xml_in
  --<IN>
  --    <BQID></BQID>    //病区ID，传空取所有病区
  --    <KSRQ></KSRQ>  //开始日期   yyyy-mm-dd
  --    <JSRQ></JSRQ>   //结束日期  yyyy-mm-dd
  --</IN>

  --出参：xml_out
  --<OUTPUT>
  --  <BQLIST>
  --    <ITEM>
  --      <BQID></BQID>  //病区ID
  --      <BQMC></BQMC>  //病区名称
  --      <DATALIST>
  --        <ITEM>
  --           <YF></YF>  //月份
  --           <KFCR></KFCR>  //开放床位数
  --        </ITEM>
  --      </DATALIST>
  --    </ITEM>
  --  </BQLIST>
  --</OUTPUT>

  n_病区id   部门表.Id%Type;
  d_开始     Date;
  d_结束     Date;
  v_Xtmp     Varchar(5000);
  x_Tmp      Xmltype;
  x_Templet  Xmltype;
  n_初床位数 病人医嘱记录.Id%Type;
  n_总天数   Number;
  v_病区名称 部门表.名称%Type;

  v_月份   Varchar(30);
  d_Tmp    Date;
  n_开放数 Number;

  Cursor c_Item(病区id_In 部门表.Id%Type) Is
    Select a.病区id, a.天, Sum(a.变动) As 开放床位数
    From (Select a.病区id, a.变动, To_Char(a.日期, 'yyyy-mm-dd') As 天
           From 床位增减记录 A
           Where a.日期 Between d_开始 And d_结束 And a.病区id = 病区id_In) A
    Group By a.病区id, a.天
    Order By a.天;

  Type t_Item Is Table Of c_Item%RowType;
  r_Item t_Item;
Begin
  Select Extractvalue(Value(A), 'IN/BQID') As 病区id,
         To_Date(Extractvalue(Value(A), 'IN/KSRQ'), 'yyyy-mm-dd hh24:mi:ss') As 开始日期,
         To_Date(Extractvalue(Value(A), 'IN/JSRQ'), 'yyyy-mm-dd hh24:mi:ss') As 结束日期
  Into n_病区id, d_开始, d_结束
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  x_Templet := Xmltype('<OUTPUT><BQLIST></BQLIST></OUTPUT>');

  --单个病区
  If Nvl(n_病区id, 0) <> 0 Then
    Select 名称 Into v_病区名称 From 部门表 Where ID = n_病区id;
    Select Nvl(Sum(a.变动), 0) Into n_初床位数 From 床位增减记录 A Where a.病区id = n_病区id And a.日期 < d_开始;
    Open c_Item(n_病区id);
    Fetch c_Item Bulk Collect
      Into r_Item;
    Close c_Item;
    v_Xtmp   := '<ITEM><BQID>' || n_病区id || '</BQID><BQMC>' || v_病区名称 || '</BQMC>';
    v_Xtmp   := v_Xtmp || '<DATALIST></DATALIST></ITEM>';
    x_Tmp    := Xmltype(v_Xtmp);
    n_开放数 := 0;
    d_Tmp    := d_开始;
    v_月份   := '-';
    --循环天数
    While d_Tmp <= d_结束 Loop
      For J In 1 .. r_Item.Count Loop
        If r_Item(J).天 = To_Char(d_Tmp, 'yyyy-mm-dd') Then
          n_初床位数 := n_初床位数 + r_Item(J).开放床位数;
        End If;
      End Loop;
    
      If Substr(To_Char(d_Tmp, 'yyyy-mm-dd'), 1, 7) <> v_月份 Then
        --1.拼接之前的
        If v_月份 <> '-' Then
          n_开放数 := Round(n_开放数 / n_总天数);
          v_Xtmp   := '<ITEM><YF>' || Substr(v_月份, 6, 2) || '</YF><KFCR>' || n_开放数 || '</KFCR></ITEM>';
          Select Appendchildxml(x_Tmp, '/ITEM/DATALIST', Xmltype(v_Xtmp)) Into x_Tmp From Dual;
        End If;
        v_月份 := Substr(To_Char(d_Tmp, 'yyyy-mm-dd'), 1, 7);
        --2.重置
        n_总天数 := 1;
        n_开放数 := n_初床位数;
      Else
        n_总天数 := n_总天数 + 1;
        n_开放数 := n_开放数 + n_初床位数;
      End If;
      d_Tmp := d_Tmp + 1;
    End Loop;
    n_开放数 := Round(n_开放数 / n_总天数);
    v_Xtmp   := '<ITEM><YF>' || Substr(v_月份, 6, 2) || '</YF><KFCR>' || n_开放数 || '</KFCR></ITEM>';
    Select Appendchildxml(x_Tmp, '/ITEM/DATALIST', Xmltype(v_Xtmp)) Into x_Tmp From Dual;
    Select Appendchildxml(x_Templet, '/OUTPUT/BQLIST', x_Tmp) Into x_Templet From Dual;
  Else
    --所有病区  
    For R In (Select a.Id, a.名称, a.编码
              From 部门表 A, 部门性质说明 B
              Where a.Id = b.部门id And b.工作性质 = '护理' And 服务对象 = 2
              Group By a.Id, a.名称, a.编码
              Order By a.编码) Loop
      v_病区名称 := r.名称;
      n_病区id   := r.Id;
    
      Select Nvl(Sum(a.变动), 0) Into n_初床位数 From 床位增减记录 A Where a.病区id = n_病区id And a.日期 < d_开始;
      Open c_Item(n_病区id);
      Fetch c_Item Bulk Collect
        Into r_Item;
      Close c_Item;
    
      v_Xtmp   := '<ITEM><BQID>' || n_病区id || '</BQID><BQMC>' || v_病区名称 || '</BQMC>';
      v_Xtmp   := v_Xtmp || '<DATALIST></DATALIST></ITEM>';
      x_Tmp    := Xmltype(v_Xtmp);
      n_开放数 := 0;
      d_Tmp    := d_开始;
      v_月份   := '-';
      --循环天数
      While d_Tmp <= d_结束 Loop
        For J In 1 .. r_Item.Count Loop
          If r_Item(J).天 = To_Char(d_Tmp, 'yyyy-mm-dd') Then
            n_初床位数 := n_初床位数 + r_Item(J).开放床位数;
          End If;
        End Loop;
      
        If Substr(To_Char(d_Tmp, 'yyyy-mm-dd'), 1, 7) <> v_月份 Then
          --1.拼接之前的
          If v_月份 <> '-' Then
            n_开放数 := Round(n_开放数 / n_总天数);
            v_Xtmp   := '<ITEM><YF>' || Substr(v_月份, 6, 2) || '</YF><KFCR>' || n_开放数 || '</KFCR></ITEM>';
            Select Appendchildxml(x_Tmp, '/ITEM/DATALIST', Xmltype(v_Xtmp)) Into x_Tmp From Dual;
          End If;
          v_月份 := Substr(To_Char(d_Tmp, 'yyyy-mm-dd'), 1, 7);
          --2.重置
          n_总天数 := 1;
          n_开放数 := n_初床位数;
        Else
          n_总天数 := n_总天数 + 1;
          n_开放数 := n_开放数 + n_初床位数;
        End If;
        d_Tmp := d_Tmp + 1;
      End Loop;
      n_开放数 := Round(n_开放数 / n_总天数);
      v_Xtmp   := '<ITEM><YF>' || Substr(v_月份, 6, 2) || '</YF><KFCR>' || n_开放数 || '</KFCR></ITEM>';
      Select Appendchildxml(x_Tmp, '/ITEM/DATALIST', Xmltype(v_Xtmp)) Into x_Tmp From Dual;
      Select Appendchildxml(x_Templet, '/OUTPUT/BQLIST', x_Tmp) Into x_Templet From Dual;
    End Loop;
  End If;
  Xml_Out := x_Templet;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getkfcws;
/

--121143:胡俊勇,2018-01-29,移动护理和HIS相关的接口
Create Or Replace Procedure Zl_Third_Getzyrs
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --功能：住院患者人数/查询
  --入参：Xml_In
  --<IN>
  --  <BQID></BQID>    //病区ID，传空取所有病区
  --  <KSRQ></KSRQ>  //开始日期   yyyy-mm-dd
  --  <JSRQ></JSRQ>   //结束日期  yyyy-mm-dd
  --</IN>
  --出参：xml_out
  --<OUTPUT>
  --  <BQLIST>
  --    <ITEM>
  --      <BQID></BQID>  //病区ID
  --      <BQMC></BQMC>  //病区名称
  --      <DATALIST>
  --        <ITEM>
  --           <YF></YF>  //月份
  --           <QCRS></QCRS>  //期初人数，即开始时间的在院病人数
  --           <XRRS></XRRS>  //新入人数，即时间段内新入病区的人数，包括入院、转入
  --           <XCRS></XCRS>  //新出人数，即时间段内新出病区的人数，包括出院、转出、死亡
  --           <QMRS></QMRS>  //期末人数，即结束时间的在院病人数
  --        </ITEM>
  --      </DATALIST>
  --    </ITEM>
  --  </BQLIST>
  --</OUTPUT>

  n_病区id   病人医嘱记录.执行科室id%Type;
  v_病区名称 部门表.名称%Type;
  v_Xtmp     Varchar(5000); --临时XML
  x_Tmp      Xmltype;
  d_开始     Date;
  d_结束     Date;
  x_Templet  Xmltype;
  d_Tmp      Date;
  n_期初人数 Number;
  n_新入人数 Number;
  n_新出人数 Number;
  n_期末人数 Number;
  d_s        Date;
  d_e        Date;

  v_月份 Varchar(50);

  --病区指定时间点的人数
  Cursor c_当前人数
  (
    时间_In   Date,
    病区id_In 病人医嘱记录.执行科室id%Type
  ) Is
    Select Count(1) As 人数
    From (Select a.病人id, a.主页id
           From (Select a.病人id, a.主页id, a.病区id, a.开始时间
                  From (Select a.病人id, a.主页id, a.病区id, a.开始时间,
                                Row_Number() Over(Partition By a.病人id, a.主页id Order By a.开始时间 Desc) As Top
                         From 病人变动记录 A
                         Where a.开始时间 < 时间_In) A
                  Where Top = 1 And a.病区id = 病区id_In) A, 病案主页 B
           Where a.病人id = b.病人id And a.主页id = b.主页id And b.入院日期 < 时间_In And (b.出院日期 Is Null Or b.出院日期 > 时间_In)
           Group By a.病人id, a.主页id);

  r_当前人数 c_当前人数%RowType;

  Cursor c_入人数
  (
    时间起_In Date,
    时间止_In Date,
    病区id_In 病人医嘱记录.执行科室id%Type
  ) Is
    Select Count(1) As 人数
    From 病人变动记录 A
    Where (a.开始原因 In (2, 3, 15) Or a.开始原因 = 1 And Not Exists
           (Select 1 From 病人变动记录 B Where a.病人id = b.病人id And a.主页id = b.主页id And b.开始原因 = 2)) And a.病区id = 病区id_In And
          a.开始时间 Between 时间起_In And 时间止_In And Nvl(a.附加床位, 0) = 0;
  r_入人数 c_入人数%RowType;

Begin
  Select Extractvalue(Value(A), 'IN/BQID') As 病区id,
         To_Date(Extractvalue(Value(A), 'IN/KSRQ'), 'yyyy-mm-dd hh24:mi:ss') As 开始日期,
         To_Date(Extractvalue(Value(A), 'IN/JSRQ'), 'yyyy-mm-dd hh24:mi:ss') As 结束日期
  Into n_病区id, d_开始, d_结束
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  x_Templet := Xmltype('<OUTPUT><BQLIST></BQLIST></OUTPUT>');

  If Nvl(n_病区id, 0) <> 0 Then
    Select 名称 Into v_病区名称 From 部门表 Where ID = n_病区id;
  
    v_Xtmp := '<ITEM><BQID>' || n_病区id || '</BQID><BQMC>' || v_病区名称 || '</BQMC>';
    v_Xtmp := v_Xtmp || '<DATALIST></DATALIST></ITEM>';
    x_Tmp  := Xmltype(v_Xtmp);
  
    d_Tmp  := d_开始;
    v_月份 := '-';
    d_s    := d_开始;
  
    --循环天数取出每个月份
    While d_Tmp <= d_结束 Loop
      If Substr(To_Char(d_Tmp, 'yyyy-mm-dd'), 1, 7) <> v_月份 Then
        If v_月份 <> '-' Then
        
          d_e := Trunc(d_Tmp) - 1 / 24 / 60;
        
          Open c_当前人数(d_s, n_病区id);
          Fetch c_当前人数
            Into r_当前人数;
          If c_当前人数%RowCount = 0 Then
            n_期初人数 := 0;
          Else
            n_期初人数 := r_当前人数.人数;
          End If;
          Close c_当前人数;
        
          Open c_当前人数(d_e, n_病区id);
          Fetch c_当前人数
            Into r_当前人数;
          If c_当前人数%RowCount = 0 Then
            n_期末人数 := 0;
          Else
            n_期末人数 := r_当前人数.人数;
          End If;
          Close c_当前人数;
        
          Open c_入人数(d_s, d_e, n_病区id);
          Fetch c_入人数
            Into r_入人数;
          If c_入人数%RowCount = 0 Then
            n_新入人数 := 0;
          Else
            n_新入人数 := r_入人数.人数;
          End If;
          Close c_入人数;
        
          n_新出人数 := n_新入人数 + n_期初人数 - n_期末人数;
        
          v_Xtmp := '<ITEM><YF>' || Substr(v_月份, 6, 2) || '</YF><QCRS>' || n_期初人数 || '</QCRS><XRRS>' || n_新入人数 ||
                    '</XRRS><XCRS>' || n_新出人数 || '</XCRS><QMRS>' || n_期末人数 || '</QMRS></ITEM>';
          Select Appendchildxml(x_Tmp, '/ITEM/DATALIST', Xmltype(v_Xtmp)) Into x_Tmp From Dual;
        
        End If;
        v_月份 := Substr(To_Char(d_Tmp, 'yyyy-mm-dd'), 1, 7);
        d_s    := d_Tmp;
      
      End If;
      d_Tmp := d_Tmp + 1;
    End Loop;
  
    d_e := d_结束;
  
    Open c_当前人数(d_s, n_病区id);
    Fetch c_当前人数
      Into r_当前人数;
    If c_当前人数%RowCount = 0 Then
      n_期初人数 := 0;
    Else
      n_期初人数 := r_当前人数.人数;
    End If;
    Close c_当前人数;
  
    Open c_当前人数(d_e, n_病区id);
    Fetch c_当前人数
      Into r_当前人数;
    If c_当前人数%RowCount = 0 Then
      n_期末人数 := 0;
    Else
      n_期末人数 := r_当前人数.人数;
    End If;
    Close c_当前人数;
  
    Open c_入人数(d_s, d_e, n_病区id);
    Fetch c_入人数
      Into r_入人数;
    If c_入人数%RowCount = 0 Then
      n_新入人数 := 0;
    Else
      n_新入人数 := r_入人数.人数;
    End If;
    Close c_入人数;
  
    n_新出人数 := n_新入人数 + n_期初人数 - n_期末人数;
  
    v_Xtmp := '<ITEM><YF>' || Substr(v_月份, 6, 2) || '</YF><QCRS>' || n_期初人数 || '</QCRS><XRRS>' || n_新入人数 ||
              '</XRRS><XCRS>' || n_新出人数 || '</XCRS><QMRS>' || n_期末人数 || '</QMRS></ITEM>';
    Select Appendchildxml(x_Tmp, '/ITEM/DATALIST', Xmltype(v_Xtmp)) Into x_Tmp From Dual;
    If x_Tmp Is Not Null Then
      Select Appendchildxml(x_Templet, '/OUTPUT/BQLIST', x_Tmp) Into x_Templet From Dual;
    End If;
  Else
    --所有病区
    For R In (Select a.Id, a.名称, a.编码
              From 部门表 A, 部门性质说明 B
              Where a.Id = b.部门id And b.工作性质 = '护理' And 服务对象 = 2
              Group By a.Id, a.名称, a.编码
              Order By a.编码) Loop
      v_病区名称 := r.名称;
      n_病区id   := r.Id;
    
      v_Xtmp := '<ITEM><BQID>' || n_病区id || '</BQID><BQMC>' || v_病区名称 || '</BQMC>';
      v_Xtmp := v_Xtmp || '<DATALIST></DATALIST></ITEM>';
      x_Tmp  := Xmltype(v_Xtmp);
    
      d_Tmp  := d_开始;
      v_月份 := '-';
      d_s    := d_开始;
    
      --循环天数取出每个月份
      While d_Tmp <= d_结束 Loop
        If Substr(To_Char(d_Tmp, 'yyyy-mm-dd'), 1, 7) <> v_月份 Then
          If v_月份 <> '-' Then
          
            d_e := Trunc(d_Tmp) - 1 / 24 / 60;
          
            Open c_当前人数(d_s, n_病区id);
            Fetch c_当前人数
              Into r_当前人数;
            If c_当前人数%RowCount = 0 Then
              n_期初人数 := 0;
            Else
              n_期初人数 := r_当前人数.人数;
            End If;
            Close c_当前人数;
          
            Open c_当前人数(d_e, n_病区id);
            Fetch c_当前人数
              Into r_当前人数;
            If c_当前人数%RowCount = 0 Then
              n_期末人数 := 0;
            Else
              n_期末人数 := r_当前人数.人数;
            End If;
            Close c_当前人数;
          
            Open c_入人数(d_s, d_e, n_病区id);
            Fetch c_入人数
              Into r_入人数;
            If c_入人数%RowCount = 0 Then
              n_新入人数 := 0;
            Else
              n_新入人数 := r_入人数.人数;
            End If;
            Close c_入人数;
          
            n_新出人数 := n_新入人数 + n_期初人数 - n_期末人数;
          
            v_Xtmp := '<ITEM><YF>' || Substr(v_月份, 6, 2) || '</YF><QCRS>' || n_期初人数 || '</QCRS><XRRS>' || n_新入人数 ||
                      '</XRRS><XCRS>' || n_新出人数 || '</XCRS><QMRS>' || n_期末人数 || '</QMRS></ITEM>';
            Select Appendchildxml(x_Tmp, '/ITEM/DATALIST', Xmltype(v_Xtmp)) Into x_Tmp From Dual;
          
          End If;
          v_月份 := Substr(To_Char(d_Tmp, 'yyyy-mm-dd'), 1, 7);
          d_s    := d_Tmp;
        
        End If;
        d_Tmp := d_Tmp + 1;
      End Loop;
    
      d_e := d_结束;
    
      Open c_当前人数(d_s, n_病区id);
      Fetch c_当前人数
        Into r_当前人数;
      If c_当前人数%RowCount = 0 Then
        n_期初人数 := 0;
      Else
        n_期初人数 := r_当前人数.人数;
      End If;
      Close c_当前人数;
    
      Open c_当前人数(d_e, n_病区id);
      Fetch c_当前人数
        Into r_当前人数;
      If c_当前人数%RowCount = 0 Then
        n_期末人数 := 0;
      Else
        n_期末人数 := r_当前人数.人数;
      End If;
      Close c_当前人数;
    
      Open c_入人数(d_s, d_e, n_病区id);
      Fetch c_入人数
        Into r_入人数;
      If c_入人数%RowCount = 0 Then
        n_新入人数 := 0;
      Else
        n_新入人数 := r_入人数.人数;
      End If;
      Close c_入人数;
    
      n_新出人数 := n_新入人数 + n_期初人数 - n_期末人数;
    
      v_Xtmp := '<ITEM><YF>' || Substr(v_月份, 6, 2) || '</YF><QCRS>' || n_期初人数 || '</QCRS><XRRS>' || n_新入人数 ||
                '</XRRS><XCRS>' || n_新出人数 || '</XCRS><QMRS>' || n_期末人数 || '</QMRS></ITEM>';
      Select Appendchildxml(x_Tmp, '/ITEM/DATALIST', Xmltype(v_Xtmp)) Into x_Tmp From Dual;
      If x_Tmp Is Not Null Then
        Select Appendchildxml(x_Templet, '/OUTPUT/BQLIST', x_Tmp) Into x_Templet From Dual;
      End If;
    End Loop;
  End If;
  Xml_Out := x_Templet;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getzyrs;
/

--121143:胡俊勇,2018-01-29,移动护理和HIS相关的接口
CREATE OR REPLACE Procedure Zl_Third_Getzycws
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --功能：实际占用床日数/查询
  --实际占用总床日数：指每日夜晚12点实际占用病床数(即每日夜晚12点住院人数)总和。
  --                   包括实际占用的临时加床在内。病人入院后于当晚12点前死亡或因故出院的病人, 作为实际占用床位1天进行统计
  --入参：Xml_In
  --<IN>
  --    <BQID></BQID>    //病区ID，传空取所有病区
  --    <KSRQ></KSRQ>    //开始日期   yyyy-mm-dd
  --    <JSRQ></JSRQ>    //结束日期  yyyy-mm-dd
  --</IN>

  --出参：xml_out
  --<OUTPUT>
  --  <BQLIST>
  --    <ITEM>
  --      <BQID></BQID>  //病区ID
  --      <BQMC></BQMC>  //病区名称
  --      <DATALIST>
  --        <ITEM>
  --           <YF></YF>  //月份
  --           <ZYCR></ZYCR>  //实际占用床日数
  --        </ITEM>
  --      </DATALIST>
  --    </ITEM>
  --  </BQLIST>
  --</OUTPUT>
  n_病区id     部门表.Id%Type;
  v_病区名称   部门表.名称%Type;
  d_开始       Date;
  d_结束       Date;
  v_Xtmp       Varchar(5000); --临时XML
  x_Tmp        Xmltype;
  x_Templet    Xmltype;
  n_床日数     Number; --病人住院天数之和
  n_病人床日数 Number;
  n_病区床日数 Number(18);
  v_月份       Varchar2(50);
  d_Tmp        Date;
  v_Pre病人    Varchar2(100);
  n_Index      Number;
  d_s          Date;
  d_e          Date;

  d_天数起    Date;
  d_天数止    Date;
  d_Pre天数止 Date;

  Cursor c_Item
  (
    时间起_In Date,
    时间止_In Date,
    病区id_In 病人医嘱记录.执行科室id%Type
  ) Is
    Select Case
             When 终止原因 = 1 And 开始原因 In (1, 2, 3, 15) And 病区id = 病区id_In Then
              '转入加转出'
             When 终止原因 = 1 Or 开始原因 In (3, 15) And 病区id <> 病区id_In Then
              '转出'
             Else
              '转入'
           End As 类型, 病人id, 主页id, Trunc(开始时间) AS 开始时间, Trunc(终止时间) AS 终止时间, 病区id, 开始原因, 终止原因
    From (Select a.病人id, a.主页id,
                  Case
                    When Trunc(a.开始时间) < 时间起_In Then
                     时间起_In
                    Else
                     a.开始时间
                  End As 开始时间,
                  Case
                    When Trunc(a.终止时间) > 时间止_In Then
                     时间止_In
                    Else
                     a.终止时间
                  End As 终止时间, a.病区id, a.开始原因, a.终止原因
           From 病人变动记录 A
           Where a.开始时间 Between 时间起_In And 时间止_In And Exists
            (Select 1 From 病人变动记录 B Where a.病人id = b.病人id And a.主页id = b.主页id And b.病区id = 病区id_In) And
                 ((((a.开始原因 = 2 Or a.开始原因 = 1 And Not Exists
                  (Select 1 From 病人变动记录 C Where a.病人id = c.病人id And a.主页id = c.主页id And c.开始原因 = 2)) And a.病区id = 病区id_In Or
                 a.开始原因 In (3, 15))) Or a.终止原因 = 1) And Nvl(a.附加床位, 0) = 0
           Union All
           Select a.病人id, a.主页id,
                  Case
                    When Trunc(a.开始时间) < 时间起_In Then
                     时间起_In
                    Else
                     a.开始时间
                  End As 开始时间,
                  Case
                    When Trunc(a.终止时间) > 时间止_In Then
                     时间止_In
                    Else
                     a.终止时间
                  End As 终止时间, a.病区id, a.开始原因, a.终止原因
           From 病人变动记录 A
           Where a.开始时间 < 时间起_In And a.病区id = 病区id_In And
                 ((a.开始原因 = 2 Or a.开始原因 = 1 And Not Exists
                  (Select 1 From 病人变动记录 C Where a.病人id = c.病人id And a.主页id = c.主页id And c.开始原因 = 2)) And a.病区id = 病区id_In) And
                 Nvl(a.附加床位, 0) = 0 And Not Exists
            (Select 1
                  From 病人变动记录 B
                  Where a.病人id = b.病人id And a.主页id = b.主页id And b.开始时间 < 时间止_In And
                        (b.开始原因 In (3, 15) And b.病区id <> 病区id_In Or b.终止原因 = 1 And 病区id = 病区id_In)))
    Order By 病人id, 主页id, 开始时间, 终止时间;

  Type t_Item Is Table Of c_Item%RowType;
  r_Item t_Item;
Begin

  Select Extractvalue(Value(A), 'IN/BQID') As 病区id,
         To_Date(Extractvalue(Value(A), 'IN/KSRQ'), 'yyyy-mm-dd hh24:mi:ss') As 开始日期,
         To_Date(Extractvalue(Value(A), 'IN/JSRQ'), 'yyyy-mm-dd hh24:mi:ss') As 结束日期
  Into n_病区id, d_开始, d_结束
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  x_Templet := Xmltype('<OUTPUT><BQLIST></BQLIST></OUTPUT>');

  If Nvl(n_病区id, 0) <> 0 Then
    Select 名称 Into v_病区名称 From 部门表 Where ID = n_病区id;
    v_Xtmp   := '<ITEM><BQID>' || n_病区id || '</BQID><BQMC>' || v_病区名称 || '</BQMC>';
    v_Xtmp   := v_Xtmp || '<DATALIST></DATALIST></ITEM>';
    x_Tmp    := Xmltype(v_Xtmp);
    d_Tmp    := d_开始;
    v_月份   := '-';
    d_s      := d_开始;
    n_床日数 := 0;

    --循环天数取出每个月份
    While d_Tmp <= d_结束 Loop
      If Substr(To_Char(d_Tmp, 'yyyy-mm-dd'), 1, 7) <> v_月份 Then
        If v_月份 <> '-' Then
          d_e       := Trunc(d_Tmp) - 1 / 24 / 60;
          n_床日数  := 0;
          v_Pre病人 := '-';
          Open c_Item(d_s, d_e, n_病区id);
          Fetch c_Item Bulk Collect
            Into r_Item;
          Close c_Item;
          n_病区床日数 := 0;
          For I In 1 .. r_Item.Count Loop
            If r_Item(I).病人id || '_' || r_Item(I).主页id <> v_Pre病人 Or v_Pre病人 = '-' Then
              --新病人开始
              If r_Item(I).类型 = '转入加转出' Then
                d_天数起 := r_Item(I).开始时间;
                d_天数止 := r_Item(I).终止时间;
                If (d_天数止 - d_天数起)=0 Then
                  n_病人床日数 :=1;
                Else
                  n_病人床日数 :=(d_天数止 - d_天数起);
                End If;
                n_病区床日数 := n_病区床日数 + n_病人床日数 ;
              Elsif r_Item(I).类型 = '转入' Then
                If I >=r_Item.Count Then
                  d_天数起 := r_Item(I).开始时间;
                  d_天数止 := Trunc(d_e);
                  If (d_天数止 - d_天数起)=0 Then
                    n_病人床日数 :=1;
                  Else
                    n_病人床日数 :=(d_天数止 - d_天数起);
                  End If;
                  n_病区床日数 := n_病区床日数 + n_病人床日数 ;
                Else
                  If r_Item(I+1).类型 = '转出' And r_Item(I+1).病人id || '_' || r_Item(I+1).主页id = r_Item(I).病人id || '_' || r_Item(I).主页id Then
                     d_天数起 := r_Item(I).开始时间;
                     d_天数止 := r_Item(I+1).开始时间;
                     If (d_天数止 - d_天数起)=0 Then
                       n_病人床日数 :=1;
                     Else
                       n_病人床日数 :=(d_天数止 - d_天数起);
                     End If;
                     n_病区床日数 := n_病区床日数 + n_病人床日数 ;
                  Else
                     d_天数起 := r_Item(I).开始时间;
                     d_天数止 := Trunc(d_e);
                     If (d_天数止 - d_天数起)=0 Then
                       n_病人床日数 :=1;
                     Else
                       n_病人床日数 :=(d_天数止 - d_天数起);
                     End If;
                     n_病区床日数 := n_病区床日数 + n_病人床日数 ;
                  End If;
                End If;
              Elsif r_Item(I).类型 = '转出' Then
                d_天数起 := Trunc(d_s);
                If NVL(r_Item(I).终止原因,0) = 1 then
                   d_天数止 := r_Item(I).终止时间;
                Else
                  d_天数止 := r_Item(I).开始时间;
                End If;
                If (d_天数止 - d_天数起)=0 Then
                  n_病人床日数 :=1;
                Else
                  n_病人床日数 :=(d_天数止 - d_天数起);
                End If;
                n_病区床日数 := n_病区床日数 + n_病人床日数 ;
              End If;
            Else
              If r_Item(I).类型 = '转入加转出' Then
                --如果上一个起始时间和这次的起始时间相同，则减一，例如：一天内在同一个科室转了多次；
                if d_天数起 = r_Item(I).开始时间 Then
                  n_病区床日数 := n_病区床日数 - 1;
                End If;
                d_天数起 := r_Item(I).开始时间;
                d_天数止 := r_Item(I).终止时间;
                If (d_天数止 - d_天数起)=0 Then
                  n_病人床日数 :=1;
                Else
                  n_病人床日数 :=(d_天数止 - d_天数起);
                End If;
                n_病区床日数 := n_病区床日数 + n_病人床日数 ;
              Elsif r_Item(I).类型 = '转入' Then
                --如果上一个起始时间和这次的起始时间相同，则减一，例如：一天内在同一个科室转了多次；
                if d_天数起 = r_Item(I).开始时间 Then
                  n_病区床日数 := n_病区床日数 - 1;
                End If;
                If I >=r_Item.Count Then
                  d_天数起 := r_Item(I).开始时间;
                  d_天数止 := Trunc(d_e);
                  If (d_天数止 - d_天数起)=0 Then
                    n_病人床日数 :=1;
                  Else
                    n_病人床日数 :=(d_天数止 - d_天数起);
                  End If;
                  n_病区床日数 := n_病区床日数 + n_病人床日数 ;
                Else
                  If r_Item(I+1).类型 = '转出' And r_Item(I+1).病人id || '_' || r_Item(I+1).主页id = r_Item(I).病人id || '_' || r_Item(I).主页id Then
                     d_天数起 := r_Item(I).开始时间;
                     d_天数止 := r_Item(I+1).开始时间;
                     If (d_天数止 - d_天数起)=0 Then
                       n_病人床日数 :=1;
                     Else
                       n_病人床日数 :=(d_天数止 - d_天数起);
                     End If;
                     n_病区床日数 := n_病区床日数 + n_病人床日数 ;
                  Else
                     d_天数起 := r_Item(I).开始时间;
                     d_天数止 := Trunc(d_e);
                     If (d_天数止 - d_天数起)=0 Then
                       n_病人床日数 :=1;
                     Else
                       n_病人床日数 :=(d_天数止 - d_天数起);
                     End If;
                     n_病区床日数 := n_病区床日数 + n_病人床日数 ;
                  End If;
                End If;
              End If;
            End If;
            v_Pre病人 := r_Item(I).病人id || '_' || r_Item(I).主页id;
          End Loop;
          v_Xtmp := '<ITEM><YF>' || Substr(v_月份, 6, 2) || '</YF><ZYCR>' || n_病区床日数 || '</ZYCR></ITEM>';
          Select Appendchildxml(x_Tmp, '/ITEM/DATALIST', Xmltype(v_Xtmp)) Into x_Tmp From Dual;
        End If;
        v_月份 := Substr(To_Char(d_Tmp, 'yyyy-mm-dd'), 1, 7);
        d_s    := d_Tmp;
      End If;
      d_Tmp := d_Tmp + 1;
    End Loop;

    d_e       := d_结束;
    n_床日数  := 0;
    v_Pre病人 := '-';
    Open c_Item(d_s, d_e, n_病区id);
    Fetch c_Item Bulk Collect
      Into r_Item;
    Close c_Item;
    n_病区床日数 := 0;
    For I In 1 .. r_Item.Count Loop
      If r_Item(I).病人id || '_' || r_Item(I).主页id <> v_Pre病人 Or v_Pre病人 = '-' Then
        --新病人开始
        If r_Item(I).类型 = '转入加转出' Then
          d_天数起 := r_Item(I).开始时间;
          d_天数止 := r_Item(I).终止时间;
          If (d_天数止 - d_天数起)=0 Then
            n_病人床日数 :=1;
          Else
            n_病人床日数 :=(d_天数止 - d_天数起);
          End If;
          n_病区床日数 := n_病区床日数 + n_病人床日数 ;
        Elsif r_Item(I).类型 = '转入' Then
          If I >=r_Item.Count Then
            d_天数起 := r_Item(I).开始时间;
            d_天数止 := Trunc(d_e);
            If (d_天数止 - d_天数起)=0 Then
              n_病人床日数 :=1;
            Else
              n_病人床日数 :=(d_天数止 - d_天数起);
            End If;
            n_病区床日数 := n_病区床日数 + n_病人床日数 ;
          Else
            If r_Item(I+1).类型 = '转出' And r_Item(I+1).病人id || '_' || r_Item(I+1).主页id = r_Item(I).病人id || '_' || r_Item(I).主页id Then
               d_天数起 := r_Item(I).开始时间;
               d_天数止 := r_Item(I+1).开始时间;
               If (d_天数止 - d_天数起)=0 Then
                 n_病人床日数 :=1;
               Else
                 n_病人床日数 :=(d_天数止 - d_天数起);
               End If;
               n_病区床日数 := n_病区床日数 + n_病人床日数 ;
            Else
               d_天数起 := r_Item(I).开始时间;
               d_天数止 := Trunc(d_e);
               If (d_天数止 - d_天数起)=0 Then
                 n_病人床日数 :=1;
               Else
                 n_病人床日数 :=(d_天数止 - d_天数起);
               End If;
               n_病区床日数 := n_病区床日数 + n_病人床日数 ;
            End If;
          End If;
        Elsif r_Item(I).类型 = '转出' Then
          d_天数起 := Trunc(d_s);
          If NVL(r_Item(I).终止原因,0) = 1 then
             d_天数止 := r_Item(I).终止时间;
          Else
            d_天数止 := r_Item(I).开始时间;
          End If;
          If (d_天数止 - d_天数起)=0 Then
            n_病人床日数 :=1;
          Else
            n_病人床日数 :=(d_天数止 - d_天数起);
          End If;
          n_病区床日数 := n_病区床日数 + n_病人床日数 ;
        End If;
      Else
        If r_Item(I).类型 = '转入加转出' Then
          --如果上一个起始时间和这次的起始时间相同，则减一，例如：一天内在同一个科室转了多次；
          if d_天数起 = r_Item(I).开始时间 Then
            n_病区床日数 := n_病区床日数 - 1;
          End If;
          d_天数起 := r_Item(I).开始时间;
          d_天数止 := r_Item(I).终止时间;
          If (d_天数止 - d_天数起)=0 Then
            n_病人床日数 :=1;
          Else
            n_病人床日数 :=(d_天数止 - d_天数起);
          End If;
          n_病区床日数 := n_病区床日数 + n_病人床日数 ;
        Elsif r_Item(I).类型 = '转入' Then
          --如果上一个起始时间和这次的起始时间相同，则减一，例如：一天内在同一个科室转了多次；
          if d_天数起 = r_Item(I).开始时间 Then
            n_病区床日数 := n_病区床日数 - 1;
          End If;
          If I >=r_Item.Count Then
            d_天数起 := r_Item(I).开始时间;
            d_天数止 := Trunc(d_e);
            If (d_天数止 - d_天数起)=0 Then
              n_病人床日数 :=1;
            Else
              n_病人床日数 :=(d_天数止 - d_天数起);
            End If;
            n_病区床日数 := n_病区床日数 + n_病人床日数 ;
          Else
            If r_Item(I+1).类型 = '转出' And r_Item(I+1).病人id || '_' || r_Item(I+1).主页id = r_Item(I).病人id || '_' || r_Item(I).主页id Then
               d_天数起 := r_Item(I).开始时间;
               d_天数止 := r_Item(I+1).开始时间;
               If (d_天数止 - d_天数起)=0 Then
                 n_病人床日数 :=1;
               Else
                 n_病人床日数 :=(d_天数止 - d_天数起);
               End If;
               n_病区床日数 := n_病区床日数 + n_病人床日数 ;
            Else
               d_天数起 := r_Item(I).开始时间;
               d_天数止 := Trunc(d_e);
               If (d_天数止 - d_天数起)=0 Then
                 n_病人床日数 :=1;
               Else
                 n_病人床日数 :=(d_天数止 - d_天数起);
               End If;
               n_病区床日数 := n_病区床日数 + n_病人床日数 ;
            End If;
          End If;
        End If;
      End If;
      v_Pre病人 := r_Item(I).病人id || '_' || r_Item(I).主页id;
    End Loop;
    v_Xtmp := '<ITEM><YF>' || Substr(v_月份, 6, 2) || '</YF><ZYCR>' || n_病区床日数 || '</ZYCR></ITEM>';
    Select Appendchildxml(x_Tmp, '/ITEM/DATALIST', Xmltype(v_Xtmp)) Into x_Tmp From Dual;
    If x_Tmp Is Not Null Then
      Select Appendchildxml(x_Templet, '/OUTPUT/BQLIST', x_Tmp) Into x_Templet From Dual;
    End If;
  Else
    --所有病区
    For R In (Select a.Id, a.名称, a.编码
              From 部门表 A, 部门性质说明 B
              Where a.Id = b.部门id And b.工作性质 = '护理' And 服务对象 = 2
              Group By a.Id, a.名称, a.编码
              Order By a.编码) Loop
      v_病区名称 := r.名称;
      n_病区id   := r.Id;

      v_Xtmp   := '<ITEM><BQID>' || n_病区id || '</BQID><BQMC>' || v_病区名称 || '</BQMC>';
      v_Xtmp   := v_Xtmp || '<DATALIST></DATALIST></ITEM>';
      x_Tmp    := Xmltype(v_Xtmp);
      d_Tmp    := d_开始;
      v_月份   := '-';
      d_s      := d_开始;
      n_床日数 := 0;

      --循环天数取出每个月份
      While d_Tmp <= d_结束 Loop
        If Substr(To_Char(d_Tmp, 'yyyy-mm-dd'), 1, 7) <> v_月份 Then
          If v_月份 <> '-' Then
            d_e       := Trunc(d_Tmp) - 1 / 24 / 60;
            n_床日数  := 0;
            v_Pre病人 := '-';
            Open c_Item(d_s, d_e, n_病区id);
            Fetch c_Item Bulk Collect
              Into r_Item;
            Close c_Item;
            n_病区床日数 := 0;
            For I In 1 .. r_Item.Count Loop
              If r_Item(I).病人id || '_' || r_Item(I).主页id <> v_Pre病人 Or v_Pre病人 = '-' Then
                --新病人开始
                If r_Item(I).类型 = '转入加转出' Then
                  d_天数起 := r_Item(I).开始时间;
                  d_天数止 := r_Item(I).终止时间;
                  If (d_天数止 - d_天数起)=0 Then
                    n_病人床日数 :=1;
                  Else
                    n_病人床日数 :=(d_天数止 - d_天数起);
                  End If;
                  n_病区床日数 := n_病区床日数 + n_病人床日数 ;
                Elsif r_Item(I).类型 = '转入' Then
                  If I >=r_Item.Count Then
                    d_天数起 := r_Item(I).开始时间;
                    d_天数止 := Trunc(d_e);
                    If (d_天数止 - d_天数起)=0 Then
                      n_病人床日数 :=1;
                    Else
                      n_病人床日数 :=(d_天数止 - d_天数起);
                    End If;
                    n_病区床日数 := n_病区床日数 + n_病人床日数 ;
                  Else
                    If r_Item(I+1).类型 = '转出' And r_Item(I+1).病人id || '_' || r_Item(I+1).主页id = r_Item(I).病人id || '_' || r_Item(I).主页id Then
                       d_天数起 := r_Item(I).开始时间;
                       d_天数止 := r_Item(I+1).开始时间;
                       If (d_天数止 - d_天数起)=0 Then
                         n_病人床日数 :=1;
                       Else
                         n_病人床日数 :=(d_天数止 - d_天数起);
                       End If;
                       n_病区床日数 := n_病区床日数 + n_病人床日数 ;
                    Else
                       d_天数起 := r_Item(I).开始时间;
                       d_天数止 := Trunc(d_e);
                       If (d_天数止 - d_天数起)=0 Then
                         n_病人床日数 :=1;
                       Else
                         n_病人床日数 :=(d_天数止 - d_天数起);
                       End If;
                       n_病区床日数 := n_病区床日数 + n_病人床日数 ;
                    End If;
                  End If;
                Elsif r_Item(I).类型 = '转出' Then
                  d_天数起 := Trunc(d_s);
                  If NVL(r_Item(I).终止原因,0) = 1 then
                     d_天数止 := r_Item(I).终止时间;
                  Else
                    d_天数止 := r_Item(I).开始时间;
                  End If;
                  If (d_天数止 - d_天数起)=0 Then
                    n_病人床日数 :=1;
                  Else
                    n_病人床日数 :=(d_天数止 - d_天数起);
                  End If;
                  n_病区床日数 := n_病区床日数 + n_病人床日数 ;
                End If;
              Else
                If r_Item(I).类型 = '转入加转出' Then
                  --如果上一个起始时间和这次的起始时间相同，则减一，例如：一天内在同一个科室转了多次；
                  if d_天数起 = r_Item(I).开始时间 Then
                    n_病区床日数 := n_病区床日数 - 1;
                  End If;
                  d_天数起 := r_Item(I).开始时间;
                  d_天数止 := r_Item(I).终止时间;
                  If (d_天数止 - d_天数起)=0 Then
                    n_病人床日数 :=1;
                  Else
                    n_病人床日数 :=(d_天数止 - d_天数起);
                  End If;
                  n_病区床日数 := n_病区床日数 + n_病人床日数 ;
                Elsif r_Item(I).类型 = '转入' Then
                  --如果上一个起始时间和这次的起始时间相同，则减一，例如：一天内在同一个科室转了多次；
                  if d_天数起 = r_Item(I).开始时间 Then
                    n_病区床日数 := n_病区床日数 - 1;
                  End If;
                  If I >=r_Item.Count Then
                    d_天数起 := r_Item(I).开始时间;
                    d_天数止 := Trunc(d_e);
                    If (d_天数止 - d_天数起)=0 Then
                      n_病人床日数 :=1;
                    Else
                      n_病人床日数 :=(d_天数止 - d_天数起);
                    End If;
                    n_病区床日数 := n_病区床日数 + n_病人床日数 ;
                  Else
                    If r_Item(I+1).类型 = '转出' And r_Item(I+1).病人id || '_' || r_Item(I+1).主页id = r_Item(I).病人id || '_' || r_Item(I).主页id Then
                       d_天数起 := r_Item(I).开始时间;
                       d_天数止 := r_Item(I+1).开始时间;
                       If (d_天数止 - d_天数起)=0 Then
                         n_病人床日数 :=1;
                       Else
                         n_病人床日数 :=(d_天数止 - d_天数起);
                       End If;
                       n_病区床日数 := n_病区床日数 + n_病人床日数 ;
                    Else
                       d_天数起 := r_Item(I).开始时间;
                       d_天数止 := Trunc(d_e);
                       If (d_天数止 - d_天数起)=0 Then
                         n_病人床日数 :=1;
                       Else
                         n_病人床日数 :=(d_天数止 - d_天数起);
                       End If;
                       n_病区床日数 := n_病区床日数 + n_病人床日数 ;
                    End If;
                  End If;
                End If;
              End If;
              v_Pre病人 := r_Item(I).病人id || '_' || r_Item(I).主页id;
            End Loop;
            v_Xtmp := '<ITEM><YF>' || Substr(v_月份, 6, 2) || '</YF><ZYCR>' || n_病区床日数 || '</ZYCR></ITEM>';
            Select Appendchildxml(x_Tmp, '/ITEM/DATALIST', Xmltype(v_Xtmp)) Into x_Tmp From Dual;
          End If;
          v_月份 := Substr(To_Char(d_Tmp, 'yyyy-mm-dd'), 1, 7);
          d_s    := d_Tmp;
        End If;
        d_Tmp := d_Tmp + 1;
      End Loop;

      d_e       := d_结束;
      n_床日数  := 0;
      v_Pre病人 := '-';
      Open c_Item(d_s, d_e, n_病区id);
      Fetch c_Item Bulk Collect
        Into r_Item;
      Close c_Item;
      n_病区床日数 := 0;
      For I In 1 .. r_Item.Count Loop
        If r_Item(I).病人id || '_' || r_Item(I).主页id <> v_Pre病人 Or v_Pre病人 = '-' Then
          --新病人开始
          If r_Item(I).类型 = '转入加转出' Then
            d_天数起 := r_Item(I).开始时间;
            d_天数止 := r_Item(I).终止时间;
            If (d_天数止 - d_天数起)=0 Then
              n_病人床日数 :=1;
            Else
              n_病人床日数 :=(d_天数止 - d_天数起);
            End If;
            n_病区床日数 := n_病区床日数 + n_病人床日数 ;
          Elsif r_Item(I).类型 = '转入' Then
            If I >=r_Item.Count Then
              d_天数起 := r_Item(I).开始时间;
              d_天数止 := Trunc(d_e);
              If (d_天数止 - d_天数起)=0 Then
                n_病人床日数 :=1;
              Else
                n_病人床日数 :=(d_天数止 - d_天数起);
              End If;
              n_病区床日数 := n_病区床日数 + n_病人床日数 ;
            Else
              If r_Item(I+1).类型 = '转出' And r_Item(I+1).病人id || '_' || r_Item(I+1).主页id = r_Item(I).病人id || '_' || r_Item(I).主页id Then
                 d_天数起 := r_Item(I).开始时间;
                 d_天数止 := r_Item(I+1).开始时间;
                 If (d_天数止 - d_天数起)=0 Then
                   n_病人床日数 :=1;
                 Else
                   n_病人床日数 :=(d_天数止 - d_天数起);
                 End If;
                 n_病区床日数 := n_病区床日数 + n_病人床日数 ;
              Else
                 d_天数起 := r_Item(I).开始时间;
                 d_天数止 := Trunc(d_e);
                 If (d_天数止 - d_天数起)=0 Then
                   n_病人床日数 :=1;
                 Else
                   n_病人床日数 :=(d_天数止 - d_天数起);
                 End If;
                 n_病区床日数 := n_病区床日数 + n_病人床日数 ;
              End If;
            End If;
          Elsif r_Item(I).类型 = '转出' Then
            d_天数起 := Trunc(d_s);
            If NVL(r_Item(I).终止原因,0) = 1 then
               d_天数止 := r_Item(I).终止时间;
            Else
              d_天数止 := r_Item(I).开始时间;
            End If;
            If (d_天数止 - d_天数起)=0 Then
              n_病人床日数 :=1;
            Else
              n_病人床日数 :=(d_天数止 - d_天数起);
            End If;
            n_病区床日数 := n_病区床日数 + n_病人床日数 ;
          End If;
        Else
          If r_Item(I).类型 = '转入加转出' Then
            --如果上一个起始时间和这次的起始时间相同，则减一，例如：一天内在同一个科室转了多次；
            if d_天数起 = r_Item(I).开始时间 Then
              n_病区床日数 := n_病区床日数 - 1;
            End If;
            d_天数起 := r_Item(I).开始时间;
            d_天数止 := r_Item(I).终止时间;
            If (d_天数止 - d_天数起)=0 Then
              n_病人床日数 :=1;
            Else
              n_病人床日数 :=(d_天数止 - d_天数起);
            End If;
            n_病区床日数 := n_病区床日数 + n_病人床日数 ;
          Elsif r_Item(I).类型 = '转入' Then
            --如果上一个起始时间和这次的起始时间相同，则减一，例如：一天内在同一个科室转了多次；
            if d_天数起 = r_Item(I).开始时间 Then
              n_病区床日数 := n_病区床日数 - 1;
            End If;
            If I >=r_Item.Count Then
              d_天数起 := r_Item(I).开始时间;
              d_天数止 := Trunc(d_e);
              If (d_天数止 - d_天数起)=0 Then
                n_病人床日数 :=1;
              Else
                n_病人床日数 :=(d_天数止 - d_天数起);
              End If;
              n_病区床日数 := n_病区床日数 + n_病人床日数 ;
            Else
              If r_Item(I+1).类型 = '转出' And r_Item(I+1).病人id || '_' || r_Item(I+1).主页id = r_Item(I).病人id || '_' || r_Item(I).主页id Then
                 d_天数起 := r_Item(I).开始时间;
                 d_天数止 := r_Item(I+1).开始时间;
                 If (d_天数止 - d_天数起)=0 Then
                   n_病人床日数 :=1;
                 Else
                   n_病人床日数 :=(d_天数止 - d_天数起);
                 End If;
                 n_病区床日数 := n_病区床日数 + n_病人床日数 ;
              Else
                 d_天数起 := r_Item(I).开始时间;
                 d_天数止 := Trunc(d_e);
                 If (d_天数止 - d_天数起)=0 Then
                   n_病人床日数 :=1;
                 Else
                   n_病人床日数 :=(d_天数止 - d_天数起);
                 End If;
                 n_病区床日数 := n_病区床日数 + n_病人床日数 ;
              End If;
            End If;
          End If;
        End If;
        v_Pre病人 := r_Item(I).病人id || '_' || r_Item(I).主页id;
      End Loop;
      v_Xtmp := '<ITEM><YF>' || Substr(v_月份, 6, 2) || '</YF><ZYCR>' || n_病区床日数 || '</ZYCR></ITEM>';
      Select Appendchildxml(x_Tmp, '/ITEM/DATALIST', Xmltype(v_Xtmp)) Into x_Tmp From Dual;

      If x_Tmp Is Not Null Then
        Select Appendchildxml(x_Templet, '/OUTPUT/BQLIST', x_Tmp) Into x_Templet From Dual;
      End If;
    End Loop;
  End If;
  Xml_Out := x_Templet;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getzycws;
/

--121143:胡俊勇,2018-01-29,移动护理和HIS相关的接口
CREATE OR REPLACE Procedure Zl_Third_Getzyhzrrs
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --功能：出院者占用总床日数/查询
  --出院者占用总床日数：指当天出院患者的住院床日之总和，即住院总天数。病人入院后于当晚12点前死亡或因故出院的病人, 作为占用床日数1天进行统计
  --基于ZLHIS系统的理解：在指定时间范围出院的病人的住院天数的总和
  --入参：Xml_In
  --<IN>
  --    <BQID></BQID>    //病区ID，传空取所有病区
  --    <KSRQ></KSRQ>  //开始日期   yyyy-mm-dd
  --    <JSRQ></JSRQ>   //结束日期  yyyy-mm-dd
  --</IN>

  --出参：xml_out
  --<OUTPUT>
  --  <BQLIST>
  --    <ITEM>
  --      <BQID></BQID>  //病区ID
  --      <BQMC></BQMC>  //病区名称
  --      <DATALIST>
  --        <ITEM>
  --           <YF></YF>  //月份
  --           <CRS></CRS>  //出院患者占用总床日数
  --        </ITEM>
  --      </DATALIST>
  --    </ITEM>
  --  </BQLIST>
  --</OUTPUT> 

  n_病区id    部门表.Id%Type;
  n_Pre病区id 部门表.Id%Type;
  d_开始      Date;
  d_结束      Date;
  v_Xtmp      Varchar(5000); --临时XML 
  x_Tmp       Xmltype;
  x_Templet   Xmltype;

  Cursor c_Item Is
    Select m.病区id, m.病区名称, m.月, Sum(m.住院天数) As 床日数
    From (Select b.当前病区id As 病区id, b.病人id, b.主页id, a.名称 As 病区名称, To_Char(b.出院日期, 'mm') As 月,
                  (Trunc(b.出院日期) - Trunc(Decode(b.入科时间, Null, b.入院日期, b.入科时间))) As 住院天数
           From 病案主页 B, 部门表 A
           Where b.当前病区id = a.Id And b.当前病区id = n_病区id And b.出院日期 Between d_开始 And d_结束) M
    Group By m.病区id, m.病区名称, m.月
    Having Sum(m.住院天数) > 0;

  Type t_Item Is Table Of c_Item%RowType;
  r_Item t_Item;

  Cursor c_Itemall Is
    Select m.病区id, m.病区名称, m.月, Sum(m.住院天数) As 床日数
    From (Select b.当前病区id As 病区id, b.病人id, b.主页id, a.名称 As 病区名称, To_Char(b.出院日期, 'mm') As 月,
                  (Trunc(b.出院日期) - Trunc(Decode(b.入科时间, Null, b.入院日期, b.入科时间))) As 住院天数
           From 病案主页 B, 部门表 A
           Where b.当前病区id = a.Id And b.出院日期 Between d_开始 And d_结束) M
    Group By m.病区id, m.病区名称, m.月
    Having Sum(m.住院天数) > 0
    Order By m.病区id;
Begin
  Select Extractvalue(Value(A), 'IN/BQID') As 病区id,
         To_Date(Extractvalue(Value(A), 'IN/KSRQ'), 'yyyy-mm-dd hh24:mi:ss') As 开始日期,
         To_Date(Extractvalue(Value(A), 'IN/JSRQ'), 'yyyy-mm-dd hh24:mi:ss') As 结束日期
  Into n_病区id, d_开始, d_结束
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  n_Pre病区id := -1;

  If n_病区id Is Null Then
    Open c_Itemall;
    Fetch c_Itemall Bulk Collect
      Into r_Item;
    Close c_Itemall;
  Else
    Open c_Item;
    Fetch c_Item Bulk Collect
      Into r_Item;
    Close c_Item;
  End If;
  x_Templet := Xmltype('<OUTPUT><BQLIST></BQLIST></OUTPUT>');
  For I In 1 .. r_Item.Count Loop
    If n_Pre病区id <> r_Item(I).病区id Then
      If x_Tmp Is Not Null Then
        Select Appendchildxml(x_Templet, '/OUTPUT/BQLIST', x_Tmp) Into x_Templet From Dual;
      End If;
      n_Pre病区id := r_Item(I).病区id;
      v_Xtmp      := '<ITEM><BQID>' || r_Item(I).病区id || '</BQID><BQMC>' || r_Item(I).病区名称 || '</BQMC>';
      v_Xtmp      := v_Xtmp || '<DATALIST></DATALIST></ITEM>';
      x_Tmp       := Xmltype(v_Xtmp);
    End If;
    v_Xtmp := '<ITEM><YF>' || r_Item(I).月 || '</YF><CRS>' || r_Item(I).床日数 || '</CRS></ITEM>';
    Select Appendchildxml(x_Tmp, '/ITEM/DATALIST', Xmltype(v_Xtmp)) Into x_Tmp From Dual;
  End Loop;
  If x_Tmp Is Not Null Then
    Select Appendchildxml(x_Templet, '/OUTPUT/BQLIST', x_Tmp) Into x_Templet From Dual;
  End If;
  Xml_Out := x_Templet;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getzyhzrrs;
/

--117750:殷瑞,2018-01-30,新增按给药途径的配置费收取方案
Create Or Replace Procedure Zl_输液配药记录_配药
(
  配药id_In   In Varchar2, --ID串:ID1,ID2.... 
  操作人员_In In 输液配药记录.操作人员%Type := Null,
  操作时间_In In 输液配药记录.操作时间%Type := Null,
  操作说明_In In 输液配药状态.操作说明%Type := Null,
  移动操作_In In Number := 0
) Is
  v_Tansid     Varchar2(20);
  v_Tmp        Varchar2(4000);
  v_No         Varchar2(20);
  v_Usercode   Varchar2(100);
  n_操作状态   输液配药记录.操作状态%Type;
  v_Error      Varchar2(255);
  n_People     Number(1);
  n_Row        Number(2);
  d_执行时间   Date;
  v_配药类型   Varchar2(50);
  n_项目id     Number(18);
  v_收费项目id Varchar2(200);
  v_Info       Varchar2(200);
  v_Id         Varchar2(20);
  n_数次       Number(2);
  n_Count      Number(18);
  n_Out        Number(10);
  n_Outnum     Number(10);
  n_打包状态   Number(1);
  v_核对人     Varchar2(20);
  v_配液人     Varchar2(20);
  Err_Custom Exception;

  Cursor c_Bill Is
    Select a.病人id, a.主页id, a.标识号, a.姓名, a.性别, a.年龄, a.床号, a.费别, a.病人病区id, a.病人科室id, a.婴儿费, e.药品id, b.库房id, f.配药类型
    From 住院费用记录 A, 药品收发记录 B, 输液配药记录 C, 输液配药内容 D, 药品规格 E, 输液药品属性 F, 配置收费方案 G
    Where a.Id = b.费用id And b.Id = d.收发id And d.记录id = c.Id And b.药品id = e.药品id And b.药品id = f.药品id And
          Substr(f.配药类型, Instr(f.配药类型, '-') + 1) = g.配药类型(+) And Nvl(c.是否打包, 0) <> 1 And c.Id = v_Tansid
    Order By g.序号;

Begin
  v_Usercode := Zl_Identity;
  v_Usercode := Substr(v_Usercode, Instr(v_Usercode, ';') + 1);
  v_Usercode := Substr(v_Usercode, Instr(v_Usercode, ',') + 1);
  v_Usercode := Substr(v_Usercode, 1, Instr(v_Usercode, ',') - 1);
  n_People   := Nvl(zl_GetSysParameter('配置费按病人收取', 1345), 0);
  n_Out      := Nvl(zl_GetSysParameter('出院病人不收配置费', 1345), 0);

  If 配药id_In Is Null Then
    v_Tmp := Null;
  Else
    v_Tmp := 配药id_In || ',';
  End If;

  While v_Tmp Is Not Null Loop
    --分解单据ID串 
    v_Tansid := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
    v_Tmp    := Replace(',' || v_Tmp, ',' || v_Tansid || ',');
  
    --检查当前输液单的状态是否为待摆药状态 
    Begin
      Select 操作状态, 执行时间, Nvl(是否打包, 0)
      Into n_操作状态, d_执行时间, n_打包状态
      From 输液配药记录
      Where ID = v_Tansid;
    
      If n_操作状态 > 3 Then
        v_Error := '该数据已被操作，不能进行发药！';
        Raise Err_Custom;
      End If;
    Exception
      When Others Then
        v_Error := '该数据已被操作！';
        Raise Err_Custom;
    End;
  
    v_核对人 := '';
    v_配液人 := '';
    Begin
      Select 核对人, 配液人
      Into v_核对人, v_配液人
      From (Select e.核对人, e.配液人
             From 输液配药记录 A, 输液配药内容 B, 药品收发记录 C, 配液台药品对照 D, 配液工作安排 E
             Where a.Id = b.记录id And b.收发id = c.Id And c.药品id = d.药品id And c.库房id = d.部门id And d.配药台id = e.配药台id And
                   a.配药批次 = e.批次 And e.日期 = To_Date(To_Char(Sysdate, 'yyyy-mm-dd'), 'yyyy-mm-dd') And a.Id = v_Tansid And
                   Rownum = 1
             Order By d.配药台id)
      Where Rownum = 1;
    Exception
      When Others Then
        Null;
    End;
  
    Update 输液配药记录 Set 操作状态 = 4, 操作人员 = 操作人员_In, 操作时间 = 操作时间_In Where ID = v_Tansid;
    If 移动操作_In = 0 Then
      Insert Into 输液配药状态
        (配药id, 操作类型, 操作人员, 操作时间, 操作说明, 实际工作人员)
      Values
        (v_Tansid, 3, 操作人员_In, 操作时间_In, 操作说明_In, v_核对人);
    End If;
    Insert Into 输液配药状态
      (配药id, 操作类型, 操作人员, 操作时间, 操作说明, 实际工作人员)
    Values
      (v_Tansid, 4, 操作人员_In, 操作时间_In, 操作说明_In, v_配液人);
  
    If n_打包状态 = 0 Then
      n_Count := 0;
      Select Nextno(14) Into v_No From Dual;
      For r_Bill In c_Bill Loop
        Select Count(病人id)
        Into n_Outnum
        From 病案主页
        Where 主页id = r_Bill.主页id And 病人id = r_Bill.病人id And (Nvl(状态, 0) = 3 Or 出院日期 Is Not Null);
        If n_Count = 0 And (n_Outnum = 0 Or n_Out = 0) Then
          --收取材料费 
          --v_收费项目id:='6970,2;6971,1;'; 
          Select Zl_Fun_Pivacustom(v_Tansid) Into v_收费项目id From Dual;
          While v_收费项目id Is Not Null Loop
            v_Info       := Substr(v_收费项目id, 1, Instr(v_收费项目id, ';') - 1);
            v_收费项目id := Replace(';' || v_收费项目id, ';' || v_Info || ';');
          
            v_Id   := Substr(v_Info, 1, Instr(v_Info, ',') - 1);
            v_Info := Replace(',' || v_Info, ',' || v_Id || ',');
          
            For r_Item In (Select a.Id 收费细目id, a.类别 收费类别, a.计算单位, a.加班加价 加班标志, d.Id 收入项目id, d.收据费目, b.现价
                           From 收费项目目录 A, 收费价目 B, 收入项目 D
                           Where a.Id = b.收费细目id And b.收入项目id = d.Id And a.Id = v_Id And b.执行日期 <= Sysdate And
                                 (b.终止日期 >= Sysdate Or b.终止日期 Is Null)) Loop
              If n_Count = 0 Then
                Insert Into 输液配药附费 (配药id, NO, 病人id) Values (v_Tansid, v_No, r_Bill.病人id);
              End If;
            
              n_Count := n_Count + 1;
              Zl_住院记帐记录_Insert(v_No, n_Count, r_Bill.病人id, r_Bill.主页id, r_Bill.标识号, r_Bill.姓名, r_Bill.性别, r_Bill.年龄,
                               r_Bill.床号, r_Bill.费别, r_Bill.病人病区id, r_Bill.病人科室id, r_Item.加班标志, r_Bill.婴儿费, r_Bill.库房id,
                               操作人员_In, Null, r_Item.收费细目id, r_Item.收费类别, r_Item.计算单位, Null, Null, Null, 1, v_Info, Null,
                               r_Bill.库房id, Null, r_Item.收入项目id, r_Item.收据费目, r_Item.现价, r_Item.现价 * v_Info,
                               r_Item.现价 * v_Info, Null, Sysdate, Sysdate, Null, Null, v_Usercode, 操作人员_In);
            End Loop;
          End Loop;
        End If;
      
        --先查询是否有按给药途径收取的配置费方案
        Select Nvl(Max(项目id), 0)
        Into n_项目id
        From 输液配药记录 A, 病人医嘱记录 B, 配置收费方案 C
        Where a.Id = v_Tansid And a.医嘱id = b.Id And b.诊疗项目id = c.诊疗id;
        If n_项目id = 0 Then
          --若无对应给药途径的配置费收取方案，则再查询是否有按配药类型收取的配置费方案
          Select Nvl(Max(项目id), 0)
          Into n_项目id
          From 配置收费方案
          Where 配药类型 = Substr(r_Bill.配药类型, Instr(r_Bill.配药类型, '-', 1, 1) + 1);
        End If;
      
        If n_项目id <> 0 Then
          n_Row := 0;
        
          If n_People = 1 Then
            Select Count(配药id)
            Into n_Row
            From 输液配药附费 A, 住院费用记录 B, 输液配药记录 C
            Where a.No = b.No And a.配药id = c.Id And b.病人id = r_Bill.病人id And b.记录状态 = 1 And b.收费细目id = n_项目id And
                  d_执行时间 Between Trunc(c.执行时间) And Trunc(c.执行时间 + 1) - 1 / 24 / 60 / 60;
          End If;
        Else
          n_Row := 1;
        End If;
      
        If n_Row = 0 And (n_Outnum = 0 Or n_Out = 0) Then
          For r_Item In (Select a.Id 收费细目id, a.类别 收费类别, a.计算单位, a.加班加价 加班标志, d.Id 收入项目id, d.收据费目, b.现价
                         From 收费项目目录 A, 收费价目 B, 收入项目 D
                         Where a.Id = b.收费细目id And b.收入项目id = d.Id And a.Id = n_项目id And b.执行日期 <= Sysdate And
                               (b.终止日期 >= Sysdate Or b.终止日期 Is Null)) Loop
            If n_Count = 0 Then
              Insert Into 输液配药附费 (配药id, NO, 病人id) Values (v_Tansid, v_No, r_Bill.病人id);
            End If;
          
            n_Count := n_Count + 1;
            Zl_住院记帐记录_Insert(v_No, n_Count, r_Bill.病人id, r_Bill.主页id, r_Bill.标识号, r_Bill.姓名, r_Bill.性别, r_Bill.年龄,
                             r_Bill.床号, r_Bill.费别, r_Bill.病人病区id, r_Bill.病人科室id, r_Item.加班标志, r_Bill.婴儿费, r_Bill.库房id,
                             操作人员_In, Null, r_Item.收费细目id, r_Item.收费类别, r_Item.计算单位, Null, Null, Null, 1, 1, Null,
                             r_Bill.库房id, Null, r_Item.收入项目id, r_Item.收据费目, r_Item.现价, r_Item.现价, r_Item.现价, Null,
                             Sysdate, Sysdate, Null, Null, v_Usercode, 操作人员_In);
          End Loop;
        End If;
      
        If n_Row = 0 Then
          Exit;
        End If;
      End Loop;
    End If;
  End Loop;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_输液配药记录_配药;
/

--117750:殷瑞,2018-02-05,新增按给药途径的配置费收取方式
Create Or Replace Procedure Zl_配置收费方案_设置
(
  序号_In     In 配置收费方案.序号%Type,
  配药类型_In In 配置收费方案.配药类型%Type,
  项目id_In   In 配置收费方案.项目id%Type,
  收费项目_In In 配置收费方案.收费项目%Type,
  诊疗id_In   In 配置收费方案.诊疗id%Type,
  n_First_In  In Number
) Is
Begin
  If n_First_In = 1 Then
    Delete From 配置收费方案;
  End If;

  Insert Into 配置收费方案
    (序号, 配药类型, 项目id, 收费项目, 诊疗id)
  Values
    (序号_In, 配药类型_In, 项目id_In, 收费项目_In, 诊疗id_In);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_配置收费方案_设置;
/

--117106:董露露,2018-01-25,解决标准路径参考模块添加一个导入的功能
Create Or Replace Procedure Zl_标准路径目录_Insert
(
  Id_In       标准路径目录.Id%Type,
  科室_In     标准路径目录.科室名称%Type,
  编码_In     标准路径目录.编码%Type,
  路径名称_In 标准路径目录.路径名称%Type,
  版本说明_In 标准路径目录.版本说明%Type,
  疾病编码_In 标准路径病种.疾病编码%Type,
  手术编码_In 标准路径病种.手术编码%Type,
  类别_In     标准路径目录.类别%Type := Null
) Is
  Nid_Nex 标准路径目录.Id%Type;
Begin
  If Id_In Is Null Then
    Select 标准路径目录_Id.Nextval Into Nid_Nex From Dual;
  Else
    Nid_Nex := Id_In;
  End If;
  Insert Into 标准路径目录
    (ID, 科室名称, 编码, 路径名称, 类别, 版本说明)
  Values
    (Id_In, 科室_In, 编码_In, 路径名称_In, 类别_In, 版本说明_In);
  Insert Into 标准路径病种 (标准路径id, 疾病编码, 手术编码) Values (Id_In, 疾病编码_In, 手术编码_In);
  --表头信息
  Zl_标准路径表单_Update(Id_In, 0, 路径名称_In || '表单', '');
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_标准路径目录_Insert;
/

--112077:董露露,2018-01-24,解决病人登记时输入的年龄可以为“约+年龄+年龄单位”和“不详”的问题
Create Or Replace Function Zl_Age_Check
(
  年龄_In     病人信息.年龄%Type,
  出生日期_In Date := Null,
  计算日期_In Date := Null
) Return Varchar2
--年龄格式:X小时[X分钟];X天[X小时];X月[X天];X岁[X月]
 As
  v_Return           Varchar2(1000);
  v_Info             Varchar2(1000);
  v_Tmpone           Varchar2(20);
  v_Tmptwo           Varchar2(20);
  v_Unitone          Varchar2(4);
  v_Unittwo          Varchar2(4);
  n_Ageformatcorrect Number(1);
  n_Ageformat        Number(1);
  v_Age              病人信息.年龄%Type;
  v_Birthday         Varchar2(20);
Begin
  v_Info             := '1|年龄格式只能为:X小时[X分钟] 或 X天[X小时] 或 X月[X天] 或 X岁[X月]，并且X为正整数。';
  n_Ageformatcorrect := 0;
  --检查年龄格式是否正确
  If Not 年龄_In Like '约%' And 年龄_In Not Like '不详%' Then
    For I In 1 .. 4 Loop
      If I = 1 Then
        v_Unitone := '岁';
        v_Unittwo := '月';
      Elsif I = 2 Then
        v_Unitone := '月';
        v_Unittwo := '天';
      Elsif I = 3 Then
        v_Unitone := '天';
        v_Unittwo := '小时';
      Else
        v_Unitone := '小时';
        v_Unittwo := '分钟';
      End If;
      --1:X岁[X月],2:X月[X天],3:X天,4:X小时[X分钟]
      If Instr(年龄_In, v_Unitone, 1) > 0 And n_Ageformatcorrect = 0 Then
        If Instr(年龄_In, v_Unitone, 1) = 1 Then
          v_Return := v_Info;
          Return v_Return;
        Else
          v_Tmpone := Substr(年龄_In, 1, Instr(年龄_In, v_Unitone, 1) - 1);
          --岁前面必须为数字
          If Translate(v_Tmpone, '\0123456789', '\') Is Null Then
            If To_Number(v_Tmpone) > 200 And v_Unitone = '岁' Then
              v_Return := '1|年龄格式为:X岁时，岁数不能大于200岁。';
              Return v_Return;
            Elsif To_Number(v_Tmpone) >= 12 And v_Unitone = '月' Then
              v_Return := '1|年龄格式为:X月时，月份数必须小于12个月。';
              Return v_Return;
            Elsif To_Number(v_Tmpone) >= 31 And v_Unitone = '天' Then
              v_Return := '1|年龄格式为:X天时，天数必须小于31天。';
              Return v_Return;
            Elsif To_Number(v_Tmpone) >= 24 And v_Unitone = '小时' Then
              v_Return := '1|年龄格式为:X小时时，小时数必须小于24小时。';
              Return v_Return;
            End If;
            If Instr(年龄_In, v_Unitone, 1) + Length(v_Unitone) - 1 = Length(年龄_In) Then
              n_Ageformatcorrect := I;
              Exit;
            Else
              v_Tmpone := Substr(年龄_In, Instr(年龄_In, v_Unitone, 1) + Length(v_Unitone));
              If Instr(v_Tmpone, v_Unittwo, 1) = 0 Or Length(v_Tmpone) = Length(v_Unittwo) Or
                 Substr(v_Tmpone, Length(v_Tmpone) - Length(v_Unittwo) + 1, Length(v_Unittwo)) <> v_Unittwo Then
                v_Return := v_Info;
                Return v_Return;
              Else
                v_Tmptwo := Substr(v_Tmpone, 1, Length(v_Tmpone) - Length(v_Unittwo));
                If Translate(v_Tmptwo, '\0123456789', '\') Is Null Then
                  If To_Number(v_Tmptwo) >= 12 And v_Unittwo = '月' Then
                    v_Return := '1|年龄格式为:[X岁X月]时，月份数必须小于12个月。';
                    Return v_Return;
                  Elsif To_Number(v_Tmptwo) >= 31 And v_Unittwo = '天' Then
                    v_Return := '1|年龄格式为:[X月X天]时，天数必须小于31天。';
                    Return v_Return;
                  Elsif To_Number(v_Tmptwo) >= 60 And v_Unittwo = '分钟' Then
                    v_Return := '1|年龄格式为:[X小时X分钟]时，分钟数必须小于60分钟。';
                    Return v_Return;
                  Elsif To_Number(v_Tmptwo) >= 24 And v_Unittwo = '小时' Then
                    v_Return := '1|年龄格式为:[X天X小时]时，小时数必须小于24小时。';
                    Return v_Return;
                  Else
                    n_Ageformatcorrect := I;
                    Exit;
                  End If;
                Else
                  v_Return := v_Info;
                  Return v_Return;
                End If;
              End If;
            End If;
          Else
            v_Return := v_Info;
            Return v_Return;
          End If;
        End If;
      End If;
    End Loop;
  
    --年龄不再上述任何一个范围:如年龄为:51、1周1天
    If n_Ageformatcorrect = 0 Then
      v_Return := v_Info;
      Return v_Return;
    End If;
    --年龄格式正确，检查年龄段是否在出生日期段内
    If 出生日期_In Is Null Then
      Return Null;
    End If;
    v_Birthday := To_Char(出生日期_In, 'YYYY-MM-DD hh24:mi:ss');
    If Substr(v_Birthday, 12) = '00:00:00' Then
      v_Birthday := Substr(v_Birthday, 1, 10);
    Else
      v_Birthday := Substr(v_Birthday, 1, 16);
    End If;
    v_Age := Zl_Age_Calc(0, 出生日期_In, 计算日期_In);
    --计算根据出生日期计算出来的年龄在那一个段
    n_Ageformat := 0;
    v_Tmpone    := '';
    If Instr(v_Age, '岁', 1) > 0 Then
      n_Ageformat := 1;
      v_Tmpone    := 'X岁[X月]';
    Elsif Instr(v_Age, '月', 1) > 0 Then
      n_Ageformat := 2;
      v_Tmpone    := 'X月[X天]';
    Elsif Instr(v_Age, '天', 1) > 0 Then
      n_Ageformat := 3;
      v_Tmpone    := 'X天[小时]';
    Elsif Instr(v_Age, '小时', 1) > 0 Then
      n_Ageformat := 4;
      v_Tmpone    := 'X小时[X分钟]';
    End If;
    v_Return := '';
    If n_Ageformat = 0 Then
      v_Return := '1|计算年龄的函数：Zl_Age_Calc 存在问题,请直接与开发商联系。';
      Return v_Return;
    End If;
    --检查根据出生日期计算出来的年龄段和传入的年龄年龄段是否相同
    If n_Ageformatcorrect <> n_Ageformat Then
      v_Return := '1|年龄[' || 年龄_In || ']与出生日期计算出来的年龄[' || v_Age || ']在格式上不一致，';
      v_Return := v_Return || '当前年龄格式应该为:' || v_Tmpone || '。';
      Return v_Return;
    End If;
    --同一时间段内则坚持年龄是否相等
    If 年龄_In <> v_Age Then
      v_Return := '0|年龄[' || 年龄_In || ']与出生日期不一致，' || v_Birthday || '出生到现在应该是[' || v_Age || ']。';
    End If;
  End If;
  Return v_Return;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Age_Check;
/

--119437:胡俊勇,2018-01-23,临床相关消息修改
Create Or Replace Procedure Zl_病人诊断记录_Delete
(
  --功能：删除病人诊断记录
  --参数：诊断类型_IN=为空时表示所有类型,否则为字符串,如'1,2,3...'
  --      诊断s_In=需要删除的诊断ID串 ,格式为 'ID1,ID2,ID3...'
  病人id_In   In 病人诊断记录.病人id%Type,
  主页id_In   In 病人诊断记录.主页id%Type,
  记录来源_In In 病人诊断记录.记录来源%Type := Null,
  病历id_In   In 病人诊断记录.病历id%Type := Null,
  诊断类型_In In Varchar2 := Null,
  诊断ids_In  In Varchar2 := Null
) Is
  v_类型串 Varchar2(255);
  v_类型   病人诊断记录.诊断类型%Type;
Begin
  If 诊断类型_In Is Null Then
    If Not 诊断ids_In Is Null Then
      For Rdiag In (Select /*+ Rule*/
                     ID, 记录来源, 诊断类型, 诊断次序, 疾病id, 诊断id, 诊断描述
                    From 病人诊断记录
                    Where ID In (Select Column_Value From Table(f_Str2list(诊断ids_In)))
                    Order By 记录来源, 诊断类型, 诊断次序) Loop
        If Rdiag.记录来源 = 3 And Rdiag.诊断类型 = 2 And Rdiag.诊断次序 = 1 Then
          Update 病案主页 Set 单病种 = Null Where 病人id = 病人id_In And 主页id = Nvl(主页id_In, 0);
        End If;
      
        --如果诊断类型是当前传入的诊断类型，则删除诊断
        If Rdiag.记录来源 = 记录来源_In Or 记录来源_In Is Null Then
          Delete From 病人诊断医嘱 Where 诊断id = Rdiag.Id;
        
          --调用消息删除 
          b_Message.Zlhis_Cis_011(病人id_In, 主页id_In, Rdiag.Id, Rdiag.疾病id, Rdiag.诊断id, Rdiag.诊断描述);
          Delete From 病人诊断记录 Where ID = Rdiag.Id;
        
          --调用消息删除 
          For R In (Select ID, 疾病id, 诊断id, 诊断描述
                    From 病人诊断记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And 记录来源 = Rdiag.记录来源 And 诊断类型 = Rdiag.诊断类型 And
                          诊断次序 = Rdiag.诊断次序 And Nvl(编码序号, 1) = 2) Loop
            b_Message.Zlhis_Cis_011(病人id_In, 主页id_In, r.Id, r.疾病id, r.诊断id, r.诊断描述);
          End Loop;
        
          Delete From 病人诊断记录
          Where 病人id = 病人id_In And 主页id = 主页id_In And 记录来源 = Rdiag.记录来源 And 诊断类型 = Rdiag.诊断类型 And 诊断次序 = Rdiag.诊断次序 And
                Nvl(编码序号, 1) = 2;
        
        End If;
      End Loop;
    Else
      Delete From 病人诊断医嘱
      Where 诊断id In (Select ID
                     From 病人诊断记录
                     Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0) And (记录来源 = 记录来源_In Or 记录来源_In Is Null) And
                           (病历id = 病历id_In Or 病历id_In Is Null));
      --调用消息删除 
      For R In (Select ID, 疾病id, 诊断id, 诊断描述
                From 病人诊断记录
                Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0) And (记录来源 = 记录来源_In Or 记录来源_In Is Null) And
                      (病历id = 病历id_In Or 病历id_In Is Null)) Loop
        b_Message.Zlhis_Cis_011(病人id_In, 主页id_In, r.Id, r.疾病id, r.诊断id, r.诊断描述);
      End Loop;
    
      Delete From 病人诊断记录
      Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0) And (记录来源 = 记录来源_In Or 记录来源_In Is Null) And
            (病历id = 病历id_In Or 病历id_In Is Null);
    
      --删除单病种标识
      If 记录来源_In = 3 Then
        Update 病案主页 Set 单病种 = Null Where 病人id = 病人id_In And 主页id = Nvl(主页id_In, 0);
      End If;
    End If;
  Else
    v_类型串 := 诊断类型_In || ',';
    While v_类型串 Is Not Null Loop
      v_类型 := To_Number(Substr(v_类型串, 1, Instr(v_类型串, ',') - 1));
    
      Delete From 病人诊断医嘱
      Where 诊断id In (Select ID
                     From 病人诊断记录
                     Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0) And (记录来源 = 记录来源_In Or 记录来源_In Is Null) And
                           (病历id = 病历id_In Or 病历id_In Is Null) And 诊断类型 = v_类型);
    
      --调用消息删除 
      For R In (Select ID, 疾病id, 诊断id, 诊断描述
                From 病人诊断记录
                Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0) And (记录来源 = 记录来源_In Or 记录来源_In Is Null) And
                      (病历id = 病历id_In Or 病历id_In Is Null) And 诊断类型 = v_类型) Loop      
        b_Message.Zlhis_Cis_011(病人id_In, 主页id_In, r.Id, r.疾病id, r.诊断id, r.诊断描述);
      End Loop;
    
      Delete From 病人诊断记录
      Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0) And (记录来源 = 记录来源_In Or 记录来源_In Is Null) And
            (病历id = 病历id_In Or 病历id_In Is Null) And 诊断类型 = v_类型;
    
      v_类型串 := Substr(v_类型串, Instr(v_类型串, ',') + 1);
    
      --如果是入院诊断则删除单病种标识
      If v_类型 = 2 And 记录来源_In = 3 Then
        Update 病案主页 Set 单病种 = Null Where 病人id = 病人id_In And 主页id = Nvl(主页id_In, 0);
      End If;
    End Loop;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人诊断记录_Delete;
/

--110624:刘涛,2018-01-23,其他出库增加修改信息
Create Or Replace Procedure Zl_药品其他出库_Strike
(
  行次_In       In Integer,
  原记录状态_In In 药品收发记录.记录状态%Type,
  No_In         In 药品收发记录.No%Type,
  序号_In       In 药品收发记录.序号%Type,
  药品id_In     In 药品收发记录.药品id%Type,
  冲销数量_In   In 药品收发记录.实际数量%Type,
  填制人_In     In 药品收发记录.填制人%Type,
  填制日期_In   In 药品收发记录.填制日期%Type
) Is
  Err_Isstriked Exception;
  Err_Isoutstock Exception;
  Err_Isnonum Exception;
  Err_Isbatch Exception;
  v_Druginf Varchar2(50); --原不分批现在分批的药品信息

  v_库房id       药品收发记录.库房id%Type;
  v_入出类别id   药品收发记录.入出类别id%Type;
  v_产地         药品收发记录.产地%Type;
  v_原产地       药品收发记录.原产地%Type;
  v_批次         药品收发记录.批次%Type;
  v_批号         药品收发记录.批号%Type;
  v_效期         药品收发记录.效期%Type;
  v_成本价       药品收发记录.成本价%Type;
  v_成本金额     药品收发记录.成本金额%Type;
  v_扣率         药品收发记录.扣率%Type;
  v_零售价       药品收发记录.零售价%Type;
  v_零售金额     药品收发记录.零售金额%Type;
  v_差价         药品收发记录.差价%Type;
  v_摘要         药品收发记录.摘要%Type;
  v_剩余数量     药品收发记录.实际数量%Type;
  v_剩余成本金额 药品收发记录.成本金额%Type;
  v_剩余零售金额 药品收发记录.零售金额%Type;
  v_入出系数     药品收发记录.入出系数%Type;
  v_外调价       药品收发记录.单量%Type;
  v_外调单位     药品收发记录.发药窗口%Type;
  v_批准文号     药品收发记录.批准文号%Type;
  v_增值税率     药品收发记录.频次%Type;

  v_收发id 药品收发记录.Id%Type;
  Intdigit Number;

  n_上次供应商id 药品库存.上次供应商id%Type;
  d_上次生产日期 药品库存.上次生产日期%Type;
Begin
  --获取金额小数位数
  Select Nvl(精度, 2) Into Intdigit From 药品卫材精度 Where 性质 = 0 And 类别 = 1 And 内容 = 4 And 单位 = 5;

  If 行次_In = 1 Then
    Update 药品收发记录
    Set 记录状态 = Decode(原记录状态_In, 1, 3, 原记录状态_In + 3)
    Where NO = No_In And 单据 = 11 And 记录状态 = 原记录状态_In;
    If Sql%RowCount = 0 Then
      Raise Err_Isstriked;
    End If;
  End If;

  --主要针对原不分批现在分批的药品，不能对其冲销
  Begin
    Select Distinct '(' || i.编码 || ')' || Nvl(n.名称, i.名称) As 药品信息
    Into v_Druginf
    From 药品收发记录 A, 药品规格 B, 收费项目目录 I, 收费项目别名 N
    Where a.药品id = b.药品id And a.药品id = i.Id And a.药品id = n.收费细目id(+) And n.性质(+) = 3 And a.No = No_In And a.单据 = 11 And
          a.药品id + 0 = 药品id_In And Mod(a.记录状态, 3) = 0 And Nvl(a.批次, 0) = 0 And
          ((Nvl(b.药库分批, 0) = 1 And
          a.库房id Not In (Select 部门id From 部门性质说明 Where (工作性质 Like '%药房') Or (工作性质 Like '制剂室'))) Or Nvl(b.药房分批, 0) = 1) And
          Rownum = 1;
  Exception
    When Others Then
      v_Druginf := '';
  End;

  If v_Druginf Is Not Null Then
    Raise Err_Isbatch;
  End If;

  Select Sum(实际数量) As 剩余数量, Sum(成本金额) As 剩余成本金额, Sum(零售金额) As 剩余零售金额, 库房id, 入出类别id, 入出系数, 批次, 产地, 原产地, 批号, 效期, 成本价, 扣率, 零售价,
         摘要, 单量, 发药窗口, 批准文号, 供药单位id, 生产日期, To_Number(Trim(To_Char(Nvl(频次, '0'), '999999999999.0000'))) As 增值税率
  Into v_剩余数量, v_剩余成本金额, v_剩余零售金额, v_库房id, v_入出类别id, v_入出系数, v_批次, v_产地, v_原产地, v_批号, v_效期, v_成本价, v_扣率, v_零售价, v_摘要, v_外调价,
       v_外调单位, v_批准文号, n_上次供应商id, d_上次生产日期, v_增值税率
  From 药品收发记录
  Where NO = No_In And 单据 = 11 And 药品id = 药品id_In And 序号 = 序号_In
  Group By 库房id, 入出类别id, 入出系数, 批次, 产地, 原产地, 批号, 效期, 成本价, 扣率, 零售价, 摘要, 单量, 发药窗口, 批准文号, 供药单位id, 生产日期,
           To_Number(Trim(To_Char(Nvl(频次, '0'), '999999999999.0000')));

  --冲销数量大于剩余数量，不允许
  If Abs(v_剩余数量) < Abs(冲销数量_In) Then
    Raise Err_Isnonum;
  End If;

  v_成本金额 := Round(冲销数量_In / v_剩余数量 * v_剩余成本金额, Intdigit);
  v_零售金额 := Round(冲销数量_In / v_剩余数量 * v_剩余零售金额, Intdigit);
  v_差价     := v_零售金额 - v_成本金额;

  Select 药品收发记录_Id.Nextval Into v_收发id From Dual;
  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 入出系数, 药品id, 批次, 产地, 原产地, 批号, 效期, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 零售金额, 差价, 单量, 发药窗口, 摘要,
     填制人, 填制日期, 审核人, 审核日期, 批准文号, 供药单位id, 生产日期, 扣率, 频次)
  Values
    (v_收发id, Decode(原记录状态_In, 1, 2, 原记录状态_In + 2), 11, No_In, 序号_In, v_库房id, v_入出类别id, v_入出系数, 药品id_In, v_批次, v_产地,v_原产地, 
     v_批号, v_效期, -冲销数量_In, -冲销数量_In, v_成本价, -v_成本金额, v_零售价, -v_零售金额, -v_差价, v_外调价, v_外调单位, v_摘要, 填制人_In, 填制日期_In, 填制人_In,
     填制日期_In, v_批准文号, n_上次供应商id, d_上次生产日期, v_扣率, v_增值税率);
  
  --更新库存，出库冲销是入库
  Zl_药品库存_Update(v_收发id, 3, 0);

  --处理调价后冲销
  Zl_药品收发记录_调价修正(v_收发id);
Exception
  When Err_Isstriked Then
    Raise_Application_Error(-20101, '[ZLSOFT]该单据已经被他人冲销！[ZLSOFT]');
  When Err_Isbatch Then
    Raise_Application_Error(-20102, '[ZLSOFT]该单据中包含有一条原来不分批，现在分批的药品[' || v_Druginf || ']，不能冲销！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品其他出库_Strike;
/

--110624:刘涛,2018-01-23,其他出库增加修改信息
Create Or Replace Procedure Zl_药品其他出库_Insert
(
  入出类别id_In In 药品收发记录.入出类别id%Type,
  No_In         In 药品收发记录.No%Type,
  序号_In       In 药品收发记录.序号%Type,
  库房id_In     In 药品收发记录.库房id%Type,
  药品id_In     In 药品收发记录.药品id%Type,
  批次_In       In 药品收发记录.批次%Type,
  填写数量_In   In 药品收发记录.填写数量%Type,
  成本价_In     In 药品收发记录.成本价%Type,
  成本金额_In   In 药品收发记录.成本金额%Type,
  零售价_In     In 药品收发记录.零售价%Type,
  零售金额_In   In 药品收发记录.零售金额%Type,
  差价_In       In 药品收发记录.差价%Type,
  外调价_In     In 药品收发记录.单量%Type,
  外调单位_In   In 药品收发记录.发药窗口%Type,
  填制人_In     In 药品收发记录.填制人%Type,
  填制日期_In   In 药品收发记录.填制日期%Type,
  产地_In       In 药品收发记录.产地%Type := Null,
  批号_In       In 药品收发记录.批号%Type := Null,
  效期_In       In 药品收发记录.效期%Type := Null,
  摘要_In       In 药品收发记录.摘要%Type := Null,
  批准文号_In   In 药品收发记录.批准文号%Type := Null,
  增值税率_In   In Number := Null,
  原产地_In     In 药品收发记录.原产地%Type := Null,
  修改人_In     In 药品收发记录.修改人%Type,
  修改日期_In   In 药品收发记录.修改日期%Type
) Is
  v_入出系数     药品收发记录.入出系数%Type; --收发ID 
  n_上次供应商id 药品库存.上次供应商id%Type;
  d_上次生产日期 药品库存.上次生产日期%Type;
  n_收发id       药品收发记录.Id%Type;
Begin
  v_入出系数 := -1;

  Begin
    Select 上次供应商id, 上次生产日期
    Into n_上次供应商id, d_上次生产日期
    From 药品库存
    Where 性质 = 1 And 库房id = 库房id_In And 药品id = 药品id_In And Nvl(批次, 0) = Nvl(批次_In, 0);
  Exception
    When Others Then
      n_上次供应商id := Null;
      d_上次生产日期 := Null;
  End;

  Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 入出系数, 药品id, 批次, 产地, 原产地,批号, 效期, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 零售金额, 差价, 摘要, 填制人,
     填制日期, 单量, 发药窗口, 批准文号, 供药单位id, 生产日期, 频次, 修改人, 修改日期)
  Values
    (n_收发id, 1, 11, No_In, 序号_In, 库房id_In, 入出类别id_In, v_入出系数, 药品id_In, 批次_In, 产地_In,原产地_In, 批号_In, 效期_In, 填写数量_In, 填写数量_In,
     成本价_In, 成本金额_In, 零售价_In, 零售金额_In, 差价_In, 摘要_In, 填制人_In, 填制日期_In, 外调价_In, 外调单位_In, 批准文号_In, n_上次供应商id, d_上次生产日期,
     增值税率_In, 修改人_In, 修改日期_In);
  
  Zl_未审药品记录_Insert(n_收发id);
  
  --更新库存数据
  Zl_药品库存_Update(n_收发id, 0);

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品其他出库_Insert;
/

--110624:刘涛,2018-01-23,盘点增加修改信息
Create Or Replace Procedure Zl_药品盘点记录单_Update 
( --为已汇总后的药品盘点单作标志
  No_In       药品收发记录.No%Type,
  修改人_In   In 药品收发记录.修改人%Type,
  修改日期_In In 药品收发记录.修改日期%Type
) Is

Begin
  Update 药品收发记录 Set 外观 = '1', 修改人 = 修改人_In, 修改日期 = 修改日期_In Where 单据 = 14 And NO = No_In;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品盘点记录单_Update;
/

--110624:刘涛,2018-01-22,申领增加修改人信息
Create Or Replace Procedure Zl_药品申领_Insert
(
  No_In           In 药品收发记录.No%Type,
  序号_In         In 药品收发记录.序号%Type,
  库房id_In       In 药品收发记录.库房id%Type,
  对方部门id_In   In 药品收发记录.对方部门id%Type,
  药品id_In       In 药品收发记录.药品id%Type,
  批次_In         In 药品收发记录.批次%Type,
  填写数量_In     In 药品收发记录.填写数量%Type,
  实际数量_In     In 药品收发记录.实际数量%Type,
  成本价_In       In 药品收发记录.成本价%Type,
  成本金额_In     In 药品收发记录.成本金额%Type,
  零售价_In       In 药品收发记录.零售价%Type,
  零售金额_In     In 药品收发记录.零售金额%Type,
  差价_In         In 药品收发记录.差价%Type,
  填制人_In       In 药品收发记录.填制人%Type,
  产地_In         In 药品收发记录.产地%Type := Null,
  批号_In         In 药品收发记录.批号%Type := Null,
  效期_In         In 药品收发记录.效期%Type := Null,
  摘要_In         In 药品收发记录.摘要%Type := Null,
  填制日期_In     In 药品收发记录.填制日期%Type := Null,
  上次供应商id_In In 药品收发记录.供药单位id%Type := Null,
  批准文号_In     In 药品收发记录.批准文号%Type := Null,
  申领方式_In     In 药品收发记录.单量%Type := 0,
  结束时间_In     In 药品收发记录.频次%Type := Null,
  原产地_In       In 药品收发记录.原产地%Type := Null,
  修改人_In       In 药品收发记录.修改人%Type,
  修改日期_In     In 药品收发记录.修改日期%Type := Null
) Is
  v_Lngid        药品收发记录.Id%Type; --收发ID 
  n_出库收发id   药品收发记录.Id%Type; --出库库房收发id 
  v_入的类别id   药品收发记录.入出类别id%Type; --入出类别ID 
  v_出的类别id   药品收发记录.入出类别id%Type; --入出类别ID 
  d_上次生产日期 药品库存.上次生产日期%Type;
Begin
  --首先找出入和出的类别ID 
  Select b.Id 
  Into v_入的类别id 
  From 药品单据性质 A, 药品入出类别 B 
  Where a.类别id = b.Id And a.单据 = 6 And b.系数 = 1 And Rownum < 2; 
  
  Select b.Id 
  Into v_出的类别id 
  From 药品单据性质 A, 药品入出类别 B 
  Where a.类别id = b.Id And a.单据 = 6 And b.系数 = -1 And Rownum < 2; 

  Select 药品收发记录_Id.Nextval Into v_Lngid From Dual;

  Begin
    Select 上次生产日期
    Into d_上次生产日期
    From 药品库存
    Where 性质 = 1 And 库房id = 库房id_In And 药品id = 药品id_In And Nvl(批次, 0) = Nvl(批次_In, 0);
  Exception
    When Others Then
      d_上次生产日期 := Null;
  End;

  Select 药品收发记录_Id.Nextval Into n_出库收发id From Dual;
  --插入类别为出的那一笔 
  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 原产地,批号, 效期, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 零售金额, 差价, 摘要,
     填制人, 填制日期, 发药方式, 供药单位id, 批准文号, 生产日期, 单量, 频次, 修改人, 修改日期)
  Values
    (n_出库收发id, 1, 6, No_In, 序号_In, 库房id_In, 对方部门id_In, v_出的类别id, -1, 药品id_In, 批次_In, 产地_In, 原产地_In,批号_In, 效期_In, 填写数量_In,
     实际数量_In, 成本价_In, 成本金额_In, 零售价_In, 零售金额_In, 差价_In, 摘要_In, 填制人_In, 填制日期_In, 1, 上次供应商id_In, 批准文号_In, d_上次生产日期, 申领方式_In,
     结束时间_In, 修改人_In, 修改日期_In);
  
  Zl_未审药品记录_Insert(n_出库收发id);

  --处理库存
  Zl_药品库存_Update(n_出库收发id, 0);

  --插入类别为入的那一笔 
  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地,原产地, 批号, 效期, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 零售金额, 差价, 摘要,
     填制人, 填制日期, 发药方式, 供药单位id, 批准文号, 生产日期, 单量, 频次, 修改人, 修改日期)
  Values
    (v_Lngid, 1, 6, No_In, 序号_In + 1, 对方部门id_In, 库房id_In, v_入的类别id, 1, 药品id_In, 批次_In, 产地_In,原产地_In, 批号_In, 效期_In, 填写数量_In,
     实际数量_In, 成本价_In, 成本金额_In, 零售价_In, 零售金额_In, 差价_In, 摘要_In, 填制人_In, 填制日期_In, 1, 上次供应商id_In, 批准文号_In, d_上次生产日期, 申领方式_In,
     结束时间_In, 修改人_In, 修改日期_In);
  
  Zl_未审药品记录_Insert(v_Lngid);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品申领_Insert;
/

--118584:刘兴洪,2018-01-22,增加免挂号模式
Create Or Replace Procedure Zl_病人挂号记录_回诊
(
  Id_In         病人挂号记录.Id%Type,
  新执行科室_In 病人挂号记录.执行部门id%Type,
  新诊室_In     病人挂号记录.诊室%Type,
  新医生_In     病人挂号记录.执行人%Type,
  需回诊_In     Integer := 0,
  预约方式_In   预约方式.名称%Type := Null
) As
  --需回诊_In :0-回诊操作 或回诊未及时就诊重新签到;1-标记为需要回诊； 
  Err_Item Exception;
  v_Err_Msg          Varchar2(200);
  n_挂号生成队列     Number;
  n_回诊病人重新排队 Number;
  n_再次签到重新排队 Number;
  n_已排队           Number;
  n_记录标志         Number;
  v_病人姓名         病人挂号记录.姓名%Type;
  n_挂号id           病人挂号记录.Id%Type;
  n_执行部门id       病人挂号记录.执行部门id%Type;
  n_排队部门id       病人挂号记录.Id%Type;
  v_排队号码         排队叫号队列.排队号码%Type;
  v_诊室             病人挂号记录.诊室%Type;
  v_医生             病人挂号记录.执行人%Type;
  n_病人id           病人挂号记录.病人id%Type;
  v_号别             病人挂号记录.号别%Type;
  n_号序             病人挂号记录.号序%Type;
  n_回诊序号         排队叫号队列.回诊序号%Type;
  v_排队序号         排队叫号队列.排队序号%Type;
  v_原队列名称       排队叫号队列.队列名称%Type;
  v_原始号码         排队叫号队列.排队号码%Type;
  d_排队时间         排队叫号队列.排队时间%Type;
  v_预约方式         病人挂号记录.预约方式%Type;
Begin
  --:记录标志:0表示就诊病人,1-表示签到的病人,2-表示需要回诊就诊的病人; 3-表示已回诊但还未接收的病人; 
  Select Max(记录标志) Into n_记录标志 From 病人挂号记录 Where ID = Id_In;
  If Sql%NotFound Then
    v_Err_Msg := '挂号项目未找到,不能继续操作!';
    Raise Err_Item;
  End If;

  Update 病人挂号记录 Set 记录标志 = Decode(需回诊_In, 1, 2, 3) Where ID = Id_In;
  If Sql%NotFound Then
    v_Err_Msg := '挂号项目未找到,不能继续操作!';
    Raise Err_Item;
  End If;
  If Nvl(需回诊_In, 0) = 1 Then
    Return;
  End If;

  n_挂号生成队列     := Zl_To_Number(Zl_Getsysparameter('排队叫号模式', 1113));
  n_回诊病人重新排队 := Zl_To_Number(Zl_Getsysparameter('回诊病人需重新排队', 1113));
  n_再次签到重新排队 := Zl_To_Number(Zl_Getsysparameter('再次签到需重新排队', 1113));

  Update 病人挂号记录 Set 记录标志 = Decode(需回诊_In, 1, 2, 3) Where ID = Id_In;

  If n_挂号生成队列 = 0 Then
    Return;
  End If;

  Begin
    Select ID, Nvl(转诊科室id, 执行部门id), 姓名, Decode(转诊科室id, Null, 诊室, 转诊诊室), Decode(转诊科室id, Null, 执行人, 转诊医生), 病人id,
           Nvl(转诊号别, 号别), 号序, 预约方式
    Into n_挂号id, n_执行部门id, v_病人姓名, v_诊室, v_医生, n_病人id, v_号别, n_号序, v_预约方式
    From 病人挂号记录
    Where ID = Id_In And Rownum < 2;
  Exception
    When Others Then
      n_挂号id := -1;
  End;
  If 预约方式_In Is Not Null Then
    v_预约方式 := 预约方式_In;
  End If;
  Begin
    Select 1, 科室id, 排队号码, 队列名称
    Into n_已排队, n_排队部门id, v_原始号码, v_原队列名称
    From 排队叫号队列
    Where 业务id = Id_In And 业务类型 = 0;
  Exception
    When Others Then
      n_已排队 := 0;
  End;

  If n_挂号id > 0 Then
    If n_已排队 > 0 And (Nvl(n_记录标志, 0) = 2 And Nvl(n_回诊病人重新排队, 0) = 0 Or Nvl(n_记录标志, 0) = 3 And Nvl(n_再次签到重新排队, 0) = 1) Then
      If Nvl(n_记录标志, 0) = 2 And Nvl(n_回诊病人重新排队, 0) = 0 Then
        --回诊签到 
        v_排队号码 := Zl_Get_Requeue(1, n_挂号id, 新执行科室_In, 新医生_In, 新诊室_In);
        --重新获取排队时间 
        d_排队时间 := Zl_Get_Requeuedate(1, n_挂号id, 新执行科室_In, 新医生_In, 新诊室_In);
        If v_原始号码 <> v_排队号码 Then
          v_排队序号 := Zlgetsequencenum(0, n_挂号id, 2);
        End If;
      Else
        --回诊重新签到 
        v_排队号码 := Zl_Get_Requeue(0, n_挂号id, 新执行科室_In, 新医生_In, 新诊室_In);
        If v_原始号码 <> v_排队号码 Then
          v_排队序号 := Zlgetsequencenum(0, n_挂号id, 1);
        End If;
      End If;
      If v_原始号码 <> v_排队号码 Or Nvl(n_记录标志, 0) = 2 Then
        --回诊: 
        Zl_排队叫号队列_Update(新执行科室_In, 0, n_挂号id, 新执行科室_In, v_病人姓名, 新诊室_In, 新医生_In, v_排队号码, v_排队序号, d_排队时间);
        Select Nvl(Max(回诊序号), 0) + 1 Into n_回诊序号 From 排队叫号队列; --更新回诊序号 
        Update 排队叫号队列 Set 回诊序号 = n_回诊序号, 排队状态 = 0 Where 业务类型 = 0 And 业务id = n_挂号id;
      Else
        Zl_排队叫号队列_Update(新执行科室_In, 0, n_挂号id, 新执行科室_In, v_病人姓名, 新诊室_In, 新医生_In);
        Update 排队叫号队列 Set 排队状态 = 0 Where 业务类型 = 0 And 业务id = n_挂号id;
      End If;
    Elsif n_已排队 > 0 Then
      --删除原来排队记录重新排队：队列名称_IN，业务ID_IN 
      Zl_排队叫号队列_Delete(v_原队列名称, n_挂号id);
    
      v_排队号码 := Zlgetnextqueue(新执行科室_In, n_挂号id, v_号别 || '|' || n_号序);
      v_排队序号 := Zlgetsequencenum(0, n_挂号id, 2);
      --  队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,排队标记_In,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In, 排队时间_In 
      Zl_排队叫号队列_Insert(新执行科室_In, 0, n_挂号id, 新执行科室_In, v_排队号码, Null, v_病人姓名, n_病人id, 新诊室_In, 新医生_In, d_排队时间, v_预约方式,
                       Null, v_排队序号);
      Select Nvl(Max(回诊序号), 0) + 1 Into n_回诊序号 From 排队叫号队列; --更新回诊序号 
      Update 排队叫号队列 Set 回诊序号 = n_回诊序号 Where 业务类型 = 0 And 业务id = n_挂号id;
    Else
      v_排队号码 := Zlgetnextqueue(新执行科室_In, n_挂号id, v_号别 || '|' || n_号序);
      v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
      --  队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,排队标记_In,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In, 排队时间_In 
      Zl_排队叫号队列_Insert(新执行科室_In, 0, n_挂号id, 新执行科室_In, v_排队号码, Null, v_病人姓名, n_病人id, 新诊室_In, 新医生_In, d_排队时间, v_预约方式,
                       Null, v_排队序号);
      Select Nvl(Max(回诊序号), 0) + 1 Into n_回诊序号 From 排队叫号队列; --更新回诊序号 
      Update 排队叫号队列 Set 回诊序号 = n_回诊序号 Where 业务类型 = 0 And 业务id = n_挂号id;
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人挂号记录_回诊;
/

--118584:刘兴洪,2018-01-22,增加免挂号模式
Create Or Replace Procedure Zl_病人挂号记录_签到
(
  Id_In       病人挂号记录.Id%Type,
  操作类型_In Integer := 0,
  预约方式_In 预约方式.名称%Type := Null,
  诊室_In     病人挂号记录.诊室%Type := Null,
  医生_In     病人挂号记录.执行人%Type := Null
  
) As
  --:操作类型_In:0-需要产生相关的排队记录或者重新签到,修改排队信息;1-不再处理排队记录,只作签到的标识填写； 
  Err_Item Exception;
  v_Err_Msg          Varchar2(200);
  n_挂号生成队列     Number;
  n_分诊台签到排队   Number;
  n_再次签到重新排队 Number;
  n_已排队           Number;
  v_原队列名称       排队叫号队列.队列名称%Type;
  v_现队列名称       排队叫号队列.队列名称%Type;
  v_病人姓名         病人挂号记录.姓名%Type;
  n_挂号id           病人挂号记录.Id%Type;
  n_执行部门id       病人挂号记录.执行部门id%Type;
  n_排队部门id       病人挂号记录.Id%Type;
  v_原始号码         排队叫号队列.排队号码%Type;
  v_排队号码         排队叫号队列.排队号码%Type;
  d_排队时间         排队叫号队列.排队时间%Type;
  v_诊室             病人挂号记录.诊室%Type;
  v_医生             病人挂号记录.执行人%Type;
  n_病人id           病人挂号记录.病人id%Type;
  v_号别             病人挂号记录.号别%Type;
  n_号序             病人挂号记录.号序%Type;
  v_排队序号         排队叫号队列.排队序号%Type;
  n_记录性质         病人挂号记录.记录性质%Type;
  d_发生时间         病人挂号记录.发生时间%Type;
  n_转诊             Number;
  n_换号             Number;
  v_挂号单           病人挂号记录.No%Type;
  v_预约方式         病人挂号记录.预约方式%Type;
  n_免挂号模式       Number;
  v_No               病人挂号记录.No%Type;
Begin
  --:记录标志:0表示就诊病人,1-表示签到的病人,2-表示需要回诊就诊的病人; 3-表示已回诊但还未接收的病人; 
  Update 病人挂号记录
  Set 记录标志 = 1, 诊室 = Nvl(诊室_In, 诊室), 执行人 = Nvl(医生_In, 执行人)
  Where ID = Id_In
  Returning 预约方式, NO Into v_预约方式, v_No;

  If Sql%NotFound Then
    v_Err_Msg := '挂号项目未找到,不能继续操作!';
    Raise Err_Item;
  End If;
  Update 门诊费用记录
  Set 执行人 = Nvl(医生_In, 执行人), 发药窗口 = Nvl(诊室_In, 发药窗口)
  Where NO = v_No And 记录性质 = 4 And 记录状态 In (0, 1, 3);

  If Nvl(操作类型_In, 0) = 1 Then
    Return;
  End If;

  If 预约方式_In Is Not Null Then
    v_预约方式 := 预约方式_In;
  End If;

  n_挂号生成队列     := Zl_To_Number(Zl_Getsysparameter('排队叫号模式', 1113));
  n_分诊台签到排队   := Zl_To_Number(Zl_Getsysparameter('分诊台签到排队', 1113));
  n_再次签到重新排队 := Zl_To_Number(Zl_Getsysparameter('再次签到需重新排队', 1113));

  n_免挂号模式 := Zl_To_Number(Zl_Getsysparameter('免挂号模式', 0));
  If Nvl(n_免挂号模式, 0) = 1 And Nvl(n_分诊台签到排队, 0) = 0 Then
    n_分诊台签到排队 := 1;
  End If;

  If n_挂号生成队列 = 0 Then
    Return;
  End If;

  Begin
    Select 1, 科室id, 排队号码, 队列名称
    Into n_已排队, n_排队部门id, v_原始号码, v_原队列名称
    From 排队叫号队列
    Where 业务id = Id_In And 业务类型 = 0;
  Exception
    When Others Then
      n_已排队 := 0;
  End;
  --如果有排队记录，说明是重新签到，不应该退出 
  If Nvl(n_分诊台签到排队, 0) = 0 And Nvl(n_已排队, 0) = 0 Then
    Return;
  End If;

  Begin
    Select ID, Nvl(转诊科室id, 执行部门id), 姓名, Decode(转诊科室id, Null, 诊室, 转诊诊室), Decode(转诊科室id, Null, 执行人, 转诊医生), 病人id,
           Nvl(转诊号别, 号别), 号序, Nvl(记录性质, 0), Decode(转诊科室id, Null, 0, 1), NO, 发生时间
    Into n_挂号id, n_执行部门id, v_病人姓名, v_诊室, v_医生, n_病人id, v_号别, n_号序, n_记录性质, n_转诊, v_挂号单, d_发生时间
    From 病人挂号记录
    Where ID = Id_In And Rownum = 1;
  Exception
    When Others Then
      n_挂号id := -1;
  End;

  Begin
    Select 1 Into n_换号 From 就诊变动记录 Where 挂号单 = v_挂号单 And Rownum = 1;
  Exception
    When Others Then
      n_换号 := 0;
  End;

  v_现队列名称 := n_执行部门id;
  If n_挂号id > 0 Then
    If n_已排队 > 0 And (Nvl(n_再次签到重新排队, 0) = 0 Or Nvl(n_记录性质, 0) = 2) Then
      v_排队号码 := Zl_Get_Requeue(0, n_挂号id, n_执行部门id, v_医生, v_诊室);
      --重新获取排队时间 
      d_排队时间 := Zl_Get_Requeuedate(0, n_挂号id, n_执行部门id, v_医生, v_诊室);
      If v_原始号码 <> v_排队号码 Then
        --重新获取序号 
        v_排队序号 := Zlgetsequencenum(0, n_挂号id, 1);
        --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In , 医生姓名_In 
        Zl_排队叫号队列_Update(v_现队列名称, 0, n_挂号id, n_执行部门id, v_病人姓名, v_诊室, v_医生, v_排队号码, v_排队序号, d_排队时间);
      Else
        --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In , 医生姓名_In 
        Zl_排队叫号队列_Update(v_现队列名称, 0, n_挂号id, n_执行部门id, v_病人姓名, v_诊室, v_医生);
      End If;
    Elsif n_已排队 > 0 Then
      --重新排队 
      v_排队号码 := Zlgetnextqueue(n_执行部门id, n_挂号id, v_号别 || '|' || n_号序);
      v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
      --重新获取排队时间 
      d_排队时间 := Zl_Get_Requeuedate(0, n_挂号id, n_执行部门id, v_医生, v_诊室);
      --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In , 医生姓名_In 
      Zl_排队叫号队列_Update(v_现队列名称, 0, n_挂号id, n_执行部门id, v_病人姓名, v_诊室, v_医生, v_排队号码, v_排队序号, d_排队时间);
    Else
      --正常排队 
      For v_队列 In (Select 队列名称, 业务id
                   From 排队叫号队列
                   Where 病人id = n_病人id And 业务类型 = 0 And Trunc(排队时间) < Sysdate) Loop
        --删除原来排队记录重新排队：队列名称_IN，业务ID_IN 
        Zl_排队叫号队列_Delete(v_队列.队列名称, v_队列.业务id);
      End Loop;
    
      v_排队号码 := Zlgetnextqueue(n_执行部门id, n_挂号id, v_号别 || '|' || n_号序);
      v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
      --重新获取排队时间 
      If n_转诊 = 1 Then
        d_排队时间 := Zl_Get_Requeuedate(2, n_挂号id, n_执行部门id, v_医生, v_诊室);
      Elsif n_换号 = 1 Then
        d_排队时间 := Zl_Get_Requeuedate(3, n_挂号id, n_执行部门id, v_医生, v_诊室);
      Else
        d_排队时间 := Zl_Get_Requeuedate(-1, n_挂号id, n_执行部门id, v_医生, v_诊室);
      End If;
      --  队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,排队标记_In,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In, 排队时间_In 
      Zl_排队叫号队列_Insert(v_现队列名称, 0, n_挂号id, n_执行部门id, v_排队号码, Null, v_病人姓名, n_病人id, v_诊室, v_医生, d_排队时间, v_预约方式, Null,
                       v_排队序号);
    End If;
    Update 排队叫号队列 Set 排队状态 = 0 Where 业务id = n_挂号id And 业务类型 = 0;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人挂号记录_签到;
/

--118584:刘兴洪,2018-01-26,增加免挂号模式
Create Or Replace Procedure Zl_门诊分诊取号_Insert
(
  病人id_In     病人信息.病人id%Type,
  记录id_In     临床出诊记录.Id%Type,
  安排id_In     挂号安排.Id%Type,
  单据号_In     病人挂号记录.No%Type,
  诊室_In       门诊诊室.名称%Type,
  医生姓名_In   挂号安排.医生姓名%Type,
  医生id_In     挂号安排.医生id%Type,
  开单部门id_In 门诊费用记录.开单部门id%Type,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  退号重用_In   Integer := 0,
  站点_In       Varchar2 := Null
) As
  ---------------------------------------------------------------------------
  --功能:主要应用于免挂号模式,即只在分诊取号，然后接诊生成划价单进行收费方式
  --参数:
  ----------------------------------------------------------------------------

  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_费别   费别.名称%Type;
  v_姓名   病人信息.姓名%Type;
  v_年龄   病人信息.年龄%Type;
  v_性别   病人信息.性别%Type;
  n_门诊号 病人信息.门诊号%Type;

  v_号码       临床出诊号源.号码%Type;
  n_科室id     临床出诊号源.科室id%Type;
  n_项目id     临床出诊号源.项目id%Type;
  n_是否分时段 临床出诊记录.是否分时段%Type;
  n_已挂数     临床出诊记录.已挂数%Type;
  n_已约数     临床出诊记录.已约数%Type;
  n_结帐id     病人结帐记录.Id%Type;
  n_限号数     临床出诊记录.限号数%Type;
  n_限约数     临床出诊记录.限约数%Type;
  n_序号_Out   挂号序号状态.序号%Type;

  n_应收金额 门诊费用记录.应收金额%Type;
  n_序号     门诊费用记录.序号%Type;
  n_价格父号 门诊费用记录.价格父号%Type;
  n_从属父号 门诊费用记录.从属父号%Type;

  d_开始时间 Date;
  n_生成队列 Number(3);
  v_Temp     Varchar2(4000);

  v_现金     结算方式.名称%Type;
  v_机器名   挂号序号状态.机器名%Type;
  v_排队号码 排队叫号队列.排队号码%Type;
  v_排队序号 排队叫号队列.排队序号%Type;
  v_队列名称 排队叫号队列.队列名称%Type;

  n_费用id 门诊费用记录.Id%Type;
  n_预交id 病人预交记录.Id%Type;
  n_挂号id 病人挂号记录.Id%Type;

  n_组id 财务缴款分组.Id%Type;

  n_序号控制       挂号安排.序号控制%Type;
  n_分诊台签到排队 Number;
  n_Count          Number;
  d_排队时间       Date;
  v_星期           挂号安排限制.限制项目%Type;

  v_付款方式编码 医疗付款方式.编码%Type;
  v_付款方式名称 医疗付款方式.名称%Type;

  d_登记时间 Date;
  d_发生时间 Date;

  v_药品等级 收费价格等级.名称%Type;
  v_卫材等级 收费价格等级.名称%Type;
  v_普通等级 收费价格等级.名称%Type;
  n_金额小数 Number;
  n_单价小数 Number;
Begin
  --获取当前机器名称

  Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
  Begin
    n_Count := 1;
    Select a.姓名, a.年龄, a.性别, a.费别, a.门诊号, b.编码, b.名称
    Into v_姓名, v_年龄, v_性别, v_费别, n_门诊号, v_付款方式编码, v_付款方式名称
    From 病人信息 A, 医疗付款方式 B
    Where a.病人id = 病人id_In And a.医疗付款方式 = b.名称(+);
  Exception
    When Others Then
      n_Count := 0;
  End;

  If n_Count = 0 Then
    v_Err_Msg := '无法确定病人信息，不能取号操作！';
    Raise Err_Item;
  End If;

  If v_费别 Is Null Then
    Select Max(名称) Into v_费别 From 费别 Where 缺省标志 = 1 And Rownum < 2;
    If v_费别 Is Null Then
      v_Err_Msg := '无法确定病人费别，请检查缺省费别是否正确设置！';
      Raise Err_Item;
    End If;
  End If;
  v_Temp := Zl_Get_Pricegrade(站点_In, 病人id_In, 0, v_付款方式名称);

  For c_价格等级 In (Select Rownum As 序号, Column_Value As 价格等级 From Table(f_Str2list(v_Temp, '|'))) Loop
    If c_价格等级.序号 = 1 Then
      v_普通等级 := c_价格等级.价格等级;
    End If;
    If c_价格等级.序号 = 2 Then
      v_药品等级 := c_价格等级.价格等级;
    End If;
    If c_价格等级.序号 = 3 Then
      v_卫材等级 := c_价格等级.价格等级;
    End If;
  End Loop;

  n_组id     := Zl_Get组id(操作员姓名_In);
  d_登记时间 := Sysdate;
  d_发生时间 := Sysdate;

  --金额小数位数
  Select Zl_To_Number(Nvl(Zl_Getsysparameter(9), '2')), Zl_To_Number(Nvl(Zl_Getsysparameter(157), '5'))
  Into n_金额小数, n_单价小数
  From Dual;

  v_现金 := '现金';
  Select Decode(To_Char(d_发生时间, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null)
  Into v_星期
  From Dual;

  --挂号获取安排
  Begin
    n_Count := 1;
    If 记录id_In <> 0 Then
      --避免并发锁
      Select a.是否序号控制, Nvl(a.限号数, 0), Nvl(a.限约数, 0), b.号码, a.科室id, a.项目id, 是否分时段, 已挂数, 已约数
      Into n_序号控制, n_限号数, n_限约数, v_号码, n_科室id, n_项目id, n_是否分时段, n_已挂数, n_已约数
      From 临床出诊记录 A, 临床出诊号源 B
      Where a.Id = 记录id_In And a.号源id = b.Id
      For Update;
    Else
    
      Select Max(1) Into n_是否分时段 From 挂号安排时段 Where 安排id = 安排id_In And 星期 = v_星期 And Rownum < 2;
      Select a.序号控制, Nvl(b.限号数, 0), Nvl(b.限约数, 0), a.号码, a.科室id, a.项目id
      Into n_序号控制, n_限号数, n_限约数, v_号码, n_科室id, n_项目id
      From 挂号安排 A, 挂号安排限制 B
      Where a.Id = b.安排id(+) And b.限制项目(+) = v_星期 And a.Id = 安排id_In;
    
      Begin
        Select 已挂数, 已约数
        Into n_已挂数, n_已约数
        From 病人挂号汇总
        Where 日期 = Trunc(d_发生时间) And 科室id = n_科室id And 项目id = n_项目id And 号码 = v_号码 And Rownum < 2
        For Update; --避免并发锁
      Exception
        When Others Then
          n_已挂数 := 0;
      End;
    End If;
  Exception
    When Others Then
      n_Count := 0;
  End;

  If n_Count = 0 Then
    v_Err_Msg := '不存相应的挂号安排数据,请检查';
    Raise Err_Item;
  End If;

  --检查数量是否充足
  If n_限号数 <= n_已挂数 And n_限号数 > 0 Then
    v_Err_Msg := '号别' || v_号码 || '在' || To_Char(Trunc(d_发生时间), 'yyyy-mm-dd ') || '已达到最大限制数！';
    Raise Err_Item;
  End If;

  --锁号操作
  If Nvl(n_序号控制, 0) = 1 Then
    If Nvl(记录id_In, 0) = 0 Then
    
      --1.传统模式
      Zl_挂号安排_传统_Lockno(2, v_号码, d_发生时间, Null, n_序号_Out, v_机器名, 操作员姓名_In, 安排id_In, Null, 0, 操作员姓名_In || '锁号', Null,
                        Null);
      If Nvl(n_序号_Out, 0) = 0 Then
        v_Err_Msg := '未找到有效的号序,可能该号源已经使用完,请检查';
        Raise Err_Item;
      End If;
    
      Update 挂号序号状态
      Set 状态 = 1
      Where 号码 = v_号码 And 序号 = n_序号_Out And 日期 Between Trunc(d_发生时间) And (Trunc(d_发生时间) + 1 - 1 / 24 / 60 / 60) And
            Nvl(状态, 0) = 5;
    
      If Sql%NotFound Then
        v_Err_Msg := '未找到序号' || n_序号_Out || '的相关记录,请检查';
        Raise Err_Item;
      End If;
    
      If n_是否分时段 = 1 Then
      
        Begin
          Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'HH24:mi:ss'), 'yyyy-mm-dd HH24:mi:ss'),
                 1
          Into d_开始时间, n_Count
          From 挂号安排时段
          Where 安排id = 安排id_In And 星期 = v_星期 And 序号 = n_序号_Out;
        Exception
          When Others Then
            n_Count := 0;
        End;
        If n_Count = 0 Then
        
          Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || ' ' || To_Char(Max(结束时间), 'HH24:mi:ss'),
                          'yyyy-mm-dd HH24:mi:ss')
          Into d_开始时间
          From 挂号安排时段
          Where 安排id = 安排id_In And 星期 = v_星期;
          If d_发生时间 > d_开始时间 Then
            d_开始时间 := d_发生时间;
          End If;
        End If;
      
        d_发生时间 := d_开始时间;
      
      End If;
    Else
      --2.临床出诊模式
    
      Zl_挂号安排_临床出诊_Lockno(2, 记录id_In, d_发生时间, Null, n_序号_Out, 0, 操作员姓名_In || '锁号', v_机器名, 操作员姓名_In, Null, Null, Null,
                          v_号码);
      If Nvl(n_序号_Out, 0) = 0 Then
        v_Err_Msg := '未找到有效的号序,可能该号源已经使用完,请检查';
        Raise Err_Item;
      End If;
    
      Update 临床出诊序号控制
      Set 挂号状态 = 1
      Where 记录id = 记录id_In And 序号 = n_序号_Out
      Returning 开始时间 Into d_开始时间;
    
      If Sql%NotFound Then
        v_Err_Msg := '未找到序号' || n_序号_Out || '的相关记录,请检查';
        Raise Err_Item;
      End If;
    
      If To_Char(d_开始时间, 'HH:MM:DD') <> '00:00:00' And Nvl(n_是否分时段, 0) = 1 Then
        d_发生时间 := d_开始时间;
      End If;
    
    End If;
  End If;

  --产生挂号费为零的记录

  Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;

  n_序号     := 1;
  n_价格父号 := Null;
  n_从属父号 := Null;
  n_费用id   := Null;

  For c_价格 In (Select 1 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次, c.Id As 收入项目id,
                      c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, -1 As 执行科室类型
               From 收费项目目录 A, 收费价目 B, 收入项目 C
               Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = n_项目id And Sysdate Between b.执行日期 And
                     Nvl(b.终止日期, Sysdate + 1) And
                     ((b.价格等级 Is Null And Nvl(v_普通等级, '-') = '-') Or b.价格等级 = Nvl(v_普通等级, '-') Or
                     (b.价格等级 Is Null And Not Exists
                      (Select 1
                        From 收费价目
                        Where b.收费细目id = 收费细目id And 价格等级 = Nvl(v_普通等级, '-') And Sysdate Between 执行日期 And
                              Nvl(终止日期, Sysdate + 1))))
               Union All
               Select 2 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, d.从项数次 As 数次,
                      c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, -1 As 执行科室类型
               From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费从属项目 D
               Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = d.从项id And d.主项id = n_项目id And
                     Sysdate Between b.执行日期 And Nvl(b.终止日期, Sysdate + 1) And
                     ((b.价格等级 Is Null And Nvl(v_普通等级, '-') = '-') Or b.价格等级 = Nvl(v_普通等级, '-') Or
                     (b.价格等级 Is Null And Not Exists
                      (Select 1
                        From 收费价目
                        Where b.收费细目id = 收费细目id And 价格等级 = Nvl(v_普通等级, '-') And Sysdate Between 执行日期 And
                              Nvl(终止日期, Sysdate + 1))))
               Order By 性质, 项目id, 收入项目id) Loop
    Select 病人费用记录_Id.Nextval Into n_费用id From Dual;
    n_应收金额 := Round(c_价格.数次 * c_价格.单价, n_金额小数);
  
    Insert Into 门诊费用记录
      (ID, 记录性质, 记录状态, 序号, 价格父号, 从属父号, NO, 实际票号, 门诊标志, 加班标志, 附加标志, 发药窗口, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 病人科室id, 收费类别,
       计算单位, 收费细目id, 收入项目id, 收据费目, 付数, 数次, 标准单价, 应收金额, 实收金额, 结帐金额, 结帐id, 记帐费用, 开单部门id, 开单人, 划价人, 执行部门id, 执行人, 操作员编号,
       操作员姓名, 发生时间, 登记时间, 保险大类id, 保险项目否, 保险编码, 统筹金额, 摘要, 结论, 缴款组id)
    Values
      (n_费用id, 4, 1, n_序号, n_价格父号, n_从属父号, 单据号_In, Null, 1, 0, 0, 诊室_In, Decode(病人id_In, 0, Null, 病人id_In),
       Decode(n_门诊号, 0, Null, n_门诊号), v_付款方式编码, v_姓名, v_性别, v_年龄, v_费别, n_科室id, c_价格.类别, v_号码, c_价格.项目id, c_价格.收入项目id,
       c_价格.收据费目, 1, c_价格.数次, c_价格.单价, n_应收金额, 0, 0, n_结帐id, 0, 开单部门id_In, 操作员姓名_In, 操作员姓名_In, n_科室id, 医生姓名_In, 操作员编号_In,
       操作员姓名_In, d_发生时间, d_登记时间, Null, Null, Null, Null, Null, Null, n_组id);
  
    If c_价格.性质 = 1 And n_价格父号 Is Null Then
    
      n_价格父号 := n_序号;
      n_从属父号 := Null;
    End If;
    If c_价格.性质 = 2 And n_从属父号 Is Null Then
      n_价格父号 := Null;
      n_从属父号 := n_序号;
    End If;
    n_序号 := n_序号 + 1;
  End Loop;

  If n_费用id Is Null Then
    v_Err_Msg := '未找到相关的费用数据,请设置对应的挂号费用!';
    Raise Err_Item;
  End If;

  Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
  Insert Into 病人预交记录
    (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
     结算性质)
  Values
    (n_预交id, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), v_现金, 0, d_登记时间, 操作员编号_In, 操作员姓名_In, n_结帐id, Null, n_组id,
     Null, Null, Null, Null, Null, Null, 4);

  Update 病人信息 Set 就诊时间 = d_发生时间, 就诊状态 = 1, 就诊诊室 = 诊室_In Where 病人id = 病人id_In;

  Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;

  Insert Into 病人挂号记录
    (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 预约时间, 操作员编号,
     操作员姓名, 复诊, 号序, 社区, 预约, 预约方式, 摘要, 交易流水号, 交易说明, 合作单位, 接收时间, 接收人, 预约操作员, 预约操作员编号, 险类, 医疗付款方式, 收费单, 取号标志, 记录标志, 出诊记录id)
  Values
    (n_挂号id, 单据号_In, 1, 1, Decode(病人id_In, 0, Null, 病人id_In), n_门诊号, v_姓名, v_性别, v_年龄, v_号码, 0, 诊室_In, Null, n_科室id,
     医生姓名_In, 0, Null, d_登记时间, d_发生时间, Null, 操作员编号_In, 操作员姓名_In, 0, n_序号_Out, Null, 0, Null, '', Null, Null, Null,
     d_登记时间, 操作员姓名_In, Null, Null, Null, v_付款方式名称, Null, 1, 1, Decode(Nvl(记录id_In, 0), 0, Null, 记录id_In));

  n_生成队列 := Zl_To_Number(Zl_Getsysparameter('排队叫号模式', 1113));

  --0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站
  If Nvl(n_生成队列, 0) <> 0 Then
  
    --产生队列
    --.按”执行部门” 的方式生成队列
    v_队列名称 := n_科室id;
    v_排队号码 := Zlgetnextqueue(n_科室id, n_挂号id, v_号码 || '|' || n_序号_Out);
    v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
    d_排队时间 := Zl_Get_Queuedate(n_挂号id, v_号码, n_序号_Out, d_发生时间);
    --  队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,排队标记_In,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In, 排队时间_In
    Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, n_科室id, v_排队号码, Null, v_姓名, 病人id_In, 诊室_In, 医生姓名_In, d_排队时间, Null, Null, v_排队序号);
  End If;

  --生成汇总数据
  If Nvl(记录id_In, 0) <> 0 Then
    Update 临床出诊记录 Set 已挂数 = Nvl(已挂数, 0) + 1 Where ID = 记录id_In;
  End If;

  Zl_病人挂号汇总_Update(医生姓名_In, 医生id_In, n_项目id, n_科室id, d_发生时间, 0, v_号码, 0, 记录id_In);

  --消息推送
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 1, n_挂号id;
  Exception
    When Others Then
      Null;
  End;
  b_Message.Zlhis_Regist_001(n_挂号id, 单据号_In);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_门诊分诊取号_Insert;
/

--118584:刘兴洪,2018-02-12,增加免挂号模式
Create Or Replace Procedure Zl_分诊预约接收_取号
(
  No_In         门诊费用记录.No%Type,
  诊室_In       门诊费用记录.发药窗口%Type,
  病人id_In     门诊费用记录.病人id%Type,
  医生姓名_In   门诊费用记录.执行人 %Type := Null,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  登记时间_In   门诊费用记录.登记时间%Type := Null,
  摘要_In       病人挂号记录.摘要%Type := Null,
  险类_In       病人挂号记录.险类%Type := Null
) As

  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  n_Count    Number(18);
  n_排队     Number;
  n_当天排队 Number;
  n_生成队列 Number(3);
  d_Date     Date;

  v_排队号码 排队叫号队列.排队号码%Type;
  v_队列名称 排队叫号队列.队列名称%Type;
  v_排队序号 排队叫号队列.排队序号%Type;
  d_排队时间 排队叫号队列.排队时间%Type;

  d_预约时间   门诊费用记录.发生时间%Type;
  d_发生时间   门诊费用记录.发生时间%Type;
  n_出诊记录id 病人挂号记录.出诊记录id%Type;
  v_操作员姓名 病人挂号记录.接收人%Type;
  v_预约方式   病人挂号记录.预约方式 %Type;
  n_挂号id     病人挂号记录.Id%Type;
  n_组id       财务缴款分组.Id%Type;

  n_记录状态   病人挂号记录.记录状态%Type;
  n_号序       病人挂号记录.号序%Type;
  v_号码       病人挂号记录.号别%Type;
  n_预交id     病人预交记录.Id%Type;
  n_号源id     临床出诊号源.Id%Type;
  n_结帐id     病人结帐记录.Id%Type;
  n_安排id     挂号安排.Id%Type;
  n_计划id     挂号安排计划.Id%Type;
  n_是否分时段 临床出诊记录.是否分时段%Type := 0;

  n_接收模式 Number := 0;
  v_Paratemp Varchar2(100);
  d_启用时间 Date;
  n_挂号模式 Number(3);

Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  n_生成队列 := To_Number(Nvl(Zl_Getsysparameter('排队叫号模式', 1113), 0));

  --0-预约接收立即就诊模式 1-预约接收不就诊模式 
  n_接收模式 := Nvl(Zl_Getsysparameter('预约接收模式', 1111), 0);
  v_Paratemp := Nvl(Zl_Getsysparameter('挂号排班模式'), 0);
  n_接收模式 := Nvl(Zl_Getsysparameter('预约接收模式', 1111), 0);

  If n_挂号模式 = 1 Then
    Begin
      d_启用时间 := To_Date(Substr(v_Paratemp, 3), 'yyyy-mm-dd hh24:mi:ss');
    Exception
      When Others Then
        d_启用时间 := Null;
    End;
  End If;

  If 登记时间_In Is Null Then
    Select Sysdate Into d_Date From Dual;
  Else
    d_Date := 登记时间_In;
  End If;

  --更新挂号序号状态
  Begin
    Select 号别, 号序, Trunc(发生时间), 发生时间, 预约方式, 记录状态, 记录性质, 接收人, 出诊记录id
    Into v_号码, n_号序, d_预约时间, d_发生时间, v_预约方式, n_记录状态, n_Count, v_操作员姓名, n_出诊记录id
    From 病人挂号记录 A
    Where 记录状态 In (1, 3) And NO = No_In And Rownum < 2;
  Exception
    When Others Then
      n_Count := -1;
  End;

  If n_Count = -1 Then
    v_Err_Msg := '预约挂号单:' || No_In || '不存在';
    Raise Err_Item;
  End If;

  If n_Count = 1 Then
    If n_记录状态 = 3 Then
      v_Err_Msg := '预约挂号单:' || No_In || '已经被退号';
      Raise Err_Item;
    End If;
    If v_操作员姓名 <> 操作员姓名_In Then
      v_Err_Msg := '预约挂号单:' || No_In || '已被接收';
      Raise Err_Item;
    Else
      v_Err_Msg := '预约挂号单:' || No_In || '已被他人接收';
      Raise Err_Item;
    End If;
  End If;

  If d_启用时间 Is Not Null Then
    If d_发生时间 < d_启用时间 Then
      v_Err_Msg := '当前预约挂号单属于出诊表排班模式安排，不能在' || To_Char(d_启用时间, 'yyyy-mm-dd hh24:mi:ss') || '之前接收!';
      Raise Err_Item;
    End If;
  End If;
  
  --表示签道了
  UPDATE 病人挂号记录 SET 记录标志=1 WHERE no=no_In;

  --判断是否分时段
  n_出诊记录id := Nvl(n_出诊记录id, 0);
  If n_出诊记录id = 0 Then
    n_Count := 0;
    Select Max(ID) Into n_安排id From 挂号安排 Where 号码 = v_号码;
  
    Select Max(ID)
    Into n_计划id
    From 挂号安排计划 A
    Where a.安排id = n_安排id And 审核时间 Is Not Null And
          a.生效时间 = (Select Max(生效时间)
                    From 挂号安排计划 A
                    Where 安排id = n_安排id And Sysdate Between Nvl(生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                          Nvl(失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And 审核时间 Is Not Null);
    If Nvl(n_计划id, 0) = 0 Then
      Select Max(1) Into n_是否分时段 From 挂号安排时段 A Where a.安排id = n_安排id And Rownum < 2;
    Else
      Select Max(1) Into n_是否分时段 From 挂号计划时段 A Where a.计划id = n_计划id And Rownum < 2;
    End If;
  Else
    --判断是否分时段
    Select Nvl(是否分时段, 0), 号源id Into n_是否分时段, n_号源id From 临床出诊记录 Where ID = n_出诊记录id;
  End If;

  --分时段的号别，只能当天接收
  If n_是否分时段 = 1 Then
    If Trunc(d_发生时间) <> Trunc(Sysdate) Then
      v_Err_Msg := '分时段的预约挂号单只能取当天号！';
      Raise Err_Item;
    End If;
  End If;

  If n_是否分时段 = 0 Then
    --0-预约接收立即就诊模式 1-预约接收不就诊模式
    If n_接收模式 = 0 Then
      If Trunc(d_发生时间) <> Trunc(Sysdate) Then
        d_发生时间 := Sysdate;
      End If;
    End If;
  End If;

  If Not n_号序 Is Null Then
  
    If Trunc(d_预约时间) <> Trunc(Sysdate) And n_接收模式 = 0 Then
      If Nvl(n_出诊记录id, 0) = 0 Then
      
        --提前接收或延迟接收:先删除当天的预约时的序号
        Delete 挂号序号状态 Where 号码 = v_号码 And Trunc(日期) = Trunc(d_预约时间) And 序号 = n_号序;
      
        --锁当前时间的号
        Zl_挂号安排_传统_Lockno(2, v_号码, d_发生时间, Null, n_号序, Null, 操作员姓名_In, n_安排id, n_计划id, 0, 操作员姓名_In || '锁号', Null, Null);
        Update 挂号序号状态
        Set 状态 = 1, 登记时间 = Sysdate
        Where Trunc(日期) = Trunc(d_预约时间) And 序号 = n_号序 And 号码 = v_号码 And 状态 In (2, 5);
      Else
        --提前接收或延迟接收:先修改当天的预约时的序号
        Update 临床出诊序号控制 Set 挂号状态 = 0 Where 序号 = n_号序 And 记录id = n_出诊记录id;
        For c_旧安排 In (Select 是否分时段, 是否序号控制, 科室id, 医生id, 项目id, 上班时段
                      
                      From 临床出诊记录
                      Where ID = n_出诊记录id) Loop
        
          Begin
            n_Count := 1;
            Select ID
            Into n_出诊记录id
            From 临床出诊记录
            Where 号源id = n_号源id And 是否分时段 = c_旧安排.是否分时段 And 是否序号控制 = c_旧安排.是否序号控制 And 科室id = c_旧安排.科室id And
                  Nvl(医生id, 0) = Nvl(c_旧安排.医生id, 0) And 上班时段 = c_旧安排.上班时段 And Nvl(是否发布, 0) = 1 And
                  出诊日期 = Trunc(Sysdate) And Rownum < 2;
          Exception
            When Others Then
              n_Count := 0;
          End;
          If n_Count = 0 Then
            v_Err_Msg := '接收当天没有对应的出诊安排,无法接收!';
            Raise Err_Item;
          End If;
        
          Zl_挂号安排_临床出诊_Lockno(2, n_出诊记录id, d_发生时间, Null, n_号序, 0, 操作员姓名_In || '锁号', Null, 操作员姓名_In, Null, Null, Null,
                              v_号码);
        
          Update 临床出诊序号控制
          Set 挂号状态 = 1, 操作员姓名 = 操作员姓名_In
          Where 记录id = n_出诊记录id And 序号 = n_号序 And Nvl(挂号状态, 0) In (0, 5);

          Update 病人挂号记录 Set 出诊记录id = n_出诊记录id Where NO = No_In;
        
        End Loop;
      
      End If;
    Else
      If Nvl(n_出诊记录id, 0) = 0 Then
      
        Update 挂号序号状态
        Set 序号 = n_号序, 状态 = 1, 登记时间 = Sysdate
        Where 号码 = v_号码 And Trunc(日期) = Trunc(d_预约时间) And 序号 = n_号序;
        If Sql%Rowcount = 0 Then
          Begin
            n_Count := 1;
            Insert Into 挂号序号状态
              (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
            Values
              (v_号码, Trunc(d_发生时间), n_号序, 1, 操作员姓名_In, Sysdate);
          Exception
            When Others Then
              n_Count := 0;
          End;
          If n_Count = 0 Then
            v_Err_Msg := '序号' || n_号序 || '已被其它人使用,请重新选择一个序号.';
            Raise Err_Item;
          
          End If;
        End If;
      Else
        Update 临床出诊序号控制
        Set 挂号状态 = 1, 操作员姓名 = 操作员姓名_In
        Where (序号 = n_号序 Or 备注 = n_号序) And 记录id = n_出诊记录id;
        If Sql%Rowcount = 0 Then
          v_Err_Msg := '序号' || n_号序 || '已被其它人使用,请重新选择一个序号.';
          Raise Err_Item;
        End If;
      End If;
    End If;
  End If;

  Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  
  --更新病人信息，含就诊信息
  Update 病人信息 Set 就诊时间 = d_Date, 就诊状态 = 2, 就诊诊室 = 诊室_In Where 病人id = 病人id_In;
  If Sql%NotFound Then
    v_Err_Msg := '传入的病人信息(病人ID)无效，请检查.';
    Raise Err_Item;
  End If;
  For c_病人 In (Select a.病人id, a.门诊号, a.费别, a.姓名, a.性别, a.年龄, a.医疗付款方式, b.编码 As 医疗付款方式编码
               From 病人信息 A, 医疗付款方式 B
               Where a.医疗付款方式 = b.名称(+) And a.病人id = 病人id_In) Loop

    --更新门诊费用记录
    Update 门诊费用记录
    Set 记录状态 = 1, 实际票号 = Null, 结帐id = n_结帐id, 结帐金额 = 0,实收金额=0, 病人id = c_病人.病人id, 标识号 = c_病人.门诊号, 姓名 = c_病人.姓名, 年龄 = c_病人.年龄,
        性别 = c_病人.性别, 付款方式 = c_病人.医疗付款方式编码, 费别 = c_病人.费别, 发生时间 = d_发生时间, 登记时间 = d_Date, 操作员编号 = 操作员编号_In,
        操作员姓名 = 操作员姓名_In, 缴款组id = n_组id, 发药窗口 = 诊室_In, 执行人 = 医生姓名_In
    Where 记录性质 = 4 And 记录状态 = 0 And NO = No_In;
    --病人挂号记录
    Update 病人挂号记录
    Set 接收人 = 操作员姓名_In, 接收时间 = d_Date, 记录性质 = 1, 病人id = c_病人.病人id, 门诊号 = c_病人.门诊号, 发生时间 = d_发生时间, 姓名 = c_病人.姓名,
        性别 = c_病人.性别, 年龄 = c_病人.年龄, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In, 险类 = Decode(Nvl(险类_In, 0), 0, Null, 险类_In),
        号序 = n_号序, 诊室 = 诊室_In, 执行人 = 医生姓名_In, 摘要 = Nvl(摘要_In, 摘要),记录标志=1,取号标志=1
    Where 记录状态 = 1 And NO = No_In And 记录性质 = 2;
    If Sql%NotFound Then
      v_Err_Msg := '由于并发原因,单据号为【' || No_In || '】的病人' || c_病人.姓名 || '已经被接收';
      Raise Err_Item;
    End If;
  
    --保存预交记录
    Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
    Insert Into 病人预交记录
      (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 结算序号,
       结算性质)
    Values
      (n_预交id, 4, 1, No_In, c_病人.病人id, '现金', 0, d_Date, 操作员编号_In, 操作员姓名_In, n_结帐id, '挂号收费', n_组id, Null, Null, Null,
       Null, Null, n_结帐id, 4);
  
    --0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站
    If Nvl(n_生成队列, 0) <> 0 Then
    
      For v_挂号 In (Select ID, 姓名, 诊室, 执行人, 执行部门id, 发生时间, 号别, 号序 From 病人挂号记录 Where NO = No_In) Loop
        Begin
          Select 1,
                 Case
                   When 排队时间 < Trunc(Sysdate) Then
                    1
                   Else
                    0
                 End
          Into n_排队, n_当天排队
          From 排队叫号队列
          Where 业务类型 = 0 And 业务id = v_挂号.Id And Rownum <= 1;
        Exception
          When Others Then
            n_排队 := 0;
        End;
      
        If n_排队 = 0 Then
          --产生队列
          --按”执行部门”产生队列
          n_挂号id   := v_挂号.Id;
          v_队列名称 := v_挂号.执行部门id;
          v_排队号码 := Zlgetnextqueue(v_挂号.执行部门id, n_挂号id, v_挂号.号别 || '|' || v_挂号.号序);
          v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
        
          --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)
          d_排队时间 := Zl_Get_Queuedate(n_挂号id, v_挂号.号别, v_挂号.号序, v_挂号.发生时间);
          --   队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,排队标记_In,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In,
          Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, v_挂号.执行部门id, v_排队号码, Null, c_病人.姓名, 病人id_In, v_挂号.诊室, v_挂号.执行人, d_排队时间,
                           
                           v_预约方式, Null, v_排队序号);
        Elsif Nvl(n_当天排队, 0) = 1 Then
          --更新队列号
          v_排队号码 := Zlgetnextqueue(v_挂号.执行部门id, v_挂号.Id, v_挂号.号别 || '|' || Nvl(v_挂号.号序, 0));
          v_排队序号 := Zlgetsequencenum(0, v_挂号.Id, 1);
          --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In, 医生姓名_In ,排队号码_In
          Zl_排队叫号队列_Update(v_挂号.执行部门id, 0, v_挂号.Id, v_挂号.执行部门id, v_挂号.姓名, v_挂号.诊室, v_挂号.执行人, v_排队号码, v_排队序号);
        
        Else
          --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In, 医生姓名_In ,排队号码_In
          Zl_排队叫号队列_Update(v_挂号.执行部门id, 0, v_挂号.Id, v_挂号.执行部门id, v_挂号.姓名, v_挂号.诊室, v_挂号.执行人);
        End If;
        --预约接收时，改变记录标志
        Update 病人挂号记录 Set 记录标志 = 1 Where ID = n_挂号id;
      
      End Loop;
    End If;
  
  End Loop;

  --病人担保信息
  If 病人id_In Is Not Null Then
    Update 病人信息
    Set 担保人 = Null, 担保额 = Null, 担保性质 = Null
    Where 病人id = 病人id_In And Nvl(在院, 0) = 0 And Exists
     (Select 1
           From 病人担保记录
           Where 病人id = 病人id_In And 主页id Is Not Null And
                 登记时间 = (Select Max(登记时间) From 病人担保记录 Where 病人id = 病人id_In));
    If Sql%Rowcount > 0 Then
      Update 病人担保记录
      Set 到期时间 = d_Date
      Where 病人id = 病人id_In And 主页id Is Not Null And Nvl(到期时间, d_Date) >= d_Date;
    End If;
  End If;

  --消息推送
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 1, n_挂号id;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_分诊预约接收_取号;
/

--120885:刘兴洪,2018-02-05,增加显示序号
--118584:刘兴洪,2018-01-22,增加免挂号模式
Create Or Replace Function Zl_Fun_挂号安排_传统_Nextsn
(
  日期_In       In Date,
  安排id_In     In 挂号安排.Id%Type,
  计划id_In     In 挂号安排计划.Id%Type,
  操作员姓名_In 人员表.姓名%Type,
  星期_In       In 挂号安排限制.限制项目%Type := Null,
  备注_In       In 挂号序号状态.备注%Type := Null,
  机器名_In     In 挂号序号状态.机器名%Type := Null,
  合作单位_In   In Varchar2 := Null,
  是否加号_In   In Number := 0,
  是否预约_In   In Number := 0,
  是否锁号_In   In Number := 1
) Return Varchar2 Is
  --功能:根据指定安排，获取一下个序号(并进行相关的锁号操作)
  --入参:操作类型_In:0-挂号;1-预约
  --     是否加号_IN:0-不进行加号;1-进行加号处理
  --     是否锁号_In:是否进行相关的锁号操作,1-锁号;0-不进行锁号
  --返回:NULL:该挂号安排无需序号控制且不分时段或不启用序号控制且分时段但当前为挂号的
  --     非空:序号|序号开始时间(yyyy-mm-dd hh24:mm:ss)
  --     返回失败时，会抛出错误信息

  n_序号         Number(18);
  n_自锁号       Number(2);
  d_序号时间     Date;
  n_Rowid        Rowid;
  v_星期         挂号安排限制.限制项目%Type;
  v_机器名       挂号序号状态.操作员姓名%Type;
  v_操作员姓名   人员表.姓名%Type;
  n_序号控制     Number(3);
  n_分时段       Number(3);
  n_启用合作单位 Number(3);
  v_号码         挂号安排.号码%Type;
  d_Max_日期     Date;
  n_限号数       Number(18);
  n_限约数       Number(18);
  n_存在         Number(3);
  n_已挂数       Number(18);
  v_Temp         Varchar2(300);
  Err_Item Exception;

Begin
  v_星期 := 星期_In;
  If v_星期 Is Null Then
    Select Decode(To_Char(日期_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null)
    Into v_星期
    From Dual;
  End If;
  v_机器名 := 机器名_In;

  If v_机器名 Is Null Then
    Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
  End If;
  v_操作员姓名 := 操作员姓名_In;
  If v_操作员姓名 Is Null Then
    v_操作员姓名 := Zl_Username;
  End If;

  If Nvl(计划id_In, 0) <> 0 Then
    Select Max(a.序号控制), Max(b.号码)
    Into n_序号控制, v_号码
    From 挂号安排计划 A, 挂号安排 B
    Where a.Id = 计划id_In And a.安排id = b.Id;
  End If;

  If Nvl(安排id_In, 0) <> 0 Then
    Select Max(序号控制), Max(号码) Into n_序号控制, v_号码 From 挂号安排 Where ID = 安排id_In;
  End If;

  If Nvl(计划id_In, 0) <> 0 Then
    Select Nvl(Max(1), 0), Trunc(Max(开始时间))
    Into n_分时段, d_Max_日期
    From 挂号计划时段
    Where 星期 = v_星期 And 计划id = 计划id_In And Rownum < 2;
    If 合作单位_In Is Not Null Then
      Select Nvl(Max(1), 0)
      Into n_启用合作单位
      From 合作单位计划控制
      Where 限制项目 = v_星期 And 计划id = 计划id_In And 合作单位 = 合作单位_In And Rownum < 2;
    End If;
  Else
    Select Nvl(Max(1), 0), Trunc(Max(开始时间))
    Into n_分时段, d_Max_日期
    From 挂号安排时段
    Where 星期 = v_星期 And 安排id = 安排id_In And Rownum < 2;
    If 合作单位_In Is Not Null Then
      Select Nvl(Max(1), 0)
      Into n_启用合作单位
      From 合作单位安排控制
      Where 限制项目 = v_星期 And 安排id = 安排id_In And 合作单位 = 合作单位_In And Rownum < 2;
    End If;
  End If;

  n_序号 := Null;
  If Nvl(n_序号控制, 0) = 0 And Nvl(n_分时段, 0) = 0 Then
    --未启用序号控制和未分时段的,直接返回
    Return n_序号;
  End If;

  If Nvl(计划id_In, 0) <> 0 Then
    Select Max(限号数), Max(限约数)
    Into n_限号数, n_限约数
    From 挂号计划限制
    Where 计划id = 计划id_In And 限制项目 = v_星期;
  Else
    Select Max(限号数), Max(限约数)
    Into n_限号数, n_限约数
    From 挂号安排限制
    Where 安排id = 安排id_In And 限制项目 = v_星期;
  End If;

  --1.未启用序号控制处理
  If Nvl(n_序号控制, 0) = 0 Then
    --1.1 不是预约，无需返回序号
    If Nvl(是否预约_In, 0) = 0 Then
      Return n_序号;
    End If;
    --1.2 分时段且是预约的，需要取一下号(暂不处理,待以后扩展
    Return n_序号;
  End If;

  If Nvl(n_限约数, 0) = 0 Then
    n_限约数 := n_限号数;
  End If;

  --2.启用序号控制且分时段的处理
  If Nvl(n_分时段, 0) = 1 Then
    --2.1 先取未使用的序号(针对跨天的，不处理，因为分时段一般情况都不跨天)
    n_序号 := Null;
    For c_序号 In (Select 序号, Max(开始时间) As 开始时间
                 From (Select 序号, 开始时间
                        From 挂号安排时段
                        Where 安排id = Nvl(安排id_In, 0) And 星期 = v_星期 And
                              日期_In <= To_Date(To_Char(日期_In, 'yyyy-mm-dd') || ' ' || To_Char(结束时间, 'hh24:mi:ss'),
                                               'yyyy-mm-dd hh24:mi:ss') And
                              Nvl(是否预约, 0) = Decode(Nvl(是否预约_In, 0), 0, Nvl(是否预约, 0), 1)
                        Union All
                        Select 序号, 开始时间
                        From 挂号计划时段
                        Where 计划id = Nvl(计划id_In, 0) And 星期 = v_星期 And
                              日期_In <= To_Date(To_Char(日期_In, 'yyyy-mm-dd') || ' ' || To_Char(结束时间, 'hh24:mi:ss'),
                                               'yyyy-mm-dd hh24:mi:ss') And
                              Nvl(是否预约, 0) = Decode(Nvl(是否预约_In, 0), 0, Nvl(是否预约, 0), 1))
                 Where 序号 Not In
                       (Select 序号
                        From 挂号序号状态
                        Where 号码 = v_号码 And 日期 Between Trunc(日期_In) And Trunc(日期_In) + 1 - 1 / 24 / 60 / 60)
                 Group By 序号
                 Order By 序号) Loop
    
      --检查该序号是否被他人使用
      n_序号 := Nvl(c_序号.序号, 0);
      Begin
        Select Rowid, 1,
               Case
                 When 机器名 = v_机器名 And 操作员姓名 = v_操作员姓名 And 状态 = 5 Then
                  1
                 Else
                  0
               End
        Into n_Rowid, n_存在, n_自锁号
        From 挂号序号状态
        Where 号码 = v_号码 And 日期 Between Trunc(日期_In) And Trunc(日期_In) + 1 - 1 / 24 / 60 / 60 And 序号 = n_序号;
      Exception
        When Others Then
          n_存在   := 0;
          n_自锁号 := 0;
      End;
    
      If Nvl(n_存在, 0) = 1 And Nvl(n_自锁号, 0) = 1 Then
        If Nvl(是否锁号_In, 0) = 1 Then
          --自己锁的号，独站起:
          Update 挂号序号状态 Set 状态 = 5 Where Rowid = n_Rowid;
        End If;
        v_Temp := n_序号 || '|' || To_Char(日期_In, 'yyyy-mm-dd') || ' ' || To_Char(c_序号.开始时间, 'hh24:mi:ss');
        Return v_Temp;
      End If;
    
      If Nvl(n_存在, 0) = 0 Then
        --不存在，直接锁住该号
        d_序号时间 := To_Date(To_Char(日期_In, 'yyyy-mm-dd') || ' ' || To_Char(c_序号.开始时间, 'hh24:mi:ss'),
                          'yyyy-mm-dd hh24:mi:ss');
        If Nvl(是否锁号_In, 0) = 1 Then
          Insert Into 挂号序号状态
            (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
          Values
            (v_号码, d_序号时间, n_序号, 5, v_操作员姓名, 备注_In, Sysdate, v_机器名);
        End If;
      
        v_Temp := n_序号 || '|' || To_Char(d_序号时间, 'yyyy-mm-dd hh24:mi:ss');
        Return v_Temp;
      End If;
    End Loop;
  
    --2.2 再取最大号+1的序号(针对跨天的，不处理，因为分时段一般情况都不跨天)
    --    有加号权限，则不进行检查限号数
    If Nvl(是否加号_In, 0) = 0 Then
      --检查限号数是否充足
      If Nvl(是否预约_In, 0) = 0 Then
        Select Nvl(Sum(已挂数), 0)
        Into n_已挂数
        From 病人挂号汇总 A
        Where 日期 Between Trunc(日期_In) And Trunc(日期_In) + 1 - 1 / 24 / 60 / 60 And 号码 = v_号码;
        If n_已挂数 >= n_限号数 And Nvl(n_限号数, 0) <> 0 Then
          v_Temp := '号别' || v_号码 || '当前已无余号';
          Raise Err_Item;
        End If;
      Else
        Select Nvl(Sum(已约数), 0)
        Into n_已挂数
        From 病人挂号汇总 A
        Where 日期 Between Trunc(日期_In) And Trunc(日期_In) + 1 - 1 / 24 / 60 / 60 And 号码 = v_号码;
        If Nvl(n_已挂数, 0) >= n_限约数 And Nvl(n_限约数, 0) <> 0 Then
          v_Temp := '号别' || v_号码 || '当前已无余号';
          Raise Err_Item;
        End If;
      End If;
    End If;
  
    --取最大号+1
    Select Nvl(Max(序号), 0) + 1, Max(结束时间)
    Into n_序号, d_序号时间
    From (Select 序号, 结束时间
           From 挂号安排时段
           Where 安排id = Nvl(安排id_In, 0) And 星期 = v_星期
           Union All
           Select 序号, 结束时间
           From 挂号计划时段
           Where 计划id = Nvl(计划id_In, 0) And 星期 = v_星期
           Union All
           Select 序号, Null As 结束时间
           From 挂号序号状态 A
           Where 号码 = v_号码 And 日期 Between Trunc(日期_In) And Trunc(日期_In) + 1 - 1 / 24 / 60 / 60);
  
    v_Temp     := To_Char(d_序号时间, 'hh24:mi:ss');
    d_序号时间 := To_Date(To_Char(日期_In, 'yyyy-mm-dd') || To_Char(d_序号时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss');
    If Nvl(是否锁号_In, 0) = 1 Then
      Insert Into 挂号序号状态
        (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
      Values
        (v_号码, d_序号时间, n_序号, 5, v_操作员姓名, 备注_In, Sysdate, v_机器名);
    End If;
    v_Temp := n_序号 || '|' || To_Char(d_序号时间, 'yyyy-mm-dd hh24:mi:ss');
    Return v_Temp;
  End If;

  --3.启用序号控制但不分时段的处理
  n_序号 := Null;

  --3.1先判断未使用的序号
  Select Min(序号)
  Into n_序号
  From (Select Level As 序号
         From Dual
         Connect By Level <= Nvl(n_限号数, 0)
         Minus
         Select 序号
         From 挂号序号状态
         Where 号码 = v_号码 And 日期 Between Trunc(日期_In) And Trunc(日期_In) + 1 - 1 / 24 / 60 / 60 And
               (nvl(状态,0) <> 5 Or nvl(状态,0) = 5 And Nvl(机器名, '-') <> Nvl(v_机器名, '-') And Nvl(操作员姓名, '-') <> Nvl(v_操作员姓名, '-')));

  If Nvl(n_序号, 0) <> 0 Then
    If Nvl(是否锁号_In, 0) = 1 Then
      --存在:返回找到的序号
      Insert Into 挂号序号状态
        (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
      Values
        (v_号码, Trunc(日期_In), n_序号, 5, v_操作员姓名, 备注_In, Sysdate, v_机器名);
    End If;
    v_Temp := n_序号 || '|' || To_Char(Sysdate, 'yyyy-mm-dd hh24:mi:ss');
    Return v_Temp;
  End If;

  --已经补使用完的号，则需要最大号+1
  If Nvl(是否加号_In, 0) = 0 Then
    --检查限号数是否充足
    If Nvl(是否预约_In, 0) = 0 Then
      Select Nvl(Sum(已挂数), 0)
      Into n_已挂数
      From 病人挂号汇总 A
      Where 日期 Between Trunc(日期_In) And Trunc(日期_In) + 1 - 1 / 24 / 60 / 60 And 号码 = v_号码;
      If n_已挂数 >= n_限号数 And Nvl(n_限号数, 0) <> 0 Then
        v_Temp := '号别' || v_号码 || '当前已无余号';
        Raise Err_Item;
      End If;
    Else
      Select Nvl(Sum(已约数), 0)
      Into n_已挂数
      From 病人挂号汇总 A
      Where 日期 Between Trunc(日期_In) And Trunc(日期_In) + 1 - 1 / 24 / 60 / 60 And 号码 = v_号码;
      If Nvl(n_已挂数, 0) >= n_限约数 And Nvl(n_限约数, 0) <> 0 Then
        v_Temp := '号别' || v_号码 || '当前已无余号';
        Raise Err_Item;
      End If;
    End If;
  End If;
  Select Nvl(Max(序号), 0) + 1
  Into n_序号
  From 挂号序号状态 A
  Where 号码 = v_号码 And 日期 Between Trunc(日期_In) And Trunc(日期_In) + 1 - 1 / 24 / 60 / 60;
  If Nvl(是否锁号_In, 0) = 1 Then
    Insert Into 挂号序号状态
      (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
    Values
      (v_号码, Trunc(日期_In), n_序号, 5, v_操作员姓名, 备注_In, Sysdate, v_机器名);
  End If;
  v_Temp := n_序号 || '|' || To_Char(Sysdate, 'yyyy-mm-dd hh24:mi:ss');
  Return v_Temp;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Temp || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_Fun_挂号安排_传统_Nextsn;
/

--110624:刘涛,2018-01-22,领用增加修改人（日期）
Create Or Replace Procedure Zl_药品领用_Strike
(
  行次_In       In Integer,
  原记录状态_In In 药品收发记录.记录状态%Type,
  No_In         In 药品收发记录.No%Type,
  序号_In       In 药品收发记录.序号%Type,
  药品id_In     In 药品收发记录.药品id%Type,
  冲销数量_In   In 药品收发记录.实际数量%Type,
  填制人_In     In 药品收发记录.填制人%Type,
  填制日期_In   In 药品收发记录.填制日期%Type,
  冲销方式_In   In Integer := 0 --0－正常冲销方式；1－产生冲销申请单据；2－审核已产生的冲销申请单据  
) Is
  Err_Isstriked Exception;
  Err_Isoutstock Exception;
  Err_Isnonum Exception;
  Err_Isbatch Exception;
  v_Druginf Varchar2(50); --原不分批现在分批的药品信息 

  v_库房id       药品收发记录.库房id%Type;
  v_对方部门id   药品收发记录.对方部门id%Type;
  v_入出类别id   药品收发记录.入出类别id%Type;
  v_产地         药品收发记录.产地%Type;
  v_原产地       药品收发记录.原产地%Type;
  v_批次         药品收发记录.批次%Type;
  v_批号         药品收发记录.批号%Type;
  v_效期         药品收发记录.效期%Type;
  v_成本价       药品收发记录.成本价%Type;
  v_成本金额     药品收发记录.成本金额%Type;
  v_扣率         药品收发记录.扣率%Type;
  v_零售价       药品收发记录.零售价%Type;
  v_零售金额     药品收发记录.零售金额%Type;
  v_差价         药品收发记录.差价%Type;
  v_摘要         药品收发记录.摘要%Type;
  v_剩余数量     药品收发记录.实际数量%Type;
  v_剩余成本金额 药品收发记录.成本金额%Type;
  v_剩余零售金额 药品收发记录.零售金额%Type;
  v_入出系数     药品收发记录.入出系数%Type;

  v_收发id   药品收发记录.Id%Type;
  v_领用人   药品收发记录.领用人%Type;
  v_批准文号 药品收发记录.批准文号%Type;
  v_发药方式 药品收发记录.发药方式%Type;

  v_是否变价     收费项目目录.是否变价%Type;
  Intdigit       Number;
  n_上次供应商id 药品库存.上次供应商id%Type;
  d_上次生产日期 药品库存.上次生产日期%Type;
  v_按月留存领用 Varchar2(4000);
Begin
  --获取金额小数位数 
  Select Nvl(精度, 2) Into Intdigit From 药品卫材精度 Where 性质 = 0 And 类别 = 1 And 内容 = 4 And 单位 = 5;
  Select Nvl(是否变价, 0) Into v_是否变价 From 收费项目目录 Where Id = 药品id_In;
  Select Zl_Getsysparameter('按月留存领用', 1305) Into v_按月留存领用 From Dual;

  If 冲销方式_In = 1 Then
    --产生冲销申请单据，不填写审核人、审核日期，不更新库存记录 
    If 行次_In = 1 Then
      Update 药品收发记录
      Set 记录状态 = Decode(原记录状态_In, 1, 3, 原记录状态_In + 3)
      Where No = No_In And 单据 = 7 And 记录状态 = 原记录状态_In;
      If Sql%Rowcount = 0 Then
        Raise Err_Isstriked;
      End If;
    End If;
  
    --主要针对原不分批现在分批的药品，不能对其冲销
    Begin
      Select Distinct '(' || i.编码 || ')' || Nvl(n.名称, i.名称) As 药品信息
      Into v_Druginf
      From 药品收发记录 a, 药品规格 b, 收费项目目录 i, 收费项目别名 n
      Where a.药品id = b.药品id And a.药品id = i.Id And a.药品id = n.收费细目id(+) And n.性质(+) = 3 And a.No = No_In And a.单据 = 7 And
            Mod(a.记录状态, 3) = 0 And Nvl(a.批次, 0) = 0 And a.药品id + 0 = 药品id_In And
            ((Nvl(b.药库分批, 0) = 1 And
            a.库房id Not In (Select 部门id From 部门性质说明 Where (工作性质 Like '%药房') Or (工作性质 Like '制剂室'))) Or
            Nvl(b.药房分批, 0) = 1) And Rownum = 1;
    Exception
      When Others Then
        v_Druginf := '';
    End;
  
    If v_Druginf Is Not Null Then
      Raise Err_Isbatch;
    End If;
  
    Select Sum(实际数量) As 剩余数量, Sum(成本金额) As 剩余成本金额, Sum(零售金额) As 剩余零售金额, 库房id, 对方部门id, 入出类别id, 入出系数, 批次, 产地, 原产地, 批号, 效期, 成本价,
           扣率, 零售价, 摘要, 领用人, 批准文号, 发药方式, 供药单位id, 生产日期
    Into v_剩余数量, v_剩余成本金额, v_剩余零售金额, v_库房id, v_对方部门id, v_入出类别id, v_入出系数, v_批次, v_产地, v_原产地, v_批号, v_效期, v_成本价, v_扣率, v_零售价,
         v_摘要, v_领用人, v_批准文号, v_发药方式, n_上次供应商id, d_上次生产日期
    From 药品收发记录
    Where No = No_In And 单据 = 7 And 药品id = 药品id_In And 序号 = 序号_In
    Group By 库房id, 对方部门id, 入出类别id, 入出系数, 批次, 产地, 原产地, 批号, 效期, 成本价, 扣率, 零售价, 摘要, 领用人, 批准文号, 发药方式, 供药单位id, 生产日期;
  
    --冲销数量大于剩余数量，不允许 
    If v_剩余数量 < 冲销数量_In Then
      Raise Err_Isnonum;
    End If;
  
    v_成本金额 := Round(冲销数量_In / v_剩余数量 * v_剩余成本金额, Intdigit);
    v_零售金额 := Round(冲销数量_In / v_剩余数量 * v_剩余零售金额, Intdigit);
    v_差价     := v_零售金额 - v_成本金额;
  
    Select 药品收发记录_Id.Nextval Into v_收发id From Dual;
  
    Insert Into 药品收发记录
      (Id, 记录状态, 单据, No, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 原产地, 批号, 效期, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 零售金额, 差价, 摘要,
       填制人, 填制日期, 审核人, 审核日期, 领用人, 批准文号, 发药方式, 供药单位id, 生产日期, 扣率)
    Values
      (v_收发id, Decode(原记录状态_In, 1, 2, 原记录状态_In + 2), 7, No_In, 序号_In, v_库房id, v_对方部门id, v_入出类别id, v_入出系数, 药品id_In, v_批次,
       v_产地, v_原产地, v_批号, v_效期, -冲销数量_In, -冲销数量_In, v_成本价, -v_成本金额, v_零售价, -v_零售金额, -v_差价, v_摘要, 填制人_In, 填制日期_In, Null, Null,
       v_领用人, v_批准文号, v_发药方式, n_上次供应商id, d_上次生产日期, v_扣率);
    
    Zl_未审药品记录_Insert(v_收发id);
    
  Elsif 冲销方式_In = 2 Then
    --审核已产生的冲销申请单据，填写审核人、审核日期，更新库存记录 
  
    --填写审核人、审核日期 
    Update 药品收发记录
    Set 审核人 = 填制人_In, 审核日期 = 填制日期_In
    Where 单据 = 7 And No = No_In And 序号 = 序号_In And 记录状态 = 原记录状态_In;
  
    --查询当前行记录的对应ID
    Select Id
    Into v_收发id
    From 药品收发记录
    Where 单据 = 7 And No = No_In And 序号 = 序号_In And 记录状态 = 原记录状态_In;
  
    --更新库存信息 领用冲销相当于入库 
    Zl_药品库存_Update(v_收发id, 3, 0);
    
    Zl_未审药品记录_Delete(v_收发id);

    --科室药品留存处理 
    If v_发药方式 = 1 Then
      Update 药品留存
      Set 可用数量 = Nvl(可用数量, 0) + 冲销数量_In, 实际数量 = Nvl(实际数量, 0) + 冲销数量_In, 实际金额 = Nvl(实际金额, 0) + v_零售金额
      Where 期间 = To_Char(Sysdate, Decode(v_按月留存领用, '1', 'yyyymm', 'yyyy')) And 科室id = v_对方部门id And 库房id = v_库房id And
            药品id = 药品id_In;
      --将金额和数量等于0的记录删除掉 
      Delete From 药品留存 Where Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0;
    End If;
  
    --处理调价后冲销 
    Zl_药品收发记录_调价修正(v_收发id);
  Else
    --正常冲销方式，产生冲销记录，填写审核人、审核日期，更新库存记录      
    If 行次_In = 1 Then
      Update 药品收发记录
      Set 记录状态 = Decode(原记录状态_In, 1, 3, 原记录状态_In + 3)
      Where No = No_In And 单据 = 7 And 记录状态 = 原记录状态_In;
      If Sql%Rowcount = 0 Then
        Raise Err_Isstriked;
      End If;
    End If;
  
    --主要针对原不分批现在分批的药品，不能对其冲销
    Begin
      Select Distinct '(' || i.编码 || ')' || Nvl(n.名称, i.名称) As 药品信息
      Into v_Druginf
      From 药品收发记录 a, 药品规格 b, 收费项目目录 i, 收费项目别名 n
      Where a.药品id = b.药品id And a.药品id = i.Id And a.药品id = n.收费细目id(+) And n.性质(+) = 3 And a.No = No_In And a.单据 = 7 And
            Mod(a.记录状态, 3) = 0 And Nvl(a.批次, 0) = 0 And a.药品id + 0 = 药品id_In And
            ((Nvl(b.药库分批, 0) = 1 And
            a.库房id Not In (Select 部门id From 部门性质说明 Where (工作性质 Like '%药房') Or (工作性质 Like '制剂室'))) Or
            Nvl(b.药房分批, 0) = 1) And Rownum = 1;
    Exception
      When Others Then
        v_Druginf := '';
    End;
  
    If v_Druginf Is Not Null Then
      Raise Err_Isbatch;
    End If;
  
    Select Sum(实际数量) As 剩余数量, Sum(成本金额) As 剩余成本金额, Sum(零售金额) As 剩余零售金额, 库房id, 对方部门id, 入出类别id, 入出系数, 批次, 产地, 原产地, 批号, 效期, 成本价,
           扣率, 零售价, 摘要, 领用人, 批准文号, 发药方式, 供药单位id, 生产日期
    Into v_剩余数量, v_剩余成本金额, v_剩余零售金额, v_库房id, v_对方部门id, v_入出类别id, v_入出系数, v_批次, v_产地, v_原产地, v_批号, v_效期, v_成本价, v_扣率, v_零售价,
         v_摘要, v_领用人, v_批准文号, v_发药方式, n_上次供应商id, d_上次生产日期
    From 药品收发记录
    Where No = No_In And 单据 = 7 And 药品id = 药品id_In And 序号 = 序号_In
    Group By 库房id, 对方部门id, 入出类别id, 入出系数, 批次, 产地, 原产地, 批号, 效期, 成本价, 扣率, 零售价, 摘要, 领用人, 批准文号, 发药方式, 供药单位id, 生产日期;
  
    --冲销数量大于剩余数量，不允许 
    If v_剩余数量 < 冲销数量_In Then
      Raise Err_Isnonum;
    End If;
  
    v_成本金额 := Round(冲销数量_In / v_剩余数量 * v_剩余成本金额, Intdigit);
    v_零售金额 := Round(冲销数量_In / v_剩余数量 * v_剩余零售金额, Intdigit);
    v_差价     := v_零售金额 - v_成本金额;
  
    Select 药品收发记录_Id.Nextval Into v_收发id From Dual;
    Insert Into 药品收发记录
      (Id, 记录状态, 单据, No, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 原产地, 批号, 效期, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 零售金额, 差价, 摘要,
       填制人, 填制日期, 审核人, 审核日期, 领用人, 批准文号, 发药方式, 供药单位id, 生产日期, 扣率)
    Values
      (v_收发id, Decode(原记录状态_In, 1, 2, 原记录状态_In + 2), 7, No_In, 序号_In, v_库房id, v_对方部门id, v_入出类别id, v_入出系数, 药品id_In, v_批次,
       v_产地, v_原产地, v_批号, v_效期, -冲销数量_In, -冲销数量_In, v_成本价, -v_成本金额, v_零售价, -v_零售金额, -v_差价, v_摘要, 填制人_In, 填制日期_In, 填制人_In,
       填制日期_In, v_领用人, v_批准文号, v_发药方式, n_上次供应商id, d_上次生产日期, v_扣率);
    
    --更新库存信息 领用冲销相当于入库 
    Zl_药品库存_Update(v_收发id, 3, 0);
    
    --科室药品留存处理 
    If v_发药方式 = 1 Then
      Update 药品留存
      Set 可用数量 = Nvl(可用数量, 0) + 冲销数量_In, 实际数量 = Nvl(实际数量, 0) + 冲销数量_In, 实际金额 = Nvl(实际金额, 0) + v_零售金额
      Where 期间 = To_Char(Sysdate, Decode(v_按月留存领用, '1', 'yyyymm', 'yyyy')) And 科室id = v_对方部门id And 库房id = v_库房id And
            药品id = 药品id_In;
      --将金额和数量等于0的记录删除掉 
      Delete From 药品留存 Where Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0;
    End If;
  
    --处理调价后冲销 
    Zl_药品收发记录_调价修正(v_收发id);
  End If;
Exception
  When Err_Isstriked Then
    Raise_Application_Error(-20101, '[ZLSOFT]该单据已经被他人冲销！[ZLSOFT]');
  When Err_Isbatch Then
    Raise_Application_Error(-20102,
                            '[ZLSOFT]该单据中包含有一条原来不分批，现在分批的药品[' || v_Druginf || ']，不能冲销！[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_药品领用_Strike;
/

--121865:黄捷,2018-02-07,新版PACS云平台
--120153:黄捷,2018-01-22,新版PACS接口支持从云端下载图像

Create Or Replace Package b_XINWANGInterface Is
  Type t_Refcur Is Ref Cursor;
  -- 1 PACS状态改变信息
  Procedure PacsStatusChange
  (
    状态ID_In   In Number,
    医嘱ID_In   In 影像检查记录.医嘱ID%Type,
    影像类别_In In 影像检查记录.影像类别%Type,
    检查号_In   In 影像检查记录.检查号%Type,
    处理时间    In Date,
    执行人      In Varchar2,
    胶片大小    In Varchar2,
    检查UID_In  In 影像检查记录.检查UID%Type := Null
  );
  -- 2 取消图像关联
  Procedure PacsUnmatchImage(医嘱ID_In In 影像检查记录.医嘱ID%Type);
  -- 3 填写报告图的存储设备
  Procedure PacsSetFTPDeviceNo
  (
    医嘱ID_In In 影像检查记录.医嘱ID%Type,
    设备号_In In 影像检查记录.位置一%Type
  );
  -- 4 更新图像数
  Procedure UpdateImgCount
  (
    医嘱ID_In 影像检查记录.医嘱ID%Type,
    图像数_In Number
  );

End b_XINWANGInterface;
/

Create Or Replace Package Body b_XINWANGInterface Is

  -- 1 PACS状态改变信息
  Procedure PacsStatusChange
  (
    状态ID_In   In Number,
    医嘱ID_In   In 影像检查记录.医嘱ID%Type,
    影像类别_In In 影像检查记录.影像类别%Type,
    检查号_In   In 影像检查记录.检查号%Type,
    处理时间    In Date,
    执行人      In Varchar2,
    胶片大小    In Varchar2,
    检查UID_In  In 影像检查记录.检查UID%Type := Null
  ) Is
    Strsql     Varchar2(2000);
    v_StudyUID 影像检查记录.检查UID%Type;
  
    Cursor c_Advice Is
      Select ID From 病人医嘱记录 Where ID = 医嘱id_In Or (相关id = 医嘱id_In And 诊疗类别 In ('F', 'G', 'D'));
  
  Begin
    --状态ID_In:1-匹配成功;2-匹配失败;3-新检查（收到第一幅图像）;4-收到每一幅图像;
    --     5-删除检查;6-胶片打印成功；7-更新电子胶片状态；8-图像转移到云平台；9-图像从云平台下载
  
    If 检查UID_In Is Null Then
      v_StudyUID := 医嘱ID_In;
    Else
      v_StudyUID := 检查UID_In;
    End If;
  
    If 状态ID_In = 1 Then
      --图象匹配成功
    
      --填写影像检查记录表的 检查UID，接收日期等，但是不填写序列级别的表,检查UID填写检查UID_In（StudyUID）
      Update 影像检查记录
      Set 检查UID = v_StudyUID, 接收日期 = Decode(处理时间, Null, Sysdate, 处理时间), 图像位置 = 1
      Where 医嘱ID = 医嘱ID_In;
    
      --设置医嘱执行状态
      For r_Advice In c_Advice Loop
        Update 病人医嘱发送
        Set 执行状态 = 3, 执行过程 = Decode(Sign(执行过程 - 2), 1, 执行过程, 3)
        Where 医嘱id = r_Advice.id;
      End Loop;
    Elsif 状态ID_In = 2 Then
      Strsql := 'dd';
    Elsif 状态ID_In = 3 Then
      -- 3-新检查（收到第一幅图像），暂时不处理
      Strsql := 'dd';
    Elsif 状态ID_In = 4 Then
      --  4-收到每一幅图像 ，暂时不处理
      Strsql := 'dd';
    Elsif 状态ID_In = 5 Then
      -- 5-删除检查
      -- 删除影像检查记录表中对应的检查UID，接收日期等
      Update 影像检查记录
      Set 检查UID = Null, 位置一 = Null, 位置二 = Null, 位置三 = Null, 报告图象 = Null, 接收日期 = Null
      Where 医嘱ID = 医嘱ID_IN;
    Elsif 状态ID_In = 6 Then
      -- 6-胶片打印成功
      --记录胶片大小，打印人等
    
      --一个医嘱打印一张或者多张胶片的情况，每张胶片调用一过程，相关ID为空
      Insert Into 胶片打印记录
        (ID, 相关id, 医嘱id, 胶片大小, 打印人, 打印时间)
      Values
        (胶片打印记录_Id.Nextval, Null, 医嘱ID_In, 胶片大小, 执行人, Decode(处理时间, Null, Sysdate, 处理时间));
      Update 影像检查记录 Set 是否打印 = 1 Where 医嘱ID = 医嘱ID_In;
    Elsif 状态ID_In = 7 Then
      --更新电子胶片状态
      Update 影像检查记录 Set 是否电子胶片 = 1 Where 医嘱ID = 医嘱ID_In;
    Elsif 状态ID_In = 8 Then
      -- 图像转移到云平台
      Update 影像检查记录 Set 检查UID = 检查UID_In, 图像位置 = 2 Where 医嘱ID = 医嘱ID_In;
    Elsif 状态ID_In = 9 Then
      -- 图像从云平台下载
      Update 影像检查记录 Set 图像位置 = 1 Where 医嘱ID = 医嘱ID_In;
    End If;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End PacsStatusChange;

  -- 2 PACS图像取消关联
  Procedure PacsUnmatchImage(医嘱ID_In In 影像检查记录.医嘱ID%Type) Is
    v_执行过程 病人医嘱发送.执行过程%Type;
    v_发送号   病人医嘱发送.发送号%Type;
  Begin
    --设置影像检查记录表的状态
    Update 影像检查记录 Set 检查UID = Null, 接收日期 = Null, 图像位置 = Null, 位置一 = Null Where 医嘱ID = 医嘱ID_In;
  
    --调用 Zl_影像检查_State 改变检查过程的状态
    Select 执行过程, 发送号 Into v_执行过程, v_发送号 From 病人医嘱发送 Where 医嘱ID = 医嘱ID_In;
  
    --如果执行过程是3，则将过程修改成2
    If v_执行过程 = 3 Then
      Zl_影像检查_State(医嘱ID_In, v_发送号, 2);
    End If;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End PacsUnmatchImage;

  -- 3 填写报告图的存储设备
  Procedure PacsSetFTPDeviceNo
  (
    医嘱ID_In In 影像检查记录.医嘱ID%Type,
    设备号_In In 影像检查记录.位置一%Type
  ) Is
  Begin
    --设置影像检查记录表的状态
    Update 影像检查记录 Set 位置一 = 设备号_In Where 医嘱ID = 医嘱ID_In;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End PacsSetFTPDeviceNo;

  -- 4 更新图像数量
  Procedure UpdateImgCount
  (
    医嘱ID_IN 影像检查记录.医嘱ID%Type,
    图像数_In Number
  ) Is
  Begin
    Update 影像检查记录 Set 图像数量 = 图像数_In Where 医嘱ID = 医嘱ID_In;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End UpdateImgCount;

End b_XINWANGInterface;
/

--113611:李南春,2018-01-18,自助禁用支付方式
CREATE OR REPLACE Function zl1_EX_ForbidPlayTypes
(
  模块_In       In zlparameters.模块%Type,
  病人ID_In     In 病人信息.病人ID%Type,
  卡类别ID_In   In 病人医疗卡信息.卡类别ID%Type := 0,
  卡号_IN       In 病人医疗卡信息.卡号%Type := Null
) Return Varchar2 Is
  ----------------------------------
  --功能：根据参数传入的病人身份信息，返回禁用的支付方式
  --格式为:卡类别ID,是否消费卡|…
  --       是否消费卡:1-是消费卡;0-不是消费卡
  --       卡类别ID:-98-现金支付;-99-帐户支付;>0 表示具体的三方卡
  -----------------------------------
  Err_Custom Exception;
  v_Error Varchar2(255);
Begin
  Return Null;
  Exception
  When Err_Custom Then
    Return Null;
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End zl1_EX_ForbidPlayTypes;
/

--113613:李南春,2018-01-18,判断当前卡是否允许退卡
Create Or Replace Function zl1_EX_ReFundCard_Check 
(
  模块_In       In zlparameters.模块%Type,
  病人ID_In     In 病人信息.病人ID%Type,
  卡类别ID_In   In 病人医疗卡信息.卡类别ID%Type := 0,
  卡号_IN       In 病人医疗卡信息.卡号%Type := Null
) Return Varchar2 Is
  ----------------------------------
  --功能：根据传过来的参数判断当前卡是否允许退卡，如果不允许退卡，返回提示内容；否则返回NULL
  -----------------------------------
  Err_Custom Exception;
  v_Error Varchar2(255);
Begin
  Return NULL;
  Exception
  When Err_Custom Then
    Return Null;
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End zl1_EX_ReFundCard_Check;
/

--118124:李南春,2018-01-18,发卡时获取卡费
CREATE OR REPLACE Function Zl1_Ex_CardFee
(
  模块号_In     In Zlparameters.模块%Type,
  卡类别ID_In   In 医疗卡类别.ID%Type,
  卡号_In       In 病人医疗卡信息.卡号%Type,
  病人ID_In     In 病人信息.病人ID%Type,
  姓名_In       In 病人信息.姓名%Type:= Null,
  性别_In       In 病人信息.性别%Type:= Null,
  年龄_In       In 病人信息.年龄%Type:= Null,
  身份证号_In   In 病人信息.身份证号%Type:= Null,
  收费细目ID_In In 收费项目目录.ID%Type:= Null
) Return Number
--功能说明：根据病人及发卡类别返回本次应收的卡费。
  --适用说明：根据病人多次办卡时，每次收取不同的费用。
  --入参说明：
  --     模块号_In：区分是哪个模块发卡
  --     卡类别ID_In：发卡类别
  --     卡号_In：发卡卡号
  --     病人ID_In：建档病人ID
  --函数返回：
  --     收费细目ID
is
Begin
  Return 收费细目ID_In;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl1_Ex_CardFee;
/

--113615:李南春,2018-01-18,充值时身份检查
Create Or Replace Function zl1_EX_ReFill_Check 
(
  模块_In       In zlparameters.模块%Type,
  病人ID_In     In 病人信息.病人ID%Type,
  卡类别ID_In   In 病人医疗卡信息.卡类别ID%Type := 0,
  卡号_IN       In 病人医疗卡信息.卡号%Type := Null
) Return Varchar2 Is
  ----------------------------------
  --功能：根据传过来的参数判断当前卡使用是否合法，如果不合法，返回提示内容；否则返回NULL
  -----------------------------------
  Err_Custom Exception;
  v_Error Varchar2(255);
Begin
  Return Null;
  Exception
  When Err_Custom Then
    Return Null;
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End zl1_EX_ReFill_Check;
/

--110000:曾杰,2018-01-18,变更影像检查记录待处理人
Create Or Replace Procedure Zl_影像检查记录_变更待处理人
(
  医嘱id_In   In 影像检查记录.医嘱id%Type,
  待处理人_In In 影像检查记录.待处理人%Type
) Is
Begin
  Update 影像检查记录 Set 待处理人 = 待处理人_In Where 医嘱id = 医嘱id_In;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_影像检查记录_变更待处理人;
/

--116636:陈刘,2018-01-18,护理记录同步体温单,汇总子项同步
Create Or Replace Procedure Zl_病人护理数据_Update
(
  文件id_In   In 病人护理数据.文件id%Type,
  发生时间_In In 病人护理数据.发生时间%Type,
  记录类型_In In 病人护理明细.记录类型%Type, --护理项目=1，签名记录=5，审签记录=15
  项目序号_In In 病人护理明细.项目序号%Type, --护理项目的序号，非护理项目固定为0
  记录内容_In In 病人护理明细.记录内容%Type := Null, --记录内容，如果内容为空，即清除以前的内容；37或38/37
  体温部位_In In 病人护理明细.体温部位%Type := Null,
  他人记录_In In Number := 1,
  数据来源_In In 病人护理明细.数据来源%Type := 0,
  审签_In     In Number := 0,
  操作员_In   In 病人护理数据.保存人%Type := Null,
  记录组号_In In 病人护理明细.记录组号%Type := Null, --适用分类汇总(一条数据对应多条相同项目的明细)
  相关序号_In In 病人护理明细.相关序号%Type := Null, --适用分类汇总(记录汇总项目关联的名称项目序号)
  未记说明_In In 病人护理明细.未记说明%Type := Null --入量导入存储医嘱ID:发送号
) Is
  Intins      Number(18);
  Int共用     Number(1);
  n_Newid     病人护理数据.Id%Type;
  n_Oldid     病人护理数据.Id%Type;
  n_行数      病人护理打印.行数%Type;
  n_Mutilbill Number(1);
  n_Syntend   Number(1);
  n_Synchro   Number(1);
  n_未记说明  Number(1);
  n_曲线      Number(1);
  n_Num       Number(18);
  v_Name      体温记录项目.记录名%Type;

  n_汇总类别     病人护理数据.汇总类别%Type;
  v_科室id       部门表.Id%Type;
  v_保存人       人员表.姓名%Type;
  v_记录人       人员表.姓名%Type;
  n_文件id       病人护理数据.文件id%Type;
  n_记录id       病人护理数据.Id%Type;
  n_明细id       病人护理明细.Id%Type;
  n_来源id       病人护理明细.来源id%Type;
  v_数据来源     病人护理明细.数据来源%Type;
  n_最高版本     病人护理明细.开始版本%Type;
  n_项目性质     护理记录项目.项目性质%Type;
  n_病人id       病人护理文件.病人id%Type;
  n_主页id       病人护理文件.主页id%Type;
  n_婴儿         病人护理文件.婴儿%Type;
  d_婴儿出院时间 病人医嘱记录.开始执行时间%Type;
  d_文件开始时间 病人护理文件.开始时间%Type;
  --提取该病人当前科室所有未结束的护理文件，且文件开始时间小于等于记录发生时间的文件列表供同步数据使用
  Cursor Cur_Fileformats Is
    Select a.Id As 格式id, b.Id As 文件id, a.保留, a.子类, b.婴儿
    From 病历文件列表 A, 病人护理文件 B, 病人护理文件 C, 病人护理数据 D
    Where a.种类 = 3 And a.保留 <> 1 And a.Id = b.格式id And b.Id <> c.Id And b.结束时间 Is Null And b.开始时间 <= d.发生时间 And
          (a.通用 = 1 Or (a.通用 = 2 And b.科室id = c.科室id)) And c.病人id = b.病人id And c.主页id = b.主页id And c.婴儿 = b.婴儿 And
          c.Id = d.文件id And d.Id = n_记录id And c.Id = 文件id_In
    Order By a.编号;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --取记录ID
  Int共用     := 0;
  n_记录id    := 0;
  n_Mutilbill := 0;
  n_Syntend   := 0;
  n_未记说明  := 0;
  n_曲线      := 0;

  If 操作员_In Is Null Then
    v_保存人 := Zl_Username;
  Else
    v_保存人 := 操作员_In;
  End If;

  --如果是对应多份护理文件值为1，表示需同步其它护理文件；否则不处理文件同步
  n_Mutilbill := Zl_To_Number(zl_GetSysParameter('对应多份护理文件', 1255));
  --如果允许多份护理文件之间数据同步,则自动同步,否则不同步
  n_Syntend := Zl_To_Number(zl_GetSysParameter('允许数据同步', 1255));

  Begin
    Select 记录名 Into v_Name From 体温记录项目 Where 项目序号 = 项目序号_In;
  Exception
    When Others Then
      v_Name := '';
  End;

  Begin
    Select ID, 汇总类别
    Into n_记录id, n_汇总类别
    From 病人护理数据
    Where 文件id = 文件id_In And 发生时间 = 发生时间_In;
  Exception
    When Others Then
      n_记录id := 0;
  End;

  --检查是不是本人的记录
  ---------------------------------------------------------------------------------------------------------------------
  If 他人记录_In = 0 And n_记录id > 0 And 审签_In = 0 Then
    v_记录人 := '';
    Begin
      Select 记录人
      Into v_记录人
      From 病人护理明细
      Where 记录id = n_记录id And 项目序号 = 项目序号_In And Nvl(体温部位, 'TWBW') = Nvl(体温部位_In, 'TWBW') And
            Nvl(记录组号, 0) = Nvl(记录组号_In, 0) And 终止版本 Is Null;
    Exception
      When Others Then
        v_记录人 := '';
    End;
    If v_记录人 Is Not Null And v_记录人 <> v_保存人 Then
      v_Error := '你无权修改他人登记的护理数据！';
      Raise Err_Custom;
    End If;
  End If;

  --检查是否入科
  Select 病人id, 主页id, Nvl(婴儿, 0), 开始时间
  Into n_病人id, n_主页id, n_婴儿, d_文件开始时间
  From 病人护理文件
  Where ID = 文件id_In;
  d_婴儿出院时间 := Null;
  If n_婴儿 <> 0 Then
    Begin
      Select 开始执行时间
      Into d_婴儿出院时间
      From 病人医嘱记录 B, 诊疗项目目录 C
      Where b.诊疗项目id + 0 = c.Id And b.医嘱状态 = 8 And Nvl(b.婴儿, 0) <> 0 And c.类别 = 'Z' And
            Instr(',3,5,11,', ',' || c.操作类型 || ',', 1) > 0 And b.病人id = n_病人id And b.主页id = n_主页id And b.婴儿 = n_婴儿;
    Exception
      When Others Then
        d_婴儿出院时间 := Null;
    End;
  End If;
  If d_婴儿出院时间 Is Null Then
    v_科室id := 0;
    Begin
      Select a.科室id
      Into v_科室id
      From 病人变动记录 A, 病人护理文件 B
      Where a.科室id Is Not Null And a.病人id = b.病人id And a.主页id = b.主页id And b.Id = 文件id_In And
            (To_Date(To_Char(发生时间_In, 'YYYY-MM-DD HH24:MI') || '59', 'YYYY-MM-DD HH24:MI:SS') >= a.开始时间 And
            (To_Date(To_Char(发生时间_In, 'YYYY-MM-DD HH24:MI') || '00', 'YYYY-MM-DD HH24:MI:SS') < = Nvl(a.终止时间, Sysdate) Or
            a.终止时间 Is Null)) And Rownum < 2;
    Exception
      When Others Then
        v_科室id := 0;
    End;
    If v_科室id = 0 Then
      v_Error := '数据发生时间 ' || To_Char(发生时间_In, 'YYYY-MM-DD HH24:MI:SS') || ' 不在病人有效变动时间范围内，不能操作！';
      Raise Err_Custom;
    End If;
  Else
    If 发生时间_In < d_文件开始时间 Or 发生时间_In > d_婴儿出院时间 Then
      v_Error := '数据发生时间 ' || To_Char(发生时间_In, 'YYYY-MM-DD HH24:MI:SS') || ' 不在病人有效变动时间范围内，不能操作！';
      Raise Err_Custom;
    End If;
  End If;

  --如果数据来源<>0则退出
  n_来源id := 0;
  If n_记录id > 0 Then
    Begin
      Select 数据来源, Nvl(来源id, 0)
      Into v_数据来源, n_来源id
      From 病人护理明细
      Where 记录id = n_记录id And Nvl(项目序号, 0) = 项目序号_In And Nvl(体温部位, 'TWBW') = Nvl(体温部位_In, 'TWBW') And
            Nvl(记录组号, 0) = Nvl(记录组号_In, 0);
    Exception
      When Others Then
        v_数据来源 := 0;
    End;
    If v_数据来源 > 0 And n_来源id > 0 Then
      Return;
    End If;
  End If;

  --取最高版本
  Select Nvl(Max(Nvl(a.开始版本, 1)), 0) + 1, Count(b.Id)
  Into n_最高版本, Intins
  From 病人护理明细 A, 病人护理数据 B
  Where b.Id = n_记录id And a.记录id = b.Id And Mod(a.记录类型, 10) = 5;

  --目前已经签名的数据不能修改，只有在审签模式下进行修改，即审签_In=1
  If 审签_In <> 1 And Intins > 0 Then
    v_Error := '发生时间 ' || To_Char(发生时间_In, 'YYYY-MM-DD HH24:MI:SS') || ' 所对应的数据已经签名或审签，不能继续操作！' || Chr(13) || Chr(10) ||
               '这可能是由于网络并发操作引起的，请刷新后再试！';
    Raise Err_Custom;
  End If;
  Intins := 0;

  --无内容时,要清除数据（审签回退时会自动清除审签过程中修改的数据，所以此处只需考虑普签即可）
  If 记录内容_In Is Null Then
    Begin
      Select ID
      Into n_明细id
      From 病人护理明细
      Where 记录id = n_记录id And Nvl(项目序号, 0) = 项目序号_In And Nvl(体温部位, 'TWBW') = Nvl(体温部位_In, 'TWBW') And
            Nvl(记录组号, 0) = Nvl(记录组号_In, 0) And 终止版本 Is Null;
    Exception
      --无数据退出
      When Others Then
        Return;
    End;
  
    --查找除了本条要删除的数据，是否还存其他有效的数据，如果存在只删除本条数据，否则删除此发生时间对应的所有数据。
    Select Count(ID)
    Into Intins
    From 病人护理明细
    Where 记录id = n_记录id And Mod(记录类型, 10) <> 5 And 终止版本 Is Null And ID <> n_明细id;
    If Intins = 0 Then
      Delete From 病人护理明细 Where 记录id = n_记录id;
    Else
      Delete From 病人护理明细 Where ID = n_明细id;
    End If;
  
    Delete From 病人护理数据 A
    Where a.Id = n_记录id And Not Exists (Select 1 From 病人护理明细 B Where b.记录id = a.Id);
  
    --如果是删除签名后修改产生的最后一条数据,则应将签名记录的终止版本清为空
    Begin
      Select 1
      Into Intins
      From 病人护理明细
      Where 开始版本 = n_最高版本 And 终止版本 Is Null And 记录类型 = 1 And 记录id = n_记录id;
    Exception
      When Others Then
        Intins := 0;
    End;
    If Intins = 0 Then
      Update 病人护理明细 Set 终止版本 = Null Where 记录类型 = 5 And 开始版本 = n_最高版本 - 1 And 记录id = n_记录id;
    End If;
    If Nvl(n_汇总类别, 0) <> 0 Then
      Return;
    End If;
  
    --############
    --清除共用数据
    --############
    For Rsdel In (Select Distinct 记录id From 病人护理明细 Where 来源id = n_明细id) Loop
    
      Delete 病人护理明细 Where 来源id = n_明细id And 记录id = Rsdel.记录id;
      --删除对应的打印数据
      Begin
        Select Count(*) Into Intins From 病人护理明细 Where 记录id = Rsdel.记录id;
      Exception
        When Others Then
          Intins := 0;
      End;
      If Intins = 0 Then
        --提取清除数据对应的文件ID
        Begin
          Select b.Id, a.保留
          Into n_文件id, Intins
          From 病历文件列表 A, 病人护理文件 B, 病人护理数据 C
          Where a.Id = b.格式id And b.Id = c.文件id And c.Id = Rsdel.记录id;
        Exception
          When Others Then
            n_文件id := 0;
        End;
        Delete 病人护理数据 Where ID = Rsdel.记录id;
        If Intins <> -1 Then
          Zl_病人护理打印_Update(n_文件id, 发生时间_In, 1, 1);
        End If;
      End If;
    End Loop;
  Else
    --检查录入的项目是否属于该记录单
    Begin
      Select 1
      Into Intins
      From (Select b.项目序号
             From 病历文件结构 A, 护理记录项目 B
             Where a.要素名称 = b.项目名称 And b.项目序号 = 项目序号_In And
                   父id = (Select b.Id
                          From 病人护理文件 A, 病历文件结构 B
                          Where a.Id = 文件id_In And a.格式id = b.文件id And b.父id Is Null And b.对象序号 = 4)
             Union
             Select 项目序号
             From 护理记录项目
             Where 项目性质 = 2 And 项目序号 = 项目序号_In);
    Exception
      When Others Then
        Intins := 0;
    End;
    If Intins = 0 Then
      Return;
    End If;
    If n_记录id = 0 Then
      Select 病人护理数据_Id.Nextval Into n_记录id From Dual;
    
      Insert Into 病人护理数据
        (ID, 文件id, 发生时间, 最后版本, 保存人, 保存时间)
      Values
        (n_记录id, 文件id_In, 发生时间_In, n_最高版本, v_保存人, Sysdate);
    End If;
  
    --插入本次登记的病人护理明细
    Update 病人护理明细
    Set 记录内容 = 记录内容_In, 数据来源 = 数据来源_In, 未记说明 = 未记说明_In, 记录人 = v_保存人, 记录时间 = Sysdate
    Where 记录id = n_记录id And 项目序号 = 项目序号_In And Nvl(体温部位, 'TWBW') = Nvl(体温部位_In, 'TWBW') And
          Nvl(记录组号, 0) = Nvl(记录组号_In, 0) And 开始版本 = n_最高版本 And 终止版本 Is Null;
    If Sql%RowCount = 0 Then
      Select 病人护理明细_Id.Nextval Into n_明细id From Dual;
      Insert Into 病人护理明细
        (ID, 记录id, 记录类型, 项目分组, 项目id, 相关序号, 项目序号, 项目名称, 项目类型, 记录内容, 项目单位, 记录标记, 记录组号, 体温部位, 数据来源, 共用, 未记说明, 开始版本, 终止版本,
         记录人, 记录时间)
        Select n_明细id, n_记录id, 记录类型_In, a.分组名, a.项目id, 相关序号_In, a.项目序号, Upper(a.项目名称), a.项目类型, 记录内容_In, a.项目单位, 0,
               记录组号_In, 体温部位_In, 数据来源_In, Nvl(b.共用, 0), 未记说明_In, n_最高版本, Null, v_保存人, Sysdate
        From 护理记录项目 A, 病人护理明细 B
        Where a.项目序号 = b.项目序号(+) And b.终止版本(+) Is Null And b.记录id(+) = n_记录id And a.项目序号 = 项目序号_In And Rownum < 2;
    End If;
    Select ID
    Into n_明细id
    From 病人护理明细
    Where 记录id = n_记录id And 项目序号 = 项目序号_In And Nvl(体温部位, 'TWBW') = Nvl(体温部位_In, 'TWBW') And
          Nvl(记录组号, 0) = Nvl(记录组号_In, 0) And 开始版本 = n_最高版本 And 终止版本 Is Null;
    --填写历史数据及签名记录的终止版本
    Update 病人护理明细
    Set 终止版本 = n_最高版本
    Where 记录id = n_记录id And ((Mod(记录类型, 10) <> 5 And 项目序号 = 项目序号_In And Nvl(体温部位, 'TWBW') = Nvl(体温部位_In, 'TWBW') And
          Nvl(记录组号, 0) = Nvl(记录组号_In, 0)) Or 记录类型 = Decode(审签_In, 1, 15, 5)) And 开始版本 <= n_最高版本 - 1 And 终止版本 Is Null;
  
    --如果是未签名数据，最后修改操作员做为该记录的保存人更新
    If n_最高版本 = 1 Then
      Update 病人护理数据 Set 保存人 = v_保存人, 保存时间 = Sysdate Where ID = n_记录id;
    End If;
  
    If Nvl(n_汇总类别, 0) <> 0 Then
      Return;
    End If;
  
    --############
    --同步共用数据
    --############
    --1\先处理体温单（一个病人始终只存在一份有效的体温单文件）
    --如果体温表存在相同发生时间的数据，使用它的ID
    --CL,2015-12-30,记录单同步文字项目到体温单
    For Row_Format In Cur_Fileformats Loop
      If Row_Format.保留 = -1 Then
        If Row_Format.子类 = '1' Then
          Begin
            Select 1, h.项目性质
            Into Intins, n_项目性质
            From (With Q2 As (Select g.项目名称 As 项目名称, g.项目性质
                              From (Select 序号
                                     From 护理汇总项目
                                     Start With 序号 = (Select Max(序号)
                                                      From 护理汇总项目
                                                      Where 父序号 Is Null
                                                      Start With 序号 = 项目序号_In
                                                      Connect By Prior 父序号 = 序号)
                                     Connect By Prior 序号 = 父序号) A, 护理记录项目 G
                              Where a.序号 = g.项目序号), Q1 As (Select To_Char(f.记录名) As 项目名称, g.项目性质
                                                           From 体温记录项目 F, 护理记录项目 G
                                                           Where f.项目序号 = g.项目序号 And g.项目性质 = 2 And
                                                                 (g.适用科室 = 1 Or
                                                                 (g.适用科室 = 2 And Exists
                                                                  (Select 1
                                                                    From 护理适用科室 D
                                                                    Where g.项目序号 = d.项目序号 And d.科室id = v_科室id))) And
                                                                 Nvl(g.应用方式, 0) <> 0 And
                                                                 (Nvl(g.适用病人, 0) = 0 Or
                                                                 Nvl(g.适用病人, 0) = Decode(Nvl(Row_Format.婴儿, 0), 0, 1, 2))
                                                           Union All
                                                           Select b.要素名称 As 项目名称, 1 As 项目性质
                                                           From 病历文件结构 A, 病历文件结构 B
                                                           Where a.文件id = Row_Format.格式id And a.父id Is Null And
                                                                 a.对象序号 In (2, 3) And b.父id = a.Id)
                   Select *
                   From Q1
                   Union 
                   Select *
                   From Q2
                   Where Exists (Select 1 From Q1, Q2 Where Q1.项目名称 = Q2.项目名称)) H
                   Where Instr(',' || h.项目名称 || ',', ',' || v_Name || ',', 1) > 0;
          
          Exception
            When Others Then
              Intins := 0;
          End;
        Else
          Begin
            Select 1, h.项目性质
            Into Intins, n_项目性质
            From (With Q2 As (Select g.项目序号, g.适用病人, g.适用科室, g.护理等级, g.项目性质, g.应用方式
                              From (Select 序号
                                     From 护理汇总项目
                                     Start With 序号 = (Select Max(序号)
                                                      From 护理汇总项目
                                                      Where 父序号 Is Null
                                                      Start With 序号 = 项目序号_In
                                                      Connect By Prior 父序号 = 序号)
                                     Connect By Prior 序号 = 父序号) A, 护理记录项目 G
                              Where a.序号 = g.项目序号), Q1 As (Select g.项目序号, g.适用病人, g.适用科室, g.护理等级, g.项目性质, g.应用方式
                                                           From 体温记录项目 F, 护理记录项目 G
                                                           Where f.项目序号 = g.项目序号)
                   Select *
                   From Q1
                   Union 
                   Select *
                   From Q2
                   Where Exists (Select 1 From Q1, Q2 Where Q1.项目序号 = Q2.项目序号)) H
                   Where Nvl(h.应用方式, 0) <> 0 And h.护理等级 >= 0 And
                         (Nvl(h.适用病人, 0) = 0 Or Nvl(h.适用病人, 0) = Decode(Nvl(Row_Format.婴儿, 0), 0, 1, 2)) And
                         h.项目序号 = 项目序号_In And
                         (h.适用科室 = 1 Or
                          (h.适用科室 = 2 And Exists
                           (Select 1 From 护理适用科室 D Where h.项目序号 = d.项目序号 And d.科室id = v_科室id)));
          
          
          Exception
            When Others Then
              Intins := 0;
          End;
        End If;
      
        If Intins > 0 Then
          --LPF,2013-01-23,检查此项目是否需要进行同步(对于以前已经同步过的数据，为了保证记录单和体温单数据一直将不根据此函数判断。)
          n_Synchro := Zl_Temperatureprogram(文件id_In, v_科室id, 项目序号_In, 发生时间_In);
          Begin
            Select b.Id
            Into n_Newid
            From 病人护理文件 A, 病人护理数据 B
            Where a.Id = Row_Format.文件id And b.文件id = a.Id And b.发生时间 = 发生时间_In;
          Exception
            When Others Then
              n_Newid := 0;
          End;
          n_Oldid := n_Newid;
          If n_Newid = 0 And n_Synchro = 1 Then
            Select 病人护理数据_Id.Nextval Into n_Newid From Dual;
            --产生体温单主记录
            Insert Into 病人护理数据
              (ID, 文件id, 保存人, 保存时间, 发生时间, 最后版本)
            Values
              (n_Newid, Row_Format.文件id, v_保存人, Sysdate, 发生时间_In, 1);
          End If;
        
          Begin
            Select To_Number(记录内容_In) Into n_Num From Dual;
          Exception
            When Invalid_Number Then
              Begin
                Select 1 Into n_曲线 From 体温记录项目 Where 项目序号 = 项目序号_In And 记录法 = 1;
              Exception
                When Others Then
                  n_曲线 := 0;
              End;
              Begin
                Select 1 Into n_未记说明 From 常用体温说明 Where 名称 = 记录内容_In;
              Exception
                When Others Then
                  n_未记说明 := 0;
              End;
          End;
        
          If n_Newid > 0 Then
            --插入未同步的体温单数据(仍然要联接多表查询)
            Select Count(*)
            Into v_数据来源
            From 病人护理明细
            Where 记录id = n_Newid And 项目序号 = 项目序号_In And
                  Decode(n_项目性质, 2, Nvl(体温部位, '无'), Nvl(体温部位_In, '无')) = Nvl(体温部位_In, '无');
            If v_数据来源 = 0 Then
              --说明在同步开始已经进行过检查
              If n_Synchro = 1 Then
                --没有检查此项目是否需要同步
                If n_曲线 = 1 And n_未记说明 = 1 Then
                  Insert Into 病人护理明细
                    (ID, 记录id, 记录类型, 项目分组, 项目id, 项目序号, 项目名称, 项目类型, 记录内容, 项目单位, 记录标记, 体温部位, 数据来源, 来源id, 未记说明, 开始版本, 终止版本,
                     记录人, 记录时间, 记录组号)
                    Select 病人护理明细_Id.Nextval, n_Newid, b.记录类型, b.项目分组, b.项目id, b.项目序号, b.项目名称, b.项目类型, Null, b.项目单位,
                           b.记录标记, b.体温部位, 1, b.Id, b.记录内容, 1, Null, b.记录人, Sysdate, 1
                    From (Select 项目序号_In As 项目序号, Nvl(体温部位_In, '无') As 体温部位
                           From Dual
                           Minus
                           Select f.项目序号, Decode(Nvl(f.项目性质, 1), 2, Nvl(体温部位, '无'), Nvl(体温部位_In, '无'))
                           From 病人护理明细 E, 护理记录项目 F
                           Where e.记录id = n_Newid And e.项目序号 = f.项目序号) A, 病人护理明细 B
                    Where a.项目序号 = b.项目序号 And b.记录id = n_记录id And b.Id = n_明细id;
                  If Sql%RowCount > 0 Then
                    Int共用 := 1;
                  End If;
                Else
                  Insert Into 病人护理明细
                    (ID, 记录id, 记录类型, 项目分组, 项目id, 项目序号, 项目名称, 项目类型, 记录内容, 项目单位, 记录标记, 体温部位, 数据来源, 来源id, 开始版本, 终止版本, 记录人,
                     记录时间, 记录组号)
                    Select 病人护理明细_Id.Nextval, n_Newid, b.记录类型, b.项目分组, b.项目id, b.项目序号, b.项目名称, b.项目类型, b.记录内容, b.项目单位,
                           b.记录标记, b.体温部位, 1, b.Id, 1, Null, b.记录人, Sysdate, 1
                    From (Select 项目序号_In As 项目序号, Nvl(体温部位_In, '无') As 体温部位
                           From Dual
                           Minus
                           Select f.项目序号, Decode(Nvl(f.项目性质, 1), 2, Nvl(体温部位, '无'), Nvl(体温部位_In, '无'))
                           From 病人护理明细 E, 护理记录项目 F
                           Where e.记录id = n_Newid And e.项目序号 = f.项目序号) A, 病人护理明细 B
                    Where a.项目序号 = b.项目序号 And b.记录id = n_记录id And b.Id = n_明细id;
                  If Sql%RowCount > 0 Then
                    Int共用 := 1;
                  End If;
                End If;
              End If;
            Else
              If n_曲线 = 1 And n_未记说明 = 1 Then
                Update 病人护理明细
                Set 未记说明 = 记录内容_In, 来源id = n_明细id, 记录内容 = Null
                Where 记录id = n_Newid And 项目序号 = 项目序号_In And
                      Decode(n_项目性质, 2, Nvl(体温部位, '无'), Nvl(体温部位_In, '无')) = Nvl(体温部位_In, '无') And 数据来源 > 0;
                If Sql%RowCount > 0 Then
                  Int共用 := 1;
                End If;
              Else
                Update 病人护理明细
                Set 记录内容 = 记录内容_In, 来源id = n_明细id
                Where 记录id = n_Newid And 项目序号 = 项目序号_In And
                      Decode(n_项目性质, 2, Nvl(体温部位, '无'), Nvl(体温部位_In, '无')) = Nvl(体温部位_In, '无') And 数据来源 > 0;
                If Sql%RowCount > 0 Then
                  Int共用 := 1;
                End If;
              End If;
            End If;
          End If;
        End If;
        --2\再循环处理记录单
      Else
        If n_Mutilbill = 1 And n_Syntend = 1 Then
          --提取记录单与当前记录单存在重叠的且有数据的固定项目
          Select Count(*)
          Into Intins
          From (Select b.项目序号
                 From 病历文件结构 A, 护理记录项目 B
                 Where a.要素名称 = b.项目名称 And b.项目表示 In (0, 4, 5) And
                       父id =
                       (Select ID From 病历文件结构 Where 文件id = Row_Format.格式id And 父id Is Null And 对象序号 = 4)
                 Intersect
                 Select b.项目序号
                 From 病历文件结构 A, 护理记录项目 B, 病人护理文件 C, 病人护理数据 D, 病人护理明细 G
                 Where c.Id = d.文件id And a.文件id = c.格式id And d.Id = g.记录id And d.Id = n_记录id And g.Id = n_明细id And
                       b.项目序号 = g.项目序号 And b.项目表示 In (0, 4, 5) And g.记录类型 = 1 And a.要素名称 = b.项目名称 And
                       a.父id = (Select ID From 病历文件结构 E Where e.文件id = c.格式id And 父id Is Null And 对象序号 = 4));
        
          If Intins > 0 Then
            n_Newid := 0;
            --可能指定文件已经存在相同发生时间的数据，直接用它的ID即可
            Begin
              Select c.Id
              Into n_Newid
              From 病人护理数据 C
              Where c.文件id = Row_Format.文件id And c.发生时间 = 发生时间_In;
            Exception
              When Others Then
                n_Newid := 0;
            End;
          
            If n_Newid = 0 Then
              --产生记录单主记录
              Select 病人护理数据_Id.Nextval Into n_Newid From Dual;
            
              Insert Into 病人护理数据
                (ID, 文件id, 保存人, 保存时间, 发生时间, 最后版本)
                Select n_Newid, Row_Format.文件id, c.保存人, c.保存时间, c.发生时间, 1
                From 病人护理数据 C
                Where c.Id = n_记录id;
            End If;
          
            If n_Newid > 0 Then
              --插入未同步的记录单数据
              Select Count(*) Into v_数据来源 From 病人护理明细 Where 记录id = n_Newid And 项目序号 = 项目序号_In;
              If v_数据来源 = 0 Then
                Insert Into 病人护理明细
                  (ID, 记录id, 记录类型, 项目分组, 项目id, 项目序号, 项目名称, 项目类型, 记录内容, 项目单位, 记录标记, 体温部位, 数据来源, 来源id, 未记说明, 开始版本, 终止版本,
                   记录人, 记录时间)
                  Select 病人护理明细_Id.Nextval, n_Newid, b.记录类型, b.项目分组, b.项目id, b.项目序号, b.项目名称, b.项目类型, b.记录内容, b.项目单位,
                         b.记录标记, b.体温部位, 1, b.Id, b.未记说明, 1, Null, b.记录人, Sysdate
                  From (Select b.项目序号
                         From 病历文件结构 A, 护理记录项目 B
                         Where a.要素名称 = b.项目名称 And b.项目表示 In (0, 4, 5) And
                               父id = (Select ID
                                      From 病历文件结构
                                      Where 文件id = Row_Format.格式id And 父id Is Null And 对象序号 = 4)
                         Intersect
                         Select b.项目序号
                         From 病历文件结构 A, 护理记录项目 B, 病人护理文件 C, 病人护理数据 D, 病人护理明细 G
                         Where c.Id = d.文件id And a.文件id = c.格式id And d.Id = g.记录id And d.Id = n_记录id And g.Id = n_明细id And
                               b.项目序号 = g.项目序号 And b.项目表示 In (0, 4, 5) And g.记录类型 = 1 And a.要素名称 = b.项目名称 And
                               a.父id =
                               (Select ID From 病历文件结构 E Where e.文件id = c.格式id And 父id Is Null And 对象序号 = 4)) A, 病人护理明细 B
                  Where a.项目序号 = b.项目序号 And b.记录id = n_记录id And b.Id = n_明细id;
                If Sql%RowCount > 0 Then
                  Int共用 := 1;
                  --原行数不要动
                  Begin
                    Select 行数 Into n_行数 From 病人护理打印 Where 文件id = Row_Format.文件id And 记录id = n_Newid;
                  Exception
                    When Others Then
                      n_行数 := 1;
                  End;
                  Zl_病人护理打印_Update(Row_Format.文件id, 发生时间_In, n_行数, 0);
                End If;
              Else
                Update 病人护理明细
                Set 记录内容 = 记录内容_In, 未记说明 = 未记说明_In, 来源id = n_明细id
                Where 记录id = n_Newid And 项目序号 = 项目序号_In And 数据来源 > 0;
                If Sql%RowCount > 0 Then
                  Int共用 := 1;
                End If;
              End If;
            End If;
          End If;
        End If;
      End If;
    End Loop;
  
    If Int共用 = 1 Then
      Update 病人护理明细 Set 共用 = 1 Where ID = n_明细id;
      --将历史数据的共用标志设置为NULL
      Update 病人护理明细 Set 共用 = Null Where 记录id = n_记录id And 项目序号 = 项目序号_In And ID <> n_明细id;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人护理数据_Update;
/

--119386:殷瑞,2018-01-18,自动排批时剔除未启用的批次
CREATE OR REPLACE Procedure Zl_输液配药记录_自动排批
(
 病人id_In In number,
 科室id_In In number,
 部门id_In In number,
 执行日期_In in date
) Is
v_批次串 varchar2(500);
n_总量 number(5);
v_配药id  varchar2(500);
v_batch varchar2(20);
v_Fields varchar2(100);
v_Tansid varchar(18);
n_科室id number(18);
v_批次   varchar2(10);
v_Id     varchar2(200);
n_自动排批模式  number(1);
n_打包    number(2);
v_配药类型  Varchar2(20);
v_历史批次  Varchar2(20);
Begin
  n_自动排批模式:=Zl_To_Number(Nvl(zl_GetSysParameter('自动排批时输液单的批次只往后面批次变动', 1345), 0));
  --该科室各个批次对应的容量
  select max(批次) into v_批次 from 配药工作批次 where 配置中心id=部门id_In and 药品类型 is  null and 启用 = 1;
  for R_Batch in (select B.批次 配药批次,A.容量,A.科室id from 科室容量设置 A,配药工作批次 B where A.配置中心ID=B.配置中心ID And A.配药批次=(B.批次 || '#') and b.启用 = 1 and (A.科室id=科室id_In or A.科室ID=0) and A.配置中心id=部门id_In order by A.科室id desc, A.配药批次 asc) loop

    n_科室id:=R_Batch.科室id;

  --该病人按批次排序，执行时间，优先级排序,各个批次现有的容量，优先级在产生输液配药记录的时候写入
    n_总量:=0;
    for r_item in (Select a.Id 配药id, d.单量,A.瓶签号,A.配药批次
    From 输液配药记录 A, 病人医嘱记录 B, 输液配药内容 C, 药品收发记录 D, 药品规格 E, 药品特性 F,配药工作批次 G
    Where a.Id = c.记录id And c.收发id = d.Id And d.药品id = e.药品id And e.药名id = f.药名id And a.部门id = 部门id_In and G.配置中心ID=a.部门id And
          a.医嘱id = b.Id And b.病人id = 病人id_In And A.配药批次=G.批次 And G.批次<>0 and g.启用 = 1 and G.药品类型 is null And f.溶媒 = 1 And a.执行时间 Between Trunc(执行日期_In ) And
          Trunc(执行日期_In+1) - 1 / 24 / 60 / 60 And A.操作状态<2 and A.配药批次<=decode(n_自动排批模式,1,R_Batch.配药批次,100)
    Order By a.配药批次,to_number(a.优先级), a.执行时间, d.单量 desc) loop

      if instr(','|| v_配药id,','|| r_item.配药id || ',',1)<1 then
        --当该配药id首次循环的时候对其单量进行累计
        v_配药id:=v_配药id || r_item.配药id || ',';
        n_总量:=n_总量+r_item.单量;
        v_批次串:=v_批次串 || r_item.配药id || ',' || R_Batch.配药批次 || '|';
      elsif instr('|'|| v_批次串,'|'|| r_item.配药id || ',' || R_Batch.配药批次 || '|',1)>0 and n_总量<>0 then
        --当该配药id及批次出现过，则累计该单量
        n_总量:=n_总量+r_item.单量;
      end if;

      if n_总量>=R_Batch.容量 then
        exit;
      end if;

    end loop;
  end loop;

  --如果该科室设置了单独的容量信息则不考虑所有科室的模式
  for r_item in (Select a.Id 配药id, d.单量,A.瓶签号
  From 输液配药记录 A, 病人医嘱记录 B, 输液配药内容 C, 药品收发记录 D, 药品规格 E, 药品特性 F,配药工作批次 G
  Where a.Id = c.记录id And c.收发id = d.Id And d.药品id = e.药品id And e.药名id = f.药名id And a.部门id = 部门id_In  And
        a.医嘱id = b.Id And b.病人id = 病人id_In And A.配药批次=G.批次 And G.批次<>0 and g.启用 = 1 and G.配置中心ID=a.部门id and G.药品类型 is null And f.溶媒 = 1  
        And A.操作状态<2 And a.执行时间 Between Trunc(执行日期_In) And Trunc(执行日期_In+1) - 1 / 24 / 60 / 60
  Order By a.配药批次,to_number(a.优先级),a.执行时间, d.单量) loop
    if instr(','|| v_配药id,','|| r_item.配药id || ',',1)<1then
      --没有进行自动分批的输液单直接在最后一个批次
      v_配药id:=v_配药id || r_item.配药id || ',';
      v_批次串:=v_批次串 || r_item.配药id || ',' || v_批次 || '|';
    end if;
  end loop;


  --根据自动调批修正数据
  while v_批次串 is not null loop
    --分解单据ID串
    v_Fields := Substr(v_批次串, 1, Instr(v_批次串, '|') - 1);
    v_Tansid := Substr(v_Fields, 1, Instr(v_Fields, ',') - 1);
    v_batch   := Substr(v_Fields, Instr(v_Fields, ',') + 1);


    v_批次串 := Replace('|' || v_批次串, '|' || v_Fields || '|');

    Select Nvl(max(打包), 0),max(药品类型) Into n_打包,v_配药类型 From 配药工作批次 Where 批次 = v_batch And 配置中心id=部门id_In;

    Select 配药批次 Into v_历史批次 From 输液配药记录 Where id=v_Tansid;
    update 输液配药记录 set 配药批次=v_batch,是否确认调整=0 where id=v_Tansid;

    Update 输液配药记录 Set 是否确认调整 = 0
    Where 医嘱id In (Select ID From 病人医嘱记录 Where 病人id = 病人id_In)
    And 执行时间 Between Trunc(执行日期_In) And Trunc(执行日期_In + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;

    If n_打包<>0 And v_配药类型 is Null Then
      update 输液配药记录 Set 是否打包=n_打包 where id=v_Tansid;
    Else
      Select Nvl(max(打包), 0) Into n_打包 From 配药工作批次 Where 批次 = v_历史批次 And 配置中心id=部门id_In;
      If n_打包<>0 Then
        Update 输液配药记录 Set 是否打包=0 where id=v_Tansid And trunc(执行时间)>trunc(Sysdate) ;
      End If;
    End If;
  end loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_输液配药记录_自动排批;
/

--120705:蒋廷中,2018-01-23,手术权限管理审核通过报错
--113951:蒋廷中,2018-01-17,手术授权管理模块增加权限授权审核
CREATE OR REPLACE Procedure Zl_人员手术权限_Update
(
  人员ids_In     Varchar2,
  诊疗项目ids_In Varchar2,
  权限_In        Number := 0,
  删除_In        Number := 0,
  审核状态_In    人员手术权限申请.审核状态%Type := 0,
  申请人_In      人员手术权限申请.申请人%Type := Null,
  审批人_In      人员手术权限申请.审批人%Type := Null
)
--参数：人员ID_In 为人员ID的串，以逗号分割 
  --      权限_in=0，同时授开单和执行权，1=授开单权，2=授执行权,3=不插入任何权限，主要适用于单个取消权限。 
  --     删除_In=0不删除，=1删除对应的所有权限（根据传入的权限_in来判断），=2删除传入的诊疗项目ID的开单和执行权，=3只删除指定项目的开单权，=4只删除指定项目的执行权 
  --     审核状态_In= -0不审核,1-待审，2-审核通过,3-审核不通过
 Is
  Cursor c_Patiinfo Is
    Select * From Table(Cast(f_Str2list(人员ids_In) As t_Strlist));
Begin
  --不需要审核，直接保存
  If 审核状态_In = 0 Then
    For r_Patiinfo In c_Patiinfo Loop
      If 删除_In = 1 Then
        If 权限_In = 0 Then
          --授开单权和执行权时，不能删除只有开单权和执行权的手术项目 
          Delete From 人员手术权限 A
          Where a.人员id = To_Number(r_Patiinfo.Column_Value) And
                (Exists (Select 1
                         From 人员手术权限 B
                         Where b.诊疗项目id = a.诊疗项目id And a.人员id = b.人员id And a.记录性质 <> b.记录性质) Or
                 诊疗项目id In (Select Column_Value From Table(Cast(f_Str2list(诊疗项目ids_In) As t_Strlist))));
        Else
          Delete From 人员手术权限 Where 人员id = To_Number(r_Patiinfo.Column_Value) And 记录性质 = 权限_In;
        End If;
      Elsif 删除_In = 2 Then
        Delete From 人员手术权限
        Where 人员id = To_Number(r_Patiinfo.Column_Value) And
              诊疗项目id In (Select Column_Value From Table(Cast(f_Str2list(诊疗项目ids_In) As t_Strlist)));
      Elsif 删除_In = 3 Then
        Delete From 人员手术权限
        Where 人员id = To_Number(r_Patiinfo.Column_Value) And
              诊疗项目id In (Select Column_Value From Table(Cast(f_Str2list(诊疗项目ids_In) As t_Strlist))) And 记录性质 = 1;
      Elsif 删除_In = 4 Then
        Delete From 人员手术权限
        Where 人员id = To_Number(r_Patiinfo.Column_Value) And
              诊疗项目id In (Select Column_Value From Table(Cast(f_Str2list(诊疗项目ids_In) As t_Strlist))) And 记录性质 = 2;
      End If;
      If 权限_In = 0 Or 权限_In = 1 Then
        Insert Into 人员手术权限
          (人员id, 诊疗项目id, 记录性质)
          Select To_Number(r_Patiinfo.Column_Value), Column_Value, 1
          From Table(Cast(f_Str2list(诊疗项目ids_In) As t_Strlist));
      
      End If;
      If 权限_In = 0 Or 权限_In = 2 Then
        Insert Into 人员手术权限
          (人员id, 诊疗项目id, 记录性质)
          Select To_Number(r_Patiinfo.Column_Value), Column_Value, 2
          From Table(Cast(f_Str2list(诊疗项目ids_In) As t_Strlist));
      End If;
    End Loop;
  Elsif 审核状态_In = 1 Then
    If 删除_In = 1 Then
      --删除重复的权限申请
      Delete From 人员手术权限申请 A
      Where (a.授权人员id, a.诊疗项目id) In
            ((Select To_Number(b.Column_Value) As 人员id, To_Number(a.Column_Value) As 诊疗项目id
              From Table(Cast(f_Num2list(诊疗项目ids_In) As t_Numlist)) A, Table(Cast(f_Num2list(人员ids_In) As t_Numlist)) B
              Minus
              Select 人员id, 诊疗项目id
              From 人员手术权限
              Where 人员id In (Select Column_Value From Table(Cast(f_Num2list(人员ids_In) As t_Numlist)))
              Group By 人员id, 诊疗项目id
              Having Decode(Sum(记录性质), 3, 权限_In, 2, 2, 1, 1, 3) = 权限_In) Union
             (Select 人员id, 诊疗项目id
              From 人员手术权限
              Where 人员id In (Select Column_Value From Table(Cast(f_Num2list(人员ids_In) As t_Numlist)))
              Group By 人员id, 诊疗项目id
              Having Decode(Sum(记录性质), 3, 权限_In, 2, 2, 1, 1, 3) = 权限_In
              Minus
              Select b.Column_Value As 人员id, To_Number(a.Column_Value) As 诊疗项目id
              From Table(Cast(f_Num2list(诊疗项目ids_In) As t_Numlist)) A, Table(Cast(f_Num2list(人员ids_In) As t_Numlist)) B));
    
      --新增或修改权限的申请
      If 权限_In <> 3 Then
        Insert Into 人员手术权限申请
          (ID, 授权人员id, 诊疗项目id, 权限, 申请人, 申请时间, 审核状态)
          Select 人员手术权限申请_Id.Nextval, To_Number(a.人员id), a.诊疗项目id, 权限_In, 申请人_In, Sysdate, 审核状态_In
          From (Select To_Number(b.Column_Value) As 人员id, To_Number(a.Column_Value) As 诊疗项目id, 权限_In As 权限
                 From Table(Cast(f_Num2list(诊疗项目ids_In) As t_Numlist)) A, Table(Cast(f_Num2list(人员ids_In) As t_Numlist)) B
                 Minus
                 Select 人员id, 诊疗项目id, Decode(Sum(记录性质), 3, Decode(删除_In, 1, 权限_In, 0), 2, 2, 1, 1, 3) As 权限
                 From 人员手术权限
                 Where 人员id In (Select Column_Value From Table(Cast(f_Num2list(人员ids_In) As t_Numlist)))
                 Group By 人员id, 诊疗项目id
                 Having Decode(Sum(记录性质), 3, 权限_In, 2, 2, 1, 1, 3) = 权限_In) A;
      End If;
    
      --删除权限的申请
      If 权限_In = 0 Or 权限_In = 3 Then
        Insert Into 人员手术权限申请
          (ID, 授权人员id, 诊疗项目id, 权限, 申请人, 申请时间, 审核状态)
          Select 人员手术权限申请_Id.Nextval, To_Number(a.人员id), a.诊疗项目id, 3, 申请人_In, Sysdate, 审核状态_In
          From (Select 人员id, 诊疗项目id, Decode(Sum(记录性质), 3, Decode(删除_In, 1, 权限_In, 0), 2, 2, 1, 1, 3) As 权限
                 From 人员手术权限
                 Where 人员id In (Select Column_Value From Table(Cast(f_Num2list(人员ids_In) As t_Numlist)))
                 Group By 人员id, 诊疗项目id
                 Having Decode(Sum(记录性质), 3, 权限_In, 2, 2, 1, 1, 3) = 权限_In
                 Minus
                 Select b.Column_Value As 人员id, a.Column_Value As 诊疗项目id, 权限_In As 权限
                 From Table(Cast(f_Num2list(诊疗项目ids_In) As t_Numlist)) A, Table(Cast(f_Num2list(人员ids_In) As t_Numlist)) B) A;
      End If;
    Else
      --删除重复的权限申请
      For r_Patiinfo In c_Patiinfo Loop
        Delete From 人员手术权限申请 A
        Where a.授权人员id = To_Number(r_Patiinfo.Column_Value) And
              (Exists (Select 1
                       From 人员手术权限申请 B
                       Where b.诊疗项目id = a.诊疗项目id And a.授权人员id = b.授权人员id And a.权限 <> b.权限) Or
               诊疗项目id In (Select Column_Value From Table(Cast(f_Str2list(诊疗项目ids_In) As t_Strlist))));
        --新增或修改权限的申请
        Insert Into 人员手术权限申请
          (ID, 授权人员id, 诊疗项目id, 权限, 申请人, 申请时间, 审核状态)
          Select 人员手术权限申请_Id.Nextval, To_Number(r_Patiinfo.Column_Value), Column_Value, 权限_In, 申请人_In, Sysdate, 审核状态_In
          From Table(Cast(f_Str2list(诊疗项目ids_In) As t_Strlist));
      End Loop;
    End If;
    --同意授权
  Elsif 审核状态_In = 2 Then
    Delete From 人员手术权限
    Where 人员id = 人员ids_In And
          诊疗项目id In (Select 诊疗项目id From 人员手术权限申请 Where 人员id = 人员ids_In And 审核状态 = 1);
    Insert Into 人员手术权限
      (人员id, 诊疗项目id, 记录性质)
      Select 授权人员id As 人员id, 诊疗项目id, 1 As 记录性质
      From 人员手术权限申请
      Where 授权人员id = 人员ids_In And 审核状态 = 1 And (权限 = 0 Or 权限 = 1)
      Union
      Select 授权人员id As 人员id, 诊疗项目id, 2 As 记录性质
      From 人员手术权限申请
      Where 授权人员id = 人员ids_In And 审核状态 = 1 And (权限 = 0 Or 权限 = 2);
  
    Update 人员手术权限申请
    Set 审核状态 = 2, 审批人 = 审批人_In, 审批时间 = Sysdate
    Where 授权人员id = 人员ids_In And 审核状态 = 1;
  
    --拒绝授权
  Elsif 审核状态_In = 3 Then
    Update 人员手术权限申请
    Set 审核状态 = 3, 审批人 = 审批人_In, 审批时间 = Sysdate
    Where 授权人员id = 人员ids_In And 审核状态 = 1;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_人员手术权限_Update;
/

--109869:胡俊勇,2018-01-17,医嘱单校对后套打
Create Or Replace Procedure Zl_病人医嘱打印_Update
(
  医嘱id_In     In 病人医嘱打印.医嘱id%Type,
  页号_In       In 病人医嘱打印.页号%Type,
  行号_In       In 病人医嘱打印.行号%Type,
  病人id_In     In 病人医嘱打印.病人id%Type := Null,
  主页id_In     In 病人医嘱打印.主页id%Type := Null,
  婴儿_In       In 病人医嘱打印.婴儿%Type := Null,
  期效_In       In 病人医嘱打印.期效%Type := Null,
  时间_In       In 病人医嘱打印.打印时间%Type := Null,
  操作员姓名_In In 人员表.姓名%Type := Null,
  打印模式_In   In Number := 0, --0-校对后打印，1-新开后打印, 
  标记_In       In 病人医嘱打印.打印标记%Type := Null
) Is
  ----标记_In 停嘱打印时传入，否则认为是常规打印 
  v_标记     病人医嘱打印.打印标记%Type;
  v_Temp     Varchar2(255);
  v_人员姓名 病人医嘱打印.打印人%Type;
  d_校对时间 Date;
Begin
  If 标记_In <> 0 Then
    If 医嘱id_In Is Not Null Then
      Select 校对时间, Decode(确认停嘱时间, Null, Decode(执行终止时间, Null, 0, 1), 2)
      Into d_校对时间, v_标记
      From 病人医嘱记录
      Where ID = 医嘱id_In;
      If v_标记 = 0 And d_校对时间 Is Not Null And 打印模式_In = 1 Then
        v_标记 := 3;
      End If;
    End If;
    Update 病人医嘱打印 Set 打印标记 = v_标记 Where 医嘱id = 医嘱id_In And 页号 = 页号_In And 行号 = 行号_In;
  Else
    --当前操作人员 
    If 操作员姓名_In Is Not Null Then
      v_人员姓名 := 操作员姓名_In;
    Else
      v_Temp     := Zl_Identity;
      v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
      v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
      v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    End If;
  
    --打印时已确认停止的医嘱标记为已打印停止标记   
    v_标记 := 0;
    If 医嘱id_In Is Not Null Then
      Select 校对时间, Decode(确认停嘱时间, Null, Decode(打印模式_In, 1, Decode(执行终止时间, Null, 0, 1), 0), 2)
      Into d_校对时间, v_标记
      From 病人医嘱记录
      Where ID = 医嘱id_In;
      If v_标记 = 0 And d_校对时间 Is Not Null Then
        v_标记 := 3;
      End If;
    End If;
  
    Update 病人医嘱打印
    Set 打印标记 = v_标记, 打印人 = v_人员姓名, 打印时间 = 时间_In
    Where 医嘱id = 医嘱id_In And 页号 = 页号_In And 行号 = 行号_In And 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And
          期效 = 期效_In And 打印时间 Is Null;
          
    If 医嘱id_In Is Null Then
      ----特殊医嘱标记为打印 
      Update 病人医嘱打印
      Set 打印标记 = v_标记, 打印人 = v_人员姓名, 打印时间 = 时间_In
      Where 医嘱id Is Null And 页号 = 页号_In And 行号 = 行号_In And 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And
            期效 = 期效_In And 打印时间 Is Null;
    End If;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱打印_Update;
/

--120005:廖思奇,2018-01-16,ZLHIS锚点消息的相关补充处理  
Create Or Replace Procedure Zl_影像检查_Cancel
(
  医嘱id_In     影像检查记录.医嘱id%Type,
  发送号_In     影像检查记录.发送号%Type,
  单独执行_In   Number := 0,
  执行部门id_In 部门表.Id%Type := 0
  --参数：
  --      医嘱ID_IN=单独执行的医嘱ID。
  --      单独执行_In=检查医嘱组合是否采用对每个项目分散单独执行的方式,0-不单独执行
) Is
  Cursor c_Advice Is
    Select ID, 相关id, Nvl(相关id, ID) As 组id, 诊疗类别, 病人来源 From 病人医嘱记录 Where ID = 医嘱id_In;
  r_Advice c_Advice%RowType;

  n_报告id Number;
  n_Count  Number;
  b_Delete Boolean;
Begin
  n_报告id := 0;

  --取主医嘱ID
  Open c_Advice;
  Fetch c_Advice
    Into r_Advice;
  Close c_Advice;

  --如果是成套执行医嘱，则取消检查的时候，删除报告，删除影像检查记录
  --如果是单独执行医嘱，则只有在取消最后一条医嘱的时候，才删除报告，删除影像检查记录
  b_Delete := False;

  If Nvl(单独执行_In, 0) = 0 Then
    b_Delete := True;
  Else
    Select Count(*)
    Into n_Count
    From 病人医嘱发送
    Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = r_Advice.组id Or 相关id = r_Advice.组id) And (执行状态 = 1 Or 执行状态 = 3);
    If n_Count = 1 Then
      Select Count(*) Into n_Count From 病人医嘱发送 Where 医嘱id = 医嘱id_In;
      If n_Count = 1 Then
        b_Delete := True;
      End If;
    End If;
  End If;

  --删除报告信息和影像信息
  If b_Delete = True Then
    Begin
      Select 病历id Into n_报告id From 病人医嘱报告 Where 医嘱id = r_Advice.组id;
    Exception
      When Others Then
        Null;
    End;
  
    Delete From 影像危急值记录 Where 医嘱id = 医嘱id_In;
  
    Delete 电子病历记录 Where ID = n_报告id;
  
    Delete From 影像检查记录 Where 医嘱id = r_Advice.组id;
  
    Delete From 影像报告记录 Where 医嘱id = r_Advice.组id;
  End If;

  --调用统一的医嘱执行Cancel过程
  Zl_病人医嘱执行_Cancel(医嘱id_In, 发送号_In, Null, 单独执行_In, 执行部门id_In);

  --先处理医嘱执行Cancel之后，再设置病人医嘱发送表的状态,PACS中有些字段定义不一样，要特殊处理
  --取消医嘱执行
  If Nvl(单独执行_In, 0) = 0 Then
    Update 病人医嘱发送
    Set 首次时间 = Null, 报到时间 = Null, 末次时间 = Null, 执行间 = Null, 执行状态 = 0, 执行过程 = 0, 结果阳性 = Null
    Where 发送号 = 发送号_In And 医嘱id In (Select ID From 病人医嘱记录 Where ID = r_Advice.组id Or 相关id = r_Advice.组id);
  Else
    Update 病人医嘱发送
    Set 首次时间 = Null, 报到时间 = Null, 末次时间 = Null, 执行间 = Null, 执行状态 = 0, 执行过程 = 0, 结果阳性 = Null
    Where 发送号 = 发送号_In And 医嘱id = 医嘱id_In;
  End If;

  If b_Delete = True Then
    b_Message.Zlhis_Pacs_003(医嘱id_In, 2, 0);
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_影像检查_Cancel;
/

--120005:廖思奇,2018-01-16,ZLHIS锚点消息的相关补充处理  
Create Or Replace Procedure Zl_影像检查_Photodelete
(
  医嘱id_In 影像检查记录.医嘱id%Type,
  发送号_In 影像检查记录.发送号%Type
) Is
Begin
  --更新影像检查记录并删除影像检查序列和影像检查图像
  Delete 影像检查序列
  Where 检查uid = (Select 检查uid From 影像检查记录 Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In);

  Update 影像检查记录
  Set 检查uid = Null, 位置一 = Null, 位置二 = Null, 位置三 = Null, 报告图象 = Null, 接收日期 = Null
  Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_影像检查_Photodelete;
/

--120005:廖思奇,2018-01-16,ZLHIS锚点消息的相关补充处理  
Create Or Replace Procedure Zl_影像检查_State
(
  医嘱id_In         影像检查记录.医嘱id%Type,
  发送号_In         影像检查记录.发送号%Type,
  执行过程_In       病人医嘱发送.执行过程%Type,
  删除报告_In       Number := 0, --1删除报告，无报告完成
  操作员编号_In     人员表.编号%Type := Null,
  操作员姓名_In     人员表.姓名%Type := Null,
  执行部门id_In     门诊费用记录.执行部门id%Type := Null,
  完成时间_In       病人医嘱发送.完成时间%Type := Null,
  报告编辑器类型_In Number := Null --1-老版PACS报告，2-老版病历编辑器报告
) Is

  v_Temp           Varchar2(255);
  v_人员编号       人员表.编号%Type;
  v_人员姓名       人员表.姓名%Type;
  n_部门id         部门表.Id%Type;
  n_报告id         Number;
  v_完成人         人员表.姓名%Type;
  d_完成时间       Date;
  n_Risid          Number;
  n_消息类型       Number(1); --1 ZLHIS_PACS_001（完成）   2 002（同步） 3 003(回退)  4 004（撤销）
  n_存在的执行过程 病人医嘱发送.执行过程%Type;
  Cursor c_Temp Is
    Select 病历id, 检查报告id From 病人医嘱报告 Where 医嘱id = 医嘱id_In;

  r_报告id c_Temp%RowType;
Begin

  --消息平台处理
  n_消息类型 := 0;

  Select Max(执行过程)
  Into n_存在的执行过程
  From 病人医嘱发送
  Where 发送号 + 0 = 发送号_In And 医嘱id In (Select ID From 病人医嘱记录 Where (ID = 医嘱id_In Or 相关id = 医嘱id_In));

  If 执行过程_In = 6 Then
    n_消息类型 := 1;
  Elsif n_存在的执行过程 = 6 Then
    n_消息类型 := 4;
  Elsif n_存在的执行过程 = 3 And 执行过程_In = 2 Then
    n_消息类型 := 3;
  Else
    n_消息类型 := 2;
  End If;

  If 执行过程_In = n_存在的执行过程 And (执行过程_In > 1 And 执行过程_In < 6) Then
    n_消息类型 := 5;
  End If;

  --取得报告完成人和时间
  If 执行过程_In = 6 Then
    v_完成人   := 操作员姓名_In;
    d_完成时间 := 完成时间_In;
  End If;

  --取当前操作人员
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null And 执行部门id_In Is Not Null Then
    v_人员编号 := 操作员编号_In;
    v_人员姓名 := 操作员姓名_In;
    n_部门id   := 执行部门id_In;
  Else
    v_Temp     := Zl_Identity;
    n_部门id   := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;

  n_报告id := 0;

  If 删除报告_In <> 0 Then
    Begin
      Select 病历id, Risid Into n_报告id, n_Risid From 病人医嘱报告 Where 医嘱id = 医嘱id_In;
    Exception
      When Others Then
        Null;
    End;
    If n_Risid Is Null Then
      Delete 电子病历记录 Where ID = n_报告id;
      Zl_影像报告标记_Clear(医嘱id_In);
    End If;
  End If;

  --只更新跟主医嘱执行状态相同的部位医嘱，跟主医嘱执行状态不同的部位医嘱，是被分部位取消执行的
  Update 病人医嘱发送 A
  Set a.执行状态 = Decode(执行过程_In, 6, 1, 3), a.执行过程 = 执行过程_In, a.完成人 = v_完成人, a.完成时间 = d_完成时间, a.采样时间 = Sysdate
  Where a.发送号 + 0 = 发送号_In And
        a.医嘱id In (Select b.Id
                   From 病人医嘱记录 B, 病人医嘱发送 C
                   Where b.Id = c.医嘱id And (b.Id = 医嘱id_In Or b.相关id = 医嘱id_In) And
                         c.执行状态 = (Select d.执行状态 From 病人医嘱发送 D Where d.医嘱id = 医嘱id_In));

  If 执行过程_In = 5 Then
    Update 影像检查记录 Set 完成人 = Null Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In;
  
    Begin
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 8, 医嘱id_In || ',' || 发送号_In;
    Exception
      When Others Then
        Null;
    End;
  Elsif 执行过程_In = 6 Then
    Update 影像检查记录 Set 完成人 = v_人员姓名 Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In;
  
    --如果是检查完成，则不需要判断参数“执行费用_In”，检查完成时，必须执行费用
    Zl_影像费用执行(医嘱id_In, 发送号_In, 执行过程_In, 0, v_人员编号, v_人员姓名, n_部门id);
  End If;

  --消息平台处理
  Open c_Temp;
  Fetch c_Temp
    Into r_报告id;
  If n_消息类型 = 1 Then
    While c_Temp% Found Loop
      If r_报告id.病历id > 0 Then
        b_Message.Zlhis_Pacs_001(医嘱id_In, r_报告id.病历id, 报告编辑器类型_In);
      Else
        b_Message.Zlhis_Pacs_001(医嘱id_In, r_报告id.检查报告id, 报告编辑器类型_In);
      End If;
      Fetch c_Temp
        Into r_报告id;
    End Loop;
  Elsif n_消息类型 = 2 Then
    b_Message.Zlhis_Pacs_002(医嘱id_In, n_存在的执行过程, 执行过程_In);
  Elsif n_消息类型 = 3 Then
    b_Message.Zlhis_Pacs_003(医嘱id_In, 3, 2);
  Elsif n_消息类型 = 4 Then
    While c_Temp% Found Loop
      If r_报告id.病历id > 0 Then
        b_Message.Zlhis_Pacs_004(医嘱id_In, r_报告id.病历id, 报告编辑器类型_In);
      Else
        b_Message.Zlhis_Pacs_004(医嘱id_In, r_报告id.检查报告id, 报告编辑器类型_In);
      End If;
      Fetch c_Temp
        Into r_报告id;
    End Loop;
  
  End If;
  Close c_Temp;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_影像检查_State;
/

--120005:廖思奇,2018-01-16,ZLHIS锚点消息的相关补充处理 .
Create Or Replace Procedure Zl_影像检查_危急更新
(
  医嘱id_In   In 影像检查记录.医嘱id%Type,
  危急状态_In In 影像检查记录.危急状态%Type
) Is

Begin
  Update 影像检查记录 Set 危急状态 = 危急状态_In Where 医嘱id = 医嘱id_In;
  If 危急状态_In = 1 Then
    b_Message.Zlhis_Pacs_005(医嘱id_In);
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_影像检查_危急更新;
/
 
--120005:廖思奇,2018-01-16,ZLHIS锚点消息的相关补充处理  
Create Or Replace Procedure Zl_影像检查_状态更新
(
  医嘱id_In     影像检查记录.医嘱id%Type,
  发送号_In     影像检查记录.发送号%Type,
  报告id_In     影像报告记录.Id%Type,
  执行过程_In   病人医嘱发送.执行过程%Type,
  删除报告_In   Number := 0, --1删除报告，无报告完成
  操作员编号_In 人员表.编号%Type := Null,
  操作员姓名_In 人员表.姓名%Type := Null,
  执行部门id_In 门诊费用记录.执行部门id%Type := Null,
  完成时间_In   病人医嘱发送.完成时间%Type := Null
) Is
  v_Temp           Varchar2(255);
  v_人员编号       人员表.编号%Type;
  v_人员姓名       人员表.姓名%Type;
  n_部门id         部门表.Id%Type;
  v_完成人         人员表.姓名%Type;
  d_完成时间       Date;
  n_消息类型       Number(1); --1 ZLHIS_PACS_001（完成）   2 ZLHIS_PACS_002（同步）   3 ZLHIS_PACS_004（撤销）
  n_存在的执行过程 病人医嘱发送.执行过程%Type;
  Cursor c_Temp Is
    Select 病历id, 检查报告id From 病人医嘱报告 Where 医嘱id = 医嘱id_In;

  r_报告id c_Temp%RowType;
Begin

  --消息平台处理
  n_消息类型 := 0;

  Select Max(执行过程)
  Into n_存在的执行过程
  From 病人医嘱发送
  Where 发送号 + 0 = 发送号_In And 医嘱id In (Select ID From 病人医嘱记录 Where (ID = 医嘱id_In Or 相关id = 医嘱id_In));

  If 执行过程_In = 6 Then
    n_消息类型 := 1;
  Elsif n_存在的执行过程 = 6 Then
    n_消息类型 := 3;
  Else
    n_消息类型 := 2;
  End If;

  If 执行过程_In = n_存在的执行过程 And (执行过程_In > 1 And 执行过程_In < 6) Then
    n_消息类型 := 4;
  End If;

  --取得报告完成人和时间
  If 执行过程_In = 6 Then
    v_完成人   := 操作员姓名_In;
    d_完成时间 := 完成时间_In;
  End If;

  --取当前操作人员
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null And 执行部门id_In Is Not Null Then
    v_人员编号 := 操作员编号_In;
    v_人员姓名 := 操作员姓名_In;
    n_部门id   := 执行部门id_In;
  Else
    v_Temp     := Zl_Identity;
    n_部门id   := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;

  If 删除报告_In <> 0 Then
    Delete 影像报告记录 Where 医嘱id = 医嘱id_In;
    Zl_影像报告标记_Clear(医嘱id_In);
  End If;

  Update 病人医嘱发送
  Set 执行状态 = Decode(执行过程_In, 6, 1, 3), 执行过程 = 执行过程_In, 完成人 = v_完成人, 完成时间 = d_完成时间, 采样时间 = Sysdate
  Where 发送号 + 0 = 发送号_In And 医嘱id In (Select ID From 病人医嘱记录 Where (ID = 医嘱id_In Or 相关id = 医嘱id_In));

  If 执行过程_In = 5 Then
    Update 影像检查记录 Set 完成人 = Null Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In;
  
    Begin
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 8, 医嘱id_In || ',' || 发送号_In || ',' || 报告id_In;
    Exception
      When Others Then
        Null;
    End;
  Elsif 执行过程_In = 6 Then
    Update 影像检查记录 Set 完成人 = v_人员姓名 Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In;
  
    --如果是检查完成，则不需要判断参数“执行费用_In”，检查完成时，必须执行费用
    Zl_影像费用执行(医嘱id_In, 发送号_In, 执行过程_In, 0, v_人员编号, v_人员姓名, n_部门id);
  End If;

  --消息平台处理
  Open c_Temp;
  Fetch c_Temp
    Into r_报告id;
  If n_消息类型 = 1 Then
    If 报告id_In > 0 Then
      b_Message.Zlhis_Pacs_001(医嘱id_In, 报告id_In, 3);
    Else
      While c_Temp% Found Loop
        If r_报告id.病历id > 0 Then
          b_Message.Zlhis_Pacs_001(医嘱id_In, r_报告id.病历id, 3);
        Else
          b_Message.Zlhis_Pacs_001(医嘱id_In, r_报告id.检查报告id, 3);
        End If;
        Fetch c_Temp
          Into r_报告id;
      End Loop;
    End If;
  
  Elsif n_消息类型 = 2 Then
    b_Message.Zlhis_Pacs_002(医嘱id_In, n_存在的执行过程, 执行过程_In);
  Elsif n_消息类型 = 3 Then
    If 报告id_In > 0 Then
      b_Message.Zlhis_Pacs_004(医嘱id_In, 报告id_In, 3);
    Else
      While c_Temp% Found Loop
        If r_报告id.病历id > 0 Then
          b_Message.Zlhis_Pacs_004(医嘱id_In, r_报告id.病历id, 3);
        Else
          b_Message.Zlhis_Pacs_004(医嘱id_In, r_报告id.检查报告id, 3);
        End If;
        Fetch c_Temp
          Into r_报告id;
      End Loop;
    End If;
  End If;
  Close c_Temp;

Exception

  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_影像检查_状态更新;
/

--120005:廖思奇,2018-01-16,ZLHIS锚点消息的相关补充处理  
Create Or Replace Procedure Zl_影像图象_Delete
(
  医嘱id_In   In 影像检查记录.医嘱id%Type,
  发送号_In   In 影像检查记录.发送号%Type,
  图像uid_In  In 影像检查图象.图像uid%Type,
  报告图象_In In 影像检查记录.报告图象%Type
) Is
  v_序列uid Varchar2(255);
  n_Row     Number(8);
Begin
  Update 影像检查记录 Set 报告图象 = 报告图象_In Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In;
  Select Distinct 序列uid Into v_序列uid From 影像检查图象 Where 图像uid = 图像uid_In;
  Delete 影像检查图象 Where 图像uid = 图像uid_In;
  Select Count(图像uid) Into n_Row From 影像检查图象 Where 序列uid = v_序列uid;
  If n_Row = 0 Then
    Delete 影像检查序列 Where 序列uid = v_序列uid;
    Select Count(b.序列uid)
    Into n_Row
    From 影像检查记录 A, 影像检查序列 B
    Where a.检查uid = b.检查uid And a.医嘱id = 医嘱id_In And a.发送号 = 发送号_In;
    If n_Row = 0 Then
      Update 影像检查记录
      Set 检查uid = Null, 位置一 = Null, 位置二 = Null, 位置三 = Null, 报告图象 = Null, 接收日期 = Null
      Where 医嘱id = 医嘱id_In;
    End If;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_影像图象_Delete;
/

--120005:廖思奇,2018-01-16,ZLHIS锚点消息的相关补充处理  
Create Or Replace Procedure Zl_影像序列_Delete
(
  医嘱id_In  In 影像检查记录.医嘱id%Type,
  序列uid_In In 影像检查序列.序列uid%Type
) Is
  n_Row Number(8);
Begin
  Delete 影像检查序列 Where 序列uid = 序列uid_In;

  Select Count(b.序列uid)
  Into n_Row
  From 影像检查记录 A, 影像检查序列 B
  Where a.检查uid = b.检查uid And a.医嘱id = 医嘱id_In;
  If n_Row = 0 Then
    Update 影像检查记录
    Set 检查uid = Null, 位置一 = Null, 位置二 = Null, 位置三 = Null, 报告图象 = Null, 接收日期 = Null
    Where 医嘱id = 医嘱id_In;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_影像序列_Delete;
/

--120005:廖思奇,2018-01-16,ZLHIS锚点消息的相关补充处理  
CREATE OR REPLACE Procedure Zl_排队叫号队列_状态更新
(
  队列id_In    排队叫号队列.Id%Type,
  排队状态_In  排队叫号队列.排队状态%Type
) Is
Begin
  --当恢复到排队状态时，需要情况呼叫医生和呼叫时间，同时需要重新设置排队时间
  Update 排队叫号队列
  Set 排队状态 = 排队状态_In,
      呼叫医生=case 排队状态 when 0 then null else 呼叫医生 end,
      呼叫时间=case 排队状态 when 0 then null else 呼叫时间 end,
      排队时间=case 排队状态 when 0 then sysdate else 排队时间 end
  Where ID = 队列id_In;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_排队叫号队列_状态更新;
/

--120256:李业庆,2018-01-16,增加卫材出库顺序参数
Create Or Replace Function Zl_Fun_Getprice
(
  药品id_In     In 药品库存.药品id%Type,
  库房id_In     In 药品库存.库房id%Type,
  总出库数量_In In 药品库存.实际数量%Type,
  备货材料_In   In Number := 0,
  备货批次_In   In Number := Null
) Return Varchar2 Is
  ----------------------------------
  --功能：根据传过来的参数返回出库药品、卫材的售价|原售价|成本价|剩余数量，中间用“|”隔断；剩余数量等于0表示数量足够，大于0则表示数量不够
  --规则：
  --      1、循环游标判断总出库数量与游标中每条记录数量是否充足，如果充足就是总数量，不充足挨个遍历直到数量直到遍历完并退出
  --      2、售价计算方式：调用Zl_Fun_Getoutprice通用过程取价格
  --      3、成本价计算方式：调用Zl_Fun_Getoutcost通用过程取价格
  --参数：
  --      药品id_In：药品id、卫材id
  --      库房id_In：发药库房
  --      总出库数量_In；总出库数量
  --      备货材料_In：只有高值卫材才需要传入，非0表示是高值卫材模式
  --      备货材料批次_In：支持高值卫材扫码确定批次出库，所以35.70支持材料非备货材料模式按批次出库；药品不支持这种模式，即药品批次都传空，做兼容性判断，即使传了非空，只要是药品都不管批次
  -----------------------------------
  n_Outmode    Number;
  n_类别       Number;
  n_分批       药品规格.药房分批%Type;
  v_名称       收费项目目录.名称%Type;
  n_当前单价   收费价目.现价%Type;
  n_当前成本价 药品规格.成本价%Type;
  n_总金额     Number;
  n_总成本     Number;
  n_总出库数量 药品库存.实际数量%Type;
  n_当前数量   药品库存.实际数量%Type;
  n_数量       药品库存.实际数量%Type;

  Err_Custom Exception;
  v_Error Varchar2(255);

  Cursor c_Stock Is
    Select 库房id, 药品id, 批次, Nvl(可用数量, 0) As 可用数量, Nvl(实际数量, 0) As 实际数量, Nvl(实际金额, 0) As 实际金额, Nvl(实际差价, 0) As 实际差价, 零售价,
           Nvl(平均成本价, 0) As 平均成本价
    From 药品库存
    Where 药品id = 药品id_In And 库房id = 库房id_In And 性质 = 1 And Nvl(可用数量, 0) > 0 And
          Decode(n_类别, 0, Decode(备货批次_In, Null, 0, Nvl(批次, 0)), 0) =
          Decode(n_类别, 0, Decode(备货批次_In, Null, 0, Nvl(备货批次_In, 0)), 0) And
          (Nvl(批次, 0) = 0 Or 效期 Is Null Or 效期 > Trunc(Sysdate))
    Order By Decode(n_Outmode, 1, 效期, Null), Nvl(批次, 0);
Begin
  --判断是药品还是卫材，0是卫材，1是药品，2是其他
  Select Decode(类别, '4', 0, '5', 1, '6', 1, '7', 1, 2) As 类别 Into n_类别 From 收费项目目录 Where ID = 药品id_In;

  If n_类别 = 0 Then
    --卫材分批出库方式 
    Select Zl_To_Number(Nvl(zl_GetSysParameter(156), 0)) Into n_Outmode From Dual;
  Elsif n_类别 = 1 Then
    --药品分批出库方式 
    Select Zl_To_Number(Nvl(zl_GetSysParameter(150), 0)) Into n_Outmode From Dual;
  End If;

  If n_类别 = 2 Then
    --只有药品和卫材才允许取值，其他不允许调用该函数
    Raise Err_Custom;
  End If;
  --取基本信息
  If n_类别 = 0 Then
    --卫材
    Select Nvl(a.在用分批, 0) As 分批 Into n_分批 From 材料特性 A Where a.材料id = 药品id_In;
  Elsif n_类别 = 1 Then
    --药品
    Select Nvl(a.药房分批, 0) As 分批 Into n_分批 From 药品规格 A Where a.药品id = 药品id_In;
  End If;

  n_总出库数量 := 总出库数量_In;
  n_总金额     := 0;
  n_总成本     := 0;
  n_数量       := 0;

  If 库房id_In = 0 Then
    --库房id等于0这种不确定库房的情况，随便显示一个价格给用户看
    n_当前成本价 := Zl_Fun_Getoutcost(药品id_In, 0, 0);
    --售价,取售价库房id不为0的情况没有，随便取的一个价格
    n_当前单价 := Zl_Fun_Getoutprice(药品id_In, 0, 0);
    Return n_当前单价 || '|' || n_当前成本价 || '|' || n_总出库数量;
  End If;

  For r_Stock In c_Stock Loop
    If n_分批 = 1 Then
      If n_总出库数量 <= Nvl(r_Stock.可用数量, 0) Then
        n_当前数量 := n_总出库数量;
      Else
        n_当前数量 := Nvl(r_Stock.可用数量, 0);
      End If;
    Else
      n_当前数量 := n_总出库数量;
    End If;
  
    n_当前成本价 := Zl_Fun_Getoutcost(r_Stock.药品id, r_Stock.批次, r_Stock.库房id);
    n_当前单价   := Zl_Fun_Getoutprice(r_Stock.药品id, r_Stock.批次, r_Stock.库房id);
  
    n_数量       := n_数量 + n_当前数量;
    n_总出库数量 := n_总出库数量 - n_当前数量;
    n_总金额     := n_总金额 + n_当前数量 * n_当前单价;
    n_总成本     := n_总成本 + n_当前数量 * n_当前成本价;
    If n_总出库数量 = 0 Then
      Exit;
    End If;
  End Loop;

  If n_数量 <> 0 Then
    n_当前单价   := n_总金额 / n_数量;
    n_当前成本价 := n_总成本 / n_数量;
  Else
    --无库存价格直接从收费价目取现价和直接从规格表取成本价
    n_当前单价   := Zl_Fun_Getoutprice(药品id_In, 0, 0);
    n_当前成本价 := Zl_Fun_Getoutcost(药品id_In, 0, 0);
    n_总出库数量 := 总出库数量_In;
  End If;
  Return n_当前单价 || '|' || n_当前成本价 || '|' || n_总出库数量;

Exception
  When Err_Custom Then
    Return Null;
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Fun_Getprice;
/

--119437:胡俊勇,2018-01-16,临床相关消息修改
Create Or Replace Procedure Zl_业务消息清单_Insert
(
  病人id_In     In 业务消息清单.病人id%Type,
  就诊id_In     In 业务消息清单.就诊id%Type,
  就诊科室id_In In 业务消息清单.就诊科室id%Type,
  就诊病区id_In In 业务消息清单.就诊病区id%Type,
  病人来源_In   In 业务消息清单.病人来源%Type,
  消息内容_In   In 业务消息清单.消息内容%Type,
  提醒场合_In   In 业务消息清单.提醒场合%Type,
  类型编码_In   In 业务消息清单.类型编码%Type,
  业务标识_In   In 业务消息清单.业务标识%Type,
  优先程度_In   In 业务消息清单.优先程度%Type,
  是否已阅_In   In 业务消息清单.是否已阅%Type := 0,
  登记时间_In   In 业务消息清单.登记时间%Type := Null,
  提醒部门_In   In varchar2 := Null, --部门id,可以是多个部门用逗号分割
  提醒人员_In   In varchar2 := Null --人员姓名，可以是多个用逗号分割
) Is
  n_Id   业务消息清单.Id%Type;
  d_Cur  业务消息清单.登记时间%Type;
  v_Temp varchar2(255);
  v_部门 业务消息清单.Id%Type;
  v_姓名 人员表.姓名%Type;
Begin
  Select 业务消息清单_Id.Nextval, Nvl(登记时间_In, Sysdate) Into n_Id, d_Cur From Dual;
  Insert Into 业务消息清单
    (ID, 病人id, 就诊id, 就诊科室id, 就诊病区id, 病人来源, 消息内容, 提醒场合, 类型编码, 业务标识, 优先程度, 是否已阅, 登记时间)
  Values
    (n_Id, 病人id_In, 就诊id_In, 就诊科室id_In, 就诊病区id_In, 病人来源_In, 消息内容_In, 提醒场合_In, 类型编码_In, 业务标识_In, 优先程度_In, 是否已阅_In, d_Cur);

  If 提醒部门_In Is Not Null Then
    v_Temp := 提醒部门_In || ',';
    While v_Temp Is Not Null Loop
      v_部门 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
      v_Temp := Substr(v_Temp, Instr(v_Temp, ',') + 1);
      If Nvl(v_部门, '0') <> '0' Then
        Insert Into 业务消息提醒部门 (消息id, 部门id) Values (n_Id, v_部门);
      End If;
    End Loop;
  End If;

  If 提醒人员_In Is Not Null Then
    v_Temp := 提醒人员_In || ',';
    While v_Temp Is Not Null Loop
      v_姓名 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
      v_Temp := Substr(v_Temp, Instr(v_Temp, ',') + 1);
      If v_姓名 Is Not Null Then
        Insert Into 业务消息提醒人员 (消息id, 提醒人员) Values (n_Id, v_姓名);
      End If;
    End Loop;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_业务消息清单_Insert;
/

--119449:刘硕,2018-01-16,消息集成修改完善
Create Or Replace Procedure Zlmsg_Lists_Using_Change
(
  Code_In  Zlmsg_Lists.Code%Type,
  Using_In Zlmsg_Lists.Using%Type
) Is
  --更新消息状态，通过重新编译使各个客户端进行包缓存的更新。
  --重新编译包会导致出现如下错误，各个客户端重试即可。
  --因此要求更新消息状态尽量放在业务低谷期进行。
  --ORA-04068: 已丢弃程序包  的当前状态
  --ORA-04061: package body "ZLHIS.B_MESSAGE" 的当前状态失效
  v_Code  Zlmsg_Lists.Code%Type;
  n_Using Zlmsg_Lists.Using%Type;
Begin
  v_Code := Code_In;
  --该变动会导致出现较大的负面影响，因此需要判断值是否变化，变化才采取后续处理
  Begin
    Select Nvl(Using, 0) Into n_Using From Zlmsg_Lists Where Code = v_Code;
  Exception
    When No_Data_Found Then
      Return;
  End;
  If n_Using = Nvl(Using_In, 0) Then
    Return;
  End If;
  Update Zlmsg_Lists Set Using = Using_In Where Code = v_Code;
  For Rs In (Select Distinct a.Name
             From User_Source A
             Where a.Type = 'PACKAGE BODY' And a.Name Like 'B_MESSAGE%' And Upper(Text) Like '%' || v_Code || '%') Loop
    Execute Immediate 'ALTER PACKAGE ' || Rs.Name || ' COMPILE SPECIFICATION';
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End;
/

--119856:胡俊勇,2018-01-15,回退自动执行的跟踪在用卫材医嘱
Create Or Replace Procedure Zl_材料收发记录_部门退料
(
  收发id_In   In 药品收发记录.Id%Type,
  审核人_In   In 药品收发记录.审核人%Type,
  审核日期_In In 药品收发记录.审核日期%Type,
  批号_In     In 药品库存.上次批号%Type := Null,
  效期_In     In 药品库存.效期%Type := Null,
  产地_In     In 药品库存.上次产地%Type := Null,
  退料数量_In In 药品收发记录.实际数量%Type := Null,
  自动销帐_In In Integer := 0,
  退料人_In   In 药品收发记录.领用人%Type := Null,
  是否销帐_In In Integer := 1
) Is
  Err_Item Exception;
  v_Err_Msg Varchar2(100);
  v_No      药品收发记录.No%Type;

  n_记录状态   药品收发记录.记录状态%Type;
  n_执行状态   住院费用记录.执行状态%Type;
  n_部分退料   Number;
  n_入出类别id Number(18);
  n_单据       药品收发记录.单据%Type;
  n_库房id     药品收发记录.库房id%Type;
  n_药品id     药品收发记录.药品id%Type;
  n_实际数量   药品收发记录.实际数量%Type;
  n_实际金额   药品收发记录.零售金额%Type;
  n_实际成本   药品收发记录.成本金额%Type;
  n_实际差价   药品收发记录.差价%Type;
  n_费用id     药品收发记录.费用id%Type;
  n_零售价     药品收发记录.零售价%Type;
  n_实价卫材   收费项目目录.是否变价%Type;

  --处理退料时，分批核算性质改变后的处理
  n_新批次       药品收发记录.批次%Type;
  n_批次         药品收发记录.批次%Type;
  n_分批         材料特性.在用分批%Type;
  n_小数         Number(2);
  n_上次供应商id 药品库存.上次供应商id%Type;
  n_成本价       药品收发记录.成本价%Type;
  d_上次生产日期 药品库存.上次生产日期%Type;
  d_灭菌效期     药品库存.灭菌效期%Type;
  v_批准文号     药品库存.批准文号%Type;
  v_产地         药品收发记录.产地%Type;
  v_费用no       住院费用记录.No%Type;
  v_Temp         Varchar2(255);
  v_人员编号     人员表.编号%Type;
  v_人员姓名     人员表.姓名%Type;
  n_主页id       住院费用记录.主页id%Type;
  n_序号         住院费用记录.序号%Type;

  v_备货id     药品收发记录.Id%Type;
  v_入库no     药品收发记录.No%Type;
  v_入库序号   Number(5) := 0;
  n_冲销记录id 药品收发记录.Id%Type;
  n_移库       Number(1) := 0;
  v_商品条码   药品库存.商品条码%Type;
  v_内部条码   药品库存.内部条码%Type;
  v_批号       药品库存.上次批号%Type;
  d_效期       药品库存.效期%Type;
Begin
  v_Temp     := Zl_Identity;
  v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);

  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into n_小数 From Dual;

  If 退料数量_In Is Not Null Then
    If 退料数量_In = 0 Then
      Return;
    End If;
  End If;

  --1、判断当前数据是否是备货卫材
  Begin
    Select 汇总发药号
    Into v_备货id
    From 药品收发记录
    Where 单据 = 21 And 审核日期 Is Not Null And
          汇总发药号 = (Select Max(a.Id)
                   From 药品收发记录 A, 药品收发记录 B
                   Where a.单据 = b.单据 And a.No = b.No And a.序号 = b.序号 And a.审核人 Is Not Null And b.Id = 收发id_In And
                         (Mod(a.记录状态, 3) = 1 Or a.记录状态 = 1)) And Rownum = 1;
  Exception
    When Others Then
      v_备货id := 0;
  End;

  Begin
    If v_备货id = 0 Then
      Select 汇总发药号
      Into v_备货id
      From 药品收发记录
      Where 单据 = 21 And 审核日期 Is Not Null And
            汇总发药号 = (Select Max(a.Id)
                     From 药品收发记录 A, 药品收发记录 B
                     Where a.单据 = b.单据 And a.No = b.No And a.序号 = b.序号 And a.审核人 Is Not Null And b.Id = 收发id_In And
                           (Mod(a.记录状态, 3) = 0)) And Rownum = 1;
    End If;
  Exception
    When Others Then
      v_备货id := 0;
  End;

  --获取该收发记录的单据、药品ID、库房ID
  Select 单据, NO, 库房id, 药品id, 费用id, 入出类别id, 记录状态, Nvl(批次, 0), 生产日期, 灭菌效期, 批准文号, 供药单位id, 成本价, 产地, 零售价, 商品条码, 内部条码, 效期, 批号
  Into n_单据, v_No, n_库房id, n_药品id, n_费用id, n_入出类别id, n_记录状态, n_批次, d_上次生产日期, d_灭菌效期, v_批准文号, n_上次供应商id, n_成本价, v_产地,
       n_零售价, v_商品条码, v_内部条码, d_效期, v_批号
  From 药品收发记录
  Where ID = 收发id_In;

  --获取该笔记录剩余未退数量、金额及差价
  --尽量避免金额及差价未出完的现象
  Select Sum(Nvl(实际数量, 0) * Nvl(付数, 1)), Sum(Nvl(零售金额, 0)), Sum(Nvl(成本金额, 0)), Sum(Nvl(差价, 0))
  Into n_实际数量, n_实际金额, n_实际成本, n_实际差价
  From 药品收发记录
  Where 审核人 Is Not Null And NO = v_No And 单据 = n_单据 And 序号 = (Select 序号 From 药品收发记录 Where ID = 收发id_In);

  --如果允许退药数为零，表示已退药
  If n_实际数量 = 0 Then
    v_Err_Msg := '该单据已被其他操作员退料，请刷新后再试！';
    Raise Err_Item;
  End If;

  If Nvl(退料数量_In, 0) > n_实际数量 Then
    v_Err_Msg := '该单据已被其他操作员部分退料，请刷新后再试！';
    Raise Err_Item;
  End If;

  --获取该材料当前是否分批的信息
  Select Nvl(在用分批, 0) Into n_分批 From 材料特性 Where 材料id = n_药品id;

  --如果是部分退料，则重新计算零售金额及差价
  n_部分退料 := 0;
  If Not (退料数量_In Is Null Or Nvl(退料数量_In, 0) = n_实际数量) Then
    n_部分退料 := 1;
  End If;

  If n_部分退料 = 1 Then
    n_实际金额 := Round(n_实际金额 * 退料数量_In / n_实际数量, n_小数);
    n_实际成本 := Round(n_实际成本 * 退料数量_In / n_实际数量, n_小数);
    n_实际差价 := Round(n_实际差价 * 退料数量_In / n_实际数量, n_小数);
    n_实际数量 := 退料数量_In;
  End If;

  --n_分批:0-不分批;1-分批;2-原分批，现不分批，按不分批处理;3-原不分批，现分批，产生新批次
  If n_分批 = 0 And n_批次 <> 0 Then
    --原分批，现不分批，按不分批处理
    n_分批 := 2;
  Elsif n_分批 <> 0 And n_批次 = 0 Then
    --原不分批,现分批,产生新的批次，并在新产生的发药记录中使用
    n_分批 := 3;
  Else
    If n_批次 = 0 Then
      n_分批 := 0;
    Else
      n_分批 := 1;
    End If;
  End If;

  If 产地_In Is Not Null Then
    v_产地 := 产地_In;
  End If;

  If 批号_In Is Not Null Then
    v_批号 := 批号_In;
  End If;
  If 效期_In Is Not Null Then
    d_效期 := 效期_In;
  End If;

  --记录状态的含义有所变化
  --冲销的记录状态        :iif(n_记录状态=1,0,1)+1
  --被冲销的记录状态        :iif(n_记录状态=1,0,1)+2
  --等待发料的记录状态    :iif(n_记录状态=1,0,1)+3
  Select 药品收发记录_Id.Nextval Into n_冲销记录id From Dual;
  --产生冲销记录
  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 灭菌效期, 付数, 填写数量, 实际数量, 成本价, 成本金额, 扣率, 零售价,
     零售金额, 差价, 摘要, 填制人, 填制日期, 配药人, 审核人, 审核日期, 费用id, 单量, 频次, 用法, 发药窗口, 领用人, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
    Select n_冲销记录id, n_记录状态 + Decode(n_记录状态, 1, 0, 1) + 1, n_单据, v_No, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号,
           效期, 灭菌效期, 1, -n_实际数量, -n_实际数量, 成本价, -n_实际成本, 扣率, 零售价, -n_实际金额, -n_实际差价, 摘要, 审核人_In, 审核日期_In, 配药人, 审核人_In,
           审核日期_In, 费用id, 单量, 频次, 用法, 发药窗口, 退料人_In, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码
    From 药品收发记录
    Where ID = 收发id_In;

  --如果是部分冲销，则付数填为1，实际数量为付数与实际数量的积
  --产生正常记录以供继续发料
  Select 药品收发记录_Id.Nextval Into n_新批次 From Dual;

  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 灭菌效期, 付数, 填写数量, 实际数量, 成本价, 成本金额, 扣率, 零售价,
     零售金额, 差价, 摘要, 填制人, 填制日期, 配药人, 审核人, 审核日期, 费用id, 单量, 频次, 用法, 发药窗口, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
    Select n_新批次, n_记录状态 + Decode(n_记录状态, 1, 0, 1) + 3, n_单据, v_No, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id,
           Decode(n_分批, 1, 批次, 3, n_新批次, Null), Decode(n_分批, 3, 产地_In, 1, 产地, Null), Decode(n_分批, 3, v_批号, 1, 批号, Null),
           Decode(n_分批, 3, d_效期, 1, 效期, Null), 灭菌效期, 1, n_实际数量, n_实际数量, 成本价, n_实际成本, 扣率, 零售价, n_实际金额, n_实际差价, 摘要, 填制人,
           填制日期, Null, Null, Null, 费用id, 单量, 频次, 用法, 发药窗口, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码
    From 药品收发记录
    Where ID = 收发id_In;

  Zl_未审药品记录_Insert(n_新批次);

  --更新病人费用记录的执行状态(0-未执行;1-完全执行;2-部分执行)
  Select Decode(Sum(Nvl(付数, 1) * 实际数量), Null, 0, 0, 0, 2)
  Into n_执行状态
  From 药品收发记录
  Where 单据 = n_单据 And NO = v_No And 费用id = n_费用id And 审核人 Is Not Null;

  If n_执行状态 = 0 Then
    Update 住院费用记录 Set 执行状态 = n_执行状态, 执行人 = Null, 执行时间 = Null Where ID = n_费用id;
    Update 门诊费用记录
    Set 执行状态 = n_执行状态, 执行人 = Null, 执行时间 = Null
    Where NO = v_No And
          序号 = (Select 序号 From 门诊费用记录 Where ID = (Select 费用id From 药品收发记录 Where ID = 收发id_In)) And
          (Mod(记录性质, 10) = 1 Or Mod(记录性质, 10) = 2) And 记录状态 <> 2 And 执行部门id = n_库房id;
  Else
    Update 住院费用记录 Set 执行状态 = n_执行状态 Where ID = n_费用id;
    Update 门诊费用记录
    Set 执行状态 = n_执行状态
    Where NO = v_No And
          序号 = (Select 序号 From 门诊费用记录 Where ID = (Select 费用id From 药品收发记录 Where ID = 收发id_In)) And
          (Mod(记录性质, 10) = 1 Or Mod(记录性质, 10) = 2) And 记录状态 <> 2 And 执行部门id = n_库房id;
  End If;

  --插入未发药品记录
  Begin
    Insert Into 未发药品记录
      (单据, NO, 病人id, 主页id, 姓名, 优先级, 对方部门id, 库房id, 发药窗口, 填制日期, 已收费, 配药人, 打印状态, 未发数)
      Select a.单据, a.No, a.病人id, a.主页id, a.姓名, Nvl(b.优先级, 0) 优先级, a.对方部门id, a.库房id, a.发药窗口, a.填制日期, a.已收费, Null, 1, 1
      From (Select b.单据, b.No, a.病人id, a.主页id, a.姓名, Decode(a.记录性质, 1, Decode(a.操作员姓名, Null, 0, 1), 1) 已收费, b.对方部门id,
                    b.库房id, b.发药窗口, b.填制日期, c.身份
             From 住院费用记录 A, 药品收发记录 B, 病人信息 C
             Where b.Id = 收发id_In And a.Id = b.费用id + 0 And a.病人id = c.病人id(+)
             Union All
             Select b.单据, b.No, a.病人id, Null As 主页id, a.姓名, Decode(a.记录性质, 1, Decode(a.操作员姓名, Null, 0, 1), 1) 已收费,
                    b.对方部门id, b.库房id, b.发药窗口, b.填制日期, c.身份
             From 门诊费用记录 A, 药品收发记录 B, 病人信息 C
             Where b.Id = 收发id_In And a.Id = b.费用id + 0 And a.病人id = c.病人id(+)) A, 身份 B
      Where b.名称(+) = a.身份;
  Exception
    When Others Then
      Null;
  End;

  --修改原记录为被冲销记录
  Update 药品收发记录 Set 记录状态 = n_记录状态 + Decode(n_记录状态, 1, 0, 1) + 2 Where ID = 收发id_In;

  --修改药品库存(反冲库存)
  Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = n_药品id;

  If n_分批 <> 3 Then
  
    Update 药品库存
    Set 实际数量 = Nvl(实际数量, 0) + n_实际数量, 实际金额 = Nvl(实际金额, 0) + n_实际金额, 实际差价 = Nvl(实际差价, 0) + n_实际差价,
        零售价 = Decode(n_实价卫材, 1, Decode(Nvl(n_批次, 0), 0, Null, Decode(Nvl(零售价, 0), 0, n_零售价, 零售价)), Null)
    Where 库房id + 0 = n_库房id And 药品id = n_药品id And 性质 = 1 And Nvl(批次, 0) = n_批次;
  
    If Sql%RowCount = 0 Then
      Insert Into 药品库存
        (库房id, 药品id, 批次, 性质, 实际数量, 实际金额, 实际差价, 效期, 灭菌效期, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 批准文号, 零售价, 平均成本价, 商品条码,
         内部条码)
      Values
        (n_库房id, n_药品id, Decode(n_分批, 2, Null, n_批次), 1, n_实际数量, n_实际金额, n_实际差价, Decode(n_分批, 1, d_效期, Null), d_灭菌效期,
         n_上次供应商id, n_成本价, Decode(n_分批, 1, v_批号, Null), d_上次生产日期, v_产地, v_批准文号,
         Decode(n_实价卫材, 1, Decode(Nvl(n_批次, 0), 0, Null, n_零售价), Null), n_成本价, v_商品条码, v_内部条码);
    End If;
  Else
    Insert Into 药品库存
      (库房id, 药品id, 批次, 性质, 实际数量, 实际金额, 实际差价, 效期, 灭菌效期, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 批准文号, 零售价, 平均成本价, 商品条码, 内部条码)
    Values
      (n_库房id, n_药品id, n_新批次, 1, n_实际数量, n_实际金额, n_实际差价, d_效期, d_灭菌效期, n_上次供应商id, n_成本价, v_批号, d_上次生产日期, v_产地, v_批准文号,
       Decode(n_实价卫材, 1, Decode(Nvl(n_新批次, 0), 0, Null, n_零售价), Null), n_成本价, v_商品条码, v_内部条码);
  End If;

  Delete 药品库存
  Where 库房id + 0 = n_库房id And 药品id = n_药品id And 性质 = 1 And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
        Nvl(实际差价, 0) = 0;

  If (自动销帐_In = 1 And n_单据 <> 24) Or (v_备货id > 1 And n_单据 <> 24 And Not (退料数量_In Is Null) And 是否销帐_In = 1) Then
    Begin
      Select 主页id, NO, 序号 Into n_主页id, v_费用no, n_序号 From 住院费用记录 Where ID = n_费用id;
    Exception
      When Others Then
        Begin
          Select Null, NO, 序号 Into n_主页id, v_费用no, n_序号 From 门诊费用记录 Where ID = n_费用id;
        Exception
          When Others Then
            n_主页id := Null;
        End;
    End;
    If n_主页id Is Null Then
      Zl_门诊记帐记录_Delete(v_费用no, n_序号, v_人员编号, v_人员姓名);
    Else
      Zl_住院记帐记录_Delete(v_费用no, n_序号, v_人员编号, v_人员姓名);
    End If;
  End If;

  If Not (退料数量_In Is Null) Then
    --备货卫材处理
    If v_备货id > 0 Then
      --2、自动冲销已审核的其他出库单据
      Begin
        Select 1
        Into n_移库
        From 药品收发记录
        Where 单据 = 15 And 审核日期 Is Null And
              费用id In (Select Distinct 费用id From 药品收发记录 Where NO = v_No And 药品id = n_药品id And 批次 = n_批次);
      Exception
        When Others Then
          n_移库 := 0;
      End;
    
      If n_移库 <> 0 Then
        For v_出库冲销 In (Select 1 行次, 记录状态, NO, 序号, 药品id
                       From 药品收发记录
                       Where 单据 = 21 And 审核日期 Is Not Null And 汇总发药号 = v_备货id) Loop
          Zl_材料其他出库_Strike(v_出库冲销.行次, v_出库冲销.记录状态, v_出库冲销.No, v_出库冲销.序号, v_出库冲销.药品id, 退料数量_In, 审核人_In, 审核日期_In);
        End Loop;
      
        --3、删除未审核的外购入库单据（已审核则不管）
        If n_部分退料 = 1 Then
          Update 药品收发记录
          Set 填写数量 = 填写数量 - 退料数量_In, 实际数量 = 实际数量 - 退料数量_In, 零售金额 = 零售金额 - n_实际金额, 成本金额 = 成本金额 - n_实际成本, 差价 = 差价 - n_实际差价
          Where 单据 = 15 And 药品id = n_药品id And Nvl(批次, 0) = n_批次 And 费用id = n_费用id And 审核日期 Is Null;
        Else
          Delete 药品收发记录
          Where 单据 = 15 And 药品id = n_药品id And Nvl(批次, 0) = n_批次 And 费用id = n_费用id And 审核日期 Is Null;
        End If;
      End If;
    End If;
  Else
    --备货卫材处理
    If v_备货id > 0 Then
      --2、自动冲销已审核的其他出库单据
      Begin
        Select 1
        Into n_移库
        From 药品收发记录
        Where 单据 = 15 And 审核日期 Is Null And
              费用id In (Select Distinct 费用id From 药品收发记录 Where NO = v_No And 药品id = n_药品id And 批次 = n_批次);
      Exception
        When Others Then
          n_移库 := 0;
      End;
    
      If n_移库 <> 0 Then
        For v_出库冲销 In (Select 1 行次, 记录状态, NO, 序号, 药品id
                       From 药品收发记录
                       Where 单据 = 21 And 审核日期 Is Not Null And 汇总发药号 = v_备货id) Loop
          Zl_材料其他出库_Strike(v_出库冲销.行次, v_出库冲销.记录状态, v_出库冲销.No, v_出库冲销.序号, v_出库冲销.药品id, 退料数量_In, 审核人_In, 审核日期_In, 1);
        End Loop;
      
        --3、产生新的其他出库单据
        If v_入库no Is Null Then
          v_入库no := Nextno(74, n_库房id);
        End If;
        v_入库序号 := v_入库序号 + 1;
      
        For v_入库 In (Select 入出类别id, 库房id, 药品id, 批次, 填写数量, 成本价, 成本金额, 零售价, 零售金额, 差价, 产地, 批号, 效期, 灭菌效期, 摘要, 单量, 发药窗口
                     From 药品收发记录
                     Where 单据 = 21 And 审核日期 Is Not Null And 汇总发药号 = v_备货id) Loop
        
          Zl_材料其他出库_Insert(v_入库.入出类别id, v_入库no, v_入库序号, v_入库.库房id, v_入库.药品id, v_入库.批次, v_入库.填写数量, v_入库.成本价, v_入库.成本金额,
                           v_入库.零售价, v_入库.零售金额, v_入库.差价, 审核人_In, 审核日期_In, v_入库.产地, v_入库.批号, v_入库.效期, v_入库.灭菌效期, v_入库.摘要,
                           v_入库.单量, v_入库.发药窗口);
        
          Update 药品收发记录
          Set 费用id = n_费用id, 汇总发药号 = n_新批次
          Where 单据 = 21 And NO = v_入库no And 序号 = v_入库序号;
        End Loop;
      
        --4、删除未审核的外购入库单据（已审核则不管）
        Delete 药品收发记录
        Where 单据 = 15 And 药品id = n_药品id And Nvl(批次, 0) = n_批次 And 费用id = n_费用id And 审核日期 Is Null;
      End If;
    End If;
  End If;
  --处理调价修正单据
  Zl_材料收发记录_调价修正(n_冲销记录id);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料收发记录_部门退料;
/

--118584:刘兴洪,2018-01-22,增加免挂号模式
--119108:刘兴洪,2018-01-15,并发锁号问题
Create Or Replace Procedure Zl_挂号安排_临床出诊_Lockno
(
  操作类型_In   Integer,
  记录id_In     临床出诊记录.Id%Type,
  日期_In       临床出诊序号控制.开始时间%Type,
  序号_In       临床出诊序号控制.序号%Type,
  序号_Out      Out 临床出诊序号控制.序号%Type,
  是否预约_In   Number := 0,
  备注_In       临床出诊序号控制.备注%Type := Null,
  机器名_In     临床出诊序号控制.工作站名称%Type := Null,
  操作员姓名_In 临床出诊序号控制.操作员姓名%Type := Null,
  启用日期_In   Date := Null,
  合作单位_In   Varchar2 := Null,
  时间段_In     Varchar2 := Null,
  号码_In       临床出诊号源.号码%Type := Null
) Is

  --功能:临床出诊模式的锁号操作
  --操作类型_In： 0-解锁,1-加锁（根据传入的日期来加锁，没找到取一个）;2-加锁(直接取一下有效号进行加锁)
  --启用日期_In:启用日期为空时，必须传入记录ID_IN;
  --时间段_In:可以不传入，不传入时，则直接取下一个有效号 格式:HH24:mi:ss-HH24:mi:ss

  n_挂号状态   临床出诊序号控制.挂号状态%Type;
  n_序号       临床出诊序号控制.序号%Type;
  v_验证姓名   临床出诊序号控制.操作员姓名%Type;
  v_验证机器名 临床出诊序号控制.工作站名称%Type;

  v_操作员姓名 临床出诊序号控制.操作员姓名%Type;
  v_机器名     临床出诊序号控制.工作站名称%Type;

  n_数量         临床出诊序号控制.数量%Type;
  n_顺序号       临床出诊序号控制.预约顺序号%Type;
  n_合约模式     Number(3);
  n_序号控制     Number(3);
  n_分时段       Number(3);
  n_存在         Number(18);
  n_启用合作单位 Number(3);
  n_是否挂号     Number(3); --1-挂号;0-预约
  n_自锁号       Number(3);
  d_时段开始     Date;
  d_时段结束     Date;
  n_Rowid        Rowid;
  n_记录id       临床出诊记录.Id%Type;
  v_Temp         Varchar2(32767); --临时XML
  Err_Item Exception;

  Function Get_Next_Sn
  (
    记录id1_In     临床出诊记录.Id%Type,
    日期1_In       Date,
    机器名1_In     临床出诊序号控制.工作站名称%Type,
    操作员姓名1_In 临床出诊序号控制.操作员姓名%Type
  ) Return Number Is
    n_Temp   Number(18);
    n_限约数 临床出诊记录.限约数%Type;
    n_限号数 临床出诊记录.限号数%Type;
    v_号码   临床出诊号源.号码%Type;
  Begin
    Select Min(序号)
    Into n_Temp
    From 临床出诊序号控制
    Where 记录id = 记录id1_In And 开始时间 >= 日期1_In And
          (Nvl(挂号状态, 0) = 0 Or
          (Nvl(挂号状态, 0) = 5 And Nvl(工作站名称, 机器名1_In) = 机器名1_In And Nvl(操作员姓名, 操作员姓名1_In) = 操作员姓名1_In)) And
          Nvl(是否停诊, 0) <> 1;
  
    If Nvl(n_Temp, 0) = 0 Then
      --检查总体数量: --0-待挂或待预约的号;1-已挂,2-已经预约,3-预留号,4-已经退号;5-已经锁号;不启用序号控制且分时段的且预约顺序号为NULL的，则为0
      Select Nvl(限约数, 0) - Nvl(已约数, 0), Nvl(限号数, 0) - Nvl(已挂数, 0)
      Into n_限约数, n_限号数
      From 临床出诊记录
      Where ID = 记录id1_In;
    
      Select Sum(数量)
      Into n_数量
      From 临床出诊序号控制
      Where 记录id = 记录id1_In And (Nvl(挂号状态, 0) In (1, 2, 5) Or
            (挂号状态 In (3, 5) And Nvl(工作站名称, '-') <> 机器名1_In And Nvl(操作员姓名, '-') <> 操作员姓名1_In));
    
      If Trunc(Sysdate) = Trunc(日期1_In) Then
        If n_限号数 - n_数量 <= 0 Then
          Select Max(b.号码)
          Into v_号码
          From 临床出诊记录 A, 临床出诊号源 B
          Where a.号源id = b.Id And a.Id = 记录id1_In;
        
          v_Temp := '传入号别' || Nvl(v_号码, '-') || '当前已无余号';
          Raise Err_Item;
        End If;
      Else
        If n_限约数 - n_数量 <= 0 Then
          v_Temp := '传入号别' || Nvl(v_号码, '-') || '当前已无余号';
          Raise Err_Item;
        End If;
      End If;
    
      Select Max(序号) + 1 Into n_Temp From 临床出诊序号控制 Where 记录id = 记录id1_In;
    End If;
    Return n_Temp;
  End;

  Function Save_Lockdata
  (
    记录id1_In     临床出诊记录.Id%Type,
    序号1_In       临床出诊序号控制.序号%Type,
    机器名1_In     临床出诊序号控制.工作站名称%Type,
    操作员姓名1_In 临床出诊序号控制.操作员姓名%Type,
    备注1_In       临床出诊序号控制.备注%Type := Null,
    预约顺序号1_In 临床出诊序号控制.预约顺序号%Type := Null
  ) Return Number Is
    n_Temp_序号 Number(18);
    n_自锁号    Number(2);
    n_Rowid     Rowid;
  Begin
    n_Temp_序号 := 序号1_In;
  
    --0-待挂或待预约的号;1-已挂,2-已经预约,3-预留号,4-已经退号;5-已经锁号;不启用序号控制且分时段的且预约顺序号为NULL的，则为0
    Begin
      Select Rowid, 1,
             Case
               When (Nvl(工作站名称, 机器名1_In) = 机器名1_In And Nvl(操作员姓名, 操作员姓名1_In) = 操作员姓名1_In And
                    Instr(',0,5,', ',' || Nvl(挂号状态, 0) || ',') > 0) Or Nvl(挂号状态, 0) = 0 Then
                1
               Else
                0
             End
      Into n_Rowid, n_存在, n_自锁号
      From 临床出诊序号控制
      Where 记录id = 记录id1_In And 序号 = n_Temp_序号;
    Exception
      When Others Then
        n_存在   := 0;
        n_自锁号 := 0;
    End;
    If Nvl(n_存在, 0) = 1 And Nvl(n_自锁号, 0) = 0 Then
    
      v_Temp := '序号为' || n_Temp_序号 || '的序号已被使用。';
      Raise Err_Item;
    End If;
  
    Update 临床出诊序号控制
    Set 挂号状态 = 5, 锁号时间 = Sysdate, 操作员姓名 = 操作员姓名1_In, 工作站名称 = 机器名1_In, 备注 = 备注1_In
    Where 记录id = 记录id1_In And 序号 = n_Temp_序号 And Decode(预约顺序号1_In, Null, 0, 预约顺序号) = Nvl(预约顺序号1_In, 0);
  
    If Sql%Rowcount = 0 Then
      Insert Into 临床出诊序号控制
        (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 锁号时间, 名称, 类型, 操作员姓名, 工作站名称, 预约顺序号, 备注)
        Select 记录id, n_Temp_序号,
               To_Date(To_Char(开始时间, 'yyyy-mm-dd') || ' ' || To_Char(日期_In, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'),
               To_Date(To_Char(开始时间, 'yyyy-mm-dd') || ' ' || To_Char(日期_In, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'), 1,
               是否预约, 5, Sysdate, 合作单位_In, 1, 操作员姓名1_In, 机器名1_In, 预约顺序号1_In, 备注1_In
        From 临床出诊序号控制
        Where 记录id = 记录id1_In And Rownum < 2;
    End If;
  
    Return n_Temp_序号;
  End;

Begin
  n_记录id := 记录id_In;
  n_序号   := 序号_In;

  v_机器名 := 机器名_In;
  If v_机器名 Is Null Then
    Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
  End If;
  v_操作员姓名 := 操作员姓名_In;
  If v_操作员姓名 Is Null Then
    v_操作员姓名 := Zl_Username;
  End If;

  If Nvl(n_记录id, 0) = 0 Then
  
    --新排班模式检查:启用30天内的，如果不传入记录ID,则自动取记录ID,启用30后，必须要传入的记录ID(此规则LEX当时定的，现更改取消30的限制，无什么意义)
    If Sysdate - 10 > Nvl(启用日期_In, Sysdate) Then
      If Nvl(日期_In, Sysdate) > Nvl(启用日期_In, Sysdate) Then
        v_Temp := '系统当前处于出诊表排班模式，传入的参数无法确定挂号安排，请重试！';
        Raise Err_Item;
      End If;
    Else
      If Nvl(日期_In, Sysdate) > Nvl(启用日期_In, Sysdate) Then
        Begin
          Select a.Id
          Into n_记录id
          From 临床出诊记录 A, 临床出诊号源 B
          Where a.号源id = b.Id And b.号码 = 号码_In And Nvl(日期_In, Sysdate) Between a.开始时间 And a.终止时间;
        Exception
          When Others Then
            v_Temp := '系统当前处于出诊表排班模式，传入的参数无法确定挂号安排，请重试！';
            Raise Err_Item;
        End;
      End If;
    End If;
  End If;

  n_是否挂号 := Case
              When Nvl(是否预约_In, 0) = 0 Then
               1
              Else
               0
            End;

  If 操作类型_In = 0 Then
    --解锁
    Update 临床出诊序号控制
    Set 挂号状态 = 0, 操作员姓名 = Null, 工作站名称 = Null, 备注 = Null
    Where 工作站名称 = v_机器名 And 操作员姓名 = v_操作员姓名 And 挂号状态 = 5 And (序号 = n_序号 Or 备注 = n_序号) And 记录id = n_记录id;
    If Sql%NotFound Then
      v_Temp := '没有发现需要解锁的序号';
      Raise Err_Item;
    End If;
    序号_Out := n_序号;
    Return;
  End If;

  If 时间段_In Is Not Null Then
    Begin
      d_时段开始 := To_Date(To_Char(日期_In, 'yyyy-mm-dd') || Substr(时间段_In, 1, Instr(时间段_In, '-') - 1),
                        'yyyy-mm-dd hh24:mi:ss');
      If Substr(时间段_In, Instr(时间段_In, '-') + 1) Is Null Then
        d_时段结束 := Null;
      Else
        d_时段结束 := To_Date(To_Char(日期_In, 'yyyy-mm-dd') || Substr(时间段_In, Instr(时间段_In, '-') + 1),
                          'yyyy-mm-dd hh24:mi:ss');
      End If;
    Exception
      When Others Then
        v_Temp := '无法解析传入的时间段格式，请检查！';
        Raise Err_Item;
    End;
  End If;

  Select Nvl(Max(1), 0)
  Into n_存在
  From 临床出诊记录
  Where ID = n_记录id And 日期_In Between 开始时间 And 终止时间 And Rownum < 2;
  If Nvl(n_存在, 0) = 0 Then
    v_Temp := '传入的时间' || To_Char(日期_In, 'yyyy-mm-dd hh24:mi:ss') || '不存出诊范围内,请检查!';
    Raise Err_Item;
  End If;

  If n_序号 Is Null Then
  
    Select Max(是否序号控制), Max(是否分时段) Into n_序号控制, n_分时段 From 临床出诊记录 Where ID = n_记录id;
  
    Select Nvl(Max(1), 0)
    Into n_启用合作单位
    From 临床出诊挂号控制记录
    Where 记录id = n_记录id And 名称 = 合作单位_In And 类型 = 1 And 性质 = 1 And Rownum < 2;
  
    If Nvl(n_序号控制, 0) = 0 Then
      --不启用序号控制的，直接返回
      Return;
    End If;
  
    If n_分时段 = 1 Then
      n_存在 := 0;
      If 时间段_In Is Null Then
      
        Update 临床出诊序号控制
        Set 备注 = 备注
        Where 记录id = n_记录id And 开始时间 <> 终止时间 And To_Char(开始时间, 'hh24:mi') = To_Char(日期_In, 'hh24:mi') And Rownum < 2;
      
        Begin
          Select 1, 挂号状态, 操作员姓名, 工作站名称, 序号
          Into n_存在, n_挂号状态, v_验证姓名, v_验证机器名, n_序号
          From 临床出诊序号控制
          Where 记录id = n_记录id And 开始时间 <> 终止时间 And To_Char(开始时间, 'hh24:mi') = To_Char(日期_In, 'hh24:mi') And
                Nvl(挂号状态, 0) <> 0 And Rownum < 2;
        Exception
          When Others Then
            n_存在 := 0;
        End;
      End If;
    
      If n_存在 = 1 Then
        If Not (n_挂号状态 = 5 And v_验证姓名 = v_操作员姓名 And v_机器名 = v_验证机器名) Then
          --传入时间的序号已经被使用
          v_Temp := '传入时间' || To_Char(日期_In, 'hh24:mi') || '的序号已被使用';
          Raise Err_Item;
        End If;
        序号_Out := n_序号;
        Return;
      End If;
    
      If 时间段_In Is Null Then
        Begin
          n_存在 := 1;
          Select 序号
          Into n_序号
          From 临床出诊序号控制
          Where 记录id = n_记录id And 开始时间 <> 终止时间 And To_Char(开始时间, 'hh24:mi') = To_Char(日期_In, 'hh24:mi') And
                Nvl(挂号状态, 0) = 0 And Nvl(是否停诊, 0) <> 1 And Rownum < 2;
        Exception
          When Others Then
            n_存在 := 0;
        End;
      
        If Nvl(n_存在, 0) = 0 Then
          If n_是否挂号 = 0 Then
            v_Temp := '传入时间' || 日期_In || '没有找到对应的序号,无法预约';
            Raise Err_Item;
          End If;
        
          Select Min(序号)
          Into n_序号
          From 临床出诊序号控制
          Where 记录id = n_记录id And 开始时间 >= 日期_In And Nvl(挂号状态, 0) = 0 And Nvl(是否停诊, 0) <> 1;
        
          If Nvl(n_序号, 0) = 0 Then
            Select Max(序号) + 1 Into n_序号 From 临床出诊序号控制 Where 记录id = n_记录id;
          End If;
        
        End If;
      
        n_序号   := Save_Lockdata(记录id_In, n_序号, v_机器名, v_操作员姓名, 备注_In, Null);
        序号_Out := n_序号;
        Return;
      End If;
    
      --未传时间段 
      Select Min(序号), Min(挂号状态)
      Into n_序号, n_挂号状态
      From 临床出诊序号控制
      Where 记录id = n_记录id And 开始时间 <> 终止时间 And To_Char(开始时间, 'hh24:mi') >= To_Char(d_时段开始, 'hh24:mi') And
            (Nvl(挂号状态, 0) = 0 Or Nvl(挂号状态, 0) = 5) And Nvl(是否停诊, 0) <> 1 And
            To_Char(开始时间, 'hh24:mi') < To_Char(d_时段结束, 'hh24:mi') And Decode(n_是否挂号, 1, 1, 是否预约) = 1 And Rownum < 2;
    
      If Nvl(n_序号, 0) = 0 Then
        If d_时段结束 Is Not Null Then
          v_Temp := '传入时间段' || 时间段_In || '序号已被使用完,无法预约';
          Raise Err_Item;
        End If;
        If Trunc(日期_In) <> Trunc(Sysdate) Then
          v_Temp := '传入时间' || 日期_In || '没有找到对应的序号,无法预约';
          Raise Err_Item;
        End If;
      
        Select Min(序号)
        Into n_序号
        From 临床出诊序号控制
        Where 记录id = n_记录id And 开始时间 >= 日期_In And Nvl(挂号状态, 0) = 0 And Nvl(是否停诊, 0) <> 1;
        If Nvl(n_序号, 0) = 0 Then
          Select Max(序号) + 1 Into n_序号 From 临床出诊序号控制 Where 记录id = n_记录id;
        End If;
      Else
        If Nvl(n_挂号状态, 0) = 5 Then
          Select Nvl(Max(1), 0)
          Into n_存在
          From 临床出诊序号控制
          Where 记录id = n_记录id And 操作员姓名 = v_操作员姓名 And 工作站名称 = v_机器名 And 序号 = n_序号;
          If n_存在 = 1 Then
            序号_Out := n_序号;
            Return;
          End If;
        Else
          --0-待挂或待预约的号;1-已挂,2-已经预约,3-预留号,4-已经退号;5-已经锁号;不启用序号控制且分时段的且预约顺序号为NULL的，则为0
          If Nvl(n_挂号状态, 0) <> 0 Then
            If d_时段结束 Is Not Null Then
              v_Temp := '传入时间段' || 时间段_In || '序号已被使用完,无法预约';
              Raise Err_Item;
            End If;
            If Trunc(日期_In) <> Trunc(Sysdate) Then
              v_Temp := '传入时间' || 日期_In || '没有找到对应的序号,无法预约';
              Raise Err_Item;
            End If;
          
            n_序号 := Get_Next_Sn(n_记录id, 日期_In, v_机器名, v_操作员姓名);
          End If;
        End If;
      End If;
      n_序号   := Save_Lockdata(记录id_In, n_序号, v_机器名, v_操作员姓名, 备注_In, Null);
      序号_Out := n_序号;
      Return;
    End If;
    --不分时段 
    If 合作单位_In Is Null Or n_启用合作单位 = 0 Then
      --非合作单位
      n_序号 := Get_Next_Sn(n_记录id, trunc(日期_In), v_机器名, v_操作员姓名);
    
      n_序号   := Save_Lockdata(记录id_In, n_序号, v_机器名, v_操作员姓名, 备注_In, Null);
      序号_Out := n_序号;
      Return;
    End If;
    --合作单位
    --控制方式:0-禁止预约;1-按比例控制预约;2-按总量控制预约;3-按序号控制预约;4-不作限制
    Begin
      Select 控制方式
      Into n_合约模式
      From 临床出诊挂号控制记录
      Where 记录id = n_记录id And 类型 = 1 And 性质 = 1 And 名称 = 合作单位_In And Rownum < 2;
    Exception
      When Others Then
        n_合约模式 := 4;
    End;
    If n_合约模式 = 0 Then
      v_Temp := '本号别禁止该合作单位预约!';
      Raise Err_Item;
    End If;
  
    If n_合约模式 = 1 Or n_合约模式 = 2 Or n_合约模式 = 4 Then
      n_序号 := Get_Next_Sn(n_记录id, 日期_In, v_机器名, v_操作员姓名);
    End If;
  
    If n_合约模式 = 3 Then
      Select Min(a.序号)
      Into n_序号
      From 临床出诊序号控制 A, 临床出诊挂号控制记录 B
      Where a.记录id = n_记录id And a.记录id = b.记录id And b.类型 = 1 And b.性质 = 1 And b.名称 = 合作单位_In And a.序号 = b.序号 And
            Nvl(a.挂号状态, 0) = 0 And Nvl(是否停诊, 0) <> 1;
    
      If n_序号 = 0 Then
        v_Temp := '本号别合作单位可预约序号已经全部使用完!';
        Raise Err_Item;
      End If;
    End If;
    n_序号   := Save_Lockdata(记录id_In, n_序号, v_机器名, v_操作员姓名, 备注_In, Null);
    序号_Out := n_序号;
    Return;
  
  End If;

  --非序号控制:n_序号  is not null 
  If n_分时段 = 1 Then
    If 合作单位_In Is Null Or n_启用合作单位 = 0 Then
      Begin
        If 时间段_In Is Null Then
          Select 序号, 数量
          Into n_序号, n_数量
          From 临床出诊序号控制
          Where 记录id = n_记录id And 预约顺序号 Is Null And 开始时间 = 日期_In;
        Else
          Select Min(序号)
          Into n_序号
          From 临床出诊序号控制 A
          Where a.记录id = n_记录id And a.预约顺序号 Is Null And a.开始时间 >= d_时段开始 And a.开始时间 < d_时段结束 And
                数量 > (Select Count(1)
                      From 临床出诊序号控制
                      Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = a.序号 And Nvl(挂号状态, 0) <> 0);
          If Nvl(n_序号, 0) = 0 Then
            v_Temp := '本号别可用序号已经全部使用完!';
            Raise Err_Item;
          End If;
          Select 数量
          Into n_数量
          From 临床出诊序号控制
          Where 记录id = n_记录id And 预约顺序号 Is Null And 序号 = n_序号;
        End If;
        Select Count(1)
        Into n_存在
        From 临床出诊序号控制
        Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = n_序号 And Nvl(挂号状态, 0) <> 0;
      
        If Nvl(n_存在, 0) >= n_数量 Then
          v_Temp := '本号别可用序号已经全部使用完!';
          Raise Err_Item;
        End If;
        Select Min(预约顺序号)
        Into n_顺序号
        From 临床出诊序号控制
        Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = n_序号 And Nvl(挂号状态, 0) = 0 And Nvl(是否停诊, 0) <> 1;
        If n_顺序号 = 0 Then
          Select Max(预约顺序号) + 1
          Into n_顺序号
          From 临床出诊序号控制
          Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = n_序号;
        End If;
        n_序号   := Save_Lockdata(记录id_In, n_序号, v_机器名, v_操作员姓名, 备注_In, n_顺序号);
        序号_Out := n_序号;
        Return;
      Exception
        When Others Then
          Null;
      End;
    Else
      --合作单位
    
      Begin
        Select 控制方式
        Into n_合约模式
        From 临床出诊挂号控制记录
        Where 记录id = n_记录id And 类型 = 1 And 性质 = 1 And 名称 = 合作单位_In And Rownum < 2;
      Exception
        When Others Then
          n_合约模式 := 4;
      End;
      If n_合约模式 = 0 Then
        v_Temp := '本号别禁止该合作单位预约!';
        Raise Err_Item;
      End If;
      If n_合约模式 = 1 Or n_合约模式 = 2 Or n_合约模式 = 4 Then
        Begin
          If 时间段_In Is Null Then
            Select 序号, 数量
            Into n_序号, n_数量
            From 临床出诊序号控制
            Where 记录id = n_记录id And 预约顺序号 Is Null And 开始时间 = 日期_In;
          Else
            Select Min(序号)
            Into n_序号
            From 临床出诊序号控制 A
            Where a.记录id = n_记录id And a.预约顺序号 Is Null And a.开始时间 >= d_时段开始 And a.开始时间 < d_时段结束 And
                  数量 > (Select Count(1)
                        From 临床出诊序号控制
                        Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = a.序号 And Nvl(挂号状态, 0) <> 0);
            If Nvl(n_序号, 0) = 0 Then
              v_Temp := '本号别可用序号已经全部使用完!';
              Raise Err_Item;
            End If;
            Select 数量
            Into n_数量
            From 临床出诊序号控制
            Where 记录id = n_记录id And 预约顺序号 Is Null And 序号 = n_序号;
          End If;
          Select Count(1)
          Into n_存在
          From 临床出诊序号控制
          Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = n_序号 And Nvl(挂号状态, 0) <> 0;
          If Nvl(n_存在, 0) >= n_数量 Then
            v_Temp := '本号别可用序号已经全部使用完!';
            Raise Err_Item;
          End If;
        
          Select Min(预约顺序号)
          Into n_顺序号
          From 临床出诊序号控制
          Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = n_序号 And Nvl(挂号状态, 0) = 0 And Nvl(是否停诊, 0) <> 1;
          If n_顺序号 = 0 Then
            Select Max(预约顺序号) + 1
            Into n_顺序号
            From 临床出诊序号控制
            Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = n_序号;
          End If;
        
          n_序号 := Save_Lockdata(记录id_In, n_序号, v_机器名, v_操作员姓名, 备注_In, n_顺序号);
        
          序号_Out := n_序号;
          Return;
        Exception
          When Others Then
            Null;
        End;
      End If;
      If n_合约模式 = 3 Then
        Begin
          If 时间段_In Is Null Then
            Select 序号
            Into n_序号
            From 临床出诊序号控制
            Where 记录id = n_记录id And 预约顺序号 Is Null And 开始时间 = 日期_In;
            Select 数量
            Into n_数量
            From 临床出诊挂号控制记录
            Where 记录id = n_记录id And 类型 = 1 And 性质 = 1 And 名称 = 合作单位_In And 序号 = n_序号;
          Else
            Select Min(序号)
            Into n_序号
            From 临床出诊序号控制 A
            Where a.记录id = n_记录id And a.预约顺序号 Is Null And a.开始时间 >= d_时段开始 And a.开始时间 < d_时段结束 And
                  数量 > (Select Count(1)
                        From 临床出诊序号控制
                        Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = a.序号 And Nvl(挂号状态, 0) <> 0);
            If Nvl(n_序号, 0) = 0 Then
              v_Temp := '本号别可用序号已经全部使用完!';
              Raise Err_Item;
            End If;
            Select 数量
            Into n_数量
            From 临床出诊序号控制
            Where 记录id = n_记录id And 预约顺序号 Is Null And 序号 = n_序号;
          End If;
        
          Select Count(1)
          Into n_存在
          From 临床出诊序号控制
          Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = n_序号 And Nvl(挂号状态, 0) <> 0;
          If Nvl(n_存在, 0) >= n_数量 Then
            v_Temp := '本号别可用序号已经全部使用完!';
            Raise Err_Item;
          End If;
        
          Select Min(预约顺序号)
          Into n_顺序号
          From 临床出诊序号控制
          Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = n_序号 And Nvl(挂号状态, 0) = 0 And Nvl(是否停诊, 0) <> 1;
          If n_顺序号 = 0 Then
            Select Max(预约顺序号) + 1
            Into n_顺序号
            From 临床出诊序号控制
            Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = n_序号;
          End If;
          n_序号 := Save_Lockdata(记录id_In, n_序号, v_机器名, v_操作员姓名, 备注_In, n_顺序号);
        
          序号_Out := n_序号;
          Return;
        Exception
          When Others Then
            Null;
        End;
      End If;
    End If;
  Else
    --未分时段 
    Null;
  End If;

Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Temp || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_挂号安排_临床出诊_Lockno;
/

--120885:刘兴洪,2018-02-05,增加显示序号
--118584:刘兴洪,2018-01-22,增加免挂号模式
--119108:刘兴洪,2018-01-15,并发锁号问题
Create Or Replace Procedure Zl_挂号安排_传统_Lockno
(
  操作类型_In   Integer,
  号码_In       挂号安排.号码%Type,
  日期_In       挂号序号状态.日期%Type,
  号序_In       挂号序号状态.序号%Type,
  序号_Out      Out 挂号序号状态.序号%Type,
  机器名_In     挂号序号状态.机器名%Type := Null,
  操作员姓名_In 挂号序号状态.操作员姓名%Type := Null,
  安排id_In     挂号安排.Id%Type := Null,
  计划id_In     挂号安排计划.Id%Type := Null,
  是否预约_In   Number := 0,
  备注_In       挂号序号状态.备注%Type := Null,
  合作单位_In   Varchar2 := Null,
  时间段_In     Varchar2 := Null
  
) Is
  --功能:传统模式的锁号操作
  --操作类型_In： 0-解锁,1-加锁（根据传入的日期来加锁，没找到取一个）;2-加锁(直接取一下有效号进行加锁)
  --安排ID_In:如果不为空，则直接从安排中取数
  --计划ID_In:如果不为空，则直接从计划中取数
  --时间段_In:可以不传入，不传入时，则直接取下一个有效号 格式:HH24:mi:ss-HH24:mi:ss
  n_安排id       挂号安排.Id%Type;
  n_计划id       挂号安排计划.Id%Type;
  v_号码         挂号安排.号码%Type;
  n_状态         挂号序号状态.状态%Type;
  v_星期         挂号安排限制.限制项目%Type;
  n_号序         挂号序号状态.序号%Type;
  v_验证姓名     挂号序号状态.操作员姓名%Type;
  v_操作员姓名   挂号序号状态.操作员姓名%Type;
  v_验证机器名   挂号序号状态.机器名%Type;
  v_机器名       挂号序号状态.机器名%Type;
  n_限号数       挂号安排限制.限号数%Type;
  n_限约数       挂号安排限制.限约数%Type;
  n_合约模式     Number(3);
  n_序号控制     Number(3);
  n_分时段       Number(3);
  n_存在         Number(18);
  n_启用合作单位 Number(3);
  n_是否挂号     Number(3); --1-挂号;0-预约
  n_自锁号       Number(3);
  d_时段开始     Date;
  d_序号时间     Date;
  d_时段结束     Date;
  n_Rowid        Rowid;
  v_Temp         Varchar2(32767); --临时XML
  Err_Item Exception;

  Function Check_Nums_Valied
  (
    安排id1_In  In 挂号安排.Id%Type,
    计划id1_In  In 挂号安排计划.Id%Type,
    星期1_In    In 挂号安排限制.限制项目%Type,
    是否挂号_In Number
  ) Return Number Is
    --功能：检查是否超出了限号或限约
    --入参:是否挂号_IN-1:挂号;0-预约
    --返回:1-表示数据合法;0-表示数据不合法:超出了限号或限约数
    n_Count Number(18);
    n_Temp  Number(18);
  Begin
    If Nvl(n_计划id, 0) <> 0 Then
      Select Max(限号数), Max(限约数)
      Into n_限号数, n_限约数
      From 挂号计划限制
      Where 计划id = 计划id1_In And 限制项目 = 星期1_In;
    Else
      Select Max(限号数), Max(限约数)
      Into n_限号数, n_限约数
      From 挂号安排限制
      Where 安排id = 安排id1_In And 限制项目 = 星期1_In;
    End If;
  
    Select Count(*)
    Into n_Count
    From (Select 序号
           From 挂号序号状态
           Where 号码 = 号码_In And Trunc(日期) = Trunc(日期_In)
           Union
           Select 序号
           From 合作单位计划控制
           Where 计划id = Decode(是否挂号_In, 1, 0, 计划id1_In) And Decode(是否挂号_In, 1, 0, 0) = 0 And 限制项目 = 星期1_In And 数量 <> 0
           Union
           Select 序号
           From 合作单位安排控制
           Where 安排id = Decode(是否挂号_In, 1, 0, 安排id1_In) And Decode(是否挂号_In, 1, 0, 0) = 0 And 限制项目 = 星期1_In And 数量 <> 0);
  
    If 是否挂号_In = 1 And Nvl(n_限号数, 0) <> 0 And Nvl(n_限号数, 0) < n_Count Then
      Return 0;
    Elsif 是否挂号_In = 0 Then
      n_Temp := Nvl(n_限约数, 0);
      If n_Temp = 0 Then
        n_Temp := Nvl(n_限号数, 0);
      End If;
      If n_Temp <> 0 And n_Temp < n_Count Then
        Return 0;
      End If;
    End If;
    Return 1;
  End;

  Function Get_Next_Plannum
  (
    号码1_In       In 挂号安排.号码%Type,
    日期1_In       In Date,
    安排id1_In     In 挂号安排.Id%Type,
    计划id1_In     In 挂号安排计划.Id%Type,
    星期1_In       In 挂号安排限制.限制项目%Type,
    操作员姓名1_In 人员表.姓名%Type,
    机器名1_In     挂号序号状态.机器名%Type,
    备注1_In       In 挂号序号状态.备注%Type
  ) Return Number Is
    n_Temp_序号 Number(18);
    n_Find      Number(2);
    n_自锁号    Number(2);
    d_序号时间  Date;
    n_Rowid     Rowid;
  Begin
    If Nvl(计划id_In, 0) <> 0 Then
      Select Max(序号) + 1
      Into n_Temp_序号
      From (Select Distinct 序号
             From 挂号计划时段
             Where 计划id = 计划id1_In And 星期 = 星期1_In
             Union All
             Select Distinct 序号
             From 挂号序号状态
             Where 号码 = 号码1_In And Trunc(日期) = Trunc(日期1_In));
    Else
      Select Max(序号) + 1
      Into n_Temp_序号
      From (Select Distinct 序号
             From 挂号安排时段
             Where 安排id = 安排id1_In And 星期 = 星期1_In
             Union
             Select Distinct 序号
             From 挂号序号状态
             Where 号码 = 号码1_In And Trunc(日期) = Trunc(日期1_In));
    End If;
  
    n_Find := 0;
    While n_Find = 0 Loop
      Begin
        Select Rowid, 1,
               Case
                 When 机器名 = 机器名1_In And 操作员姓名 = 操作员姓名1_In And 状态 = 5 Then
                  1
                 Else
                  0
               End
        Into n_Rowid, n_存在, n_自锁号
        From 挂号序号状态
        Where 号码 = 号码1_In And 日期 Between Trunc(日期1_In) And Trunc(日期1_In) + 1 - 1 / 24 / 60 / 60 And 序号 = n_Temp_序号;
      Exception
        When Others Then
          n_存在   := 0;
          n_自锁号 := 0;
      End;
      If Nvl(n_存在, 0) = 1 And Nvl(n_自锁号, 0) = 1 Then
        --自己锁的号，独站起:
        Update 挂号序号状态 Set 状态 = 5 Where Rowid = n_Rowid;
        n_Find := 1;
        Return n_Temp_序号;
      End If;
    
      If Nvl(n_存在, 0) = 0 Then
        --未发现该序号被站用，插入记录
        d_序号时间 := 日期1_In;
        If 时间段_In Is Not Null Then
          Begin
            If Nvl(计划id1_In, 0) <> 0 Then
              Select To_Date(To_Char(日期1_In, 'yyyy-mm-dd') || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss')
              Into d_序号时间
              From 挂号计划时段
              Where 计划id = 计划id1_In And 星期 = v_星期 And 序号 = n_号序;
            Else
            
              Select To_Date(To_Char(日期1_In, 'yyyy-mm-dd') || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss')
              Into d_序号时间
              From 挂号安排时段
              Where 安排id = 安排id1_In And 星期 = v_星期 And 序号 = n_号序;
            End If;
          Exception
            When Others Then
              d_序号时间 := 日期1_In;
          End;
        End If;
        Insert Into 挂号序号状态
          (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
        Values
          (号码1_In, d_序号时间, n_Temp_序号, 5, 操作员姓名1_In, 备注1_In, Sysdate, 机器名1_In);
      
        n_Find := 1;
        Return n_Temp_序号;
      End If;
      n_Temp_序号 := n_Temp_序号 + 1;
    End Loop;
  End;

Begin

  v_机器名 := 机器名_In;
  If v_机器名 Is Null Then
    Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
  End If;
  v_操作员姓名 := 操作员姓名_In;
  If v_操作员姓名 Is Null Then
    v_操作员姓名 := Zl_Username;
  End If;

  n_号序     := 号序_In;
  v_号码     := 号码_In;
  n_是否挂号 := Case
              When Nvl(是否预约_In, 0) = 0 Then
               1
              Else
               0
            End;

  If 操作类型_In = 0 Then
    --解锁
    Delete 挂号序号状态
    Where 机器名 = v_机器名 And 操作员姓名 = v_操作员姓名 And 状态 = 5 And 序号 = n_号序 And Trunc(日期) = Trunc(日期_In) And 号码 = 号码_In;
    If Sql%NotFound Then
      v_Temp := '没有发现需要解锁的序号';
      Raise Err_Item;
    End If;
    序号_Out := n_号序;
    Return;
  End If;

  --锁号
  If 时间段_In Is Not Null Then
    Begin
      d_时段开始 := To_Date(To_Char(日期_In, 'yyyy-mm-dd') || Substr(时间段_In, 1, Instr(时间段_In, '-') - 1),
                        'yyyy-mm-dd hh24:mi:ss');
      If Substr(时间段_In, Instr(时间段_In, '-') + 1) Is Null Then
        d_时段结束 := Null;
      Else
        d_时段结束 := To_Date(To_Char(日期_In, 'yyyy-mm-dd') || Substr(时间段_In, Instr(时间段_In, '-') + 1),
                          'yyyy-mm-dd hh24:mi:ss');
      End If;
    Exception
      When Others Then
        v_Temp := '无法解析传入的时间段格式，请检查！';
        Raise Err_Item;
    End;
  End If;

  Select Decode(To_Char(日期_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null)
  Into v_星期
  From Dual;

  n_计划id := Nvl(计划id_In, 0);
  n_安排id := Nvl(安排id_In, 0);
  If Nvl(n_计划id, 0) <> 0 Then
    Select Max(a.序号控制), Max(b.号码)
    Into n_序号控制, v_号码
    From 挂号安排计划 A, 挂号安排 B
    Where a.Id = n_计划id And a.安排id = b.Id;
  End If;
  If Nvl(n_安排id, 0) <> 0 Then
    Select Max(序号控制), Max(号码) Into n_序号控制, v_号码 From 挂号安排 Where ID = n_安排id;
  End If;

  If Nvl(n_计划id, 0) = 0 And Nvl(n_安排id, 0) = 0 Then
    Begin
      Select 序号控制, ID
      Into n_序号控制, n_计划id
      From (Select 序号控制, ID
             From 挂号安排计划
             Where 号码 = v_号码 And 日期_In Between Nvl(生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                   Nvl(失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And 审核时间 Is Not Null
             Order By 生效时间 Desc)
      Where Rownum < 2;
    Exception
      When Others Then
        Select 序号控制, ID Into n_序号控制, n_安排id From 挂号安排 Where 号码 = v_号码;
    End;
  End If;

  If Nvl(n_序号控制, 0) = 0 Then
    --未启用序号，不能锁号
    Return;
  End If;

  If Nvl(n_计划id, 0) <> 0 Then
    Select Nvl(Max(1), 0) Into n_分时段 From 挂号计划时段 Where 星期 = v_星期 And 计划id = n_计划id And Rownum < 2;
  
    Select Nvl(Max(1), 0)
    Into n_启用合作单位
    From 合作单位计划控制
    Where 限制项目 = v_星期 And 计划id = n_计划id And 合作单位 = 合作单位_In And Rownum < 2;
  Else
  
    Select Nvl(Max(1), 0) Into n_分时段 From 挂号安排时段 Where 星期 = v_星期 And 安排id = n_安排id And Rownum < 2;
    Select Nvl(Max(1), 0)
    Into n_启用合作单位
    From 合作单位安排控制
    Where 限制项目 = v_星期 And 安排id = n_安排id And 合作单位 = 合作单位_In And Rownum < 2;
  End If;

  If 操作类型_In = 2 Then
    --直接取一下号来进行锁号操作
    v_Temp := Zl_Fun_挂号安排_传统_Nextsn(日期_In, n_安排id, n_计划id, v_操作员姓名, v_星期, 备注_In, v_机器名, 合作单位_In, 0, Nvl(是否预约_In, 0));
    If v_Temp Is Not Null Then
      序号_Out := To_Number(Substr(v_Temp, 1, Instr(v_Temp, '|') - 1));
    End If;
    Return;
  End If;

  n_存在 := 0;
  If 时间段_In Is Null And 操作类型_In = 1 Then
    If Nvl(n_计划id, 0) <> 0 Then
      Begin
        Select 1, a.状态, a.操作员姓名, a.机器名, a.序号
        Into n_存在, n_状态, v_验证姓名, v_验证机器名, n_号序
        From 挂号序号状态 A, 挂号计划时段 B
        Where a.号码 = v_号码 And Trunc(a.日期) = Trunc(日期_In) And a.序号 = b.序号 And b.计划id = n_计划id And b.星期 = v_星期 And
              To_Char(b.开始时间, 'hh24:mi') = To_Char(日期_In, 'hh24:mi') And Rownum < 2;
      Exception
        When Others Then
          Null;
      End;
    Else
      Begin
        Select 1, a.状态, a.操作员姓名, a.机器名, a.序号
        Into n_存在, n_状态, v_验证姓名, v_验证机器名, n_号序
        From 挂号序号状态 A, 挂号安排时段 B
        Where a.号码 = v_号码 And Trunc(a.日期) = Trunc(日期_In) And a.序号 = b.序号 And b.安排id = n_安排id And b.星期 = v_星期 And
              To_Char(b.开始时间, 'hh24:mi') = To_Char(日期_In, 'hh24:mi') And Rownum < 2;
      Exception
        When Others Then
          Null;
      End;
    End If;
  End If;

  If n_存在 = 1 Then
    If Not (n_状态 = 5 And v_验证姓名 = v_操作员姓名 And v_机器名 = v_验证机器名) Then
      --传入时间的序号已经被使用
      v_Temp := '传入时间' || 日期_In || '的序号已被使用';
      Raise Err_Item;
    End If;
    序号_Out := n_号序;
    Return;
  End If;

  If n_分时段 = 1 And 操作类型_In = 1 Then
    If 时间段_In Is Null Then
      --精确定位序号
      Begin
        n_存在 := 1;
        If Nvl(n_计划id, 0) <> 0 Then
          Select 序号
          Into n_号序
          From 挂号计划时段
          Where 计划id = n_计划id And 星期 = v_星期 And To_Char(开始时间, 'hh24:mi') = To_Char(日期_In, 'hh24:mi') And Rownum < 2;
        Else
          Select 序号
          Into n_号序
          From 挂号安排时段
          Where 安排id = n_安排id And 星期 = v_星期 And To_Char(开始时间, 'hh24:mi') = To_Char(日期_In, 'hh24:mi') And Rownum < 2;
        End If;
      Exception
        When Others Then
          n_存在 := 0;
      End;
    
      If n_存在 = 1 Then
        --存在，则检查是否被其他人站用。
        Begin
          Select Rowid, 1,
                 Case
                   When 机器名 = v_机器名 And 操作员姓名 = v_操作员姓名 And 状态 = 5 Then
                    1
                   Else
                    0
                 End
          Into n_Rowid, n_存在, n_自锁号
          From 挂号序号状态
          Where 号码 = v_号码 And 日期 = 日期_In And 序号 = n_号序;
        Exception
          When Others Then
            n_存在   := 0;
            n_自锁号 := 0;
        End;
      
        If Nvl(n_存在, 0) = 1 And Nvl(n_自锁号, 0) = 1 Then
          --自己锁的号，独站起:
          Update 挂号序号状态 Set 状态 = 5 Where Rowid = n_Rowid;
          序号_Out := n_号序;
          Return;
        End If;
        If Nvl(n_存在, 0) = 1 And Nvl(n_自锁号, 0) = 0 Then
          v_Temp := '传入时间' || 日期_In || '的序号已被使用';
          Raise Err_Item;
        End If;
        Insert Into 挂号序号状态
          (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
        Values
          (v_号码, 日期_In, n_号序, 5, v_操作员姓名, 备注_In, Sysdate, v_机器名);
        序号_Out := n_号序;
        Return;
      End If;
      --不存在时，取下一个号,同时检查限号数是否正确
      n_号序 := Get_Next_Plannum(v_号码, 日期_In, n_安排id, n_计划id, v_星期, v_操作员姓名, v_机器名, 备注_In);
    
      If Check_Nums_Valied(n_安排id, n_计划id, v_星期, n_是否挂号) = 0 Then
        v_Temp := '传入号别' || 号码_In || '当前已无余号';
        Raise Err_Item;
      End If;
      序号_Out := n_号序;
      Return;
    Else
      If Nvl(n_计划id, 0) <> 0 Then
        --预约判断: 如果全部序号可以预约，则是否预约全部为0，所以需要单独处理这种情况
      
        Select Nvl(Max(1), 0)
        Into n_存在
        From 挂号计划时段
        Where 计划id = n_计划id And 星期 = v_星期 And 是否预约 = 1 And Rownum < 2;
      
        Select Min(a.序号), Min(b.状态)
        Into n_号序, n_状态
        From 挂号计划时段 A, 挂号序号状态 B
        Where a.序号 = b.序号(+) And (Nvl(b.状态, 0) = 0 Or Nvl(b.状态, 0) = 5) And b.号码(+) = v_号码 And
              Trunc(b.日期(+)) = Trunc(日期_In) And a.计划id = n_计划id And a.星期 = v_星期 And
              To_Char(a.开始时间, 'hh24:mi') >= To_Char(d_时段开始, 'hh24:mi') And
              To_Char(a.开始时间, 'hh24:mi') < To_Char(d_时段结束, 'hh24:mi') And Case
                When n_是否挂号 = 1 Or n_存在 = 0 Then
                 1
                Else
                 a.是否预约
              End = 1; --  Decode(n_是否挂号, 1, 1, Decode(n_存在, 1, a.是否预约, 1))) = 1;
      Else
        Select Nvl(Max(1), 0)
        Into n_存在
        From 挂号安排时段
        Where 安排id = n_安排id And 星期 = v_星期 And 是否预约 = 1 And Rownum < 2;
      
        Select Min(a.序号), Min(b.状态)
        Into n_号序, n_状态
        From 挂号安排时段 A, 挂号序号状态 B
        Where a.序号 = b.序号(+) And (Nvl(b.状态, 0) = 0 Or Nvl(b.状态, 0) = 5) And b.号码(+) = v_号码 And
              Trunc(b.日期(+)) = Trunc(日期_In) And a.安排id = n_安排id And a.星期 = v_星期 And
              To_Char(a.开始时间, 'hh24:mi') >= To_Char(d_时段开始, 'hh24:mi') And
              To_Char(a.开始时间, 'hh24:mi') < To_Char(d_时段结束, 'hh24:mi') And Case
                When n_是否挂号 = 1 Or n_存在 = 0 Then
                 1
                Else
                 a.是否预约
              End = 1; --  Decode(n_是否挂号, 1, 1, Decode(n_存在, 1, a.
      
      End If;
    
      If Nvl(n_号序, 0) = 0 Then
        If n_存在 = 1 Then
          v_Temp := '传入时间段' || 时间段_In || '的序号已被使用或未开放预约。';
          Raise Err_Item;
        End If;
      
        If d_时段结束 Is Not Null Then
          v_Temp := '传入时间段' || 时间段_In || '的序号已被使用';
          Raise Err_Item;
        End If;
        --不存在时，取下一个号,同时检查限号数是否正确
        n_号序 := Get_Next_Plannum(v_号码, 日期_In, n_安排id, n_计划id, v_星期, v_操作员姓名, v_机器名, 备注_In);
      
        If Check_Nums_Valied(n_安排id, n_计划id, v_星期, n_是否挂号) = 0 Then
          v_Temp := '传入号别' || v_号码 || '当前已无余号';
          Raise Err_Item;
        End If;
        序号_Out := n_号序;
        Return;
      End If;
      --存在序号
      If Nvl(n_状态, 0) = 0 Then
        --合法时间段，插入记录
        Insert Into 挂号序号状态
          (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
        Values
          (v_号码, 日期_In, n_号序, 5, v_操作员姓名, 备注_In, Sysdate, v_机器名);
        序号_Out := n_号序;
        Return;
      
      End If;
    
      If Nvl(n_状态, 0) = 5 Then
        Select Nvl(Max(1), 0)
        Into n_存在
        From 挂号序号状态
        Where 机器名 = v_机器名 And 操作员姓名 = v_操作员姓名 And 序号 = n_号序 And 号码 = v_号码;
      
        If n_存在 = 0 Then
          v_Temp := '传入时间段' || 时间段_In || '的序号已被使用';
          Raise Err_Item;
        End If;
        序号_Out := n_号序;
        Return;
      End If;
    
      If d_时段结束 Is Not Null Then
        v_Temp := '传入时间段' || 时间段_In || '的序号已被使用';
        Raise Err_Item;
      End If;
      --不存在时，取下一个号,同时检查限号数是否正确
      n_号序 := Get_Next_Plannum(v_号码, 日期_In, n_安排id, n_计划id, v_星期, v_操作员姓名, v_机器名, 备注_In);
      If Check_Nums_Valied(n_安排id, n_计划id, v_星期, n_是否挂号) = 0 Then
        v_Temp := '传入号别' || 号码_In || '当前已无余号';
        Raise Err_Item;
      End If;
    End If;
    序号_Out := n_号序;
    Return;
  End If;

  --不分时段,但启用了序号的
  If Nvl(n_计划id, 0) <> 0 Then
    Select Decode(n_是否挂号, 1, Max(限号数), Max(限约数))
    Into n_限号数
    From 挂号计划限制
    Where 计划id = n_计划id And 限制项目 = v_星期;
  Else
    Select Decode(n_是否挂号, 1, Max(限号数), Max(限约数))
    Into n_限号数
    From 挂号安排限制
    Where 安排id = n_安排id And 限制项目 = v_星期;
  End If;

  n_号序 := 1;
  If 合作单位_In Is Null Or n_启用合作单位 = 0 Then
    For r_序号 In (Select 序号, 状态, 操作员姓名, 机器名
                 From 挂号序号状态
                 Where 号码 = 号码_In And Trunc(日期) = Trunc(日期_In)
                 Union
                 Select 序号, Null, Null, Null
                 From 合作单位计划控制
                 Where 计划id = Decode(n_是否挂号, 1, 0, n_计划id) And Decode(n_是否挂号, 1, 1, 0) = 0 And 限制项目 = v_星期 And 数量 <> 0
                 Union
                 Select 序号, Null, Null, Null
                 From 合作单位安排控制
                 Where 安排id = Decode(n_是否挂号, 1, 0, n_安排id) And Decode(n_是否挂号, 1, 1, 0) = 0 And 限制项目 = v_星期 And 数量 <> 0
                 Order By 序号) Loop
      --存在锁号的，则退出
      Exit When r_序号.状态 = 5 And r_序号.操作员姓名 = v_操作员姓名 And r_序号.机器名 = v_机器名;
      If r_序号.序号 = n_号序 Then
        n_号序 := n_号序 + 1;
      End If;
    End Loop;
  
    If n_号序 > n_限号数 Then
      v_Temp := '传入号别' || 号码_In || '当前已无余号';
      Raise Err_Item;
    End If;
  
    Begin
      Select Rowid, 1,
             Case
               When 机器名 = v_机器名 And 操作员姓名 = v_操作员姓名 And 状态 = 5 Then
                1
               Else
                0
             End
      Into n_Rowid, n_存在, n_自锁号
      From 挂号序号状态
      Where 号码 = 号码_In And Trunc(日期) = Trunc(日期_In) And 序号 = n_号序;
    Exception
      When Others Then
        n_存在   := 0;
        n_自锁号 := 0;
    End;
    If n_存在 = 1 And n_自锁号 = 1 Then
      序号_Out := n_号序;
      Return;
    End If;
    If n_存在 = 1 And n_自锁号 = 0 Then
      --已经站用了
      v_Temp := '序号' || n_号序 || '已被使用';
      Raise Err_Item;
    End If;
    Insert Into 挂号序号状态
      (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
    Values
      (号码_In, Trunc(日期_In), n_号序, 5, v_操作员姓名, 备注_In, Sysdate, v_机器名);
    序号_Out := n_号序;
    Return;
  End If;

  --启用了合作单位控制的:合约单位处理
  If Nvl(n_计划id, 0) <> 0 Then
    Select Count(1)
    Into n_合约模式
    From 合作单位计划控制
    Where 序号 = 0 And 计划id = n_计划id And 合作单位 = 合作单位_In And 限制项目 = v_星期 And 数量 <> 0;
  Else
    Select Count(1)
    Into n_合约模式
    From 合作单位安排控制
    Where 序号 = 0 And 安排id = n_安排id And 合作单位 = 合作单位_In And 限制项目 = v_星期 And 数量 <> 0;
  End If;

  If n_合约模式 = 0 Then
    If Nvl(n_计划id, 0) <> 0 Then
      Select Nvl(Max(序号), 0)
      Into n_号序
      From (Select 序号
             From 合作单位计划控制 A
             Where 计划id = n_计划id And 合作单位 = 合作单位_In And 限制项目 = v_星期 And 数量 <> 0 And
                   (Not Exists
                    (Select 1
                     From 挂号序号状态
                     Where 号码 = 号码_In And 序号 = a.序号 And Trunc(日期) = Trunc(日期_In) And 状态 <> 0) Or Exists
                    (Select 1
                     From 挂号序号状态
                     Where 号码 = 号码_In And 序号 = a.序号 And Trunc(日期) = Trunc(日期_In) And 状态 = 5 And 操作员姓名 = v_操作员姓名 And
                           机器名 = v_机器名))
             Order By 序号)
      Where Rownum < 2;
    Else
    
      Select Nvl(Max(序号), 0)
      Into n_号序
      From (Select 序号
             From 合作单位安排控制 A
             Where 安排id = n_安排id And 合作单位 = 合作单位_In And 限制项目 = v_星期 And 数量 <> 0 And
                   (Not Exists
                    (Select 1
                     From 挂号序号状态
                     Where 号码 = 号码_In And 序号 = a.序号 And Trunc(日期) = Trunc(日期_In) And 状态 <> 0) Or Exists
                    (Select 1
                     From 挂号序号状态
                     Where 号码 = 号码_In And 序号 = a.序号 And Trunc(日期) = Trunc(日期_In) And 状态 = 5 And 操作员姓名 = v_操作员姓名 And
                           机器名 = v_机器名))
             Order By 序号)
      Where Rownum < 2;
    End If;
  
    If Nvl(n_号序, 0) = 0 Then
      v_Temp := '传入号别' || 号码_In || '当前已无余号';
      Raise Err_Item;
    End If;
    Begin
      Select Rowid, 1,
             Case
               When 机器名 = v_机器名 And 操作员姓名 = v_操作员姓名 And 状态 = 5 Then
                1
               Else
                0
             End
      Into n_Rowid, n_存在, n_自锁号
      From 挂号序号状态
      Where 号码 = 号码_In And 日期 Between Trunc(日期_In) And Trunc(日期_In) + 1 - 1 / 24 / 60 / 60 And 序号 = n_号序;
    Exception
      When Others Then
        n_存在   := 0;
        n_自锁号 := 0;
    End;
    If n_存在 = 1 And n_自锁号 = 0 Then
      v_Temp := '序号为' || n_号序 || '已被使用';
      Raise Err_Item;
    End If;
    If Nvl(n_存在, 0) = 0 Then
      Insert Into 挂号序号状态
        (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
      Values
        (号码_In, Trunc(日期_In), n_号序, 5, v_操作员姓名, 备注_In, Sysdate, v_机器名);
    End If;
    序号_Out := n_号序;
    Return;
  
  Else
    n_号序 := 1;
    Select 限号数 Into n_限号数 From 挂号计划限制 Where 计划id = n_计划id And 限制项目 = v_星期;
    For r_序号 In (Select 序号, 状态, 操作员姓名, 机器名
                 From 挂号序号状态
                 Where 号码 = 号码_In And Trunc(日期) = Trunc(日期_In)
                 Union All
                 Select 序号, Null, Null, Null
                 From 合作单位计划控制
                 Where 计划id = n_计划id And Decode(Nvl(n_计划id, 0), 0, 0, 1) = 1 And 限制项目 = v_星期 And 数量 <> 0
                 Union All
                 Select 序号, Null, Null, Null
                 From 合作单位安排控制
                 Where 安排id = n_安排id And Decode(Nvl(n_计划id, 0), 0, 1, 0) = 1 And 限制项目 = v_星期 And 数量 <> 0
                 Order By 序号) Loop
      If r_序号.状态 = 5 And r_序号.操作员姓名 = v_操作员姓名 And r_序号.机器名 = v_机器名 Then
        n_号序 := r_序号.序号;
        Exit;
      End If;
      If r_序号.序号 = n_号序 Then
        n_号序 := n_号序 + 1;
      End If;
    End Loop;
  
    If n_号序 > n_限号数 Then
      v_Temp := '传入号别' || 号码_In || '当前已无余号';
      Raise Err_Item;
    End If;
  
    Begin
      Select Rowid, 1,
             Case
               When 机器名 = v_机器名 And 操作员姓名 = v_操作员姓名 And 状态 = 5 Then
                1
               Else
                0
             End
      Into n_Rowid, n_存在, n_自锁号
      From 挂号序号状态
      Where 号码 = 号码_In And 日期 Between Trunc(日期_In) And Trunc(日期_In) + 1 - 1 / 24 / 60 / 60 And 序号 = n_号序;
    Exception
      When Others Then
        n_存在   := 0;
        n_自锁号 := 0;
    End;
    If n_存在 = 1 And n_自锁号 = 0 Then
      v_Temp := '序号为' || n_号序 || '已被使用';
      Raise Err_Item;
    End If;
  
    If Nvl(n_存在, 0) = 0 Then
      Insert Into 挂号序号状态
        (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
      Values
        (号码_In, Trunc(日期_In), n_号序, 5, v_操作员姓名, 备注_In, Sysdate, v_机器名);
    End If;
    序号_Out := n_号序;
    Return;
  End If;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Temp || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_挂号安排_传统_Lockno;
/

--118584:刘兴洪,2018-01-22,增加免挂号模式
--119108:刘兴洪,2018-01-15,并发锁号问题
Create Or Replace Procedure Zl_Third_Lockno
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:HIS锁号
  --入参:Xml_In:
  --<IN>
  --  <HM>5</HM>           //号码
  --  <CZJLID>1</CZJLID>       //出诊记录ID,出诊表排班模式下传入
  --  <RQ>2013-11-21 09:00</RQ>  //预约时间
  --  <CZ>1</CZ>           //操作
  --  <HX></HX>          //号序
  --  <HZDW>支付宝</HZDW>   //合作单位
  --  <JQM>机器名</JQM>        //机器名
  --  <SJD>时间段</SJD>        //锁号的时间段
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  -- <HX>号序</HX>          //锁号操作并且成功时返回
  -- 错误信息  //出错时返回
  --</ OUTPUT>
  --------------------------------------------------------------------------------------------------
  v_号码       挂号安排.号码%Type;
  d_日期       Date;
  n_操作类型   Number(3);
  n_号序       挂号序号状态.序号%Type;
  v_操作员姓名 挂号序号状态.操作员姓名%Type;
  v_机器名     挂号序号状态.机器名%Type;
  v_合作单位   合作单位安排控制.合作单位%Type;
  v_Temp       Varchar2(32767); --临时XML
  x_Templet    Xmltype; --模板XML
  n_记录id     临床出诊记录.Id%Type;
  d_启用时间   Date;
  v_时间段     Varchar2(200);
  v_Para       Varchar2(2000);
  n_挂号模式   Number(3);
  n_序号_Out   临床出诊序号控制.序号%Type;
  n_是否预约   number(3);
  Err_Item Exception;
  
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/HM'), To_Date(Extractvalue(Value(A), 'IN/RQ'), 'YYYY-MM-DD hh24:mi:ss'),
         Extractvalue(Value(A), 'IN/CZ'), Extractvalue(Value(A), 'IN/HX'), Extractvalue(Value(A), 'IN/HZDW'),
         Extractvalue(Value(A), 'IN/JQM'), Extractvalue(Value(A), 'IN/CZJLID'), Extractvalue(Value(A), 'IN/SJD')
  Into v_号码, d_日期, n_操作类型, n_号序, v_合作单位, v_机器名, n_记录id, v_时间段
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  v_Para := Nvl(Zl_Getsysparameter(256), '0');

  n_挂号模式 := To_Number(Substr(v_Para, 1, 1));

  If n_挂号模式 = 1 Then
    Begin
      d_启用时间 := To_Date(Substr(v_Para, 3), 'yyyy-mm-dd hh24:mi:ss');
    Exception
      When Others Then
        d_启用时间 := Null;
    End;
  
    If Nvl(d_日期, Sysdate) < Nvl(d_启用时间, Sysdate) Then
      n_挂号模式 := 0;
    End If;
  End If;

  If v_机器名 Is Null Then
    Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
  End If;

  v_操作员姓名 := Zl_Username;
  n_是否预约:=1;
  IF trunc(d_日期)=trunc(SYSDATE) THEN 
      n_是否预约:=0;
  END IF ;

  If Nvl(n_挂号模式, 0) = 0 Then
    --1.传统模式
    Zl_挂号安排_传统_Lockno(n_操作类型, v_号码, d_日期, n_号序, n_序号_Out, v_机器名, v_操作员姓名,NULL,NULL,n_是否预约,'移动锁号',v_合作单位, v_时间段);
  Else
    --2.临床出诊模式
    Zl_挂号安排_临床出诊_Lockno(n_操作类型, n_记录id, d_日期, n_号序, n_序号_Out,n_是否预约,'移动锁号',v_机器名, v_操作员姓名, d_启用时间, v_合作单位, v_时间段,  v_号码);
  End If;

  If n_序号_Out Is NOT Null Then
    v_Temp := '<HX>' || Nvl(n_序号_Out, 0) || '</HX>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  End If;
  Xml_Out := x_Templet;

Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Temp || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_Third_Lockno;
/

--119743:刘兴洪,2018-02-01,根据挂号单生成划价记录

Create Or Replace Procedure Zl_门诊划价记录_Buliding
(
  单据号_In     病人挂号记录.No%Type,
  划价单号_In   门诊费用记录.No%Type := Null,
  科室id_In     门诊费用记录.执行部门id%Type := Null,
  医生姓名_In   门诊费用记录.执行人%Type := Null,
  操作员姓名_In 门诊费用记录.操作员姓名%Type := Null,
  站点_In       Varchar2 := Null
) As

  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_药品等级 收费价格等级.名称%Type;
  v_卫材等级 收费价格等级.名称%Type;
  v_普通等级 收费价格等级.名称%Type;
  n_序号     门诊费用记录.序号%Type;
  n_价格父号 门诊费用记录.价格父号%Type;
  n_从属父号 门诊费用记录.从属父号%Type;
  v_划价单号 门诊费用记录.No%Type;
  d_登记时间 门诊费用记录.登记时间%Type;
  n_病人id   门诊费用记录.病人id%Type;
  n_应收金额 门诊费用记录.应收金额%Type;
  n_实收金额 门诊费用记录.实收金额%Type;

  v_付款方式名称   医疗付款方式.名称%Type;
  n_是否预约       Number(3);
  n_接收确定挂号费 Number(3);
  n_Count          Number(18);
  v_Temp           Varchar2(4000);
  n_金额小数       Number;
  n_单价小数       Number;

Begin

  Select Max(收费单) Into v_Temp From 病人挂号记录 Where NO = 单据号_In;

  If Length(Nvl(v_Temp, '')) + 20 > 2000 Then
    v_Err_Msg := '挂号单为:' || 单据号_In || '，生成的划价单过多！';
    Raise Err_Item;
  End If;
  v_划价单号 := 划价单号_In;
  If v_划价单号 Is Null Then
    v_划价单号 := Nextno(13);
  End If;
  If v_划价单号 Is Null Then
    v_Err_Msg := '取划价单据的单据号失败,请与系统管理员联系！';
    Raise Err_Item;
  End If;

  --金额小数位数
  Select Zl_To_Number(Nvl(Zl_Getsysparameter(9), '2')), Zl_To_Number(Nvl(Zl_Getsysparameter(157), '5'))
  Into n_金额小数, n_单价小数
  From Dual;
  d_登记时间 := Sysdate;

  Update 病人挂号记录
  Set 收费单 = Decode(收费单, Null, v_划价单号, 收费单 || ',' || v_划价单号)
  Where NO = 单据号_In
  Returning 医疗付款方式, 病人id, 记录性质 Into v_付款方式名称, n_病人id, n_Count;
  If Sql%NotFound Then
    v_Err_Msg := '未找到挂号单:' || 单据号_In || '！';
    Raise Err_Item;
  End If;

  If Nvl(n_Count, 0) = 2 Then
    n_是否预约 := 1;
  Else
    n_是否预约 := 0;
  End If;
  n_接收确定挂号费 := 0;
  If Nvl(n_是否预约, 0) = 1 Then
    n_接收确定挂号费 := Zl_To_Number(Nvl(Zl_Getsysparameter('预约接收确定挂号费', 1111), '0'));
    If Nvl(n_接收确定挂号费, 0) = 1 Then
    
      v_Temp := Zl_Get_Pricegrade(站点_In, n_病人id, 0, v_付款方式名称);
    
      For c_价格等级 In (Select Rownum As 序号, Column_Value As 价格等级 From Table(f_Str2list(v_Temp, '|'))) Loop
        If c_价格等级.序号 = 1 Then
          v_普通等级 := c_价格等级.价格等级;
        End If;
        If c_价格等级.序号 = 2 Then
          v_药品等级 := c_价格等级.价格等级;
        End If;
        If c_价格等级.序号 = 3 Then
          v_卫材等级 := c_价格等级.价格等级;
        End If;
      End Loop;
    End If;
  End If;
  If Nvl(n_接收确定挂号费, 0) = 1 And Nvl(n_是否预约, 0) = 1 Then
  
    --预约接收需要确定挂号费
    For c_挂号 In (Select NO, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 付款方式, 费别, 序号, 从属父号, 价格父号, 收费细目id, 收费类别, 计算单位, 发药窗口, 付数, 数次, 加班标志,
                        附加标志, 执行部门id, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 发生时间, 登记时间, 摘要, 操作员姓名, 病人科室id, 开单部门id, 开单人
                 From 门诊费用记录
                 Where NO = 单据号_In And 记录性质 = 4 And 记录状态 In (0, 1, 3) And 序号 = 1
                 Order By 序号) Loop
      n_序号     := 1;
      n_价格父号 := Null;
      n_从属父号 := Null;
      n_Count    := 0;
      For c_价格 In (Select 1 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, -1 As 执行科室类型
                   From 收费项目目录 A, 收费价目 B, 收入项目 C
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = c_挂号.收费细目id And Sysdate Between b.执行日期 And
                         Nvl(b.终止日期, Sysdate + 1) And
                         ((b.价格等级 Is Null And Nvl(v_普通等级, '-') = '-') Or b.价格等级 = Nvl(v_普通等级, '-') Or
                         (b.价格等级 Is Null And Not Exists
                          (Select 1
                            From 收费价目
                            Where b.收费细目id = 收费细目id And 价格等级 = Nvl(v_普通等级, '-') And Sysdate Between 执行日期 And
                                  Nvl(终止日期, Sysdate + 1))))
                   Union All
                   Select 2 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, d.从项数次 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, -1 As 执行科室类型
                   From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费从属项目 D
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = d.从项id And d.主项id = c_挂号.收费细目id And
                         Sysdate Between b.执行日期 And Nvl(b.终止日期, Sysdate + 1) And
                         ((b.价格等级 Is Null And Nvl(v_普通等级, '-') = '-') Or b.价格等级 = Nvl(v_普通等级, '-') Or
                         (b.价格等级 Is Null And Not Exists
                          (Select 1
                            From 收费价目
                            Where b.收费细目id = 收费细目id And 价格等级 = Nvl(v_普通等级, '-') And Sysdate Between 执行日期 And
                                  Nvl(终止日期, Sysdate + 1))))
                   Order By 性质, 项目id, 收入项目id) Loop
      
        n_应收金额 := Round(c_价格.数次 * c_价格.单价, n_金额小数);
        n_实收金额 := Round(n_应收金额, n_金额小数);
      
        If Nvl(c_价格.屏蔽费别, 0) <> 1 Then
        
          v_Temp     := Zl_Actualmoney(c_挂号.费别, c_价格.项目id, c_价格.收入项目id, n_应收金额);
          n_实收金额 := To_Number(Substr(v_Temp, Instr(v_Temp, ':') + 1));
          n_实收金额 := Round(n_实收金额, n_金额小数);
        End If;
      
        Zl_门诊划价记录_Insert(v_划价单号, n_序号, c_挂号.病人id, c_挂号.主页id, c_挂号.标识号, c_挂号.付款方式, c_挂号.姓名, c_挂号.性别, c_挂号.年龄, c_挂号.费别,
                         c_挂号.加班标志, c_挂号.病人科室id, c_挂号.开单部门id, c_挂号.开单人, c_挂号.从属父号, c_挂号.收费细目id, c_挂号.收费类别, c_挂号.计算单位,
                         c_挂号.发药窗口, 1, c_价格.数次, c_挂号.附加标志, Nvl(科室id_In, c_挂号.执行部门id), n_价格父号, c_价格.收入项目id, c_价格.收据费目,
                         c_价格.单价, n_应收金额, n_实收金额, c_挂号.发生时间, d_登记时间, c_挂号.摘要, 操作员姓名_In, '挂号:' || 单据号_In, Null, Null,
                         Null, Null, Null, Null, Null, Null, Null, Null, Null, Null, Null, Null, 医生姓名_In);
      
        If c_价格.性质 = 1 And n_价格父号 Is Null Then
          n_价格父号 := n_序号;
          n_从属父号 := Null;
        End If;
        If c_价格.性质 = 2 And n_从属父号 Is Null Then
          n_价格父号 := Null;
          n_从属父号 := n_序号;
        End If;
        n_序号  := n_序号 + 1;
        n_Count := n_Count + 1;
      End Loop;
    
    End Loop;
    If n_Count = 0 Then
    
      v_Err_Msg := '挂号号为:' || 单据号_In || '在生成划价单时失败,请检查挂号费用是否正确！';
      Raise Err_Item;
    
    End If;
    Return;
  End If;
  For c_挂号 In (Select a.No, 病人id, a.主页id, a.标识号, a.姓名, a.性别, a.年龄, a.付款方式, a.费别, a.序号, a.从属父号, a.价格父号, a.收费细目id, a.收费类别,
                      a.计算单位, a.发药窗口, a.付数, a.数次, a.加班标志, a.附加标志, a.执行部门id, a.收入项目id, a.收据费目, a.标准单价, a.应收金额, a.实收金额,
                      a.发生时间, a.登记时间, a.摘要, a.操作员姓名, a.病人科室id, a.开单部门id, a.开单人, b.屏蔽费别
               From 门诊费用记录 A, 收费项目目录 B
               Where a.No = 单据号_In And a.记录性质 = 4 And a.记录状态 In (0, 1, 3) And a.收费细目id = b.Id
               Order By a.序号) Loop
  
    n_应收金额 := Round(c_挂号.应收金额, n_金额小数);
    If Nvl(n_应收金额, 0) = 0 Then
      n_应收金额 := Round(Nvl(c_挂号.付数, 1) * Nvl(c_挂号.数次, 0) * Nvl(c_挂号.标准单价, 0), 2);
    End If;
    n_实收金额 := Round(n_应收金额, n_金额小数);
  
    If Nvl(c_挂号.屏蔽费别, 0) <> 1 Then
      v_Temp     := Zl_Actualmoney(c_挂号.费别, c_挂号.收费细目id, c_挂号.收入项目id, n_应收金额);
      n_实收金额 := To_Number(Substr(v_Temp, Instr(v_Temp, ':') + 1));
      n_实收金额 := Round(n_实收金额, n_金额小数);
    End If;
  
    Zl_门诊划价记录_Insert(v_划价单号, c_挂号.序号, c_挂号.病人id, c_挂号.主页id, c_挂号.标识号, c_挂号.付款方式, c_挂号.姓名, c_挂号.性别, c_挂号.年龄, c_挂号.费别,
                     c_挂号.加班标志, c_挂号.病人科室id, c_挂号.开单部门id, c_挂号.开单人, c_挂号.从属父号, c_挂号.收费细目id, c_挂号.收费类别, c_挂号.计算单位,
                     c_挂号.发药窗口, c_挂号.付数, c_挂号.数次, c_挂号.附加标志, Nvl(科室id_In, c_挂号.执行部门id), c_挂号.价格父号, c_挂号.收入项目id,
                     c_挂号.收据费目, c_挂号.标准单价, n_应收金额, n_实收金额, c_挂号.发生时间, d_登记时间, c_挂号.摘要, 操作员姓名_In, '挂号:' || 单据号_In, Null,
                     Null, Null, Null, Null, Null, Null, Null, Null, Null, Null, Null, Null, Null, 医生姓名_In);
  
  End Loop;

  Update 门诊费用记录
  Set 摘要 = '划价:' || Nvl(Replace(摘要, '划价:', ''), '') || Decode(摘要, Null, '', ',') || v_划价单号
  Where 记录性质 = 4 And NO = 单据号_In And 记录状态 In (0, 1, 3);

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_门诊划价记录_Buliding;
/

--110624:刘涛,2018-01-23,外购直接修改信息
--119413:秦龙,2018-01-12,修正外观字段无值
Create Or Replace Procedure Zl_药品外购_Strike
(
  行次_In       In Integer,
  原记录状态_In In 药品收发记录.记录状态%Type,
  No_In         In 药品收发记录.No%Type,
  序号_In       In 药品收发记录.序号%Type,
  药品id_In     In 药品收发记录.药品id%Type,
  冲销数量_In   Number,
  填制人_In     In 药品收发记录.填制人%Type,
  填制日期_In   In 药品收发记录.填制日期%Type,
  发票号_In     In 应付记录.发票号%Type := Null,
  发票金额_In   In 应付记录.发票金额%Type := Null,
  全部冲销_In   In 药品收发记录.实际数量%Type := 0, --用于财务审核
  财务审核_In   In Number := 0, --财务审核标志
  摘要_In       In 药品收发记录.摘要%Type,
  发票代码_In   In 应付记录.发票代码%Type := Null
) Is
  Err_Isstriked Exception;
  Err_Isoutstock Exception;
  Err_Isbatch Exception;
  Err_Isnonum Exception;
  v_Druginf Varchar2(50); --原不分批现在分批的药品信息

  v_应付id       应付记录.Id%Type;
  v_库房id       药品收发记录.库房id%Type;
  v_供药单位id   药品收发记录.供药单位id%Type;
  v_入出类别id   药品收发记录.入出类别id%Type;
  v_产地         药品收发记录.产地%Type;
  v_原产地       药品收发记录.原产地%Type;
  v_批次         药品收发记录.批次%Type;
  v_批号         药品收发记录.批号%Type;
  v_效期         药品收发记录.效期%Type;
  v_成本价       药品收发记录.成本价%Type;
  v_成本金额     药品收发记录.成本金额%Type;
  v_扣率         药品收发记录.扣率%Type;
  v_零售价       药品收发记录.零售价%Type;
  v_零售金额     药品收发记录.零售金额%Type;
  v_差价         药品收发记录.差价%Type;
  v_剩余数量     Number;
  v_剩余成本金额 药品收发记录.成本金额%Type;
  v_剩余零售金额 药品收发记录.零售金额%Type;
  v_入出系数     药品收发记录.入出系数%Type;
  v_冲销数量     Number;
  v_单量         药品收发记录.单量%Type;
  v_生产日期     药品收发记录.生产日期%Type;
  v_批准文号     药品收发记录.批准文号%Type;
  v_剩余金额差   药品收发记录.零售金额%Type;
  v_冲销金额差   药品收发记录.零售金额%Type;
  v_加成率       药品收发记录.频次%Type;
  n_平均成本价   药品库存.平均成本价%Type;
  n_计划id       药品收发记录.计划id%Type;

  v_外观     药品收发记录.外观%Type;
  v_核查人   药品收发记录.配药人%Type;
  v_核查日期 药品收发记录.配药日期%Type;
  v_发药方式 Number;
  v_收发id   药品收发记录.Id%Type;

  v_药库分批         Integer;
  v_药房分批         Integer;
  v_分批属性         Integer;
  v_药库             Integer;
  v_分批             Number;
  v_入库id           Number;
  v_差价修正金额     药品收发记录.零售金额%Type;
  v_差价修正冲销金额 药品收发记录.零售金额%Type;
  v_原成本价         药品收发记录.成本价%Type;
  n_收发id           药品收发记录.Id%Type;

  Intdigit   Number;
  v_发票金额 Number;
Begin
  --获取金额小数位数
  Select Nvl(精度, 2) Into Intdigit From 药品卫材精度 Where 性质 = 0 And 类别 = 1 And 内容 = 4 And 单位 = 5;
  --取核查人
  Select Min(配药人) 配药人, Min(配药日期) 配药日期, Sum(实际数量) 实际数量
  Into v_核查人, v_核查日期, v_冲销数量
  From 药品收发记录
  Where NO = No_In And 单据 = 1 And 序号 = 序号_In
  Group By 配药人, 配药日期;

  If 行次_In = 1 Then
    Update 药品收发记录
    Set 记录状态 = Decode(原记录状态_In, 1, 3, 原记录状态_In + 3), 费用id = 财务审核_In
    Where NO = No_In And 单据 = 1 And 记录状态 = 原记录状态_In;
  
    If Sql%RowCount = 0 Then
      Raise Err_Isstriked;
    End If;
  End If;

  --主要针对原不分批现在分批的药品，不能对其审核
  Begin
    Select Distinct '(' || i.编码 || ')' || Nvl(n.名称, i.名称) As 药品信息
    Into v_Druginf
    From 药品收发记录 A, 药品规格 B, 收费项目目录 I, 收费项目别名 N
    Where a.药品id = b.药品id And a.药品id = i.Id And a.药品id = n.收费细目id(+) And n.性质(+) = 3 And a.No = No_In And a.单据 = 1 And
          Mod(a.记录状态, 3) = 0 And Nvl(a.批次, 0) = 0 And a.药品id + 0 = 药品id_In And
          ((Nvl(b.药库分批, 0) = 1 And
          a.库房id Not In (Select 部门id From 部门性质说明 Where (工作性质 Like '%药房') Or (工作性质 Like '制剂室'))) Or Nvl(b.药房分批, 0) = 1) And
          Rownum = 1;
  Exception
    When Others Then
      v_Druginf := '';
  End;

  If v_Druginf Is Not Null Then
    Raise Err_Isbatch;
  End If;

  Select Sum(a.实际数量) As 剩余数量, Sum(a.成本金额) As 剩余成本金额, Sum(a.零售金额) As 剩余零售金额, Sum(To_Number(Nvl(a.用法, 0))) As 金额差, a.库房id,
         a.供药单位id, a.入出类别id, a.入出系数, Nvl(a.批次, 0), a.产地, a.原产地, a.批号, a.效期, a.成本价, a.扣率, a.零售价, b.药库分批, b.药房分批, a.发药方式, a.单量,
         a.生产日期, a.批准文号, a.频次, a.计划id, a.外观
  Into v_剩余数量, v_剩余成本金额, v_剩余零售金额, v_剩余金额差, v_库房id, v_供药单位id, v_入出类别id, v_入出系数, v_批次, v_产地, v_原产地, v_批号, v_效期, v_成本价, v_扣率,
       v_零售价, v_药库分批, v_药房分批, v_发药方式, v_单量, v_生产日期, v_批准文号, v_加成率, n_计划id, v_外观
  From 药品收发记录 A, 药品规格 B
  Where a.No = No_In And a.药品id = b.药品id And a.单据 = 1 And a.药品id = 药品id_In And a.序号 = 序号_In
  Group By a.库房id, a.供药单位id, a.入出类别id, a.入出系数, Nvl(a.批次, 0), a.产地, a.原产地, a.批号, a.效期, a.成本价, a.扣率, a.零售价, b.药库分批, b.药房分批,
           a.发药方式, a.单量, a.生产日期, a.批准文号, a.频次, a.计划id, a.外观;

  --如果是退库单据，并且是分批药品时，提取原始入库单据的ID
  If Nvl(v_发药方式, 0) = 1 Then
    Begin
      Select ID
      Into v_入库id
      From 药品收发记录
      Where NO = No_In And 单据 = 1 And 药品id = 药品id_In And 序号 = 序号_In And (记录状态 = 1 Or Mod(记录状态, 3) = 0);
    Exception
      When Others Then
        v_入库id := 0;
    End;
  End If;

  --判断该部门是药库还是药房
  Begin
    Select Distinct 0
    Into v_药库
    From 部门性质说明
    Where ((工作性质 Like '%药房') Or (工作性质 Like '制剂室')) And 部门id = v_库房id;
  Exception
    When Others Then
      v_药库 := 1;
  End;

  --根据部门性质,判断分批特性
  If v_药库 = 0 Then
    v_分批属性 := v_药房分批;
  Else
    v_分批属性 := v_药库分批;
  End If;

  --V_分批:(原分批,现分批为批次;否则为零)原不分批,现分批,本过程不考虑
  v_分批 := 0;
  If v_分批属性 = 1 And v_批次 <> 0 Then
    v_分批 := v_批次;
  End If;

  --全部冲销或者财务审核时，冲销数量等于剩余数量；其他情况冲销数量等于传入的冲销数量
  If 全部冲销_In = 1 Or 财务审核_In = 1 Then
    v_冲销数量 := v_剩余数量;
  Else
    v_冲销数量 := 冲销数量_In;
  End If;

  --冲销数量不能大于剩余数量（主要防止并发）
  If Abs(v_剩余数量) < Abs(v_冲销数量) Then
    Raise Err_Isnonum;
  End If;

  v_成本金额 := Round(v_冲销数量 / v_剩余数量 * v_剩余成本金额, Intdigit);
  v_零售金额 := Round(v_冲销数量 / v_剩余数量 * v_剩余零售金额, Intdigit);
  v_差价     := v_零售金额 - v_成本金额;

  --如果有金额差，则要冲销金额差
  v_冲销金额差 := 0;
  If v_剩余金额差 <> 0 Then
    If 全部冲销_In = 1 Or 财务审核_In = 1 Then
      v_冲销金额差 := v_剩余金额差;
    Else
      v_冲销金额差 := Round(v_冲销数量 / v_剩余数量 * v_剩余金额差, Intdigit);
    End If;
  End If;

  Select 药品收发记录_Id.Nextval Into v_收发id From Dual;

  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 供药单位id, 入出类别id, 入出系数, 药品id, 批次, 产地, 原产地, 批号, 效期, 填写数量, 实际数量, 成本价, 成本金额, 扣率, 零售价, 零售金额, 差价,
     摘要, 填制人, 填制日期, 配药人, 配药日期, 审核人, 审核日期, 发药方式, 单量, 生产日期, 批准文号, 用法, 频次, 费用id, 计划id, 外观)
  Values
    (v_收发id, Decode(原记录状态_In, 1, 2, 原记录状态_In + 2), 1, No_In, 序号_In, v_库房id, v_供药单位id, v_入出类别id, 1, 药品id_In, v_批次, v_产地, v_原产地,
     v_批号, v_效期, -v_冲销数量, -v_冲销数量, v_成本价, -v_成本金额, v_扣率, v_零售价, -v_零售金额, -v_差价, 摘要_In, 填制人_In, 填制日期_In, v_核查人, v_核查日期,
     填制人_In, 填制日期_In, v_发药方式, v_单量, v_生产日期, v_批准文号, Decode(v_冲销金额差, 0, Null, -v_冲销金额差), v_加成率, 财务审核_In, n_计划id, v_外观);
  
  
  --冲销单据如果计划id不为空则需要处理计划单据的执行数量
  If n_计划id Is Not Null Then
    Update 药品计划内容 Set 执行数量 = Nvl(执行数量, 0) - v_冲销数量 Where 计划id = n_计划id And 药品id = 药品id_In;
  End If;
  --调用库存更新过程
  If Nvl(v_发药方式, 0) = 1 Then
    Zl_药品库存_Update(v_收发id, 3, 0);
  Else
    If 财务审核_In = 0 Then
      Zl_药品库存_Update(v_收发id, 3, 1);
    Else
      Zl_药品库存_Update(v_收发id, 3, 1, 1);
    End If;
  End If;

  --对于冲销的单据也应该对应付余额表进行处理
  --只对填了发票号的记录进行处理
  v_发票金额 := Nvl(发票金额_In, 0);
  If Nvl(发票号_In, ' ') <> ' ' Or Nvl(发票金额_In, 0) <> 0 Then
    --对于财务审核的，要将剩余的发票金额全部冲销
    If 全部冲销_In = 1 Then
      Select Sum(b.发票金额)
      Into v_发票金额
      From (Select ID From 药品收发记录 Where 单据 = 1 And NO = No_In And 序号 = 序号_In) A, 应付记录 B
      Where a.Id = b.收发id And b.系统标识 = 1 And b.记录性质 <> -1;
    End If;
  
    Update 应付余额 Set 金额 = Nvl(金额, 0) - Nvl(v_发票金额, 0) Where 单位id = v_供药单位id And 性质 = 1;
  
    If Sql%NotFound Then
      Insert Into 应付余额 (单位id, 性质, 金额) Values (v_供药单位id, 1, -nvl(v_发票金额, 0));
    End If;
  
    Delete From 应付余额 Where 单位id = v_供药单位id And 金额 = 0;
  End If;

  --产生应付记录的冲销记录(先判断应付记录中是否已存在该记录对应的冲销记录,是则更新;否则新增)
  Select 应付记录_Id.Nextval Into v_应付id From Dual;
  Insert Into 应付记录
    (ID, 记录性质, 记录状态, 单位id, NO, 系统标识, 收发id, 入库单据号, 单据金额, 发票号, 发票日期, 发票金额, 品名, 规格, 产地, 批号, 计量单位, 数量, 采购价, 采购金额, 填制人, 填制日期,
     审核人, 审核日期, 摘要, 项目id, 序号, 随货单号, 随货日期, 库房id, 发票修改时间, 发票代码)
    Select v_应付id, 记录性质, Decode(原记录状态_In, 1, 2, 原记录状态_In + 2), 单位id, NO, 1, v_收发id, 入库单据号, -v_零售金额, 发票号, 发票日期, -v_发票金额,
           品名, 规格, 产地, 批号, 计量单位, -v_冲销数量, 采购价, -采购价 * v_冲销数量, 填制人_In, 填制日期_In, 填制人_In, 填制日期_In, 摘要, 项目id, 序号, 随货单号, 随货日期, 库房id,
           Sysdate, 发票代码
    From 应付记录
    Where 收发id = (Select ID From 药品收发记录 Where NO = No_In And 单据 = 1 And 序号 = 序号_In And Mod(记录状态, 3) = 0) And 系统标识 = 1 And
          记录性质 = 0;

  Update 应付记录
  Set 记录状态 = 3
  Where 收发id = (Select ID From 药品收发记录 Where NO = No_In And 单据 = 1 And 序号 = 序号_In And Mod(记录状态, 3) = 0) And 系统标识 = 1 And
        记录性质 = 0;

  --处理调价后冲销
  Zl_药品收发记录_调价修正(v_收发id);
Exception
  When Err_Isstriked Then
    Raise_Application_Error(-20101, '[ZLSOFT]该单据已经被他人冲销！[ZLSOFT]');
  When Err_Isbatch Then
    Raise_Application_Error(-20102, '[ZLSOFT]该单据中第' || 序号_In || '行的药品原来不分批，现在分批的药品[' || v_Druginf || ']，不能冲销！[ZLSOFT]');
  When Err_Isnonum Then
    Raise_Application_Error(-20102, '[ZLSOFT]该单据中第' || 序号_In || '行的药品冲销的数量大于了剩余数量，不能冲销！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品外购_Strike;
/

--110624:刘涛,2018-01-23,其他入库增加修改信息
--119413:秦龙,2018-01-12,外观字段的处理
Create Or Replace Procedure Zl_药品其他入库_Strike
(
  行次_In       In Integer,
  原记录状态_In In 药品收发记录.记录状态%Type,
  No_In         In 药品收发记录.No%Type,
  序号_In       In 药品收发记录.序号%Type,
  药品id_In     In 药品收发记录.药品id%Type,
  摘要_In       In 药品收发记录.摘要%Type,
  冲销数量_In   In 药品收发记录.实际数量%Type,
  填制人_In     In 药品收发记录.填制人%Type,
  填制日期_In   In 药品收发记录.填制日期%Type
) Is
  Err_Isstriked  Exception;
  Err_Isoutstock Exception;
  Err_Isnonum    Exception;
  Err_Isbatch    Exception;
  v_Druginf Varchar2(50); --原不分批现在分批的药品信息

  v_库房id       药品收发记录.库房id%Type;
  v_入出类别id   药品收发记录.入出类别id%Type;
  v_产地         药品收发记录.产地%Type;
  v_原产地       药品收发记录.原产地%Type;
  v_批次         药品收发记录.批次%Type;
  v_批号         药品收发记录.批号%Type;
  v_效期         药品收发记录.效期%Type;
  v_成本价       药品收发记录.成本价%Type;
  v_成本金额     药品收发记录.成本金额%Type;
  v_扣率         药品收发记录.扣率%Type;
  v_零售价       药品收发记录.零售价%Type;
  v_零售金额     药品收发记录.零售金额%Type;
  v_差价         药品收发记录.差价%Type;
  v_剩余数量     药品收发记录.实际数量%Type;
  v_剩余成本金额 药品收发记录.成本金额%Type;
  v_剩余零售金额 药品收发记录.零售金额%Type;
  v_入出系数     药品收发记录.入出系数%Type;
  v_生产日期     药品收发记录.生产日期%Type;
  v_批准文号     药品收发记录.批准文号%Type;
  n_上次供应商id 药品库存.上次供应商id%Type;
  v_剩余金额差   药品收发记录.零售金额%Type;
  v_冲销金额差   药品收发记录.零售金额%Type;
  v_外观         药品收发记录.外观%Type;
  v_收发id       药品收发记录.Id%Type;

  v_药库分批 Integer;
  v_药房分批 Integer;
  Intdigit   Number;
Begin
  --获取金额小数位数
  Select Nvl(精度, 2) Into Intdigit From 药品卫材精度 Where 性质 = 0 And 类别 = 1 And 内容 = 4 And 单位 = 5;

  If 行次_In = 1 Then
    Update 药品收发记录
    Set 记录状态 = Decode(原记录状态_In, 1, 3, 原记录状态_In + 3)
    Where NO = No_In And 单据 = 4 And 记录状态 = 原记录状态_In;
  
    If Sql%RowCount = 0 Then
      Raise Err_Isstriked;
    End If;
  End If;

  --主要针对原不分批现在分批的药品，不能对其审核
  Begin
    Select Distinct '(' || i.编码 || ')' || Nvl(n.名称, i.名称) As 药品信息
    Into v_Druginf
    From 药品收发记录 A, 药品规格 B, 收费项目目录 I, 收费项目别名 N
    Where a.药品id = b.药品id And a.药品id = i.Id And a.药品id = n.收费细目id(+) And n.性质(+) = 3 And a.No = No_In And a.单据 = 4 And
          Mod(a.记录状态, 3) = 0 And a.药品id + 0 = 药品id_In And Nvl(a.批次, 0) = 0 And
          ((Nvl(b.药库分批, 0) = 1 And
          a.库房id Not In (Select 部门id From 部门性质说明 Where (工作性质 Like '%药房') Or (工作性质 Like '制剂室'))) Or Nvl(b.药房分批, 0) = 1) And
          Rownum = 1;
  Exception
    When Others Then
      v_Druginf := '';
  End;

  If v_Druginf Is Not Null Then
    Raise Err_Isbatch;
  End If;

  Select Sum(a.实际数量) As 剩余数量, Sum(a.成本金额) As 剩余成本金额, Sum(a.零售金额) As 剩余零售金额, Sum(To_Number(Nvl(用法, 0))) As 金额差, a.库房id,
         a.入出类别id, a.入出系数, Nvl(a.批次, 0), a.产地, a.原产地, a.批号, a.效期, a.成本价, a.扣率, a.零售价, b.药库分批, b.药房分批, a.生产日期, a.批准文号,
         a.供药单位id, a.外观
  Into v_剩余数量, v_剩余成本金额, v_剩余零售金额, v_剩余金额差, v_库房id, v_入出类别id, v_入出系数, v_批次, v_产地, v_原产地, v_批号, v_效期, v_成本价, v_扣率, v_零售价,
       v_药库分批, v_药房分批, v_生产日期, v_批准文号, n_上次供应商id, v_外观
  From 药品收发记录 A, 药品规格 B
  Where a.No = No_In And a.单据 = 4 And a.药品id = b.药品id And a.药品id = 药品id_In And a.序号 = 序号_In
  Group By a.库房id, a.入出类别id, a.入出系数, Nvl(a.批次, 0), a.产地, a.原产地, a.批号, a.效期, a.成本价, a.扣率, a.零售价, b.药库分批, b.药房分批, a.生产日期,
           a.批准文号, a.供药单位id, a.外观;

  --冲销数量大于剩余数量，不允许
  If Abs(v_剩余数量) < Abs(冲销数量_In) Then
    Raise Err_Isnonum;
  End If;

  v_成本金额 := Round(冲销数量_In / v_剩余数量 * v_剩余成本金额, Intdigit);
  v_零售金额 := Round(冲销数量_In / v_剩余数量 * v_剩余零售金额, Intdigit);
  v_差价     := v_零售金额 - v_成本金额;

  --如果有金额差，则要冲销金额差
  v_冲销金额差 := 0;
  If v_剩余金额差 <> 0 Then
    v_冲销金额差 := Round(冲销数量_In / v_剩余数量 * v_剩余金额差, Intdigit);
  End If;

  Select 药品收发记录_Id.Nextval Into v_收发id From Dual;

  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 入出系数, 药品id, 批次, 产地, 原产地, 批号, 效期, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 零售金额, 差价, 摘要, 填制人,
     填制日期, 审核人, 审核日期, 生产日期, 批准文号, 供药单位id, 用法, 外观)
  Values
    (v_收发id, Decode(原记录状态_In, 1, 2, 原记录状态_In + 2), 4, No_In, 序号_In, v_库房id, v_入出类别id, v_入出系数, 药品id_In, v_批次, v_产地,
     v_原产地, v_批号, v_效期, -冲销数量_In, -冲销数量_In, v_成本价, -v_成本金额, v_零售价, -v_零售金额, -v_差价, 摘要_In, 填制人_In, 填制日期_In, 填制人_In,
     填制日期_In, v_生产日期, v_批准文号, n_上次供应商id, Decode(v_冲销金额差, 0, Null, -v_冲销金额差),v_外观);

  --更新库存，入库冲销相当于是出库业务
  Zl_药品库存_Update(v_收发id, 3, 1);

  --处理调价后冲销
  Zl_药品收发记录_调价修正(v_收发id);

Exception
  When Err_Isstriked Then
    Raise_Application_Error(-20101, '[ZLSOFT]该单据已经被他人冲销！[ZLSOFT]');
  When Err_Isoutstock Then
    Raise_Application_Error(-20102, '[ZLSOFT]该单据中有一笔分批药品已出库，不能冲销！[ZLSOFT]');
  When Err_Isbatch Then
    Raise_Application_Error(-20102, '[ZLSOFT]该单据中包含有一条原来不分批，现在分批的药品[' || v_Druginf || ']，不能冲销！[ZLSOFT]');
  When Err_Isnonum Then
    Raise_Application_Error(-20102, '[ZLSOFT]该单据中第' || 序号_In || '行的药品冲销的数量大于了剩余的数据，不能冲销！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品其他入库_Strike;
/

--119333:殷瑞,2018-01-12,修正肿瘤药、抗生素和营养药不受表[输液不配置药品]限制的情况
Create Or Replace Procedure Zl_输液配药记录_核查
(
  部门id_In   In 输液配药记录.部门id%Type,
  医嘱id_In   In Varchar2, --输液医嘱给药途径对应的医嘱ID:医嘱ID1,医嘱ID2...
  发送号_In   In 病人医嘱发送.发送号%Type,
  核查人_In   In 输液配药状态.操作人员%Type,
  核查时间_In In 输液配药状态.操作时间%Type
) Is
  v_Count    Number;
  v_序号     Number;
  v_执行时间 Date;

  v_相关id      Number;
  v_New相关id   Number;
  v_Old相关id   Number;
  v_发送号      Number;
  v_Tmp         Varchar2(200);
  I             Number;
  v_配药id      Number;
  v_批次        Number;
  v_Maxno       Varchar2(4000);
  v_Lableno     Varchar2(200);
  v_Maxbatch    Number;
  v_Curdose     Number;
  v_Sumdose     Number;
  v_Drugcount   Number;
  v_Currdate    Date;
  n_Needcheck   Number;
  n_Lngid       药品收发记录.Id%Type;
  n_Count       Number(3);
  n_单据        药品收发记录.单据%Type;
  v_No          药品收发记录.No%Type;
  n_发送次数    Number(5);
  n_病人id      病人信息.病人id%Type := 0;
  b_Change      Boolean := True;
  n_Sum         Number;
  n_调整批次    Number(1);
  n_Cur         Number(5);
  v_上次发送号  病人医嘱发送.发送号%Type;
  v_医嘱ids     Varchar2(4000);
  v_Tansid      Varchar2(12);
  v_当前病人    Varchar2(20);
  n_Num         Number(8);
  d_Old执行时间 Date;
  n_是否打包    Number(1);
  n_打包        Number(1);
  n_摆药单      Number(2);
  --控制参数
  v_医嘱类型       Number;
  v_输液总量       Number;
  v_大输液剂型     Varchar2(2000);
  v_大输液给药途径 Varchar2(2000);
  v_来源科室       Varchar2(4000);
  v_Continue       Number := 1;
  v_Nodosage       Number := 0;
  v_保持上次批次   Number := 0;
  d_手工打包时间   Date;
  n_Tpn处置方式    Number := 0;
  v_药品类型       Varchar2(20);
  n_打包药品批次   Number(1);
  n_特殊药品批次   Number(1);
  n_优先级         Number := 999;
  n_自动排批       Number := 0;
  n_科室id         Number := 0;
  n_Row            Number(2);
  n_备用批次       Number := 0;
  n_剩余数量       Number := 0;
  n_单次数量       Number := 0;
  n_累计数量       Number := 0;
  n_医嘱id         Number := 0;
  n_填写数量       Number := 0;
  v_配药类型       Varchar2(20);
  v_时间串         Varchar2(100);
  v_时间值         Date;
  v_Fields         Varchar2(100);
  v_是否改变       Varchar2(20);
  v_时间串1        Varchar2(100);
  Err_Item Exception;
  n_流通金额小数 Number;

  Cursor c_医嘱记录 Is
    Select /*+rule */
    Distinct e.医嘱id As 相关id, e.发送号, b.频率间隔, b.间隔单位, b.执行时间方案, a.姓名, a.性别, a.年龄, a.住院号, a.当前床号 As 床号, a.当前病区id As 病人病区id,
             a.当前科室id As 病人科室id, e.首次时间, e.末次时间, b.开始执行时间, Nvl(e.发送数次, 0) As 次数, e.发送时间, Decode(b.医嘱期效, 0, 1, 2) As 医嘱类型,
             b.诊疗项目id As 给药途径, b.病人id, Nvl(c.执行标记, 0) As 是否tpn
    From 病人医嘱发送 E, 病人医嘱记录 B, 病人信息 A, 诊疗项目目录 C, Table(f_Num2list(医嘱id_In)) D
    Where e.医嘱id = b.Id And b.病人id = a.病人id And c.类别 = 'E' And c.操作类型 = '2' And c.执行分类 = 1 And b.诊疗项目id = c.Id And
          e.医嘱id = d.Column_Value And e.发送号 = 发送号_In
    Order By b.病人id, e.医嘱id, e.发送号;

  Cursor c_单个医嘱记录 Is
    Select /*+rule */
    Distinct e.医嘱id, e.发送号, b.频率间隔, b.间隔单位, b.执行时间方案, a.姓名, a.性别, a.年龄, a.住院号, a.当前床号 As 床号, a.当前病区id As 病人病区id,
             a.当前科室id As 病人科室id, e.首次时间, e.末次时间, b.开始执行时间, Nvl(e.发送数次, 0) As 次数, e.发送时间, Decode(b.医嘱期效, 0, 1, 2) As 医嘱类型,
             b.诊疗项目id As 给药途径, b.病人id
    From 病人医嘱发送 E, 病人医嘱记录 B, 病人信息 A, 诊疗项目目录 C
    Where e.医嘱id = b.Id And b.病人id = a.病人id And b.诊疗项目id = c.Id And b.相关id = v_相关id And e.发送号 = 发送号_In
    Order By e.医嘱id, e.发送号;

  Cursor c_收发记录 Is
    Select Distinct c.Id As 收发id, c.序号, c.实际数量 As 数量, Nvl(e.是否不予配置, 0) As 是否不予配置, c.单据, c.No
    From 病人医嘱记录 A, 病人医嘱发送 B, 药品收发记录 C, 住院费用记录 D, 输液药品属性 E
    Where a.Id = b.医嘱id And c.费用id = d.Id And a.Id = d.医嘱序号 And b.No = c.No And c.药品id = e.药品id(+) And
          b.执行部门id + 0 = 部门id_In And c.单据 = 9 And c.审核日期 Is Null And a.Id = n_医嘱id And b.发送号 = 发送号_In And c.序号 < 1000
    Order By c.No, c.序号;

  Cursor c_原始收发记录 Is
    Select Distinct c.Id As 收发id, c.序号, c.实际数量 As 数量, Nvl(e.是否不予配置, 0) As 是否不予配置, c.单据, c.No
    From 病人医嘱记录 A, 病人医嘱发送 B, 药品收发记录 C, 住院费用记录 D, 输液药品属性 E
    Where a.Id = b.医嘱id And c.费用id = d.Id And a.Id = d.医嘱序号 And b.No = c.No And c.药品id = e.药品id(+) And
          b.执行部门id + 0 = 部门id_In And c.单据 = 9 And c.审核日期 Is Null And a.相关id = v_相关id And b.发送号 = 发送号_In And c.序号 < 1000
    Order By c.No, c.序号;

  Cursor c_输液单记录 Is
    Select a.Id, a.执行时间, a.配药批次, a.医嘱id, d.发送时间
    From 输液配药记录 A, 病人医嘱记录 B, 配药工作批次 C, 病人医嘱发送 D
    Where a.医嘱id = b.Id And a.配药批次 = c.批次 And d.医嘱id = a.医嘱id And a.发送号 = d.发送号 And c.批次 <> 0 And c.药品类型 Is Null And
          b.病人id = n_病人id And a.操作状态 < 2 And a.执行时间 Between Trunc(v_时间值) And Trunc(v_时间值 + 1) - 1 / 24 / 60 / 60;

  v_输液单记录   c_输液单记录%RowType;
  v_医嘱记录     c_医嘱记录%RowType;
  v_收发记录     c_收发记录%RowType;
  v_单个医嘱记录 c_单个医嘱记录%RowType;

  Function Zl_Getpivaworkbatch
  (
    执行时间_In In Date,
    发送时间_In In Date,
    药品类型_In In Varchar2 := Null
  ) Return Number As
  
    v_Exetime   Date;
    v_Starttime Date;
    v_Endtime   Date;
    v_Maxbatch  Number(2);
    v_Batch     Number;
    Cursor c_配药批次 Is
      Select 批次, 配药时间, 给药时间, 打包, 药品类型
      From 配药工作批次
      Where 启用 = 1 And 配置中心id = 部门id_In
      Order By 药品类型, 批次;
  
    v_配药批次 c_配药批次%RowType;
  Begin
    v_Exetime := To_Date(Substr(To_Char(执行时间_In, 'yyyy-mm-dd hh24:mi'), 12), 'hh24:mi');
  
    Select Max(Nvl(批次, 0)) + 1 Into v_Maxbatch From 配药工作批次 Where 启用 = 1 And 配置中心id = 部门id_In;
  
    For v_配药批次 In c_配药批次 Loop
      v_Batch := 0;
    
      --当天发送的医嘱发送到备用批次
      If (Trunc(执行时间_In) >= Trunc(v_Currdate) And Trunc(发送时间_In) < Trunc(执行时间_In)) Or n_备用批次 = 0 Then
        If v_配药批次.批次 <> '0' And
           ((Nvl(v_配药批次.药品类型, '0') <> '0' And v_配药批次.药品类型 = 药品类型_In) Or Nvl(v_配药批次.药品类型, '0') = '0') Then
          v_Starttime := To_Date(Substr(v_配药批次.给药时间, 1, Instr(v_配药批次.给药时间, '-') - 1), 'hh24:mi');
          v_Endtime   := To_Date(Substr(v_配药批次.给药时间, Instr(v_配药批次.给药时间, '-') + 1), 'hh24:mi');
        
          If v_Exetime >= v_Starttime And v_Exetime <= v_Endtime Then
            v_Batch := v_配药批次.批次;
            n_打包  := v_配药批次.打包;
            Exit When v_Batch > 0;
          End If;
        End If;
      End If;
    End Loop;
  
    If v_Batch = 0 And (n_打包药品批次 <> 1 Or n_备用批次 = 1) Then
      v_Batch := v_Maxbatch;
    End If;
    Return(v_Batch);
  End;

  Function Zl_Getfirst
  (
    配药id_In In Number,
    科室id_In In Number
  ) Return Number As
    n_First  Number;
    n_科室id Number;
    Cursor c_优先级 Is
      Select 科室id, 配药类型, 优先级, 频次
      From 输液药品优先级
      Where (科室id = 科室id_In Or 科室id = 0)
      Order By 科室id, 优先级 Desc;
  
    r_优先级 c_优先级%RowType;
  Begin
    n_First := 0;
    For r_优先级 In c_优先级 Loop
      If n_科室id <> 0 And r_优先级.科室id = 0 Then
        Exit;
      End If;
      n_科室id := r_优先级.科室id;
    
      For r_配药记录 In (Select Distinct d.配药类型, e.执行频次
                     From 输液配药记录 A, 输液配药内容 B, 药品收发记录 C, 输液药品属性 D, 病人医嘱记录 E
                     Where a.医嘱id = e.Id And a.Id = b.记录id And b.收发id = c.Id And c.药品id = d.药品id And a.Id = 配药id_In) Loop
        If Instr(r_配药记录.配药类型, r_优先级.配药类型, 1) > 0 And (Instr(r_优先级.频次, r_配药记录.执行频次, 1) > 0 Or r_优先级.频次 = '所有频次') Then
          n_First := r_优先级.优先级;
          Exit;
        End If;
      End Loop;
    End Loop;
  
    If n_First = 0 Then
      n_First := 999;
    End If;
    Return(n_First);
  End;
Begin
  n_Count          := 0;
  v_医嘱类型       := Zl_To_Number(Nvl(zl_GetSysParameter('医嘱类型', 1345), 1));
  v_输液总量       := Zl_To_Number(Nvl(zl_GetSysParameter('同批次输液总量', 1345), 0));
  v_大输液剂型     := Nvl(zl_GetSysParameter('大输液药品剂型', 1345), '');
  v_大输液给药途径 := Nvl(zl_GetSysParameter('输液给药途径', 1345), '');
  v_来源科室       := Nvl(zl_GetSysParameter('来源科室', 1345), '');
  v_保持上次批次   := Zl_To_Number(Nvl(zl_GetSysParameter('保持上次批次', 1345), 0));
  n_Tpn处置方式    := Zl_To_Number(Nvl(zl_GetSysParameter('静脉营养药物处置方式', 1345), 0));
  n_打包药品批次   := Zl_To_Number(Nvl(zl_GetSysParameter('单个药品，不予配置药品及根据给药时间没有配药批次的输液单默认为0批次并打包', 1345), 0));
  n_特殊药品批次   := Zl_To_Number(Nvl(zl_GetSysParameter('特殊药品按药品类型指定批次', 1345), 0));
  n_自动排批       := Zl_To_Number(Nvl(zl_GetSysParameter('启动自动排批', 1345), 0));
  n_备用批次       := Zl_To_Number(Nvl(zl_GetSysParameter('当天发送的医嘱产生的输液单全部到备用批次', 1345), 0));
  v_医嘱ids        := 医嘱id_In;
  v_当前病人       := '';
  n_发送次数       := 0;

  --取流通业务精度位数
  --类别:1-药品 2-卫材
  --内容：2-零售价 4-金额
  --单位：药品:1-售价 5-金额单位
  Select 精度 Into n_流通金额小数 From 药品卫材精度 Where 类别 = 1 And 内容 = 4 And 单位 = 5;

  Select Trunc(Sysdate) Into v_Currdate From Dual;

  Select Max(Nvl(批次, 0)) + 1 Into v_Maxbatch From 配药工作批次;

  --检查当前病人的医嘱是否有今天需要执行的输液单是锁定状态的
  If Instr(v_医嘱ids, ',') = 0 Then
    v_Tansid := v_医嘱ids;
  Else
    v_Tansid := Substr(v_Tmp, 1, Instr(v_医嘱ids, ',') - 1);
  End If;

  Select Count(ID)
  Into n_Num
  From 输液配药记录
  Where 是否锁定 = 1 And 执行时间 Between Trunc(v_Currdate) And Trunc(v_Currdate + 1) - 1 / 24 / 60 / 60 And
        医嘱id In
        (Select 相关id
         From 病人医嘱记录
         Where 病人id = (Select 病人id From 病人医嘱记录 Where 相关id = v_Tansid And Rownum < 2) And (诊疗类别 = '5' Or 诊疗类别 = '6')) And
        Rownum < 2;

  If n_Num > 0 Then
    Select 姓名
    Into v_当前病人
    From 输液配药记录
    Where 是否锁定 = 1 And 执行时间 Between Trunc(v_Currdate) And Trunc(v_Currdate + 1) - 1 / 24 / 60 / 60 And
          医嘱id In
          (Select 相关id
           From 病人医嘱记录
           Where 病人id = (Select 病人id From 病人医嘱记录 Where 相关id = v_Tansid And Rownum < 2) And (诊疗类别 = '5' Or 诊疗类别 = '6')) And
          Rownum < 2;
    Raise Err_Item;
  End If;

  --先将原收发记录的序号增大，新的收发记录产生后再删除
  --Update 药品收发记录
  --Set 序号 = 序号 + 10000
  --Where ID In (Select \*+rule *\
  --             Distinct c.Id
  --             From 病人医嘱记录 A, 病人医嘱发送 B, 药品收发记录 C, 住院费用记录 D, Table(f_Num2list(医嘱id_In)) F
  --             Where a.Id = b.医嘱id And c.费用id = d.Id And a.Id = d.医嘱序号 And b.No = c.No And b.执行部门id + 0 = 部门id_In And
  --                   c.单据 = 9 And c.审核日期 Is Null And a.相关id = f.Column_Value And b.发送号 = 发送号_In And c.序号 < 10000);

  For v_医嘱记录 In c_医嘱记录 Loop
    v_Continue := 1;
    n_病人id   := v_医嘱记录.病人id;
    n_科室id   := v_医嘱记录.病人科室id;
  
    Select Count(1)
    Into v_Continue
    From 病人医嘱记录 A, 输液不配置药品 B, 住院费用记录 C
    Where c.收费细目id = b.药品id And c.医嘱序号 = a.Id And a.相关id = v_医嘱记录.相关id;
    If v_Continue = 0 Then
      v_Continue := 1;
    Else
      v_Continue := 0;
    End If;
  
    --参数控制产生输液单
    If (v_医嘱类型 = 1 And v_医嘱记录.医嘱类型 <> 1) Or (v_医嘱类型 = 2 And v_医嘱记录.医嘱类型 <> 2) Then
      v_Continue := 0;
    End If;
  
    If Not v_大输液给药途径 Is Null Then
      If Instr(',' || v_大输液给药途径 || ',', ',' || v_医嘱记录.给药途径 || ',') = 0 Then
        v_Continue := 0;
      End If;
    End If;
  
    If Not v_来源科室 Is Null Then
      If Instr(',' || v_来源科室 || ',', ',' || v_医嘱记录.病人科室id || ',') = 0 Then
        v_Continue := 0;
      End If;
    End If;
  
    v_药品类型 := Null;
    For r_药品类型 In (Select Decode(Nvl(d.抗生素, 0), 0, Decode(Nvl(d.是否肿瘤药, 0), 0, '', '肿瘤药'), '抗生素') 药品类型
                   From 病人医嘱记录 A, 药品规格 B, 住院费用记录 C, 药品特性 D
                   Where c.收费细目id = b.药品id And b.药名id = d.药名id And c.医嘱序号 = a.Id And a.相关id = v_医嘱记录.相关id) Loop
      If r_药品类型.药品类型 Is Not Null Then
        v_药品类型 := r_药品类型.药品类型;
      End If;
    End Loop;
  
    If v_药品类型 Is Null Then
      If v_医嘱记录.是否tpn = 2 Then
        v_药品类型 := '营养药';
      End If;
    End If;
  
    If v_Continue = 1 Then
      v_Old相关id := v_New相关id;
      v_相关id    := v_医嘱记录.相关id;
      v_New相关id := v_相关id;
      v_发送号    := v_医嘱记录.发送号;
      v_序号      := 0;
    
      If v_Continue = 1 Then
        --v_Count := Zl_Gettransexenumber(v_医嘱记录.开始执行时间, v_医嘱记录.首次时间, v_医嘱记录.末次时间, v_医嘱记录.频率间隔, v_医嘱记录.间隔单位, v_医嘱记录.执行时间方案);
        Select Count(医嘱id)
        Into v_Count
        From 医嘱执行时间
        Where 医嘱id = v_医嘱记录.相关id And 发送号 = v_医嘱记录.发送号;
      
        v_Nodosage := 0;
      
        For I In 1 .. v_Count Loop
          Select 输液配药记录_Id.Nextval Into v_配药id From Dual;
          v_序号 := v_序号 + 1;
        
          If I > 1 Then
            --从医嘱执行时间表中取医嘱的执行时间
            Select 要求时间
            Into v_执行时间
            From 医嘱执行时间
            Where 医嘱id = v_医嘱记录.相关id And 发送号 = v_医嘱记录.发送号 And 要求时间 > v_执行时间 And Rownum = 1
            Order By 要求时间;
          Else
            Select Min(要求时间)
            Into v_执行时间
            From 医嘱执行时间
            Where 医嘱id = v_医嘱记录.相关id And 发送号 = v_医嘱记录.发送号 And Rownum = 1
            Order By 要求时间;
          End If;
        
          v_批次 := 0;
        
          If d_Old执行时间 <> Trunc(v_执行时间) Or d_Old执行时间 Is Null Then
            b_Change := True;
          End If;
        
          If b_Change = True Then
            If d_Old执行时间 <> Trunc(v_执行时间) Or d_Old执行时间 Is Null Then
              d_Old执行时间 := v_执行时间;
            
              Select Count(Distinct a.摆药单号)
              Into n_摆药单
              From 输液配药记录 A
              Where a.医嘱id In (Select ID From 病人医嘱记录 Where 病人id = v_医嘱记录.病人id And 相关id Is Null) And
                    a.执行时间 Between Trunc(v_执行时间 - 1) And Trunc(v_执行时间) - 1 / 24 / 60 / 60 And 操作状态 >= 2 And 操作状态 < 9;
            
              If n_摆药单 > 1 Then
                Update 输液配药记录
                Set 是否调整批次 = 1
                Where 医嘱id In (Select ID From 病人医嘱记录 Where 病人id = n_病人id) And
                     
                      执行时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
                b_Change := False;
              
              End If;
            End If;
          End If;
        
          If b_Change = True Then
            n_病人id := v_医嘱记录.病人id;
            Select Count(ID)
            
            Into n_Sum
            From 输液配药记录
            Where 医嘱id = v_医嘱记录.相关id And 执行时间 Between Trunc(v_执行时间 - 1) And Trunc(v_执行时间) - 1 / 24 / 60 / 60;
            If n_Sum = 0 Then
              Update 输液配药记录
              Set 是否调整批次 = 1
              Where 医嘱id In (Select ID From 病人医嘱记录 Where 病人id = n_病人id) And
                   
                    执行时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
              b_Change := False;
            
            End If;
          
            If b_Change = True Then
              --检查输液单是否调整到打包状态
              Select Count(a.Id)
              Into n_Sum
              From 输液配药记录 A, 输液配药内容 B, 药品收发记录 C
              Where a.Id = b.记录id And b.收发id = c.Id And
                    a.医嘱id In (Select ID
                               From 病人医嘱记录
                               Where 病人id = (Select 病人id From 病人医嘱记录 Where ID = v_医嘱记录.相关id And Rownum < 2)) And
                    a.执行时间 Between Trunc(v_执行时间 - 1) And Trunc(v_执行时间) - 1 / 24 / 60 / 60 And a.打包时间 Is Not Null;
              If n_Sum <> 0 Then
                Update 输液配药记录
                Set 是否调整批次 = 1
                Where 医嘱id In (Select ID From 病人医嘱记录 Where 病人id = n_病人id) And 执行时间 Between Trunc(v_执行时间) And
                      Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
                b_Change := False;
              End If;
            
              Select Count(医嘱id)
              Into n_Cur
              From 医嘱执行时间
              Where 医嘱id = v_医嘱记录.相关id And 要求时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60;
            
              Select Count(医嘱id)
              Into n_Sum
              From 医嘱执行时间
              Where 医嘱id = v_医嘱记录.相关id And 要求时间 Between Trunc(v_执行时间 - 1) And Trunc(v_执行时间) - 1 / 24 / 60 / 60;
            
              If n_Sum <> n_Cur Then
                Update 输液配药记录
                Set 是否调整批次 = 1
                Where 医嘱id In (Select ID From 病人医嘱记录 Where 病人id = n_病人id) And 执行时间 Between Trunc(v_执行时间) And
                      Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
                b_Change := False;
              End If;
            End If;
          End If;
        
          If v_时间串 <> Trunc(Sysdate) || ';false\' Or v_时间串 Is Null Then
            If Trunc(v_执行时间) = Trunc(Sysdate) Then
              If b_Change = False Then
                v_时间串 := Trunc(v_执行时间) || ';false\';
              Else
                v_时间串 := Trunc(v_执行时间) || ';true\';
              End If;
            End If;
          End If;
        
          If v_时间串1 <> Trunc(Sysdate + 1) || ';false\' Or v_时间串1 Is Null Then
            If Trunc(v_执行时间) = Trunc(Sysdate + 1) Then
              If b_Change = False Then
                v_时间串1 := Trunc(v_执行时间) || ';false\';
              Else
                v_时间串1 := Trunc(v_执行时间) || ';true\';
              End If;
            End If;
          End If;
        
          If v_药品类型 Is Null Or n_特殊药品批次 = 0 Then
            v_批次 := Zl_Getpivaworkbatch(v_执行时间, Sysdate);
          Else
            --药品类型不为空，直接根据药品类型匹配批次
            v_批次 := Zl_Getpivaworkbatch(v_执行时间, Sysdate, v_药品类型);
          End If;
        
          Select Count(医嘱id)
          Into n_发送次数
          From 医嘱执行时间
          Where 医嘱id = v_医嘱记录.相关id And 要求时间 <= v_执行时间
          Order By 要求时间;
        
          If n_发送次数 > 99 Then
            n_发送次数 := Mod(n_发送次数, 99);
          End If;
        
          If Length(v_医嘱记录.相关id) > 9 Then
            If n_发送次数 < 10 Then
              Select '91' || Substr(To_Char(v_医嘱记录.相关id), Length(v_医嘱记录.相关id) - 8) || To_Char(v_医嘱记录.相关id) || '0' ||
                      To_Char(n_发送次数)
              Into v_Maxno
              From Dual;
            Else
              Select '91' || Substr(To_Char(v_医嘱记录.相关id), Length(v_医嘱记录.相关id) - 8) || To_Char(v_医嘱记录.相关id) ||
                      To_Char(n_发送次数)
              Into v_Maxno
              From Dual;
            End If;
          Else
            If n_发送次数 < 10 Then
              Select '91' || Substr('000000000', Length(v_医嘱记录.相关id) + 1) || To_Char(v_医嘱记录.相关id) || '0' ||
                      To_Char(n_发送次数)
              Into v_Maxno
              From Dual;
            Else
              Select '91' || Substr('000000000', Length(v_医嘱记录.相关id) + 1) || To_Char(v_医嘱记录.相关id) || To_Char(n_发送次数)
              Into v_Maxno
              From Dual;
            End If;
          End If;
          n_调整批次 := 0;
          If b_Change = False Then
            n_调整批次 := 1;
          End If;
        
          If v_批次 <> 0 Then
            Select Nvl(Max(打包), 0), Max(药品类型)
            Into n_打包, v_配药类型
            From 配药工作批次
            Where 批次 = v_批次 And 配置中心id = 部门id_In;
          End If;
        
          If (Trunc(v_执行时间) <= v_Currdate Or n_打包 <> 0) And v_配药类型 Is Null Then
            n_是否打包     := 1;
            d_手工打包时间 := Null;
          Else
            n_是否打包     := 0;
            d_手工打包时间 := Null;
          End If;
        
          --如果是TPN不管其他条件如何都设置为配置
          If v_医嘱记录.是否tpn = 2 Then
            n_是否打包     := 0;
            d_手工打包时间 := Null;
          End If;
        
          If v_批次 = 0 Then
            n_是否打包 := 1;
          End If;
          --产生配药记录
          Insert Into 输液配药记录
            (ID, 部门id, 序号, 姓名, 性别, 年龄, 住院号, 床号, 病人病区id, 病人科室id, 执行时间, 医嘱id, 发送号, 配药批次, 瓶签号, 是否调整批次, 是否打包, 打包时间, 操作状态,
             操作人员, 操作时间)
          Values
            (v_配药id, 部门id_In, v_序号, v_医嘱记录.姓名, v_医嘱记录.性别, v_医嘱记录.年龄, v_医嘱记录.住院号, v_医嘱记录.床号, v_医嘱记录.病人病区id,
             v_医嘱记录.病人科室id, v_执行时间, v_医嘱记录.相关id, v_医嘱记录.发送号, v_批次, v_Maxno, n_调整批次, n_是否打包, d_手工打包时间, 1, 核查人_In, 核查时间_In);
        
          Insert Into 输液配药状态 (配药id, 操作类型, 操作人员, 操作时间) Values (v_配药id, 1, 核查人_In, 核查时间_In);
        
          For v_单个医嘱记录 In c_单个医嘱记录 Loop
            n_医嘱id   := v_单个医嘱记录.医嘱id;
            n_累计数量 := 0;
            n_剩余数量 := 0;
          
            Select Sum(c.实际数量)
            Into n_Sum
            From 病人医嘱记录 A, 病人医嘱发送 B, 药品收发记录 C, 住院费用记录 D
            Where a.Id = b.医嘱id And c.费用id = d.Id And a.Id = d.医嘱序号 And b.No = c.No And b.执行部门id + 0 = 部门id_In And
                  c.单据 = 9 And c.审核日期 Is Null And a.Id = n_医嘱id And b.发送号 = v_医嘱记录.发送号 And c.序号 < 1000;
          
            --产生配药记录对应的药品记录
            For v_收发记录 In c_收发记录 Loop
              If v_收发记录.是否不予配置 = 1 Then
                v_Nodosage := 1;
              End If;
            
              Select 药品收发记录_Id.Nextval Into n_Lngid From Dual;
              n_累计数量 := n_累计数量 + v_收发记录.数量;
            
              If n_剩余数量 = 0 Then
                n_剩余数量 := n_Sum / v_Count;
              End If;
              n_单次数量 := n_Sum / v_Count;
            
              If n_累计数量 >= n_Sum / v_Count * I Then
                n_Count := n_Count + 1;
                Insert Into 药品收发记录
                  (ID, 记录状态, 单据, NO, 序号, 库房id, 供药单位id, 入出类别id, 对方部门id, 入出系数, 药品id, 批次, 产地, 批号, 生产日期, 效期, 付数, 填写数量, 实际数量,
                   成本价, 成本金额, 扣率, 零售价, 零售金额, 差价, 摘要, 填制人, 填制日期, 配药人, 配药日期, 审核人, 审核日期, 价格id, 费用id, 单量, 频次, 用法, 外观, 灭菌日期,
                   灭菌效期, 产品合格证, 发药方式, 发药窗口, 领用人, 批准文号, 汇总发药号, 注册证号, 库房货位, 商品条码, 内部条码, 核查人, 核查日期, 签到确认人, 签到时间)
                  Select n_Lngid, 记录状态, 单据, NO, n_Count + 1000, 库房id, 供药单位id, 入出类别id, 对方部门id, 入出系数, 药品id, 批次, 产地, 批号,
                         生产日期, 效期, 付数, n_剩余数量, n_剩余数量, 成本价, Round(成本价 * n_剩余数量, n_流通金额小数), 扣率, 零售价,
                         Round(零售价 * n_剩余数量, n_流通金额小数), Round(差价 * (实际数量 / n_剩余数量), n_流通金额小数), '复制', 填制人, 填制日期, 配药人,
                         配药日期, 审核人, 审核日期, 价格id, 费用id, 单量, 频次, 用法, 外观, 灭菌日期, 灭菌效期, 产品合格证, 发药方式, 发药窗口, 领用人, 批准文号, 汇总发药号,
                         注册证号, 库房货位, 商品条码, 内部条码, 核查人, 核查日期, 签到确认人, 签到时间
                  From 药品收发记录
                  Where ID = v_收发记录.收发id;
                  
                 Zl_未审药品记录_Insert(n_Lngid);
              
                Insert Into 输液配药内容 (记录id, 收发id, 数量) Values (v_配药id, n_Lngid, n_剩余数量);
              
                n_剩余数量 := 0;
                Exit;
              Elsif n_累计数量 > (n_Sum / v_Count * (I - 1)) Then
                n_Count    := n_Count + 1;
                n_填写数量 := n_累计数量 - (n_Sum / v_Count * (I - 1)) - (n_单次数量 - n_剩余数量);
                Insert Into 药品收发记录
                  (ID, 记录状态, 单据, NO, 序号, 库房id, 供药单位id, 入出类别id, 对方部门id, 入出系数, 药品id, 批次, 产地, 批号, 生产日期, 效期, 付数, 填写数量, 实际数量,
                   成本价, 成本金额, 扣率, 零售价, 零售金额, 差价, 摘要, 填制人, 填制日期, 配药人, 配药日期, 审核人, 审核日期, 价格id, 费用id, 单量, 频次, 用法, 外观, 灭菌日期,
                   灭菌效期, 产品合格证, 发药方式, 发药窗口, 领用人, 批准文号, 汇总发药号, 注册证号, 库房货位, 商品条码, 内部条码, 核查人, 核查日期, 签到确认人, 签到时间)
                  Select n_Lngid, 记录状态, 单据, NO, n_Count + 1000, 库房id, 供药单位id, 入出类别id, 对方部门id, 入出系数, 药品id, 批次, 产地, 批号,
                         生产日期, 效期, 付数, n_填写数量, n_填写数量, 成本价, Round(成本价 * n_填写数量, n_流通金额小数), 扣率, 零售价,
                         Round(零售价 * n_填写数量, n_流通金额小数), Round(差价 * (实际数量 / n_填写数量), n_流通金额小数), '复制', 填制人, 填制日期, 配药人,
                         配药日期, 审核人, 审核日期, 价格id, 费用id, 单量, 频次, 用法, 外观, 灭菌日期, 灭菌效期, 产品合格证, 发药方式, 发药窗口, 领用人, 批准文号, 汇总发药号,
                         注册证号, 库房货位, 商品条码, 内部条码, 核查人, 核查日期, 签到确认人, 签到时间
                  From 药品收发记录
                  Where ID = v_收发记录.收发id;
                 
                Zl_未审药品记录_Insert(n_Lngid);
              
                Insert Into 输液配药内容 (记录id, 收发id, 数量) Values (v_配药id, n_Lngid, n_填写数量);
              
                n_剩余数量 := n_剩余数量 - n_填写数量;
              End If;
            End Loop;
          End Loop;
          n_优先级 := Zl_Getfirst(v_配药id, v_医嘱记录.病人科室id);
          Update 输液配药记录 Set 优先级 = n_优先级 Where ID = v_配药id;
        
        End Loop;
      
        For v_收发记录 In c_原始收发记录 Loop
          n_单据 := v_收发记录.单据;
        
          v_No := v_收发记录.No;
          Delete From 药品收发记录 Where ID = v_收发记录.收发id;
        End Loop;
      
        --单个药品或者不予配置的药品默认为0批次
        Select Count(收发id) Into n_Row From 输液配药内容 Where 记录id = v_配药id;
        If (v_Nodosage = 1 Or n_Row = 1) And n_打包药品批次 = 1 Then
          Update 输液配药记录
          Set 配药批次 = 0, 是否打包 = 1
          Where 医嘱id = v_医嘱记录.相关id And 发送号 = v_医嘱记录.发送号 And 操作状态 < 2;
        End If;
        --如果存在“不予配置”属性的药品，也设置为打包
        If v_Nodosage = 1 Then
          Update 输液配药记录
          Set 是否打包 = 1
          Where 医嘱id = v_医嘱记录.相关id And 发送号 = v_医嘱记录.发送号 And 操作状态 < 2;
        End If;
      End If;
    End If;
  End Loop;

  For v_收发记录 In (Select ID From 药品收发记录 Where 序号 < 1000 And 单据 = n_单据 And NO = v_No) Loop
    n_Count := n_Count + 1;
    Update 药品收发记录 Set 序号 = n_Count + 1000, 摘要 = '复制' Where ID = v_收发记录.Id;
  End Loop;

  Update 药品收发记录
  Set 序号 = 序号 - 1000, 摘要 = '医嘱发送'
  Where 摘要 = '复制' And 序号 > 1000 And 单据 = n_单据 And NO = v_No;

  If n_备用批次 = 1 Then
  
    Select Count(a.Id)
    Into n_Sum
    From 输液配药记录 A, 病人医嘱发送 B
    Where a.医嘱id = b.医嘱id And a.发送号 = b.发送号 And
          a.医嘱id In (Select ID From 病人医嘱记录 Where 病人id = n_病人id And 相关id Is Null) And b.发送时间 Between Trunc(Sysdate) And
          Trunc(Sysdate + 1) - 1 / 24 / 60 / 60 And a.执行时间 Between Trunc(Sysdate) And
          Trunc(Sysdate + 1) - 1 / 24 / 60 / 60 And 操作状态 < 9;
    If n_Sum <> 0 Then
      b_Change  := False;
      v_时间串1 := Trunc(Sysdate + 1) || ';false\';
    
      Update 输液配药记录
      Set 是否调整批次 = 1
      Where 医嘱id In (Select ID From 病人医嘱记录 Where 病人id = n_病人id) And 执行时间 Between Trunc(Sysdate + 1) And
            Trunc(Sysdate + 2) - 1 / 24 / 60 / 60 And 操作状态 < 2;
    End If;
  End If;
  If v_时间串 Is Null Then
    v_时间串 := v_时间串1;
  Else
    v_时间串 := v_时间串 || v_时间串1;
  End If;

  While v_时间串 Is Not Null Loop
    --分解单据ID串
    v_Fields   := Substr(v_时间串, 1, Instr(v_时间串, '\') - 1);
    v_时间值   := Substr(v_Fields, 1, Instr(v_Fields, ';') - 1);
    v_是否改变 := Substr(v_Fields, Instr(v_Fields, ';') + 1);
  
    v_时间串 := Replace('\' || v_时间串, '\' || v_Fields || '\');
  
    If v_是否改变 = 'true' Then
      b_Change := True;
    Else
      b_Change := False;
    End If;
  
    If b_Change = True Then
      Select Count(医嘱id)
      Into n_Cur
      From (Select Distinct a.要求时间, a.医嘱id
             From 医嘱执行时间 A, 输液配药记录 B
             Where a.要求时间 = b.执行时间 And a.医嘱id = b.医嘱id And a.要求时间 Between Trunc(v_时间值) And
                   Trunc(v_时间值 + 1) - 1 / 24 / 60 / 60 And
                   a.医嘱id In (Select ID From 病人医嘱记录 Where 病人id = n_病人id And 相关id Is Null));
    
      Select Count(医嘱id)
      Into n_Sum
      From (Select Distinct a.要求时间, a.医嘱id
             From 医嘱执行时间 A, 输液配药记录 B
             Where a.要求时间 = b.执行时间 And a.医嘱id = b.医嘱id And a.要求时间 Between Trunc(v_时间值 - 1) And
                   Trunc(v_时间值) - 1 / 24 / 60 / 60 And
                   a.医嘱id In (Select ID From 病人医嘱记录 Where 病人id = n_病人id And 相关id Is Null));
    
      If n_Cur <> n_Sum Then
        Update 输液配药记录
        Set 是否调整批次 = 1
        Where 医嘱id In (Select ID From 病人医嘱记录 Where 病人id = n_病人id) And 执行时间 Between Trunc(v_时间值) And
              Trunc(v_时间值 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
        b_Change := False;
      End If;
    End If;
  
    If v_保持上次批次 = 1 And b_Change = True Then
      For v_输液单记录 In c_输液单记录 Loop
        Select Distinct 配药批次
        Into v_批次
        From 输液配药记录 A, 输液配药内容 B, 药品收发记录 C
        Where a.Id = b.记录id And b.收发id = c.Id And a.医嘱id = v_输液单记录.医嘱id And
              To_Char(a.执行时间, 'hh24:mi:ss') = To_Char(v_输液单记录.执行时间, 'hh24:mi:ss') And
              a.执行时间 Between Trunc(v_输液单记录.执行时间 - 1) And Trunc(v_输液单记录.执行时间) - 1 / 24 / 60 / 60 And Rownum = 1;
      
        Update 输液配药记录
        Set 是否确认调整 = 0,是否调整批次 = 0
        Where 医嘱id In (Select ID From 病人医嘱记录 Where 病人id = n_病人id) And 执行时间 Between Trunc(v_输液单记录.执行时间) And
              Trunc(v_输液单记录.执行时间 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
      
        If v_输液单记录.配药批次 <> v_批次 Then
          Update 输液配药记录 Set 配药批次 = v_批次 Where ID = v_输液单记录.Id;
          Select Nvl(Max(打包), 0) Into n_打包 From 配药工作批次 Where 批次 = v_批次 And 配置中心id = 部门id_In;
          If n_打包 <> 0 Then
            Update 输液配药记录 Set 是否打包 = n_打包 Where ID = v_输液单记录.Id;
          Else
            Select Nvl(Max(打包), 0)
            Into n_打包
            From 配药工作批次
            Where 批次 = v_输液单记录.配药批次 And 配置中心id = 部门id_In;
          
            If n_打包 <> 0 Then
              Update 输液配药记录 Set 是否打包 = 0 Where ID = v_输液单记录.Id;
            End If;
          End If;
        End If;
      End Loop;
    End If;
  
    If n_自动排批 = 1 And (b_Change = False Or v_保持上次批次 = 0) Then
      For v_输液单记录 In c_输液单记录 Loop
        v_批次 := Zl_Getpivaworkbatch(v_输液单记录.执行时间, v_输液单记录.发送时间);
        Update 输液配药记录 Set 配药批次 = v_批次 Where ID = v_输液单记录.Id;
      End Loop;
      Zl_输液配药记录_自动排批(n_病人id, n_科室id, 部门id_In, v_时间值);
    End If;
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]病人' || v_当前病人 || '在输液配置中心有被锁定的输液单，发送失败！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_输液配药记录_核查;
/

--110624:刘涛,2018-01-23,盘点增加修改人信息
--109990:刘涛,2018-01-12,药品批号对照修改
Create Or Replace Procedure Zl_药品盘点_Insert
(
  No_In         In 药品收发记录.No%Type,
  序号_In       In 药品收发记录.序号%Type,
  库房id_In     In 药品收发记录.库房id%Type,
  批次_In       In 药品收发记录.批次%Type,
  入出类别id_In In 药品收发记录.入出类别id%Type,
  入出系数_In   In 药品收发记录.入出系数%Type,
  药品id_In     In 药品收发记录.药品id%Type,
  帐面数量_In   In 药品收发记录.填写数量%Type,
  实盘数量_In   In 药品收发记录.扣率%Type,
  数量差_In     In 药品收发记录.实际数量%Type,
  售价_In       In 药品收发记录.零售价%Type,
  金额差_In     In 药品收发记录.零售金额%Type,
  差价差_In     In 药品收发记录.差价%Type,
  填制人_In     In 药品收发记录.填制人%Type,
  填制日期_In   In 药品收发记录.填制日期%Type,
  摘要_In       In 药品收发记录.摘要%Type := Null,
  产地_In       In 药品收发记录.产地%Type := Null,
  批号_In       In 药品收发记录.批号%Type := Null,
  效期_In       In 药品收发记录.效期%Type := Null,
  盘点时间_In   In 药品收发记录.频次%Type := Null,
  库存金额_In   In 药品收发记录.成本价%Type := Null,
  库存差价_In   In 药品收发记录.成本金额%Type := Null,
  成本价_In     In 药品收发记录.单量%Type := Null,
  批准文号_In   In 药品收发记录.批准文号%Type := Null,
  新批次_In     In Number := 0,
  库房货位_In   In 药品收发记录.库房货位%Type := Null,
  原产地_In     In 药品收发记录.原产地%Type := Null,
  盘点模式_In   In 药品收发记录.单据%Type := Null, 
  修改人_In     In 药品收发记录.修改人%Type,
  修改日期_In   In 药品收发记录.修改日期%Type
) Is
  v_Lngid        Number(18);
  n_上次供应商id 药品库存.上次供应商id%Type;
  d_上次生产日期 药品库存.上次生产日期%Type;
  n_批次         药品收发记录.批次%Type;
  n_分批属性     Number(1);
Begin
  Select 药品收发记录_Id.Nextval Into v_Lngid From Dual;

  Begin
    Select 上次供应商id, 上次生产日期
    Into n_上次供应商id, d_上次生产日期
    From 药品库存
    Where 性质 = 1 And 库房id = 库房id_In And 药品id = 药品id_In And Nvl(批次, 0) = Nvl(批次_In, 0);
  Exception
    When Others Then
      n_上次供应商id := Null;
      d_上次生产日期 := Null;
  End;

  If 批次_In = -1 Then
    --如果批次_IN为-1,则表示新产生一个批次药品 
    --判断分批属性，根据分批属性生成对应批次 
    n_分批属性 := Zl_Fun_Getbatchpro(库房id_In, 药品id_In);
  
    If n_分批属性 = 1 Then
      n_批次 := Zl_Fun_Getbatchnum(药品id_In, 产地_In, 批号_In, 成本价_In, 售价_In, v_Lngid, n_上次供应商id);
    Else
      n_批次 := 0;
    End If;
  Else
    n_批次 := 批次_In;
  End If;

  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 入出系数, 药品id, 批次, 产地,原产地, 批号, 效期, 填写数量, 扣率, 实际数量, 零售价, 零售金额, 差价, 摘要, 填制人, 填制日期, 频次,
     成本价, 成本金额, 单量, 批准文号, 供药单位id, 生产日期, 发药方式, 库房货位,用法, 修改人, 修改日期)
  Values
    (v_Lngid, 1, 12, No_In, 序号_In, 库房id_In, 入出类别id_In, 入出系数_In, 药品id_In, n_批次, 产地_In,原产地_In, 批号_In, 效期_In, 帐面数量_In, 实盘数量_In,
     数量差_In, 售价_In, 金额差_In, 差价差_In, 摘要_In, 填制人_In, 填制日期_In, 盘点时间_In, 库存金额_In, 库存差价_In, 成本价_In, 批准文号_In, n_上次供应商id,
     d_上次生产日期, 新批次_In, 库房货位_In,盘点模式_In, 修改人_In, 修改日期_In);
  
  Zl_未审药品记录_Insert(v_Lngid);
  
  If 入出系数_In = -1 Then
    --入出系数=-1的需要下库存
    Zl_药品库存_Update(v_Lngid, 0);
  
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品盘点_Insert;
/

--110624:刘涛,2018-01-23,盘点增加修改信息
--109990:刘涛,2018-01-12,药品批号对照
Create Or Replace Procedure Zl_药品盘点记录单_Insert
(
  No_In         In 药品收发记录.No%Type,
  序号_In       In 药品收发记录.序号%Type,
  库房id_In     In 药品收发记录.库房id%Type,
  批次_In       In 药品收发记录.批次%Type,
  入出类别id_In In 药品收发记录.入出类别id%Type,
  入出系数_In   In 药品收发记录.入出系数%Type,
  药品id_In     In 药品收发记录.药品id%Type,
  帐面数量_In   In 药品收发记录.填写数量%Type,
  实盘数量_In   In 药品收发记录.扣率%Type,
  数量差_In     In 药品收发记录.实际数量%Type,
  售价_In       In 药品收发记录.零售价%Type,
  金额差_In     In 药品收发记录.零售金额%Type,
  差价差_In     In 药品收发记录.差价%Type,
  填制人_In     In 药品收发记录.填制人%Type,
  填制日期_In   In 药品收发记录.填制日期%Type,
  摘要_In       In 药品收发记录.摘要%Type := Null,
  产地_In       In 药品收发记录.产地%Type := Null,
  批号_In       In 药品收发记录.批号%Type := Null,
  效期_In       In 药品收发记录.效期%Type := Null,
  盘点时间_In   In 药品收发记录.频次%Type := Null,
  库存金额_In   In 药品收发记录.成本价%Type := Null,
  库存差价_In   In 药品收发记录.成本金额%Type := Null,
  批准文号_In   In 药品收发记录.批准文号%Type := Null,
  成本价_In     In 药品收发记录.单量%Type := Null,
  库房货位_In   In 药品收发记录.库房货位%Type := Null,
  原产地_In     In 药品收发记录.原产地%Type := Null,
  修改人_In     In 药品收发记录.修改人%Type,
  修改日期_In   In 药品收发记录.修改日期%Type
) Is
  v_批次 药品收发记录.批次%Type;
Begin
  v_批次 := 批次_In;
  If v_批次 < 0 Then
    v_批次 := Zl_Fun_Getbatchnum(药品id_In, 产地_In, 批号_In, 成本价_In, 售价_In, 批次_In, Null);
  End If;

  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 入出系数, 药品id, 批次, 产地,原产地, 批号, 效期, 填写数量, 扣率, 实际数量, 零售价, 零售金额, 差价, 摘要, 填制人, 填制日期, 频次,
     成本价, 成本金额, 批准文号, 单量, 库房货位, 修改人, 修改日期)
  Values
    (药品收发记录_Id.Nextval, 1, 14, No_In, 序号_In, 库房id_In, 入出类别id_In, 入出系数_In, 药品id_In, v_批次, 产地_In,原产地_In, 批号_In, 效期_In, 帐面数量_In,
     实盘数量_In, 数量差_In, 售价_In, 金额差_In, 差价差_In, 摘要_In, 填制人_In, 填制日期_In, 盘点时间_In, 库存金额_In, 库存差价_In, 批准文号_In, 成本价_In, 
	 库房货位_In, 修改人_In, 修改日期_In);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品盘点记录单_Insert;
/

--110624:刘涛,2018-01-24,移库增加修改信息
--109990:刘涛,2018-01-12,药品批号对照修改
Create Or Replace Procedure Zl_药品移库_Insert
(
  No_In           In 药品收发记录.No%Type,
  序号_In         In 药品收发记录.序号%Type,
  库房id_In       In 药品收发记录.库房id%Type,
  对方部门id_In   In 药品收发记录.对方部门id%Type,
  药品id_In       In 药品收发记录.药品id%Type,
  批次_In         In 药品收发记录.批次%Type,
  填写数量_In     In 药品收发记录.填写数量%Type,
  实际数量_In     In 药品收发记录.实际数量%Type,
  成本价_In       In 药品收发记录.成本价%Type,
  成本金额_In     In 药品收发记录.成本金额%Type,
  零售价_In       In 药品收发记录.零售价%Type,
  零售金额_In     In 药品收发记录.零售金额%Type,
  差价_In         In 药品收发记录.差价%Type,
  填制人_In       In 药品收发记录.填制人%Type,
  产地_In         In 药品收发记录.产地%Type := Null,
  批号_In         In 药品收发记录.批号%Type := Null,
  效期_In         In 药品收发记录.效期%Type := Null,
  摘要_In         In 药品收发记录.摘要%Type := Null,
  填制日期_In     In 药品收发记录.填制日期%Type := Null,
  上次供应商id_In In 药品收发记录.供药单位id%Type := Null,
  批准文号_In     In 药品收发记录.批准文号%Type := Null,
  申领方式_In     In 药品收发记录.单量%Type := Null,
  结束时间_In     In 药品收发记录.频次%Type := Null,
  原产地_In       In 药品收发记录.原产地%Type := Null,
  修改人_In       In 药品收发记录.修改人%Type,
  修改日期_In     In 药品收发记录.修改日期%Type := Null
) Is
  v_Lngid        药品收发记录.Id%Type; --收发ID 
  n_出库收发id   药品收发记录.Id%Type; --出库库房收发id 
  v_入的类别id   药品收发记录.入出类别id%Type; --入出类别ID 
  v_出的类别id   药品收发记录.入出类别id%Type; --入出类别ID 
  v_批次         药品收发记录.批次%Type := Null; --主要针对入库中实行药库分批的药品 
  v_是否分批     Integer; --判断入库是否药库分批   1:分批；0：不分批 
  v_药库分批     Integer; --判断入库是否药库分批   1:分批；0：不分批 
  v_药房分批     Integer; --判断入库是否药库分批   1:分批；0：不分批 
  d_上次生产日期 药品库存.上次生产日期%Type;
Begin
  Select b.Id
  Into v_入的类别id
  From 药品单据性质 A, 药品入出类别 B
  Where a.类别id = b.Id And a.单据 = 6 And b.系数 = 1 And Rownum < 2;
  
  Select b.Id
  Into v_出的类别id
  From 药品单据性质 A, 药品入出类别 B
  Where a.类别id = b.Id And a.单据 = 6 And b.系数 = -1 And Rownum < 2;

  Begin
    Select 上次生产日期
    Into d_上次生产日期
    From 药品库存
    Where 性质 = 1 And 库房id = 库房id_In And 药品id = 药品id_In And Nvl(批次, 0) = Nvl(批次_In, 0);
  Exception
    When Others Then
      d_上次生产日期 := Null;
  End;
  Select 药品收发记录_Id.Nextval Into n_出库收发id From Dual;
  
  --产生出的那笔
  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 原产地,批号, 效期, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 零售金额, 差价, 摘要,
     填制人, 填制日期, 供药单位id, 批准文号, 生产日期, 单量, 频次, 修改人, 修改日期)
  Values
    (n_出库收发id, 1, 6, No_In, 序号_In, 库房id_In, 对方部门id_In, v_出的类别id, -1, 药品id_In, 批次_In, 产地_In, 原产地_In,批号_In, 效期_In, 填写数量_In,
     实际数量_In, 成本价_In, 成本金额_In, 零售价_In, 零售金额_In, 差价_In, 摘要_In, 填制人_In, 填制日期_In, 上次供应商id_In, 批准文号_In, d_上次生产日期, 申领方式_In,
     结束时间_In, 修改人_In, 修改日期_In);
  
  Zl_未审药品记录_Insert(n_出库收发id);
  
  --处理库存
  Zl_药品库存_Update(n_出库收发id, 0);
  
  Select Nvl(药库分批, 0), Nvl(药房分批, 0) Into v_药库分批, v_药房分批 From 药品规格 Where 药品id = 药品id_In;

  v_是否分批 := 0;
  If v_药房分批 = 0 Then
    If v_药库分批 = 1 Then
      Begin
        Select Distinct 0
        Into v_是否分批
        From 部门性质说明
        Where ((工作性质 Like '%药房') Or (工作性质 Like '制剂室')) And 部门id = 对方部门id_In;
      Exception
        When Others Then
          v_是否分批 := 1;
      End;
    End If;
  Else
    v_是否分批 := 1;
  End If;

  Select 药品收发记录_Id.Nextval Into v_Lngid From Dual;

  If v_是否分批 = 1 And Nvl(批次_In, 0) = 0 Then
    --入库分批且出库不分批 
    v_批次 := Zl_Fun_Getbatchnum(药品id_In, 产地_In, 批号_In, 成本价_In, 零售价_In, v_Lngid, 上次供应商id_In);
  Elsif v_是否分批 = 0 Then
    --入库不分批 
    v_批次 := 0;
  Elsif Nvl(批次_In, 0) <> 0 Then
    --入库分批且出库也分批 
    v_批次 := 批次_In;
  End If;
  
  --产生入的那笔
  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 原产地,批号, 效期, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 零售金额, 差价, 摘要,
     填制人, 填制日期, 供药单位id, 批准文号, 生产日期, 单量, 频次, 修改人, 修改日期)
  Values
    (v_Lngid, 1, 6, No_In, 序号_In + 1, 对方部门id_In, 库房id_In, v_入的类别id, 1, 药品id_In, v_批次, 产地_In,原产地_In, 批号_In, 效期_In, 填写数量_In,
     实际数量_In, 成本价_In, 成本金额_In, 零售价_In, 零售金额_In, 差价_In, 摘要_In, 填制人_In, 填制日期_In, 上次供应商id_In, 批准文号_In, d_上次生产日期, 申领方式_In,
     结束时间_In, 修改人_In, 修改日期_In);
  
  Zl_未审药品记录_Insert(v_Lngid);
  
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品移库_Insert;
/

--110624:刘涛,2018-01-23,其他入库增加修改信息
--109990:刘涛,2018-01-12,药品批号对照修改
Create Or Replace Procedure Zl_药品其他入库_Insert
(
  No_In         In 药品收发记录.No%Type,
  序号_In       In 药品收发记录.序号%Type,
  库房id_In     In 药品收发记录.库房id%Type,
  入出类别id_In In 药品收发记录.入出类别id%Type,
  药品id_In     In 药品收发记录.药品id%Type,
  实际数量_In   In 药品收发记录.实际数量%Type,
  成本价_In     In 药品收发记录.成本价%Type,
  成本金额_In   In 药品收发记录.成本金额%Type,
  零售价_In     In 药品收发记录.零售价%Type,
  零售金额_In   In 药品收发记录.零售金额%Type,
  差价_In       In 药品收发记录.差价%Type,
  填制人_In     In 药品收发记录.填制人%Type,
  填制日期_In   In 药品收发记录.填制日期%Type,
  摘要_In       In 药品收发记录.摘要%Type := Null,
  产地_In       In 药品收发记录.产地%Type := Null,
  批号_In       In 药品收发记录.批号%Type := Null,
  效期_In       In 药品收发记录.效期%Type := Null,
  生产日期_In   In 药品收发记录.生产日期%Type := Null,
  批准文号_In   In 药品收发记录.批准文号%Type := Null,
  外观_In       In 药品收发记录.外观%Type := Null,
  金额差_In     In 药品收发记录.零售金额%Type := Null,
  原产地_In       In 药品收发记录.原产地%Type := Null,
  修改人_In     In 药品收发记录.修改人%Type,
  修改日期_In   In 药品收发记录.修改日期%Type
) Is
  v_Lngid    药品收发记录.Id%Type; --收发ID 
  v_入出系数 药品收发记录.入出系数%Type;
  v_批次     药品收发记录.批次%Type := Null; --批次 
  v_药库分批 Integer; --是否药库分批    1:分批;0：不分批 
  v_药房分批 Integer; --是否药库分批    1:分批;0：不分批 
  v_时价分批 Number(1);

Begin

  If Not 批准文号_In Is Null And Not 产地_In Is Null Then
    Update 药品生产商对照 Set 批准文号 = 批准文号_In Where 药品id = 药品id_In And 厂家名称 = 产地_In;
  End If;
  If Sql%RowCount = 0 And Not 产地_In Is Null And Not 批准文号_In Is Null Then
    Insert Into 药品生产商对照 (药品id, 厂家名称, 批准文号) Values (药品id_In, 产地_In, 批准文号_In);
  End If;

  v_入出系数 := 1;
  Select 药品收发记录_Id.Nextval Into v_Lngid From Dual;
  Select Nvl(药库分批, 0), Nvl(药房分批, 0) Into v_药库分批, v_药房分批 From 药品规格 Where 药品id = 药品id_In;

  If v_药房分批 = 0 Then
    If v_药库分批 = 1 Then
      Begin
        Select Distinct 0
        Into v_药库分批
        From 部门性质说明
        Where ((工作性质 Like '%药房') Or (工作性质 Like '制剂室')) And 部门id = 库房id_In;
      Exception
        When Others Then
          v_药库分批 := 1;
      End;
    
      If v_药库分批 = 1 Then
        v_批次 := Zl_Fun_Getbatchnum(药品id_In, 产地_In, 批号_In, 成本价_In, 零售价_In, v_Lngid, Null);
      End If;
    End If;
  Else
    v_批次 := Zl_Fun_Getbatchnum(药品id_In, 产地_In, 批号_In, 成本价_In, 零售价_In, v_Lngid, Null);
  End If;

  Select Nvl(是否变价, 0) Into v_时价分批 From 收费项目目录 Where ID = 药品id_In;

  If v_时价分批 = 1 And v_批次 > 0 Then
    v_时价分批 := 1;
  Else
    v_时价分批 := 0;
  End If;

  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 入出系数, 药品id, 批次, 产地, 原产地,批号, 效期, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 零售金额, 差价, 摘要, 填制人,
     填制日期, 生产日期, 批准文号, 外观, 用法, 修改人, 修改日期)
  Values
    (v_Lngid, 1, 4, No_In, 序号_In, 库房id_In, 入出类别id_In, v_入出系数, 药品id_In, v_批次, 产地_In, 原产地_In,批号_In, 效期_In, 实际数量_In, 实际数量_In,
     成本价_In, 成本金额_In, 零售价_In, 零售金额_In, 差价_In, 摘要_In, 填制人_In, 填制日期_In, 生产日期_In, 批准文号_In, 外观_In,
     Decode(v_时价分批, 1, 金额差_In, Null), 修改人_In, 修改日期_In);
  
  Zl_未审药品记录_Insert(v_Lngid);
  
  --更新库存
  Zl_药品库存_Update(v_Lngid, 0);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品其他入库_Insert;
/

--109990:刘涛,2018-01-12,药品批号对照修改
Create Or Replace Function Zl_Fun_Getbatchnum
(
  药品id_In   药品批号对照.药品id%Type,
  生产厂家_In 药品批号对照.生产厂家%Type,
  批号_In     药品批号对照.批号%Type,
  成本价_In   药品批号对照.成本价%Type,
  售价_In     药品批号对照.售价%Type,
  新批次_In   药品批号对照.批次%Type,
  供应商ID_In   药品批号对照.供应商ID%Type
) Return Number Is
  --功能：药品入库产生入库记录时根据传递过来的参数找对应的批次
  --返回值：查询到的批次，如果批次>0则说明找到了批次,如果批次=0则说明没有找到
  --参数：
  --     生产厂家_in：入库传递过来的生产商
  --     批号_in：入库时录入的批号
  --     成本价_in 入库时的成本价
  --     售价_in  入库时的售价
  --     
  n_批次     药品批号对照.批次%Type;
  n_药库包装 药品规格.药库包装%Type;
  n_是否变价 收费项目目录.是否变价%Type;
  n_Count    Number(1);
Begin
  --只处理生产厂家和批号不为空的情况
  If 生产厂家_In Is Not Null And 批号_In Is Not Null Then
    Begin
      Select 批次
      Into n_批次
      From 药品批号对照
      Where 药品id = 药品id_In And Nvl(生产厂家, 'a') = Nvl(生产厂家_In, 'a') And Nvl(批号, 'b') = Nvl(批号_In, 'b') And 成本价 = 成本价_In And
            售价 = 售价_In And Nvl(供应商id, 0) = Nvl(供应商id_In, 0);
    Exception
      When Others Then
        n_批次 := 新批次_In;
      
        If n_批次 > 0 Then
          --检查有无重复记录
          Begin
            Select 1
            Into n_Count
            From 药品批号对照
            Where 药品id = 药品id_In And Nvl(生产厂家, 'a') = Nvl(生产厂家_In, 'a') And Nvl(批号, 'b') = Nvl(批号_In, 'b') And
                  批次 = n_批次;
          Exception
            When Others Then
              n_Count := 0;
          End;
          
          --没有重复记录才能插入
          If n_Count = 0 Then
            Insert Into 药品批号对照
              (药品id, 生产厂家, 批号, 批次, 成本价, 售价,供应商ID)
            Values
              (药品id_In, 生产厂家_In, 批号_In, 新批次_In, 成本价_In, 售价_In,供应商ID_In);
          End If;
        End If;
    End;
  End If;

  Return(n_批次);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Fun_Getbatchnum;
/

--119852:李业庆,2018-01-11,取价格时返回默认价格(适用于冲销等)
Create Or Replace Function Zl_Fun_Getoutprice
(
  药品id_In   药品库存.药品id%Type,
  批次_In     药品库存.批次%Type,
  库房id_In   药品库存.库房id%Type,
  默认价格_In 药品库存.零售价%Type := Null
) Return Number Is
  n_是否药品 Number(1) := 0;
  n_是否变价 收费项目目录.是否变价%Type;
  n_售价     药品库存.零售价%Type;
  n_实际金额 药品库存.实际金额%Type;
  n_实际数量 药品库存.实际数量%Type;
  n_标准单价 收费价目.现价%Type;
Begin
  --功能：
  --1.取最新的售价
  --2.定价从收费价目取，时价从库存表取
  --3.时价如果无库存，优先从价格表取，其次从药品规格取
  --4.无库存也无价格记录时，如果有默认价格，则返回默认价格
  Begin
    Select 1 Into n_是否药品 From 收费项目目录 Where 类别 In ('5', '6', '7') And ID = 药品id_In;
  Exception
    When Others Then
      n_是否药品 := 0;
  End;

  Select Nvl(是否变价, 0) Into n_是否变价 From 收费项目目录 Where ID = 药品id_In;

  Select 现价
  Into n_标准单价
  From 收费价目
  Where 收费细目id = 药品id_In And (终止日期 Is Null Or Sysdate Between 执行日期 And Nvl(终止日期, To_Date('3000-01-01', 'yyyy-MM-dd')));

  If n_是否变价 = 0 Then
    --定价
    n_售价 := n_标准单价;
  Else
    --时价
    Begin
      Select 零售价, Nvl(实际数量, 0) As 实际数量, Nvl(实际金额, 0) As 实际金额
      Into n_售价, n_实际数量, n_实际金额
      From 药品库存
      Where 性质 = 1 And 药品id = 药品id_In And Nvl(批次, 0) = Nvl(批次_In, 0) And 库房id = 库房id_In;
    Exception
      When Others Then
        n_实际数量 := 0;
        n_实际金额 := 0;
    End;
  
    If n_售价 Is Null Or n_售价 < 0 Then
      If n_是否药品 = 1 Then
      
        Select Max(现价)
        Into n_售价
        From 药品价格记录
        Where 价格类型 = 1 And 记录状态 = 1 And 药品id = 药品id_In And Nvl(批次, 0) = Nvl(批次_In, 0) And 库房id = 库房id_In;
      
        If n_售价 Is Null Or n_售价 < 0 Then
          --如果传入了默认价格就取默认价格，如果没有则取最近价格
          If 默认价格_In Is Null Then
            Select 上次售价 Into n_售价 From 药品规格 Where 药品id = 药品id_In;
          Else
            n_售价 := 默认价格_In;
          End If;
        End If;
      Else
        If n_实际数量 <> 0 Then
          n_售价 := n_实际金额 / n_实际数量;
        End If;
      
        If n_售价 Is Null Or n_售价 < 0 Then
          --如果传入了默认价格就取默认价格，如果没有则取最近价格
          If 默认价格_In Is Null Then
            Select 上次售价 Into n_售价 From 材料特性 Where 材料id = 药品id_In;
          Else
            n_售价 := 默认价格_In;
          End If;
        End If;
      End If;
    End If;
  
    If n_售价 Is Null Or n_售价 < 0 Then
      n_售价 := n_标准单价;
    End If;
  End If;

  Return(n_售价);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Fun_Getoutprice;
/

--119852:李业庆,2018-01-11,取价格时返回默认价格(适用于冲销等)
Create Or Replace Function Zl_Fun_Getoutcost
(
  药品id_In   药品库存.药品id%Type,
  批次_In     药品库存.批次%Type,
  库房id_In   药品库存.库房id%Type,
  默认价格_In 药品库存.平均成本价%Type := Null
) Return Number Is
  n_平均成本价 药品库存.平均成本价%Type;
  n_是否药品   Number(1) := 0;
Begin
  --功能：
  --1.取最新的成本价
  --2.优先库存表取，如果无库存，优先从价格表取，其次从药品规格取
  --3.无库存也无价格记录时，如果有默认价格，则返回默认价格

  Begin
    Select 1 Into n_是否药品 From 收费项目目录 Where 类别 In ('5', '6', '7') And ID = 药品id_In;
  Exception
    When Others Then
      n_是否药品 := 0;
  End;

  Select Max(平均成本价)
  Into n_平均成本价
  From 药品库存
  Where 性质 = 1 And 药品id = 药品id_In And Nvl(批次, 0) = Nvl(批次_In, 0) And 库房id = 库房id_In;

  If n_是否药品 = 1 Then
    --药品
    If n_平均成本价 Is Null Or n_平均成本价 < 0 Then
      Select Max(现价)
      Into n_平均成本价
      From 药品价格记录
      Where 价格类型 = 2 And 记录状态 = 1 And 药品id = 药品id_In And Nvl(批次, 0) = Nvl(批次_In, 0) And 库房id = 库房id_In;
    
      If n_平均成本价 Is Null Or n_平均成本价 < 0 Then
        --如果传入了默认价格就取默认价格，如果没有则取最近价格
        If 默认价格_In Is Null Then
          Select 成本价 Into n_平均成本价 From 药品规格 Where 药品id = 药品id_In;
        Else
          n_平均成本价 := 默认价格_In;
        End If;
      End If;
    End If;
  Else
    --卫材
    If n_平均成本价 Is Null Or n_平均成本价 < 0 Then
      --如果传入了默认价格就取默认价格，如果没有则取最近价格
      If 默认价格_In Is Null Then
        Select 成本价 Into n_平均成本价 From 材料特性 Where 材料id = 药品id_In;
      Else
        n_平均成本价 := 默认价格_In;
      End If;
    End If;
  End If;
  Return(n_平均成本价);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Fun_Getoutcost;
/

--119437:胡俊勇,2018-01-09,临床相关消息修改
CREATE OR REPLACE Procedure Zl_病人医嘱记录_Insert
(
  Id_In           In 病人医嘱记录.Id%Type,
  相关id_In       In 病人医嘱记录.相关id%Type,
  序号_In         In 病人医嘱记录.序号%Type,
  病人来源_In     In 病人医嘱记录.病人来源%Type,
  病人id_In       In 病人医嘱记录.病人id%Type,
  主页id_In       In 病人医嘱记录.主页id%Type,
  婴儿_In         In 病人医嘱记录.婴儿%Type,
  医嘱状态_In     In 病人医嘱记录.医嘱状态%Type,
  医嘱期效_In     In 病人医嘱记录.医嘱期效%Type,
  诊疗类别_In     In 病人医嘱记录.诊疗类别%Type,
  诊疗项目id_In   In 病人医嘱记录.诊疗项目id%Type,
  收费细目id_In   In 病人医嘱记录.收费细目id%Type,
  天数_In         In 病人医嘱记录.天数%Type,
  单次用量_In     In 病人医嘱记录.单次用量%Type,
  总给予量_In     In 病人医嘱记录.总给予量%Type,
  医嘱内容_In     In 病人医嘱记录.医嘱内容%Type,
  医生嘱托_In     In 病人医嘱记录.医生嘱托%Type,
  标本部位_In     In 病人医嘱记录.标本部位%Type,
  执行频次_In     In 病人医嘱记录.执行频次%Type,
  频率次数_In     In 病人医嘱记录.频率次数%Type,
  频率间隔_In     In 病人医嘱记录.频率间隔%Type,
  间隔单位_In     In 病人医嘱记录.间隔单位%Type,
  执行时间方案_In In 病人医嘱记录.执行时间方案%Type,
  计价特性_In     In 病人医嘱记录.计价特性%Type,
  执行科室id_In   In 病人医嘱记录.执行科室id%Type,
  执行性质_In     In 病人医嘱记录.执行性质%Type,
  紧急标志_In     In 病人医嘱记录.紧急标志%Type,
  开始执行时间_In In 病人医嘱记录.开始执行时间%Type,
  执行终止时间_In In 病人医嘱记录.执行终止时间%Type,
  病人科室id_In   In 病人医嘱记录.病人科室id%Type,
  开嘱科室id_In   In 病人医嘱记录.开嘱科室id%Type,
  开嘱医生_In     In 病人医嘱记录.开嘱医生%Type,
  开嘱时间_In     In 病人医嘱记录.开嘱时间%Type,
  挂号单_In       In 病人医嘱记录.挂号单%Type := Null,
  前提id_In       In 病人医嘱记录.前提id%Type := Null,
  检查方法_In     In 病人医嘱记录.检查方法%Type := Null,
  执行标记_In     In 病人医嘱记录.执行标记%Type := Null,
  可否分零_In     In 病人医嘱记录.可否分零%Type := Null,
  摘要_In         In 病人医嘱记录.摘要%Type := Null,
  操作员姓名_In   In 病人医嘱状态.操作人员%Type := Null,
  零费记帐_In     In 病人医嘱记录.零费记帐%Type := Null,
  用药目的_In     In 病人医嘱记录.用药目的%Type := Null,
  用药理由_In     In 病人医嘱记录.用药理由%Type := Null,
  审核状态_In     In 病人医嘱记录.审核状态%Type := Null,
  申请序号_In     In 病人医嘱记录.申请序号%Type := Null,
  超量说明_In     In 病人医嘱记录.超量说明%Type := Null,
  首次用量_In     In 病人医嘱记录.首次用量%Type := Null,
  配方id_In       In 病人医嘱记录.配方id%Type := Null,
  手术情况_In     In 病人医嘱记录.手术情况%Type := Null,
  组合项目id_In   In 病人医嘱记录.组合项目id%Type := Null,
  皮试结果_In     In 病人医嘱记录.皮试结果%Type := Null,
  处方序号_In     In 病人医嘱记录.处方序号%Type := Null
  --功能：医生或护士新开,补录医嘱时新产生的医嘱记录。可用于门诊或住院。
) Is
  v_Temp     Varchar2(255);
  v_人员姓名 病人医嘱状态.操作人员%Type;
  n_人员id   部门表.Id%Type;
  v_姓名     病人信息.姓名%Type;
  v_性别     病人信息.性别%Type;
  v_年龄     病人信息.年龄%Type;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --当前操作人员
  If 操作员姓名_In Is Not Null Then
    v_人员姓名 := 操作员姓名_In;
  Else
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;

  If Nvl(主页id_In, 0) <> 0 Then
    Select 姓名, 性别, 年龄 Into v_姓名, v_性别, v_年龄 From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
  Else
    Select 姓名, 性别, 年龄 Into v_姓名, v_性别, v_年龄 From 病人信息 Where 病人id = 病人id_In;
  End If;

  --病人医嘱记录
  Insert Into 病人医嘱记录
    (ID, 相关id, 序号, 病人来源, 病人id, 主页id, 姓名, 性别, 年龄, 婴儿, 医嘱状态, 医嘱期效, 诊疗类别, 诊疗项目id, 收费细目id, 天数, 单次用量, 总给予量, 医嘱内容, 医生嘱托, 标本部位,
     检查方法, 执行标记, 执行频次, 频率次数, 频率间隔, 间隔单位, 执行时间方案, 计价特性, 执行科室id, 执行性质, 紧急标志, 可否分零, 开始执行时间, 执行终止时间, 病人科室id, 开嘱科室id, 开嘱医生,
     开嘱时间, 挂号单, 前提id, 摘要, 零费记帐, 手术时间, 用药目的, 用药理由, 审核状态, 申请序号, 超量说明, 首次用量, 配方id, 手术情况, 组合项目id, 皮试结果, 处方序号)
  Values
    (Id_In, 相关id_In, 序号_In, 病人来源_In, 病人id_In, 主页id_In, v_姓名, v_性别, v_年龄, 婴儿_In, 医嘱状态_In, 医嘱期效_In, 诊疗类别_In, 诊疗项目id_In,
     收费细目id_In, 天数_In, 单次用量_In, 总给予量_In, 医嘱内容_In, 医生嘱托_In, 标本部位_In, 检查方法_In, 执行标记_In, 执行频次_In, 频率次数_In, 频率间隔_In, 间隔单位_In,
     执行时间方案_In, 计价特性_In, 执行科室id_In, 执行性质_In, 紧急标志_In, 可否分零_In, 开始执行时间_In, 执行终止时间_In, 病人科室id_In, 开嘱科室id_In, 开嘱医生_In,
     开嘱时间_In, 挂号单_In, 前提id_In, 摘要_In, 零费记帐_In,
     Decode(诊疗类别_In, 'F', To_Date(标本部位_In, 'yyyy-mm-dd hh24:mi:ss'), 'K', To_Date(标本部位_In, 'yyyy-mm-dd hh24:mi:ss'),
             Null), 用药目的_In, 用药理由_In, 审核状态_In, 申请序号_In, 超量说明_In, 首次用量_In, 配方id_In, 手术情况_In, 组合项目id_In, 皮试结果_In, 处方序号_In);

  --病人医嘱状态
  If 医嘱状态_In <> -1 Then
    Delete From 病人医嘱状态 Where 医嘱id = Id_In And 操作类型 = 1;
    If Sql%RowCount <> 0 Then
      v_Error := '相同ID的新开医嘱已经存在。';
      Raise Err_Custom;
    End If;
    --因为可能同时：新开->自动校对(住院医生发送)->互斥自动停止(住院医生发送临嘱停止),因此分别-2,-1秒
    Insert Into 病人医嘱状态
      (医嘱id, 操作类型, 操作人员, 操作时间)
    Values
      (Id_In, 1, v_人员姓名, Sysdate - 2 / 60 / 60 / 24);
  End If;
  --更新常用项目
  If Nvl(挂号单_In, '空') <> '空' Then
    Select ID Into n_人员id From 人员表 Where 姓名 = v_人员姓名;
    Zl_医生常用医嘱_Update(n_人员id, 开嘱科室id_In, Null, Null, Null, 诊疗项目id_In, 收费细目id_In, 诊疗类别_In);
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱记录_Insert;
/

--119437:胡俊勇,2018-01-09,临床相关消息修改
CREATE OR REPLACE Procedure Zl_病人医嘱记录_提交
(
  病人id_In     In 病人医嘱记录.病人id%Type,
  主页id_In     In 病人医嘱记录.主页id%Type,
  前提id_In     In 病人医嘱记录.前提id%Type := Null,
  操作员姓名_In In 人员表.姓名%Type := Null
) Is
  v_Date     Date;
  v_Temp     Varchar2(255);
  v_人员姓名 病人医嘱状态.操作人员%Type;
  v_Error    Varchar2(255);
  Err_Custom Exception;
Begin
  --当前操作人员
  If 操作员姓名_In Is Not Null Then
    v_人员姓名 := 操作员姓名_In;
  Else
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;
  Select Sysdate Into v_Date From Dual;
  Insert Into 病人医嘱状态
    (医嘱id, 操作类型, 操作人员, 操作时间)
    Select ID, 1, v_人员姓名, v_Date - 2 / 60 / 60 / 24
    From 病人医嘱记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(前提id, 0) = Nvl(前提id_In, 0) And 医嘱状态 = -1;

  Update 病人医嘱记录
  Set 医嘱状态 = 1
  Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(前提id, 0) = Nvl(前提id_In, 0) And 医嘱状态 = -1;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱记录_提交;
/

--119437:胡俊勇,2018-01-09,临床相关消息修改
CREATE OR REPLACE Procedure Zl_病人医嘱执行_Arrange
(
  医嘱id_In   In 病人医嘱发送.医嘱id%Type,
  发送号_In   In 病人医嘱发送.发送号%Type,
  安排时间_In In 病人医嘱发送.安排时间%Type
  --功能：对待执行医嘱进行时间安排
) Is
  Cursor c_Advice Is
    Select ID, 相关id, 诊疗类别, 病人id, 主页id, 挂号单 From 病人医嘱记录 Where ID = 医嘱id_In;
  r_Advice c_Advice%RowType;
Begin
  Open c_Advice;
  Fetch c_Advice
    Into r_Advice;
  If r_Advice.诊疗类别 = 'C' And r_Advice.相关id Is Not Null Then
    --包含一并采集的所有检验项目
    Update 病人医嘱发送
    Set 安排时间 = 安排时间_In
    Where 发送号 + 0 = 发送号_In And 医嘱id In (Select ID From 病人医嘱记录 Where 相关id = r_Advice.相关id);
  Else
    --包含附加手术,检验部位,以及其它独立医嘱;麻醉和中药煎法是单独安排
    Update 病人医嘱发送
    Set 安排时间 = 安排时间_In
    Where 发送号 + 0 = 发送号_In And 医嘱id In (Select ID
                                        From 病人医嘱记录
                                        Where ID = 医嘱id_In
                                        Union All
                                        Select ID
                                        From 病人医嘱记录
                                        Where 相关id = 医嘱id_In And 诊疗类别 In ('F', 'D'));
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱执行_Arrange;
/

--119437:胡俊勇,2018-01-09,临床相关消息修改
CREATE OR REPLACE Procedure Zl_病人挂号记录_转诊
(
  No_In         In 病人挂号记录.No%Type,
  转诊状态_In   In 病人挂号记录.转诊状态%Type,
  转诊科室id_In In 病人挂号记录.转诊科室id%Type := Null,
  转诊诊室_In   In 病人挂号记录.转诊诊室%Type := Null,
  转诊医生_In   In 病人挂号记录.转诊医生%Type := Null
  --功能：完成病人转诊，转诊接收，取消转诊，拒绝转诊功能
  --参数：
  ----转诊状态_IN：0:转诊(需要传入其他参数),1:接收,-1:拒绝,Null:取消转诊
) As
  v_病人id   病人挂号记录.病人id%Type;
  v_转诊状态 病人挂号记录.转诊状态%Type;

  n_再次签到重新排队 Number;
  n_分诊台签到排队   Number;
  v_Temp             Varchar2(255);
  v_人员姓名         门诊费用记录.操作员姓名%Type;
  v_队列名称         排队叫号队列.队列名称%Type;
  v_现队列名称       排队叫号队列.队列名称%Type;
  v_病人姓名         病人挂号记录.姓名%Type;
  v_医生             病人挂号记录.执行人%Type;
  v_诊室             病人挂号记录.诊室%Type;
  n_挂号id           病人挂号记录.Id%Type;
  n_执行部门id       病人挂号记录.执行部门id%Type;
  v_号别             病人挂号记录.号别%Type;
  n_号序             病人挂号记录.号序%Type;
  d_Cur              Date;
  v_Error            Varchar2(255);
  Err_Custom Exception;
  n_排队       Number(2);
  v_排队号码   排队叫号队列.排队号码%Type;
  v_新排队号码 排队叫号队列.排队号码%Type;
  v_排队序号   排队叫号队列.排队序号%Type;
  d_新排队时间 排队叫号队列.排队时间%Type;
Begin
  Begin
    Select 病人id, 转诊状态, ID
    Into v_病人id, v_转诊状态, n_挂号id
    From 病人挂号记录
    Where NO = No_In And 记录状态 = 1 And 记录性质 = 1;
  Exception
    When Others Then
      Begin
        v_Error := '病人的挂号记录不存在，可能已经退号。';
        Raise Err_Custom;
      End;
  End;

  n_分诊台签到排队   := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
  n_再次签到重新排队 := Zl_To_Number(zl_GetSysParameter('再次签到需重新排队', 1113));

  If 转诊状态_In Is Null Then
    --取消转诊
    If Not (v_转诊状态 = 0 Or v_转诊状态 = -1) Or v_转诊状态 Is Null Then
      v_Error := '病人当前不处于转诊待接收或被拒绝状态，不能取消转诊。';
      Raise Err_Custom;
    End If;
  
    Update 病人挂号记录
    Set 转诊状态 = Null, 转诊号别 = Null, 转诊科室id = Null, 转诊诊室 = Null, 转诊医生 = Null
    Where NO = No_In;
  
    Begin
      Select 1 Into n_排队 From 排队叫号队列 Where Nvl(业务类型, 0) = 0 And 业务id = n_挂号id;
    Exception
      When Others Then
        n_排队 := -1;
    End;
  
    If Nvl(n_排队, 0) <> 0 Then
      Update 病人挂号记录 Set 记录标志 = 1 Where NO = No_In;
      Begin
        Select ID, 执行部门id, 姓名, 执行人, 诊室, 号别, Nvl(号序, 0)
        Into n_挂号id, n_执行部门id, v_病人姓名, v_医生, v_诊室, v_号别, n_号序
        From 病人挂号记录
        Where NO = No_In And 记录性质 = 1 And 记录状态 = 1 And Rownum = 1;
      Exception
        When Others Then
          n_挂号id := -1;
      End;
      If n_挂号id > 0 Then
        --取消转诊也只能重新获取队列
        v_现队列名称 := n_执行部门id;
        --Zlgetnextqueue(执行部门id_In Number,业务id_In     Number := Null)
        v_排队号码 := Zlgetnextqueue(n_执行部门id, n_挂号id, v_号别 || '|' || n_号序);
        v_排队序号 := Zlgetsequencenum(0, n_挂号id, 1);
        --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In , 医生姓名_In,排队号码_In
        Zl_排队叫号队列_Update(v_现队列名称, 0, n_挂号id, n_执行部门id, v_病人姓名, v_诊室, v_医生, v_排队号码, v_排队序号);
        --转诊重新获取队列
      End If;
    End If;
  
  Elsif 转诊状态_In = 0 Then
    --转诊
    If Not (v_转诊状态 Is Null Or v_转诊状态 = 1) Then
      v_Error := '病人当前已经转诊待处理，不能再进行转诊。';
      Raise Err_Custom;
    End If;
  
    Update 病人挂号记录
    Set 转诊状态 = 0, 转诊号别 = 号别, 转诊科室id = 转诊科室id_In, 转诊诊室 = 转诊诊室_In, 转诊医生 = 转诊医生_In
    Where NO = No_In And 记录性质 = 1 And 记录状态 = 1
    Returning ID Into n_挂号id;
  
    Begin
      Select 1, 队列名称 Into n_排队, v_队列名称 From 排队叫号队列 Where Nvl(业务类型, 0) = 0 And 业务id = n_挂号id;
    Exception
      When Others Then
        n_排队 := -1;
    End;
  
    If Nvl(n_排队, 0) <> 0 Then
      If Nvl(n_分诊台签到排队, 0) = 1 Then
        If Nvl(v_队列名称, 0) <> 0 And Nvl(n_再次签到重新排队, 0) = 1 Then
          --删除原来排队记录重新排队：队列名称_IN，业务ID_IN
          Zl_排队叫号队列_Delete(v_队列名称, n_挂号id);
        End If;
        Update 病人挂号记录 Set 记录标志 = 0 Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;
      Else
        Begin
          Select ID, 执行部门id, 姓名, 号别, 号序
          Into n_挂号id, n_执行部门id, v_病人姓名, v_号别, n_号序
          From 病人挂号记录
          Where NO = No_In And 记录性质 = 1 And 记录状态 = 1 And Rownum = 1;
        Exception
          When Others Then
            n_挂号id := -1;
        End;
      
        v_现队列名称 := 转诊科室id_In;
        Begin
          Select 排队号码 Into v_排队号码 From 排队叫号队列 Where 业务id = n_挂号id And 业务类型 = 0;
        Exception
          When Others Then
            v_排队号码 := -1;
        End;
        If n_挂号id > 0 Then
          v_新排队号码 := Zl_Get_Requeue(2, n_挂号id, 转诊科室id_In, 转诊医生_In, 转诊诊室_In);
          If v_排队号码 <> v_新排队号码 Or Nvl(n_再次签到重新排队, 0) = 1 Then
            d_新排队时间 := Zl_Get_Requeuedate(2, n_挂号id, 转诊科室id_In, 转诊医生_In, 转诊诊室_In);
            --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In , 医生姓名_In
            Zl_排队叫号队列_Update(v_现队列名称, 0, n_挂号id, 转诊科室id_In, v_病人姓名, 转诊诊室_In, 转诊医生_In, v_新排队号码, Null, d_新排队时间);
          Else
            --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In , 医生姓名_In
            Zl_排队叫号队列_Update(v_现队列名称, 0, n_挂号id, 转诊科室id_In, v_病人姓名, 转诊诊室_In, 转诊医生_In);
          End If;
          --转诊后,重新排队
          Update 排队叫号队列 Set 排队状态 = 0 Where 业务类型 = 0 And 业务id = n_挂号id;
        End If;
      End If;
    End If;
  Elsif 转诊状态_In = 1 Then
    --接收
    If v_转诊状态 <> 0 Or v_转诊状态 Is Null Then
      v_Error := '病人当前不处于转诊待接收状态，不能接收转诊。';
      Raise Err_Custom;
    End If;
  
    --当前接诊人员：虽然转诊指定了，但实际接诊的可能不是原指定的。
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    d_Cur      := Sysdate;
  
    --转诊接收类似强制接诊一样，只更改执行相关信息
    --原转诊时指定的内容在接诊时不一定与指定的一致
    --原转诊时指定内容的作用：1.确定转诊后再接诊的范围，2.备查。
    Insert Into 病人转诊记录
      (挂号id, NO, 申请科室id, 申请医生, 接收科室id, 接收医生, 接收时间)
      Select ID, No_In, 执行部门id, 执行人, 转诊科室id, v_人员姓名, d_Cur From 病人挂号记录 Where NO = No_In;
  
    Update 病人信息 Set 就诊状态 = 2, 就诊时间 = d_Cur Where 病人id = v_病人id;
    Update 病人挂号记录
    Set 执行人 = v_人员姓名, 执行部门id = 转诊科室id, 执行状态 = 2, 执行时间 = d_Cur, 转诊状态 = 1
    Where NO = No_In And 记录性质 = 1 And 记录状态 = 1
    Returning 转诊科室id, ID Into n_执行部门id, n_挂号id;
  
    Update 门诊费用记录
    Set 执行人 = v_人员姓名, 病人科室id = n_执行部门id, 执行部门id = n_执行部门id, 执行状态 = 2, 执行时间 = d_Cur
    Where NO = No_In And 记录性质 = 4;
  
    --接诊后,变成弃号
    Update 排队叫号队列 Set 排队状态 = 2 Where 业务类型 = 0 And 业务id = n_挂号id;
  
  Elsif 转诊状态_In = -1 Then
    --拒绝
    If v_转诊状态 <> 0 Or v_转诊状态 Is Null Then
      v_Error := '病人当前不处于转诊待接收状态，不能拒绝转诊。';
      Raise Err_Custom;
    End If;
    Update 病人挂号记录 Set 转诊状态 = -1 Where NO = No_In;
    --接诊后,变成弃号
    Update 排队叫号队列 Set 排队状态 = 2 Where 业务类型 = 0 And 业务id = n_挂号id;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人挂号记录_转诊;
/

--119437:胡俊勇,2018-01-09,临床相关消息修改
CREATE OR REPLACE Procedure Zl_输液配药记录_Update
(
  配药id_In   In Varchar2,
  是否打包_In In 输液配药记录.是否打包%Type,
  配药批次_In In 输液配药记录.配药批次%Type,
  核查人_In   In 输液配药状态.操作人员%Type,
  核查时间_In In 输液配药状态.操作时间%Type
) Is
  n_Ct    Number;
  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  Select Count(1)
  Into n_Ct
  From 输液配药记录
  Where ID = 配药id_In And 操作状态 In (1, 2, 3) And Nvl(配药批次, 0) <> Nvl(配药批次_In, 0);

  Update 输液配药记录
  Set 是否打包 = 是否打包_In, 配药批次 = 配药批次_In, 打包时间 = Decode(是否打包_In, 1, 核查时间_In, Null), 批次标记 = Decode(n_Ct, 1, 2, 批次标记)
  Where ID = 配药id_In And 操作状态 In (1, 2, 3);

  If Sql%RowCount = 0 Then
    v_Error := '由于并发操作,当前修改的配药记录已配药,操作失败.';
    Raise Err_Custom;
  End If; 
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_输液配药记录_Update;
/

--119437:胡俊勇,2018-01-09,临床相关消息修改
CREATE OR REPLACE Procedure Zl_病人预约挂号_接收
(
  No_In            In 病人挂号记录.No%Type,
  诊室_In          In 病人挂号记录.诊室%Type,
  结帐id_In        In 门诊费用记录.结帐id%Type := Null,
  卡类别id_In      In 病人预交记录.卡类别id%Type := Null,
  卡号_In          In 病人预交记录.卡号%Type := Null,
  交易流水号_In    In 病人预交记录.交易流水号%Type := Null,
  交易说明_In      In 病人预交记录.交易说明%Type := Null,
  接收时间_In      In 病人挂号记录.接收时间%Type := Null,
  冲预交病人ids_In In Varchar2 := Null
  --该过程用于直接完成预约挂号接收、就诊；主要是医生站使用。
  -- 冲预交病人ids_In:多个用逗分分离,冲预交时有效(冲预交类别与业务操作保持一致),主要是使用家属的预交款
) As
  --该游标用于收费冲预交的可用预交列表
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit
  (
    n_病人id        病人信息.病人id%Type,
    v_冲预交病人ids Varchar2
  ) Is
    Select *
    From (Select a.Id, a.病人id, a.记录状态, a.No, Nvl(a.金额, 0) As 金额
           From 病人预交记录 A,
                (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                  From 病人预交记录 A
                  Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And
                        a.病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And Nvl(预交类别, 2) = 1
                  Group By NO
                  Having Sum(Nvl(a.金额, 0)) <> 0) B
           Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.结算方式 Not In (Select 名称 From 结算方式 Where 性质 = 5) And
                 a.No = b.No And a.病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And
                 Nvl(a.预交类别, 2) = 1
           Union All
           Select 0 As ID, Max(病人id) As 病人id, 记录状态, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
           From 病人预交记录
           Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(金额, 0) <> Nvl(冲预交, 0) And
                 病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And Nvl(预交类别, 2) = 1 Having
            Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
           Group By Decode(病人id, Nvl(n_病人id, 0), 0, 1), 记录状态, NO)
    Order By ID, NO;

  --号别信息
  Cursor c_Regist Is
    Select b.科室id, b.项目id, b.医生id, b.医生姓名, b.号码
    From 门诊费用记录 A, 挂号安排 B
    Where a.记录性质 = 4 And a.记录状态 = 1 And a.No = No_In And a.序号 = 1 And a.计算单位 = b.号码;
  r_Regist c_Regist%RowType;

  Cursor c_Registnew Is
    Select b.科室id, b.项目id, b.医生id, b.医生姓名, c.号码
    From 病人挂号记录 A, 临床出诊记录 B, 临床出诊号源 C
    Where a.记录性质 = 1 And a.记录状态 = 1 And a.No = No_In And a.出诊记录id = b.Id And b.号源id = c.Id;
  r_Registnew c_Registnew%RowType;

  v_划价no       门诊费用记录.No%Type;
  v_Temp         Varchar2(255);
  v_人员编号     门诊费用记录.操作员编号%Type;
  v_人员姓名     门诊费用记录.操作员姓名%Type;
  v_挂号生成队列 Varchar2(2);
  v_排队号码     排队叫号队列.排队号码%Type;
  v_预约方式     病人挂号记录.预约方式%Type;

  n_病人id   病人挂号记录.病人id%Type;
  n_门诊号   病人挂号记录.门诊号%Type;
  n_挂号金额 门诊费用记录.实收金额%Type;
  n_剩余金额 病人余额.预交余额%Type;
  n_预交金额 病人预交记录.金额%Type;
  n_结帐id   门诊费用记录.结帐id%Type;
  n_返回值   病人预交记录.金额%Type;

  d_Date     Date;
  n_当天排队 Number(18);
  n_排队     Number(18);
  v_结算方式 病人预交记录.结算方式%Type;
  v_三方名称 医疗卡类别.名称%Type;

  v_Error Varchar2(255);
  Err_Custom Exception;
  n_组id          财务缴款分组.Id%Type;
  v_排队序号      排队叫号队列.排队序号%Type;
  n_结算模式      病人信息.结算模式%Type;
  v_付款方式      病人挂号记录.医疗付款方式%Type;
  v_冲预交病人ids Varchar2(4000);
  n_冲预交        病人余额.预交余额%Type;
  n_出诊记录id    临床出诊记录.Id%Type;
Begin
  Begin
    Select a.病人id, a.标识号, Nvl(b.预交余额, 0) - Nvl(b.费用余额, 0) As 余额, Sum(a.实收金额) As n_挂号金额, Substr(a.结论, 1, 10)
    Into n_病人id, n_门诊号, n_剩余金额, n_挂号金额, v_预约方式
    From 门诊费用记录 A, 病人余额 B
    Where a.病人id = b.病人id(+) And b.性质(+) = 1 And b.类型(+) = 1 And a.No = No_In And a.记录性质 = 4 And a.记录状态 = 0
    Group By a.病人id, a.标识号, Nvl(b.预交余额, 0) - Nvl(b.费用余额, 0), a.结论;
  Exception
    When Others Then
      v_Error := '预约挂号信息不存在，可能该预约挂号已被接收。';
      Raise Err_Custom;
  End;
  If 接收时间_In Is Null Then
    Select Sysdate Into d_Date From Dual;
  Else
    d_Date := 接收时间_In;
  End If;

  Begin
    Select 出诊记录id Into n_出诊记录id From 病人挂号记录 Where NO = No_In;
  Exception
    When Others Then
      n_出诊记录id := Null;
  End;

  v_冲预交病人ids := Nvl(冲预交病人ids_In, n_病人id);

  --当前操作人员
  v_Temp     := Zl_Identity;
  v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  n_组id     := Zl_Get组id(v_人员姓名);
  n_结算模式 := 0;
  If Nvl(n_病人id, 0) <> 0 Then
    Select Nvl(结算模式, 0) Into n_结算模式 From 病人信息 Where 病人id = n_病人id;
  End If;
  If n_结算模式 = 0 Then
    If Nvl(结帐id_In, 0) = 0 Then
      Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
    Else
      n_结帐id := 结帐id_In;
    End If;
  End If;

  --病人信息的产生
  If n_门诊号 Is Null Then
    Select To_Number(Nextno(3)) Into n_门诊号 From Dual;
  End If;

  If n_病人id Is Null Then
    Select To_Number(Nextno(1)) Into n_病人id From Dual;
    Insert Into 病人信息
      (病人id, 门诊号, 姓名, 性别, 年龄, 费别, 医疗付款方式, 登记时间)
      Select n_病人id, n_门诊号, a.姓名, a.性别, a.年龄, a.费别, b.名称, d_Date
      From 门诊费用记录 A, 医疗付款方式 B
      Where a.付款方式 = b.编码(+) And a.No = No_In And a.记录性质 = 4 And a.记录状态 = 0 And a.序号 = 1;
  End If;

  --更新病人信息，含就诊信息
  Update 病人信息 Set 就诊时间 = d_Date, 就诊状态 = 2, 就诊诊室 = 诊室_In Where 病人id = n_病人id;

  --更新门诊费用记录，含就诊信息
  Update 门诊费用记录
  Set 记录状态 = 1, 结帐id = Decode(n_结算模式, 1, Null, n_结帐id), 结帐金额 = Decode(n_结算模式, 1, Null, 实收金额), 发药窗口 = 诊室_In, 执行人 = v_人员姓名,
      执行状态 = 2, 执行时间 = d_Date, 病人id = Decode(病人id, Null, n_病人id, 病人id), 标识号 = Decode(标识号, Null, n_门诊号, 标识号),
      登记时间 = d_Date, 操作员编号 = v_人员编号, 操作员姓名 = v_人员姓名, 缴款组id = n_组id, 记帐费用 = Decode(n_结算模式, 1, 1, 0)
  Where NO = No_In And 记录性质 = 4 And 记录状态 = 0;

  Update 病人挂号记录
  Set 记录性质 = 1, 接收人 = v_人员姓名, 接收时间 = d_Date, 诊室 = 诊室_In, 执行人 = v_人员姓名, 执行时间 = d_Date, 执行状态 = 2,
      病人id = Decode(病人id, Null, n_病人id, 病人id), 门诊号 = Decode(门诊号, Null, n_门诊号, 门诊号)
  Where NO = No_In And 记录状态 = 1 And 记录性质 = 2;

  If Sql%NotFound Then
    --产生病人挂号记录，含就诊信息
    Begin
      Select a.名称
      Into v_付款方式
      From 医疗付款方式 A, 门诊费用记录 B
      Where b.No = No_In And b.记录性质 = 4 And b.记录状态 = 1 And b.序号 = 1 And a.编码 = b.付款方式 And Rownum < 2;
      Insert Into 病人挂号记录
        (ID, NO, 病人id, 记录性质, 记录状态, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 发生时间, 登记时间, 操作员编号, 操作员姓名,
         预约, 预约方式, 接收时间, 接收人, 预约时间, 医疗付款方式, 出诊记录id)
        Select 病人挂号记录_Id.Nextval, No_In, 病人id, 1, 1, 标识号, 姓名, 性别, 年龄, 计算单位, 加班标志, 诊室_In, Null, 执行部门id, v_人员姓名, 2, d_Date,
               发生时间, 登记时间, 操作员编号, 操作员姓名, 1, Substr(结论, 1, 10) As 预约方式, d_Date, v_人员姓名, 发生时间, v_付款方式, n_出诊记录id
        
        From 门诊费用记录
        Where NO = No_In And 记录性质 = 4 And 记录状态 = 1 And 序号 = 1;
    Exception
      When Others Then
        v_Error := '该预约挂号已被接收。';
        Raise Err_Custom;
    End;
  End If;

  v_挂号生成队列 := Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113));
  If v_挂号生成队列 <> 0 Then
    For c_挂号 In (Select ID, 执行部门id, 姓名, 诊室_In As 诊室, 登记时间, 执行人 As 执行人, 病人id, 号别, 号序
                 From 病人挂号记录
                 Where NO = No_In And Rownum = 1) Loop
      Begin
        Select 1,
               Case
                 When 排队时间 < Trunc(Sysdate) Then
                  1
                 Else
                  0
               End
        Into n_排队, n_当天排队
        From 排队叫号队列
        Where 业务类型 = 0 And 业务id = c_挂号.Id And Rownum <= 1;
      Exception
        When Others Then
          n_排队 := 0;
      End;
    
      If n_排队 = 0 Then
        --新增排队
        --产生队列
        --.按”执行部门” 的方式生成队列
        v_排队号码 := Zlgetnextqueue(c_挂号.执行部门id, c_挂号.Id, c_挂号.号别 || '|' || Nvl(c_挂号.号序, 0));
        v_排队序号 := Zlgetsequencenum(0, c_挂号.Id, 0);
        --  队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,排队标记_In,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In, 排队时间_In
        Zl_排队叫号队列_Insert(c_挂号.执行部门id, 0, c_挂号.Id, c_挂号.执行部门id, v_排队号码, Null, c_挂号.姓名, c_挂号.病人id, c_挂号.诊室, c_挂号.执行人,
                         Sysdate, v_预约方式, Null, v_排队序号);
      Elsif Nvl(n_当天排队, 0) = 1 Then
        --更新队列号
        v_排队号码 := Zlgetnextqueue(c_挂号.执行部门id, c_挂号.Id, c_挂号.号别 || '|' || Nvl(c_挂号.号序, 0));
        v_排队序号 := Zlgetsequencenum(0, c_挂号.Id, 1);
        --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In, 医生姓名_In ,排队号码_In
        Zl_排队叫号队列_Update(c_挂号.执行部门id, 0, c_挂号.Id, c_挂号.执行部门id, c_挂号.姓名, c_挂号.诊室, c_挂号.执行人, v_排队号码, v_排队序号);
      
      Else
        --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In, 医生姓名_In ,排队号码_In
        Zl_排队叫号队列_Update(c_挂号.执行部门id, 0, c_挂号.Id, c_挂号.执行部门id, c_挂号.姓名, c_挂号.诊室, c_挂号.执行人);
      End If;
      --接收后,变成弃号
      Update 排队叫号队列 Set 排队状态 = 2 Where 业务类型 = 0 And 业务id = c_挂号.Id;
    End Loop;
  End If;

  --挂号费用结算
  If Nvl(n_挂号金额, 0) <> 0 Then
  
    If Nvl(n_剩余金额, 0) >= Nvl(n_挂号金额, 0) And Nvl(卡类别id_In, 0) = 0 And n_结算模式 = 0 Then
      --冲预交方式结算
      n_预交金额 := n_挂号金额;
      For r_Deposit In c_Deposit(n_病人id, v_冲预交病人ids) Loop
        If r_Deposit.金额 - n_预交金额 < 0 Then
          n_冲预交 := r_Deposit.金额;
        Else
          n_冲预交 := n_预交金额;
        End If;
      
        If r_Deposit.Id <> 0 Then
          --第一次冲预交(填上结帐ID,金额为0)
          Update 病人预交记录 Set 冲预交 = 0, 结帐id = n_结帐id, 结算性质 = 4 Where ID = r_Deposit.Id;
        End If;
        --冲上次剩余额
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交, 结帐id,
           缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结算序号, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, d_Date,
                 v_人员姓名, v_人员编号, n_冲预交, n_结帐id, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结算序号, 4
          From 病人预交记录
          Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
      
        --更新病人预交余额
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) - n_冲预交
        Where 病人id = r_Deposit.病人id And 性质 = 1 And 类型 = 1
        Returning 预交余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (r_Deposit.病人id, 1, -1 * n_冲预交, 1);
          n_返回值 := -1 * n_冲预交;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 病人余额
          Where 病人id = r_Deposit.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
        End If;
      
        --检查是否已经处理完
        If r_Deposit.金额 < n_预交金额 Then
          n_预交金额 := n_预交金额 - r_Deposit.金额;
        Else
          n_预交金额 := 0;
        End If;
      
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
    
      --检查金额是否足够
      If Abs(n_预交金额) > 0 Then
        v_Error := '病人门诊预存帐户不足,请立即充值。';
        Raise Err_Custom;
      End If;
    Elsif Nvl(卡类别id_In, 0) > 0 And n_结算模式 = 0 Then
    
      Begin
        Select 结算方式, 名称 Into v_结算方式, v_三方名称 From 医疗卡类别 Where ID = 卡类别id_In;
      Exception
        When Others Then
          v_三方名称 := Null;
      End;
      If v_三方名称 Is Null Then
        v_Error := '未找到三方接口,请在医疗卡类别中设置.';
        Raise Err_Custom;
      End If;
      If v_结算方式 Is Null Then
        v_Error := v_三方名称 || '未设置对应的结算方式,请在医疗卡类别中设置.';
        Raise Err_Custom;
      End If;
      --第三方接口支付
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交, 结帐id,
         缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结算序号, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, Null, 4, 1, 病人id, 病人科室id, Null, v_结算方式, Null, '医生站挂号接收', Null, Null, Null, 登记时间,
               操作员姓名, 操作员编号, n_挂号金额, 结帐id, 缴款组id, 卡类别id_In, Null, 卡号_In, 交易流水号_In, 交易说明_In, v_三方名称, Null, 结帐id, 4
        From 门诊费用记录
        Where NO = No_In And 记录性质 = 4 And 记录状态 = 1 And 序号 = 1;
    
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + n_挂号金额
      Where 收款员 = v_人员姓名 And 性质 = 1 And 结算方式 = v_结算方式;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (v_人员姓名, v_结算方式, 1, n_挂号金额);
      End If;
    Else
      If n_结算模式 = 1 Then
        --记帐
        For c_费用 In (Select 实收金额, 病人科室id, 开单部门id, 执行部门id, 收入项目id
                     From 门诊费用记录
                     Where 记录性质 = 4 And 记录状态 = 1 And NO = No_In And Nvl(记帐费用, 0) = 1) Loop
          --病人余额
          Update 病人余额
          Set 费用余额 = Nvl(费用余额, 0) + Nvl(c_费用.实收金额, 0)
          Where 病人id = Nvl(n_病人id, 0) And 性质 = 1 And 类型 = 1;
        
          If Sql%RowCount = 0 Then
            Insert Into 病人余额
              (病人id, 性质, 类型, 费用余额, 预交余额)
            Values
              (n_病人id, 1, 1, Nvl(c_费用.实收金额, 0), 0);
          End If;
        
          --病人未结费用
          Update 病人未结费用
          Set 金额 = Nvl(金额, 0) + Nvl(c_费用.实收金额, 0)
          Where 病人id = n_病人id And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(c_费用.病人科室id, 0) And
                Nvl(开单部门id, 0) = Nvl(c_费用.开单部门id, 0) And Nvl(执行部门id, 0) = Nvl(c_费用.执行部门id, 0) And
                收入项目id + 0 = c_费用.收入项目id And 来源途径 + 0 = 1;
        
          If Sql%RowCount = 0 Then
            Insert Into 病人未结费用
              (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
            Values
              (n_病人id, Null, Null, c_费用.病人科室id, c_费用.开单部门id, c_费用.执行部门id, c_费用.收入项目id, 1, Nvl(c_费用.实收金额, 0));
          End If;
        End Loop;
      
      Else
      
        --生成划价单收费(允许的情况下)
        v_Temp := zl_GetSysParameter('允许挂号划价单', 1260);
        If Nvl(v_Temp, '0') <> '1' Then
          v_Error := '病人剩余款额' || To_Char(Nvl(n_剩余金额, 0), '0.00') || ' 不足挂号金额' || To_Char(Nvl(n_挂号金额, 0), '0.00') ||
                     '，不能完成预约接收。';
          Raise Err_Custom;
        End If;
      
        Select Nextno(13) Into v_划价no From Dual;
      
        Insert Into 门诊费用记录
          (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数,
           数次, 发药窗口, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 记帐费用, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 摘要,
           结论, 缴款组id)
          Select 病人费用记录_Id.Nextval, 1, v_划价no, 0, a.序号, a.从属父号, a.价格父号, a.门诊标志, a.病人id, a.标识号, a.付款方式, a.姓名, a.性别, a.年龄,
                 a.病人科室id, a.费别, a.收费类别, a.收费细目id, b.计算单位, a.付数, a.数次, Null, Null, Null, a.收入项目id, a.收据费目, a.标准单价,
                 a.应收金额, a.实收金额, 0, v_人员姓名, a.执行部门id, v_人员姓名, d_Date, d_Date, a.执行部门id, 0, '挂号:' || No_In, a.结论, n_组id
          From 门诊费用记录 A, 收费项目目录 B
          Where a.收费细目id = b.Id And a.No = No_In And a.记录性质 = 4 And a.记录状态 = 1;
      
        --挂号本身不收费
        Update 门诊费用记录
        Set 应收金额 = 0, 实收金额 = 0, 结帐金额 = 0
        Where NO = No_In And 记录性质 = 4 And 记录状态 = 1;
      End If;
    End If;
  End If;

  --病人挂号汇总(只处理一次,且单独收取病历费不处理)
  If n_出诊记录id Is Null Then
    Open c_Regist;
    Fetch c_Regist
      Into r_Regist;
    Update 病人挂号汇总
    Set 已挂数 = Nvl(已挂数, 0) + 1, 其中已接收 = Nvl(其中已接收, 0) + 1
    Where 日期 = Trunc(d_Date) And Nvl(科室id, 0) = Nvl(r_Regist.科室id, 0) And Nvl(项目id, 0) = Nvl(r_Regist.项目id, 0) And
          Nvl(医生姓名, '医生') = Nvl(r_Regist.医生姓名, '医生') And Nvl(医生id, 0) = Nvl(r_Regist.医生id, 0) And
          (号码 = r_Regist.号码 Or 号码 Is Null);
    If Sql%RowCount = 0 Then
      Insert Into 病人挂号汇总
        (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数)
      Values
        (Trunc(d_Date), r_Regist.科室id, r_Regist.项目id, r_Regist.医生姓名, r_Regist.医生id, r_Regist.号码, 1);
    End If;
    Close c_Regist;
  Else
    Open c_Registnew;
    Fetch c_Registnew
      Into r_Registnew;
    Update 临床出诊记录 Set 已挂数 = Nvl(已挂数, 0) + 1, 其中已接收 = Nvl(其中已接收, 0) + 1 Where ID = n_出诊记录id;
    Update 病人挂号汇总
    Set 已挂数 = Nvl(已挂数, 0) + 1, 其中已接收 = Nvl(其中已接收, 0) + 1
    Where 日期 = Trunc(d_Date) And Nvl(科室id, 0) = Nvl(r_Registnew.科室id, 0) And Nvl(项目id, 0) = Nvl(r_Registnew.项目id, 0) And
          Nvl(医生姓名, '医生') = Nvl(r_Registnew.医生姓名, '医生') And Nvl(医生id, 0) = Nvl(r_Registnew.医生id, 0) And
          (号码 = r_Registnew.号码 Or 号码 Is Null);
    If Sql%RowCount = 0 Then
      Insert Into 病人挂号汇总
        (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数)
      Values
        (Trunc(d_Date), r_Registnew.科室id, r_Registnew.项目id, r_Registnew.医生姓名, r_Registnew.医生id, r_Registnew.号码, 1);
    End If;
    Close c_Registnew;
  End If;

  --病人担保信息
  If n_病人id Is Not Null Then
    Update 病人信息
    Set 担保人 = Null, 担保额 = Null, 担保性质 = Null
    Where 病人id = n_病人id And Exists (Select 1
           From 病人担保记录
           Where 病人id = n_病人id And 主页id Is Not Null And
                 登记时间 = (Select Max(登记时间) From 病人担保记录 Where 病人id = n_病人id));
    If Sql%RowCount > 0 Then
      Update 病人担保记录
      Set 到期时间 = d_Date
      Where 病人id = n_病人id And 主页id Is Not Null And Nvl(到期时间, d_Date) > d_Date;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人预约挂号_接收;
/

--119437:胡俊勇,2018-01-09,临床相关消息修改
CREATE OR REPLACE Procedure Zl_病人接诊
(
  病人id_In     In 病人信息.病人id%Type,
  No_In         In 病人挂号记录.No%Type,
  执行部门id_In In 病人挂号记录.执行部门id%Type,
  执行人_In     In 病人挂号记录.执行人%Type,
  诊室_In       In 病人挂号记录.诊室%Type := Null,
  标记急诊_In   In 病人挂号记录.急诊%Type := 0,
  回诊_In       In Integer := 0,
  接收时间_In   In 病人挂号记录.接收时间%Type := Null
  --参数：
  --    执行部门id_In：用于续诊时，确定与原挂号科室不同的续诊执行科室;正常接诊时传入空
  --    标记急诊_in:强制续诊时，是否将挂号单标记为急诊(不改变费用)
  --    回诊_In:0-非回诊就诊;1-回诊就诊
) As
  d_Cur        Date;
  n_执行部门id 病人挂号记录.执行部门id%Type;
  v_诊室       病人挂号记录.诊室%Type;
  v_医生       病人挂号记录.执行人%Type;
  n_挂号id     病人挂号记录.Id%Type;
Begin
  If 接收时间_In Is Null Then
    d_Cur := Sysdate;
  Else
    d_Cur := 接收时间_In;
  End If;

  If 执行部门id_In Is Null Then
    --正常接诊
    Update 病人信息 Set 就诊时间 = d_Cur, 就诊状态 = 2 Where 病人id = 病人id_In;
  
    Update 门诊费用记录
    Set 执行人 = 执行人_In, 执行状态 = 2, 执行时间 = d_Cur, 发药窗口 = 诊室_In
    Where NO = No_In And 记录性质 = 4 And 记录状态 In (1, 3);
  
    Update 病人挂号记录
    Set 执行人 = 执行人_In, 执行状态 = 2, 执行时间 = d_Cur, 诊室 = 诊室_In, 续诊科室id = 执行部门id_In, 记录标志 = 0
    Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;
  Elsif Nvl(回诊_In, 0) = 1 Then
    --回诊就诊
    --1.检查是否科室;医生;诊室发生了改变的
    Select ID, 执行部门id, 执行人, 诊室
    Into n_挂号id, n_执行部门id, v_医生, v_诊室
    From 病人挂号记录
    Where NO = No_In And 记录性质 = 1 And 记录状态 = 1 And Rownum <= 1;
  
    If n_执行部门id = 执行部门id_In Then
      Update 病人挂号记录
      Set 执行人 = 执行人_In, 执行时间 = Sysdate, 诊室 = 诊室_In, 记录标志 = 0
      Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;
    
      Update 门诊费用记录
      Set 执行人 = 执行人_In, 执行状态 = 2, 执行时间 = d_Cur, 发药窗口 = 诊室_In
      Where NO = No_In And 记录性质 = 4 And 记录状态 In (1, 3);
    
      Update 病人挂号记录
      Set 执行人 = 执行人_In, 执行时间 = d_Cur, 诊室 = 诊室_In, 记录标志 = 0, 急诊 = Decode(标记急诊_In, 1, 1, 急诊)
      Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;
    
    Else
      Insert Into 病人转诊记录
        (挂号id, NO, 申请科室id, 申请医生, 接收科室id, 接收医生, 接收时间)
        Select ID, No_In, 执行部门id, 执行人, 执行部门id_In, 执行人_In, d_Cur From 病人挂号记录 Where NO = No_In;
    
      Update 门诊费用记录
      Set 执行人 = 执行人_In, 病人科室id = 执行部门id_In, 执行部门id = 执行部门id_In, 执行状态 = 2, 执行时间 = d_Cur, 发药窗口 = 诊室_In
      Where NO = No_In And 记录性质 = 4 And 记录状态 In (1, 3);
    
      Update 病人挂号记录
      Set 执行人 = 执行人_In, 执行部门id = 执行部门id_In, 执行状态 = 2, 执行时间 = d_Cur, 诊室 = 诊室_In, 续诊科室id = 执行部门id_In, 记录标志 = 0,
          急诊 = Decode(标记急诊_In, 1, 1, 急诊)
      Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;
    End If;
  Else
    --强制接诊
    Insert Into 病人转诊记录
      (挂号id, NO, 申请科室id, 申请医生, 接收科室id, 接收医生, 接收时间)
      Select ID, No_In, 执行部门id, 执行人, 执行部门id_In, 执行人_In, d_Cur From 病人挂号记录 Where NO = No_In;
  
    Update 病人信息 Set 就诊时间 = d_Cur, 就诊状态 = 2 Where 病人id = 病人id_In;
  
    Update 门诊费用记录
    Set 执行人 = 执行人_In, 病人科室id = 执行部门id_In, 执行部门id = 执行部门id_In, 执行状态 = 2, 执行时间 = d_Cur, 发药窗口 = 诊室_In
    Where NO = No_In And 记录性质 = 4 And 记录状态 In (1, 3);
  
    Update 病人挂号记录
    Set 执行人 = 执行人_In, 执行部门id = 执行部门id_In, 执行状态 = 2, 执行时间 = d_Cur, 诊室 = 诊室_In, 续诊科室id = 执行部门id_In, 记录标志 = 0,
        急诊 = Decode(标记急诊_In, 1, 1, 急诊)
    Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;
  End If;
  --接诊后,排队叫号更新为弃号
  Update 排队叫号队列
  Set 排队状态 = 2, 回诊序号 = Null
  Where 业务类型 = 0 And 业务id = (Select ID From 病人挂号记录 Where NO = No_In);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人接诊;
/

--119437:胡俊勇,2018-01-09,临床相关消息修改
--120005:廖思奇,2018-01-16,Zl_病人医嘱执行_拒绝执行 pacs调用时发送Zlhis_Cis_037消息
CREATE OR REPLACE Procedure Zl_病人医嘱执行_拒绝执行
(
  医嘱id_In     In 病人医嘱执行.医嘱id%Type,
  发送号_In     In 病人医嘱执行.发送号%Type,
  操作员编号_In In 人员表.编号%Type := Null,
  操作员姓名_In In 人员表.姓名%Type := Null,
  执行部门id_In In 门诊费用记录.执行部门id%Type := 0,
  拒绝原因_In   In 病人医嘱发送.执行说明%Type := Null
  --参数：医嘱ID_IN=单独执行的医嘱ID，检验组合为显示的检验项目的ID。
) Is
  Cursor c_Advice Is
    Select A.ID, A.相关id, A.诊疗类别, A.病人id, A.主页id, A.挂号单,B.No,A.病人来源 From 病人医嘱记录 A,病人医嘱发送 B 
    Where ID = 医嘱id_In And A.Id=B.医嘱id;
  r_Advice c_Advice%RowType;

  v_Temp     Varchar2(255); 
  v_人员姓名 人员表.姓名%Type;
 
Begin
  --当前操作人员
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then 
    v_人员姓名 := 操作员姓名_In;
  Else
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;

  Open c_Advice;
  Fetch c_Advice
    Into r_Advice;

  If r_Advice.诊疗类别 = 'C' And r_Advice.相关id Is Not Null Then
    --包含一并采集的所有检验项目
    Update 病人医嘱发送
    Set 执行状态 = 2, 完成人 = v_人员姓名, 完成时间 = Sysdate, 执行说明 = 拒绝原因_In
    Where 发送号 + 0 = 发送号_In And 医嘱id In (Select ID From 病人医嘱记录 Where 相关id = r_Advice.相关id);  
  Else
    --包含附加手术,检验部位,以及其它独立医嘱;麻醉和中药煎法是单独安排
    Update 病人医嘱发送
    Set 执行状态 = 2, 完成人 = v_人员姓名, 完成时间 = Sysdate, 执行说明 = 拒绝原因_In
    Where 发送号 + 0 = 发送号_In And 医嘱id In (Select ID
                                        From 病人医嘱记录
                                        Where ID = 医嘱id_In
                                        Union All
                                        Select ID
                                        From 病人医嘱记录
                                        Where 相关id = 医嘱id_In And 诊疗类别 In ('F', 'D'));
  End If;
  If r_Advice.诊疗类别 = 'D' Then
    Select 工作性质 Into v_Temp From 部门性质说明 Where 部门id = 执行部门id_In And 工作性质 = '检查';
    If v_Temp = '检查' Then
      b_Message.Zlhis_Cis_037(r_Advice.病人id, r_Advice.主页id, r_Advice.挂号单, 发送号_In, 医嘱id_In, r_Advice.No, r_Advice.病人来源);
    End If;
  End If;
  Close c_Advice;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱执行_拒绝执行;
/

--119437:胡俊勇,2018-01-09,临床相关消息修改
CREATE OR REPLACE Procedure Zl_病人医嘱记录_回退
(
  医嘱id_In     In 病人医嘱记录.Id%Type,
  Flag_In       In Number := 0,
  医嘱内容_In   In 病人医嘱记录.医嘱内容%Type := Null,
  操作类型_In   In 病人医嘱状态.操作类型%Type := Null,
  操作员编号_In In 人员表.编号%Type := Null,
  操作员姓名_In In 人员表.姓名%Type := Null
  --功能：回退住院医嘱的状态操作或发送操作(回退重整操作通过调用Zl_病人医嘱记录_批量回退来进行)
  --参数：医嘱ID_IN=一组医嘱ID
  --      FLAG_IN=附加数据。回退停止：0=清除执行终止时间,1=保留现有的执行终止时间。
  --      医嘱内容_IN=该过程被批量回退调用时才用，用于错误提示。
  --      操作类型_IN=该过程被批量回退调用时才用，用于核对回退数据。0-回退发送,n=回退具体医嘱操作
) Is
  --包含指定医嘱的操作记录,第一条为要回退的内容(状态操作优先)
  --临嘱不回退发送后的自动停止,在回退发送时自动回退停止操作
  Cursor c_Rolladvice Is
    Select b.操作人员, b.操作时间, 0 As 发送号, Null As NO, b.操作类型, 0 As 执行状态, Sysdate + Null As 首次时间, Sysdate + Null As 末次时间,
           a.上次执行时间, a.医嘱期效, a.诊疗类别 As 类别, a.诊疗项目id, Null As 类型, a.病人id, a.主页id, a.婴儿, 0 As 记录性质, 0 As 门诊记帐, 0 As 开嘱科室id,
           a.审核标记, a.开嘱医生, a.执行科室id, Nvl(a.相关id, a.Id) As 组id, a.相关id, a.Id As 医嘱id, -null As 发送数次, Null As 样本条码
    From 病人医嘱记录 A, 病人医嘱状态 B
    Where a.Id = b.医嘱id And (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In) And
          (Nvl(a.医嘱期效, 0) = 0 And b.操作类型 Not In (1, 2, 3) Or Nvl(a.医嘱期效, 0) = 1 And b.操作类型 Not In (1, 2, 3, 8))
    Union
    Select b.发送人 As 操作人员, b.发送时间 As 操作时间, b.发送号, b.No, -null As 操作类型, b.执行状态, b.首次时间, b.末次时间, a.上次执行时间, a.医嘱期效, c.类别,
           a.诊疗项目id, c.操作类型 As 类型, a.病人id, a.主页id, a.婴儿, b.记录性质, b.门诊记帐, a.开嘱科室id, a.审核标记, a.开嘱医生, a.执行科室id,
           Nvl(a.相关id, a.Id) As 组id, a.相关id, a.Id As 医嘱id, b.发送数次, b.样本条码
    From 病人医嘱记录 A, 病人医嘱发送 B, 诊疗项目目录 C
    Where a.Id = b.医嘱id And a.诊疗项目id = c.Id And (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In)
    Order By 操作时间 Desc, 发送号;
  r_Rolladvice c_Rolladvice%RowType;

  --方式同c_Rolladvice，只取发送部份用了自动回退处理
  Cursor c_Rollsend(v_发送号 病人医嘱发送.发送号%Type) Is
    Select Distinct b.医嘱id, b.发送时间 As 操作时间, b.发送号, b.执行状态, a.诊疗类别 As 类别, c.当前病区id As 病人病区id, a.病人科室id,
                    b.执行部门id As 执行科室id
    From 病人医嘱记录 A, 病人医嘱发送 B, 病案主页 C
    Where a.Id = b.医嘱id And b.发送号 = v_发送号 And a.病人id = c.病人id And a.主页id = c.主页id And
          (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In)
    Order By b.发送时间 Desc, b.发送号;

  --根据医嘱及发送NO求出本次回退要销帐的费用记录
  --一组医嘱并不是都填写了发送记录,且可能NO不同(药品有,用法煎法不一定有)
  --不管发送记录的计费状态(可能无需计费),有费用记录自然关联出来
  --费用只求价格父号为空的,以便取序号销帐
  --只管记录状态为1的费用,对于已销帐或部份销帐的记录,不再处理；其中"记录状态=3"的读取出来仅用于判断，不处理。
  Cursor c_Rollmoneyout
  (
    v_发送号    病人医嘱发送.发送号%Type,
    v_医嘱id    病人医嘱记录.Id%Type,
    t_Adviceids t_Numlist
  ) Is
    Select /*+ Rule*/
     a.Id, a.记录状态, a.No, a.序号, a.收费类别, a.执行状态, d.跟踪在用, a.执行部门id, a.记录性质
    From 门诊费用记录 A, Table(t_Adviceids) B, 病人医嘱发送 C, 材料特性 D
    Where c.医嘱id = b.Column_Value And c.发送号 = v_发送号 And a.医嘱序号 = b.Column_Value And
          (a.医嘱序号 = v_医嘱id Or Nvl(v_医嘱id, 0) = 0) And a.记录状态 In (0, 1, 3) And a.No = c.No And a.记录性质 = c.记录性质 And
          a.价格父号 Is Null And a.收费细目id = d.材料id(+)
    Order By a.No, a.序号;

  Cursor c_Rollmoneyin
  (
    v_发送号    病人医嘱发送.发送号%Type,
    v_医嘱id    病人医嘱记录.Id%Type,
    t_Adviceids t_Numlist
  ) Is
    Select /*+ Rule*/
     a.Id, a.记录状态, a.No, a.序号, a.收费类别, a.执行状态, d.跟踪在用, a.执行部门id, a.记录性质
    From 住院费用记录 A, Table(t_Adviceids) B, 病人医嘱发送 C, 材料特性 D
    Where c.医嘱id = b.Column_Value And c.发送号 = v_发送号 And a.医嘱序号 = b.Column_Value And
          (a.医嘱序号 = v_医嘱id Or Nvl(v_医嘱id, 0) = 0) And a.记录状态 In (0, 1, 3) And a.No = c.No And a.记录性质 = c.记录性质 And
          a.价格父号 Is Null And a.收费细目id = d.材料id(+)
    Order By a.No, a.序号;

  --取发送住院记帐时自动发放的卫材(还没有退料的)
  Cursor c_Stuff_Drug(v_费用id 药品收发记录.费用id%Type) Is
    Select ID
    From 药品收发记录
    Where 费用id = v_费用id And (记录状态 = 1 Or Mod(记录状态, 3) = 0) And 审核人 Is Not Null
    Order By 药品id;

  --用于处理特殊医嘱的回退
  Cursor c_Patilog
  (
    v_病人id 病人变动记录.病人id%Type,
    v_主页id 病人变动记录.主页id%Type
  ) Is
    Select *
    From 病人变动记录
    Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 Is Null
    Order By 开始时间 Desc;
  r_Patilog c_Patilog%RowType;

  Cursor c_Adviceids Is
    Select ID From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
  t_Adviceids t_Numlist;

  v_医嘱状态     病人医嘱记录.医嘱状态%Type;
  v_医嘱期效     病人医嘱记录.医嘱期效%Type;
  v_费用no       病人医嘱发送.No%Type;
  v_费用序号     Varchar2(255);
  v_末次时间     病人医嘱发送.末次时间%Type;
  v_重整时间     病人医嘱状态.操作时间%Type;
  v_操作类型     诊疗项目目录.操作类型%Type;
  v_执行频率     诊疗项目目录.执行频率%Type;
  v_上次时间     病人医嘱记录.上次执行时间%Type;
  v_执行时间     病人医嘱记录.执行时间方案%Type;
  v_开始执行时间 病人医嘱记录.开始执行时间%Type;
  v_上次打印时间 病人医嘱记录.上次打印时间%Type;
  v_频率间隔     病人医嘱记录.频率间隔%Type;
  v_间隔单位     病人医嘱记录.间隔单位%Type;
  v_发送号       病人医嘱发送.发送号%Type;
  n_护理等级id   病人变动记录.护理等级id%Type;
  d_开始时间     病人变动记录.开始时间%Type;
  d_操作时间     病人医嘱状态.操作时间%Type;
  v_Tmp发送号    病人医嘱发送.发送号%Type;
  n_执行         Number;

  Intdigit   Number(3);
  v_Update   Number(1);
  v_Count    Number(5);
  v_Temp     Varchar2(2000);
  v_人员编号 人员表.编号%Type;
  v_人员姓名 人员表.姓名%Type;
  v_Time     Varchar2(4000);
  n_Blndo    Number;

  v_Error Varchar2(2000);
  Err_Custom Exception;

  Function Checkmoneyundo
  (
    v_No       住院费用记录.No%Type,
    v_记录性质 住院费用记录.记录性质%Type,
    v_序号     住院费用记录.序号%Type,
    n_场合     Number := 0 --0住院，1门诊
  ) Return Number Is
    n_Num      Number;
    n_执行状态 Number;
  Begin
    n_Num := 0;
    If n_场合 = 0 Then
      Select Nvl(Sum(Nvl(付数, 1) * 数次), 0) As 数量
      Into n_Num
      From 住院费用记录
      Where NO = v_No And 记录性质 = v_记录性质 And 序号 = v_序号 And 记录状态 In (2, 3);
      Select Nvl(执行状态, 0)
      Into n_执行状态
      From 住院费用记录
      Where NO = v_No And 记录性质 = v_记录性质 And 序号 = v_序号 And 记录状态 = 3;
    Else
      Select Nvl(Sum(Nvl(付数, 1) * 数次), 0) As 数量
      Into n_Num
      From 门诊费用记录
      Where NO = v_No And 记录性质 = v_记录性质 And 序号 = v_序号 And 记录状态 In (2, 3);
      Select Nvl(执行状态, 0)
      Into n_执行状态
      From 门诊费用记录
      Where NO = v_No And 记录性质 = v_记录性质 And 序号 = v_序号 And 记录状态 = 3;
    End If;
    If n_Num <> 0 Then
      n_Num := 1;
    End If;
    --如果主记录是已执行（部分执行的）则不自动退。
    If n_执行状态 <> 0 Then
      n_Num := 0;
    End If;
    Return(n_Num);
  End;
Begin
  v_Tmp发送号 := -1;
  Open c_Rolladvice;
  Loop
    Fetch c_Rolladvice
      Into r_Rolladvice;
    If c_Rolladvice%RowCount = 0 Then
      Close c_Rolladvice;
      v_Error := Nvl(医嘱内容_In, '该医嘱') || '当前没有可以回退的内容。';
      Raise Err_Custom;
    End If;
    Exit When c_Rolladvice%NotFound;
    Exit When d_操作时间 <> r_Rolladvice.操作时间 And d_操作时间 Is Not Null;
    d_操作时间 := r_Rolladvice.操作时间;
  
    --批量回退调用时判断
    If 医嘱内容_In Is Not Null Then
      If Nvl(r_Rolladvice.操作类型, 0) <> Nvl(操作类型_In, 0) Then
        v_Error := Nvl(医嘱内容_In, '该医嘱') || '不能与当前医嘱一起回退，可能该医嘱已经执行了其他操作。';
        Raise Err_Custom;
      End If;
    End If;
  
    --一组发送号只执行一次
    If v_Tmp发送号 <> r_Rolladvice.发送号 Then
      v_Tmp发送号 := r_Rolladvice.发送号;
      n_执行      := 1;
    Else
      n_执行 := 0;
    End If;
  
    If n_执行 = 1 Then
      Open c_Adviceids;
      Fetch c_Adviceids Bulk Collect
        Into t_Adviceids;
      Close c_Adviceids;
    
      If r_Rolladvice.发送号 = 0 Then
        --回退医嘱状态操作(以时间关键字)
        --4-作废；5-重整；6-暂停；7-启用；8-停止；9-确认停止；10-皮试结果;13-停嘱申请
        ------------------------------------------------------------------
        --最多只能退回到校对状态
        If r_Rolladvice.操作类型 = 3 Then
          v_Error := Nvl(医嘱内容_In, '该医嘱') || '当前处于通过校对状态，不能再回退。';
          Raise Err_Custom;
        Elsif r_Rolladvice.操作类型 = 4 And Nvl(r_Rolladvice.婴儿, 0) = 0 Then
          If r_Rolladvice.类别 = 'H' Then
            Select 操作类型, 执行频率 Into v_操作类型, v_执行频率 From 诊疗项目目录 Where ID = r_Rolladvice.诊疗项目id;
            If v_操作类型 = '1' And v_执行频率 = '2' Then
              v_Error := '护理等级作废后不能再回退。';
              Raise Err_Custom;
            End If;
          End If;
        End If;
      
        --检查是否回退最近次重整之前的操作
        If r_Rolladvice.操作类型 <> 5 Then
          --取最后重整时间
          Select Nvl(医嘱重整时间, To_Date('1900-01-01', 'YYYY-MM-DD'))
          Into v_重整时间
          From 病案主页
          Where 病人id = r_Rolladvice.病人id And 主页id = r_Rolladvice.主页id;
        
          If r_Rolladvice.操作时间 < v_重整时间 Then
            v_Error := '该病人最近次重整之前的操作不能再回退。';
            Raise Err_Custom;
          End If;
        End If;
      
        --删除(该组医嘱)最近的状态操作记录
        Delete /*+ Rule*/
        From 病人医嘱状态
        Where 医嘱id In (Select Column_Value From Table(t_Adviceids)) And 操作时间 = r_Rolladvice.操作时间;
      
        --取删除后应恢复的医嘱状态
        Select 操作类型
        Into v_医嘱状态
        From 病人医嘱状态
        Where 操作时间 = (Select Max(操作时间) From 病人医嘱状态 Where 医嘱id = 医嘱id_In) And 医嘱id = 医嘱id_In;
      
        --恢复(该组医嘱)回退后的状态
        Update 病人医嘱记录 Set 医嘱状态 = v_医嘱状态 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
      
        --其它额外的处理
        If r_Rolladvice.操作类型 = 8 Then
          --被超期发送收回过的医嘱 ，如果是销帐申请模式，则判断对应的“病人费用销帐”申请是否取消，是则允许回退，否则不允许，
          --                       如果是产生负数费用模式，则不允许再回退。
          --可能超期发送收回时被全部收回(无上次执行时间)
          Select /*+ Rule*/
           Nvl(Count(*), 0)
          Into v_Count
          From 病人医嘱记录 A, 病人医嘱发送 B
          Where b.医嘱id = a.Id And (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In) And
                b.发送号 =
                (Select Max(发送号) From 病人医嘱发送 Where 医嘱id In (Select Column_Value From Table(t_Adviceids))) And
                a.执行终止时间 Is Not Null And ((a.上次执行时间 < b.末次时间) Or (a.上次执行时间 Is Null And b.末次时间 Is Not Null));
          If v_Count > 0 Then
            If zl_GetSysParameter('超期收回产生负数费用', 1254) = '1' Then
              v_Error := Nvl(医嘱内容_In, '该医嘱') || '已被超期发送收回，不能再撤消停止操作。';
              Raise Err_Custom;
            Else
              --如果已经取消销帐申请，则允许回退.
              Select Count(1)
              Into v_Count
              From 病人费用销帐 A, 住院费用记录 B, 病人医嘱记录 C
              Where a.费用id = b.Id And c.Id = b.医嘱序号 And (c.Id = 医嘱id_In Or c.相关id = 医嘱id_In);
              If v_Count > 0 Then
                v_Error := Nvl(医嘱内容_In, '该医嘱') || '已被超期发送收回，不能再撤消停止操作。';
                Raise Err_Custom;
              Else
                --得到上次执行时间等信息
                Select 上次执行时间, 执行时间方案, 开始执行时间, 上次打印时间, 频率间隔, 间隔单位
                Into v_上次时间, v_执行时间, v_开始执行时间, v_上次打印时间, v_频率间隔, v_间隔单位
                From 病人医嘱记录
                Where ID = 医嘱id_In;
                v_上次时间 := To_Date(To_Char(v_上次时间 + 1 / 24 / 60 / 60, 'yyyy-MM-dd hh24:mi:ss'), 'yyyy-MM-dd hh24:mi:ss');
              
                --修改上次执行时间为收回后的末次执行时间。
                v_末次时间 := Null;
                Begin
                  --一组医嘱的发送首末时间相同,一并给药是取最小的
                  --取相关ID为NULL的医嘱的发送记录的时间
                  --但给药途径或中药用法可能未填写发送记录
                  Select /*+ Rule*/
                   末次时间, 发送号
                  Into v_末次时间, v_发送号
                  From 病人医嘱发送
                  Where 医嘱id In (Select Column_Value From Table(t_Adviceids)) And
                        发送号 = (Select Max(发送号)
                               From 病人医嘱发送
                               Where 医嘱id In (Select Column_Value From Table(t_Adviceids))) And Rownum = 1;
                Exception
                  When Others Then
                    Null;
                End;
                Update 病人医嘱记录 Set 上次执行时间 = v_末次时间 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
              
                Select Count(1) Into v_Count From 病人医嘱发送 Where 医嘱id = 医嘱id_In And 发送号 = v_发送号;
                If v_Count > 0 Then
                  --还原医嘱执行时间
                  Select Zl_Adviceexetimes(医嘱id_In, v_上次时间, v_末次时间, v_执行时间, v_开始执行时间, v_上次打印时间, v_频率间隔, v_间隔单位, 0)
                  Into v_Time
                  From Dual;
                  Insert Into 医嘱执行时间
                    (要求时间, 医嘱id, 发送号)
                    Select To_Date(Column_Value, 'yyyy-mm-dd hh24:mi:ss'), 医嘱id_In, v_发送号
                    From Table(f_Str2list(v_Time));
                End If;
              End If;
            End If;
          End If;
        
          --护理等级变动，后续有其他变动时，不允许回退
          If r_Rolladvice.类别 = 'H' And Nvl(r_Rolladvice.婴儿, 0) = 0 Then
            Select 操作类型, 执行频率 Into v_操作类型, v_执行频率 From 诊疗项目目录 Where ID = r_Rolladvice.诊疗项目id;
            If v_操作类型 = '1' And v_执行频率 = '2' Then
              Select Count(*), Max(a.护理等级id), Max(a.开始时间)
              Into v_Count, n_护理等级id, d_开始时间
              From 病人变动记录 A
              Where a.病人id = r_Rolladvice.病人id And a.主页id = r_Rolladvice.主页id And a.开始原因 = 6 And a.终止时间 Is Null And
                    a.附加床位 = 0;
              --如果没有找到最后一条是护理等级变动则禁止
              If v_Count = 0 Then
                --医嘱护理等级和入住时候的护理等级一致时要单独判断
                Select Count(*)
                Into v_Count
                From 病人变动记录 A
                Where a.病人id = r_Rolladvice.病人id And a.主页id = r_Rolladvice.主页id And a.开始原因 = 6;
                If v_Count > 0 Then
                  v_Error := '由于护理等级医嘱停止后该病人已经产生了其他变动记录,不能回退该医嘱的停止操作。';
                  Raise Err_Custom;
                End If;
              Else
                --如果n_护理等级ID为Null，则检查是否是当前回退的医嘱对应的变动记录,目的是有多个护理等级医嘱时要求按顺序回退。
                --如果n_护理等级ID不为Null，则有可能是校对下一条护理等级时，自动停止的，未产生变动记录，
                --     则需要检查当前最后一条变动的护理等级ID是否是当前医嘱的护理等级ID,目的是有多个护理等级医嘱时要求按顺序回退，如果是则不需要再撤销最后一次变动，直接回退医嘱即可。
                If n_护理等级id Is Null Then
                  Select Count(*)
                  Into v_Count
                  From 病人变动记录 B, 病人医嘱计价 C
                  Where b.病人id = r_Rolladvice.病人id And b.主页id = r_Rolladvice.主页id And c.医嘱id = 医嘱id_In And
                        c.收费细目id = b.护理等级id And b.终止时间 = d_开始时间 And b.终止原因 = 6 And b.附加床位 = 0;
                Else
                  --开始时间只取分钟对比，校对的时候护理等级的开始时间是医嘱开始时间+当前时间的秒钟
                  Select Count(*)
                  Into v_Count
                  From 病人医嘱计价 C, 病人医嘱记录 A
                  Where a.Id = c.医嘱id And a.Id = 医嘱id_In And c.收费细目id = n_护理等级id And
                        a.开始执行时间 = To_Date(To_Char(d_开始时间, 'yyyy-mm-dd hh24:mi'), 'yyyy-mm-dd hh24:mi');
                End If;
                If v_Count = 0 Then
                  v_Error := '您回退的医嘱不是最后一条护理等级医嘱，请将后面的护理等级医嘱作废后再回退本条医嘱。';
                  Raise Err_Custom;
                End If;
              
                If n_护理等级id Is Null Then
                  --当前操作人员
                  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
                    v_人员编号 := 操作员编号_In;
                    v_人员姓名 := 操作员姓名_In;
                  Else
                    v_Temp     := Zl_Identity;
                    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
                    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
                    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
                    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
                  End If;
                
                  Zl_病人变动记录_Undo(r_Rolladvice.病人id, r_Rolladvice.主页id, v_人员编号, v_人员姓名, '1', Null, Null, '护理等级变动');
                End If;
              End If;
            End If;
          End If;
        
          If r_Rolladvice.类别 = 'Z' And Instr(',9,10,', ',' || r_Rolladvice.类型 || ',') > 0 And
             Nvl(r_Rolladvice.婴儿, 0) = 0 Then
            --回退病况医嘱时，调用变动记录回退
            Zl_病人变动记录_Undo(r_Rolladvice.病人id, r_Rolladvice.主页id, v_人员编号, v_人员姓名, Null, Null, Null, '病况变动');
          End If;
        
          --回退医嘱停止时,清空停嘱医生和时间,如果是实习医师申请后审核的，则恢复待审核状态
          Update 病人医嘱记录
          Set 执行终止时间 = Decode(Flag_In, 1, 执行终止时间, Null), 停嘱医生 = Null, 停嘱时间 = Null,
              审核标记 = Decode(r_Rolladvice.审核标记, 3, 2, r_Rolladvice.审核标记)
          Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
        Elsif r_Rolladvice.操作类型 = 9 Then
          --回退医嘱确认停止时,检查是否已打印停嘱时间
          Select /*+ Rule*/
           Count(*)
          Into v_Count
          From 病人医嘱打印
          Where 打印标记 = 1 And 医嘱id In (Select Column_Value From Table(t_Adviceids));
          If v_Count > 0 Then
            v_Error := Nvl(医嘱内容_In, '该医嘱') || '的停嘱时间已经打印，不能再撤消确认停止操作。';
            Raise Err_Custom;
          End If;
        
          --回退医嘱确认停止时,清空停嘱医生和时间
          Update 病人医嘱记录 Set 确认停嘱时间 = Null, 确认停嘱护士 = Null Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
        Elsif r_Rolladvice.操作类型 = 10 Then
          --回退标注皮试结果,同时删除过敏登记(+)或(-),根据记录时间
          --过敏的记录与医嘱操作无观，不需要处理
          Delete From 病人过敏记录
          Where 病人id = r_Rolladvice.病人id And Nvl(主页id, 0) = Nvl(r_Rolladvice.主页id, 0) And 记录时间 = r_Rolladvice.操作时间 And
                Nvl(结果, 0) = 0;
        
          Update 病人医嘱记录 Set 皮试结果 = Null Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
        Elsif r_Rolladvice.操作类型 = 13 Then
          If Instr(r_Rolladvice.开嘱医生, '/') > 0 Then
            Update 病人医嘱记录 Set 审核标记 = 1 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
          Else
            Update 病人医嘱记录 Set 审核标记 = Null Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
          End If;
        End If;
      Else
        --回退医嘱发送(以发送号关键字)
        ------------------------------------------------------------------
        --当前操作人员
        v_Temp     := Zl_Identity;
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
        v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
        v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
      
        --检查是否是输液配液记录，并是否已经锁定，如果查询有数据说明是配液记录
        Begin
          Select Decode(Max(是否锁定), 1, 1, 0)
          Into v_Count
          From 输液配药记录
          Where 医嘱id = 医嘱id_In And 发送号 = r_Rolladvice.发送号;
        Exception
          When Others Then
            v_Count := -1;
        End;
      
        If v_Count = 1 Then
          v_Error := '医嘱"' || 医嘱内容_In || '"是输液药品，已经被输液配置中心锁定，不能回退发送。';
          Raise Err_Custom;
        Elsif v_Count = 0 Then
          Zl_输液配药记录_医嘱回退(医嘱id_In, r_Rolladvice.发送号, v_人员姓名, Sysdate);
        End If;
      
        --检查是否存在未审核的销帐申请
        Select Count(*)
        Into v_Count
        From 病人医嘱记录 A, 病人医嘱发送 B, 住院费用记录 C, 病人费用销帐 D
        Where (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In) And a.Id = b.医嘱id And b.医嘱id = c.医嘱序号 And c.Id = d.费用id And
              c.记录状态 In (0, 1, 3) And d.状态 = 0;
      
        If v_Count > 0 Then
          v_Error := '医嘱"' || 医嘱内容_In || '"存在未审核的销帐申请，请取消或审核销帐申请后再回退发送。';
          Raise Err_Custom;
        End If;
      
        --检查医嘱是否存在有效的医嘱附费
        Select Count(*)
        Into v_Count
        From 病人医嘱附费 A, 住院费用记录 B
        Where a.医嘱id = b.医嘱序号 And a.No = b.No And b.记录状态 = 1 And b.实收金额 <> 0 And a.发送号 = r_Rolladvice.发送号 And
              a.医嘱id In (Select Column_Value From Table(t_Adviceids));
        If v_Count > 0 Then
          v_Error := '该医嘱下还存在附费项目，请先冲销。';
          Raise Err_Custom;
        End If;
      
        --本科发送自动执行时，回退也自动回退执行(仅护士站有此功能)
        --非跟踪在用的卫材医嘱，同普通医嘱执行处理
        Select 医嘱期效 Into v_医嘱期效 From 病人医嘱记录 Where ID = 医嘱id_In;
        If Substr(zl_GetSysParameter('本科执行自动完成', 1254), v_医嘱期效 + 1, 1) = '1' Then
          Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into Intdigit From Dual;
        
          For r_Rollsend In c_Rollsend(r_Rolladvice.发送号) Loop
            If Nvl(r_Rollsend.执行状态, 0) = 1 And
               (Nvl(r_Rollsend.执行科室id, 0) = Nvl(r_Rollsend.病人病区id, 0) Or
                Nvl(r_Rollsend.执行科室id, 0) = Nvl(r_Rollsend.病人科室id, 0)) Then
            
              --医嘱的执行状态
              Update 病人医嘱发送 Set 执行状态 = 0 Where 发送号 = r_Rollsend.发送号 And 医嘱id = r_Rollsend.医嘱id;
              v_Update := 1;
            
              If r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 0 Then
                --费用的执行状态
                For r_Rollmoney In c_Rollmoneyin(r_Rollsend.发送号, r_Rollsend.医嘱id, t_Adviceids) Loop
                  n_Blndo := 0;
                  If r_Rollmoney.记录状态 <> 3 Then
                    n_Blndo := 1;
                  Else
                    n_Blndo := Checkmoneyundo(r_Rollmoney.No, r_Rollmoney.记录性质, r_Rollmoney.序号);
                  End If;
                  If n_Blndo > 0 Then
                    If Not (r_Rollmoney.收费类别 = '4' And Nvl(r_Rollmoney.跟踪在用, 0) = 1) And
                       Not r_Rollmoney.收费类别 In ('5', '6', '7') Then
                      --普通费用直接取消执行状态，不含药品和跟踪在用的卫材
                      Update 住院费用记录
                      Set 执行状态 = 0, 执行时间 = Null, 执行人 = Null
                      Where NO = r_Rollmoney.No And 记录性质 = r_Rolladvice.记录性质 And 记录状态 = r_Rollmoney.记录状态 And
                            Nvl(价格父号, 序号) = r_Rollmoney.序号 And 医嘱序号 = r_Rollsend.医嘱id;
                    Elsif r_Rollmoney.收费类别 = '4' And Nvl(r_Rollmoney.跟踪在用, 0) = 1 Then
                      --跟踪在用的卫材，才自动退料
                      For r_Stuff In c_Stuff_Drug(r_Rollmoney.Id) Loop
                        Zl_材料收发记录_部门退料(r_Stuff.Id, v_人员姓名, Sysdate, Null, Null, Null, Null, 0, v_人员姓名);
                      End Loop;
                    Elsif r_Rollmoney.收费类别 In ('5', '6', '7') Then
                      --住院科室发药的药品自动退药
                      If r_Rollmoney.执行部门id = r_Rollsend.病人病区id Or r_Rollmoney.执行部门id = r_Rollsend.病人科室id Then
                        For r_Drug In c_Stuff_Drug(r_Rollmoney.Id) Loop
                          Zl_药品收发记录_部门退药(r_Drug.Id, v_人员姓名, Sysdate, Null, Null, Null, Null, Null, Null, Intdigit, 2);
                        End Loop;
                      End If;
                    End If;
                  End If;
                End Loop;
              Else
                --住院病人费用发送到门诊的情况，病人来源都是住院的
                For r_Rollmoney In c_Rollmoneyout(r_Rollsend.发送号, r_Rollsend.医嘱id, t_Adviceids) Loop
                  n_Blndo := 0;
                  If r_Rollmoney.记录状态 <> 3 Then
                    n_Blndo := 1;
                  Else
                    n_Blndo := Checkmoneyundo(r_Rollmoney.No, r_Rollmoney.记录性质, r_Rollmoney.序号, 1);
                  End If;
                  If n_Blndo > 0 Then
                    If Not (r_Rollmoney.收费类别 = '4' And Nvl(r_Rollmoney.跟踪在用, 0) = 1) And
                       Not r_Rollmoney.收费类别 In ('5', '6', '7') Then
                      --普通费用直接取消执行状态，不含药品和跟踪在用的卫材
                      Update 门诊费用记录
                      Set 执行状态 = 0, 执行时间 = Null, 执行人 = Null
                      Where NO = r_Rollmoney.No And 记录性质 = r_Rolladvice.记录性质 And 记录状态 = r_Rollmoney.记录状态 And
                            Nvl(价格父号, 序号) = r_Rollmoney.序号 And 医嘱序号 = r_Rollsend.医嘱id;
                    Elsif r_Rollmoney.收费类别 = '4' And Nvl(r_Rollmoney.跟踪在用, 0) = 1 Then
                      --跟踪在用的卫材，才自动退料
                      For r_Stuff In c_Stuff_Drug(r_Rollmoney.Id) Loop
                        Zl_材料收发记录_部门退料(r_Stuff.Id, v_人员姓名, Sysdate, Null, Null, Null, Null, 0, v_人员姓名);
                      End Loop;
                    Elsif r_Rollmoney.收费类别 In ('5', '6', '7') Then
                      --本科室发药的药品自动退药
                      If r_Rollmoney.执行部门id = r_Rollsend.病人病区id Or r_Rollmoney.执行部门id = r_Rollsend.病人科室id Then
                        For r_Drug In c_Stuff_Drug(r_Rollmoney.Id) Loop
                          Zl_药品收发记录_部门退药(r_Drug.Id, v_人员姓名, Sysdate, Null, Null, Null, Null, Null, Null, Intdigit, 1);
                        End Loop;
                      End If;
                    End If;
                  End If;
                End Loop;
              End If;
            End If;
          End Loop;
        End If;
        ------------------------------------------------------------------
        --被超期收回的长期药品医嘱不允许回退(再退费用就多退了)
        If Nvl(r_Rolladvice.医嘱期效, 0) = 0 Then
          If r_Rolladvice.上次执行时间 Is Not Null And r_Rolladvice.末次时间 Is Not Null Then
            If r_Rolladvice.上次执行时间 < r_Rolladvice.末次时间 Then
              v_Error := Nvl(医嘱内容_In, '该医嘱') || '最近超期发送的内容已被收回，不能再回退。';
              Raise Err_Custom;
            End If;
          Elsif r_Rolladvice.上次执行时间 Is Null And r_Rolladvice.末次时间 Is Not Null Then
            --长嘱可能被全部超期收回
            v_Error := Nvl(医嘱内容_In, '该医嘱') || '未被发送，或发送的内容已被全部超期收回，不能再回退。';
            Raise Err_Custom;
          End If;
        End If;
      
        If Nvl(r_Rolladvice.执行状态, 0) In (1, 3) And v_Update <> 1 Then
          --1-完全执行;3-正在执行
          v_Error := Nvl(医嘱内容_In, '该医嘱') || '最近发送的内容已经执行或正在执行，不能回退。';
          Raise Err_Custom;
        Else
          --如果相关医嘱已执行，则也要限制回退（例如：检验的采集方式）
          Select /*+ Rule*/
           Count(1)
          Into v_Count
          From 病人医嘱发送
          Where 医嘱id In (Select Column_Value From Table(t_Adviceids)) And 执行状态 In (1, 3) And
                发送号 =
                (Select Max(发送号) From 病人医嘱发送 Where 医嘱id In (Select Column_Value From Table(t_Adviceids)));
          If v_Count > 0 Then
            v_Error := Nvl(医嘱内容_In, '该医嘱') || '最近发送的内容已经执行或正在执行，不能回退。';
            Raise Err_Custom;
          End If;
        End If;
      
        ------------------------------------------------------------------
        --将该组医嘱的费用销帐(按一组医嘱可能有不同NO处理)
        --如果原始费用已被销帐(或部分销帐),调用过程中有判断
        v_费用no   := Null;
        v_费用序号 := Null;
        If r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 0 Then
          For r_Rollmoney In c_Rollmoneyin(r_Rolladvice.发送号, Null, t_Adviceids) Loop
            --对应的费用已执行
            If Nvl(r_Rollmoney.执行状态, 0) <> 0 Then
              v_Error := Nvl(医嘱内容_In, '该医嘱') || '发送的费用单据"' || r_Rollmoney.No || '"中的内容已被部分或完全执行，不能回退。';
              Raise Err_Custom;
            End If;
            n_Blndo := 0;
            If r_Rollmoney.记录状态 <> 3 Then
              n_Blndo := 1;
            Else
              n_Blndo := Checkmoneyundo(r_Rollmoney.No, r_Rollmoney.记录性质, r_Rollmoney.序号);
            End If;
            If n_Blndo > 0 Then
              --这种仅用于判断部分退药
              If v_费用no <> r_Rollmoney.No And v_费用序号 Is Not Null Then
                Zl_住院记帐记录_Delete(v_费用no, Substr(v_费用序号, 2), v_人员编号, v_人员姓名, 2, 0, 0);
                v_费用序号 := Null;
              End If;
              v_费用no   := r_Rollmoney.No;
              v_费用序号 := v_费用序号 || ',' || r_Rollmoney.序号;
            End If;
          End Loop;
        Else
          For r_Rollmoney In c_Rollmoneyout(r_Rolladvice.发送号, Null, t_Adviceids) Loop
            --对应的费用已执行
            If Nvl(r_Rollmoney.执行状态, 0) <> 0 And Not (Nvl(r_Rollmoney.执行状态, 0) = -1 And Nvl(r_Rollmoney.记录状态, 0) = 0) Then
              v_Error := Nvl(医嘱内容_In, '该医嘱') || '发送的费用单据"' || r_Rollmoney.No || '"中的内容已被部分或完全执行，不能回退。';
              Raise Err_Custom;
            End If;
            --收费单据已收费
            If r_Rollmoney.记录状态 = 1 And Not (r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 1) Then
              v_Error := Nvl(医嘱内容_In, '该医嘱') || '发送的门诊单据"' || r_Rollmoney.No || '"已收费，不能回退。';
              Raise Err_Custom;
            End If;
            n_Blndo := 0;
            If r_Rollmoney.记录状态 <> 3 Then
              n_Blndo := 1;
            Else
              n_Blndo := Checkmoneyundo(r_Rollmoney.No, r_Rollmoney.记录性质, r_Rollmoney.序号, 1);
            End If;
            If n_Blndo > 0 Then
              --这种仅用于判断部分退药
              If v_费用no <> r_Rollmoney.No And v_费用序号 Is Not Null Then
                If r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 1 Then
                  --住院发送为门诊记帐(如果是门诊医生发送为门诊记帐，门诊医嘱没有回退功能)
                  Zl_门诊记帐记录_Delete(v_费用no, v_费用序号, v_人员编号, v_人员姓名);
                Else
                  Zl_门诊划价记录_Delete(v_费用no, Substr(v_费用序号, 2));
                End If;
                v_费用序号 := Null;
              End If;
              v_费用no   := r_Rollmoney.No;
              v_费用序号 := v_费用序号 || ',' || r_Rollmoney.序号;
            End If;
          End Loop;
        End If;
        If v_费用序号 Is Not Null And v_费用no Is Not Null Then
          v_费用序号 := Substr(v_费用序号, 2);
          If r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 0 Then
            Zl_住院记帐记录_Delete(v_费用no, v_费用序号, v_人员编号, v_人员姓名, 2, 0, 0);
          Elsif r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 1 Then
            --住院发送为门诊记帐(如果是门诊医生发送为门诊记帐，门诊医嘱没有回退功能)
            Zl_门诊记帐记录_Delete(v_费用no, v_费用序号, v_人员编号, v_人员姓名);
          Else
            Zl_门诊划价记录_Delete(v_费用no, v_费用序号);
          End If;
        End If;
        --输血医嘱先删除病人医嘱附费
        Delete From 病人医嘱附费 Where 发送号 = r_Rolladvice.发送号 And 医嘱id = 医嘱id_In;
      
        --删除医嘱执行时间 (仅主医嘱ID才产生了记录)
        Delete From 医嘱执行时间 Where 发送号 = r_Rolladvice.发送号 And 医嘱id = 医嘱id_In;
      
        --删除发送记录(该组医嘱的)
        Delete /*+ Rule*/
        From 病人医嘱发送
        Where 发送号 = r_Rolladvice.发送号 And 医嘱id In (Select Column_Value From Table(t_Adviceids));
      
        --标记(该组医嘱)上次执行时间(以上次发送的末次执行时间)
        --所有长嘱(包括持续性长嘱)发送时都填写了末次时间
        --临嘱可能没有，且只可能发送了一次。
        v_末次时间 := Null;
        Begin
          --一组医嘱的发送首末时间相同,一并给药是取最小的
          --取相关ID为NULL的医嘱的发送记录的时间
          --但给药途径或中药用法可能未填写发送记录
          Select /*+ Rule*/
           末次时间
          Into v_末次时间
          From 病人医嘱发送
          Where 医嘱id In (Select Column_Value From Table(t_Adviceids)) And
                发送号 =
                (Select Max(发送号) From 病人医嘱发送 Where 医嘱id In (Select Column_Value From Table(t_Adviceids))) And
                Rownum = 1;
        Exception
          When Others Then
            Null;
        End;
        Update 病人医嘱记录 Set 上次执行时间 = v_末次时间 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
      
        --回退临嘱发送时，同时自动回退停止
        If Nvl(r_Rolladvice.医嘱期效, 0) = 1 Then
          --删除(该组临嘱)最近的停止状态操作记录
          Delete /*+ Rule*/
          From 病人医嘱状态
          Where 医嘱id In (Select Column_Value From Table(t_Adviceids)) And
                操作时间 = (Select Max(操作时间) From 病人医嘱状态 Where 医嘱id = 医嘱id_In) And 操作类型 = 8;
          --r_RollAdvice.操作时间:因发送时间可能不与自动停止时间相同。
        
          --取删除后应恢复的医嘱状态
          Select 操作类型
          Into v_医嘱状态
          From 病人医嘱状态
          Where 操作时间 = (Select Max(操作时间) From 病人医嘱状态 Where 医嘱id = 医嘱id_In) And 医嘱id = 医嘱id_In;
        
          --恢复(该组医嘱)回退后的状态
          Update 病人医嘱记录
          Set 医嘱状态 = v_医嘱状态, 执行终止时间 = Null, 停嘱医生 = Null, 停嘱时间 = Null
          Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
        End If;
      
        --住院特殊医嘱发送后的回退(3-转科;5-出院;6-转院,11-死亡)
        If r_Rolladvice.类别 = 'Z' And Instr(',3,5,6,11,', ',' || r_Rolladvice.类型 || ',') > 0 And
           Nvl(r_Rolladvice.婴儿, 0) = 0 Then
          Open c_Patilog(r_Rolladvice.病人id, r_Rolladvice.主页id);
          Fetch c_Patilog
            Into r_Patilog;
          If c_Patilog%Found Then
            If r_Rolladvice.类型 = '3' And r_Patilog.开始原因 = 3 Then
              --取消病人转科状态
              If r_Patilog.开始时间 Is Null Then
                --转科医嘱的特殊处理，当一个病人有两条转科医嘱时，只能回退最近的一条,70443
                Select Count(1)
                Into v_Count
                From 病人医嘱记录 A, 诊疗项目目录 B
                Where a.诊疗项目id = b.Id And a.病人id = r_Rolladvice.病人id And a.主页id = r_Rolladvice.主页id And a.诊疗类别 = 'Z' And
                      b.操作类型 = '3' And a.医嘱状态 = 8 And
                      a.开始执行时间 > (Select 开始执行时间 From 病人医嘱记录 Where ID = 医嘱id_In);
                If v_Count = 0 Then
                  Zl_病人变动记录_Undo(r_Rolladvice.病人id, r_Rolladvice.主页id, v_人员编号, v_人员姓名, Null, Null, Null, '转科');
                Else
                  v_Error := '病人转科已经入科，不能再回退。';
                  Raise Err_Custom;
                End If;
              Else
                v_Error := '病人转科已经入科，不能再回退。';
                Raise Err_Custom;
              End If;
            Elsif r_Rolladvice.类型 In ('5', '6', '11') And r_Patilog.开始原因 = 10 Then
              --取消病人预出院状态
              Zl_病人变动记录_Undo(r_Rolladvice.病人id, r_Rolladvice.主页id, v_人员编号, v_人员姓名, Null, Null, Null, '预出院');
            End If;
          End If;
          Close c_Patilog;
        End If;
      
        --回退病历时机
        --1.特殊事件(只有一条医嘱记录)：手术，7-会诊,8-抢救,11-死亡
        If r_Rolladvice.类别 = 'F' Or r_Rolladvice.类别 = 'Z' And Instr(',7,8,11,', ',' || r_Rolladvice.类型 || ',') > 0 Then
          Zl_电子病历时机_Delete(r_Rolladvice.病人id, r_Rolladvice.主页id, '医嘱', r_Rolladvice.开嘱科室id, 医嘱id_In);
        End If;
      
        --2.额外处理：知情同意书(手术相关的知情同意需再次调用，因为附加手术或麻醉项目可能有关联的知情同意书)
        If Instr('C,D,E,F,G,K,L', r_Rolladvice.类别) > 0 Then
          For R In (Select a.Id, a.诊疗类别 From 病人医嘱记录 A Where a.Id = 医嘱id_In Or a.相关id = 医嘱id_In) Loop
            --相关id的一组医嘱不一定是这个类别的，所以要再判断一次类别
            If Instr('C,D,E,F,G,K,L', r.诊疗类别) > 0 Then
              Zl_电子病历时机_Delete(r_Rolladvice.病人id, r_Rolladvice.主页id, '医嘱', r_Rolladvice.开嘱科室id, r.Id);
            End If;
          End Loop;
        End If;
      
        --此处添加消息触发      
        If r_Rolladvice.类别 = 'E' And r_Rolladvice.操作类型 = '6' Then
          --检验
          b_Message.Zlhis_Cis_036(r_Rolladvice.病人id, r_Rolladvice.主页id, Null, r_Rolladvice.发送号, r_Rolladvice.组id,
                                  r_Rolladvice.No, 2);
        Elsif r_Rolladvice.类别 = 'D' And r_Rolladvice.相关id Is Null Then
          --检查
          b_Message.Zlhis_Cis_037(r_Rolladvice.病人id, r_Rolladvice.主页id, Null, r_Rolladvice.发送号, r_Rolladvice.组id,
                                  r_Rolladvice.No, 2);
        Elsif r_Rolladvice.类别 = 'F' And r_Rolladvice.相关id Is Null Then
          --手术
          b_Message.Zlhis_Cis_038(r_Rolladvice.病人id, r_Rolladvice.主页id, Null, r_Rolladvice.发送号, r_Rolladvice.组id,
                                  r_Rolladvice.No);
        Elsif r_Rolladvice.类别 = 'K' And r_Rolladvice.相关id Is Null Then
          --输血
          b_Message.Zlhis_Cis_039(r_Rolladvice.病人id, r_Rolladvice.主页id, Null, r_Rolladvice.发送号, r_Rolladvice.组id,
                                  r_Rolladvice.No);
        Elsif r_Rolladvice.类别 = 'Z' And r_Rolladvice.操作类型 = '6' Then
          --会诊
          b_Message.Zlhis_Cis_040(r_Rolladvice.病人id, r_Rolladvice.主页id, r_Rolladvice.发送号, r_Rolladvice.组id,
                                  r_Rolladvice.No);
        Elsif r_Rolladvice.类别 = 'Z' And r_Rolladvice.操作类型 = '8' Then
          --抢救
          b_Message.Zlhis_Cis_041(r_Rolladvice.病人id, r_Rolladvice.主页id, r_Rolladvice.发送号, r_Rolladvice.组id,
                                  r_Rolladvice.No);
        Elsif r_Rolladvice.类别 = 'Z' And r_Rolladvice.操作类型 = '11' Then
          --死亡
          b_Message.Zlhis_Cis_042(r_Rolladvice.病人id, r_Rolladvice.主页id, r_Rolladvice.发送号, r_Rolladvice.组id,
                                  r_Rolladvice.No);
        Elsif r_Rolladvice.类别 = 'E' And r_Rolladvice.操作类型 = '5' Then
          --特殊治疗
          b_Message.Zlhis_Cis_043(r_Rolladvice.病人id, r_Rolladvice.主页id, r_Rolladvice.发送号, r_Rolladvice.组id,
                                  r_Rolladvice.No);
        End If;
      
        Select Count(1)
        Into v_Count
        From 部门性质说明 A
        Where a.部门id = r_Rolladvice.执行科室id And a.工作性质 = '护理';      
        If v_Count > 0 Then
          --病区执行医嘱回退发送
          b_Message.Zlhis_Cis_044(r_Rolladvice.病人id, r_Rolladvice.主页id, r_Rolladvice.发送号, r_Rolladvice.医嘱id,
                                  r_Rolladvice.No, r_Rolladvice.发送数次, r_Rolladvice.首次时间, r_Rolladvice.末次时间,
                                  r_Rolladvice.样本条码);
        End If;
      
      End If;
    End If;
    Exit When r_Rolladvice.发送号 = 0;
  End Loop;
  Close c_Rolladvice;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱记录_回退;
/

--119437:胡俊勇,2018-01-09,临床相关消息修改
CREATE OR REPLACE Procedure Zl_病人医嘱记录_校对
(
  --功能：校对指定的医嘱 
  --参数：医嘱ID_IN=Nvl(相关ID,ID) 
  --      状态_IN=校对通过3或校对疑问2 
  --      自动校对_IN=保存之后调用自动校对,自动填写计价内容 
  --说明：一组医嘱只能调用一次,过程同时完成处理一组医嘱的校对 
  医嘱id_In     In 病人医嘱记录.Id%Type,
  状态_In       In 病人医嘱记录.医嘱状态%Type,
  校对时间_In   In 病人医嘱状态.操作时间%Type,
  校对说明_In   In 病人医嘱状态.操作说明%Type := Null,
  自动校对_In   In Number := Null,
  操作员编号_In In 人员表.编号%Type := Null,
  操作员姓名_In In 人员表.姓名%Type := Null
) Is
  --用于医嘱检查 
  v_状态       病人医嘱记录.医嘱状态%Type;
  v_期效       病人医嘱记录.医嘱期效%Type;
  v_病人id     病人医嘱记录.病人id%Type;
  v_主页id     病人医嘱记录.主页id%Type;
  v_婴儿       病人医嘱记录.婴儿%Type;
  v_医嘱内容   病人医嘱记录.医嘱内容%Type;
  v_开嘱时间   病人医嘱记录.开嘱时间%Type;
  v_开始时间   病人医嘱记录.开始执行时间%Type;
  v_开嘱医生   病人医嘱记录.开嘱医生%Type;
  v_前提id     病人医嘱记录.前提id%Type;
  v_执行标记   病人医嘱记录.执行标记%Type;
  v_执行科室id 病人医嘱记录.执行科室id%Type;
  v_标本部位   病人医嘱记录.标本部位%Type;
  v_停止时间   病人医嘱记录.开嘱时间%Type;
  v_开嘱科室id 病人医嘱记录.开嘱科室id%Type;
  n_病人科室id 病人医嘱记录.病人科室id%Type;

  --用于变更护理等级 
  v_诊疗类别   病人医嘱记录.诊疗类别%Type;
  v_诊疗项目id 病人医嘱记录.诊疗项目id%Type;
  v_操作类型   诊疗项目目录.操作类型%Type;
  v_护理等级id 病案主页.护理等级id%Type;
  v_紧急标志   病人医嘱记录.紧急标志%Type;
  v_入院方式   入院方式.名称%Type;

  v_药品等级   收费价格等级.名称%Type;
  v_卫材等级   收费价格等级.名称%Type;
  v_普通等级   收费价格等级.名称%Type;
  v_Pricegrade Varchar2(1000);
  v_站点       部门表.站点%Type;

  v_Stopadviceids 病人医嘱记录.医嘱内容%Type;
  n_Adviceid      病人医嘱记录.病人id%Type;
  n_标记          Number(18);
  --与该项目同一自动停止互斥组的项目:组中应该都是长嘱(包括当前医嘱),程序应已检查。 
  --注意应加婴儿条件,同时也应停止除当前医嘱外的其它相同诊疗项目的医嘱。 
  Cursor c_Exclude Is
    Select Distinct b.Id As 医嘱id, b.开始执行时间, b.执行终止时间, b.上次执行时间, b.开嘱医生, b.执行时间方案, b.频率间隔, b.频率次数, b.间隔单位
    From 诊疗互斥项目 A, 病人医嘱记录 B
    Where a.类型 = 3 And a.项目id = b.诊疗项目id And b.Id <> 医嘱id_In And Nvl(b.医嘱期效, 0) = 0 And b.医嘱状态 In (3, 5, 6, 7) And
          b.病人id = v_病人id And Nvl(b.主页id, 0) = Nvl(v_主页id, 0) And Nvl(b.婴儿, 0) = Nvl(v_婴儿, 0) And
          a.组编号 In (Select Distinct 组编号 From 诊疗互斥项目 Where 类型 = 3 And 项目id = v_诊疗项目id)
    Order By b.Id;
  v_终止时间 病人医嘱记录.执行终止时间%Type;

  --护理等级互斥 
  Cursor c_Nurse Is
    Select a.Id As 医嘱id, a.开始执行时间, a.执行终止时间, a.上次执行时间, a.开嘱医生
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id And a.诊疗类别 = 'H' And b.操作类型 = '1' And a.病人id = v_病人id And Nvl(a.主页id, 0) = Nvl(v_主页id, 0) And
          Nvl(a.婴儿, 0) = Nvl(v_婴儿, 0) And Nvl(a.医嘱期效, 0) = 0 And a.医嘱状态 In (3, 5, 6, 7) And a.Id <> 医嘱id_In;

  --记录入出量互斥 
  Cursor c_Patiio Is
    Select a.Id As 医嘱id, a.开始执行时间, a.执行终止时间, a.上次执行时间, a.开嘱医生
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id And a.诊疗类别 = 'Z' And b.操作类型 = '12' And a.病人id = v_病人id And Nvl(a.主页id, 0) = Nvl(v_主页id, 0) And
          Nvl(a.婴儿, 0) = Nvl(v_婴儿, 0) And Nvl(a.医嘱期效, 0) = 0 And a.医嘱状态 In (3, 5, 6, 7) And a.Id <> 医嘱id_In;

  --记录病情互斥 
  Cursor c_Patistate Is
    Select a.Id As 医嘱id, a.开始执行时间, a.执行终止时间, a.上次执行时间, a.开嘱医生
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id And a.诊疗类别 = 'Z' And b.操作类型 In ('9', '10') And a.病人id = v_病人id And
          Nvl(a.主页id, 0) = Nvl(v_主页id, 0) And Nvl(a.婴儿, 0) = Nvl(v_婴儿, 0) And Nvl(a.医嘱期效, 0) = 0 And
          a.医嘱状态 In (3, 5, 6, 7) And a.Id <> 医嘱id_In;
  --变动有效记录 
  Cursor c_Oldinfo Is
    Select b.*
    From (Select c.*
           From 病人变动记录 C
           Where c.病人id = v_病人id And c.主页id = v_主页id And
                 c.开始时间 = (Select Min(y.开始时间)
                           From 病人变动记录 Y
                           Where y.病人id = v_病人id And y.主页id = v_主页id And y.开始时间 > v_开始时间) And
                 Nvl(c.终止时间 || '', '空') =
                 (Select Nvl(Min(x.终止时间) || '', '空')
                  From 病人变动记录 X
                  Where x.病人id = v_病人id And x.主页id = v_主页id And x.开始时间 > v_开始时间)) A, 病人变动记录 B
    Where b.病人id = v_病人id And b.主页id = v_主页id And a.开始时间 = b.终止时间 And a.开始原因 = b.终止原因 And a.附加床位 = b.附加床位
    Union
    Select a.*
    From 病人变动记录 A
    Where a.病人id = v_病人id And a.主页id = v_主页id And a.终止时间 Is Null And a.开始时间 <= v_开始时间;

  Cursor c_Endinfo Is
    Select * From 病人变动记录 Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 Is Null;
  r_Oldinfo      c_Oldinfo%RowType;
  r_Endinfo      c_Endinfo%RowType;
  v_变动终止原因 病人变动记录.终止原因%Type;
  v_变动终止时间 病人变动记录.终止时间%Type;
  v_变动终止人员 病人变动记录.终止人员%Type;

  --包含病人(婴儿)的所有未停长嘱(含配方长嘱) 
  Cursor c_Needstop
  (
    v_病人id   病人医嘱记录.病人id%Type,
    v_主页id   病人医嘱记录.主页id%Type,
    v_婴儿     病人医嘱记录.婴儿%Type,
    v_Stoptime Date
  ) Is
    Select a.Id, a.诊疗类别, b.操作类型, b.执行频率
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id(+) And a.病人id = v_病人id And a.主页id = v_主页id And (v_婴儿 = -1 Or Nvl(a.婴儿, 0) = Nvl(v_婴儿, 0)) And
          Nvl(a.医嘱期效, 0) = 0 And a.医嘱状态 Not In (1, 2, 4, 8, 9) And a.开始执行时间 < v_Stoptime
    Order By a.序号;
  --包含病人(婴儿)的已停但未确认的长嘱,终止执行时间在指定时间之后 
  Cursor c_Havestop
  (
    v_病人id   病人医嘱记录.病人id%Type,
    v_主页id   病人医嘱记录.主页id%Type,
    v_婴儿     病人医嘱记录.婴儿%Type,
    v_Stoptime Date
  ) Is
    Select ID
    From 病人医嘱记录
    Where 病人id = v_病人id And 主页id = v_主页id And (v_婴儿 = -1 Or Nvl(婴儿, 0) = Nvl(v_婴儿, 0)) And Nvl(医嘱期效, 0) = 0 And
          医嘱状态 = 8 And 执行终止时间 > v_Stoptime And 开始执行时间 < v_Stoptime
    Order By 序号;

  --取一组医嘱的计价内容 
  Cursor c_Price Is
    Select a.Id, b.收费项目id, b.收费数量, b.从属项目, b.费用性质, b.收费方式, c.类别 As 收费类别, a.诊疗类别, e.操作类型, e.试管编码,
           Sum(Decode(Nvl(c.是否变价, 0), 1, Nvl(d.缺省价格, d.原价), Null)) As 单价
    From 病人医嘱记录 A, 诊疗收费关系 B, 收费项目目录 C, 收费价目 D, 诊疗项目目录 E
    Where a.诊疗项目id = b.诊疗项目id And b.收费项目id = c.Id And c.Id = d.收费细目id And
          ((Instr(';5;6;7;', ';' || c.类别 || ';') > 0 And d.价格等级 = v_药品等级) Or
          (Instr(';4;', ';' || c.类别 || ';') > 0 And d.价格等级 = v_卫材等级) Or
          (Instr(';4;5;6;7;', ';' || c.类别 || ';') = 0 And d.价格等级 = v_普通等级) Or
          (d.价格等级 Is Null And Not Exists
           (Select 1
             From 收费价目
             Where c.Id = 收费细目id And ((Instr(';5;6;7;', ';' || c.类别 || ';') > 0 And 价格等级 = v_药品等级) Or
                   (Instr(';4;', ';' || c.类别 || ';') > 0 And 价格等级 = v_卫材等级) Or
                   (Instr(';4;5;6;7;', ';' || c.类别 || ';') = 0 And 价格等级 = v_普通等级))))) And
          (a.相关id Is Null And a.执行标记 In (1, 2) And b.费用性质 = 1 Or
          a.标本部位 = b.检查部位 And a.检查方法 = b.检查方法 And Nvl(b.费用性质, 0) = 0 Or
          a.检查方法 Is Null And Nvl(b.费用性质, 0) = 0 And b.检查部位 Is Null And b.检查方法 Is Null) And
          a.诊疗类别 Not In ('5', '6', '7') And Nvl(a.计价特性, 0) = 0 And Nvl(a.执行性质, 0) Not In (0, 5) And c.服务对象 In (2, 3) And
          (c.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or c.撤档时间 Is Null) And Sysdate Between d.执行日期 And
          Nvl(d.终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')) And Nvl(b.收费数量, 0) <> 0 And
          Not (Nvl(c.是否变价, 0) = 1 And Nvl(Nvl(d.缺省价格, d.原价), 0) = 0) And a.诊疗项目id = e.Id And
          (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In)
    Group By a.Id, b.收费项目id, b.收费数量, b.从属项目, b.费用性质, b.收费方式, c.类别, a.诊疗类别, e.操作类型, e.试管编码;

  Cursor c_Pati(v_病人id 病人信息.病人id%Type) Is
    Select * From 病人信息 Where 病人id = v_病人id;
  r_Pati c_Pati%RowType;

  v_材料id 采血管类型.材料id%Type;

  --其它临时变量 
  v_Count    Number;
  v_Date     Date;
  v_Temp     Varchar2(255);
  v_Par停嘱  Varchar2(255);
  v_人员编号 人员表.编号%Type;
  v_人员姓名 人员表.姓名%Type;
  v_叮嘱执行 Varchar2(5);

  v_Error Varchar2(255);
  Err_Custom Exception;

  Function Getadvicetext(v_医嘱id 病人医嘱记录.Id%Type) Return Varchar2 Is
    v_Text 病人医嘱记录.医嘱内容%Type;
    v_类别 病人医嘱记录.诊疗类别%Type;
    v_配方 Number;
  Begin
    Select 诊疗类别, 医嘱内容 Into v_类别, v_Text From 病人医嘱记录 Where ID = v_医嘱id;
    If v_类别 = 'E' Then
      --西药，中成药的医嘱内容 
      Begin
        Select 诊疗类别, Decode(诊疗类别, '7', v_Text, 医嘱内容)
        Into v_类别, v_Text
        From 病人医嘱记录
        Where 相关id = v_医嘱id And 诊疗类别 In ('5', '6', '7') And Rownum = 1;
      Exception
        When Others Then
          Null;
      End;
      If v_类别 = '7' Then
        v_配方 := 1;
      End If;
    End If;
    If Length(v_Text) > 30 Then
      v_Text := Substr(v_Text, 1, 30) || '...';
    End If;
    If Length(v_Text) > 20 Then
      v_Text := '"' || v_Text || '"' || Chr(13) || Chr(10);
    Else
      v_Text := '"' || v_Text || '"';
    End If;
    If v_配方 = 1 Then
      v_Text := '中药配方' || v_Text;
    End If;
    Return(v_Text);
  End;
Begin
  --检查医嘱状态是否正确:并发操作 
  Begin
    Select a.医嘱期效, a.医嘱状态, a.开嘱时间, a.开嘱医生, a.开始执行时间, a.病人id, a.主页id, a.婴儿, a.医嘱内容, a.诊疗类别, a.诊疗项目id, a.前提id,
           Nvl(b.操作类型, '0'), Nvl(a.执行标记, 0), a.执行科室id, a.标本部位, a.开嘱科室id, Nvl(a.紧急标志, 0) As 紧急标志, a.病人科室id
    Into v_期效, v_状态, v_开嘱时间, v_开嘱医生, v_开始时间, v_病人id, v_主页id, v_婴儿, v_医嘱内容, v_诊疗类别, v_诊疗项目id, v_前提id, v_操作类型, v_执行标记,
         v_执行科室id, v_标本部位, v_开嘱科室id, v_紧急标志, n_病人科室id
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id(+) And a.Id = 医嘱id_In;
  Exception
    When Others Then
      Begin
        v_Error := '医嘱已被删除，不能进行校对。' || Chr(13) || Chr(10) || '这可能是并发操作引起的，请重新读取校对数据。';
        Raise Err_Custom;
      End;
  End;
  If v_状态 <> 1 Then
    v_Error := '医嘱"' || Getadvicetext(医嘱id_In) || '"不是新开的医嘱，不能通过校对。' || Chr(13) || Chr(10) || '这可能是并发操作引起的，请重新读取校对数据。';
    Raise Err_Custom;
  End If;
  --再次检查校对时间的有效性:并发操作 
  If To_Char(v_开嘱时间, 'YYYY-MM-DD HH24:MI') <= To_Char(v_开始时间, 'YYYY-MM-DD HH24:MI') Then
    If To_Char(校对时间_In, 'YYYY-MM-DD HH24:MI') < To_Char(v_开嘱时间, 'YYYY-MM-DD HH24:MI') Then
      v_Error := '医嘱"' || Getadvicetext(医嘱id_In) || '"的校对时间不能小于开嘱时间 ' || To_Char(v_开嘱时间, 'YYYY-MM-DD HH24:MI') || '。' ||
                 Chr(13) || Chr(10) || '这可能是并发操作引起的，请重新读取校对数据。';
      Raise Err_Custom;
    End If;
  Else
    If To_Char(校对时间_In, 'YYYY-MM-DD HH24:MI') < To_Char(v_开始时间, 'YYYY-MM-DD HH24:MI') Then
      v_Error := '医嘱"' || Getadvicetext(医嘱id_In) || '"的校对时间不能小于开始执行时间 ' || To_Char(v_开始时间, 'YYYY-MM-DD HH24:MI') || '。' ||
                 Chr(13) || Chr(10) || '这可能是并发操作引起的，请重新读取校对数据。';
      Raise Err_Custom;
    End If;
  End If;

  --如果要求签名，检查校对时是否有签名(并发取消签名) 
  If 状态_In = 3 Then
    Select Zl_Fun_Getsignpar(Decode(v_前提id, Null, 1, 3), v_开嘱科室id) Into v_Count From Dual;
    If v_Count = 1 Then
      --证书停用或未注册证书不进入签名环节只判断一条数据即可 
      For C In (Select a.是否停用
                From 人员证书记录 A, 人员表 B
                Where a.人员id = b.Id And b.姓名 = v_开嘱医生
                Order By a.注册时间 Desc) Loop
        If Nvl(c.是否停用, 0) = 0 Then
          Select Count(*)
          Into v_Count
          From 病人医嘱状态 A
          Where 操作类型 = 1 And 医嘱id = 医嘱id_In And
                (签名id Is Null And Exists
                 (Select 1
                  From 人员表 R, 人员性质说明 X
                  Where r.Id = x.人员id And r.姓名 = a.操作人员 And x.人员性质 = '护士') And Not Exists
                 (Select 1
                  From 人员表 R, 人员性质说明 Y
                  Where r.Id = y.人员id And r.姓名 = a.操作人员 And y.人员性质 = '医生') Or 签名id Is Not Null Or a.操作人员 <> v_开嘱医生);
          If Nvl(v_Count, 0) = 0 Then
            v_Error := '医嘱"' || Getadvicetext(医嘱id_In) || '"还没有电子签名，不能通过校对。';
            Raise Err_Custom;
          End If;
        End If;
        Exit;
      End Loop;
    End If;
  End If;

  --当前操作人员 
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
    v_人员编号 := 操作员编号_In;
    v_人员姓名 := 操作员姓名_In;
  Else
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;

  --因为可能同时：新开->自动校对->互斥自动停止,因此分别-2,-1秒 
  Select Sysdate - 1 / 60 / 60 / 24 Into v_Date From Dual;

  Update 病人医嘱记录
  Set 医嘱状态 = 状态_In, 校对护士 = v_人员姓名, 校对时间 = 校对时间_In
  Where ID = 医嘱id_In Or 相关id = 医嘱id_In;

  Insert Into 病人医嘱状态
    (医嘱id, 操作类型, 操作人员, 操作时间, 操作说明)
    Select ID, 状态_In, v_人员姓名, v_Date, 校对说明_In From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;

  --校对通过时的其它处理 
  If 状态_In = 3 Then
    --自动校对时，自动填写缺省的计价内容 
    If Nvl(自动校对_In, 0) = 1 Then
      --1.变价的计价项目,如果最低限价不为0,则缺省为最低限价,否则不加入;可再手工计价. 
      --2.对于非药嘱药品和在用卫材未定执行科室,发送时会取缺省的,可再手工设置。 
      Select Min(站点) Into v_站点 From 部门表 Where ID = n_病人科室id;
    
      v_Pricegrade := Zl_Get_Pricegrade(v_站点, v_病人id, v_主页id);
      v_药品等级   := Substr(v_Pricegrade, 1, Instr(v_Pricegrade, '|') - 1);
      v_Pricegrade := Substr(v_Pricegrade, Instr(v_Pricegrade, '|') + 1);
      v_卫材等级   := Substr(v_Pricegrade, 1, Instr(v_Pricegrade, '|') - 1);
      v_Pricegrade := Substr(v_Pricegrade, Instr(v_Pricegrade, '|') + 1);
      v_普通等级   := Substr(v_Pricegrade, 1, Instr(v_Pricegrade, '|') - 1);
      For r_Price In c_Price Loop
        --取(检验)医嘱的管码和材料,采集方式以检验项目的为准 
        v_材料id := Null;
        If r_Price.诊疗类别 = 'E' And r_Price.操作类型 = '6' Then
          Begin
            Select c.材料id
            Into v_材料id
            From 病人医嘱记录 A, 诊疗项目目录 B, 采血管类型 C
            Where a.诊疗项目id = b.Id And b.试管编码 = c.编码 And a.相关id = r_Price.Id And Rownum = 1;
          Exception
            When Others Then
              Null;
          End;
        Elsif r_Price.诊疗类别 = 'C' And r_Price.试管编码 Is Not Null Then
          Begin
            Select 材料id Into v_材料id From 采血管类型 Where 编码 = r_Price.试管编码;
          Exception
            When Others Then
              Null;
          End;
        End If;
      
        --判断处理检验试管费用的收取 
        If (Nvl(r_Price.收费方式, 0) = 1 And r_Price.收费类别 = '4' And r_Price.收费项目id = Nvl(v_材料id, 0) Or
           Not (Nvl(r_Price.收费方式, 0) = 1 And r_Price.收费类别 = '4' And Nvl(v_材料id, 0) <> 0)) Then
          Insert Into 病人医嘱计价
            (医嘱id, 收费细目id, 数量, 单价, 从项, 执行科室id, 费用性质, 收费方式)
          Values
            (r_Price.Id, r_Price.收费项目id, r_Price.收费数量, r_Price.单价, r_Price.从属项目, Null, r_Price.费用性质, r_Price.收费方式);
        End If;
      End Loop;
    End If;
  
    --自由录入的临嘱医嘱标记为停止 
    If Nvl(v_期效, 0) = 1 And v_诊疗项目id Is Null Then
      Update 病人医嘱记录
      Set 医嘱状态 = 8, 停嘱时间 = 校对时间_In, 停嘱医生 = v_开嘱医生
      Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
    
      Insert Into 病人医嘱状态
        (医嘱id, 操作类型, 操作人员, 操作时间)
        Select ID, 8, v_人员姓名, Sysdate From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
    End If;
  
    --判断是否开启叮嘱需要执行 
    v_叮嘱执行 := zl_GetSysParameter(288);
    If v_叮嘱执行 = 1 And v_诊疗项目id Is Null Then
      Insert Into 病人医嘱发送
        (医嘱id, 发送号, 记录性质, NO, 记录序号, 发送数次, 发送人, 发送时间, 执行状态, 执行部门id, 计费状态, 首次时间, 末次时间)
      Values
        (医嘱id_In, Nextno('10', '0', '', '1'), '2', Nextno('14', '0', '', '1'), '1', '1', v_人员姓名, Sysdate, '0', v_执行科室id,
         '0', Sysdate, Sysdate);
    End If;
  
    v_Par停嘱 := zl_GetSysParameter(271);
  
    --将同一自动停止互斥组中的病人其它医嘱停止(如果尚未停止) 
    For r_Exclude In c_Exclude Loop
      Select Decode(Sign(r_Exclude.开始执行时间 - v_开始时间), 1, r_Exclude.开始执行时间, v_开始时间)
      Into v_终止时间
      From Dual;
      Select Decode(Sign(r_Exclude.执行终止时间 - v_开始时间), -1, r_Exclude.执行终止时间, v_开始时间)
      Into v_终止时间
      From Dual;
      If v_Par停嘱 = '1' Then
        v_Temp := '自动停止：医嘱互斥。';
      Else
        v_Temp := Null;
      End If;
      Zl_病人医嘱记录_停止(r_Exclude.医嘱id, v_终止时间, v_开嘱医生, 1, 0, 0, Null, Null, v_Temp);
      v_Stopadviceids := v_Stopadviceids || ',' || r_Exclude.医嘱id;
    End Loop;
  
    --对一些特殊医嘱的处理 
    If v_诊疗类别 = 'H' And v_操作类型 = '1' And Nvl(v_期效, 0) = 0 Then
      --校对护理等级时,同步更改病人护理等级 
      If Nvl(v_婴儿, 0) = 0 Then
        --病人当前应处于正常住院状态 
        v_Temp := Null;
        Begin
          Select Decode(状态, 1, '等待入科', 2, '正在转科', 3, '已预出院', Null)
          Into v_Temp
          From 病案主页
          Where 病人id = v_病人id And 主页id = v_主页id;
        Exception
          When Others Then
            Null;
        End;
        If v_Temp Is Not Null Then
          v_Error := '病人当前处于' || v_Temp || '状态,医嘱"' || v_医嘱内容 || '"不能通过校对。';
          Raise Err_Custom;
        End If;
      
        Begin
          --根据收费对照处理，当前医嘱计价表还没有填写 
          --未设置时,不处理；相同时,不处理；有多个时,只取一个。 
          Select a.收费项目id
          Into v_护理等级id
          From 诊疗收费关系 A, 收费项目目录 B
          Where a.收费项目id = b.Id And b.类别 = 'H' And Nvl(b.项目特性, 0) <> 0 And a.诊疗项目id = v_诊疗项目id And Rownum = 1 And
                Not Exists
           (Select 1 From 病案主页 Where 病人id = v_病人id And 主页id = v_主页id And 护理等级id = a.收费项目id);
        Exception
          When Others Then
            Null;
        End;
      End If;
    
      --变动记录的时间加上秒，以便回退操作时区分同一分种的校对、停止等操作 
      v_开始时间 := To_Date(To_Char(v_开始时间, 'yyyy-mm-dd hh24:mi') || To_Char(Sysdate, 'ss'), 'yyyy-mm-dd hh24:mi:ss');
      If v_护理等级id Is Not Null Then
        Zl_病人变动记录_Nurse(v_病人id, v_主页id, v_护理等级id, v_开始时间, v_人员编号, v_人员姓名);
      End If;
    
      --并停止其它护理等级医嘱(护理等级应该都为"持续性"长嘱,且只有一个未停) 
      For r_Nurse In c_Nurse Loop
        Select Decode(Sign(r_Nurse.开始执行时间 - v_开始时间), 1, r_Nurse.开始执行时间, v_开始时间)
        Into v_终止时间
        From Dual;
        Select Decode(Sign(r_Nurse.执行终止时间 - v_开始时间), -1, r_Nurse.执行终止时间, v_开始时间)
        Into v_终止时间
        From Dual;
        If v_Par停嘱 = '1' Then
          v_Temp := '自动停止：护理等级。';
        Else
          v_Temp := Null;
        End If;
        Zl_病人医嘱记录_停止(r_Nurse.医嘱id, v_终止时间, v_开嘱医生, 1, 0, 0, Null, Null, v_Temp);
        Zl_病人医嘱记录_确认停止(r_Nurse.医嘱id, v_终止时间, v_人员姓名, 1);
        v_Stopadviceids := v_Stopadviceids || ',' || r_Nurse.医嘱id;
      End Loop;
    Elsif v_诊疗类别 = 'Z' And v_操作类型 In ('9', '10') And Nvl(v_期效, 0) = 0 And Nvl(v_婴儿, 0) = 0 Then
      --病重病危医嘱：9-病重;10-病危 
      --停止相同医嘱 
      For r_Patistate In c_Patistate Loop
        Select Decode(Sign(r_Patistate.开始执行时间 - v_开始时间), 1, r_Patistate.开始执行时间, v_开始时间)
        Into v_终止时间
        From Dual;
        Select Decode(Sign(r_Patistate.执行终止时间 - v_开始时间), -1, r_Patistate.执行终止时间, v_开始时间)
        Into v_终止时间
        From Dual;
        If v_Par停嘱 = '1' Then
          If v_操作类型 = '9' Then
            v_Temp := '自动停止：病重医嘱。';
          Else
            v_Temp := '自动停止：病危医嘱。';
          End If;
        Else
          v_Temp := Null;
        End If;
        Zl_病人医嘱记录_停止(r_Patistate.医嘱id, v_终止时间, v_开嘱医生, 1, 0, 0, Null, Null, v_Temp);
        v_Stopadviceids := v_Stopadviceids || ',' || r_Patistate.医嘱id;
      End Loop;
    
      b_Message.Zlhis_Patient_005(v_病人id, v_主页id);
    
      --产生病情变动 
      Open c_Oldinfo; --必须在处理之前先打开 
      Fetch c_Oldinfo
        Into r_Oldinfo;
      Open c_Endinfo;
      Fetch c_Endinfo
        Into r_Endinfo;
      If c_Endinfo%RowCount = 0 Then
        Close c_Endinfo;
        v_Error := '未发现该病人当前有效的变动记录！';
        Raise Err_Custom;
      End If;
      Select Count(*)
      Into v_Count
      From 病人变动记录
      Where 病人id = v_病人id And 主页id = v_主页id And 开始时间 Is Null And 终止时间 Is Null;
      If v_Count > 0 Then
        v_Error := '病人当前处于转科状态，请先办理转科确认或者取消转科状态。';
        Raise Err_Custom;
      End If;
    
      Update 病案主页
      Set 当前病况 = Decode(v_操作类型, '9', '重', '10', '危')
      Where 病人id = v_病人id And 主页id = v_主页id;
    
      --取消上次变动 
      If r_Oldinfo.终止时间 Is Not Null Then
        v_变动终止时间 := r_Oldinfo.终止时间;
        v_变动终止原因 := r_Oldinfo.终止原因;
        v_变动终止人员 := r_Oldinfo.终止人员;
        --取消上次变动 
        Update 病人变动记录
        Set 终止时间 = v_开始时间, 终止原因 = 13, 终止人员 = v_人员姓名, 上次计算时间 = Null
        Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 = v_变动终止时间 And 终止原因 = v_变动终止原因;
        --更新将来的记录如果有停止到将来的则删除上次计算时间 
        Update 病人变动记录
        Set 病情 = Decode(v_操作类型, '9', '重', '10', '危'), 上次计算时间 = Null
        Where 病人id = v_病人id And 主页id = v_主页id And 开始时间 > v_开始时间;
      Else
        Update 病人变动记录
        Set 终止时间 = v_开始时间, 终止原因 = 13, 终止人员 = v_人员姓名,
            上次计算时间 = Decode(Sign(Nvl(上次计算时间, v_开始时间) - v_开始时间), 1, Null, 上次计算时间)
        Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 Is Null;
      End If;
    
      While c_Oldinfo%Found Loop
        Insert Into 病人变动记录
          (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号, 操作员姓名,
           终止时间, 终止原因, 终止人员)
        Values
          (病人变动记录_Id.Nextval, v_病人id, v_主页id, v_开始时间, 13, r_Oldinfo.附加床位, r_Oldinfo.病区id, r_Oldinfo.科室id,
           r_Oldinfo.护理等级id, r_Oldinfo.床位等级id, r_Oldinfo.床号, r_Oldinfo.责任护士, r_Oldinfo.经治医师, r_Oldinfo.主治医师,
           r_Oldinfo.主任医师, Decode(v_操作类型, '9', '重', '10', '危'), v_人员编号, v_人员姓名, v_变动终止时间, v_变动终止原因, v_变动终止人员);
      
        Fetch c_Oldinfo
          Into r_Oldinfo;
      End Loop;
    
      Close c_Oldinfo;
      Close c_Endinfo;
    Elsif v_诊疗类别 = 'Z' And v_操作类型 = '12' And Nvl(v_期效, 0) = 0 And Nvl(v_婴儿, 0) = 0 Then
      --记录入出量的医嘱，互斥 
      For r_Patiio In c_Patiio Loop
        Select Decode(Sign(r_Patiio.开始执行时间 - v_开始时间), 1, r_Patiio.开始执行时间, v_开始时间)
        Into v_终止时间
        From Dual;
        Select Decode(Sign(r_Patiio.执行终止时间 - v_开始时间), -1, r_Patiio.执行终止时间, v_开始时间)
        Into v_终止时间
        From Dual;
        Zl_病人医嘱记录_停止(r_Patiio.医嘱id, v_终止时间, v_开嘱医生, 1);
        v_Stopadviceids := v_Stopadviceids || ',' || r_Patiio.医嘱id;
      End Loop;
    Elsif (v_诊疗类别 = 'Z' And v_操作类型 In ('3', '4', '5', '6', '11', '14') And
          (v_操作类型 <> '14' Or v_操作类型 = '14' And v_执行标记 = 1)) Or (v_诊疗类别 = 'F' And v_执行标记 = 1) Then
      v_Count := 0;
      If v_操作类型 = '4' Or v_操作类型 = '14' Or v_诊疗类别 = 'F' Then
        --保持与以前校对时相同的处理 
        If Nvl(v_婴儿, 0) = 0 Then
          v_Count := 1;
        End If;
      Else
        --这几个特殊医嘱在校对中停止医嘱是新加的内容，保持与发送中相同的处理 
        v_Count := 1;
        If Nvl(v_婴儿, 0) = 0 Then
          v_婴儿 := -1;
        Else
          v_婴儿 := Nvl(v_婴儿, 0);
        End If;
      End If;
      If v_Count = 1 Then
        If v_诊疗类别 = 'F' And v_执行标记 = 1 Then
          --在手术当天(取整)停止 
          v_开始时间 := Trunc(To_Date(v_标本部位, 'yyyy-mm-dd hh24:mi:ss'));
        End If;
      
        --几个特殊医嘱校对时停止前面的长嘱,在医嘱开始时终止：3-转科;4-术后;5-出院;6-转院,11-死亡,14-术前 
        For r_Needstop In c_Needstop(v_病人id, v_主页id, v_婴儿, v_开始时间) Loop
          Select Decode(Sign(开始执行时间 - v_开始时间), 1, 开始执行时间, v_开始时间)
          Into v_停止时间
          From 病人医嘱记录
          Where ID = r_Needstop.Id;
          Update 病人医嘱记录
          Set 医嘱状态 = 8, 执行终止时间 = v_停止时间, 停嘱时间 = 校对时间_In, 停嘱医生 = v_开嘱医生
          Where ID = r_Needstop.Id;
        
          Insert Into 病人医嘱状态
            (医嘱id, 操作类型, 操作人员, 操作时间)
            Select ID, 8, v_人员姓名, 校对时间_In From 病人医嘱记录 Where ID = r_Needstop.Id;
          v_Stopadviceids := v_Stopadviceids || ',' || r_Needstop.Id;
        End Loop;
        --已停止未确认的长嘱,终止时间在医嘱开始后的,调前其终止时间(同时多个特殊医嘱的情况) 
        For r_Havestop In c_Havestop(v_病人id, v_主页id, v_婴儿, v_开始时间) Loop
          Update 病人医嘱记录
          Set 执行终止时间 = Decode(Sign(开始执行时间 - v_开始时间), 1, 开始执行时间, v_开始时间), 停嘱时间 = 校对时间_In, 停嘱医生 = v_开嘱医生
          Where ID = r_Havestop.Id;
        
          --不修改停止医嘱的操作人员，因为停止时，医生可能已进行电子签名 
          Update 病人医嘱状态 Set 操作时间 = 校对时间_In Where 医嘱id = r_Havestop.Id And 操作类型 = 8;
          v_Stopadviceids := v_Stopadviceids || ',' || r_Havestop.Id;
        End Loop;
        --处理长期备用医嘱(没有执行（发送）过的标记未用） 
        Update 病人医嘱记录
        Set 执行标记 = -1
        Where 病人id = v_病人id And 主页id = v_主页id And 医嘱期效 = 0 And 执行频次 = '必要时' And 上次执行时间 Is Null And 医嘱状态 In (3, 5, 6, 7) And
              执行标记 <> -1;
        --如果是转院转科死亡出院医嘱同时处理临时备用医嘱。 
        If v_操作类型 In ('3', '5', '6', '11') Then
          Update 病人医嘱记录
          Set 执行标记 = -1
          Where 病人id = v_病人id And 主页id = v_主页id And 医嘱期效 = 1 And 执行频次 = '需要时' And 医嘱状态 = 3 And 执行标记 <> -1;
        End If;
      End If;
    Elsif v_诊疗类别 = 'Z' And v_操作类型 = '2' Then
      --对留观病人下达入院通知; 
      --预约登记的条件：1.当前无预约,2.当前是门诊留观病人（在院时也允许，因为需要先预约,入院接收时检查了必须出院后才能接收） 
      Select Count(*) Into v_Count From 病案主页 Where 病人id = v_病人id And Nvl(主页id, 0) = 0;
      If v_Count = 0 Then
        Select Count(*) Into v_Count From 病案主页 Where 病人id = v_病人id And 主页id = v_主页id And 病人性质 <> 1;
      End If;
      If v_Count = 0 Then
        Open c_Pati(v_病人id);
        Fetch c_Pati
          Into r_Pati;
        Close c_Pati;
      
        v_入院方式 := Null;
        If v_紧急标志 = 1 Then
          v_入院方式 := '急诊';
        End If;
      
        Zl_入院病案主页_Insert(1, 0, r_Pati.病人id, r_Pati.住院号, Null, r_Pati.姓名, r_Pati.性别, r_Pati.年龄, r_Pati.费别, r_Pati.出生日期,
                         r_Pati.国籍, r_Pati.民族, r_Pati.学历, r_Pati.婚姻状况, r_Pati.职业, r_Pati.身份, r_Pati.身份证号, r_Pati.出生地点,
                         r_Pati.家庭地址, r_Pati.家庭地址邮编, r_Pati.家庭电话, r_Pati.户口地址, r_Pati.户口地址邮编, r_Pati.联系人姓名, r_Pati.联系人关系,
                         r_Pati.联系人地址, r_Pati.联系人电话, r_Pati.工作单位, r_Pati.合同单位id, r_Pati.单位电话, r_Pati.单位邮编, r_Pati.单位开户行,
                         r_Pati.单位帐号, r_Pati.担保人, r_Pati.担保额, r_Pati.担保性质, v_执行科室id, Null, Null, v_入院方式, Null, Null,
                         v_开嘱医生, r_Pati.籍贯, r_Pati.区域, v_开始时间, Null, Null, r_Pati.医疗付款方式, Null, Null, Null, Null, Null,
                         Null, r_Pati.险类, v_人员编号, v_人员姓名, 0, Null, Null, 0);
      End If;
    End If;
    --医嘱停止消息的处理 
    If v_Stopadviceids Is Not Null Then
      v_Stopadviceids := Substr(v_Stopadviceids, 2);
      b_Message.Zlhis_Cis_002(v_病人id, v_主页id, Null, v_Stopadviceids);
      Select Max(a.Id)
      Into n_标记
      From 病人医嘱记录 A
      Where a.Id In (Select Column_Value From Table(f_Num2list(v_Stopadviceids))) And a.医嘱期效 = 0 And a.医嘱状态 = 8 And
            Nvl(a.执行标记, 0) <> -1 And a.病人来源 <> 3;
      If n_标记 Is Not Null Then
        Select Max(a.Id)
        Into n_Adviceid
        From 病人医嘱记录 A
        Where a.Id In (Select Column_Value From Table(f_Num2list(v_Stopadviceids))) And a.紧急标志 = 1 And a.医嘱期效 = 0 And
              a.医嘱状态 = 8 And Nvl(a.执行标记, 0) <> -1 And a.病人来源 <> 3;
        If n_Adviceid Is Not Null Then
          n_Adviceid := n_标记;
          Select Nvl(Max(0), 2)
          Into n_标记
          From 业务消息清单 A
          Where a.病人id = v_病人id And a.就诊id = v_主页id And a.类型编码 = 'ZLHIS_CIS_002' And a.优先程度 = 2 And a.是否已阅 = 0;
        Else
          Select Nvl(Max(0), 1)
          Into n_标记
          From 业务消息清单 A
          Where a.病人id = v_病人id And a.就诊id = v_主页id And a.类型编码 = 'ZLHIS_CIS_002' And a.是否已阅 = 0;
        End If;
        If n_标记 > 0 Then
          For R In (Select a.病人性质 As 性质, a.出院科室id As 科室id, a.当前病区id As 病区id
                    From 病案主页 A
                    Where a.病人id = v_病人id And a.主页id = v_主页id) Loop
            Zl_业务消息清单_Insert(v_病人id, v_主页id, r.科室id, r.病区id, r.性质, '有新停止医嘱。', '0010', 'ZLHIS_CIS_002', n_Adviceid, n_标记,
                             0, Null, r.病区id);
          End Loop;
        End If;
      End If;
    End If;
  End If;

  --病区执行医嘱校对消息
  For R In (Select a.Id, a.病人id, a.主页id
            From 病人医嘱记录 A
            Where (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In) And Exists
             (Select 1 From 部门性质说明 B Where b.部门id = a.执行科室id And b.工作性质 = '护理')) Loop
    b_Message.Zlhis_Cis_012(r.病人id, r.主页id, r.Id);
  End Loop;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱记录_校对;
/

--119437:胡俊勇,2018-01-09,临床相关消息修改
CREATE OR REPLACE Procedure Zl_病人医嘱执行_Insert
(
  医嘱id_In       In 病人医嘱执行.医嘱id%Type,
  发送号_In       In 病人医嘱执行.发送号%Type,
  要求时间_In     In 病人医嘱执行.要求时间%Type,
  本次数次_In     In 病人医嘱执行.本次数次%Type,
  执行摘要_In     In 病人医嘱执行.执行摘要%Type,
  执行人_In       In 病人医嘱执行.执行人%Type,
  执行时间_In     In 病人医嘱执行.执行时间%Type,
  单独执行_In     In Number := 0,
  自动完成_In     In Number := 0,
  执行结果_In     In 病人医嘱执行.执行结果%Type := 1,
  未执行原因_In   In 病人医嘱执行.说明%Type := Null,
  操作员编号_In   In 人员表.编号%Type := Null,
  操作员姓名_In   In 人员表.姓名%Type := Null,
  执行部门id_In   In 门诊费用记录.执行部门id%Type := 0,
  配液检查_In     In Number := 0,
  检验项目记帐_In In Number := 0,
  输液通道_In     In 病人医嘱执行.输液通道%Type := Null,
  记录来源_In     In 病人医嘱执行.记录来源%Type := Null
  --参数：医嘱ID_IN=单独执行的医嘱ID，检验组合为显示的检验项目的ID。
  --      执行结果_In=1- 完成   =0  -未执行
  --      如果是台式机调用 操作员编号_In 操作员姓名_In 这两个参数必须传入
  --执行部门id_In=仅处理指定执行部门的费用，不传或传入0时不限制执行部门
  --配液检查_In=移动工作站调用时，是否检查配液信息。
  --检验项目记帐_In=如果是检验项目时，需要记帐但不完成医嘱发送状态
) Is
  --除了要执行的主记录,还包含了附加手术,检查部位的记录
  --手术麻醉,中药煎法,采集方法单独控制,检验组合只填写在第一个项目上，但执行状态相同
  v_组id       病人医嘱记录.Id%Type;
  v_诊疗类别   病人医嘱记录.诊疗类别%Type;
  v_自动完成   Number;
  v_病人来源   病人医嘱记录.病人来源%Type;
  v_费用性质   病人医嘱发送.记录性质%Type;
  v_操作类型   诊疗项目目录.操作类型%Type;
  v_病区id     病案主页.当前病区id%Type;
  v_配液病区   Varchar2(200);
  v_Count      Number;
  v_Temp       Varchar2(255);
  v_人员编号   人员表.编号%Type;
  v_人员姓名   人员表.姓名%Type;
  n_期效       病人医嘱记录.医嘱期效%Type;
  n_诊疗项目id 病人医嘱记录.诊疗项目id%Type;
  v_叮嘱执行   Varchar2(5);
  n_本次数次   病人医嘱执行.本次数次%Type;
  n_病人id     病人医嘱记录.病人id%Type;
  n_主页id     病人医嘱记录.主页id%Type;
  v_挂号单     病人医嘱记录.挂号单%Type;

  n_执行次数   Number;
  n_剩余次数   Number;
  n_执行状态   Number;
  d_终止时间   Date;
  d_开始时间   Date;
  n_发送数次   Number;
  n_登记数次   Number;
  n_单次数次   Number;
  d_要求时间   Date;
  n_执行科室id Number;

  v_Date  Date;
  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --并发查检，防止产生多条执行记录
  Begin
    Select (a.发送数次 - c.登记次数) As 剩余数次, a.发送数次, a.执行部门id, Nvl(d.诊疗项目id, 0), c.登记次数
    Into v_Count, n_发送数次, n_执行科室id, n_诊疗项目id, n_登记数次
    From 病人医嘱发送 A,
         (Select 医嘱id_In As 医嘱id, 发送号_In As 发送号, Nvl(Sum(b.本次数次), 0) As 登记次数
           From 病人医嘱执行 B
           Where b.医嘱id = 医嘱id_In And b.发送号 = 发送号_In) C, 病人医嘱记录 D
    Where a.医嘱id = c.医嘱id And a.发送号 = c.发送号 And a.医嘱id = 医嘱id_In And a.医嘱id = d.Id And a.发送号 = 发送号_In;
  Exception
    When Others Then
      v_Count := 本次数次_In;
  End;
  v_叮嘱执行 := zl_GetSysParameter(288);
  n_本次数次 := 本次数次_In;
  If 本次数次_In > v_Count And (Not (n_诊疗项目id = 0 And v_叮嘱执行 = 1)) Then
    If Round(n_登记数次 + 本次数次_In) = 1 Then
      --表明是输血执行
      n_本次数次 := 1 - n_登记数次;
    Else
      v_Error := '由于并发操作可能已经被他人登记，请刷新后再试。';
      Raise Err_Custom;
    End If;
  End If;
  --当前操作人员
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
    v_人员编号 := 操作员编号_In;
    v_人员姓名 := 操作员姓名_In;
  Else
    Begin
      Select 姓名, 编号 Into v_人员姓名, v_人员编号 From 人员表 Where 姓名 = 执行人_In;
    Exception
      When Others Then
        v_Temp     := Zl_Identity;
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
        v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
        v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    End;
  End If;
  --对医嘱终止时间进行检查
  Select a.执行终止时间, a.开始执行时间, a.医嘱期效, a.病人id, a.主页id, a.挂号单
  Into d_终止时间, d_开始时间, n_期效, n_病人id, n_主页id, v_挂号单
  From 病人医嘱记录 A
  Where a.Id = 医嘱id_In;
  If Not d_终止时间 Is Null And n_期效 = 0 Then
    If 要求时间_In > d_终止时间 Then
      v_Error := '要求时间超过了医嘱终止时间，请确认医嘱是否提前停止！';
      Raise Err_Custom;
    End If;
  End If;
  If Not d_开始时间 Is Null Then
    If 执行时间_In < d_开始时间 Then
      v_Error := '执行时间必须大于医嘱的开始执行时间''' || To_Char(d_开始时间, 'yyyy-mm-dd HH24:mi:ss') || '''！';
      Raise Err_Custom;
    End If;
  End If;
  Select Sysdate Into v_Date From Dual;
  Select a.病人来源, 执行科室id, Nvl(a.相关id, a.Id), Nvl(a.诊疗类别, '*'), Nvl(b.操作类型, '0') 操作类型
  Into v_病人来源, v_病区id, v_组id, v_诊疗类别, v_操作类型
  From 病人医嘱记录 A, 诊疗项目目录 B
  Where a.Id = 医嘱id_In And a.诊疗项目id = b.Id(+);

  If v_病人来源 = 2 Then
    Select Decode(记录性质, 1, 1, Decode(门诊记帐, 1, 1, 2))
    Into v_费用性质
    From 病人医嘱发送
    Where 发送号 = 发送号_In And 医嘱id = 医嘱id_In;
  Else
    v_费用性质 := 1;
  End If;

  --移动系统配液检查
  If 配液检查_In = 1 Then
    --检查当前病人所属病区是否进行配液登记管理
    Select Nvl(zl_GetSysParameter(184), '') Into v_配液病区 From Dual;
  
    If v_配液病区 Is Not Null And 执行结果_In <> 0 Then
      If Instr(',' || v_配液病区 || ',', ',' || v_病区id || ',') > 0 Then
        v_病区id   := 0;
        v_配液病区 := 'Select 1 From 病区配液记录 where 医嘱ID=:YZID AND 发送号=:FSH AND 要求时间=:YQSJ';
        Begin
          Execute Immediate v_配液病区
            Into v_病区id
            Using 医嘱id_In, 发送号_In, 要求时间_In;
        Exception
          When Others Then
            Null;
        End;
        If v_病区id = 0 Then
          v_Error := '当前医嘱还未进行配液，不允许进行执行登记！';
          Raise Err_Custom;
        End If;
      End If;
    End If;
    --检查当前医嘱是否已配液
  End If;

  --病人医嘱执行
  Select Count(1)
  Into v_Count
  From 病人医嘱执行
  Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In And 执行时间 = 执行时间_In;
  If v_Count > 0 Then
    v_Error := '您指定的执行时间，已经执行过本条医嘱，请更改一个执行时间。';
    Raise Err_Custom;
  End If;
  Insert Into 病人医嘱执行
    (医嘱id, 发送号, 要求时间, 本次数次, 执行摘要, 执行人, 执行时间, 登记时间, 登记人, 执行结果, 说明, 输液通道, 执行科室id, 记录来源)
  Values
    (医嘱id_In, 发送号_In, 要求时间_In, n_本次数次, 执行摘要_In, 执行人_In, 执行时间_In, v_Date, v_人员姓名, 执行结果_In, 未执行原因_In, 输液通道_In, n_执行科室id,
     记录来源_In);

  b_Message.Zlhis_Cis_050(n_病人id, n_主页id, v_挂号单, 发送号_In, 医嘱id_In, 要求时间_In, 执行时间_In);
  
  --费用记录的执行状态进行更新
  Select Decode(a.执行状态, 1, a.发送数次, c.登记次数), Decode(a.执行状态, 1, 0, a.发送数次 - c.登记次数), c.登记次数
  Into n_执行次数, n_剩余次数, n_登记数次
  From 病人医嘱发送 A,
       (Select 医嘱id_In 医嘱id, 发送号_In 发送号, Nvl(Sum(b.本次数次), 0) As 登记次数
         From 病人医嘱执行 B
         Where b.医嘱id = 医嘱id_In And b.发送号 = 发送号_In And Nvl(b.执行结果, 1) = 1) C
  Where a.医嘱id = c.医嘱id And a.发送号 = c.发送号 And a.医嘱id = 医嘱id_In And a.发送号 = 发送号_In;
  --如果全部执行则状态为1，未执行状态为0，部分执行状态为2
  Select Decode(n_剩余次数, 0, 1, Decode(n_执行次数, 0, 0, 2)) Into n_执行状态 From Dual;

  --填写了执行状态后就标记为正在执行
  If Nvl(单独执行_In, 0) = 1 Then
    Update 病人医嘱发送
    Set 执行状态 = Decode(n_执行次数, 0, 0, 3)
    Where 执行状态 In (0, 3) And 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In;
  Else
    Update 病人医嘱发送
    Set 执行状态 = Decode(n_执行次数, 0, 0, 3)
    Where 执行状态 In (0, 3) And 发送号 + 0 = 发送号_In And
          医嘱id In (Select ID
                   From 病人医嘱记录
                   Where ID = v_组id And Nvl(诊疗类别, '*') = v_诊疗类别
                   Union All
                   Select ID
                   From 病人医嘱记录
                   Where 相关id = v_组id And Nvl(诊疗类别, '*') = v_诊疗类别);
  End If;

  --更新对应的费用执行状态为已执行(无正在执行)
  --不应该处理药品和跟踪在用的卫材
  If 执行结果_In = 1 Then
    If v_费用性质 = 2 Then
      If Nvl(单独执行_In, 0) = 1 Then
        Update 住院费用记录 A
        Set 执行状态 = n_执行状态, 执行人 = Decode(n_执行状态, 0, Null, 执行人_In), 执行时间 = Decode(n_执行状态, 0, Null, 执行时间_In)
        Where 收费类别 Not In ('5', '6', '7') And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In) And Not Exists
         (Select 1 From 材料特性 Where 材料id = a.收费细目id And 跟踪在用 = 1) And a.记录状态 In (0, 1, 3) And
              (医嘱序号, NO, 记录性质) In
              (Select 医嘱id, NO, 记录性质
               From 病人医嘱发送
               Where 执行状态 = Decode(n_执行次数, 0, 0, 3) And 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In);
      Else
        Update 住院费用记录 A
        Set 执行状态 = n_执行状态, 执行人 = Decode(n_执行状态, 0, Null, 执行人_In), 执行时间 = Decode(n_执行状态, 0, Null, 执行时间_In)
        Where 收费类别 Not In ('5', '6', '7') And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In) And Not Exists
         (Select 1 From 材料特性 Where 材料id = a.收费细目id And 跟踪在用 = 1) And a.记录状态 In (0, 1, 3) And
              (医嘱序号, NO, 记录性质) In (Select 医嘱id, NO, 记录性质
                                   From 病人医嘱发送
                                   Where 执行状态 = Decode(n_执行次数, 0, 0, 3) And 发送号 + 0 = 发送号_In And
                                         医嘱id In (Select ID
                                                  From 病人医嘱记录
                                                  Where ID = v_组id And 诊疗类别 = v_诊疗类别
                                                  Union All
                                                  Select ID
                                                  From 病人医嘱记录
                                                  Where 相关id = v_组id And 诊疗类别 = v_诊疗类别));
      End If;
    Else
      If Nvl(单独执行_In, 0) = 1 Then
        --对于门诊单据n_执行状态可能为0（登记执行情况，选择执行结果为未执行），因此需判断
        Update 门诊费用记录 A
        Set 执行状态 = n_执行状态, 执行人 = Decode(n_执行状态, 0, Null, 执行人_In), 执行时间 = Decode(n_执行状态, 0, Null, 执行时间_In)
        Where 收费类别 Not In ('5', '6', '7') And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In) And Not Exists
         (Select 1 From 材料特性 Where 材料id = a.收费细目id And 跟踪在用 = 1) And a.记录状态 In (0, 1, 3) And
              (医嘱序号, NO, 记录性质) In
              (Select 医嘱id, NO, 记录性质
               From 病人医嘱发送
               Where 执行状态 = Decode(n_执行次数, 0, 0, 3) And 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In);
      Else
        Update 门诊费用记录 A
        Set 执行状态 = n_执行状态, 执行人 = Decode(n_执行状态, 0, Null, 执行人_In), 执行时间 = Decode(n_执行状态, 0, Null, 执行时间_In)
        Where 收费类别 Not In ('5', '6', '7') And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In) And Not Exists
         (Select 1 From 材料特性 Where 材料id = a.收费细目id And 跟踪在用 = 1) And a.记录状态 In (0, 1, 3) And
              (医嘱序号, NO, 记录性质) In (Select 医嘱id, NO, 记录性质
                                   From 病人医嘱发送
                                   Where 执行状态 = Decode(n_执行次数, 0, 0, 3) And 发送号 + 0 = 发送号_In And
                                         医嘱id In (Select ID
                                                  From 病人医嘱记录
                                                  Where ID = v_组id And 诊疗类别 = v_诊疗类别
                                                  Union All
                                                  Select ID
                                                  From 病人医嘱记录
                                                  Where 相关id = v_组id And 诊疗类别 = v_诊疗类别));
      End If;
    End If;
    --检验自动完成采集
    If v_诊疗类别 = 'E' And v_操作类型 = '6' Then
      Update 病人医嘱发送 A
      Set a.采样人 = 执行人_In, a.采样时间 = 执行时间_In
      Where 医嘱id In
            (Select ID From 病人医嘱记录 Where ID = v_组id Union All Select ID From 病人医嘱记录 Where 相关id = v_组id) And
            发送号 = 发送号_In;
    End If;
  
    --执行数次达到之后自动完成执行(主要用于PDA自动执行)，如果启用了移动临床，则护士站和PDA一致。
    v_自动完成 := 自动完成_In;
    If 自动完成_In = 1 Then
      --医嘱已经是完成状态则不用再调用执行完成过程此处先设为不自动完成
      Select Max(a.执行状态) Into v_Count From 病人医嘱发送 A Where a.医嘱id = 医嘱id_In And a.发送号 = 发送号_In;
      If v_Count = 1 Then
        v_自动完成 := 0;
      End If;
      v_Count := Null;
    End If;
  
    If Nvl(v_自动完成, 0) = 0 And (v_病人来源 = 2 Or v_病人来源 = 1) And Instr('C,D', v_诊疗类别) = 0 Then
      Begin
        Execute Immediate 'Select Count(1) From ZLMBSYSTEMS'
          Into v_Count;
      Exception
        When Others Then
          Null;
      End;
      If v_Count > 0 Then
        v_自动完成 := 1;
      End If;
    End If;
  
    If Nvl(v_自动完成, 0) = 1 Or 检验项目记帐_In = 1 Then
      Begin
        Select Decode(Sign(Nvl(Sum(b.本次数次), 0) - a.发送数次), 1, 1, 0, 1, 0)
        Into v_自动完成
        From 病人医嘱发送 A, 病人医嘱执行 B
        Where a.医嘱id = b.医嘱id And a.发送号 = b.发送号 And a.执行状态 In (0, 3) And a.医嘱id = 医嘱id_In And a.发送号 = 发送号_In
        Group By a.发送数次;
      Exception
        When Others Then
          Null;
      End;
    
      If Nvl(v_自动完成, 0) = 1 Or 检验项目记帐_In = 1 Then
        Zl_病人医嘱执行_Finish(医嘱id_In, 发送号_In, Null, 单独执行_In, v_人员编号, v_人员姓名, 执行部门id_In, 检验项目记帐_In);
      End If;
    End If;
    --更新医嘱执行计价.执行状态
    If n_发送数次 > 0 Then
      Select Count(Distinct 要求时间) Into v_Count From 医嘱执行计价 Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In;
      If v_Count > 0 Then
        n_单次数次 := n_发送数次 / v_Count;
        --已执行数量+本次数次 总共能够执行多少个时间点,取最大整数
        v_Count := Ceil((n_登记数次) / n_单次数次);
        --获取执行截至要求时间
        Select 要求时间
        Into d_要求时间
        From (Select 要求时间, Rownum As 次数
               From (Select Distinct 要求时间
                      From 医嘱执行计价
                      Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In
                      Order By 要求时间))
        Where 次数 = v_Count;
      
        If Not d_要求时间 Is Null Then
          --先检查是否已经退费
          Select Max(Nvl(执行状态, 0))
          Into v_Count
          From 医嘱执行计价
          Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In And 要求时间 <= d_要求时间;
          If v_Count = 2 Then
            v_Error := '您指定的执行时间段的医嘱费用已经被退费，不允许再执行。';
            Raise Err_Custom;
          End If;
          --更新截至要求时间之前(含)的记录执行状态；
          Update 医嘱执行计价
          Set 执行状态 = 1
          Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In And 要求时间 <= d_要求时间 And Nvl(执行状态, 0) <> 2;
        End If;
      End If;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱执行_Insert;
/

--119437:胡俊勇,2018-01-09,临床相关消息修改
CREATE OR REPLACE Procedure Zl_病人医嘱执行_Delete
(
  医嘱id_In     In 病人医嘱执行.医嘱id%Type,
  发送号_In     In 病人医嘱执行.发送号%Type,
  执行时间_In   In 病人医嘱执行.执行时间%Type,
  单独执行_In   In Number := 0,
  自动取消_In   In Number := 0,
  执行部门id_In In 门诊费用记录.执行部门id%Type := 0
  --参数：医嘱ID_IN=单独执行的医嘱ID，检验组合为显示的检验项目的ID。
  --执行部门id_In=仅处理指定执行部门的费用，不传或传入0时不限制执行部门
) Is
  --除了要执行的主记录,还包含了附加手术,检查部位的记录
  --手术麻醉,中药煎法,采集方法单独控制,检验组合只填写在第一个项目上，但执行状态相同
  v_组id     病人医嘱记录.Id%Type;
  v_诊疗类别 病人医嘱记录.诊疗类别%Type;
  v_病人来源 病人医嘱记录.病人来源%Type;
  v_费用性质 病人医嘱发送.记录性质%Type;
  v_操作类型 诊疗项目目录.操作类型%Type;

  n_病人id   病人医嘱记录.病人id%Type;
  n_主页id   病人医嘱记录.主页id%Type;
  v_挂号单   病人医嘱记录.挂号单%Type;
  n_本次数次 病人医嘱执行.本次数次%Type;
  v_执行摘要 病人医嘱执行.执行摘要%Type;
  n_执行科室 病人医嘱执行.执行科室id%Type;
  v_执行人   病人医嘱执行.执行人%Type;
  v_核对人   病人医嘱执行.核对人%Type;
  n_记录来源 病人医嘱执行.记录来源%Type;

  v_自动取消 Number;
  v_执行状态 Number;

  n_执行次数 Number;
  n_剩余次数 Number;
  n_执行状态 Number;
  n_执行结果 Number;

  n_发送数次 Number;
  n_单次数次 Number;
  v_Count    Number;
  n_登记数次 Number;
  d_要求时间 Date;

  d_登记时间 病人医嘱执行.登记时间%Type;
  n_取消执行 Number;
  n_Diffday  Number(18, 3);
  Err_Custom Exception;
  v_Error Varchar2(2000);
Begin
  Select a.病人来源, Nvl(a.相关id, a.Id), Nvl(a.诊疗类别, '*'), Nvl(b.操作类型, '0') 操作类型, a.病人id, a.主页id, a.挂号单
  Into v_病人来源, v_组id, v_诊疗类别, v_操作类型, n_病人id, n_主页id, v_挂号单
  From 病人医嘱记录 A, 诊疗项目目录 B
  Where a.Id = 医嘱id_In And a.诊疗项目id = b.Id(+);

  Select Nvl(a.执行结果, 1), a.登记时间, a.要求时间, a.本次数次, a.执行摘要, a.执行科室id, a.执行人, a.核对人, a.记录来源
  Into n_执行结果, d_登记时间, d_要求时间, n_本次数次,
       
       v_执行摘要, n_执行科室, v_执行人, v_核对人, n_记录来源
  
  From 病人医嘱执行 A
  Where a.医嘱id = 医嘱id_In And a.发送号 + 0 = 发送号_In And a.执行时间 = 执行时间_In;

  -----取消执行有效天数限制
  Select Zl_To_Number(Nvl(zl_GetSysParameter(220), '999')) Into n_取消执行 From Dual;
  Select Sysdate - d_登记时间 Into n_Diffday From Dual;
  --登记时间超过取消执行天数的记录，不允许删除医嘱执行记录
  If n_Diffday > n_取消执行 Then
    v_Error := '医嘱执行登记时间超过了取消执行有效天数，不能删除医嘱执行记录！';
    Raise Err_Custom;
  End If;

  If v_病人来源 = 2 Then
    Select Decode(记录性质, 1, 1, Decode(门诊记帐, 1, 1, 2))
    Into v_费用性质
    From 病人医嘱发送
    Where 发送号 = 发送号_In And 医嘱id = 医嘱id_In;
  Else
    v_费用性质 := 1;
  End If;

  --病人医嘱执行
  Delete From 病人医嘱执行 Where 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In And 执行时间 = 执行时间_In;
  b_Message.Zlhis_Cis_051(n_病人id, n_主页id, v_挂号单, 发送号_In, 医嘱id_In, d_要求时间, 执行时间_In, n_本次数次, n_执行结果, v_执行摘要, n_执行科室,
                          v_执行人, v_核对人, n_记录来源);
  d_要求时间 := Null;

  --对于未执行的医嘱执行记录的删除，不更新医嘱发送以及费用信息的执行状态
  If n_执行结果 <> 0 Then
    Select Decode(a.执行状态, 1, a.发送数次, c.登记次数), Decode(a.执行状态, 1, 0, a.发送数次 - c.登记次数), a.发送数次, c.登记次数

    
    Into n_执行次数, n_剩余次数, n_发送数次, n_登记数次
    From 病人医嘱发送 A,
         (Select 医嘱id_In 医嘱id, 发送号_In 发送号, Nvl(Sum(b.本次数次), 0) As 登记次数
           From 病人医嘱执行 B
           Where b.医嘱id = 医嘱id_In And b.发送号 = 发送号_In And Nvl(b.执行结果, 1) <> 0) C
    Where a.医嘱id = c.医嘱id And a.发送号 = c.发送号 And a.医嘱id = 医嘱id_In And a.发送号 = 发送号_In;
  
    --如果全部执行则状态为1，未执行状态为0，部分执行状态为2
    Select Decode(n_剩余次数, 0, 1, Decode(n_执行次数, 0, 0, 2)) Into n_执行状态 From Dual;
  
    --更新医嘱执行计价.执行状态
    If n_发送数次 > 0 Then
      If n_登记数次 > 0 Then
        Select Count(Distinct 要求时间) Into v_Count From 医嘱执行计价 Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In;
        If v_Count > 0 Then
          n_单次数次 := n_发送数次 / v_Count;
          --已执行数量+本次数次 总共能够执行多少个时间点,取最大整数
          v_Count := Ceil((n_登记数次) / n_单次数次);
          --获取执行截至要求时间
          Select 要求时间
          Into d_要求时间
          From (Select 要求时间, Rownum As 次数
                 From (Select Distinct 要求时间
                        From 医嘱执行计价
                        Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In
                        Order By 要求时间))
          Where 次数 = v_Count;
        
          If Not d_要求时间 Is Null Then
            --先检查是否已经退费
            Select Max(Nvl(执行状态, 0))
            Into v_Count
            From 医嘱执行计价
            Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In And 要求时间 <= d_要求时间;
            If v_Count = 2 Then
              v_Error := '您指定的执行时间段的医嘱费用已经被退费，不允许再执行。';
              Raise Err_Custom;
            End If;
            --更新截至要求时间之前(含)的记录执行状态；
            Update 医嘱执行计价
            Set 执行状态 = 1
            Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In And 要求时间 <= d_要求时间 And Nvl(执行状态, 0) <> 2;
            Update 医嘱执行计价
            Set 执行状态 = 0
            Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In And 要求时间 > d_要求时间 And Nvl(执行状态, 0) <> 2;
          End If;
        End If;
      Else
        Update 医嘱执行计价 Set 执行状态 = 0 Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In And Nvl(执行状态, 0) <> 2;
      End If;
    End If;
  
    --如果执行情况删除了就更新执行状态
    If Nvl(单独执行_In, 0) = 1 Then
      Update 病人医嘱发送
      Set 执行状态 = Decode(n_执行次数, 0, 0, 3), 完成人 = Null, 完成时间 = Null
      Where 执行状态 = 3 And 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In;
    Else
      Update 病人医嘱发送 A
      Set 执行状态 = Decode(n_执行次数, 0, 0, 3), 完成人 = Null, 完成时间 = Null
      Where 执行状态 = 3 And 发送号 + 0 = 发送号_In And
            医嘱id In
            (Select ID From 病人医嘱记录 Where (ID = v_组id Or 相关id = v_组id) And Nvl(诊疗类别, '*') = v_诊疗类别) And Not Exists
       (Select 1 From 病人医嘱执行 Where 发送号 + 0 = 发送号_In And 医嘱id = a.医嘱id);
    End If;
    --更新对应的费用执行状态为未执行
    --不应该处理药品和跟踪在用的卫材
    If v_费用性质 = 2 Then
      If Nvl(单独执行_In, 0) = 1 Then
        Update 住院费用记录 A
        Set 执行状态 = n_执行状态, 执行人 = Decode(n_执行状态, 0, Null, 执行人), 执行时间 = Decode(n_执行状态, 0, Null, 执行时间)
        Where 收费类别 Not In ('5', '6', '7') And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In) And Not Exists
         (Select 1 From 材料特性 Where 材料id = a.收费细目id And 跟踪在用 = 1) And a.记录状态 In (0, 1, 3) And
              (医嘱序号, NO, 记录性质) In
              (Select 医嘱id, NO, 记录性质
               From 病人医嘱发送
               Where 执行状态 = Decode(n_执行次数, 0, 0, 3) And 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In);
      Else
        Update 住院费用记录 A
        Set 执行状态 = n_执行状态, 执行人 = Decode(n_执行状态, 0, Null, 执行人), 执行时间 = Decode(n_执行状态, 0, Null, 执行时间)
        Where 收费类别 Not In ('5', '6', '7') And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In) And Not Exists
         (Select 1 From 材料特性 Where 材料id = a.收费细目id And 跟踪在用 = 1) And a.记录状态 In (0, 1, 3) And
              (医嘱序号, NO, 记录性质) In
              (Select 医嘱id, NO, 记录性质
               From 病人医嘱发送
               Where 执行状态 = Decode(n_执行次数, 0, 0, 3) And 发送号 + 0 = 发送号_In And
                     医嘱id In
                     (Select ID From 病人医嘱记录 Where (ID = v_组id Or 相关id = v_组id) And 诊疗类别 = v_诊疗类别));
      End If;
    Else
      If Nvl(单独执行_In, 0) = 1 Then
        Update 门诊费用记录 A
        Set 执行状态 = n_执行状态, 执行人 = Decode(n_执行状态, 0, Null, 执行人), 执行时间 = Decode(n_执行状态, 0, Null, 执行时间)
        Where 收费类别 Not In ('5', '6', '7') And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In) And Not Exists
         (Select 1 From 材料特性 Where 材料id = a.收费细目id And 跟踪在用 = 1) And a.记录状态 In (0, 1, 3) And
              (医嘱序号, NO, 记录性质) In
              (Select 医嘱id, NO, 记录性质
               From 病人医嘱发送
               Where 执行状态 = Decode(n_执行次数, 0, 0, 3) And 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In);
      Else
        Update 门诊费用记录 A
        Set 执行状态 = n_执行状态, 执行人 = Decode(n_执行状态, 0, Null, 执行人), 执行时间 = Decode(n_执行状态, 0, Null, 执行时间)
        Where 收费类别 Not In ('5', '6', '7') And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In) And Not Exists
         (Select 1 From 材料特性 Where 材料id = a.收费细目id And 跟踪在用 = 1) And a.记录状态 In (0, 1, 3) And
              (医嘱序号, NO, 记录性质) In
              (Select 医嘱id, NO, 记录性质
               From 病人医嘱发送
               Where 执行状态 = Decode(n_执行次数, 0, 0, 3) And 发送号 + 0 = 发送号_In And
                     医嘱id In
                     (Select ID From 病人医嘱记录 Where (ID = v_组id Or 相关id = v_组id) And 诊疗类别 = v_诊疗类别));
      End If;
    End If;
    --检验采集自动取消采集人采集时间
    If v_诊疗类别 = 'E' And v_操作类型 = '6' Then
      Update 病人医嘱发送 A
      Set a.采样人 = Null, a.采样时间 = Null
      Where 医嘱id In (Select ID From 病人医嘱记录 Where (ID = v_组id Or 相关id = v_组id)) And 发送号 = 发送号_In;
    End If;
  
    --已完成执行的，执行数次减少之后自动取消执行完成为正在执行或未执行(主要用于PDA自动执行)
    If Nvl(自动取消_In, 0) = 1 Then
      Begin
        Select Decode(Sign(Nvl(Sum(b.本次数次), 0) - a.发送数次), -1, 1, 0), Decode(Sign(Nvl(Sum(b.本次数次), 0)), 0, 0, 3)
        Into v_自动取消, v_执行状态
        From 病人医嘱发送 A, 病人医嘱执行 B
        Where a.医嘱id = b.医嘱id(+) And a.发送号 = b.发送号(+) And a.执行状态 = 1 And a.医嘱id = 医嘱id_In And a.发送号 = 发送号_In
        Group By a.发送数次;
      Exception
        When Others Then
          Null;
      End;
    
      If Nvl(v_自动取消, 0) = 1 Then
        Zl_病人医嘱执行_Cancel(医嘱id_In, 发送号_In, Null, 单独执行_In, 执行部门id_In);
      
        If v_执行状态 = 3 Then
          Select Nvl(相关id, ID), 诊疗类别 Into v_组id, v_诊疗类别 From 病人医嘱记录 Where ID = 医嘱id_In;
          Update 病人医嘱发送
          Set 执行状态 = 3, 完成人 = Null, 完成时间 = Null
          Where 发送号 + 0 = 发送号_In And
                医嘱id In (Select ID From 病人医嘱记录 Where (ID = v_组id Or 相关id = v_组id) And 诊疗类别 = v_诊疗类别);
        End If;
      
      End If;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱执行_Delete;
/

--119437:胡俊勇,2018-02-07,临床相关消息修改
Create Or Replace Procedure Zl_病人医嘱执行_Cancel
(
  医嘱id_In     In 病人医嘱执行.医嘱id%Type,
  发送号_In     In 病人医嘱执行.发送号%Type,
  取消皮试_In   In Number := Null,
  单独执行_In   In Number := 0,
  执行部门id_In In 门诊费用记录.执行部门id%Type := 0,
  操作员编号_In In 人员表.编号%Type := Null,
  操作员姓名_In In 人员表.姓名%Type := Null
  --参数：医嘱ID_IN=单独执行的医嘱ID，检验组合为显示的检验项目的ID。
  --      单独执行_In=检验或检查医嘱组合是否采用对每个项目分散单独执行的方式
  --执行部门id_In=仅处理指定执行部门的费用，不传或传入0时不限制执行部门
) Is
  Cursor c_Advice Is
    Select a.Id, a.相关id, Nvl(a.相关id, a.Id) As 组id, a.病人id, Decode(a.病人来源, 1, c.Id, a.主页id) As 就诊id, a.诊疗类别, b.操作类型,
           a.病人来源, a.主页id, a.挂号单
    From 病人医嘱记录 A, 诊疗项目目录 B, 病人挂号记录 C
    Where a.诊疗项目id = b.Id(+) And a.Id = 医嘱id_In And a.挂号单 = c.No(+);
  r_Advice c_Advice%RowType;

  v_Temp     Varchar2(255);
  v_人员编号 人员表.编号%Type;
  v_人员姓名 人员表.姓名%Type;
  v_费用性质 病人医嘱发送.记录性质%Type;
  v_操作人员 人员表.姓名%Type;
  d_完成时间 病人医嘱发送.完成时间%Type;
  n_发送数次 Number;
  n_单次数次 Number;
  n_登记数次 Number;
  d_要求时间 Date;
  n_取消执行 Number;
  n_Diffday  Number(18, 3);
  v_Date     Date;
  v_Count    Number;
  Err_Custom Exception;
  v_Error Varchar2(2000);
Begin
  --当前操作人员
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
    v_人员编号 := 操作员编号_In;
    v_人员姓名 := 操作员姓名_In;
  Else
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;

  Open c_Advice;
  Fetch c_Advice
    Into r_Advice;
  Close c_Advice;
  --医嘱取消执行天数限制，会诊医嘱不做限制
  If Not (r_Advice.诊疗类别 = 'Z' And r_Advice.操作类型 = 7) Then
    --父医嘱不需要发送，没有发送记录，此时取子医嘱的完成时间
    If Nvl(单独执行_In, 0) <> 1 Then
      Select Count(1) Into v_Count From 病人医嘱发送 Where 发送号 + 0 = 发送号_In And 医嘱id = r_Advice.组id;
    End If;
  
    If Nvl(单独执行_In, 0) = 1 Or v_Count = 0 Then
      Select 完成时间 Into d_完成时间 From 病人医嘱发送 Where 发送号 + 0 = 发送号_In And 医嘱id = 医嘱id_In;
    Else
      Select 完成时间 Into d_完成时间 From 病人医嘱发送 Where 发送号 + 0 = 发送号_In And 医嘱id = r_Advice.组id;
    End If;
    If Not d_完成时间 Is Null Then
      Select Zl_To_Number(Nvl(zl_GetSysParameter(220), '999')) Into n_取消执行 From Dual;
      Select Sysdate - d_完成时间 Into n_Diffday From Dual;
      --完成时间超过取消执行天数的记录，不允许取消执行
      If n_Diffday > n_取消执行 Then
        v_Error := '医嘱执行完成时间超过了取消执行有效天数，不能取消执行！';
        Raise Err_Custom;
      End If;
    End If;
  End If;

  --叮嘱运行执行参数
  v_Temp := zl_GetSysParameter(288);

  If (r_Advice.诊疗类别 = 'C' And r_Advice.相关id Is Not Null) Or r_Advice.诊疗类别 = 'D' Then
    If Nvl(单独执行_In, 0) = 1 Then
      Select Count(*)
      Into v_Count
      From 病人医嘱执行
      Where 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In And Nvl(执行结果, 1) <> 0;
      Update 病人医嘱发送
      Set 执行状态 = Decode(v_Count, 0, 0, 3), 完成人 = Null, 完成时间 = Null
      Where 发送号 + 0 = 发送号_In And 医嘱id = 医嘱id_In;
    Else
      If r_Advice.诊疗类别 = 'D' Then
        Select Count(1)
        Into v_Count
        From 病人医嘱执行
        Where 发送号 + 0 = 发送号_In And
              医嘱id In (Select ID From 病人医嘱记录 Where (ID = r_Advice.组id Or 相关id = r_Advice.组id)) And Nvl(执行结果, 1) <> 0;
      
        Update 病人医嘱发送
        Set 执行状态 = Decode(v_Count, 0, 0, 3), 完成人 = Null, 完成时间 = Null
        Where 发送号 + 0 = 发送号_In And
              医嘱id In (Select ID From 病人医嘱记录 Where (ID = r_Advice.组id Or 相关id = r_Advice.组id));
      Else
        Select Count(1)
        Into v_Count
        From 病人医嘱执行
        Where 发送号 + 0 = 发送号_In And 医嘱id In (Select ID From 病人医嘱记录 Where 相关id = r_Advice.相关id) And Nvl(执行结果, 1) <> 0;
        Update 病人医嘱发送
        Set 执行状态 = Decode(v_Count, 0, 0, 3), 完成人 = Null, 完成时间 = Null
        Where 发送号 + 0 = 发送号_In And 医嘱id In (Select ID From 病人医嘱记录 Where 相关id = r_Advice.相关id);
      End If;
    End If;
  Else
    Select Count(*) Into v_Count From 病人医嘱执行 Where 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In;
  
    --包含附加手术,检验部位,以及其它独立医嘱;麻醉和中药煎法是单独安排
    If r_Advice.诊疗类别 = 'E' And (r_Advice.操作类型 = '4' Or r_Advice.操作类型 = '3') Then
      Update 病人医嘱发送
      Set 执行状态 = Decode(v_Count, 0, 0, 3), 完成人 = Null, 完成时间 = Null
      Where 发送号 + 0 = 发送号_In And 医嘱id = 医嘱id_In;
    Else
      Update 病人医嘱发送
      Set 执行状态 = Decode(v_Count, 0, 0, 3), 完成人 = Null, 完成时间 = Null
      Where 发送号 + 0 = 发送号_In And
            医嘱id In (Select ID
                     From 病人医嘱记录
                     Where (ID = r_Advice.组id Or 相关id = r_Advice.组id) And 诊疗类别 = r_Advice.诊疗类别);
    End If;
  End If;

  If v_Temp = 1 And r_Advice.诊疗类别 Is Null Then
    Update 病人医嘱发送
    Set 执行状态 = Decode(v_Count, 0, 0, 3), 完成人 = Null, 完成时间 = Null
    Where 发送号 + 0 = 发送号_In And 医嘱id In (Select ID From 病人医嘱记录 Where (ID = r_Advice.组id Or 相关id = r_Advice.组id));
  End If;

  --更新对应的费用执行状态为未执行，在Zl_门诊医嘱执行_Cancel和Zl_住院医嘱执行_Cancel中进行

  --删除过敏登记记录(当前人员登记的)
  If r_Advice.诊疗类别 = 'E' And r_Advice.操作类型 = '1' Then
    Select Max(操作时间), Max(操作人员)
    Into v_Date, v_操作人员
    From (Select 操作时间, 操作人员 From 病人医嘱状态 Where 医嘱id = 医嘱id_In And 操作类型 = 10 Order By 操作时间 Desc)
    Where Rownum < 2;
    If v_Date Is Not Null And ((v_操作人员 = v_人员姓名 And Nvl(取消皮试_In, 0) = 0) Or Nvl(取消皮试_In, 0) = 1) Then
      --可能因为未设置对应过敏药物而未填写过敏记录
      --删除状态，以便标记未用时回退发送记录
      Update 病人医嘱记录 Set 皮试结果 = Null Where ID = 医嘱id_In;
      For r_Date In (Select 操作时间 From 病人医嘱状态 Where 医嘱id = 医嘱id_In And 操作类型 = 10) Loop
        --过敏记录不回退，因为病人对药过敏与医嘱操作无关。
        Delete From 病人过敏记录
        Where 病人id = r_Advice.病人id And 记录来源 = 2 And Nvl(主页id, 0) = Nvl(r_Advice.就诊id, 0) And 记录时间 = r_Date.操作时间 And
              Nvl(结果, 0) = 0;
        Delete 病人医嘱状态 Where 医嘱id = 医嘱id_In And 操作类型 = 10 And 操作时间 = r_Date.操作时间;
      End Loop;
    End If;
  End If;
  --检验自动采集，没有采集方式的医嘱执行记录，则清空采样人与采样时间
  Select Count(*) Into v_Count From 病人医嘱执行 Where 发送号 = 发送号_In And 医嘱id = r_Advice.组id;
  If v_Count = 0 And r_Advice.诊疗类别 = 'E' And r_Advice.操作类型 = '6' Then
    Update 病人医嘱发送 A
    Set a.采样人 = Null, a.采样时间 = Null
    Where 医嘱id In (Select ID From 病人医嘱记录 Where (ID = r_Advice.组id Or 相关id = r_Advice.组id)) And 发送号 = 发送号_In;
  End If;

  If r_Advice.病人来源 = 2 Then
    Select Decode(记录性质, 1, 1, Decode(门诊记帐, 1, 1, 2))
    Into v_费用性质
    From 病人医嘱发送
    Where 发送号 = 发送号_In And 医嘱id = 医嘱id_In;
  Else
    v_费用性质 := 1;
  End If;

  If v_费用性质 = 1 Then
    Zl_门诊医嘱执行_Cancel(医嘱id_In, 发送号_In, 单独执行_In, v_人员编号, v_人员姓名, r_Advice.组id, r_Advice.诊疗类别, 执行部门id_In);
  Else
    Zl_住院医嘱执行_Cancel(医嘱id_In, 发送号_In, 单独执行_In, v_人员编号, v_人员姓名, r_Advice.组id, r_Advice.诊疗类别, 执行部门id_In);
  End If;
  --更新医嘱执行计价.执行状态
  Select a.发送数次, c.登记次数
  Into n_发送数次, n_登记数次
  From 病人医嘱发送 A,
       (Select 医嘱id_In 医嘱id, 发送号_In 发送号, Nvl(Sum(b.本次数次), 0) As 登记次数
         From 病人医嘱执行 B
         Where b.医嘱id = 医嘱id_In And b.发送号 = 发送号_In And Nvl(b.执行结果, 1) <> 0) C
  Where a.医嘱id = c.医嘱id And a.发送号 = c.发送号 And a.医嘱id = 医嘱id_In And a.发送号 = 发送号_In;

  If n_发送数次 > 0 Then
    Select Count(Distinct 要求时间) Into v_Count From 医嘱执行计价 Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In;
    If v_Count > 0 Then
      n_单次数次 := n_发送数次 / v_Count;
      --已执行数量+本次数次 总共能够执行多少个时间点,取最大整数
      v_Count := Ceil((n_登记数次) / n_单次数次);
      If n_登记数次 = 0 Then
        Update 医嘱执行计价 Set 执行状态 = 0 Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In And Nvl(执行状态, 0) <> 2;
      Else
        --获取执行截至要求时间
        Select 要求时间
        Into d_要求时间
        From (Select 要求时间, Rownum As 次数
               From (Select Distinct 要求时间
                      From 医嘱执行计价
                      Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In
                      Order By 要求时间))
        Where 次数 = v_Count;
      
        If Not d_要求时间 Is Null Then
          --更新截至要求时间之前(含)的记录执行状态；
          Update 医嘱执行计价
          Set 执行状态 = 1
          Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In And 要求时间 <= d_要求时间 And Nvl(执行状态, 0) <> 2;
          Update 医嘱执行计价
          Set 执行状态 = 0
          Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In And 要求时间 > d_要求时间 And Nvl(执行状态, 0) <> 2;
        End If;
      End If;
    End If;
  End If;
  b_Message.Zlhis_Cis_053(r_Advice.病人id, r_Advice.主页id, r_Advice.挂号单, 发送号_In, 医嘱id_In);
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱执行_Cancel;
/

--119437:胡俊勇,2018-01-09,临床相关消息修改
CREATE OR REPLACE Procedure Zl_病人医嘱执行_Finish
(
  医嘱id_In       In 病人医嘱执行.医嘱id%Type,
  发送号_In       In 病人医嘱执行.发送号%Type,
  阳性_In         In 病人医嘱发送.结果阳性%Type := Null,
  单独执行_In     In Number := 0,
  操作员编号_In   In 人员表.编号%Type := Null,
  操作员姓名_In   In 人员表.姓名%Type := Null,
  执行部门id_In   In 门诊费用记录.执行部门id%Type := 0,
  检验项目记帐_In In Number := 0,
  完成时间_In     In 病人医嘱发送.完成时间%Type := Null
  --参数：医嘱ID_IN=单独执行的医嘱ID，检验组合为显示的检验项目的ID。
  --      单独执行_In=检验或检查医嘱组合是否采用对每个项目分散单独执行的方式
  --执行部门id_In=仅处理指定执行部门的费用，不传或传入0时不限制执行部门
  --检验项目记帐_In=如果是检验项目时，需要记帐但不完成医嘱发送状态
) Is
  Cursor c_Advice Is
    Select a.Id, a.相关id, Nvl(a.相关id, a.Id) As 组id, a.诊疗类别, a.病人来源, a.标本部位, a.开始执行时间, a.病人id, a.主页id, a.执行科室id, b.操作类型,
           a.挂号单
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.Id = 医嘱id_In And a.诊疗项目id = b.Id(+);
  r_Advice c_Advice%RowType;

  v_Date     Date;
  v_开始时间 Date;
  v_诊疗类别 诊疗项目目录.类别%Type;
  v_操作类型 诊疗项目目录.操作类型%Type;
  v_Temp     Varchar2(255);
  v_费用性质 病人医嘱发送.记录性质%Type;
  v_人员编号 人员表.编号%Type;
  v_人员姓名 人员表.姓名%Type;
  n_Cnt      Number;
Begin
  --如果启用了参数：输血和皮试医嘱执行后需要核对，则输血和皮试医嘱不自动完成
  Select b.类别, b.操作类型
  Into v_诊疗类别, v_操作类型
  From 病人医嘱记录 A, 诊疗项目目录 B
  Where a.诊疗项目id = b.Id(+) And a.Id = 医嘱id_In;

  v_Temp := zl_GetSysParameter(186);
  If v_Temp = '11' Then
    Select Count(1)
    Into n_Cnt
    From 病人医嘱执行
    Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In And 核对人 Is Null And (v_诊疗类别 = 'E' And v_操作类型 In ('1', '8') Or v_诊疗类别 = 'K');
  Elsif v_Temp = '01' Then
    Select Count(1)
    Into n_Cnt
    From 病人医嘱执行
    Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In And 核对人 Is Null And v_诊疗类别 = 'E' And v_操作类型 = '1';
  Elsif v_Temp = '10' Then
    Select Count(1)
    Into n_Cnt
    From 病人医嘱执行
    Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In And 核对人 Is Null And (v_诊疗类别 = 'E' And v_操作类型 = '8' Or v_诊疗类别 = 'K');
  End If;

  If n_Cnt > 0 Then
    Return;
  End If;

  --当前操作人员
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
    v_人员编号 := 操作员编号_In;
    v_人员姓名 := 操作员姓名_In;
  Else
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;

  If 完成时间_In Is Null Then
    Select Sysdate Into v_Date From Dual;
  Else
    v_Date := 完成时间_In;
  End If;

  --执行状态
  Open c_Advice;
  Fetch c_Advice
    Into r_Advice;
  Close c_Advice;

  --叮嘱运行执行参数
  v_Temp := zl_GetSysParameter(288);

  If 检验项目记帐_In = 0 Then
    If (r_Advice.诊疗类别 = 'C' And r_Advice.相关id Is Not Null) Or r_Advice.诊疗类别 = 'D' Then
      If Nvl(单独执行_In, 0) = 1 Then
        --单个检验或检查项目
        Update 病人医嘱发送
        Set 执行状态 = 1, 完成人 = v_人员姓名, 完成时间 = v_Date, 结果阳性 = Decode(阳性_In, Null, 结果阳性, 阳性_In)
        Where 发送号 = 发送号_In And 医嘱id = 医嘱id_In;
      Else
        --一并的检验项目或多部位的检查项目
        If r_Advice.诊疗类别 = 'D' Then
          Update 病人医嘱发送
          Set 执行状态 = 1, 完成人 = v_人员姓名, 完成时间 = v_Date, 结果阳性 = Decode(阳性_In, Null, 结果阳性, 阳性_In)
          Where 发送号 + 0 = 发送号_In And
                医嘱id In (Select ID From 病人医嘱记录 Where (ID = r_Advice.组id Or 相关id = r_Advice.组id));
        Else
          Update 病人医嘱发送
          Set 执行状态 = 1, 完成人 = v_人员姓名, 完成时间 = v_Date, 结果阳性 = Decode(阳性_In, Null, 结果阳性, 阳性_In)
          Where 发送号 + 0 = 发送号_In And 医嘱id In (Select ID From 病人医嘱记录 Where 相关id = r_Advice.相关id);
        End If;
      End If;
    Else
      --包含附加手术,检查部位,以及其它独立医嘱;麻醉和中药煎法是单独安排
      If r_Advice.诊疗类别 = 'E' And (r_Advice.操作类型 = '4' Or r_Advice.操作类型 = '3') Then
        Update 病人医嘱发送
        Set 执行状态 = 1, 完成人 = v_人员姓名, 完成时间 = v_Date, 结果阳性 = Decode(阳性_In, Null, 结果阳性, 阳性_In)
        Where 发送号 + 0 = 发送号_In And 医嘱id = 医嘱id_In;
      Else
        Update 病人医嘱发送
        Set 执行状态 = 1, 完成人 = v_人员姓名, 完成时间 = v_Date, 结果阳性 = Decode(阳性_In, Null, 结果阳性, 阳性_In)
        Where 发送号 + 0 = 发送号_In And
              医嘱id In (Select ID
                       From 病人医嘱记录
                       Where (ID = r_Advice.组id Or 相关id = r_Advice.组id) And 诊疗类别 = r_Advice.诊疗类别);
      End If;
    End If;
    If v_Temp = 1 And r_Advice.诊疗类别 Is Null Then
      Update 病人医嘱发送
      Set 执行状态 = 1, 完成人 = v_人员姓名, 完成时间 = v_Date, 结果阳性 = Decode(阳性_In, Null, 结果阳性, 阳性_In)
      Where 发送号 + 0 = 发送号_In And
            医嘱id In (Select ID From 病人医嘱记录 Where (ID = r_Advice.组id Or 相关id = r_Advice.组id));
    End If;
  End If;
  If r_Advice.病人来源 = 2 Then
    Select Decode(记录性质, 1, 1, Decode(门诊记帐, 1, 1, 2))
    Into v_费用性质
    From 病人医嘱发送
    Where 发送号 = 发送号_In And 医嘱id = 医嘱id_In;
  Else
    v_费用性质 := 1;
  End If;
  --检验自动完成采集
  If v_诊疗类别 = 'E' And v_操作类型 = '6' Then
    Update 病人医嘱发送 A
    Set a.采样人 = Nvl(a.采样人, v_人员姓名), a.采样时间 = Nvl(a.采样时间, v_Date)
    Where 医嘱id In (Select ID From 病人医嘱记录 Where (ID = r_Advice.组id Or 相关id = r_Advice.组id)) And 发送号 = 发送号_In;
  End If;

  If v_费用性质 = 1 Then
    Zl_门诊医嘱执行_Finish(医嘱id_In, 发送号_In, 单独执行_In, v_人员编号, v_人员姓名, r_Advice.组id, r_Advice.诊疗类别, 执行部门id_In);
  Else
    Zl_住院医嘱执行_Finish(医嘱id_In, 发送号_In, 单独执行_In, v_人员编号, v_人员姓名, r_Advice.组id, r_Advice.诊疗类别, 执行部门id_In);
  End If;

  --更新医嘱执行计价.执行状态
  Update 医嘱执行计价 Set 执行状态 = 1 Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In And Nvl(执行状态, 0) <> 2;

  If r_Advice.诊疗类别 = 'F' Then
    If Not r_Advice.标本部位 Is Null Then
      v_开始时间 := To_Date(r_Advice.标本部位, 'yyyy-mm-dd hh24:mi:ss');
    Else
      v_开始时间 := r_Advice.开始执行时间;
    End If;
    Zl_电子病历时机_Insert(r_Advice.病人id, r_Advice.主页id, 2, '手术', r_Advice.执行科室id, v_人员姓名, v_开始时间, v_Date);
  End If;
  b_Message.Zlhis_Cis_052(r_Advice.病人id, r_Advice.主页id, r_Advice.挂号单, 发送号_In, 医嘱id_In);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱执行_Finish;
/

--118402:秦龙,2018-01-09,增加传参加成率
Create Or Replace Procedure Zl_卫生材料_Update
(
  诊疗id_In         In 材料特性.诊疗id%Type,
  材料id_In         In 材料特性.材料id%Type,
  编码_In           In 收费项目目录.编码%Type,
  规格_In           In 收费项目目录.规格%Type,
  产地_In           In 收费项目目录.产地%Type := Null,
  标识主码_In       In 收费项目目录.标识主码%Type := Null,
  标识子码_In       In 收费项目目录.标识子码%Type := Null,
  备选码_In         In 收费项目目录.备选码%Type := Null,
  材料来源_In       In 材料特性.材料来源%Type := Null,
  货源情况_In       In 材料特性.货源情况%Type := Null,
  散装单位_In       In 收费项目目录.计算单位%Type := Null,
  包装单位_In       In 材料特性.包装单位%Type := Null,
  换算系数_In       In 材料特性.换算系数%Type := Null,
  是否变价_In       In 收费项目目录.是否变价%Type := Null,
  指导批发价_In     In 材料特性.指导批发价%Type := Null,
  扣率_In           In 材料特性.扣率%Type := 95,
  指导零售价_In     In 材料特性.指导零售价%Type := Null,
  指导差价率_In     In 材料特性.指导差价率%Type := Null,
  费用类型_In       In 收费项目目录.费用类型%Type := Null,
  服务对象_In       In 收费项目目录.服务对象%Type := Null,
  屏蔽费别_In       In 收费项目目录.屏蔽费别%Type := 0,
  库房分批_In       In 材料特性.库房分批%Type := Null,
  在用分批_In       In 材料特性.在用分批%Type := Null,
  最大效期_In       In 材料特性.最大效期%Type := Null,
  灭菌效期_In       In 材料特性.灭菌效期%Type := Null,
  无菌性材料_In     In 材料特性.无菌性材料%Type := Null,
  一次性材料_In     In 材料特性.一次性材料%Type := Null,
  原材料_In         In 材料特性.原材料%Type := Null,
  差价让利比_In     In 材料特性.差价让利比%Type := 0,
  成本价_In         In 材料特性.成本价%Type := 0,
  跟踪在用_In       In 材料特性.跟踪在用%Type := Null,
  核算材料_In       In 材料特性.核算材料%Type := 0,
  当前售价_In       In 收费价目.现价%Type := 0,
  收入id_In         In 收费价目.收入项目id%Type := Null,
  批准文号_In       In 材料特性.批准文号%Type := Null,
  注册商标_In       In 材料特性.注册商标%Type := Null,
  注册证号_In       In 材料特性.注册证号%Type := Null,
  许可证号_In       In 材料特性.许可证号%Type := Null,
  许可证有效期_In   In 材料特性.许可证有效期%Type := Null,
  材质分类_In       In 材料特性.材质分类%Type := Null,
  存储条件_In       In 材料特性.存储条件%Type := Null,
  跟踪病人_In       In 材料特性.跟踪病人%Type := 0,
  站点_In           In 收费项目目录.站点%Type := Null,
  品名_In           In 收费项目别名.名称%Type := Null,
  拼音_In           In 收费项目别名.简码%Type := Null,
  五笔_In           In 收费项目别名.简码%Type := Null,
  增值税率_In       In 材料特性.增值税率%Type := Null,
  说明_In           In 收费项目目录.说明%Type := Null,
  高值材料_In       In 材料特性.高值材料%Type := Null,
  条码管理_In       In 材料特性.是否条码管理%Type := Null,
  病案费目_In       In 收费项目目录.病案费目%Type := Null,
  器械包卫材单件_In In 材料特性.器械包卫材单件%Type := 0,
  注册证有效期_In   In 材料特性.注册证有效期%Type := Null,
  是否植入耗材_In   In 材料特性.是否植入耗材%Type := 0,
  修改类型_In       In Number := 0, --1-同步修改品种下所有注册证号和注册证有效期
  加成率_In         In 材料特性.加成率%Type := Null
) Is
  v_Err_Msg Varchar2(200);
  Err_Item Exception;
  v_发生     Integer;
  v_跟踪在用 Integer;
  v_Count    Integer;
  v_No       收费价目.No%Type;
  v_名称     诊疗项目目录.名称%Type;
  v_Temp     收费项目目录.病案费目%Type;
  v_病案费目 收费项目目录.病案费目%Type;

Begin
  v_Err_Msg := '无';

  v_病案费目 := 病案费目_In;
  --判断病案费目 
  If v_病案费目 Is Null Then
    If 收入id_In Is Not Null Then
      Begin
        Select 病案费目 Into v_Temp From 收入项目 Where ID = 收入id_In;
      Exception
        When Others Then
          v_Temp := Null;
      End;
      If v_Temp Is Not Null Then
        v_病案费目 := v_Temp;
      End If;
    End If;
  End If;
  --修改诊疗项目 
  Begin
    Select 跟踪在用 Into v_跟踪在用 From 材料特性 Where 材料id = 材料id_In;
  Exception
    When Others Then
      v_Err_Msg := '[ZLSOFT]不存在规格材料,可能被其他用户删除了,请检查![ZLSOFT]';
  End;
  If v_Err_Msg <> '无' Then
    Raise Err_Item;
  End If;

  Begin
    Select 名称 Into v_名称 From 诊疗项目目录 Where ID = 诊疗id_In;
  Exception
    When Others Then
      v_Err_Msg := 'Err';
  End;

  If v_Err_Msg = 'Err' Then
    v_Err_Msg := '[ZLSOFT]未找到指定的材料品种，可能已被其他用户删除！[ZLSOFT]';
    Raise Err_Item;
  End If;

  --如果更新前的材料为跟踪在用,如果改为了不跟踪则需判断库存 
  If v_跟踪在用 = 1 And 跟踪在用_In <> 1 Then
    Begin
      Select Count(*)
      Into v_Count
      From 药品库存
      Where 药品id = 材料id_In And (Nvl(可用数量, 0) <> 0 Or Nvl(实际数量, 0) <> 0 Or Nvl(实际金额, 0) <> 0 Or Nvl(实际差价, 0) <> 0);
      If v_Count <> 0 Then
        v_Err_Msg := '[ZLSOFT]该卫生材料存在库存,不能取消跟踪在用属性,请检查![ZLSOFT]';
      End If;
    Exception
      When Others Then
        Null;
    End;
  End If;

  If v_Err_Msg <> '无' Then
    Raise Err_Item;
  End If;

  --规格信息 
  Update 收费项目目录
  Set 编码 = 编码_In, 名称 = v_名称, 规格 = 规格_In, 标识主码 = 标识主码_In, 标识子码 = 标识子码_In, 备选码 = 备选码_In, 产地 = 产地_In, 是否变价 = 是否变价_In,
      计算单位 = 散装单位_In, 费用类型 = 费用类型_In, 服务对象 = 服务对象_In, 屏蔽费别 = 屏蔽费别_In, 站点 = 站点_In, 说明 = 说明_In, 病案费目 = v_病案费目
  Where ID = 材料id_In;

  If Sql%RowCount = 0 Then
    v_Err_Msg := '[ZLSOFT]该卫生材料可能被其他用户删除了,请检查![ZLSOFT]';
    Raise Err_Item;
  End If;

  --材料特性 
  Update 材料特性
  Set 最大效期 = 最大效期_In, 灭菌效期 = 灭菌效期_In, 无菌性材料 = 无菌性材料_In, 一次性材料 = 一次性材料_In, 原材料 = 原材料_In, 货源情况 = 货源情况_In, 包装单位 = 包装单位_In,
      换算系数 = 换算系数_In, 指导批发价 = 指导批发价_In, 指导零售价 = 指导零售价_In, 指导差价率 = 指导差价率_In, 扣率 = 扣率_In, 库房分批 = 库房分批_In, 在用分批 = 在用分批_In,
      材料来源 = 材料来源_In, 差价让利比 = 差价让利比_In, 成本价 = 成本价_In, 跟踪在用 = 跟踪在用_In, 核算材料 = 核算材料_In, 批准文号 = 批准文号_In, 注册商标 = 注册商标_In,
      注册证号 = 注册证号_In, 注册证有效期 = 注册证有效期_In, 材质分类 = 材质分类_In, 存储条件 = 存储条件_In, 许可证号 = 许可证号_In, 许可证有效期 = 许可证有效期_In,
      诊疗id = 诊疗id_In, 跟踪病人 = 跟踪病人_In, 增值税率 = 增值税率_In, 高值材料 = 高值材料_In, 是否条码管理 = 条码管理_In, 器械包卫材单件 = 器械包卫材单件_In,
      是否植入耗材 = 是否植入耗材_In, 加成率=加成率_In
  Where 材料id = 材料id_In;

  --同步修改改品种下所有规格
  If 修改类型_In = 1 Then
    Update 材料特性 Set 注册证号 = 注册证号_In, 注册证有效期 = 注册证有效期_In Where 诊疗id = 诊疗id_In;
  End If;

  --别名的处理 
  Delete 收费项目别名 Where 收费细目id = 材料id_In And 性质 = 1;

  Insert Into 收费项目别名
    (收费细目id, 名称, 性质, 简码, 码类)
    Select 材料id_In, 名称, 性质, 简码, 码类 From 诊疗项目别名 Where 诊疗项目id = 诊疗id_In And 性质 = 1;

  If 品名_In Is Null Then
    Delete 收费项目别名 Where 收费细目id = 材料id_In And 性质 = 3;
  Else
    If 拼音_In Is Null Then
      Delete 收费项目别名 Where 收费细目id = 材料id_In And 性质 = 3 And 码类 = 1;
    Else
      Update 收费项目别名 Set 名称 = 品名_In, 简码 = 拼音_In Where 收费细目id = 材料id_In And 性质 = 3 And 码类 = 1;
      If Sql%RowCount = 0 Then
        Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (材料id_In, 品名_In, 3, 拼音_In, 1);
      End If;
    End If;
    If 五笔_In Is Null Then
      Delete 收费项目别名 Where 收费细目id = 材料id_In And 性质 = 3 And 码类 = 2;
    Else
      Update 收费项目别名 Set 名称 = 品名_In, 简码 = 五笔_In Where 收费细目id = 材料id_In And 性质 = 3 And 码类 = 2;
      If Sql%RowCount = 0 Then
        Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (材料id_In, 品名_In, 3, 五笔_In, 2);
      End If;
    End If;
  End If;

  --定价信息：如果已经有发生，则不允许直接更改这些信息 
  Select Nvl(Count(*), 0) Into v_发生 From 药品收发记录 Where 药品id = 材料id_In And Rownum < 2;

  If v_发生 = 0 Then
    Update 收费项目目录 Set 是否变价 = 是否变价_In Where ID = 材料id_In;
    Update 材料特性 Set 成本价 = 成本价_In Where 材料id = 材料id_In;
  
    If 收入id_In Is Not Null Then
      Update 收费价目
      Set 现价 = 当前售价_In, 缺省价格 = Decode(跟踪在用_In, 0, Decode(是否变价_In, 1, 当前售价_In, 缺省价格), 缺省价格), 收入项目id = 收入id_In, 变动原因 = 1,
          调价说明 = '修改定价', 调价人 = User
      Where 收费细目id = 材料id_In
           --And (终止日期 Is Null Or 终止日期=to_date('3000-01-01','YYYY-MM-DD')); 
            And (Sysdate Between 执行日期 And 终止日期 Or Sysdate >= 执行日期 And 终止日期 Is Null) And 变动原因 = 1;
    
      If Sql%RowCount = 0 Then
        v_No := Nextno(9);
        Insert Into 收费价目
          (ID, 原价id, 收费细目id, 原价, 现价, 缺省价格, 收入项目id, 变动原因, 调价说明, 调价人, 执行日期, 终止日期, NO, 序号)
        Values
          (收费价目_Id.Nextval, Null, 材料id_In, 0, 当前售价_In, Decode(跟踪在用_In, 0, Decode(是否变价_In, 1, 当前售价_In, Null), Null),
           收入id_In, 1, '新增定价', User, Sysdate, To_Date('3000-01-01', 'YYYY-MM-DD'), v_No, 1);
      End If;
    End If;
  Else
    --有业务单据后不能直接修改价格，但是可以修改收入项目 
    Update 收费价目
    Set 收入项目id = 收入id_In
    Where 收费细目id = 材料id_In And (Sysdate Between 执行日期 And 终止日期 Or Sysdate >= 执行日期 And 终止日期 Is Null) And 变动原因 = 1;
  End If;

  --材料生产商比较增加 
  If 产地_In Is Not Null Then
    Update 材料生产商 Set 名称 = 产地_In Where 名称 = 产地_In;
    If Sql%RowCount = 0 Then
      Insert Into 材料生产商
        (编码, 名称, 简码)
        Select Nvl(Max(To_Number(编码)), 0) + 1, 产地_In, zlSpellCode(产地_In) From 材料生产商;
    End If;
  End If;

  b_Message.Zlhis_Dict_044(材料id_In);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_卫生材料_Update;
/

--118402:秦龙,2018-01-09,增加传参加成率
Create Or Replace Procedure Zl_卫生材料_Insert
(
  诊疗id_In         In 材料特性.诊疗id%Type,
  材料id_In         In 材料特性.材料id%Type,
  编码_In           In 收费项目目录.编码%Type,
  规格_In           In 收费项目目录.规格%Type,
  产地_In           In 收费项目目录.产地%Type := Null,
  标识主码_In       In 收费项目目录.标识主码%Type := Null,
  标识子码_In       In 收费项目目录.标识子码%Type := Null,
  备选码_In         In 收费项目目录.备选码%Type := Null,
  材料来源_In       In 材料特性.材料来源%Type := Null,
  货源情况_In       In 材料特性.货源情况%Type := Null,
  散装单位_In       In 收费项目目录.计算单位%Type := Null,
  包装单位_In       In 材料特性.包装单位%Type := Null,
  换算系数_In       In 材料特性.换算系数%Type := Null,
  是否变价_In       In 收费项目目录.是否变价%Type := Null,
  指导批发价_In     In 材料特性.指导批发价%Type := Null,
  扣率_In           In 材料特性.扣率%Type := 95,
  指导零售价_In     In 材料特性.指导零售价%Type := Null,
  指导差价率_In     In 材料特性.指导差价率%Type := Null,
  费用类型_In       In 收费项目目录.费用类型%Type := Null,
  服务对象_In       In 收费项目目录.服务对象%Type := Null,
  屏蔽费别_In       In 收费项目目录.屏蔽费别%Type := 0,
  库房分批_In       In 材料特性.库房分批%Type := Null,
  在用分批_In       In 材料特性.在用分批%Type := Null,
  最大效期_In       In 材料特性.最大效期%Type := Null,
  灭菌效期_In       In 材料特性.灭菌效期%Type := Null,
  无菌性材料_In     In 材料特性.无菌性材料%Type := Null,
  一次性材料_In     In 材料特性.一次性材料%Type := Null,
  原材料_In         In 材料特性.原材料%Type := Null,
  差价让利比_In     In 材料特性.差价让利比%Type := 0,
  成本价_In         In 材料特性.成本价%Type := 0,
  跟踪在用_In       In 材料特性.跟踪在用%Type := Null,
  核算材料_In       In 材料特性.核算材料%Type := 0,
  当前售价_In       In 收费价目.现价%Type := 0,
  收入id_In         In 收费价目.收入项目id%Type := Null,
  批准文号_In       In 材料特性.批准文号%Type := Null,
  注册商标_In       In 材料特性.注册商标%Type := Null,
  注册证号_In       In 材料特性.注册证号%Type := Null,
  许可证号_In       In 材料特性.许可证号%Type := Null,
  许可证有效期_In   In 材料特性.许可证有效期%Type := Null,
  材质分类_In       In 材料特性.材质分类%Type := Null,
  存储条件_In       In 材料特性.存储条件%Type := Null,
  跟踪病人_In       In 材料特性.跟踪病人%Type := 0,
  站点_In           In 收费项目目录.站点%Type := Null,
  品名_In           In 收费项目别名.名称%Type := Null,
  拼音_In           In 收费项目别名.简码%Type := Null,
  五笔_In           In 收费项目别名.简码%Type := Null,
  增值税率_In       In 材料特性.增值税率%Type := Null,
  说明_In           In 收费项目目录.说明%Type := Null,
  高值材料_In       In 材料特性.高值材料%Type := Null,
  条码管理_In       In 材料特性.是否条码管理%Type := Null,
  病案费目_In       In 收费项目目录.病案费目%Type := Null,
  器械包卫材单件_In In 材料特性.器械包卫材单件%Type := 0,
  注册证有效期_In   In 材料特性.注册证有效期%Type := Null,
  是否植入耗材_In   In 材料特性.是否植入耗材%Type := 0,
  加成率_In         In 材料特性.加成率%Type := Null
) Is
  Err_Item Exception;
  v_Err_Msg Varchar2(100);

  v_No       收费价目.No%Type;
  v_名称     诊疗项目目录.名称%Type;
  v_Temp     收费项目目录.病案费目%Type;
  v_病案费目 收费项目目录.病案费目%Type;

  Cursor c_Item Is
    Select ID
    From 部门表 D
    Where ID In (Select Distinct 部门id
                 From 部门性质说明 A
                 Where 工作性质 In ('发料部门', '物资库房', '卫材库', '制剂室', '虚拟库房'));
Begin
  v_Err_Msg := 'NO';

  v_病案费目 := 病案费目_In;
  --判断病案费目 
  If v_病案费目 Is Null Then
    If 收入id_In Is Not Null Then
      Begin
        Select 病案费目 Into v_Temp From 收入项目 Where ID = 收入id_In;
      Exception
        When Others Then
          v_Temp := Null;
      End;
      If v_Temp Is Not Null Then
        v_病案费目 := v_Temp;
      End If;
    End If;
  End If;
  Begin
    Select 名称
    Into v_名称
    From 诊疗项目目录
    Where ID = 诊疗id_In And (撤档时间 Is Null Or To_Char(撤档时间, 'yyyy-mm-dd') = '3000-01-01');
  Exception
    When Others Then
      v_Err_Msg := 'Err';
  End;
  If v_Err_Msg = 'Err' Then
    v_Err_Msg := '[ZLSOFT]未找到指定的材料品种，可能该品种已被其他用户删除或停用！[ZLSOFT]';
    Raise Err_Item;
  End If;
  --规格信息 
  Insert Into 收费项目目录
    (类别, ID, 编码, 名称, 规格, 产地, 标识主码, 标识子码, 备选码, 计算单位, 费用类型, 服务对象, 屏蔽费别, 是否变价, 站点, 建档时间, 撤档时间, 说明, 病案费目)
  Values
    (4, 材料id_In, 编码_In, v_名称, 规格_In, 产地_In, 标识主码_In, 标识子码_In, 备选码_In, 散装单位_In, 费用类型_In, 服务对象_In, 屏蔽费别_In, 是否变价_In,
     站点_In, Sysdate, To_Date('3000-01-01', 'YYYY-MM-DD'), 说明_In, v_病案费目);

  --材料特性 
  Insert Into 材料特性
    (材料id, 诊疗id, 最大效期, 灭菌效期, 无菌性材料, 一次性材料, 原材料, 货源情况, 包装单位, 换算系数, 指导批发价, 指导零售价, 指导差价率, 扣率, 库房分批, 在用分批, 材料来源, 差价让利比, 成本价,
     跟踪在用, 核算材料, 批准文号, 注册商标, 注册证号, 注册证有效期, 许可证号, 许可证有效期, 材质分类, 存储条件, 跟踪病人, 增值税率, 高值材料, 是否条码管理, 器械包卫材单件, 是否植入耗材, 加成率)
  Values
    (材料id_In, 诊疗id_In, 最大效期_In, 灭菌效期_In, 无菌性材料_In, 一次性材料_In, 原材料_In, 货源情况_In, 包装单位_In, 换算系数_In, 指导批发价_In, 指导零售价_In,
     指导差价率_In, 扣率_In, 库房分批_In, 在用分批_In, 材料来源_In, 差价让利比_In, 成本价_In, 跟踪在用_In, 核算材料_In, 批准文号_In, 注册商标_In, 注册证号_In,
     注册证有效期_In, 许可证号_In, 许可证有效期_In, 材质分类_In, 存储条件_In, 跟踪病人_In, 增值税率_In, 高值材料_In, 条码管理_In, 器械包卫材单件_In, 是否植入耗材_In, 加成率_In);

  --别名的处理 
  Insert Into 收费项目别名
    (收费细目id, 名称, 性质, 简码, 码类)
    Select 材料id_In, 名称, 性质, 简码, 码类 From 诊疗项目别名 Where 诊疗项目id = 诊疗id_In;
  If (品名_In Is Not Null) And (拼音_In Is Not Null) Then
    Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (材料id_In, 品名_In, 3, 拼音_In, 1);
  End If;
  If (品名_In Is Not Null) And (五笔_In Is Not Null) Then
    Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (材料id_In, 品名_In, 3, 五笔_In, 2);
  End If;

  For r_Item In c_Item Loop
    Insert Into 材料储备限额 (库房id, 材料id, 上限, 下限, 盘点属性) Values (r_Item.Id, 材料id_In, 0, 0, '1111');
  End Loop;
  --定价信息 
  If 收入id_In Is Not Null Then
    v_No := Nextno(9);
    --非跟踪在用的时价卫材，在销售时相当于一般的收费项目，在调价时应按”最低限价、最高限价、缺省价格”进行设置。 
    Insert Into 收费价目
      (ID, 原价id, 收费细目id, 原价, 现价, 缺省价格, 收入项目id, 变动原因, 调价说明, 调价人, 执行日期, 终止日期, NO, 序号)
    Values
      (收费价目_Id.Nextval, Null, 材料id_In, 0, 当前售价_In, Decode(跟踪在用_In, 0, Decode(是否变价_In, 1, 当前售价_In, Null), Null), 收入id_In,
       1, '新增定价', User, Sysdate, To_Date('3000-01-01', 'YYYY-MM-DD'), v_No, 1);
  End If;

  --材料生产商比较增加 
  If 产地_In Is Not Null Then
    Update 材料生产商 Set 名称 = 产地_In Where 名称 = 产地_In;
    If Sql%RowCount = 0 Then
      Insert Into 材料生产商
        (编码, 名称, 简码)
        Select Nvl(Max(To_Number(编码)), 0) + 1, 产地_In, zlSpellCode(产地_In) From 材料生产商;
    End If;
  End If;

  --插入材料的服务科室 
  Insert Into 收费执行科室
    (收费细目id, 病人来源, 开单科室id, 执行科室id)
    Select 材料id_In, 病人来源, 开单科室id, 执行科室id From 诊疗执行科室 Where 诊疗项目id = 诊疗id_In;

  b_Message.Zlhis_Dict_043(材料id_In);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_卫生材料_Insert;
/

--119475:刘鹏飞,2018-01-08,输血申请单预览打印前调用检查函数
Create Or Replace Function Zl1_Fun_Bloodapplyprint
(
  医嘱id_In   病人医嘱记录.Id%Type,
  调用场合_In Number,
  申请类型_In Number,
  模式_In     Number
) Return Varchar2 As
  v_Return Varchar2(200);
Begin
  --功能说明:申请单预览打印时对医嘱的相关内容进行检查，并返回提示及处理结果。
  --入参说明：
  ----医嘱id_In=输血医嘱ID
  ----调用场合_in=1-门诊,2-住院
  ----申请类型_In=1-输血申请单;2-取血通知单(便于医院根据申请类型控制)
  ----模式_in:0=预览是调用；1-打印是调用
  --函数返回："处理结果|提示信息",处理结果=0-正常,1-询问提示,2-禁止；处理结果为0时，无需返回提示信息及分隔符。

  v_Return := Null;
  Return v_Return;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl1_Fun_Bloodapplyprint;
/

--119643:李南春,2018-01-08,消息发送内容调整
CREATE OR REPLACE Procedure Zl_门诊记帐记录_Insert
(
  No_In         门诊费用记录.No%Type,
  序号_In       门诊费用记录.序号%Type,
  病人id_In     门诊费用记录.病人id%Type,
  标识号_In     门诊费用记录.标识号%Type,
  姓名_In       门诊费用记录.姓名%Type,
  性别_In       门诊费用记录.性别%Type,
  年龄_In       门诊费用记录.年龄%Type,
  费别_In       门诊费用记录.费别%Type,
  加班标志_In   门诊费用记录.加班标志%Type,
  婴儿费_In     门诊费用记录.婴儿费%Type,
  病人科室id_In 门诊费用记录.病人科室id%Type,
  开单部门id_In 门诊费用记录.开单部门id%Type,
  开单人_In     门诊费用记录.开单人%Type,
  从属父号_In   门诊费用记录.从属父号%Type,
  收费细目id_In 门诊费用记录.收费细目id%Type,
  收费类别_In   门诊费用记录.收费类别%Type,
  计算单位_In   门诊费用记录.计算单位%Type,
  付数_In       门诊费用记录.付数%Type,
  数次_In       门诊费用记录.数次%Type,
  附加标志_In   门诊费用记录.附加标志%Type,
  执行部门id_In 门诊费用记录.执行部门id%Type,
  价格父号_In   门诊费用记录.价格父号%Type,
  收入项目id_In 门诊费用记录.收入项目id%Type,
  收据费目_In   门诊费用记录.收据费目%Type,
  标准单价_In   门诊费用记录.标准单价%Type,
  应收金额_In   门诊费用记录.应收金额%Type,
  实收金额_In   门诊费用记录.实收金额%Type,
  发生时间_In   门诊费用记录.发生时间%Type,
  登记时间_In   门诊费用记录.登记时间%Type,
  药品摘要_In   药品收发记录.摘要%Type,
  划价_In       Number,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  记帐单id_In   门诊费用记录.记帐单id%Type := Null,
  费用摘要_In   门诊费用记录.摘要%Type := Null,
  医嘱序号_In   门诊费用记录.医嘱序号%Type := Null,
  频次_In       药品收发记录.频次%Type := Null,
  单量_In       药品收发记录.单量%Type := Null,
  用法_In       药品收发记录.用法%Type := Null, --用法[|煎法]
  期效_In       药品收发记录.扣率%Type := Null,
  计价特性_In   药品收发记录.扣率%Type := Null,
  门诊标志_In   门诊费用记录.门诊标志%Type := 1,
  中药形态_In   门诊费用记录.结论%Type := Null,
  备货材料_In   Number := 0,
  批次_In       药品收发记录.批次%Type := Null
) As
  --功能：新收一张门诊记帐单据
  --参数：
  --   药品摘要_IN:修改保存新单据时用。目前仅用于存放于药品收发记录的摘要中。
  --         原单据(记录状态=2)记录修改产生的新单据号。
  --         新单据(记录状态=1)记录所修改的原单据号。
  v_费用id 门诊费用记录.Id%Type;
  n_急诊   病人挂号记录.急诊%Type;

  --临时变量
  v_用法     药品收发记录.用法%Type;
  v_煎法     药品收发记录.外观%Type;
  n_单价小数 Number;
  n_挂号id   病人挂号记录.Id%Type;
  n_留观次数 病案主页.主页id%Type;

  n_Dec     Number;
  n_Count   Number;
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_发药窗口 药品收发记录.发药窗口%Type;
  n_跟踪在用 材料特性.跟踪在用%Type;

Begin
  n_跟踪在用 := 0;
  If 收费类别_In = '4' Then
    --跟踪在用的卫材才处理
    Select Nvl(跟踪在用, 0) Into n_跟踪在用 From 材料特性 Where 材料id = 收费细目id_In;
  End If;

  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')), Zl_To_Number(Nvl(zl_GetSysParameter(157), '5'))
  Into n_Dec, n_单价小数
  From Dual;

  Select Max(主页id) Into n_留观次数 From 病案主页 Where 病人id = 病人id_In And 病人性质 = 1 And 出院日期 Is Null;

  If (收费类别_In In ('5', '6', '7') Or 收费类别_In = '4' And n_跟踪在用 = 1) And Nvl(划价_In, 0) = 0 Then
    --同一张单据,满足同一药房同一窗口
    Begin
      Select 发药窗口
      Into v_发药窗口
      From 门诊费用记录
      Where 收费类别 In ('5', '6', '7', '4') And NO = No_In And 记录性质 = 2 And 执行部门id = 执行部门id_In And 发药窗口 Is Not Null And
            Rownum <= 1;
    Exception
      When Others Then
        v_发药窗口 := Null;
    End;
    If v_发药窗口 Is Null Then
      --同一病人在普通号挂号有效挂号天数内且未发药的且上班的,以最近一次记账窗口为准
      n_Count := To_Number(Substr(Nvl(zl_GetSysParameter(21), '11') || '11', 1, 1));
      If n_Count = 0 Then
        n_Count := 1;
      End If;

      Begin
        Select 发药窗口
        Into v_发药窗口
        From (Select 登记时间, 发药窗口
               From 门诊费用记录 A
               Where 收费类别 In ('5', '6', '7', '4') And 病人id = 病人id_In And 登记时间 Between Sysdate - n_Count And Sysdate And
                     记录性质 = 2 And 执行部门id = 执行部门id_In And 发药窗口 Is Not Null And Exists
                (Select 1
                      From 未发药品记录
                      Where a.No = NO And 单据 In (9, 26) And 库房id + 0 = 执行部门id_In And 病人id + 0 = 病人id_In) And Exists
                (Select 1
                      From 发药窗口
                      Where Nvl(上班否, 0) = 1 And 名称 = a.发药窗口 And Nvl(专家, 0) = 0 And 药房id = 执行部门id_In)
               Order By 登记时间 Desc)
        Where Rownum <= 1;

      Exception
        When Others Then
          v_发药窗口 := Null;
      End;
      If v_发药窗口 Is Null Then
        v_发药窗口 := Zl_Get发药窗口(执行部门id_In);
      End If;
    End If;
  End If;
  --门诊费用记录
  Select 病人费用记录_Id.Nextval Into v_费用id From Dual;

  --是否是急诊挂号单
  If Nvl(医嘱序号_In, 0) <> 0 Then
    Begin
      Select Nvl(Max(急诊), 0), Max(ID)
      Into n_急诊, n_挂号id
      From 病人挂号记录
      Where NO In (Select 挂号单 From 病人医嘱记录 Where ID = Nvl(医嘱序号_In, 0)) And 病人id = 病人id_In;
    Exception
      When Others Then
        n_急诊   := Null;
        n_挂号id := Null;
    End;
  End If;

  Insert Into 门诊费用记录
    (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 数次, 加班标志,
     附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 记帐费用, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 操作员编号, 操作员姓名, 婴儿费, 记帐单id,
     摘要, 医嘱序号, 结论, 发药窗口, 是否急诊, 主页id, 挂号id)
  Values
    (v_费用id, 2, No_In, Decode(划价_In, 1, 0, 1), 序号_In, Decode(从属父号_In, 0, Null, 从属父号_In),
     Decode(价格父号_In, 0, Null, 价格父号_In), 门诊标志_In, 病人id_In, Decode(标识号_In, 0, Null, 标识号_In), 姓名_In, 性别_In, 年龄_In,
     病人科室id_In, 费别_In, 收费类别_In, 收费细目id_In, 计算单位_In, 付数_In, 数次_In, 加班标志_In, 附加标志_In, 收入项目id_In, 收据费目_In, 标准单价_In, 应收金额_In,
     实收金额_In, 1, 操作员姓名_In, 开单部门id_In, 开单人_In, 发生时间_In, 登记时间_In, 执行部门id_In, 0, Decode(划价_In, 1, Null, 操作员编号_In),
     Decode(划价_In, 1, Null, 操作员姓名_In), 婴儿费_In, 记帐单id_In, 费用摘要_In, 医嘱序号_In, 中药形态_In, v_发药窗口, Nvl(n_急诊, 0), n_留观次数, n_挂号id);

  --相关汇总表的处理
  If Nvl(划价_In, 0) = 0 Then
    --病人余额
    If Nvl(门诊标志_In, 0) <> 4 Then
      Update 病人余额 Set 费用余额 = Nvl(费用余额, 0) + 实收金额_In Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1;

      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (病人id_In, 1, 1, 实收金额_In, 0);
      End If;
    End If;

    --病人未结费用
    Update 病人未结费用
    Set 金额 = Nvl(金额, 0) + 实收金额_In
    Where 病人id = 病人id_In And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(病人科室id_In, 0) And
          Nvl(开单部门id, 0) = Nvl(开单部门id_In, 0) And Nvl(执行部门id, 0) = Nvl(执行部门id_In, 0) And 收入项目id + 0 = 收入项目id_In And
          来源途径 + 0 = 门诊标志_In;

    If Sql%RowCount = 0 Then
      Insert Into 病人未结费用
        (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
      Values
        (病人id_In, Null, Null, 病人科室id_In, 开单部门id_In, 执行部门id_In, 收入项目id_In, 门诊标志_In, 实收金额_In);
    End If;

  End If;

  --药品和卫生材料部分
  If 收费类别_In In ('4', '5', '6', '7') Then
    --药品用法煎法分解
    If 用法_In Is Not Null Then
      If Instr(用法_In, '|') > 0 Then
        v_用法 := Substr(用法_In, 1, Instr(用法_In, '|') - 1);
        v_煎法 := Substr(用法_In, Instr(用法_In, '|') + 1);
      Else
        v_用法 := 用法_In;
      End If;
    End If;
    Zl_药品收发记录_销售出库(v_费用id, 药品摘要_In, 频次_In, 单量_In, v_用法, v_煎法, 期效_In, 计价特性_In, Null, 备货材料_In, 批次_In);
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊记帐记录_Insert;
/

--119437:胡俊勇,2018-01-11,临床相关消息修改
--119643:李南春,2018-01-08,消息发送内容调整
CREATE OR REPLACE Procedure Zl_Turntoward_Fee
(
  操作_In       Number,
  病人id_In     病案主页.病人id%Type,
  主页id_In     病案主页.病人id%Type,
  变动id_In     病人变动记录.Id%Type,
  原病区id_In   病案主页.当前病区id%Type,
  目标病区id_In 病案主页.当前病区id%Type,
  操作员编号_In 住院费用记录.操作员编号%Type,
  操作员姓名_In 住院费用记录.操作员姓名%Type,
  变动时间_In   住院费用记录.登记时间%Type := Null
) Is
  --功能:病人转病区费用的转入，转出处理
  --入参:操作_In: 0-病区变动,1-撤消病区变动
  --   1、操作_IN=0(病区变动)时
  --       变动ID_In: 原病区的变动记录的ID
  --       原病区ID_IN：原病区ID
  --       目标病区ID_IN:目标病区ID
  --   2、操作_IN=1(撤消病区变动)时
  --       变动ID_In: 恢复的原始病区的变动记录的ID
  --       原病区ID_IN：被撤消的病区ID
  --       目标病区ID_IN:恢复的原始病区ID
  --转入，转出规则:
  --1.病区执行的非药品和卫生材料，处理规则为
  --   1)将原记录进行销帐处理
  --   2)新增一条新病区的费用，病人科室，发生时间不变
  --2.病区执行的药品和卫生材料
  --   这个卫材退的处理在转病区时的界面中进行确认(可以打印核查清单)，在转病区发起的时候确认。
  --   a)卫材在原病区通过销帐申请来处理，新病区手工计卫材；
  --   b)撤消转病区时，自动撤消销帐申请，如果已经销帐审核了，则询问提示并且不作卫材费用处理，手工去处理。
  Err_Item Exception;
  v_Err_Msg Varchar2(200);

  v_No             住院费用记录.No%Type;
  n_Max序号        住院费用记录.序号%Type;
  n_Dec            Number;
  n_病人审核方式   Number(2);
  n_未入科禁止记账 Number(2);
  n_审核标志       病案主页.审核标志%Type;
  n_住院状态       病案主页.状态%Type;
  n_已检查         Number(2);
  v_责任护士       病人变动记录.责任护士%Type;
  d_登记时间       Date;
  n_Count          Number(18);

  n_未发料数量   病人费用销帐.数量%Type;
  n_申请未发数量 病人费用销帐.数量%Type;
  n_申请已发数量 病人费用销帐.数量%Type;
  n_申请销账数量 病人费用销帐.数量%Type;
  n_申请取消数量 病人费用销帐.数量%Type;

  v_原病区名称   部门表.名称%Type;
  v_目标病区名称 部门表.名称%Type;
  n_应收金额     住院费用记录.应收金额%Type;
  n_实收金额     住院费用记录.实收金额%Type;
  n_记录状态     费用变动记录.记录状态%Type;

  n_原变动id   病人变动记录.Id%Type;
  n_目标变动id 病人变动记录.Id%Type;
  n_变动id     病人变动记录.Id%Type;

  Procedure 销帐申请_Insert
  (
    费用id_In     病人费用销帐.费用id%Type,
    医嘱id_In     住院费用记录.医嘱序号%Type,
    申请类别_In   病人费用销帐.申请类别%Type,
    收费细目id_In 病人费用销帐.收费细目id%Type,
    申请部门id_In 病人费用销帐.申请部门id%Type,
    审核部门id_In 病人费用销帐.审核部门id%Type,
    数量_In       病人费用销帐.数量%Type,
    申请人_In     病人费用销帐.申请人%Type,
    申请时间_In   病人费用销帐.申请时间%Type,
    状态_In       病人费用销帐.状态%Type,
    销帐原因_In   病人费用销帐.销帐原因%Type
  ) Is
  Begin
    --全部都执行了，肯定销帐数量为已执行的
    Insert Into 病人费用销帐
      (费用id, 申请类别, 收费细目id, 审核部门id, 申请部门id, 数量, 申请人, 申请时间, 状态, 销帐原因)
    Values
      (费用id_In, 申请类别_In, 收费细目id_In, 审核部门id_In, 申请部门id_In, 数量_In, 申请人_In, 申请时间_In, 状态_In, 销帐原因_In);
  End;
Begin
  If 目标病区id_In Is Null Then
    Return;
  End If;

  Begin
    Select ID
    Into n_变动id
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 15 And 终止时间 Is Null;
  Exception
    When Others Then
      v_Err_Msg := '未找到病人的原始变动记录，禁止操作!';
      Raise Err_Item;
  End;

  If Nvl(操作_In, 0) = 0 Then
    n_原变动id   := 变动id_In;
    n_目标变动id := n_变动id;
    n_记录状态   := 1;
  Else
    n_原变动id   := n_变动id;
    n_目标变动id := 变动id_In;
    n_记录状态   := 2;
  End If;

  Select Max(责任护士), Count(1) Into v_责任护士, n_Count From 病人变动记录 Where ID = n_原变动id;
  If Nvl(n_Count, 0) = 0 Then
    v_Err_Msg := '未找到病人的原始变动记录，禁止操作！';
    Raise Err_Item;
  End If;

  Select Max(Decode(ID, 原病区id_In, 名称, Null)), Max(Decode(ID, 目标病区id_In, 名称, Null))
  Into v_原病区名称, v_目标病区名称
  From 部门表
  Where ID In (原病区id_In, 目标病区id_In);

  d_登记时间 := 变动时间_In;
  If d_登记时间 Is Null Then
    d_登记时间 := Sysdate;
  End If;

  n_病人审核方式   := Nvl(zl_GetSysParameter(185), 0);
  n_未入科禁止记账 := Nvl(zl_GetSysParameter(215), 0);
  --金额小数位数
  n_Dec := Zl_To_Number(Nvl(zl_GetSysParameter(9), '2'));

  n_审核标志 := 0;
  n_住院状态 := 0;
  n_已检查   := 0;

  If n_病人审核方式 = 1 Or n_未入科禁止记账 = 1 Then
    Select Nvl(审核标志, 0), Nvl(状态, 0)
    Into n_审核标志, n_住院状态
    From 病案主页
    Where 病人id = 病人id_In And 主页id = 主页id_In;
  End If;

  n_Max序号 := 0;
  v_No      := '-~';
  --当前病区的医嘱费用，不包含医嘱附费及药品
  For c_费用 In (Select a.No, a.序号, a.记录状态, a.收费细目id, Nvl(剩余数量, 0) - Nvl(已执行数, 0) As 准退数, a.卫材, a.医嘱id, b.发送号, a.费用id,
                      a. 执行状态, a. 标准单价, a. 应收金额, a. 实收金额, a.收费类别, b.费用id As 医嘱费用id
               From (Select a.No, a.序号, Max(a.收费细目id) As 收费细目id, Max(a.医嘱序号) As 医嘱id, Sum(数量) As 剩余数量,
                             Max(Decode(a.记录状态, 2, 0, a.费用id)) As 费用id, Max(a.记录状态) As 记录状态, Max(a.执行状态) As 执行状态,
                             Max(a.标准单价) As 标准单价, Sum(a.应收金额) As 应收金额, Sum(a.实收金额) As 实收金额, Max(a.收费类别) As 收费类别,
                             Nvl(Max(c.跟踪在用), 0) As 卫材
                      From (Select a.No, 记录状态, a.医嘱序号, Nvl(a.价格父号, 序号) As 序号, 收费细目id, a.执行状态, Avg(Nvl(a.付数, 1) * a.数次) As 数量,
                                    Sum(a.标准单价) As 标准单价, Sum(a.应收金额) As 应收金额, Sum(a.实收金额) As 实收金额, Max(a.收费类别) As 收费类别,
                                    Max(Decode(a.价格父号, Null, a.Id, 0)) As 费用id
                             From 住院费用记录 A, 病人医嘱发送 B
                             Where a.记录性质 = b.记录性质 And a.医嘱序号 = b.医嘱id And a.No = b.No And a.记录性质 = 2 And
                                   a.执行部门id = 原病区id_In And a.医嘱序号 Is Not Null And a.病人id = 病人id_In And a.主页id = 主页id_In And
                                   Instr(',5,6,7,', ',' || a.收费类别 || ',') = 0
                             Group By a.No, 记录状态, a.医嘱序号, Nvl(a.价格父号, 序号), 收费细目id, a.执行状态) A, 材料特性 C
                      Where a.收费细目id = c.材料id(+)
                      Group By a.No, a.序号) A,
                    (Select b.No, b.医嘱id, b.发送号, c.收费细目id, Nvl(c.费用id, 0) As 费用id,
                             Sum(Decode(Nvl(c.执行状态, 0), 1, c.数量, 0)) As 已执行数
                      From 病人医嘱记录 A, 病人医嘱发送 B, 医嘱执行计价 C, 材料特性 D
                      Where a.Id = b.医嘱id And b.发送号 = c.发送号(+) And b.医嘱id = c.医嘱id(+) And b.记录性质 = 2 And
                            Nvl(b.执行状态, 0) <> 1 And c.收费细目id = d.材料id(+) And Nvl(d.跟踪在用, 0) = 0 And a.病人id = 病人id_In And
                            a.主页id = 主页id_In
                      Group By b.No, b.医嘱id, b.发送号, c.收费细目id, Nvl(c.费用id, 0)
                      Union All
                      Select Null As NO, Null As 医嘱id, Null As 发送号, Null As 收费细目id, Null As 费用id, Null As 已执行数
                      From Dual) B
               Where (a.No = b.No And a.医嘱id = b.医嘱id And a.收费细目id = b.收费细目id And
                     (a.费用id = b.费用id Or Nvl(b.费用id, 0) = 0) And Nvl(剩余数量, 0) - Nvl(已执行数, 0) > 0) Or
                     (a.卫材 = 1 And b.No Is Null)
               Order By NO) Loop

    If v_No <> c_费用.No Then
      v_No := c_费用.No;
      Select Nvl(Max(序号), 0)
      Into n_Max序号
      From 住院费用记录
      Where NO = v_No And 记录性质 = 2 And 记录状态 In (0, 1, 3);
    End If;

    --填写 医嘱执行计价.费用ID
    If Nvl(c_费用.医嘱费用id, 0) = 0 And Nvl(c_费用.卫材, 0) = 0 Then
      For c_记录 In (Select ID, 收费细目id
                   From 住院费用记录
                   Where 记录性质 = 2 And 记录状态 <> 2 And NO = c_费用.No And 医嘱序号 = c_费用.医嘱id And 价格父号 Is Null) Loop
        Update 医嘱执行计价
        Set 费用id = c_记录.Id
        Where 医嘱id = c_费用.医嘱id And 发送号 = c_费用.发送号 And 收费细目id = c_记录.收费细目id And 费用id Is Null;
      End Loop;
    End If;

    --只有存在费用变动时才需要检查
    If Nvl(n_已检查, 0) = 0 Then
      --只检查一次
      If n_未入科禁止记账 = 1 And n_住院状态 = 1 Then
        v_Err_Msg := '病人未入科，禁止对病人相关费用的操作！';
        Raise Err_Item;
      End If;
      If n_病人审核方式 = 1 Then
        If Nvl(n_审核标志, 0) = 1 Then
          v_Err_Msg := '该病人目前正在审核费用，不能进行费用相关调整！';
          Raise Err_Item;
        End If;
        If Nvl(n_审核标志, 0) = 2 Then
          v_Err_Msg := '该病人目前已经完成了费用审核，不能进行费用相关调整！';
          Raise Err_Item;
        End If;
      End If;
      n_已检查 := 1;
    End If;

    --1.卫生材料在病区执行的，直接发出销帐申请
    If Nvl(c_费用.卫材, 0) = 1 Then
      If c_费用.记录状态 = 0 Then
        v_Err_Msg := '单据 ' || c_费用.No || ' 还未进行审核，禁止转病区操作！';
        Raise Err_Item;
      End If;
      If v_责任护士 Is Null Then
        v_Err_Msg := '原病区的责任护士不存在，不能进行卫材销帐申请！';
        Raise Err_Item;
      End If;

      Select Sum(b.实际数量)
      Into n_未发料数量
      From 药品收发记录 B
      Where 费用id = c_费用.费用id And Mod(b.记录状态, 3) = 1 And b.单据 In (24, 25, 26) And b.审核人 Is Null;

      Select Sum(Decode(申请类别, 0, 1, 0) * 数量), Sum(Decode(申请类别, 0, 0, 1) * 数量)
      Into n_申请未发数量, n_申请已发数量
      From 病人费用销帐
      Where 费用id = c_费用.费用id And Nvl(状态, 0) = 0;

      n_申请销账数量 := 0;
      If Nvl(n_未发料数量, 0) = Nvl(c_费用.准退数, 0) Then
        --都未执行
        n_申请未发数量 := Nvl(c_费用.准退数, 0) - Nvl(n_申请未发数量, 0);
        If n_申请未发数量 > 0 Then
          n_申请销账数量 := n_申请销账数量 + n_申请未发数量;
          销帐申请_Insert(c_费用.费用id, c_费用.医嘱id, 0, c_费用.收费细目id, 原病区id_In, 原病区id_In, n_申请未发数量, v_责任护士, d_登记时间, 0,
                      '从' || v_原病区名称 || '转到' || v_目标病区名称);
        End If;
      Elsif Nvl(n_未发料数量, 0) = 0 Then
        --全部都执行了，肯定销帐数量为已执行的
        n_申请已发数量 := Nvl(c_费用.准退数, 0) - Nvl(n_申请已发数量, 0);
        If n_申请已发数量 > 0 Then
          n_申请销账数量 := n_申请销账数量 + n_申请已发数量;
          销帐申请_Insert(c_费用.费用id, c_费用.医嘱id, 1, c_费用.收费细目id, 原病区id_In, 原病区id_In, n_申请已发数量, v_责任护士, d_登记时间, 0,
                      '从' || v_原病区名称 || '转到' || v_目标病区名称);
        End If;
      Else
        --可能有部分对执行的进行销帐，一部分对未执行的销帐
        n_申请未发数量 := Nvl(n_未发料数量, 0) - Nvl(n_申请未发数量, 0);
        If n_申请未发数量 > 0 Then
          n_申请销账数量 := n_申请销账数量 + n_申请未发数量;
          销帐申请_Insert(c_费用.费用id, c_费用.医嘱id, 0, c_费用.收费细目id, 原病区id_In, 原病区id_In, n_申请未发数量, v_责任护士, d_登记时间, 0,
                      '从' || v_原病区名称 || '转到' || v_目标病区名称);
        End If;
        --已执行部分
        n_申请已发数量 := Nvl(c_费用.准退数, 0) - Nvl(n_未发料数量, 0) - Nvl(n_申请已发数量, 0);
        If n_申请已发数量 > 0 Then
          n_申请销账数量 := n_申请销账数量 + n_申请已发数量;
          销帐申请_Insert(c_费用.费用id, c_费用.医嘱id, 1, c_费用.收费细目id, 原病区id_In, 原病区id_In, n_申请已发数量, v_责任护士, d_登记时间, 0,
                      '从' || v_原病区名称 || '转到' || v_目标病区名称);
        End If;
      End If;

      --增加变动记录
      If Nvl(n_申请销账数量, 0) > 0 Then
        n_应收金额 := Round(n_申请销账数量 * Nvl(c_费用.标准单价, 0), n_Dec);
        n_实收金额 := 0;
        If Nvl(c_费用.应收金额, 0) <> 0 Then
          n_实收金额 := Round(Nvl(n_应收金额, 0) * Nvl(c_费用.实收金额, 0) / c_费用.应收金额, n_Dec);
        End If;
        Insert Into 费用变动记录
          (ID, 记录状态, 病人id, 主页id, 变动时间, 原变动id, 目标变动id, 原病区id, 目标病区id, 费用id, NO, 收费类别, 收费细目id, 医嘱序号, 数量, 单价, 应收金额, 实收金额,
           状态, 摘要, 操作员编号, 操作员姓名)
        Values
          (费用变动记录_Id.Nextval, n_记录状态, 病人id_In, 主页id_In, d_登记时间, n_原变动id, n_目标变动id, 原病区id_In, 目标病区id_In, c_费用.费用id,
           c_费用.No, c_费用.收费类别, c_费用.收费细目id, c_费用.医嘱id, n_申请销账数量, c_费用.标准单价, n_应收金额, n_实收金额, 2,
           Decode(操作_In, 0, '病区变动', '病区变动撤销') || '产生的销帐申请', 操作员编号_In, 操作员姓名_In);
      End If;
    End If;

    --2.其他收费项目(药品未包含)
    If Nvl(c_费用.卫材, 0) = 0 And c_费用.执行状态 <> 1 Then
      --处理规则:
      --1.对原始记录进行销帐
      --2.新增目标病区数据
      --3.如果是划价单，直接更改原记录病区id和执行部门
      If Nvl(c_费用.记录状态, 0) = 0 Then
        --直接修改(包含病人病区及目标病区)
        Update 住院费用记录
        Set 病人病区id = 目标病区id_In, 执行部门id = 目标病区id_In
        Where NO = c_费用.No And 记录性质 = 2 And 记录状态 = 0 And Nvl(价格父号, 序号) = c_费用.序号;

        Insert Into 费用变动记录
          (ID, 记录状态, 病人id, 主页id, 变动时间, 原变动id, 目标变动id, 原病区id, 目标病区id, 费用id, NO, 收费类别, 收费细目id, 医嘱序号, 数量, 单价, 应收金额, 实收金额,
           状态, 摘要, 操作员编号, 操作员姓名)
          Select 费用变动记录_Id.Nextval, n_记录状态, 病人id_In, 主页id_In, d_登记时间, n_原变动id, n_目标变动id, 原病区id_In, 目标病区id_In, 费用id, NO,
                 收费类别, 收费细目id, 医嘱序号, 数量, 标准单价, 应收金额, 实收金额, 0, Decode(操作_In, 0, '病区变动', '病区变动撤销') || '修改记帐划价单', 操作员编号_In,
                 操作员姓名_In
          From (Select Max(Decode(价格父号, Null, ID, 0)) As 费用id, NO, 收费类别, 收费细目id, 医嘱序号, Avg(Nvl(付数, 1) * 数次) As 数量,
                        Sum(标准单价) As 标准单价, Sum(应收金额) As 应收金额, Sum(实收金额) As 实收金额
                 From 住院费用记录
                 Where NO = c_费用.No And 记录性质 = 2 And 记录状态 = 0 And Nvl(价格父号, 序号) = c_费用.序号
                 Group By NO, 收费类别, 收费细目id, 医嘱序号, Nvl(价格父号, 序号));
      Elsif Nvl(c_费用.准退数, 0) > 0 Then
        --直接销帐处理
        --序号：格式如"1,3,5,7,8",或"1:2:33456,3:2,5:2,7:2,8:2",冒号前面的数字表示行号,中间的数字表示退的数量,后面的数字表示配药记录的ID,目前仅在销帐审核时才传入
        --1.先产生销帐记录
        Zl_住院记帐记录_Delete(c_费用.No, c_费用.序号 || ':' || Nvl(c_费用.准退数, 0), 操作员编号_In, 操作员姓名_In, 2, 2, 0, d_登记时间);
        --2.目标病区转入记录
        For c_明细 In (Select 病人费用记录_Id.Nextval As 费用id, NO, 记录性质, 1 As 记录状态, n_Max序号 + Rownum As 序号, 从属父号,
                            价格父号 + (n_Max序号 + Rownum - 序号) As 价格父号, 主页id, 病人id, 医嘱序号, 门诊标志, 多病人单, 婴儿费, 姓名, 性别, 年龄, 标识号,
                            床号, 费别, 目标病区id_In As 病人病区id, 病人科室id, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, -1 * 数次 As 数次, 加班标志, 附加标志,
                            收入项目id, 收据费目, 记帐费用, 标准单价, -1 * 应收金额 As 应收金额, -1 * 实收金额 As 实收金额, 开单部门id, 开单人,
                            目标病区id_In As 执行部门id, 划价人, 执行人, c_费用.执行状态 As 执行状态, 执行时间, 操作员编号_In As 操作员编号, 操作员姓名_In As 操作员姓名,
                            发生时间, d_登记时间 As 登记时间, 保险项目否, 保险大类id, -1 * 统筹金额 As 统筹金额, 保险编码, 记帐单id, 摘要, 费用类型, 是否急诊, 结论,
                            医疗小组id
                     From 住院费用记录
                     Where NO = c_费用.No And Nvl(价格父号, 序号) = c_费用.序号 And 记录状态 = 2 And 登记时间 = d_登记时间) Loop
          Insert Into 住院费用记录
            (ID, NO, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 主页id, 病人id, 医嘱序号, 门诊标志, 多病人单, 婴儿费, 姓名, 性别, 年龄, 标识号, 床号, 费别, 病人病区id,
             病人科室id, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人,
             执行部门id, 划价人, 执行人, 执行状态, 执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 保险项目否, 保险大类id, 统筹金额, 保险编码, 记帐单id, 摘要, 费用类型, 是否急诊,
             结论, 医疗小组id)
          Values
            (c_明细.费用id, c_明细.No, c_明细.记录性质, c_明细.记录状态, c_明细.序号, c_明细.从属父号, c_明细.价格父号, c_明细.主页id, c_明细.病人id, c_明细.医嘱序号,
             c_明细.门诊标志, c_明细.多病人单, c_明细.婴儿费, c_明细.姓名, c_明细.性别, c_明细.年龄, c_明细.标识号, c_明细.床号, c_明细.费别, c_明细.病人病区id,
             c_明细.病人科室id, c_明细.收费类别, c_明细.收费细目id, c_明细.计算单位, c_明细.付数, c_明细.发药窗口, c_明细.数次, c_明细.加班标志, c_明细.附加标志,
             c_明细.收入项目id, c_明细.收据费目, c_明细.记帐费用, c_明细.标准单价, c_明细.应收金额, c_明细.实收金额, c_明细.开单部门id, c_明细.开单人, c_明细.执行部门id,
             c_明细.划价人, c_明细.执行人, /*c_明细.执行状态*/ 0, c_明细.执行时间, c_明细.操作员编号, c_明细.操作员姓名, c_明细.发生时间, c_明细.登记时间, c_明细.保险项目否,
             c_明细.保险大类id, c_明细.统筹金额, c_明细.保险编码, c_明细.记帐单id, c_明细.摘要, c_明细.费用类型, c_明细.是否急诊, c_明细.结论, c_明细.医疗小组id);

          Update 费用变动记录
          Set 单价 = Nvl(单价, 0) + Nvl(c_明细.标准单价, 0), 应收金额 = Nvl(应收金额, 0) + Nvl(c_明细.应收金额, 0),
              实收金额 = Nvl(实收金额, 0) + Nvl(c_明细.实收金额, 0)
          Where 费用id = c_费用.费用id And 变动时间 = d_登记时间 And 目标变动id = n_目标变动id And 收费细目id = c_费用.收费细目id And
                病人id + 0 = c_明细.病人id;
          If Sql%NotFound Then
            Insert Into 费用变动记录
              (ID, 记录状态, 病人id, 主页id, 变动时间, 原变动id, 目标变动id, 原病区id, 目标病区id, 费用id, NO, 收费类别, 收费细目id, 医嘱序号, 数量, 单价, 应收金额,
               实收金额, 状态, 摘要, 操作员编号, 操作员姓名)
            Values
              (费用变动记录_Id.Nextval, n_记录状态, 病人id_In, 主页id_In, d_登记时间, n_原变动id, n_目标变动id, 原病区id_In, 目标病区id_In, c_费用.费用id,
               c_费用.No, c_费用.收费类别, c_费用.收费细目id, c_费用.医嘱id, Round(c_明细.数次 * Nvl(c_明细.付数, 1), 5), c_明细.标准单价, c_明细.应收金额,
               c_明细.实收金额, 1, Decode(操作_In, 0, '病区变动', '病区变动撤销') || '修改记帐单', 操作员编号_In, 操作员姓名_In);
          End If;

          Update 病人审批项目
          Set 已用数量 = Nvl(已用数量, 0) + Round(c_明细.数次 * Nvl(c_明细.付数, 1), 5)
          Where 病人id = 病人id_In And 主页id = 主页id_In And 项目id = c_明细.收费细目id And Nvl(使用限量, 0) <> 0;

          --病人余额
          Update 病人余额
          Set 费用余额 = Nvl(费用余额, 0) + c_明细.实收金额
          Where 病人id = c_明细.病人id And 类型 = 2 And 性质 = 1;
          If Sql%RowCount = 0 Then
            Insert Into 病人余额
              (病人id, 类型, 性质, 费用余额, 预交余额)
            Values
              (c_明细.病人id, 2, 1, c_明细.实收金额, 0);
          End If;
          --病人未结费用
          Update 病人未结费用
          Set 金额 = Nvl(金额, 0) + c_明细.实收金额
          Where 病人id = c_明细.病人id And Nvl(主页id, 0) = Nvl(c_明细.主页id, 0) And Nvl(病人病区id, 0) = Nvl(c_明细.病人病区id, 0) And
                Nvl(病人科室id, 0) = Nvl(c_明细.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(c_明细.开单部门id, 0) And
                Nvl(执行部门id, 0) = Nvl(c_明细.执行部门id, 0) And 收入项目id + 0 = c_明细.收入项目id And 来源途径 + 0 = 2;
          If Sql%RowCount = 0 Then
            Insert Into 病人未结费用
              (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
            Values
              (c_明细.病人id, c_明细.主页id, c_明细.病人病区id, c_明细.病人科室id, c_明细.开单部门id, c_明细.执行部门id, c_明细.收入项目id, 2, c_明细.实收金额);
          End If;

          --更新医嘱执行计价的费用ID
          If Nvl(c_明细.价格父号, 0) = 0 Then
            Update 医嘱执行计价
            Set 费用id = c_明细.费用id
            Where 医嘱id = c_费用.医嘱id And 发送号 = c_费用.发送号 And 费用id = c_费用.费用id And 执行状态 = 0;
          End If;

          n_Max序号 := c_明细.序号;
        End Loop;
      End If;
    End If;
  End Loop;

  If Nvl(操作_In, 0) = 1 Then
    --撤消操作,需要删除卫生材料部分中未审核部分
    For c_销账 In (Select a.费用id, a.病人id, a.主页id, a.No, a.收费类别, a.收费细目id, a.医嘱序号, a.数量, a.单价, a.应收金额, a.实收金额
                 From 费用变动记录 A
                 Where a.原变动id = n_目标变动id And a.目标变动id = n_原变动id And a.状态 = 2) Loop

      Select Sum(数量) Into n_申请取消数量 From 病人费用销帐 Where 费用id = c_销账.费用id And 状态 In (0, 2);

      If Nvl(n_申请取消数量, 0) > 0 Then
        n_应收金额 := Round(n_申请取消数量 * Nvl(c_销账.单价, 0), n_Dec);
        n_实收金额 := 0;
        If Nvl(c_销账.应收金额, 0) <> 0 Then
          n_实收金额 := Round(Nvl(n_应收金额, 0) * Nvl(c_销账.实收金额, 0) / c_销账.应收金额, n_Dec);
        End If;

        Insert Into 费用变动记录
          (ID, 记录状态, 病人id, 主页id, 变动时间, 原变动id, 目标变动id, 原病区id, 目标病区id, 费用id, NO, 收费类别, 收费细目id, 医嘱序号, 数量, 单价, 应收金额, 实收金额,
           状态, 摘要, 操作员编号, 操作员姓名)
        Values
          (费用变动记录_Id.Nextval, n_记录状态, c_销账.病人id, c_销账.主页id, d_登记时间, n_原变动id, n_目标变动id, 原病区id_In, 目标病区id_In, c_销账.费用id,
           c_销账.No, c_销账.收费类别, c_销账.收费细目id, c_销账.医嘱序号, n_申请取消数量, c_销账.单价, n_应收金额, n_实收金额, 3, '病区撤销后删除销帐申请', 操作员编号_In,
           操作员姓名_In);
      End If;

      Delete 病人费用销帐 Where 费用id = c_销账.费用id And 状态 In (0, 2);
    End Loop;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Turntoward_Fee;
/

--119743:刘兴洪,2018-01-15,根据挂号单生成划价记录
--119643:李南春,2018-01-08,消息发送内容调整
Create Or Replace Procedure Zl_门诊划价记录_Insert
(
  No_In         门诊费用记录.No%Type,
  序号_In       门诊费用记录.序号%Type,
  病人id_In     门诊费用记录.病人id%Type,
  主页id_In     住院费用记录.主页id%Type,
  标识号_In     门诊费用记录.标识号%Type,
  付款方式_In   门诊费用记录.付款方式%Type,
  姓名_In       门诊费用记录.姓名%Type,
  性别_In       门诊费用记录.性别%Type,
  年龄_In       门诊费用记录.年龄%Type,
  费别_In       门诊费用记录.费别%Type,
  加班标志_In   门诊费用记录.加班标志%Type,
  病人科室id_In 门诊费用记录.病人科室id%Type,
  开单部门id_In 门诊费用记录.开单部门id%Type,
  开单人_In     门诊费用记录.开单人%Type,
  从属父号_In   门诊费用记录.从属父号%Type,
  收费细目id_In 门诊费用记录.收费细目id%Type,
  收费类别_In   门诊费用记录.收费类别%Type,
  计算单位_In   门诊费用记录.计算单位%Type,
  发药窗口_In   门诊费用记录.发药窗口%Type,
  付数_In       门诊费用记录.付数%Type,
  数次_In       门诊费用记录.数次%Type,
  附加标志_In   门诊费用记录.附加标志%Type,
  执行部门id_In 门诊费用记录.执行部门id%Type,
  价格父号_In   门诊费用记录.价格父号%Type,
  收入项目id_In 门诊费用记录.收入项目id%Type,
  收据费目_In   门诊费用记录.收据费目%Type,
  标准单价_In   门诊费用记录.标准单价%Type,
  应收金额_In   门诊费用记录.应收金额%Type,
  实收金额_In   门诊费用记录.实收金额%Type,
  发生时间_In   门诊费用记录.发生时间%Type,
  登记时间_In   门诊费用记录.登记时间%Type,
  药品摘要_In   药品收发记录.摘要%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  费用摘要_In   门诊费用记录.摘要%Type := Null,
  医嘱序号_In   门诊费用记录.医嘱序号%Type := Null,
  频次_In       药品收发记录.频次%Type := Null,
  单量_In       药品收发记录.单量%Type := Null,
  用法_In       药品收发记录.用法%Type := Null, --用法[|煎法]
  期效_In       药品收发记录.扣率%Type := Null,
  计价特性_In   药品收发记录.扣率%Type := Null,
  病人来源_In   Number := 1,
  保险编码_In   门诊费用记录.保险编码%Type := Null,
  费用类型_In   门诊费用记录.费用类型%Type := Null,
  保险项目否_In 门诊费用记录.保险项目否%Type := Null,
  保险大类id_In 门诊费用记录.保险大类id%Type := Null,
  中药形态_In   门诊费用记录.结论%Type := Null,
  备货材料_In   Number := 0,
  批次_In       药品收发记录.批次%Type := Null,
  执行人_In     门诊费用记录.执行人%Type := Null
) As
  --功能：新收一张门诊划价单据
  --参数：
  --   病人来源_IN:1-门诊病人,2-住院病人
  --     主页ID_IN:住院病人划价时用。
  --   药品摘要_IN:修改保存新单据时用。目前仅存放在药品收发记录的摘要中。
  --         新单据(记录状态=1)记录所修改的原单据号。
  v_费用id   门诊费用记录.Id%Type;
  n_急诊     病人挂号记录.急诊%Type;
  n_挂号id   病人挂号记录.Id%Type;
  n_留观次数 门诊费用记录.主页id%Type;

  --临时变量
  v_用法       药品收发记录.用法%Type;
  v_煎法       药品收发记录.外观%Type;
  n_Dec        Number;
  v_付款方式   医疗付款方式.名称%Type;
  v_费别性质   费别.属性%Type;
  n_新病人模式 Number;
  n_单价小数   Number;
  v_Err_Msg    Varchar2(255);
  Err_Item Exception;
Begin
  --金额及单价小数位数
  Select Zl_To_Number(Nvl(Zl_Getsysparameter(9), '2')), Zl_To_Number(Nvl(Zl_Getsysparameter(157), '5'))
  Into n_Dec, n_单价小数
  From Dual;

  --门诊费用记录
  Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
  Select Max(主页id) Into n_留观次数 From 病案主页 Where 病人id = 病人id_In And 病人性质 = 1 And 出院日期 Is Null;
  --是否是急诊挂号单
  If Nvl(医嘱序号_In, 0) <> 0 Then
    Begin
      Select Nvl(Max(急诊), 0), Max(ID)
      Into n_急诊, n_挂号id
      From 病人挂号记录
      Where NO In (Select 挂号单 From 病人医嘱记录 Where ID = Nvl(医嘱序号_In, 0)) And 病人id = 病人id_In;
    Exception
      When Others Then
        n_急诊   := Null;
        n_挂号id := Null;
    End;
  End If;

  Insert Into 门诊费用记录
    (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 数次, 发药窗口,
     加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 记帐费用, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 摘要, 医嘱序号, 保险项目否, 保险编码,
     保险大类id, 费用类型, 结论, 是否急诊, 挂号id, 主页id, 付款方式, 执行人, 执行时间, 执行状态)
  Values
    (v_费用id, 1, No_In, 0, 序号_In, Decode(从属父号_In, 0, Null, 从属父号_In), Decode(价格父号_In, 0, Null, 价格父号_In), Nvl(病人来源_In, 1),
     Decode(病人id_In, 0, Null, 病人id_In), Decode(标识号_In, 0, Null, 标识号_In), 姓名_In, 性别_In, 年龄_In, 病人科室id_In, 费别_In, 收费类别_In,
     收费细目id_In, 计算单位_In, 付数_In, 数次_In, 发药窗口_In, 加班标志_In, 附加标志_In, 收入项目id_In, 收据费目_In, 标准单价_In, 应收金额_In, 实收金额_In, 0,
     操作员姓名_In, 开单部门id_In, 开单人_In, 发生时间_In, 登记时间_In, 执行部门id_In, 费用摘要_In, 医嘱序号_In, 保险项目否_In, 保险编码_In, 保险大类id_In, 费用类型_In,
     中药形态_In, Nvl(n_急诊, 0), n_挂号id, n_留观次数, 付款方式_In, 执行人_In, Decode(执行人_In, Null, Null, 登记时间_In),
     Decode(执行人_In, Null, 0, 2));

  --药品和卫生材料部分
  If 收费类别_In In ('4', '5', '6', '7') Then
    --药品用法煎法分解
    If 用法_In Is Not Null Then
      If Instr(用法_In, '|') > 0 Then
        v_用法 := Substr(用法_In, 1, Instr(用法_In, '|') - 1);
        v_煎法 := Substr(用法_In, Instr(用法_In, '|') + 1);
      Else
        v_用法 := 用法_In;
      End If;
    End If;
    Zl_药品收发记录_销售出库(v_费用id, 药品摘要_In, 频次_In, 单量_In, v_用法, v_煎法, 期效_In, 计价特性_In, 主页id_In, 备货材料_In, 批次_In);
  End If;

  --更新部份病人信息
  If 序号_In = 1 And 病人id_In Is Not Null Then
  
    If 付款方式_In Is Not Null And 病人来源_In = 1 Then
      Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In;
    End If;
  
    If 费别_In Is Not Null Then
      Select Max(属性) Into v_费别性质 From 费别 Where 名称 = 费别_In; --2-动态费别不更新
    End If;
  
    Update 病人信息
    Set 性别 = Decode(姓名, '新病人', Nvl(性别_In, 性别), 性别), 年龄 = Decode(姓名, '新病人', Nvl(年龄_In, 年龄), 年龄),
        姓名 = Decode(姓名, '新病人', 姓名_In, 姓名), 医疗付款方式 = Nvl(v_付款方式, 医疗付款方式), 费别 = Decode(v_费别性质, 1, 费别_In, 费别)
    Where 病人id = 病人id_In;
  
    Select Zl_To_Number(Nvl(Zl_Getsysparameter('自动产生姓名', '1111'), '0')) Into n_新病人模式 From Dual;
    If n_新病人模式 = 1 Then
      Update 病人挂号记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In
      Where 病人id = 病人id_In And 姓名 = '新病人';
      Update 门诊费用记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In
      Where 病人id = 病人id_In And 姓名 = '新病人';
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_门诊划价记录_Insert;
/

--119643:李南春,2018-01-08,消息发送内容调整
CREATE OR REPLACE Procedure Zl_门诊记帐记录_Verify
(
  No_In         门诊费用记录.No%Type,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  序号_In       Varchar2 := Null,
  审核时间_In   门诊费用记录.登记时间%Type := Null
) As
  --功能：审核一张门诊记帐划价单
  --参数：
  --    序号_IN：格式如"1,3,5,7,8",为空表示审核所有未审核的行
  --    审核时间_IN：用于部份需要统一控制或返回时间的地方
  --只读取指定序号的,未审核的部份进行处理
  Cursor c_Bill Is
    Select a.Id, a.病人id, a.实收金额, a.门诊标志, a.收入项目id, a.执行部门id, a.开单部门id, a.病人科室id, a.发药窗口, a.收费类别, Nvl(b.跟踪在用, 0) As 跟踪在用,
           a.医嘱序号
    From 门诊费用记录 A, 材料特性 B
    Where a.收费细目id = b.材料id(+) And a.记录性质 = 2 And a.记录状态 = 0 And a.No = No_In And
          (Instr(',' || 序号_In || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 Or 序号_In Is Null)
    Order By a.序号;

  --审核中包含跟踪在用的未发卫料时，根据参数设置是否自动发料
  Cursor c_Stuff Is
    Select ID, 库房id
    From 药品收发记录 M
    Where NO = No_In And 单据 = 25 And 库房id Is Not Null And 记录状态 = 1 And 审核人 Is Null And Exists
     (Select 1
           From 门诊费用记录 A, 材料特性 B
           Where a.Id = m.费用id + 0 And a.记录性质 = 2 And a.记录状态 = 1 And a.No = No_In And
                 (Instr(',' || 序号_In || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 Or 序号_In Is Null) And
                 a.收费细目id = b.材料id And b.跟踪在用 = 1)
    Order By 库房id, 药品id;

  --
  n_发料号   药品收发记录.汇总发药号%Type;
  n_库房id   药品收发记录.库房id%Type;
  v_收发ids  Varchar2(4000);
  d_Date     Date;
  v_医嘱ids  Varchar2(4000);
  v_发药窗口 药品收发记录.发药窗口%Type;

  Type t_Record Is Record(
    药房id   Number(18),
    发药窗口 Varchar2(10));

  Type t_发药窗口 Is Table Of t_Record;
  c_发药窗口 t_发药窗口 := t_发药窗口();
  n_Step     Number(18);
  n_Havedata Number(2);
  n_Count    Number(18);

Begin
  If 审核时间_In Is Null Then
    Select Sysdate Into d_Date From Dual;
  Else
    d_Date := 审核时间_In;
  End If;

  For r_Bill In c_Bill Loop

    --处理发药窗口
    If (r_Bill.收费类别 In ('5', '6', '7') Or r_Bill.收费类别 = '4' And r_Bill.跟踪在用 = 1) Then
      --同一张单据,满足同一药房同一窗口
      v_发药窗口 := Null;
      n_Havedata := 0;
      For n_Step In 1 .. c_发药窗口.Count Loop
        If c_发药窗口(n_Step).药房id = Nvl(r_Bill.执行部门id, 0) Then
          v_发药窗口 := c_发药窗口(n_Step).发药窗口;
          n_Havedata := 1;
          Exit;
        End If;
      End Loop;

      If v_发药窗口 Is Null Then
        --同一病人在普通号挂号有效挂号天数内且未发药的且上班的,以最近一次记账窗口为准
        n_Count := To_Number(Substr(Nvl(zl_GetSysParameter(21), '11') || '11', 1, 1));
        If n_Count = 0 Then
          n_Count := 1;
        End If;

        Begin
          Select 发药窗口
          Into v_发药窗口
          From (Select 登记时间, 发药窗口
                 From 门诊费用记录 A
                 Where 收费类别 In ('5', '6', '7', '4') And 病人id = r_Bill.病人id And 登记时间 Between Sysdate - n_Count And Sysdate And
                       记录性质 = 2 And 执行部门id = r_Bill.执行部门id And 发药窗口 Is Not Null And Exists
                  (Select 1
                        From 未发药品记录
                        Where a.No = NO And 单据 In (9, 25) And 库房id + 0 = r_Bill.执行部门id And 病人id + 0 = r_Bill.病人id) And
                       Exists
                  (Select 1
                        From 发药窗口
                        Where Nvl(上班否, 0) = 1 And 名称 = a.发药窗口 And Nvl(专家, 0) = 0 And 药房id = r_Bill.执行部门id)
                 Order By 登记时间 Desc)
          Where Rownum <= 1;
        Exception
          When Others Then
            v_发药窗口 := Null;
        End;
        If v_发药窗口 Is Null Then
          v_发药窗口 := Zl_Get发药窗口(r_Bill.执行部门id);
        End If;

      End If;
      If n_Havedata = 0 Then
        c_发药窗口.Extend;
        c_发药窗口(c_发药窗口.Count).药房id := r_Bill.执行部门id;
        c_发药窗口(c_发药窗口.Count).发药窗口 := v_发药窗口;
      End If;
    End If;

    Update 门诊费用记录
    Set 记录状态 = 1, 发药窗口 = v_发药窗口, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In, 登记时间 = d_Date --已产生的药品记录的时间不变

    Where ID = r_Bill.Id;

    --药品收发记录.填制日期
    Update 药品收发记录
    Set 填制日期 = Decode(Sign(Nvl(审核日期, d_Date) - d_Date), -1, 填制日期, d_Date)
    Where NO = No_In And 单据 In (9, 25) And 费用id = r_Bill.Id;

    --病人余额
    If Nvl(r_Bill.门诊标志, 0) <> 4 Then
      Update 病人余额
      Set 费用余额 = Nvl(费用余额, 0) + Nvl(r_Bill.实收金额, 0)
      Where 病人id = r_Bill.病人id And 性质 = 1 And 类型 = 1;

      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (r_Bill.病人id, 1, 1, r_Bill.实收金额, 0);
      End If;
    End If;

    --病人未结费用
    Update 病人未结费用
    Set 金额 = Nvl(金额, 0) + Nvl(r_Bill.实收金额, 0)
    Where 病人id = r_Bill.病人id And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(r_Bill.病人科室id, 0) And
          Nvl(开单部门id, 0) = Nvl(r_Bill.开单部门id, 0) And Nvl(执行部门id, 0) = Nvl(r_Bill.执行部门id, 0) And
          收入项目id + 0 = r_Bill.收入项目id And 来源途径 + 0 = r_Bill.门诊标志;

    If Sql%RowCount = 0 Then
      Insert Into 病人未结费用
        (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
      Values
        (r_Bill.病人id, Null, Null, r_Bill.病人科室id, r_Bill.开单部门id, r_Bill.执行部门id, r_Bill.收入项目id, r_Bill.门诊标志,
         Nvl(r_Bill.实收金额, 0));
    End If;

    If r_Bill.医嘱序号 Is Not Null Then
      v_医嘱ids := v_医嘱ids || ',' || r_Bill.医嘱序号;
    End If;

  End Loop;

  --处理医嘱发送计费状态
  If v_医嘱ids Is Not Null Then
    v_医嘱ids := Substr(v_医嘱ids, 2);
    Zl_医嘱发送_计费状态_Update(0, 2, 1, No_In, v_医嘱ids);
  End If;
  --更新发药窗口
  For n_Step In 1 .. c_发药窗口.Count Loop
    Update 药品收发记录
    Set 发药窗口 = c_发药窗口(n_Step).发药窗口
    Where 库房id = c_发药窗口(n_Step).药房id And 单据 In (9, 25) And NO = No_In And
          费用id + 0 In (Select ID
                       From 门诊费用记录
                       Where 记录性质 = 2 And 记录状态 = 1 And NO = No_In And 收费类别 In ('5', '6', '7'));

    Update 未发药品记录
    Set 发药窗口 = c_发药窗口(n_Step).发药窗口
    Where 库房id = c_发药窗口(n_Step).药房id And 单据 In (9, 25) And NO = No_In;
  End Loop;

  --库房中的药品已全部审核则标为已收费
  Update 未发药品记录
  Set 已收费 = 1, 填制日期 = d_Date
  Where NO = No_In And 单据 = 9 And Nvl(已收费, 0) = 0 And
        Nvl(库房id, 0) Not In
        (Select Distinct Nvl(执行部门id, 0)
         From 门诊费用记录
         Where 记录性质 = 2 And NO = No_In And 收费类别 In ('5', '6', '7') And 记录状态 = 0);

  Update 未发药品记录
  Set 已收费 = 1, 填制日期 = d_Date
  Where NO = No_In And 单据 = 25 And Nvl(已收费, 0) = 0 And
        Nvl(库房id, 0) Not In (Select Distinct Nvl(执行部门id, 0)
                             From 门诊费用记录
                             Where 记录性质 = 2 And NO = No_In And 收费类别 = '4' And 记录状态 = 0);

  --处理跟踪在用卫料自动发料
  If zl_GetSysParameter(92) = '1' Then
    For r_Stuff In c_Stuff Loop
      If n_发料号 Is Null Then
        n_发料号 := Nextno(20);
      End If;

      If r_Stuff.库房id <> Nvl(n_库房id, 0) Then
        If Nvl(n_库房id, 0) <> 0 And v_收发ids Is Not Null Then
          v_收发ids := Substr(v_收发ids, 2);
          Zl_药品收发记录_批量发料(v_收发ids, n_库房id, 操作员姓名_In, Sysdate, 1, 操作员姓名_In, n_发料号, 操作员姓名_In);
        End If;

        n_库房id  := r_Stuff.库房id;
        v_收发ids := Null;
      End If;

      v_收发ids := v_收发ids || '|' || r_Stuff.Id || ',0';
    End Loop;
    If Nvl(n_库房id, 0) <> 0 And v_收发ids Is Not Null Then
      v_收发ids := Substr(v_收发ids, 2);
      Zl_药品收发记录_批量发料(v_收发ids, n_库房id, 操作员姓名_In, Sysdate, 1, 操作员姓名_In, n_发料号, 操作员姓名_In);
    End If;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊记帐记录_Verify;
/

--122096:胡俊勇,2018-02-11,输液配药医嘱超期发送收回
--119437:胡俊勇,2018-01-11,临床相关消息修改
--119643:李南春,2018-01-08,消息发送内容调整
Create Or Replace Procedure Zl_病人费用销帐_Insert
(
  Id_In         In 病人费用销帐.费用id%Type,
  收费细目id_In In 病人费用销帐.收费细目id%Type,
  申请部门id_In In 病人费用销帐.申请部门id%Type,
  数量_In       In 病人费用销帐.数量%Type,
  申请人_In     In 病人费用销帐.申请人%Type,
  申请时间_In   In 病人费用销帐.申请时间%Type,
  申请类别_In   In 病人费用销帐.申请类别%Type, --对药品和卫材有效:0-未发药(料);1-已发药(料);其他为0
  删除标志_In   In Integer := 0, --删除病人费用销帐时的条件:1-删除时不管申请类别,0-删除时,根据申请类别来进行删除(因为可能出现在申请销帐时,存在已执行和未执行两种状态)
  配药id_In     In Integer := 0,
  销帐原因_In   In 病人费用销帐.销帐原因%Type := Null,
  配液更新_In   In Number := 1   --是否 输液配药记录 状态字段。1-要更新，0-不更新
) As
  n_审核部门id   病人费用销帐.审核部门id%Type;
  n_申请类别     病人费用销帐.申请类别%Type;
  n_开单科室病区 病人费用销帐.审核部门id%Type;
  n_执行科室病区 病人费用销帐.审核部门id%Type;
  n_跟踪在用     材料特性.跟踪在用%Type;
  n_执行状态     住院费用记录.执行状态%Type;
  v_收费类别     住院费用记录.收费类别%Type;
  n_实际数量     药品收发记录.实际数量%Type;
  n_医嘱id       住院费用记录.Id%Type;
  n_主页id       住院费用记录.Id%Type;
  v_No           住院费用记录.No%Type;
  n_病人id       住院费用记录.病人id%Type;
  n_病人科室id   住院费用记录.病人科室id%Type;
  n_Icu科室id    住院费用记录.病人科室id%Type;
  n_已申请数量   药品收发记录.实际数量%Type;
  n_序号         住院费用记录.序号%Type;

  n_Temp    Number;
  n_Icu     Number;
  n_Cnt     Number;
  v_Err_Msg Varchar2(500);
  Err_Item Exception;
  n_审核标志       病案主页.审核标志%Type;
  n_住院状态       病案主页.状态%Type;
  n_病人审核方式   Number(2);
  n_未入科禁止记账 Number(2);

Begin
  Begin
    Select Count(1)
    Into n_Cnt
    From 住院费用记录 A, 住院费用记录 B
    Where a.No = b.No And Mod(a.记录性质, 10) = Mod(b.记录性质, 10) And Nvl(a.价格父号, a.序号) = Nvl(b.价格父号, b.序号) And b.Id = Id_In
    Group By a.No, Mod(a.记录性质, 10), Nvl(a.价格父号, a.序号)
    Having Nvl(Sum(a.结帐金额), 0) <> 0;
  Exception
    When Others Then
      n_Cnt := 0;
  End;
  If n_Cnt > 0 Then
    v_Err_Msg := '申请销帐的记录已被他人结帐';
    Raise Err_Item;
  End If;

  Select a.收费类别, a.No, Nvl(b.跟踪在用, 0), Decode(Nvl(申请类别_In, 0), 0, a.病人病区id, a.执行部门id), 医嘱序号, 病人id, Nvl(主页id, 0), 序号
  Into v_收费类别, v_No, n_跟踪在用, n_审核部门id, n_医嘱id, n_病人id, n_主页id, n_序号
  From 住院费用记录 A, 材料特性 B
  Where a.收费细目id = b.材料id(+) And a.Id = Id_In;

  If Nvl(n_主页id, 0) <> 0 Then
  
    n_病人审核方式   := Nvl(zl_GetSysParameter(185), 0);
    n_未入科禁止记账 := Nvl(zl_GetSysParameter(215), 0);
    If n_病人审核方式 = 1 Or n_未入科禁止记账 = 1 Then
      Begin
        Select 审核标志, 状态
        Into n_审核标志, n_住院状态
        From 病案主页
        Where 病人id = Nvl(n_病人id, 0) And 主页id = Nvl(n_主页id, 0);
      Exception
        When Others Then
          n_审核标志 := 0;
          n_住院状态 := 0;
      End;
      If n_未入科禁止记账 = 1 And n_住院状态 = 1 Then
        v_Err_Msg := '病人未入科,禁止对病人相关费用的操作!';
        Raise Err_Item;
      End If;
    
      If n_病人审核方式 = 1 Then
        If Nvl(n_审核标志, 0) = 1 Then
          v_Err_Msg := '该病人目前正在审核费用,不能进行费用相关调整!';
          Raise Err_Item;
        End If;
        If Nvl(n_审核标志, 0) = 2 Then
          v_Err_Msg := '该病人目前已经完成了费用审核,不能进行费用相关调整!';
          Raise Err_Item;
        End If;
      End If;
    End If;
  
  End If;

  Select 出院科室id
  Into n_病人科室id
  From 病人信息 A, 病案主页 B
  Where a.病人id = b.病人id And a.主页id = b.主页id And a.病人id = n_病人id;

  Select Decode(Count(*), 0, 0, 1) Into n_Icu From 部门性质说明 B Where b.部门id = n_病人科室id And b.工作性质 = 'ICU';
  If n_Icu = 1 Then
    --检查是否是当前操作员属性于ICU
    Select Decode(Count(Distinct a.用户名), 0, 0, 1)
    Into n_Icu
    From 上机人员表 A, 部门性质说明 B, 部门人员 C
    Where a.用户名 = User And a.人员id = c.人员id And c.部门id = b.部门id And b.工作性质 = 'ICU';
  End If;

  If n_Icu = 1 Then
    n_Icu科室id := n_病人科室id;
    If Nvl(申请类别_In, 0) = 0 Then
      n_审核部门id := n_病人科室id;
    End If;
  End If;

  If Instr(',5,6,7', ',' || v_收费类别) > 0 Or v_收费类别 = '4' And Nvl(n_跟踪在用, 0) = 1 Then
    n_申请类别 := 申请类别_In;
  Else
    n_申请类别 := 0;
  End If;

  --取消以前申请的重新生成(按批次申请时，不能取消，因为费用id相同，每个批次可分别申请)
  If 配药id_In = 0 Then
    If Nvl(删除标志_In, 0) = 1 Then
      Delete 病人费用销帐 Where 费用id = Id_In And 状态 = 0;
    Else
      Delete 病人费用销帐 Where 费用id = Id_In And 申请类别 = n_申请类别 And 状态 = 0;
    End If;
  End If;
  If 数量_In <> 0 Then
    --审核科室
    --1.药品费用或跟踪在用的卫材:
    --    a. 如果未执行,则按病人病区作为审核部门;
    --    b. 如果已执行,则按执行部门ID作为审核部门
    --2.医技科室开单的费用(即开单科室<>病人科室)，销帐审核科室为开单科室,
    --  如果开单科室是属于病区的临床科室,则销帐科室为所属病区(即护士记病人在其它科室发生的费用)
    --  (如果执行科室x属于a、b两病区，则a、b两病区都可以作为销帐确认科室,取第一个，如果a病区同时是病人病区，则只有a病区能确认)。
    --3.病区产生的费用,没有经过划价审核的,销帐审核科室为病人病区(如果已经被执行，则为执行部门,否则为病人病区)
    --  经过划价审核的,销帐审核科室为执行科室。
    --  如果执行科室是属于病区的临床科室，则销帐审核科室为所属病区
    --  (如果执行科室x属于a、b两病区，则a、b两病区都可以作为销帐确认科室,取第一个，如果a病区同时是病人病区，则只有a病区能确认)。
    --4.如果当前操作员是属于ICU,并且病人当前科室也为ICU以及未执行的项目,由ICU科室来来进行审核.
  
    If Nvl(n_跟踪在用, 0) = 1 Then
      If Nvl(申请类别_In, 0) = 0 Then
        --要检查未执行的数量必须大于等于申请数量,才会通过
        Select Sum(Nvl(付数, 0) * Nvl(实际数量, 0))
        Into n_实际数量
        From 药品收发记录
        Where 审核日期 Is Null And 费用id = Id_In And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0;
      
        If Nvl(n_实际数量, 0) < Nvl(数量_In, 0) Then
          Select '在单据号<<' || v_No || '>>中卫材料为:' || Chr(13) || 编码 || '-' || 名称 || Chr(13) || '的申请数量(' ||
                  LTrim(To_Char(数量_In, '9999999990.99')) || ')大于了待发料数量(' ||
                  LTrim(To_Char(Nvl(n_实际数量, 0), '9999999990.99')) || '),不能进行申请销帐!'
          Into v_Err_Msg
          From 收费项目目录
          Where ID = 收费细目id_In;
          Raise Err_Item;
        End If;
      End If;
    Else
      --a.执行科室或其所属病区:：0:未执行;1:完全执行;2:部份执行
      Select Decode(b.病区id, Null, a.执行部门id, Nvl(c.病区id, b.病区id)), Decode(a.执行状态, 1, 1, 2, 1, 0)
      Into n_执行科室病区, n_执行状态
      From 住院费用记录 A, 病区科室对应 B, 病区科室对应 C
      Where a.Id = Id_In And a.执行部门id = b.科室id(+) And a.执行部门id = c.科室id(+) And a.病人病区id = c.病区id(+) And Rownum < 2;
    
      --b.开单科室或其所属病区
      Select Decode(b.病区id, Null, a.开单部门id, Nvl(c.病区id, b.病区id))
      Into n_开单科室病区
      From 住院费用记录 A, 病区科室对应 B, 病区科室对应 C
      Where a.Id = Id_In And a.开单部门id = b.科室id(+) And a.开单部门id = c.科室id(+) And a.病人病区id = c.病区id(+) And Rownum < 2;
    
      For v_费用 In (Select 收费类别, Nvl(执行状态, 0) As 执行状态, 病人病区id, 执行部门id, 开单部门id, 病人科室id, 划价人, 操作员姓名
                   From 住院费用记录
                   Where ID = Id_In) Loop
        If Instr('567', v_费用.收费类别, 1) > 0 Then
          n_Temp       := Case
                            When 申请类别_In Is Null Then
                             Nvl(v_费用.执行状态, 0)
                            Else
                             申请类别_In
                          End;
          n_审核部门id := Case
                        When n_Temp = 0 Then
                         v_费用.病人病区id
                        Else
                         v_费用.执行部门id
                      End;
          If n_Temp = 0 And n_Icu = 1 Then
            --ICU为ICU科室
            n_审核部门id := n_Icu科室id;
          End If;
        Else
          If v_费用.开单部门id = v_费用.病人科室id Then
            --临床产生的费用
            If Nvl(v_费用.划价人, '-') = v_费用.操作员姓名 Or v_费用.划价人 Is Null Then
              --划价审核
              n_审核部门id := Case
                            When n_执行状态 = 1 Then
                             v_费用.执行部门id
                            Else
                             v_费用.病人病区id
                          End;
            Else
              n_审核部门id := n_执行科室病区;
            End If;
          Else
            n_审核部门id := n_执行科室病区;
          End If;
          If n_执行状态 = 0 And n_Icu = 1 Then
            --ICU为ICU科室
            n_审核部门id := n_Icu科室id;
          End If;
        End If;
      End Loop;
    
      If Instr(',5,6,7', ',' || v_收费类别) > 0 And Nvl(申请类别_In, Nvl(n_执行状态, 0)) = 0 Then
        --需要检查未执行的数量必须大于等于申请数量,才会通过
        Select Sum(Nvl(付数, 0) * Nvl(实际数量, 0))
        Into n_实际数量
        From 药品收发记录
        Where 审核日期 Is Null And 费用id = Id_In And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0;
        If Nvl(n_实际数量, 0) < Nvl(数量_In, 0) Then
          Select '在单据号<<' || v_No || '>>中药品为:' || Chr(13) || 编码 || '-' || 名称 || Chr(13) || '的申请数量(' ||
                  LTrim(To_Char(数量_In, '9999999990.99')) || ')不能大于待发药数量(' ||
                  LTrim(To_Char(Nvl(n_实际数量, 0), '9999999990.99')) || '),不能进行申请销帐!'
          Into v_Err_Msg
          From 收费项目目录
          Where ID = 收费细目id_In;
          Raise Err_Item;
        End If;
      End If;
    End If;
    --解决并发问题:当前申请数量+已经申请数量不能大于某笔申请数量
    Select Sum(Nvl(数量, 0)) Into n_已申请数量 From 病人费用销帐 Where 费用id = Id_In And Nvl(状态, 0) <> 2;
    Select Sum(Nvl(付数, 1) * Nvl(数次, 0))
    Into n_实际数量
    From 住院费用记录
    Where NO = v_No And 序号 = n_序号 And Nvl(价格父号, 0) = 0 And 记录状态 In (0, 1, 3) And
          记录性质 In (Select 记录性质 From 住院费用记录 Where ID = Id_In);
    If Nvl(n_实际数量, 0) < Nvl(n_已申请数量, 0) + Nvl(数量_In, 0) Then
      Select '在单据号<<' || v_No || '>>收费项目:' || Chr(13) || 编码 || '-' || 名称 || Chr(13) || '的申请数量(' ||
              LTrim(To_Char(Nvl(n_已申请数量, 0) + Nvl(数量_In, 0), '9999999990.99')) || ')不能大于记帐数量(' ||
              LTrim(To_Char(Nvl(n_实际数量, 0), '9999999990.99')) || '),不能进行申请销帐!'
      Into v_Err_Msg
      From 收费项目目录
      Where ID = 收费细目id_In;
      Raise Err_Item;
    End If;
  
    If n_医嘱id <> 0 And 配药id_In <> 0 Then
      --如果是输液配药中心的，则更新相关表字段
      If Nvl(配液更新_In, 0) = 1 Then
        Select Count(1)
        Into n_Temp
        From 输液配药状态
        Where 配药id = 配药id_In And 操作类型 = 9 And 操作时间 = 申请时间_In;
        If n_Temp = 0 Then
          Insert Into 输液配药状态
            (配药id, 操作类型, 操作人员, 操作时间, 操作说明)
          Values
            (配药id_In, 9, 申请人_In, 申请时间_In, 销帐原因_In);
        End If;
        Update 输液配药记录
        Set 操作人员 = 申请人_In, 操作时间 = 申请时间_In, 操作状态 = 9
        Where ID = 配药id_In
        Returning 部门id Into n_审核部门id;
      Else
        Select 部门id Into n_审核部门id From 输液配药记录 Where ID = 配药id_In;
      End If;
    End If;
  
    Insert Into 病人费用销帐
      (费用id, 申请类别, 收费细目id, 审核部门id, 申请部门id, 数量, 申请人, 申请时间, 状态, 销帐原因)
    Values
      (Id_In, n_申请类别, 收费细目id_In, n_审核部门id, 申请部门id_In, 数量_In, 申请人_In, 申请时间_In, 0, 销帐原因_In);
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人费用销帐_Insert;
/

--119643:李南春,2018-01-08,消息发送内容调整
CREATE OR REPLACE PROCEDURE ZL_保险支付项目_Delete(
  收费细目ID_IN IN 保险支付项目.收费细目ID%TYPE, 
  险类_IN          IN 保险支付项目.险类%TYPE, 
	类别_IN			IN NUMBER := 0 
) 
IS 
 v_项目编码 收费项目目录.编码%TYPE;
 v_项目名称 收费项目目录.名称%TYPE;
 v_医保编码 保险支付项目.项目编码%TYPE;
 v_医保名称 保险支付项目.项目名称%TYPE;
BEGIN 
    --进行删除
  Select Max(A.编码), Max(A.名称), Max(B.项目编码), Max(B.项目名称) Into v_项目编码, v_项目名称, v_医保编码, v_医保名称
  From 收费项目目录 A,保险支付项目 B where A.ID = b.收费细目id And 收费细目ID=收费细目ID_IN AND 险类=险类_IN; 
   
	DELETE FROM 医保对照明细 
	WHERE 收费细目ID=收费细目ID_IN AND 险类=险类_IN; 
 
	IF 类别_IN =0 THEN 
		DELETE FROM 保险支付项目 
		WHERE 收费细目ID=收费细目ID_IN AND 险类=险类_IN; 
	END IF ; 

  b_Message.ZLHIS_DICT_049(险类_In, 收费细目id_In, v_项目编码, v_项目名称, v_医保编码, v_医保名称);
EXCEPTION 
    WHEN OTHERS THEN 
        Zl_ErrorCenter (SQLCODE, SQLERRM); 
END ZL_保险支付项目_Delete;
/

--113206:胡俊勇,2018-01-08,区卫妇幼专版工作站接口
CREATE OR REPLACE Procedure Zl_Third_Advicesave
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:病人生成医嘱(检查,检验,药品，手术，卫材，治疗，其它特殊类)，一个病人调用一次
  --日期格式统一固定为：2017-05-25 10:22:31
  --入参:Xml_In:
  --  <IN>
  --   <GHDH>R0000001</GHDH> 挂号单号
  --   <JZID></JZID>就诊ID，挂号ID
  --   <BRID></BRID>病人ID  
  --   <BRKSID>21</BRKSID>  病人科室ID
  --   <CZYXM>张永康</CZYXM> 操作员姓名
  --   <ZD></ZD>站点  
  --   <YZNRLIST>  医嘱列表，可以含多个结点
  --   <YZNR> 医嘱内容  
  --    <YZXH></YZXH> 医嘱序号，即传入这批医嘱中可做为当前这行医嘱唯一标识，数字类型
  --    <JJBZ>2</JJBZ>   紧急标志
  --    <KSZXSJ>2017-05-25 10:00:00</KSZXSJ> 开始执行时间
  --    <KZKSID>23</KZKSID>开嘱科室ID
  --    <KZYS>张永康</KZYS> 开嘱医生
  --    <KZSJ>2017-05-25 10:00:00</KZSJ> 开嘱时间
  --    <YEXH></YEXH>婴儿序号，如果是病人医嘱，传0
  --    <ZLLB>D</ZLLB>  诊疗类别 D-检查，E-(采集试)检验，E-(给药途径)药品医嘱，4-卫材，E-治疗，Z-特殊
  --    <CZLX></CZLX>   操作类型 ，当为药品和检验时需要传入 2/6
  --    <ZLXMID>123</ZLXMID>  诊疗项目ID  检查项目ID,检验采集项目ID,药品医嘱约药途径项目ID，其它类项目ID
  --    <ZXKSID>123</ZXKSID>  执行科室ID  检查，     采集执行科室，  给药执行科室             其它类执行科室ID

  ------药品，卫材，治疗，特殊
  --    <SFXMID></SFXMID>收费细目ID,如果是卫材类，需传入，即  收费项目目录.ID(仅限卫材使用)
  --    <PLBM></PLBM>频率：诊疗频率项目.编码 对于 非检查，检验，手术，可不传
  --    <ZXFA></ZXFA>执行方案,可以传无 ,指定频率才传，如果每天二次
  --    <DL></DL>单量，可以传无
  --    <ZL></ZL>总量，可以传无

  ------药品医嘱 
  --    <DRUGLIST>
  --     <ROW>
  --      <YMID></YMID>药名ID,诊疗项目id
  --      <YPID></YPID>药品ID,规格，收费细目ID
  --      <YFID></YFID>药房ID,发药药房
  --      <DL></DL>单量
  --      <TS></TS>天数
  --      <ZL></ZL>总量
  --     </ROW>
  --    </DRUGLIST>

  ------检查相关的，非检验项目可以不传入
  --    <BWFFALL></BWFFALL>方法部位总述格式: 部位1(方法1),部位2(方法2,方法3),...  逗号为半角
  --                      如：胆囊和胆道(收缩功能检查),输卵管(超声造影),腹部的测试(膀胱余尿测定,常规)
  --    <BWLIST>        检查方法部位列表详情
  --     <BWFF>
  --     <BW>颅骨</BW>
  --     <FF>平扫</FF>
  --     </BWFF>
  --     <BWFF>
  --     ....
  --     </BWFF>
  --    </BWLIST>

  ------检验项目的采集相关内容，非检验项目可以不传入
  --    <CJBB>血清</CJBB>        采集标本
  --    <JYZXKSID>12</JYZXKSID>  检验执行科室ID
  --    <YBCJXM>            一并采集的检验项目
  --      <ROW>
  --       <ZLXMID></ZLXMID>诊疗项目ID 
  --       ....
  --      </ROW>
  --    </YBCJXM>

  ------手术项目
  --    <SSSJ></SSSJ>手术时间
  --    <SSQK></SSQK>手术情况，null-择期，1-急诊，2-限期
  --    <SSNR></SSNR>手术内容描术 例：01月17日14:51 在 基础麻醉 下行 视神经减压术 及 甲状腺活组织检查
  --                          格式： [日期:MM月dd日HH:mm] 在 [麻醉项目名称] 下行 [主手术项目名称] 及 [附加手术名称1,附加手术名称2...]

  --    <FJSFXM>            其它附加手术项目
  --      <ROW>
  --       <ZLXMID></ZLXMID>诊疗项目ID 
  --       ....
  --      </ROW>
  --    </FJSFXM>
  --    <MZXMID></MZXMID> 麻醉项目ID
  --    <MZZXKSID></MZZXKSID> 麻醉执行科室ID

  --    ....
  --    </YZNR>
  --   </YZNRLIST>

  --   <DIAGS>诊断信息
  --     <ROW>
  --        <ZDXH></ZDXH>诊断序号
  --        <BRID></BRID>病人ID
  --        <ZYID></ZYID>主页ID
  --        <JLLY></JLLY>记录来源，1-病历；2-入院登记；3-首页整理;4-病案，固定传3
  --        <BLID></BLID>病历ID，可以不传结点保留
  --        <ZDLX></ZDLX>诊断类型，3西诊断，11中医诊断
  --        <JBID></JBID>疾病ID，可以不传结点保留
  --        <ZDID></ZDID>诊断ID，可以不传结点保留
  --        <ZHID></ZHID>证候ID，可以不传结点保留
  --        <ZDMS></ZDMS>诊断描述，必填
  --        <CYQK></CYQK>出院情况，可以不传结点保留
  --        <SFWZ></SFWZ>是否未治 ，可以不传结点保留
  --        <SFYZ></SFYZ>是否疑诊 取值  0/1
  --        <JLRQ></JLRQ>记录日期 日期类型字符串
  --        <YZID></YZID>医嘱ID，可以不传结点保留
  --        <ZDCX></ZDCX>诊断次序，必填
  --        <BZ></BZ>备注 ，可以不传结点保留
  --        <RYBQ></RYBQ>入院病情，可以不传结点保留
  --        <FBSJ></FBSJ>发病时间 日期类型字符串
  --        <JLR></JLR>记录人，必填
  --        <ID></ID>ID， 不传结点保留，即诊断记录的真实ID值
  --        <FMID></FMID>附码ID，可以不传结点保留
  --     </ROW>
  --   </DIAGS>

  --   <ZDYZDY>诊断医嘱对应,以保存的对应关系只传医嘱ID,诊断ID,另外两个序号传空串，如果未保存的关系医嘱ID,诊断ID传空串
  --     <ROW>
  --      <YZXH></YZXH>医嘱序号
  --      <ZDXH></ZDXH>诊断序号
  --      <YZID></YZID>医嘱ID 真实的医嘱ID
  --      <ZDID></ZDID>诊断ID 直实的诊断ID
  --     </ROW>
  --   </ZDYZDY>
  --  </IN>

  --出参:Xml_Out，生成的医嘱ID串，错误信息
  --  <OUTPUT>
  --    <ITEM> 保存的医嘱主项目ID
  --     <ZLXMID></ZLXMID> 诊疗项目ID
  --     <ZYZID></ZYZID>   主医嘱ID
  --    </ITEM>
  --    <YZIDS>1234,41234,64645,...</YZIDS>医嘱ID串，逗号分割
  --    <ERROR>
  --      <MSG>错误信息</MSG>
  --    </ERROR>
  --  </OUTPUT>
  --------------------------------------------------------------------------------------------------
  Type r_医嘱记录 Is Record(
    ID           病人医嘱记录.Id%Type,
    相关id       病人医嘱记录.相关id%Type,
    序号         病人医嘱记录.序号%Type,
    病人来源     病人医嘱记录.病人来源%Type,
    病人id       病人医嘱记录.病人id%Type,
    主页id       病人医嘱记录.主页id%Type,
    婴儿         病人医嘱记录.婴儿%Type,
    医嘱状态     病人医嘱记录.医嘱状态%Type,
    医嘱期效     病人医嘱记录.医嘱期效%Type,
    诊疗类别     病人医嘱记录.诊疗类别%Type,
    诊疗项目id   病人医嘱记录.诊疗项目id%Type,
    收费细目id   病人医嘱记录.收费细目id%Type,
    天数         病人医嘱记录.天数%Type,
    单次用量     病人医嘱记录.单次用量%Type,
    总给予量     病人医嘱记录.总给予量%Type,
    医嘱内容     病人医嘱记录.医嘱内容%Type,
    医生嘱托     病人医嘱记录.医生嘱托%Type,
    标本部位     病人医嘱记录.标本部位%Type,
    执行频次     病人医嘱记录.执行频次%Type,
    频率次数     病人医嘱记录.频率次数%Type,
    频率间隔     病人医嘱记录.频率间隔%Type,
    间隔单位     病人医嘱记录.间隔单位%Type,
    执行时间方案 病人医嘱记录.执行时间方案%Type,
    计价特性     病人医嘱记录.计价特性%Type,
    执行科室id   病人医嘱记录.执行科室id%Type,
    执行性质     病人医嘱记录.执行性质%Type,
    紧急标志     病人医嘱记录.紧急标志%Type,
    开始执行时间 病人医嘱记录.开始执行时间%Type,
    执行终止时间 病人医嘱记录.执行终止时间%Type,
    病人科室id   病人医嘱记录.病人科室id%Type,
    开嘱科室id   病人医嘱记录.开嘱科室id%Type,
    开嘱医生     病人医嘱记录.开嘱医生%Type,
    开嘱时间     病人医嘱记录.开嘱时间%Type,
    挂号单       病人医嘱记录.挂号单%Type := Null,
    前提id       病人医嘱记录.前提id%Type := Null,
    检查方法     病人医嘱记录.检查方法%Type := Null,
    执行标记     病人医嘱记录.执行标记%Type := Null,
    可否分零     病人医嘱记录.可否分零%Type := Null,
    摘要         病人医嘱记录.摘要%Type := Null,
    操作员姓名   病人医嘱状态.操作人员%Type := Null,
    零费记帐     病人医嘱记录.零费记帐%Type := Null,
    用药目的     病人医嘱记录.用药目的%Type := Null,
    用药理由     病人医嘱记录.用药理由%Type := Null,
    审核状态     病人医嘱记录.审核状态%Type := Null,
    申请序号     病人医嘱记录.申请序号%Type := Null,
    超量说明     病人医嘱记录.超量说明%Type := Null,
    首次用量     病人医嘱记录.首次用量%Type := Null,
    配方id       病人医嘱记录.配方id%Type := Null,
    手术情况     病人医嘱记录.手术情况%Type := Null,
    组合项目id   病人医嘱记录.组合项目id%Type := Null,
    皮试结果     病人医嘱记录.皮试结果%Type := Null);

  Type t_医嘱记录 Is Table Of r_医嘱记录;
  Rs_Sql t_医嘱记录 := t_医嘱记录();
  Rt     r_医嘱记录;

  Type r_诊断记录 Is Record(
    病人id   病人诊断记录.病人id%Type,
    主页id   病人诊断记录.主页id%Type,
    记录来源 病人诊断记录.记录来源%Type,
    病历id   病人诊断记录.病历id%Type,
    诊断类型 病人诊断记录.诊断类型%Type,
    疾病id   病人诊断记录.疾病id%Type,
    诊断id   病人诊断记录.诊断id%Type,
    证候id   病人诊断记录.证候id%Type,
    诊断描述 病人诊断记录.诊断描述%Type,
    出院情况 病人诊断记录.出院情况%Type,
    是否未治 病人诊断记录.是否未治%Type,
    是否疑诊 病人诊断记录.是否疑诊%Type,
    记录日期 病人诊断记录.记录日期%Type,
    医嘱id   Varchar2(4000),
    诊断次序 病人诊断记录.诊断次序%Type,
    备注     病人诊断记录.备注%Type,
    入院病情 病人诊断记录.入院病情%Type,
    发病时间 病人诊断记录.发病时间%Type,
    记录人   病人诊断记录.记录人%Type,
    ID       病人诊断记录.Id%Type,
    附码id   病人诊断记录.疾病id%Type);

  Type t_诊断记录 Is Table Of r_诊断记录;
  Rs_Sql诊断 t_诊断记录 := t_诊断记录();

  Type r_诊断医嘱 Is Record(
    诊断序号 病人诊断记录.病人id%Type,
    医嘱序号 病人诊断记录.病人id%Type,
    诊断id   病人诊断记录.病人id%Type,
    医嘱id   病人诊断记录.病人id%Type);

  Type t_诊断医嘱 Is Table Of r_诊断医嘱;
  Rs_Sql诊断医嘱 t_诊断医嘱 := t_诊断医嘱();

  Cursor c_频率(P编码 诊疗频率项目.编码%Type) Is
    Select 编码, 名称, 简码, 英文名称, 频率次数, 频率间隔, 间隔单位, 适用范围 From 诊疗频率项目 Where 编码 = P编码;
  r_频率 c_频率%RowType;

  Cursor c_项目(Pid 诊疗项目目录.Id%Type) Is
    Select 计算规则, 站点, 类别, 分类id, ID, 编码, 名称, 标本部位, 计算单位, 计算方式, 执行频率, 适用性别, 单独应用, 组合项目, 操作类型, 执行安排, 执行科室, 服务对象, 计价性质,
           参考目录id, 人员id, 建档时间, 撤档时间, 录入限量, 试管编码, 执行分类, 执行标记
    From 诊疗项目目录
    Where ID = Pid;

  r_项目 c_项目%RowType;
  r_给药 c_项目%RowType;
  r_药品 c_项目%RowType;

  d_开始执行时间 病人医嘱记录.开始执行时间%Type;
  n_病人科室id   病人医嘱记录.病人科室id%Type;
  v_操作员       人员表.姓名%Type;
  d_开嘱时间     病人医嘱记录.开嘱时间%Type;
  v_挂号单       病人医嘱记录.挂号单%Type;

  v_医嘱内容     病人医嘱记录.医嘱内容%Type;
  v_Tmp          Varchar2(32767);
  v_项目名称     诊疗项目目录.名称%Type;
  n_项目计价特性 诊疗项目目录.计价性质%Type;
  n_项目执行性质 诊疗项目目录.执行科室%Type;
  v_试管编码     诊疗项目目录.试管编码%Type;
  n_医嘱id       病人医嘱记录.Id%Type;
  n_相关id       病人医嘱记录.Id%Type;
  n_序号         病人医嘱记录.序号%Type;
  n_病人id       病人医嘱记录.病人id%Type;
  v_医嘱ids      Varchar2(32767);
  J              Number;
  n_Tmp          Number;
  n_诊断id       病人医嘱记录.Id%Type;
  n_主医嘱id     病人医嘱记录.Id%Type;
  n_药名id       病人医嘱记录.Id%Type;
  n_药品id       病人医嘱记录.Id%Type;
  n_药房id       部门表.Id%Type;
  n_单量         病人医嘱记录.单次用量%Type;
  n_天数         病人医嘱记录.天数%Type;
  n_总量         病人医嘱记录.总给予量%Type;
  n_执行性质     病人医嘱记录.执行性质%Type;
  v_频率编码     诊疗频率项目.编码%Type;
  v_执行方案     Varchar2(40);
  n_收费细目id   Number(18);

  Type r_病人医嘱附件记录 Is Record(
    项目   病人医嘱附件.项目%Type,
    必填   病人医嘱附件.必填%Type,
    排列   病人医嘱附件.排列%Type,
    要素id 病人医嘱附件.要素id%Type,
    医嘱id 病人医嘱附件.医嘱id%Type,
    内容   病人医嘱附件.内容%Type);

  Type t_r_病人医嘱附件记录 Is Table Of r_病人医嘱附件记录;
  Rs_Sql病人医嘱附件记录 t_r_病人医嘱附件记录 := t_r_病人医嘱附件记录();
  Rf                     r_病人医嘱附件记录;

  n_是否有附加项 Number(18);

  v_Err_Msg Varchar(2000);
  Err_Item Exception;
  v_Erroritem    Varchar(2000);
  v_Erroritemlis Varchar(2000);

  d_Stoptime Date;
  v_Itemname Varchar(200);
  v_编码     Varchar(200);
  v_项目类别 Varchar(200);
  n_组合id   Number(18);
  n_Cnt      Number;
Begin 
  --取出诊断医嘱对应关系
  For R In (Select Extractvalue(Value(A), 'ROW/YZXH') As 医嘱序号, Extractvalue(Value(A), 'ROW/ZDXH') As 诊断序号,
                   Extractvalue(Value(A), 'ROW/YZID') As 医嘱id, Extractvalue(Value(A), 'ROW/ZDID') As 诊断id
            From Table(Xmlsequence(Extract(Xml_In, 'IN/ZDYZDY/ROW'))) A) Loop
    Rs_Sql诊断医嘱.Extend;
    Rs_Sql诊断医嘱(Rs_Sql诊断医嘱.Count).医嘱序号 := r.医嘱序号;
    Rs_Sql诊断医嘱(Rs_Sql诊断医嘱.Count).诊断序号 := r.诊断序号;
    Rs_Sql诊断医嘱(Rs_Sql诊断医嘱.Count).医嘱id := r.医嘱id;
    Rs_Sql诊断医嘱(Rs_Sql诊断医嘱.Count).诊断id := r.诊断id;
  End Loop;

  Select Extractvalue(Value(A), 'IN/GHDH') As 挂号单, Extractvalue(Value(A), 'IN/BRID') As 病人id,
         Extractvalue(Value(A), 'IN/BRKSID') As 病人科室id, Extractvalue(Value(A), 'IN/CZYXM') As 操作员
  Into v_挂号单, n_病人id, n_病人科室id, v_操作员
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  Select Nvl(Max(a.序号), 0) Into n_序号 From 病人医嘱记录 A Where a.挂号单 = v_挂号单;

  --产生医嘱 
  For X In (Select v_操作员 As 操作员, 0 As 婴儿, b.医嘱序号, b.诊疗项目id, b.诊疗类别, b.操作类型, b.执行科室id, b.紧急标志, b.开始执行时间, b.开嘱时间, b.开嘱科室id,
                   b.开嘱医生, b.收费细目id, b.频率编码, b.执行方案, b.单量, b.总量, b.西药品明细, b.检查部位方法总述, b.检查部位方法明细, b.采集标本, b.检验执行科室id,
                   b.检验项目明细, b.手术时间, b.手术情况, b.手术内容, b.手术附加项目明细, b.麻醉项目id, b.麻醉执行科室id, b.申请附项名称, b.申请附项内容
            From Xmltable('$a/IN/YZNRLIST/YZNR' Passing Xml_In As "a" Columns 医嘱序号 Number(18) Path 'YZXH',
                           诊疗项目id Number(18) Path 'ZLXMID', 诊疗类别 Varchar2(1) Path 'ZLLB', 操作类型 Varchar2(20) Path 'CZLX',
                           执行科室id Number(18) Path 'ZXKSID', 紧急标志 Number(1) Path 'JJBZ', 开始执行时间 Varchar2(30) Path 'KSZXSJ',
                           开嘱时间 Varchar2(30) Path 'KZSJ', 开嘱科室id Number(18) Path 'KZKSID', 开嘱医生 Varchar2(41) Path 'KZYS',
                           收费细目id Number(18) Path 'SFXMID', 频率编码 Varchar2(3) Path 'PLBM', 执行方案 Varchar2(100) Path 'ZXFA',
                           单量 Number(16, 5) Path 'DL', 总量 Number(16, 5) Path 'ZL', 西药品明细 Xmltype Path 'DRUGLIST',
                           检查部位方法总述 Varchar2(4000) Path 'BWFFALL', 检查部位方法明细 Xmltype Path 'BWLIST',
                           采集标本 Varchar2(60) Path 'CJBB', 检验执行科室id Number(18) Path 'JYZXKSID', 检验项目明细 Xmltype Path 'YBCJXM',
                           手术时间 Varchar2(30) Path 'SSSJ', 手术情况 Number(2) Path 'SSQK', 手术内容 Varchar2(1000) Path 'SSNR',
                           手术附加项目明细 Xmltype Path 'FJSFXM', 麻醉项目id Number(18) Path 'MZXMID', 麻醉执行科室id Number Path 'MZZXKSID',
                           申请附项名称 Varchar2(1000) Path 'SQFXMC', 申请附项内容 Varchar2(4000) Path 'SQFXNR') B) Loop
  
    d_开始执行时间 := To_Date(x.开始执行时间, 'YYYY-MM-DD HH24:MI:SS');
    d_开嘱时间     := To_Date(x.开嘱时间, 'YYYY-MM-DD HH24:MI:SS');
  
    If x.诊疗类别 = 'D' Then
      Select 名称, 计价性质, 执行科室
      Into v_项目名称, n_项目计价特性, n_项目执行性质
      From 诊疗项目目录
      Where ID = x.诊疗项目id;
    
      v_医嘱内容 := x.检查部位方法总述;
    
      Select 病人医嘱记录_Id.Nextval Into n_医嘱id From Dual;
      n_相关id := n_医嘱id;
      v_Tmp    := v_项目名称;
      If v_医嘱内容 Is Not Null Then
        v_Tmp := v_Tmp || ':' || v_医嘱内容;
      End If;
    
      n_序号 := n_序号 + 1;
      Select n_医嘱id, Null, n_序号, 1, n_病人id, Null, x.婴儿, 1, 1, x.诊疗类别, x.诊疗项目id, Null, Null, Null, 1, v_Tmp, Null, Null,
             '一次性', Null, Null, Null, Null, n_项目计价特性, x.执行科室id, n_项目执行性质, x.紧急标志, d_开始执行时间, Null, n_病人科室id, x.开嘱科室id,
             x.开嘱医生, d_开嘱时间, v_挂号单, Null, Null, 0, Null, Null, x.操作员
      Into Rt.Id, Rt.相关id, Rt.序号, Rt.病人来源, Rt.病人id, Rt.主页id, Rt.婴儿, Rt.医嘱状态, Rt.医嘱期效, Rt.诊疗类别, Rt.诊疗项目id, Rt.收费细目id,
           Rt.天数, Rt.单次用量, Rt.总给予量, Rt.医嘱内容, Rt.医生嘱托, Rt.标本部位, Rt.执行频次, Rt.频率次数, Rt.频率间隔, Rt.间隔单位, Rt.执行时间方案, Rt.计价特性,
           Rt.执行科室id, Rt.执行性质, Rt.紧急标志, Rt.开始执行时间, Rt.执行终止时间, Rt.病人科室id, Rt.开嘱科室id, Rt.开嘱医生, Rt.开嘱时间, Rt.挂号单, Rt.前提id,
           Rt.检查方法, Rt.执行标记, Rt.可否分零, Rt.摘要, Rt.操作员姓名
      From Dual;
      n_主医嘱id := n_医嘱id;
      Rs_Sql.Extend;
      Rs_Sql(Rs_Sql.Count) := Rt;
    
      If v_医嘱内容 Is Not Null Then
        --添加部位方法 
        For Y In (Select b.部位, b.方法
                  From Xmltable('$a/BWLIST/BWFF' Passing x.检查部位方法明细 As "a" Columns 部位 Varchar2(60) Path 'BW',
                                 方法 Varchar2(60) Path 'FF') B) Loop
        
          Select 病人医嘱记录_Id.Nextval Into n_医嘱id From Dual;
          n_序号 := n_序号 + 1;
        
          Select n_医嘱id, n_相关id, n_序号, 1, n_病人id, Null, x.婴儿, 1, 1, x.诊疗类别, x.诊疗项目id, Null, Null, Null, 1, v_项目名称, Null,
                 y.部位, '一次性', Null, Null, Null, Null, n_项目计价特性, x.执行科室id, n_项目执行性质, x.紧急标志, d_开始执行时间, Null, n_病人科室id,
                 x.开嘱科室id, x.开嘱医生, d_开嘱时间, v_挂号单, Null, y.方法, 0, Null, Null, x.操作员
          Into Rt.Id, Rt.相关id, Rt.序号, Rt.病人来源, Rt.病人id, Rt.主页id, Rt.婴儿, Rt.医嘱状态, Rt.医嘱期效, Rt.诊疗类别, Rt.诊疗项目id, Rt.收费细目id,
               Rt.天数, Rt.单次用量, Rt.总给予量, Rt.医嘱内容, Rt.医生嘱托, Rt.标本部位, Rt.执行频次, Rt.频率次数, Rt.频率间隔, Rt.间隔单位, Rt.执行时间方案,
               Rt.计价特性, Rt.执行科室id, Rt.执行性质, Rt.紧急标志, Rt.开始执行时间, Rt.执行终止时间, Rt.病人科室id, Rt.开嘱科室id, Rt.开嘱医生, Rt.开嘱时间,
               Rt.挂号单, Rt.前提id, Rt.检查方法, Rt.执行标记, Rt.可否分零, Rt.摘要, Rt.操作员姓名
          From Dual;
          Rs_Sql.Extend;
          Rs_Sql(Rs_Sql.Count) := Rt;
        
        End Loop;
        --==yqq 20171127===========================================
      End If;
    
      If x.申请附项名称 Is Not Null And x.申请附项内容 Is Not Null Then
        --判断是否配置了附加项
        Select Max(a.诊疗项目id)
        Into n_是否有附加项
        From 病历单据应用 A, 病历文件列表 B, 病历单据附项 C, 诊治所见项目 D
        Where a.诊疗项目id = Rt.诊疗项目id And a.应用场合 = 1 And a.病历文件id = b.Id And b.种类 = 7 And b.Id = c.文件id And
              c.要素id = d.Id(+) And 项目 = x.申请附项名称 And Rownum < 2;
        If n_是否有附加项 > 0 Then
          --添加申请附项（检查部位补充）
          Select c.项目, c.必填, c.排列, c.要素id
          Into Rf.项目, Rf.必填, Rf.排列, Rf.要素id
          From 病历单据应用 A, 病历文件列表 B, 病历单据附项 C, 诊治所见项目 D
          Where a.诊疗项目id = Rt.诊疗项目id And a.应用场合 = 1 And a.病历文件id = b.Id And b.种类 = 7 And b.Id = c.文件id And
                c.要素id = d.Id(+) And 项目 = x.申请附项名称 And Rownum < 2;
        
          Select x.申请附项内容, n_相关id Into Rf.内容, Rf.医嘱id From Dual;
        
          Rs_Sql病人医嘱附件记录.Extend;
          Rs_Sql病人医嘱附件记录(Rs_Sql病人医嘱附件记录.Count) := Rf;
        End If;
      End If;
      --==yqq 20171127===========================================
    Elsif x.诊疗类别 = 'E' And x.操作类型 = '6' Then
      n_Cnt      := 0;
      n_相关id   := Null;
      v_医嘱内容 := Null;
      --检验项目
      For Y In (Select b.诊疗项目id
                From Xmltable('$a/YBCJXM/ROW' Passing x.检验项目明细 As "a" Columns 诊疗项目id Number(18) Path 'ZLXMID') B) Loop
        Select 名称, 计价性质, 执行科室, 试管编码
        Into v_项目名称, n_项目计价特性, n_项目执行性质, v_试管编码
        From 诊疗项目目录
        Where ID = y.诊疗项目id;
      
        v_医嘱内容 := v_医嘱内容 || ',' || v_项目名称;
      
        Select 病人医嘱记录_Id.Nextval Into n_医嘱id From Dual;
        n_序号 := n_序号 + 1;
        Select n_医嘱id, n_相关id, n_序号, 1, n_病人id, Null, x.婴儿, 1, 1, 'C', y.诊疗项目id, Null, Null, Null, 1, v_项目名称, Null,
               x.采集标本, '一次性', Null, Null, Null, Null, n_项目计价特性, x.检验执行科室id, n_项目执行性质, x.紧急标志, d_开始执行时间, Null, n_病人科室id,
               x.开嘱科室id, x.开嘱医生, d_开嘱时间, v_挂号单, Null, Null, 0, Null, Null, x.操作员
        Into Rt.Id, Rt.相关id, Rt.序号, Rt.病人来源, Rt.病人id, Rt.主页id, Rt.婴儿, Rt.医嘱状态, Rt.医嘱期效, Rt.诊疗类别, Rt.诊疗项目id, Rt.收费细目id,
             Rt.天数, Rt.单次用量, Rt.总给予量, Rt.医嘱内容, Rt.医生嘱托, Rt.标本部位, Rt.执行频次, Rt.频率次数, Rt.频率间隔, Rt.间隔单位, Rt.执行时间方案, Rt.计价特性,
             Rt.执行科室id, Rt.执行性质, Rt.紧急标志, Rt.开始执行时间, Rt.执行终止时间, Rt.病人科室id, Rt.开嘱科室id, Rt.开嘱医生, Rt.开嘱时间, Rt.挂号单, Rt.前提id,
             Rt.检查方法, Rt.执行标记, Rt.可否分零, Rt.摘要, Rt.操作员姓名
        From Dual;
        Rs_Sql.Extend;
        Rs_Sql(Rs_Sql.Count) := Rt;
        n_Cnt := n_Cnt + 1;
      End Loop;
    
      Select 病人医嘱记录_Id.Nextval Into n_相关id From Dual;
      v_医嘱内容 := v_医嘱内容 || '(' || x.采集标本 || ')';
      v_医嘱内容 := Substr(v_医嘱内容, 2);
      Select 名称, 计价性质, 执行科室
      Into v_项目名称, n_项目计价特性, n_项目执行性质
      From 诊疗项目目录
      Where ID = x.诊疗项目id;
      n_序号 := n_序号 + 1;
      Select n_相关id, Null, n_序号, 1, n_病人id, Null, x.婴儿, 1, 1, 'E', x.诊疗项目id, Null, Null, Null, 1, v_医嘱内容, Null, x.采集标本,
             '一次性', Null, Null, Null, Null, n_项目计价特性, x.执行科室id, n_项目执行性质, x.紧急标志, d_开始执行时间, Null, n_病人科室id, x.开嘱科室id,
             x.开嘱医生, d_开嘱时间, v_挂号单, Null, Null, 0, Null, Null, x.操作员
      Into Rt.Id, Rt.相关id, Rt.序号, Rt.病人来源, Rt.病人id, Rt.主页id, Rt.婴儿, Rt.医嘱状态, Rt.医嘱期效, Rt.诊疗类别, Rt.诊疗项目id, Rt.收费细目id,
           Rt.天数, Rt.单次用量, Rt.总给予量, Rt.医嘱内容, Rt.医生嘱托, Rt.标本部位, Rt.执行频次, Rt.频率次数, Rt.频率间隔, Rt.间隔单位, Rt.执行时间方案, Rt.计价特性,
           Rt.执行科室id, Rt.执行性质, Rt.紧急标志, Rt.开始执行时间, Rt.执行终止时间, Rt.病人科室id, Rt.开嘱科室id, Rt.开嘱医生, Rt.开嘱时间, Rt.挂号单, Rt.前提id,
           Rt.检查方法, Rt.执行标记, Rt.可否分零, Rt.摘要, Rt.操作员姓名
      From Dual;
      n_主医嘱id := n_相关id;
      Rs_Sql.Extend;
      Rs_Sql(Rs_Sql.Count) := Rt;
      n_Cnt := n_Cnt + 1;
    
      --替换真实的相关ID
      For I In 1 .. n_Cnt - 1 Loop
        Rs_Sql(Rs_Sql.Count - I).相关id := n_相关id;
      End Loop;
    
    Elsif x.诊疗类别 = 'F' Then
      --手术医嘱
      Select 名称, 计价性质, 执行科室
      Into v_项目名称, n_项目计价特性, n_项目执行性质
      From 诊疗项目目录
      Where ID = x.诊疗项目id;
    
      v_医嘱内容  := x.手术内容;
      Rt.手术情况 := x.手术情况;
    
      Select 病人医嘱记录_Id.Nextval Into n_医嘱id From Dual;
      n_相关id := n_医嘱id;
    
      n_序号 := n_序号 + 1;
      Select n_医嘱id, Null, n_序号, 1, n_病人id, Null, x.婴儿, 1, 1, x.诊疗类别, x.诊疗项目id, Null, Null, Null, 1, v_医嘱内容, Null,
             x.手术时间, '一次性', Null, Null, Null, Null, n_项目计价特性, x.执行科室id, n_项目执行性质, x.紧急标志, d_开始执行时间, Null, n_病人科室id,
             x.开嘱科室id, x.开嘱医生, d_开嘱时间, v_挂号单, Null, Null, 0, Null, Null, x.操作员
      Into Rt.Id, Rt.相关id, Rt.序号, Rt.病人来源, Rt.病人id, Rt.主页id, Rt.婴儿, Rt.医嘱状态, Rt.医嘱期效, Rt.诊疗类别, Rt.诊疗项目id, Rt.收费细目id,
           Rt.天数, Rt.单次用量, Rt.总给予量, Rt.医嘱内容, Rt.医生嘱托, Rt.标本部位, Rt.执行频次, Rt.频率次数, Rt.频率间隔, Rt.间隔单位, Rt.执行时间方案, Rt.计价特性,
           Rt.执行科室id, Rt.执行性质, Rt.紧急标志, Rt.开始执行时间, Rt.执行终止时间, Rt.病人科室id, Rt.开嘱科室id, Rt.开嘱医生, Rt.开嘱时间, Rt.挂号单, Rt.前提id,
           Rt.检查方法, Rt.执行标记, Rt.可否分零, Rt.摘要, Rt.操作员姓名
      From Dual;
      n_主医嘱id := n_医嘱id;
      Rs_Sql.Extend;
      Rs_Sql(Rs_Sql.Count) := Rt;
    
      --附加手术 
      If x.手术附加项目明细 Is Not Null Then
        For Y In (Select b.诊疗项目id
                  From Xmltable('$a/FJSFXM/ROW' Passing x.手术附加项目明细 As "a" Columns 诊疗项目id Number(18) Path 'ZLXMID') B) Loop
          Select 病人医嘱记录_Id.Nextval Into n_医嘱id From Dual;
          n_序号 := n_序号 + 1;
          Select n_医嘱id, n_相关id, n_序号, ID, 名称, 计价性质, 执行科室
          Into Rt.Id, Rt.相关id, Rt.序号, Rt.诊疗项目id, Rt.医嘱内容, Rt.计价特性, Rt.执行性质
          From 诊疗项目目录
          Where ID = y.诊疗项目id;
        
          Rs_Sql.Extend;
          Rs_Sql(Rs_Sql.Count) := Rt;
        End Loop;
      End If;
      --麻醉 
      Rt.诊疗项目id := x.麻醉项目id;
      Rt.执行科室id := x.麻醉执行科室id;
    
      If Rt.诊疗项目id Is Not Null Then
        Select 病人医嘱记录_Id.Nextval Into n_医嘱id From Dual;
        n_序号 := n_序号 + 1;
        Select n_医嘱id, n_相关id, n_序号, 类别, 名称, 计价性质, 执行科室
        Into Rt.Id, Rt.相关id, Rt.序号, Rt.诊疗类别, Rt.医嘱内容, Rt.计价特性, Rt.执行性质
        From 诊疗项目目录
        Where ID = Rt.诊疗项目id;
        Rs_Sql.Extend;
        Rs_Sql(Rs_Sql.Count) := Rt;
      End If;
    
    Elsif x.诊疗类别 = 'E' And x.操作类型 = '2' Then
      --药品医嘱
      Open c_频率(x.频率编码); --诊疗频率项目
      Fetch c_频率
        Into r_频率;
      Close c_频率;
    
      Open c_项目(x.诊疗项目id);
      Fetch c_项目
        Into r_给药;
      Close c_项目;
    
      n_Cnt    := 0;
      n_相关id := Null;
      --药品医嘱 
      For Y In (Select b.药名id, b.药品id, b.药房id, b.单量, b.天数, b.总量
                From Xmltable('$a/DRUGLIST/ROW' Passing x.西药品明细 As "a" Columns 药名id Number(18) Path 'YMID',
                               药品id Number(18) Path 'YPID', 药房id Number(18) Path 'YFID', 单量 Number(16, 5) Path 'DL',
                               天数 Number(16, 5) Path 'TS', 总量 Number(16, 5) Path 'ZL') B) Loop
      
        n_药名id := y.药名id;
        n_药品id := y.药品id;
        n_药房id := y.药房id;
        n_单量   := y.单量;
        n_天数   := y.天数;
        n_总量   := y.总量;
      
        Open c_项目(n_药名id);
        Fetch c_项目
          Into r_药品;
        Close c_项目;
      
        n_执行性质 := 4;
        If Nvl(n_药房id, 0) = 0 Then
          n_执行性质 := 5;
        End If;
      
        --生成医嘱内容
        v_医嘱内容 := r_药品.名称;
        For Mc In (Select Nvl(b.名称, a.名称) As 名称, a.规格, a.产地, b.性质
                   From 收费项目目录 A, 收费项目别名 B
                   Where a.Id = b.收费细目id(+) And a.Id = n_药品id
                   Order By b.性质, b.码类) Loop
          If Mc.产地 Is Not Null Then
            v_医嘱内容 := v_医嘱内容 || '(' || Mc.产地 || ')';
          End If;
          If Mc.规格 Is Not Null Then
            v_医嘱内容 := v_医嘱内容 || ' ' || Mc.规格;
          End If;
          Exit;
        End Loop;
        n_序号 := n_序号 + 1;
        Select 病人医嘱记录_Id.Nextval Into n_医嘱id From Dual;
        Select n_医嘱id, n_相关id, n_序号, 1, n_病人id, Null, x.婴儿, 1, 1, r_药品.类别, n_药名id, n_药品id, n_天数, n_单量, n_总量, v_医嘱内容,
               Null, r_药品.名称, r_频率.名称, r_频率.频率次数, r_频率.频率间隔, r_频率.间隔单位, x.执行方案, Nvl(r_药品.计价性质, 0), n_药房id, n_执行性质,
               x.紧急标志, d_开始执行时间, Null, n_病人科室id, x.开嘱科室id, x.开嘱医生, d_开嘱时间, v_挂号单, Null, Null, 0, Null, Null, x.操作员
        Into Rt.Id, Rt.相关id, Rt.序号, Rt.病人来源, Rt.病人id, Rt.主页id, Rt.婴儿, Rt.医嘱状态, Rt.医嘱期效, Rt.诊疗类别, Rt.诊疗项目id, Rt.收费细目id,
             Rt.天数, Rt.单次用量, Rt.总给予量, Rt.医嘱内容, Rt.医生嘱托, Rt.标本部位, Rt.执行频次, Rt.频率次数, Rt.频率间隔, Rt.间隔单位, Rt.执行时间方案, Rt.计价特性,
             Rt.执行科室id, Rt.执行性质, Rt.紧急标志, Rt.开始执行时间, Rt.执行终止时间, Rt.病人科室id, Rt.开嘱科室id, Rt.开嘱医生, Rt.开嘱时间, Rt.挂号单, Rt.前提id,
             Rt.检查方法, Rt.执行标记, Rt.可否分零, Rt.摘要, Rt.操作员姓名
        From Dual;
        Rs_Sql.Extend;
        Rs_Sql(Rs_Sql.Count) := Rt;
        n_Cnt := n_Cnt + 1;
      End Loop;
      --给药途径医嘱
      n_序号     := n_序号 + 1;
      n_执行性质 := r_给药.执行科室;
      If Nvl(x.执行科室id, 0) = 0 Then
        n_执行性质 := 5;
      End If;
      Select 病人医嘱记录_Id.Nextval Into n_医嘱id From Dual;
      n_相关id := n_医嘱id;
      Select n_相关id, Null, n_序号, 1, n_病人id, Null, x.婴儿, 1, 1, 'E', r_给药.Id, Null, n_天数, Null, Null, r_给药.名称, Null, Null,
             r_频率.名称, r_频率.频率次数, r_频率.频率间隔, r_频率.间隔单位, x.执行方案, Nvl(r_给药.计价性质, 0), x.执行科室id, n_执行性质, x.紧急标志, d_开始执行时间,
             Null, n_病人科室id, x.开嘱科室id, x.开嘱医生, d_开嘱时间, v_挂号单, Null, Null, 0, Null, Null, x.操作员
      Into Rt.Id, Rt.相关id, Rt.序号, Rt.病人来源, Rt.病人id, Rt.主页id, Rt.婴儿, Rt.医嘱状态, Rt.医嘱期效, Rt.诊疗类别, Rt.诊疗项目id, Rt.收费细目id,
           Rt.天数, Rt.单次用量, Rt.总给予量, Rt.医嘱内容, Rt.医生嘱托, Rt.标本部位, Rt.执行频次, Rt.频率次数, Rt.频率间隔, Rt.间隔单位, Rt.执行时间方案, Rt.计价特性,
           Rt.执行科室id, Rt.执行性质, Rt.紧急标志, Rt.开始执行时间, Rt.执行终止时间, Rt.病人科室id, Rt.开嘱科室id, Rt.开嘱医生, Rt.开嘱时间, Rt.挂号单, Rt.前提id,
           Rt.检查方法, Rt.执行标记, Rt.可否分零, Rt.摘要, Rt.操作员姓名
      From Dual;
      n_主医嘱id := n_相关id;
      Rs_Sql.Extend;
      Rs_Sql(Rs_Sql.Count) := Rt;
      n_Cnt := n_Cnt + 1;
    
      --替换真实的相关ID
      For I In 1 .. n_Cnt - 1 Loop
        Rs_Sql(Rs_Sql.Count - I).相关id := n_相关id;
      End Loop;
    Elsif Instr(',4,E,Z,', x.诊疗类别) > 0 Then
      n_收费细目id := x.收费细目id;
      v_频率编码   := x.频率编码;
      v_执行方案   := x.执行方案;
      n_单量       := x.单量;
      n_总量       := x.总量;
    
      Open c_项目(x.诊疗项目id);
      Fetch c_项目
        Into r_项目;
      Close c_项目;
      Open c_频率(x.频率编码); --诊疗频率项目
      Fetch c_频率
        Into r_频率;
      Close c_频率;
    
      n_序号 := n_序号 + 1;
      Select 病人医嘱记录_Id.Nextval Into n_医嘱id From Dual;
    
      v_医嘱内容 := r_项目.名称;
      If x.诊疗类别 = '4' Then
        Select r_项目.名称 || '(' || 规格 || ')' Into v_医嘱内容 From 收费项目目录 Where ID = n_收费细目id;
      End If;
      Select n_医嘱id, Null, n_序号, 1, n_病人id, Null, x.婴儿, 1, 1, x.诊疗类别, x.诊疗项目id, n_收费细目id, Null, n_单量, n_总量, v_医嘱内容, Null,
             Null, r_频率.名称, r_频率.频率次数, r_频率.频率间隔, r_频率.间隔单位, x.执行方案, Nvl(r_项目.计价性质, 0), x.执行科室id, r_项目.执行科室, x.紧急标志,
             d_开始执行时间, Null, n_病人科室id, x.开嘱科室id, x.开嘱医生, d_开嘱时间, v_挂号单, Null, Null, Null, Null, Null, x.操作员
      Into Rt.Id, Rt.相关id, Rt.序号, Rt.病人来源, Rt.病人id, Rt.主页id, Rt.婴儿, Rt.医嘱状态, Rt.医嘱期效, Rt.诊疗类别, Rt.诊疗项目id, Rt.收费细目id,
           Rt.天数, Rt.单次用量, Rt.总给予量, Rt.医嘱内容, Rt.医生嘱托, Rt.标本部位, Rt.执行频次, Rt.频率次数, Rt.频率间隔, Rt.间隔单位, Rt.执行时间方案, Rt.计价特性,
           Rt.执行科室id, Rt.执行性质, Rt.紧急标志, Rt.开始执行时间, Rt.执行终止时间, Rt.病人科室id, Rt.开嘱科室id, Rt.开嘱医生, Rt.开嘱时间, Rt.挂号单, Rt.前提id,
           Rt.检查方法, Rt.执行标记, Rt.可否分零, Rt.摘要, Rt.操作员姓名
      From Dual;
      n_主医嘱id := n_医嘱id;
      Rs_Sql.Extend;
      Rs_Sql(Rs_Sql.Count) := Rt;
    End If;
  
    --替换真实的医嘱ID
    For J In 1 .. Rs_Sql诊断医嘱.Count Loop
      If Rs_Sql诊断医嘱(J).医嘱序号 = To_Number(x.医嘱序号) Then
        Rs_Sql诊断医嘱(J).医嘱id := n_主医嘱id;
      End If;
    End Loop;
  
  End Loop;

  --诊断相关处理
  For R In (Select Extractvalue(Value(A), 'ROW/ZDXH') As 诊断序号, Extractvalue(Value(A), 'ROW/BRID') As 病人id,
                   Extractvalue(Value(A), 'ROW/ZYID') As 主页id, Extractvalue(Value(A), 'ROW/JLLY') As 记录来源,
                   Extractvalue(Value(A), 'ROW/BLID') As 病历id, Extractvalue(Value(A), 'ROW/ZDLX') As 诊断类型,
                   Extractvalue(Value(A), 'ROW/JBID') As 疾病id, Extractvalue(Value(A), 'ROW/ZDID') As 诊断id,
                   Extractvalue(Value(A), 'ROW/ZHID') As 证候id, Extractvalue(Value(A), 'ROW/ZDMS') As 诊断描述,
                   Extractvalue(Value(A), 'ROW/CYQK') As 出院情况, Extractvalue(Value(A), 'ROW/SFWZ') As 是否未治,
                   Extractvalue(Value(A), 'ROW/SFYZ') As 是否疑诊,
                   To_Date(Extractvalue(Value(A), 'ROW/JLRQ'), 'yyyy-mm-dd hh24:mi:ss') As 记录日期,
                   Extractvalue(Value(A), 'ROW/YZID') As 医嘱id, Extractvalue(Value(A), 'ROW/ZDCX') As 诊断次序,
                   Extractvalue(Value(A), 'ROW/BZ') As 备注, Extractvalue(Value(A), 'ROW/RYBQ') As 入院病情,
                   To_Date(Extractvalue(Value(A), 'ROW/FBSJ'), 'yyyy-mm-dd hh24:mi:ss') As 发病时间,
                   Extractvalue(Value(A), 'ROW/JLR') As 记录人, Extractvalue(Value(A), 'ROW/ID') As ID,
                   Extractvalue(Value(A), 'ROW/FMID') As 附码id
            From Table(Xmlsequence(Extract(Xml_In, 'IN/DIAGS/ROW'))) A) Loop
  
    Select 病人诊断记录_Id.Nextval Into n_诊断id From Dual;
    Rs_Sql诊断.Extend;
    n_Tmp := Rs_Sql诊断.Count;
    Rs_Sql诊断(n_Tmp).病人id := r.病人id;
    Rs_Sql诊断(n_Tmp).主页id := r.主页id;
    Rs_Sql诊断(n_Tmp).记录来源 := r.记录来源;
    Rs_Sql诊断(n_Tmp).病历id := r.病历id;
    Rs_Sql诊断(n_Tmp).诊断类型 := r.诊断类型;
    Rs_Sql诊断(n_Tmp).疾病id := r.疾病id;
    Rs_Sql诊断(n_Tmp).诊断id := r.诊断id;
    Rs_Sql诊断(n_Tmp).证候id := r.证候id;
    Rs_Sql诊断(n_Tmp).诊断描述 := r.诊断描述;
    Rs_Sql诊断(n_Tmp).出院情况 := r.出院情况;
    Rs_Sql诊断(n_Tmp).是否未治 := r.是否未治;
    Rs_Sql诊断(n_Tmp).是否疑诊 := r.是否疑诊;
    Rs_Sql诊断(n_Tmp).记录日期 := r.记录日期;
    Rs_Sql诊断(n_Tmp).医嘱id := Null;
    Rs_Sql诊断(n_Tmp).诊断次序 := r.诊断次序;
    Rs_Sql诊断(n_Tmp).备注 := r.备注;
    Rs_Sql诊断(n_Tmp).入院病情 := r.入院病情;
    Rs_Sql诊断(n_Tmp).发病时间 := r.发病时间;
    Rs_Sql诊断(n_Tmp).记录人 := r.记录人;
    Rs_Sql诊断(n_Tmp).Id := n_诊断id;
    Rs_Sql诊断(n_Tmp).附码id := r.附码id;
  
    --替换真实的诊断ID
    For J In 1 .. Rs_Sql诊断医嘱.Count Loop
      If Rs_Sql诊断医嘱(J).诊断序号 = To_Number(r.诊断序号) Then
        Rs_Sql诊断医嘱(J).诊断id := n_诊断id;
      End If;
    End Loop;
  End Loop;

  --提交数据
  Xml_Out := Xmltype('<OUTPUT></OUTPUT>');
  For I In 1 .. Rs_Sql.Count Loop
    v_医嘱ids := v_医嘱ids || ',' || Rs_Sql(I).Id;
    If Rs_Sql(I).相关id Is Null Then
      v_Tmp := '<ITEM><ZLXMID>' || Rs_Sql(I).诊疗项目id || '</ZLXMID><ZYZID>' || Rs_Sql(I).Id || '</ZYZID></ITEM>';
      Select Appendchildxml(Xml_Out, '/OUTPUT', Xmltype(v_Tmp)) Into Xml_Out From Dual;
    End If;
    Zl_病人医嘱记录_Insert(Rs_Sql(I).Id, Rs_Sql(I).相关id, Rs_Sql(I).序号, Rs_Sql(I).病人来源, Rs_Sql(I).病人id, Rs_Sql(I).主页id,
                     Rs_Sql(I).婴儿, Rs_Sql(I).医嘱状态, Rs_Sql(I).医嘱期效, Rs_Sql(I).诊疗类别, Rs_Sql(I).诊疗项目id, Rs_Sql(I).收费细目id,
                     Rs_Sql(I).天数, Rs_Sql(I).单次用量, Rs_Sql(I).总给予量, Rs_Sql(I).医嘱内容, Rs_Sql(I).医生嘱托, Rs_Sql(I).标本部位,
                     Rs_Sql(I).执行频次, Rs_Sql(I).频率次数, Rs_Sql(I).频率间隔, Rs_Sql(I).间隔单位, Rs_Sql(I).执行时间方案, Rs_Sql(I).计价特性,
                     Rs_Sql(I).执行科室id, Rs_Sql(I).执行性质, Rs_Sql(I).紧急标志, Rs_Sql(I).开始执行时间, Rs_Sql(I).执行终止时间,
                     Rs_Sql(I).病人科室id, Rs_Sql(I).开嘱科室id, Rs_Sql(I).开嘱医生, Rs_Sql(I).开嘱时间, Rs_Sql(I).挂号单, Rs_Sql(I).前提id,
                     Rs_Sql(I).检查方法, Rs_Sql(I).执行标记, Rs_Sql(I).可否分零, Rs_Sql(I).摘要, Rs_Sql(I).操作员姓名);
  End Loop;

  For I In 1 .. Rs_Sql诊断.Count Loop
    Zl_病人诊断记录_Insert(Rs_Sql诊断(I).病人id, Rs_Sql诊断(I).主页id, Rs_Sql诊断(I).记录来源, Rs_Sql诊断(I).病历id, Rs_Sql诊断(I).诊断类型,
                     Rs_Sql诊断(I).疾病id, Rs_Sql诊断(I).诊断id, Rs_Sql诊断(I).证候id, Rs_Sql诊断(I).诊断描述, Rs_Sql诊断(I).出院情况,
                     Rs_Sql诊断(I).是否未治, Rs_Sql诊断(I).是否疑诊, Rs_Sql诊断(I).记录日期, Rs_Sql诊断(I).医嘱id, Rs_Sql诊断(I).诊断次序,
                     Rs_Sql诊断(I).备注, Rs_Sql诊断(I).入院病情, Rs_Sql诊断(I).发病时间, Rs_Sql诊断(I).记录人, Rs_Sql诊断(I).Id,
                     Rs_Sql诊断(I).附码id);
  End Loop;

  For I In 1 .. Rs_Sql诊断医嘱.Count Loop
    Zl_病人诊断医嘱_Delete(Rs_Sql诊断医嘱(I).医嘱id);
    Zl_病人诊断医嘱_Insert(Null, Null, Rs_Sql诊断医嘱(I).诊断id, Rs_Sql诊断医嘱(I).医嘱id);
  End Loop;

  For I In 1 .. Rs_Sql病人医嘱附件记录.Count Loop
    Zl_病人医嘱附件_Insert(Rs_Sql病人医嘱附件记录(I).医嘱id, Rs_Sql病人医嘱附件记录(I).项目, Rs_Sql病人医嘱附件记录(I).必填, Rs_Sql病人医嘱附件记录(I).排列,
                     Rs_Sql病人医嘱附件记录(I).要素id, Rs_Sql病人医嘱附件记录(I).内容);
  End Loop;

  v_Tmp := '<YZIDS>' || Substr(v_医嘱ids, 2) || '</YZIDS>';
  Select Appendchildxml(Xml_Out, '/OUTPUT', Xmltype(v_Tmp)) Into Xml_Out From Dual;
Exception
  When Err_Item Then
    Rollback;
    v_Tmp   := '<OUTPUT><ERROR><MSG>错误信息：' || v_Err_Msg || '</MSG></ERROR></OUTPUT>';
    Xml_Out := Xmltype(v_Tmp);
  When Others Then
    Rollback;
    v_Tmp   := '<OUTPUT><ERROR><MSG>错误信息：' || SQLErrM || '</MSG></ERROR></OUTPUT>';
    Xml_Out := Xmltype(v_Tmp);
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Advicesave;
/

--121568:梁唐彬,2018-02-09,门诊路径重新生成报错
CREATE OR REPLACE Procedure Zl_病人诊断记录_Insert
(
  病人id_In   病人诊断记录.病人id%Type,
  主页id_In   病人诊断记录.主页id%Type,
  记录来源_In 病人诊断记录.记录来源%Type,
  病历id_In   病人诊断记录.病历id%Type,
  诊断类型_In 病人诊断记录.诊断类型%Type,
  疾病id_In   病人诊断记录.疾病id%Type,
  诊断id_In   病人诊断记录.诊断id%Type,
  证候id_In   病人诊断记录.证候id%Type,
  诊断描述_In 病人诊断记录.诊断描述%Type,
  出院情况_In 病人诊断记录.出院情况%Type,
  是否未治_In 病人诊断记录.是否未治%Type,
  是否疑诊_In 病人诊断记录.是否疑诊%Type,
  记录日期_In 病人诊断记录.记录日期%Type,
  医嘱id_In   varchar2 := Null,
  诊断次序_In 病人诊断记录.诊断次序%Type := 1,
  备注_In     病人诊断记录.备注%Type := Null,
  入院病情_In 病人诊断记录.入院病情%Type := Null,
  发病时间_In 病人诊断记录.发病时间%Type := Null,
  记录人_In   病人诊断记录.记录人%Type := Null,
  Id_In       病人诊断记录.Id%Type := Null,
  附码id_In   病人诊断记录.疾病id%Type := Null
) Is
  --功能：插入病人诊断记录
  --医嘱id_In=与当前诊断相关联的，用","间隔的医嘱ID串
  v_诊断id 病人诊断记录.Id%Type;
  v_医嘱id 病人医嘱记录.Id%Type;

  v_病人科室id 病人信息.当前科室id%Type;
  v_经治医师   人员表.姓名%Type;
  v_编码       疾病编码目录.编码%Type;
  n_Count      Number;
  v_发病时间   病人诊断记录.发病时间%Type;

  v_Temp     varchar2(255);
  v_人员姓名 人员表.姓名%Type;
Begin
  --当前操作人员
  If 记录人_In Is Null Then
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  Else
    v_人员姓名 := 记录人_In;
  End If;

  If Id_In Is Null Then
    Select 病人诊断记录_Id.Nextval Into v_诊断id From Dual;
  Else
    v_诊断id := Id_In;
  End If;

  v_医嘱id := Zl_To_Number(医嘱id_In);
  If v_医嘱id = 0 Then
    v_医嘱id := Null;
  End If;

  Insert Into 病人诊断记录
    (ID, 病人id, 主页id, 记录来源, 病历id, 诊断类型, 诊断次序, 疾病id, 诊断id, 证候id, 诊断描述, 入院病情, 出院情况, 是否未治, 是否疑诊, 
         记录日期, 记录人, 医嘱id, 备注, 发病时间)
  Values
    (v_诊断id, 病人id_In, 主页id_In, 记录来源_In, 病历id_In, 诊断类型_In, 诊断次序_In, 疾病id_In, 诊断id_In, 证候id_In, 诊断描述_In, 入院病情_In, 出院情况_In,
     是否未治_In, 是否疑诊_In, 记录日期_In, v_人员姓名, v_医嘱id, 备注_In, 发病时间_In);

 If 附码id_In Is Not Null Then
    Insert Into 病人诊断记录
      (Id, 病人id, 主页id, 记录来源, 病历id, 诊断类型, 诊断次序,疾病id, 诊断id, 证候id, 诊断描述, 入院病情, 出院情况, 是否未治, 是否疑诊, 
          记录日期, 记录人, 医嘱id, 备注, 发病时间,编码序号)
      Select 病人诊断记录_Id.Nextval, 病人id_In, 主页id_In, 记录来源_In, 病历id_In, 诊断类型_In, 诊断次序_In, 附码id_In, 诊断id_In, 证候id_In, 诊断描述_In,
           入院病情_In, 出院情况_In, 是否未治_In, 是否疑诊_In, 记录日期_In, v_人员姓名, v_医嘱id, 备注_In, 发病时间_In,2
      From Dual;
  End If;

  --如果是门诊第一诊断则更新病人挂号记录.发病时间
  v_发病时间 := 发病时间_In;
  If 诊断类型_In = 1 And 诊断次序_In = 1 Then
    If 发病时间_In Is Null Then
      --检查中医的发病时间，有则取中医的，否则清空
      Select Max(发病时间)
      Into v_发病时间
      From 病人诊断记录
      Where 病人id = 病人id_In And 主页id = 主页id_In And 诊断类型 = 11 And 诊断次序 = 1;
    End If;
    If v_发病时间 Is Null Then
      --如果都为NULL，则取挂号记录中的
      Select Max(发病时间) Into v_发病时间 From 病人挂号记录 Where 病人id = 病人id_In And ID = 主页id_In;
    End If;
    Update 病人挂号记录 Set 发病时间 = v_发病时间 Where 病人id = 病人id_In And ID = 主页id_In;
  End If;
  If 诊断类型_In = 11 And 诊断次序_In = 1 Then
    --如果是中医，则判断是否填写了西医的发病时间，没有填写，则修改，否则以西医发病时间为准
    Select Count(*)
    Into n_Count
    From 病人诊断记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 诊断类型 = 1 And 诊断次序 = 1 And 发病时间 Is Not Null;
    If n_Count = 0 Then
      If v_发病时间 Is Null Then
        --如果都为NULL，则取挂号记录中的
        Select Max(发病时间) Into v_发病时间 From 病人挂号记录 Where 病人id = 病人id_In And ID = 主页id_In;
      End If;
      Update 病人挂号记录 Set 发病时间 = v_发病时间 Where 病人id = 病人id_In And ID = 主页id_In;
    End If;
  End If;

  If 医嘱id_In Is Not Null Then
    For r_Advice In (Select Column_Value As 医嘱id
                    From Table(Cast(f_Num2list(医嘱id_In) As Zltools.t_Numlist)) A, 病人医嘱记录 B
                    Where a.Column_Value = b.Id) Loop 
      Insert Into 病人诊断医嘱 (诊断id, 医嘱id) Values (v_诊断id, r_Advice.医嘱id);
    End Loop;
  End If;

  --如果是入院第一诊断，则判断是否是单病种
  If 诊断类型_In = 2 And 诊断次序_In = 1 And 记录来源_In = 3 Then
    If 疾病id_In Is Not Null Then
      Select 编码 Into v_编码 From 疾病编码目录 Where ID = 疾病id_In;
      Select Max(Upper(编码))
      Into v_编码
      From 单病种目录
      Where Instr('/' || Replace(Upper(Icd编码), ' ', '') || '/', '/' || Upper(v_编码) || '/') > 0 And Rownum < 2;
    Else
      v_编码 := '';
    End If;
    Update 病案主页 Set 单病种 = v_编码 Where 病人id = 病人id_In And 主页id = 主页id_In;
  End If;

  --根据传入的主页id_In查询挂号记录来区分是门诊首页还是住院首页调用
  Begin
    Select 执行人, 执行部门id Into v_病人科室id, v_经治医师 From 病人挂号记录 Where ID = 主页id_In;
    Zl_电子病历时机_Insert(病人id_In, 主页id_In, 1, '诊断', v_病人科室id, v_经治医师, 记录日期_In, 记录日期_In);
  Exception
    When Others Then
      Null;
  End;
  If v_病人科室id Is Null And (诊断类型_In <> 1 Or 诊断类型_In <> 11) Then
    Begin
      Select 出院科室id, 住院医师
      Into v_病人科室id, v_经治医师
      From 病案主页
      Where 病人id = 病人id_In And 主页id = 主页id_In;
      Zl_电子病历时机_Insert(病人id_In, 主页id_In, 2, '诊断', v_病人科室id, v_经治医师, 记录日期_In, 记录日期_In);
    Exception
      When Others Then
        Null;
    End;
  End If;
  b_Message.Zlhis_Cis_010(病人id_In, 主页id_In, v_诊断id);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人诊断记录_Insert;
/

--113206:胡俊勇,2018-01-08,区卫妇幼专版工作站接口
CREATE OR REPLACE Procedure Zl_Third_Advicesend
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:门诊医嘱发送
  --     外挂接口，医保接口，记帐报警，电子签名等功能失效。
  --入参:Xml_In:
  --  <IN>
  --  <BRID></BRID>病人ID
  --  <JZID></JZID>就诊ID，挂号ID
  --  <CZYXM></CZYXM> 操作员姓名
  --  <CZYBH></CZYBH> 操作员编号
  --  <ZD></ZD>站点,字符串，长度为1
  --  <YZIDS>1</YZIDS>要发送的医嘱ID串，逗号分割
  --  <JZD>0</JZD> 是否发送为记帐单，0-划价单，1-记帐单
  --  <JBJJ></JBJJ>加班加价 由外部传入决定
  --  <CZYID></CZYID>操作员ID
  --  <CLLIS></CLLIS>处理LIS申请，定决是否要在过程内部调用LIS接口， 0-不处理，1-要处理
  --  <FHLISDATA></FHLISDATA>是否需要返回LIS申请信息，0-不返回，1-返回
  --  </IN>

  --出参:Xml_Out
  --  <OUTPUT>
  --    <ERROR>
  --      <MSG>错误信息</MSG>
  --    </ERROR>
  --  </OUTPUT>
  --------------------------------------------------------------------------------------------------

  --自定义类型
  --动态游标类型
  Type Rs_Recordset Is Ref Cursor;

  --医嘱表格类型
  Type r_Advice Is Record(
    选择          Number,
    婴儿          Number,
    医嘱内容      Varchar2(4000),
    总量          Number(16, 5),
    总量单位      Varchar2(500),
    单量          Number(16, 5),
    单量单位      Varchar2(500),
    金额          Number(16, 5),
    金额_Data     Number(16, 5),
    频率          Varchar2(500),
    频率_Data     Varchar2(500),
    用法          Varchar2(500),
    医生嘱托      Varchar2(500),
    医生嘱托_Data Varchar2(500), --摘要
    执行时间      Varchar2(500),
    执行科室      Varchar2(500),
    执行性质      Varchar2(500),
    ID            Number(18),
    Id_Data       Varchar2(4000), --
    相关id        Number(18),
    病人科室id    Number(18),
    开嘱科室id    Number(18),
    开嘱医生      Varchar2(500),
    诊疗类别      Varchar2(500),
    诊疗项目id    Number(18),
    标本部位      Varchar2(500),
    检查方法      Varchar2(500),
    执行标记      Varchar2(500),
    计价特性      Number(1),
    执行性质id    Number(18),
    执行科室id    Number(18),
    收费细目id    Number(18),
    频率次数      Number(3),
    频率间隔      Number(3),
    间隔单位      Varchar2(4),
    剂量系数      Varchar2(500),
    门诊包装      Varchar2(500),
    门诊单位      Varchar2(500),
    可否分零      Number(1),
    库存          Varchar2(500),
    次数          Varchar2(500),
    分解时间      Varchar2(4000),
    分解时间_Data Varchar2(4000),
    首次时间      Varchar2(500),
    末次时间      Varchar2(500),
    前提id        Number(18),
    签名id        Number(18),
    试管编码      Varchar2(500),
    操作类型      Varchar2(500),
    紧急标志      Varchar2(500),
    零费记帐      Varchar2(500),
    计算方式      Varchar2(500),
    开始时间      Varchar2(500),
    执行安排      Varchar2(500),
    执行分类      Varchar2(500),
    毒理分类      Varchar2(500));
  Type t_Advice Is Table Of r_Advice;

  --项目收费对照
  Type r_Price Is Record(
    医嘱id     Number(18),
    相关id     Number(18),
    费用性质   Number(18),
    收费方式   Number(18),
    收费类别   Varchar2(500),
    收费细目id Number(18),
    执行科室id Number(18),
    数量       Number(16, 5),
    单价       Number(16, 5),
    在用       Number(18),
    变价       Number(18),
    从项       Number(18),
    固定       Number(18));
  Type t_Price Is Table Of r_Price;

  Type r_Bill Is Record(
    Key      Varchar2(200),
    NO       Varchar2(30),
    费用序号 Number(18),
    发送序号 Number(18));
  Type t_Bill Is Table Of r_Bill;

  Type r_Exec Is Record(
    医嘱id     Number(18),
    发送号     Number(18),
    收费细目id Number(18),
    要求时间   Varchar2(30),
    数量       Number(16, 5),
    费用性质   Number(1));
  Type t_Exec Is Table Of r_Exec;

  Type r_Number Is Record(
    管码       Varchar2(30),
    相关id     Number(18),
    样本条码   Varchar2(18),
    执行科室id Number(18),
    诊疗项目id Number(18),
    婴儿       Number(1),
    紧急标志   Number(1),
    标本       Varchar2(18),
    采集科室id Number(18));
  Type t_Number Is Table Of r_Number;

  Type r_Moneynow Is Record(
    医嘱id     Number(18),
    诊疗项目id Number(18),
    收费项目id Number(18),
    试管编码   Varchar2(18),
    样本条码   Varchar2(18),
    收费方式   Number(1),
    收费时间   Varchar2(18),
    执行部门id Number(18));
  Type t_Moneynow Is Table Of r_Moneynow;

  Type r_Moneyday Is Record(
    诊疗项目id Number(18),
    收费项目id Number(18),
    执行部门id Number(18),
    收费方式   Number(1),
    执行否     Number(18),
    收费时间   Varchar2(30));
  Type t_Moneyday Is Table Of r_Moneyday;

  Type 医嘱计价_Sql Is Record(
    过程名     Number, --1--ZL_病人医嘱计价_Delete ; 2 --ZL_病人医嘱计价_INSERT
    医嘱id     病人医嘱记录.Id%Type,
    收费细目id 病人医嘱计价.收费细目id%Type,
    数量       病人医嘱计价.数量%Type,
    单价       病人医嘱计价.单价%Type,
    从项       病人医嘱计价.从项%Type := Null,
    执行科室id 病人医嘱计价.执行科室id%Type := Null,
    费用性质   病人医嘱计价.费用性质%Type := 0,
    收费方式   病人医嘱计价.收费方式%Type := 0,
    删单行     Number);
  Type t_医嘱计价_Sql Is Table Of 医嘱计价_Sql;

  Type 病人费用_Insert Is Record(
    过程名     Number, --1--ZL_门诊划价记录_INSERT;  2--ZL_门诊记帐记录_INSERT
    NO         Varchar2(300),
    序号       门诊费用记录.序号%Type,
    病人id     门诊费用记录.病人id%Type,
    主页id     住院费用记录.主页id%Type,
    标识号     门诊费用记录.标识号%Type,
    付款方式   门诊费用记录.付款方式%Type,
    姓名       门诊费用记录.姓名%Type,
    性别       门诊费用记录.性别%Type,
    年龄       门诊费用记录.年龄%Type,
    费别       Varchar2(300),
    加班标志   门诊费用记录.加班标志%Type,
    病人科室id 门诊费用记录.病人科室id%Type,
    开单部门id 门诊费用记录.开单部门id%Type,
    开单人     门诊费用记录.开单人%Type,
    从属父号   门诊费用记录.从属父号%Type,
    收费细目id 门诊费用记录.收费细目id%Type,
    收费类别   门诊费用记录.收费类别%Type,
    计算单位   门诊费用记录.计算单位%Type,
    发药窗口   门诊费用记录.发药窗口%Type,
    付数       门诊费用记录.付数%Type,
    数次       门诊费用记录.数次%Type,
    附加标志   门诊费用记录.附加标志%Type,
    执行部门id 门诊费用记录.执行部门id%Type,
    价格父号   门诊费用记录.价格父号%Type,
    收入项目id 门诊费用记录.收入项目id%Type,
    收据费目   门诊费用记录.收据费目%Type,
    标准单价   门诊费用记录.标准单价%Type,
    应收金额   门诊费用记录.应收金额%Type,
    实收金额   门诊费用记录.实收金额%Type,
    发生时间   门诊费用记录.发生时间%Type,
    登记时间   门诊费用记录.登记时间%Type,
    药品摘要   药品收发记录.摘要%Type,
    操作员姓名 门诊费用记录.操作员姓名%Type,
    费用摘要   门诊费用记录.摘要%Type := Null,
    医嘱序号   门诊费用记录.医嘱序号%Type := Null,
    频次       药品收发记录.频次%Type := Null,
    单量       药品收发记录.单量%Type := Null,
    用法       药品收发记录.用法%Type := Null,
    期效       药品收发记录.扣率%Type := Null,
    计价特性   药品收发记录.扣率%Type := Null,
    病人来源   Number := 1,
    保险编码   门诊费用记录.保险编码%Type := Null,
    费用类型   门诊费用记录.费用类型%Type := Null,
    保险项目否 门诊费用记录.保险项目否%Type := Null,
    保险大类id 门诊费用记录.保险大类id%Type := Null,
    中药形态   门诊费用记录.结论%Type := Null,
    备货材料   Number := 0,
    批次       药品收发记录.批次%Type := Null,
    划价       Number,
    婴儿费     门诊费用记录.婴儿费%Type,
    操作员编号 门诊费用记录.操作员编号%Type,
    门诊标志   门诊费用记录.门诊标志%Type := 1,
    记帐单id   门诊费用记录.记帐单id%Type := Null);
  Type t_病人费用_Insert Is Table Of 病人费用_Insert;

  --自动发料可执行SQL
  Type 处方发料_Sql Is Record(
    Partid   药品收发记录.库房id%Type,
    Bill     药品收发记录.单据%Type,
    NO       药品收发记录.No%Type,
    People   药品收发记录.审核人%Type,
    配药人   药品收发记录.配药人%Type,
    校验人   药品收发记录.填制人%Type,
    发药方式 药品收发记录.发药方式%Type,
    发药时间 药品收发记录.审核日期%Type);
  Type t_处方发料_Sql Is Table Of 处方发料_Sql;
  --医嘱发送记录生成SQL
  Type 医嘱发送_Sql Is Record(
    医嘱id     病人医嘱发送.医嘱id%Type,
    发送号     病人医嘱发送.发送号%Type,
    记录性质   病人医嘱发送.记录性质%Type,
    NO         病人医嘱发送.No%Type,
    记录序号   病人医嘱发送.记录序号%Type,
    发送数次   病人医嘱发送.发送数次%Type,
    首次时间   病人医嘱发送.首次时间%Type,
    末次时间   病人医嘱发送.末次时间%Type,
    发送时间   病人医嘱发送.发送时间%Type,
    执行状态   病人医嘱发送.执行状态%Type,
    执行部门id 病人医嘱发送.执行部门id%Type,
    计费状态   病人医嘱发送.计费状态%Type,
    First      Number := 0,
    样本条码   病人医嘱发送.样本条码%Type := Null,
    操作员编号 人员表.编号%Type := Null,
    操作员姓名 人员表.姓名%Type := Null);
  Type t_医嘱发送_Sql Is Table Of 医嘱发送_Sql;

  --医嘱执行计价SQL
  Type 执行计价_Sql Is Record(
    医嘱id     医嘱执行计价.医嘱id%Type,
    发送号     医嘱执行计价.发送号%Type,
    要求时间   医嘱执行计价.要求时间%Type,
    收费细目id 医嘱执行计价.收费细目id%Type,
    数量       医嘱执行计价.数量%Type,
    费用性质   医嘱执行计价.费用性质%Type);

  Type t_执行计价_Sql Is Table Of 执行计价_Sql;

  --可执行SQL记录
  r_计价     t_医嘱计价_Sql := t_医嘱计价_Sql();
  r_费用     t_病人费用_Insert := t_病人费用_Insert();
  r_发料     t_处方发料_Sql := t_处方发料_Sql();
  r_发送     t_医嘱发送_Sql := t_医嘱发送_Sql();
  r_执行计价 t_执行计价_Sql := t_执行计价_Sql();

  --缓存数据
  Vsadvice    t_Advice;
  Rs_Price    t_Price;
  Rs_Bill     t_Bill := t_Bill();
  Rs_Exec     t_Exec;
  Rs_Number   t_Number := t_Number();
  Rs_Moneynow t_Moneynow := t_Moneynow();
  Rs_Moneyday t_Moneyday;

  --公用的
  Gv_Nodeno         Varchar2(20); --站点,外部传入
  Gn_Decprice       Number := 0; --系统参数
  Gn_Dec            Number := 0;
  Gb_加班加价       Boolean := False; --外部传入
  Gv_动态费别       Varchar2(4000);
  Gb_从项汇总折扣   Boolean := False;
  Gb_执行前先结算   Boolean := False;
  Gn_Rxcount        Number := 0;
  Gv_门诊发送划价单 Varchar2(400);
  Gn_消费验证       Number;
  Gb_门诊自动发料   Boolean;
  Gb_发送生成条形码 Boolean;

  --过程级的变量
  Mn_病人id     病人信息.病人id%Type;
  Mn_挂号id     病人信息.病人id%Type;
  Mv_挂号单     病人挂号记录.No%Type;
  Mv_门诊号     病人挂号记录.门诊号%Type;
  Mv_姓名       病人挂号记录.姓名%Type;
  Mv_性别       病人挂号记录.性别%Type;
  Mv_年龄       病人挂号记录.年龄%Type;
  Mv_操作员编号 人员表.编号%Type;
  Mv_操作员姓名 人员表.姓名%Type;

  Mv_费别             Varchar2(400);
  Mv_医嘱ids          Varchar2(4000);
  Mv_Msg              Varchar2(4000);
  Mb_Auto             Boolean := False;
  Mn_Nosequence       Number := 0; --单据号序列重新初始
  Mn_Sendno           Number := 0;
  Mv_单据组合类别     Varchar2(400);
  Mb_检验单独产生单据 Boolean := False;
  Mb_一并给药发一张   Boolean := False;
  Mb_Starttimedef     Boolean := False;

  -------------外部直接传入的XML内容-------------
  n_病人id     Number;
  n_就诊id     Number;
  v_医嘱ids    Varchar2(8000);
  v_Tmp        Varchar2(3000);
  v_站点       Varchar2(2);
  n_记帐       Number;
  v_操作员姓名 人员表.姓名%Type;
  v_操作员编号 人员表.编号%Type;
  n_加班加价   Number;
  n_调用       Number;
  n_返回       Number;
  I            Number;
  x_t          Xmltype;

  ----------------------子方法区域---------------------
  --获取出错信息
  Function f_Geterrmsg Return Varchar2 Is
  Begin
    Return Mv_Msg;
  End;

  --错误处理中心包内部调用
  Procedure p_Errcenter(Msg_In In Varchar2) Is
  Begin
    Mv_Msg := Msg_In;
  End;

  --检验LIS接口
  Procedure p_Lis接口
  (
    调用_In In Number,
    返回_In In Number,
    Xml_Out Out Xmltype
  ) Is
    --------------------------------------------------------------------------------------------------
    --功能:LIS检验接口
    --调用_IN 是否直接调用LIS存储过程,1-调用,0-不调用;
    --返回_in 是否返回调用LIS过程时的参数
    --出参:Xml_Out，生成的医嘱ID串，错误信息
    --  <OUTPUT>
    --    <LISAPP>C:44271,E:44272;C:44273,E:44274</LISAPP>检验医嘱信息，固定格式：类别:医嘱ID,类别:医嘱ID;....
    --    <LISDATA></LISDATA>新版LIS检验信息，返回值
    --         LISDATA 此结点的内容，为 Zl_Thrid_Sendlisapplication 过程的 入参数，
    --         结点内容可以有行<IN>XXX1</IN><IN>XXX2</IN>.....
    --    <ERROR>
    --      <MSG>错误信息</MSG>
    --    </ERROR>
    --  </OUTPUT>
    --------------------------------
    --申请基本信息，医嘱id_In 检验行医嘱ID
    Cursor c_Pati(医嘱id_In In 病人医嘱记录.Id%Type) Is
      Select a.Id As 医嘱id, a.相关id As 申请id, a.病人来源, a.病人id, a.婴儿, c.姓名, Decode(c.性别, '男', 1, '女', 2, '未知', 9, 0) 性别, a.年龄,
             a.开嘱医生 As 申请人, a.开嘱时间 As 申请时间, d.名称 As 申请科室, c.当前床号 As 床号, c.健康号, e.名称 As 病人科室, a.紧急标志, a.挂号单, c.门诊号, c.住院号,
             c.出生日期, a.主页id, b.接收人 As 签收人, b.接收时间 As 签收时间, b.采样人, b.采样时间, b.样本条码, 1 As 病人类型, Null As 路径状态, b.送检人,
             b.标本送出时间 As 送检时间, b.计费状态, a.诊疗项目id, f.编码 As 诊疗编码, a.标本部位 As 标本类型, b.记录性质, e.编码 As 病人科室编码, d.编码 As 申请科室编码,
             g.编码 As 病区编码, g.名称 As 病区
      From 病人医嘱记录 A, 病人医嘱发送 B, 病人信息 C, 部门表 D, 部门表 E, 诊疗项目目录 F, 部门表 G
      Where a.Id = b.医嘱id And a.病人id = c.病人id And a.开嘱科室id = d.Id And a.病人科室id = e.Id And a.诊疗项目id = f.Id And
            c.当前病区id = g.Id(+) And a.Id = 医嘱id_In;
    r_Pati c_Pati%RowType;
  
    --采集行 医嘱id_In 采集行医嘱ID
    Cursor c_Cjrow(医嘱id_In In 病人医嘱记录.Id%Type) Is
      Select 医嘱id_In As 医嘱id, b.名称 As 采集方式, c.名称 As 采集科室, Sum(d.应收金额) As 应收金额, Sum(Decode(d.记录状态, 1, d.实收金额, 0)) As 实收金额,
             Max(d.记录状态) As 记录状态, Max(d.记录性质) As 记录性质
      From 病人医嘱记录 A, 诊疗项目目录 B, 部门表 C, 门诊费用记录 D
      Where a.诊疗项目id = b.Id And a.执行科室id = c.Id And a.Id = d.医嘱序号(+) And a.Id = 医嘱id_In
      Group By b.名称, c.名称;
    r_Cj c_Cjrow%RowType;
  
    --检验行 医嘱id_In 检验行医嘱ID
    Cursor c_Jyrow(医嘱id_In In 病人医嘱记录.Id%Type) Is
      Select 医嘱id_In As 医嘱id, Max(a.费别) As 费别, Max(a.记录状态) As 记录状态, Max(a.记录性质) As 记录性质, Sum(a.应收金额) As 应收金额,
             Sum(Decode(a.记录状态, 1, a.实收金额, 0)) As 实收金额
      From 门诊费用记录 A
      Where a.医嘱序号 = 医嘱id_In;
    r_Jy c_Jyrow%RowType;
  
    v_Tmp      Varchar(32767);
    v_Lisinfo  Varchar2(30000);
    v_Lisapp   Varchar2(3000);
    x_Lis      Xmltype;
    n_医嘱id   Number(18);
    x_T1       Xmltype;
    x_T2       Xmltype;
    n_记录状态 Number;
    n_记录性质 Number;
    n_计费状态 Number;
    v_Lisids   Varchar(8000);
    v_Err_Msg  Varchar(2000);
    Err_Item Exception;
  Begin
    For I In 1 .. Vsadvice.Count Loop
      If Vsadvice(I).诊疗类别 = 'C' Then
        v_Lisapp := v_Lisapp || ';C:' || Vsadvice(I).Id;
      Elsif Vsadvice(I).诊疗类别 = 'E' And Vsadvice(I).操作类型 = '6' Then
        v_Lisapp := v_Lisapp || ',E:' || Vsadvice(I).Id;
      End If;
    End Loop;
    v_Lisids := Substr(v_Lisapp, 2);
    x_Lis    := Xmltype('<LISDATA></LISDATA>');
    v_Lisapp := v_Lisids || ';';
  
    While v_Lisapp Is Not Null Loop
      v_Tmp    := Substr(v_Lisapp, 1, Instr(v_Lisapp, ';') - 1);
      v_Lisapp := Substr(v_Lisapp, Instr(v_Lisapp, ';') + 1);
      v_Tmp    := Replace(Replace(v_Tmp, 'C:', ''), ',E:', ',');
      n_医嘱id := To_Number(Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1));
      Open c_Pati(n_医嘱id);
      Fetch c_Pati
        Into r_Pati;
      Close c_Pati;
      Open c_Jyrow(n_医嘱id);
      Fetch c_Jyrow
        Into r_Jy;
      Close c_Jyrow;
    
      n_医嘱id := To_Number(Substr(v_Tmp, Instr(v_Tmp, ',') + 1));
      Open c_Cjrow(n_医嘱id);
      Fetch c_Cjrow
        Into r_Cj;
      Close c_Cjrow;
    
      --获取计费状态
      n_记录状态 := Nvl(r_Cj.记录状态, 0);
      n_记录性质 := Nvl(r_Cj.记录性质, 0);
      If n_记录性质 = 2 And n_记录状态 = 1 Then
        n_计费状态 := 3;
      Else
        If n_记录状态 = 0 Then
          n_计费状态 := 0;
        Else
          If n_记录状态 = 1 Then
            n_计费状态 := 1;
          Else
            If n_记录状态 = 2 Or n_记录状态 = 3 Then
              n_计费状态 := 2;
            Else
              n_计费状态 := 0;
            End If;
          End If;
        End If;
      End If;
    
      v_Lisinfo := '<IN>';
      v_Lisinfo := v_Lisinfo || '<TYPE>0</TYPE><ADVICE>';
    
      v_Lisinfo := v_Lisinfo || '<SQID>' || r_Cj.医嘱id || '</SQID>';
      v_Lisinfo := v_Lisinfo || '<YZID>' || r_Jy.医嘱id || '</YZID>';
      v_Lisinfo := v_Lisinfo || '<BRLY>1</BRLY>';
      v_Lisinfo := v_Lisinfo || '<BRID>' || r_Pati.病人id || '</BRID>';
      v_Lisinfo := v_Lisinfo || '<YE>0</YE>';
      v_Lisinfo := v_Lisinfo || '<XM>' || r_Pati.姓名 || '</XM>';
      v_Lisinfo := v_Lisinfo || '<XB>' || r_Pati.性别 || '</XB>';
      v_Lisinfo := v_Lisinfo || '<NL>' || r_Pati.年龄 || '</NL>';
      v_Lisinfo := v_Lisinfo || '<NLSZ>' || Substr(r_Pati.年龄, 1, Instr(r_Pati.年龄, '岁') - 1) || '</NLSZ>';
      v_Lisinfo := v_Lisinfo || '<NLDW>' || Substr(r_Pati.年龄, Instr(r_Pati.年龄, '岁')) || '</NLDW>';
      v_Lisinfo := v_Lisinfo || '<XMBM>' || r_Pati.诊疗编码 || '</XMBM>';
      v_Lisinfo := v_Lisinfo || '<BBLX>' || r_Pati.标本类型 || '</BBLX>';
      v_Lisinfo := v_Lisinfo || '<SQR>' || r_Pati.申请人 || '</SQR>';
      v_Lisinfo := v_Lisinfo || '<SQSJ>' || To_Char(r_Pati.申请时间, 'yyyy-mm-dd hh24:mi:ss') || '</SQSJ>';
      v_Lisinfo := v_Lisinfo || '<SQKS>' || r_Pati.申请科室 || '</SQKS>';
      v_Lisinfo := v_Lisinfo || '<CH>' || r_Pati.床号 || '</CH>'; --
      v_Lisinfo := v_Lisinfo || '<JKH>' || r_Pati.健康号 || '</JKH>'; --
      v_Lisinfo := v_Lisinfo || '<BRKS>' || r_Pati.病人科室 || '</BRKS>'; --
      v_Lisinfo := v_Lisinfo || '<JJ>' || r_Pati.紧急标志 || '</JJ>'; --
      v_Lisinfo := v_Lisinfo || '<GHD>' || r_Pati.挂号单 || '</GHD>'; --
      v_Lisinfo := v_Lisinfo || '<MZH>' || r_Pati.门诊号 || '</MZH>'; --
      v_Lisinfo := v_Lisinfo || '<ZYH>' || r_Pati.住院号 || '</ZYH>'; --
      v_Lisinfo := v_Lisinfo || '<CSRQ >' || To_Char(r_Pati.出生日期, 'yyyy-mm-dd hh24:mi:ss') || '</CSRQ>'; --
      v_Lisinfo := v_Lisinfo || '<ZYID>' || r_Pati.主页id || '</ZYID>'; --
      v_Lisinfo := v_Lisinfo || '<QSR>' || r_Pati.签收人 || '</QSR>'; --
      v_Lisinfo := v_Lisinfo || '<QSSJ>' || To_Char(r_Pati.签收时间, 'yyyy-mm-dd hh24:mi:ss') || '</QSSJ>'; --
      v_Lisinfo := v_Lisinfo || '<CYR>' || r_Pati.采样人 || '</CYR>'; --
      v_Lisinfo := v_Lisinfo || '<CYSJ>' || To_Char(r_Pati.采样时间, 'yyyy-mm-dd hh24:mi:ss') || '</CYSJ>'; --
      v_Lisinfo := v_Lisinfo || '<SJR>' || r_Pati.送检人 || '</SJR>'; --
      v_Lisinfo := v_Lisinfo || '<SJSJ>' || To_Char(r_Pati.送检时间, 'yyyy-mm-dd hh24:mi:ss') || '</SJSJ>'; --
      v_Lisinfo := v_Lisinfo || '<JFZT>' || n_计费状态 || '</JFZT>'; --计费状态，单独处理
      v_Lisinfo := v_Lisinfo || '<BQ>' || r_Pati.病区 || '</BQ>'; --
      v_Lisinfo := v_Lisinfo || '<BQBM>' || r_Pati.病区编码 || '</BQBM>'; --
      v_Lisinfo := v_Lisinfo || '<SQKSBM>' || r_Pati.申请科室编码 || '</SQKSBM>'; --
      v_Lisinfo := v_Lisinfo || '<BRKSBM>' || r_Pati.病人科室编码 || '</BRKSBM>'; --
      v_Lisinfo := v_Lisinfo || '<BRLX>' || r_Pati.病人类型 || '</BRLX>'; --
      v_Lisinfo := v_Lisinfo || '<LJZT>' || r_Pati.路径状态 || '</LJZT>'; --
      v_Lisinfo := v_Lisinfo || '<YBTM>' || r_Pati.样本条码 || '</YBTM>'; --
    
      v_Lisinfo := v_Lisinfo || '<CJFS>' || r_Cj.采集方式 || '</CJFS>'; --
      v_Lisinfo := v_Lisinfo || '<CJKS>' || r_Cj.采集科室 || '</CJKS>'; --
      v_Lisinfo := v_Lisinfo || '<YSJE>' || r_Jy.应收金额 || '</YSJE>'; --检验行
      v_Lisinfo := v_Lisinfo || '<SSJE>' || r_Jy.实收金额 || '</SSJE>'; --检验行
      v_Lisinfo := v_Lisinfo || '<FB>' || r_Jy.费别 || '</FB>'; --
      v_Lisinfo := v_Lisinfo || '<ZD></ZD>'; --诊断，暂时无
      v_Lisinfo := v_Lisinfo || '<YEXM></YEXM>'; --婴儿姓名，门诊无婴儿这一说
      v_Lisinfo := v_Lisinfo || '<YEXB></YEXB>'; --婴儿性别，门诊无
      v_Lisinfo := v_Lisinfo || '<YZFX></YZFX>'; --医嘱附项 无
      v_Lisinfo := v_Lisinfo || '<CJYSJE>' || r_Cj.应收金额 || '</CJYSJE>'; --采集行
      v_Lisinfo := v_Lisinfo || '<CJSSJE>' || r_Cj.实收金额 || '</CJSSJE>'; --采集行
    
      v_Lisinfo := v_Lisinfo || '</ADVICE></IN>';
    
      If 返回_In = 1 Then
        Select Appendchildxml(x_Lis, '/LISDATA', Xmltype(v_Lisinfo)) Into x_Lis From Dual;
      End If;
    
      If 调用_In = 1 Then
        Begin
          x_T1 := Xmltype(v_Lisinfo);
          Execute Immediate 'Begin Zl_Thrid_Sendlisapplication(:1,:2); End;'
            Using In x_T1, Out x_T2;
        Exception
          When Others Then
            v_Err_Msg := '调用LIS检验接口出错。';
            Raise Err_Item;
        End;
        If x_T2 Is Not Null Then
          Select Extractvalue(Value(A), 'OUTPUT/ERROR/MSG')
          Into v_Err_Msg
          From Table(Xmlsequence(Extract(x_T2, 'OUTPUT'))) A;
          If v_Err_Msg Is Not Null Then
            Raise Err_Item;
          End If;
        End If;
      End If;
    End Loop;
    If 返回_In = 1 Then
      Select Appendchildxml(Xml_Out, '/OUTPUT', x_Lis) Into Xml_Out From Dual;
      Select Appendchildxml(Xml_Out, '/OUTPUT', Xmltype('<LISAPP>' || v_Lisids || '</LISAPP>')) Into Xml_Out From Dual;
    End If;
  Exception
    When Err_Item Then
      v_Tmp   := '<OUTPUT><ERROR><MSG>' || v_Err_Msg || '</MSG></ERROR></OUTPUT>';
      Xml_Out := Xmltype(v_Tmp);
    When Others Then
      v_Tmp   := '<OUTPUT><ERROR><MSG>错误信息：' || SQLErrM || '</MSG></ERROR></OUTPUT>';
      Xml_Out := Xmltype(v_Tmp);
  End;

  --生成真正的NO
  Procedure p_Replacetrueno Is
  
    Type r_No Is Record(
      No_False Varchar2(200),
      No_True  Varchar2(200));
    Type t_No Is Table Of r_No;
    Rsno t_No := t_No();
  
    v_Curno Varchar2(200);
    v_No    Varchar2(200);
    I       Number;
    J       Number;
  Begin
    --发送记录
    For I In 1 .. r_发送.Count Loop
      v_Curno := r_发送(I).No;
      v_No    := Null;
      For J In 1 .. Rsno.Count Loop
        If Rsno(J).No_False = v_Curno Then
          v_No := Rsno(J).No_True;
          Exit;
        End If;
      End Loop;
      If v_No Is Null Then
        If Substr(v_Curno, 1, 2) = '13' Then
          Select Nextno(13, Null, Null, 1) Into v_No From Dual;
        Else
          Select Nextno(14, Null, Null, 1) Into v_No From Dual;
        End If;
        Rsno.Extend;
        Rsno(Rsno.Count).No_False := v_Curno;
        Rsno(Rsno.Count).No_True := v_No;
      End If;
      r_发送(I).No := v_No;    
    End Loop;
  
    --费用记录
    For I In 1 .. r_费用.Count Loop
      v_Curno := r_费用(I).No;
      v_No    := Null;
      For J In 1 .. Rsno.Count Loop
        If Rsno(J).No_False = v_Curno Then
          v_No := Rsno(J).No_True;
          Exit;
        End If;
      End Loop;
      If v_No Is Null Then
        If Substr(v_Curno, 1, 2) = '13' Then
          Select Nextno(13, Null, Null, 1) Into v_No From Dual;
        Else
          Select Nextno(14, Null, Null, 1) Into v_No From Dual;
        End If;
        Rsno.Extend;
        Rsno(Rsno.Count).No_False := v_Curno;
        Rsno(Rsno.Count).No_True := v_No;
      End If;
      r_费用(I).No := v_No;
    End Loop;
  
    --发料
    For I In 1 .. r_发料.Count Loop
      v_Curno := r_发料(I).No;
      v_No    := Null;
      For J In 1 .. Rsno.Count Loop
        If Rsno(J).No_False = v_Curno Then
          v_No := Rsno(J).No_True;
          Exit;
        End If;
      End Loop;
      If v_No Is Null Then
        If Substr(v_Curno, 1, 2) = '13' Then
          Select Nextno(13, Null, Null, 1) Into v_No From Dual;
        Else
          Select Nextno(14, Null, Null, 1) Into v_No From Dual;
        End If;
        Rsno.Extend;
        Rsno(Rsno.Count).No_False := v_Curno;
        Rsno(Rsno.Count).No_True := v_No;
      End If;
      r_发料(I).No := v_No;
    End Loop;
  End;

  --获取当前费用单据的NO及序号
  Procedure p_Getcurbillset
  (
    Key_In       In Varchar2,
    费用序号_In  In Number,
    发送序号_In  In Number,
    记帐_In      In Boolean,
    No_Out       Out Varchar2,
    费用序号_Out Out Number,
    发送序号_Out Out Number
  ) Is
    b_Have Boolean;
    n_Tmp  Number;
  Begin
  
    b_Have := False;
    For I In 1 .. Rs_Bill.Count Loop
      If Rs_Bill(I).Key = Key_In Then
        n_Tmp  := I;
        b_Have := True;
        Exit;
      End If;
    End Loop;
  
    If Not b_Have Then
      Rs_Bill.Extend;
      n_Tmp := Rs_Bill.Count;
      Rs_Bill(n_Tmp).Key := Key_In;
      --取单据号
      Mn_Nosequence := Mn_Nosequence + 1;
      If 记帐_In Then
        Rs_Bill(n_Tmp).No := 14;
      Else
        Rs_Bill(n_Tmp).No := 13;
      End If;
      Rs_Bill(n_Tmp).No := Rs_Bill(n_Tmp).No || LPad(Mn_Nosequence, 4, '0');
      If 费用序号_In = -1 Then
        Rs_Bill(n_Tmp).费用序号 := 0;
      Else
        Rs_Bill(n_Tmp).费用序号 := 1;
      End If;
      If 发送序号_In = -1 Then
        Rs_Bill(n_Tmp).发送序号 := 0;
      Else
        Rs_Bill(n_Tmp).发送序号 := 1;
      End If;
    Else
      If 费用序号_In <> -1 Then
        Rs_Bill(n_Tmp).费用序号 := Rs_Bill(n_Tmp).费用序号 + 1;
      End If;
      If 发送序号_In <> -1 Then
        Rs_Bill(n_Tmp).发送序号 := Rs_Bill(n_Tmp).发送序号 + 1;
      End If;
    End If;
  
    No_Out := Rs_Bill(n_Tmp).No;
    If 费用序号_In <> -1 Then
      费用序号_Out := Rs_Bill(n_Tmp).费用序号;
    End If;
    If 发送序号_In <> -1 Then
      发送序号_Out := Rs_Bill(n_Tmp).发送序号;
    End If;
  
  End;
  --获取指定病人某天(dat收费时间)之后医嘱产生的费用项目明细
  Function f_Getpatidaymoneydetail
  (
    病人id_In   In Number,
    主页id_In   In Number,
    收费时间_In In Date
  ) Return Number Is
  
    Cursor c_Detail Is
      Select a.诊疗项目id, c.收费细目id As 收费项目id, c.执行部门id, Decode(Nvl(c.执行状态, 0), 0, 0, 1) As 执行否,
             To_Char(b.首次时间, 'yyyy-mm-dd') As 首次时间, Trunc(b.末次时间) - Trunc(b.首次时间) + 1 As 天数, 0 As 收费方式,
             To_Char(b.末次时间, 'yyyy-mm-dd') As 末次时间, a.频率间隔, a.间隔单位, a.医嘱期效, a.Id, Nvl(a.相关id, 0) As 相关id
      From 病人医嘱记录 A, 病人医嘱发送 B, 门诊费用记录 C
      Where a.病人id = 病人id_In And Nvl(a.主页id, 0) = 主页id_In And a.医嘱期效 = 1 And a.Id = b.医嘱id And b.记录性质 = c.记录性质 And
            b.No = c.No And b.医嘱id = c.医嘱序号 And c.记录状态 In (0, 1) And b.末次时间 >= 收费时间_In
      Union
      Select a.诊疗项目id, d.收费细目id, d.执行科室id As 执行部门id, 0 As 执行否, To_Char(b.首次时间, 'yyyy-mm-dd') As 首次时间,
             Trunc(b.末次时间) - Trunc(b.首次时间) + 1 As 天数, -1 As 收费方式, To_Char(b.末次时间, 'yyyy-mm-dd') As 末次时间, a.频率间隔, a.间隔单位,
             a.医嘱期效, a.Id, Nvl(a.相关id, 0) As 相关id
      From 病人医嘱记录 A, 病人医嘱发送 B, 病人医嘱计价 D
      Where a.病人id = 病人id_In And Nvl(a.主页id, 0) = 主页id_In And a.医嘱期效 = 1 And a.Id = b.医嘱id And b.末次时间 >= 收费时间_In And
            a.Id = d.医嘱id And d.收费方式 = 7 And Not Exists
       (Select 1
             From 门诊费用记录 C
             Where c.收费细目id = d.收费细目id And b.记录性质 = c.记录性质 And b.No = c.No And a.Id = c.医嘱序号)
      Order By 诊疗项目id, 收费项目id;
  
    d_Day Date;
  
    n_Tmp Number := 0;
    I     Number;
  
    n_诊疗项目id Number(18);
    n_收费项目id Number(18);
    n_执行部门id Number(18);
    n_执行否     Number(1);
    v_首次时间   Varchar2(18);
    n_天数       Number(3);
    n_收费方式   Number(1);
    v_末次时间   Varchar2(18);
    n_频率间隔   Number(18);
    v_间隔单位   Varchar2(18);
    n_医嘱期效   Number(1);
    n_Id         Number(18);
    n_相关id     Number(18);
  
    Procedure p_Addmoneydayitem Is
    Begin
      n_Tmp := 0;
      For I In 1 .. Rs_Moneyday.Count Loop
        If Rs_Moneyday(I)
         .诊疗项目id = n_诊疗项目id And Rs_Moneyday(I).收费项目id = n_收费项目id And Rs_Moneyday(I)
           .收费时间 = To_Char(d_Day, 'yyyy-MM-dd') And Rs_Moneyday(I).执行否 = n_执行否 And Rs_Moneyday(I).收费方式 = n_收费方式 Then
          n_Tmp := 1;
          Exit;
        End If;
      End Loop;
      If n_Tmp = 0 Then
        Rs_Moneyday.Extend;
        n_Tmp := Rs_Moneyday.Count;
        Rs_Moneyday(n_Tmp).诊疗项目id := n_诊疗项目id;
        Rs_Moneyday(n_Tmp).收费项目id := n_收费项目id;
        Rs_Moneyday(n_Tmp).执行部门id := n_执行部门id;
        Rs_Moneyday(n_Tmp).执行否 := n_执行否;
        Rs_Moneyday(n_Tmp).收费方式 := n_收费方式;
        Rs_Moneyday(n_Tmp).收费时间 := To_Char(d_Day, 'yyyy-MM-dd');
      End If;
    End;
  Begin
  
    Open c_Detail;
    Loop
      Fetch c_Detail
        Into n_诊疗项目id, n_收费项目id, n_执行部门id, n_执行否, v_首次时间, n_天数, n_收费方式, v_末次时间, n_频率间隔, v_间隔单位, n_医嘱期效, n_Id, n_相关id;
      Exit When c_Detail%NotFound;
      If n_频率间隔 = 1 And v_间隔单位 = '天' Or v_间隔单位 = '小时' Or v_间隔单位 = '分钟' Then
        For I In 1 .. n_天数 Loop
          If I = 1 Then
            d_Day := To_Date(v_首次时间, 'yyyy-MM-dd');
          Else
            d_Day := To_Date(v_首次时间, 'yyyy-MM-dd') + I - 1;
          End If;
          If d_Day >= 收费时间_In Then
            p_Addmoneydayitem;
          End If;
        End Loop;
      Else
        --对于临嘱这里可能会漏算
        d_Day := To_Date(v_首次时间, 'yyyy-MM-dd');
        If d_Day >= 收费时间_In Then
          p_Addmoneydayitem;
        End If;
        d_Day := To_Date(v_末次时间, 'yyyy-MM-dd');
        If d_Day >= 收费时间_In Then
          p_Addmoneydayitem;
        End If;
      End If;
    End Loop;
    Close c_Detail;
    Return(1);
  End;

  --根据管码获取对应的试管材料ID
  Function f_Gettubematerial(编码_In In 采血管类型.编码%Type) Return Number Is
    n_材料id 采血管类型.材料id%Type;
  Begin
    Select Max(材料id) Into n_材料id From 采血管类型 Where 编码 = 编码_In;
    Return(n_材料id);
  End;

  --判断指定的医嘱费用是否应该产生
  Function f_Advicemoneymake
  (
    病人id_In     In Number,
    医嘱id_In     In Number,
    诊疗项目id_In In Number,
    收费项目id_In In Number,
    执行部门id_In In Number,
    试管编码_In   In Varchar2,
    收费类别_In   In Varchar2,
    收费方式_In   In Number,
    分解时间_In   In Varchar2,
    总量_In       In Number,
    当前医嘱id_In In Number,
    发送号_In     In Number,
    计价数量_In   In Number,
    计算方式_In   In Number,
    频率_In       In Varchar2,
    单量_In       In Number,
    期效_In       In Number,
    费用性质_In   In Number,
    诊疗类别_In   In Varchar2,
    样本条码_In   In Varchar2,
    费用次数_Out  Out Number
  ) Return Number Is
  
    Type r_Days Is Record(
      收费时间 Varchar2(30),
      存在     Number(1));
    Type t_Days Is Table Of r_Days;
    Rsdays t_Days := t_Days();
  
    Arrtmp      t_Strlist := t_Strlist();
    n_Rtn       Number;
    n_Tmp       Number;
    b_Makemoney Boolean;
    n_材料id    Number;
    n_Cnt存在   Number;
    v_Tmp       Varchar2(30000);
  
    n_数量    Number := 0;
    v_Date    Varchar2(30);
    n_总量tmp Number := 0;
    n_单量tmp Number := 0;
    b_Tmp     Boolean;
  
  Begin
    b_Makemoney  := True;
    费用次数_Out := 1;
    n_Rtn        := 1;
  
    If 收费方式_In = 9 Then
      --自定义
      Null;
    End If;
  
    If 收费方式_In = 0 Then
      --正常收费的，检查在本次发送中、本医嘱中是否被排斥
      For I In 1 .. Rs_Moneynow.Count Loop
        If Rs_Moneynow(I).医嘱id = 医嘱id_In And Rs_Moneynow(I).诊疗项目id = 诊疗项目id_In And
            (Rs_Moneynow(I).收费方式 = 5 Or Rs_Moneynow(I).收费方式 = 6) Then
          b_Makemoney := False;
          Exit;
        End If;
      End Loop;
    Elsif 收费方式_In = 1 Then
      --检验试管费用(一次发送只收取一次)
      If 试管编码_In Is Not Null Then
        For I In 1 .. Rs_Moneynow.Count Loop
          If Rs_Moneynow(I).试管编码 = 试管编码_In And Rs_Moneynow(I).样本条码 = 样本条码_In And Rs_Moneynow(I).收费项目id = 收费项目id_In And
              Nvl(Rs_Moneynow(I).收费方式, 0) <> -1 Then
            b_Makemoney := False;
            Exit;
          End If;
        End Loop;
        --只收取试管对应的卫材费用
        If b_Makemoney And 收费类别_In = '4' Then
          n_材料id := f_Gettubematerial(试管编码_In);
          If n_材料id <> 0 And 收费项目id_In <> n_材料id Then
            b_Makemoney := False;
          End If;
        End If;
      End If;
    Elsif 收费方式_In = 2 Then
      --一次发送只收取一次
    
      For I In 1 .. Rs_Moneynow.Count Loop
        If Rs_Moneynow(I).诊疗项目id = 诊疗项目id_In And Rs_Moneynow(I).收费项目id = 收费项目id_In And Nvl(Rs_Moneynow(I).收费方式, 0) <> -1 Then
          b_Makemoney := False;
          Exit;
        End If;
      End Loop;
    Elsif Instr(',3,4,5,6,7,', 收费方式_In) > 0 Then
      --3-当天只收取一次；4-当天未执行收取一次；5-当天只收取一次，排斥其他项目；6-当天未执行收取一次，排斥其他项目
      --正常收费的，检查在本次发送中、本医嘱中是否被排斥
      If 收费方式_In = 7 Then
        For I In 1 .. Rs_Moneynow.Count Loop
          If Rs_Moneynow(I).医嘱id = 医嘱id_In And Rs_Moneynow(I).诊疗项目id = 诊疗项目id_In And
              (Rs_Moneynow(I).收费方式 = 5 Or Rs_Moneynow(I).收费方式 = 6) Then
            b_Makemoney := False;
            Exit;
          End If;
        End Loop;
      End If;
    
      If b_Makemoney Then
        v_Tmp := 分解时间_In;
        While v_Tmp Is Not Null Loop
          Rsdays.Extend;
          Rsdays(Rsdays.Count).收费时间 := Substr(v_Tmp, 1, 10);
          Rsdays(Rsdays.Count).存在 := 0;
          v_Tmp := Substr(v_Tmp, 21);
        End Loop;
        --先从本次发送中的找(频率为一天一次且没有收的，判断时当成已收取,以便后续的其他医嘱'首次不收'时不再认为有首次)
        For J In 1 .. Rsdays.Count Loop
          For I In 1 .. Rs_Moneynow.Count Loop
            If Rs_Moneynow(I)
             .收费时间 = Rsdays(J).收费时间 And Rs_Moneynow(I).诊疗项目id = 诊疗项目id_In And Rs_Moneynow(I).收费项目id = 收费项目id_In Then
            
              If 收费方式_In = 7 And Nvl(Rs_Moneynow(I).收费方式, 0) <> -1 Then
                Rsdays(I).存在 := 1;
                Exit;
              Elsif (收费方式_In = 4 Or 收费方式_In = 6) And Nvl(执行部门id_In, 0) <> 0 And Rs_Moneynow(I).执行部门id = 执行部门id_In Then
                Rsdays(I).存在 := 1;
                Exit;
              End If;
            End If;
          End Loop;
        End Loop;
      
        --再从已发送中的找(当天及将来执行的)
        n_Cnt存在 := 0;
        For J In 1 .. Rsdays.Count Loop
          If Rsdays(J).存在 = 0 Then
            n_Cnt存在 := n_Cnt存在 + 1;
            If Rs_Moneyday Is Null Then
              Rs_Moneyday := t_Moneyday();
              n_Tmp       := f_Getpatidaymoneydetail(病人id_In, 0, To_Date(Rsdays(J).收费时间, 'YYYY-MM-DD'));
            End If;
            For J In 1 .. Rsdays.Count Loop
              For I In 1 .. Rs_Moneyday.Count Loop
                If Rs_Moneyday(I)
                 .收费时间 = Rsdays(J).收费时间 And Rs_Moneyday(I).诊疗项目id = 诊疗项目id_In And Rs_Moneyday(I).收费项目id = 收费项目id_In Then
                
                  If 收费方式_In = 7 And Nvl(Rs_Moneyday(I).收费方式, 0) <> -1 Then
                    Rsdays(J).存在 := 1;
                    n_Cnt存在 := n_Cnt存在 - 1;
                    Exit;
                  Elsif (收费方式_In = 4 Or 收费方式_In = 6) And Nvl(执行部门id_In, 0) <> 0 And Rs_Moneyday(I).执行部门id = 执行部门id_In Then
                    Rsdays(J).存在 := 1;
                    n_Cnt存在 := n_Cnt存在 - 1;
                    Exit;
                  Else
                    Rsdays(J).存在 := 1;
                    n_Cnt存在 := n_Cnt存在 - 1;
                    Exit;
                  End If;
                End If;
              End Loop;
            End Loop;
          End If;
        End Loop;
      End If;
    End If;
    --记录到本次发送明细项目记录中
    If Instr(',3,4,5,6,7,', 收费方式_In) > 0 Then
      If 收费方式_In = 7 Then
        If b_Makemoney Then
          --rsDays.Filter = '存在=0' n_Cnt存在 代替   --没收过的那些天(频率为一天一次但未收的当成收过了)，首次不收
          费用次数_Out := 总量_In - n_Cnt存在;
          If 费用次数_Out > 0 Then
            b_Makemoney := True;
          Else
            b_Makemoney := False;
          End If;
        End If;
      Else
        -- rsDays.Filter = '存在=0'
        -- B_makemoney = rsDays.RecordCount > 0
        -- lng费用次数 = rsDays.RecordCount    --一天一次，有多少天要收就有多少次
        费用次数_Out := n_Cnt存在;
        If n_Cnt存在 > 0 Then
          b_Makemoney := True;
        Else
          b_Makemoney := False;
        End If;
        Null;
      End If;
      If b_Makemoney Or 收费方式_In = 7 And 费用次数_Out = 0 Then
        For I In 1 .. Rsdays.Count Loop
          If Rsdays(I).存在 = 0 Then
            Rs_Moneynow.Extend;
            n_Tmp := Rs_Moneynow.Count;
            Rs_Moneynow(n_Tmp).医嘱id := 医嘱id_In;
            Rs_Moneynow(n_Tmp).诊疗项目id := 诊疗项目id_In;
            Rs_Moneynow(n_Tmp).收费项目id := 收费项目id_In;
            Rs_Moneynow(n_Tmp).试管编码 := 试管编码_In;
            Rs_Moneynow(n_Tmp).样本条码 := 样本条码_In;
          
            --首次不收时，如果频率为一天一次，则计算后的费用次数为0,为了让本次后续发送的其他医嘱正确计算首是否收取，需要产生记录，但收费方式特殊记录为-1
            -- rs_MoneyNow(n_tmp).收费方式 := IIF(收费方式_In := 7 And lng费用次数 := 0, -1, 收费方式_In)
            If 收费方式_In = 7 And 费用次数_Out = 0 Then
              Rs_Moneynow(n_Tmp).收费方式 := -1;
            Else
              Rs_Moneynow(n_Tmp).收费方式 := 收费方式_In;
            End If;
            Rs_Moneynow(n_Tmp).收费时间 := Rsdays(I).收费时间;
            Rs_Moneynow(n_Tmp).执行部门id := 执行部门id_In;
          End If;
        End Loop;
      End If;
    Elsif b_Makemoney Then
      Rs_Moneynow.Extend;
      n_Tmp := Rs_Moneynow.Count;
      Rs_Moneynow(n_Tmp).医嘱id := 医嘱id_In;
      Rs_Moneynow(n_Tmp).诊疗项目id := 诊疗项目id_In;
      Rs_Moneynow(n_Tmp).收费项目id := 收费项目id_In;
      Rs_Moneynow(n_Tmp).试管编码 := 试管编码_In;
      Rs_Moneynow(n_Tmp).样本条码 := 样本条码_In;
      Rs_Moneynow(n_Tmp).收费方式 := 收费方式_In;
      If 分解时间_In Is Null Then
        Rs_Moneynow(n_Tmp).收费时间 := Substr(分解时间_In, 1, 10); --yyyy-MM-dd
      Else
        Rs_Moneynow(n_Tmp).收费时间 := Null;
      End If;
      Rs_Moneynow(n_Tmp).执行部门id := 执行部门id_In;
    End If;
  
    --读取医嘱执行计价(除药品卫材医嘱外的才存储)
    If Instr(',5,6,7,', ',' || 诊疗类别_In || ',') = 0 Then
      If 分解时间_In Is Not Null Then
        -- arrTmp = Split(分解时间_In, ',');
        v_Tmp := 分解时间_In;
        While v_Tmp Is Not Null Loop
          Arrtmp.Extend;
          Arrtmp(Arrtmp.Count) := Substr(v_Tmp, 1, 19);
          v_Tmp := Substr(v_Tmp, 21);
        End Loop;
      
        n_总量tmp := 总量_In * 计价数量_In;
        n_单量tmp := 单量_In;
        If 单量_In = 0 Then
          n_单量tmp := 1;
        End If;
        For I In 1 .. Arrtmp.Count Loop
          Rs_Exec.Extend;
          n_Tmp := Rs_Exec.Count;
          Rs_Exec(n_Tmp).医嘱id := 当前医嘱id_In;
          Rs_Exec(n_Tmp).发送号 := 发送号_In;
          Rs_Exec(n_Tmp).要求时间 := Arrtmp(I);
          Rs_Exec(n_Tmp).收费细目id := 收费项目id_In;
          Rs_Exec(n_Tmp).费用性质 := 费用性质_In;
          If b_Makemoney Then
            --卫材也可以输入单量总量
            If 频率_In Is Not Null And
               ((计算方式_In = 0 Or 计算方式_In = 3) And 总量_In > 0 Or 计算方式_In = 1 Or 计算方式_In = 2 Or 诊疗类别_In = '4') Then
              --计量和计时的需要乘以数次
              If 期效_In = 0 Then
                --1、长嘱可选频率、持续性、必要时和不定时以单量作为数次。
                n_数量 := 计价数量_In * n_单量tmp;
              Else
                --3、临嘱可选频率取单量作为数次，最后一次剩余的数量，例如红外照射治疗，总量80、单量25，每天4次，那么执行登记时，供执行四次，前三次本次数次为25，第四次为80除以25取模=5。
                --门诊有可能没有录入执行时间,分解时间就只有一个，按总量作为次数
                If Arrtmp.Count = 1 Then
                  n_数量 := 计价数量_In * 总量_In;
                Else
                  If I = Arrtmp.Count Then
                    n_数量 := n_总量tmp;
                  Else
                    If n_总量tmp >= n_单量tmp Then
                      n_数量 := 计价数量_In * n_单量tmp;
                    Else
                      n_数量 := n_总量tmp;
                    End If;
                    n_总量tmp := n_总量tmp - n_数量;
                  End If;
                End If;
              End If;
            Else
              n_数量 := 计价数量_In;
            End If;
            If I <> 1 Then
              v_Date := Substr(Arrtmp(I - 1), 1, 10);
            End If;
            --一次发送收取一次，则只有第一次收取
            If Instr(',1,2,', 收费方式_In) > 0 Then
              If I <> 1 Then
                n_数量 := 0;
              End If;
            Elsif Instr(',3,4,5,6,', 收费方式_In) > 0 Then
              --3456当天只收取一次的，存在=0的收取，默认第一次有数量
              -- rsDays.Filter = '存在=0 And 收费时间=--' || Format(arrTmp(i), 'yyyy-MM-dd') || '--'
              b_Tmp := False;
              For J In 1 .. Rsdays.Count Loop
                If Rsdays(J).存在 = 0 And Rsdays(J).收费时间 = Substr(Arrtmp(I), 1, 10) Then
                  b_Tmp := True;
                End If;
              End Loop;
              If Not (b_Tmp And Substr(Arrtmp(I), 1, 10) <> v_Date) Then
                n_数量 := 0;
              End If;
            Elsif 收费方式_In = 7 Then
              --当天首次不收取的，存在=1就收取，存在=0的为首次
              --  rsDays.Filter = '存在=1 And 收费时间=--' || Format(arrTmp(i), 'yyyy-MM-dd') || '--'
              b_Tmp := False;
              For J In 1 .. Rsdays.Count Loop
                If Rsdays(J).存在 = 1 And Rsdays(J).收费时间 = Substr(Arrtmp(I), 1, 10) Then
                  b_Tmp := True;
                End If;
              End Loop;
              If Not b_Tmp And Substr(Arrtmp(I), 1, 10) <> v_Date Then
                n_数量 := 0;
              End If;
            End If;
          Else
            --如果不收取，则设置为0
            n_数量 := 0;
          End If;
          Rs_Exec(n_Tmp).数量 := n_数量;
        End Loop;
      End If;
    End If;
    If b_Makemoney Then
      n_Rtn := 1;
    Else
      n_Rtn := 0;
    End If;
    Return(n_Rtn);
  End;

  --获取非药收费项目的执行科室
  Function f_Get收费执行科室id Return Number Is
  Begin
    Return(0);
  End;

  --对检验医嘱生成样本条码
  Function f_Getcuvettenumber
  (
    管码_In       In Varchar2,
    医嘱id_In     In Number,
    相关id_In     In Number,
    类别_In       In Varchar2,
    操作类型_In   In 诊疗项目目录.操作类型%Type,
    执行科室id_In In Number,
    婴儿_In       In Number,
    诊疗项目id_In In Number,
    紧急_In       In Number,
    标本_In       In Varchar2,
    采集科室id_In In Number
  ) Return Varchar2 Is
    v_Tmp管码 Varchar2(300);
    v_Tmp条码 Varchar2(300);
    b_无数据  Boolean := False;
    I         Number;
    n_Tmp     Number;
    --检验医嘱才会有条码，采集行和检验行同用一个条码  检验项目--诊疗项目id
  Begin
    If 类别_In = 'C' And 管码_In Is Not Null Then
      --检验项目才有管码
      b_无数据 := True;
      For I In 1 .. Rs_Number.Count Loop
        If Rs_Number(I).相关id = 相关id_In Then
          b_无数据 := False;
          n_Tmp    := I;
          Exit;
        End If;
      End Loop;
      If b_无数据 Then
        For I In 1 .. Rs_Number.Count Loop
          If Rs_Number(I).诊疗项目id = 诊疗项目id_In Then
            b_无数据 := False;
            n_Tmp    := I;
            Exit;
          End If;
        End Loop;
      
        If b_无数据 Then
          For I In 1 .. Rs_Number.Count Loop
            If Rs_Number(I).管码 = 管码_In And Rs_Number(I).执行科室id = 执行科室id_In And Rs_Number(I).婴儿 = 婴儿_In And Rs_Number(I)
               .紧急标志 = 紧急_In And Rs_Number(I).标本 = 标本_In And Rs_Number(I).采集科室id = 采集科室id_In Then
              b_无数据 := False;
              n_Tmp    := I;
              Exit;
            End If;
          End Loop;
        
          If b_无数据 Then
            --生成新的条码
            Rs_Number.Extend;
            n_Tmp := Rs_Number.Count;
            Rs_Number(n_Tmp).管码 := 管码_In;
            Rs_Number(n_Tmp).相关id := 相关id_In;
            Rs_Number(n_Tmp).样本条码 := Nextno(125, 医嘱id_In, 诊疗项目id_In, 1);
            Rs_Number(n_Tmp).诊疗项目id := 诊疗项目id_In;
            Rs_Number(n_Tmp).执行科室id := 执行科室id_In;
            Rs_Number(n_Tmp).婴儿 := 婴儿_In;
            Rs_Number(n_Tmp).紧急标志 := 紧急_In;
            Rs_Number(n_Tmp).标本 := 标本_In;
            Rs_Number(n_Tmp).采集科室id := 采集科室id_In;
            v_Tmp条码 := Rs_Number(n_Tmp).样本条码;
          Else
            --相同管码、执行科室、婴儿的检验使用相同的样本条码
            v_Tmp管码 := Rs_Number(n_Tmp).管码;
            v_Tmp条码 := Rs_Number(n_Tmp).样本条码;
            Rs_Number.Extend;
            n_Tmp := Rs_Number.Count;
            Rs_Number(n_Tmp).管码 := v_Tmp管码;
            Rs_Number(n_Tmp).相关id := 相关id_In;
            Rs_Number(n_Tmp).样本条码 := v_Tmp条码;
            Rs_Number(n_Tmp).诊疗项目id := 诊疗项目id_In;
            Rs_Number(n_Tmp).执行科室id := 执行科室id_In;
            Rs_Number(n_Tmp).婴儿 := 婴儿_In;
            Rs_Number(n_Tmp).紧急标志 := 紧急_In;
            Rs_Number(n_Tmp).标本 := 标本_In;
            Rs_Number(n_Tmp).采集科室id := 采集科室id_In;
          End If;
        Else
          --生成新的条码：相同检验的医嘱使用'不同的'条码
          Rs_Number.Extend;
          n_Tmp := Rs_Number.Count;
          Rs_Number(n_Tmp).管码 := 管码_In;
          Rs_Number(n_Tmp).相关id := 相关id_In;
          Rs_Number(n_Tmp).样本条码 := Nextno(125, 医嘱id_In, 诊疗项目id_In, 1);
          Rs_Number(n_Tmp).诊疗项目id := 诊疗项目id_In;
          Rs_Number(n_Tmp).执行科室id := 执行科室id_In;
          Rs_Number(n_Tmp).婴儿 := 婴儿_In;
          Rs_Number(n_Tmp).紧急标志 := 紧急_In;
          Rs_Number(n_Tmp).标本 := 标本_In;
          Rs_Number(n_Tmp).采集科室id := 采集科室id_In;
          v_Tmp条码 := Rs_Number(n_Tmp).样本条码;
        End If;
      Else
        --一并采集的检验项目使用相同的条码
        v_Tmp管码 := Rs_Number(n_Tmp).管码;
        v_Tmp条码 := Rs_Number(n_Tmp).样本条码;
        Rs_Number.Extend;
        n_Tmp := Rs_Number.Count;
        Rs_Number(n_Tmp).管码 := v_Tmp管码;
        Rs_Number(n_Tmp).相关id := 相关id_In;
        Rs_Number(n_Tmp).样本条码 := v_Tmp条码;
        Rs_Number(n_Tmp).诊疗项目id := 诊疗项目id_In;
        Rs_Number(n_Tmp).执行科室id := 执行科室id_In;
        Rs_Number(n_Tmp).婴儿 := 婴儿_In;
        Rs_Number(n_Tmp).紧急标志 := 紧急_In;
        Rs_Number(n_Tmp).标本 := 标本_In;
        Rs_Number(n_Tmp).采集科室id := 采集科室id_In;
      End If;
    Elsif 类别_In = 'E' And 操作类型_In = '6' Then
      --采集方式使用与医嘱相同(最近)的条码
      I := Rs_Number.Count;
      If I > 0 Then
        If Nvl(Rs_Number(I).相关id, 0) = 医嘱id_In Then
          v_Tmp条码 := Rs_Number(I).样本条码;
        End If;
      End If;
    End If;
    Return(v_Tmp条码);
  End;

  --获取诊疗项目对应的诊疗单据
  Function f_Getclinicbillid(项目id_In In 诊疗项目目录.Id%Type) Return Number Is
    n_Tmp Number(18);
  Begin
    Select Max(病历文件id) Into n_Tmp From 病历单据应用 Where 诊疗项目id = 项目id_In;
    n_Tmp := Nvl(n_Tmp, 0);
    Return(n_Tmp);
  End;

  --一并给的第一个药品的执行科室
  Function f_Getmergedrugstore(Row_In In Number) Return Number Is
    n_药房id 部门表.Id%Type := 0;
    n_Begin  Number := 0;
  Begin
    If Nvl(Vsadvice(Row_In).相关id, 0) <> Nvl(Vsadvice(Row_In - 1).相关id, 0) And Nvl(Vsadvice(Row_In).执行科室id, 0) <> 0 Then
      n_药房id := Nvl(Vsadvice(Row_In).执行科室id, 0);
    Else
      For I In 1 .. Row_In - 1 Loop
        If Nvl(Vsadvice(Row_In).相关id, 0) = Nvl(Vsadvice(I).相关id, 0) Then
          If Nvl(Vsadvice(I).执行科室id, 0) <> 0 Then
            n_药房id := Nvl(Vsadvice(I).执行科室id, 0);
            Exit;
          End If;
        Else
          Exit;
        End If;
      End Loop;
      For I In n_Begin .. Vsadvice.Count Loop
        If Nvl(Vsadvice(Row_In).相关id, 0) <> Nvl(Vsadvice(I).相关id, 0) Then
          n_Begin := I;
          Exit;
        End If;
      End Loop;
    End If;
    Return(n_药房id);
  End;

  --根据收费细目ID或收入项目ID(前者优先),应收金额,按费别设置的分段比例打折规则计算实收金额
  Function f_Actualmoney
  (
    费别_In       In Varchar2,
    收入项目id_In In Number,
    应收金额_In   In Number,
    收费细目id_In In Number,
    库房id_In     In Number,
    数量_In       In Number,
    加班加价率_In In Number,
    费别_Out      Out Varchar2
  ) Return Number Is
    n_金额 病人医嘱计价.单价%Type := 0;
    v_Tmp  Varchar2(80);
  Begin
    Select Zl_Actualmoney(费别_In, 收费细目id_In, 收入项目id_In, (应收金额_In / (1 + 加班加价率_In)), 数量_In, 库房id_In) As Actualmoney
    Into v_Tmp
    From Dual;
    费别_Out := Substr(v_Tmp, 1, Instr(v_Tmp, ':') - 1);
    n_金额   := To_Number(Substr(v_Tmp, Instr(v_Tmp, ':') + 1));
    Return(n_金额);
  End;

  --时价单计算,仅用门诊
  Function f_Calcdrugprice
  (
    药品id_In In Number,
    药房id_In In Number,
    数量_In   In Number,
    费别_In   In Varchar2
  ) Return Number Is
    n_时价   病人医嘱计价.单价%Type := 0;
    n_总数量 病人医嘱计价.单价%Type := 0;
    v_Tmp    Varchar2(80);
    v_费别   Varchar2(800);
  Begin
    Select Zl_Fun_Getprice(药品id_In, 药房id_In, 数量_In, 0, Null) As 结果 Into v_Tmp From Dual;
    If v_Tmp Is Not Null Then
      v_Tmp    := v_Tmp || '|';
      n_时价   := To_Number(Substr(v_Tmp, 1, Instr(v_Tmp, '|') - 1));
      v_Tmp    := Substr(v_Tmp, Instr(v_Tmp, '|') + 1);
      n_总数量 := To_Number(Substr(v_Tmp, 1, Instr(v_Tmp, '|') - 1));
    End If;
    If n_总数量 = 0 And 费别_In Is Not Null Then
      n_时价 := Round(n_时价 * 数量_In, Gn_Dec);
      For R In (Select a.屏蔽费别, b.收入项目id
                From 收费项目目录 A, 收费价目 B
                Where a.Id = b.收费细目id And a.Id = 药品id_In And
                      ((Sysdate Between b.执行日期 And b.终止日期) Or (Sysdate >= b.执行日期 And b.终止日期 Is Null))) Loop
        If Not (Nvl(r.屏蔽费别, 0) = 1) Then
          v_费别 := 费别_In;
          If Gv_动态费别 Is Not Null Then
            v_费别 := v_费别 || ',' || Gv_动态费别;
          End If;
          n_时价 := f_Actualmoney(v_费别, r.收入项目id, n_时价, 药品id_In, 药房id_In, 数量_In, 0, v_Tmp);
        End If;
      End Loop;
    End If;
    Return(n_时价);
  End;

  --获取收费细目的当前售价价格金额
  Function f_Calcprice
  (
    项目id_In     In 收费项目目录.Id%Type,
    费别_In       In Varchar2,
    数量_In       In 诊疗收费关系.收费数量%Type,
    加班加价_In   In Boolean,
    n_执行科室id  In 部门表.Id%Type,
    卫材医嘱id_In In 病人医嘱记录.Id%Type
  ) Return Number Is
    n_单价 病人医嘱计价.单价%Type := 0;
    n_金额 病人医嘱计价.单价%Type := 0;
    v_Tmp  Varchar2(20);
    v_费别 Varchar2(20);
    n_加率 Number;
  Begin
  
    If 卫材医嘱id_In > 0 Then
      For R In (Select 单价 From 病人医嘱计价 Where 医嘱id = 卫材医嘱id_In And 收费细目id = 项目id_In) Loop
        n_单价 := r.单价;
        Exit;
      End Loop;
    End If;
  
    If 费别_In Is Null Then
      If (Not 加班加价_In) And Gb_加班加价 Then
        Select Sum(Decode(Nvl(a.是否变价, 0), 1, Decode(n_单价, 0, b.缺省价格, n_单价), b.现价) *
                    Decode(a.加班加价, 1, 1 + Nvl(b.加班加价率, 0) / 100, 1)) As 金额
        Into n_金额
        From 收费项目目录 A, 收费价目 B
        Where a.Id = b.收费细目id And a.Id = 项目id_In And
              ((Sysdate Between b.执行日期 And b.终止日期) Or (Sysdate >= b.执行日期 And b.终止日期 Is Null));
      Else
        Select Sum(Decode(Nvl(a.是否变价, 0), 1, Decode(n_单价, 0, b.缺省价格, n_单价), b.现价)) As 金额
        Into n_金额
        From 收费项目目录 A, 收费价目 B
        Where a.Id = b.收费细目id And a.Id = 项目id_In And
              ((Sysdate Between b.执行日期 And b.终止日期) Or (Sysdate >= b.执行日期 And b.终止日期 Is Null));
      
      End If;
    Else
      If (Not 加班加价_In) And Gb_加班加价 Then
        For R In (Select a.屏蔽费别, a.加班加价, b.加班加价率, b.收入项目id,
                         Decode(Nvl(a.是否变价, 0), 1, Decode(n_单价, 0, b.缺省价格, n_单价), b.现价) *
                          Decode(a.加班加价, 1, 1 + Nvl(b.加班加价率, 0) / 100, 1) As 金额
                  From 收费项目目录 A, 收费价目 B
                  Where a.Id = b.收费细目id And a.Id = 项目id_In And
                        ((Sysdate Between b.执行日期 And b.终止日期) Or (Sysdate >= b.执行日期 And b.终止日期 Is Null))) Loop
          If Nvl(r.屏蔽费别, 0) = 1 Then
            n_金额 := n_金额 + Round(数量_In * Nvl(r.金额, 0), Gn_Dec);
          Else
            v_费别 := 费别_In;
            If Gv_动态费别 Is Not Null Then
              v_费别 := v_费别 || ',' || Gv_动态费别;
            End If;
            n_加率 := 0;
            If (Not 加班加价_In) And Gb_加班加价 And Nvl(r.加班加价, 0) = 1 Then
              n_加率 := Nvl(r.加班加价率, 0) / 100;
              Null;
            End If;
            n_金额 := n_金额 + f_Actualmoney(v_费别, r.收入项目id, 数量_In * Nvl(r.金额, 0), 项目id_In, n_执行科室id, 数量_In, n_加率, v_Tmp);
          End If;
        End Loop;
      Else
        For R In (Select a.屏蔽费别, a.加班加价, b.加班加价率, b.收入项目id,
                         Decode(Nvl(a.是否变价, 0), 1, Decode(n_单价, 0, b.缺省价格, n_单价), b.现价) As 金额
                  From 收费项目目录 A, 收费价目 B
                  Where a.Id = b.收费细目id And a.Id = 项目id_In And
                        ((Sysdate Between b.执行日期 And b.终止日期) Or (Sysdate >= b.执行日期 And b.终止日期 Is Null))) Loop
          If Nvl(r.屏蔽费别, 0) = 1 Then
            n_金额 := n_金额 + Round(数量_In * Nvl(r.金额, 0), Gn_Dec);
          Else
            v_费别 := 费别_In;
            If Gv_动态费别 Is Not Null Then
              v_费别 := v_费别 || ',' || Gv_动态费别;
            End If;
            n_加率 := 0;
            If (Not 加班加价_In) And Gb_加班加价 And Nvl(r.加班加价, 0) = 1 Then
              n_加率 := Nvl(r.加班加价率, 0) / 100;
              Null;
            End If;
            n_金额 := n_金额 + f_Actualmoney(v_费别, r.收入项目id, 数量_In * Nvl(r.金额, 0), 项目id_In, n_执行科室id, 数量_In, n_加率, v_Tmp);
          End If;
        End Loop;
      End If;
    End If;
    Return(n_金额);
  End;

  --将医嘱执行的分解时间按次数进行截断
  Function f_Trim分解时间
  (
    次数_In In Number,
    v_分解  Varchar2
  ) Return Varchar2 Is
    v_Result Varchar2(4000);
    v_Tmp    Varchar2(4000);
  Begin
    v_Tmp := v_分解;
    For I In 1 .. 次数_In Loop
      v_Result := v_Result || ',' || Substr(v_Tmp, 1, 19);
      v_Tmp    := Substr(v_Tmp, Instr(v_Tmp, ',') + 1);
    End Loop;
    v_Result := Substr(v_Result, 2);
    Return(v_Result);
  End;

  --大于指定数的整数
  Function f_Intex(Num_In In Number) Return Number Is
    n_Num Number;
  Begin
    Select Round(Num_In) Into n_Num From Dual;
    If Num_In > n_Num Then
      n_Num := n_Num + 1;
    End If;
    Return(n_Num);
  End;

  --分解时间
  Function f_Calc次数分解时间
  (
    次数_In     In 病人医嘱记录.总给予量%Type,
    开始时间_In In Date,
    终止时间_In In Date,
    执行时间_In In 病人医嘱记录.执行时间方案%Type,
    频率间隔_In In 病人医嘱记录.频率间隔%Type,
    间隔单位_In In 病人医嘱记录.间隔单位%Type
  ) Return Varchar2 Is
    v_Detailtime Varchar2(4000);
    n_First      Number(1);
    v_First      病人医嘱记录.执行时间方案%Type;
    v_Normal     病人医嘱记录.执行时间方案%Type;
    v_Mtime      Varchar(100);
    v_Rtime      Varchar(100);
    v_Curtime    Date;
    v_Tmptime    Date;
    n_Cnt        Number; --计数器
    --求某时间所在周的星期一的日期
    Function Getweekbase(v_Time Date) Return Date Is
      v_Week Number(1);
    Begin
      v_Week := To_Number(To_Char(v_Time, 'D'));
      v_Week := v_Week - 1;
      If v_Week = 0 Then
        v_Week := 7;
      End If;
      Return(Trunc(v_Time - (v_Week - 1)));
    End;
  Begin
  
    n_Cnt := 0;
  
    --执行时间方案基准
    If Nvl(Instr(执行时间_In, ','), 0) > 0 Then
      v_First  := Substr(执行时间_In, 1, Instr(执行时间_In, ',') - 1);
      v_Normal := Substr(执行时间_In, Instr(执行时间_In, ',') + 1);
    Else
      v_First  := Null;
      v_Normal := 执行时间_In;
    End If;
  
    If 间隔单位_In = '周' Then
      v_Curtime := Getweekbase(开始时间_In); --按周执行时在医嘱开始那周的星期一作为基准
    Else
      v_Curtime := 开始时间_In;
    End If;
    If 间隔单位_In = '周' Then
      If v_First Is Not Null Then
        If v_Curtime = Getweekbase(开始时间_In) Then
          n_First := 1;
        End If;
      End If;
      While v_Curtime <= 终止时间_In And n_Cnt < 次数_In Loop
        If Nvl(n_First, 0) = 1 Then
          v_Rtime := v_First || '-';
        Else
          v_Rtime := v_Normal || '-';
        End If;
        n_First := 0;
        --1/8:00-3/8:00-5/8:00
        While v_Rtime Is Not Null Loop
          v_Mtime   := Substr(v_Rtime, 1, Instr(v_Rtime, '-') - 1);
          v_Tmptime := v_Curtime + To_Number(Substr(v_Mtime, 1, Instr(v_Mtime, '/') - 1)) - 1;
          v_Mtime   := Substr(v_Mtime, Instr(v_Mtime, '/') + 1);
          If Instr(v_Mtime, ':') = 0 Then
            v_Mtime := v_Mtime || ':00';
          End If;
          v_Tmptime := Trunc(v_Tmptime) + (To_Date(v_Mtime, 'HH24:MI:SS') - Trunc(To_Date(v_Mtime, 'HH24:MI:SS')));
          If v_Tmptime >= 开始时间_In And v_Tmptime <= 终止时间_In Then
            v_Detailtime := v_Detailtime || ',' || To_Char(v_Tmptime, 'YYYY-MM-DD HH24:MI:SS');
            n_Cnt        := n_Cnt + 1;
            If n_Cnt >= 次数_In Then
              Exit;
            End If;
          Elsif v_Tmptime > 终止时间_In Then
            Exit;
          End If;
          v_Rtime := Substr(v_Rtime, Instr(v_Rtime, '-') + 1);
        End Loop;
        v_Curtime := Trunc(v_Curtime + 7);
      End Loop;
    Elsif 间隔单位_In = '天' Then
      If v_First Is Not Null Then
        If Trunc(开始时间_In) = Trunc(开始时间_In) Then
          n_First := 1;
        End If;
      End If;
      While v_Curtime <= 终止时间_In And n_Cnt < 次数_In Loop
        If Nvl(n_First, 0) = 1 Then
          v_Rtime := v_First || '-';
        Else
          v_Rtime := v_Normal || '-';
        End If;
        n_First := 0;
        If 频率间隔_In = 1 Then
          --8:00-12:00-14:00；8-12-14
          While v_Rtime Is Not Null Loop
            v_Mtime := Substr(v_Rtime, 1, Instr(v_Rtime, '-') - 1);
            If Instr(v_Mtime, ':') = 0 Then
              v_Mtime := v_Mtime || ':00';
            End If;
            v_Tmptime := Trunc(v_Curtime) + (To_Date(v_Mtime, 'HH24:MI:SS') - Trunc(To_Date(v_Mtime, 'HH24:MI:SS')));
            If v_Tmptime >= 开始时间_In And v_Tmptime <= 终止时间_In Then
            
              v_Detailtime := v_Detailtime || ',' || To_Char(v_Tmptime, 'YYYY-MM-DD HH24:MI:SS');
              n_Cnt        := n_Cnt + 1;
              If n_Cnt >= 次数_In Then
                Exit;
              
              End If;
            Elsif v_Tmptime > 终止时间_In Then
              Exit;
            End If;
            v_Rtime := Substr(v_Rtime, Instr(v_Rtime, '-') + 1);
          End Loop;
        Else
          --1/8:00-1/15:00-2/9:00
          While v_Rtime Is Not Null Loop
            v_Mtime   := Substr(v_Rtime, 1, Instr(v_Rtime, '-') - 1);
            v_Tmptime := v_Curtime + To_Number(Substr(v_Mtime, 1, Instr(v_Mtime, '/') - 1)) - 1;
            v_Mtime   := Substr(v_Mtime, Instr(v_Mtime, '/') + 1);
            If Instr(v_Mtime, ':') = 0 Then
              v_Mtime := v_Mtime || ':00';
            End If;
            v_Tmptime := Trunc(v_Tmptime) + (To_Date(v_Mtime, 'HH24:MI:SS') - Trunc(To_Date(v_Mtime, 'HH24:MI:SS')));
            If v_Tmptime >= 开始时间_In And v_Tmptime <= 终止时间_In Then
            
              v_Detailtime := v_Detailtime || ',' || To_Char(v_Tmptime, 'YYYY-MM-DD HH24:MI:SS');
              n_Cnt        := n_Cnt + 1;
              If n_Cnt >= 次数_In Then
                Exit;
              
              End If;
            Elsif v_Tmptime > 终止时间_In Then
              Exit;
            End If;
            v_Rtime := Substr(v_Rtime, Instr(v_Rtime, '-') + 1);
          End Loop;
        End If;
        v_Curtime := Trunc(v_Curtime + 频率间隔_In); --因为Loop条件注意要取整
      End Loop;
    Elsif 间隔单位_In = '小时' Then
      --10:00-20:00-40:00；10-20-40；02:30
      While v_Curtime <= 终止时间_In And n_Cnt < 次数_In Loop
      
        v_Rtime := 执行时间_In || '-';
        While v_Rtime Is Not Null Loop
          v_Mtime := Substr(v_Rtime, 1, Instr(v_Rtime, '-') - 1);
          If Instr(v_Mtime, ':') = 0 Then
            v_Tmptime := v_Curtime + (To_Number(v_Mtime) - 1) / 24;
          Else
            v_Tmptime := v_Curtime + (To_Number(Substr(v_Mtime, 1, Instr(v_Mtime, ':') - 1)) - 1) / 24 +
                         To_Number(Substr(v_Mtime, Instr(v_Mtime, ':') + 1)) / 60 / 24;
          End If;
        
          If v_Tmptime >= 开始时间_In And v_Tmptime <= 终止时间_In Then
          
            v_Detailtime := v_Detailtime || ',' || To_Char(v_Tmptime, 'YYYY-MM-DD HH24:MI:SS');
            n_Cnt        := n_Cnt + 1;
            If n_Cnt >= 次数_In Then
              Exit;
            End If;
          
          Elsif v_Tmptime > 终止时间_In Then
            Exit;
          End If;
          v_Rtime := Substr(v_Rtime, Instr(v_Rtime, '-') + 1);
        End Loop;
        v_Curtime := v_Curtime + 频率间隔_In / 24;
      End Loop;
    Elsif 间隔单位_In = '分钟' Then
      --无执行时间
      While v_Curtime <= 终止时间_In And n_Cnt < 次数_In Loop
        v_Tmptime := v_Curtime;
        If v_Tmptime >= 开始时间_In And v_Tmptime <= 终止时间_In Then
          v_Detailtime := v_Detailtime || ',' || To_Char(v_Tmptime, 'YYYY-MM-DD HH24:MI:SS');
          n_Cnt        := n_Cnt + 1;
          If n_Cnt >= 次数_In Then
            Exit;
          End If;
        Elsif v_Tmptime > 终止时间_In Then
          Exit;
        End If;
        v_Curtime := v_Curtime + 频率间隔_In / (24 * 60);
      End Loop;
    End If;
    If v_Detailtime Is Not Null Then
      v_Detailtime := Substr(v_Detailtime, 2);
    End If;
    Return(v_Detailtime);
  End;

  --库存
  Function f_库存
  (
    药品id_In In 病人挂号记录.病人id%Type,
    库房id_In In 药品库存.库房id%Type
  ) Return Number Is
    n_库存 药品库存.可用数量%Type := 0;
  Begin
    Select Nvl(Sum(a.可用数量), 0) / Nvl(b.门诊包装, 1) As 库存
    Into n_库存
    From 药品库存 A, 药品规格 B
    Where a.药品id = b.药品id(+) And a.性质 = 1 And (Nvl(a.批次, 0) = 0 Or a.效期 Is Null Or a.效期 > Trunc(Sysdate)) And
          a.药品id = 药品id_In And a.库房id = 库房id_In
    Group By Nvl(b.门诊包装, 1), a.库房id;
    Return(n_库存);
  End;

  Function f_Main
  (
    站点_In       In 部门表.站点%Type,
    挂号id_In     In 病人挂号记录.病人id%Type,
    病人id_In     In 病人挂号记录.病人id%Type,
    医嘱ids_In    In Varchar2,
    加班加价_In   In Number,
    操作员编号_In In 人员表.编号%Type,
    操作员姓名_In In 人员表.姓名%Type
  ) Return Number Is
  Begin
    Mn_病人id  := 病人id_In;
    Mn_挂号id  := 挂号id_In;
    Mv_医嘱ids := 医嘱ids_In;
    Gv_Nodeno  := 站点_In;
    If 加班加价_In = 1 Then
      Gb_加班加价 := True;
    Else
      Gb_加班加价 := False;
    End If;
    Mv_操作员编号 := 操作员编号_In;
    Mv_操作员姓名 := 操作员姓名_In;
    Return(1);
  Exception
    When Others Then
      p_Errcenter(SQLErrM);
      Return(0);
  End;

  --读取参数相关
  Procedure p_Load Is
    n_Tmp Number := 0;
    v_Tmp Varchar2(400);
  Begin
  
    --金额小数位数
    Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')), Zl_To_Number(Nvl(zl_GetSysParameter(157), '5')),
           zl_GetSysParameter(86)
    Into Gn_Dec, Gn_Decprice, Gv_门诊发送划价单
    From Dual;
  
    --执行前先结算
    n_Tmp := Zl_To_Number(Nvl(zl_GetSysParameter(163), '0'));
    If n_Tmp <> 0 Then
      Gb_执行前先结算 := True;
    End If;
  
    --从属项目汇总计算折扣
    n_Tmp := To_Number(Nvl(zl_GetSysParameter(93), 0));
    If n_Tmp <> 0 Then
      Gb_从项汇总折扣 := True;
    End If;
  
    --处方条数限制
    Gn_Rxcount := To_Number(Nvl(zl_GetSysParameter(56), 0));
  
    v_Tmp       := 0 || zl_GetSysParameter(28) || '|';
    Gn_消费验证 := To_Number(Substr(v_Tmp, 1, Instr(v_Tmp, '|') - 1));
  
    --门诊自动发料
    n_Tmp := Zl_To_Number(Nvl(zl_GetSysParameter(92), '0'));
    If n_Tmp <> 0 Then
      Gb_门诊自动发料 := True;
    Else
      Gb_门诊自动发料 := False;
    End If;
  
    --检验医嘱发送时生成条形码
    n_Tmp := Zl_To_Number(Nvl(zl_GetSysParameter(143), '0'));
    If n_Tmp <> 0 Then
      Gb_发送生成条形码 := True;
    Else
      Gb_发送生成条形码 := False;
    End If;
  
    Mn_Sendno       := To_Number(Nvl(zl_GetSysParameter('发送单据号规则', 1252), 0));
    Mv_单据组合类别 := Nvl(zl_GetSysParameter('产生为同一单据的医嘱类别', 1252), 0);
    n_Tmp           := To_Number(Nvl(zl_GetSysParameter('检验医嘱单独产生单据', 1252), 0));
    If n_Tmp = 1 Then
      Mb_检验单独产生单据 := True;
    End If;
    n_Tmp := To_Number(Nvl(zl_GetSysParameter('一并给药发送为一张', 1252), 1));
    If 1 = n_Tmp Then
      Mb_一并给药发一张 := True;
    End If;
  
    --开始时间不是同一天的分别产生单据
    n_Tmp := To_Number(Nvl(zl_GetSysParameter('开始时间不是同一天的分别产生单据', 1252), 1));
    If 1 = n_Tmp Then
      Mb_Starttimedef := True;
    End If;
  
    Select a.费别, b.门诊号, b.姓名, b.性别, b.年龄, b.No
    Into Mv_费别, Mv_门诊号, Mv_姓名, Mv_性别, Mv_年龄, Mv_挂号单
    From 病人信息 A, 病人挂号记录 B
    Where a.病人id = b.病人id And b.Id = Mn_挂号id;
    --读取动态费别,发送关闭后清除
    --(忽略)gstr动态费别 = Load动态费别(mlng接诊科室ID)
    --对 Gv_动态费别 赋值
  Exception
    When Others Then
      p_Errcenter(SQLErrM);
      --zl_ErrorCenter(SQLCode, SQLErrM);
  End;

  --读取指定医嘱(仅当前行)的计价关系到临时记录集,并计算缺省发送金额(按费别打折)
  Function f_Loadadviceprice
  (
    Row_In        In Number,
    Id_In         In 人员表.Id%Type,
    相关id_In     In 人员表.Id%Type,
    诊疗项目id_In In 人员表.Id%Type,
    收费细目id_In In 人员表.Id%Type,
    执行科室id_In In 人员表.Id%Type,
    是否变价_In   In 材料特性.跟踪在用%Type,
    跟踪在用_In   In 材料特性.跟踪在用%Type,
    可否分零_In   In 材料特性.跟踪在用%Type,
    诊疗类别_In   In 诊疗项目目录.类别%Type,
    执行性质_In   In 病人医嘱记录.执行性质%Type,
    门诊包装_In   In 药品规格.门诊包装%Type,
    剂量系数_In   In 药品规格.剂量系数%Type,
    计价特性_In   In 病人医嘱记录.计价特性%Type,
    标本部位_In   In 病人医嘱记录.标本部位%Type,
    检查方法_In   In 病人医嘱记录.检查方法%Type,
    执行标记_In   In 病人医嘱记录.执行标记%Type,
    金额_Out      Out 门诊费用记录.实收金额%Type
  ) Return Number Is
  
    b_零费记帐 Boolean := False;
    b_附加手术 Boolean := False;
    b_Havesub  Boolean := False;
  
    b_Do         Boolean := False;
    n_Row        Number := 0;
    n_数量       Number(16, 5) := 0;
    n_金额       门诊费用记录.实收金额%Type := 0;
    n_实收       门诊费用记录.实收金额%Type := 0;
    n_应收       门诊费用记录.实收金额%Type := 0;
    n_单价       门诊费用记录.实收金额%Type := 0;
    n_加班率     门诊费用记录.实收金额%Type := 0;
    n_材料id     人员表.Id%Type := 0;
    v_Sql        Varchar2(30000);
    v_Price      Varchar2(20000);
    v_费用性质   Varchar2(200);
    n_费用性质   Number := 0;
    n_项目id     人员表.Id%Type := 0;
    n_主收入id   人员表.Id%Type := 0;
    n_执行科室id 人员表.Id%Type := 0;
    v_费别       Varchar2(30);
    v_Tmp        Varchar2(3000);
  
    Type r_Recordset_Tmp Is Record(
      类别       Varchar2(30),
      收费项目id Number,
      收费数量   Number,
      固有对照   Number,
      收入项目id Number,
      加班加价   Number,
      加班加价率 Number,
      单价       Number,
      是否变价   Number,
      从项       Number,
      跟踪在用   Number,
      执行科室id Number,
      屏蔽费别   Number,
      费用性质   Number,
      收费方式   Number);
    Type t_Tmp Is Table Of r_Recordset_Tmp;
    Rs_Tmp  t_Tmp := t_Tmp();
    n_Rsrow Number := 0;
  
    c_Tmp Rs_Recordset;
  Begin
    If Vsadvice(Row_In).零费记帐 = 1 Then
      b_零费记帐 := True;
    End If;
    金额_Out := 0;
    If Instr(',4,5,6,7,', 诊疗类别_In) > 0 Then
      --不为院外执行(自备药),药品不可能为叮嘱,且固定正常计价
      If Nvl(执行性质_In, 0) <> 5 Then
        Rs_Price.Extend;
        n_Row := Rs_Price.Count;
        Rs_Price(n_Row).医嘱id := Id_In;
        Rs_Price(n_Row).相关id := 相关id_In;
        Rs_Price(n_Row).费用性质 := 0;
        Rs_Price(n_Row).收费方式 := 0;
        Rs_Price(n_Row).收费类别 := 诊疗类别_In;
        Rs_Price(n_Row).收费细目id := 收费细目id_In;
        Rs_Price(n_Row).执行科室id := 执行科室id_In;
        Rs_Price(n_Row).数量 := 1;
        Rs_Price(n_Row).在用 := Nvl(跟踪在用_In, 0);
        Rs_Price(n_Row).变价 := Nvl(是否变价_In, 0);
        Rs_Price(n_Row).固定 := 1;
        Rs_Price(n_Row).从项 := 0;
      
        --发送的零售数量
        If 诊疗类别_In = '7' Then
          If Nvl(可否分零_In, 0) = 0 Then
            n_数量 := Vsadvice(Row_In).总量 * Vsadvice(Row_In).单量 / Nvl(剂量系数_In, 1);
          Else
            n_数量 := Vsadvice(Row_In)
                    .总量 * f_Intex(Vsadvice(Row_In).单量 / Nvl(剂量系数_In, 1) / Nvl(门诊包装_In, 1)) * Nvl(门诊包装_In, 1);
          End If;
        Else
          n_数量 := Vsadvice(Row_In).总量 * Nvl(门诊包装_In, 1);
        End If;
        --记录售价单价
        If Nvl(是否变价_In, 0) = 0 Or 诊疗类别_In = '4' And Nvl(跟踪在用_In, 0) = 0 Then
          Rs_Price(n_Row).单价 := f_Calcprice(收费细目id_In, Null, Null, True, 0, 0);
        Else
          --以售价计算药品时价,自备药时无对应药房
          Rs_Price(n_Row).单价 := f_Calcdrugprice(收费细目id_In, Nvl(执行科室id_In, 0), n_数量, Null);
        End If;
        If Not b_零费记帐 Then
          If Mv_费别 Is Not Null Then
            If Nvl(是否变价_In, 0) = 0 Or 诊疗类别_In = '4' And Nvl(跟踪在用_In, 0) = 0 Then
              n_金额 := f_Calcprice(收费细目id_In, Mv_费别, n_数量, False, Nvl(执行科室id_In, 0), 0);
            Else
              --以售价计算药品时价,自备药时无对应药房
              n_金额 := f_Calcdrugprice(收费细目id_In, Nvl(执行科室id_In, 0), n_数量, Mv_费别);
            End If;
          Else
            If Gb_加班加价 Then
              If Nvl(是否变价_In, 0) = 0 Or 诊疗类别_In = '4' And Nvl(跟踪在用_In, 0) = 0 Then
                n_单价 := f_Calcprice(收费细目id_In, Null, Null, False, 0, 0);
              Else
                --以售价计算药品时价,自备药时无对应药房
                --n_金额:= f_Calcdrugprice(收费细目id_In, Nvl(执行科室id_In, 0), n_数量, Null);
                n_单价 := Rs_Price(n_Row).单价;
              End If;
              n_金额 := Round(Rs_Price(n_Row).数量 * n_数量 * n_单价, Gn_Dec);
            Else
              n_金额 := Round(Rs_Price(n_Row).数量 * n_数量 * Rs_Price(n_Row).单价, Gn_Dec);
            End If;
          End If;
        End If;
      End If;
      金额_Out := n_金额;
    Else
      --取诊疗收费 关系中的对照(发送时才定计价):正常计价,不为叮嘱、院外执行
      If Nvl(计价特性_In, 0) = 0 And Instr(',0,5,', Nvl(执行性质_In, 0)) = 0 Then
        If Vsadvice(Row_In).试管编码 Is Not Null Then
          n_材料id := f_Gettubematerial(Vsadvice(Row_In).试管编码);
        End If;
        n_数量 := Vsadvice(Row_In).总量;
        --几种对应的计价情况
        If 标本部位_In Is Not Null And 检查方法_In Is Not Null Then
          v_Price := ' And c.检查部位=:3 And c.检查方法=:4 And Nvl(c.费用性质,0)=0';
        Elsif Nvl(执行标记_In, 0) = 0 Then
          v_Price := ' And c.检查部位 Is Null And c.检查方法 is Null And Nvl(c.费用性质,0)=0 and (1=1 or c.检查方法=:3 or c.检查方法=:4)';
        Else
          --目前包含床旁或术中加收的情况
          v_Price := ' And c.检查部位 Is Null And c.检查方法 is Null And Nvl(c.费用性质,0) IN(0,1) and (1=1 or c.检查方法=:3 or c.检查方法=:4)';
        End If;
        If 诊疗类别_In = 'F' And 相关id_In Is Not Null Then
          b_附加手术 := True;
        End If;
        v_Price := 'Select * From ( Select C.诊疗项目ID,C.收费项目ID,C.检查部位,C.检查方法,C.费用性质,C.收费数量,C.固有对照,C.从属项目,C.收费方式,c.适用科室id' ||
                   ',Max(Nvl(c.适用科室id, 0)) Over(Partition By c.诊疗项目id, c.检查部位, c.检查方法, c.费用性质) As Top' ||
                   ' From 诊疗收费关系 C Where C.诊疗项目ID=:1 And (C.适用科室ID is Null And C.病人来源 = 0 or C.适用科室ID =:2 And C.病人来源 = 1) ' || v_Price ||
                   '  ) Where Nvl(适用科室id, 0) = Top';
        v_Sql   := 'Select C.类别,A.收费项目ID,A.收费数量,A.固有对照,B.收入项目ID,C.加班加价,B.加班加价率,Decode(C.是否变价,1,B.缺省价格,B.现价)';
        If b_附加手术 Then
          v_Sql := v_Sql || '*Nvl(B.附术收费率,100)/100 ';
        End If;
        v_Sql := v_Sql || '  as 单价,C.是否变价,Nvl(A.从属项目,0) as 从项,D.跟踪在用,' || 执行科室id_In ||
                 ' as 执行科室ID,C.屏蔽费别,Nvl(A.费用性质,0) as 费用性质,' || 'Nvl(A.收费方式,0) as 收费方式 ' || ' From ( ' || v_Price ||
                 ') A,收费价目 B,收费项目目录 C,材料特性 D' || '  Where A.收费项目ID=B.收费细目ID And A.收费项目ID=C.ID And A.收费项目ID=D.材料ID(+)' ||
                 ' And C.服务对象 IN(1,3) And (C.撤档时间=To_Date(''3000-01-01'',''YYYY-MM-DD'') Or C.撤档时间 is NULL)' ||
                 ' And (C.站点=''' || Gv_Nodeno || ''' Or C.站点 is Null)' ||
                 ' And ((Sysdate Between B.执行日期 and B.终止日期) or (Sysdate>=B.执行日期 And B.终止日期 is NULL))' ||
                 ' And (Nvl(A.收费方式,0)=1 And C.类别=''4'' And A.收费项目ID=:5 Or Not(Nvl(A.收费方式,0)=1 And C.类别=''4'' And ';
      
        If n_材料id <> 0 Then
          v_Sql := v_Sql || ' 1=1 ';
        Else
          v_Sql := v_Sql || ' 0=1 ';
        End If;
        v_Sql := v_Sql || ' )) Order by 费用性质,从项,A.收费项目ID';
      
        Open c_Tmp For v_Sql
          Using In 诊疗项目id_In, In 执行科室id_In, In 标本部位_In, In 检查方法_In, In n_材料id;
        Fetch c_Tmp Bulk Collect
          Into Rs_Tmp;
        Close c_Tmp;
        For I In 1 .. Rs_Tmp.Count Loop
          If Instr(',' || v_费用性质 || ',', ',' || Rs_Tmp(I).费用性质 || ',') = 0 Then
            v_费用性质 := v_费用性质 || ',' || Rs_Tmp(I).费用性质;
          End If;
        End Loop;
        v_费用性质 := Substr(v_费用性质, 2);
        While v_费用性质 Is Not Null Loop
          n_费用性质 := Substr(v_费用性质, 1, 1);
          v_费用性质 := Substr(v_费用性质, 3);
        
          For I In 1 .. Rs_Tmp.Count Loop
            If Rs_Tmp(I).费用性质 = n_费用性质 Then
              n_项目id   := 0;
              n_金额     := 0;
              n_主收入id := 0;
              b_Havesub  := False;
              If Gb_从项汇总折扣 Then
                n_Rsrow := I;
                For J In n_Rsrow .. Rs_Tmp.Count Loop
                  If Rs_Tmp(J).费用性质 = n_费用性质 Then
                    If Nvl(Rs_Tmp(J).从项, 0) = 0 Then
                      --SQL中主项排在前面,只取主项目的第一个收入
                      If n_主收入id = 0 Then
                        n_主收入id := Rs_Tmp(J).收入项目id;
                      End If;
                    Elsif Nvl(Rs_Tmp(J).从项, 0) = 1 Then
                      b_Havesub := True;
                      Exit;
                    End If;
                  End If;
                End Loop;
              End If;
            End If;
          End Loop;
        
          --正向循环方式,循环结束后再处理最后一条
          For I In 1 .. Rs_Tmp.Count Loop
            If Rs_Tmp(I).费用性质 = n_费用性质 Then
              n_Rsrow := I;
              b_Do    := False;
              If Rs_Tmp(n_Rsrow).收费项目id <> n_项目id And n_项目id <> 0 Then
                b_Do := True;
              End If;
              If b_Do Then
                If Rs_Price(n_Row).单价 Is Not Null Then
                  Rs_Price(n_Row).单价 := Round(Rs_Price(n_Row).单价, Gn_Decprice);
                End If;
                --医嘱发送金额
                n_金额 := n_金额 + Round(n_实收, Gn_Dec);
              End If;
              ---------------------------
              If Rs_Tmp(n_Rsrow).收费项目id <> n_项目id Then
                n_实收 := 0;
                Rs_Price.Extend;
                n_Row := Rs_Price.Count;
                Rs_Price(n_Row).医嘱id := Id_In;
                Rs_Price(n_Row).相关id := 相关id_In;
                Rs_Price(n_Row).费用性质 := Nvl(Rs_Tmp(n_Rsrow).费用性质, 0);
                Rs_Price(n_Row).收费方式 := Nvl(Rs_Tmp(n_Rsrow).收费方式, 0);
                Rs_Price(n_Row).收费类别 := Rs_Tmp(n_Rsrow).类别;
                Rs_Price(n_Row).收费细目id := Rs_Tmp(n_Rsrow).收费项目id;
                Rs_Price(n_Row).执行科室id := 执行科室id_In;
                Rs_Price(n_Row).数量 := Nvl(Rs_Tmp(n_Rsrow).收费数量, 0);
                Rs_Price(n_Row).在用 := Nvl(Rs_Tmp(n_Rsrow).跟踪在用, 0);
                Rs_Price(n_Row).变价 := Nvl(Rs_Tmp(n_Rsrow).是否变价, 0);
                Rs_Price(n_Row).固定 := Nvl(Rs_Tmp(n_Rsrow).固有对照, 0);
                Rs_Price(n_Row).从项 := Nvl(Rs_Tmp(n_Rsrow).从项, 0);
                --执行科室:非药嘱药品及跟踪卫材的专门取
                n_执行科室id := Nvl(Rs_Tmp(n_Rsrow).执行科室id, 0);
                If Rs_Tmp(n_Rsrow)
                 .类别 = '4' And Nvl(Rs_Tmp(n_Rsrow).跟踪在用, 0) = 1 Or Instr(',5,6,7,', Rs_Tmp(n_Rsrow).类别) > 0 Then
                
                  n_执行科室id := n_执行科室id;
                  -- lng执行科室ID = Get收费执行科室ID(mlng病人ID, 0, rsTmp!类别, rsTmp!收费项目ID, 4, NVL(rsSend!病人科室id, 0), 0, 1, lng执行科室ID)
                End If;
                If Nvl(n_执行科室id, 0) <> 0 Then
                  Rs_Price(n_Row).执行科室id := n_执行科室id;
                Else
                  Rs_Price(n_Row).执行科室id := 0;
                End If;
                Null;
              End If;
              n_项目id := Rs_Tmp(n_Rsrow).收费项目id;
            
              --计算单价和实收
              If (Nvl(Rs_Tmp(n_Rsrow).是否变价, 0) = 1 And Instr(',5,6,7,', Rs_Tmp(n_Rsrow).类别) > 0) Or
                 (Nvl(Rs_Tmp(n_Rsrow).是否变价, 0) = 1 And Rs_Tmp(n_Rsrow).类别 = '4' And Nvl(Rs_Tmp(n_Rsrow).跟踪在用, 0) = 1) Then
              
                --非药嘱药品计价按时价计算(仅一个收入),其它变价需要由医生输入
                --跟踪在用的时价卫材和药品一样计算
                Rs_Price(n_Row).单价 := f_Calcdrugprice(Rs_Tmp(n_Rsrow).收费项目id, Rs_Price(n_Row).执行科室id,
                                                      n_数量 * Nvl(Rs_Tmp(n_Rsrow).收费数量, 0), Null);
              
                n_应收 := Rs_Price(n_Row).数量 * n_数量 * Round(Rs_Price(n_Row).单价, Gn_Decprice);
              
                --处理加班加价
                If Gb_加班加价 And Nvl(Rs_Tmp(n_Rsrow).加班加价, 0) = 1 Then
                  n_应收 := n_应收 * (1 + Nvl(Rs_Tmp(n_Rsrow).加班加价率, 0) / 100);
                End If;
                n_应收 := Round(n_应收, Gn_Dec);
              
                If Not b_零费记帐 Then
                  If Nvl(Rs_Tmp(n_Rsrow).屏蔽费别, 0) = 0 And Mv_费别 Is Not Null And (Not (Gb_从项汇总折扣 And b_Havesub)) Then
                    v_费别 := Mv_费别;
                    If Gv_动态费别 Is Not Null Then
                      v_费别 := v_费别 || ',' || Gv_动态费别;
                    End If;
                    If Gb_加班加价 And Nvl(Rs_Tmp(n_Rsrow).加班加价, 0) = 1 Then
                      n_加班率 := Nvl(Rs_Tmp(n_Rsrow).加班加价率, 0) / 100;
                    Else
                      n_加班率 := 0;
                    End If;
                    n_实收 := n_实收 +
                            Round(f_Actualmoney(v_费别, Rs_Tmp(n_Rsrow).收入项目id, n_应收, Rs_Tmp(n_Rsrow).收费项目id, n_执行科室id,
                                                (Rs_Price(n_Row).数量 * n_数量), n_加班率, v_Tmp), Gn_Dec);
                  Else
                    n_实收 := n_实收 + n_应收;
                  End If;
                End If;
              Else
                --固定价格或普通变价(只有一个收入项目)
                Rs_Price(n_Row).单价 := Nvl(Rs_Price(n_Row).单价, 0) + Nvl(Rs_Tmp(n_Rsrow).单价, 0);
              
                n_应收 := Rs_Price(n_Row).数量 * n_数量 * Round(Rs_Tmp(n_Rsrow).单价, Gn_Decprice);
                --处理加班加价
                If Gb_加班加价 And Nvl(Rs_Tmp(n_Rsrow).加班加价, 0) = 1 Then
                  n_应收 := n_应收 * (1 + Nvl(Rs_Tmp(n_Rsrow).加班加价率, 0) / 100);
                End If;
                n_应收 := Round(n_应收, Gn_Dec);
                If Not b_零费记帐 Then
                  If Nvl(Rs_Tmp(n_Rsrow).屏蔽费别, 0) = 0 And Mv_费别 Is Not Null And (Not (Gb_从项汇总折扣 And b_Havesub)) Then
                    v_费别 := Mv_费别;
                    If Gv_动态费别 Is Not Null Then
                      v_费别 := v_费别 || ',' || Gv_动态费别;
                    End If;
                    If Gb_加班加价 And Nvl(Rs_Tmp(n_Rsrow).加班加价, 0) = 1 Then
                      n_加班率 := Nvl(Rs_Tmp(n_Rsrow).加班加价率, 0) / 100;
                    Else
                      n_加班率 := 0;
                    End If;
                    n_实收 := n_实收 +
                            Round(f_Actualmoney(v_费别, Rs_Tmp(n_Rsrow).收入项目id, n_应收, Rs_Tmp(n_Rsrow).收费项目id, n_执行科室id,
                                                (Rs_Price(n_Row).数量 * n_数量), n_加班率, v_Tmp), Gn_Dec);
                  Else
                    n_实收 := n_实收 + n_应收;
                  End If;
                End If;
              End If;
            End If;
          End Loop;
        
          --循环结再处理最后一条
          If Nvl(n_项目id, 0) <> 0 Then
            If Rs_Price(n_Row).单价 Is Not Null Then
              Rs_Price(n_Row).单价 := Round(Rs_Price(n_Row).单价, Gn_Decprice);
            End If;
            --医嘱发送金额
            n_金额 := n_金额 + Round(n_实收, Gn_Dec);
          End If;
        
          --从属项目汇总计算折扣
          If Gb_从项汇总折扣 And b_Havesub And n_主收入id <> 0 And Not b_零费记帐 Then
            v_费别 := Mv_费别;
            If Gv_动态费别 Is Not Null Then
              v_费别 := v_费别 || ',' || Gv_动态费别;
            End If;
            n_金额 := Round(f_Actualmoney(v_费别, n_主收入id, n_金额, 0, 0, 0, 0, v_Tmp), Gn_Dec);
          End If;
          金额_Out := 金额_Out + n_金额;
        
        End Loop;
      End If;
    End If;
    Mv_Msg := Null;
    Return(1);
  Exception
    When Others Then
      p_Errcenter(SQLErrM);
      --zl_ErrorCenter(SQLCode, SQLErrM);
      Return(0);
  End;

  Function f_Loadadvicesend Return Number Is
    --医嘱记录集
    Cursor c_Advice(医嘱ids_In Varchar2) Is
      Select a.病人id, a.Id, a.挂号单, a.相关id, Nvl(a.相关id, a.Id) As 组id, Nvl(x.序号, a.序号) As 组号, a.诊疗类别, f.名称 As 类别名称,
             a.诊疗项目id, b.名称 As 诊疗项目, a.收费细目id, c.规格, a.婴儿, a.医嘱内容, a.标本部位, a.检查方法, a.执行标记, a.天数, a.总给予量, d.门诊单位, a.单次用量,
             Decode(a.诊疗类别, '4', c.计算单位, b.计算单位) As 计算单位, d.剂量系数, d.门诊包装, a.开始执行时间, a.执行频次, a.频率次数, a.频率间隔, a.间隔单位,
             a.医生嘱托, a.执行时间方案, a.病人科室id, a.开嘱科室id, a.开嘱医生, a.计价特性, a.执行性质, a.执行科室id,
             Nvl(e.名称, Decode(Nvl(a.执行性质, 0), 5, '-')) As 执行科室, d.门诊可否分零 As 可否分零,
             Decode(a.诊疗类别, '4', g.在用分批, d.药房分批) As 分批, c.是否变价, g.跟踪在用, c.撤档时间, c.服务对象, a.前提id, a.新开签名id As 签名id, b.试管编码,
             b.操作类型, b.执行分类, a.摘要, a.紧急标志, a.零费记帐, b.计算方式, b.执行安排, h.毒理分类
      From 病人医嘱记录 A, 诊疗项目目录 B, 收费项目目录 C, 药品规格 D, 部门表 E, 诊疗项目类别 F, 材料特性 G, 药品特性 H, 病人医嘱记录 X
      Where a.相关id = x.Id(+) And b.类别 = f.编码 And a.诊疗项目id = b.Id And a.收费细目id = c.Id(+) And a.收费细目id = d.药品id(+) And
            a.收费细目id = g.材料id(+) And a.执行科室id = e.Id(+) And Not (a.诊疗类别 = 'H' And b.操作类型 = '1') And
            Nvl(a.执行标记, 0) <> -1 And b.Id = h.药名id(+) And Nvl(a.审核状态, 0) Not In (1, 3, 4, 5) And
            Nvl(a.皮试结果, '无') <> '免试' And a.开始执行时间 Is Not Null And a.病人来源 <> 3 And a.医嘱状态 = 1 And
            a.Id In (Select /*+cardinality(x,10)*/
                      x.Column_Value
                     From Table(f_Num2list(医嘱ids_In)) X)
      Order By a.婴儿, 组号, 组id, a.序号;
    r_Advice c_Advice%RowType;
  
    n_Row       Number := 0;
    n_Break     Number;
    v_停用      Varchar2(4000);
    v_分解      Varchar2(4000);
    n_Del医嘱id Number(18) := 0;
    n_Del相关id Number(18) := 0;
    n_最小次数  Number := 0;
    n_次数      Number := 0;
    n_总量      Number(16, 5) := 0;
    n_金额      Number(16, 5) := 0;
    n_Tmp       Number := 0;
    v_Tmp       Varchar2(1000);
    v_用法      Varchar2(1000);
  Begin
    Vsadvice := t_Advice();
    Rs_Price := t_Price();
    Vsadvice.Extend; --添加一个空行
    Open c_Advice(Mv_医嘱ids);
    Loop
      Fetch c_Advice
        Into r_Advice;
      Exit When c_Advice%NotFound;
      If c_Advice%RowCount > 0 Then
        n_Break := 1;
        --一并给药或配方或检验组合中的一个可能已经不能发送,则整组不能发送
        If n_Del相关id <> 0 Then
          If (r_Advice.Id = n_Del相关id Or Nvl(r_Advice.相关id, 0) = n_Del相关id) Then
            n_Break := 0;
          Else
            n_Del相关id := 0;
          End If;
        End If;
        --检查组合或手术组合中的一个可能已经不能发送,则整组不能发送
        If n_Del医嘱id <> 0 Then
          If Nvl(r_Advice.相关id, 0) = n_Del医嘱id Then
            n_Break := 0;
          Else
            n_Del医嘱id := 0;
          End If;
        End If;
        If n_Break = 1 Then
          Vsadvice.Extend;
          n_Row := Vsadvice.Count; --当前行
          Vsadvice(n_Row).选择 := 1; --1表示可以发送,非1不能发送;2-表示一般的叮嘱
          If Nvl(r_Advice.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) <> To_Date('3000-01-01', 'yyyy-mm-dd') Then
            Vsadvice(n_Row).选择 := 0;
            If Instr(v_停用 || ',', ',' || r_Advice.医嘱内容 || ',') = 0 Then
              v_停用 := v_停用 || ',' || r_Advice.医嘱内容;
            End If;
          End If;
        
          If r_Advice.诊疗类别 = 'E' Then
            If r_Advice.相关id Is Not Null Then
              If Vsadvice(n_Row - 1).诊疗类别 = 'K' Then
                Vsadvice(n_Row).Id_Data := 5; --输血途径
              Else
                Vsadvice(n_Row).Id_Data := 2; --中药煎法
              End If;
            Elsif Vsadvice(n_Row - 1).相关id = r_Advice.Id Then
              If Instr(',5,6,', Vsadvice(n_Row - 1).诊疗类别) > 0 Then
                Vsadvice(n_Row).Id_Data := 1; --给药途径
              Elsif Vsadvice(n_Row - 1).诊疗类别 = 'C' Then
                Vsadvice(n_Row).Id_Data := 4; --采集方法
              Else
                Vsadvice(n_Row).Id_Data := 3; --中药用法
              End If;
            End If;
          End If;
        
          --排开一般的叮嘱(不含给药途径,中药煎法,用法,采集方法,输血途径)
          If Nvl(r_Advice.执行性质, 0) = 0 Then
            If Instr(',1,2,3,4,5,', Vsadvice(n_Row).Id_Data) = 0 And Instr(',5,6,7,', r_Advice.诊疗类别) = 0 Then
              n_Break := 0;
              Vsadvice.Delete(n_Row);
            End If;
          End If;
        
          If n_Break = 1 Then
            Vsadvice(n_Row).婴儿 := r_Advice.婴儿;
            Vsadvice(n_Row).医嘱内容 := r_Advice.医嘱内容;
            Vsadvice(n_Row).频率 := r_Advice.执行频次;
            Vsadvice(n_Row).医生嘱托 := r_Advice.医生嘱托;
            Vsadvice(n_Row).医生嘱托_Data := r_Advice.摘要;
            Vsadvice(n_Row).执行时间 := r_Advice.执行时间方案;
            Vsadvice(n_Row).执行科室 := r_Advice.执行科室;
            Vsadvice(n_Row).执行性质 := r_Advice.执行性质;
            Vsadvice(n_Row).Id := r_Advice.Id;
            Vsadvice(n_Row).相关id := r_Advice.相关id;
            Vsadvice(n_Row).病人科室id := r_Advice.病人科室id;
            Vsadvice(n_Row).开嘱科室id := r_Advice.开嘱科室id;
            Vsadvice(n_Row).开嘱医生 := r_Advice.开嘱医生;
            Vsadvice(n_Row).诊疗类别 := r_Advice.诊疗类别;
            Vsadvice(n_Row).诊疗项目id := r_Advice.诊疗项目id;
            Vsadvice(n_Row).标本部位 := r_Advice.标本部位;
            Vsadvice(n_Row).检查方法 := r_Advice.检查方法;
            Vsadvice(n_Row).执行标记 := r_Advice.执行标记;
            Vsadvice(n_Row).计价特性 := r_Advice.计价特性;
            Vsadvice(n_Row).执行性质id := r_Advice.执行性质;
            Vsadvice(n_Row).执行科室id := r_Advice.执行科室id;
            Vsadvice(n_Row).频率次数 := r_Advice.频率次数;
            Vsadvice(n_Row).频率间隔 := r_Advice.频率间隔;
            Vsadvice(n_Row).间隔单位 := r_Advice.间隔单位;
          
            If Instr(',5,6,7,', ',' || r_Advice.诊疗类别 || ',') > 0 Then
              --药品对应的规格已撤档则不允许发送(诊疗项目本身也可以相同处理,目前暂未处理)
              If Nvl(r_Advice.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) <> To_Date('3000-01-01', 'yyyy-mm-dd') Or
                 Instr(',1,3,', Nvl(r_Advice.服务对象, 0)) = 0 Then
                --提示信息暂时不处理,跳过再处理其它医嘱
                n_Del医嘱id := r_Advice.Id;
                n_Del相关id := Nvl(r_Advice.相关id, 0);
                --往前删除整组医嘱 Call DeleteCurRow(lngRow)
                Vsadvice.Delete(n_Row);
                n_Row := n_Row - 1;
                For I In 1 .. n_Row Loop
                  If Nvl(Vsadvice(n_Row + I - 1).相关id, 0) = n_Del相关id Then
                    Vsadvice.Delete(n_Row + I - 1);
                  Else
                    Exit;
                  End If;
                End Loop;
                n_最小次数 := 0;
                n_Break    := 0;
              End If;
              If n_Break = 1 Then
                --毒理分类判断忽略
                --Vsadvice(n_Row).毒理分类 := r_Advice.毒理分类;
                Vsadvice(n_Row).收费细目id := r_Advice.收费细目id;
                Vsadvice(n_Row).剂量系数 := Nvl(r_Advice.剂量系数, 1);
                Vsadvice(n_Row).门诊包装 := Nvl(r_Advice.门诊包装, 1);
                Vsadvice(n_Row).门诊单位 := r_Advice.门诊单位;
                Vsadvice(n_Row).可否分零 := r_Advice.可否分零;
                Vsadvice(n_Row).库存 := f_库存(r_Advice.收费细目id, Nvl(r_Advice.执行科室id, 0));
              End If;
            Elsif r_Advice.诊疗类别 = '4' Then
              Vsadvice(n_Row).收费细目id := r_Advice.收费细目id;
              Vsadvice(n_Row).剂量系数 := 1;
              Vsadvice(n_Row).门诊包装 := 1;
              Vsadvice(n_Row).门诊单位 := r_Advice.计算单位;
              Vsadvice(n_Row).库存 := f_库存(r_Advice.收费细目id, Nvl(r_Advice.执行科室id, 0));
            End If;
          
            If n_Break = 1 Then
              --计算发送次数，执行的分解时间等
              If r_Advice.诊疗类别 = '7' Then
                Vsadvice(n_Row).次数 := r_Advice.总给予量;
                If r_Advice.执行时间方案 Is Not Null Or Nvl(r_Advice.间隔单位, ' ') = '分钟' Then
                  v_分解 := f_Calc次数分解时间(r_Advice.总给予量, r_Advice.开始执行时间, To_Date('3000-01-01', 'yyyy-mm-dd'),
                                       r_Advice.执行时间方案, r_Advice.频率间隔, r_Advice.间隔单位);
                  If v_分解 Is Not Null Then
                    Vsadvice(n_Row).分解时间 := v_分解;
                    Vsadvice(n_Row).首次时间 := Substr(v_分解, 1, 16);
                    Vsadvice(n_Row).末次时间 := Substr(v_分解, Instr(v_分解, ',', -1) + 1, 16);
                  End If;
                Else
                  --无分解时间(临嘱可能未输入执行时间而无法分解)
                  --记录费用发生时间(以医嘱开始执行时间)
                  Vsadvice(n_Row).分解时间_Data := To_Char(r_Advice.开始执行时间, 'YYYY-MM-DD HH24:MI:SS');
                End If;
                Vsadvice(n_Row).单量 := r_Advice.单次用量;
                Vsadvice(n_Row).单量单位 := r_Advice.计算单位;
                Vsadvice(n_Row).总量 := r_Advice.总给予量;
                Vsadvice(n_Row).总量单位 := '付';
              Elsif Instr(',5,6,', ',' || r_Advice.诊疗类别 || ',') > 0 Then
                --计算临嘱用药次数
                If Nvl(r_Advice.天数, 0) <> 0 And r_Advice.执行频次 Is Not Null Then
                  --一个频率周期的次数
                  If r_Advice.间隔单位 = '周' Then
                    n_次数 := f_Intex(r_Advice.天数 * (r_Advice.频率次数 / 7));
                  Elsif r_Advice.间隔单位 = '天' Then
                    n_次数 := f_Intex(r_Advice.天数 * (r_Advice.频率次数 / r_Advice.频率间隔));
                  Elsif r_Advice.间隔单位 = '小时' Then
                    n_次数 := f_Intex(r_Advice.天数 * (r_Advice.频率次数 / r_Advice.频率间隔) * 24);
                  Elsif r_Advice.间隔单位 = '分钟' Then
                    n_次数 := f_Intex(r_Advice.天数 * (r_Advice.频率次数 / r_Advice.频率间隔) * (24 * 60));
                  End If;
                Else
                  --可分零药品时,按总量对单量的倍数计算给药途径的次数,不可分零与一次性使用药品时，按总量对（单量与剂量系数比值取整）的倍数计算给药途径的次数
                  --否则按一个频率周期的次数计算
                  If Nvl(r_Advice.可否分零, 0) = 0 And Nvl(r_Advice.单次用量, 0) <> 0 Then
                    n_次数 := f_Intex(r_Advice.总给予量 * r_Advice.剂量系数 / r_Advice.单次用量);
                  Elsif (Nvl(r_Advice.可否分零, 0) = 1 Or Nvl(r_Advice.可否分零, 0) = 2) And Nvl(r_Advice.单次用量, 0) <> 0 Then
                    n_次数 := f_Intex(r_Advice.总给予量 / f_Intex(r_Advice.单次用量 / r_Advice.剂量系数));
                  Else
                    n_次数 := Nvl(r_Advice.频率次数, 0);
                  End If;
                End If;
                If r_Advice.执行时间方案 Is Not Null Or Nvl(r_Advice.间隔单位, ' ') = '分钟' Then
                  v_分解 := f_Calc次数分解时间(n_次数, r_Advice.开始执行时间, To_Date('3000-01-01', 'yyyy-mm-dd'), r_Advice.执行时间方案,
                                       r_Advice.频率间隔, r_Advice.间隔单位);
                  If v_分解 Is Not Null Then
                    Vsadvice(n_Row).分解时间 := v_分解;
                    Vsadvice(n_Row).首次时间 := Substr(v_分解, 1, 16);
                    Vsadvice(n_Row).末次时间 := Substr(v_分解, Instr(v_分解, ',', -1) + 1, 16);
                  End If;
                Else
                  --无分解时间(临嘱可能未输入执行时间而无法分解)
                  --记录费用发生时间(以医嘱开始执行时间)
                  Vsadvice(n_Row).分解时间_Data := To_Char(r_Advice.开始执行时间, 'YYYY-MM-DD HH24:MI:SS');
                End If;
                Vsadvice(n_Row).次数 := n_次数;
                Vsadvice(n_Row).单量 := r_Advice.单次用量;
                Vsadvice(n_Row).单量单位 := r_Advice.计算单位;
                Vsadvice(n_Row).总量 := Round(r_Advice.总给予量 / r_Advice.门诊包装, 5);
                Vsadvice(n_Row).总量单位 := r_Advice.门诊单位;
                If n_次数 < n_最小次数 Or n_最小次数 = 0 Then
                  n_最小次数 := n_次数;
                End If;
              Elsif r_Advice.诊疗类别 = 'E' And Nvl(Vsadvice(n_Row).Id_Data, '0') <> '0' Then
                --给药途径,中药煎法,中药用法,采集方法,输血途径
                --一并给药的按最小次数发送(影响给药途径计费)
                If Vsadvice(n_Row).Id_Data = '1' Then
                  --给药途径
                  For J In 1 .. n_Row Loop
                    If Vsadvice(n_Row + J - 2).相关id = r_Advice.Id Then
                      If Vsadvice(n_Row + J - 2).次数 > n_最小次数 Then
                        Vsadvice(n_Row + J - 2).次数 := n_最小次数;
                        If Vsadvice(n_Row + J - 2).分解时间 Is Not Null Then
                          v_分解 := f_Trim分解时间(n_最小次数, Vsadvice(n_Row + J - 2).分解时间);
                          Vsadvice(n_Row + J - 2).分解时间 := v_分解;
                          Vsadvice(n_Row + J - 2).首次时间 := Substr(v_分解, 1, 16);
                          Vsadvice(n_Row + J - 2).末次时间 := Substr(v_分解, Instr(v_分解, ',', -1) + 1, 16);
                        End If;
                      End If;
                    Else
                      Exit;
                    End If;
                  End Loop;
                  n_最小次数 := 0;
                End If;
                --忽略指定了给药执行次数情况
                Vsadvice(n_Row).总量 := Vsadvice(n_Row - 1).次数; --付数或次数
                Vsadvice(n_Row).次数 := Vsadvice(n_Row - 1).次数;
                Vsadvice(n_Row).分解时间 := Vsadvice(n_Row - 1).分解时间;
                Vsadvice(n_Row).首次时间 := Vsadvice(n_Row - 1).首次时间;
                Vsadvice(n_Row).末次时间 := Vsadvice(n_Row - 1).末次时间;
                Vsadvice(n_Row).分解时间_Data := Vsadvice(n_Row - 1).分解时间_Data;
                If Vsadvice(n_Row).Id_Data = '3' Then
                  --中药用法
                  Vsadvice(n_Row).总量单位 := '付';
                Else
                  Vsadvice(n_Row).总量单位 := r_Advice.计算单位;
                End If;
              Else
                --其它非药临嘱:采集方法在上面的分支中已作处理
                If r_Advice.相关id Is Null Or (r_Advice.相关id Is Not Null And r_Advice.诊疗类别 = 'C') Then
                  --主要医嘱,包括检验组合
                  If r_Advice.诊疗类别 = 'K' Then
                    --输血途径的执行次数
                    n_总量 := Nvl(r_Advice.总给予量, 0);
                    If r_Advice.执行时间方案 Is Null And
                       (Nvl(r_Advice.频率次数, 0) = 0 Or Nvl(r_Advice.频率间隔, 0) = 0 Or r_Advice.间隔单位 Is Null) Then
                      n_次数 := 1;
                    Else
                      n_次数 := Nvl(r_Advice.频率次数, 1);
                    End If;
                  Else
                    n_总量 := Nvl(r_Advice.总给予量, 1);
                    n_次数 := f_Intex(n_总量 / Nvl(r_Advice.单次用量, 1));
                  End If;
                
                  If r_Advice.执行时间方案 Is Null And
                     (Nvl(r_Advice.频率次数, 0) = 0 Or Nvl(r_Advice.频率间隔, 0) = 0 Or r_Advice.间隔单位 Is Null) Then
                    --执行频率为 一次性 的项目
                    v_分解 := Null;
                    Vsadvice(n_Row).频率_Data := 1;
                  Else
                    --执行频率为 可选频率 的项目:下医嘱时应输入了总量
                    If r_Advice.执行时间方案 Is Not Null Or Nvl(r_Advice.间隔单位, ' ') = '分钟' Then
                      v_分解 := f_Calc次数分解时间(n_次数, r_Advice.开始执行时间, To_Date('3000-01-01', 'yyyy-mm-dd'), r_Advice.执行时间方案,
                                           r_Advice.频率间隔, r_Advice.间隔单位);
                    Else
                      v_分解 := Null; --临嘱也许未输入执行时间,无法分解
                    End If;
                  End If;
                  Vsadvice(n_Row).次数 := n_次数;
                  Vsadvice(n_Row).分解时间 := v_分解;
                  If v_分解 Is Not Null Then
                    Vsadvice(n_Row).首次时间 := Substr(v_分解, 1, 16);
                    Vsadvice(n_Row).末次时间 := Substr(v_分解, Instr(v_分解, ',', -1) + 1, 16);
                  Else
                    --记录费用发生时间(当无分解时间时),以医嘱的开始执行时间
                    Vsadvice(n_Row).分解时间_Data := To_Char(r_Advice.开始执行时间, 'YYYY-MM-DD HH24:MI:SS');
                  End If;
                  Vsadvice(n_Row).单量 := r_Advice.单次用量;
                  If r_Advice.单次用量 Is Not Null Then
                    Vsadvice(n_Row).单量单位 := r_Advice.计算单位;
                  End If;
                  Vsadvice(n_Row).总量 := Round(n_总量, 5);
                  Vsadvice(n_Row).总量单位 := r_Advice.计算单位;
                Else
                  Vsadvice(n_Row).总量 := Vsadvice(n_Row - 1).总量;
                  Vsadvice(n_Row).次数 := Vsadvice(n_Row - 1).次数;
                  Vsadvice(n_Row).分解时间 := Vsadvice(n_Row - 1).分解时间;
                  Vsadvice(n_Row).分解时间_Data := Vsadvice(n_Row - 1).分解时间_Data;
                  Vsadvice(n_Row).首次时间 := Vsadvice(n_Row - 1).首次时间;
                  Vsadvice(n_Row).末次时间 := Vsadvice(n_Row - 1).末次时间;
                End If;
              End If;
            
              Vsadvice(n_Row).前提id := r_Advice.前提id;
              Vsadvice(n_Row).签名id := r_Advice.签名id;
              --采集方式的管码与检验相同(暂不考虑一并检验的情况)
              If Vsadvice(n_Row).Id_Data = '4' Then
                Vsadvice(n_Row).试管编码 := Vsadvice(n_Row - 1).试管编码;
              Else
                Vsadvice(n_Row).试管编码 := r_Advice.试管编码;
              End If;
              Vsadvice(n_Row).操作类型 := r_Advice.操作类型;
              Vsadvice(n_Row).紧急标志 := r_Advice.紧急标志;
              Vsadvice(n_Row).零费记帐 := r_Advice.零费记帐;
              --计算方式
              If Instr(',4,5,6,7,', ',' || r_Advice.诊疗类别 || ',') = 0 Then
                Vsadvice(n_Row).计算方式 := r_Advice.计算方式;
              Else
                Vsadvice(n_Row).计算方式 := '0';
              End If;
              Vsadvice(n_Row).开始时间 := To_Char(r_Advice.开始执行时间, 'YYYY-MM-DD HH24:MI:SS');
              Vsadvice(n_Row).执行安排 := r_Advice.执行安排;
              Vsadvice(n_Row).执行分类 := r_Advice.执行分类;
            
              --计算项目发送金额
              n_Tmp := f_Loadadviceprice(n_Row, r_Advice.Id, r_Advice.相关id, r_Advice.诊疗项目id, r_Advice.收费细目id,
                                         r_Advice.执行科室id, r_Advice.是否变价, r_Advice.跟踪在用, r_Advice.可否分零, r_Advice.诊疗类别,
                                         r_Advice.执行性质, r_Advice.门诊包装, r_Advice.剂量系数, r_Advice.计价特性, r_Advice.标本部位,
                                         r_Advice.检查方法, r_Advice.执行标记, n_金额);
              If n_Tmp = 0 Then
                n_Del医嘱id := r_Advice.Id;
                n_Del相关id := Nvl(r_Advice.相关id, 0);
                --往前删除整组医嘱 Call DeleteCurRow(lngRow)
                Vsadvice.Delete(n_Row);
                n_Row := n_Row - 1;
                For I In 1 .. n_Row Loop
                  If Nvl(Vsadvice(n_Row + I - 1).相关id, 0) = n_Del相关id Then
                    Vsadvice.Delete(n_Row + I - 1);
                  Else
                    Exit;
                  End If;
                End Loop;
                n_最小次数 := 0;
                n_Break    := 0;
              End If;
              If n_Break = 1 Then
                Vsadvice(n_Row).金额 := Round(n_金额, Gn_Dec);
                Vsadvice(n_Row).金额_Data := Vsadvice(n_Row).金额;
                --相关行时的一些处理：累计显示金额,给药途径,用法,执行科室,执行性质
                If r_Advice.诊疗类别 = 'E' And Instr(',1,3,', ',' || Vsadvice(n_Row).Id_Data || ',') > 0 Then
                  n_金额 := 0;
                  n_Tmp  := 0; --药品首行
                
                  For I In 1 .. n_Row - 1 Loop
                    If Nvl(Vsadvice(n_Row + I - 2).相关id, 0) = r_Advice.Id Then
                      n_Tmp := I;
                    Else
                      Exit;
                    End If;
                  End Loop;
                
                  If Vsadvice(n_Row).Id_Data = '1' Then
                    For I In n_Tmp .. n_Row - 1 Loop
                      v_Tmp := Null;
                      If Vsadvice(I).执行性质id = 5 And Nvl(Vsadvice(n_Row).执行性质id, 0) <> 5 Then
                        v_Tmp := '自备药';
                      Elsif Nvl(Vsadvice(I).执行性质id, 0) <> 5 And Vsadvice(n_Row).执行性质id = 5 Then
                        v_Tmp := '离院带药';
                      End If;
                      Vsadvice(I).执行性质 := v_Tmp;
                      Vsadvice(I).用法 := r_Advice.诊疗项目;
                    End Loop;
                  Else
                    v_Tmp := Null;
                    If Vsadvice(n_Tmp).执行性质id = 5 And Nvl(Vsadvice(n_Row).执行性质id, 0) <> 5 Then
                      v_Tmp := '自备药';
                    Elsif Nvl(Vsadvice(n_Tmp).执行性质id, 0) <> 5 And Vsadvice(n_Row).执行性质id = 5 Then
                      v_Tmp := '离院带药';
                    End If;
                    Vsadvice(n_Row).执行性质 := v_Tmp;
                    Vsadvice(n_Row).执行科室 := Vsadvice(n_Tmp).执行科室;
                    v_用法 := Null;
                    If Vsadvice(n_Row - 1).Id_Data = '2' Then
                      Select Max(名称) Into v_用法 From 诊疗项目目录 Where ID = Vsadvice(n_Row - 1).诊疗项目id;
                    End If;
                    If v_用法 Is Null Then
                      v_用法 := r_Advice.诊疗项目;
                    Else
                      v_用法 := r_Advice.诊疗项目 || '|' || v_用法;
                    End If;
                    For I In n_Tmp .. n_Row - 1 Loop
                      Vsadvice(I).用法 := v_用法;
                    End Loop;
                  End If;
                  --使相关医嘱选择状态相同(固为库存的原因；非药医嘱不用)忽略
                Elsif Instr(',5,6,7,', ',' || r_Advice.诊疗类别 || ',') = 0 Then
                  --输血途径
                  If r_Advice.诊疗类别 = 'E' And Vsadvice(n_Row).Id_Data = '5' Then
                    Vsadvice(n_Row - 1).用法 := r_Advice.诊疗项目;
                  End If;
                End If;
                --药品、卫材库存检查(0-不检查;1-检查,不足提醒;2-检查，不足禁止),自备药不检查
              End If;
            End If;
          End If;
        End If;
      End If;
    End Loop;
  
    Mv_Msg := Null;
    If Vsadvice.Count = 1 Then
      Return(0);
    Else
      Return(1);
    End If;
  Exception
    When Others Then
      p_Errcenter(SQLErrM);
      --zl_ErrorCenter(SQLCode, SQLErrM);
      Return(0);
  End;

  --医嘱发送
  Function f_Sendadvice(记帐_In In Number) Return Number Is
  
    Type r_Seek Is Record(
      费用性质 Number,
      主项标签 Number,
      主收入id Number(18),
      合计     Number(16, 5));
    Type t_Seek Is Table Of r_Seek;
  
    Type r_Money Is Record(
      ID         Number(18),
      类别       Varchar2(20),
      类别名称   Varchar2(2000),
      名称       Varchar2(2000),
      计算单位   Varchar2(20),
      是否变价   Number(1),
      屏蔽费别   Number(1),
      费用确认   Number(1),
      加班加价   Number(1),
      加班加价率 Number(16, 5),
      附术收费率 Number(16, 5),
      门诊单位   Varchar2(20),
      门诊包装   Number(16, 5),
      剂量系数   Number(16, 5),
      分批       Number(1),
      跟踪在用   Number(1),
      收入项目id Number(18),
      收据费目   Varchar2(20),
      数量       Number(16, 5),
      单价       Number(16, 5),
      执行科室id Number(18),
      从项       Number(1),
      费用性质   Number(1),
      收费方式   Number(1));
    Type t_Money Is Table Of r_Money;
  
    Rs_Seek  t_Seek;
    Rs_Money t_Money;
  
    c_Tmp Rs_Recordset;
  
    n_发送号        病人医嘱发送.发送号%Type;
    n_发送序号      病人医嘱发送.发送号%Type;
    d_Cur           Date;
    b_处方数限制    Boolean;
    n_配方数        Number;
    v_Nokey         Varchar2(600);
    v_No            Varchar2(600);
    n_Pre诊疗单据id Number(18) := 0;
    n_Tmp           Number;
    n_Tmp1          Number;
    b_离院带药      Boolean;
    n_Okrowmney     Number;
    v_Sql           Varchar2(20000);
    v_收费项目      Varchar2(6000);
    n_执行科室id    部门表.Id%Type;
    n_父序号        Number;
    n_父项目id      Number(18);
    v_Havesub       Varchar2(600);
    v_Nonesub       Varchar2(600);
    v_Cuvettenumber Varchar2(600);
    n_费用次数      Number;
    n_收费数量      Number;
    n_采集科室id    Number(18);
    n_执行状态      Number;
    n_计费状态      Number;
    b_附加手术      Boolean := False;
    b_First         Boolean;
    n_Idx           Number;
    v_分解时间      Varchar2(20000);
    I               Number;
    J               Number;
    K               Number;
    n_付数          Number(16, 5);
    n_数量          Number(16, 5);
    n_Other数量     Number(16, 5);
    n_单价          Number(16, 5);
    n_应收          Number(16, 5);
    n_实收          Number(16, 5);
    n_合计          Number(16, 5);
    n_记帐合计      Number(16, 5);
    n_发送数次      Number(16, 5);
    b_Bool          Boolean;
    n_费用父号      Number;
    n_费用序号      Number;
    v_费别          Varchar2(3000);
    v_类别          Varchar2(3000);
    d_发生时间      Date;
    d_登记时间      Date;
    n_划价          Number;
    v_自动发料      Varchar2(6000);
    b_记帐          Boolean;
  
    d_首次时间 Date;
    d_末次时间 Date;
  
  Begin
    If 记帐_In = 1 Then
      b_记帐 := True;
    Else
      b_记帐 := False;
    End If;
    Mn_Nosequence := 0;
    n_发送号      := Nextno(10, Null, Null, 1);
    If Mb_Auto Then
      Select (Sysdate + 1 / 60 / 24) As 发送时间 Into d_Cur From Dual;
    Else
      Select Sysdate Into d_Cur From Dual;
    End If;
  
    n_配方数 := 1; --表示发送的第几付配方,用于分单据号
    Rs_Exec  := t_Exec();
    --从第二行开始循环,因为前面加了空行
    For I In 2 .. Vsadvice.Count Loop
      --产生单据号分配关键字
      b_处方数限制 := False;
      If Mn_Sendno = 1 And Not Gb_执行前先结算 Then
        v_Nokey := '只产生一个单据号';
      Elsif Mn_Sendno = 2 Then
        v_Nokey := Nvl(Vsadvice(I).执行科室id, 0);
        If Instr(',5,6,', ',' || Vsadvice(I).诊疗类别 || ',') > 0 And Gn_Rxcount > 0 Then
          b_处方数限制 := True;
        End If;
      Else
        If Instr(',5,6,', ',' || Vsadvice(I).诊疗类别 || ',') > 0 Then
          v_Nokey := '中西成药_' || Mn_病人id || '_' || Mv_挂号单 || '_' || Vsadvice(I).病人科室id || Vsadvice(I).开嘱科室id;
          v_Nokey := v_Nokey || '_' || f_Getmergedrugstore(I);
        
          If Mb_一并给药发一张 Then
            If Nvl(Vsadvice(I).相关id, 0) <> Nvl(Vsadvice(I - 1).相关id, 0) Then
              --再按要打印的诊疗单据分号(一并给药的，只取第一个药品的诊疗单据ID)
              n_Pre诊疗单据id := f_Getclinicbillid(Vsadvice(I).诊疗项目id);
            End If;
            v_Nokey := v_Nokey || '_' || n_Pre诊疗单据id;
          Else
            v_Nokey := v_Nokey || '_' || f_Getclinicbillid(Vsadvice(I).诊疗项目id);
          End If;
          If Gn_Rxcount > 0 Then
            b_处方数限制 := True;
          End If;
        Elsif Instr(',4,M,', ',' || Vsadvice(I).诊疗类别 || ',') > 0 Then
          v_Nokey := '材料医嘱_' || Mn_病人id || '_' || Mv_挂号单 || '_' || Vsadvice(I).病人科室id || Vsadvice(I).开嘱科室id || '_' ||
                     Nvl(Vsadvice(I).执行科室id, 0);
          v_Nokey := v_Nokey || '_' || f_Getclinicbillid(Vsadvice(I).诊疗项目id);
        Elsif Vsadvice(I).诊疗类别 = '7' Then
          --一个配方中的所有草药分配一个独立单据号
          v_Nokey := '中药配方_' || Mn_病人id || '_' || Mv_挂号单 || '_' || n_配方数;
        Elsif Instr(Mv_单据组合类别, Vsadvice(I).诊疗类别) > 0 Then
          v_Nokey := '非药医嘱_' || Vsadvice(I).诊疗类别 || '_' || Nvl(Vsadvice(I).执行科室id, 0);
        Elsif Vsadvice(I).相关id Is Not Null And Vsadvice(I).诊疗类别 = 'C' Then
          If Mb_检验单独产生单据 Then
            v_Nokey := '一并采集_' || Vsadvice(I).相关id;
          Else
            v_Nokey := '一并采集_' || Mn_病人id || '_' || Mv_挂号单 || '_' || Vsadvice(I).标本部位 || '_' || Vsadvice(I).执行科室id || '_' || Vsadvice(I).操作类型 || '_' || Vsadvice(I).试管编码;
          
            --往后找检验医嘱的主行
            For J In I + 1 .. Vsadvice.Count Loop
              If Vsadvice(J).相关id Is Null Then
                v_Nokey := v_Nokey || '_' || Vsadvice(J).诊疗项目id || '_' || Nvl(Vsadvice(J).执行科室id, 0);
                Exit;
              End If;
            End Loop;
          End If;
        Elsif Vsadvice(I).相关id Is Not Null And Instr(',F,D,', Vsadvice(I).诊疗类别) > 0 Then
          v_Nokey := '非药医嘱_' || Vsadvice(I).相关id;
        Else
          v_Nokey := '非药医嘱_' || Vsadvice(I).Id;
        End If;
      End If;
    
      --开始时间不是同一天的分别产生单据
      If Mb_Starttimedef Then
        v_Nokey := v_Nokey || '_' || Substr(Vsadvice(I).开始时间, 1, 10);
      End If;
    
      --开单人不同的，默认全部分别产生单据
      v_Nokey := v_Nokey || '_' || Vsadvice(I).开嘱医生;
    
      --(忽略)不同诊断的医嘱分别产生单据
      --(忽略)启用参数：特殊药品分开发送 时，特殊药品医嘱的药品行单独生成单据号，一组医嘱分配一个号
      --(忽略)处理方条数限制应该放到最后
      If b_处方数限制 Then
        Null;
      End If;
    
      --是否离院带药
      b_离院带药 := False;
      If Instr(',5,6,', ',' || Vsadvice(I).诊疗类别 || ',') > 0 Then
        If Vsadvice(I).执行性质 = '离院带药' Then
          b_离院带药 := True;
        End If;
      Elsif Vsadvice(I).诊疗类别 = '7' Then
        For J In I + 1 .. Vsadvice.Count Loop
          If Vsadvice(J).Id = Vsadvice(I).相关id Then
            If Vsadvice(J).执行性质 = '离院带药' Then
              b_离院带药 := True;
            End If;
            Exit;
          End If;
        End Loop;
      End If;
    
      --产生医嘱记帐费用:以最新价格计算
      -----------------------------------------------------------------
      v_Sql      := Null;
      v_收费项目 := Null;
      If Instr(',5,6,7,', ',' || Vsadvice(I).诊疗类别 || ',') > 0 Then
        --药品缺省固定为正常计价,但下医嘱时指定了为自备药(院外执行)的不读取;药品不可能为叮嘱
        If Nvl(Vsadvice(I).执行性质id, 0) <> 5 Then
          v_Sql := ' Select A.ID,A.类别,D.名称 as 类别名称,RTrim(A.名称||'' ''||A.规格) as 名称,' ||
                   ' A.计算单位,A.是否变价,A.屏蔽费别,A.费用确认,A.加班加价,B.加班加价率,100 as 附术收费率,' ||
                   ' Y.门诊单位,Y.门诊包装,Y.剂量系数,Y.药房分批 as 分批,0 as 跟踪在用,B.收入项目ID,' || ' C.收据费目,1 as 数量,B.现价 as 单价,' ||
                   Nvl(Vsadvice(I).执行科室id, 0) || ' as 执行科室ID,0 as 从项,0 as 费用性质,0 as 收费方式' ||
                   ' From 收费项目目录 A,收费价目 B,收入项目 C,收费项目类别 D,药品规格 Y' ||
                   ' Where A.ID=B.收费细目ID And B.收入项目ID=C.ID And A.类别=D.编码' || ' And A.ID=Y.药品ID(+) And A.ID=:1 ' ||
                   ' And ((Sysdate Between B.执行日期 and B.终止日期) Or (Sysdate>=B.执行日期 And B.终止日期 is NULL))' ||
                   ' Order by A.编码';
        End If;
      Else
        --先删除原非药医嘱的计价(应该没有)
        r_计价.Extend;
        n_Tmp := r_计价.Count;
        r_计价(n_Tmp).医嘱id := Vsadvice(I).Id;
        r_计价(n_Tmp).删单行 := 1;
        r_计价(n_Tmp).过程名 := 1;
      
        --不计价,手工计价；叮嘱,院外执行的医嘱不读取
        If Nvl(Vsadvice(I).计价特性, 0) = 0 And Instr(',0,5,', Nvl(Vsadvice(I).执行性质id, 0)) = 0 Then
          For J In 1 .. Rs_Price.Count Loop
            If Rs_Price(J).医嘱id = Vsadvice(I).Id Then
              --对照数量为0的自动过滤掉
              If Nvl(Rs_Price(J).收费细目id, 0) <> 0 And Nvl(Rs_Price(J).数量, 0) <> 0 Then
                --(忽略:不涉及到)普通项目的变价单价要求输入，包括非跟踪在用的时价卫材医嘱
              
                --计价执行科室:只保存非药品及卫材医嘱的，药品和卫材计价的执行科室
                If Instr(',4,5,6,7,', ',' || Vsadvice(I).诊疗类别 || ',') > 0 And
                   (Instr(',5,6,7,', Rs_Price(J).收费类别) > 0 Or Rs_Price(J).收费类别 = '4' And Nvl(Rs_Price(J).在用, 0) = 1) Then
                  n_执行科室id := Nvl(Rs_Price(J).执行科室id, 0);
                  --(忽略)卫材必须设置执行科室
                Else
                  n_执行科室id := 0;
                End If;
                --药品、卫材医嘱的计价固定对应不保存；非跟踪在用的时价卫材的变价需要输入，因此要保存到计价表中
                If Instr(',4,5,6,7,', Vsadvice(I).诊疗类别) = 0 Or Vsadvice(I)
                  .诊疗类别 = '4' And Nvl(Rs_Price(J).在用, 0) = 0 And Nvl(Rs_Price(J).变价, 0) = 1 Then
                
                  r_计价.Extend;
                  n_Tmp := r_计价.Count;
                  r_计价(n_Tmp).医嘱id := Vsadvice(I).Id;
                  r_计价(n_Tmp).过程名 := 2;
                  r_计价(n_Tmp).收费细目id := Rs_Price(J).收费细目id;
                  r_计价(n_Tmp).数量 := Rs_Price(J).数量;
                  r_计价(n_Tmp).单价 := Rs_Price(J).单价;
                  r_计价(n_Tmp).从项 := Rs_Price(J).从项;
                  If n_执行科室id > 0 Then
                    r_计价(n_Tmp).执行科室id := n_执行科室id;
                  Else
                    r_计价(n_Tmp).执行科室id := Null;
                  End If;
                  r_计价(n_Tmp).费用性质 := Rs_Price(J).费用性质;
                  r_计价(n_Tmp).收费方式 := Rs_Price(J).收费方式;
                End If;
                --临时病人医嘱计价表
                If Nvl(Vsadvice(I).总量, 0) <> 0 Then
                  If v_Sql Is Not Null Then
                    v_Sql := v_Sql || ' Union ALL ';
                  End If;
                  v_Sql := v_Sql || 'Select ' || Rs_Price(J).收费细目id || ' as 收费细目ID,' || Nvl(Rs_Price(J).执行科室id, 0) ||
                           ' as 执行科室ID,' || Nvl(Rs_Price(J).数量, 0) || ' as 数量,' || Nvl(Rs_Price(J).单价, 0) || ' as 单价,' ||
                           Nvl(Rs_Price(J).从项, 0) || ' as 从项,' || Nvl(Rs_Price(J).费用性质, 0) || ' as 费用性质,' ||
                           Nvl(Rs_Price(J).收费方式, 0) || ' as 收费方式 From Dual';
                
                End If;
              End If;
            End If;
          End Loop;
        End If;
        If v_Sql Is Not Null Then
          v_Sql := ' Select A.ID,A.类别,D.名称 as 类别名称,A.名称,A.计算单位,A.是否变价,' ||
                   ' A.屏蔽费别,A.费用确认,A.加班加价,B.加班加价率,B.附术收费率,Y.门诊单位,Y.门诊包装,Y.剂量系数,' ||
                   ' Decode(A.类别,''4'',E.在用分批,Y.药房分批) as 分批,E.跟踪在用,B.收入项目ID,' ||
                   ' C.收据费目,X.数量,Decode(A.是否变价,1,X.单价,B.现价) as 单价,X.执行科室ID,X.从项,X.费用性质,X.收费方式' ||
                   ' From 收费项目目录 A,收费价目 B,收入项目 C,收费项目类别 D,材料特性 E,(' || v_Sql || ') X,药品规格 Y' ||
                   ' Where A.ID=B.收费细目ID And B.收入项目ID=C.ID And A.ID=E.材料ID(+)' ||
                   ' And A.类别=D.编码 And X.收费细目ID=A.ID And A.ID=Y.药品ID(+) and (1=1 or A.ID=:1 )' ||
                   ' And ((Sysdate Between B.执行日期 and B.终止日期) or (Sysdate>=B.执行日期 And B.终止日期 is NULL))' ||
                   ' Order by X.费用性质,X.从项,X.收费方式 Desc,A.ID';
          --一定要把主项排在前面,以便于计算和在费用记录中保持主从关系
        End If;
      End If;
    
      --汇总折扣变量初始
      v_Havesub := Null;
      v_Nonesub := Null;
      Rs_Seek   := t_Seek();
      --提前生成样本条码
      v_Cuvettenumber := Null;
      If Nvl(Vsadvice(I).执行性质id, 0) <> 0 Then
        If Vsadvice(I).诊疗类别 = 'C' Or Vsadvice(I).诊疗类别 = 'E' And Vsadvice(I).操作类型 = '6' Then
          n_采集科室id := 0;
          If Vsadvice(I).诊疗类别 = 'E' Then
            n_采集科室id := Nvl(Vsadvice(I).执行科室id, 0);
          Else
            For J In I + 1 .. Vsadvice.Count Loop
              If Vsadvice(J).Id = Vsadvice(I).相关id Then
                n_采集科室id := Nvl(Vsadvice(J).执行科室id, 0);
                Exit;
              End If;
            End Loop;
          End If;
          v_Cuvettenumber := f_Getcuvettenumber(Vsadvice(I).试管编码, Vsadvice(I).Id, Vsadvice(I).相关id, Vsadvice(I).诊疗类别,
                                                Vsadvice(I).操作类型, Vsadvice(I).执行科室id, Vsadvice(I).婴儿, Vsadvice(I).诊疗项目id,
                                                Vsadvice(I).紧急标志, Vsadvice(I).标本部位, n_采集科室id);
        End If;
      End If;
      --(忽略)诊间支付相关
      --(忽略)本科执行的自动执行：特殊医嘱不用处理
      n_执行状态 := 0;
    
      --无需计费或未计费
      If Vsadvice(I).计价特性 = 1 Then
        n_计费状态 := -1;
      Else
        n_计费状态 := 0;
      End If;
      If v_Sql Is Not Null Then
        Open c_Tmp For v_Sql
          Using In Nvl(Vsadvice(I).收费细目id, 0);
        Fetch c_Tmp Bulk Collect
          Into Rs_Money;
        Close c_Tmp;
        If Rs_Money.Count > 0 Then
          n_计费状态 := 1; --已计费
        End If;
      
        --处理收入项目级的费用明细
        If Vsadvice(I).诊疗类别 = 'F' And Nvl(Vsadvice(I).相关id, 0) <> 0 Then
          b_附加手术 := True;
        End If;
        For n_Idx In 1 .. Rs_Money.Count Loop
          --执行科室ID
          n_执行科室id := Nvl(Rs_Money(n_Idx).执行科室id, 0);
          --在原值基础上取有效的非药嘱药品及跟踪卫材的执行科室
          If Instr(',4,5,6,7,', Vsadvice(I).诊疗类别) = 0 And
             (Rs_Money(n_Idx).类别 = '4' And Nvl(Rs_Money(n_Idx).跟踪在用, 0) = 1 Or Instr(',5,6,7,', Rs_Money(n_Idx).类别) > 0) Then
            --(忽略)n_执行科室id := f_Get收费执行科室id;
            n_执行科室id := Nvl(Rs_Money(n_Idx).执行科室id, 0);
            -- Get收费执行科室ID(mlng病人ID, 0, Rs_Money(n_idx).类别, Rs_Money(n_idx).ID, 4, Val(Vsadvice(I).病人科室ID)), 0, 1, lng执行科室ID)
          End If;
        
          --分解时间
          If Vsadvice(I).分解时间 Is Not Null Then
            v_分解时间 := Vsadvice(I).分解时间;
          Else
            v_分解时间 := Vsadvice(I).分解时间_Data; --开始执行时间
          End If;
          --------------------------------------------
          --根据收费方式，确定当前收费项目是否应收费
          If Rs_Money(n_Idx).费用性质 || '_' || Rs_Money(n_Idx).Id <> Nvl(v_收费项目, 'NULL') Then
            n_收费数量  := 0;
            n_Okrowmney := n_Idx;
            --默认返回值是1,处理后可能0
            n_Tmp := f_Advicemoneymake(Mn_病人id, Nvl(Vsadvice(I).相关id, Vsadvice(I).Id), Vsadvice(I).诊疗项目id,
                                       Rs_Money(n_Idx).Id, n_执行科室id, Vsadvice(I).试管编码, Rs_Money(n_Idx).类别,
                                       Nvl(Rs_Money(n_Idx).收费方式, 0), v_分解时间, Vsadvice(I).总量, Vsadvice(I).Id, n_发送号,
                                       Rs_Money(n_Idx).数量, Vsadvice(I).计算方式, Vsadvice(I).频率, Vsadvice(I).单量, 1, 0,
                                       Vsadvice(I).诊疗类别, v_Cuvettenumber, n_费用次数);
            If n_Tmp = 0 Then
              --跳过当前收费项目(多个收入项目)
              v_收费项目 := Rs_Money(n_Idx).费用性质 || '_' || Rs_Money(n_Idx).Id;
              K          := n_Idx;
              While K Is Not Null Loop
                If Rs_Money(K).费用性质 || '_' || Rs_Money(K).Id = v_收费项目 Then
                  K := Rs_Money.Next(K);
                Else
                  Exit;
                End If;
              End Loop;
              If K Is Null Then
                --已经到了结尾跳出循环
                Exit;
              End If;
              n_Okrowmney := K;
            End If;
          
            If n_Okrowmney = n_Idx Then
              If Instr(',5,6,7', Rs_Money(n_Idx).类别) > 0 Then
                If Instr(',5,6,7', Vsadvice(I).诊疗类别) > 0 Then
                  If Vsadvice(I).诊疗类别 = '7' Then
                    n_付数 := Vsadvice(I).总量;
                    --中药药房单位按不可分零处理:每付
                    If Nvl(Vsadvice(I).可否分零, 0) = 0 Then
                      n_数量 := Vsadvice(I).单量 / Nvl(Rs_Money(n_Idx).剂量系数, 1);
                    Else
                      n_数量 := f_Intex(Vsadvice(I).单量 / Nvl(Rs_Money(n_Idx).剂量系数, 1) / Nvl(Rs_Money(n_Idx).门诊包装, 1)) *
                              Nvl(Rs_Money(n_Idx).门诊包装, 1);
                    End If;
                  Else
                    n_付数 := 1;
                    n_数量 := Vsadvice(I).总量 * Nvl(Rs_Money(n_Idx).门诊包装, 1);
                  End If;
                Else
                  n_付数 := 1;
                  --中药药房单位按不可分零处理:每付
                  --非药嘱药品计价:因为这里预定了售价数量,因此不作不分零处理
                  --对于收费对照中的药品，且为当天只收取一次，数量为费用次数*对照数量
                  If Instr(',2,3,4,5,6,7,9,', Rs_Money(n_Idx).收费方式) > 0 Then
                    If n_Other数量 > 0 Then
                      n_数量 := n_Other数量;
                    Else
                      n_数量 := n_费用次数 * Nvl(Rs_Money(n_Idx).数量, 0);
                    End If;
                  Else
                    n_数量 := Vsadvice(I).总量 * Nvl(Rs_Money(n_Idx).数量, 0);
                  End If;
                End If;
                n_数量 := n_数量;
              
                If Nvl(Rs_Money(n_Idx).是否变价, 0) = 1 Then
                  n_单价 := f_Calcdrugprice(Rs_Money(n_Idx).Id, n_执行科室id, n_付数 * n_数量, Null);
                Else
                  n_单价 := Nvl(Rs_Money(n_Idx).单价, 0);
                End If;
              Elsif Rs_Money(n_Idx).类别 = '4' And Nvl(Rs_Money(n_Idx).跟踪在用, 0) = 1 Then
                --检查卫生材料入出类别
                --  If lng卫材类别ID = 0 Then
                --   Screen.MousePointer = 0
                --      MsgBox '不能确定卫生材料单据的入出类别,请先到入出类别管理中设置！', vbInformation, gstrSysName
                --     GoTo FuncEnd
                --  end if;
                n_付数 := 1;
                If Instr(',1,2,3,4,5,6,7,9,', Rs_Money(n_Idx).收费方式) > 0 Then
                  If n_Other数量 > 0 Then
                    n_数量 := n_Other数量;
                  Else
                    n_数量 := n_费用次数 * Nvl(Rs_Money(n_Idx).数量, 0);
                  End If;
                Else
                  n_数量 := Vsadvice(I).总量 * Nvl(Rs_Money(n_Idx).数量, 0);
                End If;
                --确定时价卫材价格
                If Nvl(Rs_Money(n_Idx).是否变价, 0) = 1 Then
                  n_单价 := f_Calcdrugprice(Rs_Money(n_Idx).Id, n_执行科室id, n_数量, Null);
                Else
                  n_单价 := Nvl(Rs_Money(n_Idx).单价, 0);
                End If;
              Else
                --总量等于单次用量乘数次。一天只收一次时，有多少天要执行，就收多少次，不管单次用量（例如：每天两次）,但要管收费对照的次数


                n_付数 := 1;
                If Instr(',1,2,3,4,5,6,7,9,', Rs_Money(n_Idx).收费方式) > 0 Then
                  If n_Other数量 > 0 Then
                    n_数量 := n_Other数量;
                  Else
                    n_数量 := n_费用次数 * Nvl(Rs_Money(n_Idx).数量, 0);
                  End If;
                Else
                  n_数量 := Vsadvice(I).总量 * Nvl(Rs_Money(n_Idx).数量, 0);
                End If;
                n_单价 := Nvl(Rs_Money(n_Idx).单价, 0);
              End If;
              --(忽略)非药嘱药品及跟踪卫材的库存检查
              --发送金额
              n_应收 := n_付数 * n_数量 * n_单价;
              If b_附加手术 Then
                n_应收 := n_应收 * Nvl(Rs_Money(n_Idx).附术收费率, 100) / 100;
              End If;
            
              --处理加班加价
              If Gb_加班加价 And Nvl(Rs_Money(n_Idx).加班加价, 0) = 1 Then
                n_应收 := n_应收 * (1 + Nvl(Rs_Money(n_Idx).加班加价率, 0) / 100);
              End If;
            
              n_应收 := n_应收;
            
              --NO,序号
              p_Getcurbillset(v_Nokey, 0, -1, b_记帐, v_No, n_费用序号, n_Tmp1);
              r_费用.Extend;
              b_Bool := False;
              If Rs_Money(n_Idx).费用性质 || '_' || Rs_Money(n_Idx).Id <> v_收费项目 Then
                n_费用父号 := n_费用序号;
                If Rs_Money(n_Idx).从项 = 0 Then
                  --记录主项信息，主项肯定在从项前
                  --即使不汇总折扣，也要记录主从项关系
                  If Instr(v_Havesub || ',', ',' || Rs_Money(n_Idx).费用性质 || ',') = 0 And
                     Instr(v_Nonesub || ',', ',' || Rs_Money(n_Idx).费用性质 || ',') = 0 Then
                    n_Tmp := Null;
                    For J In 1 .. Rs_Money.Count Loop
                      If Rs_Money(J).费用性质 = Rs_Money(n_Idx).费用性质 And Rs_Money(J).从项 = 1 Then
                        n_Tmp := 1;
                        Exit;
                      End If;
                    End Loop;
                  
                    If n_Tmp = 1 Then
                      n_父序号   := n_费用序号;
                      n_父项目id := Rs_Money(n_Idx).Id;
                    
                      Rs_Seek.Extend;
                      n_Tmp := Rs_Seek.Count;
                      Rs_Seek(n_Tmp).费用性质 := Rs_Money(n_Idx).费用性质;
                      Rs_Seek(n_Tmp).主项标签 := r_费用.Count;
                      Rs_Seek(n_Tmp).主收入id := Rs_Money(n_Idx).收入项目id;
                      v_Havesub := v_Havesub || ',' || Rs_Money(n_Idx).费用性质;
                      b_Bool := True;
                    Else
                      v_Nonesub := v_Nonesub || ',' || Rs_Money(n_Idx).费用性质;
                    End If;
                  End If;
                End If;
              End If;
              --计算汇总折扣合计
              v_费别 := Mv_费别;
              If Gb_从项汇总折扣 And
                 (Rs_Money(n_Idx).从项 = 1 Or Instr(v_Havesub || ',', ',' || Rs_Money(n_Idx).费用性质 || ',') > 0) Then
                If Vsadvice(I).零费记帐 = 1 Then
                  n_实收 := 0;
                Else
                  n_实收 := n_应收;
                End If;
              
                --累计医嘱合计来计算折扣
                For J In 1 .. Rs_Seek.Count Loop
                  If Rs_Seek(J).费用性质 = Rs_Money(n_Idx).费用性质 Then
                    Rs_Seek(J).合计 := Nvl(Rs_Seek(J).合计, 0) + n_实收;
                    Exit;
                  End If;
                End Loop;
              Elsif Nvl(Rs_Money(n_Idx).屏蔽费别, 0) = 0 Then
                If Gv_动态费别 Is Not Null And Not b_记帐 Then
                  v_费别 := Mv_费别 || ',' || Gv_动态费别;
                End If;
                If Vsadvice(I).零费记帐 = 1 Then
                  n_实收 := 0;
                Else
                  If Gb_加班加价 And Nvl(Rs_Money(n_Idx).加班加价, 0) = 1 Then
                    n_Tmp := Nvl(Rs_Money(n_Idx).加班加价率, 0) / 100;
                  Else
                    n_Tmp := 0;
                  End If;
                  n_实收 := Round(f_Actualmoney(v_费别, Rs_Money(n_Idx).收入项目id, n_应收, Rs_Money(n_Idx).Id, n_执行科室id,
                                              n_付数 * n_数量, n_Tmp, v_费别), Gn_Dec);
                End If;
                If Instr(v_费别, ',') > 0 Then
                  v_费别 := Mv_费别;
                End If;
              Else
                If Vsadvice(I).零费记帐 = 1 Then
                  n_实收 := 0;
                Else
                  n_实收 := n_应收;
                End If;
              End If;
              --汇总折扣时，对主项的实收金额作特殊处理,直接记入扩展字段中
              --(忽略)医保相关字段
              --收集记帐报警类别
              If Instr(v_类别, Rs_Money(n_Idx).类别) = 0 Then
                v_类别 := v_类别 || Rs_Money(n_Idx).类别;
              End If;
              --发生时间
              If Vsadvice(I).分解时间 Is Not Null Then
                d_发生时间 := To_Date(Substr(Vsadvice(I).分解时间, 1, 19), 'YYYY-MM-DD HH24:MI:SS');
              Else
                d_发生时间 := To_Date(Substr(Vsadvice(I).分解时间_Data, 1, 19), 'YYYY-MM-DD HH24:MI:SS');
              End If;
              --因为现在不计价的医嘱不产生费用,所以传入的计价特性都为(0-正常计价)
              n_合计 := Nvl(n_合计, 0) + n_实收;
              If Not b_记帐 Then
                r_费用(r_费用.Count).过程名 := 1;
                d_登记时间 := d_Cur;
              Else
                --是否划价费用
                If Instr(',5,6,7,', Vsadvice(I).诊疗类别) > 0 Then
                  If Instr(Gv_门诊发送划价单, '5') > 0 Then
                    n_划价 := 1;
                  Else
                    n_划价 := 0;
                  End If;
                Else
                  If Instr(Gv_门诊发送划价单, Vsadvice(I).诊疗类别) > 0 Then
                    n_划价 := 1;
                  Else
                    n_划价 := 0;
                  End If;
                End If;
              
                If n_划价 = 0 Then
                  If Rs_Money(n_Idx).费用确认 = 1 Then
                    n_划价 := 1;
                  Else
                    n_划价 := 0;
                  End If;
                End If;
              
                If n_划价 = 0 Or n_执行状态 = 1 Then
                  If Nvl(Gn_消费验证, 0) <> 0 Then
                    n_记帐合计 := Nvl(n_记帐合计, 0) + n_实收;
                  End If;
                End If;
              
                --登记时间
                If n_划价 = 1 Then
                  d_登记时间 := d_Cur + 1 / 24 / 60;
                Else
                  d_登记时间 := d_Cur;
                End If;
                r_费用(r_费用.Count).过程名 := 2;
              End If;
              --暂未取发药窗口
            
              n_Tmp := r_费用.Count;
              r_费用(n_Tmp).No := v_No;
              r_费用(n_Tmp).主页id := Null;
              r_费用(n_Tmp).病人来源 := 1;
              r_费用(n_Tmp).保险编码 := Null;
              r_费用(n_Tmp).费用类型 := Null;
              r_费用(n_Tmp).保险项目否 := Null;
              r_费用(n_Tmp).保险大类id := Null;
              r_费用(n_Tmp).中药形态 := Null;
            
              r_费用(n_Tmp).序号 := n_费用序号;
              r_费用(n_Tmp).病人id := Mn_病人id;
              r_费用(n_Tmp).标识号 := Mv_门诊号;
              r_费用(n_Tmp).姓名 := Mv_姓名;
              r_费用(n_Tmp).性别 := Mv_性别;
              r_费用(n_Tmp).年龄 := Mv_年龄;
              r_费用(n_Tmp).费别 := v_费别;
              r_费用(n_Tmp).加班标志 := Null;
              r_费用(n_Tmp).婴儿费 := Vsadvice(I).婴儿;
              r_费用(n_Tmp).病人科室id := Vsadvice(I).开嘱科室id;
              r_费用(n_Tmp).开单部门id := Vsadvice(I).开嘱科室id;
              r_费用(n_Tmp).开单人 := Vsadvice(I).开嘱医生;
              If Rs_Money(n_Idx).从项 = 1 And n_父序号 > 0 Then
                r_费用(n_Tmp).从属父号 := n_父序号;
              Else
                r_费用(n_Tmp).从属父号 := Null;
              End If;
              r_费用(n_Tmp).收费细目id := Rs_Money(n_Idx).Id;
              r_费用(n_Tmp).收费类别 := Rs_Money(n_Idx).类别;
              r_费用(n_Tmp).计算单位 := Rs_Money(n_Idx).计算单位;
              r_费用(n_Tmp).付数 := n_付数;
              r_费用(n_Tmp).数次 := n_数量;
              If b_附加手术 Then
                r_费用(n_Tmp).附加标志 := 1;
              Else
                r_费用(n_Tmp).附加标志 := 0;
              End If;
              If n_执行科室id > 0 Then
                r_费用(n_Tmp).执行部门id := n_执行科室id;
              Else
                r_费用(n_Tmp).执行部门id := Null;
              End If;
              If n_费用父号 = n_费用序号 Then
                r_费用(n_Tmp).价格父号 := Null;
              Else
                r_费用(n_Tmp).价格父号 := n_费用父号;
              End If;
              r_费用(n_Tmp).收入项目id := Rs_Money(n_Idx).收入项目id;
              r_费用(n_Tmp).收据费目 := Rs_Money(n_Idx).收据费目;
              r_费用(n_Tmp).标准单价 := n_单价;
              r_费用(n_Tmp).应收金额 := n_应收;
              r_费用(n_Tmp).实收金额 := n_实收;
              r_费用(n_Tmp).发生时间 := d_发生时间;
              r_费用(n_Tmp).登记时间 := d_登记时间;
              r_费用(n_Tmp).药品摘要 := '医嘱发送';
              r_费用(n_Tmp).划价 := n_划价;
              r_费用(n_Tmp).操作员编号 := Mv_操作员编号;
              r_费用(n_Tmp).操作员姓名 := Mv_操作员姓名;
              r_费用(n_Tmp).记帐单id := Null;
              r_费用(n_Tmp).费用摘要 := Vsadvice(I).医嘱内容;
              r_费用(n_Tmp).医嘱序号 := Vsadvice(I).Id;
              r_费用(n_Tmp).频次 := Vsadvice(I).频率;
              r_费用(n_Tmp).单量 := Vsadvice(I).单量;
              r_费用(n_Tmp).用法 := Vsadvice(I).用法;
              r_费用(n_Tmp).期效 := 1;
              If b_离院带药 Then
                r_费用(n_Tmp).计价特性 := 3;
              Else
                r_费用(n_Tmp).计价特性 := Vsadvice(I).计价特性;
              End If;
              r_费用(n_Tmp).门诊标志 := 1;
              r_费用(n_Tmp).中药形态 := Null;
              r_费用(n_Tmp).备货材料 := 0;
              r_费用(n_Tmp).批次 := Zl_To_Number(Nvl(Vsadvice(I).检查方法, 0));
              --记录自动发料的SQL
              If Gb_门诊自动发料 And b_记帐 And n_划价 = 0 And Nvl(n_执行科室id, 0) <> 0 And Rs_Money(n_Idx).类别 = '4' And
                 Nvl(Rs_Money(n_Idx).跟踪在用, 0) = 1 Then
                If Instr(v_自动发料 || ';', ';' || v_No || ',' || n_执行科室id || ';') = 0 Then
                  r_发料.Extend;
                  n_Tmp := r_发料.Count;
                  r_发料(n_Tmp).Partid := n_执行科室id;
                  r_发料(n_Tmp).Bill := 25;
                  r_发料(n_Tmp).No := v_No;
                  r_发料(n_Tmp).People := Mv_操作员姓名;
                  r_发料(n_Tmp).配药人 := Mv_操作员姓名;
                  r_发料(n_Tmp).校验人 := Mv_操作员姓名;
                  r_发料(n_Tmp).发药方式 := 1;
                  r_发料(n_Tmp).发药时间 := Sysdate;
                  v_自动发料 := v_自动发料 || ';' || v_No || ',' || n_执行科室id;
                End If;
              End If;
              --(忽略)医保管控实时监测：生成费用项目记录集,以收费细目汇总
            End If;
          End If;
        End Loop;
      End If;
    
      --对医嘱金额进行汇总折扣处理
      If Gb_从项汇总折扣 And v_Havesub Is Not Null Then
      
        For J In 1 .. Rs_Seek.Count Loop
          n_Tmp := Rs_Seek(J).主项标签;
        
          v_费别 := Mv_费别;
          If Gv_动态费别 Is Not Null And Not b_记帐 Then
            v_费别 := v_费别 || ',' || Gv_动态费别;
          End If;
        
          If Vsadvice(I).零费记帐 = 1 Then
            n_实收 := 0;
          Else
            n_实收 := Round(f_Actualmoney(v_费别, Rs_Seek(J).主收入id, Rs_Seek(J).合计, 0, 0, 0, 0, v_费别), Gn_Dec);
          
          End If;
        
          If Instr(v_费别, ',') > 0 Then
            v_费别 := Mv_费别;
          End If;
          --替换费别和实收
          r_费用(n_Tmp).费别 := v_费别;
        
          n_实收 := n_实收 - Rs_Seek(J).合计; --打折差额
          r_费用(n_Tmp).实收金额 := n_实收;
        
        End Loop;
      End If;
      --产生医嘱发送记录
      -------------------------------------
      If Nvl(Vsadvice(I).执行性质id, 0) <> 0 Then
        --叮嘱不发送(给药途径，配方煎法、用法,采集方法、输血途径可能为)
      
        --(忽略)医嘱的发送合性检查提示
        --一样要产生费用NO
        p_Getcurbillset(v_Nokey, -1, 0, b_记帐, v_No, n_Tmp, n_发送序号);
        --是否一组医嘱的第一医嘱行:药疗的第一药品行为第一医嘱行
        b_First := False;
        If Instr(',5,6,7,', Vsadvice(I).诊疗类别) > 0 Then
          If Nvl(Vsadvice(I).相关id, 0) <> Nvl(Vsadvice(I - 1).相关id, 0) Then
            b_First := True;
          End If;
        Elsif Vsadvice(I).诊疗类别 = 'C' And Nvl(Vsadvice(I).相关id, 0) <> 0 Then
          If Nvl(Vsadvice(I).相关id, 0) <> Nvl(Vsadvice(I - 1).相关id, 0) Then
            b_First := True; --检验组合中的第一检验行
          End If;
        Elsif Instr(',1,2,3,4,5,', ',' || Vsadvice(I).Id_Data || ',') = 0 Then
          --排开给药途径、中药煎法、中药用法、采集方法、输血途径
          If Nvl(Vsadvice(I).相关id, 0) = 0 Then
            b_First := True;
          End If;
        End If;
        --发送数次:药品为剂量单位的总量,其它为次数
        If Vsadvice(I).诊疗类别 = '7' Then
          n_发送数次 := Vsadvice(I).总量 * Vsadvice(I).单量;
        Elsif Instr(',5,6,', Vsadvice(I).诊疗类别) > 0 Then
          n_发送数次 := Vsadvice(I).总量 * Vsadvice(I).门诊包装 * Vsadvice(I).剂量系数;
        Else
          n_发送数次 := Vsadvice(I).总量;
        End If;
      
        --首末时间
        v_分解时间 := Vsadvice(I).分解时间;
        If v_分解时间 Is Not Null Then
          d_首次时间 := To_Date(Substr(v_分解时间, 1, 19), 'YYYY-MM-DD HH24:MI:SS');
          d_末次时间 := To_Date(Substr(v_分解时间, Instr(v_分解时间, ',', -1) + 1, 19), 'YYYY-MM-DD HH24:MI:SS');
        Else
          --无法分解或为'一次性'临嘱，填为开始执行时间
          d_首次时间 := To_Date(Vsadvice(I).开始时间, 'YYYY-MM-DD HH24:MI:SS');
          d_末次时间 := d_首次时间;
        End If;
      
        If Not Gb_发送生成条形码 Then
          v_Cuvettenumber := Null;
        End If;
        r_发送.Extend;
        n_Tmp := r_发送.Count;
        r_发送(n_Tmp).医嘱id := Vsadvice(I).Id;
        r_发送(n_Tmp).发送号 := n_发送号;
        If b_记帐 Then
          r_发送(n_Tmp).记录性质 := 2;
        Else
          r_发送(n_Tmp).记录性质 := 1;
        End If;
        r_发送(n_Tmp).No := v_No;
        r_发送(n_Tmp).记录序号 := n_发送序号; --   病人医嘱发送.记录序号%Type,
        If n_发送数次 > 0 Then
          r_发送(n_Tmp).发送数次 := n_发送数次;
        Else
          r_发送(n_Tmp).发送数次 := Null;
        End If;
        r_发送(n_Tmp).首次时间 := d_首次时间;
        r_发送(n_Tmp).末次时间 := d_末次时间;
        r_发送(n_Tmp).发送时间 := d_Cur;
        r_发送(n_Tmp).执行状态 := n_执行状态;
        r_发送(n_Tmp).执行部门id := Vsadvice(I).执行科室id;
        r_发送(n_Tmp).计费状态 := n_计费状态;
        If b_First Then
          r_发送(n_Tmp).First := 1;
        Else
          r_发送(n_Tmp).First := 0;
        End If;
        r_发送(n_Tmp).样本条码 := v_Cuvettenumber;
        r_发送(n_Tmp).操作员编号 := Mv_操作员编号;
        r_发送(n_Tmp).操作员姓名 := Mv_操作员姓名;
      
        --医嘱执行计价
        For J In 1 .. Rs_Exec.Count Loop
          If Rs_Exec(J).医嘱id = Vsadvice(I).Id And Rs_Exec(J).发送号 = n_发送号 Then
            r_执行计价.Extend;
            n_Tmp := r_执行计价.Count;
            r_执行计价(n_Tmp).医嘱id := Rs_Exec(J).医嘱id;
            r_执行计价(n_Tmp).发送号 := n_发送号;
            r_执行计价(n_Tmp).要求时间 := To_Date(Rs_Exec(J).要求时间, 'YYYY-MM-DD HH24:MI:SS');
            r_执行计价(n_Tmp).收费细目id := Rs_Exec(J).收费细目id;
            r_执行计价(n_Tmp).数量 := Rs_Exec(J).数量;
            r_执行计价(n_Tmp).费用性质 := 0;
          End If;
        End Loop;
        --(忽略)血库系统调用 Zl_血液配血费用_Insert
        --(忽略)要发送的尚未签名的医嘱ID(组ID,一组中的叮嘱也会被签名)
      End If;
      --计算中药配方数
      If Vsadvice(I).Id_Data = '3' Then
        --中药用法
        n_配方数 := n_配方数 + 1;
      End If;
    End Loop;
    --(忽略)自动进行电子签名(未签名部份)
    --(忽略)医保管控实时监测
    --(忽略)调用外挂接口
    Return(1);
  End;

  --提交本次发送的HIS数据
  Procedure p_Completepatisend Is
  Begin
    p_Replacetrueno;
    For I In 1 .. r_计价.Count Loop
      If r_计价(I).过程名 = 1 Then
        Zl_病人医嘱计价_Delete(r_计价(I).医嘱id, r_计价(I).删单行);
      Else
        Zl_病人医嘱计价_Insert(r_计价(I).医嘱id, r_计价(I).收费细目id, r_计价(I).数量, r_计价(I).单价, r_计价(I).从项, r_计价(I).执行科室id, r_计价(I).费用性质,
                         r_计价(I).收费方式);
      End If;
    End Loop;
    For I In 1 .. r_费用.Count Loop
      If r_费用(I).过程名 = 1 Then
        Zl_门诊划价记录_Insert(r_费用(I).No, r_费用(I).序号, r_费用(I).病人id, r_费用(I).主页id, r_费用(I).标识号, r_费用(I).付款方式, r_费用(I).姓名,
                         r_费用(I).性别, r_费用(I).年龄, r_费用(I).费别, r_费用(I).加班标志, r_费用(I).病人科室id, r_费用(I).开单部门id, r_费用(I).开单人,
                         r_费用(I).从属父号, r_费用(I).收费细目id, r_费用(I).收费类别, r_费用(I).计算单位, r_费用(I).发药窗口, r_费用(I).付数, r_费用(I).数次,
                         r_费用(I).附加标志, r_费用(I).执行部门id, r_费用(I).价格父号, r_费用(I).收入项目id, r_费用(I).收据费目, r_费用(I).标准单价,
                         r_费用(I).应收金额, r_费用(I).实收金额, r_费用(I).发生时间, r_费用(I).登记时间, r_费用(I).药品摘要, r_费用(I).操作员姓名,
                         r_费用(I).费用摘要, r_费用(I).医嘱序号, r_费用(I).频次, r_费用(I).单量, r_费用(I).用法, r_费用(I).期效, r_费用(I).计价特性,
                         r_费用(I).病人来源, r_费用(I).保险编码, r_费用(I).费用类型, r_费用(I).保险项目否, r_费用(I).保险大类id, r_费用(I).中药形态,
                         r_费用(I).备货材料, r_费用(I).批次);
      Else
        Zl_门诊记帐记录_Insert(r_费用(I).No, r_费用(I).序号, r_费用(I).病人id, r_费用(I).标识号, r_费用(I).姓名, r_费用(I).性别, r_费用(I).年龄,
                         r_费用(I).费别, r_费用(I).加班标志, r_费用(I).婴儿费, r_费用(I).病人科室id, r_费用(I).开单部门id, r_费用(I).开单人,
                         r_费用(I).从属父号, r_费用(I).收费细目id, r_费用(I).收费类别, r_费用(I).计算单位, r_费用(I).付数, r_费用(I).数次, r_费用(I).附加标志,
                         r_费用(I).执行部门id, r_费用(I).价格父号, r_费用(I).收入项目id, r_费用(I).收据费目, r_费用(I).标准单价, r_费用(I).应收金额,
                         r_费用(I).实收金额, r_费用(I).发生时间, r_费用(I).登记时间, r_费用(I).药品摘要, r_费用(I).划价, r_费用(I).操作员编号,
                         r_费用(I).操作员姓名, r_费用(I).记帐单id, r_费用(I).费用摘要, r_费用(I).医嘱序号, r_费用(I).频次, r_费用(I).单量, r_费用(I).用法,
                         r_费用(I).期效, r_费用(I).计价特性, r_费用(I).门诊标志, r_费用(I).中药形态, r_费用(I).备货材料, r_费用(I).批次);
      End If;
    End Loop;
  
    For I In 1 .. r_发送.Count Loop
      Zl_门诊医嘱发送_Insert(r_发送(I).医嘱id, r_发送(I).发送号, r_发送(I).记录性质, r_发送(I).No, r_发送(I).记录序号, r_发送(I).发送数次, r_发送(I).首次时间,
                       r_发送(I).末次时间, r_发送(I).发送时间, r_发送(I).执行状态, r_发送(I).执行部门id, r_发送(I).计费状态, r_发送(I).First,
                       r_发送(I).样本条码, r_发送(I).操作员编号, r_发送(I).操作员姓名);
    
    End Loop;
  
    For I In 1 .. r_执行计价.Count Loop
      Zl_医嘱执行计价_Insert(r_执行计价(I).医嘱id, r_执行计价(I).发送号, r_执行计价(I).要求时间, r_执行计价(I).收费细目id, r_执行计价(I).数量, r_执行计价(I).费用性质);
    End Loop;
  
    For I In 1 .. r_发料.Count Loop
      Zl_材料收发记录_处方发料(r_发料(I).Partid, r_发料(I).Bill, r_发料(I).No, r_发料(I).People, r_发料(I).配药人, r_发料(I).校验人, r_发料(I).发药方式,
                     r_发料(I).发药时间);
    End Loop;
  Exception
    When Others Then
      Rollback;
      p_Errcenter(SQLErrM);
      --zl_ErrorCenter(SQLCode, SQLErrM);
  End;
Begin
  --传入参数
  Select Extractvalue(Value(A), 'IN/BRID') As 病人id, Extractvalue(Value(A), 'IN/JZID') As 就诊id,
         Extractvalue(Value(A), 'IN/YZIDS') As 医嘱ids, Extractvalue(Value(A), 'IN/ZD') As 站点,
         To_Number(Extractvalue(Value(A), 'IN/JZD')) As 记帐, Extractvalue(Value(A), 'IN/CZYXM') As 操作员,
         Extractvalue(Value(A), 'IN/CZYBH') As 操作员编号, To_Number(Extractvalue(Value(A), 'IN/JBJJ')) As 加班加价,
         To_Number(Extractvalue(Value(A), 'IN/CLLIS')) As 调用, To_Number(Extractvalue(Value(A), 'IN/FHLISDATA')) As 返回
  Into n_病人id, n_就诊id, v_医嘱ids, v_站点, n_记帐, v_操作员姓名, v_操作员编号, n_加班加价, n_调用, n_返回
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  I := f_Main(v_站点, n_就诊id, n_病人id, v_医嘱ids, n_加班加价, v_操作员编号, v_操作员姓名);
  p_Load;
  I := f_Loadadvicesend;
  If I = 1 Then
    I := f_Sendadvice(n_记帐);
    p_Completepatisend;
    p_Lis接口(n_调用, n_返回, x_t);
  End If;
  If x_t Is Null Then
    v_Tmp   := '<OUTPUT><ERROR><MSG></MSG></ERROR></OUTPUT>';
    Xml_Out := Xmltype(v_Tmp);
  Else
    Xml_Out := x_t;
  End If;
Exception
  When Others Then
    v_Tmp   := '<OUTPUT><ERROR><MSG>错误信息：' || SQLErrM || '</MSG></ERROR></OUTPUT>';
    Xml_Out := Xmltype(v_Tmp);
	zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Advicesend;
/

--113206:胡俊勇,2018-01-08,区卫妇幼专版工作站接口
CREATE OR REPLACE Procedure Zl_Third_Advicesavesend
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:病人生成医嘱发送医嘱(检查检验)，一个病人调用一次
  --入参:Xml_In:
  --特殊说明：入参结构和Zl_Third_Advicesave入参数相同
  --           除此之外在<IN> 结点下增加<FSXGXX>结点

  --  <IN>
  --   <///...>......... Zl_Third_Advicesave入参
  --   <FSXGXX> 发送相关信息
  --      <CZYBH></CZYBH> 操作员编号
  --      <JZD>0</JZD> 是否发送为记帐单，0-划价单，1-记帐单
  --      <JBJJ></JBJJ>加班加价 由外部传入决定
  --      <CLLIS></CLLIS>处理LIS申请，定决是否要在过程内部调用LIS接口， 0-不处理，1-要处理
  --      <FHLISDATA></FHLISDATA>是否需要返回LIS申请信息，0-不返回，1-返回
  --   </FSXGXX>
  --  </IN>

  --出参:Xml_Out，生成的医嘱ID串，错误信息
  --  <OUTPUT>
  --    <YZIDS>1234,41234,64645,...</YZIDS>医嘱ID串，逗号分割
  --    <LISAPP>C:44271,E:44272;C:44273,E:44274</LISAPP>检验医嘱信息，固定格式：类别:医嘱ID,类别:医嘱ID;....
  --    <LISDATA></LISDATA>新版LIS检验信息，返回值
  --         LISDATA 此结点的内容，为 Zl_Thrid_Sendlisapplication 过程的 入参数，
  --         结点内容可以有行<IN>XXX1</IN><IN>XXX2</IN>.....
  --    <ERROR>
  --      <MSG>错误信息</MSG>
  --    </ERROR>
  --  </OUTPUT>
  --------------------------------

  v_Tmp     Varchar(32767);
  v_医嘱ids Varchar2(32767);
  x_Tmp     Xmltype;
  x_Par     Xmltype;
  v_Err_Msg Varchar(2000);
  Err_Item Exception;

Begin

  --调用医嘱保存过程
  Zl_Third_Advicesave(Xml_In, x_Tmp); 
  
  --获取保存后的医嘱IDs串
  Select Extractvalue(Value(A), 'OUTPUT/YZIDS') As 医嘱ids, Extractvalue(Value(A), 'OUTPUT/ERROR/MSG') As 错误信息
  Into v_医嘱ids, v_Err_Msg
  From Table(Xmlsequence(Extract(x_Tmp, 'OUTPUT'))) A;

  If v_Err_Msg Is Not Null Then
    Raise Err_Item;
  End If;
  x_Tmp := Null;

  --重新生成发送接口的入参
  Select Xmlelement("IN",
                     Xmlforest(b.病人id As "BRID", b.就诊id As "JZID", v_医嘱ids As "YZIDS", b.操作员 As "CZYXM",
                                b.操作员编号 As "CZYBH", b.站点 As "ZD", b.是否发送记帐单 As "JZD", b.加班加价 As "JBJJ", b.处理lis申请 As "CLLIS",
                                b.Lis申请信息 As "FHLISDATA")) As 数据
  Into x_Par
  From Xmltable('$a/IN' Passing Xml_In As "a" Columns 病人id Number(18) Path 'BRID', 就诊id Number(18) Path 'JZID',
                 操作员 Varchar2(20) Path 'CZYXM', 站点 Varchar2(1) Path 'ZD', 操作员编号 Varchar2(20) Path 'FSXGXX/CZYBH',
                 是否发送记帐单 Number(1) Path 'FSXGXX/JZD', 加班加价 Number(1) Path 'FSXGXX/JBJJ',
                 处理lis申请 Number(1) Path 'FSXGXX/CLLIS', Lis申请信息 Number(1) Path 'FSXGXX/FHLISDATA') B;

  Zl_Third_Advicesend(x_Par, x_Tmp);

  Xml_Out := x_Tmp;
Exception
  When Err_Item Then
    v_Tmp   := '<OUTPUT><ERROR><MSG>' || v_Err_Msg || '</MSG></ERROR></OUTPUT>';
    Xml_Out := Xmltype(v_Tmp);
  When Others Then
    v_Tmp   := '<OUTPUT><ERROR><MSG>错误信息：' || SQLErrM || '</MSG></ERROR></OUTPUT>';
    Xml_Out := Xmltype(v_Tmp);
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Advicesavesend;
/

--113206:胡俊勇,2018-01-08,区卫妇幼专版工作站接口
CREATE OR REPLACE Procedure Zl_Third_Revokeoutadvice
( 
  Xml_In  In Xmltype, 
  Xml_Out Out Xmltype 
) Is 
  -------------------------------------------------------------------------------------------------- 
  --功能:作废门诊医嘱 
  --入参:Xml_In: 
  --  <IN> 
  --  <YZID></YZID>医嘱ID --主医嘱ID 
  --  <CZYXM></CZYXM> 操作员姓名 
  --  <CZYBH></CZYBH> 操作员编号 
  --  <CLLIS></CLLIS>处理LIS申请 0-不处理，1-要处理 
  --  <JYXM></JYXM> 检验项目，是否是检验项目，0-不是检验，1-是检验 
  --  </IN> 
  --出参:Xml_Out 
  --  <OUTPUT> 
  --    <ERROR> 
  --      <MSG>错误信息</MSG> 
  --    </ERROR> 
  --  </OUTPUT> 
  -------------------------------------------------------------------------------------------------- 
  v_Tmp   Varchar2(2000); 
  x_T1    Xmltype; 
  x_T2    Xmltype; 
  v_Error Varchar(255); 
  Err_Custom Exception; 
Begin 
  --参数名：病人接诊控制，模块：1260，忽略 
  For R In (Select Extractvalue(Value(A), 'IN/YZID') As 医嘱id, Extractvalue(Value(A), 'IN/CZYXM') As 操作员姓名, 
                   Extractvalue(Value(A), 'IN/CZYBH') As 操作员编号, Extractvalue(Value(A), 'IN/CLLIS') As 处理lis, 
                   Extractvalue(Value(A), 'IN/JYXM') As 检验项目 
            From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A) Loop 
    Zl_病人医嘱记录_作废(r.医嘱id, r.操作员编号, r.操作员姓名); 
    Zl_病人诊断医嘱_Delete(r.医嘱id); 
    If r.检验项目 = 1 And r.处理lis = 1 Then 
      --调用LIS处理接口，要用动态SQL 
      Begin 
        x_T1 := Xmltype('<IN><TYPE>1</TYPE><ADVICE><SQID>' || r.医嘱id || '</SQID></ADVICE></IN>'); 
        Execute Immediate 'Begin Zl_Thrid_Sendlisapplication(:1,:2); End;' 
          Using In x_T1, Out x_T2; 
        If x_T2 Is Not Null Then 
          Select Extractvalue(Value(A), 'OUTPUT/ERROR/MSG') 
          Into v_Error 
          From Table(Xmlsequence(Extract(x_T2, 'OUTPUT'))) A; 
          If v_Error Is Not Null Then 
            Raise Err_Custom; 
          End If; 
        End If; 
      Exception 
        When Others Then 
          v_Error := '调用LIS检验撤消接口出错。'; 
          Raise Err_Custom; 
      End; 
    End If; 
  End Loop; 
  Xml_Out := Xmltype('<OUTPUT><ERROR><MSG></MSG></ERROR></OUTPUT>'); 
Exception 
  When Err_Custom Then 
    v_Tmp   := '<OUTPUT><ERROR><MSG>' || v_Error || '</MSG></ERROR></OUTPUT>'; 
    Xml_Out := Xmltype(v_Tmp); 
  When Others Then 
    v_Tmp   := '<OUTPUT><ERROR><MSG>错误信息：' || SQLErrM || '</MSG></ERROR></OUTPUT>'; 
    Xml_Out := Xmltype(v_Tmp); 
	zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Revokeoutadvice;
/

--113206:胡俊勇,2018-01-08,区卫妇幼专版工作站接口
CREATE OR REPLACE Procedure Zl_Third_Getapplist
( 
  Xml_In  In Xmltype, 
  Xml_Out Out Xmltype 
) Is 
  -------------------------------------------------------------------------------------------------- 
  --功能:获取病人已经申请的检查检验项目 
  --入参:Xml_In: 
  --  <IN> 
  --   <GHDH></GHDH>挂号单号 
  --  </IN> 
  --出参:Xml_Out 
  --  <OUTPUT> 
  --     <ITEM> 
  --       <ID></ID>医嘱ID，主医嘱ID 
  --       <XMMC></XMMC>项目名称 
  --       <JG></JG> 结果 
  --       <ZT></ZT>状态 
  --     </ITEM> 
  --  </OUTPUT> 
  -------------------------------------------------------------------------------------------------- 
  v_Tmp   Varchar2(2000); 
  v_No    Varchar2(20); 
  v_Error Varchar(255); 
  Err_Custom Exception; 
Begin 
  Xml_Out := Xmltype('<OUTPUT></OUTPUT>'); 
  Select Extractvalue(Value(A), 'IN/GHDH') Into v_No From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A; 
  For R In (Select a.Id, a.医嘱内容 As 名称, Null As 结果, Decode(b.执行状态, 1, '完全执行', 2, '拒绝执行', 3, '正在执行', '已申请') As 状态 
            From 病人医嘱记录 A, 病人医嘱发送 B, 诊疗项目目录 C 
            Where a.Id = b.医嘱id And a.诊疗项目id = c.Id And a.医嘱状态 = 8 And 
                  (a.诊疗类别 = 'D' And a.相关id Is Null Or a.诊疗类别 = 'E' And c.操作类型 = '6') And a.挂号单 = v_No 
            Order By a.序号) Loop 
    v_Tmp := '<ITEM>'; 
    v_Tmp := v_Tmp || '<ID>' || r.Id || '</ID>'; 
    v_Tmp := v_Tmp || '<XMMC>' || r.名称 || '</XMMC>'; 
    v_Tmp := v_Tmp || '<JG>' || r.结果 || '</JG>'; 
    v_Tmp := v_Tmp || '<ZT>' || r.状态 || '</ZT>'; 
    v_Tmp := v_Tmp || '</ITEM>'; 
    Select Appendchildxml(Xml_Out, '/OUTPUT', Xmltype(v_Tmp)) Into Xml_Out From Dual; 
  End Loop; 
Exception 
  When Err_Custom Then 
    v_Tmp   := '<OUTPUT><ERROR><MSG>' || v_Error || '</MSG></ERROR></OUTPUT>'; 
    Xml_Out := Xmltype(v_Tmp); 
  When Others Then 
    v_Tmp   := '<OUTPUT><ERROR><MSG>错误信息：' || SQLErrM || '</MSG></ERROR></OUTPUT>'; 
    Xml_Out := Xmltype(v_Tmp); 
	zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getapplist;
/

--113206:胡俊勇,2018-01-08,区卫妇幼专版工作站接口
CREATE OR REPLACE Procedure Zl_Third_Adviceedit
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --功能：单条医嘱编辑功能
  --注意：对于日期类别的变量统一格式：2017-09-05 09:12:08
  --Xml 
  --<IN>
  --<DYFS></DYFS> 调用方式：1-根据传入医嘱ID查询某条医嘱，2-保存更新后医嘱
  --<ZYZID></ZYZID> 主医嘱ID:当调用查询时始用
  --<YZNR> 医嘱内容,保存医嘱时需传入
  --  <ROW>
  --    <ID></ID> ID  NUMBER
  --    <XGID></XGID> 相关ID  NUMBER
  --    <XH></XH> 序号  NUMBER
  --    <YZZT></YZZT> 医嘱状态  NUMBER
  --    <YZQX></YZQX> 医嘱期效  NUMBER
  --    <ZLXMID></ZLXMID> 诊疗项目ID  NUMBER
  --    <SFXMID></SFXMID> 收费细目ID  NUMBER
  --    <TS></TS> 天数  NUMBER
  --    <DCYL></DCYL> 单次用量  NUMBER
  --    <ZGYL></ZGYL> 总给予量  NUMBER
  --    <YZNR></YZNR> 医嘱内容  VARCHAR2
  --    <YSZT></YSZT> 医生嘱托  VARCHAR2
  --    <BBBW></BBBW> 标本部位  VARCHAR2
  --    <ZXPC></ZXPC> 执行频次  VARCHAR2
  --    <PLCS></PLCS> 频率次数  NUMBER
  --    <PLJG></PLJG> 频率间隔  NUMBER
  --    <JGDW></JGDW> 间隔单位  VARCHAR2
  --    <ZXSJFA></ZXSJFA> 执行时间方案  VARCHAR2
  --    <JJTX></JJTX> 计价特性  NUMBER
  --    <ZXKSID></ZXKSID> 执行科室ID  NUMBER
  --    <ZXXZ></ZXXZ> 执行性质  NUMBER
  --    <JJBZ></JJBZ> 紧急标志  NUMBER
  --    <KSZXSJ></KSZXSJ> 开始执行时间  DATE
  --    <ZXZZSJ></ZXZZSJ> 执行终止时间  DATE
  --    <BRKSID></BRKSID> 病人科室ID  NUMBER
  --    <KZKSID></KZKSID> 开嘱科室ID  NUMBER
  --    <KZYS></KZYS> 开嘱医生  VARCHAR2
  --    <KZSJ></KZSJ> 开嘱时间  DATE
  --    <JCFF></JCFF> 检查方法  VARCHAR2
  --    <ZXBJ></ZXBJ> 执行标记  NUMBER
  --    <KFFL></KFFL> 可否分零  NUMBER
  --    <ZY></ZY> 摘要  VARCHAR2
  --    <CYZXM></CYZXM> 操员作姓名   VARCHAR2，即当前操作员；查询时返回为空，保存医嘱时需从外部传入
  --    <LFJZ></LFJZ> 零费记帐  NUMBER
  --    <YYMD></YYMD> 用药目的  NUMBER
  --    <YYLY></YYLY> 用药理由  VARCHAR2
  --    <SHZT></SHZT> 审核状态  NUMBER
  --    <CLSM></CLSM> 超量说明  VARCHAR2
  --    <SCYL></SCYL> 首次用量  NUMBER
  --    <SSQK></SSQK> 手术情况  NUMBER
  --    <ZHXMID></ZHXMID> 组合项目ID  NUMBER
  --    <PSJG></PSJG> 皮试结果  VARCHAR2
  --  </ROW>
  --  ...
  --  ...
  --</YZNR>
  --</IN>

  --Xml_Out--当调用功能为查询时有用
  --<OUTPUT>
  --<YZNR> 医嘱内容保存时的结节内容相同，当调用功能为查询时有用，否则无此结点
  --</YZNR>
  --  <ERROR>
  --    <MSG></MSG>  //错误捕获
  --  </ERROR>
  --</OUTPUT>

  Type r_医嘱 Is Record(
    ID           病人医嘱记录.Id%Type,
    相关id       病人医嘱记录.相关id%Type,
    序号         病人医嘱记录.序号%Type,
    医嘱状态     病人医嘱记录.医嘱状态%Type,
    医嘱期效     病人医嘱记录.医嘱期效%Type,
    诊疗项目id   病人医嘱记录.诊疗项目id%Type,
    收费细目id   病人医嘱记录.收费细目id%Type,
    天数         病人医嘱记录.天数%Type,
    单次用量     病人医嘱记录.单次用量%Type,
    总给予量     病人医嘱记录.总给予量%Type,
    医嘱内容     病人医嘱记录.医嘱内容%Type,
    医生嘱托     病人医嘱记录.医生嘱托%Type,
    标本部位     病人医嘱记录.标本部位%Type,
    执行频次     病人医嘱记录.执行频次%Type,
    频率次数     病人医嘱记录.频率次数%Type,
    频率间隔     病人医嘱记录.频率间隔%Type,
    间隔单位     病人医嘱记录.间隔单位%Type,
    执行时间方案 病人医嘱记录.执行时间方案%Type,
    计价特性     病人医嘱记录.计价特性%Type,
    执行科室id   病人医嘱记录.执行科室id%Type,
    执行性质     病人医嘱记录.执行性质%Type,
    紧急标志     病人医嘱记录.紧急标志%Type,
    开始执行时间 病人医嘱记录.开始执行时间%Type,
    执行终止时间 病人医嘱记录.执行终止时间%Type,
    病人科室id   病人医嘱记录.病人科室id%Type,
    开嘱科室id   病人医嘱记录.开嘱科室id%Type,
    开嘱医生     病人医嘱记录.开嘱医生%Type,
    开嘱时间     病人医嘱记录.开嘱时间%Type,
    检查方法     病人医嘱记录.检查方法%Type,
    执行标记     病人医嘱记录.执行标记%Type,
    可否分零     病人医嘱记录.可否分零%Type,
    摘要         病人医嘱记录.摘要%Type,
    操员作姓名   病人医嘱状态.操作人员%Type,
    零费记帐     病人医嘱记录.零费记帐%Type,
    用药目的     病人医嘱记录.用药目的%Type,
    用药理由     病人医嘱记录.用药理由%Type,
    审核状态     病人医嘱记录.审核状态%Type,
    超量说明     病人医嘱记录.超量说明%Type,
    首次用量     病人医嘱记录.首次用量%Type,
    手术情况     病人医嘱记录.手术情况%Type,
    组合项目id   病人医嘱记录.组合项目id%Type,
    皮试结果     病人医嘱记录.皮试结果%Type);
  r_Item     r_医嘱;
  
  n_医嘱id   病人医嘱记录.Id%Type;
  n_调用方式 Number;
  x_Templet  Xmltype;
  v_Temp     Varchar2(32767); --临时XML

  Cursor c_医嘱 Is
    Select a.Id, a.相关id, a.序号, a.医嘱状态, a.医嘱期效, a.诊疗项目id, a.收费细目id, a.天数, a.单次用量, a.总给予量, a.医嘱内容, a.医生嘱托, a.标本部位, a.执行频次,
           a.频率次数, a.频率间隔, a.间隔单位, a.执行时间方案, a.计价特性, a.执行科室id, a.执行性质, a.紧急标志, a.开始执行时间, a.执行终止时间, a.病人科室id, a.开嘱科室id,
           a.开嘱医生, a.开嘱时间, a.检查方法, a.执行标记, a.可否分零, a.摘要, Null As 操员作姓名, a.零费记帐, a.用药目的, a.用药理由, a.审核状态, a.超量说明, a.首次用量,
           a.手术情况, a.组合项目id, a.皮试结果
    From 病人医嘱记录 A
    Where a.Id = n_医嘱id Or a.相关id = n_医嘱id
    Order By a.序号;

Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');
  Select Extractvalue(Value(A), 'IN/DYFS'), Extractvalue(Value(A), 'IN/ZYZID')
  Into n_调用方式, n_医嘱id
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  If n_调用方式 = 1 Then
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype('<YZNR></YZNR>')) Into x_Templet From Dual;
    Open c_医嘱;
    Loop
      Fetch c_医嘱
        Into r_Item;
      Exit When c_医嘱%NotFound;
      v_Temp := '<ROW>';
      v_Temp := v_Temp || '<ID>' || r_Item.Id || '</ID>';
      v_Temp := v_Temp || '<XGID>' || r_Item.相关id || '</XGID>';
      v_Temp := v_Temp || '<XH>' || r_Item.序号 || '</XH>';
      v_Temp := v_Temp || '<YZZT>' || r_Item.医嘱状态 || '</YZZT>';
      v_Temp := v_Temp || '<YZQX>' || r_Item.医嘱期效 || '</YZQX>';
      v_Temp := v_Temp || '<ZLXMID>' || r_Item.诊疗项目id || '</ZLXMID>';
      v_Temp := v_Temp || '<SFXMID>' || r_Item.收费细目id || '</SFXMID>';
      v_Temp := v_Temp || '<TS>' || r_Item.天数 || '</TS>';
      v_Temp := v_Temp || '<DCYL>' || r_Item.单次用量 || '</DCYL>';
      v_Temp := v_Temp || '<ZGYL>' || r_Item.总给予量 || '</ZGYL>';
      v_Temp := v_Temp || '<YZNR>' || r_Item.医嘱内容 || '</YZNR>';
      v_Temp := v_Temp || '<YSZT>' || r_Item.医生嘱托 || '</YSZT>';
      v_Temp := v_Temp || '<BBBW>' || r_Item.标本部位 || '</BBBW>';
      v_Temp := v_Temp || '<ZXPC>' || r_Item.执行频次 || '</ZXPC>';
      v_Temp := v_Temp || '<PLCS>' || r_Item.频率次数 || '</PLCS>';
      v_Temp := v_Temp || '<PLJG>' || r_Item.频率间隔 || '</PLJG>';
      v_Temp := v_Temp || '<JGDW>' || r_Item.间隔单位 || '</JGDW>';
      v_Temp := v_Temp || '<ZXSJFA>' || r_Item.执行时间方案 || '</ZXSJFA>';
      v_Temp := v_Temp || '<JJTX>' || r_Item.计价特性 || '</JJTX>';
      v_Temp := v_Temp || '<ZXKSID>' || r_Item.执行科室id || '</ZXKSID>';
      v_Temp := v_Temp || '<ZXXZ>' || r_Item.执行性质 || '</ZXXZ>';
      v_Temp := v_Temp || '<JJBZ>' || r_Item.紧急标志 || '</JJBZ>';
      v_Temp := v_Temp || '<KSZXSJ>' || To_Char(r_Item.开始执行时间, 'yyyy-mm-dd hh24:mi:ss') || '</KSZXSJ>';
      v_Temp := v_Temp || '<ZXZZSJ>' || To_Char(r_Item.执行终止时间, 'yyyy-mm-dd hh24:mi:ss') || '</ZXZZSJ>';
      v_Temp := v_Temp || '<BRKSID>' || r_Item.病人科室id || '</BRKSID>';
      v_Temp := v_Temp || '<KZKSID>' || r_Item.开嘱科室id || '</KZKSID>';
      v_Temp := v_Temp || '<KZYS>' || r_Item.开嘱医生 || '</KZYS>';
      v_Temp := v_Temp || '<KZSJ>' || To_Char(r_Item.开嘱时间, 'yyyy-mm-dd hh24:mi:ss') || '</KZSJ>';
      v_Temp := v_Temp || '<JCFF>' || r_Item.检查方法 || '</JCFF>';
      v_Temp := v_Temp || '<ZXBJ>' || r_Item.执行标记 || '</ZXBJ>';
      v_Temp := v_Temp || '<KFFL>' || r_Item.可否分零 || '</KFFL>';
      v_Temp := v_Temp || '<ZY>' || r_Item.摘要 || '</ZY>';
      v_Temp := v_Temp || '<CYZXM>' || r_Item.操员作姓名 || '</CYZXM>';
      v_Temp := v_Temp || '<LFJZ>' || r_Item.零费记帐 || '</LFJZ>';
      v_Temp := v_Temp || '<YYMD>' || r_Item.用药目的 || '</YYMD>';
      v_Temp := v_Temp || '<YYLY>' || r_Item.用药理由 || '</YYLY>';
      v_Temp := v_Temp || '<SHZT>' || r_Item.审核状态 || '</SHZT>';
      v_Temp := v_Temp || '<CLSM>' || r_Item.超量说明 || '</CLSM>';
      v_Temp := v_Temp || '<SCYL>' || r_Item.首次用量 || '</SCYL>';
      v_Temp := v_Temp || '<SSQK>' || r_Item.手术情况 || '</SSQK>';
      v_Temp := v_Temp || '<ZHXMID>' || r_Item.组合项目id || '</ZHXMID>';
      v_Temp := v_Temp || '<PSJG>' || r_Item.皮试结果 || '</PSJG>';
      v_Temp := v_Temp || '</ROW>';
      Select Appendchildxml(x_Templet, '/OUTPUT/YZNR', Xmltype(v_Temp)) Into x_Templet From Dual;
    End Loop;
    Close c_医嘱;
    Xml_Out := x_Templet;
  End If;

  If n_调用方式 = 2 Then
    For R In (Select Extractvalue(Value(A), 'ROW/ID') As ID, Extractvalue(Value(A), 'ROW/XGID') As 相关id,
                     Extractvalue(Value(A), 'ROW/XH') As 序号, Extractvalue(Value(A), 'ROW/YZZT') As 医嘱状态,
                     Extractvalue(Value(A), 'ROW/YZQX') As 医嘱期效, Extractvalue(Value(A), 'ROW/ZLXMID') As 诊疗项目id,
                     Extractvalue(Value(A), 'ROW/SFXMID') As 收费细目id, Extractvalue(Value(A), 'ROW/TS') As 天数,
                     Extractvalue(Value(A), 'ROW/DCYL') As 单次用量, Extractvalue(Value(A), 'ROW/ZGYL') As 总给予量,
                     Extractvalue(Value(A), 'ROW/YZNR') As 医嘱内容, Extractvalue(Value(A), 'ROW/YSZT') As 医生嘱托,
                     Extractvalue(Value(A), 'ROW/BBBW') As 标本部位, Extractvalue(Value(A), 'ROW/ZXPC') As 执行频次,
                     Extractvalue(Value(A), 'ROW/PLCS') As 频率次数, Extractvalue(Value(A), 'ROW/PLJG') As 频率间隔,
                     Extractvalue(Value(A), 'ROW/JGDW') As 间隔单位, Extractvalue(Value(A), 'ROW/ZXSJFA') As 执行时间方案,
                     Extractvalue(Value(A), 'ROW/JJTX') As 计价特性, Extractvalue(Value(A), 'ROW/ZXKSID') As 执行科室id,
                     Extractvalue(Value(A), 'ROW/ZXXZ') As 执行性质, Extractvalue(Value(A), 'ROW/JJBZ') As 紧急标志,
                     To_Date(Extractvalue(Value(A), 'ROW/KSZXSJ'), 'yyyy-mm-dd hh24:mi:ss') As 开始执行时间,
                     To_Date(Extractvalue(Value(A), 'ROW/ZXZZSJ'), 'yyyy-mm-dd hh24:mi:ss') As 执行终止时间,
                     Extractvalue(Value(A), 'ROW/BRKSID') As 病人科室id, Extractvalue(Value(A), 'ROW/KZKSID') As 开嘱科室id,
                     Extractvalue(Value(A), 'ROW/KZYS') As 开嘱医生,
                     To_Date(Extractvalue(Value(A), 'ROW/KZSJ'), 'yyyy-mm-dd hh24:mi:ss') As 开嘱时间,
                     Extractvalue(Value(A), 'ROW/JCFF') As 检查方法, Extractvalue(Value(A), 'ROW/ZXBJ') As 执行标记,
                     Extractvalue(Value(A), 'ROW/KFFL') As 可否分零, Extractvalue(Value(A), 'ROW/ZY') As 摘要,
                     Extractvalue(Value(A), 'ROW/CYZXM') As 操员作姓名, Extractvalue(Value(A), 'ROW/LFJZ') As 零费记帐,
                     Extractvalue(Value(A), 'ROW/YYMD') As 用药目的, Extractvalue(Value(A), 'ROW/YYLY') As 用药理由,
                     Extractvalue(Value(A), 'ROW/SHZT') As 审核状态, Extractvalue(Value(A), 'ROW/CLSM') As 超量说明,
                     Extractvalue(Value(A), 'ROW/SCYL') As 首次用量, Extractvalue(Value(A), 'ROW/SSQK') As 手术情况,
                     Extractvalue(Value(A), 'ROW/ZHXMID') As 组合项目id, Extractvalue(Value(A), 'ROW/PSJG') As 皮试结果
              From Table(Xmlsequence(Extract(Xml_In, 'IN/YZNR/ROW'))) A) Loop
    
      Zl_病人医嘱记录_Update(r.Id, r.相关id, r.序号, r.医嘱状态, r.医嘱期效, r.诊疗项目id, r.收费细目id, r.天数, r.单次用量, r.总给予量, r.医嘱内容, r.医生嘱托,
                       r.标本部位, r.执行频次, r.频率次数, r.频率间隔, r.间隔单位, r.执行时间方案, r.计价特性, r.执行科室id, r.执行性质, r.紧急标志, r.开始执行时间,
                       r.执行终止时间, r.病人科室id, r.开嘱科室id, r.开嘱医生, r.开嘱时间, r.检查方法, r.执行标记, r.可否分零, r.摘要, r.操员作姓名, r.零费记帐,
                       r.用药目的, r.用药理由, r.审核状态, r.超量说明, r.首次用量, r.手术情况, r.组合项目id, r.皮试结果);
    
    End Loop;
    Xml_Out := Xmltype('<OUTPUT><ERROR><MSG></MSG></ERROR></OUTPUT>');
  End If;
Exception
  When Others Then
    v_Temp := '<ERROR><MSG>' || SQLErrM || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Xml_Out := x_Templet;
	zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Adviceedit;
/

--113206:胡俊勇,2018-01-08,区卫妇幼专版工作站接口
CREATE OR REPLACE Procedure Zl_Third_adviceDelete
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:医嘱支传入一批医嘱进行删除
  --入参:Xml_In:
  --  <IN>
  --  <ROW>
  --  <YZID></YZID>医嘱ID --主医嘱ID
  --  <ROW>
  --  </IN>
  --  示例 xml_in:=Xmltype('<IN><ROW><YZID>1</YZID></ROW><ROW><YZID>2</YZID></ROW></IN>');
  --出参:Xml_Out
  --  <OUTPUT>
  --    <ERROR>
  --      <MSG>错误信息</MSG>
  --    </ERROR>
  --  </OUTPUT>
  --------------------------------------------------------------------------------------------------
  v_Tmp Varchar2(2000);
  v_Error Varchar(255);
  Err_Custom Exception;
Begin
  For R In (Select b.医嘱id
            From (Select Xml_In As Datas From Dual) A,
                 Xmltable('//IN/ROW' Passing a.Datas Columns 医嘱id Number(18) Path 'YZID') B) Loop
    Zl_病人医嘱记录_Delete(r.医嘱id, 1);
  End Loop;
  Xml_Out := Xmltype('<OUTPUT><ERROR><MSG></MSG></ERROR></OUTPUT>');
Exception
  When Err_Custom Then
    v_Tmp   := '<OUTPUT><ERROR><MSG>' || v_Error || '</MSG></ERROR></OUTPUT>';
    Xml_Out := Xmltype(v_Tmp);
  When Others Then
    v_Tmp   := '<OUTPUT><ERROR><MSG>错误信息：' || SQLErrM || '</MSG></ERROR></OUTPUT>';
    Xml_Out := Xmltype(v_Tmp);
	zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_adviceDelete;
/

--113206:胡俊勇,2018-01-08,区卫妇幼专版工作站接口
CREATE OR REPLACE Procedure Zl_Third_Deleteoutdiag
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --功能：删除诊断
  --入参
  --Xml_In
  --<IN>
  -- <BRID></BRID>病人ID
  -- <ZYID></ZYID>主页ID
  -- <JLLY></JLLY>记录来源
  -- <BLID></BLID>病历ID 空串，结点保留
  -- <ZDLX></ZDLX>诊断类型,
  -- <ZDIDS></ZDIDS>诊断IDS，诊断ID拼串，逗号分割。
  --</IN>

  --出参:Xml_Out， 
  --  <OUTPUT>  
  --    <ERROR> 
  --      <MSG>错误信息</MSG> 
  --    </ERROR> 
  --  </OUTPUT> 
  v_Tmp Varchar2(4000);
Begin
  For R In (Select Extractvalue(Value(A), 'ROW/BRID') As 病人id, Extractvalue(Value(A), 'ROW/ZYID') As 主页id,
                   Extractvalue(Value(A), 'ROW/JLLY') As 记录来源, Extractvalue(Value(A), 'ROW/BLID') As 病历id,
                   Extractvalue(Value(A), 'ROW/ZDLX') As 诊断类型, Extractvalue(Value(A), 'ROW/ZDIDS') As 诊断ids
            From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A) Loop
    Zl_病人诊断记录_Delete(r.病人id, r.主页id, r.记录来源, r.病历id, r.诊断类型, r.诊断ids);
  End Loop;
  Xml_Out := Xmltype('<OUTPUT><ERROR><MSG></MSG></ERROR></OUTPUT>');
Exception
  When Others Then
    v_Tmp   := '<OUTPUT><ERROR><MSG>错误信息：' || SQLErrM || '</MSG></ERROR></OUTPUT>';
    Xml_Out := Xmltype(v_Tmp);
	zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Deleteoutdiag;
/

--113206:胡俊勇,2018-01-08,区卫妇幼专版工作站接口
CREATE OR REPLACE Procedure Zl_Third_Updateoutdiag
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --功能：修改诊断
  --日期格式统一固定为：2017-05-25 10:22:31
  --入参
  --Xml_In
  --<IN>
  -- <ID></ID>ID
  -- <BRID></BRID>病人ID
  -- <ZYID></ZYID>主页ID
  -- <JLLY></JLLY>记录来源
  -- <ZDLX></ZDLX>诊断类型
  -- <JBID></JBID>疾病ID
  -- <ZDID></ZDID>诊断ID
  -- <ZHID></ZHID>证候ID
  -- <ZDMS></ZDMS>诊断描述
  -- <CYQK></CYQK>出院情况
  -- <SFWZ></SFWZ>是否未治
  -- <SFYZ></SFYZ>是否疑诊
  -- <ZDCX></ZDCX>诊断次序
  -- <BZ></BZ>备注
  -- <RYBQ></RYBQ>入院病情
  -- <FBSJ></FBSJ>发病时间
  -- <FMID></FMID>附码ID
  --</IN>

  --出参:Xml_Out，
  --  <OUTPUT>
  --    <ERROR>
  --      <MSG>错误信息</MSG>
  --    </ERROR>
  --  </OUTPUT>
  v_Tmp Varchar2(4000);
Begin
  For R In (Select Extractvalue(Value(A), 'ROW/ID') As ID, Extractvalue(Value(A), 'ROW/BRID') As 病人id,
                   Extractvalue(Value(A), 'ROW/ZYID') As 主页id, Extractvalue(Value(A), 'ROW/JLLY') As 记录来源,
                   Extractvalue(Value(A), 'ROW/ZDLX') As 诊断类型, Extractvalue(Value(A), 'ROW/JBID') As 疾病id,
                   Extractvalue(Value(A), 'ROW/ZDID') As 诊断id, Extractvalue(Value(A), 'ROW/ZHID') As 证候id,
                   Extractvalue(Value(A), 'ROW/ZDMS') As 诊断描述, Extractvalue(Value(A), 'ROW/CYQK') As 出院情况,
                   Extractvalue(Value(A), 'ROW/SFWZ') As 是否未治, Extractvalue(Value(A), 'ROW/SFYZ') As 是否疑诊,
                   Extractvalue(Value(A), 'ROW/ZDCX') As 诊断次序, Extractvalue(Value(A), 'ROW/BZ') As 备注,
                   Extractvalue(Value(A), 'ROW/RYBQ') As 入院病情,
                   To_Date(Extractvalue(Value(A), 'ROW/FBSJ'), 'yyyy-mm-dd hh24:mi:ss') As 发病时间,
                   Extractvalue(Value(A), 'ROW/FMID') As 附码id
            From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A) Loop
  
    Zl_病人诊断记录_Update(r.Id, r.病人id, r.主页id, r.记录来源, r.诊断类型, r.疾病id, r.诊断id, r.证候id, r.诊断描述, r.出院情况, r.是否未治, r.是否疑诊,
                     r.诊断次序, r.备注, r.入院病情, r.发病时间, r.附码id);
  End Loop;
  Xml_Out := Xmltype('<OUTPUT><ERROR><MSG></MSG></ERROR></OUTPUT>');
Exception
  When Others Then
    v_Tmp   := '<OUTPUT><ERROR><MSG>错误信息：' || SQLErrM || '</MSG></ERROR></OUTPUT>';
    Xml_Out := Xmltype(v_Tmp);
	zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Updateoutdiag;
/

--113206:胡俊勇,2018-01-08,区卫妇幼专版工作站接口
Create Or Replace Procedure Zl_Third_Getallitems
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:根据（简码/名称/编码）获取诊疗项目（药品）
  --入参:Xml_In:
  --<IN>
  --    <SRNR></SRNR>     //输入内容
  --    <XB></XB>         //性别，男，女，其它等,空表示不区分性别
  --    <SRXG></SRXG>输入效果，0-其它, 1-全数字，2-全字母，3-包含汉字
  --</IN>
  --出参:Xml_Out
  --<OUTPUT>
  --  <XMLIST>
  --<LBID>   || 类别ID ||   </LBID>  ;
  --<ZLXMID>   || 诊疗项目ID ||   </ZLXMID>  ;
  --<SFXMID>   || 收费细目ID ||   </SFXMID>  ;
  --<LB>   || 类别 ||   </LB>  ;
  --<JB>   || 基本 ||   </JB>  ;
  --<BM>   || 编码 ||   </BM>  ;

  --<MC>   || 名称 ||   </MC>  ;
  --<SPM>   || 商品名 ||   </SPM>  ;
  --<JM>   || 简码 ||   </JM>  ;
  --<JSDW>   || 计算单位 ||   </JSDW>  ;
  --<GG>   || 规格 ||   </GG>  ;
  --<KC>   || 库存 ||   </KC>  ;

  --<CD>   || 产地 ||   </CD>  ;
  --<YPJX>   || 药品剂型 ||   </YPJX>  ;
  --<XMTX>   || 项目特性 ||   </XMTX>  ;
  --<FYLX>   || 费用类型 ||   </FYLX>  ;
  --<YBDL>   || 医保大类 ||   </YBDL>  ;
  --<SM>   || 说明 ||   </SM>  ;

  --<CFZWID>   || 处方职务ID ||   </CFZWID>  ;
  --<JG>   || 价格 ||   </JG>  ;
  --<KJDJ>   || 抗菌等级 ||   </KJDJ>  ;
  --<LCZGYID>   || 临床自管药id ||   </LCZGYID>  ;
  --<PC>   || 批次 ||   </PC></XMLIST>  ;*/

  --  </XMLIST>
  --  <XMLIST>
  --      ...
  --  </XMLIST>
  --  <ERROR>
  --    <MSG></MSG>  //错误捕获
  --  </ERROR>
  --</OUTPUT>

  --------------------------------------------------------------------------------------------------

  --其它
  Cursor c_其它
  (
    码类_In Number,
    名称_In Varchar2,
    编码_In Varchar2,
    性别_In Varchar2
  ) Is
    Select /*+ rule*/
     Rownum As Keyid, a.类别id, a.诊疗项目id, a.收费细目id, a.类别, a.基本, a.编码, a.名称, a.商品名, a.简码, a.计算单位, a.规格, a.库存, a.产地, a.药品剂型,
     a.项目特性, a.费用类型, a.医保大类, a.说明, a.处方职务id, a.价格, a.抗菌等级, a.临床自管药id, a.批次
    From (Select a.类别 As 类别id, e.Id As 诊疗项目id, a.Id As 收费细目id, f.名称 As 类别, c.基本药物 As 基本, a.编码, a.名称, a.商品名, a.简码, e.计算单位,
                  a.规格, a.产地, d.药品剂型, Null As 项目特性, a.费用类型, a.医保大类, a.说明, d.处方职务 As 处方职务id,
                  Decode(a.价格, Null, Decode(c.上次售价, Null, a.现价, c.上次售价), a.现价) * c.门诊包装 || '/' || c.门诊单位 As 价格, Null As 库存,
                  Decode(d.抗生素, 0, '', 1, '非限制使用', 2, '限制使用', 3, '特殊使用') As 抗菌等级, d.临床自管药 As 临床自管药id, Null As 批次
           From 药品规格 C, 药品特性 D, 诊疗项目目录 E, 收费项目类别 F,
                (Select a.Id, a.类别, a.编码, a.名称, a.商品名, a.简码, a.零售单位, a.零售包装, a.规格, a.产地, a.费用类型, a.医保大类, a.说明,
                         Sum(Decode(a.是否变价, 1, Null, b.现价)) As 价格, Sum(b.现价) As 现价
                  From 收费价目 B,
                       (Select a.Id, a.类别, a.编码, C2.名称, C1.名称 As 商品名, b.简码, a.计算单位 As 零售单位, 1 As 零售包装, a.规格, a.产地, a.费用类型,
                                Null As 医保大类, a.说明, a.是否变价
                         From 收费项目别名 B, 收费项目目录 A, 收费项目别名 C2, 收费项目别名 C1
                         Where a.Id = b.收费细目id And a.类别 In ('5', '6', '7') And a.Id = C1.收费细目id(+) And C1.码类(+) = 1 And
                               C1.性质(+) = 3 And a.Id = C2.收费细目id(+) And C2.码类(+) = 1 And C2.性质(+) = 1 And
                               (a.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or a.撤档时间 Is Null) And
                               (a.站点 = '-' Or a.站点 Is Null) And a.服务对象 In (1, 3) And
                               (a.编码 Like 编码_In And b.码类 = 码类_In Or b.名称 Like 名称_In And b.码类 = 码类_In Or
                               b.简码 Like 名称_In And b.码类 In (码类_In, 3))) A
                  Where a.Id = b.收费细目id And Sysdate Between b.执行日期 + 0 And Nvl(b.终止日期, To_Date('3000-01-01', 'YYYY-MM-DD'))
                  Group By a.Id, a.类别, a.编码, a.名称, a.商品名, a.简码, a.零售单位, a.零售包装, a.规格, a.产地, a.费用类型, a.医保大类, a.说明) A
           Where a.Id = c.药品id And c.药名id = d.药名id And d.药名id = e.Id And a.类别 = f.编码 And e.类别 In ('5', '6', '7') And
                 Instr(性别_In, ',' || Nvl(e.适用性别, 0) || ',') > 0 And
                 (e.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or e.撤档时间 Is Null) And e.服务对象 In (1, 3) And
                 Nvl(e.执行频率, 0) In (0, 1)
           Union All
           Select a.类别 As 类别id, a.Id As 诊疗项目id, -null As 收费细目id, d.名称 As 类别, Null As 基本, a.编码, b.名称, Null As 商品名, b.简码,
                  a.计算单位, a.标本部位 As 规格, Null As 产地, Null As 药品剂型,
                  Decode(a.类别, 'H', Decode(a.操作类型, '1', '护理等级', '护理常规'), 'E',
                          Decode(a.操作类型, '1', '过敏试验', '2', '给药途径', '3', '中药煎法', '4', '中药用法', '5', '特殊治疗', '6', '采集方法', '7',
                                  '配血方法', '8', '输血途径', Null), 'Z',
                          Decode(a.操作类型, '1', '留观', '2', '住院', '3', '转科', '4', '术后', '5', '出院', '6', '转院', '7', '会诊', '8',
                                  '抢救', '9', '病重', '10', '病危', '11', '死亡', '12', '记录入出量', '14', '术前', Null), a.操作类型) As 项目特性,
                  Null As 费用类型, Null As 医保大类, Null As 说明, Null As 处方职务id, Null As 价格, Null As 库存, Null As 抗菌等级,
                  Null As 临床自管药id, Null As 批次
           From 诊疗项目类别 D, 诊疗项目别名 B, 诊疗项目目录 A
           Where a.Id = b.诊疗项目id And a.类别 = d.编码 And a.类别 Not In ('4', '5', '6', '7') And a.类别 <> '9' And
                 Nvl(a.单独应用, 0) = 1 And Instr(性别_In, ',' || Nvl(a.适用性别, 0) || ',') > 0 And Nvl(a.执行频率, 0) In (0, 1) And
                 (a.编码 Like 编码_In Or b.名称 Like 名称_In Or b.简码 Like 名称_In) And b.码类 = 码类_In And
                 (a.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or a.撤档时间 Is Null) And (a.站点 = '-' Or a.站点 Is Null) And
                 a.服务对象 In (1, 3)
           Union All
           Select a.类别 As 类别id, e.Id As 诊疗项目id, a.Id As 收费细目id, f.名称 As 类别, Null As 基本, a.编码, a.名称, Null As 商品名, a.简码,
                  a.计算单位, a.规格, a.产地, Null As 药品剂型, Null As 项目特性, a.费用类型, a.医保大类, a.说明, Null As 处方职务id,
                  Decode(a.价格, Null, Decode(c.上次售价, Null, a.现价, c.上次售价), a.现价) || '/' || a.计算单位 As 价格, Null As 库存,
                  Null As 抗菌等级, Null As 临床自管药id, a.批次
           From 材料特性 C, 诊疗项目目录 E, 收费项目类别 F,
                (Select a.Id, a.类别, a.编码, a.名称, a.简码, a.计算单位, a.规格, a.产地, a.费用类型, a.医保大类, a.说明,
                         Sum(Decode(a.是否变价, 1, Null, b.现价)) As 价格, Sum(b.现价) As 现价, Null As 批次
                  From 收费价目 B,
                       (Select a.Id, a.类别, a.编码, b.名称, b.简码, a.计算单位, a.规格, a.产地, a.费用类型, Null As 医保大类, a.说明, a.是否变价,
                                Null As 批次
                         From 收费项目别名 B, 收费项目目录 A
                         Where a.Id = b.收费细目id And a.类别 = '4' And
                               (a.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or a.撤档时间 Is Null) And
                               (a.站点 = '-' Or a.站点 Is Null) And a.服务对象 In (1, 3) And
                               (a.编码 Like 编码_In Or b.名称 Like 名称_In Or b.简码 Like 名称_In) And b.码类 = 码类_In) A
                  Where a.Id = b.收费细目id And Sysdate Between b.执行日期 + 0 And Nvl(b.终止日期, To_Date('3000-01-01', 'YYYY-MM-DD'))
                  Group By a.Id, a.类别, a.编码, a.名称, a.简码, a.计算单位, a.规格, a.产地, a.费用类型, a.医保大类, a.说明) A
           Where a.Id = c.材料id And c.诊疗id = e.Id And a.类别 = f.编码 And e.类别 = '4' And
                 Instr(性别_In, ',' || Nvl(e.适用性别, 0) || ',') > 0 And c.核算材料 = 0 And
                 (e.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or e.撤档时间 Is Null) And e.服务对象 In (1, 3) And
                 Nvl(e.执行频率, 0) In (0, 1)) A
    Order By Decode(类别id, '4', 'Z', 类别id), 类别, 编码;

  --全数字
  Cursor c_数字
  (
    码类_In Number,
    名称_In Varchar2,
    编码_In Varchar2,
    性别_In Varchar2
  ) Is
    Select /*+ rule*/
     Rownum As Keyid, a.类别id, a.诊疗项目id, a.收费细目id, a.类别, a.基本, a.编码, a.名称, a.商品名, a.简码, a.计算单位, a.规格, a.库存, a.产地, a.药品剂型,
     a.项目特性, a.费用类型, a.医保大类, a.说明, a.处方职务id, a.价格, a.抗菌等级, a.临床自管药id, a.批次
    From (Select a.类别 As 类别id, e.Id As 诊疗项目id, a.Id As 收费细目id, f.名称 As 类别, c.基本药物 As 基本, a.编码, a.名称, a.商品名, a.简码, e.计算单位,
                  a.规格, a.产地, d.药品剂型, Null As 项目特性, a.费用类型, a.医保大类, a.说明, d.处方职务 As 处方职务id,
                  Decode(a.价格, Null, Decode(c.上次售价, Null, a.现价, c.上次售价), a.现价) * c.门诊包装 || '/' || c.门诊单位 As 价格, Null As 库存,
                  Decode(d.抗生素, 0, '', 1, '非限制使用', 2, '限制使用', 3, '特殊使用') As 抗菌等级, d.临床自管药 As 临床自管药id, Null As 批次
           From 药品规格 C, 药品特性 D, 诊疗项目目录 E, 收费项目类别 F,
                (Select a.Id, a.类别, a.编码, a.名称, a.商品名, a.简码, a.零售单位, a.零售包装, a.规格, a.产地, a.费用类型, a.医保大类, a.说明,
                         Sum(Decode(a.是否变价, 1, Null, b.现价)) As 价格, Sum(b.现价) As 现价
                  From 收费价目 B,
                       (Select a.Id, a.类别, a.编码, C2.名称, C1.名称 As 商品名, b.简码, a.计算单位 As 零售单位, 1 As 零售包装, a.规格, a.产地, a.费用类型,
                                Null As 医保大类, a.说明, a.是否变价
                         From 收费项目别名 B, 收费项目目录 A, 收费项目别名 C2, 收费项目别名 C1
                         Where a.Id = b.收费细目id And a.类别 In ('5', '6', '7') And a.Id = C1.收费细目id(+) And C1.码类(+) = 1 And
                               C1.性质(+) = 3 And a.Id = C2.收费细目id(+) And C2.码类(+) = 1 And C2.性质(+) = 1 And
                               (a.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or a.撤档时间 Is Null) And
                               (a.站点 = '-' Or a.站点 Is Null) And a.服务对象 In (1, 3) And
                               (a.编码 Like 编码_In And b.码类 = 码类_In Or b.简码 Like 名称_In And b.码类 = 3)) A
                  Where a.Id = b.收费细目id And Sysdate Between b.执行日期 + 0 And Nvl(b.终止日期, To_Date('3000-01-01', 'YYYY-MM-DD'))
                  Group By a.Id, a.类别, a.编码, a.名称, a.商品名, a.简码, a.零售单位, a.零售包装, a.规格, a.产地, a.费用类型, a.医保大类, a.说明) A
           Where a.Id = c.药品id And c.药名id = d.药名id And d.药名id = e.Id And a.类别 = f.编码 And e.类别 In ('5', '6', '7') And
                 Instr(性别_In, ',' || Nvl(e.适用性别, 0) || ',') > 0 And
                 (e.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or e.撤档时间 Is Null) And e.服务对象 In (1, 3) And
                 Nvl(e.执行频率, 0) In (0, 1)
           Union All
           Select a.类别 As 类别id, a.Id As 诊疗项目id, -null As 收费细目id, d.名称 As 类别, Null As 基本, a.编码, b.名称, Null As 商品名, b.简码,
                  a.计算单位, a.标本部位 As 规格, Null As 产地, Null As 药品剂型,
                  Decode(a.类别, 'H', Decode(a.操作类型, '1', '护理等级', '护理常规'), 'E',
                          Decode(a.操作类型, '1', '过敏试验', '2', '给药途径', '3', '中药煎法', '4', '中药用法', '5', '特殊治疗', '6', '采集方法', '7',
                                  '配血方法', '8', '输血途径', Null), 'Z',
                          Decode(a.操作类型, '1', '留观', '2', '住院', '3', '转科', '4', '术后', '5', '出院', '6', '转院', '7', '会诊', '8',
                                  '抢救', '9', '病重', '10', '病危', '11', '死亡', '12', '记录入出量', '14', '术前', Null), a.操作类型) As 项目特性,
                  Null As 费用类型, Null As 医保大类, Null As 说明, Null As 处方职务id, Null As 价格, Null As 库存, Null As 抗菌等级,
                  Null As 临床自管药id, Null As 批次
           From 诊疗项目类别 D, 诊疗项目别名 B, 诊疗项目目录 A
           Where a.Id = b.诊疗项目id And a.类别 = d.编码 And a.类别 Not In ('4', '5', '6', '7') And a.类别 <> '9' And
                 Nvl(a.单独应用, 0) = 1 And Instr(性别_In, ',' || Nvl(a.适用性别, 0) || ',') > 0 And Nvl(a.执行频率, 0) In (0, 1) And
                 a.编码 Like 编码_In And b.码类 = 码类_In And (a.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or a.撤档时间 Is Null) And
                 (a.站点 = '-' Or a.站点 Is Null) And a.服务对象 In (1, 3)
           Union All
           Select a.类别 As 类别id, e.Id As 诊疗项目id, a.Id As 收费细目id, f.名称 As 类别, Null As 基本, a.编码, a.名称, Null As 商品名, a.简码,
                  a.计算单位, a.规格, a.产地, Null As 药品剂型, Null As 项目特性, a.费用类型, a.医保大类, a.说明, Null As 处方职务id,
                  Decode(a.价格, Null, Decode(c.上次售价, Null, a.现价, c.上次售价), a.现价) || '/' || a.计算单位 As 价格, Null As 库存,
                  Null As 抗菌等级, Null As 临床自管药id, a.批次
           From 材料特性 C, 诊疗项目目录 E, 收费项目类别 F,
                (Select a.Id, a.类别, a.编码, a.名称, a.简码, a.计算单位, a.规格, a.产地, a.费用类型, a.医保大类, a.说明,
                         Sum(Decode(a.是否变价, 1, Null, b.现价)) As 价格, Sum(b.现价) As 现价, Null As 批次
                  From 收费价目 B,
                       (Select a.Id, a.类别, a.编码, b.名称, b.简码, a.计算单位, a.规格, a.产地, a.费用类型, Null As 医保大类, a.说明, a.是否变价,
                                Null As 批次
                         From 收费项目别名 B, 收费项目目录 A
                         Where a.Id = b.收费细目id And a.类别 = '4' And
                               (a.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or a.撤档时间 Is Null) And
                               (a.站点 = '-' Or a.站点 Is Null) And a.服务对象 In (1, 3) And (a.编码 Like 编码_In) And b.码类 = 码类_In) A
                  Where a.Id = b.收费细目id And Sysdate Between b.执行日期 + 0 And Nvl(b.终止日期, To_Date('3000-01-01', 'YYYY-MM-DD'))
                  Group By a.Id, a.类别, a.编码, a.名称, a.简码, a.计算单位, a.规格, a.产地, a.费用类型, a.医保大类, a.说明) A
           Where a.Id = c.材料id And c.诊疗id = e.Id And a.类别 = f.编码 And e.类别 = '4' And
                 Instr(性别_In, ',' || Nvl(e.适用性别, 0) || ',') > 0 And c.核算材料 = 0 And
                 (e.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or e.撤档时间 Is Null) And e.服务对象 In (1, 3) And
                 Nvl(e.执行频率, 0) In (0, 1)) A
    Order By Decode(类别id, '4', 'Z', 类别id), 类别, 编码;

  --全字母
  Cursor c_字母
  (
    码类_In Number,
    名称_In Varchar2,
    编码_In Varchar2,
    性别_In Varchar2
  ) Is
    Select /*+ rule*/
     Rownum As Keyid, a.类别id, a.诊疗项目id, a.收费细目id, a.类别, a.基本, a.编码, a.名称, a.商品名, a.简码, a.计算单位, a.规格, a.库存, a.产地, a.药品剂型,
     a.项目特性, a.费用类型, a.医保大类, a.说明, a.处方职务id, a.价格, a.抗菌等级, a.临床自管药id, a.批次
    From (Select a.类别 As 类别id, e.Id As 诊疗项目id, a.Id As 收费细目id, f.名称 As 类别, c.基本药物 As 基本, a.编码, a.名称, a.商品名, a.简码, e.计算单位,
                  a.规格, a.产地, d.药品剂型, Null As 项目特性, a.费用类型, a.医保大类, a.说明, d.处方职务 As 处方职务id,
                  Decode(a.价格, Null, Decode(c.上次售价, Null, a.现价, c.上次售价), a.现价) * c.门诊包装 || '/' || c.门诊单位 As 价格, Null As 库存,
                  Decode(d.抗生素, 0, '', 1, '非限制使用', 2, '限制使用', 3, '特殊使用') As 抗菌等级, d.临床自管药 As 临床自管药id, Null As 批次
           From 药品规格 C, 药品特性 D, 诊疗项目目录 E, 收费项目类别 F,
                (Select a.Id, a.类别, a.编码, a.名称, a.商品名, a.简码, a.零售单位, a.零售包装, a.规格, a.产地, a.费用类型, a.医保大类, a.说明,
                         Sum(Decode(a.是否变价, 1, Null, b.现价)) As 价格, Sum(b.现价) As 现价
                  From 收费价目 B,
                       (Select a.Id, a.类别, a.编码, C2.名称, C1.名称 As 商品名, b.简码, a.计算单位 As 零售单位, 1 As 零售包装, a.规格, a.产地, a.费用类型,
                                Null As 医保大类, a.说明, a.是否变价
                         From 收费项目别名 B, 收费项目目录 A, 收费项目别名 C2, 收费项目别名 C1
                         Where a.Id = b.收费细目id And a.类别 In ('5', '6', '7') And a.Id = C1.收费细目id(+) And C1.码类(+) = 1 And
                               C1.性质(+) = 3 And a.Id = C2.收费细目id(+) And C2.码类(+) = 1 And C2.性质(+) = 1 And
                               (a.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or a.撤档时间 Is Null) And
                               (a.站点 = '-' Or a.站点 Is Null) And a.服务对象 In (1, 3) And b.简码 Like 名称_In And b.码类 = 码类_In) A
                  Where a.Id = b.收费细目id And Sysdate Between b.执行日期 + 0 And Nvl(b.终止日期, To_Date('3000-01-01', 'YYYY-MM-DD'))
                  Group By a.Id, a.类别, a.编码, a.名称, a.商品名, a.简码, a.零售单位, a.零售包装, a.规格, a.产地, a.费用类型, a.医保大类, a.说明) A
           Where a.Id = c.药品id And c.药名id = d.药名id And d.药名id = e.Id And a.类别 = f.编码 And e.类别 In ('5', '6', '7') And
                 Instr(性别_In, ',' || Nvl(e.适用性别, 0) || ',') > 0 And
                 (e.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or e.撤档时间 Is Null) And e.服务对象 In (1, 3) And
                 Nvl(e.执行频率, 0) In (0, 1)
           Union All
           Select a.类别 As 类别id, a.Id As 诊疗项目id, -null As 收费细目id, d.名称 As 类别, Null As 基本, a.编码, b.名称, Null As 商品名, b.简码,
                  a.计算单位, a.标本部位 As 规格, Null As 产地, Null As 药品剂型,
                  Decode(a.类别, 'H', Decode(a.操作类型, '1', '护理等级', '护理常规'), 'E',
                          Decode(a.操作类型, '1', '过敏试验', '2', '给药途径', '3', '中药煎法', '4', '中药用法', '5', '特殊治疗', '6', '采集方法', '7',
                                  '配血方法', '8', '输血途径', Null), 'Z',
                          Decode(a.操作类型, '1', '留观', '2', '住院', '3', '转科', '4', '术后', '5', '出院', '6', '转院', '7', '会诊', '8',
                                  '抢救', '9', '病重', '10', '病危', '11', '死亡', '12', '记录入出量', '14', '术前', Null), a.操作类型) As 项目特性,
                  Null As 费用类型, Null As 医保大类, Null As 说明, Null As 处方职务id, Null As 价格, Null As 库存, Null As 抗菌等级,
                  Null As 临床自管药id, Null As 批次
           From 诊疗项目类别 D, 诊疗项目别名 B, 诊疗项目目录 A
           Where a.Id = b.诊疗项目id And a.类别 = d.编码 And a.类别 Not In ('4', '5', '6', '7') And a.类别 <> '9' And
                 Nvl(a.单独应用, 0) = 1 And Instr(性别_In, ',' || Nvl(a.适用性别, 0) || ',') > 0 And Nvl(a.执行频率, 0) In (0, 1) And
                 b.简码 Like 名称_In And b.码类 = 码类_In And (a.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or a.撤档时间 Is Null) And
                 (a.站点 = '-' Or a.站点 Is Null) And a.服务对象 In (1, 3)
           Union All
           Select a.类别 As 类别id, e.Id As 诊疗项目id, a.Id As 收费细目id, f.名称 As 类别, Null As 基本, a.编码, a.名称, Null As 商品名, a.简码,
                  a.计算单位, a.规格, a.产地, Null As 药品剂型, Null As 项目特性, a.费用类型, a.医保大类, a.说明, Null As 处方职务id,
                  Decode(a.价格, Null, Decode(c.上次售价, Null, a.现价, c.上次售价), a.现价) || '/' || a.计算单位 As 价格, Null As 库存,
                  Null As 抗菌等级, Null As 临床自管药id, a.批次
           From 材料特性 C, 诊疗项目目录 E, 收费项目类别 F,
                (Select a.Id, a.类别, a.编码, a.名称, a.简码, a.计算单位, a.规格, a.产地, a.费用类型, a.医保大类, a.说明,
                         Sum(Decode(a.是否变价, 1, Null, b.现价)) As 价格, Sum(b.现价) As 现价, Null As 批次
                  From 收费价目 B,
                       (Select a.Id, a.类别, a.编码, b.名称, b.简码, a.计算单位, a.规格, a.产地, a.费用类型, Null As 医保大类, a.说明, a.是否变价,
                                Null As 批次
                         From 收费项目别名 B, 收费项目目录 A
                         Where a.Id = b.收费细目id And a.类别 = '4' And
                               (a.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or a.撤档时间 Is Null) And
                               (a.站点 = '-' Or a.站点 Is Null) And a.服务对象 In (1, 3) And (b.简码 Like 名称_In) And b.码类 = 码类_In) A
                  Where a.Id = b.收费细目id And Sysdate Between b.执行日期 + 0 And Nvl(b.终止日期, To_Date('3000-01-01', 'YYYY-MM-DD'))
                  Group By a.Id, a.类别, a.编码, a.名称, a.简码, a.计算单位, a.规格, a.产地, a.费用类型, a.医保大类, a.说明) A
           Where a.Id = c.材料id And c.诊疗id = e.Id And a.类别 = f.编码 And e.类别 = '4' And
                 Instr(性别_In, ',' || Nvl(e.适用性别, 0) || ',') > 0 And c.核算材料 = 0 And
                 (e.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or e.撤档时间 Is Null) And e.服务对象 In (1, 3) And
                 Nvl(e.执行频率, 0) In (0, 1)) A
    Order By Decode(类别id, '4', 'Z', 类别id), 类别, 编码;

  --有汉字
  Cursor c_汉字
  (
    码类_In Number,
    名称_In Varchar2,
    编码_In Varchar2,
    性别_In Varchar2
  ) Is
    Select /*+ rule*/
     Rownum As Keyid, a.类别id, a.诊疗项目id, a.收费细目id, a.类别, a.基本, a.编码, a.名称, a.商品名, a.简码, a.计算单位, a.规格, a.库存, a.产地, a.药品剂型,
     a.项目特性, a.费用类型, a.医保大类, a.说明, a.处方职务id, a.价格, a.抗菌等级, a.临床自管药id, a.批次
    From (Select a.类别 As 类别id, e.Id As 诊疗项目id, a.Id As 收费细目id, f.名称 As 类别, c.基本药物 As 基本, a.编码, a.名称, a.商品名, a.简码, e.计算单位,
                  a.规格, a.产地, d.药品剂型, Null As 项目特性, a.费用类型, a.医保大类, a.说明, d.处方职务 As 处方职务id,
                  Decode(a.价格, Null, Decode(c.上次售价, Null, a.现价, c.上次售价), a.现价) * c.门诊包装 || '/' || c.门诊单位 As 价格, Null As 库存,
                  Decode(d.抗生素, 0, '', 1, '非限制使用', 2, '限制使用', 3, '特殊使用') As 抗菌等级, d.临床自管药 As 临床自管药id, Null As 批次
           From 药品规格 C, 药品特性 D, 诊疗项目目录 E, 收费项目类别 F,
                (Select a.Id, a.类别, a.编码, a.名称, a.商品名, a.简码, a.零售单位, a.零售包装, a.规格, a.产地, a.费用类型, a.医保大类, a.说明,
                         Sum(Decode(a.是否变价, 1, Null, b.现价)) As 价格, Sum(b.现价) As 现价
                  From 收费价目 B,
                       (Select a.Id, a.类别, a.编码, C2.名称, C1.名称 As 商品名, b.简码, a.计算单位 As 零售单位, 1 As 零售包装, a.规格, a.产地, a.费用类型,
                                Null As 医保大类, a.说明, a.是否变价
                         From 收费项目别名 B, 收费项目目录 A, 收费项目别名 C2, 收费项目别名 C1
                         Where a.Id = b.收费细目id And a.类别 In ('5', '6', '7') And a.Id = C1.收费细目id(+) And C1.码类(+) = 1 And
                               C1.性质(+) = 3 And a.Id = C2.收费细目id(+) And C2.码类(+) = 1 And C2.性质(+) = 1 And
                               (a.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or a.撤档时间 Is Null) And
                               (a.站点 = '-' Or a.站点 Is Null) And a.服务对象 In (1, 3) And b.名称 Like 名称_In And b.码类 = 码类_In) A
                  Where a.Id = b.收费细目id And Sysdate Between b.执行日期 + 0 And Nvl(b.终止日期, To_Date('3000-01-01', 'YYYY-MM-DD'))
                  Group By a.Id, a.类别, a.编码, a.名称, a.商品名, a.简码, a.零售单位, a.零售包装, a.规格, a.产地, a.费用类型, a.医保大类, a.说明) A
           Where a.Id = c.药品id And c.药名id = d.药名id And d.药名id = e.Id And a.类别 = f.编码 And e.类别 In ('5', '6', '7') And
                 Instr(性别_In, ',' || Nvl(e.适用性别, 0) || ',') > 0 And
                 (e.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or e.撤档时间 Is Null) And e.服务对象 In (1, 3) And
                 Nvl(e.执行频率, 0) In (0, 1)
           Union All
           Select a.类别 As 类别id, a.Id As 诊疗项目id, -null As 收费细目id, d.名称 As 类别, Null As 基本, a.编码, b.名称, Null As 商品名, b.简码,
                  a.计算单位, a.标本部位 As 规格, Null As 产地, Null As 药品剂型,
                  Decode(a.类别, 'H', Decode(a.操作类型, '1', '护理等级', '护理常规'), 'E',
                          Decode(a.操作类型, '1', '过敏试验', '2', '给药途径', '3', '中药煎法', '4', '中药用法', '5', '特殊治疗', '6', '采集方法', '7',
                                  '配血方法', '8', '输血途径', Null), 'Z',
                          Decode(a.操作类型, '1', '留观', '2', '住院', '3', '转科', '4', '术后', '5', '出院', '6', '转院', '7', '会诊', '8',
                                  '抢救', '9', '病重', '10', '病危', '11', '死亡', '12', '记录入出量', '14', '术前', Null), a.操作类型) As 项目特性,
                  Null As 费用类型, Null As 医保大类, Null As 说明, Null As 处方职务id, Null As 价格, Null As 库存, Null As 抗菌等级,
                  Null As 临床自管药id, Null As 批次
           From 诊疗项目类别 D, 诊疗项目别名 B, 诊疗项目目录 A
           Where a.Id = b.诊疗项目id And a.类别 = d.编码 And a.类别 Not In ('4', '5', '6', '7') And a.类别 <> '9' And
                 Nvl(a.单独应用, 0) = 1 And Instr(性别_In, ',' || Nvl(a.适用性别, 0) || ',') > 0 And Nvl(a.执行频率, 0) In (0, 1) And
                 b.名称 Like 名称_In And b.码类 = 码类_In And (a.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or a.撤档时间 Is Null) And
                 (a.站点 = '-' Or a.站点 Is Null) And a.服务对象 In (1, 3)
           Union All
           Select a.类别 As 类别id, e.Id As 诊疗项目id, a.Id As 收费细目id, f.名称 As 类别, Null As 基本, a.编码, a.名称, Null As 商品名, a.简码,
                  a.计算单位, a.规格, a.产地, Null As 药品剂型, Null As 项目特性, a.费用类型, a.医保大类, a.说明, Null As 处方职务id,
                  Decode(a.价格, Null, Decode(c.上次售价, Null, a.现价, c.上次售价), a.现价) || '/' || a.计算单位 As 价格, Null As 库存,
                  Null As 抗菌等级, Null As 临床自管药id, a.批次
           From 材料特性 C, 诊疗项目目录 E, 收费项目类别 F,
                (Select a.Id, a.类别, a.编码, a.名称, a.简码, a.计算单位, a.规格, a.产地, a.费用类型, a.医保大类, a.说明,
                         Sum(Decode(a.是否变价, 1, Null, b.现价)) As 价格, Sum(b.现价) As 现价, Null As 批次
                  From 收费价目 B,
                       (Select a.Id, a.类别, a.编码, b.名称, b.简码, a.计算单位, a.规格, a.产地, a.费用类型, Null As 医保大类, a.说明, a.是否变价,
                                Null As 批次
                         From 收费项目别名 B, 收费项目目录 A
                         Where a.Id = b.收费细目id And a.类别 = '4' And
                               (a.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or a.撤档时间 Is Null) And
                               (a.站点 = '-' Or a.站点 Is Null) And a.服务对象 In (1, 3) And b.名称 Like 名称_In And b.码类 = 码类_In) A
                  Where a.Id = b.收费细目id And Sysdate Between b.执行日期 + 0 And Nvl(b.终止日期, To_Date('3000-01-01', 'YYYY-MM-DD'))
                  Group By a.Id, a.类别, a.编码, a.名称, a.简码, a.计算单位, a.规格, a.产地, a.费用类型, a.医保大类, a.说明) A
           Where a.Id = c.材料id And c.诊疗id = e.Id And a.类别 = f.编码 And e.类别 = '4' And
                 Instr(性别_In, ',' || Nvl(e.适用性别, 0) || ',') > 0 And c.核算材料 = 0 And
                 (e.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or e.撤档时间 Is Null) And e.服务对象 In (1, 3) And
                 Nvl(e.执行频率, 0) In (0, 1)) A
    Order By Decode(类别id, '4', 'Z', 类别id), 类别, 编码;

  r_Item c_汉字%RowType;

  v_Temp    Varchar2(32767); --临时XML
  x_Templet Xmltype; --模板XML 

  n_码类     Number(3);
  v_性别     Varchar2(20);
  v_输入内容 Varchar2(2000); --外部传入
  n_输入效果 Number; --0-其它, 1-全数字，2-全字母，3-包含汉字

  --被忽略的参数   -- 不显示库存列,不显示成套项目

  --Mstrlike         Varchar2(200); --参数  输入匹配 固定为左匹配
  --Mlng西药房       Number(18); --参数缺省库房
  --Mlng成药房       Number(18);
  --Mlng中药房       Number(18);
  --Mstr可用西药房   Varchar2(30000);
  --Mstr可用成药房   Varchar2(30000);
  --Mstr可用中药房   Varchar2(30000);
  --Mlng发料部门     Number(18);
  --Mint险类         Number; --病人相关 
  --Mint简码         Number(18); --参数  简码方式 0-拼音,1-五笔,固定为拼音 
  --Gstrmatchmode    Varchar2(200); --参数 44号系统参数 收费项目输入简码匹配方式:10.输入全是数字时只匹配编码  01.输入全是字母时只匹配简码,11两者均要求,固定为 11 
  --Gblnstock        Boolean; --参数 指定药房时限制库存  18号系统参数,固定为 False  
  --Gbyt输入药品显示 Number; --参数 "输入药品显示" 0-按输入匹配显示，1-固定显示通用名和商品名,固定为1

  Procedure p_Additem Is
  Begin
    v_Temp := '<XMLIST><LBID>' || r_Item.类别id || '</LBID>';
    v_Temp := v_Temp || '<ZLXMID>' || r_Item.诊疗项目id || '</ZLXMID>';
    v_Temp := v_Temp || '<SFXMID>' || r_Item.收费细目id || '</SFXMID>';
    v_Temp := v_Temp || '<LB>' || r_Item.类别 || '</LB>';
    v_Temp := v_Temp || '<JB>' || r_Item.基本 || '</JB>';
    v_Temp := v_Temp || '<BM>' || r_Item.编码 || '</BM>';
    v_Temp := v_Temp || '<MC>' || r_Item.名称 || '</MC>';
    v_Temp := v_Temp || '<SPM>' || r_Item.商品名 || '</SPM>';
    v_Temp := v_Temp || '<JM>' || r_Item.简码 || '</JM>';
    v_Temp := v_Temp || '<JSDW>' || r_Item.计算单位 || '</JSDW>';
    v_Temp := v_Temp || '<GG>' || r_Item.规格 || '</GG>';
    v_Temp := v_Temp || '<KC>' || r_Item.库存 || '</KC>';
  
    v_Temp := v_Temp || '<CD>' || r_Item.产地 || '</CD>';
    v_Temp := v_Temp || '<YPJX>' || r_Item.药品剂型 || '</YPJX>';
    v_Temp := v_Temp || '<XMTX>' || r_Item.项目特性 || '</XMTX>';
    v_Temp := v_Temp || '<FYLX>' || r_Item.费用类型 || '</FYLX>';
    v_Temp := v_Temp || '<YBDL>' || r_Item.医保大类 || '</YBDL>';
    v_Temp := v_Temp || '<SM>' || r_Item.说明 || '</SM>';
  
    v_Temp := v_Temp || '<CFZWID>' || r_Item.处方职务id || '</CFZWID>';
    v_Temp := v_Temp || '<JG>' || r_Item.价格 || '</JG>';
    v_Temp := v_Temp || '<KJDJ>' || r_Item.抗菌等级 || '</KJDJ>';
    v_Temp := v_Temp || '<LCZGYID>' || r_Item.临床自管药id || '</LCZGYID>';
    v_Temp := v_Temp || '<PC>' || r_Item.批次 || '</PC></XMLIST>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  End;
Begin
  Select Extractvalue(Value(A), 'IN/XB'), Extractvalue(Value(A), 'IN/SRXG'), Upper(Extractvalue(Value(A), 'IN/SRNR'))
  Into v_性别, n_输入效果, v_输入内容
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  n_码类 := 1;
  If Instr(v_性别, '男') > 0 Then
    v_性别 := '0,1';
  Elsif Instr(v_性别, '男') > 0 Then
    v_性别 := '0,2';
  Elsif v_性别 Is Null Then
    v_性别 := '0,1,2';
  Else
    v_性别 := '0';
  End If;
  v_性别 := ',' || v_性别 || ',';

  x_Templet := Xmltype('<OUTPUT></OUTPUT>');
  --0-其它, 1-全数字，2-全字母，3-包含汉字
  If v_输入内容 Is Not Null Then
    If n_输入效果 = 0 Then
      Open c_其它(n_码类, '%' || v_输入内容 || '%', v_输入内容 || '%', v_性别);
      Loop
        Fetch c_其它
          Into r_Item;
        Exit When c_其它%NotFound;
        p_Additem;
      End Loop;
      Close c_其它;
    Elsif n_输入效果 = 1 Then
      Open c_数字(n_码类, '%' || v_输入内容 || '%', v_输入内容 || '%', v_性别);
      Loop
        Fetch c_数字
          Into r_Item;
        Exit When c_数字%NotFound;
        p_Additem;
      End Loop;
      Close c_数字;
    Elsif n_输入效果 = 2 Then
      Open c_字母(n_码类, '%' || v_输入内容 || '%', v_输入内容 || '%', v_性别);
      Loop
        Fetch c_字母
          Into r_Item;
        Exit When c_字母%NotFound;
        p_Additem;
      End Loop;
      Close c_字母;
    Elsif n_输入效果 = 3 Then
      Open c_其它(n_码类, '%' || v_输入内容 || '%', v_输入内容 || '%', v_性别);
      Loop
        Fetch c_其它
          Into r_Item;
        Exit When c_其它%NotFound;
        p_Additem;
      End Loop;
      Close c_其它;
    End If;
  End If;
  Xml_Out := x_Templet;
Exception
  When Others Then
    v_Temp := '<ERROR><MSG>' || SQLErrM || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Xml_Out := x_Templet;
	zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getallitems;
/

--119578:黄捷,2018-01-05,ZLHIS锚点消息,增加取消检查预约的消息
Create Or Replace Procedure Zl_Ris检查预约_Delete(医嘱id_In In Ris检查预约.医嘱id%Type) Is
  v_预约id       Ris检查预约.预约id%Type;
  v_预约日期     Ris检查预约.预约日期%Type;
  v_预约序号     Ris检查预约.序号%Type;
  v_检查设备名称 Ris检查预约.检查设备名称%Type;
Begin
  Select 预约id, 预约日期, 序号, 检查设备名称
  Into v_预约id, v_预约日期, v_预约序号, v_检查设备名称
  From Ris检查预约
  Where 医嘱id = 医嘱id_In;

  Delete Ris检查预约 Where 医嘱id = 医嘱id_In;

  --发送消息
  b_Message.Zlhis_Pacs_007(医嘱id_In, v_预约id, v_预约日期, v_预约序号, v_检查设备名称);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Ris检查预约_Delete;
/

--103177:廖思奇,2018-01-05,Zl_影像检查记录_发送安排 增加单独修改执行间的使用方法
Create Or Replace Procedure Zl_影像检查记录_发送安排
(
  医嘱id_In       影像检查记录.医嘱id%Type,
  发送号_In       影像检查记录.发送号%Type,
  是否安排_In     影像检查记录.是否安排%Type,
  检查技师_In     影像检查记录.检查技师%Type,
  检查技师二_In   影像检查记录.检查技师二%Type,
  执行间_In       病人医嘱发送.执行间%Type,
  过程兼容功能_In Number := Null
) As
Begin
  --过程兼容功能_In:  1 仅更新病人医嘱发送.执行间数据。问题103177
  If 过程兼容功能_In Is Null Then
    Update 影像检查记录
    Set 检查技师 = 检查技师_In, 检查技师二 = 检查技师二_In, 是否安排 = 是否安排_In
    Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In;
  
    Update 病人医嘱发送 Set 执行间 = 执行间_In Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In;
  Else
    Update 病人医嘱发送 Set 执行间 = 执行间_In Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_影像检查记录_发送安排;
/

--119437:胡俊勇,2018-01-09,临床相关消息修改
--115972:胡俊勇,2018-01-05,原液皮试药品费用减数量
CREATE OR REPLACE Procedure Zl_门诊医嘱发送_Insert
(
  医嘱id_In     In 病人医嘱发送.医嘱id%Type,
  发送号_In     In 病人医嘱发送.发送号%Type,
  记录性质_In   In 病人医嘱发送.记录性质%Type,
  No_In         In 病人医嘱发送.No%Type,
  记录序号_In   In 病人医嘱发送.记录序号%Type,
  发送数次_In   In 病人医嘱发送.发送数次%Type,
  首次时间_In   In 病人医嘱发送.首次时间%Type,
  末次时间_In   In 病人医嘱发送.末次时间%Type,
  发送时间_In   In 病人医嘱发送.发送时间%Type,
  执行状态_In   In 病人医嘱发送.执行状态%Type,
  执行部门id_In In 病人医嘱发送.执行部门id%Type,
  计费状态_In   In 病人医嘱发送.计费状态%Type,
  First_In      In Number := 0,
  样本条码_In   In 病人医嘱发送.样本条码%Type := Null,
  操作员编号_In In 人员表.编号%Type := Null,
  操作员姓名_In In 人员表.姓名%Type := Null,
  原液皮试_In   In Varchar2 := Null
  --功能：填写病人医嘱发送记录
  --参数：First_IN=表示是否一组医嘱的第一医嘱行,以便处理医嘱相关内容(如成药,配方的第一行,因为给药途径,配方煎法,用法可能为叮嘱不发送)
  --      源液皮试_In 原液皮试医嘱ID，需求号7107/bug115972用于关联药品医嘱行和皮试医嘱行。关联字段为 病人医嘱发送.标本发送批号 存入药品行的医嘱ID值
  --      格式：1医嘱ID,2医嘱ID 前面一个为皮试医嘱的医嘱ID，第二个为药品行医嘱的医嘱ID
) Is
  --包含病人及医嘱(一组医嘱中第一行)相关信息的游标
  Cursor c_Advice Is
    Select Nvl(a.相关id, a.Id) As 组id, a.相关id, a.序号, a.病人id, a.挂号单, a.婴儿, b.姓名, c.操作类型, a.诊疗类别, a.医嘱状态, a.医嘱内容, a.开嘱医生,
           a.开始执行时间, a.执行时间方案, a.频率次数, a.频率间隔, a.间隔单位, Nvl(a.紧急标志, 0) As 紧急标志, a.诊疗项目id, a.收费细目id
    From 病人医嘱记录 A, 病人信息 B, 诊疗项目目录 C
    Where a.病人id = b.病人id And a.诊疗项目id = c.Id And a.Id = 医嘱id_In
    Group By a.相关id, a.Id, a.序号, a.病人id, a.挂号单, a.婴儿, b.姓名, c.操作类型, a.诊疗类别, a.医嘱状态, a.医嘱内容, a.开嘱医生, a.开始执行时间, a.执行时间方案,
             a.频率次数, a.频率间隔, a.间隔单位, a.紧急标志, a.诊疗项目id, a.收费细目id;
  r_Advice c_Advice%RowType;

  Cursor c_Pati(v_病人id 病人信息.病人id%Type) Is
    Select * From 病人信息 Where 病人id = v_病人id;
  r_Pati c_Pati%RowType;

  --其它临时变量
  v_Temp       Varchar2(255);
  v_Count      Number;
  v_病人性质   病案主页.病人性质%Type;
  v_人员编号   人员表.编号%Type;
  v_人员姓名   人员表.姓名%Type;
  v_入院方式   入院方式.名称%Type;
  d_开始时间   病人医嘱记录.开始执行时间%Type;
  n_医嘱状态   病人医嘱记录.医嘱状态%Type;
  n_皮试标号   病人医嘱发送.医嘱id%Type;
  n_皮试医嘱id 病人医嘱发送.医嘱id%Type;
  v_Error      Varchar2(255);
  Err_Custom Exception;
Begin
  --当前操作人员
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
    v_人员编号 := 操作员编号_In;
    v_人员姓名 := 操作员姓名_In;
  Else
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;
  --如果首次时间为空则填入开始执行时间
  Select 开始执行时间, 医嘱状态 Into d_开始时间, n_医嘱状态 From 病人医嘱记录 Where ID = 医嘱id_In;

  Open c_Advice;
  Fetch c_Advice
    Into r_Advice;
  --是一组医嘱的第一行时处理医嘱内容
  If Nvl(First_In, 0) = 1 Or n_医嘱状态 = 1 Then
    --并发操作检查
    ---------------------------------------------------------------------------------------
    If Nvl(r_Advice.医嘱状态, 0) <> 1 Then
      v_Error := '"' || r_Advice.姓名 || '"的医嘱"' || r_Advice.医嘱内容 || '"已经被其他人发送。' || Chr(13) || Chr(10) ||
                 '该病人的医嘱发送失败。请重新读取发送清单再试。';
      Raise Err_Custom;
    End If;
  
    --发送后的医嘱处理:临嘱发送后自动停止
    ---------------------------------------------------------------------------------------
    Update 病人医嘱记录
    Set 医嘱状态 = 8, 执行终止时间 = 末次时间_In,
        --可能没有
        停嘱时间 = 发送时间_In,
        --要作为发送时间显示
        停嘱医生 = v_人员姓名 --要作为发送人显示,不同于住院,门诊医嘱无护士操作
    Where ID = r_Advice.组id Or 相关id = r_Advice.组id;
  
    Insert Into 病人医嘱状态
      (医嘱id, 操作类型, 操作人员, 操作时间)
      Select ID, 8, v_人员姓名, 发送时间_In From 病人医嘱记录 Where ID = r_Advice.组id Or 相关id = r_Advice.组id;
  
    --特殊医嘱的处理
    ---------------------------------------------------------------------------------------
    If r_Advice.诊疗类别 = 'Z' And Nvl(r_Advice.操作类型, '0') <> '0' And Nvl(r_Advice.婴儿, 0) = 0 Then
      --1-留观;2-住院;
      If Instr(',1,2,', r_Advice.操作类型) > 0 And 执行部门id_In Is Not Null Then
        --满足产生新的预约登记的条件：1.当前无预约,2.当前不在院,3-无要求预约时间内的住院记录
      
        --删除超过挂号有效天数的预约登记
        Begin
          Select Count(*) Into v_Count From 病案主页 Where 病人id = r_Advice.病人id And Nvl(主页id, 0) = 0;
        Exception
          When Others Then
            v_Count := 0;
        End;
        If Nvl(v_Count, 0) > 0 Then
          Zl_入院病案主页_Delete(r_Advice.病人id, 0, 0, 0);
          v_Count := 0;
        End If;
      
        If v_Count = 0 Then
          Select Count(*) Into v_Count From 病案主页 Where 病人id = r_Advice.病人id And 出院日期 Is Null;
        End If;
        If v_Count = 0 Then
          Select Count(*)
          Into v_Count
          From 病案主页
          Where 病人id = r_Advice.病人id And (入院日期 >= r_Advice.开始执行时间 Or 出院日期 >= r_Advice.开始执行时间);
        End If;
        If v_Count = 0 Then
          If r_Advice.操作类型 = '1' Then
            --留观医嘱,将病人在"开始时间"留观到临床执行科室
            Begin
              v_病人性质 := 2;
              Select Decode(服务对象, 1, 1, 2)
              Into v_病人性质
              From 部门性质说明
              Where 工作性质 = '临床' And 部门id = 执行部门id_In;
            Exception
              When Others Then
                Null;
            End;
          Elsif r_Advice.操作类型 = '2' Then
            --住院医嘱,将病人在"开始时间"登记到临床执行科室
            v_病人性质 := 0;
          End If;
        
          Open c_Pati(r_Advice.病人id);
          Fetch c_Pati
            Into r_Pati;
        
          v_入院方式 := Null;
          If r_Advice.紧急标志 = 1 Then
            v_入院方式 := '急诊';
          Else
            Select Decode(急诊, 1, '急诊', Null)
            Into v_入院方式
            From 病人挂号记录
            Where NO = r_Advice.挂号单 And 记录性质 = 1 And 记录状态 = 1;
          End If;
        
          If v_病人性质 = 1 Then
            Zl_入院病案主页_Insert(1, v_病人性质, r_Pati.病人id, r_Pati.门诊号, Null, r_Pati.姓名, r_Pati.性别, r_Pati.年龄, r_Pati.费别,
                             r_Pati.出生日期, r_Pati.国籍, r_Pati.民族, r_Pati.学历, r_Pati.婚姻状况, r_Pati.职业, r_Pati.身份,
                             r_Pati.身份证号, r_Pati.出生地点, r_Pati.家庭地址, r_Pati.家庭地址邮编, r_Pati.家庭电话, r_Pati.户口地址,
                             r_Pati.户口地址邮编, r_Pati.联系人姓名, r_Pati.联系人关系, r_Pati.联系人地址, r_Pati.联系人电话, r_Pati.工作单位,
                             r_Pati.合同单位id, r_Pati.单位电话, r_Pati.单位邮编, r_Pati.单位开户行, r_Pati.单位帐号, r_Pati.担保人, r_Pati.担保额,
                             r_Pati.担保性质, 执行部门id_In, Null, Null, v_入院方式, Null, Null, r_Advice.开嘱医生, r_Pati.籍贯, r_Pati.区域,
                             r_Advice.开始执行时间, Null, Null, r_Pati.医疗付款方式, Null, Null, Null, Null, Null, Null, r_Pati.险类,
                             v_人员编号, v_人员姓名, 0, Null, Null, 0);
          Else
            Zl_入院病案主页_Insert(1, v_病人性质, r_Pati.病人id, r_Pati.住院号, Null, r_Pati.姓名, r_Pati.性别, r_Pati.年龄, r_Pati.费别,
                             r_Pati.出生日期, r_Pati.国籍, r_Pati.民族, r_Pati.学历, r_Pati.婚姻状况, r_Pati.职业, r_Pati.身份,
                             r_Pati.身份证号, r_Pati.出生地点, r_Pati.家庭地址, r_Pati.家庭地址邮编, r_Pati.家庭电话, r_Pati.户口地址,
                             r_Pati.户口地址邮编, r_Pati.联系人姓名, r_Pati.联系人关系, r_Pati.联系人地址, r_Pati.联系人电话, r_Pati.工作单位,
                             r_Pati.合同单位id, r_Pati.单位电话, r_Pati.单位邮编, r_Pati.单位开户行, r_Pati.单位帐号, r_Pati.担保人, r_Pati.担保额,
                             r_Pati.担保性质, 执行部门id_In, Null, Null, v_入院方式, Null, Null, r_Advice.开嘱医生, r_Pati.籍贯, r_Pati.区域,
                             r_Advice.开始执行时间, Null, Null, r_Pati.医疗付款方式, Null, Null, Null, Null, Null, Null, r_Pati.险类,
                             v_人员编号, v_人员姓名, 0, Null, Null, 0);
          End If;
          Close c_Pati;
        End If;
      End If;
    End If;
  End If;
  Close c_Advice;

  If 原液皮试_In Is Not Null Then
    v_Count      := Instr(原液皮试_In, ',');
    n_皮试医嘱id := Substr(原液皮试_In, 1, v_Count - 1);
    n_皮试标号   := Substr(原液皮试_In, v_Count + 1);
    Update 病人医嘱发送 Set 标本发送批号 = n_皮试标号 Where 医嘱id = n_皮试医嘱id;
  End If;
  --填写发送记录
  ---------------------------------------------------------------------------------------
  Insert Into 病人医嘱发送
    (医嘱id, 发送号, 记录性质, NO, 记录序号, 发送数次, 发送人, 发送时间, 执行状态, 执行部门id, 计费状态, 首次时间, 末次时间, 样本条码, 门诊记帐, 标本发送批号)
  Values
    (医嘱id_In, 发送号_In, 记录性质_In, No_In, 记录序号_In, 发送数次_In, v_人员姓名, 发送时间_In, 执行状态_In, 执行部门id_In, 计费状态_In,
     Nvl(首次时间_In, d_开始时间), Nvl(末次时间_In, d_开始时间), 样本条码_In, Decode(记录性质_In, 2, 1, Null), n_皮试标号);

  --手术和检查医嘱同步更新主医嘱的计费状态
  If 计费状态_In = 1 And r_Advice.组id <> 医嘱id_In And (r_Advice.诊疗类别 = 'D' Or r_Advice.诊疗类别 = 'F') Then
    Update 病人医嘱发送 Set 计费状态 = 1 Where 医嘱id = r_Advice.组id And 发送号 = 发送号_In;
  End If;

  --自动填为已执行时，需要同步处理费用执行状态及审核划价状态
  If 执行状态_In = 1 Then
    Zl_病人医嘱执行_Finish(医嘱id_In, 发送号_In, Null, Null, v_人员编号, v_人员姓名, 执行部门id_In);
  End If;
  --消息推送
  Begin
    Execute Immediate 'Begin zl_服务窗消息_发送(:1,:2); End;'
      Using 3, 发送号_In;
  Exception
    When Others Then
      Null;
  End;

  If r_Advice.诊疗类别 = 'E' And r_Advice.操作类型 = '6' Then
    --检验项目
    b_Message.Zlhis_Cis_016(r_Advice.病人id, Null, r_Advice.挂号单, 发送号_In, r_Advice.组id, 1);
  Elsif r_Advice.诊疗类别 = 'D' And r_Advice.相关id Is Null Then
    b_Message.Zlhis_Cis_017(r_Advice.病人id, Null, r_Advice.挂号单, 发送号_In, r_Advice.组id, 1);
  Elsif r_Advice.诊疗类别 = 'F' And r_Advice.相关id Is Null Then
    b_Message.Zlhis_Cis_018(r_Advice.病人id, Null, r_Advice.挂号单, 发送号_In, r_Advice.组id);
  Elsif r_Advice.诊疗类别 = 'K' Then
    b_Message.Zlhis_Cis_019(r_Advice.病人id, Null, r_Advice.挂号单, 发送号_In, r_Advice.组id);
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊医嘱发送_Insert;
/

--110624:刘涛,2018-01-22,领用增加修改人（日期）
--119490:刘涛,2018-01-05,药品留存可用数量处理
Create Or Replace Procedure Zl_药品领用_Insert
(
  入出类别id_In In 药品收发记录.入出类别id%Type,
  No_In         In 药品收发记录.No%Type,
  序号_In       In 药品收发记录.序号%Type,
  库房id_In     In 药品收发记录.库房id%Type,
  对方部门id_In In 药品收发记录.对方部门id%Type,
  药品id_In     In 药品收发记录.药品id%Type,
  批次_In       In 药品收发记录.批次%Type,
  填写数量_In   In 药品收发记录.填写数量%Type,
  实际数量_In   In 药品收发记录.实际数量%Type,
  成本价_In     In 药品收发记录.成本价%Type,
  成本金额_In   In 药品收发记录.成本金额%Type,
  零售价_In     In 药品收发记录.零售价%Type,
  零售金额_In   In 药品收发记录.零售金额%Type,
  差价_In       In 药品收发记录.差价%Type,
  填制人_In     In 药品收发记录.填制人%Type,
  填制日期_In   In 药品收发记录.填制日期%Type,
  产地_In       In 药品收发记录.产地%Type := Null,
  批号_In       In 药品收发记录.批号%Type := Null,
  效期_In       In 药品收发记录.效期%Type := Null,
  摘要_In       In 药品收发记录.摘要%Type := Null,
  领用人_In     In 药品收发记录.领用人%Type := Null,
  批准文号_In   In 药品收发记录.批准文号%Type := Null,
  发药方式_In   In 药品收发记录.发药方式%Type := 0,
  原产地_In     In 药品收发记录.原产地%Type := Null,
  修改人_In     In 药品收发记录.修改人%Type := Null,
  修改日期_In   In 药品收发记录.修改日期%Type := Null
) Is
  v_入出系数 药品收发记录.入出系数%Type; --收发ID 
  Err_Isnonumber Exception;
  v_编码         收费项目目录.编码%Type;
  n_上次供应商id 药品库存.上次供应商id%Type;
  d_上次生产日期 药品库存.上次生产日期%Type;
  n_收发id       药品收发记录.Id%Type;
Begin
  v_入出系数 := -1;

  Begin
    Select 上次供应商id, 上次生产日期
    Into n_上次供应商id, d_上次生产日期
    From 药品库存
    Where 性质 = 1 And 库房id = 库房id_In And 药品id = 药品id_In And Nvl(批次, 0) = Nvl(批次_In, 0);
  Exception
    When Others Then
      n_上次供应商id := Null;
      d_上次生产日期 := Null;
  End;

  Select 药品收发记录_Id.Nextval Into n_收发id From Dual;

  --插入类别为出的那一笔 
  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地,原产地, 批号, 效期, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 零售金额, 差价, 摘要,
     填制人, 填制日期, 领用人, 批准文号, 发药方式, 供药单位id, 生产日期, 修改人, 修改日期)
  Values
    (n_收发id, 1, 7, No_In, 序号_In, 库房id_In, 对方部门id_In, 入出类别id_In, v_入出系数, 药品id_In, 批次_In, 产地_In,原产地_In, 批号_In, 效期_In, 填写数量_In,
     实际数量_In, 成本价_In, 成本金额_In, 零售价_In, 零售金额_In, 差价_In, 摘要_In, 填制人_In, 填制日期_In, 领用人_In, 批准文号_In, 发药方式_In, n_上次供应商id,
     d_上次生产日期, 修改人_In, 修改日期_In);
  
  Zl_未审药品记录_Insert(n_收发id);

  --更新库存数据
  Zl_药品库存_Update(n_收发id, 0);


Exception
  When Err_Isnonumber Then
    Select 编码 Into v_编码 From 收费项目目录 Where ID = 药品id_In;
    Raise_Application_Error(-20101,
                            '[ZLSOFT]编码为' || v_编码 || ',批号为' || 批号_In || '的分批核算药品' || Chr(10) || Chr(13) ||
                             '可用库存数量不够！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品领用_Insert;
/

--119437:胡俊勇,2018-01-09,临床相关消息修改
--115972:胡俊勇,2018-01-05,原液皮试药品费用减数量
--111037:余伟节,2018-01-04,发送婴儿死亡医嘱时自动更新死亡时间
CREATE OR REPLACE Procedure Zl_病人医嘱发送_Insert
(
  医嘱id_In     In 病人医嘱发送.医嘱id%Type,
  发送号_In     In 病人医嘱发送.发送号%Type,
  记录性质_In   In 病人医嘱发送.记录性质%Type,
  No_In         In 病人医嘱发送.No%Type,
  记录序号_In   In 病人医嘱发送.记录序号%Type,
  发送数次_In   In 病人医嘱发送.发送数次%Type,
  首次时间_In   In 病人医嘱发送.首次时间%Type,
  末次时间_In   In 病人医嘱发送.末次时间%Type,
  发送时间_In   In 病人医嘱发送.发送时间%Type,
  执行状态_In   In 病人医嘱发送.执行状态%Type,
  执行部门id_In In 病人医嘱发送.执行部门id%Type,
  计费状态_In   In 病人医嘱发送.计费状态%Type,
  First_In      In Number := 0,
  样本条码_In   In 病人医嘱发送.样本条码%Type := Null,
  操作员编号_In In 人员表.编号%Type := Null,
  操作员姓名_In In 人员表.姓名%Type := Null,
  领药号_In     In 未发药品记录.领药号%Type := Null,
  门诊记帐_In   In 病人医嘱发送.门诊记帐%Type := Null,
  分解时间_In   In Varchar2 := Null,
  原液皮试_In   In Varchar2 := Null
  --功能：填写病人医嘱发送记录
  --参数：
  --      医嘱id_In=要发送的每个医嘱ID
  --      First_IN=表示是否一组医嘱的第一医嘱行,以便处理医嘱相关内容(如成药,配方的第一行,因为给药途径,配方煎法,用法可能为叮嘱不发送)
  --      发送数次_IN,首次时间_IN,末次时间_IN:对"持续性"长嘱,不填写发送数次,可填写首末次时间(用于回退)。
  --      门诊记帐_In,住院临嘱发送到门诊记帐时才填写为1（因为记录性质是2，用于区分住院记帐），其余情况均填空。
  --      源液皮试_In 原液皮试医嘱ID，需求号7107/bug115972用于关联药品医嘱行和皮试医嘱行。关联字段为 病人医嘱发送.标本发送批号 存入药品行的医嘱ID值
  --      格式：1医嘱ID,2医嘱ID 前面一个为皮试医嘱的医嘱ID，第二个为药品行医嘱的医嘱ID
) Is
  --包含病人及医嘱(一组医嘱中第一行)相关信息的游标
  Cursor c_Advice Is
    Select Nvl(a.相关id, a.Id) As 组id, a.序号, a.病人id, a.主页id, a.婴儿, a.姓名, a.病人科室id, c.操作类型, a.诊疗类别, a.医嘱期效, a.医嘱状态, a.医嘱内容,
           a.开嘱医生, a.开嘱时间, a.开始执行时间, a.上次执行时间, a.执行终止时间, a.执行时间方案, a.频率次数, a.频率间隔, a.间隔单位, a.开嘱科室id, a.标本部位, a.执行科室id,
           a.相关id, a.诊疗项目id, a.挂号单
    From 病人医嘱记录 A, 诊疗项目目录 C
    Where a.诊疗项目id = c.Id And a.Id = 医嘱id_In;
  r_Advice c_Advice%RowType;

  --包含病人(婴儿)的所有未停长嘱(含配方长嘱),婴儿传入-1表示都处理
  Cursor c_Needstop
  (
    v_病人id   病人医嘱记录.病人id%Type,
    v_主页id   病人医嘱记录.主页id%Type,
    v_婴儿     病人医嘱记录.婴儿%Type,
    v_Stoptime Date
  ) Is
    Select a.Id, a.诊疗类别, b.操作类型, b.执行频率
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id(+) And a.病人id = v_病人id And a.主页id = v_主页id And (v_婴儿 = -1 Or Nvl(a.婴儿, 0) = Nvl(v_婴儿, 0)) And
          Nvl(a.医嘱期效, 0) = 0 And a.医嘱状态 Not In (1, 2, 4, 8, 9) And a.开始执行时间 < v_Stoptime
    Order By a.序号;
  --包含病人(婴儿)的已停但未确认的长嘱,终止执行时间在指定时间之后,婴儿传入-1表示都处理
  Cursor c_Havestop
  (
    v_病人id   病人医嘱记录.病人id%Type,
    v_主页id   病人医嘱记录.主页id%Type,
    v_婴儿     病人医嘱记录.婴儿%Type,
    v_Stoptime Date
  ) Is
    Select ID
    From 病人医嘱记录
    Where 病人id = v_病人id And 主页id = v_主页id And (v_婴儿 = -1 Or Nvl(婴儿, 0) = Nvl(v_婴儿, 0)) And Nvl(医嘱期效, 0) = 0 And
          医嘱状态 = 8 And 执行终止时间 > v_Stoptime And 开始执行时间 < v_Stoptime
    Order By 序号;

  --其它临时变量
  v_婴儿       病人医嘱记录.婴儿%Type;
  v_持续性     Number(1); --是否持续性长嘱
  v_Autostop   Number(1);
  v_Date       Date;
  v_Temp       Varchar2(255);
  v_人员编号   人员表.编号%Type;
  v_人员姓名   人员表.姓名%Type;
  v_停止时间   病人医嘱记录.开嘱时间%Type;
  n_执行状态   病人医嘱发送.执行状态%Type;
  d_开始时间   病人医嘱记录.开始执行时间%Type;
  v_Count      Number;
  n_皮试标号   病人医嘱发送.医嘱id%Type;
  n_皮试医嘱id 病人医嘱发送.医嘱id%Type;

  v_Stopadviceids 病人医嘱记录.医嘱内容%Type;
  n_Adviceid      病人医嘱记录.病人id%Type;
  n_标记          Number(18);
  v_Error         Varchar2(255);
  Err_Custom Exception;
Begin
  --当前操作人员
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
    v_人员编号 := 操作员编号_In;
    v_人员姓名 := 操作员姓名_In;
  Else
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;
  --如果首次时间为空则填入开始执行时间
  If 首次时间_In Is Null Or 分解时间_In Is Null Or 末次时间_In Is Null Then
    Select 开始执行时间 Into d_开始时间 From 病人医嘱记录 Where ID = 医嘱id_In;
  End If;

  Open c_Advice;
  Fetch c_Advice
    Into r_Advice;
  Close c_Advice;

  --是一组医嘱的第一行时处理医嘱内容
  If Nvl(First_In, 0) = 1 Then
    --并发操作检查
    ---------------------------------------------------------------------------------------
    If Nvl(r_Advice.医嘱状态, 0) = 4 Then
      --检查要发送的医嘱是否被作废
      v_Error := '"' || r_Advice.姓名 || '"的医嘱"' || r_Advice.医嘱内容 || '"已经被其他人作废。' || Chr(13) || Chr(10) ||
                 '该病人的医嘱发送失败。请重新读取发送清单再试。';
      Raise Err_Custom;
    End If;
  
    If Nvl(r_Advice.医嘱期效, 0) = 0 Then
      --长嘱：含成药长嘱,配方长嘱,非药"可选频率"长嘱,非药"持续性"长嘱
    
      --检查长嘱是否已被发送
      If r_Advice.上次执行时间 Is Not Null Then
        If r_Advice.上次执行时间 >= 首次时间_In Then
          v_Error := '"' || r_Advice.姓名 || '"的医嘱"' || r_Advice.医嘱内容 || '"已经被其他人发送。' || Chr(13) || Chr(10) ||
                     '该病人的医嘱发送失败。请重新读取发送清单再试。';
          Raise Err_Custom;
        End If;
      End If;
    
      --检查长嘱发送前是否已被自动停止(如术后)
      If r_Advice.执行终止时间 Is Not Null Then
        If 首次时间_In > r_Advice.执行终止时间 Then
          v_Error := '"' || r_Advice.姓名 || '"的医嘱"' || r_Advice.医嘱内容 || '"已经被停止。' || Chr(13) || Chr(10) ||
                     '该病人的医嘱发送失败。请重新读取发送清单再试。';
          Raise Err_Custom;
        End If;
      End If;
    Elsif Nvl(r_Advice.医嘱状态, 0) In (8, 9) Then
      --临嘱：含配方临嘱
    
      --检查是否已被发送(或因其它原因自动停止)
      v_Error := '"' || r_Advice.姓名 || '"的医嘱"' || r_Advice.医嘱内容 || '"已经被其他人发送。' || Chr(13) || Chr(10) ||
                 '该病人的医嘱发送失败。请重新读取发送清单再试。';
      Raise Err_Custom;
    End If;
  
    --发送后的医嘱处理
    ---------------------------------------------------------------------------------------
    If Nvl(r_Advice.医嘱期效, 0) = 0 Then
      --长期医嘱:更新上次执行时间
      Update 病人医嘱记录 Set 上次执行时间 = 末次时间_In Where ID = r_Advice.组id Or 相关id = r_Advice.组id;
    
      --判断是否持续性长嘱
      v_持续性 := 0;
      If r_Advice.执行时间方案 Is Null And (Nvl(r_Advice.频率次数, 0) = 0 Or Nvl(r_Advice.频率间隔, 0) = 0 Or r_Advice.间隔单位 Is Null) Then
        v_持续性 := 1;
      End If;
    
      --预定了终止时间且未停止的自动停止
      If r_Advice.执行终止时间 Is Not Null And Nvl(r_Advice.医嘱状态, 0) Not In (8, 9) Then
        v_Autostop := 0;
        If v_持续性 = 1 Then
          --非药"持续性"长嘱
          If Trunc(末次时间_In) = Trunc(r_Advice.执行终止时间 - 1) Then
            v_Autostop := 1; --终止这天不执行
          End If;
        Elsif Zl_Advicenexttime(医嘱id_In) > r_Advice.执行终止时间 Then
          --成药长嘱或非药"可选频率"长嘱
          v_Autostop := 1; --如果是等于,还可以执行一次
        End If;
      
        If v_Autostop = 1 Then
          Update 病人医嘱记录
          Set 医嘱状态 = 8, 停嘱时间 = 末次时间_In, 停嘱医生 = r_Advice.开嘱医生
          Where ID = r_Advice.组id Or 相关id = r_Advice.组id;
          v_Temp := zl_GetSysParameter(271);
          If v_Temp = '1' Then
            v_Temp := '自动停止：预定停止时间。';
          Else
            v_Temp := Null;
          End If;
          Insert Into 病人医嘱状态
            (医嘱id, 操作类型, 操作人员, 操作时间, 操作说明)
            Select ID, 8, r_Advice.开嘱医生, 发送时间_In, v_Temp
            From 病人医嘱记录
            Where ID = r_Advice.组id Or 相关id = r_Advice.组id;
          v_Stopadviceids := v_Stopadviceids || ',' || r_Advice.组id;
        End If;
      End If;
    Else
      --临嘱停止。
      --住院医生发送时自动校对、停止：校对是以Sysdate取的,为避免重复,停止时间也取Sysdate
      Select Sysdate Into v_Date From Dual;
      Update 病人医嘱记录
      Set 医嘱状态 = 8, 执行终止时间 = 末次时间_In,
          --为一次性临嘱时没有
          上次执行时间 = 末次时间_In,
          --为一次性临嘱时没有
          停嘱时间 = v_Date,
          --发送时间_IN,
          停嘱医生 = r_Advice.开嘱医生
      Where ID = r_Advice.组id Or 相关id = r_Advice.组id;
    
      Insert Into 病人医嘱状态
        (医嘱id, 操作类型, 操作人员, 操作时间)
        Select ID, 8, v_人员姓名, v_Date --发送时间_IN
        From 病人医嘱记录
        Where ID = r_Advice.组id Or 相关id = r_Advice.组id;
    End If;
  
    --特殊医嘱的处理
    ---------------------------------------------------------------------------------------
    If r_Advice.诊疗类别 = 'Z' And Nvl(r_Advice.操作类型, '0') <> '0' Then
      --(1-留观;2-住院;)3-转科;4-术后(不发送);5-出院;6-转院,7-会诊,11-死亡
    
      --几种特殊医嘱要自动停止病人该医嘱之前(按时间算)所有未停的长嘱
      If r_Advice.操作类型 In ('3', '5', '6', '11') Then
        If Nvl(r_Advice.婴儿, 0) = 0 Then
          v_婴儿 := -1;
        Else
          v_婴儿 := Nvl(r_Advice.婴儿, 0);
        End If;
        For r_Needstop In c_Needstop(r_Advice.病人id, r_Advice.主页id, v_婴儿, r_Advice.开始执行时间) Loop
          Select Decode(Sign(开始执行时间 - r_Advice.开始执行时间), 1, 开始执行时间, r_Advice.开始执行时间)
          Into v_停止时间
          From 病人医嘱记录
          Where ID = r_Needstop.Id;
          Update 病人医嘱记录
          Set 医嘱状态 = 8, 执行终止时间 = v_停止时间, 停嘱时间 = 发送时间_In, 停嘱医生 = r_Advice.开嘱医生
          Where ID = r_Needstop.Id;
        
          Insert Into 病人医嘱状态
            (医嘱id, 操作类型, 操作人员, 操作时间)
            Select ID, 8, v_人员姓名, 发送时间_In From 病人医嘱记录 Where ID = r_Needstop.Id;
          v_Stopadviceids := v_Stopadviceids || ',' || r_Needstop.Id;
        End Loop;
        --已停止未确认的长嘱,终止时间在医嘱开始后的,调前其终止时间(同时多个特殊医嘱的情况)
        For r_Havestop In c_Havestop(r_Advice.病人id, r_Advice.主页id, v_婴儿, r_Advice.开始执行时间) Loop
          Update 病人医嘱记录
          Set 执行终止时间 = Decode(Sign(开始执行时间 - r_Advice.开始执行时间), 1, 开始执行时间, r_Advice.开始执行时间), 停嘱时间 = 发送时间_In,
              停嘱医生 = r_Advice.开嘱医生
          Where ID = r_Havestop.Id;
        
          --不修改停止医嘱的操作人员，因为停止时，医生可能已进行电子签名
          Update 病人医嘱状态 Set 操作时间 = 发送时间_In Where 医嘱id = r_Havestop.Id And 操作类型 = 8;
          v_Stopadviceids := v_Stopadviceids || ',' || r_Havestop.Id;
        End Loop;
        --处理长期备用医嘱(没有执行（发送）过的标记未用）,同时处理临嘱
        Update 病人医嘱记录
        Set 执行标记 = -1
        Where 病人id = r_Advice.病人id And 主页id = r_Advice.主页id And
              (医嘱期效 = 0 And 执行频次 = '必要时' And 上次执行时间 Is Null And 医嘱状态 In (3, 5, 6, 7) Or
              医嘱期效 = 1 And 执行频次 = '需要时' And 医嘱状态 = 3) And 执行标记 <> -1;
      End If;
    
      --具体的特殊处理
      If Nvl(r_Advice.婴儿, 0) = 0 Then
        If r_Advice.操作类型 = '3' And 执行部门id_In Is Not Null And r_Advice.病人科室id Is Not Null And
           Nvl(r_Advice.病人科室id, 0) <> Nvl(执行部门id_In, 0) Then
          --转科医嘱,将病人登记转科到"执行科室ID"(在院病人且当前科室与转入科室不同才处理)
          Select Count(1)
          Into v_Temp
          From 病案主页
          Where 病人id = r_Advice.病人id And 主页id = r_Advice.主页id And 出院科室id <> 执行部门id_In;
          If v_Temp = '1' Then
            Zl_病人变动记录_Change(r_Advice.病人id, r_Advice.主页id, 执行部门id_In, v_人员编号, v_人员姓名);
          End If;
        Elsif r_Advice.操作类型 In ('5', '6', '11') Then
          --出院、转院、死亡医嘱,将病人标记为预出院
          Begin
            Select 开始时间
            Into v_Date
            From 病人变动记录
            Where 开始时间 Is Not Null And 终止时间 Is Null And 病人id = r_Advice.病人id And 主页id = r_Advice.主页id;
          Exception
            When Others Then
              v_Date := To_Date('1900-01-01', 'YYYY-MM-DD');
          End;
          If r_Advice.开始执行时间 <= v_Date Then
            v_Error := '医嘱"' || r_Advice.医嘱内容 || '"的开始时间应大于该病人上次变动时间 ' || To_Char(v_Date, 'YYYY-MM-DD HH24:Mi') || ' 。';
            Raise Err_Custom;
          End If;
          Zl_病人变动记录_Preout(r_Advice.病人id, r_Advice.主页id, r_Advice.开始执行时间);
        End If;
      Else
        If r_Advice.操作类型 = '11' Then
          Update 病人新生儿记录
          Set 死亡时间 = r_Advice.开始执行时间
          Where 病人id = r_Advice.病人id And Nvl(主页id, 0) = Nvl(r_Advice.主页id, 0) And Nvl(序号, 0) = Nvl(r_Advice.婴儿, 0);
        End If;
      End If;
    End If;
    --12小时未执行的备用临嘱处理为标记未用
    If r_Advice.医嘱期效 = 1 Then
      Update 病人医嘱记录
      Set 执行标记 = -1
      Where 病人id = r_Advice.病人id And 主页id = r_Advice.主页id And 执行标记 <> -1 And 医嘱期效 = 1 And 执行频次 = '需要时' And
            Sysdate - 开始执行时间 > 0.5 And 医嘱状态 = 3;
    End If;
  End If;

  --填写发送记录
  ---------------------------------------------------------------------------------------
  n_执行状态 := 执行状态_In;
  If 执行状态_In = 1 Then
    v_Temp := zl_GetSysParameter(186);
    If v_Temp = '11' Then
      If r_Advice.诊疗类别 = 'E' And r_Advice.操作类型 In ('1', '8') Or r_Advice.诊疗类别 = 'K' Then
        n_执行状态 := 0;
      End If;
    Elsif v_Temp = '01' Then
      If r_Advice.诊疗类别 = 'E' And r_Advice.操作类型 = '1' Then
        n_执行状态 := 0;
      End If;
    Elsif v_Temp = '10' Then
      If r_Advice.诊疗类别 = 'E' And r_Advice.操作类型 = '8' Or r_Advice.诊疗类别 = 'K' Then
        n_执行状态 := 0;
      End If;
    End If;
  End If;

  If 原液皮试_In Is Not Null Then
    v_Count      := Instr(原液皮试_In, ',');
    n_皮试医嘱id := Substr(原液皮试_In, 1, v_Count - 1);
    n_皮试标号   := Substr(原液皮试_In, v_Count + 1);
    Update 病人医嘱发送 Set 标本发送批号 = n_皮试标号 Where 医嘱id = n_皮试医嘱id;
  End If;

  Insert Into 病人医嘱发送
    (医嘱id, 发送号, 记录性质, NO, 记录序号, 发送数次, 发送人, 发送时间, 执行状态, 执行部门id, 计费状态, 首次时间, 末次时间, 样本条码, 门诊记帐, 标本发送批号)
  Values
    (医嘱id_In, 发送号_In, 记录性质_In, No_In, 记录序号_In, 发送数次_In, v_人员姓名, 发送时间_In, n_执行状态, 执行部门id_In, 计费状态_In,
     Nvl(首次时间_In, d_开始时间), Nvl(末次时间_In, d_开始时间), 样本条码_In, 门诊记帐_In, n_皮试标号);

  --手术和检查医嘱同步更新主医嘱的计费状态
  If 计费状态_In = 1 And r_Advice.组id <> 医嘱id_In And (r_Advice.诊疗类别 = 'D' Or r_Advice.诊疗类别 = 'F') Then
    Update 病人医嘱发送 Set 计费状态 = 1 Where 医嘱id = r_Advice.组id And 发送号 = 发送号_In;
  End If;

  --领药号的填写
  If 领药号_In Is Not Null Then
    Update 未发药品记录 Set 领药号 = 领药号_In Where NO = No_In And 单据 = 9 And 领药号 Is Null;
    Update 药品收发记录 Set 产品合格证 = 领药号_In Where NO = No_In And 单据 = 9 And 产品合格证 Is Null;
  End If;

  --自动填为已执行时，需要同步处理费用执行状态及审核划价状态
  If 执行状态_In = 1 Then
    Zl_病人医嘱执行_Finish(医嘱id_In, 发送号_In, Null, Null, v_人员编号, v_人员姓名, 执行部门id_In);
  End If;

  --产生医嘱执行时间记录(只产生主记录的)
  If Nvl(分解时间_In, To_Char(d_开始时间, 'yyyy-mm-dd hh24:mi:ss')) Is Not Null Then
    If r_Advice.相关id Is Null Then
      Insert Into 医嘱执行时间
        (要求时间, 医嘱id, 发送号)
        Select To_Date(Column_Value, 'yyyy-mm-dd hh24:mi:ss'), 医嘱id_In, 发送号_In
        From Table(f_Str2list(Nvl(分解时间_In, To_Char(d_开始时间, 'yyyy-mm-dd hh24:mi:ss'))));
    End If;
  End If;

  --病历书写时机的填写
  If r_Advice.诊疗类别 = 'F' Then
    --一组手术只调一次
    If r_Advice.相关id Is Null Then
      If Not r_Advice.标本部位 Is Null Then
        v_Date := To_Date(r_Advice.标本部位, 'yyyy-mm-dd hh24:mi:ss');
      Else
        v_Date := r_Advice.开始执行时间;
      End If;
      Zl_电子病历时机_Insert(r_Advice.病人id, r_Advice.主页id, 2, '手术', r_Advice.开嘱科室id, r_Advice.开嘱医生, v_Date, v_Date,
                       r_Advice.执行科室id);
    End If;
  Elsif r_Advice.诊疗类别 = 'Z' And r_Advice.操作类型 = '7' Then
    Zl_电子病历时机_Insert(r_Advice.病人id, r_Advice.主页id, 2, '会诊', r_Advice.开嘱科室id, r_Advice.开嘱医生, r_Advice.开始执行时间,
                     r_Advice.开始执行时间, r_Advice.执行科室id);
  Elsif r_Advice.诊疗类别 = 'Z' And r_Advice.操作类型 = '8' Then
    Zl_电子病历时机_Insert(r_Advice.病人id, r_Advice.主页id, 2, '抢救', r_Advice.开嘱科室id, r_Advice.开嘱医生, r_Advice.开始执行时间,
                     r_Advice.开始执行时间, r_Advice.执行科室id);
  Elsif r_Advice.诊疗类别 = 'Z' And r_Advice.操作类型 = '11' Then
    Zl_电子病历时机_Insert(r_Advice.病人id, r_Advice.主页id, 2, '死亡', r_Advice.开嘱科室id, r_Advice.开嘱医生, r_Advice.开始执行时间,
                     r_Advice.开始执行时间, r_Advice.执行科室id);
  End If;
  --额外调用(知情文件允许的诊疗类别才调用)
  If Instr('C,D,E,F,G,K,L', r_Advice.诊疗类别) > 0 Then
    Zl_电子病历时机_Insert(r_Advice.病人id, r_Advice.主页id, 2, '知情文书', r_Advice.开嘱科室id, r_Advice.开嘱医生, r_Advice.开始执行时间,
                     r_Advice.开始执行时间, r_Advice.执行科室id, r_Advice.诊疗项目id, r_Advice.医嘱内容);
  End If;
  --医嘱停止消息的处理
  If v_Stopadviceids Is Not Null Then
    v_Stopadviceids := Substr(v_Stopadviceids, 2);
    b_Message.Zlhis_Cis_002(r_Advice.病人id, r_Advice.主页id, Null, v_Stopadviceids);
    Select Max(a.Id)
    Into n_标记
    From 病人医嘱记录 A
    Where a.Id In (Select Column_Value From Table(f_Num2list(v_Stopadviceids))) And a.医嘱期效 = 0 And a.医嘱状态 = 8 And
          Nvl(a.执行标记, 0) <> -1 And a.病人来源 <> 3;
    If n_标记 Is Not Null Then
      Select Max(a.Id)
      Into n_Adviceid
      From 病人医嘱记录 A
      Where a.Id In (Select Column_Value From Table(f_Num2list(v_Stopadviceids))) And a.紧急标志 = 1 And a.医嘱期效 = 0 And
            a.医嘱状态 = 8 And Nvl(a.执行标记, 0) <> -1 And a.病人来源 <> 3;
      If n_Adviceid Is Not Null Then
        Select Nvl(Max(0), 2)
        Into n_标记
        From 业务消息清单 A
        Where a.病人id = r_Advice.病人id And a.就诊id = r_Advice.主页id And a.类型编码 = 'ZLHIS_CIS_002' And a.优先程度 = 2 And
              a.是否已阅 = 0;
      Else
        n_Adviceid := n_标记;
        Select Nvl(Max(0), 1)
        Into n_标记
        From 业务消息清单 A
        Where a.病人id = r_Advice.病人id And a.就诊id = r_Advice.主页id And a.类型编码 = 'ZLHIS_CIS_002' And a.是否已阅 = 0;
      End If;
      If n_标记 > 0 Then
        For R In (Select a.病人性质 As 性质, a.出院科室id As 科室id, a.当前病区id As 病区id
                  From 病案主页 A
                  Where a.病人id = r_Advice.病人id And a.主页id = r_Advice.主页id) Loop
          Zl_业务消息清单_Insert(r_Advice.病人id, r_Advice.主页id, r.科室id, r.病区id, r.性质, '有新停止医嘱。', '0010', 'ZLHIS_CIS_002',
                           n_Adviceid, n_标记, 0, Null, r.病区id);
        End Loop;
      End If;
    End If;
  End If;

  If r_Advice.诊疗类别 = 'E' And r_Advice.操作类型 = '6' Then
    --检验项目
    b_Message.Zlhis_Cis_016(r_Advice.病人id, r_Advice.主页id, r_Advice.挂号单, 发送号_In, r_Advice.组id, 2);
  Elsif r_Advice.诊疗类别 = 'D' And r_Advice.相关id Is Null Then
    b_Message.Zlhis_Cis_017(r_Advice.病人id, r_Advice.主页id, r_Advice.挂号单, 发送号_In, r_Advice.组id, 2);
  Elsif r_Advice.诊疗类别 = 'F' And r_Advice.相关id Is Null Then
    b_Message.Zlhis_Cis_018(r_Advice.病人id, r_Advice.主页id, r_Advice.挂号单, 发送号_In, r_Advice.组id);
  Elsif r_Advice.诊疗类别 = 'K' Then
    b_Message.Zlhis_Cis_019(r_Advice.病人id, r_Advice.主页id, r_Advice.挂号单, 发送号_In, r_Advice.组id);
  Elsif r_Advice.诊疗类别 = 'Z' Then
    If r_Advice.操作类型 = '7' Then
      b_Message.Zlhis_Cis_020(r_Advice.病人id, r_Advice.主页id, 发送号_In, r_Advice.组id);
    Elsif r_Advice.操作类型 = '8' Then
      b_Message.Zlhis_Cis_021(r_Advice.病人id, r_Advice.主页id, 发送号_In, r_Advice.组id);
    Elsif r_Advice.操作类型 = '11' Then
      b_Message.Zlhis_Cis_022(r_Advice.病人id, r_Advice.主页id, 发送号_In, r_Advice.组id);
    End If;
  Elsif r_Advice.诊疗类别 = 'E' And r_Advice.操作类型 = '5' Then
    b_Message.Zlhis_Cis_023(r_Advice.病人id, r_Advice.主页id, 发送号_In, r_Advice.组id);
  End If;
  
  --病区执行医嘱发送
  Select Count(1) Into n_标记 From 部门性质说明 B Where b.部门id = r_Advice.执行科室id And b.工作性质 = '护理';
  If n_标记 > 0 Then
    b_Message.Zlhis_Cis_026(r_Advice.病人id, r_Advice.主页id, 发送号_In, 医嘱id_In);
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱发送_Insert;
/

--119437:胡俊勇,2018-01-09,临床相关消息修改
--111037:余伟节,2018-01-04,作废婴儿死亡医嘱更新死亡时间
CREATE OR REPLACE Procedure Zl_病人医嘱记录_作废
(
  Id_In         In 病人医嘱记录.Id%Type,
  操作员编号_In In 人员表.编号%Type := Null,
  操作员姓名_In In 人员表.姓名%Type := Null,
  护理医嘱id_In In 病人医嘱记录.Id%Type := Null,
  作废时间_In   In 病人医嘱状态.操作时间%Type := Null
) Is
  --功能：作废指定的医嘱(未发送的长嘱或临嘱)
  --说明：一并给药的只能调用一次(界面显示有多行)
  --参数：ID_IN=组医嘱ID
  --      护理医嘱id_In 取除开本次作废的护理等级医嘱外的最近的自动停止的护理等级医嘱id
  v_发送号       病人医嘱发送.发送号%Type;
  v_费用no       门诊费用记录.No%Type;
  v_记录性质     门诊费用记录.记录性质%Type;
  v_费用序号     Varchar2(255);
  n_自动取消执行 Number(1) := 0;
  n_先作废后退药 Number(1) := 0;

  v_Date     Date;
  v_Count    Number;
  v_Temp     Varchar2(255);
  v_人员编号 人员表.编号%Type;
  v_人员姓名 人员表.姓名%Type;
  v_No       病人医嘱发送.No%Type;

  --包含医嘱相关信息
  Cursor c_Advice Is
    Select Nvl(a.相关id, a.Id) As 组id, a.病人id, a.挂号单, a.主页id, a.婴儿, a.医嘱状态, a.上次执行时间, a.医嘱内容, a.诊疗类别, b.操作类型, a.病人来源,
           a.执行科室id, b.执行频率, a.诊疗项目id, a.开始执行时间
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id And a.Id = Id_In;
  r_Advice c_Advice%RowType;

  --门诊医嘱作废时，取对应的费用销帐或作废(收费划价单)：
  --根据医嘱及发送NO求出本次回退要销帐或退费的记录
  --一组医嘱并不是都填写了发送记录,也不一定都计费了,且可能NO不同
  --只管记录状态为1的记录,如果已经销帐或部份销帐的记录,不再处理
  --费用只求价格父号为空的,以便取序号销帐
  --如果【门诊药嘱先作废后退药】,则不对相应费用(包括给药途径的)进行检查和处理,除非是还没有执行的记帐单,或未执行、收费的划价单，可以先删了。

  Cursor c_Rollmoney(v_发送号 病人医嘱发送.发送号%Type) Is
    Select Decode(a.记录性质, 11, 1, a.记录性质) As 记录性质, a.记录状态, a.No, a.序号, a.执行状态 As 费用执行, c.执行状态 As 医嘱执行, c.执行部门id, b.病人科室id,
           b.诊疗类别, i.操作类型
    From 门诊费用记录 A, 病人医嘱记录 B, 病人医嘱发送 C, 诊疗项目目录 I
    Where c.医嘱id = b.Id And c.发送号 = v_发送号 And (b.Id = Id_In Or b.相关id = Id_In) And a.医嘱序号 = b.Id And a.记录状态 In (0, 1) And
          a.No = c.No And (a.记录性质 = c.记录性质 Or a.记录性质 = 11 And c.记录性质 = 1) And b.诊疗项目id = i.Id And a.价格父号 Is Null And
          (n_先作废后退药 = 0 Or
          n_先作废后退药 = 1 And
          Not (Exists (Select 1
                        From 门诊费用记录 D
                        Where d.医嘱序号 = b.Id And d.记录状态 In (0, 1) And d.No = c.No And
                              (d.记录性质 = c.记录性质 Or d.记录性质 = 11 And c.记录性质 = 1) And d.收费类别 In ('5', '6', '7'))) Or
          Nvl(a.执行状态, 0) = 0 And Not (a.记录性质 = 1 And a.记录状态 <> 0))
    Order By a.记录性质, a.No, a.序号, a.收费细目id;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --检查医嘱状态是否正确:并发操作
  Open c_Advice;
  Fetch c_Advice
    Into r_Advice;

  --当前操作人员
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
    v_人员编号 := 操作员编号_In;
    v_人员姓名 := 操作员姓名_In;
  Else
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;

  --检查是否已经出了报告单，已经出报告单的医嘱不能够作废
  Select Count(1) Into v_Count From 病人医嘱报告 Where 医嘱id = Id_In;
  If v_Count > 0 Then
    If Not (r_Advice.操作类型 = '7' And r_Advice.诊疗类别 = 'Z') Then
      v_Error := '医嘱"' || r_Advice.医嘱内容 || '"已出报告，不能作废。';
      Raise Err_Custom;
    End If;
  End If;

  --检查是否是输液配液记录，并是否已经锁定
  Select Count(1) Into v_Count From 输液配药记录 Where 是否锁定 = 1 And 医嘱id = Id_In;
  If v_Count > 0 Then
    v_Error := '医嘱"' || r_Advice.医嘱内容 || '"是输液药品，已经被输液配置中心锁定，不能作废。';
    Raise Err_Custom;
  End If;

  If r_Advice.挂号单 Is Null And r_Advice.病人来源 <> 3 Then
    If r_Advice.医嘱状态 In (4, 8, 9) Then
      v_Error := '医嘱"' || r_Advice.医嘱内容 || '"已经被作废或停止，不能再作废。';
      Raise Err_Custom;
    Elsif r_Advice.上次执行时间 Is Not Null Then
      v_Error := '医嘱"' || r_Advice.医嘱内容 || '"已经发送，不能被作废。';
      Raise Err_Custom;
    End If;
  
    --持续性护理等级无须发送，校对后就可能已自动计费，作废及回退作废都应按停止流程处理。
    If r_Advice.诊疗类别 = 'H' And r_Advice.操作类型 = '1' And r_Advice.执行频率 = '2' And Nvl(r_Advice.婴儿, 0) = 0 Then
      --(已取消，由于存在无费退院的情况，问题号：45977)a.开始时间是当天之前的，说明已生效（自动费用计算），不允许作废。
      --医嘱的时间只精确到了分钟，所以变动记录的开始时间要去掉秒来比较。
      v_Count := 0;
      Begin
        Select b.终止时间
        Into v_Date
        From 病人变动记录 B, 病人医嘱计价 C
        Where b.病人id = r_Advice.病人id And b.主页id = r_Advice.主页id And c.医嘱id = Id_In And c.收费细目id = b.护理等级id And
              b.开始原因 = 6 And b.附加床位 = 0 And
              To_Char(b.开始时间, 'yyyy-mm-dd hh24:mi') = To_Char(r_Advice.开始执行时间, 'yyyy-mm-dd hh24:mi');
      Exception
        When Others Then
          v_Count := 1;
      End;
      If v_Count = 0 Then
        --d.后续有其他变动发生
        If v_Date Is Not Null Then
          v_Error := '由于护理等级医嘱生效后已经产生了其他变动记录,不能作废该医嘱。';
          Raise Err_Custom;
        Else
          --本次有要自动启用的护理等级，如果和原来护理等级相同则不用撤消护理变动记录
          If Nvl(护理医嘱id_In, 0) <> 0 Then
            Delete 病人医嘱状态 Where 医嘱id = 护理医嘱id_In And 操作类型 In (8, 9);
            Select 操作类型
            Into v_Count
            From (Select 操作类型 From 病人医嘱状态 Where 医嘱id = 护理医嘱id_In Order By 操作时间 Desc)
            Where Rownum < 2;
            Update 病人医嘱记录
            Set 医嘱状态 = v_Count, 执行终止时间 = Null, 停嘱医生 = Null, 停嘱时间 = Null, 确认停嘱时间 = Null, 确认停嘱护士 = Null
            Where ID = 护理医嘱id_In;
            --排除过于频繁的操作
            Select Count(a.Id)
            Into v_Count
            From 病人医嘱记录 A, 诊疗收费关系 B, 病案主页 C
            Where a.诊疗项目id = b.诊疗项目id And c.护理等级id = b.收费项目id And c.病人id = a.病人id And c.主页id = a.主页id And
                  a.Id = 护理医嘱id_In;
          End If;
          If v_Count = 0 Then
            --c.护理等级是最后一条变动
            Zl_病人变动记录_Undo(r_Advice.病人id, r_Advice.主页id, v_人员编号, v_人员姓名, '1', Null, Null, '护理等级变动');
          End If;
        End If;
      Else
        --恢复最近一次被自动停止的护理等级
        If Nvl(护理医嘱id_In, 0) <> 0 Then
          Delete 病人医嘱状态 Where 医嘱id = 护理医嘱id_In And 操作类型 In (8, 9);
          Select 操作类型
          Into v_Count
          From (Select 操作类型 From 病人医嘱状态 Where 医嘱id = 护理医嘱id_In Order By 操作时间 Desc)
          Where Rownum < 2;
          Update 病人医嘱记录
          Set 医嘱状态 = v_Count, 执行终止时间 = Null, 停嘱医生 = Null, 停嘱时间 = Null, 确认停嘱时间 = Null, 确认停嘱护士 = Null
          Where ID = 护理医嘱id_In;
        Else
          --病人入院时指定的护理级产生的变动记录和医嘱新开产生的变动记录不同，这里要先判断
          Select Count(a.Id)
          Into v_Count
          From 病人变动记录 A
          Where a.病人id = r_Advice.病人id And a.主页id = r_Advice.主页id And a.开始原因 = 6;
          If v_Count <> 0 Then
            --b.如果与以前的护理等级相同，则校对时没有产生护理等级变动,产生护理等级停止变动
            Zl_病人变动记录_Nurse(r_Advice.病人id, r_Advice.主页id, Null, Sysdate, v_人员编号, v_人员姓名);
          End If;
        End If;
      End If;
    End If;
  Else
    If r_Advice.医嘱状态 <> 8 Then
      v_Error := '医嘱"' || r_Advice.医嘱内容 || '"尚未发送或已经作废。';
      Raise Err_Custom;
    End If;
    --医嘱附费判断
    Select Count(1)
    Into v_Count
    From 病人医嘱附费 A, 病人医嘱记录 B
    Where a.医嘱id = b.Id And (b.Id = Id_In Or b.相关id = Id_In);
    If v_Count <> 0 Then
      v_Error := '医嘱"' || r_Advice.医嘱内容 || '"存在附加费用，不能作废。';
      Raise Err_Custom;
    End If;
  
    Begin
      --医嘱ID为传入值的这条医嘱不一定发送了的,甚至无发送。
      Select Distinct 发送号
      Into v_发送号
      From 病人医嘱发送
      Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = Id_In Or 相关id = Id_In);
    Exception
      When Others Then
        v_发送号 := Null;
    End;
  
    Select Zl_To_Number(Nvl(zl_GetSysParameter(68), 0)) Into n_先作废后退药 From Dual;
    Select Zl_To_Number(Nvl(zl_GetSysParameter('门诊本科自动执行', '1252'), 0)) Into n_自动取消执行 From Dual;
    If n_自动取消执行 = 1 And v_发送号 Is Not Null Then
      --先更新医嘱和费用的执行状态，因为后续的判断，以及过程Zl_门诊记帐记录_Delete中有检查
      For Rc In (Select a.医嘱id, a.执行部门id
                 From 病人医嘱发送 A, 病人医嘱记录 B
                 Where a.医嘱id = b.Id And (b.Id = Id_In Or b.相关id = Id_In) And a.执行部门id = b.病人科室id) Loop
        Zl_病人医嘱执行_Cancel(Rc.医嘱id, v_发送号, Null, 1, Rc.执行部门id);
      End Loop;
    End If;
  
    --门诊医嘱只可能发送一次
    --后面退费时还有检查，因为可能医嘱没有费用，所以要检查一次执行状态
    Select Count(*)
    Into v_Count
    From 病人医嘱发送 A, 病人医嘱记录 B, 诊疗项目目录 I
    Where a.医嘱id = b.Id And b.诊疗项目id = i.Id And a.执行状态 In (1, 3) And (b.Id = Id_In Or b.相关id = Id_In) And
          (n_先作废后退药 = 0 Or
          n_先作废后退药 = 1 And Not (b.诊疗类别 In ('5', '6', '7') Or b.诊疗类别 = 'E' And i.操作类型 In ('2', '3', '4')));
    If v_Count > 0 Then
      v_Error := '该医嘱已经执行或正在执行，不能作废。';
      Raise Err_Custom;
    End If;
  End If;

  If 作废时间_In Is Null Then
    Select Sysdate Into v_Date From Dual;
  Else
    v_Date := 作废时间_In;
  End If;

  Update 病人医嘱记录 Set 医嘱状态 = 4 Where ID = Id_In Or 相关id = Id_In;

  Insert Into 病人医嘱状态
    (医嘱id, 操作类型, 操作人员, 操作时间)
    Select ID, 4, v_人员姓名, v_Date From 病人医嘱记录 Where ID = Id_In Or 相关id = Id_In;

  --住院医嘱作废时,未打印的情况下,缺省设置为屏蔽打印
  If r_Advice.挂号单 Is Null Then
    Select Count(*)
    Into v_Count
    From 病人医嘱打印
    Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = Id_In Or 相关id = Id_In);
    If Nvl(v_Count, 0) = 0 Then
      Zl_病人医嘱记录_屏蔽打印(Id_In, 1);
    End If;
    If Nvl(r_Advice.婴儿, 0) > 0 And r_Advice.操作类型 = '11' Then
      Update 病人新生儿记录
      Set 死亡时间 = Null
      Where 病人id = r_Advice.病人id And Nvl(主页id, 0) = Nvl(r_Advice.主页id, 0) And 序号 = Nvl(r_Advice.婴儿, 0);
    End If;
  Else
    --门诊医嘱(临嘱)作废时还需要回退相关内容:只有一次发送
    --回退划价或记帐费用
    If v_发送号 Is Not Null Then
      --将该组医嘱的费用删除或销帐(按一组医嘱可能有不同NO处理)
      --门诊记帐：如果原始费用已被销帐(或部分销帐),调用过程中有判断
      --门诊划价：如果已收费，则不允许删除
      v_费用no   := Null;
      v_费用序号 := Null;
      For r_Rollmoney In c_Rollmoney(v_发送号) Loop
        If Nvl(r_Rollmoney.医嘱执行, 0) In (1, 3) Then
          --1-完全执行;3-正在执行
          v_Error := '医嘱"' || r_Advice.医嘱内容 || '"已经执行或正在执行，不能作废。';
          Raise Err_Custom;
        End If;
        If Nvl(r_Rollmoney.费用执行, 0) In (1, 2) Then
          --1-完全执行;2-部份执行
          v_Error := '医嘱费用单据"' || r_Rollmoney.No || '"中的内容已经全部或部分执行，不能作废。';
          Raise Err_Custom;
        End If;
        If r_Rollmoney.费用执行 = 9 Then
          v_Error := '医嘱费用单据"' || r_Rollmoney.No || '"中的收费结算产生异常，不能作废。';
          Raise Err_Custom;
        End If;
        v_Count := 1;
        If r_Rollmoney.记录性质 = 1 And r_Rollmoney.记录状态 <> 0 Then
          If 1 = n_先作废后退药 And r_Rollmoney.诊疗类别 = 'E' And r_Rollmoney.操作类型 In ('2', '3', '4') Then
            v_Count := 0;
          Else
            v_Error := '医嘱费用单据"' || r_Rollmoney.No || '"已经收费，不能作废。';
            Raise Err_Custom;
          End If;
        End If;
        If 1 = v_Count Then
          If Nvl(v_费用no, '空') <> r_Rollmoney.No Then
            If v_费用序号 Is Not Null And v_费用no Is Not Null Then
              v_费用序号 := Substr(v_费用序号, 2);
              If v_记录性质 = 1 Then
                Zl_门诊划价记录_Delete(v_费用no, v_费用序号);
              Elsif v_记录性质 = 2 Then
                Zl_门诊记帐记录_Delete(v_费用no, v_费用序号, v_人员编号, v_人员姓名);
              End If;
            End If;
            v_费用序号 := Null;
          End If;
          v_记录性质 := r_Rollmoney.记录性质;
          v_费用no   := r_Rollmoney.No;
          v_费用序号 := v_费用序号 || ',' || r_Rollmoney.序号;
        End If;
      End Loop;
      If v_费用序号 Is Not Null And v_费用no Is Not Null Then
        v_费用序号 := Substr(v_费用序号, 2);
        If v_记录性质 = 1 Then
          Zl_门诊划价记录_Delete(v_费用no, v_费用序号);
        Elsif v_记录性质 = 2 Then
          Zl_门诊记帐记录_Delete(v_费用no, v_费用序号, v_人员编号, v_人员姓名);
        End If;
      End If;
    
      --如果"门诊药嘱先作废后退药"，则对应的给药途径费用设置为未执行，以便退费
      If n_先作废后退药 = 1 Then
        Update 门诊费用记录
        Set 执行状态 = 0
        Where 执行状态 = 1 And 医嘱序号 = Id_In And Exists
         (Select 1
               From 病人医嘱记录 A, 诊疗项目目录 B
               Where a.诊疗项目id = b.Id And b.类别 = 'E' And b.操作类型 In ('2', '3', '4') And a.Id = Id_In);
      End If;
    
      --回退医嘱发送记录(及执行记录)
      Delete From 病人医嘱执行 Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = Id_In Or 相关id = Id_In);
      Delete From 病人医嘱发送 Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = Id_In Or 相关id = Id_In);
    
      --回退特殊医嘱的处理
      If r_Advice.诊疗类别 = 'Z' And Nvl(r_Advice.操作类型, '0') <> '0' And Nvl(r_Advice.婴儿, 0) = 0 Then
      
        If r_Advice.操作类型 = '1' And r_Advice.执行科室id Is Not Null Then
          --留观医嘱
          Select Count(*)
          Into v_Count
          From 病案主页
          Where 病人id = r_Advice.病人id And Nvl(主页id, 0) = 0 And 入院科室id = r_Advice.执行科室id And 病人性质 In (1, 2);
          If v_Count = 1 Then
            Zl_入院病案主页_Delete(r_Advice.病人id, 0);
          End If;
        Elsif r_Advice.操作类型 = '2' And r_Advice.执行科室id Is Not Null Then
          --住院医嘱
          Select Count(*)
          Into v_Count
          From 病案主页
          Where 病人id = r_Advice.病人id And Nvl(主页id, 0) = 0 And 入院科室id = r_Advice.执行科室id And Nvl(病人性质, 0) = 0;
          If v_Count = 1 Then
            Zl_入院病案主页_Delete(r_Advice.病人id, 0);
          End If;
        End If;
      End If;
    End If;
  End If;

  --删除过敏登记记录
  If r_Advice.诊疗类别 = 'E' And r_Advice.操作类型 = '1' Then
    --Update 病人医嘱记录 Set 皮试结果=Null Where ID=ID_IN; --保留最后的皮试结果
    --删除不过敏的记录，过敏记录保留，因为不管医嘱是否作废，病人对该药过敏
    For r_Test In (Select 操作时间 From 病人医嘱状态 Where 医嘱id = Id_In And 操作类型 = 10) Loop
      Delete From 病人过敏记录
      Where 病人id = r_Advice.病人id And 记录来源 = 2 And Nvl(主页id, 0) = Nvl(r_Advice.主页id, 0) And 记录时间 = r_Test.操作时间 And
            Nvl(结果, 0) = 0;
    End Loop;
  End If;
  If r_Advice.诊疗项目id Is Not Null Then
    --非自由录入医嘱，住院病区执行医嘱作废，Zlhis_Cis_003
    If r_Advice.主页id Is Not Null Then
      For R In (Select a.Id
                From 病人医嘱记录 A
                Where (a.Id = Id_In Or a.相关id = Id_In) And Exists
                 (Select 1 From 部门性质说明 B Where b.部门id = a.执行科室id And b.工作性质 = '护理')) Loop
        b_Message.Zlhis_Cis_003(r_Advice.病人id, r_Advice.主页id, Null, r.Id);
      End Loop;
    End If;
  
    If r_Advice.挂号单 Is Not Null Then     
      If r_Advice.诊疗类别 = 'E' And r_Advice.操作类型 = '6' Or Instr(',D,F,K,', r_Advice.诊疗类别) > 0 Then
        Select Max(a.No) Into v_No From 病人医嘱发送 A Where a.医嘱id = r_Advice.组id;
        If r_Advice.诊疗类别 = 'E' And r_Advice.操作类型 = '6' Then
          --检验
          b_Message.Zlhis_Cis_036(r_Advice.病人id, Null, r_Advice.挂号单, v_发送号, r_Advice.组id, v_No, 1);
        Elsif r_Advice.诊疗类别 = 'D' Then
          --检查
          b_Message.Zlhis_Cis_037(r_Advice.病人id, Null, r_Advice.挂号单, v_发送号, r_Advice.组id, v_No, 1);
        Elsif r_Advice.诊疗类别 = 'F' Then
          --手术
          b_Message.Zlhis_Cis_038(r_Advice.病人id, Null, r_Advice.挂号单, v_发送号, r_Advice.组id, v_No);
        Elsif r_Advice.诊疗类别 = 'K' Then
          --输血
          b_Message.Zlhis_Cis_039(r_Advice.病人id, Null, r_Advice.挂号单, v_发送号, r_Advice.组id, v_No);
        End If;
      End If;
    End If;
  End If;
  Close c_Advice;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱记录_作废;
/

--119434:梁唐彬,2018-01-04,集成平台消息处理
Create Or Replace Procedure Zl_入院病案主页_Delete
(
  病人id_In     病案主页.病人id%Type,
  主页id_In     病案主页.主页id%Type,
  转留观_In     Number := 0,
  清除住院号_In Number := 0
  --功能：取消病人入院/预约登记
  --     主页ID_IN:为0时表示取消预约登记
  --     转留观_IN:将正常入院登记病人转为住院留观病人
  --     清除住院号_In:第一次住院的病人转留观时是否清除住院号
) As
  v_入院时间   病案主页.入院日期%Type;
  v_入院科室   病案主页.入院科室id%Type;
  v_出院时间   病案主页.出院日期%Type;
  v_住院号     病案主页.住院号%Type;
  v_再入院     病案主页.再入院%Type;
  v_出院科室id 病案主页.出院科室id%Type;
  n_病人性质   病案主页.病人性质%Type;
  n_主页id     病案主页.主页id%Type;

  v_Count Number;
  v_Error Varchar2(255);
  Err_Custom Exception;

  Function Checkpatiadvice
  (
    病人id_In 病案主页.病人id%Type,
    主页id_In 病案主页.主页id%Type
  ) Return Varchar2 Is
    --本次住院所有医嘱记录都已作废
    v_Err Varchar2(255);
  Begin
    v_Err := Null;
  
    For r_Row In (Select 开嘱医生, Decode(医嘱状态, -1, '暂存', 1, '新开', 2, '校对疑问', '未作废') As 状态, 医嘱内容
                  From 病人医嘱记录
                  Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(医嘱状态, 0) <> 4 And Rownum < 2) Loop
      v_Err := '【' || r_Row.开嘱医生 || '】医生有' || r_Row.状态 || '的医嘱没有处理,不允许取消登记！';
    End Loop;
    Return v_Err;
  End Checkpatiadvice;
Begin
  Select Nvl(状态, 0), Nvl(病人性质, 0)
  Into v_Count, n_病人性质
  From 病案主页
  Where 病人id = 病人id_In And 主页id = 主页id_In;
  If v_Count <> 1 Then
    v_Error := '该病人已经入科,请先将病人撤消至入院状态。';
    Raise Err_Custom;
  End If;

  --删除电子病历时机
  Select 出院科室id, 再入院 Into v_出院科室id, v_再入院 From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
  If v_再入院 = 0 Then
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '入院', v_出院科室id);
  Else
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '再次入院', v_出院科室id);
  End If;

  --提取最近一次不为空的住院号
  Begin
    If 主页id_In = 0 Then
      Select 住院号
      Into v_住院号
      From 病案主页
      Where 病人id = 病人id_In And
            主页id =
            (Select Max(主页id) From 病案主页 Where 病人id = 病人id_In And Nvl(主页id, 0) <> 0 And Nvl(住院号, 0) <> 0);
    Else
      Select 住院号
      Into v_住院号
      From 病案主页
      Where 病人id = 病人id_In And
            主页id =
            (Select Max(主页id) From 病案主页 Where 病人id = 病人id_In And 主页id < 主页id_In And Nvl(住院号, 0) <> 0);
    End If;
  Exception
    When Others Then
      Null;
  End;

  b_Message.ZLHIS_PATIENT_006(病人id_In,主页id_In,'入院登记');

  If 转留观_In = 1 And Nvl(主页id_In, 0) <> 0 Then
    Update 病案主页
    Set 病人性质 = 2, 住院号 = Decode(清除住院号_In, 1, Null, 住院号)
    Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(病人性质, 0) = 0;
  
    --调整住院次数
    Update 病人信息 Set 住院次数 = Decode(Sign(住院次数 - 1), 1, 住院次数 - 1, Null) Where 病人id = 病人id_In;
    If 清除住院号_In = 1 Then
      Update 病人信息 Set 住院号 = v_住院号 Where 病人id = 病人id_In;
    End If;
  Else
    Begin
      Select b.入院日期, b.出院日期, b.入院科室id
      Into v_入院时间, v_出院时间, v_入院科室
      From 病人信息 A, 病案主页 B
      Where a.病人id = 病人id_In And a.病人id = b.病人id And a.主页id = b.主页id And Nvl(b.主页id, 0) <> 0;
    Exception
      When Others Then
        Null;
    End;
    --撤消预约登记病人不检查住院日报
    If Nvl(主页id_In, 0) <> 0 Then
      Select Zl_住院日报_Count(v_入院科室, v_入院时间) Into v_Count From Dual;
      If v_Count > 0 Then
        v_Error := '已产生业务时间内的住院日报,不能办理该业务!';
        Raise Err_Custom;
      End If;
    End If;
    --门诊留观病人下达入院通知后存在两条有效的病案主页记录（36549）
    Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 入院日期 Is Not Null And 出院日期 Is Null;
    If Not v_Count > 1 Then
      v_Count := 0;
      If Nvl(主页id_In, 0) <> 0 And Nvl(n_病人性质, 0) = 0 Then
        v_Count := 1;
      End If;
      --再入院病人,取消入院登记时,病人信息的入院时间和出院时间应该回退到上一次入院日期和出院日期
      If v_再入院 = 1 Then
        Begin
          Select 入院日期, 出院日期
          Into v_入院时间, v_出院时间
          From 病案主页
          Where 病人id = 病人id_In And
                主页id = (Select Max(主页id)
                        From 病案主页
                        Where 病人id = 病人id_In And 主页id < 主页id_In);
        End;
      End If;
    
      Update 病人信息
      Set 住院号 = v_住院号, 住院次数 = Decode(v_Count, 0, 住院次数, Decode(Sign(住院次数 - 1), 1, 住院次数 - 1, Null)), 当前科室id = Null,
          当前病区id = Null, 当前床号 = Null, 入院时间 = v_入院时间, 出院时间 = v_出院时间, 担保人 = Null, 担保额 = Null, 担保性质 = Null, 在院 = Null
      Where 病人id = 病人id_In;
      Delete From 在院病人 Where 病人id = 病人id_In;
    End If;
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In;
    Delete From 病人自动计算 Where 病人id = 病人id_In And 主页id = 主页id_In;
    Delete From 病人诊断记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 记录来源 = 2;
  
    --本次住院如果交了预交款,改为当作门诊交的
    Update 病人预交记录 Set 主页id = Null Where 病人id = 病人id_In And 主页id = 主页id_In;
  
    --本次发卡的,改变门诊发卡
    Update 住院费用记录 Set 主页id = Null Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 5;
  
    --本次住院的所有费用记录无结算且已全部冲销，则将对应费用记录中的"主页ID"清除。
    v_Count := 0;
    Select Nvl(Count(*), 0)
    Into v_Count
    From 住院费用记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 记帐费用 = 1 And 结帐id Is Not Null;
  
    If v_Count = 0 Then
      Begin
        Select Nvl(Count(*), 0)
        Into v_Count
        From 住院费用记录
        Where 病人id = 病人id_In And 主页id = 主页id_In And 记帐费用 = 1
        Group By NO, 记录性质, 序号
        Having Nvl(Sum(实收金额), 0) <> 0;
      Exception
        When Others Then
          v_Count := 0;
      End;
    
      If v_Count = 0 Then
        Delete 病人未结费用 Where 病人id = 病人id_In And 主页id = 主页id_In And 金额 = 0;
        Update 住院费用记录 Set 主页id = Null Where 病人id = 病人id_In And 主页id = 主页id_In And 记帐费用 = 1;
      End If;
    End If;
  
    --本次住院所有医嘱记录都已作废
    v_Count := 0;
    Select Nvl(Count(*), 0)
    Into v_Count
    From 病人医嘱记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(医嘱状态, 0) <> 4;
    If v_Count = 0 Then
      Delete From 病人医嘱记录 Where 病人id = 病人id_In And 主页id = 主页id_In;
    Else
      v_Error := Checkpatiadvice(病人id_In, 主页id_In);
      If v_Error Is Not Null Then
        Raise Err_Custom;
      End If;
    End If;
  
    --以下表,没有建病案主页(病人ID,主页ID)的外键,因为其主页ID可能是挂号ID
    Delete From 病人过敏记录 Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0);
    Delete From 病人诊断记录 Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0);
    Delete From 病人新生儿记录 Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0);
    Delete From 电子病历记录 Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0);
    Delete From 电子病历打印 Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0);
    --如果入院发放了就诊卡,则删除会失败(病人费用记录主页ID有外键约束)
    Delete From 病案主页 Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0);
    --修改病人信息的主页ID和住院次数
    Select Max(主页id) Into n_主页id From 病案主页 Where 病人id = 病人id_In And Nvl(主页id, 0) <> 0;
    Update 病人信息 Set 主页id = n_主页id Where 病人id = 病人id_In;
    If n_主页id Is Null Then
      Update 病人信息 Set 住院次数 = Null Where 病人id = 病人id_In;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_入院病案主页_Delete;
/

--119434:梁唐彬,2018-01-04,集成平台消息调整
Create Or Replace Procedure zl_病人信息_DELETE(
    病人ID_IN    病人信息.病人ID%Type
)
AS
    Err_custom Exception;
    v_Error Varchar2(255);
    v_Count Number;
Begin
    Select Nvl(Count(*),0) Into v_Count From 病人信息 Where 就诊状态=2 And 病人ID=病人ID_IN;
    IF v_Count>0 Then
        v_Error:='该病人正处于就诊状态,请先取消就诊！';
        Raise Err_custom;
    End if;
	b_Message.Zlhis_Patient_028(病人id_In);
    DELETE FROM 病人信息 WHERE 病人ID = 病人ID_IN;
    UPDATE 床位状况记录 SET 状态 = '空床',病人ID = NULL,科室ID=Decode(共用,1,NULL,科室ID) WHERE 病人ID = 病人ID_IN;
Exception
    When Err_custom Then Raise_Application_Error(-20101,'[ZLSOFT]'||v_Error||'[ZLSOFT]');
    When Others Then Zl_ErrorCenter (SQLCODE, SQLERRM);
End zl_病人信息_DELETE;
/

--119434:梁唐彬,2018-01-04,消息统一调整改进
Create Or Replace Procedure Zl_病人变动记录_Change
(
  病人id_In     病案主页.病人id%Type,
  主页id_In     病案主页.主页id%Type,
  转入科室id_In 病人变动记录.科室id%Type,
  操作员编号_In 病人变动记录.操作员编号%Type,
  操作员姓名_In 病人变动记录.操作员姓名%Type
) As
  -----------------------------------------------------------
  --说明：病人转科登记
  -----------------------------------------------------------
  v_Count  Number;
  v_科室id 病人临床路径.科室id%Type;
  v_年龄   病人信息.年龄%Type;
  v_姓名   病人信息.姓名%Type;
  Err_Custom Exception;
  v_Error Varchar2(255);
Begin
  --首先判断该病人是否处于等待转科或入科状态
  Select Count(*)
  Into v_Count
  From 病案主页
  Where 病人id = 病人id_In And 主页id = 主页id_In And 出院日期 Is Null And Nvl(状态, 0) In (0, 3);
  If v_Count = 0 Then
    v_Error := '操作失败,该病人正处于转科状态或尚未入科,不能转科。';
    Raise Err_Custom;
  End If;

  Select Count(*)
  Into v_Count
  From 病案主页
  Where 病人id = 病人id_In And 主页id = 主页id_In And 出院科室id = 转入科室id_In;
  If v_Count > 0 Then
    v_Error := '操作失败,当前该病人所在的科室和即将转入的科室相同,不能进行当前操作.' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态！';
    Raise Err_Custom;
  End If;

  --一次住院只有一个路径，临床路径正在执行时不允许转科(除非是从ICU转出或转入)
  Select Nvl(Max(科室id), 0)
  Into v_科室id
  From 病人临床路径 A
  Where a.病人id = 病人id_In And a.主页id = 主页id_In And a.状态 = 1;
  If v_科室id <> 0 Then
    Select Count(*)
    Into v_Count
    From 部门性质说明 C
    Where (c.部门id = v_科室id Or c.部门id = 转入科室id_In) And c.工作性质 = 'ICU';
    If v_Count = 0 Then
      v_Error := '该病人的临床路径正在执行中,不能转科。';
      Raise Err_Custom;
    End If;
  End If;

  --检查未校对的医嘱，或已校对但未发送的临嘱
  v_Count := Nvl(zl_GetSysParameter('特殊医嘱发送前检查未生效医嘱', 1254), 0);
  If v_Count = 1 Then
    v_姓名 := Null;
    Select Max(姓名)
    Into v_姓名
    From 病人医嘱记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 医嘱状态 = 1 And Nvl(婴儿, 0) = 0 And Rownum = 1;
    If v_姓名 Is Not Null Then
      v_Error := v_姓名 || '存在未校对的医嘱，请删除或校对后再继续。';
      Raise Err_Custom;
    End If;
  
    v_姓名 := Null;
    Select Max(姓名)
    Into v_姓名
    From 病人医嘱记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 医嘱期效 = 1 And 医嘱状态 In (2, 3) And Nvl(执行标记, 0) <> -1 And Nvl(婴儿, 0) = 0 And
          Nvl(执行性质, 0) <> 0 And Rownum = 1;
    If v_姓名 Is Not Null Then
      v_Error := v_姓名 || '存在校对后未发送的临嘱，请发送或作废后再继续。';
      Raise Err_Custom;
    End If;
  End If;

  --修改病人临床路径表中的科室ID
  Update 病人临床路径 Set 科室id = 转入科室id_In Where 病人id = 病人id_In And 主页id = 主页id_In And 状态 = 1;

  --不填写开始时间和终止时间
  Insert Into 病人变动记录
    (ID, 病人id, 主页id, 开始时间, 开始原因, 病区id, 科室id, 操作员编号, 操作员姓名)
  Values
    (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, Null, 3, Null, 转入科室id_In, 操作员编号_In, 操作员姓名_In);

  Update 病案主页 Set 状态 = 2 Where 病人id = 病人id_In And 主页id = 主页id_In;

  v_年龄 := Zl_Age_Calc(病人id_In);
  Update 病人信息 Set 年龄 = v_年龄 Where 病人id = 病人id_In;

  --并发操作检查
  Select Count(*)
  Into v_Count
  From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 Is Null And 终止时间 Is Null;
  If v_Count > 1 Then
    v_Error := '发现病人存在非法的变动记录,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;

  Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In And 出院日期 Is Null;
  If v_Count = 0 Then
    v_Error := '操作失败,该病人已出院,不能进行当前操作.' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态！';
    Raise Err_Custom;
  End If;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人变动记录_Change;
/

--111037:余伟节,2018-01-04,病人新生儿记录增加死亡时间
Create Or Replace Procedure Zl_病人新生儿记录_Insert
(
  病人id_In   病人新生儿记录.病人id%Type,
  主页id_In   病人新生儿记录.主页id%Type,
  序号_In     病人新生儿记录.序号%Type,
  婴儿姓名_In 病人新生儿记录.婴儿姓名%Type,
  婴儿性别_In 病人新生儿记录.婴儿性别%Type,
  分娩次数_In 病人新生儿记录.分娩次数%Type,
  分娩方式_In 病人新生儿记录.分娩方式%Type,
  胎儿状况_In 病人新生儿记录.胎儿状况%Type,
  出生时间_In 病人新生儿记录.出生时间%Type,
  身长_In     病人新生儿记录.身长%Type,
  体重_In     病人新生儿记录.体重%Type,
  血型_In     病人新生儿记录.血型%Type,
  备注说明_In 病人新生儿记录.备注说明%Type := Null,
  死亡时间_In 病人新生儿记录.死亡时间%Type := Null
) Is
Begin
  Insert Into 病人新生儿记录
    (病人id, 主页id, 序号, 婴儿姓名, 婴儿性别, 分娩次数, 分娩方式, 胎儿状况, 身长, 体重, 血型, 出生时间, 死亡时间, 备注说明)
  Values
    (病人id_In, 主页id_In, 序号_In, 婴儿姓名_In, 婴儿性别_In, 分娩次数_In, 分娩方式_In, 胎儿状况_In, 身长_In, 体重_In, 血型_In, 出生时间_In, 死亡时间_In,
     备注说明_In);

  Zl_病区自动标记_Update(病人id_In, 主页id_In);
  b_Message.Zlhis_Patient_011(病人id_In, 主页id_In, 序号_In);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人新生儿记录_Insert;
/

--119096:冉俊明,2018-01-04,支持对预交款支付的费用进行医保补结算
Create Or Replace Procedure Zl_费用补充结算_Modify
(
  操作类型_In   Number,
  结算id_In     In 费用补充记录.结算id%Type,
  结算方式_In   Varchar2,
  卡类别id_In   病人预交记录.卡类别id%Type := Null,
  卡号_In       病人预交记录.卡号%Type := Null,
  交易流水号_In 病人预交记录.交易流水号%Type := Null,
  交易说明_In   病人预交记录.交易说明%Type := Null,
  误差金额_In   门诊费用记录.实收金额%Type := Null,
  完成结算_In   Number := 0,
  冲预交_In     病人预交记录.冲预交%Type := Null
) As
  ------------------------------------------------------------------------------------------------------------------------------
  --功能:保险补充结算时,修改结算的相关信息
  --操作类型_In:
  --   0-普通结算方式:
  --     结算方式_IN:允许传入多个,格式为:结算方式|结算金额|结算号码|结算摘要||.. ;也允许传入空.
  --   1.三方卡结算:
  --     ①结算方式_IN:只能传入一个结算方式,但允许包含一些辅助信息,格式为:结算方式|结算金额|结算号码|结算摘要
  --     ②卡类别ID_IN,卡号_IN,交易流水号_IN,交易说明_In:需要传入
  --   2-医保结算(如果存在医保的结算,则要先删除原医保结算,后按新传入的更新)
  --     ①结算方式_IN:允许传入多个,格式为:结算方式|结算金额||..
  -- 误差金额_In:存在误差费时,传入
  -- 完成结算_In:1-完成补充结算;0-未完成补充结算;2-完成了异常作废
  --  冲预交_In:冲预交金额，退款时为负，收款时为正
  ------------------------------------------------------------------------------------------------------------------------------
  v_误差费 结算方式.名称%Type;
  n_Count  Number(18);
  n_会话号 病人预交记录.会话号%Type; --格式：SID+'_'+SERIAL#

  v_结算内容 Varchar2(4000);
  v_当前结算 Varchar2(4000);
  v_结算方式 病人预交记录.结算方式%Type;
  n_结算金额 病人预交记录.冲预交%Type;
  v_结算号码 病人预交记录.结算号码%Type;
  v_结算摘要 病人预交记录.摘要%Type;

  n_冲预交 病人预交记录.冲预交%Type;
  n_返回值 病人预交记录.冲预交%Type;
  l_预交id t_Numlist := t_Numlist();

  Cursor c_Balance Is
    Select 记录性质, NO, 记录状态, 实际票号, 结算id, 收费结帐id, 费用状态, 操作员编号, 操作员姓名, 登记时间, 缴款组id, 病人id, 结算序号

    From 费用补充记录 A
    Where 结算id = 结算id_In And 记录性质 = 1 And Rownum < 2;
  r_Balance c_Balance%RowType;

  Err_Item Exception;
  v_Err_Msg Varchar2(255);
Begin
  Begin
    Select Sid || '_' || Serial# Into n_会话号 From V$session Where Audsid = Userenv('sessionid');
  Exception
    When Others Then
      n_会话号 := Null;
  End;

  Begin
    Select 1 Into n_Count From 费用补充记录 Where 结算id = 结算id_In And Rownum < 2 And 记录性质 = 1;
  Exception
    When Others Then
      n_Count := 0;
  End;
  If n_Count = 0 Then
    v_Err_Msg := '未找到医保补结算数据，不能继续操作!';
    Raise Err_Item;
  End If;

  Open c_Balance;
  Fetch c_Balance
    Into r_Balance;

  If Nvl(误差金额_In, 0) <> 0 Then
    Begin
      Select 名称 Into v_误差费 From 结算方式 Where Nvl(性质, 0) = 9;
    Exception
      When Others Then
        v_误差费 := '误差费';
    End;
  
    Update 病人预交记录
    Set 冲预交 = Nvl(冲预交, 0) + Nvl(误差金额_In, 0)
    Where 结帐id = 结算id_In And 结算方式 = v_误差费;
    If Sql%NotFound Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
      Values
        (病人预交记录_Id.Nextval, 6, r_Balance.No, r_Balance.记录状态, r_Balance.病人id, Null, Null, v_误差费, r_Balance.登记时间,
         r_Balance.操作员编号, r_Balance.操作员姓名, 误差金额_In, r_Balance.结算id, r_Balance.缴款组id, r_Balance.结算序号, 2, Null, Null,
         卡号_In, 交易流水号_In, 交易说明_In, Null, 6, n_会话号);
      Update 病人预交记录 Set 冲预交 = Nvl(冲预交, 0) - 误差金额_In Where 结帐id = 结算id_In And 结算方式 Is Null;
    End If;
  End If;

  --退预交款
  If Nvl(冲预交_In, 0) < 0 Then
    n_冲预交 := -1 * 冲预交_In;
    For v_退预交 In (Select Max(ID) As 预交id, Max(收款时间) As 收款时间, 病人id, Sum(Nvl(冲预交, 0)) As 金额
                  From 病人预交记录
                  Where Mod(记录性质, 10) = 1 And Nvl(预交类别, 0) = 1 And
                        结帐id In
                        (Select a.结帐id
                         From 门诊费用记录 A, 门诊费用记录 B
                         Where a.记录性质 = b.记录性质 And a.No = b.No And a.序号 = b.序号 And b.记录状态 <> 2 And
                               b.结帐id In
                               (Select 收费结帐id From 费用补充记录 Where 记录性质 = 1 And 结算序号 = r_Balance.结算序号))
                  Group By NO, 病人id
                  Having Sum(Nvl(冲预交, 0)) > 0
                  Order By 收款时间 Desc) Loop
    
      If v_退预交.金额 - n_冲预交 < 0 Then
        n_结算金额 := -1 * v_退预交.金额;
        n_冲预交   := n_冲预交 - v_退预交.金额;
      Else
        n_结算金额 := -1 * n_冲预交;
        n_冲预交   := 0;
      End If;
    
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
         卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 结算性质, 会话号)
        Select 病人预交记录_Id.Nextval, 11, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, r_Balance.登记时间, r_Balance.操作员编号,
               r_Balance.操作员姓名, n_结算金额, r_Balance.结算id, r_Balance.缴款组id, r_Balance.结算序号, 2, 卡类别id, 结算卡序号, 卡号, 交易流水号,
               交易说明, 结算号码, 预交类别, 6, n_会话号
        From 病人预交记录
        Where ID = v_退预交.预交id;
    
      --更新病人余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + (-1 * n_结算金额)
      Where 病人id = v_退预交.病人id And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (v_退预交.病人id, 1, -1 * n_结算金额, 1);
        n_返回值 := -1 * n_结算金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = v_退预交.病人id And 性质 = 1 And 类型 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      Update 病人预交记录 Set 冲预交 = Nvl(冲预交, 0) - n_结算金额 Where 结帐id = 结算id_In And 结算方式 Is Null;
    
      If n_冲预交 = 0 Then
        Exit;
      End If;
    End Loop;
    If n_冲预交 <> 0 Then
      v_Err_Msg := '当前退款金额大于了预交款可退金额，退款失败！';
      Raise Err_Item;
    End If;
  End If;

  --0.普通结算方式
  If Nvl(操作类型_In, 0) = 0 Then
    --各个收费结算 :格式为:结算方式|结算金额|结算号码|结算摘要||..
    v_结算内容 := 结算方式_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
    
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If Nvl(n_结算金额, 0) <> 0 Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
        Values
          (病人预交记录_Id.Nextval, 6, r_Balance.No, r_Balance.记录状态, r_Balance.病人id, Null, v_结算摘要, v_结算方式, r_Balance.登记时间,
           r_Balance.操作员编号, r_Balance.操作员姓名, n_结算金额, r_Balance.结算id, r_Balance.缴款组id, r_Balance.结算序号, 2, Null, Null,
           卡号_In, 交易流水号_In, 交易说明_In, v_结算号码, 6, n_会话号);
      
        Update 病人预交记录 Set 冲预交 = Nvl(冲预交, 0) - n_结算金额 Where 结帐id = 结算id_In And 结算方式 Is Null;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --1.三方卡结算
  If Nvl(操作类型_In, 0) = 1 Then
    v_当前结算 := 结算方式_In;
    v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
  
    If Nvl(n_结算金额, 0) <> 0 Then
      Update 病人预交记录
      Set 冲预交 = Nvl(冲预交, 0) + n_结算金额
      Where 结帐id = 结算id_In And 结算方式 = v_结算方式 And 卡类别id = 卡类别id_In;
      If Sql%NotFound Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
        Values
          (病人预交记录_Id.Nextval, 6, r_Balance.No, r_Balance.记录状态, r_Balance.病人id, Null, v_结算摘要, v_结算方式, r_Balance.登记时间,
           r_Balance.操作员编号, r_Balance.操作员姓名, n_结算金额, r_Balance.结算id, r_Balance.缴款组id, r_Balance.结算序号, 2, 卡类别id_In, Null,
           卡号_In, 交易流水号_In, 交易说明_In, v_结算号码, 6, n_会话号);
      End If;
      Update 病人预交记录 Set 冲预交 = Nvl(冲预交, 0) - n_结算金额 Where 结帐id = 结算id_In And 结算方式 Is Null;
    End If;
  End If;

  --2.医保结算
  If Nvl(操作类型_In, 0) = 2 Then
    --2.1检查是否已经存在医保结算数据,存在先删除
    n_结算金额 := 0;
    For v_医保 In (Select ID, 结算方式, 冲预交
                 From 病人预交记录 A
                 Where 结帐id = 结算id_In And Exists
                  (Select 1 From 结算方式 Where a.结算方式 = 名称 And 性质 In (3, 4)) And Mod(记录性质, 10) <> 1) Loop
      n_结算金额 := n_结算金额 + Nvl(v_医保.冲预交, 0);
      l_预交id.Extend;
      l_预交id(l_预交id.Count) := v_医保.Id;
    End Loop;
  
    If l_预交id.Count <> 0 Then
      Forall I In 1 .. l_预交id.Count
        Delete 病人预交记录 Where ID = l_预交id(I);
    End If;
  
    --先删除结算方式为空的记录
    Delete 病人预交记录 Where 结帐id = 结算id_In And 结算方式 Is Null;
    If 结算方式_In Is Not Null Then
      v_结算内容 := 结算方式_In || '||';
    End If;
    n_冲预交 := 0;
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
      Values
        (病人预交记录_Id.Nextval, 6, r_Balance.No, r_Balance.记录状态, r_Balance.病人id, Null, '保险结算', v_结算方式, r_Balance.登记时间,
         r_Balance.操作员编号, r_Balance.操作员姓名, Nvl(n_结算金额, 0), r_Balance.结算id, r_Balance.缴款组id, r_Balance.结算序号, 2, Null,
         Null, Null, Null, Null, Null, 6, n_会话号);
      n_冲预交 := n_冲预交 + Nvl(n_结算金额, 0);
    
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  
    --处理结算方式为NULL
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
       交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
    Values
      (病人预交记录_Id.Nextval, 6, r_Balance.No, r_Balance.记录状态, r_Balance.病人id, Null, '', Null, r_Balance.登记时间,
       r_Balance.操作员编号, r_Balance.操作员姓名, -1 * n_冲预交, r_Balance.结算id, r_Balance.缴款组id, r_Balance.结算序号, 1, Null, Null,
       Null, Null, Null, Null, 6, n_会话号);
    --医保相关表的处理
    Update 保险结算明细 Set 标志 = 2 Where 结帐id = 结算id_In;
  End If;

  If Nvl(完成结算_In, 0) = 0 Then
    Return;
  End If;

  If Nvl(完成结算_In, 0) = 2 Then
    --1.更新校对标志
    Update 病人预交记录 Set 校对标志 = 0 Where NO = r_Balance.No;
    Update 费用补充记录 Set 费用状态 = 2 Where NO = r_Balance.No;
    If Sql%NotFound Then
      v_Err_Msg := '未找到医保补结算数据，可能被他人进行了作废操作!';
      Raise Err_Item;
    End If;
    Return;
  End If;

  Delete 病人预交记录 Where 结帐id = 结算id_In And Mod(记录性质, 10) <> 1 And 结算方式 Is Null And Nvl(冲预交, 0) = 0;
  If Sql%NotFound Then
    Select Count(1) Into n_Count From 病人预交记录 A Where 结帐id = 结算id_In And 结算方式 Is Null;
    If n_Count <> 0 Then
      v_Err_Msg := '还存在未缴款的数据，不能完成结算！';
    Else
      v_Err_Msg := '结算信息错误，可能因为并发原因造成结算信息错误，请在[保险补充结算]中重新结算！';
    End If;
    Raise Err_Item;
  End If;

  --1.更新异常状态
  Update 费用补充记录 Set 费用状态 = 0 Where 结算序号 = r_Balance.结算序号;
  If Sql%NotFound Then
    v_Err_Msg := '未找到医保补结算数据，可能被他人进行了退费或作废操作!';
    Raise Err_Item;
  End If;

  --2.更新校对标志,会话号
  Update 病人预交记录 Set 校对标志 = 0, 会话号 = Null Where 结帐id = 结算id_In;
  --3.更新人员缴款数据
  For c_缴款 In (Select a.结算方式, a.操作员姓名, Nvl(Sum(a.冲预交), 0) As 冲预交
               From 病人预交记录 A
               Where a.结算序号 = r_Balance.结算序号 And Mod(a.记录性质, 10) <> 1
               Group By a.结算方式, a.操作员姓名
               Having Nvl(Sum(a.冲预交), 0) <> 0) Loop
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + c_缴款.冲预交
    Where 收款员 = c_缴款.操作员姓名 And 性质 = 1 And 结算方式 = c_缴款.结算方式;
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额
        (收款员, 结算方式, 性质, 余额)
      Values
        (c_缴款.操作员姓名, c_缴款.结算方式, 1, c_缴款.冲预交);
    End If;
  End Loop;

  --消息集成处理
  --结算类型:1-收费结算，2-补充结算
  --结帐ID:结算id
  b_Message.Zlhis_Charge_002(2, 结算id_In);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_费用补充结算_Modify;
/

--119096:冉俊明,2018-01-04,支持对预交款支付的费用进行医保补结算
Create Or Replace Procedure Zl_费用补充记录_Delete
(
  No_In           In 费用补充记录.No%Type,
  冲销id_In       In 费用补充记录.结算id%Type,
  重结id_In       In 费用补充记录.结算id%Type,
  结算序号_In     In 费用补充记录.结算序号%Type,
  退费结帐ids_In  In Varchar2,
  操作员编号_In   In 费用补充记录.操作员编号%Type,
  操作员姓名_In   In 费用补充记录.操作员姓名%Type,
  登记时间_In     In 费用补充记录.登记时间%Type := Null,
  非原样退结算_In In Varchar2 := Null
) Is
  --退费结帐id_In:传入本次退费的结帐ID,多个用逗号分离(123,111...)
  Err_Item Exception;
  v_Err_Msg  Varchar2(255);
  d_Date     Date;
  n_组id     财务缴款分组.Id%Type;
  n_结算id   费用补充记录.结算id%Type;
  n_费用状态 费用补充记录.费用状态%Type;
  v_实际票号 费用补充记录.实际票号%Type;
  n_病人id   费用补充记录.病人id%Type;
  n_附加标志 费用补充记录.附加标志%Type;
  n_Count    Number(18);
  n_打印id   票据使用明细.Id%Type;
  n_会话号   病人预交记录.会话号%Type; --格式：SID+'_'+SERIAL#
Begin
  n_组id := Zl_Get组id(操作员姓名_In);
  d_Date := 登记时间_In;
  If 登记时间_In Is Null Then
    d_Date := Sysdate;
  End If;

  Begin
    Select Sid || '_' || Serial# Into n_会话号 From V$session Where Audsid = Userenv('sessionid');
  Exception
    When Others Then
      n_会话号 := Null;
  End;

  v_Err_Msg := Null;
  Begin
    Select 结算id, 费用状态, 实际票号, 病人id, 附加标志
    Into n_结算id, n_费用状态, v_实际票号, n_病人id, n_附加标志
    From 费用补充记录
    Where 记录性质 = 1 And NO = No_In And 记录状态 = 1 And Rownum < 2 And Nvl(费用状态, 0) = 0;
  Exception
    When Others Then
      v_Err_Msg := '未找到结算单号为' || No_In || '的结算记录,可能已经被他人作废或重新结算,不允许再继续操作！';
  End;

  If v_Err_Msg Is Not Null Then
    Raise Err_Item;
  End If;

  Update 费用补充记录 Set 记录状态 = 3 Where 结算id = n_结算id;

  Insert Into 费用补充记录
    (记录性质, NO, 记录状态, 实际票号, 结算id, 收费结帐id, 费用状态, 操作员编号, 操作员姓名, 登记时间, 缴款组id, 病人id, 结算序号, 附加标志)
    Select 记录性质, NO, 2, 实际票号, 冲销id_In As 结算id, 收费结帐id, 1 As 费用状态, 操作员编号_In As 操作员编号, 操作员姓名_In As 操作员姓名, d_Date As 登记时间,
           n_组id As 缴款组id, 病人id, 结算序号_In As 结算序号, 附加标志
    From 费用补充记录
    Where 结算id = n_结算id;

  --先将医保退回,剩下部分,直接退款(退款界面)
  Insert Into 病人预交记录
    (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
     交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
    Select 病人预交记录_Id.Nextval, 6, NO, 2, 病人id, 主页id, 摘要, 结算方式, d_Date As 收款时间, 操作员编号_In As 操作员编号, 操作员姓名_In As 操作员姓名,
           -1 * 冲预交, 冲销id_In As 结帐id, n_组id As 缴款组id, 结算序号_In As 结算序号, 2 As 校对标志, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 结算号码, 6,
           n_会话号
    From 病人预交记录 A
    Where 结帐id = n_结算id And Exists
     (Select 1
           From 结算方式
           Where a.结算方式 = 名称 And 性质 In (3, 4) And Instr(',' || 非原样退结算_In || ',', ',' || 名称 || ',') = 0) And
          Mod(a.记录性质, 10) <> 1;

  --插入病人预交记录.结算方式为空的记录
  Insert Into 病人预交记录
    (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
     交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
    Select 病人预交记录_Id.Nextval, 6, NO, 2, 病人id, 主页id, 摘要, Null, d_Date As 收款时间, 操作员编号_In As 操作员编号, 操作员姓名_In As 操作员姓名,
           -1 * 退款额, 冲销id_In As 结帐id, n_组id As 缴款组id, 结算序号_In As 结算序号, 1 As 校对标志, Null, Null, Null, Null, Null, Null, 6,
           n_会话号
    From (Select NO, Max(病人id) As 病人id, Max(主页id) As 主页id, Max(摘要) As 摘要, Sum(冲预交) As 退款额
           From 病人预交记录
           Where 结帐id = 冲销id_In
           Group By NO) A;

  Update 病人预交记录 Set 记录状态 = 3 Where Mod(记录性质, 10) <> 1 And 结帐id = n_结算id;

  Select Count(*)
  Into n_Count
  From (Select a.No, a.记录性质, a.序号, a.收费细目id, Sum(Nvl(a.付数, 1) * a.数次) As 数量
         From 门诊费用记录 A,
              (Select Distinct m.记录性质, m.No
                From 费用补充记录 J, 门诊费用记录 M
                Where j.收费结帐id = m.结帐id And j.No = No_In And Mod(j.记录性质, 0) = 1) B
         Where a.记录性质 = b.记录性质 And a.No = b.No And a.价格父号 Is Null
         Group By a.No, a.记录性质, a.序号, a.收费细目id
         Having Sum(Nvl(a.付数, 1) * a.数次) <> 0);

  If Nvl(n_Count, 0) <> 0 Then
    --部分冲销,需要产生重收记录
    Insert Into 费用补充记录
      (记录性质, NO, 记录状态, 实际票号, 结算id, 收费结帐id, 费用状态, 操作员编号, 操作员姓名, 登记时间, 缴款组id, 病人id, 结算序号, 附加标志)
      Select 1 As 记录性质, No_In As NO, 1, v_实际票号 As 实际票号, 重结id_In As 结算id, 收费结帐id, 1 As 费用状态, 操作员编号_In As 操作员编号,
             操作员姓名_In As 操作员姓名, d_Date As 登记时间, n_组id As 缴款组id, n_病人id As 病人id, 结算序号_In As 结算序号, n_附加标志 As 附加标志
      From (Select Distinct 收费结帐id As 收费结帐id
             From 费用补充记录 J
             Where j.No = No_In And Mod(j.记录性质, 10) = 1
             Union
             Select Column_Value As 结帐id From Table(f_Num2list(退费结帐ids_In)));
  End If;
  --收回票据
  --获取单据最后一次的打印ID(可能是多张单据收费打印)
  Begin
    --性质=1，原因=6为退费打印票据(红票)，不回收
    Select ID
    Into n_打印id
    From (Select b.Id
           From 票据使用明细 A, 票据打印内容 B
           Where a.打印id = b.Id And a.性质 = 1 And a.原因 In (1, 3) And b.数据性质 = 1 And b.No = No_In
           Order By a.使用时间 Desc)
    Where Rownum < 2;
  Exception
    When Others Then
      Null;
  End;

  --可能以前没有打印,无收回
  If n_打印id Is Not Null Then
    --a.多张单据循环调用时只能收回一次
    Select Count(*) Into n_Count From 票据使用明细 Where 票种 = 1 And 性质 = 2 And 打印id = n_打印id;
    If n_Count = 0 Then
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人, 票据金额)
        Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In, 票据金额
        From 票据使用明细
        Where 打印id = n_打印id And 票种 = 1 And 性质 = 1;
    Else
      --b.部分退费多次收回时,最后一次全退收回要排开已收回的
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人, 票据金额)
        Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In, 票据金额
        From 票据使用明细 A
        Where 打印id = n_打印id And 票种 = 1 And 性质 = 1 And Not Exists
         (Select 1 From 票据使用明细 B Where a.号码 = b.号码 And 打印id = n_打印id And 票种 = 1 And 性质 = 2);
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_费用补充记录_Delete;
/

--119096:冉俊明,2018-01-04,支持对预交款支付的费用进行医保补结算
Create Or Replace Procedure Zl_病人挂号补结算_Delete
(
  单据号_In     门诊费用记录.No%Type,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  冲销id_In     门诊费用记录.结帐id%Type := Null,
  结算序号_In   病人预交记录.结算序号%Type := Null,
  退号时间_In   门诊费用记录.登记时间%Type := Null,
  删除门诊号_In Number := 0
) As
  --该游标用于判断是否单独收病历费,及挂号汇总表处理

  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  n_结帐id   病人预交记录.结帐id%Type;
  n_冲销id   门诊费用记录.结帐id%Type;
  n_结算序号 病人预交记录.结算序号%Type;

  n_病人id   病人信息.病人id%Type;
  n_退费金额 病人预交记录.冲预交%Type;
  n_挂号id   病人挂号记录.Id%Type;
  n_组id     财务缴款分组.Id%Type;

  n_分诊台签到排队 Number;
  n_挂号生成队列   Number;
  d_Date           Date;
  n_病人id1        病人信息.病人id%Type;
  d_Temp           Date;
  n_就诊病人id     病人信息.病人id%Type;
  d_就诊时间       就诊登记记录.就诊时间%Type;
Begin
  n_组id := Zl_Get组id(操作员姓名_In);
  --首先判断要退号/取消预约的记录是否存在

  Begin
    Select a.结帐id, a.病人id
    Into n_结帐id, n_病人id
    From 门诊费用记录 A
    Where a.记录性质 = 4 And a.No = 单据号_In And a.记录状态 = 1 And Rownum < 2;
  Exception
  
    When Others Then
      n_病人id := -1;
  End;
  If Nvl(n_病人id, 0) = -1 Then
    v_Err_Msg := '未找到指定的挂号单:' || 单据号_In || ',可能已经被人退号,不允许再次退号。';
    Raise Err_Item;
  End If;

  --2.挂号处理

  d_Date     := 退号时间_In;
  n_冲销id   := 冲销id_In;
  n_结算序号 := 结算序号_In;

  If d_Date Is Null Then
    d_Date := Sysdate;
  End If;
  If n_冲销id Is Null Then
    Select 病人结帐记录_Id.Nextval Into n_冲销id From Dual;
  End If;

  If n_结算序号 Is Null Then
    n_结算序号 := -1 * n_冲销id;
  End If;
  --更新挂号序号状态
  If Zl_To_Number(zl_GetSysParameter('已退序号允许挂号', 1111)) = 1 Then
    Delete 挂号序号状态
    Where 状态 = 1 And
          (号码, 序号, 日期) = (Select 号别, 号序, Trunc(发生时间) From 病人挂号记录 Where NO = 单据号_In And Rownum = 1) Or
          (号码, 序号, 日期) = (Select 号别, 号序, 发生时间 From 病人挂号记录 Where NO = 单据号_In And Rownum = 1);
  Else
    Update 挂号序号状态
    Set 状态 = 4
    Where 状态 = 1 And
          (号码, 序号, 日期) = (Select 号别, 号序, Trunc(发生时间) From 病人挂号记录 Where NO = 单据号_In And Rownum = 1) Or
          (号码, 序号, 日期) = (Select 号别, 号序, 发生时间 From 病人挂号记录 Where NO = 单据号_In And Rownum = 1);
  End If;

  --病人就诊状态
  If n_病人id Is Not Null Then
    Update 病人信息 Set 就诊状态 = 0, 就诊诊室 = Null Where 病人id = n_病人id;
    --删除门诊号相关处理,只有当只有一条挂号记录并且病人建档日期与挂号日期近似时才会处理(界面要根据提示来删除)
    If 删除门诊号_In = 1 Then
      Delete 门诊病案记录 Where 病人id = n_病人id;
      Update 病人信息 Set 门诊号 = Null Where 病人id = n_病人id;
      --费用记录包括挂号及病案、就诊卡费用,以及病人交费后退费或销帐的费用,挂号记录在最后处理
      Update 门诊费用记录 Set 标识号 = Null Where 门诊标志 = 1 And 病人id = n_病人id;
    End If;
  End If;

  --如果挂时收了就诊卡费,退费时清除就诊卡号,在非光退病历费时
  n_病人id1 := Null;
  Begin
    Select 病人id
    Into n_病人id1
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And 附加标志 = 2 And Rownum < 2;
  Exception
    When Others Then
      Null;
  End;
  If n_病人id1 Is Not Null Then
    Update 病人信息
    Set 就诊卡号 = Null, 卡验证码 = Null, Ic卡号 = Decode(Ic卡号, 就诊卡号, Null, Ic卡号)
    Where 病人id = n_病人id1;
  End If;

  --门诊费用记录
  --冲销记录
  Insert Into 门诊费用记录
    (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别, 收费细目id, 计算单位, 付数,
     数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 执行人, 操作员编号, 操作员姓名, 发生时间, 登记时间,
     结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 缴款组id, 费用状态, 执行状态)
    Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别,
           收费细目id, 计算单位, 付数, -数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, -应收金额, -实收金额, 开单部门id, 开单人, 执行部门id, 执行人,
           操作员编号_In, 操作员姓名_In, 发生时间, d_Date, n_冲销id, -1 * 结帐金额, 保险项目否, 保险大类id, -1 * 统筹金额, 摘要 As 摘要, 附加标志, 保险编码, 费用类型,
           n_组id, 1, 1
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In;

  Update 门诊费用记录 Set 记录状态 = 3 Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In;
  Select Sum(实收金额) Into n_退费金额 From 门诊费用记录 Where 结帐id = n_冲销id;
  Insert Into 病人预交记录
    (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 结算序号, 缴款组id, 预交类别, 卡类别id,
     结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算性质)
    Select 病人预交记录_Id.Nextval, a.No, a.实际票号, 4, 2, a.病人id, a.主页id, a.科室id, a.摘要, Null, d_Date, 操作员编号_In, 操作员姓名_In, n_退费金额,
           n_冲销id, n_结算序号, n_组id, 预交类别, Null, Null, Null, Null, Null, Null, 1, 4
    From 病人预交记录 A
    Where a.结帐id = n_结帐id And Rownum < 2;
  If Sql%NotFound Then
    v_Err_Msg := '未找到挂号单为【' || 单据号_In || '】的原始挂号记录!';
    Raise Err_Item;
  End If;
  Update 病人预交记录 Set 记录状态 = 3 Where Mod(记录性质, 10) <> 1 And 结帐id = n_结帐id;

  --病人挂号汇总
  For c_挂号 In (Select a.收费细目id, a.发生时间, a.登记时间, c.接收时间, c.执行部门id, c.执行人, m.Id As 医生id, Nvl(c.号别, b.号码) As 号码, a.结帐id,
                      a.病人id, Decode(c.预约, Null, 0, 0, 0, 1) As 预约
               From 门诊费用记录 A, 病人挂号记录 C, 挂号安排 B, 人员表 M
               Where a.记录性质 = 4 And a.结帐id = n_冲销id And a.从属父号 Is Null And c.执行人 = m.姓名(+) And a.No = c.No And
                     Nvl(c.号别, Nvl(a.计算单位, '-')) = b.号码 And Nvl(a.附加标志, 0) = 0 And Rownum < 2) Loop
    --退非挂号费用,则不处理汇总表数据
  
    If Nvl(c_挂号.预约, 0) <> 0 Then
      d_Temp := Trunc(c_挂号.接收时间);
    Else
      d_Temp := Trunc(c_挂号.发生时间);
    End If;
  
    Update 病人挂号汇总
    Set 已挂数 = Nvl(已挂数, 0) - 1, 其中已接收 = Nvl(其中已接收, 0) - Nvl(c_挂号.预约, 0), 已约数 = Nvl(已约数, 0) - Nvl(c_挂号.预约, 0)
    Where 日期 = d_Temp And 科室id = c_挂号.执行部门id And 项目id = c_挂号.收费细目id And Nvl(医生姓名, '医生') = Nvl(c_挂号.执行人, '医生') And
          Nvl(医生id, 0) = Nvl(c_挂号.医生id, 0) And (号码 = c_挂号.号码 Or 号码 Is Null);
  
    If Sql%RowCount = 0 Then
      Insert Into 病人挂号汇总
        (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 其中已接收, 已约数)
      Values
        (d_Temp, c_挂号.执行部门id, c_挂号.收费细目id, c_挂号.执行人, Decode(c_挂号.医生id, 0, Null, c_挂号.医生id), c_挂号.号码, -1,
         -1 * Nvl(c_挂号.预约, 0), -1 * Nvl(c_挂号.预约, 0));
    End If;
  End Loop;

  n_挂号生成队列 := Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113));
  If n_挂号生成队列 <> 0 Then
    n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
    If Nvl(n_分诊台签到排队, 0) = 0 Then
      --要删除队列
      For v_挂号 In (Select ID, 诊室, 执行部门id, 执行人 From 病人挂号记录 Where NO = 单据号_In) Loop
        Zl_排队叫号队列_Delete(v_挂号.执行部门id, v_挂号.Id);
      End Loop;
    End If;
  End If;

  --医保产生的就诊登记记录
  Begin
    Select 病人id, 发生时间 Into n_就诊病人id, d_就诊时间 From 病人挂号记录 Where NO = 单据号_In;
    Delete From 就诊登记记录 Where 病人id = n_就诊病人id And 就诊时间 = d_就诊时间 And 主页id Is Null;
  Exception
    When Others Then
      Null;
  End;
  --病人挂号记录
  Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;

  Update 病人挂号记录 Set 记录状态 = 3 Where NO = 单据号_In And 记录性质 = 1 And 记录状态 = 1;
  If Sql%NotFound Then
    v_Err_Msg := '挂号单【' || 单据号_In || '】不存在或由于并发原因已经被退号';
    Raise Err_Item;
  End If;

  Insert Into 病人挂号记录
    (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 操作员编号, 操作员姓名, 复诊,
     号序, 社区, 预约, 摘要, 预约方式, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 险类, 医疗付款方式)
    Select n_挂号id, NO, 记录性质, 2, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, d_Date, 发生时间, 操作员编号_In,
           操作员姓名_In, 复诊, 号序, 社区, 预约, 摘要 As 摘要, 预约方式, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 险类, 医疗付款方式
    From 病人挂号记录
    Where NO = 单据号_In And 记录状态 = 3;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人挂号补结算_Delete;
/

--121114:冉俊明,2018-02-08,修正挂号补结算后退费报错“人员缴款余额（结算方式）必须录入”问题
--119096:冉俊明,2018-01-04,支持对预交款支付的费用进行医保补结算
Create Or Replace Procedure Zl_费用补充结算_完成退费
(
  结算id_In         In 费用补充记录.结算id%Type,
  结算方式_In       Varchar2,
  卡类别id_In       病人预交记录.卡类别id%Type := Null,
  卡号_In           病人预交记录.卡号%Type := Null,
  交易流水号_In     病人预交记录.交易流水号%Type := Null,
  交易说明_In       病人预交记录.交易说明%Type := Null,
  误差金额_In       门诊费用记录.实收金额%Type := Null,
  完成结算_In       Number := 1,
  三方卡按次结算_In Number := 0,
  冲预交_In         病人预交记录.冲预交%Type := Null
) As
  ------------------------------------------------------------------------------------------------------------------------------
  --功能:补结算退费
  --   结算方式_IN:格式为:"结算方式|结算金额|结算号码|结算摘要" ;也允许传入空.
  --   三方卡结算:需传入卡类别ID_IN,卡号_IN,交易流水号_IN,交易说明_In:需要传入
  --   误差金额_In:存在误差费时,传入
  --   完成结算_In .1-完成补充结算退费;0-未完成补充结算退费
  --   三方卡按次结算_In.三方卡退费是否按结算次数分别调用接口结算
  --  冲预交_In:冲预交金额，退款时为负，收款时为正
  ------------------------------------------------------------------------------------------------------------------------------
  v_误差费 结算方式.名称%Type;
  n_Count  Number(18);

  v_当前结算 Varchar2(4000);
  v_结算内容 Varchar2(4000);
  v_结算方式 病人预交记录.结算方式%Type;
  n_结算金额 病人预交记录.冲预交%Type;
  v_结算号码 病人预交记录.结算号码%Type;
  v_结算摘要 病人预交记录.摘要%Type;

  n_预交金额 病人预交记录.冲预交%Type;
  n_冲预交   病人预交记录.冲预交%Type;
  n_剩余金额 病人预交记录.冲预交%Type;
  n_未退合计 病人预交记录.冲预交%Type;
  n_返回值   病人预交记录.冲预交%Type;

  Cursor c_Balance Is
    Select 记录性质, NO, 记录状态, 实际票号, 结算id, 收费结帐id, 费用状态, 操作员编号, 操作员姓名, 登记时间, 缴款组id, 病人id, 结算序号, 附加标志
    From 费用补充记录 A
    Where 结算id = 结算id_In And 记录性质 = 1 And Rownum < 2;
  r_Balance c_Balance%RowType;

  Err_Item Exception;
  v_Err_Msg Varchar2(255);
Begin
  Begin
    Select 1 Into n_Count From 费用补充记录 Where 结算id = 结算id_In And 记录性质 = 1 And Rownum < 2;
  Exception
    When Others Then
      n_Count := 0;
  End;
  If n_Count = 0 Then
    v_Err_Msg := '未找到医保补结算数据，不能继续操作!';
    Raise Err_Item;
  End If;

  Open c_Balance;
  Fetch c_Balance
    Into r_Balance;

  If Nvl(误差金额_In, 0) <> 0 Then
    Begin
      Select 名称 Into v_误差费 From 结算方式 Where Nvl(性质, 0) = 9;
    Exception
      When Others Then
        v_误差费 := '误差费';
    End;
  
    Update 病人预交记录
    Set 冲预交 = Nvl(冲预交, 0) + Nvl(误差金额_In, 0)
    Where 结帐id = 结算id_In And 结算方式 = v_误差费;
  
    If Sql%NotFound Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 6, r_Balance.No, r_Balance.记录状态, r_Balance.病人id, Null, Null, v_误差费, r_Balance.登记时间,
         r_Balance.操作员编号, r_Balance.操作员姓名, 误差金额_In, r_Balance.结算id, r_Balance.缴款组id, r_Balance.结算序号, 2, Null, Null,
         卡号_In, 交易流水号_In, 交易说明_In, Null, 6);
    End If;
  
    Update 病人预交记录
    Set 冲预交 = Nvl(冲预交, 0) - Nvl(误差金额_In, 0)
    Where 结算方式 Is Null And 结帐id = 结算id_In;
    If Sql%NotFound Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 6, r_Balance.No, r_Balance.记录状态, r_Balance.病人id, Null, Null, Null, r_Balance.登记时间,
         r_Balance.操作员编号, r_Balance.操作员姓名, -1 * 误差金额_In, r_Balance.结算id, r_Balance.缴款组id, r_Balance.结算序号, 2, Null, Null,
         Null, Null, Null, Null, 6);
    End If;
  End If;

  --退预交款
  If Nvl(冲预交_In, 0) < 0 Then
    n_预交金额 := -1 * 冲预交_In;
    For v_退预交 In (Select Max(ID) As 预交id, Max(收款时间) As 收款时间, 病人id, Sum(Nvl(冲预交, 0)) As 金额
                  From 病人预交记录
                  Where Mod(记录性质, 10) = 1 And Nvl(预交类别, 0) = 1 And
                        结帐id In
                        (
                         --费用结帐ID
                         Select a.结帐id As 原结帐id
                         From 门诊费用记录 A, 门诊费用记录 B
                         Where a.记录性质 = b.记录性质 And a.No = b.No And a.序号 = b.序号 And b.记录状态 <> 2 And
                               b.结帐id In
                               (Select 收费结帐id From 费用补充记录 Where 记录性质 = 1 And 结算序号 = r_Balance.结算序号)
                         Union All
                         --补充结算结帐ID
                         Select 结帐id
                         From 病人预交记录
                         Where 结算序号 In (Select a.结算序号
                                        From 费用补充记录 A, 费用补充记录 B
                                        Where a.No = b.No And a.记录性质 = b.记录性质 And a.附加标志 = b.附加标志 And b.记录性质 = 1 And
                                              b.结算序号 = r_Balance.结算序号))
                  Group By NO, 病人id
                  Having Sum(Nvl(冲预交, 0)) > 0
                  Order By 收款时间 Desc) Loop
    
      If v_退预交.金额 - n_预交金额 < 0 Then
        n_结算金额 := -1 * v_退预交.金额;
        n_预交金额 := n_预交金额 - v_退预交.金额;
      Else
        n_结算金额 := -1 * n_预交金额;
        n_预交金额 := 0;
      End If;
    
      n_剩余金额 := Nvl(n_结算金额, 0);
      --需要根据“结算金额”排序，先处理收款（正）的，再处理退款（负）的
      For c_结算 In (Select 病人id, 记录性质, 结帐id, Nvl(Sum(冲预交), 0) As 结算金额
                   From 病人预交记录
                   Where 结算序号 = r_Balance.结算序号 And 结算方式 Is Null
                   Group By 病人id, 结帐id, 记录性质
                   Having Nvl(Sum(冲预交), 0) <> 0
                   Order By 结算金额 Desc) Loop
      
        If c_结算.结算金额 < n_剩余金额 Then
          n_冲预交   := n_剩余金额;
          n_剩余金额 := 0;
        Else
          n_冲预交   := c_结算.结算金额;
          n_剩余金额 := n_剩余金额 - c_结算.结算金额;
        End If;
      
        If n_冲预交 <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id,
             结算卡序号, 卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 结算性质)
            Select 病人预交记录_Id.Nextval, 11, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, r_Balance.登记时间, r_Balance.操作员编号,
                   r_Balance.操作员姓名, n_冲预交, c_结算.结帐id, r_Balance.缴款组id, r_Balance.结算序号, 2, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
                   结算号码, 预交类别, Mod(c_结算.记录性质, 10)
            From 病人预交记录
            Where ID = v_退预交.预交id;
        
          --更新病人余额
          Update 病人余额
          Set 预交余额 = Nvl(预交余额, 0) + (-1 * n_冲预交)
          Where 病人id = v_退预交.病人id And 性质 = 1 And 类型 = 1
          Returning 预交余额 Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (c_结算.病人id, 1, -1 * n_冲预交, 1);
            n_返回值 := -1 * n_冲预交;
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 病人余额
            Where 病人id = c_结算.病人id And 性质 = 1 And 类型 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
          End If;
        
          Update 病人预交记录 Set 冲预交 = Nvl(冲预交, 0) - n_冲预交 Where 结算方式 Is Null And 结帐id = c_结算.结帐id;
        End If;
      
        If n_剩余金额 = 0 Then
          Exit;
        End If;
      End Loop;
    
      If n_预交金额 = 0 Then
        Exit;
      End If;
    End Loop;
    If n_预交金额 <> 0 Then
      v_Err_Msg := '当前退款金额大于了预交款可退金额，退款失败！';
      Raise Err_Item;
    End If;
  End If;

  --各个收费结算 :格式为:"结算方式|结算金额|结算号码|结算摘要||.."
  v_结算内容 := 结算方式_In || '||';
  While v_结算内容 Is Not Null Loop
    Select Sum(Nvl(冲预交, 0))
    Into n_未退合计
    From 病人预交记录
    Where 结算序号 = r_Balance.结算序号 And 结算方式 Is Null And Mod(记录性质, 10) <> 1;
  
    v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
    v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
  
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
  
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
  
    If Nvl(三方卡按次结算_In, 0) = 0 And Nvl(n_未退合计, 0) <> -1 * Nvl(n_结算金额, 0) Then
      v_Err_Msg := '当前退款合计(' || Nvl(n_结算金额, 0) || ')与未退合计(' || Nvl(n_未退合计, 0) || ')不匹配！';
      Raise Err_Item;
    End If;
  
    n_剩余金额 := Nvl(n_结算金额, 0);
    --三方卡按次结算_In=0：结算金额为正，需要根据“结算金额”排序，先处理收款（正）的，再处理退款（负）的
    --三方卡按次结算_In=1：结算金额为负，需要根据“结算金额”排序，先处理退款（负）的，再处理收款（正）的
    For c_结算 In (Select 结帐id, 记录性质, 记录状态, NO, Nvl(Sum(冲预交), 0) As 结算金额
                 From 病人预交记录
                 Where 结算序号 = r_Balance.结算序号 And 结算方式 Is Null
                 Group By 结帐id, 记录性质, NO, 记录状态
                 Having Nvl(Sum(冲预交), 0) <> 0
                 Order By Decode(Nvl(三方卡按次结算_In, 0), 0, 1, -1) * 结算金额) Loop
    
      If Nvl(三方卡按次结算_In, 0) = 0 Then
        n_冲预交   := c_结算.结算金额;
        n_剩余金额 := n_剩余金额 - c_结算.结算金额;
      Else
        If c_结算.结算金额 < n_剩余金额 Then
          n_冲预交   := n_剩余金额;
          n_剩余金额 := 0;
        Else
          n_冲预交   := c_结算.结算金额;
          n_剩余金额 := n_剩余金额 - c_结算.结算金额;
        End If;
      End If;
    
      If n_冲预交 <> 0 Then
        Update 病人预交记录
        Set 冲预交 = Nvl(冲预交, 0) + n_冲预交
        Where 结帐id = c_结算.结帐id And 结算方式 = v_结算方式 And 卡类别id = 卡类别id_In;
        If Sql%NotFound Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 结算号码, 结算性质)
          Values
            (病人预交记录_Id.Nextval, c_结算.记录性质, c_结算.No, c_结算.记录状态, r_Balance.病人id, Null, v_结算摘要, v_结算方式, r_Balance.登记时间,
             r_Balance.操作员编号, r_Balance.操作员姓名, n_冲预交, c_结算.结帐id, r_Balance.缴款组id, r_Balance.结算序号, 2, 卡类别id_In, Null,
             卡号_In, 交易流水号_In, 交易说明_In, v_结算号码, Mod(c_结算.记录性质, 10));
        End If;
      
        Update 病人预交记录 Set 冲预交 = Nvl(冲预交, 0) - n_冲预交 Where 结算方式 Is Null And 结帐id = c_结算.结帐id;
      End If;
    
      If n_剩余金额 = 0 Then
        Exit;
      End If;
    End Loop;
  
    v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
  End Loop;

  If Nvl(完成结算_In, 0) = 0 Then
    Return;
  End If;

  Delete From 病人预交记录
  Where 结算序号 = r_Balance.结算序号 And 结算方式 Is Null And Mod(记录性质, 10) <> 1 And Nvl(冲预交, 0) = 0;
  If Sql%NotFound Then
    Select Count(1) Into n_Count From 病人预交记录 A Where 结帐id = 结算id_In And 结算方式 Is Null;
    If n_Count <> 0 Then
      v_Err_Msg := '还存在未缴款的数据，不能完成结算！';
    Else
      v_Err_Msg := '结算信息错误，可能因为并发原因造成结算信息错误，请在[保险补充结算]中重新结算！';
    End If;
    Raise Err_Item;
  End If;

  --1.更新异常状态
  Update 门诊费用记录
  Set 费用状态 = 0
  Where Nvl(费用状态, 0) = 1 And 结帐id In (Select Distinct 结帐id From 病人预交记录 Where 结算序号 = r_Balance.结算序号);

  Update 费用补充记录 Set 费用状态 = 0 Where 结算序号 = r_Balance.结算序号;
  If Sql%NotFound Then
    v_Err_Msg := '未找到医保补结算数据，可能补他人进行了退费或作废操作!';
    Raise Err_Item;
  End If;

  --2.更新校对标志,会话号
  Update 病人预交记录 Set 校对标志 = 0, 会话号 = Null Where 结算序号 = r_Balance.结算序号;

  --3.更新人员缴款数据
  For c_缴款 In (Select a.结算方式, a.操作员姓名, Nvl(Sum(a.冲预交), 0) As 冲预交
               From 病人预交记录 A
               Where a.结算序号 = r_Balance.结算序号 And Mod(a.记录性质, 10) <> 1
               Group By a.结算方式, a.操作员姓名
               Having Nvl(Sum(a.冲预交), 0) <> 0) Loop
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + c_缴款.冲预交
    Where 收款员 = c_缴款.操作员姓名 And 性质 = 1 And 结算方式 = c_缴款.结算方式;
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额
        (收款员, 结算方式, 性质, 余额)
      Values
        (c_缴款.操作员姓名, c_缴款.结算方式, 1, c_缴款.冲预交);
    End If;
  End Loop;

  --消息集成处理
  For c_结帐id In (Select Distinct 结帐id From 病人预交记录 Where 记录性质 = 3 And 结算序号 = r_Balance.结算序号) Loop
    b_Message.Zlhis_Charge_004(2, c_结帐id.结帐id);
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_费用补充结算_完成退费;
/

--119410:廖思奇,2018-01-04,处理 Zl_病人医嘱执行_取消拒绝  报错返回多行错误
--119410:廖思奇,2018-01-17,微调查询条件
--119410:廖思奇,2018-02-11,再次微调查询条件
Create Or Replace Procedure Zl_病人医嘱执行_取消拒绝
(
  医嘱id_In     病人医嘱执行.医嘱id%Type,
  发送号_In     病人医嘱执行.发送号%Type,
  操作员编号_In 人员表.编号%Type := Null,
  操作员姓名_In 人员表.姓名%Type := Null,
  执行部门id_In 门诊费用记录.执行部门id%Type := 0
  --参数：医嘱ID_IN=单独执行的医嘱ID，检验组合为显示的检验项目的ID。
) Is
  Cursor c_Advice Is
    Select ID, 相关id, 诊疗类别 From 病人医嘱记录 Where ID = 医嘱id_In;
  r_Advice   c_Advice%RowType;
  d_完成时间 病人医嘱发送.完成时间%Type;
  n_取消执行 Number;
  n_Diffday  Number(18, 3);

  n_Temp  Number;
  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  Select 完成时间 Into d_完成时间 From 病人医嘱发送 Where 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In;
  -----取消执行有效天数限制
  If Not d_完成时间 Is Null Then
    Select Zl_To_Number(Nvl(zl_GetSysParameter(220), '999')) Into n_取消执行 From Dual;
    Select Sysdate - d_完成时间 Into n_Diffday From Dual;
    --登记时间超过取消执行天数的记录，不允许删除医嘱执行记录
    If n_Diffday > n_取消执行 Then
      v_Error := '医嘱执行登记时间超过了取消执行有效天数，不能取消拒绝！';
      Raise Err_Custom;
    End If;
  End If;

  Open c_Advice;
  Fetch c_Advice
    Into r_Advice;

  If r_Advice.诊疗类别 = 'C' And r_Advice.相关id Is Not Null Then
    --包含一并采集的所有检验项目
    Update 病人医嘱发送
    Set 执行状态 = 0, 完成人 = Null, 完成时间 = Null, 执行说明 = Null
    Where 发送号 + 0 = 发送号_In And 医嘱id In (Select ID From 病人医嘱记录 Where 相关id = r_Advice.相关id);
  Else
    --包含附加手术,检验部位,以及其它独立医嘱;麻醉和中药煎法是单独安排
    Update 病人医嘱发送
    Set 执行状态 = 0, 完成人 = Null, 完成时间 = Null, 执行说明 = Null
    Where 发送号 + 0 = 发送号_In And 医嘱id In (Select ID
                                        From 病人医嘱记录
                                        Where ID = 医嘱id_In
                                        Union All
                                        Select ID
                                        From 病人医嘱记录
                                        Where 相关id = 医嘱id_In And 诊疗类别 In ('F', 'E', 'D'));
  End If;
  Close c_Advice;

  --消息平台处理
  If 执行部门id_In > 0 Then
    Select Count(1) Into n_Temp From 部门性质说明 Where 部门id = 执行部门id_In And 工作性质 = '检查';
    If n_Temp > 0 Then
      b_Message.Zlhis_Pacs_002(医嘱id_In, 2, 0);
    End If;
  End If;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱执行_取消拒绝;
/

--119388:黄捷,2018-01-04,修改设置报告图过程的参数
Create Or Replace Procedure Zl_影像检查_设置报告图
(
  图像uid_In    影像检查图象.图像uid%Type,
  Actiontype_In Number
) Is

Begin
  -- ActionType : 1 - 加入报告图；2 - 取消加入报告图
  If Actiontype_In = 1 Then
    Update 影像检查图象 Set 报告图 = 0 Where 图像uid = 图像uid_In And 报告图 Is Null;
  Else
    Update 影像检查图象 Set 报告图 = Null Where 图像uid = 图像uid_In And 报告图 = 0;
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_影像检查_设置报告图;
/

--119342:李业庆,2018-01-03,可用数量异常数据处理
--121505:李业庆,2018-02-01,可用数量动态计算
Create Or Replace Procedure Zl_药品库存_可用数量异常处理
(
  库房id_In In 药品库存.库房id%Type,
  药品id_In In 药品库存.药品id%Type,
  批次_In   In 药品库存.批次%Type := Null
) Is
  n_Month    Number(18);
  n_Count    Number(18);
  n_有效时间 药品收发记录.填制日期%Type;
  n_可用数量 药品库存.可用数量%Type;
  v_类别     收费项目目录.类别%Type;
  Cursor c_Stock Is
    Select 库房id, 药品id, 批次
    From 药品库存
    Where 药品id = 药品id_In And 库房id = 库房id_In And 批次 = Nvl(批次_In, 批次) And 性质 = 1
    Order By 批次;
Begin
  Select 类别 Into v_类别 From 收费项目目录 Where ID = 药品id_In;

  --只处理药品
  If v_类别 In ('5', '6', '7') Then
    n_Month := Nvl(zl_GetSysParameter(292), 0);
  
    If n_Month > 0 Then
      For r_Stock In c_Stock Loop
        Select Count(ID)
        Into n_Count
        From 药品收发记录
        Where 库房id + 0 = r_Stock.库房id And 药品id + 0 = r_Stock.药品id And 批次 = r_Stock.批次 And 填制日期 > Trunc(Sysdate);
      
        --当天无或只有1个该药品流通或发药数据时才处理
        If n_Count <= 1 Then
          Select Add_Months(Sysdate, -n_Month) Into n_有效时间 From Dual;
        
          Select Nvl(Sum(可用数量), 0) As 可用数量
          Into n_可用数量
          From (Select -1 * a.入出系数 * Nvl(a.付数, 1) * a.实际数量 As 可用数量
                 From 药品收发记录 A, 未审药品记录 B
                 Where a.Id = b.收发id And b.库房id + 0 = r_Stock.库房id And b.药品id + 0 = r_Stock.药品id And b.批次 = r_Stock.批次 And
                       b.单据 In (8, 9, 10) And Nvl(a.发药方式, -999) <> -1 And a.审核日期 Is Null And b.填制日期 > n_有效时间
                 Union All
                 Select -1 * a.入出系数 * Nvl(a.付数, 1) * a.实际数量 As 可用数量
                 From 药品收发记录 A, 未审药品记录 B
                 Where a.Id = b.收发id And b.库房id + 0 = r_Stock.库房id And b.药品id + 0 = r_Stock.药品id And b.批次 = r_Stock.批次 And
                       b.单据 In (1, 2, 3, 6, 7, 11, 12) And a.入出系数 * Nvl(a.付数, 1) * a.实际数量 < 0 And a.审核日期 Is Null And
                       b.填制日期 > n_有效时间);
        
          If n_可用数量 > 0 Then
            Update 药品库存
            Set 可用数量 = 实际数量 - n_可用数量
            Where 性质 = 1 And 库房id = r_Stock.库房id And 药品id = r_Stock.药品id And 批次 = r_Stock.批次;
          End If;
        End If;
      End Loop;
    End If;
  
    --容错处理
    Update 药品库存
    Set 可用数量 = 实际数量
    Where 性质 = 1 And 库房id = 库房id_In And 药品id = 药品id_In And 批次 = Nvl(批次_In, 批次) And Nvl(可用数量, 0) > Nvl(实际数量, 0);
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品库存_可用数量异常处理;
/

--119290:廖思奇,2018-01-03,Pacs排队叫号增加预呼功能。微调呼叫语句构成
Create Or Replace Function Zl_排队叫号队列_获取呼叫内容
(
  队列id_In   In 排队叫号队列.Id%Type,
  呼叫方式_In In Number
  --功能：获取语音播放时的播放内容 
  --参数： 
  --    呼叫方式_In:0-顺乎，1-直呼,2-广播,3-候诊呼叫 
) Return Varchar2 Is
  v_姓名     排队叫号队列.患者姓名%Type;
  v_诊室     排队叫号队列.诊室%Type;
  v_呼叫内容 Varchar2(1000);
Begin
  Select Zl_排队语音呼叫_多音字处理(a.患者姓名), a.诊室 Into v_姓名, v_诊室 From 排队叫号队列 A Where a.Id = 队列id_In;

  If 呼叫方式_In <> 3 Then
    v_呼叫内容 := '  请、' || v_姓名 || '、  ' || v_姓名 || '  、到' || v_诊室 || '就诊';
  Else
    v_呼叫内容 := '  请、' || v_姓名 || '、  ' || v_姓名 || '  、到' || v_诊室 || '准备检查';
  End If;

  Return v_呼叫内容;
Exception
  When Others Then
    Return Null;
End Zl_排队叫号队列_获取呼叫内容;
/

--117919:刘硕,2018-01-03,将Long Raw类型转换为BLOB或者CLOB类型
Create Or Replace Function Zl_Lob_Read
(
  Tab_In     In Number,
  Key_In     In Varchar2,
  Pos_In     In Number,
  Moved_In   In Number := 0,
  Lobtype_In In Number := 0
  --参数说明：
  --Tab_In：包含LOB的数据表
  --        0-病历标记图形;1-病历文件格式;2-病历文件图形;3-病历范文格式;4-病历范文图形;
  --        5-电子病历格式;6-电子病历图形;7-病历页面格式(图形);8-电子病历附件;9-体温重叠标记;
  --        10-临床路径文件;11-临床路径图标;12-病历页面格式(页眉文件);13-病历页面格式(页脚文件);
  --        14-人员证书记录;15-人员表;16-人员照片;17-药品规格(使用说明);18-药品规格(图片);
  --        19-部门扩展信息;20-人员扩展信息;22-医嘱报告内容;23-供应商照片;24-自定义申请单文件;25-医嘱申请单文件
  --        26-门诊路径文件,27-病人照片,28-咨询图片元素,29-咨询段落目录
  --Key_In：数据记录的关键字
  --Pos_In：从0开始不断读取，直到返回为空
  --Moved_In: 0正常记录,1读取转储后备表记录
  --LobType_IN:0-BLOb,1-CLOB
) Return Varchar2 Is
  Pragma Autonomous_Transaction;
  l_Blob   Blob;
  l_Clob   Clob;
  v_Buffer Varchar2(32767);
  n_Amount Number := 2000;
  n_Offset Number := 1;
  t_Key    t_Strlist;
  v_Dblink Varchar2(30);
Begin
  If Moved_In = 1 Then
    Select Max(Db连接) Into v_Dblink From zlBakSpaces Where 系统 = 100 And 当前 = 1;
  End If;
  If Tab_In = 0 Then
    Select 图形 Into l_Blob From 病历标记图形 Where 编码 = Key_In;
  Elsif Tab_In = 1 Then
    Select 内容 Into l_Blob From 病历文件格式 Where 文件id = To_Number(Key_In);
  Elsif Tab_In = 2 Then
    Select 图形 Into l_Blob From 病历文件图形 Where 对象id = To_Number(Key_In);
  Elsif Tab_In = 3 Then
    Select 内容 Into l_Blob From 病历范文格式 Where 文件id = To_Number(Key_In);
  Elsif Tab_In = 4 Then
    Select 图形 Into l_Blob From 病历范文图形 Where 对象id = To_Number(Key_In);
  Elsif Tab_In = 5 Then
    If Moved_In = 0 Then
      Select 内容 Into l_Blob From 电子病历格式 Where 文件id = To_Number(Key_In);
    Else
      If v_Dblink Is Not Null Then
        Execute Immediate 'Insert Into H电子病历格式 Select * From 电子病历格式@' || v_Dblink || ' Where 文件id = :1'
          Using To_Number(Key_In);
      End If;
      Select 内容 Into l_Blob From H电子病历格式 Where 文件id = To_Number(Key_In);
    End If;
  Elsif Tab_In = 6 Then
    If Moved_In = 0 Then
      Select 图形 Into l_Blob From 电子病历图形 Where 对象id = To_Number(Key_In);
    Else
      If v_Dblink Is Not Null Then
        Execute Immediate 'Insert Into H电子病历图形 Select * From 电子病历图形@' || v_Dblink || ' Where 对象id = :1'
          Using To_Number(Key_In);
      End If;
      Select 图形 Into l_Blob From H电子病历图形 Where 对象id = To_Number(Key_In);
    End If;
  Elsif Tab_In = 7 Then
    Select 图形
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
  Elsif Tab_In = 8 Then
    If Moved_In = 0 Then
      Select 内容
      Into l_Blob
      From 电子病历附件
      Where 病历id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 序号 = Substr(Key_In, Instr(Key_In, ',') + 1);
    Else
      If v_Dblink Is Not Null Then
        Execute Immediate 'Insert Into H电子病历附件 Select * From 电子病历附件@' || v_Dblink || ' Where 病历id = :1 And 序号 = :2'
          Using To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)), To_Number(Substr(Key_In, Instr(Key_In, ',') + 1));
      End If;
      Select 内容
      Into l_Blob
      From H电子病历附件
      Where 病历id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 序号 = Substr(Key_In, Instr(Key_In, ',') + 1);
    End If;
  Elsif Tab_In = 9 Then
    Select 标记图形 Into l_Blob From 体温重叠标记 Where 序号 = To_Number(Key_In);
  Elsif Tab_In = 10 Then
    Select 内容
    Into l_Blob
    From 临床路径文件
    Where 路径id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 文件名 = Substr(Key_In, Instr(Key_In, ',') + 1);
  Elsif Tab_In = 11 Then
    Select 图标 Into l_Blob From 临床路径图标 Where ID = To_Number(Key_In);
  Elsif Tab_In = 12 Then
    Select 页眉文件
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
  Elsif Tab_In = 13 Then
    Select 页脚文件
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
  Elsif Tab_In = 14 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    Select 签章信息 Into l_Clob From 人员证书记录 Where 人员id = To_Number(t_Key(1)) And Certsn = t_Key(2);
  Elsif Tab_In = 15 Then
    Select 签名图片 Into l_Blob From 人员表 Where ID = To_Number(Key_In);
  Elsif Tab_In = 16 Then
    Select 照片 Into l_Blob From 人员照片 Where 人员id = To_Number(Key_In);
  Elsif Tab_In = 19 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    Select 图片 Into l_Blob From 部门扩展信息 Where 部门id = To_Number(t_Key(1)) And 项目 = t_Key(2);
  Elsif Tab_In = 20 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    Select 图片 Into l_Blob From 人员扩展信息 Where 人员id = To_Number(t_Key(1)) And 项目 = t_Key(2);
  Elsif Tab_In = 22 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    Select 内容 Into l_Blob From 医嘱报告内容 Where ID = To_Number(Key_In);
  Elsif Tab_In = 23 Then
    If To_Number(Substr(Key_In, Instr(Key_In, ',') + 1)) = 0 Then
      Select 许可证号照片
      Into l_Blob
      From 供应商照片
      Where 供应商id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1));
    Elsif To_Number(Substr(Key_In, Instr(Key_In, ',') + 1)) = 1 Then
      Select 执照号照片
      Into l_Blob
      From 供应商照片
      Where 供应商id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1));
    Elsif To_Number(Substr(Key_In, Instr(Key_In, ',') + 1)) = 2 Then
      Select 授权号照片
      Into l_Blob
      From 供应商照片
      Where 供应商id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1));
    End If;
  Elsif Tab_In = 24 Then
    Select 内容
    Into l_Clob
    From 自定义申请单文件
    Where 文件id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And
          类别 = To_Number(Substr(Key_In, Instr(Key_In, ',') + 1));
  Elsif Tab_In = 25 Then
    Select 内容
    Into l_Clob
    From 医嘱申请单文件
    Where 医嘱id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And
          类别 = To_Number(Substr(Key_In, Instr(Key_In, ',') + 1));
  Elsif Tab_In = 26 Then
    Select 内容
    Into l_Blob
    From 门诊路径文件
    Where 路径id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 文件名 = Substr(Key_In, Instr(Key_In, ',') + 1);
  Elsif Tab_In = 27 Then
    Select 照片 Into l_Blob From 病人照片 Where 病人id = To_Number(Key_In);
  Elsif Tab_In = 28 Then
    Select 图形 Into l_Blob From 咨询图片元素 Where 序号 = To_Number(Key_In);
  Elsif Tab_In = 29 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    Select 段落文本
    Into l_Clob
    From 咨询段落目录
    Where 页面序号 = To_Number(t_Key(1)) And 段落序号 = To_Number(t_Key(2));
  End If;

  n_Offset := n_Offset + Pos_In * n_Amount;
  If Lobtype_In = 1 Then
    If l_Clob Is Null Then
      v_Buffer := Null;
    Else
      Dbms_Lob.Read(l_Clob, n_Amount, n_Offset, v_Buffer);
    End If;
  Else
    If l_Blob Is Null Then
      v_Buffer := Null;
    Else
      Dbms_Lob.Read(l_Blob, n_Amount, n_Offset, v_Buffer);
    End If;
  End If;
  If v_Dblink Is Not Null And Moved_In = 1 Then
	  Commit;
  End If;
  Return v_Buffer;
Exception
  When No_Data_Found Then
    If v_Dblink Is Not Null And Moved_In = 1 Then
      Commit;
    End If;
    Return Null;
End Zl_Lob_Read;
/

--117919:刘硕,2018-01-03,将Long Raw类型转换为BLOB或者CLOB类型
--99257:刘硕,2018-01-25,空文件处理
Create Or Replace Procedure Zl_Lob_Append
(
  Tab_In     In Number,
  Key_In     In Varchar2,
  Txt_In     In Varchar2, --16进制的文件片段或文字片段
  Cls_In     In Number := 0, --是否清除原来的内容，第一片段传递时为1，以后为0
  Lobtype_In In Number := 0 --0-BLOB;1-CLOB
  --参数说明：
  --Tab_In：包含LOB的数据表
  --        0-病历标记图形;1-病历文件格式;2-病历文件图形;3-病历范文格式;4-病历范文图形;
  --        5/21-电子病历格式;6-电子病历图形;7-病历页面格式；8-电子病历附件;9-体温重叠标记
  --        10-临床路径文件,11-临床路径图标;14-人员证书记录;15-人员表;16-人员照片;
  --        19-部门扩展信息;20-人员扩展信息;22-医嘱报告内容;
  --        23-供应商照片;24-自定义申请单文件;25-医嘱申请单文件
  --        26-门诊路径文件,27-病人照片,28-咨询图片元素,29-咨询段落目录
  --Key_In：数据记录的关键字
  --Txt_In：16进制的文件片段或文字片段
  --Cls_In：是否清除原来的内容，第一片段传递时为1，以后为0
  --Lobtype_In:--0-BLOB;1-CLOB
) Is
  l_Blob Blob;
  l_Clob Clob;
  t_Key  t_Strlist;
Begin
  If Tab_In = 0 Then
    If Cls_In = 1 Then
      Update 病历标记图形 Set 图形 = Empty_Blob() Where 编码 = Key_In;
    End If;
    Select 图形 Into l_Blob From 病历标记图形 Where 编码 = Key_In For Update;
  Elsif Tab_In = 1 Then
    If Cls_In = 1 Then
      Update 病历文件格式 Set 内容 = Empty_Blob() Where 文件id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 病历文件格式 (文件id, 内容) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 内容 Into l_Blob From 病历文件格式 Where 文件id = To_Number(Key_In) For Update;
  Elsif Tab_In = 2 Then
    If Cls_In = 1 Then
      Update 病历文件图形 Set 图形 = Empty_Blob() Where 对象id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 病历文件图形 (对象id, 图形) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 图形 Into l_Blob From 病历文件图形 Where 对象id = To_Number(Key_In) For Update;
  Elsif Tab_In = 3 Then
    If Cls_In = 1 Then
      Update 病历范文格式 Set 内容 = Empty_Blob() Where 文件id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 病历范文格式 (文件id, 内容) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 内容 Into l_Blob From 病历范文格式 Where 文件id = To_Number(Key_In) For Update;
  Elsif Tab_In = 4 Then
    If Cls_In = 1 Then
      Update 病历范文图形 Set 图形 = Empty_Blob() Where 对象id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 病历范文图形 (对象id, 图形) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 图形 Into l_Blob From 病历范文图形 Where 对象id = To_Number(Key_In) For Update;
  Elsif Tab_In = 5 Then
    If Cls_In = 1 Then
      Update 电子病历格式 Set 内容 = Empty_Blob() Where 文件id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 电子病历格式 (文件id, 内容) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 内容 Into l_Blob From 电子病历格式 Where 文件id = To_Number(Key_In) For Update;
  Elsif Tab_In = 6 Then
    If Cls_In = 1 Then
      Update 电子病历图形 Set 图形 = Empty_Blob() Where 对象id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 电子病历图形 (对象id, 图形) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 图形 Into l_Blob From 电子病历图形 Where 对象id = To_Number(Key_In) For Update;
  Elsif Tab_In = 7 Then
    If Cls_In = 1 Then
      Update 病历页面格式
      Set 图形 = Empty_Blob()
      Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
    End If;
    Select 图形
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3)
    For Update;
  Elsif Tab_In = 8 Then
    If Cls_In = 1 Then
      Update 电子病历附件
      Set 内容 = Empty_Blob()
      Where 病历id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 序号 = Substr(Key_In, Instr(Key_In, ',') + 1);
    End If;
    Select 内容
    Into l_Blob
    From 电子病历附件
    Where 病历id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 序号 = Substr(Key_In, Instr(Key_In, ',') + 1)
    For Update;
  Elsif Tab_In = 9 Then
    If Cls_In = 1 Then
      Update 体温重叠标记 Set 标记图形 = Empty_Blob() Where 序号 = To_Number(Key_In);
    End If;
    Select 标记图形 Into l_Blob From 体温重叠标记 Where 序号 = To_Number(Key_In) For Update;
  Elsif Tab_In = 10 Then
    If Cls_In = 1 Then
      Update 临床路径文件
      Set 内容 = Empty_Blob()
      Where 路径id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And
            文件名 = Substr(Key_In, Instr(Key_In, ',') + 1);
    End If;
    Select 内容
    Into l_Blob
    From 临床路径文件
    Where 路径id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 文件名 = Substr(Key_In, Instr(Key_In, ',') + 1)
    For Update;
  Elsif Tab_In = 11 Then
    If Cls_In = 1 Then
      Update 临床路径图标 Set 图标 = Empty_Blob() Where ID = To_Number(Key_In);
    End If;
    Select 图标 Into l_Blob From 临床路径图标 Where ID = To_Number(Key_In) For Update;
  Elsif Tab_In = 12 Then
    If Cls_In = 1 Then
      Update 病历页面格式
      Set 页眉文件 = Empty_Blob()
      Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
    End If;
    Select 页眉文件
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3)
    For Update;
  Elsif Tab_In = 13 Then
    If Cls_In = 1 Then
      Update 病历页面格式
      Set 页脚文件 = Empty_Blob()
      Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
    End If;
    Select 页脚文件
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3)
    For Update;
  Elsif Tab_In = 14 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    If Cls_In = 1 Then
      Update 人员证书记录 Set 签章信息 = Empty_Clob() Where 人员id = To_Number(t_Key(1)) And Certsn = t_Key(2);
    End If;
    Select 签章信息 Into l_Clob From 人员证书记录 Where 人员id = To_Number(t_Key(1)) And Certsn = t_Key(2) For Update;
  Elsif Tab_In = 15 Then
    If Cls_In = 1 Then
      Update 人员表 Set 签名图片 = Empty_Blob() Where ID = To_Number(Key_In);
    End If;
    Select 签名图片 Into l_Blob From 人员表 Where ID = To_Number(Key_In) For Update;
    Update 人员表 Set 最后修改时间 = Sysdate Where ID = To_Number(Key_In);
  Elsif Tab_In = 16 Then
    If Cls_In = 1 Then
      Update 人员照片 Set 照片 = Empty_Blob() Where 人员id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 人员照片 (人员id, 照片) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 照片 Into l_Blob From 人员照片 Where 人员id = To_Number(Key_In) For Update;
    Update 人员表 Set 最后修改时间 = Sysdate Where ID = To_Number(Key_In);
  Elsif Tab_In = 19 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    If Cls_In = 1 Then
      Update 部门扩展信息 Set 图片 = Empty_Blob() Where 部门id = To_Number(t_Key(1)) And 项目 = t_Key(2);
    End If;
    Select 图片 Into l_Blob From 部门扩展信息 Where 部门id = To_Number(t_Key(1)) And 项目 = t_Key(2) For Update;
    Update 部门表 Set 最后修改时间 = Sysdate Where ID = To_Number(t_Key(1));
  Elsif Tab_In = 20 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    If Cls_In = 1 Then
      Update 人员扩展信息 Set 图片 = Empty_Blob() Where 人员id = To_Number(t_Key(1)) And 项目 = t_Key(2);
    End If;
    Select 图片 Into l_Blob From 人员扩展信息 Where 人员id = To_Number(t_Key(1)) And 项目 = t_Key(2) For Update;
    Update 人员表 Set 最后修改时间 = Sysdate Where ID = To_Number(t_Key(1));
  Elsif Tab_In = 21 Then
    If Cls_In = 1 Then
      Update 电子病历格式 Set 文本内容 = Empty_Clob() Where 文件id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 电子病历格式 (文件id, 文本内容) Values (To_Number(Key_In), Empty_Clob());
      End If;
    End If;
    Select 文本内容 Into l_Clob From 电子病历格式 Where 文件id = To_Number(Key_In) For Update;
  Elsif Tab_In = 22 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    If Cls_In = 1 Then
      Update 医嘱报告内容 Set 内容 = Empty_Blob() Where ID = To_Number(t_Key(1));
    End If;
    Select 内容 Into l_Blob From 医嘱报告内容 Where ID = To_Number(t_Key(1)) For Update;
  Elsif Tab_In = 23 Then
    If To_Number(Substr(Key_In, Instr(Key_In, ',') + 1))=0 Then
      If Cls_In = 1 Then
        Update 供应商照片 Set 许可证号照片 = Empty_Blob() Where 供应商ID = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1));
        If Sql%RowCount = 0 Then
          Insert Into 供应商照片 (供应商ID, 许可证号照片,执照号照片,授权号照片) Values (To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)), Empty_Blob(), Empty_Blob(), Empty_Blob());
        End If;
      End If;
      Select 许可证号照片 Into l_Blob From 供应商照片 Where 供应商ID =To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) For Update;
    Elsif  To_Number(Substr(Key_In, Instr(Key_In, ',') + 1))=1 Then
      If Cls_In = 1 Then
        Update 供应商照片 Set 执照号照片 = Empty_Blob() Where 供应商ID = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1));
        If Sql%RowCount = 0 Then
          Insert Into 供应商照片 (供应商ID, 许可证号照片,执照号照片,授权号照片) Values (To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)), Empty_Blob(), Empty_Blob(), Empty_Blob());
        End If;
      End If;
      Select 执照号照片 Into l_Blob From 供应商照片 Where 供应商ID =To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) For Update;
    Elsif To_Number(Substr(Key_In, Instr(Key_In, ',') + 1))=2 Then
     If Cls_In = 1 Then
        Update 供应商照片 Set 授权号照片 = Empty_Blob() Where 供应商ID = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1));
        If Sql%RowCount = 0 Then
          Insert Into 供应商照片 (供应商ID, 许可证号照片,执照号照片,授权号照片) Values (To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)), Empty_Blob(), Empty_Blob(), Empty_Blob());
        End If;
      End If;
      Select 授权号照片 Into l_Blob From 供应商照片 Where 供应商ID =To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) For Update;
    End If;
  Elsif Tab_In = 24 Then
    If Cls_In = 1 Then
      Update 自定义申请单文件
      Set 内容 = Empty_Clob()
      Where 文件id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And
            类别 = To_Number(Substr(Key_In, Instr(Key_In, ',') + 1)) ;
    End If;
    Select 内容
    Into l_Clob
    From 自定义申请单文件
    Where 文件id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 类别 = To_Number(Substr(Key_In, Instr(Key_In, ',') + 1)) 
    For Update;
  ElsIf Tab_In = 25 Then
    If Cls_In = 1 Then
      Update 医嘱申请单文件
      Set 内容 = Empty_Clob()
      Where 医嘱id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 
            类别 = To_Number(Substr(Key_In, Instr(Key_In, ',') + 1))  ;
    End If;
    Select 内容
    Into l_Clob
    From 医嘱申请单文件
    Where 医嘱id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 类别 = To_Number(Substr(Key_In, Instr(Key_In, ',') + 1)) 
    For Update;
  Elsif Tab_In = 26 Then
    If Cls_In = 1 Then
      Update 门诊路径文件
      Set 内容 = Empty_Blob()
      Where 路径id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And
            文件名 = Substr(Key_In, Instr(Key_In, ',') + 1);
    End If;
    Select 内容
    Into l_Blob
    From 门诊路径文件
    Where 路径id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 文件名 = Substr(Key_In, Instr(Key_In, ',') + 1)
    For Update;
  Elsif Tab_In = 27 Then
    If Cls_In = 1 Then
      Update 病人照片 Set 照片 = Empty_Blob() Where 病人id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 病人照片 (病人id, 照片) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 照片 Into l_Blob From 病人照片 Where 病人id = To_Number(Key_In) For Update;
  Elsif Tab_In = 28 Then
    If Cls_In = 1 Then
      Update 咨询图片元素 Set 图形 = Empty_Blob() Where 序号 = To_Number(Key_In);
    End If;
    Select 图形 Into l_Blob From 咨询图片元素 Where 序号 = To_Number(Key_In) For Update;
  Elsif Tab_In = 29 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    If Cls_In = 1 Then
      Update 咨询段落目录
      Set 段落文本 = Empty_Clob()
      Where 页面序号 = To_Number(t_Key(1)) And 段落序号 = To_Number(t_Key(2));
    End If;
    Select 段落文本
    Into l_Clob
    From 咨询段落目录
    Where 页面序号 = To_Number(t_Key(1)) And 段落序号 = To_Number(t_Key(2))
    For Update;
  End If;

  If Not Txt_In Is Null Then
    If Lobtype_In = 1 Then
      Dbms_Lob.Writeappend(l_Clob, Length(Txt_In), Txt_In);
    Else
      Dbms_Lob.Writeappend(l_Blob, Length(Hextoraw(Txt_In)) / 2, Hextoraw(Txt_In));
    End If;
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Lob_Append;
/
--122143:冉俊明,2018-02-26,修正当日已部分停诊且当前在停诊时间范围内时号源在支付宝仍能够看到并挂号问题
--118848:冉俊明,2017-12-29,获取预约号源时，启用分时段序号控制的不返回不允许预约的序号时段
Create Or Replace Procedure Zl_Third_Getnolist
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取号源列表(简易模式)
  --入参:Xml_In:
  --<IN>
  --  <RQ>日期</RQ>
  --  <KSID>科室ID</KSID>
  --  <YSID>医生ID</YSID>
  --  <YSXM>医生姓名</YSXM>
  --  <HZDW>支付宝</HZDW>    //合作单位，传入了的时候，只取合作单位的号;为空时，只取非合作单位的号
  --  <FKFS>付款方式</FKFS>  
  --  <SJJG>60</SJJG>     //时间间隔,不传则返回序号时段
  --  <ZD></ZD>           //站点
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  --  <GROUP>
  --    <RQ>日期</RQ>
  --    <HBLIST>
  --     <HB>
  --        <CZJLID>1</CZJLID>     //出诊记录ID
  --        <APID></APID>          //挂号安排ID
  --        <JHID></JHID>          //挂号计划ID
  --        <HM>235</HM>       //号码
  --        <YSID>549</YSID>      //医生ID
  --        <YS>张锐</YS>       //医生姓名
  --        <KSID>123</KSID>   //科室ID
  --        <KSMC>内科</KSMC>   //科室名称
  --        <ZC>主治医师</ZC> //职称
  --        <XMID>10086<XMID> //挂号项目的ID
  --        <XMMC>挂号费</XMMC> //挂号项目的名称
  --        <YGHS>0</YGHS>      //已挂号数
  --        <SYHS>99</SYHS>   //剩余号数
  --        <PRICE>15</PRICE>      //价格
  --        <HL>普通</HL>       //挂号类型
  --        <HCXH>1</HCXH>    //是否存在缓冲序号时间段，1-存在 0或者空-不存在
  --        <FSD>0</FSD>      //是否分时段
  --        <FWMC>白天</FWMC>     //号别时段
  --        <HBTIME>(08:00-17:59)</HBTIME> //可挂时间
  --     <SPANLIST>
  --            <SPAN>
  --                  <SJD></SJD>          //时间段,格式:hh24:mi-hh24:mi
  --                  <GHZS></GHZS>      //时段挂号总数
  --                  <SL></SL>      //剩余数量
  --            </SPAN>
  --            ……
  --          </SPANLIST>
  --      </HB>
  --      <HB>
  --      ……
  --      </HB>
  --    </HBLIST>
  --  </GROUP>
  --</OUTPUT>
  --
  --“序号时段”<SPANLIST>和“剩余号数”<SYHS>节点说明：
  --  1.出诊表排班模式：
  --    1.1启用分时段，同时启用序号控制
  --      1.1.1传入合作单位
  --          1）当日：
  --                  序号时段：按比例或按总量时，号源剩余的可挂号时段；按序号时，分配给该合作单位剩余的可预约时段
  --                  剩余号数：分配给该合作单位剩余的可预约数量
  --          2）当日以后：
  --                  序号时段：按比例或按总量时，号源剩余的可预约时段；按序号时，分配给该合作单位剩余的可预约时段
  --                  剩余号数：分配给该合作单位剩余的可预约数量
  --      1.1.2不传入合作单位
  --          1）当日：
  --                  序号时段：号源剩余的可挂号时段
  --                  剩余号数：号源剩余的可挂号数量
  --          2）当日以后：
  --                  序号时段：号源剩余的可预约时段
  --                  剩余号数：号源剩余的可预约数量
  --------------------------------------------------------------------------------------------------
  x_Templet Xmltype; --模板XML

  d_日期     临床出诊记录.出诊日期%Type;
  n_科室id   挂号安排.科室id%Type;
  n_医生id   挂号安排.医生id%Type;
  v_医生姓名 挂号安排.医生姓名%Type;
  v_合作单位 挂号合作单位.名称%Type;
  n_时间间隔 挂号安排.默认时段间隔%Type;

  v_挂号模式 Varchar2(500);
  n_挂号模式 Number(3);
  d_启用时间 Date;
  n_预约天数 挂号安排.预约天数%Type;
  n_补充天数 挂号安排.预约天数%Type;

  v_剩余数量 挂号安排时段.限制数量%Type;
  n_禁用     Number(3);
  v_Temp     Varchar2(32767); --临时XML
  c_Xmlmain  Clob; --临时XML 
  v_Xmlmain  Clob; --临时XML 

  d_时段开始 挂号安排时段.开始时间%Type;
  d_时段结束 挂号安排时段.结束时间%Type;
  n_时段总数 挂号安排时段.限制数量%Type;
  n_时段剩余 挂号安排时段.限制数量%Type;
  n_时段已挂 挂号安排时段.限制数量%Type;

  v_星期         挂号安排限制.限制项目%Type;
  v_时间段       Varchar2(100);
  n_分时段       Number(3);
  n_单个剩余     Number(5);
  n_已挂数       Number(5);
  n_合约已挂数   Number(5);
  n_合计金额     收费价目.现价%Type;
  n_合约总数量   Number(5);
  n_合约剩余数量 Number(5);
  n_最大可用数量 Number(5);
  n_合约模式     Number(3); --合约模式:1-合约单位限数量模式 0-合约单位指定序号模式
  n_非合约       Number(3);
  n_是否预留     Number(3);

  d_开始时间 临床出诊记录.开始时间%Type;
  d_终止时间 临床出诊记录.终止时间%Type;
  d_加号时间 临床出诊记录.开始时间%Type;

  n_缓冲序号 Number(3);
  n_时段数量 Number(5);
  n_预留数量 Number(5);
  n_特殊预约 Number(3);
  v_Timetemp Varchar2(100);
  n_Exists   Number(5);

  v_普通等级   Varchar2(100);
  v_Pricegrade Varchar2(500);
  v_站点       部门表.站点%Type;
  v_付款方式   医疗付款方式.名称%Type;
  v_方式       Varchar2(20);

  v_Err_Msg Varchar2(200);
  Err_Item Exception;

  --获取序号时段XML
  Function Gettimexml
  (
    时段开始_In 临床出诊序号控制.开始时间%Type,
    时段结束_In 临床出诊序号控制.终止时间%Type,
    时段总数_In 临床出诊序号控制.数量%Type,
    时段剩余_In 临床出诊序号控制.数量%Type
  ) Return Varchar2 Is
    v_Temp Varchar2(4000);
  Begin
    v_Temp := '';
    v_Temp := v_Temp || '<SPAN>';
    v_Temp := v_Temp || '<SJD>' || To_Char(时段开始_In, 'hh24:mi:ss') || '-' || To_Char(时段结束_In, 'hh24:mi:ss') || '</SJD>';
    v_Temp := v_Temp || '<GHZS>' || 时段总数_In || '</GHZS>';
    v_Temp := v_Temp || '<SL>' || 时段剩余_In || '</SL>';
    v_Temp := v_Temp || '</SPAN>';
    Return v_Temp;
  End;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select To_Date(Extractvalue(Value(A), 'IN/RQ'), 'YYYY-MM-DD hh24:mi:ss'), Extractvalue(Value(A), 'IN/KSID'),
         Extractvalue(Value(A), 'IN/YSID'), Extractvalue(Value(A), 'IN/YSXM'), Extractvalue(Value(A), 'IN/HZDW'),
         Extractvalue(Value(A), 'IN/SJJG'), Extractvalue(Value(A), 'IN/ZD'), Extractvalue(Value(A), 'IN/FKFS')
  Into d_日期, n_科室id, n_医生id, v_医生姓名, v_合作单位, n_时间间隔, v_站点, v_方式
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  --日期节点为空的情况
  d_日期 := Nvl(d_日期, Trunc(Sysdate));

  If v_方式 Is Null Then
    Select Max(名称) Into v_付款方式 From 医疗付款方式 Where 缺省标志 = 1;
  Else
    Select Nvl(Max(名称), v_方式) Into v_付款方式 From 医疗付款方式 Where 编码 = v_方式;
  End If;
  v_Pricegrade := Zl_Get_Pricegrade(v_站点, Null, Null, v_付款方式);
  v_普通等级   := Substr(v_Pricegrade, 1, Instr(v_Pricegrade, '|') - 1);

  v_挂号模式 := zl_GetSysParameter('挂号排班模式') || '|||';
  n_挂号模式 := To_Number(Substr(v_挂号模式, 1, Instr(v_挂号模式, '|') - 1));
  If n_挂号模式 = 1 Then
    v_挂号模式 := Substr(v_挂号模式, Instr(v_挂号模式, '|') + 1);
    v_Temp     := Substr(v_挂号模式, 1, Instr(v_挂号模式, '|') - 1);
    d_启用时间 := To_Date(Nvl(v_Temp, '1900-01-01'), 'yyyy-mm-dd hh24:mi:ss');
    If d_日期 < d_启用时间 Then
      n_挂号模式 := 0;
    End If;
  End If;

  n_预约天数 := Nvl(zl_GetSysParameter(66), 7);
  c_Xmlmain  := '';

  --===========================================================================================
  --计划排班模式 
  --===========================================================================================
  If n_挂号模式 = 0 Then
    Select Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null)
    Into v_星期
    From Dual;
    n_合约剩余数量 := 0;
  
    For r_No In (Select a.科室id, a.号类, a.科室名称, a.医生姓名, a.医生id, a.职称, a.号码, a.安排id, a.计划id, a.排班, a.项目id, a.项目名称, a.序号控制,
                        a.限号数, a.限约数, a.预约天数, Nvl(Hz.已挂数, 0) As 已挂数, Nvl(Hz.已约数, 0) As 已约数, Nvl(Hz.其中已接收, 0) As 已接收,
                        Sum(b.现价) As 价格
                 From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Nvl(Ap.医生id, 0) As 医生id, Ry.专业技术职务 As 职称, Ap.号码,
                               Ap.安排id, Ap.计划id, Ap.排班, Ap.项目id, Fy.名称 As 项目名称, Ap.序号控制, Ap.限号数, Ap.限约数, Ap.预约天数
                        From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Ap.医生id, Ap.号码, Ap.Id As 安排id, 0 As 计划id,
                                      Ap.项目id, Nvl(Ap.序号控制, 0) As 序号控制,
                                      Decode(To_Char(d_日期, 'D'), '1', Ap.周日, '2', Ap.周一, '3', Ap.周二, '4', Ap.周三, '5', Ap.周四,
                                              '6', Ap.周五, '7', Ap.周六, Null) As 排班, Xz.限约数, Xz.限号数,
                                      Nvl(Ap.预约天数, n_预约天数) As 预约天数
                               From 挂号安排 Ap, 部门表 Bm, 挂号安排限制 Xz
                               Where Ap.科室id = Bm.Id(+) And Decode(Nvl(n_科室id, 0), 0, 0, Ap.科室id) = Nvl(n_科室id, 0) And
                                     Decode(Nvl(n_医生id, 0), 0, 0, Ap.医生id) = Nvl(n_医生id, 0) And
                                     Decode(Nvl(v_医生姓名, '-'), '-', '-', Ap.医生姓名) = Nvl(v_医生姓名, '-') And Ap.停用日期 Is Null And
                                     d_日期 Between Nvl(Ap.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                     Nvl(Ap.终止时间, To_Date('3000 - 01 - 01', 'YYYY-MM-DD')) And Xz.安排id(+) = Ap.Id And
                                     Xz.限制项目(+) = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                         '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                (Select Rownum
                                      From 挂号安排停用状态 Ty
                                      Where Ty.安排id = Ap.Id And d_日期 Between Ty.开始停止时间 And Ty.结束停止时间) And Not Exists
                                (Select Rownum
                                      From 挂号安排计划 Jh
                                      Where Jh.安排id = Ap.Id And Jh.审核时间 Is Not Null And
                                            d_日期 Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                            Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')))
                               Union All
                               Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Jh.医生姓名, Jh.医生id, Ap.号码, Ap.Id As 安排id, Jh.Id As 计划id,
                                      Jh.项目id, Nvl(Jh.序号控制, 0) As 序号控制,
                                      Decode(To_Char(d_日期, 'D'), '1', Jh.周日, '2', Jh.周一, '3', Jh.周二, '4', Jh.周三, '5', Jh.周四,
                                              '6', Jh.周五, '7', Jh.周六, Null) As 排班, Xz.限约数, Xz.限号数,
                                      Nvl(Ap.预约天数, n_预约天数) As 预约天数
                               From 挂号安排计划 Jh, 挂号安排 Ap, 部门表 Bm, 挂号计划限制 Xz
                               Where Jh.安排id = Ap.Id And Ap.科室id = Bm.Id(+) And Ap.停用日期 Is Null And
                                     Decode(Nvl(n_科室id, 0), 0, 0, Ap.科室id) = Nvl(n_科室id, 0) And
                                     Decode(Nvl(n_医生id, 0), 0, 0, Jh.医生id) = Nvl(n_医生id, 0) And
                                     Decode(Nvl(v_医生姓名, '-'), '-', '-', Jh.医生姓名) = Nvl(v_医生姓名, '-') And
                                     d_日期 Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                     Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.计划id(+) = Jh.Id And
                                     Xz.限制项目(+) = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                         '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                (Select Rownum
                                      From 挂号安排停用状态 Ty
                                      Where Ty.安排id = Ap.Id And d_日期 Between Ty.开始停止时间 And Ty.结束停止时间) And
                                     (Jh.生效时间, Jh.安排id) =
                                     (Select Max(Sxjh.生效时间) As 生效时间, 安排id
                                      From 挂号安排计划 Sxjh
                                      Where Sxjh.审核时间 Is Not Null And
                                            d_日期 Between Nvl(Sxjh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                            Nvl(Sxjh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Sxjh.安排id = Jh.安排id
                                      Group By Sxjh.安排id)) Ap, 部门表 Bm, 人员表 Ry, 收费项目目录 Fy
                        Where Ap.科室id = Bm.Id(+) And Ap.医生id = Ry.Id(+) And Ap.项目id = Fy.Id And 排班 Is Not Null) A,
                      病人挂号汇总 Hz, 收费价目 B
                 Where a.号码 = Hz.号码(+) And Hz.日期(+) = Trunc(d_日期) And a.项目id = b.收费细目id And
                       Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-Mm-DD')) > d_日期 And b.执行日期 <= d_日期 And
                       (b.价格等级 = v_普通等级 Or (b.价格等级 Is Null And Not Exists
                        (Select 1
                                             From 收费价目
                                             Where 收费细目id = b.收费细目id And 价格等级 = v_普通等级 And d_日期 Between 执行日期 And
                                                   Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')))))
                 Group By a.科室id, a.号类, a.科室名称, a.医生姓名, a.医生id, a.职称, a.号码, a.安排id, a.计划id, a.排班, a.项目id, a.项目名称, a.序号控制,
                          a.限号数, a.限约数, a.预约天数, Nvl(Hz.已挂数, 0), Nvl(Hz.已约数, 0), Nvl(Hz.其中已接收, 0)) Loop
      Zl_挂号序号状态_Delete(1, r_No.号码);
      If Sysdate + Nvl(r_No.预约天数, n_预约天数) >= d_日期 Then
        If r_No.计划id <> 0 Then
          Select Sign(Count(Rownum))
          Into n_分时段
          From 挂号安排计划 Jh, 挂号计划时段 Sd
          Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7',
                               '周六', Null) And Rownum < 2;
        Else
          Select Sign(Count(Rownum))
          Into n_分时段
          From 挂号安排 Ap, 挂号安排时段 Sd
          Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7',
                               '周六', Null) And Rownum < 2;
        End If;
        --分时段不序号控制当天号为普通号
        If Trunc(Sysdate) = Trunc(d_日期) And n_分时段 = 1 And r_No.序号控制 = 0 Then
          n_分时段 := 0;
        End If;
        If n_分时段 = 0 Then
          v_Temp := '';
          If v_合作单位 Is Not Null And r_No.序号控制 = 1 Then
            If r_No.计划id <> 0 Then
              Select Nvl(Sum(数量), 0)
              Into n_合约总数量
              From 合作单位计划控制
              Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null);
              Select Count(1)
              Into n_合约模式
              From 合作单位计划控制
              Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 序号 = 0;
            Else
              Select Nvl(Sum(数量), 0)
              Into n_合约总数量
              From 合作单位安排控制
              Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null);
              Select Count(1)
              Into n_合约模式
              From 合作单位安排控制
              Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 序号 = 0;
            End If;
            If n_合约模式 = 0 Then
              If r_No.计划id <> 0 Then
                Select Count(1)
                Into n_合约已挂数
                From 病人挂号记录 A
                Where 号别 = r_No.号码 And 记录状态 = 1 And 发生时间 Between Trunc(d_日期) And Trunc(d_日期 + 1) - 1 / 60 / 60 / 24 And
                      Exists
                 (Select 1
                       From 合作单位计划控制
                       Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                             限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                           '周五', '7', '周六', Null) And 序号 = a.号序 And 数量 <> 0);
              Else
                Select Count(1)
                Into n_合约已挂数
                From 病人挂号记录 A
                Where 号别 = r_No.号码 And 记录状态 = 1 And 发生时间 Between Trunc(d_日期) And Trunc(d_日期 + 1) - 1 / 60 / 60 / 24 And
                      Exists
                 (Select 1
                       From 合作单位安排控制
                       Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                             限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                           '周五', '7', '周六', Null) And 序号 = a.号序 And 数量 <> 0);
              End If;
            Else
              Select Count(1)
              Into n_合约已挂数
              From 病人挂号记录
              Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                    Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
            End If;
            If n_合约总数量 = 0 Then
              n_合约剩余数量 := 0;
            Else
              n_合约剩余数量 := n_合约总数量 - n_合约已挂数;
              If n_合约剩余数量 > (Nvl(r_No.限号数, 0) - r_No.已挂数) Then
                n_合约剩余数量 := Nvl(r_No.限号数, 0) - r_No.已挂数;
              End If;
            End If;
          End If;
        Else
          v_Temp := '<SPANLIST>';
          If r_No.计划id <> 0 Then
            Select To_Date(To_Char(d_日期, 'yyyy-mm-dd') || To_Char(Max(结束时间), 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss')
            Into d_加号时间
            From 挂号计划时段
            Where 计划id = r_No.计划id And 星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                   '周四', '6', '周五', '7', '周六', Null);
            If r_No.序号控制 = 1 Then
              If Trunc(d_日期) = Trunc(Sysdate) Then
                n_特殊预约 := 0;
              Else
                Select Nvl(Max(Jh.是否预约), 0)
                Into n_特殊预约
                From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                              To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                              To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                       From 挂号安排计划 Jh, 挂号计划时段 Sd
                       Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                             Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                            '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                Where Zt.日期(+) = Jh.开始时间 And Zt.号码(+) = Jh.号码 And Zt.序号(+) = Jh.序号 And
                      Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) <> 1;
              End If;
            
              d_时段开始 := Null;
              d_时段结束 := Null;
              n_时段总数 := 0;
              n_时段剩余 := 0;
              For r_Time In (Select Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约, 0 As 已约数,
                                    Decode(Nvl(Zt.序号, 0), 0, 1, 0) As 剩余数,
                                    Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) As 失效时段
                             From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                    From 挂号安排计划 Jh, 挂号计划时段 Sd
                                    Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And Not Exists
                                     (Select 1
                                           From 挂号安排停用状态
                                           Where 安排id = Jh.安排id And
                                                 To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' ||
                                                         To_Char(Sd.开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') Between
                                                 开始停止时间 And 结束停止时间) And
                                          Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                         '5', '周四', '6', '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                             Where Zt.日期(+) = Jh.开始时间 And Zt.号码(+) = Jh.号码 And Zt.序号(+) = Jh.序号
                             Order By 序号) Loop
                If Nvl(n_时间间隔, 0) <> 0 Then
                  If d_时段开始 Is Null Then
                    d_时段开始 := r_Time.开始时间;
                    d_时段结束 := r_Time.开始时间 + n_时间间隔 / 24 / 60;
                    n_时段总数 := n_时段总数 + r_Time.限制数量;
                    If d_加号时间 < d_时段结束 Then
                      d_时段结束 := d_加号时间;
                    End If;
                  Else
                    If r_Time.开始时间 >= d_时段结束 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                    To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                    '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                      n_时段总数 := r_Time.限制数量;
                      n_时段剩余 := 0;
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := d_时段开始 + n_时间间隔 / 24 / 60;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      n_时段总数 := n_时段总数 + r_Time.限制数量;
                    End If;
                  End If;
                End If;
                If v_合作单位 Is Not Null Then
                  Select Nvl(Max(1), 0)
                  Into n_合约模式
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
                Else
                  n_合约模式 := 0;
                End If;
                If r_Time.剩余数 = 0 Then
                  n_单个剩余 := 0;
                Else
                  n_单个剩余 := r_Time.限制数量;
                End If;
                If v_合作单位 Is Null Or n_合约模式 = 1 Then
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And Rownum < 2;
                  If n_Exists = 0 And r_Time.失效时段 <> 1 Then
                    If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                      Null;
                    Else
                      Select Nvl(Max(1), 0)
                      Into n_是否预留
                      From 挂号序号状态
                      Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                      If n_是否预留 = 0 Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                    '</SPAN>';
                        Else
                          n_时段剩余 := n_时段剩余 + n_单个剩余;
                        End If;
                        n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                      End If;
                    End If;
                  End If;
                Else
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                  Begin
                    Select 0
                    Into n_非合约
                    From 合作单位计划控制
                    Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_非合约 := 1;
                  End;
                  If (n_Exists = 1 Or n_非合约 = 1) And r_Time.失效时段 <> 1 Then
                    If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                      Null;
                    Else
                      Select Nvl(Max(1), 0)
                      Into n_是否预留
                      From 挂号序号状态
                      Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                      If n_是否预留 = 0 Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                    '</SPAN>';
                        Else
                          n_时段剩余 := n_时段剩余 + n_单个剩余;
                        End If;
                        n_合约剩余数量 := n_合约剩余数量 + 1;
                      End If;
                    End If;
                  End If;
                End If;
              End Loop;
              If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                              To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                              n_时段剩余 || '</SL>' || '</SPAN>';
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
              End If;
            Else
              n_最大可用数量 := Nvl(r_No.限约数, Nvl(r_No.限号数, 0)) - Nvl(r_No.已约数, 0);
              n_时段总数     := 0;
              n_时段剩余     := 0;
              d_时段开始     := Null;
              d_时段结束     := Null;
              For r_Time In (Select Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约,
                                    Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 已约数,
                                    Jh.限制数量 - Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 剩余数,
                                    Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) As 失效时段
                             From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                    From 挂号安排计划 Jh, 挂号计划时段 Sd
                                    Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And Not Exists
                                     (Select 1
                                           From 挂号安排停用状态
                                           Where 安排id = Jh.安排id And
                                                 To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' ||
                                                         To_Char(Sd.开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') Between
                                                 开始停止时间 And 结束停止时间) And
                                          Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                         '5', '周四', '6', '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                             Where Jh.号码 = Zt.号码(+) And Jh.开始时间 = Zt.日期(+)
                             Group By Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约
                             Order By Jh.序号) Loop
                If Nvl(n_时间间隔, 0) <> 0 Then
                  If d_时段开始 Is Null Then
                    d_时段开始 := r_Time.开始时间;
                    d_时段结束 := r_Time.开始时间 + n_时间间隔 / 24 / 60;
                    n_时段总数 := n_时段总数 + r_Time.限制数量;
                    If d_加号时间 < d_时段结束 Then
                      d_时段结束 := d_加号时间;
                    End If;
                  Else
                    If r_Time.开始时间 >= d_时段结束 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                    To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                    '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                      n_时段总数 := r_Time.限制数量;
                      n_时段剩余 := 0;
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := d_时段开始 + n_时间间隔 / 24 / 60;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      n_时段总数 := n_时段总数 + r_Time.限制数量;
                    End If;
                  End If;
                End If;
                If v_合作单位 Is Not Null Then
                  Select Nvl(Max(1), 0)
                  Into n_合约模式
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
                Else
                  n_合约模式 := 0;
                End If;
                n_单个剩余 := r_Time.剩余数;
                If v_合作单位 Is Null Or n_合约模式 = 1 Then
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And Rownum < 2;
                  If n_Exists = 0 And r_Time.失效时段 <> 1 Then
                    If n_最大可用数量 < n_单个剩余 Then
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_最大可用数量;
                      End If;
                      n_时段数量 := Nvl(n_时段数量, 0) + n_最大可用数量;
                    Else
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_单个剩余;
                      End If;
                      n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                    End If;
                  End If;
                Else
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                  Begin
                    Select 0
                    Into n_非合约
                    From 合作单位计划控制
                    Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_非合约 := 1;
                  End;
                  If (n_Exists = 1 Or n_非合约 = 1) And r_Time.失效时段 <> 1 Then
                    If n_最大可用数量 < n_单个剩余 Then
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_最大可用数量;
                      End If;
                      n_合约剩余数量 := n_合约剩余数量 + Nvl(n_最大可用数量, 0);
                    Else
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_单个剩余;
                      End If;
                      n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                    End If;
                  End If;
                End If;
              End Loop;
              If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                              To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                              n_时段剩余 || '</SL>' || '</SPAN>';
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
              End If;
            End If;
          Else
            Select To_Date(To_Char(d_日期, 'yyyy-mm-dd') || To_Char(Max(结束时间), 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss')
            Into d_加号时间
            From 挂号安排时段
            Where 安排id = r_No.安排id And 星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                   '周四', '6', '周五', '7', '周六', Null);
            If r_No.序号控制 = 1 Then
              If Trunc(d_日期) = Trunc(Sysdate) Then
                n_特殊预约 := 0;
              Else
                Select Nvl(Max(Ap.是否预约), 0)
                Into n_特殊预约
                From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                              To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                              To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                       From 挂号安排 Ap, 挂号安排时段 Sd
                       Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                             Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                            '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                Where Zt.日期(+) = Ap.开始时间 And Zt.号码(+) = Ap.号码 And Zt.序号(+) = Ap.序号 And
                      Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) <> 1;
              End If;
              n_时段总数 := 0;
              n_时段剩余 := 0;
              d_时段开始 := Null;
              d_时段结束 := Null;
              For r_Time In (Select Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约, 0 As 已约数,
                                    Decode(Nvl(Zt.序号, 0), 0, 1, 0) As 剩余数,
                                    Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) As 失效时段
                             
                             From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                    From 挂号安排 Ap, 挂号安排时段 Sd
                                    Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And Not Exists
                                     (Select 1
                                           From 挂号安排停用状态
                                           Where 安排id = Ap.Id And
                                                 To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' ||
                                                         To_Char(Sd.开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') Between
                                                 开始停止时间 And 结束停止时间) And
                                          Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                         '5', '周四', '6', '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                             Where Zt.日期(+) = Ap.开始时间 And Zt.号码(+) = Ap.号码 And Zt.序号(+) = Ap.序号
                             Order By 序号) Loop
                If Nvl(n_时间间隔, 0) <> 0 Then
                  If d_时段开始 Is Null Then
                    d_时段开始 := r_Time.开始时间;
                    n_时段总数 := n_时段总数 + r_Time.限制数量;
                    d_时段结束 := r_Time.开始时间 + n_时间间隔 / 24 / 60;
                    If d_加号时间 < d_时段结束 Then
                      d_时段结束 := d_加号时间;
                    End If;
                  Else
                    If r_Time.开始时间 >= d_时段结束 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                    To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                    '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                      n_时段总数 := r_Time.限制数量;
                      n_时段剩余 := 0;
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := d_时段开始 + n_时间间隔 / 24 / 60;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      n_时段总数 := n_时段总数 + r_Time.限制数量;
                    End If;
                  End If;
                End If;
                If v_合作单位 Is Not Null Then
                  Begin
                    Select 1
                    Into n_合约模式
                    From 合作单位安排控制
                    Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
                  Exception
                    When Others Then
                      n_合约模式 := 0;
                  End;
                Else
                  n_合约模式 := 0;
                End If;
                If r_Time.剩余数 = 0 Then
                  n_单个剩余 := 0;
                Else
                  n_单个剩余 := r_Time.限制数量;
                End If;
                If v_合作单位 Is Null Or n_合约模式 = 1 Then
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And Rownum < 2;
                  If n_Exists = 0 And r_Time.失效时段 <> 1 Then
                    If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                      Null;
                    Else
                      Select Nvl(Max(1), 0)
                      Into n_是否预留
                      From 挂号序号状态
                      Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                      If n_是否预留 = 0 Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                    '</SPAN>';
                        Else
                          n_时段剩余 := n_时段剩余 + n_单个剩余;
                        End If;
                        n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                      End If;
                    End If;
                  End If;
                Else
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                  Begin
                    Select 0
                    Into n_非合约
                    From 合作单位安排控制
                    Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_非合约 := 1;
                  End;
                  If (n_Exists = 1 Or n_非合约 = 1) And r_Time.失效时段 <> 1 Then
                    If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                      Null;
                    Else
                      Select Nvl(Max(1), 0)
                      Into n_是否预留
                      From 挂号序号状态
                      Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                      If n_是否预留 = 0 Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                    '</SPAN>';
                        Else
                          n_时段剩余 := n_时段剩余 + n_单个剩余;
                        End If;
                        n_合约剩余数量 := n_合约剩余数量 + n_单个剩余;
                      End If;
                    End If;
                  End If;
                End If;
              End Loop;
              If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                              To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                              n_时段剩余 || '</SL>' || '</SPAN>';
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
              End If;
            Else
              n_最大可用数量 := Nvl(r_No.限约数, Nvl(r_No.限号数, 0)) - Nvl(r_No.已约数, 0);
              n_时段总数     := 0;
              n_时段剩余     := 0;
              d_时段开始     := Null;
              d_时段结束     := Null;
              For r_Time In (Select Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约,
                                    Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 已约数,
                                    Ap.限制数量 - Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 剩余数,
                                    Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) As 失效时段
                             From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                    From 挂号安排 Ap, 挂号安排时段 Sd
                                    Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And Not Exists
                                     (Select 1
                                           From 挂号安排停用状态
                                           Where 安排id = Ap.Id And
                                                 To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' ||
                                                         To_Char(Sd.开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') Between
                                                 开始停止时间 And 结束停止时间) And
                                          Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                         '5', '周四', '6', '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                             Where Ap.号码 = Zt.号码(+) And Ap.开始时间 = Zt.日期(+)
                             Group By Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约
                             Order By Ap.序号) Loop
                If Nvl(n_时间间隔, 0) <> 0 Then
                  If d_时段开始 Is Null Then
                    d_时段开始 := r_Time.开始时间;
                    d_时段结束 := r_Time.开始时间 + n_时间间隔 / 24 / 60;
                    n_时段总数 := n_时段总数 + r_Time.限制数量;
                    If d_加号时间 < d_时段结束 Then
                      d_时段结束 := d_加号时间;
                    End If;
                  Else
                    If r_Time.开始时间 >= d_时段结束 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                    To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                    '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                      n_时段总数 := r_Time.限制数量;
                      n_时段剩余 := 0;
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := d_时段开始 + n_时间间隔 / 24 / 60;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      n_时段总数 := n_时段总数 + r_Time.限制数量;
                    End If;
                  End If;
                End If;
                If v_合作单位 Is Not Null Then
                  Select Nvl(Max(1), 0)
                  Into n_合约模式
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
                Else
                  n_合约模式 := 0;
                End If;
                n_单个剩余 := r_Time.剩余数;
                If v_合作单位 Is Null Or n_合约模式 = 1 Then
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And Rownum < 2;
                  If n_Exists = 0 And r_Time.失效时段 <> 1 Then
                    If n_最大可用数量 < n_单个剩余 Then
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_最大可用数量;
                      End If;
                      n_时段数量 := Nvl(n_时段数量, 0) + n_最大可用数量;
                    Else
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_单个剩余;
                      End If;
                      n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                    End If;
                  End If;
                Else
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                  Begin
                    Select 0
                    Into n_非合约
                    From 合作单位安排控制
                    Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_非合约 := 1;
                  End;
                  If (n_Exists = 1 Or n_非合约 = 1) And r_Time.失效时段 <> 1 Then
                    If n_最大可用数量 < n_单个剩余 Then
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_最大可用数量;
                      End If;
                      n_合约剩余数量 := n_合约剩余数量 + Nvl(n_最大可用数量, 0);
                    Else
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_单个剩余;
                      End If;
                      n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                    End If;
                  End If;
                End If;
              End Loop;
              If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                              To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                              n_时段剩余 || '</SL>' || '</SPAN>';
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
              End If;
            End If;
          End If;
        End If;
        If v_合作单位 Is Not Null Then
          If Nvl(r_No.计划id, 0) <> 0 Then
            Begin
              Select 0
              Into n_非合约
              From 合作单位计划控制
              Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
            Exception
              When Others Then
                n_非合约 := 1;
            End;
          Else
            Begin
              Select 0
              Into n_非合约
              From 合作单位安排控制
              Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
            Exception
              When Others Then
                n_非合约 := 1;
            End;
          End If;
        End If;
        If v_合作单位 Is Null Or n_非合约 = 1 Then
          If r_No.限号数 = 0 Then
            v_剩余数量 := '';
          Else
            If Nvl(r_No.计划id, 0) <> 0 Then
              Select Sum(数量)
              Into n_合约总数量
              From 合作单位计划控制
              Where 计划id = r_No.计划id And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null);
            Else
              Select Sum(数量)
              Into n_合约总数量
              From 合作单位安排控制
              Where 安排id = r_No.安排id And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null);
            End If;
            Select Count(1)
            Into n_合约已挂数
            From 病人挂号记录
            Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 Is Not Null And 发生时间 Between Trunc(d_日期) And
                  Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
            Select Count(1)
            Into n_预留数量
            From 挂号序号状态
            Where 状态 = 3 And 号码 = r_No.号码 And Trunc(日期) = Trunc(d_日期);
            If Trunc(d_日期) = Trunc(Sysdate) Then
              If Nvl(n_合约总数量, 0) = 0 Then
                v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_预留数量;
              Else
                v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_合约总数量 + n_合约已挂数 - n_预留数量;
              End If;
              n_已挂数 := r_No.已挂数;
              If Nvl(n_时段数量, 0) < v_剩余数量 And n_分时段 <> 0 Then
                n_缓冲序号 := 1;
                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_加号时间, 'hh24:mi:ss') || '-' || '</SJD>' ||
                              '<SL>' || To_Number(v_剩余数量 - Nvl(n_时段数量, 0) - Nvl(n_合约剩余数量, 0)) || '</SL>' || '</SPAN>';
              Else
                n_缓冲序号 := 0;
              End If;
            Else
              If Nvl(n_合约总数量, 0) = 0 Then
                v_剩余数量 := r_No.限约数 - r_No.已约数 - n_预留数量;
                If v_剩余数量 Is Null Then
                  v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_预留数量;
                End If;
              Else
                v_剩余数量 := r_No.限约数 - r_No.已约数 - n_合约总数量 + n_合约已挂数 - n_预留数量;
                If v_剩余数量 Is Null Then
                  v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_合约总数量 + n_合约已挂数 - n_预留数量;
                End If;
              End If;
              n_已挂数 := r_No.已挂数;
            End If;
          End If;
        Else
          If Nvl(r_No.计划id, 0) <> 0 Then
            If v_合作单位 Is Not Null Then
              Select Nvl(Max(1), 0)
              Into n_合约模式
              From 合作单位计划控制
              Where 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
            Else
              n_合约模式 := 0;
            End If;
            Select Sum(数量)
            Into n_合约总数量
            From 合作单位计划控制
            Where 计划id = r_No.计划id And 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                     '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
          Else
            If v_合作单位 Is Not Null Then
              Select Nvl(Max(1), 0)
              Into n_合约模式
              From 合作单位安排控制
              Where 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
            Else
              n_合约模式 := 0;
            End If;
            Select Sum(数量)
            Into n_合约总数量
            From 合作单位安排控制
            Where 安排id = r_No.安排id And 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                     '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
          End If;
          If n_合约模式 = 0 Then
            v_剩余数量   := n_合约剩余数量;
            n_已挂数     := r_No.已挂数;
            n_合约已挂数 := Nvl(n_合约总数量, 0) - n_合约剩余数量;
          Else
            n_已挂数 := r_No.已挂数;
            Select Count(1)
            Into n_合约已挂数
            From 病人挂号记录
            Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                  Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
            If Nvl(n_合约总数量, 0) = 0 Then
              v_剩余数量 := '0';
            Else
              v_剩余数量 := n_合约总数量 - n_合约已挂数;
            End If;
          End If;
        End If;
        Select To_Char(开始时间, 'hh24:mi') Into v_Timetemp From 时间段 Where 时间段 = r_No.排班;
        v_时间段 := v_Timetemp || '-';
        Select To_Char(终止时间, 'hh24:mi') Into v_Timetemp From 时间段 Where 时间段 = r_No.排班;
        v_时间段 := v_时间段 || v_Timetemp;
        If v_Temp Is Not Null Then
          v_Temp := v_Temp || '</SPANLIST>';
        End If;
        If v_合作单位 Is Not Null Then
          If Nvl(r_No.计划id, 0) <> 0 Then
            Select Nvl(Max(1), 0)
            Into n_禁用
            From 合作单位计划控制
            Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
          Else
            Select Nvl(Max(1), 0)
            Into n_禁用
            From 合作单位安排控制
            Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
          End If;
        End If;
        --限约数=0的预约禁止
        If Trunc(d_日期) <> Trunc(Sysdate) Then
          If r_No.限约数 = 0 Then
            n_禁用 := 1;
          End If;
        End If;
        If Nvl(n_禁用, 0) = 0 Then
          --从项金额计算
          n_合计金额 := r_No.价格;
          For r_Subfee In (Select 现价, 从项数次
                           From 收费从属项目 A, 收费价目 B
                           Where a.主项id = r_No.项目id And a.从项id = b.收费细目id And d_日期 Between b.执行日期 And
                                 Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And
                                 (b.价格等级 = v_普通等级 Or
                                 (b.价格等级 Is Null And Not Exists
                                  (Select 1
                                    From 收费价目
                                    Where 收费细目id = b.收费细目id And 价格等级 = v_普通等级 And d_日期 Between 执行日期 And
                                          Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')))))) Loop
            n_合计金额 := n_合计金额 + r_Subfee.现价 * r_Subfee.从项数次;
          End Loop;
          If Trunc(Sysdate) = Trunc(d_日期) Then
            Select Nvl(Max(1), 0)
            Into n_Exists
            From (Select 时间段
                   From 时间段
                   Where ('3000-01-10 ' || To_Char(Sysdate, 'HH24:MI:SS') < '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS')) Or
                         ('3000-01-10 ' || To_Char(Sysdate, 'HH24:MI:SS') <
                         Decode(Sign(开始时间 - 终止时间), 1, '3000-01-11 ' || To_Char(终止时间, 'HH24:MI:SS'),
                                 '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS'))))
            Where 时间段 = r_No.排班;
          Else
            n_Exists := 1;
          End If;
          If n_Exists = 1 Then
            If v_剩余数量 > 0 Then
              c_Xmlmain := '<HB>' || '<APID>' || r_No.安排id || '</APID>' || '<JHID>' || r_No.计划id || '</JHID>' || '<HM>' ||
                           r_No.号码 || '</HM>' || '<YSID>' || r_No.医生id || '</YSID>' || '<YS>' || r_No.医生姓名 || '</YS>' ||
                           '<KSID>' || r_No.科室id || '</KSID>' || '<KSMC>' || r_No.科室名称 || '</KSMC>' || '<ZC>' ||
                           r_No.职称 || '</ZC>' || '<XMID>' || r_No.项目id || '</XMID>' || '<XMMC>' || r_No.项目名称 ||
                           '</XMMC>' || '<YGHS>' || n_已挂数 || '</YGHS>' || '<SYHS>' || v_剩余数量 || '</SYHS>' || '<PRICE>' ||
                           n_合计金额 || '</PRICE>' || '<HCXH>' || n_缓冲序号 || '</HCXH>' || '<HL>' || r_No.号类 || '</HL>' ||
                           '<FSD>' || n_分时段 || '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' || '<FWMC>' || r_No.排班 ||
                           '</FWMC>' || v_Temp || '</HB>';
            Else
              c_Xmlmain := '<HB>' || '<APID>' || r_No.安排id || '</APID>' || '<JHID>' || r_No.计划id || '</JHID>' || '<HM>' ||
                           r_No.号码 || '</HM>' || '<YSID>' || r_No.医生id || '</YSID>' || '<YS>' || r_No.医生姓名 || '</YS>' ||
                           '<KSID>' || r_No.科室id || '</KSID>' || '<KSMC>' || r_No.科室名称 || '</KSMC>' || '<ZC>' ||
                           r_No.职称 || '</ZC>' || '<XMID>' || r_No.项目id || '</XMID>' || '<XMMC>' || r_No.项目名称 ||
                           '</XMMC>' || '<YGHS>' || n_已挂数 || '</YGHS>' || '<SYHS>' || v_剩余数量 || '</SYHS>' || '<PRICE>' ||
                           n_合计金额 || '</PRICE>' || '<HL>' || r_No.号类 || '</HL>' || '<FSD>' || n_分时段 || '</FSD>' ||
                           '<HBTIME>' || v_时间段 || '</HBTIME>' || '<FWMC>' || r_No.排班 || '</FWMC>' || '</HB>';
            End If;
            v_Xmlmain := v_Xmlmain || c_Xmlmain;
          End If;
        End If;
      End If;
      n_合约剩余数量 := 0;
      n_合约总数量   := 0;
      n_时段数量     := 0;
      n_禁用         := 0;
      n_非合约       := 0;
    End Loop;
  
    v_Xmlmain := '<GROUP>' || '<RQ>' || To_Char(d_日期, 'yyyy-mm-dd') || '</RQ>' || '<HBLIST>' || v_Xmlmain ||
                 '</HBLIST>' || '</GROUP>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Xmlmain)) Into x_Templet From Dual;
    Xml_Out := x_Templet;
    Return;
  End If;

  --===========================================================================================
  --出诊表排班模式 
  --===========================================================================================
  n_合约剩余数量 := 0;
  n_补充天数     := Zl_Fun_Getappointmentdays;
  --注意出诊记录停用了，但可能启用了部分时段
  --临床出诊序号控制 中，开始时间与终止时间相等的是加号的序号
  --记录性质：1-正常出诊记录,2-替诊出诊记录
  For r_No In (Select a.记录性质, a.记录id, a.号源id, b.号类, b.号码, a.科室id, c.名称 As 科室名称, a.项目id, e.名称 As 项目名称, a.医生id, a.医生姓名,
                      d.专业技术职务 As 职称, a.排班, a.开始时间, a.终止时间, a.序号控制, a.分时段, a.预约控制, a.限号数, a.限约数, a.已挂数, a.已约数, a.已接收,
                      a.替诊开始时间, a.替诊终止时间, a.停诊开始时间, a.停诊终止时间, Nvl(b.预约天数, n_预约天数) + n_补充天数 As 预约天数
               From (Select 1 As 记录性质, a.Id As 记录id, a.号源id, a.科室id, a.项目id, a.医生id, a.医生姓名, a.上班时段 As 排班, a.开始时间, a.终止时间,
                             Nvl(a.是否序号控制, 0) As 序号控制, Nvl(a.是否分时段, 0) As 分时段, a.预约控制, a.限号数, Nvl(a.限约数, a.限号数) As 限约数,
                             Nvl(a.已挂数, 0) As 已挂数, Nvl(a.已约数, 0) As 已约数, Nvl(a.其中已接收, 0) As 已接收, a.替诊开始时间, a.替诊终止时间,
                             a.停诊开始时间, a.停诊终止时间
                      From 临床出诊记录 A
                      Where Nvl(a.是否发布, 0) = 1 And Nvl(a.是否锁定, 0) = 0 And
                            (a.开始时间 < Nvl(a.替诊开始时间, a.终止时间) Or a.终止时间 > Nvl(a.替诊终止时间, a.开始时间)) And a.开始时间 > Trunc(d_启用时间) And
                            a.终止时间 > Sysdate And
                            (a.开始时间 < Nvl(a.停诊开始时间, a.终止时间) And Nvl(a.停诊开始时间, a.终止时间) > Sysdate Or
                             a.终止时间 > Nvl(a.停诊终止时间, a.开始时间) And a.终止时间 > Sysdate Or Exists
                             (Select 1
                              From 临床出诊序号控制
                              Where 记录id = a.Id And Nvl(是否停诊, 0) = 0 And Nvl(a.是否序号控制, 0) = 1 And Nvl(a.是否分时段, 0) = 1 And
                                    开始时间 <> 终止时间 And 开始时间 >= Sysdate)) And
                            Decode(Nvl(n_医生id, 0), 0, 0, a.医生id) = Nvl(n_医生id, 0) And
                            Decode(Nvl(v_医生姓名, '-'), '-', '-', a.医生姓名) = Nvl(v_医生姓名, '-') And
                            Decode(Nvl(n_科室id, 0), 0, 0, a.科室id) = Nvl(n_科室id, 0) And a.出诊日期 = Trunc(d_日期)
                      Union All
                      Select 2 As 记录性质, a.Id As 记录id, a.号源id, a.科室id, a.项目id, a.替诊医生id As 医生id, a.替诊医生姓名 As 医生姓名,
                             a.上班时段 As 排班, a.开始时间, a.终止时间, Nvl(a.是否序号控制, 0) As 序号控制, Nvl(a.是否分时段, 0) As 分时段, a.预约控制, a.限号数,
                             Nvl(a.限约数, a.限号数) As 限约数, Nvl(a.已挂数, 0) As 已挂数, Nvl(a.已约数, 0) As 已约数, Nvl(a.其中已接收, 0) As 已接收,
                             a.替诊开始时间, a.替诊终止时间, a.停诊开始时间, a.停诊终止时间
                      From 临床出诊记录 A
                      Where Nvl(a.是否发布, 0) = 1 And Nvl(a.是否锁定, 0) = 0 And a.开始时间 > Trunc(d_启用时间) And a.终止时间 > Sysdate And
                            (a.开始时间 < Nvl(a.停诊开始时间, a.终止时间) And Nvl(a.停诊开始时间, a.终止时间) > Sysdate Or
                             a.终止时间 > Nvl(a.停诊终止时间, a.开始时间) And a.终止时间 > Sysdate Or Exists
                             (Select 1
                              From 临床出诊序号控制
                              Where 记录id = a.Id And Nvl(是否停诊, 0) = 0 And Nvl(a.是否序号控制, 0) = 1 And Nvl(a.是否分时段, 0) = 1 And
                                    开始时间 <> 终止时间 And 开始时间 >= Sysdate)) And
                            Decode(Nvl(n_医生id, 0), 0, 0, a.替诊医生id) = Nvl(n_医生id, 0) And
                            Decode(Nvl(v_医生姓名, '-'), '-', '-', a.替诊医生姓名) = Nvl(v_医生姓名, '-') And
                            Decode(Nvl(n_科室id, 0), 0, 0, a.科室id) = Nvl(n_科室id, 0) And a.替诊医生姓名 Is Not Null And
                            a.出诊日期 = Trunc(d_日期)) A, 临床出诊号源 B, 部门表 C, 人员表 D, 收费项目目录 E
               Where a.号源id = b.Id And a.科室id = c.Id And a.项目id = e.Id And a.医生id = d.Id(+)) Loop
  
    Zl_挂号序号状态_出诊_Delete(r_No.记录id);
    v_Temp := '';
    n_禁用 := 0;
    If Sysdate + Nvl(r_No.预约天数, n_预约天数) + n_补充天数 >= d_日期 Then
      If Trunc(d_日期) = Trunc(Sysdate) Then
        --当日
        If v_合作单位 Is Null Then
          --未传入合作单位
          n_已挂数   := r_No.已挂数;
          v_剩余数量 := r_No.限号数 - Nvl(r_No.已挂数, 0) - (Nvl(r_No.已约数, 0) - Nvl(r_No.已接收, 0));
          If r_No.分时段 = 1 And r_No.序号控制 = 1 Then
            v_Temp     := '<SPANLIST>';
            n_Exists   := 0;
            n_时段总数 := 0;
            n_时段剩余 := 0;
            d_时段开始 := Null;
            d_时段结束 := Null;
            Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
            For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                           From 临床出诊序号控制
                           Where 记录id = r_No.记录id And (r_No.记录性质 = 1 And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                                 Nvl(r_No.替诊终止时间, Sysdate - 1) Or
                                 r_No.记录性质 = 2 And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And
                                 Nvl(r_No.替诊终止时间, Sysdate - 1)) And Nvl(是否停诊, 0) = 0) Loop
              If r_Time.开始时间 > Sysdate Then
                If Nvl(n_时间间隔, 0) = 0 Then
                  If Nvl(r_Time.挂号状态, 0) = 0 Then
                    n_时段剩余 := 1;
                    n_Exists   := n_Exists + 1;
                  Else
                    n_时段剩余 := 0;
                  End If;
                  v_Temp := v_Temp || Gettimexml(r_Time.开始时间, r_Time.终止时间, 1, n_时段剩余);
                Else
                  If d_时段开始 Is Null Then
                    n_时段总数 := 1;
                    n_时段剩余 := 0;
                    d_时段开始 := r_Time.开始时间;
                    d_时段结束 := r_Time.开始时间 + n_时间间隔 / 24 / 60;
                    If d_加号时间 < d_时段结束 Then
                      d_时段结束 := d_加号时间;
                    End If;
                  Else
                    If r_Time.开始时间 >= d_时段结束 Then
                      v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                    
                      n_时段总数 := 1;
                      n_时段剩余 := 0;
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := d_时段开始 + n_时间间隔 / 24 / 60;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      n_时段总数 := n_时段总数 + 1;
                    End If;
                  End If;
                
                  If Nvl(r_Time.挂号状态, 0) = 0 Then
                    n_时段剩余 := n_时段剩余 + 1;
                    n_Exists   := n_Exists + 1;
                  End If;
                End If;
              End If;
            End Loop;
          
            If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
              v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
            End If;
          
            If r_No.记录性质 = 1 And n_Exists < To_Number(v_剩余数量) Then
              v_Temp := v_Temp || Gettimexml(d_加号时间, '', v_剩余数量, To_Number(v_剩余数量) - n_Exists);
            End If;
            v_Temp := v_Temp || '</SPANLIST>';
          End If;
        Else
          --传入合作单位
          n_已挂数 := r_No.已挂数;
          Begin
            Select 控制方式
            Into n_合约模式
            From 临床出诊挂号控制记录
            Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位 And Rownum < 2;
          Exception
            When Others Then
              n_合约模式 := 4;
          End;
        
          If n_合约模式 = 0 Then
            n_禁用 := 1;
          Elsif n_合约模式 = 1 Or n_合约模式 = 2 Then
            Select 数量
            Into n_合约总数量
            From 临床出诊挂号控制记录
            Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位;
            If n_合约模式 = 1 Then
              n_合约总数量 := Floor(r_No.限约数 * n_合约总数量 / 100);
            End If;
          
            Select Count(1)
            Into n_合约已挂数
            From 病人挂号记录
            Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                  Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
            n_合约剩余数量 := n_合约总数量 - n_合约已挂数;
          
            If r_No.限号数 - Nvl(r_No.已挂数, 0) < n_合约剩余数量 Then
              v_剩余数量 := r_No.限号数 - Nvl(r_No.已挂数, 0);
            Else
              v_剩余数量 := n_合约剩余数量;
            End If;
          
            If r_No.分时段 = 1 And r_No.序号控制 = 1 Then
              v_Temp     := '<SPANLIST>';
              n_Exists   := 0;
              n_时段总数 := 0;
              n_时段剩余 := 0;
              d_时段开始 := Null;
              d_时段结束 := Null;
              Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
              For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                             From 临床出诊序号控制
                             Where 记录id = r_No.记录id And (r_No.记录性质 = 1 And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                                   Nvl(r_No.替诊终止时间, Sysdate - 1) Or
                                   r_No.记录性质 = 2 And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And
                                   Nvl(r_No.替诊终止时间, Sysdate - 1)) And Nvl(是否停诊, 0) = 0) Loop
              
                If r_Time.开始时间 > Sysdate Then
                  If Nvl(n_时间间隔, 0) = 0 Then
                    If Nvl(r_Time.挂号状态, 0) = 0 Then
                      n_时段剩余 := 1;
                      n_Exists   := n_Exists + 1;
                    Else
                      n_时段剩余 := 0;
                    End If;
                    v_Temp := v_Temp || Gettimexml(r_Time.开始时间, r_Time.终止时间, 1, n_时段剩余);
                  Else
                    If d_时段开始 Is Null Then
                      n_时段总数 := 1;
                      n_时段剩余 := 0;
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := r_Time.开始时间 + n_时间间隔 / 24 / 60;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      If r_Time.开始时间 >= d_时段结束 Then
                        v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                      
                        n_时段总数 := 1;
                        n_时段剩余 := 0;
                        d_时段开始 := r_Time.开始时间;
                        d_时段结束 := d_时段开始 + n_时间间隔 / 24 / 60;
                        If d_加号时间 < d_时段结束 Then
                          d_时段结束 := d_加号时间;
                        End If;
                      Else
                        n_时段总数 := n_时段总数 + 1;
                      End If;
                    End If;
                  
                    If Nvl(r_Time.挂号状态, 0) = 0 Then
                      n_时段剩余 := n_时段剩余 + 1;
                      n_Exists   := n_Exists + 1;
                    End If;
                  End If;
                End If;
              End Loop;
            
              If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
              End If;
            
              If r_No.记录性质 = 1 And n_Exists < To_Number(v_剩余数量) Then
                v_Temp := v_Temp || Gettimexml(d_加号时间, '', v_剩余数量, To_Number(v_剩余数量) - n_Exists);
              End If;
              v_Temp := v_Temp || '</SPANLIST>';
            End If;
          Elsif n_合约模式 = 3 Then
            If r_No.序号控制 = 0 Then
              n_已挂数   := r_No.已挂数;
              v_剩余数量 := r_No.限号数 - Nvl(r_No.已挂数, 0) - (Nvl(r_No.已约数, 0) - Nvl(r_No.已接收, 0));
            Else
              v_Temp     := '<SPANLIST>';
              n_已挂数   := 0;
              v_剩余数量 := 0;
              n_时段总数 := 0;
              n_时段剩余 := 0;
              d_时段开始 := Null;
              d_时段结束 := Null;
              For r_合作 In (Select 序号
                           From 临床出诊挂号控制记录
                           Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位) Loop
              
                Begin
                  Select 1, 开始时间, 终止时间
                  Into n_Exists, d_开始时间, d_终止时间
                  From 临床出诊序号控制
                  Where 记录id = r_No.记录id And 序号 = r_合作.序号 And Nvl(挂号状态, 0) = 0 And
                        (r_No.记录性质 = 1 And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) Or
                        r_No.记录性质 = 2 And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1)) And
                        Nvl(是否停诊, 0) = 0;
                Exception
                  When Others Then
                    n_Exists := 0;
                End;
              
                If n_Exists = 1 Then
                  v_剩余数量 := v_剩余数量 + 1;
                Else
                  n_已挂数 := n_已挂数 + 1;
                End If;
              
                If d_开始时间 > Sysdate Then
                  If Nvl(n_时间间隔, 0) = 0 Then
                    If n_Exists = 1 Then
                      n_时段剩余 := 1;
                    Else
                      n_时段剩余 := 0;
                    End If;
                    v_Temp := v_Temp || Gettimexml(d_开始时间, d_终止时间, 1, n_时段剩余);
                  Else
                    If d_时段开始 Is Null Then
                      n_时段总数 := 1;
                      n_时段剩余 := 0;
                      d_时段开始 := d_开始时间;
                      d_时段结束 := d_开始时间 + n_时间间隔 / 24 / 60;
                    Else
                      If d_开始时间 >= d_时段结束 Then
                        v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                      
                        n_时段总数 := 1;
                        n_时段剩余 := 0;
                        d_时段开始 := d_开始时间;
                        d_时段结束 := d_时段开始 + n_时间间隔 / 24 / 60;
                      Else
                        n_时段总数 := n_时段总数 + 1;
                      End If;
                    End If;
                  
                    If n_Exists = 1 Then
                      n_时段剩余 := n_时段剩余 + 1;
                    End If;
                  End If;
                End If;
              End Loop;
            
              If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
              End If;
              v_Temp := v_Temp || '</SPANLIST>';
            End If;
          Elsif n_合约模式 = 4 Then
            n_已挂数   := r_No.已挂数;
            v_剩余数量 := r_No.限号数 - Nvl(r_No.已挂数, 0) - (Nvl(r_No.已约数, 0) - Nvl(r_No.已接收, 0));
            If r_No.分时段 = 1 And r_No.序号控制 = 1 Then
              v_Temp     := '<SPANLIST>';
              n_Exists   := 0;
              n_时段总数 := 0;
              n_时段剩余 := 0;
              d_时段开始 := Null;
              d_时段结束 := Null;
              Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
              For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                             From 临床出诊序号控制
                             Where 记录id = r_No.记录id And (r_No.记录性质 = 1 And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                                   Nvl(r_No.替诊终止时间, Sysdate - 1) Or
                                   r_No.记录性质 = 2 And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And
                                   Nvl(r_No.替诊终止时间, Sysdate - 1)) And Nvl(是否停诊, 0) = 0) Loop
              
                If r_Time.开始时间 > Sysdate Then
                  If Nvl(n_时间间隔, 0) = 0 Then
                    If Nvl(r_Time.挂号状态, 0) = 0 Then
                      n_时段剩余 := 1;
                      n_Exists   := n_Exists + 1;
                    Else
                      n_时段剩余 := 0;
                    End If;
                    v_Temp := v_Temp || Gettimexml(r_Time.开始时间, r_Time.终止时间, 1, n_时段剩余);
                  Else
                    If d_时段开始 Is Null Then
                      n_时段总数 := 1;
                      n_时段剩余 := 0;
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := r_Time.开始时间 + n_时间间隔 / 24 / 60;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      If r_Time.开始时间 >= d_时段结束 Then
                        v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                      
                        n_时段总数 := 1;
                        n_时段剩余 := 0;
                        d_时段开始 := r_Time.开始时间;
                        d_时段结束 := d_时段开始 + n_时间间隔 / 24 / 60;
                        If d_加号时间 < d_时段结束 Then
                          d_时段结束 := d_加号时间;
                        End If;
                      Else
                        n_时段总数 := n_时段总数 + 1;
                      End If;
                    End If;
                  
                    If Nvl(r_Time.挂号状态, 0) = 0 Then
                      n_时段剩余 := n_时段剩余 + 1;
                      n_Exists   := n_Exists + 1;
                    End If;
                  End If;
                End If;
              End Loop;
            
              If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
              End If;
            
              If r_No.记录性质 = 1 And n_Exists < To_Number(v_剩余数量) Then
                v_Temp := v_Temp || Gettimexml(d_加号时间, '', v_剩余数量, To_Number(v_剩余数量) - n_Exists);
              End If;
              v_Temp := v_Temp || '</SPANLIST>';
            End If;
          End If;
        End If;
      Else
        --预约挂号
        If r_No.预约控制 = 1 Then
          n_禁用 := 1;
        Else
          --不限制预约
          If v_合作单位 Is Null Then
            If r_No.分时段 = 0 Then
              n_已挂数   := r_No.已约数;
              v_剩余数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
            Else
              --分时段
              v_Temp     := '<SPANLIST>';
              n_已挂数   := 0;
              v_剩余数量 := 0;
              n_时段总数 := 0;
              n_时段剩余 := 0;
              d_时段开始 := Null;
              d_时段结束 := Null;
              Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
              If r_No.序号控制 = 0 Then
                --非序号控制分时段预约
                For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态, 数量
                               From 临床出诊序号控制
                               Where 记录id = r_No.记录id And 预约顺序号 Is Null And 是否预约 = 1 And
                                     (r_No.记录性质 = 1 And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                                     Nvl(r_No.替诊终止时间, Sysdate - 1) Or
                                     r_No.记录性质 = 2 And 开始时间 Between Nvl(r_No.停诊开始时间, Sysdate) And
                                     Nvl(r_No.停诊终止时间, Sysdate - 1))) Loop
                
                  Select Count(1)
                  Into n_时段已挂
                  From 临床出诊序号控制
                  Where 记录id = r_No.记录id And 序号 = r_Time.序号 And 预约顺序号 Is Not Null And Nvl(挂号状态, 0) <> 0;
                
                  n_已挂数   := n_已挂数 + n_时段已挂;
                  v_剩余数量 := v_剩余数量 + (r_Time.数量 - n_时段已挂);
                
                  If r_Time.开始时间 > Sysdate Then
                    If Nvl(n_时间间隔, 0) = 0 Then
                      n_时段剩余 := r_Time.数量 - n_时段已挂;
                      v_Temp     := v_Temp || Gettimexml(r_Time.开始时间, r_Time.终止时间, r_Time.数量, n_时段剩余);
                    Else
                      If d_时段开始 Is Null Then
                        n_时段总数 := r_Time.数量;
                        n_时段剩余 := 0;
                        d_时段开始 := r_Time.开始时间;
                        d_时段结束 := r_Time.开始时间 + n_时间间隔 / 24 / 60;
                        If d_加号时间 < d_时段结束 Then
                          d_时段结束 := d_加号时间;
                        End If;
                      Else
                        If r_Time.开始时间 >= d_时段结束 Then
                          v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                        
                          n_时段总数 := r_Time.数量;
                          n_时段剩余 := 0;
                          d_时段开始 := r_Time.开始时间;
                          d_时段结束 := d_时段开始 + n_时间间隔 / 24 / 60;
                          If d_加号时间 < d_时段结束 Then
                            d_时段结束 := d_加号时间;
                          End If;
                        Else
                          n_时段总数 := n_时段总数 + r_Time.数量;
                        End If;
                      End If;
                    
                      n_时段剩余 := n_时段剩余 + r_Time.数量 - n_时段已挂;
                    End If;
                  End If;
                End Loop;
              
                If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                  v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                End If;
              Else
                --序号控制分时段预约
                For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                               From 临床出诊序号控制
                               Where 记录id = r_No.记录id And 是否预约 = 1 And
                                     (r_No.记录性质 = 1 And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                                     Nvl(r_No.替诊终止时间, Sysdate - 1) Or
                                     r_No.记录性质 = 2 And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And
                                     Nvl(r_No.替诊终止时间, Sysdate - 1)) And Nvl(是否停诊, 0) = 0) Loop
                
                  If Nvl(r_Time.挂号状态, 0) = 0 Then
                    v_剩余数量 := v_剩余数量 + 1;
                  Else
                    n_已挂数 := n_已挂数 + 1;
                  End If;
                
                  If r_Time.开始时间 > Sysdate Then
                    If Nvl(n_时间间隔, 0) = 0 Then
                      If Nvl(r_Time.挂号状态, 0) = 0 Then
                        n_时段剩余 := 1;
                      Else
                        n_时段剩余 := 0;
                      End If;
                      v_Temp := v_Temp || Gettimexml(r_Time.开始时间, r_Time.终止时间, 1, n_时段剩余);
                    Else
                      If d_时段开始 Is Null Then
                        n_时段总数 := 1;
                        n_时段剩余 := 0;
                        d_时段开始 := r_Time.开始时间;
                        d_时段结束 := r_Time.开始时间 + n_时间间隔 / 24 / 60;
                        If d_加号时间 < d_时段结束 Then
                          d_时段结束 := d_加号时间;
                        End If;
                      Else
                        If r_Time.开始时间 >= d_时段结束 Then
                          v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                        
                          n_时段总数 := 1;
                          n_时段剩余 := 0;
                          d_时段开始 := r_Time.开始时间;
                          d_时段结束 := d_时段开始 + n_时间间隔 / 24 / 60;
                          If d_加号时间 < d_时段结束 Then
                            d_时段结束 := d_加号时间;
                          End If;
                        Else
                          n_时段总数 := n_时段总数 + 1;
                        End If;
                      End If;
                    
                      If Nvl(r_Time.挂号状态, 0) = 0 Then
                        n_时段剩余 := n_时段剩余 + 1;
                      End If;
                    End If;
                  End If;
                End Loop;
              
                If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                  v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                End If;
              End If;
              v_Temp := v_Temp || '</SPANLIST>';
            End If;
          Else
            --合作单位预约挂号
            If r_No.预约控制 = 2 Then
              n_禁用 := 1;
            Else
              Begin
                Select 控制方式
                Into n_合约模式
                From 临床出诊挂号控制记录
                Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位 And Rownum < 2;
              Exception
                When Others Then
                  n_合约模式 := 4;
              End;
            
              If n_合约模式 = 0 Then
                n_禁用 := 1;
              Elsif n_合约模式 = 1 Or n_合约模式 = 2 Then
                Select 数量
                Into n_合约总数量
                From 临床出诊挂号控制记录
                Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位;
                If n_合约模式 = 1 Then
                  n_合约总数量 := Floor(r_No.限约数 * n_合约总数量 / 100);
                End If;
              
                Select Count(1)
                Into n_合约已挂数
                From 病人挂号记录
                Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                      Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
              
                n_合约剩余数量 := n_合约总数量 - n_合约已挂数;
              
                If Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0) < n_合约剩余数量 Then
                  v_剩余数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
                Else
                  v_剩余数量 := n_合约剩余数量;
                End If;
                n_已挂数 := r_No.已约数;
              
                If r_No.分时段 = 1 Then
                  v_Temp     := '<SPANLIST>';
                  n_Exists   := 0;
                  n_时段总数 := 0;
                  n_时段剩余 := 0;
                  d_时段开始 := Null;
                  d_时段结束 := Null;
                  Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                  If r_No.序号控制 = 1 Then
                    --分时段,序号控制
                    For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                                   From 临床出诊序号控制
                                   Where 记录id = r_No.记录id And 是否预约 = 1 And
                                         (r_No.记录性质 = 1 And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                                         Nvl(r_No.替诊终止时间, Sysdate - 1) Or
                                         r_No.记录性质 = 2 And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And
                                         Nvl(r_No.替诊终止时间, Sysdate - 1)) And Nvl(是否停诊, 0) = 0) Loop
                    
                      If r_Time.开始时间 > Sysdate Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          If Nvl(r_Time.挂号状态, 0) = 0 Then
                            n_时段剩余 := 1;
                            n_Exists   := n_Exists + 1;
                          Else
                            n_时段剩余 := 0;
                          End If;
                          v_Temp := v_Temp || Gettimexml(r_Time.开始时间, r_Time.终止时间, 1, n_时段剩余);
                        Else
                          If d_时段开始 Is Null Then
                            n_时段总数 := 1;
                            n_时段剩余 := 0;
                            d_时段开始 := r_Time.开始时间;
                            d_时段结束 := r_Time.开始时间 + n_时间间隔 / 24 / 60;
                            If d_加号时间 < d_时段结束 Then
                              d_时段结束 := d_加号时间;
                            End If;
                          Else
                            If r_Time.开始时间 >= d_时段结束 Then
                              v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                            
                              n_时段总数 := 1;
                              n_时段剩余 := 0;
                              d_时段开始 := r_Time.开始时间;
                              d_时段结束 := d_时段开始 + n_时间间隔 / 24 / 60;
                              If d_加号时间 < d_时段结束 Then
                                d_时段结束 := d_加号时间;
                              End If;
                            Else
                              n_时段总数 := n_时段总数 + 1;
                            End If;
                          End If;
                        
                          If Nvl(r_Time.挂号状态, 0) = 0 Then
                            n_时段剩余 := 1;
                            n_Exists   := n_Exists + 1;
                          End If;
                        End If;
                      End If;
                    End Loop;
                  
                    If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                      v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                    End If;
                  
                    If n_Exists < To_Number(v_剩余数量) Then
                      v_剩余数量 := n_Exists;
                    End If;
                  Else
                    --分时段,非序号控制
                    For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态, 数量
                                   From 临床出诊序号控制
                                   Where 记录id = r_No.记录id And 预约顺序号 Is Null And 是否预约 = 1 And
                                         (r_No.记录性质 = 1 And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                                         Nvl(r_No.替诊终止时间, Sysdate - 1) Or
                                         r_No.记录性质 = 2 And 开始时间 Between Nvl(r_No.停诊开始时间, Sysdate) And
                                         Nvl(r_No.停诊终止时间, Sysdate - 1))) Loop
                    
                      Select Count(1)
                      Into n_时段已挂
                      From 临床出诊序号控制
                      Where 记录id = r_No.记录id And 序号 = r_Time.序号 And 预约顺序号 Is Not Null And Nvl(挂号状态, 0) <> 0;
                    
                      If r_Time.开始时间 > Sysdate Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          n_时段剩余 := r_Time.数量 - n_时段已挂;
                          n_Exists   := n_Exists + n_时段剩余;
                          v_Temp     := v_Temp || Gettimexml(r_Time.开始时间, r_Time.终止时间, r_Time.数量, n_时段剩余);
                        Else
                          If d_时段开始 Is Null Then
                            n_时段总数 := r_Time.数量;
                            n_时段剩余 := 0;
                            d_时段开始 := r_Time.开始时间;
                            d_时段结束 := r_Time.开始时间 + n_时间间隔 / 24 / 60;
                            If d_加号时间 < d_时段结束 Then
                              d_时段结束 := d_加号时间;
                            End If;
                          Else
                            If r_Time.开始时间 >= d_时段结束 Then
                              v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                            
                              n_时段总数 := r_Time.数量;
                              n_时段剩余 := 0;
                              d_时段开始 := r_Time.开始时间;
                              d_时段结束 := d_时段开始 + n_时间间隔 / 24 / 60;
                              If d_加号时间 < d_时段结束 Then
                                d_时段结束 := d_加号时间;
                              End If;
                            Else
                              n_时段总数 := n_时段总数 + r_Time.数量;
                            End If;
                          End If;
                        
                          n_时段剩余 := n_时段剩余 + (r_Time.数量 - n_时段已挂);
                          n_Exists   := n_Exists + (r_Time.数量 - n_时段已挂);
                        End If;
                      End If;
                    End Loop;
                  
                    If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                      v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                    End If;
                  
                    If n_Exists < To_Number(v_剩余数量) Then
                      v_剩余数量 := n_Exists;
                    End If;
                  End If;
                  v_Temp := v_Temp || '</SPANLIST>';
                End If;
              Elsif n_合约模式 = 3 Then
                If r_No.分时段 = 0 Then
                  If r_No.序号控制 = 0 Then
                    n_禁用 := 1;
                  Else
                    --序号控制不分时段
                    n_已挂数   := 0;
                    v_剩余数量 := 0;
                    For r_合作 In (Select 序号
                                 From 临床出诊挂号控制记录
                                 Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位) Loop
                    
                      Select Count(1)
                      Into n_Exists
                      From 临床出诊序号控制
                      Where 记录id = r_No.记录id And 序号 = r_合作.序号 And 是否预约 = 1 And Nvl(挂号状态, 0) = 0 And
                            (r_No.记录性质 = 1 And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                            Nvl(r_No.替诊终止时间, Sysdate - 1) Or
                            r_No.记录性质 = 2 And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1)) And
                            Nvl(是否停诊, 0) = 0;
                    
                      If n_Exists = 1 Then
                        v_剩余数量 := v_剩余数量 + 1;
                      Else
                        n_已挂数 := n_已挂数 + 1;
                      End If;
                    End Loop;
                  
                    If Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0) < v_剩余数量 Then
                      v_剩余数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
                    End If;
                  End If;
                Else
                  v_Temp     := '<SPANLIST>';
                  n_已挂数   := 0;
                  v_剩余数量 := 0;
                  n_时段总数 := 0;
                  n_时段剩余 := 0;
                  d_时段开始 := Null;
                  d_时段结束 := Null;
                  Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                  If r_No.序号控制 = 0 Then
                    --分时段,非序号控制
                    For r_合作 In (Select 序号, 数量
                                 From 临床出诊挂号控制记录
                                 Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位) Loop
                    
                      Select Count(1), Max(开始时间), Max(终止时间)
                      Into n_时段已挂, d_开始时间, d_终止时间
                      From 临床出诊序号控制
                      Where 记录id = r_No.记录id And 序号 = r_合作.序号 And 预约顺序号 Is Not Null And Nvl(挂号状态, 0) <> 0 And
                            (r_No.记录性质 = 1 And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                            Nvl(r_No.替诊终止时间, Sysdate - 1) Or
                            r_No.记录性质 = 2 And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1));
                    
                      n_已挂数   := n_已挂数 + n_时段已挂;
                      v_剩余数量 := v_剩余数量 + r_合作.数量 - n_时段已挂;
                    
                      If d_开始时间 > Sysdate Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          n_时段剩余 := r_合作.数量 - n_时段已挂;
                          v_Temp     := v_Temp || Gettimexml(d_开始时间, d_终止时间, r_合作.数量, n_时段剩余);
                        Else
                          If d_时段开始 Is Null Then
                            n_时段总数 := r_合作.数量;
                            n_时段剩余 := 0;
                            d_时段开始 := d_开始时间;
                            d_时段结束 := d_开始时间 + n_时间间隔 / 24 / 60;
                            If d_加号时间 < d_时段结束 Then
                              d_时段结束 := d_加号时间;
                            End If;
                          Else
                            If d_开始时间 >= d_时段结束 Then
                              v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                            
                              n_时段总数 := r_合作.数量;
                              n_时段剩余 := 0;
                              d_时段开始 := d_开始时间;
                              d_时段结束 := d_时段开始 + n_时间间隔 / 24 / 60;
                              If d_加号时间 < d_时段结束 Then
                                d_时段结束 := d_加号时间;
                              End If;
                            Else
                              n_时段总数 := n_时段总数 + r_合作.数量;
                            End If;
                          End If;
                        
                          n_时段剩余 := n_时段剩余 + r_合作.数量 - n_时段已挂;
                        End If;
                      End If;
                    End Loop;
                  
                    If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                      v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                    End If;
                  Else
                    --分时段,序号控制
                    For r_合作 In (Select 序号
                                 From 临床出诊挂号控制记录
                                 Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位) Loop
                    
                      Select Max(1), Max(开始时间), Max(终止时间)
                      Into n_Exists, d_开始时间, d_终止时间
                      From 临床出诊序号控制
                      Where 记录id = r_No.记录id And 序号 = r_合作.序号 And Nvl(挂号状态, 0) = 0 And
                            (r_No.记录性质 = 1 And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                            Nvl(r_No.替诊终止时间, Sysdate - 1) Or
                            r_No.记录性质 = 2 And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1)) And
                            Nvl(是否停诊, 0) = 0;
                    
                      If n_Exists = 1 Then
                        v_剩余数量 := v_剩余数量 + 1;
                      Else
                        n_已挂数 := n_已挂数 + 1;
                      End If;
                    
                      If d_开始时间 > Sysdate Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          If n_Exists = 1 Then
                            n_时段剩余 := 1;
                          Else
                            n_时段剩余 := 0;
                          End If;
                          v_Temp := v_Temp || Gettimexml(d_开始时间, d_终止时间, 1, n_时段剩余);
                        Else
                          If d_时段开始 Is Null Then
                            n_时段总数 := 1;
                            n_时段剩余 := 0;
                            d_时段开始 := d_开始时间;
                            d_时段结束 := d_开始时间 + n_时间间隔 / 24 / 60;
                            If d_加号时间 < d_时段结束 Then
                              d_时段结束 := d_加号时间;
                            End If;
                          Else
                            If d_开始时间 >= d_时段结束 Then
                              v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                            
                              n_时段总数 := 1;
                              n_时段剩余 := 0;
                              d_时段开始 := d_开始时间;
                              d_时段结束 := d_时段开始 + n_时间间隔 / 24 / 60;
                              If d_加号时间 < d_时段结束 Then
                                d_时段结束 := d_加号时间;
                              End If;
                            Else
                              n_时段总数 := n_时段总数 + 1;
                            End If;
                          End If;
                        
                          If n_Exists = 1 Then
                            n_时段剩余 := n_时段剩余 + 1;
                          End If;
                        End If;
                      End If;
                    End Loop;
                  
                    If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                      v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                    End If;
                  End If;
                  v_Temp := v_Temp || '</SPANLIST>';
                End If;
              Elsif n_合约模式 = 4 Then
                If r_No.分时段 = 0 Then
                  n_已挂数   := r_No.已约数;
                  v_剩余数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
                Else
                  --分时段
                  v_Temp     := '<SPANLIST>';
                  n_已挂数   := 0;
                  v_剩余数量 := 0;
                  n_时段总数 := 0;
                  n_时段剩余 := 0;
                  d_时段开始 := Null;
                  d_时段结束 := Null;
                  Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                  If r_No.序号控制 = 0 Then
                    --非序号控制分时段预约
                    For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态, 数量
                                   From 临床出诊序号控制
                                   Where 记录id = r_No.记录id And 预约顺序号 Is Null And 是否预约 = 1 And
                                         (r_No.记录性质 = 1 And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                                         Nvl(r_No.替诊终止时间, Sysdate - 1) Or
                                         r_No.记录性质 = 2 And 开始时间 Between Nvl(r_No.停诊开始时间, Sysdate) And
                                         Nvl(r_No.停诊终止时间, Sysdate - 1))) Loop
                    
                      Select Count(1)
                      Into n_时段已挂
                      From 临床出诊序号控制
                      Where 记录id = r_No.记录id And 序号 = r_Time.序号 And 预约顺序号 Is Not Null And Nvl(挂号状态, 0) <> 0;
                    
                      n_已挂数   := n_已挂数 + n_时段已挂;
                      v_剩余数量 := v_剩余数量 + n_时段剩余;
                    
                      If r_Time.开始时间 > Sysdate Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          n_时段剩余 := r_Time.数量 - n_时段已挂;
                          v_Temp     := v_Temp || Gettimexml(r_Time.开始时间, r_Time.终止时间, r_Time.数量, n_时段剩余);
                        Else
                          If d_时段开始 Is Null Then
                            n_时段总数 := r_Time.数量;
                            n_时段剩余 := 0;
                            d_时段开始 := r_Time.开始时间;
                            d_时段结束 := r_Time.开始时间 + n_时间间隔 / 24 / 60;
                            If d_加号时间 < d_时段结束 Then
                              d_时段结束 := d_加号时间;
                            End If;
                          Else
                            If r_Time.开始时间 >= d_时段结束 Then
                              v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                            
                              n_时段总数 := r_Time.数量;
                              n_时段剩余 := 0;
                              d_时段开始 := r_Time.开始时间;
                              d_时段结束 := d_时段开始 + n_时间间隔 / 24 / 60;
                              If d_加号时间 < d_时段结束 Then
                                d_时段结束 := d_加号时间;
                              End If;
                            Else
                              n_时段总数 := n_时段总数 + r_Time.数量;
                            End If;
                          End If;
                        
                          n_时段剩余 := n_时段剩余 + (r_Time.数量 - n_时段已挂);
                        End If;
                      End If;
                    End Loop;
                  
                    If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                      v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                    End If;
                  Else
                    For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                                   From 临床出诊序号控制
                                   Where 记录id = r_No.记录id And 是否预约 = 1 And
                                         (r_No.记录性质 = 1 And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                                         Nvl(r_No.替诊终止时间, Sysdate - 1) Or
                                         r_No.记录性质 = 2 And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And
                                         Nvl(r_No.替诊终止时间, Sysdate - 1)) And Nvl(是否停诊, 0) = 0) Loop
                    
                      If Nvl(r_Time.挂号状态, 0) = 0 Then
                        v_剩余数量 := v_剩余数量 + 1;
                      Else
                        n_已挂数 := n_已挂数 + 1;
                      End If;
                    
                      If r_Time.开始时间 > Sysdate Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          If Nvl(r_Time.挂号状态, 0) = 0 Then
                            n_时段剩余 := 1;
                          Else
                            n_时段剩余 := 0;
                          End If;
                          v_Temp := v_Temp || Gettimexml(r_Time.开始时间, r_Time.终止时间, 1, n_时段剩余);
                        Else
                          If d_时段开始 Is Null Then
                            n_时段总数 := 1;
                            n_时段剩余 := 0;
                            d_时段开始 := r_Time.开始时间;
                            d_时段结束 := r_Time.开始时间 + n_时间间隔 / 24 / 60;
                            If d_加号时间 < d_时段结束 Then
                              d_时段结束 := d_加号时间;
                            End If;
                          Else
                            If r_Time.开始时间 >= d_时段结束 Then
                              v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                            
                              n_时段总数 := 1;
                              n_时段剩余 := 0;
                              d_时段开始 := r_Time.开始时间;
                              d_时段结束 := d_时段开始 + n_时间间隔 / 24 / 60;
                              If d_加号时间 < d_时段结束 Then
                                d_时段结束 := d_加号时间;
                              End If;
                            Else
                              n_时段总数 := n_时段总数 + 1;
                            End If;
                          End If;
                        
                          If Nvl(r_Time.挂号状态, 0) = 0 Then
                            n_时段剩余 := n_时段剩余 + 1;
                          End If;
                        End If;
                      End If;
                    End Loop;
                  
                    If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                      v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                    End If;
                  End If;
                  v_Temp := v_Temp || '</SPANLIST>';
                End If;
              End If;
            End If;
          End If;
        End If;
      End If;
    
      If Not (r_No.分时段 = 1 And r_No.序号控制 = 1) Then
        If d_日期 Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) Then
          n_禁用 := 1;
        End If;
        If d_日期 Between Nvl(r_No.停诊开始时间, Sysdate) And Nvl(r_No.停诊终止时间, Sysdate - 1) Then
          n_禁用 := 1;
        End If;
      End If;
    
      If Nvl(n_禁用, 0) = 0 Then
        n_合计金额 := 0;
        For r_Fee In (Select b.现价, a.从项数次
                      From 收费从属项目 A, 收费价目 B
                      Where a.从项id = b.收费细目id And a.主项id = r_No.项目id And d_日期 Between b.执行日期 And
                            Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And
                            (b.价格等级 = v_普通等级 Or
                            (b.价格等级 Is Null And Not Exists
                             (Select 1
                               From 收费价目
                               Where 收费细目id = b.收费细目id And 价格等级 = v_普通等级 And d_日期 Between 执行日期 And
                                     Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')))))
                      Union
                      Select b.现价, 1 As 从项数次
                      From 收费项目目录 A, 收费价目 B
                      Where a.Id = b.收费细目id And a.Id = r_No.项目id And d_日期 Between b.执行日期 And
                            Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And
                            (b.价格等级 = v_普通等级 Or
                            (b.价格等级 Is Null And Not Exists
                             (Select 1
                               From 收费价目
                               Where 收费细目id = b.收费细目id And 价格等级 = v_普通等级 And d_日期 Between 执行日期 And
                                     Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')))))) Loop
          n_合计金额 := n_合计金额 + r_Fee.现价 * r_Fee.从项数次;
        End Loop;
      
        v_时间段  := To_Char(r_No.开始时间, 'HH24:MI') || '-' || To_Char(r_No.终止时间, 'HH24:MI');
        c_Xmlmain := '<HB>';
        c_Xmlmain := c_Xmlmain || '<CZJLID>' || r_No.记录id || '</CZJLID>';
        c_Xmlmain := c_Xmlmain || '<HM>' || r_No.号码 || '</HM>';
        c_Xmlmain := c_Xmlmain || '<YSID>' || r_No.医生id || '</YSID>';
        c_Xmlmain := c_Xmlmain || '<YS>' || r_No.医生姓名 || '</YS>';
        c_Xmlmain := c_Xmlmain || '<KSID>' || r_No.科室id || '</KSID>';
        c_Xmlmain := c_Xmlmain || '<KSMC>' || r_No.科室名称 || '</KSMC>';
        c_Xmlmain := c_Xmlmain || '<ZC>' || r_No.职称 || '</ZC>';
        c_Xmlmain := c_Xmlmain || '<XMID>' || r_No.项目id || '</XMID>';
        c_Xmlmain := c_Xmlmain || '<XMMC>' || r_No.项目名称 || '</XMMC>';
        c_Xmlmain := c_Xmlmain || '<PRICE>' || n_合计金额 || '</PRICE>';
        c_Xmlmain := c_Xmlmain || '<HL>' || r_No.号类 || '</HL>';
        c_Xmlmain := c_Xmlmain || '<FSD>' || r_No.分时段 || '</FSD>';
        c_Xmlmain := c_Xmlmain || '<HBTIME>' || v_时间段 || '</HBTIME>';
        c_Xmlmain := c_Xmlmain || '<FWMC>' || r_No.排班 || '</FWMC>';
        If Trunc(Sysdate) = Trunc(d_日期) Or r_No.已约数 < r_No.限约数 Then
          c_Xmlmain := c_Xmlmain || '<YGHS>' || n_已挂数 || '</YGHS>';
          c_Xmlmain := c_Xmlmain || '<SYHS>' || v_剩余数量 || '</SYHS>';
          c_Xmlmain := c_Xmlmain || v_Temp;
        Else
          c_Xmlmain := c_Xmlmain || '<YGHS>' || r_No.已约数 || '</YGHS>';
          c_Xmlmain := c_Xmlmain || '<SYHS>' || 0 || '</SYHS>';
        End If;
        c_Xmlmain := c_Xmlmain || '</HB>';
        v_Xmlmain := v_Xmlmain || c_Xmlmain;
      End If;
    End If;
  End Loop;
  v_Xmlmain := '<GROUP>' || '<RQ>' || To_Char(d_日期, 'yyyy-mm-dd') || '</RQ>' || '<HBLIST>' || v_Xmlmain || '</HBLIST>' ||
               '</GROUP>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Xmlmain)) Into x_Templet From Dual;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getnolist;
/

--121638:李业庆,2018-02-05,冲销时价格处理调整
--120148:李业庆,2018-01-22,入库价格处理
Create Or Replace Procedure Zl_药品价格记录_Addnew
(
  新增库存_In   In Number, --0-更新库存，1-新增库存
  调价类型_In   In 药品价格记录.调价类型%Type,
  价格类型_In   In 药品价格记录.价格类型%Type,
  库房id_In     In 药品价格记录.库房id%Type,
  药品id_In     In 药品价格记录.药品id%Type,
  批次_In       In 药品价格记录.批次%Type := Null,
  原价_In       In 药品价格记录.原价%Type := Null,
  现价_In       In 药品价格记录.现价%Type := Null,
  执行日期_In   In 药品价格记录.执行日期%Type := Null,
  调价说明_In   In 药品价格记录.调价说明%Type := Null,
  调价人_In     In 药品价格记录.调价人%Type := Null,
  调价汇总号_In In 药品价格记录.调价汇总号%Type := Null,
  供药单位id_In In 药品价格记录.供药单位id%Type := Null,
  批号_In       In 药品价格记录.批号%Type := Null,
  效期_In       In 药品价格记录.效期%Type := Null,
  产地_In       In 药品价格记录.产地%Type := Null,
  灭菌效期_In   In 药品价格记录.灭菌效期%Type := Null,
  发票号_In     In 药品价格记录.发票号%Type := Null,
  发票日期_In   In 药品价格记录.发票日期%Type := Null,
  发票金额_In   In 药品价格记录.发票金额%Type := Null,
  应付款变动_In In 药品价格记录.应付款变动%Type := 0,
  记录状态_In   In 药品价格记录.记录状态%Type := 0
) As
  n_原价     药品价格记录.原价%Type;
  n_调价类型 药品价格记录.调价类型%Type;
  n_调价说明 药品价格记录.调价说明%Type;
Begin
  --该过程用于入库或更新库存时对应的价格表更新（新增价格或停止已有价格产生新价格）
  ----新增库存记录时，检查是否存在对应的批次价格
  --1.1如果没有价格记录则新增价格（无论是否分批）
  --1.2如果有价格记录并且原价现价不等时，则停止当前价格，重新产生新的价格

  ----更新库存记录时
  --1.如果是分批的则不管
  --2.如果是不分批的，检查是否存在对应的批次价格
  --2.1如果没有价格记录则新增价格
  --2.1如果有价格记录并且原价现价不等时，则停止当前价格，重新产生新的价格

  --新增库存或批次=0时
  If 新增库存_In = 1 Or 批次_In = 0 Then
    Begin
      Select 现价
      Into n_原价
      From 药品价格记录
      Where 价格类型 = 价格类型_In And 记录状态 = 1 And 库房id = 库房id_In And 药品id = 药品id_In And 批次 = 批次_In And Rownum < 2;
    Exception
      When Others Then
        n_原价 := Null;
    End;
  
    If n_原价 Is Not Null And Nvl(n_原价, 0) <> 现价_In Then
      --有原价时并且原价现价不等时，停用原来价格
      Zl_药品价格记录_Stop(价格类型_In, 库房id_In, 药品id_In, 批次_In, 执行日期_In - 1 / 24 / 60 / 60, 1);
    End If;
  
    If n_原价 Is Null Or (n_原价 Is Not Null And Nvl(n_原价, 0) <> 现价_In) Then
      --如果没有原价，或者有原价但原价和现价不等时，产生新的价格
      If n_原价 Is Null Then
        n_调价类型 := 0;
        n_调价说明 := '入库新增批次价格';
      Else
        n_调价类型 := 2;
        n_调价说明 := '入库批次价格重算';
      End If;
      Zl_药品价格记录_Insert(n_调价类型, 价格类型_In, 库房id_In, 药品id_In, 批次_In, Nvl(n_原价, 0), 现价_In, 执行日期_In, n_调价说明, Zl_Username,
                       调价汇总号_In, 供药单位id_In, 批号_In, 效期_In, 产地_In, 灭菌效期_In, 发票号_In, 发票日期_In, 发票金额_In, 应付款变动_In, 记录状态_In);
    End If;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品价格记录_Addnew;
/

--119852:李业庆,2018-01-11,取价格时返回默认价格(适用于冲销等)
--119148:李业庆,2017-12-28,入库时停用价格停用时间减1秒
--119342:李业庆,2018-01-03,可用数量异常数据处理
--120148:李业庆,2018-01-22,入库价格处理
--121116:李业庆,2018-01-29,无库存调价时更新药品批号对照
Create Or Replace Procedure Zl_药品库存_Update
(
  Id_In       In 药品收发记录.Id%Type,
  业务类型_In In Number := 0,
  入出类型_In In Number := 0,
  操作类型_In In Number := 0
) Is
  --功能：
  --      根据业务类型处理库存表，处理业务药品所有业务和卫材发料业务，卫材内部流通业务不处理
  --id_in  需要处理收发记录单
  --业务类型_in  业务类型，0-新增、1-删除、2-审核、3-冲销
  --入出类型_in  0-入库，1-出库
  --操作类型：根据业务情况确定
  ----外购入库中，表示财务审核：  0-不是财务审核，1-财务审核，目前只有外购入库有财务审核
  ----申领，移库中冲销流程：0-正常冲销流程，1-申请，审核冲销流程

  n_可用数量 药品库存.实际数量%Type;
  n_实际数量 药品库存.实际数量%Type;
  n_零售金额 药品库存.实际金额%Type;
  n_差价     药品库存.实际差价%Type;
  n_时价     Number(1);
  n_成本价   药品收发记录.成本价%Type;
  n_零售价   药品库存.零售价%Type;

  n_库存数量     药品库存.实际数量%Type;
  n_库存平均价   药品库存.平均成本价%Type;
  n_库存售价     药品库存.零售价%Type;
  n_总数量       药品收发记录.实际数量%Type;
  n_总成本价     药品收发记录.成本价%Type;
  n_总售价       药品收发记录.零售价%Type;
  n_库房分批     药品规格.药库分批%Type;
  n_申请冲销     Number(1);
  n_更新库存     Number(1) := 0;
  v_现价         药品收发记录.零售价%Type;
  v_执行新价格   Number(1) := 0;
  n_有库存       Number(1) := 0;
  v_审核日期     药品收发记录.审核日期%Type;
  n_价格更新     Number(1) := 0;
  n_新增时价售价 Number(1) := 0;
  n_新增成本价   Number(1) := 0;
  n_分批属性     Number(1) := 0; --0-分批属性不符合，1-分批属性符合
  n_新增库存     Number(1) := 0; --0-更新库存，1-新增库存
  n_重算价格     Number(1) := 0; --0-不重算价格,1-重算价格
  --业务明细数据，把库存数据更新需要的数据都列出来
  Cursor c_Detail Is
    Select a.Id, a.记录状态, a.单据, a.No, a.序号, a.库房id, a.供药单位id, a.入出类别id, a.对方部门id, a.入出系数, Nvl(a.发药方式, 0) As 发药方式, a.药品id,
           Nvl(a.批次, 0) 批次, a.产地, a.原产地, a.批号, a.生产日期, a.效期, a.付数, Nvl(a.填写数量, 0) As 填写数量, a.实际数量, a.成本价, a.成本金额, a.扣率,
           a.零售价, Nvl(a.零售金额, 0) As 零售金额, Nvl(a.差价, 0) As 差价, a.配药人, a.配药日期, a.审核人, a.审核日期, a.灭菌日期, a.灭菌效期, a.批准文号,
           a.商品条码, a.内部条码, Nvl(b.是否变价, 0) As 是否变价, a.单量, a.频次, a.摘要, Nvl(a.费用id, 0) As 费用id
    From 药品收发记录 A, 收费项目目录 B
    Where a.药品id = b.Id And a.Id = Id_In;

  r_Detail c_Detail%RowType;
Begin
  For r_Detail In c_Detail Loop
    If Zl_Fun_Getbatchpro(r_Detail.库房id, r_Detail.药品id) = 1 Then
      If r_Detail.批次 > 0 Then
        n_分批属性 := 1;
      Else
        n_分批属性 := 0;
      End If;
    Else
      If r_Detail.批次 = 0 Then
        n_分批属性 := 1;
      Else
        n_分批属性 := 0;
      End If;
    End If;
  
    n_实际数量 := r_Detail.入出系数 * r_Detail.实际数量 * Nvl(r_Detail.付数, 1);
    If n_实际数量 Is Null Then
      n_实际数量 := 0;
    End If;
    n_可用数量 := 0;
    n_零售价   := r_Detail.零售价;
    If r_Detail.单据 = 12 Then
      n_成本价 := r_Detail.单量;
    Else
      n_成本价 := r_Detail.成本价;
    End If;
    n_零售金额 := r_Detail.入出系数 * r_Detail.零售金额;
    n_差价     := r_Detail.入出系数 * r_Detail.差价;
  
    --先取库存和单据的数量和成本价
    Begin
      Select Nvl(实际数量, 0)
      Into n_库存数量
      From 药品库存
      Where 性质 = 1 And 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次;
    Exception
      When Others Then
        n_库存数量 := 0;
    End;
  
    n_库存平均价 := Zl_Fun_Getoutcost(r_Detail.药品id, r_Detail.批次, r_Detail.库房id);
    n_库存售价   := Zl_Fun_Getoutprice(r_Detail.药品id, r_Detail.批次, r_Detail.库房id);
  
    --时价药品都需要更新库存表零售价字段
    If r_Detail.是否变价 = 1 Then
      n_时价 := 1;
    Else
      n_时价 := 0;
    End If;
  
    --特殊业务处理库存
    --包含业务--5-差价调整；13-调价变动
    --单据5，13都是业务类型_in，2-审核、入出类型_in  0-入库
    If r_Detail.单据 = 5 Or r_Detail.单据 = 13 Then
      --这种类型的单据收发记录成本价字段不是保存的真正成本价而是存储的其他数据
      If r_Detail.单据 = 5 Then
        If r_Detail.填写数量 <> 0 Then
          n_零售价 := Nvl(r_Detail.零售价, 0) / r_Detail.填写数量;
        Else
          n_零售价 := 0;
        End If;
        --审核
        If r_Detail.记录状态 = 1 Then
          --差价调整发药方式=0；主动调价、退货、发药产生的调价修正发药方式=1
          n_成本价 := r_Detail.单量;
        Else
          --冲销 还原原始成本价
          Begin
            --成本价=(金额-差价)/数量
            n_成本价 := (Nvl(r_Detail.零售价, 0) - Nvl(r_Detail.成本价, 0)) / r_Detail.填写数量;
          Exception
            When Others Then
              Select 成本价 Into n_成本价 From 药品规格 Where 药品id = r_Detail.药品id;
          End;
        End If;
      Else
        n_成本价 := Nvl(r_Detail.单量, 0) - Nvl(r_Detail.频次, 0);
      End If;
    
      If r_Detail.单据 = 5 Then
        --单据=5 的成本价修正记录 平均成本价不需要重算，因为保存了最新价格的
        If r_Detail.摘要 = '外购退库差价误差自动修正' Or r_Detail.摘要 = '财务审核价格变动修正' Then
          --这一步肯定是外购退库，外购退库只更新成本价,且肯定有库存
          Update 药品库存
          Set 实际差价 = Nvl(实际差价, 0) + n_差价
          Where 性质 = 1 And 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次;
        Else
          Update 药品库存
          Set 平均成本价 = n_成本价, 上次采购价 = n_成本价, 实际金额 = Nvl(实际金额, 0) + n_零售金额, 实际差价 = Nvl(实际差价, 0) + n_差价
          Where 性质 = 1 And 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次;
          If Sql%NotFound Then
            Insert Into 药品库存
              (库房id, 药品id, 批次, 性质, 实际差价, 上次批号, 效期, 上次产地, 原产地, 上次供应商id, 上次生产日期, 批准文号, 实际金额, 上次采购价, 平均成本价)
            Values
              (r_Detail.库房id, r_Detail.药品id, r_Detail.批次, 1, n_差价, r_Detail.批号, r_Detail.效期, r_Detail.产地, r_Detail.原产地,
               r_Detail.供药单位id, r_Detail.生产日期, r_Detail.批准文号, n_零售金额, n_成本价, n_成本价);
          
            Insert Into 药品入库信息
              (药品id, 库房id, 批次, 入库日期)
              Select r_Detail.药品id, r_Detail.库房id, r_Detail.批次, r_Detail.审核日期
              From Dual
              Where Not Exists (Select 1
                     From 药品入库信息
                     Where 药品id = r_Detail.药品id And 库房id = r_Detail.库房id And 批次 = r_Detail.批次);
          End If;
        End If;
      Elsif r_Detail.单据 = 13 Then
        --单据=13 的售价修正记录 同步更新的金额和差价，所以不需要重算平均成本价
        If r_Detail.费用id = 0 Then
          Update 药品库存
          Set 零售价 = Decode(n_时价, 1, n_零售价, Null), 实际金额 = Nvl(实际金额, 0) + n_零售金额, 实际差价 = Nvl(实际差价, 0) + n_差价
          Where 性质 = 1 And 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次;
        Else
          Update 药品库存
          Set 实际金额 = Nvl(实际金额, 0) + n_零售金额, 实际差价 = Nvl(实际差价, 0) + n_差价
          Where 性质 = 1 And 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次;
        End If;
      
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 零售价)
          Values
            (r_Detail.库房id, r_Detail.药品id, r_Detail.批次, 1, 0, 0, n_零售金额, n_零售金额, Decode(n_时价, 1, n_零售价, Null));
        
          Insert Into 药品入库信息
            (药品id, 库房id, 批次, 入库日期)
            Select r_Detail.药品id, r_Detail.库房id, r_Detail.批次, r_Detail.审核日期
            From Dual
            Where Not Exists (Select 1
                   From 药品入库信息
                   Where 药品id = r_Detail.药品id And 库房id = r_Detail.库房id And 批次 = r_Detail.批次);
        End If;
      End If;
    Else
      --一般业务处理库存
      --包含业务--1-外购入库；2-自制入库；3-协药入库；4-其他入库；6-库房移出；
      --7-部门领用；8-收费处方发药；9-记帐单处方发药；10-记帐表处方发药；11-其他出库；
      --12-盘点；14-药品盘点记录单
      --21-材料其他出库；24-收费处方发料；25-记帐单处方发料；26-记帐表处方发料
      If 业务类型_In = 0 Or 业务类型_In = 1 Then
        --新增，删除
        If r_Detail.单据 = 8 Or r_Detail.单据 = 9 Or r_Detail.单据 = 10 Or r_Detail.单据 = 21 Or r_Detail.单据 = 24 Or
           r_Detail.单据 = 25 Or r_Detail.单据 = 26 Or r_Detail.单据 = 7 Or r_Detail.单据 = 11 Or
           ((r_Detail.单据 = 2 Or r_Detail.单据 = 3 Or r_Detail.单据 = 12) And r_Detail.入出系数 = -1) Or
           (r_Detail.单据 = 1 And r_Detail.发药方式 = 1) Or (r_Detail.单据 = 6 And r_Detail.入出系数 = -1 And r_Detail.记录状态 = 1) Or
           (r_Detail.单据 = 6 And Mod(r_Detail.记录状态, 3) = 2 And r_Detail.入出系数 = 1) Then
          --需要在新增/删除单据时减少/增加可用数量的单据类型
          ----1.发药/发料单据(收费处方，记账单，记账表)
          ----2.普通出库（领用、其他出库、移库中出的那笔(r_Detail.单据 = 6 And r_Detail.入出系数 = -1 And r_Detail.记录状态 = 1)、盘点单中盘亏那笔）
          ----3.退库单（r_Detail.单据 = 1 And r_Detail.发药方式 = 1）
          ----4.移库申请冲销单（原入库那笔的冲销记录，r_Detail.单据 = 6 And Mod(r_Detail.记录状态, 3) = 2 And r_Detail.入出系数 = 1）
        
          --新增，删除单据时，因为没有审核所以只处理数量不处理金额和差价
        
          If 业务类型_In = 0 Then
            --新增时正常处理可用数量
            n_可用数量 := n_实际数量;
          Else
            --删除时按相反数计算可用数量
            n_可用数量 := -1 * n_实际数量;
          End If;
        
          n_实际数量 := 0;
          n_零售金额 := 0;
          n_差价     := 0;
        
          --处理库存
          Update 药品库存
          Set 可用数量 = 可用数量 + n_可用数量
          Where 药品id = r_Detail.药品id And 库房id = r_Detail.库房id And Nvl(批次, 0) = r_Detail.批次 And 性质 = 1;
        
          n_更新库存 := 1;
        End If;
      Elsif 业务类型_In = 2 Then
        --审核
        --10.35开始，理论上所有的出库类单据在审核时都不再处理可用数量
        If r_Detail.单据 = 8 Or r_Detail.单据 = 9 Or r_Detail.单据 = 10 Or r_Detail.单据 = 21 Or r_Detail.单据 = 24 Or
           r_Detail.单据 = 25 Or r_Detail.单据 = 26 Or r_Detail.单据 = 7 Or r_Detail.单据 = 11 Or
           ((r_Detail.单据 = 2 Or r_Detail.单据 = 3 Or r_Detail.单据 = 12) And r_Detail.入出系数 = -1) Or
           (r_Detail.单据 = 1 And r_Detail.发药方式 = 1) Or (r_Detail.单据 = 6 And r_Detail.入出系数 = -1 And r_Detail.记录状态 = 1) Or
           (r_Detail.单据 = 6 And Mod(r_Detail.记录状态, 3) = 2 And r_Detail.入出系数 = 1) Then
          n_可用数量 := 0;
        Else
          n_可用数量 := n_实际数量;
        End If;
      
        --处理库存
        If 入出类型_In = 0 Then
          --入库审核
          Update 药品库存
          Set 可用数量 = Nvl(可用数量, 0) + n_可用数量, 实际数量 = Nvl(实际数量, 0) + n_实际数量, 实际金额 = Nvl(实际金额, 0) + n_零售金额,
              实际差价 = Nvl(实际差价, 0) + n_差价, 上次供应商id = r_Detail.供药单位id,
              上次采购价 = Decode(r_Detail.单据, 1, Decode(r_Detail.发药方式, 1, 上次采购价, n_成本价), n_成本价),
              上次批号 = Nvl(r_Detail.批号, 上次批号), 上次生产日期 = Nvl(r_Detail.生产日期, 上次生产日期), 上次产地 = Nvl(r_Detail.产地, 上次产地),
              原产地 = Nvl(r_Detail.原产地, 原产地), 灭菌效期 = Nvl(r_Detail.灭菌效期, 灭菌效期), 效期 = Nvl(r_Detail.效期, 效期),
              批准文号 = Nvl(r_Detail.批准文号, 批准文号), 上次扣率 = Decode(r_Detail.单据, 12, 上次扣率, r_Detail.扣率),
              商品条码 = Nvl(r_Detail.商品条码, 商品条码), 内部条码 = Nvl(r_Detail.内部条码, 内部条码)
          Where 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次 And 性质 = 1;
        Else
          --出库审核，只需要下数量和金额
          Update 药品库存
          Set 可用数量 = Nvl(可用数量, 0) + n_可用数量, 实际数量 = Nvl(实际数量, 0) + n_实际数量, 实际金额 = Nvl(实际金额, 0) + n_零售金额,
              实际差价 = Nvl(实际差价, 0) + n_差价, 平均成本价 = Decode(平均成本价, Null, n_成本价, 平均成本价),
              上次采购价 = Decode(上次采购价, Null, n_成本价, 上次采购价)
          Where 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次 And 性质 = 1;
        End If;
      
        n_更新库存 := 1;
      Elsif 业务类型_In = 3 Then
        --冲销
        If r_Detail.单据 = 8 Or r_Detail.单据 = 9 Or r_Detail.单据 = 10 Or r_Detail.单据 = 21 Or r_Detail.单据 = 24 Or
           r_Detail.单据 = 25 Or r_Detail.单据 = 26 Then
          --发药/发料单退药/退料时同时又产生了未发单据，所以就不处理可用数量
          n_可用数量 := 0;
        Elsif r_Detail.单据 = 6 And Mod(r_Detail.记录状态, 3) = 2 And r_Detail.入出系数 = 1 Then
          --药库单的冲销单据，要判断是否需要申请
          n_申请冲销 := 操作类型_In;
          If n_申请冲销 = 0 Then
            --不需要申请的在冲销时处理可用数量
            n_可用数量 := n_实际数量;
          Else
            --需要申请的，已经在申请时处理了可用数量
            n_可用数量 := 0;
          End If;
        Else
          n_可用数量 := n_实际数量;
        End If;
      
        --处理库存
        If 入出类型_In = 0 Then
          --出库单据冲销需要将入库库房数据都更新
          Update 药品库存
          Set 可用数量 = Nvl(可用数量, 0) + n_可用数量, 实际数量 = Nvl(实际数量, 0) + n_实际数量, 实际金额 = Nvl(实际金额, 0) + n_零售金额,
              实际差价 = Nvl(实际差价, 0) + n_差价, 上次供应商id = r_Detail.供药单位id,
              上次采购价 = Decode(r_Detail.单据, 1, Decode(r_Detail.发药方式, 1, 上次采购价, n_成本价), 上次采购价),
              上次批号 = Nvl(r_Detail.批号, 上次批号), 上次生产日期 = Nvl(r_Detail.生产日期, 上次生产日期), 上次产地 = Nvl(r_Detail.产地, 上次产地),
              原产地 = Nvl(r_Detail.原产地, 原产地), 灭菌效期 = Nvl(r_Detail.灭菌效期, 灭菌效期), 效期 = Nvl(r_Detail.效期, 效期),
              批准文号 = Nvl(r_Detail.批准文号, 批准文号), 上次扣率 = Decode(r_Detail.单据, 12, 上次扣率, r_Detail.扣率),
              商品条码 = Nvl(r_Detail.商品条码, 商品条码), 内部条码 = Nvl(r_Detail.内部条码, 内部条码)
          Where 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次 And 性质 = 1;
        Else
          --入库单据冲销只需要下数量和金额
          Update 药品库存
          Set 可用数量 = Nvl(可用数量, 0) + n_可用数量, 实际数量 = Nvl(实际数量, 0) + n_实际数量, 实际金额 = Nvl(实际金额, 0) + n_零售金额,
              实际差价 = Nvl(实际差价, 0) + n_差价
          Where 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次 And 性质 = 1;
        End If;
      
        n_更新库存 := 1;
      End If;
    
      --新增/删除/审核/冲销业务时，库存表未找到数据则需要产生库存表所有信息
      If Sql%RowCount = 0 And n_更新库存 = 1 Then
        --入库业务取界面价格（之前已经取过了），出库业务冲销业务取最新价格
        If 业务类型_In = 3 Or 入出类型_In = 1 Then
          --取最新成本价
          v_现价 := Zl_Fun_Getoutcost(r_Detail.药品id, r_Detail.批次, r_Detail.库房id, n_成本价);
          If v_现价 Is Not Null Then
            n_成本价 := v_现价;
          End If;
        
          --时价售价取最新价格
          If r_Detail.是否变价 = 1 Then
            v_现价 := Zl_Fun_Getoutprice(r_Detail.药品id, r_Detail.批次, r_Detail.库房id, n_零售价);
            If v_现价 Is Not Null Then
              n_零售价 := v_现价;
            End If;
          End If;
        End If;
      
        --新增库存
        n_新增库存 := 1;
        Insert Into 药品库存
          (库房id, 药品id, 批次, 效期, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 原产地, 灭菌效期, 批准文号, 零售价,
           上次扣率, 商品条码, 内部条码, 平均成本价)
        Values
          (r_Detail.库房id, r_Detail.药品id, r_Detail.批次, r_Detail.效期, 1, n_可用数量, n_实际数量, n_零售金额, n_差价, r_Detail.供药单位id,
           n_成本价, r_Detail.批号, r_Detail.生产日期, r_Detail.产地, r_Detail.原产地, r_Detail.灭菌效期, r_Detail.批准文号,
           Decode(n_时价, 1, n_零售价, Null), r_Detail.扣率, r_Detail.商品条码, r_Detail.内部条码, n_成本价);
      
        Insert Into 药品入库信息
          (药品id, 库房id, 批次, 入库日期)
          Select r_Detail.药品id, r_Detail.库房id, r_Detail.批次, r_Detail.审核日期
          From Dual
          Where Not Exists (Select 1
                 From 药品入库信息
                 Where 药品id = r_Detail.药品id And 库房id = r_Detail.库房id And 批次 = r_Detail.批次);
      End If;
    
      --重算平均成本价，入库审核需要重算平均成本价和零售价，注意只限于不分批药品，分批药品不用重算（确保和之前库存的数据一致）
      --只有更新库存状态需要重新计算价格，新增库存状态不用重算
      If 入出类型_In = 0 And 业务类型_In = 2 And r_Detail.批次 = 0 And n_新增库存 <> 1 Then
        --按总金额/总数量方式计算平均成本价而不用（金额-差价）/数量是为了数据的准确性
        n_重算价格 := 1;
        n_总数量   := (n_库存数量 + n_实际数量);
        If n_总数量 <> 0 Then
          n_总成本价 := (n_库存数量 * n_库存平均价 + n_实际数量 * n_成本价) / n_总数量;
        
          If n_总成本价 < 0 Then
            n_总成本价 := n_成本价;
          End If;
        
          Update 药品库存
          Set 平均成本价 = n_总成本价
          Where 性质 = 1 And 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次;
        
          --更新时价零售价
          If n_时价 = 1 Then
            n_总售价 := (n_库存数量 * n_库存售价 + n_实际数量 * n_零售价) / n_总数量;
            Update 药品库存
            Set 零售价 = n_总售价
            Where 性质 = 1 And 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次 And
                  Nvl(实际数量, 0) <> 0;
            If Sql%NotFound Then
              n_总售价 := n_零售价;
              Update 药品库存
              Set 零售价 = n_总售价
              Where 性质 = 1 And 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次;
            End If;
          End If;
        End If;
      End If;
    
      --价格处理
      --分批属性正确时才进行价格处理
      If n_分批属性 = 1 Then
        --新增库存，或者更新库存并且重算了价格的情况下才处理价格
        If n_新增库存 = 1 Or (n_新增库存 = 0 And n_重算价格 = 1) Then
          --时价价格
          If r_Detail.是否变价 = 1 Then
            Zl_药品价格记录_Addnew(n_新增库存, 0, 1, r_Detail.库房id, r_Detail.药品id, r_Detail.批次, 0, Nvl(n_总售价, n_零售价), Sysdate,
                             '入库新增批次价格', Zl_Username, Null, r_Detail.供药单位id, r_Detail.批号, r_Detail.效期, r_Detail.产地, Null,
                             Null, Null, Null, Null, 1);
          End If;
        
          --成本价价格
          Zl_药品价格记录_Addnew(n_新增库存, 0, 2, r_Detail.库房id, r_Detail.药品id, r_Detail.批次, 0, Nvl(n_总成本价, n_成本价), Sysdate,
                           '入库新增批次价格', Zl_Username, Null, r_Detail.供药单位id, r_Detail.批号, r_Detail.效期, r_Detail.产地, Null,
                           Null, Null, Null, Null, 1);
        End If;
      End If;
    End If;
  
    --删除多余的库存数据，外购入库财务审核为了确保库存不变产生修正数据必须保证不删除库存
    If Not (r_Detail.单据 = 1 And 操作类型_In = 1) Then
      Delete From 药品库存
      Where 性质 = 1 And 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次 And Nvl(可用数量, 0) = 0 And
            Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0;
    End If;
  
    Zl_药品库存_可用数量异常处理(r_Detail.库房id, r_Detail.药品id, r_Detail.批次);
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品库存_Update;
/

--120548:陈刘,2018-01-22,骑线体温自动标记,体温时点影响修正
--114591:陈刘,2017-12-28,体温单批量录入自动标记骑线
CREATE OR REPLACE Procedure Zl_体温单骑线设置_Update
(
  文件id_In   In 病人护理文件.Id%Type, --病人护理文件ID
  发生时间_In In 病人护理数据.发生时间%Type,
  项目序号_In In 病人护理明细.项目序号%Type, --护理项目的序号，非护理项目固定为0
  记录id_In   In 病人护理数据.Id%Type,
  编辑_In     In Number := 0
) As
  n_子类         病历文件列表.种类%Type;
  n_开始时点     Number;
  n_监测次数     Number;
  n_时间间隔     Number;
  v_入院时间     病人变动记录.开始时间%Type;
  Ncount         Number;
  v_记录日期     病人护理数据.发生时间%Type;
  v_体温记录     病人护理明细.记录内容%Type;
  v_开始时间     Varchar2(20);
  v_结束时间     Varchar2(20);
  v_中间时间     Varchar2(20);
  v_显示时间pre  Varchar2(20);
  v_显示时间next Varchar2(20);
  v_入院开始时间 Varchar2(20);
  v_入院结束时间 Varchar2(20);
  v_数值         病人护理明细.记录内容%Type;
  v_内容时间     Varchar2(20);
  n_骑线         Number(1);
  n_明细id       病人护理明细.Id%Type;
  v_Error        Varchar2(255);
  n_入院         Number(1);
  n_Time         Number(2);
  n_p            Number(2);
  Err_Custom Exception;
  --当前时段显示的体温数据
  Function f_Nowshow
  (
    开始时间_In   In Varchar2,
    结束时间_In   In Varchar2,
    中间时间_In   In Varchar2,
    Id_In         In 病人护理明细.Id%Type,
    护理文件id_In In 病人护理文件.Id%Type
  ) Return Varchar2 Is
    n_时间差   Number;
    n_显示     Number(1);
    v_记录内容 病人护理明细.记录内容%Type;
    v_时间     Varchar2(20);
  Begin
    n_时间差 := -1;
    For r_Temp In (Select g.发生时间, f.记录内容, f.显示, f.未记说明
                   From 病人护理文件 B, 病人护理数据 G, 病人护理明细 F
                   Where b.Id = g.文件id And g.Id = f.记录id And b.Id = 护理文件id_In And f.项目序号 = 1 And f.记录类型 = 1 And
                         f.记录标记 = 0 And g.发生时间 Between To_Date(开始时间_In, 'YYYY-MM-DD hh24:mi:ss') And
                         To_Date(结束时间_In, 'YYYY-MM-DD hh24:mi:ss') And f.Id <> Id_In
                   Order By g.发生时间) Loop
      If n_时间差 = -1 Then
        n_时间差   := Abs((r_Temp.发生时间 - To_Date(中间时间_In, 'YYYY-MM-DD hh24:mi:ss')) * 24 * 60 * 60);
        v_记录内容 := r_Temp.记录内容;
        n_显示     := r_Temp.显示;
        v_时间     := To_Char(r_Temp.发生时间, 'YYYY-MM-DD hh24:mi:ss');
      Else
        If r_Temp.显示 = 1 Then
          If n_显示 = 1 And Abs((r_Temp.发生时间 - To_Date(中间时间_In, 'YYYY-MM-DD hh24:mi:ss')) * 24 * 60 * 60) < n_时间差 Then
            n_时间差   := Abs((r_Temp.发生时间 - To_Date(中间时间_In, 'YYYY-MM-DD hh24:mi:ss')) * 24 * 60 * 60);
            v_记录内容 := r_Temp.记录内容;
            n_显示     := r_Temp.显示;
            v_时间     := To_Char(r_Temp.发生时间, 'YYYY-MM-DD hh24:mi:ss');
          Else
            n_时间差   := Abs((r_Temp.发生时间 - To_Date(中间时间_In, 'YYYY-MM-DD hh24:mi:ss')) * 24 * 60 * 60);
            v_记录内容 := r_Temp.记录内容;
            n_显示     := r_Temp.显示;
            v_时间     := To_Char(r_Temp.发生时间, 'YYYY-MM-DD hh24:mi:ss');
          End If;
        Else
          If Abs((r_Temp.发生时间 - To_Date(中间时间_In, 'YYYY-MM-DD hh24:mi:ss')) * 24 * 60 * 60) < n_时间差 And n_显示 = 0 Then
            n_时间差   := Abs((r_Temp.发生时间 - To_Date(中间时间_In, 'YYYY-MM-DD hh24:mi:ss')) * 24 * 60 * 60);
            v_记录内容 := r_Temp.记录内容;
            n_显示     := r_Temp.显示;
            v_时间     := To_Char(r_Temp.发生时间, 'YYYY-MM-DD hh24:mi:ss');
          End If;
        End If;

      End If;
      If r_Temp.未记说明 Is Not Null And r_Temp.记录内容 Is Null Then
        Return Null;
      End If;
    End Loop;
    If v_时间 Is Not Null Then
      Return v_时间 || '|' || v_记录内容;
    Else
      Return Null;
    End If;
  Exception
    When Others Then
      Return Null;
  End f_Nowshow;

Begin
  n_入院 := 0;
  If 项目序号_In <> 1 Then
    Return;
  End If;

  If 编辑_In = 1 Then
    Update 病人护理明细 Set 记录类型 = 1 Where 记录id = 记录id_In And 项目序号 = 项目序号_In;
  End If;

  Begin
    Select Max(a.子类)
    Into n_子类
    From 病历文件列表 A, 病人护理文件 B
    Where a.种类 = 3 And a.保留 <> 1 And a.Id = b.格式id And b.Id = 文件id_In;
  End;

  --查询入院时间
  If n_子类 = 1 Then
    For r_List In (Select c.要素名称, c.内容文本
                   From 病人护理文件 A, 病历文件结构 C, 病历文件结构 D
                   Where c.父id = d.Id And d.父id Is Null And d.对象序号 = 1 And a.格式id = c.文件id And a.Id = 文件id_In
                   Order By c.Id) Loop
      Case r_List.要素名称
        When '开始时点' Then
          n_开始时点 := To_Number(r_List.内容文本);
        When '监测次数' Then
          n_监测次数 := To_Number(r_List.内容文本);
        When '时间间隔' Then
          n_时间间隔 := To_Number(r_List.内容文本);
		Else
          v_Error := '';
      End Case;
    End Loop;
  Else
    n_开始时点 :=  Zl_To_Number(zl_GetSysParameter('体温开始时间', 1255)) ;
    n_监测次数 := 6;
    n_时间间隔 := 4;
  End If;

  Select Min(h.开始时间)
  Into v_入院时间
  From 病人变动记录 H, 病人护理文件 B
  Where h.开始时间 Is Not Null And h.病人id = b.病人id And h.主页id = b.主页id And b.Id = 文件id_In
  Group By h.病人id, h.主页id;

  v_记录日期 := To_Date(To_Char(v_入院时间, 'YYYY-MM-DD'), 'YYYY-MM-DD hh24:mi:ss');
  Ncount     := Floor(((v_入院时间 - v_记录日期) * 24 - n_开始时点) / n_时间间隔);

  If Ncount > n_监测次数 Then
    Ncount := n_监测次数;
  End If;
  v_入院开始时间 := To_Char(v_记录日期 + ((n_开始时点 + Ncount * n_时间间隔 - (n_时间间隔 / 4)) / 24), 'YYYY-MM-DD hh24:mi:ss');
  v_入院结束时间 := To_Char(v_记录日期 + ((n_开始时点 + Ncount * n_时间间隔 + (n_时间间隔 / 4)) / 24), 'YYYY-MM-DD hh24:mi:ss');
  If v_入院时间 <= To_Date(v_入院开始时间, 'YYYY-MM-DD hh24:mi:ss') And
     v_入院时间 >= To_Date(v_入院开始时间, 'YYYY-MM-DD hh24:mi:ss') - n_时间间隔 / 4 / 24 Then
    v_入院结束时间 := v_入院开始时间;
    v_入院开始时间 := To_Char(v_记录日期 + (n_开始时点 + Ncount * n_时间间隔) / 24, 'YYYY-MM-DD hh24:mi:ss');
    n_入院         := 1;
  Elsif v_入院时间 <= To_Date(v_入院开始时间, 'YYYY-MM-DD hh24:mi:ss') + n_时间间隔 / 24 And
        v_入院时间 >= To_Date(v_入院结束时间, 'YYYY-MM-DD hh24:mi:ss') Then
    v_入院开始时间 := v_入院结束时间;
    v_入院结束时间 := To_Char(v_记录日期 + ((n_开始时点 + (Ncount + 1) * n_时间间隔) / 24), 'YYYY-MM-DD hh24:mi:ss');
    n_入院         := 1;
  End If;

  v_记录日期 := To_Date(To_Char(发生时间_In, 'YYYY-MM-DD'), 'YYYY-MM-DD hh24:mi:ss');
  Ncount     := Floor(((发生时间_In - v_记录日期) * 24 - n_开始时点) / n_时间间隔);

  If Ncount > n_监测次数 Then
    Ncount := n_监测次数;
  End If;

  --当前数据所在时间断
  v_开始时间 := To_Char(v_记录日期 + ((n_开始时点 + Ncount * n_时间间隔) / 24), 'YYYY-MM-DD hh24:mi:ss');
  v_结束时间 := To_Char(v_记录日期 + ((n_开始时点 + n_时间间隔 * (Ncount + 1)) / 24), 'YYYY-MM-DD hh24:mi:ss');
  v_中间时间 := To_Char(To_Date(v_开始时间, 'YYYY-MM-DD hh24:mi:ss') +
                    (To_Date(v_结束时间, 'YYYY-MM-DD hh24:mi:ss') - To_Date(v_开始时间, 'YYYY-MM-DD hh24:mi:ss')) / 2,
                    'YYYY-MM-DD hh24:mi:ss');

  Select Max(f.记录内容), Max(f.Id)
  Into v_体温记录, n_明细id
  From 病人护理文件 B, 病人护理数据 G, 病人护理明细 F
  Where b.Id = g.文件id And g.Id = f.记录id And b.Id = 文件id_In And f.项目序号 = 1 And f.记录标记 = 0 And g.发生时间 = 发生时间_In;

  v_数值         := f_Nowshow(v_开始时间, v_结束时间, v_中间时间, n_明细id, 文件id_In);
  v_显示时间next := '';
  While v_显示时间next Is Null Loop
    If v_数值 Is Null Then
      If v_内容时间 Is Not Null Then
        v_内容时间 := To_Char(To_Date(v_中间时间, 'YYYY-MM-DD hh24:mi:ss') + n_时间间隔 / 24, 'YYYY-MM-DD hh24:mi:ss');
      Else
        v_内容时间 := v_中间时间;
      End If;
    Else
      n_p        := Instr(v_数值, '|');
      v_内容时间 := Substr(v_数值, 1, n_p - 1);
      v_数值     := Substr(v_数值, n_p + 1);
    End If;
    If To_Date(v_内容时间, 'YYYY-MM-DD hh24:mi:ss') < 发生时间_In Then
      v_数值 := f_Nowshow(To_Char(To_Date(v_开始时间, 'YYYY-MM-DD hh24:mi:ss') + n_时间间隔 / 24, 'YYYY-MM-DD hh24:mi:ss'),
                        To_Char(To_Date(v_结束时间, 'YYYY-MM-DD hh24:mi:ss') + n_时间间隔 / 24, 'YYYY-MM-DD hh24:mi:ss'),
                        To_Char(To_Date(v_中间时间, 'YYYY-MM-DD hh24:mi:ss') + n_时间间隔 / 24, 'YYYY-MM-DD hh24:mi:ss'), n_明细id,
                        文件id_In);
    Else
      v_显示时间next := v_内容时间;
    End If;
  End Loop;
  v_数值     := '';
  v_内容时间 := '';

  --循环查询当前时间之前的普通数据
  n_Time := 0;
  While n_Time * n_时间间隔 <= 24 Loop
    If To_Date(v_开始时间, 'YYYY-MM-DD hh24:mi:ss') < Trunc(To_Date(v_开始时间, 'YYYY-MM-DD hh24:mi:ss')) + n_开始时点 / 24 And
       To_Date(v_开始时间, 'YYYY-MM-DD hh24:mi:ss') <> Trunc(To_Date(v_开始时间, 'YYYY-MM-DD hh24:mi:ss')) Then
      v_结束时间 := To_Char(Trunc(To_Date(v_开始时间, 'YYYY-MM-DD hh24:mi:ss')) + n_开始时点 / 24, 'YYYY-MM-DD hh24:mi:ss');
      v_开始时间 := To_Char(Trunc(To_Date(v_开始时间, 'YYYY-MM-DD hh24:mi:ss')), 'YYYY-MM-DD hh24:mi:ss');
      v_中间时间 := To_Char(To_Date(v_开始时间, 'YYYY-MM-DD hh24:mi:ss') +
                        (To_Date(v_结束时间, 'YYYY-MM-DD hh24:mi:ss') - To_Date(v_开始时间, 'YYYY-MM-DD hh24:mi:ss')) / 2,
                        'YYYY-MM-DD hh24:mi:ss');
      v_数值     := f_Nowshow(v_开始时间, v_结束时间, v_中间时间, n_明细id, 文件id_In);
      v_结束时间 := To_Char(Trunc(To_Date(v_结束时间, 'YYYY-MM-DD hh24:mi:ss')), 'YYYY-MM-DD hh24:mi:ss');
      v_开始时间 := To_Char(To_Date(v_结束时间, 'YYYY-MM-DD hh24:mi:ss') - n_时间间隔 / 24, 'YYYY-MM-DD hh24:mi:ss');
      v_中间时间 := To_Char(To_Date(v_结束时间, 'YYYY-MM-DD hh24:mi:ss') - n_时间间隔 / 2 / 24, 'YYYY-MM-DD hh24:mi:ss');
    Else
      v_数值     := f_Nowshow(v_开始时间, v_结束时间, v_中间时间, n_明细id, 文件id_In);
      v_开始时间 := To_Char(To_Date(v_开始时间, 'YYYY-MM-DD hh24:mi:ss') - n_时间间隔 / 24, 'YYYY-MM-DD hh24:mi:ss');
      v_结束时间 := To_Char(To_Date(v_结束时间, 'YYYY-MM-DD hh24:mi:ss') - n_时间间隔 / 24, 'YYYY-MM-DD hh24:mi:ss');
      v_中间时间 := To_Char(To_Date(v_中间时间, 'YYYY-MM-DD hh24:mi:ss') - n_时间间隔 / 24, 'YYYY-MM-DD hh24:mi:ss');

    End If;
    n_Time := n_Time + 1;
    If v_数值 Is Not Null Then
      n_p           := Instr(v_数值, '|');
      v_内容时间    := Substr(v_数值, 1, n_p - 1);
      v_数值        := Substr(v_数值, n_p + 1);
      v_显示时间pre := v_内容时间;
      Exit When To_Date(v_内容时间, 'YYYY-MM-DD hh24:mi:ss') < 发生时间_In;
    End If;
  End Loop;
  If v_内容时间 Is Not Null Then
    If v_数值 < v_体温记录 And v_体温记录 > 37.5 Then
      Select Count(f.Id)
      Into n_骑线
      From 病人护理文件 B, 病人护理数据 G, 病人护理明细 F
      Where b.Id = g.文件id And g.Id = f.记录id And b.Id = 文件id_In And f.项目序号 = 项目序号_In And g.发生时间 <> 发生时间_In And
            f.记录类型 = 7 And g.发生时间 Between To_Date(v_显示时间pre, 'YYYY-MM-DD hh24:mi:ss') And
            To_Date(v_显示时间next, 'YYYY-MM-DD hh24:mi:ss');

      If n_骑线 < 1 Then
        Update 病人护理明细 Set 记录类型 = 7 Where 记录id = 记录id_In And 项目序号 = 项目序号_In And 终止版本 Is Null;
      End If;

    End If;
  Else
    If 发生时间_In >= To_Date(v_入院开始时间, 'YYYY-MM-DD hh24:mi:ss') And 发生时间_In <= To_Date(v_入院结束时间, 'YYYY-MM-DD hh24:mi:ss') And
       n_入院 = 1 Then
      Select Count(f.Id)
      Into n_骑线
      From 病人护理文件 B, 病人护理数据 G, 病人护理明细 F
      Where b.Id = g.文件id And g.Id = f.记录id And b.Id = 文件id_In And f.项目序号 = 项目序号_In And g.发生时间 <> 发生时间_In And
            f.记录类型 = 7 And g.发生时间 Between To_Date(v_入院开始时间, 'YYYY-MM-DD hh24:mi:ss') And
            To_Date(v_入院结束时间, 'YYYY-MM-DD hh24:mi:ss');

      If n_骑线 < 1 Then
        Update 病人护理明细 Set 记录类型 = 7 Where 记录id = 记录id_In And 项目序号 = 项目序号_In And 终止版本 Is Null;
      End If;
    End If;
  End If;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_体温单骑线设置_Update;
/

--117460:陈刘,2017-12-28,体温单上下标只有一个能生效
CREATE OR REPLACE Procedure Zl_体温单数据_Update
(
  文件id_In   In 病人护理文件.Id%Type, --病人护理文件ID
  发生时间_In In 病人护理数据.发生时间%Type, --护理数据的发生时间
  记录类型_In In 病人护理明细.记录类型%Type, --护理项目=1，上标说明=2，入出转标记=3，手术日标记=4,下标说明=6
  项目序号_In In 病人护理明细.项目序号%Type, --护理项目的序号，非护理项目固定为0
  记录内容_In In 病人护理明细.记录内容%Type := Null, --记录内容，如果内容为空，即清除以前的内容  36或36/37
  体温部位_In In 病人护理明细.体温部位%Type := Null, --删除数据时不用填写部位 除活动项目外
  复试合格_In In Number := 0,
  未记说明_In In 病人护理明细.未记说明%Type := Null, --未记说明
  他人记录_In In Number := 1,
  数据来源_In In 病人护理明细.数据来源%Type := 0,
  来源id_In   In 病人护理明细.来源id%Type := Null, --始终为原始记录的来源ID
  共用_In     In 病人护理明细.共用%Type := 0,
  项目首次_In In Number := 0, --汇总项目使用，保存数据前是否先删除一段时间内的数据信息。 1 删除
  开始时间_In In 病人护理数据.发生时间%Type := Null, --本记录有效跨度的开始时间
  结束时间_In In 病人护理数据.发生时间%Type := Null, --本记录有效跨度的终止时间，单独记录为每分钟，体温表为4小时,时间跨度内的相同项目记录要删除

  
  操作员_In   In 病人护理数据.保存人%Type := Null,
  检查科室_In In Number := 1,
  显示_In     In Number := 0,
  骑线_In     In Number := 0
) Is
  n_项目序号 病人护理明细.项目序号%Type;
  n_记录标记 病人护理明细.记录标记%Type; --记录内容的特殊标志
  v_保存人   病人护理数据.保存人%Type;
  v_记录人   病人护理明细.记录人%Type;
  d_结束时间 病人护理数据.发生时间%Type;
  d_发生时间 病人护理数据.发生时间%Type;
  d_开始时间 病人护理数据.发生时间%Type;
  n_记录id   病人护理明细.记录id%Type;
  v_科室id   病人护理文件.科室id%Type;
  n_心率应用 护理记录项目.应用方式%Type;
  n_脉搏     护理记录项目.项目序号%Type := 2;
  n_体温     护理记录项目.项目序号%Type := 1;
  n_心率     护理记录项目.项目序号%Type := -1;
  n_项目性质 护理记录项目.项目性质%Type := 1;
  n_开始版本 病人护理明细.开始版本%Type;
  n_疼痛强度 护理记录项目.项目序号%Type;
  n_Newid    病人护理明细.Id%Type;

  n_病人id       病人护理文件.病人id%Type;
  n_主页id       病人护理文件.主页id%Type;
  n_婴儿         病人护理文件.婴儿%Type;
  d_婴儿出院时间 病人医嘱记录.开始执行时间%Type;
  d_文件开始时间 病人护理文件.开始时间%Type;
  n_Preblue      Number;
  n_i            Number;
  n_Sqlrowcount  Number;
  v_记录内容     病人护理明细.记录内容%Type;
  v_Data         病人护理明细.记录内容%Type;
  n_Count        Number(1);
  --主过程
  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  d_发生时间 := 发生时间_In;

  If d_发生时间 Is Null Then
    v_Error := '数据发生时间不能为空！';
    Raise Err_Custom;
  End If;

  If 开始时间_In Is Null Then
    d_开始时间 := d_发生时间;
  Else
    d_开始时间 := 开始时间_In;
  End If;

  If 结束时间_In Is Null Then
    d_结束时间 := d_开始时间;
  Else
    d_结束时间 := 结束时间_In;
  End If;

  --提取记录ID
  n_记录id := 0;
  If 操作员_In Is Null Then
    v_保存人 := Zl_Username;
  Else
    v_保存人 := 操作员_In;
  End If;
  ----------------------------------------------------------------------------------------------------------------------
  Begin
    Select ID Into n_记录id From 病人护理数据 Where 文件id = 文件id_In And 发生时间 = 发生时间_In;
  Exception
    When Others Then
      n_记录id := 0;
  End;

  --检查数据的发生时间是否对应科室
  ---------------------------------------------------------------------------------------------------------------------
  Select 病人id, 主页id, Nvl(婴儿, 0), 开始时间
  Into n_病人id, n_主页id, n_婴儿, d_文件开始时间
  From 病人护理文件
  Where ID = 文件id_In;
  d_婴儿出院时间 := Null;
  If n_婴儿 <> 0 Then
    Begin
      Select 开始执行时间
      Into d_婴儿出院时间
      From 病人医嘱记录 B, 诊疗项目目录 C
      Where b.诊疗项目id + 0 = c.Id And b.医嘱状态 = 8 And Nvl(b.婴儿, 0) <> 0 And c.类别 = 'Z' And
            Instr(',3,5,11,', ',' || c.操作类型 || ',', 1) > 0 And b.病人id = n_病人id And b.主页id = n_主页id And b.婴儿 = n_婴儿;
    Exception
      When Others Then
        d_婴儿出院时间 := Null;
    End;
  End If;
  If d_婴儿出院时间 Is Null Then
    v_科室id := 0;
    Begin
      Select a.科室id
      Into v_科室id
      From 病人变动记录 A, 病人护理文件 B
      Where a.科室id Is Not Null And a.病人id = b.病人id And a.主页id = b.主页id And b.Id = 文件id_In And
            (发生时间_In >= a.开始时间 And (发生时间_In < = Nvl(a.终止时间, Sysdate) Or a.终止时间 Is Null)) And Rownum < 2;
    Exception
      When Others Then
        v_科室id := 0;
    End;
    If v_科室id = 0 And 检查科室_In = 1 Then
      v_Error := '数据发生时间 ' || To_Char(发生时间_In, 'YYYY-MM-DD HH24:MI:SS') || ' 不在病人有效变动时间范围内，不能操作！';
      Raise Err_Custom;
    End If;
  Else
    If 发生时间_In < d_文件开始时间 Or (发生时间_In > d_婴儿出院时间 And 检查科室_In = 1) Then
      v_Error := '数据发生时间 ' || To_Char(发生时间_In, 'YYYY-MM-DD HH24:MI:SS') || ' 不在病人有效变动时间范围内，不能操作！';
      Raise Err_Custom;
    End If;
  End If;
  --检查是不是本人的记录
  ---------------------------------------------------------------------------------------------------------------------
  If 他人记录_In = 0 And n_记录id > 0 Then
    v_记录人 := '';
    Begin
      Select 记录人
      Into v_记录人
      From 病人护理明细
      Where 记录id = n_记录id And 记录类型 = 记录类型_In And 项目序号 = 项目序号_In And 终止版本 Is Null And Rownum < 2
      Order By Nvl(记录标记, 0);
    Exception
      When Others Then
        v_记录人 := '';
    End;
    If v_记录人 Is Not Null And v_记录人 <> v_保存人 Then
      v_Error := '在' || To_Char(d_开始时间, 'yyyy-mm-dd hh24:mi:ss') || '至' || To_Char(d_结束时间, 'yyyy-mm-dd hh24:mi:ss') ||
                 '段内记录人不是当前人，你无权修改！';
      Raise Err_Custom;
    End If;
  End If;

  --提取疼痛强度曲线项目的项目序号
  Begin
    Select 项目序号 Into n_疼痛强度 From 体温记录项目 Where 记录名 = '疼痛强度';
  Exception
    When Others Then
      n_疼痛强度 := -999;
  End;
  --检查脉搏心率是否共用
  If 项目序号_In = n_脉搏 Then
    n_项目序号 := n_心率;
  Else
    n_项目序号 := 项目序号_In;
  End If;
  Begin
    Select 应用方式, 项目性质 Into n_心率应用, n_项目性质 From 护理记录项目 Where 项目序号 = n_项目序号;
  Exception
    When Others Then
      n_心率应用 := 0;
  End;

  ----清除某段时间内的护理数据信息
  --项目首次_In 汇总项目根据汇总时间段保存一天数据时先清除在保存 项目首次_In：=1
  --记录内容_In Is Null And 未记说明_In Is Null 则认为删除数据
  ---------------------------------------------------------------------------------------------------------------------
  If (项目首次_In = 1) Or (记录内容_In Is Null And 未记说明_In Is Null) Then
    If 项目首次_In = 1 Then
      For r_List In (Select l.Id, Count(*) As 记录数, Min(l.发生时间) 发生时间
                     From 病人护理文件 A, 病人护理数据 L, 病人护理明细 D
                     Where a.Id = l.文件id And l.Id = d.记录id And a.Id = 文件id_In And d.终止版本 Is Null And l.发生时间 >= d_开始时间 And
                           l.发生时间 <= d_结束时间
                     Group By l.Id) Loop
        n_Sqlrowcount := 0;
        If 记录类型_In = 2 Or 记录类型_In = 6 Then
          Delete 病人护理明细
          Where 记录id = r_List.Id And 记录类型 = 记录类型_In And 项目序号 = 项目序号_In And 终止版本 Is Null;
          n_Sqlrowcount := Sql%RowCount;
        Else
          If 体温部位_In Is Not Null Then
            --此处主要针对活动项目
            Delete 病人护理明细
            Where 记录id = r_List.Id And 记录类型 = 记录类型_In And 项目序号 = 项目序号_In And Nvl(体温部位, '无') = Nvl(体温部位_In, '无') And
                  终止版本 Is Null;
          Else
            Delete 病人护理明细
            Where 记录id = r_List.Id And 记录类型 = 记录类型_In And 项目序号 = 项目序号_In And 终止版本 Is Null;
          End If;
        
          n_Sqlrowcount := Sql%RowCount;
          --如果脉搏和心率共用删除脉搏是同时删除心率数据
          If 项目序号_In = n_脉搏 And n_心率应用 = 2 Then
            Delete 病人护理明细
            Where 记录id = r_List.Id And 记录类型 = 记录类型_In And 项目序号 = n_心率 And 终止版本 Is Null;
            n_Sqlrowcount := n_Sqlrowcount + Sql%RowCount;
          End If;
          --如果为收缩压/舒张压删除收缩压时同时删除舒张压数据
          If 项目序号_In = 4 Then
            Delete 病人护理明细
            Where 记录id = r_List.Id And 记录类型 = 记录类型_In And 项目序号 = 5 And 终止版本 Is Null;
            n_Sqlrowcount := n_Sqlrowcount + Sql%RowCount;
          End If;
        End If;
        If n_Sqlrowcount >= r_List.记录数 Then
          Delete 病人护理数据 Where ID = r_List.Id;
        End If;
        --更新打印
        Update 体温单打印
        Set 打印人 = Null, 打印时间 = Null
        Where 文件id = 文件id_In And
              开始时间 = (Select Max(开始时间) From 体温单打印 Where 文件id = 文件id_In And 开始时间 <= r_List.发生时间);
      End Loop;
    Else
      For r_List In (Select l.Id, Count(*) As 记录数, Min(l.发生时间) 发生时间
                     From 病人护理文件 A, 病人护理数据 L, 病人护理明细 D
                     Where a.Id = l.文件id And l.Id = d.记录id And a.Id = 文件id_In And d.终止版本 Is Null And l.发生时间 = 发生时间_In And
                           l.发生时间 >= d_开始时间 And l.发生时间 <= d_结束时间
                     Group By l.Id) Loop
        n_Sqlrowcount := 0;
        If 记录类型_In = 2 Or 记录类型_In = 6 Then
          Delete 病人护理明细
          Where 记录id = r_List.Id And 记录类型 = 记录类型_In And 项目序号 = 项目序号_In And 终止版本 Is Null;
          n_Sqlrowcount := Sql%RowCount;
        Else
          If 体温部位_In Is Not Null Then
            --此处主要针对活动项目
            Delete 病人护理明细
            Where 记录id = r_List.Id And 记录类型 = 记录类型_In And 项目序号 = 项目序号_In And Nvl(体温部位, '无') = Nvl(体温部位_In, '无') And
                  终止版本 Is Null;
          Else
            Delete 病人护理明细
            Where 记录id = r_List.Id And 记录类型 = 记录类型_In And 项目序号 = 项目序号_In And 终止版本 Is Null;
          End If;
        
          n_Sqlrowcount := Sql%RowCount;
          --如果脉搏和心率共用删除脉搏是同时删除心率数据
          If 项目序号_In = n_脉搏 And n_心率应用 = 2 Then
            Delete 病人护理明细
            Where 记录id = r_List.Id And 记录类型 = 记录类型_In And 项目序号 = n_心率 And 终止版本 Is Null;
            n_Sqlrowcount := n_Sqlrowcount + Sql%RowCount;
          End If;
          --如果为收缩压/舒张压删除收缩压时同时删除舒张压数据
          If 项目序号_In = 4 Then
            Delete 病人护理明细
            Where 记录id = r_List.Id And 记录类型 = 记录类型_In And 项目序号 = 5 And 终止版本 Is Null;
            n_Sqlrowcount := n_Sqlrowcount + Sql%RowCount;
          End If;
        End If;
        If n_Sqlrowcount >= r_List.记录数 Then
          Delete 病人护理数据 Where ID = r_List.Id;
        End If;
        --更新打印
        Update 体温单打印
        Set 打印人 = Null, 打印时间 = Null
        Where 文件id = 文件id_In And
              开始时间 = (Select Max(开始时间) From 体温单打印 Where 文件id = 文件id_In And 开始时间 <= r_List.发生时间);
      End Loop;
    End If;
  End If;

  If 记录内容_In Is Null And 未记说明_In Is Null Then
    Return;
  End If;

  --分解项目记录内容
  n_Preblue := 0;
  If (记录类型_In = 1 Or 记录类型_In = 7) And Instr(',' || n_疼痛强度 || ',1,2,4,', ',' || 项目序号_In || ',', 1) > 0 Then
    n_Preblue := Nvl(Instr(Nvl(记录内容_In, ''), '/', 1), 0);
    If n_Preblue > 1 Then
      n_Preblue := 1;
    End If;
  End If;

  If 项目序号_In = 4 And n_Preblue = 0 Then
    v_Error := '血压数据格式错误! 格式:收缩压/舒张压。';
    Raise Err_Custom;
  End If;

  --确认开始版本号
  ---------------------------------------------------------------------------------------------------------------------
  n_开始版本 := 1;

  --改写病人护理数据：如果已经存在与病人、科室和发生时间相同的记录则修改，否则增加新的记录
  ---------------------------------------------------------------------------------------------------------------------
  --汇总项目是删除后在增加，可能开始提取的记录ID已经不存在。
  Begin
    Select ID Into n_记录id From 病人护理数据 Where ID = n_记录id;
  Exception
    When Others Then
      n_记录id := 0;
  End;

  If n_记录id = 0 Then
    Select 病人护理数据_Id.Nextval Into n_记录id From Dual;
    Insert Into 病人护理数据
      (ID, 文件id, 显示, 发生时间, 保存人, 保存时间, 最后版本)
    Values
      (n_记录id, 文件id_In, 0, d_发生时间, v_保存人, Sysdate, n_开始版本);
  End If;

  --检查删除物理降温数据或脉搏短轴数据
  If (项目序号_In = n_体温 Or 项目序号_In = n_疼痛强度 Or (项目序号_In = n_脉搏 And n_心率应用 = 2)) And n_Preblue = 0 Then
    Delete From 病人护理明细
    Where 记录id = n_记录id And 项目序号 = Decode(项目序号_In, n_脉搏, n_心率, 项目序号_In) And Decode(项目序号_In, n_脉搏, 1, Nvl(记录标记, 0)) = 1 And
          记录类型 = 记录类型_In And 终止版本 Is Null;
  End If;

  --改写病人护理明细：如果已经存在与病人、科室和发生时间相同的记录则修改，否则增加新的记录
  -----------------------------------------------------------------------------------------------------------------------
  v_Data     := 记录内容_In;
  n_项目序号 := 项目序号_In;
  For n_i In 0 .. n_Preblue Loop
    If n_i = 0 Then
      If 项目序号_In = n_心率 Then
        n_记录标记 := 1;
      Else
        n_记录标记 := 0;
      End If;
    Else
      --收缩压/舒张压
      If 项目序号_In = 4 Then
        n_记录标记 := 0;
        n_项目序号 := 5;
      Else
        n_记录标记 := 1;
        If 项目序号_In = n_脉搏 Then
          n_项目序号 := n_心率;
        End If;
      End If;
    
    End If;
    If n_Preblue > 0 Then
      v_记录内容 := Substr(v_Data, 1, Instr(v_Data, '/', 1) - 1);
      If v_记录内容 Is Null Then
        v_记录内容 := v_Data;
      End If;
    Else
      v_记录内容 := v_Data;
    End If;
  
    --检查是否需要标记骑线
    Select Count(b.记录名)
    Into n_Count
    From 护理记录项目 A, 体温记录项目 B
    Where a.项目序号 = b.项目序号 And a.项目序号 = 项目序号_In And b.记录法 = 1 And a.分组名 = '1)体温曲线项目';
    --为了兼容以前同步过来的心率数据记录标记为0
    If n_i = 0 Then
      If 记录类型_In = 2 Or 记录类型_In = 6 Then
        Update 病人护理明细
        Set 记录内容 = v_记录内容, 体温部位 = 体温部位_In, 复试合格 = 复试合格_In,
            未记说明 = Decode(n_项目序号, n_体温, Decode(v_记录内容, '不升', Null, 未记说明_In), 未记说明_In), 记录人 = v_保存人, 记录时间 = Sysdate
        Where 记录id = n_记录id And 项目序号 = n_项目序号 And
              Decode(项目序号_In, n_体温, Nvl(记录标记, 0), n_疼痛强度, Nvl(记录标记, 0), Nvl(n_记录标记, 0)) = Nvl(n_记录标记, 0) And
              记录类型 = 记录类型_In And Decode(n_项目性质, 2, Nvl(体温部位, '无'), Nvl(体温部位_In, '无')) = Nvl(体温部位_In, '无') And
              终止版本 Is Null;
      Else
        Update 病人护理明细
        Set 记录内容 = v_记录内容, 体温部位 = 体温部位_In, 复试合格 = 复试合格_In,
            未记说明 = Decode(n_项目序号, n_体温, Decode(v_记录内容, '不升', Null, 未记说明_In), 未记说明_In), 记录类型 = 记录类型_In, 记录人 = v_保存人,
            记录时间 = Sysdate
        Where 记录id = n_记录id And 项目序号 = n_项目序号 And
              Decode(项目序号_In, n_体温, Nvl(记录标记, 0), n_疼痛强度, Nvl(记录标记, 0), Nvl(n_记录标记, 0)) = Nvl(n_记录标记, 0) And
              Decode(n_项目性质, 2, Nvl(体温部位, '无'), Nvl(体温部位_In, '无')) = Nvl(体温部位_In, '无') And 终止版本 Is Null;
      End If;
      --Zl_体温单骑线设置_Update(文件id_In, 发生时间_In, 项目序号_In, n_记录id);
    Else
      Update 病人护理明细
      Set 记录内容 = v_记录内容, 记录类型 = 记录类型_In, 记录人 = v_保存人, 记录时间 = Sysdate
      Where 记录id = n_记录id And 项目序号 = n_项目序号 And
            Decode(项目序号_In, n_体温, Nvl(记录标记, 0), n_疼痛强度, Nvl(记录标记, 0), Nvl(n_记录标记, 0)) = Nvl(n_记录标记, 0) And 终止版本 Is Null;
      --Zl_体温单骑线设置_Update(文件id_In, 发生时间_In, 项目序号_In, n_记录id,1);
    End If;
  
    If Sql%RowCount = 0 Then
      --插入本次登记的病人护理内容
      If Mod(记录类型_In, 10) = 1 Or 记录类型_In = 7 Then
        Select 病人护理明细_Id.Nextval Into n_Newid From Dual;
        Insert Into 病人护理明细
          (ID, 记录id, 记录类型, 项目分组, 项目id, 项目序号, 项目名称, 项目类型, 记录内容, 项目单位, 记录标记, 记录人, 体温部位, 复试合格, 开始版本, 终止版本, 记录组号, 未记说明,
           记录时间, 数据来源, 显示, 来源id, 共用)
          Select n_Newid, n_记录id, 记录类型_In, 分组名, 项目id, 项目序号, 项目名称, 项目类型, v_记录内容, 项目单位, n_记录标记, v_保存人, 体温部位_In, 复试合格_In,
                 n_开始版本, Null, Null, Decode(n_项目序号, n_体温, Decode(v_记录内容, '不升', Null, 未记说明_In), 未记说明_In), Sysdate,
                 数据来源_In, 0, 来源id_In, 共用_In
          From 护理记录项目
          Where 项目序号 = n_项目序号;
        If 显示_In = 1 Then
          Zl_体温单数据_设置显示(n_Newid, 1);
        End If;
      
        If n_Count > 0 And 骑线_In = 1 Then
          Zl_体温单骑线设置_Update(文件id_In, 发生时间_In, 项目序号_In, n_记录id);
        End If;
      Else
        Insert Into 病人护理明细
          (ID, 记录id, 记录类型, 项目分组, 项目id, 项目序号, 项目名称, 项目类型, 记录内容, 项目单位, 记录标记, 记录人, 体温部位, 复试合格, 开始版本, 终止版本, 记录组号, 未记说明,
           记录时间, 数据来源, 显示, 来源id, 共用)
        Values
          (病人护理明细_Id.Nextval, n_记录id, 记录类型_In, Null, Null, 0,
           Decode(记录类型_In, 2, '上标说明', 6, '下标说明', 3, '入出转', 4, v_记录内容), Decode(记录类型_In, 3, 0, 1),
           Decode(记录类型_In, 4, '1', 记录内容_In), '', n_记录标记, v_保存人, 体温部位_In, 复试合格_In, n_开始版本, Null, Null, 未记说明_In, Sysdate,
           数据来源_In, 0, 来源id_In, 共用_In);
      End If;
    End If;
    If n_Preblue > 0 Then
      v_Data := Substr(v_Data, Instr(v_Data, '/', 1) + 1);
    End If;
  End Loop;
  --更新打印
  Update 体温单打印
  Set 打印人 = Null, 打印时间 = Null
  Where 文件id = 文件id_In And
        开始时间 = (Select Max(开始时间) From 体温单打印 Where 文件id = 文件id_In And 开始时间 <= d_发生时间);

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_体温单数据_Update;
/

--118973:秦龙,2017-12-28,解决勾选应用于本分类的问题
--116247:秦龙,2017-12-26,规格能单独设置过敏试验
Create Or Replace Procedure Zl_用法用量_Update
(
  药名id_In     In 诊疗用法用量.项目id%Type,
  过敏试验id_In In Varchar2, --以"|"分隔的过敏实验的内容 
  处方限量_In   In 药品特性.处方限量%Type,
  疗程_In       In 诊疗用法用量.疗程%Type,
  用法用量_In   In Varchar2, --以"|"分隔的用法用量内容，每条记录按"用法ID^频次^成人剂量^小儿剂量^医生嘱托"组织 
  方式_In       In Number := 0, --0-诊疗项目本身,1-当前类别;2-特定分类项目 
  类别_In       In Varchar2 := '0',
  分类id_In     In 诊疗项目目录.分类id%Type := 0,
  药品id_In     In 药品规格.药品id%Type := 0
) Is
  --药品id_in :不等于空说明是规格，否则为品种或者分类 
  v_Records      Varchar2(4000);
  v_Currrec      Varchar2(1000);
  v_Fields       Varchar2(1000);
  v_用法id       诊疗用法用量.用法id%Type;
  v_频次         诊疗用法用量.频次%Type;
  v_成人剂量     诊疗用法用量.成人剂量%Type;
  v_小儿剂量     诊疗用法用量.小儿剂量%Type;
  v_医生嘱托     诊疗用法用量.医生嘱托%Type;
  v_Ddd值        诊疗用法用量.Ddd值%Type;
  v_性质         诊疗用法用量.性质%Type;
  v_是否皮试     药品特性.是否皮试%Type;
  n_药名id       药品规格.药名id%Type;
  n_药品用法用量 Number; --0-药品用法用量中不存在数据，1-药品用法用量中存在数据 

  Cursor c_Item Is
    Select i.Id
    From 诊疗项目目录 I, 药品特性 T, (Select 药品剂型 From 药品特性 Where 药名id = 药名id_In) C
    Where i.Id = t.药名id And t.药品剂型 = c.药品剂型 And i.分类id = 分类id_In And i.Id <> 药名id_In;
Begin
  --品种和分类 
  If 药品id_In = 0 Then
    For r_Item In (Select ID
                   From 诊疗项目目录
                   Where (方式_In = 0 And ID = 药名id_In) Or (方式_In = 1 And 类别 = 类别_In) Or
                         (分类id In (Select ID From 诊疗分类目录 Start With ID = 分类id_In Connect By Prior ID = 上级id))) Loop
      --过敏试验
      If 过敏试验id_In Is Not Null Then
        v_是否皮试 := 1;
      Else
        v_是否皮试 := 0;
      End If;
    
      Update 药品特性 Set 处方限量 = 处方限量_In, 是否皮试 = v_是否皮试 Where 药名id = r_Item.Id;
    
      For r_Spec In (Select b.药品id From 药品规格 B Where b.药名id = r_Item.Id) Loop
        Delete From 药品用法用量 Where 药品id = r_Spec.药品id And 性质 = 0;
      End Loop;
    
      Delete From 诊疗用法用量 Where 项目id = r_Item.Id And 性质 = 0;
    
      v_Records := 过敏试验id_In;
    
      While v_Records Is Not Null Loop
        v_Currrec := Substr(v_Records, 1, Instr(v_Records, '|') - 1);
        v_Fields  := v_Currrec;
        v_用法id  := To_Number(v_Fields);
        Insert Into 诊疗用法用量 (项目id, 性质, 用法id) Values (r_Item.Id, 0, v_用法id);
        v_Records := Replace('|' || v_Records, '|' || v_Currrec || '|');
      
        --判断在药品用法用量中是否存在对应该品种的规格的数据 
        Begin
          n_药品用法用量 := 0;
          Select 1
          Into n_药品用法用量
          From 药品规格 A, 药品用法用量 B
          Where a.药品id = b.药品id And a.药名id = r_Item.Id And b.用法id = v_用法id And Rownum <= 1;
        Exception
          When Others Then
            n_药品用法用量 := 0;
        End;
      
        If n_药品用法用量 = 0 Then
          For r_药品id In (Select 药品id From 药品规格 Where 药名id = r_Item.Id) Loop
            Insert Into 药品用法用量 (药品id, 用法id, 性质) Values (r_药品id.药品id, v_用法id, 0);
          End Loop;
        End If;
      End Loop;
    
      --用法用量   Select 药品id From 药品规格 Where 药名id = r_Item.Id
      For r_Spec In (Select b.药品id From 药品规格 B Where b.药名id = r_Item.Id) Loop
        Delete From 药品用法用量 Where 药品id = r_Spec.药品id And 性质 > 0;
      End Loop;
      Delete From 诊疗用法用量 Where 项目id = r_Item.Id And 性质 > 0;
    
      If 用法用量_In Is Null Then
        v_Records := Null;
      Else
        v_Records := 用法用量_In || '|';
      End If;
      v_性质 := 0;
      While v_Records Is Not Null Loop
        v_Currrec  := Substr(v_Records, 1, Instr(v_Records, '|') - 1);
        v_Fields   := v_Currrec;
        v_用法id   := To_Number(Substr(v_Fields, 1, Instr(v_Fields, '^') - 1));
        v_Fields   := Substr(v_Fields, Instr(v_Fields, '^') + 1);
        v_频次     := Substr(v_Fields, 1, Instr(v_Fields, '^') - 1);
        v_Fields   := Substr(v_Fields, Instr(v_Fields, '^') + 1);
        v_成人剂量 := To_Number(Substr(v_Fields, 1, Instr(v_Fields, '^') - 1));
        v_Fields   := Substr(v_Fields, Instr(v_Fields, '^') + 1);
        v_小儿剂量 := To_Number(Substr(v_Fields, 1, Instr(v_Fields, '^') - 1));
        v_Fields   := Substr(v_Fields, Instr(v_Fields, '^') + 1);
        v_医生嘱托 := Substr(v_Fields, 1, Instr(v_Fields, '^') - 1);
        v_Fields   := Substr(v_Fields, Instr(v_Fields, '^') + 1);
        v_Ddd值    := To_Number(v_Fields);
        v_性质     := v_性质 + 1;
        Insert Into 诊疗用法用量
          (项目id, 性质, 用法id, 频次, 成人剂量, 小儿剂量, 医生嘱托, 疗程, Ddd值)
        Values
          (r_Item.Id, v_性质, v_用法id, v_频次, v_成人剂量, v_小儿剂量, v_医生嘱托, 疗程_In, v_Ddd值);
        If 分类id_In <> 0 Then
          For t_Item In c_Item Loop
            Delete From 诊疗用法用量 Where 项目id = t_Item.Id And 用法id = v_用法id And 性质 > 0;
            Insert Into 诊疗用法用量 (项目id, 性质, 用法id, 频次) Values (t_Item.Id, v_性质, v_用法id, v_频次);
          End Loop;
        End If;
      
        --判断在药品用法用量中是否存在对应该品种的规格的数据 
        Begin
          n_药品用法用量 := 0;
          Select 1
          Into n_药品用法用量
          From 药品规格 A, 药品用法用量 B
          Where a.药品id = b.药品id And a.药名id = r_Item.Id And b.用法id = v_用法id And Rownum <= 1;
        Exception
          When Others Then
            n_药品用法用量 := 0;
        End;
      
        If n_药品用法用量 = 0 Then
          For r_药品id In (Select 药品id From 药品规格 Where 药名id = r_Item.Id) Loop
            Insert Into 药品用法用量
              (药品id, 用法id, 频次, 成人剂量, 小儿剂量, 医生嘱托, 疗程, Ddd值, 性质)
            Values
              (r_药品id.药品id, v_用法id, v_频次, v_成人剂量, v_小儿剂量, v_医生嘱托, 疗程_In, v_Ddd值, 1);
          End Loop;
        End If;
      
        v_Records := Replace('|' || v_Records, '|' || v_Currrec || '|');
      End Loop;
    End Loop;
  Else
    --规格 
    --过敏试验
    If 过敏试验id_In Is Not Null Then
      v_是否皮试 := 1;
    Else
      v_是否皮试 := 0;
    End If;
    Select 药名id Into n_药名id From 药品规格 Where 药品id = 药品id_In;
    Update 药品特性 Set 处方限量 = 处方限量_In, 是否皮试 = v_是否皮试 Where 药名id = n_药名id;
  
    Delete From 药品用法用量 Where 药品id = 药品id_In And 性质 = 0;
    v_Records := 过敏试验id_In;
  
    While v_Records Is Not Null Loop
      v_Currrec := Substr(v_Records, 1, Instr(v_Records, '|') - 1);
      v_Fields  := v_Currrec;
      v_用法id  := To_Number(v_Fields);
      Insert Into 药品用法用量 (药品id, 用法id, 性质) Values (药品id_In, v_用法id, 0);
      v_Records := Replace('|' || v_Records, '|' || v_Currrec || '|');
    End Loop;
  
    --用法用量
    Delete From 药品用法用量 Where 药品id = 药品id_In And 性质 > 0;
    If 用法用量_In Is Null Then
      v_Records := Null;
    Else
      v_Records := 用法用量_In || '|';
    End If;
    v_性质 := 0;
    While v_Records Is Not Null Loop
      v_Currrec  := Substr(v_Records, 1, Instr(v_Records, '|') - 1);
      v_Fields   := v_Currrec;
      v_用法id   := To_Number(Substr(v_Fields, 1, Instr(v_Fields, '^') - 1));
      v_Fields   := Substr(v_Fields, Instr(v_Fields, '^') + 1);
      v_频次     := Substr(v_Fields, 1, Instr(v_Fields, '^') - 1);
      v_Fields   := Substr(v_Fields, Instr(v_Fields, '^') + 1);
      v_成人剂量 := To_Number(Substr(v_Fields, 1, Instr(v_Fields, '^') - 1));
      v_Fields   := Substr(v_Fields, Instr(v_Fields, '^') + 1);
      v_小儿剂量 := To_Number(Substr(v_Fields, 1, Instr(v_Fields, '^') - 1));
      v_Fields   := Substr(v_Fields, Instr(v_Fields, '^') + 1);
      v_医生嘱托 := Substr(v_Fields, 1, Instr(v_Fields, '^') - 1);
      v_Fields   := Substr(v_Fields, Instr(v_Fields, '^') + 1);
      v_Ddd值    := To_Number(v_Fields);
      v_性质     := v_性质 + 1;
    
      Insert Into 药品用法用量
        (药品id, 用法id, 频次, 成人剂量, 小儿剂量, 医生嘱托, 疗程, Ddd值, 性质)
      Values
        (药品id_In, v_用法id, v_频次, v_成人剂量, v_小儿剂量, v_医生嘱托, 疗程_In, v_Ddd值, 1);
    
      v_Records := Replace('|' || v_Records, '|' || v_Currrec || '|');
    End Loop;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_用法用量_Update;
/

--120719:王振涛,2018-01-23,消息处理
--118566:李小东,2017-12-22,老版LIS检验项目管理修改站点为空
CREATE OR REPLACE Procedure Zl_检验项目_Edit
(
  编辑类型_In   In Number, --1-增加；2-修改；3-删除
  Id_In         In 诊疗项目目录.Id%Type,
  诊疗分类id_In In 诊疗项目目录.分类id%Type := Null,
  操作类型_In   In 诊疗项目目录.操作类型%Type := Null,
  编码_In       In 诊疗项目目录.编码%Type := Null,
  名称_In       In 诊疗项目目录.名称%Type := Null,
  名称拼音_In   In 诊疗项目别名.简码%Type := Null,
  名称五笔_In   In 诊疗项目别名.简码%Type := Null,
  别名_In       In 诊疗项目别名.名称%Type := Null,
  英文名_In     In 检验项目.缩写%Type := Null,
  计算单位_In   In 诊疗项目目录.计算单位%Type := Null,
  标本部位_In   In 诊疗项目目录.标本部位%Type := Null,
  适用性别_In   In 诊疗项目目录.适用性别%Type := Null,
  单独应用_In   In 诊疗项目目录.单独应用%Type := Null,
  组合项目_In   In 诊疗项目目录.组合项目%Type := Null,
  排列序号_In   In 检验项目.排列序号%Type := Null,
  检验方法_In   In 检验项目.检验方法%Type := Null,

  项目类别_In In 检验项目.项目类别%Type := Null,
  结果类型_In In 检验项目.结果类型%Type := Null,
  结果范围_In In 检验项目.结果范围%Type := Null,
  默认值_In   In 检验项目.默认值%Type := Null,
  计算公式_In In 检验项目.计算公式%Type := Null,
  取值序列_In In 检验项目.取值序列%Type := Null,
  隐私项目_In In 检验项目.隐私项目%Type := Null,
  多参考_In   In 检验项目.多参考%Type := Null,

  阳性公式_In   In 检验项目.阳性公式%Type := Null,
  弱阳性公式_In In 检验项目.弱阳性公式%Type := Null,
  Cutoff公式_In In 检验项目.Cutoff公式%Type := Null

) Is
  v_服务对象   诊疗项目目录.服务对象%Type;
  v_组合项目   诊疗项目目录.组合项目%Type;
  v_执行科室   诊疗项目目录.执行科室%Type;
  v_报告项目id 检验报告项目.报告项目id%Type := 0;
  v_站点       诊疗项目目录.站点%Type;
  v_编码       诊治所见项目.编码%Type;
  v_中文名     诊治所见项目.中文名%Type;
  v_英文名     诊治所见项目.英文名%Type;

  Function Get_诊治项目id(诊疗项目id_In In 诊疗项目目录.Id%Type) Return Number Is
    v_诊治项目id 诊治所见项目.Id%Type;
  Begin
    Select 报告项目id Into v_诊治项目id From 检验报告项目 Where 诊疗项目id = 诊疗项目id_In And 报告项目id Is Not Null;
    Return v_诊治项目id;
  Exception
    When Others Then
      Return Null;
  End Get_诊治项目id;

Begin
  If 编辑类型_In = 1 Then
    Zl_诊疗项目_Insert('C', 诊疗分类id_In, Id_In, 编码_In, 名称_In, 名称拼音_In, 名称五笔_In, 别名_In, 名称拼音_In, 名称五笔_In, 操作类型_In, 1, 单独应用_In,
                   3, 计算单位_In, 适用性别_In, 0, 3, 组合项目_In, 标本部位_In, Null, 4, Null, Null, Null, Null, 0);
    --Update 诊疗项目目录 Set 排列序号 = 排列序号_In Where ID = Id_In;
    If 组合项目_In = 0 Then
      Select 诊治所见项目_Id.Nextval Into v_报告项目id From Dual;
    End If;
    Begin
      b_Message.Zlhis_Dict_017(Id_In);
    Exception
      When Others Then
        Null;
    End;
  Elsif 编辑类型_In = 2 Then
    Select 服务对象, Nvl(组合项目, 0), 执行科室, 站点
    Into v_服务对象, v_组合项目, v_执行科室, v_站点
    From 诊疗项目目录
    Where ID = Id_In;
    Zl_诊疗项目_Update('C', 诊疗分类id_In, Id_In, 编码_In, 名称_In, 名称拼音_In, 名称五笔_In, 别名_In, 名称拼音_In, 名称五笔_In, 操作类型_In, 1, 单独应用_In,
                   3, 计算单位_In, 适用性别_In, 0, v_服务对象, 组合项目_In, 标本部位_In, Null, v_执行科室, Null, Null, Null, Null, 1, 0, Null, 0,
                   0, 0, v_站点);
    --Update 诊疗项目目录 Set 排列序号 = 排列序号_In Where ID = Id_In;
    If v_组合项目 = 0 Then
      v_报告项目id := Get_诊治项目id(Id_In);
      If 组合项目_In = 1 Then
        Delete 检验报告项目 Where 诊疗项目id = Id_In And 细菌id Is Null;
        Delete 诊治所见项目 Where ID = v_报告项目id;
      End If;
    Else
      If 组合项目_In = 0 Then
        Delete 检验报告项目 Where 诊疗项目id = Id_In;
        Select 诊治所见项目_Id.Nextval Into v_报告项目id From Dual;
      End If;
    End If;
    -- 用老版程序增加的项目,可能没有报告项目id 2007-07-13
    If Nvl(v_报告项目id, 0) = 0 Then
      Select 诊治所见项目_Id.Nextval Into v_报告项目id From Dual;
    End If;
    Begin
      b_Message.Zlhis_Dict_018(Id_In);
    Exception
      When Others Then
        Null;
    End;
  Elsif 编辑类型_In = 3 Then
   
    Select Nvl(组合项目, 0) Into v_组合项目 From 诊疗项目目录 Where ID = Id_In;
    If v_组合项目 = 0 Then
      v_报告项目id := Get_诊治项目id(Id_In);
      Select 编码, 中文名, 英文名 Into v_编码, v_中文名, v_英文名 From 诊治所见项目 Where ID = v_报告项目id;
      Delete 检验报告项目 Where 诊疗项目id = Id_In;
      Delete 诊治所见项目 Where ID = v_报告项目id;
    End If;
    Delete 诊疗项目目录 Where ID = Id_In;
    Begin
      b_Message.Zlhis_Dict_019(Id_In,v_编码,v_中文名,v_英文名);
    Exception
      When Others Then
        Null;
    End;

    Return;
  End If;

  If 组合项目_In = 0 Then
    Update 诊治所见项目
    Set 编码 = 编码_In, 中文名 = 名称_In, 英文名 = 英文名_In, 替换域 = 0, 类型 = Decode(结果类型_In, 1, 0, 2, 1, 3, 3),
        长度 = Decode(结果类型_In, 1, 10, 2, 100, 3, 10), 小数 = Decode(结果类型_In, 1, 3, 2, 0, 3, 0), 单位 = 计算单位_In, 表示法 = 0,
        性别域 = 适用性别_In
    Where ID = v_报告项目id;
    If Sql%RowCount = 0 Then
      Insert Into 诊治所见项目
        (ID, 编码, 中文名, 英文名, 替换域, 类型, 长度, 小数, 单位, 表示法, 性别域)
      Values
        (v_报告项目id, 编码_In, 名称_In, 英文名_In, 0, Decode(结果类型_In, 1, 0, 2, 1, 3, 3), Decode(结果类型_In, 1, 10, 2, 100, 3, 10),
         Decode(结果类型_In, 1, 3, 2, 0, 3, 0), 计算单位_In, 0, 适用性别_In);
      Insert Into 检验报告项目
        (ID, 诊疗项目id, 报告项目id, 检验标本)
      Values
        (检验报告项目_Id.Nextval, Id_In, v_报告项目id, 标本部位_In);
    Else
      Update 检验报告项目 Set 检验标本 = 标本部位_In Where 诊疗项目id = Id_In And 报告项目id = v_报告项目id;
    End If;

    Update 检验项目
    Set 缩写 = 英文名_In, 单位 = 计算单位_In, 项目类别 = 项目类别_In, 结果类型 = 结果类型_In, 结果范围 = 结果范围_In, 默认值 = 默认值_In, 计算公式 = 计算公式_In,
        取值序列 = 取值序列_In, 隐私项目 = 隐私项目_In, 阳性公式 = 阳性公式_In, 弱阳性公式 = 弱阳性公式_In, Cutoff公式 = Cutoff公式_In, 排列序号 = 排列序号_In,
        检验方法 = 检验方法_In, 多参考 = 多参考_In
    Where 诊治项目id = v_报告项目id;
    If Sql%RowCount = 0 Then
      Insert Into 检验项目
        (诊治项目id, 缩写, 单位, 项目类别, 结果类型, 结果范围, 默认值, 计算公式, 取值序列, 隐私项目, 阳性公式, 弱阳性公式, Cutoff公式, 排列序号, 检验方法, 多参考)
      Values
        (v_报告项目id, 英文名_In, 计算单位_In, 项目类别_In, 结果类型_In, 结果范围_In, 默认值_In, 计算公式_In, 取值序列_In, 隐私项目_In, 阳性公式_In, 弱阳性公式_In,
         Cutoff公式_In, 排列序号_In, 检验方法_In, 多参考_In);
    End If;
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_检验项目_Edit;
/

--118837:刘鹏飞,2017-12-22,输血申请新增输血同意书和评估选项
Create Or Replace Procedure Zl_输血申请记录_Insert
(
  医嘱id_In           输血申请记录.医嘱id%Type,
  是否待诊_In         输血申请记录.是否待诊%Type,
  输血类型_In         输血申请记录.输血类型%Type,
  输血目的_In         输血申请记录.输血目的%Type,
  输血性质_In         输血申请记录.输血性质%Type,
  即往输血史_In       输血申请记录.即往输血史%Type,
  既往输血反应史_In   输血申请记录.既往输血反应史%Type,
  输血禁忌及过敏史_In 输血申请记录.输血禁忌及过敏史%Type,
  孕产情况_In         输血申请记录.孕产情况%Type,
  受血者属地_In       输血申请记录.受血者属地%Type,
  输血血型_In         输血申请记录.输血血型%Type,
  Rhd_In              输血申请记录.Rhd%Type,
  是否签订同意书_In   输血申请记录.是否签订同意书%Type := Null,
  是否已评估_In       输血申请记录.是否已评估%Type := Null,
  输血项目_In         Varchar2 := Null
) Is

Begin
  --先删除原有的数据 
  Delete From 输血申请记录 Where 医嘱id = 医嘱id_In;
  Insert Into 输血申请记录
    (医嘱id, 是否待诊, 输血类型, 输血目的, 输血性质, 即往输血史, 既往输血反应史, 输血禁忌及过敏史, 孕产情况, 受血者属地, 输血血型, Rhd, 是否签订同意书, 是否已评估)
  Values
    (医嘱id_In, 是否待诊_In, 输血类型_In, 输血目的_In, 输血性质_In, 即往输血史_In, 既往输血反应史_In, 输血禁忌及过敏史_In, 孕产情况_In, 受血者属地_In, 输血血型_In, Rhd_In,
     是否签订同意书_In, 是否已评估_In);

  Zl_输血申请项目_Upate(医嘱id_In, 输血项目_In);
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_输血申请记录_Insert;
/

--121419:刘鹏飞,2018-02-06,用血申请医生确定血液信息
Create Or Replace Procedure Zl_输血申请项目_Upate
(
  医嘱id_In In 输血申请记录.医嘱id%Type,
  Para_In   In Varchar2
) Is
  Strdata      Varchar2(1000);
  Intpos       Number(5);
  Strtext      Varchar2(100);
  n_诊疗项目id 输血申请项目.诊疗项目id%Type;
  n_申请量     输血申请项目.申请量%Type;
  v_申请血型   输血申请项目.申请血型%Type;
  v_申请rh     输血申请项目.申请rh%Type;
  v_血液信息   输血申请项目.血液信息%Type;
Begin
  --删除所有体温部位
  Delete 输血申请项目 Where 医嘱id = 医嘱id_In;
  --参数格式为 诊疗项目ID,申请量,申请血型,申请RH,血液收发ID串;诊疗项目ID,申请量,申请血型,申请RH,血液收发ID串.....
  ------------血液收发ID串存放血液收发记录的ID，多个ID之间以'|'号分割,只有用血申请采用医生下达申请确定血液的模式才会有
  Strdata := Para_In;
  Intpos  := Instr(Strdata, ';', 1);
  If Intpos > 0 Then
    Strtext := Substr(Strdata, 1, Instr(Strdata, ';', 1) - 1);
    Strdata := Substr(Strdata, Instr(Strdata, ';', 1) + 1);
  Else
    Strtext := Strdata;
    Strdata := '';
  End If;

  While Strtext Is Not Null Loop
    n_诊疗项目id := Substr(Strtext, 1, Instr(Strtext, ',', 1) - 1);
    Strtext      := Substr(Strtext, Instr(Strtext, ',', 1) + 1);
    n_申请量     := Substr(Strtext, 1, Instr(Strtext, ',', 1) - 1);
    Strtext      := Substr(Strtext, Instr(Strtext, ',', 1) + 1);
    v_申请血型   := Substr(Strtext, 1, Instr(Strtext, ',', 1) - 1);
    Strtext      := Substr(Strtext, Instr(Strtext, ',', 1) + 1);
    Intpos       := Instr(Strtext, ',', 1);
    If Intpos > 0 Then
      v_申请rh   := Substr(Strtext, 1, Instr(Strtext, ',', 1) - 1);
      v_血液信息 := Substr(Strtext, Instr(Strtext, ',', 1) + 1);
    Else
      v_血液信息 := '';
      v_申请rh   := Strtext;
    End If;
  
    Insert Into 输血申请项目
      (医嘱id, 诊疗项目id, 申请量, 申请血型, 申请rh, 血液信息)
    Values
      (医嘱id_In, n_诊疗项目id, n_申请量, v_申请血型, v_申请rh, v_血液信息);
  
    Intpos := Instr(Strdata, ';', 1);
    If Intpos > 0 Then
      Strtext := Substr(Strdata, 1, Instr(Strdata, ';', 1) - 1);
      Strdata := Substr(Strdata, Instr(Strdata, ';', 1) + 1);
    Else
      Strtext := Strdata;
      Strdata := '';
    End If;
  End Loop;

Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_输血申请项目_Upate;
/

--110624:刘涛,2018-01-23,外购直接修改信息
--109990:刘涛,2018-01-12,药品批号对照修改
--118802:刘涛,2017-12-21,药品卫材验收结论处理
Create Or Replace Procedure Zl_药品外购_Insert
(
  No_In         In 药品收发记录.No%Type,
  序号_In       In 药品收发记录.序号%Type,
  库房id_In     In 药品收发记录.库房id%Type,
  对方部门id_In In 药品收发记录.对方部门id%Type,
  供药单位id_In In 药品收发记录.供药单位id%Type,
  药品id_In     In 药品收发记录.药品id%Type,
  产地_In       In 药品收发记录.产地%Type := Null,
  批号_In       In 药品收发记录.批号%Type := Null,
  效期_In       In 药品收发记录.效期%Type := Null,
  实际数量_In   In 药品收发记录.实际数量%Type := Null,
  成本价_In     In 药品收发记录.成本价%Type := Null,
  成本金额_In   In 药品收发记录.成本金额%Type := Null,
  扣率_In       In 药品收发记录.扣率%Type := Null,
  零售价_In     In 药品收发记录.零售价%Type := Null,
  零售金额_In   In 药品收发记录.零售金额%Type := Null,
  差价_In       In 药品收发记录.差价%Type := Null,
  摘要_In       In 药品收发记录.摘要%Type := Null,
  填制人_In     In 药品收发记录.填制人%Type := Null,
  发票号_In     In 应付记录.发票号%Type := Null,
  发票日期_In   In 应付记录.发票日期%Type := Null,
  发票金额_In   In 应付记录.发票金额%Type := Null,
  填制日期_In   In 药品收发记录.填制日期%Type := Null,
  外观_In       In 药品收发记录.外观%Type := Null,
  产品合格证_In In 药品收发记录.产品合格证%Type := Null,
  核查人_In     In 药品收发记录.配药人%Type := Null,
  核查日期_In   In 药品收发记录.配药日期%Type := Null,
  批次_In       In 药品收发记录.批次%Type := 0,
  退货_In       In Number := 1,
  生产日期_In   In 药品收发记录.生产日期%Type := Null,
  批准文号_In   In 药品收发记录.批准文号%Type := Null,
  随货单号_In   In 应付记录.随货单号%Type := Null,
  金额差_In     In 药品收发记录.零售金额%Type := Null,
  加成率_In     In 药品收发记录.频次%Type := Null,
  发票代码_In   In 应付记录.发票代码%Type := Null,
  计划id_In     In 药品收发记录.计划id%Type := Null,
  财务审核_In   In Number := 0,
  原产地_In     In 药品收发记录.原产地%Type := Null,
  随货日期_In   In 应付记录.随货日期%Type := Null,
  验收结论_In   In 药品收发记录.验收结论%Type := Null,
  修改人_In     In 药品收发记录.修改人%Type := Null,
  修改日期_In   In 药品收发记录.修改日期%Type := Null
) Is
  v_No         应付记录.No%Type; --应付记录的NO
  v_商品名     收费项目目录.名称%Type; --通用名称
  v_规格       收费项目目录.规格%Type;
  v_产地       收费项目目录.规格%Type;
  v_单位       收费项目目录.计算单位%Type;
  v_Lngid      药品收发记录.Id%Type; --收发ID
  v_应付id     应付记录.Id%Type; --应付记录的ID
  v_入出类别id 药品收发记录.入出类别id%Type; --入出类别ID
  v_入出系数   药品收发记录.入出系数%Type; --入出系数
  v_批次       药品收发记录.批次%Type := Null; --批次
  v_药库分批   Integer; --是否药库分批    1:分批；0：不分批
  v_药房分批   Integer; --是否药房分批       1:分批；0：不分批
  v_指导批价   药品规格.指导批发价%Type;
  v_时价分批   Number(1);

  Err_Msg Varchar2(255);
  Err_Noenough Exception;
Begin

  If Not 批准文号_In Is Null And Not 产地_In Is Null Then
    Update 药品生产商对照 Set 批准文号 = 批准文号_In Where 药品id = 药品id_In And 厂家名称 = 产地_In;
  End If;
  If Sql%RowCount = 0 And Not 产地_In Is Null And Not 批准文号_In Is Null Then
    Insert Into 药品生产商对照 (药品id, 厂家名称, 批准文号) Values (药品id_In, 产地_In, 批准文号_In);
  End If;

  --取该药品的商品名
  v_产地 := '';
  Select 名称, 规格, 计算单位, Nvl(是否变价, 0)
  Into v_商品名, v_规格, v_单位, v_时价分批
  From 收费项目目录
  Where ID = 药品id_In;
  If v_规格 Is Not Null Then
    If Instr(v_规格, '|') <> 0 Then
      v_产地 := Substr(v_规格, Instr(v_规格, '|'));
      v_规格 := Substr(v_规格, Instr(v_规格, '|') - 1);
    End If;
  End If;

  Select 药品收发记录_Id.Nextval Into v_Lngid From Dual;
  Select Nvl(药库分批, 0), Nvl(药房分批, 0), Nvl(指导批发价, 0)
  Into v_药库分批, v_药房分批, v_指导批价
  From 药品规格
  Where 药品id = 药品id_In;

  --财务审核_in=0表示普通入库，财务审核_in=1表示是财务审核产生新单据，如果是财务审核模式不需要重新产生批次
  If 财务审核_In = 0 Then
    If v_药房分批 = 0 Then
      If v_药库分批 = 1 Then
        Begin
          Select Distinct 0
          Into v_药库分批
          From 部门性质说明
          Where ((工作性质 Like '%药房') Or (工作性质 Like '制剂室')) And 部门id = 库房id_In;
        Exception
          When Others Then
            v_药库分批 := 1;
        End;
      
        If v_药库分批 = 1 Then
          v_批次 := Zl_Fun_Getbatchnum(药品id_In, 产地_In, 批号_In, 成本价_In, 零售价_In, v_Lngid, 供药单位id_In);
        End If;
      End If;
    Else
      v_批次 := Zl_Fun_Getbatchnum(药品id_In, 产地_In, 批号_In, 成本价_In, 零售价_In, v_Lngid, 供药单位id_In);
    End If;
  Else
    v_批次 := 批次_In;
  End If;

  If v_时价分批 = 1 And v_批次 > 0 Then
    v_时价分批 := 1;
  Else
    v_时价分批 := 0;
  End If;

  Select b.Id, b.系数
  Into v_入出类别id, v_入出系数
  From 药品单据性质 A, 药品入出类别 B
  Where a.类别id = b.Id And a.单据 = 1 And Rownum < 2;

  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 供药单位id, 入出类别id, 对方部门id, 入出系数, 药品id, 批次, 产地,原产地, 批号, 效期, 填写数量, 实际数量, 成本价, 成本金额, 扣率, 零售价,
     零售金额, 差价, 摘要, 填制人, 填制日期, 配药人, 配药日期, 发药方式, 单量, 外观, 产品合格证, 生产日期, 批准文号, 用法, 频次, 计划id, 验收结论, 修改人, 修改日期)
  Values
    (v_Lngid, 1, 1, No_In, 序号_In, 库房id_In, 供药单位id_In, v_入出类别id, 对方部门id_In, v_入出系数, 药品id_In,
     Decode(退货_In, -1, 批次_In, v_批次), 产地_In, 原产地_In,批号_In, 效期_In, 退货_In * 实际数量_In, 退货_In * 实际数量_In, 成本价_In, 退货_In * 成本金额_In,
     扣率_In, 零售价_In, 退货_In * 零售金额_In, 退货_In * 差价_In, 摘要_In, 填制人_In, 填制日期_In, 核查人_In, 核查日期_In, Decode(退货_In, -1, 1, 0),
     v_指导批价, 外观_In, 产品合格证_In, 生产日期_In, 批准文号_In, Decode(退货_In, -1, Null, Decode(v_时价分批, 1, 金额差_In, Null)), 加成率_In,
     计划id_In, 验收结论_In, 修改人_In, 修改日期_In);
  
  Zl_未审药品记录_Insert(v_Lngid);

  --调用库存更新过程
  Zl_药品库存_Update(v_Lngid, 0);

  If 发票号_In Is Not Null Or 随货单号_In Is Not Null Then
    --如果是第一笔明细,则产生应付记录的NO
    Begin
      Select NO
      Into v_No
      From 应付记录
      Where 系统标识 = 1 And 记录性质 = 0 And 记录状态 = 1 And 入库单据号 = No_In And Rownum < 2;
    Exception
      When Others Then
        v_No := Nextno(67);
    End;
    Select 应付记录_Id.Nextval Into v_应付id From Dual;
    Insert Into 应付记录
      (ID, 记录性质, 记录状态, 单位id, NO, 系统标识, 收发id, 入库单据号, 单据金额, 发票号, 发票日期, 发票金额, 品名, 规格, 产地, 批号, 计量单位, 数量, 采购价, 采购金额, 填制人,
       填制日期, 审核人, 审核日期, 摘要, 项目id, 序号, 随货单号, 库房id, 发票修改时间, 发票代码, 随货日期)
    Values
      (v_应付id, 0, 1, 供药单位id_In, v_No, 1, v_Lngid, No_In, 退货_In * 零售金额_In, 发票号_In, 发票日期_In,
       退货_In * Decode(Nvl(发票金额_In, 0), 0, 成本金额_In, 发票金额_In), v_商品名, v_规格, v_产地, 批号_In, v_单位, 退货_In * 实际数量_In, 成本价_In,
       退货_In * 成本金额_In, 填制人_In, 填制日期_In, Null, Null, 摘要_In, 药品id_In, 序号_In, 随货单号_In, 库房id_In, Sysdate, 发票代码_In, 随货日期_In);
  End If;
Exception
  When Err_Noenough Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品外购_Insert;
/

--118802:刘涛,2017-12-21,药品卫材验收结论处理
Create Or Replace Procedure Zl_药品验收明细_Insert
(
  验收id_In   In 药品验收明细.验收id%Type,
  药品id_In   In 药品验收明细.药品id%Type,
  成本价_In   In 药品验收明细.成本价%Type := Null,
  零售价_In   In 药品验收明细.零售价%Type := Null,
  进药数量_In In 药品验收明细.进药数量%Type := Null,
  批号_In     In 药品验收明细.批号%Type := Null,
  生产日期_In In 药品验收明细.生产日期%Type := Null,
  效期_In     In 药品验收明细.效期%Type := Null,
  产地_In     In 药品验收明细.产地%Type := Null,
  批准文号_In In 药品验收明细.批准文号%Type := Null,
  进药日期_In In 药品验收明细.进药日期%Type := Null,
  是否合格_In In 药品验收明细.是否合格%Type := 0,
  验收结论_In In 药品验收明细.验收结论%Type := Null
) Is
Begin
  Insert Into 药品验收明细
    (验收id, 药品id, 成本价, 零售价, 进药数量, 批号, 生产日期, 效期, 产地, 批准文号, 进药日期, 是否合格, 验收结论)
  Values
    (验收id_In, 药品id_In, 成本价_In, 零售价_In, 进药数量_In, 批号_In, 生产日期_In, 效期_In, 产地_In, 批准文号_In, 进药日期_In, 是否合格_In, 验收结论_In);

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End;
/

--119913:涂建华,2018-01-11,统一调整blob的读取方式
Create Or Replace Package b_Pacs_Rptmanage Is
  Type t_Refcur Is Ref Cursor;

  --1、锁定报告人
  Procedure p_Edit_Doc_Lockinfo
  (
    报告_Id_In 影像报告记录.Id%Type,
    锁定人_In  影像报告记录.锁定人%Type
  );

  --2、评定报告质量
  Procedure p_Edit_Doc_Evaluatrptquality
  (
    报告id_In   影像报告记录.Id%Type,
    质量等级_In 影像报告记录.报告质量%Type
  );

  --3、评定阴阳性
  Procedure p_Edit_Doc_Evaluatresult
  (
    报告id_In   影像报告记录.Id%Type,
    检查结果_In 影像报告记录.结果阳性%Type
  );

  --4、报告发放/回收
  Procedure p_Edit_Doc_Reportrelease
  (
    报告id_In     影像报告记录.Id%Type,
    当前操作人_In 影像报告记录.报告发放人%Type
  );

  --5、新增，修改报告
  Procedure p_影像报告记录_新增
  (
    原型id_In     影像报告记录.原型id%Type,
    报告内容_In   影像报告记录.报告内容%Type,
    记录人_In     影像报告记录.记录人%Type,
    最后编辑人_In 影像报告记录.最后编辑人%Type,
    Id_In         影像报告记录.Id%Type,
    医嘱id_In     影像报告记录.医嘱id%Type
  );

  --6、获取书写的文档内容
  Procedure p_Get_Doc_Content
  (
    Val      Out t_Refcur,
    Docid_In 影像报告记录.Id%Type
  );

  --7、设置报告打印作废信息
  Procedure p_Checkrejectsignature
  (
    Signdate_In Date,
    报告id_In   影像报告操作记录.报告id%Type,
    作废人_In   影像报告操作记录.作废人%Type,
    作废说明_In 影像报告操作记录.作废说明%Type,
    Val         Out Sys_Refcursor
  );

  --8、查询相应原型下的最大序号
  Procedure p_Get_Samplelist_Maxseqnum
  (
    Val       Out t_Refcur,
    原型id_In 影像报告范文清单.原型id%Type
  );

  --9、删除文档范文
  Procedure p_Del_影像报告范文清单(Id_In 影像报告范文清单.Id%Type);

  --10、添加文档的操作日志
  Procedure p_影像报告操作记录_Add
  (
    Id_In       影像报告操作记录.Id%Type,
    报告id_In   影像报告操作记录.报告id%Type,
    操作人_In   影像报告操作记录.操作人%Type,
    操作类型_In 影像报告操作记录.操作类型%Type
  );

  --11、删除报告
  Procedure p_影像报告记录_删除(报告_Id_In 影像报告记录.Id%Type);

  --12、获取签名类型
  Procedure p_Get_Sysconfigsignature
  (
    Val       Out t_Refcur,
    科室id_In In 部门表.Id%Type
  );

  --13、获取账户签名印章
  Procedure p_Get_Personsignimg
  (
    Val   Out t_Refcur,
    Id_In In 人员表.Id%Type
  );

  --14、获取签名的证书信息
  Procedure p_Get_Signcertinfo
  (
    Val       Out t_Refcur,
    证书id_In 人员证书记录.Id%Type
  );

  --15、更新报告状态
  Procedure p_Update_Reportstate
  (
    报告id_In   影像报告记录.Id%Type,
    报告状态_In 影像报告记录.报告状态%Type,
    审核人_In   影像报告记录.最后审核人%Type
  );

  --16、获取报告状态
  Procedure p_Get_Reportstate
  (
    Val       Out t_Refcur,
    报告id_In 影像报告记录.Id%Type
  );

  --17、报告驳回
  Procedure p_Reject_Report
  (
    医嘱id_In   影像报告驳回.医嘱id%Type,
    报告id_In   影像报告驳回.检查报告id%Type,
    驳回理由_In 影像报告驳回.驳回理由%Type,
    驳回时间_In 影像报告驳回.驳回时间%Type,
    驳回人_In   影像报告驳回.驳回人%Type,
    待处理人_In 影像报告记录.待处理人%Type,
    报告状态_In 影像报告记录.报告状态%Type
  );

  --17.1、撤销报告驳回
  Procedure p_Reject_Cancel
  (
    Id_In       影像报告驳回.Id%Type,
    报告id_In   影像报告驳回.检查报告id%Type,
    报告状态_In 影像报告记录.报告状态%Type
  );

  --18、获取报告驳回信息
  Procedure p_Get_Rejectinfo
  (
    Val       Out t_Refcur,
    报告id_In 影像报告驳回.检查报告id%Type
  );

  --19、获取原型动作
  Procedure p_Get_Doc_Process
  (
    Val       Out t_Refcur,
    原型id_In 影像报告动作.原型id%Type
  );

  --20、通过学科筛选获得相应的范文信息
  Procedure p_Get_Samplelist_By_Conditions
  (
    Val          Out t_Refcur,
    原型id_In    Varchar2,
    学科_In      Varchar2,
    Condition_In Varchar2, --过滤筛选
    作者_In      Varchar2
  );

  --21、通过部门ID获取部门名称
  Procedure p_Get_部门名称_By_Id
  (
    Val   Out t_Refcur,
    Id_In 部门表.Id%Type
  );

  --22、提取所有预备提纲
  Procedure p_Get_Allpreoutlines(Val Out t_Refcur);

  --23、提取文档标题
  Procedure p_Get_Reporttitle_By_Id
  (
    Val   Out t_Refcur,
    Id_In 影像报告记录.Id%Type
  );

  --24、提取报告锁定人
  Procedure p_Get_报告锁定人_By_Id
  (
    Val   Out t_Refcur,
    Id_In 影像报告记录.Id%Type
  );

  --25、通过医嘱ID获取报告列表
  Procedure p_Get_影像报告记录_By_医嘱id
  (
    Val       Out t_Refcur,
    医嘱id_In 影像报告记录.医嘱id%Type
  );

  --26、查询影像流程参数值
  Procedure p_Get_影像流程参数值
  (
    Val       Out t_Refcur,
    科室id_In 影像流程参数.科室id%Type
  );

  --27、根据医嘱ID，查询对应的原型列表
  Procedure p_Get_影像原型列表_By_医嘱id
  (
    Val     Out t_Refcur,
    医嘱_In 影像检查记录.医嘱id%Type
  );

  --28、根据报告ID查询打印记录
  Procedure p_Get_Reportprintlog_By_报告id
  (
    Val     Out Sys_Refcursor,
    报告_In 影像报告操作记录.报告id%Type
  );

  --29、根据医嘱ID查询报告发放列表
  Procedure p_Get_Reportreleaselist
  (
    Val     Out t_Refcur,
    医嘱_In 影像报告记录.医嘱id%Type
  );

  --30、根据报告ID查询驳回记录数量
  Procedure p_Get_Rejectedcount
  (
    Val     Out t_Refcur,
    报告_In 影像报告驳回.检查报告id%Type
  );

  --31、根据医嘱ID查询报告动作需要的一些ID们
  Procedure p_Get_Docprocess_Ids
  (
    Val     Out t_Refcur,
    医嘱_In 病人医嘱记录.Id%Type
  );

  --32、根据医嘱ID和报告ID查询报告的一些参数
  Procedure p_Get_Docinfo
  (
    Val       Out t_Refcur,
    医嘱id_In 影像检查记录.医嘱id%Type,
    报告id_In 影像报告记录.Id%Type
  );

  --33、查询一个检查中相同原型ID的报告数量
  Procedure p_Get_Sameantetypedoccounts
  (
    Val       Out t_Refcur,
    医嘱id_In 影像报告记录.医嘱id%Type,
    原型id_In 影像报告记录.原型id%Type
  );

  --34、提取报告图存储信息
  Procedure p_Get_Docimagesaveinof_By_Id
  (
    Val   Out t_Refcur,
    Id_In 影像报告记录.Id%Type
  );

  --35、修改原型使用次数
  Procedure p_Update_Antetypeusecount(Id_In 影像报告原型清单.Id%Type);

  --36、更新影像检查图像的报告图标记
  Procedure p_Update_Rptimage
  (
    Uid_In        影像检查图象.图像uid%Type,
    Actiontype_In Number
  );

  --37、提取打印控制信息
  Procedure p_Get_Printcontrol
  (
    Val       Out t_Refcur,
    报告id_In 影像报告记录.Id%Type
  );

End b_Pacs_Rptmanage;

/

--影像报告业务(---实现部分---)***************************************************

Create Or Replace Package Body b_Pacs_Rptmanage Is

  --1、锁定报告人
  Procedure p_Edit_Doc_Lockinfo
  (
    报告_Id_In 影像报告记录.Id%Type,
    锁定人_In  影像报告记录.锁定人%Type
  ) Is
  Begin
  
    --  报告ID为空，则清空所有“锁定人_In”正在锁定的标记
    If 报告_Id_In Is Null Then
      Update 影像报告记录 a Set a.锁定人 = '' Where a.锁定人 = 锁定人_In;
    Else
      Update 影像报告记录 a Set a.锁定人 = 锁定人_In Where a.Id = 报告_Id_In;
    End If;
  
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Doc_Lockinfo;

  --2、评定报告质量
  Procedure p_Edit_Doc_Evaluatrptquality
  (
    报告id_In   影像报告记录.Id%Type,
    质量等级_In 影像报告记录.报告质量%Type
  ) Is
  Begin
    Update 影像报告记录 Set 报告质量 = 质量等级_In Where Id = 报告id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Doc_Evaluatrptquality;

  --3、评定阴阳性
  Procedure p_Edit_Doc_Evaluatresult
  (
    报告id_In   影像报告记录.Id%Type,
    检查结果_In 影像报告记录.结果阳性%Type
  ) Is
  Begin
    Update 影像报告记录 Set 结果阳性 = 检查结果_In Where Id = 报告id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Doc_Evaluatresult;

  --4、报告发放/回收
  Procedure p_Edit_Doc_Reportrelease
  (
    报告id_In     影像报告记录.Id%Type,
    当前操作人_In 影像报告记录.报告发放人%Type
  ) Is
    v_报告发放 影像报告记录.报告发放%Type;
  Begin
  
    Begin
      Select Nvl(报告发放, 0) Into v_报告发放 From 影像报告记录 Where Id = 报告id_In;
    Exception
      When Others Then
        v_报告发放 := 0;
    End;
  
    Update 影像报告记录
    Set 报告发放 = Decode(v_报告发放, 0, 1, 0), 报告发放人 = Decode(v_报告发放, 0, 当前操作人_In, '')
    Where Id = 报告id_In;
  
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Doc_Reportrelease;

  --5、新增，修改报告
  Procedure p_影像报告记录_新增
  (
    原型id_In     影像报告记录.原型id%Type,
    报告内容_In   影像报告记录.报告内容%Type,
    记录人_In     影像报告记录.记录人%Type,
    最后编辑人_In 影像报告记录.最后编辑人%Type,
    Id_In         影像报告记录.Id%Type,
    医嘱id_In     影像报告记录.医嘱id%Type
  ) As
    --原型ID_In 原型ID
    --保存文档书写记录
    --1 处理匿名数据
    --2 保存文档书写记录、状态
    --3 处理编辑日志
    --4 更新文档任务
    v_报告id    影像报告记录.Id%Type;
    v_原型名称  影像报告原型清单.名称%Type;
    v_设备号    影像报告原型清单.设备号%Type;
    v_报告序号  Number;
    x_Editlog   Xmltype;
    Cur_Time    Date;
    To_Editlist t_Editlist;
    Tn_Editlist t_Editlist;
    v_Msg       Varchar2(200);
    v_New       Number;
    Err_Custom Exception;
    v_Result 影像报告记录.诊断意见%Type;
    v_操作id 影像报告操作记录.Id%Type;
  
    Function Elist_Filter(Source_t t_Editlist) Return t_Editlist Is
      Target_t t_Editlist := t_Editlist();
    Begin
    
      --对独立文档来说，这个函数只是将 Source_t按照编辑时间排序后输出
      For Rs In (Select /*+rule*/
                  *
                 From Table(Cast(Source_t As t_Editlist)) a
                 Order By a.编辑时间) Loop
        Target_t.Extend;
        Target_t(Target_t.Count) := t_Edits(Rs.编辑人, Rs.编辑时间, Rs.签名, Rs.审订签名);
      End Loop;
      Return Target_t;
    End;
  
    Function Build_Editlog
    (
      Tn_Edit t_Editlist,
      To_Edit t_Editlist,
      v_Did   影像报告记录.Id%Type
    ) Return Xmltype Is
      --Tn_Edit 本次保存的新编辑记录；To_Edit上次保存的旧编辑记录
      --将两次编辑记录，组合成一个编辑记录
    
      x_Return Xmltype;
      r_Saveid Raw(16);
      n_Class  Number;
      --n_Class 编辑日志中的操作类别： 1-创建、2-删除、3-编辑、4-签名、5-审订、6-审签、7-撤签
      v_Signor  影像报告记录.创建人%Type;
      v_Adjunct 影像报告记录.创建人%Type;
      Tns_Edit  t_Editlist;
      Tos_Edit  t_Editlist;
    
      Function Atitle(原型id 影像报告原型清单.Id%Type) Return Varchar2 Is
        v_原型名称 影像报告原型清单.名称%Type;
      Begin
        --根据原型ID，返回原型名称
        If 原型id Is Null Then
          Return Null;
        Else
          Select 名称 Into v_原型名称 From 影像报告原型清单 Where Id = 原型id;
          Return v_原型名称;
        End If;
      End;
    
    Begin
      x_Return := Xmltype('<root></root>');
      If v_Did Is Null Then
        --表明是新增文档，新增文档传null进来
        Select Sys_Guid() Into r_Saveid From Dual;
      
        --PACS报告没有子文档，但是下面构造XML的语句保留成跟EMR相同，这里的v_Subiid赋值为空
        Tns_Edit := Elist_Filter(Tn_Edit);
        Select Decode(Tns_Edit(Tns_Edit.Count).签名, 0, 1, 4) Into n_Class From Dual;
        Select Appendchildxml(x_Return,
                               '/root',
                               Xmlelement("operate",
                                          Xmlforest(r_Saveid As "saving_id",
                                                    n_Class As "class",
                                                    To_Char(Cur_Time, 'yyyy-mm-dd hh24:mi:ss') As "cur_time",
                                                    最后编辑人_In As "operator",
                                                    Decode(n_Class, 4, Tns_Edit(Tns_Edit.Count).编辑人, '') As "signer",
                                                    '' As Adjunct)))
        Into x_Return
        From Dual;
      Else
        --不是新增的文档？
        Select Sys_Guid() Into r_Saveid From Dual;
      
        v_Signor  := '';
        v_Adjunct := '';
        Tns_Edit  := Elist_Filter(Tn_Edit);
        Tos_Edit  := Elist_Filter(To_Edit);
        If Tns_Edit(Tns_Edit.Count).签名 = 1 And Tns_Edit(Tns_Edit.Count).审订签名 = 0 Then
          --最近一次是签名
          If Tos_Edit.Count = 0 Then
            --新增子文档直接签名
            n_Class  := 4;
            v_Signor := Tns_Edit(Tns_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count).编辑人 Is Null Then
            --之前没签名
            n_Class  := 4;
            v_Signor := Tns_Edit(Tns_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count).签名 = 1 And Tns_Edit(Tns_Edit.Count).编辑时间 > Tos_Edit(Tos_Edit.Count).编辑时间 Then
            --多次普通签名
            n_Class  := 4;
            v_Signor := Tns_Edit(Tns_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count).签名 = 1 And Tns_Edit(Tns_Edit.Count).编辑时间 < Tos_Edit(Tos_Edit.Count).编辑时间 Then
            --撤消多次签名
            n_Class   := 7;
            v_Adjunct := Tos_Edit(Tos_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count).签名 = 1 And Tns_Edit(Tns_Edit.Count).编辑时间 = Tos_Edit(Tos_Edit.Count).编辑时间 Then
            --无变化
            n_Class := -1;
          End If;
        Elsif Tns_Edit(Tns_Edit.Count).签名 = 1 And Tns_Edit(Tns_Edit.Count).审订签名 = 1 Then
          --审订签名
          If Tos_Edit(Tos_Edit.Count).审订签名 = 0 Then
            --之前没审签，可能是已签名或已审订
            n_Class  := 6;
            v_Signor := Tns_Edit(Tns_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count).审订签名 = 1 And Tns_Edit(Tns_Edit.Count).编辑时间 > Tos_Edit(Tos_Edit.Count).编辑时间 Then
            --多次审签
            n_Class  := 6;
            v_Signor := Tns_Edit(Tns_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count).审订签名 = 1 And Tns_Edit(Tns_Edit.Count).编辑时间 < Tos_Edit(Tos_Edit.Count).编辑时间 Then
            --撤消多次审签
            n_Class   := 7;
            v_Adjunct := Tos_Edit(Tos_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count).审订签名 = 1 And Tns_Edit(Tns_Edit.Count).编辑时间 = Tos_Edit(Tos_Edit.Count).编辑时间 Then
            --无变化
            n_Class := -1;
          End If;
        Elsif Tns_Edit(Tns_Edit.Count).编辑人 Is Null And Tos_Edit.Count = 0 Then
          n_Class := 1;
        Elsif Tns_Edit(Tns_Edit.Count).编辑人 Is Null And Tos_Edit(Tos_Edit.Count).签名 = 1 Then
          n_Class   := 7;
          v_Adjunct := Tos_Edit(Tos_Edit.Count).编辑人;
        Elsif Tns_Edit(Tns_Edit.Count).编辑人 Is Null And Tos_Edit(Tos_Edit.Count).编辑人 Is Null Then
          n_Class := 3;
        Elsif Tns_Edit(Tns_Edit.Count).审订签名 = 0 And Tos_Edit(Tos_Edit.Count).审订签名 = 0 Then
          n_Class := 5;
        Elsif Tns_Edit(Tns_Edit.Count).审订签名 = 0 And Tos_Edit(Tos_Edit.Count).审订签名 = 1 Then
          n_Class   := 7;
          v_Adjunct := Tos_Edit(Tos_Edit.Count).编辑人;
        End If;
      
        If n_Class <> -1 Then
          Select Appendchildxml(x_Return,
                                 '/root',
                                 Xmlelement("operate",
                                            Xmlforest(r_Saveid As "saving_id",
                                                      n_Class As "class",
                                                      To_Char(Cur_Time, 'yyyy-mm-dd hh24:mi:ss') As "cur_time",
                                                      最后编辑人_In As "operator",
                                                      Decode(n_Class, 4, v_Signor, 6, v_Signor, '') As "signer",
                                                      v_Adjunct As Adjunct)))
          Into x_Return
          From Dual;
        End If;
      
      End If;
      Return x_Return;
    End Build_Editlog;
  
    Function Get_Nextrptnum
    (
      Antetypename 影像报告原型清单.名称%Type,
      Order_Id     影像报告记录.医嘱id%Type
    ) Return Number Is
      v_序号  Number;
      v_Count Number;
      v_Num   Number;
    Begin
    
      v_Count := 0;
      v_Num   := 1;
      Loop
        Select Count(*) + v_Num Into v_序号 From 影像报告记录 Where 医嘱id = Order_Id;
        Select Count(*)
        Into v_Count
        From 影像报告记录
        Where 医嘱id = Order_Id
        And 文档标题 = Antetypename || '_' || v_序号;
      
        If v_Count = 0 Then
          Exit;
        End If;
      
        v_Num := v_Num + 1;
      End Loop;
    
      Return v_序号;
    End;
  
  Begin
  
    Select 名称, 设备号, Sysdate Into v_原型名称, v_设备号, Cur_Time From 影像报告原型清单 Where Id = 原型id_In;
  
    --------------------1 保存文档书写记录、状态--------------------
    --提取文档的签名和编辑（新增、修改）记录
    Tn_Editlist := b_Pacs_Rptpublic.f_Geteditlist(报告内容_In);
  
    --------------------2 处理编辑日志--------------------
    Select Count(*) Into v_New From 影像报告记录 Where Id = Id_In;
  
    v_报告id := Id_In;
    Select Zlpub_Pacs_取提纲内容byxml(报告内容_In, '诊断意见') Into v_Result From Dual;
    If v_New = 0 Then
      --新增报告
      To_Editlist := t_Editlist();
      x_Editlog   := Build_Editlog(Tn_Editlist, To_Editlist, Null);
    
      --取报告序号
      v_报告序号 := Get_Nextrptnum(v_原型名称, 医嘱id_In);
    
      Insert Into 影像报告记录
        (Id, 原型id, 文档标题, 报告内容, 创建时间, 创建人, 报告状态, 最后编辑时间, 最后编辑人, 编辑日志, 医嘱id, 记录人, 诊断意见, 设备号)
      Values
        (v_报告id, 原型id_In, v_原型名称 || '_' || v_报告序号, 报告内容_In, Cur_Time, 最后编辑人_In, 1, Cur_Time, 最后编辑人_In, x_Editlog,
         医嘱id_In, 记录人_In, v_Result, v_设备号);
      Insert Into 病人医嘱报告 (医嘱id, 检查报告id) Values (医嘱id_In, v_报告id);
    
      Select Sys_Guid() Into v_操作id From Dual;
      Insert Into 影像报告操作记录
        (Id, 报告id, 医嘱id, 文档标题, 操作人, 操作时间, 操作类型)
      Values
        (v_操作id, v_报告id, 医嘱id_In, v_原型名称 || '_' || v_报告序号, 最后编辑人_In, Sysdate, 6);
    
    Else
      --提取文件原始编辑记录,必需在更新之前提取
      Select b_Pacs_Rptpublic.f_Geteditlist(报告内容) Into To_Editlist From 影像报告记录 Where Id = v_报告id;
    
      x_Editlog := Build_Editlog(Tn_Editlist, To_Editlist, v_报告id);
      Select Appendchildxml(编辑日志, '/root', Extract(x_Editlog, '/root/*'))
      Into x_Editlog
      From 影像报告记录
      Where Id = v_报告id;
    
      Update 影像报告记录
      Set 报告内容 = 报告内容_In, 最后编辑时间 = Cur_Time, 最后编辑人 = 最后编辑人_In, 编辑日志 = x_Editlog, 记录人 = 记录人_In, 诊断意见 = v_Result
      Where Id = v_报告id;
    End If;
  
  Exception
    When Err_Custom Then
      Raise_Application_Error(-20101, v_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_影像报告记录_新增;

  --6、获取书写的文档内容
  Procedure p_Get_Doc_Content
  (
    Val      Out t_Refcur,
    Docid_In 影像报告记录.Id%Type
  ) As
  Begin
    Open Val For
      Select (Nvl(a.报告内容, Xmltype('<ZLXML/>'))).Getclobval() As 报告内容 From 影像报告记录 a Where a.Id = Docid_In;
  End;

  --7、设置报告打印作废信息
  Procedure p_Checkrejectsignature
  (
    Signdate_In Date,
    报告id_In   影像报告操作记录.报告id%Type,
    作废人_In   影像报告操作记录.作废人%Type,
    作废说明_In 影像报告操作记录.作废说明%Type,
    Val         Out Sys_Refcursor
  ) As
  Begin
    Open Val For
      Select 操作人, 操作时间
      From 影像报告操作记录
      Where 报告id = 报告id_In
      And 操作类型 = 1
      And 操作时间 >= Signdate_In
      And 作废时间 Is Null
      Order By 操作时间 Asc;
    --作废打印记录
    Update 影像报告操作记录 b
    Set 作废人 = 作废人_In, 作废时间 = Sysdate, b.作废说明 = 作废说明_In
    Where 报告id = 报告id_In
    And 操作类型 = 1
    And 操作时间 >= Signdate_In;
  
  End p_Checkrejectsignature;

  --8、查询相应原型下的最大序号
  Procedure p_Get_Samplelist_Maxseqnum
  (
    Val       Out t_Refcur,
    原型id_In 影像报告范文清单.原型id%Type
  ) As
  Begin
    Open Val For
      Select Nvl(Max(a.编号), 0) + 1 As Num From 影像报告范文清单 a Where a.原型id = 原型id_In;
  End;

  --9、删除文档范文
  Procedure p_Del_影像报告范文清单(Id_In 影像报告范文清单.Id%Type) As
  Begin
    Delete From 影像报告范文清单 Where Id = Id_In;
  End;

  --10、添加文档的操作日志
  Procedure p_影像报告操作记录_Add
  (
    Id_In       影像报告操作记录.Id%Type,
    报告id_In   影像报告操作记录.报告id%Type,
    操作人_In   影像报告操作记录.操作人%Type,
    操作类型_In 影像报告操作记录.操作类型%Type
  ) As
    n_医嘱id   影像报告操作记录.医嘱id%Type;
    n_文档标题 影像报告记录.文档标题%Type;
  Begin
  
    Begin
      Select 医嘱id, 文档标题 Into n_医嘱id, n_文档标题 From 影像报告记录 Where Id = 报告id_In;
    Exception
      When Others Then
        Null;
    End;
    If n_医嘱id Is Not Null Then
      Insert Into 影像报告操作记录
        (Id, 报告id, 医嘱id, 文档标题, 操作人, 操作时间, 操作类型)
      Values
        (Id_In, 报告id_In, n_医嘱id, n_文档标题, 操作人_In, Sysdate, 操作类型_In);
      If 操作类型_In = 1 Then
        Update 影像报告记录 Set 报告打印 = 1 Where Id = 报告id_In;
      End If;
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --11、删除报告
  Procedure p_影像报告记录_删除(报告_Id_In 影像报告记录.Id%Type) As
  Begin
  
    Delete From 影像报告记录 Where 影像报告记录.Id = Hextoraw(报告_Id_In);
  
    Delete From 病人医嘱报告 Where 检查报告id = Hextoraw(报告_Id_In);
  
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_影像报告记录_删除;

  --12、获取签名类型
  Procedure p_Get_Sysconfigsignature
  (
    Val       Out t_Refcur,
    科室id_In In 部门表.Id%Type
  ) Is
  Begin
    --返回用户, 模块号,功能
    Open Val For
      Select Zl_Fun_Getsignpar(7, 科室id_In) As 签名类型 From Dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --13、获取账户签名印章
  Procedure p_Get_Personsignimg
  (
    Val   Out t_Refcur,
    Id_In In 人员表.Id%Type
  ) Is
    --v_sql Varchar2(1000);
    --n_count Number(5);
  Begin
    --Select Count(*) Into n_Count From user_tables Where table_name =Upper('影像签名图片');
  
    --If n_Count > 0 Then
    --   v_sql := 'Truncate Table 影像签名图片';
    --   Execute Immediate v_sql;
  
    --   v_sql := 'Insert Into 影像签名图片 Select a.id, to_lob(a.签名图片) as 签名图片 From 人员表 a Where a.ID=' || ID_In;
    --   Execute Immediate v_sql;
    --Else
    --   v_sql := 'Create GLOBAL TEMPORARY TABLE 影像签名图片 ON COMMIT PRESERVE ROWS AS Select a.id, to_lob(a.签名图片) as 签名图片 From 人员表 a Where a.ID=' || ID_In;
    --   Execute Immediate v_sql;
    --End If;
  
    --v_sql := 'Select 签名图片 From 影像签名图片 Where Id=:ID';
  
    ----返回用户, 模块号,功能
    --Open  Val For v_sql Using ID_In;
  
    Open Val For
      Select 签名图片 From 人员表 Where Id = Id_In;
  
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --14、获取签名的证书信息
  Procedure p_Get_Signcertinfo
  (
    Val       Out t_Refcur,
    证书id_In 人员证书记录.Id%Type
  ) Is
  Begin
    Open Val For
      Select Id, Certdn, Certsn, Signcert, Enccert From 人员证书记录 Where Id = 证书id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --15、更新报告状态
  Procedure p_Update_Reportstate
  (
    报告id_In   影像报告记录.Id%Type,
    报告状态_In 影像报告记录.报告状态%Type,
    审核人_In   影像报告记录.最后审核人%Type
  ) Is
  Begin
    --报告状态1-未签名；2-已诊断；3-已审核；4-已终审；5-诊断驳回；6-审核驳回
    --如果报告状态是1-未签名；2-已诊断;5-诊断驳回，此时是没有审核人的
    If (报告状态_In = 1) Or (报告状态_In = 2) Or (报告状态_In = 5) Then
      Update 影像报告记录 Set 报告状态 = 报告状态_In, 最后审核人 = Null, 最后审核时间 = Null Where Id = 报告id_In;
    Elsif (报告状态_In = 3) Or (报告状态_In = 4) Then
      Update 影像报告记录
      Set 报告状态 = 报告状态_In, 最后审核人 = 审核人_In, 最后审核时间 = Sysdate
      Where Id = 报告id_In;
    Else
      Update 影像报告记录 Set 报告状态 = 报告状态_In Where Id = 报告id_In;
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --16、获取报告状态
  Procedure p_Get_Reportstate
  (
    Val       Out t_Refcur,
    报告id_In 影像报告记录.Id%Type
  ) Is
  Begin
    Open Val For
      Select 报告状态 From 影像报告记录 Where Id = 报告id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --17、报告驳回
  Procedure p_Reject_Report
  (
    医嘱id_In   影像报告驳回.医嘱id%Type,
    报告id_In   影像报告驳回.检查报告id%Type,
    驳回理由_In 影像报告驳回.驳回理由%Type,
    驳回时间_In 影像报告驳回.驳回时间%Type,
    驳回人_In   影像报告驳回.驳回人%Type,
    待处理人_In 影像报告记录.待处理人%Type,
    报告状态_In 影像报告记录.报告状态%Type
  ) Is
  Begin
    Insert Into 影像报告驳回
      (Id, 医嘱id, 检查报告id, 驳回理由, 驳回时间, 驳回人)
    Values
      (影像报告驳回_Id.Nextval, 医嘱id_In, 报告id_In, 驳回理由_In, 驳回时间_In, 驳回人_In);
  
    Update 影像报告记录 Set 报告状态 = 报告状态_In, 待处理人 = 待处理人_In Where Id = 报告id_In;
  
    --Update 病人医嘱发送 Set 执行过程=-1 Where 医嘱ID= 医嘱ID_IN;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --17.1、撤销报告驳回
  Procedure p_Reject_Cancel
  (
    Id_In       影像报告驳回.Id%Type,
    报告id_In   影像报告驳回.检查报告id%Type,
    报告状态_In 影像报告记录.报告状态%Type
  ) Is
  Begin
    Update 影像报告驳回 Set 是否撤销 = 1 Where Id = Id_In;
    Update 影像报告记录 Set 报告状态 = 报告状态_In, 待处理人 = '' Where Id = 报告id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --18、获取报告驳回信息
  Procedure p_Get_Rejectinfo
  (
    Val       Out t_Refcur,
    报告id_In 影像报告驳回.检查报告id%Type
  ) Is
  Begin
    Open Val For
      Select a.Id, a.驳回理由, a.驳回时间, a.驳回人, Nvl(a.是否撤销, 0) As 驳回状态, b.报告状态
      From 影像报告驳回 a, 影像报告记录 b
      Where a.检查报告id = 报告id_In
      And a.检查报告id = b.Id
      Order By 驳回时间;
  End;

  --19、获取原型动作
  Procedure p_Get_Doc_Process
  (
    Val       Out t_Refcur,
    原型id_In 影像报告动作.原型id%Type
  ) As
  Begin
    Open Val For
      Select Rawtohex(p.Id) Id, p.名称 As 动作名称, e.名称 As 事件名称, e.种类 As 事件种类, e.元素iid As 元素iid, p.动作类型, p.序号, p.说明, p.可否手工执行,
             (Nvl(p.内容, Xmltype('<NULL/>'))).Getclobval() As 内容, Rawtohex(p.事件id) 事件id
      From 影像报告动作 p, 影像报告事件 e
      Where p.事件id = e.Id(+)
      And p.原型id = 原型id_In
      Order By 动作类型, 序号;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Doc_Process;

  --20、通过学科筛选获得相应的范文信息
  Procedure p_Get_Samplelist_By_Conditions
  (
    Val          Out t_Refcur,
    原型id_In    Varchar2,
    学科_In      Varchar2,
    Condition_In Varchar2, --过滤筛选
    作者_In      Varchar2
  ) As
  Begin
  
    Open Val For
      Select /*+ rule*/
       Rawtohex(a.Id) Id, a.名称, a.作者, a.说明, Nvl2(a.说明, a.说明 || '作者:' || a.作者, '作者:' || a.作者) Content, a.标签, a.学科
      From 影像报告范文清单 a
      Where a.原型id = Hextoraw(原型id_In)
      And ((a.学科 Is Null And a.是否私有 = 0) Or 学科_In Is Null Or a.作者 = 作者_In Or
            (a.学科 Is Not Null And b_Pacs_Rptpublic.f_If_Intersect(a.学科, 学科_In) > 0 And a.是否私有 = 0))
      And (Condition_In Is Null Or
            (a.标签 Is Not Null And Condition_In Is Not Null And b_Pacs_Rptpublic.f_If_Intersect(a.标签, Condition_In) > 0))
      Order By a.编号;
  
  End p_Get_Samplelist_By_Conditions;

  --21、通过部门ID获取部门名称
  Procedure p_Get_部门名称_By_Id
  (
    Val   Out t_Refcur,
    Id_In 部门表.Id%Type
  ) Is
  Begin
    Open Val For
      Select 名称 From 部门表 Where Id = Id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_部门名称_By_Id;

  --22、提取所有预备提纲
  Procedure p_Get_Allpreoutlines(Val Out t_Refcur) Is
  Begin
    Open Val For
      Select Rawtohex(Id) Id, a.编码, a.名称 From 影像报告预备提纲 a Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Allpreoutlines;

  --23、提取文档标题
  Procedure p_Get_Reporttitle_By_Id
  (
    Val   Out t_Refcur,
    Id_In 影像报告记录.Id%Type
  ) Is
  Begin
    Open Val For
      Select 文档标题 From 影像报告记录 Where Id = Id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Reporttitle_By_Id;

  --24、提取报告锁定人
  Procedure p_Get_报告锁定人_By_Id
  (
    Val   Out t_Refcur,
    Id_In 影像报告记录.Id%Type
  ) Is
  Begin
    Open Val For
      Select 锁定人 From 影像报告记录 Where Id = Id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_报告锁定人_By_Id;

  --25、通过医嘱ID获取报告列表
  Procedure p_Get_影像报告记录_By_医嘱id
  (
    Val       Out t_Refcur,
    医嘱id_In 影像报告记录.医嘱id%Type
  ) Is
  Begin
    Open Val For
      Select Rawtohex(Id) As Reportid, Rawtohex(原型id) As Antetypeid, 医嘱id As Orderid, 文档标题 As Reportname,
             创建时间 As Reportdate,
             Decode(Nvl(报告状态, 0), 1, '编辑中', 2, '已诊断', 3, '已审核', 4, '已终审', 5, '诊断驳回', '审核驳回') As Reportstate,
             创建人 As Createuser, 最后审核时间 As Examineydate, 最后审核人 As Examineyuser,
             Decode(Nvl(结果阳性, 0), 1, '阳性', '') As Resultpositive, Nvl(报告质量, 0) As Innerquality, ' ' As Reportquality,
             Decode(Nvl(报告打印, 0), 0, '未打印', '已打印') As Reportprint,
             Decode(Nvl(报告发放, 0), 0, '未发放', '已发放') As Reportrelease, 记录人 As Recdoctor, 锁定人 As RecLocker, ' ' As Locked
      From 影像报告记录
      Where 医嘱id = 医嘱id_In
      Order By Reportdate Desc;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_影像报告记录_By_医嘱id;

  --26、查询影像流程参数值
  Procedure p_Get_影像流程参数值
  (
    Val       Out t_Refcur,
    科室id_In 影像流程参数.科室id%Type
  ) Is
  Begin
    Open Val For
      Select 参数名, 参数值 From 影像流程参数 Where 科室id = 科室id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_影像流程参数值;

  --27、根据医嘱ID，查询对应的原型列表
  Procedure p_Get_影像原型列表_By_医嘱id
  (
    Val     Out t_Refcur,
    医嘱_In 影像检查记录.医嘱id%Type
  ) Is
  Begin
    Open Val For
      Select Rawtohex(c.Id) As Antetypeid, c.名称 As Antetypename, c.说明
      From 病人医嘱记录 a, 影像报告原型应用 b, 影像报告原型清单 c
      Where a.Id = 医嘱_In
      And a.诊疗项目id = b.诊疗项目id
      And b.报告原型id = c.Id
      And a.病人来源 = b.应用场合
      Order By c.使用次数 Desc;
  
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_影像原型列表_By_医嘱id;

  --28、根据报告ID查询打印记录
  Procedure p_Get_Reportprintlog_By_报告id
  (
    Val     Out Sys_Refcursor,
    报告_In 影像报告操作记录.报告id%Type
  ) Is
  Begin
    Open Val For
      Select c.文档标题, b.操作人, To_Char(b.操作时间, 'yyyy-MM-dd HH24:mi') 打印时间, b.作废人,
             To_Char(b.作废时间, 'yyyy-MM-dd HH24:mi') 作废时间, b.作废说明
      From 影像报告操作记录 b, 影像报告记录 c
      Where c.Id = 报告_In
      And b.报告id = c.Id
      And 操作类型 = 1
      Order By b.操作时间;
  
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Reportprintlog_By_报告id;

  --29、根据医嘱ID查询报告发放列表
  Procedure p_Get_Reportreleaselist
  (
    Val     Out t_Refcur,
    医嘱_In 影像报告记录.医嘱id%Type
  ) Is
  Begin
    Open Val For
      Select Rawtohex(Id) As 报告id, 文档标题 As 报告名称, 最后编辑时间 As 报告日期, Decode(Nvl(报告发放, 0), 0, '未发放', '已发放') As 报告发放
      From 影像报告记录
      Where 报告状态 Between 2 And 4
      And 医嘱id = 医嘱_In;
  
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Reportreleaselist;

  --30、根据报告ID查询驳回记录数量
  Procedure p_Get_Rejectedcount
  (
    Val     Out t_Refcur,
    报告_In 影像报告驳回.检查报告id%Type
  ) Is
  Begin
    Open Val For
      Select Count(*) As 驳回数量 From 影像报告驳回 Where 检查报告id = 报告_In;
  
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Rejectedcount;

  --31、根据医嘱ID查询报告动作需要的一些ID们
  Procedure p_Get_Docprocess_Ids
  (
    Val     Out t_Refcur,
    医嘱_In 病人医嘱记录.Id%Type
  ) Is
  Begin
    Open Val For
      Select Id As 医嘱id, 主页id, 挂号单 From 病人医嘱记录 Where Id = 医嘱_In;
  
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Docprocess_Ids;

  --32、根据医嘱ID和报告ID查询报告的一些参数
  Procedure p_Get_Docinfo
  (
    Val       Out t_Refcur,
    医嘱id_In 影像检查记录.医嘱id%Type,
    报告id_In 影像报告记录.Id%Type
  ) Is
  Begin
    If 报告id_In Is Null Then
      Open Val For
        Select 执行科室id, '创建人' As 创建人 From 影像检查记录 Where 医嘱id = 医嘱id_In;
    Else
      Open Val For
        Select 执行科室id, 创建人
        From 影像检查记录 a, 影像报告记录 b
        Where a.医嘱id = b.医嘱id
        And b.Id = 报告id_In;
    End If;
  
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Docinfo;

  --33、查询一个检查中相同原型ID的报告数量
  Procedure p_Get_Sameantetypedoccounts
  (
    Val       Out t_Refcur,
    医嘱id_In 影像报告记录.医嘱id%Type,
    原型id_In 影像报告记录.原型id%Type
  ) Is
  Begin
    Open Val For
      Select Count(Id) As Doccounts
      From 影像报告记录
      Where 医嘱id = 医嘱id_In
      And 原型id = 原型id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Sameantetypedoccounts;

  --34、提取报告图存储信息
  Procedure p_Get_Docimagesaveinof_By_Id
  (
    Val   Out t_Refcur,
    Id_In 影像报告记录.Id%Type
  ) Is
  Begin
    Open Val For
      Select 设备号, 创建时间 From 影像报告记录 Where Id = Id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Docimagesaveinof_By_Id;

  --35、修改原型使用次数
  Procedure p_Update_Antetypeusecount(Id_In 影像报告原型清单.Id%Type) Is
  Begin
    Update 影像报告原型清单 Set 使用次数 = 使用次数 + 1 Where Id = Id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Update_Antetypeusecount;

  --36、更新影像检查图像的报告图标记
  Procedure p_Update_Rptimage
  (
    Uid_In        影像检查图象.图像uid%Type,
    Actiontype_In Number
  ) Is
    v_Sql Varchar2(4000);
    No_Column Exception;
    Pragma Exception_Init(No_Column, -00904);
  Begin
    If Actiontype_In = 1 Then
      v_Sql := 'Update 影像检查图象 Set 报告图 = Nvl(报告图, 0) + 1 Where 图像uid = :1';
    Else
      v_Sql := 'Update 影像检查图象
      Set 报告图 = Decode(报告图, Null, Null, Decode(Nvl(报告图, 0) - 1, 0, Null, Nvl(报告图, 0) - 1))
      Where 图像uid = :1';
    End If;
    Execute Immediate v_Sql
      Using Uid_In;
  Exception
    When No_Column Then
      --兼容处理，10.36新增加 报告图 字段，问题号 103996
      Null;
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Update_Rptimage;

  --37、提取打印控制信息
  Procedure p_Get_Printcontrol
  (
    Val       Out t_Refcur,
    报告id_In 影像报告记录.Id%Type
  ) Is
    v_紧急     Number;
    v_打印控制 Number;
  Begin
  
    Select Nvl(Decode(a.急诊, 1, 1, b.紧急标志), 0) As 紧急
    Into v_紧急
    From 病人挂号记录 a, 病人医嘱记录 b
    Where a.No(+) = b.挂号单
    And b.Id = (Select c.医嘱id From 影像报告记录 c Where c.Id = 报告id_In);
  
    Select Nvl(Extractvalue(b.Column_Value, '/root/print_limit'), 0) Printlimit
    Into v_打印控制
    From 影像报告原型清单 a, Table(Xmlsequence(Extract(a.控制选项, '/root'))) b, 影像报告记录 c
    Where a.Id = c.原型id
    And c.Id = 报告id_In;
  
    Open Val For
      Select v_紧急 As 紧急, v_打印控制 As 打印控制 From Dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Printcontrol;

End b_Pacs_Rptmanage;
/

--119437:胡俊勇,2018-01-09,临床相关消息修改
--118748:李业庆,2017-12-20,退药，销帐消息锚点修改
--119449:刘硕,2018-01-04,消息集成修改完善
--119434:梁唐彬,2018-01-04,消息集成修改完善
--119578:黄捷,2018-01-05,ZLHIS锚点消息,增加取消检查预约的消息
--119643:李南春,2018-01-08,消息集成修改完善
--120700:李业庆,2018-01-23,消息描点调整
--120005:廖思奇,2018-01-30,b_Message中删除队列部分的消息
--121583:娄经平,2018-02-03,删除手麻未使用的消息
Create Or Replace Package b_Message Is
  Procedure p_Msg_Todo_Insert
  (
    Msg_Code_In  Zlmsg_Todo.Msg_Code%Type,
    Key_Value_In Zlmsg_Todo.Key_Value%Type
  );
  --设置平台调用类型
  Procedure Set_Platform_Call(Platform_Call Number);
  --新增部门
  Procedure Zlhis_Dict_001(Id_In 部门表.Id%Type);
  --修改部门
  Procedure Zlhis_Dict_002(部门id_In 部门表.Id%Type);
  --停用部门
  Procedure Zlhis_Dict_003(部门id_In 部门表.Id%Type);
  --启用部门
  Procedure Zlhis_Dict_004(部门id_In 部门表.Id%Type);
  --新增人员
  Procedure Zlhis_Dict_005(人员id_In 人员表.Id%Type);
  --修改人员
  Procedure Zlhis_Dict_006(人员id_In 人员表.Id%Type);
  --停用人员
  Procedure Zlhis_Dict_007(人员id_In 人员表.Id%Type);
  --启用人员
  Procedure Zlhis_Dict_008(人员id_In 人员表.Id%Type);
  --新增收费项目
  Procedure Zlhis_Dict_009(细目id_In 收费项目目录.Id%Type);
  --修改收费项目
  Procedure Zlhis_Dict_010(细目id_In 收费项目目录.Id%Type);
  --停用收费项目
  Procedure Zlhis_Dict_011(细目id_In 收费项目目录.Id%Type);
  --启用收费项目
  Procedure Zlhis_Dict_012(细目id_In 收费项目目录.Id%Type);
  --新增诊疗项目
  Procedure Zlhis_Dict_013(诊疗id_In 诊疗项目目录.Id%Type);
  --修改诊疗项目
  Procedure Zlhis_Dict_014(诊疗id_In 诊疗项目目录.Id%Type);
  --停用诊疗项目
  Procedure Zlhis_Dict_015(诊疗id_In 诊疗项目目录.Id%Type);
  --启用诊疗项目
  Procedure Zlhis_Dict_016(诊疗id_In 诊疗项目目录.Id%Type);
  --新增检验项目
  Procedure Zlhis_Dict_017(诊疗id_In 诊疗项目目录.Id%Type);
  --修改检验项目
  Procedure Zlhis_Dict_018(诊疗id_In 诊疗项目目录.Id%Type);
  --删除检验项目
  Procedure Zlhis_Dict_019
  (
    诊疗id_In 诊疗项目目录.Id%Type,
    编码_In   诊治所见项目.编码%Type,
    中文名_In 诊治所见项目.中文名%Type,
    英文名_In 诊治所见项目.英文名%Type
  );

  --新增疾病编码目录
  Procedure Zlhis_Dict_021(疾病id_In 疾病编码目录.Id%Type);
  --修改疾病编码目录
  Procedure Zlhis_Dict_022(疾病id_In 疾病编码目录.Id%Type);
  --停用疾病编码目录
  Procedure Zlhis_Dict_023(疾病id_In 疾病编码目录.Id%Type);
  --启用疾病编码目录
  Procedure Zlhis_Dict_024(疾病id_In 疾病编码目录.Id%Type);
  --新增药品分类
  Procedure Zlhis_Dict_025
  (
    类型_In 诊疗分类目录.类型%Type,
    Id_In   诊疗分类目录.Id%Type
  );
  --修改药品分类
  Procedure Zlhis_Dict_026
  (
    类型_In 诊疗分类目录.类型%Type,
    Id_In   诊疗分类目录.Id%Type
  );
  --删除药品分类
  Procedure Zlhis_Dict_027
  (
    类型_In 诊疗分类目录.类型%Type,
    Id_In   诊疗分类目录.Id%Type,
    编码_In 诊疗分类目录.编码%Type,
    名称_In 诊疗分类目录.名称%Type
  );
  --停用药品分类
  Procedure Zlhis_Dict_028
  (
    类型_In 诊疗分类目录.类型%Type,
    Id_In   诊疗分类目录.Id%Type
  );
  --启用药品分类
  Procedure Zlhis_Dict_029
  (
    类型_In 诊疗分类目录.类型%Type,
    Id_In   诊疗分类目录.Id%Type
  );
  --新增药品品种
  Procedure Zlhis_Dict_030
  (
    类别_In 诊疗项目目录.类别%Type,
    Id_In   诊疗项目目录.Id%Type
  );
  --修改药品品种
  Procedure Zlhis_Dict_031
  (
    类别_In 诊疗项目目录.类别%Type,
    Id_In   诊疗项目目录.Id%Type
  );
  --删除药品品种
  Procedure Zlhis_Dict_032
  (
    类别_In 诊疗项目目录.类别%Type,
    Id_In   诊疗项目目录.Id%Type,
    编码_In 诊疗项目目录.编码%Type,
    名称_In 诊疗项目目录.名称%Type
  );
  --停用药品品种
  Procedure Zlhis_Dict_033
  (
    类别_In 诊疗项目目录.类别%Type,
    Id_In   诊疗项目目录.Id%Type
  );
  --启用药品品种
  Procedure Zlhis_Dict_034
  (
    类别_In 诊疗项目目录.类别%Type,
    Id_In   诊疗项目目录.Id%Type
  );
  --新增药品规格
  Procedure Zlhis_Dict_035
  (
    类别_In   收费项目目录.类别%Type,
    药品id_In 收费项目目录.Id%Type
  );
  --修改药品规格
  Procedure Zlhis_Dict_036
  (
    类别_In   收费项目目录.类别%Type,
    药品id_In 收费项目目录.Id%Type
  );
  --删除药品规格
  Procedure Zlhis_Dict_037
  (
    类别_In   收费项目目录.类别%Type,
    药品id_In 收费项目目录.Id%Type,
    编码_In   收费项目目录.编码%Type,
    名称_In   收费项目目录.名称%Type,
    规格_In   收费项目目录.规格%Type,
    产地_In   收费项目目录.产地%Type
  );
  --停用药品规格
  Procedure Zlhis_Dict_038
  (
    类别_In   收费项目目录.类别%Type,
    药品id_In 收费项目目录.Id%Type
  );
  --启用药品规格
  Procedure Zlhis_Dict_039
  (
    类别_In   收费项目目录.类别%Type,
    药品id_In 收费项目目录.Id%Type
  );
  --设置药品存储库房
  Procedure Zlhis_Dict_040
  (
    类别_In   收费项目目录.类别%Type,
    药品id_In 收费项目目录.Id%Type
  );
  --设置药品储备限额
  Procedure Zlhis_Dict_041
  (
    类别_In   收费项目目录.类别%Type,
    药品id_In 收费项目目录.Id%Type
  );
  --新增卫材品种
  Procedure Zlhis_Dict_042(Id_In 诊疗项目目录.Id%Type);
  --新增卫材规格
  Procedure Zlhis_Dict_043(Id_In 收费项目目录.Id%Type);
  --修改卫材规格
  Procedure Zlhis_Dict_044(Id_In 收费项目目录.Id%Type);
  --删除卫材规格
  Procedure Zlhis_Dict_045
  (
    Id_In 收费项目目录.Id%Type,
    编码_In   收费项目目录.编码%Type,
    名称_In   收费项目目录.名称%Type,
    规格_In   收费项目目录.规格%Type,
    产地_In   收费项目目录.产地%Type
  );  
  --停用卫材规格
  Procedure Zlhis_Dict_046(Id_In 收费项目目录.Id%Type);
  --启用卫材规格
  Procedure Zlhis_Dict_047(Id_In 收费项目目录.Id%Type);
  --医保对码
  Procedure Zlhis_Dict_048
  (
    险类_In       In 保险支付项目.险类%Type,
    收费细目id_In In 保险支付项目.收费细目id%Type
  );
  --删除医保对码
  Procedure Zlhis_Dict_049
  (
    险类_In       In 保险支付项目.险类%Type,
    收费细目id_In In 保险支付项目.收费细目id%Type,
    项目编码_In   In 收费项目目录.编码%Type,
    项目名称_In   In 收费项目目录.名称%Type,
    医保编码_In   In 保险支付项目.项目编码%Type,
    医保名称_In   In 保险支付项目.项目名称%Type
  );
  --新增卫材分类
  Procedure Zlhis_Dict_050
  (
    类型_In 诊疗分类目录.类型%Type,
    Id_In   诊疗分类目录.Id%Type
  );
  --修改卫材分类
  Procedure Zlhis_Dict_051
  (
    类型_In 诊疗分类目录.类型%Type,
    Id_In   诊疗分类目录.Id%Type
  );
  --删除卫材分类
  Procedure Zlhis_Dict_052
  (
    类型_In 诊疗分类目录.类型%Type,
    Id_In   诊疗分类目录.Id%Type,
    编码_In 诊疗分类目录.编码%Type,
    名称_In 诊疗分类目录.名称%Type
  );
  --药品备药发送
  Procedure Zlhis_Drug_001(No_In 药品收发记录.No%Type);
  --取消药品备药发送
  Procedure Zlhis_Drug_002(No_In 药品收发记录.No%Type);
  --药品移库单接收
  Procedure Zlhis_Drug_003(No_In 药品收发记录.No%Type);
  --药品移库单冲销
  Procedure Zlhis_Drug_004(No_In 药品收发记录.No%Type);
  --部门发药
  Procedure Zlhis_Drug_005
  (
    库房id_In 药品收发记录.库房id%Type,
    收发id_In 药品收发记录.Id%Type
  );
  --部门退药
  Procedure Zlhis_Drug_006
  (
    冲销收发id_In 药品收发记录.Id%Type,
    待发收发id_In 药品收发记录.Id%Type,
    数量_In       药品收发记录.实际数量%Type,
    费用id_In     门诊费用记录.Id%Type
  );
  --药品调价
  Procedure Zlhis_Drug_007
  (
    价格id_In   药品价格记录.Id%Type
  );
  --静配发送
  Procedure ZLHIS_DRUG_008
  (
    记录Ids_In Varchar2
  );
  --药品调售价
  Procedure Zlhis_Drug_009
  (
    价格id_In   药品价格记录.Id%Type,
    时价_In Number
  );
  --卫材调成本价
  Procedure Zlhis_Drug_010
  (
    价格id_In   成本价调价信息.ID%Type
  );
  --卫材调售价
  Procedure Zlhis_Drug_011
  (
    价格id_In   收费价目.Id%Type,
    时价_In Number
  );
  --2.停止患者医嘱，住院
  Procedure Zlhis_Cis_002
  (
    病人id_In  In 病人医嘱记录.病人id%Type,
    主页id_In  In 病人医嘱记录.主页id%Type,
    医嘱id_In  In 病人医嘱记录.Id%Type,
    医嘱ids_In In Varchar2
  );
  --3.作废患者医嘱，门诊/住院
  Procedure Zlhis_Cis_003
  (
    病人id_In In 病人医嘱记录.病人id%Type,
    主页id_In In 病人医嘱记录.主页id%Type,
    挂号单_In In 病人挂号记录.No%Type,
    医嘱id_In In 病人医嘱记录.Id%Type
  );

  --10.下达患者诊断，门诊/住院
  Procedure Zlhis_Cis_010
  (
    病人id_In In 病人挂号记录.病人id%Type,
    就诊id_In In 病人挂号记录.Id%Type, --门诊病人 挂号ID，住院病人 主页ID
    诊断id_In In 病人诊断记录.Id%Type
  );
  --11.撤消患者诊断
  Procedure Zlhis_Cis_011
  (
    病人id_In   In 病人挂号记录.病人id%Type,
    就诊id_In   In 病人挂号记录.Id%Type, --门诊病人 挂号ID，住院病人 主页ID
    Id_In       In 病人诊断记录.Id%Type,
    疾病id_In   In 病人诊断记录.疾病id%Type,
    诊断id_In   In 病人诊断记录.诊断id%Type,
    诊断描述_In In 病人诊断记录.诊断描述%Type
  );

  --病区执行医嘱校对
  Procedure Zlhis_Cis_012
  (
    病人id_In In 病人医嘱记录.病人id%Type,
    主页id_In In 病人医嘱记录.主页id%Type,
    医嘱id_In In 病人医嘱记录.Id%Type
  );

  --13.检验危急值阅读通知
  Procedure Zlhis_Cis_014
  (
    病人id_In In 病人挂号记录.病人id%Type,
    就诊id_In In 病人挂号记录.Id%Type, --门诊病人 挂号ID，住院病人 主页ID
    医嘱id_In In 病人医嘱记录.Id%Type,
    消息id_In In 业务消息清单.Id%Type
  );

  --15.患者检验申请，门诊/住院
  Procedure Zlhis_Cis_016
  (
    病人id_In   In 病人医嘱记录.病人id%Type,
    主页id_In   In 病人医嘱记录.主页id%Type,
    挂号单_In   In 病人挂号记录.No%Type,
    发送号_In   In 病人医嘱发送.发送号%Type,
    医嘱id_In   In 病人医嘱记录.Id%Type,
    病人来源_In In 病人医嘱记录.病人来源%Type
  );
  --16.患者检查申请，门诊/住院
  Procedure Zlhis_Cis_017
  (
    病人id_In   In 病人医嘱记录.病人id%Type,
    主页id_In   In 病人医嘱记录.主页id%Type,
    挂号单_In   In 病人挂号记录.No%Type,
    发送号_In   In 病人医嘱发送.发送号%Type,
    医嘱id_In   In 病人医嘱记录.Id%Type,
    病人来源_In In 病人医嘱记录.病人来源%Type
  );
  --17.患者手术申请，门诊/住院
  Procedure Zlhis_Cis_018
  (
    病人id_In In 病人医嘱记录.病人id%Type,
    主页id_In In 病人医嘱记录.主页id%Type,
    挂号单_In In 病人挂号记录.No%Type,
    发送号_In In 病人医嘱发送.发送号%Type,
    医嘱id_In In 病人医嘱记录.Id%Type
  );
  --18.患者输血申请，住院
  Procedure Zlhis_Cis_019
  (
    病人id_In In 病人医嘱记录.病人id%Type,
    主页id_In In 病人医嘱记录.主页id%Type,
    挂号单_In In 病人挂号记录.No%Type,
    发送号_In In 病人医嘱发送.发送号%Type,
    医嘱id_In In 病人医嘱记录.Id%Type
  );
  --19.患者会诊申请，住院
  Procedure Zlhis_Cis_020
  (
    病人id_In In 病人医嘱记录.病人id%Type,
    主页id_In In 病人医嘱记录.主页id%Type,
    发送号_In In 病人医嘱发送.发送号%Type,
    医嘱id_In In 病人医嘱记录.Id%Type
  );
  --20.患者抢救医嘱，住院
  Procedure Zlhis_Cis_021
  (
    病人id_In In 病人医嘱记录.病人id%Type,
    主页id_In In 病人医嘱记录.主页id%Type,
    发送号_In In 病人医嘱发送.发送号%Type,
    医嘱id_In In 病人医嘱记录.Id%Type
  );
  --21.患者死亡医嘱，住院
  Procedure Zlhis_Cis_022
  (
    病人id_In In 病人医嘱记录.病人id%Type,
    主页id_In In 病人医嘱记录.主页id%Type,
    发送号_In In 病人医嘱发送.发送号%Type,
    医嘱id_In In 病人医嘱记录.Id%Type
  );
  --22.患者特殊治疗医嘱，住院
  Procedure Zlhis_Cis_023
  (
    病人id_In In 病人医嘱记录.病人id%Type,
    主页id_In In 病人医嘱记录.主页id%Type,
    发送号_In In 病人医嘱发送.发送号%Type,
    医嘱id_In In 病人医嘱记录.Id%Type
  );

  --24.检查危急值阅读通知
  Procedure Zlhis_Cis_025
  (
    病人id_In In 病人挂号记录.病人id%Type,
    就诊id_In In 病人挂号记录.Id%Type, --门诊病人 挂号ID，住院病人 主页ID
    医嘱id_In In 病人医嘱记录.Id%Type,
    消息id_In In 业务消息清单.Id%Type
  );

  --病区执行医嘱发送
  Procedure Zlhis_Cis_026
  (
    病人id_In In 病人医嘱记录.病人id%Type,
    主页id_In In 病人医嘱记录.主页id%Type,
    发送号_In In 病人医嘱发送.发送号%Type,
    医嘱id_In In 病人医嘱记录.Id%Type
  );

  --撤消患者检验申请
  Procedure Zlhis_Cis_036
  (
    病人id_In   In 病人医嘱记录.病人id%Type,
    主页id_In   In 病人医嘱记录.主页id%Type,
    挂号单_In   In 病人挂号记录.No%Type,
    发送号_In   In 病人医嘱发送.发送号%Type,
    医嘱id_In   In 病人医嘱记录.Id%Type,
    No_In       In 病人医嘱发送.No%Type,
    病人来源_In In 病人医嘱记录.病人来源%Type
  );

  --撤消患者检查申请
  Procedure Zlhis_Cis_037
  (
    病人id_In   In 病人医嘱记录.病人id%Type,
    主页id_In   In 病人医嘱记录.主页id%Type,
    挂号单_In   In 病人挂号记录.No%Type,
    发送号_In   In 病人医嘱发送.发送号%Type,
    医嘱id_In   In 病人医嘱记录.Id%Type,
    No_In       In 病人医嘱发送.No%Type,
    病人来源_In In 病人医嘱记录.病人来源%Type
  );

  --撤消患者手术申请
  Procedure Zlhis_Cis_038
  (
    病人id_In In 病人医嘱记录.病人id%Type,
    主页id_In In 病人医嘱记录.主页id%Type,
    挂号单_In In 病人挂号记录.No%Type,
    发送号_In In 病人医嘱发送.发送号%Type,
    医嘱id_In In 病人医嘱记录.Id%Type,
    No_In     In 病人医嘱发送.No%Type
  );

  --撤消患者输血申请
  Procedure Zlhis_Cis_039
  (
    病人id_In In 病人医嘱记录.病人id%Type,
    主页id_In In 病人医嘱记录.主页id%Type,
    挂号单_In In 病人挂号记录.No%Type,
    发送号_In In 病人医嘱发送.发送号%Type,
    医嘱id_In In 病人医嘱记录.Id%Type,
    No_In     In 病人医嘱发送.No%Type
  );

  --撤消患者会诊申请
  Procedure Zlhis_Cis_040
  (
    病人id_In In 病人医嘱记录.病人id%Type,
    主页id_In In 病人医嘱记录.主页id%Type,
    发送号_In In 病人医嘱发送.发送号%Type,
    医嘱id_In In 病人医嘱记录.Id%Type,
    No_In     In 病人医嘱发送.No%Type
  );

  --撤消患者抢救医嘱
  Procedure Zlhis_Cis_041
  (
    病人id_In In 病人医嘱记录.病人id%Type,
    主页id_In In 病人医嘱记录.主页id%Type,
    发送号_In In 病人医嘱发送.发送号%Type,
    医嘱id_In In 病人医嘱记录.Id%Type,
    No_In     In 病人医嘱发送.No%Type
  );

  --撤消患者死亡医嘱
  Procedure Zlhis_Cis_042
  (
    病人id_In In 病人医嘱记录.病人id%Type,
    主页id_In In 病人医嘱记录.主页id%Type,
    发送号_In In 病人医嘱发送.发送号%Type,
    医嘱id_In In 病人医嘱记录.Id%Type,
    No_In     In 病人医嘱发送.No%Type
  );

  --撤消特殊治疗医嘱
  Procedure Zlhis_Cis_043
  (
    病人id_In In 病人医嘱记录.病人id%Type,
    主页id_In In 病人医嘱记录.主页id%Type,
    发送号_In In 病人医嘱发送.发送号%Type,
    医嘱id_In In 病人医嘱记录.Id%Type,
    No_In     In 病人医嘱发送.No%Type
  );

  --撤消病区执行医嘱
  Procedure Zlhis_Cis_044
  (
    病人id_In   In 病人医嘱记录.病人id%Type,
    主页id_In   In 病人医嘱记录.主页id%Type,
    发送号_In   In 病人医嘱发送.发送号%Type,
    医嘱id_In   In 病人医嘱记录.Id%Type,
    No_In       In 病人医嘱发送.No%Type,
    发送数次_In In 病人医嘱发送.发送数次%Type,
    首次时间_In In 病人医嘱发送.首次时间%Type,
    末次时间_In In 病人医嘱发送.末次时间%Type,
    样本条码_In In 病人医嘱发送.样本条码%Type
  );
  --患者医嘱执行登记
  Procedure Zlhis_Cis_050
  (
    病人id_In   In 病人医嘱记录.病人id%Type,
    主页id_In   In 病人医嘱记录.主页id%Type,
    挂号单_In   In 病人挂号记录.No%Type,
    发送号_In   In 病人医嘱发送.发送号%Type,
    医嘱id_In   In 病人医嘱记录.Id%Type,
    要求时间_In In 病人医嘱执行.要求时间%Type,
    执行时间_In In 病人医嘱执行.执行时间%Type
  );

  --患者医嘱取消执行登记
  Procedure Zlhis_Cis_051
  (
    病人id_In   In 病人医嘱记录.病人id%Type,
    主页id_In   In 病人医嘱记录.主页id%Type,
    挂号单_In   In 病人挂号记录.No%Type,
    发送号_In   In 病人医嘱发送.发送号%Type,
    医嘱id_In   In 病人医嘱记录.Id%Type,
    要求时间_In In 病人医嘱执行.要求时间%Type,
    执行时间_In In 病人医嘱执行.执行时间%Type,
    本次数次_In In 病人医嘱执行.本次数次%Type,
    执行结果_In In 病人医嘱执行.执行结果%Type,
    执行摘要_In In 病人医嘱执行.执行摘要%Type,
    执行科室_In In 病人医嘱执行.执行科室id%Type,
    执行人_In   In 病人医嘱执行.执行人%Type,
    核对人_In   In 病人医嘱执行.核对人%Type,
    记录来源_In In 病人医嘱执行.记录来源%Type
  );
  --患者医嘱执行完成
  Procedure Zlhis_Cis_052
  (
    病人id_In In 病人医嘱记录.病人id%Type,
    主页id_In In 病人医嘱记录.主页id%Type,
    挂号单_In In 病人挂号记录.No%Type,
    发送号_In In 病人医嘱发送.发送号%Type,
    医嘱id_In In 病人医嘱记录.Id%Type
  );
  --患者医嘱撤消执行完成
  Procedure Zlhis_Cis_053
  (
    病人id_In In 病人医嘱记录.病人id%Type,
    主页id_In In 病人医嘱记录.主页id%Type,
    挂号单_In In 病人挂号记录.No%Type,
    发送号_In In 病人医嘱发送.发送号%Type,
    医嘱id_In In 病人医嘱记录.Id%Type
  );

  --26.检查报告完成，检查完成时
  Procedure Zlhis_Pacs_001
  (
    医嘱id_In   In 影像检查记录.医嘱id%Type,
    报告id_Ins  In Varchar2,
    报告类型_In In Number --1-老版PACS报告，2-老版病历编辑器报告，3-新版编辑器报告
  );
  --27.检查状态同步，检查状态改变后
  Procedure Zlhis_Pacs_002
  (
    医嘱id_In In 影像检查记录.医嘱id%Type,
    原状态_In In 病人医嘱发送.执行过程%Type,
    新状态_In In 病人医嘱发送.执行过程%Type
  );
  --28.检查状态回退，检查状态回退后
  Procedure Zlhis_Pacs_003
  (
    医嘱id_In In 影像检查记录.医嘱id%Type,
    原状态_In In 病人医嘱发送.执行过程%Type,
    新状态_In In 病人医嘱发送.执行过程%Type
  );
  --29.检查报告撤销，撤销检查完成时
  Procedure Zlhis_Pacs_004
  (
    医嘱id_In   In 影像检查记录.医嘱id%Type,
    报告id_Ins  In Varchar2,
    报告类型_In In Number --1-老版PACS报告，2-老版病历编辑器报告，3-新版编辑器报告
  );
  --30.检查危急值通知，检查发生危急值时
  Procedure Zlhis_Pacs_005(医嘱id_In In 影像检查记录.医嘱id%Type);
  -- 检查预约通知，检查预约时
  Procedure Zlhis_Pacs_006
  (
    医嘱id_In In 影像检查记录.医嘱id%Type,
    预约id_In In Ris检查预约.预约id%Type
  );
  -- 取消检查预约，取消预约时
  Procedure Zlhis_Pacs_007
  (
    医嘱id_In       In 影像检查记录.医嘱id%Type,
    预约id_In       In Ris检查预约.预约id%Type,
    预约日期_In     In Ris检查预约.预约日期%Type,
    预约序号_In     In Ris检查预约.序号%Type,
    检查设备名称_In In Ris检查预约.检查设备名称%Type
  );

  --36.患者发卡
  Procedure Zlhis_Patient_018
  (
    变动id_In   In 病人变动记录.Id%Type,
    病人id_In   In 病人信息.病人id%Type,
    卡类别id_In In 医疗卡类别.Id%Type,
    卡号_In     In 病人医疗卡信息.卡号%Type
  );

  --37.患者退卡
  Procedure Zlhis_Patient_019
  (
    变动id_In   In 病人变动记录.Id%Type,
    病人id_In   In 病人信息.病人id%Type,
    卡类别id_In In 医疗卡类别.Id%Type,
    卡号_In     In 病人医疗卡信息.卡号%Type
  );

  --38.患者退卡
  Procedure Zlhis_Patient_020
  (
    变动id_In   In 病人变动记录.Id%Type,
    病人id_In   In 病人信息.病人id%Type,
    卡类别id_In In 医疗卡类别.Id%Type,
    原卡号_In   In 病人医疗卡信息.卡号%Type,
    新卡号_In   In 病人医疗卡信息.卡号%Type
  );

  --39.病人挂号登记（包含预约登记)
  Procedure Zlhis_Regist_001
  (
    挂号id_In In 病人挂号记录.Id%Type,
    No_In     In 病人挂号记录.No%Type
  );

  --40.病人分诊
  Procedure Zlhis_Regist_002
  (
    挂号id_In In 病人挂号记录.Id%Type,
    No_In     In 病人挂号记录.No%Type,
    诊室_In   In 病人挂号记录.诊室%Type
  );

  --41.病人退号
  Procedure Zlhis_Regist_003
  (
    挂号id_In In 病人挂号记录.Id%Type,
    No_In     In 病人挂号记录.No%Type
  );

  --42.临床出诊安排调整
  Procedure Zlhis_Regist_004
  (
    变动原因_In In Integer, --1-停诊;2-替诊;3-诊室变动
    记录id_In   In 临床出诊记录.Id%Type,
    变动id_In   In 临床出诊变动记录.Id%Type
  );

  --43.门诊患者挂号换号操作
  Procedure Zlhis_Regist_005
  (
    No_In         In 病人挂号记录.No%Type,
    变动原因_In   Integer, --1-替诊;2-换号;3-预约日期变动,
    就诊变动id_In 就诊变动记录.Id%Type
  );


  --费用门诊收费及补充结算
  --结算类型_In:1-收费结算，2-补充结算
  Procedure Zlhis_Charge_002
  (
    结算类型_In In Number,
    结帐id_In   In 门诊费用记录.结帐id%Type
  );


  --46.门诊退费单据
  Procedure Zlhis_Charge_004
  (
    退费类型_In In Number,
    结帐id_In   In 门诊费用记录.结帐id%Type
  );

  --47.收预交款
  Procedure Zlhis_Charge_005
  (
    预交id_In In 病人预交记录.Id%Type,
    单据号_In In 病人预交记录.No%Type
  );

  --48.退预交款(包含负数退预交款部分)
  Procedure Zlhis_Charge_006
  (
    退预交id_In In 病人预交记录.Id%Type,
    单据号_In   In 病人预交记录.No%Type
  );

  --住院记帐单据
  Procedure Zlhis_Charge_007
  (
    收费类别_In In 住院费用记录.收费类别%Type,
    费用id_In   In 住院费用记录.Id%Type
  );

  --住院记帐单据销账
  Procedure Zlhis_Charge_008
  (
    收费类别_In In 住院费用记录.收费类别%Type,
    费用id_In   In 住院费用记录.Id%Type,
    收发ids_In  In Varchar2 := Null --可能费用ID对应多个收发id，对应格式：收发id,数量|收发id,数量；非药品不传
  );

  --53.住院患者入院登记
  Procedure Zlhis_Patient_001
  (
    病人id_In In 病案主页.病人id%Type,
    主页id_In In 病案主页.主页id%Type
  );
  --54.住院患者入院入科
  Procedure Zlhis_Patient_002
  (
    病人id_In In 病案主页.病人id%Type,
    主页id_In In 病案主页.主页id%Type
  );
  --56.住院患者床位变更
  Procedure Zlhis_Patient_004
  (
    病人id_In In 病案主页.病人id%Type,
    主页id_In In 病案主页.主页id%Type
  );
  --57.住院患者病情变更
  Procedure Zlhis_Patient_005
  (
    病人id_In In 病案主页.病人id%Type,
    主页id_In In 病案主页.主页id%Type
  );
  --58.住院患者变更撤消
  Procedure Zlhis_Patient_006
  (
    病人id_In   In 病案主页.病人id%Type,
    主页id_In   In 病案主页.主页id%Type,
    撤销方式_In In Varchar2
  );
  --59.住院患者医护变更
  Procedure Zlhis_Patient_007
  (
    病人id_In In 病案主页.病人id%Type,
    主页id_In In 病案主页.主页id%Type
  );
  --住院患者护理等级变更
  Procedure Zlhis_Patient_008
  (
    病人id_In In 病案主页.病人id%Type,
    主页id_In In 病案主页.主页id%Type
  );
  --60.住院患者预出院
  Procedure Zlhis_Patient_009
  (
    病人id_In In 病案主页.病人id%Type,
    主页id_In In 病案主页.主页id%Type
  );
  --61.住院患者出院
  Procedure Zlhis_Patient_010
  (
    病人id_In In 病案主页.病人id%Type,
    主页id_In In 病案主页.主页id%Type
  );
  --62.住院患者新生儿登记
  Procedure Zlhis_Patient_011
  (
    病人id_In   In 病案主页.病人id%Type,
    主页id_In   In 病案主页.主页id%Type,
    婴儿序号_In 病人医嘱记录.婴儿%Type
  );
  --63.住院患者转入科室
  Procedure Zlhis_Patient_012
  (
    病人id_In In 病案主页.病人id%Type,
    主页id_In In 病案主页.主页id%Type
  );
  --64.新生儿登记作废
  Procedure Zlhis_Patient_013
  (
    病人id_In   In 病案主页.病人id%Type,
    主页id_In   In 病案主页.主页id%Type,
    婴儿序号_In 病人医嘱记录.婴儿%Type
  );
  --65.门诊患者登记
  Procedure Zlhis_Patient_015(病人id_In In 病案主页.病人id%Type);
  --66.患者信息修改
  Procedure Zlhis_Patient_016(病人id_In In 病案主页.病人id%Type);

  --67.患者合并
  Procedure Zlhis_Patient_017
  (
    病人id_In   In 病案主页.病人id%Type,
    原病人id_In In 病案主页.病人id%Type
  );

  --69.患者转病区转入
  Procedure Zlhis_Patient_026
  (
    病人id_In In 病案主页.病人id%Type,
    主页id_In In 病案主页.主页id%Type
  );

  Procedure Zlhis_Patient_028(病人id_In In 病案主页.病人id%Type);

  --血库:科室配血完成
  Procedure Zlhis_Blood_001(医嘱id_In In 病人医嘱记录.Id%Type);
  --血库:科室配血拒绝
  Procedure Zlhis_Blood_002(医嘱id_In In 病人医嘱记录.Id%Type);

  --70.检验标本审核
  Procedure Zlhis_Lis_001(标本id_In In 检验标本记录.Id%Type);
  --71.检验标本审核撤消
  Procedure Zlhis_Lis_002(标本id_In In 检验标本记录.Id%Type);
  --73.检验标本条码打印
  Procedure Zlhis_Lis_004
  (
    样本条码_In In 病人医嘱发送.样本条码%Type,
    医嘱id_In   In 病人医嘱发送.医嘱id%Type,
    医嘱ids_In  In Varchar2
  );
  --74.检验标本条码打印撤销
  Procedure Zlhis_Lis_005
  (
    样本条码_In In 病人医嘱发送.样本条码%Type,
    医嘱id_In   In 病人医嘱发送.医嘱id%Type,
    医嘱ids_In  In Varchar2
  );
  --75.检验标本核收
  Procedure Zlhis_Lis_006(标本id_In In 检验标本记录.Id%Type);
  --76.检验标本核收撤销
  Procedure Zlhis_Lis_007(标本id_In In 检验标本记录.Id%Type);
  --77.检验标本拒收
  Procedure Zlhis_Lis_008(标本id_In In 检验标本记录.Id%Type);
End b_Message;
/

--119437:胡俊勇,2018-01-09,临床相关消息修改
--119449:刘硕,2018-01-04,消息集成修改完善
--118748:李业庆,2017-12-20,退药，销帐消息锚点修改
--119434:梁唐彬,2018-01-04,消息集成修改完善
--119578:黄捷,2018-01-05,ZLHIS锚点消息,增加取消检查预约的消息
--119643:李南春,2018-01-08,消息集成修改完善
--120005:廖思奇,2018-01-17,消息问题Pacs部分
--120700:李业庆,2018-01-23,消息描点调整
--121583:娄经平,2018-02-03,删除手麻未使用的消息
Create Or Replace Package Body b_Message Is
  --是否是平台调用
  Is_Platform_Call Number(1) := 0;
  --消息公共方法
  Message_Creator Zlmsg_Todo.Creator%Type := Null;
  --缓存消息查询结果  
  Type Tmap_Msg_Using Is Table Of Number(1) Index By Varchar2(30);
  Zlmsg_Map Tmap_Msg_Using;
  --消息是否启用
  Function p_Msg_Using(Msg_Code_In Zlmsg_Lists.Code%Type) Return Number As
    n_Using Zlmsg_Lists.Using%Type;
    v_Code  Zlmsg_Lists.Code%Type;
  Begin
    If Is_Platform_Call = 1 Then
      Return 0;
    End If;
    v_Code := Upper(Msg_Code_In);
    Begin
      n_Using := Zlmsg_Map(v_Code);
      Return n_Using;
    Exception
      When No_Data_Found Then
        --不采取Max容错处理，错误相当于外键,用户可能没有采取同步修改或自己增加了消息类型但是未注册到Zlmsg_Lists，这两种情况会出现错误。
        Select Nvl(Using, 0) Into n_Using From Zlmsg_Lists A Where Code = v_Code;
        Zlmsg_Map(v_Code) := n_Using;
        --查询生成消息的人员，放在这里减少执行次数
        If Message_Creator Is Null Then
          Message_Creator := Zl_Username;
        End If;
        Return n_Using;
    End;
  Exception
    When Others Then
      Raise_Application_Error(-20101, '[ZLSOFT]' || '未在Zlmsg_Lists中找到消息"' || v_Code || '"！请联系管理员进行处理。' || '[ZLSOFT]');
      Return 0;
  End;
  Procedure p_Msg_Todo_Insert
  (
    Msg_Code_In  Zlmsg_Todo.Msg_Code%Type,
    Key_Value_In Zlmsg_Todo.Key_Value%Type
  ) Is
  Begin
    If p_Msg_Using(Msg_Code_In) = 0 Then
      Return;
    End If;
    Insert Into Zlmsg_Todo
      (ID, Msg_Code, Key_Value, State, Create_Time, Creator)
    Values
      (Zlmsg_Todo_Id.Nextval, Upper(Msg_Code_In), Key_Value_In, 0, Sysdate, Message_Creator);
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Msg_Todo_Insert;
  --设置当前会话为平台调用
  Procedure Set_Platform_Call(Platform_Call Number) Is
  Begin
    Is_Platform_Call := Platform_Call;
  End Set_Platform_Call;
  --消息Zlhis_Dict_001
  Procedure Zlhis_Dict_001(Id_In 部门表.Id%Type) Is
    v_Define Xmltype;
    v_Value  Zlmsg_Todo.Key_Value%Type;
  Begin
    If p_Msg_Using('ZLHIS_DICT_001') = 0 Then
      Return;
    End If;
    Begin
      Select Xmltype(Key_Define) Into v_Define From Zlmsg_Lists Where Code = 'ZLHIS_DICT_001';
    Exception
      When Others Then
        v_Define := Xmltype('<root><ID>NULL</ID></root>');
    End;
    Select Updatexml(v_Define, '/root/ID/text()', Id_In).Getstringval() Into v_Value From Dual;
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_001', v_Value);
  End Zlhis_Dict_001;
  --修改部门
  Procedure Zlhis_Dict_002(部门id_In 部门表.Id%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><部门ID>' || 部门id_In || '</部门ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_002', v_Value);
  End Zlhis_Dict_002;
  --停用部门
  Procedure Zlhis_Dict_003(部门id_In 部门表.Id%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><部门ID>' || 部门id_In || '</部门ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_003', v_Value);
  End Zlhis_Dict_003;
  --启用部门
  Procedure Zlhis_Dict_004(部门id_In 部门表.Id%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><部门ID>' || 部门id_In || '</部门ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_004', v_Value);
  End Zlhis_Dict_004;
  --新增人员
  Procedure Zlhis_Dict_005(人员id_In 人员表.Id%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><人员ID>' || 人员id_In || '</人员ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_005', v_Value);
  End Zlhis_Dict_005;
  --修改人员
  Procedure Zlhis_Dict_006(人员id_In 人员表.Id%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><人员ID>' || 人员id_In || '</人员ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_006', v_Value);
  End Zlhis_Dict_006;
  --停用人员
  Procedure Zlhis_Dict_007(人员id_In 人员表.Id%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><人员ID>' || 人员id_In || '</人员ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_007', v_Value);
  End Zlhis_Dict_007;
  --启用人员
  Procedure Zlhis_Dict_008(人员id_In 人员表.Id%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><人员ID>' || 人员id_In || '</人员ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_008', v_Value);
  End Zlhis_Dict_008;
  --新增收费项目
  Procedure Zlhis_Dict_009(细目id_In 收费项目目录.Id%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><细目ID>' || 细目id_In || '</细目ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_009', v_Value);
  End Zlhis_Dict_009;
  --修改收费项目
  Procedure Zlhis_Dict_010(细目id_In 收费项目目录.Id%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><细目ID>' || 细目id_In || '</细目ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_010', v_Value);
  End Zlhis_Dict_010;
  --停用收费项目
  Procedure Zlhis_Dict_011(细目id_In 收费项目目录.Id%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><细目ID>' || 细目id_In || '</细目ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_011', v_Value);
  End Zlhis_Dict_011;
  --启用收费项目
  Procedure Zlhis_Dict_012(细目id_In 收费项目目录.Id%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><细目ID>' || 细目id_In || '</细目ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_012', v_Value);
  End Zlhis_Dict_012;
  --新增诊疗项目
  Procedure Zlhis_Dict_013(诊疗id_In 诊疗项目目录.Id%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><诊疗ID>' || 诊疗id_In || '</诊疗ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_013', v_Value);
  End Zlhis_Dict_013;
  --修改诊疗项目
  Procedure Zlhis_Dict_014(诊疗id_In 诊疗项目目录.Id%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><诊疗ID>' || 诊疗id_In || '</诊疗ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_014', v_Value);
  End Zlhis_Dict_014;
  --停用诊疗项目
  Procedure Zlhis_Dict_015(诊疗id_In 诊疗项目目录.Id%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><诊疗ID>' || 诊疗id_In || '</诊疗ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_015', v_Value);
  End Zlhis_Dict_015;
  --启用诊疗项目
  Procedure Zlhis_Dict_016(诊疗id_In 诊疗项目目录.Id%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><诊疗ID>' || 诊疗id_In || '</诊疗ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_016', v_Value);
  End Zlhis_Dict_016;
  --新增检验项目
  Procedure Zlhis_Dict_017(诊疗id_In 诊疗项目目录.Id%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><诊疗ID>' || 诊疗id_In || '</诊疗ID><系统>1</系统></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_017', v_Value);
  End Zlhis_Dict_017;
  --修改检验项目
  Procedure Zlhis_Dict_018(诊疗id_In 诊疗项目目录.Id%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><诊疗ID>' || 诊疗id_In || '</诊疗ID><系统>1</系统></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_018', v_Value);
  End Zlhis_Dict_018;
  --删除检验项目
  Procedure Zlhis_Dict_019
  (
    诊疗id_In 诊疗项目目录.Id%Type,
    编码_In   诊治所见项目.编码%Type,
    中文名_In 诊治所见项目.中文名%Type,
    英文名_In 诊治所见项目.英文名%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><诊疗ID>' || 诊疗id_In || '</诊疗ID>' || '<编码>' || 编码_In || '</编码>' || '<中文名>' || 中文名_In || '</中文名>' ||
               '<英文名>' || 英文名_In || '</英文名>' || '<系统>1</系统></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_019', v_Value);
  End Zlhis_Dict_019;
  --新增疾病编码目录
  Procedure Zlhis_Dict_021(疾病id_In 疾病编码目录.Id%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><疾病ID>' || 疾病id_In || '</疾病ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_021', v_Value);
  End Zlhis_Dict_021;
  --修改疾病编码目录
  Procedure Zlhis_Dict_022(疾病id_In 疾病编码目录.Id%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><疾病ID>' || 疾病id_In || '</疾病ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_022', v_Value);
  End Zlhis_Dict_022;
  --停用疾病编码目录
  Procedure Zlhis_Dict_023(疾病id_In 疾病编码目录.Id%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><疾病ID>' || 疾病id_In || '</疾病ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_023', v_Value);
  End Zlhis_Dict_023;
  --启用疾病编码目录
  Procedure Zlhis_Dict_024(疾病id_In 疾病编码目录.Id%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><疾病ID>' || 疾病id_In || '</疾病ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_024', v_Value);
  End Zlhis_Dict_024;
  --新增药品分类
  Procedure Zlhis_Dict_025
  (
    类型_In 诊疗分类目录.类型%Type,
    Id_In   诊疗分类目录.Id%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><类型>' || 类型_In || '</类型><ID>' || Id_In || '</ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_025', v_Value);
  End Zlhis_Dict_025;
  --修改药品分类
  Procedure Zlhis_Dict_026
  (
    类型_In 诊疗分类目录.类型%Type,
    Id_In   诊疗分类目录.Id%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><类型>' || 类型_In || '</类型><ID>' || Id_In || '</ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_026', v_Value);
  End Zlhis_Dict_026;
  --删除药品分类
  Procedure Zlhis_Dict_027
  (
    类型_In 诊疗分类目录.类型%Type,
    Id_In   诊疗分类目录.Id%Type,
    编码_In 诊疗分类目录.编码%Type,
    名称_In 诊疗分类目录.名称%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><类型>' || 类型_In || '</类型><ID>' || Id_In || '</ID><编码>' || 编码_In || '</编码><名称>' || 名称_In  || '</名称></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_027', v_Value);
  End Zlhis_Dict_027;
  --停用药品分类
  Procedure Zlhis_Dict_028
  (
    类型_In 诊疗分类目录.类型%Type,
    Id_In   诊疗分类目录.Id%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><类型>' || 类型_In || '</类型><ID>' || Id_In || '</ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_028', v_Value);
  End Zlhis_Dict_028;
  --启用药品分类
  Procedure Zlhis_Dict_029
  (
    类型_In 诊疗分类目录.类型%Type,
    Id_In   诊疗分类目录.Id%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><类型>' || 类型_In || '</类型><ID>' || Id_In || '</ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_029', v_Value);
  End Zlhis_Dict_029;
  --新增药品品种
  Procedure Zlhis_Dict_030
  (
    类别_In 诊疗项目目录.类别%Type,
    Id_In   诊疗项目目录.Id%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><类别>' || 类别_In || '</类别><ID>' || Id_In || '</ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_030', v_Value);
  End Zlhis_Dict_030;
  --修改药品品种
  Procedure Zlhis_Dict_031
  (
    类别_In 诊疗项目目录.类别%Type,
    Id_In   诊疗项目目录.Id%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><类别>' || 类别_In || '</类别><ID>' || Id_In || '</ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_031', v_Value);
  End Zlhis_Dict_031;
  --删除药品品种
  Procedure Zlhis_Dict_032
  (
    类别_In 诊疗项目目录.类别%Type,
    Id_In   诊疗项目目录.Id%Type,
    编码_In 诊疗项目目录.编码%Type,
    名称_In 诊疗项目目录.名称%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><类别>' || 类别_In || '</类别><ID>' || Id_In || '</ID><编码>' || 编码_In || '</编码><名称>' || 名称_In  || '</名称></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_032', v_Value);
  End Zlhis_Dict_032;
  --停用药品品种
  Procedure Zlhis_Dict_033
  (
    类别_In 诊疗项目目录.类别%Type,
    Id_In   诊疗项目目录.Id%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><类别>' || 类别_In || '</类别><ID>' || Id_In || '</ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_033', v_Value);
  End Zlhis_Dict_033;
  --启用药品品种
  Procedure Zlhis_Dict_034
  (
    类别_In 诊疗项目目录.类别%Type,
    Id_In   诊疗项目目录.Id%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><类别>' || 类别_In || '</类别><ID>' || Id_In || '</ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_034', v_Value);
  End Zlhis_Dict_034;
  --新增药品规格
  Procedure Zlhis_Dict_035
  (
    类别_In   收费项目目录.类别%Type,
    药品id_In 收费项目目录.Id%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><类别>' || 类别_In || '</类别><药品ID>' || 药品id_In || '</药品ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_035', v_Value);
  End Zlhis_Dict_035;
  --修改药品规格
  Procedure Zlhis_Dict_036
  (
    类别_In   收费项目目录.类别%Type,
    药品id_In 收费项目目录.Id%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><类别>' || 类别_In || '</类别><药品ID>' || 药品id_In || '</药品ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_036', v_Value);
  End Zlhis_Dict_036;
  --删除药品规格
  Procedure Zlhis_Dict_037
  (
    类别_In   收费项目目录.类别%Type,
    药品id_In 收费项目目录.Id%Type,
    编码_In   收费项目目录.编码%Type,
    名称_In   收费项目目录.名称%Type,
    规格_In   收费项目目录.规格%Type,
    产地_In   收费项目目录.产地%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><类别>' || 类别_In || '</类别><药品ID>' || 药品id_In || '</药品ID><编码>' || 编码_In || '</编码><名称>' || 名称_In  || '</名称><规格>' ||
            规格_In || '</规格><产地>' || 产地_In || '</产地></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_037', v_Value);
  End Zlhis_Dict_037;
  --停用药品规格
  Procedure Zlhis_Dict_038
  (
    类别_In   收费项目目录.类别%Type,
    药品id_In 收费项目目录.Id%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><类别>' || 类别_In || '</类别><药品ID>' || 药品id_In || '</药品ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_038', v_Value);
  End Zlhis_Dict_038;
  --启用药品规格
  Procedure Zlhis_Dict_039
  (
    类别_In   收费项目目录.类别%Type,
    药品id_In 收费项目目录.Id%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><类别>' || 类别_In || '</类别><药品ID>' || 药品id_In || '</药品ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_039', v_Value);
  End Zlhis_Dict_039;
  --设置药品存储库房
  Procedure Zlhis_Dict_040
  (
    类别_In   收费项目目录.类别%Type,
    药品id_In 收费项目目录.Id%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><类别>' || 类别_In || '</类别><药品ID>' || 药品id_In || '</药品ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_040', v_Value);
  End Zlhis_Dict_040;
  --设置药品储备限额
  Procedure Zlhis_Dict_041
  (
    类别_In   收费项目目录.类别%Type,
    药品id_In 收费项目目录.Id%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><类别>' || 类别_In || '</类别><药品ID>' || 药品id_In || '</药品ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_041', v_Value);
  End Zlhis_Dict_041;
  --新增卫材品种
  Procedure Zlhis_Dict_042(Id_In 诊疗项目目录.Id%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><材料ID>' || Id_In || '</材料ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_042', v_Value);
  End Zlhis_Dict_042;
  --新增卫材规格
  Procedure Zlhis_Dict_043(Id_In 收费项目目录.Id%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><材料ID>' || Id_In || '</材料ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_043', v_Value);
  End Zlhis_Dict_043;
  --修改卫材规格
  Procedure Zlhis_Dict_044(Id_In 收费项目目录.Id%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><材料ID>' || Id_In || '</材料ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_044', v_Value);
  End Zlhis_Dict_044;
  --删除卫材规格
  Procedure Zlhis_Dict_045
  (
   Id_In 收费项目目录.Id%Type,
   编码_In   收费项目目录.编码%Type,
   名称_In   收费项目目录.名称%Type,
   规格_In   收费项目目录.规格%Type,
   产地_In   收费项目目录.产地%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><材料ID>' || Id_In || '</材料ID><编码>' || 编码_In || '</编码><名称>' || 名称_In  || '</名称><规格>' || 规格_In || '</规格><产地>' || 产地_In || '</产地></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_045', v_Value);
  End Zlhis_Dict_045;
  --停用卫材规格
  Procedure Zlhis_Dict_046(Id_In 收费项目目录.Id%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><材料ID>' || Id_In || '</材料ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_046', v_Value);
  End Zlhis_Dict_046;
  --启用卫材规格
  Procedure Zlhis_Dict_047(Id_In 收费项目目录.Id%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><材料ID>' || Id_In || '</材料ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_047', v_Value);
  End Zlhis_Dict_047;
  --医保对码
  Procedure Zlhis_Dict_048
  (
    险类_In       In 保险支付项目.险类%Type,
    收费细目id_In In 保险支付项目.收费细目id%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><险类>' || 险类_In || '</险类><收费细目ID>' || 收费细目id_In || '</收费细目ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_048', v_Value);
  End Zlhis_Dict_048;
  --删除医保对码
  Procedure Zlhis_Dict_049
  (
    险类_In       In 保险支付项目.险类%Type,
    收费细目id_In In 保险支付项目.收费细目id%Type,
    项目编码_In   In 收费项目目录.编码%Type,
    项目名称_In   In 收费项目目录.名称%Type,
    医保编码_In   In 保险支付项目.项目编码%Type,
    医保名称_In   In 保险支付项目.项目名称%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><险类>' || 险类_In || '</险类><收费细目ID>' || 收费细目id_In || '</收费细目ID><项目编码>' || 项目编码_In || '</项目编码><项目名称>' ||
               项目名称_In || '</项目名称><医保编码>' || 医保编码_In || '</医保编码><医保名称>' || 医保名称_In || '</医保名称></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_049', v_Value);
  End Zlhis_Dict_049;
  --新增卫材分类
  Procedure Zlhis_Dict_050
  (
    类型_In 诊疗分类目录.类型%Type,
    ID_In 诊疗分类目录.ID%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><类型>' || 类型_In || '</类型><ID>' || ID_In ||  '</ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_050', v_Value);
  End Zlhis_Dict_050;
  --修改卫材分类
  Procedure ZLHIS_DICT_051
  (
    类型_In 诊疗分类目录.类型%Type,
    ID_In 诊疗分类目录.ID%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><类型>' || 类型_In || '</类型><ID>' || ID_In ||  '</ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_051', v_Value);
  End ZLHIS_DICT_051;
  --删除卫材分类
  Procedure ZLHIS_DICT_052
  (
    类型_In 诊疗分类目录.类型%Type,
    ID_In 诊疗分类目录.ID%Type,
    编码_In 诊疗分类目录.编码%Type,
    名称_In 诊疗分类目录.名称%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><类型>' || 类型_In || '</类型><ID>' || Id_In || '</ID><编码>' || 编码_In || '</编码><名称>' || 名称_In  || '</名称></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DICT_052', v_Value);
  End ZLHIS_DICT_052;
  --药品备药发送
  Procedure Zlhis_Drug_001(No_In 药品收发记录.No%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><单据号>' || No_In || '</单据号></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DRUG_001', v_Value);
  End Zlhis_Drug_001;
  --取消药品备药发送
  Procedure Zlhis_Drug_002(No_In 药品收发记录.No%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><单据号>' || No_In || '</单据号></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DRUG_002', v_Value);
  End Zlhis_Drug_002;
  --药品移库单接收
  Procedure Zlhis_Drug_003(No_In 药品收发记录.No%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><单据号>' || No_In || '</单据号></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DRUG_003', v_Value);
  End Zlhis_Drug_003;
  --药品移库单冲销
  Procedure Zlhis_Drug_004(No_In 药品收发记录.No%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><单据号>' || No_In || '</单据号></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DRUG_004', v_Value);
  End Zlhis_Drug_004;
  --部门发药
  Procedure Zlhis_Drug_005
  (
    库房id_In 药品收发记录.库房id%Type,
    收发id_In 药品收发记录.Id%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><库房ID>' || 库房id_In || '</库房ID><收发ID>' || 收发id_In || '</收发ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DRUG_005', v_Value);
  End Zlhis_Drug_005;
  --部门退药
  Procedure Zlhis_Drug_006
  (
    冲销收发id_In 药品收发记录.Id%Type,
    待发收发id_In 药品收发记录.Id%Type,
    数量_In       药品收发记录.实际数量%Type,
    费用id_In     门诊费用记录.Id%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><冲销记录ID>' || 冲销收发id_In || '</冲销记录ID><待发记录ID>' || 待发收发id_In || '</待发记录ID><数量>' || 数量_In ||
               '</数量><费用ID>' || 费用id_In || '</费用ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DRUG_006', v_Value);
  End Zlhis_Drug_006;
  --药品调价
  Procedure ZLHIS_DRUG_007
  (
    价格ID_In 药品价格记录.ID%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><价格ID>' || 价格ID_In ||  '</价格ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DRUG_007', v_Value);
  End ZLHIS_DRUG_007;
  --静配发送
  Procedure ZLHIS_DRUG_008
  (
    记录Ids_In Varchar2
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
    n_记录id 输液配药记录.ID%Type;
    v_Tmp    varchar2(4000);
  Begin
    If 记录Ids_In Is Null Then
      v_Tmp := Null;
    Else
      v_Tmp := 记录Ids_In || ',';
    End If;
    
    v_Value := '<root><记录IDS>';
    
    While v_Tmp Is Not Null Loop
      --分解单据ID串
      n_记录id :=to_number(Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1));
      v_Tmp    := Replace(',' || v_Tmp, ',' || n_记录id || ',');
      
      v_Value:=v_Value || '<记录ID>' || n_记录id || '</记录ID>';
    End Loop;
    
    v_Value:=v_Value || '</记录IDS></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DRUG_008', v_Value);
  End ZLHIS_DRUG_008;
  --药品调售价
  Procedure ZLHIS_DRUG_009
  (
    价格ID_In 药品价格记录.ID%Type,
    时价_In Number
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><价格ID>' || 价格ID_In ||  '</价格ID><时价>' || 时价_In || '</时价></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DRUG_009', v_Value);
  End ZLHIS_DRUG_009;
  --卫材调成本价
  Procedure ZLHIS_DRUG_010
  (
    价格ID_In 成本价调价信息.ID%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><价格ID>' || 价格ID_In ||  '</价格ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DRUG_010', v_Value);
  End ZLHIS_DRUG_010;
  --卫材调售价
  Procedure ZLHIS_DRUG_011
  (
    价格ID_In 收费价目.ID%Type,
    时价_In Number
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><价格ID>' || 价格ID_In ||  '</价格ID><时价>' || 时价_In || '</时价></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_DRUG_011', v_Value);
  End ZLHIS_DRUG_011;

  --2.停止患者医嘱，住院
  Procedure Zlhis_Cis_002
  (
    病人id_In  In 病人医嘱记录.病人id%Type,
    主页id_In  In 病人医嘱记录.主页id%Type,
    医嘱id_In  In 病人医嘱记录.Id%Type,
    医嘱ids_In In Varchar2
  ) Is
  Begin
    If p_Msg_Using('ZLHIS_CIS_002') = 0 Then
      Return;
    End If;
    If 医嘱id_In Is Not Null Then
      b_Message.p_Msg_Todo_Insert('ZLHIS_CIS_002',
                                  '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID><ID>' || 医嘱id_In ||
                                   '</ID></root>');
    Else
      For R In (Select '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID><ID>' || ID || '</ID></root>' As Xml_Value
                From 病人医嘱记录
                Where ID In (Select Column_Value From Table(f_Num2list(医嘱ids_In))) And 相关id Is Null) Loop
        b_Message.p_Msg_Todo_Insert('ZLHIS_CIS_002', r.Xml_Value);
      End Loop;
    End If;
  End Zlhis_Cis_002;
  --3.作废患者医嘱，门诊/住院
  Procedure Zlhis_Cis_003
  (
    病人id_In In 病人医嘱记录.病人id%Type,
    主页id_In In 病人医嘱记录.主页id%Type,
    挂号单_In In 病人挂号记录.No%Type,
    医嘱id_In In 病人医嘱记录.Id%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID><挂号单>' || 挂号单_In || '</挂号单><ID>' ||
               医嘱id_In || '</ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_CIS_003', v_Value);
  End Zlhis_Cis_003;

  --10.下达患者诊断，门诊/住院
  Procedure Zlhis_Cis_010
  (
    病人id_In In 病人挂号记录.病人id%Type,
    就诊id_In In 病人挂号记录.Id%Type, --门诊病人 挂号ID，住院病人 主页ID
    诊断id_In In 病人诊断记录.Id%Type
  ) Is
  Begin
    b_Message.p_Msg_Todo_Insert('ZLHIS_CIS_010',
                                '<root><病人ID>' || 病人id_In || '</病人ID><就诊ID>' || 就诊id_In || '</就诊ID><ID>' || 诊断id_In ||
                                 '</ID></root>');
  End Zlhis_Cis_010;
  --11.撤消患者诊断
  Procedure Zlhis_Cis_011
  (
    病人id_In   In 病人挂号记录.病人id%Type,
    就诊id_In   In 病人挂号记录.Id%Type, --门诊病人 挂号ID，住院病人 主页ID
    Id_In       In 病人诊断记录.Id%Type,
    疾病id_In   In 病人诊断记录.疾病id%Type,
    诊断id_In   In 病人诊断记录.诊断id%Type,
    诊断描述_In In 病人诊断记录.诊断描述%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><病人ID>' || 病人id_In || '</病人ID><就诊ID>' || 就诊id_In || '</就诊ID><ID>' || Id_In || '</ID><疾病ID>' ||
               疾病id_In || '</疾病ID><诊断ID>' || 诊断id_In || '</诊断ID><诊断描述>' || 诊断描述_In || '</诊断描述></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_CIS_011', v_Value);
  End Zlhis_Cis_011;

  --病区执行医嘱校对
  Procedure Zlhis_Cis_012
  (
    病人id_In In 病人医嘱记录.病人id%Type,
    主页id_In In 病人医嘱记录.主页id%Type,
    医嘱id_In In 病人医嘱记录.Id%Type
  ) Is
  Begin
    b_Message.p_Msg_Todo_Insert('ZLHIS_CIS_012',
                                '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID><ID>' || 医嘱id_In ||
                                 '</ID></root>');
  End Zlhis_Cis_012;

  --13.检验危急值阅读通知
  Procedure Zlhis_Cis_014
  (
    病人id_In In 病人挂号记录.病人id%Type,
    就诊id_In In 病人挂号记录.Id%Type, --门诊病人 挂号ID，住院病人 主页ID
    医嘱id_In In 病人医嘱记录.Id%Type,
    消息id_In In 业务消息清单.Id%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><病人ID>' || 病人id_In || '</病人ID><就诊ID>' || 就诊id_In || '</就诊ID><医嘱ID>' || 医嘱id_In || '</医嘱ID><ID>' ||
               消息id_In || '</ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_CIS_014', v_Value);
  End Zlhis_Cis_014;
  --15.患者检验申请，门诊/住院
  Procedure Zlhis_Cis_016
  (
    病人id_In   In 病人医嘱记录.病人id%Type,
    主页id_In   In 病人医嘱记录.主页id%Type,
    挂号单_In   In 病人挂号记录.No%Type,
    发送号_In   In 病人医嘱发送.发送号%Type,
    医嘱id_In   In 病人医嘱记录.Id%Type,
    病人来源_In In 病人医嘱记录.病人来源%Type --1-门诊;2-住院;3-外来(今后用于辅诊部门接收外来病人);4-体检病人
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID><挂号单>' || 挂号单_In || '</挂号单><发送号>' ||
               发送号_In || '</发送号><ID>' || 医嘱id_In || '</ID><病人来源>' || 病人来源_In || '</病人来源></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_CIS_016', v_Value);
  End Zlhis_Cis_016;
  --16.患者检查申请，门诊/住院
  Procedure Zlhis_Cis_017
  (
    病人id_In   In 病人医嘱记录.病人id%Type,
    主页id_In   In 病人医嘱记录.主页id%Type,
    挂号单_In   In 病人挂号记录.No%Type,
    发送号_In   In 病人医嘱发送.发送号%Type,
    医嘱id_In   In 病人医嘱记录.Id%Type,
    病人来源_In In 病人医嘱记录.病人来源%Type --1-门诊;2-住院;3-外来(今后用于辅诊部门接收外来病人);4-体检病人
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
    v_操作类型 诊疗项目目录.操作类型%Type;
  Begin
    Select MAX(A.操作类型) Into v_操作类型 From 诊疗项目目录 A,病人医嘱记录 B Where B.诊疗项目ID = a.ID And B.ID = 医嘱id_In;
    v_Value := '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID><挂号单>' || 挂号单_In || '</挂号单><发送号>' ||
               发送号_In || '</发送号><ID>' || 医嘱id_In || '</ID><病人来源>' || 病人来源_In || '</病人来源></root>';
    If v_操作类型 = '病理' Then
       b_Message.p_Msg_Todo_Insert('ZLHIS_CIS_054', v_Value);
    Else
       b_Message.p_Msg_Todo_Insert('ZLHIS_CIS_017', v_Value);
    End If;
  End Zlhis_Cis_017;
  --17.患者手术申请，门诊/住院
  Procedure Zlhis_Cis_018
  (
    病人id_In In 病人医嘱记录.病人id%Type,
    主页id_In In 病人医嘱记录.主页id%Type,
    挂号单_In In 病人挂号记录.No%Type,
    发送号_In In 病人医嘱发送.发送号%Type,
    医嘱id_In In 病人医嘱记录.Id%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID><挂号单>' || 挂号单_In || '</挂号单><发送号>' ||
               发送号_In || '</发送号><ID>' || 医嘱id_In || '</ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_CIS_018', v_Value);
  End Zlhis_Cis_018;
  --18.患者输血申请，住院
  Procedure Zlhis_Cis_019
  (
    病人id_In In 病人医嘱记录.病人id%Type,
    主页id_In In 病人医嘱记录.主页id%Type,
    挂号单_In In 病人挂号记录.No%Type,
    发送号_In In 病人医嘱发送.发送号%Type,
    医嘱id_In In 病人医嘱记录.Id%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID><挂号单>' || 挂号单_In || '</挂号单><发送号>' ||
               发送号_In || '</发送号><ID>' || 医嘱id_In || '</ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_CIS_019', v_Value);
  End Zlhis_Cis_019;
  --19.患者会诊申请，住院
  Procedure Zlhis_Cis_020
  (
    病人id_In In 病人医嘱记录.病人id%Type,
    主页id_In In 病人医嘱记录.主页id%Type,
    发送号_In In 病人医嘱发送.发送号%Type,
    医嘱id_In In 病人医嘱记录.Id%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID><发送号>' || 发送号_In || '</发送号><ID>' ||
               医嘱id_In || '</ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_CIS_020', v_Value);
  End Zlhis_Cis_020;
  --20.患者抢救医嘱，住院
  Procedure Zlhis_Cis_021
  (
    病人id_In In 病人医嘱记录.病人id%Type,
    主页id_In In 病人医嘱记录.主页id%Type,
    发送号_In In 病人医嘱发送.发送号%Type,
    医嘱id_In In 病人医嘱记录.Id%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID><发送号>' || 发送号_In || '</发送号><ID>' ||
               医嘱id_In || '</ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_CIS_021', v_Value);
  End Zlhis_Cis_021;
  --21.患者死亡医嘱，住院
  Procedure Zlhis_Cis_022
  (
    病人id_In In 病人医嘱记录.病人id%Type,
    主页id_In In 病人医嘱记录.主页id%Type,
    发送号_In In 病人医嘱发送.发送号%Type,
    医嘱id_In In 病人医嘱记录.Id%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID><发送号>' || 发送号_In || '</发送号><ID>' ||
               医嘱id_In || '</ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_CIS_022', v_Value);
  End Zlhis_Cis_022;
  --22.患者特殊治疗医嘱，住院
  Procedure Zlhis_Cis_023
  (
    病人id_In In 病人医嘱记录.病人id%Type,
    主页id_In In 病人医嘱记录.主页id%Type,
    发送号_In In 病人医嘱发送.发送号%Type,
    医嘱id_In In 病人医嘱记录.Id%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID><发送号>' || 发送号_In || '</发送号><ID>' ||
               医嘱id_In || '</ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_CIS_023', v_Value);
  End Zlhis_Cis_023;

  --24.检查危急值阅读通知
  Procedure Zlhis_Cis_025
  (
    病人id_In In 病人挂号记录.病人id%Type,
    就诊id_In In 病人挂号记录.Id%Type, --门诊病人 挂号ID，住院病人 主页ID
    医嘱id_In In 病人医嘱记录.Id%Type,
    消息id_In In 业务消息清单.Id%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><病人ID>' || 病人id_In || '</病人ID><就诊ID>' || 就诊id_In || '</就诊ID><医嘱ID>' || 医嘱id_In || '</医嘱ID><ID>' ||
               消息id_In || '</ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_CIS_025', v_Value);
  End Zlhis_Cis_025;

  --病区执行医嘱发送
  Procedure Zlhis_Cis_026
  (
    病人id_In In 病人医嘱记录.病人id%Type,
    主页id_In In 病人医嘱记录.主页id%Type,
    发送号_In In 病人医嘱发送.发送号%Type,
    医嘱id_In In 病人医嘱记录.Id%Type
  ) Is
  Begin
    b_Message.p_Msg_Todo_Insert('ZLHIS_CIS_026',
                                '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID><发送号>' || 发送号_In ||
                                 '</发送号><ID>' || 医嘱id_In || '</ID></root>');
  End Zlhis_Cis_026;

  --撤消患者检验申请
  Procedure Zlhis_Cis_036
  (
    病人id_In   In 病人医嘱记录.病人id%Type,
    主页id_In   In 病人医嘱记录.主页id%Type,
    挂号单_In   In 病人挂号记录.No%Type,
    发送号_In   In 病人医嘱发送.发送号%Type,
    医嘱id_In   In 病人医嘱记录.Id%Type,
    No_In       In 病人医嘱发送.No%Type,
    病人来源_In In 病人医嘱记录.病人来源%Type --1-门诊;2-住院;3-外来(今后用于辅诊部门接收外来病人);4-体检病人
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID><挂号单>' || 挂号单_In || '</挂号单><发送号>' ||
               发送号_In || '</发送号><ID>' || 医嘱id_In || '</ID><NO>' || No_In || '</NO><病人来源>' || 病人来源_In ||
               '</病人来源></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_CIS_036', v_Value);
  End Zlhis_Cis_036;

  --撤消患者检查申请
  Procedure Zlhis_Cis_037
  (
    病人id_In   In 病人医嘱记录.病人id%Type,
    主页id_In   In 病人医嘱记录.主页id%Type,
    挂号单_In   In 病人挂号记录.No%Type,
    发送号_In   In 病人医嘱发送.发送号%Type,
    医嘱id_In   In 病人医嘱记录.Id%Type,
    No_In       In 病人医嘱发送.No%Type,
    病人来源_In In 病人医嘱记录.病人来源%Type --1-门诊;2-住院;3-外来(今后用于辅诊部门接收外来病人);4-体检病人
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
    v_操作类型 诊疗项目目录.操作类型%Type;
  Begin
    Select MAX(A.操作类型) Into v_操作类型 From 诊疗项目目录 A,病人医嘱记录 B Where B.诊疗项目ID = a.ID And B.ID = 医嘱id_In;
    v_Value := '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID><挂号单>' || 挂号单_In || '</挂号单><发送号>' ||
               发送号_In || '</发送号><ID>' || 医嘱id_In || '</ID><NO>' || No_In || '</NO><病人来源>' || 病人来源_In ||
               '</病人来源></root>';
    If v_操作类型 = '病理' Then
       b_Message.p_Msg_Todo_Insert('ZLHIS_CIS_055', v_Value);
    Else
       b_Message.p_Msg_Todo_Insert('ZLHIS_CIS_037', v_Value);
    End If;
  End Zlhis_Cis_037;

  --撤消患者手术申请
  Procedure Zlhis_Cis_038
  (
    病人id_In In 病人医嘱记录.病人id%Type,
    主页id_In In 病人医嘱记录.主页id%Type,
    挂号单_In In 病人挂号记录.No%Type,
    发送号_In In 病人医嘱发送.发送号%Type,
    医嘱id_In In 病人医嘱记录.Id%Type,
    No_In     In 病人医嘱发送.No%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID><挂号单>' || 挂号单_In || '</挂号单><发送号>' ||
               发送号_In || '</发送号><ID>' || 医嘱id_In || '</ID><NO>' || No_In || '</NO></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_CIS_038', v_Value);
  End Zlhis_Cis_038;

  --撤消患者输血申请
  Procedure Zlhis_Cis_039
  (
    病人id_In In 病人医嘱记录.病人id%Type,
    主页id_In In 病人医嘱记录.主页id%Type,
    挂号单_In In 病人挂号记录.No%Type,
    发送号_In In 病人医嘱发送.发送号%Type,
    医嘱id_In In 病人医嘱记录.Id%Type,
    No_In     In 病人医嘱发送.No%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID><挂号单>' || 挂号单_In || '</挂号单><发送号>' ||
               发送号_In || '</发送号><ID>' || 医嘱id_In || '</ID><NO>' || No_In || '</NO></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_CIS_039', v_Value);
  End Zlhis_Cis_039;

  --撤消患者会诊申请
  Procedure Zlhis_Cis_040
  (
    病人id_In In 病人医嘱记录.病人id%Type,
    主页id_In In 病人医嘱记录.主页id%Type,
    发送号_In In 病人医嘱发送.发送号%Type,
    医嘱id_In In 病人医嘱记录.Id%Type,
    No_In     In 病人医嘱发送.No%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID><发送号>' || 发送号_In || '</发送号><ID>' ||
               医嘱id_In || '</ID><NO>' || No_In || '</NO></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_CIS_040', v_Value);
  End Zlhis_Cis_040;

  --撤消患者抢救医嘱
  Procedure Zlhis_Cis_041
  (
    病人id_In In 病人医嘱记录.病人id%Type,
    主页id_In In 病人医嘱记录.主页id%Type,
    发送号_In In 病人医嘱发送.发送号%Type,
    医嘱id_In In 病人医嘱记录.Id%Type,
    No_In     In 病人医嘱发送.No%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID><发送号>' || 发送号_In || '</发送号><ID>' ||
               医嘱id_In || '</ID><NO>' || No_In || '</NO></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_CIS_041', v_Value);
  End Zlhis_Cis_041;

  --撤消患者死亡医嘱
  Procedure Zlhis_Cis_042
  (
    病人id_In In 病人医嘱记录.病人id%Type,
    主页id_In In 病人医嘱记录.主页id%Type,
    发送号_In In 病人医嘱发送.发送号%Type,
    医嘱id_In In 病人医嘱记录.Id%Type,
    No_In     In 病人医嘱发送.No%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID><发送号>' || 发送号_In || '</发送号><ID>' ||
               医嘱id_In || '</ID><NO>' || No_In || '</NO></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_CIS_042', v_Value);
  End Zlhis_Cis_042;

  --撤消特殊治疗医嘱
  Procedure Zlhis_Cis_043
  (
    病人id_In In 病人医嘱记录.病人id%Type,
    主页id_In In 病人医嘱记录.主页id%Type,
    发送号_In In 病人医嘱发送.发送号%Type,
    医嘱id_In In 病人医嘱记录.Id%Type,
    No_In     In 病人医嘱发送.No%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID><发送号>' || 发送号_In || '</发送号><ID>' ||
               医嘱id_In || '</ID><NO>' || No_In || '</NO></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_CIS_043', v_Value);
  End Zlhis_Cis_043;

  --撤消病区执行医嘱
  Procedure Zlhis_Cis_044
  (
    病人id_In   In 病人医嘱记录.病人id%Type,
    主页id_In   In 病人医嘱记录.主页id%Type,
    发送号_In   In 病人医嘱发送.发送号%Type,
    医嘱id_In   In 病人医嘱记录.Id%Type,
    No_In       In 病人医嘱发送.No%Type,
    发送数次_In In 病人医嘱发送.发送数次%Type,
    首次时间_In In 病人医嘱发送.首次时间%Type,
    末次时间_In In 病人医嘱发送.末次时间%Type,
    样本条码_In In 病人医嘱发送.样本条码%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID><发送号>' || 发送号_In || '</发送号><ID>' ||
               医嘱id_In || '</ID><NO>' || No_In || '</NO><发送数次>' || 发送数次_In || '</发送数次><首次时间>' ||
               To_Char(首次时间_In, 'yyyy-mm-dd hh24:mi:ss') || '</首次时间><末次时间>' ||
               To_Char(末次时间_In, 'yyyy-mm-dd hh24:mi:ss') || '</末次时间><样本条码>' || 样本条码_In || '</样本条码></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_CIS_044', v_Value);
  End Zlhis_Cis_044;

  --患者医嘱执行登记
  Procedure Zlhis_Cis_050
  (
    病人id_In   In 病人医嘱记录.病人id%Type,
    主页id_In   In 病人医嘱记录.主页id%Type,
    挂号单_In   In 病人挂号记录.No%Type,
    发送号_In   In 病人医嘱发送.发送号%Type,
    医嘱id_In   In 病人医嘱记录.Id%Type,
    要求时间_In In 病人医嘱执行.要求时间%Type,
    执行时间_In In 病人医嘱执行.执行时间%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID><挂号单>' || 挂号单_In || '</挂号单><发送号>' ||
               发送号_In || '</发送号><ID>' || 医嘱id_In || '</ID><要求时间>' || To_Char(要求时间_In, 'yyyy-mm-dd hh24:mi:ss') ||
               '</要求时间><执行时间>' || To_Char(执行时间_In, 'yyyy-mm-dd hh24:mi:ss') || '</执行时间></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_CIS_050', v_Value);
  End Zlhis_Cis_050;

  --患者医嘱取消执行登记
  Procedure Zlhis_Cis_051
  (
    病人id_In   In 病人医嘱记录.病人id%Type,
    主页id_In   In 病人医嘱记录.主页id%Type,
    挂号单_In   In 病人挂号记录.No%Type,
    发送号_In   In 病人医嘱发送.发送号%Type,
    医嘱id_In   In 病人医嘱记录.Id%Type,
    要求时间_In In 病人医嘱执行.要求时间%Type,
    执行时间_In In 病人医嘱执行.执行时间%Type,
    本次数次_In In 病人医嘱执行.本次数次%Type,
    执行结果_In In 病人医嘱执行.执行结果%Type,
    执行摘要_In In 病人医嘱执行.执行摘要%Type,
    执行科室_In In 病人医嘱执行.执行科室id%Type,
    执行人_In   In 病人医嘱执行.执行人%Type,
    核对人_In   In 病人医嘱执行.核对人%Type,
    记录来源_In In 病人医嘱执行.记录来源%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID><挂号单>' || 挂号单_In || '</挂号单><发送号>' ||
               发送号_In || '</发送号><ID>' || 医嘱id_In || '</ID><要求时间>' || To_Char(要求时间_In, 'yyyy-mm-dd hh24:mi:ss') ||
               '</要求时间><执行时间>' || To_Char(执行时间_In, 'yyyy-mm-dd hh24:mi:ss') || '</执行时间><本次数次>' || 本次数次_In ||
               '</本次数次><执行结果>' || 执行结果_In || '</执行结果><执行摘要>' || 执行摘要_In || '</执行摘要><执行科室ID>' || 执行科室_In ||
               '</执行科室ID><执行人>' || 执行人_In || '</执行人><核对人>' || 核对人_In || '</核对人><记录来源>' || 记录来源_In || '</记录来源></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_CIS_051', v_Value);
  End Zlhis_Cis_051;
  --患者医嘱执行完成
  Procedure Zlhis_Cis_052
  (
    病人id_In In 病人医嘱记录.病人id%Type,
    主页id_In In 病人医嘱记录.主页id%Type,
    挂号单_In In 病人挂号记录.No%Type,
    发送号_In In 病人医嘱发送.发送号%Type,
    医嘱id_In In 病人医嘱记录.Id%Type
  ) Is
  Begin
    b_Message.p_Msg_Todo_Insert('ZLHIS_CIS_052',
                                '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID><挂号单>' || 挂号单_In ||
                                 '</挂号单><发送号>' || 发送号_In || '</发送号><ID>' || 医嘱id_In || '</ID></root>');
  End Zlhis_Cis_052;
  --患者医嘱撤消执行完成
  Procedure Zlhis_Cis_053
  (
    病人id_In In 病人医嘱记录.病人id%Type,
    主页id_In In 病人医嘱记录.主页id%Type,
    挂号单_In In 病人挂号记录.No%Type,
    发送号_In In 病人医嘱发送.发送号%Type,
    医嘱id_In In 病人医嘱记录.Id%Type
  ) Is
  Begin
    b_Message.p_Msg_Todo_Insert('ZLHIS_CIS_053',
                                '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID><挂号单>' || 挂号单_In ||
                                 '</挂号单><发送号>' || 发送号_In || '</发送号><ID>' || 医嘱id_In || '</ID></root>');
  End Zlhis_Cis_053;

  --26.检查报告完成，检查完成时
  Procedure Zlhis_Pacs_001
  (
    医嘱id_In   In 影像检查记录.医嘱id%Type,
    报告id_Ins  In Varchar2,
    报告类型_In In Number --1-老版PACS报告，2-老版病历编辑器报告，3-新版编辑器报告
  ) Is
  Begin
    If p_Msg_Using('ZLHIS_PACS_001') = 0 Then
      Return;
    End If;
    For R In (Select '<root><医嘱ID>' || 医嘱id_In || '</医嘱ID><报告ID>' || Column_Value || '</报告ID><报告类型>' || 报告类型_In ||
                      '<报告类型></root>' As Xml_Value
              From Table(f_Str2list(报告id_Ins))) Loop
      b_Message.p_Msg_Todo_Insert('ZLHIS_PACS_001', r.Xml_Value);
    End Loop;
  End Zlhis_Pacs_001;
  --27.检查状态同步，检查状态改变后
  Procedure Zlhis_Pacs_002
  (
    医嘱id_In In 影像检查记录.医嘱id%Type,
    原状态_In In 病人医嘱发送.执行过程%Type,
    新状态_In In 病人医嘱发送.执行过程%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><医嘱ID>' || 医嘱id_In || '</医嘱ID><原状态>' || 原状态_In || '</原状态><新状态>' || 新状态_In || '</新状态></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_PACS_002', v_Value);
  End Zlhis_Pacs_002;
  --28.检查状态回退，检查状态回退后
  Procedure Zlhis_Pacs_003
  (
    医嘱id_In In 影像检查记录.医嘱id%Type,
    原状态_In In 病人医嘱发送.执行过程%Type,
    新状态_In In 病人医嘱发送.执行过程%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><医嘱ID>' || 医嘱id_In || '</医嘱ID><原状态>' || 原状态_In || '</原状态><新状态>' || 新状态_In || '</新状态></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_PACS_003', v_Value);
  End Zlhis_Pacs_003;
  --29.检查报告撤销，撤销检查完成时
  Procedure Zlhis_Pacs_004
  (
    医嘱id_In   In 影像检查记录.医嘱id%Type,
    报告id_Ins  In Varchar2,
    报告类型_In In Number --1-老版PACS报告，2-老版病历编辑器报告，3-新版编辑器报告
  ) Is
  Begin
    If p_Msg_Using('ZLHIS_PACS_004') = 0 Then
      Return;
    End If;
    For R In (Select '<root><医嘱ID>' || 医嘱id_In || '</医嘱ID><报告ID>' || Column_Value || '</报告ID><报告类型>' || 报告类型_In ||
                      '<报告类型></root>' As Xml_Value
              From Table(f_Str2list(报告id_Ins))) Loop
      b_Message.p_Msg_Todo_Insert('ZLHIS_PACS_004', r.Xml_Value);
    End Loop;
  End Zlhis_Pacs_004;
  --30.检查危急值通知，检查发生危急值时
  Procedure Zlhis_Pacs_005(医嘱id_In In 影像检查记录.医嘱id%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><医嘱ID>' || 医嘱id_In || '</医嘱ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_PACS_005', v_Value);
  End Zlhis_Pacs_005;
  -- 检查预约通知，检查预约时
  Procedure Zlhis_Pacs_006
  (
    医嘱id_In In 影像检查记录.医嘱id%Type,
    预约id_In In Ris检查预约.预约id%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><医嘱ID>' || 医嘱id_In || '</医嘱ID><预约ID>' || 预约id_In || '</预约ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_PACS_006', v_Value);
  End Zlhis_Pacs_006;
  -- 取消检查预约，取消预约时
  Procedure Zlhis_Pacs_007
  (
    医嘱id_In       In 影像检查记录.医嘱id%Type,
    预约id_In       In Ris检查预约.预约id%Type,
    预约日期_In     In Ris检查预约.预约日期%Type,
    预约序号_In     In Ris检查预约.序号%Type,
    检查设备名称_In In Ris检查预约.检查设备名称%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><医嘱ID>' || 医嘱id_In || '</医嘱ID><预约ID>' || 预约id_In || '</预约ID><预约日期>' || 预约日期_In || '</预约日期><预约序号>' ||
               预约序号_In || '</预约序号><检查设备名称>' || 检查设备名称_In || '</检查设备名称></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_PACS_007', v_Value);
  End Zlhis_Pacs_007;

  --36.患者发卡或绑定卡
  Procedure Zlhis_Patient_018
  (
    变动id_In   In 病人变动记录.Id%Type,
    病人id_In   In 病人信息.病人id%Type,
    卡类别id_In In 医疗卡类别.Id%Type,
    卡号_In     In 病人医疗卡信息.卡号%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><变动ID>' || 变动id_In || '</变动ID><病人ID>' || 病人id_In || '</病人ID><卡类别ID>' || 卡类别id_In ||
               '</卡类别ID><卡号>' || 卡号_In || '</卡号></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_PATIENT_018', v_Value);
  End;

  --37.患者退卡
  Procedure Zlhis_Patient_019
  (
    变动id_In   In 病人变动记录.Id%Type,
    病人id_In   In 病人信息.病人id%Type,
    卡类别id_In In 医疗卡类别.Id%Type,
    卡号_In     In 病人医疗卡信息.卡号%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><变动ID>' || 变动id_In || '</变动ID><病人ID>' || 病人id_In || '</病人ID><卡类别ID>' || 卡类别id_In ||
               '</卡类别ID><卡号>' || 卡号_In || '</卡号></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_PATIENT_019', v_Value);
  End;

  --38.患者补卡/换卡
  Procedure Zlhis_Patient_020
  (
    变动id_In   In 病人变动记录.Id%Type,
    病人id_In   In 病人信息.病人id%Type,
    卡类别id_In In 医疗卡类别.Id%Type,
    原卡号_In   In 病人医疗卡信息.卡号%Type,
    新卡号_In   In 病人医疗卡信息.卡号%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><变动ID>' || 变动id_In || '</变动ID><病人ID>' || 病人id_In || '</病人ID><卡类别ID>' || 卡类别id_In ||
               '</卡类别ID><原卡号>' || 原卡号_In || '</原卡号><新卡号>' || 新卡号_In || '</新卡号></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_PATIENT_020', v_Value);
  End;

  --39.病人挂号登记（包含预约登记)
  Procedure Zlhis_Regist_001
  (
    挂号id_In In 病人挂号记录.Id%Type,
    No_In     In 病人挂号记录.No%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><挂号ID>' || 挂号id_In || '</挂号ID><NO>' || No_In || '</NO></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_REGIST_001', v_Value);
  End;

  --40.病人分诊
  Procedure Zlhis_Regist_002
  (
    挂号id_In In 病人挂号记录.Id%Type,
    No_In     In 病人挂号记录.No%Type,
    诊室_In   In 病人挂号记录.诊室%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><挂号ID>' || 挂号id_In || '</挂号ID><NO>' || No_In || '</NO><诊室>' || Nvl(诊室_In, '') || '</诊室></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_REGIST_002', v_Value);
  End;

  --41.病人退号（含取消预约)
  Procedure Zlhis_Regist_003
  (
    挂号id_In In 病人挂号记录.Id%Type,
    No_In     In 病人挂号记录.No%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><挂号ID>' || 挂号id_In || '</挂号ID><NO>' || No_In || '</NO></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_REGIST_003', v_Value);
  End;

  --42.临床出诊安排调整
  Procedure Zlhis_Regist_004
  (
    变动原因_In In Integer, --1-停诊;2-替诊;3-诊室变动
    记录id_In   In 临床出诊记录.Id%Type,
    变动id_In   In 临床出诊变动记录.Id%Type
    
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><变动原因>' || 变动原因_In || '</变动原因><记录ID>' || 记录id_In || '</记录ID><变动ID>' || 变动id_In ||
               '</变动ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_REGIST_004', v_Value);
  End;

  --43.门诊患者挂号换号操作
  Procedure Zlhis_Regist_005
  (
    No_In         In 病人挂号记录.No%Type,
    变动原因_In   Integer, --1-替诊;2-换号;3-预约日期变动,
    就诊变动id_In 就诊变动记录.Id%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><NO>' || No_In || '</NO><变动原因>' || 变动原因_In || '</变动原因><就诊变动ID>' || 就诊变动id_In ||
               '</就诊变动ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_REGIST_005', v_Value);
  End;


  --费用门诊收费及补充结算
  Procedure Zlhis_Charge_002
  (
    结算类型_In In Number,
    结帐id_In   In 门诊费用记录.结帐id%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    --结算类型_In:1-收费结算，2-补充结算
    v_Value := '<root><结算类型>' || 结算类型_In || '</结算类型><结帐ID>' || 结帐id_In || '</结帐ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_CHARGE_002', v_Value);
  End;


  --46.门诊退费单据
  Procedure Zlhis_Charge_004
  (
    退费类型_In In Number,
    结帐id_In   In 门诊费用记录.结帐id%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    --退费类型_In:1-收费结算，2-补充结算
    v_Value := '<root><退费类型>' || 退费类型_In || '</退费类型><结帐ID>' || 结帐id_In || '</结帐ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_CHARGE_004', v_Value);
  End;

  --47.收预交款
  Procedure Zlhis_Charge_005
  (
    预交id_In In 病人预交记录.Id%Type,
    单据号_In In 病人预交记录.No%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><预交ID>' || 预交id_In || '</预交ID><单据号>' || 单据号_In || '</单据号></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_CHARGE_005', v_Value);
  End;

  --48.退预交款(包含负数退预交款部分)
  Procedure Zlhis_Charge_006
  (
    退预交id_In In 病人预交记录.Id%Type,
    单据号_In   In 病人预交记录.No%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><退预交ID>' || 退预交id_In || '</退预交ID><单据号>' || 单据号_In || '</单据号></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_CHARGE_006', v_Value);
  End;

  --住院记帐单据
  Procedure Zlhis_Charge_007
  (
    收费类别_In In 住院费用记录.收费类别%Type,
    费用id_In   In 住院费用记录.Id%Type
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    v_Value := '<root><收费类别>' || 收费类别_In || '</收费类别><费用ID>' || 费用id_In || '</费用ID></root>';
    b_Message.p_Msg_Todo_Insert('ZLHIS_CHARGE_007', v_Value);
  End;

  --住院记帐单据销账
  Procedure Zlhis_Charge_008
  (
    收费类别_In In 住院费用记录.收费类别%Type,
    费用id_In   In 住院费用记录.Id%Type,
    收发ids_In  In Varchar2 := Null --可能费用ID对应多个收发id，对应格式：收发id,数量|收发id,数量；非药品不传
  ) Is
    v_Value   Zlmsg_Todo.Key_Value%Type;
    v_Tmp     Varchar2(4000);
    v_Infotmp Varchar2(4000);
    v_Fields  Varchar2(4000);
    v_收发id  Varchar2(50);
    v_数量    Varchar2(20);
  Begin
    If p_Msg_Using('ZLHIS_CHARGE_008') = 0 Then
      Return;
    End If;
    v_Value := '<root><收费类别>' || 收费类别_In || '</收费类别><费用ID>' || 费用id_In || '</费用ID>';
  
    If 收发ids_In Is Null Then
      v_Infotmp := Null;
      v_Tmp     := '<收发IDS>' || '<收发ID>' || '</收发ID>' || '<数量>' || '</数量>' || '</收发IDS>';
    Else
      v_Infotmp := 收发ids_In || '|';
      While v_Infotmp Is Not Null Loop
        --分解收发ID串
        v_Fields  := Substr(v_Infotmp, 1, Instr(v_Infotmp, '|') - 1);
        v_收发id  := Substr(v_Fields, 1, Instr(v_Fields, ',') - 1);
        v_数量    := Substr(v_Fields, Instr(v_Fields, ',') + 1);
        v_Infotmp := Replace('|' || v_Infotmp, '|' || v_Fields || '|');
      
        v_Tmp := v_Tmp || '<收发IDS>' || '<收发ID>' || v_收发id || '</收发ID>' || '<数量>' || v_数量 || '</数量>' || '</收发IDS>';
      End Loop;
    End If;
  
    v_Value := v_Value || v_Tmp || '</root>';
  
    b_Message.p_Msg_Todo_Insert('ZLHIS_CHARGE_008', v_Value);
  End;

  --53.住院患者入院登记
  Procedure Zlhis_Patient_001
  (
    病人id_In In 病案主页.病人id%Type,
    主页id_In In 病案主页.主页id%Type
  ) Is
    n_变动id 病人变动记录.Id%Type;
  Begin
    If p_Msg_Using('ZLHIS_PATIENT_001') = 0 Then
      Return;
    End If;
    Select Max(ID)
    Into n_变动id
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 1 And Nvl(附加床位, 0) = 0;
    b_Message.p_Msg_Todo_Insert('ZLHIS_PATIENT_001',
                                '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID><变动ID>' || n_变动id ||
                                 '</变动ID></root>');
  End Zlhis_Patient_001;
  --54.住院患者入院入科
  Procedure Zlhis_Patient_002
  (
    病人id_In In 病案主页.病人id%Type,
    主页id_In In 病案主页.主页id%Type
  ) Is
    n_变动id 病人变动记录.Id%Type;
  Begin
    If p_Msg_Using('ZLHIS_PATIENT_002') = 0 Then
      Return;
    End If;
    Select Max(ID)
    Into n_变动id
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And Nvl(附加床位, 0) = 0;
    b_Message.p_Msg_Todo_Insert('ZLHIS_PATIENT_002',
                                '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID><变动ID>' || n_变动id ||
                                 '</变动ID></root>');
  End Zlhis_Patient_002;
  --56.住院患者床位变更
  Procedure Zlhis_Patient_004
  (
    病人id_In In 病案主页.病人id%Type,
    主页id_In In 病案主页.主页id%Type
  ) Is
    v_原床号   Varchar2(255);
    v_新床号   Varchar2(255);
    n_变动id   Number(18);
    n_开始原因 Number(3);
    d_开始时间 Date;
  Begin
    If p_Msg_Using('ZLHIS_PATIENT_004') = 0 Then
      Return;
    End If;
    Select ID, 床号, 开始时间, 开始原因
    Into n_变动id, v_新床号, d_开始时间, n_开始原因
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And Nvl(附加床位, 0) = 0;
  
    Select Max(床号)
    Into v_原床号
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = d_开始时间 And 终止原因 = n_开始原因 And Nvl(附加床位, 0) = 0;
  
    b_Message.p_Msg_Todo_Insert('ZLHIS_PATIENT_004',
                                '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID>' || '<原床号>' ||
                                 v_原床号 || '</原床号>' || '<新床号>' || v_新床号 || '</新床号>' || '<变动ID>' || n_变动id || '</变动ID>' ||
                                 '</root>');
  End Zlhis_Patient_004;
  --57.住院患者病情变更
  Procedure Zlhis_Patient_005
  (
    病人id_In In 病案主页.病人id%Type,
    主页id_In In 病案主页.主页id%Type
  ) Is
    n_变动id 病人变动记录.Id%Type;
  Begin
    If p_Msg_Using('ZLHIS_PATIENT_005') = 0 Then
      Return;
    End If;
    Select Max(ID)
    Into n_变动id
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And Nvl(附加床位, 0) = 0;
    b_Message.p_Msg_Todo_Insert('ZLHIS_PATIENT_005',
                                '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID><变动ID>' || n_变动id ||
                                 '</变动ID></root>');
  End Zlhis_Patient_005;
  --58.住院患者变更撤消
  Procedure Zlhis_Patient_006
  (
    病人id_In   In 病案主页.病人id%Type,
    主页id_In   In 病案主页.主页id%Type,
    撤销方式_In In Varchar2
  ) Is
    n_科室id     病人变动记录.科室id%Type;
    n_病区id     病人变动记录.病区id%Type;
    n_护理等级id 病人变动记录.护理等级id%Type;
    n_医疗小组id 病人变动记录.医疗小组id%Type;
    v_床号       病人变动记录.床号%Type;
    v_责任护士   病人变动记录.责任护士%Type;
    v_主任医师   病人变动记录.主任医师%Type;
    v_主治医师   病人变动记录.主治医师%Type;
    v_经治医师   病人变动记录.经治医师%Type;
    v_病情       病人变动记录.病情%Type;
  Begin
    If p_Msg_Using('ZLHIS_PATIENT_006') = 0 Then
      Return;
    End If;
    Select Max(科室id), Max(病区id), Max(护理等级id), Max(医疗小组id), Max(床号), Max(责任护士), Max(主任医师), Max(主治医师), Max(经治医师), Max(病情)
    Into n_科室id, n_病区id, n_护理等级id, n_医疗小组id, v_床号, v_责任护士, v_主任医师, v_主治医师, v_经治医师, v_病情
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And (终止时间 Is Null Or 终止原因 = 1) And Nvl(附加床位, 0) = 0;
    b_Message.p_Msg_Todo_Insert('ZLHIS_PATIENT_006',
                                '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID><撤销方式>' || 撤销方式_In ||
                                 '</撤销方式><科室ID>' || n_科室id || '</科室ID>' || '<病区ID>' || n_病区id || '</病区ID>' || '<护理等级ID>' ||
                                 n_护理等级id || '</护理等级ID>' || '<医疗小组ID>' || n_医疗小组id || '</医疗小组ID>' || '<床号>' || v_床号 ||
                                 '</床号>' || '<责任护士>' || v_责任护士 || '</责任护士>' || '<主任医师>' || v_主任医师 || '</主任医师>' ||
                                 '<主治医师>' || v_主治医师 || '</主治医师>' || '<经治医师>' || v_经治医师 || '</经治医师>' || '<病情>' || v_病情 ||
                                 '</病情>' || '</root>');
  End Zlhis_Patient_006;
  --59.住院患者医护变更
  Procedure Zlhis_Patient_007
  (
    病人id_In In 病案主页.病人id%Type,
    主页id_In In 病案主页.主页id%Type
  ) Is
    v_原住院医生 Varchar2(100);
    v_新住院医生 Varchar2(100);
    v_原主治医生 Varchar2(100);
    v_新主治医生 Varchar2(100);
    v_原主任医生 Varchar2(100);
    v_新主任医生 Varchar2(100);
    v_原责任护士 Varchar2(100);
    v_新责任护士 Varchar2(100);
    n_变动id     Number(18);
    n_开始原因   Number(3);
    d_开始时间   Date;
  Begin
    If p_Msg_Using('ZLHIS_PATIENT_007') = 0 Then
      Return;
    End If;
    Select ID, 经治医师, 主治医师, 主任医师, 责任护士, 开始时间, 开始原因
    Into n_变动id, v_新住院医生, v_新主治医生, v_新主任医生, v_新责任护士, d_开始时间, n_开始原因
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And Nvl(附加床位, 0) = 0;
  
    Select Max(经治医师), Max(主治医师), Max(主任医师), Max(责任护士)
    Into v_原住院医生, v_原主治医生, v_原主任医生, v_原责任护士
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = d_开始时间 And 终止原因 = n_开始原因 And Nvl(附加床位, 0) = 0;
  
    b_Message.p_Msg_Todo_Insert('ZLHIS_PATIENT_007',
                                '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID>' || '<原住院医生>' ||
                                 v_原住院医生 || '</原住院医生>' || '<新住院医生>' || v_新住院医生 || '</新住院医生>' || '<原主治医生>' || v_原主治医生 ||
                                 '</原主治医生>' || '<新主治医生>' || v_新主治医生 || '</新主治医生>' || '<原主任医生>' || v_原主任医生 || '</原主任医生>' ||
                                 '<新主任医生>' || v_新主任医生 || '</新主任医生>' || '<原责任护士>' || v_原责任护士 || '</原责任护士>' || '<新责任护士>' ||
                                 v_新责任护士 || '</新责任护士>' || '<变动ID>' || n_变动id || '</变动ID>' || '</root>');
  End Zlhis_Patient_007;
  --住院患者护理等级变更
  Procedure Zlhis_Patient_008
  (
    病人id_In In 病案主页.病人id%Type,
    主页id_In In 病案主页.主页id%Type
  ) Is
    v_原护理等级id Number(18);
    v_新护理等级id Number(18);
    n_变动id       Number(18);
    n_开始原因     Number(3);
    d_开始时间     Date;
  Begin
    If p_Msg_Using('ZLHIS_PATIENT_008') = 0 Then
      Return;
    End If;
    Select ID, 护理等级id, 开始时间, 开始原因
    Into n_变动id, v_新护理等级id, d_开始时间, n_开始原因
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And Nvl(附加床位, 0) = 0;
  
    Select Max(护理等级id)
    Into v_原护理等级id
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = d_开始时间 And 终止原因 = n_开始原因 And Nvl(附加床位, 0) = 0;
  
    b_Message.p_Msg_Todo_Insert('ZLHIS_PATIENT_008',
                                '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID>' || '<原护理等级ID>' ||
                                 v_原护理等级id || '</原护理等级ID>' || '<新护理等级ID>' || v_新护理等级id || '</新护理等级ID>' || '<变动ID>' ||
                                 n_变动id || '</变动ID>' || '</root>');
  End Zlhis_Patient_008;
  --60.住院患者预出院
  Procedure Zlhis_Patient_009
  (
    病人id_In In 病案主页.病人id%Type,
    主页id_In In 病案主页.主页id%Type
  ) Is
    n_变动id 病人变动记录.Id%Type;
  Begin
    If p_Msg_Using('ZLHIS_PATIENT_009') = 0 Then
      Return;
    End If;
    Select Max(ID)
    Into n_变动id
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And Nvl(附加床位, 0) = 0;
    b_Message.p_Msg_Todo_Insert('ZLHIS_PATIENT_009',
                                '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID><变动ID>' || n_变动id ||
                                 '</变动ID></root>');
  End Zlhis_Patient_009;
  --61.住院患者出院
  Procedure Zlhis_Patient_010
  (
    病人id_In In 病案主页.病人id%Type,
    主页id_In In 病案主页.主页id%Type
  ) Is
  Begin
    b_Message.p_Msg_Todo_Insert('ZLHIS_PATIENT_010',
                                '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID></root>');
  End Zlhis_Patient_010;
  --62.住院患者新生儿登记
  Procedure Zlhis_Patient_011
  (
    病人id_In   In 病案主页.病人id%Type,
    主页id_In   In 病案主页.主页id%Type,
    婴儿序号_In 病人医嘱记录.婴儿%Type
  ) Is
  Begin
    b_Message.p_Msg_Todo_Insert('ZLHIS_PATIENT_011',
                                '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID><婴儿序号>' || 婴儿序号_In ||
                                 '</婴儿序号></root>');
  End Zlhis_Patient_011;
  --63.住院患者转入科室
  Procedure Zlhis_Patient_012
  (
    病人id_In In 病案主页.病人id%Type,
    主页id_In In 病案主页.主页id%Type
  ) Is
    v_转出科室id Number(18);
    v_转入科室id Number(18);
    n_变动id     Number(18);
    n_开始原因   Number(3);
    d_开始时间   Date;
  Begin
    If p_Msg_Using('ZLHIS_PATIENT_012') = 0 Then
      Return;
    End If;
    Select ID, 科室id, 开始时间, 开始原因
    Into n_变动id, v_转入科室id, d_开始时间, n_开始原因
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And Nvl(附加床位, 0) = 0;
  
    Select Max(科室id)
    Into v_转出科室id
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = d_开始时间 And 终止原因 = n_开始原因 And Nvl(附加床位, 0) = 0;
  
    b_Message.p_Msg_Todo_Insert('ZLHIS_PATIENT_012',
                                '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID>' || '<转出科室ID>' ||
                                 v_转出科室id || '</转出科室ID>' || '<转入科室ID>' || v_转入科室id || '</转入科室ID>' || '<变动ID>' || n_变动id ||
                                 '</变动ID>' || '</root>');
  End Zlhis_Patient_012;
  --64.新生儿登记作废
  Procedure Zlhis_Patient_013
  (
    病人id_In   In 病案主页.病人id%Type,
    主页id_In   In 病案主页.主页id%Type,
    婴儿序号_In 病人医嘱记录.婴儿%Type
  ) Is
  Begin
    b_Message.p_Msg_Todo_Insert('ZLHIS_PATIENT_013',
                                '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID><婴儿序号>' || 婴儿序号_In ||
                                 '</婴儿序号></root>');
  End Zlhis_Patient_013;
  --65.门诊患者登记
  Procedure Zlhis_Patient_015(病人id_In In 病案主页.病人id%Type) Is
  Begin
    b_Message.p_Msg_Todo_Insert('ZLHIS_PATIENT_015', '<root><病人ID>' || 病人id_In || '</病人ID></root>');
  End Zlhis_Patient_015;
  --66.患者信息修改
  Procedure Zlhis_Patient_016(病人id_In In 病案主页.病人id%Type) Is
  Begin
    b_Message.p_Msg_Todo_Insert('ZLHIS_PATIENT_016', '<root><病人ID>' || 病人id_In || '</病人ID></root>');
  End Zlhis_Patient_016;

  --67.患者合并
  Procedure Zlhis_Patient_017
  (
    病人id_In   In 病案主页.病人id%Type,
    原病人id_In In 病案主页.病人id%Type
  ) Is
  Begin
    b_Message.p_Msg_Todo_Insert('ZLHIS_PATIENT_017',
                                '<root><病人ID>' || 病人id_In || '</病人ID><原病人ID>' || 原病人id_In || '</原病人ID></root>');
  End Zlhis_Patient_017;

  --69.住院患者转入病区
  Procedure Zlhis_Patient_026
  (
    病人id_In In 病案主页.病人id%Type,
    主页id_In In 病案主页.主页id%Type
  ) Is
    v_转出病区id Number(18);
    v_转入病区id Number(18);
    n_变动id     Number(18);
    n_开始原因   Number(3);
    d_开始时间   Date;
  Begin
    If p_Msg_Using('ZLHIS_PATIENT_026') = 0 Then
      Return;
    End If;
    Select ID, 病区id, 开始时间, 开始原因
    Into n_变动id, v_转入病区id, d_开始时间, n_开始原因
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And Nvl(附加床位, 0) = 0;
  
    Select Max(病区id)
    Into v_转出病区id
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = d_开始时间 And 终止原因 = n_开始原因 And Nvl(附加床位, 0) = 0;
  
    b_Message.p_Msg_Todo_Insert('ZLHIS_PATIENT_026',
                                '<root><病人ID>' || 病人id_In || '</病人ID><主页ID>' || 主页id_In || '</主页ID>' || '<转出病区ID>' ||
                                 v_转出病区id || '</转出病区ID>' || '<转入病区ID>' || v_转入病区id || '</转入病区ID>' || '<变动ID>' || n_变动id ||
                                 '</变动ID>' || '</root>');
  End Zlhis_Patient_026;

  Procedure Zlhis_Patient_028(病人id_In In 病案主页.病人id%Type) Is
    v_姓名     病人信息.姓名%Type;
    v_性别     病人信息.性别%Type;
    v_年龄     病人信息.年龄%Type;
    v_出生日期 病人信息.出生日期%Type;
    v_门诊号   病人信息.门诊号%Type;
    v_身份证号 病人信息.身份证号%Type;
  Begin
    If p_Msg_Using('ZLHIS_PATIENT_028') = 0 Then
      Return;
    End If;
    Select 姓名, 性别, 年龄, 出生日期, 门诊号, 身份证号
    Into v_姓名, v_性别, v_年龄, v_出生日期, v_门诊号, v_身份证号
    From 病人信息
    Where 病人id = 病人id_In;
  
    b_Message.p_Msg_Todo_Insert('ZLHIS_PATIENT_028',
                                '<root><病人ID>' || 病人id_In || '</病人ID><姓名>' || v_姓名 || '</姓名>' || '<性别>' || v_性别 ||
                                 '</性别>' || '<年龄>' || v_年龄 || '</年龄>' || '<出生日期>' || v_出生日期 || '</出生日期>' || '<门诊号>' ||
                                 v_门诊号 || '</门诊号>' || '<身份证号>' || v_身份证号 || '</身份证号>' || '</root>');
  End Zlhis_Patient_028;

  --血库:科室配血完成
  Procedure Zlhis_Blood_001(医嘱id_In In 病人医嘱记录.Id%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    If 医嘱id_In Is Not Null Then
      v_Value := '<root><医嘱ID>' || 医嘱id_In || '</医嘱ID></root>';
      b_Message.p_Msg_Todo_Insert('ZLHIS_BLOOD_001', v_Value);
    End If;
  End Zlhis_Blood_001;

  --血库:科室拒绝配血
  Procedure Zlhis_Blood_002(医嘱id_In In 病人医嘱记录.Id%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    If 医嘱id_In Is Not Null Then
      v_Value := '<root><医嘱ID>' || 医嘱id_In || '</医嘱ID></root>';
      b_Message.p_Msg_Todo_Insert('ZLHIS_BLOOD_002', v_Value);
    End If;
  End Zlhis_Blood_002;

  --70.检验报告审核
  Procedure Zlhis_Lis_001(标本id_In In 检验标本记录.Id%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    If 标本id_In Is Not Null Then
      v_Value := '<root><标本ID>' || 标本id_In || '</标本ID><系统>1</系统></root>';
      b_Message.p_Msg_Todo_Insert('ZLHIS_LIS_001', v_Value);
    End If;
  End Zlhis_Lis_001;
  --71.检验报告审核撤消
  Procedure Zlhis_Lis_002(标本id_In In 检验标本记录.Id%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    If 标本id_In Is Not Null Then
      v_Value := '<root><标本ID>' || 标本id_In || '</标本ID><系统>1</系统></root>';
      b_Message.p_Msg_Todo_Insert('ZLHIS_LIS_002', v_Value);
    End If;
  End Zlhis_Lis_002;
  --73.检验标本条码打印
  Procedure Zlhis_Lis_004
  (
    样本条码_In In 病人医嘱发送.样本条码%Type,
    医嘱id_In   In 病人医嘱发送.医嘱id%Type,
    医嘱ids_In  In Varchar2
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    If p_Msg_Using('ZLHIS_LIS_004') = 0 Then
      Return;
    End If;
    If 医嘱id_In Is Not Null Then
      v_Value := '<root><样本条码>' || 样本条码_In || '</样本条码><医嘱ID>' || 医嘱id_In || '</医嘱ID><系统>1</系统></root>';
      b_Message.p_Msg_Todo_Insert('ZLHIS_LIS_004', v_Value);
    Else
      For R In (Select '<root><样本条码>' || 样本条码_In || '</样本条码><医嘱ID>' || 医嘱id_In || '</医嘱ID><系统>1</系统></root>' As Xml_Value
                From 病人医嘱发送
                Where 医嘱id In (Select Column_Value From Table(f_Num2list(医嘱ids_In)))) Loop
        b_Message.p_Msg_Todo_Insert('ZLHIS_LIS_004', r.Xml_Value);
      End Loop;
    End If;
  End Zlhis_Lis_004;
  --74.检验标本条码打印撤销
  Procedure Zlhis_Lis_005
  (
    样本条码_In In 病人医嘱发送.样本条码%Type,
    医嘱id_In   In 病人医嘱发送.医嘱id%Type,
    医嘱ids_In  In Varchar2
  ) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    If p_Msg_Using('ZLHIS_LIS_005') = 0 Then
      Return;
    End If;
    If 医嘱id_In Is Not Null Then
      v_Value := '<root><样本条码>' || 样本条码_In || '</样本条码><医嘱ID>' || 医嘱id_In || '</医嘱ID><系统>1</系统></root>';
      b_Message.p_Msg_Todo_Insert('ZLHIS_LIS_005', v_Value);
    Else
      For R In (Select '<root><样本条码>' || 样本条码_In || '</样本条码><医嘱ID>' || 医嘱id_In || '</医嘱ID><系统>1</系统></root>' As Xml_Value
                From 病人医嘱发送
                Where 医嘱id In (Select Column_Value From Table(f_Num2list(医嘱ids_In)))) Loop
        b_Message.p_Msg_Todo_Insert('ZLHIS_LIS_005', r.Xml_Value);
      End Loop;
    End If;
  End Zlhis_Lis_005;
  --75.检验标本核收
  Procedure Zlhis_Lis_006(标本id_In In 检验标本记录.Id%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    If 标本id_In Is Not Null Then
      v_Value := '<root><标本ID>' || 标本id_In || '</标本ID><系统>1</系统></root>';
      b_Message.p_Msg_Todo_Insert('ZLHIS_LIS_006', v_Value);
    End If;
  End Zlhis_Lis_006;
  --76.检验标本核收撤销
  Procedure Zlhis_Lis_007(标本id_In In 检验标本记录.Id%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    If 标本id_In Is Not Null Then
      v_Value := '<root><标本ID>' || 标本id_In || '</标本ID><系统>1</系统></root>';
      b_Message.p_Msg_Todo_Insert('ZLHIS_LIS_007', v_Value);
    End If;
  End Zlhis_Lis_007;
  --77.检验标本拒收
  Procedure Zlhis_Lis_008(标本id_In In 检验标本记录.Id%Type) Is
    v_Value Zlmsg_Todo.Key_Value%Type;
  Begin
    If 标本id_In Is Not Null Then
      v_Value := '<root><标本ID>' || 标本id_In || '</标本ID><系统>1</系统></root>';
      b_Message.p_Msg_Todo_Insert('ZLHIS_LIS_008', v_Value);
    End If;
  End Zlhis_Lis_008;

End b_Message;
/

--118748:李业庆,2017-12-20,退药，销帐消息锚点修改
--120700:李业庆,2018-01-23,消息描点调整
Create Or Replace Procedure Zl_药品收发记录_部门退药
(
  Billid_In     In 药品收发记录.Id%Type,
  People_In     In 药品收发记录.审核人%Type,
  Date_In       In 药品收发记录.审核日期%Type,
  批号_In       In 药品库存.上次批号%Type := Null,
  效期_In       In 药品库存.效期%Type := Null,
  产地_In       In 药品库存.上次产地%Type := Null,
  退药数量_In   In 药品收发记录.实际数量%Type := Null,
  退药库房_In   In 药品收发记录.库房id%Type := Null,
  退药人_In     In 药品收发记录.领用人%Type := Null,
  Intdigit_In   In Number := 2,
  门诊_In       In Number := 2,
  汇总发药号_In In 药品收发记录.汇总发药号%Type := Null
) Is
  --只读变量
  Int记录状态   药品收发记录.记录状态%Type;
  Int执行状态   住院费用记录.执行状态%Type;
  Bln部分退药   Number;
  Lng入出类别id Number(18);
  Strno         药品收发记录.No%Type;
  Int单据       药品收发记录.单据%Type;
  Lng库房id     药品收发记录.库房id%Type;
  Lng药品id     药品收发记录.药品id%Type;
  Dbl实际数量   药品收发记录.实际数量%Type;
  Dbl实际金额   药品收发记录.零售金额%Type;
  Dbl实际成本   药品收发记录.成本金额%Type;
  Dbl实际差价   药品收发记录.差价%Type;
  Lng费用id     药品收发记录.费用id%Type;
  n_零售价      药品收发记录.零售价%Type;
  n_是否变价    Number;
  n_时价分批    Number;

  --20020731 Modified by zyb
  --处理退药时，分批核算性质改变后的处理
  Lng新批次 药品收发记录.批次%Type;
  Lng分批   药品规格.药房分批%Type;
  Lng批次   药品收发记录.批次%Type; --原批次

  Str批号        药品收发记录.批号%Type; --原批号
  Date效期       药品收发记录.效期%Type; --原效期
  n_上次供应商id 药品库存.上次供应商id%Type;
  n_上次采购价   药品库存.上次采购价%Type;
  v_上次产地     药品库存.上次产地%Type;
  v_原产地       药品库存.原产地%Type;
  d_上次生产日期 药品库存.上次生产日期%Type;
  v_批准文号     药品库存.批准文号%Type;

  n_记录性质   住院费用记录.记录性质%Type;
  v_收费类别   住院费用记录.收费类别%Type;
  n_付数       药品收发记录.付数%Type;
  n_原始数量   药品收发记录.实际数量%Type;
  v_冲销记录id 药品收发记录.Id%Type;
  Err_Custom Exception;
  v_Error    Varchar2(255);
  v_配药确认 药房配药控制.配药确认%Type;
  v_配药     药房配药控制.配药%Type;
  v_排队状态 Number(1);
  v_执行时间 药品收发记录.审核日期%Type;

Begin
  If 退药数量_In Is Not Null Then
    If 退药数量_In = 0 Then
      Return;
    End If;
  End If;

  --获取该收发记录的单据、药品ID、库房ID
  Select a.单据, a.No, a.库房id, a.药品id, a.费用id, a.入出类别id, a.记录状态, Nvl(a.批次, 0), a.批号, a.效期, a.供药单位id, a.产地, a.原产地, a.生产日期,
         a.批准文号, a.成本价, a.付数, Nvl(a.实际数量, 0) * Nvl(a.付数, 1) As 实际数量, a.零售价, Nvl(b.是否变价, 0) 是否变价
  Into Int单据, Strno, Lng库房id, Lng药品id, Lng费用id, Lng入出类别id, Int记录状态, Lng批次, Str批号, Date效期, n_上次供应商id, v_上次产地, v_原产地,
       d_上次生产日期, v_批准文号, n_上次采购价, n_付数, n_原始数量, n_零售价, n_是否变价
  From 药品收发记录 A, 收费项目目录 B
  Where a.药品id = b.Id And a.Id = Billid_In;

  Begin
    Select Nvl(配药确认, 0), Nvl(配药, 0)
    Into v_配药确认, v_配药
    From 药房配药控制
    Where 药房id = Lng库房id And Rownum = 1;
  
  Exception
    When Others Then
      v_配药确认 := 0;
      v_配药     := 0;
      Null;
  End;

  If v_配药确认 = 0 And v_配药 = 0 Then
    v_排队状态 := 2;
  Elsif v_配药确认 = 1 Then
    v_排队状态 := 0;
  Elsif v_配药 = 1 Then
    v_排队状态 := 1;
  End If;

  --获取该笔记录剩余未退数量、金额及差价
  --尽量避免金额及差价未出完的现象
  Select Sum(Nvl(实际数量, 0) * Nvl(付数, 1)), Sum(Nvl(零售金额, 0)), Sum(Nvl(成本金额, 0)), Sum(Nvl(差价, 0))
  Into Dbl实际数量, Dbl实际金额, Dbl实际成本, Dbl实际差价
  From 药品收发记录
  Where 审核人 Is Not Null And NO = Strno And 单据 = Int单据 And 序号 = (Select 序号 From 药品收发记录 Where ID = Billid_In);

  --如果允许退药数为零，表示已退药
  If Dbl实际数量 = 0 Then
    v_Error := '该单据已被其他操作员退药，请刷新后再试！';
    Raise Err_Custom;
  End If;
  If Nvl(退药数量_In, 0) > Dbl实际数量 Then
    v_Error := '该单据已被其他操作员部分退药，请刷新后再试！';
    Raise Err_Custom;
  End If;

  --获取该药品当前是否分批的信息
  Select Nvl(药房分批, 0) Into Lng分批 From 药品规格 Where 药品id = Lng药品id;
  --如果是部分退药，则重新计算零售金额及差价
  Bln部分退药 := 0;
  If Not (退药数量_In Is Null Or Nvl(退药数量_In, 0) = Dbl实际数量) Then
    Bln部分退药 := 1;
  End If;
  If Bln部分退药 = 1 Then
    Dbl实际金额 := Round(Dbl实际金额 * 退药数量_In / Dbl实际数量, Intdigit_In);
    Dbl实际成本 := Round(Dbl实际成本 * 退药数量_In / Dbl实际数量, Intdigit_In);
    Dbl实际差价 := Round(Dbl实际差价 * 退药数量_In / Dbl实际数量, Intdigit_In);
    Dbl实际数量 := 退药数量_In;
  End If;

  If n_原始数量 = 退药数量_In Then
    Dbl实际数量 := 退药数量_In / n_付数;
  Else
    n_付数 := 1;
  End If;

  --lng分批:0-不分批;1-分批;2-原分批，现不分批，按不分批处理;3-原不分批，现分批，产生新批次
  If Lng分批 = 0 And Lng批次 <> 0 Then
    --原分批，现不分批，按不分批处理
    Lng分批 := 2;
  Elsif Lng分批 <> 0 And Lng批次 = 0 Then
    --原不分批,现分批,产生新的批次，并在新产生的发药记录中使用
    Lng分批 := 3;
  Else
    If Lng批次 = 0 Then
      Lng分批 := 0;
    Else
      Lng分批 := 1;
    End If;
  End If;
  --判断是否时价分批
  If (Lng分批 = 1 Or Lng分批 = 3) And n_是否变价 = 1 Then
    n_时价分批 := 1;
  Else
    n_时价分批 := 0;
  End If;

  --记录状态的含义有所变化
  --冲销的记录状态        :iif(int记录状态=1,0,1)+1
  --被冲销的记录状态        :iif(int记录状态=1,0,1)+2
  --等待发药的记录状态    :iif(int记录状态=1,0,1)+3

  --产生冲销记录
  Select 药品收发记录_Id.Nextval Into v_冲销记录id From Dual;
  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 成本价, 成本金额, 扣率, 零售价, 零售金额,
     差价, 摘要, 填制人, 填制日期, 配药人, 审核人, 审核日期, 费用id, 单量, 频次, 用法, 发药窗口, 外观, 领用人, 供药单位id, 生产日期, 批准文号, 汇总发药号, 发药方式, 注册证号, 原产地)
    Select v_冲销记录id, Int记录状态 + Decode(Int记录状态, 1, 0, 1) + 1, Int单据, Strno, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地,
           批号, 效期, n_付数, -dbl实际数量, -dbl实际数量, 成本价, -dbl实际成本, 扣率, 零售价, -dbl实际金额, -dbl实际差价, 摘要, People_In, Date_In, 配药人,
           People_In, Date_In, 费用id, 单量, 频次, 用法, 发药窗口, 退药库房_In, 退药人_In, 供药单位id, 生产日期, 批准文号, 汇总发药号_In, 发药方式, 注册证号, 原产地
    From 药品收发记录
    Where ID = Billid_In;

  --如果是部分冲销，则付数填为1，实际数量为付数与实际数量的积
  --产生正常记录以供继续发药
  Select 药品收发记录_Id.Nextval Into Lng新批次 From Dual;
  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 成本价, 成本金额, 扣率, 零售价, 零售金额,
     差价, 摘要, 填制人, 填制日期, 配药人, 审核人, 审核日期, 费用id, 单量, 频次, 用法, 发药窗口, 供药单位id, 生产日期, 批准文号, 注册证号, 原产地)
    Select Lng新批次, Int记录状态 + Decode(Int记录状态, 1, 0, 1) + 3, Int单据, Strno, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id,
           Decode(Lng分批, 1, 批次, 3, Lng新批次, 0), Decode(Lng分批, 3, 产地_In, 1, 产地, 产地), Decode(Lng分批, 3, 批号_In, 1, 批号, Null),
           Decode(Lng分批, 3, 效期_In, 1, 效期, Null), n_付数, Dbl实际数量, Dbl实际数量, 成本价, Dbl实际成本, 扣率, 零售价, Dbl实际金额, Dbl实际差价, 摘要,
           填制人, 填制日期, Null, Null, Null, 费用id, 单量, 频次, 用法, 发药窗口, 供药单位id, 生产日期, 批准文号, 注册证号, 原产地
    From 药品收发记录
    Where ID = Billid_In;

  Zl_未审药品记录_Insert(Lng新批次);

  --更新费用记录的执行状态(0-未执行;1-完全执行;2-部分执行)
  Select Decode(Sum(Nvl(付数, 1) * 实际数量), Null, 0, 0, 0, 2)
  Into Int执行状态
  From 药品收发记录
  Where 单据 = Int单据 And NO = Strno And 费用id = Lng费用id And 审核人 Is Not Null;

  If 门诊_In = 1 Then
    Select 记录性质, 收费类别 Into n_记录性质, v_收费类别 From 门诊费用记录 Where ID = Lng费用id;
  End If;

  If Int执行状态 = 0 Then
    If 门诊_In = 1 Then
      Update 门诊费用记录
      Set 执行状态 = Int执行状态, 执行人 = Null, 执行时间 = Null
      Where NO = Strno And
            序号 = (Select 序号 From 门诊费用记录 Where ID = (Select 费用id From 药品收发记录 Where ID = Billid_In)) And
            Mod(记录性质, 10) = n_记录性质 And 记录状态 <> 2 And 执行部门id = Lng库房id;
    Else
      Update 住院费用记录 Set 执行状态 = Int执行状态, 执行人 = Null, 执行时间 = Null Where ID = Lng费用id;
    End If;
  Else
    If 门诊_In = 1 Then
      Update 门诊费用记录
      Set 执行状态 = Int执行状态
      Where NO = Strno And
            序号 = (Select 序号 From 门诊费用记录 Where ID = (Select 费用id From 药品收发记录 Where ID = Billid_In)) And
            Mod(记录性质, 10) = n_记录性质 And 记录状态 <> 2 And 执行部门id = Lng库房id;
    Else
      Update 住院费用记录 Set 执行状态 = Int执行状态 Where ID = Lng费用id;
    End If;
  End If;

  --插入未发药品记录
  Begin
    If 门诊_In = 1 Then
      Insert Into 未发药品记录
        (单据, NO, 病人id, 主页id, 姓名, 优先级, 对方部门id, 库房id, 发药窗口, 填制日期, 已收费, 配药人, 打印状态, 未发数, 领药号, 排队状态)
        Select a.单据, a.No, a.病人id, Null, a.姓名, Nvl(b.优先级, 0) 优先级, a.对方部门id, a.库房id, a.发药窗口, a.填制日期, a.已收费, Null, 1, 1,
               a.产品合格证, v_排队状态
        From (Select b.单据, b.No, a.病人id, a.姓名, Decode(a.记录状态, 0, 0, 1) 已收费, b.对方部门id, b.库房id, b.发药窗口, b.填制日期, c.身份,
                      b.产品合格证
               From 门诊费用记录 A, 药品收发记录 B, 病人信息 C
               Where b.Id = Billid_In And a.Id = b.费用id + 0 And a.病人id = c.病人id(+)) A, 身份 B
        Where b.名称(+) = a.身份;
    
      --修改处方类型
      Zl_Prescription_Type_Update(Strno, n_记录性质, Lng药品id, v_收费类别);
    Else
      Insert Into 未发药品记录
        (单据, NO, 病人id, 主页id, 姓名, 优先级, 对方部门id, 库房id, 发药窗口, 填制日期, 已收费, 配药人, 打印状态, 未发数, 领药号, 排队状态)
        Select a.单据, a.No, a.病人id, a.主页id, a.姓名, Nvl(b.优先级, 0) 优先级, a.对方部门id, a.库房id, a.发药窗口, a.填制日期, a.已收费, Null, 1, 1,
               a.产品合格证, v_排队状态
        From (Select b.单据, b.No, a.病人id, a.主页id, a.姓名, Decode(a.记录状态, 0, 0, 1) 已收费, b.对方部门id, b.库房id, b.发药窗口, b.填制日期,
                      c.身份, b.产品合格证
               From 住院费用记录 A, 药品收发记录 B, 病人信息 C
               Where b.Id = Billid_In And a.Id = b.费用id + 0 And a.病人id = c.病人id(+)) A, 身份 B
        Where b.名称(+) = a.身份;
    End If;
  Exception
    When Others Then
      Null;
  End;

  --修改原记录为被冲销记录
  Update 药品收发记录 Set 记录状态 = Int记录状态 + Decode(Int记录状态, 1, 0, 1) + 2 Where ID = Billid_In;

  --修改药品库存(反冲库存)
  If Lng分批 <> 3 Then
    --正常单据需要将库存表实际数量和金额、差价还回去，如果库存表没有则在库存表插入数据
    Zl_药品库存_Update(v_冲销记录id, 3, 0);
  Else
    --原不分批，现在分批，直接在库存表产生新单据
    Insert Into 药品库存
      (库房id, 药品id, 批次, 效期, 性质, 实际数量, 实际金额, 实际差价, 零售价, 上次批号, 上次产地, 上次供应商id, 上次采购价, 上次生产日期, 批准文号, 平均成本价)
    Values
      (Lng库房id, Lng药品id, Lng新批次, 效期_In, 1, Dbl实际数量 * n_付数, Dbl实际金额, Dbl实际差价, Decode(n_时价分批, 1, n_零售价, Null), 批号_In,
       产地_In, n_上次供应商id, n_上次采购价, d_上次生产日期, v_批准文号, n_上次采购价);
  End If;

  Delete 药品库存
  Where 库房id + 0 = Lng库房id And 药品id = Lng药品id And 性质 = 1 And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
        Nvl(实际差价, 0) = 0;

  --处理调价修正
  Zl_药品收发记录_调价修正(v_冲销记录id);

  Begin
    --移动支付宝项目在发药后动态调用生成推送信息的过程
    Execute Immediate 'Begin zl_服务窗消息_发送(:1,:2); End;'
      Using 7, Billid_In || ',' || 退药数量_In || ',' || 门诊_In;
  Exception
    When Others Then
      Null;
  End;

  --消息处理，剩余全部退数量传0
  If Bln部分退药 = 1 Then
    b_Message.Zlhis_Drug_006(v_冲销记录id, Lng新批次, Dbl实际数量 * n_付数, Lng费用id);
  Else
    b_Message.Zlhis_Drug_006(v_冲销记录id, Lng新批次, 0, Lng费用id);
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_部门退药;
/

--120353:李业庆,2018-01-17,部分销帐删除未发药记录处理
--118156:李业庆,2017-12-29,药品库存或收发记录批次为空处理
--118748:李业庆,2017-12-20,退药，销帐消息锚点修改
Create Or Replace Procedure Zl_药品收发记录_销售退费
(
  费用id_In   In 门诊费用记录.Id%Type,
  销帐数量_In In 药品收发记录.实际数量%Type := 0,
  配药id_In   Varchar2 := Null,
  消息_In     Number := 0 --是否发送销帐消息
) Is
  ----------------------------------
  --功能：删除门诊收费单、门诊划价单、门诊收费销帐时用来处理药品库存、药品收发记录、未发药记录的过程
  --参数：
  --      费用id_In：门诊费用记录或者住院费用记录做删除或者销帐时被删除单据的id
  --      销帐数量_In：销帐审核时需要销帐的数量
  --      配药id_In：销帐审核时输液配置中心需要传递的记录id，以字符串传递，用逗号分割，如：1001,1002,1003
  --      为空表示冲销所有可冲销行
  -----------------------------------
  --该游标用于处理药品库存可用数量
  l_药品收发   t_Numlist := t_Numlist();
  n_单据       药品收发记录.单据%Type;
  v_No         药品收发记录.No%Type;
  n_原始数量   Number;
  n_销帐数量   Number;
  v_收费类别   收费项目目录.类别%Type;
  n_虚拟库房id 药品收发记录.库房id%Type;
  n_其他出库id 药品收发记录.Id%Type;
  n_库房id     药品收发记录.库房id%Type;
  n_备货卫材   Number;
  v_收发ids    Varchar2(4000); --用户消息锚点发送，格式:收发id,数量|收发id,数量...

  Err_Item Exception;
  v_Err_Msg Varchar2(255);

  --找出需要处理的药品单据
  Cursor c_药品收发记录 Is
    Select ID, 费用id, NO, 单据, 药品id, 库房id, Nvl(批次, 0) 批次, 批号, 产地,
           Decode(发药方式, Null, 1, -1, 0, 1) * Nvl(付数, 1) * Nvl(实际数量, 0) As 数量, 实际数量, 付数, 发药方式, 灭菌效期, 效期, 商品条码, 内部条码
    From 药品收发记录
    Where 单据 In (8, 9, 10, 21, 24, 25, 26) And Mod(记录状态, 3) = 1 And 审核人 Is Null And 费用id = 费用id_In;

  Cursor c_销帐审核 Is
    Select /*+ rule*/
     a.Id, a.费用id, a.No, a.单据, a.药品id, a.库房id, Nvl(a.批次, 0) 批次, a.批号, a.产地,
     Decode(a.发药方式, Null, 1, -1, 0, 1) * Nvl(a.付数, 1) * Nvl(a.实际数量, 0) As 数量, a.实际数量, a.付数, a.发药方式, a.灭菌效期, a.效期, a.商品条码,
     a.内部条码
    From 药品收发记录 A, Table(f_Str2list(配药id_In)) B, 输液配药内容 C
    Where a.单据 In (9, 10, 25, 26) And Mod(a.记录状态, 3) = 1 And a.审核人 Is Null And a.费用id = 费用id_In And a.Id = c.收发id And
          c.记录id = b.Column_Value
    Order By 填制日期;

  r_Row c_药品收发记录%RowType;
Begin
  n_单据 := 0;
  v_No   := '';

  If 销帐数量_In = 0 Then
  
    --数量为空表示是全部删除
    --打开游标
    Open c_药品收发记录;
  
    --遍历游标
    Loop
      Fetch c_药品收发记录
        Into r_Row;
      Exit When c_药品收发记录%NotFound;
    
      Select 类别 Into v_收费类别 From 收费项目目录 Where ID = r_Row.药品id;
    
      --处理药品库存
      If r_Row.库房id Is Not Null Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) + r_Row.数量
        Where 库房id = r_Row.库房id And 药品id = r_Row.药品id And Nvl(批次, 0) = Nvl(r_Row.批次, 0) And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码)
          Values
            (r_Row.库房id, r_Row.药品id, 1, Nvl(r_Row.批次, 0), r_Row.效期, r_Row.数量, r_Row.批号, r_Row.产地, r_Row.灭菌效期,
             r_Row.商品条码, r_Row.内部条码);
        End If;
      
        --删除多余的库存数据
        Delete From 药品库存
        Where 库房id = r_Row.库房id And 药品id = r_Row.药品id And Nvl(批次, 0) = Nvl(r_Row.批次, 0) And 性质 = 1 And Nvl(可用数量, 0) = 0 And
              Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0;
      
        Zl_药品库存_可用数量异常处理(r_Row.库房id, r_Row.药品id, r_Row.批次);
      End If;
    
      n_单据 := r_Row.单据;
      v_No   := r_Row.No;
      l_药品收发.Extend;
      l_药品收发(l_药品收发.Count) := r_Row.Id;
    
      v_收发ids := v_收发ids || '|' || r_Row.Id || ',' || 0;
    End Loop;
  
    --关闭游标
    Close c_药品收发记录;
  Else
    --数量不为空表示是销帐审核操作
    If 配药id_In Is Not Null Then
      Open c_销帐审核;
    Else
      Open c_药品收发记录;
    End If;
    n_销帐数量 := 销帐数量_In;
  
    --只有住院记账处理才会走这一步
    Loop
      If 配药id_In Is Not Null Then
        Fetch c_销帐审核
          Into r_Row;
        Exit When c_销帐审核%NotFound;
      Else
        Fetch c_药品收发记录
          Into r_Row;
        Exit When c_药品收发记录%NotFound;
      End If;
    
      n_虚拟库房id := Null;
      n_其他出库id := Null;
      Select 类别 Into v_收费类别 From 收费项目目录 Where ID = r_Row.药品id;
      If v_收费类别 = '4' Then
        Begin
          Select 1, 库房id, ID
          Into n_备货卫材, n_虚拟库房id, n_其他出库id
          From 药品收发记录
          Where 费用id = 费用id_In And 审核日期 Is Null And 单据 = 21 And Rownum = 1;
        Exception
          When Others Then
            n_备货卫材 := 0;
        End;
      Else
        n_备货卫材 := 0;
      End If;
    
      n_原始数量 := r_Row.数量;
    
      If n_销帐数量 >= n_原始数量 Then
        l_药品收发.Extend;
        l_药品收发(l_药品收发.Count) := r_Row.Id;
        v_收发ids := v_收发ids || '|' || r_Row.Id || ',' || 0;
        If Nvl(n_其他出库id, 0) > 0 Then
          l_药品收发.Extend;
          l_药品收发(l_药品收发.Count) := n_其他出库id;
          v_收发ids := v_收发ids || '|' || n_其他出库id || ',' || 0;
        End If;
        n_销帐数量 := n_销帐数量 - n_原始数量;
      Else
        If v_收费类别 = '7' Then
          --当前行的数量要大
          Update 药品收发记录
          Set 付数 = 1, 实际数量 = Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - n_销帐数量,
              填写数量 = Decode(付数, Null, 1, 0, 1, 付数) * Nvl(填写数量, 0) - n_销帐数量,
              成本金额 =
               (Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - n_销帐数量) * 成本价,
              零售金额 =
               (Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - n_销帐数量) * 零售价,
              差价 = Round((Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - n_销帐数量) * 零售价 -
                          (Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - n_销帐数量) * 成本价, 5)
          Where ID = r_Row.Id;
        Else
          Update 药品收发记录
          Set 实际数量 = Nvl(实际数量, 0) - n_销帐数量, 填写数量 = Nvl(填写数量, 0) - n_销帐数量,
              成本金额 =
               (Nvl(实际数量, 0) - n_销帐数量) * 成本价,
              零售金额 =
               (Nvl(实际数量, 0) - n_销帐数量) * 零售价,
              差价 = Round((Nvl(实际数量, 0) - n_销帐数量) * 零售价 - (Nvl(实际数量, 0) - n_销帐数量) * 成本价, 5)
          Where ID = r_Row.Id;
        End If;
      
        v_收发ids := v_收发ids || '|' || r_Row.Id || ',' || n_销帐数量;
      
        --更新其他出库单
        If Nvl(n_其他出库id, 0) <> 0 Then
          If v_收费类别 = '7' Then
            Update 药品收发记录
            Set 付数 = 1, 实际数量 = Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - n_销帐数量,
                填写数量 = Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - n_销帐数量,
                成本金额 =
                 (Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - n_销帐数量) * 成本价,
                零售金额 =
                 (Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - n_销帐数量) * 零售价,
                差价 = Round((Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - n_销帐数量) * 零售价 -
                            (Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - n_销帐数量) * 成本价, 5)
            Where ID = Nvl(n_其他出库id, 0);
          Else
            Update 药品收发记录
            Set 实际数量 = Nvl(实际数量, 0) - n_销帐数量, 填写数量 = Nvl(实际数量, 0) - n_销帐数量,
                成本金额 =
                 (Nvl(实际数量, 0) - n_销帐数量) * 成本价,
                零售金额 =
                 (Nvl(实际数量, 0) - n_销帐数量) * 零售价,
                差价 = Round((Nvl(实际数量, 0) - n_销帐数量) * 零售价 - (Nvl(实际数量, 0) - n_销帐数量) * 成本价, 5)
            Where ID = Nvl(n_其他出库id, 0);
          End If;
        
          v_收发ids := v_收发ids || '|' || n_其他出库id || ',' || n_销帐数量;
        End If;
        n_原始数量 := n_销帐数量;
        n_销帐数量 := 0;
      End If;
      If Nvl(n_备货卫材, 0) = 1 Then
        n_库房id := n_虚拟库房id;
      Else
        n_库房id := r_Row.库房id;
      End If;
    
      If n_库房id Is Not Null Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) + n_原始数量
        Where 库房id = n_库房id And 药品id = r_Row.药品id And Nvl(批次, 0) = Nvl(r_Row.批次, 0) And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期)
          Values
            (n_库房id, r_Row.药品id, 1, Nvl(r_Row.批次, 0), r_Row.效期, n_原始数量, r_Row.批号, r_Row.产地, r_Row.灭菌效期);
        End If;
        Delete 药品库存
        Where 库房id = n_库房id And 药品id = r_Row.药品id And Nvl(批次, 0) = Nvl(r_Row.批次, 0) And 性质 = 1 And Nvl(可用数量, 0) = 0 And
              Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0;
      
        Zl_药品库存_可用数量异常处理(r_Row.库房id, r_Row.药品id, r_Row.批次);
      End If;
    
      If Nvl(n_备货卫材, 0) = 1 Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) + n_原始数量
        Where 库房id = r_Row.库房id And 药品id = r_Row.药品id And Nvl(批次, 0) = Nvl(r_Row.批次, 0) And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期)
          Values
            (r_Row.库房id, r_Row.药品id, 1, Nvl(r_Row.批次, 0), r_Row.效期, n_原始数量, r_Row.批号, r_Row.产地, r_Row.灭菌效期);
        End If;
      
        Delete 药品库存
        Where 库房id = r_Row.库房id And 药品id = r_Row.药品id And Nvl(批次, 0) = Nvl(r_Row.批次, 0) And 性质 = 1 And Nvl(可用数量, 0) = 0 And
              Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0;
      
        Zl_药品库存_可用数量异常处理(r_Row.库房id, r_Row.药品id, r_Row.批次);
      End If;
    
      If n_销帐数量 = 0 Then
        Exit;
      End If;
    End Loop;
  
    --不跟踪卫材的,不检查:因为不跟噻的话,不会在药品收发记录中存在
    If Nvl(n_销帐数量, 0) <> 0 And Not (v_收费类别 = '4' And n_原始数量 = 0) Then
      --未分配完成,表示此药品可能已经执行.
      v_Err_Msg := '要销帐的费用中存在已发的药品或卫材，或已被其他人销帐；这可能是并发操作引起的。';
      Raise Err_Item;
    End If;
  End If;

  --删除药品收发记录
  Forall I In 1 .. l_药品收发.Count
    Delete From 药品收发记录 Where ID = l_药品收发(I) And 审核人 Is Null;

  --删除未发药品记录
  Delete From 未发药品记录 A
  Where NO = v_No And 单据 = n_单据 And Not Exists
   (Select 1
         From 药品收发记录
         Where 单据 = a.单据 And Nvl(库房id, 0) = Nvl(a.库房id, 0) And NO = v_No And Mod(记录状态, 3) = 1 And 审核人 Is Null);

  --发送销帐消息
  If 消息_In = 1 Then
    b_Message.Zlhis_Charge_008(v_收费类别, 费用id_In, v_收发ids);
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_销售退费;
/

--105001:胡俊勇,2018-01-22,医嘱中药医嘱内容多行打印
--118806:胡俊勇,2018-01-29,转科医嘱打印位置
--116297:胡俊勇,2017-12-20,临嘱单术后医嘱换页
Create Or Replace Procedure Zl_病人医嘱打印_Insert
(
  病人id_In In 病人医嘱记录.病人id%Type,
  主页id_In In 病人医嘱记录.主页id%Type,
  婴儿_In   In 病人医嘱记录.婴儿%Type,
  期效_In   In 病人医嘱记录.医嘱期效%Type,
  行数_In   In 病人医嘱打印.行号%Type
  --功能：将病人没有打印过的医嘱插入 病人医嘱打印
  --参数：行数_In：报表医嘱单一页可以打多少行
  --      行数_In医嘱单报表的行数，通常是28行。
) Is
  n_序号     病人医嘱记录.序号%Type;
  n_医嘱id   病人医嘱记录.Id%Type;
  n_重整标记 Number;
  v_Max_Date Date;
  d_重整     Date;
  d_Pdate    Date;

  n_转科     Number;
  n_页号     Number;
  n_行号     Number;
  b_重整换页 Boolean;
  n_Cnt      Number;
  v_Tmp      Varchar2(200);

  --参数 
  n_显示位置   Number;
  n_打印模式   Number;
  n_打给药方式 Number;
  n_重整换页   Number;

  n_长转科换页   Number; --长期医嘱单
  n_长转科打重开 Number;
  n_长术后换页   Number;

  n_临转科换页 Number; --临嘱单，临嘱单转科换页参数
  n_临术后换页 Number;

  n_内容长度 Number; --长嘱11，临嘱29
  v_打印内容 病人医嘱记录.医嘱内容%Type;

  --c_Advice 取出待打印的医嘱，在打印临嘱时转科医嘱都会读取出来，后面要判断是不是要生成打印记录
  Cursor c_Advice Is
    Select 医嘱id, 顺序, 打印标记, 换页, 诊疗类别, 操作类型, 医嘱内容
    From (With Printtable As (Select a.Id As 医嘱id, a.序号 As 顺序, 0 As 打印标记, Null As 特殊医嘱,
                                     Decode(a.诊疗类别, 'Z', Decode(b.操作类型, '3', 3, '4', 4, 0), 0) As 换页, a.诊疗项目id, a.相关id,
                                     b.操作类型, a.诊疗类别
                              From 病人医嘱记录 A, 诊疗项目目录 B
                              Where a.病人id = 病人id_In And a.主页id = 主页id_In And Nvl(a.婴儿, 0) = 婴儿_In And a.诊疗项目id = b.Id(+) And
                                    (期效_In = 0 And a.医嘱期效 = 0 Or
                                    a.医嘱期效 = 1 And a.诊疗类别 = 'Z' And b.操作类型 In ('3', '5', '11') Or
                                    期效_In = 1 And a.医嘱期效 = 1 Or
                                    期效_In = 1 And n_临术后换页 = 1 And Nvl(a.诊疗类别, 'X') = 'Z' And Nvl(b.操作类型, 'X') = '4') And
                                    a.医嘱状态 Not In (-1, 2) And (n_打印模式 = 1 And a.医嘱状态 = 1 Or a.医嘱状态 <> 1) And
                                    Nvl(a.屏蔽打印, 0) = 0 And a.序号 > n_序号 And Exists
                               (Select 1 From 病人医嘱状态 C Where a.Id = c.医嘱id And c.操作时间 >= v_Max_Date) And a.病人来源 = 2)
           Select p.医嘱id, p.顺序, p.打印标记, p.换页, p.诊疗类别, p.操作类型, l.医嘱内容
           From 病人医嘱记录 L, 诊疗项目目录 I, Printtable P
           Where l.Id = p.医嘱id And l.诊疗项目id = i.Id And
                 (l.诊疗类别 Not In ('5', '6', '7', 'E') Or l.诊疗类别 = 'E' And Nvl(i.操作类型, '0') Not In ('2', '3') Or
                 i.Id Is Null) And l.相关id Is Null
           Union All
           Select p.医嘱id, p.顺序, p.打印标记, p.换页, p.诊疗类别, p.操作类型, Null As 医嘱内容
           From 病人医嘱记录 L, Printtable P
           Where l.Id = p.医嘱id And l.诊疗类别 In ('5', '6')
           Union All
           Select p.医嘱id, p.顺序, p.打印标记, p.换页, p.诊疗类别, p.操作类型, Null As 医嘱内容
           From Printtable P
           Where p.诊疗类别 = 'E' And p.操作类型 = '2' And p.相关id Is Null And
                 (n_打给药方式 = 1 Or n_打给药方式 = 2 And Exists
                  (Select 1 From 病人医嘱记录 L Where l.相关id = p.医嘱id Having Count(1) > 1))
           Union All
           Select p.医嘱id, p.顺序, p.打印标记, p.换页, p.诊疗类别, p.操作类型, Null As 医嘱内容
           From Printtable P
           Where p.诊疗项目id Is Null
           Order By 顺序);


  --获取下一个或用的行号和页号
  Procedure Getnextpos
  (
    v_页号     In 病人医嘱打印.页号%Type,
    v_行号     In 病人医嘱打印.行号%Type,
    v_行数     In 病人医嘱打印.行号%Type,
    v_页号_Out Out 病人医嘱打印.页号%Type,
    v_行号_Out Out 病人医嘱打印.页号%Type
  ) Is
  Begin
    If v_行号 = 0 Then
      v_页号_Out := 1;
      v_行号_Out := 1;
    Elsif v_行号 = v_行数 Then
      v_页号_Out := v_页号 + 1;
      v_行号_Out := 1;
    Else
      v_页号_Out := v_页号;
      v_行号_Out := v_行号 + 1;
    End If;
  End Getnextpos;

Begin
  n_显示位置     := Zl_To_Number(Nvl(zl_GetSysParameter('转科和出院打印', 1254), 0));
  n_打印模式     := Zl_To_Number(Nvl(zl_GetSysParameter('医嘱单打印模式', 1253), 0));
  n_打给药方式   := Zl_To_Number(Nvl(zl_GetSysParameter('药品用法单独打印一行', 1254), 0));
  n_临转科换页   := Zl_To_Number(Nvl(zl_GetSysParameter('临嘱单转科换页', 1254), 0));
  n_重整换页     := Zl_To_Number(Nvl(zl_GetSysParameter('长嘱单重整换页', 1254), 0));
  n_长转科换页   := Zl_To_Number(Nvl(zl_GetSysParameter('长嘱单转科换页', 1254), 0));
  n_长术后换页   := Zl_To_Number(Nvl(zl_GetSysParameter('长嘱单术后换页', 1254), 0));
  n_长转科打重开 := Zl_To_Number(Nvl(zl_GetSysParameter('转科换页后在首行打印重开医嘱', 1254), 0));
  n_临术后换页   := Zl_To_Number(Nvl(zl_GetSysParameter('临嘱单术后换页', 1254), 0));

  --中药医嘱按内容拆分时一行显示的字符长度
  If 期效_In = 1 Then
    n_内容长度 := Zl_To_Number(Nvl(zl_GetSysParameter('长嘱单中药医嘱单行显示字数', 1254), 0));
  Else
    n_内容长度 := Zl_To_Number(Nvl(zl_GetSysParameter('临嘱单中药医嘱单行显示字数', 1254), 0));
  End If;

  --取出重整 时间
  If 期效_In = 1 Then
    d_重整 := To_Date('1900-01-01', 'YYYY-MM-DD');
  Else
    Select 医嘱重整时间 Into d_重整 From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
    If d_重整 Is Null Then
      d_重整 := To_Date('1900-01-01', 'YYYY-MM-DD');
    End If;
  End If;
  v_Max_Date := d_重整;

  Begin
    Select 医嘱id, 打印时间, 页号, 行号
    Into n_医嘱id, d_Pdate, n_页号, n_行号
    From (Select 医嘱id, 打印时间, 页号, 行号
           From 病人医嘱打印
           Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And 医嘱id Is Not Null
           Order By 页号 Desc, 行号 Desc)
    Where Rownum < 2;
  
    Select Nvl(Max(序号), 0)
    Into n_序号
    From 病人医嘱记录
    Where ID = (Select Nvl(a.相关id, a.Id) From 病人医嘱记录 A Where a.Id = n_医嘱id);
  
    If 期效_In = 0 Then
      If d_Pdate Is Not Null Then
        If d_Pdate < d_重整 And d_重整 <> To_Date('1900-01-01', 'YYYY-MM-DD') Then
          n_重整标记 := 1;
          n_序号     := 0;
        End If;
      End If;
    End If;
  Exception
    When Others Then
      n_页号 := 0;
      n_行号 := 0;
      n_序号 := 0;
  End;

  If n_医嘱id Is Not Null Then
    Select Max(b.操作类型)
    Into v_Tmp
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id And a.Id = n_医嘱id And a.诊疗类别 = 'Z';
  End If;
  If v_Tmp = '3' Then
    n_转科 := 1;
  End If;

  Getnextpos(n_页号, n_行号, 行数_In, n_页号, n_行号);

  If n_转科 = 1 And n_临转科换页 = 1 And 期效_In = 1 Then
    --临时医嘱转科换页
    If n_行号 <> 1 Then
      n_行号 := 1;
      n_页号 := n_页号 + 1;
    End If;
  Elsif 期效_In = 0 Then
    b_重整换页 := False;
    --重整，术后，转科重开，这些只针对于长期医嘱单
    --重整标记
    If n_重整标记 = 1 Then
      If n_重整换页 = 1 Then
        --重整换页
        If n_行号 <> 1 Then
          n_行号 := 1;
          n_页号 := n_页号 + 1;
        End If;
      End If;
      --重整标记
      Insert Into 病人医嘱打印
        (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
      Values
        (-1 * Null, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, 0, Null);
      Getnextpos(n_页号, n_行号, 行数_In, n_页号, n_行号);
      b_重整换页 := True;
    End If;
  
    If n_转科 = 1 Then
      --转科
      If n_长转科换页 = 1 Then
        --如果重整已经换了页就不用换了。
        If Not b_重整换页 Then
          If n_行号 <> 1 Then
            n_行号 := 1;
            n_页号 := n_页号 + 1;
          End If;
        End If;
        If n_长转科打重开 = 1 Then
          Insert Into 病人医嘱打印
            (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
          Values
            (-1 * Null, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, 0, 1);
          Getnextpos(n_页号, n_行号, 行数_In, n_页号, n_行号);
        End If;
      End If;
    End If;
  End If;
  n_转科 := 0;

  --换页行号计算规则：如果行号为1说明已经是新的一页的第一行,否则换页
  For r_Print In c_Advice Loop
    If n_转科 = 1 Then
      --长期医嘱单转科换页
      If 期效_In = 0 And n_长转科换页 = 1 Then
        If n_长转科打重开 = 1 Then
          --长期医嘱单打重开字样
          If n_行号 <> 1 Then
            n_行号 := 1;
            n_页号 := n_页号 + 1;
          End If;
          Insert Into 病人医嘱打印
            (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
          Values
            (-1 * Null, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, 0, 1);
          Getnextpos(n_页号, n_行号, 行数_In, n_页号, n_行号);
        Else
          --只是单纯换一页
          If n_行号 <> 1 Then
            n_行号 := 1;
            n_页号 := n_页号 + 1;
          End If;
        End If;
      Elsif 期效_In = 1 And n_临转科换页 = 1 Then
        --临时医嘱单转科换页
        If n_行号 <> 1 Then
          n_行号 := 1;
          n_页号 := n_页号 + 1;
        End If;
      End If;
    End If;
    n_转科 := 0;
  
    --术后医嘱换页，术后医嘱是换页后打在首行上
    If r_Print.换页 = 4 And (n_长术后换页 = 1 And 期效_In = 0 Or n_临术后换页 = 1 And 期效_In = 1) Then
      If n_行号 <> 1 Then
        n_行号 := 1;
        n_页号 := n_页号 + 1;
      End If;
    End If;
  
    If r_Print.诊疗类别 = 'Z' And Instr(',3,5,11,', ',' || r_Print.操作类型 || ',') > 0 Then
      --转科，出院，死亡显示位置处理
      If 期效_In = 0 And Instr(',0,2,', n_显示位置) > 0 Or 期效_In = 1 And Instr(',1,2,', n_显示位置) > 0 Then
        Insert Into 病人医嘱打印
          (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记)
        Values
          (r_Print.医嘱id, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, r_Print.打印标记);
        Getnextpos(n_页号, n_行号, 行数_In, n_页号, n_行号);
      End If;
    Elsif r_Print.诊疗类别 = 'E' And r_Print.操作类型 = '4' And n_内容长度 > 0 Then
      --中药医嘱拆分
      v_打印内容 := r_Print.医嘱内容;
      n_Cnt      := 0;
      --将中药医嘱内容截断成多行
      While v_打印内容 Is Not Null Loop
        n_Cnt := n_Cnt + 1;
        Insert Into 病人医嘱打印
          (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 医嘱内容, 特殊医嘱)
        Values
          (r_Print.医嘱id, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, r_Print.打印标记, Substr(v_打印内容, 1, n_内容长度), n_Cnt);
        Getnextpos(n_页号, n_行号, 行数_In, n_页号, n_行号);
        v_打印内容 := Substr(v_打印内容, n_内容长度 + 1);
      End Loop;
    Else
      Insert Into 病人医嘱打印
        (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记)
      Values
        (r_Print.医嘱id, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, r_Print.打印标记);
      Getnextpos(n_页号, n_行号, 行数_In, n_页号, n_行号);
    End If;
  
    --启用了转科换页打重开字样，则插入一重开医嘱标记，此处一定换页，因为转科换页前要先打出转科医嘱，
    --这里不插入数据，只进行标记，再下一次循时才插入。如果转科医嘱是最后一条是不用打印新开字样的。
    If r_Print.换页 = 3 Then
      n_转科 := 1;
    End If;
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱打印_Insert;
/

--105001:胡俊勇,2018-01-25,医嘱中药医嘱内容多行打印
--116297:胡俊勇,2017-12-20,临嘱单术后医嘱换页
Create Or Replace Procedure Zl_病人医嘱打印_Delete
(
  病人id_In   In 病人医嘱记录.病人id%Type,
  主页id_In   In 病人医嘱记录.主页id%Type,
  婴儿_In     In 病人医嘱记录.婴儿%Type,
  期效_In     In 病人医嘱记录.医嘱期效%Type,
  起始页号_In In 病人医嘱打印.页号%Type := Null,
  医嘱位置_In In Varchar2 := Null,
  清除方式_In In Number := Null
  --清除方式_In： 1-清除上次打印保留数据，2-清除上次打印删除打印数据，3－清除预打印数据，其它－按指定规则清除打印 
) Is
  v_位置    Varchar2(10);
  n_Cnt     Number(8);
  n_End     Number(8);
  n_Begin   Number(8);
  n_重整    Number;
  d_重整    Date;
  n_医嘱id  病人医嘱记录.Id%Type;
  v_医嘱ids Varchar2(4000);
  v_Tmp     Varchar2(20);
Begin

  If 期效_In = 1 Then
    d_重整 := To_Date('1900-01-01', 'YYYY-MM-DD');
  Else
    Select 医嘱重整时间 Into d_重整 From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
    If d_重整 Is Null Then
      d_重整 := To_Date('1900-01-01', 'YYYY-MM-DD');
    End If;
  End If;

  If 清除方式_In = 3 Then
    --对于那种占用了两页的打印记录部分打印部分没有打印，但是是一组医嘱的，不应该清除
    For R In (Select 医嘱id
              From 病人医嘱打印
              Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And 打印时间 Is Null And
                    医嘱id Is Not Null
              Order By 页号, 行号) Loop
    
      Select Nvl(b.相关id, b.Id) As 医嘱id, c.类别 || c.操作类型 As 中药
      Into n_医嘱id, v_Tmp
      From 病人医嘱记录 B, 诊疗项目目录 C
      Where b.Id = r.医嘱id And b.诊疗项目id = c.Id(+);
    
      n_Cnt := 0;
      For X In (Select b.医嘱id, b.打印时间
                From 病人医嘱记录 A, 病人医嘱打印 B
                Where a.Id = b.医嘱id And (a.Id = n_医嘱id Or a.相关id = n_医嘱id) And b.打印时间 > d_重整) Loop
        v_医嘱ids := v_医嘱ids || ',' || x.医嘱id;
        n_Cnt     := n_Cnt + 1;
        If x.打印时间 Is Null Then
          n_End := 1;
        Else
          n_Begin := 1;
        End If;
      End Loop;
      If Not (n_Cnt > 1 And n_End = 1 And n_Begin = 1) Then
        v_医嘱ids := Null;
      End If;
    
      --中药医嘱拆分占了两页的情况。
      If v_Tmp = 'E4' Then
        n_End   := 0;
        n_Begin := 0;
        For S In (Select a.页号, a.行号, a.打印时间 From 病人医嘱打印 A Where 医嘱id = r.医嘱id Order By a.页号, a.行号) Loop
          If s.打印时间 Is Not Null Then
            n_Begin := 1;
          Else
            n_End := 1;
          End If;
          If n_End = 1 And n_Begin = 1 Then
            v_医嘱ids := v_医嘱ids || ',' || r.医嘱id;
            Exit;
          End If;
        End Loop;
      End If;
    
      Exit;
    End Loop;
  
    Delete From 病人医嘱打印
    Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And 打印时间 Is Null And
          Instr(v_医嘱ids || ',', ',' || 医嘱id || ',') = 0;
  Else
    --医嘱变化时的自动清除和清除指定位置医嘱，删数据方式   
    If 清除方式_In Is Null Then
      If 医嘱位置_In Is Not Null Then
        v_位置 := 医嘱位置_In;
      End If;
      If v_位置 Is Null Then
        --通过页号来找一个合适的位置 
        v_位置 := LPad(起始页号_In, 4, '0') || '001';
      End If;
    Else
      Select Nvl(Min(LPad(页号, 4, '0') || LPad(行号, 3, '0')), '0001001')
      Into v_位置
      From 病人医嘱打印
      Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And
            打印时间 = (Select Max(打印时间)
                    From 病人医嘱打印
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In);
    End If;
    n_重整 := 0;
    n_Cnt  := To_Number(v_位置);
    Select Max(医嘱id)
    Into n_医嘱id
    From 病人医嘱打印
    Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And
          To_Number(LPad(页号, 4, '0') || LPad(行号, 3, '0')) = n_Cnt;
  
    --判断重整的情况 
    If d_重整 <> To_Date('1900-01-01', 'YYYY-MM-DD') And 期效_In = 0 Then
      --找到数据说明这条医嘱是已经被重整，所以本次清除只能最后一次重整处 
      Select Max(n.位置)
      Into n_Cnt
      From (Select To_Number(LPad(页号, 4, '0') || LPad(行号, 3, '0')) As 位置
             From 病人医嘱打印
             Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And 打印时间 < d_重整 And
                   医嘱id = n_医嘱id) N;
      If n_Cnt Is Null Then
        n_Cnt := To_Number(v_位置);
      Else
        n_Cnt  := n_Cnt + 1;
        n_重整 := 1;
      End If;
    End If;
  
    If n_重整 <> 1 Then
      --判断这条医嘱是不是占用了两页，只有药品医嘱/中药医嘱可能会用两页的情况，
      For X In (Select Nvl(a.相关id, a.Id) As 组id, a.相关id, a.Id, a.诊疗类别, b.操作类型
                From 病人医嘱记录 A, 诊疗项目目录 B
                Where a.诊疗项目id = b.Id And a.Id = n_医嘱id) Loop
        If x.诊疗类别 = '5' Or x.诊疗类别 = '6' Or (x.诊疗类别 = 'E' And x.操作类型 In ('2', '4')) Then
          Select Max(n.位置), Min(n.位置)
          Into n_End, n_Begin
          From (Select To_Number(LPad(b.页号, 4, '0') || LPad(b.行号, 3, '0')) As 位置
                 From 病人医嘱记录 A, 病人医嘱打印 B
                 Where (ID = x.组id Or 相关id = x.组id) And a.Id = b.医嘱id) N;
          If n_End >= n_Cnt And n_Begin < n_Cnt Then
            Update 病人医嘱打印
            Set 打印标记 = Null, 打印人 = Null, 打印时间 = Null
            Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And
                  To_Number(LPad(页号, 4, '0') || LPad(行号, 3, '0')) Between n_Cnt And n_End;
            n_Cnt := n_End + 1;
          End If;
        End If;
      End Loop;
    End If;
    If n_Cnt Is Not Null Then
      Delete From 病人医嘱打印
      Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And
            To_Number(LPad(页号, 4, '0') || LPad(行号, 3, '0')) >= n_Cnt;
    End If;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱打印_Delete;
/

--118738:刘涛,2017-12-20,修改发票信息库存上次供应商处理
Create Or Replace Procedure Zl_材料外购发票信息_Update
(
  No_In         In 药品收发记录.No%Type := Null,
  记录状态_In   In 药品收发记录.记录状态%Type := Null,
  序号_In       In 药品收发记录.序号%Type := Null,
  发票号_In     In 应付记录.发票号%Type := Null,
  发票日期_In   In 应付记录.发票日期%Type := Null,
  发票金额_In   In 应付记录.发票金额%Type := Null,
  供货单位id_In In 应付记录.单位id%Type := 0,
  发票代码_In   In 应付记录.发票代码%Type := Null
) Is
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_No         应付记录.No%Type;
  n_应付id     应付记录.Id%Type;
  n_收发id     应付记录.收发id%Type;
  n_付款序号   应付记录.付款序号%Type;
  n_发票金额   应付记录.发票金额%Type; --旧发票金额
  n_供货单位id 应付记录.单位id%Type;
  n_Dec        Number;
  n_剩余数量   应付记录.发票金额%Type;
Begin
  --金额小数位数
  Select Nvl(精度, 2) Into n_Dec From 药品卫材精度 Where 性质 = 0 And 类别 = 2 And 内容 = 4 And 单位 = 5;

  --取是否付款及总额
  Begin
    Select Max(付款序号), Sum(Nvl(发票金额, 0))
    Into n_付款序号, n_发票金额
    From 应付记录
    Where 收发id In (Select ID From 药品收发记录 Where NO = No_In And 序号 = 序号_In And 单据 = 15) And 系统标识 = 5 And 记录性质 = -1;
  Exception
    When Others Then
      n_发票金额 := 0;
  End;

  n_付款序号 := Nvl(n_付款序号, 0);

  If n_付款序号 <> 0 Then
    v_Err_Msg := '[ZLSOFT]该单据已经被付了款，不能再修改发票信息[ZLSOFT]';
    Raise Err_Item;
  End If;

  If 发票金额_In > n_发票金额 And n_发票金额 <> 0 Then
    v_Err_Msg := '[ZLSOFT]发票金额不能小于计划付款金额[ZLSOFT]';
    Raise Err_Item;
  End If;
  n_发票金额 := Nvl(n_发票金额, 0);

  --判断是否冲销后的记录
  If 记录状态_In <> 1 Then
    Begin
      Select Sum(Nvl(发票金额, 0))
      Into n_发票金额
      From 应付记录
      Where 收发id In (Select ID From 药品收发记录 Where NO = No_In And 序号 = 序号_In And 单据 = 15) And 系统标识 = 5 And 记录性质 = 0;
    Exception
      When Others Then
        n_发票金额 := 0;
    End;
    n_发票金额 := Nvl(n_发票金额, 0);
    If Nvl(发票号_In, ' ') = ' ' And 发票金额_In <> 0 Then
      v_Err_Msg := '[ZLSOFT]不能对冲销或被冲销记录的发票号改为空,不能保存！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Select 供药单位id, Sum(Nvl(实际数量, 0))
    Into n_供货单位id, n_剩余数量
    From 药品收发记录
    Where 单据 = 15 And NO = No_In And 序号 = 序号_In
    Group By 供药单位id;
  
    --更新相关的发票信息,只更改发票号，发票日期
    For v_收发 In (Select a.Id, a.库房id, a.No, a.记录状态, a.零售金额, b.名称, b.规格, b.产地, a.批号, b.计算单位, a.实际数量, a.成本价, a.成本金额, a.填制人,
                        a.填制日期, a.审核人, a.审核日期, a.摘要, a.药品id, a.序号, a.供药单位id
                 From 药品收发记录 A, 收费项目目录 B
                 Where a.单据 = 15 And a.No = No_In And a.序号 = 序号_In And a.药品id = b.Id
                 Order By a.Id) Loop
      Update 应付记录
      Set 发票号 = 发票号_In, 发票代码 = 发票代码_In, 发票日期 = 发票日期_In, 发票金额 = Round((v_收发.实际数量 / n_剩余数量) * 发票金额_In, n_Dec),
          单位id = 供货单位id_In, 发票修改时间 = Sysdate
      Where 收发id = v_收发.Id And 系统标识 = 5 And 记录性质 = 0;
    
      If Sql%RowCount = 0 Then
        If 发票号_In Is Not Null Then
          --如果是第一笔明细,则产生应付记录的NO
          Begin
            Select NO
            Into v_No
            From 应付记录
            Where 系统标识 = 5 And 记录性质 = 0 And 入库单据号 = No_In And Rownum < 2;
          Exception
            When Others Then
              v_No := Nextno(67);
          End;
        
          Select 应付记录_Id.Nextval Into n_应付id From Dual;
          Insert Into 应付记录
            (ID, 记录性质, 记录状态, 单位id, NO, 系统标识, 收发id, 入库单据号, 单据金额, 发票号, 发票日期, 发票金额, 品名, 规格, 产地, 批号, 计量单位, 数量, 采购价, 采购金额,
             填制人, 填制日期, 审核人, 审核日期, 摘要, 项目id, 序号, 库房id, 发票代码, 发票修改时间)
          Values
            (n_应付id, 0, v_收发.记录状态, 供货单位id_In, v_No, 5, v_收发.Id, v_收发.No, v_收发.零售金额, 发票号_In, 发票日期_In,
             Round((v_收发.实际数量 / n_剩余数量) * 发票金额_In, n_Dec), v_收发.名称, v_收发.规格, v_收发.产地, v_收发.批号, v_收发.计算单位, v_收发.实际数量,
             v_收发.成本价, v_收发.成本金额, v_收发.填制人, v_收发.填制日期, v_收发.审核人, v_收发.审核日期, v_收发.摘要, v_收发.药品id, v_收发.序号, v_收发.库房id,
             发票代码_In, Sysdate);
        End If;
      End If;
    End Loop;
  Else
    --未冲销的单据
    Select a.Id, Nvl(b.发票金额, 0), a.供药单位id
    Into n_收发id, n_发票金额, n_供货单位id
    From 药品收发记录 A, (Select * From 应付记录 Where 系统标识 = 5 And 记录性质 = 0 And 记录状态 = 1 And 付款序号 Is Null) B
    Where a.Id = b.收发id(+) And a.No = No_In And a.单据 = 15 And a.记录状态 = 1 And a.序号 = 序号_In;
  
    Update 应付记录
    Set 发票号 = 发票号_In, 发票代码 = 发票代码_In, 发票日期 = 发票日期_In, 发票金额 = 发票金额_In, 单位id = 供货单位id_In, 发票修改时间 = Sysdate
    Where 收发id = n_收发id And 系统标识 = 5 And 记录状态 = 1 And 记录性质 = 0;
  
    If Sql%RowCount = 0 Then
      If 发票号_In Is Not Null Or 发票代码_In Is Not Null Then
        --如果是第一笔明细,则产生应付记录的NO
        Begin
          Select NO
          Into v_No
          From 应付记录
          Where 系统标识 = 5 And 记录性质 = 0 And 记录状态 = 1 And 入库单据号 = No_In And Rownum < 2;
        Exception
          When Others Then
            v_No := Nextno(67);
        End;
      
        Select 应付记录_Id.Nextval Into n_应付id From Dual;
      
        Insert Into 应付记录
          (ID, 记录性质, 记录状态, 项目id, 序号, 单位id, NO, 系统标识, 收发id, 入库单据号, 单据金额, 发票号, 发票日期, 发票金额, 品名, 规格, 产地, 批号, 计量单位, 数量, 采购价,
           采购金额, 填制人, 填制日期, 审核人, 审核日期, 摘要, 库房id, 发票代码, 发票修改时间)
          Select n_应付id, 0, 1, a.药品id, a.序号, 供货单位id_In, v_No, 5, n_收发id, a.No, a.零售金额, 发票号_In, 发票日期_In, 发票金额_In, b.名称,
                 b.规格, b.产地, a.批号, b.计算单位, a.实际数量, a.成本价, a.成本金额, a.填制人, a.填制日期, a.审核人, a.审核日期, a.摘要, a.库房id, 发票代码_In,
                 Sysdate
          From 药品收发记录 A, 收费项目目录 B
          Where a.单据 = 15 And a.No = No_In And a.序号 = 序号_In And a.药品id = b.Id;
      End If;
    End If;
  End If;

  Update 应付余额 Set 金额 = Nvl(金额, 0) - n_发票金额 Where 单位id = n_供货单位id And 性质 = 1;
  If Sql%NotFound Then
    Insert Into 应付余额 (单位id, 性质, 金额) Values (n_供货单位id, 1, -n_发票金额);
  End If;
  Update 应付余额 Set 金额 = Nvl(金额, 0) + Nvl(发票金额_In, 0) Where 单位id = 供货单位id_In And 性质 = 1;

  If Sql%NotFound Then
    Insert Into 应付余额 (单位id, 性质, 金额) Values (供货单位id_In, 1, 发票金额_In);
  End If;

  --更新药品收发记录中的供药单位
  Update 药品收发记录 Set 供药单位id = 供货单位id_In Where NO = No_In And 单据 = 15 And 序号 = 序号_In;

  --更新药品库存里的上次供应商
  Update 药品库存
  Set 上次供应商id = 供货单位id_In
  Where 性质 = 1 And (库房id, 药品id, 批次) In (Select 库房id, 药品id, nvl(批次,0) as 批次 From 药品收发记录 Where NO = No_In And 单据 = 15);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When No_Data_Found Then
    Raise_Application_Error(-20101, '[ZLSOFT]该单据已经被他人冲销或已经付过款！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料外购发票信息_Update;
/

--118738:刘涛,2017-12-20,修改发票信息库存上次供应商处理
Create Or Replace Procedure Zl_药品外购发票信息_Update
(
  No_In       In 药品收发记录.No%Type := Null,
  序号_In     In 药品收发记录.序号%Type,
  发票号_In   In 应付记录.发票号%Type := Null,
  发票日期_In In 应付记录.发票日期%Type := Null,
  发票金额_In In 应付记录.发票金额%Type := Null,
  供药单位_In In 应付记录.单位id%Type := 0,
  操作标志_In Number, --1、未冲销单据修改发票信息; 2、部分冲销单据修改发票信息
  发票代码_In In 应付记录.发票代码%Type := Null
) Is
  Errinfor Varchar2(255);
  Erritem Exception;

  v_No         应付记录.No%Type;
  v_应付id     应付记录.Id%Type;
  v_收发id     应付记录.收发id%Type;
  v_付款序号   应付记录.付款序号%Type;
  v_发票金额   应付记录.发票金额%Type; --旧发票金额
  v_供药单位id 应付记录.单位id%Type;
  n_Dec        Number;
  n_剩余数量   药品收发记录.实际数量%Type;

  Cursor c_药品记录 Is
    Select a.Id, a.库房id, a.No, a.记录状态, a.零售金额, b.名称, b.规格, b.产地, a.批号, b.计算单位, a.实际数量, a.成本价, a.成本金额, a.填制人, a.填制日期,
           a.审核人, a.审核日期, a.摘要, a.药品id, a.序号, a.供药单位id
    From 药品收发记录 A, 收费项目目录 B
    Where a.单据 = 1 And a.No = No_In And a.序号 = 序号_In And a.药品id = b.Id
    Order By a.Id;
Begin
  --金额小数位数
  Select Nvl(精度, 2) Into n_Dec From 药品卫材精度 Where 性质 = 0 And 类别 = 1 And 内容 = 4 And 单位 = 5;

  --取是否付款及总额
  Begin
    Select Max(付款序号), Sum(Nvl(发票金额, 0))
    Into v_付款序号, v_发票金额
    From 应付记录
    Where 收发id In (Select ID From 药品收发记录 Where NO = No_In And 序号 = 序号_In And 单据 = 1) And 系统标识 = 1 And 记录性质 = -1;
  Exception
    When Others Then
      v_发票金额 := 0;
      Null;
  End;
  v_发票金额 := Nvl(v_发票金额, 0);
  v_付款序号 := Nvl(v_付款序号, 0);
  If v_付款序号 <> 0 Then
    Errinfor := '[ZLSOFT]该单据已经被付了款，不能再修改发票信息[ZLSOFT]';
    Raise Erritem;
  End If;
  If 发票金额_In > v_发票金额 And v_发票金额 <> 0 Then
    Errinfor := '[ZLSOFT]发票金额不能大于计划付款金额[ZLSOFT]';
    Raise Erritem;
  End If;

  If 操作标志_In = 1 Then
    --未冲销单据
    Select a.Id, Nvl(b.发票金额, 0), a.供药单位id
    Into v_收发id, v_发票金额, v_供药单位id
    From 药品收发记录 A, (Select * From 应付记录 Where 系统标识 = 1 And 记录性质 = 0 And 记录状态 = 1 And 付款序号 Is Null) B
    Where a.Id = b.收发id(+) And a.No = No_In And a.单据 = 1 And a.记录状态 = 1 And a.序号 = 序号_In;
  
    Update 应付记录
    Set 发票号 = 发票号_In, 发票代码 = 发票代码_In, 发票日期 = 发票日期_In, 发票金额 = 发票金额_In, 单位id = 供药单位_In, 发票修改时间 = Sysdate
    Where 收发id = v_收发id And 系统标识 = 1 And 记录状态 = 1 And 记录性质 = 0;
  
    If Sql%RowCount = 0 Then
      If 发票号_In Is Not Null Then
        --如果是第一笔明细,则产生应付记录的NO
        Begin
          Select NO
          Into v_No
          From 应付记录
          Where 系统标识 = 1 And 记录性质 = 0 And 记录状态 = 1 And 入库单据号 = No_In And Rownum < 2;
        Exception
          When Others Then
            v_No := Nextno(67);
        End;
      
        Select 应付记录_Id.Nextval Into v_应付id From Dual;
        Insert Into 应付记录
          (ID, 记录性质, 记录状态, 单位id, NO, 系统标识, 收发id, 入库单据号, 单据金额, 发票号, 发票日期, 发票金额, 品名, 规格, 产地, 批号, 计量单位, 数量, 采购价, 采购金额, 填制人,
           填制日期, 审核人, 审核日期, 摘要, 项目id, 序号, 库房id, 发票修改时间, 发票代码)
          Select v_应付id, 0, 1, 供药单位_In, v_No, 1, v_收发id, a.No, a.零售金额, 发票号_In, 发票日期_In, 发票金额_In, b.名称, b.规格, b.产地, a.批号,
                 b.计算单位, a.实际数量, a.成本价, a.成本金额, a.填制人, a.填制日期, a.审核人, a.审核日期, a.摘要, a.药品id, a.序号, a.库房id, Sysdate,
                 发票代码_In
          From 药品收发记录 A, 收费项目目录 B
          Where a.单据 = 1 And a.No = No_In And a.序号 = 序号_In And a.药品id = b.Id;
      End If;
    End If;
  Else
    --计算原单据的发票金额
    Begin
      Select Sum(Nvl(发票金额, 0))
      Into v_发票金额
      From 应付记录
      Where 收发id In (Select ID From 药品收发记录 Where NO = No_In And 序号 = 序号_In And 单据 = 1) And 系统标识 = 1 And 记录性质 = 0;
    Exception
      When Others Then
        v_发票金额 := 0;
        Null;
    End;
  
    v_发票金额 := Nvl(v_发票金额, 0);
  
    --部分冲销单据，按数量分摊发票金额
    Select 供药单位id, Sum(实际数量)
    Into v_供药单位id, n_剩余数量
    From 药品收发记录
    Where 单据 = 1 And NO = No_In And 序号 = 序号_In
    Group By 供药单位id;
  
    For v_药品记录 In c_药品记录 Loop
      Update 应付记录
      Set 发票号 = 发票号_In, 发票代码 = 发票代码_In, 发票日期 = 发票日期_In, 发票金额 = Round((v_药品记录.实际数量 / n_剩余数量) * 发票金额_In, n_Dec),
          单位id = 供药单位_In, 发票修改时间 = Sysdate
      Where 收发id = v_药品记录.Id And 系统标识 = 1 And 记录性质 = 0;
    
      If Sql%RowCount = 0 Then
        If 发票号_In Is Not Null Then
          --如果是第一笔明细,则产生应付记录的NO
          Begin
            Select NO
            Into v_No
            From 应付记录
            Where 系统标识 = 1 And 记录性质 = 0 And 入库单据号 = No_In And Rownum < 2;
          Exception
            When Others Then
              v_No := Nextno(67);
          End;
        
          Select 应付记录_Id.Nextval Into v_应付id From Dual;
          Insert Into 应付记录
            (ID, 记录性质, 记录状态, 单位id, NO, 系统标识, 收发id, 入库单据号, 单据金额, 发票号, 发票日期, 发票金额, 品名, 规格, 产地, 批号, 计量单位, 数量, 采购价, 采购金额,
             填制人, 填制日期, 审核人, 审核日期, 摘要, 项目id, 序号, 库房id, 发票修改时间, 发票代码)
          Values
            (v_应付id, 0, v_药品记录.记录状态, 供药单位_In, v_No, 1, v_药品记录.Id, v_药品记录.No, v_药品记录.零售金额, 发票号_In, 发票日期_In,
             Round((v_药品记录.实际数量 / n_剩余数量) * 发票金额_In, n_Dec), v_药品记录.名称, v_药品记录.规格, v_药品记录.产地, v_药品记录.批号, v_药品记录.计算单位,
             v_药品记录.实际数量, v_药品记录.成本价, v_药品记录.成本金额, v_药品记录.填制人, v_药品记录.填制日期, v_药品记录.审核人, v_药品记录.审核日期, v_药品记录.摘要,
             v_药品记录.药品id, v_药品记录.序号, v_药品记录.库房id, Sysdate, 发票代码_In);
        End If;
      End If;
    
    End Loop;
  End If;

  Update 应付余额 Set 金额 = Nvl(金额, 0) - v_发票金额 Where 单位id = v_供药单位id And 性质 = 1;
  If Sql%NotFound Then
    Insert Into 应付余额 (单位id, 性质, 金额) Values (v_供药单位id, 1, -v_发票金额);
  End If;
  Update 应付余额 Set 金额 = Nvl(金额, 0) + 发票金额_In Where 单位id = 供药单位_In And 性质 = 1;
  If Sql%NotFound Then
    Insert Into 应付余额 (单位id, 性质, 金额) Values (供药单位_In, 1, 发票金额_In);
  End If;

  --更新药品收发记录中的供药单位
  Update 药品收发记录 Set 供药单位id = 供药单位_In Where NO = No_In And 单据 = 1 And 序号 = 序号_In;

  --更新药品库存里的上次供应商
  Update 药品库存
  Set 上次供应商id = 供药单位_In
  Where (库房id, 药品id, 批次) In (Select 库房id, 药品id, nvl(批次,0) as 批次 From 药品收发记录 Where NO = No_In And 单据 = 1) And 性质 = 1;
Exception
  When Erritem Then
    Raise_Application_Error(-20101, Errinfor);
  When No_Data_Found Then
    Raise_Application_Error(-20101, '[ZLSOFT]该单据已经被他人冲销或已经付过款！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品外购发票信息_Update;
/

--106747:李小东,2017-12-19,直接登记的标本回滚到无主状态时删除病人医嘱记录
Create Or Replace Procedure Zl_检验标本记录_转为无主
(
  医嘱id_In   In 检验标本记录.医嘱id%Type,
  删除院外_In In Number := 0
) Is
  --=0删除无主=1不删除无主

  Cursor c_Sample Is
    Select Distinct a.Id As 标本id, Decode(b.医嘱id, Null, a.医嘱id, b.医嘱id) As 医嘱id, a.申请类型, a.病人id, a.病人来源
    From 检验项目分布 B, 检验标本记录 A
    Where a.Id = b.标本id(+) And a.医嘱id = 医嘱id_In;

  Cursor c_Stuff(Vno Varchar2) Is
    Select Distinct s.Id, s.批号, s.实际数量, s.已发数量
    From (Select a.Id, a.批号, a.实际数量, b.已发数量, a.记录状态, a.审核人
           From (Select a.Id, a.药品id, a.序号, a.单据, a.批号, a.实际数量, a.记录状态, a.审核人
                  From 药品收发记录 A
                  Where a.审核人 Is Not Null And Nvl(a.发药方式, 0) <> -1 And (a.记录状态 = 1 Or Mod(a.记录状态, 3) = 0) And a.No = Vno And
                        a.单据 In (24, 25, 26)) A,
                (Select a.单据, a.药品id, a.序号, Sum(a.实际数量) As 已发数量
                  From 药品收发记录 A
                  Where a.审核人 Is Not Null And Nvl(a.发药方式, 0) <> -1 And a.No = Vno And
                        单据 In (Select 单据
                               From 药品收发记录
                               Where NO = Vno And 审核人 Is Not Null And Nvl(发药方式, 0) <> -1 And (记录状态 = 1 Or Mod(记录状态, 3) = 0) And
                                     单据 In (24, 25, 26))
                  Group By a.单据, a.药品id, a.序号) B
           Where a.单据 = b.单据 And a.药品id + 0 = b.药品id And a.序号 = b.序号 And b.已发数量 <> 0) S
    Where (s.记录状态 = 1 Or Mod(s.记录状态, 3) = 0) And s.实际数量 > (s.实际数量 - s.已发数量) And s.审核人 Is Not Null;

  v_Temp       Varchar2(255);
  v_人员部门id 部门人员.部门id%Type;
  v_人员编号   人员表.编号%Type;
  v_人员姓名   人员表.姓名%Type;
  Err_Custom Exception;
  v_Error Varchar2(255);
  v_Flag  Number(1) := 0;

  v_No       Varchar2(20);
  v_当前时间 Date;
  v_主页id   Number(18);
Begin
  v_Temp       := Zl_Identity;
  v_人员部门id := To_Number(Substr(v_Temp, 1, Instr(v_Temp, ',') - 1));
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_人员编号   := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_人员姓名   := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_当前时间   := Sysdate;
  v_Flag       := 0;
  Begin
    Select Nvl(Max(1), 0) Into v_Flag From 检验标本记录 Where 微生物标本 = 1 And 医嘱id = 医嘱id_In;
  Exception
    When Others Then
      v_Flag := 0;
  End;

  If v_Flag = 1 Then
  
    For r_Sample In c_Sample Loop
      Update 检验项目分布
      Set 医嘱id = Null
      Where 标本id In (Select Distinct ID From 检验标本记录 Where 医嘱id = r_Sample.医嘱id);
      Update 检验标本记录
      Set 医嘱id = Null, 姓名 = Null, 性别 = Null, 年龄 = Null, 病人id = Null, 病人来源 = Null, 婴儿 = Null, 合并id = Null, 紧急 = Null,
          挂号单 = Null, 门诊号 = Null, 住院号 = Null, 出生日期 = Null, 主页id = Null, 检验项目 = Null, 操作类型 = Null, 年龄单位 = Null,
          年龄数字 = Null, 申请人 = Null, 申请科室id = Null, 采样人 = Null, 采样时间 = Null, 标本类型 = Null, 标本形态 = Null, 接收人 = Null,
          接收时间 = Null, 样本条码 = Null
      Where 医嘱id = r_Sample.医嘱id;
      If r_Sample.申请类型 = 1 Then
        --删除时有问题时不进行删除
        Begin
          Delete 医嘱执行时间 Where 医嘱id In (Select ID From 病人医嘱记录 Where r_Sample.医嘱id In (ID, 相关id));
          Delete 病人医嘱发送 Where 医嘱id In (Select ID From 病人医嘱记录 Where r_Sample.医嘱id In (ID, 相关id));
          Delete 病人医嘱记录 Where r_Sample.医嘱id In (ID, 相关id);
          Null;
        Exception
          When Others Then
            Null;
        End;
      Else
        Update 病人医嘱发送
        Set 执行状态 = 0
        Where 执行状态 = 3 And 医嘱id In (Select ID From 病人医嘱记录 Where r_Sample.医嘱id In (ID, 相关id));
      
        If r_Sample.病人来源 = 2 Then
          Update /*+ rule */ 住院费用记录
          Set 执行状态 = 0, 执行时间 = Null, 执行人 = Null
          Where 病人id = r_Sample.病人id And 收费类别 Not In ('5', '6', '7') And
                (医嘱序号, 记录性质, NO) In
                (Select 医嘱id, 记录性质, NO
                 From 病人医嘱附费
                 Where 医嘱id = r_Sample.医嘱id
                 Union All
                 Select 医嘱id, 记录性质, NO
                 From 病人医嘱发送
                 Where 医嘱id In (Select ID From 病人医嘱记录 Where r_Sample.医嘱id In (ID, 相关id) And 相关id Is Not Null) And
                       接收人 Is Null
                 Union All
                 Select a.医嘱id, a.记录性质, a.No
                 From 病人医嘱发送 A, 住院费用记录 B
                 Where 医嘱id In (Select ID From 病人医嘱记录 Where r_Sample.医嘱id In (ID, 相关id) And 相关id Is Null) And
                       采样人 Is Null And a.医嘱id = b.医嘱序号 And a.记录性质 = b.记录性质 And a.No = b.No And
                       b.执行人 In (Select Distinct 姓名
                                 From 人员表 A, 部门人员 B, 部门性质说明 C
                                 Where a.Id = b.人员id And b.部门id = c.部门id And c.工作性质 = '检验'));
        Else
          Update /*+ rule */ 门诊费用记录
          Set 执行状态 = 0, 执行时间 = Null, 执行人 = Null
          Where 病人id = r_Sample.病人id And 收费类别 Not In ('5', '6', '7') And
                (医嘱序号, 记录性质, NO) In
                (Select 医嘱id, 记录性质, NO
                 From 病人医嘱附费
                 Where 医嘱id = r_Sample.医嘱id
                 Union All
                 Select 医嘱id, 记录性质, NO
                 From 病人医嘱发送
                 Where 医嘱id In (Select ID From 病人医嘱记录 Where r_Sample.医嘱id In (ID, 相关id) And 相关id Is Not Null) And
                       接收人 Is Null
                 Union All
                 Select a.医嘱id, a.记录性质, a.No
                 From 病人医嘱发送 A, 门诊费用记录 B
                 Where 医嘱id In (Select ID From 病人医嘱记录 Where r_Sample.医嘱id In (ID, 相关id) And 相关id Is Null) And
                       采样人 Is Null And a.医嘱id = b.医嘱序号 And a.记录性质 = b.记录性质 And a.No = b.No And
                       b.执行人 In (Select Distinct 姓名
                                 From 人员表 A, 部门人员 B, 部门性质说明 C
                                 Where a.Id = b.人员id And b.部门id = c.部门id And c.工作性质 = '检验'));
        
        End If;
        --取消试剂消耗单的审核
        v_No := '';
        Begin
          Select Distinct NO Into v_No From 检验试剂记录 Where 医嘱id = r_Sample.医嘱id;
        Exception
          When Others Then
            v_No := '';
        End;
      
        If v_No Is Not Null Then
        
          For r_Stuff In c_Stuff(v_No) Loop
            Zl_材料收发记录_部门退料(r_Stuff.Id, v_人员姓名, v_当前时间, r_Stuff.批号, Null, Null, r_Stuff.已发数量, 0, Null, 0);
          End Loop;
        
          v_主页id := Null;
          Select 主页id Into v_主页id From 病人医嘱记录 A Where ID = r_Sample.医嘱id;
        
          If v_主页id Is Null Then
            Zl_门诊记帐记录_Delete(v_No, '', v_人员编号, v_人员姓名);
          Else
            Zl_住院记帐记录_Delete(v_No, '', v_人员编号, v_人员姓名);
          End If;
          Update 检验试剂记录 Set NO = '' Where 医嘱id = r_Sample.医嘱id;
        End If;
      End If;
    
    End Loop;
  
  Else
  
    For r_Sample In c_Sample Loop
    
      --检查是否允许取消核收
      v_Flag := 0;
      Begin
        Select 1 Into v_Flag From 检验标本记录 Where ID = r_Sample.标本id And 样本状态 = 2;
      Exception
        When Others Then
          v_Flag := 0;
      End;
    
      If v_Flag = 1 Then
        v_Error := '当前申请所在的标本中有已经被审核的，请先取消审核！';
        Raise Err_Custom;
      End If;
    
      --删除合并关联项目
      Update 检验标本记录 Set 合并id = Null Where 合并id In (Select ID From 检验标本记录 Where 医嘱id = 医嘱id_In);
      --更改检验标本记录里记录的医嘱id,其实这可以不要此信息,以后考虑取消
      Update 检验标本记录
      Set 医嘱id = Null, 姓名 = Null, 性别 = Null, 年龄 = Null, 病人id = Null, 病人来源 = Null, 婴儿 = Null, 合并id = Null, 紧急 = Null,
          挂号单 = Null, 门诊号 = Null, 住院号 = Null, 出生日期 = Null, 主页id = Null, 检验项目 = Null, 操作类型 = Null, 年龄单位 = Null,
          年龄数字 = Null, 申请人 = Null, 申请科室id = Null, 采样人 = Null, 采样时间 = Null, 标本类型 = Null, 标本形态 = Null, 接收人 = Null,
          接收时间 = Null, 样本条码 = Null
      Where ID = r_Sample.标本id;
    
      Update 检验项目分布 Set 医嘱id = Null Where 标本id = r_Sample.标本id;
    
      If r_Sample.申请类型 = 1 Then
        --删除时有问题时不进行删除
        Begin
          Delete 医嘱执行时间 Where 医嘱id In (Select ID From 病人医嘱记录 Where r_Sample.医嘱id In (ID, 相关id));
          Delete 病人医嘱发送 Where 医嘱id In (Select ID From 病人医嘱记录 Where r_Sample.医嘱id In (ID, 相关id));
          Delete 病人医嘱记录 Where r_Sample.医嘱id In (ID, 相关id);
          Null;
        Exception
          When Others Then
            Null;
        End;
      Else
        Update 病人医嘱发送
        Set 执行状态 = 0
        Where 执行状态 = 3 And 医嘱id In (Select ID From 病人医嘱记录 Where r_Sample.医嘱id In (ID, 相关id));
      
        If r_Sample.病人来源 = 2 Then
          Update /*+ rule */ 住院费用记录
          Set 执行状态 = 0, 执行时间 = Null, 执行人 = Null
          Where 病人id = r_Sample.病人id And 收费类别 Not In ('5', '6', '7') And
                (医嘱序号, 记录性质, NO) In
                (Select 医嘱id, 记录性质, NO
                 From 病人医嘱附费
                 Where 医嘱id = r_Sample.医嘱id
                 Union All
                 Select 医嘱id, 记录性质, NO
                 From 病人医嘱发送
                 Where 医嘱id In (Select ID From 病人医嘱记录 Where r_Sample.医嘱id In (ID, 相关id) And 相关id Is Not Null) And
                       接收人 Is Null
                 Union All
                 Select a.医嘱id, a.记录性质, a.No
                 From 病人医嘱发送 A, 住院费用记录 B
                 Where 医嘱id In (Select ID From 病人医嘱记录 Where r_Sample.医嘱id In (ID, 相关id) And 相关id Is Null) And
                       采样人 Is Null And a.医嘱id = b.医嘱序号 And a.记录性质 = b.记录性质 And a.No = b.No And
                       b.执行人 In (Select Distinct 姓名
                                 From 人员表 A, 部门人员 B, 部门性质说明 C
                                 Where a.Id = b.人员id And b.部门id = c.部门id And c.工作性质 = '检验'));
        Else
          Update /*+ rule */ 门诊费用记录
          Set 执行状态 = 0, 执行时间 = Null, 执行人 = Null
          Where 病人id = r_Sample.病人id And 收费类别 Not In ('5', '6', '7') And
                (医嘱序号, 记录性质, NO) In
                (Select 医嘱id, 记录性质, NO
                 From 病人医嘱附费
                 Where 医嘱id = r_Sample.医嘱id
                 Union All
                 Select 医嘱id, 记录性质, NO
                 From 病人医嘱发送
                 Where 医嘱id In (Select ID From 病人医嘱记录 Where r_Sample.医嘱id In (ID, 相关id) And 相关id Is Not Null) And
                       接收人 Is Null
                 Union All
                 Select a.医嘱id, a.记录性质, a.No
                 From 病人医嘱发送 A, 门诊费用记录 B
                 Where 医嘱id In (Select ID From 病人医嘱记录 Where r_Sample.医嘱id In (ID, 相关id) And 相关id Is Null) And
                       采样人 Is Null And a.医嘱id = b.医嘱序号 And a.记录性质 = b.记录性质 And a.No = b.No And
                       b.执行人 In (Select Distinct 姓名
                                 From 人员表 A, 部门人员 B, 部门性质说明 C
                                 Where a.Id = b.人员id And b.部门id = c.部门id And c.工作性质 = '检验'));
        End If;
      End If;
      --取消试剂消耗单的审核
      v_No := '';
      Begin
        Select Distinct NO Into v_No From 检验试剂记录 Where 医嘱id = r_Sample.医嘱id;
      Exception
        When Others Then
          v_No := '';
      End;
      If v_No Is Not Null Then
        For r_Stuff In c_Stuff(v_No) Loop
          Zl_材料收发记录_部门退料(r_Stuff.Id, v_人员姓名, v_当前时间, r_Stuff.批号, Null, Null, r_Stuff.已发数量, 0, Null, 0);
        End Loop;
      
        v_主页id := Null;
        Select 主页id Into v_主页id From 病人医嘱记录 A Where ID = r_Sample.医嘱id;
      
        If v_主页id Is Null Then
          Zl_门诊记帐记录_Delete(v_No, '', v_人员编号, v_人员姓名);
        Else
          Zl_住院记帐记录_Delete(v_No, '', v_人员编号, v_人员姓名);
        End If;
        Update 检验试剂记录 Set NO = '' Where 医嘱id = r_Sample.医嘱id;
      End If;
      --删除试剂消耗单
    --Delete From 检验试剂记录 Where 医嘱id = r_Sample.医嘱id;
    End Loop;
  End If;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_检验标本记录_转为无主;
/

--120398:李业庆,2018-01-18,收发记录填写发药窗口
--120256:李业庆,2018-01-16,增加卫材出库顺序参数
--118679:李业庆,2017-12-19,住院记帐药品业务封装
--118156:李业庆,2017-12-20,药品库存或收发记录批次为空处理
Create Or Replace Procedure Zl_药品收发记录_销售出库
(
  Id_In           In 门诊费用记录.Id%Type,
  药品摘要_In     药品收发记录.摘要%Type := Null,
  频次_In         药品收发记录.频次%Type := Null,
  单量_In         药品收发记录.单量%Type := Null,
  用法_In         药品收发记录.用法%Type := Null,
  煎法_In         药品收发记录.外观%Type := Null,
  期效_In         药品收发记录.扣率%Type := Null,
  计价特性_In     药品收发记录.扣率%Type := Null,
  主页id_In       未发药品记录.主页id%Type := Null,
  备货材料_In     Number := 0,
  备货材料批次_In 药品收发记录.批次%Type := Null,
  领药部门_In     药品收发记录.对方部门id%Type := Null
) Is
  ----------------------------------
  --功能：收费、划价时按照参数设置分解药品并产生相应的收发记录
  --规则：
  --      1、循环游标判断总出库数量与游标中每条记录数量是否充足，如果充足就是总数量，不充足挨个遍历直到数量直到遍历完并退出
  --      2、金额计算方式：定价取收费价目表现价，时价分批取库存表零售价，时价不分批，零售金额/实际数量，并将所有批次的金额累加起来为总出库金额
  --参数：
  --      Id_In：门诊费用记录或者住院费用记录ID
  --      备货材料_In：只有高值卫材才需要传入，非0表示是高值卫材模式
  --      备货材料批次_In：支持高值卫材扫码确定批次出库，所以35.70支持材料非备货材料模式按批次出库；药品不支持这种模式，即药品批次都传空，做兼容性判断，即使传了非空，只要是药品都不管批次
  --      药品摘要_In：可选参数
  --      频次_In；单量_In；用法_In；煎法_In；期效_In；计价特性_In，可选参数，医嘱记录产生
  -----------------------------------
  Cursor c_Stock
  (
    n_Outmode  Number,
    n_库房id   药品收发记录.库房id%Type,
    n_药品id   药品收发记录.药品id%Type,
    n_备货批次 药品收发记录.批次%Type,
    n_类别     Number --0-卫材,1-药品
  ) Is
    Select 库房id, 药品id, Nvl(批次, 0) 批次, 效期, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 灭菌效期, 批准文号,
           平均成本价, 零售价, 上次扣率, 商品条码, 内部条码, 原产地
    From 药品库存 A
    Where 药品id = n_药品id And 库房id = n_库房id And 性质 = 1 And Decode(n_类别, 0, Decode(n_备货批次, Null, 0, Nvl(批次, 0)), 0) =
          Decode(n_类别, 0, Decode(n_备货批次, Null, 0, Nvl(n_备货批次, 0)), 0) And
          (Nvl(批次, 0) = 0 Or 效期 Is Null Or 效期 > Trunc(Sysdate)) And Nvl(可用数量, 0) > 0
    Order By Decode(n_Outmode, 1, 效期, Null), Nvl(批次, 0);
  r_Stock c_Stock%RowType;

  n_Outmode      Number;
  n_分批         药品规格.药房分批%Type;
  n_时价         收费项目目录.是否变价%Type;
  n_当前数量     药品库存.实际数量%Type;
  n_费用金额小数 Number;
  n_费用单价小数 Number;
  n_流通金额小数 Number;
  n_流通单价小数 Number;
  n_标准单价     收费价目.现价%Type;
  n_当前单价     收费价目.现价%Type;
  n_类别         药品单据性质.类别id%Type;
  n_总金额       Number;
  n_总数量       药品库存.实际数量%Type;
  n_单据         药品单据性质.单据%Type;
  n_跟踪在用     材料特性.跟踪在用%Type;
  n_序号         门诊费用记录.序号%Type;
  v_名称         收费项目目录.名称%Type;
  n_虚拟库房id   部门表.Id%Type;
  n_库房id       部门表.Id%Type;
  n_优先级       身份.优先级%Type;
  n_Count        Number;
  Err_Custom Exception;
  v_Rust     Varchar2(300);
  v_Error    Varchar2(255);
  v_部门名称 部门表.名称%Type;

  v_单据类别   Varchar2(10);
  v_No         药品收发记录.No%Type;
  n_对方部门id 药品收发记录.对方部门id%Type;
  n_收费细目id 药品收发记录.药品id%Type;
  n_总出库数量 药品库存.实际数量%Type;
  n_发药库房id 药品收发记录.库房id%Type;
  n_记录性质   门诊费用记录.记录性质%Type;
  v_收费类别   门诊费用记录.收费类别%Type;
  n_多病人单   住院费用记录.多病人单%Type;
  n_医嘱序号   门诊费用记录.医嘱序号%Type;
  v_姓名       门诊费用记录.姓名%Type;
  n_付数       门诊费用记录.付数%Type;
  v_操作员     门诊费用记录.操作员姓名%Type;
  d_登记时间   门诊费用记录.登记时间%Type;
  n_门诊标志   门诊费用记录.门诊标志%Type;
  n_病人科室id 门诊费用记录.病人科室id%Type;
  n_标识号     门诊费用记录.标识号%Type;
  v_性别       门诊费用记录.性别%Type;
  n_年龄       门诊费用记录.年龄%Type;
  n_病人id     门诊费用记录.病人id%Type;
  v_发药窗口   门诊费用记录.发药窗口%Type;
  n_记录状态   门诊费用记录.记录状态%Type;

  --药品收发记录
  n_收发id   药品收发记录.Id%Type;
  n_扣率     药品收发记录.扣率%Type;
  d_灭菌效期 药品收发记录.灭菌效期%Type;
  d_灭菌日期 药品收发记录.灭菌日期%Type;

  v_其他出库no 药品收发记录.No%Type;
  n_出库序号   药品收发记录.序号%Type;
  n_定价售价   收费价目.现价%Type;
  n_出库检查   Number(1);
Begin
  Begin
    Select 类别, NO, 序号, 对方部门id, 收费细目id, 总出库数量, 发药库房id, 记录性质, 收费类别, 多病人单, 医嘱序号, 姓名, 付数, 划价人, 登记时间, 门诊标志, 病人科室id, 标识号, 性别,
           年龄, 病人id, 发药窗口, 记录状态, 标准单价
    Into v_单据类别, v_No, n_序号, n_对方部门id, n_收费细目id, n_总出库数量, n_发药库房id, n_记录性质, v_收费类别, n_多病人单, n_医嘱序号, v_姓名, n_付数, v_操作员,
         d_登记时间, n_门诊标志, n_病人科室id, n_标识号, v_性别, n_年龄, n_病人id, v_发药窗口, n_记录状态, n_标准单价
    From (Select '门诊' As 类别, NO, 序号, 病人科室id As 对方部门id, 收费细目id, 付数 * 数次 As 总出库数量, 执行部门id As 发药库房id, 记录性质, 收费类别, 0 As 多病人单,
                  医嘱序号, 姓名, 付数, 划价人, 登记时间, 门诊标志, 病人科室id, 标识号, 性别, 年龄, 病人id, 发药窗口, 记录状态, 标准单价
           From 门诊费用记录
           Where ID = Id_In
           Union All
           Select '住院' As 类别, NO, 序号, 病人科室id As 对方部门id, 收费细目id, 付数 * 数次 As 总出库数量, 执行部门id As 发药库房id, 记录性质, 收费类别, 多病人单, 医嘱序号,
                  姓名, 付数, Nvl(划价人, 操作员姓名) As 划价人, 登记时间, 门诊标志, 病人科室id, 标识号, 性别, 年龄, 病人id, 发药窗口, 记录状态, 标准单价
           From 住院费用记录
           Where ID = Id_In);
  Exception
    When Others Then
      v_No         := Null;
      n_对方部门id := 0;
      n_总出库数量 := 0;
  End;

  Zl_药品库存_可用数量异常处理(n_发药库房id, n_收费细目id);

  --住院领药部门确认
  If v_单据类别 = '住院' Then
    n_对方部门id := 领药部门_In;
  End If;

  n_跟踪在用 := 0;
  --只处理有数量的
  If n_总出库数量 <> 0 Then
    If v_收费类别 = '4' Then
      --卫材分批出库方式 
      Select Zl_To_Number(Nvl(zl_GetSysParameter(156), 0)) Into n_Outmode From Dual;
    Else
      --药品分批出库方式
      Select Zl_To_Number(Nvl(zl_GetSysParameter(150), 0)) Into n_Outmode From Dual;
    End If;
  
    --金额小数位数
    Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')), Zl_To_Number(Nvl(zl_GetSysParameter(157), '5'))
    Into n_费用金额小数, n_费用单价小数
    From Dual;
  
    --取流通业务精度位数
    --类别:1-药品 2-卫材
    --内容：2-零售价 4-金额
    --单位：药品:1-售价 5-金额单位
    If v_收费类别 = '4' Then
      Select 精度 Into n_流通单价小数 From 药品卫材精度 Where 类别 = 2 And 内容 = 2 And 单位 = 1;
      Select 精度 Into n_流通金额小数 From 药品卫材精度 Where 类别 = 2 And 内容 = 4 And 单位 = 5;
    Else
      Select 精度 Into n_流通单价小数 From 药品卫材精度 Where 类别 = 1 And 内容 = 2 And 单位 = 1;
      Select 精度 Into n_流通金额小数 From 药品卫材精度 Where 类别 = 1 And 内容 = 4 And 单位 = 5;
    End If;
  
    n_总数量 := n_总出库数量;
  
    If v_收费类别 = '4' Then
      --收费类别=4表示是卫材单据
      If v_单据类别 = '门诊' Then
        If n_记录性质 = 1 Then
          n_单据 := 24;
        Else
          n_单据 := 25;
        End If;
      Elsif v_单据类别 = '住院' Then
        If n_多病人单 = 1 Then
          n_单据 := 26;
        Else
          n_单据 := 25;
        End If;
      End If;
    
      Select Nvl(a.在用分批, 0), Nvl(b.是否变价, 0), b.名称, c.现价
      Into n_分批, n_时价, v_名称, n_定价售价
      From 材料特性 A, 收费项目目录 B, 收费价目 C
      Where a.材料id = b.Id And b.Id = n_收费细目id And b.Id = c.收费细目id And Sysdate Between c.执行日期 And c.终止日期;
      --跟踪在用
      Select 跟踪在用 Into n_跟踪在用 From 材料特性 Where 材料id = n_收费细目id;
      --备货卫材需要判断是否设置了虚拟库房对照
      If Nvl(备货材料_In, 0) = 1 Then
        Begin
          Select 虚拟库房id Into n_虚拟库房id From 虚拟库房对照 Where 科室id = n_发药库房id And Rownum <= 1;
        Exception
          When Others Then
            n_虚拟库房id := 0;
        End;
        If Nvl(n_虚拟库房id, 0) = 0 Then
          Begin
            Select 名称 Into v_Error From 部门表 Where ID = n_发药库房id;
          Exception
            When Others Then
              v_Error := '';
          End;
          v_Error := '执行部门"' || Nvl(v_Error, '') || '"未设置虚拟部门,请在卫材参数设置中设置.';
          Raise Err_Custom;
        End If;
      End If;
    Else
      --收费类别<>4表示是药品单据，收费类别有"5，6，7"
      If v_单据类别 = '门诊' Then
        If n_记录性质 = 1 Then
          n_单据 := 8;
        Else
          n_单据 := 9;
        End If;
      Elsif v_单据类别 = '住院' Then
        If n_多病人单 = 1 Then
          n_单据 := 10;
        Else
          n_单据 := 9;
        End If;
      End If;
    
      Select Nvl(a.药房分批, 0), Nvl(b.是否变价, 0), b.名称, c.现价
      Into n_分批, n_时价, v_名称, n_定价售价
      From 药品规格 A, 收费项目目录 B, 收费价目 C
      Where a.药品id = b.Id And b.Id = n_收费细目id And b.Id = c.收费细目id And Sysdate Between c.执行日期 And c.终止日期;
    End If;
  
    --可能分批时价药品分解的批次变了
    If n_时价 = 1 Then
      --只有一个批次时,直接取该批次的单价
      --按照最小单位进行格式化
    
      If Nvl(备货材料_In, 0) = 1 And v_收费类别 = '4' Then
        v_Rust := Zl_Fun_Getprice(n_收费细目id, n_虚拟库房id, n_总出库数量, 备货材料_In, 备货材料批次_In);
      Else
        v_Rust := Zl_Fun_Getprice(n_收费细目id, n_发药库房id, n_总出库数量, 备货材料_In, 备货材料批次_In);
      End If;
      n_当前单价 := To_Number(Substr(v_Rust, 1, Instr(v_Rust, '|') - 1));
    
      If Round(n_当前单价, n_费用单价小数) <> Round(n_标准单价, n_费用单价小数) Then
        If n_医嘱序号 Is Null Then
          If v_收费类别 = '4' Then
            v_Error := '第 ' || n_序号 || ' 行的时价卫生材料"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
          Else
            v_Error := '第 ' || n_序号 || ' 行的时价药品"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
          End If;
        Else
          If v_收费类别 = '4' Then
            v_Error := '在处理病人"' || v_姓名 || '"时发现时价卫生材料"' || v_名称 || '"当前计算的单价发生变化。' || Chr(13) || Chr(10) ||
                       '请检查该病人是否同时使用了两笔相同的"' || v_名称 || '"！';
          Else
            v_Error := '在处理病人"' || v_姓名 || '"时发现时价药品"' || v_名称 || '"当前计算的单价发生变化。' || Chr(13) || Chr(10) ||
                       '请检查该病人是否同时使用了两笔相同的"' || v_名称 || '"！';
          End If;
        End If;
        Raise Err_Custom;
      End If;
    End If;
  
    If v_收费类别 In ('5', '6', '7') Or (v_收费类别 = '4' And Nvl(n_跟踪在用, 0) = 1) Then
      If Nvl(备货材料_In, 0) = 1 And v_收费类别 = '4' Then
        n_库房id := n_虚拟库房id;
      Else
        n_库房id := n_发药库房id;
      End If;
    
      Begin
        If v_收费类别 In ('5', '6', '7') Then
          Select 检查方式 Into n_出库检查 From 药品出库检查 Where 库房id = n_库房id;
        Else
          Select 检查方式 Into n_出库检查 From 材料出库检查 Where 库房id = n_库房id;
        End If;
      Exception
        When Others Then
          n_出库检查 := 0;
      End;
    
      If v_收费类别 = '4' Then
        Select 类别id Into n_类别 From 药品单据性质 Where 单据 = n_单据 + 16;
      Else
        Select 类别id Into n_类别 From 药品单据性质 Where 单据 = n_单据;
      End If;
    
      n_总金额 := 0;
      --打开游标
      If v_收费类别 = '4' Then
        Open c_Stock(n_Outmode, n_库房id, n_收费细目id, 备货材料批次_In, 0);
      Else
        Open c_Stock(n_Outmode, n_库房id, n_收费细目id, 备货材料批次_In, 1);
      End If;
      --循环遍历
      While n_总出库数量 <> 0 Loop
        Fetch c_Stock
          Into r_Stock;
        If c_Stock%NotFound Then
          --第一次就没有库存,分批或时价都不允许。
          --分批药品数量分解不完,也就是库存不足。
          If n_分批 = 1 Or n_时价 = 1 Then
            Close c_Stock;
            If n_单据 = 8 Or n_单据 = 24 Then
              If v_收费类别 = '4' Then
                v_Error := '第 ' || n_序号 || ' 行的分批或时价卫生材料"' || v_名称 || '"没有可用的库存！';
              Else
                v_Error := '第 ' || n_序号 || ' 行的分批或时价药品"' || v_名称 || '"没有可用的药品库存！';
              End If;
            Else
              --单据=9，10，25，26是记账单提示不一样
              If n_医嘱序号 Is Null Then
                If v_收费类别 = '4' Then
                  If Nvl(备货材料_In, 0) = 1 And Not (n_分批 = 1 Or n_时价 = 1) Then
                    v_Error := '第 ' || n_序号 || ' 行的卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
                  Else
                    v_Error := '第 ' || n_序号 || ' 行的分批或时价卫生材料"' || v_名称 || '"没有足够的材料库存' || Case
                                 When Nvl(备货材料_In, 0) = 0 Then
                                  '！'
                                 Else
                                  ',不能进行备货记帐！'
                               End;
                  End If;
                Else
                  v_Error := '第 ' || n_序号 || ' 行的分批或时价药品"' || v_名称 || '"没有足够的库存！';
                End If;
              Else
                If v_收费类别 = '4' Then
                  If Nvl(备货材料_In, 0) = 1 And Not (n_分批 = 1 Or n_时价 = 1) Then
                    v_Error := '在处理病人"' || v_姓名 || '"时发现卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
                  Else
                    v_Error := '在处理病人"' || v_姓名 || '"时发现分批或时价卫生材料"' || v_名称 || '"没有足够的材料库存' || Case
                                 When Nvl(备货材料_In, 0) = 0 Then
                                  '！'
                                 Else
                                  ',不能进行备货记帐！'
                               End;
                  End If;
                Else
                  v_Error := '在处理病人"' || v_姓名 || '"时发现分批或时价药品"' || v_名称 || '"没有足够的库存！';
                End If;
              End If;
            End If;
            Raise Err_Custom;
          End If;
        Elsif (n_分批 = 1 And Nvl(r_Stock.批次, 0) = 0) Or (n_分批 = 0 And Nvl(r_Stock.批次, 0) <> 0) Then
          Close c_Stock;
          If n_医嘱序号 Is Null Then
            If v_收费类别 = '4' Then
              v_Error := '第 ' || n_序号 || ' 行卫生材料"' || v_名称 || '"的在用分批属性与库存记录不相符,请检查材料数据的正确性！';
            Else
              v_Error := '第 ' || n_序号 || ' 行药品"' || v_名称 || '"的分批属性与库存记录不相符,请检查药品数据的正确性！';
            End If;
          Else
            If v_收费类别 = '4' Then
              v_Error := '在处理病人"' || v_姓名 || '"时发现卫生材料"' || v_名称 || '"的分批属性与库存记录不相符,请检查材料数据的正确性！';
            Else
              v_Error := '在处理病人"' || v_姓名 || '"时发现药品"' || v_名称 || '"的分批属性与库存记录不相符,请检查药品数据的正确性！';
            End If;
          End If;
          Raise Err_Custom;
        End If;
      
        If c_Stock%Found Then
          If Nvl(r_Stock.实际数量, 0) = 0 And (n_总出库数量 > 0 Or n_时价 = 1) And n_出库检查 = 2 Then
            --实际数量为零时，如果严格控制库存，不允许出库
            --实际数量不为零，金额为零，可能是正常的零价格管理。
            --负数的情况相当于入库,这种情况应是允许的；但时价需要计算价格，必须要有实际数量。
            Close c_Stock;
            If n_医嘱序号 Is Null Then
              If v_收费类别 = '4' Then
                v_Error := '第 ' || n_序号 || ' 行的卫生材料"' || v_名称 || '"当前无库存实际数量，可能存在尚未退料的记录，当前不能出库。';
              Else
                v_Error := '第 ' || n_序号 || ' 行药品"' || v_名称 || '"当前无库存实际数量，可能存在尚未退药的记录，当前不能出库。';
              End If;
            Else
              If v_收费类别 = '4' Then
                v_Error := '在处理病人"' || v_姓名 || '"时发现卫生材料"' || v_名称 || '"当前无库存实际数量，可能存在尚未退料的记录，当前不能出库。';
              Else
                v_Error := '在处理病人"' || v_姓名 || '"时发现药品"' || v_名称 || '"当前无库存实际数量，可能存在尚未退药的记录，当前不能出库。';
              End If;
            End If;
            Raise Err_Custom;
          End If;
        End If;
      
        If n_分批 = 1 Or n_时价 = 1 Then
          --对于不分批的时价只可能分解一次,分解不完上面判断了.它分解是为了计算单价.
          --每次分解取小者,库存不够分解不完在上面判断.
          If n_总出库数量 <= Nvl(r_Stock.可用数量, 0) Then
            n_当前数量 := n_总出库数量;
          Else
            n_当前数量 := Nvl(r_Stock.可用数量, 0);
          End If;
          If n_时价 = 1 Then
            n_当前单价 := Nvl(r_Stock.零售价, Nvl(r_Stock.实际金额 / r_Stock.实际数量, 0));
          Elsif n_分批 = 1 Then
            n_当前单价 := n_定价售价;
          End If;
        Else
          --定价不分批
          --非门诊单据且是高值卫材需要检查库存
          If n_单据 <> 8 Or n_单据 <> 24 Then
            If Nvl(备货材料_In, 0) = 1 And v_收费类别 = '4' Then
              If n_总出库数量 > Nvl(r_Stock.可用数量, 0) Then
                --不分批, 但又是备货卫材方式出库的,则需要检查当前库存是否充足.
                v_Error := '第 ' || n_序号 || ' 行的卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
                Raise Err_Custom;
              End If;
            End If;
          End If;
          n_当前数量 := n_总出库数量;
          n_当前单价 := n_定价售价;
        End If;
      
        --药品收发记录
        If c_Stock%Found Then
          --卫材灭菌效期:一次性材料且有效期
          If v_收费类别 = '4' Then
            n_Count := 0;
            Begin
              Select 灭菌效期 Into n_Count From 材料特性 Where Nvl(一次性材料, 0) = 1 And 材料id = n_收费细目id;
            Exception
              When Others Then
                Null;
            End;
            If Nvl(n_Count, 0) > 0 Then
              d_灭菌效期 := r_Stock.灭菌效期;
              d_灭菌日期 := d_灭菌效期 - n_Count * 30;
            End If;
          End If;
        End If;
      
        Select Nvl(Max(序号), 0) + 1 Into n_序号 From 药品收发记录 Where 单据 = n_单据 And 记录状态 = 1 And NO = v_No;
      
        n_扣率 := Null;
        If 期效_In Is Not Null Or 计价特性_In Is Not Null Then
          n_扣率 := Nvl(期效_In, 0) || Nvl(计价特性_In, 0);
        End If;
      
        --分批药品,如果是只使用了一个批次,则要填写付数
        If n_分批 = 1 And n_当前数量 <> n_总数量 Then
          n_Count := 1;
        Else
          n_Count := 0;
        End If;
      
        Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
        --修改的原单据号存放在摘要中
        Insert Into 药品收发记录
          (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人,
           填制日期, 费用id, 频次, 发药窗口, 单量, 用法, 外观, 扣率, 灭菌效期, 灭菌日期, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码, 原产地)
        Values
          (n_收发id, 1, n_单据, v_No, n_序号, n_发药库房id, n_对方部门id, n_类别, -1, n_收费细目id, Nvl(r_Stock.批次, 0), r_Stock.上次产地,
           r_Stock.上次批号, r_Stock.效期, Decode(n_Count, 1, 1, n_付数), Decode(n_Count, 1, n_当前数量, n_当前数量 / n_付数),
           Decode(n_Count, 1, n_当前数量, n_当前数量 / n_付数), n_当前单价, Round(n_当前单价 * n_当前数量, n_流通金额小数), 药品摘要_In, v_操作员, d_登记时间,
           Id_In, 频次_In, v_发药窗口, 单量_In, 用法_In, 煎法_In, n_扣率, d_灭菌效期, d_灭菌日期, r_Stock.上次供应商id, r_Stock.上次生产日期,
           r_Stock.批准文号, r_Stock.商品条码, r_Stock.内部条码, r_Stock.原产地);
      
        Zl_未审药品记录_Insert(n_收发id);
      
        --药品库存(普通情况可能没有记录)
        Zl_药品库存_Update(n_收发id, 0, 1);
      
        --产生其他出库单 ，只有高值卫材才需要处理
        If v_收费类别 = '4' And Nvl(备货材料_In, 0) = 1 Then
          Begin
            Select Max(a.No), Max(a.序号)
            Into v_其他出库no, n_出库序号
            From 药品收发记录 A, 住院费用记录 B
            Where a.费用id = b.Id And b.No = v_No And 记录性质 = 2 And b.门诊标志 = n_门诊标志 And
                  Instr(',8,9,10,21,24,25,26,', ',' || a.单据 || ',') > 0;
          Exception
            When Others Then
              v_其他出库no := Null;
          End;
          If v_其他出库no Is Null Then
            v_其他出库no := Nextno(74, n_虚拟库房id, Null, 1);
          End If;
          If v_其他出库no Is Null Then
            v_Error := '在生成卫生材料的其他出库单时,获取相关的出库NO有误,请检查出库单的规则是否有误!';
            Raise Err_Custom;
          End If;
          If Nvl(n_病人科室id, 0) <> 0 Then
            Select 名称 Into v_部门名称 From 部门表 Where ID = n_病人科室id;
          End If;
          v_Error := LPad(' ', 4);
          v_Error := Substr('病人姓名:' || v_姓名 || v_Error || '性别:' || v_性别 || v_Error || '年龄' || n_年龄 || v_Error || '门诊号:' ||
                            Nvl(n_标识号, '') || v_Error || '病人科室:' || v_部门名称, 1, 100);
        
          n_出库序号 := Nvl(n_出库序号, 0) + 1;
          Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
        
          --高值卫材类别id默认19是为了方便统计，因为其他出库可以设置很多类别，所以默认19
          Insert Into 药品收发记录
            (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人,
             填制日期, 费用id, 频次, 发药窗口, 单量, 用法, 外观, 扣率, 灭菌效期, 灭菌日期, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码, 原产地)
          Values
            (n_收发id, 1, 21, v_其他出库no, n_出库序号, n_虚拟库房id, n_对方部门id, 19, -1, n_收费细目id, Nvl(r_Stock.批次, 0), r_Stock.上次产地,
             r_Stock.上次批号, r_Stock.效期, 1, n_当前数量, n_当前数量, n_当前单价, Round(n_当前单价 * n_当前数量, n_流通金额小数), v_Error, v_操作员,
             d_登记时间, Id_In, 频次_In, v_发药窗口, 单量_In, 用法_In, 煎法_In, n_扣率, d_灭菌效期, d_灭菌日期, r_Stock.上次供应商id, r_Stock.上次生产日期,
             r_Stock.批准文号, r_Stock.商品条码, r_Stock.内部条码, r_Stock.原产地);
        
          Zl_未审药品记录_Insert(n_收发id);
        
          --药品库存(普通情况可能没有记录)
          Zl_药品库存_Update(n_收发id, 0, 1);
        End If;
      
        v_Error      := '';
        n_总出库数量 := n_总出库数量 - n_当前数量;
        n_总金额     := n_总金额 + n_当前数量 * n_当前单价;
      End Loop;
    
      --未发药品记录
      Update 未发药品记录
      Set 病人id = n_病人id, 姓名 = v_姓名, 发药窗口 = v_发药窗口, 主页id = 主页id_In
      Where 单据 = n_单据 And NO = v_No And Nvl(库房id, 0) = Nvl(n_发药库房id, 0);
      If Sql%RowCount = 0 Then
        --取身份优先级
        Begin
          Select b.优先级 Into n_优先级 From 病人信息 A, 身份 B Where a.身份 = b.名称(+) And a.病人id = n_病人id;
        Exception
          When Others Then
            Null;
        End;
        Insert Into 未发药品记录
          (单据, NO, 病人id, 主页id, 姓名, 优先级, 库房id, 对方部门id, 填制日期, 已收费, 打印状态, 发药窗口)
        Values
          (n_单据, v_No, n_病人id, 主页id_In, v_姓名, n_优先级, n_发药库房id, n_对方部门id, d_登记时间, n_记录状态, 0, v_发药窗口);
      End If;
    
      --处理未发药记录状态
      Zl_Prescription_Type_Update(v_No, n_记录性质, n_收费细目id, v_收费类别);
    
      Close c_Stock;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_销售出库;
/

--118679:李业庆,2017-12-19,住院记帐药品业务封装
Create Or Replace Procedure Zl_住院记帐记录_Insert
(
  No_In             住院费用记录.No%Type,
  序号_In           住院费用记录.序号%Type,
  病人id_In         住院费用记录.病人id%Type,
  主页id_In         住院费用记录.主页id%Type,
  标识号_In         住院费用记录.标识号%Type,
  姓名_In           住院费用记录.姓名%Type,
  性别_In           住院费用记录.性别%Type,
  年龄_In           住院费用记录.年龄%Type,
  床号_In           住院费用记录.床号%Type,
  费别_In           住院费用记录.费别%Type,
  病区id_In         住院费用记录.病人病区id%Type,
  科室id_In         住院费用记录.病人科室id%Type,
  加班标志_In       住院费用记录.加班标志%Type,
  婴儿费_In         住院费用记录.婴儿费%Type,
  开单部门id_In     住院费用记录.开单部门id%Type,
  开单人_In         住院费用记录.开单人%Type,
  从属父号_In       住院费用记录.从属父号%Type,
  收费细目id_In     住院费用记录.收费细目id%Type,
  收费类别_In       住院费用记录.收费类别%Type,
  计算单位_In       住院费用记录.计算单位%Type,
  保险项目否_In     住院费用记录.保险项目否%Type,
  保险大类id_In     住院费用记录.保险大类id%Type,
  保险编码_In       住院费用记录.保险编码%Type,
  付数_In           住院费用记录.付数%Type,
  数次_In           住院费用记录.数次%Type,
  附加标志_In       住院费用记录.附加标志%Type,
  执行部门id_In     住院费用记录.执行部门id%Type,
  价格父号_In       住院费用记录.价格父号%Type,
  收入项目id_In     住院费用记录.收入项目id%Type,
  收据费目_In       住院费用记录.收据费目%Type,
  标准单价_In       住院费用记录.标准单价%Type,
  应收金额_In       住院费用记录.应收金额%Type,
  实收金额_In       住院费用记录.实收金额%Type,
  统筹金额_In       住院费用记录.统筹金额%Type,
  发生时间_In       住院费用记录.发生时间%Type,
  登记时间_In       住院费用记录.登记时间%Type,
  药品摘要_In       药品收发记录.摘要%Type,
  划价_In           Number,
  操作员编号_In     住院费用记录.操作员编号%Type,
  操作员姓名_In     住院费用记录.操作员姓名%Type,
  多病人单_In       Number := 0,
  类别id_In         药品单据性质.类别id%Type := Null,
  记帐单id_In       住院费用记录.记帐单id%Type := Null,
  费用摘要_In       住院费用记录.摘要%Type := Null,
  是否急诊_In       住院费用记录.是否急诊%Type := 0,
  医嘱序号_In       住院费用记录.医嘱序号%Type := Null,
  频次_In           药品收发记录.频次%Type := Null,
  单量_In           药品收发记录.单量%Type := Null,
  用法_In           药品收发记录.用法%Type := Null, --用法[|煎法]
  期效_In           药品收发记录.扣率%Type := Null,
  计价特性_In       药品收发记录.扣率%Type := Null,
  简单记帐_In       Number := 0,
  费用类型_In       住院费用记录.费用类型%Type := Null,
  医技补临床费用_In Number := 0,
  领药部门id_In     药品收发记录.对方部门id%Type := Null,
  中药形态_In       住院费用记录.结论%Type := Null,
  医疗小组id_In     住院费用记录.医疗小组id%Type := -1,
  备货材料_In       Number := 0,
  批次_In           药品收发记录.批次%Type := Null
) As
  --功能：新收一张住院记帐单据
  --参数：
  --   药品摘要_IN:存放医嘱中的附加说明或修改保存新单据时用。目前仅用于存放于药品收发记录的摘要中。
  --         原单据(记录状态=2)记录修改产生的新单据号。
  --         新单据(记录状态=1)记录所修改的原单据号。
  --   划价-是否属于住院划价。
  --   医技补临床费用_in:医技站补费时,如果开单科室为临床科室则划价人和记帐人填写为不同,用于销帐申请时区分填写审核科室
  --   备货材料_IN: 医技站的卫生材料备货处理方式:0-正常记帐单;1-备货材料记帐
  --   批次_In:当备货材料_IN=1时有效.传入指定的卫生材料的批次
  v_费用id 住院费用记录.Id%Type;
  n_当前数量 Number;
  n_领药部门id 药品收发记录.对方部门id%Type;
  v_用法       药品收发记录.用法%Type;
  v_煎法       药品收发记录.外观%Type;
  n_医疗小组id 住院费用记录.医疗小组id%Type;
  v_Err_Msg    Varchar2(255);
  Err_Item Exception;
  n_审核标志       病案主页.审核标志%Type;
  n_住院状态       病案主页.状态%Type;
  n_病人审核方式   Number(2);
  n_未入科禁止记账 Number(2);
  v_操作员编号     人员表.编号%Type;
  v_操作员姓名     人员表.姓名%Type;
  v_Temp           Varchar2(255);
Begin
  v_操作员编号 := 操作员编号_In;
  v_操作员姓名 := 操作员姓名_In;
  If v_操作员编号 Is Null Then
    v_Temp := Zl_Identity(1);
    If Not (Nvl(v_Temp, '0') = '0' Or Nvl(v_Temp, '_') = '_') Then
      v_Temp       := Substr(v_Temp, Instr(v_Temp, ';') + 1);
      v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
      v_操作员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
      v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
      v_操作员姓名 := v_Temp;
    End If;
  End If;
  
  If Nvl(多病人单_In, 0) = 1 Or Nvl(序号_In, 0) = 1 Then
    --记帐表,全部检查,如果是记帐单只检查第一条,其他不检查
  
    n_病人审核方式   := Nvl(zl_GetSysParameter(185), 0);
    n_未入科禁止记账 := Nvl(zl_GetSysParameter(215), 0);
    If n_病人审核方式 = 1 Or n_未入科禁止记账 = 1 Then
      Begin
        Select 审核标志, 状态
        Into n_审核标志, n_住院状态
        From 病案主页
        Where 病人id = Nvl(病人id_In, 0) And 主页id = Nvl(主页id_In, 0);
      Exception
        When Others Then
          n_审核标志 := 0;
          n_住院状态 := 0;
      End;
      If n_未入科禁止记账 = 1 And n_住院状态 = 1 Then
        v_Err_Msg := '病人未入科,禁止对病人相关费用的操作!';
        Raise Err_Item;
      End If;
    
      If n_病人审核方式 = 1 Then
      
        If Nvl(n_审核标志, 0) = 1 Then
          v_Err_Msg := '该病人目前正在审核费用,不能进行费用相关调整!';
          Raise Err_Item;
        End If;
        If Nvl(n_审核标志, 0) = 2 Then
          v_Err_Msg := '该病人目前已经完成了费用审核,不能进行费用相关调整!';
          Raise Err_Item;
        End If;
      End If;
    End If;
  End If;
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --领药部门确认规则:
  -- 1.传入 :领药部门ID_IN,直接以传入的为准
  -- 2.领药部门ID_IN=NULL的情况, 如果”开单科室=病人科室”，则填为”病人病区”，如果”开单科室<>病人科室”，则填写为”开单科室”
  If Nvl(领药部门id_In, 0) = 0 Then
    If Nvl(科室id_In, 0) = Nvl(开单部门id_In, 0) Then
      --如果”开单科室=病人科室”，则填为”病人病区”(如果没有入科,即病匹为空这种情况,则以病人科室为准,由于一般这种情况较少(护土开单),因此,这种情况应该不会存在)
      n_领药部门id := Nvl(病区id_In, 0);
      If Nvl(n_领药部门id, 0) = 0 Then
        n_领药部门id := 科室id_In;
      End If;
    Else
      --如果”开单科室<>病人科室”，则填写为”开单科室”
      n_领药部门id := 开单部门id_In;
    End If;
  Else
    n_领药部门id := 领药部门id_In;
  End If;
  --需要检查0这种情况,回为有关联
  If Nvl(n_领药部门id, 0) = 0 Then
    n_领药部门id := Null;
  End If;
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --住院费用记录
  Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
  n_医疗小组id := 医疗小组id_In;

  If Nvl(医疗小组id_In, 0) < 0 Then
    n_医疗小组id := Zl_医疗小组_Get(开单部门id_In, 开单人_In, 病人id_In, 主页id_In, 发生时间_In);
  End If;

  Insert Into 住院费用记录
    (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id, 费别, 收费类别, 收费细目id,
     计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用, 开单部门id,
     开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 是否急诊, 医嘱序号, 结论, 医疗小组id)
  Values
    (v_费用id, 2, No_In, Decode(划价_In, 1, 0, 1), 序号_In, Decode(从属父号_In, 0, Null, 从属父号_In),
     Decode(价格父号_In, 0, Null, 价格父号_In), 多病人单_In, 2, 病人id_In, 主页id_In, Decode(标识号_In, 0, Null, 标识号_In), 姓名_In, 性别_In,
     年龄_In, 床号_In, Decode(病区id_In, 0, Null, 病区id_In), Decode(科室id_In, 0, Null, 科室id_In), 费别_In, 收费类别_In, 收费细目id_In,
     计算单位_In, 保险项目否_In, 保险大类id_In, 保险编码_In, 费用类型_In, Decode(Nvl(简单记帐_In, 0), 0, Null, 收费类别_In), 付数_In, 数次_In, 加班标志_In,
     附加标志_In, 婴儿费_In, 收入项目id_In, 收据费目_In, 标准单价_In, 应收金额_In, 实收金额_In, 统筹金额_In, 1, 开单部门id_In, 开单人_In, 发生时间_In, 登记时间_In,
     执行部门id_In, 0, Decode(划价_In, 1, v_操作员姓名, Decode(医技补临床费用_In, 1, '补临床费', Null)), Decode(划价_In, 1, Null, v_操作员编号),
     Decode(划价_In, 1, Null, v_操作员姓名), 记帐单id_In, 费用摘要_In, 是否急诊_In, 医嘱序号_In, 中药形态_In, n_医疗小组id);

  Select Max(使用限量 - Nvl(已用数量, 0))
  Into n_当前数量
  From 病人审批项目
  Where 病人id = 病人id_In And 主页id = 主页id_In And 项目id = 收费细目id_In And Nvl(使用限量, 0) <> 0;
  If 付数_In * 数次_In <= Nvl(n_当前数量, 0) Then
    Update 病人审批项目
    Set 已用数量 = Nvl(已用数量, 0) + 付数_In * 数次_In
    Where 病人id = 病人id_In And 主页id = 主页id_In And 项目id = 收费细目id_In And Nvl(使用限量, 0) <> 0;
  Elsif Not n_当前数量 Is Null Then
    v_Err_Msg := '第 ' || 序号_In || ' 行输入的数次超过了批准的可用数量' || n_当前数量 || '.'; --简化为不转换,直接以售价单位提示.
    Raise Err_Item;
  End If;

  --相关汇总表的处理
  If Nvl(划价_In, 0) = 0 Then
    --病人余额
    Update 病人余额 Set 费用余额 = Nvl(费用余额, 0) + 实收金额_In Where 病人id = 病人id_In And 类型 = 2 And 性质 = 1;
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 类型, 性质, 费用余额, 预交余额) Values (病人id_In, 2, 1, 实收金额_In, 0);
    End If;
  
    --病人未结费用
    Update 病人未结费用
    Set 金额 = Nvl(金额, 0) + 实收金额_In
    Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0) And Nvl(病人病区id, 0) = Nvl(病区id_In, 0) And
          Nvl(病人科室id, 0) = Nvl(科室id_In, 0) And Nvl(开单部门id, 0) = Nvl(开单部门id_In, 0) And
          Nvl(执行部门id, 0) = Nvl(执行部门id_In, 0) And 收入项目id + 0 = 收入项目id_In And 来源途径 + 0 = 2;
    If Sql%RowCount = 0 Then
      Insert Into 病人未结费用
        (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
      Values
        (病人id_In, 主页id_In, 病区id_In, 科室id_In, 开单部门id_In, 执行部门id_In, 收入项目id_In, 2, 实收金额_In);
    End If;
  End If;

  --药品和卫生材料部分
  If 收费类别_In In ('4', '5', '6', '7') Then
    --药品用法煎法分解
    If 用法_In Is Not Null Then
      If Instr(用法_In, '|') > 0 Then
        v_用法 := Substr(用法_In, 1, Instr(用法_In, '|') - 1);
        v_煎法 := Substr(用法_In, Instr(用法_In, '|') + 1);
      Else
        v_用法 := 用法_In;
      End If;
    End If;
    Zl_药品收发记录_销售出库(v_费用id, 药品摘要_In, 频次_In, 单量_In, v_用法, v_煎法, 期效_In, 计价特性_In, 主页id_In, 备货材料_In, 批次_In, n_领药部门id);
  End If;

  b_Message.Zlhis_Charge_007(收费类别_In, v_费用id);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_住院记帐记录_Insert;
/

--118748:李业庆,2017-12-20,退药，销帐消息锚点修改
--118679:李业庆,2017-12-19,住院记帐药品业务封装
Create Or Replace Procedure Zl_住院记帐记录_Delete
(
  No_In           住院费用记录.No%Type,
  序号_In         Varchar2,
  操作员编号_In   住院费用记录.操作员编号%Type,
  操作员姓名_In   住院费用记录.操作员姓名%Type,
  记录性质_In     住院费用记录.记录性质%Type := 2,
  操作状态_In     Number := 0,
  输液配药检查_In Number := 1,
  登记时间_In     住院费用记录.登记时间%Type := Sysdate
) As
  --功能：冲销一张住院记帐单据中指定序号行
  --序号：格式如"1,3,5,7,8",或"1:2:33456,3:2,5:2,7:2,8:2",冒号前面的数字表示行号,中间的数字表示退的数量,后面的数字表示配药记录的ID,目前仅在销帐审核时才传入
  --      为空表示冲销所有可冲销行
  --记录性质:    2-人工记帐单,3-自动记帐单
  --输液配药检查:    0-医嘱调用，不检查药品是否进入输液配药中心；1-非医嘱调用，检查药品是否进入配药中心
  --该光标用于销帐指定费用行
  --操作状态_In:0-表示直接销帐;1-表示审核销帐(通过销帐申请-->销帐审核流程);2-表示转病区费用
  --该游标为要退费单据的所有原始记录
  Cursor c_Bill Is
    Select a.Id, a.价格父号, a.序号, a.执行状态, a.记录性质, a.收费类别, a.医嘱序号, a.收费细目id, a.病人id, a.主页id, a.收入项目id, a.开单部门id, a.病人科室id,
           a.执行部门id, a.病人病区id, a.付数, a.数次, m.跟踪在用
    From 住院费用记录 A, 材料特性 M
    Where a.No = No_In And a.记录性质 = 记录性质_In And a.记录状态 In (0, 1, 3) And a.门诊标志 = 2 And a.收费细目id + 0 = m.材料id(+)
    Order By 收费细目id, 序号;

  --该游标用于处理药品库存可用数量
  --不要管费用的执行状态,因为先于此步处理
  Cursor c_Stock(v_序号_In Varchar2) Is
    Select ID, 单据, NO, 库房id, 药品id, 批次, 发药方式, 付数, 实际数量, 灭菌效期, 效期, 产地, 批号, 填制日期, 费用id, 商品条码, 内部条码
    From 药品收发记录
    Where NO = No_In And 单据 In (9, 10, 25, 26) And Mod(记录状态, 3) = 1 And 审核人 Is Null And
          费用id In (Select ID
                   From 住院费用记录
                   Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 In (0, 1, 3) And 收费类别 In ('4', '5', '6', '7') And
                         门诊标志 = 2 And (Instr(',' || v_序号_In || ',', ',' || 序号 || ',') > 0 Or v_序号_In Is Null))
    Order By 药品id, 填制日期 Desc;

  r_Stock c_Stock%RowType;

  --该游标用于处理费用记录序号
  Cursor c_Serial Is
    Select 序号, 价格父号
    From 住院费用记录
    Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 In (0, 1, 3)
    Order By 序号;

  v_医嘱id 病人医嘱记录.Id%Type;
  n_划价   Number;
  v_父号   住院费用记录.价格父号%Type;
  v_序号   Varchar2(2000);
  v_Tmp    Varchar2(4000);

  v_医嘱ids Varchar2(4000);
  l_划价    t_Numlist := t_Numlist();
  n_付数    Number;
  n_返回值  Number;
  --部分退费计算变量
  v_剩余数量 Number;
  v_剩余应收 Number;
  v_剩余实收 Number;
  v_剩余统筹 Number;

  v_准退数量 Number;
  v_退费次数 Number;
  v_应收金额 Number;
  v_实收金额 Number;
  v_统筹金额 Number;
  n_部分销帐 Number;
  v_Dec      Number;
  n_Count    Number;
  v_Curdate  Date;
  Err_Item Exception;
  v_Err_Msg        Varchar2(255);
  n_病人id         病案主页.病人id%Type;
  n_主页id         病案主页.主页id%Type;
  n_审核标志       病案主页.审核标志%Type;
  n_住院状态       病案主页.状态%Type;
  n_病人审核方式   Number(2);
  n_未入科禁止记账 Number(2);
  v_配药id         Varchar2(4000);

  n_未执行数量 药品收发记录.实际数量%Type;
  n_已执行数量 药品收发记录.实际数量%Type;
Begin
  --销帐审核时,非药品会传入行号的销帐数量
  If Not 序号_In Is Null Then
    If Instr(序号_In, ':') > 0 Then
      v_Tmp := 序号_In || ',';
      While Not v_Tmp Is Null Loop
        v_序号 := v_序号 || ',' || Substr(v_Tmp, 1, Instr(v_Tmp, ':') - 1);
        If Instr(Substr(v_Tmp, Instr(v_Tmp, ':') + 1, Instr(v_Tmp, ',') - Instr(v_Tmp, ':') - 1), ':') > 0 Then
          v_配药id := v_配药id || ',' ||
                    Substr(v_Tmp, Instr(v_Tmp, ':', 1, 2) + 1, Instr(v_Tmp, ',') - Instr(v_Tmp, ':', 1, 2) - 1);
        End If;
        v_Tmp := Substr(v_Tmp, Instr(v_Tmp, ',') + 1);
      End Loop;
      v_序号 := Substr(v_序号, 2);
      If v_配药id Is Not Null Then
        v_配药id := Substr(v_配药id, 2);
      End If;
    Else
      v_序号 := 序号_In;
    End If;
  End If;

  --是否已经全部完全执行(只是整张单据的检查)
  Select Nvl(Count(*), 0), Nvl(Max(病人id), 0), Nvl(Max(主页id), 0)
  Into n_Count, n_病人id, n_主页id
  From 住院费用记录
  Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 In (0, 1, 3) And Nvl(执行状态, 0) <> 1 And 门诊标志 = 2;
  If n_Count = 0 Then
    v_Err_Msg := '该单据中的项目已经全部完全执行！';
    Raise Err_Item;
  End If;

  n_病人审核方式   := Nvl(zl_GetSysParameter(185), 0);
  n_未入科禁止记账 := Nvl(zl_GetSysParameter(215), 0);
  If n_病人审核方式 = 1 Or n_未入科禁止记账 = 1 Then
  
    Begin
      Select 审核标志, 状态 Into n_审核标志, n_住院状态 From 病案主页 Where 病人id = n_病人id And 主页id = n_主页id;
    Exception
      When Others Then
        n_审核标志 := 0;
        n_住院状态 := 0;
    End;
    If n_未入科禁止记账 = 1 And n_住院状态 = 1 Then
      v_Err_Msg := '病人未入科,禁止对病人相关费用的操作!';
      Raise Err_Item;
    End If;
  
    If n_病人审核方式 = 1 Then
    
      If Nvl(n_审核标志, 0) = 1 Then
        v_Err_Msg := '该病人目前正在审核费用,不能进行费用相关调整!';
        Raise Err_Item;
      End If;
      If Nvl(n_审核标志, 0) = 2 Then
        v_Err_Msg := '该病人目前已经完成了费用审核,不能进行费用相关调整!';
        Raise Err_Item;
      End If;
    End If;
  End If;

  --未完全执行的项目是否有剩余数量(只是整张单据的检查)
  Select Nvl(Count(*), 0)
  Into n_Count
  From (Select 序号, Sum(数量) As 剩余数量
         From (Select 记录状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                From 住院费用记录
                Where NO = No_In And 记录性质 = 记录性质_In And 门诊标志 = 2 And
                      Nvl(价格父号, 序号) In
                      (Select Nvl(价格父号, 序号)
                       From 住院费用记录
                       Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 In (0, 1, 3) And Nvl(执行状态, 0) <> 1)
                Group By 记录状态, Nvl(价格父号, 序号))
         Group By 序号
         Having Sum(数量) <> 0);
  If n_Count = 0 Then
    v_Err_Msg := '该单据中未完全执行部分项目剩余数量为零,没有可以销帐的费用！';
    Raise Err_Item;
  End If;

  --医嘱费用：检查正在执行的医嘱(注意已执行的情况在下面检查,因为不传 序号_IN 这种情况费用界面已限制)
  If Nvl(操作状态_In, 0) = 0 Then
    --走销帐申请流程的，不检查医保执行状态
    Select Nvl(Count(*), 0)
    Into n_Count
    From 病人医嘱发送
    Where 执行状态 = 3 And (NO, 记录性质, 医嘱id) In
          (Select NO, 记录性质, 医嘱序号
                        From 住院费用记录
                        Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 In (0, 1, 3) And 医嘱序号 Is Not Null And
                              (Instr(',' || v_序号 || ',', ',' || 序号 || ',') > 0 Or v_序号 Is Null));
    If n_Count > 0 Then
      v_Err_Msg := '要销帐的费用中存在对应的医嘱正在执行的情况，不能销帐！';
      Raise Err_Item;
    End If;
  End If;

  ---------------------------------------------------------------------------------
  --先打开药品对应数据集,以确保当前条件下有数据,为了处理并发判断
  --不能在游标条件中取消"审核人 is Null"条件，因为多次退药可能部份又已发
  Open c_Stock(v_序号);

  --公用变量
  Select 登记时间_In Into v_Curdate From Dual;

  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into v_Dec From Dual;

  For c_编目病案 In (Select a.姓名
                 From 病人信息 A, 病案主页 B
                 Where a.病人id = b.病人id And b.编目日期 Is Not Null And
                       (b.病人id, b.主页id) In
                       (Select Distinct 病人id, 主页id
                        From 住院费用记录
                        Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 In (0, 1, 3) And 门诊标志 = 2)) Loop
    v_Err_Msg := '病人『' || c_编目病案.姓名 || '』 已经被病案编目,不能被销帐！';
    Raise Err_Item;
  End Loop;
  v_医嘱ids := Null;
  --循环处理每行费用(收入项目行)
  For r_Bill In c_Bill Loop
    --检查已经存在病案编目的,则不能进行销帐处理
    If Instr(',' || v_序号 || ',', ',' || Nvl(r_Bill.价格父号, r_Bill.序号) || ',') > 0 Or v_序号 Is Null Then
      Select Decode(记录状态, 0, 1, 0) Into n_划价 From 住院费用记录 Where ID = r_Bill.Id;
      If Nvl(r_Bill.执行状态, 0) <> 1 Then
        --求剩余数量,剩余应收,剩余实收
        Select Sum(Nvl(付数, 1) * 数次), Sum(应收金额), Sum(实收金额), Sum(统筹金额)
        Into v_剩余数量, v_剩余应收, v_剩余实收, v_剩余统筹
        From 住院费用记录
        Where NO = No_In And 记录性质 = 记录性质_In And 序号 = r_Bill.序号;
        n_部分销帐 := 0;
        If v_剩余数量 = 0 Then
          If v_序号 Is Not Null Then
            v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经全部销帐！';
            Raise Err_Item;
          End If;
          --情况：未限定行号,原始单据中的该笔已经全部销帐(执行状态=0的一种可能)
        Else
        
          If Instr(序号_In, ':') > 0 Then
            v_Tmp := ',' || 序号_In;
            v_Tmp := Substr(v_Tmp, Instr(v_Tmp, ',' || r_Bill.序号 || ':') + Length(',' || r_Bill.序号 || ':'));
            v_Tmp := Substr(v_Tmp, 1, Instr(v_Tmp || ',', ',') - 1);
            If Instr(v_Tmp, ':') > 0 Then
              v_Tmp := Substr(v_Tmp, 1, Instr(v_Tmp, ':') - 1);
            End If;
            v_准退数量 := v_Tmp;
            n_部分销帐 := 1;
          End If;
        
          --准销数量(非药品项目为剩余数量,原始数量)
          If Instr(',4,5,6,7,', r_Bill.收费类别) = 0 Then
            If Instr(序号_In, ':') = 0 Or 序号_In Is Null Then
              v_准退数量 := v_剩余数量;
            End If;
          Else
            --医嘱超期收回时,卫材可能没有发放,但申请销帐的是部分数量,所以要以申请的为准
            If Instr(序号_In, ':') = 0 Or 序号_In Is Null Then
              Select Nvl(Sum(Nvl(付数, 1) * 实际数量), 0), Count(*)
              Into v_准退数量, n_Count
              From 药品收发记录
              Where NO = No_In And 单据 In (9, 10, 25, 26) And Mod(记录状态, 3) = 1 And 审核人 Is Null And 费用id = r_Bill.Id;
            End If;
          
            --有剩余数量无准退数量的有两种情况：
            --1.不跟踪在用的卫材无对应的收发记录,这时使用剩余数量
            --2.并发操作,此时已发药或发料
            If v_准退数量 = 0 Then
              If r_Bill.收费类别 = '4' Then
                If n_Count > 0 Or Nvl(r_Bill.跟踪在用, 0) = 1 Then
                  v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发料,须退料后再退费！';
                  Raise Err_Item;
                Else
                  v_准退数量 := v_剩余数量;
                End If;
              Else
                v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发药,须退药后再退费！';
                Raise Err_Item;
              End If;
            End If;
          End If;
        
          --处理住院费用记录
          If Nvl(n_划价, 0) = 0 Then
            --划价时,直接更改数量,所以不须查划冲销次数
            --该笔项目第几次销帐
            Select Nvl(Max(Abs(执行状态)), 0) + 1
            Into v_退费次数
            From 住院费用记录
            Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 = 2 And 序号 = r_Bill.序号 And 门诊标志 = 2;
          End If;
        
          --金额=剩余金额*(准退数/剩余数)
          v_应收金额 := Round(v_剩余应收 * (v_准退数量 / v_剩余数量), v_Dec);
          v_实收金额 := Round(v_剩余实收 * (v_准退数量 / v_剩余数量), v_Dec);
          v_统筹金额 := Round(v_剩余统筹 * (v_准退数量 / v_剩余数量), v_Dec);
          If Nvl(n_划价, 0) = 1 Then
            If Nvl(n_部分销帐, 0) = 0 Then
              l_划价.Extend;
              l_划价(l_划价.Count) := r_Bill.Id;
              n_返回值 := 0;
            Else
              --更新数量
              --划价的,先将相关的数据处理在内部表集中
              n_付数 := 0;
              If r_Bill.付数 > 1 Then
                --如果是中药,超期回收肯定是回收的付数,而不是次数.因此,需要检查准退数量是否可以整 除
                If Trunc(v_准退数量 / r_Bill.数次) <> (v_准退数量 / r_Bill.数次) Then
                  v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用为中药,请按付数进行退费！';
                  Raise Err_Item;
                End If;
                n_付数 := Trunc(v_准退数量 / r_Bill.数次);
                If Nvl(r_Bill.付数, 0) - n_付数 < 0 Then
                  v_准退数量 := r_Bill.数次;
                Else
                  v_准退数量 := 0;
                End If;
              End If;
              Update 住院费用记录
              Set 付数 = 付数 - n_付数, 数次 = 数次 - v_准退数量, 应收金额 = Nvl(应收金额, 0) - v_应收金额, 实收金额 = Nvl(实收金额, 0) - v_实收金额,
                  登记时间 = v_Curdate, 统筹金额 = Nvl(统筹金额, 0) - v_统筹金额
              Where ID = r_Bill.Id
              Returning Nvl(数次, 0) * Nvl(付数, 0) Into n_返回值;
            End If;
            If Nvl(n_返回值, 0) <= 0 Then
              l_划价.Extend;
              l_划价(l_划价.Count) := r_Bill.Id;
            End If;
            If r_Bill.医嘱序号 Is Not Null Then
              If Instr(',' || Nvl(v_医嘱ids, '') || ',', ',' || r_Bill.医嘱序号 || ',') = 0 Then
                v_医嘱ids := Nvl(v_医嘱ids, '') || ',' || r_Bill.医嘱序号;
              End If;
              --记录病人医嘱附费对应的医嘱ID(不是主费用)
              If v_医嘱id Is Null Then
                v_医嘱id := r_Bill.医嘱序号;
              End If;
            End If;
          
          End If;
        
          If Nvl(n_划价, 0) = 0 Then
            --划价时,直接更改数量,所以不须查划冲销次数
            --插入退费记录
            Insert Into 住院费用记录
              (ID, NO, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 主页id, 病人id, 医嘱序号, 门诊标志, 多病人单, 婴儿费, 姓名, 性别, 年龄, 标识号, 床号, 费别, 病人病区id,
               病人科室id, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人,
               执行部门id, 划价人, 执行人, 执行状态, 执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 保险项目否, 保险大类id, 统筹金额, 保险编码, 记帐单id, 摘要, 费用类型, 是否急诊,
               结论, 医疗小组id)
              Select 病人费用记录_Id.Nextval, NO, 记录性质, 2, 序号, 从属父号, 价格父号, 主页id, 病人id, 医嘱序号, 门诊标志, 多病人单, 婴儿费, 姓名, 性别, 年龄, 标识号,
                     床号, 费别, 病人病区id, 病人科室id, 收费类别, 收费细目id, 计算单位, Decode(Sign(v_准退数量 - Nvl(付数, 1) * 数次), 0, 付数, 1), 发药窗口,
                     Decode(Sign(v_准退数量 - Nvl(付数, 1) * 数次), 0, -1 * 数次, -1 * v_准退数量), 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用,
                     标准单价, -1 * v_应收金额, -1 * v_实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, -1 * v_退费次数, 执行时间, 操作员编号_In,
                     操作员姓名_In, 发生时间, v_Curdate, 保险项目否, 保险大类id, -1 * v_统筹金额, 保险编码, 记帐单id, 摘要, 费用类型, 是否急诊, 结论, 医疗小组id
              From 住院费用记录
              Where ID = r_Bill.Id;
          
            --记录病人医嘱附费对应的医嘱ID(不是主费用)
            If v_医嘱id Is Null And r_Bill.医嘱序号 Is Not Null Then
              v_医嘱id := r_Bill.医嘱序号;
            End If;
          
            Update 病人审批项目
            Set 已用数量 = Nvl(已用数量, 0) - v_准退数量
            Where 病人id = r_Bill.病人id And 主页id = r_Bill.主页id And 项目id = r_Bill.收费细目id And Nvl(使用限量, 0) <> 0;
          
            --病人余额
            Update 病人余额
            Set 费用余额 = Nvl(费用余额, 0) - v_实收金额
            Where 病人id = r_Bill.病人id And 类型 = 2 And 性质 = 1;
            If Sql%RowCount = 0 Then
              Insert Into 病人余额
                (病人id, 类型, 性质, 费用余额, 预交余额)
              Values
                (r_Bill.病人id, 2, 1, -1 * v_实收金额, 0);
            End If;
          
            --病人未结费用
            Update 病人未结费用
            Set 金额 = Nvl(金额, 0) - v_实收金额
            Where 病人id = r_Bill.病人id And Nvl(主页id, 0) = Nvl(r_Bill.主页id, 0) And Nvl(病人病区id, 0) = Nvl(r_Bill.病人病区id, 0) And
                  Nvl(病人科室id, 0) = Nvl(r_Bill.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(r_Bill.开单部门id, 0) And
                  Nvl(执行部门id, 0) = Nvl(r_Bill.执行部门id, 0) And 收入项目id + 0 = r_Bill.收入项目id And 来源途径 + 0 = 2;
            If Sql%RowCount = 0 Then
              Insert Into 病人未结费用
                (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
              Values
                (r_Bill.病人id, r_Bill.主页id, r_Bill.病人病区id, r_Bill.病人科室id, r_Bill.开单部门id, r_Bill.执行部门id, r_Bill.收入项目id, 2,
                 -1 * v_实收金额);
            End If;
          
            --标记原费用记录
            --执行状态:全部退完(准退数=剩余数)标记为0,否则保持原状态
            If Instr(',4,5,6,7,', r_Bill.收费类别) = 0 Then
              --一般情况非药品和卫材的项目,不存在部分销帐的情况,只有销帐申请和销帐审核时,才会出现部分销帐,所以
              --执行状态只有两种:0.未执行;1已执行;
              --由于在销帐审核过程中将已执行强制改为了2部分执行,因此需要在此处改为1已执行.未执行的不变.
              Update 住院费用记录
              Set 记录状态 = 3, 执行状态 = Decode(Sign(v_准退数量 - v_剩余数量), 0, 0, Decode(执行状态, 2, 1, 执行状态))
              Where ID = r_Bill.Id;
            Else
              Select Nvl(Sum(Decode(审核人, Null, 1, 0) * Nvl(付数, 1) * 实际数量), 0),
                     Nvl(Sum(Decode(审核人, Null, 0, 1) * Nvl(付数, 1) * 实际数量), 0)
              Into n_未执行数量, n_已执行数量
              From 药品收发记录
              Where NO = No_In And 单据 In (9, 10, 25, 26) And 费用id = r_Bill.Id;
            
              Update 住院费用记录
              Set 记录状态 = 3,
                  执行状态 = Decode(Sign(v_准退数量 - v_剩余数量), 0, 0,
                                 Decode(Sign(n_未执行数量 - v_准退数量), 1, Decode(n_已执行数量, 0, 0, 2), 1))
              Where ID = r_Bill.Id;
            End If;
          End If;
        End If;
      Else
        If v_序号 Is Not Null Then
          v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经完全执行,不能销帐！';
          Raise Err_Item;
        End If;
        --情况:没限定行号,原始单据中包括已经完全执行的
      End If;
    End If;
  End Loop;

  If Nvl(操作状态_In, 0) = 2 Then
    --转病区费用时:
    --1.药品及跟踪在用的卫材不会调用该过程
    --2.划价记账单也不会调用该过程
    --3.不需要更改医嘱信息
    For r_Bill In c_Bill Loop
      If Nvl(r_Bill.执行状态, 0) <> 1 Then
        b_Message.Zlhis_Charge_008(r_Bill.收费类别, r_Bill.Id);
      End If;
    End Loop;
    Return;
  End If;

  --不存在配药ID,检查该药品是否在输液配药中心
  If v_配药id Is Null And 输液配药检查_In = 1 Then
    For v_费用 In (Select ID
                 From 住院费用记录
                 Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 In (0, 1, 3) And 收费类别 In ('4', '5', '6', '7') And 门诊标志 = 2 And
                       (Instr(',' || v_序号 || ',', ',' || 序号 || ',') > 0 Or v_序号 Is Null)) Loop
      Begin
        Select Count(1)
        Into n_Count
        From 输液配药内容 A, 药品收发记录 B
        Where a.收发id = b.Id And b.费用id = v_费用.Id And Instr(',8,9,10,21,24,25,26,', ',' || b.单据 || ',') > 0;
      Exception
        When Others Then
          n_Count := 0;
      End;
      If n_Count <> 0 Then
        v_Err_Msg := '存在已经进入输液配药中心的待销帐药品，无法完成销帐！';
        Raise Err_Item;
      End If;
    End Loop;
  End If;

  ---------------------------------------------------------------------------------
  --药品相关处理:主要是对销帐审核有效.(可以是部分)
  For v_费用 In (Select ID, 序号, 收费类别
               From 住院费用记录
               Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 In (0, 1, 3) And 收费类别 In ('4', '5', '6', '7') And 门诊标志 = 2 And
                     (Instr(',' || v_序号 || ',', ',' || 序号 || ',') > 0 Or v_序号 Is Null)
               Order By 收费细目id) Loop
    --根据费用ID来进行相关的处理
    v_准退数量 := 0;
    If Instr(序号_In, ':') > 0 Then
      v_Tmp := ',' || 序号_In;
      v_Tmp := Substr(v_Tmp, Instr(v_Tmp, ',' || v_费用.序号 || ':') + Length(',' || v_费用.序号 || ':'));
      v_Tmp := Substr(v_Tmp, 1, Instr(v_Tmp || ',', ',') - 1);
      If Instr(v_Tmp, ':') > 0 Then
        v_Tmp := Substr(v_Tmp, 1, Instr(v_Tmp, ':') - 1);
      End If;
      v_准退数量 := v_Tmp;
    End If;
  
    Zl_药品收发记录_销售退费(v_费用.Id, v_准退数量, v_配药id, 1);
  End Loop;

  ---------------------------------------------------------------------------------
  --如果是划价,直接删除费用记录(药品处理后)
  n_Count := l_划价.Count;
  --删除划价记录
  Forall I In 1 .. l_划价.Count
    Delete From 住院费用记录 Where ID = l_划价(I);

  --删除之后再统一调整序号
  If n_Count > 0 Then
    n_Count := 1;
    For r_Serial In c_Serial Loop
      If r_Serial.价格父号 Is Null Then
        v_父号 := n_Count;
      End If;
    
      Update 住院费用记录
      Set 序号 = n_Count, 价格父号 = Decode(价格父号, Null, Null, v_父号)
      Where NO = No_In And 记录性质 = 记录性质_In And 序号 = r_Serial.序号;
    
      Update 住院费用记录
      Set 从属父号 = n_Count
      Where NO = No_In And 记录性质 = 记录性质_In And 从属父号 = r_Serial.序号;
    
      n_Count := n_Count + 1;
    End Loop;
  
  End If;
  --整张单据全部冲完时，删除病人医嘱附费
  For c_医嘱 In (Select Distinct 医嘱序号
               From 住院费用记录
               Where NO = No_In And 记录性质 = 2 And 记录状态 = 3 And 医嘱序号 Is Not Null) Loop
    Select Nvl(Count(*), 0)
    Into n_Count
    From (Select 序号, Sum(数量) As 剩余数量
           From (Select 记录状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                  From 住院费用记录
                  Where 记录性质 = 2 And 医嘱序号 + 0 = c_医嘱.医嘱序号 And NO = No_In
                  Group By 记录状态, Nvl(价格父号, 序号))
           Group By 序号
           Having Sum(数量) <> 0);
  
    If n_Count = 0 Then
      Delete From 病人医嘱附费 Where 医嘱id = c_医嘱.医嘱序号 And 记录性质 = 2 And NO = No_In;
    End If;
  End Loop;

  If v_医嘱ids Is Not Null Then
    --医嘱处理
    --场合_In    Integer:=0, --0:门诊;1-住院
    --性质_In    Integer:=1, --1-收费单;2-记帐单
    --操作_In    Integer:=0, --0:删除划价单;1-收费或记帐;2-退费或销帐
    --No_In      门诊费用记录.No%Type,
    --医嘱ids_In Varchar2 := Null
    v_医嘱ids := Substr(v_医嘱ids, 2);
    Zl_医嘱发送_计费状态_Update(1, 2, 0, No_In, v_医嘱ids);
  Else
    Zl_医嘱发送_计费状态_Update(1, 2, 2, No_In);
  End If;
  For r_Bill In c_Bill Loop
    --卫材药品类别的消息放到Zl_药品收发记录_销售退费中发送
    If Nvl(r_Bill.执行状态, 0) <> 1 And Instr(',4,5,6,7,', ',' || r_Bill.收费类别 || ',') = 0 Then
      b_Message.Zlhis_Charge_008(r_Bill.收费类别, r_Bill.Id);
    End If;
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_住院记帐记录_Delete;
/

--122096:胡俊勇,2018-02-11,输液配药医嘱超期发送收回
--118679:李业庆,2017-12-19,住院记帐药品业务封装
--118156:李业庆,2017-12-20,药品库存或收发记录批次为空处理
Create Or Replace Procedure Zl_病人医嘱记录_收回
(
  --功能：将指定医嘱超期发送部分收回。如果上次发送没有产生费用，则仅收回医嘱的上次执行时间。
  --参数：
  --      收回量_IN=对西药、中成药为按住院单位的收回量,对中药为收回付数,对其它医嘱为收回总量或次数。
  --      医嘱ID_IN=每条要收回的医嘱记录的ID(明细存储的ID),对成药或配方,不一定包含给药途径或用法煎法(可能为叮嘱而未读取)
  --      上次时间_IN=医嘱超期发送部分收回后应该还原的上次执行时间(严格按频率计算得来),为空时表示被全部收回了。
  --      NO_IN=当收回要产生负数费用记录时，为新生成记录的单据号(供费用及药品使用),当前处理的只是新NO的一部份。
  --            因为药品可能分批,所以序号在处理时取。
  --            如果全是划价单（传入值为：调整划价单），则不产生负数单据，直接修改或删除划价单
  收回量_In     In 病人医嘱发送.发送数次%Type,
  医嘱id_In     In 病人医嘱记录.Id%Type,
  上次时间_In   In 病人医嘱记录.上次执行时间%Type,
  收回时间_In   In 病人医嘱记录.上次执行时间%Type,
  No_In         In 住院费用记录.No%Type := Null,
  操作员编号_In In 人员表.编号%Type := Null,
  操作员姓名_In In 人员表.姓名%Type := Null
) Is
  --收回医嘱对应的发送费用明细的剩余数量,按后产生的费用先收回
  --剩余数量没有排开已申请的数量部份，在产生新申请时覆盖原来的申请
  --对药品和卫材，对一个数量，可能存在未执行和已执行部分，需分别填写申请记录，且以未执行优先
  --执行标志=0-未执行,1-已执行；药品的有部分执行，以收发记录中的明细量区分为准；非药品的只优先处理未执行的
  Cursor c_Detail Is
    Select a.费用id, a.No, a.序号, a.收费细目id, a.病人病区id, a.收费类别, a.跟踪在用, a.诊疗类别, a.医嘱内容, a.单次用量, a.剩余数量, a.已执行量, a.未执行量,
           a.执行标志, a.记录状态, a.登记时间, a.收费方式
    From (With 医嘱费用记录 As (Select Max(Decode(b.记录状态, 2, 0, b.Id)) As 费用id, b.No, Nvl(b.价格父号, b.序号) As 序号, b.收费细目id,
                                 b.病人病区id, Sum(Nvl(b.付数, 1) * b.数次) As 剩余数量, b.收费类别, Max(Nvl(b.执行状态, 0)) As 执行状态, d.跟踪在用,
                                 c.诊疗类别, c.医嘱内容, c.单次用量, Max(b.记录状态) As 记录状态, Max(b.登记时间) As 登记时间, Nvl(e.收费方式, 0) As 收费方式
                          From 病人医嘱发送 A, 住院费用记录 B, 病人医嘱记录 C, 材料特性 D, 病人医嘱计价 E
                          Where a.医嘱id = 医嘱id_In And a.No = b.No And a.记录性质 = b.记录性质 And a.医嘱id = b.医嘱序号 And
                                b.价格父号 Is Null And b.收费细目id = d.材料id(+) And c.Id = 医嘱id_In And e.医嘱id(+) = b.医嘱序号 And
                                e.收费细目id(+) = b.收费细目id And Not Exists
                           (Select 1 From 输液配药记录 F Where f.医嘱id = c.相关id And a.发送号 = f.发送号)
                          Group By b.No, b.记录性质, Nvl(b.价格父号, b.序号), b.收费细目id, b.病人病区id, b.收费类别, d.跟踪在用, c.诊疗类别, c.医嘱内容,
                                   c.单次用量, e.收费方式
                          Having Sum(Nvl(b.付数, 1) * b.数次) > 0)
           Select 费用id, NO, 序号, 收费细目id, 病人病区id, 收费类别, 跟踪在用, 诊疗类别, 医嘱内容, 单次用量, 剩余数量, Null As 已执行量, Null As 未执行量,
                  执行状态 As 执行标志, 记录状态, 登记时间, 收费方式
           From 医嘱费用记录
           Where 收费类别 Not In ('5', '6', '7') And Not (收费类别 = '4' And Nvl(跟踪在用, 0) = 1)
           Union All
           Select a.费用id, a.No, a.序号, a.收费细目id, a.病人病区id, a.收费类别, a.跟踪在用, a.诊疗类别, a.医嘱内容, a.单次用量, a.剩余数量, 0 As 已执行量,
                  Sum(Nvl(b.付数, 1) * b.实际数量) As 未执行量, 0 As 执行标志, a.记录状态, Max(a.登记时间) As 登记时间, a.收费方式
           From 医嘱费用记录 A, 药品收发记录 B
           Where (a.收费类别 In ('5', '6', '7') Or (a.收费类别 = '4' And Nvl(a.跟踪在用, 0) = 1)) And a.费用id = b.费用id And
                 a.No = b.No And b.单据 In (9, 10, 25, 26) And Mod(b.记录状态, 3) = 1 And b.审核人 Is Null
           Group By a.费用id, a.No, a.序号, a.记录状态, a.收费细目id, a.病人病区id, a.收费类别, a.跟踪在用, a.诊疗类别, a.医嘱内容, a.单次用量, a.剩余数量,
                    a.收费方式
           Having Sum(Nvl(b.付数, 1) * b.实际数量) > 0
           Union All
           Select a.费用id, a.No, a.序号, a.收费细目id, a.病人病区id, a.收费类别, a.跟踪在用, a.诊疗类别, a.医嘱内容, a.单次用量, a.剩余数量,
                  Sum(Nvl(b.付数, 1) * b.实际数量) As 已执行量, 0 As 未执行量, 1 As 执行标志, a.记录状态, Max(a.登记时间) As 登记时间, a.收费方式
           From 医嘱费用记录 A, 药品收发记录 B
           Where (a.收费类别 In ('5', '6', '7') Or (a.收费类别 = '4' And Nvl(a.跟踪在用, 0) = 1)) And a.费用id = b.费用id And
                 a.No = b.No And b.单据 In (9, 10, 25, 26) And Not (Mod(b.记录状态, 3) = 1 And b.审核人 Is Null)
           Group By a.费用id, a.No, a.序号, a.记录状态, a.收费细目id, a.病人病区id, a.收费类别, a.跟踪在用, a.诊疗类别, a.医嘱内容, a.单次用量, a.剩余数量,
                    a.收费方式
           Having Sum(Nvl(b.付数, 1) * b.实际数量) > 0) A
           Order By Decode(a.诊疗类别, '5', 0, '6', 0, '7', 0, a.收费细目id), a.执行标志, a.登记时间 Desc;


  Cursor c_Applay(v_费用ids Varchar2) Is
    Select a.费用id, b.No, b.序号, a.数量, a.申请时间, a.申请类别
    From 病人费用销帐 A, 住院费用记录 B
    Where a.费用id = b.Id And a.申请部门id = a.审核部门id And a.申请时间 = 收回时间_In And
          a.费用id In (Select * From Table(Cast(f_Num2list(v_费用ids) As Zltools.t_Numlist)))
    Order By NO, 序号;

  --包含指定药品长嘱发送时产生的相关费用及药品/卫材记录信息(因多次发送有多条记录,分批的已在界面禁止)
  --药品医嘱填写了"病人医嘱发送"记录,对应的给药途径不一定填写了的(可能为叮嘱),且NO不同。
  --因为要收回的次数可能包含了多次发送的内容,所以要将多次发送的收发记录都取出来，多次发送时，划价的先收回（修改或删除）
  Cursor c_Drug Is
    Select a.病人id, a.主页id, d.姓名, Nvl(x.剂量系数, 1) As 剂量系数, Nvl(x.住院包装, 1) As 住院包装, x.最大效期, Nvl(b.付数, 1) * b.实际数量 As 数量,
           b.Id As 收发id, b.单据, b.药品id, b.对方部门id, b.库房id, b.费用id, Nvl(x.药房分批, 0) As 分批, b.批次, b.批号, b.效期, a.记录状态, a.No,
           a.序号, a.收费细目id, a.执行状态 As 执行标志
    From 住院费用记录 A, 药品收发记录 B, 病人医嘱发送 C, 病人信息 D, 药品规格 X
    Where c.医嘱id = 医嘱id_In And a.No = c.No And a.记录性质 = c.记录性质 And a.记录状态 In (0, 1, 3) And a.医嘱序号 + 0 = 医嘱id_In And
          a.No = b.No And a.Id = b.费用id + 0 And b.单据 In (9, 10, 25, 26) And (b.记录状态 = 1 Or Mod(b.记录状态, 3) = 0) And
          a.病人id = d.病人id And b.药品id = x.药品id(+)
    Order By a.记录状态, b.No Desc, b.Id Desc;

  --包含非药长嘱(含给药途径)发送时所产生的费用(因多个收入而有多条记录)
  --对非药医嘱,直接收回指定量,不管多次发送(如果多次发送价格不同,则收回的价格是以最后次的；不然就要根据多个收入依次减收回量)。
  --卫材本身是售价单位，无需住院单位转换
  --非药长嘱都填写了发送记录(除开了叮嘱及护理等级)
  --一天只收一次或一次发送只收一次的项目暂时不支持负数申请
  Cursor c_Other(n_发送号 病人医嘱发送.发送号%Type) Is
    With 医嘱费用记录 As
     (Select a.No, a.序号, a.记录状态, a.收费细目id, a.Id As 费用id, a.数次 As 剩余数量, Nvl(a.执行状态, 0) As 执行状态, a.医嘱序号, b.发送号,
             c.数量 As 对照数量, Nvl(c.收费方式, 0) As 收费方式, a.收费类别
      From 住院费用记录 A, 病人医嘱发送 B, 病人医嘱计价 C
      Where a.No = b.No And a.记录性质 = b.记录性质 And a.医嘱序号 + 0 = b.医嘱id And b.医嘱id = 医嘱id_In And a.医嘱序号 = c.医嘱id(+) And
            a.收费细目id = c.收费细目id(+))
    Select a.No, a.序号, a.费用id, a.剩余数量, a.收费细目id, a.记录状态, a.执行状态, a.对照数量, a.收费方式, a.收费类别
    From (Select a.No, a.序号, a.记录状态, a.收费细目id, a.费用id, a.剩余数量, a.对照数量, a.执行状态, a.医嘱序号, a.收费方式, a.收费类别
           From 医嘱费用记录 A
           Where a.记录状态 In (1, 3) And a.发送号 = n_发送号
           Union All
           Select a.No, a.序号, a.记录状态, a.收费细目id, a.费用id, a.剩余数量, a.对照数量, a.执行状态, a.医嘱序号, a.收费方式, a.收费类别
           From 医嘱费用记录 A
           Where a.记录状态 = 0) A
    Order By a.收费细目id, a.序号, a.记录状态;

  --按序号排序是为了产生新记录时,填写同一收费细目的不同收入项目的价格父号

  --该游标用于处理费用相关汇总表
  Cursor c_Money
  (
    v_Start 住院费用记录.序号%Type,
    v_End   住院费用记录.序号%Type
  ) Is
    Select 病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, Sum(Nvl(应收金额, 0)) As 应收金额, Sum(Nvl(实收金额, 0)) As 实收金额
    From 住院费用记录
    Where 记录性质 = 2 And 记录状态 = 1 And NO = No_In And 序号 Between v_Start And v_End
    Group By 病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id;

  --系统参数指定执行后需要自动审核的划价费用：用于非药医嘱，包含对应的药品及卫材费用
  Cursor c_Verify
  (
    v_Start 住院费用记录.序号%Type,
    v_End   住院费用记录.序号%Type
  ) Is
    Select NO, 序号
    From 住院费用记录
    Where 记录性质 = 2 And 记录状态 = 0 And NO = No_In And 价格父号 Is Null And 序号 Between v_Start And v_End;

  Cursor c_Compound
  (
    相关id_In       病人医嘱记录.相关id%Type,
    执行终止时间_In 病人医嘱记录.执行终止时间%Type,
    配药id_In       输液配药记录.Id%Type,
    医嘱序号_In     病人医嘱记录.Id%Type
  ) Is
    Select b.费用id, b.药品id As 收费细目id, Sum(a.数量) As 数量, c.住院包装, c.住院单位, d.名称, e.病人病区id, e.操作状态, e.Id As 配药id, f.No,
           Nvl(f.价格父号, f.序号) As 序号, f.记录状态 As 记录状态, f.执行状态 As 执行标志
    From 输液配药内容 A, 药品收发记录 B, 药品规格 C, 收费项目目录 D, 输液配药记录 E, 住院费用记录 F
    Where a.收发id = b.Id And b.药品id = c.药品id And c.药品id = d.Id And e.Id = a.记录id And f.No = b.No And f.Id = b.费用id And
          e.医嘱id = 相关id_In And e.执行时间 > 执行终止时间_In And e.Id = 配药id_In And f.医嘱序号 + 0 = 医嘱序号_In
    Group By b.费用id, b.药品id, c.住院包装, c.住院单位, d.名称, e.病人病区id, e.操作状态, e.Id, f.No, f.价格父号, f.序号, f.记录状态, f.执行状态;

  v_Dec      Number;
  v_First    Number;
  v_划价类别 Varchar2(255);

  v_诊疗类别 病人医嘱记录.诊疗类别%Type;
  v_单次用量 病人医嘱记录.单次用量%Type;
  v_跟踪在用 材料特性.跟踪在用%Type;

  v_费用序号 住院费用记录.序号%Type;
  v_收发序号 药品收发记录.序号%Type;
  v_费用id   住院费用记录.Id%Type;
  v_实收金额 住院费用记录.实收金额%Type;

  v_开始序号 住院费用记录.序号%Type;
  v_结束序号 住院费用记录.序号%Type;

  v_医嘱执行 病人医嘱发送.执行状态%Type;

  v_剂量系数 药品规格.剂量系数%Type;
  v_住院包装 药品规格.住院包装%Type;
  v_医嘱内容 病人医嘱记录.医嘱内容%Type;

  v_结帐参数       Zlparameters.参数值%Type;
  v_配液药销帐申请 Zlparameters.参数值%Type;
  v_结帐金额       住院费用记录.结帐金额%Type;

  v_收费细目id   住院费用记录.收费细目id%Type;
  v_剩余数量     住院费用记录.数次%Type;
  v_收回数量     住院费用记录.数次%Type;
  v_当前数量     住院费用记录.数次%Type;
  v_当前付数     住院费用记录.付数%Type;
  v_费用ids      Varchar2(4000);
  v_组id         病人医嘱记录.Id%Type;
  v_对照数量     病人医嘱计价.数量%Type;
  v_收回量       住院费用记录.数次%Type;
  v_收回剩余     住院费用记录.数次%Type;
  v_输液收回剩余 住院费用记录.数次%Type;

  v_Delno    Varchar2(4000);
  v_Temp     Varchar2(4000);
  v_收费内容 Varchar2(4000);
  v_No       住院费用记录.No%Type;
  v_人员编号 住院费用记录.操作员编号%Type;
  v_人员姓名 住院费用记录.操作员姓名%Type;

  n_相关id       病人医嘱记录.相关id%Type;
  d_执行终止时间 病人医嘱记录.执行终止时间%Type;
  b_输液配药记录 Boolean;
  d_收回时间     病人医嘱记录.执行终止时间%Type;
  n_申请类别     病人费用销帐.申请类别%Type;
  v_销帐原因     病人费用销帐.销帐原因%Type;
  n_Count        Number;
  v_Lngid        药品收发记录.Id%Type; --收发ID
  n_Tmp序号      病人医嘱记录.序号%Type;
  n_配液更新     Number; ----是否更新输液配药记录的状态

  v_Error Varchar2(255);
  Err_Custom Exception;

  Procedure 负数收发记录_Insert
  (
    费用id_In     Number,
    批次_In       药品收发记录.批次%Type,
    分批_In       药品规格.药房分批%Type,
    批号_In       药品收发记录.批号%Type,
    效期_In       药品收发记录.效期%Type,
    最大效期_In   药品规格.最大效期%Type,
    收发id_In     药品收发记录.Id%Type,
    病人id_In     住院费用记录.病人id%Type,
    主页id_In     住院费用记录.主页id%Type,
    药品id_In     药品收发记录.药品id%Type,
    库房id_In     药品收发记录.库房id%Type,
    单据_In       药品收发记录.单据%Type,
    姓名_In       病人信息.姓名%Type,
    对方部门id_In 药品收发记录.对方部门id%Type,
    收费类别_In   住院费用记录.收费类别%Type,
    划价类别_In   Varchar
  ) Is
    v_批次   药品收发记录.批次%Type;
    v_效期   药品收发记录.效期%Type;
    v_批号   药品收发记录.批号%Type;
    v_优先级 身份.优先级%Type;
  Begin
    --确定批次
    If Nvl(批次_In, 0) <> 0 And 分批_In = 0 Then
      --原分批,现不分批
      v_批次 := Null;
      v_批号 := 批号_In;
      v_效期 := 效期_In;
    Elsif Nvl(批次_In, 0) = 0 And 分批_In = 1 Then
      --原不分批,现分批
      Select 药品收发记录_Id.Nextval Into v_批次 From Dual;
      Select To_Char(Sysdate, 'YYYYMMDD') Into v_批号 From Dual;
      If 最大效期_In Is Not Null Then
        v_效期 := Trunc(Sysdate + 最大效期_In * 30);
      Else
        v_效期 := Null;
      End If;
    Else
      v_批次 := 批次_In;
      v_批号 := 批号_In;
      v_效期 := 效期_In;
    End If;
  
    Select 药品收发记录_Id.Nextval Into v_Lngid From Dual;
    Insert Into 药品收发记录
      (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人, 填制日期,
       费用id, 单量, 频次, 用法, 供药单位id, 生产日期, 批准文号, 灭菌效期)
      Select v_Lngid, 1, 单据, No_In, v_收发序号, 库房id, 对方部门id, 入出类别id, -1, 药品id, Nvl(v_批次, 0), 产地, v_批号, v_效期, v_当前付数,
             -1 * v_当前数量, -1 * v_当前数量, 零售价, Round(-1 * v_当前付数 * v_当前数量 * 零售价, v_Dec), '超期发送收回', v_人员姓名, 收回时间_In, 费用id_In,
             单量, 频次, 用法, 供药单位id, 生产日期, 批准文号, 灭菌效期
      From 药品收发记录
      Where ID = 收发id_In;
  
    Zl_未审药品记录_Insert(v_Lngid);
  
    Zl_药品库存_Update(v_Lngid, 0, 1);
  
    --未发药品记录
    Update 未发药品记录
    Set 病人id = 病人id_In, 主页id = 主页id_In, 姓名 = 姓名_In
    Where 单据 = 单据_In And NO = No_In And 库房id + 0 = 库房id_In;
  
    If Sql%RowCount = 0 Then
      --取身份优先级
      Begin
        Select b.优先级 Into v_优先级 From 病人信息 A, 身份 B Where a.身份 = b.名称(+) And a.病人id = 病人id_In;
      Exception
        When Others Then
          Null;
      End;
    
      Insert Into 未发药品记录
        (单据, NO, 病人id, 主页id, 姓名, 优先级, 对方部门id, 库房id, 填制日期, 已收费, 打印状态)
      Values
        (单据_In, No_In, 病人id_In, 主页id_In, 姓名_In, v_优先级, 对方部门id_In, 库房id_In, 收回时间_In,
         Decode(Nvl(Instr(划价类别_In, Decode(收费类别_In, '4', '4', '5')), 0), 0, 1, 0), 0);
    End If;
  
    v_收发序号 := v_收发序号 + 1;
  End;
Begin
  --取操作员信息(部门ID,部门名称;人员ID,人员编号,人员姓名)
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
    v_人员编号 := 操作员编号_In;
    v_人员姓名 := 操作员姓名_In;
  Else
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;
  --检查是否是输液配液记录，并是否已经锁定
  Select 医嘱内容, Nvl(相关id, ID) Into v_医嘱内容, n_相关id From 病人医嘱记录 Where ID = 医嘱id_In;
  Select Count(1)
  Into n_Count
  From 输液配药记录 A, 病人医嘱记录 B
  Where a.医嘱id = b.Id And 医嘱id = 医嘱id_In And a.执行时间 > b.执行终止时间 And a.是否锁定 = 1;

  If n_Count > 0 Then
    v_Error := '医嘱"' || v_医嘱内容 || '"是输液药品，已经被输液配置中心锁定，不能超期收回。';
    Raise Err_Custom;
  End If;
  Select Max(操作说明) Into v_销帐原因 From 病人医嘱状态 Where 医嘱id = 医嘱id_In And 操作类型 = 8;
  If Nvl(收回量_In, 0) > 0 Then
    --判断是否是输液配药药品(输液配制中心药品统一走销帐申请)
    b_输液配药记录 := False;
    v_输液收回剩余 := 收回量_In;
  
    Select Max(a.执行终止时间)
    Into d_执行终止时间
    From 输液配药记录 E, 病人医嘱记录 A
    Where a.Id = n_相关id And e.医嘱id = a.Id And e.执行时间 > a.执行终止时间;
  
    If d_执行终止时间 Is Not Null Then
      d_收回时间       := 收回时间_In;
      v_配液药销帐申请 := zl_GetSysParameter('配液输液单配药后允许销帐申请', 1345);
      b_输液配药记录   := True;
    
      If n_相关id = 医嘱id_In Then
        --给药途径行，更新状态，但不改变数量
        n_配液更新 := 1;
      Else
        n_配液更新 := 0;
        n_Tmp序号  := 医嘱id_In;
      End If;
    
      For X In (Select e.Id As 配药id, e.操作状态, e.是否打包
                From 输液配药记录 E
                Where e.医嘱id = n_相关id And e.执行时间 > d_执行终止时间 And Nvl(e.操作状态, 0) In (1, 2, 3, 4, 5, 6, 7, 8)) Loop
        If Not (x.操作状态 In (4, 5, 6, 7, 8) And Nvl(x.是否打包, 0) = 0 And Nvl(v_配液药销帐申请, '0') = '0') Then
          If n_配液更新 = 0 Then
            --产生药品行明细销帐申请
            For r_Compound In c_Compound(n_相关id, d_执行终止时间, x.配药id, n_Tmp序号) Loop
            
              v_输液收回剩余 := v_输液收回剩余 - r_Compound.数量;
              If x.操作状态 = 1 Then
                n_申请类别 := 0;
              Else
                n_申请类别 := 1;
              End If;
              Zl_病人费用销帐_Insert(r_Compound.费用id, r_Compound.收费细目id, r_Compound.病人病区id, r_Compound.数量, v_人员姓名, d_收回时间,
                               n_申请类别, Null, r_Compound.配药id, v_销帐原因, 0);
              If x.操作状态 = 1 Then
                --未发药的，自动审核。
                Zl_病人费用销帐_Audit(r_Compound.费用id, d_收回时间, v_人员姓名, d_收回时间, 1, 1, n_申请类别);
                Zl_住院记帐记录_Delete(r_Compound.No, r_Compound.序号 || ':' || r_Compound.数量 || ':' || r_Compound.配药id, v_人员编号,
                                 v_人员姓名, 2, Null, Null, d_收回时间);
              End If;
            End Loop;
          End If;
        
          --更新状态
          If n_配液更新 = 1 Then
            Select Count(1)
            Into n_Count
            From 输液配药状态
            Where 配药id = x.配药id And 操作类型 = 9 And 操作时间 = d_收回时间;
            If n_Count = 0 Then
              Insert Into 输液配药状态
                (配药id, 操作类型, 操作人员, 操作时间, 操作说明)
              Values
                (x.配药id, 9, v_人员姓名, d_收回时间, v_销帐原因);
            End If;
            Update 输液配药记录 Set 操作人员 = v_人员姓名, 操作时间 = d_收回时间, 操作状态 = 9 Where ID = x.配药id;
          
            If x.操作状态 = 1 Then
              Insert Into 输液配药状态
                (配药id, 操作类型, 操作人员, 操作时间)
              Values
                (x.配药id, 10, v_人员姓名, d_收回时间);
              Update 输液配药记录 Set 操作人员 = v_人员姓名, 操作时间 = d_收回时间, 操作状态 = 10 Where ID = x.配药id;
            End If;
          End If;
        
          --由于不同批次（执行时间）申请时，申请时间和费用ID有唯一约束，所以同时销帐多个批次时，依次加一秒
          d_收回时间 := d_收回时间 + 1 / 24 / 60 / 60;
        End If;
      End Loop;
    End If;
  
    --a.销帐申请收回模式
    --输液配药记录单独进行销帐
    If b_输液配药记录 = False Or v_输液收回剩余 > 0 Then
      If No_In Is Null Then
        v_结帐参数 := zl_GetSysParameter(23);
        --根据收回数量对照原始费用进行分摊申请
        For r_Detail In c_Detail Loop
          --确定该收费细目ID的收回总数量
          If Nvl(v_收费细目id, 0) <> r_Detail.收费细目id And (r_Detail.诊疗类别 Not In ('5', '6', '7') Or Nvl(v_收费细目id, 0) = 0) Then
            --数量未分摊完成
            If v_收费细目id Is Not Null And v_收回数量 > 0 Then
              v_Error := '医嘱"' || v_医嘱内容 || '"对应的费用剩余数量不足收回数量，可能存在手工销帐或已结帐的费用，或相应的划价单已被删除。';
              Raise Err_Custom;
            End If;
            --药品收回总量是以最后发送规格为准计算的，以此计算出收回售价数量
            Begin
              Select 剂量系数, 住院包装 Into v_剂量系数, v_住院包装 From 药品规格 Where 药品id = r_Detail.收费细目id;
            Exception
              When Others Then
                Null;
            End;
            --计算收回数量，如果收费方式不是0正常收取，则使用特殊的方法进行计算
            If r_Detail.收费方式 = 0 Then
              If r_Detail.诊疗类别 = '7' Then
                --中药配方药品：付数*单量
                v_收回数量 := Round(v_输液收回剩余 * r_Detail.单次用量 / Nvl(v_剂量系数, 1), 5);
              Else
                If r_Detail.诊疗类别 Not In ('5', '6') Then
                  Select Nvl(Max(数量), 1)
                  Into v_对照数量
                  From 病人医嘱计价
                  Where 医嘱id = 医嘱id_In And 收费细目id = r_Detail.收费细目id;
                Else
                  v_对照数量 := 1;
                End If;
                v_收回数量 := Round(v_输液收回剩余 * Nvl(v_住院包装, 1), 5) * v_对照数量;
              End If;
            Else
              Select Nvl(Sum(数量), 0)
              Into v_收回数量
              From 医嘱执行计价
              Where 医嘱id = 医嘱id_In And 收费细目id = r_Detail.收费细目id And
                    要求时间 > Nvl(上次时间_In, To_Date('1900-01-01', 'yyyy-MM-dd'));
            
              v_收回数量 := Round(v_收回数量, 5);
            
            End If;
            v_医嘱内容 := r_Detail.医嘱内容;
          End If;
        
          --该收费细目的每个费用明细分摊收回
          If v_收回数量 > 0 Then
            --检查对应费用是否已结帐，当禁止时
            v_结帐金额 := 0;
            If v_结帐参数 = '2' And r_Detail.记录状态 <> 0 Then
              Select Sum(结帐金额)
              Into v_结帐金额
              From 住院费用记录
              Where NO = r_Detail.No And 记录性质 In (2, 12) And Nvl(价格父号, 序号) = r_Detail.序号;
            End If;
          
            If Nvl(v_结帐金额, 0) = 0 Then
              If r_Detail.收费类别 In ('5', '6', '7') Or r_Detail.收费类别 = '4' And r_Detail.跟踪在用 = 1 Then
                --药品和跟踪在用的卫材
                If r_Detail.执行标志 = 0 Then
                  v_剩余数量 := r_Detail.未执行量;
                Elsif r_Detail.执行标志 = 1 Then
                  v_剩余数量 := r_Detail.已执行量;
                End If;
              Else
                --普通费用
                v_剩余数量 := r_Detail.剩余数量;
              End If;
              If v_收回数量 > v_剩余数量 Then
                v_当前数量 := v_剩余数量;
              Else
                v_当前数量 := v_收回数量;
              End If;
              v_收回数量 := v_收回数量 - v_当前数量;
              --系统参数决定执行后是否审核划价单，所以，已执行的仍然可能是划价单
              If r_Detail.执行标志 = 0 And r_Detail.记录状态 = 0 Then
                v_Delno := v_Delno || '|' || r_Detail.No || ',' || r_Detail.序号 || ':' || v_当前数量;
              Else
                If Not (r_Detail.收费类别 = '7' And r_Detail.执行标志 <> 0) Then
                  Zl_病人费用销帐_Insert(r_Detail.费用id, r_Detail.收费细目id, r_Detail.病人病区id, v_当前数量, v_人员姓名, 收回时间_In,
                                   r_Detail.执行标志, Null, Null, v_销帐原因);
                End If;
              End If;
              v_费用ids := v_费用ids || ',' || r_Detail.费用id;
            End If;
          End If;
          v_收费细目id := r_Detail.收费细目id;
        End Loop;
      
        --数量未分摊完成
        If v_收回数量 > 0 Then
          v_Error := '医嘱"' || v_医嘱内容 || '"对应的费用剩余数量不足收回数量，可能存在手工销帐或已结帐的费用，或相应的划价单已被删除。';
          Raise Err_Custom;
        End If;
        --本科的销帐申请自动审核
        If zl_GetSysParameter('超期收回费用本科自动审核', 1254) = '1' And v_费用ids Is Not Null Then
          For r_Applay In c_Applay(Substr(v_费用ids, 2)) Loop
            Zl_病人费用销帐_Audit(r_Applay.费用id, r_Applay.申请时间, v_人员姓名, 收回时间_In, 1, 1, r_Applay.申请类别);
            v_Delno := v_Delno || '|' || r_Applay.No || ',' || r_Applay.序号 || ':' || r_Applay.数量;
          End Loop;
        End If;
      Else
        ---b.负数收回模式-------------------------------------------------------------------------------------------------------
        --如果全是划价单，就不用产生负数冲销单据
        If No_In = '调整划价单' Then
          --未审核的划价单，先进行修改或删除，可能多次发送为不同的NO,为了计算每次的收回量，需要按收费细目ID排序
          For r_Price In (Select c.诊疗类别, b.No, b.序号, b.收费细目id, Nvl(b.付数, 1) * b.数次 As 剩余数量, c.单次用量, d.剂量系数, d.住院包装,
                                 c.医嘱内容, Nvl(e.收费方式, 0) As 收费方式
                          From 病人医嘱发送 A, 住院费用记录 B, 病人医嘱记录 C, 药品规格 D, 病人医嘱计价 E
                          Where a.医嘱id = 医嘱id_In And a.No = b.No And a.记录性质 = b.记录性质 And a.医嘱id = b.医嘱序号 And
                                b.价格父号 Is Null And b.收费细目id = d.药品id(+) And b.记录状态 = 0 And c.Id = a.医嘱id And
                                b.医嘱序号 = e.医嘱id(+) And b.收费细目id = e.收费细目id(+)
                          Order By 收费细目id, NO Desc) Loop
            If Nvl(v_收费细目id, 0) <> r_Price.收费细目id Then
              --数量未分摊完成
              If v_收费细目id Is Not Null And v_收回数量 > 0 Then
                v_Error := '医嘱"' || v_医嘱内容 || '"对应的费用剩余数量不足收回数量，可能相关划价单已被删除或审核。';
                Raise Err_Custom;
              End If;
              --计算收回数量，如果收费方式不是0正常收取，则使用特殊的方法进行计算
              If r_Price.收费方式 = 0 Then
                If r_Price.诊疗类别 = '7' Then
                  --中药配方药品：付数*单量
                  v_收回数量 := Round(v_输液收回剩余 * r_Price.单次用量 / Nvl(r_Price.剂量系数, 1), 5);
                Else
                  If r_Price.诊疗类别 Not In ('5', '6') Then
                    Select Nvl(Max(数量), 1)
                    Into v_对照数量
                    From 病人医嘱计价
                    Where 医嘱id = 医嘱id_In And 收费细目id = r_Price.收费细目id;
                  Else
                    v_对照数量 := 1;
                  End If;
                  v_收回数量 := Round(v_输液收回剩余 * Nvl(r_Price.住院包装, 1), 5) * v_对照数量;
                End If;
              Else
                Select Nvl(Sum(数量), 0)
                Into v_收回数量
                From 医嘱执行计价
                Where 医嘱id = 医嘱id_In And 收费细目id = r_Price.收费细目id And
                      要求时间 > Nvl(上次时间_In, To_Date('1900-01-01', 'yyyy-MM-dd'));
              
                v_收回数量 := Round(v_收回数量, 5);
              End If;
              v_医嘱内容 := r_Price.医嘱内容;
            End If;
            If v_收回数量 > 0 Then
              If v_收回数量 > r_Price.剩余数量 Then
                v_当前数量 := r_Price.剩余数量;
              Else
                v_当前数量 := v_收回数量;
              End If;
              v_收回数量 := v_收回数量 - v_当前数量;
              v_Delno    := v_Delno || '|' || r_Price.No || ',' || r_Price.序号 || ':' || v_当前数量;
            End If;
            v_收费细目id := r_Price.收费细目id;
          End Loop;
          --数量未分摊完成
          If v_收回数量 > 0 Then
            v_Error := '医嘱"' || v_医嘱内容 || '"对应的费用剩余数量不足收回数量，可能相关划价单已被删除或审核。';
            Raise Err_Custom;
          End If;
        Else
          --负数冲销，可能存在划价单与记帐单混合的情况
          --金额小数位数
          Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into v_Dec From Dual;
          --生成划价单系统参数
          Select zl_GetSysParameter(80) Into v_划价类别 From Dual;
          v_开始序号 := Null;
          v_结束序号 := Null;
        
          Select a.诊疗类别, a.单次用量, b.跟踪在用
          Into v_诊疗类别, v_单次用量, v_跟踪在用
          From 病人医嘱记录 A, 材料特性 B
          Where ID = 医嘱id_In And a.收费细目id = b.材料id(+);
        
          If v_诊疗类别 In ('5', '6', '7') Or (v_诊疗类别 = '4' And Nvl(v_跟踪在用, 0) = 1) Then
            --药品、卫材
            -----------------------------------------------------------------------------------------------------
            v_收回数量 := Null;
            Select Nvl(Max(序号), 0) + 1
            Into v_收发序号
            From 药品收发记录
            Where 单据 In (9, 10, 25, 26) And 记录状态 = 1 And NO = No_In;
            Select Nvl(Max(序号), 0) + 1
            Into v_费用序号
            From 住院费用记录
            Where 记录性质 = 2 And 记录状态 In (0, 1) And NO = No_In;
          
            --一条医嘱的药品只有一行，这里的循环是为了处理多次发送的情况，分批药品在界面已禁用负数收回
            For r_Drug In c_Drug Loop
              --初始化要收回的总数量(零售数量)
              v_First := 0;
              If v_收回数量 Is Null Then
                If v_诊疗类别 = '7' Then
                  v_收回数量 := Round(v_输液收回剩余 * v_单次用量 / r_Drug.剂量系数, 5);
                Else
                  If v_诊疗类别 Not In ('5', '6') Then
                    Select Nvl(Max(数量), 1)
                    Into v_对照数量
                    From 病人医嘱计价
                    Where 医嘱id = 医嘱id_In And 收费细目id = r_Drug.收费细目id;
                  Else
                    v_对照数量 := 1;
                  End If;
                  v_收回数量 := Round(v_输液收回剩余 * r_Drug.住院包装, 5) * v_对照数量;
                End If;
                v_First := 1;
              End If;
            
              --如果第一次数量就足够，则按付数处理，否则付数不好处理
              If v_收回数量 > r_Drug.数量 Then
                v_当前付数 := 1;
                v_当前数量 := r_Drug.数量;
                v_收回数量 := v_收回数量 - r_Drug.数量;
              Else
                If v_First = 1 And v_诊疗类别 = '7' Then
                  v_当前付数 := v_输液收回剩余;
                  v_当前数量 := Round(v_单次用量 / r_Drug.剂量系数, 5);
                Else
                  v_当前付数 := 1;
                  v_当前数量 := v_收回数量;
                End If;
                v_收回数量 := 0;
              End If;
            
              If r_Drug.记录状态 = 0 Then
                v_Delno := v_Delno || '|' || r_Drug.No || ',' || r_Drug.序号 || ':' || v_当前数量 * v_当前付数;
              Else
                If Not (v_诊疗类别 = '7' And r_Drug.执行标志 <> 0) Then
                
                  Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
                  负数收发记录_Insert(v_费用id, r_Drug.批次, r_Drug.分批, r_Drug.批号, r_Drug.效期, r_Drug.最大效期, r_Drug.收发id,
                                r_Drug.病人id, r_Drug.主页id, r_Drug.药品id, r_Drug.库房id, r_Drug.单据, r_Drug.姓名, r_Drug.对方部门id,
                                v_诊疗类别, v_划价类别);
                
                  --住院费用记录
                  -------------------------------------------------------------------------------------
                  --记录序号范围以处理汇总表
                  If v_开始序号 Is Null Then
                    v_开始序号 := v_费用序号;
                  End If;
                  v_结束序号 := v_费用序号;
                
                  Insert Into 住院费用记录
                    (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id,
                     费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额,
                     统筹金额, 记帐费用, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 医嘱序号, 划价人, 操作员编号, 操作员姓名)
                    Select v_费用id, 2, No_In, Decode(Nvl(Instr(v_划价类别, Decode(v_诊疗类别, '4', '4', '5')), 0), 0, 1, 0),
                           v_费用序号, Null, Null, 多病人单, 2, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id, 费别, 收费类别,
                           收费细目id, 计算单位, 保险项目否, 保险大类id, v_当前付数, -1 * v_当前数量, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价,
                           Round(-1 * v_当前付数 * v_当前数量 * 标准单价, v_Dec), Round(-1 * v_当前付数 * v_当前数量 * 标准单价, v_Dec), Null, 1,
                           开单部门id, 开单人, 收回时间_In, 收回时间_In, 执行部门id, 0, 医嘱序号, v_人员姓名,
                           Decode(Nvl(Instr(v_划价类别, Decode(v_诊疗类别, '4', '4', '5')), 0), 0, v_人员编号, Null),
                           Decode(Nvl(Instr(v_划价类别, Decode(v_诊疗类别, '4', '4', '5')), 0), 0, v_人员姓名, Null)
                    From 住院费用记录
                    Where ID = r_Drug.费用id;
                
                  Select Zl_Actualmoney(费别, 收费细目id, 收入项目id, 应收金额, 数次, 执行部门id)
                  Into v_Temp
                  From 住院费用记录
                  Where ID = v_费用id;
                  v_实收金额 := Round(Substr(v_Temp, Instr(v_Temp, ':') + 1), v_Dec);
                  Update 住院费用记录 A Set 实收金额 = v_实收金额 Where ID = v_费用id;
                
                  v_费用序号 := v_费用序号 + 1;
                End If;
                If v_收回数量 <= 0 Then
                  Exit;
                End If;
              End If;
            End Loop;
          
            If v_收回数量 <> 0 Then
              --没有收回所有数量,收发记录本身有问题(如记录不全或数量为负)
              Null;
            End If;
          Else
            --其它非药医嘱(包括给药途径，及绑定的卫材等)
            -----------------------------------------------------------------------------------------------------
            Select Nvl(Max(序号), 0) + 1
            Into v_收发序号
            From 药品收发记录
            Where 单据 In (9, 10, 25, 26) And 记录状态 = 1 And NO = No_In;
            --取费用序号
            Select Nvl(Max(序号), 0) + 1
            Into v_费用序号
            From 住院费用记录
            Where 记录性质 = 2 And 记录状态 In (0, 1) And NO = No_In;
          
            v_收回剩余 := v_输液收回剩余;
          
            For r_Othersend In (Select 发送号, 发送数次
                                From 病人医嘱发送
                                Where 医嘱id = 医嘱id_In And 末次时间 > 上次时间_In
                                Order By 发送号 Desc) Loop
              If r_Othersend.发送数次 < v_收回剩余 Then
                --一次收回多次发送，但是每次发送费用有所变动（计价）
                v_收回剩余 := v_收回剩余 - r_Othersend.发送数次;
                v_收回量   := r_Othersend.发送数次;
              Else
                --一次发送中收回剩余；
                v_收回量   := v_收回剩余;
                v_收回剩余 := 0;
              End If;
              v_收费内容 := '';
              For r_Other In c_Other(r_Othersend.发送号) Loop
                If Nvl(v_收费内容, '0') <> r_Other.收费细目id || ',' || r_Other.序号 Then
                  --根据最近一次发送的费用记录，按需要收回的数量全部收回
                  --计算收回数量，如果收费方式不是0正常收取，则使用特殊的方法进行计算
                  If r_Other.收费方式 = 0 Then
                    v_收回数量 := v_收回量 * Nvl(r_Other.对照数量, 1);
                  Else
                    Select Nvl(Sum(数量), 0)
                    Into v_收回数量
                    From 医嘱执行计价
                    Where 医嘱id = 医嘱id_In And 收费细目id = r_Other.收费细目id And
                          要求时间 > Nvl(上次时间_In, To_Date('1900-01-01', 'yyyy-MM-dd'));
                  End If;
                End If;
              
                If v_收回数量 > 0 Then
                  If r_Other.记录状态 = 0 Then
                    If v_收回数量 > r_Other.剩余数量 Then
                      v_当前数量 := r_Other.剩余数量;
                    Else
                      v_当前数量 := v_收回数量;
                    End If;
                  Else
                    v_当前数量 := v_收回数量;
                  End If;
                  v_收回数量 := v_收回数量 - v_当前数量;
                  v_当前付数 := 1;
                
                  If r_Other.记录状态 = 0 Then
                    v_Delno := v_Delno || '|' || r_Other.No || ',' || r_Other.序号 || ':' || v_当前数量;
                  Else
                    --记录序号范围以处理汇总表
                    If v_开始序号 Is Null Then
                      v_开始序号 := v_费用序号;
                    End If;
                    v_结束序号 := v_费用序号;
                  
                    --住院费用记录:按理如果收回量大于了上次发送量,则不正确
                    Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
                    If r_Other.收费类别 In ('4', '5', '6', '7') Then
                      For r_Otherdrug In (Select a.病人id, a.主页id, d.姓名, Nvl(x.剂量系数, 1) As 剂量系数, Nvl(x.住院包装, 1) As 住院包装,
                                                 x.最大效期, Nvl(b.付数, 1) * b.实际数量 As 数量, b.Id As 收发id, b.单据, b.药品id,
                                                 b.对方部门id, b.库房id, b.费用id, Nvl(x.药房分批, 0) As 分批, b.批次, b.批号, b.效期, a.记录状态,
                                                 a.No, a.序号, a.收费细目id
                                          From 住院费用记录 A, 药品收发记录 B, 病人信息 D, 药品规格 X
                                          Where a.Id = r_Other.费用id And a.记录状态 In (0, 1, 3) And a.No = b.No And
                                                a.Id = b.费用id + 0 And b.单据 In (9, 10, 25, 26) And
                                                (b.记录状态 = 1 Or Mod(b.记录状态, 3) = 0) And a.病人id = d.病人id And
                                                b.药品id = x.药品id(+)
                                          Order By a.记录状态, b.No Desc, b.Id Desc) Loop
                        负数收发记录_Insert(v_费用id, r_Otherdrug.批次, r_Otherdrug.分批, r_Otherdrug.批号, r_Otherdrug.效期,
                                      r_Otherdrug.最大效期, r_Otherdrug.收发id, r_Otherdrug.病人id, r_Otherdrug.主页id,
                                      r_Otherdrug.药品id, r_Otherdrug.库房id, r_Otherdrug.单据, r_Otherdrug.姓名,
                                      r_Otherdrug.对方部门id, r_Other.收费类别, v_划价类别);
                      End Loop;
                    End If;
                    --医嘱已执行，收回的费用也填为已执行：不包含药品和跟踪在用的卫材，因为实际发放表示执行
                    Insert Into 住院费用记录
                      (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id,
                       费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额,
                       统筹金额, 记帐费用, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 执行时间, 执行人, 医嘱序号, 划价人, 操作员编号, 操作员姓名)
                      Select v_费用id, 2, No_In, Decode(Nvl(Instr(v_划价类别, r_Other.收费类别), 0), 0, 1, 0), v_费用序号, Null,
                             Decode(a.价格父号, Null, Null, v_费用序号 + a.价格父号 - a.序号), a.多病人单, 2, a.病人id, a.主页id, a.标识号, a.姓名,
                             a.性别, a.年龄, a.床号, a.病人病区id, a.病人科室id, a.费别, a.收费类别, a.收费细目id, a.计算单位, a.保险项目否, a.保险大类id, 1,
                             -1 * v_当前数量, a.加班标志, a.附加标志, a.婴儿费, a.收入项目id, a.收据费目, a.标准单价,
                             Round(-1 * v_当前数量 * a.标准单价, v_Dec), Round(-1 * v_当前数量 * a.标准单价, v_Dec), Null, 1, a.开单部门id,
                             a.开单人, 收回时间_In, 收回时间_In, a.执行部门id,
                             Decode(r_Other.执行状态, 1,
                                     Decode(a.收费类别, '4', Decode(b.跟踪在用, 1, 0, 1),
                                             Decode(Instr(',5,6,7,', a.收费类别), 0, 1, 0)), 0),
                             Decode(r_Other.执行状态, 1,
                                     Decode(a.收费类别, '4', Decode(b.跟踪在用, 1, Null, 收回时间_In),
                                             Decode(Instr(',5,6,7,', a.收费类别), 0, 收回时间_In, Null)), Null),
                             Decode(r_Other.执行状态, 1,
                                     Decode(a.收费类别, '4', Decode(b.跟踪在用, 1, Null, v_人员姓名),
                                             Decode(Instr(',5,6,7,', a.收费类别), 0, v_人员姓名, Null)), Null), a.医嘱序号, v_人员姓名,
                             Decode(Nvl(Instr(v_划价类别, r_Other.收费类别), 0), 0, v_人员编号, Null),
                             Decode(Nvl(Instr(v_划价类别, r_Other.收费类别), 0), 0, v_人员姓名, Null)
                      From 住院费用记录 A, 材料特性 B
                      Where a.Id = r_Other.费用id And a.收费细目id = b.材料id(+);
                  
                    Select Zl_Actualmoney(费别, 收费细目id, 收入项目id, 应收金额, 数次, 执行部门id)
                    Into v_Temp
                    From 住院费用记录
                    Where ID = v_费用id;
                    v_实收金额 := Round(Substr(v_Temp, Instr(v_Temp, ':') + 1), v_Dec);
                    Update 住院费用记录 A Set 实收金额 = v_实收金额 Where ID = v_费用id;
                  
                    v_费用序号 := v_费用序号 + 1;
                    v_医嘱执行 := r_Other.执行状态; --多个收费项目的执行状态是一样的
                  End If;
                
                  v_收费内容 := r_Other.收费细目id || ',' || r_Other.序号;
                End If;
              End Loop;
              If v_收回剩余 = 0 Then
                Exit;
              End If;
            End Loop;
          
            --如果医嘱已执行，则按系统参数执行后自动审核费用：包含已执行医嘱对应的药品和卫材费用。
            -----------------------------------------------------------------------------------------------------
            If Nvl(v_医嘱执行, 0) = 1 And v_开始序号 Is Not Null And v_结束序号 Is Not Null Then
              For r_Verify In c_Verify(v_开始序号, v_结束序号) Loop
                Zl_住院记帐记录_Verify(r_Verify.No, v_人员编号, v_人员姓名, r_Verify.序号, Null, 收回时间_In);
              End Loop;
            End If;
          End If;
        
          --处理费用汇总表
          -----------------------------------------------------------------------------------------------------
          If v_开始序号 Is Not Null And v_结束序号 Is Not Null Then
            --最后统一处理费用相关汇总表
            For r_Money In c_Money(v_开始序号, v_结束序号) Loop
              --病人余额
              Update 病人余额
              Set 费用余额 = Nvl(费用余额, 0) + r_Money.实收金额
              Where 病人id = r_Money.病人id And 性质 = 1 And 类型 = 2;
            
              If Sql%RowCount = 0 Then
                Insert Into 病人余额
                  (病人id, 性质, 类型, 费用余额, 预交余额)
                Values
                  (r_Money.病人id, 1, 2, r_Money.实收金额, 0);
              End If;
            
              --病人未结费用
              Update 病人未结费用
              Set 金额 = Nvl(金额, 0) + r_Money.实收金额
              Where 病人id = r_Money.病人id And 主页id = r_Money.主页id And Nvl(病人病区id, 0) = Nvl(r_Money.病人病区id, 0) And
                    Nvl(病人科室id, 0) = Nvl(r_Money.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(r_Money.开单部门id, 0) And
                    Nvl(执行部门id, 0) = Nvl(r_Money.执行部门id, 0) And 收入项目id + 0 = r_Money.收入项目id And 来源途径 + 0 = 2;
            
              If Sql%RowCount = 0 Then
                Insert Into 病人未结费用
                  (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
                Values
                  (r_Money.病人id, r_Money.主页id, r_Money.病人病区id, r_Money.病人科室id, r_Money.开单部门id, r_Money.执行部门id,
                   r_Money.收入项目id, 2, r_Money.实收金额);
              End If;
            End Loop;
          End If;
        End If;
      End If;
    End If;
  End If;

  --过程Zl_住院记帐记录_Delete，不支持每次删除一行的循环处理（序号重整），必须把一个单据要删除的序号一次性传入
  If Not v_Delno Is Null Then
    v_Temp := '';
    v_No   := '';
    For r_Price In (Select /*+ rule*/
                     C1 As NO, C2 As 序号数量
                    From Table(f_Str2list2(Substr(v_Delno, 2), '|', ','))
                    Order By NO) Loop
      If v_No Is Not Null And v_No <> r_Price.No Then
        Zl_住院记帐记录_Delete(v_No, v_Temp, v_人员编号, v_人员姓名, 2);
        v_No := '';
      End If;
      If v_No Is Null Then
        v_No   := r_Price.No;
        v_Temp := r_Price.序号数量;
      Else
        v_Temp := v_Temp || ',' || r_Price.序号数量;
      End If;
    End Loop;
    If Not v_No Is Null Then
      Zl_住院记帐记录_Delete(v_No, v_Temp, v_人员编号, v_人员姓名, 2);
    End If;
  End If;

  --处理医嘱的上次执行时间:给药途径等可能因为未发送而没调用收回过程。
  -----------------------------------------------------------------------------------------------------
  Select Nvl(相关id, ID) Into v_组id From 病人医嘱记录 Where ID = 医嘱id_In;
  Update 病人医嘱记录 Set 上次执行时间 = 上次时间_In Where ID = v_组id Or 相关id = v_组id;

  --删除医嘱执行时间
  If 上次时间_In Is Null Then
    --全部收回
    Delete From 医嘱执行时间 Where 医嘱id = v_组id;
    Delete From 医嘱执行计价 Where 医嘱id = 医嘱id_In;
  Else
    --可能收回多次发送的数据
    Delete From 医嘱执行时间 Where 医嘱id = v_组id And 要求时间 > 上次时间_In;
    Delete From 医嘱执行计价 Where 医嘱id = 医嘱id_In And 要求时间 > 上次时间_In;
  End If;
  --处理输液配液记录的批次问题，每个医嘱都进行调用，在过程里面只处理了输液配液的医嘱
  Zl_输液配药记录_批次调整(医嘱id_In);

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱记录_收回;
/

--118817:殷瑞,2017-12-21,处理错误的查询异常
--118364:殷瑞,2017-12-19,修正退发药品“配药人”和“配药日期”可能为空的情况
Create Or Replace Procedure Zl_药品收发记录_处方发药
(
  Partid_In        In 药品收发记录.库房id%Type,
  Bill_In          In 药品收发记录.单据%Type,
  No_In            In 药品收发记录.No%Type,
  People_In        In 药品收发记录.审核人%Type,
  配药人_In        In 药品收发记录.配药人%Type := Null,
  校验人_In        In 药品收发记录.填制人%Type := Null,
  发药方式_In      In 药品收发记录.发药方式%Type := 1,
  发药时间_In      In 药品收发记录.审核日期%Type := Null,
  操作员编号_In    In 人员表.编号%Type := Null,
  操作员姓名_In    In 人员表.姓名%Type := Null,
  Intdigit_In      In Number := 2,
  Intautoverify_In In Number := 0,
  门诊_In          In Number := 1,
  核查人_In        In 药品收发记录.核查人%Type := Null,
  未取药_In        In 药品收发记录.是否未取药%Type := Null,
  汇总发药号_In    In 药品收发记录.汇总发药号%Type := Null
) Is
  --住院病人
  Cursor c_Modifybillin Is
    Select a.Id, a.药品id, a.入出类别id, a.入出系数, a.费用id, Nvl(a.实际数量, 0) * Nvl(a.付数, 1) 数量, Nvl(a.零售金额, 0) 金额, Nvl(a.批次, 0) 批次,
           a.供药单位id, a.成本价, a.批号, a.产地, a.效期, a.生产日期, a.批准文号, b.病人id, b.序号, Nvl(c.处方类型, Nvl(a.注册证号, 0)) 处方类型,
           Nvl(a.零售价, 0) As 零售价, a.记录状态
    From 药品收发记录 A, 住院费用记录 B, 未发药品记录 C
    Where a.单据 = c.单据 And a.No = c.No And Nvl(a.库房id, 0) = Nvl(c.库房id, 0) And a.No = No_In And a.单据 = Bill_In And
          (a.库房id + 0 = Partid_In Or a.库房id Is Null) And Nvl(a.摘要, '小宝') <> '拒发' And a.费用id = b.Id And
          Nvl(b.执行状态, 0) <> 1 And Mod(a.记录状态, 3) = 1 And a.审核人 Is Null;

  --门诊病人
  Cursor c_Modifybillout Is
    Select a.Id, a.药品id, a.入出类别id, a.入出系数, a.费用id, Nvl(a.实际数量, 0) * Nvl(a.付数, 1) 数量, Nvl(a.零售金额, 0) 金额, Nvl(a.批次, 0) 批次,
           a.供药单位id, a.成本价, a.批号, a.产地, a.效期, a.生产日期, a.批准文号, b.病人id, b.序号, Nvl(c.处方类型, Nvl(a.注册证号, 0)) 处方类型,
           Nvl(a.零售价, 0) As 零售价, b.No, b.记录性质, a.记录状态
    From 药品收发记录 A, 门诊费用记录 B, 未发药品记录 C
    Where a.单据 = c.单据 And a.No = c.No And Nvl(a.库房id, 0) = Nvl(c.库房id, 0) And a.No = No_In And a.单据 = Bill_In And
          (a.库房id + 0 = Partid_In Or a.库房id Is Null) And Nvl(a.摘要, '小宝') <> '拒发' And a.费用id = b.Id And
          Nvl(b.执行状态, 0) <> 1 And Mod(a.记录状态, 3) = 1 And a.审核人 Is Null
    Order By 药品id;

  v_Modifybillin  c_Modifybillin%RowType;
  v_Modifybillout c_Modifybillout%RowType;

  --只读变量
  Dbl差价率  Number;
  v_核查日期 药品收发记录.核查日期%Type;
  --可写变量
  Dbl实际金额       药品收发记录.零售金额%Type;
  Dbl成本金额       药品收发记录.成本金额%Type;
  Dbl实际差价       药品收发记录.差价%Type;
  Date操作时间      药品收发记录.审核日期%Type;
  Bln收费与发药分离 Number(1);
  n_平均成本价      药品库存.平均成本价%Type;
  v_填制人          药品收发记录.填制人%Type;
  v_配药人          药品收发记录.配药人%Type;
  v_配药日期        药品收发记录.配药日期%Type;
  v_Error           Varchar2(4000);
  Err_Custom Exception;
  n_流通售价小数   Number;
  n_流通金额小数   Number;
  n_零差价管理模式 Number(1);
  n_药品零差价管理 Number(1);
Begin
  --取发药时间
  If 发药时间_In Is Null Then
    Select Sysdate Into Date操作时间 From Dual;
  Else
    Date操作时间 := 发药时间_In;
  End If;

  v_核查日期 := Date操作时间;
  Begin
    Select 0 Into Bln收费与发药分离 From 未发药品记录 Where 单据 = Bill_In And NO = No_In And 库房id + 0 = Partid_In;
  Exception
    When Others Then
      Bln收费与发药分离 := 1;
  End;

  --重写已发药处方的配药人和汇总发药号
  Update 药品收发记录
  Set 配药人 = Decode(配药人_In, Null, 配药人, 配药人_In), 配药日期 = Decode(配药人_In, Null, 配药日期, Date操作时间), 汇总发药号 = 汇总发药号_In
  Where NO = No_In And 单据 = Bill_In And (库房id + 0 = Partid_In Or 库房id Is Null) And Mod(记录状态, 3) = 1 And 审核人 Is Not Null;

  --修正退发药品“配药人”和“配药日期”可能为空的情况
  Begin
    If 配药人_In Is Null Then
      Select 配药人, 配药日期
      Into v_配药人, v_配药日期
      From 药品收发记录
      Where NO = No_In And 单据 = Bill_In And (库房id + 0 = Partid_In Or 库房id Is Null) And Mod(记录状态, 3) = 1 And
            配药人 Is Not Null And Rownum = 1
      Order By 记录状态 Desc;
    
      Update 药品收发记录
      Set 配药人 = v_配药人, 配药日期 = v_配药日期
      Where NO = No_In And 单据 = Bill_In And (库房id + 0 = Partid_In Or 库房id Is Null) And Mod(记录状态, 3) = 1 And 审核人 Is Null;
    End If;
  Exception
    When Others Then
      v_配药人   := Null;
      v_配药日期 := Null;
  End;

  Begin
    Select 填制人
    Into v_填制人
    From 药品收发记录
    Where NO = No_In And 单据 = Bill_In And 库房id + 0 = Partid_In And 审核日期 Is Null And Rownum = 1
    For Update Nowait;
  Exception
    When Others Then
      v_Error := '已有其他用户在执行发药，不能重复操作！';
      Raise Err_Custom;
  End;

  --取流通业务精度位数
  --类别:1-药品 2-卫材
  --内容：2-零售价 4-金额
  --单位：药品:1-售价 5-金额单位
  Begin
    Select 精度 Into n_流通金额小数 From 药品卫材精度 Where 类别 = 1 And 内容 = 4 And 单位 = 5;
  Exception
    When Others Then
      n_流通金额小数 := 2;
  End;

  Begin
    Select 精度 Into n_流通售价小数 From 药品卫材精度 Where 类别 = 1 And 内容 = 2 And 单位 = 1;
  Exception
    When Others Then
      n_流通售价小数 := 2;
  End;

  Select Zl_To_Number(Nvl(zl_GetSysParameter(275), '0')) Into n_零差价管理模式 From Dual;

  --重新计算成本价、成本金额、零售金额及差价
  If 门诊_In = 1 Then
    --处理门诊数据
    For v_Modifybillout In c_Modifybillout Loop
      If n_零差价管理模式 <> 0 Then
        Select Nvl(是否零差价管理, 0) Into n_药品零差价管理 From 药品规格 Where 药品id = v_Modifybillout.药品id;
      End If;
    
      If v_Modifybillout.记录状态 = 1 Then
        --原始发药记录，取最新价格
        n_平均成本价 := Zl_Fun_Getoutcost(v_Modifybillout.药品id, v_Modifybillout.批次, Partid_In);
      
        If n_零差价管理模式 <> 0 And n_药品零差价管理 = 1 And
           (v_Modifybillout.零售价 = n_平均成本价 Or Round(v_Modifybillout.零售价, n_流通售价小数) = Round(n_平均成本价, n_流通售价小数)) Then
          Dbl成本金额 := Nvl(v_Modifybillout.金额, 0);
        Else
          Dbl成本金额 := Round(n_平均成本价 * Nvl(v_Modifybillout.数量, 0), n_流通金额小数);
        End If;
      Else
        --退药再发记录，取原始单据价格
        Select a.成本价
        Into n_平均成本价
        From 药品收发记录 A, 药品收发记录 B
        Where b.Id = v_Modifybillout.Id And a.单据 = b.单据 And a.No = b.No And a.库房id = b.库房id And a.药品id + 0 = b.药品id And
              a.序号 = b.序号 And Nvl(a.批次, 0) = Nvl(b.批次, 0) And (a.记录状态 = 1 Or Mod(a.记录状态, 3) = 0);
      
        Dbl成本金额 := Round(n_平均成本价 * Nvl(v_Modifybillout.数量, 0), n_流通金额小数);
      End If;
    
      --零售金额
      Dbl实际金额 := Nvl(v_Modifybillout.金额, 0);
      --差价
      Dbl实际差价 := Round(Dbl实际金额 - Dbl成本金额, n_流通金额小数);
    
      --更新药品收发记录的零售金额、成本金额、差价、审核人等信息
      Update 药品收发记录
      Set 成本价 = n_平均成本价, 成本金额 = Dbl成本金额, 差价 = Dbl实际差价, 库房id = Partid_In, 配药人 = Decode(配药人_In, Null, 配药人, 配药人_In),
          核查人 = 核查人_In, 核查日期 = v_核查日期, 配药日期 = Decode(配药人_In, Null, 配药日期, Date操作时间),
          填制人 = Decode(校验人_In, Null, 填制人, 校验人_In), 审核人 = Decode(People_In, Null, Zl_Username, People_In),
          审核日期 = Date操作时间, 发药方式 = 发药方式_In, 注册证号 = v_Modifybillout.处方类型, 是否未取药 = 未取药_In, 汇总发药号 = 汇总发药号_In
      Where ID = v_Modifybillout.Id;
    
      --处理库存
      Zl_药品库存_Update(v_Modifybillout.Id, 2, 1);
      
      Zl_未审药品记录_Delete(v_Modifybillout.Id);
      
      --更新费用记录的执行状态(已执行)
      Update 门诊费用记录
      Set 执行状态 = 1, 执行人 = Decode(People_In, Null, Zl_Username, People_In), 执行部门id = Partid_In, 执行时间 = Date操作时间






      
      Where NO = v_Modifybillout.No And Mod(记录性质, 10) = v_Modifybillout.记录性质 And 记录状态 <> 2 And 序号 = v_Modifybillout.序号;
    
      --费用审核（重复审核也没有关系）
      If Intautoverify_In = 1 Then
        If Bill_In = 9 Then
          Zl_门诊记帐记录_Verify(No_In, 操作员编号_In, 操作员姓名_In, v_Modifybillout.序号, 发药时间_In);
        End If;
      End If;
    
      --处理调价修正
      Zl_药品收发记录_调价修正(v_Modifybillout.Id);
    End Loop;
  Else
    --处理住院数据
    For v_Modifybillin In c_Modifybillin Loop
      If n_零差价管理模式 <> 0 Then
        Select Nvl(是否零差价管理, 0) Into n_药品零差价管理 From 药品规格 Where 药品id = v_Modifybillin.药品id;
      End If;
    
      If v_Modifybillin.记录状态 = 1 Then
        --原始发药记录，取最新价格
        n_平均成本价 := Zl_Fun_Getoutcost(v_Modifybillin.药品id, v_Modifybillin.批次, Partid_In);
      
        If n_零差价管理模式 <> 0 And n_药品零差价管理 = 1 And
           (v_Modifybillin.零售价 = n_平均成本价 Or Round(v_Modifybillin.零售价, n_流通售价小数) = Round(n_平均成本价, n_流通售价小数)) Then
          Dbl成本金额 := Nvl(v_Modifybillin.金额, 0);
        Else
          Dbl成本金额 := Round(n_平均成本价 * Nvl(v_Modifybillin.数量, 0), n_流通金额小数);
        End If;
      Else
        --退药再发记录，取原始单据价格
        Select a.成本价
        Into n_平均成本价
        From 药品收发记录 A, 药品收发记录 B
        Where b.Id = v_Modifybillin.Id And a.单据 = b.单据 And a.No = b.No And a.库房id = b.库房id And a.药品id + 0 = b.药品id And
              a.序号 = b.序号 And Nvl(a.批次, 0) = Nvl(b.批次, 0) And (a.记录状态 = 1 Or Mod(a.记录状态, 3) = 0);
      
        Dbl成本金额 := Round(n_平均成本价 * Nvl(v_Modifybillin.数量, 0), n_流通金额小数);
      End If;
    
      --零售金额
      Dbl实际金额 := Nvl(v_Modifybillin.金额, 0);
      --差价
      Dbl实际差价 := Round(Dbl实际金额 - Dbl成本金额, n_流通金额小数);
    
      --更新药品收发记录的零售金额、成本金额、差价、审核人等信息
      Update 药品收发记录
      Set 成本价 = n_平均成本价, 成本金额 = Dbl成本金额, 差价 = Dbl实际差价, 库房id = Partid_In, 配药人 = Decode(配药人_In, Null, 配药人, 配药人_In),
          核查人 = 核查人_In, 核查日期 = v_核查日期, 配药日期 = Decode(配药人_In, Null, 配药日期, Date操作时间),
          填制人 = Decode(校验人_In, Null, 填制人, 校验人_In), 审核人 = Decode(People_In, Null, Zl_Username, People_In),
          审核日期 = Date操作时间, 发药方式 = 发药方式_In, 注册证号 = v_Modifybillin.处方类型, 汇总发药号 = 汇总发药号_In
      Where ID = v_Modifybillin.Id;
    
      --处理库存
      Zl_药品库存_Update(v_Modifybillin.Id, 2, 1);
      
      Zl_未审药品记录_Delete(v_Modifybillin.Id);
      
      --更新费用记录的执行状态(已执行)
      Update 住院费用记录
      Set 执行状态 = 1, 执行人 = Decode(People_In, Null, Zl_Username, People_In), 执行部门id = Partid_In, 执行时间 = Date操作时间






      
      Where ID = v_Modifybillin.费用id;
    
      --费用审核（重复审核也没有关系）
      If Intautoverify_In = 1 Then
        If Bill_In = 9 Then
          Zl_住院记帐记录_Verify(No_In, 操作员编号_In, 操作员姓名_In, v_Modifybillin.序号, v_Modifybillin.病人id, 发药时间_In);
        End If;
      End If;
    
      --处理调价修正
      Zl_药品收发记录_调价修正(v_Modifybillin.Id);
    End Loop;
  End If;

  --更新或删除未发药品记录
  Delete 未发药品记录 Where NO = No_In And 单据 = Bill_In And (库房id + 0 = Partid_In Or 库房id Is Null);

  If Bill_In = 8 Then
    Begin
      --移动支付宝项目在发药后动态调用生成推送信息的过程
      Execute Immediate 'Begin zl_服务窗消息_发送(:1,:2); End;'
        Using 6, No_In || ',' || Partid_In;
    Exception
      When Others Then
        Null;
    End;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_处方发药;
/

--115597:焦博,2017-12-18,严格控制并支持重复使用的院内卡，当数据库中有相同卡号时，重复使用该卡号票据领用记录将不会发生数量变化
Create Or Replace Procedure Zl_医疗卡记录_Insert
(
  发卡类型_In     Number,
  单据号_In       住院费用记录.No%Type,
  病人id_In       住院费用记录.病人id%Type,
  主页id_In       住院费用记录.主页id%Type,
  标识号_In       住院费用记录.标识号%Type,
  费别_In         住院费用记录.费别%Type,
  卡类别id_In     医疗卡类别.Id%Type,
  原卡号_In       病人医疗卡信息.卡号%Type,
  医疗卡号_In     病人医疗卡信息.卡号%Type,
  变动原因_In     病人医疗卡变动.变动原因%Type,
  密码_In         病人信息.卡验证码%Type,
  姓名_In         住院费用记录.姓名%Type,
  性别_In         住院费用记录.性别%Type,
  年龄_In         住院费用记录.年龄%Type,
  病人病区id_In   住院费用记录.病人病区id%Type,
  病人科室id_In   住院费用记录.病人科室id%Type,
  收费细目id_In   住院费用记录.收费细目id%Type,
  收费类别_In     住院费用记录.收费类别%Type,
  计算单位_In     住院费用记录.计算单位%Type,
  收入项目id_In   住院费用记录.收入项目id%Type,
  收据费目_In     住院费用记录.收据费目%Type,
  标准单价_In     住院费用记录.标准单价%Type,
  执行部门id_In   住院费用记录.执行部门id%Type,
  开单部门id_In   住院费用记录.开单部门id%Type,
  操作员编号_In   住院费用记录.操作员编号%Type,
  操作员姓名_In   住院费用记录.操作员姓名%Type,
  加班标志_In     住院费用记录.加班标志%Type,
  发卡时间_In     住院费用记录.登记时间%Type,
  领用id_In       票据使用明细.领用id%Type,
  Ic卡号_In       病人信息.Ic卡号%Type := Null,
  应收金额_In     住院费用记录.应收金额%Type,
  实收金额_In     住院费用记录.实收金额%Type,
  结算方式_In     病人预交记录.结算方式%Type,
  刷卡类别id_In   病人预交记录.卡类别id%Type,
  消费卡_In       Integer := 0,
  刷卡卡号_In     病人医疗卡信息.卡号%Type,
  结帐id_In       病人预交记录.结帐id%Type,
  交易流水号_In   病人预交记录.交易流水号%Type := Null,
  交易说明_In     病人预交记录.交易说明%Type := Null,
  合作单位_In     病人预交记录.合作单位%Type := Null,
  摘要_In         住院费用记录.摘要%Type := Null,
  更新交款余额_In Number := 1,
  支付金额_In     病人预交记录.冲预交%Type := Null
) As
  --参数：发卡类型=0-发卡,1-补卡,2-换卡(相当于重打);8-发卡、补卡收取病历费;9绑定卡换卡收取病历费
  --      换卡时,单据号_IN传入的是原发/补卡的单据号。
  --      补卡/换卡后,再换卡时是以最后一次卡号为准。
  --     更新交款余额_In 是否更新人员交款余额，主要是处理统一操作员登录多台自助机的情况。
  Cursor c_Precard Is
    Select ID As 费用id From 住院费用记录 Where 记录性质 = 5 And 实际票号 = 原卡号_In And 病人id = 病人id_In;
  r_Cardrow c_Precard%RowType;

  Cursor c_医疗卡 Is
    Select ID, 编码, 名称, 短名, 前缀文本, 卡号长度, 缺省标志, 是否固定, 是否严格控制, Nvl(是否自制, 0) As 是否自制, Nvl(是否存在帐户, 0) As 是否存在帐户,
           Nvl(是否全退, 0) As 是否全退, 部件, 备注, 特定项目, 结算方式, 是否启用, 卡号密文, Nvl(是否重复使用, 0) As 是否重复使用

    
    From 医疗卡类别
    Where ID = 卡类别id_In;
  r_医疗卡 c_医疗卡%RowType;

  v_费用id         住院费用记录.Id%Type;
  v_结帐id         住院费用记录.结帐id%Type;
  v_收回id         票据打印内容.Id%Type;
  v_打印id         票据打印内容.Id%Type;
  n_回收次数       票据使用明细.回收次数%Type;
  n_性质           票据使用明细.性质%Type;
  n_返回值         病人余额.费用余额%Type;
  n_预交id         病人预交记录.Id%Type;
  n_医疗卡重复使用 Number(3);
  Err_Item Exception;
  v_Err_Msg  Varchar2(500);
  n_组id     财务缴款分组.Id%Type;
  n_变动类型 Number;
  n_序号     住院费用记录.序号%Type;
  n_支付金额 病人预交记录.冲预交%Type;
Begin

  If Nvl(支付金额_In, 0) <> 0 Then
    n_支付金额 := Nvl(支付金额_In, 0);
  Else
    n_支付金额 := 实收金额_In;
  End If;

  If 发卡类型_In <> 8 And 发卡类型_In <> 9 Then
    n_组id := Zl_Get组id(操作员姓名_In);
    Open c_医疗卡;
    Fetch c_医疗卡
      Into r_医疗卡;
    If c_医疗卡%RowCount = 0 Then
      Close c_医疗卡;
      v_Err_Msg := '[ZLSOFT]没有发现原医疗卡的相应类别,不能继续操作！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    n_医疗卡重复使用 := Nvl(r_医疗卡.是否重复使用, 0);
    Close c_医疗卡;
    If Not 结算方式_In Is Null Then
      If Nvl(结帐id_In, 0) <> 0 Then
        v_结帐id := 结帐id_In;
      Else
        Select 病人结帐记录_Id.Nextval Into v_结帐id From Dual;
      End If;
    End If;
    If 发卡类型_In <> 2 Then
      --发卡和补卡
      Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
    
      Insert Into 住院费用记录
        (ID, 记录性质, 记录状态, NO, 实际票号, 序号, 病人id, 主页id, 病人病区id, 病人科室id, 标识号, 姓名, 性别, 年龄, 费别, 记帐费用, 门诊标志, 加班标志, 开单部门id, 开单人,
         操作员编号, 操作员姓名, 发生时间, 登记时间, 收费细目id, 收费类别, 计算单位, 付数, 数次, 发药窗口, 附加标志, 执行部门id, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 结帐id,
         结帐金额, 缴款组id, 结论, 摘要)
      Values
        (v_费用id, 5, 1, 单据号_In, 医疗卡号_In, 1, 病人id_In, Decode(主页id_In, 0, Null, 主页id_In),
         Decode(病人病区id_In, 0, Null, 病人病区id_In), Decode(病人科室id_In, 0, Null, 病人科室id_In), Decode(标识号_In, 0, Null, 标识号_In),
         姓名_In, 性别_In, 年龄_In, 费别_In, Decode(结算方式_In, Null, 1, 0), 3, 加班标志_In, 开单部门id_In, 操作员姓名_In, 操作员编号_In, 操作员姓名_In,
         发卡时间_In, 发卡时间_In, 收费细目id_In, 收费类别_In, 计算单位_In, 1, 1, 医疗卡号_In, 发卡类型_In, 执行部门id_In, 收入项目id_In, 收据费目_In, 标准单价_In,
         应收金额_In, 实收金额_In, v_结帐id, Decode(结算方式_In, Null, Null, 实收金额_In), n_组id, 卡类别id_In, 摘要_In);
    
      --发卡使用票据
      Select 票据打印内容_Id.Nextval Into v_打印id From Dual;
      Insert Into 票据打印内容 (ID, 数据性质, NO) Values (v_打印id, 5, 单据号_In);
      n_回收次数 := 0;
      If n_医疗卡重复使用 = 1 Then
        Select Nvl(Max(回收次数), 0), Nvl(Max(性质), 0)
        Into n_回收次数, n_性质
        From 票据使用明细
        Where 票种 = 5 And 号码 = 医疗卡号_In;
        If n_回收次数 > 0 Or n_性质 > 0 Then
          n_回收次数 := n_回收次数 + 1;
        End If;
      Else
        --需要检查是否存在票据使用明细，如果存在，肯定会发生错误
        Select Nvl(Max(性质), 0)
        Into n_性质
        From 票据使用明细 A, 票据领用记录 B
        Where a.票种 = 5 And a.号码 = 医疗卡号_In And Nvl(a.领用id, 0) = Nvl(领用id_In, 0) And a.领用id = b.Id;
        If n_性质 <> 0 Then
          v_Err_Msg := '[ZLSOFT]卡号:' || 医疗卡号_In || ' 已经使用，不能再进行发卡操作,请检查![ZLSOFT]';
          Raise Err_Item;
        End If;
      End If;
    
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 回收次数, 打印id, 使用时间, 使用人)
      Values
        (票据使用明细_Id.Nextval, 5, 医疗卡号_In, 1, 1, 领用id_In, Decode(n_回收次数, 0, Null, n_回收次数), v_打印id, 发卡时间_In, 操作员姓名_In);
      --如果是回收,再发的,则不减剩余数量
      If Nvl(n_回收次数, 0) = 0 Then
        --该批领用状态变化
        Update 票据领用记录
        Set 当前号码 = 医疗卡号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
        Where ID = Nvl(领用id_In, 0);
      End If;
    Else
      --处理换卡方式
      --首先查找需要换卡的原医疗卡费用记录
      Open c_Precard;
      Fetch c_Precard
        Into r_Cardrow;
    
      If c_Precard%RowCount = 0 Then
        Close c_Precard;
        v_Err_Msg := '[ZLSOFT]没有发现原医疗卡发放记录,换卡操作失败！[ZLSOFT]';
        Raise Err_Item;
      Else
        --仅当有原费用记录时才处理
        --重打收回票据
        Begin
          Select ID
          Into v_收回id
          From (Select b.Id
                 From 票据使用明细 A, 票据打印内容 B
                 Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 5 And b.No = 单据号_In
                 Order By a.使用时间 Desc)
          Where Rownum < 2;
        Exception
          When Others Then
            Null;
        End;
      
        If v_收回id Is Not Null Then
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 回收次数, 打印id, 使用时间, 使用人)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 4, 领用id, 回收次数, 打印id, 发卡时间_In, 操作员姓名_In
            From 票据使用明细
            Where 打印id = v_收回id And 票种 = 5 And 性质 = 1;
        End If;
      
        --重打发出票据
        Select 票据打印内容_Id.Nextval Into v_打印id From Dual;
      
        Insert Into 票据打印内容 (ID, 数据性质, NO) Values (v_打印id, 5, 单据号_In);
        n_回收次数 := 0;
        If n_医疗卡重复使用 = 1 Then
          Select Nvl(Max(a.回收次数), 0), Nvl(Max(a.性质), 0)
          Into n_回收次数, n_性质
          From 票据使用明细 A, 票据打印内容 B, 住院费用记录 C
          Where a.打印id = b.Id And b.No = c.No And a.票种 = 5 And c.结论 = 卡类别id_In And c.记录性质 = 5 And a.号码 = 医疗卡号_In;
          If n_回收次数 > 0 Or n_性质 > 0 Then
            n_回收次数 := n_回收次数 + 1;
          End If;
        Else
          --需要检查是否存在票据使用明细，如果存在，肯定会发生错误
          Select Nvl(Max(性质), 0)
          Into n_性质
          From 票据使用明细 A, 票据领用记录 B
          Where a.票种 = 5 And a.号码 = 医疗卡号_In And Nvl(a.领用id, 0) = Nvl(领用id_In, 0) And a.领用id = b.Id;
          If n_性质 <> 0 Then
            v_Err_Msg := '[ZLSOFT]新卡号:' || 医疗卡号_In || ' 已经使用，请换一张新卡,请检查![ZLSOFT]';
            Raise Err_Item;
          End If;
        
        End If;
      
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 回收次数, 打印id, 使用时间, 使用人)
        Values
          (票据使用明细_Id.Nextval, 5, 医疗卡号_In, 1, Decode(v_收回id, Null, 1, 3), 领用id_In, Decode(n_回收次数, 0, Null, n_回收次数),
           v_打印id, 发卡时间_In, 操作员姓名_In);
        --如果是回收,再发的,则不减剩余数量
        If Nvl(n_回收次数, 0) = 0 Then
          --领用状态变化
          Update 票据领用记录
          Set 当前号码 = 医疗卡号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
          Where ID = Nvl(领用id_In, 0);
        End If;
        --更改原发卡记录状态
        Update 住院费用记录
        Set 实际票号 = 医疗卡号_In, 发药窗口 = 医疗卡号_In, 附加标志 = 2, 结论 = 卡类别id_In
        Where ID = r_Cardrow.费用id;
        Close c_Precard;
      End If;
    End If;
  
    --处理相关的变动信息
    --Zl_医疗卡变动_Insert (变动类型_In/病人id_In ,卡类别id_In, 原卡号_In, 医疗卡号_In, 变动原因_In, 密码_In, 操作员姓名_In, 变动时间_In
    --Ic卡号_In, 挂失方式_In)
    --变动类型_In:1-发卡(或11绑定卡);2-换卡;3-补卡(13-补卡停用);4-退卡(或14取消绑定); ５-密码调整(只记录);6-挂失(16取消挂失)
    n_变动类型 := Case
                When 发卡类型_In = 0 Then
                 1
                When 发卡类型_In = 1 Then
                 3
                Else
                 2
              End;
    Zl_医疗卡变动_Insert(n_变动类型, 病人id_In, 卡类别id_In, 原卡号_In, 医疗卡号_In, 变动原因_In, 密码_In, 操作员姓名_In, 发卡时间_In, Ic卡号_In, Null);
  Else
    --插入病历费
    n_序号 := Case
              When 发卡类型_In = 8 Then
               2
              When 发卡类型_In = 9 Then
               1
            End;
    If Not 结算方式_In Is Null Then
      If Nvl(结帐id_In, 0) <> 0 Then
        v_结帐id := 结帐id_In;
      Else
        Select 病人结帐记录_Id.Nextval Into v_结帐id From Dual;
      End If;
    End If;
    Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
  
    Insert Into 住院费用记录
      (ID, 记录性质, 记录状态, NO, 实际票号, 序号, 病人id, 主页id, 病人病区id, 病人科室id, 标识号, 姓名, 性别, 年龄, 费别, 记帐费用, 门诊标志, 加班标志, 开单部门id, 开单人,
       操作员编号, 操作员姓名, 发生时间, 登记时间, 收费细目id, 收费类别, 计算单位, 付数, 数次, 发药窗口, 附加标志, 执行部门id, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 结帐id,
       结帐金额, 缴款组id, 结论, 摘要)
    Values
      (v_费用id, 5, 1, 单据号_In, Null, n_序号, 病人id_In, Decode(主页id_In, 0, Null, 主页id_In),
       Decode(病人病区id_In, 0, Null, 病人病区id_In), Decode(病人科室id_In, 0, Null, 病人科室id_In), Decode(标识号_In, 0, Null, 标识号_In),
       姓名_In, 性别_In, 年龄_In, 费别_In, Decode(结算方式_In, Null, 1, 0), 3, 加班标志_In, 开单部门id_In, 操作员姓名_In, 操作员编号_In, 操作员姓名_In,
       发卡时间_In, 发卡时间_In, 收费细目id_In, 收费类别_In, 计算单位_In, 1, 1, Null, 8, 执行部门id_In, 收入项目id_In, 收据费目_In, 标准单价_In, 应收金额_In,
       实收金额_In, v_结帐id, Decode(结算方式_In, Null, Null, 实收金额_In), n_组id, Null, 摘要_In);
  End If;
  --发卡、补卡或者绑定卡、换卡发了病历本
  If 发卡类型_In <> 2 Then
    --如果是现收医疗卡费用，则将结算填入病人预交记录
    If Not 结算方式_In Is Null And 发卡类型_In <> 8 Then
      Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      Insert Into 病人预交记录
        (ID, NO, 记录性质, 记录状态, 病人id, 主页id, 科室id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 摘要, 缴款组id, 卡类别id, 卡号, 结算卡序号, 交易流水号,
         交易说明, 结算序号, 合作单位, 结算性质)
      Values
        (n_预交id, 单据号_In, 5, 1, 病人id_In, Decode(主页id_In, 0, Null, 主页id_In), Decode(病人科室id_In, 0, Null, 病人科室id_In),
         结算方式_In, 发卡时间_In, 操作员编号_In, 操作员姓名_In, n_支付金额, v_结帐id, '医疗卡费用', n_组id, Decode(消费卡_In, 0, 刷卡类别id_In, Null),
         刷卡卡号_In, Decode(消费卡_In, 0, Null, 刷卡类别id_In), 交易流水号_In, 交易说明_In, v_结帐id, 合作单位_In, 5);
    
      If 消费卡_In = 1 And 刷卡卡号_In Is Not Null And Nvl(n_支付金额, 0) <> 0 Then
        Zl_病人卡结算记录_支付(刷卡类别id_In, 刷卡卡号_In, 0, n_支付金额, n_预交id, 操作员编号_In, 操作员姓名_In, 发卡时间_In);
      End If;
    End If;
  
    --相关汇总表的处理
    If 结算方式_In Is Null Then
      --汇总'病人余额'
      Update 病人余额
      Set 费用余额 = Nvl(费用余额, 0) + 实收金额_In
      Where 性质 = 1 And 病人id = 病人id_In And Nvl(类型, 2) = Decode(Nvl(主页id_In, 0), 0, 1, 2)
      Returning 费用余额 Into n_返回值;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 预交余额, 费用余额)
        Values
          (病人id_In, 1, Decode(Nvl(主页id_In, 0), 0, 1, 2), 0, 实收金额_In);
        n_返回值 := 实收金额_In;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --汇总'病人未结费用'
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) + 实收金额_In
      Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0) And Nvl(病人病区id, 0) = Nvl(病人病区id_In, 0) And
            Nvl(病人科室id, 0) = Nvl(病人科室id_In, 0) And Nvl(开单部门id, 0) = Nvl(开单部门id_In, 0) And
            Nvl(执行部门id, 0) = Nvl(执行部门id_In, 0) And 收入项目id + 0 = 收入项目id_In And 来源途径 = 3;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人未结费用
          (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
        Values
          (病人id_In, Decode(主页id_In, 0, Null, 主页id_In), Decode(病人病区id_In, 0, Null, 病人病区id_In),
           Decode(病人科室id_In, 0, Null, 病人科室id_In), 开单部门id_In, 执行部门id_In, 收入项目id_In, 3, 实收金额_In);
      End If;
    
    Else
      --汇总"人员缴款余额"
      If Nvl(更新交款余额_In, 1) = 1 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + 实收金额_In
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = 结算方式_In
        Returning 余额 Into n_返回值;
      
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, 结算方式_In, 1, 实收金额_In);
          n_返回值 := 实收金额_In;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = 结算方式_In And Nvl(余额, 0) = 0;
        End If;
      End If;
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_医疗卡记录_Insert;
/

--121560:冉俊明,2018-02-07,如果消费卡的退卡(回收)记录已轧账，则不允许取消退卡(取消回收)
--117147:冉俊明,2017-12-18,消费卡管理误差费处理
Create Or Replace Procedure Zl_消费卡信息_Backcard
(
  消费卡id_In   消费卡信息.Id%Type,
  操作员编号_In 病人卡结算记录.操作员编号%Type,
  操作员姓名_In 病人卡结算记录.操作员姓名%Type,
  退卡时间_In   消费卡信息.回收时间%Type,
  结算方式_In   病人卡结算记录.结算方式%Type,
  结算序号_In   病人卡结算记录.Id%Type,
  误差金额_In   病人卡结算记录.实收金额%Type,
  取消退卡_In   Number := 0,
  结算号码_In   病人卡结算记录.结算号码%Type := Null,
  开户行_In     病人卡结算记录.单位开户行%Type := Null,
  帐号_In       病人卡结算记录.单位帐号%Type := Null,
  卡类别id_In   病人卡结算记录.卡类别id%Type := Null,
  结算卡号_In   病人卡结算记录.结算卡号%Type := Null,
  交易流水号_In 病人卡结算记录.交易流水号%Type := Null,
  交易说明_In   病人卡结算记录.交易说明%Type := Null,
  缴款_In       病人卡结算记录.缴款%Type := Null,
  找补_In       病人卡结算记录.找补%Type := Null
) Is
  --退卡、取消退卡
  Err_Item Exception;
  v_Err_Msg Varchar2(500);

  n_接口编号 消费卡信息.接口编号%Type;
  v_卡号     消费卡信息.卡号%Type;
  v_卡名称   消费卡类别目录.名称%Type;
  d_回收时间 消费卡信息.回收时间%Type;
  d_停用时间 消费卡信息.停用日期%Type;
  d_有效期   消费卡信息.有效期%Type;
  n_存在卡片 Number(2);
  n_最大序号 消费卡信息.序号%Type;
  n_序号     消费卡信息.序号%Type;
  v_发卡人   消费卡信息.发卡人%Type;
  n_领用id   消费卡信息.领用id%Type;

  n_Id       病人卡结算记录.Id%Type;
  n_充值序号 病人卡结算记录.序号%Type;
  n_余额     消费卡信息.余额%Type;
  n_返回值   消费卡信息.销售金额%Type;
  n_Count    Number(2);

  v_误差费   结算方式.名称%Type;
  n_误差金额 病人卡结算记录.实收金额%Type;

  n_组id 财务缴款分组.Id%Type;
Begin
  --检查当前卡号
  Begin
    Select b.名称, a.卡号, 1, a.回收时间, a.停用日期,
           (Select Max(序号) From 消费卡信息 B Where a.卡号 = b.卡号 And a.接口编号 = b.接口编号), a.序号, a.发卡人, a.接口编号, a.有效期,
           Nvl(a.领用id, 0)
    Into v_卡名称, v_卡号, n_存在卡片, d_回收时间, d_停用时间, n_最大序号, n_序号, v_发卡人, n_接口编号, d_有效期, n_领用id
    From 消费卡信息 A, 消费卡类别目录 B
    Where a.接口编号 = b.编号 And a.Id = 消费卡id_In;
  Exception
    When Others Then
      n_存在卡片 := 0;
  End;

  n_组id := Zl_Get组id(操作员姓名_In);

  If Nvl(取消退卡_In, 0) = 0 Then
    If n_存在卡片 = 0 Then
      v_Err_Msg := '未找到卡记录，可能已被他人删除，不能再退卡！';
      Raise Err_Item;
    End If;
    If Nvl(n_序号, 0) < Nvl(n_最大序号, 0) Then
      v_Err_Msg := '不能对历史发放的' || v_卡名称 || '(卡号为“' || v_卡号 || '”)进行退卡！';
      Raise Err_Item;
    End If;
    If Nvl(d_回收时间, To_Date('3000-01-01', 'yyyy-mm-dd')) < To_Date('3000-01-01', 'yyyy-mm-dd') Then
      v_Err_Msg := '卡号为“' || v_卡号 || '”的' || v_卡名称 || '已经退卡，不能再退卡！';
      Raise Err_Item;
    End If;
    If Nvl(d_停用时间, To_Date('3000-01-01', 'yyyy-mm-dd')) < To_Date('3000-01-01', 'yyyy-mm-dd') Then
      v_Err_Msg := '卡号为“' || v_卡号 || '”的' || v_卡名称 || '已经停止使用，不能再退卡！';
      Raise Err_Item;
    End If;
  
    If 操作员姓名_In <> v_发卡人 Then
      v_Err_Msg := '卡号为“' || v_卡号 || '”的' || v_卡名称 || '不是你发放的卡，不能退卡！';
      Raise Err_Item;
    End If;
  
    Select Count(1) Into n_Count From 病人卡结算记录 Where 消费卡id = 消费卡id_In And 记录性质 = 4 And Rownum < 2;
    If n_Count > 0 Then
      v_Err_Msg := '卡号为“' || v_卡号 || '”的' || v_卡名称 || '已经发生消费，不能再退卡处理，只能回收卡片！';
      Raise Err_Item;
    End If;
  
    Select Count(1)
    Into n_Count
    From (Select 1
           From 病人卡结算记录　where 消费卡id = 消费卡id_In And 记录性质 = 2 And 记录状态 = 1
           Having Count(1) > 1);
    If n_Count > 0 Then
      v_Err_Msg := '卡号为“' || v_卡号 || '”的' || v_卡名称 || '已经被多次充值，不能再退卡处理，只能回收卡片！';
      Raise Err_Item;
    End If;
  
    Select Count(1) Into n_Count From 病人卡结算记录　where 消费卡id = 消费卡id_In And 记录性质 = 3 And Rownum < 2;
    If n_Count > 0 Then
      v_Err_Msg := '卡号为“' || v_卡号 || '”的' || v_卡名称 || '已进行了余额退款，不能再退卡处理，只能回收卡片！';
      Raise Err_Item;
    End If;
  
    Update 消费卡信息
    Set 回收时间 = 退卡时间_In, 回收人 = 操作员姓名_In, 当前状态 = 3, 回收组id = n_组id, 余额 = 0
    Where ID = 消费卡id_In And (回收时间 Is Null Or 回收时间 >= To_Date('3000-01-01', 'yyyy-mm-dd'));
    If Sql%NotFound Then
      v_Err_Msg := '卡号为“' || v_卡号 || '”的' || v_卡名称 || '可能被他人退卡，不能再退卡！';
      Raise Err_Item;
    End If;
  
    n_Id := 结算序号_In;
    --误差金额放在第一条记录的实收金额上，同时产生一条结算方式为“误差费”的记录
    n_误差金额 := Nvl(误差金额_In, 0);
    For c_记录 In (Select a.Id, a.记录性质, a.应收金额, Nvl(a.实收金额, 0) As 缴款金额, a.交易序号, a.序号, a.病人id
                 From 病人卡结算记录 A
                 Where a.消费卡id = 消费卡id_In And a.记录性质 In (1, 2) And a.记录状态 = 1 And a.交易序号 Is Not Null) Loop
      Update 病人卡结算记录 Set 记录状态 = 3 Where ID = c_记录.Id;
    
      If n_Id = 0 Then
        Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      End If;
    
      Insert Into 病人卡结算记录
        (ID, 接口编号, 记录性质, 记录状态, 消费卡id, 卡号, 序号, 应收金额, 扣率, 实收金额, 结算id, 结算方式, 结算序号, 缴款, 找补, 缴款组id, 缴款人姓名, 病人id, 单位开户行, 单位帐号,
         结算号码, 卡类别id, 结算卡号, 交易流水号, 交易说明, 交易时间, 备注, 结算标志, 操作员编号, 操作员姓名, 登记时间, 交易序号)
        Select n_Id, 接口编号, 记录性质, 2, 消费卡id, 卡号, 序号, -1 * 应收金额, 扣率, -1 * (Nvl(实收金额, 0) - n_误差金额), n_Id, 结算方式_In, 结算序号_In,
               缴款_In, 找补_In, n_组id, 缴款人姓名, 病人id, 开户行_In, 帐号_In, 结算号码_In, 卡类别id_In, 结算卡号_In, 交易流水号_In, 交易说明_In, 退卡时间_In,
               备注, 1, 操作员编号_In, 操作员姓名_In, 退卡时间_In, 交易序号
        From 病人卡结算记录
        Where ID = c_记录.Id;
    
      Update 帐户缴款余额
      Set 余额 = Nvl(余额, 0) - Nvl(c_记录.应收金额, 0),
          实际缴款 =
           (Nvl(余额, 0) - Nvl(c_记录.应收金额, 0)) * 扣率 / 100
      Where 性质 = 1 And 交易序号 = c_记录.交易序号 And 消费卡id = 消费卡id_In
      Returning 余额 Into n_返回值;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 帐户缴款余额 Where 性质 = 1 And 交易序号 = c_记录.交易序号 And 消费卡id = 消费卡id_In;
      End If;
    
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) - (c_记录.缴款金额 - n_误差金额)
      Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = 结算方式_In
      Returning 余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (操作员姓名_In, 结算方式_In, 1, -1 * (c_记录.缴款金额 - n_误差金额));
        n_返回值 := -1 * (c_记录.缴款金额 - n_误差金额);
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete 人员缴款余额 Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = 结算方式_In And Nvl(余额, 0) = 0;
      End If;
    
      --插入误差记录
      If n_误差金额 <> 0 Then
        Begin
          Select 名称 Into v_误差费 From 结算方式 Where Nvl(性质, 0) = 9;
        Exception
          When Others Then
            v_误差费 := '误差费';
        End;
      
        Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
        Insert Into 病人卡结算记录
          (ID, 接口编号, 记录性质, 记录状态, 消费卡id, 卡号, 序号, 应收金额, 扣率, 实收金额, 结算id, 结算方式, 结算序号, 缴款组id, 病人id, 交易时间, 结算标志, 操作员编号, 操作员姓名,
           登记时间, 交易序号)
        Values
          (n_Id, n_接口编号, c_记录.记录性质, 2, 消费卡id_In, v_卡号, c_记录.序号, 0, 0, -1 * n_误差金额, n_Id, v_误差费, 结算序号_In, n_组id,
           c_记录.病人id, 退卡时间_In, 1, 操作员编号_In, 操作员姓名_In, 退卡时间_In, Null);
      
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) - n_误差金额
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_误差费
        Returning 余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, v_误差费, 1, -1 * n_误差金额);
          n_返回值 := -1 * n_误差金额;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete 人员缴款余额 Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_误差费 And Nvl(余额, 0) = 0;
        End If;
      End If;
    
      n_Id       := 0;
      n_误差金额 := 0;
    End Loop;
  
    Insert Into 消费卡使用记录
      (ID, 卡号, 性质, 原因, 领用id, 回收次数, 接口编号, 使用时间, 使用人)
      Select 消费卡使用记录_Id.Nextval, 卡号, 2, 2, 领用id, 回收次数, 接口编号, 退卡时间_In, 操作员姓名_In
      From 消费卡使用记录 A
      Where 接口编号 = n_接口编号 And 卡号 = v_卡号 And
            Nvl(回收次数, 0) =
            (Select Nvl(Max(回收次数), 0) From 消费卡使用记录 Where 接口编号 = a.接口编号 And 卡号 = a.卡号 And 性质 = 1) And Not Exists
       (Select 1
             From 消费卡使用记录
             Where 接口编号 = a.接口编号 And 卡号 = a.卡号 And Nvl(回收次数, 0) = Nvl(a.回收次数, 0) And 性质 = 2);
  
    --处理相关的变动信息 
    Zl_消费卡变动记录_Insert(4, 消费卡id_In, '退卡', v_卡号, 操作员姓名_In, 退卡时间_In);
    Return;
  End If;

  --取消退卡
  If n_存在卡片 = 0 Then
    v_Err_Msg := '未找到卡记录，可能已被他人删除，不能再取消退卡！';
    Raise Err_Item;
  End If;
  If Nvl(n_序号, 0) < Nvl(n_最大序号, 0) Then
    v_Err_Msg := '不能对历史发放的' || v_卡名称 || '(卡号为“' || v_卡号 || '”)取消退卡！';
    Raise Err_Item;
  End If;
  If Nvl(d_回收时间, To_Date('3000-01-01', 'yyyy-mm-dd')) >= To_Date('3000-01-01', 'yyyy-mm-dd') Then
    v_Err_Msg := '卡号为“' || v_卡号 || '”的' || v_卡名称 || '可能被他人取消退卡(在用)，不能再取消退卡！';
    Raise Err_Item;
  End If;
  If Nvl(d_停用时间, To_Date('3000-01-01', 'yyyy-mm-dd')) < To_Date('3000-01-01', 'yyyy-mm-dd') Then
    v_Err_Msg := '卡号为“' || v_卡号 || '”的' || v_卡名称 || '已经停止使用，不能取消退卡！';
    Raise Err_Item;
  End If;
  If 操作员姓名_In <> v_发卡人 Then
    v_Err_Msg := '卡号为“' || v_卡号 || '”的' || v_卡名称 || '不是你的卡，不能取消退卡！';
    Raise Err_Item;
  End If;

  --已轧账的卡不允许再取消退卡
  Select Count(1)
  Into n_Count
  From 消费卡使用记录 A, 消费卡领用记录 B, 人员收缴票据 C, 人员收缴记录 D
  Where a.领用id = b.Id(+) And c.收缴id = d.Id And a.使用时间 Between d.开始时间 And d.终止时间 And Nvl(c.批次, '-') = Nvl(b.批次, '-') And
        Length(c.开始票号) = Length(a.卡号) And a.卡号 Between c.开始票号 And c.终止票号 And d.作废时间 Is Null And c.票种 = 6 And c.性质 = 2 And
        a.接口编号 = n_接口编号 And a.卡号 = v_卡号 And a.性质 = 2 And Nvl(a.领用id, 0) = n_领用id And Rownum < 2;
  If Nvl(n_Count, 0) <> 0 Then
    v_Err_Msg := '卡号为“' || v_卡号 || '”的' || v_卡名称 || '已进行了轧账处理，不允许再取消退卡！';
    Raise Err_Item;
  End If;

  --恢复卡面额及充值记录
  Select Nvl(Max(a.序号), 0) + 1
  Into n_充值序号
  From 病人卡结算记录 A
  Where a.记录性质 = 1 And a.消费卡id = 消费卡id_In;

  n_余额 := 0;
  n_Id   := 结算序号_In;
  --误差金额放在第一条记录的实收金额上，同时产生一条结算方式为“误差费”的记录
  n_误差金额 := Nvl(误差金额_In, 0);
  For c_记录 In (Select a.Id, a.记录性质, Nvl(a.应收金额, 0) As 应收金额, Nvl(a.实收金额, 0) As 缴款金额, a.病人id
               From 病人卡结算记录 A, 消费卡信息 B
               Where a.消费卡id = b.Id And a.序号 = b.序号 And a.消费卡id = 消费卡id_In And a.记录性质 In (1, 2) And a.记录状态 = 3 And
                     a.交易序号 Is Not Null) Loop
    If n_Id = 0 Then
      Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
    End If;
  
    Insert Into 病人卡结算记录
      (ID, 接口编号, 记录性质, 记录状态, 消费卡id, 卡号, 序号, 应收金额, 扣率, 实收金额, 结算id, 结算方式, 结算序号, 缴款, 找补, 缴款组id, 缴款人姓名, 病人id, 单位开户行, 单位帐号,
       结算号码, 卡类别id, 结算卡号, 交易流水号, 交易说明, 交易时间, 备注, 结算标志, 操作员编号, 操作员姓名, 登记时间, 交易序号)
      Select n_Id, 接口编号, 记录性质, 1, 消费卡id, 卡号, n_充值序号, 应收金额, 扣率, Nvl(实收金额, 0) - n_误差金额, n_Id, 结算方式_In, 结算序号_In, 缴款_In,
             找补_In, n_组id, 缴款人姓名, 病人id, 开户行_In, 帐号_In, 结算号码_In, 卡类别id_In, 结算卡号_In, 交易流水号_In, 交易说明_In, 退卡时间_In, 备注, 1,
             操作员编号_In, 操作员姓名_In, 退卡时间_In, n_Id
      From 病人卡结算记录
      Where ID = c_记录.Id;
  
    Insert Into 帐户缴款余额
      (性质, 消费卡id, 结算方式, 余额, 扣率, 实际缴款, 卡类别id, 卡号, 交易流水号, 交易说明, 有效期, 交易序号, 缴款时间)
      Select 1, 消费卡id, 结算方式_In, 应收金额, 扣率, 实收金额, 卡类别id_In, 结算卡号_In, 交易流水号_In, 交易说明_In,
             Decode(记录性质, 1, Nvl(d_有效期, To_Date('3000-01-01', 'yyyy-mm-dd')), To_Date('3000-01-01', 'yyyy-mm-dd')), n_Id,
             退卡时间_In - Decode(记录性质, 1, 1 / 24 / 60 / 60, 0)
      From 病人卡结算记录
      Where ID = c_记录.Id;
  
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + (Nvl(c_记录.缴款金额, 0) - n_误差金额)
    Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = 结算方式_In
    Returning 余额 Into n_返回值;
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额
        (收款员, 结算方式, 性质, 余额)
      Values
        (操作员姓名_In, 结算方式_In, 1, Nvl(c_记录.缴款金额, 0) - n_误差金额);
      n_返回值 := Nvl(c_记录.缴款金额, 0) - n_误差金额;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete 人员缴款余额 Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = 结算方式_In And Nvl(余额, 0) = 0;
    End If;
  
    --插入误差记录
    If n_误差金额 <> 0 Then
      Begin
        Select 名称 Into v_误差费 From 结算方式 Where Nvl(性质, 0) = 9;
      Exception
        When Others Then
          v_误差费 := '误差费';
      End;
    
      Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      Insert Into 病人卡结算记录
        (ID, 接口编号, 记录性质, 记录状态, 消费卡id, 卡号, 序号, 应收金额, 扣率, 实收金额, 结算id, 结算方式, 结算序号, 缴款组id, 病人id, 交易时间, 结算标志, 操作员编号, 操作员姓名,
         登记时间, 交易序号)
      Values
        (n_Id, n_接口编号, c_记录.记录性质, 1, 消费卡id_In, v_卡号, n_充值序号, 0, 0, n_误差金额, n_Id, v_误差费, 结算序号_In, n_组id, c_记录.病人id,
         退卡时间_In, 1, 操作员编号_In, 操作员姓名_In, 退卡时间_In, Null);
    
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + n_误差金额
      Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_误差费
      Returning 余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, v_误差费, 1, n_误差金额);
        n_返回值 := n_误差金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete 人员缴款余额 Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_误差费 And Nvl(余额, 0) = 0;
      End If;
    End If;
  
    n_余额     := n_余额 + Nvl(c_记录.应收金额, 0);
    n_Id       := 0;
    n_误差金额 := 0;
  End Loop;

  Update 消费卡信息
  Set 回收人 = Null, 回收时间 = Null, 当前状态 = 1, 回收组id = Null, 余额 = n_余额
  Where ID = 消费卡id_In And 回收时间 Is Not Null;

  Delete From 消费卡使用记录 A
  Where 接口编号 = n_接口编号 And 卡号 = v_卡号 And
        Nvl(回收次数, 0) =
        (Select Nvl(Max(回收次数), 0) From 消费卡使用记录 Where 接口编号 = a.接口编号 And 卡号 = a.卡号 And 性质 = 1) And 性质 = 2 And 原因 = 2;

  --处理相关的变动信息 
  Zl_消费卡变动记录_Insert(14, 消费卡id_In, '取消退卡', v_卡号, 操作员姓名_In, 退卡时间_In);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_消费卡信息_Backcard;
/

--117147:冉俊明,2017-12-18,消费卡管理误差费处理
Create Or Replace Procedure Zl_病人卡结算记录_充值回退
(
  Id_In         病人卡结算记录.Id%Type,
  操作员编号_In 病人卡结算记录.操作员编号%Type,
  操作员姓名_In 病人卡结算记录.操作员姓名%Type,
  结算方式_In   病人卡结算记录.结算方式%Type,
  结算序号_In   病人卡结算记录.结算序号%Type,
  误差金额_In   病人卡结算记录.实收金额%Type,
  结算号码_In   病人卡结算记录.结算号码%Type := Null,
  开户行_In     病人卡结算记录.单位开户行%Type := Null,
  帐号_In       病人卡结算记录.单位帐号%Type := Null,
  卡类别id_In   病人卡结算记录.卡类别id%Type := Null,
  结算卡号_In   病人卡结算记录.结算卡号%Type := Null,
  交易流水号_In 病人卡结算记录.交易流水号%Type := Null,
  交易说明_In   病人卡结算记录.交易说明%Type := Null,
  缴款_In       病人卡结算记录.缴款%Type := Null,
  找补_In       病人卡结算记录.找补%Type := Null
) Is
  Err_Item Exception;
  v_Err_Msg Varchar2(500);

  Cursor c_充值 Is
    Select 消费卡id, 应收金额 As 充值金额, 实收金额 As 缴款金额, 结算方式, 交易序号, 病人id, 序号
    From 病人卡结算记录
    Where ID = Id_In;
  r_记录 c_充值%RowType;

  n_接口编号 消费卡类别目录.编号%Type;
  n_消费卡id 消费卡信息.Id%Type;
  v_卡号     消费卡信息.卡号%Type;
  v_卡名称   消费卡类别目录.名称%Type;
  d_回收时间 消费卡信息.回收时间%Type;
  d_停用时间 消费卡信息.停用日期%Type;
  n_存在卡片 Number(2);
  n_最大序号 消费卡信息.序号%Type;
  n_序号     消费卡信息.序号%Type;
  n_余额     消费卡信息.余额%Type;

  n_交易序号 病人卡结算记录.交易序号%Type;
  n_Id       病人卡结算记录.Id%Type;
  n_返回值   人员缴款余额.余额%Type;
  n_组id     财务缴款分组.Id%Type;
  v_误差费   结算方式.名称%Type;
  n_Count    Number;
Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  Open c_充值;
  Fetch c_充值
    Into r_记录;

  --检查当前卡号是否已经使用
  Begin
    Select a.Id, b.编号, b.名称, a.卡号, 1, a.回收时间, a.停用日期,
           (Select Max(序号) From 消费卡信息 B Where a.卡号 = b.卡号 And a.接口编号 = b.接口编号), a.序号, a.余额
    Into n_消费卡id, n_接口编号, v_卡名称, v_卡号, n_存在卡片, d_回收时间, d_停用时间, n_最大序号, n_序号, n_余额
    From 消费卡信息 A, 消费卡类别目录 B
    Where a.接口编号 = b.编号 And a.Id = r_记录.消费卡id;
  Exception
    When Others Then
      n_存在卡片 := 0;
  End;

  --取消回收
  If n_存在卡片 = 0 Then
    v_Err_Msg := '未找到卡记录，可能已被他人删除，不能充值回退！';
    Raise Err_Item;
  End If;
  If Nvl(n_序号, 0) < Nvl(n_最大序号, 0) Then
    v_Err_Msg := '不能对历史发放的' || v_卡名称 || '(卡号为“' || v_卡号 || '”)进行充值回退！';
    Raise Err_Item;
  End If;
  If Nvl(d_回收时间, To_Date('3000-01-01', 'yyyy-mm-dd')) < To_Date('3000-01-01', 'yyyy-mm-dd') Then
    v_Err_Msg := '卡号为“' || v_卡号 || '”的' || v_卡名称 || '可能被他人回收或退卡，不能充值回退！';
    Raise Err_Item;
  End If;
  If Nvl(d_停用时间, To_Date('3000-01-01', 'yyyy-mm-dd')) < To_Date('3000-01-01', 'yyyy-mm-dd') Then
    v_Err_Msg := '卡号为“' || v_卡号 || '”的' || v_卡名称 || '已经停止使用，不能充值回退！';
    Raise Err_Item;
  End If;

  --检查余额是否充足
  If Nvl(n_余额, 0) - Nvl(r_记录.充值金额, 0) < 0 Then
    v_Err_Msg := '卡号为“' || v_卡号 || '”的' || v_卡名称 || '的余额不足，不能充值回退！';
    Raise Err_Item;
  End If;

  --只有升级以后的才进行检查  And b.交易序号 > 0
  Select Count(1)
  Into n_Count
  From 病人卡结算记录 A, 帐户缴款余额 B
  Where a.交易序号 = b.交易序号 And a.消费卡id = b.消费卡id And (a.应收金额 = b.余额 Or b.交易序号 <= 0) And a.Id = Id_In;
  If n_Count = 0 Then
    v_Err_Msg := '该笔充值也被消费使用，不能充值回退！';
    Raise Err_Item;
  End If;

  --需要更新余额
  Update 消费卡信息 Set 余额 = Nvl(余额, 0) - Nvl(r_记录.充值金额, 0) Where ID = r_记录.消费卡id;
  If Sql%NotFound Then
    v_Err_Msg := '卡号为“' || v_卡号 || '”的' || v_卡名称 || '可能被他人删除，不能充值回退！';
    Raise Err_Item;
  End If;

  Update 病人卡结算记录 Set 记录状态 = 3 Where ID = Id_In Returning 交易序号 Into n_交易序号;

  n_Id := 结算序号_In;
  Insert Into 病人卡结算记录
    (ID, 接口编号, 记录性质, 记录状态, 消费卡id, 卡号, 序号, 应收金额, 扣率, 实收金额, 结算id, 结算方式, 结算序号, 缴款, 找补, 缴款组id, 缴款人姓名, 病人id, 单位开户行, 单位帐号,
     结算号码, 卡类别id, 结算卡号, 交易流水号, 交易说明, 交易时间, 备注, 结算标志, 操作员编号, 操作员姓名, 登记时间, 交易序号)
    Select n_Id, 接口编号, 2, 2, 消费卡id, 卡号, 序号, -1 * 应收金额, 扣率, -1 * (Nvl(实收金额, 0) - Nvl(误差金额_In, 0)), n_Id, 结算方式_In, 结算序号_In,
           缴款_In, 找补_In, n_组id, Null, 病人id, 开户行_In, 帐号_In, 结算号码_In, 卡类别id_In, 结算卡号_In, 交易流水号_In, 交易说明_In, Sysdate, 备注, 1,
           操作员编号_In, 操作员姓名_In, Sysdate, 交易序号
    From 病人卡结算记录
    Where ID = Id_In;

  Update 帐户缴款余额
  Set 余额 = Nvl(余额, 0) - Nvl(r_记录.充值金额, 0),
      实际缴款 =
       (Nvl(余额, 0) - Nvl(r_记录.充值金额, 0)) * 扣率 / 100
  Where 性质 = 1 And 交易序号 = r_记录.交易序号 And 消费卡id = r_记录.消费卡id
  Returning 余额 Into n_返回值;
  If Nvl(n_返回值, 0) = 0 Then
    Delete From 帐户缴款余额 Where 性质 = 1 And 交易序号 = r_记录.交易序号 And 消费卡id = r_记录.消费卡id;
  End If;

  Update 人员缴款余额
  Set 余额 = Nvl(余额, 0) - (Nvl(r_记录.缴款金额, 0) - Nvl(误差金额_In, 0))
  Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = 结算方式_In
  Returning 余额 Into n_返回值;
  If Sql%RowCount = 0 Then
    Insert Into 人员缴款余额
      (收款员, 结算方式, 性质, 余额)
    Values
      (操作员姓名_In, 结算方式_In, 1, -1 * (Nvl(r_记录.缴款金额, 0) - Nvl(误差金额_In, 0)));
    n_返回值 := (Nvl(r_记录.缴款金额, 0) - Nvl(误差金额_In, 0));
  End If;
  If Nvl(n_返回值, 0) = 0 Then
    Delete 人员缴款余额 Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = 结算方式_In And Nvl(余额, 0) = 0;
  End If;

  --插入误差记录
  If Nvl(误差金额_In, 0) <> 0 Then
    Begin
      Select 名称 Into v_误差费 From 结算方式 Where Nvl(性质, 0) = 9;
    Exception
      When Others Then
        v_误差费 := '误差费';
    End;
  
    Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
    Insert Into 病人卡结算记录
      (ID, 接口编号, 记录性质, 记录状态, 消费卡id, 卡号, 序号, 应收金额, 扣率, 实收金额, 结算id, 结算方式, 结算序号, 缴款组id, 病人id, 交易时间, 结算标志, 操作员编号, 操作员姓名,
       登记时间, 交易序号)
    Values
      (n_Id, n_接口编号, 2, 2, n_消费卡id, v_卡号, r_记录.序号, 0, 0, -1 * Nvl(误差金额_In, 0), n_Id, v_误差费, 结算序号_In, n_组id, r_记录.病人id,
       Sysdate, 1, 操作员编号_In, 操作员姓名_In, Sysdate, Null);
  
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) - Nvl(误差金额_In, 0)
    Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_误差费
    Returning 余额 Into n_返回值;
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额
        (收款员, 结算方式, 性质, 余额)
      Values
        (操作员姓名_In, v_误差费, 1, -1 * Nvl(误差金额_In, 0));
      n_返回值 := -1 * Nvl(误差金额_In, 0);
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete 人员缴款余额 Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_误差费 And Nvl(余额, 0) = 0;
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人卡结算记录_充值回退;
/

--117147:冉俊明,2017-12-18,消费卡管理误差费处理
Create Or Replace Procedure Zl_消费卡信息_余额退款
(
  消费卡id_In   消费卡信息.Id%Type,
  交易序号_In   Varchar2,
  结算方式_In   帐户缴款余额.结算方式%Type,
  退款金额_In   病人卡结算记录.实收金额%Type,
  误差金额_In   病人卡结算记录.实收金额%Type,
  退款时间_In   消费卡信息.回收时间%Type,
  操作员编号_In 病人卡结算记录.操作员编号%Type,
  操作员姓名_In 病人卡结算记录.操作员姓名%Type,
  结算序号_In   病人卡结算记录.结算序号%Type,
  开户行_In     病人卡结算记录.单位开户行%Type := Null,
  帐号_In       病人卡结算记录.单位帐号%Type := Null,
  结算号码_In   病人卡结算记录.结算号码%Type := Null,
  卡类别id_In   病人卡结算记录.卡类别id%Type := Null,
  结算卡号_In   病人卡结算记录.结算卡号%Type := Null,
  交易流水号_In 病人卡结算记录.交易流水号%Type := Null,
  交易说明_In   病人卡结算记录.交易说明%Type := Null,
  缴款_In       病人卡结算记录.缴款%Type := Null,
  找补_In       病人卡结算记录.找补%Type := Null
) Is
  --交易序号_In 多个用逗号分隔
  --退款金额_In 用于校验，从帐户中实际退回的金额
  --说明：
  --        本次实际退给病人的金额=退款金额_In-误差金额_In
  Err_Item Exception;
  v_Err_Msg Varchar2(500);

  n_接口编号     消费卡信息.接口编号%Type;
  v_卡名称       消费卡类别目录.名称%Type;
  n_特定病人     消费卡类别目录.是否特定病人%Type;
  n_允许余额退款 消费卡类别目录.是否允许余额退款%Type;

  v_卡号     消费卡信息.卡号%Type;
  d_回收时间 消费卡信息.回收时间%Type;
  d_停用时间 消费卡信息.停用日期%Type;
  n_存在卡片 Number(2);
  n_最大序号 消费卡信息.序号%Type;
  n_序号     消费卡信息.序号%Type;
  n_病人id   消费卡信息.病人id%Type;
  n_卡余额   消费卡信息.余额%Type;

  n_剩余退款金额 消费卡信息.余额%Type;
  n_返回值       消费卡信息.销售金额%Type;

  v_误差费   结算方式.名称%Type;
  n_误差金额 病人卡结算记录.实收金额%Type;

  n_Id       病人卡结算记录.Id%Type;
  n_记录序号 病人卡结算记录.序号%Type;
  n_组id     财务缴款分组.Id%Type;
Begin
  --检查当前卡号
  Begin
    Select 1, b.名称, b.是否特定病人, b.是否允许余额退款, a.卡号, a.回收时间, a.停用日期,
           (Select Max(序号) From 消费卡信息 B Where a.卡号 = b.卡号 And a.接口编号 = b.接口编号), a.序号, a.接口编号, 病人id, Nvl(a.余额, 0)
    Into n_存在卡片, v_卡名称, n_特定病人, n_允许余额退款, v_卡号, d_回收时间, d_停用时间, n_最大序号, n_序号, n_接口编号, n_病人id, n_卡余额
    From 消费卡信息 A, 消费卡类别目录 B
    Where a.接口编号 = b.编号 And a.Id = 消费卡id_In;
  Exception
    When Others Then
      n_存在卡片 := 0;
  End;

  If n_存在卡片 = 0 Then
    v_Err_Msg := '未找到卡记录，可能已被他人删除！';
    Raise Err_Item;
  End If;
  If Nvl(n_允许余额退款, 0) = 0 Then
    v_Err_Msg := v_卡名称 || '不支持余额退款！';
    Raise Err_Item;
  End If;

  If Nvl(n_序号, 0) < Nvl(n_最大序号, 0) Then
    v_Err_Msg := '不能对历史发放的' || v_卡名称 || '(卡号为“' || v_卡号 || '”)进行余额退款！';
    Raise Err_Item;
  End If;
  If Nvl(d_回收时间, To_Date('3000-01-01', 'yyyy-mm-dd')) < To_Date('3000-01-01', 'yyyy-mm-dd') Then
    v_Err_Msg := '卡号为“' || v_卡号 || '”的' || v_卡名称 || '已经退卡，不能再余额退款！';
    Raise Err_Item;
  End If;
  If Nvl(d_停用时间, To_Date('3000-01-01', 'yyyy-mm-dd')) < To_Date('3000-01-01', 'yyyy-mm-dd') Then
    v_Err_Msg := '卡号为“' || v_卡号 || '”的' || v_卡名称 || '已经停止使用，不能再余额退款！';
    Raise Err_Item;
  End If;

  n_组id         := Zl_Get组id(操作员姓名_In);
  n_剩余退款金额 := Nvl(退款金额_In, 0);
  --误差金额放在第一条记录的实收金额上，同时产生一条结算方式为“误差费”的记录
  n_误差金额 := Nvl(误差金额_In, 0);
  For c_记录 In (Select /*+cardinality(b,10)*/
                Nvl(a.余额, 0) As 退余额, a.扣率, Nvl(a.实际缴款, 0) As 退款金额, a.交易序号
               From 帐户缴款余额 A, Table(f_Num2list(交易序号_In, ',')) B
               Where a.交易序号 = b.Column_Value And a.性质 = 1) Loop
  
    If Nvl(c_记录.交易序号, 0) <= 0 Then
      v_Err_Msg := 结算方式_In || '是升级前的缴款记录，不允许余额退款！';
      Raise Err_Item;
    End If;
  
    If n_卡余额 - c_记录.退余额 < 0 Then
      v_Err_Msg := 结算方式_In || '余额不足，退款失败！';
      Raise Err_Item;
    End If;
  
    Select Nvl(Max(a.序号), 0) + 1
    Into n_记录序号
    From 病人卡结算记录 A
    Where a.记录性质 = 3 And a.消费卡id = 消费卡id_In;
  
    Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
    Insert Into 病人卡结算记录
      (ID, 接口编号, 记录性质, 记录状态, 消费卡id, 卡号, 序号, 应收金额, 扣率, 实收金额, 结算id, 结算方式, 结算序号, 缴款, 找补, 缴款组id, 缴款人姓名, 病人id, 单位开户行, 单位帐号,
       结算号码, 卡类别id, 结算卡号, 交易流水号, 交易说明, 交易时间, 备注, 结算标志, 操作员编号, 操作员姓名, 登记时间, 交易序号)
    Values
      (n_Id, n_接口编号, 3, 1, 消费卡id_In, v_卡号, n_记录序号, -1 * c_记录.退余额, c_记录.扣率, -1 * (c_记录.退款金额 - n_误差金额), n_Id, 结算方式_In,
       结算序号_In, 缴款_In, 找补_In, n_组id, Null, n_病人id, 开户行_In, 帐号_In, 结算号码_In, 卡类别id_In, 结算卡号_In, 交易流水号_In, 交易说明_In, 退款时间_In,
       Null, 1, 操作员编号_In, 操作员姓名_In, 退款时间_In, c_记录.交易序号);
  
    Update 消费卡信息 Set 余额 = Nvl(余额, 0) - c_记录.退余额 Where ID = 消费卡id_In Returning 余额 Into n_卡余额;
  
    Update 帐户缴款余额
    Set 余额 = Nvl(余额, 0) - c_记录.退余额, 实际缴款 = Nvl(实际缴款, 0) - c_记录.退款金额
    Where 性质 = 1 And 交易序号 = c_记录.交易序号 And 消费卡id = 消费卡id_In
    Returning 余额 Into n_返回值;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 帐户缴款余额 Where 性质 = 1 And 交易序号 = c_记录.交易序号 And 消费卡id = 消费卡id_In;
    End If;
  
    --更新人员缴款余额
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) - (c_记录.退款金额 - n_误差金额)
    Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = 结算方式_In
    Returning 余额 Into n_返回值;
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额
        (收款员, 结算方式, 性质, 余额)
      Values
        (操作员姓名_In, 结算方式_In, 1, -1 * (c_记录.退款金额 - n_误差金额));
      n_返回值 := -1 * (c_记录.退款金额 - n_误差金额);
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete 人员缴款余额 Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = 结算方式_In And Nvl(余额, 0) = 0;
    End If;
  
    --插入误差记录
    If n_误差金额 <> 0 Then
      Begin
        Select 名称 Into v_误差费 From 结算方式 Where Nvl(性质, 0) = 9;
      Exception
        When Others Then
          v_误差费 := '误差费';
      End;
    
      Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      Insert Into 病人卡结算记录
        (ID, 接口编号, 记录性质, 记录状态, 消费卡id, 卡号, 序号, 应收金额, 扣率, 实收金额, 结算id, 结算方式, 结算序号, 缴款组id, 病人id, 交易时间, 结算标志, 操作员编号, 操作员姓名,
         登记时间, 交易序号)
      Values
        (n_Id, n_接口编号, 3, 1, 消费卡id_In, v_卡号, n_记录序号, 0, 0, -1 * n_误差金额, n_Id, v_误差费, 结算序号_In, n_组id, n_病人id, 退款时间_In, 1,
         操作员编号_In, 操作员姓名_In, 退款时间_In, Null);
    
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) - n_误差金额
      Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_误差费
      Returning 余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, v_误差费, 1, -1 * n_误差金额);
        n_返回值 := -1 * n_误差金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete 人员缴款余额 Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_误差费 And Nvl(余额, 0) = 0;
      End If;
    End If;
  
    n_剩余退款金额 := n_剩余退款金额 - c_记录.退款金额;
    n_误差金额     := 0;
  End Loop;
  If n_剩余退款金额 <> 0 Then
    v_Err_Msg := 结算方式_In || '当前退款金额大于了可退金额，退款失败！';
    Raise Err_Item;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_消费卡信息_余额退款;
/

--116073:黄捷,2017-12-15,RIS接口支持多HIS库
CREATE OR REPLACE Package b_Zlxwinterface Is
  Type t_Refcur Is Ref Cursor;

  --1、接收RIS状态改变
  Procedure Receiverisstate
  (
    医嘱id_In   病人医嘱发送.医嘱id%Type,
    Risid_In    病人医嘱报告.Risid%Type,
    状态_In     Number,
    操作人员_In 病人医嘱发送.完成人%Type,
    执行时间_In 病人医嘱发送.完成时间%Type := Null,
    执行说明_In 病人医嘱发送.执行说明%Type := Null,
    单独执行_In Number := 0
  );

  --2、费用确认
  Procedure 影像费用执行
  (
    医嘱id_In     影像检查记录.医嘱id%Type,
    单独执行_In   Number := 0,
    操作员编号_In 人员表.编号%Type := Null,
    操作员姓名_In 人员表.姓名%Type := Null,
    执行部门id_In 门诊费用记录.执行部门id%Type := Null
  );

  --3、取消费用确认
  Procedure 影像费用执行_Cancel
  (
    医嘱id_In     影像检查记录.医嘱id%Type,
    单独执行_In   Number := 0,
    操作员编号_In 人员表.编号%Type := Null,
    操作员姓名_In 人员表.姓名%Type := Null,
    执行部门id_In 门诊费用记录.执行部门id%Type := Null
  );

  --4、接收RIS的报告
  Procedure Receivereport
  (
    医嘱id_In   病人医嘱发送.医嘱id%Type,
    Risid_In    病人医嘱报告.Risid%Type,
    报告所见_In 电子病历内容.内容文本%Type,
    报告意见_In 电子病历内容.内容文本%Type,
    报告建议_In 电子病历内容.内容文本%Type,
    报告医生_In 电子病历记录.创建人%Type
  );

  --5、修改申请单信息
  Procedure 影像病人信息_修改
  (
    医嘱id_In       病人医嘱记录.Id%Type,
    姓名_In         病人信息.姓名%Type,
    性别_In         病人信息.性别%Type,
    年龄_In         病人信息.年龄%Type,
    费别_In         病人信息.费别%Type,
    医疗付款方式_In 病人信息.医疗付款方式%Type,
    民族_In         病人信息.民族%Type,
    婚姻_In         病人信息.婚姻状况%Type,
    职业_In         病人信息.职业%Type,
    身份证号_In     病人信息.身份证号%Type,
    家庭地址_In     病人信息.家庭地址%Type,
    家庭电话_In     病人信息.家庭电话%Type,
    家庭地址邮编_In 病人信息.家庭地址邮编%Type,
    出生日期_In     病人信息.出生日期%Type := Null
  );

  --6、取消申请单信息
  Procedure 取消检查申请单
  (
    医嘱id_In     病人医嘱执行.医嘱id%Type,
    操作员编号_In 人员表.编号%Type := Null,
    操作员姓名_In 人员表.姓名%Type := Null,
    执行部门id_In 门诊费用记录.执行部门id%Type := 0,
    拒绝原因_In   病人医嘱发送.执行说明%Type := Null
  );

  --7、插入医嘱操作失败记录
  Procedure Ris医嘱失败记录_Insert
  (
    病人来源_In   In Ris医嘱失败记录.病人来源%Type,
    病人id_In     In Ris医嘱失败记录.病人id%Type,
    主页id_In     In Ris医嘱失败记录.主页id%Type,
    挂号单号_In   In Ris医嘱失败记录.挂号单号%Type,
    发送号_In     In Ris医嘱失败记录.发送号%Type,
    体检任务id_In In Ris医嘱失败记录.体检任务id%Type,
    体检报到号_In In Ris医嘱失败记录.体检报到号%Type,
    发送类型_In   In Ris医嘱失败记录.发送类型%Type
  );

  --8、更新医嘱操作失败记录
  Procedure Ris医嘱失败记录_重发
  (
    Id_In       In Ris医嘱失败记录.Id%Type,
    操作类型_In In Number
  );

  --9、销账后新建住院记账单据
  Procedure 病人医嘱_重建单据
  (
    医嘱id_In In 病人医嘱发送.医嘱id%Type,
    No_In     In 病人医嘱发送.No%Type,
    Action_In In Number
  );

  --10、打印RIS检查预约通知单
  Procedure Ris检查预约_打印(医嘱id_In In Ris检查预约.医嘱id%Type);

  --11、更新RIS分科室启用参数
  Procedure Ris启用控制_Update
  (
    检查类型_In Ris启用控制.检查类型%Type,
    场合_In     Ris启用控制.场合%Type,
    部门ids_In  Varchar2,
    启用类型_In Number
  );

  --12、删除RIS分科室启用参数
  Procedure Ris启用控制_Delete;

  --13、根据元素名提取信息
  Function Ris_Replace_Element_Value
  (
    元素名_In   In 诊治所见项目.中文名%Type,
    病人id_In   In 电子病历记录.病人id%Type,
    就诊id_In   In 电子病历记录.主页id%Type,
    病人来源_In In 电子病历记录.病人来源%Type,
    医嘱id_In   In 病人医嘱发送.医嘱id%Type
  ) Return Varchar2;

  --14、删除RIS分院设置参数
  Procedure Ris分院设置_Delete;

  --15、更新RISRis分院设置参数
  Procedure Ris分院设置_Update
  (
    Id_In           Ris分院设置.Id%Type,
    医院名称_In     Ris分院设置.医院名称%Type,
    医院代码_In     Ris分院设置.医院代码%Type,
    用户名_In       Ris分院设置.用户名%Type,
    密码_In         Ris分院设置.密码%Type,
    数据库服务名_In Ris分院设置.数据库服务名%Type
  );
End b_Zlxwinterface;
/

CREATE OR REPLACE Package Body b_Zlxwinterface Is

  --1、接收RIS状态改变
  Procedure Receiverisstate
  (
    医嘱id_In   病人医嘱发送.医嘱id%Type,
    Risid_In    病人医嘱报告.Risid%Type,
    状态_In     Number,
    操作人员_In 病人医嘱发送.完成人%Type,
    执行时间_In 病人医嘱发送.完成时间%Type := Null,
    执行说明_In 病人医嘱发送.执行说明%Type := Null,
    单独执行_In Number := 0
  ) Is
  
    --参数：医嘱ID_IN - 单独执行的医嘱ID。
    --      状态_IN - -1-删除；0-预约；1-登记；3-检查完成；4-检查中止；9-初步报告；12-报告审核；15-发放
    --     单独执行_In -0-全部执行；1-单独执行；检查医嘱组合是否采用对每个项目分散单独执行的方式
  
    Cursor c_Adviceinfo Is
      Select a.Id, a.相关id, Nvl(a.相关id, a.Id) As 组id, a.诊疗类别, a.病人来源, a.执行科室id, b.执行过程
      From 病人医嘱记录 A, 病人医嘱发送 B
      Where a.Id = b.医嘱id And ID = 医嘱id_In;
    r_Adviceinfo c_Adviceinfo%RowType;
  
    v_执行状态 病人医嘱发送.执行状态%Type;
    v_执行过程 病人医嘱发送.执行过程%Type;
    n_执行     Number; --标记是否需要更新状态，1：需要更新，其他不需要更新
    v_Count    Number;
    v_完成人   病人医嘱发送.完成人%Type;
    v_完成时间 病人医嘱发送.完成时间%Type;
    v_Error    Varchar2(255);
    Err_Custom Exception;
  
  Begin
  
    v_执行状态 := 0;
    v_执行过程 := 0;
  
    --提取医嘱的主医嘱ID，及组ID
    Open c_Adviceinfo;
    Fetch c_Adviceinfo
      Into r_Adviceinfo;
    Close c_Adviceinfo;
  
    --根据状态_IN执行医嘱
    ---1-删除；0-预约；1-登记；3-检查完成；4-检查中止；9-初步报告；12-报告审核；13-取消审核；14-报告删除；15-发放
  
    If 状态_In = -1 Or 状态_In = 0 Then
      v_执行状态 := 0; --未执行
      v_执行过程 := 0;
    Elsif 状态_In = 1 Then
      v_执行状态 := 3; --正在执行
      v_执行过程 := 2; --已报到
    Elsif 状态_In = 3 Or 状态_In = 14 Then
      v_执行状态 := 3; --正在执行
      v_执行过程 := 3; --已检查
    Elsif 状态_In = 4 Then
      --不改变
      v_执行状态 := v_执行状态;
    Elsif 状态_In = 9 Or 状态_In = 13 Then
      v_执行状态 := 3; --正在执行
      v_执行过程 := 4; --已报告
    Elsif 状态_In = 12 Then
      v_执行状态 := 3; --正在执行
      v_执行过程 := 5; --已审核
    Elsif 状态_In = 15 Then
      v_执行状态 := 1; --完全执行
      v_执行过程 := 6; --已完成
      v_完成人   := 操作人员_In;
      v_完成时间 := 执行时间_In;
    End If;
  
    n_执行 := 1; --默认都要更新状态
  
    If 状态_In = 13 Or 状态_In = 14 Then
      --删除对应报告数据
      Delete From 电子病历记录
      Where ID = (Select 病历id From 病人医嘱报告 Where 医嘱id = 医嘱id_In And Risid = Risid_In);
      Delete From 病人医嘱报告 Where 医嘱id = 医嘱id_In And Risid = Risid_In;
    
      --删除后判断是否还存在报告，若存在则医嘱状态保持不变，若报告全部删除则更新医嘱状态
      Select Count(1) Into v_Count From 病人医嘱报告 Where 医嘱id = 医嘱id_In;
    
      If v_Count > 0 Then
        n_执行 := 0; --若存在则医嘱状态保持不变
      End If;
    End If;
  
    --如果是登记，先判断此检查是否未执行
    If 状态_In = 1 Then
      If r_Adviceinfo.执行过程 >= 3 Then
        v_Error := '患者已经做过检查了，不能重复登记。';
        Raise Err_Custom;
      End If;
    End If;
  
    --开始执行医嘱
    If n_执行 = 1 Then
      If Nvl(单独执行_In, 0) = 1 Then
        -- 单个部位医嘱单独执行
        Update 病人医嘱发送
        Set 执行状态 = v_执行状态, 执行过程 = v_执行过程, 执行说明 = 执行说明_In, 完成人 = v_完成人, 完成时间 = v_完成时间
        Where 医嘱id = 医嘱id_In;
      Else
        Update 病人医嘱发送
        Set 执行状态 = v_执行状态, 执行过程 = v_执行过程, 执行说明 = 执行说明_In, 完成人 = v_完成人, 完成时间 = v_完成时间
        Where 医嘱id In (Select ID From 病人医嘱记录 Where (ID = r_Adviceinfo.组id Or 相关id = r_Adviceinfo.组id));
      End If;
    End If;
  Exception
    When Err_Custom Then
      Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End Receiverisstate;

  --2、费用确认
  Procedure 影像费用执行
  (
    医嘱id_In     影像检查记录.医嘱id%Type,
    单独执行_In   Number := 0,
    操作员编号_In 人员表.编号%Type := Null,
    操作员姓名_In 人员表.姓名%Type := Null,
    执行部门id_In 门诊费用记录.执行部门id%Type := Null
  ) Is
    --参数：医嘱ID_IN=单独执行的医嘱ID。
    --      单独执行_In=检查医嘱组合是否采用对每个项目分散单独执行的方式,0-不单独执行
    Cursor c_Advice Is
      Select ID, 相关id, Nvl(相关id, ID) As 组id, 诊疗类别, 病人来源 From 病人医嘱记录 Where ID = 医嘱id_In;
    r_Advice c_Advice%RowType;
  
    v_Temp     Varchar2(255);
    v_人员编号 人员表.编号%Type;
    v_人员姓名 人员表.姓名%Type;
    v_部门id   部门表.Id%Type;
    v_费用性质 病人医嘱发送.记录性质%Type;
    v_发送号   病人医嘱发送.发送号%Type;
    v_执行过程 病人医嘱发送.执行过程%Type;
    v_Count    Number;
    v_Error    Varchar2(255);
    Err_Custom Exception;
  Begin
  
    --取主医嘱ID
    Open c_Advice;
    Fetch c_Advice
      Into r_Advice;
    Close c_Advice;
  
    Select 发送号, 执行过程 Into v_发送号, v_执行过程 From 病人医嘱发送 Where 医嘱id = r_Advice.组id;
  
    --登记和完成才执行费用  2-登记，3-检查，4-报告，5-审核，6-完成
    If v_执行过程 >= 2 Or v_执行过程 <= 6 Then
    
      --先检查是否已经出院的住院病人，已经预出院或者出院的检查申请，不允执行费用
      Select Count(*)
      Into v_Count
      From 病人医嘱记录 A, 病案主页 B
      Where a.病人id = b.病人id And a.主页id = b.主页id And (b.出院日期 Is Not Null Or b.状态 = 3) And a.Id = r_Advice.组id;
    
      If v_Count > 0 Then
        --已经出院、预出院或转院，需要判断先是否死亡
        Select Count(*)
        Into v_Count
        From 病人医嘱记录 A, 诊疗项目目录 B, 病人医嘱发送 C
        Where a.Id = c.医嘱id And a.诊疗项目id = b.Id And b.类别 = 'Z' And b.操作类型 = 11 And
              a.病人id = (Select d.病人id From 病人医嘱记录 D Where d.Id = r_Advice.组id);
        If v_Count > 0 Then
          v_Error := '已经对患者下达死亡医嘱，不能执行费用。';
          Raise Err_Custom;
        End If;
        --再判断是否已经预约，已经预约可执行
        Select Count(*) Into v_Count From Ris检查预约 Where 医嘱id = r_Advice.组id;
        If v_Count = 0 Then
          --已经出院或者预出院，未预约，如果在旧版PACS已经报到，也可以执行
          Select Count(*) Into v_Count From 影像检查记录 Where 医嘱id = r_Advice.组id;
          If v_Count = 0 Then
            v_Error := '住院病人已经出院或者预出院，不能执行费用。';
            Raise Err_Custom;
          End If;
        End If;
      End If;
    
      --取当前操作人员
      If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null And 执行部门id_In Is Not Null Then
        v_人员编号 := 操作员编号_In;
        v_人员姓名 := 操作员姓名_In;
        v_部门id   := 执行部门id_In;
      Else
        v_Temp     := Zl_Identity;
        v_部门id   := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
        v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
        v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
      End If;
    
      If r_Advice.病人来源 = 2 Then
        Select Decode(记录性质, 1, 1, Decode(门诊记帐, 1, 1, 2))
        Into v_费用性质
        From 病人医嘱发送
        Where 发送号 = v_发送号 And 医嘱id = 医嘱id_In;
      Else
        v_费用性质 := 1;
      End If;
    
      --执行费用和自动发料
      If v_费用性质 = 1 Then
        Zl_门诊医嘱执行_Finish(医嘱id_In, v_发送号, 单独执行_In, v_人员编号, v_人员姓名, r_Advice.组id, r_Advice.诊疗类别, v_部门id);
      Else
        Zl_住院医嘱执行_Finish(医嘱id_In, v_发送号, 单独执行_In, v_人员编号, v_人员姓名, r_Advice.组id, r_Advice.诊疗类别, v_部门id);
      End If;
    End If;
  
  Exception
    When Err_Custom Then
      Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End 影像费用执行;

  --3、取消费用确认
  Procedure 影像费用执行_Cancel
  (
    医嘱id_In     影像检查记录.医嘱id%Type,
    单独执行_In   Number := 0,
    操作员编号_In 人员表.编号%Type := Null,
    操作员姓名_In 人员表.姓名%Type := Null,
    执行部门id_In 门诊费用记录.执行部门id%Type := Null
  ) Is
    --参数：
    --      医嘱ID_IN=单独执行的医嘱ID。
    --      单独执行_In=检查医嘱组合是否采用对每个项目分散单独执行的方式,0-不单独执行
  
    Cursor c_Advice Is
      Select ID, 相关id, Nvl(相关id, ID) As 组id From 病人医嘱记录 Where ID = 医嘱id_In;
    r_Advice c_Advice%RowType;
  
    v_发送号 病人医嘱发送.发送号%Type;
    v_Count  Number;
    v_Error  Varchar2(255);
    Err_Custom Exception;
  
  Begin
  
    --取主医嘱ID
    Open c_Advice;
    Fetch c_Advice
      Into r_Advice;
    Close c_Advice;
  
    --先检查是否已经出院的住院病人，已经预出院或者出院的检查申请，不允执行费用
    Select Count(*)
    Into v_Count
    From 病人医嘱记录 A, 病案主页 B
    Where a.病人id = b.病人id And a.主页id = b.主页id And (b.出院日期 Is Not Null Or b.状态 = 3) And a.Id = r_Advice.组id;
  
    If v_Count > 0 Then
      v_Error := '住院病人已经出院或者预出院，不能取消费用。';
      Raise Err_Custom;
    End If;
  
    Select 发送号 Into v_发送号 From 病人医嘱发送 Where 医嘱id = r_Advice.组id;
  
    --调用统一的医嘱执行Cancel过程
    Zl_病人医嘱执行_Cancel(医嘱id_In, v_发送号, Null, 单独执行_In, 执行部门id_In, 操作员编号_In, 操作员姓名_In);
  
  Exception
    When Err_Custom Then
      Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End 影像费用执行_Cancel;

  --4、接收RIS的报告
  Procedure Receivereport
  (
    医嘱id_In   病人医嘱发送.医嘱id%Type,
    Risid_In    病人医嘱报告.Risid%Type,
    报告所见_In 电子病历内容.内容文本%Type,
    报告意见_In 电子病历内容.内容文本%Type,
    报告建议_In 电子病历内容.内容文本%Type,
    报告医生_In 电子病历记录.创建人%Type
  ) Is
    --提取病人医嘱及报告的相关信息
    Cursor c_Advice
    (
      v_组id  Number,
      v_Risid Number
    ) Is
      Select e.Id, e.病人来源, e.病人id, e.主页id, e.婴儿, e.病人科室id, e.文件id, e.病历种类, e.病历名称, f.病历id, e.执行科室id
      From (Select c.Id, c.病人来源, c.病人id, c.主页id, c.婴儿, c.病人科室id, c.文件id, d.种类 病历种类, d.名称 病历名称, c.执行科室id
             From (Select a.Id, a.病人来源, a.病人id, a.主页id, a.婴儿, a.病人科室id, b.病历文件id 文件id, a.执行科室id
                    From 病人医嘱记录 A, 病历单据应用 B
                    Where a.Id = v_组id And a.诊疗项目id = b.诊疗项目id(+) And b.应用场合(+) = Decode(a.病人来源, 2, 2, 4, 4, 1)) C,
                  病历文件列表 D
             Where c.文件id = d.Id(+)) E, 病人医嘱报告 F
      Where e.Id = f.医嘱id(+) And f.Risid(+) = v_Risid;
  
    --查找文件的组成元素
    Cursor c_File(v_File Number) Is
      Select a.Id, a.文件id, a.父id, a.对象序号, a.对象类型, a.对象标记, a.保留对象, a.对象属性, a.内容行次, a.内容文本, a.是否换行, a.预制提纲id, a.复用提纲,
             a.使用时机, a.诊治要素id, a.替换域, a.要素名称, a.要素类型, a.要素长度, a.要素小数, a.要素单位, a.要素表示, a.输入形态, a.要素值域
      From 病历文件结构 A
      Where a.文件id = v_File
      Order By a.对象序号;
  
    Cursor c_Report(v_电子病历记录id Number) Is
      Select b.Id, a.内容文本
      From 电子病历内容 A, 电子病历内容 B
      Where a.对象类型 = 3 And a.Id = b.父id And b.对象类型 = 2 And b.终止版 = 0 And a.文件id = v_电子病历记录id;
  
    Cursor c_Content
    (
      v_文件id Number,
      v_表格id Number
    ) Is
      Select a.Id, a.文件id, a.父id, a.对象序号, a.对象类型, a.对象标记, a.保留对象, a.对象属性, a.内容行次, a.内容文本, a.是否换行, a.预制提纲id, a.复用提纲,
             a.使用时机, a.诊治要素id, a.替换域, a.要素名称, a.要素类型, a.要素长度, a.要素小数, a.要素单位, a.要素表示, a.输入形态, a.要素值域
      From 病历文件结构 A
      Where 文件id = v_文件id And 父id = v_表格id;
  
    r_Advice        c_Advice%RowType;
    v_病历id        电子病历内容.文件id%Type;
    v_病历内容id    电子病历内容.Id%Type;
    v_病历内容idnew 电子病历内容.Id%Type;
    v_对象序号      电子病历内容.对象序号%Type;
    v_父id          电子病历内容.父id%Type;
    v_内容文本      电子病历内容.内容文本%Type;
    v_定义提纲id    电子病历内容.定义提纲id%Type;
    --v_格式内容    电子病历格式.内容%Type;
    v_Error Varchar2(255);
    Err_Custom Exception;
    v_主医嘱id 病人医嘱发送.医嘱id%Type;
    v_表格     Varchar2(300);
    n_数量     Number;
    n_Rptcount Number;
    v_病历名称 电子病历记录.病历名称%Type;
    v_挂号单id 病人挂号记录.Id%Type;
  
    Function Getrptno
    (
      v_医嘱idin   病人医嘱发送.医嘱id%Type,
      v_病历名称in 电子病历记录.病历名称%Type
    ) Return Varchar As
      v_Return Number;
      v_No     Number;
      v_Count  Number;
    Begin
      Select Count(医嘱id) + 1 Into v_No From 病人医嘱报告 Where 医嘱id = v_医嘱idin;
      v_Count := 1;
      While v_Count = 1 Loop
        Select Count(ID)
        Into v_Count
        From 病人医嘱报告 A, 电子病历记录 B
        Where a.医嘱id = v_医嘱idin And a.病历id = b.Id And b.病历名称 = v_病历名称in || v_No;
        If v_Count = 1 Then
          v_No := v_No + 1;
        End If;
      End Loop;
      v_Return := v_No;
      Return v_Return;
    End Getrptno;
  
  Begin
  
    -- 提取主医嘱ID ，防止因为传入部位医嘱，导致报告保存出错
    Select Nvl(相关id, ID) As 组id Into v_主医嘱id From 病人医嘱记录 Where ID = 医嘱id_In;
  
    Open c_Advice(v_主医嘱id, Nvl(Risid_In, 0));
    Fetch c_Advice
      Into r_Advice;
  
    If Nvl(r_Advice.文件id, 0) = 0 Then
      v_Error := '本次检查项目没有对应相关的检查报告，请与管理员联系！';
      Raise Err_Custom;
    Else
      If Nvl(r_Advice.病历id, 0) > 0 Then
        ----产生过报告
        --找出检查已填写的报告提纲中含有"%所见%","%描述%","%建议%","%意见%",并用传入的参数更新
        For r_Report In c_Report(r_Advice.病历id) Loop
          If r_Report.内容文本 Like '%所见%' Then
            Update 电子病历内容 Set 内容文本 = 报告所见_In || Chr(13) || Chr(13) Where ID = r_Report.Id;
          Elsif r_Report.内容文本 Like '%意见%' Then
            Update 电子病历内容 Set 内容文本 = 报告意见_In || Chr(13) || Chr(13) Where ID = r_Report.Id;
          Elsif r_Report.内容文本 Like '%建议%' Then
            Update 电子病历内容 Set 内容文本 = 报告建议_In || Chr(13) || Chr(13) Where ID = r_Report.Id;
          End If;
        End Loop;
        --更新保存时间
        Update 电子病历记录
        Set 完成时间 = Sysdate, 保存人 = 报告医生_In, 保存时间 = Sysdate
        Where ID = r_Advice.病历id;
      Else
        --先判断单据中是否有对应的提纲和表格
        If Nvl(报告所见_In, ' ') <> ' ' Then
          Select Count(1)
          Into n_数量
          From 病历文件结构 A, 病历文件结构 B
          Where a.父id = b.Id And a.对象类型 = 3 And b.对象类型 = 1 And a.内容文本 Like '%所见%' And a.文件id = r_Advice.文件id;
        
          If n_数量 <= 0 Then
            v_Error := '在诊疗单据中没有找到【所见】对应的提纲或表格，请联系管理员设置！';
            Raise Err_Custom;
          End If;
        End If;
        If Nvl(报告意见_In, ' ') <> ' ' Then
          Select Count(1)
          Into n_数量
          From 病历文件结构 A, 病历文件结构 B
          Where a.父id = b.Id And a.对象类型 = 3 And b.对象类型 = 1 And a.内容文本 Like '%意见%' And a.文件id = r_Advice.文件id;
        
          If n_数量 <= 0 Then
            v_Error := '在诊疗单据中没有找到【意见】对应的提纲或表格，请联系管理员设置！';
            Raise Err_Custom;
          End If;
        End If;
        If Nvl(报告建议_In, ' ') <> ' ' Then
          Select Count(1)
          Into n_数量
          From 病历文件结构 A, 病历文件结构 B
          Where a.父id = b.Id And a.对象类型 = 3 And b.对象类型 = 1 And a.内容文本 Like '%建议%' And a.文件id = r_Advice.文件id;
        
          If n_数量 <= 0 Then
            v_Error := '在诊疗单据中没有找到【建议】对应的提纲或表格，请联系管理员设置！';
            Raise Err_Custom;
          End If;
        End If;
      
        If r_Advice.病人来源 = 1 Then
          --门诊，提取挂号单ID
          Select Nvl(c.Id, 0)
          Into v_挂号单id
          From 病人医嘱记录 B, 病人挂号记录 C
          Where b.挂号单 = c.No(+) And c.记录状态 In (1, 3) And b.Id = v_主医嘱id;
        Else
          --体检或者外诊，无挂号单ID，直接设置为0
          v_挂号单id := 0;
        End If;
      
        --产生电子病历记录
        Select 电子病历记录_Id.Nextval Into v_病历id From Dual;
        n_Rptcount := Getrptno(医嘱id_In, r_Advice.病历名称);
        If n_Rptcount > 1 Then
          v_病历名称 := r_Advice.病历名称 || n_Rptcount;
        Else
          v_病历名称 := r_Advice.病历名称;
        End If;
        Insert Into 电子病历记录
          (ID, 病人来源, 病人id, 主页id, 婴儿, 科室id, 病历种类, 文件id, 病历名称, 创建人, 创建时间, 完成时间, 保存人, 保存时间, 最后版本, 签名级别)
        Values
          (v_病历id, r_Advice.病人来源, r_Advice.病人id, Decode(r_Advice.病人来源, 2, r_Advice.主页id, v_挂号单id), r_Advice.婴儿,
           r_Advice.病人科室id, r_Advice.病历种类, r_Advice.文件id, v_病历名称, 报告医生_In, Sysdate, Sysdate, 报告医生_In, Sysdate, 1, 2);
      
        --产生医嘱报告记录
        Insert Into 病人医嘱报告 (医嘱id, 病历id, Risid) Values (v_主医嘱id, v_病历id, Risid_In);
      
        v_对象序号 := 0;
      
        --新产生报告内容
        For r_File In c_File(r_Advice.文件id) Loop
          Select 电子病历内容_Id.Nextval Into v_病历内容id From Dual;
          v_内容文本   := r_File.内容文本;
          v_定义提纲id := 0;
        
          If Nvl(r_File.对象类型, 0) = 1 And Nvl(r_File.父id, 0) = 0 Then
            --提纲
            v_定义提纲id := r_File.Id;
            v_父id       := v_病历内容id;
          End If;
        
          If Nvl(r_File.对象类型, 0) = 4 And r_File.要素名称 Is Not Null Then
            --元素
            v_内容文本 := Zl_Replace_Element_Value(r_File.要素名称, r_Advice.病人id, r_Advice.主页id, r_Advice.病人来源, r_Advice.Id);
          End If;
        
          If Nvl(r_File.父id, 0) <> 0 Then
            v_定义提纲id := 0;
          End If;
        
          v_对象序号 := v_对象序号 + 1;
        
          If Instr(v_表格, '|' || r_File.父id || '|') > 0 Then
            Null;
          Else
            Insert Into 电子病历内容
              (ID, 文件id, 开始版, 终止版, 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行, 预制提纲id, 复用提纲, 使用时机, 诊治要素id, 替换域,
               要素名称, 要素类型, 要素长度, 要素小数, 要素单位, 要素表示, 输入形态, 要素值域, 定义提纲id)
            Values
              (v_病历内容id, v_病历id, 1, 0, Decode(v_定义提纲id, 0, v_父id, Null), v_对象序号, r_File.对象类型, r_File.对象标记, r_File.保留对象,
               r_File.对象属性, Null, v_内容文本, r_File.是否换行, r_File.预制提纲id, r_File.复用提纲, r_File.使用时机, r_File.诊治要素id,
               r_File.替换域, r_File.要素名称, r_File.要素类型, r_File.要素长度, r_File.要素小数, r_File.要素单位, r_File.要素表示, r_File.输入形态,
               r_File.要素值域, Decode(v_定义提纲id, 0, Null, v_定义提纲id));
          End If;
        
          --为表格时，插入文本内容
          If Nvl(r_File.对象类型, 0) = 3 And Nvl(r_File.父id, 0) <> 0 Then
            v_表格 := v_表格 || ',|' || r_File.Id || '|';
          
            If r_File.内容文本 Like '%所见%' Then
              v_内容文本 := 报告所见_In || Chr(13) || Chr(13);
            Elsif r_File.内容文本 Like '%意见%' Then
              v_内容文本 := 报告意见_In || Chr(13) || Chr(13);
            Else
              v_内容文本 := 报告建议_In || Chr(13) || Chr(13);
            End If;
          
            For r_Con In c_Content(r_Advice.文件id, r_File.Id) Loop
              Select 电子病历内容_Id.Nextval Into v_病历内容idnew From Dual;
              v_对象序号 := v_对象序号 + 1;
            
              Insert Into 电子病历内容
                (ID, 文件id, 开始版, 终止版, 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行, 预制提纲id, 复用提纲, 使用时机, 诊治要素id,
                 替换域, 要素名称, 要素类型, 要素长度, 要素小数, 要素单位, 要素表示, 输入形态, 要素值域, 定义提纲id)
              Values
                (v_病历内容idnew, v_病历id, 1, 0, v_病历内容id, v_对象序号, 2, r_Con.对象标记, r_Con.保留对象, r_Con.对象属性, Null, v_内容文本,
                 r_Con.是否换行, r_Con.预制提纲id, r_Con.复用提纲, r_Con.使用时机, r_Con.诊治要素id, r_Con.替换域, r_Con.要素名称, r_Con.要素类型,
                 r_Con.要素长度, r_Con.要素小数, r_Con.要素单位, r_Con.要素表示, r_Con.输入形态, r_Con.要素值域,
                 Decode(v_定义提纲id, 0, Null, v_定义提纲id));
            End Loop;
          End If;
        End Loop;
      
        --因电子病历格式中含了内容文字格式，此种方法导入之后内容文字将不可见
        --Select 内容 Into v_格式内容 From 病历文件格式 Where 文件ID=r_Advice.文件ID;
        --Insert Into 电子病历格式 (文件ID,内容) Values (v_病历id,v_格式内容);
      
      End If;
    End If;
    Close c_Advice;
  
  Exception
    When Err_Custom Then
      Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End Receivereport;

  --5、修改申请单信息
  Procedure 影像病人信息_修改
  (
    医嘱id_In       病人医嘱记录.Id%Type,
    姓名_In         病人信息.姓名%Type,
    性别_In         病人信息.性别%Type,
    年龄_In         病人信息.年龄%Type,
    费别_In         病人信息.费别%Type,
    医疗付款方式_In 病人信息.医疗付款方式%Type,
    民族_In         病人信息.民族%Type,
    婚姻_In         病人信息.婚姻状况%Type,
    职业_In         病人信息.职业%Type,
    身份证号_In     病人信息.身份证号%Type,
    家庭地址_In     病人信息.家庭地址%Type,
    家庭电话_In     病人信息.家庭电话%Type,
    家庭地址邮编_In 病人信息.家庭地址邮编%Type,
    出生日期_In     病人信息.出生日期%Type := Null
  ) As
  
    v_年龄     Varchar2(20);
    v_年龄单位 Varchar2(20);
    v_出生日期 Date;
    v_病人来源 病人医嘱记录.病人来源%Type;
    v_病人id   病人医嘱记录.病人id%Type;
  Begin
    Begin
      Select 病人来源, 病人id Into v_病人来源, v_病人id From 病人医嘱记录 Where ID = 医嘱id_In;
    Exception
      When Others Then
        Return;
    End;
  
    If 出生日期_In Is Null And 年龄_In Is Not Null Then
      --根据年龄求出生日期
      v_年龄单位 := Substr(年龄_In, Length(年龄_In), 1);
      If Instr('岁,月,天', v_年龄单位) <= 0 Then
        v_年龄单位 := Null;
      Else
        v_年龄 := Replace(年龄_In, v_年龄单位, '');
      End If;
      Begin
        v_年龄 := To_Number(v_年龄);
      Exception
        When Others Then
          v_年龄 := Null;
      End;
      If v_年龄 Is Not Null And v_年龄单位 Is Not Null Then
        Select Decode(v_年龄单位, '岁', Add_Months(Sysdate, -12 * v_年龄), '月', Add_Months(Sysdate, -1 * v_年龄), '天',
                       Sysdate - v_年龄)
        Into v_出生日期
        From Dual;
      End If;
    Else
      v_出生日期 := 出生日期_In;
    End If;
  
    If v_病人来源 = 3 Then
      Update 病人信息
      Set 姓名 = 姓名_In, 性别 = Nvl(性别_In, 性别), 年龄 = 年龄_In, 出生日期 = v_出生日期, 费别 = Nvl(费别_In, 费别),
          医疗付款方式 = Nvl(医疗付款方式_In, 医疗付款方式), 民族 = Nvl(民族_In, 民族), 婚姻状况 = Nvl(婚姻_In, 婚姻状况), 职业 = Nvl(职业_In, 职业),
          身份证号 = 身份证号_In, 家庭地址 = 家庭地址_In, 家庭电话 = 家庭电话_In, 家庭地址邮编 = 家庭地址邮编_In
      Where 病人id = v_病人id;
    
      --修改对应的医嘱记录
      Update 病人医嘱记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In
      Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
    Else
      Update 病人信息
      Set 民族 = Nvl(民族_In, 民族), 婚姻状况 = Nvl(婚姻_In, 婚姻状况), 职业 = Nvl(职业_In, 职业), 家庭地址 = 家庭地址_In, 家庭电话 = 家庭电话_In,
          家庭地址邮编 = 家庭地址邮编_In
      Where 病人id = v_病人id;
    End If;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End 影像病人信息_修改;

  --6、取消申请单信息
  Procedure 取消检查申请单
  (
    医嘱id_In     病人医嘱执行.医嘱id%Type,
    操作员编号_In 人员表.编号%Type := Null,
    操作员姓名_In 人员表.姓名%Type := Null,
    执行部门id_In 门诊费用记录.执行部门id%Type := 0,
    拒绝原因_In   病人医嘱发送.执行说明%Type := Null
  ) As
    --参数：医嘱ID_IN=单独执行的医嘱ID
  
    v_发送号 病人医嘱执行.发送号%Type;
  
  Begin
  
    Begin
      Select 发送号 Into v_发送号 From 病人医嘱发送 Where 医嘱id = 医嘱id_In;
    Exception
      When Others Then
        Return;
    End;
  
    Zl_病人医嘱执行_拒绝执行(医嘱id_In, v_发送号, 操作员编号_In, 操作员姓名_In, 执行部门id_In, 拒绝原因_In);
  
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End 取消检查申请单;

  --7、插入医嘱操作失败记录
  Procedure Ris医嘱失败记录_Insert
  (
    病人来源_In   In Ris医嘱失败记录.病人来源%Type,
    病人id_In     In Ris医嘱失败记录.病人id%Type,
    主页id_In     In Ris医嘱失败记录.主页id%Type,
    挂号单号_In   In Ris医嘱失败记录.挂号单号%Type,
    发送号_In     In Ris医嘱失败记录.发送号%Type,
    体检任务id_In In Ris医嘱失败记录.体检任务id%Type,
    体检报到号_In In Ris医嘱失败记录.体检报到号%Type,
    发送类型_In   In Ris医嘱失败记录.发送类型%Type
  ) Is
  Begin
    Insert Into Ris医嘱失败记录
      (ID, 病人来源, 病人id, 主页id, 挂号单号, 发送号, 体检任务id, 体检报到号, 发送类型, 发送时间, 重发次数)
    Values
      (Ris医嘱失败记录_Id.Nextval, 病人来源_In, 病人id_In, 主页id_In, 挂号单号_In, 发送号_In, 体检任务id_In, 体检报到号_In, 发送类型_In, Sysdate, 0);
  
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End Ris医嘱失败记录_Insert;

  --8、更新医嘱操作失败记录
  Procedure Ris医嘱失败记录_重发
  (
    Id_In       In Ris医嘱失败记录.Id%Type,
    操作类型_In In Number
  ) Is
    v_重发次数 Ris医嘱失败记录.重发次数%Type;
  Begin
    --操作类型_In -- 1 重发成功，删除记录；2--重发失败
  
    If 操作类型_In = 1 Then
      Delete From Ris医嘱失败记录 Where ID = Id_In;
    Else
      Select 重发次数 Into v_重发次数 From Ris医嘱失败记录 Where ID = Id_In;
      If v_重发次数 >= 99 Then
        v_重发次数 := 99;
      Else
        v_重发次数 := v_重发次数 + 1;
      End If;
      Update Ris医嘱失败记录 Set 发送时间 = Sysdate, 重发次数 = v_重发次数 Where ID = Id_In;
    End If;
  
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End Ris医嘱失败记录_重发;

  --9、销账后新建住院记账单据
  Procedure 病人医嘱_重建单据
  (
    医嘱id_In In 病人医嘱发送.医嘱id%Type,
    No_In     In 病人医嘱发送.No%Type,
    Action_In In Number
  ) Is
    -- Action_In: 1 重建单据；2 取消重建单据
    v_No 病人医嘱发送.No%Type;
  Begin
    If Action_In = 1 Then
      Select Nextno(14) Into v_No From Dual;
    
      Update 病人医嘱发送
      Set NO = v_No, 计费状态 = 0
      Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In);
      Update 住院费用记录 Set 医嘱序号 = Null Where NO = No_In;
    Elsif Action_In = 2 Then
      Update 住院费用记录 Set 医嘱序号 = 医嘱id_In Where NO = No_In;
      Update 病人医嘱发送
      Set NO = No_In, 计费状态 = 4
      Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In);
    End If;
  
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End 病人医嘱_重建单据;

  --10、打印RIS检查预约通知单
  Procedure Ris检查预约_打印(医嘱id_In In Ris检查预约.医嘱id%Type) Is
  Begin
    Update Ris检查预约 Set 是否打印 = 1 Where 医嘱id = 医嘱id_In;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End Ris检查预约_打印;

  --11、更新RIS分科室启用参数
  Procedure Ris启用控制_Update
  (
    检查类型_In Ris启用控制.检查类型%Type,
    场合_In     Ris启用控制.场合%Type,
    部门ids_In  Varchar2,
    启用类型_In Number
  ) Is
  
    l_部门id   t_Numlist := t_Numlist();
    v_启用ris  Ris启用控制.是否启用ris%Type;
    v_启用预约 Ris启用控制.是否启用预约%Type;
  
    Cursor c_Dept(Dept_In Varchar2) Is
      Select Column_Value From Table(f_Num2list(Dept_In));
  Begin
  
    If 启用类型_In = 1 Then
      v_启用ris  := 1;
      v_启用预约 := Null;
      Delete From Ris启用控制 Where 检查类型 = 检查类型_In And 场合 = 场合_In And 是否启用ris = 1;
    Else
      v_启用ris  := Null;
      v_启用预约 := 1;
      Delete From Ris启用控制 Where 检查类型 = 检查类型_In And 场合 = 场合_In And 是否启用预约 = 1;
    End If;
  
    If 部门ids_In Is Null Then
      Insert Into Ris启用控制
        (ID, 检查类型, 场合, 部门id, 是否启用ris, 是否启用预约)
      Values
        (Ris启用控制_Id.Nextval, 检查类型_In, 场合_In, Null, v_启用ris, v_启用预约);
    Else
      Open c_Dept(部门ids_In);
      Fetch c_Dept Bulk Collect
        Into l_部门id;
      Close c_Dept;
    
      Forall I In 1 .. l_部门id.Count
        Insert Into Ris启用控制
          (ID, 检查类型, 场合, 部门id, 是否启用ris, 是否启用预约)
        Values
          (Ris启用控制_Id.Nextval, 检查类型_In, 场合_In, l_部门id(I), v_启用ris, v_启用预约);
    End If;
  
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End Ris启用控制_Update;

  --12、删除RIS分科室启用参数
  Procedure Ris启用控制_Delete Is
  
  Begin
    Delete From Ris启用控制;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End Ris启用控制_Delete;

  --13、根据元素名提取信息
  Function Ris_Replace_Element_Value
  (
    元素名_In   In 诊治所见项目.中文名%Type,
    病人id_In   In 电子病历记录.病人id%Type,
    就诊id_In   In 电子病历记录.主页id%Type,
    病人来源_In In 电子病历记录.病人来源%Type,
    医嘱id_In   In 病人医嘱发送.医嘱id%Type
  ) Return Varchar2 Is
    v_Return Varchar2(4000) := Null;
    Cursor c_Patient Is
      Select 姓名, 性别, Decode(性别, '男', 'M', '女', 'F', 'O') As 性别编码, 出生日期, 病人id, 联系人地址, 家庭电话, 联系人电话, 婚姻状况, 身份证号, 当前科室id,
             当前病区id, 当前床号 As 床号, 就诊卡号, 入院时间, 出院时间
      From 病人信息
      Where 病人id = 病人id_In;
    r_Patient c_Patient%RowType;
  
    Cursor c_Order Is
      Select 主页id, 婴儿, Decode(病人来源, 1, 'OUTPAT', 2, 'INPAT', 'UNK') As 病人来源, 开嘱医生, 开嘱时间, 校对护士, 医嘱内容, 紧急标志, 执行科室id
      From 病人医嘱记录
      Where ID = 医嘱id_In;
    r_Order c_Order%RowType;
  
    Cursor c_Diagnose Is
      Select 诊断描述 || Decode(Nvl(是否疑诊, 0), 0, '', ' (？)') As 临床诊断
      From 病人诊断医嘱 A, 病人诊断记录 B
      Where a.医嘱id = 医嘱id_In And a.诊断id = b.Id;
    r_Diagnose c_Diagnose%RowType;
  
    --获取指定表的行类型
    Procedure p_Get_Rowtype(Table_In In Varchar2) Is
    Begin
      If Table_In = '病人信息' Then
        Open c_Patient;
        Fetch c_Patient
          Into r_Patient;
      Elsif Table_In = '病人医嘱记录' Then
        Open c_Order;
        Fetch c_Order
          Into r_Order;
      Elsif Table_In = '病人诊断记录' Then
        Open c_Diagnose;
        Fetch c_Diagnose
          Into r_Diagnose;
      End If;
    Exception
      When Others Then
        Null;
    End p_Get_Rowtype;
  
  Begin
    Case
    --直接返回的输入元素
      When 元素名_In = '医嘱ID' Then
        v_Return := 医嘱id_In;
      When 元素名_In = '病人ID' Then
        v_Return := 病人id_In;
      
    --姓名，性别单独处理，可能是婴儿
      When Instr(',姓名,性别,性别编码,出生日期,', ',' || 元素名_In || ',') > 0 Then
        p_Get_Rowtype('病人医嘱记录');
        p_Get_Rowtype('病人信息');
        If Nvl(r_Order.婴儿, 0) = 0 Then
          If 元素名_In = '姓名' Then
            v_Return := r_Patient.姓名;
          Elsif 元素名_In = '性别' Then
            v_Return := r_Patient.性别;
          Elsif 元素名_In = '性别编码' Then
            v_Return := r_Patient.性别编码;
          Elsif 元素名_In = '出生日期' Then
            v_Return := To_Char(r_Patient.出生日期, 'YYYYMMDDMISS');
          End If;
        Else
          If 元素名_In = '姓名' Then
            Select Decode(婴儿姓名, Null, r_Patient.姓名 || '之婴' || Trim(To_Char(序号, '9')), 婴儿姓名) As 婴儿姓名
            Into v_Return
            From 病人新生儿记录
            Where 病人id = 病人id_In And 主页id = r_Order.主页id And 序号 = Nvl(r_Order.婴儿, 0);
          Elsif Instr('性别', 元素名_In) > 0 Then
            Select 婴儿性别
            Into v_Return
            From 病人新生儿记录
            Where 病人id = 病人id_In And 主页id = r_Order.主页id And 序号 = Nvl(r_Order.婴儿, 0);
            If 元素名_In = '性别编码' Then
              Select Decode(v_Return, '男', 'M', '女', 'F', 'O') Into v_Return From Dual;
            End If;
          Elsif 元素名_In = '出生日期' Then
            Select 出生时间
            Into v_Return
            From 病人新生儿记录
            Where 病人id = 病人id_In And 主页id = r_Order.主页id And 序号 = Nvl(r_Order.婴儿, 0);
            v_Return := To_Char(v_Return, 'YYYYMMDDMISS');
          End If;
        End If;
      
    --查询病人信息表返回的元素
      When Instr(',联系人地址,家庭电话,联系人电话,婚姻状况,身份证号,床号,就诊卡号,入院时间,出院时间,', ',' || 元素名_In || ',') > 0 Then
        p_Get_Rowtype('病人信息');
        Case 元素名_In
          When '联系人地址' Then
            v_Return := r_Patient.联系人地址;
          When '家庭电话' Then
            v_Return := r_Patient.家庭电话;
          When '联系人电话' Then
            v_Return := r_Patient.联系人电话;
          When '婚姻状况' Then
            v_Return := r_Patient.婚姻状况;
          When '身份证号' Then
            v_Return := r_Patient.身份证号;
          When '床号' Then
            v_Return := r_Patient.床号;
          When '就诊卡号' Then
            v_Return := r_Patient.就诊卡号;
          When '入院时间' Then
            v_Return := To_Char(r_Patient.入院时间, 'YYYYMMDDMISS');
          When '出院时间' Then
            v_Return := To_Char(r_Patient.出院时间, 'YYYYMMDDMISS');
          Else
            v_Return := '';
        End Case;
        --查询医嘱表返回的元素
      When Instr(',病人来源,开嘱医生,开嘱时间,校对护士,医嘱内容,紧急标志,紧急标志对码,', ',' || 元素名_In || ',') > 0 Then
        p_Get_Rowtype('病人医嘱记录');
        Case 元素名_In
          When '病人来源' Then
            v_Return := r_Order.病人来源;
          When '开嘱医生' Then
            v_Return := r_Order.开嘱医生;
          When '开嘱时间' Then
            v_Return := To_Char(r_Order.开嘱时间, 'YYYYMMDDMISS');
          When '校对护士' Then
            v_Return := r_Order.校对护士;
          When '医嘱内容' Then
            v_Return := r_Order.医嘱内容;
          When '紧急标志' Then
            v_Return := r_Order.紧急标志;
        End Case;
        --查询诊断记录返回的元素
      When 元素名_In = '临床诊断' Then
        p_Get_Rowtype('病人诊断记录');
        v_Return := r_Diagnose.临床诊断;
      
      Else
        --自行查询SQL返回值的元素
        If 元素名_In = '执行站点' Then
          p_Get_Rowtype('病人医嘱记录');
          Select Decode(站点, 1, 'SITE0002', 2, 'SITE0001', 3, 'SITE0003', 'SITE0001')
          Into v_Return
          From 部门表
          Where ID = r_Order.执行科室id;
        End If;
        If 元素名_In = '当前科室名称' Then
          p_Get_Rowtype('病人信息');
          Select 名称 Into v_Return From 部门表 Where ID = r_Patient.当前科室id;
        End If;
        If 元素名_In = '病区名称' Then
          p_Get_Rowtype('病人信息');
          Select 名称 Into v_Return From 部门表 Where ID = r_Patient.当前病区id;
        End If;
        If 元素名_In = '标识号' Then
          Select Decode(a.病人来源, 1, c.门诊号, 2, Decode(c.住院号, Null, c.门诊号, c.住院号), 4, c.健康号, c.门诊号)
          Into v_Return
          From 病人医嘱记录 A, 病人信息 C
          Where a.病人id = c.病人id And a.Id = 医嘱id_In;
        End If;
    End Case;
  
    Return Trim(v_Return);
  Exception
    When Others Then
      Return Null;
  End Ris_Replace_Element_Value;

  --14、删除RIS分院设置参数
  Procedure Ris分院设置_Delete Is
  Begin
    Delete From Ris分院设置;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End Ris分院设置_Delete;

  --15、更新RISRis分院设置参数
  Procedure Ris分院设置_Update
  (
    Id_In           Ris分院设置.Id%Type,
    医院名称_In     Ris分院设置.医院名称%Type,
    医院代码_In     Ris分院设置.医院代码%Type,
    用户名_In       Ris分院设置.用户名%Type,
    密码_In         Ris分院设置.密码%Type,
    数据库服务名_In Ris分院设置.数据库服务名%Type
  ) Is
  
  Begin
  
    Insert Into Ris分院设置
      (ID, 医院名称, 医院代码, 用户名, 密码, 数据库服务名)
    Values
      (Id_In, 医院名称_In, 医院代码_In, 用户名_In, 密码_In, 数据库服务名_In);
  
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End Ris分院设置_Update;

End b_Zlxwinterface;
/

--117884:梁唐彬,2017-12-14,非病人病区执行的附费药品不自动取消发药
Create Or Replace Procedure Zl_住院医嘱执行_Cancel
(
  医嘱id_In     病人医嘱执行.医嘱id%Type,
  发送号_In     病人医嘱执行.发送号%Type,
  单独执行_In   Number,
  操作员编号_In 人员表.编号%Type,
  操作员姓名_In 人员表.姓名%Type,
  组id_In       病人医嘱执行.医嘱id%Type,
  诊疗类别_In   病人医嘱记录.诊疗类别%Type,
  执行部门id_In 门诊费用记录.执行部门id%Type
  --参数：医嘱ID_IN=单独执行的医嘱ID，检验组合为显示的检验项目的ID。
  --      单独执行_In=检验医嘱组合是否采用对每个项目分散单独执行的方式
) Is
  --医嘱相关的费用单据
  Cursor c_No Is
    Select a.No || ':' || a.记录性质
    From 病人医嘱附费 A, 病人医嘱记录 B
    Where a.发送号 + 0 = 发送号_In And a.医嘱id = b.Id And b.诊疗类别 = 诊疗类别_In And (b.Id = 组id_In Or b.相关id = 组id_In)
    Union
    Select NO || ':' || 记录性质 From 病人医嘱发送 Where 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In;

  Cursor c_Noone Is
    Select NO || ':' || 记录性质
    From 病人医嘱附费
    Where 发送号 + 0 = 发送号_In And 医嘱id = 医嘱id_In
    Union
    Select NO || ':' || 记录性质 From 病人医嘱发送 Where 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In;
  r_No       t_Strlist;
  r_No_Stuff t_Strlist;
  r_Finish   t_Numlist;

  n_执行次数 Number;
  n_剩余次数 Number;
  n_执行状态 Number;
  n_Count    Number;
  --要取消执行的费用行(不包含药品和跟踪在用的卫材)
  Cursor c_Finish(r_No t_Strlist) Is
    Select /*+ RULE */
     a.Id
    From (Select Distinct a.Id, a.收费类别, a.收费细目id
           From 住院费用记录 A, 病人医嘱记录 B,
                (Select Substr(Column_Value, 1, Instr(Column_Value, ':') - 1) As NO,
                         To_Number(Substr(Column_Value, Instr(Column_Value, ':') + 1)) As 记录性质
                  From Table(r_No)) N
           Where a.医嘱序号 = b.Id And (b.Id = 组id_In Or b.相关id = 组id_In) And a.No = n.No And a.记录性质 = n.记录性质 And
                 a.记录状态 In (0, 1, 3) And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In)) A, 材料特性 B
    Where a.收费细目id = b.材料id(+) And Not a.收费类别 In ('5', '6', '7') And Not (a.收费类别 = '4' And Nvl(b.跟踪在用, 0) = 1);

  Cursor c_Finishone(r_No t_Strlist) Is
    Select /*+ RULE */
     a.Id
    From (Select a.Id, a.收费类别, a.收费细目id
           From 住院费用记录 A,
                (Select Substr(Column_Value, 1, Instr(Column_Value, ':') - 1) As NO,
                         To_Number(Substr(Column_Value, Instr(Column_Value, ':') + 1)) As 记录性质
                  From Table(r_No)) N
           Where a.医嘱序号 = 医嘱id_In And a.No = n.No And a.记录性质 = n.记录性质 And a.记录状态 In (0, 1, 3) And
                 (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In)) A, 材料特性 B
    Where a.收费细目id = b.材料id(+) And Not a.收费类别 In ('5', '6', '7') And Not (a.收费类别 = '4' And Nvl(b.跟踪在用, 0) = 1);

  --取消执行中包含跟踪在用的发料卫料时，根据参数设置是否自动退料
  --卫生材料医嘱目前不存在单独和组合执行的情况
  Cursor c_Stuff(r_No t_Strlist) Is
    Select /*+ RULE */
     b.Id
    From 住院费用记录 A, 药品收发记录 B, 病人医嘱记录 C,
         (Select Substr(Column_Value, 1, Instr(Column_Value, ':') - 1) As NO,
                  To_Number(Substr(Column_Value, Instr(Column_Value, ':') + 1)) As 记录性质
           From Table(r_No)) N
    Where a.Id = b.费用id And (b.记录状态 = 1 Or Mod(b.记录状态, 3) = 0) And b.审核人 Is Not Null And a.收费类别 = '4' And a.记录状态 = 1 And
          a.医嘱序号 = c.Id And c.诊疗类别 = 诊疗类别_In And (c.Id = 组id_In Or c.相关id = 组id_In) And a.No = n.No And a.记录性质 = n.记录性质 And
          b.单据 In (25, 26) And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In)
    Order By b.药品id;

  --取消执行中包含药品时，本科执行的自动退药
  Cursor c_Drug(r_No t_Strlist) Is
    Select /*+ RULE */
     b.Id
    From 住院费用记录 A, 药品收发记录 B, 病人医嘱记录 C, 病案主页 D,
         (Select Substr(Column_Value, 1, Instr(Column_Value, ':') - 1) As NO,
                  To_Number(Substr(Column_Value, Instr(Column_Value, ':') + 1)) As 记录性质
           From Table(r_No)) N
    Where a.Id = b.费用id And (b.记录状态 = 1 Or Mod(b.记录状态, 3) = 0) And b.审核人 Is Not Null And b.库房id = 执行部门id_In And
          a.收费类别 In ('5', '6', '7') And a.记录状态 = 1 And a.医嘱序号 = c.Id And c.诊疗类别 = 诊疗类别_In And c.病人id = d.病人id And
          c.主页id = d.主页id And (c.Id = 组id_In Or c.相关id = 组id_In) And a.No = n.No And a.记录性质 = n.记录性质
    Order By b.药品id;

  v_医嘱期效 病人医嘱记录.医嘱期效%Type;
Begin
  Open c_Noone;
  Fetch c_Noone Bulk Collect
    Into r_No_Stuff;
  Close c_Noone;

  If Nvl(单独执行_In, 0) = 0 Then
    Open c_No;
    Fetch c_No Bulk Collect
      Into r_No;
    Close c_No;
  Else
    r_No := r_No_Stuff;
  End If;

  --主费用可能需要限制医嘱序号
  --不包含药品和跟踪在用的卫材，因为这些都要发放才表示执行
  If Nvl(单独执行_In, 0) = 0 Then
    Open c_Finish(r_No);
    Fetch c_Finish Bulk Collect
      Into r_Finish;
    Close c_Finish;
  Else
    Open c_Finishone(r_No);
    Fetch c_Finishone Bulk Collect
      Into r_Finish;
    Close c_Finishone;
  End If;

  Select Decode(a.执行状态, 1, a.发送数次, c.登记次数), Decode(a.执行状态, 1, 0, a.发送数次 - c.登记次数)
  Into n_执行次数, n_剩余次数
  From 病人医嘱发送 A,
       (Select 医嘱id_In 医嘱id, 发送号_In 发送号, Nvl(Sum(b.本次数次), 0) As 登记次数
         From 病人医嘱执行 B
         Where b.医嘱id = 医嘱id_In And b.发送号 = 发送号_In And Nvl(b.执行结果, 1) <> 0) C
  Where a.医嘱id = c.医嘱id And a.发送号 = c.发送号 And a.医嘱id = 医嘱id_In And a.发送号 = 发送号_In;

  --如果全部执行则状态为1，未执行状态为0，部分执行状态为2
  Select Decode(n_剩余次数, 0, 1, Decode(n_执行次数, 0, 0, 2)) Into n_执行状态 From Dual;

  Forall I In 1 .. r_Finish.Count
    Update 住院费用记录
    Set 执行状态 = n_执行状态, 执行时间 = Decode(n_执行状态, 0, Null, 执行时间), 执行人 = Decode(n_执行状态, 0, Null, 执行人)
    Where ID = r_Finish(I);

  --处理跟踪在用卫材自动发料
  For r_Stuff In c_Stuff(r_No_Stuff) Loop
    Zl_材料收发记录_部门退料(r_Stuff.Id, 操作员姓名_In, Sysdate, Null, Null, Null, Null, 0, 操作员姓名_In);
  End Loop;

  --处理药品自动发药(只在护士站，本科药品才处理,本科由参数和游标判断)
  Select Max(a.医嘱期效), Max(Decode(b.病区id, 执行部门id_In, 1, 0))
  Into v_医嘱期效, n_Count
  From 病人医嘱记录 A, 病人变动记录 B
  Where a.病人id = b.病人id And a.主页id = b.主页id And a.Id = 医嘱id_In;

  If Substr(Zl_Getsysparameter('本科执行自动完成', 1254), v_医嘱期效 + 1, 1) = '1' And n_Count = 1 Then
    For r_Drug In c_Drug(r_No_Stuff) Loop
      Zl_药品收发记录_部门退药(r_Drug.Id, 操作员姓名_In, Sysdate);
    End Loop;
  End If;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_住院医嘱执行_Cancel;
/

--115519:李小东,2017-12-14,拒收后重采标本允许医嘱回退和作废
Create Or Replace Procedure Zl_检验预置条码_采集完成
(
  医嘱内容_In Varchar2, --内容包括多个医嘱ID使用","分隔 
  人员编号_In 人员表.编号%Type := Null,
  人员姓名_In 人员表.姓名%Type := Null, --Null=取消，不为空时完成采集
  操作_In     Number := 0, --0=完成采集，1=取消采集
  医嘱类别_In Number := 0 --0=检验医嘱,1=输血医嘱 
) Is
  n_自动发料 Number;
  --查找当前标本的相关申请 
  Cursor c_Samplequest(v_医嘱id In Varchar2) Is
    Select /*+ rule */
    Distinct ID As 医嘱id, 病人来源
    From 病人医嘱记录 A, 病人医嘱发送 B
    Where a.Id = b.医嘱id And b.接收人 Is Null And Sign(Nvl(a.相关id, 0)) = 医嘱类别_In And
          a.Id In (Select * From Table(Cast(f_Num2list(v_医嘱id) As Zltools.t_Numlist)));

  --未审核的费用行(不包含药品) 
  Cursor c_Verify(v_医嘱id In Varchar2) Is
    Select /*+ rule */
    Distinct 记录性质, NO, 序号, 记录状态, 门诊标志
    From 住院费用记录
    Where 收费类别 Not In ('5', '6', '7') And
          医嘱序号 + 0 In (Select ID
                       From 病人医嘱记录
                       Where ID In (Select * From Table(Cast(f_Num2list(v_医嘱id) As Zltools.t_Numlist))) And
                             Sign(Nvl(相关id, 0)) = 医嘱类别_In) And 记帐费用 = 1 And 记录状态 = 0 And 价格父号 Is Null And
          (记录性质, NO) In (Select 记录性质, NO
                         From 病人医嘱附费
                         Where 医嘱id In (Select * From Table(Cast(f_Num2list(v_医嘱id) As Zltools.t_Numlist)))
                         Union All
                         Select 记录性质, NO
                         From 病人医嘱发送
                         Where 医嘱id In (Select ID
                                        From 病人医嘱记录
                                        Where ID In (Select * From Table(Cast(f_Num2list(v_医嘱id) As Zltools.t_Numlist))) And
                                              Sign(Nvl(相关id, 0)) = 医嘱类别_In) And 接收人 Is Null)
    Union All
    Select /*+ rule */
    Distinct 记录性质, NO, 序号, 记录状态, 门诊标志
    From 门诊费用记录
    Where 收费类别 Not In ('5', '6', '7') And
          医嘱序号 + 0 In (Select ID
                       From 病人医嘱记录
                       Where ID In (Select * From Table(Cast(f_Num2list(v_医嘱id) As Zltools.t_Numlist))) And
                             Sign(Nvl(相关id, 0)) = 医嘱类别_In) And 记帐费用 = 1 And 记录状态 = 0 And 价格父号 Is Null And
          (记录性质, NO) In (Select 记录性质, NO
                         From 病人医嘱附费
                         Where 医嘱id In (Select * From Table(Cast(f_Num2list(v_医嘱id) As Zltools.t_Numlist)))
                         Union All
                         Select 记录性质, NO
                         From 病人医嘱发送
                         Where 医嘱id In (Select ID
                                        From 病人医嘱记录
                                        Where ID In (Select * From Table(Cast(f_Num2list(v_医嘱id) As Zltools.t_Numlist))) And
                                              Sign(Nvl(相关id, 0)) = 医嘱类别_In) And 接收人 Is Null)
    Order By 记录性质, NO, 序号;

  v_检验标本记录 Number(18);
  v_执行状态     Number(1);
  v_接收人       Varchar2(50);
  v_Error        Varchar2(100);
  v_No           病人医嘱发送.No%Type;
  v_性质         病人医嘱发送.记录性质%Type;
  v_序号         Varchar2(1000);

  v_收发ids Varchar2(4000);
  n_库房id  Number;
  n_发料号  Number;

  Err_Custom Exception;
  n_Par Number;
Begin
  Select zl_GetSysParameter('自动发料退料', 1211) Into n_自动发料 From Dual;
  If 人员姓名_In Is Not Null And 操作_In = 0 Then
    --检查标本是否被核收或接收 
    Begin
      Select /*+ rule */
       Nvl(c.Id, 0), b.执行状态, b.接收人
      Into v_检验标本记录, v_执行状态, v_接收人
      From 病人医嘱记录 A, 病人医嘱发送 B, 检验标本记录 C
      Where a.Id = b.医嘱id And a.相关id = c.医嘱id(+) And
            a.Id In (Select * From Table(Cast(f_Num2list(医嘱内容_In) As Zltools.t_Numlist)));
    Exception
      When Others Then
        v_检验标本记录 := 0;
    End;
  
    If v_检验标本记录 <> 0 Then
      v_Error := '标本已被检验科核收不能完成采集!';
      Raise Err_Custom;
    End If;
  
    If v_执行状态 <> 2 And v_接收人 Is Not Null Then
      v_Error := '标本已被检验科签收不能完成采集!';
      Raise Err_Custom;
    End If;
  
    --检查医嘱是否收费
    n_Par := Zl_To_Number(Nvl(zl_GetSysParameter(163), '0'));
    If n_Par = 1 Then
      For r_Verify In c_Verify(医嘱内容_In) Loop
        If r_Verify.记录状态 = 0 Then
          If r_Verify.门诊标志 = 1 Then
            v_Error := '标本未收费，不允许执行，请联系管理员！';
            Raise Err_Custom;
          Elsif r_Verify.门诊标志 = 2 Then
            v_Error := '标本未记账，不允许执行，请联系管理员！';
            Raise Err_Custom;
          End If;
        End If;
      End Loop;
    End If;
  
    Update /*+ rule */ 检验拒收记录
    Set 重采人 = 人员姓名_In, 重采时间 = Sysdate
    Where 医嘱id In (Select * From Table(Cast(f_Num2list(医嘱内容_In) As Zltools.t_Numlist)));
  
    --更新采集信息(检验和采集） 
    Update /*+ rule */ 病人医嘱发送
    Set 采样人 = 人员姓名_In, 采样时间 = Sysdate, 执行状态 = Decode(执行状态, 2, 0, 执行状态),
        重采标本 = Decode(Nvl(重采标本, 0), 0, Decode(执行状态, 2, 1, 0), 重采标本), 执行说明 = Null
    Where 医嘱id In (Select * From Table(Cast(f_Num2list(医嘱内容_In) As Zltools.t_Numlist)));
  
    --更新医嘱和费用记录 
    For r_Samplequest In c_Samplequest(医嘱内容_In) Loop
      If r_Samplequest.病人来源 = 2 Then
        --2.费用执行处理 
        Update 住院费用记录
        Set 执行状态 = 1, 执行时间 = Sysdate, 执行人 = 人员姓名_In
        Where 收费类别 Not In ('5', '6', '7') And
              (医嘱序号, 记录性质, NO) In
              (Select 医嘱id, 记录性质, NO
               From 病人医嘱附费
               Where 医嘱id = r_Samplequest.医嘱id
               Union All
               Select 医嘱id, 记录性质, NO
               From 病人医嘱发送
               Where 医嘱id In (Select ID
                              From 病人医嘱记录 A, 病人医嘱发送 B
                              Where a.Id = b.医嘱id And r_Samplequest.医嘱id In (a.Id) And Sign(Nvl(a.相关id, 0)) = 医嘱类别_In And
                                    b.执行状态 In (0, 2) And b.接收人 Is Null));
      Else
        --发料
        If n_自动发料 = 1 Then
          For c_Stuff In (Select a.记录性质, a.记录状态, b.Id, b.库房id
                          From 门诊费用记录 A, 药品收发记录 B
                          Where a.Id = b.费用id And a.收费类别 = '4' And b.审核人 Is Null And
                                (a.医嘱序号, a.记录性质, a.No) In
                                (Select 医嘱id, 记录性质, NO
                                 From 病人医嘱附费
                                 Where 医嘱id = r_Samplequest.医嘱id
                                 Union All
                                 Select 医嘱id, 记录性质, NO
                                 From 病人医嘱发送
                                 Where 医嘱id In
                                       (Select ID
                                        From 病人医嘱记录 A, 病人医嘱发送 B
                                        Where a.Id = b.医嘱id And r_Samplequest.医嘱id In (a.Id) And
                                              Sign(Nvl(a.相关id, 0)) = 医嘱类别_In And b.执行状态 In (0, 2) And b.接收人 Is Null))) Loop
            If Mod(Nvl(c_Stuff.记录性质, 0), 10) = 1 And Nvl(c_Stuff.记录状态, 0) = 1 Then
              If n_发料号 Is Null Then
                n_发料号 := Nextno(20);
              End If;
            
              If c_Stuff.库房id <> Nvl(n_库房id, 0) Then
                If Nvl(n_库房id, 0) <> 0 And v_收发ids Is Not Null Then
                  v_收发ids := Substr(v_收发ids, 2);
                  Zl_药品收发记录_批量发料(v_收发ids, n_库房id, 人员姓名_In, Sysdate, 1, 人员姓名_In, n_发料号, 人员姓名_In);
                End If;
              
                n_库房id  := c_Stuff.库房id;
                v_收发ids := Null;
              End If;
            
              v_收发ids := v_收发ids || '|' || c_Stuff.Id || ',0';
            End If;
          End Loop;
          If Nvl(n_库房id, 0) <> 0 And v_收发ids Is Not Null Then
            v_收发ids := Substr(v_收发ids, 2);
            Zl_药品收发记录_批量发料(v_收发ids, n_库房id, 人员姓名_In, Sysdate, 1, 人员姓名_In, n_发料号, 人员姓名_In);
          End If;
        End If;
      
        --2.费用执行处理 
        Update 门诊费用记录
        Set 执行状态 = 1, 执行时间 = Sysdate, 执行人 = 人员姓名_In
        Where 收费类别 Not In ('5', '6', '7') And
              (医嘱序号, 记录性质, NO) In
              (Select 医嘱id, 记录性质, NO
               From 病人医嘱附费
               Where 医嘱id = r_Samplequest.医嘱id
               Union All
               Select 医嘱id, 记录性质, NO
               From 病人医嘱发送
               Where 医嘱id In (Select ID
                              From 病人医嘱记录 A, 病人医嘱发送 B
                              Where a.Id = b.医嘱id And r_Samplequest.医嘱id In (a.Id) And Sign(Nvl(a.相关id, 0)) = 医嘱类别_In And
                                    b.执行状态 In (0, 2) And b.接收人 Is Null));
      End If;
    End Loop;
  
    --更新执行状态(只更新采集） 
    Update /*+ rule */ 病人医嘱发送
    Set 执行状态 = 1, 完成人 = 人员姓名_In, 完成时间 = Sysdate
    Where 医嘱id In (Select ID
                   From 病人医嘱记录
                   Where ID In (Select * From Table(Cast(f_Num2list(医嘱内容_In) As Zltools.t_Numlist))) And
                         Sign(Nvl(相关id, 0)) = 医嘱类别_In);
    --3.自动审核记帐 
    For r_Verify In c_Verify(医嘱内容_In) Loop
      If r_Verify.No || ',' || r_Verify.记录性质 <> v_No || ',' || v_性质 Then
        If v_序号 Is Not Null Then
          If v_性质 = 1 Then
            Zl_门诊记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
          Elsif v_性质 = 2 Then
            Zl_住院记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
          End If;
        End If;
        v_序号 := Null;
      End If;
      v_No   := r_Verify.No;
      v_性质 := r_Verify.记录性质;
      v_序号 := v_序号 || ',' || r_Verify.序号;
    End Loop;
    If v_序号 Is Not Null Then
      If v_性质 = 1 Then
        Zl_门诊记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
      Elsif v_性质 = 2 Then
        Zl_住院记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
      End If;
    End If;
  
  Else
    --检查标本是否被核收或接收 
    Begin
      Select /*+ rule */
       Nvl(c.Id, 0), b.执行状态, b.接收人
      Into v_检验标本记录, v_执行状态, v_接收人
      From 病人医嘱记录 A, 病人医嘱发送 B, 检验标本记录 C
      Where a.Id = b.医嘱id And a.相关id = c.医嘱id(+) And
            a.Id In (Select * From Table(Cast(f_Num2list(医嘱内容_In) As Zltools.t_Numlist)));
    Exception
      When Others Then
        v_检验标本记录 := 0;
    End;
  
    If v_检验标本记录 <> 0 Then
      v_Error := '标本已被检验科核收不能取消完成采集!';
      Raise Err_Custom;
    End If;
  
    If v_执行状态 <> 2 And v_接收人 Is Not Null Then
      v_Error := '标本已被检验科签收不能取消完成采集!';
      Raise Err_Custom;
    End If;
  
    Update /*+ rule */ 病人医嘱发送
    Set 采样人 = Null, 采样时间 = Null, 执行状态 = 0, 执行说明 = Null, 完成人 = Null, 完成时间 = Null
    Where 医嘱id In (Select ID
                   From 病人医嘱记录
                   Where ID In (Select * From Table(Cast(f_Num2list(医嘱内容_In) As Zltools.t_Numlist))));
  
    For r_Samplequest In c_Samplequest(医嘱内容_In) Loop
    
      If r_Samplequest.病人来源 = 2 Then
        --2.费用执行处理 
        Update 住院费用记录
        Set 执行状态 = 0, 执行时间 = Null, 执行人 = 人员姓名_In
        Where 收费类别 Not In ('5', '6', '7') And
              (医嘱序号, 记录性质, NO) In
              (Select 医嘱id, 记录性质, NO
               From 病人医嘱附费
               Where 医嘱id = r_Samplequest.医嘱id
               Union All
               Select 医嘱id, 记录性质, NO
               From 病人医嘱发送
               Where 医嘱id In (Select ID
                              From 病人医嘱记录
                              Where r_Samplequest.医嘱id In (ID) And Sign(Nvl(相关id, 0)) = 医嘱类别_In) And 执行状态 In (0, 2) And
                     接收人 Is Null);
      Else
        --退料
        If n_自动发料 = 1 Then
          For c_Stuff In (Select b.Id, b.实际数量
                          From 门诊费用记录 A, 药品收发记录 B
                          Where a.Id = b.费用id And a.收费类别 = '4' And (b.记录状态 = 1 Or Mod(b.记录状态, 3) = 0) And
                                b.审核人 Is Not Null And (a.医嘱序号, a.记录性质, a.No) In
                                (Select 医嘱id, 记录性质, NO
                                                       From 病人医嘱附费
                                                       Where 医嘱id = r_Samplequest.医嘱id
                                                       Union All
                                                       Select 医嘱id, 记录性质, NO
                                                       From 病人医嘱发送
                                                       Where 医嘱id In (Select ID
                                                                      From 病人医嘱记录
                                                                      Where r_Samplequest.医嘱id In (ID) And
                                                                            Sign(Nvl(相关id, 0)) = 医嘱类别_In) And
                                                             执行状态 In (0, 2) And 接收人 Is Null)) Loop
          
            Zl_材料收发记录_部门退料(c_Stuff.Id, 人员姓名_In, Sysdate, Null, Null, Null, c_Stuff.实际数量);
          End Loop;
        End If;
        --退费
        Update 门诊费用记录
        Set 执行状态 = 0, 执行时间 = Null, 执行人 = 人员姓名_In
        Where 收费类别 Not In ('5', '6', '7') And
              (医嘱序号, 记录性质, NO) In
              (Select 医嘱id, 记录性质, NO
               From 病人医嘱附费
               Where 医嘱id = r_Samplequest.医嘱id
               Union All
               Select 医嘱id, 记录性质, NO
               From 病人医嘱发送
               Where 医嘱id In (Select ID
                              From 病人医嘱记录
                              Where r_Samplequest.医嘱id In (ID) And Sign(Nvl(相关id, 0)) = 医嘱类别_In) And 执行状态 In (0, 2) And
                     接收人 Is Null);
      End If;
    End Loop;
  End If;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_检验预置条码_采集完成;
/

--116339:陈刘,2017-12-18,记录项目管理√符号设置修改
Create Or Replace Procedure Zl_护理记录项目_Insert
(
  项目序号_In In 护理记录项目.项目序号%Type,
  项目名称_In In 护理记录项目.项目名称%Type,
  项目类型_In In 护理记录项目.项目类型%Type,
  项目长度_In In 护理记录项目.项目长度%Type,
  项目小数_In In 护理记录项目.项目小数%Type,
  项目单位_In In 护理记录项目.项目单位%Type,
  项目表示_In In 护理记录项目.项目表示%Type,
  项目值域_In In 护理记录项目.项目值域%Type,
  护理等级_In In 护理记录项目.护理等级%Type,
  分组名_In   In 护理记录项目.分组名%Type,
  项目id_In   In 护理记录项目.项目id%Type,
  应用方式_In In 护理记录项目.应用方式%Type,
  适用病人_In In 护理记录项目.适用病人%Type,
  项目性质_In In 护理记录项目.项目性质%Type := 1,
  应用场合_In In 护理记录项目.应用场合%Type := 0,
  说明_In     In 护理记录项目.说明%Type := Null,
  缺省值_In     In 护理记录项目.缺省值%Type := Null
) Is
Begin
  Insert Into 护理记录项目
    (项目序号, 项目名称, 项目类型, 项目长度, 项目小数, 项目单位, 项目表示, 项目值域, 护理等级, 分组名, 项目id, 适用科室, 应用方式, 适用病人, 项目性质, 应用场合, 说明, 缺省值)

  Values
    (项目序号_In, 项目名称_In, 项目类型_In, 项目长度_In, 项目小数_In, 项目单位_In, 项目表示_In, 项目值域_In, 护理等级_In, 分组名_In, 项目id_In, 1, 应用方式_In,
     适用病人_In, 项目性质_In, 应用场合_In, 说明_In, 缺省值_In);

  If 项目表示_In = 4 Then
    Insert Into 护理汇总项目
      (序号, 父序号)
      Select 项目序号_In, Null From Dual Where Not Exists (Select 1 From 护理汇总项目 Where 序号 = 项目序号_In);
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_护理记录项目_Insert;
/

--116339:陈刘,2017-12-18,记录项目管理√符号设置修改
Create Or Replace Procedure Zl_护理记录项目_Update
(
  项目序号_In In 护理记录项目.项目序号%Type,
  项目名称_In In 护理记录项目.项目名称%Type,
  项目类型_In In 护理记录项目.项目类型%Type,
  项目长度_In In 护理记录项目.项目长度%Type,
  项目小数_In In 护理记录项目.项目小数%Type,
  项目单位_In In 护理记录项目.项目单位%Type,
  项目表示_In In 护理记录项目.项目表示%Type,
  项目值域_In In 护理记录项目.项目值域%Type,
  护理等级_In In 护理记录项目.护理等级%Type,
  分组名_In   In 护理记录项目.分组名%Type,
  项目id_In   In 护理记录项目.项目id%Type,
  应用方式_In In 护理记录项目.应用方式%Type,
  适用病人_In In 护理记录项目.适用病人%Type,
  项目性质_In In 护理记录项目.项目性质%Type := 1,
  应用场合_In In 护理记录项目.应用场合%Type := 0,
  说明_In     In 护理记录项目.说明%Type := Null,
  缺省值_In     In 护理记录项目.缺省值%Type := Null
) Is
  n_汇总 Number(1);
Begin
  n_汇总 := 0;
  Select Count(项目序号) Into n_汇总 From 护理记录项目 Where 项目序号 = 项目序号_In And 项目表示 = 4;
  Update 护理记录项目
  Set 项目名称 = 项目名称_In, 项目类型 = 项目类型_In, 项目长度 = 项目长度_In, 项目小数 = 项目小数_In, 项目单位 = 项目单位_In, 项目表示 = 项目表示_In, 项目值域 = 项目值域_In,
      护理等级 = 护理等级_In, 分组名 = 分组名_In, 项目id = 项目id_In, 应用方式 = 应用方式_In, 适用病人 = 适用病人_In, 项目性质 = 项目性质_In, 应用场合 = 应用场合_In,
      说明 = 说明_In, 缺省值 = 缺省值_In

  Where 项目序号 = 项目序号_In;

  If 项目序号_In = 2 Then
    Update 护理记录项目
    Set 项目类型 = 项目类型_In, 项目长度 = 项目长度_In, 项目小数 = 项目小数_In, 项目单位 = 项目单位_In, 项目表示 = 项目表示_In, 项目值域 = 项目值域_In, 护理等级 = 护理等级_In,
        分组名 = 分组名_In, 项目性质 = 项目性质_In, 应用场合 = 应用场合_In, 说明 = 说明_In
    Where 项目序号 = -1;
  End If;

  If 项目序号_In = 4 Or 项目序号_In = 5 Then
    Update 护理记录项目
    Set 项目类型 = 项目类型_In, 项目长度 = 项目长度_In, 项目小数 = 项目小数_In, 项目单位 = 项目单位_In, 项目表示 = 项目表示_In, 护理等级 = 护理等级_In, 分组名 = 分组名_In,
        应用方式 = 应用方式_In, 适用病人 = 适用病人_In, 项目性质 = 项目性质_In, 应用场合 = 应用场合_In, 说明 = 说明_In
    Where 项目序号 In (4, 5);
  End If;
  If 项目表示_In = 4 Then
    Insert Into 护理汇总项目
      (序号, 父序号)
      Select 项目序号_In, Null From Dual Where Not Exists (Select 1 From 护理汇总项目 Where 序号 = 项目序号_In);
  Else
    If n_汇总 = 1 Then
      Delete 护理汇总项目 Where 序号 = 项目序号_In;
      Update 护理汇总项目 Set 父序号 = Null Where 父序号 = 项目序号_In;
    End If;
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_护理记录项目_Update;
/

--116848:刘鹏飞,2017-12-14,输血申请检验结果血型对照
Create Or Replace Function Zl_Fun_BloodApplyCode
(
  申请类型_In Number,
  用血安排_In Number,
  模式_In     Number := 1
) Return Varchar2 As
  v_Return Varchar2(100);
Begin
  --功能说明:下单申请时：1、强制控制是否允许修改申请单ABO和RH；2、返回输血申请单上检验指标中的ABO和RH指标代码(也可只返回ABO指标代码)。
  ----                                                        A：提取检验结果时则自动更新ABO和RH。B:保存时检查ABO和RH是否和检验结果内容一致

  --入参说明：
  ----申请类型_In=1-输血申请单;2-取血通知单(便于医院根据申请类型控制)
  ----用血安排_In=0-普通输血;1-紧急输血(便于医院根据输血紧急程度控制)
  ----模式_in:0=通过参数值控制是否允许允许申请单ABO和RH；1=根据检验结果更新ABO和RH；保存是检查ABO、RH是否和检验结果一致(输血申请单时有效)
  --函数返回：模式_in=0时，返回0(允许修改)或1(不允许修改)；模式_in=1时，返回字符串格式: ABO指标代码:0(询问)或1(禁止),RH指标代码:0(询问)或1(禁止)，
  ----        如：800001:1,表示保存时ABO和检验结果不一致时则禁止保存，也可直接写指标代码，如：800001，表示保存时ABO和检验结果不一致时则进行询问。

  If  模式_In = 0 Then
    --0表示允许修改ABO;1不允许修改ABO
    v_Return := '0';
  Else
    --返回空不自动匹配ABO和RH，且保存时不进行检查。
    v_Return := '';
  End If;
  Return v_Return;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_Fun_BloodApplyCode;
/

--116846:刘鹏飞,2017-12-14,输血申请保存自定义函数检查
Create Or Replace Function Zl1_EX_BloodApplyCheck
(
  调用场合_In         Number,
  病人id_In           病人医嘱记录.病人id%Type,
  就诊id_In           Number,
  申请类型_In         Number,
  用血安排_In         Number,
  是否待诊_In         输血申请记录.是否待诊%Type,
  诊断内容_In         病人医嘱附件.内容%Type,
  诊断ids_In          Varchar2,
  输血类型_In         输血类型.名称%Type,
  输血目的_In         输血目的.名称%Type,
  输血性质_In         输血性质.名称%Type,
  预定输血日期_In     病人医嘱记录.标本部位%Type,
  血型_In             血型.名称%Type,
  Rhd_In              Varchar2,
  申请项目_In         Varchar2,
  输血执行科室id_In   病人医嘱记录.执行科室id%Type,
  途径id_In           病人医嘱记录.诊疗项目id%Type,
  途径执行科室id_In   病人医嘱记录.执行科室id%Type,
  备注_In             病人医嘱记录.医生嘱托%Type,
  婴儿序号_In         病人医嘱记录.婴儿%Type := 0,
  即往输血史_In       输血申请记录.即往输血史%Type := Null,
  既往输血反应史_In   输血申请记录.既往输血反应史%Type := Null,
  输血禁忌及过敏史_In 输血申请记录.输血禁忌及过敏史%Type := Null,
  孕产情况_In         输血申请记录.孕产情况%Type := Null,
  受血者属地_In       输血申请记录.受血者属地%Type := Null,
  检验结果_In         Varchar2 := Null
) Return Varchar2
--功能说明：新开和修改输血申请时，保存数据之前对申请的相关内容进行检查，并返回提示及处理结果。
--适用说明：如过需在数据保存之前对申请单内容进行特定检查和控制，以满足医院业务特定环节，则请调整此函数
--入参说明：
  ----调用场合_in=1-门诊,2-住院 
  ----就诊id_In=门诊时传挂号记录id,住院时传入主页id 
  ----申请类型_In=1-输血申请单;2-取血通知单
  ----用血安排_In=0-普通输血;1-紧急输血
  ----是否待诊_In=0-非待诊;1-待诊
  ----诊断内容_In=待诊时为空，否则为诊断内容信息
  ----诊断ids_In=从首页选择的诊断则传入诊断iD，多个诊断以','号分割，自由录入的诊断为空
  ----输血类型_In=对应输血类型字典表的名称
  ----输血目的_In=对应输血目的字典表的名称
  ----输血性质_In=对应输血性质字典表的名称
  ----血型_In=对应血型字典表的名称
  ----Rhd_In=;+;-
  ----申请项目_In=以诊疗项目+申请量的方式传入，如申请多个品种则以';'分割，格式如：输血诊疗项目ID,申请量;输血诊疗项目ID,申请量
  ----途径id_In=输血申请单则是采集方式的诊疗项目id，取血通知单则是输血途径的诊疗项目ID
  ----孕产情况_In=格式:孕次/产次
  ----检验结果_In=输血申请则返回申请单下方的检验结果信息（字段内容请参考:输血检验结果），取血申请则为空。单个指标的内容以<SplitCol>分割，不同指标之间以<SplitRow>分割，返回格式如下：
  ----            检验项目ID<SplitCol>指标代码<SplitCol>指标中文名<SplitCol>指标英文名<SplitCol>指标结果<SplitCol>结果单位<SplitCol>结果标志<SplitCol>结果参考
  ----            <SplitCol>取值序列<SplitCol>是否人工填写<SplitRow>检验项目ID<SplitCol>指标代码<SplitCol>指标中文名<SplitCol>指标英文名<SplitCol>指标结果
  ----            <SplitCol>结果单位<SplitCol>结果标志<SplitCol>结果参考<SplitCol>取值序列<SplitCol>是否人工填写
  ----    
--函数返回："处理结果|提示信息",处理结果=0-正常,1-询问提示,2-禁止；处理结果为0时，无需返回提示信息及分隔符。 
 As
  v_Return Varchar2(200);
Begin
  v_Return := Null;
  Return v_Return;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl1_EX_BloodApplyCheck;
/

--113016:胡俊勇,2017-12-13,门诊常用诊断
Create Or Replace Procedure Zl_医生常用诊断_Update
(
  人员id_In   In 医生常用诊断.人员id%Type,
  科室id_In   In 医生常用诊断.科室id%Type,
  诊断名称_In In 医生常用诊断.诊断名称%Type := Null,
  疾病id_In   In 医生常用诊断.疾病id%Type := Null,
  诊断id_In   In 医生常用诊断.诊断id%Type := Null,
  诊断类型_In In 医生常用诊断.诊断类型%Type := Null
) Is
  --说明：诊断类型_In  11-中医诊断，1-西诊断
Begin
  Update 医生常用诊断
  Set 使用次数 = 使用次数 + 1
  Where 人员id = 人员id_In And Nvl(科室id, 0) = Nvl(科室id_In, 0) And Nvl(诊断名称, '空') = Nvl(诊断名称_In, '空') And
        Nvl(疾病id, 0) = Nvl(疾病id_In, 0) And Nvl(诊断id, 0) = Nvl(诊断id_In, 0) And Nvl(诊断类型, 0) = Nvl(诊断类型_In, 0);
  If Sql%RowCount = 0 Then
    --不存在则新增 
    Insert Into 医生常用诊断
      (ID, 人员id, 科室id, 诊断名称, 疾病id, 诊断id, 使用次数, 诊断类型)
    Values
      (医生常用诊断_Id.Nextval, 人员id_In, 科室id_In, 诊断名称_In, 疾病id_In, 诊断id_In, 1, 诊断类型_In);
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_医生常用诊断_Update;
/

--107484:廖思奇,2017-12-12,调整Zl_影像消息_Xml内容获取中 婴儿病人姓名获取方式
--107484:廖思奇,2017-12-13,布局还原成以前的样式，增加过程错误处理
--117484:廖思奇,2017-12-14,调整Zl_影像消息_Xml内容获取中 婴儿病人姓名获取方式
Create Or Replace Function zl_影像消息_XML内容获取
( 
    医嘱ID_In 病人医嘱记录.id%Type, 
    消息类型_In varchar2, 
    当前用户_In varchar2,
    消息标记_In varchar2:=Null         --新版：检查报告ID 
) Return varchar2 IS 
  v_Context varchar2(4000); 
  n_婴儿序号 病人医嘱记录.婴儿%Type;
  v_姓名 病人医嘱记录.姓名%Type;
  n_主页id   病人医嘱记录.主页id%Type;
 
  --ZLHIS_CIS_005(医技执行安排完成) 
  Function Get_Zlhis_Cis_005 Return varchar2 As 
    v_Return varchar2(4000); 
  Begin 
        Select 
          '<patient_info>' || 
             '<patient_id>' || a.病人id || '</patient_id>' || 
             '<patient_name>' || v_姓名 ||'</patient_name>' || 
          '</patient_info>' || 
          '<patient_clinic>' || 
             '<patient_source>' || b.病人来源 ||'</patient_source>' || 
             '<clinic_dept_id>' || b.病人科室id || '</clinic_dept_id>' || 
          '</patient_clinic>' || 
          '<patient_order>' || 
             '<order_id>' || c.医嘱id || '</order_id>' || 
             '<order_expiry>' || b.医嘱期效 ||'</order_expiry>' || 
             '<order_kind>' || b.诊疗类别 || '</order_kind>' || 
             '<operation_kind>' || d.操作类型 ||'</operation_kind>' || 
             '<order_item_id>' || c.医嘱id || '</order_item_id>' || 
             '<order_item_title>' || b.医嘱内容 ||'</order_item_title>' || 
          '</patient_order>' || 
          '<arrange_result>' || 
             '<arrange_time>' ||To_Char(c.安排时间,'yyyy/mm/dd hh24:mi:ss')|| '</arrange_time>' || 
          '</arrange_result>'   Into v_Return 
 
      From 病人信息 A, 病人医嘱记录 B, 病人医嘱发送 C, 诊疗项目目录 D 
      Where a.病人id = b.病人id And c.医嘱id = b.Id And b.诊疗项目id = d.Id And c.安排时间 Is Not Null And b.相关id Is Null And 
          b.诊疗类别 = 'D' And b.Id = 医嘱id_In; 
    Return v_Return; 
  End Get_Zlhis_Cis_005; 
 
  --ZLHIS_CIS_017(患者检查申请) 
  Function Get_ZLHIS_CIS_017 Return varchar2 As 
    v_return varchar2(4000); 
  Begin 
        Select 
           '<patient_info>' || 
               '<patient_id>' || a.病人id || '</patient_id>' || 
               '<patient_name>' || v_姓名 || '</patient_name>' || 
               '<in_number>' || nvl(a.住院号,0) || '</in_number>' || 
               '<out_number>' || nvl(a.门诊号,0) || '</out_number>' || 
           '</patient_info>' || 
           '<patient_clinic>' || 
               '<patient_source>' || b.病人来源 || '</patient_source>' || 
               '<clinic_id>' || Case b.病人来源 When 1 Then nvl(d.id,0) When 2 Then nvl(b.主页id, 0) Else 0 End || '</clinic_id>' || 
               '<clinic_dept_id>' || nvl(a.当前科室id,0) || '</clinic_dept_id>' || 
           '</patient_clinic>' || 
           '<check_request>' || 
               '<request_id>' || b.id || '</request_id>' || 
               '<check_item_id>' || b.诊疗项目id || '</check_item_id>' || 
               '<check_item_title>' || b.医嘱内容 || '</check_item_title>' || 
               '<execute_dept_id>' || nvl(c.执行部门id,0) || '</execute_dept_id>' || 
               '<send_serial>' || c.发送号 || '</send_serial>' || 
               '<bill_no>' || c.NO || '</bill_no>' || 
               '<bill_kind>' || c.记录性质 || '</bill_kind>' || 
               '<create_doctor>' || b.开嘱医生 || '</create_doctor>' || 
               '<create_time>' || b.开嘱时间 || '</create_time>' || 
               '<create_dept_id>' || nvl(b.开嘱科室id,0) || '</create_dept_id>' || 
           '</check_request>' into v_return 
 
        From 病人信息 a, 病人医嘱记录 b, 病人医嘱发送 c, 病人挂号记录 d 
        Where a.病人id=b.病人id And b.id=c.医嘱id And b.挂号单=d.no(+) And b.相关ID Is Null 
              And a.病人id=b.病人id And b.id=医嘱ID_In; 
 
      Return v_return; 
  End Get_ZLHIS_CIS_017; 
  
  --ZLHIS_CIS_015(医技拒绝执行) 
  Function Get_ZLHIS_CIS_015 Return varchar2 As 
    v_return varchar2(4000); 
  Begin 
       Select 
           '<patient_info>' || 
               '<patient_id>' || a.病人id || '</patient_id>' || 
               '<patient_name>' || v_姓名 || '</patient_name>' || 
               '<in_number>' || nvl(a.住院号,0) || '</in_number>' || 
               '<out_number>' || nvl(a.门诊号,0) || '</out_number>' || 
           '</patient_info>' || 
           '<patient_clinic>' || 
               '<patient_source>' || b.病人来源 || '</patient_source>' || 
               '<clinic_id>' || Case b.病人来源 When 1 Then nvl(e.id,0) When 2 Then nvl(b.主页id, 0) Else 0 End || '</clinic_id>' || 
               '<clinic_dept_id>' || nvl(a.当前科室id,0) || '</clinic_dept_id>' || 
           '</patient_clinic>' || 
           '<refuse_order>' || 
               '<order_id>' || b.id || '</order_id>' || 
               '<order_expiry>1</order_expiry>' || 
               '<order_kind>' || b.诊疗类别 || '</order_kind>' || 
               '<operation_kind>' || d.操作类型 || '</operation_kind>' || 
               '<order_item_id>' || b.诊疗项目ID || '</order_item_id>' || 
               '<order_item_title>' || d.名称 || '</order_item_title>' || 
           '</refuse_order>' Into v_return 
 
       From 病人信息 a, 病人医嘱记录 b, 病人医嘱发送 c, 诊疗项目目录 d, 病人挂号记录 e 
       Where a.病人id=b.病人id And b.id=c.医嘱id And b.诊疗项目id=d.id And b.挂号单=e.no(+) And b.相关ID Is Null 
              And a.病人id=b.病人id And b.id=医嘱ID_In; 
              
       Return v_return;     
  End Get_ZLHIS_CIS_015;   
   
 
  --ZLHIS_CIS_024(患者医嘱撤销) 
  Function Get_ZLHIS_CIS_024 Return varchar2 As 
    v_return varchar2(4000); 
  Begin 
       Select 
           '<patient_info>' || 
               '<patient_id>' || a.病人id || '</patient_id>' || 
               '<patient_name>' || v_姓名 || '</patient_name>' || 
               '<in_number>' || nvl(a.住院号,0) || '</in_number>' || 
               '<out_number>' || nvl(a.门诊号,0) || '</out_number>' || 
           '</patient_info>' || 
           '<patient_clinic>' || 
               '<patient_source>' || b.病人来源 || '</patient_source>' || 
               '<clinic_id>' || Case b.病人来源 When 1 Then nvl(e.id,0) When 2 Then nvl(b.主页id, 0) Else 0 End || '</clinic_id>' || 
               '<clinic_dept_id>' || nvl(a.当前科室id,0) || '</clinic_dept_id>' || 
           '</patient_clinic>' || 
           '<cancel_order>' || 
               '<order_id>' || b.id || '</order_id>' || 
               '<order_kind>' || b.诊疗类别 || '</order_kind>' || 
               '<operation_kind>' || d.操作类型 || '</operation_kind>' || 
           '</cancel_order>' Into v_return 
 
       From 病人信息 a, 病人医嘱记录 b, 病人医嘱发送 c, 诊疗项目目录 d, 病人挂号记录 e 
       Where a.病人id=b.病人id And b.id=c.医嘱id And b.诊疗项目id=d.id And b.挂号单=e.no(+) And b.相关ID Is Null 
              And a.病人id=b.病人id And b.id=医嘱ID_In; 
 
      Return v_return; 
  End Get_ZLHIS_CIS_024; 
 
 
  --ZLHIS_PACS_001(检查报告完成) 
  Function Get_ZLHIS_PACS_001 Return varchar2 As 
    v_return varchar2(4000); 
  Begin 
    If 消息标记_In Is Null Then
        Select 
           '<patient_info>' || 
               '<patient_id>' || a.病人id || '</patient_id>' || 
               '<patient_name>' || v_姓名 || '</patient_name>' || 
               '<in_number>' || nvl(a.住院号,0) || '</in_number>' || 
               '<out_number>' || nvl(a.门诊号,0) || '</out_number>' || 
           '</patient_info>' || 
           '<patient_clinic>' || 
               '<patient_source>' || b.病人来源 || '</patient_source>' || 
               '<clinic_id>' || Case b.病人来源 When 1 Then nvl(e.id,0) When 2 Then nvl(b.主页id, 0) Else 0 End || '</clinic_id>' || 
               '<clinic_dept_id>' || nvl(a.当前科室id,0) || '</clinic_dept_id>' || 
           '</patient_clinic>' || 
           '<advice_info>' || 
               '<order_id>' || b.id || '</order_id>' || 
               '<check_item_id>' || b.诊疗项目id || '</check_item_id>' || 
               '<check_item_title>' || b.医嘱内容 || '</check_item_title>' || 
               '<create_doctor>' || b.开嘱医生 || '</create_doctor>' || 
               '<create_dept_id>' || nvl(b.开嘱科室id, 0) || '</create_dept_id>' || 
               '<study_execute_id>' || nvl(b.执行科室id,0) || '</study_execute_id>' || 
           '</advice_info>' || 
           '<report_inf>' || 
               '<report_id>' || d.病历id || '</report_id>' || 
               '<report_doctor>' || c.完成人 || '</report_doctor>' || 
               '<result_positive>' || c.结果阳性 || '</result_positive>' || 
           '</report_inf>'  Into v_return 
 
        From 病人信息 a, 病人医嘱记录 b, 病人医嘱发送 c, 病人医嘱报告 d, 病人挂号记录 e 
        Where a.病人id=b.病人id And b.id=c.医嘱id And b.id=d.医嘱id And b.挂号单=e.no(+) And b.相关ID Is Null 
              And d.检查报告id Is Null And a.病人id=b.病人id And b.id=医嘱ID_In; 
    Else
        Select 
           '<patient_info>' || 
               '<patient_id>' || a.病人id || '</patient_id>' || 
               '<patient_name>' || v_姓名 || '</patient_name>' || 
               '<in_number>' || nvl(a.住院号,0) || '</in_number>' || 
               '<out_number>' || nvl(a.门诊号,0) || '</out_number>' || 
           '</patient_info>' || 
           '<patient_clinic>' || 
               '<patient_source>' || b.病人来源 || '</patient_source>' || 
               '<clinic_id>' || Case b.病人来源 When 1 Then nvl(e.id,0) When 2 Then nvl(b.主页id, 0) Else 0 End || '</clinic_id>' || 
               '<clinic_dept_id>' || nvl(a.当前科室id,0) || '</clinic_dept_id>' || 
           '</patient_clinic>' || 
           '<advice_info>' || 
               '<order_id>' || b.id || '</order_id>' || 
               '<check_item_id>' || b.诊疗项目id || '</check_item_id>' || 
               '<check_item_title>' || b.医嘱内容 || '</check_item_title>' || 
               '<create_doctor>' || b.开嘱医生 || '</create_doctor>' || 
               '<create_dept_id>' || nvl(b.开嘱科室id, 0) || '</create_dept_id>' || 
               '<study_execute_id>' || nvl(b.执行科室id,0) || '</study_execute_id>' || 
           '</advice_info>' || 
           '<report_inf>' || 
               '<report_id>' || d.检查报告id || '</report_id>' || 
               '<report_doctor>' || c.完成人 || '</report_doctor>' || 
               '<result_positive>' || c.结果阳性 || '</result_positive>' || 
           '</report_inf>'  Into v_return 
 
        From 病人信息 a, 病人医嘱记录 b, 病人医嘱发送 c, 病人医嘱报告 d, 病人挂号记录 e 
        Where a.病人id=b.病人id And b.id=c.医嘱id And b.id=d.医嘱id And b.挂号单=e.no(+) And b.相关ID Is Null 
              And d.病历id Is Null And a.病人id=b.病人id And b.id=医嘱ID_In And d.检查报告id=消息标记_In; 
    End If;
    
    Return v_return; 
  End Get_ZLHIS_PACS_001; 
 
  --ZLHIS_PACS_002(患者状态同步) 
  Function Get_ZLHIS_PACS_002 Return varchar2 As 
    v_return varchar2(4000); 
  Begin 
        Select 
           '<patient_info>' || 
               '<patient_id>' || a.病人id || '</patient_id>' || 
               '<patient_name>' || v_姓名 || '</patient_name>' || 
               '<identity_card>' || a.身份证号 || '</identity_card>' || 
               '<in_number>' || nvl(a.住院号,0) || '</in_number>' || 
               '<out_number>' || nvl(a.门诊号,0) || '</out_number>' || 
           '</patient_info>' || 
           '<patient_clinic>' || 
               '<patient_source>' || b.病人来源 || '</patient_source>' || 
               '<clinic_id>' || Case b.病人来源 When 1 Then nvl(d.id,0) When 2 Then nvl(b.主页id, 0) Else 0 End || '</clinic_id>' || 
               '<clinic_dept_id>' || nvl(a.当前科室id,0) || '</clinic_dept_id>' || 
           '</patient_clinic>' || 
           '<study_state>' || 
               '<study_cur_state>' || nvl(c.执行过程,0) || '</study_cur_state>' || 
               '<study_cur_time>' || sysdate || '</study_cur_time>' || 
               '<order_id>' || b.id || '</order_id>' || 
               '<study_item_id>' || b.诊疗项目id || '</study_item_id>' || 
               '<study_item_title>' || b.医嘱内容 || '</study_item_title>' || 
               '<study_oper_person>' || 当前用户_In || '</study_oper_person>' || 
               '<study_execute_id>' || nvl(b.执行科室id,0) || '</study_execute_id>' || 
           '</study_state>' Into v_return 
 
        From 病人信息 a, 病人医嘱记录 b, 病人医嘱发送 c, 病人挂号记录 d 
        Where a.病人id=b.病人id And b.id=c.医嘱id And b.挂号单=d.no(+) And b.相关ID Is Null 
              And a.病人id=b.病人id And b.id=医嘱ID_In; 
 
      Return v_return; 
  End Get_ZLHIS_PACS_002; 
 
 
  --ZLHIS_PACS_003(检查状态回退) 
  Function Get_ZLHIS_PACS_003 Return varchar2 As 
    v_return varchar2(4000); 
  Begin 
        Select 
           '<patient_info>' || 
               '<patient_id>' || a.病人id || '</patient_id>' || 
               '<patient_name>' || v_姓名 || '</patient_name>' || 
               '<identity_card>' || a.身份证号 || '</identity_card>' || 
               '<in_number>' || nvl(a.住院号,0) || '</in_number>' || 
               '<out_number>' || nvl(a.门诊号,0) || '</out_number>' || 
           '</patient_info>' || 
           '<patient_clinic>' || 
               '<patient_source>' || b.病人来源 || '</patient_source>' || 
               '<clinic_id>' || Case b.病人来源 When 1 Then nvl(d.id,0) When 2 Then nvl(b.主页id, 0) Else 0 End || '</clinic_id>' || 
               '<clinic_dept_id>' || nvl(a.当前科室id, 0) || '</clinic_dept_id>' || 
           '</patient_clinic>' || 
           '<study_state>' || 
               '<study_cur_state>' || nvl(c.执行过程,0) || '</study_cur_state>' || 
               '<study_cur_time>' || Sysdate || '</study_cur_time>' || 
               '<study_order_id>' || b.id || '</study_order_id>' || 
               '<study_item_id>' || b.诊疗项目id || '</study_item_id>' || 
               '<study_item_title>' || b.医嘱内容 || '</study_item_title>' || 
               '<study_oper_person>' || 当前用户_In || '</study_oper_person>' || 
               '<study_execute_id>' || nvl(b.执行科室id,0) || '</study_execute_id>' || 
           '</study_state>' Into v_return 
 
        From 病人信息 a, 病人医嘱记录 b, 病人医嘱发送 c, 病人挂号记录 d 
        Where a.病人id=b.病人id And b.id=c.医嘱id And b.挂号单=d.no(+) And b.相关ID Is Null 
              And a.病人id=b.病人id And b.id=医嘱ID_In; 
 
      Return v_return; 
  End Get_ZLHIS_PACS_003; 
 
 
  --ZLHIS_PACS_004(检查报告撤销) 
  Function Get_ZLHIS_PACS_004 Return varchar2 As 
    v_return varchar2(4000); 
  Begin 
    If 消息标记_In Is Null Then
        Select 
           '<patient_info>' || 
               '<patient_id>' || a.病人id || '</patient_id>' || 
               '<patient_name>' || v_姓名 || '</patient_name>' || 
               '<in_number>' || nvl(a.住院号,0) || '</in_number>' || 
               '<out_number>' || nvl(a.门诊号,0) || '</out_number>' || 
           '</patient_info>' || 
           '<patient_clinic>' || 
               '<patient_source>' || b.病人来源 || '</patient_source>' || 
               '<clinic_id>' || Case b.病人来源 When 1 Then nvl(e.id,0) When 2 Then nvl(b.主页id, 0) Else 0 End || '</clinic_id>' || 
               '<clinic_dept_id>' || nvl(a.当前科室id,0) || '</clinic_dept_id>' || 
           '</patient_clinic>' || 
           '<advice_info>' || 
               '<order_id>' || b.id || '</order_id>' || 
               '<cur_state>' || nvl(c.执行过程,0) || '</cur_state>' || 
               '<check_item_id>' || b.诊疗项目id || '</check_item_id>' || 
               '<check_item_title>' || b.医嘱内容 || '</check_item_title>' || 
               '<create_doctor>' || b.开嘱医生 || '</create_doctor>' || 
               '<create_dept_id>' || nvl(b.开嘱科室id,0) || '</create_dept_id>' || 
               '<study_execute_id>' || nvl(b.执行科室id,0) || '</study_execute_id>' || 
           '</advice_info>' || 
           '<report_info>' || 
               '<report_id>' || d.病历id || '</report_id>' || 
           '</report_info>'  Into v_return 
 
        From 病人信息 a, 病人医嘱记录 b, 病人医嘱发送 c, 病人医嘱报告 d, 病人挂号记录 e 
        Where a.病人id=b.病人id And b.id=c.医嘱id And b.id=d.医嘱id And b.挂号单=e.no(+) And b.相关ID Is Null 
              And d.检查报告id Is Null And a.病人id=b.病人id And b.id=医嘱ID_In; 
    Else
        Select 
           '<patient_info>' || 
               '<patient_id>' || a.病人id || '</patient_id>' || 
               '<patient_name>' || v_姓名 || '</patient_name>' || 
               '<in_number>' || nvl(a.住院号,0) || '</in_number>' || 
               '<out_number>' || nvl(a.门诊号,0) || '</out_number>' || 
           '</patient_info>' || 
           '<patient_clinic>' || 
               '<patient_source>' || b.病人来源 || '</patient_source>' || 
               '<clinic_id>' || Case b.病人来源 When 1 Then nvl(e.id,0) When 2 Then nvl(b.主页id, 0) Else 0 End || '</clinic_id>' || 
               '<clinic_dept_id>' || nvl(a.当前科室id,0) || '</clinic_dept_id>' || 
           '</patient_clinic>' || 
           '<advice_info>' || 
               '<order_id>' || b.id || '</order_id>' || 
               '<cur_state>' || nvl(c.执行过程,0) || '</cur_state>' || 
               '<check_item_id>' || b.诊疗项目id || '</check_item_id>' || 
               '<check_item_title>' || b.医嘱内容 || '</check_item_title>' || 
               '<create_doctor>' || b.开嘱医生 || '</create_doctor>' || 
               '<create_dept_id>' || nvl(b.开嘱科室id,0) || '</create_dept_id>' || 
               '<study_execute_id>' || nvl(b.执行科室id,0) || '</study_execute_id>' || 
           '</advice_info>' || 
           '<report_info>' || 
               '<report_id>' || d.检查报告id || '</report_id>' || 
           '</report_info>'  Into v_return 
 
        From 病人信息 a, 病人医嘱记录 b, 病人医嘱发送 c, 病人医嘱报告 d, 病人挂号记录 e 
        Where a.病人id=b.病人id And b.id=c.医嘱id And b.id=d.医嘱id And b.挂号单=e.no(+) And b.相关ID Is Null 
              And d.病历id Is Null And a.病人id=b.病人id And b.id=医嘱ID_In And d.检查报告id=消息标记_In; 
    End If;
    
    Return v_return; 
  End Get_ZLHIS_PACS_004; 
  
  --ZLHIS_PACS_005(检查危急值通知) 
  Function Get_ZLHIS_PACS_005 Return varchar2 As 
    v_return varchar2(4000); 
  Begin 
        With t As (Select id, 姓名 From 人员表) 
        Select 
           '<patient_info>' || 
               '<patient_id>' || a.病人id || '</patient_id>' || 
               '<patient_name>' || v_姓名 || '</patient_name>' || 
               '<in_number>' || nvl(a.住院号,0) || '</in_number>' || 
               '<out_number>' || nvl(a.门诊号,0) || '</out_number>' || 
           '</patient_info>' || 
           '<patient_clinic>' || 
               '<patient_source>' || b.病人来源 || '</patient_source>' || 
               '<clinic_id>' || Case b.病人来源 When 1 Then nvl(i.id,0) When 2 Then nvl(b.主页id, 0) Else 0 End || '</clinic_id>' || 
               '<clinic_area_id>' || nvl(a.当前病区id,0) || '</clinic_area_id>' || 
               '<clinic_dept_id>' || nvl(b.开嘱科室id,0) || '</clinic_dept_id>' || 
               '<in_doctor_id>' || nvl(e.id,0) || '</in_doctor_id>' || 
               '<director_doctor_id>' || nvl(g.id,0) || '</director_doctor_id>' || 
               '<treat_doctor_id>' || nvl(h.id,0) || '</treat_doctor_id>' || 
               '<duty_nurse_id>' || nvl(f.id,0) || '</duty_nurse_id>' || 
           '</patient_clinic>' || 
           '<check_order>' || 
               '<order_id>' || b.id || '</order_id>' || 
               '<check_item_id>' || b.诊疗项目id || '</check_item_id>' || 
               '<check_item_title>' || b.医嘱内容 || '</check_item_title>' || 
               '<study_execute_id>' || nvl(b.执行科室id,0) || '</study_execute_id>' || 
           '</check_order>'  Into v_return 
 
        From 病人信息 a, 病人医嘱记录 b, 病案主页 c, 病人挂号记录 i, 
             (Select a.病人ID,a.主页ID,主任医师,主治医师 From 病人变动记录 a,病人医嘱记录 b 
              Where a.病人id=b.病人id And a.开始原因 Is Not Null And a.终止时间 Is Null And b.id=0) d, 
              t e, t f, t g, t h 
        Where b.病人id = a.病人id And b.挂号单=i.no(+) 
              And b.病人id=c.病人id(+) And b.主页id=c.主页id(+) 
              And c.住院医师=e.姓名(+) And c.责任护士=f.姓名(+) 
              And c.病人id =d.病人id(+) And c.主页id=d.主页id(+) 
              And d.主任医师=g.姓名(+) And d.主治医师=h.姓名(+) 
              And b.相关id Is Null And a.病人id=b.病人id And b.id=医嘱ID_In; 
 
      Return v_return; 
  End Get_ZLHIS_PACS_005;
  
  --ZLHIS_PACS_006(检查预约通知) 
  Function Get_ZLHIS_PACS_006 Return varchar2 As 
    v_return varchar2(4000); 
  Begin 
        Select 
           '<patient_info>' || 
               '<patient_id>' || a.病人id || '</patient_id>' || 
               '<patient_name>' || v_姓名 || '</patient_name>' || 
               '<in_number>' || nvl(a.住院号,0) || '</in_number>' || 
               '<out_number>' || nvl(a.门诊号,0) || '</out_number>' || 
           '</patient_info>' || 
           '<patient_clinic>' || 
               '<patient_source>' || b.病人来源 || '</patient_source>' || 
               '<clinic_id>' || Case b.病人来源 When 1 Then nvl(i.id,0) When 2 Then nvl(b.主页id, 0) Else 0 End || '</clinic_id>' || 
               '<clinic_area_id>' || nvl(a.当前病区id,0) || '</clinic_area_id>' || 
               '<clinic_dept_id>' || nvl(b.开嘱科室id,0) || '</clinic_dept_id>' || 
           '</patient_clinic>' || 
           '<check_order>' || 
               '<order_id>' || b.id || '</order_id>' || 
               '<check_item_id>' || b.诊疗项目id || '</check_item_id>' || 
               '<check_item_title>' || b.医嘱内容 || '</check_item_title>' || 
               '<study_execute_id>' || nvl(b.执行科室id,0) || '</study_execute_id>' ||
               '<schedult_id>' || k.预约id || '</schedult_id>' ||
               '<machine_id>' || nvl(k.检查设备id,0) || '</machine_id>' ||
               '<machine_name>' || nvl(k.检查设备名称,'') || '</machine_name>' ||
               '<schedule_date>' || To_Char(k.预约日期, 'YYYY-MM-DD HH24:MI:SS') || '</schedule_date>' ||
               '<schedule_begin_time>' || To_Char(k.预约开始时间, 'YYYY-MM-DD HH24:MI:SS') || '</schedule_begin_time>' ||
               '<schedule_end_time>' || To_Char(k.预约结束时间, 'YYYY-MM-DD HH24:MI:SS')  || '</schedule_end_time>' ||
               '<schedule_sec_begin>' || To_Char(k.预约开始时间段, 'YYYY-MM-DD HH24:MI:SS')  || '</schedule_sec_begin>' ||
               '<schedule_sec_end>' || To_Char(k.预约结束时间段, 'YYYY-MM-DD HH24:MI:SS')  || '</schedule_sec_end>' ||
               '<schedule_call_no>' || nvl(k.序号,0) || '</schedule_call_no>' || 
           '</check_order>'  Into v_return 
 
        From 病人信息 a, 病人医嘱记录 b, 病案主页 c, 病人挂号记录 i, Ris检查预约 k 
        Where b.病人id = a.病人id And b.挂号单=i.no(+) 
              And b.病人id=c.病人id(+) And b.主页id=c.主页id(+) 
              And b.id =k.医嘱id 
              And b.相关id Is Null And a.病人id=b.病人id And b.id=医嘱ID_In; 
 
      Return v_return; 
  End Get_ZLHIS_PACS_006; 
 
Begin 
  v_Context := ''; 
  
  --首先判断是否是婴儿，若是则v_姓名 提取婴儿姓名，否则v_姓名 为病人医嘱记录的姓名。
  Select Max(婴儿), Max(主页id) Into n_婴儿序号, n_主页id From 病人医嘱记录 Where ID = 医嘱id_In;
  If n_婴儿序号 > 0 And n_主页id > 0 Then
    Select Nvl(b.婴儿姓名, a.姓名 || '之子' || Trim(To_Char(b.序号, '9')))
    Into v_姓名
    From 病人医嘱记录 A, 病人新生儿记录 B
    Where a.病人id = b.病人id And b.主页id = n_主页id And b.序号 = n_婴儿序号 And a.Id = 医嘱id_In;
  Else
    Select 姓名 Into v_姓名 From 病人医嘱记录
    Where Id = 医嘱id_In;
  End If;
 
  Case 消息类型_In 
    When 'ZLHIS_CIS_005' Then 
      --ZLHIS_CIS_005(医技执行安排完成) 
      v_Context := Get_ZLHIS_CIS_005; 
 
    When 'ZLHIS_CIS_015' Then 
        --ZLHIS_CIS_015(医技拒绝执行) 
        v_Context := Get_ZLHIS_CIS_015; 
        
    When 'ZLHIS_CIS_017' Then 
        --ZLHIS_CIS_017(患者检查申请) 
        v_Context := Get_ZLHIS_CIS_017; 
 
    When 'ZLHIS_CIS_024' Then 
        --ZLHIS_PACS_024(患者医嘱撤销) 
        v_Context := Get_ZLHIS_CIS_024; 
 
    When 'ZLHIS_PACS_001' Then 
        --ZLHIS_PACS_001(检查报告完成) 
        v_Context := Get_ZLHIS_PACS_001; 
 
    When 'ZLHIS_PACS_002' Then 
        --ZLHIS_PACS_002(检查状态同步) 
        v_Context := Get_ZLHIS_PACS_002; 
 
    When 'ZLHIS_PACS_003' Then 
        --ZLHIS_PACS_003(检查状态回退) 
        v_Context := Get_ZLHIS_PACS_003; 
 
    When 'ZLHIS_PACS_004' Then 
        --ZLHIS_PACS_004(检查报告撤销) 
        v_Context := Get_ZLHIS_PACS_004; 
 
    When 'ZLHIS_PACS_005' Then 
        --ZLHIS_PACS_005(检查危急值通知) 
        v_Context := Get_ZLHIS_PACS_005; 
    
    When 'ZLHIS_PACS_006' Then 
        --ZLHIS_PACS_006(检查预约通知) 
        v_Context := Get_ZLHIS_PACS_006; 
    Else 
      Return ''; 
  End Case; 
 
  Return v_Context; 
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End zl_影像消息_XML内容获取;
/

--117999:李南春,2017-12-13,序号锁号状态检查
CREATE OR REPLACE Function Zl_Fun_Get临床出诊预约状态
(
  记录id_In   In 临床出诊记录.Id%Type,
  预约时间_In In 病人挂号记录.预约时间%Type,
  序号_In     临床出诊序号控制.序号%Type := Null,
  预约方式_In 预约方式.名称%Type := Null,
  合作单位_In 挂号合作单位.名称%Type := Null,
  收费预约_In Number := 0,
  操作员姓名_In 挂号序号状态.操作员姓名%Type := Null,
  机器名_In   挂号序号状态.机器名%Type := Null
) Return Varchar2 As
  --功能：判断出诊记录在预约时间是否可预约
  --入参：
  --返回：
  --     格式：预约状态|提示信息，如："1|预约时间不在当前上班时段时间范围内。"
  --     预约状态：
  --         0-可预约
  --         ======================================================
  --         1-不可预约，预约时间不在当前上班时段时间范围内
  --         2-不可预约，当前上班时段禁止预约
  --         3-不可预约，当前上班时段在预约时间时已停诊
  --         4-不可预约，当前上班时段剩余可预约数为零
  --         ======================================================
  --         5-不可预约，当前预约时间在法定节假日时间范围内，不上班
  --         6-不可预约，当前预约时间在法定节假日时间范围内，禁止预约
  --         7-不可预约，当前预约时间在法定节假日不允许预约的时间范围内
  --         8-不可预约，当前预约时间在法定节假日不允许挂号的时间范围内
  --         9-不可预约，当前预约时间在法定节假日时间范围内，已停诊
  --         ======================================================
  --         10-不可预约，当前预约方式禁止预约
  --         11-不可预约，当前预约方式可预约数不足
  --         ======================================================
  --         12-不可预约，当前合作单位禁止预约
  --         13-不可预约，当前合作单位可预约数不足
  --         ======================================================
  --         14-不可预约，当前序号禁止预约
  --         15-不可预约，当前序号已经被使用
  --         16-不可预约，当前序号不可用
  --
  n_号源id         临床出诊记录.号源id%Type;
  n_是否分时段     临床出诊记录.是否分时段%Type;
  n_预约控制       临床出诊记录.预约控制%Type;
  d_停诊开始时间   临床出诊记录.停诊开始时间%Type;
  d_停诊终止时间   临床出诊记录.停诊终止时间%Type;
  v_停诊原因       临床出诊记录.停诊原因%Type;
  n_限约数         临床出诊记录.限约数%Type;
  n_已约数         临床出诊记录.已约数%Type;
  n_独占           临床出诊记录.是否独占%Type;
  n_控制方式       临床出诊挂号控制记录.控制方式%Type;
  n_数量           临床出诊挂号控制记录.数量%Type;
  n_数量限制       临床出诊挂号控制记录.数量%Type;
  n_序号控制       临床出诊记录.是否序号控制%Type;
  v_预约方式       临床出诊挂号控制记录.名称%Type;
  n_类型           临床出诊挂号控制记录.类型%Type;
  n_预约方式限约数 临床出诊记录.限约数%Type;
  n_预约方式已约数 临床出诊记录.已约数%Type;
  n_挂号状态       临床出诊序号控制.挂号状态%Type;
  n_是否预约       临床出诊序号控制.是否预约%Type;

  n_假日控制状态 临床出诊号源.假日控制状态%Type;

  v_允许预约 法定假日表.允许预约日期%Type;
  v_允许挂号 法定假日表.允许挂号日期%Type;
  n_Count    Number(2);
  n_已使用   Number(5);
  v_锁号机器名 挂号序号状态.机器名%Type;
  v_锁号操作员 挂号序号状态.操作员姓名%Type;
Begin
  Begin
    Select a.号源id, a.是否分时段, a.预约控制, a.停诊开始时间, a.停诊终止时间, a.停诊原因, Nvl(限约数, 限号数), 已约数, 是否独占, 是否序号控制
    Into n_号源id, n_是否分时段, n_预约控制, d_停诊开始时间, d_停诊终止时间, v_停诊原因, n_限约数, n_已约数, n_独占, n_序号控制
    From 临床出诊记录 A
    Where a.Id = 记录id_In And 预约时间_In Between 开始时间 And 终止时间;
  Exception
    When Others Then
      Return '1|预约时间不在当前上班时段时间范围内。';
  End;

  --预约方式检查
  If 预约方式_In Is Not Null Then
    Begin
      Select 控制方式
      Into n_控制方式
      From 临床出诊挂号控制记录
      Where 类型 = 2 And 性质 = 1 And 记录id = 记录id_In And 名称 = 预约方式_In And Rownum < 2;
    Exception
      When Others Then
        Begin
          Select 控制方式
          Into n_控制方式
          From 临床出诊挂号控制记录
          Where 类型 = 2 And 性质 = 1 And 记录id = 记录id_In And Rownum < 2;
        Exception
          When Others Then
            Null;
        End;
    End;
    If n_控制方式 = 0 Then
      Return '10|当前预约方式禁止预约。';
    End If;
    If n_控制方式 = 1 Or n_控制方式 = 2 Then
      Select Nvl(限约数, 限号数) Into n_预约方式限约数 From 临床出诊记录 Where ID = 记录id_In;
      If n_独占 = 0 Then
        Begin
          Select 数量
          Into n_数量
          From 临床出诊挂号控制记录
          Where 类型 = 2 And 性质 = 1 And 名称 = 预约方式_In And 记录id = 记录id_In;
        Exception
          When Others Then
            n_数量 := Null;
        End;
        If n_数量 Is Not Null Then
          If n_控制方式 = 1 Then
            n_预约方式限约数 := Round(n_预约方式限约数 * n_数量 / 100);
          Else
            n_预约方式限约数 := n_数量;
          End If;
          Select Count(1)
          Into n_预约方式已约数
          From 病人挂号记录
          Where 出诊记录id = 记录id_In And 记录状态 = 1 And 预约方式 = 预约方式_In;
          If n_预约方式已约数 >= n_预约方式限约数 Then
            Return '11|当前预约方式可预约数不足。';
          End If;
        End If;
      Else
        --限数量独占
        Begin
          Select 数量
          Into n_数量
          From 临床出诊挂号控制记录
          Where 类型 = 2 And 性质 = 1 And 名称 = 预约方式_In And 记录id = 记录id_In;
        Exception
          When Others Then
            n_数量 := Null;
        End;
        If n_数量 Is Not Null Then
          If n_控制方式 = 1 Then
            n_预约方式限约数 := Round(n_预约方式限约数 * n_数量 / 100);
          Else
            n_预约方式限约数 := n_数量;
          End If;
          Select Count(1)
          Into n_预约方式已约数
          From 病人挂号记录
          Where 出诊记录id = 记录id_In And 记录状态 = 1 And 预约方式 = 预约方式_In;
          If n_预约方式已约数 >= n_预约方式限约数 Then
            Return '11|当前预约方式可预约数不足。';
          End If;
        Else
          If 收费预约_In = 0 Then
            For r_限制 In (Select 数量, 名称, 类型 From 临床出诊挂号控制记录 Where 性质 = 1 And 记录id = 记录id_In) Loop
              If r_限制.类型 = 1 Then
                Select Count(1)
                Into n_已使用
                From 病人挂号记录
                Where 出诊记录id = 记录id_In And 合作单位 = r_限制.名称 And 记录状态 = 1;
              Else
                Select Count(1)
                Into n_已使用
                From 病人挂号记录
                Where 出诊记录id = 记录id_In And 预约方式 = r_限制.名称 And 记录状态 = 1;
              End If;
              If n_控制方式 = 1 Then
                n_数量限制 := Nvl(n_数量限制, 0) + Round(r_限制.数量 * n_预约方式限约数 / 100) - Nvl(n_已使用, 0);
              Else
                n_数量限制 := Nvl(n_数量限制, 0) + r_限制.数量 - Nvl(n_已使用, 0);
              End If;
            End Loop;
            Select Count(1) Into n_已使用 From 病人挂号记录 Where 出诊记录id = 记录id_In And 记录状态 = 1;
            If n_预约方式限约数 - n_数量限制 - n_已使用 > 0 Then
              Null;
            Else
              Return '11|当前预约方式可预约数不足。';
            End If;
          Else
            For r_限制 In (Select 数量, 名称, 类型
                         From 临床出诊挂号控制记录
                         Where 性质 = 1 And 类型 = 2 And 记录id = 记录id_In) Loop
              Select Count(1)
              Into n_已使用
              From 病人挂号记录
              Where 出诊记录id = 记录id_In And 预约方式 = r_限制.名称 And 记录状态 = 1;
              If n_控制方式 = 1 Then
                n_数量限制 := Nvl(n_数量限制, 0) + Round(r_限制.数量 * n_预约方式限约数 / 100) - Nvl(n_已使用, 0);
              Else
                n_数量限制 := Nvl(n_数量限制, 0) + r_限制.数量 - Nvl(n_已使用, 0);
              End If;
            End Loop;
            Select Count(1) Into n_已使用 From 病人挂号记录 Where 出诊记录id = 记录id_In And 记录状态 = 1;
            If n_预约方式限约数 - n_数量限制 - n_已使用 > 0 Then
              Null;
            Else
              Return '11|当前预约方式可预约数不足。';
            End If;
          End If;
        End If;
      End If;
    End If;
    If n_控制方式 = 3 Then
      If n_序号控制 = 1 Then
        If 收费预约_In = 0 Then
          Begin
            Select 数量, 名称, 类型
            Into n_预约方式限约数, v_预约方式, n_类型
            From 临床出诊挂号控制记录
            Where 性质 = 1 And 记录id = 记录id_In And 序号 = 序号_In;
          Exception
            When Others Then
              n_预约方式限约数 := Null;
          End;
          If n_预约方式限约数 Is Not Null Then
            If v_预约方式 <> 预约方式_In Or n_类型 = 1 Then
              Return '11|当前预约方式可预约数不足。';
            End If;
            Select Nvl(Max(1), 0)
            Into n_预约方式已约数
            From 病人挂号记录
            Where 出诊记录id = 记录id_In And 号序 = 序号_In;
            If n_预约方式已约数 >= n_预约方式限约数 Then
              Return '11|当前预约方式可预约数不足。';
            End If;
          End If;
        Else
          Begin
            Select 数量, 名称, 类型
            Into n_预约方式限约数, v_预约方式, n_类型
            From 临床出诊挂号控制记录
            Where 性质 = 1 And 类型 = 2 And 记录id = 记录id_In And 序号 = 序号_In;
          Exception
            When Others Then
              n_预约方式限约数 := Null;
          End;
          If n_预约方式限约数 Is Not Null Then
            If v_预约方式 <> 预约方式_In Then
              Return '11|当前预约方式可预约数不足。';
            End If;
            Select Nvl(Max(1), 0)
            Into n_预约方式已约数
            From 病人挂号记录
            Where 出诊记录id = 记录id_In And 号序 = 序号_In;
            If n_预约方式已约数 >= n_预约方式限约数 Then
              Return '11|当前预约方式可预约数不足。';
            End If;
          End If;
        End If;
      Else
        If 收费预约_In = 0 Then
          For r_限制 In (Select 数量, 名称, 类型
                       From 临床出诊挂号控制记录
                       Where 性质 = 1 And 记录id = 记录id_In And 序号 = 序号_In) Loop
            If r_限制.名称 <> 预约方式_In Or r_限制.类型 = 1 Then
              If r_限制.类型 = 1 Then
                Select Count(1)
                Into n_已使用
                From 临床出诊序号控制 A, 病人挂号记录 B
                Where a.记录id = 记录id_In And a.预约顺序号 Is Not Null And Nvl(a.挂号状态, 0) <> 0 And a.备注 = b.号序 And
                      b.合作单位 = r_限制.名称 And b.记录状态 = 1;
              Else
                Select Count(1)
                Into n_已使用
                From 临床出诊序号控制 A, 病人挂号记录 B
                Where a.记录id = 记录id_In And a.预约顺序号 Is Not Null And Nvl(a.挂号状态, 0) <> 0 And a.备注 = b.号序 And
                      b.预约方式 = r_限制.名称 And b.记录状态 = 1;
              End If;
              n_数量限制 := Nvl(n_数量限制, 0) + r_限制.数量 - Nvl(n_已使用, 0);
            Else
              Select Count(1)
              Into n_预约方式已约数
              From 临床出诊序号控制 A, 病人挂号记录 B
              Where a.记录id = 记录id_In And a.预约顺序号 Is Not Null And Nvl(a.挂号状态, 0) <> 0 And a.备注 = b.号序 And
                    b.预约方式 = 预约方式_In And b.记录状态 = 1;
              If n_预约方式已约数 >= n_预约方式限约数 Then
                Return '11|当前预约方式可预约数不足。';
              End If;
            End If;
          End Loop;
          Select Count(1)
          Into n_已使用
          From 临床出诊序号控制 A
          Where a.记录id = 记录id_In And a.预约顺序号 Is Not Null And Nvl(a.挂号状态, 0) <> 0 And 序号 = 序号_In;
          Select Nvl(限约数, 限号数) Into n_预约方式限约数 From 临床出诊记录 Where ID = 记录id_In;
          If n_预约方式限约数 - n_数量限制 - n_已使用 > 0 Then
            Null;
          Else
            Return '11|当前预约方式可预约数不足。';
          End If;
        Else
          For r_限制 In (Select 数量, 名称, 类型
                       From 临床出诊挂号控制记录
                       Where 性质 = 1 And 类型 = 2 And 记录id = 记录id_In And 序号 = 序号_In) Loop
            If r_限制.名称 <> 预约方式_In Then
              Select Count(1)
              Into n_已使用
              From 临床出诊序号控制 A, 病人挂号记录 B
              Where a.记录id = 记录id_In And a.预约顺序号 Is Not Null And Nvl(a.挂号状态, 0) <> 0 And a.备注 = b.号序 And
                    b.预约方式 = r_限制.名称 And b.记录状态 = 1;
              n_数量限制 := Nvl(n_数量限制, 0) + r_限制.数量 - Nvl(n_已使用, 0);
            Else
              Select Count(1)
              Into n_预约方式已约数
              From 临床出诊序号控制 A, 病人挂号记录 B
              Where a.记录id = 记录id_In And a.预约顺序号 Is Not Null And Nvl(a.挂号状态, 0) <> 0 And a.备注 = b.号序 And
                    b.预约方式 = 预约方式_In And b.记录状态 = 1;
              If n_预约方式已约数 >= n_预约方式限约数 Then
                Return '11|当前预约方式可预约数不足。';
              End If;
            End If;
          End Loop;
          Select Count(1)
          Into n_已使用
          From 临床出诊序号控制 A
          Where a.记录id = 记录id_In And a.预约顺序号 Is Not Null And Nvl(a.挂号状态, 0) <> 0 And 序号 = 序号_In;
          Select Nvl(限约数, 限号数) Into n_预约方式限约数 From 临床出诊记录 Where ID = 记录id_In;
          If n_预约方式限约数 - n_数量限制 - n_已使用 > 0 Then
            Null;
          Else
            Return '11|当前预约方式可预约数不足。';
          End If;
        End If;
      End If;
    End If;
  End If;

  --合作单位检查
  If 合作单位_In Is Not Null Then
    Begin
      Select 控制方式
      Into n_控制方式
      From 临床出诊挂号控制记录
      Where 类型 = 1 And 性质 = 1 And 记录id = 记录id_In And 名称 = 合作单位_In And Rownum < 2;
    Exception
      When Others Then
        Begin
          Select 控制方式
          Into n_控制方式
          From 临床出诊挂号控制记录
          Where 类型 = 1 And 性质 = 1 And 记录id = 记录id_In And Rownum < 2;
        Exception
          When Others Then
            Null;
        End;
    End;
    If n_控制方式 = 0 Then
      Return '12|当前合作单位禁止预约。';
    End If;
    If n_控制方式 = 1 Or n_控制方式 = 2 Then
      Select Nvl(限约数, 限号数) Into n_预约方式限约数 From 临床出诊记录 Where ID = 记录id_In;
      If n_独占 = 0 Then
        Begin
          Select 数量
          Into n_数量
          From 临床出诊挂号控制记录
          Where 类型 = 1 And 性质 = 1 And 名称 = 合作单位_In And 记录id = 记录id_In;
        Exception
          When Others Then
            n_数量 := Null;
        End;
        If n_数量 Is Not Null Then
          If n_控制方式 = 1 Then
            n_预约方式限约数 := Round(n_预约方式限约数 * n_数量 / 100);
          Else
            n_预约方式限约数 := n_数量;
          End If;
          Select Count(1)
          Into n_预约方式已约数
          From 病人挂号记录
          Where 出诊记录id = 记录id_In And 记录状态 = 1 And 合作单位 = 合作单位_In;
          If n_预约方式已约数 >= n_预约方式限约数 Then
            Return '13|当前合作单位可预约数不足。';
          End If;
        End If;
      Else
        --限数量独占
        Begin
          Select 数量
          Into n_数量
          From 临床出诊挂号控制记录
          Where 类型 = 1 And 性质 = 1 And 名称 = 合作单位_In And 记录id = 记录id_In;
        Exception
          When Others Then
            n_数量 := Null;
        End;
        If n_数量 Is Not Null Then
          If n_控制方式 = 1 Then
            n_预约方式限约数 := Round(n_预约方式限约数 * n_数量 / 100);
          Else
            n_预约方式限约数 := n_数量;
          End If;
          Select Count(1)
          Into n_预约方式已约数
          From 病人挂号记录
          Where 出诊记录id = 记录id_In And 记录状态 = 1 And 合作单位 = 合作单位_In;
          If n_预约方式已约数 >= n_预约方式限约数 Then
            Return '13|当前合作单位可预约数不足。';
          End If;
        Else
          For r_限制 In (Select 数量, 名称, 类型 From 临床出诊挂号控制记录 Where 性质 = 1 And 记录id = 记录id_In) Loop
            If r_限制.类型 = 1 Then
              Select Count(1)
              Into n_已使用
              From 病人挂号记录
              Where 出诊记录id = 记录id_In And 合作单位 = r_限制.名称 And 记录状态 = 1;
            Else
              Select Count(1)
              Into n_已使用
              From 病人挂号记录
              Where 出诊记录id = 记录id_In And 预约方式 = r_限制.名称 And 记录状态 = 1;
            End If;
            If n_控制方式 = 1 Then
              n_数量限制 := Nvl(n_数量限制, 0) + Round(r_限制.数量 * n_预约方式限约数 / 100) - Nvl(n_已使用, 0);
            Else
              n_数量限制 := Nvl(n_数量限制, 0) + r_限制.数量 - Nvl(n_已使用, 0);
            End If;
          End Loop;
          Select Count(1) Into n_已使用 From 病人挂号记录 Where 出诊记录id = 记录id_In And 记录状态 = 1;
          If n_预约方式限约数 - n_数量限制 - n_已使用 > 0 Then
            Null;
          Else
            Return '13|当前合作单位可预约数不足。';
          End If;
        End If;
      End If;
    End If;
    If n_控制方式 = 3 Then
      If n_序号控制 = 1 Then
        Begin
          Select 数量, 名称, 类型
          Into n_预约方式限约数, v_预约方式, n_类型
          From 临床出诊挂号控制记录
          Where 性质 = 1 And 记录id = 记录id_In And 序号 = 序号_In;
        Exception
          When Others Then
            n_预约方式限约数 := Null;
        End;
        If n_预约方式限约数 Is Not Null Then
          If v_预约方式 <> 合作单位_In Or n_类型 = 1 Then
            Return '13|当前合作单位可预约数不足。';
          End If;
          Select Nvl(Max(1), 0)
          Into n_预约方式已约数
          From 病人挂号记录
          Where 出诊记录id = 记录id_In And 号序 = 序号_In;
          If n_预约方式已约数 >= n_预约方式限约数 Then
            Return '13|当前合作单位可预约数不足。';
          End If;
        End If;
      Else
        For r_限制 In (Select 数量, 名称, 类型
                     From 临床出诊挂号控制记录
                     Where 性质 = 1 And 记录id = 记录id_In And 序号 = 序号_In) Loop
          If r_限制.名称 <> 合作单位_In Or r_限制.类型 = 1 Then
            If r_限制.类型 = 1 Then
              Select Count(1)
              Into n_已使用
              From 临床出诊序号控制 A, 病人挂号记录 B
              Where a.记录id = 记录id_In And a.预约顺序号 Is Not Null And Nvl(a.挂号状态, 0) <> 0 And a.备注 = b.号序 And
                    b.合作单位 = r_限制.名称 And b.记录状态 = 1;
            Else
              Select Count(1)
              Into n_已使用
              From 临床出诊序号控制 A, 病人挂号记录 B
              Where a.记录id = 记录id_In And a.预约顺序号 Is Not Null And Nvl(a.挂号状态, 0) <> 0 And a.备注 = b.号序 And
                    b.预约方式 = r_限制.名称 And b.记录状态 = 1;
            End If;
            n_数量限制 := Nvl(n_数量限制, 0) + r_限制.数量 - Nvl(n_已使用, 0);
          Else
            Select Count(1)
            Into n_预约方式已约数
            From 临床出诊序号控制 A, 病人挂号记录 B
            Where a.记录id = 记录id_In And a.预约顺序号 Is Not Null And Nvl(a.挂号状态, 0) <> 0 And a.备注 = b.号序 And b.合作单位 = 合作单位_In And
                  b.记录状态 = 1;
            If n_预约方式已约数 >= n_预约方式限约数 Then
              Return '13|当前合作单位可预约数不足。';
            End If;
          End If;
        End Loop;
        Select Count(1)
        Into n_已使用
        From 临床出诊序号控制 A
        Where a.记录id = 记录id_In And a.预约顺序号 Is Not Null And Nvl(a.挂号状态, 0) <> 0 And 序号 = 序号_In;
        Select Nvl(限约数, 限号数) Into n_预约方式限约数 From 临床出诊记录 Where ID = 记录id_In;
        If n_预约方式限约数 - n_数量限制 - n_已使用 > 0 Then
          Null;
        Else
          Return '13|当前合作单位可预约数不足。';
        End If;
      End If;
    End If;
  End If;

  --0-不作预约限制;1-该号别禁止预约;2-仅禁止三方机构平台的预约
  If Nvl(n_预约控制, 0) = 1 Then
    Return '2|当前上班时段禁止预约。';
  End If;

  If d_停诊开始时间 Is Not Null And Not (Nvl(n_序号控制, 0) = 1 And Nvl(n_是否分时段, 0) = 1) Then
    If 预约时间_In >= d_停诊开始时间 And 预约时间_In <= d_停诊终止时间 Then
      Return '3|当前上班时段在预约时间时已停诊，不能预约！';
    End If;
  End If;

  If Nvl(n_限约数, 0) > 0 Then
    If Nvl(n_限约数, 0) - Nvl(n_已约数, 0) <= 0 Then
      Return '4|当前上班时段剩余可预约数为零，不能继续预约！';
    End If;
  End If;

  If Nvl(n_是否分时段, 0) = 0 Then
    --不分时段
    Begin
      Select Nvl(b.假日控制状态, 0) Into n_假日控制状态 From 临床出诊号源 B Where b.Id = n_号源id;
    Exception
      When Others Then
        n_假日控制状态 := 0;
    End;

    --1.查找包含预约时间的节假日
    Begin
      Select a.允许预约日期, a.允许挂号日期
      Into v_允许预约, v_允许挂号
      From 法定假日表 A
      Where a.性质 = 0 And 预约时间_In Between a.开始日期 And a.终止日期 + 1 - 1 / 24 / 60 / 60 And Rownum < 2;
    Exception
      When Others Then
        Return '0|正常预约。';
    End;

    --假日控制状态：0-不上班;1-上班且开放预约;2-上班但不开放预约;3-受节假日设置控制
    If Nvl(n_假日控制状态, 0) = 0 Then
      --不上班的肯定是不能预约的
      Return '5|当前预约时间在法定节假日时间范围内，不上班。';
    Elsif Nvl(n_假日控制状态, 0) = 1 Then
      Return '0|正常预约。';
    Elsif Nvl(n_假日控制状态, 0) = 2 Then
      --在节假日时间范围内，则不能预约
      Return '6|当前预约时间在法定节假日时间范围内，禁止预约。';
    Elsif Nvl(n_假日控制状态, 0) = 3 Then
      --没有"允许挂号"就一定没有"允许预约"
      If v_允许挂号 Is Not Null Then
        --2.检查是否有包含预约时间的"允许挂号"
        Select Max(1)
        Into n_Count
        From Table(f_Str2list(v_允许挂号, ';'))
        Where 预约时间_In Between To_Date(Column_Value, 'yyyy-mm-dd') And
              To_Date(Column_Value, 'yyyy-mm-dd') + 1 - 1 / 24 / 60 / 60 And Rownum < 2;

        If Nvl(n_Count, 0) <> 0 Then
          --3.检查是否有包含预约时间的"允许预约"
          Select Max(1)
          Into n_Count
          From Table(f_Str2list(v_允许预约, ';'))
          Where 预约时间_In Between To_Date(Column_Value, 'yyyy-mm-dd') And
                To_Date(Column_Value, 'yyyy-mm-dd') + 1 - 1 / 24 / 60 / 60 And Rownum < 2;

          If Nvl(n_Count, 0) = 0 Then
            --不在"允许预约"时间范围内，则不能预约
            Return '7|当前预约时间在法定节假日不允许预约的时间范围内，不能预约。';
          Else
            Return '0|正常预约。';
          End If;
        Else
          Return '8|当前预约时间在法定节假日不允许挂号的时间范围内，不能预约。';
        End If;
      Else
        --没有设置"允许挂号"/"允许预约"表示停诊，肯定不能预约
        Return '9|当前预约时间在法定节假日时间范围内，已停诊，不能预约。';
      End If;
    End If;
  Else
    --分时段
    If Nvl(序号_In, 0) <> 0 Then
      Begin
        Select Nvl(是否预约, 0), Nvl(挂号状态, 0), 操作员姓名, 工作站名称
        Into n_是否预约, n_挂号状态, v_锁号操作员, v_锁号机器名
        From 临床出诊序号控制
        Where 记录id = 记录id_In And 序号 = 序号_In;
      Exception
        When Others Then
          Return '16|当前选择的序号不可用。';
      End;
      If n_是否预约 = 0 Then
        Return '14|当前选择的序号禁止预约。';
      End If;
      If n_挂号状态 <> 0 Then
        If n_挂号状态 = 5 And (Nvl(操作员姓名_In, '-') <> Nvl(v_锁号操作员, '_') Or Nvl(机器名_In, '-') <> Nvl(v_锁号机器名, '_')) Then
           Return '15|当前选择的序号已经被'|| Nvl(v_锁号机器名,'') ||'锁定。';
        Elsif n_挂号状态 <> 5 Then
           Return '15|当前选择的序号已经被使用。';
        End if;
      End If;
    End If;
    Return '0|正常预约。';
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Fun_Get临床出诊预约状态;
/

--118177:刘兴洪,2018-01-05,负数记帐销帐后不能结帐.
Create Or Replace Procedure Zl_结帐费用记录_Insert
(
  Id_In       住院费用记录.Id%Type,
  No_In       住院费用记录.No%Type,
  记录性质_In 住院费用记录.记录性质%Type,
  记录状态_In 住院费用记录.记录状态%Type,
  执行状态_In 住院费用记录.执行状态%Type,
  序号_In     住院费用记录.序号%Type,
  结帐金额_In 住院费用记录.结帐金额%Type,
  结帐id_In   住院费用记录.结帐id%Type
) As
  n_Next_Id    住院费用记录.Id%Type;
  n_病人id     住院费用记录.病人id%Type;
  n_主页id     住院费用记录.主页id%Type;
  n_病人病区id 住院费用记录.病人病区id%Type;
  n_病人科室id 住院费用记录.病人科室id%Type;
  n_开单部门id 住院费用记录.开单部门id%Type;
  n_执行部门id 住院费用记录.执行部门id%Type;
  n_收入项目id 住院费用记录.收入项目id%Type;
  n_门诊标志   住院费用记录.门诊标志%Type;
  n_记帐费用   住院费用记录.记帐费用%Type;
  v_操作员     住院费用记录.操作员姓名%Type;
  v_操作员姓名 住院费用记录.操作员姓名%Type;
  v_操作员编码 住院费用记录.操作员编号%Type;

  n_结帐金额 住院费用记录.结帐金额%Type;
  n_实收金额 住院费用记录.实收金额%Type;
  n_返回值   病人余额.预交余额%Type;
  n_类别     Number(18);
  v_Temp     Varchar2(500);

  Err_Custom  Exception;
  Err_Special Exception;
  v_Error Varchar2(255);
  n_来源  Number;
Begin
  --人员id,人员编号,人员姓名
  v_Temp := Zl_Identity(1);
  If Not (Nvl(v_Temp, '0') = '0' Or Nvl(v_Temp, '_') = '_') Then
    v_Temp       := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_操作员编码 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_操作员姓名 := v_Temp;
  End If;

  If Id_In <> 0 Then
    Begin
      Select 2 Into n_来源 From 住院费用记录 Where ID = Id_In;
    Exception
      When Others Then
        n_来源 := 1;
    End;
  
    --第一次结帐但部分结
    If n_来源 = 1 Then
      Update 门诊费用记录 Set 结帐金额 = 结帐金额_In, 结帐id = 结帐id_In Where ID = Id_In And 结帐id Is Null;
    Else
      Update 住院费用记录 Set 结帐金额 = 结帐金额_In, 结帐id = 结帐id_In Where ID = Id_In And 结帐id Is Null;
    End If;
  
    If Sql%Rowcount = 0 Then
      If n_来源 = 1 Then
        Select Max(b.操作员姓名)
        Into v_操作员
        From 门诊费用记录 A, 病人结帐记录 B
        Where a.Id = Id_In And b.Id = a.结帐id;
      Else
        Select Max(b.操作员姓名)
        Into v_操作员
        From 住院费用记录 A, 病人结帐记录 B
        Where a.Id = Id_In And b.Id = a.结帐id;
      End If;
      If v_操作员 Is Null Then
        v_Error := '未发现结帐的费用,当前结帐操作不能继续。';
        Raise Err_Custom;
      Else
        If v_操作员姓名 = v_操作员 Then
          v_Error := '发现已经被结帐的费用,当前结帐操作不能继续。';
          Raise Err_Special;
        Else
          v_Error := '发现已经被其他人结帐的费用,当前结帐操作不能继续。';
          Raise Err_Custom;
        End If;
      End If;
    End If;
  
    n_Next_Id := Id_In;
  Else
    --结以前的余帐
    Select 病人费用记录_Id.Nextval Into n_Next_Id From Dual;
  
    If Mod(记录性质_In, 10) = 3 Or Mod(记录性质_In, 10) = 5 Then
      --自动记帐或就诊卡;肯定是住院
      n_来源 := 2;
    Else
      Begin
        Select 2
        Into n_来源
        From 住院费用记录
        Where NO = No_In And 序号 = 序号_In And 记录状态 In (1, 2, 3) And Nvl(执行状态, 0) = Nvl(执行状态_In, 0) And
              Substr(记录性质, Length(记录性质), 1) = 记录性质_In And Rownum < 2;
      Exception
        When Others Then
          n_来源 := 1;
      End;
    End If;
  
    If n_来源 = 1 Then
      Insert Into 门诊费用记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 记帐单id, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 病人科室id, 费别, 收费类别,
         收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 划价人, 开单部门id, 开单人, 发生时间, 登记时间,
         执行部门id, 执行状态, 执行人, 执行时间, 操作员姓名, 操作员编号, 结帐金额, 结帐id, 保险项目否, 保险大类id, 统筹金额, 保险编码, 费用类型, 是否急诊, 摘要, 主页id)
        Select n_Next_Id, NO, 实际票号, To_Number('1' || 记录性质_In), 记录状态, 序号, 从属父号, 价格父号, 记帐单id, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄,
               标识号, 付款方式, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, Null,
               Null, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 执行人, 执行时间, 操作员姓名, 操作员编号, 结帐金额_In, 结帐id_In, 保险项目否,
               保险大类id, 统筹金额, 保险编码, 费用类型, 是否急诊, 摘要, 主页id
        From 门诊费用记录
        Where NO = No_In And 序号 = 序号_In And (记录状态 = 记录状态_In Or 记录状态 = Decode(记录状态_In, 1, 3, 记录状态_In)) And
              Nvl(执行状态, 0) = Nvl(执行状态_In, 0) And Substr(记录性质, Length(记录性质), 1) = 记录性质_In And Rownum < 2;
    
      --检查多次结帐后结帐金额是否高于原金额
      Select Nvl(Sum(实收金额), 0), Nvl(Sum(结帐金额), 0)
      Into n_实收金额, n_结帐金额
      From 门诊费用记录
      Where NO = No_In And 序号 = 序号_In And (记录状态 = 记录状态_In Or 记录状态 = Decode(记录状态_In, 1, 3, 记录状态_In)) And
            Substr(记录性质, Length(记录性质), 1) = 记录性质_In And Nvl(执行状态, 0) = 执行状态_In;
    Else
      Insert Into 住院费用记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 记帐单id, 病人id, 主页id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 床号, 病人病区id,
         病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 划价人,
         开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 执行人, 执行时间, 操作员姓名, 操作员编号, 结帐金额, 结帐id, 保险项目否, 保险大类id, 统筹金额, 保险编码, 费用类型,
         是否急诊, 摘要, 医疗小组id)
        Select n_Next_Id, NO, 实际票号, To_Number('1' || 记录性质_In), 记录状态, 序号, 从属父号, 价格父号, 多病人单, 记帐单id, 病人id, 主页id, 医嘱序号, 门诊标志,
               姓名, 性别, 年龄, 标识号, 床号, 病人病区id, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id,
               收据费目, 标准单价, Null, Null, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 执行人, 执行时间, 操作员姓名, 操作员编号, 结帐金额_In,
               结帐id_In, 保险项目否, 保险大类id, 统筹金额, 保险编码, 费用类型, 是否急诊, 摘要, 医疗小组id
        From 住院费用记录
        Where NO = No_In And 序号 = 序号_In And (记录状态 = 记录状态_In Or 记录状态 = Decode(记录状态_In, 1, 3, 记录状态_In)) And
              Nvl(执行状态, 0) = Nvl(执行状态_In, 0) And Substr(记录性质, Length(记录性质), 1) = 记录性质_In And Rownum < 2;
    
      --检查多次结帐后结帐金额是否高于原金额
      Select Nvl(Sum(实收金额), 0), Nvl(Sum(结帐金额), 0)
      Into n_实收金额, n_结帐金额
      From 住院费用记录
      Where NO = No_In And 序号 = 序号_In And (记录状态 = 记录状态_In Or 记录状态 = Decode(记录状态_In, 1, 3, 记录状态_In)) And
            Substr(记录性质, Length(记录性质), 1) = 记录性质_In And Nvl(执行状态, 0) = 执行状态_In;
    End If;
  
    If n_结帐金额 > n_实收金额 Then
      If n_来源 = 1 Then
        Select Max(b.操作员姓名)
        Into v_操作员
        From 门诊费用记录 A, 病人结帐记录 B
        Where a.Id = Id_In And b.Id = a.结帐id;
      Else
        Select Max(b.操作员姓名)
        Into v_操作员
        From 住院费用记录 A, 病人结帐记录 B
        Where a.Id = Id_In And b.Id = a.结帐id;
      End If;
    
      If v_操作员 Is Null Then
        v_Error := '未发现结帐的费用,当前结帐操作不能继续。';
        Raise Err_Custom;
      Else
        If v_操作员姓名 = v_操作员 Then
          v_Error := '发现已经被结帐的费用,当前结帐操作不能继续。';
          Raise Err_Special;
        Else
          v_Error := '发现已经被其他人结帐的费用,当前结帐操作不能继续。';
          Raise Err_Custom;
        End If;
      End If;
    End If;
  End If;
  If n_来源 = 1 Then
    Select 病人id, Null, Null, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 门诊标志, 记帐费用
    Into n_病人id, n_主页id, n_病人病区id, n_病人科室id, n_开单部门id, n_执行部门id, n_收入项目id, n_门诊标志, n_记帐费用
    From 门诊费用记录
    Where ID = n_Next_Id;
    n_类别 := 1;
  Else
    Select 病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 门诊标志, 记帐费用
    Into n_病人id, n_主页id, n_病人病区id, n_病人科室id, n_开单部门id, n_执行部门id, n_收入项目id, n_门诊标志, n_记帐费用
    From 住院费用记录
    Where ID = n_Next_Id;
  
    If Nvl(n_门诊标志, 0) = 1 Or Nvl(n_门诊标志, 0) = 2 Then
      n_类别 := n_门诊标志;
    Elsif Nvl(n_主页id, 0) = 0 Or Nvl(n_门诊标志, 0) = 4 Then
      n_类别 := 1;
    Else
      n_类别 := 2;
    End If;
  End If;

  If Nvl(n_门诊标志, 0) <> 4 Then
    --病人余额
    Update 病人余额
    Set 费用余额 = Nvl(费用余额, 0) - 结帐金额_In
    Where 病人id = n_病人id And 性质 = 1 And 类型 = n_类别
    Returning 费用余额 Into n_返回值;
    If Sql%Rowcount = 0 Then
      Insert Into 病人余额 (病人id, 性质, 类型, 预交余额, 费用余额) Values (n_病人id, 1, n_类别, 0, -1 * 结帐金额_In);
      n_返回值 := -1 * 结帐金额_In;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 病人余额 Where Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0 And 病人id = n_病人id;
    End If;
  End If;

  --病人未结费用
  Update 病人未结费用
  Set 金额 = Nvl(金额, 0) - 结帐金额_In
  Where 病人id = n_病人id And Nvl(主页id, 0) = Nvl(n_主页id, 0) And Nvl(病人病区id, 0) = Nvl(n_病人病区id, 0) And
        Nvl(病人科室id, 0) = Nvl(n_病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(n_开单部门id, 0) And Nvl(执行部门id, 0) = Nvl(n_执行部门id, 0) And
        收入项目id + 0 = n_收入项目id And 来源途径 + 0 = n_门诊标志
  Returning 金额 Into n_返回值;
  If Sql%Rowcount = 0 Then
    Insert Into 病人未结费用
      (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
    Values
      (n_病人id, Decode(n_主页id, 0, Null, n_主页id), Decode(n_病人病区id, 0, Null, n_病人病区id), n_病人科室id, n_开单部门id, n_执行部门id,
       n_收入项目id, n_门诊标志, -1 * 结帐金额_In);
    n_返回值 := -1 * 结帐金额_In;
  End If;
  If Nvl(n_返回值, 0) = 0 Then
    Delete From 病人未结费用 Where 病人id = n_病人id And Nvl(金额, 0) = 0;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Err_Special Then
    Raise_Application_Error(-20105, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_结帐费用记录_Insert;
/

--115264:冉俊明,2017-12-11,住院病人按门诊收费，直接收费，病人无门诊号时，门诊标志和标识号填写错误
Create Or Replace Procedure Zl_病人划价收费_Insert
(
  No_In         门诊费用记录.No%Type,
  病人id_In     门诊费用记录.病人id%Type,
  病人来源_In   Number,
  付款方式_In   门诊费用记录.付款方式%Type,
  姓名_In       门诊费用记录.姓名%Type,
  性别_In       门诊费用记录.性别%Type,
  年龄_In       门诊费用记录.年龄%Type,
  病人科室id_In 门诊费用记录.病人科室id%Type,
  开单部门id_In 门诊费用记录.开单部门id%Type,
  开单人_In     门诊费用记录.开单人%Type,
  结帐id_In     门诊费用记录.结帐id%Type,
  发生时间_In   门诊费用记录.发生时间%Type,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  发药窗口_In   Varchar2 := Null,
  是否急诊_In   门诊费用记录.是否急诊%Type := 0,
  登记时间_In   门诊费用记录.登记时间%Type := Null
) As
  --功能：用于收费时收取划价单费用 
  --参数： 
  --      发药窗口_In:执行部门ID1|发药窗口1;...;执行部门IDn|发药窗口n 

  --        病人来源_IN:1-门诊;2-住院 
  --说明： 
  --        1.收取划价费用时,才计算费用相关汇总,在划价时不处理;但药品相关汇总(姓名除外)划价时已经计算。 
  --        2.收取划价费用时,目前界面及过程中未处理加收工本费,由划价时直接处理。 
  --该游标为划价原单据内容 
  Cursor c_Price Is
    Select ID
    From 门诊费用记录
    Where NO = No_In And 记录性质 = 1 And 记录状态 = 0 And 操作员姓名 Is Null
    Order By 序号;

  n_Array_Size Number := 200;
  t_费用id     t_Numlist;
  v_部门名称   部门表.名称%Type;

  v_标识号   门诊费用记录.标识号%Type;
  n_门诊标志 门诊费用记录.门诊标志%Type;
  v_付款方式 医疗付款方式.名称%Type;

  --临时变量 
  n_Count      Number;
  v_操作员姓名 门诊费用记录.操作员姓名%Type;
  n_新病人模式 Number;
  v_出库no     药品收发记录.No%Type;
  v_Date       Date;
  v_Err_Msg    Varchar2(255);
  Err_Item Exception;
  Err_Special Exception;
  n_组id 财务缴款分组.Id%Type;
Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  Select Count(ID)
  Into n_Count
  From 门诊费用记录
  Where 记录性质 = 1 And 记录状态 = 0 And NO = No_In And 操作员姓名 Is Null;
  If n_Count = 0 Then
    Select Max(操作员姓名) Into v_操作员姓名 From 门诊费用记录 Where 记录性质 = 1 And NO = No_In;
    If v_操作员姓名 Is Not Null Then
      If v_操作员姓名 = 操作员姓名_In Then
        v_Err_Msg := '不能读取划价单内容,该单据已经被收费！';
        Raise Err_Special;
      Else
        v_Err_Msg := '不能读取划价单内容,该单据已经被收费！';
        Raise Err_Item;
      End If;
    Else
      v_Err_Msg := '不能读取划价单内容,该单据已经被删除！';
      Raise Err_Item;
    End If;
  End If;
  v_Date := 登记时间_In;
  If v_Date Is Null Then
    Select Sysdate Into v_Date From Dual;
  End If;
  If Nvl(病人id_In, 0) <> 0 Then
    --根据门诊标志获取门诊号/住院号
    Select Max(门诊标志), Max(标识号) Into n_门诊标志, v_标识号 From 门诊费用记录 Where 记录性质 = 1 And NO = No_In;
    If v_标识号 Is Null Then
      Select Decode(n_门诊标志, 2, 住院号, 门诊号) Into v_标识号 From 病人信息 Where 病人id = 病人id_In;
    End If;
  End If;

  ------------------------------------------------------------------------------------------------------------------------ 
  --批量更新 
  Open c_Price;
  Loop
    Fetch c_Price Bulk Collect
      Into t_费用id Limit n_Array_Size;
    Exit When t_费用id.Count = 0;
  
    --循环处理门诊费用记录 
    Forall I In 1 .. t_费用id.Count
    --执行状态相关字段不处理,在划价时处理;因为可能未收费发药,这种已执行的划价单是允许收费操作的。 
    --为保证与预交结算记录的时间相同,重新填写登记时间,但药品部分不变动。 
      Update 门诊费用记录
      Set 记录状态 = 1, 病人id = Decode(病人id_In, 0, Null, 病人id_In), 标识号 = Nvl(标识号, v_标识号), 付款方式 = 付款方式_In, 姓名 = 姓名_In,
          年龄 = 年龄_In, 性别 = 性别_In,
          --可能保持医嘱发送的内容 
          病人科室id = Nvl(病人科室id_In, 病人科室id), 开单部门id = Nvl(开单部门id_In, 开单部门id), 开单人 = Nvl(开单人_In, 开单人), 结帐金额 = 实收金额,
          结帐id = 结帐id_In, 发生时间 = 发生时间_In, 登记时间 = v_Date, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In, 是否急诊 = 是否急诊_In,
          缴款组id = n_组id, 费用状态 = 1, 执行状态 = Decode(Nvl(执行状态, 0), -1, Null, Nvl(执行状态, 0))
      Where ID = t_费用id(I) And 记录状态 = 0;
  
    If Sql%RowCount <> t_费用id.Count Then
      Select Count(1)
      Into n_Count
      From 门诊费用记录
      Where 记录状态 = 1 And ID In (Select Column_Value From Table(t_费用id));
      If n_Count <> t_费用id.Count Then
        v_Err_Msg := '由于并发操作,该单据已经删除！';
        Raise Err_Item;
      Else
        Select Max(操作员姓名)
        Into v_操作员姓名
        From 门诊费用记录
        Where 记录状态 = 1 And ID In (Select Column_Value From Table(t_费用id));
        If v_操作员姓名 = 操作员姓名_In Then
          v_Err_Msg := '由于并发操作,该单据已经收费！';
          Raise Err_Special;
        Else
          v_Err_Msg := '由于并发操作,该单据已经收费！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  End Loop;

  Close c_Price;

  --相关汇总表的处理 
  --药品部分非费用信息的修改 
  --药品未发记录(如果已发药则修改不到),分离发药时无库房ID 
  --可能存在材料和药品库房相同，但材料无发药窗口 
  Update 未发药品记录
  Set 病人id = Decode(病人id_In, 0, Null, 病人id_In), 姓名 = 姓名_In, 对方部门id = 开单部门id_In, 已收费 = 1, 填制日期 = v_Date
  Where 单据 = 24 And NO = No_In And
        Nvl(库房id, 0) In (Select Distinct Nvl(执行部门id, 0)
                         From 门诊费用记录
                         Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 = '4');

  Update 未发药品记录
  Set 病人id = Decode(病人id_In, 0, Null, 病人id_In), 姓名 = 姓名_In, 对方部门id = 开单部门id_In, 已收费 = 1, 填制日期 = v_Date
  Where 单据 = 8 And NO = No_In And
        Nvl(库房id, 0) In (Select Distinct Nvl(执行部门id, 0)
                         From 门诊费用记录
                         Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 In ('5', '6', '7'));

  --药品收发记录(可能已经发药或取消发药,所有记录更改) 
  Update 药品收发记录
  Set 对方部门id = 开单部门id_In, 填制日期 = Decode(Sign(Nvl(审核日期, v_Date) - v_Date), -1, 填制日期, v_Date)
  Where 单据 = 24 And NO = No_In And
        费用id + 0 In (Select ID From 门诊费用记录 Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 = '4');

  ------------------------------------------------------------------------------------------- 
  --处理备货卫材 
  n_Count := Null;
  Begin
    Select Count(*), Max(a.No)
    Into n_Count, v_出库no
    From 药品收发记录 A, 门诊费用记录 B
    Where a.费用id = b.Id And b.收费类别 = '4' And b.记录性质 = 1 And b.记录状态 = 1 And b.No = No_In And
          Instr(',8,9,10,21,24,25,26,', ',' || a.单据 || ',') > 0 And Rownum <= 1;
  Exception
    When Others Then
      Null;
  End;
  If Nvl(n_Count, 0) > 0 Then
    If Nvl(病人科室id_In, 0) <> 0 Then
      Select 名称 Into v_部门名称 From 部门表 Where ID = 病人科室id_In;
    End If;
    v_Err_Msg := LPad(' ', 4);
    v_Err_Msg := Substr('病人姓名:' || 姓名_In || v_Err_Msg || '性别:' || 性别_In || v_Err_Msg || '年龄' || 年龄_In || v_Err_Msg ||
                        '门诊号:' || Nvl(v_标识号, '') || v_Err_Msg || '病人科室:' || v_部门名称, 1, 100);
  
    Update 药品收发记录
    Set 对方部门id = 开单部门id_In, 填制日期 = Decode(Sign(Nvl(审核日期, v_Date) - v_Date), -1, 填制日期, v_Date), 摘要 = v_Err_Msg
    Where 单据 = 21 And NO = v_出库no And
          费用id + 0 In (Select ID From 门诊费用记录 Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 = '4');
  End If;

  Update 药品收发记录
  Set 对方部门id = 开单部门id_In, 填制日期 = Decode(Sign(Nvl(审核日期, v_Date) - v_Date), -1, 填制日期, v_Date)
  Where 单据 = 8 And NO = No_In And
        费用id + 0 In
        (Select ID From 门诊费用记录 Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 In ('5', '6', '7'));

  If Not 发药窗口_In Is Null Then
    --更新发药窗口 
    For v_窗口 In (Select To_Number(C1) As C1, C2 From Table(f_Str2list2(发药窗口_In, ';', '|'))) Loop
    
      Update 门诊费用记录
      Set 发药窗口 = Nvl(v_窗口.C2, 发药窗口)
      Where NO = No_In And 记录性质 = 1 And 记录状态 = 1 And 执行部门id = Nvl(v_窗口.C1, 执行部门id) And 收费类别 In ('5', '6', '7');
    
      Update 药品收发记录
      Set 发药窗口 = Nvl(v_窗口.C2, 发药窗口)
      Where 单据 = 8 And NO = No_In And 库房id = Nvl(v_窗口.C1, 库房id) And
            费用id + 0 In (Select ID
                         From 门诊费用记录
                         Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 In ('5', '6', '7'));
    
      Update 未发药品记录
      Set 发药窗口 = Nvl(v_窗口.C2, 发药窗口)
      Where 单据 = 8 And NO = No_In And 库房id = Nvl(v_窗口.C1, 库房id) And
            Nvl(库房id, 0) In (Select Distinct Nvl(执行部门id, 0)
                             From 门诊费用记录
                             Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 In ('5', '6', '7'));
    
    End Loop;
  End If;

  --更新部份病人信息 
  If 病人id_In Is Not Null Then
    If 付款方式_In Is Not Null And 病人来源_In = 1 Then
      Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In;
    End If;
    --通过划价单收费时不允许改费别,因为费用不允许变 
    Update 病人信息
    Set 性别 = Decode(姓名, '新病人', Nvl(性别_In, 性别), 性别), 年龄 = Decode(姓名, '新病人', Nvl(年龄_In, 年龄), 年龄),
        姓名 = Decode(姓名, '新病人', 姓名_In, 姓名), 医疗付款方式 = Nvl(v_付款方式, 医疗付款方式)
    Where 病人id = 病人id_In;
    Select Zl_To_Number(Nvl(zl_GetSysParameter('自动产生姓名', '1111'), '0')) Into n_新病人模式 From Dual;
    If n_新病人模式 = 1 Then
    
      Update 病人挂号记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In
      Where 病人id = 病人id_In And 姓名 = '新病人';
    
      Update 门诊费用记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In, 付款方式 = 付款方式_In
      Where 病人id = 病人id_In And 姓名 = '新病人';
    End If;
  End If;

  --医嘱处理 
  --场合_In    Integer:=0, --0:门诊;1-住院 
  --性质_In    Integer:=1, --1-收费单;2-记帐单 
  --操作_In    Integer:=0, --0:删除划价单;1-收费或记帐;2-退费或销帐 
  --No_In      门诊费用记录.No%Type, 
  --医嘱ids_In Varchar2 := Null 
  Zl_医嘱发送_计费状态_Update(0, 1, 1, No_In);

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Err_Special Then
    Raise_Application_Error(-20105, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人划价收费_Insert;
/

--118154:余伟节,2017-12-12,合理用药杭州逸曜
Create Or Replace Procedure Zl_病人医嘱记录_Update
(
  Id_In           病人医嘱记录.Id%Type,
  相关id_In       病人医嘱记录.相关id%Type,
  序号_In         病人医嘱记录.序号%Type,
  医嘱状态_In     病人医嘱记录.医嘱状态%Type,
  医嘱期效_In     病人医嘱记录.医嘱期效%Type,
  诊疗项目id_In   病人医嘱记录.诊疗项目id%Type,
  收费细目id_In   病人医嘱记录.收费细目id%Type,
  天数_In         病人医嘱记录.天数%Type,
  单次用量_In     病人医嘱记录.单次用量%Type,
  总给予量_In     病人医嘱记录.总给予量%Type,
  医嘱内容_In     病人医嘱记录.医嘱内容%Type,
  医生嘱托_In     病人医嘱记录.医生嘱托%Type,
  标本部位_In     病人医嘱记录.标本部位%Type,
  执行频次_In     病人医嘱记录.执行频次%Type,
  频率次数_In     病人医嘱记录.频率次数%Type,
  频率间隔_In     病人医嘱记录.频率间隔%Type,
  间隔单位_In     病人医嘱记录.间隔单位%Type,
  执行时间方案_In 病人医嘱记录.执行时间方案%Type,
  计价特性_In     病人医嘱记录.计价特性%Type,
  执行科室id_In   病人医嘱记录.执行科室id%Type,
  执行性质_In     病人医嘱记录.执行性质%Type,
  紧急标志_In     病人医嘱记录.紧急标志%Type,
  开始执行时间_In 病人医嘱记录.开始执行时间%Type,
  执行终止时间_In 病人医嘱记录.执行终止时间%Type,
  病人科室id_In   病人医嘱记录.病人科室id%Type,
  开嘱科室id_In   病人医嘱记录.开嘱科室id%Type,
  开嘱医生_In     病人医嘱记录.开嘱医生%Type,
  开嘱时间_In     病人医嘱记录.开嘱时间%Type,
  检查方法_In     病人医嘱记录.检查方法%Type := Null,
  执行标记_In     病人医嘱记录.执行标记%Type := Null,
  可否分零_In     病人医嘱记录.可否分零%Type := Null,
  摘要_In         病人医嘱记录.摘要%Type := Null,
  操员作姓名_In   病人医嘱状态.操作人员%Type := Null,
  零费记帐_In     病人医嘱记录.零费记帐%Type := Null,
  用药目的_In     病人医嘱记录.用药目的%Type := Null,
  用药理由_In     病人医嘱记录.用药理由%Type := Null,
  审核状态_In     病人医嘱记录.审核状态%Type := Null,
  超量说明_In     病人医嘱记录.超量说明%Type := Null,
  首次用量_In     病人医嘱记录.首次用量%Type := Null,
  手术情况_In     病人医嘱记录.手术情况%Type := Null,
  组合项目id_In   病人医嘱记录.组合项目id%Type := Null,
  皮试结果_In     病人医嘱记录.皮试结果%Type := Null,
  处方序号_In     病人医嘱记录.处方序号%Type := Null
  --功能：被医生或护士修改了部分内容的医嘱记录。可用于门诊或住院。
  --说明：Update时之所以涉及诊疗项目ID,计价特性变化,是因为给药途径,用法的变化
  --      Update时之所以涉及期效变化,是因为自由录入医嘱可任意改变期效
) Is
  v_Count Number;

  v_Temp     Varchar2(255);
  v_人员姓名 病人医嘱状态.操作人员%Type;
  v_处方审查锁定IDs varChar2(4000);
  v_药品内容 病人医嘱记录.医嘱内容%Type;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --检查该医嘱状态:并发操作
  Begin
    Select 医嘱状态 Into v_Count From 病人医嘱记录 Where ID = Id_In;
  Exception
    When Others Then
      Begin
        v_Error := '医嘱"' || 医嘱内容_In || '"已经不存在,可能已被其他人删除。';
        Raise Err_Custom;
      End;
  End;
  If v_Count Not In (-1, 1, 2) Then
    v_Error := '医嘱"' || 医嘱内容_In || '"已经校对或发送,不能再修改。';
    Raise Err_Custom;
  End If;

  Select Count(*) Into v_Count From 病人医嘱状态 Where 医嘱id = Id_In And 操作类型 = 1 And 签名id Is Not Null;
  If Nvl(v_Count, 0) > 0 Then
    v_Error := '医嘱"' || 医嘱内容_In || '"已经电子签名,不能再修改。';
    Raise Err_Custom;
  End If;
  
  --处方审查撤销
  If 相关id_In Is Null Then
     zl_处方审查_cancel(Id_In,v_处方审查锁定IDs);
  End If;

  If v_处方审查锁定IDs Is Not Null Then
    Select 医嘱内容 Into v_药品内容 From 病人医嘱记录 Where 相关ID = Id_In And Rownum<2;
    v_Error :=  '医嘱"' || v_药品内容 || '"已锁定，正在进行处方审查，不能再修改。';
    Raise Err_Custom;
  End If;

  --当前操作人员
  If 操员作姓名_In Is Not Null Then
    v_人员姓名 := 操员作姓名_In;
  Else
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;

  --病人医嘱记录
  Update 病人医嘱记录
  Set 相关id = 相关id_In,
      --比如一并给药，重新设置检查部位等引起的相关ID变化
      序号 = 序号_In, 医嘱状态 = 医嘱状态_In,
      --!因为只能修改未校对医嘱，所以应该为新开，校对疑问的医嘱修改后为新开
      医嘱期效 = 医嘱期效_In, 诊疗项目id = 诊疗项目id_In, 收费细目id = 收费细目id_In, 天数 = 天数_In, 单次用量 = 单次用量_In, 总给予量 = 总给予量_In, 医嘱内容 = 医嘱内容_In,
      医生嘱托 = 医生嘱托_In, 标本部位 = 标本部位_In, 检查方法 = 检查方法_In, 执行标记 = 执行标记_In, 执行频次 = 执行频次_In, 频率次数 = 频率次数_In, 频率间隔 = 频率间隔_In,
      间隔单位 = 间隔单位_In, 执行时间方案 = 执行时间方案_In, 计价特性 = 计价特性_In, 执行科室id = 执行科室id_In, 执行性质 = 执行性质_In, 可否分零 = 可否分零_In,
      --药品根据外购药,出院带药的调整时会发生变化
      紧急标志 = 紧急标志_In, 开始执行时间 = 开始执行时间_In, 执行终止时间 = 执行终止时间_In,
      --!长嘱的终止时间可以修改,临嘱应该为空
      病人科室id = 病人科室id_In,
      --修改时更新为病人的当前科室
      开嘱科室id = 开嘱科室id_In,
      --修改后会根据当前科室变化
      开嘱医生 = 开嘱医生_In, 审核标记 = Decode(Nvl(Instr(开嘱医生_In, '/'), 0), 0, Decode(审核标记, 1, Null, 审核标记), 1),
      --护士开医嘱时可以更改
      开嘱时间 = 开嘱时间_In,
      --补录的可以修改
      摘要 = 摘要_In, 零费记帐 = 零费记帐_In, 手术时间 = Decode(诊疗类别, 'F', To_Date(标本部位_In, 'yyyy-mm-dd hh24:mi:ss'), Null),
      用药目的 = 用药目的_In, 用药理由 = 用药理由_In, 审核状态 = 审核状态_In, 超量说明 = 超量说明_In, 首次用量 = 首次用量_In, 手术情况 = 手术情况_In, 组合项目id = 组合项目id_In,
      皮试结果 = 皮试结果_In,
      --合理用药监测
      处方序号 = 处方序号_In
  Where ID = Id_In;

  --病人医嘱状态:更新医生新开这条
  --因为可能同时：新开(修改)->自动校对(住院医生发送)->互斥自动停止(住院医生发送临嘱停止),因此分别-2,-1秒
  If 医嘱状态_In <> -1 Then
    Update 病人医嘱状态
    Set 操作人员 = v_人员姓名, 操作时间 = Sysdate - 2 / 60 / 60 / 24
    Where 医嘱id = Id_In And 操作类型 = 1; --新开这条始终有,校对疑问保留作为历史记录
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱记录_Update;
/

--118128:刘涛,2017-12-11,不分批批次等于0处理
Create Or Replace Procedure Zl_材料其他入库_Insert
(
  No_In         In 药品收发记录.No%Type,
  序号_In       In 药品收发记录.序号%Type,
  库房id_In     In 药品收发记录.库房id%Type,
  入出类别id_In In 药品收发记录.入出类别id%Type,
  材料id_In     In 药品收发记录.药品id%Type,
  实际数量_In   In 药品收发记录.实际数量%Type,
  成本价_In     In 药品收发记录.成本价%Type,
  成本金额_In   In 药品收发记录.成本金额%Type,
  零售价_In     In 药品收发记录.零售价%Type,
  零售金额_In   In 药品收发记录.零售金额%Type,
  差价_In       In 药品收发记录.差价%Type,
  零售差价_In   In 药品收发记录.差价%Type,
  填制人_In     In 药品收发记录.填制人%Type,
  填制日期_In   In 药品收发记录.填制日期%Type,
  摘要_In       In 药品收发记录.摘要%Type := Null,
  产地_In       In 药品收发记录.产地%Type := Null,
  批号_In       In 药品收发记录.批号%Type := Null,
  生产日期_In   In 药品收发记录.生产日期%Type := Null,
  效期_In       In 药品收发记录.效期%Type := Null,
  灭菌日期_In   In 药品收发记录.灭菌日期%Type := Null,
  灭菌效期_In   In 药品收发记录.灭菌效期%Type := Null,
  商品条码_In   In 药品收发记录.商品条码%Type := Null,
  批准文号_In   In 药品收发记录.批准文号%Type := Null
) Is
  n_Id       药品收发记录.Id%Type; --收发ID
  n_入出系数 药品收发记录.入出系数%Type;
  n_批次     药品收发记录.批次%Type := Null; --批次
  n_库房分批 Integer; --是否分批核算    1:分批;0：不分批
  n_在用分批 Integer; --是否分批核算    1:分批;0：不分批
Begin
  If Not 批准文号_In Is Null And Not 产地_In Is Null Then
    Update 药品生产商对照 Set 批准文号 = 批准文号_In Where 药品id = 材料id_In And 厂家名称 = 产地_In;
    If Sql%RowCount = 0 Then
      Insert Into 药品生产商对照 (药品id, 厂家名称, 批准文号) Values (材料id_In, 产地_In, 批准文号_In);
    End If;
  End If;

  n_入出系数 := 1;

  Select 药品收发记录_Id.Nextval Into n_Id From Dual;

  Select Nvl(库房分批, 0), Nvl(在用分批, 0) Into n_库房分批, n_在用分批 From 材料特性 Where 材料id = 材料id_In;

  If n_在用分批 = 0 Then
    If n_库房分批 = 1 Then
      Begin
        Select Distinct 0
        Into n_库房分批
        From 部门性质说明
        Where (工作性质 = '发料部门' Or 工作性质 Like '制剂室') And 部门id = 库房id_In;
      Exception
        When Others Then
          n_库房分批 := 1;
      End;
    
      If n_库房分批 = 1 Then
        n_批次 := n_Id;
      End If;
	Else
      n_批次 := 0;
    End If;
  Else
    n_批次 := n_Id;
  End If;
  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 灭菌日期, 灭菌效期, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 零售金额, 差价,
     摘要, 填制人, 填制日期, 生产日期, 用法, 商品条码, 批准文号)
  Values
    (n_Id, 1, 17, No_In, 序号_In, 库房id_In, 入出类别id_In, n_入出系数, 材料id_In, n_批次, 产地_In, 批号_In, 效期_In, 灭菌日期_In, 灭菌效期_In,
     实际数量_In, 实际数量_In, 成本价_In, 成本金额_In, 零售价_In, 零售金额_In, 差价_In, 摘要_In, 填制人_In, 填制日期_In, 生产日期_In, 零售差价_In, 商品条码_In,
     批准文号_In);
  
  Zl_未审药品记录_Insert(n_Id);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料其他入库_Insert;
/

--118802:刘涛,2017-12-21,药品卫材验收结论处理
--118128:刘涛,2017-12-11,不分批批次等于0处理
Create Or Replace Procedure Zl_材料外购_Insert
(
  No_In         In 药品收发记录.No%Type,
  序号_In       In 药品收发记录.序号%Type,
  库房id_In     In 药品收发记录.库房id%Type,
  供药单位id_In In 药品收发记录.供药单位id%Type,
  材料id_In     In 药品收发记录.药品id%Type,
  产地_In       In 药品收发记录.产地%Type := Null,
  批号_In       In 药品收发记录.批号%Type := Null,
  生产日期_In   In 药品收发记录.生产日期%Type := Null,
  效期_In       In 药品收发记录.效期%Type := Null,
  灭菌日期_In   In 药品收发记录.灭菌日期%Type := Null,
  灭菌效期_In   In 药品收发记录.灭菌效期%Type := Null,
  实际数量_In   In 药品收发记录.实际数量%Type := Null,
  成本价_In     In 药品收发记录.成本价%Type := Null,
  成本金额_In   In 药品收发记录.成本金额%Type := Null,
  扣率_In       In 药品收发记录.扣率%Type := Null,
  零售价_In     In 药品收发记录.零售价%Type := Null,
  零售金额_In   In 药品收发记录.零售金额%Type := Null,
  差价_In       In 药品收发记录.差价%Type := Null,
  零售差价_In   In 药品收发记录.差价%Type := Null,
  摘要_In       In 药品收发记录.摘要%Type := Null,
  注册证号_In   In 药品收发记录.注册证号%Type := Null,
  填制人_In     In 药品收发记录.填制人%Type := Null,
  随货单号_In   In 应付记录.随货单号%Type := Null,
  发票号_In     In 应付记录.发票号%Type := Null,
  发票日期_In   In 应付记录.发票日期%Type := Null,
  发票金额_In   In 应付记录.发票金额%Type := Null,
  填制日期_In   In 药品收发记录.填制日期%Type := Null,
  核查人_In     In 药品收发记录.配药人%Type := Null,
  核查日期_In   In 药品收发记录.配药日期%Type := Null,
  批次_In       In 药品收发记录.批次%Type := 0,
  退货_In       In Number := 1,
  高值材料_In   In Varchar2 := Null,
  商品条码_In   In 药品收发记录.商品条码%Type := Null,
  内部条码_In   In 药品收发记录.内部条码%Type := Null,
  费用id_In     In 药品收发记录.费用id%Type := 0,
  发票代码_In   In 应付记录.发票代码%Type := Null,
  财务审核_In   In Number := 0,
  批准文号_In   In 药品收发记录.批准文号%Type := Null,
  验收结论_In     In 药品收发记录.验收结论%Type := Null
) Is
  Err_Item Exception;
  v_Err_Msg Varchar2(200);

  v_No         应付记录.No%Type; --应付记录的NO
  v_商品名     收费项目目录.名称%Type; --通用名称
  v_规格       收费项目目录.规格%Type;
  v_产地       收费项目目录.规格%Type;
  v_单位       收费项目目录.计算单位%Type;
  v_Lngid      药品收发记录.Id%Type; --收发ID
  n_应付id     应付记录.Id%Type; --应付记录的ID
  n_入出类别id 药品收发记录.入出类别id%Type; --入出类别ID
  n_入出系数   药品收发记录.入出系数%Type; --入出系数
  n_批次       药品收发记录.批次%Type := Null; --批次
  n_库房分批   Integer; --是否分批核算    1:分批；0：不分批
  n_在用分批   Integer; --是否在用分批       1:分批；0：不分批
  v_可用数量   药品库存.可用数量%Type;
  v_下库存   Zlparameters.参数值%Type;
Begin
  Select To_Number(Nvl(Zl_Getsysparameter(95), '0')) Into v_下库存 From Dual;
  
  If Not 批准文号_In Is Null And Not 产地_In Is Null Then
    Update 药品生产商对照 Set 批准文号 = 批准文号_In Where 药品id = 材料id_In And 厂家名称 = 产地_In;
    If Sql%RowCount = 0 Then
      Insert Into 药品生产商对照 (药品id, 厂家名称, 批准文号) Values (材料id_In, 产地_In, 批准文号_In);
    End If;
  End If;

  --取该材料的名称
  v_产地 := '';
  Select 名称, 规格, 计算单位 Into v_商品名, v_规格, v_单位 From 收费项目目录 Where ID = 材料id_In;

  If v_规格 Is Not Null Then
    If Instr(v_规格, '|') <> 0 Then
      v_产地 := Substr(v_规格, Instr(v_规格, '|'));
      v_规格 := Substr(v_规格, Instr(v_规格, '|') - 1);
    End If;
  End If;

  Select 药品收发记录_Id.Nextval Into v_Lngid From Dual;

  Select Nvl(库房分批, 0), Nvl(在用分批, 0) Into n_库房分批, n_在用分批 From 材料特性 Where 材料id = 材料id_In;

  --财务审核直接用传过来的批次
  If 财务审核_In = 0 Then
    If 费用id_In > 0 And 批次_In > 0 Then
      n_批次 := 批次_In;
    Else
      If n_在用分批 = 0 Then
        If n_库房分批 = 1 Then
          Begin
            Select Distinct 0
            Into n_库房分批
            From 部门性质说明
            Where ((工作性质 Like '发料部门') Or (工作性质 Like '制剂室')) And 部门id = 库房id_In;
          Exception
            When Others Then
              n_库房分批 := 1;
          End;
        
          If n_库房分批 = 1 Then
            n_批次 := v_Lngid;
          End If;
		Else
          n_批次 := 0;
        End If;
      Else
        n_批次 := v_Lngid;
      End If;
    End If;
  Else
    n_批次 := 批次_In;
  End If;

  Select b.Id, b.系数
  Into n_入出类别id, n_入出系数
  From 药品单据性质 A, 药品入出类别 B
  Where a.类别id = b.Id And a.单据 = 30 And Rownum < 2;

  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 供药单位id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 生产日期, 效期, 灭菌日期, 灭菌效期, 填写数量, 实际数量, 成本价, 成本金额,
     扣率, 零售价, 零售金额, 差价, 摘要, 填制人, 填制日期, 发药方式, 配药人, 配药日期, 注册证号, 用法, 商品条码, 内部条码, 费用id, 批准文号, 验收结论)
  Values
    (v_Lngid, 1, 15, No_In, 序号_In, 库房id_In, 供药单位id_In, n_入出类别id, n_入出系数, 材料id_In, Decode(退货_In, -1, 批次_In, n_批次), 产地_In,
     批号_In, 生产日期_In, 效期_In, 灭菌日期_In, 灭菌效期_In, 退货_In * 实际数量_In, 退货_In * 实际数量_In, 成本价_In, 退货_In * 成本金额_In, 扣率_In, 零售价_In,
     退货_In * 零售金额_In, 退货_In * 差价_In, 摘要_In, 填制人_In, 填制日期_In, Decode(退货_In, -1, 1, 0), 核查人_In, 核查日期_In, 注册证号_In, 零售差价_In,
     商品条码_In, 内部条码_In, 费用id_In, 批准文号_In, 验收结论_In);
  
  Zl_未审药品记录_Insert(v_Lngid);
  --高值材料信息
  If Length(高值材料_In) > 0 Then
    Insert Into 收发记录补充信息
      (收发id, 科室, 病人姓名, 住院号, 床号)
    Values
      (v_Lngid, Substr(高值材料_In, 1, Instr(高值材料_In, ',', 1, 1) - 1),
       Substr(高值材料_In, Instr(高值材料_In, ',', 1, 1) + 1, Instr(高值材料_In, ',', 1, 2) - Instr(高值材料_In, ',', 1, 1) - 1),
       Substr(高值材料_In, Instr(高值材料_In, ',', 1, 2) + 1, Instr(高值材料_In, ',', 1, 3) - Instr(高值材料_In, ',', 1, 2) - 1),
       Substr(高值材料_In, Instr(高值材料_In, ',', 1, 3) + 1, Length(高值材料_In)));
  End If;

  If 发票号_In Is Not Null Or 随货单号_In Is Not Null Then
  
    Select 应付记录_Id.Nextval Into n_应付id From Dual;
  
    --如果是第一笔明细,则产生应付记录的NO
    Begin
      Select NO
      Into v_No
      From 应付记录
      Where 系统标识 = 5 And 记录性质 = 0 And 记录状态 = 1 And 入库单据号 = No_In And Rownum < 2;
    Exception
      When Others Then
        v_No := Nextno(67);
    End;
  
    Insert Into 应付记录
      (ID, 记录性质, 记录状态, 项目id, 序号, 单位id, NO, 系统标识, 收发id, 入库单据号, 单据金额, 随货单号, 发票号, 发票日期, 发票金额, 品名, 规格, 产地, 批号, 计量单位, 数量,
       采购价, 采购金额, 填制人, 填制日期, 审核人, 审核日期, 摘要, 库房id, 发票代码)
    Values
      (n_应付id, 0, 1, 材料id_In, 序号_In, 供药单位id_In, v_No, 5, v_Lngid, No_In, 退货_In * 零售金额_In, 随货单号_In, 发票号_In, 发票日期_In,
       退货_In * Decode(发票号_In, Null, 成本金额_In, 发票金额_In), v_商品名, v_规格, v_产地, 批号_In, v_单位, 退货_In * 实际数量_In, 成本价_In,
       退货_In * 成本金额_In, 填制人_In, 填制日期_In, Null, Null, 摘要_In, 库房id_In, 发票代码_In);
  End If;
  
  if v_下库存=1 then
    --退货时下可用数量
    If 退货_In = -1 And Nvl(费用id_In, 0) <> 2 Then
      --检查库存
      Begin
        Select Nvl(可用数量, 0)
        Into v_可用数量
        From 药品库存
        Where 库房id = 库房id_In And 药品id = 材料id_In And Nvl(批次, 0) = Nvl(批次_In, 0) And 性质 = 1;
      Exception
        When Others Then
          v_可用数量 := 0;
      End;
    
      If v_可用数量 - 实际数量_In < 0 Then
        v_Err_Msg := '[ZLSOFT]第' || 序号_In || '行的可用数量不够,请检查[ZLSOFT]';
        Raise Err_Item;
      End If;
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) - 实际数量_In
      Where 库房id = 库房id_In And 药品id = 材料id_In And Nvl(批次, 0) = 批次_In And 性质 = 1;
      Delete From 药品库存
      Where 库房id = 库房id_In And 药品id = 材料id_In And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
            Nvl(实际差价, 0) = 0;
    End If;
  end if;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料外购_Insert;
/

--116632:刘涛,2017-12-08,药品结存汇总修改
Create Or Replace Procedure Zl1_Autocloseaccount Is
  v_Lngid    药品结存记录.Id%Type;
  d_开始日期 药品结存记录.期初日期%Type;
  d_结束日期 药品结存记录.期末日期%Type;
  n_结存时点 Number(2);
  v_Error    Varchar2(255);
  Err_Custom Exception;
  d_计算日期     药品结存记录.期末日期%Type;
  n_结存id       药品结存记录.Id%Type;
  n_未审核结存id 药品结存记录.Id%Type;

  Cursor c_Stock Is
    Select Distinct b.Id
    From 部门性质说明 A, 部门表 B
    Where a.部门id = b.Id And a.工作性质 In ('西药库', '成药库', '中药库', '西药房', '成药房', '中药房', '制剂室') And
          To_Char(b.撤档时间, 'yyyy-MM-dd') = '3000-01-01'
    Order By b.Id;
  r_Stock c_Stock%RowType;
Begin
  --取结存时点，默认每月最后一日结存
  n_结存时点 := Nvl(zl_GetSysParameter(221), 0);

  --只有自动结存才走此过程，手工结存不在走此过程
  If n_结存时点 <> -1 Then
    --计算本次结存的结束日期；因为自动结存是对前一天数据进行结存，所以需要按当前日期提前一天来计算或判断，
    If n_结存时点 = 0 Or n_结存时点 > To_Number(To_Char(Trunc(Last_Day(Sysdate - 1)), 'dd')) Then
      --指定按每月最后一天结存；或者结存时点大于了本月最大天数，也按本月最后一天结存
      d_结束日期 := Trunc(Last_Day(Sysdate - 1)) + 1 - 1 / 24 / 60 / 60;
    Else
      d_结束日期 := Trunc(Sysdate - 1, 'MONTH') + n_结存时点 - 1 / 24 / 60 / 60;
    End If;
  
    --检查日期，在结存时点后才能进行自动结存
    If Sysdate - d_结束日期 > 0 Then
      For r_Stock In c_Stock Loop
        --判断期间内是否有结存(不算转结)
        --此处不再通过“期间”字段进行判断，而是通过结存时间点来判断：如2016-05-28 23：59：59，如有则不结存，无则结存
        Select Nvl(Max(ID), 0)
        Into n_结存id
        From 药品结存记录
        Where 库房id = r_Stock.Id And 期末日期 = d_结束日期 And 取消人 Is Null;
      
        If n_结存id > 0 Then
          --如果当前期间已经结存过了，就不再结存，一个期间只结存一次
          Null;
        Else
          --取库房最大的结存ID和本次结存的开始日期
          Select Nvl(Max(ID), 0), Max(期末日期) + 1 / 24 / 60 / 60
          Into n_结存id, d_开始日期
          From 药品结存记录
          Where 库房id = r_Stock.Id And 取消人 Is Null;
        
          --开始时间不能大于结束时间
          If d_开始日期 <= d_结束日期 Then
            If n_结存id > 0 Then
              --检查是否存在未审核的结存，如果存在则自动审核(通常情况都是在期间内手工审核)
              Select Nvl(Max(ID), 0)
              Into n_未审核结存id
              From 药品结存记录
              Where 库房id = r_Stock.Id And 审核日期 Is Null;
            
              If n_未审核结存id > 0 Then
                Zl_药品结存记录_Verify(n_未审核结存id, Zl_Username);
              End If;
            
              --产生新的结存记录
              Select 药品结存记录_Id.Nextval Into v_Lngid From Dual;
            
              Insert Into 药品结存记录
                (ID, 库房id, 期初日期, 期末日期, 填制人, 填制日期, 上次结存id, 期间, 性质)
              Values
                (v_Lngid, r_Stock.Id, d_开始日期, d_结束日期, Nvl(Zl_Username, 'zlhis'), Sysdate, n_结存id,
                 To_Char(Trunc(d_结束日期), 'yyyymm'), 1);
            
              --产生药品结存明细表，本期期末=本期期初(上期期末)+期间发生
              Insert Into 药品结存明细
                (结存id, 库房id, 药品id, 批次, 期初数量, 期初金额, 期初差价, 期末数量, 期末金额, 期末差价)
                Select v_Lngid, 库房id, 药品id, 批次, Sum(期初数量), Sum(期初金额), Sum(期初差价), Sum(期末数量), Sum(期末金额), Sum(期末差价)
                From (Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, a.期末数量 As 期初数量, a.期末金额 As 期初金额, a.期末差价 As 期初差价, a.期末数量,
                              a.期末金额, a.期末差价
                       From 药品结存明细 A, 药品规格 B
                       Where a.药品id = b.药品id And a.结存id = n_结存id
                       Union All
                       Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, 0 As 期初数量, 0 As 期初金额, 0 As 期初差价,
                              a.入出系数 * a.实际数量 * Nvl(a.付数, 1) As 期末数量, a.入出系数 * a.零售金额 As 期末金额, a.入出系数 * a.差价 As 期末差价
                       From 药品收发记录 A, 药品规格 B
                       Where a.药品id = b.药品id And a.库房id + 0 = r_Stock.Id And a.审核日期 Between d_开始日期 And d_结束日期)
                Group By 库房id, 药品id, 批次
                Order By 库房id, 药品id, 批次;

			  --将期间数据插入药品结存汇总表
              Insert Into 药品结存汇总
                (结存id, 入出系数, 入出类别id, 库房id, 药品id, 批次, 数量, 金额, 差价)
                Select v_Lngid, c.系数, c.id, a.库房id, a.药品id, Nvl(a.批次, 0), Sum(Nvl(a.实际数量, 0) * Nvl(a.付数, 1)) 实际数量,
                       Sum(Nvl(a.零售金额, 0)) 零售金额, Sum(Nvl(a.差价, 0)) As 差价
                From 药品收发记录 A, 药品规格 B, 药品入出类别 C
                Where a.药品id = b.药品id And a.入出类别id = c.Id And a.库房id = r_Stock.Id And a.审核日期 Between d_开始日期 And d_结束日期
                Group By a.库房id, a.药品id, c.id, c.系数, Nvl(a.批次, 0);
            
              --计算误差：本期期末-库存记录(减去本期期末时间后发生的数据)
              Insert Into 药品结存误差
                (ID, 结存id, 库房id, 药品id, 批次, 数量差, 金额差, 差价差)
                Select 药品结存误差_Id.Nextval, v_Lngid, a.库房id, a.药品id, a.批次, a.实际数量 As 数量差, a.实际金额 As 金额差, a.实际差价 As 差价差
                From (Select 库房id, 药品id, 批次, Sum(实际数量) As 实际数量, Sum(实际金额) As 实际金额, Sum(实际差价) As 实际差价
                       From (Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, Nvl(a.期末数量, 0) As 实际数量, Nvl(a.期末金额, 0) As 实际金额,
                                     Nvl(a.期末差价, 0) As 实际差价
                              From 药品结存明细 A, 药品规格 B
                              Where a.药品id = b.药品id And a.结存id = v_Lngid
                              Union All
                              Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, -1 * Nvl(a.实际数量, 0) As 实际数量,
                                     -1 * Nvl(a.实际金额, 0) As 实际金额, -1 * Nvl(实际差价, 0) As 实际差价
                              From 药品库存 A, 药品规格 B
                              Where a.药品id = b.药品id And a.性质 = 1 And a.库房id = r_Stock.Id
                              Union All
                              Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, a.入出系数 * a.实际数量 * Nvl(a.付数, 1) As 实际数量,
                                     a.入出系数 * a.零售金额 As 实际金额, a.入出系数 * a.差价 As 实际差价
                              From 药品收发记录 A, 药品规格 B
                              Where a.药品id = b.药品id And a.库房id = r_Stock.Id And a.审核日期 > d_结束日期) A
                       Group By 库房id, 药品id, 批次) A
                Where a.实际数量 <> 0 Or a.实际金额 <> 0 Or a.实际差价 <> 0;
              --自动结存后立马审核结存信息
              Zl_药品结存记录_Verify(v_Lngid, Zl_Username);
            End If;
          End If;
        End If;
        --按库房提交
        Commit;
      End Loop;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl1_Autocloseaccount;
/

--116632:刘涛,2017-12-08,药品结存汇总表的修改
Create Or Replace Procedure Zl_药品结存记录_Insert
(
  库房id_In In 药品结存记录.库房id%Type := Null,
  填制人_In In 药品结存记录.填制人%Type := Null,
  转结_In   In Number := 1
) Is
  v_Lngid      药品结存记录.Id%Type;
  d_开始日期   药品结存记录.期初日期%Type;
  d_结束日期   药品结存记录.期末日期%Type;
  n_结存时点   Number(2);
  n_上次结存id 药品结存记录.Id%Type;
  v_上次期间   药品结存记录.期间%Type;
  v_Error      Varchar2(255);
  Err_Custom Exception;
  n_未审核记录 Number(1) := 0;
Begin
  If 转结_In = 0 Then
    --初始结存，期初日期 = 期末日期= 当前系统日期
    d_开始日期 := Sysdate;
    d_结束日期 := d_开始日期;
  Else
    --检查是否存在未审核的结存记录，如果存在则不能结存
    Select Count(ID) Into n_未审核记录 From 药品结存记录 Where 库房id = 库房id_In And 审核日期 Is Null;
  
    If n_未审核记录 > 0 Then
      v_Error := '上次结存未审核，不能再次结存';
      Raise Err_Custom;
    End If;
  
    --取结存时点，默认每月最后一日结存
    n_结存时点 := Nvl(Zl_Getsysparameter(221), 0);
  
    If n_结存时点 <> -1 Then
      --自动结存
      --取上次结存ID,上期期末日期作为本期的期初日期,上次期间
      Select Max(ID), Trunc(Max(期末日期)) + 1, Max(期间)
      Into n_上次结存id, d_开始日期, v_上次期间
      From 药品结存记录
      Where 库房id = 库房id_In And 取消人 Is Null;
    
      --自动结存
      If n_结存时点 = 0 Or n_结存时点 > To_Number(To_Char(Trunc(Last_Day(d_开始日期 - 1)), 'dd')) Then
        --指定按每月最后一天结存；或者结存时点大于了本月最大天数，也按本月最后一天结存
        d_结束日期 := Trunc(Last_Day(Sysdate - 1)) + 1 - 1 / 24 / 60 / 60;
      Else
        d_结束日期 := Trunc(Sysdate - 1, 'MONTH') + n_结存时点 - 1 / 24 / 60 / 60;
      End If;
      --检查日期，在结存时点后才能进行结存
      If Sysdate - d_结束日期 < 0 Then
        v_Error := '本月结存时点未到，不能提前结存！';
        Raise Err_Custom;
      End If;
    
      --检查期间
      If v_上次期间 = To_Char(Trunc(d_结束日期), 'yyyymm') Then
        v_Error := '本月已经结存，不能再次结存！';
        Raise Err_Custom;
      End If;
    Else
      --手工结存
      --取上次结存ID,上期期末日期作为本期的期初日期,上次期间
      Select Max(ID), Max(期末日期) + 1 / 24 / 60 / 60, Max(期间)
      Into n_上次结存id, d_开始日期, v_上次期间
      From 药品结存记录
      Where 库房id = 库房id_In And 取消人 Is Null;
    
      d_结束日期 := Sysdate;
    End If;
  End If;

  Select 药品结存记录_Id.Nextval Into v_Lngid From Dual;

  --产生药品结存主表
  Insert Into 药品结存记录
    (ID, 库房id, 期初日期, 期末日期, 填制人, 填制日期, 审核人, 审核日期, 上次结存id, 期间, 性质)
  Values
    (v_Lngid, 库房id_In, d_开始日期, d_结束日期, Nvl(填制人_In, Zl_Username), Sysdate,
     Decode(d_开始日期, Null, Nvl(填制人_In, Zl_Username), Null), Decode(d_开始日期, Null, Sysdate, Null), n_上次结存id,
     To_Char(Trunc(d_结束日期), 'yyyymm'), Decode(转结_In, 0, 0, 1));

  If 转结_In = 0 Then
    --初始结存，以当前库存为准期末 = 期初=当前库存数据
    Insert Into 药品结存明细
      (结存id, 库房id, 药品id, 批次, 期初数量, 期初金额, 期初差价, 期末数量, 期末金额, 期末差价)
      Select v_Lngid, 库房id, 药品id, 批次, Sum(期初数量), Sum(期初金额), Sum(期初差价), Sum(期末数量), Sum(期末金额), Sum(期末差价)
      From (Select a.库房id, a.药品id, Nvl(a.批次, 0) 批次, Nvl(a.实际数量, 0) As 期初数量, Nvl(a.实际金额, 0) As 期初金额,
                    Nvl(a.实际差价, 0) As 期初差价, Nvl(a.实际数量, 0) As 期末数量, Nvl(实际金额, 0) As 期末金额, Nvl(实际差价, 0) As 期末差价
             From 药品库存 A, 药品规格 B
             Where a.药品id = b.药品id And a.性质 = 1 And a.库房id = 库房id_In
             Union All
             Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, -1 * a.入出系数 * a.实际数量 * Nvl(a.付数, 1) As 期初数量,
                    -1 * a.入出系数 * a.零售金额 As 期初金额, -1 * a.入出系数 * a.差价 As 期初差价, -1 * a.入出系数 * a.实际数量 * Nvl(a.付数, 1) As 期末数量,
                    -1 * a.入出系数 * a.零售金额 As 期末金额, -1 * a.入出系数 * a.差价 As 期末差价
             From 药品收发记录 A, 药品规格 B
             Where a.药品id = b.药品id And a.库房id + 0 = 库房id_In And a.审核日期 > d_结束日期)
      Group By 库房id, 药品id, 批次
      Order By 库房id, 药品id, 批次;
  Else
    --产生药品结存明细表，本期期末=本期期初(上期期末)+期间发生
    Insert Into 药品结存明细
      (结存id, 库房id, 药品id, 批次, 期初数量, 期初金额, 期初差价, 期末数量, 期末金额, 期末差价)
      Select v_Lngid, 库房id, 药品id, 批次, Sum(期初数量), Sum(期初金额), Sum(期初差价), Sum(期末数量), Sum(期末金额), Sum(期末差价)
      From (Select 库房id, 药品id, Nvl(批次, 0) As 批次, 期末数量 As 期初数量, 期末金额 As 期初金额, 期末差价 As 期初差价, 期末数量, 期末金额, 期末差价
             From 药品结存明细
             Where 结存id = n_上次结存id
             Union All
             Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, 0 As 期初数量, 0 As 期初金额, 0 As 期初差价,
                    a.入出系数 * a.实际数量 * Nvl(a.付数, 1) As 期末数量, a.入出系数 * a.零售金额 As 期末金额, a.入出系数 * a.差价 As 期末差价
             From 药品收发记录 A, 药品规格 B
             Where a.药品id = b.药品id And a.库房id + 0 = 库房id_In And a.审核日期 Between d_开始日期 And d_结束日期)
      Group By 库房id, 药品id, 批次
      Order By 库房id, 药品id, 批次;

	--将期间数据插入药品结存汇总表
    Insert Into 药品结存汇总
      (结存id, 入出系数, 入出类别id, 库房id, 药品id, 批次, 数量, 金额, 差价)
      Select v_Lngid, c.系数, c.id, a.库房id, a.药品id, Nvl(a.批次, 0), Sum(Nvl(a.实际数量, 0) * Nvl(a.付数, 1)) 实际数量,
             Sum(Nvl(a.零售金额, 0)) 零售金额, Sum(Nvl(a.差价, 0)) As 差价
      From 药品收发记录 A, 药品规格 B, 药品入出类别 C
      Where a.药品id = b.药品id And a.入出类别id = c.Id And a.库房id = 库房id_In And a.审核日期 Between d_开始日期 And d_结束日期

      Group By a.库房id, a.药品id, c.id, c.系数, Nvl(a.批次, 0);
  
    --计算误差：本期期末-库存记录(减去本期期末时间后发生的数据)
    Insert Into 药品结存误差
      (ID, 结存id, 库房id, 药品id, 批次, 数量差, 金额差, 差价差)
      Select 药品结存误差_Id.Nextval, v_Lngid, a.库房id, a.药品id, a.批次, a.实际数量 As 数量差, a.实际金额 As 金额差, a.实际差价 As 差价差
      From (Select 库房id, 药品id, 批次, Sum(实际数量) As 实际数量, Sum(实际金额) As 实际金额, Sum(实际差价) As 实际差价
             From (Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, Nvl(a.期末数量, 0) As 实际数量, Nvl(a.期末金额, 0) As 实际金额,
                           Nvl(a.期末差价, 0) As 实际差价
                    From 药品结存明细 A, 药品规格 B
                    Where a.药品id = b.药品id And a.结存id = v_Lngid
                    Union All
                    Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, -1 * Nvl(a.实际数量, 0) As 实际数量, -1 * Nvl(a.实际金额, 0) As 实际金额,
                           -1 * Nvl(a.实际差价, 0) As 实际差价
                    From 药品库存 A, 药品规格 B
                    Where a.药品id = b.药品id And a.性质 = 1 And a.库房id = 库房id_In
                    Union All
                    Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, a.入出系数 * a.实际数量 * Nvl(a.付数, 1) As 实际数量,
                           a.入出系数 * a.零售金额 As 实际金额, a.入出系数 * a.差价 As 实际差价
                    From 药品收发记录 A, 药品规格 B
                    Where a.药品id = b.药品id And a.库房id = 库房id_In And a.审核日期 > d_结束日期) A
             Group By 库房id, 药品id, 批次) A
      Where a.实际数量 <> 0 Or a.实际金额 <> 0 Or a.实际差价 <> 0;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品结存记录_Insert;
/

--0:余伟节,2017-12-11,门诊临床路径数据抽回
Create Or Replace Procedure Zl_Retu_Clinic
(
  n_Patiid In Number,
  v_Times  In Varchar2,
  n_Flag   In Number
) As
  --------------------------------------------
  --参数:n_Patiid,病人id
  --     v_Times,挂号单号或住院主页id（体检时，挂号单是体检单号）
  --     n_Flag,门诊或住院标志:0-门诊,1-住院,2-体检（此时，只有n_Patiid参数无效）
  --------------------------------------------
  Err_Item Exception;
  v_Err_Msg    Varchar2(100);
  n_System     Number(5);
  n_Opersystem Number(5);
  n_只读       Number(2);
  n_Count      Number(5);

  v_Table    Varchar2(100);
  v_Subtable Varchar2(100);
  v_Field    Varchar2(100);
  v_Subfield Varchar2(100);
  v_Sql      Varchar2(4000);
  v_Sqlchild Varchar2(4000);
  v_Fields   Varchar2(4000);

  v_Dblink Varchar2(30);

  Type t_Tab_Col Is Table Of Varchar2(4000) Index By Varchar2(32);
  Arr_Tab_Col t_Tab_Col;

  ---------------------------------------------
  --功能：获取表的字段字符串
  Function Getfields(v_Table In Varchar2) Return Varchar2 As
    v_Colstr Varchar2(4000);
  Begin
    If Arr_Tab_Col.Exists(v_Table) Then
      v_Colstr := Arr_Tab_Col(v_Table);
    Else
      Select f_List2str(Cast(Collect(Column_Name) As t_Strlist)) As Colsstr
      Into v_Colstr
      From (Select Column_Name From User_Tab_Columns Where Table_Name = v_Table Order By Column_Id);
    
      Arr_Tab_Col(v_Table) := v_Colstr;
    End If;
  
    Return v_Colstr;
  End Getfields;

  --------------------------------------------
  --返回指定病人ID和主页的相关表的子过程
  --------------------------------------------
  Procedure Zl_Retu_Other
  (
    n_Pati_Id 病案主页.病人id%Type,
    n_Page_Id 病案主页.主页id%Type
  ) As
  
  Begin
  
    For R In (Select Column_Value From Table(f_Str2list('病人过敏记录,病人诊断记录,病人手麻记录'))) Loop
      v_Table  := r.Column_Value;
      v_Fields := Getfields(v_Table);
      v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                  Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table || ' Where 病人id = :1 And 主页id = :2';
      Execute Immediate v_Sql
        Using n_Pati_Id, n_Page_Id;
    
      v_Sql := 'Delete From H' || v_Table || ' Where 病人id = :1 And 主页id = :2';
      Execute Immediate v_Sql
        Using n_Pati_Id, n_Page_Id;
    End Loop;
  End Zl_Retu_Other;

  --------------------------------------------
  --返回指定病人ID和主页的临床路径相关表的子过程
  --------------------------------------------
  Procedure Zl_Retu_Path
  (
    n_Pati_Id 病案主页.病人id%Type,
    n_Page_Id 病案主页.主页id%Type
  ) As
  Begin
    v_Table  := '病人临床路径';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                ' From H' || v_Table || ' Where 病人id = :1 And 主页id = :2 ';
    Execute Immediate v_Sql
      Using n_Pati_Id, n_Page_Id;
  
    --病人路径医嘱，在病人医嘱记录转出之后执行
    For P In (Select ID As 路径记录id From H病人临床路径 Where 病人id = n_Pati_Id And 主页id = n_Page_Id) Loop
      For R In (Select Column_Value
                From Table(f_Str2list('病人路径执行,病人合并路径,病人路径评估,病人路径变异,病人路径指标,病人合并路径评估,病人出径记录'))) Loop
        v_Table := r.Column_Value;
        If v_Table = '病人合并路径' Then
          v_Field := '首要路径记录id';
        Else
          v_Field := '路径记录id';
        End If;
      
        v_Fields := Getfields(v_Table);
        v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                    Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table || ' Where ' || v_Field || ' = :1';
        Execute Immediate v_Sql
          Using p.路径记录id;
      
        v_Sql := 'Delete H' || v_Table || ' Where ' || v_Field || ' = :1';
        Execute Immediate v_Sql
          Using p.路径记录id;
      End Loop;
    End Loop;
  
    Delete H病人临床路径 Where 病人id = n_Pati_Id And 主页id = n_Page_Id;
  End Zl_Retu_Path;
  --------------------------------------------
  --返回指定挂号ID的门诊临床路径相关表的子过程
  --------------------------------------------
  Procedure Zl_Retu_Pathout(n_Pati_Visit_Id 病人挂号记录.Id%Type) As
  Begin
    --病人路径医嘱，在病人医嘱记录转出之后执行
    For P In (Select Distinct ID
              From H病人门诊路径
              Where ID In (Select 路径记录id From H病人门诊路径记录 Where 挂号id = n_Pati_Visit_Id)) Loop

      v_Table  := '病人门诊路径';
      v_Fields := Getfields(v_Table);
      v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                  Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table || ' Where ID = :1';
      Execute Immediate v_Sql
        Using p.Id;
      For R In (Select Column_Value
                From Table(f_Str2list('病人门诊路径记录,病人门诊路径执行,病人门诊路径评估,病人门诊路径变异,病人门诊路径指标,病人门诊出径记录'))) Loop
        v_Table := r.Column_Value;
        v_Field := '路径记录id';
      
        v_Fields := Getfields(v_Table);
        v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                    Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table || ' Where ' || v_Field || ' = :1';
        Execute Immediate v_Sql
          Using p.Id;
      
        v_Sql := 'Delete H' || v_Table || ' Where ' || v_Field || ' = :1';
        Execute Immediate v_Sql
          Using p.Id;
      End Loop;
      Delete H病人门诊路径 Where ID = p.Id;
    End Loop;
  
  End Zl_Retu_Pathout;
  --------------------------------------------
  --返回指定病人ID和主页的护理相关表的子过程
  --------------------------------------------
  Procedure Zl_Retu_Tend
  (
    n_Pati_Id 病案主页.病人id%Type,
    n_Page_Id 病案主页.主页id%Type
  ) As
  Begin
  
    v_Table  := '病人护理文件';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                ' From H' || v_Table || ' Where 病人id = :1 And 主页id = :2 ';
    Execute Immediate v_Sql
      Using n_Pati_Id, n_Page_Id;
  
    For P In (Select ID As 文件id From H病人护理文件 Where 病人id = n_Pati_Id And 主页id = n_Page_Id) Loop
      For R In (Select Column_Value
                From Table(f_Str2list('病人护理数据,病人护理打印,病人护理诊断,病人护理活动项目,病人护理要素内容,产程要素内容'))) Loop
        v_Table  := r.Column_Value;
        v_Fields := Getfields(v_Table);
        v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                    Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table || ' Where 文件id = :1';
        Execute Immediate v_Sql
          Using p.文件id;
      
        If v_Table = '病人护理数据' Then
          v_Fields := Getfields('病人护理明细');
          v_Sql    := 'Insert Into 病人护理明细(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                      ' From H病人护理明细 Where 记录id In (Select ID From H病人护理数据 Where 文件id = :1)';
          Execute Immediate v_Sql
            Using p.文件id;
        
          v_Sql := 'Delete H病人护理明细 Where 记录id In (Select ID From H病人护理数据 Where 文件id = :1)';
          Execute Immediate v_Sql
            Using p.文件id;
        End If;
      
        v_Sql := 'Delete H' || v_Table || ' Where 文件id = :1';
        Execute Immediate v_Sql
          Using p.文件id;
      End Loop;
    End Loop;
  
    Delete H病人护理文件 Where 病人id = n_Pati_Id And 主页id = n_Page_Id;
  
    --老版护理系统数据
    ------------------------------------------------------------------------
    v_Table  := '病人护理记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                ' From H' || v_Table || ' Where 病人id = :1 And 主页id = :2 ';
    Execute Immediate v_Sql
      Using n_Pati_Id, n_Page_Id;
  
    For P In (Select ID From H病人护理记录 Where 病人id = n_Pati_Id And 主页id = n_Page_Id) Loop
      v_Table  := '病人护理内容';
      v_Fields := Getfields(v_Table);
      v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                  Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table || ' Where 记录ID = :1';
      Execute Immediate v_Sql
        Using p.Id;
    
      v_Sql := 'Delete H' || v_Table || ' Where 记录ID = :1';
      Execute Immediate v_Sql
        Using p.Id;
    End Loop;
  
    Delete H病人护理记录 Where 病人id = n_Pati_Id And 主页id = n_Page_Id;
  End Zl_Retu_Tend;

  --------------------------------------------
  --返回指定ID的病人新版电子病历记录子过程
  --------------------------------------------
  Procedure Zl_Retu_Epr(n_Rec_Id H电子病历记录.Id%Type) As
    v_Field Varchar(100);
  Begin
    v_Table  := '电子病历记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                ' From H' || v_Table || ' Where id = :1';
    Execute Immediate v_Sql
      Using n_Rec_Id;
  
    --病人诊断记录在Zl_Retu_Other中已转回（无病历ID外键）
    --影像报告驳回,病人医嘱报告,报告查阅记录,这几张表的数据在Zl_Retu_Order中转回医嘱后再处理
    For R In (Select Column_Value
              From Table(f_Str2list('电子病历附件,电子病历格式,电子病历内容,疾病申报记录,疾病报告反馈,疾病申报反馈'))) Loop
      v_Table := r.Column_Value;
      If v_Table = '电子病历附件' Then
        v_Field := '病历id';
      Else
        v_Field := '文件id';
      End If;
      v_Fields := Getfields(v_Table);
    
      --含LOB字段的表(电子病历图形,电子病历格式,电子病历附件)，其H表是临时表，所以需直接指定dblink
      If v_Dblink Is Not Null And (v_Table = '电子病历附件' Or v_Table = '电子病历格式') Then
        v_Sql := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                 ' From ' || v_Table || '@' || v_Dblink || ' Where ' || v_Field || ' = :1';
      Else
        v_Sql := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                 ' From H' || v_Table || ' Where ' || v_Field || ' = :1';
      End If;
      Execute Immediate v_Sql
        Using n_Rec_Id;
    
      If v_Table = '电子病历内容' Then
        v_Fields := Getfields('电子病历图形');
      
        If v_Dblink Is Not Null Then
          v_Sql := 'Insert Into 电子病历图形(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                   ' From 电子病历图形@' || v_Dblink ||
                   ' a Where 对象id In (Select ID From H电子病历内容 Where 文件id = :1 And 对象类型 = 5)';
        Else
          v_Sql := 'Insert Into 电子病历图形(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                   ' From H电子病历图形 Where 对象id In (Select ID From H电子病历内容 Where 文件id = :1 And 对象类型 = 5)';
        End If;
        Execute Immediate v_Sql
          Using n_Rec_Id;
      
        If v_Dblink Is Not Null Then
          v_Sql := 'Delete 电子病历图形@' || v_Dblink ||
                   ' Where 对象id In (Select ID From H电子病历内容 Where 文件id = :1 And 对象类型 = 5)';
          Execute Immediate v_Sql
            Using n_Rec_Id;
        Else
          Delete H电子病历图形 Where 对象id In (Select ID From H电子病历内容 Where 文件id = n_Rec_Id And 对象类型 = 5);
        End If;
      End If;
    
      If v_Dblink Is Not Null And (v_Table = '电子病历附件' Or v_Table = '电子病历格式') Then
        v_Sql := 'Delete ' || v_Table || '@' || v_Dblink || ' Where ' || v_Field || ' = :1';
      Else
        v_Sql := 'Delete H' || v_Table || ' Where ' || v_Field || ' = :1';
      End If;
      Execute Immediate v_Sql
        Using n_Rec_Id;
    End Loop;
  
    Delete H电子病历记录 Where ID = n_Rec_Id;
  End Zl_Retu_Epr;
  --------------------------------------------
  --返回指定ID的病人医嘱记录子过程，必须在病历、临床路径转出之后执行(病人医嘱报告,影像报告驳回，病人路径医嘱,病人门诊路径医嘱)
  --在Zl_Retu_Other中已转回了"病人诊断记录",转回"病人诊断医嘱"时不用再转
  --------------------------------------------
  Procedure Zl_Retu_Order(n_Rec_Id H病人医嘱记录.Id%Type) As
  Begin
    v_Table  := '病人医嘱记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                ' From H' || v_Table || ' Where id = :1';
    Execute Immediate v_Sql
      Using n_Rec_Id;
  
    --以"医嘱ID,发送号"为外键的，都按医嘱ID直接转回，只需要排在"病人医嘱发送"之后即可
    --由于外键关系，"报告查阅记录"须在"病人医嘱报告"后面
    For P In (Select Column_Value
              From Table(f_Str2list('病人医嘱计价,病人医嘱状态,病人医嘱发送,病人医嘱附费,病人医嘱附件,病人医嘱执行,病人医嘱打印,输血申请记录,输血检验结果,输血申请项目,' ||
                                     '医嘱执行打印,医嘱执行时间,医嘱执行计价,执行打印记录,病人诊断医嘱,病人路径医嘱,病人门诊路径医嘱,病人医嘱报告,报告查阅记录,' ||
                                     '影像报告驳回,影像报告记录,影像报告操作记录,影像检查记录,影像申请单图像,影像收藏内容,影像危急值记录,检验标本记录,检验试剂记录,检验拒收记录,RIS检查预约,疾病阳性记录,医嘱申请单文件,病人危急值记录'))) Loop
      v_Table := p.Column_Value;
      If Instr('病人路径医嘱,病人门诊路径医嘱', v_Table) > 0 Then
        v_Field := '病人医嘱ID';
      Else
        v_Field := '医嘱ID';
      End If;
    
      v_Fields := Getfields(v_Table);
      v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                  Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table || ' Where ' || v_Field || ' = :1';
      If v_Table = '病人医嘱状态' Or v_Table = '病人医嘱报告' Then
        v_Sqlchild := v_Sql;
      Else
        Execute Immediate v_Sql
          Using n_Rec_Id;
      End If;
    
      If v_Table = '病人医嘱状态' Then
        v_Fields := Getfields('医嘱签名记录');
        v_Sql    := 'Insert Into 医嘱签名记录(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                    ' From H医嘱签名记录 Where ID In (Select 签名id From H病人医嘱状态 Where 医嘱id = :1 And 签名id Is Not Null)';
        Execute Immediate v_Sql
          Using n_Rec_Id;
      
        Delete H医嘱签名记录
        Where ID In (Select 签名id From H病人医嘱状态 Where 医嘱id = n_Rec_Id And 签名id Is Not Null);
      
        Execute Immediate v_Sqlchild
          Using n_Rec_Id;
      
      Elsif v_Table = '病人医嘱发送' Then
        v_Fields := Getfields('诊疗单据打印');
        v_Sql    := 'Insert Into 诊疗单据打印(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                    ' From H诊疗单据打印 Where (NO, 记录性质) In (Select NO, 记录性质 From H病人医嘱发送 Where 医嘱id = :1)';
        Execute Immediate v_Sql
          Using n_Rec_Id;
        Delete H诊疗单据打印 Where (NO, 记录性质) In (Select NO, 记录性质 From H病人医嘱发送 Where 医嘱id = n_Rec_Id);
      
      Elsif v_Table = '影像检查记录' Then
        v_Fields := Getfields('影像检查序列');
        v_Sql    := 'Insert Into 影像检查序列(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                    ' From H影像检查序列 Where 检查uid In (Select 检查uid From H影像检查记录 Where 医嘱id = :1)';
        Execute Immediate v_Sql
          Using n_Rec_Id;
      
        v_Fields := Getfields('影像检查图象');
        v_Sql    := 'Insert Into 影像检查图象(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                    ' From H影像检查图象 Where 序列uid In (Select b.序列uid From H影像检查记录 A, H影像检查序列 B Where a.医嘱id = :1 And a.检查uid = b.检查uid)';
        Execute Immediate v_Sql
          Using n_Rec_Id;
      
        Delete H影像检查图象
        Where 序列uid In (Select b.序列uid
                        From H影像检查记录 A, H影像检查序列 B
                        Where a.医嘱id = n_Rec_Id And a.检查uid = b.检查uid);
        Delete H影像检查序列 Where 检查uid In (Select 检查uid From H影像检查记录 Where 医嘱id = n_Rec_Id);
      
      Elsif v_Table = '检验标本记录' Then
        For R In (Select Column_Value
                  From Table(f_Str2list('检验申请项目,检验分析记录,检验项目分布,检验质控记录,检验操作记录,检验签名记录,检验图像结果'))) Loop
          v_Subtable := r.Column_Value;
          If v_Subtable = '检验签名记录' Then
            v_Subfield := '检验标本ID';
          Else
            v_Subfield := '标本ID';
          End If;
          v_Fields := Getfields(v_Subtable);
          v_Sql    := 'Insert Into ' || v_Subtable || '(' || v_Fields || ') Select ' ||
                      Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Subtable || ' Where ' || v_Subfield ||
                      ' In (Select ID From H检验标本记录 Where 医嘱id = :1)';
          Execute Immediate v_Sql
            Using n_Rec_Id;
        
          v_Sql := 'Delete H' || v_Subtable || ' Where ' || v_Subfield ||
                   ' In (Select ID From H检验标本记录 Where 医嘱id = :1)';
          Execute Immediate v_Sql
            Using n_Rec_Id;
        End Loop;
      
        v_Fields := Getfields('检验普通结果');
        v_Sql    := 'Insert Into 检验普通结果(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                    ' From H检验普通结果 Where 检验标本id In (Select ID From H检验标本记录 Where 医嘱id = :1)';
        Execute Immediate v_Sql
          Using n_Rec_Id;
      
        v_Fields := Getfields('检验药敏结果');
        v_Sql    := 'Insert Into 检验药敏结果(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                    ' From H检验药敏结果 Where 细菌结果id In (Select ID From H检验普通结果 Where 检验标本id In (Select ID From H检验标本记录 Where 医嘱id = :1))';
        Execute Immediate v_Sql
          Using n_Rec_Id;
      
        v_Fields := Getfields('检验质控报告');
        v_Sql    := 'Insert Into 检验质控报告(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                    ' From H检验质控报告 Where 结果ID In (Select ID From H检验普通结果 Where 检验标本id In (Select ID From H检验标本记录 Where 医嘱id = :1))';
        Execute Immediate v_Sql
          Using n_Rec_Id;
      
        Delete H检验药敏结果
        Where 细菌结果id In
              (Select ID From H检验普通结果 Where 检验标本id In (Select ID From H检验标本记录 Where 医嘱id = n_Rec_Id));
        Delete H检验质控报告
        Where 结果id In
              (Select ID From H检验普通结果 Where 检验标本id In (Select ID From H检验标本记录 Where 医嘱id = n_Rec_Id));
      
        Delete H检验普通结果 Where 检验标本id In (Select ID From H检验标本记录 Where 医嘱id = n_Rec_Id);
      Elsif v_Table = '病人医嘱报告' Then
        v_Fields := Getfields('医嘱报告内容');
        v_Sql    := 'Insert Into 医嘱报告内容(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                    ' From H医嘱报告内容 Where ID In (Select 报告id From H病人医嘱报告 Where 医嘱id = :1 And 报告id Is Not Null)';
        Execute Immediate v_Sql
          Using n_Rec_Id;
      
        Delete H医嘱报告内容
        Where ID In (Select 报告id From H病人医嘱报告 Where 医嘱id = n_Rec_Id And 报告id Is Not Null);
      
        Execute Immediate v_Sqlchild
          Using n_Rec_Id;
      Elsif v_Table = '病人危急值记录' Then
      
        v_Fields := Getfields('病人危急值病历');
        v_Sql    := 'Insert Into 病人危急值病历(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                    ' From H病人危急值病历 Where 危急值id In (Select ID From H病人危急值记录 Where 医嘱id = :1)';
        Execute Immediate v_Sql
          Using n_Rec_Id;      
        Delete H病人危急值病历 Where 危急值id In (Select ID From H病人危急值记录 Where 医嘱id = n_Rec_Id);
                
        v_Fields := Getfields('病人危急值医嘱');
        v_Sql    := 'Insert Into 病人危急值医嘱(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                    ' From H病人危急值医嘱 Where 危急值id In (Select ID From H病人危急值记录 Where 医嘱id = :1)';
        Execute Immediate v_Sql
          Using n_Rec_Id;
      
        Delete H病人危急值医嘱 Where 危急值id In (Select ID From H病人危急值记录 Where 医嘱id = n_Rec_Id);
         
      End If;
    
      v_Sql := 'Delete H' || v_Table || ' Where ' || v_Field || ' = :1';
      Execute Immediate v_Sql
        Using n_Rec_Id;
    End Loop;
  
    --手麻数据
    If n_Opersystem > 0 Then
      Execute Immediate 'Call zl24_Retu_Oper(:1)'
        Using n_Rec_Id;
    End If;
  
    Delete H病人医嘱记录 Where ID = n_Rec_Id;
  End Zl_Retu_Order;

  --------------------------------------------
  --返回指定挂号单的(病人挂号记录\病人医嘱记录\电子病历记录\病人转诊记录)
  --------------------------------------------
  Procedure Zl_Retu_Outclinic(v_Times H病人挂号记录.No%Type) As
  Begin
    v_Table  := '病人挂号记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                ' From H' || v_Table || ' Where NO =:1 ';
    Execute Immediate v_Sql
      Using v_Times;
  
    For r_Other In (Select ID, 病人id From H病人挂号记录 Where NO = v_Times) Loop
      Zl_Retu_Other(r_Other.病人id, r_Other.Id);
    End Loop;
  
    For r_Epr In (Select b.Id
                  From H病人挂号记录 A, H电子病历记录 B
                  Where a.No = v_Times And a.病人id = n_Patiid And b.病人id = a.病人id And b.主页id = a.Id) Loop
      Zl_Retu_Epr(r_Epr.Id);
    End Loop;
  
    For r_Order In (Select ID From H病人医嘱记录 Where 病人来源 <> 4 And 病人id = n_Patiid And 挂号单 = v_Times) Loop
      Zl_Retu_Order(r_Order.Id);
    End Loop;
  
    --转诊记录
    v_Table  := '病人转诊记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                ' From H' || v_Table || ' Where NO =:1';
    Execute Immediate v_Sql
      Using v_Times;
  
    Delete H病人转诊记录 Where NO = v_Times;
    Delete H病人挂号记录 Where NO = v_Times;
  End Zl_Retu_Outclinic;
  --------------------------------------------
  --以下为主程序体
  --------------------------------------------
Begin
  ----------------------------------------------------------------------------------------------------------
  --对基于视图的转储方案进行了只读判断.
  Select 编号 Into n_System From zlSystems Where Upper(所有者) = Zl_Owner And 编号 Like '1%';
  Begin
    Select Nvl(只读, 0) Into n_只读 From zlBakSpaces Where 系统 = n_System And 当前 = 1;
  Exception
    When Others Then
      v_Err_Msg := '[ZLSOFT]当前没有可用的历史数据空间,不能继续![ZLSOFT]';
      Raise Err_Item;
  End;
  If n_只读 = 1 Then
    v_Err_Msg := '[ZLSOFT]历史数据空间目前的状态为只读,不能继续![ZLSOFT]';
    Raise Err_Item;
  End If;

  Select Max(Db连接) Into v_Dblink From zlBakSpaces Where 系统 = 100 And 当前 = 1;

  --对基于视图的转储方案进行了只读判断.
  n_Opersystem := 0;
  Select 编号 Into n_Opersystem From zlSystems Where Upper(所有者) = Zl_Owner And 编号 Like '24%';
  If n_Opersystem > 0 Then
    Begin
      Select Nvl(只读, 0) Into n_只读 From zlBakSpaces Where 系统 = n_Opersystem And 当前 = 1;
    Exception
      When Others Then
        v_Err_Msg := '[ZLSOFT]当前没有可用的手麻子系统历史数据空间,不能继续![ZLSOFT]';
        Raise Err_Item;
    End;
    If n_只读 = 1 Then
      v_Err_Msg := '[ZLSOFT]手麻子系统历史数据空间目前的状态为只读,不能继续![ZLSOFT]';
      Raise Err_Item;
    End If;
  End If;

  --1.门诊病人，按挂号单抽回
  If n_Flag = 0 Then
    --抽回未结记帐费用
    Zl_Retu_Exes(n_Patiid, 8);
    --存在门诊临床路径数据，将所有就诊数据抽回
    Select Count(1) Into n_Count From H病人门诊路径记录 A, H病人挂号记录 B Where b.Id = a.挂号id And b.No = v_Times;
    If n_Count = 0 Then
      Zl_Retu_Outclinic(v_Times);
    Else
      For R In (Select Distinct b.No
                From H病人门诊路径记录 A, H病人挂号记录 B
                Where a.挂号id = b.Id And
                      a.路径记录id In (Select a.路径记录id
                                   From H病人门诊路径记录 A, H病人挂号记录 B
                                   Where b.Id = a.挂号id And b.No = v_Times)) Loop
        Zl_Retu_Outclinic(r.No);
      End Loop;
      For R In (Select ID From 病人挂号记录 Where NO = v_Times) Loop
        Zl_Retu_Pathout(r.Id);
      End Loop;
    End If;
  
    --2.住院病人，按病人ID和主页ID抽回
  Elsif n_Flag = 1 Then
    --抽回未结记帐费用
    Zl_Retu_Exes(n_Patiid || ',' || v_Times, 8);
  
    Zl_Retu_Other(n_Patiid, To_Number(v_Times));
    Zl_Retu_Path(n_Patiid, To_Number(v_Times));
  
    --先转病历，再转医嘱（影像报告驳回，病人医嘱报告这类又有病历又有医嘱的子表，在医嘱转回后处理）
    For r_Epr In (Select ID From H电子病历记录 Where 病人id = n_Patiid And 主页id = To_Number(v_Times)) Loop
      Zl_Retu_Epr(r_Epr.Id);
    End Loop;
  
    Zl_Retu_Tend(n_Patiid, To_Number(v_Times));
  
    For r_Order In (Select ID From H病人医嘱记录 Where 病人id = n_Patiid And 主页id = To_Number(v_Times)) Loop
      Zl_Retu_Order(r_Order.Id);
    End Loop;
  
    Update 病案主页 Set 数据转出 = 0 Where 病人id = n_Patiid And 主页id = To_Number(v_Times);
  
    --3.体检病人
  Elsif n_Flag = 2 Then
    Zl_Retu_Other(n_Patiid, v_Times);
  
    For r_Cpr In (Select ID From H病人医嘱记录 Where 病人来源 = 4 And 挂号单 = v_Times) Loop
      Zl_Retu_Order(r_Cpr.Id);
    End Loop;
  
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM || ':' || v_Sql);
End Zl_Retu_Clinic;
/

--117925:刘涛,2017-12-08,排除导致死锁处理
Create Or Replace Procedure Zl_材料领用_Delete(
                                           --删除药品收发记录及恢复相应的表：药品库存
                                           No_In In 药品收发记录.No%Type) Is
  Err_Item Exception;
  v_Err_Msg Varchar2(100);

  n_实价卫材 收费项目目录.是否变价%Type;
  v_下库存   Zlparameters.参数值%Type;
Begin
  Select To_Number(Nvl(Zl_Getsysparameter(95), '0')) Into v_下库存 From Dual;

  If v_下库存 = 1 Then
    --通过循环，恢复原来的可用数量
    For v_单据 In (Select ID, 填写数量, 库房id, 零售价, 批次, 批号, 药品id, 供药单位id, 成本价, 效期, 灭菌效期, 产地, 生产日期, 批准文号
                 From 药品收发记录
                 Where NO = No_In And 单据 = 20 And 入出系数 = -1
                 Order By 药品id, 批次) Loop
      Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = v_单据.药品id;
    
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) + v_单据.填写数量
      Where 库房id = v_单据.库房id And 药品id = v_单据.药品id And Nvl(批次, 0) = Nvl(v_单据.批次, 0) And 性质 = 1;
    
      If Sql%NotFound Then
      
        Insert Into 药品库存
          (库房id, 药品id, 批次, 性质, 可用数量, 效期, 灭菌效期, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 批准文号, 零售价)
        Values
          (v_单据.库房id, v_单据.药品id, v_单据.批次, 1, v_单据.填写数量, v_单据.效期, v_单据.灭菌效期, v_单据.供药单位id, v_单据.成本价, v_单据.批号, v_单据.生产日期,
           v_单据.产地, v_单据.批准文号, Decode(n_实价卫材, 1, Decode(Nvl(v_单据.批次, 0), 0, Null, v_单据.零售价), Null));
      End If;
    
      Delete From 药品库存
      Where 库房id = v_单据.库房id And 药品id = v_单据.药品id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
            Nvl(实际差价, 0) = 0;
      Delete From 材料领用信息 Where 收发id = v_单据.Id;
    End Loop;
  End If;

  Delete From 药品收发记录 Where NO = No_In And 单据 = 20 And 记录状态 = 1 And 审核人 Is Null;

  If Sql%RowCount = 0 Then
    v_Err_Msg := '[ZLSOFT]该单据已经被他人删除或已被人审核！[ZLSOFT]';
    Raise Err_Item;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料领用_Delete;
/

--117925:刘涛,2017-12-08,排序导致死锁处理
--105711:李业庆,2018-01-03,出库库存平均成本价处理
Create Or Replace Procedure Zl_材料其他入库_Verify
(
  No_In     In 药品收发记录.No%Type := Null,
  审核人_In In 药品收发记录.审核人%Type := Null
) Is
  Err_Item Exception;
  v_Err_Msg Varchar2(500);

  n_实价卫材    收费项目目录.是否变价%Type;
  n_Batch_Count Integer; --原不分批现在分批的材料的数量
  v_条码前缀    Varchar2(20);
  v_内部条码    药品库存.内部条码%Type;
  n_平均成本价  药品库存.平均成本价%Type;
Begin
  v_条码前缀 := Nvl(zl_GetSysParameter(159), '');

  Update 药品收发记录
  Set 审核人 = 审核人_In, 审核日期 = Sysdate
  Where NO = No_In And 单据 = 17 And 记录状态 = 1 And 审核人 Is Null;

  If Sql%RowCount = 0 Then
    v_Err_Msg := '[ZLSOFT]该单据已经被他人审核！[ZLSOFT]';
    Raise Err_Item;
  End If;

  --主要针对原不分批现在分批的材料，不能对其审核
  Select Count(*)
  Into n_Batch_Count
  From 药品收发记录 A, 材料特性 B
  Where a.药品id = b.材料id And a.No = No_In And a.单据 = 17 And a.记录状态 = 1 And Nvl(a.批次, 0) = 0 And
        ((Nvl(b.库房分批, 0) = 1 And
        a.库房id Not In (Select 部门id From 部门性质说明 Where (工作性质 Like '发料部门') Or (工作性质 Like '制剂室'))) Or Nvl(b.在用分批, 0) = 1);

  If n_Batch_Count > 0 Then
    v_Err_Msg := '[ZLSOFT]该单据中包含有一条原来不分批，现在分批的材料，不能审核！[ZLSOFT';
    Raise Err_Item;
  End If;

  --原分批现不分批的材料,在审核时，要处理他
  Update 药品收发记录
  Set 批次 = 0
  Where ID =
        (Select ID
         From 药品收发记录 A, 材料特性 B
         Where b.材料id = a.药品id And a.No = No_In And a.单据 = 17 And a.记录状态 = 1 And Nvl(a.批次, 0) > 0 And
               (Nvl(b.库房分批, 0) = 0 Or
               (Nvl(b.在用分批, 0) = 0 And
               a.库房id In (Select 部门id From 部门性质说明 Where (工作性质 Like '发料部门') Or (工作性质 Like '制剂室')))));

  For c_收发 In (Select a.Id, a.实际数量, a.零售价, a.零售金额, a.差价, a.库房id, a.药品id, a.批次, a.成本价, a.批号, a.效期, a.灭菌效期, a.灭菌日期, a.产地,
                      a.入出类别id, a.生产日期, a.商品条码, a.内部条码, Nvl(b.是否条码管理, 0) As 条码管理, a.批准文号
               From 药品收发记录 A, 材料特性 B
               Where a.药品id = b.材料id And a.No = No_In And a.单据 = 17 And a.记录状态 = 1
               Order By a.药品id, a.批次) Loop
  
    v_内部条码 := Null;
    If c_收发.条码管理 = 1 Then
      If Not v_条码前缀 Is Null Then
        v_内部条码 := v_条码前缀 || Nextno(126);
      Else
        v_内部条码 := Nextno(126);
      End If;
    End If;
  
    --更改药品库存表的相应数据
    Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = c_收发.药品id;
  
    Update 药品库存
    Set 可用数量 = Nvl(可用数量, 0) + Nvl(c_收发.实际数量, 0), 实际数量 = Nvl(实际数量, 0) + Nvl(c_收发.实际数量, 0),
        实际金额 = Nvl(实际金额, 0) + Nvl(c_收发.零售金额, 0), 实际差价 = Nvl(实际差价, 0) + Nvl(c_收发.差价, 0), 上次采购价 = Nvl(c_收发.成本价, 上次采购价),
        上次批号 = Nvl(c_收发.批号, 上次批号), 上次生产日期 = Nvl(c_收发.生产日期, 上次生产日期), 上次产地 = Nvl(c_收发.产地, 上次产地), 效期 = Nvl(c_收发.效期, 效期),
        灭菌效期 = Nvl(c_收发.灭菌效期, 灭菌效期), 零售价 = Decode(Nvl(c_收发.批次, 0), 0, Null, Decode(n_实价卫材, 1, c_收发.零售价, Null)),
        商品条码 = c_收发.商品条码, 内部条码 = v_内部条码, 批准文号 = c_收发.批准文号
    Where 库房id = c_收发.库房id And 药品id = c_收发.药品id And Nvl(批次, 0) = Nvl(c_收发.批次, 0) And 性质 = 1;
  
    If Sql%NotFound Then
      Insert Into 药品库存
        (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次采购价, 上次批号, 上次生产日期, 上次产地, 效期, 灭菌效期, 零售价, 商品条码, 内部条码, 平均成本价, 批准文号)
      Values
        (c_收发.库房id, c_收发.药品id, c_收发.批次, 1, c_收发.实际数量, c_收发.实际数量, c_收发.零售金额, c_收发.差价, c_收发.成本价, c_收发.批号, c_收发.生产日期,
         c_收发.产地, c_收发.效期, c_收发.灭菌效期, Decode(Nvl(c_收发.批次, 0), 0, Null, Decode(n_实价卫材, 1, c_收发.零售价, Null)), c_收发.商品条码,
         v_内部条码, c_收发.成本价, c_收发.批准文号);
    End If;
  
    Zl_未审药品记录_Delete(c_收发.Id);
  
    Delete From 药品库存
    Where 库房id = c_收发.库房id And 药品id = c_收发.药品id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
          Nvl(实际差价, 0) = 0;
  
    If Not v_内部条码 Is Null Then
      Update 药品收发记录 Set 内部条码 = v_内部条码 Where ID = c_收发.Id;
    End If;
  
    --更新该材料的成本价
    Update 材料特性 Set 成本价 = c_收发.成本价, 上次售价 = c_收发.零售价 Where 材料id = c_收发.药品id;
  
    --不分批入库时才重新计算库存表中的平均成本价
    If Nvl(c_收发.批次, 0) = 0 Then
      Update 药品库存
      Set 平均成本价 = Decode(Nvl(批次, 0), 0, Decode((实际金额 - 实际差价) / 实际数量, 0, 上次采购价, (实际金额 - 实际差价) / 实际数量), 上次采购价)
      Where 药品id = c_收发.药品id And Nvl(批次, 0) = Nvl(c_收发.批次, 0) And 库房id = c_收发.库房id And Nvl(实际数量, 0) <> 0 And 性质 = 1;
      If Sql%NotFound Then
        Select 成本价 Into n_平均成本价 From 材料特性 Where 材料id = c_收发.药品id;
        Update 药品库存
        Set 平均成本价 = n_平均成本价
        Where 药品id = c_收发.药品id And 库房id = c_收发.库房id And Nvl(批次, 0) = Nvl(c_收发.批次, 0) And 性质 = 1;
      End If;
    End If;
  
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料其他入库_Verify;
/

--117925:刘涛,2017-12-07,排序导致死锁处理
Create Or Replace Procedure Zl_材料申领_Delete(No_In In 药品收发记录.NO%Type) Is
  Err_Item Exception;
  v_Err_Msg  Varchar2(500);
  v_下库存   zlParameters.参数值%Type;
  v_明确批次 zlParameters.参数值%Type;
  d_发送日期 药品收发记录.配药日期%Type;
  n_实价卫材 收费项目目录.是否变价%Type;

Begin
  Select Nvl(zl_GetSysParameter(95), '0') Into v_下库存 From Dual;

  --只有在明确批次的情况下才能下可用库存
  Select Nvl(zl_GetSysParameter(83), '0') Into v_明确批次 From Dual;

  --检查是否已经发料或审核
  Select 配药日期 Into d_发送日期 From 药品收发记录 Where 单据 = 19 And NO = No_In And Rownum < 2;

  If d_发送日期 Is Not Null Then
    v_Err_Msg := '[ZLSOFT]该申领单已经被他人发料,不能进行删除![ZLSOFT]';
    Raise Err_Item;
  End If;

  If To_Number(v_下库存, '9999') = 1 And To_Number(v_明确批次, '9999') = 1 Then
    --需要还原可用库存
    --通过循环，恢复原来的可用数量
    For v_单据 In (Select 实际数量, 库房id, 批次, 药品id, 零售价, 批号, 效期, 产地, 供药单位id, 成本价, 生产日期,
                          批准文号, 灭菌效期
                   From 药品收发记录
                   Where NO = No_In And 单据 = 19 And 入出系数 = -1
                   Order By 药品id, 批次) Loop
      Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = v_单据.药品id;

      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) + v_单据.实际数量
      Where 库房id = v_单据.库房id And 药品id = v_单据.药品id And Nvl(批次, 0) = Nvl(v_单据.批次, 0) And 性质 = 1;

      If Sql%NotFound Then

        Insert Into 药品库存
          (库房id, 药品id, 批次, 性质, 可用数量, 效期, 灭菌效期, 上次供应商id, 上次采购价, 上次批号, 上次生产日期,
           上次产地, 批准文号, 零售价)
        Values
          (v_单据.库房id, v_单据.药品id, v_单据.批次, 1, v_单据.实际数量, v_单据.效期, v_单据.灭菌效期,
           v_单据.供药单位id, v_单据.成本价, v_单据.批号, v_单据.生产日期, v_单据.产地, v_单据.批准文号,
           Decode(n_实价卫材, 1, Decode(Nvl(v_单据.批次, 0), 0, Null, v_单据.零售价), Null));
      End If;

      Delete From 药品库存
      Where 库房id = v_单据.库房id And 药品id = v_单据.药品id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And
            Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0;
    End Loop;
  End If;

  Delete 药品收发记录 Where NO = No_In And 单据 = 19 And 记录状态 = 1 And 审核人 Is Null;

  If Sql%NotFound Then
    v_Err_Msg := '[ZLSOFT]该单据已经被他人删除或已被人审核！[ZLSOFT]';
    Raise Err_Item;
  End If;
Exception

  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料申领_Delete;
/

--117925:刘涛,2017-12-07,排序导致死锁处理
Create Or Replace Procedure Zl_材料盘点_Strike
(
  No_In     In 药品收发记录.No%Type,
  审核人_In In 药品收发记录.审核人%Type
) Is
  Err_Item Exception;
  v_Err_Msg Varchar2(255);

  n_Batch_Count Integer; --原不分批现在分批的材料的数量
  n_Count       Integer; --原分批现不分批

  n_批次       药品收发记录.批次%Type;
  n_成本价     药品收发记录.成本价%Type;
  n_材料id     药品收发记录.药品id%Type;
  n_实价卫材   收费项目目录.是否变价%Type;
  n_平均成本价 药品库存.平均成本价%Type;
  
Begin
  Update 药品收发记录 Set 记录状态 = 3 Where NO = No_In And 单据 = 22 And 记录状态 = 1;

  If Sql%RowCount = 0 Then
    v_Err_Msg := '[ZLSOFT]该单据已经被他人冲销！[ZLSOFT]';
    Raise Err_Item;
  End If;

  --主要针对原不分批现在分批的材料，不能对其审核
  Select Count(*), Max(a.药品id)
  Into n_Batch_Count, n_材料id
  From 药品收发记录 A, 材料特性 B
  Where a.药品id = b.材料id And a.No = No_In And a.单据 = 22 And a.记录状态 = 3 And Nvl(a.批次, 0) = 0 And
        ((Nvl(b.库房分批, 0) = 1 And
        a.库房id Not In (Select 部门id From 部门性质说明 Where (工作性质 Like '发料部门') Or (工作性质 Like '制剂室'))) Or Nvl(b.在用分批, 0) = 1);

  If n_Batch_Count > 0 Then
    Begin
      Select 编码 || '-' || 名称 Into v_Err_Msg From 收费项目目录 Where ID = n_材料id;
    Exception
      When Others Then
        Null;
    End;
    v_Err_Msg := '[ZLSOFT]该单据中材料为:' || v_Err_Msg || Chr(10) || Chr(13) || '的材料,原来不分批,而现在分批，因此不能审核！[ZLSOFT]';
    Raise Err_Item;
  End If;
  
  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 灭菌效期, 填写数量, 扣率, 实际数量, 成本价, 成本金额, 零售价, 零售金额, 差价, 摘要,
     填制人, 填制日期, 审核人, 审核日期, 频次, 供药单位id, 生产日期, 批准文号, 单量)
    Select 药品收发记录_Id.Nextval, 2, 单据, NO, 序号, 库房id, 入出类别id, 入出系数, a.药品id,
           Decode(Nvl(a.批次, 0), 0, Null, (Decode(Nvl(b.库房分批, 0), 0, Null, a.批次))), a.产地, 批号, a.效期, a.灭菌效期, 填写数量, a.扣率,
           -实际数量, a.成本价, 成本金额, 零售价, -零售金额, -差价, 摘要, 审核人_In, Sysdate, 审核人_In, Sysdate, a.频次, a.供药单位id, a.生产日期, a.批准文号,
           a.单量
    From 药品收发记录 A, 材料特性 B
    Where NO = No_In And a.药品id = b.材料id And 单据 = 22 And 记录状态 = 3;
  
  For c_单据 In (Select ID, 实际数量, 零售价, 零售金额, 差价, 库房id, 药品id 材料id, 批次, 批号, 效期, 灭菌效期, 产地, 入出类别id, 入出系数, 供药单位id, 生产日期, 批准文号,
                      单量
               From 药品收发记录
               Where NO = No_In And 单据 = 22 And 记录状态 = 2
               Order By 药品id, 批次) Loop
    Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = c_单据.材料id;
  
    --原分批现不分批的材料,在C冲消时，要处理他
    Begin
      Select Count(*)
      Into n_Count
      From 药品收发记录 A, 材料特性 B
      Where b.材料id + 0 = c_单据.材料id And a.No = No_In And a.药品id = b.材料id And a.单据 = 22 And a.库房id + 0 = c_单据.库房id And
            a.记录状态 = 3 And Nvl(a.批次, 0) > 0 And
            (Nvl(b.库房分批, 0) = 0 Or
            (Nvl(b.在用分批, 0) = 0 And
            a.库房id In (Select 部门id From 部门性质说明 Where (工作性质 Like '发料部门') Or (工作性质 Like '制剂室'))));
    Exception
      When Others Then
        n_Count := 0;
    End;
    If n_Count > 0 Then
      n_批次 := 0;
    Else
      n_批次 := Nvl(c_单据.批次, 0);
    End If;
  
    --更改药品库存表的相应数据
    Update 药品库存
    Set 可用数量 = Nvl(可用数量, 0) + Nvl(c_单据.实际数量, 0) * c_单据.入出系数, 实际数量 = Nvl(实际数量, 0) + Nvl(c_单据.实际数量, 0) * c_单据.入出系数,
        实际金额 = Nvl(实际金额, 0) + Nvl(c_单据.零售金额, 0) * c_单据.入出系数, 实际差价 = Nvl(实际差价, 0) + Nvl(c_单据.差价, 0) * c_单据.入出系数,
        零售价 = Decode(n_实价卫材, 1, Decode(Nvl(n_批次, 0), 0, Null, Decode(Nvl(零售价, 0), 0, c_单据.零售价, 零售价)), Null)
    Where 库房id = c_单据.库房id And 药品id = c_单据.材料id And Nvl(批次, 0) = n_批次 And 性质 = 1;
  
    If Sql%NotFound Then
      If Nvl(c_单据.实际数量, 0) <> 0 Then
        n_成本价 := Round((Nvl(c_单据.零售金额, 0) - Nvl(c_单据.差价, 0)) / c_单据.实际数量, 7);
      Else
        n_成本价 := 0;
      End If;
      Insert Into 药品库存
        (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 效期, 灭菌效期, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 批准文号, 零售价, 平均成本价)
      
      Values
        (c_单据.库房id, c_单据.材料id, n_批次, 1, c_单据.实际数量 * c_单据.入出系数, c_单据.实际数量 * c_单据.入出系数, c_单据.零售金额 * c_单据.入出系数,
         c_单据.差价 * c_单据.入出系数, c_单据.效期, c_单据.灭菌效期, c_单据.供药单位id, n_成本价, c_单据.批号, c_单据.生产日期, c_单据.产地, c_单据.批准文号,
         Decode(n_实价卫材, 1, Decode(Nvl(c_单据.批次, 0), 0, Null, c_单据.零售价), Null), n_成本价);
    End If;
  
    Delete From 药品库存
    Where 库房id = c_单据.库房id And 药品id = c_单据.材料id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
          Nvl(实际差价, 0) = 0;
    Zl_材料收发记录_调价修正(c_单据.Id);
  
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料盘点_Strike;
/

--117925:刘涛,2017-12-07,排序导致死锁处理
--105711:李业庆,2018-01-03,出库库存平均成本价处理
Create Or Replace Procedure Zl_材料盘点_Verify
(
  No_In     In 药品收发记录.No%Type := Null,
  审核人_In In 药品收发记录.审核人%Type := Null
) Is
  Err_Item Exception;
  v_Err_Msg Varchar2(200);

  n_成本价      药品收发记录.成本价%Type;
  n_材料id      药品收发记录.药品id%Type;
  n_实价卫材    收费项目目录.是否变价%Type;
  n_平均成本价  药品库存.平均成本价%Type;
  v_下库存      Zlparameters.参数值%Type;
  n_Batch_Count Integer; --原不分批现在分批的材料的数量
  n_可用数量    药品收发记录.实际数量%Type;

Begin
  Select To_Number(Nvl(zl_GetSysParameter(95), '0')) Into v_下库存 From Dual;

  Update 药品收发记录
  Set 审核人 = 审核人_In, 审核日期 = Sysdate
  Where NO = No_In And 单据 = 22 And 记录状态 = 1 And 审核人 Is Null;

  If Sql%RowCount = 0 Then
    v_Err_Msg := '[ZLSOFT]该单据已经被他人审核！[ZLSOFT]';
    Raise Err_Item;
  End If;

  For c_单据 In (Select ID, 实际数量, 零售价, 零售金额, 差价, 库房id, 药品id 材料id, 批次, 批号, 效期, 灭菌效期, 产地, 入出类别id, 入出系数, 供药单位id, 生产日期, 批准文号
               From 药品收发记录
               Where NO = No_In And 单据 = 22 And 记录状态 = 1
               Order By 材料id, 批次) Loop
  
    Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = c_单据.材料id;
    If v_下库存 = 1 Then
      If c_单据.入出系数 = -1 Then
        n_可用数量 := 0;
      Else
        n_可用数量 := Nvl(c_单据.实际数量, 0);
      End If;
    Else
      n_可用数量 := Nvl(c_单据.实际数量, 0) * c_单据.入出系数;
    End If;
  
    If Nvl(c_单据.实际数量, 0) <> 0 Then
      n_成本价 := Round((Nvl(c_单据.零售金额, 0) - Nvl(c_单据.差价, 0)) / c_单据.实际数量, 7);
    Else
      n_成本价 := 0;
    End If;
  
    --更改药品库存表的相应数据
    Update 药品库存
    Set 可用数量 = Nvl(可用数量, 0) + n_可用数量, 实际数量 = Nvl(实际数量, 0) + Nvl(c_单据.实际数量, 0) * c_单据.入出系数,
        实际金额 = Nvl(实际金额, 0) + Nvl(c_单据.零售金额, 0) * c_单据.入出系数, 实际差价 = Nvl(实际差价, 0) + Nvl(c_单据.差价, 0) * c_单据.入出系数,
        零售价 = Decode(n_实价卫材, 1, Decode(Nvl(c_单据.批次, 0), 0, Null, Decode(Nvl(零售价, 0), 0, c_单据.零售价, 零售价)), Null),
        上次批号 = c_单据.批号, 上次产地 = c_单据.产地, 效期 = c_单据.效期
    Where 库房id = c_单据.库房id And 药品id = c_单据.材料id And Nvl(批次, 0) = Nvl(c_单据.批次, 0) And 性质 = 1;
  
    If Sql%NotFound Then
      Insert Into 药品库存
        (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 效期, 灭菌效期, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 批准文号, 零售价, 平均成本价)
      
      Values
        (c_单据.库房id, c_单据.材料id, c_单据.批次, 1, n_可用数量, c_单据.实际数量 * c_单据.入出系数, c_单据.零售金额 * c_单据.入出系数, c_单据.差价 * c_单据.入出系数,
         c_单据.效期, c_单据.灭菌效期, c_单据.供药单位id, n_成本价, c_单据.批号, c_单据.生产日期, c_单据.产地, c_单据.批准文号,
         Decode(n_实价卫材, 1, Decode(Nvl(c_单据.批次, 0), 0, Null, c_单据.零售价), Null), n_成本价);
    End If;
  
    Zl_未审药品记录_Delete(c_单据.Id);
  
    Delete From 药品库存
    Where 库房id = c_单据.库房id And 药品id = c_单据.材料id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
          Nvl(实际差价, 0) = 0;
  
    --平均价为空时重新计算平均成本价
    Update 药品库存
    Set 平均成本价 = n_成本价
    Where 库房id = c_单据.库房id And 药品id = c_单据.材料id And Nvl(批次, 0) = Nvl(c_单据.批次, 0) And 性质 = 1 And Nvl(平均成本价, 0) = 0;
  
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料盘点_Verify;
/

--117925:刘涛,2017-12-07,排序导致死锁处理
Create Or Replace Procedure Zl_材料盘点_Delete(
                                           
                                           --删除药品收发记录及恢复相应的表：药品库存
                                           No_In In 药品收发记录.No%Type) Is
  Err_Item Exception;
  v_Err_Msg  Varchar2(100);
  n_成本价   药品收发记录.成本价%Type;
  n_实价卫材 收费项目目录.是否变价%Type;
  v_下库存   Zlparameters.参数值%Type;
Begin
  --通过循环，恢复出库类别原来的可用数量，
  --实际数量保存的是数量差
  Select To_Number(Nvl(Zl_Getsysparameter(95), '0')) Into v_下库存 From Dual;

  If v_下库存 = 1 Then
    For c_单据 In (Select 实际数量, 库房id, 批次, 药品id 材料id, 零售价, 供药单位id, 零售金额, 差价, 效期, 灭菌效期, 产地, 批号, 生产日期, 批准文号
                 From 药品收发记录
                 Where NO = No_In And 单据 = 22 And 入出系数 = -1
                 Order By 药品id, 批次) Loop
      Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = c_单据.材料id;
    
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) + c_单据.实际数量,
          零售价 = Decode(n_实价卫材, 1, Decode(Nvl(c_单据.批次, 0), 0, Null, Decode(Nvl(零售价, 0), 0, c_单据.零售价, 零售价)), Null)
      Where 库房id = c_单据.库房id And 药品id = c_单据.材料id And Nvl(批次, 0) = Nvl(c_单据.批次, 0) And 性质 = 1;
    
      If Sql%NotFound Then
        If Nvl(c_单据.实际数量, 0) <> 0 Then
          n_成本价 := Round((Nvl(c_单据.零售金额, 0) - Nvl(c_单据.差价, 0)) / c_单据.实际数量, 7);
        Else
          n_成本价 := 0;
        End If;
        Insert Into 药品库存
          (库房id, 药品id, 批次, 性质, 可用数量, 上次供应商id, 上次采购价, 零售价)
        Values
          (c_单据.库房id, c_单据.材料id, c_单据.批次, 1, c_单据.实际数量, c_单据.供药单位id, n_成本价,
           Decode(n_实价卫材, 1, Decode(Nvl(c_单据.批次, 0), 0, Null, c_单据.零售价), Null));
      End If;
    
      Delete From 药品库存
      Where 库房id = c_单据.库房id And 药品id = c_单据.材料id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
            Nvl(实际差价, 0) = 0;
    End Loop;
  End If;

  Delete From 药品收发记录 Where NO = No_In And 单据 = 22 And 记录状态 = 1 And 审核人 Is Null;

  If Sql%RowCount = 0 Then
    v_Err_Msg := '[ZLSOFT]该单据已经被他人删除或已被人审核！[ZLSOFT]';
    Raise Err_Item;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料盘点_Delete;
/

--117925:刘涛,2017-12-07,排序导致死锁处理
Create Or Replace Procedure Zl_材料移库_Back(No_In In 药品收发记录.NO%Type) Is
  v_Err_Msg Varchar2(500);
  Err_Item Exception;

  d_发送日期 药品收发记录.配药日期%Type;
  v_备料     药品收发记录.配药人%Type;
  v_审核     药品收发记录.审核人%Type;
  v_下库存   zlParameters.参数值%Type;
  n_实价卫材 收费项目目录.是否变价%Type;

Begin
  Select Nvl(zl_GetSysParameter(95), '0') Into v_下库存 From Dual;

  Select 配药人, 配药日期, 审核人
  Into v_备料, d_发送日期, v_审核
  From 药品收发记录
  Where 单据 = 19 And NO = No_In And Rownum < 2;

  If v_审核 Is Not Null Then
    v_Err_Msg := '[ZLSOFT]该单据已被库房接收，不再允许回退！[ZLSOFT]';
    Raise Err_Item;
  End If;

  If v_备料 Is Null Then
    Return;
  End If;

  If d_发送日期 Is Null Then
    --仅更新配药人为空即可
    Update 药品收发记录 Set 配药人 = Null, 外观 = Null Where 单据 = 19 And NO = No_In;
  Else

    --需要恢复出库库房的可用数量
    Update 药品收发记录 Set 配药日期 = Null Where 单据 = 19 And NO = No_In;
    --如果是在增加单据时已经下了库存的,则本次回退不再恢愎可用可存了.
    If To_Number(v_下库存, '9999') <> 1 Then

      For v_单据 In (Select 实际数量, 库房id, 零售价, 批次, 药品id, 批号, 效期, 产地, 供药单位id, 成本价, 生产日期,
                            灭菌效期, 批准文号
                     From 药品收发记录
                     Where NO = No_In And 单据 = 19 And 入出系数 = -1
                     Order By 药品id, 批次) Loop
        Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = v_单据.药品id;

        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) + v_单据.实际数量
        Where 库房id = v_单据.库房id And 药品id = v_单据.药品id And Nvl(批次, 0) = Nvl(v_单据.批次, 0) And 性质 = 1;

        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 可用数量, 效期, 灭菌效期, 上次供应商id, 上次采购价, 上次批号, 上次生产日期,
             上次产地, 批准文号, 零售价)
          Values
            (v_单据.库房id, v_单据.药品id, Nvl(v_单据.批次, 0), 1, v_单据.实际数量, v_单据.效期, v_单据.灭菌效期,
             v_单据.供药单位id, v_单据.成本价, v_单据.批号, v_单据.生产日期, v_单据.产地, v_单据.批准文号,
             Decode(n_实价卫材, 1, Decode(Nvl(v_单据.批次, 0), 0, Null, v_单据.零售价), Null));

        End If;

        Delete From 药品库存
        Where 库房id = v_单据.库房id And 药品id = v_单据.药品id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And
              Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0;
      End Loop;
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料移库_Back;
/

--117925:刘涛,2017-12-07,排序导致死锁处理
Create Or Replace Procedure Zl_材料移库_Prepare
(
  No_In     In 药品收发记录.NO%Type,
  操作员_In Varchar2 := Null
) Is
  v_Err_Msg Varchar2(500);
  Err_Item Exception;
  v_下库存   zlParameters.参数值%Type;
  n_实价卫材 收费项目目录.是否变价%Type;

Begin
  Select Nvl(zl_GetSysParameter(95), '0') Into v_下库存 From Dual;

  If 操作员_In Is Not Null Then
    Update 药品收发记录
    Set 配药人 = 操作员_In, 外观 = To_Char(Sysdate, 'yyyy-MM-dd hh24:mi:ss')
    Where 单据 = 19 And NO = No_In;

  Else

    Update 药品收发记录 Set 配药日期 = Sysdate Where 单据 = 19 And NO = No_In;

    If To_Number(v_下库存, '9999') <> 1 Then
      For v_单据 In (Select 实际数量, 库房id, 零售价, 批次, 药品id, 批号, 效期, 产地, 供药单位id, 成本价, 灭菌效期,
                            生产日期, 批准文号
                     From 药品收发记录
                     Where NO = No_In And 单据 = 19 And 入出系数 = -1
                     Order By 药品id, 批次) Loop

        Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = v_单据.药品id;

        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - v_单据.实际数量
        Where 库房id = v_单据.库房id And 药品id = v_单据.药品id And Nvl(批次, 0) = Nvl(v_单据.批次, 0) And 性质 = 1;

        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 可用数量, 效期, 灭菌效期, 上次供应商id, 上次采购价, 上次批号, 上次生产日期,
             上次产地, 批准文号, 零售价)
          Values
            (v_单据.库房id, v_单据.药品id, Nvl(v_单据.批次, 0), 1, -1 * v_单据.实际数量, v_单据.效期, v_单据.灭菌效期,
             v_单据.供药单位id, v_单据.成本价, v_单据.批号, v_单据.生产日期, v_单据.产地, v_单据.批准文号,
             Decode(n_实价卫材, 1, Decode(Nvl(v_单据.批次, 0), 0, Null, v_单据.零售价), Null));

        End If;

        Delete From 药品库存
        Where 库房id = v_单据.库房id And 药品id = v_单据.药品id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And
              Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0;

      End Loop;
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料移库_Prepare;
/

--117925:刘涛,2017-12-07,排序导致死锁处理
Create Or Replace Procedure Zl_材料移库_Strike
(
  行次_In       In Integer,
  原记录状态_In In 药品收发记录.记录状态%Type,
  No_In         In 药品收发记录.No%Type,
  序号_In       In 药品收发记录.序号%Type,
  材料id_In     In 药品收发记录.药品id%Type,
  冲销数量_In   In 药品收发记录.实际数量%Type,
  填制人_In     In 药品收发记录.填制人%Type,
  填制日期_In   In 药品收发记录.填制日期%Type,
  冲销方式_In   In Integer := 0
  --0－正常冲销方式；1－产生冲销申请单据；2－审核已产生的冲销申请单据
) Is
  Err_Item Exception;
  v_Err_Msg Varchar2(500);

  n_Batch_Count Integer; --原不分批现在分批的药品的数量

  n_库房id       药品收发记录.库房id%Type;
  n_对方部门id   药品收发记录.对方部门id%Type;
  n_批次         药品收发记录.批次%Type;
  n_成本价       药品收发记录.成本价%Type;
  n_成本金额     药品收发记录.成本金额%Type;
  n_零售价       药品收发记录.零售价%Type;
  n_零售金额     药品收发记录.零售金额%Type;
  n_差价率       药品收发记录.差价%Type;
  v_产地         药品收发记录.产地%Type;
  v_批号         药品收发记录.批号%Type;
  v_效期         药品收发记录.效期%Type;
  v_商品条码     药品收发记录.商品条码%Type;
  v_内部条码     药品收发记录.内部条码%Type;
  v_灭菌日期     药品收发记录.灭菌日期%Type;
  v_灭菌效期     药品收发记录.灭菌效期%Type;
  n_供药单位id   药品收发记录.供药单位id%Type;
  d_生产日期     药品收发记录.生产日期%Type;
  v_批准文号     药品收发记录.批准文号%Type;
  n_扣率         药品收发记录.扣率%Type;
  n_序号         药品收发记录.序号%Type;
  n_入出系数     药品收发记录.入出系数%Type;
  n_入出类别id   药品收发记录.入出类别id%Type;
  v_配药人       药品收发记录.配药人%Type;
  d_发送日期     药品收发记录.配药日期%Type;
  v_摘要         药品收发记录.摘要%Type;
  n_剩余数量     药品收发记录.实际数量%Type;
  n_剩余成本金额 药品收发记录.成本金额%Type;
  n_剩余零售金额 药品收发记录.零售金额%Type;
  n_收发id       药品收发记录.Id%Type;
  n_实价卫材     收费项目目录.是否变价%Type;
  --对冲销数量进行检查
  n_库存数     药品库存.实际数量%Type;
  n_库房分批   Integer;
  n_在用分批   Integer;
  n_小数       Number;
  n_记录数     Number;
  n_平均成本价 药品库存.平均成本价%Type;
  v_下可用库存 Zlparameters.参数值%Type;
  n_可用数量   药品库存.可用数量%Type;

  Cursor c_药品收发记录 Is
    Select a.Id, a.序号, a.库房id, a.对方部门id, a.入出类别id, a.入出系数, a.药品id, Nvl(a.批次, 0) As 批次, a.产地, a.批号, a.效期, a.配药人,
           a.配药日期 As 发送日期, a.摘要, a.供药单位id, a.批准文号, a.生产日期, a.成本价, a.零售价, Nvl(b.是否变价, 0) As 时价, a.扣率, a.单量, a.频次, a.商品条码,
           a.内部条码, a.灭菌日期, a.灭菌效期
    From 药品收发记录 A, 收费项目目录 B
    Where a.药品id = b.Id And a.No = No_In And a.单据 = 19 And (a.序号 >= 序号_In And a.序号 <= 序号_In + 1) And
          (a.记录状态 = 1 Or Mod(a.记录状态, 3) = 0)
    Order By a.药品id,a.批次,a.序号;

  Cursor c_冲销申请记录 Is
    Select a.Id, a.序号, a.库房id, a.对方部门id, a.入出类别id, a.入出系数, a.药品id, Nvl(a.批次, 0) As 批次, a.产地, a.批号, a.效期, a.配药人,
           a.配药日期 As 发送日期, a.摘要, a.供药单位id, a.批准文号, a.生产日期, a.成本价, a.实际数量, a.零售金额, a.差价, a.零售价, Nvl(b.是否变价, 0) As 时价,
           a.扣率, a.单量, a.频次, a.商品条码, a.内部条码, a.灭菌日期, a.灭菌效期
    From 药品收发记录 A, 收费项目目录 B
    Where a.药品id = b.Id And a.No = No_In And a.单据 = 19 And (a.序号 >= 序号_In And a.序号 <= 序号_In + 1) And
          (a.记录状态 = 原记录状态_In And Mod(a.记录状态, 3) = 2) And a.审核日期 Is Null
    Order By a.药品id,a.批次;
Begin
  --获取金额小数位数
  Select Nvl(精度, 2) Into n_小数 From 药品卫材精度 Where 性质 = 0 And 类别 = 2 And 内容 = 4 And 单位 = 5;
  Select Nvl(Zl_Getsysparameter(95), '0') Into v_下可用库存 From Dual;

  If 冲销方式_In = 1 Then
    --申请冲销，只产生冲销数据，不填写审核人，审核日期，也不更新库存
    If 行次_In = 1 Then
      Update 药品收发记录
      Set 记录状态 = Decode(原记录状态_In, 1, 3, 原记录状态_In + 3)
      Where NO = No_In And 单据 = 19 And 记录状态 = 原记录状态_In;
    
      If Sql%RowCount = 0 Then
        v_Err_Msg := '[ZLSOFT]该单据已经被他人冲销！[ZLSOFT]';
        Raise Err_Item;
      End If;
    End If;
  
    --原来不分批，现在分批的卫生材料，不能冲销
    Select Count(*)
    Into n_Batch_Count
    From 药品收发记录 A, 材料特性 B
    Where a.药品id = b.材料id And a.No = No_In And a.单据 = 19 And a.药品id + 0 = 材料id_In And Mod(a.记录状态, 3) = 0 And
          Nvl(a.批次, 0) = 0 And
          ((Nvl(b.库房分批, 0) = 1 And
          a.库房id Not In (Select 部门id From 部门性质说明 Where (工作性质 Like '%发料部门') Or (工作性质 Like '制剂室'))) Or
          Nvl(b.在用分批, 0) = 1);
  
    If n_Batch_Count > 0 Then
      v_Err_Msg := '[ZLSOFT]该单据中包含有一条原来不分批，现在分批的卫生材料，不能冲销！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    --获取当前冲销单据剩余数量
    Select Sum(a.实际数量) As 剩余数量, Sum(a.成本金额) As 剩余成本金额, Sum(a.零售金额) As 剩余零售金额, a.成本价, a.零售价, a.对方部门id, Nvl(a.批次, 0),
           b.库房分批, b.在用分批
    Into n_剩余数量, n_剩余成本金额, n_剩余零售金额, n_成本价, n_零售价, n_库房id, n_批次, n_库房分批, n_在用分批
    From 药品收发记录 A, 材料特性 B
    Where a.No = No_In And a.药品id = b.材料id And a.单据 = 19 And a.药品id + 0 = 材料id_In And a.序号 = 序号_In
    Group By a.成本价, a.零售价, a.对方部门id, Nvl(a.批次, 0), b.库房分批, b.在用分批;
    --判断该部门是库房还是发料部门
    --n_分批:(原分批,现分批为批次;否则为零)原不分批,现分批,本过程不考虑
    --因为对于对方库房，相当于出库，而对于当前库房，相当于入库，所以当前库房不予检查，仅检查退库那条记录
    Select Nvl(a.批次, 0)
    Into n_批次
    From 药品收发记录 A
    Where a.No = No_In And a.单据 = 19 And a.药品id + 0 = 材料id_In And a.序号 = 序号_In + 1 And Mod(a.记录状态, 3) = 0;
  
    --取库存数
    Begin
      Select Nvl(实际数量, 0)
      Into n_库存数
      From 药品库存
      Where 库房id = n_库房id And 药品id = 材料id_In And Nvl(批次, 0) = n_批次 And 性质 = 1;
    Exception
      When Others Then
        n_库存数 := 0;
    End;
  
    If Nvl(n_剩余数量, 0) = 0 Then
      v_Err_Msg := '[ZLSOFT]该单据中第' || Ceil(序号_In / 2) || '行的材料已经被冲销完成,不能再冲！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    --如果库存数大于剩余数量,取剩余数量;否则取库存数
    If n_库存数 < n_剩余数量 Then
      n_剩余成本金额 := n_库存数 / n_剩余数量 * n_剩余成本金额;
      n_剩余零售金额 := n_库存数 / n_剩余数量 * n_剩余零售金额;
      n_剩余数量     := n_库存数;
    End If;
  
    --冲销数量大于剩余数量，不允许
    If n_剩余数量 < 冲销数量_In Then
      v_Err_Msg := '[ZLSOFT]该单据中第' || Ceil(序号_In / 2) || '行的卫生材料冲销的数量大于了剩余的数据，不能冲销！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    n_成本金额 := Round(冲销数量_In / n_剩余数量 * n_剩余成本金额, n_小数);
    n_零售金额 := Round(冲销数量_In / n_剩余数量 * n_剩余零售金额, n_小数);
    n_差价率   := Round(n_零售金额 - n_成本金额, n_小数);
  
    For v_药品收发记录 In c_药品收发记录 Loop
      n_库房id     := v_药品收发记录.库房id;
      n_对方部门id := v_药品收发记录.对方部门id;
      n_批次       := v_药品收发记录.批次;
      n_零售价     := v_药品收发记录.零售价;
      n_入出系数   := v_药品收发记录.入出系数;
      n_成本价     := v_药品收发记录.成本价;
      v_产地       := v_药品收发记录.产地;
      v_批号       := v_药品收发记录.批号;
      v_效期       := v_药品收发记录.效期;
      v_商品条码   := v_药品收发记录.商品条码;
      v_内部条码   := v_药品收发记录.内部条码;
      v_灭菌效期   := v_药品收发记录.灭菌效期;
      v_灭菌日期   := v_药品收发记录.灭菌日期;
      n_供药单位id := v_药品收发记录.供药单位id;
      d_生产日期   := v_药品收发记录.生产日期;
      v_批准文号   := v_药品收发记录.批准文号;
      n_扣率       := v_药品收发记录.扣率;
      n_序号       := v_药品收发记录.序号;
      n_入出类别id := v_药品收发记录.入出类别id;
      v_配药人     := v_药品收发记录.配药人;
      d_发送日期   := v_药品收发记录.发送日期;
      v_摘要       := v_药品收发记录.摘要;
    
      Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
      Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = 材料id_In;
    
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 灭菌日期, 灭菌效期, 填写数量, 实际数量, 成本价, 成本金额, 零售价,
         零售金额, 差价, 摘要, 填制人, 填制日期, 配药人, 配药日期, 供药单位id, 生产日期, 批准文号, 扣率, 商品条码, 内部条码)
      Values
        (n_收发id, Decode(原记录状态_In, 1, 2, 原记录状态_In + 2), 19, No_In, n_序号, n_库房id, n_对方部门id, n_入出类别id, n_入出系数, 材料id_In,
         n_批次, v_产地, v_批号, v_效期, v_灭菌日期, v_灭菌效期, -冲销数量_In, -冲销数量_In, n_成本价, -n_成本金额, n_零售价, -n_零售金额, -n_差价率, v_摘要,
         填制人_In, 填制日期_In, v_配药人, d_发送日期, n_供药单位id, d_生产日期, v_批准文号, n_扣率, v_商品条码, v_内部条码);
      
      Zl_未审药品记录_Insert(n_收发id);
    End Loop;
  
    --参数为1表示申请冲销时下可用数量，仅对原移入库房
    If v_下可用库存 = '1' And n_入出系数 = 1 Then
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) - 冲销数量_In
      Where 库房id = n_库房id And 药品id = 材料id_In And Nvl(批次, 0) = n_批次 And 性质 = 1;
    
      If Sql%RowCount = 0 Then
        Insert Into 药品库存
          (库房id, 药品id, 批次, 性质, 可用数量, 上次批号, 效期, 上次产地)
        Values
          (n_库房id, 材料id_In, n_批次, 1, -1 * 冲销数量_In, v_批号, v_效期, v_产地);
      End If;
    
      Delete From 药品库存
      Where 库房id = n_库房id And 药品id = 材料id_In And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
            Nvl(实际差价, 0) = 0;
    End If;
  
  Elsif 冲销方式_In = 2 Then
  
    --审核申请冲销产生的单据，及填写审核人，审核日期，并更新库存
    For v_冲销申请记录 In c_冲销申请记录 Loop
      n_库房id     := v_冲销申请记录.库房id;
      n_对方部门id := v_冲销申请记录.对方部门id;
      n_批次       := v_冲销申请记录.批次;
      n_零售价     := v_冲销申请记录.零售价;
      n_零售金额   := v_冲销申请记录.零售金额;
      n_差价率     := v_冲销申请记录.差价;
      n_入出系数   := v_冲销申请记录.入出系数;
      n_成本价     := v_冲销申请记录.成本价;
      v_产地       := v_冲销申请记录.产地;
      v_批号       := v_冲销申请记录.批号;
      v_效期       := v_冲销申请记录.效期;
      v_商品条码   := v_冲销申请记录.商品条码;
      v_内部条码   := v_冲销申请记录.内部条码;
      v_灭菌效期   := v_冲销申请记录.灭菌效期;
      v_灭菌日期   := v_冲销申请记录.灭菌日期;
      n_供药单位id := v_冲销申请记录.供药单位id;
      d_生产日期   := v_冲销申请记录.生产日期;
      v_批准文号   := v_冲销申请记录.批准文号;
      n_扣率       := v_冲销申请记录.扣率;
      --原分批现不分批的材料,在冲消时，要处理他
      Begin
        Select Count(*)
        Into n_记录数
        From 药品收发记录 A, 材料特性 B
        Where b.材料id = a.药品id And a.药品id = 材料id_In And a.No = No_In And a.单据 = 19 And a.库房id = n_库房id And
              Mod(a.记录状态, 3) = 0 And Nvl(a.批次, 0) > 0 And
              (Nvl(b.库房分批, 0) = 0 Or
              (Nvl(b.在用分批, 0) = 0 And
              a.库房id In (Select 部门id From 部门性质说明 Where (工作性质 Like '%发料部门') Or (工作性质 Like '制剂室'))));
      Exception
        When Others Then
          n_记录数 := 0;
      End;
      If n_记录数 > 0 Then
        n_批次 := 0;
      Else
        n_批次 := Nvl(n_批次, 0);
      End If;
      Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = 材料id_In;
      --申请时，已经下了可用库存这个地方就不能在下了
      If v_下可用库存 = '1' And n_入出系数 = 1 Then
        n_可用数量 := 0;
      Else
        n_可用数量 := 冲销数量_In;
      End If;
    
      --更改药品库存表的相应数据
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) + Nvl(n_可用数量, 0) * n_入出系数, 实际数量 = Nvl(实际数量, 0) + Nvl(冲销数量_In, 0) * n_入出系数,
          实际金额 = Nvl(实际金额, 0) + Nvl(n_零售金额, 0) * n_入出系数, 实际差价 = Nvl(实际差价, 0) + Nvl(n_差价率, 0) * n_入出系数,
          上次采购价 = Nvl(n_成本价, 上次采购价), 上次批号 = Nvl(v_批号, 上次批号), 上次产地 = Nvl(v_产地, 上次产地), 效期 = Nvl(v_效期, 效期),
          零售价 = Decode(n_实价卫材, 1, Decode(Nvl(批次, 0), 0, Null, Decode(Nvl(零售价, 0), 0, n_零售价, 零售价)), Null),
          商品条码 = Nvl(商品条码, v_商品条码), 内部条码 = Nvl(内部条码, v_内部条码)
      Where 库房id = n_库房id And 药品id = 材料id_In And Nvl(批次, 0) = n_批次 And 性质 = 1;
    
      If Sql%NotFound Then
        Insert Into 药品库存
          (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次采购价, 上次批号, 上次产地, 效期, 灭菌效期, 上次供应商id, 上次生产日期, 批准文号, 零售价, 上次扣率,
           商品条码, 内部条码, 平均成本价)
        Values
          (n_库房id, 材料id_In, n_批次, 1, 冲销数量_In * n_入出系数, 冲销数量_In * n_入出系数, n_零售金额 * n_入出系数, n_差价率 * n_入出系数, n_成本价, v_批号,
           v_产地, v_效期, v_灭菌效期, n_供药单位id, d_生产日期, v_批准文号, Decode(n_实价卫材, 1, Decode(Nvl(n_批次, 0), 0, Null, n_零售价), Null),
           n_扣率, v_商品条码, v_内部条码, n_成本价);
      End If;
    
      Delete From 药品库存
      Where 库房id = n_库房id And 药品id = 材料id_In And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
            Nvl(实际差价, 0) = 0;
    
      --填写审核人、审核日期
      Update 药品收发记录
      Set 审核人 = 填制人_In, 审核日期 = 填制日期_In
      Where NO = No_In And 单据 = 19 And ID = v_冲销申请记录.Id;
      
      Zl_未审药品记录_Delete(v_冲销申请记录.Id);
      
      Zl_材料收发记录_调价修正(v_冲销申请记录.Id);
    End Loop;
  Else
    --正常冲销业务，产生冲销单据审核并更新库存
    If 行次_In = 1 Then
      Update 药品收发记录
      Set 记录状态 = Decode(原记录状态_In, 1, 3, 原记录状态_In + 3)
      Where NO = No_In And 单据 = 19 And 记录状态 = 原记录状态_In;
      If Sql%RowCount = 0 Then
        v_Err_Msg := '[ZLSOFT]该单据已经被他人冲销！[ZLSOFT]';
        Raise Err_Item;
      End If;
    End If;
  
    Select Count(*)
    Into n_Batch_Count
    From 药品收发记录 A, 材料特性 B
    Where a.药品id = b.材料id And a.No = No_In And a.单据 = 19 And a.药品id + 0 = 材料id_In And Mod(a.记录状态, 3) = 0 And
          Nvl(a.批次, 0) = 0 And
          ((Nvl(b.库房分批, 0) = 1 And
          a.库房id Not In (Select 部门id From 部门性质说明 Where (工作性质 Like '%发料部门') Or (工作性质 Like '制剂室'))) Or
          Nvl(b.在用分批, 0) = 1);
  
    If n_Batch_Count > 0 Then
      v_Err_Msg := '[ZLSOFT]该单据中包含有一条原来不分批，现在分批的卫生材料，不能冲销！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Select Sum(a.实际数量) As 剩余数量, Sum(a.成本金额) As 剩余成本金额, Sum(a.零售金额) As 剩余零售金额, a.成本价, a.零售价, a.对方部门id, Nvl(a.批次, 0),
           b.库房分批, b.在用分批
    Into n_剩余数量, n_剩余成本金额, n_剩余零售金额, n_成本价, n_零售价, n_库房id, n_批次, n_库房分批, n_在用分批
    From 药品收发记录 A, 材料特性 B
    Where a.No = No_In And a.药品id = b.材料id And a.单据 = 19 And a.药品id + 0 = 材料id_In And a.序号 = 序号_In
    Group By a.成本价, a.零售价, a.对方部门id, Nvl(a.批次, 0), b.库房分批, b.在用分批;
  
    --判断该部门是库房还是发料部门
    --n_分批:(原分批,现分批为批次;否则为零)原不分批,现分批,本过程不考虑
    --因为对于对方库房，相当于出库，而对于当前库房，相当于入库，所以当前库房不予检查，仅检查退库那条记录
    Select Nvl(a.批次, 0)
    Into n_批次
    From 药品收发记录 A
    Where a.No = No_In And a.单据 = 19 And a.药品id + 0 = 材料id_In And a.序号 = 序号_In + 1 And Mod(a.记录状态, 3) = 0;
  
    --取库存数
    Begin
      Select Nvl(实际数量, 0)
      Into n_库存数
      From 药品库存
      Where 库房id = n_库房id And 药品id = 材料id_In And Nvl(批次, 0) = n_批次 And 性质 = 1;
    Exception
      When Others Then
        n_库存数 := 0;
    End;
  
    If Nvl(n_剩余数量, 0) = 0 Then
      v_Err_Msg := '[ZLSOFT]该单据中第' || Ceil(序号_In / 2) || '行的材料已经被冲销完成,不能再冲！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    --如果库存数大于剩余数量,取剩余数量;否则取库存数
    If n_库存数 < n_剩余数量 Then
      n_剩余成本金额 := n_库存数 / n_剩余数量 * n_剩余成本金额;
      n_剩余零售金额 := n_库存数 / n_剩余数量 * n_剩余零售金额;
      n_剩余数量     := n_库存数;
    End If;
  
    --冲销数量大于剩余数量，不允许
    If n_剩余数量 < 冲销数量_In Then
      v_Err_Msg := '[ZLSOFT]该单据中第' || Ceil(序号_In / 2) || '行的卫生材料冲销的数量大于了剩余的数据，不能冲销！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    n_成本金额 := Round(冲销数量_In / n_剩余数量 * n_剩余成本金额, n_小数);
    n_零售金额 := Round(冲销数量_In / n_剩余数量 * n_剩余零售金额, n_小数);
    n_差价率   := Round(n_零售金额 - n_成本金额, n_小数);
  
    For v_药品收发记录 In c_药品收发记录 Loop
      n_库房id     := v_药品收发记录.库房id;
      n_对方部门id := v_药品收发记录.对方部门id;
      n_批次       := v_药品收发记录.批次;
      n_零售价     := v_药品收发记录.零售价;
      n_入出系数   := v_药品收发记录.入出系数;
      n_成本价     := v_药品收发记录.成本价;
      v_产地       := v_药品收发记录.产地;
      v_批号       := v_药品收发记录.批号;
      v_效期       := v_药品收发记录.效期;
      v_商品条码   := v_药品收发记录.商品条码;
      v_内部条码   := v_药品收发记录.内部条码;
      v_灭菌效期   := v_药品收发记录.灭菌效期;
      v_灭菌日期   := v_药品收发记录.灭菌日期;
      n_供药单位id := v_药品收发记录.供药单位id;
      d_生产日期   := v_药品收发记录.生产日期;
      v_批准文号   := v_药品收发记录.批准文号;
      n_扣率       := v_药品收发记录.扣率;
      n_序号       := v_药品收发记录.序号;
      n_入出类别id := v_药品收发记录.入出类别id;
      v_配药人     := v_药品收发记录.配药人;
      d_发送日期   := v_药品收发记录.发送日期;
      v_摘要       := v_药品收发记录.摘要;
    
      Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
      Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = 材料id_In;
    
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 灭菌日期, 灭菌效期, 填写数量, 实际数量, 成本价, 成本金额, 零售价,
         零售金额, 差价, 摘要, 填制人, 填制日期, 审核人, 审核日期, 配药人, 配药日期, 供药单位id, 生产日期, 批准文号, 扣率, 商品条码, 内部条码)
      Values
        (n_收发id, Decode(原记录状态_In, 1, 2, 原记录状态_In + 2), 19, No_In, n_序号, n_库房id, n_对方部门id, n_入出类别id, n_入出系数, 材料id_In,
         n_批次, v_产地, v_批号, v_效期, v_灭菌日期, v_灭菌效期, -冲销数量_In, -冲销数量_In, n_成本价, -n_成本金额, n_零售价, -n_零售金额, -n_差价率, v_摘要,
         填制人_In, 填制日期_In, 填制人_In, 填制日期_In, v_配药人, d_发送日期, n_供药单位id, d_生产日期, v_批准文号, n_扣率, v_商品条码, v_内部条码);
      
      --原分批现不分批的材料,在冲消时，要处理他
      Begin
        Select Count(*)
        Into n_记录数
        From 药品收发记录 A, 材料特性 B
        Where b.材料id = a.药品id And a.药品id = 材料id_In And a.No = No_In And a.单据 = 19 And a.库房id = n_库房id And
              Mod(a.记录状态, 3) = 0 And Nvl(a.批次, 0) > 0 And
              (Nvl(b.库房分批, 0) = 0 Or
              (Nvl(b.在用分批, 0) = 0 And
              a.库房id In (Select 部门id From 部门性质说明 Where (工作性质 Like '%发料部门') Or (工作性质 Like '制剂室'))));
      Exception
        When Others Then
          n_记录数 := 0;
      End;
      If n_记录数 > 0 Then
        n_批次 := 0;
      Else
        n_批次 := Nvl(n_批次, 0);
      End If;
    
      --更改药品库存表的相应数据
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) - Nvl(冲销数量_In, 0) * n_入出系数, 实际数量 = Nvl(实际数量, 0) - Nvl(冲销数量_In, 0) * n_入出系数,
          实际金额 = Nvl(实际金额, 0) - Nvl(n_零售金额, 0) * n_入出系数, 实际差价 = Nvl(实际差价, 0) - Nvl(n_差价率, 0) * n_入出系数,
          上次采购价 = Nvl(n_成本价, 上次采购价), 上次批号 = Nvl(v_批号, 上次批号), 上次产地 = Nvl(v_产地, 上次产地), 效期 = Nvl(v_效期, 效期),
          零售价 = Decode(n_实价卫材, 1, Decode(Nvl(批次, 0), 0, Null, Decode(Nvl(零售价, 0), 0, n_零售价, 零售价)), Null),
          商品条码 = Nvl(商品条码, v_商品条码), 内部条码 = Nvl(内部条码, v_内部条码)
      Where 库房id = n_库房id And 药品id = 材料id_In And Nvl(批次, 0) = n_批次 And 性质 = 1;
    
      If Sql%NotFound Then
        Insert Into 药品库存
          (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次采购价, 上次批号, 上次产地, 效期, 灭菌效期, 上次供应商id, 上次生产日期, 批准文号, 零售价, 上次扣率,
           商品条码, 内部条码, 平均成本价)
        Values
          (n_库房id, 材料id_In, n_批次, 1, -冲销数量_In * n_入出系数, -冲销数量_In * n_入出系数, -n_零售金额 * n_入出系数, -n_差价率 * n_入出系数, n_成本价,
           v_批号, v_产地, v_效期, v_灭菌效期, n_供药单位id, d_生产日期, v_批准文号,
           Decode(n_实价卫材, 1, Decode(Nvl(n_批次, 0), 0, Null, n_零售价), Null), n_扣率, v_商品条码, v_内部条码, n_成本价);
      End If;
    
      Delete From 药品库存
      Where 库房id = n_库房id And 药品id = 材料id_In And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
            Nvl(实际差价, 0) = 0;
    
      --重新计算库存表中的平均成本价
      Update 药品库存
      Set 平均成本价 = Decode(Nvl(批次, 0), 0, Decode((实际金额 - 实际差价) / 实际数量, 0, 上次采购价, (实际金额 - 实际差价) / 实际数量), 上次采购价)
      Where 性质 = 1 And 库房id = n_库房id And 药品id = 材料id_In And Nvl(批次, 0) = n_批次 And Nvl(实际数量, 0) <> 0;
      If Sql%NotFound Then
        Select 成本价 Into n_平均成本价 From 材料特性 Where 材料id = 材料id_In;
        Update 药品库存
        Set 平均成本价 = n_平均成本价
        Where 性质 = 1 And 库房id = n_库房id And 药品id = 材料id_In And Nvl(批次, 0) = n_批次 And Nvl(平均成本价, 0) <> n_成本价;
      End If;
      --处理调价后冲销
      
      Zl_材料收发记录_调价修正(n_收发id);
    End Loop;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料移库_Strike;
/

--119864:秦龙,2018-01-16,实际数量不足提示问题
--117925:刘涛,2017-12-07,排序导致死锁处理
--105711:李业庆,2018-01-03,出库库存平均成本价处理
Create Or Replace Procedure Zl_材料移库_Verify
(
  序号_In       In 药品收发记录.序号%Type,
  库房id_In     In 药品收发记录.库房id%Type,
  对方部门id_In In 药品收发记录.对方部门id%Type,
  材料id_In     In 药品收发记录.药品id%Type,
  产地_In       In 药品收发记录.产地%Type,
  出批次_In     In 药品收发记录.批次%Type,
  填写数量_In   In 药品收发记录.填写数量%Type,
  实际数量_In   In 药品收发记录.实际数量%Type,
  成本价_In     In 药品收发记录.成本价%Type,
  成本金额_In   In 药品收发记录.成本金额%Type,
  零售金额_In   In 药品收发记录.零售金额%Type,
  差价_In       In 药品收发记录.差价%Type,
  出类别id_In   In 药品收发记录.入出类别id%Type,
  入类别id_In   In 药品收发记录.入出类别id%Type,
  No_In         In 药品收发记录.No%Type,
  审核人_In     In 药品收发记录.审核人%Type,
  批号_In       In 药品收发记录.批号%Type := Null,
  效期_In       In 药品收发记录.效期%Type := Null,
  灭菌效期_In   In 药品收发记录.灭菌效期%Type := Null,
  审核日期_In   In 药品收发记录.审核日期%Type := Null,
  移库单_In     In Number := 1,
  零售价_In     In 药品收发记录.零售价%Type := Null
) Is
  Err_Item Exception;
  v_Err_Msg    Varchar2(500);
  v_编码       收费项目目录.编码%Type;
  v_负成本计算 Zlparameters.参数值%Type;
  v_批准文号   药品库存.批准文号%Type;
  n_实价卫材   收费项目目录.是否变价%Type;

  n_入批次       药品收发记录.批次%Type := Null;
  n_实际库存金额 药品库存.实际金额%Type;
  n_实际库存差价 药品库存.实际差价%Type;
  n_出库差价     药品库存.实际差价%Type;
  n_成本价       药品收发记录.成本价%Type;
  n_成本金额     药品收发记录.成本金额%Type;
  n_实际数量     药品库存.实际数量%Type;
  n_上次供应商id 药品库存.上次供应商id%Type;
  n_上次生产日期 药品库存.上次生产日期%Type;
  n_零售价       药品收发记录.零售价%Type;
  n_小数         Number;
  v_上次扣率     药品库存.上次扣率%Type;
  v_商品条码     药品库存.商品条码%Type;
  v_内部条码     药品库存.内部条码%Type;
  n_平均成本价   药品库存.平均成本价%Type;

  Cursor c_药品收发记录 Is
    Select ID
    From 药品收发记录
    Where NO = No_In And 单据 = 19 And 药品id = 材料id_In And 记录状态 = 1 And 序号 In (序号_In, 序号_In + 1) And 审核人 Is Null
    Order By 药品id, 批次;

Begin
  --获取金额小数位数
  Select Nvl(精度, 2) Into n_小数 From 药品卫材精度 Where 类别 = 2 And 内容 = 4 And 单位 = 5;
  Select zl_GetSysParameter(120) Into v_负成本计算 From Dual;

  --由于移库处理允许在审核时改变实际数量，
  --所以首先对实际数量和其他相应的字段进行更新。
  Begin
    Select Nvl(实际金额, 0), Nvl(实际差价, 0), Nvl(实际数量, 0), Nvl(上次扣率, 100), 商品条码, 内部条码
    Into n_实际库存金额, n_实际库存差价, n_实际数量, v_上次扣率, v_商品条码, v_内部条码
    From 药品库存
    Where 药品id = 材料id_In And Nvl(批次, 0) = 出批次_In And 库房id = 库房id_In And 性质 = 1 And Rownum = 1;
  Exception
    When Others Then
      n_实际库存金额 := 0;
      n_实际数量     := 0;
      v_上次扣率     := 100;
      v_商品条码     := Null;
      v_内部条码     := Null;
  End;
  Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = 材料id_In;

  If 成本价_In Is Null Then
    --成本价为空
    n_成本价   := Round(Zl_Fun_Getoutcost(材料id_In, 出批次_In, 库房id_In), 7);
    n_成本金额 := Round(n_成本价 * 实际数量_In, n_小数);
    n_出库差价 := Round(零售金额_In - n_成本金额, n_小数);
  Else
    n_成本价   := 成本价_In;
    n_成本金额 := 成本金额_In;
    n_出库差价 := 差价_In;
  End If;

  For c_删除 In c_药品收发记录 Loop
    Zl_未审药品记录_Delete(c_删除.Id);
  End Loop;

  Update 药品收发记录
  Set 审核人 = Nvl(审核人_In, 审核人), 审核日期 = 审核日期_In, 实际数量 = 实际数量_In, 成本价 = n_成本价, 成本金额 = n_成本金额, 零售价 = 零售价_In, 零售金额 = 零售金额_In,
      差价 = n_出库差价, 扣率 = v_上次扣率, 商品条码 = v_商品条码, 内部条码 = v_内部条码
  Where NO = No_In And 单据 = 19 And 药品id = 材料id_In And 记录状态 = 1 And 序号 In (序号_In, 序号_In + 1) And 审核人 Is Null;

  If Sql%RowCount = 0 Then
    v_Err_Msg := '[ZLSOFT]该单据已经被他人审核！[ZLSOFT]';
    Raise Err_Item;
  End If;

  If 出批次_In > 0 Then
    If n_实际数量 < 实际数量_In Then
      Select 编码 Into v_编码 From 收费项目目录 Where ID = 材料id_In;
      v_Err_Msg := '[ZLSOFT]编码为' || v_编码 || ',批号为' || 批号_In || '的库房分批材料' || Chr(10) || Chr(13) || '实际库存数量不够！[ZLSOFT]';
      Raise Err_Item;
    End If;
  End If;

  --取入类别的批次和上次供应商
  Select 批次, 供药单位id, 生产日期, 批准文号, 零售价
  Into n_入批次, n_上次供应商id, n_上次生产日期, v_批准文号, n_零售价
  From 药品收发记录
  Where NO = No_In And 单据 = 19 And 记录状态 = 1 And 序号 = 序号_In + 1;

  --更改入类别的材料库存的相应数据

  Update 药品库存
  Set 可用数量 = Nvl(可用数量, 0) + 实际数量_In, 实际数量 = Nvl(实际数量, 0) + 实际数量_In, 实际金额 = Nvl(实际金额, 0) + 零售金额_In,
      实际差价 = Nvl(实际差价, 0) + n_出库差价, 上次采购价 = Decode(上次采购价, Null, n_成本价, 0, n_成本价, 上次采购价), 上次批号 = Nvl(批号_In, 上次批号),
      上次产地 = Nvl(产地_In, 上次产地), 灭菌效期 = Nvl(灭菌效期_In, 灭菌效期), 商品条码 = v_商品条码, 内部条码 = v_内部条码
  Where 库房id = 对方部门id_In And 药品id = 材料id_In And Nvl(批次, 0) = Nvl(n_入批次, 0) And 性质 = 1;

  If Sql%NotFound Then
    Insert Into 药品库存
      (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次采购价, 上次批号, 上次产地, 效期, 灭菌效期, 上次供应商id, 上次生产日期, 批准文号, 零售价, 上次扣率, 商品条码,
       内部条码, 平均成本价)
    Values
      (对方部门id_In, 材料id_In, n_入批次, 1, 实际数量_In, 实际数量_In, 零售金额_In, n_出库差价, n_成本价, 批号_In, 产地_In, 效期_In, 灭菌效期_In, n_上次供应商id,
       n_上次生产日期, v_批准文号, Decode(n_实价卫材, 1, Decode(Nvl(n_入批次, 0), 0, Null, n_零售价), Null), v_上次扣率, v_商品条码, v_内部条码, n_成本价);
  End If;

  Delete From 药品库存
  Where 库房id = 对方部门id_In And 药品id = 材料id_In And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
        Nvl(实际差价, 0) = 0;

  --入库类别：不分批的重新计算平均成本价
  If Nvl(n_入批次, 0) = 0 Then
    Update 药品库存
    Set 平均成本价 = Decode(Nvl(批次, 0), 0, Decode((实际金额 - 实际差价) / 实际数量, 0, 上次采购价, (实际金额 - 实际差价) / 实际数量), 上次采购价)
    Where 药品id = 材料id_In And Nvl(批次, 0) = Nvl(n_入批次, 0) And 库房id = 对方部门id_In And Nvl(实际数量, 0) <> 0 And 性质 = 1;
    If Sql%NotFound Then
      Select 成本价 Into n_平均成本价 From 材料特性 Where 材料id = 材料id_In;
      Update 药品库存
      Set 平均成本价 = n_平均成本价
      Where 药品id = 材料id_In And 库房id = 对方部门id_In And Nvl(批次, 0) = Nvl(n_入批次, 0) And 性质 = 1;
    End If;
  End If;

  --更改出类别的材料库存的相应数据

  Update 药品库存
  Set 实际数量 = Nvl(实际数量, 0) - 实际数量_In, 实际金额 = Nvl(实际金额, 0) - 零售金额_In, 实际差价 = Nvl(实际差价, 0) - n_出库差价
  Where 库房id = 库房id_In And 药品id = 材料id_In And Nvl(批次, 0) = Nvl(出批次_In, 0) And 性质 = 1;

  If Sql%NotFound Then
    Insert Into 药品库存
      (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次批号, 上次产地, 效期, 灭菌效期, 上次供应商id, 上次采购价, 上次生产日期, 批准文号, 零售价, 上次扣率, 商品条码,
       内部条码, 平均成本价)
    Values
      (库房id_In, 材料id_In, 出批次_In, 1, 0, -实际数量_In, -零售金额_In, -n_出库差价, 批号_In, 产地_In, 效期_In, 灭菌效期_In, n_上次供应商id, n_成本价,
       n_上次生产日期, v_批准文号, Decode(n_实价卫材, 1, Decode(Nvl(出批次_In, 0), 0, Null, n_零售价), Null), v_上次扣率, v_商品条码, v_内部条码, n_成本价);
  End If;

  --出库房，平均成本价为空时需要重新计算库存表中的平均成本价
  Update 药品库存
  Set 平均成本价 = n_成本价
  Where 药品id = 材料id_In And Nvl(批次, 0) = Nvl(出批次_In, 0) And 库房id = 库房id_In And 性质 = 1 And Nvl(平均成本价, 0) = 0;

  Delete From 药品库存
  Where 库房id = 库房id_In And 药品id = 材料id_In And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
        Nvl(实际差价, 0) = 0;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料移库_Verify;
/

--105711:李业庆,2018-01-03,出库库存平均成本价处理
Create Or Replace Procedure Zl_材料其他出库_Verify
(
  序号_In       In 药品收发记录.序号%Type,
  No_In         In 药品收发记录.No%Type,
  库房id_In     In 药品收发记录.库房id%Type,
  材料id_In     In 药品收发记录.药品id%Type,
  批次_In       In 药品收发记录.批次%Type,
  实际数量_In   In 药品收发记录.实际数量%Type,
  成本价_In     In 药品收发记录.成本价%Type,
  成本金额_In   In 药品收发记录.成本金额%Type,
  零售金额_In   In 药品收发记录.零售金额%Type,
  差价_In       In 药品收发记录.差价%Type,
  入出类别id_In In 药品收发记录.入出类别id%Type,
  审核人_In     In 药品收发记录.审核人%Type,
  审核日期_In   In 药品收发记录.审核日期%Type,
  药库业务_In   In Number := 0
) Is
  --  药库业务_in 0-药房业务，1-药库业务
  Err_Item Exception;
  v_Err_Msg    Varchar2(100);
  v_负成本计算 Zlparameters.参数值%Type;
  v_批准文号   药品库存.批准文号%Type;
  v_批号       药品收发记录.批号%Type;
  v_产地       药品收发记录.产地%Type;

  n_实际库存金额 药品库存.实际金额%Type;
  n_实际库存差价 药品库存.实际差价%Type;
  n_实际库存数量 药品库存.实际数量%Type;

  n_出库差价 药品库存.实际差价%Type;
  n_成本价   药品收发记录.成本价%Type;
  n_成本金额 药品收发记录.成本金额%Type;

  n_上次供应商id 药品库存.上次供应商id%Type;
  n_实价卫材     收费项目目录.是否变价%Type;
  n_零售价       药品收发记录.零售价%Type;
  n_小数         Number(2);

  d_上次生产日期   药品库存.上次生产日期%Type;
  d_效期           药品库存.效期%Type;
  d_灭菌效期       药品库存.灭菌效期%Type;
  v_上次扣率       药品库存.上次扣率%Type;
  v_商品条码       药品库存.商品条码%Type;
  v_内部条码       药品库存.内部条码%Type;
  n_平均成本价     药品库存.平均成本价%Type;
  n_药品收发记录id 药品收发记录.Id%Type;

  v_下库存   Zlparameters.参数值%Type;
  n_可用数量 药品库存.可用数量%Type;
Begin
  Select Nvl(精度, 2) Into n_小数 From 药品卫材精度 Where 类别 = 2 And 内容 = 4 And 单位 = 5;
  Select zl_GetSysParameter(120) Into v_负成本计算 From Dual;
  Select Nvl(zl_GetSysParameter(95), '0') Into v_下库存 From Dual;

  --由于领用处理允许在审核时改变实际数量，
  --所以首先对实际数量和其他相应的字段进行更新。
  Begin
    Select Nvl(实际金额, 0), Nvl(实际差价, 0), Nvl(实际数量, 0), Nvl(上次扣率, 100), 商品条码, 内部条码
    Into n_实际库存金额, n_实际库存差价, n_实际库存数量, v_上次扣率, v_商品条码, v_内部条码
    From 药品库存
    Where 药品id = 材料id_In And Nvl(批次, 0) = 批次_In And 库房id = 库房id_In And 性质 = 1 And Rownum = 1;
  Exception
    When Others Then
      n_实际库存金额 := 0;
      n_实际库存数量 := 0;
      v_上次扣率     := 100;
      v_商品条码     := Null;
      v_内部条码     := Null;
  End;

  If 成本价_In Is Null Then
    --成本价为空
    n_成本价   := Round(Zl_Fun_Getoutcost(材料id_In, 批次_In, 库房id_In), 7);
    n_成本金额 := Round(n_成本价 * 实际数量_In, n_小数);
    n_出库差价 := Round(零售金额_In - n_成本金额, n_小数);
  Else
    n_成本价   := 成本价_In;
    n_成本金额 := 成本金额_In;
    n_出库差价 := 差价_In;
  End If;

  --取上次供应商ID
  Begin
    Select ID, 供药单位id, 零售价, 生产日期, 批准文号, 效期, 灭菌效期, 批号, 产地
    Into n_药品收发记录id, n_上次供应商id, n_零售价, d_上次生产日期, v_批准文号, d_效期, d_灭菌效期, v_批号, v_产地
    From 药品收发记录
    Where NO = No_In And 单据 = 21 And 药品id = 材料id_In And 记录状态 = 1 And 序号 = 序号_In And Rownum = 1;
  
  Exception
    When Others Then
      n_上次供应商id := Null;
  End;

  Zl_未审药品记录_Delete(n_药品收发记录id);

  Update 药品收发记录
  Set 审核人 = Nvl(审核人_In, 审核人), 审核日期 = 审核日期_In, 成本价 = n_成本价, 成本金额 = n_成本金额, 差价 = n_出库差价, 扣率 = v_上次扣率, 商品条码 = v_商品条码,
      内部条码 = v_内部条码
  Where NO = No_In And 单据 = 21 And 药品id = 材料id_In And 序号 = 序号_In And 记录状态 = 1 And 审核人 Is Null;

  If Sql%RowCount = 0 Then
    v_Err_Msg := '[ZLSOFT]该单据已经被他人审核！[ZLSOFT]';
    Raise Err_Item;
  End If;
  Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = 材料id_In;

  --更改药品库存的相应数据
  If 药库业务_In = 0 Then
    n_可用数量 := 0;
  Else
    If To_Number(v_下库存, '9999') = 1 Then
      n_可用数量 := 0;
    Else
      n_可用数量 := 实际数量_In;
    End If;
  End If;

  Update 药品库存
  Set 可用数量 = Nvl(可用数量, 0) - n_可用数量, 实际数量 = Nvl(实际数量, 0) - 实际数量_In, 实际金额 = Nvl(实际金额, 0) - 零售金额_In,
      实际差价 = Nvl(实际差价, 0) - n_出库差价,
      零售价 = Decode(n_实价卫材, 1, Decode(Nvl(批次_In, 0), 0, Null, Decode(Nvl(零售价, 0), 0, n_零售价, 零售价)), Null), 商品条码 = v_商品条码,
      内部条码 = v_内部条码
  Where 库房id = 库房id_In And 药品id = 材料id_In And Nvl(批次, 0) = Nvl(批次_In, 0) And 性质 = 1;

  If Sql%NotFound Then
    Insert Into 药品库存
      (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 效期, 灭菌效期, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 批准文号, 零售价, 上次扣率, 商品条码,
       内部条码, 平均成本价)
    Values
      (库房id_In, 材料id_In, 批次_In, 1, -n_可用数量, -实际数量_In, -零售金额_In, -n_出库差价, d_效期, d_灭菌效期, n_上次供应商id, n_成本价, v_批号, d_上次生产日期,
       v_产地, v_批准文号, Decode(n_实价卫材, 1, Decode(Nvl(批次_In, 0), 0, Null, n_零售价), Null), v_上次扣率, v_商品条码, v_内部条码, n_成本价);
  End If;

  Delete From 药品库存
  Where 库房id = 库房id_In And 药品id = 材料id_In And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
        Nvl(实际差价, 0) = 0;

  --出库房，平均成本价为空时需要重新计算库存表中的平均成本价
  Update 药品库存
  Set 平均成本价 = n_成本价
  Where 药品id = 材料id_In And Nvl(批次, 0) = Nvl(批次_In, 0) And 库房id = 库房id_In And 性质 = 1 And Nvl(平均成本价, 0) = 0;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料其他出库_Verify;
/

--105711:李业庆,2018-01-03,出库库存平均成本价处理
Create Or Replace Procedure Zl_材料领用_Verify
(
  序号_In       In 药品收发记录.序号%Type,
  No_In         In 药品收发记录.No%Type,
  库房id_In     In 药品收发记录.库房id%Type,
  对方部门id_In In 药品收发记录.对方部门id%Type,
  材料id_In     In 药品收发记录.药品id%Type,
  产地_In       In 药品收发记录.产地%Type,
  批次_In       In 药品收发记录.批次%Type,
  填写数量_In   In 药品收发记录.填写数量%Type,
  实际数量_In   In 药品收发记录.实际数量%Type,
  成本价_In     In 药品收发记录.成本价%Type,
  成本金额_In   In 药品收发记录.成本金额%Type,
  零售金额_In   In 药品收发记录.零售金额%Type,
  差价_In       In 药品收发记录.差价%Type,
  入出类别id_In In 药品收发记录.入出类别id%Type,
  审核人_In     In 药品收发记录.审核人%Type,
  审核日期_In   In 药品收发记录.审核日期%Type,
  批号_In       In 药品收发记录.批号%Type := Null,
  效期_In       In 药品收发记录.效期%Type := Null,
  审核方式_In   In Number := 0
) Is
  Err_Item Exception;
  v_Err_Msg    Varchar2(500);
  v_负成本计算 Zlparameters.参数值%Type;
  v_编码       收费项目目录.编码%Type;
  v_批准文号   药品库存.批准文号%Type;

  d_上次生产日期 药品库存.上次生产日期%Type;
  d_效期         药品库存.效期%Type;
  d_灭菌效期     药品库存.灭菌效期%Type;

  n_可用数量       药品库存.可用数量%Type;
  n_实际数量       药品库存.实际数量%Type;
  n_上次供应商id   药品库存.上次供应商id%Type;
  n_零售价         药品收发记录.零售价%Type;
  n_实价卫材       收费项目目录.是否变价%Type;
  n_小数           Number(2);
  v_上次扣率       药品库存.上次扣率%Type;
  n_数量差         药品收发记录.实际数量%Type;
  v_商品条码       药品库存.商品条码%Type;
  v_内部条码       药品库存.内部条码%Type;
  n_平均成本价     药品库存.平均成本价%Type;
  v_下库存         Zlparameters.参数值%Type;
  n_药品收发记录id 药品收发记录.Id%Type;

Begin
  Select zl_GetSysParameter(120) Into v_负成本计算 From Dual;
  Select Nvl(精度, 2) Into n_小数 From 药品卫材精度 Where 性质 = 0 And 类别 = 2 And 内容 = 4 And 单位 = 5;
  Select To_Number(Nvl(zl_GetSysParameter(95), '0')) Into v_下库存 From Dual;
  --由于领用处理允许在审核时改变实际数量，
  --所以首先对实际数量和其他相应的字段进行更新。

  Begin
    Select Nvl(可用数量, 0), Nvl(实际数量, 0), Nvl(上次扣率, 100), 商品条码, 内部条码
    Into n_可用数量, n_实际数量, v_上次扣率, v_商品条码, v_内部条码
    From 药品库存
    Where 药品id = 材料id_In And Nvl(批次, 0) = 批次_In And 库房id = 库房id_In And 性质 = 1 And Rownum = 1;
  
  Exception
    When Others Then
      n_可用数量 := 0;
      n_实际数量 := 0;
      v_上次扣率 := 100;
      v_商品条码 := Null;
      v_内部条码 := Null;
  End;

  --取上次供应商ID
  Begin
    Select ID, 供药单位id, 生产日期, 批准文号, 效期, 灭菌效期, 零售价
    Into n_药品收发记录id, n_上次供应商id, d_上次生产日期, v_批准文号, d_效期, d_灭菌效期, n_零售价
    From 药品收发记录
    Where NO = No_In And 单据 = 20 And 药品id = 材料id_In And 记录状态 = 1 And 序号 = 序号_In And Rownum = 1;
  
  Exception
    When Others Then
      n_上次供应商id := Null;
      d_效期         := 效期_In;
  End;

  If 审核方式_In = 0 Then
    --出库审核
    Begin
      Select 实际数量 - 实际数量_In
      Into n_数量差
      From 药品收发记录
      Where NO = No_In And 单据 = 20 And 药品id = 材料id_In And 序号 = 序号_In And 记录状态 = 1 And 审核人 Is Null;
    Exception
      When Others Then
        n_数量差 := Null;
    End;
  
    If n_数量差 Is Null Then
      v_Err_Msg := '[ZLSOFT]该单据已经被他人审核！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Update 药品收发记录
    Set 审核人 = Nvl(审核人_In, 审核人), 审核日期 = 审核日期_In, 实际数量 = 实际数量_In, 成本价 = 成本价_In, 成本金额 = 成本金额_In, 零售金额 = 零售金额_In, 差价 = 差价_In,
        扣率 = v_上次扣率, 商品条码 = v_商品条码, 内部条码 = v_内部条码
    Where NO = No_In And 单据 = 20 And 药品id = 材料id_In And 序号 = 序号_In And 记录状态 = 1 And 审核人 Is Null;
  
    Zl_未审药品记录_Delete(n_药品收发记录id);
  Elsif 审核方式_In = 1 Then
    --财务审核
    Begin
      Select 实际数量 - 实际数量_In
      Into n_数量差
      From 药品收发记录
      Where NO = No_In And 单据 = 20 And 药品id = 材料id_In And 序号 = 序号_In And 记录状态 = 1 And 配药人 Is Null;
    Exception
      When Others Then
        n_数量差 := Null;
    End;
  
    If n_数量差 Is Null Then
      v_Err_Msg := '[ZLSOFT]该单据已经被他人审核！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Update 药品收发记录
    Set 配药人 = Nvl(审核人_In, 配药人), 配药日期 = 审核日期_In, 实际数量 = 实际数量_In, 成本价 = 成本价_In, 成本金额 = 成本金额_In, 零售金额 = 零售金额_In, 差价 = 差价_In,
        扣率 = v_上次扣率
    Where NO = No_In And 单据 = 20 And 药品id = 材料id_In And 序号 = 序号_In And 记录状态 = 1 And 配药人 Is Null;
  
    Zl_未审药品记录_Delete(n_药品收发记录id);
  End If;

  If 批次_In > 0 And (n_可用数量 + n_数量差) < 0 Then
    Select 编码 Into v_编码 From 收费项目目录 Where ID = 材料id_In;
    v_Err_Msg := '[ZLSOFT]编码为' || v_编码 || ',批号为' || 批号_In || '的分批核算材料' || Chr(10) || Chr(13) || '可用库存数量不够！[ZLSOFT]';
    Raise Err_Item;
  End If;

  Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = 材料id_In;

  If 审核方式_In = 0 Then
    --审核
    If v_下库存 = 0 Then
      n_数量差 := -1 * 实际数量_In;
    End If;
  Else
    --核查
    If v_下库存 = 0 Then
      n_数量差 := 0;
    End If;
  End If;

  If 审核方式_In = 0 Then
    --出库审核处理实际库存
    Update 药品库存
    Set 可用数量 = Nvl(可用数量, 0) + n_数量差, 实际数量 = Nvl(实际数量, 0) - 实际数量_In, 实际金额 = Nvl(实际金额, 0) - 零售金额_In,
        实际差价 = Nvl(实际差价, 0) - 差价_In,
        零售价 = Decode(n_实价卫材, 1, Decode(Nvl(批次_In, 0), 0, Null, Decode(Nvl(零售价, 0), 0, n_零售价, 零售价)), Null), 商品条码 = v_商品条码,
        内部条码 = v_内部条码
    Where 库房id = 库房id_In And 药品id = 材料id_In And Nvl(批次, 0) = Nvl(批次_In, 0) And 性质 = 1;
  
    If Sql%NotFound Then
      Insert Into 药品库存
        (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 效期, 灭菌效期, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 批准文号, 零售价, 上次扣率,
         商品条码, 内部条码, 平均成本价)
      Values
        (库房id_In, 材料id_In, 批次_In, 1, -实际数量_In, -实际数量_In, -零售金额_In, -差价_In, d_效期, d_灭菌效期, n_上次供应商id, 成本价_In, 批号_In,
         d_上次生产日期, 产地_In, v_批准文号, Decode(n_实价卫材, 1, Decode(Nvl(批次_In, 0), 0, Null, n_零售价), Null), v_上次扣率, v_商品条码, v_内部条码,
         成本价_In);
    End If;
  
    Delete From 药品库存
    Where 库房id = 库房id_In And 药品id = 材料id_In And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
          Nvl(实际差价, 0) = 0;
  
    --出库房，平均成本价为空时需要重新计算库存表中的平均成本价
    Update 药品库存
    Set 平均成本价 = 成本价_In
    Where 药品id = 材料id_In And Nvl(批次, 0) = Nvl(批次_In, 0) And 库房id = 库房id_In And 性质 = 1 And Nvl(平均成本价, 0) = 0;
  
  Elsif 审核方式_In = 1 Then
    --财务审核仅处理可用库存
    Update 药品库存
    Set 可用数量 = Nvl(可用数量, 0) + n_数量差
    Where 库房id = 库房id_In And 药品id = 材料id_In And Nvl(批次, 0) = Nvl(批次_In, 0) And 性质 = 1;
  End If;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料领用_Verify;
/

--117925:刘涛,2017-12-07,排序导致死锁处理
Create Or Replace Procedure Zl_材料移库_Delete
(
  No_In       In 药品收发记录.No%Type,
  记录状态_In In 药品收发记录.记录状态%Type := 1
) Is
  v_发送 药品收发记录.配药日期%Type;

  v_Err_Msg Varchar2(200);
  Err_Item Exception;
  v_下库存   Zlparameters.参数值%Type;
  n_实价卫材 收费项目目录.是否变价%Type;

  Cursor c_药品收发记录 Is
    Select 实际数量, 零售价, 库房id, Nvl(批次, 0) As 批次, 药品id, 批号, 效期, 产地, 供药单位id, 成本价, 灭菌效期, 生产日期, 批准文号 
    From 药品收发记录
    Where NO = No_In And 单据 = 19 And 入出系数 = -1
    Order By 药品id,批次;

  Cursor c_申请冲销记录 Is
    Select (-1 * 实际数量) 实际数量, 库房id, Nvl(批次, 0) As 批次, 药品id, 批号, 效期, 产地, 供药单位id, 批准文号, 成本价, 生产日期 
    From 药品收发记录
    Where NO = No_In And 单据 = 19 And 入出系数 = 1 And 记录状态 = 记录状态_In
    Order By 药品id,批次;
Begin
  Select Nvl(Zl_Getsysparameter(95), '0') Into v_下库存 From Dual;

  If 记录状态_In = 1 Then
    --检查是否已发送，已发送的单据需要还原可用数量 
    Select 配药日期 Into v_发送 From 药品收发记录 Where 单据 = 19 And NO = No_In And Rownum < 2;
  
    If v_发送 Is Not Null Or To_Number(v_下库存, '9999') = 1 Then
      --通过循环，恢复原来的可用数量 
      For c_单据 In c_药品收发记录 Loop
        Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = c_单据.药品id;
      
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) + c_单据.实际数量
        Where 库房id = c_单据.库房id And 药品id = c_单据.药品id And Nvl(批次, 0) = Nvl(c_单据.批次, 0) And 性质 = 1;
      
        If Sql%NotFound Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 可用数量, 效期, 灭菌效期, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 批准文号, 零售价)
          Values
            (c_单据.库房id, c_单据.药品id, c_单据.批次, 1, c_单据.实际数量, c_单据.效期, c_单据.灭菌效期, c_单据.供药单位id, c_单据.成本价, c_单据.批号, c_单据.生产日期,
             c_单据.产地, c_单据.批准文号, Decode(n_实价卫材, 1, Decode(Nvl(c_单据.批次, 0), 0, Null, c_单据.零售价), Null));
        End If;
      
        Delete From 药品库存
        Where 库房id = c_单据.库房id And 药品id = c_单据.药品id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
              Nvl(实际差价, 0) = 0;
      End Loop;
    End If;
  Else
    --处理移库申请冲销单据 
  
    --如果参数值为1也要恢复原来的可用数量 
    If v_下库存 = '1' Then
      --通过循环，恢复原来的可用数量 
      For v_申请冲销记录 In c_申请冲销记录 Loop
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) + v_申请冲销记录.实际数量
        Where 库房id = v_申请冲销记录.库房id And 药品id = v_申请冲销记录.药品id And Nvl(批次, 0) = v_申请冲销记录.批次 And 性质 = 1;
      
        If Sql%NotFound Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 可用数量, 上次批号, 效期, 上次产地, 上次供应商id, 批准文号, 上次采购价, 上次生产日期)
          Values
            (v_申请冲销记录.库房id, v_申请冲销记录.药品id, v_申请冲销记录.批次, 1, v_申请冲销记录.实际数量, v_申请冲销记录.批号, v_申请冲销记录.效期, v_申请冲销记录.产地,
             v_申请冲销记录.供药单位id, v_申请冲销记录.批准文号, v_申请冲销记录.成本价, v_申请冲销记录.生产日期);
        End If;
      
        Delete From 药品库存
        Where 库房id = v_申请冲销记录.库房id And 药品id = v_申请冲销记录.药品id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And
              Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0;
      End Loop;
    End If;
  End If;

  Delete --把入和出两种类别的移库单都删除 
  From 药品收发记录
  Where NO = No_In And 单据 = 19 And 记录状态 = 记录状态_In And 审核人 Is Null;

  If Sql%RowCount = 0 Then
    v_Err_Msg := '[ZLSOFT]该单据已经被他人删除或已被人审核！[ZLSOFT]';
    Raise Err_Item;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料移库_Delete;
/

--117925:刘涛,2017-12-07,排序导致死锁处理
CREATE OR REPLACE Procedure Zl_材料库存差价调整_Verify
(
  No_In     In 药品收发记录.NO%Type := Null,
  审核人_In In 药品收发记录.审核人%Type := Null
) Is
  Err_Item Exception;
  v_Err_Msg Varchar2(100);

  Cursor c_材料单据信息 Is
    Select 库房id, 药品id 材料id, 批次, 入出类别id, 差价, 产地, 效期, 灭菌效期, 成本价,单量 as 新成本价, 供药单位id, 生产日期, 批准文号,
           批号
    From 药品收发记录
    Where NO = No_In And 单据 = 18 And 记录状态 = 1
    Order By 药品id, 批次;
Begin
  Update 药品收发记录
  Set 审核人 = 审核人_In, 审核日期 = Sysdate
  Where NO = No_In And 单据 = 18 And 记录状态 = 1 And 审核人 Is Null;

  If Sql%RowCount = 0 Then
    v_Err_Msg := '[ZLSOFT]该单据已经被他人审核！[ZLSOFT]';
    Raise Err_Item;
  End If;

  For c_单据 In c_材料单据信息 Loop
    --更改药品库存表的相应数据

    Update 药品库存
    Set 实际差价 = Nvl(实际差价, 0) + Nvl(c_单据.差价, 0),上次采购价=c_单据.新成本价,平均成本价=c_单据.新成本价
    Where 库房id = c_单据.库房id And 药品id = c_单据.材料id And Nvl(批次, 0) = Nvl(c_单据.批次, 0) And 性质 = 1;

    If Sql%NotFound Then

      Insert Into 药品库存
        (库房id, 药品id, 批次, 性质, 实际差价, 效期, 灭菌效期, 上次供应商id, 上次采购价, 上次批号, 上次生产日期,
         上次产地, 批准文号,平均成本价)
      Values
        (c_单据.库房id, c_单据.材料id, c_单据.批次, 1, c_单据.差价, c_单据.效期, c_单据.灭菌效期, c_单据.供药单位id,
         c_单据.新成本价, c_单据.批号, c_单据.生产日期, c_单据.产地, c_单据.批准文号,c_单据.新成本价);
    End If;

    Delete From 药品库存
    Where 库房id = c_单据.库房id And 药品id = c_单据.材料id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And
          Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0;
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料库存差价调整_Verify;
/

--117925:刘涛,2017-12-07,排序导致死锁处理
Create Or Replace Procedure Zl_材料其他出库_Delete(
                                             --删除药品收发记录及恢复相应的表：药品库存
                                             No_In In 药品收发记录.No%Type) Is
  v_Err_Msg Varchar2(500);
  Err_Item Exception;
  n_实价卫材 收费项目目录.是否变价%Type;
  v_下库存   Zlparameters.参数值%Type;
Begin
  Select Nvl(Zl_Getsysparameter(95), '0') Into v_下库存 From Dual;

  --通过循环，恢复原来的可用数量
  If To_Number(v_下库存, '9999') = 1 Then
    For c_单据 In (Select 填写数量, 库房id, 零售价, 批次, 效期, 灭菌效期, 药品id 材料id, 成本价, 供药单位id, 生产日期, 批号, 批准文号, 产地
                 From 药品收发记录
                 Where NO = No_In And 单据 = 21
                 Order By 药品id, 批次) Loop
      Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = c_单据.材料id;
    
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) + c_单据.填写数量,
          零售价 = Decode(n_实价卫材, 1, Decode(Nvl(c_单据.批次, 0), 0, Null, Decode(Nvl(零售价, 0), 0, c_单据.零售价, 零售价)), Null)
      Where 库房id = c_单据.库房id And 药品id = c_单据.材料id And Nvl(批次, 0) = Nvl(c_单据.批次, 0) And 性质 = 1;
    
      If Sql%NotFound Then
      
        Insert Into 药品库存
          (库房id, 药品id, 批次, 性质, 可用数量, 效期, 灭菌效期, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 批准文号, 零售价)
        Values
          (c_单据.库房id, c_单据.材料id, c_单据.批次, 1, c_单据.填写数量, c_单据.效期, c_单据.灭菌效期, c_单据.供药单位id, c_单据.成本价, c_单据.批号, c_单据.生产日期,
           c_单据.产地, c_单据.批准文号, Decode(n_实价卫材, 1, Decode(Nvl(c_单据.批次, 0), 0, Null, c_单据.零售价), Null));
      End If;
    
      Delete From 药品库存
      Where 库房id = c_单据.库房id And 药品id = c_单据.材料id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
            Nvl(实际差价, 0) = 0;
    End Loop;
  End If;

  Delete From 药品收发记录 Where NO = No_In And 单据 = 21 And 记录状态 = 1 And 审核人 Is Null;

  If Sql%RowCount = 0 Then
    v_Err_Msg := '[ZLSOFT]该单据已经被他人删除或已被人审核！[ZLSOFT]';
    Raise Err_Item;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料其他出库_Delete;
/

--117925:刘涛,2017-12-07,排序导致死锁处理
Create Or Replace Procedure Zl_材料自制原料出库_Insert
(
  No_In         In 药品收发记录.NO%Type,
  对方部门id_In In 药品收发记录.对方部门id%Type
) As
  v_Err_Msg Varchar2(100);
  Err_Item Exception;

  n_数量       药品收发记录.实际数量%Type;
  n_成本价     药品收发记录.成本价%Type;
  n_成本金额   药品收发记录.成本金额%Type;
  n_差价       药品收发记录.差价%Type;
  n_售价       药品收发记录.零售价%Type;
  n_零售金额   药品收发记录.零售金额%Type;
  n_库存金额   药品库存.实际金额%Type;
  n_库存差价   药品库存.实际差价%Type;
  n_可用数量   药品库存.可用数量%Type;
  n_实际数量   药品库存.实际数量%Type;
  n_出的类别id 药品收发记录.入出类别id%Type; --入出类别ID
  n_Max_序号   药品收发记录.序号%Type;
  v_Lngid  药品收发记录.Id%Type; --收发ID 

  v_上次产地   药品库存.上次产地%Type;
  v_负成本计算 zlParameters.参数值%Type;
Begin
  Select B.ID
  Into n_出的类别id
  From 药品单据性质 A, 药品入出类别 B
  Where A.类别id = B.ID And A.单据 = 31 And B.系数 = -1 And Rownum < 2;

  Select zl_GetSysParameter(120) Into v_负成本计算 From Dual;

  Select Max(序号) Into n_Max_序号 From 药品收发记录 Where NO = No_In And 单据 = 16 And 入出系数 = 1;

  For v_自制 In (Select * From 药品收发记录 Where NO = No_In And 单据 = 16 And 入出系数 = 1 Order By 药品id, 批次) Loop

    For v_组成 In (Select A.*, B.是否变价, C.指导差价率, C.成本价
                   From 自制材料构成 A, 收费项目目录 B, 材料特性 C
                   Where A.原料材料id = B.ID And A.自制材料id = v_自制.药品id And A.原料材料id = C.材料id
				   Order By A.原料材料id) Loop

      Begin
        Select 可用数量, 实际数量, 实际差价, 实际金额, 上次产地
        Into n_可用数量, n_实际数量, n_库存差价, n_库存金额, v_上次产地
        From 药品库存
        Where 药品id = v_组成.原料材料id And 性质 = 1 And 库房id = 对方部门id_In;
      Exception
        When Others Then
          n_可用数量 := 0;
          n_实际数量 := 0;
          n_库存差价 := 0;
          n_库存金额 := 0;
      End;
      If Nvl(v_组成.是否变价, 0) = 1 Then
        --实价
        If Nvl(n_实际数量, 0) > 0 Then
          n_售价 := Nvl(n_库存金额, 0) / n_实际数量;
        Else
          --无库数:需提示
          v_Err_Msg := '[ZLSOFT]该单据中存在一笔以上原料的实际数量不足[ZLSOFT]';
          Raise Err_Item;
        End If;
      Else
        --定价,以现价为准
        Begin
          Select Nvl(现价, 0)
          Into n_售价
          From 收费价目
          Where 收费细目id = v_组成.原料材料id And
                ((Sysdate Between 执行日期 And 终止日期) Or (Sysdate >= 执行日期 And 终止日期 Is Null));

        Exception
          When Others Then
            v_Err_Msg := 'Err';
        End;
        If v_Err_Msg = 'Err' Then
          v_Err_Msg := '[ZLSOFT]该单据中存在一笔以上原料还未进行定价！[ZLSOFT]';
          Raise Err_Item;
        End If;
      End If;
      n_数量 := Nvl(v_自制.实际数量, 0) * v_组成.分子 / v_组成.分母;

      If n_数量 = 0 Then
        v_Err_Msg := '[ZLSOFT]该单据中存在一笔以上原料的数量为零了！[ZLSOFT]';
        Raise Err_Item;
      End If;
      n_零售金额 := n_数量 * n_售价;

      --算成本价
      If Nvl(n_库存金额, 0) <= 0 Then
        If v_负成本计算 = '1' And Nvl(v_组成.成本价, 0) > 0 Then
          n_成本价 := v_组成.成本价;
          n_差价   := n_零售金额 - n_数量 * n_成本价;
        Else
          n_差价   := n_零售金额 * v_组成.指导差价率 / 100;
          n_成本价 := (n_零售金额 - n_差价) / n_数量;
        End If;
      Else
        n_差价   := n_零售金额 * (n_库存差价 / n_库存金额);
        n_成本价 := (n_零售金额 - n_差价) / n_数量;
      End If;
      n_成本价 := Nvl(n_成本价, 0);

      n_成本金额 := n_成本价 * n_数量;
      n_Max_序号 := n_Max_序号 + 1;
      
      Select 药品收发记录_Id.Nextval Into v_Lngid from dual;
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 产地, 填写数量, 实际数量,
         成本价, 成本金额, 零售价, 零售金额, 差价, 摘要, 填制人, 填制日期, 费用id, 扣率)
      Values
        (v_Lngid, 1, 16, No_In, n_Max_序号, v_自制.对方部门id, v_自制.库房id, n_出的类别id, -1,
         v_组成.原料材料id, v_上次产地, n_数量, n_数量, n_成本价, n_成本金额, n_售价, n_零售金额, n_差价, v_自制.摘要,
         v_自制.填制人, v_自制.填制日期, v_自制.药品id, v_自制.序号);
      
      Zl_未审药品记录_Insert(v_Lngid);
      --IF n_可用数量<0 then
      --    v_Err_Msg:='[ZLSOFT]该单据中存在一笔以上原料的可用数量不足[ZLSOFT]';
      --    RAISE Err_Item;
      --End IF ;

      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) - n_数量
      Where 库房id = v_自制.对方部门id And 药品id = v_组成.原料材料id And 性质 = 1;

      If Sql%NotFound Then
        Insert Into 药品库存
          (库房id, 药品id, 性质, 可用数量)
        Values
          (v_自制.对方部门id, v_组成.原料材料id, 1, -n_数量);
      End If;

      Delete From 药品库存
      Where 库房id = v_自制.对方部门id And 药品id = v_组成.原料材料id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And
            Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0;

    End Loop;
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料自制原料出库_Insert;
/

--117925:刘涛,2017-12-07,排序导致死锁处理
Create Or Replace Procedure Zl_自制材料入库_Insert
(
  No_In         In 药品收发记录.No%Type,
  序号_In       In 药品收发记录.序号%Type,
  库房id_In     In 药品收发记录.库房id%Type,
  对方部门id_In In 药品收发记录.对方部门id%Type,
  材料id_In     In 药品收发记录.药品id%Type,
  实际数量_In   In 药品收发记录.实际数量%Type,
  零售价_In     In 药品收发记录.零售价%Type,
  零售金额_In   In 药品收发记录.零售金额%Type,
  填制人_In     In 药品收发记录.填制人%Type,
  批号_In       In 药品收发记录.批号%Type := Null,
  效期_In       In 药品收发记录.效期%Type := Null,
  灭菌日期_In   In 药品收发记录.灭菌日期%Type := Null,
  灭菌效期_In   In 药品收发记录.灭菌效期%Type := Null,
  摘要_In       In 药品收发记录.摘要%Type := Null,
  填制日期_In   In 药品收发记录.填制日期%Type := Null,
  记录数_In     In Integer := 0
) Is
  Err_Item Exception;
  v_Err_Msg Varchar2(100);

  n_Id         药品收发记录.Id%Type; --收发ID
  n_出库类别id 药品收发记录.入出类别id%Type; --入出类别ID
  n_入的类别id 药品收发记录.入出类别id%Type; --入出类别ID
  n_剩余数量   药品库存.可用数量%Type;
  n_当前数量   药品收发记录.实际数量%Type;
  n_售价       药品收发记录.零售价%Type;
  n_现价       收费价目.现价%Type;
  n_零售金额   药品收发记录.零售金额%Type;
  n_成本价     药品收发记录.成本价%Type;
  n_成本金额   药品收发记录.成本金额%Type;
  n_总出库成本 药品收发记录.成本金额%Type;
  n_差价       药品收发记录.差价%Type;
  n_出序号     药品收发记录.序号%Type;
  n_最后出库id 药品收发记录.Id%Type;
  n_实价卫材   收费项目目录.是否变价%Type;
  n_库房分批   Integer; --是否分批核算   1:分批;0：不分批
  n_在用分批   Integer; --在用分批
  n_批次       药品收发记录.批次%Type := Null; --批次
  v_负成本计算 Zlparameters.参数值%Type;
Begin
  -------------------------------------------------------------------------------------------
  --1.先处理原料出库部分
  Select b.Id
  Into n_出库类别id
  From 药品单据性质 A, 药品入出类别 B
  Where a.类别id = b.Id And a.单据 = 31 And b.系数 = -1 And Rownum < 2;

  Select Zl_Getsysparameter(120) Into v_负成本计算 From Dual;

  Select Max(序号) Into n_出序号 From 药品收发记录 Where NO = No_In And 单据 = 16 And 入出系数 = -1;
  If Nvl(n_出序号, 0) < 记录数_In Then
    n_出序号 := 记录数_In;
  End If;
  n_总出库成本 := 0;
  For v_组成 In (Select a.*, b.是否变价, c.指导差价率, c.成本价, c.在用分批
               From 自制材料构成 A, 收费项目目录 B, 材料特性 C
               Where a.原料材料id = b.Id And a.自制材料id = 材料id_In And a.原料材料id = c.材料id
			   Order By a.原料材料id) Loop
    n_剩余数量 := Round(实际数量_In * v_组成.分子 / v_组成.分母, 7);
  
    If n_剩余数量 = 0 Then
      v_Err_Msg := '[ZLSOFT]该单据中存在一笔以上原料的数量为零了！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    If Nvl(v_组成.是否变价, 0) = 0 Then
      --定价处理
      Begin
        Select Nvl(现价, 0)
        Into n_现价
        From 收费价目
        Where 收费细目id = v_组成.原料材料id And ((Sysdate Between 执行日期 And 终止日期) Or (Sysdate >= 执行日期 And 终止日期 Is Null));
      Exception
        When Others Then
          v_Err_Msg := 'Err';
      End;
      If Nvl(v_Err_Msg, ' ') = 'Err' Then
        v_Err_Msg := '[ZLSOFT]该单据中存在一笔以上原料还未进行定价！[ZLSOFT]';
        Raise Err_Item;
      End If;
    Else
      n_现价 := 0;
    End If;
    n_最后出库id := -1;
    --按先进先出法原则出库
    For v_库存 In (Select Nvl(批次, 0) As 批次, Max(零售价) As 零售价, Sum(Nvl(可用数量, 0)) As 可用数量, Sum(Nvl(实际数量, 0)) As 实际数量,
                        Sum(Nvl(实际差价, 0)) As 实际差价, Sum(Nvl(实际金额, 0)) As 实际金额, Max(上次产地) As 上次产地, Max(上次批号) As 上次批号,
                        Max(上次生产日期) As 上次生产日期, Max(效期) As 效期, Max(灭菌效期) As 灭菌效期, Max(批准文号) As 批准文号
                 From 药品库存
                 Where 药品id = v_组成.原料材料id And 性质 = 1 And 库房id = 对方部门id_In
                 Group By Nvl(批次, 0)
                 Order By Nvl(批次, 0)) Loop
    
      Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = v_组成.原料材料id;
    
      If Nvl(v_组成.是否变价, 0) = 1 Then
        --实价处理
        If Nvl(v_库存.实际数量, 0) > 0 Then
          If Nvl(v_库存.批次, 0) <> 0 And Nvl(v_库存.零售价, 0) <> 0 Then
            --分批实价，如果库存有零售价，则只能以零售价为准.
            n_售价 := Nvl(v_库存.零售价, 0);
          Else
            n_售价 := Nvl(v_库存.实际金额, 0) / v_库存.实际数量;
          End If;
        Else
          --无库数:需提示
          v_Err_Msg := '[ZLSOFT]该单据中存在一笔以上原料的实际数量不足[ZLSOFT]';
          Raise Err_Item;
        End If;
      Else
        n_售价 := n_现价;
      End If;
      If Nvl(v_库存.可用数量, 0) >= n_剩余数量 Then
        n_当前数量 := n_剩余数量;
      Else
        n_当前数量 := Nvl(v_库存.可用数量, 0);
      End If;
      n_零售金额 := Round(n_当前数量 * n_售价, 7);
    
      --算成本价
      If Nvl(v_库存.实际金额, 0) <= 0 Then
        If v_负成本计算 = '1' And Nvl(v_组成.成本价, 0) > 0 Then
          n_成本价 := v_组成.成本价;
          n_差价   := Round(n_零售金额 - n_当前数量 * n_成本价, 7);
        Else
          n_差价   := n_零售金额 * v_组成.指导差价率 / 100;
          n_成本价 := (n_零售金额 - n_差价) / n_当前数量;
        End If;
      Else
        n_差价   := n_零售金额 * (v_库存.实际差价 / v_库存.实际金额);
        n_成本价 := (n_零售金额 - n_差价) / n_当前数量;
      End If;
      n_成本价     := Nvl(n_成本价, 0);
      n_成本金额   := n_成本价 * n_当前数量;
      n_总出库成本 := n_总出库成本 + n_成本金额;
    
      n_出序号 := n_出序号 + 1;
      Select 药品收发记录_Id.Nextval Into n_最后出库id From Dual;
    
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 批号, 效期, 灭菌效期, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 零售金额, 差价,
         摘要, 填制人, 填制日期, 费用id, 扣率)
      Values
        (n_最后出库id, 1, 16, No_In, n_出序号, 对方部门id_In, 库房id_In, n_出库类别id, -1, v_组成.原料材料id,
         Decode(v_库存.批次, 0, Null, v_库存.批次), v_库存.上次批号, v_库存.效期, v_库存.灭菌效期, Nvl(n_当前数量, 0), n_当前数量, n_成本价, n_成本金额, n_售价,
         n_零售金额, n_差价, 摘要_In, 填制人_In, 填制日期_In, 材料id_In, 序号_In);
      
      Zl_未审药品记录_Insert(n_最后出库id);
      
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) - n_当前数量
      Where 库房id = 对方部门id_In And 药品id = v_组成.原料材料id And Nvl(批次, 0) = Nvl(v_库存.批次, 0) And 性质 = 1;
    
      If Sql%NotFound Then
        Insert Into 药品库存
          (库房id, 药品id, 批次, 性质, 可用数量, 零售价)
        Values
          (对方部门id_In, v_组成.原料材料id, Decode(Nvl(v_库存.批次, 0), 0, Null, v_库存.批次), 1, -n_当前数量,
           Decode(n_实价卫材, 1, Decode(Nvl(v_库存.批次, 0), 0, Null, n_售价), Null));
      End If;
    
      Delete From 药品库存
      Where 库房id = 对方部门id_In And 药品id = v_组成.原料材料id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
            Nvl(实际差价, 0) = 0;
      n_剩余数量 := n_剩余数量 - Nvl(v_库存.可用数量, 0);
      If n_剩余数量 <= 0 Then
        Exit;
      End If;
    End Loop;
  
    If n_剩余数量 > 0 Then
      --比库存数还多,需要将剩余数量加入
      If Nvl(v_组成.是否变价, 0) = 1 Or Nvl(v_组成.在用分批, 0) = 1 Then
        --实价或在用分批必需要有库存
        v_Err_Msg := '[ZLSOFT]该单据中存在一笔以上原料的可用数量不足，请检查[ZLSOFT]';
        Raise Err_Item;
      End If;
    
      If n_最后出库id = -1 Then
        --表示根本没有库存，需要处理相关的数量
        n_售价     := n_现价;
        n_零售金额 := Round(n_剩余数量 * n_售价, 7);
        If v_负成本计算 = '1' And Nvl(v_组成.成本价, 0) > 0 Then
          n_成本价 := v_组成.成本价;
          n_差价   := Round(n_零售金额 - n_剩余数量 * n_成本价, 7);
        Else
          n_差价   := n_零售金额 * v_组成.指导差价率 / 100;
          n_成本价 := (n_零售金额 - n_差价) / n_剩余数量;
        End If;
        n_成本价     := Nvl(n_成本价, 0);
        n_成本金额   := n_成本价 * n_剩余数量;
        n_总出库成本 := n_总出库成本 + n_成本金额;
      
        n_出序号 := n_出序号 + 1;
        Select 药品收发记录_Id.Nextval Into n_最后出库id From Dual;
      
        Insert Into 药品收发记录
          (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 批号, 效期, 灭菌效期, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 零售金额,
           差价, 摘要, 填制人, 填制日期, 费用id, 扣率)
        Values
          (n_最后出库id, 1, 16, No_In, n_出序号, 对方部门id_In, 库房id_In, n_出库类别id, -1, v_组成.原料材料id, Null, Null, Null, Null, n_剩余数量,
           n_剩余数量, n_成本价, n_成本金额, n_售价, n_零售金额, n_差价, 摘要_In, 填制人_In, 填制日期_In, 材料id_In, 序号_In);
        
        Zl_未审药品记录_Insert(n_最后出库id);
      Else
        --还存在剩余
        Select 成本价, 零售价, 零售金额, 差价, 填写数量, 成本金额
        Into n_成本价, n_售价, n_零售金额, n_差价, n_当前数量, n_成本金额
        From 药品收发记录
        Where ID = n_最后出库id;
      
        Update 药品收发记录
        Set 填写数量 = Nvl(填写数量, 0) + n_剩余数量, 实际数量 = Nvl(实际数量, 0) + n_剩余数量, 成本价 = Nvl(n_成本价, 0),
            成本金额 = Nvl(n_成本价, 0) * (n_当前数量 + n_剩余数量), 零售价 = n_售价, 零售金额 = n_售价 * (n_当前数量 + n_剩余数量),
            差价 = Round((n_售价 * (n_当前数量 + n_剩余数量)) - (Nvl(n_成本价, 0) * (n_当前数量 + n_剩余数量)), 7)
        Where ID = n_最后出库id;
        n_总出库成本 := (n_总出库成本 - n_成本金额) + Nvl(n_成本价, 0) * (n_当前数量 + n_剩余数量);
      
      End If;
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) - n_剩余数量
      Where 库房id = 对方部门id_In And 药品id = v_组成.原料材料id And Nvl(批次, 0) = 0 And 性质 = 1;
    
      If Sql%NotFound Then
        Insert Into 药品库存
          (库房id, 药品id, 性质, 可用数量, 零售价)
        Values
          (对方部门id_In, v_组成.原料材料id, 1, -n_剩余数量, Null);
      End If;
    
      Delete From 药品库存
      Where 库房id = 对方部门id_In And 药品id = v_组成.原料材料id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
            Nvl(实际差价, 0) = 0;
    End If;
  End Loop;

  n_成本价 := n_总出库成本 / 实际数量_In;
  n_差价   := 零售金额_In - n_总出库成本;

  Select 药品收发记录_Id.Nextval Into n_Id From Dual;

  --确定是否分批  
  Select Nvl(库房分批, 0), Nvl(在用分批, 0) Into n_库房分批, n_在用分批 From 材料特性 Where 材料id = 材料id_In;

  If n_在用分批 = 0 Then
    If n_库房分批 = 1 Then
      Begin
        Select Distinct 0
        Into n_库房分批
        From 部门性质说明
        Where (工作性质 = '发料部门' Or 工作性质 Like '制剂室') And 部门id = 库房id_In;
      Exception
        When Others Then
          n_库房分批 := 1;
      End;
    
      If n_库房分批 = 1 Then
        n_批次 := n_Id;
      End If;
    End If;
  Else
    n_批次 := n_Id;
  End If;

  Select b.Id
  Into n_入的类别id
  From 药品单据性质 A, 药品入出类别 B
  Where a.类别id = b.Id And a.单据 = 31 And b.系数 = 1 And Rownum < 2;

  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 批号, 效期, 灭菌日期, 灭菌效期, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 零售金额,
     差价, 摘要, 填制人, 填制日期)
  Values
    (n_Id, 1, 16, No_In, 序号_In, 库房id_In, 对方部门id_In, n_入的类别id, 1, 材料id_In, n_批次, 批号_In, 效期_In, 灭菌日期_In, 灭菌效期_In, 实际数量_In,
     实际数量_In, n_成本价, n_总出库成本, 零售价_In, 零售金额_In, n_差价, 摘要_In, 填制人_In, 填制日期_In);
  
  Zl_未审药品记录_Insert(n_Id);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_自制材料入库_Insert;
/

--117925:刘涛,2017-12-07,排序导致死锁处理
Create Or Replace Procedure Zl_自制材料入库_Strike
(
  No_In     In 药品收发记录.No%Type,
  审核人_In In 药品收发记录.审核人%Type
) Is
  Err_Item Exception;
  v_Err_Msg    Varchar2(500);
  n_实价卫材   收费项目目录.是否变价%Type;
  n_平均成本价 药品库存.平均成本价%Type;

Begin
  Update 药品收发记录 Set 记录状态 = 3 Where NO = No_In And 单据 = 16 And 记录状态 = 1;

  If Sql%RowCount = 0 Then
    v_Err_Msg := '[ZLSOFT]该单据已经被他人冲销！[ZLSOFT]';
    Raise Err_Item;
  End If;
  
  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 对方部门id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 零售金额, 差价, 摘要,
     填制人, 填制日期, 审核人, 审核日期, 费用id, 扣率)
    Select 药品收发记录_Id.Nextval, 2, 16, No_In, 序号, 库房id, 入出类别id, 对方部门id, 入出系数, 药品id, 批次, 产地, 批号, 效期, -填写数量, -实际数量, 成本价,
           -成本金额, 零售价, -零售金额, -差价, 摘要, 审核人_In, Sysdate, 审核人_In, Sysdate, 费用id, 扣率
    From 药品收发记录
    Where NO = No_In And 单据 = 16 And 记录状态 = 3;
    

  For c_单据 In (Select ID, 库房id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 零售价, 填写数量, 实际数量, 成本价, 零售金额, 差价
               From 药品收发记录 A
               Where NO = No_In And 单据 = 16 And 记录状态 = 2
			   Order By 药品id,批次) Loop
  
    Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = c_单据.药品id;
  
    --更改材料库存表的相应数据
    --自制材料与原料材料的处理通过入出系数来实现
    Update 药品库存
    Set 可用数量 = Nvl(可用数量, 0) + Nvl(c_单据.填写数量, 0) * c_单据.入出系数, 实际数量 = Nvl(实际数量, 0) + Nvl(c_单据.填写数量, 0) * c_单据.入出系数,
        实际金额 = Nvl(实际金额, 0) + Nvl(c_单据.零售金额, 0) * c_单据.入出系数, 实际差价 = Nvl(实际差价, 0) + Nvl(c_单据.差价, 0) * c_单据.入出系数,
        上次采购价 = Nvl(c_单据.成本价, 上次采购价), 上次批号 = Nvl(c_单据.批号, 上次批号), 上次产地 = Nvl(c_单据.产地, 上次产地), 效期 = Nvl(c_单据.效期, 效期),
        零售价 = Decode(n_实价卫材, 1, Decode(Nvl(c_单据.批次, 0), 0, Null, Decode(Nvl(零售价, 0), 0, c_单据.零售价, 零售价)), Null)
    Where 库房id = c_单据.库房id And 药品id = c_单据.药品id And Nvl(批次, 0) = Nvl(c_单据.批次, 0) And 性质 = 1;
  
    If Sql%NotFound Then
      Insert Into 药品库存
        (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次采购价, 上次批号, 上次产地, 效期, 零售价, 平均成本价)
      Values
        (c_单据.库房id, c_单据.药品id, c_单据.批次, 1, c_单据.填写数量 * c_单据.入出系数, c_单据.填写数量 * c_单据.入出系数, c_单据.零售金额 * c_单据.入出系数,
         c_单据.差价 * c_单据.入出系数, c_单据.成本价, c_单据.批号, c_单据.产地, c_单据.效期,
         Decode(n_实价卫材, 1, Decode(Nvl(c_单据.批次, 0), 0, Null, c_单据.零售价), Null), c_单据.成本价);
    End If;
  
    Delete From 药品库存
    Where 库房id = c_单据.库房id And 药品id = c_单据.药品id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
          Nvl(实际差价, 0) = 0;
  
    --重新计算库存表中的平均成本价
    Update 药品库存
    Set 平均成本价 = Decode(Nvl(批次, 0), 0, Decode((实际金额 - 实际差价) / 实际数量, 0, 上次采购价, (实际金额 - 实际差价) / 实际数量), 上次采购价)
    Where 性质 = 1 And 库房id = c_单据.库房id And 药品id = c_单据.药品id And Nvl(批次, 0) = Nvl(c_单据.批次, 0) And Nvl(实际数量, 0) <> 0;
    If Sql%NotFound Then
      Select 成本价 Into n_平均成本价 From 材料特性 Where 材料id = c_单据.药品id;
      Update 药品库存
      Set 平均成本价 = n_平均成本价
      Where 性质 = 1 And 库房id = c_单据.库房id And 药品id = c_单据.药品id And Nvl(批次, 0) = Nvl(c_单据.批次, 0) And
            Nvl(平均成本价, 0) <> c_单据.成本价;
    End If;
    Zl_材料收发记录_调价修正(c_单据.Id);
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_自制材料入库_Strike;
/

--117925:刘涛,2017-12-07,排序导致死锁处理
Create Or Replace Procedure Zl_自制材料入库_Verify
(
  No_In     In 药品收发记录.No%Type := Null,
  审核人_In In 药品收发记录.审核人%Type := Null
) Is
  Err_Item Exception;
  v_Err_Msg Varchar2(100);

  v_负成本计算 Zlparameters.参数值%Type;

  n_实际库存金额 药品库存.实际金额%Type;
  n_实际库存差价 药品库存.实际差价%Type;
  n_实际库存数量 药品库存.实际数量%Type;
  n_出库差价     药品库存.实际差价%Type;
  n_实价卫材     收费项目目录.是否变价%Type;

  n_成本价     药品收发记录.成本价%Type;
  n_成本金额   药品收发记录.成本金额%Type;
  n_差价率     Number(18, 8);
  n_小数       Number(2);
  n_平均成本价 药品库存.平均成本价%Type;

Begin
  Select zl_GetSysParameter(120) Into v_负成本计算 From Dual;

  Update 药品收发记录
  Set 审核人 = Nvl(审核人_In, 审核人), 审核日期 = Sysdate
  Where NO = No_In And 单据 = 16 And 记录状态 = 1 And 审核人 Is Null;

  If Sql%RowCount = 0 Then
    v_Err_Msg := '[ZLSOFT]该单据已经被他人审核！[ZLSOFT]';
    Raise Err_Item;
  End If;

  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into n_小数 From Dual;

  Update 药品收发记录 Set 成本金额 = 0 Where NO = No_In And 单据 = 16 And 记录状态 = 1 And 入出系数 = 1;

  For v_原料 In (Select ID, 实际数量, 零售价, 零售金额, 差价, 库房id, 药品id, 批次, 成本价, 批号, 效期, 产地, 灭菌效期, 批准文号, 生产日期, 入出类别id, 入出系数, 对方部门id,
                      费用id As 自制材料id, Trunc(扣率) As 序号
               From 药品收发记录
               Where NO = No_In And 单据 = 16 And 记录状态 = 1 And 入出系数 = -1
               Order By 药品id, 批次) Loop
  
    Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = v_原料.药品id;
  
    Begin
      Select Nvl(实际金额, 0), Nvl(实际差价, 0), Nvl(实际数量, 0)
      Into n_实际库存金额, n_实际库存差价, n_实际库存数量
      From 药品库存
      Where 药品id = v_原料.药品id And Nvl(批次, 0) = Nvl(v_原料.批次, 0) And 库房id = v_原料.库房id And 性质 = 1 And Rownum = 1;
    Exception
      When Others Then
        n_实际库存金额 := 0;
        n_实际库存数量 := 0;
    End;
  
    If n_实际库存金额 <= 0 Then
      If (n_实际库存金额 - n_实际库存差价) <= 0 Or n_实际库存数量 <= 0 Then
      
        Begin
          Select 指导差价率 / 100 Into n_差价率 From 材料特性 Where 材料id = v_原料.药品id;
        Exception
          When Others Then
            n_差价率 := 0;
        End;
        If v_负成本计算 = '1' Then
          Begin
            Select Nvl(成本价, 0) Into n_成本价 From 材料特性 Where 材料id = v_原料.药品id;
          Exception
            When Others Then
              n_成本价 := 0;
          End;
          If n_成本价 = 0 Then
            n_出库差价 := Round(v_原料.零售金额 * n_差价率, 4);
          Else
            n_出库差价 := Round(v_原料.零售金额 - v_原料.实际数量 * n_成本价, 4);
          End If;
        Else
          n_出库差价 := Round(v_原料.零售金额 * n_差价率, n_小数);
        End If;
      Else
        --主要处理零售价为零的情况，从而造成无成本的问题
        n_成本价   := ((n_实际库存金额 - n_实际库存差价) / n_实际库存数量);
        n_出库差价 := Round(v_原料.零售金额 - n_成本价 * v_原料.实际数量, n_小数);
      End If;
    Else
      n_差价率   := n_实际库存差价 / n_实际库存金额;
      n_出库差价 := Round(v_原料.零售金额 * n_差价率, n_小数);
    End If;
  
    If Nvl(v_原料.实际数量, 0) = 0 Then
      n_成本价 := (v_原料.零售金额 - n_出库差价);
    Else
      n_成本价 := (v_原料.零售金额 - n_出库差价) / v_原料.实际数量;
    End If;
    n_成本价   := Nvl(n_成本价, 0);
    n_成本金额 := Round(n_成本价 * v_原料.实际数量, n_小数);
  
    Update 药品收发记录 Set 成本价 = n_成本价, 成本金额 = n_成本金额, 差价 = n_出库差价 Where ID = v_原料.Id;
  
    Update 药品库存
    Set 实际数量 = Nvl(实际数量, 0) - Nvl(v_原料.实际数量, 0), 实际金额 = Nvl(实际金额, 0) - Nvl(v_原料.零售金额, 0), 实际差价 = Nvl(实际差价, 0) - n_出库差价
    Where 库房id = v_原料.库房id And 药品id = v_原料.药品id And Nvl(批次, 0) = Nvl(v_原料.批次, 0) And 性质 = 1;
    
    If Sql%NotFound Then
      Insert Into 药品库存
        (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次批号, 上次生产日期, 效期, 上次产地, 灭菌效期, 批准文号, 上次采购价, 零售价,平均成本价)
      Values
        (v_原料.库房id, v_原料.药品id, Decode(v_原料.批次, Null, Null, 0, Null, v_原料.批次), 1,
         Decode(v_原料.入出系数, 1, Nvl(v_原料.实际数量, 0), 0), v_原料.实际数量 * v_原料.入出系数, v_原料.零售金额 * v_原料.入出系数, n_出库差价 * v_原料.入出系数,
         v_原料.批号, v_原料.生产日期, v_原料.效期, v_原料.产地, v_原料.灭菌效期, v_原料.批准文号, n_成本价,
         Decode(n_实价卫材, 1, Decode(Nvl(v_原料.批次, 0), 0, Null, v_原料.零售价), Null),n_成本价);
    End If;
    
    Zl_未审药品记录_Delete(v_原料.id);
    
    Delete From 药品库存
    Where 库房id = v_原料.库房id And 药品id = v_原料.药品id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
          Nvl(实际差价, 0) = 0;
  
    Update 药品收发记录
    Set 成本金额 = Nvl(成本金额, 0) + n_成本金额
    Where NO = No_In And 序号 = v_原料.序号 And 药品id = Nvl(v_原料.自制材料id, 0) And 单据 = 16 And 记录状态 = 1 And 入出系数 = 1;
  End Loop;

  For v_自制材料 In (Select ID, 成本金额, 零售价, 实际数量, 零售金额, 差价, 库房id, 药品id, 批次, 成本价, 批号, 效期, 产地, 灭菌效期, 批准文号, 生产日期, 入出类别id, 入出系数,
                        对方部门id, 费用id As 自制材料id, Trunc(扣率) As 序号
                 From 药品收发记录
                 Where NO = No_In And 单据 = 16 And 记录状态 = 1 And 入出系数 = 1
                 Order By 药品id, 批次) Loop
    Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = v_自制材料.药品id;
  
    n_成本金额 := Nvl(v_自制材料.成本金额, 0);
    If Nvl(v_自制材料.实际数量, 0) <> 0 Then
      n_成本价 := n_成本金额 / Nvl(v_自制材料.实际数量, 0);
    Else
      n_成本价 := n_成本金额;
    End If;
    n_出库差价 := v_自制材料.零售金额 - n_成本金额;
  
    Update 药品收发记录 Set 成本价 = n_成本价, 成本金额 = n_成本金额, 差价 = n_出库差价 Where ID = v_自制材料.Id;
    Update 药品库存
    Set 可用数量 = Nvl(可用数量, 0) + Decode(v_自制材料.入出系数, 1, Nvl(v_自制材料.实际数量, 0), 0), 实际数量 = Nvl(实际数量, 0) + Nvl(v_自制材料.实际数量, 0),
        实际金额 = Nvl(实际金额, 0) + Nvl(v_自制材料.零售金额, 0), 实际差价 = Nvl(实际差价, 0) + n_出库差价,
        零售价 = Decode(n_实价卫材, 1, Decode(Nvl(v_自制材料.批次, 0), 0, Null, Decode(Nvl(零售价, 0), 0, v_自制材料.零售价, 零售价)), Null)
    Where 库房id = v_自制材料.库房id And 药品id = v_自制材料.药品id And Nvl(批次, 0) = Nvl(v_自制材料.批次, 0) And 性质 = 1;
    
    If Sql%NotFound Then
      Insert Into 药品库存
        (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次批号, 上次生产日期, 效期, 上次产地, 灭菌效期, 批准文号, 上次采购价, 零售价,平均成本价)
      Values
        (v_自制材料.库房id, v_自制材料.药品id, Decode(Nvl(v_自制材料.批次, 0), 0, Null, v_自制材料.批次), 1,
         Decode(v_自制材料.入出系数, 1, Nvl(v_自制材料.实际数量, 0), 0), v_自制材料.实际数量 * v_自制材料.入出系数, v_自制材料.零售金额 * v_自制材料.入出系数,
         n_出库差价 * v_自制材料.入出系数, v_自制材料.批号, v_自制材料.生产日期, v_自制材料.效期, v_自制材料.产地, v_自制材料.灭菌效期, v_自制材料.批准文号, n_成本价,
         Decode(n_实价卫材, 1, Decode(Nvl(v_自制材料.批次, 0), 0, Null, v_自制材料.零售价), Null),n_成本价);
    End If;
    
    Zl_未审药品记录_Delete(v_自制材料.id);
    
    Delete From 药品库存
    Where 库房id = v_自制材料.库房id And 药品id = v_自制材料.药品id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
          Nvl(实际差价, 0) = 0;
  
    --更新该材料的成本价
    Update 材料特性 Set 成本价 = n_成本价 Where 材料id = v_自制材料.药品id;
  
    --重新计算库存表中的平均成本价
    Update 药品库存
    Set 平均成本价 = Decode(Nvl(批次, 0), 0, decode((实际金额 - 实际差价) / 实际数量,0,上次采购价,(实际金额 - 实际差价) / 实际数量), 上次采购价)
    Where 药品id = v_自制材料.药品id And Nvl(批次, 0) = Nvl(v_自制材料.批次, 0) And 库房id = v_自制材料.库房id And 性质 = 1 And Nvl(实际数量, 0) <> 0;
    If Sql%NotFound Then
      Select 成本价 Into n_平均成本价 From 材料特性 Where 材料id = v_自制材料.药品id;
      Update 药品库存
      Set 平均成本价 = n_平均成本价
      Where 药品id = v_自制材料.药品id And 库房id = v_自制材料.库房id And Nvl(批次, 0) = Nvl(v_自制材料.批次, 0) and 性质=1;
    End If;
  
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_自制材料入库_Verify;
/

--117925:刘涛,2017-12-07,排序导致死锁处理
--105711:李业庆,2018-01-03,出库库存平均成本价处理
Create Or Replace Procedure Zl_材料外购_Verify
(
  No_In       In 药品收发记录.No%Type := Null,
  审核人_In   In 药品收发记录.审核人%Type := Null,
  审核日期_In In 药品收发记录.审核日期%Type := Sysdate
) Is
  Err_Item Exception;
  v_Err_Msg Varchar2(500);

  n_单位id      药品收发记录.供药单位id%Type;
  n_发票金额    应付记录.发票金额%Type;
  n_库存金额    药品库存.实际金额%Type;
  n_库存差价    药品库存.实际差价%Type;
  n_库存数量    药品库存.实际数量%Type;
  n_实价卫材    收费项目目录.是否变价%Type;
  n_Batch_Count Integer; --原不分批现在分批的材料的数量
  v_条码前缀    Varchar2(20);
  v_内部条码    药品库存.内部条码%Type;
  v_移库no      药品收发记录.No%Type;
  v_对方库房id  药品收发记录.库房id%Type := 0;
  v_入类别id    药品收发记录.入出类别id%Type := 0;
  v_出类别id    药品收发记录.入出类别id%Type := 0;
  n_平均成本价  药品库存.平均成本价%Type;
  n_可用数量    药品收发记录.实际数量%Type;
  v_下库存      Zlparameters.参数值%Type;
Begin
  Select To_Number(Nvl(zl_GetSysParameter(95), '0')) Into v_下库存 From Dual;
  v_条码前缀 := Nvl(zl_GetSysParameter(159), '');

  Update 药品收发记录
  Set 审核人 = Nvl(审核人_In, 审核人), 审核日期 = 审核日期_In
  Where NO = No_In And 单据 = 15 And 记录状态 = 1 And 审核人 Is Null;

  If Sql%RowCount = 0 Then
    v_Err_Msg := '[ZLSOFT]该单据已经被他人审核或删除，不能进行审核！[ZLSOFT]';
    Raise Err_Item;
  End If;
  --主要针对原不分批现在分批的材料，不能对其审核
  Select Count(*)
  Into n_Batch_Count
  From 药品收发记录 A, 材料特性 B
  Where a.药品id = b.材料id And a.No = No_In And a.单据 = 15 And a.记录状态 = 1 And Nvl(a.批次, 0) = 0 And
        ((Nvl(b.库房分批, 0) = 1 And
        a.库房id Not In (Select 部门id From 部门性质说明 Where (工作性质 Like '发料部门') Or (工作性质 Like '制剂室'))) Or Nvl(b.在用分批, 0) = 1);

  If n_Batch_Count > 0 Then
    v_Err_Msg := '[ZLSOFT]该单据中包含有一条原来不分批，现在分批的材料，不能审核！[ZLSOFT]';
    Raise Err_Item;
  End If;

  --原分批现不分批的材料,在审核时，要处理他
  Update 药品收发记录
  Set 批次 = 0
  Where ID In
        (Select ID
         From 药品收发记录 A, 材料特性 B
         Where a.药品id = b.材料id And a.No = No_In And a.单据 = 15 And a.记录状态 = 1 And Nvl(a.批次, 0) > 0 And
               (Nvl(b.库房分批, 0) = 0 Or
               (Nvl(b.在用分批, 0) = 0 And
               a.库房id In (Select 部门id From 部门性质说明 Where (工作性质 Like '发料部门') Or (工作性质 Like '制剂室')))));

  For v_收发 In (Select a.Id, a.实际数量, a.发药方式, a.零售价, a.零售金额, a.差价, a.库房id, a.药品id, a.批次, a.供药单位id, a.成本价, a.批号, a.效期,
                      a.灭菌效期, a.生产日期, a.产地, a.入出类别id, a.注册证号, a.扣率, a.商品条码, a.内部条码, Nvl(b.是否条码管理, 0) As 条码管理, a.批准文号,
                      Nvl(a.费用id, 0) As 费用id, 序号, a.入出系数
               From 药品收发记录 A, 材料特性 B
               Where a.药品id = b.材料id And a.No = No_In And a.单据 = 15 And a.记录状态 = 1
               Order By a.药品id, a.批次) Loop
    v_内部条码 := Null;
    If v_收发.条码管理 = 1 Then
      If v_收发.内部条码 Is Null Then
        If Not v_条码前缀 Is Null Then
          v_内部条码 := v_条码前缀 || Nextno(126);
        Else
          v_内部条码 := Nextno(126);
        End If;
      Else
        v_内部条码 := v_收发.内部条码;
      End If;
      --处理条码打印管理数据
      Insert Into 卫材条码打印记录
        (NO, 单据, 库房id, 材料id, 序号, 商品条码, 内部条码, 入库数量, 打印数量, 入库时间)
      Values
        (No_In, 15, v_收发.库房id, v_收发.药品id, v_收发.序号, v_收发.商品条码, v_内部条码, v_收发.实际数量, 0, 审核日期_In);
    End If;
  
    --更改材料库存表的相应数据
    Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = v_收发.药品id;
  
    If v_收发.费用id = 2 Then
      n_可用数量 := Nvl(v_收发.实际数量, 0);
    Else
      If v_收发.发药方式 = 1 Then
        If v_下库存 = 1 Then
          n_可用数量 := 0;
        Else
          n_可用数量 := Nvl(v_收发.实际数量, 0);
        End If;
      Else
        n_可用数量 := Nvl(v_收发.实际数量, 0);
      End If;
    End If;
  
    Update 药品库存
    Set 可用数量 = Nvl(可用数量, 0) + n_可用数量, 实际数量 = Nvl(实际数量, 0) + Nvl(v_收发.实际数量, 0), 实际金额 = Nvl(实际金额, 0) + Nvl(v_收发.零售金额, 0),
        实际差价 = Nvl(实际差价, 0) + Nvl(v_收发.差价, 0), 上次供应商id = Nvl(v_收发.供药单位id, 上次供应商id), 上次采购价 = Nvl(v_收发.成本价, 上次采购价),
        上次批号 = Nvl(v_收发.批号, 上次批号), 上次产地 = Nvl(v_收发.产地, 上次产地), 灭菌效期 = Nvl(v_收发.灭菌效期, 灭菌效期),
        上次生产日期 = Nvl(v_收发.生产日期, 上次生产日期), 效期 = Nvl(v_收发.效期, 效期),
        零售价 = Decode(Nvl(v_收发.批次, 0), 0, Null, Decode(n_实价卫材, 1, v_收发.零售价, Null)), 上次扣率 = Nvl(v_收发.扣率, 上次扣率),
        商品条码 = v_收发.商品条码, 内部条码 = v_内部条码, 批准文号 = v_收发.批准文号
    Where 库房id = v_收发.库房id And 药品id = v_收发.药品id And Nvl(批次, 0) = Nvl(v_收发.批次, 0) And 性质 = 1;
  
    If Sql%NotFound Then
      Insert Into 药品库存
        (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 灭菌效期, 效期, 零售价, 上次扣率, 商品条码,
         内部条码, 平均成本价, 批准文号)
      Values
        (v_收发.库房id, v_收发.药品id, v_收发.批次, 1, n_可用数量, v_收发.实际数量, v_收发.零售金额, v_收发.差价, v_收发.供药单位id, v_收发.成本价, v_收发.批号,
         v_收发.生产日期, v_收发.产地, v_收发.灭菌效期, v_收发.效期, Decode(Nvl(v_收发.批次, 0), 0, Null, Decode(n_实价卫材, 1, v_收发.零售价, Null)),
         v_收发.扣率, v_收发.商品条码, v_内部条码, v_收发.成本价, v_收发.批准文号);
    End If;
  
    Zl_未审药品记录_Delete(v_收发.Id);
  
    If v_收发.内部条码 Is Null And Not v_内部条码 Is Null Then
      Update 药品收发记录 Set 内部条码 = v_内部条码 Where ID = v_收发.Id;
    End If;
  
    --清除数量金额为零的记录
    Delete From 药品库存
    Where 库房id = v_收发.库房id And 药品id = v_收发.药品id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
          Nvl(实际差价, 0) = 0;
  
    --更改材料收发汇总表的相应数据
    --更新该材料的成本价
    Begin
      Select Sum(Nvl(实际金额, 0)), Sum(Nvl(实际差价, 0)), Sum(Nvl(实际数量, 0))
      Into n_库存金额, n_库存差价, n_库存数量
      From 药品库存
      Where 性质 = 1 And 药品id = v_收发.药品id;
    Exception
      When Others Then
        n_库存数量 := 0;
    End;
  
    --更新该药品的成本价
    Update 材料特性
    Set 成本价 = v_收发.成本价, 上次售价 = v_收发.零售价, 上次供应商id = v_收发.供药单位id, 上次产地 = v_收发.产地
    Where 材料id = v_收发.药品id;
  
    --更改材料特性中的注册证号:如果发现材料特性表中的注册证号没填，则直接反写给材料特性表中的注册证号
    If Nvl(v_收发.注册证号, ' ') <> ' ' Then
      Update 材料特性 Set 注册证号 = v_收发.注册证号 Where 材料id = v_收发.药品id And 注册证号 Is Null;
    End If;
  
    --不分批入库时才重新计算库存表中的平均成本价
    If Nvl(v_收发.批次, 0) = 0 And v_收发.入出系数 * Nvl(v_收发.实际数量, 0) > 0 Then
      Update 药品库存
      Set 平均成本价 = Decode((实际金额 - 实际差价) / 实际数量, 0, 上次采购价, (实际金额 - 实际差价) / 实际数量)
      Where 药品id = v_收发.药品id And Nvl(批次, 0) = Nvl(v_收发.批次, 0) And 库房id = v_收发.库房id And 性质 = 1 And Nvl(实际数量, 0) <> 0;
      If Sql%NotFound Then
        Select 成本价 Into n_平均成本价 From 材料特性 Where 材料id = v_收发.药品id;
        Update 药品库存
        Set 平均成本价 = n_平均成本价
        Where 药品id = v_收发.药品id And 库房id = v_收发.库房id And Nvl(批次, 0) = Nvl(v_收发.批次, 0) And 性质 = 1;
      End If;
    End If;
  End Loop;

  --对应付余额表进行处理
  --此处用一个块，主要是解决没有对应发票号的记录
  Begin
    Update 应付记录
    Set 审核人 = 审核人_In, 审核日期 = 审核日期_In
    Where 入库单据号 = No_In And 系统标识 = 5 And 记录性质 = 0 And 记录状态 = 1;
  
    Select b.单位id, Sum(发票金额)
    Into n_单位id, n_发票金额
    From 药品收发记录 A, 应付记录 B
    Where a.Id = b.收发id And a.No = No_In And a.单据 = 15 And b.系统标识 = 5
    Group By b.单位id;
  
    If Nvl(n_单位id, 0) <> 0 Then
      Update 应付余额 Set 金额 = Nvl(金额, 0) + Nvl(n_发票金额, 0) Where 单位id = n_单位id And 性质 = 1;
    
      If Sql%NotFound Then
        Insert Into 应付余额 (单位id, 性质, 金额) Values (n_单位id, 1, n_发票金额);
      End If;
    End If;
  Exception
    When No_Data_Found Then
      Null;
  End;

  --如果是自动产生的备货卫材入库单，则产生移库单
  For v_Data In (Select ID, 序号, 实际数量, 发药方式, 零售价, 零售金额, 差价, 库房id, 药品id, 批次, 供药单位id, 成本价, 成本金额, 批号, 效期, 灭菌效期, 生产日期, 产地,
                        入出类别id, 注册证号, 扣率, 摘要, 商品条码, 内部条码, 费用id, 审核人, 审核日期
                 From 药品收发记录
                 Where NO = No_In And 单据 = 15 And 记录状态 = 1 And 审核日期 Is Not Null And 费用id > 0
                 Order By 药品id, 批次, 序号) Loop
    If v_对方库房id = 0 Then
      Begin
        Select Distinct 库房id Into v_对方库房id From 药品收发记录 Where 单据 In (24, 25) And 费用id = v_Data.费用id;
      Exception
        When Others Then
          v_对方库房id := 0;
      End;
    End If;
  
    If v_对方库房id > 0 Then
      If v_移库no Is Null Then
        v_移库no := Nextno(72, v_Data.库房id);
      End If;
    
      Zl_材料移库_Insert(v_移库no, v_Data.序号 * 2 - 1, v_Data.库房id, v_对方库房id, v_Data.药品id, v_Data.批次, v_Data.实际数量, v_Data.实际数量,
                     v_Data.成本价, v_Data.成本金额, v_Data.零售价, v_Data.零售金额, v_Data.差价, v_Data.审核人, v_Data.产地, v_Data.批号,
                     v_Data.效期, v_Data.灭菌效期, v_Data.摘要, v_Data.审核日期);
    End If;
  End Loop;

  --对新产生的移库单进行备料和审核
  If Not v_移库no Is Null Then
    Zl_材料移库_Prepare(v_移库no, 审核人_In);
    Zl_材料移库_Prepare(v_移库no);
  
    Select b.Id As 类别id
    Into v_入类别id
    From 药品单据性质 A, 药品入出类别 B
    Where a.类别id = b.Id And a.单据 = 34 And 系数 = 1 And Rownum < 2;
  
    Select b.Id As 类别id
    Into v_出类别id
    From 药品单据性质 A, 药品入出类别 B
    Where a.类别id = b.Id And a.单据 = 34 And 系数 = -1 And Rownum < 2;
  
    For v_Data In (Select 序号, 库房id, 对方部门id, 药品id, 产地, Nvl(批次, 0) As 批次, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 零售金额, 差价, NO, 填制人, 批号,
                          效期, 灭菌效期, 填制日期
                   From 药品收发记录
                   Where 单据 = 19 And NO = v_移库no And 审核日期 Is Null And 入出系数 = -1
                   Order By 药品id, 批次, 序号) Loop
    
      Zl_材料移库_Verify(v_Data.序号, v_Data.库房id, v_Data.对方部门id, v_Data.药品id, v_Data.产地, v_Data.批次, v_Data.填写数量, v_Data.实际数量,
                     v_Data.成本价, v_Data.成本金额, v_Data.零售金额, v_Data.差价, v_出类别id, v_入类别id, v_Data.No, v_Data.填制人, v_Data.批号,
                     v_Data.效期, v_Data.灭菌效期, v_Data.填制日期, 1, v_Data.零售价);
    End Loop;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料外购_Verify;
/

--117925:刘涛,2017-12-07,排序导致死锁处理
Create Or Replace Procedure Zl_材料外购_Delete(
                                           --删除药品收发记录及相应的表：应付记录
                                           No_In In 药品收发记录.No%Type) Is
  Merritem Exception;
  Merrmsg  Varchar2(100);
  v_下库存 Zlparameters.参数值%Type;
Begin

  Select To_Number(Nvl(zl_GetSysParameter(95), '0')) Into v_下库存 From Dual;

  If v_下库存 = 1 Then
    --恢复可用数量
    For v_收发 In (Select 实际数量, 库房id, 批次, 药品id, 成本价, 批号, 生产日期, 灭菌效期, 效期, 产地, 供药单位id, 批准文号
                 From 药品收发记录
                 Where NO = No_In And Nvl(发药方式, 0) = 1 And 单据 = 15
                 Order By 药品id,批次,序号) Loop
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) + (-1 * v_收发.实际数量)
      Where 库房id = v_收发.库房id And 药品id = v_收发.药品id And Nvl(批次, 0) = Nvl(v_收发.批次, 0) And 性质 = 1;
    
      If Sql%NotFound Then
        Insert Into 药品库存
          (库房id, 药品id, 批次, 性质, 可用数量, 上次供应商id, 上次采购价, 上次批号, 上次产地, 效期, 灭菌效期, 上次生产日期, 批准文号)
        Values
          (v_收发.库房id, v_收发.药品id, v_收发.批次, 1, -1 * v_收发.实际数量, v_收发.供药单位id, v_收发.成本价, v_收发.批号, v_收发.产地, v_收发.效期,
           v_收发.灭菌效期, v_收发.生产日期, v_收发.批准文号);
      End If;
    
      Delete From 药品库存
      Where 库房id = v_收发.库房id And 药品id = v_收发.药品id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
            Nvl(实际差价, 0) = 0;
    
    End Loop;
  End If;

  Delete 应付记录 Where 系统标识 = 5 And 收发id In (Select ID From 药品收发记录 Where NO = No_In And 单据 = 15);
  --对应应付记录的删除通过级联删除
  Delete --删除本身
  From 药品收发记录
  Where NO = No_In And 单据 = 15 And 记录状态 = 1 And 审核人 Is Null;

  If Sql%RowCount = 0 Then
    Merrmsg := '[ZLSOFT]该单据已经被他人删除或已被人审核！[ZLSOFT]';
    Raise Merritem;
  End If;
Exception
  When Merritem Then
    Raise_Application_Error(-20101, Merrmsg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料外购_Delete;
/

--117925:刘涛,2017-12-07,排序导致死锁处理
Create Or Replace Procedure Zl_药品盘点_Delete(
  No_In In 药品收发记录.No%Type
) Is
  Err_Isverified Exception;
  n_库房id 药品收发记录.库房id%Type;
  
  Cursor c_药品收发记录 Is
    Select ID From 药品收发记录 Where NO = No_In And 单据 = 12 Order By 药品id,批次;
Begin
  --通过循环，恢复出库类别原来的可用数量，
  --实际数量保存的是数量差
  For v_药品收发记录 In c_药品收发记录 Loop
    Zl_药品库存_Update(v_药品收发记录.Id, 1);
  End Loop;

  Begin
    Select Distinct 库房id
    Into n_库房id
    From 药品收发记录
    Where NO = No_In And 单据 = 12 And 记录状态 = 1 And 审核人 Is Null And 入出系数 = -1;
  Exception
    When Others Then
      n_库房id := 0;
  End;

  Delete From 药品收发记录 Where NO = No_In And 单据 = 12 And 记录状态 = 1 And 审核人 Is Null;

  If Sql%RowCount = 0 Then
    Raise Err_Isverified;
  End If;
Exception
  When Err_Isverified Then
    Raise_Application_Error(-20101, '[ZLSOFT]该单据已经被他人删除或已被人审核！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品盘点_Delete;
/

--117925:刘涛,2017-12-07,排序导致死锁处理
Create Or Replace Procedure Zl_药品盘点_Verify
(
  No_In     In 药品收发记录.No%Type := Null,
  审核人_In In 药品收发记录.审核人%Type := Null
) Is
  Err_Isverified Exception;
  n_库房id 药品收发记录.库房id%Type;

  Cursor c_药品收发记录 Is
    Select ID, 实际数量, 零售金额, 差价, 库房id, 药品id, 批次, 批号, 效期, 产地, 入出类别id, 入出系数, 批准文号, 供药单位id, 生产日期, 单量
    From 药品收发记录
    Where NO = No_In And 单据 = 12 And 记录状态 = 1
    Order By 药品id,批次;
Begin
  Update 药品收发记录
  Set 审核人 = 审核人_In, 审核日期 = Sysdate
  Where NO = No_In And 单据 = 12 And 记录状态 = 1 And 审核人 Is Null;

  If Sql%RowCount = 0 Then
    Raise Err_Isverified;
  End If;

  For v_药品收发记录 In c_药品收发记录 Loop
    --更改药品库存表的相应数据
    If v_药品收发记录.入出系数 = 1 Then
      Zl_药品库存_Update(v_药品收发记录.Id, 2, 0);
    Else
      Zl_药品库存_Update(v_药品收发记录.Id, 2, 1);
      n_库房id := v_药品收发记录.库房id;
    End If;
    
    Zl_未审药品记录_Delete(v_药品收发记录.Id);
    
	Zl_药品收发记录_调价修正(v_药品收发记录.Id);
  End Loop;
Exception
  When Err_Isverified Then
    Raise_Application_Error(-20101, '[ZLSOFT]该单据已经被他人审核！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品盘点_Verify;
/

--110624:刘涛,2018-01-23,盘点增加修改人信息
--117925:刘涛,2017-12-07,排序导致死锁处理
Create Or Replace Procedure Zl_药品盘点_Strike
(
  No_In     In 药品收发记录.No%Type,
  审核人_In In 药品收发记录.审核人%Type
) Is
  Err_Isstriked Exception;
  Err_Isbatch Exception;
  v_Err_Msg     Varchar2(255);
  n_Batch_Count Number;
  n_药品id      药品收发记录.药品id%Type;

  Cursor c_药品收发记录 Is
    Select a.Id, a.实际数量, a.零售金额, a.差价, a.零售价, Nvl(b.是否变价, 0) As 是否变价, a.库房id, a.药品id, a.批次, a.批号, a.效期, a.产地, a.原产地, a.入出类别id,
           a.入出系数, a.单量, a.批准文号, a.供药单位id, a.生产日期
    From 药品收发记录 A, 收费项目目录 B
    Where a.药品id = b.Id And NO = No_In And 单据 = 12 And 记录状态 = 2
    Order By 药品id,批次;
Begin
  Update 药品收发记录 Set 记录状态 = 3 Where NO = No_In And 单据 = 12 And 记录状态 = 1;
  If Sql%RowCount = 0 Then
    Raise Err_Isstriked;
  End If;

  --主要针对原不分批现在分批的材料，不能对其审核 
  Select Count(*), Max(a.药品id)
  Into n_Batch_Count, n_药品id
  From 药品收发记录 A, 药品规格 B
  Where a.药品id = b.药品id And a.No = No_In And a.单据 = 12 And a.记录状态 = 3 And Nvl(a.批次, 0) = 0 And
        ((Nvl(b.药房分批, 0) = 1 And
        a.库房id Not In (Select 部门id From 部门性质说明 Where (工作性质 Like '%药房') Or (工作性质 Like '制剂室'))) Or Nvl(b.药房分批, 0) = 1);

  If n_Batch_Count > 0 Then
    Begin
      Select 编码 || '-' || 名称 Into v_Err_Msg From 收费项目目录 Where ID = n_药品id;
    Exception
      When Others Then
        Null;
    End;
    v_Err_Msg := '该单据中为:' || v_Err_Msg || Chr(10) || Chr(13) || '的药品,原来不分批,而现在分批，因此不能审核！';
    Raise Err_Isbatch;
  End If;
  
  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 入出系数, 药品id, 批次, 产地, 原产地, 批号, 效期, 填写数量, 扣率, 实际数量, 成本价, 成本金额, 零售价, 零售金额, 差价, 摘要, 填制人,
     填制日期, 审核人, 审核日期, 频次, 单量, 批准文号, 供药单位id, 生产日期, 库房货位)
    Select 药品收发记录_Id.Nextval, 2, 单据, NO, 序号, 库房id, 入出类别id, 入出系数, a.药品id,
           Decode(Nvl(a.批次, 0), 0, Null, (Decode(Nvl(b.药库分批, 0), 0, Null, a.批次))), a.产地, a.原产地, 批号, 效期, 填写数量, a.扣率, -实际数量,
           a.成本价, 成本金额, 零售价, -零售金额, -差价, 摘要, 审核人_In, Sysdate, 审核人_In, Sysdate, 频次, 单量, a.批准文号, a.供药单位id, a.生产日期, 
		   a.库房货位
    From (Select * From 药品收发记录 Where NO = No_In And 单据 = 12 And 记录状态 = 3 Order By 药品id) A, 药品规格 B
    Where a.药品id = b.药品id;
  
  For v_药品收发记录 In c_药品收发记录 Loop
    --处理库存
    If v_药品收发记录.入出系数 = 1 Then
      Zl_药品库存_Update(v_药品收发记录.Id, 3, 1);
    Else
      Zl_药品库存_Update(v_药品收发记录.Id, 3, 0);
    End If;
  
    --处理调价后冲销
    Zl_药品收发记录_调价修正(v_药品收发记录.Id);
  End Loop;
Exception
  When Err_Isbatch Then
    Raise_Application_Error(-20102, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Err_Isstriked Then
    Raise_Application_Error(-20101, '[ZLSOFT]该单据已经被他人冲销！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品盘点_Strike;
/

--117925:刘涛,2017-12-07,排序导致死锁处理
Create Or Replace Procedure Zl_药品移库_Verify
(
  序号_In         In 药品收发记录.序号%Type,
  库房id_In       In 药品收发记录.库房id%Type,
  对方部门id_In   In 药品收发记录.对方部门id%Type,
  药品id_In       In 药品收发记录.药品id%Type,
  产地_In         In 药品收发记录.产地%Type,
  出批次_In       In 药品收发记录.批次%Type,
  实际数量_In     In 药品收发记录.实际数量%Type,
  成本价_In       In 药品收发记录.成本价%Type,
  成本金额_In     In 药品收发记录.成本金额%Type,
  零售金额_In     In 药品收发记录.零售金额%Type,
  差价_In         In 药品收发记录.差价%Type,
  No_In           In 药品收发记录.No%Type,
  审核人_In       In 药品收发记录.审核人%Type,
  批号_In         In 药品收发记录.批号%Type := Null,
  效期_In         In 药品收发记录.效期%Type := Null,
  审核日期_In     In 药品收发记录.审核日期%Type := Null,
  上次供应商id_In In 药品收发记录.供药单位id%Type := Null,
  批准文号_In     In 药品收发记录.批准文号%Type := Null,
  零售价_In       In 药品收发记录.零售价%Type := Null
) Is
  Err_Isverified Exception;
  Err_Isnonumber Exception;
  Err_Isbatch Exception;
  Err_Isprice Exception;
  v_Druginf  Varchar2(50); --原不分批现在分批的药品信息 
  v_实际数量 药品库存.实际数量%Type;
  v_编码     收费项目目录.编码%Type;
  Intdigit   Number;
  v_上次扣率 药品库存.上次扣率%Type;
  n_Unverify Number; --未审核的记录数

  Cursor c_药品收发记录 Is
    Select ID, 入出系数
    From 药品收发记录
    Where NO = No_In And 单据 = 6 And 药品id = 药品id_In And 记录状态 = 1 And 序号 In (序号_In, 序号_In + 1) And 审核日期 Is Not Null
	Order By 药品id,批次;
Begin
  --获取金额小数位数 
  Select Nvl(精度, 2) Into Intdigit From 药品卫材精度 Where 性质 = 0 And 类别 = 1 And 内容 = 4 And 单位 = 5;

  --主要针对原不分批现在分批的药品，不能对其审核 
  --仅检查入类别 
  Begin
    Select Distinct '(' || i.编码 || ')' || Nvl(n.名称, i.名称) As 药品信息
    Into v_Druginf
    From 药品收发记录 A, 药品规格 B, 收费项目目录 I, 收费项目别名 N
    Where a.药品id = b.药品id And a.药品id = i.Id And a.药品id = n.收费细目id(+) And n.性质(+) = 3 And a.No = No_In And a.单据 = 6 And
          a.记录状态 = 1 And Nvl(a.批次, 0) = 0 And a.药品id + 0 = 药品id_In And a.序号 = 序号_In + 1 And
          ((Nvl(b.药库分批, 0) = 1 And
          a.库房id Not In (Select 部门id From 部门性质说明 Where (工作性质 Like '%药房') Or (工作性质 Like '制剂室'))) Or Nvl(b.药房分批, 0) = 1) And
          Rownum = 1;
  Exception
    When Others Then
      v_Druginf := '';
  End;

  If v_Druginf Is Not Null Then
    Raise Err_Isbatch;
  End If;

  Begin
    Select Nvl(实际数量, 0), Nvl(上次扣率, 100)
    Into v_实际数量, v_上次扣率
    From 药品库存
    Where 药品id = 药品id_In And Nvl(批次, 0) = 出批次_In And 库房id = 库房id_In And 性质 = 1 And Rownum = 1;
  Exception
    When Others Then
      v_实际数量 := 0;
      v_上次扣率 := 100;
  End;

  Update 药品收发记录
  Set 审核人 = Nvl(审核人_In, 审核人), 审核日期 = 审核日期_In, 实际数量 = 实际数量_In, 成本价 = 成本价_In, 成本金额 = 成本金额_In, 零售价 = 零售价_In, 零售金额 = 零售金额_In,
      差价 = 差价_In, 扣率 = v_上次扣率
  Where NO = No_In And 单据 = 6 And 药品id = 药品id_In And 记录状态 = 1 And 序号 In (序号_In, 序号_In + 1) And 审核人 Is Null;

  If Sql%RowCount = 0 Then
    Raise Err_Isverified;
  End If;

  --更新入出库库存
  For v_药品收发记录 In c_药品收发记录 Loop
    If v_药品收发记录.入出系数 = 1 Then
      Zl_药品库存_Update(v_药品收发记录.Id, 2, 0);
    Else
      Zl_药品库存_Update(v_药品收发记录.Id, 2, 1);
    End If;
  
    Zl_未审药品记录_Delete(v_药品收发记录.Id);
  End Loop;

  Select Count(ID) Into n_Unverify From 药品收发记录 Where 单据 = 6 And NO = No_In And 审核日期 Is Null;

  --全部审核完了再调用消息
  If n_Unverify = 0 Then
    b_Message.Zlhis_Drug_003(No_In);
  End If;
Exception
  When Err_Isverified Then
    Raise_Application_Error(-20101, '[ZLSOFT]该单据已经被他人审核！[ZLSOFT]');
  When Err_Isnonumber Then
    Select 编码 Into v_编码 From 收费项目目录 Where ID = 药品id_In;
    Raise_Application_Error(-20101,
                            '[ZLSOFT]编码为' || v_编码 || ',批号为' || 批号_In || '的药库分批药品' || Chr(10) || Chr(13) ||
                             '可用库存数量不够！[ZLSOFT]');
  When Err_Isbatch Then
    Raise_Application_Error(-20102, '[ZLSOFT]该单据中包含有一条原来不分批，现在分批的药品[' || v_Druginf || ']，不能审核！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品移库_Verify;
/

--117925:刘涛,2017-12-07,排序导致死锁处理
Create Or Replace Procedure Zl_药品移库_Delete
(
  No_In       In 药品收发记录.No%Type,
  记录状态_In In 药品收发记录.记录状态%Type := 1
) Is
  Err_Isverified Exception;
  n_库房id 药品收发记录.库房id%Type;

  Cursor c_药品收发记录 Is
    Select ID From 药品收发记录 Where NO = No_In And 单据 = 6 Order By 药品id,批次;

  Cursor c_申请冲销记录 Is
    Select ID From 药品收发记录 Where NO = No_In And 单据 = 6 And 记录状态 = 记录状态_In Order By 药品id,批次;
Begin
  If 记录状态_In = 1 Then
    --处理未审核移库单据
    --通过循环，恢复原来的可用数量
    For v_药品收发记录 In c_药品收发记录 Loop
      Zl_药品库存_Update(v_药品收发记录.Id, 1);
    End Loop;
  Else
    --处理移库申请冲销单据
    --通过循环，恢复原来的可用数量
    For v_申请冲销记录 In c_申请冲销记录 Loop
      Zl_药品库存_Update(v_申请冲销记录.Id, 1);
    End Loop;
  End If;

  Begin
    Select Distinct 库房id
    Into n_库房id
    From 药品收发记录
    Where NO = No_In And 单据 = 6 And 记录状态 = 记录状态_In And 入出系数 = -1;
  Exception
    When Others Then
      n_库房id := 0;
  End;


  --删除未审核单据 
  Delete From 药品收发记录 Where NO = No_In And 单据 = 6 And 记录状态 = 记录状态_In And 审核人 Is Null;

  If Sql%RowCount = 0 Then
    Raise Err_Isverified;
  End If;
Exception
  When Err_Isverified Then
    Raise_Application_Error(-20101, '[ZLSOFT]该单据已经被他人删除或已被人审核！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品移库_Delete;
/

--110624:刘涛,2018-01-22,申领增加修改人信息
--117925:刘涛,2017-12-07,排序导致死锁处理
Create Or Replace Procedure Zl_药品移库_Strike
(
  行次_In       In Integer,
  原记录状态_In In 药品收发记录.记录状态%Type,
  No_In         In 药品收发记录.No%Type,
  序号_In       In 药品收发记录.序号%Type,
  药品id_In     In 药品收发记录.药品id%Type,
  冲销数量_In   In 药品收发记录.实际数量%Type,
  填制人_In     In 药品收发记录.填制人%Type,
  填制日期_In   In 药品收发记录.填制日期%Type,
  摘要_In       In 药品收发记录.摘要%Type := Null,
  冲销方式_In   In Integer := 0 --0－正常冲销方式；1－产生冲销申请单据；2－审核已产生的冲销申请单据
) Is
  Err_Isstriked Exception;
  Err_Isoutstock Exception;
  Err_Isnonum Exception;
  Err_Isbatch Exception;
  v_Druginf      Varchar2(50); --原不分批现在分批的药品信息
  v_库房id       药品收发记录.库房id%Type;
  v_批次         药品收发记录.批次%Type;
  v_成本价       药品收发记录.成本价%Type;
  v_成本金额     药品收发记录.成本金额%Type;
  v_零售价       药品收发记录.零售价%Type;
  v_零售金额     药品收发记录.零售金额%Type;
  v_差价         药品收发记录.差价%Type;
  v_剩余数量     药品收发记录.实际数量%Type;
  v_剩余成本金额 药品收发记录.成本金额%Type;
  v_剩余零售金额 药品收发记录.零售金额%Type;
  v_收发id       药品收发记录.Id%Type;
  v_批准文号     药品收发记录.批准文号%Type;

  v_药库分批 Integer;
  v_药房分批 Integer;
  Intdigit   Number;
  n_操作类型 Number;

  Cursor c_药品收发记录 Is
    Select a.Id, a.序号, a.库房id, a.对方部门id, a.入出类别id, a.入出系数, a.药品id, a.批次, a.产地, a.原产地, a.批号, a.效期, a.配药人, a.配药日期, a.摘要,
           a.供药单位id, a.批准文号, a.生产日期, a.成本价, a.零售价, Nvl(b.是否变价, 0) As 时价, a.扣率, a.单量, a.频次
    From 药品收发记录 A, 收费项目目录 B
    Where a.药品id = b.Id And a.No = No_In And a.单据 = 6 And (a.序号 >= 序号_In And a.序号 <= 序号_In + 1) And
          (a.记录状态 = 1 Or Mod(a.记录状态, 3) = 0)
    Order By a.药品id,a.批次;

  Cursor c_冲销申请记录 Is
    Select a.Id, a.序号, a.库房id, a.对方部门id, a.入出类别id, a.入出系数, a.药品id, a.批次, a.产地, a.原产地, a.批号, a.效期, a.配药人, a.配药日期, a.摘要,
           a.供药单位id, a.批准文号, a.生产日期, a.成本价, a.实际数量, a.零售金额, a.差价, a.零售价, Nvl(b.是否变价, 0) As 时价, a.扣率, a.单量, a.频次
    From 药品收发记录 A, 收费项目目录 B
    Where a.药品id = b.Id And a.No = No_In And a.单据 = 6 And (a.序号 >= 序号_In And a.序号 <= 序号_In + 1) And
          (a.记录状态 = 原记录状态_In And Mod(a.记录状态, 3) = 2) And a.审核日期 Is Null
    Order By a.药品id,a.批次;
Begin
  --获取金额小数位数
  Select Nvl(精度, 2) Into Intdigit From 药品卫材精度 Where 性质 = 0 And 类别 = 1 And 内容 = 4 And 单位 = 5;

  If 冲销方式_In = 0 Then
    n_操作类型 := 0;
  Else
    n_操作类型 := 1;
  End If;

  If 冲销方式_In = 1 Then
    --产生冲销申请单据，不填写审核人、审核日期，不更新库存记录
    If 行次_In = 1 Then
      Update 药品收发记录
      Set 记录状态 = Decode(原记录状态_In, 1, 3, 原记录状态_In + 3)
      Where NO = No_In And 单据 = 6 And 记录状态 = 原记录状态_In;
      If Sql%RowCount = 0 Then
        Raise Err_Isstriked;
      End If;
    End If;
  
    --主要针对原不分批现在分批的药品，不能对其冲销
    Begin
      Select Distinct '(' || i.编码 || ')' || Nvl(n.名称, i.名称) As 药品信息
      Into v_Druginf
      From 药品收发记录 A, 药品规格 B, 收费项目目录 I, 收费项目别名 N
      Where a.药品id = b.药品id And a.药品id = i.Id And a.药品id = n.收费细目id(+) And n.性质(+) = 3 And a.No = No_In And a.单据 = 6 And
            a.药品id + 0 = 药品id_In And Mod(a.记录状态, 3) = 0 And Nvl(a.批次, 0) = 0 And a.序号 = 序号_In And
            ((Nvl(b.药库分批, 0) = 1 And
            a.库房id Not In (Select 部门id From 部门性质说明 Where (工作性质 Like '%药房') Or (工作性质 Like '制剂室'))) Or
            Nvl(b.药房分批, 0) = 1) And Rownum = 1;
    Exception
      When Others Then
        v_Druginf := '';
    End;
  
    If v_Druginf Is Not Null Then
      Raise Err_Isbatch;
    End If;
  
    Select Sum(a.实际数量) As 剩余数量, Sum(a.成本金额) As 剩余成本金额, Sum(a.零售金额) As 剩余零售金额, a.成本价, a.零售价, a.对方部门id, Nvl(a.批次, 0),
           b.药库分批, b.药房分批, a.批准文号
    Into v_剩余数量, v_剩余成本金额, v_剩余零售金额, v_成本价, v_零售价, v_库房id, v_批次, v_药库分批, v_药房分批, v_批准文号
    From 药品收发记录 A, 药品规格 B
    Where a.No = No_In And a.药品id = b.药品id And a.单据 = 6 And a.药品id = 药品id_In And a.序号 = 序号_In
    Group By a.成本价, a.零售价, a.对方部门id, Nvl(a.批次, 0), b.药库分批, b.药房分批, a.批准文号;
  
    --V_分批:(原分批,现分批为批次;否则为零)原不分批,现分批,本过程不考虑
    --因为对于对方库房，相当于出库，而对于当前库房，相当于入库，所以当前库房不予检查，仅检查退库那条记录
    Select Nvl(a.批次, 0)
    Into v_批次
    From 药品收发记录 A
    Where a.No = No_In And a.单据 = 6 And a.药品id = 药品id_In And a.序号 = 序号_In + 1 And Mod(a.记录状态, 3) = 0;
  
    --冲销数量大于剩余数量，不允许
    If v_剩余数量 < 冲销数量_In Then
      Raise Err_Isnonum;
    End If;
  
    v_成本金额 := Round(冲销数量_In / v_剩余数量 * v_剩余成本金额, Intdigit);
    v_零售金额 := Round(冲销数量_In / v_剩余数量 * v_剩余零售金额, Intdigit);
    v_差价     := v_零售金额 - v_成本金额;
  
    For v_药品收发记录 In c_药品收发记录 Loop
    
      Select 药品收发记录_Id.Nextval Into v_收发id From Dual;
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 原产地, 批号, 效期, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 零售金额,
         差价, 摘要, 填制人, 填制日期, 审核人, 审核日期, 配药人, 配药日期, 供药单位id, 批准文号, 生产日期, 扣率, 单量, 频次)
      Values
        (v_收发id, Decode(原记录状态_In, 1, 2, 原记录状态_In + 2), 6, No_In, v_药品收发记录.序号, v_药品收发记录.库房id, v_药品收发记录.对方部门id,
         v_药品收发记录.入出类别id, v_药品收发记录.入出系数, 药品id_In, v_药品收发记录.批次, v_药品收发记录.产地, v_药品收发记录.原产地, v_药品收发记录.批号, v_药品收发记录.效期,
         -冲销数量_In, -冲销数量_In, v_成本价, -v_成本金额, v_零售价, -v_零售金额, -v_差价, 摘要_In, 填制人_In, 填制日期_In, Null, Null, v_药品收发记录.配药人,
         v_药品收发记录.配药日期, v_药品收发记录.供药单位id, v_药品收发记录.批准文号, v_药品收发记录.生产日期, v_药品收发记录.扣率, v_药品收发记录.单量, v_药品收发记录.频次);
    
      Zl_未审药品记录_Insert(v_收发id);
    
      --处理库存，原入的那笔相当于出库
      If v_药品收发记录.入出系数 = 1 Then
        Zl_药品库存_Update(v_收发id, 0, 1);
      End If;
    
      If v_药品收发记录.入出系数 = -1 Then
        v_库房id := v_药品收发记录.库房id;
      End If;
    End Loop;
  
  Elsif 冲销方式_In = 2 Then
    --审核已产生的冲销申请单据，填写审核人、审核日期，更新库存记录
    For v_药品收发记录 In c_冲销申请记录 Loop
      --填写审核人、审核日期
      Update 药品收发记录
      Set 审核人 = 填制人_In, 审核日期 = 填制日期_In
      Where NO = No_In And 单据 = 6 And ID = v_药品收发记录.Id;
    
      --更改药品库存表的相应数据，注意这时传入的数量等是负数
      --参数为1表示申请冲销时下可用数量，仅对原移入库房，下了可用数量就不用再更新可用数量了
      If v_药品收发记录.入出系数 = 1 Then
        Zl_药品库存_Update(v_药品收发记录.Id, 3, 1, n_操作类型);
      Else
        Zl_药品库存_Update(v_药品收发记录.Id, 3, 0);
      End If;
    
      Zl_未审药品记录_Delete(v_药品收发记录.Id);
    
      If v_药品收发记录.入出系数 = -1 Then
        v_库房id := v_药品收发记录.库房id;
      
      End If;
    
      --处理调价后冲销
      Zl_药品收发记录_调价修正(v_药品收发记录.Id);
    End Loop;
  
    b_Message.Zlhis_Drug_004(No_In);
  Else
    --正常冲销方式，产生冲销记录，填写审核人、审核日期，更新库存记录
    If 行次_In = 1 Then
      Update 药品收发记录
      Set 记录状态 = Decode(原记录状态_In, 1, 3, 原记录状态_In + 3)
      Where NO = No_In And 单据 = 6 And 记录状态 = 原记录状态_In;
      If Sql%RowCount = 0 Then
        Raise Err_Isstriked;
      End If;
    End If;
  
    --主要针对原不分批现在分批的药品，不能对其冲销
    Begin
      Select Distinct '(' || i.编码 || ')' || Nvl(n.名称, i.名称) As 药品信息
      Into v_Druginf
      From 药品收发记录 A, 药品规格 B, 收费项目目录 I, 收费项目别名 N
      Where a.药品id = b.药品id And a.药品id = i.Id And a.药品id = n.收费细目id(+) And n.性质(+) = 3 And a.No = No_In And a.单据 = 6 And
            a.药品id + 0 = 药品id_In And Mod(a.记录状态, 3) = 0 And Nvl(a.批次, 0) = 0 And a.序号 = 序号_In And
            ((Nvl(b.药库分批, 0) = 1 And
            a.库房id Not In (Select 部门id From 部门性质说明 Where (工作性质 Like '%药房') Or (工作性质 Like '制剂室'))) Or
            Nvl(b.药房分批, 0) = 1) And Rownum = 1;
    Exception
      When Others Then
        v_Druginf := '';
    End;
  
    If v_Druginf Is Not Null Then
      Raise Err_Isbatch;
    End If;
  
    Select Sum(a.实际数量) As 剩余数量, Sum(a.成本金额) As 剩余成本金额, Sum(a.零售金额) As 剩余零售金额, a.成本价, a.零售价, a.对方部门id, Nvl(a.批次, 0),
           b.药库分批, b.药房分批, a.批准文号
    Into v_剩余数量, v_剩余成本金额, v_剩余零售金额, v_成本价, v_零售价, v_库房id, v_批次, v_药库分批, v_药房分批, v_批准文号
    From 药品收发记录 A, 药品规格 B
    Where a.No = No_In And a.药品id = b.药品id And a.单据 = 6 And a.药品id = 药品id_In And a.序号 = 序号_In
    Group By a.成本价, a.零售价, a.对方部门id, Nvl(a.批次, 0), b.药库分批, b.药房分批, a.批准文号;
  
    --V_分批:(原分批,现分批为批次;否则为零)原不分批,现分批,本过程不考虑
    --因为对于对方库房，相当于出库，而对于当前库房，相当于入库，所以当前库房不予检查，仅检查退库那条记录
    Select Nvl(a.批次, 0)
    Into v_批次
    From 药品收发记录 A
    Where a.No = No_In And a.单据 = 6 And a.药品id = 药品id_In And a.序号 = 序号_In + 1 And Mod(a.记录状态, 3) = 0;
  
    --冲销数量大于剩余数量，不允许
    If v_剩余数量 < 冲销数量_In Then
      Raise Err_Isnonum;
    End If;
  
    v_成本金额 := Round(冲销数量_In / v_剩余数量 * v_剩余成本金额, Intdigit);
    v_零售金额 := Round(冲销数量_In / v_剩余数量 * v_剩余零售金额, Intdigit);
    v_差价     := v_零售金额 - v_成本金额;
  
    For v_药品收发记录 In c_药品收发记录 Loop
      Select 药品收发记录_Id.Nextval Into v_收发id From Dual;
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 原产地, 批号, 效期, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 零售金额,
         差价, 摘要, 填制人, 填制日期, 审核人, 审核日期, 配药人, 配药日期, 供药单位id, 批准文号, 生产日期, 扣率, 单量, 频次)
      Values
        (v_收发id, Decode(原记录状态_In, 1, 2, 原记录状态_In + 2), 6, No_In, v_药品收发记录.序号, v_药品收发记录.库房id, v_药品收发记录.对方部门id,
         v_药品收发记录.入出类别id, v_药品收发记录.入出系数, 药品id_In, v_药品收发记录.批次, v_药品收发记录.产地, v_药品收发记录.原产地, v_药品收发记录.批号, v_药品收发记录.效期,
         -冲销数量_In, -冲销数量_In, v_成本价, -v_成本金额, v_零售价, -v_零售金额, -v_差价, 摘要_In, 填制人_In, 填制日期_In, 填制人_In, 填制日期_In,
         v_药品收发记录.配药人, v_药品收发记录.配药日期, v_药品收发记录.供药单位id, v_药品收发记录.批准文号, v_药品收发记录.生产日期, v_药品收发记录.扣率, v_药品收发记录.单量,
         v_药品收发记录.频次);
    
      --更改药品库存表的相应数据
      If v_药品收发记录.入出系数 = 1 Then
        Zl_药品库存_Update(v_收发id, 3, 1, n_操作类型);
      Else
        Zl_药品库存_Update(v_收发id, 3, 0);
      End If;
    
      --处理调价后冲销
      Zl_药品收发记录_调价修正(v_收发id);
    End Loop;
  
    b_Message.Zlhis_Drug_004(No_In);
  End If;
Exception
  When Err_Isstriked Then
    Raise_Application_Error(-20101, '[ZLSOFT]该单据已经被他人冲销！[ZLSOFT]');
  When Err_Isbatch Then
    Raise_Application_Error(-20102, '[ZLSOFT]该单据中包含有一条原来不分批，现在分批的药品[' || v_Druginf || ']，不能冲销！[ZLSOFT]');
  When Err_Isnonum Then
    Raise_Application_Error(-20103, '[ZLSOFT]该单据中第' || Ceil(序号_In / 2) || '行的药品冲销的数量大于了剩余的数据，不能冲销！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品移库_Strike;
/

--117925:刘涛,2017-12-07,排序导致死锁处理
Create Or Replace Procedure Zl_药品其他出库_Delete(
  No_In In 药品收发记录.No%Type
) Is
  Err_Isverified Exception;
  n_库房id 药品收发记录.库房id%Type;

  Cursor c_药品收发记录 Is
    Select ID From 药品收发记录 Where NO = No_In And 单据 = 11 Order By 药品id,批次;
Begin
  For v_药品收发记录 In c_药品收发记录 Loop
    Zl_药品库存_Update(v_药品收发记录.Id, 1);
  End Loop;

  Begin
    Select Distinct 库房id
    Into n_库房id
    From 药品收发记录
    Where NO = No_In And 单据 = 11 And 记录状态 = 1 And 审核人 Is Null And 入出系数 = -1;
  Exception
    When Others Then
      n_库房id := 0;
  End;
  Delete From 药品收发记录 Where NO = No_In And 单据 = 11 And 记录状态 = 1 And 审核人 Is Null;

  If Sql%RowCount = 0 Then
    Raise Err_Isverified;
  End If;

Exception
  When Err_Isverified Then
    Raise_Application_Error(-20101, '[ZLSOFT]该单据已经被他人删除或已被人审核！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品其他出库_Delete;
/

--119490:刘涛,2018-01-05,药品留存可用数量处理
--117925:刘涛,2017-12-07,排序导致死锁处理
Create Or Replace Procedure Zl_药品领用_Delete
(
  No_In       In 药品收发记录.No%Type,
  记录状态_In In 药品收发记录.记录状态%Type := 1
  
) Is
  Err_Isverified Exception;
  n_库房id 药品收发记录.库房id%Type;

  Cursor c_药品收发记录 Is
    Select ID, 填写数量, 库房id, 批次, 药品id, 批号, 效期, 产地, 批准文号, 对方部门id, 发药方式
    From 药品收发记录
    Where NO = No_In And 单据 = 7
    Order By 药品id,批次;
  v_按月留存领用 Varchar2(4000);

Begin
  Select zl_GetSysParameter('按月留存领用', 1305) Into v_按月留存领用 From Dual;
  If 记录状态_In = 1 Then
    --通过循环，恢复原来的可用数量
    For v_药品收发记录 In c_药品收发记录 Loop
      Zl_药品库存_Update(v_药品收发记录.Id, 1);
    End Loop;
  End If;

  Begin
    Select Distinct 库房id
    Into n_库房id
    From 药品收发记录
    Where NO = No_In And 单据 = 7 And 记录状态 = 1 And 审核人 Is Null;
  Exception
    When Others Then
      n_库房id := 0;
  End;
  Delete From 药品收发记录 Where NO = No_In And 单据 = 7 And 记录状态 = 记录状态_In And 审核人 Is Null;

  If Sql%RowCount = 0 Then
    Raise Err_Isverified;
  End If;
Exception
  When Err_Isverified Then
    Raise_Application_Error(-20101, '[ZLSOFT]该单据已经被他人删除或已被人审核！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品领用_Delete;
/

--117925:刘涛,2017-12-06,排序导致死锁处理
Create Or Replace Procedure Zl_药品外购_Delete(
  No_In In 药品收发记录.No%Type
) Is
  Err_Isverified Exception;
  n_库房id 药品收发记录.库房id%Type;

  Cursor c_药品收发记录 Is
    Select ID From 药品收发记录 Where NO = No_In And 单据 = 1 Order By 药品id,批次,序号;
Begin

  --通过循环，恢复原来的可用数量
  For v_药品收发记录 In c_药品收发记录 Loop
    --调用库存更新过程
    Zl_药品库存_Update(v_药品收发记录.Id, 1);
  End Loop;

  Begin
    Select Distinct 库房id Into n_库房id From 药品收发记录 Where NO = No_In And 单据 = 1 And Nvl(发药方式, 0) = 1;
  Exception
    When Others Then
      n_库房id := 0;
  End;

  Delete 应付记录 Where 系统标识 = 1 And 收发id In (Select ID From 药品收发记录 Where NO = No_In And 单据 = 1);

  --对应应付记录的删除通过级联删除
  Delete --删除本身
  From 药品收发记录
  Where NO = No_In And 单据 = 1 And 记录状态 = 1 And 审核人 Is Null;

  If Sql%RowCount = 0 Then
    Raise Err_Isverified;
  End If;

Exception
  When Err_Isverified Then
    Raise_Application_Error(-20101, '[ZLSOFT]该单据已经被他人删除或已被人审核！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品外购_Delete;
/

--117925:刘涛,2017-12-06,排序导致死锁处理
Create Or Replace Procedure Zl_药品外购_Verify
(
  Newno_In    In 药品收发记录.No%Type := Null,
  Oldno_In    In 药品收发记录.No%Type := Null,
  审核人_In   In 药品收发记录.审核人%Type := Null,
  审核日期_In In 药品收发记录.审核日期%Type := Sysdate
) Is
  Err_Isverified Exception;
  Err_Isbatch Exception;
  v_Druginf        Varchar2(50); --原不分批现在分批的药品信息
  v_供药单位id     药品收发记录.供药单位id%Type;
  v_发票金额       应付记录.发票金额%Type;
  v_可用数量       药品库存.可用数量%Type;
  v_时价分批       Number(1);
  v_Newno          药品收发记录.No%Type;
  n_New序号        Number;
  n_收发id         药品收发记录.Id%Type;
  n_调整额         药品收发记录.零售金额%Type;
  n_入出类别id     药品收发记录.入出类别id%Type;
  n_售价入出类别id 药品收发记录.入出类别id%Type;
  n_入出系数       药品收发记录.入出系数%Type;

  Cursor c_药品收发记录 Is
    Select a.Id, a.零售价, a.实际数量, a.零售金额, a.差价, a.库房id, a.药品id, a.批次, a.供药单位id, a.成本价, a.批号, a.效期, a.产地, a.原产地, a.入出类别id, a.生产日期,
           a.批准文号, Nvl(b.是否变价, 0) As 时价, Nvl(a.发药方式, 0) As 退库, a.灭菌效期, a.扣率, Nvl(a.计划id, 0) As 计划id,
           Nvl(a.费用id, 0) As 费用id, a.序号
    From 药品收发记录 A, 收费项目目录 B
    Where a.药品id = b.Id And a.No = Newno_In And a.单据 = 1 And a.记录状态 = 1
    Order By a.药品id,a.批次;
Begin

  n_New序号 := 1;

  Select b.Id, b.系数
  Into n_入出类别id, n_入出系数
  From 药品单据性质 A, 药品入出类别 B
  Where a.类别id = b.Id And a.单据 = 5 And Rownum < 2;

  Select 类别id Into n_售价入出类别id From 药品单据性质 Where 单据 = 13 And Rownum < 2;

  Update 药品收发记录
  Set 审核人 = Nvl(审核人_In, 审核人), 审核日期 = 审核日期_In
  Where NO = Newno_In And 单据 = 1 And 记录状态 = 1 And 审核人 Is Null;

  If Sql%RowCount = 0 Then
    Raise Err_Isverified;
  End If;

  --主要针对原不分批现在分批的药品，不能对其审核
  Begin
    Select Distinct '(' || i.编码 || ')' || Nvl(n.名称, i.名称) As 药品信息
    Into v_Druginf
    From 药品收发记录 A, 药品规格 B, 收费项目目录 I, 收费项目别名 N
    Where a.药品id = b.药品id And a.药品id = i.Id And a.药品id = n.收费细目id(+) And n.性质(+) = 3 And a.No = Newno_In And a.单据 = 1 And
          a.记录状态 = 1 And Nvl(a.批次, 0) = 0 And
          ((Nvl(b.药库分批, 0) = 1 And
          a.库房id Not In (Select 部门id From 部门性质说明 Where (工作性质 Like '%药房') Or (工作性质 Like '制剂室'))) Or Nvl(b.药房分批, 0) = 1) And
          Rownum = 1;
  Exception
    When Others Then
      v_Druginf := '';
  End;

  If v_Druginf Is Not Null Then
    Raise Err_Isbatch;
  End If;

  --原分批现不分批的药品,在审核时，要处理他
  Update 药品收发记录
  Set 批次 = 0
  Where ID In
        (Select ID
         From 药品收发记录 A, 药品规格 B
         Where b.药品id = a.药品id And a.No = Newno_In And a.单据 = 1 And a.记录状态 = 1 And Nvl(a.批次, 0) > 0 And
               (Nvl(b.药库分批, 0) = 0 Or
               (Nvl(b.药房分批, 0) = 0 And
               a.库房id In (Select 部门id From 部门性质说明 Where (工作性质 Like '%药房') Or (工作性质 Like '制剂室')))));

  For v_药品收发记录 In c_药品收发记录 Loop
    --处理采购计划表中的执行数量，多次导入采用累加执行数量
    If v_药品收发记录.计划id > 0 Then
      Update 药品计划内容
      Set 执行数量 = Nvl(执行数量, 0) + v_药品收发记录.实际数量
      Where 计划id = v_药品收发记录.计划id And 药品id = v_药品收发记录.药品id;
    End If;
  
    --如果是分批药品退库，取原来的成本价
    If v_药品收发记录.退库 = 1 Then
      --调用库存更新记录更新库存表
      Zl_药品库存_Update(v_药品收发记录.Id, 2, 1);
    
    Else
      --调用库存更新记录更新库存表
      If Oldno_In Is Null Then
        Zl_药品库存_Update(v_药品收发记录.Id, 2, 0);
      Else
        --财务审核单据为了保持库存成本价不变，所以用出库方式
        Zl_药品库存_Update(v_药品收发记录.Id, 2, 1);
      End If;
    End If;
    
    Zl_未审药品记录_Delete(v_药品收发记录.Id);
  
    --时价审核时更新上次售价（排除退库和财务审核）
    If v_药品收发记录.时价 = 1 And v_药品收发记录.退库 = 0 And v_药品收发记录.费用id <> 2 Then
      Update 药品规格 Set 上次售价 = v_药品收发记录.零售价 Where 药品id = v_药品收发记录.药品id;
    End If;
  
    --更新该药品的成本价（排除退库和财务审核）
    If v_药品收发记录.退库 = 0 And v_药品收发记录.费用id <> 2 Then
      Update 药品规格
      Set 成本价 = v_药品收发记录.成本价, 上次供应商id = v_药品收发记录.供药单位id, 上次批号 = v_药品收发记录.批号, 上次生产日期 = v_药品收发记录.生产日期, 上次产地 = v_药品收发记录.产地,
          上次批准文号 = v_药品收发记录.批准文号, 原产地 = v_药品收发记录.原产地
      Where 药品id = v_药品收发记录.药品id;
    End If;
  
    If (Oldno_In Is Null And v_药品收发记录.退库 = 1) Or Oldno_In Is Not Null Then
      --1.退库时因为价格会变动，调用调价修正保持当前库存价格关系不变
      --2.财务审核时因为价格会变动，调用调价修正保持当前库存价格关系不变
      Zl_药品收发记录_调价修正(v_药品收发记录.Id);
    End If;
  End Loop;

  --对应付余额表进行处理
  --此处用一个块，主要是解决没有对应发票号的记录
  Begin
    Update 应付记录
    Set 审核人 = 审核人_In, 审核日期 = 审核日期_In
    Where 入库单据号 = Newno_In And 系统标识 = 1 And 记录性质 = 0 And 记录状态 = 1;
  
    Select b.单位id, Sum(发票金额)
    Into v_供药单位id, v_发票金额
    From 药品收发记录 A, 应付记录 B
    Where a.Id = b.收发id And a.No = Newno_In And a.单据 = 1 And b.系统标识 = 1
    Group By b.单位id;
  
    If Nvl(v_供药单位id, 0) <> 0 Then
      Update 应付余额 Set 金额 = Nvl(金额, 0) + Nvl(v_发票金额, 0) Where 单位id = v_供药单位id And 性质 = 1;
    
      If Sql%NotFound Then
        Insert Into 应付余额 (单位id, 性质, 金额) Values (v_供药单位id, 1, v_发票金额);
      End If;
    End If;
  Exception
    When No_Data_Found Then
      Null;
  End;
Exception
  When Err_Isverified Then
    Raise_Application_Error(-20101, '[ZLSOFT]该单据已经被他人审核！[ZLSOFT]');
  When Err_Isbatch Then
    Raise_Application_Error(-20102, '[ZLSOFT]该单据中包含有一条原来不分批，现在分批的药品[' || v_Druginf || ']，不能审核！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品外购_Verify;
/

--117925:刘涛,2017-12-06,排序导致死锁处理
Create Or Replace Procedure Zl_药品其他入库_Delete(
  No_In In 药品收发记录.No%Type
) Is
  Err_Isverified Exception;
  Cursor c_药品收发记录 Is
    Select ID From 药品收发记录 Where NO = No_In And 单据 = 4 Order By 药品id,批次,序号;
Begin
  --通过循环，恢复原来的可用数量
  For v_药品收发记录 In c_药品收发记录 Loop
    Zl_药品库存_Update(v_药品收发记录.Id, 1);
  End Loop;

  --删除药品收发记录 
  Delete --删除本身 
  From 药品收发记录
  Where NO = No_In And 单据 = 4 And 记录状态 = 1 And 审核人 Is Null;

  If Sql%RowCount = 0 Then
    Raise Err_Isverified;
  End If;
Exception
  When Err_Isverified Then
    Raise_Application_Error(-20101, '[ZLSOFT]该单据已经被他人删除或已被人审核！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品其他入库_Delete;
/

--117925:刘涛,2017-12-06,排序导致死锁处理
Create Or Replace Procedure Zl_药品其他入库_Verify
(
  No_In     In 药品收发记录.No%Type := Null,
  审核人_In In 药品收发记录.审核人%Type := Null
) Is
  Err_Isverified Exception;
  Err_Isbatch Exception;
  v_Druginf Varchar2(50); --原不分批现在分批的药品信息

  Cursor c_药品收发记录 Is
    Select a.Id, a.实际数量, a.零售金额, a.零售价, a.差价, a.库房id, a.药品id, a.批次, a.成本价, a.批号, a.效期, a.产地, a.原产地, a.入出类别id, a.生产日期, a.批准文号,
           a.供药单位id, Nvl(b.是否变价, 0) As 时价
    From 药品收发记录 A, 收费项目目录 B
    Where a.药品id = b.Id And a.No = No_In And a.单据 = 4 And a.记录状态 = 1
    Order By a.药品id,a.批次;
Begin
  Update 药品收发记录
  Set 审核人 = 审核人_In, 审核日期 = Sysdate
  Where NO = No_In And 单据 = 4 And 记录状态 = 1 And 审核人 Is Null;

  If Sql%RowCount = 0 Then
    Raise Err_Isverified;
  End If;

  --主要针对原不分批现在分批的药品，不能对其审核
  Begin
    Select Distinct '(' || i.编码 || ')' || Nvl(n.名称, i.名称) As 药品信息
    Into v_Druginf
    From 药品收发记录 A, 药品规格 B, 收费项目目录 I, 收费项目别名 N
    Where a.药品id = b.药品id And a.药品id = i.Id And a.药品id = n.收费细目id(+) And n.性质(+) = 3 And a.No = No_In And a.单据 = 4 And
          a.记录状态 = 1 And Nvl(a.批次, 0) = 0 And
          ((Nvl(b.药库分批, 0) = 1 And
          a.库房id Not In (Select 部门id From 部门性质说明 Where (工作性质 Like '%药房') Or (工作性质 Like '制剂室'))) Or Nvl(b.药房分批, 0) = 1) And
          Rownum = 1;
  Exception
    When Others Then
      v_Druginf := '';
  End;

  If v_Druginf Is Not Null Then
    Raise Err_Isbatch;
  End If;

  --原分批现不分批的药品,在审核时，要处理他
  Update 药品收发记录
  Set 批次 = 0
  Where ID In
        (Select ID
         From 药品收发记录 A, 药品规格 B
         Where b.药品id = a.药品id And a.No = No_In And a.单据 = 4 And a.记录状态 = 1 And Nvl(a.批次, 0) > 0 And
               (Nvl(b.药库分批, 0) = 0 Or
               (Nvl(b.药房分批, 0) = 0 And
               a.库房id In (Select 部门id From 部门性质说明 Where (工作性质 Like '%药房') Or (工作性质 Like '制剂室')))));

  For v_药品收发记录 In c_药品收发记录 Loop
    --更新库存 入库审核
    Zl_药品库存_Update(v_药品收发记录.Id, 2, 0);
    
    Zl_未审药品记录_Delete(v_药品收发记录.Id);
    
    Update 药品规格
    Set 成本价 = v_药品收发记录.成本价, 上次售价 = Decode(v_药品收发记录.时价, 1, v_药品收发记录.零售价, Null),
        上次供应商id = Decode(v_药品收发记录.供药单位id, Null, 上次供应商id, v_药品收发记录.供药单位id), 上次批号 = v_药品收发记录.批号, 上次生产日期 = v_药品收发记录.生产日期,
        上次产地 = v_药品收发记录.产地, 上次批准文号 = v_药品收发记录.批准文号, 原产地 = v_药品收发记录.原产地
    Where 药品id = v_药品收发记录.药品id;
  End Loop;
Exception
  When Err_Isverified Then
    Raise_Application_Error(-20101, '[ZLSOFT]该单据已经被他人审核！[ZLSOFT]');
  When Err_Isbatch Then
    Raise_Application_Error(-20102, '[ZLSOFT]该单据中包含有一条原来不分批，现在分批的药品[' || v_Druginf || ']，不能审核！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品其他入库_Verify;
/

--117925:刘涛,2017-12-06,排序导致死锁处理
Create Or Replace Procedure Zl_协定入库_Delete(
  No_In In 药品收发记录.No%Type
) Is
  Err_Isverified Exception;
  n_库房id 药品收发记录.库房id%Type;

  Cursor c_药品收发记录 Is
    Select ID From 药品收发记录 Where NO = No_In And 单据 = 3 Order By 药品id,批次;
Begin
  --通过循环，恢复所有构成协定药原来的可用数量
  For v_药品收发记录 In c_药品收发记录 Loop
    Zl_药品库存_Update(v_药品收发记录.Id, 1);
  End Loop;

  Begin
    Select Distinct 库房id Into n_库房id From 药品收发记录 Where NO = No_In And 单据 = 3 And 入出系数 = -1;
  Exception
    When Others Then
      n_库房id := 0;
  End;

  Delete --删除本身及相应的构成协定药 
  From 药品收发记录
  Where NO = No_In And 单据 = 3 And 记录状态 = 1 And 审核人 Is Null;

  If Sql%RowCount = 0 Then
    Raise Err_Isverified;
  End If;
Exception
  When Err_Isverified Then
    Raise_Application_Error(-20101, '[ZLSOFT]该单据已经被他人删除或已被人审核！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_协定入库_Delete;
/

--117925:刘涛,2017-12-06,排序导致死锁处理
Create Or Replace Procedure Zl_协定入库_Verify
(
  No_In     In 药品收发记录.No%Type := Null,
  审核人_In In 药品收发记录.审核人%Type := Null
) Is
  Err_Isverified Exception;

  Cursor c_药品收发记录 Is
    Select ID, 填写数量, 零售价, 零售金额, 差价, 库房id, 药品id, 批次, 成本价, 批号, 产地, 入出类别id, 入出系数, 对方部门id, 供药单位id, 生产日期, 批准文号, 效期
    From 药品收发记录
    Where NO = No_In And 单据 = 3 And 记录状态 = 1
	Order By 药品id,批次;
Begin
  Update 药品收发记录
  Set 审核人 = Nvl(审核人_In, 审核人), 审核日期 = Sysdate
  Where NO = No_In And 单据 = 3 And 记录状态 = 1 And 审核人 Is Null;

  If Sql%RowCount = 0 Then
    Raise Err_Isverified;
  End If;

  For v_药品收发记录 In c_药品收发记录 Loop
    --调用库存更新过程
    If v_药品收发记录.入出系数 = 1 Then
      Zl_药品库存_Update(v_药品收发记录.Id, 2, 0);
    Else
      Zl_药品库存_Update(v_药品收发记录.Id, 2, 1);
      
    End If;
    
    Zl_未审药品记录_Delete(v_药品收发记录.Id);
    
    If v_药品收发记录.入出系数 = 1 Then
      --只有入业务才处理
      --更新该药品的成本价
      Update 药品规格 Set 成本价 = v_药品收发记录.成本价 Where 药品id = v_药品收发记录.药品id;
    End If;
  
  End Loop;
Exception
  When Err_Isverified Then
    Raise_Application_Error(-20101, '[ZLSOFT]该单据已经被他人审核！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_协定入库_Verify;
/

--117925:刘涛,2017-12-06,排序导致死锁处理
Create Or Replace Procedure Zl_协定入库_Strike
(
  No_In     In 药品收发记录.No%Type,
  审核人_In In 药品收发记录.审核人%Type
) Is
  Err_Isstriked Exception;
  

  Cursor c_药品收发记录 Is
    Select ID, 库房id, 入出类别id, 入出系数, 药品id, 填写数量, 批次, 实际数量, 成本价, 零售金额, 差价, 产地, 批号, 效期, 供药单位id, 生产日期, 批准文号
    From 药品收发记录 A
    Where NO = No_In And 单据 = 3 And 记录状态 = 2
	Order By 药品id,批次;
Begin
  Update 药品收发记录 Set 记录状态 = 3 Where NO = No_In And 单据 = 3 And 记录状态 = 1;

  If Sql%RowCount = 0 Then
    Raise Err_Isstriked;
  End If;
  
  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 对方部门id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 零售金额, 差价, 摘要,
     填制人, 填制日期, 审核人, 审核日期, 费用id, 扣率, 供药单位id, 生产日期, 批准文号)
    Select 药品收发记录_Id.Nextval, 2, 单据, No_In, 序号, 库房id, 入出类别id, 对方部门id, 入出系数, 药品id, 批次, 产地, 批号, 效期, -填写数量, -实际数量, 成本价,
           -成本金额, 零售价, -零售金额, -差价, 摘要, 审核人_In, Sysdate, 审核人_In, Sysdate, 费用id, 扣率, 供药单位id, 生产日期, 批准文号
    From 药品收发记录
    Where NO = No_In And 单据 = 3 And 记录状态 = 3;
  
  
  For v_药品收发记录 In c_药品收发记录 Loop
    --更改药品库存表的相应数据
    If v_药品收发记录.入出系数 = 1 Then
      Zl_药品库存_Update(v_药品收发记录.Id, 3, 1);
    Else
      Zl_药品库存_Update(v_药品收发记录.Id, 3, 0);
    End If;
  
    --处理调价后冲销
    Zl_药品收发记录_调价修正(v_药品收发记录.Id);
  End Loop;
Exception
  When Err_Isstriked Then
    Raise_Application_Error(-20101, '[ZLSOFT]该单据已经被他人冲销！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_协定入库_Strike;
/

--117925:刘涛,2017-12-06,排序导致死锁处理
Create Or Replace Procedure Zl_自制入库_Delete(
  No_In In 药品收发记录.No%Type
) Is
  Err_Isverified Exception;
  n_库房id 药品收发记录.库房id%Type;

  Cursor c_药品收发记录 Is
    Select ID From 药品收发记录 Where NO = No_In And 单据 = 2 Order By 药品id,批次;
Begin
  --通过循环，恢复所有构成原料药原来的可用数量
  For v_药品收发记录 In c_药品收发记录 Loop
    --更新库存
    Zl_药品库存_Update(v_药品收发记录.Id, 1);
  End Loop;

  Begin
    Select Distinct 库房id
    Into n_库房id
    From 药品收发记录
    Where NO = No_In And 单据 = 2 And 记录状态 = 1 And 入出系数 = -1 And 审核人 Is Null;
  Exception
    When Others Then
      n_库房id := 0;
  End;

  Delete --删除本身及相应的构成原料药 
  From 药品收发记录
  Where NO = No_In And 单据 = 2 And 记录状态 = 1 And 审核人 Is Null;

  If Sql%RowCount = 0 Then
    Raise Err_Isverified;
  End If;
Exception
  When Err_Isverified Then
    Raise_Application_Error(-20101, '[ZLSOFT]该单据已经被他人删除或已被人审核！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_自制入库_Delete;
/

--117925:刘涛,2017-12-06,排序导致死锁处理
Create Or Replace Procedure Zl_自制入库_Verify
(
  No_In     In 药品收发记录.No%Type := Null,
  审核人_In In 药品收发记录.审核人%Type := Null
) Is
  Err_Isverified Exception;

  n_库房id 药品收发记录.库房id%Type;

  Cursor c_药品收发记录 Is
    Select ID, 实际数量, Nvl(零售价, 0) As 零售价, 零售金额, 差价, 库房id, 药品id, 批次, 成本价, 批号, 效期, 产地, 入出类别id, 入出系数, 对方部门id, 供药单位id, 生产日期,
           批准文号
    From 药品收发记录
    Where NO = No_In And 单据 = 2 And 记录状态 = 1
    Order By 药品id,批次;
Begin
  Update 药品收发记录
  Set 审核人 = Nvl(审核人_In, 审核人), 审核日期 = Sysdate
  Where NO = No_In And 单据 = 2 And 记录状态 = 1 And 审核人 Is Null;

  If Sql%RowCount = 0 Then
    Raise Err_Isverified;
  End If;

  For v_药品收发记录 In c_药品收发记录 Loop
    --调用库存更新过程
    If v_药品收发记录.入出系数 = 1 Then
      Zl_药品库存_Update(v_药品收发记录.Id, 2, 0);
    Else
      Zl_药品库存_Update(v_药品收发记录.Id, 2, 1);
      n_库房id := v_药品收发记录.库房id;
    End If;
    
    Zl_未审药品记录_Delete(v_药品收发记录.Id);
    
    If v_药品收发记录.入出系数 = 1 Then
      --只有入业务才处理
      --更新该药品的成本价
      Update 药品规格 Set 成本价 = v_药品收发记录.成本价 Where 药品id = v_药品收发记录.药品id;
    End If;
  End Loop;
Exception
  When Err_Isverified Then
    Raise_Application_Error(-20101, '[ZLSOFT]该单据已经被他人审核！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_自制入库_Verify;
/

--117925:刘涛,2017-12-06,排序导致死锁处理
Create Or Replace Procedure Zl_自制入库_Strike
(
  No_In     In 药品收发记录.No%Type,
  审核人_In In 药品收发记录.审核人%Type
) Is
  Err_Isstriked Exception;

  v_入出类别id 药品收发记录.入出类别id%Type;

  Cursor c_药品收发记录 Is
    Select ID, 库房id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 实际数量, 成本价, 零售金额, 差价, 供药单位id, 生产日期, 批准文号, 单量
    From 药品收发记录 A
    Where NO = No_In And 单据 = 2 And 记录状态 = 2
    Order By 药品id,批次;
Begin
  Update 药品收发记录 Set 记录状态 = 3 Where NO = No_In And 单据 = 2 And 记录状态 = 1;

  If Sql%RowCount = 0 Then
    Raise Err_Isstriked;
  End If;
  
  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 对方部门id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 零售金额, 差价, 摘要,
     填制人, 填制日期, 审核人, 审核日期, 费用id, 扣率, 供药单位id, 生产日期, 批准文号, 单量)
    Select 药品收发记录_Id.Nextval, 2, 2, No_In, 序号, 库房id, 入出类别id, 对方部门id, 入出系数, 药品id, 批次, 产地, 批号, 效期, -填写数量, -实际数量, 成本价,
           -成本金额, 零售价, -零售金额, -差价, 摘要, 审核人_In, Sysdate, 审核人_In, Sysdate, 费用id, 扣率, 供药单位id, 生产日期, 批准文号, 单量
    From 药品收发记录
    Where NO = No_In And 单据 = 2 And 记录状态 = 3;
  

  For v_药品收发记录 In c_药品收发记录 Loop
    --更改药品库存表的相应数据
    If v_药品收发记录.入出系数 = 1 Then
      Zl_药品库存_Update(v_药品收发记录.Id, 3, 1);
    Else
      Zl_药品库存_Update(v_药品收发记录.Id, 3, 0);
    End If;
  
    --处理调价后冲销
    Zl_药品收发记录_调价修正(v_药品收发记录.Id);
  End Loop;
Exception
  When Err_Isstriked Then
    Raise_Application_Error(-20101, '[ZLSOFT]该单据已经被他人冲销！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_自制入库_Strike;
/

--115082:董露露,2017-12-06,解决病区床位管理和护士站中床位排序的问题
Create Or Replace Procedure Zl_床位状况记录_Insert
(
  床号_In     床位状况记录.床号%Type,
  病区id_In   床位状况记录.病区id%Type,
  科室id_In   床位状况记录.科室id%Type,
  房间号_In   床位状况记录.房间号%Type,
  性别分类_In 床位状况记录.性别分类%Type,
  床位编制_In 床位状况记录.床位编制%Type,
  等级id_In   床位状况记录.等级id%Type,
  新增_In     Number,
  顺序号_In   床位状况记录.顺序号%Type
) As
  v_Count  Number;
  v_科室id 床位状况记录.科室id%Type;
  v_Error  Varchar2(255);
  Err_Custom Exception;
Begin

  If 新增_In = 1 Then
    Select Zl_住院日报_Count(科室id_In, Sysdate) Into v_Count From Dual;
    If v_Count > 0 Then
      v_Error := '已产生业务时间内的住院日报,不能办理该业务!';
      Raise Err_Custom;
    End If;

    Insert Into 床位增减记录
      (日期, 变动, 病区id, 床号, 科室id, 床位编制)
    Values
      (Sysdate, 1, 病区id_In, 床号_In, 科室id_In, 床位编制_In);

    Insert Into 床位状况记录
      (病区id, 床号, 科室id, 房间号, 性别分类, 床位编制, 等级id, 状态, 病人id, 共用,顺序号)
    Values
      (病区id_In, 床号_In, 科室id_In, 房间号_In, 性别分类_In, 床位编制_In, Decode(等级id_In, 0, Null, 等级id_In), '空床', Null,
       Decode(科室id_In, Null, 1, 0),顺序号_In);
  Else
    Select 科室id Into v_科室id From 床位状况记录 Where 病区id = 病区id_In And 床号 = 床号_In;
    If Nvl(科室id_In, 0) <> Nvl(v_科室id, 0) Then
      If Nvl(v_科室id, 0) <> 0 Then
        Insert Into 床位增减记录
          (日期, 变动, 病区id, 床号, 科室id, 床位编制)
        Values
          (Sysdate, -1, 病区id_In, 床号_In, v_科室id, 床位编制_In);
      End If;
      If Nvl(科室id_In, 0) <> 0 Then
        Insert Into 床位增减记录
          (日期, 变动, 病区id, 床号, 科室id, 床位编制)
        Values
          (Sysdate, 1, 病区id_In, 床号_In, 科室id_In, 床位编制_In);
      End If;
    End If;
    Update 床位状况记录
    Set 科室id = 科室id_In, 房间号 = 房间号_In, 性别分类 = 性别分类_In, 床位编制 = 床位编制_In, 等级id = 等级id_In, 共用 = Decode(科室id_In, Null, 1, 0),顺序号=顺序号_In
    Where 病区id = 病区id_In And 床号 = 床号_In;
  End If;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_床位状况记录_Insert;
/

--101765:秦龙,2017-12-06,增加传参“是否辅助用药”
Create Or Replace Procedure Zl_草药品种_Insert
(
  类别_In         In 诊疗项目目录.类别%Type := Null,
  分类id_In       In 诊疗项目目录.分类id%Type := Null,
  Id_In           In 诊疗项目目录.Id%Type,
  编码_In         In 诊疗项目目录.编码%Type := Null,
  名称_In         In 诊疗项目目录.名称%Type := Null,
  拼音_In         In 诊疗项目别名.简码%Type := Null,
  五笔_In         In 诊疗项目别名.简码%Type := Null,
  英文_In         In 诊疗项目别名.名称%Type := Null,
  单位_In         In 诊疗项目目录.计算单位%Type := Null,
  毒理分类_In     In 药品特性.毒理分类%Type := Null,
  价值分类_In     In 药品特性.价值分类%Type := Null,
  货源情况_In     In 药品特性.货源情况%Type := Null,
  用药梯次_In     In 药品特性.用药梯次%Type := Null,
  药品类型_In     In 药品特性.药品类型%Type := Null,
  处方职务_In     In 药品特性.处方职务%Type := '00',
  处方限量_In     In 药品特性.处方限量%Type := Null,
  单独应用_In     In 诊疗项目目录.单独应用%Type := Null,
  是否原料_In     In 药品特性.是否原料%Type := 0,
  适用性别_In     In 诊疗项目目录.适用性别%Type := 0,
  参考目录id_In   In 诊疗项目目录.参考目录id%Type := Null,
  其他别名_In     In Varchar2 := Null, --以"|"分隔的别名记录，每条记录按"名称^拼音^五笔"组织
  自管药_In       In Number := Null,
  是否辅助用药_In In 药品特性.是否辅助用药%Type := 0
) Is
  v_Records Varchar2(4000); --临时记录别名数据的字符串
  v_Currrec Varchar2(1000); --包含在别名记录中的一条别名
  v_Fields  Varchar2(1000); --临时记录一条别名的字符串
  v_名称    诊疗项目目录.名称%Type;
  v_拼音    诊疗项目别名.简码%Type;
  v_五笔    诊疗项目别名.简码%Type;
Begin
  Insert Into 诊疗项目目录
    (类别, 分类id, ID, 编码, 名称, 计算单位, 计算方式, 执行频率, 单独应用, 组合项目, 执行安排, 计价性质, 服务对象, 建档时间, 撤档时间, 参考目录id, 适用性别)
  Values
    (类别_In, 分类id_In, Id_In, 编码_In, 名称_In, 单位_In, 1, 0, 单独应用_In, 0, 0, 0, 3, Sysdate,
     To_Date('3000-01-01', 'YYYY-MM-DD'), 参考目录id_In, 适用性别_In);

  Insert Into 药品特性
    (药名id, 药品剂型, 毒理分类, 价值分类, 货源情况, 用药梯次, 药品类型, 处方职务, 处方限量, 急救药否, 是否新药, 是否原料, 是否皮试, 临床自管药, 是否辅助用药)
  Values
    (Id_In, '方剂', 毒理分类_In, 价值分类_In, 货源情况_In, 用药梯次_In, 药品类型_In, 处方职务_In, 处方限量_In, 0, 0, 是否原料_In, 0, 自管药_In, 是否辅助用药_In);

  If 拼音_In Is Not Null Then
    Insert Into 诊疗项目别名 (诊疗项目id, 名称, 性质, 简码, 码类) Values (Id_In, 名称_In, 1, 拼音_In, 1);
  End If;
  If 五笔_In Is Not Null Then
    Insert Into 诊疗项目别名 (诊疗项目id, 名称, 性质, 简码, 码类) Values (Id_In, 名称_In, 1, 五笔_In, 2);
  End If;
  If 英文_In Is Not Null Then
    Insert Into 诊疗项目别名 (诊疗项目id, 名称, 性质, 简码, 码类) Values (Id_In, 英文_In, 2, Null, 0);
  End If;

  If 其他别名_In Is Null Then
    v_Records := Null;
  Else
    v_Records := 其他别名_In || '|';
  End If;
  While v_Records Is Not Null Loop
    v_Currrec := Substr(v_Records, 1, Instr(v_Records, '|') - 1);
    v_Fields  := v_Currrec;
    v_名称    := Substr(v_Fields, 1, Instr(v_Fields, '^') - 1);
    v_Fields  := Substr(v_Fields, Instr(v_Fields, '^') + 1);
    v_拼音    := Substr(v_Fields, 1, Instr(v_Fields, '^') - 1);
    v_Fields  := Substr(v_Fields, Instr(v_Fields, '^') + 1);
    v_五笔    := v_Fields;
    If v_拼音 Is Not Null Then
      Insert Into 诊疗项目别名 (诊疗项目id, 名称, 性质, 简码, 码类) Values (Id_In, v_名称, 9, v_拼音, 1);
    End If;
    If v_五笔 Is Not Null Then
      Insert Into 诊疗项目别名 (诊疗项目id, 名称, 性质, 简码, 码类) Values (Id_In, v_名称, 9, v_五笔, 2);
    End If;
    v_Records := Replace('|' || v_Records, '|' || v_Currrec || '|');
  End Loop;

  --添加缺省的对应输出单据
  Insert Into 病历单据应用
    (病历文件id, 应用场合, 诊疗项目id)
    Select a.病历文件id, 1, Id_In
    From 病历单据应用 A, 诊疗项目目录 I
    Where a.诊疗项目id = i.Id And i.类别 = 类别_In And 应用场合 = 1 And Rownum < 2;
  Insert Into 病历单据应用
    (病历文件id, 应用场合, 诊疗项目id)
    Select a.病历文件id, 2, Id_In
    From 病历单据应用 A, 诊疗项目目录 I
    Where a.诊疗项目id = i.Id And i.类别 = 类别_In And 应用场合 = 2 And Rownum < 2;

  b_Message.Zlhis_Dict_030(类别_In, Id_In);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_草药品种_Insert;
/

--101765:秦龙,2017-12-06,增加传参“是否辅助用药”
Create Or Replace Procedure Zl_草药品种_Update
(
  分类id_In       In 诊疗项目目录.分类id%Type := Null,
  Id_In           In 诊疗项目目录.Id%Type,
  编码_In         In 诊疗项目目录.编码%Type := Null,
  名称_In         In 诊疗项目目录.名称%Type := Null,
  拼音_In         In 诊疗项目别名.简码%Type := Null,
  五笔_In         In 诊疗项目别名.简码%Type := Null,
  英文_In         In 诊疗项目别名.名称%Type := Null,
  单位_In         In 诊疗项目目录.计算单位%Type := Null,
  毒理分类_In     In 药品特性.毒理分类%Type := Null,
  价值分类_In     In 药品特性.价值分类%Type := Null,
  货源情况_In     In 药品特性.货源情况%Type := Null,
  用药梯次_In     In 药品特性.用药梯次%Type := Null,
  药品类型_In     In 药品特性.药品类型%Type := Null,
  处方职务_In     In 药品特性.处方职务%Type := '00',
  处方限量_In     In 药品特性.处方限量%Type := Null,
  单独应用_In     In 诊疗项目目录.单独应用%Type := Null,
  是否原料_In     In 药品特性.是否原料%Type := 0,
  适用性别_In     In 诊疗项目目录.适用性别%Type := 0,
  参考目录id_In   In 诊疗项目目录.参考目录id%Type := Null,
  其他别名_In     In Varchar2 := Null, --以"|"分隔的别名记录，每条记录按"名称^拼音^五笔"组织
  自管药_In       In Number := Null,
  是否辅助用药_In In 药品特性.是否辅助用药%Type := 0
) Is
  v_Records Varchar2(4000); --临时记录别名数据的字符串
  v_Currrec Varchar2(1000); --包含在别名记录中的一条别名
  v_Fields  Varchar2(1000); --临时记录一条别名的字符串
  v_名称    诊疗项目目录.名称%Type;
  v_拼音    诊疗项目别名.简码%Type;
  v_五笔    诊疗项目别名.简码%Type;
  Err_Notfind Exception;
  v_类别 诊疗项目目录.类别%Type;
Begin
  Update 诊疗项目目录
  Set 分类id = 分类id_In, 编码 = 编码_In, 名称 = 名称_In, 计算单位 = 单位_In, 参考目录id = 参考目录id_In, 适用性别 = 适用性别_In, 单独应用 = 单独应用_In
  Where ID = Id_In
  Returning 类别 Into v_类别;
  If Sql%RowCount = 0 Then
    Raise Err_Notfind;
  End If;

  Update 药品特性
  Set 毒理分类 = 毒理分类_In, 价值分类 = 价值分类_In, 货源情况 = 货源情况_In, 用药梯次 = 用药梯次_In, 药品类型 = 药品类型_In, 处方职务 = 处方职务_In, 处方限量 = 处方限量_In,
      是否原料 = 是否原料_In, 临床自管药 = 自管药_In, 是否辅助用药 = 是否辅助用药_In
  Where 药名id = Id_In;

  Update 收费项目目录 Set 名称 = 名称_In Where ID In (Select 药品id From 药品规格 Where 药名id = Id_In);

  If 拼音_In Is Null Then
    Delete From 诊疗项目别名 Where 诊疗项目id = Id_In And 性质 = 1 And 码类 = 1;
    Delete From 收费项目别名
    Where 收费细目id In (Select 药品id From 药品规格 Where 药名id = Id_In) And 性质 = 1 And 码类 = 1;
  Else
    Update 诊疗项目别名 Set 名称 = 名称_In, 简码 = 拼音_In Where 诊疗项目id = Id_In And 性质 = 1 And 码类 = 1;
    If Sql%RowCount = 0 Then
      Insert Into 诊疗项目别名 (诊疗项目id, 名称, 性质, 简码, 码类) Values (Id_In, 名称_In, 1, 拼音_In, 1);
    End If;
    For r_Spec In (Select 药品id From 药品规格 Where 药名id = Id_In) Loop
      Update 收费项目别名
      Set 名称 = 名称_In, 简码 = 拼音_In
      Where 收费细目id = r_Spec.药品id And 性质 = 1 And 码类 = 1;
      If Sql%RowCount = 0 Then
        Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (r_Spec.药品id, 名称_In, 1, 拼音_In, 1);
      End If;
    End Loop;
  End If;
  If 五笔_In Is Null Then
    Delete From 诊疗项目别名 Where 诊疗项目id = Id_In And 性质 = 1 And 码类 = 2;
    Delete From 收费项目别名
    Where 收费细目id In (Select 药品id From 药品规格 Where 药名id = Id_In) And 性质 = 1 And 码类 = 2;
  Else
    Update 诊疗项目别名 Set 名称 = 名称_In, 简码 = 五笔_In Where 诊疗项目id = Id_In And 性质 = 1 And 码类 = 2;
    If Sql%RowCount = 0 Then
      Insert Into 诊疗项目别名 (诊疗项目id, 名称, 性质, 简码, 码类) Values (Id_In, 名称_In, 1, 五笔_In, 2);
    End If;
    For r_Spec In (Select 药品id From 药品规格 Where 药名id = Id_In) Loop
      Update 收费项目别名
      Set 名称 = 名称_In, 简码 = 五笔_In
      Where 收费细目id = r_Spec.药品id And 性质 = 1 And 码类 = 2;
      If Sql%RowCount = 0 Then
        Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (r_Spec.药品id, 名称_In, 1, 五笔_In, 2);
      End If;
    End Loop;
  End If;
  If 英文_In Is Null Then
    Delete From 诊疗项目别名 Where 诊疗项目id = Id_In And 性质 = 2;
    Delete From 收费项目别名 Where 收费细目id In (Select 药品id From 药品规格 Where 药名id = Id_In) And 性质 = 2;
  Else
    Update 诊疗项目别名 Set 名称 = 英文_In Where 诊疗项目id = Id_In And 性质 = 2;
    If Sql%RowCount = 0 Then
      Insert Into 诊疗项目别名 (诊疗项目id, 名称, 性质, 简码, 码类) Values (Id_In, 英文_In, 2, Null, 0);
    End If;
    For r_Spec In (Select 药品id From 药品规格 Where 药名id = Id_In) Loop
      Update 收费项目别名 Set 名称 = 英文_In Where 收费细目id = r_Spec.药品id And 性质 = 2;
      If Sql%RowCount = 0 Then
        Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (r_Spec.药品id, 英文_In, 2, Null, 0);
      End If;
    End Loop;
  End If;

  Delete From 诊疗项目别名 Where 诊疗项目id = Id_In And 性质 = 9;
  Delete From 收费项目别名 Where 收费细目id In (Select 药品id From 药品规格 Where 药名id = Id_In) And 性质 = 9;
  If 其他别名_In Is Null Then
    v_Records := Null;
  Else
    v_Records := 其他别名_In || '|';
  End If;
  While v_Records Is Not Null Loop
    v_Currrec := Substr(v_Records, 1, Instr(v_Records, '|') - 1);
    v_Fields  := v_Currrec;
    v_名称    := Substr(v_Fields, 1, Instr(v_Fields, '^') - 1);
    v_Fields  := Substr(v_Fields, Instr(v_Fields, '^') + 1);
    v_拼音    := Substr(v_Fields, 1, Instr(v_Fields, '^') - 1);
    v_Fields  := Substr(v_Fields, Instr(v_Fields, '^') + 1);
    v_五笔    := v_Fields;
    If v_拼音 Is Not Null Then
      Insert Into 诊疗项目别名 (诊疗项目id, 名称, 性质, 简码, 码类) Values (Id_In, v_名称, 9, v_拼音, 1);
      Insert Into 收费项目别名
        (收费细目id, 名称, 性质, 简码, 码类)
        Select 药品id, v_名称, 9, v_拼音, 1 From 药品规格 Where 药名id = Id_In;
    End If;
    If v_五笔 Is Not Null Then
      Insert Into 诊疗项目别名 (诊疗项目id, 名称, 性质, 简码, 码类) Values (Id_In, v_名称, 9, v_五笔, 2);
      Insert Into 收费项目别名
        (收费细目id, 名称, 性质, 简码, 码类)
        Select 药品id, v_名称, 9, v_五笔, 2 From 药品规格 Where 药名id = Id_In;
    End If;
    v_Records := Replace('|' || v_Records, '|' || v_Currrec || '|');
  End Loop;

  b_Message.Zlhis_Dict_031(v_类别, Id_In);
Exception
  When Err_Notfind Then
    Raise_Application_Error(-20101, '[ZLSOFT]该品种不存在，可能已被其他用户删除！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_草药品种_Update;
/

--101765:秦龙,2017-12-06,增加传参“是否辅助用药”
Create Or Replace Procedure Zl_成药品种_Update
(
  分类id_In       In 诊疗项目目录.分类id%Type := Null,
  Id_In           In 诊疗项目目录.Id%Type,
  编码_In         In 诊疗项目目录.编码%Type := Null,
  名称_In         In 诊疗项目目录.名称%Type := Null,
  拼音_In         In 诊疗项目别名.简码%Type := Null,
  五笔_In         In 诊疗项目别名.简码%Type := Null,
  英文_In         In 诊疗项目别名.名称%Type := Null,
  单位_In         In 诊疗项目目录.计算单位%Type := Null,
  药品剂型_In     In 药品特性.药品剂型%Type := Null,
  毒理分类_In     In 药品特性.毒理分类%Type := Null,
  价值分类_In     In 药品特性.价值分类%Type := Null,
  货源情况_In     In 药品特性.货源情况%Type := Null,
  用药梯次_In     In 药品特性.用药梯次%Type := Null,
  药品类型_In     In 药品特性.药品类型%Type := Null,
  处方职务_In     In 药品特性.处方职务%Type := '00',
  处方限量_In     In 药品特性.处方限量%Type := Null,
  急救药否_In     In 药品特性.急救药否%Type := 0,
  是否新药_In     In 药品特性.是否新药%Type := 0,
  是否原料_In     In 药品特性.是否原料%Type := 0,
  是否皮试_In     In 药品特性.是否皮试%Type := 0,
  抗生素_In       In 药品特性.抗生素%Type := 0,
  参考目录id_In   In 诊疗项目目录.参考目录id%Type := Null,
  品种医嘱_In     In 药品特性.品种医嘱%Type := 0,
  适用性别_In     In 诊疗项目目录.适用性别%Type := 0,
  其他别名_In     In Varchar2 := Null, --以"|"分隔的别名记录，每条记录按"名称^拼音^五笔"组织 
  自管药_In       In Number := Null,
  Atccode_In      In Varchar2 := Null,
  肿瘤药_In       In 药品特性.是否肿瘤药%Type := 0,
  溶媒_In         In 药品特性.溶媒%Type := 0,
  是否原研药_In   In 药品特性.是否原研药%Type := 0,
  是否专利药_In   In 药品特性.是否专利药%Type := 0,
  是否单独定价_In In 药品特性.是否单独定价%Type := 0,
  是否辅助用药_In In 药品特性.是否辅助用药%Type := 0 
) Is
  v_Records Varchar2(4000); --临时记录别名数据的字符串 
  v_Currrec Varchar2(1000); --包含在别名记录中的一条别名 
  v_Fields  Varchar2(1000); --临时记录一条别名的字符串 
  v_名称    诊疗项目目录.名称%Type;
  v_拼音    诊疗项目别名.简码%Type;
  v_五笔    诊疗项目别名.简码%Type;
  Err_Notfind Exception;
  v_类别 诊疗项目目录.类别%Type;
Begin
  Update 诊疗项目目录
  Set 分类id = 分类id_In, 编码 = 编码_In, 名称 = 名称_In, 计算单位 = 单位_In, 参考目录id = 参考目录id_In, 适用性别 = 适用性别_In
  Where ID = Id_In
  Returning 类别 Into v_类别;
  If Sql%RowCount = 0 Then
    Raise Err_Notfind;
  End If;

  Update 药品特性
  Set 药品剂型 = 药品剂型_In, 毒理分类 = 毒理分类_In, 价值分类 = 价值分类_In, 货源情况 = 货源情况_In, 用药梯次 = 用药梯次_In, 药品类型 = 药品类型_In, 处方职务 = 处方职务_In,
      处方限量 = 处方限量_In, 抗生素 = 抗生素_In, 急救药否 = 急救药否_In, 是否新药 = 是否新药_In, 是否原料 = 是否原料_In, 是否皮试 = 是否皮试_In, 品种医嘱 = 品种医嘱_In,
      临床自管药 = 自管药_In, Atccode = Atccode_In, 是否肿瘤药 = 肿瘤药_In, 溶媒 = 溶媒_In, 是否原研药 = 是否原研药_In, 是否专利药 = 是否专利药_In,
      是否单独定价 = 是否单独定价_In, 是否辅助用药=是否辅助用药_In
  Where 药名id = Id_In;

  Update 收费项目目录 Set 名称 = 名称_In Where ID In (Select 药品id From 药品规格 Where 药名id = Id_In);

  If 拼音_In Is Null Then
    Delete From 诊疗项目别名 Where 诊疗项目id = Id_In And 性质 = 1 And 码类 = 1;
    Delete From 收费项目别名
    Where 收费细目id In (Select 药品id From 药品规格 Where 药名id = Id_In) And 性质 = 1 And 码类 = 1;
  Else
    Update 诊疗项目别名 Set 名称 = 名称_In, 简码 = 拼音_In Where 诊疗项目id = Id_In And 性质 = 1 And 码类 = 1;
    If Sql%RowCount = 0 Then
      Insert Into 诊疗项目别名 (诊疗项目id, 名称, 性质, 简码, 码类) Values (Id_In, 名称_In, 1, 拼音_In, 1);
    End If;
    For r_Spec In (Select 药品id From 药品规格 Where 药名id = Id_In) Loop
      Update 收费项目别名
      Set 名称 = 名称_In, 简码 = 拼音_In
      Where 收费细目id = r_Spec.药品id And 性质 = 1 And 码类 = 1;
      If Sql%RowCount = 0 Then
        Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (r_Spec.药品id, 名称_In, 1, 拼音_In, 1);
      End If;
    End Loop;
  End If;
  If 五笔_In Is Null Then
    Delete From 诊疗项目别名 Where 诊疗项目id = Id_In And 性质 = 1 And 码类 = 2;
    Delete From 收费项目别名
    Where 收费细目id In (Select 药品id From 药品规格 Where 药名id = Id_In) And 性质 = 1 And 码类 = 2;
  Else
    Update 诊疗项目别名 Set 名称 = 名称_In, 简码 = 五笔_In Where 诊疗项目id = Id_In And 性质 = 1 And 码类 = 2;
    If Sql%RowCount = 0 Then
      Insert Into 诊疗项目别名 (诊疗项目id, 名称, 性质, 简码, 码类) Values (Id_In, 名称_In, 1, 五笔_In, 2);
    End If;
    For r_Spec In (Select 药品id From 药品规格 Where 药名id = Id_In) Loop
      Update 收费项目别名
      Set 名称 = 名称_In, 简码 = 五笔_In
      Where 收费细目id = r_Spec.药品id And 性质 = 1 And 码类 = 2;
      If Sql%RowCount = 0 Then
        Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (r_Spec.药品id, 名称_In, 1, 五笔_In, 2);
      End If;
    End Loop;
  End If;
  If 英文_In Is Null Then
    Delete From 诊疗项目别名 Where 诊疗项目id = Id_In And 性质 = 2;
    Delete From 收费项目别名 Where 收费细目id In (Select 药品id From 药品规格 Where 药名id = Id_In) And 性质 = 2;
  Else
    Update 诊疗项目别名 Set 名称 = 英文_In Where 诊疗项目id = Id_In And 性质 = 2;
    If Sql%RowCount = 0 Then
      Insert Into 诊疗项目别名 (诊疗项目id, 名称, 性质, 简码, 码类) Values (Id_In, 英文_In, 2, Null, 0);
    End If;
    For r_Spec In (Select 药品id From 药品规格 Where 药名id = Id_In) Loop
      Update 收费项目别名 Set 名称 = 英文_In Where 收费细目id = r_Spec.药品id And 性质 = 2;
      If Sql%RowCount = 0 Then
        Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (r_Spec.药品id, 英文_In, 2, Null, 0);
      End If;
    End Loop;
  End If;

  Delete From 诊疗项目别名 Where 诊疗项目id = Id_In And 性质 = 9;
  Delete From 收费项目别名 Where 收费细目id In (Select 药品id From 药品规格 Where 药名id = Id_In) And 性质 = 9;
  If 其他别名_In Is Null Then
    v_Records := Null;
  Else
    v_Records := 其他别名_In || '|';
  End If;
  While v_Records Is Not Null Loop
    v_Currrec := Substr(v_Records, 1, Instr(v_Records, '|') - 1);
    v_Fields  := v_Currrec;
    v_名称    := Substr(v_Fields, 1, Instr(v_Fields, '^') - 1);
    v_Fields  := Substr(v_Fields, Instr(v_Fields, '^') + 1);
    v_拼音    := Substr(v_Fields, 1, Instr(v_Fields, '^') - 1);
    v_Fields  := Substr(v_Fields, Instr(v_Fields, '^') + 1);
    v_五笔    := v_Fields;
    If v_拼音 Is Not Null Then
      Insert Into 诊疗项目别名 (诊疗项目id, 名称, 性质, 简码, 码类) Values (Id_In, v_名称, 9, v_拼音, 1);
      Insert Into 收费项目别名
        (收费细目id, 名称, 性质, 简码, 码类)
        Select 药品id, v_名称, 9, v_拼音, 1 From 药品规格 Where 药名id = Id_In;
    End If;
    If v_五笔 Is Not Null Then
      Insert Into 诊疗项目别名 (诊疗项目id, 名称, 性质, 简码, 码类) Values (Id_In, v_名称, 9, v_五笔, 2);
      Insert Into 收费项目别名
        (收费细目id, 名称, 性质, 简码, 码类)
        Select 药品id, v_名称, 9, v_五笔, 2 From 药品规格 Where 药名id = Id_In;
    End If;
    v_Records := Replace('|' || v_Records, '|' || v_Currrec || '|');
  End Loop;

  b_Message.Zlhis_Dict_031(v_类别, Id_In);
Exception
  When Err_Notfind Then
    Raise_Application_Error(-20101, '[ZLSOFT]该品种不存在，可能已被其他用户删除！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_成药品种_Update;
/

--101765:秦龙,2017-12-06,增加传参“是否辅助用药”
Create Or Replace Procedure Zl_成药品种_Insert
(
  类别_In         In 诊疗项目目录.类别%Type := Null,
  分类id_In       In 诊疗项目目录.分类id%Type := Null,
  Id_In           In 诊疗项目目录.Id%Type,
  编码_In         In 诊疗项目目录.编码%Type := Null,
  名称_In         In 诊疗项目目录.名称%Type := Null,
  拼音_In         In 诊疗项目别名.简码%Type := Null,
  五笔_In         In 诊疗项目别名.简码%Type := Null,
  英文_In         In 诊疗项目别名.名称%Type := Null,
  单位_In         In 诊疗项目目录.计算单位%Type := Null,
  药品剂型_In     In 药品特性.药品剂型%Type := Null,
  毒理分类_In     In 药品特性.毒理分类%Type := Null,
  价值分类_In     In 药品特性.价值分类%Type := Null,
  货源情况_In     In 药品特性.货源情况%Type := Null,
  用药梯次_In     In 药品特性.用药梯次%Type := Null,
  药品类型_In     In 药品特性.药品类型%Type := Null,
  处方职务_In     In 药品特性.处方职务%Type := '00',
  处方限量_In     In 药品特性.处方限量%Type := Null,
  急救药否_In     In 药品特性.急救药否%Type := 0,
  是否新药_In     In 药品特性.是否新药%Type := 0,
  是否原料_In     In 药品特性.是否原料%Type := 0,
  是否皮试_In     In 药品特性.是否皮试%Type := 0,
  抗生素_In       In 药品特性.抗生素%Type := 0,
  参考目录id_In   In 诊疗项目目录.参考目录id%Type := Null,
  品种医嘱_In     In 药品特性.品种医嘱%Type := 0,
  适用性别_In     In 诊疗项目目录.适用性别%Type := 0,
  其他别名_In     In Varchar2 := Null, --以"|"分隔的别名记录，每条记录按"名称^拼音^五笔"组织 
  自管药_In       In Number := Null,
  Atccode_In      In Varchar2 := Null,
  肿瘤药_In       In 药品特性.是否肿瘤药%Type := 0,
  溶媒_In         In 药品特性.溶媒%Type := 0,
  是否原研药_In   In 药品特性.是否原研药%Type := 0,
  是否专利药_In   In 药品特性.是否专利药%Type := 0,
  是否单独定价_In In 药品特性.是否单独定价%Type := 0,
  是否辅助用药_In In 药品特性.是否辅助用药%Type := 0
) Is
  v_Records Varchar2(4000); --临时记录别名数据的字符串 
  v_Currrec Varchar2(1000); --包含在别名记录中的一条别名 
  v_Fields  Varchar2(1000); --临时记录一条别名的字符串 
  v_名称    诊疗项目目录.名称%Type;
  v_拼音    诊疗项目别名.简码%Type;
  v_五笔    诊疗项目别名.简码%Type;
Begin
  Insert Into 诊疗项目目录
    (类别, 分类id, ID, 编码, 名称, 计算单位, 计算方式, 执行频率, 单独应用, 组合项目, 执行安排, 计价性质, 服务对象, 建档时间, 撤档时间, 参考目录id, 适用性别)
  Values
    (类别_In, 分类id_In, Id_In, 编码_In, 名称_In, 单位_In, 1, 0, 1, 0, 0, 0, 3, Sysdate, To_Date('3000-01-01', 'YYYY-MM-DD'),
     参考目录id_In, 适用性别_In);

  Insert Into 药品特性
    (药名id, 药品剂型, 毒理分类, 价值分类, 货源情况, 用药梯次, 药品类型, 处方职务, 处方限量, 急救药否, 是否新药, 抗生素, 是否原料, 是否皮试, 品种医嘱, 临床自管药, Atccode, 是否肿瘤药, 溶媒,
     是否原研药, 是否专利药, 是否单独定价, 是否辅助用药)
  Values
    (Id_In, 药品剂型_In, 毒理分类_In, 价值分类_In, 货源情况_In, 用药梯次_In, 药品类型_In, 处方职务_In, 处方限量_In, 急救药否_In, 是否新药_In, 抗生素_In, 是否原料_In,
     是否皮试_In, 品种医嘱_In, 自管药_In, Atccode_In, 肿瘤药_In, 溶媒_In, 是否原研药_In, 是否专利药_In, 是否单独定价_In, 是否辅助用药_In);

  If 拼音_In Is Not Null Then
    Insert Into 诊疗项目别名 (诊疗项目id, 名称, 性质, 简码, 码类) Values (Id_In, 名称_In, 1, 拼音_In, 1);
  End If;
  If 五笔_In Is Not Null Then
    Insert Into 诊疗项目别名 (诊疗项目id, 名称, 性质, 简码, 码类) Values (Id_In, 名称_In, 1, 五笔_In, 2);
  End If;
  If 英文_In Is Not Null Then
    Insert Into 诊疗项目别名 (诊疗项目id, 名称, 性质, 简码, 码类) Values (Id_In, 英文_In, 2, Null, 0);
  End If;

  If 其他别名_In Is Null Then
    v_Records := Null;
  Else
    v_Records := 其他别名_In || '|';
  End If;
  While v_Records Is Not Null Loop
    v_Currrec := Substr(v_Records, 1, Instr(v_Records, '|') - 1);
    v_Fields  := v_Currrec;
    v_名称    := Substr(v_Fields, 1, Instr(v_Fields, '^') - 1);
    v_Fields  := Substr(v_Fields, Instr(v_Fields, '^') + 1);
    v_拼音    := Substr(v_Fields, 1, Instr(v_Fields, '^') - 1);
    v_Fields  := Substr(v_Fields, Instr(v_Fields, '^') + 1);
    v_五笔    := v_Fields;
    If v_拼音 Is Not Null Then
      Insert Into 诊疗项目别名 (诊疗项目id, 名称, 性质, 简码, 码类) Values (Id_In, v_名称, 9, v_拼音, 1);
    End If;
    If v_五笔 Is Not Null Then
      Insert Into 诊疗项目别名 (诊疗项目id, 名称, 性质, 简码, 码类) Values (Id_In, v_名称, 9, v_五笔, 2);
    End If;
    v_Records := Replace('|' || v_Records, '|' || v_Currrec || '|');
  End Loop;
  --添加缺省的对应输出单据 
  Insert Into 病历单据应用
    (病历文件id, 应用场合, 诊疗项目id)
    Select a.病历文件id, 1, Id_In
    From 病历单据应用 A, 诊疗项目目录 I
    Where a.诊疗项目id = i.Id And i.类别 = 类别_In And 应用场合 = 1 And Rownum < 2;
  Insert Into 病历单据应用
    (病历文件id, 应用场合, 诊疗项目id)
    Select a.病历文件id, 2, Id_In
    From 病历单据应用 A, 诊疗项目目录 I
    Where a.诊疗项目id = i.Id And i.类别 = 类别_In And 应用场合 = 2 And Rownum < 2;

  b_Message.Zlhis_Dict_030(类别_In, Id_In);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_成药品种_Insert;
/

--114289:蒋廷中,2017-12-05,医生常用项目可删除
Create Or Replace Procedure Zl_医生常用医嘱_替换
(
  Id_In         医生常用医嘱.Id%Type,
  诊疗项目id_In 医生常用医嘱.诊疗项目id%Type,
  药品id_In     医生常用医嘱.药品id%Type := Null
) Is
Begin
  --诊疗项目id_In和药品id_IN同时为-1时 为删除常用项目
  If 诊疗项目id_In = -1 And 药品id_In = -1 Then
    Delete From 医生常用医嘱 Where ID = Id_In;
  Else
    --先删除，否则可能会唯一约束
    Delete From 医生常用医嘱
    Where (人员id, 科室id, 诊断名称, 疾病id, 诊断id, 诊疗项目id, 药品id) In
          (Select 人员id, 科室id, 诊断名称, 疾病id, 诊断id, 诊疗项目id_In, 药品id_In From 医生常用医嘱 Where ID = Id_In);
  
    Update 医生常用医嘱 Set 诊疗项目id = 诊疗项目id_In, 药品id = 药品id_In Where ID = Id_In;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_医生常用医嘱_替换;
/

--113098:余伟节,2017-12-04,路径医嘱变动双审核
Create Or Replace Procedure Zl_路径医嘱变动_Insert
(
  项目ids_In    Varchar2, --项目Id 串 ID,ID,...;双审核模式:项目ID;审核状态
  操作时间_In   Date,
  操作员_In     人员表.姓名%Type,
  项目id_In     路径医嘱变动.项目id%Type := Null,
  医嘱内容id_In 路径医嘱变动.医嘱内容id%Type := Null,
  相关id_In     路径医嘱变动.相关id%Type := Null,
  序号_In       路径医嘱变动.序号%Type := Null,
  期效_In       路径医嘱变动.期效%Type := Null,
  诊疗项目id_In 路径医嘱变动.诊疗项目id%Type := Null,
  收费细目id_In 路径医嘱变动.收费细目id%Type := Null,
  医嘱内容_In   路径医嘱变动.医嘱内容%Type := Null,
  单次用量_In   路径医嘱变动.单次用量%Type := Null,
  总给予量_In   路径医嘱变动.总给予量%Type := Null,
  标本部位_In   路径医嘱变动.标本部位%Type := Null,
  检查方法_In   路径医嘱变动.检查方法%Type := Null,
  执行频次_In   路径医嘱变动.执行频次%Type := Null,
  频率次数_In   路径医嘱变动.频率次数%Type := Null,
  频率间隔_In   路径医嘱变动.频率间隔%Type := Null,
  间隔单位_In   路径医嘱变动.间隔单位%Type := Null,
  医生嘱托_In   路径医嘱变动.医生嘱托%Type := Null,
  执行性质_In   路径医嘱变动.执行性质%Type := Null,
  执行标记_In   路径医嘱变动.执行标记%Type := Null,
  执行科室id_In 路径医嘱变动.执行科室id%Type := Null,
  时间方案_In   路径医嘱变动.时间方案%Type := Null,
  是否缺省_In   路径医嘱变动.是否缺省%Type := Null,
  是否备选_In   路径医嘱变动.是否备选%Type := Null,
  配方id_In     路径医嘱变动.配方id%Type := Null,
  组合项目id_In 路径医嘱变动.组合项目id%Type := Null,
  审核状态_In   路径医嘱变动.审核状态%Type := Null
) Is
  --启用了双审核模式 传入该值：审核状态_In:1-只修改了药品只需药剂科审核;2-修改了医嘱未修改药品只需要医务科审核;3-需要药剂科和医务科同审


  n_Count Number(5);
  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  If Instr(项目ids_In, ';') = 0 Then
    Select /*+cardinality(D,10)*/
     Count(a.操作时间)
    Into n_Count
    From 路径医嘱变动 A, Table(f_Num2list(项目ids_In)) D
    Where a.项目id = d.Column_Value And a.操作时间 = 操作时间_In;
  Else
    Select /*+cardinality(D,10)*/
     Count(a.操作时间)
    Into n_Count
    From 路径医嘱变动 A, Table(f_Num2list2(项目ids_In, ',', ';')) D
    Where a.项目id = d.C1 And a.操作时间 = 操作时间_In;
  End If;
  If n_Count > 0 Then
    v_Error := '不允许同一个临床路径项目在同一时间被操作！';
    Raise Err_Custom;
  End If;
  If 项目ids_In Is Not Null Then
    If Instr(项目ids_In, ';') = 0 Then
      Insert Into 路径医嘱变动
        (项目id, 操作时间, 操作员, 医嘱内容id, 相关id, 序号, 期效, 诊疗项目id, 收费细目id, 医嘱内容, 单次用量, 总给予量, 标本部位, 检查方法, 执行频次, 频率次数, 频率间隔, 间隔单位,
         医生嘱托, 执行性质, 执行标记, 执行科室id, 时间方案, 是否缺省, 是否备选, 配方id, 组合项目id, 审核状态, 审核人, 审核时间)
        Select /*+cardinality(D,10)*/
         c.路径项目id, 操作时间_In, 操作员_In, b.Id, b.相关id, b.序号, b.期效, b.诊疗项目id, b.收费细目id, b.医嘱内容, b.单次用量, b.总给予量, b.标本部位, b.检查方法,
         b.执行频次, b.频率次数, b.频率间隔, b.间隔单位, b.医生嘱托, b.执行性质, b.执行标记, b.执行科室id, b.时间方案, b.是否缺省, b.是否备选, b.配方id, b.组合项目id, 1,
         操作员_In, 操作时间_In
        From 路径医嘱内容 B, 临床路径医嘱 C, Table(f_Num2list(项目ids_In)) D
        Where c.医嘱内容id = b.Id And c.路径项目id = d.Column_Value;
    Else
      Insert Into 路径医嘱变动
        (项目id, 操作时间, 操作员, 医嘱内容id, 相关id, 序号, 期效, 诊疗项目id, 收费细目id, 医嘱内容, 单次用量, 总给予量, 标本部位, 检查方法, 执行频次, 频率次数, 频率间隔, 间隔单位,
         医生嘱托, 执行性质, 执行标记, 执行科室id, 时间方案, 是否缺省, 是否备选, 配方id, 组合项目id, 审核状态, 审核人, 审核时间, 药剂审核人, 药剂审核时间)
        Select /*+cardinality(D,10)*/
         c.路径项目id, 操作时间_In, 操作员_In, b.Id, b.相关id, b.序号, b.期效, b.诊疗项目id, b.收费细目id, b.医嘱内容, b.单次用量, b.总给予量, b.标本部位, b.检查方法,
         b.执行频次, b.频率次数, b.频率间隔, b.间隔单位, b.医生嘱托, b.执行性质, b.执行标记, b.执行科室id, b.时间方案, b.是否缺省, b.是否备选, b.配方id, b.组合项目id, 1,
         Decode(d.C2, 2, 操作员_In, 3, 操作员_In, Null), Decode(d.C2, 2, 操作时间_In, 3, 操作时间_In, Null),
         Decode(d.C2, 1, 操作员_In, 3, 操作员_In, Null), Decode(d.C2, 1, 操作时间_In, 3, 操作时间_In, Null)
        From 路径医嘱内容 B, 临床路径医嘱 C, Table(f_Num2list2(项目ids_In, ',', ';')) D
        Where c.医嘱内容id = b.Id And c.路径项目id = d.C1;
    End If;
  Else
    Insert Into 路径医嘱变动
      (项目id, 操作时间, 操作员, 医嘱内容id, 相关id, 序号, 期效, 诊疗项目id, 收费细目id, 医嘱内容, 单次用量, 总给予量, 标本部位, 检查方法, 执行频次, 频率次数, 频率间隔, 间隔单位,
       医生嘱托, 执行性质, 执行标记, 执行科室id, 时间方案, 是否缺省, 是否备选, 配方id, 组合项目id, 审核状态)
    Values
      (项目id_In, 操作时间_In, 操作员_In, 医嘱内容id_In, 相关id_In, 序号_In, 期效_In, 诊疗项目id_In, 收费细目id_In, 医嘱内容_In, 单次用量_In, 总给予量_In,
       标本部位_In, 检查方法_In, 执行频次_In, 频率次数_In, 频率间隔_In, 间隔单位_In, 医生嘱托_In, 执行性质_In, 执行标记_In, 执行科室id_In, 时间方案_In, 是否缺省_In,
       是否备选_In, 配方id_In, 组合项目id_In, Decode(审核状态_In, 1, 2, 2, Null, 3, 3, Null));
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_路径医嘱变动_Insert;
/

--113098:余伟节,2017-12-04,路径医嘱变动双审核
Create Or Replace Procedure Zl_路径医嘱变动_Audit
(
  项目id_In   路径医嘱变动.项目id%Type,
  操作时间_In Date,
  功能_In     Number := 0,
  审核模式_In Number := 0 --1-只审核药品;2-只审非药品;3-都审查 ；0-非双审核模式
) Is
  n_Numrow       Number(5);
  d_Currdate     Date;
  d_药剂审核时间 Date;
  d_审核时间     Date;
  v_药剂审核人   Varchar2(100);
  v_审核人       Varchar2(100);
  v_操作员       Varchar2(100);
  v_Error        Varchar2(255);
  Err_Custom Exception;
Begin
  d_Currdate := Sysdate;
  v_操作员   := zl_UserName;
  If 功能_In = 0 Then
    If 审核模式_In = 1 Then
      --只审药品
      Select Count(1)
      Into n_Numrow
      From 路径医嘱变动
      Where 项目id = 项目id_In And 操作时间 = 操作时间_In And 审核状态 = 2;
      If n_Numrow = 0 Then
        Update 路径医嘱变动 A
        Set 药剂审核人 = v_操作员, 药剂审核时间 = d_Currdate, 审核状态 = Null
        Where 项目id = 项目id_In And 操作时间 = 操作时间_In And 审核状态 = 3 And Exists
         (Select Count(1)
               From 诊疗项目目录 B
               Where b.Id = a.诊疗项目id And (b.类别 In ('5', '6', '7') Or (b.类别 = 'E' And b.操作类型 In ('2', '3', '4'))));
        Return;
      End If;
    Elsif 审核模式_In = 2 Then
      --只审非药品医嘱
      Select Count(1)
      Into n_Numrow
      From 路径医嘱变动
      Where 项目id = 项目id_In And 操作时间 = 操作时间_In And Nvl(审核状态, -1) = -1;
      If n_Numrow = 0 Then
        Update 路径医嘱变动 A
        Set 审核人 = v_操作员, 审核时间 = d_Currdate, 审核状态 = 2
        Where 项目id = 项目id_In And 操作时间 = 操作时间_In And 审核状态 = 3 And Exists
         (Select Count(1)
               From 诊疗项目目录 B
               Where b.Id = a.诊疗项目id And Not (b.类别 In ('5', '6', '7') Or (b.类别 = 'E' And b.操作类型 In ('2', '3', '4'))));
        Return;
      End If;
    End If;
  
    --将原来的医嘱导入路径医嘱变动记录
    Zl_路径医嘱变动_Insert(项目id_In, d_Currdate, zl_UserName);
    If 审核模式_In <> 0 Then
      Select Max(药剂审核人), Max(审核人), Max(药剂审核时间), Max(审核时间)
      Into v_药剂审核人, v_审核人, d_药剂审核时间, d_审核时间
      From 路径医嘱变动
      Where 项目id = 项目id_In And 操作时间 = 操作时间_In;
    End If;
    If 审核模式_In = 1 Then
      Update 路径医嘱变动
      Set 药剂审核人 = v_操作员, 药剂审核时间 = d_Currdate, 审核人 = v_审核人, 审核时间 = d_审核时间
      Where 项目id = 项目id_In And 操作时间 = d_Currdate;
    Elsif 审核模式_In = 2 Then
      Update 路径医嘱变动
      Set 药剂审核人 = v_药剂审核人, 药剂审核时间 = d_药剂审核时间, 审核人 = v_操作员, 审核时间 = d_Currdate
      Where 项目id = 项目id_In And 操作时间 = d_Currdate;
    Elsif 审核模式_In = 3 Then
      Update 路径医嘱变动
      Set 药剂审核人 = Nvl(v_药剂审核人, v_操作员), 药剂审核时间 = Nvl(d_药剂审核时间, d_Currdate), 审核人 = Nvl(v_审核人, v_操作员),
          审核时间 = Nvl(d_审核时间, d_Currdate)
      Where 项目id = 项目id_In And 操作时间 = d_Currdate;
    End If;
    --删除原来的【路径医嘱内容】的数据;同时级联删除【临床路径医嘱】的数据
    Delete From 路径医嘱内容 Where ID In (Select 医嘱内容id From 临床路径医嘱 Where 路径项目id = 项目id_In);
  
    --将【路径医嘱变动】未审核的医嘱复制到【路径医嘱内容】,并将路径项目ID和医嘱ID关联
    Insert Into 路径医嘱内容
      (ID, 相关id, 序号, 期效, 诊疗项目id, 收费细目id, 医嘱内容, 单次用量, 总给予量, 标本部位, 检查方法, 执行频次, 频率次数, 频率间隔, 间隔单位, 医生嘱托, 执行性质, 执行标记, 执行科室id,
       时间方案, 是否缺省, 是否备选, 配方id, 组合项目id)
      Select 医嘱内容id, 相关id, 序号, 期效, 诊疗项目id, 收费细目id, 医嘱内容, 单次用量, 总给予量, 标本部位, 检查方法, 执行频次, 频率次数, 频率间隔, 间隔单位, 医生嘱托, 执行性质,
             执行标记, 执行科室id, 时间方案, 是否缺省, 是否备选, 配方id, 组合项目id
      From 路径医嘱变动
      Where 项目id = 项目id_In And 操作时间 = 操作时间_In;
  
    Insert Into 临床路径医嘱
      (路径项目id, 医嘱内容id)
      Select 项目id, 医嘱内容id From 路径医嘱变动 Where 项目id = 项目id_In And 操作时间 = 操作时间_In;
    --删除【路径医嘱变动】中已经复制到【路径医嘱内容】的数据
    Delete From 路径医嘱变动 Where 项目id = 项目id_In And 操作时间 = 操作时间_In;
  Else
    --审核不通过:
    --双审核模式,存在一方审核不通过;整个项目都审核不通过  审核状态=0
    If 审核模式_In = 1 Then
      Update 路径医嘱变动
      Set 药剂审核人 = v_操作员, 药剂审核时间 = d_Currdate, 审核状态 = 0
      Where 项目id = 项目id_In And 操作时间 = 操作时间_In;
    Elsif 审核模式_In = 2 Or 审核模式_In = 0 Then
      Update 路径医嘱变动
      Set 审核人 = v_操作员, 审核时间 = d_Currdate, 审核状态 = 0
      Where 项目id = 项目id_In And 操作时间 = 操作时间_In;
    Elsif 审核模式_In = 3 Then
      Select Max(药剂审核人), Max(审核人), Max(药剂审核时间), Max(审核时间)
      Into v_药剂审核人, v_审核人, d_药剂审核时间, d_审核时间
      From 路径医嘱变动
      Where 项目id = 项目id_In And 操作时间 = 操作时间_In;
      Update 路径医嘱变动
      Set 审核人 = Nvl(v_审核人, v_操作员), 审核时间 = Nvl(d_审核时间, d_Currdate), 药剂审核人 = Nvl(v_药剂审核人, v_操作员),
          药剂审核时间 = Nvl(d_药剂审核时间, d_Currdate), 审核状态 = 0
      Where 项目id = 项目id_In And 操作时间 = 操作时间_In;
    End If;
  End If;
Exception

  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_路径医嘱变动_Audit;
/

--120818:焦博,2018-01-25,新版出诊表模式下,调用zl_三方机构挂号_insert对当日以后的号源进行挂号会报错
--117999:李南春,2017-12-12,序号锁号状态检查
--117829:焦博,2017-12-04,调整zl_三方机构挂号_insert调用子过程zl_三方机构挂号_出诊_insert时的入参
Create Or Replace Procedure Zl_三方机构挂号_Insert
(
  操作方式_In      Integer,
  病人id_In        门诊费用记录.病人id%Type,
  号码_In          挂号安排.号码%Type,
  号序_In          挂号序号状态.序号%Type,
  单据号_In        门诊费用记录.No%Type,
  票据号_In        门诊费用记录.实际票号%Type,
  结算方式_In      Varchar2,
  摘要_In          门诊费用记录.摘要%Type, --预约挂号摘要信息
  发生时间_In      门诊费用记录.发生时间%Type,
  登记时间_In      门诊费用记录.登记时间%Type,
  合作单位_In      挂号合作单位.名称%Type,
  挂号金额合计_In  门诊费用记录.实收金额%Type,
  领用id_In        票据使用明细.领用id%Type,
  收费票据_In      Number := 0, --挂号是否使用收费票据
  交易流水号_In    病人预交记录.交易流水号%Type,
  交易说明_In      病人预交记录.交易说明%Type,
  预约方式_In      预约方式.名称%Type := Null,
  预交id_In        病人预交记录.Id%Type := Null,
  卡类别id_In      病人预交记录.卡类别id%Type := Null,
  加入序号状态_In  Number := 0,
  是否自助设备_In  Number := 0,
  结帐id_In        门诊费用记录.结帐id%Type := Null,
  锁定类型_In      Number := 0,
  保险结算_In      Varchar2 := Null,
  冲预交_In        Number := Null,
  支付卡号_In      病人预交记录.卡号%Type := Null,
  退号重用_In      Number := 1,
  费别_In          门诊费用记录.费别%Type := Null,
  冲预交病人ids_In Varchar2 := Null,
  机器名_In        挂号序号状态.机器名%Type := Null,
  更新年龄_In      Number := 0,
  购买病历_In      Number := 0,
  出诊记录id_In    临床出诊记录.Id%Type := Null,
  记帐费用_In      Number := 0,
  付款方式_In      医疗付款方式.名称%Type := Null
) As
  --功能：三方机构进行挂号(包含预约;预约挂号不扣款;预约挂号扣款)
  --入参:操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
  --      结算方式_IN:支持多种结算方式,多种结算方式时，传入格式如下:结算方式名称1,金额,结算号码,三方卡标志|结算方式名称2,金额,结算号码,三方卡标志|...
  --      加入序号状态_In:1-表示强制加入挂号序号状态表中;否则根据启用序号或启用时段时才加入.
  --      是否自助设备_In:1-表示是医院的自助设备进行此函数的调用,自助设备调用此函数 允许加号,否则不允许
  --      锁定类型_In :0-产生正常数据 1-表示对单据进行锁定,产生未生效的单据信息;2-对锁定的记录进行解锁-生成正常数据:未生效的单据在银行扣款完成后进行解锁
  --      保险结算_IN:格式="结算方式|结算金额||....."
  --      冲预交病人ids_In:多个用逗分分离,冲预交时有效(冲预交类别与业务操作保持一致),主要是使用家属的预交款
  Err_Item Exception;
  Err_Special Exception;
  v_Err_Msg            Varchar2(255);
  n_打印id             票据打印内容.Id%Type;
  n_返回值             病人预交记录.金额%Type;
  v_排队号码           Varchar2(20);
  v_队列名称           排队叫号队列.队列名称%Type;
  n_预交id             病人预交记录.Id%Type;
  n_挂号id             病人挂号记录.Id%Type;
  v_结算内容           Varchar2(3000);
  v_当前结算           Varchar2(150);
  d_发生时间           Date;
  v_结算方式           病人预交记录.结算方式%Type;
  n_结算金额           病人预交记录.冲预交%Type;
  n_结算合计           Number(16, 5);
  n_预交金额           病人预交记录.冲预交%Type;
  n_组id               财务缴款分组.Id%Type;
  d_排队时间           Date;
  n_锁定               Number;
  n_病人预约科室数     Number(18);
  n_已约科室           Number(18);
  n_合作单位限制       Number(18);
  n_是否开放           Number(1);
  n_Count              Number(18);
  n_行号               Number(18);
  n_序号               病人挂号记录.号序%Type;
  n_费用id             门诊费用记录.Id%Type;
  n_价格父号           Number(18);
  n_原项目id           收费项目目录.Id%Type;
  n_原收入项目id       收费项目目录.Id%Type;
  v_诊室               病人挂号记录.诊室%Type;
  n_安排id             挂号安排.Id%Type;
  n_实收金额合计       门诊费用记录.实收金额%Type;
  n_开单部门id         门诊费用记录.开单部门id%Type;
  n_实收金额           门诊费用记录.实收金额%Type;
  n_应收金额           门诊费用记录.实收金额%Type;
  n_结帐id             病人结帐记录.Id%Type;
  v_Temp               Varchar2(500);
  n_预约时段序号       Number;
  n_预约总数           Number;
  n_Exists             Number;
  n_分时点显示         Number;
  d_时段开始时间       Date;
  v_冲预交病人ids      Varchar2(4000);
  v_收费项目ids        Varchar2(300);
  n_预约数量           合作单位挂号汇总.已约数%Type;
  n_号序               病人挂号记录.号序%Type;
  d_登记时间           Date;
  v_操作员编号         人员表.编号%Type;
  v_操作员姓名         人员表.姓名%Type;
  n_急诊               病人挂号记录.急诊%Type;
  n_预约               Integer;
  v_星期               挂号安排时段.星期%Type;
  n_启用分时段         Integer;
  n_已挂数             病人挂号汇总.已挂数%Type;
  n_已约数             病人挂号汇总.已约数%Type;
  n_其中已接收         病人挂号汇总.已约数%Type;
  n_预约生成队列       Number;
  d_Date               Date;
  n_挂号序号           Number;
  v_排队序号           排队叫号队列.排队序号%Type;
  v_机器名             挂号序号状态.机器名%Type;
  v_序号操作员         挂号序号状态.操作员姓名%Type;
  v_序号机器名         挂号序号状态.机器名%Type;
  n_序号锁定           Number := 0;
  n_病历费id           收费特定项目.收费细目id%Type;
  v_付款方式           病人挂号记录.医疗付款方式%Type;
  v_费别               门诊费用记录.费别%Type;
  n_屏蔽费别           Number(3) := 0;
  n_Tmp安排id          挂号安排.Id%Type;
  n_计划id             挂号安排计划.Id%Type;
  v_年龄               病人信息.年龄%Type;
  n_合作单位限数量模式 Number;
  n_出诊记录id         临床出诊记录.Id%Type;
  n_挂号模式           Number(3);
  n_同科限号数         Number;
  n_同科限约数         Number;
  n_病人挂号科室数     Number;
  d_启用时间           Date;
  v_Para               Varchar2(2000);
  n_专家号挂号限制     Number;
  n_专家号预约限制     Number;
  v_站点               部门表.站点%Type;
  v_普通等级           Varchar2(100);
  v_Pricegrade         Varchar2(500);
  v_时间段             时间段.时间段%Type;
  d_检查开始时间       时间段.开始时间%Type;
  d_检查结束时间       时间段.终止时间%Type;
  v_传入               Varchar2(100);
  n_更新项目id         挂号安排.项目id%Type;
  n_项目id             挂号安排.项目id%Type;

  Cursor c_Pati(n_病人id 病人信息.病人id%Type) Is
    Select a.病人id, a.姓名, a.性别, a.年龄, a.住院号, a.门诊号, a.费别, a.险类, c.编码 As 付款方式, a.出生日期, a.身份证号
    From 病人信息 A, 医疗付款方式 C
    Where a.病人id = n_病人id And a.医疗付款方式 = c.名称(+);

  r_Pati c_Pati%RowType;

  --该游标用于收费冲预交的可用预交列表
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit
  (
    v_病人id        病人信息.病人id%Type,
    v_冲预交病人ids Varchar2
  ) Is
    Select 病人id, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额, Min(记录状态) As 记录状态, Nvl(Max(结帐id), 0) As 结帐id,
           Max(Decode(记录性质, 1, ID, 0) * Decode(记录状态, 2, 0, 1)) As 原预交id
    From 病人预交记录
    Where 记录性质 In (1, 11) And 病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And Nvl(预交类别, 2) = 1
     Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
    Group By NO, 病人id
    Order By Decode(病人id, Nvl(v_病人id, 0), 0, 1), 结帐id, NO;

  Cursor c_安排
  (
    v_号码        挂号安排.号码%Type,
    d_发生时间_In Date
  ) Is
    Select *
    From (With 安排时间段 As (Select 时间段
                         From (Select 时间段,
                                       To_Date(Decode(Sign(开始时间 - 终止时间), 1, '3000-01-09 ' || To_Char(开始时间, 'HH24:MI:SS'),
                                                       '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS')), 'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                       To_Date(Decode(Sign(开始时间 - 终止时间), 1, '3000-01-11 ' || To_Char(终止时间, 'HH24:MI:SS'),
                                                       '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS')), 'yyyy-mm-dd hh24:mi:ss') As 终止时间,
                                       To_Date('3000-01-10 ' || To_Char(d_发生时间_In, 'HH24:MI:SS'), 'yyyy-mm-dd hh24:mi:ss') As 当前时间,
                                       To_Date('3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS'), 'yyyy-mm-dd hh24:mi:ss') As 开始时间1,
                                       To_Date('3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS'), 'yyyy-mm-dd hh24:mi:ss') As 终止时间1
                                From 时间段)
                         Where 当前时间 Between 开始时间 And 终止时间1 Or 当前时间 Between 开始时间1 And 终止时间)
           Select Distinct p.Id, p.号类, p.号码, p.科室id, b.编码 As 科室编码, b.名称 As 科室名称, p.项目id, c.编码 As 项目编码, c.名称 As 项目名称,
                           p.医生id, d.编号 As 医生编号, p.医生姓名, p.限号数, p.限约数, p.周日 As 日, p.周一 As 一, p.周二 As 二, p.周三 As 三,
                           p.周四 As 四, p.周五 As 五, p.周六 As 六, p.序号控制, p.计划id
           From (Select p.Id, p.号码, p.号类, p.科室id, p.项目id, p.医生id, p.医生姓名, b.限号数, b.限约数, Nvl(p.病案必须, 0) As 病案必须, p.周日, p.周一,
                         p.周二, p.周三, p.周四, p.周五, p.周六, p.分诊方式, p.序号控制,
                         Decode(To_Char(d_发生时间_In, 'D'), '1', p.周日, '2', p.周一, '3', p.周二, '4', p.周三, '5', p.周四, '6', p.周五,
                                 '7', p.周六, Null) As 排班, Null As 计划id
                  From 挂号安排 P, 挂号安排限制 B
                  Where p.停用日期 Is Null And p.Id = b.安排id(+) And
                        b.限制项目(+) = Decode(To_Char(d_发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四',
                                           '6', '周五', '7', '周六', Null) And
                        d_发生时间_In Between Nvl(p.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                        Nvl(p.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Not Exists
                   (Select 1
                         From 挂号安排计划
                         Where 安排id = p.Id And (d_发生时间_In Between 生效时间 And 失效时间) And 审核时间 Is Not Null) And Not Exists
                   (Select 1
                         From 挂号安排停用状态
                         Where 安排id = p.Id And d_发生时间_In Between 开始停止时间 And 结束停止时间) And p.号码 = v_号码
                  Union All
                  Select c.Id, c.号码, c.号类, c.科室id, p.项目id, p.医生id, p.医生姓名, b.限号数, b.限约数, Nvl(c.病案必须, 0) As 病案必须, p.周日, p.周一,
                         p.周二, p.周三, p.周四, p.周五, p.周六, p.分诊方式, p.序号控制,
                         Decode(To_Char(d_发生时间_In, 'D'), '1', p.周日, '2', p.周一, '3', p.周二, '4', p.周三, '5', p.周四, '6', p.周五,
                                 '7', p.周六, Null) As 排班, p.Id As 计划id
                  From 挂号安排计划 P, 挂号安排 C, 挂号计划限制 B,
                       (Select Max(a.生效时间) As 生效, 安排id
                         From 挂号安排计划 A, 挂号安排 B
                         Where a.安排id = b.Id And a.审核时间 Is Not Null And
                               发生时间_In Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                               Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) And b.号码 = 号码_In
                         Group By 安排id) E
                  Where p.安排id = c.Id And p.Id = b.计划id(+) And p.生效时间 = e.生效 And p.安排id = e.安排id And
                        Nvl(p.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) = Nvl(e.生效, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                        b.限制项目(+) = Decode(To_Char(d_发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四',
                                           '6', '周五', '7', '周六', Null) And (d_发生时间_In Between p.生效时间 And p.失效时间) And
                        p.审核时间 Is Not Null And Not Exists
                   (Select 1
                         From 挂号安排停用状态
                         Where 安排id = c.Id And d_发生时间_In Between 开始停止时间 And 结束停止时间) And p.号码 = v_号码) P, 部门表 B, 收费项目目录 C,
                人员表 D
           Where p.科室id = b.Id And p.医生id = d.Id(+) And p.项目id = c.Id And
                 (c.撤档时间 Is Null Or c.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD')) And
                 (Nvl(p.医生id, 0) = 0 Or Exists
                  (Select 1
                   From 人员表 Q
                   Where p.医生id = q.Id And (q.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or q.撤档时间 Is Null))) And Exists
            (Select 1 From 安排时间段 Where 时间段 = p.排班))
           Order By 号码;


  r_安排 c_安排%RowType;

  Function Zl_诊室(号码_In 挂号安排.号码%Type) Return Varchar2 As
    n_分诊方式 挂号安排.分诊方式%Type;
    n_安排id   挂号安排.Id%Type;
    v_诊室     病人挂号记录.诊室%Type;
    v_Rowid    Varchar2(500);
    n_Next     Integer;
    n_First    Integer;
  Begin
  
    If 锁定类型_In = 2 Then
      --对单据进行解锁,首先检查是否存在锁定
      Select Count(Rowid) Into n_锁定 From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
      If n_锁定 = 0 Then
        v_Err_Msg := '单据号为(' || 单据号_In || ')的单据,不存在或者已经被解锁!';
        Raise Err_Item;
      End If;
      Select Max(号序) Into n_号序 From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
    End If;
  
    Begin
      Select ID, Nvl(分诊方式, 0) Into n_安排id, n_分诊方式 From 挂号安排 Where 号码 = 号码_In;
    Exception
      When Others Then
        n_安排id := -1;
    End;
  
    If n_安排id = -1 Then
      v_Err_Msg := '号码(' || 号码_In || ')未找到!';
      Raise Err_Item;
    End If;
    --0-不分诊、1-指定诊室、2-动态分诊、3-平均分诊,对应门诊诊室设置
    v_诊室 := Null;
    If n_分诊方式 = 1 Then
      --1-指定诊室
      Begin
        Select 门诊诊室 Into v_诊室 From 挂号安排诊室 Where 号表id = n_安排id;
      Exception
        When Others Then
          v_诊室 := Null;
      End;
    End If;
    If n_分诊方式 = 2 Then
      --2-动态分诊:该个号别当天挂号未诊数最少的诊室
      For c_诊室 In (Select 门诊诊室, Sum(Num) As Num
                   From (Select 门诊诊室, 0 As Num
                          From 挂号安排诊室
                          Where 号表id = n_安排id
                          Union All
                          Select 诊室, Count(诊室) As Num
                          From 病人挂号记录
                          Where Nvl(执行状态, 0) = 0 And 发生时间 Between Trunc(Sysdate) And Sysdate And 号别 = 号码_In And
                                诊室 In (Select 门诊诊室 From 挂号安排诊室 Where 号表id = n_安排id)
                          Group By 诊室)
                   Group By 门诊诊室
                   Order By Num) Loop
        v_诊室 := c_诊室.门诊诊室;
        Exit;
      End Loop;
    End If;
    If n_分诊方式 = 3 Then
    
      --平均分诊：当前分配=1表示下次应取的当前诊室
      n_Next  := 0;
      n_First := 1;
      For c_诊室 In (Select Rowid As Rid, 号表id, 门诊诊室, 当前分配 From 挂号安排诊室 Where 号表id = n_安排id) Loop
        If n_First = 1 Then
          v_Rowid := c_诊室.Rid;
        End If;
        If n_Next = 1 Then
          v_诊室 := c_诊室.门诊诊室;
          Update 挂号安排诊室 Set 当前分配 = 1 Where Rowid = c_诊室.Rid;
          Exit;
        End If;
        If Nvl(c_诊室.当前分配, 0) = 1 Then
          Update 挂号安排诊室 Set 当前分配 = 0 Where Rowid = c_诊室.Rid;
          n_Next := 1;
        End If;
      End Loop;
      If v_诊室 Is Null Then
        Update 挂号安排诊室 Set 当前分配 = 1 Where Rowid = v_Rowid Returning 门诊诊室 Into v_诊室;
      End If;
    End If;
  
    Return v_诊室;
  End;

  Function Zl_操作员
  (
    Type_In     Integer,
    Splitstr_In Varchar2
  ) Return Varchar2 As
    n_Step Number(18);
    v_Sub  Varchar2(1000);
    --Type_In:0-获取缺省部门ID;1-获取操作员编号;2-获取操作员姓名
    -- SplitStr:格式为:部门ID,部门名称;人员ID,人员编号,人员姓名(用Zl_Identity获取的)
  Begin
    If Type_In = 0 Then
      --缺省部门
      n_Step := Instr(Splitstr_In, ',');
      v_Sub  := Substr(Splitstr_In, 1, n_Step - 1);
      Return v_Sub;
    End If;
    If Type_In = 1 Then
      --操作员编码
      n_Step := Instr(Splitstr_In, ';');
      v_Sub  := Substr(Splitstr_In, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, 1, n_Step - 1);
      Return v_Sub;
    End If;
    If Type_In = 2 Then
      --操作员姓名
      n_Step := Instr(Splitstr_In, ';');
      v_Sub  := Substr(Splitstr_In, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      Return v_Sub;
    End If;
  End;

  Procedure Zl_三方机构挂号_出诊_Insert
  (
    记录id_In        临床出诊记录.Id%Type,
    操作方式_In      Integer,
    病人id_In        门诊费用记录.病人id%Type,
    号码_In          挂号安排.号码%Type,
    号序_In          挂号序号状态.序号%Type,
    单据号_In        门诊费用记录.No%Type,
    票据号_In        门诊费用记录.实际票号%Type,
    结算方式_In      Varchar2,
    摘要_In          门诊费用记录.摘要%Type, --预约挂号摘要信息
    发生时间_In      门诊费用记录.发生时间%Type,
    登记时间_In      门诊费用记录.登记时间%Type,
    合作单位_In      挂号合作单位.名称%Type,
    挂号金额合计_In  门诊费用记录.实收金额%Type,
    领用id_In        票据使用明细.领用id%Type,
    收费票据_In      Number := 0, --挂号是否使用收费票据
    交易流水号_In    病人预交记录.交易流水号%Type,
    交易说明_In      病人预交记录.交易说明%Type,
    预约方式_In      预约方式.名称%Type := Null,
    预交id_In        病人预交记录.Id%Type := Null,
    卡类别id_In      病人预交记录.卡类别id%Type := Null,
    加入序号状态_In  Number := 0,
    是否自助设备_In  Number := 0,
    结帐id_In        门诊费用记录.结帐id%Type := Null,
    锁定类型_In      Number := 0,
    保险结算_In      Varchar2 := Null,
    冲预交_In        Number := Null,
    支付卡号_In      病人预交记录.卡号%Type := Null,
    费别_In          门诊费用记录.费别%Type := Null,
    冲预交病人ids_In Varchar2 := Null,
    机器名_In        挂号序号状态.机器名%Type := Null,
    更新年龄_In      Number := 0,
    购买病历_In      Number := 0,
    记帐费用_In      Number := 0,
    付款方式_In      医疗付款方式.名称%Type := Null
  ) As
    --功能：三方机构进行挂号(包含预约;预约挂号不扣款;预约挂号扣款),出诊表排班模式下使用
    --入参: 操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
    --      加入序号状态_In:1-表示强制加入挂号序号状态表中;否则根据启用序号或启用时段时才加入.
    --      是否自助设备_In:1-表示是医院的自助设备进行此函数的调用,自助设备调用此函数 允许加号,否则不允许
    --      锁定类型_In :0-产生正常数据 1-表示对单据进行锁定,产生未生效的单据信息;2-对锁定的记录进行解锁-生成正常数据:未生效的单据在银行扣款完成后进行解锁
    --      保险结算_IN:格式="结算方式|结算金额||....."
    --      冲预交病人ids_In:多个用逗分分离,冲预交时有效(冲预交类别与业务操作保持一致),主要是使用家属的预交款
    Err_Item Exception;
    Err_Special Exception;
    v_Err_Msg  Varchar2(255);
    n_打印id   票据打印内容.Id%Type;
    n_返回值   病人预交记录.金额%Type;
    v_排队号码 Varchar2(20);
    v_队列名称 排队叫号队列.队列名称%Type;
    n_预交id   病人预交记录.Id%Type;
    n_挂号id   病人挂号记录.Id%Type;
    v_结算内容 Varchar2(3000);
    v_当前结算 Varchar2(150);
  
    v_结算方式           病人预交记录.结算方式%Type;
    n_结算金额           病人预交记录.冲预交%Type;
    n_结算合计           Number(16, 5);
    n_预交金额           病人预交记录.冲预交%Type;
    n_组id               财务缴款分组.Id%Type;
    d_排队时间           Date;
    n_锁定               Number;
    n_病人预约科室数     Number(18);
    n_已约科室           Number(18);
    d_发生时间           Date;
    n_合作单位限制       Number(18);
    n_是否开放           Number(1);
    n_Count              Number(18);
    n_行号               Number(18);
    n_费用id             门诊费用记录.Id%Type;
    n_价格父号           Number(18);
    n_原项目id           收费项目目录.Id%Type;
    n_原收入项目id       收费项目目录.Id%Type;
    v_诊室               病人挂号记录.诊室%Type;
    n_实收金额合计       门诊费用记录.实收金额%Type;
    n_开单部门id         门诊费用记录.开单部门id%Type;
    n_实收金额           门诊费用记录.实收金额%Type;
    n_应收金额           门诊费用记录.实收金额%Type;
    n_急诊               病人挂号记录.急诊%Type;
    n_结帐id             病人结帐记录.Id%Type;
    v_Temp               Varchar2(500);
    v_结算方式记录       Varchar2(1000);
    n_预约时段序号       Number;
    n_序号控制           临床出诊记录.是否序号控制%Type;
    n_限约数             临床出诊记录.限约数%Type;
    n_项目id             临床出诊记录.项目id%Type;
    n_科室id             临床出诊记录.科室id%Type;
    d_终止时间           临床出诊记录.终止时间%Type;
    v_医生姓名           临床出诊记录.医生姓名%Type;
    n_医生id             临床出诊记录.医生id%Type;
    n_预约顺序号         临床出诊序号控制.预约顺序号%Type;
    n_预约总数           Number;
    d_时段开始时间       Date;
    d_时段终止时间       Date;
    v_收费项目ids        Varchar2(300);
    n_三方卡标志         Number;
    n_号序               病人挂号记录.号序%Type;
    d_登记时间           Date;
    n_单笔金额           病人预交记录.冲预交%Type;
    v_结算号码           病人预交记录.结算号码%Type;
    v_操作员编号         人员表.编号%Type;
    v_操作员姓名         人员表.姓名%Type;
    n_预约               Integer;
    n_分时点显示         Number;
    v_现金               病人预交记录.结算方式%Type;
    n_启用分时段         Integer;
    n_已挂数             病人挂号汇总.已挂数%Type;
    n_已约数             病人挂号汇总.已约数%Type;
    n_其中已接收         病人挂号汇总.已约数%Type;
    n_预约生成队列       Number;
    n_限号数             临床出诊记录.限号数%Type;
    d_Date               Date;
    n_挂号序号           Number;
    v_排队序号           排队叫号队列.排队序号%Type;
    v_机器名             挂号序号状态.机器名%Type;
    v_序号操作员         挂号序号状态.操作员姓名%Type;
    v_序号机器名         挂号序号状态.机器名%Type;
    n_序号锁定           Number := 0;
    n_病历费id           收费特定项目.收费细目id%Type;
    v_付款方式           病人挂号记录.医疗付款方式%Type;
    v_费别               门诊费用记录.费别%Type;
    n_屏蔽费别           Number(3) := 0;
    v_年龄               病人信息.年龄%Type;
    n_合作单位限数量模式 Number;
    n_同科限号数         Number;
    n_同科限约数         Number;
    n_病人挂号科室数     Number;
    n_Exists             Number(5);
    v_冲预交病人ids      Varchar2(4000);
    n_替诊医生id         临床出诊记录.替诊医生id%Type;
    v_替诊医生姓名       临床出诊记录.替诊医生姓名%Type;
    d_替诊开始时间       临床出诊记录.替诊开始时间%Type;
    d_替诊终止时间       临床出诊记录.替诊终止时间%Type;
    n_专家号挂号限制     Number;
    n_专家号预约限制     Number;
    v_站点               部门表.站点%Type;
    v_普通等级           Varchar2(100);
    v_Pricegrade         Varchar2(500);
    v_传入               Varchar2(100);
    n_更新项目id         挂号安排.项目id%Type;
  
    Cursor c_Pati(n_病人id 病人信息.病人id%Type) Is
      Select a.病人id, a.姓名, a.性别, a.年龄, a.住院号, a.门诊号, a.费别, a.险类, c.编码 As 付款方式, a.出生日期, a.身份证号
      From 病人信息 A, 医疗付款方式 C
      Where a.病人id = n_病人id And a.医疗付款方式 = c.名称(+);
  
    r_Pati c_Pati%RowType;
  
    --该游标用于收费冲预交的可用预交列表
    --以ID排序，优先冲上次未冲完的。
    Cursor c_Deposit
    (
      v_病人id        病人信息.病人id%Type,
      v_冲预交病人ids Varchar2
    ) Is
      Select 病人id, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额, Min(记录状态) As 记录状态, Nvl(Max(结帐id), 0) As 结帐id,
             Max(Decode(记录性质, 1, ID, 0) * Decode(记录状态, 2, 0, 1)) As 原预交id
      From 病人预交记录
      Where 记录性质 In (1, 11) And 病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And Nvl(预交类别, 2) = 1
       Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
      Group By NO, 病人id
      Order By Decode(病人id, Nvl(v_病人id, 0), 0, 1), 结帐id, NO;
  
    Function Zl_诊室(记录id_In 临床出诊记录.Id%Type) Return Varchar2 As
      n_分诊方式 临床出诊记录.分诊方式%Type;
      v_诊室     病人挂号记录.诊室%Type;
      v_Rowid    Varchar2(500);
      n_Next     Integer;
      n_First    Integer;
    Begin
    
      If 锁定类型_In = 2 Then
        --对单据进行解锁,首先检查是否存在锁定
        Select Count(Rowid)
        Into n_锁定
        From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
        If n_锁定 = 0 Then
          v_Err_Msg := '单据号为(' || 单据号_In || ')的单据,不存在或者已经被解锁!';
          Raise Err_Item;
        End If;
        Select Max(号序) Into n_号序 From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
      End If;
    
      Begin
        Select Nvl(分诊方式, 0) Into n_分诊方式 From 临床出诊记录 Where ID = 记录id_In;
      Exception
        When Others Then
          v_Err_Msg := '出诊记录(' || 记录id_In || ')未找到!';
          Raise Err_Item;
      End;
    
      --0-不分诊、1-指定诊室、2-动态分诊、3-平均分诊,对应门诊诊室设置
      v_诊室 := Null;
      If n_分诊方式 = 1 Then
        --1-指定诊室
        Begin
          Select b.名称 Into v_诊室 From 临床出诊诊室记录 A, 门诊诊室 B Where a.诊室id = b.Id And a.记录id = 记录id_In;
        Exception
          When Others Then
            v_诊室 := Null;
        End;
      End If;
      If n_分诊方式 = 2 Then
        --2-动态分诊:该个号别当天挂号未诊数最少的诊室
        For c_诊室 In (Select 门诊诊室, Sum(Num) As Num
                     From (Select b.名称 As 门诊诊室, 0 As Num
                            From 临床出诊诊室记录 A, 门诊诊室 B
                            Where a.诊室id = b.Id And a.记录id = 记录id_In
                            Union All
                            Select 诊室, Count(诊室) As Num
                            From 病人挂号记录
                            Where Nvl(执行状态, 0) = 0 And 发生时间 Between Trunc(Sysdate) And Sysdate And 号别 = 号码_In And
                                  诊室 In (Select d.名称
                                         From 临床出诊诊室记录 C, 门诊诊室 D
                                         Where c.诊室id = d.Id And c.记录id = 记录id_In)
                            Group By 诊室)
                     Group By 门诊诊室
                     Order By Num) Loop
          v_诊室 := c_诊室.门诊诊室;
          Exit;
        End Loop;
      End If;
      If n_分诊方式 = 3 Then
        --平均分诊：当前分配=1表示下次应取的当前诊室
        n_Next  := 0;
        n_First := 1;
        For c_诊室 In (Select a.Rowid As Rid, b.名称 As 门诊诊室, a.当前分配
                     From 临床出诊诊室记录 A, 门诊诊室 B
                     Where a.诊室id = b.Id And a.记录id = 记录id_In) Loop
          If n_First = 1 Then
            v_Rowid := c_诊室.Rid;
          End If;
          If n_Next = 1 Then
            v_诊室 := c_诊室.门诊诊室;
            Update 临床出诊诊室记录 Set 当前分配 = 1 Where Rowid = c_诊室.Rid;
            Exit;
          End If;
          If Nvl(c_诊室.当前分配, 0) = 1 Then
            Update 临床出诊诊室记录 Set 当前分配 = 0 Where Rowid = c_诊室.Rid;
            n_Next := 1;
          End If;
        End Loop;
        If v_诊室 Is Null Then
          Update 临床出诊诊室记录 Set 当前分配 = 1 Where Rowid = v_Rowid Returning 诊室id Into v_诊室;
          Select 名称 Into v_诊室 From 门诊诊室 Where ID = v_诊室;
        End If;
      End If;
      Return v_诊室;
    End;
  
    Function Zl_操作员
    (
      Type_In     Integer,
      Splitstr_In Varchar2
    ) Return Varchar2 As
      n_Step Number(18);
      v_Sub  Varchar2(1000);
      --Type_In:0-获取缺省部门ID;1-获取操作员编号;2-获取操作员姓名
      -- SplitStr:格式为:部门ID,部门名称;人员ID,人员编号,人员姓名(用Zl_Identity获取的)
    Begin
      If Type_In = 0 Then
        --缺省部门
        n_Step := Instr(Splitstr_In, ',');
        v_Sub  := Substr(Splitstr_In, 1, n_Step - 1);
        Return v_Sub;
      End If;
      If Type_In = 1 Then
        --操作员编码
        n_Step := Instr(Splitstr_In, ';');
        v_Sub  := Substr(Splitstr_In, n_Step + 1);
        n_Step := Instr(v_Sub, ',');
        v_Sub  := Substr(v_Sub, n_Step + 1);
        n_Step := Instr(v_Sub, ',');
        v_Sub  := Substr(v_Sub, 1, n_Step - 1);
        Return v_Sub;
      End If;
      If Type_In = 2 Then
        --操作员姓名
        n_Step := Instr(Splitstr_In, ';');
        v_Sub  := Substr(Splitstr_In, n_Step + 1);
        n_Step := Instr(v_Sub, ',');
        v_Sub  := Substr(v_Sub, n_Step + 1);
        n_Step := Instr(v_Sub, ',');
        v_Sub  := Substr(v_Sub, n_Step + 1);
        Return v_Sub;
      End If;
    End;
  
  Begin
    d_发生时间 := 发生时间_In;
  
    If d_发生时间 Is Null Then
      d_发生时间 := Sysdate;
    End If;
  
    If 付款方式_In Is Null Then
      Select Max(名称) Into v_付款方式 From 医疗付款方式 Where 缺省标志 = 1;
    Else
      Select Max(名称) Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In;
      If v_付款方式 Is Null Then
        v_付款方式 := 付款方式_In;
      End If;
    End If;
    v_冲预交病人ids := Nvl(冲预交病人ids_In, 病人id_In);
    Begin
      Select 名称 Into v_现金 From 结算方式 Where 性质 = 1;
    Exception
      When Others Then
        v_现金 := '现金';
    End;
  
    If 费别_In Is Null Then
      Select Zl_Custom_Getpatifeetype(1, 病人id_In) Into v_费别 From Dual;
    Else
      v_费别 := 费别_In;
    End If;
    If v_费别 Is Null Then
      n_屏蔽费别 := 1;
      Select 名称 Into v_费别 From 费别 Where 缺省标志 = 1 And Rownum < 2;
    End If;
    Update 病人信息 Set 费别 = v_费别 Where 病人id = 病人id_In;
  
    If 更新年龄_In = 1 Then
      Select Zl_Age_Calc(病人id_In) Into v_年龄 From Dual;
      If v_年龄 Is Not Null Then
        Update 病人信息 Set 年龄 = v_年龄 Where 病人id = 病人id_In;
      End If;
    End If;
    --获取当前机器名称
    If 机器名_In Is Not Null Then
      v_机器名 := 机器名_In;
    Else
      Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
    End If;
    n_实收金额合计 := 0;
  
    Select Count(*) + 1
    Into n_挂号序号
    From 病人挂号记录
    Where 出诊记录id = 记录id_In And 登记时间 Between Trunc(发生时间_In) And Trunc(发生时间_In + 1) - 1 / 24 / 60 / 60;
  
    If 登记时间_In Is Null Then
      d_登记时间 := Sysdate;
    Else
      d_登记时间 := 登记时间_In;
    End If;
    If Trunc(Sysdate) > Trunc(发生时间_In) Then
      v_Err_Msg := '不能挂以前的号(' || To_Char(发生时间_In, 'yyyy-mm-dd') || ')。';
      Raise Err_Item;
    End If;
  
    v_Temp           := Nvl(zl_GetSysParameter('病人同科限挂N个号', 1111), '0|0') || '|';
    n_同科限号数     := To_Number(Substr(v_Temp, 1, Instr(v_Temp, '|') - 1));
    n_同科限约数     := To_Number(Nvl(zl_GetSysParameter('病人同科限约N个号', 1111), '0'));
    n_病人预约科室数 := To_Number(Nvl(zl_GetSysParameter('病人预约科室数', 1111), '0'));
    n_病人挂号科室数 := To_Number(Nvl(zl_GetSysParameter('病人挂号科室限制', 1111), '0'));
    n_专家号挂号限制 := To_Number(Nvl(zl_GetSysParameter('专家号挂号限制'), '0'));
    n_专家号预约限制 := To_Number(Nvl(zl_GetSysParameter('专家号预约限制'), '0'));
  
    --部门ID,部门名称;人员ID,人员编号,人员姓名
    v_Temp := Zl_Identity(0);
    If Nvl(v_Temp, ' ') = ' ' Then
      v_Err_Msg := '当前操作人员未设置对应的人员关系,不能继续。';
      Raise Err_Item;
    End If;
    n_开单部门id := To_Number(Zl_操作员(0, v_Temp));
    v_操作员编号 := Zl_操作员(1, v_Temp);
    v_操作员姓名 := Zl_操作员(2, v_Temp);
    n_组id       := Zl_Get组id(v_操作员姓名);
  
    --支付宝并发提交检查
    Select Nvl(Max(1), 0)
    Into n_Exists
    From 病人挂号记录
    Where 病人id = 病人id_In And 号别 = 号码_In And 号序 = 号序_In And 操作员姓名 = v_操作员姓名 And Nvl(记录id_In, 0) = Nvl(出诊记录id, 0) And
          登记时间 > Sysdate - 0.01 And 记录状态 = 1 And 发生时间 = 发生时间_In;
    If n_Exists = 1 Then
      v_Err_Msg := '病人已经挂号,不能重复挂相同的号！';
      Raise Err_Special;
    End If;
  
    If 操作方式_In <> 1 Then
      --预约检查是否添加合作单位控制
      --如果设置了合作单位控制 则
      Begin
        Select 1
        Into n_合作单位限制
        From 临床出诊挂号控制记录
        Where 记录id = 记录id_In And 类型 = 1 And 性质 = 1 And 控制方式 <> 4 And Rownum < 2;
      Exception
        When Others Then
          n_合作单位限制 := 0;
      End;
    End If;
  
    If 操作方式_In <> 2 Then
      v_诊室 := Zl_诊室(记录id_In);
    End If;
  
    --因为现在有按日编单据号规则,日挂号量不能超过10000次,所以要检查唯一约束。
    Select Count(*) Into n_Count From 门诊费用记录 Where 记录性质 = 4 And 记录状态 In (1, 3) And NO = 单据号_In;
    If n_Count <> 0 Then
      v_Err_Msg := '挂号单据号重复,不能保存！' || Chr(13) || '如果使用了按日顺序编号,当日挂号量不能超过10000人次。';
      Raise Err_Item;
    End If;
  
    Open c_Pati(病人id_In);
    n_Count := 0;
    Begin
      Fetch c_Pati
        Into r_Pati;
    Exception
      When Others Then
        n_Count := -1;
    End;
    If n_Count = -1 Then
      v_Err_Msg := '病人未找到，不能继续。';
      Raise Err_Item;
    End If;
  
    Begin
      Select Nvl(是否分时段, 0), 限号数, 已挂数, 其中已接收, 已约数, 是否序号控制, 限约数, 项目id, 科室id, 医生id, 医生姓名, 替诊医生id, 替诊医生姓名, 替诊开始时间, 替诊终止时间
      Into n_启用分时段, n_限号数, n_已挂数, n_其中已接收, n_已约数, n_序号控制, n_限约数, n_项目id, n_科室id, n_医生id, v_医生姓名, n_替诊医生id, v_替诊医生姓名,
           d_替诊开始时间, d_替诊终止时间
      From 临床出诊记录
      Where ID = 记录id_In And Nvl(是否锁定, 0) = 0;
    Exception
      When Others Then
        n_Count := -1;
    End;
    If n_Count = -1 Then
      v_Err_Msg := '该号别没有在' || To_Char(发生时间_In, 'yyyy-mm-dd hh24:mi:ss') || '中进行安排。';
      Raise Err_Item;
    End If;
  
    Select Min(站点) Into v_站点 From 部门表 Where ID = n_科室id;
    v_Pricegrade := Zl_Get_Pricegrade(v_站点, 病人id_In, Null, v_付款方式);
    v_普通等级   := Substr(v_Pricegrade, 1, Instr(v_Pricegrade, '|') - 1);
  
    If 发生时间_In Between Nvl(d_替诊开始时间, Sysdate) And Nvl(d_替诊终止时间, Sysdate - 1) And v_替诊医生姓名 Is Not Null Then
      n_医生id   := n_替诊医生id;
      v_医生姓名 := v_替诊医生姓名;
    End If;
  
    --对参数控制进行检查
    --仅在预约不扣款时进行检查
    If 操作方式_In = 2 Then
      If Nvl(n_同科限约数, 0) <> 0 Or Nvl(n_病人预约科室数, 0) <> 0 Then
        n_已约科室 := 0;
        For c_Chkitem In (Select Distinct 执行部门id
                          From 病人挂号记录
                          Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 2 And 预约时间 Between Trunc(发生时间_In) And
                                Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id <> n_科室id) Loop
          n_已约科室 := n_已约科室 + 1;
        End Loop;
        If n_已约科室 >= Nvl(n_病人预约科室数, 0) And Nvl(n_病人预约科室数, 0) > 0 Then
          v_Err_Msg := '同一病人最多同时能预约[' || Nvl(n_病人预约科室数, 0) || ']个科室,不能再预约！';
          Raise Err_Item;
        End If;
      
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 2 And 预约时间 Between Trunc(发生时间_In) And
              Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id = n_科室id;
        If n_Count >= Nvl(n_同科限约数, 0) And Nvl(n_同科限约数, 0) > 0 Then
          v_Err_Msg := '该病人已经在该科室预约了' || n_Count || '次,不能再预约！';
          Raise Err_Item;
        End If;
      End If;
      If Nvl(n_专家号预约限制, 0) <> 0 Then
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 2 And 出诊记录id = 记录id_In;
        If n_Count >= Nvl(n_专家号预约限制, 0) And Nvl(n_专家号预约限制, 0) > 0 Then
          v_Err_Msg := '该病人已经超过本号预约限制,不能再预约！';
          Raise Err_Item;
        End If;
      End If;
    Else
      If Nvl(n_同科限号数, 0) <> 0 Or Nvl(n_病人挂号科室数, 0) <> 0 Then
        n_已约科室 := 0;
        For c_Chkitem In (Select Distinct 执行部门id
                          From 病人挂号记录
                          Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 1 And 发生时间 Between Trunc(发生时间_In) And
                                Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id <> n_科室id) Loop
          n_已约科室 := n_已约科室 + 1;
        End Loop;
        If n_已约科室 >= Nvl(n_病人挂号科室数, 0) And Nvl(n_病人挂号科室数, 0) > 0 Then
          v_Err_Msg := '同一病人最多同时能挂号[' || Nvl(n_病人挂号科室数, 0) || ']个科室,不能再挂号！';
          Raise Err_Item;
        End If;
      
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 1 And 发生时间 Between Trunc(发生时间_In) And
              Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id = n_科室id;
        If n_Count >= Nvl(n_同科限号数, 0) And Nvl(n_同科限号数, 0) > 0 Then
          v_Err_Msg := '该病人已经在该科室挂号了' || n_Count || '次,不能再挂号！';
          Raise Err_Item;
        End If;
      End If;
      If Nvl(n_专家号挂号限制, 0) <> 0 Then
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 1 And 出诊记录id = 记录id_In;
        If n_Count >= Nvl(n_专家号挂号限制, 0) And Nvl(n_专家号挂号限制, 0) > 0 Then
          v_Err_Msg := '该病人已经超过本号挂号限制,不能再挂号！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  
    d_Date         := Null;
    d_时段开始时间 := Null;
  
    If Nvl(n_限号数, 0) >= 0 Or n_限号数 Is Null Then
      If n_启用分时段 = 1 Then
        If Nvl(n_序号控制, 0) = 1 Then
          If Nvl(是否自助设备_In, 0) = 0 Then
            Select Count(*), Max(开始时间)
            Into n_Count, d_时段开始时间
            From 临床出诊序号控制
            Where 记录id = 记录id_In And 序号 = Nvl(号序_In, 0);
          
            v_Temp := '挂号';
            If 操作方式_In > 1 Then
              v_Temp := '预约挂号';
            End If;
          
            If n_Count = 0 Then
              v_Err_Msg := '号别为' || 号码_In || '的挂号安排中不存在序号为' || Nvl(号序_In, 0) || '的安排,不能再' || v_Temp || '！';
              Raise Err_Item;
            End If;
          End If;
        
          --过点的,不能选择挂号
          If Trunc(Sysdate) = Trunc(发生时间_In) Then
            --挂当天的号
            v_Temp := To_Char(Sysdate, 'yyyy-mm-dd') || ' ';
            For v_时段 In (Select To_Date(v_Temp || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                To_Date(To_Char(Sysdate + Decode(Sign(开始时间 - 终止时间), 1, 1, 0), 'yyyy-mm-dd') || ' ' ||
                                         To_Char(终止时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 终止时间, 数量, 是否预约
                         From 临床出诊序号控制
                         Where 记录id = 记录id_In And 序号 = Nvl(号序_In, 0)) Loop
              If Sysdate > v_时段.终止时间 Then
                v_Err_Msg := '号别为' || 号码_In || '及号序为' || Nvl(号序_In, 0) || '的安排,已经超过时点,不能再' || v_Temp || '！';
                Raise Err_Item;
              End If;
            End Loop;
          End If;
        Elsif 操作方式_In > 1 Then
          --未启用序号的,需要检查预约的情况
          n_Count := 0;
          For v_时段 In (Select 序号, 开始时间, 终止时间, 数量, 是否预约
                       From 临床出诊序号控制
                       Where 记录id = 记录id_In And
                             (('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                             Decode(Sign(开始时间 - 终止时间 - 1 / 24 / 60 / 60), 1,
                                      '3000-01-09 ' || To_Char(开始时间, 'HH24:MI:SS'),
                                      '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS')) And
                             '3000-01-10 ' || To_Char(终止时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS')) Or
                             ('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                             '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS') And
                             Decode(Sign(开始时间 - 终止时间 - 1 / 24 / 60 / 60), 1,
                                      '3000-01-11 ' || To_Char(终止时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'),
                                      '3000-01-10 ' || To_Char(终止时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'))))) Loop
            n_预约时段序号 := v_时段.序号;
            d_时段开始时间 := v_时段.开始时间;
            d_时段终止时间 := v_时段.终止时间;
          
            Select Count(*), Max(序号), Max(预约顺序号) + 1
            Into n_Count, n_预约总数, n_预约顺序号
            From 临床出诊序号控制
            Where 记录id = 记录id_In And Nvl(挂号状态, 0) Not In (0, 4, 5);
          
            If Nvl(n_Count, 0) > Nvl(v_时段.数量, 0) And 锁定类型_In <> 2 Then
              v_Err_Msg := '号别为' || 号码_In || '的挂号安排中在' || To_Char(v_时段.开始时间, 'hh24:mi:ss') || '至' ||
                           To_Char(v_时段.终止时间, 'hh24:mi:ss') || '最多只能预约' || Nvl(v_时段.数量, 0) || '人,不能再进行预约挂号！';
              Raise Err_Item;
            End If;
            n_Count := 1;
          End Loop;
        
          If n_Count = 0 Then
            v_Err_Msg := '号别为' || 号码_In || '的挂号安排中没有相关的安排计划(' || To_Char(发生时间_In, 'YYYY-mm-dd HH24:MI:SS') ||
                         '),不能进行预约挂号！';
            Raise Err_Item;
          End If;
        End If;
      End If;
    End If;
  
    If 操作方式_In = 1 And 锁定类型_In <> 2 Then
      --挂号规则:
      --  已挂数不能大于限号数
      If n_已挂数 >= Nvl(n_限号数, 0) And n_限号数 Is Not Null Then
        v_Err_Msg := '该号别今天已达到限号数 ' || Nvl(n_限号数, 0) || '不能再挂号！';
        Raise Err_Item;
      End If;
    End If;
  
    If 操作方式_In > 1 Then
      --预约的相关检查
      --规则:
      --   1.已限约不能超过限约数
      --   2.检查是否启用时段的
      If n_已约数 >= Nvl(n_限约数, 0) And Nvl(n_限约数, 0) <> 0 And n_限约数 Is Not Null And 锁定类型_In <> 2 Then
        v_Err_Msg := '该号别已达到限约数 ' || Nvl(n_限约数, 0) || '不能再预约挂号！';
        Raise Err_Item;
      End If;
      If 预约方式_In Is Not Null Then
        Select To_Number(Substr(Zl_Fun_Get临床出诊预约状态(记录id_In, 发生时间_In, 号序_In, 预约方式_In, Null, 0, v_操作员姓名, v_机器名), 1, 1))
        Into n_Exists
        From Dual;
        If n_Exists <> 0 Then
          v_Err_Msg := '传入的预约方式' || 预约方式_In || '不可用,不能继续。';
          Raise Err_Item;
        End If;
      End If;
    End If;
    If n_合作单位限制 > 0 And 操作方式_In <> 1 And 合作单位_In Is Not Null Then
      If Nvl(n_序号控制, 0) = 1 And Nvl(号序_In, 0) = 0 Then
        v_Err_Msg := '当前安排使用了序号控制,请确认所需要预约的序号,不能继续。';
        Raise Err_Item;
      End If; --Nvl(r_安排.序号控制, 0) =0
    
      --合作单位控制模式
      Begin
        Select Nvl(控制方式, 0)
        Into n_合作单位限数量模式
        From 临床出诊挂号控制记录
        Where 记录id = 记录id_In And 名称 = 合作单位_In And 类型 = 1 And 性质 = 1 And Rownum < 2;
      Exception
        When Others Then
          n_合作单位限数量模式 := 4;
      End;
    
      If n_合作单位限数量模式 = 0 Then
        v_Err_Msg := '当前号码(' || Nvl(号码_In, 0) || '未开放' || 合作单位_In || '的预约,不能继续。';
        Raise Err_Item;
      End If;
      If n_合作单位限数量模式 = 1 Or n_合作单位限数量模式 = 2 Then
        Select 数量
        Into n_Count
        From 临床出诊挂号控制记录
        Where 记录id = 记录id_In And 名称 = 合作单位_In And 类型 = 1 And 性质 = 1;
        If n_合作单位限数量模式 = 1 Then
          n_Count := Round(Nvl(n_限约数, n_限号数) * n_Count / 100);
        End If;
        Select Count(1)
        Into n_Exists
        From 病人挂号记录
        Where 记录状态 = 1 And 出诊记录id = 记录id_In And 合作单位 = 合作单位_In;
        If n_Exists >= n_Count Then
          v_Err_Msg := '当前号码(' || Nvl(号码_In, 0) || '已经超过' || 合作单位_In || '的预约限制,不能继续。';
          Raise Err_Item;
        End If;
      End If;
      --开放序号检查
      If n_合作单位限数量模式 = 3 Then
        For c_合作单位 In (Select 序号, 数量
                       From 临床出诊挂号控制记录
                       Where 记录id = 记录id_In And 名称 = 合作单位_In And 类型 = 1 And 性质 = 1 And 序号 = 号序_In) Loop
          If n_序号控制 = 1 Then
            Begin
              Select 1
              Into n_Count
              From 临床出诊序号控制
              Where 记录id = 记录id_In And 序号 = 号序_In And Nvl(挂号状态, 0) = 0;
            Exception
              When Others Then
                n_Count := 0;
            End;
            If n_Count = 1 Then
              n_是否开放 := 1;
            Else
              v_Err_Msg := '当前序号(' || Nvl(号序_In, 0) || '已经超过' || 合作单位_In || '的预约限制,不能继续。';
              Raise Err_Item;
            End If;
          Else
            Select Count(1)
            Into n_Count
            From 临床出诊序号控制
            Where 记录id = 记录id_In And 序号 = 号序_In And 预约顺序号 Is Not Null And Nvl(挂号状态, 0) <> 0;
            If n_Count >= c_合作单位.数量 Then
              v_Err_Msg := '当前序号(' || Nvl(号序_In, 0) || '已经超过' || 合作单位_In || '的预约限制,不能继续。';
              Raise Err_Item;
            Else
              n_是否开放 := 1;
            End If;
          End If;
        End Loop;
      
        If Nvl(n_是否开放, 0) = 0 Then
          v_Err_Msg := '当前序号(' || Nvl(号序_In, 0) || '未开放,不能继续。';
          Raise Err_Item;
        End If;
      End If;
    End If;
  
    --检查限号数和限约数
    n_行号         := 1;
    n_原项目id     := 0;
    n_原收入项目id := 0;
    n_实收金额合计 := 0;
    If 锁定类型_In <> 1 Then
      If 操作方式_In <> 2 Then
        If Nvl(结帐id_In, 0) = 0 Then
          --这里应该程序传入
          Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
        Else
          n_结帐id := 结帐id_In;
        End If;
      Else
        n_结帐id := Null;
      End If;
    End If;
  
    If Nvl(记录id_In, 0) <> 0 Then
      v_传入 := '2|' || 记录id_In;
    End If;
    If v_传入 Is Null Then
      v_传入 := '3|' || 号码_In;
    End If;
  
    n_更新项目id := Zl_Custom_Getregeventitem(r_Pati.病人id, r_Pati.姓名, r_Pati.身份证号, r_Pati.出生日期, r_Pati.性别, r_Pati.年龄, v_传入);
    If Nvl(n_更新项目id, 0) <> 0 Then
      n_项目id := n_更新项目id;
    End If;
    If Nvl(购买病历_In, 0) = 1 Then
      Begin
        Select 收费细目id Into n_病历费id From 收费特定项目 Where 特定项目 = '病历费';
        v_收费项目ids := n_项目id || ',' || n_病历费id;
      Exception
        When Others Then
          v_Err_Msg := '不能确定病历费,挂号失败!';
          Raise Err_Item;
      End;
    Else
      v_收费项目ids := n_项目id;
    End If;
  
    For c_Item In (Select 1 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, Null As 从属父号,
                          Nvl(a.项目特性, 0) As 急诊
                   From 收费项目目录 A, 收费价目 B, 收入项目 C
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = n_项目id And d_发生时间 Between b.执行日期 And
                         Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And
                         (b.价格等级 = v_普通等级 Or
                         (b.价格等级 Is Null And Not Exists
                          (Select 1
                            From 收费价目
                            Where b.收费细目id = 收费细目id And 价格等级 = v_普通等级 And d_发生时间 Between 执行日期 And
                                  Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')))))
                   Union All
                   Select 2 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, Null As 从属父号, 0 As 急诊
                   From 收费项目目录 A, 收费价目 B, 收入项目 C
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = n_病历费id And d_发生时间 Between b.执行日期 And
                         Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And
                         (b.价格等级 = v_普通等级 Or
                         (b.价格等级 Is Null And Not Exists
                          (Select 1
                            From 收费价目
                            Where b.收费细目id = 收费细目id And 价格等级 = v_普通等级 And d_发生时间 Between 执行日期 And
                                  Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')))))
                   Union All
                   Select 3 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, d.从项数次 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, 1 As 从属父号, 0 As 急诊
                   From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费从属项目 D
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = d.从项id And
                         d.主项id In (Select Column_Value From Table(f_Str2list(v_收费项目ids))) And d_发生时间 Between b.执行日期 And
                         Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And
                         (b.价格等级 = v_普通等级 Or
                         (b.价格等级 Is Null And Not Exists
                          (Select 1
                            From 收费价目
                            Where b.收费细目id = 收费细目id And 价格等级 = v_普通等级 And d_发生时间 Between 执行日期 And
                                  Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')))))
                   Order By 性质, 项目编码, 收入编码) Loop
      If c_Item.性质 = 1 Then
        n_急诊 := Nvl(c_Item.急诊, 0);
      End If;
      n_价格父号 := Null;
      If n_原项目id = c_Item.项目id Then
        If n_原收入项目id <> c_Item.收入项目id Then
          n_价格父号 := n_行号;
        End If;
        n_原收入项目id := c_Item.收入项目id;
      End If;
      n_原项目id := c_Item.项目id;
      n_应收金额 := Round(c_Item.数次 * c_Item.单价, 5);
      n_实收金额 := n_应收金额;
      If Nvl(c_Item.屏蔽费别, 0) <> 1 And n_屏蔽费别 = 0 Then
        --打折:
        v_Temp     := Zl_Actualmoney(r_Pati.费别, c_Item.项目id, c_Item.收入项目id, n_应收金额);
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ':') + 1);
        n_实收金额 := Zl_To_Number(v_Temp);
      End If;
      n_实收金额合计 := Nvl(n_实收金额合计, 0) + n_实收金额;
    
      --锁定单据不产生费用
      If 锁定类型_In <> 1 Then
        --产生病人挂号费用(可能单独是或包括病历费用)
        Select 病人费用记录_Id.Nextval Into n_费用id From Dual;
        --:操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
        Insert Into 门诊费用记录
          (ID, 记录性质, 记录状态, 序号, 价格父号, 从属父号, NO, 实际票号, 门诊标志, 加班标志, 附加标志, 发药窗口, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 病人科室id,
           收费类别, 计算单位, 收费细目id, 收入项目id, 收据费目, 付数, 数次, 标准单价, 应收金额, 实收金额, 结帐金额, 结帐id, 记帐费用, 开单部门id, 开单人, 划价人, 执行部门id, 执行人,
           操作员编号, 操作员姓名, 发生时间, 登记时间, 保险大类id, 保险项目否, 保险编码, 统筹金额, 摘要, 结论, 缴款组id)
        Values
          (n_费用id, 4, Decode(操作方式_In, 2, 0, 1), n_行号, n_价格父号, c_Item.从属父号, 单据号_In, 票据号_In, 1, n_急诊, Null,
           Decode(操作方式_In, 2, To_Char(号序_In), v_诊室), r_Pati.病人id, r_Pati.门诊号, r_Pati.付款方式, r_Pati.姓名, r_Pati.性别,
           r_Pati.年龄, r_Pati.费别, n_科室id, c_Item.类别, 号码_In, c_Item.项目id, c_Item.收入项目id, c_Item.收据费目, 1, c_Item.数次,
           c_Item.单价, n_应收金额, n_实收金额, Decode(操作方式_In, 2, Null, Decode(Nvl(记帐费用_In, 0), 1, Null, n_实收金额)),
           Decode(Nvl(记帐费用_In, 0), 1, Null, n_结帐id), Decode(Nvl(记帐费用_In, 0), 1, 1, 0), n_开单部门id, v_操作员姓名,
           Decode(操作方式_In, 2, v_操作员姓名, Null), n_科室id, v_医生姓名, v_操作员编号, v_操作员姓名, 发生时间_In, d_登记时间, Null, 0, Null, Null,
           摘要_In, 预约方式_In, Decode(操作方式_In, 2, Null, n_组id));
      End If;
      n_行号 := n_行号 + 1;
    
    End Loop;
  
    If Round(Nvl(挂号金额合计_In, 0), 5) <> Round(Nvl(n_实收金额合计, 0), 5) Then
      v_Err_Msg := '本次挂号金额不正确,可能是因为医院调整了价格,请重新获取挂号收费项目的价格,不能继续。';
      Raise Err_Item;
    End If;
  
    If n_启用分时段 = 1 Then
      d_Date := To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(d_时段开始时间, 'hh24:mi:ss'),
                        'yyyy-mm-dd hh24:mi:ss');
    Else
      d_Date := Trunc(发生时间_In);
    End If;
  
    --更新挂号序号状态
    If 锁定类型_In <> 2 Then
      n_号序 := 号序_In;
    End If;
    Begin
      Select 1
      Into n_Count
      From 临床出诊序号控制
      Where 记录id = 记录id_In And 序号 = n_号序 And Nvl(挂号状态, 0) Not In (0, 5);
    Exception
      When Others Then
        n_Count := 0;
    End;
    If n_Count = 1 Then
      If n_启用分时段 = 0 And Nvl(n_序号控制, 0) = 1 Then
        n_号序 := Null;
      End If;
      If n_启用分时段 = 1 And Nvl(n_序号控制, 0) = 1 Then
        v_Err_Msg := '当前序号已被使用，请重新选择一个序号！';
        Raise Err_Item;
      End If;
    End If;
  
    If n_启用分时段 = 0 And Nvl(n_序号控制, 0) = 1 And n_号序 Is Null And 锁定类型_In <> 2 Then
      Select Nvl(Min(序号), 0)
      Into n_号序
      From 临床出诊序号控制
      Where 记录id = 记录id_In And Nvl(挂号状态, 0) = 5 And 操作员姓名 = v_操作员姓名 And 工作站名称 = v_机器名;
      If n_号序 = 0 Then
        Select Nvl(Min(序号), 0) Into n_号序 From 临床出诊序号控制 Where 记录id = 记录id_In And Nvl(挂号状态, 0) = 0;
        If n_号序 = 0 Then
          Select Nvl(Max(序号), 0) + 1 Into n_号序 From 临床出诊序号控制 Where 记录id = 记录id_In;
        End If;
      End If;
    End If;
  
    If n_启用分时段 = 1 And 锁定类型_In <> 2 Then
      If 操作方式_In > 1 And Nvl(n_序号控制, 0) = 0 Then
        --规则:预约时段序号||预约数
        If Nvl(n_预约总数, 0) = 0 Then
          v_Temp := Nvl(n_限约数, 0);
          v_Temp := LTrim(RTrim(v_Temp));
          v_Temp := LPad(Nvl(n_预约总数, 0) + 1, Length(v_Temp), '0');
          v_Temp := n_预约时段序号 || v_Temp;
          n_号序 := To_Number(v_Temp);
        Else
          n_号序 := n_预约总数 + 1;
        End If;
      End If;
    End If;
  
    If Nvl(n_序号控制, 0) = 1 Or (操作方式_In > 1 And n_启用分时段 = 1) Or 加入序号状态_In = 1 Then
      --锁定序号的处理
      Begin
        Select 操作员姓名, 工作站名称
        Into v_序号操作员, v_序号机器名
        From 临床出诊序号控制
        Where 挂号状态 = 5 And 记录id = 记录id_In And 序号 = n_号序;
        n_序号锁定 := 1;
      Exception
        When Others Then
          v_序号操作员 := Null;
          v_序号机器名 := Null;
          n_序号锁定   := 0;
      End;
      If n_序号锁定 = 0 Then
        If n_启用分时段 = 1 And n_序号控制 = 0 Then
          Insert Into 临床出诊序号控制
            (记录id, 序号, 预约顺序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 类型, 名称, 操作员姓名, 备注)
            Select 记录id_In, n_预约时段序号, n_预约顺序号, d_时段开始时间, d_时段终止时间, 1, Decode(操作方式_In, 1, 0, 1), Decode(操作方式_In, 2, 2, 1),
                   1, 合作单位_In, v_操作员姓名, n_号序
            From Dual;
        Else
          Update 临床出诊序号控制
          Set 挂号状态 = Decode(操作方式_In, 2, 2, 1), 操作员姓名 = v_操作员姓名
          Where 记录id = 记录id_In And 序号 = n_号序;
        End If;
        If Sql%RowCount = 0 Then
          Begin
            If n_启用分时段 = 1 Then
              --分时段
              If n_序号控制 = 1 Then
                --序号控制
                Select Max(终止时间) Into d_终止时间 From 临床出诊序号控制 Where 记录id = 记录id_In;
                If Sysdate > d_终止时间 Then
                  d_终止时间 := Sysdate;
                End If;
                Insert Into 临床出诊序号控制
                  (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 类型, 名称, 操作员姓名)
                  Select 记录id_In, n_号序, d_终止时间, d_终止时间, 1, Decode(操作方式_In, 1, 0, 1), Decode(操作方式_In, 2, 2, 1), 1,
                         合作单位_In, v_操作员姓名
                  From Dual;
              Else
                --分时段,非序号控制
                Null;
              End If;
            Else
              --不分时段
              Insert Into 临床出诊序号控制
                (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 类型, 名称, 操作员姓名)
                Select 记录id_In, n_号序, 开始时间, 终止时间, 1, Decode(操作方式_In, 1, 0, 1), Decode(操作方式_In, 2, 2, 1), 1, 合作单位_In,
                       v_操作员姓名
                From 临床出诊序号控制
                Where 记录id = 记录id_In And 序号 = 1;
            End If;
          Exception
            When Others Then
              v_Err_Msg := '序号' || n_号序 || '已被使用,请重新选择一个序号.';
              Raise Err_Item;
          End;
        End If;
      Else
        If v_操作员姓名 <> v_序号操作员 Or v_机器名 <> v_序号机器名 Then
          v_Err_Msg := '序号' || n_号序 || '已被机器' || v_机器名 || '锁定,请重新选择一个序号.';
          Raise Err_Item;
        Else
          Update 临床出诊序号控制
          Set 挂号状态 = Decode(操作方式_In, 2, 2, 1), 锁号时间 = Null
          Where 记录id = 记录id_In And 序号 = n_号序 And 挂号状态 = 5 And 操作员姓名 = v_操作员姓名 And 工作站名称 = v_机器名;
        End If;
      End If;
    End If;
  
    --锁定单据不产生任何 费用
    If 操作方式_In <> 2 And 锁定类型_In <> 1 And Nvl(记帐费用_In, 0) = 0 Then
      --挂号,预约挂号已经扣款部分
      n_预交id := 预交id_In;
      If Nvl(n_预交id, 0) = 0 Then
        Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      End If;
      n_结算合计 := 0;
      If 保险结算_In Is Not Null Then
        --各个保险结算
        v_结算内容 := 保险结算_In || '||';
        n_结算合计 := 0;
        While v_结算内容 Is Not Null Loop
          v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
          v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
          n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
          If Nvl(n_结算金额, 0) <> 0 Then
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 记录状态, 病人id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算性质)
            Values
              (n_预交id, 4, 单据号_In, 1, Decode(病人id_In, 0, Null, 病人id_In), '保险结算', v_结算方式, d_登记时间, v_操作员编号, v_操作员姓名,
               n_结算金额, n_结帐id, n_组id, n_结帐id, 4);
            Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          End If;
          n_结算合计 := Nvl(n_结算合计, 0) + Nvl(n_结算金额, 0);
          v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
        End Loop;
      End If;
    
      If Nvl(冲预交_In, 0) <> 0 Then
        --处理总预交
        n_结算合计 := n_结算合计 + Nvl(冲预交_In, 0);
        n_预交金额 := 冲预交_In;
        For r_Deposit In c_Deposit(病人id_In, v_冲预交病人ids) Loop
          n_结算金额 := Case
                      When r_Deposit.金额 - n_预交金额 < 0 Then
                       r_Deposit.金额
                      Else
                       n_预交金额
                    End;
          If r_Deposit.结帐id = 0 Then
            --第一次冲预交(填上结帐ID,金额为0)
            Update 病人预交记录 Set 冲预交 = 0, 结帐id = n_结帐id, 结算性质 = 4 Where ID = r_Deposit.原预交id;
          End If;
          --冲上次剩余额
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 预交类别, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名,
             操作员编号, 冲预交, 结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 预交类别, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行,
                   单位帐号, d_登记时间, v_操作员姓名, v_操作员编号, n_结算金额, n_结帐id, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, n_结帐id, 4
            From 病人预交记录
            Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
        
          --更新病人预交余额
          Update 病人余额
          Set 预交余额 = Nvl(预交余额, 0) - n_结算金额
          Where 病人id = r_Deposit.病人id And 性质 = 1 And 类型 = Nvl(1, 2)
          Returning 预交余额 Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 病人余额 (病人id, 预交余额, 性质, 类型) Values (r_Deposit.病人id, -1 * n_结算金额, 1, 1);
            n_返回值 := -1 * n_结算金额;
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 病人余额
            Where 病人id = r_Deposit.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
          End If;
        
          --检查是否已经处理完
          If r_Deposit.金额 <= n_结算金额 Then
            n_预交金额 := n_预交金额 - r_Deposit.金额;
          Else
            n_预交金额 := 0;
          End If;
          If n_预交金额 = 0 Then
            Exit;
          End If;
        End Loop;
        If n_预交金额 > 0 Then
          v_Err_Msg := '预交余额不够支付本次支付金额,不能继续操作！';
          Raise Err_Item;
        End If;
      End If;
      --剩余款项,用指定结算方支付
      n_结算金额 := Nvl(n_实收金额合计, 0) - Nvl(n_结算合计, 0);
      If Nvl(n_结算金额, 0) < 0 Then
        v_Err_Msg := '挂号的相关结算金额超出了当前实结金额,不能继续操作！';
        Raise Err_Item;
      End If;
    
      If Nvl(n_结算金额, 0) <> 0 Or (Nvl(n_结算金额, 0) = 0 And Nvl(冲预交_In, 0) = 0) Then
        If 结算方式_In Is Null Then
          v_Err_Msg := '未传入指定的结算方式,不能继续操作！';
          Raise Err_Item;
        End If;
      
        If Nvl(预交id_In, 0) <> 0 Then
          --传入的预交ID_In主要是为了解决三方交易,如果医保结算站用了该ID,需要用新的ID进行更新,三方交易用转入的ID
          Update 病人预交记录 Set ID = n_预交id Where ID = Nvl(预交id_In, 0);
          n_预交id := Nvl(预交id_In, 0);
        End If;
        If Instr(结算方式_In, ',') = 0 Then
          --只传入一种结算方式的
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          Insert Into 病人预交记录
            (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
             合作单位, 结算性质, 结算号码)
          Values
            (n_预交id, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(结算方式_In, v_现金), Nvl(n_结算金额, 0), 登记时间_In,
             v_操作员编号, v_操作员姓名, n_结帐id, '挂号收费', n_组id, 卡类别id_In, Null, 支付卡号_In, 交易流水号_In, 交易说明_In, 合作单位_In, 4, v_结算号码);
        Else
          v_结算内容     := 结算方式_In || '|'; --以空格分开以|结尾,没有结算号码的
          n_Exists       := 0;
          v_结算方式记录 := '';
          While v_结算内容 Is Not Null Loop
            v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '|') - 1);
            v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1);
          
            v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
            n_单笔金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1));
          
            v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
            v_结算号码 := Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1);
          
            v_当前结算   := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
            n_三方卡标志 := To_Number(v_当前结算);
          
            If Instr('|' || v_结算方式记录 || '|', '|' || Nvl(v_结算方式, v_现金) || '|') <> 0 Then
              v_Err_Msg := '使用了重复的结算方式,请检查!';
              Raise Err_Item;
            Else
              v_结算方式记录 := v_结算方式记录 || '|' || Nvl(v_结算方式, v_现金);
            End If;
          
            If n_三方卡标志 = 0 Then
              Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
              Insert Into 病人预交记录
                (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号,
                 交易说明, 合作单位, 结算性质, 结算号码)
              Values
                (n_预交id, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(v_结算方式, v_现金), Nvl(n_单笔金额, 0), 登记时间_In,
                 v_操作员编号, v_操作员姓名, n_结帐id, '挂号收费', n_组id, Null, Null, Null, Null, Null, 合作单位_In, 4, v_结算号码);
            Else
              If n_Exists = 1 Then
                v_Err_Msg := '目前挂号仅支持一种三方结算方式,不能继续操作！';
                Raise Err_Item;
              End If;
              Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
              Insert Into 病人预交记录
                (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号,
                 交易说明, 合作单位, 结算性质, 结算号码)
              Values
                (n_预交id, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(v_结算方式, v_现金), Nvl(n_单笔金额, 0), 登记时间_In,
                 v_操作员编号, v_操作员姓名, n_结帐id, '挂号收费', n_组id, 卡类别id_In, Null, 支付卡号_In, 交易流水号_In, 交易说明_In, 合作单位_In, 4, v_结算号码);
              n_Exists := 1;
            End If;
          
            v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '|') + 1);
          End Loop;
        End If;
      End If;
    
      --更新人员缴款数据
    
      For v_缴款 In (Select 结算方式, Sum(Nvl(a.冲预交, 0)) As 冲预交
                   From 病人预交记录 A
                   Where a.结帐id = n_结帐id And Mod(a.记录性质, 10) <> 1 And Nvl(病人id, 0) = Nvl(病人id_In, 0)
                   Group By 结算方式) Loop
      
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + Nvl(v_缴款.冲预交, 0)
        Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = v_缴款.结算方式
        Returning 余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (v_操作员姓名, v_缴款.结算方式, 1, Nvl(v_缴款.冲预交, 0));
          n_返回值 := Nvl(v_缴款.冲预交, 0);
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = v_操作员姓名 And 结算方式 = v_缴款.结算方式 And 性质 = 1 And Nvl(余额, 0) = 0;
        End If;
      End Loop;
    End If;
  
    --处理挂号记录
    If 锁定类型_In = 2 Then
      Begin
        Select ID Into n_挂号id From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
      Exception
        When Others Then
          Null;
      End;
    Else
      Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
    End If;
  
    Update 病人挂号记录
    Set 记录性质 = Decode(操作方式_In, 2, 2, 1), 记录状态 = Decode(锁定类型_In, 1, 0, 1), 门诊号 = r_Pati.门诊号, 操作员姓名 = v_操作员姓名,
        操作员编号 = v_操作员编号, 预约 = Decode(操作方式_In, 1, 0, 1),
        接收人 = Decode(锁定类型_In, 1, Null, Decode(操作方式_In, 2, Null, v_操作员姓名)),
        接收时间 = Case 锁定类型_In
                  When 1 Then
                   Null
                  Else
                   Case 操作方式_In
                     When 2 Then
                      Null
                     Else
                      d_登记时间
                   End
                End, 交易流水号 = Nvl(交易流水号_In, 交易流水号), 交易说明 = Nvl(交易说明_In, 交易说明), 合作单位 = Nvl(合作单位_In, 合作单位),
        预约操作员 = Decode(操作方式_In, 1, Nvl(预约操作员, Null), Nvl(预约操作员, v_操作员姓名)),
        预约操作员编号 = Decode(操作方式_In, 1, Nvl(预约操作员编号, Null), Nvl(预约操作员编号, v_操作员编号)), 出诊记录id = 记录id_In
    Where ID = n_挂号id;
    If Sql%NotFound Then
      Begin
        Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = r_Pati.付款方式 And Rownum < 2;
      Exception
        When Others Then
          v_付款方式 := Null;
      End;
      Insert Into 病人挂号记录
        (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 预约时间, 操作员编号,
         操作员姓名, 复诊, 号序, 预约, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 医疗付款方式, 预约操作员, 预约操作员编号, 出诊记录id)
      Values
        (n_挂号id, 单据号_In, Decode(操作方式_In, 2, 2, 1), Decode(锁定类型_In, 1, 0, 1), r_Pati.病人id, r_Pati.门诊号, r_Pati.姓名,
         r_Pati.性别, r_Pati.年龄, 号码_In, n_急诊, v_诊室, Null, n_科室id, v_医生姓名, 0, Null, d_登记时间, 发生时间_In,
         Case When(Nvl(操作方式_In, 0)) = 1 Then Null Else 发生时间_In End, v_操作员编号, v_操作员姓名, 0, n_号序, Decode(操作方式_In, 1, 0, 1),
         Decode(操作方式_In, 2, Null, v_操作员姓名), Decode(操作方式_In, 2, To_Date(Null), d_登记时间), 交易流水号_In, 交易说明_In, 合作单位_In,
         v_付款方式, Decode(操作方式_In, 1, Null, v_操作员姓名), Decode(操作方式_In, 1, Null, v_操作员编号), 记录id_In);
    End If;
    --锁定单据不能产生队列
    If 锁定类型_In <> 1 Then
      n_预约生成队列 := 0;
      If 操作方式_In > 1 Then
        n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
      End If;
      --挂号和收费的预约都直接进入队列(收费预约缺少接收过程,所以直接和挂号一样直接进入队列)
      If 操作方式_In <> 2 Or n_预约生成队列 = 1 Then
        If Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113)) <> 0 Then
          --排队叫号模式:-0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站
          If Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113)) = 0 Or n_预约生成队列 = 1 Then
            n_分时点显示 := Nvl(Zl_To_Number(zl_GetSysParameter(270)), 0);
            If Nvl(操作方式_In, 0) > 1 And n_分时点显示 = 1 And n_启用分时段 = 1 Then
              n_分时点显示 := 1;
            Else
              n_分时点显示 := Null;
            End If;
            --产生队列
            --.按”执行部门” 的方式生成队列
            v_队列名称 := n_科室id;
            v_排队号码 := Zlgetnextqueue(n_科室id, n_挂号id, 号码_In || '|' || 号序_In);
            --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)
            v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
            --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)
            d_排队时间 := Zl_Get_Queuedate(n_挂号id, 号码_In, 号序_In, d_Date);
            --  队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,v_排队标记,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In, 排队时间_In
            Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, n_科室id, v_排队号码, Null, r_Pati.姓名, r_Pati.病人id, v_诊室, v_医生姓名, d_排队时间,
                             预约方式_In, n_分时点显示, v_排队序号);
          End If;
        End If;
      End If;
    
      If Nvl(操作方式_In, 0) = 1 And Nvl(记帐费用_In, 0) = 0 Then
        --处理票据使用情况
        If 票据号_In Is Not Null Then
          Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
          --发出票据
          Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 4, 单据号_In);
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人, 票据金额)
          Values
            (票据使用明细_Id.Nextval, Decode(收费票据_In, 1, 1, 4), 票据号_In, 1, 1, 领用id_In, n_打印id, d_登记时间, v_操作员姓名, 挂号金额合计_In);
          --状态改动
          Update 票据领用记录
          Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
          Where ID = Nvl(领用id_In, 0);
        End If;
        --病人本次就诊(以发生时间为准)
        If Nvl(r_Pati.病人id, 0) <> 0 Then
          Update 病人信息 Set 就诊时间 = 发生时间_In, 就诊状态 = 1, 就诊诊室 = v_诊室 Where 病人id = r_Pati.病人id;
        End If;
      End If;
    End If;
    --病人挂号汇总
    --解锁单据时不用再对汇总单据进行统计了 在锁定单据时已经进行了汇总
    If 锁定类型_In <> 2 Then
      --操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
      --是否为预约接收:0-非预约挂号; 1-预约挂号,2-预约接收;3-收费预约
      --调用zl_third_lockno进行锁号，不建议使用本过程锁号
      n_预约 := Case
                When Nvl(操作方式_In, 0) = 1 Then
                 0
                When Nvl(操作方式_In, 0) = 2 Then
                 1
                When Nvl(操作方式_In, 0) = 3 Then
                 3
                Else
                 0
              End;
      Zl_病人挂号汇总_Update(v_医生姓名, n_医生id, n_项目id, n_科室id, 发生时间_In, n_预约, 号码_In, 0, 记录id_In);
    End If;
    
    If 锁定类型_In <> 1 Then
      --消息推送,锁号时不发送信息
      Begin
        Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
          Using 1, n_挂号id;
      Exception
        When Others Then
          Null;
      End;
      b_Message.Zlhis_Regist_001(n_挂号id, 单据号_In);
    End If;
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, '[ZLSOFT]+' || v_Err_Msg || '+[ZLSOFT]');
    When Err_Special Then
      Raise_Application_Error(-20105, '[ZLSOFT]+' || v_Err_Msg || '+[ZLSOFT]');
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End;

Begin
  n_出诊记录id := 出诊记录id_In;
  v_Para       := zl_GetSysParameter(256);
  n_挂号模式   := Substr(v_Para, 1, 1);
  Begin
    d_启用时间 := To_Date(Substr(v_Para, 3), 'yyyy-mm-dd hh24:mi:ss');
  Exception
    When Others Then
      d_启用时间 := Null;
  End;

  d_发生时间 := 发生时间_In;
  If d_发生时间 Is Null Then
    d_发生时间 := Sysdate;
  End If;

  If 付款方式_In Is Null Then
    Select Max(名称) Into v_付款方式 From 医疗付款方式 Where 缺省标志 = 1;
  Else
    Select Max(名称) Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In;
    If v_付款方式 Is Null Then
      v_付款方式 := 付款方式_In;
    End If;
  End If;

  If Sysdate - 10 > Nvl(d_启用时间, Sysdate - 30) Then
    If n_挂号模式 = 1 And Nvl(发生时间_In, Sysdate) > Nvl(d_启用时间, Sysdate - 30) And n_出诊记录id Is Null Then
      v_Err_Msg := '系统当前处于出诊表排班模式，传入的参数无法确定挂号安排，请重试！';
      Raise Err_Item;
    End If;
  Else
    If n_挂号模式 = 1 And Nvl(发生时间_In, Sysdate) > Nvl(d_启用时间, Sysdate - 30) And n_出诊记录id Is Null Then
      Begin
        Select a.Id
        Into n_出诊记录id
        From 临床出诊记录 A, 临床出诊号源 B
        Where a.号源id = b.Id And b.号码 = 号码_In And Nvl(发生时间_In, Sysdate) Between a.开始时间 And a.终止时间;
      Exception
        When Others Then
          v_Err_Msg := '系统当前处于出诊表排班模式，传入的参数无法确定挂号安排，请重试！';
          Raise Err_Item;
      End;
    End If;
  End If;

  If n_出诊记录id Is Not Null Then
    --出诊表排班模式
    Zl_三方机构挂号_出诊_Insert(n_出诊记录id, 操作方式_In, 病人id_In, 号码_In, 号序_In, 单据号_In, 票据号_In, 结算方式_In, 摘要_In, 发生时间_In, 登记时间_In,
                        合作单位_In, 挂号金额合计_In, 领用id_In, 收费票据_In, 交易流水号_In, 交易说明_In, 预约方式_In, 预交id_In, 卡类别id_In, 加入序号状态_In,
                        是否自助设备_In, 结帐id_In, 锁定类型_In, 保险结算_In, 冲预交_In, 支付卡号_In,费别_In, 冲预交病人ids_In, 机器名_In, 更新年龄_In, 购买病历_In,
                        记帐费用_In, 付款方式_In);
  Else
    v_冲预交病人ids := Nvl(冲预交病人ids_In, 病人id_In);
    v_Temp          := zl_GetSysParameter(256);
    If v_Temp Is Null Or Substr(v_Temp, 1, 1) = '0' Then
      Null;
    Else
      Begin
        d_启用时间 := To_Date(Substr(v_Temp, 3), 'YYYY-MM-DD hh24:mi:ss');
      Exception
        When Others Then
          Null;
      End;
      If 发生时间_In > d_启用时间 Then
        v_Err_Msg := '当前挂号的发生时间' || To_Char(发生时间_In, 'yyyy-mm-dd hh24:mi:ss') || '已经启用了出诊表排班模式,不能再使用计划排班模式挂号!';
        Raise Err_Item;
      End If;
    End If;
    If 费别_In Is Null Then
      Select Zl_Custom_Getpatifeetype(1, 病人id_In) Into v_费别 From Dual;
    Else
      v_费别 := 费别_In;
    End If;
    If v_费别 Is Null Then
      n_屏蔽费别 := 1;
      Select 名称 Into v_费别 From 费别 Where 缺省标志 = 1 And Rownum < 2;
    End If;
    Update 病人信息 Set 费别 = v_费别 Where 病人id = 病人id_In;
  
    If 更新年龄_In = 1 Then
      Select Zl_Age_Calc(病人id_In) Into v_年龄 From Dual;
      If v_年龄 Is Not Null Then
        Update 病人信息 Set 年龄 = v_年龄 Where 病人id = 病人id_In;
      End If;
    End If;
    --获取当前机器名称
    If 机器名_In Is Not Null Then
      v_机器名 := 机器名_In;
    Else
      Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
    End If;
    n_实收金额合计 := 0;
    Select Count(*) + 1
    Into n_挂号序号
    From 病人挂号记录
    Where 号别 = 号码_In And 登记时间 Between Trunc(发生时间_In) And Trunc(发生时间_In + 1) - 1 / 24 / 60 / 60;
    --Begin
    v_Temp           := Nvl(zl_GetSysParameter('病人同科限挂N个号', 1111), '0|0') || '|';
    n_同科限号数     := To_Number(Substr(v_Temp, 1, Instr(v_Temp, '|') - 1));
    n_同科限约数     := To_Number(Nvl(zl_GetSysParameter('病人同科限约N个号', 1111), '0'));
    n_病人预约科室数 := To_Number(Nvl(zl_GetSysParameter('病人预约科室数', 1111), '0'));
    n_病人挂号科室数 := To_Number(Nvl(zl_GetSysParameter('病人挂号科室限制', 1111), '0'));
    n_专家号挂号限制 := To_Number(Nvl(zl_GetSysParameter('专家号挂号限制'), '0'));
    n_专家号预约限制 := To_Number(Nvl(zl_GetSysParameter('专家号预约限制'), '0'));
  
    --部门ID,部门名称;人员ID,人员编号,人员姓名
    v_Temp := Zl_Identity(0);
    If Nvl(v_Temp, ' ') = ' ' Then
      v_Err_Msg := '当前操作人员未设置对应的人员关系,不能继续。';
      Raise Err_Item;
    End If;
  
    If 登记时间_In Is Null Then
      d_登记时间 := Sysdate;
    Else
      d_登记时间 := 登记时间_In;
    End If;
    If Trunc(Sysdate) > Trunc(发生时间_In) Then
      v_Err_Msg := '不能挂以前的号(' || To_Char(发生时间_In, 'yyyy-mm-dd') || ')。';
      Raise Err_Item;
    End If;
    n_开单部门id := To_Number(Zl_操作员(0, v_Temp));
    v_操作员编号 := Zl_操作员(1, v_Temp);
    v_操作员姓名 := Zl_操作员(2, v_Temp);
    n_组id       := Zl_Get组id(v_操作员姓名);
  
    --支付宝并发提交检查
    Select Nvl(Max(1), 0)
    Into n_Exists
    From 病人挂号记录
    Where 病人id = 病人id_In And 号别 = 号码_In And 号序 = 号序_In And 操作员姓名 = v_操作员姓名 And Nvl(n_出诊记录id, 0) = Nvl(出诊记录id, 0) And
          登记时间 > Sysdate - 0.01 And 记录状态 = 1 And 发生时间 = 发生时间_In;
    If n_Exists = 1 Then
      v_Err_Msg := '病人已经挂号,不能重复挂相同的号！';
      Raise Err_Special;
    End If;
  
    If 操作方式_In <> 1 Then
      --预约检查是否添加合作单位控制
      --如果设置了合作单位控制 则
      Begin
        Select ID
        Into n_计划id
        From 挂号安排计划
        Where 号码 = 号码_In And 发生时间_In Between Nvl(生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
              Nvl(失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Rownum < 2
        Order By 生效时间 Desc;
      Exception
        When Others Then
          Select ID Into n_Tmp安排id From 挂号安排 Where 号码 = 号码_In;
      End;
      If Nvl(n_计划id, 0) <> 0 Then
        Select Count(0)
        Into n_合作单位限制
        From 合作单位计划控制
        Where 合作单位 = 合作单位_In And 计划id = n_计划id And Rownum < 2;
      Else
        Select Count(0)
        Into n_合作单位限制
        From 合作单位安排控制
        Where 合作单位 = 合作单位_In And 安排id = n_Tmp安排id And Rownum < 2;
      End If;
    End If;
  
    If 操作方式_In <> 2 Then
      v_诊室 := Zl_诊室(号码_In);
    End If;
    If 操作方式_In <> 2 And 结算方式_In Is Not Null Then
      --检查结算方式是否完备
      Select Count(*) Into n_Count From 结算方式 Where 名称 = Nvl(结算方式_In, 'Lxh') And 性质 In (2, 7, 8);
      If Nvl(卡类别id_In, 0) <> 0 And n_Count = 0 Then
        Select Count(1)
        Into n_Count
        From 医疗卡类别
        Where ID = Nvl(卡类别id_In, 0) And 结算方式 = Nvl(结算方式_In, 'lxh');
      End If;
      If n_Count = 0 Then
        v_Err_Msg := '结算方式(' || 结算方式_In || ')未设置,请在结算方式管理中设置。';
        Raise Err_Item;
      End If;
    End If;
  
    --因为现在有按日编单据号规则,日挂号量不能超过10000次,所以要检查唯一约束。
    Select Count(*) Into n_Count From 门诊费用记录 Where 记录性质 = 4 And 记录状态 In (1, 3) And NO = 单据号_In;
    If n_Count <> 0 Then
      v_Err_Msg := '挂号单据号重复,不能保存！' || Chr(13) || '如果使用了按日顺序编号,当日挂号量不能超过10000人次。';
      Raise Err_Item;
    End If;
  
    Open c_Pati(病人id_In);
    n_Count := 0;
    Begin
      Fetch c_Pati
        Into r_Pati;
    Exception
      When Others Then
        n_Count := -1;
    End;
    If n_Count = -1 Then
      v_Err_Msg := '病人未找到，不能继续。';
      Raise Err_Item;
    End If;
  
    Open c_安排(号码_In, 发生时间_In);
    Begin
      Fetch c_安排
        Into r_安排;
    Exception
      When Others Then
        n_Count := -1;
    End;
    If n_Count = -1 Then
      v_Err_Msg := '该号别没有在' || To_Char(发生时间_In, 'yyyy-mm-dd hh24:mi:ss') || '中进行安排。';
      Raise Err_Item;
    End If;
  
    Select Min(站点) Into v_站点 From 部门表 Where ID = r_安排.科室id;
    v_Pricegrade := Zl_Get_Pricegrade(v_站点, 病人id_In, Null, v_付款方式);
    v_普通等级   := Substr(v_Pricegrade, 1, Instr(v_Pricegrade, '|') - 1);
  
    Select Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六',
                   '周日')
    Into v_星期
    From Dual;
    Begin
      If r_安排.计划id Is Null Then
        Select Max(1) Into n_启用分时段 From 挂号安排时段 Where 安排id = r_安排.Id And 星期 = v_星期 And Rownum < 2;
        Select Decode(To_Char(发生时间_In, 'D'), '1', 周日, '2', 周一, '3', 周二, '4', 周三, '5', 周四, '6', 周五, '7', 周六, Null)
        Into v_时间段
        From 挂号安排
        Where ID = r_安排.Id;
      Else
        Select Max(1)
        Into n_启用分时段
        From 挂号计划时段
        Where 计划id = r_安排.计划id And 星期 = v_星期 And Rownum < 2;
        Select Decode(To_Char(发生时间_In, 'D'), '1', 周日, '2', 周一, '3', 周二, '4', 周三, '5', 周四, '6', 周五, '7', 周六, Null)
        Into v_时间段
        From 挂号安排计划
        Where ID = r_安排.计划id;
      End If;
    Exception
      When Others Then
        n_启用分时段 := 0;
    End;
  
    If v_时间段 Is Not Null And d_启用时间 Is Not Null Then
      --检查是否跨模式挂号安排
      Select To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'),
             To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(终止时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss')
      Into d_检查开始时间, d_检查结束时间
      From 时间段
      Where 时间段 = v_时间段 And 站点 Is Null And 号类 Is Null;
      If d_检查开始时间 > d_检查结束时间 Then
        d_检查结束时间 := d_检查结束时间 + 1;
      End If;
      If d_检查结束时间 > d_启用时间 Then
        --获取出诊记录id
        Begin
          Select a.Id
          Into n_出诊记录id
          From 临床出诊记录 A, 临床出诊号源 B
          Where a.号源id = b.Id And b.号码 = 号码_In And 上班时段 = v_时间段 And 发生时间_In Between 开始时间 And 终止时间;
        Exception
          When Others Then
            n_出诊记录id := Null;
        End;
      End If;
    End If;
  
    --对参数控制进行检查
    --仅在预约不扣款时进行检查
    If 操作方式_In = 2 Then
      If Nvl(n_同科限约数, 0) <> 0 Or Nvl(n_病人预约科室数, 0) <> 0 Then
        n_已约科室 := 0;
        For c_Chkitem In (Select Distinct 执行部门id
                          From 病人挂号记录
                          Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 2 And 预约时间 Between Trunc(发生时间_In) And
                                Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id <> r_安排.科室id) Loop
          n_已约科室 := n_已约科室 + 1;
        End Loop;
        If n_已约科室 >= Nvl(n_病人预约科室数, 0) And Nvl(n_病人预约科室数, 0) > 0 Then
          v_Err_Msg := '同一病人最多同时能预约[' || Nvl(n_病人预约科室数, 0) || ']个科室,不能再预约！';
          Raise Err_Item;
        End If;
      
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 2 And 预约时间 Between Trunc(发生时间_In) And
              Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id = r_安排.科室id;
        If n_Count >= Nvl(n_同科限约数, 0) And Nvl(n_同科限约数, 0) > 0 Then
          v_Err_Msg := '该病人已经在该科室预约了' || n_Count || '次,不能再预约！';
          Raise Err_Item;
        End If;
      End If;
      If Nvl(n_专家号预约限制, 0) <> 0 Then
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 2 And 预约时间 Between Trunc(发生时间_In) And
              Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 号别 = r_安排.号码;
        If n_Count >= Nvl(n_专家号预约限制, 0) And Nvl(n_专家号预约限制, 0) > 0 Then
          v_Err_Msg := '该病人已经超过本号预约限制,不能再预约！';
          Raise Err_Item;
        End If;
      End If;
    Else
      If Nvl(n_同科限号数, 0) <> 0 Or Nvl(n_病人挂号科室数, 0) <> 0 Then
        n_已约科室 := 0;
        For c_Chkitem In (Select Distinct 执行部门id
                          From 病人挂号记录
                          Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 1 And 发生时间 Between Trunc(发生时间_In) And
                                Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id <> r_安排.科室id) Loop
          n_已约科室 := n_已约科室 + 1;
        End Loop;
        If n_已约科室 >= Nvl(n_病人挂号科室数, 0) And Nvl(n_病人挂号科室数, 0) > 0 Then
          v_Err_Msg := '同一病人最多同时能挂号[' || Nvl(n_病人挂号科室数, 0) || ']个科室,不能再挂号！';
          Raise Err_Item;
        End If;
      
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 1 And 发生时间 Between Trunc(发生时间_In) And
              Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id = r_安排.科室id;
        If n_Count >= Nvl(n_同科限号数, 0) And Nvl(n_同科限号数, 0) > 0 Then
          v_Err_Msg := '该病人已经在该科室挂号了' || n_Count || '次,不能再挂号！';
          Raise Err_Item;
        End If;
      End If;
      If Nvl(n_专家号挂号限制, 0) <> 0 Then
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 1 And 预约时间 Between Trunc(发生时间_In) And
              Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 号别 = r_安排.号码;
        If n_Count >= Nvl(n_专家号挂号限制, 0) And Nvl(n_专家号挂号限制, 0) > 0 Then
          v_Err_Msg := '该病人已经超过本号挂号限制,不能再挂号！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  
    d_Date         := Null;
    d_时段开始时间 := Null;
  
    If Nvl(r_安排.限号数, 0) >= 0 Or r_安排.限号数 Is Null Then
    
      Select Nvl(Sum(Nvl(b.已挂数, 0)), 0), Nvl(Sum(Nvl(b.其中已接收, 0)), 0), Nvl(Sum(Nvl(b.已约数, 0)), 0)
      Into n_已挂数, n_其中已接收, n_已约数
      From 挂号安排 A, 病人挂号汇总 B
      Where a.科室id = b.科室id And a.项目id = b.项目id And a.号码 = 号码_In And b.日期 Between Trunc(发生时间_In) And
            Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And (a.号码 = b.号码 Or b.号码 Is Null) And Nvl(a.医生id, 0) = Nvl(b.医生id, 0) And
            Nvl(a.医生姓名, '医生') = Nvl(b.医生姓名, '医生');
    
      If n_启用分时段 = 1 Then
        If Nvl(r_安排.序号控制, 0) = 1 Then
          If Nvl(是否自助设备_In, 0) = 0 Then
            If r_安排.计划id Is Null Then
              Select Count(*), Max(开始时间)
              Into n_Count, d_时段开始时间
              From 挂号安排时段
              Where 安排id = r_安排.Id And 星期 = v_星期 And 序号 = Nvl(号序_In, 0);
            Else
              Select Count(*), Max(开始时间)
              Into n_Count, d_时段开始时间
              From 挂号计划时段
              Where 计划id = r_安排.计划id And 星期 = v_星期 And 序号 = Nvl(号序_In, 0);
            End If;
            v_Temp := '挂号';
            If 操作方式_In > 1 Then
              v_Temp := '预约挂号';
            End If;
          
            If n_Count = 0 Then
              v_Err_Msg := '号别为' || 号码_In || '的挂号安排中不存在序号为' || Nvl(号序_In, 0) || '的安排,不能再' || v_Temp || '！';
              Raise Err_Item;
            End If;
          End If;
          --过点的,不能选择挂号
          If Trunc(Sysdate) = Trunc(发生时间_In) Then
            --挂当天的号
            v_Temp := To_Char(Sysdate, 'yyyy-mm-dd') || ' ';
            If r_安排.计划id Is Null Then
              For v_时段 In (Select To_Date(v_Temp || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                  To_Date(To_Char(Sysdate + Decode(Sign(开始时间 - 结束时间), 1, 1, 0), 'yyyy-mm-dd') || ' ' ||
                                           To_Char(结束时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 结束时间, 限制数量, 是否预约
                           From 挂号安排时段
                           Where 安排id = r_安排.Id And 星期 = v_星期 And 序号 = Nvl(号序_In, 0)) Loop
                If Sysdate > v_时段.结束时间 Then
                  v_Err_Msg := '号别为' || 号码_In || '及号序为' || Nvl(号序_In, 0) || '的安排,已经超过时点,不能再' || v_Temp || '！';
                  Raise Err_Item;
                End If;
              End Loop;
            Else
              For v_时段 In (Select To_Date(v_Temp || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                  To_Date(To_Char(Sysdate + Decode(Sign(开始时间 - 结束时间), 1, 1, 0), 'yyyy-mm-dd') || ' ' ||
                                           To_Char(结束时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 结束时间, 限制数量, 是否预约
                           From 挂号计划时段
                           Where 计划id = r_安排.计划id And 星期 = v_星期 And 序号 = Nvl(号序_In, 0)) Loop
                If Sysdate > v_时段.结束时间 Then
                  v_Err_Msg := '号别为' || 号码_In || '及号序为' || Nvl(号序_In, 0) || '的安排,已经超过时点,不能再' || v_Temp || '！';
                  Raise Err_Item;
                End If;
              End Loop;
            End If;
          End If;
        Elsif 操作方式_In > 1 Then
          --未启用序号的,需要检查预约的情况
          n_Count := 0;
          If r_安排.计划id Is Null Then
            For v_时段 In (Select 序号, 开始时间, 结束时间, 限制数量, 是否预约
                         From 挂号安排时段
                         Where 安排id = r_安排.Id And 星期 = v_星期 And
                               (('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                               Decode(Sign(开始时间 - 结束时间 - 1 / 24 / 60 / 60), 1,
                                        '3000-01-09 ' || To_Char(开始时间, 'HH24:MI:SS'),
                                        '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS')) And
                               '3000-01-10 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS')) Or
                               ('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                               '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS') And
                               Decode(Sign(开始时间 - 结束时间 - 1 / 24 / 60 / 60), 1,
                                        '3000-01-11 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'),
                                        '3000-01-10 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'))))) Loop
              n_预约时段序号 := v_时段.序号;
              d_时段开始时间 := v_时段.开始时间;
            
              Select Count(*), Max(序号)
              Into n_Count, n_预约总数
              From 挂号序号状态
              Where 号码 = 号码_In And 日期 = 发生时间_In And 状态 Not In (4, 5);
            
              If Nvl(n_Count, 0) > Nvl(v_时段.限制数量, 0) And 锁定类型_In <> 2 Then
                v_Err_Msg := '号别为' || 号码_In || '的挂号安排中在' || To_Char(v_时段.开始时间, 'hh24:mi:ss') || '至' ||
                             To_Char(v_时段.结束时间, 'hh24:mi:ss') || '最多只能预约' || Nvl(v_时段.限制数量, 0) || '人,不能再进行预约挂号！';
                Raise Err_Item;
              End If;
              n_Count := 1;
            End Loop;
          Else
            For v_时段 In (Select 序号, 开始时间, 结束时间, 限制数量, 是否预约
                         From 挂号计划时段
                         Where 计划id = r_安排.计划id And 星期 = v_星期 And
                               (('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                               Decode(Sign(开始时间 - 结束时间 - 1 / 24 / 60 / 60), 1,
                                        '3000-01-09 ' || To_Char(开始时间, 'HH24:MI:SS'),
                                        '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS')) And
                               '3000-01-10 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS')) Or
                               ('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                               '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS') And
                               Decode(Sign(开始时间 - 结束时间 - 1 / 24 / 60 / 60), 1,
                                        '3000-01-11 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'),
                                        '3000-01-10 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'))))) Loop
              n_预约时段序号 := v_时段.序号;
              d_时段开始时间 := v_时段.开始时间;
            
              Select Count(*), Max(序号)
              Into n_Count, n_预约总数
              From 挂号序号状态
              Where 号码 = 号码_In And 日期 = 发生时间_In And 状态 Not In (4, 5);
            
              If Nvl(n_Count, 0) > Nvl(v_时段.限制数量, 0) And 锁定类型_In <> 2 Then
                v_Err_Msg := '号别为' || 号码_In || '的挂号安排中在' || To_Char(v_时段.开始时间, 'hh24:mi:ss') || '至' ||
                             To_Char(v_时段.结束时间, 'hh24:mi:ss') || '最多只能预约' || Nvl(v_时段.限制数量, 0) || '人,不能再进行预约挂号！';
                Raise Err_Item;
              End If;
              n_Count := 1;
            End Loop;
          End If;
        
          If n_Count = 0 Then
            v_Err_Msg := '号别为' || 号码_In || '的挂号安排中没有相关的安排计划(' || To_Char(发生时间_In, 'YYYY-mm-dd HH24:MI:SS') ||
                         '),不能进行预约挂号！';
            Raise Err_Item;
          End If;
        End If;
      End If;
    End If;
  
    If 操作方式_In = 1 And 锁定类型_In <> 2 Then
      --挂号规则:
      --  已挂数不能大于限号数
      If n_已挂数 >= Nvl(r_安排.限号数, 0) And r_安排.限号数 Is Not Null Then
        v_Err_Msg := '该号别今天已达到限号数 ' || Nvl(r_安排.限号数, 0) || '不能再挂号！';
        Raise Err_Item;
      End If;
    End If;
  
    If 操作方式_In > 1 Then
      --预约的相关检查
      --规则:
      --   1.已限约不能超过限约数
      --   2.检查是否启用时段的
      If n_已约数 >= Nvl(r_安排.限约数, 0) And Nvl(r_安排.限约数, 0) <> 0 And r_安排.限约数 Is Not Null And 锁定类型_In <> 2 Then
        v_Err_Msg := '该号别已达到限约数 ' || Nvl(r_安排.限约数, 0) || '不能再预约挂号！';
        Raise Err_Item;
      End If;
    End If;
    If n_合作单位限制 > 0 And 操作方式_In <> 1 And 合作单位_In Is Not Null Then
    
      If Nvl(r_安排.序号控制, 0) = 1 And Nvl(号序_In, 0) = 0 Then
        v_Err_Msg := '当前安排使用了序号控制,请确认所需要预约的序号,不能继续。';
        Raise Err_Item;
      End If; --Nvl(r_安排.序号控制, 0) =0
    
      n_序号 := Case
                When Nvl(r_安排.序号控制, 0) = 1 Or n_启用分时段 = 1 And 操作方式_In > 1 Then
                 Nvl(号序_In, 0)
                Else
                 0
              End;
    
      --合作单位限数量模式
      Begin
        If Nvl(n_计划id, 0) <> 0 Then
          Select 0
          Into n_序号
          From 合作单位计划控制
          Where 合作单位 = 合作单位_In And 计划id = n_计划id And
                限制项目 = Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                              '7', '周六', Null) And 数量 <> 0 And 序号 = 0 And Rownum < 2;
        Else
          Select 0
          Into n_序号
          From 合作单位安排控制
          Where 合作单位 = 合作单位_In And 安排id = n_Tmp安排id And
                限制项目 = Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                              '7', '周六', Null) And 数量 <> 0 And 序号 = 0 And Rownum < 2;
        End If;
        n_合作单位限数量模式 := 1;
      Exception
        When Others Then
          n_合作单位限数量模式 := 0;
      End;
      --开放序号检查
      For c_合作单位 In (Select c.序号, 数量
                     From 挂号安排 A, 合作单位安排控制 C
                     Where a.号码 = 号码_In And Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                   '周四', '6', '周五', '7', '周六', Null) = c.限制项目(+) And a.Id = c.安排id And
                           c.合作单位 = 合作单位_In And c.序号 = n_序号 And Not Exists
                      (Select 1
                            From 挂号安排计划 D
                            Where d.安排id = a.Id And d.审核时间 Is Not Null And
                                  发生时间_In Between Nvl(d.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                                  Nvl(d.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')))
                     Union All
                     Select c.序号, 数量
                     From 挂号安排计划 A, 挂号安排 D, 合作单位计划控制 C,
                          (Select Max(a.生效时间) As 生效, 安排id
                            From 挂号安排计划 A, 挂号安排 B
                            Where a.安排id = b.Id And a.审核时间 Is Not Null And
                                  发生时间_In Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                                  Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) And b.号码 = 号码_In
                            Group By 安排id) E
                     Where a.安排id = d.Id And a.审核时间 Is Not Null And d.号码 = 号码_In And a.安排id = e.安排id And
                           Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) =
                           Nvl(e.生效, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                           Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) = c.限制项目(+) And a.Id = c.计划id And c.合作单位 = 合作单位_In And c.序号 = n_序号 And
                           发生时间_In Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                           Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd'))) Loop
      
        If Nvl(r_安排.序号控制, 0) = 1 And c_合作单位.序号 = n_序号 And n_合作单位限数量模式 = 0 Then
          n_是否开放 := 1;
          Exit;
        Elsif (Nvl(r_安排.序号控制, 0) = 0 And c_合作单位.序号 = n_序号) Or n_合作单位限数量模式 = 1 Then
          Begin
            Select Nvl(已约数, 0)
            Into n_预约数量
            From 合作单位挂号汇总
            Where 合作单位 = 合作单位_In And 日期 = Trunc(发生时间_In) And 号码 = 号码_In;
          Exception
            When Others Then
              n_预约数量 := 0;
          End;
          If c_合作单位.数量 <= n_预约数量 And Nvl(c_合作单位.数量, 0) > 0 And 锁定类型_In <> 2 Then
            v_Err_Msg := '该号别已达到限约数 ' || Nvl(c_合作单位.数量, 0) || '不能再预约挂号！';
            Raise Err_Item;
          End If;
          n_是否开放 := 1;
          Exit;
        End If;
      
      End Loop;
    
      If Nvl(n_是否开放, 0) = 0 Then
        v_Err_Msg := '当前序号(' || Nvl(号序_In, 0) || '未开放,不能继续。';
        Raise Err_Item;
      End If;
    End If;
  
    --检查限号数和限约数
    n_行号         := 1;
    n_原项目id     := 0;
    n_原收入项目id := 0;
    n_实收金额合计 := 0;
    If 锁定类型_In <> 1 Then
      If 操作方式_In <> 2 Then
        If Nvl(结帐id_In, 0) = 0 Then
          --这里应该程序传入
          Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
        Else
          n_结帐id := 结帐id_In;
        End If;
      Else
        n_结帐id := Null;
      End If;
    End If;
    n_项目id := r_安排.项目id;
    If Nvl(n_计划id, 0) <> 0 Then
      v_传入 := '1|' || n_计划id;
    Else
      If Nvl(r_安排.Id, 0) <> 0 Then
        v_传入 := '0|' || r_安排.Id;
      End If;
    End If;
    If v_传入 Is Null Then
      v_传入 := '3|' || 号码_In;
    End If;
  
    n_更新项目id := Zl_Custom_Getregeventitem(r_Pati.病人id, r_Pati.姓名, r_Pati.身份证号, r_Pati.出生日期, r_Pati.性别, r_Pati.年龄, v_传入);
    If Nvl(n_更新项目id, 0) <> 0 Then
      n_项目id := n_更新项目id;
    End If;
  
    If Nvl(购买病历_In, 0) = 1 Then
      Begin
        Select 收费细目id Into n_病历费id From 收费特定项目 Where 特定项目 = '病历费';
        v_收费项目ids := n_项目id || ',' || n_病历费id;
      Exception
        When Others Then
          v_Err_Msg := '不能确定病历费,挂号失败!';
          Raise Err_Item;
      End;
    Else
      v_收费项目ids := n_项目id;
    End If;
  
    For c_Item In (Select 1 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, Null As 从属父号,
                          Nvl(a.项目特性, 0) As 急诊
                   From 收费项目目录 A, 收费价目 B, 收入项目 C
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = r_安排.项目id And d_发生时间 Between b.执行日期 And
                         Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And
                         (b.价格等级 = v_普通等级 Or
                         (b.价格等级 Is Null And Not Exists
                          (Select 1
                            From 收费价目
                            Where b.收费细目id = 收费细目id And 价格等级 = v_普通等级 And d_发生时间 Between 执行日期 And
                                  Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')))))
                   Union All
                   Select 2 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, Null As 从属父号, 0 As 急诊
                   From 收费项目目录 A, 收费价目 B, 收入项目 C
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = n_病历费id And d_发生时间 Between b.执行日期 And
                         Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And
                         (b.价格等级 = v_普通等级 Or
                         (b.价格等级 Is Null And Not Exists
                          (Select 1
                            From 收费价目
                            Where b.收费细目id = 收费细目id And 价格等级 = v_普通等级 And d_发生时间 Between 执行日期 And
                                  Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')))))
                   Union All
                   Select 3 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, d.从项数次 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, 1 As 从属父号, 0 As 急诊
                   From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费从属项目 D
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = d.从项id And
                         d.主项id In (Select Column_Value From Table(f_Str2list(v_收费项目ids))) And d_发生时间 Between b.执行日期 And
                         Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And
                         (b.价格等级 = v_普通等级 Or
                         (b.价格等级 Is Null And Not Exists
                          (Select 1
                            From 收费价目
                            Where b.收费细目id = 收费细目id And 价格等级 = v_普通等级 And d_发生时间 Between 执行日期 And
                                  Nvl(终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')))))
                   Order By 性质, 项目编码, 收入编码) Loop
      If c_Item.性质 = 1 Then
        n_急诊 := Nvl(c_Item.急诊, 0);
      End If;
      n_价格父号 := Null;
      If n_原项目id = c_Item.项目id Then
        If n_原收入项目id <> c_Item.收入项目id Then
          n_价格父号 := n_行号;
        End If;
        n_原收入项目id := c_Item.收入项目id;
      End If;
      n_原项目id := c_Item.项目id;
      n_应收金额 := Round(c_Item.数次 * c_Item.单价, 5);
      n_实收金额 := n_应收金额;
      If Nvl(c_Item.屏蔽费别, 0) <> 1 And n_屏蔽费别 = 0 Then
        --打折:
        v_Temp     := Zl_Actualmoney(r_Pati.费别, c_Item.项目id, c_Item.收入项目id, n_应收金额);
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ':') + 1);
        n_实收金额 := Zl_To_Number(v_Temp);
      End If;
      n_实收金额合计 := Nvl(n_实收金额合计, 0) + n_实收金额;
    
      --锁定单据不产生费用
      If 锁定类型_In <> 1 Then
        --产生病人挂号费用(可能单独是或包括病历费用)
        Select 病人费用记录_Id.Nextval Into n_费用id From Dual;
        --:操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
        Insert Into 门诊费用记录
          (ID, 记录性质, 记录状态, 序号, 价格父号, 从属父号, NO, 实际票号, 门诊标志, 加班标志, 附加标志, 发药窗口, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 病人科室id,
           收费类别, 计算单位, 收费细目id, 收入项目id, 收据费目, 付数, 数次, 标准单价, 应收金额, 实收金额, 结帐金额, 结帐id, 记帐费用, 开单部门id, 开单人, 划价人, 执行部门id, 执行人,
           操作员编号, 操作员姓名, 发生时间, 登记时间, 保险大类id, 保险项目否, 保险编码, 统筹金额, 摘要, 结论, 缴款组id)
        Values
          (n_费用id, 4, Decode(操作方式_In, 2, 0, 1), n_行号, n_价格父号, c_Item.从属父号, 单据号_In, 票据号_In, 1, n_急诊, Null,
           Decode(操作方式_In, 2, To_Char(号序_In), v_诊室), r_Pati.病人id, r_Pati.门诊号, r_Pati.付款方式, r_Pati.姓名, r_Pati.性别,
           r_Pati.年龄, r_Pati.费别, r_安排.科室id, c_Item.类别, 号码_In, c_Item.项目id, c_Item.收入项目id, c_Item.收据费目, 1, c_Item.数次,
           c_Item.单价, n_应收金额, n_实收金额, Decode(操作方式_In, 2, Null, Decode(Nvl(记帐费用_In, 0), 1, Null, n_实收金额)),
           Decode(Nvl(记帐费用_In, 0), 1, Null, n_结帐id), Decode(Nvl(记帐费用_In, 0), 1, 1, 0), n_开单部门id, v_操作员姓名,
           Decode(操作方式_In, 2, v_操作员姓名, Null), r_安排.科室id, r_安排.医生姓名, v_操作员编号, v_操作员姓名, 发生时间_In, d_登记时间, Null, 0, Null,
           Null, 摘要_In, 预约方式_In, Decode(操作方式_In, 2, Null, n_组id));
      End If;
      n_行号 := n_行号 + 1;
    
    End Loop;
  
    If Round(Nvl(挂号金额合计_In, 0), 5) <> Round(Nvl(n_实收金额合计, 0), 5) Then
      v_Err_Msg := '本次挂号金额不正确,可能是因为医院调整了价格,请重新获取挂号收费项目的价格,不能继续。';
      Raise Err_Item;
    End If;
  
    If n_启用分时段 = 1 Then
      d_Date := To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(d_时段开始时间, 'hh24:mi:ss'),
                        'yyyy-mm-dd hh24:mi:ss');
    Else
      d_Date := Trunc(发生时间_In);
    End If;
  
    --更新挂号序号状态
    If 锁定类型_In <> 2 Then
      n_号序 := 号序_In;
    End If;
    Begin
      Select 1
      Into n_Count
      From 挂号序号状态
      Where Trunc(日期) = Trunc(发生时间_In) And 号码 = 号码_In And 序号 = n_号序 And 状态 <> 5;
    Exception
      When Others Then
        n_Count := 0;
    End;
    If n_Count = 1 Then
      If n_启用分时段 = 0 And Nvl(r_安排.序号控制, 0) = 1 Then
        n_号序 := Null;
      End If;
      If n_启用分时段 = 1 And Nvl(r_安排.序号控制, 0) = 1 Then
        v_Err_Msg := '当前序号已被使用，请重新选择一个序号！';
        Raise Err_Item;
      End If;
    End If;
    n_Count := 0;
    If n_启用分时段 = 0 And Nvl(r_安排.序号控制, 0) = 1 And n_号序 Is Null And 锁定类型_In <> 2 Then
      If 退号重用_In = 1 Then
        Select Nvl(Max(序号), 0) + 1
        Into n_号序
        From 挂号序号状态
        Where 日期 = Trunc(发生时间_In) And 号码 = r_安排.号码 And 状态 Not In (4, 5);
      Else
        Select Nvl(Max(序号), 0) + 1
        Into n_号序
        From 挂号序号状态
        Where 日期 = Trunc(发生时间_In) And 号码 = r_安排.号码 And 状态 <> 5;
      End If;
    End If;
    If n_启用分时段 = 1 And 锁定类型_In <> 2 Then
    
      If 操作方式_In > 1 And Nvl(r_安排.序号控制, 0) = 0 Then
        --规则:预约时段序号||预约数
        If Nvl(n_预约总数, 0) = 0 Then
          v_Temp := Nvl(r_安排.限约数, 0);
          v_Temp := LTrim(RTrim(v_Temp));
          v_Temp := LPad(Nvl(n_预约总数, 0) + 1, Length(v_Temp), '0');
          v_Temp := n_预约时段序号 || v_Temp;
          n_号序 := To_Number(v_Temp);
        Else
          n_号序 := n_预约总数 + 1;
        End If;
      End If;
    End If;
  
    If Nvl(r_安排.序号控制, 0) = 1 Or (操作方式_In > 1 And n_启用分时段 = 1) Or 加入序号状态_In = 1 Then
      --锁定序号的处理
      Begin
        Select 操作员姓名, 机器名
        Into v_序号操作员, v_序号机器名
        From 挂号序号状态
        Where 状态 = 5 And 号码 = 号码_In And Trunc(日期) = Trunc(d_Date) And 序号 = n_号序;
        n_序号锁定 := 1;
      Exception
        When Others Then
          v_序号操作员 := Null;
          v_序号机器名 := Null;
          n_序号锁定   := 0;
      End;
      If n_序号锁定 = 0 Then
        Update 挂号序号状态
        Set 状态 = Decode(操作方式_In, 2, 2, 1), 预约 = Decode(操作方式_In, 1, 0, 1), 登记时间 = Sysdate
        Where 号码 = 号码_In And 日期 = d_Date And 序号 = n_号序 And 操作员姓名 = v_操作员姓名;
        If Sql%RowCount = 0 Then
          Begin
            Insert Into 挂号序号状态
              (号码, 日期, 序号, 状态, 操作员姓名, 预约, 登记时间)
            Values
              (号码_In, d_Date, n_号序, Decode(操作方式_In, 2, 2, 1), v_操作员姓名, Decode(操作方式_In, 1, 0, 1), Sysdate);
          
            If n_合作单位限制 > 0 And 操作方式_In > 1 And Nvl(n_是否开放, 0) = 1 Then
              Update 合作单位挂号汇总
              Set 已约数 = 已约数 + Decode(操作方式_In, 2, 1, 0), 已接数 = 已接数 + Decode(操作方式_In, 3, 1, 0)
              Where 号码 = 号码_In And 日期 = d_Date And 序号 = n_号序 And 合作单位 = 合作单位_In;
              If Sql%NotFound Then
                Insert Into 合作单位挂号汇总
                  (号码, 日期, 序号, 合作单位, 已约数, 已接数)
                Values
                  (号码_In, d_Date, n_号序, 合作单位_In, Decode(操作方式_In, 1, 0, 1), Decode(操作方式_In, 3, 1, 0));
              End If;
            End If;
          Exception
            When Others Then
              v_Err_Msg := '序号' || n_号序 || '已被使用,请重新选择一个序号.';
              Raise Err_Item;
          End;
        End If;
      Else
        If v_操作员姓名 <> v_序号操作员 Or v_机器名 <> v_序号机器名 Then
          v_Err_Msg := '序号' || n_号序 || '已被自助机' || v_机器名 || '锁定,请重新选择一个序号.';
          Raise Err_Item;
        Else
          Update 挂号序号状态
          Set 状态 = Decode(操作方式_In, 2, 2, 1), 预约 = Decode(操作方式_In, 1, 0, 1), 登记时间 = Sysdate
          Where 号码 = 号码_In And Trunc(日期) = Trunc(d_Date) And 序号 = n_号序 And 状态 = 5 And 操作员姓名 = v_操作员姓名 And 机器名 = v_机器名;
        End If;
      End If;
    End If;
  
    If n_出诊记录id Is Not Null Then
      Update 临床出诊序号控制
      Set 挂号状态 = Decode(操作方式_In, 2, 2, 1), 操作员姓名 = v_操作员姓名
      Where 记录id = n_出诊记录id And 序号 = n_序号;
      If 操作方式_In = 2 Then
        Update 临床出诊记录 Set 已约数 = 已约数 + 1 Where ID = n_出诊记录id;
      Else
        If 操作方式_In <> 1 Then
          Update 临床出诊记录
          Set 已约数 = 已约数 + 1, 已挂数 = 已挂数 + 1, 其中已接收 = 其中已接收 + 1
          Where ID = n_出诊记录id;
        Else
          Update 临床出诊记录 Set 已挂数 = 已挂数 + 1 Where ID = n_出诊记录id;
        End If;
      End If;
    End If;
  
    --锁定单据不产生任何 费用
    If 操作方式_In <> 2 And 锁定类型_In <> 1 And Nvl(记帐费用_In, 0) = 0 Then
      --挂号,预约挂号已经扣款部分
      n_预交id := 预交id_In;
      If Nvl(n_预交id, 0) = 0 Then
        Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      End If;
      n_结算合计 := 0;
      If 保险结算_In Is Not Null Then
        --各个保险结算
        v_结算内容 := 保险结算_In || '||';
        n_结算合计 := 0;
        While v_结算内容 Is Not Null Loop
          v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
          v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
          n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
          If Nvl(n_结算金额, 0) <> 0 Then
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 记录状态, 病人id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算性质)
            Values
              (n_预交id, 4, 单据号_In, 1, Decode(病人id_In, 0, Null, 病人id_In), '保险结算', v_结算方式, d_登记时间, v_操作员编号, v_操作员姓名,
               n_结算金额, n_结帐id, n_组id, n_结帐id, 4);
            Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          End If;
          n_结算合计 := Nvl(n_结算合计, 0) + Nvl(n_结算金额, 0);
          v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
        End Loop;
      End If;
    
      If Nvl(冲预交_In, 0) <> 0 Then
        --处理总预交
        n_结算合计 := n_结算合计 + Nvl(冲预交_In, 0);
        n_预交金额 := 冲预交_In;
        For r_Deposit In c_Deposit(病人id_In, v_冲预交病人ids) Loop
          n_结算金额 := Case
                      When r_Deposit.金额 - n_预交金额 < 0 Then
                       r_Deposit.金额
                      Else
                       n_预交金额
                    End;
          If r_Deposit.结帐id = 0 Then
            --第一次冲预交(填上结帐ID,金额为0)
            Update 病人预交记录 Set 冲预交 = 0, 结帐id = n_结帐id, 结算性质 = 4 Where ID = r_Deposit.原预交id;
          End If;
          --冲上次剩余额
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 预交类别, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名,
             操作员编号, 冲预交, 结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 预交类别, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行,
                   单位帐号, d_登记时间, v_操作员姓名, v_操作员编号, n_结算金额, n_结帐id, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, n_结帐id, 4
            From 病人预交记录
            Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
        
          --更新病人预交余额
          Update 病人余额
          Set 预交余额 = Nvl(预交余额, 0) - n_结算金额
          Where 病人id = r_Deposit.病人id And 性质 = 1 And 类型 = Nvl(1, 2)
          Returning 预交余额 Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 病人余额 (病人id, 预交余额, 性质, 类型) Values (r_Deposit.病人id, -1 * n_结算金额, 1, 1);
            n_返回值 := -1 * n_结算金额;
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 病人余额
            Where 病人id = r_Deposit.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
          End If;
        
          --检查是否已经处理完
          If r_Deposit.金额 <= n_结算金额 Then
            n_预交金额 := n_预交金额 - r_Deposit.金额;
          Else
            n_预交金额 := 0;
          End If;
          If n_预交金额 = 0 Then
            Exit;
          End If;
        End Loop;
        If n_预交金额 > 0 Then
          v_Err_Msg := '预交余额不够支付本次支付金额,不能继续操作！';
          Raise Err_Item;
        End If;
      End If;
      --剩余款项,用指定结算方支付
      n_结算金额 := Nvl(n_实收金额合计, 0) - Nvl(n_结算合计, 0);
      If Nvl(n_结算金额, 0) < 0 Then
        v_Err_Msg := '挂号的相关结算金额超出了当前实结金额,不能继续操作！';
        Raise Err_Item;
      End If;
      If Nvl(n_结算金额, 0) <> 0 Or (Nvl(n_结算金额, 0) = 0 And Nvl(冲预交_In, 0) = 0) Then
        If 结算方式_In Is Null Then
          v_Err_Msg := '未传入指定的结算方式,不能继续操作！';
          Raise Err_Item;
        End If;
      
        If Nvl(预交id_In, 0) <> 0 Then
          --传入的预交ID_In主要是为了解决三方交易,如果医保结算站用了该ID,需要用新的ID进行更新,三方交易用转入的ID
          Update 病人预交记录 Set ID = n_预交id Where ID = Nvl(预交id_In, 0);
          n_预交id := Nvl(预交id_In, 0);
        End If;
      
        Insert Into 病人预交记录
          (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 交易流水号, 交易说明, 结算序号, 合作单位, 卡类别id, 卡号,
           结算性质)
        Values
          (n_预交id, 4, 1, 单据号_In, r_Pati.病人id, 结算方式_In, Nvl(n_结算金额, 0), d_登记时间, v_操作员编号, v_操作员姓名, n_结帐id,
           合作单位_In || '缴款', n_组id, 交易流水号_In, 交易说明_In, n_结帐id, 合作单位_In, 卡类别id_In, 支付卡号_In, 4);
      End If;
    
      --更新人员缴款数据
    
      For v_缴款 In (Select 结算方式, Sum(Nvl(a.冲预交, 0)) As 冲预交
                   From 病人预交记录 A
                   Where a.结帐id = n_结帐id And Mod(a.记录性质, 10) <> 1 And Nvl(病人id, 0) = Nvl(病人id_In, 0)
                   Group By 结算方式) Loop
      
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + Nvl(v_缴款.冲预交, 0)
        Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = v_缴款.结算方式
        Returning 余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (v_操作员姓名, v_缴款.结算方式, 1, Nvl(v_缴款.冲预交, 0));
          n_返回值 := Nvl(v_缴款.冲预交, 0);
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = v_操作员姓名 And 结算方式 = 结算方式_In And 性质 = 1 And Nvl(余额, 0) = 0;
        End If;
      
      End Loop;
    
    End If;
  
    --处理挂号记录
    If 锁定类型_In = 2 Then
      Begin
        Select ID Into n_挂号id From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
      Exception
        When Others Then
          Null;
      End;
    Else
      Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
    End If;
  
    Update 病人挂号记录
    Set 记录性质 = Decode(操作方式_In, 2, 2, 1), 记录状态 = Decode(锁定类型_In, 1, 0, 1), 门诊号 = r_Pati.门诊号, 操作员姓名 = v_操作员姓名,
        操作员编号 = v_操作员编号, 预约 = Decode(操作方式_In, 1, 0, 1),
        接收人 = Decode(锁定类型_In, 1, Null, Decode(操作方式_In, 2, Null, v_操作员姓名)),
        接收时间 = Case 锁定类型_In
                  When 1 Then
                   Null
                  Else
                   Case 操作方式_In
                     When 2 Then
                      Null
                     Else
                      d_登记时间
                   End
                End, 交易流水号 = Nvl(交易流水号_In, 交易流水号), 交易说明 = Nvl(交易说明_In, 交易说明), 合作单位 = Nvl(合作单位_In, 合作单位),
        预约操作员 = Decode(操作方式_In, 1, Nvl(预约操作员, Null), Nvl(预约操作员, v_操作员姓名)),
        预约操作员编号 = Decode(操作方式_In, 1, Nvl(预约操作员编号, Null), Nvl(预约操作员编号, v_操作员编号))
    Where ID = n_挂号id;
    If Sql%NotFound Then
      Begin
        Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = r_Pati.付款方式 And Rownum < 2;
      Exception
        When Others Then
          v_付款方式 := Null;
      End;
      Insert Into 病人挂号记录
        (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 预约时间, 操作员编号,
         操作员姓名, 复诊, 号序, 预约, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 医疗付款方式, 预约操作员, 预约操作员编号)
      Values
        (n_挂号id, 单据号_In, Decode(操作方式_In, 2, 2, 1), Decode(锁定类型_In, 1, 0, 1), r_Pati.病人id, r_Pati.门诊号, r_Pati.姓名,
         r_Pati.性别, r_Pati.年龄, 号码_In, n_急诊, v_诊室, Null, r_安排.科室id, r_安排.医生姓名, 0, Null, d_登记时间, 发生时间_In,
         Case When(Nvl(操作方式_In, 0)) = 1 Then Null Else 发生时间_In End, v_操作员编号, v_操作员姓名, 0, n_号序, Decode(操作方式_In, 1, 0, 1),
         Decode(操作方式_In, 2, Null, v_操作员姓名), Decode(操作方式_In, 2, To_Date(Null), d_登记时间), 交易流水号_In, 交易说明_In, 合作单位_In,
         v_付款方式, Decode(操作方式_In, 1, Null, v_操作员姓名), Decode(操作方式_In, 1, Null, v_操作员编号));
    End If;
    --锁定单据不能产生队列
    If 锁定类型_In <> 1 Then
      n_预约生成队列 := 0;
      If 操作方式_In > 1 Then
        n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
      End If;
      --挂号和收费的预约都直接进入队列(收费预约缺少接收过程,所以直接和挂号一样直接进入队列)
      If 操作方式_In <> 2 Or n_预约生成队列 = 1 Then
        If Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113)) <> 0 Then
          --排队叫号模式:-0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站
          If Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113)) = 0 Or n_预约生成队列 = 1 Then
            n_分时点显示 := Nvl(Zl_To_Number(zl_GetSysParameter(270)), 0);
            If Nvl(操作方式_In, 0) > 1 And n_分时点显示 = 1 And n_启用分时段 = 1 Then
              n_分时点显示 := 1;
            Else
              n_分时点显示 := Null;
            End If;
            --产生队列
            --.按”执行部门” 的方式生成队列
            v_队列名称 := r_安排.科室id;
            v_排队号码 := Zlgetnextqueue(r_安排.科室id, n_挂号id, 号码_In || '|' || 号序_In);
            --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)
            v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
            --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)
            d_排队时间 := Zl_Get_Queuedate(n_挂号id, 号码_In, 号序_In, d_Date);
            --  队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,v_排队标记,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In, 排队时间_In
            Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, r_安排.科室id, v_排队号码, Null, r_Pati.姓名, r_Pati.病人id, v_诊室, r_安排.医生姓名,
                             d_排队时间, 预约方式_In, n_分时点显示, v_排队序号);
          End If;
        End If;
      End If;
    
      If Nvl(操作方式_In, 0) = 1 Then
        --处理票据使用情况
        If 票据号_In Is Not Null Then
          Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
          --发出票据
          Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 4, 单据号_In);
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人, 票据金额)
          Values
            (票据使用明细_Id.Nextval, Decode(收费票据_In, 1, 1, 4), 票据号_In, 1, 1, 领用id_In, n_打印id, d_登记时间, v_操作员姓名, 挂号金额合计_In);
          --状态改动
          Update 票据领用记录
          Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
          Where ID = Nvl(领用id_In, 0);
        End If;
        --病人本次就诊(以发生时间为准)
        If Nvl(r_Pati.病人id, 0) <> 0 Then
          Update 病人信息 Set 就诊时间 = 发生时间_In, 就诊状态 = 1, 就诊诊室 = v_诊室 Where 病人id = r_Pati.病人id;
        End If;
      End If;
    End If;
    --病人挂号汇总
    --解锁单据时不用再对汇总单据进行统计了 在锁定单据时已经进行了汇总
    If 锁定类型_In <> 2 Then
      --操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
      --是否为预约接收:0-非预约挂号; 1-预约挂号,2-预约接收;3-收费预约
      --调用zl_third_lockno进行锁号，不建议使用本过程锁号
      n_预约 := Case
                When Nvl(操作方式_In, 0) = 1 Then
                 0
                When Nvl(操作方式_In, 0) = 2 Then
                 1
                When Nvl(操作方式_In, 0) = 3 Then
                 3
                Else
                 0
              End;
      Zl_病人挂号汇总_Update(r_安排.医生姓名, r_安排.医生id, r_安排.项目id, r_安排.科室id, 发生时间_In, n_预约, 号码_In);
    End If;

    If 锁定类型_In <> 1 Then
      --消息推送,锁号时不发送信息
      Begin
        Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
          Using 1, n_挂号id;
      Exception
        When Others Then
          Null;
      End;
      b_Message.Zlhis_Regist_001(n_挂号id, 单据号_In);
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]+' || v_Err_Msg || '+[ZLSOFT]');
  When Err_Special Then
    Raise_Application_Error(-20105, '[ZLSOFT]+' || v_Err_Msg || '+[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_三方机构挂号_Insert;
/

--113098:余伟节,2017-12-04,临床路径双审核
Create Or Replace Procedure Zl_路径医嘱内容_Update
(
  功能_In        In Number, --1-单条医嘱更新，2-检查检验;
  医嘱内容id_In  In 路径医嘱内容.Id%Type,
  诊疗项目id_In  In 路径医嘱内容.诊疗项目id%Type,
  收费细目id_In  In 路径医嘱内容.收费细目id% Type := Null,
  医嘱内容_In    In 路径医嘱内容.医嘱内容%Type := Null,
  单次用量_In    In 路径医嘱内容.单次用量%Type := Null,
  总给予量_In    In 路径医嘱内容.总给予量%Type := Null,
  标本部位_In    In 路径医嘱内容.标本部位%Type := Null,
  检查方法_In    In 路径医嘱内容.检查方法%Type := Null,
  医生嘱托_In    In 路径医嘱内容.医生嘱托%Type := Null,
  执行频次_In    In 路径医嘱内容.执行频次%Type := Null,
  频率次数_In    In 路径医嘱内容.频率次数%Type := Null,
  频率间隔_In    In 路径医嘱内容.频率间隔%Type := Null,
  间隔单位_In    In 路径医嘱内容.间隔单位%Type := Null,
  时间方案_In    In 路径医嘱内容.时间方案%Type := Null,
  插入内容ids_In In Varchar2 := Null, --功能_IN=2时,新医嘱ID串
  项目医嘱ids_In In Varchar2 := Null,
  诊疗类别_In    In Varchar2 := Null --区分检查检验
) As
  n_序号    Number(5);
  n_Count   Number(5);
  n_Start   Number(5);
  n_Groupid Number(18);
  Arr_Id    t_Numlist;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin

  --
  If 功能_In = 1 Then
    If Nvl(诊疗项目id_In, 0) = 0 And Nvl(收费细目id_In, 0) = 0 Then
      --药品
      Update 路径医嘱内容 T
      Set t.医嘱内容 = Nvl(医嘱内容_In, t.医嘱内容), t.单次用量 = Nvl(单次用量_In, t.单次用量), t.总给予量 = Nvl(总给予量_In, t.总给予量),
          t.标本部位 = Nvl(标本部位_In, t.标本部位), t.检查方法 = Nvl(检查方法_In, t.检查方法), t.医生嘱托 = Nvl(医生嘱托_In, t.医生嘱托),
          t.执行频次 = Nvl(执行频次_In, t.执行频次), t.频率次数 = Nvl(频率次数_In, t.频率次数), t.频率间隔 = Nvl(频率间隔_In, t.频率间隔),
          t.间隔单位 = Nvl(间隔单位_In, t.间隔单位), t.时间方案 = Nvl(时间方案_In, t.时间方案)
      Where t.Id = 医嘱内容id_In;
    Else
      --药品
      Update 路径医嘱内容 T
      Set t.诊疗项目id = 诊疗项目id_In, t.收费细目id = 收费细目id_In, t.医嘱内容 = Nvl(医嘱内容_In, t.医嘱内容), t.单次用量 = Nvl(单次用量_In, t.单次用量),
          t.总给予量 = Nvl(总给予量_In, t.总给予量), t.标本部位 = Nvl(标本部位_In, t.标本部位), t.检查方法 = Nvl(检查方法_In, t.检查方法),
          t.医生嘱托 = Nvl(医生嘱托_In, t.医生嘱托), t.执行频次 = Nvl(执行频次_In, t.执行频次), t.频率次数 = Nvl(频率次数_In, t.频率次数),
          t.频率间隔 = Nvl(频率间隔_In, t.频率间隔), t.间隔单位 = Nvl(间隔单位_In, t.间隔单位), t.时间方案 = Nvl(时间方案_In, t.时间方案)
      Where t.Id = 医嘱内容id_In;
    End If;
  Elsif 功能_In = 2 Then
    --检查,检验
    For R1 In (Select a.C1 As 项目id, a.C2 As 组医嘱id From Table(f_Num2list2(项目医嘱ids_In, ':', ',')) A) Loop
      --删除原医嘱（级联删除临床路径医嘱）
      Delete From 路径医嘱内容 T Where t.Id = R1.组医嘱id Or t.相关id = R1.组医嘱id;
      Select Nvl(Max(b.序号), 0)
      Into n_序号
      From 临床路径医嘱 A, 路径医嘱内容 B
      Where a.路径项目id = R1.项目id And a.医嘱内容id = b.Id;
      --预先读取医嘱内容ID,相关ID
      Select Count(1) Into n_Count From Table(f_Num2list(插入内容ids_In, ','));
    
      Select 路径医嘱内容_Id.Nextval Bulk Collect Into Arr_Id From Dual Connect By Rownum <= n_Count;
      If 诊疗类别_In = 'D' Then
        n_Groupid := Arr_Id(1);
      Else
        n_Groupid := Arr_Id(n_Count);
      End If;
      --临床路径医嘱关联
      n_Start := 0;
      For R2 In (Select b.Column_Value As 内容id From Table(f_Num2list(插入内容ids_In, ',')) B) Loop
        --新增医嘱内容
        n_序号  := n_序号 + 1;
        n_Start := n_Start + 1;
        Insert Into 路径医嘱内容 A
          (a.Id, a.相关id, a.序号, a.期效, a.诊疗项目id, a.收费细目id, a.医嘱内容, a.单次用量, a.总给予量, a.标本部位, a.检查方法, a.医生嘱托, a.执行频次, a.频率次数,
           a.频率间隔, a.间隔单位, a.执行性质, a.执行标记, a.执行科室id, a.时间方案, a.是否缺省, a.是否备选, a.配方id, a.组合项目id)
          Select /* +rule */
           Arr_Id(n_Start) As ID, Decode(b.相关id, Null, Null, n_Groupid) As 相关id, n_序号 As 序号, b.期效, b.诊疗项目id, b.收费细目id,
           b.医嘱内容, b.单次用量, b.总给予量, b.标本部位, b.检查方法, b.医生嘱托, b.执行频次, b.频率次数, b.频率间隔, b.间隔单位, b.执行性质, b.执行标记, b.执行科室id,
           b.时间方案, b.是否缺省, b.是否备选, b.配方id, b.组合项目id
          From 路径医嘱内容 B
          Where b.Id = R2.内容id;
        Insert Into 临床路径医嘱 T (t.路径项目id, t.医嘱内容id) Values (R1.项目id, Arr_Id(n_Start));
      End Loop;
    End Loop;
    --删除临时医嘱
    Delete From 路径医嘱内容 T Where Instr(',' || 插入内容ids_In || ',', ',' || t.Id || ',') > 0;
  
  End If;
Exception

  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_路径医嘱内容_Update;
/

--117686:冉俊明,2017-12-04,使用消费卡缴预交，退款时多退回了
Create Or Replace Procedure Zl_病人卡结算记录_退款
(
  接口编号_In   消费卡类别目录.编号%Type,
  卡号_In       消费卡信息.卡号%Type,
  消费卡id_In   消费卡信息.Id%Type,
  结算金额_In   病人卡结算记录.应收金额%Type,
  原预交id_In   病人卡结算记录.结算id%Type,
  新预交id_In   病人卡结算记录.结算id%Type,
  操作员编号_In 病人卡结算记录.操作员编号%Type,
  操作员姓名_In 病人卡结算记录.操作员姓名%Type,
  退款时间_In   病人预交记录.收款时间%Type
) As
  --检查消费卡的有效性,并退款
  --入参：
  --        结算金额_In 传入正数
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_名称 消费卡类别目录.名称%Type;

  n_消费卡id 消费卡信息.Id%Type;
  v_卡号     消费卡信息.卡号%Type;
  n_序号     消费卡信息.序号%Type;
  d_停用日期 消费卡信息.停用日期%Type;
  d_回收时间 消费卡信息.回收时间%Type;
  d_有效期   消费卡信息.有效期%Type;
  n_最大序号 消费卡信息.序号%Type;
  v_当前状态 Varchar2(255);

  n_结算金额 病人卡结算记录.应收金额%Type;
  n_结算序号 病人卡结算记录.结算序号%Type;
  n_Id       病人卡结算记录.Id%Type;
  n_本次金额 帐户缴款余额.余额%Type;
  n_返回值   帐户缴款余额.余额%Type;
  d_缴款时间 帐户缴款余额.缴款时间%Type;

  n_Count Number(8);
Begin
  Begin
    Select 名称 Into v_名称 From 消费卡类别目录 Where 编号 = 接口编号_In;
  Exception
    When Others Then
      v_名称 := Null;
  End;
  If v_名称 Is Null Then
    v_Err_Msg := '未找到对应的卡类别信息，不能退费！';
    Raise Err_Item;
  End If;

  n_消费卡id := 消费卡id_In;
  If Nvl(n_消费卡id, 0) = 0 Then
    If 卡号_In Is Null Then
      v_Err_Msg := '未找到对应的消费卡信息，不能刷卡消费！';
      Raise Err_Item;
    Else
      --根据卡号获取消费卡ID
      Begin
        Select ID
        Into n_消费卡id
        From 消费卡信息 A
        Where a.接口编号 = 接口编号_In And a.卡号 = 卡号_In And
              a.序号 = (Select Max(序号) From 消费卡信息 Where 接口编号 = a.接口编号 And 卡号 = a.卡号);
      Exception
        When Others Then
          n_消费卡id := 0;
      End;
    End If;
  End If;
  If Nvl(n_消费卡id, 0) = 0 Then
    v_Err_Msg := '未找到对应的消费卡信息，不能刷卡消费！';
    Raise Err_Item;
  End If;

  Begin
    Select 卡号, 序号, 停用日期, 回收时间, Decode(a.当前状态, 2, '回收', 3, '退卡', Null) As 当前状态, a.有效期,
           (Select Max(序号) From 消费卡信息 B Where a.卡号 = b.卡号 And a.接口编号 = b.接口编号)
    Into v_卡号, n_序号, d_停用日期, d_回收时间, v_当前状态, d_有效期, n_最大序号
    From 消费卡信息 A
    Where a.Id = n_消费卡id;
  Exception
    When Others Then
      v_Err_Msg := '卡号为"' || v_卡号 || '"的' || v_名称 || '已经被他人删除，不能退费！';
      Raise Err_Item;
  End;

  If Nvl(n_序号, 0) < Nvl(n_最大序号, 0) Then
    v_Err_Msg := '卡号为' || v_卡号 || '的' || v_名称 || '已经是历史卡了，不能退费！';
    Raise Err_Item;
  End If;

  If Nvl(d_回收时间, Sysdate + 1) < Sysdate Then
    v_Err_Msg := '卡号为' || v_卡号 || '的' || v_名称 || '已经被' || Nvl(v_当前状态, '回收') || '，不能退费！';
    Raise Err_Item;
  End If;

  If Nvl(d_停用日期, Sysdate + 1) < Sysdate Then
    v_Err_Msg := '卡号为' || v_卡号 || '的' || v_名称 || '已经被停用，不能退费！';
    Raise Err_Item;
  End If;

  n_结算金额 := 结算金额_In;
  n_结算序号 := 0;
  For c_记录 In (Select Max(Decode(a.记录状态, 2, 0, a.Id)) As ID, Sum(a.应收金额) As 应收金额, Max(a.扣率) As 扣率, Max(a.结算方式) As 结算方式,
                      Max(a.交易序号) As 交易序号, Max(a.卡类别id) As 卡类别id, Max(a.结算卡号) As 结算卡号, Max(a.交易流水号) As 交易流水号,
                      Max(a.交易说明) As 交易说明
               From 病人卡结算记录 A, 病人卡结算记录 B
               Where a.接口编号 = b.接口编号 And a.记录性质 = b.记录性质 And a.消费卡id = b.消费卡id And a.序号 = b.序号 And b.记录性质 = 4 And
                     b.消费卡id = n_消费卡id And b.结算id = 原预交id_In
               Group By a.消费卡id, a.序号
               Having Nvl(Sum(a.应收金额), 0) < 0) Loop
  
    If Abs(c_记录.应收金额) < n_结算金额 Then
      n_本次金额 := Abs(c_记录.应收金额);
      n_结算金额 := n_结算金额 - Abs(c_记录.应收金额);
    Else
      n_本次金额 := n_结算金额;
      n_结算金额 := 0;
    End If;
  
    Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
    If n_结算序号 = 0 Then
      n_结算序号 := n_Id;
    End If;
  
    Update 病人卡结算记录 Set 记录状态 = 3 Where ID = c_记录.Id;
  
    --插入卡结算记录 
    Insert Into 病人卡结算记录
      (ID, 接口编号, 记录性质, 记录状态, 消费卡id, 卡号, 序号, 结算id, 应收金额, 扣率, 实收金额, 结算方式, 交易时间, 结算标志, 卡类别id, 结算卡号, 交易流水号, 交易说明, 操作员编号,
       操作员姓名, 登记时间, 结算序号, 交易序号)
      Select n_Id, 接口编号, 记录性质, 2, 消费卡id, 卡号, 序号, 新预交id_In, n_本次金额, 扣率, n_本次金额 * 扣率 / 100, 结算方式, 退款时间_In, 1, 卡类别id, 结算卡号,
             交易流水号, 交易说明, 操作员编号_In, 操作员姓名_In, Sysdate, n_结算序号, c_记录.交易序号
      From 病人卡结算记录
      Where ID = c_记录.Id;
  
    Update 帐户缴款余额
    Set 余额 = Nvl(余额, 0) + n_本次金额,
        实际缴款 =
         (Nvl(余额, 0) + n_本次金额) * 扣率 / 100
    Where 性质 = 1 And 交易序号 = c_记录.交易序号 And 消费卡id = n_消费卡id
    Returning 余额 Into n_返回值;
    If Sql%NotFound Then
      --判断是否为面值，取有效期
      Select Count(1)
      Into n_Count
      From 病人卡结算记录
      Where 记录性质 = 1 And 消费卡id = n_消费卡id And 交易序号 = c_记录.交易序号;
      If n_Count > 0 Then
        Begin
          Select 有效期 Into d_有效期 From 消费卡信息 Where ID = n_消费卡id;
        Exception
          When Others Then
            d_有效期 := Null;
        End;
      End If;
    
      --取原缴款记录的缴款时间
      Begin
        --可能发卡时同时进行了充值，为了先使用面值金额，面值的登记时间需要减一秒
        Select 登记时间 - Decode(记录性质, 1, 1 / 24 / 60 / 10, 0)
        Into d_缴款时间
        From 病人卡结算记录
        Where 交易序号 = c_记录.交易序号 And 记录性质 In (1, 2) And 消费卡id = n_消费卡id And Rownum < 2;
      Exception
        When Others Then
          d_缴款时间 := 退款时间_In;
      End;
    
      Insert Into 帐户缴款余额
        (性质, 消费卡id, 结算方式, 余额, 扣率, 实际缴款, 卡类别id, 卡号, 交易流水号, 交易说明, 有效期, 交易序号, 缴款时间)
      Values
        (1, n_消费卡id, c_记录.结算方式, n_本次金额, c_记录.扣率, n_本次金额 * c_记录.扣率 / 100, c_记录.卡类别id, c_记录.结算卡号, c_记录.交易流水号, c_记录.交易说明,
         Nvl(d_有效期, To_Date('3000-01-01', 'yyyy-mm-dd')), c_记录.交易序号, d_缴款时间);
      n_返回值 := n_本次金额;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 帐户缴款余额 Where 性质 = 1 And 交易序号 = c_记录.交易序号 And 消费卡id = n_消费卡id;
    End If;
  
    --更新其余额
    Update 消费卡信息 Set 余额 = Nvl(余额, 0) + n_本次金额 Where ID = n_消费卡id;
  
    If n_结算金额 = 0 Then
      Exit;
    End If;
  End Loop;

  If n_结算金额 > 0 Then
    v_Err_Msg := '卡号为' || v_卡号 || '的' || v_名称 || '剩余可退金额(' || LTrim(To_Char(结算金额_In - n_结算金额, '9999999990.00')) ||
                 ')不足本次退款金额(' || LTrim(To_Char(结算金额_In, '9999999990.00')) || ')，不能退费！';
    Raise Err_Item;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, ' [ZLSOFT] ' || v_Err_Msg || ' [ZLSOFT] ');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人卡结算记录_退款;
/

--120659:胡俊勇,2018-01-23,过敏实验仅绑定到药品规格上
--97553:胡俊勇,2017-12-01,过敏皮试结果登记时间
Create Or Replace Procedure Zl_病人医嘱记录_皮试
(
  --功能：填写医嘱皮试结果
  --说明：同时处理病人过敏记录
  --参数：标注_In=比如阳性："(+)",阴性："(-)",免试："免试"，等
  --      结果_IN=0-阴性,1-阳性，NULL=免试
  Id_In         In 病人医嘱记录.Id%Type,
  标注_In       In 病人医嘱记录.皮试结果%Type,
  结果_In       In 病人过敏记录.结果%Type,
  操作员姓名_In In 人员表.姓名%Type := Null,
  皮试时间_In   In 病人过敏记录.过敏时间%Type := Null,
  过敏反应_In   In 病人过敏药物.过敏反应%Type := Null
) Is
  --跟该过敏试验相关的所有药品信息项目
  Cursor c_Data Is
    Select a.病人id, a.主页id, a.项目id, a.名称
    From (Select c.病人id, Decode(c.挂号单, Null, c.主页id, d.Id) As 主页id, a.项目id, b.名称
           From 诊疗用法用量 A, 诊疗项目目录 B, 病人医嘱记录 C, 病人挂号记录 D
           Where Nvl(a.性质, 0) = 0 And a.用法id = c.诊疗项目id And a.项目id = b.Id And b.类别 In ('5', '6') And c.挂号单 = d.No(+) And
                 c.Id = Id_In
           Union All
           Select c.病人id, Decode(c.挂号单, Null, c.主页id, d.Id) As 主页id, b.Id As 项目id, b.名称
           From 药品用法用量 A, 诊疗项目目录 B, 病人医嘱记录 C, 病人挂号记录 D, 药品规格 E
           Where Nvl(a.性质, 0) = 0 And a.用法id = c.诊疗项目id And a.药品id = e.药品id And e.药名id = b.Id And b.类别 In ('5', '6') And
                 c.挂号单 = d.No(+) And c.Id = Id_In) A
    Group By a.病人id, a.主页id, a.项目id, a.名称;

  v_挂号单   病人医嘱记录.挂号单%Type;
  v_状态     病人医嘱记录.医嘱状态%Type;
  v_医嘱内容 病人医嘱记录.医嘱内容%Type;

  v_Date         Date;
  d_操作时间     Date;
  v_Temp         Varchar2(255);
  v_人员编号     人员表.编号%Type;
  v_人员姓名     病人医嘱状态.操作人员%Type;
  v_上次记录时间 Date;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --检查医嘱状态是否正确:并发操作
  Select 挂号单, 医嘱状态, 医嘱内容 Into v_挂号单, v_状态, v_医嘱内容 From 病人医嘱记录 Where ID = Id_In;
  If v_状态 = 4 Then
    v_Error := '医嘱"' || v_医嘱内容 || '"已经作废，不能登记过敏试验结果。';
    Raise Err_Custom;
  End If;
  If v_挂号单 Is Not Null And v_状态 = 1 And Not 结果_In Is Null Then
    v_Error := '医嘱"' || v_医嘱内容 || '"尚未发送，不能登记过敏试验结果。';
    Raise Err_Custom;
  End If;

  --当前操作人员
  If 操作员姓名_In Is Null Then
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  Else
    v_人员姓名 := 操作员姓名_In;
    Select 编号 Into v_人员编号 From 人员表 Where 姓名 = v_人员姓名;
  End If;

  If 皮试时间_In Is Null Then
    Select Sysdate Into v_Date From Dual;
    d_操作时间 := v_Date;
  Else
    v_Date := 皮试时间_In;
    Select Sysdate Into d_操作时间 From Dual;
  End If;

  --处理医嘱记录:清除免试一样记录
  Update 病人医嘱记录 Set 皮试结果 = 标注_In, 标本部位 = To_Char(v_Date, 'YYYY-MM-DD HH24:MI:SS') Where ID = Id_In;

  --获取上次填写该记录的时间
  Begin
    Select 操作时间
    Into v_上次记录时间
    From (Select 操作时间 From 病人医嘱状态 Where 医嘱id = Id_In And 操作类型 = 10 Order By 操作时间 Desc)
    Where Rownum < 2;
  Exception
    When No_Data_Found Then
      v_上次记录时间 := Null;
  End;

  Insert Into 病人医嘱状态 (医嘱id, 操作类型, 操作人员, 操作时间) Values (Id_In, 10, v_人员姓名, d_操作时间);

  --登记病人过敏记录(即使以前有同类药的过敏结果登记)
  If Not 结果_In Is Null Then
    For r_Data In c_Data Loop
    
      If Not v_上次记录时间 Is Null Then
        Delete From 病人过敏记录 A
        Where a.病人id = r_Data.病人id And a.主页id = r_Data.主页id And a.记录来源 = 2 And a.记录时间 = v_上次记录时间;
      End If;
      Insert Into 病人过敏记录
        (ID, 病人id, 主页id, 记录来源, 药物id, 药物名, 结果, 过敏时间, 记录时间, 记录人, 过敏反应)
      Values
        (病人过敏记录_Id.Nextval, r_Data.病人id, r_Data.主页id, 2, r_Data.项目id, r_Data.名称, 结果_In, v_Date, d_操作时间, v_人员姓名, 过敏反应_In);
      If 结果_In = 1 Then
        Update 病人过敏药物
        Set 过敏反应 = 过敏反应_In, 过敏药物id = r_Data.项目id
        Where 病人id = r_Data.病人id And 过敏药物 = r_Data.名称;
        If Sql%RowCount = 0 Then
          Insert Into 病人过敏药物
            (病人id, 过敏药物id, 过敏药物, 过敏反应)
          Values
            (r_Data.病人id, r_Data.项目id, r_Data.名称, 过敏反应_In);
        End If;
      Else
        --如果没有过敏的记录就删除该药品的过敏记录
        Delete From 病人过敏药物 A
        Where a.病人id = r_Data.病人id And a.过敏药物 = r_Data.名称 And a.过敏药物id = r_Data.项目id And Not Exists
         (Select 1
               From 病人过敏记录 B
               Where b.病人id = a.病人id And b.药物id = a.过敏药物id And b.药物名 = a.过敏药物 And 结果 = 1);
      End If;
    End Loop;
    --标记皮试结果时将医嘱自动设为执行完成
    For X In (Select 执行状态, 发送号, 执行部门id From 病人医嘱发送 Where 医嘱id = Id_In) Loop
      If x.执行状态 <> 1 Then
        Zl_病人医嘱执行_Finish(Id_In, x.发送号, Null, 0, v_人员编号, v_人员姓名, x.执行部门id);
      End If;
    End Loop;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱记录_皮试;
/

--117279:刘硕,2017-12-01,停用人员时锁定账户
Create Or Replace Procedure Zl_人员表_停用
(
  Id_In       In 人员表.Id%Type,
  撤档原因_In 人员表.撤档原因%Type := Null
) Is
   v_User 上机人员表.用户名%Type;
Begin
  Update 人员表 Set 撤档时间 = Sysdate, 撤档原因 = 撤档原因_In Where ID = Id_In;
  Select Max(用户名) Into v_User From 上机人员表 Where 人员id = Id_In;
  If Not v_User Is Null Then
    Begin
      --停用数据库用户
      Execute Immediate 'Alter User ' || v_User || '  Account Lock';
    Exception
      When Others Then
        Null;
        --1、由于用户可能不存在，上级人员表为我们记录的用户，并不是数据库实际存在用户 
      --2、系统所有者没有权限，以前系统所有者没有ALter User权限
      --因此采取错误屏蔽
    End;
  End If;
  Begin
    --因为可能独立安装，所以只能动态执行
    Execute Immediate 'call Zl_人员表_更新挂号安排(:1,:2,:3)'
      Using Id_In,2,sysdate;
  Exception
    When Others Then
      Null;
  End;

  Begin
    --因为可能独立安装，所以只能动态执行
    Execute Immediate 'call b_Message.Zlhis_Dict_007(:1)'
      Using Id_In;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_人员表_停用;
/

--117279:刘硕,2017-12-01,停用人员时锁定账户
Create Or Replace Procedure Zl_人员表_启用
(
  Id_In In 人员表.ID%Type
) Is
d_撤档时间 date;
v_User 上机人员表.用户名%Type;
v_Error    Varchar2(255);
Err_Custom Exception;
Begin
  Begin
    select 撤档时间 into d_撤档时间 from 人员表 where id=Id_In;
  Exception
    When Others Then
      v_Error := '该人员已被删除！';
      Raise Err_Custom;
  End;   
    
  Update 人员表 Set 撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd'), 撤档原因 = '' Where ID = Id_In;
  
  Begin
    --因为可能独立安装，所以只能动态执行，只有 ZLHIS有
    Execute Immediate 'call Zl_人员表_更新挂号安排(:1,:2,:3)'
      Using Id_In,3,d_撤档时间;
  Exception
    When Others Then
      Null;
  End;
  Select Max(用户名) Into v_User From 上机人员表 Where 人员id = Id_In;
  If Not v_User Is Null Then
    Begin
      --启用数据库用户
      Execute Immediate 'Alter User ' || v_User || '  Account UnLock';
    Exception
      When Others Then
        Null;
        --1、由于用户可能不存在，上级人员表为我们记录的用户，并不是数据库实际存在用户 
      --2、系统所有者没有权限，以前系统所有者没有ALter User权限
      --因此采取错误屏蔽
    End;
  End If;
  Begin
    --因为可能独立安装，所以只能动态执行
    Execute Immediate 'call b_Message.Zlhis_Dict_008(:1)'
      Using Id_In;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_人员表_启用;
/

--117279:刘硕,2017-12-01,停用人员时锁定账户
Create Or Replace Procedure Zl_人员表_Delete(Id_In In 人员表.Id%Type) Is
  v_User 上机人员表.用户名%Type;
Begin
  Select Max(用户名) Into v_User From 上机人员表 Where 人员id = Id_In;
  Delete From 人员表 Where ID = Id_In;
  If Not v_User Is Null Then
    Begin
      --停用数据库用户
      Execute Immediate 'Alter User ' || v_User || '  Account Lock';
    Exception
      When Others Then
        Null;
        --1、由于用户可能不存在，上级人员表为我们记录的用户，并不是数据库实际存在用户 
      --2、系统所有者没有权限，以前系统所有者没有ALter User权限
      --因此采取错误屏蔽
    End;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_人员表_Delete;
/

--109325:李业庆,2018-01-03,可用数量异常数据处理
Create Or Replace Procedure Zl_药品结存记录_Verify
(
  结存id_In In 药品结存记录.Id%Type,
  审核人_In In 药品结存记录.审核人%Type := Null
) Is
  v_Id    药品结存记录.Id%Type;
  Err_Msg Varchar2(255);
  Err_Find Exception;

  Cursor c_Mistake Is
    Select a.Id, a.结存id, a.库房id, a.药品id, Nvl(a.批次, 0) 批次, a.数量差, a.金额差, a.差价差
    From 药品结存误差 A, 药品规格 B
    Where a.药品id = b.药品id And a.结存id = 结存id_In;
Begin
  --并发检查 
  Begin
    Select ID Into v_Id From 药品结存记录 Where 审核人 Is Null And ID = 结存id_In;
  Exception
    When Others Then
      Err_Msg := '该结存记录已被其他操作员审核，请查看！';
      Raise Err_Find;
  End;

  --审核药品结存主表 
  Update 药品结存记录
  Set 审核人 = Nvl(审核人_In, Zl_Username), 审核日期 = Sysdate
  Where 审核人 Is Null And ID = 结存id_In;

  --根据误差数据修正库存数据 
  For r_Mistake In c_Mistake Loop
    Update 药品库存
    Set 可用数量 = Nvl(可用数量, 0) + r_Mistake.数量差, 实际数量 = Nvl(实际数量, 0) + r_Mistake.数量差, 实际金额 = Nvl(实际金额, 0) + r_Mistake.金额差,
        实际差价 = Nvl(实际差价, 0) + r_Mistake.差价差
    Where 性质 = 1 And 库房id = r_Mistake.库房id And 药品id = r_Mistake.药品id And Nvl(批次, 0) = Nvl(r_Mistake.批次, 0);
  
    If Sql%RowCount = 0 Then
      Begin
        Insert Into 药品库存
          (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次批号, 效期, 上次供应商id, 上次采购价, 上次产地, 上次生产日期, 批准文号)
          Select 库房id, 药品id, Nvl(批次, 0) As 批次, 1, r_Mistake.数量差, r_Mistake.数量差, r_Mistake.金额差, r_Mistake.差价差, 批号, 效期,
                 供药单位id, 成本价, 产地, 生产日期, 批准文号
          From 药品收发记录
          Where ID = (Select Max(ID)
                      From 药品收发记录
                      Where 库房id = r_Mistake.库房id And 药品id = r_Mistake.药品id And Nvl(批次, 0) = Nvl(r_Mistake.批次, 0) And
                            审核日期 Is Not Null And 单据 In (1, 2, 3, 4, 6, 7, 8, 9, 10, 11));
      
      Exception
        When Others Then
          Null;
      End;
    End If;
  
    Delete From 药品库存
    Where 性质 = 1 And 库房id = r_Mistake.库房id And 药品id = r_Mistake.药品id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And
          Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0;
  
    Zl_药品库存_可用数量异常处理(r_Mistake.库房id, r_Mistake.药品id, Nvl(r_Mistake.批次, 0));
  End Loop;

Exception
  When Err_Find Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品结存记录_Verify;
/


--119638:陈福容,2018-01-08，更改图形为BLOB
Create Or Replace Procedure zl_咨询图片元素_Insert (
    序号_IN                咨询图片元素.序号%Type,
    名称_IN                咨询图片元素.名称%Type,    
    性质_IN                咨询图片元素.性质%Type,
    类型_IN                咨询图片元素.类型%Type,
    宽度_IN                咨询图片元素.宽度%Type,
    高度_IN                咨询图片元素.高度%Type,                
    修改日期_IN            咨询图片元素.修改日期%Type)
AS
Begin
    Insert Into 咨询图片元素(序号,名称,性质,类型,宽度,高度,修改日期)
    Values (序号_IN,名称_IN,性质_IN,类型_IN,宽度_IN,高度_IN,修改日期_IN);
Exception
    When Others Then  Zl_ErrorCenter (SQLCODE, SQLERRM);
End zl_咨询图片元素_Insert;
/

--119638:陈福容,2018-01-08，更改段落文本为CLOB，需要增加字段进行处理
Create Or Replace Procedure zl_咨询段落目录_insert (
    页面序号_IN            咨询段落目录.页面序号%Type,
    段落序号_IN            咨询段落目录.段落序号%Type,
    标题文本_IN            咨询段落目录.标题文本%Type,
    标题图标_IN            咨询段落目录.标题图标%Type,
    标题隐藏_IN            咨询段落目录.标题隐藏%Type,
    标题位置_IN            咨询段落目录.标题位置%Type,
    标题字体_IN            咨询段落目录.标题字体%Type,
    返回页首_IN            咨询段落目录.返回页首%Type,
    插表序号_IN            咨询段落目录.插表序号%Type,
    插表位置_IN            咨询段落目录.插表位置%Type,
    插图序号_IN            咨询段落目录.插图序号%Type,
    插图位置_IN            咨询段落目录.插图位置%Type,
    段落字体_In		 咨询段落目录.段落字体%Type:=Null,
    段落类型_In		 咨询段落目录.段落类型%Type:=0) As
Begin
    INSERT INTO 咨询段落目录(页面序号,段落序号,段落类型,标题文本,标题图标,标题隐藏,标题位置,标题字体,返回页首,插表序号,插表位置,插图序号,插图位置,段落字体)
    VALUES (页面序号_IN,段落序号_IN,段落类型_In,标题文本_IN,DECODE(标题图标_IN,0,NULL,标题图标_IN),标题隐藏_IN,标题位置_IN,标题字体_IN,返回页首_IN,DECODE(插表序号_IN,0,NULL,插表序号_IN),DECODE(插表序号_IN,0,NULL,插表位置_IN),DECODE(插图序号_IN,0,NULL,插图序号_IN),DECODE(插图序号_IN,0,NULL,插图位置_IN),段落字体_In);
Exception
    When Others Then  Zl_ErrorCenter (SQLCODE, SQLERRM);
End zl_咨询段落目录_insert;
/

--119638:陈福容,2018-01-08，更改段落文本为CLOB，需要增加字段进行处理
Create Or Replace Procedure zl_咨询段落目录_update (
    页面序号_IN            咨询段落目录.页面序号%Type,
    段落序号_IN            咨询段落目录.段落序号%Type,
    标题文本_IN            咨询段落目录.标题文本%Type,
    标题图标_IN            咨询段落目录.标题图标%Type,
    标题隐藏_IN            咨询段落目录.标题隐藏%Type,
    标题位置_IN            咨询段落目录.标题位置%Type,
    标题字体_IN            咨询段落目录.标题字体%Type,
    返回页首_IN            咨询段落目录.返回页首%Type,
    插表序号_IN            咨询段落目录.插表序号%Type,
    插表位置_IN            咨询段落目录.插表位置%Type,
    插图序号_IN            咨询段落目录.插图序号%Type,
    插图位置_IN            咨询段落目录.插图位置%Type,
    段落字体_In		 咨询段落目录.段落字体%Type:=Null,
    段落类型_In		 咨询段落目录.段落类型%Type:=0) As
Begin
    UPDATE 咨询段落目录
    SET 段落类型=段落类型_In,标题文本=标题文本_IN,标题图标=DECODE(标题图标_IN,0,NULL,标题图标_IN),标题隐藏=标题隐藏_IN,标题位置=标题位置_IN,标题字体=标题字体_IN,返回页首=返回页首_IN,插表序号=DECODE(插表序号_IN,0,NULL,插表序号_IN),插表位置=DECODE(插表序号_IN,0,NULL,插表位置_IN),插图序号=DECODE(插图序号_IN,0,NULL,插图序号_IN),插图位置=DECODE(插图序号_IN,0,NULL,插图位置_IN),段落字体=段落字体_In
    WHERE 页面序号=页面序号_IN AND 段落序号=段落序号_IN;
Exception
    When Others Then  Zl_ErrorCenter (SQLCODE, SQLERRM);
End zl_咨询段落目录_update;
/

--120700:李业庆,2018-01-23,消息描点调整
Create Or Replace Procedure Zl_诊疗分类目录_Insert
(
  Id_In      诊疗分类目录.Id%Type,
  上级id_In  诊疗分类目录.上级id%Type,
  编码_In    诊疗分类目录.编码%Type,
  名称_In    诊疗分类目录.名称%Type,
  简码_In    诊疗分类目录.简码%Type,
  类型_In    诊疗分类目录.类型%Type,
  v_Brethren Number
  --是否对同级编码进行长度处理,0-否,1-是
) As
  v_Parent Varchar2(20); --上级编码
  v_Extend Number(20); --扩充长度(为负表示压缩)
Begin
  --调整同级编码的长度
  If v_Brethren = 1 Then
    If Nvl(上级id_In, 0) <> 0 Then
      Select 编码 Into v_Parent From 诊疗分类目录 Where ID = 上级id_In;
    Else
      v_Parent := Null;
    End If;
    Begin
      Select Length(RTrim(编码_In)) - Length(RTrim(编码))
      Into v_Extend
      From 诊疗分类目录
      Where (上级id = 上级id_In Or 上级id Is Null And Nvl(上级id_In, 0) = 0) And ID <> Id_In And 类型 = 类型_In And Rownum = 1;
    Exception
      When Others Then
        v_Extend := 0;
    End;
    If v_Extend > 0 Then
      --扩充处理
      If v_Parent Is Null Then
        Update 诊疗分类目录 Set 编码 = LPad('0', v_Extend, '0') || 编码 Where ID <> Id_In And 类型 = 类型_In;
      Else
        Update 诊疗分类目录
        Set 编码 = v_Parent || LPad('0', v_Extend, '0') || Substr(编码, Length(v_Parent) + 1)
        Where 编码 Like v_Parent || '_%' And 类型 = 类型_In;
      End If;
    End If;
    If v_Extend < 0 Then
      --压缩处理
      If v_Parent Is Null Then
        Update 诊疗分类目录 Set 编码 = Substr(编码, 1 + Abs(v_Extend)) Where ID <> Id_In And 类型 = 类型_In;
      Else
        Update 诊疗分类目录
        Set 编码 = v_Parent || Substr(编码, Length(v_Parent) + 1 + Abs(v_Extend))
        Where 编码 Like v_Parent || '_%' And 类型 = 类型_In;
      End If;
    End If;
  End If;
  --添加本记录
  Insert Into 诊疗分类目录
    (ID, 上级id, 编码, 名称, 类型, 简码)
  Values
    (Id_In, Decode(上级id_In, 0, Null, 上级id_In), 编码_In, 名称_In, 类型_In, 简码_In);

  --消息处理，药品和卫材分类
  If 类型_In In (1, 2, 3) Then
    b_Message.Zlhis_Dict_025(类型_In, Id_In);
  Elsif 类型_In = 7 Then
    b_Message.Zlhis_Dict_050(类型_In, Id_In);
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_诊疗分类目录_Insert;
/

--120700:李业庆,2018-01-23,消息描点调整
Create Or Replace Procedure Zl_诊疗分类目录_Update
(
  Id_In      诊疗分类目录.Id%Type,
  上级id_In  诊疗分类目录.上级id%Type,
  编码_In    诊疗分类目录.编码%Type,
  名称_In    诊疗分类目录.名称%Type,
  简码_In    诊疗分类目录.简码%Type,
  v_Brethren Number
  --是否对同级编码进行长度处理,0-否,1-是
) As
  v_Oldcode Varchar2(20); --原来的编码
  v_Parent  Varchar2(20); --上级编码
  v_Extend  Number(20); --扩充长度(为负表示压缩)
  v_Kind    Number(1); --当前项目的类型
  Err_Notfind Exception;

Begin
  Select RTrim(编码), 类型 Into v_Oldcode, v_Kind From 诊疗分类目录 Where ID = Id_In;
  If v_Oldcode Is Null Then
    Raise Err_Notfind;
  End If;
  --修改项目本身
  Update 诊疗分类目录
  Set 上级id = Decode(上级id_In, 0, Null, 上级id_In), 编码 = 编码_In, 名称 = 名称_In, 简码 = 简码_In
  Where ID = Id_In;
  --修改本系各级下属编码
  Update 诊疗分类目录
  Set 编码 = 编码_In || Substr(编码, Length(v_Oldcode) + 1)
  Where 编码 <> 编码_In And 编码 Like v_Oldcode || '_%' And 类型 = v_Kind;
  --调整同级编码的长度
  If v_Brethren = 1 Then
    If Nvl(上级id_In, 0) <> 0 Then
      Select 编码 Into v_Parent From 诊疗分类目录 Where ID = 上级id_In;
    Else
      v_Parent := Null;
    End If;
    Begin
      Select Length(RTrim(编码_In)) - Length(RTrim(编码))
      Into v_Extend
      From 诊疗分类目录
      Where (上级id = 上级id_In Or 上级id Is Null And Nvl(上级id_In, 0) = 0) And ID <> Id_In And 类型 = v_Kind And Rownum = 1;
    Exception
      When Others Then
        v_Extend := 0;
    End;
    If v_Extend > 0 Then
      --扩充处理
      If v_Parent Is Null Then
        Update 诊疗分类目录
        Set 编码 = LPad('0', v_Extend, '0') || 编码
        Where 类型 = v_Kind And ID Not In (Select ID From 诊疗分类目录 Start With ID = Id_In Connect By Prior ID = 上级id);
      Else
        Update 诊疗分类目录
        Set 编码 = v_Parent || LPad('0', v_Extend, '0') || Substr(编码, Length(v_Parent) + 1)
        Where 类型 = v_Kind And 编码 Like v_Parent || '_%' And
              ID Not In (Select ID From 诊疗分类目录 Start With ID = Id_In Connect By Prior ID = 上级id);
      End If;
    End If;
    If v_Extend < 0 Then
      --压缩处理
      If v_Parent Is Null Then
        Update 诊疗分类目录
        Set 编码 = Substr(编码, 1 + Abs(v_Extend))
        Where ID Not In (Select ID
                         From 诊疗分类目录
                         Where 类型 = v_Kind
                         Start With 上级id = Id_In
                         Connect By Prior ID = 上级id
                         Union All
                         Select ID From 诊疗分类目录 Where 类型 = v_Kind And ID = Id_In) And 类型 = v_Kind;
      Else
        Update 诊疗分类目录
        Set 编码 = v_Parent || Substr(编码, Length(v_Parent) + 1 + Abs(v_Extend))
        Where 编码 Like v_Parent || '_%' And
              ID Not In (Select ID
                         From 诊疗分类目录
                         Where 类型 = v_Kind
                         Start With 上级id = Id_In
                         Connect By Prior ID = 上级id
                         Union All
                         Select ID From 诊疗分类目录 Where 类型 = v_Kind And ID = Id_In) And 类型 = v_Kind;
      End If;
    End If;
  End If;

  --消息处理，药品和卫材
  If v_Kind In (1, 2, 3) Then
    b_Message.Zlhis_Dict_026(v_Kind, Id_In);
  Elsif v_Kind = 7 Then
    b_Message.Zlhis_Dict_051(v_Kind, Id_In);
  End If;
Exception
  When Err_Notfind Then
    Raise_Application_Error(-20101, '[ZLSOFT]该项目不存在，可能已被其他用户删除！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_诊疗分类目录_Update;
/

--120700:李业庆,2018-01-23,消息描点调整
Create Or Replace Procedure Zl_诊疗分类目录_Delete(Id_In 诊疗分类目录.Id%Type) As
  n_类型 诊疗分类目录.类型%Type;
  v_编码 诊疗分类目录.编码%Type;
  v_名称 诊疗分类目录.名称%Type;
Begin
  Delete From 诊疗分类目录 Where ID = Id_In Returning 类型, 编码, 名称 Into n_类型, v_编码, v_名称;

  --消息处理，药品和卫材
  If n_类型 In (1, 2, 3) Then
    b_Message.Zlhis_Dict_027(n_类型, Id_In, v_编码, v_名称);
  Elsif n_类型 = 7 Then
    b_Message.Zlhis_Dict_052(n_类型, Id_In, v_编码, v_名称);
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_诊疗分类目录_Delete;
/

--120700:李业庆,2018-01-23,消息描点调整
Create Or Replace Procedure Zl_成药品种_Delete(Id_In In 诊疗项目目录.Id%Type) Is
  v_类别 诊疗项目目录.类别%Type;
  v_编码 诊疗项目目录.编码%Type;
  v_名称 诊疗项目目录.名称%Type;
Begin
  Delete 诊疗项目目录 Where ID = Id_In Returning 类别, 编码, 名称 Into v_类别, v_编码, v_名称;

  b_Message.Zlhis_Dict_032(v_类别, Id_In, v_编码, v_名称);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_成药品种_Delete;
/

--120700:李业庆,2018-01-23,消息描点调整
Create Or Replace Procedure Zl_成药规格_Delete(Id_In In 收费项目目录.Id%Type) Is
  v_类别 收费项目目录.类别%Type;
  v_编码 收费项目目录.编码%Type;
  v_名称 收费项目目录.名称%Type;
  v_规格 收费项目目录.规格%Type;
  v_产地 收费项目目录.产地%Type;
Begin
  Delete 收费项目目录
  Where ID = Id_In
  Returning 类别, 编码, 名称, 规格, 产地 Into v_类别, v_编码, v_名称, v_规格, v_产地;
  Delete From 保险支付项目 Where 收费细目id = Id_In;

  b_Message.Zlhis_Dict_037(v_类别, Id_In, v_编码, v_名称, v_规格, v_产地);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_成药规格_Delete;
/

--120700:李业庆,2018-01-23,消息描点调整
Create Or Replace Procedure Zl_卫生材料_Delete(Id_In In 收费项目目录.Id%Type) Is
  v_编码 收费项目目录.编码%Type;
  v_名称 收费项目目录.名称%Type;
  v_规格 收费项目目录.规格%Type;
  v_产地 收费项目目录.产地%Type;
Begin
  Delete 收费项目目录 Where ID = Id_In Returning 编码, 名称, 规格, 产地 Into v_编码, v_名称, v_规格, v_产地;
  b_Message.Zlhis_Dict_045(Id_In, v_编码, v_名称, v_规格, v_产地);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_卫生材料_Delete;
/

--117750:殷瑞,2018-02-01,新增按给药途径的配置费收取方案
--120700:李业庆,2018-01-23,消息描点调整
Create Or Replace Procedure Zl_输液配药记录_发送
(
  配药id_In   In Varchar2, --ID串:ID1,ID2....
  操作人员_In In 输液配药记录.操作人员%Type := Null,
  操作时间_In In 输液配药记录.操作时间%Type := Null,
  操作说明_In In 输液配药状态.操作说明%Type := Null
) Is
  v_Tansid     Varchar2(20);
  v_Tmp        Varchar2(4000);
  v_Error      Varchar2(255);
  n_操作状态   输液配药记录.操作状态%Type;
  n_People     Number(2);
  v_No         Varchar2(20);
  n_项目id     Number(18);
  v_收费项目id Varchar2(200);
  n_Row        Number(2);
  n_Out        Number(10);
  n_Outnum     Number(10);
  n_Count      Number(18);
  n_Packet     Number(2);
  v_Usercode   Varchar2(100);
  v_复核人     Varchar2(20);
  Err_Custom Exception;

  Cursor c_Bill Is
    Select a.病人id, a.主页id, a.标识号, a.姓名, a.性别, a.年龄, a.床号, a.费别, a.病人病区id, a.病人科室id, a.婴儿费, e.药品id, b.库房id, f.配药类型,
           c.执行时间
    From 住院费用记录 A, 药品收发记录 B, 输液配药记录 C, 输液配药内容 D, 药品规格 E, 输液药品属性 F, 配置收费方案 G
    Where a.Id = b.费用id And b.Id = d.收发id And d.记录id = c.Id And b.药品id = e.药品id And b.药品id = f.药品id And
          Substr(f.配药类型, Instr(f.配药类型, '-') + 1) = g.配药类型(+) And Nvl(c.是否打包, 0) <> 0 And c.Id = v_Tansid
    Order By g.序号;
Begin
  v_Usercode := Zl_Identity;
  v_Usercode := Substr(v_Usercode, Instr(v_Usercode, ';') + 1);
  v_Usercode := Substr(v_Usercode, Instr(v_Usercode, ',') + 1);
  v_Usercode := Substr(v_Usercode, 1, Instr(v_Usercode, ',') - 1);
  n_People   := Nvl(zl_GetSysParameter('配置费按病人收取', 1345), 0);
  n_Out      := Nvl(zl_GetSysParameter('出院病人不收配置费', 1345), 0);
  n_Packet   := Nvl(zl_GetSysParameter('打包药品在发送环节收取配置费', 1345), 0);

  If 配药id_In Is Null Then
    v_Tmp := Null;
  Else
    v_Tmp := 配药id_In || ',';
  End If;
  While v_Tmp Is Not Null Loop
    --分解单据ID串
    v_Tansid := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
    v_Tmp    := Replace(',' || v_Tmp, ',' || v_Tansid || ',');
  
    Begin
      Select 操作状态 Into n_操作状态 From 输液配药记录 Where ID = v_Tansid;
    
      If n_操作状态 > 4 Then
        v_Error := '该数据已被操作，不能进行发送操作！';
        Raise Err_Custom;
      End If;
    Exception
      When Others Then
        v_Error := '该数据已被操作！';
        Raise Err_Custom;
    End;
  
    v_复核人 := '';
    Begin
      Select 复核人
      Into v_复核人
      From (Select e.复核人
             From 输液配药记录 A, 输液配药内容 B, 药品收发记录 C, 配液台药品对照 D, 配液工作安排 E
             Where a.Id = b.记录id And b.收发id = c.Id And c.药品id = d.药品id And c.库房id = d.部门id And d.配药台id = e.配药台id And
                   a.配药批次 = e.批次 And e.日期 = To_Date(To_Char(Sysdate, 'yyyy-mm-dd'), 'yyyy-mm-dd') And a.Id = v_Tansid And
                   Rownum = 1
             Order By d.配药台id)
      Where Rownum = 1;
    Exception
      When Others Then
        Null;
    End;
  
    Insert Into 输液配药状态
      (配药id, 操作类型, 操作人员, 操作时间, 操作说明, 实际工作人员)
    Values
      (v_Tansid, 5, 操作人员_In, 操作时间_In, 操作说明_In, v_复核人);
    Update 输液配药记录 Set 操作状态 = 5, 操作人员 = 操作人员_In, 操作时间 = 操作时间_In Where ID = v_Tansid;
  
    --打包药品收费
    If n_Packet = 1 Then
      n_Count := 0;
      Select Nextno(14) Into v_No From Dual;
    
      For r_Bill In c_Bill Loop
        Select Count(病人id)
        Into n_Outnum
        From 病案主页
        Where 主页id = r_Bill.主页id And 病人id = r_Bill.病人id And (Nvl(状态, 0) = 3 Or 出院日期 Is Not Null);
      
        --先查询是否有按给药途径收取的配置费方案
        Select Nvl(Max(项目id), 0)
        Into n_项目id
        From 输液配药记录 A, 病人医嘱记录 B, 配置收费方案 C
        Where a.Id = v_Tansid And a.医嘱id = b.Id And b.诊疗项目id = c.诊疗id;
        If n_项目id = 0 Then
          --若无对应给药途径的配置费收取方案，则再查询是否有按配药类型收取的配置费方案
          Select Nvl(Max(项目id), 0)
          Into n_项目id
          From 配置收费方案
          Where 配药类型 = Substr(r_Bill.配药类型, Instr(r_Bill.配药类型, '-', 1, 1) + 1);
        End If;
      
        If n_项目id <> 0 Then
          n_Row := 0;
          
          If n_People = 1 Then
            Select Count(配药id)
            Into n_Row
            From 输液配药附费 A, 住院费用记录 B, 输液配药记录 C
            Where a.No = b.No And a.配药id = c.Id And b.病人id = r_Bill.病人id And b.记录状态 = 1 And b.收费细目id = n_项目id And
                  r_Bill.执行时间 Between Trunc(c.执行时间) And Trunc(c.执行时间 + 1) - 1 / 24 / 60 / 60;
          End If;
        Else
          n_Row := 1;
        End If;
      
        If n_Row = 0 And (n_Outnum = 0 Or n_Out = 0) Then
          For r_Item In (Select a.Id 收费细目id, a.类别 收费类别, a.计算单位, a.加班加价 加班标志, d.Id 收入项目id, d.收据费目, b.现价
                         From 收费项目目录 A, 收费价目 B, 收入项目 D
                         Where a.Id = b.收费细目id And b.收入项目id = d.Id And a.Id = n_项目id And b.执行日期 <= Sysdate And
                               (b.终止日期 >= Sysdate Or b.终止日期 Is Null)) Loop
            If n_Count = 0 Then
              Insert Into 输液配药附费 (配药id, NO, 病人id) Values (v_Tansid, v_No, r_Bill.病人id);
            End If;
          
            n_Count := n_Count + 1;
            Zl_住院记帐记录_Insert(v_No, n_Count, r_Bill.病人id, r_Bill.主页id, r_Bill.标识号, r_Bill.姓名, r_Bill.性别, r_Bill.年龄,
                             r_Bill.床号, r_Bill.费别, r_Bill.病人病区id, r_Bill.病人科室id, r_Item.加班标志, r_Bill.婴儿费, r_Bill.库房id,
                             操作人员_In, Null, r_Item.收费细目id, r_Item.收费类别, r_Item.计算单位, Null, Null, Null, 1, 1, Null,
                             r_Bill.库房id, Null, r_Item.收入项目id, r_Item.收据费目, r_Item.现价, r_Item.现价, r_Item.现价, Null,
                             Sysdate, Sysdate, Null, Null, v_Usercode, 操作人员_In);
          End Loop;
        End If;
      
        If n_Row = 0 Then
          Exit;
        End If;
      End Loop;
    End If;
  End Loop;

  --消息处理
  b_Message.Zlhis_Drug_008(配药id_In);
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_输液配药记录_发送;
/

--120700:李业庆,2018-01-23,消息描点调整,取消原消息
Create Or Replace Procedure Zl_输液配药记录_审核
(
  医嘱id_In   In Varchar2, --ID串:ID1,操作1||ID2,操作1....
  审核药师_In In Varchar2 := Null
) Is
  v_Tansid Varchar2(20);
  v_Tmp    Varchar2(4000);
  v_Fields Varchar2(50);
  v_状态   Varchar2(2);
Begin
  If 医嘱id_In Is Null Then
    v_Tmp := Null;
  Else
    v_Tmp := 医嘱id_In;
  End If;

  While v_Tmp Is Not Null Loop
    --分解单据ID串
    v_Fields := Substr(v_Tmp, 1, Instr(v_Tmp, '|') - 1);
    v_Tansid := Substr(v_Fields, 1, Instr(v_Fields, ',') - 1);
    v_状态   := Substr(v_Fields, Instr(v_Fields, ',') + 1);
  
    v_Tmp := Replace('|' || v_Tmp, '|' || v_Fields || '|');
  
    If 审核药师_In Is Null And v_状态 <> '0' Then
      Update 病人医嘱记录
      Set 药师审核标志 = v_状态, 药师审核时间 = Sysdate
      Where ID = v_Tansid And Nvl(药师审核标志, 0) = 0;
    Else
      If v_状态 = '0' Then
        Update 病人医嘱记录 Set 药师审核标志 = v_状态, 药师审核时间 = Null, 审核药师 = Null Where ID = v_Tansid;
      Else
        Update 病人医嘱记录
        Set 药师审核标志 = v_状态, 药师审核时间 = Sysdate, 审核药师 = 审核药师_In
        Where ID = v_Tansid;
      End If;
    End If;
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_输液配药记录_审核;
/

--120700:李业庆,2018-01-23,消息描点调整
--121116:李业庆,2018-01-29,无库存调价时更新药品批号对照
Create Or Replace Procedure Zl_药品收发记录_Adjust
(
  药品id_In   In Number, --药品ID,为0时检查所有预调价
  调价方式_In In Number := 0 --0-检查售价和成本价预调价,1-只检查售价预调价,2-只检查成本价预调价
) As
  Classid          Number(18); --入出类别
  v_Billno         药品收发记录.No%Type; --调价单号
  Adjustdate       Date; --调价时间
  n_批次           Number(18);
  n_现价           收费价目.现价%Type;
  n_原价           收费价目.原价%Type;
  n_序号           Number(8);
  n_原价id         收费价目.原价id%Type;
  n_零售金额       药品库存.实际金额%Type;
  n_收发id         药品收发记录.Id%Type;
  n_流通金额小数   Number;
  n_Stockid        药品收发记录.库房id%Type;
  n_入出类别id     药品收发记录.入出类别id%Type;
  n_入出系数       药品收发记录.入出系数%Type;
  n_价格id         收费价目.Id%Type;
  n_无库存调价模式 Number(1) := 0;
  n_分批属性       Number(1) := 0;
  n_消息调用       Number(1) := 0;
  --定价售价，时价售价预调价记录
  --价格类型：0-定价售价,1-时价售价
  Cursor c_Priceadjust Is
    Select 0 As 价格类型, p.Id As 价格id, p.原价id, p.执行日期, p.原价, p.现价, i.药品id, s.库房id As 库房id, Nvl(s.批次, 0) As 批次, s.上次批号 As 批号,
           s.效期, s.上次产地 As 产地, s.上次供应商id As 供应商id, Nvl(s.实际数量, 0) As 实际数量, s.上次扣率 As 扣率, Nvl(s.实际金额, 0) As 实际金额,
           Nvl(s.实际差价, 0) As 实际差价, Nvl(s.零售价, 0) As 零售价, s.平均成本价, s.Rowid As 库存记录, s.灭菌效期, s.批准文号, s.上次生产日期 As 生产日期,
           p.调价汇总号
    From 收费价目 P, 药品规格 I, 收费项目目录 A, 药品库存 S
    Where i.药品id = a.Id And p.收费细目id = i.药品id And i.药品id = s.药品id(+) And s.性质(+) = 1 And Nvl(a.是否变价, 0) = 0 And
          Sysdate Between p.执行日期 And Nvl(p.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And Nvl(p.变动原因, 0) = 0 And
          p.收费细目id = Decode(药品id_In, 0, p.收费细目id, 药品id_In) And 调价方式_In In (0, 1)
    Union All
    Select 价格类型, p.Id As 价格id, p.原价id, p.执行日期, p.原价, p.现价, i.药品id, p.库房id As 库房id, Nvl(p.批次, 0) As 批次, p.批号 As 批号, p.效期,
           p.产地 As 产地, s.上次供应商id As 供应商id, Nvl(s.实际数量, 0) As 实际数量, s.上次扣率 As 扣率, Nvl(s.实际金额, 0) As 实际金额,
           Nvl(s.实际差价, 0) As 实际差价, Nvl(s.零售价, 0) As 零售价, s.平均成本价, s.Rowid As 库存记录, s.灭菌效期, s.批准文号, s.上次生产日期 As 生产日期,
           p.调价汇总号
    From 药品价格记录 P, 药品规格 I, 收费项目目录 A, 药品库存 S
    Where i.药品id = a.Id And p.药品id = i.药品id And p.库房id = s.库房id(+) And p.药品id = s.药品id(+) And
          Nvl(p.批次, 0) = Nvl(s.批次(+), 0) And s.性质(+) = 1 And Sysdate Between p.执行日期 And
          Nvl(p.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And Nvl(p.记录状态, 0) = 0 And
          p.药品id = Decode(药品id_In, 0, p.药品id, 药品id_In) And 价格类型 = 1 And 调价方式_In In (0, 1)
    Order By 价格类型, 药品id, 批次, 库房id;

  r_Priceadjust c_Priceadjust%RowType;

  --成本价预调价记录
  Cursor c_Costadjust Is
    Select 价格类型, p.Id As 价格id, p.原价id, p.执行日期, p.原价, p.现价, i.药品id, p.库房id As 库房id, Nvl(p.批次, 0) As 批次, p.批号 As 批号, p.效期,
           p.产地 As 产地, s.上次供应商id As 供应商id, Nvl(s.实际数量, 0) As 实际数量, s.上次扣率 As 扣率, Nvl(s.实际金额, 0) As 实际金额,
           Nvl(s.实际差价, 0) As 实际差价, Nvl(s.零售价, 0) As 零售价, s.平均成本价, s.Rowid As 库存记录, s.灭菌效期, s.批准文号, s.上次生产日期 As 生产日期,
           p.调价汇总号
    From 药品价格记录 P, 药品规格 I, 收费项目目录 A, 药品库存 S
    Where i.药品id = a.Id And p.药品id = i.药品id And p.库房id = s.库房id(+) And p.药品id = s.药品id(+) And
          Nvl(p.批次, 0) = Nvl(s.批次(+), 0) And s.性质(+) = 1 And Sysdate Between p.执行日期 And
          Nvl(p.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And Nvl(p.记录状态, 0) = 0 And
          p.药品id = Decode(药品id_In, 0, p.药品id, 药品id_In) And 价格类型 = 2 And 调价方式_In In (0, 2)
    Order By 药品id, 批次, 库房id;

  r_Costadjust c_Costadjust%RowType;

  --当前生效的价格，用于无库存调价
  Cursor c_Nostockadjust
  (
    Drugid_In 药品价格记录.药品id%Type,
    Type_In   药品价格记录.价格类型%Type
  ) Is
    Select a.价格类型, a.Id As 价格id, a.原价, a.现价, a.药品id, a.库房id, a.批次, a.供药单位id, a.批号, a.效期, a.产地
    From 药品价格记录 A
    Where Sysdate Between a.执行日期 And Nvl(a.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And a.记录状态 = 1 And
          a.药品id = Drugid_In And a.价格类型 = Type_In And a.库房id Is Not Null
    Order By a.库房id, a.药品id, a.批次;

  r_Nostockadjust c_Nostockadjust%RowType;
Begin
  --取流通业务精度位数
  --类别:1-药品 2-卫材
  --内容：2-零售价 4-金额
  --单位：药品:1-售价 5-金额单位
  Select 精度 Into n_流通金额小数 From 药品卫材精度 Where 类别 = 1 And 内容 = 4 And 单位 = 5;

  --取入出类别ID
  Select 类别id Into Classid From 药品单据性质 Where 单据 = 13;

  Adjustdate := Sysdate;

  --售价调价处理
  If 调价方式_In = 0 Or 调价方式_In = 1 Then
  
    n_序号 := 0;
  
    --取调价NO取
    Select Nextno(147) Into v_Billno From Dual;
  
    For r_Priceadjust In c_Priceadjust Loop
      If r_Priceadjust.库房id Is Not Null Then
        --有库房id正常调价
      
        --取分批属性
        n_分批属性 := Zl_Fun_Getbatchpro(r_Priceadjust.库房id, r_Priceadjust.药品id);
      
        --产生调价盈亏记录的条件：1.要有库存记录，2.分批属性和库存批次一致，3.库存实际数量不为0
        If r_Priceadjust.库存记录 Is Not Null And (n_分批属性 = 1 And r_Priceadjust.批次 > 0) Or
           (n_分批属性 = 0 And r_Priceadjust.批次 = 0) And r_Priceadjust.实际数量 <> 0 Then
          n_序号 := n_序号 + 1;
        
          Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
        
          n_原价 := r_Priceadjust.原价;
        
          --时价调价，如果原价和当前库存不一致，则以当前库存为准
          If r_Priceadjust.价格类型 = 1 And r_Priceadjust.原价 <> r_Priceadjust.零售价 And r_Priceadjust.库存记录 Is Not Null Then
            n_原价 := r_Priceadjust.零售价;
          End If;
        
          n_零售金额 := Round(r_Priceadjust.现价 * r_Priceadjust.实际数量, n_流通金额小数) - Round(n_原价 * r_Priceadjust.实际数量, n_流通金额小数);
        
          n_价格id := r_Priceadjust.价格id;
          If r_Priceadjust.价格类型 = 1 Then
            Select ID
            Into n_价格id
            From 收费价目
            Where Sysdate Between 执行日期 And Nvl(终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And 收费细目id = r_Priceadjust.药品id;
          End If;
        
          --产生调价影响记录
          Insert Into 药品收发记录
            (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 零售金额, 差价, 摘要, 填制人,
             填制日期, 库房id, 入出系数, 价格id, 审核人, 审核日期, 单量, 频次, 供药单位id)
          Values
            (n_收发id, 1, 13, v_Billno, n_序号, Classid, r_Priceadjust.药品id, r_Priceadjust.批次, r_Priceadjust.批号,
             r_Priceadjust.效期, r_Priceadjust.产地, 1, r_Priceadjust.实际数量, 0, n_原价, 0, r_Priceadjust.现价, r_Priceadjust.扣率,
             n_零售金额, n_零售金额, '药品调价', Zl_Username, Adjustdate, r_Priceadjust.库房id, 1, n_价格id, Zl_Username, Adjustdate,
             r_Priceadjust.实际金额, r_Priceadjust.实际差价, r_Priceadjust.供应商id);
        
          Zl_未审药品记录_Insert(n_收发id);
        
          --更新药品库存，无库存不执行
          If r_Priceadjust.库存记录 Is Not Null Then
            Zl_药品库存_Update(n_收发id, 2, 0);
          End If;
        End If;
      
        --更新原价格信息
        If r_Priceadjust.价格类型 = 1 Then
          Update 药品价格记录 Set 记录状态 = 2 Where ID = r_Priceadjust.原价id;
        End If;
      
        --时价调价更新价格表中的信息
        If r_Priceadjust.价格类型 = 1 Then
          --更新当前价格信息
          If r_Priceadjust.库存记录 Is Not Null Then
            Update 药品价格记录
            Set 批号 = r_Priceadjust.批号, 效期 = r_Priceadjust.效期, 产地 = r_Priceadjust.产地, 灭菌效期 = r_Priceadjust.灭菌效期,
                供药单位id = r_Priceadjust.供应商id, 原价 = n_原价, 收发id = n_收发id, 记录状态 = 1
            Where ID = r_Priceadjust.价格id;
          Else
            --无库存时只更新记录状态，收发id
            Update 药品价格记录 Set 收发id = n_收发id, 记录状态 = 1 Where ID = r_Priceadjust.价格id;
          End If;
        End If;
      
        --更新批号对照表售价
        If r_Priceadjust.价格类型 = 1 Then
          --如果是时价，则更新该药品批次对应的价格
          Update 药品批号对照
          Set 售价 = r_Priceadjust.现价
          Where 药品id = r_Priceadjust.药品id And Nvl(批次, 0) = r_Priceadjust.批次 And 售价 <> r_Priceadjust.现价;
        End If;
      
        --消息处理
        --定价只调用一次消息，时价可多次调用
        If (r_Priceadjust.价格类型 = 0 And n_消息调用 = 0) Or r_Priceadjust.价格类型 = 1 Then
          n_消息调用 := 1;
          b_Message.Zlhis_Drug_009(r_Priceadjust.价格id, r_Priceadjust.价格类型);
        End If;
      Else
        --无库存调价模式，价格表中该药品所有生效的价格都要按无库存调价时的价格调整
      
        If r_Priceadjust.价格类型 = 1 Then
          --更新原价格信息
          Update 药品价格记录 Set 记录状态 = 2 Where ID = r_Priceadjust.原价id;
        
          --更新现价格状态
          Update 药品价格记录 Set 记录状态 = 1 Where ID = r_Priceadjust.价格id;
        End If;
      
        n_无库存调价模式 := 0;
        For r_Nostockadjust In c_Nostockadjust(r_Priceadjust.药品id, 1) Loop
          If r_Priceadjust.现价 <> r_Nostockadjust.现价 Then
            Zl_药品价格记录_Stop(1, r_Nostockadjust.库房id, r_Nostockadjust.药品id, r_Nostockadjust.批次,
                           Adjustdate - 2 / 24 / 60 / 60);
            Zl_药品价格记录_Insert(1, 1, r_Nostockadjust.库房id, r_Nostockadjust.药品id, r_Nostockadjust.批次, Null,
                             r_Priceadjust.现价, Adjustdate - 1 / 24 / 60 / 60, '药品调价', Zl_Username, r_Priceadjust.调价汇总号,
                             r_Nostockadjust.供药单位id, r_Nostockadjust.批号, r_Nostockadjust.效期, r_Nostockadjust.产地);
            n_无库存调价模式 := 1;
          End If;
        End Loop;
        If n_无库存调价模式 = 1 Then
          Zl_药品收发记录_Adjust(r_Priceadjust.药品id, 1);
        End If;
      End If;
    
      --更新规格价格
      If r_Priceadjust.现价 <> r_Priceadjust.原价 Then
        Update 药品规格
        Set 上次售价 = r_Priceadjust.现价
        Where 药品id = r_Priceadjust.药品id And 上次售价 <> r_Priceadjust.现价;
      End If;
    
      If r_Priceadjust.价格类型 = 0 Then
        n_价格id := r_Priceadjust.价格id;
      Else
        Begin
          Select ID
          Into n_价格id
          From 收费价目
          Where Sysdate Between 执行日期 And Nvl(终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And Nvl(变动原因, 0) = 0 And
                收费细目id = r_Priceadjust.药品id;
        Exception
          When Others Then
            n_价格id := 0;
        End;
      End If;
    
      If n_价格id > 0 Then
        Update 收费价目 Set 变动原因 = 1 Where Nvl(变动原因, 0) = 0 And ID = n_价格id;
      End If;
    
      --更新批号对照表售价
      If r_Priceadjust.价格类型 = 0 Then
        --如果是定价，则更新该药品对应的所有批次的售价
        Update 药品批号对照
        Set 售价 = r_Priceadjust.现价
        Where 药品id = r_Priceadjust.药品id And 售价 <> r_Priceadjust.现价;
      End If;
    End Loop;
  End If;

  --成本价调价处理
  If 调价方式_In = 0 Or 调价方式_In = 2 Then
  
    n_序号    := 0;
    n_Stockid := 0;
  
    Select b.Id, b.系数
    Into n_入出类别id, n_入出系数
    From 药品单据性质 A, 药品入出类别 B
    Where a.类别id = b.Id And a.单据 = 5 And Rownum < 2;
  
    v_Billno := Nextno(25, n_Stockid);
  
    For r_Costadjust In c_Costadjust Loop
      If r_Costadjust.库房id Is Not Null Then
        --有库房id正常调价
      
        --取分批属性
        n_分批属性 := Zl_Fun_Getbatchpro(r_Costadjust.库房id, r_Costadjust.药品id);
      
        --产生调价盈亏记录的条件：1.要有库存记录，2.分批属性和库存批次一致，3.库存实际数量不为0
        If r_Costadjust.库存记录 Is Not Null And (n_分批属性 = 1 And r_Costadjust.批次 > 0) Or
           (n_分批属性 = 0 And r_Costadjust.批次 = 0) And r_Costadjust.实际数量 <> 0 Then
          n_序号 := n_序号 + 1;
        
          --产生库存差价调整单
          Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
        
          --如果原价和当前库存不一致，则以当前库存为准
          n_原价 := r_Costadjust.原价;
          If r_Costadjust.原价 <> r_Costadjust.平均成本价 And r_Costadjust.库存记录 Is Not Null Then
            n_原价 := r_Costadjust.平均成本价;
          End If;
        
          n_零售金额 := Round(n_原价 * r_Costadjust.实际数量, n_流通金额小数) - Round(r_Costadjust.现价 * r_Costadjust.实际数量, n_流通金额小数);
        
          Insert Into 药品收发记录
            (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 供药单位id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 实际数量, 零售价, 零售金额, 成本价, 成本金额,
             差价, 摘要, 填制人, 填制日期, 审核人, 审核日期, 生产日期, 批准文号, 单量, 发药方式, 扣率, 灭菌效期)
          Values
            (n_收发id, 1, 5, v_Billno, n_序号, r_Costadjust.库房id, n_入出类别id, r_Costadjust.供应商id, n_入出系数, r_Costadjust.药品id,
             r_Costadjust.批次, r_Costadjust.产地, r_Costadjust.批号, r_Costadjust.效期, r_Costadjust.实际数量, 0, r_Costadjust.实际金额,
             0, r_Costadjust.实际差价, 0, n_零售金额, '成本价调价', Zl_Username, Adjustdate, Zl_Username, Adjustdate,
             r_Costadjust.生产日期, r_Costadjust.批准文号, r_Costadjust.现价, 1, n_原价, r_Costadjust.灭菌效期);
        
          Zl_未审药品记录_Insert(n_收发id);
        
          Zl_药品库存_Update(n_收发id, 2, 0);
        
          --更新当前价格信息
          Update 药品价格记录
          Set 批号 = r_Costadjust.批号, 效期 = r_Costadjust.效期, 产地 = r_Costadjust.产地, 灭菌效期 = r_Costadjust.灭菌效期,
              供药单位id = r_Costadjust.供应商id, 原价 = n_原价, 收发id = n_收发id, 记录状态 = 1
          Where ID = r_Costadjust.价格id;
        Else
          --无库存时只更新记录状态
          Update 药品价格记录 Set 记录状态 = 1 Where ID = r_Costadjust.价格id;
        End If;
      
        --更新原价格信息
        Update 药品价格记录 Set 记录状态 = 2 Where ID = r_Costadjust.原价id;
      
        --更新批号对照表成本价
        Update 药品批号对照
        Set 成本价 = r_Costadjust.现价
        Where 药品id = r_Costadjust.药品id And Nvl(批次, 0) = r_Costadjust.批次 And 成本价 <> r_Costadjust.现价;
      Else
        --无库存调价模式，价格表中该药品所有生效的价格都要按无库存调价时的价格调整
      
        --更新原价格信息
        Update 药品价格记录 Set 记录状态 = 2 Where ID = r_Costadjust.原价id;
      
        --更新现价格状态
        Update 药品价格记录 Set 记录状态 = 1 Where ID = r_Costadjust.价格id;
      
        n_无库存调价模式 := 0;
        For r_Nostockadjust In c_Nostockadjust(r_Costadjust.药品id, 2) Loop
          If r_Costadjust.现价 <> r_Nostockadjust.现价 Then
            Zl_药品价格记录_Stop(2, r_Nostockadjust.库房id, r_Nostockadjust.药品id, r_Nostockadjust.批次,
                           Adjustdate - 2 / 24 / 60 / 60);
            Zl_药品价格记录_Insert(1, 2, r_Nostockadjust.库房id, r_Nostockadjust.药品id, r_Nostockadjust.批次, Null,
                             r_Costadjust.现价, Adjustdate - 1 / 24 / 60 / 60, '成本价调价', Zl_Username, r_Costadjust.调价汇总号,
                             r_Nostockadjust.供药单位id, r_Nostockadjust.批号, r_Nostockadjust.效期, r_Nostockadjust.产地);
            n_无库存调价模式 := 1;
          End If;
        End Loop;
        If n_无库存调价模式 = 1 Then
          Zl_药品收发记录_Adjust(r_Costadjust.药品id, 2);
        End If;
      End If;
    
      --更新规格价格
      If r_Costadjust.原价 <> r_Costadjust.现价 Then
        Update 药品规格
        Set 成本价 = r_Costadjust.现价
        Where 药品id = r_Costadjust.药品id And 成本价 <> r_Costadjust.现价;
      End If;
    
      --消息处理
      b_Message.Zlhis_Drug_007(r_Costadjust.价格id);
    End Loop;
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_Adjust;
/

--120700:李业庆,2018-01-23,消息描点调整
Create Or Replace Procedure Zl_材料收发记录_成本价调价(材料id_In In 药品收发记录.药品id%Type) As
  v_No         药品收发记录.No%Type;
  v_应付id     应付记录.Id%Type; --应付记录的ID 
  v_应付单据号 应付记录.No%Type;
  d_调价时间   Date;
  n_序号       Number(8);
  n_库房id     药品收发记录.库房id%Type;
  n_入出类别id 药品收发记录.入出类别id%Type;
  n_入出系数   药品收发记录.入出系数%Type;
  n_收发id     药品收发记录.Id%Type;
  n_调整额     药品收发记录.零售金额%Type;
  n_原成本价   药品收发记录.成本价%Type;
  n_新成本价   药品收发记录.成本价%Type;
  n_平均成本价 药品库存.平均成本价%Type;
  v_调价id     成本价调价信息.Id%Type;
  v_调价汇总号 成本价调价信息.调价汇总号%Type;
  n_Count      Number(1) := 0;

  Cursor c_Stock Is --当前库存 
    Select 上次供应商id, a.库房id, a.药品id As 材料id, Nvl(a.批次, 0) As 批次, a.上次批号, a.效期, a.上次产地, a.灭菌效期,
           Decode(Sign(Nvl(a.批次, 0)), 1, a.上次采购价, a.平均成本价) As 原成本价
    From 药品库存 A
    Where a.性质 = 1 And Nvl(a.实际数量, 0) <> 0 And a.药品id = 材料id_In
    Order By a.库房id;

  v_Stock c_Stock%RowType;
Begin
  d_调价时间 := Sysdate;
  n_库房id   := 0;

  --判断是否存在无库存调价 
  Begin
    Select ID, 新成本价, 调价汇总号
    Into v_调价id, n_新成本价, v_调价汇总号
    From 成本价调价信息
    Where 执行日期 Is Null And Nvl(库房id, 0) = 0 And 药品id = 材料id_In;
  Exception
    When Others Then
      v_调价id   := 0;
      n_新成本价 := Null;
  End;

  --无库存调价 
  If v_调价id > 0 Then
    --根据当前库存重新产生调价信息 
    For v_Stock In c_Stock Loop
      Zl_材料成本调价_Insert(v_Stock.上次供应商id, v_Stock.库房id, v_Stock.材料id, v_Stock.批次, v_Stock.上次批号, v_Stock.原成本价, n_新成本价,
                       Null, Null, 0, 0, v_调价汇总号);
      n_Count := n_Count + 1;
    End Loop;
  
    If n_Count > 0 Then
      --如果当前有库存记录，则删除无库存调价记录 
      Delete 成本价调价信息 Where ID = v_调价id;
    Else
      Update 成本价调价信息 Set 执行日期 = d_调价时间 Where ID = v_调价id;
    
      Update 材料特性 Set 成本价 = n_新成本价 Where 材料id = 材料id_In And 成本价 <> n_新成本价;
    End If;
  End If;

  --取库存差价调整的入出类别ID 
  Select b.Id, b.系数
  Into n_入出类别id, n_入出系数
  From 药品单据性质 A, 药品入出类别 B
  Where a.类别id = b.Id And a.单据 = 33 And Rownum < 2;

  For c_成本调整 In (Select a.库房id, a.药品id As 材料id, Nvl(a.批次, 0) 批次, a.上次供应商id, a.实际数量, a.实际金额, a.实际差价, a.上次产地 As 产地,
                        a.上次批号 As 批号, a.灭菌效期, a.效期, a.上次生产日期 As 生产日期, a.批准文号, Nvl(a.平均成本价, 0) As 原成本价, b.新成本价, b.发票号,
                        b.发票日期, b.发票金额, Nvl(a.上次采购价, 0) As 上次采购价, b.Id As 调价id
                 From 药品库存 A, 成本价调价信息 B
                 Where a.药品id = b.药品id And Nvl(a.上次供应商id, 0) = Nvl(b.供药单位id, 0) And a.库房id = b.库房id And
                       Nvl(a.批次, 0) = Nvl(b.批次, 0) And a.性质 = 1 And b.执行日期 Is Null And a.药品id = 材料id_In
                 Order By a.库房id) Loop
    If n_库房id <> c_成本调整.库房id Then
      n_序号   := 1;
      n_库房id := c_成本调整.库房id;
      v_No     := Nextno(71, n_库房id);
    Else
      n_序号 := n_序号 + 1;
    End If;
  
    Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
    If Nvl(c_成本调整.实际数量, 0) = 0 And Nvl(c_成本调整.实际金额, 0) = 0 And Nvl(c_成本调整.实际差价, 0) = 0 Then
      --数量,金额、差价都为0，则表示数据是填单下可用数量出库产生的单据，此单据还没有审核，因此只需要更新调价信息，其他不更新
      Update 材料特性 Set 成本价 = c_成本调整.新成本价 Where 材料id = c_成本调整.材料id;
    
      Update 成本价调价信息
      Set 收发id = n_收发id, 执行日期 = d_调价时间, 效期 = c_成本调整.效期, 灭菌效期 = c_成本调整.灭菌效期, 产地 = c_成本调整.产地, 批号 = c_成本调整.批号
      Where ID = c_成本调整.调价id;
    Elsif Nvl(c_成本调整.实际数量, 0) = 0 And (Nvl(c_成本调整.实际金额, 0) <> 0 Or Nvl(c_成本调整.实际差价, 0) <> 0) Then
      --数量=0 金额或差价<>0时只更新库存表中对应的平均成本价和特性表中成本价，并产生成本价修正数据但是差价差=0，只记录最新成本价 
      --产生调价记录，只记录最新成本价 
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 供药单位id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 零售价, 成本价, 差价, 摘要, 填制人, 填制日期, 审核人,
         审核日期, 生产日期, 批准文号, 单量, 发药方式, 扣率)
      Values
        (n_收发id, 1, 18, v_No, n_序号, c_成本调整.库房id, n_入出类别id, c_成本调整.上次供应商id, n_入出系数, c_成本调整.材料id, c_成本调整.批次, c_成本调整.产地,
         c_成本调整.批号, c_成本调整.效期, 0, c_成本调整.实际金额, c_成本调整.实际差价, 0, '卫生材料成本价调价', Zl_Username, d_调价时间, Zl_Username, d_调价时间,
         c_成本调整.生产日期, c_成本调整.批准文号, c_成本调整.新成本价, 1, c_成本调整.原成本价);
    
      Zl_未审药品记录_Insert(n_收发id);
      --更新库存 
      Update 药品库存
      Set 平均成本价 = c_成本调整.新成本价, 上次采购价 = c_成本调整.新成本价
      Where 库房id = c_成本调整.库房id And 药品id = c_成本调整.材料id And Nvl(批次, 0) = c_成本调整.批次 And 性质 = 1;
      Update 材料特性 Set 成本价 = c_成本调整.新成本价 Where 材料id = c_成本调整.材料id;
    
      Update 成本价调价信息
      Set 收发id = n_收发id, 执行日期 = d_调价时间, 效期 = c_成本调整.效期, 灭菌效期 = c_成本调整.灭菌效期, 产地 = c_成本调整.产地, 批号 = c_成本调整.批号
      Where ID = c_成本调整.调价id;
    Else
      --调整相应的库存:原成本金额-实新成本金额 
      n_调整额   := (c_成本调整.实际金额 - c_成本调整.实际差价) - Round(c_成本调整.新成本价 * c_成本调整.实际数量, 2);
      n_原成本价 := c_成本调整.原成本价;
    
      If n_原成本价 <= 0 Then
        n_原成本价 := c_成本调整.上次采购价;
      End If;
    
      --目前：收发记录对应: 
      -- 扣率--> 原成本价 
      -- 单量-->新成本价 
      -- 填写数量-->库存实际数量 
      -- 零售价-->库存实际金额 
      -- 成本价-->库存实际差价 
      -- 差价-->本次调整额 
    
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 供药单位id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 零售价, 成本价, 差价, 摘要, 填制人, 填制日期, 审核人,
         审核日期, 生产日期, 批准文号, 单量, 发药方式, 扣率)
      Values
        (n_收发id, 1, 18, v_No, n_序号, c_成本调整.库房id, n_入出类别id, c_成本调整.上次供应商id, n_入出系数, c_成本调整.材料id, c_成本调整.批次, c_成本调整.产地,
         c_成本调整.批号, c_成本调整.效期, c_成本调整.实际数量, c_成本调整.实际金额, c_成本调整.实际差价, n_调整额, '卫生材料成本价调价', Zl_Username, d_调价时间,
         Zl_Username, d_调价时间, c_成本调整.生产日期, c_成本调整.批准文号, c_成本调整.新成本价, 1, n_原成本价);
    
      Zl_未审药品记录_Insert(n_收发id);
      --更新库存 
      Update 药品库存
      Set 实际差价 = Nvl(实际差价, 0) + n_调整额
      Where 库房id = c_成本调整.库房id And 药品id = c_成本调整.材料id And Nvl(批次, 0) = Nvl(c_成本调整.批次, 0) And 性质 = 1;
    
      If Sql%NotFound Then
        Insert Into 药品库存
          (库房id, 药品id, 批次, 性质, 实际差价, 上次批号, 效期, 上次产地, 上次供应商id, 上次生产日期, 批准文号, 灭菌效期)
        Values
          (c_成本调整.库房id, c_成本调整.材料id, c_成本调整.批次, 1, n_调整额, c_成本调整.批号, c_成本调整.效期, c_成本调整.产地, c_成本调整.上次供应商id, c_成本调整.生产日期,
           c_成本调整.批准文号, c_成本调整.灭菌效期);
      End If;
    
      Update 药品库存
      Set 上次采购价 = c_成本调整.新成本价
      Where 药品id = c_成本调整.材料id And 上次采购价 <> c_成本调整.新成本价;
    
      Update 材料特性
      Set 成本价 = c_成本调整.新成本价
      Where 材料id = c_成本调整.材料id And 成本价 <> c_成本调整.新成本价;
    
      --重新计算库存表中的平均成本价 
      Update 药品库存
      Set 平均成本价 = Decode(Nvl(批次, 0), 0, Decode((实际金额 - 实际差价) / 实际数量, 0, 上次采购价, (实际金额 - 实际差价) / 实际数量), 上次采购价)
      Where 药品id = c_成本调整.材料id And Nvl(批次, 0) = Nvl(c_成本调整.批次, 0) And 库房id = c_成本调整.库房id And 性质 = 1 And
            Nvl(实际数量, 0) <> 0;
      If Sql%NotFound Then
        Select 成本价 Into n_平均成本价 From 材料特性 Where 材料id = c_成本调整.材料id;
        Update 药品库存
        Set 平均成本价 = n_平均成本价
        Where 药品id = c_成本调整.材料id And 库房id = c_成本调整.库房id And Nvl(批次, 0) = Nvl(c_成本调整.批次, 0) And 性质 = 1;
      End If;
    
      --更新成本价调价信息 
      Update 成本价调价信息
      Set 收发id = n_收发id, 执行日期 = d_调价时间, 原成本价 = n_原成本价, 效期 = c_成本调整.效期, 灭菌效期 = c_成本调整.灭菌效期, 产地 = c_成本调整.产地,
          批号 = c_成本调整.批号
      Where ID = c_成本调整.调价id;
    End If;
  
    --消息处理
    b_Message.Zlhis_Drug_010(c_成本调整.调价id);
  End Loop;

  --产生应付记录 
  For c_应付 In (Select Distinct a.供药单位id, a.药品id, a.发票号, a.发票日期, a.发票金额, b.名称, b.计算单位, b.规格
               From 成本价调价信息 A, 收费项目目录 B
               Where a.药品id = b.Id And Nvl(a.应付款变动, 0) = 1 And Nvl(a.供药单位id, 0) <> 0 And a.药品id = 材料id_In
               Order By a.供药单位id) Loop
  
    v_应付单据号 := Nextno(67);
  
    Select 应付记录_Id.Nextval Into v_应付id From Dual;
  
    Insert Into 应付记录
      (ID, 记录性质, 记录状态, 单位id, NO, 系统标识, 发票号, 发票日期, 发票金额, 品名, 规格, 填制人, 填制日期, 审核人, 审核日期, 摘要)
    Values
      (v_应付id, 1, 1, c_应付.供药单位id, v_应付单据号, 5, c_应付.发票号, c_应付.发票日期, c_应付.发票金额, c_应付.名称, c_应付.规格, Zl_Username, d_调价时间,
       Zl_Username, d_调价时间, '成本价调价自动产生应付款变动记录');
  
    If Nvl(c_应付.供药单位id, 0) <> 0 Then
      Update 应付余额 Set 金额 = Nvl(金额, 0) + Nvl(c_应付.发票金额, 0) Where 单位id = c_应付.供药单位id And 性质 = 1;
      If Sql%NotFound Then
        Insert Into 应付余额 (单位id, 性质, 金额) Values (c_应付.供药单位id, 1, Nvl(c_应付.发票金额, 0));
      End If;
    End If;
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料收发记录_成本价调价;
/

--120700:李业庆,2018-01-23,消息描点调整
Create Or Replace Procedure Zl_材料收发记录_Adjust
(
  调价id_In   In Number, --调价记录的ID
  定价_In     In Number := 0, --是否转为定价销售（更新材料特性、收费细目中的变价）
  材料id_In   In Number := 0, --当不为0时表示是成本价调价，不处理售价相关内容
  Billinfo_In In Varchar2 := Null --用于时价卫材按批次调价。格式:"批次1,现价1|批次2,现价2|....."
) As
  n_入出类别id 药品收发记录.入出类别id%Type; --入出类别
  v_调价单据号 药品收发记录.No%Type; --调价单号
  d_生效日期   Date; --调价生效时间
  n_执行调价   Number(1); --调价时刻到了
  n_实价材料   Number(1); --时价药品
  n_收费细目id Number(18); --收费细目ID
  d_审核日期   药品收发记录.审核日期%Type;
  n_零售金额   药品库存.实际金额%Type;
  n_零售价     药品库存.零售价%Type;
  n_序号       Integer(8);
  v_Infotmp    Varchar2(4000);
  v_Fields     Varchar2(4000);
  n_批次       Number(18);
  n_现价       收费价目.现价%Type;
  n_原价       收费价目.原价%Type;
  n_收发id     药品收发记录.Id%Type;
  n_时价分批   Number(1);
  v_Lngid      药品收发记录.Id%Type; --收发ID
  n_价格id     收费价目.Id%Type;

  Cursor c_Price --普通调价
  Is
    Select 1 记录状态, 13 单据, v_调价单据号 NO, Rownum 序号, n_入出类别id 入出类别id, m.材料id 药品id, s.批次 批次, Null 批号, s.效期,
           Decode(s.上次产地, Null, q.产地, s.上次产地) 产地, 1 付数, s.实际数量 填写数量, 0 实际数量, a.原价 成本价, 0 成本金额, a.现价 零售价, 0 扣率,
           Nvl(s.零售价, 0) As 库存零售价, s.实际金额 As 库存金额, s.实际差价 As 库存差价, '卫材调价' 摘要, User 填制人, Sysdate 填制日期, s.库房id 库房id,
           1 入出系数, a.Id 价格id, s.上次生产日期, s.灭菌效期, s.批准文号, s.上次供应商id,
           Nvl(s.零售价, Decode(Nvl(s.实际数量, 0), 0, a.原价, Nvl(s.实际金额, 0) / s.实际数量)) As 原售价
    From 药品库存 S, 材料特性 M, 收费价目 A, 收费项目目录 Q
    Where s.药品id = m.材料id And m.材料id = q.Id And m.材料id = a.收费细目id And s.性质 = 1 And a.变动原因 = 0 And a.Id = 调价id_In And
          a.执行日期 <= Sysdate;

  Cursor c_时价按批次调价 --时价卫材按批次调价
  Is
    Select 1 记录状态, 13 单据, v_调价单据号 NO, n_序号 + Rownum 序号, n_入出类别id 入出类别id, s.药品id 药品id, s.批次 批次, Null 批号, s.效期,
           Decode(s.上次产地, Null, b.产地, s.上次产地) 产地, 1 付数, Nvl(s.实际数量, 0) 填写数量, 0 实际数量, a.原价 成本价, 0 成本金额, n_现价 零售价, 0 扣率,
           '卫材调价' 摘要, User 填制人, Sysdate 填制日期, s.库房id 库房id, 1 入出系数, a.Id 价格id, Nvl(b.是否变价, 0) As 时价, s.实际金额 As 库存金额,
           s.实际差价 As 库存差价, Nvl(s.零售价, Decode(Nvl(s.实际数量, 0), 0, a.原价, Nvl(s.实际金额, 0) / s.实际数量)) As 原售价
    From 药品库存 S, 材料特性 M, 收费价目 A, 收费项目目录 B
    Where s.药品id = m.材料id And m.材料id = a.收费细目id And a.收费细目id = b.Id And s.性质 = 1 And a.变动原因 = 0 And a.Id = 调价id_In And
          a.执行日期 <= Sysdate And Nvl(s.批次, 0) = n_批次;
Begin

  If 材料id_In <> 0 Then
    --成本价调价
    Zl_材料收发记录_成本价调价(材料id_In);
    Return;
  End If;

  --取入出类别ID
  Select 类别id Into n_入出类别id From 药品单据性质 Where 单据 = 13;

  --取序列
  Select Nextno(147) Into v_调价单据号 From Dual;
  --取调价记录生效日期
  Select 收费细目id, 执行日期 Into n_收费细目id, d_生效日期 From 收费价目 Where ID = 调价id_In;
  --取该材料是否是时价药品
  Select Nvl(是否变价, 0) Into n_实价材料 From 收费项目目录 Where ID = n_收费细目id;

  If Sysdate >= d_生效日期 Then
    n_执行调价 := 1;
  Else
    n_执行调价 := 0;
  End If;

  If n_执行调价 = 1 Then
    d_审核日期 := Sysdate;
    --普通调价处理
    If Billinfo_In = '' Or Billinfo_In Is Null Then
      --非时价药品调价
      For c_调价 In c_Price Loop
        n_价格id := c_调价.价格id;
        If Nvl(c_调价.填写数量, 0) = 0 And Nvl(c_调价.库存金额, 0) = 0 And Nvl(c_调价.库存差价, 0) = 0 Then
          Null;
        Elsif Nvl(c_调价.填写数量, 0) = 0 And (Nvl(c_调价.库存金额, 0) <> 0 Or Nvl(c_调价.库存差价, 0) <> 0) Then
          --数量=0 金额或差价<>0时只更新库存表中对应的零售价,并产生售价修正数据但是金额差=0，只记录最新售价，金额差和差价差不填数据
        
          --产生调价影响记录
          Select 药品收发记录_Id.Nextval Into v_Lngid From Dual;
          Insert Into 药品收发记录
            (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 摘要, 填制人, 填制日期,
             库房id, 入出系数, 价格id, 审核人, 审核日期, 生产日期, 灭菌效期, 批准文号, 供药单位id, 单量, 频次)
          Values
            (v_Lngid, c_调价.记录状态, c_调价.单据, c_调价.No, c_调价.序号, c_调价.入出类别id, c_调价.药品id, c_调价.批次, c_调价.批号, c_调价.效期, c_调价.产地,
             c_调价.付数, c_调价.填写数量, c_调价.实际数量, Decode(n_实价材料, 1, c_调价.原售价, c_调价.成本价), c_调价.成本金额, c_调价.零售价, c_调价.扣率, c_调价.摘要,
             c_调价.填制人, c_调价.填制日期, c_调价.库房id, c_调价.入出系数, c_调价.价格id, User, d_审核日期, c_调价.上次生产日期, c_调价.灭菌效期, c_调价.批准文号,
             c_调价.上次供应商id, c_调价.库存金额, c_调价.库存差价);
        
          Zl_未审药品记录_Insert(v_Lngid);
          --更新材料库存 ，只有时价卫材才更新零售价
          Update 药品库存
          Set 零售价 = Decode(n_实价材料, 1, Decode(Nvl(c_调价.批次, 0), 0, Null, c_调价.零售价), Null)
          Where 库房id = c_调价.库房id And 药品id = c_调价.药品id And 性质 = 1 And Nvl(批次, 0) = Nvl(c_调价.批次, 0);
        
          Zl_未审药品记录_Delete(v_Lngid);
        Else
          If n_实价材料 = 1 Then
            If c_调价.库存零售价 = 0 Then
              n_零售价 := c_调价.库存金额 / c_调价.填写数量;
            Else
              n_零售价 := c_调价.库存零售价;
            End If;
          Else
            n_零售价 := c_调价.成本价;
          End If;
          n_零售金额 := Round((c_调价.零售价 - n_零售价) * c_调价.填写数量, 2);
        
          --产生调价影响记录
          Select 药品收发记录_Id.Nextval Into v_Lngid From Dual;
          Insert Into 药品收发记录
            (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 零售金额, 差价, 摘要, 填制人,
             填制日期, 库房id, 入出系数, 价格id, 审核人, 审核日期, 生产日期, 灭菌效期, 批准文号, 供药单位id, 单量, 频次)
          Values
            (v_Lngid, c_调价.记录状态, c_调价.单据, c_调价.No, c_调价.序号, c_调价.入出类别id, c_调价.药品id, c_调价.批次, c_调价.批号, c_调价.效期, c_调价.产地,
             c_调价.付数, c_调价.填写数量, c_调价.实际数量, Decode(n_实价材料, 1, c_调价.原售价, c_调价.成本价), c_调价.成本金额, c_调价.零售价, c_调价.扣率, n_零售金额,
             n_零售金额, c_调价.摘要, c_调价.填制人, c_调价.填制日期, c_调价.库房id, c_调价.入出系数, c_调价.价格id, User, d_审核日期, c_调价.上次生产日期, c_调价.灭菌效期,
             c_调价.批准文号, c_调价.上次供应商id, c_调价.库存金额, c_调价.库存差价);
        
          Zl_未审药品记录_Insert(v_Lngid);
          --更新材料库存
          Update 药品库存
          Set 实际金额 = Nvl(实际金额, 0) + n_零售金额, 实际差价 = Nvl(实际差价, 0) + n_零售金额,
              零售价 = Decode(n_实价材料, 1, Decode(Nvl(c_调价.批次, 0), 0, Null, c_调价.零售价), Null)
          Where 库房id = c_调价.库房id And 药品id = c_调价.药品id And 性质 = 1 And Nvl(批次, 0) = Nvl(c_调价.批次, 0);
        
          If Sql%RowCount = 0 Then
            Insert Into 药品库存
              (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 效期, 灭菌效期, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 批准文号, 零售价)
            Values
              (c_调价.库房id, c_调价.药品id, c_调价.批次, 1, 0, 0, n_零售金额, n_零售金额, c_调价.效期, c_调价. 灭菌效期, c_调价.上次供应商id, c_调价.成本价,
               c_调价.批号, c_调价.上次生产日期, c_调价.产地, c_调价.批准文号,
               Decode(n_实价材料, 1, Decode(Nvl(c_调价.批次, 0), 0, Null, c_调价.零售价), Null));
          End If;
        
          Zl_未审药品记录_Delete(v_Lngid);
        End If;
      End Loop;
    
      --消息处理
      b_Message.Zlhis_Drug_011(n_价格id, 0);
    Else
      --时价分批调价处理
      n_序号 := 0;
      --时价药品按批次调价
      v_Infotmp := Billinfo_In || '|';
      While v_Infotmp Is Not Null Loop
        --分解单据ID串
        v_Fields  := Substr(v_Infotmp, 1, Instr(v_Infotmp, '|') - 1);
        n_批次    := Substr(v_Fields, 1, Instr(v_Fields, ',') - 1);
        n_现价    := Substr(v_Fields, Instr(v_Fields, ',') + 1);
        v_Infotmp := Replace('|' || v_Infotmp, '|' || v_Fields || '|');
      
        For v_时价按批次调价 In c_时价按批次调价 Loop
          If v_时价按批次调价.填写数量 <> 0 Then
            n_原价 := Nvl(v_时价按批次调价.库存金额, 0) / v_时价按批次调价.填写数量;
          Else
            n_原价 := v_时价按批次调价.成本价;
          End If;
        
          Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
          If Nvl(v_时价按批次调价.填写数量, 0) = 0 And Nvl(v_时价按批次调价.库存金额, 0) = 0 And Nvl(v_时价按批次调价.库存差价, 0) = 0 Then
            Null;
            n_价格id := Null;
          Elsif Nvl(v_时价按批次调价.填写数量, 0) = 0 And (Nvl(v_时价按批次调价.库存金额, 0) <> 0 Or Nvl(v_时价按批次调价.库存差价, 0) <> 0) Then
            --数量=0 金额或差价<>0时只更新库存表中对应的零售价,并产生售价修正数据但是金额差=0，只记录最新售价，金额差和差价差不填数据
          
            --产生调价影响记录
            Insert Into 药品收发记录
              (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 摘要, 填制人, 填制日期,
               库房id, 入出系数, 价格id, 审核人, 审核日期, 单量, 频次)
            Values
              (n_收发id, v_时价按批次调价.记录状态, v_时价按批次调价.单据, v_时价按批次调价.No, v_时价按批次调价.序号, v_时价按批次调价.入出类别id, v_时价按批次调价.药品id,
               v_时价按批次调价.批次, v_时价按批次调价.批号, v_时价按批次调价.效期, v_时价按批次调价.产地, v_时价按批次调价.付数, v_时价按批次调价.填写数量, v_时价按批次调价.实际数量,
               Decode(n_实价材料, 1, v_时价按批次调价.原售价, v_时价按批次调价.成本价), v_时价按批次调价.成本金额, v_时价按批次调价.零售价, v_时价按批次调价.扣率,
               v_时价按批次调价.摘要, v_时价按批次调价.填制人, v_时价按批次调价.填制日期, v_时价按批次调价.库房id, v_时价按批次调价.入出系数, v_时价按批次调价.价格id, User, d_审核日期,
               v_时价按批次调价.库存金额, v_时价按批次调价.库存差价);
            n_序号 := n_序号 + 1;
          
            Zl_未审药品记录_Insert(n_收发id);
            --处理库存
            --更新库存零售价,只有时价分批药品才能更新零售价字段
            Update 药品库存
            Set 零售价 = Decode(v_时价按批次调价.时价, 1, Decode(Nvl(v_时价按批次调价.批次, 0), 0, Null, v_时价按批次调价.零售价), Null)
            Where 库房id = v_时价按批次调价.库房id And 药品id = v_时价按批次调价.药品id And 性质 = 1 And Nvl(批次, 0) = Nvl(v_时价按批次调价.批次, 0);
          
            Zl_未审药品记录_Delete(n_收发id);
          
            n_价格id := n_收发id;
          Else
            n_零售价   := v_时价按批次调价.库存金额 / v_时价按批次调价.填写数量;
            n_零售金额 := Round((n_现价 - n_零售价) * v_时价按批次调价.填写数量, 2);
            --产生调价影响记录
            Insert Into 药品收发记录
              (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 零售金额, 差价, 摘要,
               填制人, 填制日期, 库房id, 入出系数, 价格id, 审核人, 审核日期, 单量, 频次)
            Values
              (n_收发id, v_时价按批次调价.记录状态, v_时价按批次调价.单据, v_时价按批次调价.No, v_时价按批次调价.序号, v_时价按批次调价.入出类别id, v_时价按批次调价.药品id,
               v_时价按批次调价.批次, v_时价按批次调价.批号, v_时价按批次调价.效期, v_时价按批次调价.产地, v_时价按批次调价.付数, v_时价按批次调价.填写数量, v_时价按批次调价.实际数量,
               Decode(n_实价材料, 1, v_时价按批次调价.原售价, v_时价按批次调价.成本价), v_时价按批次调价.成本金额, v_时价按批次调价.零售价, v_时价按批次调价.扣率, n_零售金额,
               n_零售金额, v_时价按批次调价.摘要, v_时价按批次调价.填制人, v_时价按批次调价.填制日期, v_时价按批次调价.库房id, v_时价按批次调价.入出系数, v_时价按批次调价.价格id, User,
               d_审核日期, v_时价按批次调价.库存金额, v_时价按批次调价.库存差价);
            n_序号 := n_序号 + 1;
          
            Zl_未审药品记录_Insert(n_收发id);
            --处理库存
            If v_时价按批次调价.时价 = 1 And Nvl(v_时价按批次调价.批次, 0) > 0 Then
              n_时价分批 := 1;
            Else
              n_时价分批 := 0;
            End If;
          
            If Nvl(v_时价按批次调价.批次, 0) = 0 Then
              Update 药品库存
              Set 实际金额 = Nvl(实际金额, 0) + n_零售金额, 实际差价 = Nvl(实际差价, 0) + n_零售金额
              Where 库房id = v_时价按批次调价.库房id And 药品id = v_时价按批次调价.药品id And 性质 = 1 And (批次 Is Null Or 批次 = 0);
            Else
              Update 药品库存
              Set 实际金额 = Nvl(实际金额, 0) + n_零售金额, 实际差价 = Nvl(实际差价, 0) + n_零售金额,
                  零售价 = Decode(n_时价分批, 1, v_时价按批次调价.零售价, 零售价)
              Where 库房id = v_时价按批次调价.库房id And 药品id = v_时价按批次调价.药品id And 性质 = 1 And 批次 = v_时价按批次调价.批次;
            End If;
          
            If Sql%RowCount = 0 Then
              Insert Into 药品库存
                (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 零售价)
              Values
                (v_时价按批次调价.库房id, v_时价按批次调价.药品id, v_时价按批次调价.批次, 1, 0, 0, n_零售金额, n_零售金额,
                 Decode(n_时价分批, 1, v_时价按批次调价.零售价, Null));
            End If;
          
            Zl_未审药品记录_Delete(n_收发id);
          
            n_价格id := n_收发id;
          End If;
        
          --消息处理
          If n_价格id Is Not Null Then
            b_Message.Zlhis_Drug_011(n_价格id, 1);
          End If;
        End Loop;
      End Loop;
    End If;
  
    Update 药品收发记录 Set 审核人 = User, 审核日期 = Sysdate Where 价格id = 调价id_In;
    Update 收费价目 Set 变动原因 = 1 Where ID = 调价id_In;
  
    --更新药品目录、收费细目中的变价
    If 定价_In = 1 Then
      Update 收费项目目录 Set 是否变价 = 0 Where ID = n_收费细目id;
    End If;
    --成本价调价
    Zl_材料收发记录_成本价调价(n_收费细目id);
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料收发记录_Adjust;
/

---------------------------------------------------------------------------------------------------
--更改系统及部件的版本号
-------------------------------------------------------------------------------------------------------
--系统版本号
Update zlSystems Set 版本号='10.35.90' Where 编号=&n_System;
--部件版本号

--113763:杨周一,2017-12-07,DBA工具执行文件名称修改
Delete From Zltools.Zlfilesupgrade Where 文件名 = 'ZLDBATOOLSEXE.EXE';
Insert Into Zltools.Zlfilesupgrade
  (序号, 加入日期, 安装路径, 文件类型, 文件名, 版本号, 修改日期, 所属系统, 业务部件, Md5, 文件说明, 自动注册, 强制覆盖, 附加安装路径, 文件版本号)
  Select 序号, To_Date('2017-07-05 17:22:54', 'yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]', 0, 'ZLDBATOOLS.EXE', Null, Null, Null,
         Null, Null, '部件功能:DBA管理工具单独执行文件', 0, 0, Null, Null
  From Dual A, (Select Nvl(Max(To_Number(序号)), 0) + 1 序号 From zlFilesUpgrade) B
  Where Not Exists (Select 1 From Zltools.Zlfilesupgrade Where Upper(文件名) = 'ZLDBATOOLS.EXE');

--000000:刘硕,2018-01-16,更新部分信息，未登记问题
Update zlFilesUpgrade
Set 文件说明 = '部件功能:新版LIS通讯程序部件。系统定位:主要处理与仪器接口之间数据交互。缺失后果:不能正常解析仪器数据'
Where Upper(文件名) = 'ZL9LABRECEIV.EXE';
Update Zlfiles
Set 文件说明 = '部件功能:新版LIS通讯程序部件。系统定位:主要处理与仪器接口之间数据交互。缺失后果:不能正常解析仪器数据'
Where Upper(名称) = 'ZL9LABRECEIV.EXE';


--118267:杨周一,2017-12-16,LIS图片数据转出单独执行文件
Insert Into Zltools.Zlfilesupgrade
  (序号, 加入日期, 安装路径, 文件类型, 文件名, 版本号, 修改日期, 所属系统, 业务部件, Md5, 文件说明, 自动注册, 强制覆盖, 附加安装路径)
  Select 序号, To_Date('2017-12-16 02:25:54', 'yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]', 0, 'ZLLISPIC2FTP.EXE', Null, Null, Null,
         Null, Null, '部件功能:LIS图片数据转出单独执行文件', 0, 0, Null
  From Dual A, (Select Nvl(Max(To_Number(序号)), 0) + 1 序号 From zlFilesUpgrade) B
  Where Not Exists (Select 1 From Zltools.Zlfilesupgrade Where Upper(文件名) = 'ZLLISPIC2FTP.EXE');


--119656:杨周一,2018-01-18,LIS图片数据转出子程序
Insert Into Zltools.Zlfilesupgrade
  (序号, 加入日期, 安装路径, 文件类型, 文件名, 版本号, 修改日期, 所属系统, 业务部件, Md5, 文件说明, 自动注册, 强制覆盖, 附加安装路径)
  Select 序号, To_Date('2018-01-18 02:25:54', 'yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]', 0, 'ZLLISPIC2FTPSUB.EXE', Null, Null, Null,
         Null, Null, '部件功能:LIS图片数据转出子程序', 0, 0, Null
  From Dual A, (Select Nvl(Max(To_Number(序号)), 0) + 1 序号 From zlFilesUpgrade) B
  Where Not Exists (Select 1 From Zltools.Zlfilesupgrade Where Upper(文件名) = 'ZLLISPIC2FTPSUB.EXE');

--121712:高腾,2018-02-06,诊疗项目管理分开授权
Insert Into Zltools.Zlprogfuncs (系统, 序号, 功能, 排列, 说明, 缺省值) Values (&n_System, 1054, '诊疗项目编辑', 5, '增加、删除、修改诊疗项目的操作权限。有该权限时，允许对分类及诊疗项目进行增加、删除、修改、启用、停用，并允许设置检查部位、采集方式、标本对照、排斥关系、对应单据', 1);
Insert Into Zltools.Zlprogfuncs (系统, 序号, 功能, 排列, 说明, 缺省值) Values (&n_System, 1054, '中药配方编辑', 7, '增加、删除、修改中药配方的操作权限。有该权限时，允许对分类及中药配方进行增加、删除、修改、启用、停用', 1);
Insert Into Zltools.Zlprogfuncs (系统, 序号, 功能, 排列, 说明, 缺省值) Values (&n_System, 1054, '成套方案编辑', 11, '增加、删除、修改成套方案的操作权限。有该权限时，允许对分类及成套方案进行增加、删除、修改、启用、停用', 1);
Update Zltools.Zlprogfuncs Set 排列 = 2 Where 系统 = &n_System And 序号 = 1054 And 功能 = '参数设置';
Update Zltools.Zlprogfuncs Set 排列 = 6 Where 系统 = &n_System And 序号 = 1054 And 功能 = '管理中药配方';
Update Zltools.Zlprogfuncs Set 排列 = 8 Where 系统 = &n_System And 序号 = 1054 And 功能 = '管理成套方案';
Update Zltools.Zlprogfuncs Set 排列 = 9 Where 系统 = &n_System And 序号 = 1054 And 功能 = '全院成套方案';
Update Zltools.Zlprogfuncs Set 排列 = 10 Where 系统 = &n_System And 序号 = 1054 And 功能 = '本科成套方案';
Update Zltools.Zlprogfuncs Set 排列 = 12 Where 系统 = &n_System And 序号 = 1054 And 功能 = '修改全院成套方案';
Update Zltools.Zlprogfuncs Set 排列 = 13 Where 系统 = &n_System And 序号 = 1054 And 功能 = '修改科室成套方案';
Update Zltools.Zlprogfuncs Set 排列 = 14 Where 系统 = &n_System And 序号 = 1054 And 功能 = '修改个人成套方案';
Insert Into Zltools.zlProgPrivs(系统,序号,功能,所有者,对象,权限)
	Select &n_System,1054,'成套方案编辑',User,A.* From (
	Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
	Select 'ZL_成套方案内容_Insert','EXECUTE' From Dual Union All
	Select 'ZL_成套方案项目_UPDATE','EXECUTE' From Dual Union All
	Select 'ZL_诊疗分类目录_DELETE','EXECUTE' From Dual Union All
	Select 'ZL_诊疗分类目录_Insert','EXECUTE' From Dual Union All
	Select 'ZL_诊疗分类目录_UPDATE','EXECUTE' From Dual Union All
	Select 'ZL_诊疗项目_DELETE','EXECUTE' From Dual Union All
	Select 'ZL_诊疗项目_Insert','EXECUTE' From Dual Union All
	Select 'ZL_诊疗项目_REUSE','EXECUTE' From Dual Union All
	Select 'ZL_诊疗项目_STOP','EXECUTE' From Dual Union All
	Select 'ZL_诊疗项目_UPDATE','EXECUTE' From Dual Union All
	Select 'ZL_所见项目_DELETE','EXECUTE' From Dual Union All
	Select 'ZL_所见项目_Insert','EXECUTE' From Dual Union All
	Select 'ZL_所见项目_UPDATE','EXECUTE' From Dual Union All
	Select 对象,权限 From zlProgPrivs Where 1 = 0) A;
Insert Into Zltools.zlProgPrivs(系统,序号,功能,所有者,对象,权限)
	Select &n_System,1054,'诊疗项目编辑',User,A.* From (
	Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
	Select 'ZL_检查组合项目_UPDATE','EXECUTE' From Dual Union All
	Select 'ZL_检验报告项目_UPDATE','EXECUTE' From Dual Union All
	Select 'ZL_检验项目_UPDATE','EXECUTE' From Dual Union All
	Select 'ZL_配伍禁忌_UPDATE','EXECUTE' From Dual Union All
	Select 'ZL_所见项目_DELETE','EXECUTE' From Dual Union All
	Select 'ZL_所见项目_Insert','EXECUTE' From Dual Union All
	Select 'ZL_所见项目_UPDATE','EXECUTE' From Dual Union All
	Select 'ZL_用法用量_UPDATE','EXECUTE' From Dual Union All
	Select 'ZL_诊疗单据应用_UPDATE','EXECUTE' From Dual Union All
	Select 'ZL_诊疗分类目录_DELETE','EXECUTE' From Dual Union All
	Select 'ZL_诊疗分类目录_Insert','EXECUTE' From Dual Union All
	Select 'ZL_诊疗分类目录_UPDATE','EXECUTE' From Dual Union All
	Select 'ZL_诊疗互斥项目_SAVE','EXECUTE' From Dual Union All
	Select 'ZL_诊疗项目_DELETE','EXECUTE' From Dual Union All
	Select 'ZL_诊疗项目_Insert','EXECUTE' From Dual Union All
	Select 'ZL_诊疗项目_REUSE','EXECUTE' From Dual Union All
	Select 'ZL_诊疗项目_STOP','EXECUTE' From Dual Union All
	Select 'ZL_诊疗项目_UPDATE','EXECUTE' From Dual Union All
	Select 'Zl_诊疗项目部位_DELETE','EXECUTE' From Dual Union All
	Select 'Zl_诊疗项目部位_Insert','EXECUTE' From Dual Union All
	Select '检验项目','SELECT' From Dual Union All
	Select '检验项目参考','SELECT' From Dual Union All
	Select '诊疗分类目录_ID','SELECT' From Dual Union All
	Select '诊疗项目目录_ID','SELECT' From Dual Union All
	Select '诊治所见项目_ID','SELECT' From Dual Union All
	Select 对象,权限 From zlProgPrivs Where 1 = 0) A;
Insert Into Zltools.zlProgPrivs(系统,序号,功能,所有者,对象,权限)
	Select &n_System,1054,'中药配方编辑',User,A.* From (
	Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
	Select 'ZL_中药配方_UPDATE','EXECUTE' From Dual Union All
	Select 'ZL_诊疗分类目录_DELETE','EXECUTE' From Dual Union All
	Select 'ZL_诊疗分类目录_Insert','EXECUTE' From Dual Union All
	Select 'ZL_诊疗分类目录_UPDATE','EXECUTE' From Dual Union All
	Select 'ZL_诊疗项目_DELETE','EXECUTE' From Dual Union All
	Select 'ZL_诊疗项目_Insert','EXECUTE' From Dual Union All
	Select 'ZL_诊疗项目_REUSE','EXECUTE' From Dual Union All
	Select 'ZL_诊疗项目_STOP','EXECUTE' From Dual Union All
	Select 'ZL_诊疗项目_UPDATE','EXECUTE' From Dual Union All
	Select 'ZL_所见项目_DELETE','EXECUTE' From Dual Union All
	Select 'ZL_所见项目_Insert','EXECUTE' From Dual Union All
	Select 'ZL_所见项目_UPDATE','EXECUTE' From Dual Union All
	Select 对象,权限 From zlProgPrivs Where 1 = 0) A;
Insert Into zlProgRelas(系统,序号,组号,功能,关系,主项,主项关系)
  Select &n_System,1054,1,A.* From (
  Select 功能,关系,主项,主项关系 From zlProgRelas Where 1 = 0 Union All
  Select '修改个人成套方案',2,0,0 From Dual Union All
  Select 功能,关系,主项,主项关系 From zlProgRelas Where 1 = 0) A;
Insert Into zlProgRelas(系统,序号,组号,功能,关系,主项,主项关系)
  Select &n_System,1054,2,A.* From (
  Select 功能,关系,主项,主项关系 From zlProgRelas Where 1 = 0 Union All
  Select '本科成套方案',2,1,0 From Dual Union All
  Select '修改科室成套方案',2,0,0 From Dual Union All
  Select 功能,关系,主项,主项关系 From zlProgRelas Where 1 = 0) A;
Insert Into zlProgRelas(系统,序号,组号,功能,关系,主项,主项关系)
  Select &n_System,1054,3,A.* From (
  Select 功能,关系,主项,主项关系 From zlProgRelas Where 1 = 0 Union All
  Select '全院成套方案',2,1,0 From Dual Union All
  Select '修改全院成套方案',2,0,0 From Dual Union All
  Select 功能,关系,主项,主项关系 From zlProgRelas Where 1 = 0) A;
Insert Into zlProgRelas(系统,序号,组号,功能,关系,主项,主项关系)
  Select &n_System,1054,4,A.* From (
  Select 功能,关系,主项,主项关系 From zlProgRelas Where 1 = 0 Union All
  Select '管理诊疗项目',2,1,0 From Dual Union All
  Select '诊疗项目编辑',2,0,0 From Dual Union All
  Select 功能,关系,主项,主项关系 From zlProgRelas Where 1 = 0) A;
Insert Into zlProgRelas(系统,序号,组号,功能,关系,主项,主项关系)
  Select &n_System,1054,5,A.* From (
  Select 功能,关系,主项,主项关系 From zlProgRelas Where 1 = 0 Union All
  Select '管理中药配方',2,1,0 From Dual Union All
  Select '中药配方编辑',2,0,0 From Dual Union All
  Select 功能,关系,主项,主项关系 From zlProgRelas Where 1 = 0) A;
Insert Into zlProgRelas(系统,序号,组号,功能,关系,主项,主项关系)
  Select &n_System,1054,6,A.* From (
  Select 功能,关系,主项,主项关系 From zlProgRelas Where 1 = 0 Union All
  Select '管理成套方案',2,1,0 From Dual Union All
  Select '成套方案编辑',2,0,0 From Dual Union All
  Select 功能,关系,主项,主项关系 From zlProgRelas Where 1 = 0) A;
Insert Into zlProgRelas(系统,序号,组号,功能,关系,主项,主项关系)
  Select &n_System,1054,7,A.* From (
  Select 功能,关系,主项,主项关系 From zlProgRelas Where 1 = 0 Union All
  Select '成套方案编辑',2,1,0 From Dual Union All
  Select '修改个人成套方案',2,0,0 From Dual Union All
  Select '修改科室成套方案',2,0,0 From Dual Union All
  Select '修改全院成套方案',2,0,0 From Dual Union All
  Select 功能,关系,主项,主项关系 From zlProgRelas Where 1 = 0) A;
Insert Into Zltools.Zlrolegrant
  (系统, 序号, 角色, 功能)
  Select 系统, 序号, 角色, '诊疗项目编辑'
  From Zltools.Zlrolegrant
  Where 系统 = &n_System And 序号 = 1054 And 功能 = '项目编辑';
Insert Into Zltools.Zlrolegrant
  (系统, 序号, 角色, 功能)
  Select 系统, 序号, 角色, '中药配方编辑'
  From Zltools.Zlrolegrant
  Where 系统 = &n_System And 序号 = 1054 And 功能 = '项目编辑';
Insert Into Zltools.Zlrolegrant
  (系统, 序号, 角色, 功能)
  Select 系统, 序号, 角色, '成套方案编辑'
  From Zltools.Zlrolegrant
  Where 系统 = &n_System And 序号 = 1054 And 功能 = '项目编辑';
Insert Into Zltools.zlModuleRelas(系统,模块,功能,相关系统,相关模块,相关类型,相关功能,缺省值)
	Select &n_System,1252,A.* From (
	Select 功能,相关系统,相关模块,相关类型,相关功能,缺省值 From zlModuleRelas Where 1 = 0 Union All
	Select NULL,&n_System,1054,0,'成套方案编辑',1 From Dual Union All
	Select 功能,相关系统,相关模块,相关类型,相关功能,缺省值 From zlModuleRelas Where 1 = 0) A;
Insert Into Zltools.zlModuleRelas(系统,模块,功能,相关系统,相关模块,相关类型,相关功能,缺省值)
	Select &n_System,1253,A.* From (
	Select 功能,相关系统,相关模块,相关类型,相关功能,缺省值 From zlModuleRelas Where 1 = 0 Union All
	Select NULL,&n_System,1054,0,'成套方案编辑',1 From Dual Union All
	Select 功能,相关系统,相关模块,相关类型,相关功能,缺省值 From zlModuleRelas Where 1 = 0) A;
Delete Zltools.Zlmodulerelas Where 系统 = &n_System And 模块 = 1252 And 功能 Is Null And 相关系统 = &n_System And 相关模块 = 1054 And 相关功能 = '项目编辑';
Delete Zltools.Zlmodulerelas Where 系统 = &n_System And 模块 = 1253 And 功能 Is Null And 相关系统 = &n_System And 相关模块 = 1054 And 相关功能 = '项目编辑';
Delete Zltools.Zlprogfuncs Where 系统 = &n_System And 序号 = 1054 And 功能 = '项目编辑';

--10.35.90部件更新信息
EXECUTE Zlfiles_Autoupdate('7Z.DLL','E3C7BC97672CDEB280DD43F2A69776BB','9.20.0.0',To_Date('2011-03-30 11:44:26', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'7-ZIP压缩程序',0,0,Null);
EXECUTE Zlfiles_Autoupdate('7Z.EXE','7083BA03D91F9D76CC659F973F14F839','9.20.0.0',To_Date('2011-03-30 11:44:26', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'7-ZIP压缩程序',0,0,Null);
EXECUTE Zlfiles_Autoupdate('AAMD532.DLL','CEFD956A1EF122CDA4D53007BAB6C694','1.0.0.1',To_Date('2011-09-27 11:15:40', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'部件功能:三方的MD5计算接口。使用原因:当不能使用VB进行MD5计算时，使用该三方部件进行Md5计算。缺失后果:常规无影响。但是自动升级检查该文件存在性，当不存在时不能自动升级。',0,0,Null);
EXECUTE Zlfiles_Autoupdate('Codejock.SyntaxEdit.v15.3.1.ocx','7010CEB71C0AEAFFE49A16EF5A27E582','15.3.1.0',To_Date('2014-09-10 16:33:04', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'部件功能:美化SQL语句使用原因:方便用户使用缺失后果:无法正常升级以及使用自定义过程管理。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('OO4O.7Z','8469280C3A059ACA7833B68F16A19F1A',Null,To_Date('2017-11-28 10:41:20', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-11-27 17:22:54', 'yyyy-mm-dd HH24:mi:ss'),4,'[APPSOFT]\ZLEXFILE',Null,Null,'部件功能:OO4O组件安装包，包含817、10g、11g的OO4O组件。缺失后果:无法安装OO4O组件。',0,0,Null);
EXECUTE Zlfiles_Autoupdate('QRMAKER.OCX','C00A0B76BC515DAA01060F7F9A230D0D','1.31.0.0',To_Date('2013-11-19 14:13:28', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'部件功能:输出2D条码使用原因:用户需求缺失后果:体检报告输出不完整',1,0,Null);
EXECUTE Zlfiles_Autoupdate('WINCMP3.EXE','4A8C0E6B9E9537418FAADAB1223376AE','4.2.0.2221',To_Date('2010-11-13 18:40:46', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,Null,0,0,Null);
EXECUTE Zlfiles_Autoupdate('WINCMP3.INI','5C19E599CAEECC87381FC5EB7DAE4A9F',Null,To_Date('2016-04-14 14:29:00', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,Null,0,0,Null);
EXECUTE Zlfiles_Autoupdate('ZL7Z.DLL','B4BB5790C910278FCBD443B672620E5B','1.0.0',To_Date('2017-08-08 11:34:16', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),0,'[SYSTEM]',Null,Null,'部件功能:中联7z压缩解压部件系统定位:进行文件压缩解压缺失后果:无法进行客户端部件升级。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZL9BillEdit.ocx','987A1776D901EA48E6EEE7B66118B02F','10.35.90',To_Date('2018-03-02 13:44:08', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),0,'[PUBLIC]',Null,'1,3,4,6,21,22,23,24,25','部件功能:单据编辑控件系统定位:提供表格控件缺失后果:用到此控件的界面不能正常打开，或者报错。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZL9Insure.dll','8EDCEF5A44DBAA7D5057DCCD8988AB95','10.35.90',To_Date('2018-03-02 13:48:44', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),0,'[PUBLIC]',Null,Null,'部件功能:医保接口部件。使用原因:医保项目检查，医保记帐作废上传缺失后果:重打时出错',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZL9LABWork.dll','78BD7A94E5DDEA0A61056F00875C7E67','10.35.90',To_Date('2018-03-02 14:26:21', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'25','部件功能:新版LIS核心部件系统定位:处理新版LIS工作站，报告查询等缺失后果:新版LIS将不能正常使用',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZL9LisInsideComm.dll','CE03A675352B6DA4869362BBA4E62600','10.35.90',To_Date('2018-03-02 14:22:51', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll,zl9PeisManage.dll,zl9CISAudit.dll,zl9Disease.dll,ZL9LabWork.dll,zl9LisWork.dll,zl9CISJob.dll,zl9Blood.dll','1,25','部件功能:处理新版LIS与HIS之间数据交互系统定位:主要应用于LIS与HIS交互接口部分，以及临床申请单使用。检验申请单设置缺失后果:LIS与HIS的数据将不正常',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZL9PACSIMAGECAP.DLL','9D8FFA254EB60B2E6CD141A3F3A2DC57','10.35.90',To_Date('2018-03-02 14:19:16', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9PACSWork.dll','1','部件功能:提供影像图像的采集与传输系统定位:影像检查图像采集支持缺失后果:影像采集病理系统不能运行。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZL9TEMPERATURECHARTSD.dll','B8D636E6788A74DCD40B3BB0DA46E5A8','10.35.90',To_Date('2018-03-02 14:32:14', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:新版护士工作站体温单相关功能(山东地区适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZL9TemperaTureChartYN.Dll','DA4F1B60038187C2C2949F3F3041CA98','10.35.90',To_Date('2018-03-02 14:31:13', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:新版护士工作站体温单相关功能(云南大理专用体温部件)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZL9XWINTERFACE.DLL','36D3263E1A60970239DDA9CCE0D959B7','10.35.90',To_Date('2018-03-02 14:32:49', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll,zl9PeisManage.dll,zlWizardStart.exe,zl9CISAudit.dll,zl9CISJob.dll,zl9PACSWork.dll,zl9Patient.dll,zl9InPatient.dll,zl9CISBase.dll,zl9BaseItem.dll','1','部件功能:提供ris与his系统数据交换接口系统定位:专业ris系统支持缺失后果:不能使用专业版ris系统',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLDBATOOLS.DLL','F2A08CBE8CF9FB8D92B115C59AC15D30','10.35.90',To_Date('2018-03-02 14:33:50', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),0,'[PUBLIC]',Null,Null,'部件功能:DBA管理工具。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLDBATOOLS.EXE','716DD5A692CBE5FC30AAD80E5DDD5AE8','10.35.90',To_Date('2018-03-02 14:36:41', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-07-05 17:22:54', 'yyyy-mm-dd HH24:mi:ss'),0,'[APPSOFT]',Null,Null,'部件功能:DBA管理工具单独执行文件',0,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLDSVIDEOPROCESS.OCX','915B1465C101552783EF186341BDA99A','1.2.74',To_Date('2016-08-03 14:10:50', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zl9RegEvent.dll,zl9CardSquare.dll,ZL9Peis.dll,zl9PeisManage.dll,zl9PACSWork.dll','1','部件功能:视频采集相关功能封装使用原因:体检人员照片采集缺失后果:不能采集图像和录像',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLEXINSTALL.EXE','E26C9EF54975B2B0C41A4D48B9E32F20','10.35.90',To_Date('2018-03-02 14:36:20', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-11-27 17:22:54', 'yyyy-mm-dd HH24:mi:ss'),0,'[APPSOFT]\ZLEXFILE',Null,Null,'部件功能:附加组件安装程序，现仅支持对OO4O组件安装。缺失后果:无法单独安装附加组件。',0,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLHIS+.exe','E0563339E92AF29F1BE86991C8A916D3','10.35.90',To_Date('2018-03-02 13:48:02', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),0,'[APPSOFT]',Null,'1,3,4,6,21,22,23,24,25,26','部件功能:ZLHIS+启动程序。系统定位:登录该程序才能进入导航台，进行业务操作。缺失后果:缺失该部件将无法进行各项业务。',0,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLHISCRUST.EXE','FDBEB6C1C5A6AD163A2325E69E24E641','10.35.90',To_Date('2018-03-02 13:45:52', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),0,'[APPSOFT]',Null,'1,3,4,6,21,22,23,24,25,26','部件功能:客户端自动升级工具。系统定位:通过该工具对各个客户端进行文件升级。缺失后果:缺失该文件，将会导致需要升级的客户端无法进入导航台。',0,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLLISPIC2FTP.EXE','66A5B60E11A5FE7EBFD63629611BAF59','10.35.90',To_Date('2018-03-02 14:36:21', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-12-16 02:25:54', 'yyyy-mm-dd HH24:mi:ss'),0,'[APPSOFT]',Null,Null,'部件功能:LIS图片数据转出单独执行文件',0,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLLISPIC2FTPSUB.EXE','A039D3BACAE7A7C8AC794254BB25E81A','10.35.90',To_Date('2018-03-02 14:36:42', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2018-01-18 02:25:54', 'yyyy-mm-dd HH24:mi:ss'),0,'[APPSOFT]',Null,Null,'部件功能:LIS图片数据转出子程序',0,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLLOGIN.DLL','19456EF340BBE5B36B803DDFF76AC88E','10.35.90',To_Date('2018-03-02 14:32:25', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),0,'[PUBLIC]',Null,'1,3,4,6,21,22,23,24,25,26','部件功能:公共登录部件，提供统一登录接口，以及登陆中的功能、授权、客户端控制、升级等处理。系统定位:各个Exe均通过该部件实现登录。缺失后果:缺失该部件将会导致启动Exe程序出错。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLNewQuery.exe','38E957C113B997EBA0BFC792EC73EC19','10.35.90',To_Date('2018-03-02 14:03:27', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]',Null,'1','部件功能:老版自助系统系统定位:自助挂号、Lis打印、费用查询缺失后果:老版自助系统不能使用',0,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLPACSFTPTOOLS.EXE','2110B63987A4072EEFE5C2DB88A45EF7','1.0.0',To_Date('2017-10-23 09:49:29', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-10-25 16:49:54', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]','zl9PACSWork.dll','1','部件功能:对FTP进行测试，排查FTP相关操作错误。',0,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLPUBLICDRUG.DLL','A3F5D523C3F193951A4B413295A69451','10.35.90',To_Date('2018-03-02 14:33:44', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zlCISKernel.dll,zl9InExse.DLL,zl9OutExse.dll','1','部件功能:药品业务公共部件系统定位:其他业务调用药品公共功能接口缺失后果:其他业务调用药品公共功能错误',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLREGISTER.DLL','561FFA6F6E33A5BBE93FE5E3C282EEF7','10.35.90',To_Date('2018-03-02 10:18:31', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),0,'[PUBLIC]',Null,Null,'部件功能:用到此控件的界面不能正常打开，或者报错。使用原因:统一的注册校验、用户加密解密部件。缺失后果:相关流程无法进行身份验证，流程终止，包含：配血审核身份验证、发血身份验证、血液接收登记身份验证、输血执行身份验证。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLRPTSQLAdjust.exe','714965EB415CE338351CF6741A35E031','10.35.90',To_Date('2018-03-02 14:20:26', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),0,'[APPSOFT]',Null,Null,'部件功能:10.26病人费用表拆分配套工具。系统定位:进行大表拆分后的涉及病人费用记录的报表的调整。缺失后果:无法进行方便的进行大表拆分后的报表调整。',0,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLRUNAS.EXE','CACE237C26F0699C63828FF3D79B8566','9.43.0',To_Date('2013-11-04 10:14:23', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),4,'[APPSOFT]',Null,Null,'该文件在自动升级zlhisCrust.exe中使用。主要功能,在USER权限下可以使用管理员权限来进行登录执行管理操作',0,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLSOFTSHOWHISFORMS.EXE','CC265738CAAE7D860E42A4858AF45C10','10.35.90',To_Date('2018-03-02 14:33:47', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]','zl9XWInterface.dll','1','部件功能:显示病历查阅,医嘱，pacs历史报告等系统定位:ris中调用查看病历内容。缺失后果:ris系统不能查看病历内容。',0,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLSQLTRACE.EXE','F8DB1816A3ECA7BEE8DFBAA81F3D2EC8','10.35.90',To_Date('2018-03-02 14:33:50', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),0,'[APPSOFT]',Null,Null,'部件功能:zlSQL跟踪工具.',0,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLSoft.BusinessHome.ClientControl.TimeLineBase.dll','E7181C04903EA3430C6C1630785867AB','1.0.0',To_Date('2017-04-18 09:20:32', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),4,'[PUBLIC]',Null,Null,'部件功能:ZLSoft_BusinessHome_ClientControl_TimeLineBase使用原因:住院工作诊疗一览功能。缺失后果:住院诊疗一览功能不能使用，进入工作站时报错。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('Zl9DrugStore.dll','70F3717FC7B897A123FD9BDBD0E5911A','10.35.90',To_Date('2018-03-02 14:01:48', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'1','部件功能:药房事务系统定位:门诊、住院药房发药管理，输液配置中心管理缺失后果:无法使用门诊、住院药房管理功能，无法使用静配功能',1,0,Null);
EXECUTE Zlfiles_Autoupdate('Zl9LISComm.exe','7AF2CA9C9766D89E4596D2A87C70EAF6','10.35.90',To_Date('2018-03-02 14:14:07', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]','zl9LisWork.dll','1','部件功能:老版检验通讯程序系统定位:老版检验通讯程序，处理仪器回传数据，加工成检验系统能够认识的数据格式缺失后果:检验结果将不能正常回传给老版LIS系统',0,0,Null);
EXECUTE Zlfiles_Autoupdate('ZlBrw.dll','40A35B0FFEB6AFAA83A4E46FB14025BD','10.35.90',To_Date('2018-03-02 13:48:04', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),0,'[APPSOFT]\APPLY',Null,'1,3,4,6,21,22,23,24,25,26','部件功能:标准导航台样式，即双列表样式。系统定位:用来进行各个业务的导航，并提供一些基础的工具。缺失后果:缺失该部件，当选择的导航台样式为该样式时，无法进入整个系统。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZlMdi.dll','F50503CE571014D64C69FF84AE3EB60D','10.35.90',To_Date('2018-03-02 13:48:17', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),0,'[APPSOFT]\APPLY',Null,'1,3,4,6,21,22,23,24,25,26','部件功能:Mdi样式导航台，即父窗体里面存在各个子窗体。系统定位:用来进行各个业务的导航，并提供一些基础的工具。缺失后果:缺失该部件，当选择的导航台样式为该样式时，无法进入整个系统。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZlPacsSrv.exe','8DD9197F8D47A47C59AAE22A69C5C4AF','10.35.90',To_Date('2018-03-02 14:16:31', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]','zl9CISJob.dll','1','部件功能:接受Dicom设备发送的检查图像系统定位:PACS网关服务，监听影像DICOM设备请求并进行处理缺失后果:不能与影像DICOM设备通讯，不能接受设备图像',0,0,Null);
EXECUTE Zlfiles_Autoupdate('ZlPatiAddress.ocx','EBCF7CA356D7AC2636C1DCB1C7A751B2','10.35.90',To_Date('2018-03-02 13:59:30', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zl9RegEvent.dll,zl9CardSquare.dll,zl9CISJob.dll,zl9InPatient.dll,zl9Patient.dll,zl9MedRec.dll,zl9InExse.DLL','1','部件功能:结构化地址部件系统定位:支持系统中进行结构化地址填写缺失后果:无法使用入院、挂号、首页等相关程序',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZlWin.dll','84C7D99540681A882E00E123B46B1E85','10.35.90',To_Date('2018-03-02 13:48:21', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),0,'[APPSOFT]\APPLY',Null,'1,3,4,6,21,22,23,24,25,26','部件功能:仿Window桌面样式导航台。系统定位:用来进行各个业务的导航，并提供一些基础的工具。缺失后果:缺失该部件，当选择的导航台样式为该样式时，无法进入整个系统。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('_sql.schclass','DB00476956C307C75B75808662F482BE',Null,To_Date('2014-09-10 16:33:01', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),4,'[PUBLIC]',Null,Null,'SyntaxEdit控件SQL颜色方案配置文件。',0,0,Null);
EXECUTE Zlfiles_Autoupdate('codejock.calendar.v16.3.1.ocx','78ED7FE2F2076E79AE2E8FA2D40B44CF','16.3.1.0',To_Date('2016-06-28 11:33:16', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'部件功能:提供日期控件使用原因:使用日期控件缺失后果:程序无法使用',1,0,Null);
EXECUTE Zlfiles_Autoupdate('gacutil.exe','CB9A5FE7A8ACE0C5513DF6065F55F6F2','4.6.1055.0',To_Date('2016-10-27 15:08:12', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),4,'[PUBLIC]',Null,Null,'.net gac注册命令文件',0,0,Null);
EXECUTE Zlfiles_Autoupdate('gacutil.exe.config','7033A6FA2F8A457716F6D642137CC7DB',Null,To_Date('2016-10-27 15:08:12', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),4,'[PUBLIC]',Null,Null,'.net gac注册命令文件',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zL9CashBill.dll','D05C92C90464A76747103CEC1B734BE8','10.35.90',To_Date('2018-03-02 14:00:32', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll,zl9PeisManage.dll,zl9RegEvent.dll,zl9CardSquare.dll,zl9InExse.DLL,zl9OutExse.dll,zl9Patient.dll,zl9InPatient.dll,zl9CustAcc.dll','1','部件功能:财务监控及票据管理系统定位:收费轧帐、财务组收款、收费财务监控、人员借款和票据的入库、领用和报损。缺失后果:相关功能不能使用',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9AppTool.dll','622E08FAC668FCFF3C217E4024F5756F','10.35.90',To_Date('2018-03-02 13:45:04', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),0,'[PUBLIC]',Null,'1,3,4,6,21,22,23,24,25,26','部件功能:导航台的中提供的基础应用工具功能部件。系统定位:提供了个人系统级的个性化设置、系统基础字典数据管理、邮件收发管理等功能。缺失后果:缺失将会导致无法使用整个系统。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BaseItem.dll','6F97323A33F7E4A94F000A96E2DC95EE','10.35.90',To_Date('2018-03-02 14:00:26', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9BaseItem.dll,zl9InExse.DLL,zl9OutExse.dll','1','部件功能:基础数据管理系统定位:业务基础部件，包括部门，人员，收费项目，收入项目，各业务公共参数等基础设置缺失后果:无法进行基础数据设置',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Blood.dll','6720DB320C7AD6785F7E75F81D50628B','10.35.90',To_Date('2018-03-02 14:16:54', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'22','部件功能:血库系统核心框架部件系统定位:包含血库相关功能模块：血液目录管理、血液供应入出库、科室配血管理、科室发血管理、血袋回收、报废等缺失后果:血库系统将无法使用',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BodyEditor.dll','9780A8087241FAAD38186482516BFC4A','10.35.90',To_Date('2018-03-02 14:19:58', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:老版护士工作站中标准体温单相关功能调用,在未使用地区性体温部件时,均使用此部件系统定位:处理老版护士工作站中标准体温单相关业务缺失后果:无法使用老版护士工作站体温单的数据展示,编辑和打印功能',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BodyEditorGS.dll','13178A0AEB4B6FCB3C05DE39032B6885','10.35.90',To_Date('2018-03-02 14:21:18', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:甘肃中医院专用体温单部件系统定位:处理老版护士工作站中体温单的相关业务缺失后果:缺失后会使用标准版体温部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BodyEditorGX.dll','B512F25EAA1E3E7B7183F8C9902CAF41','10.35.90',To_Date('2018-03-02 14:21:28', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:老版护士工作站中体温单(广西地区适用)系统定位:处理老版护士工作站中体温单相关业务缺失后果:缺失会自动使用标准版体温部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BodyEditorHEN.dll','A5185C8D1F6CDF7C6583AC6498AACB92','10.35.90',To_Date('2018-03-02 14:22:03', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:老版护士工作站中体温单相关功能(河南地区适用)系统定位:处理老版护士工作站中体温单相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BodyEditorHN.dll','861339BB392AC5D37E019C6DB036670F','10.35.90',To_Date('2018-03-02 14:21:08', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:老版护士工作站中体温单相关功能(河南地区适用)系统定位:处理老版护士工作站中体温单相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BodyEditorHun.dll','C73812BF0CDC7959E350F39D11063865','10.35.90',To_Date('2018-03-02 14:22:19', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:老版护士工作站中体温单相关功能(湖南省通适用)系统定位:处理老版护士工作站中体温单相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BodyEditorQD.dll','1CD9E7095C323E7DFDB36DD79AFF9FA4','10.35.90',To_Date('2018-03-02 14:21:37', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:老版护士工作站中体温单相关功能(青岛地区适用)系统定位:处理老版护士工作站中体温单相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BodyEditorSCDQ.dll','089512C99673058996C0A373BA341718','10.35.90',To_Date('2018-03-02 14:20:20', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:老版护士工作站中体温单相关功能(四川地区通用)系统定位:处理老版护士工作站中体温单相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BodyEditorSXHZ.dll','4005990DB73DD6DB917238828E338A37','10.35.90',To_Date('2018-03-02 14:20:58', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:老版护士工作站中体温单相关功能(陕西省汉中市适用)系统定位:处理老版护士工作站中体温单相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BodyEditorSxet.dll','55680ACA85B427B37BE7DC5B6D0C68E1','10.35.90',To_Date('2018-03-02 14:22:12', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:老版护士工作站中体温单相关功能(陕西西安儿童医院适用)系统定位:处理老版护士工作站中体温单相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BodyEditorYDEY.dll','5D76A63D5355FAF8F1D8814F4648D2C6','10.35.90',To_Date('2018-03-02 14:20:32', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:老版护士工作站中体温单相关功能(医大二院适用)系统定位:处理老版护士工作站中体温单相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BodyEditorYX.dll','702E798CF53F2A5F440A3AEA6700A826','10.35.90',To_Date('2018-03-02 14:20:12', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:老版护士工作站中体温单相关功能(云南省玉溪市人民医院适用)系统定位:处理老版护士工作站中体温单相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9CISAudit.dll','0DD1D76523520C0A6F55E35658A54813','10.35.90',To_Date('2018-03-02 14:17:10', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'1','部件功能:电子病案审查归档系统定位:包含模块：病案评分标准、病案审查标准、电子病案审查、电子病案借阅、电子病案评分、病历质量查阅、电子病案接收；以电子病历质控为核心业务的应用模块集中于该部件中。缺失后果:质控相关模块窗口无法使用。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9CISBase.dll','2DEFAE05929AFE7DEA505D4C9A56BAD8','10.35.90',To_Date('2018-03-02 14:14:41', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISAudit.dll,zl9InExse.DLL,zl9LisWork.dll,zl9PACSWork.dll,zl9Oper.dll,zl9CISBase.dll,zl9Blood.dll,zl9CISJob.dll','1','部件功能:临床基础部件系统定位:设置药品目录，诊疗项目及相关，检查、检验、影像等相关基础数据缺失后果:无法设置药品目录，诊疗项目及相关，检查、检验、影像等相关基础数据',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9CISJob.dll','4471E60BBDDC0DA4772924C50C00D79D','10.35.90',To_Date('2018-03-02 14:13:35', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','Zl9DrugStore.dll','1','部件功能:临床工作站框架部件系统定位:住院医生站，住院护士站，新版护士站，老版护士站，老版医技站，电子病案查阅。缺失后果:以上工作站无法使用。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9CardSquare.dll','183836E7689698C8FC35E3DCC1AD19CC','10.35.90',To_Date('2018-03-02 14:05:27', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll,zl9PeisManage.dll,zl9RegEvent.dll,zl9Transfusion.dll,zl9Blood.dll,zl9CISAudit.dll,zl9PACSWork.dll,zl9OutExse.dll,zl9Oper.dll,zl9LisWork.dll,ZL9LabWork.dll,zl9InPatient.dll,zl9InExse.DLL,Zl9DrugStore.dll,zl9Patient.dll,zl9CISJob.dll,zl9CardSquare.dll,zl9XWInterface.dll,zl9Stuff.dll,zl9CISBase.dll','1','部件功能:结算卡管理部件系统定位:医疗卡、消费卡管理缺失后果:涉及一卡通的业务无法使用',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9ComLib.dll','33A1661D86F8F50158209C2EAC2A8213','10.35.90',To_Date('2018-03-02 13:42:12', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),0,'[PUBLIC]',Null,'1,3,4,6,21,22,23,24,25,26','部件功能:公共的基础函数库，用来提供统一的SQL查询、一些系统常用API封装、常用控件处理、常用类型方法以及应用系统基础业务的常用查询。系统定位:ZLHIS的系统底层支持部件，一般部件均使用该部件提供的公共方法进行编码缺失后果:整个应用系统无法使用。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9ComLibpss.dll','C083D8DCC77F4CF88081FEC86CECC56E','10.35.90',To_Date('2018-03-02 14:23:36', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zlWizardStart.exe','26','部件功能:导诊公共函数部件系统定位:提供公共方法函数（和导诊业务无关）缺失后果:系统不能运行',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9CommEvents.dll','8D61AD4F695B00240CC3E5689E961005','10.35.90',To_Date('2018-03-02 14:26:11', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),0,'[PUBLIC]',Null,'1,3,4,6,21,22,23,24,25,26','部件功能:公共的基础事件部件：自动发卡、投币、键盘输入和自动读卡事件触发后，主程序能够响应。系统定位:三方程序触发事件,以便主程序接收数据。缺失后果:自助发卡、自助系统的现金支付功能调用就会出现错误，所有使用第三方接口自动读卡也会出现错误。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9CustAcc.dll','A13149922EF09172D25B230A2C049E6C','10.35.90',To_Date('2018-03-02 14:00:39', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zl9BaseItem.dll,zl9InExse.DLL,zl9OutExse.dll','1','部件功能:自定义记帐单部件系统定位:专项记帐和专项记账单设置缺失后果:不能使用专项记帐单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Device.dll','2AA80A6E26C4A7867F719D45E2A92E76','10.35.90',To_Date('2018-03-02 14:15:42', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'6','部件功能:管理医院的设备系统定位:既可以独立存在，也可以共享标准系统存在缺失后果:缺少将无法管理设备',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Disease.dll','42249F2E3CEFFB0C8F55A71DC5EE9E17','10.35.90',To_Date('2018-03-02 14:08:17', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:传染病管理系统相关功能系统定位:处理传染病管理系统相关业务缺失后果:无法使用传染病填写、上报相关功能',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9DrawReport.dll','B03D98FF284BFDF69AF5CC8F2C13E1F0','10.35.90',To_Date('2018-03-02 14:17:34', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll,zl9PeisManage.dll,zl9Oper.dll','21,24','部件功能:zl9DrawReport系统定位:实现固定报告格式的打印输出预览缺失后果:不能实现打印输出预览功能',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Due.dll','271658E6E6C4B80441412F5677DB9E14','10.35.90',To_Date('2018-03-02 14:01:09', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'1','部件功能:付款管理部件系统定位:医院所有采购商品应付和已付的管理缺失后果:缺少将无法使用付款管理',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9ESign.dll','EA390E60D55727099788506015A74F27','10.35.90',To_Date('2018-03-02 13:45:15', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zl9CISJob.dll','1','部件功能:电子签名部件系统定位:集成不同CA厂商的电子签名接口并供各个业务模块调用。缺失后果:各个业务模块将无法启用电子签名功能',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Function.dll','A39479E2195EE3690F4A2E2DD74E84B3','10.35.90',To_Date('2018-03-02 13:44:16', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),0,'[PUBLIC]',Null,Null,'部件功能:函数管理工具。系统定位:进行自定义报表函数的管理。缺失后果:无法进行自定义报表函数的管理。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9HealthStation.dll','B4B3E4414F4A9822234D6571713FDFF4','10.35.90',To_Date('2018-03-02 14:35:43', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[Appsoft]\Apply','zl9PeisManage.dll,zlHealthLibrary.dll','27','实现健康体检中心产品的各种后台服务功能',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9InExse.DLL','CD1E9CA311AB4108D1B47A7F1FBFC02B','10.35.90',To_Date('2018-03-02 14:07:33', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll,zl9InPatient.dll,zl9OutExse.dll','1','部件功能:住院费用部件系统定位:住院记帐、科室分散记帐、医技科室记帐、自动记帐计算、病人费用查询、费用审核、执行登记、病人结帐处理。缺失后果:住院费用业务不能运行。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9InPatient.dll','BB4E8E7ED9A7C71B65BAA5420B6080EB','10.35.90',To_Date('2018-03-02 14:02:10', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll,zl9InExse.DLL','1','部件功能:住院病人部件系统定位:实现病人入院登记、病人入出管理、病区床位管理缺失后果:无法完成住院病人登记、病人入出管理、病区床位管理',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Infect.dll','2B583B3A6D4DDCFD696EC8D27B1E7FAF','10.35.90',To_Date('2018-03-02 14:16:45', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'23','部件功能:院感管理系统核心框架部件系统定位:院感系统核心功能窗体，含：病例监测管理、病例日报管理、人员监测管理、医院感染汇总表缺失后果:无法使用院感系统',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9LCDShow.dll','587EAD6BDD99F367242AD6246899B0A7','10.35.90',To_Date('2018-03-02 14:14:31', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9Transfusion.dll','1','部件功能:老版排队显示业务封装系统定位:老版排队情况封装缺失后果:不能显示排队情况',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9LabPrintSvr.exe','767BB68A1581EADA713C31B992708D64','10.35.90',To_Date('2018-03-02 14:23:31', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]','ZL9LabWork.dll','25,26','部件功能:新版LIS打印服务系统定位:主要处理 批量打印报告缺失后果:导诊和新版LIS打印报告部分将不能使用',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9LabReceiv.exe','2F11FC848AF96A525A6B35B513AE9D4B','10.35.90',To_Date('2018-03-02 14:23:23', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]','ZL9LabWork.dll','25','部件功能:新版LIS通讯程序部件。系统定位:主要处理与仪器接口之间数据交互。缺失后果:不能正常解析仪器数据',0,0,'[APPSOFT]\DEV_[*]');
EXECUTE Zlfiles_Autoupdate('zl9LabTcpSvr.exe','A7DC34B2362935DC167AE15D35B43EC3','10.35.90',To_Date('2018-03-02 14:23:31', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]','ZL9LabWork.dll','25','部件功能:新版LIS检验消息转发部件系统定位:处理实验室和通讯程序间的消息转发缺失后果:数据不能正常转发',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9LedVoice.dll','E011B0939BE6A0B686EE7009C7D4BCAC','10.35.90',To_Date('2018-03-02 13:44:19', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zl9RegEvent.dll,zl9CardSquare.dll,zl9InExse.DLL,zl9OutExse.dll,zl9Patient.dll,zl9InPatient.dll','1','部件功能:LED显示、语言报价部件系统定位:向病人显示收费信息缺失后果:不能支持语言半价或者在LED屏显示信息',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9LisQuery_Base.dll','1A65B24FEFA66DC243EE54C956358635','10.35.90',To_Date('2018-03-02 14:20:48', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9LisWork.dll','1','部件功能:检验外挂接口部件系统定位:支持检验外挂接口。缺失后果:综合查询外挂不能加载',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9LisQuery_Dfn.dll','0BE8EEAD6D6EB47F9C63E2685EE955AF','10.35.0',To_Date('2015-12-01 09:06:50', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zl9LisWork.dll','1','部件功能:老版LIS外挂部件系统定位:加载渠道开发的外挂部件缺失后果:不能正常加载外挂',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9LisWork.dll','513A95E750E182127B3FDEE1A139B4C9','10.35.90',To_Date('2018-03-02 14:14:46', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:老版LIS核心部件。系统定位:处理检验相关操作。包含检验技师工作站、检验采集工作站、检验登记。缺失后果:检验相关业务讲不能正常使用。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Material.dll','DED8B121638B29E90EE1EDC1E9ADB88C','10.35.90',To_Date('2018-03-02 14:15:45', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'4','部件功能:管理医院的物资系统定位:既可以独立存在，也可以共享标准系统存在缺失后果:缺少将无法管理物资',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9MedRec.dll','281C062CD8BFFCCF797CF86E92550BEE','10.35.90',To_Date('2018-03-02 14:16:09', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'3','部件功能:病案管理事务系统定位:病案系统管理、门诊日报、住院日报功能缺失后果:病案系统、门诊、住院日报功能失效。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9MediStore.dll','15F1B2A777D6D0DD27AB58D0452A9F11','10.35.90',To_Date('2018-03-02 14:03:05', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'1','部件功能:zlMediStore系统定位:药品流通业务部件，如入库，出库，盘点等业务操作缺失后果:无法进行药品流通业务',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Oper.dll','7E7CBBEC48B50323BB2B056DB694283B','10.35.90',To_Date('2018-03-02 14:18:14', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'24','部件功能:手术麻醉部件系统定位:实现手术安排及相关计费缺失后果:手麻产品不能运行',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9OpsStarand.dll','DD4A57908BA201DBFCE67314CFA63BA1','10.35.90',To_Date('2018-03-02 14:18:12', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9Oper.dll','24','部件功能:手术麻醉单打印预览系统定位:生成手术麻醉单，并进行打印或预览缺失后果:不能生成手术麻醉单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9OutExse.dll','6006664F21CCACB8175C340A9D08B328','10.35.90',To_Date('2018-03-02 14:03:49', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','Zl9DrugStore.dll','1','部件功能:门诊费用部件系统定位:门诊划价、门诊收费、门诊记账缺失后果:缺失上述功能',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PACSWork.dll','A70004238DBA8AAC9D2B29FF1A976891','10.35.90',To_Date('2018-03-02 14:20:22', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'1','部件功能:进行影像系统基本业务处理系统定位:封装了对影像系统基本业务的处理，是业务系统的入库。缺失后果:不能进入对应的影像系统。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PacsControl.ocx','9B7CDE317DA6F8FAEA7027DF069C4F05','10.35.90',To_Date('2018-03-02 14:44:09', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9PACSWork.dll','1','部件功能:自定义控件封装系统定位:对常用的控件进行封装缺失后果:进入影像系统将产生异常',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PacsCore.dll','012F1243A50A103067945B64E402EA4E','10.35.90',To_Date('2018-03-02 14:18:57', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9PACSWork.dll','1','部件功能:PACS观片处理部件系统定位:查看PACS图像缺失后果:不能进行影像观片',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Partogram.dll','944D7ABDC5B14A70472528F51BB3060E','10.35.90',To_Date('2018-03-02 14:23:18', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:产程图管理相关功能系统定位:处理产程图相关业务缺失后果:无法使用产程图展示,编辑,打印功能',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Patient.dll','B08A0FE7CE89D50A5B953D3BB6E8743C','10.35.90',To_Date('2018-03-02 14:03:31', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9RegEvent.dll,zl9CardSquare.dll,zl9InExse.DLL,zl9OutExse.dll,zl9InPatient.dll','1','部件功能:病人信息管理部件。系统定位:病人信息登记、修改、删除等操作。缺失后果:无法对病人信息进行维护。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PeisBase.dll','6E07AF79012CB0484FFEBAADD99AC258','10.35.90',To_Date('2018-03-02 14:31:09', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll','21','部件功能:体检基础业务系统定位:体检基础数据设置（增删改），包括体检相关的公共或系统参数设置，是体检产品运行必不可少的部件。缺失后果:不能维护体检基础数据；同时体检业务大部份功能也会不正常。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PeisComLib.dll','6C17BCE7731686C9C4F230F99FE53243','10.35.90',To_Date('2018-03-02 14:41:51', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','ZL9Peis.dll,zl9PeisManage.dll,zl9PeisBase.dll','21','部件功能:体检公共组件系统定位:给体检基础功能和业务功能提供公共的方法函数缺失后果:整个体检产品无法使用。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PeisDevAnalyse.dll','191FB33503B62F5F44588EFB0B4606E6','10.35.0',To_Date('2015-12-01 09:22:53', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll,zl9PeisManage.dll,zl9PeisBase.dll','21','部件功能:体检非标准串口的接口程序系统定位:定时读取非标准串口仪器所产生的指标结果数据缺失后果:不能接收到非标准串口仪器的指标结果数据',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PeisFlow.dll','D86AF21680B3DCFB54AA1814B3C20920','10.35.90',To_Date('2018-03-02 14:30:13', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll,zl9PeisManage.dll,zl9PeisBase.dll','21','部件功能:体检执行业务系统定位:实现体检分科、总检等业务功能缺失后果:体检产品不能使用',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PeisInnerInterface.dll','18DA0C3ADC0B231DB708F6982BE69B1C','10.35.90',To_Date('2018-03-02 14:29:31', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll,zl9PeisManage.dll,zl9PeisBase.dll','21','部件功能:体检内部接口系统定位:实现费用、排队叫号、医嘱、票据等的数据交换缺失后果:体检产品不能正确运行',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PeisInstrument.dll','E72B4A469D1F491BB4DA1E110169A4E2','10.35.0',To_Date('2015-12-01 09:20:44', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll,zl9PeisManage.dll,zl9PeisBase.dll','21','部件功能:体检基本仪器数据接口系统定位:完成体检基本仪器数据传输接口缺失后果:不能接收到身高体重仪等基本仪器数据',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PeisInterface.dll','0A34255A6DF04C8305B2BA01A0CC46AF','10.35.90',To_Date('2018-03-02 14:20:44', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll,zl9PeisManage.dll,zl9PeisBase.dll','21','部件功能:第三方体检接口部件系统定位:实现三方体检和ZLHIS的数据交换缺失后果:不能实现三方体检和ZLHIS的接口',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PeisManage.dll','9B4183F73FAB814DEB6F370D49BF86FE','10.35.90',To_Date('2018-03-02 14:31:01', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll','21','部件功能:体检管理业务系统定位:实现体检登记、报到、填写结果、打印报告、指引单等业务缺失后果:体检产品不能使用。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PeisPersonPDF.dll','DC508F36DEDF6CE94A450A463DA2910C','10.35.90',To_Date('2018-03-02 14:31:38', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll,zl9PeisManage.dll,zl9PeisBase.dll','21','部件功能:体检报告PDF输出接口系统定位:体检报告打印三方生成的PDF文件缺失后果:不能完整输出体检报告内容',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PeisPersonReport.dll','347DE30055B963F884B128DC81E50F0D','10.35.90',To_Date('2018-03-02 14:31:34', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll,zl9PeisManage.dll,zl9PeisBase.dll','21','部件功能:体检个人报告自定义报表系统定位:体检报告中需要调用自定义报表进行打印缺失后果:体检报告中自定义报表时不能输出完整的体检报告',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PeisPersonRpt.dll','29CD77A7B7E4786B550F285D2B68C84C','10.35.90',To_Date('2018-03-02 14:21:46', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll,zl9PeisManage.dll,zl9PeisBase.dll','21','部件功能:个人体检报告输出系统定位:按固定的格式生成报告打印数据缺失后果:不能输出个人体检报告',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PeisRpt.dll','4BFFCFEAF162E24E7F35D8D9FCEE47FC','10.35.90',To_Date('2018-03-02 14:18:18', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll,zl9PeisManage.dll,zl9PeisBase.dll','21','部件功能:体检报告格式系统定位:个人体检报告的内容生成缺失后果:不能生成报告内容',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PrintMode.dll','47702A89B3756E184360468ED1150259','10.35.90',To_Date('2018-03-02 13:44:27', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),0,'[PUBLIC]',Null,'1,3,4,6,21,22,23,24,25,26','部件功能:打印表格控件内容、通过命令生成输出内容等系统定位:方便用户输出数据缺失后果:可以缺少，但无法输出数据',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Purvey.dll','F9DECD7D163549B18BAA0DBFB5DC8B6D','10.35.90',To_Date('2018-03-02 14:17:28', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9Material.dll','4','部件功能:管理供应室的器械包系统定位:属于物资系统的子系统缺失后果:缺少将无法管理器械包',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9RecipeAudit.dll','52238360BC7BF9EB6151F6BB21D833F3','10.35.90',To_Date('2018-03-02 14:32:21', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:药剂师对门诊和住院的用药处方审查系统定位:控制有问题的处方，提升处方合格率缺失后果:缺少将无法使用处方审查系统',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9RegEvent.dll','F360E3275937F6BFE9161CD32F32954D','10.35.90',To_Date('2018-03-02 14:05:14', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll,zl9OutExse.dll','1','部件功能:门诊挂号部件系统定位:设置挂号安排和临床出诊，提供挂号、预约、分诊等功能，提供患者服务中心对病人预约进行管理缺失后果:与挂号相关的功能不能使用',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Report.dll','A114564D7486671E66592394E2D6AAEF','10.35.90',To_Date('2018-03-02 13:45:15', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),0,'[PUBLIC]',Null,'1,3,4,6,21,22,23,24,25,26','部件功能:支持业务系统输出自定义报表的内容，以及设计自定义报表系统定位:方便用户和技术人员缺失后果:缺少将无法输出报表和设计报表',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Stuff.dll','32789D1A878A7BC08AA1DD2861B11F29','10.35.90',To_Date('2018-03-02 14:05:43', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','Zl9DrugStore.dll','1','部件功能:zl9Stuff系统定位:卫材业务部件，包括卫材目录，卫材入出流通管理，卫材发放管理等缺失后果:不能开展卫材流通，发放等业务',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChart.dll','41572FD87264044A78797E22C5283D13','10.35.90',To_Date('2018-03-02 14:10:28', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:新版护士工作站体温单相关功能(标准体温单,未启用地区性体温单时均使用此体温单)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:无法进行体温单的展示和数据编辑功能',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChartGD.dll','5CF0867FF47C6C261F4BF9DEC0BA8FE0','10.35.90',To_Date('2018-03-02 14:29:29', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:新版护士工作站体温单相关功能(广东省地区适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChartGS.dll','B5A0F5E19DBA84E1C45BC320E840CFE2','10.35.90',To_Date('2018-03-02 14:11:02', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:新版护士工作站体温单相关功能(甘肃中医院适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChartGX.dll','864CE2ED0B5E402424D54AC53C56A4D8','10.35.90',To_Date('2018-03-02 14:10:39', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:新版护士工作站体温单相关功能(广西省适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChartGZJX.dll','E18DE3D7ED5828633A2B5C85A8A311D0','10.35.90',To_Date('2018-03-02 14:33:28', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:新版护士工作站体温单相关功能(广州揭西适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChartHLJ.dll','6B91AF0EEEFED06A25971F947CCCAFEB','10.35.90',To_Date('2018-03-02 14:32:42', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:新版护士工作站体温单相关功能(黑龙江地区适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChartHnnx.dll','180F426FDE7F4EE0923AF1360F4EC9E5','10.35.90',To_Date('2018-03-02 14:28:45', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:新版护士工作站体温单相关功能(湖南宁乡人民医院适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChartJX.dll','6E6C4976AD6AF4FAEEC238C7DD389B36','10.35.90',To_Date('2018-03-02 14:33:06', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:新版护士工作站体温单相关功能(江西省适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChartNJ.dll','210E825D6C5A0E527544B86BEFC62829','10.35.90',To_Date('2018-03-02 14:31:56', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:新版护士工作站体温单相关功能(江苏地区适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChartS3201.dll','27C2F04659FEBB5E19454EA1A08F74BD','10.35.90',To_Date('2018-03-02 14:10:50', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:新版护士工作站体温单相关功能(陕西3201医院适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChartSC.dll','6850CF060F533A9B979FE48EDCF5BAE0','10.35.90',To_Date('2018-03-02 13:48:37', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:新版护士工作站体温单相关功能(四川地区通用体温部件)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChartSCZG.dll','7B6BB6EC1D98A77B06EC1D36C3680DAE','10.35.90',To_Date('2018-03-02 13:48:52', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:新版护士工作站体温单相关功能(四川自贡市适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChartSX.dll','15C02F3B0E9904D257B91C07E85C74C1','10.35.90',To_Date('2018-03-02 14:27:09', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:新版护士工作站体温单相关功能(山西地区适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChartYDEY.dll','6A51920A8012FEC6E762AC7938B22062','10.35.90',To_Date('2018-03-02 14:29:11', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:新版护士工作站体温单相关功能(医大二院适用)系统定位:处理新版护士工作站中体温单的相关业务缺失后果:缺失会自动使用标准体温单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TendFile.dll','ABEB8917BA1C900AF7613925B328CC23','10.35.90',To_Date('2018-03-02 14:11:20', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISAudit.dll,zl9CISJob.dll,zl9Oper.dll','1','部件功能:处理护士工作站记录单相关业务系统定位:护士工作站中记录单相关业务流程缺失后果:无法在护士工作站中进行记录单的查看和操作',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Transfusion.dll','9D5B03A44E552C32E8F78B852901C6CF','10.35.90',To_Date('2018-03-02 14:16:13', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'1','部件功能:门诊输液系统部件系统定位:处理门诊输液执行、附费相关业务缺失后果:无法使用门诊输液工作站',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardCards.dll','16C72A95209D6DC9EA02696A2F47BBA3','10.35.90',To_Date('2018-03-02 14:28:36', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','26','部件功能:自助发卡与签约系统定位:提供自助设备上进行发卡和绑定卡操作缺失后果:自助发卡与签约功能缺失',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardControl.ocx','ACBCEB196EC6FDB2E850FF424424F484','10.35.90',To_Date('2018-03-02 14:26:08', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zlWizardStart.exe','26','部件功能:提供自助系统所需要的控件系统定位:完成自助系统的控件统一效果及功能实现缺失后果:不能运行自助系统并报错',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardDeposit.dll','4E42E6B12766610D8822332AEC23BD6B','10.35.90',To_Date('2018-03-02 14:27:38', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','26','部件功能:自助充值管理系统定位:提供门诊预交和住院预交以及历史充值记录查询缺失后果:自助充值及查询功能缺失',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardEMR.dll','FF78DE8F49143EE2D772AF6BE9608EC5','10.35.90',To_Date('2018-03-02 14:31:19', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','26','部件功能:zl9WizardEMR系统定位:门诊电子病历缺失后果:无法使用自助服务系统门诊电子病历相关功能',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardFeeQuery.dll','E4BE903488692F3E1D7364552F49593F','10.35.90',To_Date('2018-03-02 14:27:45', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','26','部件功能:自助费用查询系统定位:自助设备上查询病人门诊和住院费用缺失后果:自助费用查询功能缺失',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardInvoice.dll','A22FE5BDBB8B8503BC175F3E682ED3BA','10.35.90',To_Date('2018-03-02 14:27:51', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','26','部件功能:自助票据打印系统定位:自助设备上对未打印票据的缴费和挂号单据打印票据缺失后果:挂号和收费票据打印功能缺失',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardLABCall.dll','36389D23DDA16272F6EF53FE178D6EE5','10.35.90',To_Date('2018-03-02 14:28:23', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','26','部件功能:zl9WizardLABCall系统定位:检验叫号缺失后果:暂无',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardLabPrint.dll','247D4197E8FA5C000AFCC3E6D32436B2','10.35.90',To_Date('2018-03-02 14:27:57', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','25','部件功能:导诊打印老版LIS报告系统定位:在导诊系统中，打印老版LIS相关报告缺失后果:不能正常打印老版LIS报告',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardLib.dll','0BBC4CBEE94CDBF209ABF47794711E73','10.35.90',To_Date('2018-03-02 14:24:31', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zlWizardStart.exe','26','部件功能:病人自助系统公共库系统定位:提供自助系统中需要使用的方法函数缺失后果:系统不能运行',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardMain.exe','3A648F8229A967FE6EFC839539B33C06','10.35.90',To_Date('2018-03-02 14:28:26', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]',Null,'26','部件功能:病人自助系统后台管理程序系统定位:完成自助系统的所有后台设置，包括资源配置、动态页面设计、静态页面参数等缺失后果:系统不能正常运行',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardManage.dll','AB1A3D7FB325822FA3742F8AE0060B16','10.35.90',To_Date('2018-03-02 14:26:54', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9WizardMain.exe','26','部件功能:自助系统后台管理系统定位:配置自助系统的资源、页面、参数等缺失后果:不能启动后台管理',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardPage.dll','5FE4DE249134F36748CD9CA9F9C156BF','10.35.90',To_Date('2018-03-02 14:26:22', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','26','部件功能:自助动态页面显示系统定位:根据动态页面的设计显示最终的页面展示效果缺失后果:自助系统不能使用',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardPayFee.dll','4CF210BE3069AC4CF450C17D8BAD59FF','10.35.90',To_Date('2018-03-02 14:44:22', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','26','部件功能:自助缴费管理系统定位:自助设备上对划价单据进行缴费缺失后果:自助缴费功能缺失',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardPeisQueue.dll','29766D06784FDA6B02302B4401188768','10.35.90',To_Date('2018-03-02 14:28:55', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','26','部件功能:体检自助排队系统定位:体检人员通过病人自助系统提供体检自助排队功能进行自助体检排队缺失后果:体检人员无法自助排队',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardPharmacy.dll','712576039471DBC1065E1F84A5BA3877','10.35.90',To_Date('2018-03-02 14:33:12', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','26','部件功能:自助系统中的门诊药房病人签到管理系统定位:作为自助系统的一部分存在缺失后果:缺少将无法使用门诊药房签到',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardPrice.dll','4799A9949BA67609FD3548C2159ABF0D','10.35.90',To_Date('2018-03-02 14:26:27', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','26','部件功能:提供收费项目的价格自助查询系统定位:通过简码等实现收费项目价格的自助查询缺失后果:不能自助查询价格',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardProficient.dll','831C124E5629FD6426ACEE170E5505BE','10.35.90',To_Date('2018-03-02 14:26:33', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','26','部件功能:实现医院专家介绍自助查询系统定位:实现医院专家介绍自助查询缺失后果:不能实现专家介绍查询',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardProof.dll','641CE96026FEF8B72B68DE11A5C57A4E','10.35.90',To_Date('2018-03-02 14:31:29', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','26','部件功能:自助凭条打印系统定位:自助设备上打印缴费和挂号凭条缺失后果:缴费和挂号凭条打印功能缺失',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardRegEvent.dll','9608206D319F177D955D98823B607694','10.35.90',To_Date('2018-03-02 15:26:22', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','26','部件功能:自助挂号和预约系统定位:自助设备上病人进行挂号和预约以及取号缺失后果:挂号和预约以及取号功能缺失，今日就诊也不能进行挂号',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardToday.dll','9CCC2474F8A8E363BD7B069FDEB625D6','10.35.90',To_Date('2018-03-02 14:26:46', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','26','部件功能:今日就诊系统定位:查询挂号安排，进行挂号/预约，查看挂号科室上班时间缺失后果:挂号、预约以及查询功能缺失',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9keyboard.dll','94EFD2A89C9714355BDC7BB8EA7F8143','10.35.0',To_Date('2015-12-01 09:01:40', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zl9RegEvent.dll,zl9CardSquare.dll,zl9Patient.dll,zl9InPatient.dll','1','部件功能:密码键盘部件系统定位:使用密码键盘设备缺失后果:密码键盘无法使用',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9peisgrouprpt.dll','498174AD806C5669911CB37595770B9A','10.35.90',To_Date('2018-03-02 14:21:53', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll,zl9PeisManage.dll,zl9PeisBase.dll','21','部件功能:体检团体报告预览及打印输出。系统定位:实现体检团体报告预览及打印输出。缺失后果:不能实现团体报告预览及打印输出',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlActMain.exe','65663FF8AF4A50627C8996BEFD5190EB','10.35.90',To_Date('2018-03-02 14:29:30', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),0,'[APPSOFT]',Null,'1,3,4,6,21,22,23,24,25,26','部件功能:BH融合中的虚拟导航台。系统定位:BH调用各个模块均通过该程序进行导航。缺失后果:缺失时BH无法使用所有的业务模块。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlCISKernel.dll','3F44F52CC4D47AA0FE3699AA56BDBB1F','10.35.90',To_Date('2018-03-02 14:08:19', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISAudit.dll,zl9InExse.DLL,zl9LisWork.dll,zl9PACSWork.dll,zl9Oper.dll,zl9CISBase.dll,zl9Blood.dll','1,22,24,25','部件功能:临床核心部件，提供医嘱相关操作封装等接口，提供DOCK页签等。系统定位:提供医嘱核功能缺失后果:临床医嘱相关功能丢失，各大工作站的医嘱信息页签丢失。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlCISPath.dll','32245485C9E276D15EB955E1D3F7A3CC','10.35.90',To_Date('2018-03-02 14:08:54', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISAudit.dll,zl9CISJob.dll','1','部件功能:临床路径部件系统定位:临床路径应用、临床路径管理、临床路径跟踪缺失后果:临床路径应用、临床路径管理、临床路径跟踪将无法正常运行',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlCisAuditPrint.EXE','C5628B8D9F9B0AF3DF5A7AED4A702F44','10.35.90',To_Date('2018-03-02 14:31:32', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISAudit.dll','1','部件功能:用于电子病案审查中,文件-输出到PDF系统定位:避免连续PDF输出引起系统GDI超量，导致系统假死缺失后果:无法进行PDF输出',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlDisReportCard.DLL','DC98D565144F2B6621BB0402FEA8E6A4','10.35.90',To_Date('2018-03-02 14:31:29', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9Disease.dll','1','部件功能:传染病固定格式报告卡控件系统定位:用于填写传染病报告卡缺失后果:无法使用固定格式传染病报告卡',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlDisReportCardEx.DLL','EADF06F9CE5B26E0A72C34E2AEC719C8','10.35.90',To_Date('2018-03-02 14:33:55', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlDisReportCard.DLL','1','部件功能:保存传染病报告卡格式',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlGetImage.exe','A82CE3C9D334A7435A2E61ABBE65DD40','10.35.90',To_Date('2018-03-02 14:22:21', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9PACSWork.dll','1','部件功能:提供影像检查图像下载支持系统定位:后台下载影像检查图像缺失后果:不能观片',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zlHealthBase.dll','3849824F61E9F50D6A4A408D66A72160','10.35.90',To_Date('2018-03-02 14:35:37', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[Appsoft]\Apply','zl9PeisManage.dll,zlHealthLibrary.dll','27','实现健康体检中心产品基础数据设置',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zlHealthControl.ocx','23BEBBA02DE78FD5FD4BC10AC51746B2','10.35.90',To_Date('2018-03-02 14:34:21', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zl9PeisManage.dll,zlHealthLibrary.dll','27','实现健康体检中心产品中所使用到的各种控件定义',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zlHealthCore.dll','F552ECEFE0123F81C3F6B0A37D70D60E','10.35.90',To_Date('2018-03-02 14:36:32', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[Appsoft]\Apply','zl9PeisManage.dll,zlHealthLibrary.dll','27','实现健康体检中心产品的业务功能',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zlHealthData.dll','1E9199BDB7056E8C2222D8F229FEEA7A','10.35.90',To_Date('2018-03-02 14:34:35', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[Appsoft]\Apply','zl9PeisManage.dll,zlHealthLibrary.dll','27','实现健康体检中心产品中所有和数据交互接口',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zlHealthLibrary.dll','5B75F680A2717F0CEDD5BC860DEE5F3B','10.35.90',To_Date('2018-03-02 14:34:02', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[Appsoft]\Apply','zl9PeisManage.dll,zlHealthLibrary.dll','27','实现健康体检中心产品中所使用到的公共方法函数定义',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zlHealthPlugin.dll','3559595164C43159BC00FB81F9AF4DDA','10.35.90',To_Date('2018-03-02 14:34:20', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[Appsoft]\Apply','zl9PeisManage.dll,zlHealthLibrary.dll','27','实现健康体检中心产品与ZLHIS等产品的功能接口',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zlHealthService.exe','0866711B39EBBF0552AC6EC9AAD7ECBF','10.35.90',To_Date('2018-03-02 14:36:11', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[Appsoft]','zl9PeisManage.dll,zlHealthLibrary.dll','27','实现健康体检中心后台服务运行的启动程序',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zlHealthServiceData.dll','043D88A540AA3DB4A010F282D5AF1A28','10.35.90',To_Date('2018-03-02 14:35:53', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[Appsoft]\Apply','zl9PeisManage.dll,zlHealthLibrary.dll','27','健康体检中心产品的后台服务程序',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zlICCard.dll','91527424D177BD5B5678D658E1BCB8E7','10.35.90',To_Date('2018-03-02 13:45:24', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),0,'[PUBLIC]',Null,'1,3,4,6,21,22,23,24,25,26','部件功能:IC卡读卡的统一接口系统定位:IC卡读卡缺失后果:一卡通无法使用，部分会导致程序异常退出',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlIDCard.dll','EFFA1B66144402B546F12CBA0E27541E','10.35.90',To_Date('2018-03-02 13:45:18', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),0,'[PUBLIC]',Null,'1,3,4,6,21,22,23,24,25,26','部件功能:身份证读卡的统一接口系统定位:读取身份证信息缺失后果:无法读取身份证信息',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlIDKind.ocx','B54AF60C4DAFAED2558F5FA8F6A9910C','10.35.90',To_Date('2018-03-02 13:41:56', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),0,'[PUBLIC]',Null,'1,3,4,6,21,22,23,24,25','部件功能:病人身份识别控件系统定位:刷卡和读卡查询病人缺失后果:使用的地方应控件丢失出错',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlLISDev.dll','3FC44511F5769CEB1CEE238F236DA7CA','10.35.90',To_Date('2018-03-02 14:18:13', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe,zl9LisWork.dll,ZL9LabWork.dll','1,25','部件功能:处理检验仪器的数据、图片解析系统定位:让仪器数据，能够保存为我们认识的检验结果。缺失后果:检验仪器数据将不能正常解析到我们系统。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlLISInterface.DLL','E4B3E687EF2468627E4E20AA8481B171','10.35.90',To_Date('2018-03-02 14:31:14', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9LisWork.dll','1','部件功能:三方检验接口部件系统定位:支持三方检验接入到HIS系统中缺失后果:三方检验不能正常接入到his系统，该部件未正常发布。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlLisMessage.exe','FE24572860BC6502A61E6DE4477C082C','10.35.90',To_Date('2018-03-02 14:33:54', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]','ZL9LabWork.dll','25','部件功能:LIS消息部件系统定位:在大屏幕上显示某些检验科内部的情况缺失后果:无法再大屏幕上显示检验科内部的情况',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zlLisReceiveSend.exe','1A7E194151478D9BE76375DBF4890389','10.35.0',To_Date('2015-12-01 09:12:48', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]','zl9LisWork.dll','1','部件功能:主要与检验仪器直接通讯系统定位:记录仪器回传的检验结果，并保存文本为LIS认识的检验结果。缺失后果:如果缺失,老版LIS将不能正常解析检验数据',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zlMedRecPage.dll','E36F7B9CCB8D44FB944637950BF833D9','10.35.90',To_Date('2018-03-02 13:45:50', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zl9CISJob.dll,zl9MedRec.dll','1','部件功能:住院首页、病案首页程序系统定位:处理病人住院首页、病案首页相关业务缺失后果:临床工作站、病案系统等业务模块无法使用',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlOperInterface.dll','BB9F40FA814F15708C459BA2AB3BB770','10.35.90',To_Date('2018-03-02 14:20:40', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9Oper.dll','24','部件功能:三方手麻软件接口ZLHIS系统定位:实现三方手麻产品和ZLHIS产品之间的功能接口缺失后果:无法实现和ZLHIS的数据交换。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlOrclConfig.exe','BFC1E7171D907BB30B5A82FAAC4BED0F','10.35.0',To_Date('2015-12-01 09:23:20', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),0,'[APPSOFT]',Null,Null,'用于快速配置ORACLE配置文件的工具。',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zlPacsRichPages.ocx','1AECE8FE5ABB73B5DC04BE911A46D289','1.3520.345',To_Date('2016-08-08 15:17:06', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zlPublicPacs.dll','1','部件功能:封装pacs智能文档编辑器相关处理。系统定位:使用Pacs智能文档编辑器编辑需要。缺失后果:不能使用pacs智能文档编辑器',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlPacsVBCommon.dll','975C6D27982A00D58231A3C8850602B0','10.35.90',To_Date('2018-03-02 14:19:19', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zl9PACSWork.dll','1','部件功能:封装zlpacs与pacs智能报告编辑器之间的数据交换系统定位:zlpacs整合pacs智能报告编辑器缺失后果:不能使用pacs智能报告编辑器',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlPassInterface.dll','1BFEA3759F0F6FBB5CCF5BDE30ED66C3','10.35.90',To_Date('2018-03-02 14:06:10', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zl9CISJob.dll','1','部件功能:合理用药监测部件：集成了美康、大通、太元通、药卫士等合理用药监测接口。系统定位:供临床医生工作站、药品发药组件调用。缺失后果:合理用药监测功能无法启用。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlPeisAutoAnalyse.exe','B5FC34218A959A72EF0F2E5D3A52C5CD','10.35.90',To_Date('2018-03-02 14:29:18', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]','ZL9Peis.dll,zl9PeisManage.dll,zl9PeisBase.dll','21','部件功能:体检自动分析服务系统定位:实现非标准的仪器数据接口缺失后果:不能接收到非标准串口的体检仪器数据',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zlPictureEditor.dll','B6BD66212E619271BEE72C91EBE1C266','10.35.90',To_Date('2018-03-02 14:05:40', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','ZL9Peis.dll,zl9PeisManage.dll,zlWizardStart.exe,zl9Blood.dll,zl9CISJob.dll,zl9PACSWork.dll,zl9Oper.dll,zl9LisWork.dll,zl9Disease.dll,zl9CISAudit.dll','1','部件功能:用于对图片进行压缩处理系统定位:在病历标记图管理、电子病历编辑、保存过程中对图片进行压缩处理，以便优化处理后存入数据库缺失后果:因固定引用，缺少将无法使用电子病历所有模块',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlPublicAdvice.dll','5CB6EFDEDA4BF2EF72EC87ECC75AD0EF','10.35.90',To_Date('2018-03-02 14:09:03', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zl9CISJob.dll','1,21,22,24,25','部件功能:封装医嘱核心业务功能，提供公共接口，DOCK页签等。系统定位:封装工作站和医嘱核心业务功能缺失后果:通过该部件去使用临床功能会报错或者失效。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlPublicBlood.dll','19E3E41087ED95A314D738B14B8BBDC9','10.35.90',To_Date('2018-03-02 14:14:52', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),0,'[PUBLIC]',Null,'1','血库业务封装公共部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlPublicExpense.dll','B0F75B6B5EE0E30209C13C4240F6F605','10.35.90',To_Date('2018-03-02 13:47:25', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zl9InExse.DLL,zl9OutExse.dll','1','部件功能:费用公共部件。系统定位:提供医生站预约、挂号，医嘱附费等功能，提供公共接口。缺失后果:费用相关功能无法使用',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlPublicLIS.dll','61A4D98A98D6C53A5CCA98ADD8F34B69','10.35.90',To_Date('2018-03-02 14:09:06', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','ZL9LabWork.dll','25','部件功能:检验公共部件系统定位:检验业务中的公共部件。主要处理检验相关的业务缺失后果:目前影响输血申请单的使用',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlPublicPacs.dll','A844A05490237F2B2E3F7B1932C97B4C','10.35.90',To_Date('2018-03-02 14:10:02', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zl9PACSWork.dll','1','部件功能:封装PACS依赖业务调用接口系统定位:调用pacs相关的处理功能缺失后果:如临床不能进行pacs观片等',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlPublicPath.dll','1C34ACAAFE71F8C55109FBEE20BB40EF','10.35.90',To_Date('2018-03-02 14:10:04', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zl9CISJob.dll','1','部件功能:临床路径公共接口部件系统定位:提供临床路径开放接口缺失后果:临床路径功能无法正常运行',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlPublicPatient.dll','FE7EDB9444D4AF626F6B98ADC7846C9F','10.35.90',To_Date('2018-03-02 14:09:10', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zl9CISJob.dll,zl9Patient.dll,zl9InPatient.dll','1','部件功能:病人信息公共部件,封装了病人信息相关的公共方法：病人基本信息调整、身份证号反算年龄等。系统定位:供各个业务模块调用。如首页、病人信息管理、病人入院管理的基本信息调整功能。缺失后果:程序无法正常运行',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlPublicPeis.dll','D06D09AE0E7BCFDC603F14AD704BDD65','10.35.0',To_Date('2015-12-01 09:03:42', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','ZL9Peis.dll,zl9PeisManage.dll','21','部件功能:体检公共接口系统定位:提供其他业务或三方调用体检功能的接口（如生成PDF，查阅体检报告）缺失后果:该接口不能正常工作。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlQueueManage.dll','9312C26B141AF7781332E4B2F51B84C8','10.35.90',To_Date('2018-03-02 14:03:48', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll,zl9PeisManage.dll,zl9RegEvent.dll,zlWizardStart.exe,zl9CISJob.dll,zl9Transfusion.dll','1','部件功能:老板排队业务封装系统定位:老板排队支持缺失后果:不能进行排队管理',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlQueueOper.ocx','317B6FE0272027A71ACBE3D89921A736','10.35.90',To_Date('2018-03-02 14:18:23', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zl9Oper.dll,zl9PACSWork.dll','1','部件功能:排队叫号业务封装系统定位:pacs排队管理支持缺失后果:不能进行排队操作',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlQueueShow.exe','3D9D5F7E806DEAC41232A6FF6C02EF6E','10.35.90',To_Date('2018-03-02 10:06:26', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\ZLQUEUESHOW',Null,'1','部件功能:新版排队显示系统定位:pacs排队情况显示缺失后果:不能显示pacs排队状态',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zlRISDumpTool.exe','1CF2469D4736074A152351674E4819EE','10.35.90',To_Date('2018-03-02 14:33:05', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]',Null,'1','部件功能:基础数据，用户，诊疗项目，数据字典等初始化系统定位:初始化ris接口数据缺失后果:不能使用ris系统。',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zlRichEPR.DLL','192AD6F3BA6AACCF02F744BDC70F9BEC','10.35.90',To_Date('2018-03-02 14:44:58', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll,zl9PeisManage.dll,zlWizardStart.exe,zl9Blood.dll,zl9CISJob.dll,zl9PACSWork.dll,zl9Oper.dll,zl9LisWork.dll,zl9Disease.dll,zl9CISAudit.dll,zl9Disease.dll','1','部件功能:病历编辑窗口及业务处理程序系统定位:提供模块：病历标记图形管理、护理记录项目管理、病历文件管理、病历范文管理、诊疗单据设置、移动护士站基础设置、病人病历检索、疾病申报管理缺失后果:病历相关业务无法开展，医生工作站因直接引用，将无法打开。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlRichEditor.ocx','DFFCD62651577AE8AFAC678E0D1722B9','10.35.90',To_Date('2018-03-02 14:06:21', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','ZL9Peis.dll,zl9PeisManage.dll,zlWizardStart.exe,zl9Blood.dll,zl9CISJob.dll,zl9PACSWork.dll,zl9Oper.dll,zl9LisWork.dll,zl9Disease.dll,zl9CISAudit.dll,zl9Disease.dll','1','部件功能:病历编辑核心部件系统定位:提供病历编辑、打印输出功能缺失后果:无法编辑、打印病历',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlScreenKeyboard.exe','B8C3E47A26784CA912ADD4C91B43A991','10.35.0',To_Date('2015-12-01 09:23:05', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','部件功能:屏幕键盘小程序系统定位:在门诊医生工作站中用到，强制续诊，门诊医嘱下达缺失后果:强制续诊，门诊医嘱下达不能用使用键盘功能。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlSubclass.ocx','C41981C87A9DAC84B66E3C84A9512704','10.35.90',To_Date('2018-03-02 14:05:44', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','ZL9Peis.dll,zl9PeisManage.dll,zlWizardStart.exe,zl9Blood.dll,zl9CISJob.dll,zl9PACSWork.dll,zl9Oper.dll,zl9LisWork.dll,zl9Disease.dll,zl9CISAudit.dll,zl9Disease.dll','1','部件功能:鼠标、键盘勾子系统定位:用于向病历编辑相关模块提供鼠标、键盘勾子，以便在病历编辑过程中对界面内容进行鼠标控制、控件原有快捷键屏蔽。缺失后果:无法编辑病历',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlSvgProcess.dll','9E00926BA33C621864432B114DF8CE93','1.0.3',To_Date('2015-09-29 16:24:43', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','zl9PACSWork.dll','1','部件功能:svg图像转换使用原因:影像PACS智能报告编辑器检查图像转换缺失后果:不能查看报告图像',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlSvrNotice.exe','C02B7FFB9993DBF2A3E47513B7E511AC','10.35.90',To_Date('2018-03-02 13:45:42', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),0,'[APPSOFT]',Null,Null,'部件功能:自动提醒服务。系统定位:进行消息提醒的提示与阅读。缺失后果:无发处理消息提醒。',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zlSvrStudio.exe','BAF7748568BBD5E262CA977E8AC56398','10.35.90',To_Date('2018-03-02 13:47:07', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),0,'[APPSOFT]',Null,Null,'部件功能:ZLHIS系统的后台管理工具。系统定位:提供了系统的升级、安装、授权以及其他的实用功能，可以方便的进行后台管理。缺失后果:缺失该部件将会导致无法进行系统管理操作。',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zlSwitchEffect.dll','55968705B856B2947F168E114D35309C','10.35.0',To_Date('2015-12-01 09:22:27', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','26','部件功能:实现自助页面切换效果系统定位:实现自助页面切换效果缺失后果:自助页面切换时没有切换变换效果，直接切换。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlSwitchPage.dll','EDB7BEA3A23946049A12248AC02AD01E','10.35.0',To_Date('2015-12-01 09:22:25', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','26','部件功能:实现自助页面切换效果系统定位:实现自助页面切换效果缺失后果:没有切换效果',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlTable.ocx','85CA159B7A09F3A3E15E418100FC24CD','10.35.90',To_Date('2018-03-02 14:05:59', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[PUBLIC]','ZL9Peis.dll,zl9PeisManage.dll,zlWizardStart.exe,zl9Blood.dll,zl9CISJob.dll,zl9PACSWork.dll,zl9Oper.dll,zl9LisWork.dll,zl9Disease.dll,zl9CISAudit.dll,zl9Disease.dll','1','部件功能:向病历编辑过程中提供自定义内嵌表格支持系统定位:全文式病历编辑过程中，插入表格后编辑生成对应的表格图，以及后续编辑时再次进行编辑转换、以提供检查报告图组缺失后果:无法进行内嵌表格编辑',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlTableEPR.dll','2061CF249C9EBB18B54B32CAB568F84B','10.35.90',To_Date('2018-03-02 14:06:06', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZL9Peis.dll,zl9PeisManage.dll,zlWizardStart.exe,zl9Blood.dll,zl9CISJob.dll,zl9PACSWork.dll,zl9Oper.dll,zl9LisWork.dll,zl9Disease.dll,zl9CISAudit.dll,zl9Disease.dll','1','部件功能:表格式病历核心编辑器系统定位:用于以表格式病历进行编辑的主窗口、表格式病历的打印缺失后果:无法进行表格式病历编辑',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlUpgradeReader.exe','A060662DBD18A531ADF86F7EF22B152B','10.35.90',To_Date('2018-03-02 14:03:47', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),0,'[APPSOFT]',Null,Null,'部件功能:升级说明阅读器。系统定位:进行重大功能的核对以及培训事宜的处理。缺失后果:无法进行升级问题清单的阅读与核对。',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zlWizardNewLabPrint.dll','7A2C943C1042771B6689BC29148B6D27','10.35.90',To_Date('2018-03-02 14:27:30', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','25,26','部件功能:导诊新版LIS打印部件系统定位:在导诊系统中，进行新版LIS报告打印缺失后果:新版LIS报告将不能正常打印',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlWizardPacsPrint.dll','6FC2CA436B5D99F22DBFFDE70F7639B2','10.35.90',To_Date('2018-03-02 14:28:49', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlWizardStart.exe','26','部件功能:pacs报告自助打印系统定位:提供患者自助服务系统支持缺失后果:不能进行pacs自助打印',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlWizardStart.exe','03B9EE86936B7A8C1073A19E5FB4E098','10.35.90',To_Date('2018-03-02 14:26:56', 'yyyy-mm-dd HH24:mi:ss'),To_Date('', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]',Null,'26','部件功能:自助系统前台查询启动程序系统定位:启动自助系统前台功能缺失后果:不能运行自助系统前台查询',0,0,Null);

Commit;
