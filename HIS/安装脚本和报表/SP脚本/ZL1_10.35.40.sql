--[连续升级]1
--[管理工具版本号]10.35.40
--本脚本支持从ZLHIS+ v10.35.30 升级到 v10.35.40
--请以系统所有者登录PLSQL并执行下列脚本
--脚本执行后，请手工升级导出报表
Define n_System=100;
-------------------------------------------------------------------------------
--结构修正部份
-------------------------------------------------------------------------------
--103428:李南春,2017-02-16,医疗卡增加发卡控制
Alter Table 医疗卡类别 Add(发卡控制 number(2));

--103000:李南春,2017-02-08,保存病人手机号信息
Alter Table 病人信息 Add(手机号 Varchar2(50));

Create Index 病人信息_IX_手机号 on 病人信息(手机号) Tablespace zl9Indexhis;

--104750:刘尔旋,2017-01-09,销帐申请原因
Alter Table 病人费用销帐 Add 销帐原因 Varchar2(200);

--104247:胡俊勇,2017-01-03,停嘱原因修改
Create Table 停嘱原因
(
  编码 Varchar2(2),
  名称 Varchar2(50),
  简码 Varchar2(25), 
  缺省标志 Number(1)) 
Tablespace zl9BaseItem;

Alter Table 停嘱原因 Add Constraint 停嘱原因_PK Primary Key (编码) Using Index Tablespace zl9Indexhis;

Alter Table 停嘱原因 Add Constraint 停嘱原因_UQ_名称 Unique (名称) Using Index Tablespace zl9Indexhis;

--104448:张险华,2016-12-26,增加电子病历格式.文本内容
Alter Table 电子病历格式 Add 文本内容 Clob;

--104031:余智勇,2016-12-19,补充外键索引
Create Index 处方审查条件_IX_科室ID ON 处方审查条件(科室ID) Tablespace Zl9indexhis;
Create Index 处方审查条件_IX_医生ID ON 处方审查条件(医生ID) Tablespace Zl9indexhis;
Create Index 处方审查条件_IX_诊断ID ON 处方审查条件(诊断ID) Tablespace Zl9indexhis;
Create Index 处方审查条件_IX_疾病ID ON 处方审查条件(疾病ID) Tablespace Zl9indexhis;
Create Index 处方审查条件_IX_药名ID ON 处方审查条件(药名ID) Tablespace Zl9indexhis;

Create Index 处方审查记录_IX_提交科室ID ON 处方审查记录(提交科室ID) Tablespace Zl9indexhis;
Create Index 处方审查记录_IX_发药药房ID ON 处方审查记录(发药药房ID) Tablespace Zl9indexhis;

Alter Table 处方审查条件 Drop Constraint 处方审查条件_NN_类别;

--103946:黄捷,2016-12-15,RISID增加索引
Create Index 病人医嘱报告_IX_RISID On 病人医嘱报告(RISID)  Tablespace zl9Indexcis;


--103232:冉俊明,2016-12-15,临床出诊安排，按序号时段开放停诊安排。
Alter Table 临床出诊序号控制 Add 是否停诊 Number(2) Default 0;

--103544:廖思奇,2016-12-08,增加字段
Alter Table 影像插件功能 Add 自动执行时机 Number(5) Default 0;

--103310:李南春,2016-12-08,医疗卡卡号增加回车符位
Alter table 医疗卡类别 add 设备是否启用回车 NUMBER(1) default 0;

--103157:黄捷,2016-12-02,RIS分科室启用控制
create table RIS启用控制
(
  ID Number(18),
  检查类型   VARCHAR2(20),
  场合   Number(1),
  部门ID   NUMBER(18),
  是否启用RIS     Number(1),
  是否启用预约     Number(1)
)Tablespace ZL9CISREC;

Alter Table RIS启用控制 Add Constraint RIS启用控制_PK Primary Key (ID) Using Index Tablespace zl9indexhis;
Alter Table RIS启用控制 Add Constraint RIS启用控制_FK_部门ID foreign key (部门ID) references 部门表 (ID);

Create Sequence RIS启用控制_ID Start With 1;

--102641:胡俊勇,2016-11-25,RIS预约相关修改
Alter Table Ris检查预约 Add 序号 Number(18);

--102623:黄捷,2016-11-24,RIS打印预约通知
alter table RIS检查预约 add 是否打印 NUMBER(1);

Create Index RIS检查预约_IX_预约日期 On RIS检查预约(预约日期) Tablespace zl9Indexcis;

--102656:刘鹏飞,2016-11-16,病人护理文件续打ID字段添加索引
Create index 病人护理文件_IX_续打ID On 病人护理文件(续打ID) Pctfree 5 Tablespace zl9Indexcis nologging;

Drop Procedure ZL1_AUTOAPTALL;

--105308:李业庆,2016-10-20,药品零差价管理药品规格新增字段
Alter Table 药品规格 Add 是否零差价管理 Number(1);

--103974:李南春,2016-12-26,自动记账从病案主页获取病人基本信息
Create Or Replace View 在院病人自动记帐 As
Select p.病人id, p.主页id,Nvl(A.姓名,I.姓名) as 姓名, Nvl(A.性别,I.性别) as 性别, Nvl(A.年龄,I.年龄) as 年龄, Nvl(A.住院号,i.住院号) as 住院号, a.费别, p.科室id, p.病区id, p.床号, p.附加床位, p.收费细目id, p.收入项目id, 1 As 标志,
       p.现价 As 标准单价, p.开始日期, p.终止日期, p.终止日期 - p.开始日期 As 天数, p.数量, p.经治医师, p.责任护士, p.操作员编号, p.操作员姓名
From 病人信息 I, 病案主页 A,
     (Select b.病人id, b.主页id, b.科室id, b.病区id, b.床号, b.附加床位, p.收费细目id, p.收入项目id, p.现价, b.经治医师, b.责任护士, b.操作员编号, b.操作员姓名,
              Zl_Date_Half(Greatest(Least(Nvl(b.上次计算时间, b.开始时间), Nvl(b.终止时间, Greatest(Nvl(b.上次计算时间, b.开始时间))),
                                           Greatest(Nvl(b.上次计算时间, b.开始时间))), p.执行日期, Nvl(a.启用日期, Add_Months(Sysdate, -2)))) As 开始日期,
              Zl_Date_Half(Least(Nvl(b.终止时间, Greatest(b.开始时间, Sysdate)), Nvl(p.终止日期, Sysdate + 30) + 1)) As 终止日期, b.数量
       From 自动计价项目 A,
            (Select a.病人id, a.主页id, a.开始时间, a.附加床位, a.病区id, a.科室id, a.床号, a.床位等级id, 1 As 数量, a.责任护士, a.经治医师, a.终止时间,
                     a.操作员编号, a.操作员姓名, a.上次计算时间
              From 病人变动记录 A, 病人信息 B
              Where a.开始原因 <> 10 And a.病人id = b.病人id And a.主页id = b.主页id And b.在院 = 1
              Union All
              Select b.病人id, b.主页id, 开始时间, 附加床位, b.病区id, b.科室id, 床号, i.从项id As 床位等级id, i.从项数次 As 数量, 责任护士, 经治医师, 终止时间, 操作员编号,
                     操作员姓名, 上次计算时间
              From 病人变动记录 B, 收费从属项目 I, 病人信息 C
              Where b.病人id = c.病人id And b.主页id = c.主页id And c.在院 = 1 And b.床位等级id = i.主项id And b.开始原因 <> 10 And i.固有从属 > 0) B,
            收费价目 P
       Where a.病区id = b.病区id And Zl_Date_Half(Nvl(b.上次计算时间, b.开始时间)) <> Zl_Date_Half(Nvl(b.终止时间, Sysdate)) And p.现价 <> 0 And
             a.计算标志 = 1 And b.床位等级id = p.收费细目id And Zl_Date_Half(Nvl(b.终止时间, Sysdate)) >= Zl_Date_Half(p.执行日期) And
             Zl_Date_Half(b.开始时间) <= Zl_Date_Half(Nvl(p.终止日期, Sysdate) + 1) And
             Zl_Date_Half(Least(Nvl(b.终止时间, Sysdate), Nvl(p.终止日期, Sysdate + 30) + 1)) >=
             Zl_Date_Half(Nvl(a.启用日期, Add_Months(Sysdate, -2)))
       Union All
       Select b.病人id, b.主页id, b.科室id, b.病区id, b.床号, b.附加床位, p.收费细目id, p.收入项目id, p.现价, b.经治医师, b.责任护士, b.操作员编号, b.操作员姓名,
              Zl_Date_Half(Greatest(Least(Nvl(b.上次计算时间, b.开始时间), Nvl(b.终止时间, Greatest(Nvl(b.上次计算时间, b.开始时间))),
                                           Greatest(Nvl(b.上次计算时间, b.开始时间))), p.执行日期, Nvl(a.启用日期, Add_Months(Sysdate, -2)))) As 开始日期,
              Zl_Date_Half(Least(Nvl(b.终止时间, Greatest(b.开始时间, Sysdate)), Nvl(p.终止日期, Sysdate + 30) + 1)) As 终止日期, b.数量
       From 自动计价项目 A,
            (Select a.病人id, a.主页id, 开始时间, 附加床位, a.病区id, a.科室id, 床号, 护理等级id, 1 As 数量, 责任护士, 经治医师, 终止时间, 操作员编号, 操作员姓名, 上次计算时间
              From 病人变动记录 A, 病人信息 B
              Where 开始原因 <> 10 And a.病人id = b.病人id And a.主页id = b.主页id And b.在院 = 1
              Union All
              Select b.病人id, b.主页id, 开始时间, 附加床位, b.病区id, b.科室id, 床号, i.从项id As 护理等级id, i.从项数次 As 数量, 责任护士, 经治医师, 终止时间, 操作员编号,
                     操作员姓名, 上次计算时间
              From 病人变动记录 B, 收费从属项目 I, 病人信息 C
              Where b.护理等级id = i.主项id And b.病人id = c.病人id And b.主页id = c.主页id And c.在院 = 1 And b.开始原因 <> 10 And i.固有从属 > 0) B,
            收费价目 P, 收费项目目录 C
       Where a.病区id = b.病区id And b.附加床位 <> 1 And
             Zl_Date_Half(Nvl(b.上次计算时间, b.开始时间)) <> Zl_Date_Half(Nvl(b.终止时间, Sysdate)) And p.现价 <> 0 And a.计算标志 = 2 And
             b.护理等级id = p.收费细目id And b.护理等级id = c.Id And Nvl(c.计算方式, 0) <> 1 And
             Zl_Date_Half(Nvl(b.终止时间, Sysdate)) >= Zl_Date_Half(p.执行日期) And
             Zl_Date_Half(b.开始时间) <= Zl_Date_Half(Nvl(p.终止日期, Sysdate) + 1) And
             Zl_Date_Half(Least(Nvl(b.终止时间, Sysdate), Nvl(p.终止日期, Sysdate + 30) + 1)) >=
             Zl_Date_Half(Nvl(a.启用日期, Add_Months(Sysdate, -2)))
       Union All
       Select b.病人id, b.主页id, b.科室id, b.病区id, b.床号, b.附加床位, p.收费细目id, p.收入项目id, p.现价, b.经治医师, b.责任护士, b.操作员编号, b.操作员姓名,
              Zl_Date_Half(Greatest(Least(Nvl(b.上次计算时间, b.开始时间), Nvl(b.终止时间, Greatest(Nvl(b.上次计算时间, b.开始时间))),
                                           Greatest(Nvl(b.上次计算时间, b.开始时间))), p.执行日期, Nvl(a.启用日期, Add_Months(Sysdate, -2)))) As 开始日期,
              Zl_Date_Half(Least(Nvl(b.终止时间, Greatest(b.开始时间, Sysdate)), Nvl(p.终止日期, Sysdate + 30) + 1)) As 终止日期, a.数量
       From (Select 病区id, 计算标志, 收费细目id, 1 As 数量, 启用日期
              From 自动计价项目
              Union All
              Select 病区id, 计算标志, 从项id, i.从项数次 As 数量, 启用日期
              From 自动计价项目 A, 收费从属项目 I
              Where a.收费细目id = i.主项id And i.固有从属 > 0) A, 病人变动记录 B, 收费价目 P, 病人信息 C
       Where a.病区id = b.病区id And b.病人id = c.病人id And b.主页ID = c.主页ID And c.在院 = 1 And b.附加床位 <> 1 And b.开始原因 <> 10 And
             Zl_Date_Half(Nvl(b.上次计算时间, b.开始时间)) <> Zl_Date_Half(Nvl(b.终止时间, Sysdate)) And p.现价 <> 0 And
             a.收费细目id = p.收费细目id And (a.计算标志 = 6 And b.床位等级id Is Not Null Or a.计算标志 = 7) And
             Zl_Date_Half(Nvl(b.终止时间, Sysdate)) >= Zl_Date_Half(p.执行日期) And
             Zl_Date_Half(b.开始时间) <= Zl_Date_Half(Nvl(p.终止日期, Sysdate) + 1) And
             Zl_Date_Half(Least(Nvl(b.终止时间, Sysdate), Nvl(p.终止日期, Sysdate + 30) + 1)) >=
             Zl_Date_Half(Nvl(a.启用日期, Add_Months(Sysdate, -2)))) P
Where i.病人id = p.病人id And a.病人id = p.病人id And a.主页id = p.主页id;

Create Or Replace View 出院病人自动记帐 As
Select p.病人id, p.主页id, Nvl(A.姓名,I.姓名) as 姓名, Nvl(A.性别,I.性别) as 性别, Nvl(A.年龄,I.年龄) as 年龄, Nvl(A.住院号,i.住院号) as 住院号, a.费别, p.科室id, p.病区id, p.床号, p.附加床位, p.收费细目id, p.收入项目id, 1 As 标志,
       p.现价 As 标准单价, p.开始日期, p.终止日期, p.终止日期 - p.开始日期 As 天数, p.数量, p.经治医师, p.责任护士, p.操作员编号, p.操作员姓名
From 病人信息 I, 病案主页 A,
     (Select b.病人id, b.主页id, b.科室id, b.病区id, b.床号, b.附加床位, p.收费细目id, p.收入项目id, p.现价, b.经治医师, b.责任护士, b.操作员编号, b.操作员姓名,
              Zl_Date_Half(Greatest(Least(Nvl(b.上次计算时间, b.开始时间), Nvl(b.终止时间, Greatest(Nvl(b.上次计算时间, b.开始时间))),
                                           Greatest(Nvl(b.上次计算时间, b.开始时间))), p.执行日期, Nvl(a.启用日期, Add_Months(Sysdate, -2)))) As 开始日期,
              Zl_Date_Half(Least(Nvl(b.终止时间, Greatest(b.开始时间, Sysdate)), Nvl(p.终止日期, Sysdate + 30) + 1)) As 终止日期, b.数量
       From 自动计价项目 A,
            (Select 病人id, 主页id, 开始时间, 附加床位, 病区id, 科室id, 床号, 床位等级id, 1 As 数量, 责任护士, 经治医师, 终止时间, 操作员编号, 操作员姓名, 上次计算时间
              From 病人变动记录 A
              Where 开始原因 <> 10
              Union All
              Select 病人id, 主页id, 开始时间, 附加床位, 病区id, 科室id, 床号, i.从项id As 床位等级id, i.从项数次 As 数量, 责任护士, 经治医师, 终止时间, 操作员编号, 操作员姓名,
                     上次计算时间
              From 病人变动记录 B, 收费从属项目 I
              Where b.床位等级id = i.主项id And b.开始原因 <> 10 And i.固有从属 > 0) B, 收费价目 P
       Where a.病区id = b.病区id And Zl_Date_Half(Nvl(b.上次计算时间, b.开始时间)) <> Zl_Date_Half(Nvl(b.终止时间, Sysdate)) And p.现价 <> 0 And
             a.计算标志 = 1 And b.床位等级id = p.收费细目id And Zl_Date_Half(Nvl(b.终止时间, Sysdate)) >= Zl_Date_Half(p.执行日期) And
             Zl_Date_Half(b.开始时间) <= Zl_Date_Half(Nvl(p.终止日期, Sysdate) + 1) And
             Zl_Date_Half(Least(Nvl(b.终止时间, Sysdate), Nvl(p.终止日期, Sysdate + 30) + 1)) >=
             Zl_Date_Half(Nvl(a.启用日期, Add_Months(Sysdate, -2)))
       Union All
       Select b.病人id, b.主页id, b.科室id, b.病区id, b.床号, b.附加床位, p.收费细目id, p.收入项目id, p.现价, b.经治医师, b.责任护士, b.操作员编号, b.操作员姓名,
              Zl_Date_Half(Greatest(Least(Nvl(b.上次计算时间, b.开始时间), Nvl(b.终止时间, Greatest(Nvl(b.上次计算时间, b.开始时间))),
                                           Greatest(Nvl(b.上次计算时间, b.开始时间))), p.执行日期, Nvl(a.启用日期, Add_Months(Sysdate, -2)))) As 开始日期,
              Zl_Date_Half(Least(Nvl(b.终止时间, Greatest(b.开始时间, Sysdate)), Nvl(p.终止日期, Sysdate + 30) + 1)) As 终止日期, b.数量
       From 自动计价项目 A,
            (Select 病人id, 主页id, 开始时间, 附加床位, 病区id, 科室id, 床号, 护理等级id, 1 As 数量, 责任护士, 经治医师, 终止时间, 操作员编号, 操作员姓名, 上次计算时间
              From 病人变动记录
              Where 开始原因 <> 10
              Union All
              Select 病人id, 主页id, 开始时间, 附加床位, 病区id, 科室id, 床号, i.从项id As 护理等级id, i.从项数次 As 数量, 责任护士, 经治医师, 终止时间, 操作员编号, 操作员姓名,
                     上次计算时间
              From 病人变动记录 B, 收费从属项目 I
              Where b.护理等级id = i.主项id And b.开始原因 <> 10 And i.固有从属 > 0) B, 收费价目 P, 收费项目目录 C
       Where a.病区id = b.病区id And b.附加床位 <> 1 And
             Zl_Date_Half(Nvl(b.上次计算时间, b.开始时间)) <> Zl_Date_Half(Nvl(b.终止时间, Sysdate)) And p.现价 <> 0 And a.计算标志 = 2 And
             b.护理等级id = p.收费细目id And b.护理等级id = c.Id And Nvl(c.计算方式, 0) <> 1 And
             Zl_Date_Half(Nvl(b.终止时间, Sysdate)) >= Zl_Date_Half(p.执行日期) And
             Zl_Date_Half(b.开始时间) <= Zl_Date_Half(Nvl(p.终止日期, Sysdate) + 1) And
             Zl_Date_Half(Least(Nvl(b.终止时间, Sysdate), Nvl(p.终止日期, Sysdate + 30) + 1)) >=
             Zl_Date_Half(Nvl(a.启用日期, Add_Months(Sysdate, -2)))
       Union All
       Select b.病人id, b.主页id, b.科室id, b.病区id, b.床号, b.附加床位, p.收费细目id, p.收入项目id, p.现价, b.经治医师, b.责任护士, b.操作员编号, b.操作员姓名,
              Zl_Date_Half(Greatest(Least(Nvl(b.上次计算时间, b.开始时间), Nvl(b.终止时间, Greatest(Nvl(b.上次计算时间, b.开始时间))),
                                           Greatest(Nvl(b.上次计算时间, b.开始时间))), p.执行日期, Nvl(a.启用日期, Add_Months(Sysdate, -2)))) As 开始日期,
              Zl_Date_Half(Least(Nvl(b.终止时间, Greatest(b.开始时间, Sysdate)), Nvl(p.终止日期, Sysdate + 30) + 1)) As 终止日期, a.数量
       From (Select 病区id, 计算标志, 收费细目id, 1 As 数量, 启用日期
              From 自动计价项目
              Union All
              Select 病区id, 计算标志, 从项id, i.从项数次 As 数量, 启用日期
              From 自动计价项目 A, 收费从属项目 I
              Where a.收费细目id = i.主项id And i.固有从属 > 0) A, 病人变动记录 B, 收费价目 P
       Where a.病区id = b.病区id And b.附加床位 <> 1 And b.开始原因 <> 10 And
             Zl_Date_Half(Nvl(b.上次计算时间, b.开始时间)) <> Zl_Date_Half(Nvl(b.终止时间, Sysdate)) And p.现价 <> 0 And
             a.收费细目id = p.收费细目id And (a.计算标志 = 6 And b.床位等级id Is Not Null Or a.计算标志 = 7) And
             Zl_Date_Half(Nvl(b.终止时间, Sysdate)) >= Zl_Date_Half(p.执行日期) And
             Zl_Date_Half(b.开始时间) <= Zl_Date_Half(Nvl(p.终止日期, Sysdate) + 1) And
             Zl_Date_Half(Least(Nvl(b.终止时间, Sysdate), Nvl(p.终止日期, Sysdate + 30) + 1)) >=
             Zl_Date_Half(Nvl(a.启用日期, Add_Months(Sysdate, -2)))) P
Where i.病人id = p.病人id And a.病人id = p.病人id And a.主页id = p.主页id;

-------------------------------------------------------------------------------
--数据修正部份
-------------------------------------------------------------------------------
--104388:李南春,2017-02-22,自助挂号加收药事服务费
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明,参数值含义,关联说明,适用说明,警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1802, 0, 0, 0, 0, 0, 0, 44, '加收药事服务费', '0', '0',
         '自助挂号是否加收药事服务费。','0-不收药事服务费;1-收取药事服务费','在自助挂号的时候，判断是否在挂号费用的基础上加收药事服务费','适用于医院根据设备自身业务状况推行药事服务费',NULL
  From Dual;

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明,参数值含义,关联说明,适用说明,警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1803, 0, 0, 0, 0, 0, 0, 44, '加收药事服务费', '0', '0',
         '自助收费预约是否加收药事服务费。','0-不收药事服务费;1-收取药事服务费','在自助预约的时候，判断是否在挂号费用的基础上加收药事服务费','适用于医院根据设备自身业务状况推行药事服务费',NULL
  From Dual;

--106239:刘硕,2017-02-21,双击不能自动升级以及部分升级调整
Delete From Zlfilesupgrade Where Upper(文件名) = 'REGCOM.DLL';

Update Zlfilesupgrade Set 自动注册 = 0 Where Upper(文件名) In ('ZLZIP11.DLL', 'ZLUZIP10.DLL', 'COMDLG32.DLL');

--106109:胡俊勇,2017-02-16,接诊时自动处理完成就诊 参数修正
Delete zlParameters Where 参数名 = '缺省预约方式' And 参数号=31 And Nvl(模块,0) = 1260 And Nvl(系统,0) = &n_System;

Insert Into zlParameters 
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1260, 1, 0, 0, 0, 0, 0, 31, '接诊时自动处理完成就诊', Null, Null, '门诊医生接诊病人时自动处理上一个病人完成就诊或需回诊。',Null, Null,Null, Null
  From Dual;

--103428:李南春,2017-02-16,医疗卡增加发卡控制
Update 医疗卡类别 Set 发卡控制 = 1 Where Nvl(是否严格控制,0) = 0 And  发卡控制 is Null;

--93221:刘尔旋,2017-02-14,轧帐默认时间
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1506, 1, 0, 0, 0, 0, 0, 30, '缺省轧帐时间', Null, Null,
         '每天轧帐的默认时间,默认时间到当前时间之间没有轧帐记录的,取默认时间,否则取当前时间', 'Null-不启用,hh:mm:ss-启用,并且值为默认时间', Null, '适用于需要自定义轧账时间的场合', Null
  From Dual;

--90694:刘尔旋,2017-02-13,门诊与住院结帐票据分开控制
Update zlParameters
Set 参数名 = '住院结帐票据类型',
    影响控制说明 = '在病人结帐管理中当住院结帐完成后控制调用不同类型的报表:' || Chr(13) || '1)如果本站点设置为住院医疗收据时,在住院结帐完成后,如果需要打印结帐票据,则调用报表:zl1_BILL_1137' ||
              Chr(13) || '2)如果本站点设置为门诊医疗收据时,在住院结帐完成后,如果需要打印结帐票据,则调用报表:zl1_BILL_1137_2',
    参数值含义 = '0-表示使用住院医疗费收据,1-表示门诊医疗费收据',
    关联说明 = '1)需要结合参数"病人结帐打印"中是否打印来进行控制:' || Chr(13) || ' a)如果打印或提示选择打印,则本参数有效' || Chr(13) || ' b)如果不打印或提示选择不打印,则本参数无效.' ||
            Chr(13) || '2)需要配合"住院结帐发票格式"来控制调用报表的格式 ', 适用说明 = '根据住院结帐所用票据选择类型'
Where 参数名 = '结帐票据类型' And 模块 = 1137 And 系统 = &n_System;

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1137, 0, 1, 0, 0, 0, 0, 58, '门诊结帐票据类型', 参数值, 缺省值,
         '在病人结帐管理中当门诊结帐完成后控制调用不同类型的报表:' || Chr(13) || '1)如果本站点设置为住院医疗收据时,在门诊结帐完成后,如果需要打印结帐票据,则调用报表:zl1_BILL_1137' ||
          Chr(13) || '2)如果本站点设置为门诊医疗收据时,在门诊结帐完成后,如果需要打印结帐票据,则调用报表:zl1_BILL_1137_2', '0-表示使用住院医疗费收据,1-表示门诊医疗费收据',
         '1)需要结合参数"病人结帐打印"中是否打印来进行控制:' || Chr(13) || ' a)如果打印或提示选择打印,则本参数有效' || Chr(13) || ' b)如果不打印或提示选择不打印,则本参数无效.' ||
          Chr(13) || '2)需要配合"门诊结帐发票格式"来控制调用报表的格式 ', '根据门诊结帐所用票据选择类型', Null
  From zlParameters
  Where 系统 = &n_System And 模块 = 1137 And 参数名 = '住院结帐票据类型' And Not Exists
   (Select 1 From zlParameters Where 系统 = &n_System And 模块 = 1137 And 参数名 = '门诊结帐票据类型');

Insert Into zlUserParas
  (参数id, 用户名, 机器名, 参数值)
  Select c.Id, a.用户名, a.机器名, a.参数值
  From zlUserParas A, zlParameters B, zlParameters C
  Where b.系统 = &n_System And b.模块 = 1137 And b.参数名 = '住院结帐票据类型' And a.参数id = b.Id And c.系统 = &n_System And c.模块 = 1137 And
        c.参数名 = '门诊结帐票据类型';

Update zlParameters
Set 参数名 = '住院结帐发票格式',
    影响控制说明 = '1)在病人结帐管理中完成住院结帐后,根据病人类型决定打印哪种结帐票据' || Chr(13) ||
              '2)如果本站点设置的"住院结帐票据类型"为住院医疗收据时,在住院结帐完成后,如果需要打印结帐票据,则调用报表:zl1_BILL_1137的对应格式' || Chr(13) ||
              '3)如果本站点设置的"住院结帐票据类型"为门诊医疗收据时,在住院结帐完成后,如果需要打印结帐票据,则调用报表:zl1_BILL_1137_2的对应格式',
    参数值含义 = '格式:使用类别1,格式1|使用类别2,格式2|...' || Chr(13) || '使用类别:普通病人,医保病人或… ' || Chr(13) || '格式:0或NULL:使用本地缺省格式,>0:票据格式序号',
    关联说明 = '1)需要结合参数"病人结帐打印"中是否打印来进行控制:' || Chr(13) || 'a)如果打印或提示选择打印,则本参数有效' || Chr(13) || 'b)如果不打印或提示选择不打印,则本参数无效.' ||
            Chr(13) || '2)需要配合"住院结帐票据类型"来控制如果是住院医疗票据是调用"zl1_BILL_1137",如果是门诊医疗票据就调用报表"zl1_BILL_1137_2"',
    适用说明 = '根据住院结帐所用票据选择格式'
Where 参数名 = '结帐发票格式' And 模块 = 1137 And 系统 = &n_System;

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1137, 0, 1, 0, 0, 0, 0, 59, '门诊结帐发票格式', 参数值, 缺省值,
         '1)在病人结帐管理中完成门诊结帐后,根据病人类型决定打印哪种结帐票据' || Chr(13) ||
          '2)如果本站点设置的"门诊结帐票据类型"为住院医疗收据时,在门诊结帐完成后,如果需要打印结帐票据,则调用报表:zl1_BILL_1137的对应格式' || Chr(13) ||
          '3)如果本站点设置的"门诊结帐票据类型"为门诊医疗收据时,在门诊结帐完成后,如果需要打印结帐票据,则调用报表:zl1_BILL_1137_2的对应格式',
         '格式:使用类别1,格式1|使用类别2,格式2|...' || Chr(13) || '使用类别:普通病人,医保病人或… ' || Chr(13) || '格式:0或NULL:使用本地缺省格式,>0:票据格式序号',
         '1)需要结合参数"病人结帐打印"中是否打印来进行控制:' || Chr(13) || 'a)如果打印或提示选择打印,则本参数有效' || Chr(13) || 'b)如果不打印或提示选择不打印,则本参数无效.' ||
          Chr(13) || '2)需要配合"门诊结帐票据类型"来控制如果是住院医疗票据是调用"zl1_BILL_1137",如果是门诊医疗票据就调用报表"zl1_BILL_1137_2"', '根据门诊结帐所用票据选择格式',
         Null
  From zlParameters
  Where 系统 = &n_System And 模块 = 1137 And 参数名 = '住院结帐发票格式' And Not Exists
   (Select 1 From zlParameters Where 系统 = &n_System And 模块 = 1137 And 参数名 = '门诊结帐发票格式');

Insert Into zlUserParas
  (参数id, 用户名, 机器名, 参数值)
  Select c.Id, a.用户名, a.机器名, a.参数值
  From zlUserParas A, zlParameters B, zlParameters C
  Where b.系统 = &n_System And b.模块 = 1137 And b.参数名 = '住院结帐发票格式' And a.参数id = b.Id And c.系统 = &n_System And c.模块 = 1137 And
        c.参数名 = '门诊结帐发票格式';


--104261:胡俊勇,2017-01-22,诊间支付允许使用预交款
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1252, 1, 0, 0, 0, 0, 0, 58, '诊间支付允许使用预交款', '1', '1',
         '在进行诊间支付时是否允许使用预交款。', '0－不可以，1－可以。',Null,'支付宝诊间支付当遇到患者有预交款，科室没有配刷卡设备时，可以启用该参数就可直接使用预交款。',Null
  From Dual;

--103219:胡俊勇,2017-01-19,科室药房对照按本机参数设置
Insert Into zlParameters
(ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
Select Zlparameters_Id.Nextval, &n_System,-Null,-Null, -Null,-Null,-Null,-Null,-Null,274, '科室药房对照按本机参数设置', '0', '0',
'本参数会影响（科室药房对照）的参数性质，0-为部门性质，参数值在临床公共模中设置，1-为本机性质，参数值在医嘱模块(门诊/住院下达模块)内部设置。',
'0-科室药房对照按部门参数性质设值，1-科室药房对照按本机参数性质设值。', 
'本参数会影响（科室药房对照）的参数性质，即以下这批参数：'||chr(13)||
'模块1252－门诊缺省西药房,门诊缺省成药房,门诊缺省中药房,门诊缺省发料部门,门诊可用西药房,门诊可用成药房,门诊可用中药房;'||chr(13)||
'模块1253－住院缺省西药房,住院缺省成药房,住院缺省中药房,住院缺省发料部门,住院可用西药房,住院可用成药房,住院可用中药房.'||chr(13)||
'本参数对（科室药房对照）参数影响，要重新登陆导航台后才生效。',
'科室药房对照参数性质应按实际业务应用来设置，不应该轻修改。',
'如果修改本参数会引起临床科室下药品和卫材医嘱的缺省发药科室，同时关联的科室药房对照参数的设置位也会发生变化。'
From Dual;

--89938:胡俊勇,2017-01-11,临嘱单转科换页
Insert Into Zlparameters
  (Id, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System,1254, -null, -null,1,1, 0, 0, 76, '临嘱单转科换页', '0', '0',
         '打印临时医嘱单时，如果启用了此参数，下达转科医嘱后临时医嘱单会换页。', Null, Null, Null,null
  From Dual;

--104247:胡俊勇,2017-01-03,停嘱原因修改
Insert Into zlBaseCode(系统,表名,固定,说明,分类) Values( &n_System,'停嘱原因',0,'用于描述停止长期医嘱的原因。','医疗工作' );

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, -Null, -Null, -Null, -Null, -Null,-Null, -Null, 271, '停嘱时录入原因', '0', '0',
  '启用参数后控制：住院场合停止长期医嘱时必须填写一个停止医嘱的原因，对于自动停止的默认为（自动停止：XXXX）。','0-不启用，1-启用。', Null, Null, Null
  From Dual;

Insert Into 停嘱原因(编码,名称,简码,缺省标志)  
select * from (Select '01','转科','ZK',1 From Dual Union All
Select '02','术后','SH',null From Dual Union All
Select '03','出院','CY',null From Dual Union All
Select '04','转院','ZY',null From Dual Union All
Select '05','死亡','SW',null From Dual)
where not exists (select 1 from 停嘱原因 having count(1)>=1);

--104278:涂建华,2016-12-21,更新参数病理费用执行模式
Insert Into zlParameters(ID,系统,模块,私有,本机,授权,固定,部门,性质,参数号,参数名,参数值,缺省值,影响控制说明,参数值含义,关联说明,适用说明,警告说明)
Select zlParameters_ID.Nextval,&n_System,1294,A.* From (
  Select 私有,本机,授权,固定,部门,性质,参数号,参数名,参数值,缺省值,影响控制说明,参数值含义,关联说明,适用说明,警告说明 From zlParameters Where 1 = 0 Union All
  Select 0,0,0,0,0,0,109,'病理费用执行模式','0','0',NULL,'控制费用的执行时机，取值为报到时执行，检查时执行，报告时执行。',NULL,'根据医院实际业务确定费用的执行时机，默认为报到时执行。',NULL From Dual Union All
  Select 私有,本机,授权,固定,部门,性质,参数号,参数名,参数值,缺省值,影响控制说明,参数值含义,关联说明,适用说明,警告说明 From zlParameters Where 1 = 0) A;

--102941:冉俊明,2016-11-25,删除号源的同时停用当前时间以后的所有出诊安排。
--修正删除了号源但没有停诊当前时间以后的出诊安排
Declare
  d_开始时间 临床出诊记录.开始时间%Type;
Begin
  For c_记录 In (Select Distinct a.Id, a.开始时间, a.终止时间
               From 临床出诊记录 A, 临床出诊号源 B
               Where a.号源id = b.Id And Nvl(b.是否删除, 0) = 1 And a.出诊日期 >= Trunc(Sysdate) - 1 And a.终止时间 > Sysdate And
                     a.上班时段 Is Not Null And (a.开始时间 <> Nvl(a.停诊开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')) Or
                     a.终止时间 <> Nvl(a.停诊终止时间, To_Date('1900-01-01', 'yyyy-mm-dd')))) Loop
  
    If c_记录.开始时间 < Sysdate Then
      d_开始时间 := Sysdate;
    Else
      d_开始时间 := c_记录.开始时间;
    End If;
    Zl_临床出诊记录_Stopvisit(c_记录.Id, d_开始时间, c_记录.终止时间, '删除号源', Zl_Username, Sysdate, 0, 1);
  End Loop;
End;
/

--103232:冉俊明,2016-12-15,临床出诊安排，按序号时段开放停诊安排。
Begin
  For c_记录 In (Select ID, 停诊开始时间, 停诊终止时间
               From 临床出诊记录
               Where 出诊日期 >= Trunc(Sysdate) And 停诊终止时间 > Sysdate And Nvl(是否序号控制, 0) = 1 And Nvl(是否分时段, 0) = 1) Loop
  
    Update 临床出诊序号控制
    Set 是否停诊 = 1
    Where 记录id = c_记录.Id And 开始时间 Between c_记录.停诊开始时间 And c_记录.停诊终止时间;
  End Loop;
End;
/

--101951:梁经伙,2016-12-14,增加参数 ICD附码检查 
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1261, 0, 0, 0, 0, 0, 0, 51, 'ICD附码检查', Null, Null,
         '控制住院医生站中首页的主要出院诊断编码为C、D类时，主要出院诊断是否需要填写ICD附码。', '主要出院诊断编码为C、D类时，主要出院诊断的ICD附码：1-必须填写，2-提示是否填写，0-不检查。',Null,Null ,Null
  From Dual;

--103523:廖思奇,2017-02-20,调整参数号重复问题
--103523:廖思奇,2016-12-12,增加字体参数
Update zlParameters Set 参数号 = 52 Where 参数名 = '医技费用执行模式' And 系统 = &n_System And 模块 = 1290;

Delete From zlParameters Where 参数名 = '身份识别读卡模式' And 系统 = &n_System And 模块 = 1290 And 参数号 = 46;
Delete From zlParameters Where 参数名 = '身份识别键盘控制' And 系统 = &n_System And 模块 = 1290 And 参数号 = 47;

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1290, 1, 1, 0, 0, 0, 0, 53, '报告显示字号', Null, '0',
         '保存报告显示的字号大小', '保存报告显示的字号大小' ,
         Null, '对于不想使用影像工作站的菜单中统一的大中小字体功能又想改变报告字体大小的用户，会用到这个参数保存报告显示的字号', Null
  From Dual;
  
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1291, 1, 1, 0, 0, 0, 0, 55, '报告显示字号', Null, '0',
         '保存报告显示的字号大小', '保存报告显示的字号大小',
         Null, '对于不想使用影像工作站的菜单中统一的大中小字体功能又想改变报告字体大小的用户，会用到这个参数保存报告显示的字号', Null
  From Dual;

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1294, 1, 1, 0, 0, 0, 0, 111, '报告显示字号', Null, '0',
         '保存报告显示的字号大小', '保存报告显示的字号大小',
         Null, '对于不想使用影像工作站的菜单中统一的大中小字体功能又想改变报告字体大小的用户，会用到这个参数保存报告显示的字号', Null
  From Dual;

--102791:刘尔旋,2016-12-08,预约排队按时点显示
Insert Into zlParameters(ID,系统,模块,私有,本机,授权,固定,部门,性质,参数号,参数名,参数值,缺省值,影响控制说明,参数值含义,关联说明,适用说明,警告说明)
Select zlParameters_ID.Nextval,&n_System,-Null,-Null,-Null,-Null,-Null,A.* From (
Select 部门,性质,参数号,参数名,参数值,缺省值,影响控制说明,参数值含义,关联说明,适用说明,警告说明 From zlParameters Where 1 = 0 Union All 
    Select 0,0,270,'预约排队按时点显示',Null,'0','控制预约挂号进入排队叫号列表后,分时段的号码是否到了发生时间才能显示','0-不时点显示,1-按时点显示',Null,'适用于医院根据需要控制排队叫号队列显示的情况',Null From Dual Union All 
Select 部门,性质,参数号,参数名,参数值,缺省值,影响控制说明,参数值含义,关联说明,适用说明,警告说明 From zlParameters Where 1 = 0) A;

--103334:余智勇,2016-12-02,呼叫时通知设备准备发药
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1341, 0, 1, 0, 0, 0, 0, 61, '呼叫时通知开始发药', Null, '0',
         '当启用药品自动化设备部件后，操作“呼叫”功能的同时通知设备开始发药！', '0-呼叫不通知设备；1-呼叫通知设备',
         Null, '只有注册相关部件后，参数设置窗体才可见。', Null
  From Dual;

--102973:冉俊明,2016-11-24,对医保病人进行门诊收费，在进入结算窗口时光标是否缺省定位到“医保结算”按钮上。
Update zlParameters Set 参数名 = '医保结算光标缺省定位' Where 系统 = &n_System And 模块 = 1121 And 参数名 = '医保结算焦点定位';

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1121, 1, 0, 0, 0, 0, 0, 112, '医保结算光标缺省定位', '0', '0',
         '对医保病人进行门诊收费，在进入结算窗口时光标是否缺省定位到"医保结算"按钮上。', '0-不缺省定位到"医保结算"按钮上，1-缺省定位到"医保结算"按钮上。',
         Null, '个性化设置，适用于不同医院不同收款员的操作习惯。', Null
  From Dual;

--95629:冉俊明,2016-11-24,退款选择现金结算方式时缺省退款金额。
Update zlParameters Set 参数号 = 111, 参数名 = '现金退款缺省方式' Where 系统 = &n_System And 模块 = 1121 And 参数名 = '退费现金结算缺省金额';

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1121, 1, 0, 0, 0, 0, 0, 111, '现金退款缺省方式', '0', '0', '如果勾选了该参数则在门诊退费选择现金结算方式时会缺省退款金额',
         '在门诊退费选择现金结算方式时的退款金额缺省方式：1-缺省退款金额，0-不缺省', Null, '适用于用户需要在门诊退费时选择现金结算方式也缺省退款金额的业务', Null
  From Dual;

--102701:刘尔旋,2016-11-22,结帐退款现金缺省金额
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1137, 1, 0, 0, 0, 0, 0, 57, '退款现金结算缺省金额', Null, Null,
         '控制结帐退款时，退款现金结算方式时，是否默认缺省的退款金额。', '0-不缺省金额;1-缺省金额',Null,'结帐退款时现金的快捷处理' ,Null
  From Dual;

--102750:刘尔旋,2016-11-22,缺省预约方式
Update zlParameters Set 私有 = 1 Where 系统 = &n_System And 模块 = 9000 And 参数名 = '缺省预约方式';

--102781:刘尔旋,2016-11-21,挂号默认界面设置
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1111, 0, 0, 0, 0, 0, 0, 70, '计划排班挂号默认界面', Null, Null,
         '计划排班模式下有效，控制挂号时，挂号界面的默认大小。精简界面情况下部分控件会被隐藏。', '0-默认1024X768界面;1-默认800X600界面',Null,'适用于需要缩小挂号界面布局的情况' ,Null
  From Dual;

--102550:刘尔旋,2016-11-14,包含科室安排挂号和预约分开控制
Update zlParameters
Set 缺省值 = '0|0', 参数值 = Nvl(参数值, 0) || '|' || Nvl(参数值, 0), 适用说明 = '适用于控制医生站挂号范围的情况',
    参数值含义 = '挂号控制方式|预约控制方式.0-不包含没有医生的所属科室的安排;1-包含没有医生的所属科室的安排'
Where 系统 = &n_System And 模块 = 9000 And 参数名 = '包含科室安排' And Instr(Nvl(参数值, '-'), '|') = 0;

--102506:胡俊勇,2016-11-11,门诊医嘱下达参数添加
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1252, 1, 0, 0, 0, 0, 0, 57, '门诊病历缺省页签', Null, Null,
         '控制门诊医嘱下达界面显示的病历页签，参数格式：病历文件列表 ID串逗号分割。', '当参数为空时页签展示方式和原来一样显示快捷病历，设置参数值后以参数设置显示',Null,Null ,Null
  From Dual;

--102600:梁经伙,2016-11-15,关联授权脚本，把9001和电子病案查阅1259模块关联
Insert Into Zlmodulerelas
  (系统, 模块, 功能, 相关系统, 相关模块, 相关类型, 相关功能, 缺省值)
  Select &n_System, 9001, Null, &n_System, 1259, 1, '基本', 1
  From Dual;

--102854:李业庆,2016-11-21,申领填单按批次出库参数，默认不按批次出库
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1343, 0, 0, 0, 0, 0, 0, 7, '药品按批次出库', '0', '0', '药品在进行申领时是否按批次进行填写出库单',
         '在进行申领时药品申领方式，0-不按批次出库,1-按批次出库', Null, Null, Null
  From Dual;

--102854:李业庆,2017-02-10,移库填单按批次出库参数，默认不按批次出库
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1304, 0, 0, 0, 0, 0, 0, 13, '药品按批次出库', '1', '1', '药品在进行移库时是否按批次进行填写出库单',
         '在进行移库时填写移库单方式，0-不按批次出库,1-按批次出库', Null, Null, Null
  From Dual;

--102854:李业庆,2017-02-10,领用填单按批次出库参数，默认不按批次出库
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1305, 0, 0, 0, 0, 0, 0, 8, '药品按批次出库', '1', '1', '药品在进行领用时是否按批次进行填写出库单',
         '在进行领用时填写领用单方式，0-不按批次出库,1-按批次出库', Null, Null, Null
  From Dual;

--103653:李业庆,2016-12-09,删除药品批号对照表批次小于或等于0的记录
Delete From 药品批号对照 Where 批次 <= 0;

--104085:余伟节,2016-12-20,修正病人信息身份证号等于未办、未带、遗失待办的数据
Begin
  For r_Row In (Select a.病人id, a.身份证号 From 病人信息 A, 身份证未录原因 B Where a.身份证号 = b.名称) Loop
    Update 病人信息从表 Set 信息值 = r_Row.身份证号 Where 病人id = r_Row.病人id And 信息名 = '身份证号状态';
    If Sql%RowCount = 0 Then
      Insert Into 病人信息从表 (病人id, 信息名, 信息值) Values (r_Row.病人id, '身份证号状态', r_Row.身份证号);
    End If;
    Update 病人信息 Set 身份证号 = Null Where 病人id = r_Row.病人id;
  End Loop;
End;
/

--100545:李业庆,2016-12-22,药品移库增加按批次出库时允许修改批号产地参数
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1304, 0, 0, 0, 0, 0, 0, 12, '分批出库时允许修改产地批号', '0', '0', '药品在填写移库单按批次出库时是否允许修改产地批号信息',
         '药品在填写移库单按批次出库时是否允许修改产地批号信息，0-不允许修改,1-允许修改', Null, Null, Null
  From Dual;


--104480:李业庆,2017-01-11,申领填单当前库房药品数据显示按出库批次或所有批次总数方式计算和显示
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1343, 1, 0, 0, 0, 0, 0, 10, '当前库房药品数量是否按批次显示', '0', '0', '当按批次申领时，药品在进行申领时当前库房药品的数量显示方式',
         '当按批次申领时，药品在进行申领时当前库房药品的数量显示方式，0-按出库批次显示,1-按当前库房该药品总数量显示', Null, Null, Null
  From Dual;

--104963:李业庆,2017-1-24,诊疗项目目录增加应用范围参数
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1054, 0, 1, 1, 0, 0, 0, 7, '项目应用范围', '000', '000', '用于设置诊疗项目时的批量应用方式，为了防止误操作或不用的操作，可以通过该参数设置希望的应用方式，没有勾选的参数项目就不能选择该种应用方式',
         '1.每一位表示一种应用方式范围类型，其中0-表示用户不能选择，1-表示用户能够选择', Null, '为防止误操作，默认是所有应用项都不勾选，并根据实际使用的角色授权使用', Null
  From Dual;

--105308:李业庆,2016-10-20,药品零差价管理新增参数
Insert Into zlParameters(ID,系统,模块,私有,本机,授权,固定,部门,性质,参数号,参数名,参数值,缺省值,影响控制说明,参数值含义,关联说明,适用说明,警告说明)
Select zlParameters_ID.Nextval,&n_System,-Null,-Null,-Null,-Null,-Null,A.* From (
Select 部门,性质,参数号,参数名,参数值,缺省值,影响控制说明,参数值含义,关联说明,适用说明,警告说明 From zlParameters Where 1 = 0 Union All 
    Select 0,0,275,'药品零差价管理模式',Null,'0','是否启用系统级别的药品零差价管理模式。0-不启用，1-只在销售环节启用，确保销售出库的药品零差价管理和数据准确（售价和成本价一致，差价为0）2-全流通业务都采取零差价管理，确保在整个流通环节（包括入库，出库，盘点等）的数据数据准确性（售价和成本价一致，差价为0）','0-不启用零差价管理模式，1-启用销售环节零差价模式，2-启用全流通环节零差价模式',Null,Null,Null From Dual Union All 
Select 部门,性质,参数号,参数名,参数值,缺省值,影响控制说明,参数值含义,关联说明,适用说明,警告说明 From zlParameters Where 1 = 0) A;

-------------------------------------------------------------------------------
--权限修正部份
-------------------------------------------------------------------------------
--106636:廖思奇,2017-03-01,删除9004与9003的模块关联关系.增加1290,1291,1294与9003的模块关联关系.
Delete From Zlmodulerelas Where 系统 = &n_System And 模块 = 9004 And 相关模块 = 9003 And 相关功能 = '基本';

Insert Into zlModuleRelas(系统,模块,功能,相关系统,相关模块,相关类型,相关功能,缺省值)
Select &n_System,1290,A.* From (
Select 功能,相关系统,相关模块,相关类型,相关功能,缺省值 From zlModuleRelas Where 1 = 0 Union All
Select NULL,&n_System,9003,1,'基本',1 From Dual Union All
Select 功能,相关系统,相关模块,相关类型,相关功能,缺省值 From ZLMODULERELAS Where 1 = 0) A;

Insert Into zlModuleRelas(系统,模块,功能,相关系统,相关模块,相关类型,相关功能,缺省值)
Select &n_System,1291,A.* From (
Select 功能,相关系统,相关模块,相关类型,相关功能,缺省值 From zlModuleRelas Where 1 = 0 Union All
Select NULL,&n_System,9003,1,'基本',1 From Dual Union All
Select 功能,相关系统,相关模块,相关类型,相关功能,缺省值 From ZLMODULERELAS Where 1 = 0) A;

Insert Into zlModuleRelas(系统,模块,功能,相关系统,相关模块,相关类型,相关功能,缺省值)
Select &n_System,1294,A.* From (
Select 功能,相关系统,相关模块,相关类型,相关功能,缺省值 From zlModuleRelas Where 1 = 0 Union All
Select NULL,&n_System,9003,1,'基本',1 From Dual Union All
Select 功能,相关系统,相关模块,相关类型,相关功能,缺省值 From ZLMODULERELAS Where 1 = 0) A;

--100891:刘尔旋,2017-02-17,结帐数据升级处理
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
  Select &n_System,1137,'基本',User,A.* From (
  Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
  Select 'Zl_病人结帐记录_Upgrade','EXECUTE' From Dual Union All
  Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--104658:刘尔旋,2017-02-07,挂号发票支持多张打印
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
  Select &n_System,1111,'基本',User,A.* From (
  Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
  Select 'Zl_病人挂号票据_Insert','EXECUTE' From Dual Union All
  Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--100837:刘尔旋,2017-2-6,挂号附加费处理
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
  Select &n_System,9000,'基本',User,A.* From (
  Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
  Select 'Zl_Fun_Regcustomname','EXECUTE' From Dual Union All
  Select 'Zl_Fun_Customregexpenses','EXECUTE' From Dual Union All
  Select 对象,权限 From zlProgPrivs Where 1 = 0) A;
  
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
  Select &n_System,1111,'基本',User,A.* From (
  Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
  Select 'Zl_Fun_Regcustomname','EXECUTE' From Dual Union All
  Select 'Zl_Fun_Customregexpenses','EXECUTE' From Dual Union All
  Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
  Select &n_System,1539,'基本',User,A.* From (
  Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
  Select 'Zl_Fun_Regcustomname','EXECUTE' From Dual Union All
  Select 'Zl_Fun_Customregexpenses','EXECUTE' From Dual Union All
  Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
  Select &n_System,1802,'基本',User,A.* From (
  Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
  Select 'Zl_Fun_Regcustomname','EXECUTE' From Dual Union All
  Select 'Zl_Fun_Customregexpenses','EXECUTE' From Dual Union All
  Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
  Select &n_System,1803,'基本',User,A.* From (
  Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
  Select 'Zl_Fun_Regcustomname','EXECUTE' From Dual Union All
  Select 'Zl_Fun_Customregexpenses','EXECUTE' From Dual Union All
  Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--103742:廖思奇,2017-02-06,新设计函数增加使用权限
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1160, '基本', User, 'Zl_排队语音呼叫_多音字处理', 'EXECUTE'
  From Dual;

--104617:冉俊明,2017-01-23,允许调整已发布且没有预约挂号的临床出诊安排。
Update zlProgFuncs
Set 说明 = '有该权限时，允许对已经发布的固定安排制定临时安排(计划)。'
Where 系统 = &n_System And 序号 = 1114 And 功能 = '临时出诊安排';

Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select &n_System, 1114, '调整安排', 23, '对已发布的临床出诊安排是否允许调整安排。有该权限，允许调整已发布的安排。', 1
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1114, '调整安排', User, 'Zl_临床出诊安排_Delete', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1114, '调整安排', User, 'Zl_临床出诊安排_Insert', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1114, '调整安排', User, 'Zl_临床出诊挂号控制记录_Insert', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1114, '调整安排', User, 'Zl_临床出诊记录_Insert', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1114, '调整安排', User, 'Zl_临床出诊上班时段_Delete', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1114, '调整安排', User, 'Zl1_Auto_Buildingregisterplan', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1114, '审核临时固定安排', User, 'Zl1_Auto_Buildingregisterplan', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1114, '取消临时固定安排审核', User, 'Zl1_Auto_Buildingregisterplan', 'EXECUTE'
  From Dual;

--103219:胡俊勇,2017-01-19,科室药房对照按本机参数设置
Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select &n_System, 1252, '医嘱选项设置', 29, '对医嘱相关的参数选项进行设置的权限。', 1
  From Dual;

--104735:廖思奇,2017-01-06,同步修改权限
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1294, '参数设置', User, 'Zl_病理号码规则_Insert', 'EXECUTE'
  From Dual;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1294, '参数设置', User, 'Zl_病理号码规则_Delete', 'EXECUTE'
  From Dual;

Delete From zlProgPrivs Where 系统 = &n_System And 序号 = 1294 And 功能 = '参数设置' And 对象 = Upper('Zl_病理号码_规则');

Delete From zlProgPrivs Where 系统 = &n_System And 序号 = 1294 And 功能 = '标本核收' And 对象 = Upper('Zl_病理号码_规则');

--104247:胡俊勇,2017-01-03,停嘱原因修改
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限) Values(&n_System,1253,'基本',User,'停嘱原因','SELECT');

--104462:蔡青松,2016-12-26,封装与质量控制有关的部分功能
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,1212,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All 
    Select '批量核对',-null,'是否允许使用批量核对功能,有该权限时允许使用,无该权限时不能使用',0 From Dual Union All
Select 功能,排列,说明,缺省值 From ZLPROGFUNCS Where 1 = 0) A;

--103221:刘尔旋,2016-12-26,开放停诊号码
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
  Select &n_System,9000,'挂号',User,A.* From (
  Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
  Select 'zl_临床出诊序号控制_开放挂号','EXECUTE' From Dual Union All
  Select 对象,权限 From zlProgPrivs Where 1 = 0) A;
  
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
  Select &n_System,9000,'预约',User,A.* From (
  Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
  Select 'zl_临床出诊序号控制_开放挂号','EXECUTE' From Dual Union All
  Select 对象,权限 From zlProgPrivs Where 1 = 0) A;
  
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
  Select &n_System,9000,'预约登记',User,A.* From (
  Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
  Select 'zl_临床出诊序号控制_开放挂号','EXECUTE' From Dual Union All
  Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--104221:余伟节,2016-12-22,身份证合法性检查及获取身份证中出生日期、性别、年龄
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,9003,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select 'Zl_Fun_Checkidcard','EXECUTE' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--104181:张险华,2016-12-20,1070增加人员性质说明
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1070,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
Select '人员性质说明','SELECT' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--100933:黄捷,2016-12-20,1287模块无法授权
delete from zlprogprivs where 序号=1287 and upper(对象)=upper('ZlComponent') ;

--101536:黄捷,2016-12-20,删除其他系统的Lob_Read对象
delete from zlProgPrivs  where 序号=1287 and upper(对象)=upper('Zl21_Lob_Read');
delete from zlProgPrivs  where 序号=1287 and upper(对象)=upper('Zl24_Lob_Read');
delete from zlProgPrivs  where 序号=1287 and upper(对象)=upper('Zl26_Lob_Read');

--103923:黄捷,2016-12-16,RIS接口对象授权

--11 字典管理工具 基本
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select null,11,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
    Select 'RIS接口日志记录','SELECT' From Dual Union All 
    Select 'ZL_RIS接口日志记录_Insert','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--1001 部门管理（增删改）
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1001,'增删改',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
    Select 'RIS接口日志记录','SELECT' From Dual Union All 
    Select 'ZL_RIS接口日志记录_Insert','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--1002 人员管理 增删改
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1002,'增删改',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
    Select 'RIS接口日志记录','SELECT' From Dual Union All 
    Select 'ZL_RIS接口日志记录_Insert','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--1049 检查部位设置 增删改
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1049,'增删改',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
    Select 'RIS接口日志记录','SELECT' From Dual Union All 
    Select 'ZL_RIS接口日志记录_Insert','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--1054 诊疗项目管理 基本
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1054,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
    Select 'RIS接口日志记录','SELECT' From Dual Union All 
    Select 'ZL_RIS接口日志记录_Insert','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

-- 1056 检查项目关联 增删改
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1056,'增删改',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
    Select 'RIS接口日志记录','SELECT' From Dual Union All 
    Select 'ZL_RIS接口日志记录_Insert','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

-- 1252 门诊医嘱下达 基本
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1252,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select 'RIS接口日志记录','SELECT' From Dual Union All 
    Select 'ZL_RIS接口日志记录_Insert','EXECUTE' From Dual Union All 
    Select 'RIS医嘱失败记录','SELECT' From Dual Union All
    Select 'b_zlXWInterface','EXECUTE' From Dual Union All
    Select 'RIS启用控制','SELECT' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--1253 住院医嘱下达 基本
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1253,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select 'RIS接口日志记录','SELECT' From Dual Union All 
    Select 'ZL_RIS接口日志记录_Insert','EXECUTE' From Dual Union All 
    Select 'RIS医嘱失败记录','SELECT' From Dual Union All
    Select 'b_zlXWInterface','EXECUTE' From Dual Union All
    Select 'RIS启用控制','SELECT' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

-- 1254  住院医嘱发送 基本
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1254,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select 'RIS接口日志记录','SELECT' From Dual Union All 
    Select 'ZL_RIS接口日志记录_Insert','EXECUTE' From Dual Union All 
    Select 'RIS医嘱失败记录','SELECT' From Dual Union All
    Select 'b_zlXWInterface','EXECUTE' From Dual Union All
    Select 'RIS启用控制','SELECT' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--1566 电子病案打印 基本
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1566,'基本',user,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select 'RIS接口日志记录','SELECT' From Dual Union All 
    Select 'ZL_RIS接口日志记录_Insert','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--103862:胡俊勇,2016-12-15,门诊医生站权限添加
Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select &n_System, 1260, '操作其他医生的病人', 20, '有权限时，在门诊医生工作站当前医生可以操作由其它医生接诊的急诊病人。', 0
  From Dual;

--102600:梁经伙,2016-12-15,为1259模块增加 病案项目，病案重症监护情况 两张表的查询权限
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1259,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select '病案项目','SELECT' From Dual Union All 
    Select '病案重症监护情况','SELECT' From Dual Union All 
	Select '病案化疗记录','SELECT' From Dual Union All 
    Select '病案放疗记录','SELECT' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--103936:余智勇,2016-12-15,补充数据库对象的权限脚本
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1351,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select '病人诊断医嘱','SELECT' From Dual Union All 
    Select '医疗卡类别','SELECT' From Dual Union All 
    Select '结算方式','SELECT' From Dual Union All 
    Select '卡消费接口目录','SELECT' From Dual Union All 
    Select '病人医疗卡信息','SELECT' From Dual Union All 
    Select '医疗卡挂失方式','SELECT' From Dual Union All 
    Select '床位状况记录','SELECT' From Dual Union All 
    Select '医疗付款方式','SELECT' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1352,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select '病人诊断医嘱','SELECT' From Dual Union All 
    Select '医疗卡类别','SELECT' From Dual Union All 
    Select '结算方式','SELECT' From Dual Union All 
    Select '卡消费接口目录','SELECT' From Dual Union All 
    Select '病人医疗卡信息','SELECT' From Dual Union All 
    Select '医疗卡挂失方式','SELECT' From Dual Union All 
    Select '床位状况记录','SELECT' From Dual Union All 
    Select '医疗付款方式','SELECT' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1354,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select '疾病编码科室','SELECT' From Dual Union All 
    Select '疾病编码分类','SELECT' From Dual Union All 
    Select '疾病编码类别','SELECT' From Dual Union All 
    Select '疾病诊断分类','SELECT' From Dual Union All 
    Select '疾病诊断属类','SELECT' From Dual Union All 
    Select '疾病诊断科室','SELECT' From Dual Union All 
    Select '疾病诊断对照','SELECT' From Dual Union All 
    Select 'ZL_疾病诊断科室_INSERT','EXECUTE' From Dual Union All 
    Select 'ZL_疾病诊断科室_DELETE','EXECUTE' From Dual Union All 
    Select 'ZL_疾病编码科室_INSERT','EXECUTE' From Dual Union All 
    Select 'ZL_疾病编码科室_DELETE','EXECUTE' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--103232:冉俊明,2016-12-15,临床出诊安排，按序号时段开放停诊安排。
Insert Into zlProgPrivs(系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1114, '停诊', User, 'Zl_临床出诊序号控制_开放挂号', 'EXECUTE'
  From Dual;

--103796:张险华,2016-12-13,病历增加权限
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,2220,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
Select '批量质控',5,'控制批量质控功能',0 From Dual Union All
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,2221,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
Select '批量质控',4,'控制批量质控功能',0 From Dual Union All
Select '全部提交',5,'控制全部提交功能',1 From Dual Union All
Select '全部撤销',6,'控制全部撤销功能',1 From Dual Union All
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,2222,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
Select '批量质控',3,'控制批量质控功能',0 From Dual Union All
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;


--103157:黄捷,2016-12-02,RIS分科室启用控制
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1011,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select '诊疗检查类型','SELECT' From Dual Union All 
    Select 'ris启用控制','SELECT' From Dual Union All 
    Select 'b_Zlxwinterface','EXECUTE' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1287,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select 'ris启用控制','SELECT' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--102769:胡俊勇,2016-11-30,门诊医生站权限添加
Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select &n_System, 1260, '修改医疗付款方式', 18, '没有该权限，在门诊医生工作站医疗付款方式不能修改。', 0
  From Dual;

Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select &n_System, 1260, '修改费别', 19, '没有该权限，在门诊医生工作站费别不能修改。', 0
  From Dual;

--102975:冉俊明,2016-11-25,成套方案的使用调整。
Update zlProgFuncs
Set 说明 = '是否允许将当前的收费项目保存为收费成套项目,有此权限,允许将当前的收费项目保存为存套项目.'
Where 系统 = &n_System And 序号 = 1150 And 功能 = '增加成套项目';

Update zlProgFuncs
Set 说明 = '是否允许显示和使用操作员所属科室设置的成套收费项目,有此权限,允许显示和使用操作员所属科室制定的成套项目.'
Where 系统 = &n_System And 序号 In (1120, 1121, 1122, 1150, 1257) And 功能 = '本科成套方案';

Update zlProgFuncs
Set 说明 = '是否允许显示和使用本医院设置的成套收费项目,有此权限,允许显示和和使用本院制定的成套项目.'
Where 系统 = &n_System And 序号 In (1120, 1121, 1122, 1150, 1257) And 功能 = '全院成套方案';

--102274:梁经伙,2016-11-23,将病历种类为5的疾病报告全部显示在医生站的“疾病报告”页签下面，在1249模块下面添加权限
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,1249,A.* From (
    Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
    Select '病历书写',1,'增删修改病人疾病报告病历。有该权归时，允许对病人疾病报告病历进行增加、删除、修改。',1 From Dual Union All
    Select '他人病历',2,'允许可书写疾病报告病历的人员删改他人书写的疾病报告病历。有该权限时，允许对他人书写的疾病报告病历进行删除、修改。',1 From Dual Union All
    Select '病历审阅',3,'上级医师对已完成的疾病报告病历的审核修改处理。有该权限时，允许对下级医师已完成的疾病报告病历进行审核、修改。',1 From Dual Union All
    Select '病历归档',4,'将指定病人疾病报告病历记录进行归档保存。有该权限时，允许将指定病人疾病报告病历进行归档。',1 From Dual Union All
    Select '强制删除',5,'为进行维护性处理而强制删除指定的疾病报告病历。有该权限时，允许强制删除指定的疾病报告病历。',1 From Dual Union All
    Select '病历打印',6,'允许打印指定病人的疾病报告病历。有该权限时，允许对病人的疾病报告病历进行打印。',1 From Dual Union All
    Select '质量监测',7,'对指定病人疾病报告病历记录的时限要求和内容质量检查监测。有该权限时，允许对指定病人疾病报告病历记录的时限要求和内容质量进行检查和监测。',1 From Dual Union All
    Select '取消打印',8,'取消打印标记，以允许疾病报告病历继续操作。',1 From Dual Union All
    Select '未签名打印',9,'对未签名的疾病报告病历进行打印。',1 From Dual Union All
    Select '归档病历输出',10,'可以打印导出已经归档病历的病历。',1 From Dual Union All
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1249,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select '保险帐户','SELECT' From Dual Union All 
    Select '病案主页','SELECT' From Dual Union All 
    Select '病人信息','SELECT' From Dual Union All 
    Select '部门人员','SELECT' From Dual Union All
    Select '消费卡目录','SELECT' From Dual Union All 
    Select '医疗卡类别','SELECT' From Dual Union All 
    Select '病历标记图形','SELECT' From Dual Union All 
    Select '病历常用样式','SELECT' From Dual Union All 
    Select '病历词句分类','SELECT' From Dual Union All 
    Select '病历词句示范','SELECT' From Dual Union All 
    Select '病历词句组成','SELECT' From Dual Union All 
    Select '病历单据应用','SELECT' From Dual Union All 
    Select '病历范文目录','SELECT' From Dual Union All 
    Select '病历范文内容','SELECT' From Dual Union All 
    Select '病历时限要求','SELECT' From Dual Union All 
    Select '病历提纲词句','SELECT' From Dual Union All 
    Select '病历文件结构','SELECT' From Dual Union All 
    Select '病历文件列表','SELECT' From Dual Union All 
    Select '病历页面格式','SELECT' From Dual Union All 
    Select '病历应用科室','SELECT' From Dual Union All 
    Select '收费项目目录','SELECT' From Dual Union All 
    Select '部门性质说明','SELECT' From Dual Union All 
    Select '床位状况记录','SELECT' From Dual Union All 
    Select '疾病报告前提','SELECT' From Dual Union All 
    Select '疾病编码目录','SELECT' From Dual Union All 
    Select '人员性质说明','SELECT' From Dual Union All 
    Select '人员证书记录','SELECT' From Dual Union All 
    Select '电子病历打印','SELECT' From Dual Union All 
    Select '电子病历附件','SELECT' From Dual Union All 
    Select '电子病历记录','SELECT' From Dual Union All 
    Select '电子病历内容','SELECT' From Dual Union All 
    Select '电子病历时机','SELECT' From Dual Union All 
    Select '电子病历图形','SELECT' From Dual Union All 
    Select '影像检查记录','SELECT' From Dual Union All 
    Select '影像设备目录','SELECT' From Dual Union All     
    Select '诊疗项目别名','SELECT' From Dual Union All 
    Select '诊疗项目目录','SELECT' From Dual Union All 
    Select '诊治所见分类','SELECT' From Dual Union All 
    Select '诊治所见项目','SELECT' From Dual Union All 
    Select '诊治所见性质','SELECT' From Dual Union All 
    Select '病人变动记录','SELECT' From Dual Union All 
    Select '病人医嘱报告','SELECT' From Dual Union All 
    Select '病案主页从表','SELECT' From Dual Union All 
    Select '病人新生儿记录','SELECT' From Dual Union All 
    Select '医疗卡挂失方式','SELECT' From Dual Union All 
    Select '病人医疗卡属性','SELECT' From Dual Union All 
    Select '病人医疗卡信息','SELECT' From Dual Union All 
    Select '卡消费接口目录','SELECT' From Dual Union All 
    Select 'Zl_Out_Epr_Allowed','EXECUTE' From Dual Union All 
    Select 'zl_人员证书记录_insert','EXECUTE' From Dual Union All 
    Select 'F_SENTENCE_USABLE','EXECUTE' From Dual Union All 
    Select 'T_DIC_ROWSET','EXECUTE' From Dual Union All 
    Select 'ZL_DIC_SEARCH','EXECUTE' From Dual Union All 
    Select 'ZL_Replace_Element_Value','EXECUTE' From Dual Union All 
    Select 'Zl_In_Epr_Allowed','EXECUTE' From Dual Union All 
    Select 'Zl_Lob_Read','EXECUTE' From Dual Union All 
    Select 'Zl_电子病历打印_Cancel','EXECUTE' From Dual Union All 
    Select 'Zl_电子病历打印_Insert','EXECUTE' From Dual Union All 
    Select 'Zl_电子病历时机_Makeup','EXECUTE' From Dual Union All 
    Select 'Zl_Replace_Element_Value','EXECUTE' From Dual Union All 
    Select 'f_Segment_Usable','EXECUTE' From Dual Union All 
    Select 'zl_疾病申报记录_update','EXECUTE' From Dual Union All 
    Select 'Zl_传染病报告卡内容_Update','EXECUTE' From Dual Union All 
    Select 'Zl_电子病历记录_DELETE','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1249,'病历归档',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
    Select 'Zl_电子病历记录_Archive','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1249,'病历审阅',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
    Select '电子病历记录_ID','SELECT' From Dual Union All
    Select '电子病历内容_ID','SELECT' From Dual Union All
    Select 'Zl_Lob_Append','EXECUTE' From Dual Union All
    Select 'ZL_电子病历内容_UPDATE','EXECUTE' From Dual Union All
    Select 'Zl_电子病历记录_UPDATE','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1249,'病历书写',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
    Select 'ZL_电子病历内容_UPDATE','EXECUTE' From Dual Union All
    Select 'Zl_Lob_Append','EXECUTE' From Dual Union All
    Select 'Zl_电子病历记录_UPDATE','EXECUTE' From Dual Union All
    Select 'Zl_电子病历记录_更改序号','EXECUTE' From Dual Union All
    Select '病历范文包','SELECT' From Dual Union All
    Select '电子病历格式','SELECT' From Dual Union All
    Select '病历范文包组成','SELECT' From Dual Union All
    Select '电子病历记录_ID','SELECT' From Dual Union All
    Select '电子病历内容_ID','SELECT' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1249,'质量监测',User,A.* From (
    Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
    Select 'Zl_病历内容监测_Neaten','EXECUTE' From Dual Union All
    Select 'Zl_病历时限监测_Neaten','EXECUTE' From Dual Union All
    Select '病历内容监测','SELECT' From Dual Union All
    Select '病历时限监测','SELECT' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--102930:刘尔旋,2016-11-22,门诊转住院权限缺失
Insert Into zlProgPrivs(系统, 序号, 功能, 所有者, 对象, 权限)
Select &n_System, 1137, '门诊费用转住院', User, a.* From (
Select 对象, 权限 From zlProgPrivs Where 1 = 0 Union All
 Select 'Zl_门诊转住院_三方卡结算', 'EXECUTE' From Dual Union All
Select 对象, 权限 From zlProgPrivs Where 1 = 0) A;

--102861:张险华,2016-11-21,会诊医嘱取消关联
Insert Into zlProgPrivs
  (系统, 序号, 功能, 对象, 所有者, 权限)
  Select &n_System, 1251, '基本', 'Zl_病历医嘱报告_Modify', User, 'EXECUTE' From Dual;

--102975:冉俊明,2016-11-25,成套方案的使用调整。
Delete From Zlprogrelas
Where 系统 = &n_System And 序号 In (1120, 1121, 1122, 1150, 1257) And 功能 In ('增加成套项目', '本科成套方案', '全院成套方案');

--103758:李业庆,2016-12-13,申领移库增加当前库房对方库房显示库存方式
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1343, 1, 0, 0, 0, 0, 0, 8, '填单时当前库房库存显示方式', '0', '0', '填写申领单时当前库房的库存显示方式',
         '填写申领单时当前库房的库存显示方式，0-显示库存实际数量,1-显示库存可用数量', Null, Null, Null
  From Dual;
  
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1343, 1, 0, 0, 0, 0, 0, 9, '填单时对方库房库存显示方式', '0', '0', '填写申领单时对方库房的库存显示方式',
         '填写申领单时对方库房的库存显示方式，0-显示库存实际数量,1-显示库存可用数量', Null, Null, Null
  From Dual;

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1304, 1, 0, 0, 0, 0, 0, 10, '填单时当前库房库存显示方式', '0', '0', '填写移库单时当前库房的库存显示方式',
         '填写移库单时当前库房的库存显示方式，0-显示库存实际数量,1-显示库存可用数量', Null, Null, Null
  From Dual;
  
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 部门, 性质, 参数号, 参数名, 参数值, 缺省值, 影响控制说明, 参数值含义, 关联说明, 适用说明, 警告说明)
  Select Zlparameters_Id.Nextval, &n_System, 1304, 1, 0, 0, 0, 0, 0, 11, '填单时对方库房库存显示方式', '0', '0', '填写移库单时对方库房的库存显示方式',
         '填写移库单时对方库房的库存显示方式，0-显示库存实际数量,1-显示库存可用数量', Null, Null, Null
  From Dual;

--104963:李业庆,2017-1-24,诊疗项目目录增加应用范围参数 
Insert Into zlProgFuncs(系统, 序号, 功能, 排列, 说明, 缺省值)
Select &n_System, 1054, a.* From (
Select 功能, 排列, 说明, 缺省值 From zlProgFuncs Where 1 = 0 Union All
  Select '参数设置',9,'设置参数设置的操作权限。有该权限时，允许对需要权限控制的参数进行参数设置',1 From Dual Union All
Select 功能, 排列, 说明, 缺省值 From zlProgFuncs Where 1 = 0) A;

-------------------------------------------------------------------------------
--报表修正部份
-------------------------------------------------------------------------------






-------------------------------------------------------------------------------
--过程修正部份
-------------------------------------------------------------------------------
--103900:张险华,2016-12-19,门诊病人取年龄用病人挂号记录
--106905:张险华,2017-03-08,PACS病人取年龄用病人信息
Create Or Replace Function Zl_Replace_Element_Value
(
  元素名_In   In 诊治所见项目.中文名%Type,
  病人id_In   In 电子病历记录.病人id%Type,
  就诊id_In   In 电子病历记录.主页id%Type,
  病人来源_In In 电子病历记录.病人来源%Type,
  医嘱id_In   In 病人医嘱记录.Id%Type := Null,
  婴儿_In     In Number := 0,
  时间_In     In Date := Null
) Return Varchar2 Is
  v_Return Varchar2(4000) := Null;

  Cursor c_Annex Is
    Select 医嘱id, 项目, 内容 From 病人医嘱附件 Where 医嘱id = 医嘱id_In And 项目 = 元素名_In;
  r_Annex c_Annex%RowType;

  Cursor c_Pati Is
    Select 姓名, 性别, 年龄, 职业, 民族, 国籍, 婚姻状况, 出生日期, 出生地点, 身份证号, 身份, 学历, 家庭地址, 家庭电话, 工作单位, 单位电话, 门诊号, 住院次数, 联系人姓名, 联系人关系,
           联系人地址, 联系人电话
    From 病人信息
    Where 病人id = 病人id_In;
  r_Patient c_Pati%RowType;

  Cursor c_Reg Is
    Select 姓名, 性别, 年龄, 摘要, 登记时间, 急诊, 执行部门id
    From 病人挂号记录
    Where 病人id + 0 = 病人id_In And ID = 就诊id_In;
  r_Regist c_Reg%RowType;

  Cursor c_Inpage Is
    Select Nvl(b.姓名, a.姓名) 姓名, Nvl(b.性别, a.性别) 性别, Nvl(b.年龄, a.年龄) 年龄, b.住院号, b.入院日期, b.出院日期, b.住院目的, b.入院科室id, b.入院病区id,
           b.出院病床, b.当前病区id, b.当前病况, b.住院医师, b.责任护士, b.二级院转入, b.入院方式, b.护理等级id, b.出院方式, b.入院病床, b.联系人姓名, b.联系人关系,
           b.联系人地址, b.联系人电话, b.出院科室id, b.留观号
    From 病人信息 A, 病案主页 B
    Where a.病人id = b.病人id And b.病人id = 病人id_In And b.主页id = 就诊id_In;
  r_Inpage c_Inpage%RowType;

  Cursor c_Order Is
    Select 婴儿, 紧急标志, 开嘱科室id, 开嘱医生, 开嘱时间, 执行科室id, 开始执行时间, 医生嘱托, 诊疗类别, 诊疗项目id, 标本部位, 检查方法
    
    From 病人医嘱记录
    Where 病人id + 0 = 病人id_In And ID = 医嘱id_In;
  r_Order c_Order%RowType;

  Cursor c_Signs Is
    Select b.项目名称, b.记录内容
    From 病人护理记录 A, 病人护理内容 B
    Where a.病人id = 病人id_In And a.主页id = 就诊id_In And a.病人来源 = 病人来源_In And a.Id = b.记录id And b.记录类型 = 1 And
          b.项目名称 = 元素名_In;
  r_Signs c_Signs%RowType;

  v_Subtype 诊疗项目目录.操作类型%Type := Null;

  Type t_Str_Table Is Table Of Varchar2(2000);
  a_Return t_Str_Table := t_Str_Table();

  n_主页id 病案主页.主页id%Type;
  n_Times  Number;
  n_Have   Number(3);
  v_Sql    Varchar2(2000);

  --获取指定表的行类型
  Procedure p_Get_Rowtype(Table_In In Varchar2) Is
  Begin
    If Table_In = '病人信息' Then
      Open c_Pati;
      Fetch c_Pati
        Into r_Patient;
    Elsif Table_In = '病人挂号记录' Then
      Open c_Reg;
      Fetch c_Reg
        Into r_Regist;
    Elsif Table_In = '病案主页' Then
      Open c_Inpage;
      Fetch c_Inpage
        Into r_Inpage;
    Elsif Table_In = '病人医嘱记录' Then
      Open c_Order;
      Fetch c_Order
        Into r_Order;
    Elsif Table_In = '病人护理内容' Then
      Open c_Signs;
      Fetch c_Signs
        Into r_Signs;
    Elsif Table_In = '病人医嘱附件' Then
      Open c_Annex;
      Fetch c_Annex
        Into r_Annex;
    End If;
  Exception
    When Others Then
      Null;
  End p_Get_Rowtype;

  --从电子病历内容获取指定预制提纲的最新内容
  Function f_Latest_Epr_Content(提纲标题_In In 病历文件结构.内容文本%Type) Return Varchar2 Is
    v_Content Varchar2(32767);
    n_预制id  病历文件结构.Id%Type;
  Begin
    Select ID Into n_预制id From 病历文件结构 Where 内容文本 = 提纲标题_In And 文件id Is Null;
    Select c.内容文本 || Decode(c.要素类型, 0, c.要素单位) Bulk Collect
    Into a_Return
    From 电子病历内容 C,
         (Select ID
           From (Select r.Id 记录id, c.Id
                  From 电子病历记录 R, 电子病历内容 C
                  Where r.Id = c.文件id And r.病人id = 病人id_In And r.主页id = 就诊id_In And c.预制提纲id + 0 = n_预制id
                  Order By r.创建时间 Desc)
           Where Rownum = 1) P
    Where c.父id = p.Id And (c.对象类型 = 2 Or c.对象类型 = 4)
    Order By c.对象序号, c.内容行次;
    v_Content := Null;
    For n_Count In 1 .. a_Return.Count Loop
      v_Content := v_Content || a_Return(n_Count);
    End Loop;
    v_Content := Replace(v_Content, ' ', '');
    Return v_Content;
  Exception
    When Others Then
      Return Null;
  End f_Latest_Epr_Content;

  --从病人医嘱附件获取指定要素的最新内容，实际只有“病历摘要”需要
  Function f_Latest_Advice_Annex Return Varchar2 Is
    v_Content Varchar2(32767);
    n_要素id  病人医嘱附件.要素id%Type;
    v_挂号单  病人医嘱记录.挂号单%Type;
  Begin
    Select ID Into n_要素id From 诊治所见项目 Where 中文名 = 元素名_In;
    If 病人来源_In = 1 Then
      Select NO Into v_挂号单 From 病人挂号记录 Where ID = 就诊id_In;
    End If;
    Select 内容
    Into v_Content
    From (Select l.Id, a.内容, l.开嘱时间
           From 病人医嘱记录 L, 病人医嘱附件 A
           Where l.Id = a.医嘱id And l.病人id = 病人id_In And a.要素id = n_要素id
           Order By l.开嘱时间 Desc)
    Where Rownum = 1;
    Return v_Content;
  Exception
    When Others Then
      Return Null;
  End f_Latest_Advice_Annex;

  --获得病人指定就诊次数的最新诊断
  Function f_Latest_Diagnose
  (
    主页id_In In 病人诊断记录.主页id%Type,
    时间_In   In Date := Null
  ) Return Varchar2 Is
    v_Content Varchar2(32767);
  Begin
    If 时间_In Is Null Then
      --如果已经整理首页或病案中的诊断，则以这些诊断为最后诊断返回
      Select 诊断描述 || Decode(Nvl(是否疑诊, 0), 0, '', ' (？)') Bulk Collect
      Into a_Return
      From 病人诊断记录 D,
           (Select Max(记录来源) As 记录来源, Max(Mod(诊断类型, 10)) As 诊断类型
             From 病人诊断记录
             Where 病人id = 病人id_In And 主页id = 主页id_In And 病历id Is Null And 记录来源 > 1 And 诊断类型 In (1, 11, 2, 12, 3, 13)) F
      Where d.病人id = 病人id_In And d.主页id = 主页id_In And d.记录来源 = f.记录来源 And Mod(d.诊断类型, 10) = f.诊断类型
      Order By d.诊断次序;
      v_Content := Null;
      For n_Count In 1 .. a_Return.Count Loop
        If a_Return.Count > 1 Then
          v_Content := v_Content || '  ' || n_Count || '、' || a_Return(n_Count);
        Else
          v_Content := v_Content || a_Return(n_Count);
        End If;
      End Loop;
      If v_Content Is Not Null Then
        Return Trim(v_Content);
      End If;
    
      --否则，获取最后书写的病历中诊断作为最后诊断(隐含包括，如果还没有写病历，则以入院时填写的诊断为最后诊断)：
      Select d.诊断描述 || Decode(Nvl(d.是否疑诊, 0), 0, '', ' (？)') Bulk Collect
      Into a_Return
      From 病人诊断记录 D,
           (Select 病历id
             From (Select Distinct a.病历id, b.创建时间
                    From 病人诊断记录 A, 电子病历记录 B
                    Where a.病人id = 病人id_In And a.主页id = 主页id_In And a.诊断类型 In (1, 11, 2, 12, 3, 13) And Nvl(a.病历id, 0) <> 0 And
                          a.病历id = b.Id
                    Order By b.创建时间 Desc)
             Where Rownum = 1) M
      Where d.病人id = 病人id_In And d.主页id = 主页id_In And d.诊断类型 In (1, 11, 2, 12, 3, 13) And d.病历id = m.病历id
      Order By d.诊断次序;
      For n_Count In 1 .. a_Return.Count Loop
        If a_Return.Count > 1 Then
          v_Content := v_Content || '  ' || n_Count || '、' || a_Return(n_Count);
        Else
          v_Content := v_Content || a_Return(n_Count);
        End If;
      End Loop;
      Return Trim(v_Content);
    Else
      Select 诊断描述 || Decode(Nvl(是否疑诊, 0), 0, '', ' (？)') Bulk Collect
      Into a_Return
      From 病人诊断记录 D,
           (Select Max(记录来源) As 记录来源, Max(Mod(诊断类型, 10)) As 诊断类型
             From 病人诊断记录
             Where 病人id = 病人id_In And 主页id = 主页id_In And 记录日期 < 时间_In And 诊断类型 In (1, 11, 2, 12, 3, 13)) F
      Where d.病人id = 病人id_In And d.主页id = 主页id_In And d.记录来源 = f.记录来源 And Mod(d.诊断类型, 10) = f.诊断类型
      Order By d.诊断次序;
      v_Content := Null;
      For n_Count In 1 .. a_Return.Count Loop
        If a_Return.Count > 1 Then
          v_Content := v_Content || '  ' || n_Count || '、' || a_Return(n_Count);
        Else
          v_Content := v_Content || a_Return(n_Count);
        End If;
      End Loop;
      If v_Content Is Not Null Then
        Return Trim(v_Content);
      End If;
    End If;
  
  Exception
    When Others Then
      Return Null;
  End f_Latest_Diagnose;

  --获取病人最新疾病ID和诊断ID
  Function f_Last_Diagnoseid(主页id_In In 病人诊断记录.主页id%Type) Return Varchar2 Is
    v_Returndiagnose Varchar2(500);
  Begin
    For r_Diagnose In (Select 疾病id, 诊断id
                       From 病人诊断记录 D,
                            (Select Max(记录来源) As 记录来源, Max(Mod(诊断类型, 10)) As 诊断类型
                              From 病人诊断记录
                              Where 病人id = 病人id_In And 主页id = 主页id_In And 病历id Is Null And 记录来源 > 1 And
                                    诊断类型 In (1, 11, 2, 12, 3, 13)) F
                       Where d.病人id = 病人id_In And d.主页id = 主页id_In And d.记录来源 = f.记录来源 And Mod(d.诊断类型, 10) = f.诊断类型
                       Order By d.诊断次序) Loop
      v_Returndiagnose := r_Diagnose.疾病id || '|' || r_Diagnose.诊断id;
      Return v_Returndiagnose;
    End Loop;
    --没取到则返回
    v_Returndiagnose := '|';
    Return v_Returndiagnose;
  Exception
    When Others Then
      Return Null;
  End f_Last_Diagnoseid;

  --获得病人指定住院诊断
  Function f_Diagnose(Inttype_In In Number) Return Varchar2 Is
    v_Content Varchar2(32767);
  Begin
    --intType_IN:1-西医门诊诊断;2-中医门诊诊断;3-西医入院诊断;4-中医入院诊断;
    --       5,所有西医出院诊断;6,只取西医出院主要诊断(诊断次序)=1;7,只取西医出院其他诊断(诊断次序)>1;8-中医出院诊断
    Select 诊断描述 || Decode(Nvl(是否疑诊, 0), 0, '', ' (？)') Bulk Collect
    Into a_Return
    From 病人诊断记录 D,
         (Select Max(记录来源) As 记录来源, Max(诊断类型) As 诊断类型
           From 病人诊断记录
           Where 病人id = 病人id_In And 主页id = 就诊id_In And 病历id Is Null And 记录来源 > 1 And
                 诊断类型 = Decode(Inttype_In, 1, 1, 2, 11, 3, 2, 4, 12, 8, 13, 3)) F
    Where d.病人id = 病人id_In And d.主页id = 就诊id_In And d.记录来源 = f.记录来源 And d.诊断类型 = f.诊断类型 And
          d.诊断次序 > Decode(Inttype_In, 7, 1, 0) And Rownum < Decode(Inttype_In, 6, 2, 10)
    Order By d.诊断次序;
  
    v_Content := Null;
    For n_Count In 1 .. a_Return.Count Loop
      If a_Return.Count > 1 Then
        v_Content := v_Content || '  ' || n_Count || '、' || a_Return(n_Count);
      Else
        v_Content := v_Content || a_Return(n_Count);
      End If;
    End Loop;
    If v_Content Is Not Null Then
      Return Trim(v_Content);
    End If;
  
  Exception
    When Others Then
      Return Null;
  End f_Diagnose;

  --获取病人本次就诊的医嘱内容
  Function f_Get_Advice_Text Return Varchar2 Is
    v_Text   Varchar2(4000);
    v_挂号单 病人挂号记录.No%Type;
  Begin
    If 病人来源_In = 1 Then
      Begin
        Select NO Into v_挂号单 From 病人挂号记录 Where ID = 就诊id_In;
      Exception
        When Others Then
          Return Null;
      End;
    End If;
  
    --提取病人医嘱：界面可见行医嘱内容，不含作废的
    For r_Row In (Select a.医嘱内容
                  From 病人医嘱记录 A, 诊疗项目目录 B
                  Where a.诊疗项目id = b.Id And a.开始执行时间 Is Not Null And a.医嘱状态 <> 4 And Nvl(a.婴儿, 0) = 0 And
                        Not (a.诊疗类别 In ('F', 'G', 'D', 'C', 'E') And a.相关id Is Not Null) And a.诊疗类别 <> '7' And
                        Not (a.诊疗类别 = 'E' And b.操作类型 In ('2', '4')) And a.病人来源 = 病人来源_In And a.病人id = 病人id_In And
                        (病人来源_In = 1 And a.挂号单 = v_挂号单 Or a.主页id = 就诊id_In)
                  Order By a.序号) Loop
      If Lengthb(v_Text || r_Row.医嘱内容) <= 4000 Then
        v_Text := v_Text || Chr(13) || Chr(10) || r_Row.医嘱内容;
      Else
        Exit;
      End If;
    End Loop;
  
    Return Substr(v_Text, 3);
  End f_Get_Advice_Text;
Begin
  Case
    When Instr('会诊范围,会诊邀请医院,会诊邀请科室,会诊医生级别,会诊邀请医生,会诊代表科室,会诊诊断,会诊目的,会诊意见,会诊完成时间,会诊完成科室,会诊医生', 元素名_In) > 0 Then
      p_Get_Rowtype('病人医嘱附件');
      v_Return := r_Annex.内容;
    When Instr('体温,呼吸,脉搏,收缩压,舒张压', 元素名_In) > 0 And 病人来源_In = 1 Then
      p_Get_Rowtype('病人护理内容');
      v_Return := r_Signs.记录内容;
    When Instr(',当前日期,当前时间,DQSJ', ',' || Upper(元素名_In)) > 0 Then
      --无需读取任何表数据的元素
      Case Upper(元素名_In)
        When '当前日期' Then
          v_Return := To_Char(Sysdate, 'yyyy-mm-dd');
          v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日';
        When '当前时间' Then
          v_Return := To_Char(Sysdate, 'yyyy-mm-dd hh24:mi');
          v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日' ||
                      Substr(v_Return, 12, 2) || '时' || Substr(v_Return, 15, 2) || '分';
        When 'DQSJ' Then
          v_Return := To_Char(Sysdate, 'yyyy-mm-dd hh24:mi');
          v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日' ||
                      Substr(v_Return, 12, 2) || '时' || Substr(v_Return, 15, 2) || '分';
      End Case;
    When Instr(',职业,民族,国籍,婚姻状况,出生日期,出生地点,身份证号,身份,学历,家庭地址,家庭电话,工作单位,单位电话,门诊号,住院次数', ',' || 元素名_In) > 0 Then
      --只查病人信息表的元素
      p_Get_Rowtype('病人信息');
      Case 元素名_In
        When '职业' Then
          v_Return := r_Patient.职业;
        When '民族' Then
          v_Return := r_Patient.民族;
        When '国籍' Then
          v_Return := r_Patient.国籍;
        When '婚姻状况' Then
          v_Return := r_Patient.婚姻状况;
        When '出生日期' Then
          v_Return := To_Char(r_Patient.出生日期, 'yyyy-mm-dd');
          v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日';
        When '出生地点' Then
          v_Return := r_Patient.出生地点;
        When '身份证号' Then
          v_Return := r_Patient.身份证号;
        When '身份' Then
          v_Return := r_Patient.身份;
        When '学历' Then
          v_Return := r_Patient.学历;
        When '家庭地址' Then
          v_Return := r_Patient.家庭地址;
        When '家庭电话' Then
          v_Return := r_Patient.家庭电话;
        When '工作单位' Then
          v_Return := r_Patient.工作单位;
        When '单位电话' Then
          v_Return := r_Patient.单位电话;
        When '门诊号' Then
          v_Return := r_Patient.门诊号;
        When '住院次数' Then
          v_Return := Nvl(r_Patient.住院次数, 0);
        Else
          v_Return := '';
      End Case;
    When Instr(',留观号,住院号,入院日期,出院日期,住院目的,入院科室,入院病区,当前床号,当前病区,当前病况,住院医师,责任护士,住院天数,入院方式,护理等级,出院方式,入院病室,出院病室,当前病室',
               ',' || 元素名_In) > 0 Then
      --只查病人主页的元素
      p_Get_Rowtype('病案主页');
      Case 元素名_In
        When '留观号' Then
          v_Return := r_Inpage.留观号;
        When '住院号' Then
          v_Return := r_Inpage.住院号;
        When '入院日期' Then
          If 病人来源_In = 2 Then
            v_Return := To_Char(r_Inpage.入院日期, 'yyyy-mm-dd hh24:mi');
            v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日' ||
                        Substr(v_Return, 12, 2) || '时' || Substr(v_Return, 15, 2) || '分';
          
          End If;
        When '出院日期' Then
          If 病人来源_In = 2 Then
            v_Return := To_Char(r_Inpage.出院日期, 'yyyy-mm-dd hh24:mi');
            v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日' ||
                        Substr(v_Return, 12, 2) || '时' || Substr(v_Return, 15, 2) || '分';
          End If;
        When '住院目的' Then
          If 病人来源_In = 2 Then
            v_Return := r_Inpage.住院目的;
          End If;
        
        When '入院科室' Then
          If 病人来源_In = 2 Then
            Select Max(d.名称)
            Into v_Return
            From 部门表 D, 病人变动记录 P
            Where d.Id = p.科室id And p.病人id = 病人id_In And p.主页id = 就诊id_In And p.开始原因 = 9;
            If v_Return Is Null Then
              Select 名称 Into v_Return From 部门表 Where ID = r_Inpage.入院科室id;
            End If;
          End If;
        When '入院病区' Then
          If 病人来源_In = 2 Then
            Select Max(d.名称)
            Into v_Return
            From 部门表 D, 病人变动记录 P
            Where d.Id = p.病区id And p.病人id = 病人id_In And p.主页id = 就诊id_In And p.开始原因 = 9;
            If v_Return Is Null Then
              Select 名称 Into v_Return From 部门表 Where ID = r_Inpage.入院病区id;
            End If;
          End If;
        When '当前床号' Then
          If 病人来源_In = 2 Then
            v_Return := r_Inpage.出院病床;
          End If;
        When '当前病区' Then
          If 病人来源_In = 2 Then
            Select 名称 Into v_Return From 部门表 Where ID = r_Inpage.当前病区id;
          End If;
        When '当前病况' Then
          If 病人来源_In = 2 Then
            v_Return := r_Inpage.当前病况;
          End If;
        When '住院医师' Then
          If 病人来源_In = 2 Then
            v_Return := r_Inpage.住院医师;
          End If;
        When '责任护士' Then
          If 病人来源_In = 2 Then
            v_Return := r_Inpage.责任护士;
          End If;
        When '住院天数' Then
          If 病人来源_In = 2 Then
            v_Return := Trunc(Nvl(r_Inpage.出院日期, Sysdate)) - Trunc(r_Inpage.入院日期);
          End If;
        When '入院方式' Then
          If 病人来源_In = 2 Then
            If r_Inpage.二级院转入 = 1 Then
              v_Return := '转入';
            Else
              v_Return := r_Inpage.入院方式;
            
            End If;
          
          End If;
        When '护理等级' Then
          If 病人来源_In = 2 Then
            Select 名称 Into v_Return From 收费项目目录 Where ID = r_Inpage.护理等级id;
          End If;
        When '出院方式' Then
          If 病人来源_In = 2 Then
            v_Return := r_Inpage.出院方式;
          End If;
        When '入院病室' Then
          If 病人来源_In = 2 Then
            If v_Return Is Null And r_Inpage.入院病床 Is Not Null Then
              Begin
                Select 房间号
                Into v_Return
                From 床位状况记录
                Where 病区id = r_Inpage.入院病区id And 床号 = r_Inpage.入院病床;
              Exception
              
                When Others Then
                  Null;
              End;
            End If;
          End If;
        When '出院病室' Then
          If 病人来源_In = 2 Then
            If v_Return Is Null And r_Inpage.出院病床 Is Not Null Then
            
              Begin
                Select 房间号
                Into v_Return
                From 床位状况记录
                Where 病区id = r_Inpage.当前病区id And 床号 = r_Inpage.出院病床;
              Exception
                When Others Then
                  Null;
              End;
            End If;
          End If;
        When '当前病室' Then
          If 病人来源_In = 2 Then
            If v_Return Is Null And r_Inpage.出院病床 Is Not Null Then
              Begin
                Select 房间号
                Into v_Return
                From 床位状况记录
                Where 病区id = r_Inpage.当前病区id And 床号 = r_Inpage.出院病床;
              Exception
                When Others Then
                  Null;
              End;
            End If;
          End If;
        Else
          v_Return := '';
      End Case;
    When Instr(',姓名,性别,年龄', ',' || 元素名_In) > 0 Then
      p_Get_Rowtype('病人医嘱记录');
      If Nvl(r_Order.婴儿, 0) = 0 And Nvl(婴儿_In, 0) = 0 Then
        If 病人来源_In = 2 Then
          p_Get_Rowtype('病案主页');
          If 元素名_In = '姓名' Then
            v_Return := r_Inpage.姓名;
          Elsif 元素名_In = '性别' Then
            v_Return := r_Inpage.性别;
          Elsif 元素名_In = '年龄' Then
            v_Return := r_Inpage.年龄;
          End If;
        Else
		  p_Get_Rowtype('病人挂号记录');
          If Not r_Regist.姓名 Is Null Then
            If 元素名_In = '姓名' Then
              v_Return := r_Regist.姓名;
            Elsif 元素名_In = '性别' Then
              v_Return := r_Regist.性别;
            Elsif 元素名_In = '年龄' Then
              v_Return := r_Regist.年龄;
            End If;
          Else
            p_Get_Rowtype('病人信息');
            If 元素名_In = '姓名' Then
              v_Return := r_Patient.姓名;
            Elsif 元素名_In = '性别' Then
              v_Return := r_Patient.性别;
            Elsif 元素名_In = '年龄' Then
              v_Return := r_Patient.年龄;
            End If;
          End If;
        End If;
      Else
        If 元素名_In = '姓名' Then
          p_Get_Rowtype('病案主页');
          Select Decode(婴儿姓名, Null, r_Inpage.姓名 || '之婴' || Trim(To_Char(序号, '9')), 婴儿姓名) As 婴儿姓名
          Into v_Return
          From 病人新生儿记录
          Where 病人id = 病人id_In And 主页id = 就诊id_In And 序号 = Decode(婴儿_In, 0, Nvl(r_Order.婴儿, 0), 婴儿_In);
        Elsif 元素名_In = '性别' Then
          Select 婴儿性别
          Into v_Return
          From 病人新生儿记录
          Where 病人id = 病人id_In And 主页id = 就诊id_In And 序号 = Decode(婴儿_In, 0, Nvl(r_Order.婴儿, 0), 婴儿_In);
        Elsif 元素名_In = '年龄' Then
          Select To_Char(出生时间, 'yyyy-mm-dd hh24:mi')
          Into v_Return
          From 病人新生儿记录
          Where 病人id = 病人id_In And 主页id = 就诊id_In And 序号 = Decode(婴儿_In, 0, Nvl(r_Order.婴儿, 0), 婴儿_In);
        End If;
      End If;
    When Instr(',标识号,联系人姓名,联系人关系,联系人地址,联系人电话', ',' || 元素名_In) > 0 Then
      If 病人来源_In = 2 Then
        p_Get_Rowtype('病案主页');
        If 元素名_In = '标识号' Then
          v_Return := r_Inpage.住院号;
        Elsif 元素名_In = '联系人姓名' Then
          v_Return := r_Inpage.联系人姓名;
        Elsif 元素名_In = '联系人关系' Then
          v_Return := r_Inpage.联系人关系;
        Elsif 元素名_In = '联系人地址' Then
          v_Return := r_Inpage.联系人地址;
        Elsif 元素名_In = '联系人电话' Then
          v_Return := r_Inpage.联系人电话;
        End If;
      Else
        p_Get_Rowtype('病人信息');
        If 元素名_In = '标识号' Then
          v_Return := r_Patient.门诊号;
        Elsif 元素名_In = '联系人姓名' Then
          v_Return := r_Patient.联系人姓名;
        Elsif 元素名_In = '联系人关系' Then
          v_Return := r_Patient.联系人关系;
        Elsif 元素名_In = '联系人地址' Then
          v_Return := r_Patient.联系人地址;
        Elsif 元素名_In = '联系人电话' Then
          v_Return := r_Patient.联系人电话;
        End If;
      End If;
    When Instr(',门诊就诊摘要,就诊科室,就诊时间,是否急诊,当前科室', ',' || 元素名_In) > 0 Then
      --只查病人挂号记录的元素
      If 病人来源_In = 1 Then
        p_Get_Rowtype('病人挂号记录');
        If 元素名_In = '门诊就诊摘要' Then
          v_Return := r_Regist.摘要;
        Elsif 元素名_In = '就诊科室' Then
          Select 名称 Into v_Return From 部门表 Where ID = r_Regist.执行部门id;
        Elsif 元素名_In = '就诊时间' Then
          v_Return := To_Char(r_Regist.登记时间, 'yyyy-mm-dd hh24:mi');
          v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日' ||
                      Substr(v_Return, 12, 2) || '时' || Substr(v_Return, 15, 2) || '分';
        Elsif 元素名_In = '是否急诊' Then
          If r_Regist.急诊 = 1 Then
            v_Return := '急诊';
          End If;
        Elsif 元素名_In = '当前科室' Then
          Select 名称 Into v_Return From 部门表 Where ID = r_Regist.执行部门id;
        End If;
      Else
        If 元素名_In = '当前科室' Then
          p_Get_Rowtype('病案主页');
          Select 名称 Into v_Return From 部门表 Where ID = r_Inpage.出院科室id;
        End If;
      End If;
    When Instr(',紧急程度,开单科室,开单医生,开单时间,开单时间,执行科室,要求时间,医生嘱托,诊疗类别,申请项目,检查类型,部位方法,检验标本', ',' || 元素名_In) > 0 Then
      --只查病人医嘱记录的元素
      p_Get_Rowtype('病人医嘱记录');
      If 元素名_In = '紧急程度' Then
        If r_Order.紧急标志 = 1 Then
          v_Return := '急';
        End If;
      Elsif 元素名_In = '开单科室' Then
        Select 名称 Into v_Return From 部门表 Where ID = r_Order.开嘱科室id;
      Elsif 元素名_In = '开单医生' Then
        v_Return := r_Order.开嘱医生;
      Elsif 元素名_In = '开单时间' Then
        v_Return := To_Char(r_Order.开嘱时间, 'yyyy-mm-dd hh24:mi');
        v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日' ||
                    Substr(v_Return, 12, 2) || '时' || Substr(v_Return, 15, 2) || '分';
      Elsif 元素名_In = '执行科室' Then
        Select 名称 Into v_Return From 部门表 Where ID = r_Order.执行科室id;
      Elsif 元素名_In = '要求时间' Then
        v_Return := To_Char(r_Order.开始执行时间, 'yyyy-mm-dd hh24:mi');
        v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日' ||
                    Substr(v_Return, 12, 2) || '时' || Substr(v_Return, 15, 2) || '分';
      Elsif 元素名_In = '医生嘱托' Then
        v_Return := r_Order.医生嘱托;
      Elsif 元素名_In = '诊疗类别' Then
        Select 名称 Into v_Return From 诊疗项目类别 Where 编码 = r_Order.诊疗类别;
      Elsif 元素名_In = '申请项目' Then
        Select 操作类型 Into v_Subtype From 诊疗项目目录 Where ID = r_Order.诊疗项目id;
        If r_Order.诊疗类别 = 'E' And v_Subtype = '6' Then
          Select i.名称 Bulk Collect
          Into a_Return
          From 诊疗项目目录 I, (Select 序号, 诊疗项目id From 病人医嘱记录 Where 相关id = 医嘱id_In) A
          Where i.Id = a.诊疗项目id
          Order By a.序号;
        Else
          Select i.名称 Bulk Collect
          Into a_Return
          From 诊疗项目目录 I,
               (Select 序号, 诊疗项目id
                 From 病人医嘱记录
                 Where ID = 医嘱id_In
                 Union All
                 Select 序号, 诊疗项目id
                 From 病人医嘱记录
                 Where 相关id = 医嘱id_In And 诊疗类别 <> 'G') A
          Where i.Id = a.诊疗项目id
          Group By i.名称
          Order By Max(a.序号);
        End If;
        If a_Return.Count > 1 Then
          For n_Count In 1 .. a_Return.Count Loop
            v_Return := v_Return || ' ' || n_Count || ')' || a_Return(n_Count);
          End Loop;
        Else
          v_Return := a_Return(1);
        End If;
        v_Return := Trim(v_Return);
      Elsif 元素名_In = '检查类型' Then
        Select 操作类型 Into v_Return From 诊疗项目目录 Where ID = r_Order.诊疗项目id And 类别 = 'D';
      Elsif 元素名_In = '部位方法' Then
        Select 部位 || Chr(9) || 方法 Bulk Collect
        Into a_Return
        From (Select 标本部位 As 部位, 检查方法 As 方法
               From 病人医嘱记录
               Where 相关id = 医嘱id_In And 诊疗类别 = 'D'
               Union All
               Select r_Order.标本部位, r_Order.检查方法
               From Dual) A,
             (Select p.编码, p.名称
               From 诊疗检查部位 P, 诊疗项目目录 I
               Where p.类型 = i.操作类型 And ID = r_Order.诊疗项目id And 类别 = 'D') P
        Where a.部位 = p.名称
        Order By p.编码;
        For n_Count In 1 .. a_Return.Count Loop
          If Instr(v_Return, ' ' || Substr(a_Return(n_Count), 1, Instr(a_Return(n_Count), Chr(9)))) > 0 Then
            v_Return := v_Return || '、' || Substr(a_Return(n_Count), Instr(a_Return(n_Count), Chr(9)) + 1);
          Else
            v_Return := v_Return || '  ' || a_Return(n_Count);
          End If;
        End Loop;
        v_Return := Replace(v_Return, Chr(9), ':');
      Elsif 元素名_In = '检验标本' Then
        v_Return := r_Order.标本部位;
      Else
        v_Return := '';
      End If;
    Else
      --自行查询SQL返回值的元素
      If 元素名_In = '单位名称' Then
        Select 内容 Into v_Return From Zlregaudit Where 项目 = '单位名称';
        If Instr(v_Return, ';') > 0 Then
          v_Return := Substr(v_Return, 1, Instr(v_Return, ';') - 1);
        End If;
      Elsif 元素名_In = '入科时间' Then
        If 病人来源_In = 2 Then
          Select Count(*)
          Into n_Times
          From 病人变动记录
          Where 病人id = 病人id_In And 主页id = 就诊id_In And 开始原因 = 2;
          If n_Times = 0 Then
            Select To_Char(开始时间, 'yyyy-mm-dd hh24:mi')
            Into v_Return
            From 病人变动记录
            Where 病人id = 病人id_In And 主页id = 就诊id_In And 开始原因 = 1;
          Else
            Select To_Char(开始时间, 'yyyy-mm-dd hh24:mi')
            Into v_Return
            From 病人变动记录
            Where 病人id = 病人id_In And 主页id = 就诊id_In And 开始原因 = 2;
          End If;
          v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日' ||
                      Substr(v_Return, 12, 2) || '时' || Substr(v_Return, 15, 2) || '分';
        End If;
      
      Elsif 元素名_In = 'ABO' Or 元素名_In = 'RH' Then
        Select 信息值 Into v_Return From 病人信息从表 P Where p.病人id = 病人id_In And p.信息名 = 元素名_In;
      Elsif 元素名_In = '一次住院时间' Or 元素名_In = '二次住院时间' Or 元素名_In = '上次住院时间' Then
        If 病人来源_In = 2 Then
          Select To_Char(入院日期, 'yyyy-mm-dd hh24:mi') Bulk Collect
          Into a_Return
          From 病案主页
          Where 病人id = 病人id_In And 主页id < 就诊id_In
          Order By 入院日期;
          If 元素名_In = '一次住院时间' And a_Return.Count > 0 Then
            v_Return := a_Return(1);
          Elsif 元素名_In = '二次住院时间' And a_Return.Count > 1 Then
            v_Return := a_Return(2);
          Elsif 元素名_In = '上次住院时间' And a_Return.Count > 0 Then
            v_Return := a_Return(a_Return.Count);
          Else
            Return Null;
          End If;
          v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日' ||
                      Substr(v_Return, 12, 2) || '时' || Substr(v_Return, 15, 2) || '分';
        End If;
      Elsif 元素名_In = '最后诊断' Then
        v_Return := f_Latest_Diagnose(就诊id_In, 时间_In);
      Elsif 元素名_In = '最后诊断ID' Then
        v_Return := f_Last_Diagnoseid(就诊id_In);
      Elsif 元素名_In = '门诊诊断' Then
        v_Return := f_Diagnose(1);
      Elsif 元素名_In = '一次住院诊断' Or 元素名_In = '二次住院诊断' Or 元素名_In = '上次住院诊断' Then
        Select 主页id Bulk Collect
        Into a_Return
        From 病案主页
        Where 病人id = 病人id_In And 主页id < 就诊id_In
        Order By 入院日期;
        If 元素名_In = '一次住院诊断' And a_Return.Count > 0 Then
          n_主页id := To_Number(a_Return(1));
        Elsif 元素名_In = '二次住院诊断' And a_Return.Count > 1 Then
          n_主页id := To_Number(a_Return(2));
        Elsif 元素名_In = '上次住院诊断' And a_Return.Count > 0 Then
          n_主页id := To_Number(a_Return(a_Return.Count));
        Else
          Return Null;
        End If;
        v_Return := f_Latest_Diagnose(n_主页id);
      Elsif 元素名_In = '西医门诊诊断' Then
        v_Return := f_Diagnose(1);
      Elsif 元素名_In = '中医门诊诊断' Then
        v_Return := f_Diagnose(2);
      Elsif 元素名_In = '西医入院诊断' Then
        v_Return := f_Diagnose(3);
      Elsif 元素名_In = '中医入院诊断' Then
        v_Return := f_Diagnose(4);
      Elsif 元素名_In = '西医出院诊断' Then
        v_Return := f_Diagnose(5);
      Elsif 元素名_In = '西医出院主要诊断' Then
        v_Return := f_Diagnose(6);
      Elsif 元素名_In = '西医出院其他诊断' Then
        v_Return := f_Diagnose(7);
      Elsif 元素名_In = '中医出院诊断' Then
        v_Return := f_Diagnose(8);
      Elsif 元素名_In = '过敏药物' Then
        Select d.药物名 Bulk Collect
        Into a_Return
        From 病人过敏记录 D, (Select Max(记录时间) As 时间 From 病人过敏记录 Where 病人id = 病人id_In And 结果 = 1) M
        Where d.病人id = 病人id_In And d.结果 = 1 And d.记录时间 = m.时间;
        For n_Count In 1 .. a_Return.Count Loop
          v_Return := v_Return || '；' || a_Return(n_Count);
        End Loop;
        If v_Return Is Not Null Then
          v_Return := Substr(v_Return, 2);
        End If;
      Elsif 元素名_In = '病人主诉' Then
        v_Return := f_Latest_Epr_Content(元素名_In);
        v_Return := Replace(Replace(Replace(v_Return, '病人主诉：'), '病人主诉:'), '病人主诉');
        v_Return := Replace(Replace(Replace(v_Return, '主诉：'), '主诉:'), '主诉');
        v_Return := Replace(Replace(Replace(v_Return, Chr(13)), Chr(10)), ' ');
      Elsif 元素名_In = '病历摘要' Then
        v_Return := f_Latest_Epr_Content(元素名_In);
        If v_Return Is Null Then
          v_Return := f_Latest_Advice_Annex();
        End If;
        If v_Return Is Null Then
          v_Return := f_Latest_Epr_Content('病人主诉');
          v_Return := Replace(Replace(Replace(v_Return, '病人主诉：'), '病人主诉:'), '病人主诉');
          v_Return := Replace(Replace(Replace(v_Return, '主诉：'), '主诉:'), '主诉');
        End If;
      Elsif 元素名_In = '现病史' Or 元素名_In = '体格检查' Or 元素名_In = '辅助检查' Or 元素名_In = '专科检查' Or 元素名_In = '既往史' Then
        v_Return := f_Latest_Epr_Content(元素名_In);
        v_Return := Replace(Replace(Replace(v_Return, Chr(13)), Chr(10)), ' ');
      Elsif 元素名_In = '检验类型' Then
        Select 操作类型
        Into v_Return
        From 诊疗项目目录 I,
             (Select 序号, 诊疗项目id From 病人医嘱记录 Where 相关id = 医嘱id_In And 诊疗类别 = 'C' And Rownum < 2) A
        Where i.Id = a.诊疗项目id;
      Elsif 元素名_In = '麻醉方式' Then
        Select i.名称
        Into v_Return
        From 病人医嘱记录 A, 诊疗项目目录 I
        Where a.诊疗项目id = i.Id And a.相关id = 医嘱id_In And a.诊疗类别 = 'G';
      Elsif 元素名_In = '本次医嘱' Then
        v_Return := f_Get_Advice_Text();
      Elsif 元素名_In = '报到时间' Then
        Select To_Char(Max(报到时间), 'yyyy-mm-dd hh24:mi') Into v_Return From 病人医嘱发送 Where 医嘱id = 医嘱id_In;
        v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日' ||
                    Substr(v_Return, 12, 2) || '时' || Substr(v_Return, 15, 2) || '分';
      Elsif 元素名_In = '执行间' Then
        Select Max(执行间) Into v_Return From 病人医嘱发送 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '费用单号' Then
        Select Max(记录性质 || NO) Into v_Return From 病人医嘱发送 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '执行人' Then
        Select Max(执行人) Into v_Return From 病人医嘱执行 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '执行时间' Then
        Select To_Char(Max(执行时间), 'yyyy-mm-dd hh24:mi') Into v_Return From 病人医嘱执行 Where 医嘱id = 医嘱id_In;
        v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日' ||
                    Substr(v_Return, 12, 2) || '时' || Substr(v_Return, 15, 2) || '分';
      Elsif 元素名_In = '设备型号' Then
        Select 名称 Bulk Collect
        Into a_Return
        From (Select a.名称
               From (Select r.仪器id
                      From 检验标本记录 L, 检验普通结果 R
                      Where r.检验标本id = l.Id And l.医嘱id = 医嘱id_In
                      Union
                      Select l.仪器id
                      From 检验标本记录 L
                      Where l.医嘱id = 医嘱id_In) L, 检验仪器 A
               Where l.仪器id = a.Id
               Union All
               Select 检查设备
               From 影像检查记录
               Where 医嘱id = 医嘱id_In);
        For n_Count In 1 .. a_Return.Count Loop
          v_Return := v_Return || ' ' || a_Return(n_Count);
        End Loop;
        v_Return := Trim(v_Return);
      
      Elsif 元素名_In = '采样人' Then
        Select Max(采样人) Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '采样时间' Then
        Select To_Char(Max(采样时间), 'yyyy-mm-dd hh24:mi') Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '样本条码' Then
        Select Max(样本条码) Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '标本序号' Then
        Select Max(标本序号) Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '标本类型' Then
        Select Max(标本类型) Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '核收人' Then
        Select Max(核收人) Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '核收时间' Then
        Select To_Char(Max(核收时间), 'yyyy-mm-dd hh24:mi') Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '检验人' Then
        Select Max(检验人) Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '检验时间' Then
        Select To_Char(Max(检验时间), 'yyyy-mm-dd hh24:mi') Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '审核人' Then
        Select Max(审核人) Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '审核时间' Then
        Select To_Char(Max(审核时间), 'yyyy-mm-dd hh24:mi') Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '检验评语' Then
        Select Max(备注) Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '检验备注' Then
        Select Max(检验备注) Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '检验项目' Then
        Select 名称 Bulk Collect
        Into a_Return
        From (Select i.名称
               From 诊疗项目目录 I, 病人医嘱记录 A,
                    (Select r.医嘱id From 检验标本记录 L, 检验项目分布 R Where r.标本id = l.Id And l.医嘱id = 医嘱id_In) L
               Where i.Id = a.诊疗项目id And a.相关id = l.医嘱id
               Order By a.序号);
        For n_Count In 1 .. a_Return.Count Loop
          v_Return := v_Return || ' ' || a_Return(n_Count);
        End Loop;
        v_Return := Trim(v_Return);
      
      Elsif 元素名_In = '影像类别' Then
        Select Max(影像类别) Into v_Return From 影像检查记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '检查号' Then
        Select Max(检查号) Into v_Return From 影像检查记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '服用造影剂' Then
        Select 造影剂 || '  用量:' || 用量 || '  浓度:' || 浓度 Into v_Return From 服用造影剂 Where 医嘱id = 医嘱id_In;
      
      Elsif 元素名_In = '手术规模' Or 元素名_In = '手术执行间' Or 元素名_In = '手术麻醉质量' Or 元素名_In = '手术麻醉方式' Or 元素名_In = '手术开始时间' Or
            元素名_In = '手术结束时间' Or 元素名_In = '麻醉开始时间' Or 元素名_In = '麻醉结束时间' Or 元素名_In = '输氧开始时间' Or 元素名_In = '输氧结束时间' Or
            元素名_In = '主刀医生' Or 元素名_In = '助手医生' Or 元素名_In = '麻醉医生' Or 元素名_In = '洗手护士' Or 元素名_In = '巡回护士' Or
            元素名_In = '其他手术人员' Or 元素名_In = '拟行主手术' Or 元素名_In = '拟行附手术' Or 元素名_In = '已行主手术' Or 元素名_In = '已行附手术' Or
            元素名_In = '术前主诊断' Or 元素名_In = '术前次诊断' Or 元素名_In = '术后主诊断' Or 元素名_In = '术后次诊断' Or 元素名_In = '输液总量' Or
            元素名_In = '拟施手术时间' Or 元素名_In = '拟施麻醉方式' Then
      
        --这些要素从手麻子系统中获取
        n_Have := 0;
        Begin
          Select 1 Into n_Have From zlSystems Where Floor(编号 / 100) = 24;
        Exception
          When Others Then
            Null;
        End;
        If n_Have = 1 Then
          If 医嘱id_In Is Null Then
            v_Sql := 'Select Zl24_Replace_Element_Value(:v1,:v2,:v3,:v4,Null) From Dual';
            Begin
              Execute Immediate v_Sql
                Into v_Return
                Using 元素名_In, Trim(To_Char(病人id_In)), Trim(To_Char(就诊id_In)), Trim(To_Char(病人来源_In));
            Exception
              When Others Then
                Null;
            End;
          Else
            v_Sql := 'Select Zl24_Replace_Element_Value(:v1,:v2,:v3,:v4,:v5) From Dual';
            Begin
              Execute Immediate v_Sql
                Into v_Return
                Using 元素名_In, Trim(To_Char(病人id_In)), Trim(To_Char(就诊id_In)), Trim(To_Char(病人来源_In)), Trim(To_Char(医嘱id_In));
            Exception
              When Others Then
                Null;
            End;
          End If;
        End If;
      Else
        v_Sql := 'Select Zl_Replace_Element_Value_User(:v1,:v2,:v3,:v4,:v5,:v6) From Dual';
        Begin
          Execute Immediate v_Sql
            Into v_Return
            Using 元素名_In, 病人id_In, 就诊id_In, 病人来源_In, 医嘱id_In, 婴儿_In;
        Exception
          When Others Then
            Null;
        End;
      End If;
  End Case;
  Return Trim(v_Return);
Exception
  When Others Then
    Return Null;
End Zl_Replace_Element_Value;
/
--106309:蔡青松,2017-03-07,登记标本时保存输入的送检人
Create Or Replace Procedure Zl_病人医嘱发送_Sampleinput
(
  医嘱id      In Varchar2,
  接收人_In   In 病人医嘱发送.接收人%Type := Null,
  接收批次_In In 病人医嘱发送.接收批次%Type := 0,
  人员编号_In In 人员表.编号%Type := Null,
  人员姓名_In In 人员表.姓名%Type := Null,
  送检人_In   In 病人医嘱发送.送检人%Type := Null
) Is
  --未审核的费用行(不包含药品)
  Cursor c_Verify(v_医嘱id In Number) Is
    Select Distinct 记录性质, NO, 序号
    From 住院费用记录
    Where 收费类别 Not In ('5', '6', '7') And 医嘱序号 + 0 = v_医嘱id And 记帐费用 = 1 And 记录状态 = 0 And 价格父号 Is Null And
          (记录性质, NO) In (Select 记录性质, NO
                         From 病人医嘱附费
                         Where 医嘱id = v_医嘱id
                         Union All
                         Select 记录性质, NO
                         From 病人医嘱发送
                         Where 医嘱id In (Select ID From 病人医嘱记录 Where v_医嘱id In (ID, 相关id)))
    Union All
    Select Distinct 记录性质, NO, 序号
    From 门诊费用记录
    Where 收费类别 Not In ('5', '6', '7') And 医嘱序号 + 0 = v_医嘱id And 记帐费用 = 1 And 记录状态 = 0 And 价格父号 Is Null And
          (记录性质, NO) In (Select 记录性质, NO
                         From 病人医嘱附费
                         Where 医嘱id = v_医嘱id
                         Union All
                         Select 记录性质, NO
                         From 病人医嘱发送
                         Where 医嘱id In (Select ID From 病人医嘱记录 Where v_医嘱id In (ID, 相关id)))
    Order By 记录性质, NO, 序号;

  --查找当前标本的相关申请
  Cursor c_Samplequest(v_医嘱id In Number) Is
    Select Distinct ID As 医嘱id, 病人来源 From 病人医嘱记录 Where v_医嘱id In (ID, 相关id);

  v_No   病人医嘱发送.No%Type;
  v_性质 病人医嘱发送.记录性质%Type;
  v_序号 Varchar2(1000);

  v_医嘱id   病人医嘱发送.医嘱id%Type;
  v_相关id   病人医嘱记录.相关id%Type;
  v_费用性质 病人医嘱发送.记录性质%Type;
  v_样本条码 病人医嘱发送.样本条码%Type;
  v_Records  Varchar2(2000);
  v_Currrec  Varchar2(50);
  v_Fields   Varchar2(50);
  v_Count    Number(18);
  v_病人id   病人医嘱记录.病人id%Type;
  v_主页id   病人医嘱记录.主页id%Type;
  v_是否出院 Number; --0=出院,1=在院
  v_记录状态 Number;
  v_病人来源 病人医嘱记录.病人来源%Type;
  v_Date     Date;
  Err_Custom Exception;
  v_Error Varchar2(100);
Begin
  Select Sysdate Into v_Date From Dual;

  v_Records := 医嘱id || '|';

  While v_Records Is Not Null Loop
  
    v_Currrec := Substr(v_Records, 1, Instr(v_Records, '|') - 1);
    v_Fields  := v_Currrec;
    v_医嘱id  := Substr(v_Fields, 1, Instr(v_Fields, ',') - 1);
    v_相关id  := Substr(v_Fields, Instr(v_Fields, ',') + 1);
    If 接收人_In Is Null Then
      Update 病人医嘱发送
      Set 接收人 = Null, 接收时间 = Null, 接收批次 = Null, 送检人 = Null
      Where 医嘱id In (v_医嘱id, v_相关id);
      Update 病人医嘱发送
      Set 执行状态 = Decode(样本条码, Null, 0, 1)
      Where 医嘱id In (Select ID From 病人医嘱记录 Where ID In (v_医嘱id, v_相关id) And 相关id Is Null);
      For r_Samplequest In c_Samplequest(v_相关id) Loop
        If r_Samplequest.病人来源 = 2 Then
          Select Decode(记录性质, 1, 1, Decode(门诊记帐, 1, 1, 2))
          Into v_费用性质
          From 病人医嘱发送
          Where 医嘱id = r_Samplequest.医嘱id;
        Else
          v_费用性质 := 1;
        End If;
        If v_费用性质 = 2 Then
          --2.费用执行处理
          Update 住院费用记录
          Set 执行状态 = 0, 执行时间 = Null, 执行人 = 接收人_In
          Where 收费类别 Not In ('5', '6', '7') And
                (医嘱序号, 记录性质, NO) In
                (Select 医嘱id, 记录性质, NO
                 From 病人医嘱附费
                 Where 医嘱id = r_Samplequest.医嘱id
                 Union All
                 Select 医嘱id, 记录性质, NO
                 From 病人医嘱发送
                 Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = r_Samplequest.医嘱id And 相关id Is Not Null)
                 Union All
                 Select 医嘱id, 记录性质, NO
                 From 病人医嘱发送
                 Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = r_Samplequest.医嘱id And 相关id Is Null) And 采样人 Is Null);
        Else
          Update 门诊费用记录
          Set 执行状态 = 0, 执行时间 = Null, 执行人 = 接收人_In
          Where 收费类别 Not In ('5', '6', '7') And
                (医嘱序号, 记录性质, NO) In
                (Select 医嘱id, 记录性质, NO
                 From 病人医嘱附费
                 Where 医嘱id = r_Samplequest.医嘱id
                 Union All
                 Select 医嘱id, 记录性质, NO
                 From 病人医嘱发送
                 Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = r_Samplequest.医嘱id And 相关id Is Not Null)
                 Union All
                 Select 医嘱id, 记录性质, NO
                 From 病人医嘱发送
                 Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = r_Samplequest.医嘱id And 相关id Is Null) And 采样人 Is Null);
        End If;
      End Loop;
    Else
      --判断是否已出院，如果已出院负不完成登记
      Begin
        If v_主页id Is Null Then
          Select a.病人id, a.主页id, a.病人来源
          Into v_病人id, v_主页id, v_病人来源
          From 病人医嘱记录 A, 病案主页 B
          Where a.病人id = b.病人id And a.主页id = b.主页id(+) And a.Id = v_医嘱id;
        End If;
      Exception
        When Others Then
          v_病人来源 := 1;
      End;
      If v_病人来源 = 2 Then
        If Nvl(v_主页id, 0) > 0 Then
          Select Decode(出院日期, Null, 1, 0)
          Into v_是否出院
          From 病案主页
          Where 病人id = v_病人id And 主页id = v_主页id;
        Else
          v_是否出院 := 0;
        End If;
      
        If v_是否出院 = 0 Then
          --出院的才处理
          Begin
            Select Nvl(记录状态, 0)
            Into v_记录状态
            From 住院费用记录
            Where 医嘱序号 = v_医嘱id And Nvl(记录状态, 0) = 0 And Rownum = 1;
          Exception
            When Others Then
              v_记录状态 := 1;
          End;
        
          Select Nvl(样本条码, 0) Into v_样本条码 From 病人医嘱发送 Where 医嘱id = v_医嘱id;
          If v_样本条码 = 0 Then
            v_Error := '病人已出院不能完成登记!';
            Raise Err_Custom;
          End If;
        
        End If;
      End If;
    
      Update 病人医嘱发送
      Set 接收人 = 接收人_In, 接收时间 = v_Date, 接收批次 = 接收批次_In,  重采标本 = Null, 送检人 = 送检人_In
      Where 医嘱id In (v_医嘱id, v_相关id);
      Update 病人医嘱发送
      Set 执行状态 = 1
      Where 医嘱id In (Select ID From 病人医嘱记录 Where ID In (v_医嘱id, v_相关id) And 相关id Is Null);
      --记帐划价单是否转为记帐单
      --2.检查当前标本相关的申请的相关标本是否完成审核
      For r_Samplequest In c_Samplequest(v_相关id) Loop
        v_Count := 0;
        --r_SampleQuest.医嘱id申请已经完成,处理后续环节
        If v_Count = 0 Then
          If r_Samplequest.病人来源 = 2 Then
            Select Decode(记录性质, 1, 1, Decode(门诊记帐, 1, 1, 2))
            Into v_费用性质
            From 病人医嘱发送
            Where 医嘱id = r_Samplequest.医嘱id;
          Else
            v_费用性质 := 1;
          End If;
          If v_费用性质 = 2 Then
            --2.费用执行处理
            Update 住院费用记录
            Set 执行状态 = 1, 执行时间 = Sysdate, 执行人 = 人员姓名_In
            Where 收费类别 Not In ('5', '6', '7') And
                  (医嘱序号, 记录性质, NO) In
                  (Select 医嘱id, 记录性质, NO
                   From 病人医嘱附费
                   Where 医嘱id = r_Samplequest.医嘱id
                   Union All
                   Select 医嘱id, 记录性质, NO
                   From 病人医嘱发送
                   Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = r_Samplequest.医嘱id And 相关id Is Not Null)
                   Union All
                   Select 医嘱id, 记录性质, NO
                   From 病人医嘱发送
                   Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = r_Samplequest.医嘱id And 相关id Is Null) And 采样人 Is Null);
          Else
            Update 门诊费用记录
            Set 执行状态 = 1, 执行时间 = Sysdate, 执行人 = 人员姓名_In
            Where 收费类别 Not In ('5', '6', '7') And
                  (医嘱序号, 记录性质, NO) In
                  (Select 医嘱id, 记录性质, NO
                   From 病人医嘱附费
                   Where 医嘱id = r_Samplequest.医嘱id
                   Union All
                   Select 医嘱id, 记录性质, NO
                   From 病人医嘱发送
                   Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = r_Samplequest.医嘱id And 相关id Is Not Null)
                   Union All
                   Select 医嘱id, 记录性质, NO
                   From 病人医嘱发送
                   Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = r_Samplequest.医嘱id And 相关id Is Null) And 采样人 Is Null);
          End If;
          --3.自动审核记帐
            For r_Verify In c_Verify(r_Samplequest.医嘱id) Loop
              If r_Verify.No || ',' || r_Verify.记录性质 <> v_No || ',' || v_性质 Then
                If v_序号 Is Not Null Then
                  If v_费用性质 = 1 Then
                    Zl_门诊记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
                  Elsif v_费用性质 = 2 Then
                    Zl_住院记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
                  End If;
                End If;
                v_序号 := Null;
              End If;
              v_No   := r_Verify.No;
              v_性质 := r_Verify.记录性质;
              v_序号 := v_序号 || ',' || r_Verify.序号;
            End Loop;
            If v_序号 Is Not Null Then
              If v_费用性质 = 1 Then
                Zl_门诊记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
              Elsif v_费用性质 = 2 Then
                Zl_住院记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
              End If;
            End If;
        End If;
      End Loop;
    End If;
    v_Records := Substr('|' || v_Records, Length('|' || v_Currrec || '|') + 1);
  End Loop;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人医嘱发送_Sampleinput;
/
--106806:张德婷,2017-03-07,发药按药品id排序
Create Or Replace Procedure Zl1_Autosend As
  v_库房id       药品收发记录.库房id%Type;
  v_自动发药天数 药房配药控制.自动发药天数%Type;

  Intdigit      Number(1);
  Str操作员编号 人员表.编号%Type;
  Str操作员姓名 人员表.姓名%Type;

  Cursor Autosenddepid Is
    Select Nvl(药房id, 0) 药房id, 自动发药天数 From 药房配药控制 Where 门诊 = 2 And Nvl(自动发药天数, 0) > 0;

  Cursor Autosendlist Is
    Select Distinct A.库房id, A.ID, Nvl(A.批次, 0) 批次, C.操作员姓名, a.药品id
    From 药品收发记录 A, 未发药品记录 B, 住院费用记录 C
    Where A.单据 = B.单据 And A.NO = B.NO And A.费用id = C.ID And Nvl(A.库房id, v_库房id) + 0 = Nvl(B.库房id, v_库房id) And
          A.单据 In (9, 10) And Mod(A.记录状态, 3) = 1 And A.审核人 Is Null And Nvl(A.库房id, 0) + 0 = v_库房id And
          B.填制日期 < Sysdate - v_自动发药天数 order by a.药品id;

  v_Autosenddepid Autosenddepid%RowType;
  v_Autosendlist  Autosendlist%RowType;
Begin
  If f_Is_Primary_Node = 0 Then
    Return;
  End If;

  --取操作员编号与姓名
  Select 编号, 姓名
  Into Str操作员编号, Str操作员姓名
  From 人员表 A, 上机人员表 B
  Where A.ID = B.人员id And B.用户名 = User;

  --获取金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into Intdigit From Dual;

  For v_Autosenddepid In Autosenddepid Loop
    v_库房id       := v_Autosenddepid.药房id;
    v_自动发药天数 := v_Autosenddepid.自动发药天数;
    If v_自动发药天数 > 30 Then
      v_自动发药天数 := 30;
    End If;
    For v_Autosendlist In Autosendlist Loop
      Zl_药品收发记录_部门发药(v_Autosendlist.库房id, v_Autosendlist.ID, v_Autosendlist.操作员姓名, Sysdate, v_Autosendlist.批次, 3, Null,
                     Null, Str操作员编号, Str操作员姓名, Intdigit);
      Commit;
    End Loop;
  End Loop;
End Zl1_Autosend;
/

--106806:张德婷,2017-03-07,发药按药品id排序
Create Or Replace Procedure Zl_药品收发记录_更改库房
(
  Partid_In       In 药品收发记录.库房id%Type,
  Bill_In         In 药品收发记录.单据%Type,
  No_In           In 药品收发记录.No%Type,
  Otherstockid_In In 药品收发记录.库房id%Type,
  门诊_In         In Number := 1,
  Date_In         In 药品收发记录.填制日期%Type := Null
) Is
  --重新计算用
  Cursor c_Modifybillout Is
    Select a.Id, a.药品id, a.入出类别id, a.入出系数, a.费用id, Nvl(a.实际数量, 0) * Nvl(a.付数, 1) 数量, Nvl(a.零售金额, 0) 金额, Nvl(a.批次, 0) 批次,
           a.供药单位id, a.成本价, a.零售价, a.批号, a.产地, a.效期, a.生产日期, a.批准文号, c.是否变价, c.类别
    From 药品收发记录 A, 门诊费用记录 B, 收费项目目录 C
    Where a.药品id = c.Id And a.No = No_In And a.单据 = Bill_In And (a.库房id + 0 = Otherstockid_In Or a.库房id Is Null) And
          Nvl(a.摘要, '小宝') <> '拒发' And a.费用id = b.Id And Nvl(b.执行状态, 0) <> 1 And a.审核人 Is Null order by a.药品id;

  Cursor c_Modifybillin Is
    Select a.Id, a.药品id, a.入出类别id, a.入出系数, a.费用id, Nvl(a.实际数量, 0) * Nvl(a.付数, 1) 数量, Nvl(a.零售金额, 0) 金额, Nvl(a.批次, 0) 批次,
           a.供药单位id, a.成本价, a.零售价, a.批号, a.产地, a.效期, a.生产日期, a.批准文号, c.是否变价, c.类别
    From 药品收发记录 A, 住院费用记录 B, 收费项目目录 C
    Where a.药品id = c.Id And a.No = No_In And a.单据 = Bill_In And (a.库房id + 0 = Otherstockid_In Or a.库房id Is Null) And
          Nvl(a.摘要, '小宝') <> '拒发' And a.费用id = b.Id And Nvl(b.执行状态, 0) <> 1 And a.审核人 Is Null order by a.药品id;

  --用于修正病人未结费用
  Cursor c_Billout Is
    Select b.实收金额, b.病人id, 0 主页id, 0 病人病区id, b.病人科室id, b.开单部门id, b.执行部门id, b.收入项目id, b.门诊标志
    From 药品收发记录 A, 门诊费用记录 B
    Where a.费用id = b.Id And Nvl(b.执行状态, 0) <> 1 And a.No = No_In And a.单据 = Bill_In And
          (a.库房id + 0 = Otherstockid_In Or a.库房id Is Null) And Nvl(a.摘要, '小宝') <> '拒发' And a.审核人 Is Null And b.记录性质 = 2 And
          b.记录状态 = 1 order by a.药品id;

  Cursor c_Billin Is
    Select b.实收金额, b.病人id, b.主页id, b.病人病区id, b.病人科室id, b.开单部门id, b.执行部门id, b.收入项目id, b.门诊标志
    From 药品收发记录 A, 住院费用记录 B
    Where a.费用id = b.Id And Nvl(b.执行状态, 0) <> 1 And a.No = No_In And a.单据 = Bill_In And
          (a.库房id + 0 = Otherstockid_In Or a.库房id Is Null) And Nvl(a.摘要, '小宝') <> '拒发' And a.审核人 Is Null And b.记录性质 = 2 And
          b.记录状态 = 1 order by a.药品id;

  r_Modifybillout c_Modifybillout%RowType;
  r_Modifybillin  c_Modifybillin%RowType;
  r_Billout       c_Billout%RowType;
  r_Billin        c_Billin%RowType;
  v_Count         Number;
  n_成本价        药品收发记录.成本价%Type;
  n_零售价        药品收发记录.零售价%Type;
Begin
  --增加原库房的可以库存，减现库房的可用库存
  If 门诊_In = 1 Then
    --处理门诊
    For r_Modifybillout In c_Modifybillout Loop
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) + Nvl(r_Modifybillout.数量, 0)
      Where 库房id + 0 = Otherstockid_In And 药品id = r_Modifybillout.药品id And 性质 = 1 And Nvl(批次, 0) = r_Modifybillout.批次;
    
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) - Nvl(r_Modifybillout.数量, 0)
      Where 库房id + 0 = Partid_In And 药品id = r_Modifybillout.药品id And 性质 = 1 And Nvl(批次, 0) = r_Modifybillout.批次;
    
      If Sql%RowCount = 0 Then
        If r_Modifybillout.成本价 Is Null Then
          n_成本价 := Round(Zl_Fun_Getoutcost(r_Modifybillout.药品id, r_Modifybillout.批次, Partid_In), 7);
        Else
          n_成本价 := r_Modifybillout.成本价;
        End If;
      
        If r_Modifybillout.类别 = '4' Then
          If r_Modifybillout.是否变价 = 1 And r_Modifybillout.批次 > 0 Then
            --卫材时价分批
            n_零售价 := r_Modifybillout.零售价;
          Else
            n_零售价 := Null;
          End If;
        Else
          If r_Modifybillout.是否变价 = 1 Then
            --药品时价
            n_零售价 := r_Modifybillout.零售价;
          Else
            n_零售价 := Null;
          End If;
        End If;
      
        Insert Into 药品库存
          (库房id, 药品id, 批次, 性质, 可用数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次产地, 效期, 上次生产日期, 批准文号, 零售价, 平均成本价)
        Values
          (Partid_In, r_Modifybillout.药品id, r_Modifybillout.批次, 1, 0 - Nvl(r_Modifybillout.数量, 0), 0, 0,
           r_Modifybillout.供药单位id, n_成本价, r_Modifybillout.批号, r_Modifybillout.产地, r_Modifybillout.效期,
           r_Modifybillout.生产日期, r_Modifybillout.批准文号, n_零售价, n_成本价);
      End If;
    End Loop;
  Else
    --处理住院
    For r_Modifybillin In c_Modifybillin Loop
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) + Nvl(r_Modifybillin.数量, 0)
      Where 库房id + 0 = Otherstockid_In And 药品id = r_Modifybillin.药品id And 性质 = 1 And Nvl(批次, 0) = r_Modifybillin.批次;
    
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) - Nvl(r_Modifybillin.数量, 0)
      Where 库房id + 0 = Partid_In And 药品id = r_Modifybillin.药品id And 性质 = 1 And Nvl(批次, 0) = r_Modifybillin.批次;
    
      If Sql%RowCount = 0 Then
        If r_Modifybillin.成本价 Is Null Then
          n_成本价 := Round(Zl_Fun_Getoutcost(r_Modifybillin.药品id, r_Modifybillin.批次, Partid_In), 7);
        Else
          n_成本价 := r_Modifybillin.成本价;
        End If;
      
        If r_Modifybillin.类别 = '4' Then
          If r_Modifybillin.是否变价 = 1 And r_Modifybillin.批次 > 0 Then
            --卫材时价分批
            n_零售价 := r_Modifybillin.零售价;
          Else
            n_零售价 := Null;
          End If;
        Else
          If r_Modifybillin.是否变价 = 1 Then
            --药品时价
            n_零售价 := r_Modifybillin.零售价;
          Else
            n_零售价 := Null;
          End If;
        End If;
      
        Insert Into 药品库存
          (库房id, 药品id, 批次, 性质, 可用数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次产地, 效期, 上次生产日期, 批准文号, 零售价, 平均成本价)
        Values
          (Partid_In, r_Modifybillin.药品id, r_Modifybillin.批次, 1, 0 - Nvl(r_Modifybillin.数量, 0), 0, 0,
           r_Modifybillin.供药单位id, n_成本价, r_Modifybillin.批号, r_Modifybillin.产地, r_Modifybillin.效期, r_Modifybillin.生产日期,
           r_Modifybillin.批准文号, n_零售价, n_成本价);
      End If;
    End Loop;
  End If;

  --处理发其它药房处方情况，改变库房ID
  If 门诊_In = 1 Then
    --处理门诊
    For r_Billout In c_Billout Loop
      --减原库房的未结费用
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) - Nvl(r_Billout.实收金额, 0)
      Where 病人id = r_Billout.病人id And Nvl(主页id, 0) = Nvl(r_Billout.主页id, 0) And
            Nvl(病人病区id, 0) = Nvl(r_Billout.病人病区id, 0) And Nvl(病人科室id, 0) = Nvl(r_Billout.病人科室id, 0) And
            Nvl(开单部门id, 0) = Nvl(r_Billout.开单部门id, 0) And Nvl(执行部门id, 0) = Nvl(r_Billout.执行部门id, 0) And
            收入项目id + 0 = r_Billout.收入项目id And 来源途径 + 0 = r_Billout.门诊标志;
    
      If Sql%RowCount <> 0 Then
        --增加现库房的未结费用
        Update 病人未结费用
        Set 金额 = Nvl(金额, 0) + Nvl(r_Billout.实收金额, 0)
        Where 病人id = r_Billout.病人id And Nvl(主页id, 0) = Nvl(r_Billout.主页id, 0) And
              Nvl(病人病区id, 0) = Nvl(r_Billout.病人病区id, 0) And Nvl(病人科室id, 0) = Nvl(r_Billout.病人科室id, 0) And
              Nvl(开单部门id, 0) = Nvl(r_Billout.开单部门id, 0) And Nvl(执行部门id, 0) = Partid_In And
              收入项目id + 0 = r_Billout.收入项目id And 来源途径 + 0 = r_Billout.门诊标志;
      
        If Sql%RowCount = 0 Then
          Insert Into 病人未结费用
            (病人id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
          Values
            (r_Billout.病人id, r_Billout.病人科室id, r_Billout.开单部门id, Partid_In, r_Billout.收入项目id, r_Billout.门诊标志,
             Nvl(r_Billout.实收金额, 0));
        End If;
      End If;
    End Loop;
  Else
    --处理住院
    For r_Billin In c_Billin Loop
      --减原库房的未结费用
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) - Nvl(r_Billin.实收金额, 0)
      Where 病人id = r_Billin.病人id And Nvl(主页id, 0) = Nvl(r_Billin.主页id, 0) And Nvl(病人病区id, 0) = Nvl(r_Billin.病人病区id, 0) And
            Nvl(病人科室id, 0) = Nvl(r_Billin.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(r_Billin.开单部门id, 0) And
            Nvl(执行部门id, 0) = Nvl(r_Billin.执行部门id, 0) And 收入项目id + 0 = r_Billin.收入项目id And 来源途径 + 0 = r_Billin.门诊标志;
    
      If Sql%RowCount <> 0 Then
        --增加现库房的未结费用
        Update 病人未结费用
        Set 金额 = Nvl(金额, 0) + Nvl(r_Billin.实收金额, 0)
        Where 病人id = r_Billin.病人id And Nvl(主页id, 0) = Nvl(r_Billin.主页id, 0) And
              Nvl(病人病区id, 0) = Nvl(r_Billin.病人病区id, 0) And Nvl(病人科室id, 0) = Nvl(r_Billin.病人科室id, 0) And
              Nvl(开单部门id, 0) = Nvl(r_Billin.开单部门id, 0) And Nvl(执行部门id, 0) = Partid_In And 收入项目id + 0 = r_Billin.收入项目id And
              来源途径 + 0 = r_Billin.门诊标志;
      
        If Sql%RowCount = 0 Then
          Insert Into 病人未结费用
            (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
          Values
            (r_Billin.病人id, r_Billin.主页id, r_Billin.病人病区id, r_Billin.病人科室id, r_Billin.开单部门id, Partid_In,
             r_Billin.收入项目id, r_Billin.门诊标志, Nvl(r_Billin.实收金额, 0));
        End If;
      End If;
    End Loop;
  End If;

  Delete From 病人未结费用 Where 金额 = 0;

  If 门诊_In = 1 Then
    Update 门诊费用记录
    Set 执行部门id = Partid_In
    Where ID In
          (Select Distinct 费用id From 药品收发记录 Where NO = No_In And 单据 = Bill_In And 库房id + 0 = Otherstockid_In);
  Else
    Update 住院费用记录
    Set 执行部门id = Partid_In
    Where ID In
          (Select Distinct 费用id From 药品收发记录 Where NO = No_In And 单据 = Bill_In And 库房id + 0 = Otherstockid_In);
  End If;

  --修改该单据所有记录(退药后再代发的情况)
  Update 药品收发记录 Set 库房id = Partid_In Where NO = No_In And 单据 = Bill_In And 库房id + 0 = Otherstockid_In;

  --修改未发药品记录
  Begin
    Select 1 Into v_Count From 未发药品记录 Where 库房id + 0 = Partid_In And NO = No_In And 单据 = Bill_In;
  Exception
    When Others Then
      v_Count := 0;
  End;

  If v_Count = 0 Then
    Update 未发药品记录 Set 库房id = Partid_In Where NO = No_In And 单据 = Bill_In And 库房id + 0 = Otherstockid_In;
  Else
    Delete 未发药品记录 Where NO = No_In And 单据 = Bill_In And 库房id + 0 = Otherstockid_In;
  End If;

  If Date_In Is Not Null Then
    Delete From 病人费用汇总 Where 日期 >= Date_In;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_更改库房;
/
--106685:余伟节,2017-03-02,解决15位身份证反算出生日期无效的问题
Create Or Replace Procedure Zl_Third_Buildpatient
(
  Patiinfo_In  In Xmltype,
  Patiinfo_Out Out Xmltype
) Is
  -------------------------------------------------------------------------------
  --参数说明:
  -- 入参 Patiinfo_In:
  --<IN>
  --  <ZJH></ZJH>                 //证件号，目前仅支持身份证号
  --  <ZJLX></ZJLX>                       //证件类型(目前仅支持身份证,为空时默认为身份证)
  --  <XM></XM>                       //姓名
  --  <SJH></SJH>                      //手机号
  --</IN>

  --出参 Patiinfo_Out：
  --<OUTPUT>
  --       <BRID></BRID>                //病人ID
  --       <MZH></MZH>                  //门诊号
  --     <ERROR></ERROR>         //如果有错误返回该节点
  --</OUTPUT>
  -------------------------------------------------------------------------------
  n_Pati_Id      病人信息.病人id%Type;
  n_Card_Type_Id 医疗卡类别.Id%Type;
  n_Count        Number(5);
  n_Sum          Number(5);
  v_校验位       Varchar2(50);

  v_姓名         病人信息.姓名%Type;
  v_身份证号     病人信息.身份证号%Type;
  v_手机号       病人信息.家庭电话%Type;
  v_性别         病人信息.性别%Type;
  v_年龄         病人信息.年龄%Type;
  v_操作员       人员表.姓名%Type;
  v_医疗付款方式 病人信息.医疗付款方式%Type;
  n_门诊号       病人信息.门诊号%Type;
  v_证件类型     医疗卡类别.名称%Type;
  v_证件号       病人医疗卡信息.卡号%Type;

  v_Pattern Varchar2(500);
  v_Temp    Varchar2(32767); --临时XML
  v_Err_Msg Varchar2(2000);
  n_存在    Number(2);

  d_出生日期  病人信息.出生日期%Type;
  d_Curr_Time Date;

  Err_Item Exception;
Begin
  Patiinfo_Out := Xmltype('<OUTPUT></OUTPUT>');
  Select Sysdate Into d_Curr_Time From Dual;

  --新建病人：姓名、身份证号、手机号（存在家庭电话中）、出生日期、性别、年龄(后面三项可从身份证中获取)。
  Select Extractvalue(Value(I), 'IN/XM'), Extractvalue(Value(I), 'IN/ZJH'), Extractvalue(Value(I), 'IN/SJH'),
         Extractvalue(Value(I), 'IN/ZJLX')
  Into v_姓名, v_证件号, v_手机号, v_证件类型
  From Table(Xmlsequence(Extract(Patiinfo_In, 'IN'))) I;

  Begin
    If v_证件类型 Is Null Then
      Select 病人id
      Into n_Pati_Id
      From 病人医疗卡信息
      Where 卡号 = v_证件号 And 卡类别id In (Select ID From 医疗卡类别 Where 名称 Like '%身份证%') And Rownum < 2;
    Else
      Select 病人id
      Into n_Pati_Id
      From 病人医疗卡信息
      Where 卡号 = v_证件号 And 卡类别id In (Select ID From 医疗卡类别 Where 名称 = v_证件类型) And Rownum < 2;
    End If;
    n_存在 := 1;
  Exception
    When Others Then
      n_存在 := 0;
  End;

  If Nvl(n_存在, 0) = 1 Then
    v_Temp := '<BRID>' || n_Pati_Id || '</BRID>';
    Select Appendchildxml(Patiinfo_Out, '/OUTPUT', Xmltype(v_Temp)) Into Patiinfo_Out From Dual;
    Select 门诊号 Into n_门诊号 From 病人信息 Where 病人id = n_Pati_Id;
    If n_门诊号 Is Null Then
      n_门诊号 := Nextno(3);
      Update 病人信息 Set 门诊号 = n_门诊号 Where 病人id = n_Pati_Id;
    End If;
    v_Temp := '<MZH>' || n_门诊号 || '</MZH>';
    Select Appendchildxml(Patiinfo_Out, '/OUTPUT', Xmltype(v_Temp)) Into Patiinfo_Out From Dual;
  Else
    If v_姓名 Is Null Then
      v_Err_Msg := '传人姓名为空!';
      Raise Err_Item;
    End If;
    If v_证件类型 Like '%身份证%' Or v_证件类型 Is Null Then
      v_身份证号 := v_证件号;
    Else
      v_Err_Msg := '目前不支持身份证以外的方式建档！';
      Raise Err_Item;
    End If;
  
    If v_身份证号 Is Null Then
      v_Err_Msg := '传人身份证号为空!';
      Raise Err_Item;
    Else
      --身份证合法验证
      v_Pattern := '11,12,13,14,15,21,22,23,31,32,33,34,35,36,37,41,42,43,44,45,46,50,51,52,53,54,61,62,63,64,65,71,81,82,91';
    
      --地区检验
      If Instr(v_Pattern, Substr(v_身份证号, 1, 2)) = 0 Then
        v_Err_Msg := '身份证前两位地区码不正确!';
        Raise Err_Item;
      End If;
      --身份证长度检查
      If Length(v_身份证号) = 15 Then
        --检查身份证号:15位身份证号要求全部为数字
        v_Pattern := '^\d{15}$';
        Select Count(1) Into n_Count From Dual Where Regexp_Like(v_身份证号, v_Pattern);
        If n_Count = 0 Then
          v_Err_Msg := '身份证中包含非法字符，请检查!';
          Raise Err_Item;
        End If;
        --获取性别
        If Mod(To_Number(Substr(v_身份证号, 15, 1)), 2) = 1 Then
          v_性别 := '男';
        Else
          v_性别 := '女';
        End If;
        --出生日期的合法性检查
        d_出生日期 := To_Date('19' || Substr(v_身份证号, 7, 6), 'yyyy-mm-dd');
        v_Pattern  := '^19[0-9]{2}((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|[1-2][0-9]))$';
        Select Count(1) Into n_Count From Dual Where Regexp_Like('19' || Substr(v_身份证号, 7, 6), v_Pattern);
        If n_Count = 0 Then
          v_Err_Msg := '身份证中的出生日期无效，请检查!';
          Raise Err_Item;
        Else
          If d_出生日期 > To_Date(To_Char(d_Curr_Time, 'YYYY-MM-DD'), 'YYYY-MM-dd') Then
            v_Err_Msg := '身份证中的出生日期无效，请检查!';
            Raise Err_Item;
          End If;
        End If;
      Elsif Length(v_身份证号) = 18 Then
        -- 18 位身份证号前17 位全部为数字，最后1位可为数字或x
        v_Pattern := '^\d{17}[0-9Xx]$';
        Select Count(1) Into n_Count From Dual Where Regexp_Like(v_身份证号, v_Pattern);
        If n_Count = 0 Then
          v_Err_Msg := '身份证中包含非法字符!';
          Raise Err_Item;
        End If;
        --获取性别
        If Mod(To_Number(Substr(v_身份证号, 17, 1)), 2) = 1 Then
          v_性别 := '男';
        Else
          v_性别 := '女';
        End If;
        --出生日期的合法性检查
        d_出生日期 := To_Date(Substr(v_身份证号, 7, 8), 'yyyy-mm-dd');
        v_Pattern  := '^(1[6-9]|[2-9][0-9])[0-9]{2}((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|[1-2][0-9]))$';
        Select Count(1) Into n_Count From Dual Where Regexp_Like(Substr(v_身份证号, 7, 8), v_Pattern);
        If n_Count = 0 Then
          v_Err_Msg := '身份证中的出生日期无效，请检查!';
          Raise Err_Item;
        Else
          If d_出生日期 > To_Date(To_Char(d_Curr_Time, 'YYYY-MM-DD'), 'YYYY-MM-dd') Then
            v_Err_Msg := '身份证中的出生日期无效，请检查!';
            Raise Err_Item;
          End If;
          --计算校验位
          n_Sum     := (To_Number(Substr(v_身份证号, 1, 1)) + To_Number(Substr(v_身份证号, 11, 1))) * 7 +
                       (To_Number(Substr(v_身份证号, 2, 1)) + To_Number(Substr(v_身份证号, 12, 1))) * 9 +
                       (To_Number(Substr(v_身份证号, 3, 1)) + To_Number(Substr(v_身份证号, 13, 1))) * 10 +
                       (To_Number(Substr(v_身份证号, 4, 1)) + To_Number(Substr(v_身份证号, 14, 1))) * 5 +
                       (To_Number(Substr(v_身份证号, 5, 1)) + To_Number(Substr(v_身份证号, 15, 1))) * 8 +
                       (To_Number(Substr(v_身份证号, 6, 1)) + To_Number(Substr(v_身份证号, 16, 1))) * 4 +
                       (To_Number(Substr(v_身份证号, 7, 1)) + To_Number(Substr(v_身份证号, 17, 1))) * 2 +
                       To_Number(Substr(v_身份证号, 8, 1)) * 1 + To_Number(Substr(v_身份证号, 9, 1)) * 6 +
                       To_Number(Substr(v_身份证号, 10, 1)) * 3;
          n_Count   := Mod(n_Sum, 11);
          v_Pattern := '10X98765432';
          v_校验位  := Substr(v_Pattern, n_Count + 1, 1);
          If v_校验位 <> Upper(Substr(v_身份证号, 18, 1)) Then
            v_Err_Msg := '身份证号码不正确，请检查。';
            Raise Err_Item;
          End If;
        End If;
      Else
        v_Err_Msg := '身份证长度不对,请检查。';
        Raise Err_Item;
      End If;
    
      If Nvl(v_年龄, '_') = '_' Then
        v_年龄 := Zl_Age_Calc(0, d_出生日期, d_Curr_Time);
      End If;
    End If;
  
    Select 名称 Into v_医疗付款方式 From 医疗付款方式 Where 缺省标志 = 1;
    n_Pati_Id := Nextno(1);
    n_门诊号  := Nextno(3);
    Insert Into 病人信息
      (病人id, 姓名, 身份证号, 家庭电话, 出生日期, 性别, 年龄, 登记时间, 门诊号, 医疗付款方式)
      Select n_Pati_Id, v_姓名, v_身份证号, v_手机号, d_出生日期, v_性别, v_年龄, d_Curr_Time, n_门诊号, v_医疗付款方式
      From Dual;
  
    --病人信息保存完后，完成医疗卡绑定（二代身份证卡类别的绑定）
    Begin
      If v_证件类型 Is Null Then
        Select ID Into n_Card_Type_Id From 医疗卡类别 Where 名称 Like '%身份证%' And Rownum < 2;
      Else
        Select ID Into n_Card_Type_Id From 医疗卡类别 Where 名称 = v_证件类型 And Rownum < 2;
      End If;
    Exception
      When No_Data_Found Then
        v_Err_Msg := '身份证卡类别不存在！';
        Raise Err_Item;
    End;
    Select b.姓名 Into v_操作员 From 上机人员表 A, 人员表 B Where a.人员id = b.Id And a.用户名 = User;
  
    Zl_医疗卡变动_Insert(11, n_Pati_Id, n_Card_Type_Id, Null, v_身份证号, '创建虚拟卡', Null, v_操作员, d_Curr_Time);
  
    v_Temp := '<BRID>' || n_Pati_Id || '</BRID>';
    Select Appendchildxml(Patiinfo_Out, '/OUTPUT', Xmltype(v_Temp)) Into Patiinfo_Out From Dual;
    v_Temp := '<MZH>' || n_门诊号 || '</MZH>';
    Select Appendchildxml(Patiinfo_Out, '/OUTPUT', Xmltype(v_Temp)) Into Patiinfo_Out From Dual;
  End If;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Buildpatient;
/

--102791:刘尔旋,2017-03-01,批量换号诊室
Create Or Replace Procedure Zl_病人挂号记录_批量换号
(
  Nos_In        In Varchar2 := Null,
  新号别_In     In 病人挂号记录.号别%Type := Null,
  新医生姓名_In In 挂号安排.医生姓名%Type := Null,
  新医生id_In   In 挂号安排.医生id%Type := Null,
  新科室id_In   In 挂号安排.科室id%Type := Null,
  原医生姓名_In In 挂号安排.医生姓名%Type := Null,
  原医生id_In   In 挂号安排.医生id%Type := Null,
  原号别_In     In 病人挂号记录.号别%Type := Null,
  操作员姓名_In In 挂号序号状态.操作员姓名%Type := Null,
  原出诊id_In   In 临床出诊记录.Id%Type := Null,
  新出诊id_In   In 临床出诊记录.Id%Type := Null
  --功能: 完成病人批量换号功能,在挂号项目相同,限号数相同,限约数相同,科室相同的情况下。
  --参数说明:  Nos_In :需要跟换排班的病人挂号记录单据集:格式: M000001|M000002|..........
) As
  --获取对应挂号记录的门诊费用记录信息
  Cursor c_Bill(c_No 病人挂号记录.No%Type) Is
    Select ID, 序号, NO, 发生时间, 执行部门id, 收费细目id, 计算单位
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 In (0, 1) And NO = c_No
    Order By 序号;
  --获取相应排班的分诊诊室
  Cursor c_平均分诊(c_指定分诊号表id 挂号安排.Id%Type) Is
    Select 号表id, 门诊诊室, 当前分配 From 挂号安排诊室 Where 号表id = c_指定分诊号表id;
  Cursor c_出诊平均分诊 Is
    Select 记录id, 诊室id, 当前分配 From 临床出诊诊室记录 Where 记录id = 新出诊id_In;

  --变量定义
  r_平均分诊         挂号安排诊室%RowType;
  r_出诊平均分诊     临床出诊诊室记录%RowType;
  r_Bill             c_Bill%RowType;
  v_Nos              Varchar(2000);
  v_No               病人挂号记录.No%Type;
  n_病人id           病人挂号记录.病人id%Type;
  n_原序号           病人挂号记录.号序%Type;
  d_原就诊日期       病人挂号记录.预约时间%Type;
  n_是否已被挂出     Number(1);
  n_记录性质         Number(1);
  n_预约             Number(1);
  n_挂号状态         Number(1); --0-正常挂号:1-预约挂号;2-预约挂号接收
  v_新就诊诊室       病人信息.就诊诊室%Type;
  n_分诊方式         Number(1); --0-不分诊:1-指定分诊:2-动态分诊:3-平均分诊
  n_指定分诊号表id   Number(10);
  n_分诊诊室数量     Number(3);
  n_是否找到分诊诊室 Number(1); --0:未找到:1-找到但分配标识未更改:2-修改第一条数据标识
  n_Index            Number(1); --当前记录集的索引值
  v_现队列名称       排队叫号队列.队列名称%Type;
  n_挂号生成队列     Number;
  n_预约生成队列     Number;
  v_排队号码         排队叫号队列.排队号码%Type;
  n_业务id           病人挂号记录.Id%Type;
  v_Temp             Varchar2(500);
  v_操作员编号       就诊变动记录.操作员编号%Type;
  v_操作员姓名       就诊变动记录.操作员姓名%Type;
  n_医生id           人员表.Id%Type;
  v_Error            Varchar2(255);
  n_出诊记录id       临床出诊记录.Id%Type;
  Err_Custom Exception;
Begin
  If 原出诊id_In Is Null Then
    --计划排班模式
    --检查是否存在该挂号记录
    If Nos_In Is Not Null Then
      v_Nos := Nos_In || '|';
      While v_Nos Is Not Null Loop
        --初始化变量
        n_病人id           := 0;
        n_原序号           := 0;
        d_原就诊日期       := Null;
        n_是否已被挂出     := 0;
        n_记录性质         := 0;
        n_预约             := 0;
        n_挂号状态         := 0;
        v_新就诊诊室       := '';
        n_分诊方式         := 0;
        n_指定分诊号表id   := 0;
        v_现队列名称       := '';
        v_排队号码         := '';
        n_业务id           := 0;
        n_分诊诊室数量     := 0;
        n_挂号生成队列     := 0;
        n_预约生成队列     := 0;
        n_是否找到分诊诊室 := 0;
        n_Index            := 0;
      
        v_No  := Substr(v_Nos, 1, Instr(v_Nos, '|') - 1);
        v_Nos := Substr(v_Nos, Instr(v_Nos, '|') + 1);
        --检查是否存在该挂号记录
        Begin
          Select a.Id, a.病人id, a.号序, Nvl(b.日期, Nvl(a.预约时间, a.发生时间)), a.记录性质, Nvl(a.预约, 0)
          Into n_业务id, n_病人id, n_原序号, d_原就诊日期, n_记录性质, n_预约
          From 病人挂号记录 A, 挂号序号状态 B
          Where NO = v_No And 记录性质 In (1, 2) And 记录状态 = 1 And a.号别 = b.号码(+) And
                Trunc(Nvl(预约时间, 发生时间)) = Trunc(b.日期(+)) And a.号序 = b.序号(+);
        Exception
          When Others Then
            Null;
        End;
        If n_病人id = 0 Then
          v_Error := '没有找到病人的挂号信息';
          Raise Err_Custom;
        End If;
        --判断当前挂号状态
        n_挂号状态 := 0; --正常挂号
        If n_记录性质 = 1 And n_预约 = 1 Then
          n_挂号状态 := 2; --预约接收
        End If;
        If n_记录性质 = 2 And n_预约 = 1 Then
          n_挂号状态 := 1; --预约
        End If;
      
        --检查换号的新号别是否已被挂出
        Begin
          Select a.状态
          Into n_是否已被挂出
          From 挂号序号状态 A
          Where a.日期 = d_原就诊日期 And a.号码 = 新号别_In And a.序号 = n_原序号;
        Exception
          When Others Then
            n_是否已被挂出 := 0;
        End;
        If n_是否已被挂出 > 0 Then
          v_Error := '要换的号别已被挂出';
          Raise Err_Custom;
        End If;
        --预约接收的情况下进行分诊诊室的获取
        If n_挂号状态 = 2 Then
          --获取新号别诊室
          --说明:预约的情况下，不需要分诊，因此不用获取就诊诊室
          --     接收的情况下,需要进行分诊,因此需要获取接诊诊室
          --获取分诊方式
          Begin
            Select ID, Nvl(分诊方式, 0) Into n_指定分诊号表id, n_分诊方式 From 挂号安排 Where 号码 = 新号别_In;
          Exception
            When Others Then
              n_分诊方式       := 0;
              n_指定分诊号表id := 0;
          End;
        
          Begin
            If n_分诊方式 = 0 Then
              --不分诊
              v_新就诊诊室 := '';
            End If;
            If n_分诊方式 = 1 Then
              --指定分诊
              Select 门诊诊室 Into v_新就诊诊室 From 挂号安排诊室 Where 号表id = n_指定分诊号表id;
            End If;
            If n_分诊方式 = 2 Then
              --动态分诊
              Select 门诊诊室
              Into v_新就诊诊室
              From (Select 门诊诊室, Sum(Num) As Num
                     From (Select 门诊诊室, 0 As Num
                            From 挂号安排诊室
                            Where 号表id = n_指定分诊号表id
                            Union All
                            Select 诊室, Count(诊室) As Num
                            From 病人挂号记录
                            Where Nvl(执行状态, 0) = 0 And 记录性质 = 1 And 记录状态 = 1 And 发生时间 Between Trunc(Sysdate) And Sysdate And
                                  号别 = 新号别_In And 诊室 In (Select 门诊诊室 From 挂号安排诊室 Where 号表id = n_指定分诊号表id)
                            Group By 诊室)
                     Group By 门诊诊室
                     Order By Num)
              Where Rownum = 1;
            End If;
            If n_分诊方式 = 3 Then
              --平均分诊
              --获取当前安排下的诊室数量
              Select Count(1) Into n_分诊诊室数量 From 挂号安排诊室 Where 号表id = n_指定分诊号表id;
            
              Open c_平均分诊(n_指定分诊号表id);
              Loop
                Fetch c_平均分诊
                  Into r_平均分诊;
                Exit When c_平均分诊%NotFound;
                n_Index := n_Index + 1;
                --找到了对应的分诊诊室,需要修改下一个诊室的当前分配为1(代表该诊室是下一次的分诊诊室)
                If n_是否找到分诊诊室 = 1 Then
                  Update 挂号安排诊室
                  Set 当前分配 = 1
                  Where 号表id = r_平均分诊.号表id And 门诊诊室 = r_平均分诊.门诊诊室;
                  Exit;
                End If;
              
                If Nvl(r_平均分诊.当前分配, 0) = 1 Then
                  v_新就诊诊室 := r_平均分诊.门诊诊室;
                  Update 挂号安排诊室
                  Set 当前分配 = 0
                  Where 号表id = r_平均分诊.号表id And 门诊诊室 = r_平均分诊.门诊诊室;
                  n_是否找到分诊诊室 := 1;
                End If;
              
                If n_分诊诊室数量 = 1 And n_是否找到分诊诊室 = 1 Then
                  n_是否找到分诊诊室 := 2;
                  Exit;
                End If;
                If n_分诊诊室数量 > 1 And n_是否找到分诊诊室 = 1 Then
                  --游标已经到了最后,所以需从第一条数据开始修改标识
                  If n_Index >= n_分诊诊室数量 Then
                    n_是否找到分诊诊室 := 2;
                    Exit;
                  End If;
                End If;
              End Loop;
              Close c_平均分诊;
              --重置索引值
              n_Index := 0;
              --第一次分诊
              If Nvl(v_新就诊诊室, ' ') = ' ' Or v_新就诊诊室 Is Null Then
                Open c_平均分诊(n_指定分诊号表id);
                Loop
                  Fetch c_平均分诊
                    Into r_平均分诊;
                  Exit When c_平均分诊%NotFound;
                  n_Index := n_Index + 1;
                
                  If n_是否找到分诊诊室 = 1 Then
                    Update 挂号安排诊室
                    Set 当前分配 = 1
                    Where 号表id = r_平均分诊.号表id And 门诊诊室 = r_平均分诊.门诊诊室;
                    Exit;
                  End If;
                
                  Update 挂号安排诊室
                  Set 当前分配 = 0
                  Where 号表id = r_平均分诊.号表id And 门诊诊室 = r_平均分诊.门诊诊室;
                  v_新就诊诊室 := r_平均分诊.门诊诊室;
                
                  n_是否找到分诊诊室 := 1;
                  If n_分诊诊室数量 = 1 And n_是否找到分诊诊室 = 1 Then
                    n_是否找到分诊诊室 := 2;
                    Exit;
                  End If;
                
                  If n_分诊诊室数量 > 1 And n_是否找到分诊诊室 = 1 Then
                    --游标已经到了最后,所以需从第一条数据开始修改标识
                    If n_Index >= n_分诊诊室数量 Then
                      n_是否找到分诊诊室 := 2;
                      Exit;
                    End If;
                  End If;
                
                End Loop;
                Close c_平均分诊;
              End If;
            
              If n_是否找到分诊诊室 = 2 Then
                Open c_平均分诊(n_指定分诊号表id);
                Loop
                  Fetch c_平均分诊
                    Into r_平均分诊;
                  Exit When c_平均分诊%NotFound;
                  Update 挂号安排诊室
                  Set 当前分配 = 1
                  Where 号表id = r_平均分诊.号表id And 门诊诊室 = r_平均分诊.门诊诊室;
                  Exit;
                End Loop;
                Close c_平均分诊;
              End If;
            End If;
          Exception
            When Others Then
              v_新就诊诊室 := '';
          End;
        End If;
      
        --更新病人信息的就诊诊室和状态
        Update 病人信息 Set 就诊诊室 = v_新就诊诊室, 就诊状态 = 1 Where 病人id = n_病人id And 就诊状态 In (1, 2);
      
        --打开游标
        Open c_Bill(v_No);
        Loop
          Fetch c_Bill
            Into r_Bill;
          Exit When c_Bill%NotFound;
          If r_Bill.序号 = 1 Then
            --需要确定是否预约挂号
            --1.如果是预约挂号产生的挂号记录,则需要减已约数
            --2.如果是预约挂号为接收的挂号记录,则需要减已挂数和其中已接收数
            --3.如果是正常挂号,则只减已挂数
            --恢复以前的挂号汇总
            Update 病人挂号汇总
            Set 已挂数 = Nvl(已挂数, 0) + Decode(n_挂号状态, 0, -1, 2, -1, 0), 其中已接收 = Nvl(其中已接收, 0) + Decode(n_挂号状态, 2, -1, 0),
                已约数 = Nvl(已约数, 0) + Decode(n_挂号状态, 0, 0, -1)
            Where 日期 = Trunc(r_Bill.发生时间) And Nvl(科室id, 0) = Nvl(r_Bill.执行部门id, 0) And
                  Nvl(项目id, 0) = Nvl(r_Bill.收费细目id, 0) And (号码 = r_Bill.计算单位 Or 号码 Is Null);
            If Sql%RowCount = 0 Then
              Insert Into 病人挂号汇总
                (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 已约数, 其中已接收)
              Values
                (Trunc(r_Bill.发生时间), r_Bill.执行部门id, r_Bill.收费细目id, 原医生姓名_In, Decode(原医生id_In, 0, Null, 原医生id_In),
                 r_Bill.计算单位, 0, 0, 0);
            End If;
          
            ----然后再更新挂号汇总
            Update 病人挂号汇总
            Set 已挂数 = Nvl(已挂数, 0) + Decode(n_挂号状态, 0, 1, 2, 1, 0), 其中已接收 = Nvl(其中已接收, 0) + Decode(n_挂号状态, 2, 1, 0),
                已约数 = Nvl(已约数, 0) + Decode(n_挂号状态, 0, 0, 1)
            Where 日期 = Trunc(r_Bill.发生时间) And Nvl(科室id, 0) = 新科室id_In And Nvl(项目id, 0) = Nvl(r_Bill.收费细目id, 0) And
                 
                  (号码 = 新号别_In Or 号码 Is Null);
            If Sql%RowCount = 0 Then
              Insert Into 病人挂号汇总
                (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 已约数, 其中已接收)
              Values
                (Trunc(r_Bill.发生时间), 新科室id_In, r_Bill.收费细目id, 新医生姓名_In, Decode(新医生id_In, 0, Null, 新医生id_In), 新号别_In,
                 Decode(n_挂号状态, 0, 1, 2, 1, 0), Decode(n_挂号状态, 0, 0, 1), Decode(n_挂号状态, 2, 1, 0));
            End If;
          End If;
        
          ---更新挂号记录
          If n_挂号状态 = 1 Then
            --预约
            Update 门诊费用记录
            Set 执行部门id = 新科室id_In, 病人科室id = 新科室id_In, 计算单位 = 新号别_In, 发药窗口 = n_原序号,
                --病人病区id = 科室id_In,
                执行人 = 新医生姓名_In, 执行状态 = 0, 执行时间 = Null
            Where ID = r_Bill.Id;
          Else
            --挂号或接收
            Update 门诊费用记录
            Set 执行部门id = 新科室id_In, 病人科室id = 新科室id_In, 计算单位 = 新号别_In, 发药窗口 = v_新就诊诊室,
                --病人病区id = 科室id_In,
                执行人 = 新医生姓名_In, 执行状态 = 0, 执行时间 = Null
            Where ID = r_Bill.Id;
          End If;
        
          --更新病人挂号记录
          If r_Bill.序号 = 1 Then
            v_Temp := Zl_Identity(1);
            Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_Temp From Dual;
            Select Substr(v_Temp, 0, Instr(v_Temp, ',') - 1) Into v_操作员编号 From Dual;
            Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_操作员姓名 From Dual;
            Begin
              Select ID Into n_医生id From 人员表 Where 姓名 = 新医生姓名_In And Rownum < 2;
            Exception
              When Others Then
                n_医生id := Null;
            End;
            Zl_就诊变动记录_Insert(r_Bill.No, 1, '批量换号', v_操作员姓名, v_操作员编号, 新号别_In, 新科室id_In, Null, n_医生id, 新医生姓名_In, v_新就诊诊室,
                             n_原序号, Null);
            --修改队列信息
            Update 排队叫号队列
            Set 医生姓名 = 新医生姓名_In, 诊室 = v_新就诊诊室
            Where 业务id = n_业务id And 业务类型 = 0;
          
            Update 病人挂号记录
            Set 执行部门id = 新科室id_In, 号别 = 新号别_In, 诊室 = v_新就诊诊室, 执行人 = 新医生姓名_In, 执行状态 = 0, 执行时间 = Null, 号序 = n_原序号
            Where NO = r_Bill.No;
            --修改挂号序号状态
            If n_原序号 Is Not Null Then
              --1.恢复以前挂号序号状态
              Delete 挂号序号状态 Where 日期 = d_原就诊日期 And 序号 = n_原序号 And 号码 = 原号别_In;
              --2.新增换号后挂号序号状态
              Insert Into 挂号序号状态
                (号码, 日期, 序号, 操作员姓名, 状态, 预约, 登记时间)
              Values
                (新号别_In, d_原就诊日期, n_原序号, 操作员姓名_In, Decode(n_挂号状态, 1, 2, 1), Decode(n_挂号状态, 0, 0, 1), Sysdate);
            End If;
          End If;
        End Loop;
        Close c_Bill;
      End Loop;
    End If;
  Else
    --出诊表排班模式
    --检查是否存在该挂号记录
    If Nos_In Is Not Null Then
      v_Nos := Nos_In || '|';
      While v_Nos Is Not Null Loop
        --初始化变量
        n_病人id           := 0;
        n_原序号           := 0;
        d_原就诊日期       := Null;
        n_是否已被挂出     := 0;
        n_记录性质         := 0;
        n_预约             := 0;
        n_挂号状态         := 0;
        v_新就诊诊室       := '';
        n_分诊方式         := 0;
        n_指定分诊号表id   := 0;
        v_现队列名称       := '';
        v_排队号码         := '';
        n_业务id           := 0;
        n_分诊诊室数量     := 0;
        n_挂号生成队列     := 0;
        n_预约生成队列     := 0;
        n_是否找到分诊诊室 := 0;
        n_Index            := 0;
      
        v_No  := Substr(v_Nos, 1, Instr(v_Nos, '|') - 1);
        v_Nos := Substr(v_Nos, Instr(v_Nos, '|') + 1);
        --检查是否存在该挂号记录
        Begin
          Select a.Id, a.病人id, a.号序, Nvl(b.开始时间, Nvl(a.预约时间, a.发生时间)), a.记录性质, Nvl(a.预约, 0), a.出诊记录id
          Into n_业务id, n_病人id, n_原序号, d_原就诊日期, n_记录性质, n_预约, n_出诊记录id
          From 病人挂号记录 A, 临床出诊序号控制 B
          Where NO = v_No And 记录性质 In (1, 2) And 记录状态 = 1 And a.号序 = b.序号(+) And a.出诊记录id = b.记录id(+);
        Exception
          When Others Then
            Null;
        End;
        If n_病人id = 0 Then
          v_Error := '没有找到病人的挂号信息';
          Raise Err_Custom;
        End If;
        --判断当前挂号状态
        n_挂号状态 := 0; --正常挂号
        If n_记录性质 = 1 And n_预约 = 1 Then
          n_挂号状态 := 2; --预约接收
        End If;
        If n_记录性质 = 2 And n_预约 = 1 Then
          n_挂号状态 := 1; --预约
        End If;
      
        --检查换号的新号别是否已被挂出
        Begin
          Select a.挂号状态
          Into n_是否已被挂出
          From 临床出诊序号控制 A
          Where a.记录id = 新出诊id_In And a.序号 = n_原序号;
        Exception
          When Others Then
            n_是否已被挂出 := 0;
        End;
        If n_是否已被挂出 > 0 Then
          v_Error := '要换的号别已被挂出';
          Raise Err_Custom;
        End If;
        --预约接收的情况下进行分诊诊室的获取
        If n_挂号状态 = 2 Then
          --获取新号别诊室
          --说明:预约的情况下，不需要分诊，因此不用获取就诊诊室
          --     接收的情况下,需要进行分诊,因此需要获取接诊诊室
          --获取分诊方式
          Begin
            Select Nvl(分诊方式, 0) Into n_分诊方式 From 临床出诊记录 Where ID = 新出诊id_In;
          Exception
            When Others Then
              n_分诊方式 := 0;
          End;
        
          Begin
            If n_分诊方式 = 0 Then
              --不分诊
              v_新就诊诊室 := '';
            End If;
            If n_分诊方式 = 1 Then
              --指定分诊
              Select b.名称
              Into v_新就诊诊室
              From 临床出诊诊室记录 A, 门诊诊室 B
              Where a.诊室id = b.Id And a.记录id = 新出诊id_In;
            End If;
            If n_分诊方式 = 2 Then
              --动态分诊
              Select 门诊诊室
              Into v_新就诊诊室
              From (Select 门诊诊室, Sum(Num) As Num
                     From (Select b.名称 As 门诊诊室, 0 As Num
                            From 临床出诊诊室记录 A, 门诊诊室 B
                            Where a.记录id = 新出诊id_In
                            Union All
                            Select 诊室, Count(诊室) As Num
                            From 病人挂号记录
                            Where Nvl(执行状态, 0) = 0 And 记录性质 = 1 And 记录状态 = 1 And 发生时间 Between Trunc(Sysdate) And Sysdate And
                                  号别 = 新号别_In And 诊室 In (Select b.名称
                                                         From 临床出诊诊室记录 A, 门诊诊室 B
                                                         Where a.诊室id = b.Id And a.记录id = 新出诊id_In)
                            Group By 诊室)
                     Group By 门诊诊室
                     Order By Num)
              Where Rownum = 1;
            End If;
            If n_分诊方式 = 3 Then
              --平均分诊
              --获取当前安排下的诊室数量
              Select Count(1) Into n_分诊诊室数量 From 临床出诊诊室记录 Where 记录id = 新出诊id_In;
            
              Open c_出诊平均分诊;
              Loop
                Fetch c_出诊平均分诊
                  Into r_出诊平均分诊;
                Exit When c_出诊平均分诊%NotFound;
                n_Index := n_Index + 1;
                --找到了对应的分诊诊室,需要修改下一个诊室的当前分配为1(代表该诊室是下一次的分诊诊室)
                If n_是否找到分诊诊室 = 1 Then
                  Update 临床出诊诊室记录
                  Set 当前分配 = 1
                  Where 记录id = r_出诊平均分诊.记录id And 诊室id = r_出诊平均分诊.诊室id;
                  Exit;
                End If;
              
                If Nvl(r_平均分诊.当前分配, 0) = 1 Then
                  v_新就诊诊室 := r_平均分诊.门诊诊室;
                  Update 临床出诊诊室记录
                  Set 当前分配 = 0
                  Where 记录id = r_出诊平均分诊.记录id And 诊室id = r_出诊平均分诊.诊室id;
                  n_是否找到分诊诊室 := 1;
                End If;
              
                If n_分诊诊室数量 = 1 And n_是否找到分诊诊室 = 1 Then
                  n_是否找到分诊诊室 := 2;
                  Exit;
                End If;
                If n_分诊诊室数量 > 1 And n_是否找到分诊诊室 = 1 Then
                  --游标已经到了最后,所以需从第一条数据开始修改标识
                  If n_Index >= n_分诊诊室数量 Then
                    n_是否找到分诊诊室 := 2;
                    Exit;
                  End If;
                End If;
              End Loop;
              Close c_出诊平均分诊;
              --重置索引值
              n_Index := 0;
              --第一次分诊
              If Nvl(v_新就诊诊室, ' ') = ' ' Or v_新就诊诊室 Is Null Then
                Open c_出诊平均分诊;
                Loop
                  Fetch c_出诊平均分诊
                    Into r_出诊平均分诊;
                  Exit When c_出诊平均分诊%NotFound;
                  n_Index := n_Index + 1;
                
                  If n_是否找到分诊诊室 = 1 Then
                    Update 临床出诊诊室记录
                    Set 当前分配 = 1
                    Where 记录id = r_出诊平均分诊.记录id And 诊室id = r_出诊平均分诊.诊室id;
                    Exit;
                  End If;
                
                  Update 临床出诊诊室记录
                  Set 当前分配 = 0
                  Where 记录id = r_出诊平均分诊.记录id And 诊室id = r_出诊平均分诊.诊室id;
                  v_新就诊诊室 := r_出诊平均分诊.诊室id;
                
                  n_是否找到分诊诊室 := 1;
                  If n_分诊诊室数量 = 1 And n_是否找到分诊诊室 = 1 Then
                    n_是否找到分诊诊室 := 2;
                    Exit;
                  End If;
                
                  If n_分诊诊室数量 > 1 And n_是否找到分诊诊室 = 1 Then
                    --游标已经到了最后,所以需从第一条数据开始修改标识
                    If n_Index >= n_分诊诊室数量 Then
                      n_是否找到分诊诊室 := 2;
                      Exit;
                    End If;
                  End If;
                
                End Loop;
                Close c_出诊平均分诊;
              End If;
            
              If n_是否找到分诊诊室 = 2 Then
                Open c_出诊平均分诊;
                Loop
                  Fetch c_出诊平均分诊
                    Into r_出诊平均分诊;
                  Exit When c_出诊平均分诊%NotFound;
                  Update 临床出诊诊室记录
                  Set 当前分配 = 1
                  Where 记录id = r_出诊平均分诊.记录id And 诊室id = r_出诊平均分诊.诊室id;
                  Exit;
                End Loop;
                Close c_出诊平均分诊;
              End If;
            End If;
          Exception
            When Others Then
              v_新就诊诊室 := '';
          End;
        End If;
      
        --更新病人信息的就诊诊室和状态
        Update 病人信息 Set 就诊诊室 = v_新就诊诊室, 就诊状态 = 1 Where 病人id = n_病人id And 就诊状态 In (1, 2);
      
        --打开游标
        Open c_Bill(v_No);
        Loop
          Fetch c_Bill
            Into r_Bill;
          Exit When c_Bill%NotFound;
          If r_Bill.序号 = 1 Then
            --需要确定是否预约挂号
            --1.如果是预约挂号产生的挂号记录,则需要减已约数
            --2.如果是预约挂号为接收的挂号记录,则需要减已挂数和其中已接收数
            --3.如果是正常挂号,则只减已挂数
            --恢复以前的挂号汇总
            Update 病人挂号汇总
            Set 已挂数 = Nvl(已挂数, 0) + Decode(n_挂号状态, 0, -1, 2, -1, 0), 其中已接收 = Nvl(其中已接收, 0) + Decode(n_挂号状态, 2, -1, 0),
                已约数 = Nvl(已约数, 0) + Decode(n_挂号状态, 0, 0, -1)
            Where 日期 = Trunc(r_Bill.发生时间) And Nvl(医生id, 0) = Nvl(原医生id_In, 0) And Nvl(医生姓名, '-') = Nvl(原医生姓名_In, '-') And
                  Nvl(科室id, 0) = Nvl(r_Bill.执行部门id, 0) And Nvl(项目id, 0) = Nvl(r_Bill.收费细目id, 0) And
                  (号码 = r_Bill.计算单位 Or 号码 Is Null);
            If Sql%RowCount = 0 Then
              Insert Into 病人挂号汇总
                (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 已约数, 其中已接收)
              Values
                (Trunc(r_Bill.发生时间), r_Bill.执行部门id, r_Bill.收费细目id, 原医生姓名_In, Decode(原医生id_In, 0, Null, 原医生id_In),
                 r_Bill.计算单位, 0, 0, 0);
            End If;
          
            Update 临床出诊记录
            Set 已挂数 = Nvl(已挂数, 0) + Decode(n_挂号状态, 0, -1, 2, -1, 0), 其中已接收 = Nvl(其中已接收, 0) + Decode(n_挂号状态, 2, -1, 0),
                已约数 = Nvl(已约数, 0) + Decode(n_挂号状态, 0, 0, -1)
            Where ID = 原出诊id_In;
          
            ----然后再更新挂号汇总
            Update 病人挂号汇总
            Set 已挂数 = Nvl(已挂数, 0) + Decode(n_挂号状态, 0, 1, 2, 1, 0), 其中已接收 = Nvl(其中已接收, 0) + Decode(n_挂号状态, 2, 1, 0),
                已约数 = Nvl(已约数, 0) + Decode(n_挂号状态, 0, 0, 1)
            Where 日期 = Trunc(r_Bill.发生时间) And Nvl(医生id, 0) = Nvl(新医生id_In, 0) And Nvl(医生姓名, '-') = Nvl(新医生姓名_In, '-') And
                  Nvl(科室id, 0) = 新科室id_In And Nvl(项目id, 0) = Nvl(r_Bill.收费细目id, 0) And (号码 = 新号别_In Or 号码 Is Null);
            If Sql%RowCount = 0 Then
              Insert Into 病人挂号汇总
                (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 已约数, 其中已接收)
              Values
                (Trunc(r_Bill.发生时间), 新科室id_In, r_Bill.收费细目id, 新医生姓名_In, Decode(新医生id_In, 0, Null, 新医生id_In), 新号别_In,
                 Decode(n_挂号状态, 0, 1, 2, 1, 0), Decode(n_挂号状态, 0, 0, 1), Decode(n_挂号状态, 2, 1, 0));
            End If;
            Update 临床出诊记录
            Set 已挂数 = Nvl(已挂数, 0) + Decode(n_挂号状态, 0, 1, 2, 1, 0), 其中已接收 = Nvl(其中已接收, 0) + Decode(n_挂号状态, 2, 1, 0),
                已约数 = Nvl(已约数, 0) + Decode(n_挂号状态, 0, 0, 1)
            Where ID = 新出诊id_In;
          End If;
        
          ---更新挂号记录
          If n_挂号状态 = 1 Then
            --预约
            Update 门诊费用记录
            Set 执行部门id = 新科室id_In, 病人科室id = 新科室id_In, 计算单位 = 新号别_In, 发药窗口 = n_原序号,
                --病人病区id = 科室id_In,
                执行人 = 新医生姓名_In, 执行状态 = 0, 执行时间 = Null
            Where ID = r_Bill.Id;
          Else
            --挂号或接收
            Update 门诊费用记录
            Set 执行部门id = 新科室id_In, 病人科室id = 新科室id_In, 计算单位 = 新号别_In, 发药窗口 = v_新就诊诊室,
                --病人病区id = 科室id_In,
                执行人 = 新医生姓名_In, 执行状态 = 0, 执行时间 = Null
            Where ID = r_Bill.Id;
          End If;
        
          --更新病人挂号记录
          If r_Bill.序号 = 1 Then
            v_Temp := Zl_Identity(1);
            Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_Temp From Dual;
            Select Substr(v_Temp, 0, Instr(v_Temp, ',') - 1) Into v_操作员编号 From Dual;
            Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_操作员姓名 From Dual;
            Begin
              Select ID Into n_医生id From 人员表 Where 姓名 = 新医生姓名_In And Rownum < 2;
            Exception
              When Others Then
                n_医生id := Null;
            End;
            Zl_就诊变动记录_Insert(r_Bill.No, 1, '批量换号', v_操作员姓名, v_操作员编号, 新号别_In, 新科室id_In, Null, n_医生id, 新医生姓名_In, v_新就诊诊室,
                             n_原序号, Null);
            --修改队列信息
            Update 排队叫号队列
            Set 医生姓名 = 新医生姓名_In, 诊室 = v_新就诊诊室
            Where 业务id = n_业务id And 业务类型 = 0;
          
            Update 病人挂号记录
            Set 执行部门id = 新科室id_In, 号别 = 新号别_In, 诊室 = v_新就诊诊室, 执行人 = 新医生姓名_In, 执行状态 = 0, 执行时间 = Null, 号序 = n_原序号,
                出诊记录id = 新出诊id_In
            Where NO = r_Bill.No;
            --修改挂号序号状态
            If n_原序号 Is Not Null Then
              --1.恢复以前挂号序号状态
              Update 临床出诊序号控制
              Set 挂号状态 = 0, 操作员姓名 = Null, 工作站ip = Null, 工作站名称 = Null
              Where 记录id = 原出诊id_In And 序号 = n_原序号;
              --2.新增换号后挂号序号状态
              Update 临床出诊序号控制
              Set 挂号状态 = Decode(n_挂号状态, 1, 2, 1), 操作员姓名 = v_操作员姓名, 工作站ip = Null, 工作站名称 = Null
              Where 记录id = 新出诊id_In And 序号 = n_原序号;
            End If;
          End If;
        End Loop;
        Close c_Bill;
      End Loop;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人挂号记录_批量换号;
/

--106347:余智勇,2017-02-22,更新标志信息修正
Create Or Replace Procedure Zl_药品收发住院标志_Flag
(
  业务分类_In In 药品收发住院标志.业务分类%Type,
  收发信息_In In Varchar2,
  传送标志_In In Number
) Is
  v_Error Varchar2(255);
  Err_Custom Exception;
Begin

  --参数 
  --  收发信息：收发id1;收发2... 

  For r_Tmp In (Select b.Column_Value 收发id, a.标志
                From 药品收发住院标志 A, Table(f_Str2list(收发信息_In, ';')) B
                Where a.收发id(+) = b.Column_Value And a.业务分类(+) = 业务分类_In) Loop
    If r_Tmp.标志 Is Null Then
      Delete 药品收发住院标志 Where 收发id = r_Tmp.收发id;
      If 传送标志_In = 1 Then
        Insert Into 药品收发住院标志 (收发id, 业务分类, 标志) Values (r_Tmp.收发id, 业务分类_In, 1);
      Else
        Insert Into 药品收发住院标志 (收发id, 业务分类, 标志) Values (r_Tmp.收发id, 业务分类_In, 11);
      End If;
    Elsif r_Tmp.标志 Between 11 And 12 Then
      If 传送标志_In = 1 Then
        Update 药品收发住院标志 Set 标志 = 1 Where 收发id = r_Tmp.收发id And 业务分类 = 业务分类_In;
      Else
        Update 药品收发住院标志 Set 标志 = 标志 + 1 Where 收发id = r_Tmp.收发id And 业务分类 = 业务分类_In;
      End If;
    End If;
  End Loop;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发住院标志_Flag;
/

--106347:余智勇,2017-02-22,更新标志信息修正
Create Or Replace Procedure Zl_药品收发门诊标志_Flag
(
  业务分类_In In 药品收发门诊标志.业务分类%Type,
  库房id_In   In 药品收发门诊标志.库房id%Type,
  处方信息_In In Varchar2,
  传送标志_In In Number
) Is
  v_Error Varchar2(255);
  Err_Custom Exception;
Begin

  --参数 
  --  处方信息：单据1,处方号1;单据2,处方号2... 

  For r_Tmp In (Select b.C2 处方号, b.C1 单据, a.标志
                From 药品收发门诊标志 A, Table(f_Str2list2(处方信息_In, ';', ',')) B
                Where a.处方号(+) = b.C2 And a.单据(+) = b.C1 And a.库房id(+) = 库房id_In And a.业务分类(+) = 业务分类_In) Loop
    If r_Tmp.标志 Is Null Then
      Delete 药品收发门诊标志 Where 处方号 = r_Tmp.处方号 And 单据 = r_Tmp.单据 And 库房id = 库房id_In;
      If 传送标志_In = 1 Then
        Insert Into 药品收发门诊标志
          (处方号, 单据, 库房id, 业务分类, 标志)
        Values
          (r_Tmp.处方号, r_Tmp.单据, 库房id_In, 业务分类_In, 1);
      Else
        Insert Into 药品收发门诊标志
          (处方号, 单据, 库房id, 业务分类, 标志)
        Values
          (r_Tmp.处方号, r_Tmp.单据, 库房id_In, 业务分类_In, 11);
      End If;
    Elsif r_Tmp.标志 Between 11 And 12 Then
      If 传送标志_In = 1 Then
        Update 药品收发门诊标志
        Set 标志 = 1
        Where 处方号 = r_Tmp.处方号 And 单据 = r_Tmp.单据 And 库房id = 库房id_In And 业务分类 = 业务分类_In;
      Else
        Update 药品收发门诊标志
        Set 标志 = 标志 + 1
        Where 处方号 = r_Tmp.处方号 And 单据 = r_Tmp.单据 And 库房id = 库房id_In And 业务分类 = 业务分类_In;
      End If;
    End If;
  End Loop;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发门诊标志_Flag;
/

--106185:余伟节,2017-02-22,解决替换路径项目时诊疗项目ID和收费项目ID不一致问题
Create Or Replace Procedure Zl_路径医嘱内容_Update
(
  功能_In        In Number, --1-单条医嘱更新，2-检查检验
  医嘱内容id_In  In 路径医嘱内容.Id%Type,
  诊疗项目id_In  In 路径医嘱内容.诊疗项目id%Type,
  收费细目id_In  In 路径医嘱内容.收费细目id% Type := Null,
  医嘱内容_In    In 路径医嘱内容.医嘱内容%Type := Null,
  单次用量_In    In 路径医嘱内容.单次用量%Type := Null,
  总给予量_In    In 路径医嘱内容.总给予量%Type := Null,
  标本部位_In    In 路径医嘱内容.标本部位%Type := Null,
  检查方法_In    In 路径医嘱内容.检查方法%Type := Null,
  医生嘱托_In    In 路径医嘱内容.医生嘱托%Type := Null,
  执行频次_In    In 路径医嘱内容.执行频次%Type := Null,
  频率次数_In    In 路径医嘱内容.频率次数%Type := Null,
  频率间隔_In    In 路径医嘱内容.频率间隔%Type := Null,
  间隔单位_In    In 路径医嘱内容.间隔单位%Type := Null,
  时间方案_In    In 路径医嘱内容.时间方案%Type := Null,
  插入内容ids_In In Varchar2 := Null, --功能_IN=2时,新医嘱ID串
  项目医嘱ids_In In Varchar2 := Null,
  诊疗类别_In    In Varchar2 := Null --区分检查检验
) As
  n_序号    Number(5);
  n_Count   Number(5);
  n_Start   Number(5);
  n_Groupid Number(18);
  Arr_Id    t_Numlist;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin

  --
  If 功能_In = 1 Then
    --药品
    Update 路径医嘱内容 T
    Set t.诊疗项目id = 诊疗项目id_In, t.收费细目id = 收费细目id_In, t.医嘱内容 = Nvl(医嘱内容_In, t.医嘱内容), t.单次用量 = Nvl(单次用量_In, t.单次用量),
        t.总给予量 = Nvl(总给予量_In, t.总给予量), t.标本部位 = Nvl(标本部位_In, t.标本部位), t.检查方法 = Nvl(检查方法_In, t.检查方法),
        t.医生嘱托 = Nvl(医生嘱托_In, t.医生嘱托), t.执行频次 = Nvl(执行频次_In, t.执行频次), t.频率次数 = Nvl(频率次数_In, t.频率次数),
        t.频率间隔 = Nvl(频率间隔_In, t.频率间隔), t.间隔单位 = Nvl(间隔单位_In, t.间隔单位), t.时间方案 = Nvl(时间方案_In, t.时间方案)
    Where t.Id = 医嘱内容id_In;
  Elsif 功能_In = 2 Then
    --检查,检验
    For R1 In (Select a.C1 As 项目id, a.C2 As 组医嘱id From Table(f_Num2list2(项目医嘱ids_In, ':', ',')) A) Loop
      --删除原医嘱（级联删除临床路径医嘱）
      Delete From 路径医嘱内容 T Where t.Id = R1.组医嘱id Or t.相关id = R1.组医嘱id;
      Select Nvl(Max(b.序号), 0)
      Into n_序号
      From 临床路径医嘱 A, 路径医嘱内容 B
      Where a.路径项目id = R1.项目id And a.医嘱内容id = b.Id;
      --预先读取医嘱内容ID,相关ID
      Select Count(1) Into n_Count From Table(f_Num2list(插入内容ids_In, ','));
    
      Select 路径医嘱内容_Id.Nextval Bulk Collect Into Arr_Id From Dual Connect By Rownum <= n_Count;
      If 诊疗类别_In = 'D' Then
        n_Groupid := Arr_Id(1);
      Else
        n_Groupid := Arr_Id(n_Count);
      End If;
      --临床路径医嘱关联
      n_Start := 0;
      For R2 In (Select b.Column_Value As 内容id From Table(f_Num2list(插入内容ids_In, ',')) B) Loop
        --新增医嘱内容
        n_序号  := n_序号 + 1;
        n_Start := n_Start + 1;
        Insert Into 路径医嘱内容 A
          (a.Id, a.相关id, a.序号, a.期效, a.诊疗项目id, a.收费细目id, a.医嘱内容, a.单次用量, a.总给予量, a.标本部位, a.检查方法, a.医生嘱托, a.执行频次, a.频率次数,
           a.频率间隔, a.间隔单位, a.执行性质, a.执行标记, a.执行科室id, a.时间方案, a.是否缺省, a.是否备选, a.配方id, a.组合项目id)
          Select /* +rule */
           Arr_Id(n_Start) As ID, Decode(b.相关id, Null, Null, n_Groupid) As 相关id, n_序号 As 序号, b.期效, b.诊疗项目id, b.收费细目id,
           b.医嘱内容, b.单次用量, b.总给予量, b.标本部位, b.检查方法, b.医生嘱托, b.执行频次, b.频率次数, b.频率间隔, b.间隔单位, b.执行性质, b.执行标记, b.执行科室id,
           b.时间方案, b.是否缺省, b.是否备选, b.配方id, b.组合项目id
          From 路径医嘱内容 B
          Where b.Id = R2.内容id;
        Insert Into 临床路径医嘱 T (t.路径项目id, t.医嘱内容id) Values (R1.项目id, Arr_Id(n_Start));
      End Loop;
    End Loop;
    --删除临时医嘱
    Delete From 路径医嘱内容 T Where Instr(',' || 插入内容ids_In || ',', ',' || t.Id || ',') > 0;
  
  End If;
Exception

  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_路径医嘱内容_Update;
/

--106199:刘尔旋,2017-02-22,服务窗医保实时结算补充提交
Create Or Replace Procedure Zl_Third_Getregistalter
(
  Xml_In  Xmltype,
  Xml_Out Out Xmltype
) Is
  -----------------------------------------------
  --功能：获取当天操作的停换诊安排
  --入参：XML_IN
  --<IN>
  --  <JSKLB>结算卡类别</JSKLB>
  --  <RQ>日期</RQ>
  --</IN>
  --出参:XML_OUT
  --<OUTPUT>
  --  <TZLISTS>          //停诊列表
  --    <ITEM>
  --      <HM>号码</HM>
  --      <YSID>医生ID</YSID>
  --      <YS>医生姓名</YS>
  --      <KSSJ>停诊开始时间</KSSJ>
  --      <JSSJ>停诊结束时间</JSSJ>
  --      <BRLIST>
  --        <INFO>
  --          <YYNO>预约单据号</YYNO>
  --          <BRID>病人ID</BRID>
  --          <YYSJ>预约时间</YYSJ>
  --          <CZSJ>操作时间</CZSJ>
  --          <YYKS>预约科室</YYKS>
  --          <GHLX>号类</GHLX>
  --          <YSXM>医生姓名</YSXM>
  --        </INFO>
  --      </BRLIST>
  --    </ITEM>
  --  </TZLISTS>
  --  <HZLISTS>          //换诊列表
  --    <ITEM>
  --      <BRID>病人ID</BRID>
  --      <YYSJ>预约的操作时间</YYSJ>
  --      <YSJ>原预约时间</YSJ>
  --      <YHM>原号码</YHM>
  --      <YYS>原医生</YYS>
  --      <YZC>原医生的职称</YZC>
  --      <XSJ>现预约时间</XSJ>
  --      <XHM>现号码</XHM>
  --      <XYS>现医生</XYS>
  --      <XZC>现医生的职称</XZC>
  --    </ITEM>
  --  </HZLIST>
  --</OUTPUT>
  -----------------------------------------------------

  d_Date     Date;
  v_Jsklb    Varchar2(100);
  n_卡类别id 医疗卡类别.Id%Type;
  n_Cnt      Number(3);
  v_Temp     Clob;
  v_Brinfo   Varchar2(4000);
  d_启用时间 Date;
  v_Para     Varchar2(2000);
  n_Exists   Number(3);
  n_挂号模式 Number(3);
  x_Templet  Xmltype;
Begin
  Select Extractvalue(Value(A), 'IN/JSKLB') Into v_Jsklb From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  Select To_Date(Extractvalue(Value(A), 'IN/RQ'), 'yyyy-mm-dd')
  Into d_Date
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  Select b.Id Into n_卡类别id From 医疗卡类别 B Where b.名称 = v_Jsklb And Rownum < 2;
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  v_Para     := zl_GetSysParameter(256);
  n_挂号模式 := Substr(v_Para, 1, 1);
  Begin
    d_启用时间 := To_Date(Substr(v_Para, 3), 'yyyy-mm-dd hh24:mi:ss');
  Exception
    When Others Then
      d_启用时间 := Null;
  End;

  If n_挂号模式 = 1 And Nvl(d_Date, Sysdate) > Nvl(d_启用时间, Sysdate - 30) Then
    --出诊表排班模式
    --获取停诊安排
    For r_停诊 In (Select a.Id As 记录id, b.号码, a.医生id, a.医生姓名, a.停诊开始时间, a.停诊终止时间
                 From 临床出诊记录 A, 临床出诊号源 B, 临床出诊停诊记录 C
                 Where a.Id = c.记录id And a.号源id = b.Id And a.停诊开始时间 Is Not Null And c.审批时间 Between d_Date And
                       d_Date + 1 - 1 / 24 / 60 / 60) Loop
      v_Temp := v_Temp || '<ITEM><HM>' || r_停诊.号码 || '</HM><YSID>' || r_停诊.医生id || '</YSID><YS>' || r_停诊.医生姓名 ||
                '</YS><KSSJ>' || r_停诊.停诊开始时间 || '</KSSJ><JSSJ>' || r_停诊.停诊终止时间 || '</JSSJ>';
      For r_停诊病人 In (Select a.记录性质, a.No, a.病人id, To_Char(a.发生时间, 'yyyy-mm-dd') As 发生时间,
                            To_Char(a.登记时间, 'yyyy-mm-dd hh24:mi:ss') As 登记时间, b.名称, d.号类, c.医生姓名 As 医生姓名
                     From 病人挂号记录 A, 部门表 B, 临床出诊记录 C, 临床出诊号源 D
                     Where a.执行部门id = b.Id And a.出诊记录id = c.Id And c.号源id = d.Id And 记录状态 = 1 And
                           发生时间 Between r_停诊.停诊开始时间 And r_停诊.停诊终止时间 And a.出诊记录id = r_停诊.记录id And Not Exists
                      (Select 1 From 就诊变动记录 Where 挂号单 = a.No)) Loop
        --停诊病人列表，不包含已经换诊和取消了的病人
        If r_停诊病人.记录性质 = 2 Then
          v_Brinfo := v_Brinfo || '<INFO><YYNO>' || r_停诊病人.No || '</YYNO><BRID>' || r_停诊病人.病人id || '</BRID><YYSJ>' ||
                      r_停诊病人.发生时间 || '</YYSJ><CZSJ>' || r_停诊病人.登记时间 || '</CZSJ>' || '<YYKS>' || r_停诊病人.名称 ||
                      '</YYKS><GHLX>' || r_停诊病人.号类 || '</GHLX><YSXM>' || r_停诊病人.医生姓名 || '</YSXM></INFO>';
        Else
          Begin
            Select 1
            Into n_Exists
            From 病人预交记录
            Where NO = r_停诊病人.No And 记录性质 = 4 And 卡类别id = n_卡类别id;
          Exception
            When Others Then
              n_Exists := 0;
          End;
          If n_Exists = 1 Then
            v_Brinfo := v_Brinfo || '<INFO><YYNO>' || r_停诊病人.No || '</YYNO><BRID>' || r_停诊病人.病人id || '</BRID><YYSJ>' ||
                        r_停诊病人.发生时间 || '</YYSJ><CZSJ>' || r_停诊病人.登记时间 || '</CZSJ>' || '<YYKS>' || r_停诊病人.名称 ||
                        '</YYKS><GHLX>' || r_停诊病人.号类 || '</GHLX><YSXM>' || r_停诊病人.医生姓名 || '</YSXM></INFO>';
          End If;
        End If;
      End Loop;
      v_Temp   := v_Temp || '<BRLIST>' || v_Brinfo || '</BRLIST></ITEM>';
      v_Brinfo := '';
    End Loop;
    v_Temp := '<TZLISTS>' || v_Temp || '</TZLISTS>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    --换取换诊列表
    v_Temp := '';
    For r_换诊 In (Select d.记录性质, d.No, a.病人id, To_Char(d.发生时间, 'yyyy-mm-dd hh24:mi:ss') As 预约时间,
                        To_Char(a.登记时间, 'yyyy-mm-dd hh24:mi:ss') As 登记时间, a.原号码, a.原医生姓名, b.专业技术职务 As 原职务, a.现号码, a.现医生姓名,
                        c.专业技术职务 As 现职务
                 From 就诊变动记录 A, 人员表 B, 人员表 C, 病人挂号记录 D
                 Where a.登记时间 Between d_Date And d_Date + 1 - 1 / 24 / 60 / 60 And a.原医生id = b.Id And a.现医生id = c.Id And
                       a.挂号单 = d.No) Loop
      --只返回该卡类别挂号的病人         
      If r_换诊.记录性质 = 2 Then
        v_Temp := v_Temp || '<ITEM><BRID>' || r_换诊.病人id || '</BRID><YYSJ>' || r_换诊.登记时间 || '</YYSJ>';
        v_Temp := v_Temp || '<YSJ>' || r_换诊.预约时间 || '</YSJ><YHM>' || r_换诊.原号码 || '</YHM><YYS>' || r_换诊.原医生姓名 ||
                  '</YYS><YZC>' || r_换诊.原职务 || '</YZC>';
        v_Temp := v_Temp || '<XSJ>' || r_换诊.预约时间 || '</XSJ><XHM>' || r_换诊.现号码 || '</XHM><XYS>' || r_换诊.现医生姓名 ||
                  '</XYS><XZC>' || r_换诊.现职务 || '</XZC></ITEM>';
      Else
        Begin
          Select 1 Into n_Exists From 病人预交记录 Where NO = r_换诊.No And 记录性质 = 4 And 卡类别id = n_卡类别id;
        Exception
          When Others Then
            n_Exists := 0;
        End;
        If n_Exists = 1 Then
          v_Temp := v_Temp || '<ITEM><BRID>' || r_换诊.病人id || '</BRID><YYSJ>' || r_换诊.登记时间 || '</YYSJ>';
          v_Temp := v_Temp || '<YSJ>' || r_换诊.预约时间 || '</YSJ><YHM>' || r_换诊.原号码 || '</YHM><YYS>' || r_换诊.原医生姓名 ||
                    '</YYS><YZC>' || r_换诊.原职务 || '</YZC>';
          v_Temp := v_Temp || '<XSJ>' || r_换诊.预约时间 || '</XSJ><XHM>' || r_换诊.现号码 || '</XHM><XYS>' || r_换诊.现医生姓名 ||
                    '</XYS><XZC>' || r_换诊.现职务 || '</XZC></ITEM>';
        End If;
      End If;
    End Loop;
    v_Temp := '<HZLISTS>' || v_Temp || '</HZLISTS>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Else
    --计划排班模式
    --获取停诊安排
    For Rs In (Select b.号码, b.医生id, b.医生姓名, To_Char(a.开始停止时间, 'yyyy-mm-dd hh24:mi:ss') As 开始停止时间,
                      To_Char(a.结束停止时间, 'yyyy-mm-dd hh24:mi:ss') As 结束停止时间
               From 挂号安排停用状态 A, 挂号安排 B
               Where a.安排id = b.Id And a.制订日期 Between d_Date And d_Date + 1 - 1 / 24 / 60 / 60) Loop
      v_Temp := v_Temp || '<ITEM><HM>' || Rs.号码 || '</HM><YSID>' || Rs.医生id || '</YSID><YS>' || Rs.医生姓名 ||
                '</YS><KSSJ>' || Rs.开始停止时间 || '</KSSJ><JSSJ>' || Rs.结束停止时间 || '</JSSJ>';
      ----2015/7/28
      For Rs_Br In (Select a.No, a.病人id, To_Char(a.发生时间, 'yyyy-mm-dd') As 发生时间,
                           To_Char(a.登记时间, 'yyyy-mm-dd hh24:mi:ss') As 登记时间, b.名称, c.号类, a.执行人 As 医生姓名
                    From 病人挂号记录 A, 部门表 B, 挂号安排 C
                    Where a.号别 = Rs.号码 And a.执行状态 = 0 And a.执行部门id = b.Id And b.Id = c.科室id And a.号别 = c.号码 And
                          Trunc(发生时间) Between Trunc(To_Date(Rs.开始停止时间, 'yyyy-mm-dd hh24:mi:ss')) And
                          Trunc(To_Date(Rs.结束停止时间, 'yyyy-mm-dd hh24:mi:ss'))) Loop
        --只返回该卡类别挂号的病人
        Select Count(*)
        Into n_Cnt
        From (Select 1
               From 病人预交记录 A
               Where a.No = Rs_Br.No AND A.记录性质=4 AND a.记录状态 = 1 And a.病人id = Rs_Br.病人id And 卡类别id = n_卡类别id
               Union All
               Select 1 From 病人挂号记录 Where NO = Rs_Br.No And 记录状态 = 1 And 交易说明 = v_Jsklb);
        If n_Cnt > 0 Then
          v_Brinfo := v_Brinfo || '<INFO><YYNO>' || Rs_Br.No || '</YYNO><BRID>' || Rs_Br.病人id || '</BRID><YYSJ>' ||
                      Rs_Br.发生时间 || '</YYSJ><CZSJ>' || Rs_Br.登记时间 || '</CZSJ>' || '<YYKS>' || Rs_Br.名称 ||
                      '</YYKS><GHLX>' || Rs_Br.号类 || '</GHLX><YSXM>' || Rs_Br.医生姓名 || '</YSXM></INFO>';
        End If;
      End Loop;
      v_Temp   := v_Temp || '<BRLIST>' || v_Brinfo || '</BRLIST></ITEM>';
      v_Brinfo := '';
    End Loop;
    v_Temp := '<TZLISTS>' || v_Temp || '</TZLISTS>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  
    --获取换诊记录
    v_Temp := '';
    For Rs In (Select d.No, a.病人id, To_Char(d.发生时间, 'yyyy-mm-dd hh24:mi:ss') As 预约时间,
                      To_Char(a.登记时间, 'yyyy-mm-dd hh24:mi:ss') As 登记时间, a.原号码, a.原医生姓名, b.专业技术职务 As 原职务, a.现号码, a.现医生姓名,
                      c.专业技术职务 As 现职务
               From 就诊变动记录 A, 人员表 B, 人员表 C, 病人挂号记录 D
               Where a.登记时间 Between d_Date And d_Date + 1 - 1 / 24 / 60 / 60 And a.原医生id = b.Id And a.现医生id = c.Id And
                     a.挂号单 = d.No) Loop
      --只返回该卡类别挂号的病人         
      Select Count(*)
      Into n_Cnt
      From (Select 1
             From 病人预交记录 A
             Where a.No = Rs.No And a.记录性质 = 4 And a.记录状态 = 1 And a.病人id = Rs.病人id And 卡类别id = n_卡类别id
             Union All
             Select 1 From 病人挂号记录 Where NO = Rs.No AND 记录状态 = 1 And 交易说明 = v_Jsklb);
      If n_Cnt > 0 Then
        v_Temp := v_Temp || '<ITEM><BRID>' || Rs.病人id || '</BRID><YYSJ>' || Rs.登记时间 || '</YYSJ>';
        v_Temp := v_Temp || '<YSJ>' || Rs.预约时间 || '</YSJ><YHM>' || Rs.原号码 || '</YHM><YYS>' || Rs.原医生姓名 || '</YYS><YZC>' ||
                  Rs.原职务 || '</YZC>';
        v_Temp := v_Temp || '<XSJ>' || Rs.预约时间 || '</XSJ><XHM>' || Rs.现号码 || '</XHM><XYS>' || Rs.现医生姓名 || '</XYS><XZC>' ||
                  Rs.现职务 || '</XZC></ITEM>';
      End If;
    End Loop;
    v_Temp := '<HZLISTS>' || v_Temp || '</HZLISTS>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  End If;
  Xml_Out := x_Templet;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getregistalter;
/

--105986:胡俊勇,2017-02-21,中草药医嘱下达
Create Or Replace Function Zl_Dispensechspecs
(
  药名id_In   药品规格.药名id%Type,
  形态_In     药品规格.中药形态%Type, --0-散装，1-中药饮片，2-免煎剂
  数量_In     药品库存.可用数量%Type, --按剂量单位传入
  付数_In     药品库存.可用数量%Type,
  药房_In     药品库存.库房id%Type,
  分离发药_In Integer := 0, --分离分药模式,只能处理定价.不能处理实价药品
  场合_In     Number := 1, -- 1-门诊 ，2-住院
  药品ids_In  Varchar2 := Null --指定药品的分配
) Return Varchar2 As
  --返回:药品id,数量;药品id,数量;...(散装只选择一个规格)
  --                             不能完全分配时返回:剂量为6和10的情况下,17克的分配=23755,6;23756,10|1
  --                             不能分配时返回空,例如:剂量为6和10的情况下,3克的分配
  n_本次数量     药品库存.可用数量%Type;
  n_总数量       药品库存.可用数量%Type;
  n_包数         药品库存.可用数量%Type;
  n_总包数       药品库存.可用数量%Type;
  n_剩余数量     药品库存.可用数量%Type := 0;
  v_分配结果     Varchar2(1000);
  n_可用数量     药品库存.可用数量%Type;
  n_总数量tmp    药品库存.可用数量%Type;
  n_上次总数量   药品库存.可用数量%Type;
  n_本次数量tmp  药品库存.可用数量%Type;
  n_减少数量     药品库存.可用数量%Type;
  n_上次计量系数 药品库存.可用数量%Type;
  n_方式         药品出库检查.检查方式%Type;
  --Select Zl_Dispensechspecs(7366,2,28,1,76) as txt From dual
  --可能存在不同批次的,所以要汇总
  Cursor c_Medi(v_药品ids Varchar) Is
    Select a.药品id, b.剂量系数, Decode(场合_In, 2, b.住院可否分零, b.门诊可否分零) As 可否分零, Sum(a.可用数量) * b.剂量系数 可用数量
    From 药品库存 A, 药品规格 B, 收费项目目录 C
    Where a.药品id = b.药品id And b.药名id = 药名id_In And a.药品id = c.Id And Decode(分离发药_In, 1, c.是否变价, 0) = 0 And 库房id = 药房_In And
          a.性质 = 1 And b.中药形态 = 形态_In And (Nvl(a.批次, 0) = 0 Or a.效期 Is Null Or a.效期 > Trunc(Sysdate)) And
          (b.药品id In (Select Column_Value From Table(f_Num2list(v_药品ids))) Or v_药品ids Is Null) And c.服务对象 In (场合_In, 3)
    Group By a.药品id, b.剂量系数, Decode(场合_In, 2, b.住院可否分零, b.门诊可否分零)
    Having Nvl(Sum(a.可用数量), 0) > 0
    Order By b.剂量系数 Desc, 可用数量;
  --不限定库存的时候
  Cursor c_Medi_Nostock Is
    Select b.药品id, b.剂量系数, Decode(场合_In, 2, b.住院可否分零, b.门诊可否分零) As 可否分零, 数量_In * 付数_In As 可用数量
    From 药品规格 B, 收费项目目录 C
    Where b.药名id = 药名id_In And b.药品id = c.Id And b.中药形态 = 形态_In And
          (b.药品id In (Select Column_Value From Table(f_Num2list(药品ids_In))) Or 药品ids_In Is Null) And c.服务对象 In (场合_In, 3)
    Order By b.剂量系数 Desc;

  Type t_Medi Is Table Of c_Medi%Rowtype;
  r_Medi t_Medi;
Begin
  Open c_Medi(Null);
  Fetch c_Medi Bulk Collect
    Into r_Medi;
  Close c_Medi;
  n_可用数量 := 0;
  For J In 1 .. r_Medi.Count Loop
    n_可用数量 := n_可用数量 + r_Medi(J).可用数量;
  End Loop;

  If n_可用数量 < 数量_In Then
    Select Nvl(Max(检查方式), 0) Into n_方式 From 药品出库检查 Where 库房id = 药房_In;
    If n_方式 <> 2 Then
      Open c_Medi_Nostock;
      Fetch c_Medi_Nostock Bulk Collect
        Into r_Medi;
      Close c_Medi_Nostock;
      n_可用数量 := 0;
      For J In 1 .. r_Medi.Count Loop
        n_可用数量 := n_可用数量 + r_Medi(J).可用数量;
      End Loop;
    End If;
  Elsif 药品ids_In Is Not Null Then
    Open c_Medi(药品ids_In);
    Fetch c_Medi Bulk Collect
      Into r_Medi;
    Close c_Medi;
  End If;

  If Not r_Medi Is Null Then
    For J In 0 .. r_Medi.Count - 1 Loop
      --第二层循环是为了处理"大规格"优先时不能完成分配的情况,例如:剂量为6和10的情况下,12克的分配
      v_分配结果 := Null;
      n_总数量   := 数量_In;
      n_总包数   := 0;
      n_剩余数量 := 0;
      For I In 1 + J .. r_Medi.Count Loop
        --按剂量大小的倒序分配满足了"最少用包原则"
        --总数量(3)可能小于剂量系数(5),存在不能分零的情况
        --如果总数量刚好等于所有规格的库存之和,但大于任何一种规格的库存,这种特殊情况因处理复杂,实用价值不高,不处理(返回空)
        n_本次数量 := 0;
        n_包数     := 0;
        If n_总数量 <= r_Medi(I).可用数量 Then
          If n_总数量 >= r_Medi(I).剂量系数 Then
            If r_Medi(I).可否分零 = 1 Then
              --不分零
              n_包数     := Floor(n_总数量 / r_Medi(I).剂量系数);
              n_本次数量 := n_包数 * r_Medi(I).剂量系数;
            Else
              n_包数     := n_总数量 / r_Medi(I).剂量系数;
              n_本次数量 := n_总数量;
            End If;
          End If;
        
          --这里处理连续的两种规格分配时，大包用后，小包不能用的情况。比如：规格为小包为6g/包，大包为10g/包，现在总量是22g，如果是原来的方式，则是大包2包，余2g 分不尽，
          --                                                   现修改为在大包分了两包后，小包分不尽的时候，则将已分的大包循环减一个计量系数，这里大包的计量系数为10g，
          --                                                  已分了20g，现在减10g，就余下12g，然后小包就可以分尽了。最后结果就为大包 1包10g，小包2包12g。
          --如果中间隔了一个规格，本分支不能解决。比如：三个规格，前两种分不尽，后两种也分不尽，只有第一种和第三种才分的尽的，这种情况应该不多。
          If ((n_总数量 < r_Medi(I).剂量系数 And n_总数量 > 0) Or n_总数量 - n_本次数量 <> 0) And I <> 1 + J And v_分配结果 Is Not Null Then
            n_减少数量 := 0;
            --每次减上次的总量，都将减的数量累加起来。
            n_总数量tmp := n_总数量 + n_上次计量系数;
            n_减少数量  := n_减少数量 + n_上次计量系数;
            Loop
              --循环减，直到将上次分配的减完。
              Exit When n_总数量tmp >= n_上次总数量;
              If r_Medi(I).可否分零 = 1 Then
                --不分零的才会出现这种
                n_本次数量tmp := Floor(n_总数量tmp / r_Medi(I).剂量系数) * r_Medi(I).剂量系数;
              End If;
              --如果能够分尽，则更新本次的数量，并将上次的数量重新修改。
              If n_总数量tmp = n_本次数量tmp Then
                n_包数     := Floor(n_总数量tmp / r_Medi(I).剂量系数);
                n_本次数量 := n_本次数量tmp;
                If n_上次总数量 - n_总数量 - n_减少数量 = 0 Then
                  --如果上次分配的被减完了，则删除上次分配的结果。
                  v_分配结果 := Substr(v_分配结果, 1, Instr(v_分配结果, ';', -1) - 1);
                Else
                  v_分配结果 := Substr(v_分配结果, 1, Instr(v_分配结果, ',', -1)) || (n_上次总数量 - n_总数量 - n_减少数量);
                End If;
                --这里由于上次的数量发生了变化，所以总数量也要修改。
                n_总数量 := n_总数量 + n_减少数量;
                Exit;
              End If;
              n_总数量tmp := n_总数量tmp + n_上次计量系数;
              n_减少数量  := n_减少数量 + n_上次计量系数;
            End Loop;
          End If;
        
          If n_总数量 >= r_Medi(I).剂量系数 Then
            If 付数_In * n_本次数量 <= r_Medi(I).可用数量 Then
              If v_分配结果 Is Null Then
                v_分配结果 := r_Medi(I).药品id || ',' || n_本次数量;
              Else
                v_分配结果 := v_分配结果 || ';' || r_Medi(I).药品id || ',' || n_本次数量;
              End If;
            
              n_上次总数量   := n_总数量;
              n_总包数       := n_总包数 + n_包数;
              n_总数量       := n_总数量 - n_本次数量;
              n_上次计量系数 := r_Medi(I).剂量系数;
              If 形态_In = 0 Then
                Exit; --散装只能使用一种规格
              End If;
            End If;
          End If;
        Elsif n_总数量 >= r_Medi(I).剂量系数 And n_总数量 > r_Medi(I).可用数量 And n_总数量 <= n_可用数量 Then
          --处理了单个规格库存不足，但是所有规格的总数量够用的情况。（这里处理为如果某一个规格数量不足，就能用多少用多少）
          If r_Medi(I).可否分零 = 1 Then
            --不分零
            n_包数     := Floor(r_Medi(I).可用数量 / r_Medi(I).剂量系数);
            n_本次数量 := n_包数 * r_Medi(I).剂量系数;
          Else
            n_包数     := r_Medi(I).可用数量 / r_Medi(I).剂量系数;
            n_本次数量 := r_Medi(I).可用数量;
          End If;
        
          If 付数_In * n_本次数量 <= n_可用数量 Then
            If v_分配结果 Is Null Then
              v_分配结果 := r_Medi(I).药品id || ',' || n_本次数量;
            Else
              v_分配结果 := v_分配结果 || ';' || r_Medi(I).药品id || ',' || n_本次数量;
            End If;
            n_上次总数量   := n_总数量;
            n_总包数       := n_总包数 + n_包数;
            n_总数量       := n_总数量 - n_本次数量;
            n_可用数量     := n_可用数量 - n_本次数量;
            n_上次计量系数 := r_Medi(I).剂量系数;
            If 形态_In = 0 Then
              Exit; --散装只能使用一种规格
            End If;
          End If;
        End If;
      End Loop;
      If n_总数量 = 0 Then
        n_剩余数量 := 0;
        Exit;
      Elsif n_剩余数量 = 0 And v_分配结果 Is Not Null Then
        n_剩余数量 := n_总数量;
      End If;
    End Loop;
  End If;

  If n_总数量 = 0 Or n_剩余数量 <> 0 Then
    --检查是否适用"倍量优先原则"
    If n_剩余数量 <> 0 Then
      n_总数量 := 数量_In - n_剩余数量;
    Else
      n_总数量 := 数量_In;
    End If;
    For I In 1 .. r_Medi.Count Loop
      If n_总数量 >= r_Medi(I).剂量系数 And n_总数量 <= r_Medi(I).可用数量 Then
        n_包数     := Floor(n_总数量 / r_Medi(I).剂量系数);
        n_本次数量 := n_包数 * r_Medi(I).剂量系数;
        If n_总数量 = n_本次数量 And 付数_In * n_本次数量 <= r_Medi(I).可用数量 Then
          If n_包数 <= n_总包数 Then
            If n_剩余数量 <> 0 Then
              v_分配结果 := r_Medi(I).药品id || ',' || n_本次数量 || '|' || n_剩余数量;
            Else
              v_分配结果 := r_Medi(I).药品id || ',' || n_本次数量;
            End If;
          End If;
          Exit;
        End If;
      End If;
    End Loop;
  
    Return v_分配结果;
  Else
    Return Null;
  End If;
End Zl_Dispensechspecs;
/

--100891:刘尔旋,2017-02-17,结帐数据升级处理
Create Or Replace Procedure Zl_病人结帐记录_Upgrade(结帐id_In 病人结帐记录.Id%Type) Is
  --功能：过滤结帐单据时，针对没有填写结帐金额的历史结帐记录进行数据升级,填写结帐金额
  --参数：
  --     结帐id_in：需要升级的结帐记录ID
  --     
  n_结帐金额 病人结帐记录.结帐金额%Type;
Begin
  Select Nvl(Sum(结帐金额), 0) Into n_结帐金额 From 门诊费用记录 Where 结帐id = 结帐id_In;
  Select n_结帐金额 + Nvl(Sum(结帐金额), 0) Into n_结帐金额 From 住院费用记录 Where 结帐id = 结帐id_In;
  Update 病人结帐记录 Set 结帐金额 = n_结帐金额 Where ID = 结帐id_In And 结帐金额 Is Null;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人结帐记录_Upgrade;
/

--103112:余伟节,2017-02-15,病人入院管理支持手机号录入及查询
Create Or Replace Procedure Zl_入院病案主页_Update
(
  登记模式_In       Number,
  病人id_In         病人信息.病人id%Type,
  住院号_In         病人信息.住院号%Type,
  医保号_In         保险帐户.医保号%Type,
  姓名_In           病人信息.姓名%Type,
  性别_In           病人信息.性别%Type,
  年龄_In           病人信息.年龄%Type,
  费别_In           病人信息.费别%Type,
  出生日期_In       病人信息.出生日期%Type,
  国籍_In           病人信息.国籍%Type,
  民族_In           病人信息.民族%Type,
  学历_In           病人信息.学历%Type,
  婚姻状况_In       病人信息.婚姻状况%Type,
  职业_In           病人信息.职业%Type,
  身份_In           病人信息.身份%Type,
  身份证号_In       病人信息.身份证号%Type,
  出生地点_In       病人信息.出生地点%Type,
  家庭地址_In       病人信息.家庭地址%Type,
  家庭地址邮编_In   病人信息.家庭地址邮编%Type,
  家庭电话_In       病人信息.家庭电话%Type,
  户口地址_In       病人信息.户口地址%Type,
  户口地址邮编_In   病人信息.户口地址邮编%Type,
  联系人姓名_In     病人信息.联系人姓名%Type,
  联系人关系_In     病人信息.联系人关系%Type,
  联系人地址_In     病人信息.联系人地址%Type,
  联系人电话_In     病人信息.联系人电话%Type,
  工作单位_In       病人信息.工作单位%Type,
  合同单位id_In     病人信息.合同单位id%Type,
  单位电话_In       病人信息.单位电话%Type,
  单位邮编_In       病人信息.单位邮编%Type,
  单位开户行_In     病人信息.单位开户行%Type,
  单位帐号_In       病人信息.单位帐号%Type,
  担保人_In         病人信息.担保人%Type,
  担保额_In         病人信息.担保额%Type,
  担保性质_In       病人信息.担保性质%Type,
  主页id_In         病案主页.主页id%Type,
  入院科室id_In     病案主页.入院科室id%Type,
  护理等级id_In     病案主页.护理等级id%Type,
  入院病况_In       病案主页.入院病况%Type,
  入院方式_In       病案主页.入院方式%Type,
  住院目的_In       病案主页.住院目的%Type,
  二级院转入_In     病案主页.二级院转入%Type,
  门诊医师_In       病案主页.门诊医师%Type,
  籍贯_In           病人信息.籍贯%Type,
  区域_In           病案主页.区域%Type,
  入院时间_In       病案主页.入院日期%Type,
  付款方式_In       病案主页.医疗付款方式%Type,
  疾病id_In         病人诊断记录.疾病id%Type,
  诊断id_In         病人诊断记录.诊断id%Type,
  门诊诊断_In       病人诊断记录.诊断描述%Type,
  中医疾病id_In     病人诊断记录.疾病id%Type,
  中医诊断id_In     病人诊断记录.诊断id%Type,
  中医诊断_In       病人诊断记录.诊断描述%Type,
  操作员编号_In     病案主页.编目员编号%Type,
  操作员姓名_In     病案主页.编目员姓名%Type,
  备注_In           病案主页.备注%Type,
  病区id_In         病案主页.入院病区id%Type,
  再入院_In         病案主页.再入院%Type,
  入院属性_In       病案主页.入院属性%Type := Null,
  其他证件_In       病人信息.其他证件%Type := Null,
  病人类型_In       病案主页.病人类型%Type := Null,
  联系人身份证号_In 病人信息.联系人身份证号%Type := Null,
  手机号_In         病人信息.手机号%Type := Null
) As
  -----------------------------------------------------------
  --说明：本函数仅用于入院未入科登记病人信息的修改
  --      登记模式_IN=0-正常登记,1-预约登记
  --      病区ID_IN=只有当病区管理病床模式下,入院时入科时,才会有值
  --      住院号_IN = 病人性质为 门诊留观时 住院号_In 为病人门诊号
  -----------------------------------------------------------
  v_病人性质 病案主页.病人性质%Type;
  v_Count    Number;
  v_Date     Date;
  v_Error    Varchar2(255);
  Err_Custom Exception;
Begin
  --判断病人是否锁定
  Select Count(病人id) Into v_Count From 病人信息 Where 病人id = 病人id_In;
  If v_Count <> 0 Then
    Zl_病人信息_锁定检查(病人id_In);
  End If;
  --判断病人是否未入院
  Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In And 状态 = 1;
  If v_Count = 0 Then
    v_Error := '病人当前不处于等待入科状态，操作不能继续！' || Chr(13) || Chr(10) || '可能该病人已经被其它操作员取消登记或分配床位。';
    Raise Err_Custom;
  End If;

  Select Sysdate Into v_Date From Dual;
  Select 病人性质 Into v_病人性质 From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;

  --病人基本信息
  --非第一次入院时,门诊费别保持不变,除非是门诊留观病人

  Update 病人信息
  Set 住院号 = Decode(v_病人性质, 1, 住院号, 2, 住院号, 住院号_In), 门诊号 = Decode(v_病人性质, 1, 住院号_In, 门诊号), 姓名 = 姓名_In, 性别 = 性别_In,
      年龄 = 年龄_In, 医疗付款方式 = 付款方式_In, 费别 = Decode(v_病人性质, 1, 费别_In, 费别), 出生日期 = 出生日期_In, 国籍 = 国籍_In, 民族 = 民族_In,
      籍贯 = 籍贯_In, 区域 = 区域_In, 学历 = 学历_In, 婚姻状况 = 婚姻状况_In, 职业 = 职业_In, 身份 = 身份_In, 身份证号 = 身份证号_In, 出生地点 = 出生地点_In,
      家庭地址 = 家庭地址_In, 家庭地址邮编 = 家庭地址邮编_In, 家庭电话 = 家庭电话_In, 户口地址 = 户口地址_In, 户口地址邮编 = 户口地址邮编_In, 联系人姓名 = 联系人姓名_In,
      联系人关系 = 联系人关系_In, 联系人地址 = 联系人地址_In, 联系人电话 = 联系人电话_In, 联系人身份证号 = 联系人身份证号_In, 工作单位 = 工作单位_In,
      合同单位id = Decode(合同单位id_In, 0, Null, 合同单位id_In), 单位电话 = 单位电话_In, 单位邮编 = 单位邮编_In, 单位开户行 = 单位开户行_In, 单位帐号 = 单位帐号_In,
      担保人 = 担保人_In, 担保额 = Decode(担保额_In, 0, Null, 担保额_In), 担保性质 = 担保性质_In, 其他证件 = 其他证件_In, 手机号 = 手机号_In
  Where 病人id = 病人id_In;

  If 登记模式_In = 0 Then
    --病案信息
    Update 病人信息
    Set 当前病区id = 病区id_In, 当前科室id = 入院科室id_In, 入院时间 = 入院时间_In, 出院时间 = Null
    Where 病人id = 病人id_In;
  End If;

  Begin
    --在院病人  
    If 登记模式_In = 0 Then
      Update 在院病人 Set 病区id = Nvl(病区id_In, 0), 科室id = 入院科室id_In Where 病人id = 病人id_In;
      If Sql%RowCount = 0 Then
        Insert Into 在院病人
          (病人id, 科室id, 病区id, 主页id)
        Values
          (病人id_In, 入院科室id_In, Nvl(病区id_In, 0), Nvl(主页id_In, 0));
      End If;
    End If;
  Exception
    When Others Then
      Null;
  End;

  --修改病案主页
  Update 病案主页
  Set 住院号 = Decode(v_病人性质, 1, Null, 2, Null, 住院号_In), 留观号 = Decode(v_病人性质, 2, 住院号_In, Null), 费别 = 费别_In,
      入院病区id = 病区id_In, 入院科室id = 入院科室id_In, 入院日期 = 入院时间_In, 入院病况 = 入院病况_In, 入院方式 = 入院方式_In, 入院属性 = 入院属性_In,
      二级院转入 = 二级院转入_In, 住院目的 = 住院目的_In, 当前病况 = 入院病况_In, 当前病区id = 病区id_In, 护理等级id = Decode(护理等级id_In, 0, Null, 护理等级id_In),
      出院科室id = 入院科室id_In, 门诊医师 = 门诊医师_In, 编目员编号 = 操作员编号_In, 编目员姓名 = 操作员姓名_In, 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In,
      婚姻状况 = 婚姻状况_In, 职业 = 职业_In, 国籍 = 国籍_In, 学历 = 学历_In, 单位电话 = 单位电话_In, 单位邮编 = 单位邮编_In, 单位地址 = 工作单位_In, 区域 = 区域_In,
      家庭地址 = 家庭地址_In, 家庭电话 = 家庭电话_In, 家庭地址邮编 = 家庭地址邮编_In, 户口地址 = 户口地址_In, 户口地址邮编 = 户口地址邮编_In, 联系人姓名 = 联系人姓名_In,
      联系人关系 = 联系人关系_In, 联系人地址 = 联系人地址_In, 联系人电话 = 联系人电话_In, 联系人身份证号 = 联系人身份证号_In, 医疗付款方式 = 付款方式_In, 备注 = 备注_In,
      登记人 = 操作员姓名_In, 登记时间 = v_Date, 再入院 = 再入院_In, 病人类型 = 病人类型_In
  Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0);

  If 登记模式_In = 0 Then
    --医保号
    If 医保号_In Is Not Null Then
      Update 病案主页从表 Set 信息值 = 医保号_In Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '医保号';
      If Sql%RowCount = 0 Then
        Insert Into 病案主页从表 (病人id, 主页id, 信息名, 信息值) Values (病人id_In, 主页id_In, '医保号', 医保号_In);
      End If;
    Else
      Delete From 病案主页从表 Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '医保号';
    End If;
  
    --修改病人变动记录(肯定为入院变动;单独入科的不准修改,入院同时入科的病人界面程序禁止修改)
    Update 病人变动记录
    Set 开始时间 = 入院时间_In, 病区id = 病区id_In, 科室id = 入院科室id_In, 护理等级id = Decode(护理等级id_In, 0, Null, 护理等级id_In), 病情 = 入院病况_In,
        操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And 开始原因 = 1;
  
    --处理门诊诊断
    If 门诊诊断_In Is Null And 疾病id_In Is Null Then
      Delete From 病人诊断记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 诊断类型 = 1 And 记录来源 = 2;
    Else
      Update 病人诊断记录
      Set 疾病id = 疾病id_In, 诊断id = 诊断id_In, 诊断描述 = 门诊诊断_In, 记录日期 = Sysdate, 记录人 = 操作员姓名_In
      Where 病人id = 病人id_In And 主页id = 主页id_In And 诊断类型 = 1 And 记录来源 = 2;
      If Sql%RowCount = 0 Then
        Insert Into 病人诊断记录
          (ID, 病人id, 主页id, 记录来源, 诊断类型, 诊断次序, 疾病id, 诊断id, 诊断描述, 记录日期, 记录人)
        Values
          (病人诊断记录_Id.Nextval, 病人id_In, 主页id_In, 2, 1, 1, 疾病id_In, 诊断id_In, 门诊诊断_In, Sysdate, 操作员姓名_In);
      End If;
    End If;
  
    --处理中医诊断
    If 中医诊断_In Is Null And 中医疾病id_In Is Null Then
      Delete From 病人诊断记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 诊断类型 = 11 And 记录来源 = 2;
    Else
      Update 病人诊断记录
      Set 疾病id = 中医疾病id_In, 诊断id = 中医诊断id_In, 诊断描述 = 中医诊断_In, 记录日期 = Sysdate, 记录人 = 操作员姓名_In
      Where 病人id = 病人id_In And 主页id = 主页id_In And 诊断类型 = 11 And 记录来源 = 2;
      If Sql%RowCount = 0 Then
        Insert Into 病人诊断记录
          (ID, 病人id, 主页id, 记录来源, 诊断类型, 诊断次序, 疾病id, 诊断id, 诊断描述, 记录日期, 记录人)
        Values
          (病人诊断记录_Id.Nextval, 病人id_In, 主页id_In, 2, 11, 1, 中医疾病id_In, 中医诊断id_In, 中医诊断_In, Sysdate, 操作员姓名_In);
      End If;
    End If;
  End If;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_入院病案主页_Update;
/

--101262:王振涛,2017-02-13,三方检验病人医嘱报告出错
Create Or Replace Procedure Zl_检验报告单_Insert
(
  Id_In   In 病人医嘱记录.Id%Type,
  Type_In In Number -- 0=新增 1=删除 
) Is
  --HIS和其他LIS接口使用 
  v_主页id     病人医嘱记录.主页id%Type;
  v_医嘱id     病人医嘱记录.Id%Type;
  v_开嘱科室id 病人医嘱记录.开嘱科室id%Type;
  v_病人来源   检验标本记录.病人来源%Type;
  v_病人id     检验标本记录.病人id%Type;
  v_婴儿       检验标本记录.婴儿%Type;
  v_病历文件id 病历单据应用.病历文件id%Type;
  v_病历文件名 病历文件列表.名称%Type;
  v_文件id     电子病历内容.文件id%Type;
  v_Temp       Varchar2(255);
  v_人员部门id 部门人员.部门id%Type;
  v_人员编号   人员表.编号%Type;
  v_人员姓名   人员表.姓名%Type;
  v_No         病人医嘱发送.No%Type;
  v_性质       病人医嘱发送.记录性质%Type;
  v_序号       Varchar2(1000);
  v_查阅       Number;
  v_Error      Varchar2(255);
  Err_Custom Exception;
  --查找当前标本的相关申请 
  Cursor c_Samplequest Is
    Select Distinct ID As 医嘱id From 病人医嘱记录 Where Id_In In (ID, 相关id);

  --未审核的费用行(不包含药品) 
  Cursor c_Verify(v_医嘱id In Number) Is
    Select Distinct 记录性质, NO, 序号
    From 住院费用记录
    Where 收费类别 Not In ('5', '6', '7') And 医嘱序号 + 0 In (Select ID From 病人医嘱记录 Where v_医嘱id In (ID, 相关id)) And 记帐费用 = 1 And
          记录状态 = 0 And 价格父号 Is Null And
          (记录性质, NO) In (Select 记录性质, NO
                         From 病人医嘱附费
                         Where 医嘱id = v_医嘱id
                         Union All
                         Select 记录性质, NO
                         From 病人医嘱发送
                         Where 医嘱id In (Select ID From 病人医嘱记录 Where v_医嘱id In (ID, 相关id)))
    Order By 记录性质, NO, 序号;

Begin
  --操作员信息:部门ID,部门名称;人员ID,人员编号,人员姓名 
  v_Temp       := Zl_Identity;
  v_人员部门id := To_Number(Substr(v_Temp, 1, Instr(v_Temp, ',') - 1));

  v_Temp       := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_人员编号   := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_人员姓名   := Substr(v_Temp, Instr(v_Temp, ',') + 1);

  Select Distinct Nvl(b.主页id, 0), Nvl(b.相关id, 0), Decode(b.病人来源, 2, 2, 4, 4, 1), Nvl(b.病人id, 0), Nvl(b.开嘱科室id, 0),
                  Nvl(b.婴儿, 0)
  Into v_主页id, v_医嘱id, v_病人来源, v_病人id, v_开嘱科室id, v_婴儿
  From 病人医嘱记录 B
  Where b.相关id = Id_In;
  If v_病人来源 = 1 Then
    --主页ID： 门诊病人填挂号ID
    Select Nvl(max(b.Id), 0) Into v_主页id From 病人挂号记录 B, 病人医嘱记录 A Where a.挂号单 = b.No(+) And a.Id = Id_In;
  End If;
  Begin
    Select 病历文件id, c.名称
    Into v_病历文件id, v_病历文件名
    From 病人医嘱记录 A, 病历单据应用 B, 病历文件列表 C
    Where a.诊疗项目id = b.诊疗项目id And b.病历文件id = c.Id And a.相关id = v_医嘱id And b.应用场合 = v_病人来源 And Rownum <= 1;
  Exception
    When Others Then
      Return;
  End;

  If Type_In = 0 Then
    --新增 
    --删除以前的报告记录 
    Begin
      Select Nvl(病历id, 0) Into v_文件id From 病人医嘱报告 Where 医嘱id = v_医嘱id And Rownum <= 1;
      If v_文件id > 0 Then
        Delete 电子病历记录 Where ID = v_文件id;
        Delete 电子病历内容 Where 文件id = v_文件id;
      End If;
    Exception
      When Others Then
        Select 电子病历记录_Id.Nextval Into v_文件id From Dual;
        --Insert Into 病人医嘱报告 (医嘱id, 病历id) Values (v_医嘱id, v_文件id); 
    End;
  
    Insert Into 电子病历记录
      (ID, 病人来源, 病人id, 主页id, 婴儿, 科室id, 病历种类, 文件id, 病历名称, 创建人, 创建时间, 保存人, 保存时间, 最后版本, 签名级别)
    Values
      (v_文件id, v_病人来源, v_病人id, v_主页id, v_婴儿, v_开嘱科室id, 7, v_病历文件id, v_病历文件名, Null, Sysdate, Null, Sysdate, 1, 0);
  
    Insert Into 病人医嘱报告 (医嘱id, 病历id) Values (v_医嘱id, v_文件id);
  
    Insert Into 电子病历内容
      (ID, 文件id, 开始版, 终止版, 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行)
    Values
      (电子病历内容_Id.Nextval, v_文件id, 1, 1, Null, 1, 2, Null, Null, 0, 0, 0, 0);
  
    Update 病人医嘱发送 Set 执行状态 = 1 Where 医嘱id In (Select ID From 病人医嘱记录 Where v_医嘱id In (ID, 相关id));
  
    --2.检查当前标本相关的申请的相关标本是否完成审核 
    For r_Samplequest In c_Samplequest Loop
    
      --r_SampleQuest.医嘱id申请已经完成,处理后续环节 
    
      --2.费用执行处理 
      If v_性质 = 1 Then
        Update 门诊费用记录
        Set 执行状态 = 1, 执行时间 = Sysdate, 执行人 = v_人员姓名
        Where 收费类别 Not In ('5', '6', '7') And
              (医嘱序号, 记录性质, NO) In
              (Select 医嘱id, 记录性质, NO
               From 病人医嘱附费
               Where 医嘱id = r_Samplequest.医嘱id
               Union All
               Select 医嘱id, 记录性质, NO
               From 病人医嘱发送
               Where 医嘱id In (Select ID From 病人医嘱记录 Where r_Samplequest.医嘱id In (ID, 相关id)));
      Else
        Update 住院费用记录
        Set 执行状态 = 1, 执行时间 = Sysdate, 执行人 = v_人员姓名
        Where 收费类别 Not In ('5', '6', '7') And
              (医嘱序号, 记录性质, NO) In
              (Select 医嘱id, 记录性质, NO
               From 病人医嘱附费
               Where 医嘱id = r_Samplequest.医嘱id
               Union All
               Select 医嘱id, 记录性质, NO
               From 病人医嘱发送
               Where 医嘱id In (Select ID From 病人医嘱记录 Where r_Samplequest.医嘱id In (ID, 相关id)));
      End If;
      --3.自动审核记帐 
      For r_Verify In c_Verify(r_Samplequest.医嘱id) Loop
        If r_Verify.No || ',' || r_Verify.记录性质 <> v_No || ',' || v_性质 Then
          If v_序号 Is Not Null Then
            If v_性质 = 1 Then
              Zl_门诊记帐记录_Verify(v_No, v_人员编号, v_人员姓名, Substr(v_序号, 2));
            Elsif v_性质 = 2 Then
              Zl_住院记帐记录_Verify(v_No, v_人员编号, v_人员姓名, Substr(v_序号, 2));
            End If;
          End If;
          v_序号 := Null;
        End If;
        v_No   := r_Verify.No;
        v_性质 := r_Verify.记录性质;
        v_序号 := v_序号 || ',' || r_Verify.序号;
      End Loop;
      If v_序号 Is Not Null Then
        If v_性质 = 1 Then
          Zl_门诊记帐记录_Verify(v_No, v_人员编号, v_人员姓名, Substr(v_序号, 2));
        Elsif v_性质 = 2 Then
          Zl_住院记帐记录_Verify(v_No, v_人员编号, v_人员姓名, Substr(v_序号, 2));
        End If;
      End If;
    
    End Loop;
  Else
    --删除 
  
    v_查阅 := 0;
    Select Nvl(查阅状态, 0) Into v_查阅 From 病人医嘱报告 Where 医嘱id = v_医嘱id;
    If v_查阅 = 0 Then
      Select 病历id Into v_文件id From 病人医嘱报告 Where 医嘱id = v_医嘱id And Rownum <= 1;
      Delete 病人医嘱报告 Where 医嘱id = v_医嘱id;
      Delete 电子病历记录 Where ID = v_文件id;
      Delete 电子病历内容 Where 文件id = v_文件id;
      Update 病人医嘱发送
      Set 执行状态 = 0
      Where 医嘱id In (Select ID From 病人医嘱记录 Where v_医嘱id In (ID, 相关id));
      For r_Samplequest In c_Samplequest Loop
        --2.费用执行处理 
        If v_性质 = 1 Then
          Update 门诊费用记录
          Set 执行状态 = 0, 执行时间 = Null, 执行人 = Null
          Where 收费类别 Not In ('5', '6', '7') And
                (医嘱序号, 记录性质, NO) In
                (Select 医嘱id, 记录性质, NO
                 From 病人医嘱附费
                 Where 医嘱id = r_Samplequest.医嘱id
                 Union All
                 Select 医嘱id, 记录性质, NO
                 From 病人医嘱发送
                 Where 医嘱id In (Select ID From 病人医嘱记录 Where r_Samplequest.医嘱id In (ID, 相关id)));
        Else
          Update 住院费用记录
          Set 执行状态 = 0, 执行时间 = Null, 执行人 = Null
          Where 收费类别 Not In ('5', '6', '7') And
                (医嘱序号, 记录性质, NO) In
                (Select 医嘱id, 记录性质, NO
                 From 病人医嘱附费
                 Where 医嘱id = r_Samplequest.医嘱id
                 Union All
                 Select 医嘱id, 记录性质, NO
                 From 病人医嘱发送
                 Where 医嘱id In (Select ID From 病人医嘱记录 Where r_Samplequest.医嘱id In (ID, 相关id)));
        End If;
      End Loop;
    Else
      v_Error := '该报告已经被医生查阅，不能取消，请联系医生。';
      Raise Err_Custom;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_检验报告单_Insert;
/

--103325:冉俊明,2017-02-09,整周跨月的周出诊表调整。
Create Or Replace Procedure Zl_临床出诊表_Add
(
  操作类型_In Number,
  出诊id_In   临床出诊表.Id%Type,
  出诊表名_In 临床出诊表.出诊表名%Type,
  站点_In     部门表.站点%Type,
  操作员_In   临床出诊安排.操作员姓名%Type,
  操作时间_In 临床出诊安排.登记时间%Type,
  开始时间_In 临床出诊安排.开始时间%Type := Null,
  终止时间_In 临床出诊安排.终止时间%Type := Null,
  年份_In     临床出诊表.年份%Type := Null,
  月份_In     临床出诊表.月份%Type := Null,
  周数_In     临床出诊表.周数%Type := Null,
  应用范围_In 临床出诊表.应用范围%Type := Null,
  科室id_In   临床出诊表.科室id%Type := Null,
  备注_In     临床出诊表.备注%Type := Null,
  人员id_In   人员表.Id%Type := Null,
  删除安排_In Number := 0,
  模板类型_In 临床出诊表.模板类型%Type := Null
) As
  --功能：增加出诊表或模板
  --参数：
  --        操作类型_In 1-模板，2-固定安排, 3-月安排，4-周安排
  --        人员id_In 除固定安排外有效，不为0或null表示临床科室人员在添加
  --        删除安排_In 固定排班转为月排班/周排班时，在制定月排班/周排班时是否删除新出诊表时间内未使用的出诊记录
  --说明：
  v_Err_Msg Varchar2(255);
  Err_Item Exception;
  n_Count Number(8);

  n_出诊id       临床出诊表.Id%Type;
  n_跨月周出诊id 临床出诊表.Id%Type;
  n_跨月周安排id 临床出诊安排.Id%Type;

  l_记录id t_Numlist := t_Numlist();

  Function Get跨月周出诊id(出诊id_In 临床出诊表.Id%Type) Return 临床出诊表.Id%Type Is
    ----------------------------------------
    --如果原周出诊表不是整周(不足7天)，则需要查找到另一个出诊表构成整周
    ----------------------------------------
    n_出诊id 临床出诊表.Id%Type;
    n_年份   临床出诊表.年份%Type;
    n_月份   临床出诊表.月份%Type;
    n_周数   临床出诊表.周数%Type;
  
    d_开始时间 临床出诊安排.开始时间%Type;
    d_结束时间 临床出诊安排.终止时间%Type;
  
    --根据日期计算当月的周数，以及每一周的时间范围
    Cursor c_Weekrange(Date_In Date) Is
      Select Rownum As 周数, 开始日期, 结束日期
      From (With Month_Range As (Select Trunc(Date_In) As First_Day, Last_Day(Trunc(Date_In)) As Last_Day From Dual)
             Select Decode(To_Char(First_Day, 'day'), '星期日', First_Day, Null) As 开始日期,
                    Decode(To_Char(First_Day, 'day'), '星期日', First_Day, Null) As 结束日期
             From Month_Range
             Union All
             Select Decode(Sign(Trunc(First_Day + 7 * Week, 'day') + 1 - First_Day), 1,
                            Trunc(First_Day + 7 * Week, 'day') + 1, First_Day) As 开始日期,
                    Decode(Sign(Trunc(First_Day + 7 * Week, 'day') + 7 - Last_Day), 1, Last_Day,
                            Trunc(First_Day + 7 * Week, 'day') + 7) As 结束日期
             From Month_Range A, (Select Level - 1 As Week From Dual Connect By Level <= 6) B)
             Where 开始日期 <= 结束日期;
  
  
  Begin
    Begin
      Select 年份, 月份, 周数 Into n_年份, n_月份, n_周数 From 临床出诊表 Where ID = 出诊id_In;
    Exception
      When Others Then
        Return 0;
    End;
  
    If n_年份 Is Null Or n_月份 Is Null Or n_周数 Is Null Then
      Return 0;
    End If;
  
    For r_Weekrange In c_Weekrange(To_Date(n_年份 || '-' || n_月份 || '-01', 'yyyy-mm-dd')) Loop
      If r_Weekrange.周数 = n_周数 Then
        d_开始时间 := r_Weekrange.开始日期;
        d_结束时间 := r_Weekrange.结束日期;
        Exit;
      End If;
    End Loop;
  
    If d_开始时间 Is Null Or d_结束时间 Is Null Then
      Return 0;
    End If;
    If Trunc(d_结束时间) - Trunc(d_开始时间) >= 6 Then
      Return 0;
    End If;
  
    --存在跨月的，查找另一个出诊表的年月周
    n_年份 := Null;
    n_月份 := Null;
    n_周数 := Null;
    If Trunc(d_开始时间 - 1, 'month') <> Trunc(d_开始时间, 'month') Then
      --当前是第一周,获取另一个出诊表的年月
      n_年份 := To_Number(To_Char(d_开始时间 - 1, 'yyyy'));
      n_月份 := To_Number(To_Char(d_开始时间 - 1, 'mm'));
    Elsif Trunc(d_结束时间 + 1, 'month') <> Trunc(d_结束时间, 'month') Then
      --当前是最后一周,获取另一个出诊表的年月
      n_年份 := To_Number(To_Char(d_结束时间 + 1, 'yyyy'));
      n_月份 := To_Number(To_Char(d_结束时间 + 1, 'mm'));
      n_周数 := 1;
    Else
      Return 0;
    End If;
  
    --获取跨月的另一个出诊表的ID
    Begin
      Select ID
      Into n_出诊id
      From (Select Rownum As 行号, ID
             From 临床出诊表
             Where Nvl(排班方式, 0) = 2 And 年份 = n_年份 And 月份 = n_月份 And (n_周数 Is Null Or 周数 = n_周数)
             Order By 周数 Desc)
      Where 行号 < 2;
    Exception
      When Others Then
        Return 0;
    End;
  
    Return n_出诊id;
  End;
Begin
  n_出诊id := 出诊id_In;
  If Nvl(n_出诊id, 0) = 0 Then
    Select 临床出诊表_Id.Nextval Into n_出诊id From Dual;
  End If;

  --排班方式：0-固定排班;1-按月排班;2-按周排班;3-模板
  --============================================================================================================================================
  --1.模板
  If Nvl(操作类型_In, 0) = 1 Then
    Begin
      Select 1 Into n_Count From 临床出诊表 Where 出诊表名 = 出诊表名_In And 排班方式 = 3 And Rownum < 2;
    Exception
      When Others Then
        n_Count := 0;
    End;
    If Nvl(n_Count, 0) > 0 Then
      v_Err_Msg := '当前已存在名为“' || 出诊表名_In || '”的模板！';
      Raise Err_Item;
    End If;
  
    --检查是否有可操作的有效号源
    Begin
      Select 1
      Into n_Count
      From 临床出诊号源 A, 部门表 D
      Where a.科室id = d.Id And a.排班方式 = Decode(Nvl(模板类型_In, 0), 0, 2, 1) And Nvl(a.是否删除, 0) = 0 And
            (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd'))
           --当前人员可操作的号源
            And (Nvl(人员id_In, 0) = 0 Or
            (Nvl(a.是否临床排班, 0) = 1 And Exists (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
           --站点
            And (d.站点 Is Null Or d.站点 = 站点_In) And Rownum < 2;
    Exception
      When Others Then
        n_Count := 0;
    End;
    If Nvl(n_Count, 0) = 0 Then
      If Nvl(模板类型_In, 0) = 0 Then
        v_Err_Msg := '当前无可按周排班的号源，不能新增模板，请先到“基础设置>临床号源管理”中添加出诊号源！';
      Else
        v_Err_Msg := '当前无可按月排班的号源，不能新增模板，请先到“基础设置>临床号源管理”中添加出诊号源！';
      End If;
      Raise Err_Item;
    End If;
  
    --模板，肯定是新出诊表
    Insert Into 临床出诊表
      (ID, 排班方式, 出诊表名, 应用范围, 科室id, 备注, 发布人, 发布时间, 模板类型)
    Values
      (n_出诊id, 3, 出诊表名_In, 应用范围_In, 科室id_In, 备注_In, 操作员_In, 操作时间_In, 模板类型_In);
  
    --临床出诊安排
    For c_号源 In (Select 临床出诊安排_Id.Nextval As 安排id, n_出诊id As 出诊id, a.Id As 号源id, a.项目id, a.医生id, a.医生姓名
                 From 临床出诊号源 A, 部门表 D
                 Where a.科室id = d.Id And a.排班方式 = Decode(Nvl(模板类型_In, 0), 0, 2, 1) And Nvl(a.是否删除, 0) = 0 And
                       (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd'))
                      --当前人员可操作的号源
                       And (Nvl(人员id_In, 0) = 0 Or (Nvl(a.是否临床排班, 0) = 1 And Exists
                        (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
                      --站点
                       And (d.站点 Is Null Or d.站点 = 站点_In)) Loop
    
      If Nvl(模板类型_In, 0) = 2 Then
        --2-按天排班的月排班模板，排班规则缺省为6-特定日期
        Insert Into 临床出诊安排
          (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 排班规则, 操作员姓名, 登记时间)
        Values
          (c_号源.安排id, c_号源.出诊id, c_号源.号源id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, 6, 操作员_In, 操作时间_In);
      Else
        Insert Into 临床出诊安排
          (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 排班规则, 操作员姓名, 登记时间)
        Values
          (c_号源.安排id, c_号源.出诊id, c_号源.号源id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, 1, 操作员_In, 操作时间_In);
      End If;
    End Loop;
    Return;
  End If;

  --============================================================================================================================================
  --2.固定排班
  If Nvl(操作类型_In, 0) = 2 Then
    Begin
      Select 1 Into n_Count From 临床出诊表 Where 出诊表名 = 出诊表名_In And 排班方式 = 0 And Rownum < 2;
    Exception
      When Others Then
        n_Count := 0;
    End;
    If Nvl(n_Count, 0) > 0 Then
      v_Err_Msg := '当前已存在名为“' || 出诊表名_In || '”的固定出诊表！';
      Raise Err_Item;
    End If;
  
    --检查是否有有效号源
    Begin
      Select 1
      Into n_Count
      From 临床出诊号源 A, 部门表 D
      Where a.科室id = d.Id And a.排班方式 = 0 And Nvl(a.是否删除, 0) = 0 And
            (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd'))
           --站点
            And (d.站点 Is Null Or d.站点 = 站点_In) And Rownum < 2;
    Exception
      When Others Then
        n_Count := 0;
    End;
    If Nvl(n_Count, 0) = 0 Then
      v_Err_Msg := '当前无可按固定排班的号源，不能新增固定安排，请先到“基础设置>临床号源管理”中添加出诊号源！';
      Raise Err_Item;
    End If;
  
    --固定安排，肯定是新出诊表,只有有"所有科室"权限的人才能新增
    Insert Into 临床出诊表
      (ID, 排班方式, 出诊表名, 年份)
    Values
      (n_出诊id, 0, 出诊表名_In, To_Number(To_Char(开始时间_In, 'yyyy')));
  
    --缺省加入上一次有效的出诊安排
    For c_号源 In (Select 临床出诊安排_Id.Nextval As 安排id, n_出诊id As 出诊id, 原安排id, 号源id, 项目id, 医生id, 医生姓名
                 From (Select a.Id As 原安排id, b.Id As 号源id, b.项目id, b.医生id, b.医生姓名,
                               Row_Number() Over(Partition By b.Id Order By a.开始时间 Desc) As 组号
                        From 临床出诊安排 A, 临床出诊号源 B, 临床出诊表 C, 部门表 D
                        Where a.号源id = b.Id And a.出诊id = c.Id And b.科室id = d.Id
                             --号源限制
                              And b.排班方式 = 0 And Nvl(b.是否删除, 0) = 0 And
                              (b.撤档时间 Is Null Or b.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd'))
                             --上一次出诊安排限制
                              And c.发布人 Is Not Null And c.排班方式 = 0 And (d.站点 Is Null Or d.站点 = 站点_In)) M
                 Where 组号 = 1) Loop
    
      Insert Into 临床出诊安排
        (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 开始时间, 终止时间, 操作员姓名, 登记时间)
      Values
        (c_号源.安排id, c_号源.出诊id, c_号源.号源id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, 开始时间_In, 终止时间_In, 操作员_In, 操作时间_In);
    
      --复制出诊安排
      For c_限制 In (Select ID From 临床出诊限制 Where 安排id = c_号源.原安排id) Loop
        Zl_临床出诊限制_Copy(c_限制.Id, c_号源.安排id);
      End Loop;
    End Loop;
  
    --加入无上一次有效出诊安排的号源
    For c_号源 In (Select 临床出诊安排_Id.Nextval As 安排id, n_出诊id As 出诊id, a.Id As 号源id, a.项目id, a.医生id, a.医生姓名
                 From 临床出诊号源 A, 部门表 D
                 Where a.科室id = d.Id And a.排班方式 = 0 And Nvl(a.是否删除, 0) = 0 And
                       (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd'))
                      --站点
                       And (d.站点 Is Null Or d.站点 = 站点_In)
                      
                       And Not Exists (Select 1 From 临床出诊安排 Where 出诊id = n_出诊id And 号源id = a.Id)) Loop
    
      Insert Into 临床出诊安排
        (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 开始时间, 终止时间, 操作员姓名, 登记时间)
      Values
        (c_号源.安排id, c_号源.出诊id, c_号源.号源id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, 开始时间_In, 终止时间_In, 操作员_In, 操作时间_In);
    End Loop;
    Return;
  End If;

  --============================================================================================================================================
  --月排班、周排班
  --检查是否有有效号源
  Begin
    Select 1
    Into n_Count
    From 临床出诊号源 A, 部门表 B
    Where a.科室id = b.Id
         --有效号源
          And Nvl(a.是否删除, 0) = 0 And (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
          (
          --月排班
           Nvl(操作类型_In, 0) = 3 And a.排班方式 = 1
          --周排班
           Or Nvl(操作类型_In, 0) = 4 And
           (
           --当前出诊表所在时间范围内不能有月排班
            a.排班方式 = 2 And Not Exists
            (Select 1
                From 临床出诊安排 P, 临床出诊表 Q
                Where p.出诊id = q.Id And p.号源id = a.Id And
                      Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 1)
           --当前已调整为了月排班,但是本月又用了周排班，则本月剩下的部分将继续按周进行排班
            Or a.排班方式 = 1 And Exists
            (Select 1
                From 临床出诊安排 P, 临床出诊表 Q
                Where p.出诊id = q.Id And p.号源id = a.Id And
                      Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 2)))
         --号源在该出诊表时间范围内无出诊记录
          And Not Exists
     (Select 1
           From 临床出诊记录 O, 临床出诊安排 P, 临床出诊表 Q
           Where o.安排id = p.Id And p.出诊id = q.Id And p.号源id = a.Id And o.出诊日期 Between 开始时间_In And 终止时间_In And
                 (q.排班方式 In (1, 2)
                 --原来为固定出诊安排
                 Or q.排班方式 = 0 And (Nvl(删除安排_In, 0) = 0 Or Nvl(删除安排_In, 0) = 1 And Exists
                  (Select 1 From 病人挂号记录 Where 出诊记录id = a.Id))))
         --当前人员可操作的号源
          And (Nvl(人员id_In, 0) = 0 Or
          (Nvl(a.是否临床排班, 0) = 1 And Exists (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
         --站点
          And (b.站点 Is Null Or b.站点 = 站点_In) And Rownum < 2;
  Exception
    When Others Then
      n_Count := 0;
  End;
  If Nvl(n_Count, 0) = 0 Then
    If Nvl(操作类型_In, 0) = 3 Then
      v_Err_Msg := '当前无可按月排班的号源，不能新增月出诊表，请先到“基础设置>临床号源管理”中添加出诊号源！';
    Else
      v_Err_Msg := '当前无可按周排班的号源，不能新增周出诊表，请先到“基础设置>临床号源管理”中添加出诊号源！';
    End If;
    Raise Err_Item;
  End If;

  --出诊表存在，则不再新增出诊表，直接向该出诊表添加上次有效号源安排即可
  --涉及到临床排班，当前操作员可能只能操作某一部分号源
  Begin
    Select 1 Into n_Count From 临床出诊表 Where ID = n_出诊id;
  Exception
    When Others Then
      n_Count := 0;
  End;
  If Nvl(n_Count, 0) = 0 Then
    Insert Into 临床出诊表
      (ID, 排班方式, 出诊表名, 年份, 月份, 周数)
    Values
      (n_出诊id,
       Case
          When Nvl(操作类型_In, 0) = 3 Then
           1
          Else
           2
        End, 出诊表名_In, 年份_In, 月份_In, 周数_In);
  End If;

  --如果当前出诊表时间范围内无挂号且无预约的出诊记录(固定安排)，则删除这部分出诊记录(在删除出诊表时可恢复)，程序中已询问

  If Nvl(删除安排_In, 0) = 1 Then
    For c_安排 In (Select b.Id As 安排id
                 From 临床出诊安排 B, 临床出诊表 C, 临床出诊号源 D
                 Where b.出诊id = c.Id And b.号源id = d.Id
                      --号源
                       And Nvl(d.是否删除, 0) = 0 And (d.撤档时间 Is Null Or d.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
                       Nvl(d.排班方式, 0) = Decode(Nvl(操作类型_In, 0), 3, 1, 2)
                      --安排有被使用了的出诊记录
                       And c.排班方式 = 0 And b.终止时间 >= 开始时间_In And Not Exists
                  (Select 1
                        From 临床出诊记录 M, 病人挂号记录 N
                        Where m.安排id = b.Id And m.Id = n.出诊记录id And m.出诊日期 >= 开始时间_In)
                      --当前人员可操作的号源
                       And (Nvl(人员id_In, 0) = 0 Or (Nvl(d.是否临床排班, 0) = 1 And Exists
                        (Select 1 From 部门人员 Where 部门id = d.科室id And 人员id = 人员id_In)))) Loop
    
      For c_记录 In (Select ID As 记录id From 临床出诊记录 Where 安排id = c_安排.安排id And 出诊日期 >= 开始时间_In) Loop
        l_记录id.Extend();
        l_记录id(l_记录id.Count) := c_记录.记录id;
      End Loop;
    End Loop;
    Zl_临床出诊记录_Batchdelete(l_记录id);
  
  End If;

  --缺省加入上一次有效的出诊安排
  For c_号源 In (Select 临床出诊安排_Id.Nextval As 安排id, n_出诊id As 出诊id, 原安排id, 号源id, 项目id, 医生id, 医生姓名, 原出诊id
               From (Select a.Id As 原安排id, b.Id As 号源id, b.项目id, b.医生id, b.医生姓名, c.Id As 原出诊id,
                             Row_Number() Over(Partition By b.Id Order By a.开始时间 Desc) As 组号
                      From 临床出诊安排 A, 临床出诊号源 B, 临床出诊表 C, 部门表 D
                      Where a.号源id = b.Id And a.出诊id = c.Id And b.科室id = d.Id
                           --有效号源
                            And Nvl(b.是否删除, 0) = 0 And
                            Nvl(b.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                            (
                            --月排班
                             Nvl(操作类型_In, 0) = 3 And b.排班方式 = 1
                            --周排班
                             Or
                             Nvl(操作类型_In, 0) = 4 And
                             (
                             --当前出诊表所在时间范围内不能有月排班
                              b.排班方式 = 2 And Not Exists
                              (Select 1
                               From 临床出诊安排 P, 临床出诊表 Q
                               Where p.出诊id = q.Id And p.号源id = b.Id And
                                     Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 1)
                             --当前已调整为了月排班,但是本月又用了周排班，则本月剩下的部分将继续按周进行排班
                              Or b.排班方式 = 1 And Exists
                              (Select 1
                               From 临床出诊安排 P, 临床出诊表 Q
                               Where p.出诊id = q.Id And p.号源id = b.Id And
                                     Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 2)))
                           --上一次有效出诊安排
                            And c.发布人 Is Not Null And c.排班方式 = Decode(Nvl(操作类型_In, 0), 3, 1, 2)
                           --号源在该出诊表时间范围内无出诊记录
                            And Not Exists (Select 1
                             From 临床出诊记录 P
                             Where p.号源id = b.Id And p.出诊日期 Between 开始时间_In And 终止时间_In)
                           --当前人员可操作的号源
                            And (Nvl(人员id_In, 0) = 0 Or
                            (Nvl(b.是否临床排班, 0) = 1 And Exists
                             (Select 1 From 部门人员 Where 部门id = b.科室id And 人员id = 人员id_In)))
                           --站点
                            And (d.站点 Is Null Or d.站点 = 站点_In))
               Where 组号 = 1) Loop
  
    Insert Into 临床出诊安排
      (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 开始时间, 终止时间, 操作员姓名, 登记时间)
    Values
      (c_号源.安排id, c_号源.出诊id, c_号源.号源id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, 开始时间_In, 终止时间_In, 操作员_In, 操作时间_In);
  
    --整周跨月的周出诊表需要找到相邻的出诊表的安排
    n_跨月周安排id := 0;
    If Nvl(操作类型_In, 0) = 4 Then
      n_跨月周出诊id := Get跨月周出诊id(c_号源.原出诊id);
      If Nvl(n_跨月周出诊id, 0) <> 0 Then
        Begin
          Select a.Id
          Into n_跨月周安排id
          From 临床出诊安排 A, 临床出诊表 B
          Where a.出诊id = b.Id And b.Id = n_跨月周出诊id And a.号源id = c_号源.号源id And b.发布时间 Is Not Null;
        Exception
          When Others Then
            n_跨月周安排id := 0;
        End;
      End If;
    End If;
  
    --复制出诊安排
    For c_记录 In (Select Decode(b.Id, Null, a.Id, b.Id) As ID, c.日期
                 From 临床出诊记录 A, 临床出诊记录 B,
                      (Select Trunc(开始时间_In) + Level - 1 As 日期
                        From Dual
                        Connect By Level <= Trunc(终止时间_In) - Trunc(开始时间_In) + 1) C
                 Where a.Id = b.相关id(+) And (a.安排id = c_号源.原安排id Or a.安排id = n_跨月周安排id) And a.相关id Is Null And
                       Nvl(a.是否临时出诊, 0) = 0
                      --月排班
                       And (Nvl(操作类型_In, 0) = 3 And To_Char(a.出诊日期, 'dd') = To_Char(c.日期, 'dd')
                       --周排班
                       Or Nvl(操作类型_In, 0) = 4 And To_Char(a.出诊日期, 'D') = To_Char(c.日期, 'D'))) Loop
      Zl_临床出诊记录_Copy(c_记录.Id, c_号源.安排id, c_记录.日期, 操作员_In, 操作时间_In);
    End Loop;
  End Loop;

  --加入无上一次有效出诊安排的号源
  For c_号源 In (Select 临床出诊安排_Id.Nextval As 安排id, n_出诊id As 出诊id, a.Id As 号源id, a.项目id, a.医生id, a.医生姓名
               From 临床出诊号源 A, 部门表 D
               Where a.科室id = d.Id
                    --有效号源
                     And Nvl(a.是否删除, 0) = 0 And (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
                     (
                     --月排班
                      Nvl(操作类型_In, 0) = 3 And a.排班方式 = 1
                     --周排班
                      Or Nvl(操作类型_In, 0) = 4 And
                      (
                      --当前出诊表所在时间范围内不能有月排班
                       a.排班方式 = 2 And Not Exists
                       (Select 1
                           From 临床出诊安排 P, 临床出诊表 Q
                           Where p.出诊id = q.Id And p.号源id = a.Id And
                                 Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 1)
                      --当前已调整为了月排班,但是本月又用了周排班，则本月剩下的部分将继续按周进行排班
                       Or a.排班方式 = 1 And Exists
                       (Select 1
                           From 临床出诊安排 P, 临床出诊表 Q
                           Where p.出诊id = q.Id And p.号源id = a.Id And
                                 Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 2)))
                    --号源在该出诊表时间范围内无出诊记录
                     And Not Exists
                (Select 1
                      From 临床出诊记录 P
                      Where p.号源id = a.Id And p.出诊日期 Between 开始时间_In And 终止时间_In)
                    --当前人员可操作的号源
                     And (Nvl(人员id_In, 0) = 0 Or (Nvl(a.是否临床排班, 0) = 1 And Exists
                      (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
                    --站点
                     And (d.站点 Is Null Or d.站点 = 站点_In)
                    
                     And Not Exists (Select 1 From 临床出诊安排 Where 出诊id = n_出诊id And 号源id = a.Id)) Loop
  
    Insert Into 临床出诊安排
      (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 开始时间, 终止时间, 操作员姓名, 登记时间)
    Values
      (c_号源.安排id, c_号源.出诊id, c_号源.号源id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, 开始时间_In, 终止时间_In, 操作员_In, 操作时间_In);
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊表_Add;
/

--103325:冉俊明,2017-02-09,整周跨月的周出诊表调整。
Create Or Replace Procedure Zl_Buildregisterplanbyrecord
(
  原出诊id_In   临床出诊表.Id%Type,
  新出诊id_In   临床出诊表.Id%Type,
  排班方式_In   临床出诊表.排班方式%Type,
  出诊表名_In   临床出诊表.出诊表名%Type,
  年份_In       临床出诊表.年份%Type,
  月份_In       临床出诊表.月份%Type,
  周数_In       临床出诊表.周数%Type,
  开始时间_In   临床出诊安排.开始时间%Type,
  终止时间_In   临床出诊安排.终止时间%Type,
  操作员姓名_In 临床出诊安排.操作员姓名%Type,
  登记时间_In   临床出诊安排.登记时间%Type,
  站点_In       部门表.站点%Type,
  人员id_In     人员表.Id%Type := Null,
  删除安排_In   Number := 0
) As
  -------------------------------------------------------------------------
  --功能：根据出诊记录生成新的出诊记录（月安排/周安排）
  --参数：
  --        人员id_In 除固定安排外有效，不为0或null表示临床科室人员在添加
  --        删除安排_In 固定排班转为月排班/周排班时，在制定月排班/周排班时是否删除新出诊表时间内未使用的出诊记录
  --说明：
  -------------------------------------------------------------------------
  n_Count Number;

  l_记录id t_Numlist := t_Numlist();
  n_安排id 临床出诊安排.Id%Type;

  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  n_跨月周出诊id 临床出诊表.Id%Type;

  Function Get跨月周出诊id(出诊id_In 临床出诊表.Id%Type) Return 临床出诊表.Id%Type Is
    ----------------------------------------
    --如果原周出诊表不是整周(不足7天)，则需要查找到另一个出诊表构成整周
    ----------------------------------------
    n_出诊id 临床出诊表.Id%Type;
    n_年份   临床出诊表.年份%Type;
    n_月份   临床出诊表.月份%Type;
    n_周数   临床出诊表.周数%Type;
  
    d_开始时间 临床出诊安排.开始时间%Type;
    d_结束时间 临床出诊安排.终止时间%Type;
  
    --根据日期计算当月的周数，以及每一周的时间范围
    Cursor c_Weekrange(Date_In Date) Is
      Select Rownum As 周数, 开始日期, 结束日期
      From (With Month_Range As (Select Trunc(Date_In) As First_Day, Last_Day(Trunc(Date_In)) As Last_Day From Dual)
             Select Decode(To_Char(First_Day, 'day'), '星期日', First_Day, Null) As 开始日期,
                    Decode(To_Char(First_Day, 'day'), '星期日', First_Day, Null) As 结束日期
             From Month_Range
             Union All
             Select Decode(Sign(Trunc(First_Day + 7 * Week, 'day') + 1 - First_Day), 1,
                            Trunc(First_Day + 7 * Week, 'day') + 1, First_Day) As 开始日期,
                    Decode(Sign(Trunc(First_Day + 7 * Week, 'day') + 7 - Last_Day), 1, Last_Day,
                            Trunc(First_Day + 7 * Week, 'day') + 7) As 结束日期
             From Month_Range A, (Select Level - 1 As Week From Dual Connect By Level <= 6) B)
             Where 开始日期 <= 结束日期;
  
  
  Begin
    Begin
      Select 年份, 月份, 周数 Into n_年份, n_月份, n_周数 From 临床出诊表 Where ID = 出诊id_In;
    Exception
      When Others Then
        Return 0;
    End;
  
    If n_年份 Is Null Or n_月份 Is Null Or n_周数 Is Null Then
      Return 0;
    End If;
  
    For r_Weekrange In c_Weekrange(To_Date(n_年份 || '-' || n_月份 || '-01', 'yyyy-mm-dd')) Loop
      If r_Weekrange.周数 = n_周数 Then
        d_开始时间 := r_Weekrange.开始日期;
        d_结束时间 := r_Weekrange.结束日期;
        Exit;
      End If;
    End Loop;
  
    If d_开始时间 Is Null Or d_结束时间 Is Null Then
      Return 0;
    End If;
    If Trunc(d_结束时间) - Trunc(d_开始时间) >= 6 Then
      Return 0;
    End If;
  
    --存在跨月的，查找另一个出诊表的年月周
    n_年份 := Null;
    n_月份 := Null;
    n_周数 := Null;
    If Trunc(d_开始时间 - 1, 'month') <> Trunc(d_开始时间, 'month') Then
      --当前是第一周,获取另一个出诊表的年月
      n_年份 := To_Number(To_Char(d_开始时间 - 1, 'yyyy'));
      n_月份 := To_Number(To_Char(d_开始时间 - 1, 'mm'));
    Elsif Trunc(d_结束时间 + 1, 'month') <> Trunc(d_结束时间, 'month') Then
      --当前是最后一周,获取另一个出诊表的年月
      n_年份 := To_Number(To_Char(d_结束时间 + 1, 'yyyy'));
      n_月份 := To_Number(To_Char(d_结束时间 + 1, 'mm'));
      n_周数 := 1;
    Else
      Return 0;
    End If;
  
    --获取跨月的另一个出诊表的ID
    Begin
      Select ID
      Into n_出诊id
      From (Select Rownum As 行号, ID
             From 临床出诊表
             Where Nvl(排班方式, 0) = 2 And 年份 = n_年份 And 月份 = n_月份 And (n_周数 Is Null Or 周数 = n_周数)
             Order By 周数 Desc)
      Where 行号 < 2;
    Exception
      When Others Then
        Return 0;
    End;
  
    Return n_出诊id;
  End;
Begin
  Begin
    Select 1
    Into n_Count
    From 临床出诊号源 A, 部门表 B
    Where a.科室id = b.Id
         --有效号源
          And Nvl(a.是否删除, 0) = 0 And (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
          (
          --月排班
           Nvl(排班方式_In, 0) = 1 And a.排班方式 = 1
          --周排班
           Or Nvl(排班方式_In, 0) = 2 And
           (
           --当前出诊表所在时间范围内不能有月排班
            a.排班方式 = 2 And Not Exists
            (Select 1
                From 临床出诊安排 P, 临床出诊表 Q
                Where p.出诊id = q.Id And p.号源id = a.Id And
                      Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 1)
           --当前已调整为了月排班,但是本月又用了周排班，则本月剩下的部分将继续按周进行排班
            Or a.排班方式 = 1 And Exists
            (Select 1
                From 临床出诊安排 P, 临床出诊表 Q
                Where p.出诊id = q.Id And p.号源id = a.Id And
                      Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 2)))
         --号源在该出诊表时间范围内无出诊记录
          And Not Exists
     (Select 1
           From 临床出诊记录 O, 临床出诊安排 P, 临床出诊表 Q
           Where o.安排id = p.Id And p.出诊id = q.Id And p.号源id = a.Id And o.出诊日期 Between 开始时间_In And 终止时间_In And
                 (q.排班方式 In (1, 2)
                 --原来为固定出诊安排
                 Or q.排班方式 = 0 And (Nvl(删除安排_In, 0) = 0 Or Nvl(删除安排_In, 0) = 1 And Exists
                  (Select 1 From 病人挂号记录 Where 出诊记录id = a.Id))))
         --当前人员可操作的号源
          And (Nvl(人员id_In, 0) = 0 Or
          (Nvl(a.是否临床排班, 0) = 1 And Exists (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
         --站点
          And (b.站点 Is Null Or b.站点 = 站点_In) And Rownum < 2;
  Exception
    When Others Then
      n_Count := 0;
  End;
  If n_Count = 0 Then
    If Nvl(排班方式_In, 0) = 1 Then
      v_Err_Msg := '当前出诊表中已无可按月排班的号源，不能生成新的出诊表！';
    Else
      v_Err_Msg := '当前出诊表中已无可按周排班的号源，不能生成新的出诊表！';
    End If;
    Raise Err_Item;
  End If;

  --检查出诊表是否存在
  Begin
    Select 1 Into n_Count From 临床出诊表 Where ID = 新出诊id_In;
  Exception
    When Others Then
      n_Count := 0;
  End;
  If Nvl(n_Count, 0) = 0 Then
    Insert Into 临床出诊表
      (ID, 排班方式, 出诊表名, 年份, 月份, 周数)
    Values
      (新出诊id_In, 排班方式_In, 出诊表名_In, 年份_In, 月份_In, 周数_In);
  End If;

  --如果当前出诊表时间范围内无挂号且无预约的出诊记录(固定安排)，则删除这部分出诊记录(在删除出诊表时可恢复)，
  --并修改固定安排的终止时间，程序中已询问
  If Nvl(删除安排_In, 0) = 1 Then
    For c_安排 In (Select b.Id As 安排id
                 From 临床出诊安排 B, 临床出诊表 C, 临床出诊号源 D
                 Where b.出诊id = c.Id And b.号源id = d.Id
                      --号源
                       And Nvl(d.是否删除, 0) = 0 And (d.撤档时间 Is Null Or d.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
                       Nvl(d.排班方式, 0) = 排班方式_In
                      --安排有被使用了的出诊记录
                       And c.排班方式 = 0 And b.终止时间 >= 开始时间_In And Not Exists
                  (Select 1
                        From 临床出诊记录 M, 病人挂号记录 N
                        Where m.安排id = b.Id And m.Id = n.出诊记录id And m.出诊日期 >= 开始时间_In)
                      --当前人员可操作的号源
                       And (Nvl(人员id_In, 0) = 0 Or (Nvl(d.是否临床排班, 0) = 1 And Exists
                        (Select 1 From 部门人员 Where 部门id = d.科室id And 人员id = 人员id_In)))) Loop
    
      For c_记录 In (Select ID As 记录id From 临床出诊记录 Where 安排id = c_安排.安排id And 出诊日期 >= 开始时间_In) Loop
        l_记录id.Extend();
        l_记录id(l_记录id.Count) := c_记录.记录id;
      End Loop;
    End Loop;
  
    Zl_临床出诊记录_Batchdelete(l_记录id);
  
  End If;

  --如果原周出诊表不是整周(不足7天)，则需要查找到另一个出诊表构成整周
  If Nvl(排班方式_In, 0) = 2 Then
    n_跨月周出诊id := Get跨月周出诊id(原出诊id_In);
  End If;

  For c_号源 In (Select 新出诊id_In As 出诊id, b.Id As 原安排id, b.号源id, c.项目id, c.医生id, c.医生姓名
               From 临床出诊安排 B, 临床出诊号源 C, 部门表 D
               Where b.号源id = c.Id And c.科室id = d.Id And (b.出诊id = 原出诊id_In Or b.出诊id = n_跨月周出诊id)
                    --有效号源
                     And Nvl(c.是否删除, 0) = 0 And (c.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd') Or c.撤档时间 Is Null) And
                     (
                     --月排班
                      Nvl(排班方式_In, 0) = 1 And c.排班方式 = 1
                     -- 周排班
                      Or Nvl(排班方式_In, 0) = 2 And
                      (
                      --当前出诊表所在时间范围内不能有月排班
                       c.排班方式 = 2 And Not Exists
                       (Select 1
                           From 临床出诊安排 P, 临床出诊表 Q
                           Where p.出诊id = q.Id And p.号源id = c.Id And
                                 Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 1)
                      --当前已调整为了月排班,但是本月又用了周排班，则本月剩下的部分将继续按周进行排班
                       Or c.排班方式 = 1 And Exists
                       (Select 1
                           From 临床出诊安排 P, 临床出诊表 Q
                           Where p.出诊id = q.Id And p.号源id = c.Id And
                                 Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 2)))
                    --号源在该出诊表时间范围内无出诊记录
                     And Not Exists
                (Select 1
                      From 临床出诊记录 P
                      Where p.号源id = c.Id And p.出诊日期 Between 开始时间_In And 终止时间_In)
                    --当前人员可操作的号源
                     And (Nvl(人员id_In, 0) = 0 Or (Nvl(c.是否临床排班, 0) = 1 And Exists
                      (Select 1 From 部门人员 Where 部门id = c.科室id And 人员id = 人员id_In)))
                    --站点
                     And (d.站点 Is Null Or d.站点 = 站点_In)) Loop
  
    Begin
      Select ID Into n_安排id From 临床出诊安排 Where 出诊id = c_号源.出诊id And 号源id = c_号源.号源id;
    Exception
      When Others Then
        n_安排id := Null;
    End;
  
    If Nvl(n_安排id, 0) = 0 Then
      Select 临床出诊安排_Id.Nextval Into n_安排id From Dual;
    
      Insert Into 临床出诊安排
        (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 开始时间, 终止时间, 操作员姓名, 登记时间)
      Values
        (n_安排id, c_号源.出诊id, c_号源.号源id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, 开始时间_In, 终止时间_In, 操作员姓名_In, 登记时间_In);
    End If;
  
    --出诊记录
    For c_记录 In (Select Decode(b.Id, Null, a.Id, b.Id) As ID, c.日期
                 From 临床出诊记录 A, 临床出诊记录 B,
                      (Select Trunc(开始时间_In) + Level - 1 As 日期
                        From Dual
                        Connect By Level <= Trunc(终止时间_In) - Trunc(开始时间_In) + 1) C
                 Where a.Id = b.相关id(+) And a.安排id = c_号源.原安排id And a.相关id Is Null And Nvl(a.是否临时出诊, 0) = 0
                      --月排班
                       And (Nvl(排班方式_In, 0) = 1 And To_Char(a.出诊日期, 'dd') = To_Char(c.日期, 'dd')
                       --周排班
                       Or Nvl(排班方式_In, 0) = 2 And To_Char(a.出诊日期, 'D') = To_Char(c.日期, 'D'))) Loop
      Zl_临床出诊记录_Copy(c_记录.Id, n_安排id, c_记录.日期, 操作员姓名_In, 登记时间_In);
    End Loop;
  End Loop;

  --加入没有的出诊安排的号源
  For c_号源 In (Select 临床出诊安排_Id.Nextval As 安排id, 新出诊id_In As 出诊id, a.Id As 号源id, a.项目id, a.医生id, a.医生姓名
               From 临床出诊号源 A, 部门表 D
               Where a.科室id = d.Id
                    --有效号源
                     And Nvl(a.是否删除, 0) = 0 And (a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd') Or a.撤档时间 Is Null) And
                     (
                     --月排班
                      Nvl(排班方式_In, 0) = 1 And a.排班方式 = 1
                     -- 周排班
                      Or Nvl(排班方式_In, 0) = 2 And
                      (
                      --当前出诊表所在时间范围内不能有月排班
                       a.排班方式 = 2 And Not Exists
                       (Select 1
                           From 临床出诊安排 P, 临床出诊表 Q
                           Where p.出诊id = q.Id And p.号源id = a.Id And
                                 Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 1)
                      --当前已调整为了月排班,但是本月又用了周排班，则本月剩下的部分将继续按周进行排班
                       Or a.排班方式 = 1 And Exists
                       (Select 1
                           From 临床出诊安排 P, 临床出诊表 Q
                           Where p.出诊id = q.Id And p.号源id = a.Id And
                                 Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 2)))
                    --号源在该出诊表时间范围内无出诊记录
                     And Not Exists
                (Select 1
                      From 临床出诊记录 P
                      Where p.号源id = a.Id And p.出诊日期 Between 开始时间_In And 终止时间_In)
                    --当前人员可操作的号源
                     And (Nvl(人员id_In, 0) = 0 Or (Nvl(a.是否临床排班, 0) = 1 And Exists
                      (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
                    --站点
                     And (d.站点 Is Null Or d.站点 = 站点_In)
                    
                     And Not Exists (Select 1 From 临床出诊安排 Where 出诊id = 新出诊id_In And 号源id = a.Id)) Loop
  
    Insert Into 临床出诊安排
      (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 开始时间, 终止时间, 操作员姓名, 登记时间)
    Values
      (c_号源.安排id, c_号源.出诊id, c_号源.号源id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, 开始时间_In, 终止时间_In, 操作员姓名_In, 登记时间_In);
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Buildregisterplanbyrecord;
/

--103325:冉俊明,2017-02-08,跨月周出诊表按整周（七天）生成新的周出诊表或保存为模板。
Create Or Replace Procedure Zl_临床出诊表_Totemplet
(
  出诊id_In   临床出诊表.Id%Type,
  模板id_In   临床出诊表.Id%Type,
  出诊表名_In 临床出诊表.出诊表名%Type,
  应用范围_In 临床出诊表.应用范围%Type,
  科室id_In   临床出诊表.科室id%Type,
  备注_In     临床出诊表.备注%Type,
  操作员_In   临床出诊安排.操作员姓名%Type,
  操作时间_In 临床出诊安排.登记时间%Type,
  站点_In     部门表.站点%Type,
  人员id_In   人员表.Id%Type := Null
) As
  --功能：由月/周出诊表生成模板
  --参数：
  --        出诊id_In 月/周出诊表的出诊ID
  --        人员id_In 除固定安排外有效，不为0或null表示临床科室人员在添加
  --说明：
  v_Err_Msg Varchar2(255);
  Err_Item Exception;
  n_Count Number(8);

  n_模板id       临床出诊表.Id%Type;
  n_模板类型     临床出诊表.模板类型%Type;
  n_跨月周出诊id 临床出诊表.Id%Type;

  n_安排id 临床出诊安排.Id%Type;

  Function Get跨月周出诊id(出诊id_In 临床出诊表.Id%Type) Return 临床出诊表.Id%Type Is
    ----------------------------------------
    --如果原周出诊表不是整周(不足7天)，则需要查找到另一个出诊表构成整周
    ----------------------------------------
    n_出诊id 临床出诊表.Id%Type;
    n_年份   临床出诊表.年份%Type;
    n_月份   临床出诊表.月份%Type;
    n_周数   临床出诊表.周数%Type;
  
    d_开始时间 临床出诊安排.开始时间%Type;
    d_结束时间 临床出诊安排.终止时间%Type;
  
    --根据日期计算当月的周数，以及每一周的时间范围
    Cursor c_Weekrange(Date_In Date) Is
      Select Rownum As 周数, 开始日期, 结束日期
      From (With Month_Range As (Select Trunc(Date_In) As First_Day, Last_Day(Trunc(Date_In)) As Last_Day From Dual)
             Select Decode(To_Char(First_Day, 'day'), '星期日', First_Day, Null) As 开始日期,
                    Decode(To_Char(First_Day, 'day'), '星期日', First_Day, Null) As 结束日期
             From Month_Range
             Union All
             Select Decode(Sign(Trunc(First_Day + 7 * Week, 'day') + 1 - First_Day), 1,
                            Trunc(First_Day + 7 * Week, 'day') + 1, First_Day) As 开始日期,
                    Decode(Sign(Trunc(First_Day + 7 * Week, 'day') + 7 - Last_Day), 1, Last_Day,
                            Trunc(First_Day + 7 * Week, 'day') + 7) As 结束日期
             From Month_Range A, (Select Level - 1 As Week From Dual Connect By Level <= 6) B)
             Where 开始日期 <= 结束日期;
  
  
  Begin
    Begin
      Select 年份, 月份, 周数 Into n_年份, n_月份, n_周数 From 临床出诊表 Where ID = 出诊id_In;
    Exception
      When Others Then
        Return 0;
    End;
  
    If n_年份 Is Null Or n_月份 Is Null Or n_周数 Is Null Then
      Return 0;
    End If;
  
    For r_Weekrange In c_Weekrange(To_Date(n_年份 || '-' || n_月份 || '-01', 'yyyy-mm-dd')) Loop
      If r_Weekrange.周数 = n_周数 Then
        d_开始时间 := r_Weekrange.开始日期;
        d_结束时间 := r_Weekrange.结束日期;
        Exit;
      End If;
    End Loop;
  
    If d_开始时间 Is Null Or d_结束时间 Is Null Then
      Return 0;
    End If;
    If Trunc(d_结束时间) - Trunc(d_开始时间) >= 6 Then
      Return 0;
    End If;
  
    --存在跨月的，查找另一个出诊表的年月周
    n_年份 := Null;
    n_月份 := Null;
    n_周数 := Null;
    If Trunc(d_开始时间 - 1, 'month') <> Trunc(d_开始时间, 'month') Then
      --当前是第一周,获取另一个出诊表的年月
      n_年份 := To_Number(To_Char(d_开始时间 - 1, 'yyyy'));
      n_月份 := To_Number(To_Char(d_开始时间 - 1, 'mm'));
    Elsif Trunc(d_结束时间 + 1, 'month') <> Trunc(d_结束时间, 'month') Then
      --当前是最后一周,获取另一个出诊表的年月
      n_年份 := To_Number(To_Char(d_结束时间 + 1, 'yyyy'));
      n_月份 := To_Number(To_Char(d_结束时间 + 1, 'mm'));
      n_周数 := 1;
    Else
      Return 0;
    End If;
  
    --获取跨月的另一个出诊表的ID
    Begin
      Select ID
      Into n_出诊id
      From (Select Rownum As 行号, ID
             From 临床出诊表
             Where Nvl(排班方式, 0) = 2 And 年份 = n_年份 And 月份 = n_月份 And (n_周数 Is Null Or 周数 = n_周数)
             Order By 周数 Desc)
      Where 行号 < 2;
    Exception
      When Others Then
        Return 0;
    End;
  
    Return n_出诊id;
  End;
Begin
  Select Count(1)
  Into n_Count
  From 临床出诊号源 A, 临床出诊安排 B, 临床出诊记录 C, 部门表 D
  Where a.Id = b.号源id And b.Id = c.安排id And a.科室id = d.Id And a.排班方式 In (1, 2) And Nvl(a.是否删除, 0) = 0 And
        (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd'))
       --当前人员可操作的号源
        And (Nvl(人员id_In, 0) = 0 Or
        (Nvl(a.是否临床排班, 0) = 1 And Exists (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
       --站点
        And (d.站点 Is Null Or d.站点 = 站点_In) And b.出诊id = 出诊id_In And Rownum < 2;
  If Nvl(n_Count, 0) = 0 Then
    v_Err_Msg := '当前出诊表中无有效的安排，不能另存为模板！';
    Raise Err_Item;
  End If;

  --排班方式：0-固定排班;1-按月排班;2-按周排班;3-模板
  Select Count(1) Into n_Count From 临床出诊表 Where 出诊表名 = 出诊表名_In And 排班方式 = 3 And Rownum < 2;
  If Nvl(n_Count, 0) > 0 Then
    v_Err_Msg := '当前已存在名为“' || 出诊表名_In || '”的模板！';
    Raise Err_Item;
  End If;

  Begin
    Select Decode(排班方式, 1, 2, 0)
    Into n_模板类型
    From 临床出诊表
    Where ID = 出诊id_In And 排班方式 In (1, 2) And Rownum < 2;
  Exception
    When Others Then
      v_Err_Msg := '未发现当前出诊表！';
      Raise Err_Item;
  End;

  n_模板id := 模板id_In;
  If Nvl(n_模板id, 0) = 0 Then
    Select 临床出诊表_Id.Nextval Into n_模板id From Dual;
  End If;

  --模板，肯定是新出诊表
  Insert Into 临床出诊表
    (ID, 排班方式, 出诊表名, 应用范围, 科室id, 备注, 发布人, 发布时间, 模板类型)
  Values
    (n_模板id, 3, 出诊表名_In, 应用范围_In, 科室id_In, 备注_In, 操作员_In, 操作时间_In, n_模板类型);

  --如果原周出诊表不是整周(不足7天)，则需要查找到另一个出诊表构成整周
  If Nvl(n_模板类型, 0) = 0 Then
    n_跨月周出诊id := Get跨月周出诊id(出诊id_In);
  End If;

  --月/周出诊表保存为模板
  For c_安排 In (Select b.Id As 安排id, b.号源id, a.项目id, a.医生id, a.医生姓名
               From 临床出诊号源 A, 临床出诊安排 B, 部门表 D
               Where a.Id = b.号源id And a.科室id = d.Id And a.排班方式 In (1, 2) And Nvl(a.是否删除, 0) = 0 And
                     (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd'))
                    --当前人员可操作的号源
                     And (Nvl(人员id_In, 0) = 0 Or (Nvl(a.是否临床排班, 0) = 1 And Exists
                      (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
                    --站点
                     And (d.站点 Is Null Or d.站点 = 站点_In) And (b.出诊id = 出诊id_In Or b.出诊id = n_跨月周出诊id)) Loop
  
    Begin
      Select ID Into n_安排id From 临床出诊安排 Where 出诊id = n_模板id And 号源id = c_安排.号源id;
    Exception
      When Others Then
        n_安排id := Null;
    End;
  
    If Nvl(n_安排id, 0) = 0 Then
      Select 临床出诊安排_Id.Nextval Into n_安排id From Dual;
    
      --1.临床出诊安排
      --排班规则:1-星期排班;2-单日排班;3-双日排班;4-月内轮循;5-轮循不限制;6-特定日期
      If Nvl(n_模板类型, 0) = 2 Then
        --按天安排出诊的月出诊表保存为特定日期的规则
        Zl_临床出诊安排_Insert(n_安排id, n_模板id, c_安排.号源id, c_安排.项目id, c_安排.医生id, c_安排.医生姓名, 6, Null, Null, Null, Null, 操作员_In,
                         操作时间_In);
      Else
        Zl_临床出诊安排_Insert(n_安排id, n_模板id, c_安排.号源id, c_安排.项目id, c_安排.医生id, c_安排.医生姓名, 1, Null, Null, Null, Null, 操作员_In,
                         操作时间_In);
      End If;
    End If;
  
    For c_记录 In (Select 临床出诊限制_Id.Nextval As 限制id, Decode(b.Id, Null, a.Id, b.Id) As 记录id,
                        Decode(To_Char(a.出诊日期, 'D'), '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六',
                                '1', '周日') As 限制项目, To_Number(To_Char(a.出诊日期, 'dd')) || '日' As 出诊日期, a.上班时段,
                        Decode(b.Id, Null, a.限号数, b.限号数) As 限号数, Decode(b.Id, Null, a.限约数, b.限约数) As 限约数,
                        Decode(b.Id, Null, a.是否分时段, b.是否分时段) As 是否分时段, Decode(b.Id, Null, a.是否序号控制, b.是否序号控制) As 是否序号控制,
                        Decode(b.Id, Null, a.预约控制, b.预约控制) As 预约控制, Decode(b.Id, Null, a.是否独占, b.是否独占) As 是否独占,
                        Decode(b.Id, Null, a.分诊方式, b.分诊方式) As 分诊方式
                 From 临床出诊记录 A, 临床出诊记录 B
                 Where a.Id = b.相关id(+) And a.安排id = c_安排.安排id And a.相关id Is Null And Nvl(a.是否临时出诊, 0) = 0) Loop
    
      --2.临床出诊限制
      If Nvl(n_模板类型, 0) = 2 Then
        Insert Into 临床出诊限制
          (ID, 安排id, 限制项目, 上班时段, 限号数, 限约数, 是否分时段, 是否序号控制, 预约控制, 是否独占, 分诊方式)
        Values
          (c_记录.限制id, n_安排id, c_记录.出诊日期, c_记录.上班时段, c_记录.限号数, c_记录.限约数, c_记录.是否分时段, c_记录.是否序号控制, c_记录.预约控制, c_记录.是否独占,
           c_记录.分诊方式);
      Else
        Insert Into 临床出诊限制
          (ID, 安排id, 限制项目, 上班时段, 限号数, 限约数, 是否分时段, 是否序号控制, 预约控制, 是否独占, 分诊方式)
        Values
          (c_记录.限制id, n_安排id, c_记录.限制项目, c_记录.上班时段, c_记录.限号数, c_记录.限约数, c_记录.是否分时段, c_记录.是否序号控制, c_记录.预约控制, c_记录.是否独占,
           c_记录.分诊方式);
      End If;
    
      --3.临床出诊诊室
      Insert Into 临床出诊诊室
        (限制id, 诊室id)
        Select c_记录.限制id, 诊室id From 临床出诊诊室记录 Where 记录id = c_记录.记录id;
    
      --4.临床出诊时段
      --分时段不分序号的，在预约挂号时会新增记录，填写预约顺序号
      If Nvl(c_记录.是否分时段, 0) = 1 And Nvl(c_记录.是否序号控制, 0) = 1 Then
        Insert Into 临床出诊时段
          (限制id, 序号, 开始时间, 终止时间, 限制数量, 是否预约)
          Select c_记录.限制id, 序号, 开始时间, 终止时间, 数量, 是否预约
          From 临床出诊序号控制
          Where 记录id = c_记录.记录id;
      Else
        Insert Into 临床出诊时段
          (限制id, 序号, 开始时间, 终止时间, 限制数量, 是否预约)
          Select c_记录.限制id, 序号, 开始时间, 终止时间, 数量, 是否预约
          From 临床出诊序号控制
          Where 记录id = c_记录.记录id And 预约顺序号 Is Null;
      End If;
    
      --5.临床出诊挂号控制
      Insert Into 临床出诊挂号控制
        (限制id, 类型, 性质, 名称, 序号, 控制方式, 数量)
        Select c_记录.限制id, 类型, 性质, 名称, 序号, 控制方式, 数量
        From 临床出诊挂号控制记录
        Where 记录id = c_记录.记录id;
    End Loop;
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊表_Totemplet;
/

--104979:冉俊明,2017-02-08,固定安排在制定临时安排时可修改收费项目，已被使用的按月或周排班的号源可以修改收费项目。
Create Or Replace Procedure Zl_临床出诊记录_Copy
(
  原记录id_In   临床出诊记录.Id%Type,
  安排id_In     临床出诊限制.安排id%Type,
  出诊日期_In   临床出诊记录.出诊日期%Type,
  操作员姓名_In 临床出诊记录.登记人%Type,
  登记时间_In   临床出诊记录.登记时间%Type,
  是否发布_In   临床出诊记录.是否发布%Type := 0,
  相关id_In     临床出诊记录.相关id%Type := Null
) As
  --复制临床出诊记录
  n_记录id 临床出诊记录.Id%Type;

  d_开始时间     临床出诊记录.开始时间%Type;
  n_是否分时段   临床出诊记录.是否分时段%Type;
  n_是否序号控制 临床出诊记录.是否序号控制%Type;
Begin
  Select 临床出诊记录_Id.Nextval Into n_记录id From Dual;
  Begin
    Select a.开始时间, a.是否分时段, a.是否序号控制
    Into d_开始时间, n_是否分时段, n_是否序号控制
    From 临床出诊记录 A
    Where a.Id = 原记录id_In;
  Exception
    When Others Then
      Return;
  End;

  --收费项目可能已调整，需要取安排中的收费项目，而不是原出诊记录的收费项目
  Insert Into 临床出诊记录
    (ID, 相关id, 安排id, 号源id, 出诊日期, 上班时段, 开始时间, 终止时间, 停诊开始时间, 停诊终止时间, 停诊原因, 缺省预约时间, 提前挂号时间, 限号数, 已挂数, 限约数, 已约数, 其中已接收,
     是否序号控制, 是否分时段, 预约控制, 是否独占, 项目id, 科室id, 医生id, 医生姓名, 替诊医生id, 替诊医生姓名, 分诊方式, 诊室id, 是否锁定, 是否临时出诊, 登记人, 登记时间, 是否发布)
    Select n_记录id, 相关id_In, 安排id_In, a.号源id, 出诊日期_In, a.上班时段,
           To_Date(To_Char(出诊日期_In, 'yyyy-mm-dd ') || To_Char(a.开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'),
           To_Date(To_Char(出诊日期_In, 'yyyy-mm-dd ') || To_Char(a.终止时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') + Case
             When Trunc(终止时间) > Trunc(d_开始时间) Then
              1
             Else
              0
           End, Null As 停诊开始时间, Null As 停诊终止时间, Null As 停诊原因,
           To_Date(To_Char(出诊日期_In, 'yyyy-mm-dd ') || To_Char(a.缺省预约时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') + Case
             When Trunc(缺省预约时间) > Trunc(d_开始时间) Then
              1
             Else
              0
           End,
           To_Date(To_Char(出诊日期_In, 'yyyy-mm-dd ') || To_Char(a.提前挂号时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') + Case
             When Trunc(提前挂号时间) < Trunc(d_开始时间) Then
              -1
             Else
              0
           End, a.限号数, 0 As 已挂数, a.限约数, 0 As 已约数, 0 As 其中已接收, a.是否序号控制, a.是否分时段, a.预约控制, a.是否独占, b.项目id, a.科室id, a.医生id,
           a.医生姓名, Null As 替诊医生id, Null As 替诊医生姓名, a.分诊方式, a.诊室id, 0 As 是否锁定, 0 As 是否临时出诊, 操作员姓名_In, 登记时间_In, 是否发布_In
    From 临床出诊记录 A, (Select 项目id From 临床出诊安排 Where ID = 安排id_In) B
    Where a.Id = 原记录id_In;

  Insert Into 临床出诊诊室记录
    (记录id, 诊室id)
    Select n_记录id, 诊室id From 临床出诊诊室记录 Where 记录id = 原记录id_In;

  --分时段不分序号的，在预约挂号时会新增记录，填写预约顺序号
  If Nvl(n_是否分时段, 0) = 1 And Nvl(n_是否序号控制, 0) = 1 Then
    --分时段且启用序号控制，使用"预约顺序号"记录"是否预约"
    Insert Into 临床出诊序号控制
      (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 预约顺序号)
      Select n_记录id, 序号,
             To_Date(To_Char(出诊日期_In, 'yyyy-mm-dd ') || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') + Case
                When Trunc(开始时间) > Trunc(d_开始时间) Then
                 1
                Else
                 0
              End,
             To_Date(To_Char(出诊日期_In, 'yyyy-mm-dd ') || To_Char(终止时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') + Case
                When Trunc(终止时间) > Trunc(d_开始时间) Then
                 1
                Else
                 0
              End, 数量, 是否预约, 是否预约
      From 临床出诊序号控制
      Where 记录id = 原记录id_In And (开始时间 <> 终止时间 Or 开始时间 Is Null And 终止时间 Is Null);
    --排除加号权限加的（开始时间=终止时间）
  Else
    Insert Into 临床出诊序号控制
      (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约)
      Select n_记录id, 序号,
             To_Date(To_Char(出诊日期_In, 'yyyy-mm-dd ') || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') + Case
               When Trunc(开始时间) > Trunc(d_开始时间) Then
                1
               Else
                0
             End,
             To_Date(To_Char(出诊日期_In, 'yyyy-mm-dd ') || To_Char(终止时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') + Case
               When Trunc(终止时间) > Trunc(d_开始时间) Then
                1
               Else
                0
             End, 数量, 是否预约
      From 临床出诊序号控制
      Where 预约顺序号 Is Null And 记录id = 原记录id_In;
  End If;

  Insert Into 临床出诊挂号控制记录
    (记录id, 类型, 性质, 名称, 序号, 控制方式, 数量)
    Select n_记录id, 类型, 性质, 名称, 序号, 控制方式, 数量 From 临床出诊挂号控制记录 Where 记录id = 原记录id_In;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊记录_Copy;
/

--105277:李南春,2017-02-08,没有指定的就诊ID，不更新病人的费用业务数据
Create Or Replace Procedure Zl_病人信息_基本信息调整_费用
(
  病人id_In 病人信息变动.病人id%Type,
  就诊id_In Number,
  姓名_In   病人信息.姓名%Type,
  性别_In   病人信息.性别%Type,
  年龄_In   病人信息.年龄%Type,
  场合_In   Number, --1-门诊;2-住院
  说明_Out  Out 病人信息变动.说明%Type
) As
  ------------------------------------------------------------------------------------------
  --功能:更新费用相关业务数据的病人基本信息
  --入参:病人id_In:病人ID
  --     就诊id_In:门诊病人为挂号ID;住院病人为主页ID;为0说明是外来或非挂号就诊的病人(就诊id_In为空时,不更改该病人的费用部分的业务数据)
  --     姓名_In:需要更改的病人姓名
  --     性别_In:需要更改的病人性别
  --     年龄_In:需要更改的病人年龄
  --     场合_In:1-门诊;2-住院
  --出参:说明_Out:病人信息调整后的说明信息，用于提示操作员进行相关操作
  ------------------------------------------------------------------------------------------
  Err_Custom Exception;
  v_Error   Varchar2(2000);
  d_Maxdate Date;
  v_说明    Varchar2(4000);
  v_No      门诊费用记录.No%Type;
  v_科室    部门表.名称%Type;
  n_类别    Number(2);
  v_Temp    Varchar2(4000);
  n_Split   Number(2);
  n_主页id  病案主页.主页id%Type;
Begin
  --没有指定的就诊ID，不更新病人的费用业务数据
  If Nvl(就诊id_In, 0) = 0 Then
    Return;
  End If;
  
  If Nvl(场合_In, 0) <= 1 Then
    --门诊
    If Nvl(就诊id_In, 0) <> 0 Then
      Begin
        Select a.No, b.名称, 登记时间
        Into v_No, v_科室, d_Maxdate
        From 病人挂号记录 A, 部门表 B
        Where a.执行部门id = b.Id(+) And a.Id = 就诊id_In;
      Exception
        When Others Then
          v_No := Null;
      End;
    
      If v_No Is Null Then
        v_Error := '未找到对应的挂号记录,不能更新病人基本信息.';
        Raise Err_Custom;
      End If;
      v_说明 := '挂号单:' || v_No || LPad(' ', 4) || '挂号科室:' || v_科室 || ' 收回票据信息:';
    Else
      v_No   := '-';
      v_说明 := '收回票据信息:';
    End If;
    n_类别 := 0;
    v_Temp := Null;
    For c_费用 In (Select Distinct 1 As 性质, '挂号:' As 类别, c.号码
                 From 门诊费用记录 A, 票据打印内容 B, 票据使用明细 C
                 Where a.No = b.No And b.数据性质 = 4 And b.Id = c.打印id And c.性质 = 1 And a.病人id = 病人id_In And a.记录性质 = 4 And
                       (a.No = v_No Or Nvl(就诊id_In, 0) = 0)
                 Union All
                 Select Distinct 2 As 性质, '收费:' As 类别, c.号码
                 From 门诊费用记录 A, 票据打印内容 B, 票据使用明细 C
                 Where a.No = b.No And b.数据性质 = 1 And b.Id = c.打印id And c.性质 = 1 And a.病人id = 病人id_In And a.记录性质 = 1 And
                       (Exists (Select 1 From 病人医嘱记录 B Where a.医嘱序号 = b.Id And 挂号单 = v_No) Or 医嘱序号 Is Null Or
                        Nvl(就诊id_In, 0) = 0)
                 Union All
                 Select Distinct 3 As 性质, '医疗卡:' As 类别, c.号码
                 From 住院费用记录 A, 票据打印内容 B, 票据使用明细 C
                 Where a.No = b.No And b.数据性质 = 5 And b.Id = c.打印id And c.性质 = 1 And Nvl(a.记帐费用, 0) = 0 And
                       a.病人id = 病人id_In And a.记录性质 = 5 And
                       (Exists (Select 1 From 病人医嘱记录 B Where a.医嘱序号 = b.Id And 挂号单 = v_No) Or 医嘱序号 Is Null Or
                        Nvl(就诊id_In, 0) = 0)
                 Union All
                 Select Distinct 4 As 性质, '预交:' As 类别, c.号码
                 From 病人预交记录 A, 票据打印内容 B, 票据使用明细 C
                 Where a.No = b.No And b.数据性质 = 2 And b.Id = c.打印id And c.性质 = 1 And Nvl(a.预交类别, 0) = 1 And
                       a.病人id = 病人id_In And a.记录性质 = 1
                 Union All
                 Select Distinct 5 As 性质, '结帐:' As 类别, c.号码
                 From (Select Distinct b.Id, b.No
                        From 门诊费用记录 A, 病人结帐记录 B
                        Where a.结帐id = b.Id And a.记帐费用 = 1 And a.病人id = 病人id_In And a.记录性质 In (2, 12) And
                              (Exists (Select 1 From 病人医嘱记录 B Where a.医嘱序号 = b.Id And 挂号单 = v_No) Or 医嘱序号 Is Null Or
                               Nvl(就诊id_In, 0) = 0)
                        Union All
                        Select Distinct b.Id, b.No
                        From 住院费用记录 A, 病人结帐记录 B
                        Where a.结帐id = b.Id And Nvl(a.记帐费用, 0) = 1 And a.病人id = 病人id_In And a.记录性质 = 5 And
                              (Exists (Select 1 From 病人医嘱记录 B Where a.医嘱序号 = b.Id And 挂号单 = v_No) Or 医嘱序号 Is Null Or
                               Nvl(就诊id_In, 0) = 0)) A, 票据打印内容 B, 票据使用明细 C
                 Where a.No = b.No And b.数据性质 = 3 And b.Id = c.打印id And c.性质 = 1
                 Order By 性质, 号码) Loop
    
      If Length(Nvl(v_说明, '-') || Nvl(v_Temp, '-')) > 3800 Then
        v_说明 := v_说明 || '等';
        Exit;
      End If;
    
      If n_类别 <> Nvl(c_费用.性质, 0) Then
        If Not v_Temp Is Null Then
          v_说明 := Nvl(v_说明, '') || v_Temp;
        End If;
      
        n_Split := 1;
        If v_Temp Is Null Then
          v_Temp := c_费用.类别;
        Else
          v_Temp := ';' || c_费用.类别;
        End If;
        n_类别 := Nvl(c_费用.性质, 0);
      End If;
    
      If n_Split = 1 Then
        v_Temp := Nvl(v_Temp, '') || c_费用.号码;
      Else
        v_Temp := Nvl(v_Temp, '') || ',' || c_费用.号码;
      End If;
      n_Split := 0;
    End Loop;
    If Not v_Temp Is Null Then
      If Length(Nvl(v_说明, '-') || Nvl(v_Temp, '-')) > 4000 Then
        v_说明 := v_说明 || '等';
      Else
        v_说明 := Nvl(v_说明, '') || v_Temp;
      End If;
    
    End If;
  
    说明_Out := v_说明;
  
    If Nvl(就诊id_In, 0) = 0 Then
      --批量更新所有费用
      Update 门诊费用记录
      Set 姓名 = Nvl(姓名_In, 姓名), 性别 = Nvl(性别_In, 性别), 年龄 = Nvl(年龄_In, 年龄)
      Where 病人id = 病人id_In;
    
      Update 排队叫号队列 Set 患者姓名 = Nvl(姓名_In, 患者姓名) Where 病人id = 病人id_In And 业务类型 = 0;
    
      Update 住院费用记录
      Set 姓名 = Nvl(姓名_In, 姓名), 性别 = Nvl(性别_In, 性别), 年龄 = Nvl(年龄_In, 年龄)
      Where 病人id = 病人id_In And 记录性质 = 5;
      Return;
    End If;
  
    --有诊疗ID的,只更新这次就诊的或直接登记的病人信息
    Update 门诊费用记录 A
    Set 姓名 = Nvl(姓名_In, 姓名), 性别 = Nvl(性别_In, 性别), 年龄 = Nvl(年龄_In, 年龄)
    Where 病人id = 病人id_In And a.记录性质 <> 4 And
          (Exists (Select 1 From 病人医嘱记录 B Where a.医嘱序号 = b.Id And 挂号单 = v_No) Or 医嘱序号 Is Null);
  
    Update 门诊费用记录 A
    Set 姓名 = Nvl(姓名_In, 姓名), 性别 = Nvl(性别_In, 性别), 年龄 = Nvl(年龄_In, 年龄)
    Where 病人id = 病人id_In And a.记录性质 = 4 And NO = v_No;
  
    Update 住院费用记录 A
    Set 姓名 = Nvl(姓名_In, 姓名), 性别 = Nvl(性别_In, 性别), 年龄 = Nvl(年龄_In, 年龄)
    Where 病人id = 病人id_In And (Exists (Select 1 From 病人医嘱记录 B Where a.医嘱序号 = b.Id And 挂号单 = v_No) Or 医嘱序号 Is Null) And
          记录性质 = 5;
  
    Update 排队叫号队列
    Set 患者姓名 = Nvl(姓名_In, 患者姓名)
    Where 病人id = 病人id_In And 业务类型 = 0 And 业务id = 就诊id_In;
    Return;
  End If;

  --住院:
  --1.结了账且打印了发票的,不允许更改

  If Nvl(就诊id_In, 0) <> 0 Then
    Begin
      Select b.名称, a.入院日期
      Into v_科室, d_Maxdate
      From 病案主页 A, 部门表 B
      Where a.入院科室id = b.Id(+) And a.病人id = 病人id_In And a.主页id = 就诊id_In;
    Exception
      When Others Then
        d_Maxdate := Null;
    End;
  
    If d_Maxdate Is Null Then
      v_Error := '未找到对应的病案记录,不能更新病人基本信息.';
      Raise Err_Custom;
    End If;
    v_说明 := '入院科室:' || v_科室 || ' 收回票据信息:';
  Else
    v_说明 := '收回票据信息:';
  End If;

  n_类别   := 0;
  n_主页id := Nvl(就诊id_In, 0);
  v_Temp   := Null;

  For c_费用 In (Select Distinct 4 As 性质, '预交:' As 类别, c.号码
               From 病人预交记录 A, 票据打印内容 B, 票据使用明细 C
               Where a.No = b.No And b.数据性质 = 2 And b.Id = c.打印id And c.性质 = 1 And Nvl(a.预交类别, 0) = 2 And
                     a.病人id = 病人id_In And a.记录性质 = 1 And Decode(n_主页id, 0, 0, a.主页id) = n_主页id
               Union All
               Select Distinct 5 As 性质, '结帐:' As 类别, c.号码
               From (Select Distinct b.Id, b.No
                      From 住院费用记录 A, 病人结帐记录 B
                      Where a.结帐id = b.Id And Nvl(a.记帐费用, 0) = 1 And a.病人id = 病人id_In And
                            Decode(n_主页id, 0, 0, a.主页id) = n_主页id And a.记录性质 <> 5) A, 票据打印内容 B, 票据使用明细 C
               Where a.No = b.No And b.数据性质 = 3 And b.Id = c.打印id And c.性质 = 1
               Order By 性质, 号码) Loop
  
    If Length(Nvl(v_说明, '-') || Nvl(v_Temp, '-')) > 3800 Then
      v_说明 := v_说明 || '等';
      Exit;
    End If;
  
    If n_类别 <> Nvl(c_费用.性质, 0) Then
      If Not v_Temp Is Null Then
        v_说明 := Nvl(v_说明, '') || v_Temp;
      End If;
      n_Split := 1;
      If v_Temp Is Null Then
        v_Temp := c_费用.类别;
      Else
        v_Temp := ';' || c_费用.类别;
      End If;
      n_类别 := Nvl(c_费用.性质, 0);
    End If;
  
    If n_Split = 1 Then
      v_Temp := Nvl(v_Temp, '') || c_费用.号码;
    Else
      v_Temp := Nvl(v_Temp, '') || ',' || c_费用.号码;
    End If;
    n_Split := 0;
  End Loop;
  If Not v_Temp Is Null Then
    If Length(Nvl(v_说明, '-') || Nvl(v_Temp, '-')) > 4000 Then
      v_说明 := v_说明 || '等';
    Else
      v_说明 := Nvl(v_说明, '') || v_Temp;
    End If;
  End If;
  说明_Out := v_说明;

  Update 住院费用记录
  Set 姓名 = Nvl(姓名_In, 姓名), 性别 = Nvl(性别_In, 性别), 年龄 = Nvl(年龄_In, 年龄)
  Where 病人id = 病人id_In And Decode(n_主页id, 0, 0, 主页id) = n_主页id And 记录性质 <> 5;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人信息_基本信息调整_费用;
/

--101452:余伟节,2017-02-07,取消登记时如果存在未作废的医嘱弹出提示并禁止
Create Or Replace Procedure Zl_入院病案主页_Delete
(
  病人id_In     病案主页.病人id%Type,
  主页id_In     病案主页.主页id%Type,
  转留观_In     Number := 0,
  清除住院号_In Number := 0
  --功能：取消病人入院/预约登记
  --     主页ID_IN:为0时表示取消预约登记
  --     转留观_IN:将正常入院登记病人转为住院留观病人
  --     清除住院号_In:第一次住院的病人转留观时是否清除住院号
) As
  v_入院时间   病案主页.入院日期%Type;
  v_入院科室   病案主页.入院科室id%Type;
  v_出院时间   病案主页.出院日期%Type;
  v_住院号     病案主页.住院号%Type;
  v_再入院     病案主页.再入院%Type;
  v_出院科室id 病案主页.出院科室id%Type;
  n_病人性质   病案主页.病人性质%Type;
  n_主页id     病案主页.主页id%Type;

  v_Count Number;
  v_Error Varchar2(255);
  Err_Custom Exception;

  Function Checkpatiadvice
  (
    病人id_In 病案主页.病人id%Type,
    主页id_In 病案主页.主页id%Type
  ) Return Varchar2 Is
    --本次住院所有医嘱记录都已作废
    v_Err Varchar2(255);
  Begin
    v_Err := Null;
  
    For r_Row In (Select 开嘱医生, Decode(医嘱状态, -1, '暂存', 1, '新开', 2, '校对疑问', '未作废') As 状态, 医嘱内容
                  From 病人医嘱记录
                  Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(医嘱状态, 0) <> 4 And Rownum < 2) Loop
      v_Err := '【' || r_Row.开嘱医生 || '】医生有' || r_Row.状态 || '的医嘱没有处理,不允许取消登记！';
    End Loop;
    Return v_Err;
  End Checkpatiadvice;
Begin
  Select Nvl(状态, 0), Nvl(病人性质, 0)
  Into v_Count, n_病人性质
  From 病案主页
  Where 病人id = 病人id_In And 主页id = 主页id_In;
  If v_Count <> 1 Then
    v_Error := '该病人已经入科,请先将病人撤消至入院状态。';
    Raise Err_Custom;
  End If;

  --删除电子病历时机
  Select 出院科室id, 再入院 Into v_出院科室id, v_再入院 From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
  If v_再入院 = 0 Then
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '入院', v_出院科室id);
  Else
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '再次入院', v_出院科室id);
  End If;

  --提取最近一次不为空的住院号
  Begin
    If 主页id_In = 0 Then
      Select 住院号
      Into v_住院号
      From 病案主页
      Where 病人id = 病人id_In And
            主页id =
            (Select Max(主页id) From 病案主页 Where 病人id = 病人id_In And Nvl(主页id, 0) <> 0 And Nvl(住院号, 0) <> 0);
    Else
      Select 住院号
      Into v_住院号
      From 病案主页
      Where 病人id = 病人id_In And
            主页id =
            (Select Max(主页id) From 病案主页 Where 病人id = 病人id_In And 主页id < 主页id_In And Nvl(住院号, 0) <> 0);
    End If;
  Exception
    When Others Then
      Null;
  End;

  If 转留观_In = 1 And Nvl(主页id_In, 0) <> 0 Then
    Update 病案主页
    Set 病人性质 = 2, 住院号 = Decode(清除住院号_In, 1, Null, 住院号)
    Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(病人性质, 0) = 0;
  
    --调整住院次数
    Update 病人信息 Set 住院次数 = Decode(Sign(住院次数 - 1), 1, 住院次数 - 1, Null) Where 病人id = 病人id_In;
    If 清除住院号_In = 1 Then
      Update 病人信息 Set 住院号 = v_住院号 Where 病人id = 病人id_In;
    End If;
  Else
    Begin
      Select b.入院日期, b.出院日期, b.入院科室id
      Into v_入院时间, v_出院时间, v_入院科室
      From 病人信息 A, 病案主页 B
      Where a.病人id = 病人id_In And a.病人id = b.病人id And a.主页id = b.主页id And Nvl(b.主页id, 0) <> 0;
    Exception
      When Others Then
        Null;
    End;
    --撤消预约登记病人不检查住院日报
    If Nvl(主页id_In, 0) <> 0 Then
      Select Zl_住院日报_Count(v_入院科室, v_入院时间) Into v_Count From Dual;
      If v_Count > 0 Then
        v_Error := '已产生业务时间内的住院日报,不能办理该业务!';
        Raise Err_Custom;
      End If;
    End If;
    --门诊留观病人下达入院通知后存在两条有效的病案主页记录（36549）
    Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 入院日期 Is Not Null And 出院日期 Is Null;
    If Not v_Count > 1 Then
      v_Count := 0;
      If Nvl(主页id_In, 0) <> 0 And Nvl(n_病人性质, 0) = 0 Then
        v_Count := 1;
      End If;
      --再入院病人,取消入院登记时,病人信息的入院时间和出院时间应该回退到上一次入院日期和出院日期
      If v_再入院 = 1 Then
        Select 入院日期, 出院日期
        Into v_入院时间, v_出院时间
        From 病案主页
        Where 病人id = 病人id_In And
              主页id =
              (Select Max(主页id) From 病案主页 Where 病人id = 病人id_In And 主页id < 主页id_In And Nvl(住院号, 0) <> 0);
      End If;
    
      Update 病人信息
      Set 住院号 = v_住院号, 住院次数 = Decode(v_Count, 0, 住院次数, Decode(Sign(住院次数 - 1), 1, 住院次数 - 1, Null)), 当前科室id = Null,
          当前病区id = Null, 当前床号 = Null, 入院时间 = v_入院时间, 出院时间 = v_出院时间, 担保人 = Null, 担保额 = Null, 担保性质 = Null, 在院 = Null
      Where 病人id = 病人id_In;
      Delete From 在院病人 Where 病人id = 病人id_In;
    End If;
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In;
    Delete From 病人诊断记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 记录来源 = 2;
  
    --本次住院如果交了预交款,改为当作门诊交的
    Update 病人预交记录 Set 主页id = Null Where 病人id = 病人id_In And 主页id = 主页id_In;
  
    --本次发卡的,改变门诊发卡
    Update 住院费用记录 Set 主页id = Null Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 5;
  
    --本次住院的所有费用记录无结算且已全部冲销，则将对应费用记录中的"主页ID"清除。
    v_Count := 0;
    Select Nvl(Count(*), 0)
    Into v_Count
    From 住院费用记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 记帐费用 = 1 And 结帐id Is Not Null;
  
    If v_Count = 0 Then
      Begin
        Select Nvl(Count(*), 0)
        Into v_Count
        From 住院费用记录
        Where 病人id = 病人id_In And 主页id = 主页id_In And 记帐费用 = 1
        Group By NO, 记录性质, 序号
        Having Nvl(Sum(实收金额), 0) <> 0;
      Exception
        When Others Then
          v_Count := 0;
      End;
    
      If v_Count = 0 Then
        Delete 病人未结费用 Where 病人id = 病人id_In And 主页id = 主页id_In And 金额 = 0;
        Update 住院费用记录 Set 主页id = Null Where 病人id = 病人id_In And 主页id = 主页id_In And 记帐费用 = 1;
      End If;
    End If;
  
    --本次住院所有医嘱记录都已作废
    v_Count := 0;
    Select Nvl(Count(*), 0)
    Into v_Count
    From 病人医嘱记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(医嘱状态, 0) <> 4;
    If v_Count = 0 Then
      Delete From 病人医嘱记录 Where 病人id = 病人id_In And 主页id = 主页id_In;
    Else
      v_Error := Checkpatiadvice(病人id_In, 主页id_In);
      If v_Error Is Not Null Then
        Raise Err_Custom;
      End If;
    End If;
  
    --以下表,没有建病案主页(病人ID,主页ID)的外键,因为其主页ID可能是挂号ID
    Delete From 病人过敏记录 Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0);
    Delete From 病人诊断记录 Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0);
    Delete From 病人新生儿记录 Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0);
    Delete From 电子病历记录 Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0);
    Delete From 电子病历打印 Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0);
    --如果入院发放了就诊卡,则删除会失败(病人费用记录主页ID有外键约束)
    Delete From 病案主页 Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0);
    --修改病人信息的主页ID和住院次数
    Select Max(主页id) Into n_主页id From 病案主页 Where 病人id = 病人id_In And Nvl(主页id, 0) <> 0;
    Update 病人信息 Set 主页id = n_主页id Where 病人id = 病人id_In;
    If n_主页id Is Null Then
      Update 病人信息 Set 住院次数 = Null Where 病人id = 病人id_In;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_入院病案主页_Delete;
/

--104658:刘尔旋,2017-02-07,挂号发票支持多张打印
--100837:刘尔旋,2017-02-07,挂号附加费处理
Create Or Replace Procedure Zl_病人挂号记录_Delete
(
  单据号_In       门诊费用记录.No%Type,
  操作员编号_In   门诊费用记录.操作员编号%Type,
  操作员姓名_In   门诊费用记录.操作员姓名%Type,
  摘要_In         门诊费用记录.摘要%Type := Null, --预约取消时 填写 存放预约取消原因
  删除门诊号_In   Number := 0,
  非原样退结算_In Varchar2 := Null,
  退费类型_In     In Number := 0, --0-全退 1-退挂号费 2-退病历费 3-退附加费 4-退挂号与病历 5-退挂号与附加
  退指定结算_In   病人预交记录.结算方式%Type := Null,
  退号重用_In     Number := 1,
  收回票据号_In   Varchar2 := Null
) As
  --退费类型_In,在一下几种情况下不准进行部分退费
  --    2.三方接口,暂时不支持
  -- 挂号费病历费分开退,规则
  --    普通结算方式:原结算方式退部分费用
  --    预交款:预交款,退部分
  --    预交款与普通结算方式混合:退款按照普通结算方式部分退
  --    消费卡:原样将费用部分退入消费卡
  --非原样退结算_In:指不能退还给原样结算方式(如医保的个人账户,三方账户的退现等),多个用逗分离
  --退指定结算_IN:指非原样退结算部分,应该退给哪种结算方式,为空时缺省退给现金,否则退给指定的结算方式

  --该游标用于判断是否单独收病历费,及挂号汇总表处理
  Cursor c_Registinfo(v_状态 门诊费用记录.记录状态%Type) Is
    Select a.发生时间, a.登记时间, c.接收时间, a.收费细目id As 项目id, c.执行部门id As 科室id, c.执行人 As 医生姓名, d.Id As 医生id, c.号别 As 号码
    From 门诊费用记录 A, 挂号安排 B, 病人挂号记录 C, 人员表 D
    Where a.记录性质 = 4 And a.序号 = 1 And a.记录状态 = v_状态 And c.No = a.No And c.执行人 = d.姓名(+) And a.No = 单据号_In And
          Nvl(a.计算单位, '号别') = c.号别 And Rownum < 2;
  r_Registrow c_Registinfo%RowType;

  --该游标用于判断记录是否存在,及费用汇总表处理
  Cursor c_Moneyinfo(v_状态 门诊费用记录.记录状态%Type) Is
    Select 病人科室id, 开单部门id, 执行部门id, 收入项目id, Nvl(Sum(应收金额), 0) As 应收, Nvl(Sum(实收金额), 0) As 实收, Nvl(Sum(结帐金额), 0) As 结帐
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 = v_状态 And NO = 单据号_In
    Group By 病人科室id, 开单部门id, 执行部门id, 收入项目id;
  r_Moneyrow c_Moneyinfo%RowType;

  --该光标用于处理人员缴款余额中退的不同结算方式的金额
  Cursor c_Opermoney(n_Id 病人预交记录.结帐id%Type) Is
    Select Distinct b.结算方式, -1 * Nvl(b.冲预交, 0) As 冲预交
    From 病人预交记录 B
    Where b.结帐id = n_Id And b.记录性质 = 4 And b.记录状态 = 2 And Nvl(b.冲预交, 0) <> 0;

  v_Err_Msg Varchar(255);
  Err_Item Exception;

  n_结帐id 病人预交记录.结帐id%Type;
  n_销帐id 门诊费用记录.结帐id%Type;

  v_退指定结算方式 病人预交记录.结算方式%Type;
  n_退款金额       病人预交记录.冲预交%Type;
  n_打印id         票据打印内容.Id%Type;
  n_病人id         病人信息.病人id%Type;
  n_退费金额       病人预交记录.冲预交%Type;
  n_预交金额       病人预交记录.冲预交%Type; --原记录 预交缴款金额
  n_返回值         病人余额.预交余额%Type;
  n_挂号id         病人挂号记录.Id%Type;
  n_组id           财务缴款分组.Id%Type;

  n_二次退费       Number; --记录是否是此单据的第二次退费
  n_分诊台签到排队 Number;
  n_预约生成队列   Number;
  n_预约挂号       Number;
  n_挂号生成队列   Number;
  d_Date           Date;
  n_记帐           门诊费用记录.记帐费用%Type;
  n_病人id1        病人信息.病人id%Type;
  n_返回额         门诊费用记录.实收金额%Type;
  n_已结帐         Number;
  n_安排id         挂号安排.Id%Type;
  n_计划id         挂号安排计划.Id%Type;
  d_启用时间       Date;
  d_发生时间       病人挂号记录.发生时间%Type;
  n_出诊记录id     临床出诊记录.Id%Type;
  v_号码           挂号安排.号码%Type;
  n_序号           病人挂号记录.号序%Type;
  v_时间段         时间段.时间段%Type;
  d_检查开始时间   Date;
  d_检查结束时间   Date;
  v_Temp           Varchar2(500);
  v_附加ids        Varchar2(500);
  n_就诊病人id     病人信息.病人id%Type;
  d_就诊时间       就诊登记记录.就诊时间%Type;
Begin
  n_组id           := Zl_Get组id(操作员姓名_In);
  v_退指定结算方式 := 退指定结算_In;

  --首先判断要退号/取消预约的记录是否存在
  Open c_Moneyinfo(1);
  Fetch c_Moneyinfo
    Into r_Moneyrow;
  If c_Moneyinfo%RowCount = 0 Then
    Close c_Moneyinfo;
    Open c_Moneyinfo(0);
    Fetch c_Moneyinfo
      Into r_Moneyrow;
    If c_Moneyinfo%RowCount = 0 Then
      v_Err_Msg := '要处理的单据不存在。';
      Raise Err_Item;
    End If;
    n_预约挂号 := 1;
  End If;
  Close c_Moneyinfo;

  v_Temp := zl_GetSysParameter(256);
  If v_Temp Is Null Or Substr(v_Temp, 1, 1) = '0' Then
    Null;
  Else
    Begin
      d_启用时间 := To_Date(Substr(v_Temp, 3), 'YYYY-MM-DD hh24:mi:ss');
    Exception
      When Others Then
        d_启用时间 := Null;
    End;
  End If;

  Select 号别, 号序, 发生时间 Into v_号码, n_序号, d_发生时间 From 病人挂号记录 Where NO = 单据号_In And Rownum < 2;

  Begin
    Select a.Id Into n_安排id From 挂号安排 A Where a.号码 = v_号码;
  Exception
    When Others Then
      n_安排id := -1;
  End;

  Begin
    Select ID
    Into n_计划id
    From 挂号安排计划
    Where 安排id = n_安排id And 审核时间 Is Not Null And
          Nvl(生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) =
          (Select Max(a.生效时间) As 生效
           From 挂号安排计划 A
           Where a.审核时间 Is Not Null And d_发生时间 Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                 Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) And a.安排id = n_安排id) And
          d_发生时间 Between Nvl(生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
          Nvl(失效时间, To_Date('3000-01-01', 'yyyy-mm-dd'));
  Exception
    When Others Then
      n_计划id := 0;
  End;

  Begin
    If Nvl(n_计划id, 0) = 0 Then
      Select Decode(To_Char(d_发生时间, 'D'), '1', 周日, '2', 周一, '3', 周二, '4', 周三, '5', 周四, '6', 周五, '7', 周六, Null)
      Into v_时间段
      From 挂号安排
      Where ID = n_安排id;
    Else
      Select Decode(To_Char(d_发生时间, 'D'), '1', 周日, '2', 周一, '3', 周二, '4', 周三, '5', 周四, '6', 周五, '7', 周六, Null)
      Into v_时间段
      From 挂号安排计划
      Where ID = n_计划id;
    End If;
  Exception
    When Others Then
      v_时间段 := Null;
  End;

  If v_时间段 Is Not Null And d_启用时间 Is Not Null Then
    --检查是否跨模式挂号安排
    Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'),
           To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || ' ' || To_Char(终止时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss')
    Into d_检查开始时间, d_检查结束时间
    From 时间段
    Where 时间段 = v_时间段 And 站点 Is Null And 号类 Is Null;
    If d_检查开始时间 > d_检查结束时间 Then
      d_检查结束时间 := d_检查结束时间 + 1;
    End If;
    If d_检查结束时间 > d_启用时间 Then
      --获取出诊记录id
      Begin
        Select a.Id
        Into n_出诊记录id
        From 临床出诊记录 A, 临床出诊号源 B
        Where a.号源id = b.Id And b.号码 = v_号码 And 上班时段 = v_时间段 And d_发生时间 Between 开始时间 And 终止时间;
      Exception
        When Others Then
          n_出诊记录id := Null;
      End;
    End If;
  End If;

  Begin
    Select Zl_Fun_Regcustomname Into v_Temp From Dual;
    If v_Temp Is Not Null Then
      v_附加ids := Substr(v_Temp, Instr(v_Temp, '|') + 1);
    End If;
  Exception
    When Others Then
      v_附加ids := Null;
  End;

  --1.预约处理
  If Nvl(n_预约挂号, 0) = 1 Then
    --减少已约数
    Open c_Registinfo(0);
    Fetch c_Registinfo
      Into r_Registrow;
  
    Update 病人挂号汇总
    Set 已约数 = Nvl(已约数, 0) - 1
    Where 日期 = Trunc(r_Registrow.发生时间) And 科室id = r_Registrow.科室id And 项目id = r_Registrow.项目id And
          (号码 = r_Registrow.号码 Or 号码 Is Null);
  
    If Sql%RowCount = 0 Then
      Insert Into 病人挂号汇总
        (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已约数)
      Values
        (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
         Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, -1);
    End If;
    Close c_Registinfo;
  
    --更新挂号序号状态
    Delete 挂号序号状态
    Where 状态 = 2 And
          (号码, 序号, 日期) = (Select 计算单位, 发药窗口, Trunc(发生时间)
                          From 门诊费用记录
                          Where 记录性质 = 4 And 记录状态 = 0 And 序号 = 1 And Rownum = 1 And NO = 单据号_In) Or
          (号码, 序号, 日期) = (Select 计算单位, 发药窗口, 发生时间
                          From 门诊费用记录
                          Where 记录性质 = 4 And 记录状态 = 0 And 序号 = 1 And Rownum = 1 And NO = 单据号_In);
  
    --添加病人挂号记录的 冲销记录
    Select 病人挂号记录_Id.Nextval, Sysdate Into n_挂号id, d_Date From Dual;
  
    Update 病人挂号记录 Set 记录状态 = 3 Where NO = 单据号_In And 记录状态 = 1 And 记录性质 = 2;
    If Sql%NotFound Then
      v_Err_Msg := '预约单【' || 单据号_In || '】不存在或由于并发原因已经被取消预约';
      Raise Err_Item;
    End If;
  
    Insert Into 病人挂号记录
      (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 操作员编号, 操作员姓名,
       复诊, 号序, 社区, 预约, 摘要, 预约方式, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 医疗付款方式)
      Select n_挂号id, NO, 记录性质, 2, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, d_Date, 发生时间,
             操作员编号_In, 操作员姓名_In, 复诊, 号序, 社区, 预约, Nvl(摘要_In, 摘要) As 摘要, 预约方式, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 医疗付款方式
      From 病人挂号记录
      Where NO = 单据号_In;
  
    If n_出诊记录id Is Not Null Then
      Update 临床出诊记录 Set 已约数 = 已约数 - 1 Where ID = n_出诊记录id And Nvl(已约数, 0) > 0;
      Update 临床出诊序号控制 Set 挂号状态 = Null, 操作员姓名 = Null Where 记录id = n_出诊记录id And 序号 = n_序号;
    End If;
  
    --Update 病人挂号记录 set 摘要=nvl(摘要_IN,摘要) where NO=单据号_IN;
    --删除门诊费用记录
    Delete From 门诊费用记录 Where NO = 单据号_In And 记录性质 = 4 And 记录状态 = 0;
    --如果预约生成队列时需要清除队列
  
    n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
    If Nvl(n_预约生成队列, 0) = 1 Then
      --要删除队列
      For v_挂号 In (Select ID, 诊室, 执行部门id, 执行人 From 病人挂号记录 Where NO = 单据号_In) Loop
        Zl_排队叫号队列_Delete(v_挂号.执行部门id, v_挂号.Id);
      End Loop;
    End If;
    Return;
  End If;

  Select Nvl(记帐费用, 0), 病人id, Decode(Sign(Nvl(结帐id, 0)), 0, 0, 1)
  Into n_记帐, n_病人id, n_已结帐
  From 门诊费用记录
  Where 记录性质 = 4 And NO = 单据号_In And 记录状态 In (1, 3) And Rownum < 2;

  --2.挂号处理
  n_已结帐 := Nvl(n_已结帐, 0);

  If n_已结帐 = 1 And n_记帐 = 1 Then
    Select Sysdate, Null Into d_Date, n_销帐id From Dual;
  Else
    Select Sysdate, 病人结帐记录_Id.Nextval Into d_Date, n_销帐id From Dual;
  End If;

  ----0-全退 1-退挂号费 2-退病历费
  If Nvl(退费类型_In, 0) Not In (2, 3) Then
    --不是光退病历费时处理
    --更新挂号序号状态
    If 退号重用_In = 1 Then
      Delete 挂号序号状态
      Where 状态 = 1 And
            (号码, 序号, 日期) = (Select 号别, 号序, Trunc(发生时间) From 病人挂号记录 Where NO = 单据号_In And Rownum = 1) Or
            (号码, 序号, 日期) = (Select 号别, 号序, 发生时间 From 病人挂号记录 Where NO = 单据号_In And Rownum = 1);
    Else
      Update 挂号序号状态
      Set 状态 = 4
      Where 状态 = 1 And
            (号码, 序号, 日期) = (Select 号别, 号序, Trunc(发生时间) From 病人挂号记录 Where NO = 单据号_In And Rownum = 1) Or
            (号码, 序号, 日期) = (Select 号别, 号序, 发生时间 From 病人挂号记录 Where NO = 单据号_In And Rownum = 1);
    End If;
  
    --病人就诊状态
    If n_病人id Is Not Null Then
      Update 病人信息 Set 就诊状态 = 0, 就诊诊室 = Null Where 病人id = n_病人id;
    
      --删除门诊号相关处理,只有当只有一条挂号记录并且病人建档日期与挂号日期近似时才会处理
      If 删除门诊号_In = 1 Then
        Delete 门诊病案记录 Where 病人id = n_病人id;
        Update 病人信息 Set 门诊号 = Null Where 病人id = n_病人id;
        --费用记录包括挂号及病案、就诊卡费用,以及病人交费后退费或销帐的费用,挂号记录在最后处理
        Update 门诊费用记录 Set 标识号 = Null Where 门诊标志 = 1 And 病人id = n_病人id;
      End If;
    End If;
  
    --如果挂时收了就诊卡费,退费时清除就诊卡号,在非光退病历费时
    n_病人id1 := Null;
    Begin
      Select 病人id
      Into n_病人id1
      From 门诊费用记录
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And 附加标志 = 2 And Rownum < 2;
    Exception
      When Others Then
        Null;
    End;
  
    If n_病人id1 Is Not Null And Nvl(退费类型_In, 0) Not In (2, 3) Then
      Update 病人信息
      Set 就诊卡号 = Null, 卡验证码 = Null, Ic卡号 = Decode(Ic卡号, 就诊卡号, Null, Ic卡号)
      Where 病人id = n_病人id1;
    End If;
  
  End If;

  --检查前面是否已经部分退过费用
  Begin
    Select 1 Into n_二次退费 From 门诊费用记录 Where 记录性质 = 4 And NO = 单据号_In And 记录状态 = 3 And Rownum < 2;
  Exception
    When Others Then
      n_二次退费 := 0;
  End;

  If Nvl(退费类型_In, 0) = 0 Or Nvl(退费类型_In, 0) = 2 Then
    --全退,退病历费
    --门诊费用记录，冲销记录
    Insert Into 门诊费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别, 收费细目id, 计算单位, 付数,
       数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 执行人, 操作员编号, 操作员姓名, 发生时间, 登记时间,
       结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 缴款组id)
      Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别,
             收费细目id, 计算单位, 付数, -数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, -应收金额, -实收金额, 开单部门id, 开单人, 执行部门id, 执行人,
             操作员编号_In, 操作员姓名_In, 发生时间, d_Date, n_销帐id,
             Decode(n_记帐, 1, Decode(Nvl(n_已结帐, 0), 0, -1 * 实收金额, Null), -1 * 结帐金额), 保险项目否, 保险大类id, -1 * 统筹金额,
             Nvl(摘要_In, 摘要) As 摘要, Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, n_组id
      From 门诊费用记录
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And
            Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
  
    --原始记录
    If n_记帐 = 1 And Nvl(n_已结帐, 0) = 0 Then
      Update 门诊费用记录
      Set 记录状态 = 3, 结帐id = n_销帐id, 结帐金额 = 实收金额
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And
            Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
    Else
      Update 门诊费用记录
      Set 记录状态 = 3
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And
            Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
    End If;
  Elsif Nvl(退费类型_In, 0) = 1 Or Nvl(退费类型_In, 0) = 4 Then
    --退挂号费,退挂号与病历费
    --门诊费用记录，冲销记录
    Insert Into 门诊费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别, 收费细目id, 计算单位, 付数,
       数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 执行人, 操作员编号, 操作员姓名, 发生时间, 登记时间,
       结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 缴款组id)
      Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别,
             收费细目id, 计算单位, 付数, -数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, -应收金额, -实收金额, 开单部门id, 开单人, 执行部门id, 执行人,
             操作员编号_In, 操作员姓名_In, 发生时间, d_Date, n_销帐id,
             Decode(n_记帐, 1, Decode(Nvl(n_已结帐, 0), 0, -1 * 实收金额, Null), -1 * 结帐金额), 保险项目否, 保险大类id, -1 * 统筹金额,
             Nvl(摘要_In, 摘要) As 摘要, Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, n_组id
      From 门诊费用记录
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And Instr(',' || v_附加ids || ',', ',' || 收费细目id || ',') = 0 And
            Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
  
    --原始记录
    If n_记帐 = 1 And Nvl(n_已结帐, 0) = 0 Then
      Update 门诊费用记录
      Set 记录状态 = 3, 结帐id = n_销帐id, 结帐金额 = 实收金额
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And Instr(',' || v_附加ids || ',', ',' || 收费细目id || ',') = 0 And
            Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
    Else
      Update 门诊费用记录
      Set 记录状态 = 3
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And Instr(',' || v_附加ids || ',', ',' || 收费细目id || ',') = 0 And
            Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
    End If;
  Elsif Nvl(退费类型_In, 0) = 3 Then
    --退附加费
    --门诊费用记录，冲销记录
    Insert Into 门诊费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别, 收费细目id, 计算单位, 付数,
       数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 执行人, 操作员编号, 操作员姓名, 发生时间, 登记时间,
       结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 缴款组id)
      Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别,
             收费细目id, 计算单位, 付数, -数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, -应收金额, -实收金额, 开单部门id, 开单人, 执行部门id, 执行人,
             操作员编号_In, 操作员姓名_In, 发生时间, d_Date, n_销帐id,
             Decode(n_记帐, 1, Decode(Nvl(n_已结帐, 0), 0, -1 * 实收金额, Null), -1 * 结帐金额), 保险项目否, 保险大类id, -1 * 统筹金额,
             Nvl(摘要_In, 摘要) As 摘要, Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, n_组id
      From 门诊费用记录
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And Instr(',' || v_附加ids || ',', ',' || 收费细目id || ',') > 0 And
            Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
  
    --原始记录
    If n_记帐 = 1 And Nvl(n_已结帐, 0) = 0 Then
      Update 门诊费用记录
      Set 记录状态 = 3, 结帐id = n_销帐id, 结帐金额 = 实收金额
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And Instr(',' || v_附加ids || ',', ',' || 收费细目id || ',') > 0 And
            Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
    Else
      Update 门诊费用记录
      Set 记录状态 = 3
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And Instr(',' || v_附加ids || ',', ',' || 收费细目id || ',') > 0 And
            Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
    End If;
  Elsif Nvl(退费类型_In, 0) = 5 Then
    --退挂号与附加费
    --门诊费用记录，冲销记录
    Insert Into 门诊费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别, 收费细目id, 计算单位, 付数,
       数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 执行人, 操作员编号, 操作员姓名, 发生时间, 登记时间,
       结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 缴款组id)
      Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别,
             收费细目id, 计算单位, 付数, -数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, -应收金额, -实收金额, 开单部门id, 开单人, 执行部门id, 执行人,
             操作员编号_In, 操作员姓名_In, 发生时间, d_Date, n_销帐id,
             Decode(n_记帐, 1, Decode(Nvl(n_已结帐, 0), 0, -1 * 实收金额, Null), -1 * 结帐金额), 保险项目否, 保险大类id, -1 * 统筹金额,
             Nvl(摘要_In, 摘要) As 摘要, Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, n_组id
      From 门诊费用记录
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And Nvl(附加标志, 0) <> 1;
  
    --原始记录
    If n_记帐 = 1 And Nvl(n_已结帐, 0) = 0 Then
      Update 门诊费用记录
      Set 记录状态 = 3, 结帐id = n_销帐id, 结帐金额 = 实收金额
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And Nvl(附加标志, 0) <> 1;
    Else
      Update 门诊费用记录
      Set 记录状态 = 3
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And Nvl(附加标志, 0) <> 1;
    End If;
  End If;

  n_结帐id := 0;
  If n_记帐 = 0 Then
    --获取结帐ID
    Select Nvl(结帐id, 0)
    Into n_结帐id
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 = 3 And NO = 单据号_In And Rownum < 2;
  End If;

  If n_记帐 = 1 Then
    --记帐
    For c_费用 In (Select 实收金额, 病人科室id, 开单部门id, 执行部门id, 收入项目id
                 From 门诊费用记录
                 Where 记录性质 = 4 And 记录状态 = 3 And NO = 单据号_In And
                       Nvl(附加标志, 0) =
                       Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0)) And
                       Nvl(记帐费用, 0) = 1) Loop
      --病人余额
      Update 病人余额
      Set 费用余额 = Nvl(费用余额, 0) - Nvl(c_费用.实收金额, 0)
      Where 病人id = Nvl(n_病人id, 0) And 性质 = 1 And 类型 = 1
      Returning 费用余额 Into n_返回额;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 费用余额, 预交余额)
        Values
          (n_病人id, 1, 1, -1 * Nvl(c_费用.实收金额, 0), 0);
        n_返回额 := Nvl(c_费用.实收金额, 0);
      End If;
      If Nvl(n_返回额, 0) = 0 Then
        Delete 病人余额
        Where 病人id = Nvl(n_病人id, 0) And 性质 = 1 And 类型 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
      --病人未结费用
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) - Nvl(c_费用.实收金额, 0)
      Where 病人id = n_病人id And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(c_费用.病人科室id, 0) And
            Nvl(开单部门id, 0) = Nvl(c_费用.开单部门id, 0) And Nvl(执行部门id, 0) = Nvl(c_费用.执行部门id, 0) And 收入项目id + 0 = c_费用.收入项目id And
            来源途径 + 0 = 1;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人未结费用
          (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
        Values
          (n_病人id, Null, Null, c_费用.病人科室id, c_费用.开单部门id, c_费用.执行部门id, c_费用.收入项目id, 1, -1 * Nvl(c_费用.实收金额, 0));
      End If;
    End Loop;
    Delete 病人未结费用
    Where 病人id = n_病人id And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(金额, 0) = 0 And 来源途径 + 0 = 1;
  End If;

  If n_记帐 = 0 Then
    --1.退费
    --病人挂号结算:现金和个人帐户部份
    If 非原样退结算_In Is Not Null Then
      --退款金额获取
      If Nvl(退费类型_In, 0) <> 0 Or Nvl(n_二次退费, 0) <> 0 Then
        --如果是单独退病历费,或者只退挂号费,先获取退费金额
        Begin
          --获取本次退款金额
          Select -1 * Sum(Nvl(实收金额, 0)) As 收款金额
          Into n_退款金额
          From 门诊费用记录
          Where NO = 单据号_In And 记录性质 = 4 And 记录状态 = 2 And 结帐id = n_销帐id;
        
        Exception
          When Others Then
            v_Err_Msg := '单据【' || 单据号_In || '】的' || Case Nvl(退费类型_In, 0)
                           When 1 Then
                            '挂号费用'
                           When 2 Then
                            '病历费'
                         End || '可能由于并发原因已经进行了退费或者单据不存在!';
            Raise Err_Item;
        End;
        Begin
          Select 冲预交
          Into n_退费金额
          From 病人预交记录
          Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_结帐id And Instr(',' || 非原样退结算_In || ',', ',' || 结算方式 || ',') = 0;
        Exception
          When Others Then
            n_退费金额 := 0;
        End;
      
        --a.允许的结算方式
      
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
           结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_Date, 操作员编号_In, 操作员姓名_In, -n_退款金额,
                 n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
          From 病人预交记录
          Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_结帐id And Instr(',' || 非原样退结算_In || ',', ',' || 结算方式 || ',') = 0;
      
        If n_退费金额 = 0 Then
          --b.不允许的退现金
          If n_退款金额 <> 0 Then
            If v_退指定结算方式 Is Null Then
              --退给现金
              Begin
                Select 名称 Into v_退指定结算方式 From 结算方式 Where 性质 = 1;
              Exception
                When Others Then
                  v_退指定结算方式 := '现金';
              End;
            End If;
            Update 病人预交记录
            Set 冲预交 = 冲预交 + (-1 * n_退款金额)
            Where 记录性质 = 4 And 记录状态 = 2 And 结帐id = n_销帐id And 结算方式 = v_退指定结算方式;
            If Sql%RowCount = 0 Then
              Insert Into 病人预交记录
                (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
                 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
                Select 病人预交记录_Id.Nextval, a.No, a.实际票号, a.记录性质, 2, a.病人id, a.主页id, a.科室id, a.摘要, v_退指定结算方式, d_Date,
                       操作员编号_In, 操作员姓名_In, -1 * n_退款金额, n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
                From 病人预交记录 A
                Where a.记录性质 = 4 And a.记录状态 = 1 And a.结帐id = n_结帐id And Rownum < 2;
            End If;
          End If;
        End If;
      Else
        --a.允许的结算方式原样退
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
           结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_Date, 操作员编号_In, 操作员姓名_In, -冲预交,
                 n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
          From 病人预交记录
          Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_结帐id And Instr(',' || 非原样退结算_In || ',', ',' || 结算方式 || ',') = 0;
      
        --b.不允许的退现金
        Begin
          Select Sum(冲预交)
          Into n_退费金额
          From 病人预交记录
          Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_结帐id And Instr(',' || 非原样退结算_In || ',', ',' || 结算方式 || ',') > 0;
        Exception
          When Others Then
            n_退费金额 := 0;
        End;
        If n_退费金额 <> 0 Then
          If v_退指定结算方式 Is Null Then
            --退给现金
            Begin
              Select 结算方式
              Into v_退指定结算方式
              From 病人预交记录
              Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_结帐id And Instr(',' || 非原样退结算_In || ',', ',' || 结算方式 || ',') = 0;
            
            Exception
              When Others Then
                Begin
                  Select 名称 Into v_退指定结算方式 From 结算方式 Where 性质 = 1;
                Exception
                  When Others Then
                    v_退指定结算方式 := '现金';
                End;
            End;
          End If;
          Update 病人预交记录
          Set 冲预交 = 冲预交 + (-1 * n_退费金额)
          Where 记录性质 = 4 And 记录状态 = 2 And 结帐id = n_销帐id And 结算方式 = v_退指定结算方式;
          If Sql%RowCount = 0 Then
            Insert Into 病人预交记录
              (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
               结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
              Select 病人预交记录_Id.Nextval, a.No, a.实际票号, a.记录性质, 2, a.病人id, a.主页id, a.科室id, a.摘要, v_退指定结算方式, d_Date,
                     操作员编号_In, 操作员姓名_In, -1 * n_退费金额, n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
              From 病人预交记录 A
              Where a.记录性质 = 4 And a.记录状态 = 1 And a.结帐id = n_结帐id And Rownum < 2;
          End If;
        End If;
      End If;
    Else
      --退款金额获取
      If Nvl(退费类型_In, 0) <> 0 Or Nvl(n_二次退费, 0) <> 0 Then
        --如果是单独退病历费,或者只退挂号费,先获取退费金额
        Begin
          --获取本次退款金额
          Select -1 * Sum(Nvl(实收金额, 0)) As 收款金额
          Into n_退款金额
          From 门诊费用记录
          Where NO = 单据号_In And 记录性质 = 4 And 记录状态 = 2 And 结帐id = n_销帐id;
        Exception
          When Others Then
            v_Err_Msg := '单据【' || 单据号_In || '】的' || Case Nvl(退费类型_In, 0)
                           When 1 Then
                            '挂号费用'
                           When 2 Then
                            '病历费'
                         End || '可能由于并发原因已经进行了退费或者单据不存在!';
            Raise Err_Item;
        End;
      End If;
      If Nvl(n_二次退费, 0) = 0 And Nvl(退费类型_In, 0) = 0 Then
        --首次全退
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
           结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_Date, 操作员编号_In, 操作员姓名_In, -1 * 冲预交,
                 n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
          From 病人预交记录
          Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_结帐id;
      Else
        --二次退费,或者本次单退一部分
        --二次退费时,记录状态=3 ,首次部分退,记录状态为1
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
           结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_Date, 操作员编号_In, 操作员姓名_In,
                 -1 * n_退款金额, n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
          From 病人预交记录
          Where 记录性质 = 4 And 记录状态 = Decode(Nvl(n_二次退费, 0), 0, 1, 3) And 结帐id = n_结帐id And 摘要 = '医保挂号' And 冲预交 = n_退款金额 And
                Rownum < 2;
        If Sql%RowCount = 0 Then
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
             结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_Date, 操作员编号_In, 操作员姓名_In,
                   -1 * n_退款金额, n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
            From 病人预交记录
            Where 记录性质 = 4 And 记录状态 = Decode(Nvl(n_二次退费, 0), 0, 1, 3) And 结帐id = n_结帐id And 冲预交 = n_退款金额 And Rownum < 2;
        End If;
        If Sql%RowCount = 0 Then
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
             结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_Date, 操作员编号_In, 操作员姓名_In,
                   -1 * n_退款金额, n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
            From 病人预交记录
            Where 记录性质 = 4 And 记录状态 = Decode(Nvl(n_二次退费, 0), 0, 1, 3) And 结帐id = n_结帐id And Rownum < 2;
          If Sql%RowCount = 0 Then
            --部分退费,并且全部使用预交款缴费时才存在此种情况
            n_预交金额 := n_退款金额;
          End If;
        End If;
      
      End If;
    End If;
    --首次退费时,记录状态便调整为了3
    Update 病人预交记录
    Set 记录状态 = 3
    Where 记录性质 = 4 And 记录状态 = Decode(Nvl(n_二次退费, 0), 0, 1, 3) And 结帐id = n_结帐id;
  
    --冲预交 1-全退 2-部分退,部分退时当全部使用预交进行缴款
    If Nvl(退费类型_In, 0) = 0 Or (Nvl(退费类型_In, 0) <> 0 And n_预交金额 <> 0) Then
      --病人挂号结算:冲预交款部份
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, d_Date,
               操作员姓名_In, 操作员编号_In, -1 * Decode(Nvl(退费类型_In, 0) + Nvl(n_二次退费, 0), 0, 冲预交, n_预交金额), n_销帐id, n_组id, 预交类别,
               卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
        From 病人预交记录
        Where 记录性质 In (1, 11) And 结帐id = n_结帐id And Nvl(冲预交, 0) <> 0 And
              Rownum = Decode(Nvl(退费类型_In, 0) + Nvl(n_二次退费, 0), 0, Rownum, 1);
    End If;
  
    --处理病人预交余额
    For c_预交 In (Select 病人id, 预交类别, -1 * Sum(Nvl(冲预交, 0)) As 冲预交
                 From 病人预交记录
                 Where 记录性质 In (1, 11) And 结帐id = n_销帐id
                 Group By 病人id, 预交类别) Loop
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + Nvl(c_预交.冲预交, 0)
      Where 病人id = c_预交.病人id And 类型 = Nvl(c_预交.预交类别, 2) And 性质 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 预交余额, 性质, 类型)
        Values
          (c_预交.病人id, Nvl(c_预交.冲预交, 0), 1, Nvl(c_预交.预交类别, 2));
        n_返回值 := Nvl(c_预交.冲预交, 0);
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = c_预交.病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
      End If;
    End Loop;
  
    If 收回票据号_In Is Not Null Then
      --光退挂号费,不回收票据
      --退卡收回票据(可能上次挂号使用票据,不能收回)
      Begin
        --从最后一次打印的内容中取
        --81907
        Select ID
        Into n_打印id
        From (Select b.Id
               From 票据使用明细 A, 票据打印内容 B
               Where a.打印id = b.Id And a.性质 = 1 And a.原因 In (1, 3) And b.数据性质 = 4 And b.No = 单据号_In
               Order By a.使用时间 Desc)
        Where Rownum < 2;
      Exception
        When Others Then
          n_打印id := Null;
      End;
    
      --先收回原票据
      If n_打印id Is Not Null Then
        Begin
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
            From 票据使用明细
            Where 打印id = n_打印id And 性质 = 1 And Instr(',' || 收回票据号_In || ',', ',' || 号码 || ',') > 0;
        Exception
          When Others Then
            Delete From 票据使用明细 Where 打印id = n_打印id And 性质 = 2 And 原因 = 2;
            Insert Into 票据使用明细
              (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
              Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
              From 票据使用明细
              Where 打印id = n_打印id And 性质 = 1 And Instr(',' || 收回票据号_In || ',', ',' || 号码 || ',') > 0;
        End;
      End If;
    End If;
  End If;

  --单独退病历费用,不处理汇总记录
  --相关汇总表的处理

  --病人挂号汇总
  If Nvl(退费类型_In, 0) Not In (2, 3) Then
    Open c_Registinfo(3);
    Fetch c_Registinfo
      Into r_Registrow;
  
    If c_Registinfo%RowCount = 0 Then
      --只收病历费时无号别,不处理
      Close c_Registinfo;
    Else
    
      --需要确定是否预约挂号
      --1.如果是退预约挂号产生的挂号记录,则需要减已挂数和其中已接数
      --2.如果是正常挂号,则只减已挂数
    
      Begin
        Select Decode(预约, Null, 0, 0, 0, 1) Into n_预约挂号 From 病人挂号记录 Where NO = 单据号_In And Rownum = 1;
      Exception
        When Others Then
          n_预约挂号 := 0;
      End;
    
      Update 病人挂号汇总
      Set 已挂数 = Nvl(已挂数, 0) - 1, 其中已接收 = Nvl(其中已接收, 0) - n_预约挂号, 已约数 = Nvl(已约数, 0) - n_预约挂号
      Where 日期 = Trunc(r_Registrow.发生时间) And 科室id = r_Registrow.科室id And 项目id = r_Registrow.项目id And
            (号码 = r_Registrow.号码 Or 号码 Is Null);
    
      If Sql%RowCount = 0 Then
        Insert Into 病人挂号汇总
          (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 其中已接收, 已约数)
        Values
          (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
           Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, -1, -1 * n_预约挂号, -1 * n_预约挂号);
      End If;
    
      If n_出诊记录id Is Not Null Then
        Update 临床出诊记录
        Set 已挂数 = Nvl(已挂数, 0) - 1, 其中已接收 = Nvl(其中已接收, 0) - n_预约挂号, 已约数 = Nvl(已约数, 0) - n_预约挂号
        Where ID = n_出诊记录id And Nvl(已约数, 0) > 0;
        Update 临床出诊序号控制 Set 挂号状态 = Null, 操作员姓名 = Null Where 记录id = n_出诊记录id And 序号 = n_序号;
      End If;
    
      Close c_Registinfo;
    End If;
  End If;

  If n_记帐 = 0 Then
    --人员缴款余额(包括个人帐户等的结算金额,不含退冲预交款)
    For r_Opermoney In c_Opermoney(n_销帐id) Loop
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + (-1 * r_Opermoney.冲预交)
      Where 收款员 = 操作员姓名_In And 结算方式 = r_Opermoney.结算方式 And 性质 = 1
      Returning 余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (操作员姓名_In, r_Opermoney.结算方式, 1, -1 * r_Opermoney.冲预交);
        n_返回值 := r_Opermoney.冲预交;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = 操作员姓名_In And 结算方式 = r_Opermoney.结算方式 And 性质 = 1 And Nvl(余额, 0) = 0;
      End If;
    End Loop;
  End If;
  If Nvl(退费类型_In, 0) Not In (2, 3) Then
    n_挂号生成队列 := Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113));
    If n_挂号生成队列 <> 0 Then
      n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
      If Nvl(n_分诊台签到排队, 0) = 0 Then
      
        --要删除队列
        For v_挂号 In (Select ID, 诊室, 执行部门id, 执行人 From 病人挂号记录 Where NO = 单据号_In) Loop
          Zl_排队叫号队列_Delete(v_挂号.执行部门id, v_挂号.Id);
        End Loop;
      End If;
    End If;
  
    --医保产生的就诊登记记录
    Begin
      Select 病人id, 发生时间 Into n_就诊病人id, d_就诊时间 From 病人挂号记录 Where NO = 单据号_In;
      Delete From 就诊登记记录 Where 病人id = n_就诊病人id And 就诊时间 = d_就诊时间 And 主页id Is Null;
    Exception
      When Others Then
        Null;
    End;
  
    --病人挂号记录
    Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
  
    Update 病人挂号记录 Set 记录状态 = 3 Where NO = 单据号_In And 记录性质 = 1 And 记录状态 = 1;
    If Sql%NotFound Then
      v_Err_Msg := '挂号单【' || 单据号_In || '】不存在或由于并发原因已经被退号';
      Raise Err_Item;
    End If;
    Insert Into 病人挂号记录
      (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 操作员编号, 操作员姓名,
       复诊, 号序, 社区, 预约, 摘要, 预约方式, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 险类, 医疗付款方式)
      Select n_挂号id, NO, 记录性质, 2, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, d_Date, 发生时间,
             操作员编号_In, 操作员姓名_In, 复诊, 号序, 社区, 预约, Nvl(摘要_In, 摘要) As 摘要, 预约方式, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 险类, 医疗付款方式
      From 病人挂号记录
      Where NO = 单据号_In;
  End If;
  --消息推送
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 2, 单据号_In;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人挂号记录_Delete;
/


Create Or Replace Procedure Zl_病人挂号票据_Insert
(
  No_In           Varchar2,
  票据号_In       票据使用明细.号码%Type,
  领用id_In       票据使用明细.领用id%Type,
  使用人_In       票据使用明细.使用人%Type,
  使用时间_In     票据使用明细.使用时间%Type,
  票据张数_In     Number := 1,
  医保接口打印_In Number := 0,
  收费票据_In     Number := 0
) As
  --功能：处理门诊挂号票据的发出
  --参数：
  --      NO_IN       =     挂号的单据号。格式为：A0000001
  --      票据号_IN   =     要使用的开始票据号。该票据号应该不为空，为空时不处理数据
  --      领用ID_IN   =     严格控制票据时，为使用票据的领用批次。非严格控制时，为NULL。
  --      票据张数_In =     实际所需的票据打印张数
  --      医保接口打印_In = 是否医保接口打印先存入票据数据，若是将传入打印id_In
  --      收费票据_In =     挂号是否使用收费票据
  --该游标用于票据范围判断
  Cursor c_Fact Is
    Select * From 票据领用记录 Where ID = Nvl(领用id_In, 0);
  r_Factrow c_Fact%RowType;

  v_票据号     票据使用明细.号码%Type;
  v_当前票据号 票据使用明细.号码%Type;
  n_打印id     票据打印内容.Id%Type;

  v_当前号 门诊费用记录.No%Type;
  v_单据号 Varchar2(1000);

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin

  --无票据号时,不用处理票据
  If 票据号_In Is Null Then
    Return;
  End If;

  Select 票据打印内容_Id.Nextval Into n_打印id From Dual;

  --生成单据的票据打印内容
  Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 4, No_In);
  Update 门诊费用记录 Set 实际票号 = 票据号_In Where NO = No_In And 记录性质 = 4;

  --并发出票据
  v_票据号 := 票据号_In;
  If Nvl(领用id_In, 0) <> 0 Then
    Open c_Fact;
    Fetch c_Fact
      Into r_Factrow;
    If c_Fact%RowCount = 0 Then
      v_Error := '无效的票据领用批次，无法完成挂号票据分配操作。';
      Close c_Fact;
      Raise Err_Custom;
    Elsif Nvl(r_Factrow.剩余数量, 0) < 票据张数_In Then
      v_Error := '当前批次的剩余数量不足' || 票据张数_In || '张，无法完成挂号票据分配操作。';
      Close c_Fact;
      Raise Err_Custom;
    End If;
  End If;
  For I In 1 .. 票据张数_In Loop
    --检查票据范围是否正确
    If Nvl(领用id_In, 0) <> 0 Then
      If Not (Upper(v_票据号) >= Upper(r_Factrow.开始号码) And Upper(v_票据号) <= Upper(r_Factrow.终止号码) And
          Length(v_票据号) = Length(r_Factrow.终止号码)) Then
        v_Error := '该单据需要打印多张票据,但票据号"' || v_票据号 || '"超出票据领用的号码范围！';
        Close c_Fact;
        Raise Err_Custom;
      End If;
    End If;
  
    --发出票据
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
    Values
      (票据使用明细_Id.Nextval, Decode(收费票据_In, 1, 1, 4), v_票据号, 1, 1, 领用id_In, n_打印id, 使用时间_In, 使用人_In);
  
    v_当前票据号 := v_票据号;
    --下一个票据号
    v_票据号 := Zl_Incstr(v_票据号);
  End Loop;

  If Nvl(领用id_In, 0) <> 0 Then
    Update 票据领用记录
    Set 使用时间 = 使用时间_In, 当前号码 = v_当前票据号, 剩余数量 = Nvl(剩余数量, 0) - 票据张数_In
    Where ID = 领用id_In;
    Close c_Fact;
  End If;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人挂号票据_Insert;
/

Create Or Replace Procedure Zl_病人挂号记录_Reprint
(
  No_In         门诊费用记录.No%Type,
  票据号_In     票据使用明细.号码%Type,
  领用id_In     票据使用明细.领用id%Type,
  使用人_In     票据使用明细.使用人%Type,
  使用时间_In   票据使用明细.使用时间%Type,
  退费_In       Number := 0,
  票据张数_In   Number := 0,
  收回票据号_In Varchar2 := Null,
  收费票据_In   Number := 0
) As
  --功能：用于重打收费票据 
  --参数： 
  --      NO_IN         =   要重打的单据号。 
  --      票据号        =   用于重打的起始票据号.而该张挂号单据可能使用多张票据。 
  --      领用ID        =   如果为0或NULL,表示不严格控制票据。 
  --      退费_IN       =   是否部份退费时调用该过程 
  --      收回票据号_In =   界面选择要收回的票据 
  --该游标用于范围判断 
  Cursor c_Fact Is
    Select 开始号码, 终止号码 From 票据领用记录 Where ID = Nvl(领用id_In, 0);
  r_Factrow c_Fact%RowType;

  v_收回id   票据打印内容.Id%Type;
  v_打印id   票据打印内容.Id%Type;
  v_票据号   票据使用明细.号码%Type;
  n_补打     Number(2);
  n_分单据   Number(2);
  n_打印类型 票据打印内容.打印类型%Type;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin

  Begin
    --从最后一次打印的内容中取
    --81907
    Select ID
    Into v_收回id
    From (Select b.Id
           From 票据使用明细 A, 票据打印内容 B
           Where a.打印id = b.Id And a.性质 = 1 And a.原因 In (1, 3) And b.数据性质 = 4 And b.No = No_In
           Order By a.使用时间 Desc)
    Where Rownum < 2;
  Exception
    When Others Then
      Null;
  End;

  --先收回原票据(可能以前未使用票据,不能收回)
  If v_收回id Is Not Null Then
    Begin
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
        Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 4, 领用id, 打印id, 使用时间_In, 使用人_In
        From 票据使用明细
        Where 打印id = v_收回id And 性质 = 1 And Instr(',' || 收回票据号_In || ',', ',' || 号码 || ',') > 0;
    Exception
      When Others Then
        Delete From 票据使用明细 Where 打印id = v_收回id And 性质 = 2 And 原因 = 2;
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 4, 领用id, 打印id, 使用时间_In, 使用人_In
          From 票据使用明细
          Where 打印id = v_收回id And 性质 = 1 And Instr(',' || 收回票据号_In || ',', ',' || 号码 || ',') > 0;
    End;
  End If;

  --无票据号时,不用处理票据 
  If 票据号_In Is Null Then
    Return;
  End If;

  --重新发出票据并填写票据打印内容 
  Select 票据打印内容_Id.Nextval Into v_打印id From Dual;
  Insert Into 票据打印内容 (ID, 数据性质, NO) Values (v_打印id, 4, No_In);
  Update 门诊费用记录 Set 实际票号 = 票据号_In Where NO = No_In And 记录性质 = 4;

  v_票据号 := 票据号_In;

  If Nvl(领用id_In, 0) <> 0 Then
    Open c_Fact;
    Fetch c_Fact
      Into r_Factrow;
    If c_Fact%RowCount = 0 Then
      v_Error := '无效的票据领用批次,无法完成重打操作！';
      Close c_Fact;
      Raise Err_Custom;
    End If;
  End If;
  For I In 1 .. 票据张数_In Loop
    If Nvl(领用id_In, 0) <> 0 Then
      --检查票据范围 
      If Not (Upper(v_票据号) >= Upper(r_Factrow.开始号码) And Upper(v_票据号) <= Upper(r_Factrow.终止号码) And
          Length(v_票据号) = Length(r_Factrow.终止号码)) Then
        v_Error := '单据需要打印多张票据,但票据号"' || v_票据号 || '"超出票据领用的号码范围！';
        Close c_Fact;
        Raise Err_Custom;
      End If;
    End If;
  
    --发出票据:重打时,如果是部份退费重打,则处理为新发生；如果以前没有收回，也处理为新发出。 
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
    Values
      (票据使用明细_Id.Nextval, Decode(收费票据_In, 1, 1, 4), v_票据号, 1, Decode(Nvl(退费_In, 0), 0, Decode(v_收回id, Null, 1, 3), 1),
       领用id_In, v_打印id, 使用人_In, 使用时间_In);
  
    Update 票据领用记录
    Set 当前号码 = v_票据号, 剩余数量 = Decode(Sign(Nvl(剩余数量, 0) - 1), -1, 0, Nvl(剩余数量, 0) - 1)
    Where ID = Nvl(领用id_In, 0);
  
    v_票据号 := Zl_Incstr(v_票据号);
  End Loop;

  Update 票据领用记录 Set 使用时间 = 使用时间_In Where ID = 领用id_In;

  If Nvl(领用id_In, 0) <> 0 Then
    Close c_Fact;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人挂号记录_Reprint;
/

Create Or Replace Procedure Zl_病人挂号记录_出诊_Delete
(
  单据号_In       门诊费用记录.No%Type,
  操作员编号_In   门诊费用记录.操作员编号%Type,
  操作员姓名_In   门诊费用记录.操作员姓名%Type,
  摘要_In         门诊费用记录.摘要%Type := Null, --预约取消时 填写 存放预约取消原因
  删除门诊号_In   Number := 0,
  非原样退结算_In Varchar2 := Null,
  退费类型_In     In Number := 0, --0-全退 1-退挂号费 2-退病历费
  退指定结算_In   病人预交记录.结算方式%Type := Null,
  退号重用_In     Number := 1,
  结算方式_In     Varchar2 := Null,
  退预交_In       病人预交记录.冲预交%Type := Null,
  收回票据号_In   Varchar2 := Null
) As
  --退费类型_In,在一下几种情况下不准进行部分退费
  --    2.三方接口,暂时不支持
  -- 挂号费病历费分开退,规则
  --    普通结算方式:原结算方式退部分费用
  --    预交款:预交款,退部分
  --    预交款与普通结算方式混合:退款按照普通结算方式部分退
  --    消费卡:原样将费用部分退入消费卡
  --非原样退结算_In:指不能退还给原样结算方式(如医保的个人账户,三方账户的退现等),多个用逗分离
  --退指定结算_IN:指非原样退结算部分,应该退给哪种结算方式,为空时缺省退给现金,否则退给指定的结算方式

  --该游标用于判断是否单独收病历费,及挂号汇总表处理
  Cursor c_Registinfo(v_状态 门诊费用记录.记录状态%Type) Is
    Select a.发生时间, a.登记时间, c.接收时间, a.收费细目id As 项目id, c.执行部门id As 科室id, c.执行人 As 医生姓名, d.Id As 医生id, c.号别 As 号码
    From 门诊费用记录 A, 病人挂号记录 C, 人员表 D
    Where a.记录性质 = 4 And a.No = 单据号_In And a.No = c.No And a.记录状态 = v_状态 And c.执行人 = d.姓名(+) And Rownum < 2;
  r_Registrow c_Registinfo%RowType;

  --该游标用于判断记录是否存在,及费用汇总表处理
  Cursor c_Moneyinfo(v_状态 门诊费用记录.记录状态%Type) Is
    Select 病人科室id, 开单部门id, 执行部门id, 收入项目id, Nvl(Sum(应收金额), 0) As 应收, Nvl(Sum(实收金额), 0) As 实收, Nvl(Sum(结帐金额), 0) As 结帐
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 = v_状态 And NO = 单据号_In
    Group By 病人科室id, 开单部门id, 执行部门id, 收入项目id;
  r_Moneyrow c_Moneyinfo%RowType;

  --该光标用于处理人员缴款余额中退的不同结算方式的金额
  Cursor c_Opermoney(n_Id 病人预交记录.结帐id%Type) Is
    Select Distinct b.结算方式, -1 * Nvl(b.冲预交, 0) As 冲预交
    From 病人预交记录 B
    Where b.结帐id = n_Id And b.记录性质 = 4 And b.记录状态 = 2 And Nvl(b.冲预交, 0) <> 0;

  v_Err_Msg Varchar(255);
  Err_Item Exception;

  n_结帐id 病人预交记录.结帐id%Type;
  n_销帐id 门诊费用记录.结帐id%Type;

  v_退指定结算方式 病人预交记录.结算方式%Type;
  n_退款金额       病人预交记录.冲预交%Type;
  n_打印id         票据打印内容.Id%Type;
  n_病人id         病人信息.病人id%Type;
  n_退费金额       病人预交记录.冲预交%Type;
  n_预交金额       病人预交记录.冲预交%Type; --原记录 预交缴款金额
  n_返回值         病人余额.预交余额%Type;
  n_挂号id         病人挂号记录.Id%Type;
  n_组id           财务缴款分组.Id%Type;

  n_二次退费       Number; --记录是否是此单据的第二次退费
  n_分诊台签到排队 Number;
  n_预约生成队列   Number;
  n_预约挂号       Number;
  n_挂号生成队列   Number;
  d_Date           Date;
  n_记帐           门诊费用记录.记帐费用%Type;
  n_病人id1        病人信息.病人id%Type;
  n_返回额         门诊费用记录.实收金额%Type;
  n_已结帐         Number;
  n_序号           病人挂号记录.号序%Type;
  n_就诊病人id     病人信息.病人id%Type;
  d_就诊时间       就诊登记记录.就诊时间%Type;
  n_出诊记录id     临床出诊记录.Id%Type;
  v_结算内容       Varchar2(5000);
  v_当前结算       Varchar2(1000);
  v_附加ids        Varchar2(500);
  v_Temp           Varchar2(500);
  v_结算方式       病人预交记录.结算方式%Type;
  n_三方卡标志     Number;
  n_结算金额       病人预交记录.冲预交%Type;
  n_检查数         Number;
Begin
  n_组id           := Zl_Get组id(操作员姓名_In);
  v_退指定结算方式 := 退指定结算_In;

  Select 出诊记录id, 号序 Into n_出诊记录id, n_序号 From 病人挂号记录 Where NO = 单据号_In And Rownum < 2;

  --首先判断要退号/取消预约的记录是否存在
  Open c_Moneyinfo(1);
  Fetch c_Moneyinfo
    Into r_Moneyrow;
  If c_Moneyinfo%RowCount = 0 Then
    Close c_Moneyinfo;
    Open c_Moneyinfo(0);
    Fetch c_Moneyinfo
      Into r_Moneyrow;
    If c_Moneyinfo%RowCount = 0 Then
      v_Err_Msg := '要处理的单据不存在。';
      Raise Err_Item;
    End If;
    n_预约挂号 := 1;
  End If;
  Close c_Moneyinfo;

  Begin
    Select Zl_Fun_Regcustomname Into v_Temp From Dual;
    If v_Temp Is Not Null Then
      v_附加ids := Substr(v_Temp, Instr(v_Temp, '|') + 1);
    End If;
  Exception
    When Others Then
      v_附加ids := Null;
  End;

  --1.预约处理
  If Nvl(n_预约挂号, 0) = 1 Then
    --减少已约数
    Open c_Registinfo(0);
    Fetch c_Registinfo
      Into r_Registrow;
  
    n_检查数 := Null;
    Update 临床出诊记录 Set 已约数 = Nvl(已约数, 0) - 1 Where ID = n_出诊记录id Returning 已约数 Into n_检查数;
    If Nvl(n_检查数, 0) < 0 Then
      Update 临床出诊记录 Set 已约数 = 0 Where ID = n_出诊记录id;
    End If;
  
    Update 病人挂号汇总
    Set 已约数 = Nvl(已约数, 0) - 1
    Where 日期 = Trunc(r_Registrow.发生时间) And Nvl(医生id, 0) = Nvl(r_Registrow.医生id, 0) And
          Nvl(医生姓名, '-') = Nvl(r_Registrow.医生姓名, '-') And 科室id = r_Registrow.科室id And 项目id = r_Registrow.项目id And
          (号码 = r_Registrow.号码 Or 号码 Is Null);
  
    If Sql%RowCount = 0 Then
      Insert Into 病人挂号汇总
        (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已约数)
      Values
        (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
         Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, -1);
    End If;
  
    Close c_Registinfo;
  
    --更新挂号序号状态
    Update 临床出诊序号控制
    Set 挂号状态 = 0, 操作员姓名 = Null
    Where 挂号状态 = 2 And 记录id = n_出诊记录id And 序号 = n_序号;
  
    Update 临床出诊序号控制
    Set 挂号状态 = 4, 操作员姓名 = Null
    Where 挂号状态 = 2 And 记录id = n_出诊记录id And 备注 = To_Char(n_序号);
  
    --添加病人挂号记录的 冲销记录
    Select 病人挂号记录_Id.Nextval, Sysdate Into n_挂号id, d_Date From Dual;
  
    Update 病人挂号记录 Set 记录状态 = 3 Where NO = 单据号_In And 记录状态 = 1 And 记录性质 = 2;
    If Sql%NotFound Then
      v_Err_Msg := '预约单【' || 单据号_In || '】不存在或由于并发原因已经被取消预约';
      Raise Err_Item;
    End If;
  
    Insert Into 病人挂号记录
      (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 操作员编号, 操作员姓名,
       复诊, 号序, 社区, 预约, 摘要, 预约方式, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 医疗付款方式, 出诊记录id, 预约操作员, 预约操作员编号)
      Select n_挂号id, NO, 记录性质, 2, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, d_Date, 发生时间,
             操作员编号_In, 操作员姓名_In, 复诊, 号序, 社区, 预约, Nvl(摘要_In, 摘要) As 摘要, 预约方式, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 医疗付款方式,
             n_出诊记录id, 预约操作员, 预约操作员编号
      From 病人挂号记录
      Where NO = 单据号_In;
  
    Update 门诊费用记录 Set 记录状态 = 3 Where NO = 单据号_In And 记录性质 = 4 And 记录状态 = 0;
    Insert Into 门诊费用记录
      (ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 记帐单id, 病人id, 医嘱序号, 门诊标志, 记帐费用, 姓名, 性别, 年龄, 标识号, 付款方式, 病人科室id, 费别, 收费类别,
       收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id,
       执行人, 执行状态, 执行时间, 结论, 操作员编号, 操作员姓名, 结帐id, 结帐金额, 保险大类id, 保险项目否, 保险编码, 费用类型, 统筹金额, 是否上传, 摘要, 是否急诊, 缴款组id, 费用状态, 待转出,
       挂号id, 主页id)
      Select 病人费用记录_Id.Nextval, 记录性质, NO, 实际票号, 2, 序号, 从属父号, 价格父号, 记帐单id, 病人id, 医嘱序号, 门诊标志, 记帐费用, 姓名, 性别, 年龄, 标识号, 付款方式,
             病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, -1 * 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, -1 * 应收金额,
             -1 * 实收金额, 划价人, 开单部门id, 开单人, 发生时间, d_Date, 执行部门id, 执行人, -1, 执行时间, 结论, 操作员编号_In, 操作员姓名_In, Null, Null,
             保险大类id, 保险项目否, 保险编码, 费用类型, 统筹金额, 是否上传, 摘要, 是否急诊, 缴款组id, 费用状态, 待转出, 挂号id, 主页id
      From 门诊费用记录
      Where NO = 单据号_In And 记录性质 = 4 And 记录状态 = 3;
  
    --如果预约生成队列时需要清除队列
  
    n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
    If Nvl(n_预约生成队列, 0) = 1 Then
      --要删除队列
      For v_挂号 In (Select ID, 诊室, 执行部门id, 执行人 From 病人挂号记录 Where NO = 单据号_In) Loop
        Zl_排队叫号队列_Delete(v_挂号.执行部门id, v_挂号.Id);
      End Loop;
    End If;
    Return;
  End If;

  Select Nvl(记帐费用, 0), 病人id, Decode(Sign(Nvl(结帐id, 0)), 0, 0, 1)
  Into n_记帐, n_病人id, n_已结帐
  From 门诊费用记录
  Where 记录性质 = 4 And NO = 单据号_In And 记录状态 In (1, 3) And Rownum < 2;

  --2.挂号处理
  n_已结帐 := Nvl(n_已结帐, 0);

  If n_已结帐 = 1 And n_记帐 = 1 Then
    Select Sysdate, Null Into d_Date, n_销帐id From Dual;
  Else
    Select Sysdate, 病人结帐记录_Id.Nextval Into d_Date, n_销帐id From Dual;
  End If;

  ----0-全退 1-退挂号费 2-退病历费
  If Nvl(退费类型_In, 0) <> 2 Then
    --不是光退病历费时处理
    --更新挂号序号状态
    If 退号重用_In = 1 Then
      Update 临床出诊序号控制
      Set 挂号状态 = 0, 操作员姓名 = Null
      Where 挂号状态 = 1 And 记录id = n_出诊记录id And 序号 = n_序号;
    
      Update 临床出诊序号控制
      Set 挂号状态 = 4, 操作员姓名 = Null
      Where 挂号状态 = 1 And 记录id = n_出诊记录id And 备注 = To_Char(n_序号);
    Else
      Update 临床出诊序号控制
      Set 挂号状态 = 4, 操作员姓名 = 操作员姓名_In
      Where 挂号状态 = 1 And 记录id = n_出诊记录id And (序号 = n_序号 Or 备注 = To_Char(n_序号));
    End If;
  
    --病人就诊状态
    If n_病人id Is Not Null Then
      Update 病人信息 Set 就诊状态 = 0, 就诊诊室 = Null Where 病人id = n_病人id;
    
      --删除门诊号相关处理,只有当只有一条挂号记录并且病人建档日期与挂号日期近似时才会处理
      If 删除门诊号_In = 1 Then
        Delete 门诊病案记录 Where 病人id = n_病人id;
        Update 病人信息 Set 门诊号 = Null Where 病人id = n_病人id;
        --费用记录包括挂号及病案、就诊卡费用,以及病人交费后退费或销帐的费用,挂号记录在最后处理
        Update 门诊费用记录 Set 标识号 = Null Where 门诊标志 = 1 And 病人id = n_病人id;
      End If;
    End If;
  
    --如果挂时收了就诊卡费,退费时清除就诊卡号,在非光退病历费时
    n_病人id1 := Null;
    Begin
      Select 病人id
      Into n_病人id1
      From 门诊费用记录
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And 附加标志 = 2 And Rownum < 2;
    Exception
      When Others Then
        Null;
    End;
  
    If n_病人id1 Is Not Null And Nvl(退费类型_In, 0) <> 2 Then
      Update 病人信息
      Set 就诊卡号 = Null, 卡验证码 = Null, Ic卡号 = Decode(Ic卡号, 就诊卡号, Null, Ic卡号)
      Where 病人id = n_病人id1;
    End If;
  
  End If;

  --检查前面是否已经部分退过费用
  Begin
    Select 1 Into n_二次退费 From 门诊费用记录 Where 记录性质 = 4 And NO = 单据号_In And 记录状态 = 3 And Rownum < 2;
  Exception
    When Others Then
      n_二次退费 := 0;
  End;

  --门诊费用记录
  --冲销记录
  If Nvl(退费类型_In, 0) = 0 Or Nvl(退费类型_In, 0) = 2 Then
    --全退,退病历费
    --门诊费用记录，冲销记录
    Insert Into 门诊费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别, 收费细目id, 计算单位, 付数,
       数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 执行人, 操作员编号, 操作员姓名, 发生时间, 登记时间,
       结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 缴款组id)
      Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别,
             收费细目id, 计算单位, 付数, -数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, -应收金额, -实收金额, 开单部门id, 开单人, 执行部门id, 执行人,
             操作员编号_In, 操作员姓名_In, 发生时间, d_Date, n_销帐id,
             Decode(n_记帐, 1, Decode(Nvl(n_已结帐, 0), 0, -1 * 实收金额, Null), -1 * 结帐金额), 保险项目否, 保险大类id, -1 * 统筹金额,
             Nvl(摘要_In, 摘要) As 摘要, Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, n_组id
      From 门诊费用记录
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And
            Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
  
    --原始记录
    If n_记帐 = 1 And Nvl(n_已结帐, 0) = 0 Then
      Update 门诊费用记录
      Set 记录状态 = 3, 结帐id = n_销帐id, 结帐金额 = 实收金额
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And
            Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
    Else
      Update 门诊费用记录
      Set 记录状态 = 3
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And
            Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
    End If;
  Elsif Nvl(退费类型_In, 0) = 1 Or Nvl(退费类型_In, 0) = 4 Then
    --退挂号费,退挂号与病历费
    --门诊费用记录，冲销记录
    Insert Into 门诊费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别, 收费细目id, 计算单位, 付数,
       数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 执行人, 操作员编号, 操作员姓名, 发生时间, 登记时间,
       结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 缴款组id)
      Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别,
             收费细目id, 计算单位, 付数, -数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, -应收金额, -实收金额, 开单部门id, 开单人, 执行部门id, 执行人,
             操作员编号_In, 操作员姓名_In, 发生时间, d_Date, n_销帐id,
             Decode(n_记帐, 1, Decode(Nvl(n_已结帐, 0), 0, -1 * 实收金额, Null), -1 * 结帐金额), 保险项目否, 保险大类id, -1 * 统筹金额,
             Nvl(摘要_In, 摘要) As 摘要, Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, n_组id
      From 门诊费用记录
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And Instr(',' || v_附加ids || ',', ',' || 收费细目id || ',') = 0 And
            Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
  
    --原始记录
    If n_记帐 = 1 And Nvl(n_已结帐, 0) = 0 Then
      Update 门诊费用记录
      Set 记录状态 = 3, 结帐id = n_销帐id, 结帐金额 = 实收金额
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And Instr(',' || v_附加ids || ',', ',' || 收费细目id || ',') = 0 And
            Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
    Else
      Update 门诊费用记录
      Set 记录状态 = 3
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And Instr(',' || v_附加ids || ',', ',' || 收费细目id || ',') = 0 And
            Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
    End If;
  Elsif Nvl(退费类型_In, 0) = 3 Then
    --退附加费
    --门诊费用记录，冲销记录
    Insert Into 门诊费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别, 收费细目id, 计算单位, 付数,
       数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 执行人, 操作员编号, 操作员姓名, 发生时间, 登记时间,
       结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 缴款组id)
      Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别,
             收费细目id, 计算单位, 付数, -数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, -应收金额, -实收金额, 开单部门id, 开单人, 执行部门id, 执行人,
             操作员编号_In, 操作员姓名_In, 发生时间, d_Date, n_销帐id,
             Decode(n_记帐, 1, Decode(Nvl(n_已结帐, 0), 0, -1 * 实收金额, Null), -1 * 结帐金额), 保险项目否, 保险大类id, -1 * 统筹金额,
             Nvl(摘要_In, 摘要) As 摘要, Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, n_组id
      From 门诊费用记录
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And Instr(',' || v_附加ids || ',', ',' || 收费细目id || ',') > 0 And
            Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
  
    --原始记录
    If n_记帐 = 1 And Nvl(n_已结帐, 0) = 0 Then
      Update 门诊费用记录
      Set 记录状态 = 3, 结帐id = n_销帐id, 结帐金额 = 实收金额
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And Instr(',' || v_附加ids || ',', ',' || 收费细目id || ',') > 0 And
            Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
    Else
      Update 门诊费用记录
      Set 记录状态 = 3
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And Instr(',' || v_附加ids || ',', ',' || 收费细目id || ',') > 0 And
            Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
    End If;
  Elsif Nvl(退费类型_In, 0) = 5 Then
    --退挂号与附加费
    --门诊费用记录，冲销记录
    Insert Into 门诊费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别, 收费细目id, 计算单位, 付数,
       数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 执行人, 操作员编号, 操作员姓名, 发生时间, 登记时间,
       结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 缴款组id)
      Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别,
             收费细目id, 计算单位, 付数, -数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, -应收金额, -实收金额, 开单部门id, 开单人, 执行部门id, 执行人,
             操作员编号_In, 操作员姓名_In, 发生时间, d_Date, n_销帐id,
             Decode(n_记帐, 1, Decode(Nvl(n_已结帐, 0), 0, -1 * 实收金额, Null), -1 * 结帐金额), 保险项目否, 保险大类id, -1 * 统筹金额,
             Nvl(摘要_In, 摘要) As 摘要, Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, n_组id
      From 门诊费用记录
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And Nvl(附加标志, 0) <> 1;
  
    --原始记录
    If n_记帐 = 1 And Nvl(n_已结帐, 0) = 0 Then
      Update 门诊费用记录
      Set 记录状态 = 3, 结帐id = n_销帐id, 结帐金额 = 实收金额
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And Nvl(附加标志, 0) <> 1;
    Else
      Update 门诊费用记录
      Set 记录状态 = 3
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And Nvl(附加标志, 0) <> 1;
    End If;
  End If;

  n_结帐id := 0;
  If n_记帐 = 0 Then
    --获取结帐ID
    Select Nvl(结帐id, 0)
    Into n_结帐id
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 = 3 And NO = 单据号_In And
          Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0)) And
          Rownum = 1;
  End If;

  If n_记帐 = 1 Then
    --记帐
    For c_费用 In (Select 实收金额, 病人科室id, 开单部门id, 执行部门id, 收入项目id
                 From 门诊费用记录
                 Where 记录性质 = 4 And 记录状态 = 3 And NO = 单据号_In And
                       Nvl(附加标志, 0) =
                       Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0)) And
                       Nvl(记帐费用, 0) = 1) Loop
      --病人余额
      Update 病人余额
      Set 费用余额 = Nvl(费用余额, 0) - Nvl(c_费用.实收金额, 0)
      Where 病人id = Nvl(n_病人id, 0) And 性质 = 1 And 类型 = 1
      Returning 费用余额 Into n_返回额;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 费用余额, 预交余额)
        Values
          (n_病人id, 1, 1, -1 * Nvl(c_费用.实收金额, 0), 0);
        n_返回额 := Nvl(c_费用.实收金额, 0);
      End If;
      If Nvl(n_返回额, 0) = 0 Then
        Delete 病人余额
        Where 病人id = Nvl(n_病人id, 0) And 性质 = 1 And 类型 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
      --病人未结费用
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) - Nvl(c_费用.实收金额, 0)
      Where 病人id = n_病人id And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(c_费用.病人科室id, 0) And
            Nvl(开单部门id, 0) = Nvl(c_费用.开单部门id, 0) And Nvl(执行部门id, 0) = Nvl(c_费用.执行部门id, 0) And 收入项目id + 0 = c_费用.收入项目id And
            来源途径 + 0 = 1;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人未结费用
          (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
        Values
          (n_病人id, Null, Null, c_费用.病人科室id, c_费用.开单部门id, c_费用.执行部门id, c_费用.收入项目id, 1, -1 * Nvl(c_费用.实收金额, 0));
      End If;
    End Loop;
    Delete 病人未结费用
    Where 病人id = n_病人id And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(金额, 0) = 0 And 来源途径 + 0 = 1;
  End If;

  If n_记帐 = 0 Then
    --1.退费
    --病人挂号结算:现金和个人帐户部份
    If 结算方式_In Is Null Then
      If 非原样退结算_In Is Not Null Then
        --退款金额获取
        If Nvl(退费类型_In, 0) <> 0 Or Nvl(n_二次退费, 0) <> 0 Then
          --如果是单独退病历费,或者只退挂号费,先获取退费金额
          Begin
            --获取本次退款金额
            Select Sum(Nvl(实收金额, 0)) As 收款金额
            Into n_退款金额
            From 门诊费用记录
            Where NO = 单据号_In And 记录性质 = 4 And 记录状态 = 3 And
                  Nvl(附加标志, 0) =
                  Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
          
          Exception
            When Others Then
              v_Err_Msg := '单据【' || 单据号_In || '】的' || Case Nvl(退费类型_In, 0)
                             When 1 Then
                              '挂号费用'
                             When 2 Then
                              '病历费'
                           End || '可能由于并发原因已经进行了退费或者单据不存在!';
              Raise Err_Item;
          End;
          Begin
            Select 冲预交
            Into n_退费金额
            From 病人预交记录
            Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_结帐id And Instr(',' || 非原样退结算_In || ',', ',' || 结算方式 || ',') = 0;
          Exception
            When Others Then
              n_退费金额 := 0;
          End;
        
          --a.允许的结算方式
        
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
             结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_Date, 操作员编号_In, 操作员姓名_In, -n_退款金额,
                   n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
            From 病人预交记录
            Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_结帐id And Instr(',' || 非原样退结算_In || ',', ',' || 结算方式 || ',') = 0;
        
          If n_退费金额 = 0 Then
            --b.不允许的退现金
            If n_退款金额 <> 0 Then
              If v_退指定结算方式 Is Null Then
                --退给现金
                Begin
                  Select 名称 Into v_退指定结算方式 From 结算方式 Where 性质 = 1;
                Exception
                  When Others Then
                    v_退指定结算方式 := '现金';
                End;
              End If;
              Update 病人预交记录
              Set 冲预交 = 冲预交 + (-1 * n_退款金额)
              Where 记录性质 = 4 And 记录状态 = 2 And 结帐id = n_销帐id And 结算方式 = v_退指定结算方式;
              If Sql%RowCount = 0 Then
                Insert Into 病人预交记录
                  (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
                   卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
                  Select 病人预交记录_Id.Nextval, a.No, a.实际票号, a.记录性质, 2, a.病人id, a.主页id, a.科室id, a.摘要, v_退指定结算方式, d_Date,
                         操作员编号_In, 操作员姓名_In, -1 * n_退款金额, n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
                  From 病人预交记录 A
                  Where a.记录性质 = 4 And a.记录状态 = 1 And a.结帐id = n_结帐id And Rownum < 2;
              End If;
            End If;
          End If;
        Else
          --a.允许的结算方式原样退
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
             结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_Date, 操作员编号_In, 操作员姓名_In, -冲预交,
                   n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
            From 病人预交记录
            Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_结帐id And Instr(',' || 非原样退结算_In || ',', ',' || 结算方式 || ',') = 0;
        
          --b.不允许的退现金
          Begin
            Select Sum(冲预交)
            Into n_退费金额
            From 病人预交记录
            Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_结帐id And Instr(',' || 非原样退结算_In || ',', ',' || 结算方式 || ',') > 0;
          Exception
            When Others Then
              n_退费金额 := 0;
          End;
          If n_退费金额 <> 0 Then
            If v_退指定结算方式 Is Null Then
              --退给现金
              Begin
                Select 结算方式
                Into v_退指定结算方式
                From 病人预交记录
                Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_结帐id And
                      Instr(',' || 非原样退结算_In || ',', ',' || 结算方式 || ',') = 0;
              
              Exception
                When Others Then
                  Begin
                    Select 名称 Into v_退指定结算方式 From 结算方式 Where 性质 = 1;
                  Exception
                    When Others Then
                      v_退指定结算方式 := '现金';
                  End;
              End;
            End If;
            Update 病人预交记录
            Set 冲预交 = 冲预交 + (-1 * n_退费金额)
            Where 记录性质 = 4 And 记录状态 = 2 And 结帐id = n_销帐id And 结算方式 = v_退指定结算方式;
            If Sql%RowCount = 0 Then
              Insert Into 病人预交记录
                (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
                 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
                Select 病人预交记录_Id.Nextval, a.No, a.实际票号, a.记录性质, 2, a.病人id, a.主页id, a.科室id, a.摘要, v_退指定结算方式, d_Date,
                       操作员编号_In, 操作员姓名_In, -1 * n_退费金额, n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
                From 病人预交记录 A
                Where a.记录性质 = 4 And a.记录状态 = 1 And a.结帐id = n_结帐id And Rownum < 2;
            End If;
          End If;
        End If;
      Else
        --退款金额获取
        If Nvl(退费类型_In, 0) <> 0 Or Nvl(n_二次退费, 0) <> 0 Then
          --如果是单独退病历费,或者只退挂号费,先获取退费金额
          Begin
            --获取本次退款金额
            Select Sum(Nvl(实收金额, 0)) As 收款金额
            Into n_退款金额
            From 门诊费用记录
            Where NO = 单据号_In And 记录性质 = 4 And 记录状态 = 3 And
                  Nvl(附加标志, 0) =
                  Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
          Exception
            When Others Then
              v_Err_Msg := '单据【' || 单据号_In || '】的' || Case Nvl(退费类型_In, 0)
                             When 1 Then
                              '挂号费用'
                             When 2 Then
                              '病历费'
                           End || '可能由于并发原因已经进行了退费或者单据不存在!';
              Raise Err_Item;
          End;
        End If;
        If Nvl(n_二次退费, 0) = 0 And Nvl(退费类型_In, 0) = 0 Then
          --首次全退
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
             结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_Date, 操作员编号_In, 操作员姓名_In,
                   -1 * 冲预交, n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
            From 病人预交记录
            Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_结帐id;
        Else
          --二次退费,或者本次单退一部分
          --二次退费时,记录状态=3 ,首次部分退,记录状态为1
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
             结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_Date, 操作员编号_In, 操作员姓名_In,
                   -1 * n_退款金额, n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
            From 病人预交记录
            Where 记录性质 = 4 And 记录状态 = Decode(Nvl(n_二次退费, 0), 0, 1, 3) And 结帐id = n_结帐id And 摘要 = '医保挂号' And
                  冲预交 = n_退款金额 And Rownum < 2;
          If Sql%RowCount = 0 Then
            Insert Into 病人预交记录
              (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
               结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
              Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_Date, 操作员编号_In, 操作员姓名_In,
                     -1 * n_退款金额, n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
              From 病人预交记录
              Where 记录性质 = 4 And 记录状态 = Decode(Nvl(n_二次退费, 0), 0, 1, 3) And 结帐id = n_结帐id And 冲预交 = n_退款金额 And
                    Rownum < 2;
          End If;
          If Sql%RowCount = 0 Then
            Insert Into 病人预交记录
              (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
               结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
              Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_Date, 操作员编号_In, 操作员姓名_In,
                     -1 * n_退款金额, n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
              From 病人预交记录
              Where 记录性质 = 4 And 记录状态 = Decode(Nvl(n_二次退费, 0), 0, 1, 3) And 结帐id = n_结帐id And Rownum < 2;
            If Sql%RowCount = 0 Then
              --部分退费,并且全部使用预交款缴费时才存在此种情况
              n_预交金额 := n_退款金额;
            End If;
          End If;
        
        End If;
      End If;
    Else
      --按结算方式退
      v_结算内容 := 结算方式_In || '|'; --以空格分开以|结尾,没有结算号码的
      While v_结算内容 Is Not Null Loop
        v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '|') - 1);
        v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1);
      
        v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
        n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1));
      
        v_当前结算   := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
        n_三方卡标志 := To_Number(v_当前结算);
      
        If n_三方卡标志 = 0 Then
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
             结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质, 结算号码)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, v_结算方式, d_Date, 操作员编号_In, 操作员姓名_In,
                   -1 * n_结算金额, n_销帐id, n_组id, 预交类别, Null, Null, Null, Null, Null, 合作单位, 4, 结算号码
            From 病人预交记录
            Where 记录性质 = 4 And 记录状态 = Decode(Nvl(n_二次退费, 0), 0, 1, 3) And 结帐id = n_结帐id And Rownum < 2;
        Else
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
             结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质, 结算号码)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, v_结算方式, d_Date, 操作员编号_In, 操作员姓名_In,
                   -1 * n_结算金额, n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4, 结算号码

            
            From 病人预交记录
            Where 记录性质 = 4 And 记录状态 = Decode(Nvl(n_二次退费, 0), 0, 1, 3) And 结帐id = n_结帐id And
                  (卡类别id Is Not Null Or 结算卡序号 Is Not Null) And Rownum < 2;
        End If;
        v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '|') + 1);
      End Loop;
      n_预交金额 := Nvl(退预交_In, 0);
    End If;
    --首次退费时,记录状态便调整为了3
    Update 病人预交记录
    Set 记录状态 = 3
    Where 记录性质 = 4 And 记录状态 = Decode(Nvl(n_二次退费, 0), 0, 1, 3) And 结帐id = n_结帐id;
  
    --冲预交 1-全退 2-部分退,部分退时当全部使用预交进行缴款
    If Nvl(退费类型_In, 0) = 0 Or (Nvl(退费类型_In, 0) <> 0 And n_预交金额 <> 0) Then
      --病人挂号结算:冲预交款部份
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, d_Date,
               操作员姓名_In, 操作员编号_In, -1 * Decode(Nvl(退费类型_In, 0) + Nvl(n_二次退费, 0), 0, 冲预交, n_预交金额), n_销帐id, n_组id, 预交类别,
               卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
        From 病人预交记录
        Where 记录性质 In (1, 11) And 结帐id = n_结帐id And Nvl(冲预交, 0) <> 0 And
              Rownum = Decode(Nvl(退费类型_In, 0) + Nvl(n_二次退费, 0), 0, Rownum, 1);
    End If;
  
    --处理病人预交余额
    For c_预交 In (Select 病人id, 预交类别, -1 * Sum(Nvl(冲预交, 0)) As 冲预交
                 From 病人预交记录
                 Where 记录性质 In (1, 11) And 结帐id = n_销帐id
                 Group By 病人id, 预交类别) Loop
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + Nvl(c_预交.冲预交, 0)
      Where 病人id = c_预交.病人id And 类型 = Nvl(c_预交.预交类别, 2) And 性质 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 预交余额, 性质, 类型)
        Values
          (c_预交.病人id, Nvl(c_预交.冲预交, 0), 1, Nvl(c_预交.预交类别, 2));
        n_返回值 := Nvl(c_预交.冲预交, 0);
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = c_预交.病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
      End If;
    End Loop;
  
    If 收回票据号_In Is Not Null Then
      --光退挂号费,不回收票据
      --退卡收回票据(可能上次挂号使用票据,不能收回)
      Begin
        --从最后一次打印的内容中取
        --81907
        Select ID
        Into n_打印id
        From (Select b.Id
               From 票据使用明细 A, 票据打印内容 B
               Where a.打印id = b.Id And a.性质 = 1 And a.原因 In (1, 3) And b.数据性质 = 4 And b.No = 单据号_In
               Order By a.使用时间 Desc)
        Where Rownum < 2;
      Exception
        When Others Then
          n_打印id := Null;
      End;
    
      --先收回原票据
      If n_打印id Is Not Null Then
        Begin
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
            From 票据使用明细
            Where 打印id = n_打印id And 性质 = 1 And Instr(',' || 收回票据号_In || ',', ',' || 号码 || ',') > 0;
        Exception
          When Others Then
            Delete From 票据使用明细 Where 打印id = n_打印id And 性质 = 2 And 原因 = 2;
            Insert Into 票据使用明细
              (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
              Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
              From 票据使用明细
              Where 打印id = n_打印id And 性质 = 1 And Instr(',' || 收回票据号_In || ',', ',' || 号码 || ',') > 0;
        End;
      End If;
    End If;
  End If;

  --单独退病历费用,不处理汇总记录
  --相关汇总表的处理

  --病人挂号汇总
  Open c_Registinfo(3);
  Fetch c_Registinfo
    Into r_Registrow;

  If c_Registinfo%RowCount = 0 Then
    --只收病历费时无号别,不处理
    Close c_Registinfo;
  Else
  
    --需要确定是否预约挂号
    --1.如果是退预约挂号产生的挂号记录,则需要减已挂数和其中已接数
    --2.如果是正常挂号,则只减已挂数
  
    Begin
      Select Decode(预约, Null, 0, 0, 0, 1) Into n_预约挂号 From 病人挂号记录 Where NO = 单据号_In And Rownum = 1;
    Exception
      When Others Then
        n_预约挂号 := 0;
    End;
    n_检查数 := Null;
    Update 临床出诊记录
    Set 已挂数 = Nvl(已挂数, 0) - 1, 其中已接收 = Nvl(其中已接收, 0) - n_预约挂号, 已约数 = Nvl(已约数, 0) - n_预约挂号
    Where ID = n_出诊记录id
    Returning 已挂数 Into n_检查数;
  
    If Nvl(n_检查数, 0) < 0 Then
      Update 临床出诊记录 Set 已挂数 = 0 Where ID = n_出诊记录id;
    End If;
  
    Update 病人挂号汇总
    Set 已挂数 = Nvl(已挂数, 0) - 1, 其中已接收 = Nvl(其中已接收, 0) - n_预约挂号, 已约数 = Nvl(已约数, 0) - n_预约挂号
    Where 日期 = Trunc(r_Registrow.发生时间) And Nvl(医生id, 0) = Nvl(r_Registrow.医生id, 0) And
          Nvl(医生姓名, '-') = Nvl(r_Registrow.医生姓名, '-') And 科室id = r_Registrow.科室id And 项目id = r_Registrow.项目id And
          (号码 = r_Registrow.号码 Or 号码 Is Null);
  
    If Sql%RowCount = 0 Then
      Insert Into 病人挂号汇总
        (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 其中已接收, 已约数)
      Values
        (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
         Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, -1, -1 * n_预约挂号, -1 * n_预约挂号);
    End If;
  
    Close c_Registinfo;
  End If;

  If n_记帐 = 0 Then
    --人员缴款余额(包括个人帐户等的结算金额,不含退冲预交款)
    For r_Opermoney In c_Opermoney(n_销帐id) Loop
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + (-1 * r_Opermoney.冲预交)
      Where 收款员 = 操作员姓名_In And 结算方式 = r_Opermoney.结算方式 And 性质 = 1
      Returning 余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (操作员姓名_In, r_Opermoney.结算方式, 1, -1 * r_Opermoney.冲预交);
        n_返回值 := r_Opermoney.冲预交;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = 操作员姓名_In And 结算方式 = r_Opermoney.结算方式 And 性质 = 1 And Nvl(余额, 0) = 0;
      End If;
    End Loop;
  End If;
  If Nvl(退费类型_In, 0) Not In (2, 3) Then
    n_挂号生成队列 := Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113));
    If n_挂号生成队列 <> 0 Then
      n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
      If Nvl(n_分诊台签到排队, 0) = 0 Then
      
        --要删除队列
        For v_挂号 In (Select ID, 诊室, 执行部门id, 执行人 From 病人挂号记录 Where NO = 单据号_In) Loop
          Zl_排队叫号队列_Delete(v_挂号.执行部门id, v_挂号.Id);
        End Loop;
      End If;
    End If;
  
    --医保产生的就诊登记记录
    Begin
      Select 病人id, 发生时间 Into n_就诊病人id, d_就诊时间 From 病人挂号记录 Where NO = 单据号_In;
      Delete From 就诊登记记录 Where 病人id = n_就诊病人id And 就诊时间 = d_就诊时间 And 主页id Is Null;
    Exception
      When Others Then
        Null;
    End;
  
    --病人挂号记录
    Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
  
    Update 病人挂号记录 Set 记录状态 = 3 Where NO = 单据号_In And 记录性质 = 1 And 记录状态 = 1;
    If Sql%NotFound Then
      v_Err_Msg := '挂号单【' || 单据号_In || '】不存在或由于并发原因已经被退号';
      Raise Err_Item;
    End If;
    Insert Into 病人挂号记录
      (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 操作员编号, 操作员姓名,
       复诊, 号序, 社区, 预约, 摘要, 预约方式, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 险类, 医疗付款方式, 出诊记录id)
      Select n_挂号id, NO, 记录性质, 2, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, d_Date, 发生时间,
             操作员编号_In, 操作员姓名_In, 复诊, 号序, 社区, 预约, Nvl(摘要_In, 摘要) As 摘要, 预约方式, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 险类, 医疗付款方式,
             n_出诊记录id
      From 病人挂号记录
      Where NO = 单据号_In;
  End If;
  --消息推送
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 2, 单据号_In;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人挂号记录_出诊_Delete;
/



Create Or Replace Procedure Zl_Third_Getregfeedetail
(
  Xml_In  In Xmltype,
  Xml_Out In Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取挂号费用明细
  --入参:Xml_In:
  --<IN>
  --  <BRID></BRID> //病人ID
  --  <SFYY></SFYY> //是否仅预约不支付,1-仅预约不支付,0-挂号,预约支付,预约接收，默认为0
  --  <GHDH></GHDH> //挂号单号,预约接收时传入
  --  <GHHM></GHHM> //挂号安排号码,挂号和预约时传入
  --  <XMID></XMID> //挂号安排的项目ID,挂号和预约时传入
  --  <FB></FB>     //病人费别
  --  <ZD></ZD>     //站点
  --</IN>
  --出参:Xml_Out
  -- <OUTPUT>
  --  <ZJE></ZJE>   //总实收金额
  --  <XMMX>        //项目明细
  --    <XM>
  --      <DJH></DJH>       //单据号
  --      <MC></MC>   //项目名称
  --      <ID></ID>   //项目ID
  --      <SL></SL>   //数量，数次*付数
  --      <YSJE></YSJE>   //应收金额
  --      <SSJE></SSJE>   //实收金额
  --      <SJFM></SJFM>       //收据费目
  --    </XM>
  --    <XM>
  --    ...
  --    </XM>
  --  </XMMX>
  -- </OUTPUT>

  --------------------------------------------------------------------------------------------------
  x_Templet    Xmltype; --模板XML
  v_Err_Msg    Varchar2(200);
  v_Temp       Varchar2(4000);
  n_项目id     挂号安排.项目id%Type;
  v_No         门诊费用记录.No%Type;
  n_预约       Number(3);
  n_病人id     病人信息.病人id%Type;
  v_费别       病人信息.费别%Type;
  v_站点       部门表.站点%Type;
  v_号码       挂号安排.号码%Type;
  n_总金额     门诊费用记录.实收金额%Type;
  n_实收金额   门诊费用记录.实收金额%Type;
  v_实收       Varchar(500);
  v_附加项目id Varchar2(500);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');
  Select Extractvalue(Value(A), 'IN/BRID'), Extractvalue(Value(A), 'IN/XMID'), Extractvalue(Value(A), 'IN/GHHM'),
         Extractvalue(Value(A), 'IN/FB'), Extractvalue(Value(A), 'IN/ZD'), Extractvalue(Value(A), 'IN/SFYY'),
         Extractvalue(Value(A), 'IN/GHDH')
  Into n_病人id, n_项目id, v_号码, v_费别, v_站点, n_预约, v_No
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  n_总金额 := 0;
  If v_No Is Null Then
    --挂号或者预约
    For c_挂号项目 In (Select 1 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, -1 As 执行科室类型
                   From 收费项目目录 A, 收费价目 B, 收入项目 C
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = n_项目id And Sysdate Between b.执行日期 And
                         Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                   Union All
                   Select 2 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, d.从项数次 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, -1 As 执行科室类型
                   From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费从属项目 D
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = d.从项id And d.主项id = n_项目id And
                         Sysdate Between b.执行日期 And Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))) Loop
      v_实收     := Zl_Actualmoney(v_费别, c_挂号项目.项目id, c_挂号项目.收入项目id, c_挂号项目.数次 * c_挂号项目.单价);
      n_实收金额 := To_Number(Substr(v_实收, Instr(v_实收, ':') + 1));
      n_总金额   := n_总金额 + Nvl(n_实收金额, 0);
      v_Temp     := v_Temp || '<XM><DJH></DJH><MC>' || c_挂号项目.项目名称 || '</MC>' || '<ID>' || c_挂号项目.项目id || '</ID>' ||
                    '<SL>' || c_挂号项目.数次 || '</SL>' || '<YSJE>' || c_挂号项目.数次 * c_挂号项目.单价 || '</YSJE>' || '<SSJE>' ||
                    n_实收金额 || '</SSJE>' || '<SJFM>' || c_挂号项目.收据费目 || '</SJFM></XM>';
    End Loop;
  Else
    --预约接收
    For c_挂号项目 In (Select a.收费细目id As 项目id, a.应收金额, a.实收金额, a.计算单位, a.收据费目, b.名称 As 项目名称, a.No, Nvl(a.付数, 1) As 付数, a.数次
                   From 门诊费用记录 A, 收费项目目录 B
                   Where a.收费细目id = b.Id And a.No = v_No And a.记录性质 = 4 And a.记录状态 = 0) Loop
      n_总金额 := n_总金额 + Nvl(c_挂号项目.实收金额, 0);
      v_号码   := c_挂号项目.计算单位;
      v_Temp   := v_Temp || '<XM><DJH>' || c_挂号项目.No || '</DJH><MC>' || c_挂号项目.项目名称 || '</MC>' || '<ID>' || c_挂号项目.项目id ||
                  '</ID>' || '<SL>' || c_挂号项目.付数 * c_挂号项目.数次 || '</SL>' || '<YSJE>' || c_挂号项目.应收金额 || '</YSJE>' ||
                  '<SSJE>' || c_挂号项目.实收金额 || '</SSJE>' || '<SJFM>' || c_挂号项目.收据费目 || '</SJFM></XM>';
    End Loop;
  End If;

  If Nvl(n_预约, 0) = 0 Then
    Begin
      Select Zl_Fun_Customregexpenses(n_病人id, 0, v_号码) Into v_附加项目id From Dual;
    Exception
      When Others Then
        v_附加项目id := Null;
    End;
    If v_附加项目id Is Not Null Then
      For c_附加项目 In (Select /*+cardinality(D,10)*/
                      5 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次, c.Id As 收入项目id,
                      c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, -1 As 执行科室类型
                     From 收费项目目录 A, 收费价目 B, 收入项目 C, Table(f_Str2list(v_附加项目id)) D
                     Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = d.Column_Value And Sysdate Between b.执行日期 And
                           Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                     Union All
                     Select /*+cardinality(E,10)*/
                      5 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, d.从项数次 As 数次,
                      c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, -1 As 执行科室类型
                     From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费从属项目 D, Table(f_Str2list(v_附加项目id)) E
                     Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = d.从项id And d.主项id = e.Column_Value And
                           Sysdate Between b.执行日期 And Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))) Loop
        v_实收     := Zl_Actualmoney(v_费别, c_附加项目.项目id, c_附加项目.收入项目id, c_附加项目.数次 * c_附加项目.单价);
        n_实收金额 := To_Number(Substr(v_实收, Instr(v_实收, ':') + 1));
        n_总金额   := n_总金额 + Nvl(n_实收金额, 0);
        v_Temp     := v_Temp || '<XM><DJH></DJH><MC>' || c_附加项目.项目名称 || '</MC>' || '<ID>' || c_附加项目.项目id || '</ID>' ||
                      '<SL>' || c_附加项目.数次 || '</SL>' || '<YSJE>' || c_附加项目.数次 * c_附加项目.单价 || '</YSJE>' || '<SSJE>' ||
                      n_实收金额 || '</SSJE>' || '<SJFM>' || c_附加项目.收据费目 || '</SJFM></XM>';
      End Loop;
    End If;
  End If;

  v_Temp := '<XMMX>' || v_Temp || '</XMMX>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;

  v_Temp := '<ZJE>' || n_总金额 || '</ZJE>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;

  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getregfeedetail;
/

--103664:廖思奇,2017-02-06,修正回退处理逻辑
Create Or Replace Procedure Zl_影像报告回退
(
  签名id_In     In 电子病历内容.Id%Type,
  报告文件id_In In 电子病历内容.文件id%Type,
  版本号_In     In 电子病历内容.开始版%Type
) Is
  v_签名数   Number;
  v_签名级别 电子病历内容.要素表示%Type;
  v_Temp     Varchar2(255);
  v_保存人   电子病历记录.保存人%Type;
Begin
  v_Temp   := Zl_Identity;
  v_Temp   := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp   := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_保存人 := Substr(v_Temp, Instr(v_Temp, ',') + 1);

  If 签名id_In > 0 Then
    Select Count(*) Into v_签名数 From 电子病历内容 Where 文件id = 报告文件id_In And 对象类型 = 8;
    If v_签名数 = 1 Then
      Update 电子病历记录
      Set 完成时间 = Null, 签名级别 = 0, 保存人 = v_保存人, 保存时间 = Sysdate
      Where ID = 报告文件id_In;
    Else
      Begin
        Select 要素表示
        Into v_签名级别
        From 电子病历内容
        Where 文件id = 报告文件id_In And 对象类型 = 8 And 对象标记 = (Select 对象标记 From 电子病历内容 Where ID = 签名id_In) - 1;
      Exception
        When No_Data_Found Then
          v_签名级别 := 0;
      End;
      Update 电子病历记录 Set 签名级别 = v_签名级别, 保存人 = v_保存人, 保存时间 = Sysdate Where ID = 报告文件id_In;
    End If;
  
    Delete From 电子病历内容 Where ID = 签名id_In;
  Elsif 版本号_In > 1 Then
    Delete From 电子病历内容 Where 文件id = 报告文件id_In And 开始版 = 版本号_In;
    Update 电子病历内容 Set 终止版 = 0 Where 文件id = 报告文件id_In And 终止版 = 版本号_In - 1;
    Update 电子病历记录
    Set 最后版本 = 版本号_In - 1,
        签名级别 =
         (Select Max(b.要素表示) From 电子病历内容 B Where b.文件id = 报告文件id_In And b.开始版 = 版本号_In - 1), 保存人 = v_保存人, 保存时间 = Sysdate
    Where ID = 报告文件id_In;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_影像报告回退;
/

--100837:刘尔旋,2017-2-6,挂号附加费处理
Create Or Replace Function Zl_Fun_Regcustomname Return Varchar2
  --    功能：挂号附加费名称用户自定义函数
  --    返回: 格式:功能名称|收费细目ID1,收费细目ID2...返回NULL不加载菜单
 Is
Begin
  Return Null;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Fun_Regcustomname;
/

--100837:刘尔旋,2017-2-6,挂号附加费处理
Create Or Replace Function Zl_Fun_Customregexpenses
(
  病人id_In In 病人信息.病人id%Type,
  险类_In   In 病人信息.险类%Type,
  号码_In   In 挂号安排.号码%Type
) Return Varchar2
  --    功能：挂号附加费处理项目用户自定义函数
  --    参数：
  --        病人ID_In：病人信息.病人ID
  --        险类_In：病人信息.险类
  --        号码_In: 挂号安排.号码
  --    返回: 收费细目ID,多个用逗号分隔,返回NULL时，不处理
 Is
Begin
  Return Null;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Fun_Customregexpenses;
/

--103742:廖思奇,2017-02-06,排队叫号语音内容多音字替换
Create Or Replace Procedure Zl_排队语音呼叫_Insert
(
  队列id_In   排队叫号队列.Id%Type,
  站点_In     排队语音呼叫.站点%Type,
  呼叫方式_In Number
) Is
  --呼叫方式_IN: 0-呼叫(就诊)，1-呼叫(候诊) 
  Cursor c_Queue Is
    Select a.队列名称, a.科室id, a.业务id, a.排队号码, a.排队标记, a.患者姓名, a.诊室, a.医生姓名, a.优先, a.排队时间, a.排队状态, b.名称 As 科室
    From 排队叫号队列 A, 部门表 B
    Where a.科室id = b.Id And a.Id = 队列id_In;

  r_Queue       c_Queue%RowType;
  V语音id       排队语音呼叫.Id%Type;
  V呼叫内容     排队语音呼叫.呼叫内容%Type;
  V呼叫患者姓名 排队叫号队列.患者姓名%Type;
Begin

  For r_Queue In c_Queue Loop
    --组织呼叫内容 
    V呼叫患者姓名 := Zl_排队语音呼叫_多音字处理(r_Queue.患者姓名);
    If 呼叫方式_In = 0 Then
      If r_Queue.排队号码 Is Null Then
        V呼叫内容 := '  请、' || V呼叫患者姓名 || '、  ' || V呼叫患者姓名 || '  、到' || Nvl(r_Queue.诊室, r_Queue.科室) || '就诊';
      Else
        V呼叫内容 := '  请、' || r_Queue.排队号码 || '号、  ' || V呼叫患者姓名 || '、  ' || V呼叫患者姓名 || '  、到' ||
                 Nvl(r_Queue.诊室, r_Queue.科室) || '就诊';
      End If;
    Elsif 呼叫方式_In = 1 Then
      If r_Queue.排队号码 Is Null Then
        V呼叫内容 := '  请、' || V呼叫患者姓名 || '、  ' || V呼叫患者姓名 || '  、到' || Nvl(r_Queue.诊室, r_Queue.科室) || '候诊';
      Else
        V呼叫内容 := '  请、' || r_Queue.排队号码 || '号、  ' || V呼叫患者姓名 || '、  ' || V呼叫患者姓名 || '  、到' ||
                 Nvl(r_Queue.诊室, r_Queue.科室) || '候诊';
      End If;
    End If;
  
    --写入数据库表 
    Select 排队语音呼叫_Id.Nextval Into V语音id From Dual;
    Insert Into 排队语音呼叫
      (ID, 队列id, 呼叫内容, 队列名称, 站点)
      Select V语音id, 队列id_In, V呼叫内容, r_Queue.队列名称, 站点_In
      From Dual
      Where Not Exists (Select 1 From 排队语音呼叫 Where 队列id = 队列id_In And Upper(站点) = Upper(站点_In));
  
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_排队语音呼叫_Insert;
/

--103742:廖思奇,2017-02-06,排队叫号语音内容多音字替换
Create Or Replace Function Zl_排队叫号队列_获取呼叫内容
(
  队列id_In   In 排队叫号队列.Id%Type,
  呼叫方式_In In Number
  --功能：获取语音播放时的播放内容 
  --参数： 
  --    呼叫方式_In:0-顺乎，1-直呼,2-广播,3-候诊呼叫 
) Return Varchar2 Is
  v_姓名     排队叫号队列.患者姓名%Type;
  v_诊室     排队叫号队列.诊室%Type;
  v_呼叫内容 Varchar2(1000);
Begin
  Select Zl_排队语音呼叫_多音字处理(a.患者姓名), a.诊室 Into v_姓名, v_诊室 From 排队叫号队列 A Where a.Id = 队列id_In;

  If 呼叫方式_In <> 3 Then
    v_呼叫内容 := '  请、' || v_姓名 || '、  ' || v_姓名 || '  、到' || v_诊室 || '就诊';
  Else
    v_呼叫内容 := '  请、' || v_姓名 || '、  ' || v_姓名 || '  、到' || v_诊室 || '侯诊';
  End If;

  Return v_呼叫内容;
Exception
  When Others Then
    Return Null;
End Zl_排队叫号队列_获取呼叫内容;
/

--103742:廖思奇,2017-02-10,排队叫号语音内容多音字替换
Create Or Replace Function Zl_排队语音呼叫_多音字处理
(
  原名字_In In 排队叫号队列.患者姓名%Type
) Return Varchar2 As
  v_新名字 排队叫号队列.患者姓名%Type;

Begin

  v_新名字 := Replace(原名字_In, '覃', '秦');
  v_新名字 := Replace(v_新名字, '单', '善');
  v_新名字 := Replace(v_新名字, '曾', '增');
  v_新名字 := Replace(v_新名字, '雨', '宇');

  Return v_新名字;
Exception
  When Others Then
    Return 原名字_In ;
End Zl_排队语音呼叫_多音字处理;
/

--105391:刘尔旋,2017-02-06,过程空值判断问题
--103110:刘尔旋,2017-01-26,病人信息新增手机号
Create Or Replace Procedure Zl_挂号病人病案_Insert
(
  处理类型_In       Number,
  病人id_In         病人信息.病人id%Type,
  门诊号_In         病人信息.门诊号%Type,
  就诊卡号_In       病人信息.就诊卡号%Type,
  卡验证码_In       病人信息.卡验证码%Type,
  姓名_In           病人信息.姓名%Type,
  性别_In           病人信息.性别%Type,
  年龄_In           病人信息.年龄%Type,
  费别_In           病人信息.费别%Type,
  医疗付款方式_In   病人信息.医疗付款方式%Type,
  国籍_In           病人信息.国籍%Type,
  民族_In           病人信息.民族%Type,
  婚姻_In           病人信息.婚姻状况%Type,
  职业_In           病人信息.职业%Type,
  身份证号_In       病人信息.身份证号%Type,
  工作单位_In       病人信息.工作单位%Type,
  合同单位id_In     病人信息.合同单位id%Type,
  单位电话_In       病人信息.单位电话%Type,
  单位邮编_In       病人信息.单位邮编%Type,
  家庭地址_In       病人信息.家庭地址%Type,
  家庭电话_In       病人信息.家庭电话%Type,
  家庭地址邮编_In   病人信息.家庭地址邮编%Type,
  登记时间_In       病人信息.登记时间%Type,
  挂号单_In         病人挂号记录.No%Type := Null,
  出生日期_In       病人信息.出生日期%Type := Null,
  医保号_In         病人信息.医保号%Type := Null,
  Ic卡号_In         病人信息.Ic卡号%Type := Null,
  险类_In           病人信息.险类%Type := Null,
  区域_In           病人信息.区域%Type := Null,
  户口地址_In       病人信息.户口地址%Type := Null,
  户口地址邮编_In   病人信息.户口地址邮编%Type := Null,
  联系人身份证号_In In 病人信息.联系人身份证号%Type := Null,
  联系人姓名_In     In 病人信息.联系人姓名%Type := Null,
  联系人电话_In     In 病人信息.联系人电话%Type := Null,
  联系人关系_In     In 病人信息.联系人关系%Type := Null,
  监护人_In         In 病人信息.监护人%Type := Null,
  出生地点_In       In 病人信息.出生地点%Type := Null,
  手机号_In         In 病人信息.手机号%Type := Null
) As
  --功能：处理挂号病人病案信息
  --参数：
  --处理类型：
  --             1=新建病人信息及门诊病案(用于新挂号病人)
  --             2=修改病人信息，新建门诊病案(用于无病案的病人)
  --             3=修改病人信息，不处理门诊病案(用于有病案的病人,但可能修改了病案的门诊号)
  v_年龄         Varchar2(20);
  v_年龄单位     Varchar2(20);
  v_出生日期     Date;
  n_一卡通       Number(1);
  v_Username     人员表.姓名%Type;
  v_姓名信息     病人信息.姓名%Type;
  v_年龄信息     病人信息.年龄%Type;
  v_性别信息     病人信息.性别%Type;
  v_身份证号     病人信息.身份证号%Type;
  d_出生日期信息 Date;
  d_变动时间     Date;
Begin
  If 出生日期_In Is Null And 年龄_In Is Not Null Then
    --根据年龄求出生日期
    v_年龄单位 := Substr(年龄_In, Length(年龄_In), 1);
    If Instr('岁,月,天', v_年龄单位) <= 0 Then
      v_年龄单位 := Null;
    Else
      v_年龄 := Replace(年龄_In, v_年龄单位, '');
    End If;
    Begin
      v_年龄 := To_Number(v_年龄);
    Exception
      When Others Then
        v_年龄 := Null;
    End;
    If v_年龄 Is Not Null And v_年龄单位 Is Not Null Then
      Select Decode(v_年龄单位, '岁', Add_Months(Sysdate, -12 * v_年龄), '月', Add_Months(Sysdate, -1 * v_年龄), '天',
                     Sysdate - v_年龄)
      Into v_出生日期
      From Dual;
    End If;
  Else
    v_出生日期 := 出生日期_In;
  End If;

  Begin
    Select 姓名, 性别, 年龄, 出生日期, 身份证号
    Into v_姓名信息, v_性别信息, v_年龄信息, d_出生日期信息, v_身份证号
    From 病人信息
    Where 病人id = 病人id_In;
    v_年龄信息 := Zl_Age_Calc(病人id_In, d_出生日期信息);
  Exception
    When Others Then
      v_姓名信息     := 姓名_In;
      v_性别信息     := 性别_In;
      v_年龄信息     := 年龄_In;
      d_出生日期信息 := v_出生日期;
      v_身份证号     := 身份证号_In;
  End;

  Begin
    Select 1 Into n_一卡通 From 一卡通目录 Where 启用 = 2 And Rownum <= 1;
  Exception
    When Others Then
      n_一卡通 := 0;
  End;

  If Not 就诊卡号_In Is Null And n_一卡通 = 0 Then
    Update 病人信息
    Set 就诊卡号 = Null, Ic卡号 = Decode(Ic卡号, 就诊卡号, Null, Ic卡号)
    Where 病人id <> 病人id_In And 就诊卡号 = 就诊卡号_In;
  End If;

  If 处理类型_In = 1 Then
    --新病人信息
    Insert Into 病人信息
      (病人id, 门诊号, 就诊卡号, 卡验证码, Ic卡号, 姓名, 性别, 年龄, 出生日期, 费别, 医疗付款方式, 国籍, 民族, 婚姻状况, 职业, 身份证号, 工作单位, 合同单位id, 单位电话, 单位邮编,
       家庭地址, 家庭电话, 家庭地址邮编, 户口地址, 户口地址邮编, 登记时间, 医保号, 区域, 联系人身份证号, 联系人姓名, 联系人电话, 联系人关系, 监护人, 出生地点, 手机号)
    Values
      (病人id_In, 门诊号_In, 就诊卡号_In, 卡验证码_In, Ic卡号_In, 姓名_In, 性别_In, 年龄_In, v_出生日期, 费别_In, 医疗付款方式_In, 国籍_In, 民族_In, 婚姻_In,
       职业_In, 身份证号_In, 工作单位_In, Decode(合同单位id_In, 0, Null, 合同单位id_In), 单位电话_In, 单位邮编_In, 家庭地址_In, 家庭电话_In, 家庭地址邮编_In,
       户口地址_In, 户口地址邮编_In, 登记时间_In, 医保号_In, 区域_In, 联系人身份证号_In, 联系人姓名_In, 联系人电话_In, 联系人关系_In, 监护人_In, 出生地点_In, 手机号_In);
  Elsif 处理类型_In In (2, 3) Then
    --宁波一卡通,档案号以IC卡号传入,此时不更新就诊卡号
    Update 病人信息
    Set 门诊号 = 门诊号_In, 就诊卡号 = Decode(n_一卡通, 1, Decode(Ic卡号_In, Null, Nvl(就诊卡号_In, 就诊卡号), 就诊卡号), Nvl(就诊卡号_In, 就诊卡号)),
        Ic卡号 = Decode(n_一卡通, 1, Decode(Ic卡号_In, Null, Ic卡号, Nvl(Ic卡号_In, Ic卡号)), Nvl(Ic卡号_In, Ic卡号)),
        卡验证码 = Decode(n_一卡通, 1, Decode(Ic卡号_In, Null, Nvl(卡验证码_In, 卡验证码), 卡验证码),
                       Decode(就诊卡号_In, Null, 卡验证码, Nvl(卡验证码_In, 卡验证码))), 姓名 = 姓名_In, 性别 = Nvl(性别_In, 性别), 年龄 = 年龄_In,
        出生日期 = v_出生日期, 费别 = Nvl(费别_In, 费别), 医疗付款方式 = Nvl(医疗付款方式_In, 医疗付款方式), 国籍 = Nvl(国籍_In, 国籍), 民族 = Nvl(民族_In, 民族),
        婚姻状况 = Nvl(婚姻_In, 婚姻状况), 职业 = Nvl(职业_In, 职业), 身份证号 = 身份证号_In, 工作单位 = 工作单位_In,
        合同单位id = Decode(合同单位id_In, 0, Null, 合同单位id_In), 单位电话 = 单位电话_In, 单位邮编 = 单位邮编_In, 家庭地址 = 家庭地址_In, 家庭电话 = 家庭电话_In,
        户口地址 = Nvl(户口地址_In, 户口地址), 户口地址邮编 = Nvl(户口地址邮编_In, 户口地址邮编), 家庭地址邮编 = 家庭地址邮编_In, 医保号 = 医保号_In, 险类 = 险类_In,
        区域 = Nvl(区域_In, 区域), 联系人身份证号 = 联系人身份证号_In, 联系人姓名 = 联系人姓名_In, 联系人电话 = 联系人电话_In, 联系人关系 = 联系人关系_In, 监护人 = 监护人_In,
        出生地点 = 出生地点_In, 手机号 = Nvl(手机号_In, 手机号)
    Where 病人id = 病人id_In;
  
    v_Username := Zl_Username;
    d_变动时间 := Sysdate;
    If Nvl(病人id_In, 0) > 0 Then
      If Nvl(姓名_In, '__') <> Nvl(v_姓名信息, '__') Then
        Insert Into 病人信息变动
          (病人id, 变动项目, 原信息, 新信息, 变动时间, 变动人, 变动模块, 说明)
        Values
          (病人id_In, '姓名', v_姓名信息, 姓名_In, d_变动时间, v_Username, '挂号', '病人基本信息调整');
      End If;
      If Nvl(身份证号_In, '__') <> Nvl(v_身份证号, '__') Then
        Insert Into 病人信息变动
          (病人id, 变动项目, 原信息, 新信息, 变动时间, 变动人, 变动模块, 说明)
        Values
          (病人id_In, '身份证号', v_身份证号, 身份证号_In, d_变动时间, v_Username, '挂号', '病人基本信息调整');
      End If;
      If Nvl(性别_In, '__') <> Nvl(v_性别信息, '__') Then
        Insert Into 病人信息变动
          (病人id, 变动项目, 原信息, 新信息, 变动时间, 变动人, 变动模块, 说明)
        Values
          (病人id_In, '性别', v_性别信息, 性别_In, d_变动时间, v_Username, '挂号', '病人基本信息调整');
      End If;
      If Nvl(年龄_In, '__') <> Nvl(v_年龄信息, '__') Then
        Insert Into 病人信息变动
          (病人id, 变动项目, 原信息, 新信息, 变动时间, 变动人, 变动模块, 说明)
        Values
          (病人id_In, '年龄', v_年龄信息, 年龄_In, d_变动时间, v_Username, '挂号', '病人基本信息调整');
      End If;
      If Nvl(v_出生日期, Sysdate) <> Nvl(d_出生日期信息, Sysdate) Then
        Insert Into 病人信息变动
          (病人id, 变动项目, 原信息, 新信息, 变动时间, 变动人, 变动模块, 说明)
        Values
          (病人id_In, '出生日期', To_Char(d_出生日期信息, 'YYYY-MM-DD hh24:mi'), To_Char(v_出生日期, 'YYYY-MM-DD hh24:mi'), d_变动时间,
           v_Username, '挂号', '病人基本信息调整');
      End If;
    End If;
  
    --北京医保:问题:26982
    If Nvl(险类_In, 0) = 920 And Not 医保号_In Is Null Then
      --需要反更新
      Update 医保病人档案 B
      Set 医保号 = 医保号_In
      Where (险类, 中心, 医保号) = (Select 险类, 中心, 医保号
                             From 医保病人关联表 A
                             Where 险类 = 险类_In And a.病人id = 病人id_In And a.医保号 <> 医保号_In And Rownum = 1);
      Update 医保病人关联表 Set 医保号 = 医保号_In Where 病人id = 病人id_In And 医保号 <> 医保号_In And 险类 = 险类_In;
    End If;
  
    If 挂号单_In Is Not Null Then
    
      Update 病人挂号记录
      Set 门诊号 = 门诊号_In, 姓名 = 姓名_In, 性别 = Nvl(性别_In, 性别), 年龄 = Nvl(年龄_In, 年龄)
      Where NO = 挂号单_In;
    
      Update 门诊费用记录
      Set 标识号 = 门诊号_In, 姓名 = 姓名_In, 性别 = Nvl(性别_In, 性别), 年龄 = Nvl(年龄_In, 年龄)
      Where NO = 挂号单_In And 记录性质 = 4;
    End If;
  End If;

  --门诊病案
  If 门诊号_In Is Not Null Then
    If 处理类型_In In (1, 2) Then
      Update 门诊病案记录 Set 病案号 = 门诊号_In Where 病人id = 病人id_In;
      If Sql%RowCount = 0 Then
        Insert Into 门诊病案记录
          (病人id, 病案号, 建立日期, 病案类别, 存储状态, 存放位置)
        Values
          (病人id_In, 门诊号_In, 登记时间_In, '一般', Null, Null);
      End If;
    Elsif 处理类型_In = 3 Then
      Update 门诊病案记录 Set 病案号 = 门诊号_In Where 病人id = 病人id_In;
    End If;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_挂号病人病案_Insert;
/

--106288:张德婷,2017-02-22,修正自动排批对已摆药数据的影响
--102386:张德婷,2017-02-21,自动排批或继承批次时取消该病人当天输液单的确认调整标志
--104668:张德婷,2017-01-25,静配中心自动排批与保持上一天批次整合
CREATE OR REPLACE Procedure Zl_输液配药记录_自动排批
(
 病人id_In In number,
 科室id_In In number,
 部门id_In In number,
 执行日期_In in date
) Is
v_批次串 varchar2(500);
n_总量 number(5);
v_配药id  varchar2(500);
v_batch varchar2(20);
v_Fields varchar2(100);
v_Tansid varchar(18);
n_科室id number(18);
v_批次   varchar2(10);
v_Id     varchar2(200);
n_自动排批模式  number(1);
n_打包    number(2);
v_配药类型  Varchar2(20);
v_历史批次  Varchar2(20);
Begin
  n_自动排批模式:=Zl_To_Number(Nvl(zl_GetSysParameter('自动排批时输液单的批次只往后面批次变动', 1345), 0));
  --该科室各个批次对应的容量
  select max(批次) into v_批次 from 配药工作批次 where 配置中心id=部门id_In and 药品类型 is  null;
  for R_Batch in (select B.批次 配药批次,A.容量,A.科室id from 科室容量设置 A,配药工作批次 B where A.配置中心ID=B.配置中心ID And A.配药批次=(B.批次 || '#') and (A.科室id=科室id_In or A.科室ID=0) and A.配置中心id=部门id_In order by A.科室id desc, A.配药批次 asc) loop

    n_科室id:=R_Batch.科室id;

  --该病人按批次排序，执行时间，优先级排序,各个批次现有的容量，优先级在产生输液配药记录的时候写入
    n_总量:=0;
    for r_item in (Select a.Id 配药id, d.单量,A.瓶签号,A.配药批次
    From 输液配药记录 A, 病人医嘱记录 B, 输液配药内容 C, 药品收发记录 D, 药品规格 E, 药品特性 F,配药工作批次 G
    Where a.Id = c.记录id And c.收发id = d.Id And d.药品id = e.药品id And e.药名id = f.药名id And a.部门id = 部门id_In and G.配置中心ID=a.部门id And
          a.医嘱id = b.Id And b.病人id = 病人id_In And A.配药批次=G.批次 And G.批次<>0 and G.药品类型 is null And f.溶媒 = 1 And a.执行时间 Between Trunc(执行日期_In ) And
          Trunc(执行日期_In+1) - 1 / 24 / 60 / 60 And A.操作状态<2 and A.配药批次<=decode(n_自动排批模式,1,R_Batch.配药批次,100)
    Order By a.优先级,a.配药批次, a.执行时间, d.单量 desc) loop

      if instr(','|| v_配药id,','|| r_item.配药id || ',',1)<1 then
        --当该配药id首次循环的时候对其单量进行累计
        v_配药id:=v_配药id || r_item.配药id || ',';
        n_总量:=n_总量+r_item.单量;
        v_批次串:=v_批次串 || r_item.配药id || ',' || R_Batch.配药批次 || '|';
      elsif instr('|'|| v_批次串,'|'|| r_item.配药id || ',' || R_Batch.配药批次 || '|',1)>0 and n_总量<>0 then
        --当该配药id及批次出现过，则累计该单量
        n_总量:=n_总量+r_item.单量;
      end if;

      if n_总量>=R_Batch.容量 then
        exit;
      end if;

    end loop;
  end loop;

  --如果该科室设置了单独的容量信息则不考虑所有科室的模式
  for r_item in (Select a.Id 配药id, d.单量,A.瓶签号
  From 输液配药记录 A, 病人医嘱记录 B, 输液配药内容 C, 药品收发记录 D, 药品规格 E, 药品特性 F,配药工作批次 G
  Where a.Id = c.记录id And c.收发id = d.Id And d.药品id = e.药品id And e.药名id = f.药名id And a.部门id = 部门id_In  And
        a.医嘱id = b.Id And b.病人id = 病人id_In And A.配药批次=G.批次 And G.批次<>0 and G.配置中心ID=a.部门id and G.药品类型 is null And f.溶媒 = 1  
        And A.操作状态<2 And a.执行时间 Between Trunc(执行日期_In) And Trunc(执行日期_In+1) - 1 / 24 / 60 / 60
  Order By a.配药批次,a.优先级,a.执行时间, d.单量) loop
    if instr(','|| v_配药id,','|| r_item.配药id || ',',1)<1then
      --没有进行自动分批的输液单直接在最后一个批次
      v_配药id:=v_配药id || r_item.配药id || ',';
      v_批次串:=v_批次串 || r_item.配药id || ',' || v_批次 || '|';
    end if;
  end loop;


  --根据自动调批修正数据
  while v_批次串 is not null loop
    --分解单据ID串
    v_Fields := Substr(v_批次串, 1, Instr(v_批次串, '|') - 1);
    v_Tansid := Substr(v_Fields, 1, Instr(v_Fields, ',') - 1);
    v_batch   := Substr(v_Fields, Instr(v_Fields, ',') + 1);


    v_批次串 := Replace('|' || v_批次串, '|' || v_Fields || '|');

    Select Nvl(max(打包), 0),max(药品类型) Into n_打包,v_配药类型 From 配药工作批次 Where 批次 = v_batch And 配置中心id=部门id_In;

    Select 配药批次 Into v_历史批次 From 输液配药记录 Where id=v_Tansid;
    update 输液配药记录 set 配药批次=v_batch,是否确认调整=0 where id=v_Tansid;

    Update 输液配药记录 Set 是否确认调整 = 0
    Where 医嘱id In (Select ID From 病人医嘱记录 Where 病人id = 病人id_In)
    And 执行时间 Between Trunc(执行日期_In) And Trunc(执行日期_In + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;

    If n_打包<>0 And v_配药类型 is Null Then
      update 输液配药记录 Set 是否打包=n_打包 where id=v_Tansid;
    Else
      Select Nvl(max(打包), 0) Into n_打包 From 配药工作批次 Where 批次 = v_历史批次 And 配置中心id=部门id_In;
      If n_打包<>0 Then
        Update 输液配药记录 Set 是否打包=0 where id=v_Tansid And trunc(执行时间)>trunc(Sysdate) ;
      End If;
    End If;
  end loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_输液配药记录_自动排批;
/

--104668:张德婷,2017-01-25,静配中心自动排批与保持上一天批次整合
CREATE OR REPLACE Procedure Zl_输液配药记录_打包
(
配药id_In In Varchar2, --ID串:配药ID1,打包1|配药ID2,打包2....
手工调整打包_In Number:=0
) Is
  v_Tansid Varchar2(20);
  v_打包   Number(1);
  v_Tmp    Varchar2(4000);
  v_Fields Varchar2(4000);
Begin
  If 配药id_In Is Null Then
    v_Tmp := Null;
  Else
    v_Tmp := 配药id_In || '|';
  End If;
  While v_Tmp Is Not Null Loop
    --分解单据ID串
    v_Fields := Substr(v_Tmp, 1, Instr(v_Tmp, '|') - 1);
    v_Tansid := Substr(v_Fields, 1, Instr(v_Fields, ',') - 1);
    v_打包   := Substr(v_Fields, Instr(v_Fields, ',') + 1);

    v_Tmp := Replace('|' || v_Tmp, '|' || v_Fields || '|');
    if  v_打包=0 Or 手工调整打包_In=0 then
      Update 输液配药记录 Set 是否打包 = v_打包,打包时间=null Where ID = v_Tansid;
    else
      Update 输液配药记录 Set 是否打包 = v_打包,打包时间=sysdate Where ID = v_Tansid;
    end if;
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_输液配药记录_打包;
/

--104617:冉俊明,2017-01-23,允许调整已发布且没有预约挂号的临床出诊安排。
Create Or Replace Procedure Zl_临床出诊记录_Insert
(
  Id_In           临床出诊记录.Id%Type,
  安排id_In       临床出诊记录.安排id%Type,
  号源id_In       临床出诊记录.号源id%Type,
  出诊日期_In     临床出诊记录.出诊日期%Type,
  上班时段_In     临床出诊记录.上班时段%Type,
  开始时间_In     临床出诊记录.开始时间%Type,
  终止时间_In     临床出诊记录.终止时间%Type,
  缺省预约时间_In 临床出诊记录.缺省预约时间%Type,
  提前挂号时间_In 临床出诊记录.提前挂号时间%Type,
  限号数_In       临床出诊记录.限号数%Type,
  限约数_In       临床出诊记录.限约数%Type,
  是否序号控制_In 临床出诊记录.是否序号控制%Type,
  是否分时段_In   临床出诊记录.是否分时段%Type,
  预约控制_In     临床出诊记录.预约控制%Type,
  是否独占_In     临床出诊记录.是否独占%Type,
  项目id_In       临床出诊记录.项目id%Type,
  科室id_In       临床出诊记录.科室id%Type,
  医生id_In       临床出诊记录.医生id%Type,
  医生姓名_In     临床出诊记录.医生姓名%Type,
  分诊方式_In     临床出诊记录.分诊方式%Type,
  是否临时出诊_In 临床出诊记录.是否临时出诊%Type,
  登记人_In       临床出诊记录.登记人%Type,
  登记时间_In     临床出诊记录.登记时间%Type,
  是否发布_In     临床出诊记录.是否发布%Type,
  诊室_In         Varchar2 := Null,
  时段_In         Varchar2 := Null,
  删除序号_In     Number := 0
) As
  --功能：插入或更新临床出诊记录
  --参数：
  --     诊室_In:诊室1,诊室2,...
  --     时段_In:序号,开始时间,终止时间,限制数量,预约标志|...
  --     删除序号_In:是否删除现有序号时段
  v_时段     Varchar2(5000);
  n_序号     临床出诊序号控制.序号%Type;
  d_开始时间 临床出诊序号控制.开始时间%Type;
  d_终止时间 临床出诊序号控制.终止时间%Type;
  n_数量     临床出诊序号控制.数量%Type;
  n_是否预约 临床出诊序号控制.是否预约%Type;
  v_当前序号 Varchar2(100);

  n_是否发布 Number;
  n_Count    Number;

  Err_Item Exception;
  v_Err_Msg Varchar2(255);
Begin
  --已发布后的都是临时出诊
  Select Max(1)
  Into n_是否发布
  From 临床出诊安排 A, 临床出诊表 B
  Where a.出诊id = b.Id And b.发布时间 Is Not Null And a.Id = 安排id_In;

  If Nvl(n_是否发布, 0) = 1 Then
    --肯定是发布后调整安排
    --备份数据
    For c_记录 In (Select ID, 安排id, To_Date('1900-01-01', 'yyyy-mm-dd') As 出诊日期, 登记人, 登记时间, 是否发布, 上班时段, 停诊开始时间

                 From 临床出诊记录 A
                 Where 安排id = 安排id_In And 出诊日期 = 出诊日期_In And 上班时段 = 上班时段_In And 相关id Is Null And Nvl(是否临时出诊, 0) = 0 And
                       Not Exists (Select 1 From 临床出诊记录 Where 相关id = a.Id)) Loop
    
      --检查是否已停诊
      If c_记录.停诊开始时间 Is Not Null Then
        v_Err_Msg := '上班时段 ' || c_记录.上班时段 || ' 已停诊，不能调整！';
        Raise Err_Item;
      End If;
      --检查是否已用于预约挂号
      Select Max(1) Into n_Count From 病人挂号记录 Where 出诊记录id = c_记录.Id And Rownum < 2;
      If Nvl(n_Count, 0) = 1 Then
        v_Err_Msg := '上班时段 ' || c_记录.上班时段 || ' 已用于预约挂号，不能调整！';
        Raise Err_Item;
      End If;
      Zl_临床出诊记录_Copy(c_记录.Id, c_记录.安排id, c_记录.出诊日期, c_记录.登记人, c_记录.登记时间, c_记录.是否发布, c_记录.Id);
    End Loop;
  End If;

  Update 临床出诊记录
  Set 安排id = 安排id_In, 号源id = 号源id_In, 出诊日期 = 出诊日期_In, 上班时段 = 上班时段_In, 开始时间 = 开始时间_In, 终止时间 = 终止时间_In, 缺省预约时间 = 缺省预约时间_In,
      提前挂号时间 = 提前挂号时间_In, 限号数 = 限号数_In, 限约数 = 限约数_In, 是否序号控制 = 是否序号控制_In, 是否分时段 = 是否分时段_In, 预约控制 = 预约控制_In,
      是否独占 = 是否独占_In, 项目id = 项目id_In, 科室id = 科室id_In, 医生id = 医生id_In, 医生姓名 = 医生姓名_In, 分诊方式 = 分诊方式_In,
      是否临时出诊 = Nvl(是否临时出诊_In, 是否临时出诊), 登记人 = Nvl(登记人_In, 登记人), 登记时间 = Nvl(登记时间_In, 登记时间), 诊室id = Null,
      是否发布 = Nvl(是否发布_In, 是否发布)
  Where ID = Id_In;
  If Sql% NotFound Then
    Insert Into 临床出诊记录
      (ID, 安排id, 号源id, 出诊日期, 上班时段, 开始时间, 终止时间, 缺省预约时间, 提前挂号时间, 限号数, 限约数, 是否序号控制, 是否分时段, 预约控制, 是否独占, 项目id, 科室id, 医生id,
       医生姓名, 分诊方式, 是否临时出诊, 登记人, 登记时间, 是否发布)
    Values
      (Id_In, 安排id_In, 号源id_In, 出诊日期_In, 上班时段_In, 开始时间_In, 终止时间_In, 缺省预约时间_In, 提前挂号时间_In, 限号数_In, 限约数_In, 是否序号控制_In,
       是否分时段_In, 预约控制_In, 是否独占_In, 项目id_In, 科室id_In, 医生id_In, 医生姓名_In, 分诊方式_In, 是否临时出诊_In, 登记人_In, 登记时间_In, 是否发布_In);
  End If;

  --删除上班时段为空的
  Delete From 临床出诊记录
  Where 安排id = 安排id_In And 号源id = 号源id_In And 出诊日期 = 出诊日期_In And 上班时段 Is Null And Exists
   (Select 1
         From 临床出诊记录
         Where 安排id = 安排id_In And 号源id = 号源id_In And 出诊日期 = 出诊日期_In And 上班时段 Is Not Null);

  Delete From 临床出诊诊室记录 Where 记录id = Id_In;
  --出诊诊室
  If 诊室_In Is Not Null Then
    Insert Into 临床出诊诊室记录
      (记录id, 诊室id)
      Select Id_In, Column_Value From Table(f_Str2list(诊室_In));
  
    If Nvl(分诊方式_In, 0) = 1 Then
      Update 临床出诊记录 Set 诊室id = To_Number(诊室_In) Where ID = Id_In;
    End If;
  End If;

  --出诊时段
  If Nvl(删除序号_In, 0) = 1 Then
    --删除现有序号时段
    Delete 临床出诊序号控制 Where 记录id = Id_In;
  End If;
  If 时段_In Is Not Null Then
    v_时段 := 时段_In || '|';
  End If;
  While v_时段 Is Not Null Loop
    v_当前序号 := Substr(v_时段, 1, Instr(v_时段, '|') - 1);
    n_序号     := To_Number(Substr(v_当前序号, 1, Instr(v_当前序号, ',') - 1));
    v_当前序号 := Substr(v_当前序号, Instr(v_当前序号, ',') + 1);
    d_开始时间 := To_Date(Substr(v_当前序号, 1, Instr(v_当前序号, ',') - 1), 'yyyy-mm-dd hh24:mi:ss');
    v_当前序号 := Substr(v_当前序号, Instr(v_当前序号, ',') + 1);
    d_终止时间 := To_Date(Substr(v_当前序号, 1, Instr(v_当前序号, ',') - 1), 'yyyy-mm-dd hh24:mi:ss');
    v_当前序号 := Substr(v_当前序号, Instr(v_当前序号, ',') + 1);
    n_数量     := To_Number(Substr(v_当前序号, 1, Instr(v_当前序号, ',') - 1));
    v_当前序号 := Substr(v_当前序号, Instr(v_当前序号, ',') + 1);
    n_是否预约 := To_Number(v_当前序号);
    If Nvl(n_序号, 0) > 0 Then
      If Nvl(是否分时段_In, 0) = 1 And Nvl(是否序号控制_In, 0) = 1 Then
        --分时段且启用序号控制，使用"预约顺序号"记录"是否预约"
        Insert Into 临床出诊序号控制
          (记录id, 序号, 开始时间, 终止时间, 是否预约, 数量, 预约顺序号)
        Values
          (Id_In, n_序号, d_开始时间, d_终止时间, n_是否预约, n_数量, n_是否预约);
      Else
        Insert Into 临床出诊序号控制
          (记录id, 序号, 开始时间, 终止时间, 是否预约, 数量)
        Values
          (Id_In, n_序号, d_开始时间, d_终止时间, n_是否预约, n_数量);
      End If;
    End If;
    v_时段 := Substr(v_时段, Instr(v_时段, '|') + 1);
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊记录_Insert;
/

--104981:冉俊明,2017-02-06,退费时，相应的退费记录中的挂号ID和主页ID为原费用记录的挂号ID和主页ID。
--105271:冉俊明,2017-01-23,收费时为负数数量的收费项目无法退费。
Create Or Replace Procedure Zl_门诊收费记录_销帐
(
  No_In         门诊费用记录.No%Type,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  序号_In       Varchar2 := Null,
  退费时间_In   门诊费用记录.登记时间%Type := Null,
  退费摘要_In   门诊费用记录.摘要%Type := Null,
  结帐id_In     病人预交记录.结帐id%Type := Null,
  回收票据_In   Number := 0
) As
  --功能：删除一张门诊收费单据
  --参数：
  --        序号_IN           =要退费的项目序号,格式为"1,3,5,6...",缺省NULL表示退"未退的"所有行。
  --        回收票据_In       =0:全退或最后一次全退时,收回票据。
  --                           1:部份退费不处理票据,通过重打调用单独处理。
  --该游标为要退费单据的所有原始记录

  --医保全退但某种结算退现金从而产生了新的误差时,排开此处的误差处理,执行完本过程后,界面程序中单独处理新误差
  Cursor c_Bill Is
    Select a.Id, a.No, a.附加标志, a.收费细目id, a.序号, a.价格父号, a.执行状态, a.收费类别, a.付数, a.数次, a.医嘱序号, j.诊疗类别, m.跟踪在用,
           Nvl(a.附加标志, 0) As 误差, Nvl(j.医嘱状态, 0) As 医嘱状态
    From 门诊费用记录 A, 病人医嘱记录 J, 材料特性 M
    Where a.医嘱序号 = j.Id(+) And a.No = No_In And a.记录性质 = 1 And a.记录状态 In (1, 3) And a.收费细目id + 0 = m.材料id(+)
    Order By a.收费细目id, a.序号;

  --:不管原始单据误差,都应该根据当前退费产生的误差项进行处理
  -- Decode(Sign(误差_In), 0, 999, 9)

  --该光标用于处理人员缴款余额中退的不同结算方式的金额

  n_结帐id 门诊费用记录.结帐id%Type;
  n_打印id 票据打印内容.Id%Type;

  --部分退费计算变量
  n_剩余数量 Number;
  n_剩余应收 Number;
  n_剩余实收 Number;
  n_剩余统筹 Number;
  n_准退数量 Number;
  n_退费次数 Number;

  n_应收金额 Number;
  n_实收金额 Number;
  n_统筹金额 Number;
  n_总金额   Number;
  n_组id     财务缴款分组.Id%Type;

  l_使用id   t_Numlist := t_Numlist();
  l_序号     t_Numlist := t_Numlist();
  l_执行状态 t_Numlist := t_Numlist();

  n_Dec   Number;
  d_Date  Date;
  n_Count Number;

  Err_Item Exception;
  v_Err_Msg  Varchar2(255);
  n_启用模式 Number(3);
  v_Para     Varchar2(1000);

Begin
  n_组id := Zl_Get组id(操作员姓名_In);
  --是否已经全部完全执行(只是该单据整张单据的检查)
  Select Nvl(Count(*), 0)
  Into n_Count
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1;
  If n_Count = 0 Then
    v_Err_Msg := '该单据中的项目已经全部完全执行！';
    Raise Err_Item;
  End If;

  --未完全执行的项目是否有剩余数量(只是整张单据的检查)
  --执行状态在原始记录上判断
  Select Nvl(Count(*), 0)
  Into n_Count
  From (Select 序号, Sum(数量) As 剩余数量
         From (Select 记录状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量, 结帐id
                From 门诊费用记录
                Where NO = No_In And Mod(记录性质, 10) = 1 And Nvl(附加标志, 0) <> 9 And
                      Nvl(价格父号, 序号) In
                      (Select Nvl(价格父号, 序号)
                       From 门诊费用记录
                       Where NO = No_In And Mod(记录性质, 10) = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1)
                Group By 记录状态, Nvl(价格父号, 序号), 结帐id)
         Group By 序号
         Having Sum(数量) <> 0);
  If n_Count = 0 Then
    v_Err_Msg := '该单据中未完全执行部分项目剩余数量为零,没有可以退费的费用！';
    Raise Err_Item;
  End If;

  ---------------------------------------------------------------------------------
  --公用变量
  If 退费时间_In Is Not Null Then
    d_Date := 退费时间_In;
  Else
    Select Sysdate Into d_Date From Dual;
  End If;

  If 结帐id_In Is Null Then
    Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  Else
    n_结帐id := 结帐id_In;
  End If;

  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into n_Dec From Dual;

  --循环处理每行费用(收入项目行)
  n_总金额 := 0;
  For r_Bill In c_Bill Loop
    If Instr(',' || 序号_In || ',', ',' || Nvl(r_Bill.价格父号, r_Bill.序号) || ',') > 0 Or 序号_In Is Null Then
      If Nvl(r_Bill.执行状态, 0) <> 1 Then
        --求剩余数量,剩余应收,剩余实收
        Select Sum(Nvl(付数, 1) * 数次), Sum(应收金额), Sum(实收金额), Sum(统筹金额)
        Into n_剩余数量, n_剩余应收, n_剩余实收, n_剩余统筹
        From 门诊费用记录
        Where NO = No_In And Mod(记录性质, 10) = 1 And 序号 = r_Bill.序号;
      
        If n_剩余数量 = 0 Then
          If 序号_In Is Not Null Then
            v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经全部退费！';
            Raise Err_Item;
          End If;
        Else
          --准退数量(非药品项目为剩余数量,原始数量)
          If Instr(',4,5,6,7,', r_Bill.收费类别) = 0 Or (r_Bill.收费类别 = '4' And Nvl(r_Bill.跟踪在用, 0) = 0) Then
            --@@@
            --非药品部分(以具体医嘱执行为准进行检查)
            --: 1.存在医嘱执行计价的,则以医嘱执行为准(但不能包含:检查;检验;手术;麻醉及输血),已执行的不允许退费
            --: 2.不存在医嘱执行计价的,则以剩余数量为准
            --: 3.医嘱作废了的,则以剩余数量为准(病人医嘱记录.医嘱状态=4表示作废医嘱，会删除"病人医嘱发送",门诊药嘱先作废后退药)
            n_Count := 0;
            If Instr(',C,D,F,G,K,', ',' || r_Bill.诊疗类别 || ',') = 0 And r_Bill.诊疗类别 Is Not Null And r_Bill.医嘱状态 <> 4 Then
              Select Nvl(Sum(Decode(c.执行状态, 0, 1, 0) * c.数量), 0), Count(1)
              Into n_准退数量, n_Count
              From 病人医嘱发送 B, 医嘱执行计价 C
              Where b.医嘱id = r_Bill.医嘱序号 And b.No = r_Bill.No And b.医嘱id = c.医嘱id And b.发送号 = c.发送号 And
                    c.收费细目id + 0 = r_Bill.收费细目id And b.记录性质 = 1;
            End If;
            If Nvl(n_Count, 0) <> 0 And n_准退数量 = 0 Then
              v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已执行，不允许退费！';
              Raise Err_Item;
            End If;
          
            If Nvl(n_Count, 0) = 0 Then
              If r_Bill.执行状态 = 2 Then
                --无医嘱执行计价的部分退费无法判断准退数量，不允许退费
                v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已部分执行，无法判断准退数量，不允许退费！';
                Raise Err_Item;
              Else
                n_准退数量 := n_剩余数量;
              End If;
            End If;
          
          Else
            Select Nvl(Sum(Nvl(付数, 1) * 实际数量), 0), Count(*)
            Into n_准退数量, n_Count
            From 药品收发记录
            Where NO = No_In And 单据 In (8, 24) And Mod(记录状态, 3) = 1 --@@@
                  And 审核人 Is Null And 费用id = r_Bill.Id;
          
            --有剩余数量无准退数量的有两种情况：
            --1.不跟踪在用的卫材无对应的收发记录,这时使用剩余数量
            --2.并发操作,此时已发药或发料
            If n_准退数量 = 0 Then
              If r_Bill.收费类别 = '4' Then
                If n_Count > 0 Then
                  v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发料,须退料后再退费！';
                  Raise Err_Item;
                Else
                  n_准退数量 := n_剩余数量;
                End If;
              Else
                v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发药,须退药后再退费！';
                Raise Err_Item;
              End If;
            End If;
          End If;
        
          If n_准退数量 > n_剩余数量 Then
            v_Err_Msg := '单据[' || No_In || '] 中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用的退费数量(' || n_准退数量 ||
                         ')大于了剩余数量(' || n_剩余数量 || ')，不允许退费！';
            Raise Err_Item;
          End If;
          --收费的时候是负数数量的不检查准退数量是否小于零
          If n_准退数量 < 0 And Nvl(r_Bill.付数, 1) * r_Bill.数次 > 0 Then
            v_Err_Msg := '单据[' || No_In || '] 中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用的退费数量(' || n_准退数量 ||
                         ')小于了零，不允许退费！';
            Raise Err_Item;
          End If;
        
          --该笔项目第几次退费
          Select Nvl(Max(Abs(执行状态)), 0) + 1
          Into n_退费次数
          From 门诊费用记录
          Where NO = No_In And Mod(记录性质, 10) = 1 And 记录状态 = 2 And Nvl(执行状态, 0) < 0 And 序号 = r_Bill.序号;
        
          --金额=剩余金额*(准退数/剩余数)
          n_应收金额 := Round(n_剩余应收 * (n_准退数量 / n_剩余数量), n_Dec);
          n_实收金额 := Round(n_剩余实收 * (n_准退数量 / n_剩余数量), n_Dec);
          n_统筹金额 := Round(n_剩余统筹 * (n_准退数量 / n_剩余数量), n_Dec);
          n_总金额   := n_总金额 + n_实收金额;
        
          --插入退费记录
          Insert Into 门诊费用记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别,
             收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人,
             执行状态, 费用状态, 执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 结论,
             缴款组id, 挂号id, 主页id)
            Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别,
                   病人科室id, 收费类别, 收费细目id, 计算单位, Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, 付数, 1), 发药窗口,
                   Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, -1 * 数次, -1 * n_准退数量), 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价,
                   -1 * n_应收金额, -1 * n_实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, -1 * n_退费次数, 1, 执行时间, 操作员编号_In, 操作员姓名_In,
                   发生时间, d_Date, n_结帐id, -1 * n_实收金额, 保险项目否, 保险大类id, -1 * n_统筹金额, Nvl(退费摘要_In, 摘要),
                   Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, 结论, n_组id, 挂号id, 主页id
            From 门诊费用记录
            Where ID = r_Bill.Id;
        
          --标记原费用记录
          l_序号.Extend;
          l_序号(l_序号.Count) := r_Bill.序号;
          l_执行状态.Extend;
          l_执行状态(l_执行状态.Count) := Case
                                    When Sign(n_准退数量 - n_剩余数量) = 0 Then
                                     0
                                    Else
                                     1
                                  End;
        End If;
      Else
        If 序号_In Is Not Null Then
          v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经完全执行,不能退费！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  End Loop;
  --标记原费用记录
  Forall I In 1 .. l_序号.Count
    Update 门诊费用记录
    Set 记录状态 = 3, 执行状态 = l_执行状态(I)
    Where Mod(记录性质, 10) = 1 And NO = No_In And 序号 = l_序号(I) And 记录状态 In (1, 3);

  l_序号.Delete;
  For c_结帐 In (Select Distinct b.结帐id
               From 门诊费用记录 A, 病人预交记录 B
               Where a.结帐id = b.结帐id And a.No = No_In And Mod(a.记录性质, 10) = 1 And a.记录状态 In (1, 3) And
                     Nvl(b.记录状态, 0) = 1) Loop
    l_序号.Extend;
    l_序号(l_序号.Count) := c_结帐.结帐id;
  End Loop;

  Forall I In 1 .. l_序号.Count
    Update 病人预交记录 Set 记录状态 = 3 Where 结帐id = l_序号(I) And Mod(记录性质, 10) <> 1;

  ---------------------------------------------------------------------------------
  --退费票据回收(仅全退时才回退,部分退是在重打过程中回收)
  If 回收票据_In = 1 Then
  
    --启用标志||NO;执行科室(条数);收据费目(首页汇总,条数);收费细目(条数)
    v_Para     := Nvl(zl_GetSysParameter('票据分配规则', 1121), '0||0;0;0,0;0');
    n_启用模式 := Zl_To_Number(Substr(v_Para, 1, 1));
    If n_启用模式 <> 0 Then
      --收回票据
      Select 使用id Bulk Collect
      Into l_使用id
      From (Select Distinct b.使用id From 票据打印明细 B Where b.No = No_In And Nvl(b.票种, 0) = 1);
    
      n_启用模式 := l_使用id.Count;
      If l_使用id.Count <> 0 Then
        --插入回收记录
        Forall I In 1 .. l_使用id.Count
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 操作员姓名_In, d_Date
            From 票据使用明细 A
            Where ID = l_使用id(I) And 性质 = 1 And Not Exists
             (Select 1 From 票据使用明细 Where 号码 = a.号码 And 票种 = a.票种 And Nvl(性质, 0) <> 1);
      
        Forall I In 1 .. l_使用id.Count
          Update 票据打印明细 Set 是否回收 = 1 Where 使用id = l_使用id(I) And Nvl(是否回收, 0) = 0;
      
      End If;
    End If;
    If n_启用模式 = 0 Then
      --获取单据最后一次的打印ID(可能是多张单据收费打印)
      Begin
        --性质=1，原因=6为退费打印票据(红票)，不回收
        Select ID
        Into n_打印id
        From (Select b.Id
               From 票据使用明细 A, 票据打印内容 B
               Where a.打印id = b.Id And a.性质 = 1 And a.原因 In (1, 3) And b.数据性质 = 1 And b.No = No_In
               Order By a.使用时间 Desc)
        Where Rownum < 2;
      Exception
        When Others Then
          Null;
      End;
      --可能以前没有打印,无收回
      If n_打印id Is Not Null Then
        --a.多张单据循环调用时只能收回一次
        Select Count(*) Into n_Count From 票据使用明细 Where 票种 = 1 And 性质 = 2 And 打印id = n_打印id;
        If n_Count = 0 Then
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
            From 票据使用明细
            Where 打印id = n_打印id And 票种 = 1 And 性质 = 1;
        Else
          --b.部分退费多次收回时,最后一次全退收回要排开已收回的
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
            From 票据使用明细 A
            Where 打印id = n_打印id And 票种 = 1 And 性质 = 1 And Not Exists
             (Select 1 From 票据使用明细 B Where a.号码 = b.号码 And 打印id = n_打印id And 票种 = 1 And 性质 = 2);
        End If;
      End If;
    End If;
  End If;

  ---------------------------------------------------------------------------------
  --药品卫材相关内容
  For r_Expenses In (Select ID
                     From 门诊费用记录
                     Where NO = No_In And Mod(记录性质, 10) = 1 And 记录状态 In (1, 3) And 收费类别 In ('4', '5', '6', '7') And
                           (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null)) Loop
    Zl_药品收发记录_销售退费(r_Expenses.Id);
  End Loop;

  --医嘱处理
  --删除病人医嘱附费(最后一次删除时)
  For c_医嘱 In (Select Distinct 医嘱序号
               From 门诊费用记录
               Where NO = No_In And Mod(记录性质, 10) = 1 And 记录状态 = 3 And 医嘱序号 Is Not Null) Loop
    Select Nvl(Count(*), 0)
    Into n_Count
    From (Select 序号, Sum(数量) As 剩余数量
           From (Select 记录状态, 执行状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                  From 门诊费用记录
                  Where Mod(记录性质, 10) = 1 And Nvl(附加标志, 0) <> 9 And 医嘱序号 + 0 = c_医嘱.医嘱序号 And NO = No_In
                  Group By 记录状态, 执行状态, Nvl(价格父号, 序号))
           Group By 序号
           Having Sum(数量) <> 0);
  
    If n_Count = 0 Then
      Delete From 病人医嘱附费 Where 医嘱id = c_医嘱.医嘱序号 And 记录性质 = 1 And NO = No_In;
    End If;
  End Loop;

  --调整医嘱执行计价.执行状态 NULL-历史数据；0-未执行；1-已执行；2-已退费
  For c_费用 In (Select Distinct a.医嘱序号 As 医嘱id, a.收费细目id, b.发送号
               From 门诊费用记录 A, 病人医嘱发送 B
               Where a.医嘱序号 = b.医嘱id And a.No = b.No And a.记录性质 = 1 And a.记录状态 In (1, 3) And a.No = No_In And
                     (Instr(',' || 序号_In || ',', ',' || a.序号 || ',') > 0 Or 序号_In Is Null) And a.价格父号 Is Null And
                     b.记录性质 = 1) Loop
    Update 医嘱执行计价
    Set 执行状态 = 2
    Where 医嘱id = c_费用.医嘱id And 发送号 = c_费用.发送号 And 收费细目id = c_费用.收费细目id And 执行状态 = 0;
  End Loop;

  --场合_In    Integer:=0, --0:门诊;1-住院
  --性质_In    Integer:=1, --1-收费单;2-记帐单
  --操作_In    Integer:=0, --0:删除划价单;1-收费或记帐;2-退费或销帐
  --No_In      门诊费用记录.No%Type,
  --医嘱ids_In Varchar2 := Null
  Zl_医嘱发送_计费状态_Update(0, 1, 2, No_In);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费记录_销帐;
/

--104754:梁经伙,2017-01-23,修正了存在主页ID为0的记录时获取住院次数不准确
CREATE OR REPLACE Function Zl_获取住院次数或主页id
( 
  病人id_In 病案主页.病人id%Type, 
  次数_In   病案主页.主页id%Type, 
  标识_In   Integer 
) 
-------------------------------------------------------------------------------------------------------------------------------------- 
  --功能:获取住院次数或主页ID 
  --入参: 
  --      病人ID_IN:病人ID值 
  --      次数_IN:当标识_IN为1时传入实际的住院次数(排除了留观病人),当标识_IN为0时,表示传入的是主页id. 
  -- 标识_IN:1-返回指定次数的主页id,0-根据主页id返回住院次数(排除了留观病人) 
  --返回:根据病人ID，返回主页id或实际住院次数 
  -------------------------------------------------------------------------------------------------------------------------------------- 
 
 Return Integer Is 
  n_次数 病案主页.主页id%Type; 
  n_留观 病案主页.主页id%Type; 
Begin 
  If 标识_In = 1 Then 
    --根据住院次数，获取主页id 
    Begin 
      Select Max(主页id) 
      Into n_次数 
      From 病案主页 
      Where 病人id = 病人id_In And Nvl(病人性质, 0) = 0 Having Count(*) <= 次数_In; 
    Exception 
      When Others Then 
        n_次数 := 0; 
    End; 
 
    --IF n_次数=0 THEN 
    --  --获取当前的最大主页id,但要排除留观病人 
    --  SELECT max(主页id) INTO n_次数 
    --  FROM 病案主页 
    --  WHERE 病人id=病人id_In  AND nvl(病人性质,0)=0; 
    --End IF ; 
    Return n_次数; 
  Else 
    --判断是否存在留观病人 
    Begin 
      Select Count(*) 
      Into n_留观 
      From 病案主页 
      Where 病人id = 病人id_In And 主页id <= 次数_In And Nvl(病人性质, 0) <> 0; 
    Exception 
      When Others Then 
        n_留观 := 0; 
    End; 
    If n_留观 > 0 Then 
      --根据主页id，获取实际的住院次数 
      Begin 
        Select Count(*) 
        Into n_次数 
        From 病案主页 
        Where 病人id = 病人id_In And 主页id <= 次数_In And Nvl(病人性质, 0) = 0; 
      Exception 
        When Others Then 
          n_次数 := 0; 
      End; 
    Else 
      --根据住院次数，获取主页id,处理切换系统的情况. 
      Begin 
        Select Max(主页id) 
        Into n_次数 
        From 病案主页 
        Where 病人id = 病人id_In And Nvl(病人性质, 0) = 0 And 主页id <= 次数_In and 主页ID > 0 Having Count(*) <= 次数_In; 
      Exception 
        When Others Then 
          n_次数 := 0; 
      End; 
    End If; 
    Return n_次数; 
  End If; 
Exception 
  When Others Then 
    Return 0; 
End Zl_获取住院次数或主页id;
/

--101452:余伟节,2017-01-22,撤销入住、入院入住操作如果存在未作废医嘱时禁止撤销操作
Create Or Replace Procedure Zl_病人变动记录_Undo
(
  病人id_In     病案主页.病人id%Type,
  主页id_In     病案主页.主页id%Type,
  操作员编号_In 病人变动记录.操作员编号%Type,
  操作员姓名_In 病人变动记录.操作员姓名%Type,
  数据_In       Varchar2 := Null, --a.转为住院时,清除住院号,b-检查自动记帐费用是否已结帐
  床号_In       Varchar2 := Null, --传入时表示撤销出院时安排到新的床号，原床位被占用在程序中判断
  主床位_In     Varchar2 := Null, --传入时表示撤销出院时安排到新的主床位，原床位被占用在程序中判断
  撤销方式_In   Varchar2 := Null --指明具体撤销操作，如撤销出院、转科等必须输入
) As
  -----------------------------------------------------------
  --说明：1.撤消病人最近一次的变动
  --        2.前提：当病人包床时,对其中一张床位作变动,则所有床位相应产生变动
  -----------------------------------------------------------
  --要撤消的变动记录(如果包床,可能多条)
  Cursor c_Curlog Is
    Select *
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And (终止时间 Is Null Or 终止原因 = 1)
    Order By 终止时间 Desc, 开始时间 Desc;
  r_Curlogrow c_Curlog%RowType;

  --撤消后要恢复的变动记录(如果包床,可能多条)
  Cursor c_Prelog
  (
    v_终止时间 病人变动记录.终止时间%Type,
    v_终止原因 病人变动记录.终止原因%Type
  ) Is
    Select *
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_终止时间 And 终止原因 = v_终止原因
    Order By 终止时间 Desc, 开始时间 Desc;
  r_Prelogrow c_Prelog%RowType;

  --获取病人原床位所住病人信息
  Cursor c_Prebed
  (
    v_病人id 病案主页.病人id%Type,
    v_主页id 病案主页.主页id%Type
  ) Is
    Select a.床号, c.出院病床, c.出院科室id, c.当前病区id
    From 病人变动记录 A, 床位状况记录 B, 病案主页 C
    Where a.病人id = 病人id_In And a.主页id = 主页id_In And 终止原因 = 4 And a.病区id = b.病区id And a.病人id = c.病人id And
          a.主页id = c.主页id And a.床号 = b.床号
    Order By 终止时间 Desc, 开始时间 Desc;
  r_Prebedrow c_Prebed%RowType;

  Cursor c_Prebedpati
  (
    v_出院科室id 病人变动记录.科室id%Type,
    v_病区id     病人变动记录.病区id%Type,
    v_原床号     病人变动记录.床号%Type
  ) Is
    Select a.病人id, c.主页id, a.床号, c.出院病床
    From 病人变动记录 A, 病案主页 C,
         (Select 病人id
           From 床位状况记录
           Where (科室id Is Null Or 科室id = v_出院科室id Or 共用 = 1) And 病区id = v_病区id And 床号 = v_原床号) D
    Where a.病人id = d.病人id And a.主页id = (Select 主页id From 病人信息 Where 病人id = d.病人id) And a.终止原因 = 4 And a.病人id = c.病人id And
          a.主页id = c.主页id
    Order By 终止时间 Desc, 开始时间 Desc;
  r_Prebedpati c_Prebedpati%RowType;

  v_开始时间 病人变动记录.开始时间%Type;
  v_开始原因 病人变动记录.开始原因%Type;
  v_终止人员 病人变动记录.终止人员%Type;

  v_Count       Number;
  v_Countcurlog Number;
  v_Countprelog Number;

  Err_Custom Exception;
  v_Error Varchar2(255);

  v_撤销方式     Varchar2(100);
  v_共享号       Zlsystems.共享号%Type;
  v_病案状态     Number(3);
  v_床号串       Varchar2(255);
  v_床号         病人变动记录.床号%Type;
  v_病人id       病人变动记录.病人id%Type;
  v_主页id       病人变动记录.主页id%Type;
  v_病区id       病人变动记录.病区id%Type;
  v_原床号1      病人变动记录.床号%Type;
  v_原床号2      病人变动记录.床号%Type;
  v_当前床号1    病人变动记录.床号%Type;
  v_当前床号2    病人变动记录.床号%Type;
  v_出院科室id   病人变动记录.科室id%Type;
  v_床位等级id   病人变动记录.床位等级id%Type;
  v_险类         病案主页.险类%Type;
  v_姓名         病人信息.姓名%Type;
  n_原科室id     病案主页.出院科室id%Type;
  n_原病区id     病案主页.当前病区id%Type;
  v_母婴转科标志 病案主页.母婴转科标志%Type;
  v_Tmp          Varchar2(100);
  d_开始时间     Date;

  Function Checkpatiadvice
  (
    病人id_In   病案主页.病人id%Type,
    主页id_In   病案主页.主页id%Type,
    撤销方式_In Varchar2 := Null
  ) Return Varchar2 Is
    --本次住院所有医嘱记录都已作废
    v_Err Varchar2(255);
  Begin
    v_Err := Null;
  
    For r_Row In (Select 开嘱医生, Decode(医嘱状态, -1, '暂存', 1, '新开', 2, '校对疑问', '未作废') As 状态, 医嘱内容
                  From 病人医嘱记录
                  Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(医嘱状态, 0) <> 4 And Rownum < 2) Loop
      v_Err := '[ZLSOFT]【' || r_Row.开嘱医生 || '】医生有' || r_Row.状态 || '的医嘱没有处理,不允许撤销' || 撤销方式_In || '！[ZLSOFT]';
    End Loop;
    Return v_Err;
  End Checkpatiadvice;
Begin
  If 撤销方式_In Is Null Then
    v_Error := '[ZLSOFT]没有指明具体的撤销操作！[ZLSOFT]';
    Raise Err_Custom;
  Else
    v_撤销方式 := 撤销方式_In;
  End If;

  Open c_Curlog;
  Fetch c_Curlog
    Into r_Curlogrow;
  If c_Curlog%RowCount = 0 Then
    v_Error := '[ZLSOFT]病人当前没有可以撤消的操作！[ZLSOFT]';
    Close c_Curlog;
    Raise Err_Custom;
  End If;

  Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id > 主页id_In;
  If v_Count > 0 Then
    v_Error := '[ZLSOFT]您只能对病人的最后一次住院进行撤销操作,本次撤销操作终止![ZLSOFT]';
    Raise Err_Custom;
  End If;

  Select Count(ID)
  Into v_Countcurlog
  From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And (终止时间 Is Null Or 终止原因 = 1)
  Order By 终止时间 Desc, 开始时间 Desc;

  Select Count(a.床号)
  Into v_Countprelog
  From 病人变动记录 A, 床位状况记录 B, 病案主页 C
  Where a.病人id = 病人id_In And a.主页id = 主页id_In And 终止原因 = 4 And a.病区id = b.病区id And a.病人id = c.病人id And a.主页id = c.主页id And
        a.床号 = b.床号
  Order By 终止时间 Desc, 开始时间 Desc;

  --判断是否撤消床位对换
  If v_撤销方式 = '换床' And v_Countcurlog <= 1 And v_Countprelog <= 1 Then
    Open c_Prebed(病人id_In, 主页id_In);
    Fetch c_Prebed
      Into r_Prebedrow;
  
    v_出院科室id := r_Prebedrow.出院科室id;
    v_病区id     := r_Prebedrow.当前病区id;
    v_原床号1    := r_Prebedrow.床号;
    v_当前床号1  := r_Prebedrow.出院病床;
  
    For r_Prebedpati In c_Prebedpati(v_出院科室id, v_病区id, v_原床号1) Loop
      v_病人id    := r_Prebedpati.病人id;
      v_主页id    := r_Prebedpati.主页id;
      v_原床号2   := r_Prebedpati.床号;
      v_当前床号2 := r_Prebedpati.出院病床;
    
      If v_病人id <> 0 And v_主页id <> 0 And v_原床号1 = v_当前床号2 And v_原床号2 = v_当前床号1 Then
        v_撤销方式 := '床位对换';
        Select 险类 Into v_险类 From 病案主页 Where 病人id = v_病人id And 主页id = v_主页id;
        If v_险类 Is Null Then
          Zl_病人变动记录_Undo(v_病人id, v_主页id, 操作员编号_In, 操作员姓名_In, Null, 床号_In, 主床位_In, v_撤销方式);
        Else
          Zl_病人变动记录_Undo(v_病人id, v_主页id, 操作员编号_In, 操作员姓名_In, '1', 床号_In, 主床位_In, v_撤销方式);
        End If;
      End If;
    
      --只对最近一次床位是对方床位的记录进行处理
      Exit;
    End Loop;
  End If;

  If r_Curlogrow.终止时间 Is Null And r_Curlogrow.开始时间 Is Null And r_Curlogrow.开始原因 = 3 And v_撤销方式 = '转科' Then
    --撤消转科(标志)
    Delete From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 Is Null And 终止时间 Is Null And 开始原因 = 3;
  
    Update 病案主页 Set 状态 = 0 Where 病人id = 病人id_In And 主页id = 主页id_In;
  
    Close c_Curlog;
  Elsif r_Curlogrow.终止时间 Is Null And r_Curlogrow.开始时间 Is Null And r_Curlogrow.开始原因 = 15 And v_撤销方式 = '转病区' Then
    --撤消转科(标志)
    Delete From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 Is Null And 终止时间 Is Null And 开始原因 = 15;
  
    Update 病案主页 Set 状态 = 0 Where 病人id = 病人id_In And 主页id = 主页id_In;
  
    Close c_Curlog;
  Elsif r_Curlogrow.终止时间 Is Not Null And r_Curlogrow.终止原因 = 1 And v_撤销方式 = '出院' Then
    --撤消出院
    v_开始时间 := r_Curlogrow.终止时间; --新增的变动记录的开始时间
  
    Select Zl_住院日报_Count(r_Curlogrow.科室id, r_Curlogrow.终止时间) Into v_Count From Dual;
    If v_Count > 0 Then
      v_Error := '[ZLSOFT]已产生业务时间内的住院日报,不能办理该业务![ZLSOFT]';
      Raise Err_Custom;
    End If;
    --是否进行过电子病案审查
    Select Nvl(病案状态, 0) Into v_病案状态 From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
    If v_病案状态 Not In (0, 2) Then
      v_Error := '[ZLSOFT]病人的电子病案已提交审查，不能再撤消出院。[ZLSOFT]';
      Close c_Curlog;
      Raise Err_Custom;
    End If;
  
    --删除病历书写时机
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '出院', r_Curlogrow.科室id);
  
    --恢复入院
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Not Null And 终止原因 = 1;
  
    Select 开始原因
    Into v_开始原因
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And Nvl(附加床位, 0) = 0;
  
    Update 病案主页
    Set 状态 = Decode(v_开始原因, 10, 3, 状态), 出院日期 = Null, 出院方式 = Null, 随诊标志 = Null, 随诊期限 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In;
    --处理床位
    If 床号_In Is Null Then
      --原床位没有被占用,家庭病床也不会被占用(程序中已判断被占用情况,占用会传入床号_In)
      Close c_Curlog;
      For r_Curlogrow In c_Curlog Loop
        If r_Curlogrow.床号 Is Not Null Then
          --检查床位
          Select Count(*)
          Into v_Count
          From 床位状况记录
          Where 病区id = r_Curlogrow.病区id And 床号 = r_Curlogrow.床号 And 状态 = '空床';
          If v_Count = 0 Then
            v_Error := '[ZLSOFT]操作失败,床位 ' || r_Curlogrow.床号 || ' 不是空床！[ZLSOFT]';
            Raise Err_Custom;
          End If;
          --重新占用床位
          Update 床位状况记录
          Set 状态 = '占用', 病人id = 病人id_In, 等级id = r_Curlogrow.床位等级id, 科室id = r_Curlogrow.科室id --强行恢复以前的科室,共用床也不用处理了。
          Where 病区id = r_Curlogrow.病区id And 床号 = r_Curlogrow.床号;
        End If;
      
        If Nvl(r_Curlogrow.附加床位, 0) = 0 Then
          Update 病人信息
          Set 出院时间 = Null, 当前病区id = r_Curlogrow.病区id, 当前科室id = r_Curlogrow.科室id, 当前床号 = r_Curlogrow.床号, 在院 = 1
          Where 病人id = 病人id_In;
        
          --更新在院病人
          Begin
            Update 在院病人
            Set 病区id = Nvl(r_Curlogrow.病区id, 0), 科室id = r_Curlogrow.科室id
            Where 病人id = 病人id_In;
            If Sql%RowCount = 0 Then
              Insert Into 在院病人
                (病人id, 科室id, 病区id, 主页id)
              Values
                (病人id_In, r_Curlogrow.科室id, Nvl(r_Curlogrow.病区id, 0), Nvl(主页id_In, 0));
            End If;
          Exception
            When Others Then
              Null;
          End;
        
        End If;
      End Loop;
    Else
      --原床位被占用，传入新安排的床位,入住一张或多张病床病床
      v_床号串 := 床号_In || ',';
      --如果病人出院前状态为预出院，则撤消预出院
      If v_开始原因 = 10 Then
        --撤消预出院
        Update 病案主页 Set 状态 = 0 Where 病人id = 病人id_In And 主页id = 主页id_In;
        --恢复变动
        Delete From 病人变动记录
        Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 10 And 终止时间 Is Null;
      
        Update 病人变动记录
        Set 终止时间 = v_开始时间, 终止原因 = 4, 终止人员 = 操作员姓名_In,
            上次计算时间 = Decode(Sign(Nvl(上次计算时间, v_开始时间) - v_开始时间), 1, Null, 上次计算时间)
        Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 10 And 终止时间 = r_Curlogrow.开始时间;
      Else
        Update 病人变动记录
        Set 终止时间 = v_开始时间, 终止原因 = 4, 终止人员 = 操作员姓名_In,
            上次计算时间 = Decode(Sign(Nvl(上次计算时间, v_开始时间) - v_开始时间), 1, Null, 上次计算时间)
        Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
      End If;
    
      While v_床号串 Is Not Null Loop
        v_床号 := Substr(v_床号串, 1, Instr(v_床号串, ',') - 1);
        --原始床位等级与新床位等级及数量在程序中判断
        --检查床位
        Select Count(*)
        Into v_Count
        From 床位状况记录
        Where 病区id = r_Curlogrow.病区id And 床号 = v_床号 And 状态 = '空床';
        If v_Count = 0 Then
          v_Error := '操作失败,床位 ' || v_床号 || ' 不是空床！';
          Close c_Curlog;
          Raise Err_Custom;
        End If;
        --更新床位状况记录
        Update 床位状况记录
        Set 状态 = '占用', 病人id = 病人id_In, 科室id = r_Curlogrow.科室id
        Where 病区id = r_Curlogrow.病区id And 床号 = v_床号;
      
        Select 等级id Into v_床位等级id From 床位状况记录 Where 病区id = r_Curlogrow.病区id And 床号 = v_床号;
        ----新增原因为4
        Insert Into 病人变动记录
          (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号,
           操作员姓名)
        Values
          (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, v_开始时间, 4, Decode(主床位_In, v_床号, 0, 1), r_Curlogrow.病区id,
           r_Curlogrow.科室id, r_Curlogrow.医疗小组id, r_Curlogrow.护理等级id, v_床位等级id, v_床号, r_Curlogrow.责任护士, r_Curlogrow.经治医师,
           r_Curlogrow.主治医师, r_Curlogrow.主任医师, r_Curlogrow.病情, 操作员编号_In, 操作员姓名_In);
      
        v_床号串 := Substr(v_床号串, Instr(v_床号串, ',') + 1);
      End Loop;
      --更新病人信息
      Update 病人信息
      Set 出院时间 = Null, 当前病区id = r_Curlogrow.病区id, 当前科室id = r_Curlogrow.科室id, 当前床号 = 主床位_In, 在院 = 1
      Where 病人id = 病人id_In;
    
      --更新在院病人
      Begin
        Update 在院病人 Set 病区id = Nvl(r_Curlogrow.病区id, 0), 科室id = r_Curlogrow.科室id Where 病人id = 病人id_In;
        If Sql%RowCount = 0 Then
          Insert Into 在院病人
            (病人id, 科室id, 病区id, 主页id)
          Values
            (病人id_In, r_Curlogrow.科室id, Nvl(r_Curlogrow.病区id, 0), Nvl(主页id_In, 0));
        End If;
      Exception
        When Others Then
          Null;
      End;
    
      --更新病案主页出院病床
      Update 病案主页 Set 出院病床 = 主床位_In Where 病人id = 病人id_In And 主页id = 主页id_In;
      Close c_Curlog;
    End If;
    --删除出院诊断 保留该诊断信息
    --Delete From 病人诊断记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 诊断类型 in (3,13) And 记录来源 = 2;
  
    Begin
      Select 共享号 Into v_共享号 From zlSystems Where Floor(编号 / 100) = 3;
    Exception
      When Others Then
        Null;
    End;
    --删除该病人的随诊记录
    If v_共享号 = 100 Then
      Execute Immediate 'Delete From 随诊记录 Where 病人id =:1 And 主页id =:2'
        Using 病人id_In, 主页id_In;
    End If;
  Elsif r_Curlogrow.开始原因 = 1 And v_撤销方式 = '入院入住' Then
    v_Error := Checkpatiadvice(病人id_In, 主页id_In, 撤销方式_In);
    If v_Error Is Not Null Then
      Raise Err_Custom;
    End If;
    --撤消入科(入院同时入科)
    v_开始时间 := r_Curlogrow.开始时间;
    Select Zl_住院日报_Count(r_Curlogrow.科室id, v_开始时间) Into v_Count From Dual;
    If v_Count > 0 Then
      v_Error := '[ZLSOFT]已产生业务时间内的住院日报,不能办理该业务![ZLSOFT]';
      Raise Err_Custom;
    End If;
  
    Select Count(1)
    Into v_Count
    From 病人护理文件 A, 病人护理数据 B
    Where a.Id = b.文件id And 病人id = 病人id_In And 主页id = 主页id_In And 科室id = r_Curlogrow.科室id And Rownum < 2;
    If v_Count > 0 Then
      v_Error := '[ZLSOFT]病人已产生有数据的护理文件，不能办理该业务！[ZLSOFT]';
      Raise Err_Custom;
    End If;
    Delete From 病人护理文件 Where 病人id = 病人id_In And 主页id = 主页id_In And 科室id = r_Curlogrow.科室id;
  
    Close c_Curlog;
  
    If 数据_In = '1' Then
      For r_Fee In (Select NO
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 登记时间 >= v_开始时间
                    Group By NO, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        v_Error := '[ZLSOFT]该病人的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
    --退除当前床位
    For r_Curlogrow In c_Curlog Loop
      If r_Curlogrow.床号 Is Not Null Then
        Update 床位状况记录
        Set 状态 = '空床', 病人id = Null, 科室id = Decode(共用, 1, Null, 科室id)
        Where 病区id = r_Curlogrow.病区id And 床号 = r_Curlogrow.床号;
      End If;
    End Loop;
    --相关信息还原
    Update 病案主页 Set 入院病床 = Null, 出院病床 = Null, 状态 = 1 Where 病人id = 病人id_In And 主页id = 主页id_In;
  
    Update 病人信息 Set 当前床号 = Null Where 病人id = 病人id_In;
  
    --恢复变动(入院同时入科不会有包床)
    --因为是同一条记录中的撤消,所以不处理人员
    Update 病人变动记录
    Set 床位等级id = Null, 床号 = Null, 责任护士 = Null, 经治医师 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 1 And 终止时间 Is Null;
  Elsif r_Curlogrow.开始原因 = 2 And v_撤销方式 = '入住' Then
    v_Error := Checkpatiadvice(病人id_In, 主页id_In, 撤销方式_In);
    If v_Error Is Not Null Then
      Raise Err_Custom;
    End If;
    --撤消入院入科
    v_开始时间 := r_Curlogrow.开始时间;
    Select Zl_住院日报_Count(r_Curlogrow.科室id, v_开始时间) Into v_Count From Dual;
    If v_Count > 0 Then
      v_Error := '[ZLSOFT]已产生业务时间内的住院日报,不能办理该业务![ZLSOFT]';
      Raise Err_Custom;
    End If;
  
    Select Count(1)
    Into v_Count
    From 病人护理文件 A, 病人护理数据 B
    Where a.Id = b.文件id And 病人id = 病人id_In And 主页id = 主页id_In And 科室id = r_Curlogrow.科室id And Rownum < 2;
    If v_Count > 0 Then
      v_Error := '[ZLSOFT]病人已产生有数据的护理文件，不能办理该业务！[ZLSOFT]';
      Raise Err_Custom;
    End If;
    Delete From 病人护理文件 Where 病人id = 病人id_In And 主页id = 主页id_In And 科室id = r_Curlogrow.科室id;
  
    If 数据_In = '1' Then
      For r_Fee In (Select NO
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 登记时间 >= v_开始时间
                    Group By NO, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        v_Error := '[ZLSOFT]该病人的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
    --删除病历书写时机
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '入院', r_Curlogrow.科室id);
    Close c_Curlog;
    --退除当前床位
    For r_Curlogrow In c_Curlog Loop
      If r_Curlogrow.床号 Is Not Null Then
        Update 床位状况记录
        Set 状态 = '空床', 病人id = Null, 科室id = Decode(共用, 1, Null, 科室id)
        Where 病区id = r_Curlogrow.病区id And 床号 = r_Curlogrow.床号;
      End If;
    End Loop;
    --相关信息还原
    Open c_Prelog(v_开始时间, 2);
    Fetch c_Prelog
      Into r_Prelogrow;
    Update 病案主页
    Set 入院病床 = Null, 出院病床 = Null, 状态 = 1, 当前病况 = r_Prelogrow.病情, 入院病况 = r_Prelogrow.病情, 医疗小组id = r_Prelogrow.医疗小组id,
        护理等级id = r_Prelogrow.护理等级id
    Where 病人id = 病人id_In And 主页id = 主页id_In;
    Close c_Prelog;
  
    Update 病人信息 Set 当前床号 = Null Where 病人id = 病人id_In;
    Delete 病案主页从表
    Where 病人id = 病人id_In And 主页id = 主页id_In And (信息名 = '主治医师' Or 信息名 = '主任医师');
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 2 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 2 And 终止时间 = v_开始时间;
  Elsif r_Curlogrow.开始原因 = 3 And v_撤销方式 = '转科入住' Then
    --撤消转科入科
    v_开始时间 := r_Curlogrow.开始时间;
    Select Zl_住院日报_Count(r_Curlogrow.科室id, v_开始时间) Into v_Count From Dual;
    If v_Count > 0 Then
      v_Error := '[ZLSOFT]已产生业务时间内的住院日报,不能办理该业务![ZLSOFT]';
      Raise Err_Custom;
    End If;
  
    Select Count(1)
    Into v_Count
    From 病人护理文件
    Where 病人id = 病人id_In And 主页id = 主页id_In And 科室id = r_Curlogrow.科室id And 创建时间 >= r_Curlogrow.开始时间;
    If v_Count > 0 Then
      v_Error := '[ZLSOFT]病人已产生护理文件，不能办理该业务！[ZLSOFT]';
      Raise Err_Custom;
    End If;
  
    If 数据_In = '1' Then
      For r_Fee In (Select NO
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 登记时间 >= v_开始时间
                    Group By NO, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        v_Error := '[ZLSOFT]该病人的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
  
    --删除病历书写时机
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '转科', r_Curlogrow.科室id);
    Close c_Curlog;
    --退除当前床位
    For r_Curlogrow In c_Curlog Loop
      If r_Curlogrow.床号 Is Not Null Then
        Update 床位状况记录
        Set 状态 = '空床', 病人id = Null, 科室id = Decode(共用, 1, Null, 科室id)
        Where 病区id = r_Curlogrow.病区id And 床号 = r_Curlogrow.床号;
      End If;
    End Loop;
    --检查及还原原床位
    For r_Prelogrow In c_Prelog(v_开始时间, 3) Loop
      d_开始时间 := r_Prelogrow.开始时间;
      If r_Prelogrow.床号 Is Not Null Then
        Select Count(*)
        Into v_Count
        From 床位状况记录
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号 And 状态 = '空床';
        If v_Count = 0 Then
          v_Error := '[ZLSOFT]病人转入该科室前的床位 ' || r_Prelogrow.床号 || ' 当前非空床或已经撤消！[ZLSOFT]';
          Raise Err_Custom;
        End If;
      
        Update 床位状况记录
        Set 状态 = '占用', 病人id = 病人id_In, 等级id = r_Prelogrow.床位等级id, 科室id = r_Prelogrow.科室id --强行恢复以前的科室,共用床也不用处理了。
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号;
      End If;
      --相关信息还原
      If Nvl(r_Prelogrow.附加床位, 0) = 0 Then
        --判断是否有婴儿
        Select Count(1) Into v_Count From 病人新生儿记录 Where 病人id = 病人id_In And 主页id = 主页id_In;
        If v_Count > 0 Then
          Select 母婴转科标志 Into v_母婴转科标志 From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
          If v_母婴转科标志 Is Not Null Then
            If Substr(v_母婴转科标志, Length(v_母婴转科标志)) = '1' Then
              --如果是1表示母亲和婴儿未分开，则清空“病案主页.婴儿科室ID”和”病案主页.婴儿病区ID”；
              Update 病案主页 Set 婴儿科室id = Null, 婴儿病区id = Null Where 病人id = 病人id_In And 主页id = 主页id_In;
              If Length(v_母婴转科标志) > 1 Then
                v_母婴转科标志 := Substr(v_母婴转科标志, 1, Length(v_母婴转科标志) - 1);
              Else
                v_母婴转科标志 := '';
              End If;
            Else
              --如果是0，表示是上次转科是母亲单独转走的，则重新将原产科科室和病区填写到“病案主页.婴儿科室ID”和”病案主页.婴儿病区ID”（从病人变动记录中取），并清除最后一位标识
              If Length(v_母婴转科标志) > 1 Then
                v_母婴转科标志 := Substr(v_母婴转科标志, 1, Length(v_母婴转科标志) - 1);
                --查看上一次转科的标识
                If Substr(v_母婴转科标志, Length(v_母婴转科标志)) = '1' Then
                  Update 病案主页
                  Set 婴儿科室id = Null, 婴儿病区id = Null
                  Where 病人id = 病人id_In And 主页id = 主页id_In;
                Else
                  --取出转科前的婴儿科室病区ID
                  v_Tmp   := v_母婴转科标志;
                  v_Count := 1;
                  While v_Tmp Is Not Null Loop
                    v_Count := v_Count + 1;
                    If Substr(v_Tmp, Length(v_Tmp)) = '1' Then
                      Select Max(a.科室id) As 科室id, Max(a.病区id) As 科室id
                      Into n_原科室id, n_原病区id
                      From (Select 科室id, 病区id, Rownum As 序号
                             From (Select 科室id, 病区id
                                    From 病人变动记录
                                    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 3 And 附加床位 = 0
                                    Order By 开始时间 Desc)) A
                      Where 序号 = v_Count;
                    End If;
                    If Length(v_Tmp) = 1 Then
                      v_Tmp := '';
                    Else
                      v_Tmp := Substr(v_Tmp, 1, Length(v_Tmp) - 1);
                    End If;
                  End Loop;
                  If Nvl(n_原科室id, 0) = 0 Then
                    --如果没有找到，则取入院科室
                    Select Max(b.科室id), Max(b.病区id)
                    Into n_原科室id, n_原病区id
                    From 病人变动记录 B
                    Where b.病人id = 病人id_In And b.主页id = 主页id_In And b.科室id Is Not Null And b.病区id Is Not Null And
                          b.开始时间 = (Select Min(a.开始时间)
                                    From 病人变动记录 A
                                    Where a.病人id = b.病人id And a.主页id = b.主页id And a.科室id Is Not Null And
                                          a.病区id Is Not Null And a.附加床位 = 0);
                  End If;
                
                  If Nvl(n_原科室id, 0) <> 0 Then
                    Update 病案主页
                    Set 婴儿科室id = n_原科室id, 婴儿病区id = n_原病区id
                    Where 病人id = 病人id_In And 主页id = 主页id_In;
                  Else
                    --之前没有转科记录,清空婴儿科室ID和婴儿病区ID
                    Update 病案主页
                    Set 婴儿科室id = Null, 婴儿病区id = Null
                    Where 病人id = 病人id_In And 主页id = 主页id_In;
                  End If;
                End If;
              Else
                --只有这一次转科,回退后清空婴儿科室病区ID
                v_母婴转科标志 := '';
                Update 病案主页
                Set 婴儿科室id = Null, 婴儿病区id = Null
                Where 病人id = 病人id_In And 主页id = 主页id_In;
              End If;
            End If;
            --去除最后一位标识
            Update 病案主页 Set 母婴转科标志 = v_母婴转科标志 Where 病人id = 病人id_In And 主页id = 主页id_In;
          End If;
        
        End If;
      
        Update 病案主页
        Set 状态 = 2, 当前病区id = r_Prelogrow.病区id, 出院科室id = r_Prelogrow.科室id, 医疗小组id = r_Prelogrow.医疗小组id,
            出院病床 = r_Prelogrow.床号, 护理等级id = r_Prelogrow.护理等级id, 责任护士 = r_Prelogrow.责任护士, 住院医师 = r_Prelogrow.经治医师,
            当前病况 = r_Curlogrow.病情
        Where 病人id = 病人id_In And 主页id = 主页id_In;
      
        Update 病案主页从表
        Set 信息值 = r_Prelogrow.主治医师
        Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主治医师';
        Update 病案主页从表
        Set 信息值 = r_Prelogrow.主任医师
        Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主任医师';
      
        Update 病人信息
        Set 当前病区id = r_Prelogrow.病区id, 当前科室id = r_Prelogrow.科室id, 当前床号 = r_Prelogrow.床号
        Where 病人id = 病人id_In;
      
        --更新在院病人
        Update 在院病人 Set 病区id = Nvl(r_Prelogrow.病区id, 0), 科室id = r_Prelogrow.科室id Where 病人id = 病人id_In;
      
      End If;
    End Loop;
    --恢复变动(恢复到临时转科标记状态)
    Delete From 病人变动记录
    Where 附加床位 = 1 And 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 3 And 终止时间 Is Null;
  
    Select 终止人员
    Into v_终止人员
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 3 And 终止时间 = v_开始时间 And Nvl(附加床位, 0) = 0;
    --临时记录的操作员信息记录的是终止人员,因为没有记录终止人员编号,就不恢复
    Update 病人变动记录
    Set 开始时间 = Null, 医疗小组id = Null, 护理等级id = Null, 床位等级id = Null, 床号 = Null, 责任护士 = Null, 经治医师 = Null, 操作员编号 = Null,
        操作员姓名 = v_终止人员, 上次计算时间 = Null, 病区id = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 3 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 3 And 终止时间 = v_开始时间 And 开始时间 = d_开始时间;
  
  Elsif r_Curlogrow.开始原因 = 4 And v_撤销方式 = '换床' Then
    --撤消换床
    v_开始时间 := r_Curlogrow.开始时间;
    Close c_Curlog;
    If 数据_In = '1' Then
      For r_Fee In (Select NO
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 登记时间 >= v_开始时间
                    Group By NO, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        v_Error := '[ZLSOFT]该病人的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
    --退除当前床位
    For r_Curlogrow In c_Curlog Loop
      If r_Curlogrow.床号 Is Not Null Then
        Update 床位状况记录
        Set 状态 = '空床', 病人id = Null, 科室id = Decode(共用, 1, Null, 科室id)
        Where 病区id = r_Curlogrow.病区id And 床号 = r_Curlogrow.床号;
      End If;
    End Loop;
    --检查及还原原床位
    For r_Prelogrow In c_Prelog(v_开始时间, 4) Loop
      d_开始时间 := r_Prelogrow.开始时间;
      If r_Prelogrow.床号 Is Not Null Then
        Select Count(*)
        Into v_Count
        From 床位状况记录
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号 And 状态 = '空床';
        If v_Count = 0 Then
          v_Error := '[ZLSOFT]病人最近一次换床前所入住的床位 ' || r_Prelogrow.床号 || ' 当前非空床或已经撤消！[ZLSOFT]';
          Raise Err_Custom;
        End If;
      
        Update 床位状况记录
        Set 状态 = '占用', 病人id = 病人id_In, 等级id = r_Prelogrow.床位等级id, 科室id = Decode(共用, 1, r_Prelogrow.科室id, 科室id)
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号;
      End If;
      --病人信息、病案主页,仅当病区与科室独立时,换床才可以换病区,此处为简化判断,统一还原病区
      If Nvl(r_Prelogrow.附加床位, 0) = 0 Then
        Update 病案主页
        Set 出院病床 = r_Prelogrow.床号, 当前病区id = r_Prelogrow.病区id
        Where 病人id = 病人id_In And 主页id = 主页id_In;
      
        Update 病人信息 Set 当前床号 = r_Prelogrow.床号, 当前病区id = r_Prelogrow.病区id Where 病人id = 病人id_In;
        --更新在院病人
        Update 在院病人 Set 病区id = Nvl(r_Prelogrow.病区id, 0) Where 病人id = 病人id_In;
      End If;
    End Loop;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 4 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 4 And 终止时间 = v_开始时间 And 开始时间 = d_开始时间;
  Elsif r_Curlogrow.开始原因 = 4 And v_撤销方式 = '床位对换' Then
    --撤消床位对换
    v_开始时间 := r_Curlogrow.开始时间;
    Select 姓名 Into v_姓名 From 病人信息 Where 病人id = 病人id_In;
    Close c_Curlog;
    If 数据_In = '1' Then
      For r_Fee In (Select NO
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 登记时间 >= v_开始时间
                    Group By NO, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        v_Error := '[ZLSOFT]病人 ' || v_姓名 || ' 的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
    --退除当前床位
    --检查及还原原床位
    For r_Prelogrow In c_Prelog(v_开始时间, 4) Loop
      d_开始时间 := r_Prelogrow.开始时间;
      If r_Prelogrow.床号 Is Not Null Then
        Update 床位状况记录
        Set 状态 = '占用', 病人id = 病人id_In, 等级id = r_Prelogrow.床位等级id, 科室id = Decode(共用, 1, r_Prelogrow.科室id, 科室id)
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号;
      End If;
      --病人信息、病案主页,仅当病区与科室独立时,换床才可以换病区,此处为简化判断,统一还原病区
      If Nvl(r_Prelogrow.附加床位, 0) = 0 Then
        Update 病案主页
        Set 出院病床 = r_Prelogrow.床号, 当前病区id = r_Prelogrow.病区id
        Where 病人id = 病人id_In And 主页id = 主页id_In;
      
        Update 病人信息 Set 当前床号 = r_Prelogrow.床号, 当前病区id = r_Prelogrow.病区id Where 病人id = 病人id_In;
        --更新在院病人
        Update 在院病人 Set 病区id = Nvl(r_Prelogrow.病区id, 0) Where 病人id = 病人id_In;
      End If;
    End Loop;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 4 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 4 And 终止时间 = v_开始时间 And 开始时间 = d_开始时间;
  Elsif r_Curlogrow.开始原因 = 5 And v_撤销方式 = '床位等级变动' Then
    --撤消床位等级变动
    If 数据_In = '1' Then
      For r_Fee In (Select NO
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 收费细目id = r_Curlogrow.床位等级id And
                          登记时间 >= r_Curlogrow.开始时间
                    Group By NO, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        Close c_Curlog;
        v_Error := '[ZLSOFT]该病人的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
    --还原原床位的等级
    For r_Prelogrow In c_Prelog(r_Curlogrow.开始时间, 5) Loop
      d_开始时间 := r_Prelogrow.开始时间;
      If r_Prelogrow.床号 Is Not Null Then
        Update 床位状况记录
        Set 等级id = r_Prelogrow.床位等级id
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号;
      End If;
    End Loop;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 5 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 5 And 终止时间 = r_Curlogrow.开始时间 And 开始时间 = d_开始时间;
  
    Close c_Curlog;
  Elsif r_Curlogrow.开始原因 = 6 And v_撤销方式 = '护理等级变动' Then
    --撤消护理等级变动
    If 数据_In = '1' Then
      For r_Fee In (Select NO
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 收费细目id = r_Curlogrow.护理等级id And
                          登记时间 >= r_Curlogrow.开始时间
                    Group By NO, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        Close c_Curlog;
        v_Error := '[ZLSOFT]该病人的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
  
    Open c_Prelog(r_Curlogrow.开始时间, 6);
    Fetch c_Prelog
      Into r_Prelogrow;
    --恢复原护理等级
    Update 病案主页 Set 护理等级id = r_Prelogrow.护理等级id Where 病人id = 病人id_In And 主页id = 主页id_In;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 6 And 终止时间 Is Null;
  
    --医嘱产生的护理等级变动没有记录秒，可能前一等级的停止时间与当前等级的开始时间是同一分钟，所以要取max(id)
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 6 And 终止时间 = r_Curlogrow.开始时间 And 开始时间 = r_Prelogrow.开始时间;
  
    Close c_Prelog;
    Close c_Curlog;
  Elsif r_Curlogrow.开始原因 = 7 And v_撤销方式 = '经治医师改变' Then
    --删除病历书写时机
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '交班', r_Curlogrow.科室id);
    --撤消经治医师改变
    Open c_Prelog(r_Curlogrow.开始时间, 7);
    Fetch c_Prelog
      Into r_Prelogrow;
    --恢复原医师
    Update 病案主页 Set 住院医师 = r_Prelogrow.经治医师 Where 病人id = 病人id_In And 主页id = 主页id_In;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 7 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 7 And 终止时间 = r_Curlogrow.开始时间 And 开始时间 = r_Prelogrow.开始时间;
  
    Close c_Prelog;
    Close c_Curlog;
  Elsif r_Curlogrow.开始原因 = 8 And v_撤销方式 = '责任护士改变' Then
    --撤消责任护士改变
    Open c_Prelog(r_Curlogrow.开始时间, 8);
    Fetch c_Prelog
      Into r_Prelogrow;
    --恢复原责任护士
    Update 病案主页 Set 责任护士 = r_Prelogrow.责任护士 Where 病人id = 病人id_In And 主页id = 主页id_In;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 8 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 8 And 终止时间 = r_Curlogrow.开始时间 And 开始时间 = r_Prelogrow.开始时间;
  
    Close c_Prelog;
    Close c_Curlog;
  Elsif r_Curlogrow.开始原因 = 9 And v_撤销方式 = '转为住院病人' Then
    --撤消转为住院病人
    --删除病历书写时机
    Open c_Prelog(r_Curlogrow.开始时间, 9);
    Fetch c_Prelog
      Into r_Prelogrow;
  
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '入院', r_Curlogrow.科室id);
    Update 病案主页 Set 病人性质 = 2 Where 病人id = 病人id_In And 主页id = 主页id_In;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 9 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 9 And 终止时间 = r_Curlogrow.开始时间 And 开始时间 = r_Prelogrow.开始时间;
  
    If 主页id_In = 1 And Nvl(数据_In, '0') = '1' Then
      Update 病人信息 Set 住院号 = Null Where 病人id = 病人id_In;
      Update 病案主页 Set 住院号 = Null Where 病人id = 病人id_In;
    End If;
  
    Close c_Curlog;
    Close c_Prelog;
  Elsif r_Curlogrow.开始原因 = 10 And v_撤销方式 = '预出院' Then
    --撤消预出院
    --删除病历书写时机
    Open c_Prelog(r_Curlogrow.开始时间, 10);
    Fetch c_Prelog
      Into r_Prelogrow;
  
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '出院', r_Curlogrow.科室id);
    --恢复住院状态
    Update 病案主页 Set 状态 = 0 Where 病人id = 病人id_In And 主页id = 主页id_In;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 10 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 上次计算时间 = Null, 终止人员 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 10 And 终止时间 = r_Curlogrow.开始时间 And 开始时间 = r_Prelogrow.开始时间;
  
    Close c_Curlog;
    Close c_Prelog;
  Elsif r_Curlogrow.开始原因 = 11 And v_撤销方式 = '主治医师变动' Then
    --撤消主治医师改变
    Open c_Prelog(r_Curlogrow.开始时间, 11);
    Fetch c_Prelog
      Into r_Prelogrow;
    --恢复原主治医师
    Update 病案主页从表
    Set 信息值 = r_Prelogrow.主治医师
    Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主治医师';
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 11 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 11 And 终止时间 = r_Curlogrow.开始时间 And 开始时间 = r_Prelogrow.开始时间;
  
    Close c_Prelog;
    Close c_Curlog;
  Elsif r_Curlogrow.开始原因 = 12 And v_撤销方式 = '主任医师变动' Then
    --撤消主任医师改变
    Open c_Prelog(r_Curlogrow.开始时间, 12);
    Fetch c_Prelog
      Into r_Prelogrow;
    --恢复原主任医师
    Update 病案主页从表
    Set 信息值 = r_Prelogrow.主任医师
    Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主任医师';
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 12 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 12 And 终止时间 = r_Curlogrow.开始时间 And 开始时间 = r_Prelogrow.开始时间;
  
    Close c_Prelog;
    Close c_Curlog;
  Elsif r_Curlogrow.开始原因 = 13 And v_撤销方式 = '病况变动' Then
    --撤消病情改变
    Open c_Prelog(r_Curlogrow.开始时间, 13);
    Fetch c_Prelog
      Into r_Prelogrow;
    --恢复原病情
    Update 病案主页 Set 当前病况 = r_Prelogrow.病情 Where 病人id = 病人id_In And 主页id = 主页id_In;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 13 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 13 And 终止时间 = r_Curlogrow.开始时间 And 开始时间 = r_Prelogrow.开始时间;
  
    Close c_Prelog;
    Close c_Curlog;
  
  Elsif r_Curlogrow.开始原因 = 14 And v_撤销方式 = '转医疗小组' Then
    --删除病历书写时机
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '交班', r_Curlogrow.科室id);
  
    --撤消医疗小组改变
    Open c_Prelog(r_Curlogrow.开始时间, 14);
    Fetch c_Prelog
      Into r_Prelogrow;
    --恢复原医疗小组
    Update 病案主页
    Set 医疗小组id = r_Prelogrow.医疗小组id, 住院医师 = r_Prelogrow.经治医师
    Where 病人id = 病人id_In And 主页id = 主页id_In;
    --恢复原主治医师
    Update 病案主页从表
    Set 信息值 = r_Prelogrow.主治医师
    Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主治医师';
  
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 14 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 14 And 终止时间 = r_Curlogrow.开始时间 And 开始时间 = r_Prelogrow.开始时间;
  
    Close c_Prelog;
    Close c_Curlog;
  Elsif r_Curlogrow.开始原因 = 15 And v_撤销方式 = '转病区入住' Then
    --撤消入病区
    v_开始时间 := r_Curlogrow.开始时间;
  
    If 数据_In = '1' Then
      For r_Fee In (Select NO
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 登记时间 >= v_开始时间
                    Group By NO, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        v_Error := '[ZLSOFT]该病人的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
  
    Open c_Prelog(v_开始时间, 15);
    Fetch c_Prelog
      Into r_Prelogrow;
  
    d_开始时间 := r_Prelogrow.开始时间;
    --对有效的医嘱(未停止、作废的长嘱，未发送的临嘱)，为原病区执行的，将执行科室自动更换为新的病区
    Update 病人医嘱记录
    Set 执行科室id = r_Prelogrow.病区id
    Where 病人id = 病人id_In And 主页id = 主页id_In And 执行科室id = r_Curlogrow.病区id And 医嘱状态 Not In (4, 8, 9) And 开嘱时间 < v_开始时间;
    --对未审核的记帐划价单，为原病区执行的，将执行科室自动更换为新的病区
    Update 住院费用记录
    Set 执行部门id = r_Prelogrow.病区id
    Where 病人id = 病人id_In And 主页id = 主页id_In And 执行部门id = r_Curlogrow.病区id And 记录状态 = 0;
    Close c_Prelog;
    Close c_Curlog;
  
    --退除当前床位
    For r_Curlogrow In c_Curlog Loop
      If r_Curlogrow.床号 Is Not Null Then
        Update 床位状况记录
        Set 状态 = '空床', 病人id = Null, 科室id = Decode(共用, 1, Null, 科室id)
        Where 病区id = r_Curlogrow.病区id And 床号 = r_Curlogrow.床号;
      End If;
    End Loop;
    --检查及还原原床位
    For r_Prelogrow In c_Prelog(v_开始时间, 15) Loop
      If r_Prelogrow.床号 Is Not Null Then
        Select Count(*)
        Into v_Count
        From 床位状况记录
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号 And 状态 = '空床';
        If v_Count = 0 Then
          v_Error := '[ZLSOFT]病人转入该病区前的床位 ' || r_Prelogrow.床号 || ' 当前非空床或已经撤消！[ZLSOFT]';
          Raise Err_Custom;
        End If;
      
        Update 床位状况记录
        Set 状态 = '占用', 病人id = 病人id_In, 等级id = r_Prelogrow.床位等级id, 科室id = r_Prelogrow.科室id --强行恢复以前的科室,共用床也不用处理了。
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号;
      End If;
      --相关信息还原
      If Nvl(r_Prelogrow.附加床位, 0) = 0 Then
        Update 病案主页
        Set 状态 = 2, 当前病区id = r_Prelogrow.病区id, 出院科室id = r_Prelogrow.科室id, 医疗小组id = r_Prelogrow.医疗小组id,
            出院病床 = r_Prelogrow.床号, 护理等级id = r_Prelogrow.护理等级id, 责任护士 = r_Prelogrow.责任护士, 住院医师 = r_Prelogrow.经治医师,
            当前病况 = r_Curlogrow.病情
        Where 病人id = 病人id_In And 主页id = 主页id_In;
      
        Update 病人信息 Set 当前病区id = r_Prelogrow.病区id, 当前床号 = r_Prelogrow.床号 Where 病人id = 病人id_In;
      
        --更新在院病人
        Update 在院病人 Set 病区id = Nvl(r_Prelogrow.病区id, 0) Where 病人id = 病人id_In;
      
      End If;
    End Loop;
  
    --恢复变动(恢复到临时转科标记状态)
    Delete From 病人变动记录
    Where 附加床位 = 1 And 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 15 And 终止时间 Is Null;
  
    Select 终止人员
    Into v_终止人员
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 15 And 终止时间 = v_开始时间 And Nvl(附加床位, 0) = 0;
    --临时记录的操作员信息记录的是终止人员,因为没有记录终止人员编号,就不恢复
    Update 病人变动记录
    Set 开始时间 = Null, 医疗小组id = Null, 护理等级id = Null, 床位等级id = Null, 床号 = Null, 责任护士 = Null, 经治医师 = Null, 操作员编号 = Null,
        操作员姓名 = v_终止人员, 上次计算时间 = Null, 附加床位 = Null, 主治医师 = Null, 病情 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 15 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 15 And 终止时间 = v_开始时间 And 开始时间 = d_开始时间;
  Else
    Close c_Curlog;
    v_Error := '[ZLSOFT]你执行的撤销' || v_撤销方式 || '操作已经被其他人执行,请刷新界面！[ZLSOFT]';
    Raise Err_Custom;
  End If;
  --并发操作检查
  Select Count(*)
  Into v_Count
  From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(附加床位, 0) = 0 And 开始时间 Is Not Null And 终止时间 Is Null;
  If v_Count > 1 Then
    v_Error := '发现病人存在非法的变动记录,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;

  Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In And 出院日期 Is Null;
  If v_Count = 0 Then
    v_Error := '操作失败,该病人已出院,不能进行当前操作' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态！';
    Raise Err_Custom;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, v_Error);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人变动记录_Undo;
/

--105249:刘尔旋,2017-01-22,新挂号安排调整挂号收费项目关联修改
Create Or Replace Procedure Zl_病人挂号汇总_Update
(
  医生姓名_In   挂号安排.医生姓名%Type,
  医生id_In     挂号安排.医生id%Type,
  收费细目id_In 门诊费用记录.收费细目id%Type,
  执行部门id_In 门诊费用记录.执行部门id%Type,
  发生时间_In   门诊费用记录.发生时间%Type,
  预约标志_In   Number := 0, --是否为预约接收:0-非预约挂号; 1-预约挂号,2-预约接收;3-收费预约
  号码_In       挂号安排.号码%Type := Null,
  三方调用_In   Number := 0, --是否接口调用
  出诊记录id_In 临床出诊记录.Id%Type := Null
) As
  --发生时间_In:预约时,为预约时间;否则为登记时间
  v_Date    Date;
  n_预约数  病人挂号汇总.已约数%Type;
  n_时段    Number := 0;
  v_Err_Msg Varchar2(255);
  Err_Item Exception;
  n_接收模式     Number := 0;
  n_号源id       临床出诊记录.号源id%Type;
  n_新出诊记录id 临床出诊记录.Id%Type;
  n_旧分时段     临床出诊记录.是否分时段%Type;
  n_旧序号控制   临床出诊记录.是否序号控制%Type;
  n_旧医生id     临床出诊记录.医生id%Type;
  v_旧上班时段   临床出诊记录.上班时段%Type;
  n_旧科室id     临床出诊记录.科室id%Type;
Begin
  If 出诊记录id_In Is Null Then
    Begin
      Select 1
      Into n_时段
      From Dual
      Where Exists (Select 1
             From 挂号安排时段 A, 挂号安排 B
             Where a.安排id = b.Id And b.号码 = 号码_In And Rownum <= 1
             Union All
             Select 1
             From 挂号计划时段 C, 挂号安排计划 D 　
             Where c.计划id = d.Id And d.号码 = 号码_In And d.生效时间 > Sysdate And Rownum <= 1);
    Exception
      When Others Then
        n_时段 := 0;
    End;
    n_接收模式 := Nvl(zl_GetSysParameter('预约接收模式', 1111), 0);
    --分时段的号别，只能当天接收
    If n_时段 = 1 And Nvl(预约标志_In, 0) = 2 And 三方调用_In = 0 And n_接收模式 = 0 Then
      If Trunc(发生时间_In) <> Trunc(Sysdate) Then
        v_Err_Msg := '分时段的预约挂号单只能当天接收！';
        Raise Err_Item;
      End If;
    End If;
    If Nvl(预约标志_In, 0) <> 2 Or 三方调用_In = 1 Then
      v_Date := Trunc(发生时间_In);
    Else
      If n_接收模式 = 0 Then
        v_Date := Trunc(Sysdate);
      Else
        v_Date := Trunc(发生时间_In);
      End If;
    End If;
  
    n_预约数 := 0;
    If Nvl(预约标志_In, 0) <> 1 Then
      --非预约挂号;或预约接收
      If Nvl(预约标志_In, 0) = 2 And v_Date <> Trunc(发生时间_In) Then
        --1.减去预约日期的预约数;
        --2-加上当前预约日期的挂号数;
        Update 病人挂号汇总
        Set 已约数 = Nvl(已约数, 0) - 1
        Where 日期 = Trunc(发生时间_In) And Nvl(科室id, 0) = 执行部门id_In And Nvl(项目id, 0) = 收费细目id_In And
              (号码 = 号码_In Or 号码 Is Null)
        Returning 已约数 Into n_预约数;
      
        If n_预约数 < 0 Then
          Update 病人挂号汇总
          Set 已约数 = 0
          Where 日期 = Trunc(发生时间_In) And Nvl(科室id, 0) = 执行部门id_In And Nvl(项目id, 0) = 收费细目id_In And
                (号码 = 号码_In Or 号码 Is Null)
          Returning 已约数 Into n_预约数;
        End If;
        n_预约数 := 1;
      Elsif Nvl(预约标志_In, 0) = 3 Then
        n_预约数 := 1;
      End If;
      Update 病人挂号汇总
      Set 已挂数 = Nvl(已挂数, 0) + 1, 其中已接收 = Nvl(其中已接收, 0) + Decode(预约标志_In, 0, 0, 1), 已约数 = Nvl(已约数, 0) + Nvl(n_预约数, 0)
      Where 日期 = Decode(预约标志_In, 2, Trunc(v_Date), Trunc(发生时间_In)) And Nvl(科室id, 0) = 执行部门id_In And
            Nvl(项目id, 0) = 收费细目id_In And (号码 = 号码_In Or 号码 Is Null);
      If Sql%RowCount = 0 Then
        Insert Into 病人挂号汇总
          (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 已约数, 其中已接收)
        Values
          (Decode(预约标志_In, 2, Trunc(v_Date), Trunc(发生时间_In)), 执行部门id_In, 收费细目id_In, 医生姓名_In,
           Decode(医生id_In, 0, Null, 医生id_In), 号码_In, 1, Nvl(n_预约数, 0), Decode(预约标志_In, 0, 0, 1));
      End If;
    Else
      --预约挂号
      Update 病人挂号汇总
      Set 已约数 = Nvl(已约数, 0) + 1
      Where 日期 = Trunc(v_Date) And Nvl(科室id, 0) = 执行部门id_In And Nvl(项目id, 0) = 收费细目id_In And (号码 = 号码_In Or 号码 Is Null);
    
      If Sql%RowCount = 0 Then
        Insert Into 病人挂号汇总
          (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已约数)
        Values
          (Trunc(v_Date), 执行部门id_In, 收费细目id_In, 医生姓名_In, Decode(医生id_In, 0, Null, 医生id_In), 号码_In, 1);
      End If;
    End If;
  Else
    --出诊表排班模式
    Begin
      Select Nvl(是否分时段, 0) Into n_时段 From 临床出诊记录 Where ID = 出诊记录id_In;
    Exception
      When Others Then
        n_时段 := 0;
    End;
    Select 号源id Into n_号源id From 临床出诊记录 Where ID = 出诊记录id_In;
    n_接收模式 := Nvl(zl_GetSysParameter('预约接收模式', 1111), 0);
    --分时段的号别，只能当天接收
    If n_时段 = 1 And Nvl(预约标志_In, 0) = 2 And 三方调用_In = 0 And n_接收模式 = 0 Then
      If Trunc(发生时间_In) <> Trunc(Sysdate) Then
        v_Err_Msg := '分时段的预约挂号单只能当天接收！';
        Raise Err_Item;
      End If;
    End If;
    If Nvl(预约标志_In, 0) <> 2 Or 三方调用_In = 1 Then
      v_Date := Trunc(发生时间_In);
    Else
      If n_接收模式 = 0 Then
        v_Date := Trunc(Sysdate);
      Else
        v_Date := Trunc(发生时间_In);
      End If;
    End If;
  
    n_预约数 := 0;
    If Nvl(预约标志_In, 0) <> 1 Then
      --非预约挂号;或预约接收
      If Nvl(预约标志_In, 0) = 2 And v_Date <> Trunc(发生时间_In) Then
        --1.减去预约日期的预约数;
        --2-加上当前预约日期的挂号数;
        Update 临床出诊记录 Set 已约数 = Nvl(已约数, 0) - 1 Where ID = 出诊记录id_In Returning 已约数 Into n_预约数;
        If n_预约数 < 0 Then
          Update 临床出诊记录 Set 已约数 = 0 Where ID = 出诊记录id_In Returning 已约数 Into n_预约数;
        End If;
        Update 病人挂号汇总
        Set 已约数 = Nvl(已约数, 0) - 1
        Where 日期 = Trunc(发生时间_In) And Nvl(医生id, 0) = Nvl(医生id_In, 0) And Nvl(医生姓名, '-') = Nvl(医生姓名_In, '-') And
              Nvl(科室id, 0) = 执行部门id_In And Nvl(项目id, 0) = 收费细目id_In And (号码 = 号码_In Or 号码 Is Null)
        Returning 已约数 Into n_预约数;
        If n_预约数 < 0 Then
          Update 病人挂号汇总
          Set 已约数 = 0
          Where 日期 = Trunc(发生时间_In) And Nvl(医生id, 0) = Nvl(医生id_In, 0) And Nvl(医生姓名, '-') = Nvl(医生姓名_In, '-') And
                Nvl(科室id, 0) = 执行部门id_In And Nvl(项目id, 0) = 收费细目id_In And (号码 = 号码_In Or 号码 Is Null)
          Returning 已约数 Into n_预约数;
        End If;
        n_预约数 := 1;
      Elsif Nvl(预约标志_In, 0) = 3 Then
        n_预约数 := 1;
      End If;
      If Nvl(预约标志_In, 0) = 2 And v_Date <> Trunc(发生时间_In) Then
        Select 是否分时段, 是否序号控制, 科室id, 医生id, 上班时段
        Into n_旧分时段, n_旧序号控制, n_旧科室id, n_旧医生id, v_旧上班时段
        From 临床出诊记录
        Where ID = 出诊记录id_In;
        Begin
          Select ID
          Into n_新出诊记录id
          From 临床出诊记录
          Where 号源id = n_号源id And 是否分时段 = n_旧分时段 And 是否序号控制 = n_旧序号控制 And 科室id = n_旧科室id And
                Nvl(医生id, 0) = Nvl(n_旧医生id, 0) And Nvl(是否发布, 0) = 1 And 出诊日期 = Trunc(Sysdate) And 上班时段 = v_旧上班时段 And
                Rownum < 2;
        Exception
          When Others Then
            v_Err_Msg := '接收当天没有对应的出诊安排,无法接收!';
            Raise Err_Item;
        End;
        Update 临床出诊记录
        Set 已挂数 = Nvl(已挂数, 0) + 1, 其中已接收 = Nvl(其中已接收, 0) + Decode(预约标志_In, 0, 0, 1), 已约数 = Nvl(已约数, 0) + Nvl(n_预约数, 0)
        Where ID = n_新出诊记录id;
      
        Update 病人挂号汇总
        Set 已挂数 = Nvl(已挂数, 0) + 1, 其中已接收 = Nvl(其中已接收, 0) + Decode(预约标志_In, 0, 0, 1), 已约数 = Nvl(已约数, 0) + Nvl(n_预约数, 0)
        Where 日期 = Decode(预约标志_In, 2, Trunc(v_Date), Trunc(发生时间_In)) And Nvl(科室id, 0) = 执行部门id_In And
              Nvl(项目id, 0) = 收费细目id_In And Nvl(医生id, 0) = Nvl(医生id_In, 0) And Nvl(医生姓名, '-') = Nvl(医生姓名_In, '-') And
              (号码 = 号码_In Or 号码 Is Null);
        If Sql%RowCount = 0 Then
          Insert Into 病人挂号汇总
            (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 已约数, 其中已接收)
          Values
            (Decode(预约标志_In, 2, Trunc(v_Date), Trunc(发生时间_In)), 执行部门id_In, 收费细目id_In, 医生姓名_In,
             Decode(医生id_In, 0, Null, 医生id_In), 号码_In, 1, Nvl(n_预约数, 0), Decode(预约标志_In, 0, 0, 1));
        End If;
      Else
        Update 临床出诊记录
        Set 已挂数 = Nvl(已挂数, 0) + 1, 其中已接收 = Nvl(其中已接收, 0) + Decode(预约标志_In, 0, 0, 1), 已约数 = Nvl(已约数, 0) + Nvl(n_预约数, 0)
        Where ID = 出诊记录id_In;
      
        Update 病人挂号汇总
        Set 已挂数 = Nvl(已挂数, 0) + 1, 其中已接收 = Nvl(其中已接收, 0) + Decode(预约标志_In, 0, 0, 1), 已约数 = Nvl(已约数, 0) + Nvl(n_预约数, 0)
        Where 日期 = Decode(预约标志_In, 2, Trunc(v_Date), Trunc(发生时间_In)) And Nvl(科室id, 0) = 执行部门id_In And
              Nvl(项目id, 0) = 收费细目id_In And Nvl(医生id, 0) = Nvl(医生id_In, 0) And Nvl(医生姓名, '-') = Nvl(医生姓名_In, '-') And
              (号码 = 号码_In Or 号码 Is Null);
        If Sql%RowCount = 0 Then
          Insert Into 病人挂号汇总
            (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 已约数, 其中已接收)
          Values
            (Decode(预约标志_In, 2, Trunc(v_Date), Trunc(发生时间_In)), 执行部门id_In, 收费细目id_In, 医生姓名_In,
             Decode(医生id_In, 0, Null, 医生id_In), 号码_In, 1, Nvl(n_预约数, 0), Decode(预约标志_In, 0, 0, 1));
        End If;
      End If;
    Else
      --预约挂号
      Update 临床出诊记录 Set 已约数 = Nvl(已约数, 0) + 1 Where ID = 出诊记录id_In;
      Update 病人挂号汇总
      Set 已约数 = Nvl(已约数, 0) + 1
      Where 日期 = Trunc(v_Date) And Nvl(医生id, 0) = Nvl(医生id_In, 0) And Nvl(医生姓名, '-') = Nvl(医生姓名_In, '-') And
            Nvl(科室id, 0) = 执行部门id_In And Nvl(项目id, 0) = 收费细目id_In And (号码 = 号码_In Or 号码 Is Null);
    
      If Sql%RowCount = 0 Then
        Insert Into 病人挂号汇总
          (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已约数)
        Values
          (Trunc(v_Date), 执行部门id_In, 收费细目id_In, 医生姓名_In, Decode(医生id_In, 0, Null, 医生id_In), 号码_In, 1);
      End If;
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人挂号汇总_Update;
/

--105219:刘尔旋,2017-01-20,结账作废回退多笔消费卡预交问题
Create Or Replace Procedure Zl_病人结帐记录_Delete
(
  No_In           病人结帐记录.No%Type,
  操作员编号_In   病人结帐记录.操作员编号%Type,
  操作员姓名_In   病人结帐记录.操作员姓名%Type,
  误差金额_In     病人预交记录.冲预交%Type := 0, --医保或预交退现金产生的误差
  结帐作废结算_In Varchar2 := Null, --结算方式|结算金额|结算号码||......
  预交退现金_In   Number := 0, --当预交款退现金时，结算方式及金额通过参数结帐作废结算_In传入
  冲销id_In       病人预交记录.结帐id%Type := Null,
  冲销时间_In     Date := Null,
  缴预交id_In     病人预交记录.Id%Type := Null, --在作废时将相关的金额充值到预交款时填写
  票据号_In       病人结帐记录.实际票号%Type := Null,
  领用id_In       票据领用记录.Id%Type := Null,
  票种_In         票据使用明细.票种%Type := Null
) As
  Err_Item Exception;
  v_Err_Msg Varchar2(255);

  --该游标用于预交记录相关信息
  Cursor c_Deposit(v_Id 病人预交记录.结帐id%Type) Is
    Select 病人id, 记录性质, 结算方式, 冲预交, 预交类别 From 病人预交记录 Where 结帐id = v_Id;
  r_Depositrow c_Deposit%RowType;

  --该游标用于处理费用相关汇总表
  Cursor c_Money(v_Id 病人预交记录.结帐id%Type) Is
    Select NO, 开单部门id, 病人科室id, 执行部门id, 病人病区id, 病人id, 主页id, 收入项目id, 门诊标志, 结帐金额
    From 住院费用记录
    Where 结帐id = v_Id
    Union All
    Select NO, 开单部门id, 病人科室id, 执行部门id, 0 As 病人病区id, 病人id, 0 As 主页id, 收入项目id, 门诊标志, 结帐金额
    From 门诊费用记录
    Where 结帐id = v_Id;

  r_Moneyrow c_Money%RowType;

  --该游标包含病人的相关信息
  Cursor c_Pati(n_病人id 病人信息.病人id%Type) Is
    Select a.姓名, a.性别, a.年龄, a.住院号, a.门诊号, b.主页id, b.出院病床, b.当前病区id, b.出院科室id, Nvl(b.费别, a.费别) As 费别, a.险类, c.编码 As 付款方式
    From 病人信息 A, 病案主页 B, 医疗付款方式 C
    Where a.病人id = n_病人id And a.病人id = b.病人id(+) And Nvl(a.主页id, 0) = b.主页id(+) And a.医疗付款方式 = c.名称(+);
  r_Pati c_Pati%RowType;

  --过程变量
  v_结算内容 Varchar2(500);
  v_当前结算 Varchar2(50);
  v_结算方式 病人预交记录.结算方式%Type;
  n_结算金额 病人预交记录.冲预交%Type;
  v_结算号码 病人预交记录.结算号码%Type;
  v_实际票号 病人预交记录.实际票号%Type;
  v_误差no   住院费用记录.No%Type;
  v_误差     结算方式.名称%Type;
  n_病人id   病人信息.病人id%Type;

  n_原id   病人结帐记录.Id%Type;
  n_结帐id 病人结帐记录.Id%Type;
  n_打印id 票据打印内容.Id%Type;

  n_来源     Number; --1-门诊;2-住院;3-门诊和住院
  n_返回值   病人余额.预交余额%Type;
  n_组id     财务缴款分组.Id%Type;
  n_预交类别 Number;
  d_Date     Date;
  n_预交id   病人预交记录.Id%Type;
  n_卡结算id 病人结帐记录.Id%Type;
  v_打印id   票据打印内容.Id%Type;

Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  Select 名称 Into v_误差 From 结算方式 Where 性质 = 9 And Rownum = 1;

  Begin
    Select ID, 病人id, 实际票号 Into n_原id, n_病人id, v_实际票号 From 病人结帐记录 Where 记录状态 = 1 And NO = No_In;
    --最后一次打印的内容
    Select Max(ID)
    Into n_打印id
    From (Select b.Id
           From 票据使用明细 A, 票据打印内容 B
           Where a.打印id = b.Id And a.性质 = 1 And a.原因 In (1, 3) And b.数据性质 = 3 And b.No = No_In
           Order By a.使用时间 Desc)
    Where Rownum < 2;
  Exception
    When Others Then
      Begin
        v_Err_Msg := '没有发现要作废的结帐单据,可能已经作废！';
        Raise Err_Item;
      End;
  End;

  Open c_Pati(n_病人id);
  Fetch c_Pati
    Into r_Pati; --体检系统调用此过程,团体结帐时没有病人信息

  d_Date := 冲销时间_In;
  If d_Date Is Null Then
    Select Sysdate Into d_Date From Dual;
  End If;
  n_结帐id := 冲销id_In;
  If Nvl(n_结帐id, 0) = 0 Then
    Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  End If;

  If 票据号_In Is Not Null Then
    Select 票据打印内容_Id.Nextval Into v_打印id From Dual;
  
    --发出票据
    Insert Into 票据打印内容 (ID, 数据性质, NO) Values (v_打印id, 3, No_In);
  
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
    Values
      (票据使用明细_Id.Nextval, 票种_In, 票据号_In, 1, 6, 领用id_In, v_打印id, d_Date, 操作员姓名_In);
  
    --状态改动
    Update 票据领用记录
    Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
    Where ID = Nvl(领用id_In, 0);
  End If;

  --病人结帐记录
  Insert Into 病人结帐记录
    (ID, NO, 实际票号, 记录状态, 中途结帐, 病人id, 操作员编号, 操作员姓名, 开始日期, 结束日期, 收费时间, 备注, 原因, 缴款组id, 结帐类型)
    Select n_结帐id, NO, 实际票号, 2, 中途结帐, 病人id, 操作员编号_In, 操作员姓名_In, 开始日期, 结束日期, d_Date, 备注, 原因, n_组id, 结帐类型
    From 病人结帐记录
    Where ID = n_原id;

  Update 病人结帐记录 Set 记录状态 = 3 Where ID = n_原id;

  --作废收回票据(可能以前没有使用票据,无法收回)
  If n_打印id Is Not Null Then
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
      Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
      From 票据使用明细
      Where 打印id = n_打印id And 票种 In (1, 3) And 性质 = 1;
  End If;

  --病人预交记录(冲预交及缴款)
  If 结帐作废结算_In Is Null Then
    Insert Into 病人预交记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交, 结帐id,
       缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
      Select 病人预交记录_Id.Nextval, NO, 实际票号, To_Number('1' || Substr(记录性质, Length(记录性质), 1)), 记录状态, 病人id, 主页id, 科室id, Null,
             结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, d_Date, 操作员姓名_In, 操作员编号_In, -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 合作单位, 2
      From 病人预交记录
      Where 结帐id = n_原id And (记录性质 In (1, 11) And Nvl(冲预交, 0) <> 0 Or 记录性质 Not In (1, 11));
  
    --消费卡处理
    For c_消费卡结算 In (Select a.Id, a.结算卡序号, Nvl(b.名称, '消费卡') As 卡名称
                    From 病人预交记录 A, 卡消费接口目录 B
                    Where a.结算卡序号 = b.编号(+) And a.结帐id = n_原id And Nvl(a.结算卡序号, 0) <> 0) Loop
    
      For c_消费卡 In (Select a.Id, a.接口编号, a.消费卡id, a.序号, a.记录状态, a.结算方式, a.结算金额, a.卡号, a.交易流水号, a.交易时间, a.备注, a.结算标志,
                           b.停用日期, b.回收时间
                    From 病人卡结算记录 A, 消费卡目录 B
                    Where a.消费卡id = b.Id(+) And
                          a.Id In (Select 卡结算id From 病人卡结算对照 Where 预交id = c_消费卡结算.Id)) Loop
      
        If Nvl(c_消费卡.停用日期, To_Date('3000-01-01', 'yyyy-mm-dd')) < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || c_消费卡.卡号 || '"的' || c_消费卡结算.卡名称 || '已经被他人停用，不能再进行结帐作废,请检查！';
          Raise Err_Item;
        End If;
      
        If c_消费卡.回收时间 < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || c_消费卡.卡号 || '"的' || c_消费卡结算.卡名称 || '已经回收，不能退费,请检查！';
          Raise Err_Item;
        End If;
        Select 病人卡结算记录_Id.Nextval Into n_卡结算id From Dual;
      
        Insert Into 病人卡结算记录
          (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Values
          (n_卡结算id, c_消费卡结算.结算卡序号, c_消费卡.消费卡id, c_消费卡.序号, 2, c_消费卡.结算方式, -1 * c_消费卡.结算金额, c_消费卡.卡号, c_消费卡.交易流水号, d_Date,
           Null, 0);
      
        Insert Into 病人卡结算对照
          (预交id, 卡结算id)
          Select ID, n_卡结算id
          From 病人预交记录
          Where 结帐id = n_结帐id And 结算卡序号 = Nvl(c_消费卡结算.结算卡序号, 0);
      
        Update 消费卡目录 Set 余额 = 余额 + c_消费卡.结算金额 Where ID = c_消费卡.消费卡id;
        If Sql%NotFound Then
          v_Err_Msg := '卡号为' || c_消费卡.卡号 || '的' || c_消费卡结算.卡名称 || '未找到!';
          Raise Err_Item;
        End If;
      End Loop;
    End Loop;
  
  Else
    --1.先处理冲预交部分
    If 预交退现金_In = 0 Then
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, To_Number('1' || Substr(记录性质, Length(记录性质), 1)), 记录状态, 病人id, 主页id, 科室id,
               Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, d_Date, 操作员姓名_In, 操作员编号_In, -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id,
               结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 2
        From 病人预交记录
        Where 结帐id = n_原id And 记录性质 In (1, 11) And Nvl(冲预交, 0) <> 0;
    End If;
  
    --2.再处理结帐结算,包括医保和非医保
    v_结算内容 := 结帐作废结算_In || ' ||'; --以空格分开以|结尾,没有结算号码的
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_结算号码 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 结算性质)
      Values
        (病人预交记录_Id.Nextval, No_In, v_实际票号, 12, 1, n_病人id, r_Pati.主页id, r_Pati.出院科室id, Null, v_结算方式, v_结算号码, '结帐作废退款',
         Null, Null, Null, d_Date, 操作员姓名_In, 操作员编号_In, -1 * n_结算金额, n_结帐id, n_组id, 2);
    
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;
  --确定结帐的费用记录来源
  Begin
    Select Case
             When Nvl(Max(住院), 0) = 1 And Nvl(Max(门诊), 0) = 1 Then
              3
             When Nvl(Max(住院), 0) = 1 Then
              2
             Else
              1
           End
    Into n_来源
    From (Select 1 As 住院, 0 As 门诊
           From 住院费用记录
           Where 结帐id = n_原id And Rownum = 1
           Union All
           Select 0 As 住院, 1 As 门诊
           From 门诊费用记录
           Where 结帐id = n_原id And Rownum = 1);
  
  Exception
    When Others Then
      n_来源 := 3;
  End;

  If 误差金额_In <> 0 Then
    Update 病人预交记录
    Set 冲预交 = 冲预交 + 误差金额_In
    Where NO = No_In And 记录性质 = 12 And 记录状态 = 1 And 结帐id = n_结帐id;
    If Sql%RowCount = 0 Then
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 结算性质)
      Values
        (病人预交记录_Id.Nextval, No_In, v_实际票号, 12, 1, n_病人id, r_Pati.主页id, r_Pati.出院科室id, Null, v_误差, Null, '结帐作废退款', Null,
         Null, Null, d_Date, 操作员姓名_In, 操作员编号_In, 误差金额_In, n_结帐id, n_组id, 2);
    End If;
  End If;

  If n_来源 = 2 Or n_来源 = 3 Then
    --作废结帐对应的费用记录:不包含原始结帐产生的误差项目
    Insert Into 住院费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 记帐单id, 病人id, 主页id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 床号, 病人病区id,
       病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 划价人, 开单部门id,
       开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 执行人, 执行时间, 操作员姓名, 操作员编号, 结帐金额, 结帐id, 保险项目否, 保险大类id, 统筹金额, 是否急诊, 保险编码, 费用类型, 摘要,
       缴款组id, 医疗小组id)
      Select 病人费用记录_Id.Nextval, NO, 实际票号, To_Number('1' || Substr(记录性质, Length(记录性质), 1)), 记录状态, 序号, 从属父号, 价格父号, 多病人单,
             记帐单id, 病人id, 主页id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 床号, 病人病区id, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次,
             加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, Null, Null, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 执行人,
             执行时间, 操作员姓名, 操作员编号, -1 * 结帐金额, n_结帐id, 保险项目否, 保险大类id, 统筹金额, 是否急诊, 保险编码, 费用类型, 摘要, 缴款组id, 医疗小组id
      From 住院费用记录
      Where 结帐id = n_原id And Nvl(附加标志, 0) <> 9;
  End If;

  If n_来源 = 1 Or n_来源 = 3 Then
    Insert Into 门诊费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 记帐单id, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 病人科室id, 费别, 收费类别,
       收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 划价人, 开单部门id, 开单人, 发生时间, 登记时间,
       执行部门id, 执行状态, 执行人, 执行时间, 操作员姓名, 操作员编号, 结帐金额, 结帐id, 保险项目否, 保险大类id, 统筹金额, 是否急诊, 保险编码, 费用类型, 摘要, 缴款组id)
      Select 病人费用记录_Id.Nextval, NO, 实际票号, To_Number('1' || Substr(记录性质, Length(记录性质), 1)), 记录状态, 序号, 从属父号, 价格父号, 记帐单id,
             病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费,
             记帐费用, 收入项目id, 收据费目, 标准单价, Null, Null, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 执行人, 执行时间, 操作员姓名, 操作员编号,
             -1 * 结帐金额, n_结帐id, 保险项目否, 保险大类id, 统筹金额, 是否急诊, 保险编码, 费用类型, 摘要, 缴款组id
      From 门诊费用记录
      Where 结帐id = n_原id And Nvl(附加标志, 0) <> 9;
  End If;
  --相关汇总表处理
  For r_Depositrow In c_Deposit(n_结帐id) Loop
    If r_Depositrow.记录性质 In (1, 11) Then
    
      --病人余额(预交)
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - r_Depositrow.冲预交 --注:新的结帐ID产生的是负数金额
      Where 病人id = r_Depositrow.病人id And 类型 = Nvl(r_Depositrow.预交类别, 2) And 性质 = 1
      Returning 预交余额 Into n_返回值;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 预交余额, 费用余额)
        Values
          (r_Depositrow.病人id, 1, Nvl(r_Depositrow.预交类别, 2), -1 * r_Depositrow.冲预交, 0);
        n_返回值 := -1 * r_Depositrow.冲预交;
      End If;
    
      If Nvl(n_返回值, 0) = 0 Then
        Delete 病人余额
        Where 性质 = 1 And 病人id = r_Depositrow.病人id And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
      End If;
    
    Else
      --人员缴款余额,医保不支持作废的结算方式在新的预交结算中已被处理为了退现金,
      --此处用加,表示收回退给病人的现金(结帐时,退款是负,作废时是正)
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + r_Depositrow.冲预交
      Where 收款员 = 操作员姓名_In And 结算方式 = r_Depositrow.结算方式 And 性质 = 1
      Returning 余额 Into n_返回值;
    
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (操作员姓名_In, r_Depositrow.结算方式, 1, r_Depositrow.冲预交);
        n_返回值 := -1 * r_Depositrow.冲预交;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = 操作员姓名_In And 结算方式 = r_Depositrow.结算方式 And 性质 = 1 And Nvl(余额, 0) = 0;
      End If;
    End If;
  End Loop;

  For r_Moneyrow In c_Money(n_结帐id) Loop
    --病人余额 ,误差项已结帐,所以不需要更新这两个汇总表
    If Nvl(v_误差no, 'sc') <> Nvl(r_Moneyrow.No, 'sc') Then
      If Nvl(r_Moneyrow.门诊标志, 0) = 1 Or Nvl(r_Moneyrow.门诊标志, 0) = 2 Then
        n_预交类别 := r_Moneyrow.门诊标志;
      Elsif Nvl(r_Moneyrow.主页id, 0) = 0 Or Nvl(r_Moneyrow.门诊标志, 0) = 4 Then
        --体检:门诊病人
        n_预交类别 := 1;
      Else
        n_预交类别 := 2;
      End If;
    
      If Nvl(r_Moneyrow.门诊标志, 0) <> 4 Then
        Update 病人余额
        Set 费用余额 = Nvl(费用余额, 0) - r_Moneyrow.结帐金额 --注:新的结帐ID产生的是负数金额
        Where 病人id = r_Moneyrow.病人id And 类型 = n_预交类别 And 性质 = 1
        Returning 费用余额 Into n_返回值;
      
        If Sql%RowCount = 0 Then
          Insert Into 病人余额
            (病人id, 性质, 类型, 预交余额, 费用余额)
          Values
            (r_Moneyrow.病人id, 1, n_预交类别, 0, -1 * r_Moneyrow.结帐金额);
          n_返回值 := -1 * r_Moneyrow.结帐金额;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete 病人余额
          Where 病人id = r_Moneyrow.病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
        End If;
      End If;
    
      --病人未结费用
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) - r_Moneyrow.结帐金额
      Where 病人id = r_Moneyrow.病人id And Nvl(主页id, 0) = Nvl(r_Moneyrow.主页id, 0) And
            Nvl(病人病区id, 0) = Nvl(r_Moneyrow.病人病区id, 0) And Nvl(病人科室id, 0) = Nvl(r_Moneyrow.病人科室id, 0) And
            Nvl(开单部门id, 0) = Nvl(r_Moneyrow.开单部门id, 0) And Nvl(执行部门id, 0) = Nvl(r_Moneyrow.执行部门id, 0) And
            收入项目id + 0 = r_Moneyrow.收入项目id And 来源途径 + 0 = r_Moneyrow.门诊标志;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人未结费用
          (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
        Values
          (r_Moneyrow.病人id, Decode(r_Moneyrow.主页id, Null, Null, 0, Null, r_Moneyrow.主页id),
           Decode(r_Moneyrow.病人病区id, Null, Null, 0, Null, r_Moneyrow.病人病区id), r_Moneyrow.病人科室id, r_Moneyrow.开单部门id,
           r_Moneyrow.执行部门id, r_Moneyrow.收入项目id, r_Moneyrow.门诊标志, -1 * r_Moneyrow.结帐金额);
      End If;
    End If;
  End Loop;

  If Nvl(缴预交id_In, 0) <> 0 Then
    --作废时将退款金额充值到预交款帐户,这里标明是本次结帐缴存的
    Update 病人预交记录 Set 结帐id = 冲销id_In Where ID = 缴预交id_In And 结帐id Is Null;
    If Sql%NotFound Then
      v_Err_Msg := '未找到对应的预交款记录！';
      Raise Err_Item;
    End If;
  End If;
  Close c_Pati;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人结帐记录_Delete;
/

--104979:冉俊明,2017-01-19,固定安排在制定临时安排时可修改收费项目，已被使用的按月或周排班的号源可以修改收费项目。
Create Or Replace Procedure Zl_临床出诊临时安排_Verify
(
  安排id_In   In 临床出诊安排.Id%Type,
  审核人_In   In 临床出诊安排.审核人%Type,
  审核时间_In In 临床出诊安排.审核时间%Type
) Is
  Err_Item Exception;
  v_Err_Msg Varchar2(500);

  n_Count    Number(1);
  n_号源id   临床出诊安排.号源id%Type;
  d_开始时间 临床出诊安排.开始时间%Type;
  d_终止时间 临床出诊安排.终止时间%Type;
  d_登记时间 临床出诊安排.登记时间%Type;
Begin
  Begin
    Select 号源id, 开始时间, 终止时间, 登记时间
    Into n_号源id, d_开始时间, d_终止时间, d_登记时间
    From 临床出诊安排
    Where ID = 安排id_In And Rownum < 2;
  Exception
    When Others Then
      v_Err_Msg := '当前安排已被他人删除，不能再审核！！';
      Raise Err_Item;
  End;

  Select Max(1) Into n_Count From 临床出诊限制 A Where a.安排id = 安排id_In And a.限制项目 Is Not Null And Rownum < 2;
  If Nvl(n_Count, 0) = 0 Then
    v_Err_Msg := '当前安排中无任何有效安排，不能审核！';
    Raise Err_Item;
  End If;

  Select Max(1)
  Into n_Count
  From 临床出诊安排 A, 临床出诊安排 B, 临床出诊表 C
  Where a.号源id = b.号源id And a.出诊id = c.Id And c.排班方式 = 0 And a.Id <> b.Id And b.Id = 安排id_In And a.登记时间 < b.登记时间 And
        a.审核时间 Is Null And Rownum < 2;
  If Nvl(n_Count, 0) <> 0 Then
    v_Err_Msg := '该号源在当前安排之前还存在未审核的安排，你不能审核当前安排！';
    Raise Err_Item;
  End If;

  Select Max(1)
  Into n_Count
  From (Select Decode(To_Char(a.出诊日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六',
                        Null) As 限制项目, a.上班时段
         From 临床出诊记录 A, 病人挂号记录 B
         Where a.Id = b.出诊记录id And a.上班时段 Is Not Null And a.号源id = n_号源id And a.出诊日期 Between d_开始时间 And d_终止时间 And
               b.登记时间 > d_登记时间
         Minus
         Select Decode(To_Char(a.出诊日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六',
                        Null) As 限制项目, a.上班时段
         From 临床出诊记录 A, 病人挂号记录 B
         Where a.Id = b.出诊记录id And a.上班时段 Is Not Null And a.号源id = n_号源id And a.出诊日期 Between d_开始时间 And d_终止时间 And
               b.登记时间 <= d_登记时间)
  Where Rownum < 2;
  If Nvl(n_Count, 0) <> 0 Then
    v_Err_Msg := '在当前选择的有效时间范围内，当前号源自上次新增或修改到现在这段时间范围内有不在该安排中的上班时段产生了新的预约挂号记录(这些上班时段必须包含在新的安排中)，需要重新调整安排，你不能审核！';
    Raise Err_Item;
  End If;

  Update 临床出诊安排 Set 审核人 = 审核人_In, 审核时间 = 审核时间_In Where ID = 安排id_In And 审核时间 Is Null;
  If Sql%NotFound Then
    v_Err_Msg := '当前安排已被他人审核或删除，不能再审核！';
    Raise Err_Item;
  End If;

  --新增号源安排审核，同时将临时安排也一并审核了
  For c_安排 In (Select a.Id
               From 临床出诊安排 A, 临床出诊安排 B
               Where a.出诊id = b.出诊id And a.号源id = b.号源id And b.Id = 安排id_In And Nvl(b.是否临时安排, 0) = 0 And
                     Nvl(a.是否临时安排, 0) = 1 And a.审核时间 Is Null) Loop
    Update 临床出诊安排 Set 审核人 = 审核人_In, 审核时间 = 审核时间_In Where ID = c_安排.Id;
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊临时安排_Verify;
/

--104895:胡俊勇,2017-02-14,时价药品发送后库存问题
--99679:李业庆,2017-02-22,住院销售出库价格取原始价格，金额位数按流通参数确定
Create Or Replace Procedure Zl_住院记帐记录_Insert
(
  No_In             住院费用记录.No%Type,
  序号_In           住院费用记录.序号%Type,
  病人id_In         住院费用记录.病人id%Type,
  主页id_In         住院费用记录.主页id%Type,
  标识号_In         住院费用记录.标识号%Type,
  姓名_In           住院费用记录.姓名%Type,
  性别_In           住院费用记录.性别%Type,
  年龄_In           住院费用记录.年龄%Type,
  床号_In           住院费用记录.床号%Type,
  费别_In           住院费用记录.费别%Type,
  病区id_In         住院费用记录.病人病区id%Type,
  科室id_In         住院费用记录.病人科室id%Type,
  加班标志_In       住院费用记录.加班标志%Type,
  婴儿费_In         住院费用记录.婴儿费%Type,
  开单部门id_In     住院费用记录.开单部门id%Type,
  开单人_In         住院费用记录.开单人%Type,
  从属父号_In       住院费用记录.从属父号%Type,
  收费细目id_In     住院费用记录.收费细目id%Type,
  收费类别_In       住院费用记录.收费类别%Type,
  计算单位_In       住院费用记录.计算单位%Type,
  保险项目否_In     住院费用记录.保险项目否%Type,
  保险大类id_In     住院费用记录.保险大类id%Type,
  保险编码_In       住院费用记录.保险编码%Type,
  付数_In           住院费用记录.付数%Type,
  数次_In           住院费用记录.数次%Type,
  附加标志_In       住院费用记录.附加标志%Type,
  执行部门id_In     住院费用记录.执行部门id%Type,
  价格父号_In       住院费用记录.价格父号%Type,
  收入项目id_In     住院费用记录.收入项目id%Type,
  收据费目_In       住院费用记录.收据费目%Type,
  标准单价_In       住院费用记录.标准单价%Type,
  应收金额_In       住院费用记录.应收金额%Type,
  实收金额_In       住院费用记录.实收金额%Type,
  统筹金额_In       住院费用记录.统筹金额%Type,
  发生时间_In       住院费用记录.发生时间%Type,
  登记时间_In       住院费用记录.登记时间%Type,
  药品摘要_In       药品收发记录.摘要%Type,
  划价_In           Number,
  操作员编号_In     住院费用记录.操作员编号%Type,
  操作员姓名_In     住院费用记录.操作员姓名%Type,
  多病人单_In       Number := 0,
  类别id_In         药品单据性质.类别id%Type := Null,
  记帐单id_In       住院费用记录.记帐单id%Type := Null,
  费用摘要_In       住院费用记录.摘要%Type := Null,
  是否急诊_In       住院费用记录.是否急诊%Type := 0,
  医嘱序号_In       住院费用记录.医嘱序号%Type := Null,
  频次_In           药品收发记录.频次%Type := Null,
  单量_In           药品收发记录.单量%Type := Null,
  用法_In           药品收发记录.用法%Type := Null, --用法[|煎法]
  期效_In           药品收发记录.扣率%Type := Null,
  计价特性_In       药品收发记录.扣率%Type := Null,
  简单记帐_In       Number := 0,
  费用类型_In       住院费用记录.费用类型%Type := Null,
  医技补临床费用_In Number := 0,
  领药部门id_In     药品收发记录.对方部门id%Type := Null,
  中药形态_In       住院费用记录.结论%Type := Null,
  医疗小组id_In     住院费用记录.医疗小组id%Type := -1,
  备货材料_In       Number := 0,
  批次_In           药品收发记录.批次%Type := Null
) As
  --功能：新收一张住院记帐单据
  --参数：
  --   药品摘要_IN:存放医嘱中的附加说明或修改保存新单据时用。目前仅用于存放于药品收发记录的摘要中。
  --         原单据(记录状态=2)记录修改产生的新单据号。
  --         新单据(记录状态=1)记录所修改的原单据号。
  --   划价-是否属于住院划价。
  --   医技补临床费用_in:医技站补费时,如果开单科室为临床科室则划价人和记帐人填写为不同,用于销帐申请时区分填写审核科室
  --   备货材料_IN: 医技站的卫生材料备货处理方式:0-正常记帐单;1-备货材料记帐
  --   批次_In:当备货材料_IN=1时有效.传入指定的卫生材料的批次
  v_费用id 住院费用记录.Id%Type;
  v_优先级 未发药品记录.优先级%Type;

  --药房分批、时价药品--
  ------------------------------------------------------------
  --该游标用于分批药品数量分解
  Cursor c_Stock
  (
    n_Outmode Number,
    n_库房id  药品收发记录.库房id%Type
  ) Is
    Select 库房id, 药品id, 批次, 上次批号, 可用数量, 实际数量, 实际金额, 上次供应商id, 批准文号, 上次产地, 上次生产日期, 灭菌效期, 效期, 零售价, 商品条码, 内部条码
    From 药品库存
    Where 药品id = 收费细目id_In And 库房id = n_库房id And 性质 = 1 And (Nvl(批次, 0) = Nvl(批次_In, 0) Or Nvl(批次_In, 0) = 0) And
          (Nvl(批次, 0) = 0 Or 效期 Is Null Or 效期 > Trunc(Sysdate)) And Nvl(可用数量, 0) > 0
    Order By Decode(n_Outmode, 1, 效期, Null), Nvl(批次, 0);
  r_Stock c_Stock%RowType;

  --属性
  n_分批 药品规格.药房分批%Type;
  n_时价 收费项目目录.是否变价%Type;
  v_名称 收费项目目录.名称%Type;
  --临时变量
  n_总数量   Number;
  n_当前数量 Number;
  n_总金额   Number;
  n_当前单价 Number;
  --药品收发记录
  n_批次       药品收发记录.批次%Type;
  n_序号       药品收发记录.序号%Type;
  n_扣率       药品收发记录.扣率%Type;
  n_领药部门id 药品收发记录.对方部门id%Type;
  n_供药单位id 药品收发记录.供药单位id%Type;
  v_商品条码   药品收发记录.商品条码%Type;
  v_内部条码   药品收发记录.内部条码%Type;
  d_效期       药品收发记录.效期%Type;
  d_灭菌效期   药品收发记录.灭菌效期%Type;
  d_灭菌日期   药品收发记录.灭菌日期%Type;
  d_生产日期   药品收发记录.生产日期%Type;
  n_虚拟库房id 药品收发记录.库房id%Type;
  v_产地       药品收发记录.产地%Type;
  v_批号       药品收发记录.批号%Type;
  v_批准文号   药品收发记录.批准文号%Type;
  v_其他出库no 药品收发记录.No%Type;
  n_Aval       药品库存.可用数量%Type;
  v_部门名称   部门表.名称%Type;
  ------------------------------------------------------------
  v_用法       药品收发记录.用法%Type;
  v_煎法       药品收发记录.外观%Type;
  n_单价小数   Number;
  n_医疗小组id 住院费用记录.医疗小组id%Type;
  n_库房id     药品库存.库房id%Type;
  n_修正库房id 药品库存.库房id%Type;
  n_Outmode    Number(1);
  v_Dec        Number;
  v_Count      Number;
  v_Err_Msg    Varchar2(255);
  Err_Item Exception;
  n_出库序号       药品收发记录.序号%Type;
  n_审核标志       病案主页.审核标志%Type;
  n_住院状态       病案主页.状态%Type;
  n_病人审核方式   Number(2);
  n_未入科禁止记账 Number(2);
  n_流通金额小数   Number;
  n_标准单价       药品收发记录.零售价%Type;
Begin
  --根据执行库房取虚拟库房ID
  Begin
    Select 虚拟库房id Into n_虚拟库房id From 虚拟库房对照 Where 科室id = 执行部门id_In And Rownum <= 1;
  Exception
    When Others Then
      n_虚拟库房id := 0;
  End;
  If 批次_In Is Not Null Then
    Select Nvl(Sum(可用数量), 0)
    Into n_Aval
    From 药品库存
    Where 药品id = 收费细目id_In And 批次 = 批次_In And 库房id = 执行部门id_In;
    If n_Aval <= 0 Then
      n_修正库房id := n_虚拟库房id;
    End If;
  End If;

  If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
    If Nvl(n_虚拟库房id, 0) = 0 Then
      Begin
        Select 名称 Into v_Err_Msg From 部门表 Where ID = 执行部门id_In;
      Exception
        When Others Then
          v_Err_Msg := '';
      End;
      v_Err_Msg := '执行部门"' || Nvl(v_Err_Msg, '') || '"未设置虚拟部门,请在卫材参数设置中设置.';
      Raise Err_Item;
    End If;
  End If;
  If Nvl(多病人单_In, 0) = 1 Or Nvl(序号_In, 0) = 1 Then
    --记帐表,全部检查,如果是记帐单只检查第一条,其他不检查
  
    n_病人审核方式   := Nvl(zl_GetSysParameter(185), 0);
    n_未入科禁止记账 := Nvl(zl_GetSysParameter(215), 0);
    If n_病人审核方式 = 1 Or n_未入科禁止记账 = 1 Then
      Begin
        Select 审核标志, 状态
        Into n_审核标志, n_住院状态
        From 病案主页
        Where 病人id = Nvl(病人id_In, 0) And 主页id = Nvl(主页id_In, 0);
      Exception
        When Others Then
          n_审核标志 := 0;
          n_住院状态 := 0;
      End;
      If n_未入科禁止记账 = 1 And n_住院状态 = 1 Then
        v_Err_Msg := '病人未入科,禁止对病人相关费用的操作!';
        Raise Err_Item;
      End If;
    
      If n_病人审核方式 = 1 Then
      
        If Nvl(n_审核标志, 0) = 1 Then
          v_Err_Msg := '该病人目前正在审核费用,不能进行费用相关调整!';
          Raise Err_Item;
        End If;
        If Nvl(n_审核标志, 0) = 2 Then
          v_Err_Msg := '该病人目前已经完成了费用审核,不能进行费用相关调整!';
          Raise Err_Item;
        End If;
      End If;
    End If;
  End If;
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --领药部门确认规则:
  -- 1.传入 :领药部门ID_IN,直接以传入的为准
  -- 2.领药部门ID_IN=NULL的情况, 如果”开单科室=病人科室”，则填为”病人病区”，如果”开单科室<>病人科室”，则填写为”开单科室”
  If Nvl(领药部门id_In, 0) = 0 Then
    If Nvl(科室id_In, 0) = Nvl(开单部门id_In, 0) Then
      --如果”开单科室=病人科室”，则填为”病人病区”(如果没有入科,即病匹为空这种情况,则以病人科室为准,由于一般这种情况较少(护土开单),因此,这种情况应该不会存在)
      n_领药部门id := Nvl(病区id_In, 0);
      If Nvl(n_领药部门id, 0) = 0 Then
        n_领药部门id := 科室id_In;
      End If;
    Else
      --如果”开单科室<>病人科室”，则填写为”开单科室”
      n_领药部门id := 开单部门id_In;
    End If;
  Else
    n_领药部门id := 领药部门id_In;
  End If;
  --需要检查0这种情况,回为有关联
  If Nvl(n_领药部门id, 0) = 0 Then
    n_领药部门id := Null;
  End If;
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --药品用法煎法分解
  If 用法_In Is Not Null Then
    If Instr(用法_In, '|') > 0 Then
      v_用法 := Substr(用法_In, 1, Instr(用法_In, '|') - 1);
      v_煎法 := Substr(用法_In, Instr(用法_In, '|') + 1);
    Else
      v_用法 := 用法_In;
    End If;
  End If;

  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')), Zl_To_Number(Nvl(zl_GetSysParameter(157), '5'))
  Into v_Dec, n_单价小数
  From Dual;

  --取流通业务精度位数
  --类别:1-药品 2-卫材
  --内容：2-零售价 4-金额
  --单位：药品:1-售价 5-金额单位
  If 收费类别_In = '4' Then
    Select 精度 Into n_流通金额小数 From 药品卫材精度 Where 类别 = 2 And 内容 = 4 And 单位 = 5;
  Else
    Select 精度 Into n_流通金额小数 From 药品卫材精度 Where 类别 = 1 And 内容 = 4 And 单位 = 5;
  End If;

  If 收费类别_In In ('4', '5', '6', '7') Then
    --取定价药品/卫材价格
    Select c.现价
    Into n_标准单价
    From 收费价目 C
    Where c.收费细目id = 收费细目id_In And Sysdate Between c.执行日期 And c.终止日期;
  End If;

  --住院费用记录
  Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
  n_医疗小组id := 医疗小组id_In;

  If Nvl(医疗小组id_In, 0) < 0 Then
    n_医疗小组id := Zl_医疗小组_Get(开单部门id_In, 开单人_In, 病人id_In, 主页id_In, 发生时间_In);
  End If;

  Insert Into 住院费用记录
    (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id, 费别, 收费类别, 收费细目id,
     计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用, 开单部门id,
     开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 是否急诊, 医嘱序号, 结论, 医疗小组id)
  Values
    (v_费用id, 2, No_In, Decode(划价_In, 1, 0, 1), 序号_In, Decode(从属父号_In, 0, Null, 从属父号_In),
     Decode(价格父号_In, 0, Null, 价格父号_In), 多病人单_In, 2, 病人id_In, 主页id_In, Decode(标识号_In, 0, Null, 标识号_In), 姓名_In, 性别_In,
     年龄_In, 床号_In, Decode(病区id_In, 0, Null, 病区id_In), Decode(科室id_In, 0, Null, 科室id_In), 费别_In, 收费类别_In, 收费细目id_In,
     计算单位_In, 保险项目否_In, 保险大类id_In, 保险编码_In, 费用类型_In, Decode(Nvl(简单记帐_In, 0), 0, Null, 收费类别_In), 付数_In, 数次_In, 加班标志_In,
     附加标志_In, 婴儿费_In, 收入项目id_In, 收据费目_In, 标准单价_In, 应收金额_In, 实收金额_In, 统筹金额_In, 1, 开单部门id_In, 开单人_In, 发生时间_In, 登记时间_In,
     执行部门id_In, 0, Decode(划价_In, 1, 操作员姓名_In, Decode(医技补临床费用_In, 1, '补临床费', Null)), Decode(划价_In, 1, Null, 操作员编号_In),
     Decode(划价_In, 1, Null, 操作员姓名_In), 记帐单id_In, 费用摘要_In, 是否急诊_In, 医嘱序号_In, 中药形态_In, n_医疗小组id);

  Select Max(使用限量 - Nvl(已用数量, 0))
  Into n_当前数量
  From 病人审批项目
  Where 病人id = 病人id_In And 主页id = 主页id_In And 项目id = 收费细目id_In And Nvl(使用限量, 0) <> 0;
  If 付数_In * 数次_In <= Nvl(n_当前数量, 0) Then
    Update 病人审批项目
    Set 已用数量 = Nvl(已用数量, 0) + 付数_In * 数次_In
    Where 病人id = 病人id_In And 主页id = 主页id_In And 项目id = 收费细目id_In And Nvl(使用限量, 0) <> 0;
  Elsif Not n_当前数量 Is Null Then
    v_Err_Msg := '第 ' || 序号_In || ' 行输入的数次超过了批准的可用数量' || n_当前数量 || '.'; --简化为不转换,直接以售价单位提示.
    Raise Err_Item;
  End If;

  --相关汇总表的处理
  If Nvl(划价_In, 0) = 0 Then
    --病人余额
    Update 病人余额 Set 费用余额 = Nvl(费用余额, 0) + 实收金额_In Where 病人id = 病人id_In And 类型 = 2 And 性质 = 1;
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 类型, 性质, 费用余额, 预交余额) Values (病人id_In, 2, 1, 实收金额_In, 0);
    End If;
  
    --病人未结费用
    Update 病人未结费用
    Set 金额 = Nvl(金额, 0) + 实收金额_In
    Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0) And Nvl(病人病区id, 0) = Nvl(病区id_In, 0) And
          Nvl(病人科室id, 0) = Nvl(科室id_In, 0) And Nvl(开单部门id, 0) = Nvl(开单部门id_In, 0) And
          Nvl(执行部门id, 0) = Nvl(执行部门id_In, 0) And 收入项目id + 0 = 收入项目id_In And 来源途径 + 0 = 2;
    If Sql%RowCount = 0 Then
      Insert Into 病人未结费用
        (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
      Values
        (病人id_In, 主页id_In, 病区id_In, 科室id_In, 开单部门id_In, 执行部门id_In, 收入项目id_In, 2, 实收金额_In);
    End If;
  End If;

  --药品和卫生材料部分
  v_Count := 0; --@@@
  If 收费类别_In = '4' Then
    --跟踪在用的卫材才处理
    Select 跟踪在用 Into v_Count From 材料特性 Where 材料id = 收费细目id_In;
  End If;
  If 收费类别_In In ('5', '6', '7') Or (收费类别_In = '4' And Nvl(v_Count, 0) = 1) Then
    If 收费类别_In = '4' Then
      Select Nvl(a.在用分批, 0), Nvl(b.是否变价, 0), b.名称
      Into n_分批, n_时价, v_名称
      From 材料特性 A, 收费项目目录 B
      Where a.材料id = b.Id And b.Id = 收费细目id_In;
    Else
      Select Nvl(a.药房分批, 0), Nvl(b.是否变价, 0), b.名称
      Into n_分批, n_时价, v_名称
      From 药品规格 A, 收费项目目录 B
      Where a.药品id = b.Id And b.Id = 收费细目id_In;
    End If;
  
    --药品分批出库方式
    Select Zl_To_Number(Nvl(zl_GetSysParameter(150), 0)) Into n_Outmode From Dual;
  
    n_总数量 := 付数_In * 数次_In;
    n_总金额 := 0;
    If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
      n_库房id := n_虚拟库房id;
      Open c_Stock(n_Outmode, n_虚拟库房id);
    Else
      If Nvl(n_修正库房id, 0) <> 0 Then
        n_库房id := n_修正库房id;
        Open c_Stock(n_Outmode, n_修正库房id);
      Else
        n_库房id := 执行部门id_In;
        Open c_Stock(n_Outmode, 执行部门id_In);
      End If;
    End If;
  
    While n_总数量 <> 0 Loop
      Fetch c_Stock
        Into r_Stock;
      If c_Stock%NotFound Then
        --第一次就没有库存,分批或时价都不允许(包含备货卫材)。
        --分批药品数量分解不完,也就是库存不足。
        If n_分批 = 1 Or n_时价 = 1 Or (Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4') Then
          Close c_Stock;
          If 医嘱序号_In Is Null Then
            If 收费类别_In = '4' Then
              If Nvl(备货材料_In, 0) = 1 And Not (n_分批 = 1 Or n_时价 = 1) Then
                v_Err_Msg := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
              Else
                v_Err_Msg := '第 ' || 序号_In || ' 行的分批或时价卫生材料"' || v_名称 || '"没有足够的材料库存' || Case
                               When Nvl(备货材料_In, 0) = 0 Then
                                '！'
                               Else
                                ',不能进行备货记帐！'
                             End;
              End If;
            Else
              v_Err_Msg := '第 ' || 序号_In || ' 行的分批或时价药品"' || v_名称 || '"没有足够的药品库存！';
            End If;
          Else
            If 收费类别_In = '4' Then
              If Nvl(备货材料_In, 0) = 1 And Not (n_分批 = 1 Or n_时价 = 1) Then
                v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
              Else
                v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现分批或时价卫生材料"' || v_名称 || '"没有足够的材料库存' || Case
                               When Nvl(备货材料_In, 0) = 0 Then
                                '！'
                               Else
                                ',不能进行备货记帐！'
                             End;
              End If;
            Else
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现分批或时价药品"' || v_名称 || '"没有足够的药品库存！';
            End If;
          End If;
          Raise Err_Item;
        End If;
      Elsif (n_分批 = 1 And Nvl(r_Stock.批次, 0) = 0) Or (n_分批 = 0 And Nvl(r_Stock.批次, 0) <> 0) Then
        Close c_Stock;
        If 医嘱序号_In Is Null Then
          If 收费类别_In = '4' Then
            v_Err_Msg := '第 ' || 序号_In || ' 行卫生材料"' || v_名称 || '"的分批属性与库存记录不相符,请检查材料数据的正确性！';
          Else
            v_Err_Msg := '第 ' || 序号_In || ' 行药品"' || v_名称 || '"的分批属性与库存记录不相符,请检查药品数据的正确性！';
          End If;
        Else
          If 收费类别_In = '4' Then
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现卫生材料"' || v_名称 || '"的分批属性与库存记录不相符,请检查材料数据的正确性！';
          Else
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现药品"' || v_名称 || '"的分批属性与库存记录不相符,请检查药品数据的正确性！';
          End If;
        End If;
        Raise Err_Item;
      End If;
    
      If c_Stock%Found Then
        If Nvl(r_Stock.实际数量, 0) = 0 And (n_总数量 > 0 Or n_时价 = 1) Then
          --实际数量为零时，不正常，不允许出库
          --实际数量不为零，金额为零，可能是正常的零价格管理。
          --负数的情况相当于入库,这种情况应是允许的；但时价需要计算价格，必须要有实际数量。
          Close c_Stock;
          If 医嘱序号_In Is Null Then
            If 收费类别_In = '4' Then
              v_Err_Msg := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"当前无库存实际数量，可能存在尚未退料的记录，当前不能出库。';
            Else
              v_Err_Msg := '第 ' || 序号_In || ' 行药品"' || v_名称 || '"当前无库存实际数量，可能存在尚未退药的记录，当前不能出库。';
            End If;
          Else
            If 收费类别_In = '4' Then
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现卫生材料"' || v_名称 || '"当前无库存实际数量，可能存在尚未退料的记录，当前不能出库。';
            Else
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现药品"' || v_名称 || '"当前无库存实际数量，可能存在尚未退药的记录，当前不能出库。';
            End If;
          End If;
          Raise Err_Item;
        End If;
      End If;
    
      --确定本次分解数量
      If n_分批 = 1 Or n_时价 = 1 Then
        --对于不分批的时价只可能分解一次,分解不完上面判断了.它分解是为了计算单价.
        --每次分解取小者,库存不够分解不完在上面判断.
        If n_总数量 <= Nvl(r_Stock.可用数量, 0) Then
          n_当前数量 := n_总数量;
        Else
          n_当前数量 := Nvl(r_Stock.可用数量, 0);
        End If;
        If n_时价 = 1 Then
          n_当前单价 := Nvl(r_Stock.零售价, Nvl(r_Stock.实际金额 / r_Stock.实际数量, 0));
        Elsif n_分批 = 1 Then
          n_当前单价 := n_标准单价;
        End If;
      Else
        --普通药品
        --不管够不够,程序中已根据参数判断
        If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
          If n_总数量 > Nvl(r_Stock.可用数量, 0) Then
            --不分批, 但又是备货卫材方式出库的,则需要检查当前库存是否充足.
            v_Err_Msg := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
            Raise Err_Item;
          End If;
        End If;
        n_当前数量 := n_总数量;
        n_当前单价 := n_标准单价;
      End If;
    
      --药品库存(普通情况可能没有记录)
      If c_Stock%Found Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - n_当前数量
        Where 库房id = n_库房id And 药品id = 收费细目id_In And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1
        Returning 可用数量 Into v_Count;
        If n_分批 = 1 Or n_时价 = 1 Then
          If v_Count < 0 Then
            If 收费类别_In = '4' Then
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现卫生材料"' || v_名称 || '"当前库存实际数量不足，当前不能出库，可能是由于网络并发操作引起，请刷新后再试！。';
            Else
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现药品"' || v_名称 || '"当前库存实际数量不足，当前不能出库，可能是由于网络并发操作引起，请刷新后再试！。';
            End If;
            Raise Err_Item;
          End If;
        End If;
      Elsif n_库房id Is Not Null Then
        --只有不分批非时价药品可能库存不足出库
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - n_当前数量
        Where 库房id = n_库房id And 药品id = 收费细目id_In And Nvl(批次, 0) = 0 And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 可用数量, 商品条码, 内部条码)
          Values
            (n_库房id, 收费细目id_In, 1, -1 * n_当前数量, r_Stock.商品条码, r_Stock.内部条码);
        End If;
      End If;
    
      If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - n_当前数量
        Where 库房id = 执行部门id_In And 药品id = 收费细目id_In And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;
      
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 可用数量, 商品条码, 内部条码, 效期, 上次批号, 上次产地, 上次供应商id, 上次生产日期, 批准文号)
          Values
            (执行部门id_In, 收费细目id_In, Nvl(r_Stock.批次, 0), 1, -1 * n_当前数量, r_Stock.商品条码, r_Stock.内部条码, r_Stock.效期,
             r_Stock.上次批号, r_Stock.上次产地, r_Stock.上次供应商id, r_Stock.上次生产日期, r_Stock.批准文号);
        End If;
      End If;
    
      --药品收发记录
      n_批次       := Null;
      v_批号       := Null;
      d_效期       := Null;
      v_产地       := Null;
      d_灭菌效期   := Null;
      d_灭菌日期   := Null;
      n_供药单位id := Null;
      d_生产日期   := Null;
      v_批准文号   := Null;
      If c_Stock%Found Then
        n_批次       := r_Stock.批次;
        v_批号       := r_Stock.上次批号;
        d_效期       := r_Stock.效期;
        v_产地       := r_Stock.上次产地;
        n_供药单位id := r_Stock.上次供应商id;
        d_生产日期   := r_Stock.上次生产日期;
        v_批准文号   := r_Stock.批准文号;
        v_商品条码   := r_Stock.商品条码;
        v_内部条码   := r_Stock.内部条码;
      
        --卫材灭菌效期:一次性材料且有效期
        If 收费类别_In = '4' Then
          v_Count := 0;
          Begin
            Select 灭菌效期 Into v_Count From 材料特性 Where Nvl(一次性材料, 0) = 1 And 材料id = 收费细目id_In;
          Exception
            When Others Then
              Null;
          End;
          If Nvl(v_Count, 0) > 0 Then
            d_灭菌效期 := r_Stock.灭菌效期;
            d_灭菌日期 := d_灭菌效期 - v_Count * 30;
          End If;
        End If;
      End If;
    
      Select Nvl(Max(序号), 0) + 1
      Into n_序号
      From 药品收发记录
      Where NO = No_In And 记录状态 = 1 And 单据 = Decode(多病人单_In, 1, 10, 9) + Decode(收费类别_In, '4', 16, 0);
    
      n_扣率 := Null;
      If 期效_In Is Not Null Or 计价特性_In Is Not Null Then
        n_扣率 := Nvl(期效_In, 0) || Nvl(计价特性_In, 0);
      End If;
    
      --分批药品,如果是只使用了一个批次,则要填写付数
      If n_分批 = 1 And n_当前数量 <> 付数_In * 数次_In Then
        v_Count := 1;
      Else
        v_Count := 0;
      End If;
    
      --修改的原单据号存放在摘要中
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人,
         填制日期, 费用id, 频次, 单量, 用法, 外观, 扣率, 灭菌效期, 灭菌日期, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
      Values
        (药品收发记录_Id.Nextval, 1, Decode(多病人单_In, 1, 10, 9) + Decode(收费类别_In, '4', 16, 0), No_In, n_序号, 执行部门id_In,
         n_领药部门id, 类别id_In, -1, 收费细目id_In, n_批次, v_产地, v_批号, d_效期, Decode(v_Count, 1, 1, 付数_In),
         Decode(v_Count, 1, n_当前数量, n_当前数量 / 付数_In), Decode(v_Count, 1, n_当前数量, n_当前数量 / 付数_In), n_当前单价,
         Round(n_当前单价 * n_当前数量, n_流通金额小数), 药品摘要_In, 操作员姓名_In, 登记时间_In, v_费用id, 频次_In, 单量_In, v_用法, v_煎法, n_扣率, d_灭菌效期,
         d_灭菌日期, n_供药单位id, d_生产日期, v_批准文号, v_商品条码, v_内部条码);
    
      --产生其他出库单
      If 收费类别_In = '4' And (Nvl(备货材料_In, 0) = 1 Or Nvl(n_修正库房id, 0) <> 0) Then
        Begin
          Select Max(a.No), Max(a.序号)
          Into v_其他出库no, n_出库序号
          From 药品收发记录 A, 住院费用记录 B
          Where a.费用id = b.Id And a.单据 = 21 And b.No = No_In And b.记录性质 = 2;
        Exception
          When Others Then
            v_其他出库no := Null;
        End;
        If v_其他出库no Is Null Then
          v_其他出库no := Nextno(74, n_虚拟库房id, Null, 1);
        End If;
        If v_其他出库no Is Null Then
          v_Err_Msg := '在生成卫生材料的其他出库单时,获取相关的出库NO有误,请检查出库单的规则是否有误!';
          Raise Err_Item;
        End If;
        If Nvl(科室id_In, 0) <> 0 Then
          Select 名称 Into v_部门名称 From 部门表 Where ID = 科室id_In;
        End If;
        v_Err_Msg := LPad(' ', 4);
        v_Err_Msg := Substr('病人姓名:' || 姓名_In || v_Err_Msg || '性别:' || 性别_In || v_Err_Msg || '年龄' || 年龄_In || v_Err_Msg ||
                            '床号:' || 床号_In || v_Err_Msg || '住院号:' || Nvl(标识号_In, '') || v_Err_Msg || '病人科室:' || v_部门名称, 1,
                            100);
      
        n_出库序号 := Nvl(n_出库序号, 0) + 1;
        Insert Into 药品收发记录
          (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人,
           填制日期, 费用id, 频次, 单量, 用法, 外观, 扣率, 灭菌效期, 灭菌日期, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
        Values
          (药品收发记录_Id.Nextval, 1, 21, v_其他出库no, n_出库序号, n_虚拟库房id, n_领药部门id, 类别id_In, -1, 收费细目id_In, n_批次, v_产地, v_批号,
           d_效期, Decode(v_Count, 1, 1, 付数_In), Decode(v_Count, 1, n_当前数量, n_当前数量 / 付数_In),
           Decode(v_Count, 1, n_当前数量, n_当前数量 / 付数_In), n_当前单价, Round(n_当前单价 * n_当前数量, n_流通金额小数), v_Err_Msg, 操作员姓名_In,
           登记时间_In, v_费用id, 频次_In, 单量_In, v_用法, v_煎法, n_扣率, d_灭菌效期, d_灭菌日期, n_供药单位id, d_生产日期, v_批准文号, v_商品条码, v_内部条码);
      End If;
      v_Err_Msg := '';
      n_总数量  := n_总数量 - n_当前数量;
      n_总金额  := n_总金额 + Round(n_当前数量 * n_当前单价, n_流通金额小数);
    End Loop;
  
    --未发药品记录
    Update 未发药品记录
    Set 病人id = 病人id_In, 主页id = 主页id_In, 姓名 = 姓名_In
    Where 单据 = Decode(多病人单_In, 1, 10, 9) + Decode(收费类别_In, '4', 16, 0) And NO = No_In And
          Nvl(库房id, 0) = Nvl(执行部门id_In, 0);
    If Sql%RowCount = 0 Then
      --取身份优先级
      Begin
        Select b.优先级 Into v_优先级 From 病人信息 A, 身份 B Where a.身份 = b.名称(+) And a.病人id = 病人id_In;
      Exception
        When Others Then
          Null;
      End;
      Insert Into 未发药品记录
        (单据, NO, 病人id, 主页id, 姓名, 优先级, 对方部门id, 库房id, 填制日期, 已收费, 打印状态)
      Values
        (Decode(多病人单_In, 1, 10, 9) + Decode(收费类别_In, '4', 16, 0), No_In, 病人id_In, 主页id_In, 姓名_In, v_优先级, n_领药部门id,
         执行部门id_In, 登记时间_In, Decode(划价_In, 1, 0, 1), 0);
    End If;
    Zl_Prescription_Type_Zy_Update(No_In, 2, 收费细目id_In, 收费类别_In);
    --可能时价药品的库存金额和数量变化了
    If n_时价 = 1 Then
      --只有一个批次时,直接取该批次的单价
      If n_当前数量 <> 付数_In * 数次_In Then
        n_当前单价 := n_总金额 / (付数_In * 数次_In);
      End If;
      If Round(n_当前单价, n_单价小数) <> 标准单价_In Then
        Close c_Stock;
        If 医嘱序号_In Is Null Then
          If 收费类别_In = '4' Then
            v_Err_Msg := '第 ' || 序号_In || ' 行的时价卫生材料"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
          Else
            v_Err_Msg := '第 ' || 序号_In || ' 行的时价药品"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
          End If;
        Else
          --医嘱摆药时是按病人分次计算并提交数据库,因此不同病人使用相同实价药品没有问题。
          --但同一病人同时使用两笔以上相同实价药品则会有问题。
          If 收费类别_In = '4' Then
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现时价卫生材料"' || v_名称 || '"当前计算的单价发生变化。' || Chr(13) || Chr(10) ||
                         '请检查该病人是否同时使用了两笔相同的"' || v_名称 || '"！';
          Else
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现时价药品"' || v_名称 || '"当前计算的单价发生变化。' || Chr(13) || Chr(10) ||
                         '请检查该病人是否同时使用了两笔相同的"' || v_名称 || '"！';
          End If;
        End If;
        Raise Err_Item;
      End If;
    End If;
    Close c_Stock;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_住院记帐记录_Insert;
/

--104979:冉俊明,2017-01-18,固定安排在制定临时安排时可修改收费项目，已被使用的按月或周排班的号源可以修改收费项目。
Create Or Replace Procedure Zl_临床出诊号源_Modify
(
  操作类型_In     Number,
  Id_In           临床出诊号源.Id%Type,
  号类_In         临床出诊号源.号类%Type := Null,
  号码_In         临床出诊号源.号码%Type := Null,
  科室id_In       临床出诊号源.科室id%Type := 0,
  项目id_In       临床出诊号源.项目id%Type := 0,
  医生id_In       临床出诊号源.医生id%Type := Null,
  医生姓名_In     临床出诊号源.医生姓名%Type := Null,
  是否建病案_In   临床出诊号源.是否建病案%Type := 0,
  预约天数_In     临床出诊号源.预约天数%Type := 0,
  出诊频次_In     临床出诊号源.出诊频次%Type := 0,
  假日控制状态_In 临床出诊号源.假日控制状态%Type := 0,
  是否假日换休_In 临床出诊号源.是否假日换休%Type := 0,
  是否临床排班_In 临床出诊号源.是否临床排班%Type := 0,
  排班方式_In     临床出诊号源.排班方式%Type := 0,
  适用性别_In     临床出诊号源.适用性别%Type := Null,
  适用年龄段_In   临床出诊号源.适用年龄段%Type := Null,
  更新出诊表_In   Number := 0
) As
  --操作类型_In 0-新增，1-修改，2-删除
  --分诊诊室_In 诊室ID，格式：诊室ID1;诊室ID2;诊室ID13;...
  --更新出诊表_In 操作类型_In=1时，号源收费项目改变后，是否同步调整未发布的按月/周安排的出诊表
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  n_号源id 临床出诊号源.Id%Type;

  l_安排id t_Numlist := t_Numlist();
  l_记录id t_Numlist := t_Numlist();
  n_安排id 临床出诊安排.Id%Type;
Begin

  If 操作类型_In = 0 Then
    --增加号源
    n_号源id := Id_In;
  
    If Nvl(n_号源id, 0) = 0 Then
      Select 临床出诊号源_Id.Nextval Into n_号源id From Dual;
    End If;
    Insert Into 临床出诊号源
      (ID, 号类, 号码, 科室id, 项目id, 医生id, 医生姓名, 是否建病案, 预约天数, 出诊频次, 假日控制状态, 是否假日换休, 是否临床排班, 排班方式, 适用性别, 适用年龄段, 是否删除, 建档时间,
       撤档时间)
    Values
      (n_号源id, 号类_In, 号码_In, 科室id_In, 项目id_In, 医生id_In, 医生姓名_In, 是否建病案_In, 预约天数_In, 出诊频次_In, 假日控制状态_In, 是否假日换休_In,
       是否临床排班_In, 排班方式_In, 适用性别_In, 适用年龄段_In, 0, Sysdate, To_Date('3000-01-01', 'yyyy-mm-dd'));
  
    Return;
  End If;

  --修改号源
  Update 临床出诊号源
  Set 号类 = 号类_In, 号码 = 号码_In, 科室id = 科室id_In, 项目id = 项目id_In, 医生id = 医生id_In, 医生姓名 = 医生姓名_In, 是否建病案 = 是否建病案_In,
      预约天数 = 预约天数_In, 出诊频次 = 出诊频次_In, 假日控制状态 = 假日控制状态_In, 是否假日换休 = 是否假日换休_In, 是否临床排班 = 是否临床排班_In, 排班方式 = 排班方式_In,
      适用性别 = 适用性别_In, 适用年龄段 = 适用年龄段_In
  Where ID = Id_In And Nvl(是否删除, 0) = 0 And Nvl(撤档时间, Sysdate) >= Sysdate;
  If Sql%NotFound Then
    v_Err_Msg := '当前号源可能已被他人删除或停用，不能对该号源信息进行修改!';
    Raise Err_Item;
  End If;

  --同步调整未发布的按月/周安排的出诊表，和模板
  For c_安排 In (Select Distinct a.Id As 安排id, c.Id As 记录id
               From 临床出诊记录 C, 临床出诊安排 A, 临床出诊表 B
               Where a.Id = c.安排id(+) And a.出诊id = b.Id And a.号源id = Id_In And
                     (Nvl(b.排班方式, 0) In (1, 2) And b.发布时间 Is Null And Nvl(更新出诊表_In, 0) = 1 Or Nvl(b.排班方式, 0) = 3)
               Order By a.Id) Loop
    If c_安排.安排id <> Nvl(n_安排id, 0) Then
      l_安排id.Extend();
      l_安排id(l_安排id.Count) := c_安排.安排id;
      n_安排id := c_安排.安排id;
    End If;
    If c_安排.记录id Is Not Null Then
      l_记录id.Extend();
      l_记录id(l_记录id.Count) := c_安排.记录id;
    End If;
  End Loop;

  Forall I In 1 .. l_安排id.Count
    Update 临床出诊安排 Set 项目id = 项目id_In Where ID = l_安排id(I);

  Forall I In 1 .. l_记录id.Count
    Update 临床出诊记录 Set 项目id = 项目id_In Where ID = l_记录id(I);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊号源_Modify;
/

--89938:胡俊勇,2017-01-11,临嘱单转科换页
Create Or Replace Procedure Zl_病人医嘱打印_Insert
(
  病人id_In 病人医嘱记录.病人id%Type,
  主页id_In 病人医嘱记录.主页id%Type,
  婴儿_In   病人医嘱记录.婴儿%Type,
  期效_In   病人医嘱记录.医嘱期效%Type,
  行数_In   Number
  --功能：将病人没有打印过的医嘱插入 病人医嘱打印 
  --参数：行数_In：报表医嘱单一页可以打多少行 
  --      行数_In医嘱单报表的行数，通常是28行。 
) Is
  n_序号       病人医嘱记录.序号%Type;
  n_医嘱id     病人医嘱记录.Id%Type;
  n_重整标记   Number;
  v_Max_Date   Date;
  d_重整       Date;
  d_Pdate      Date;
  n_换页打     Number;
  n_打重开     Number;
  n_转科       Number;
  n_页号       Number;
  n_行号       Number;
  n_位置       Number;
  n_打印模式   Number;
  n_打给药方式 Number;
  n_Lzzkhy     Number;
  v_Tmp        Varchar2(200);

  --c_Advice 取出待打印的医嘱，在打印临嘱时转科医嘱都会读取出来，后面要判断是不是要生成打印记录
  Cursor c_Advice Is
    Select 医嘱id, 顺序, 打印标记, 特殊医嘱, 换页
    From (With Printtable As (Select a.Id As 医嘱id, a.序号 As 顺序, 0 As 打印标记, Null As 特殊医嘱,
                                     Decode(a.诊疗类别, 'Z', Decode(b.操作类型, '3', 3, '4', 4, 0), 0) As 换页, a.诊疗项目id
                              From 病人医嘱记录 A, 诊疗项目目录 B
                              Where a.病人id = 病人id_In And a.主页id = 主页id_In And Nvl(a.婴儿, 0) = 婴儿_In And a.诊疗项目id = b.Id(+) And
                                    (期效_In = 0 And (a.医嘱期效 = 0 Or n_位置 In (-1, 0, 2) And a.医嘱期效 = 1 And a.诊疗类别 = 'Z' And
                                    b.操作类型 In ('5', '3', '11')) Or
                                    期效_In = 1 And a.医嘱期效 = 1 And
                                    Not (n_位置 = 0 And Nvl(a.诊疗类别, 'X') = 'Z' And Nvl(b.操作类型, 'X') In ('5', '3', '11')) Or
                                    期效_In = 1 And a.医嘱期效 = 1 And n_位置 = 0 And a.诊疗类别 = 'Z' And b.操作类型 = '3') And
                                    a.医嘱状态 Not In (-1, 2) And (n_打印模式 = 1 And a.医嘱状态 = 1 Or a.医嘱状态 <> 1) And
                                    Nvl(a.屏蔽打印, 0) = 0 And Not Exists
                               (Select 1 From 病人医嘱记录 W Where w.诊疗类别 = 'F' And w.Id = a.前提id) And a.序号 > n_序号 And
                                    a.病人来源 = 2)
           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
           From 病人医嘱记录 L, 诊疗项目目录 I, Printtable P
           Where l.Id = p.医嘱id And l.诊疗项目id = i.Id And
                 (l.诊疗类别 Not In ('5', '6', '7', 'E') Or l.诊疗类别 = 'E' And Nvl(i.操作类型, '0') Not In ('2', '3') Or
                 i.Id Is Null) And l.相关id Is Null
           Union All
           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
           From 病人医嘱记录 L, Printtable P
           Where l.Id = p.医嘱id And l.诊疗类别 In ('5', '6')
           Union All
           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
           From 病人医嘱记录 L, 诊疗项目目录 I, Printtable P
           Where l.Id = p.医嘱id And l.诊疗项目id = i.Id And l.诊疗类别 = 'E' And i.操作类型 = '2' And l.相关id Is Null And n_打给药方式 = 1
           Union All
           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
           From Printtable P
           Where p.诊疗项目id Is Null
           Order By 顺序);


  Cursor c_Advice_Redo Is
    Select 医嘱id, 顺序, 打印标记, 特殊医嘱, 换页
    From (With Printtable As (Select a.Id As 医嘱id, a.序号 As 顺序, 0 As 打印标记, Null As 特殊医嘱,
                                     Decode(a.诊疗类别, 'Z', Decode(b.操作类型, '3', 3, '4', 4, 0), 0) As 换页, a.诊疗项目id
                              From 病人医嘱记录 A, 诊疗项目目录 B
                              Where a.病人id = 病人id_In And a.主页id = 主页id_In And Nvl(a.婴儿, 0) = 婴儿_In And a.诊疗项目id = b.Id(+) And
                                    (期效_In = 0 And (a.医嘱期效 = 0 Or n_位置 In (-1, 0, 2) And a.医嘱期效 = 1 And a.诊疗类别 = 'Z' And
                                    b.操作类型 In ('5', '3', '11')) Or
                                    期效_In = 1 And a.医嘱期效 = 1 And
                                    Not (n_位置 = 0 And Nvl(a.诊疗类别, 'X') = 'Z' And Nvl(b.操作类型, 'X') In ('5', '3', '11'))) And
                                    a.医嘱状态 Not In (-1, 2) And (n_打印模式 = 1 And a.医嘱状态 = 1 Or a.医嘱状态 <> 1) And
                                    Nvl(a.屏蔽打印, 0) = 0 And Not Exists
                               (Select 1 From 病人医嘱记录 Where 诊疗类别 = 'F' And ID = a.前提id) And a.序号 > n_序号 And Exists
                               (Select 1 From 病人医嘱状态 C Where a.Id = c.医嘱id And c.操作时间 >= v_Max_Date) And a.病人来源 = 2)
           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
           From 病人医嘱记录 L, 诊疗项目目录 I, Printtable P
           Where l.Id = p.医嘱id And l.诊疗项目id = i.Id And
                 (l.诊疗类别 Not In ('5', '6', '7', 'E') Or l.诊疗类别 = 'E' And Nvl(i.操作类型, '0') Not In ('2', '3') Or
                 i.Id Is Null) And l.相关id Is Null
           Union All
           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
           From 病人医嘱记录 L, Printtable P
           Where l.Id = p.医嘱id And l.诊疗类别 In ('5', '6')
           Union All
           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
           From 病人医嘱记录 L, 诊疗项目目录 I, Printtable P
           Where l.Id = p.医嘱id And l.诊疗项目id = i.Id And l.诊疗类别 = 'E' And i.操作类型 = '2' And l.相关id Is Null And n_打给药方式 = 1
           Union All
           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
           From Printtable P
           Where p.诊疗项目id Is Null
           Order By 顺序);


  --获取下一个或用的行号和页号
  Function Getnextpos
  (
    v_页号 病人医嘱打印.页号%Type,
    v_行号 病人医嘱打印.行号%Type,
    v_行数 Number
  ) Return Varchar2 Is
    n_p Number;
    n_r Number;
  Begin
    If v_行号 = 0 Then
      n_p := 1;
      n_r := 1;
    Elsif v_行号 = v_行数 Then
      n_p := v_页号 + 1;
      n_r := 1;
    Else
      n_p := v_页号;
      n_r := v_行号 + 1;
    End If;
    Return(n_p || ',' || n_r);
  End;

Begin
  n_位置       := Zl_To_Number(Nvl(zl_GetSysParameter('转科和出院打印', 1254), 0));
  n_打印模式   := Zl_To_Number(Nvl(zl_GetSysParameter('医嘱单打印模式', 1253), 0));
  n_打给药方式 := Zl_To_Number(Nvl(zl_GetSysParameter('药品用法单独打印一行', 1254), 0));
  n_Lzzkhy     := Zl_To_Number(Nvl(zl_GetSysParameter('临嘱单转科换页', 1254), 0));

  If 期效_In = 1 Then
    d_重整 := To_Date('1900-01-01', 'YYYY-MM-DD');
  Else
    Select 医嘱重整时间 Into d_重整 From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
    If d_重整 Is Null Then
      d_重整 := To_Date('1900-01-01', 'YYYY-MM-DD');
    End If;
  End If;
  v_Max_Date := d_重整;
  Begin
    Select 医嘱id, 打印时间, 页号, 行号
    Into n_医嘱id, d_Pdate, n_页号, n_行号
    From (Select 医嘱id, 打印时间, 页号, 行号
           From 病人医嘱打印
           Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And 医嘱id Is Not Null
           Order By 页号 Desc, 行号 Desc)
    Where Rownum < 2;
  
    Select Nvl(Max(序号), 0)
    Into n_序号
    From 病人医嘱记录
    Where ID = (Select Nvl(a.相关id, a.Id) From 病人医嘱记录 A Where a.Id = n_医嘱id);
  
    If 期效_In = 0 Then
      If d_Pdate Is Not Null Then
        If d_Pdate < d_重整 And d_重整 <> To_Date('1900-01-01', 'YYYY-MM-DD') Then
          n_重整标记 := 1;
          n_序号     := 0;
        End If;
      End If;
    End If;
  Exception
    When Others Then
      n_页号 := 0;
      n_行号 := 0;
      n_序号 := 0;
  End;

  If 期效_In = 0 Then
    n_换页打 := Zl_To_Number(Nvl(zl_GetSysParameter('重整和术后医嘱换页打印', 1254), 0));
    n_打重开 := Zl_To_Number(Nvl(zl_GetSysParameter('转科换页后在首行打印重开医嘱', 1254), 0));
    If n_医嘱id Is Not Null And n_打重开 = 1 Then
      Select Count(1)
      Into n_转科
      From 病人医嘱记录 A, 诊疗项目目录 B
      Where a.诊疗项目id = b.Id(+) And a.Id = n_医嘱id And a.诊疗类别 = 'Z' And b.操作类型 = '3';
    End If;
  End If;

  v_Tmp  := Getnextpos(n_页号, n_行号, 行数_In);
  n_页号 := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
  n_行号 := Substr(v_Tmp, Instr(v_Tmp, ',') + 1);

  --插入重整医嘱，只插入一条 
  If n_重整标记 = 1 Then
    If n_换页打 = 1 Then
      If n_行号 <> 1 Then
        n_行号 := 1;
        n_页号 := n_页号 + 1;
      End If;
    End If;
    Insert Into 病人医嘱打印
      (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
    Values
      (-1 * Null, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, 0, Null);
    v_Tmp  := Getnextpos(n_页号, n_行号, 行数_In);
    n_页号 := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
    n_行号 := Substr(v_Tmp, Instr(v_Tmp, ',') + 1);
  End If;

  --转科医嘱换页打医嘱重开字样 
  If n_换页打 = 1 And n_转科 = 1 And 期效_In = 0 Then
    If n_重整标记 = 1 Then
      --前面打了重整就不换页了 
      If n_打重开 = 1 Then
        Insert Into 病人医嘱打印
          (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
        Values
          (-1 * Null, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, 0, 1);
        v_Tmp  := Getnextpos(n_页号, n_行号, 行数_In);
        n_页号 := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
        n_行号 := Substr(v_Tmp, Instr(v_Tmp, ',') + 1);
      End If;
    Else
      If n_打重开 = 1 Then
        --打重开字样 
        If n_行号 <> 1 Then
          n_行号 := 1;
          n_页号 := n_页号 + 1;
        End If;
        Insert Into 病人医嘱打印
          (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
        Values
          (-1 * Null, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, 0, 1);
        v_Tmp  := Getnextpos(n_页号, n_行号, 行数_In);
        n_页号 := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
        n_行号 := Substr(v_Tmp, Instr(v_Tmp, ',') + 1);
      End If;
    End If;
  End If;
  n_转科 := 0;

  --最近次重整后,需要打印的医嘱，考虑换页打印情况转科术后 
  ---r_Print.换页 对特殊医嘱标记，4－术后，3－转科 
  If v_Max_Date = To_Date('1900-01-01', 'YYYY-MM-DD') Then
    For r_Print In c_Advice Loop
      ----换页或者打医嘱重开字样 
      If n_换页打 = 1 And n_转科 = 1 And 期效_In = 0 Then
        If n_打重开 = 1 Then
          --打重开字样 
          If n_行号 <> 1 Then
            n_行号 := 1;
            n_页号 := n_页号 + 1;
          End If;
          Insert Into 病人医嘱打印
            (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
          Values
            (-1 * Null, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, 0, 1);
          v_Tmp  := Getnextpos(n_页号, n_行号, 行数_In);
          n_页号 := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
          n_行号 := Substr(v_Tmp, Instr(v_Tmp, ',') + 1);
        Else
          --只是单纯换一页 
          If n_行号 <> 1 Then
            n_行号 := 1;
            n_页号 := n_页号 + 1;
          End If;
        End If;
        n_转科 := 0;
      End If;
    
      If 期效_In = 1 And n_转科 = 1 And n_Lzzkhy = 1 Then
        If n_行号 <> 1 Then
          n_行号 := 1;
          n_页号 := n_页号 + 1;
        End If;
        n_转科 := 0;
      End If;
    
      If r_Print.换页 = 4 And n_换页打 = 1 Then
        --术后医嘱换页 
        --如果行号为1说明已经是新的一页的第一行,否则换页 
        If n_行号 <> 1 Then
          n_行号 := 1;
          n_页号 := n_页号 + 1;
        End If;
      End If;
    
      If 期效_In = 0 Or 期效_In = 1 And (n_位置 = 2 Or n_位置 = 1 Or r_Print.换页 <> 3) Then
        Insert Into 病人医嘱打印
          (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
        Values
          (r_Print.医嘱id, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, r_Print.打印标记, r_Print.特殊医嘱);
        v_Tmp  := Getnextpos(n_页号, n_行号, 行数_In);
        n_页号 := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
        n_行号 := Substr(v_Tmp, Instr(v_Tmp, ',') + 1);
      End If;
      --启用了转科换页打重开字样，则插入一重开医嘱标记，此处一定换页，因为转科换页前要先打出转科医嘱， 
      --这里不插入数据，只进行标记，再下一次循时才插入。如果转科医嘱是最后一条是不用打印新开字样的。 
      If r_Print.换页 = 3 Then
        n_转科 := 1;
      End If;
    End Loop;
  Else
    For r_Print In c_Advice_Redo Loop
      ----换页或者打医嘱重开字样 
      If n_换页打 = 1 And n_转科 = 1 And 期效_In = 0 Then
        If n_打重开 = 1 Then
          --打重开字样 
          If n_行号 <> 1 Then
            n_行号 := 1;
            n_页号 := n_页号 + 1;
          End If;
          Insert Into 病人医嘱打印
            (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
          Values
            (-1 * Null, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, 0, 1);
          v_Tmp  := Getnextpos(n_页号, n_行号, 行数_In);
          n_页号 := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
          n_行号 := Substr(v_Tmp, Instr(v_Tmp, ',') + 1);
        Else
          --只是单纯换一页 
          If n_行号 <> 1 Then
            n_行号 := 1;
            n_页号 := n_页号 + 1;
          End If;
        End If;
        n_转科 := 0;
      End If;
    
      If r_Print.换页 = 4 And n_换页打 = 1 Then
        --术后医嘱换页 
        --如果行号为1说明已经是新的一页的第一行,否则换页 
        If n_行号 <> 1 Then
          n_行号 := 1;
          n_页号 := n_页号 + 1;
        End If;
      End If;
      Insert Into 病人医嘱打印
        (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
      Values
        (r_Print.医嘱id, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, r_Print.打印标记, r_Print.特殊医嘱);
      v_Tmp  := Getnextpos(n_页号, n_行号, 行数_In);
      n_页号 := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
      n_行号 := Substr(v_Tmp, Instr(v_Tmp, ',') + 1);
      --启用了转科换页打重开字样，则插入一重开医嘱标记，此处一定换页，因为转科换页前要先打出转科医嘱 
      --这里不插入数据，只进行标记，再下一次循时才插入。如果转科医嘱是最后一条是不用打印新开字样的。 
    
      If r_Print.换页 = 3 And 期效_In = 0 Then
        n_转科 := 1;
      End If;
    End Loop;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱打印_Insert;
/

--104911:胡俊勇,2017-01-11,护士站配液医嘱销帐
--104750:刘尔旋,2017-01-09,销帐申请原因
Create Or Replace Procedure Zl_病人费用销帐_Insert
(
  Id_In         病人费用销帐.费用id%Type,
  收费细目id_In 病人费用销帐.收费细目id%Type,
  申请部门id_In 病人费用销帐.申请部门id%Type,
  数量_In       病人费用销帐.数量%Type,
  申请人_In     病人费用销帐.申请人%Type,
  申请时间_In   病人费用销帐.申请时间%Type,
  申请类别_In   病人费用销帐.申请类别%Type, --对药品和卫材有效:0-未发药(料);1-已发药(料);其他为0
  删除标志_In   Integer := 0, --删除病人费用销帐时的条件:1-删除时不管申请类别,0-删除时,根据申请类别来进行删除(因为可能出现在申请销帐时,存在已执行和未执行两种状态)
  配药id_In     Integer := 0,
  销帐原因_In   病人费用销帐.销帐原因%Type := Null
) As
  n_审核部门id   病人费用销帐.审核部门id%Type;
  n_申请类别     病人费用销帐.申请类别%Type;
  n_开单科室病区 病人费用销帐.审核部门id%Type;
  n_执行科室病区 病人费用销帐.审核部门id%Type;
  n_跟踪在用     材料特性.跟踪在用%Type;
  n_执行状态     住院费用记录.执行状态%Type;
  v_收费类别     住院费用记录.收费类别%Type;
  n_实际数量     药品收发记录.实际数量%Type;
  n_医嘱id       住院费用记录.Id%Type;
  n_主页id       住院费用记录.Id%Type;
  v_No           住院费用记录.No%Type;
  n_病人id       住院费用记录.病人id%Type;
  n_病人科室id   住院费用记录.病人科室id%Type;
  n_Icu科室id    住院费用记录.病人科室id%Type;
  n_已申请数量   药品收发记录.实际数量%Type;
  n_序号         住院费用记录.序号%Type;

  n_Temp    Number;
  n_Icu     Number;
  n_Cnt     Number;
  v_Err_Msg Varchar2(500);
  Err_Item Exception;
  n_审核标志       病案主页.审核标志%Type;
  n_住院状态       病案主页.状态%Type;
  n_病人审核方式   Number(2);
  n_未入科禁止记账 Number(2);

Begin
  Begin
    Select Count(1)
    Into n_Cnt
    From 住院费用记录 A, 住院费用记录 B
    Where a.No = b.No And Mod(a.记录性质, 10) = Mod(b.记录性质, 10) And Nvl(a.价格父号, a.序号) = Nvl(b.价格父号, b.序号) And b.Id = Id_In
    Group By a.No, Mod(a.记录性质, 10), Nvl(a.价格父号, a.序号)
    Having Nvl(Sum(a.结帐金额), 0) <> 0;
  Exception
    When Others Then
      n_Cnt := 0;
  End;
  If n_Cnt > 0 Then
    v_Err_Msg := '申请销帐的记录已被他人结帐';
    Raise Err_Item;
  End If;

  Select a.收费类别, a.No, Nvl(b.跟踪在用, 0), Decode(Nvl(申请类别_In, 0), 0, a.病人病区id, a.执行部门id), 医嘱序号, 病人id, Nvl(主页id, 0), 序号
  Into v_收费类别, v_No, n_跟踪在用, n_审核部门id, n_医嘱id, n_病人id, n_主页id, n_序号
  From 住院费用记录 A, 材料特性 B
  Where a.收费细目id = b.材料id(+) And a.Id = Id_In;

  If Nvl(n_主页id, 0) <> 0 Then
  
    n_病人审核方式   := Nvl(zl_GetSysParameter(185), 0);
    n_未入科禁止记账 := Nvl(zl_GetSysParameter(215), 0);
    If n_病人审核方式 = 1 Or n_未入科禁止记账 = 1 Then
      Begin
        Select 审核标志, 状态
        Into n_审核标志, n_住院状态
        From 病案主页
        Where 病人id = Nvl(n_病人id, 0) And 主页id = Nvl(n_主页id, 0);
      Exception
        When Others Then
          n_审核标志 := 0;
          n_住院状态 := 0;
      End;
      If n_未入科禁止记账 = 1 And n_住院状态 = 1 Then
        v_Err_Msg := '病人未入科,禁止对病人相关费用的操作!';
        Raise Err_Item;
      End If;
    
      If n_病人审核方式 = 1 Then
        If Nvl(n_审核标志, 0) = 1 Then
          v_Err_Msg := '该病人目前正在审核费用,不能进行费用相关调整!';
          Raise Err_Item;
        End If;
        If Nvl(n_审核标志, 0) = 2 Then
          v_Err_Msg := '该病人目前已经完成了费用审核,不能进行费用相关调整!';
          Raise Err_Item;
        End If;
      End If;
    End If;
  
  End If;

  Select 出院科室id
  Into n_病人科室id
  From 病人信息 A, 病案主页 B
  Where a.病人id = b.病人id And a.主页id = b.主页id And a.病人id = n_病人id;

  Select Decode(Count(*), 0, 0, 1) Into n_Icu From 部门性质说明 B Where b.部门id = n_病人科室id And b.工作性质 = 'ICU';
  If n_Icu = 1 Then
    --检查是否是当前操作员属性于ICU
    Select Decode(Count(Distinct a.用户名), 0, 0, 1)
    Into n_Icu
    From 上机人员表 A, 部门性质说明 B, 部门人员 C
    Where a.用户名 = User And a.人员id = c.人员id And c.部门id = b.部门id And b.工作性质 = 'ICU';
  End If;

  If n_Icu = 1 Then
    n_Icu科室id := n_病人科室id;
    If Nvl(申请类别_In, 0) = 0 Then
      n_审核部门id := n_病人科室id;
    End If;
  End If;

  If Instr(',5,6,7', ',' || v_收费类别) > 0 Or v_收费类别 = '4' And Nvl(n_跟踪在用, 0) = 1 Then
    n_申请类别 := 申请类别_In;
  Else
    n_申请类别 := 0;
  End If;

  --取消以前申请的重新生成(按批次申请时，不能取消，因为费用id相同，每个批次可分别申请)
  If 配药id_In = 0 Then
    If Nvl(删除标志_In, 0) = 1 Then
      Delete 病人费用销帐 Where 费用id = Id_In And 状态 = 0;
    Else
      Delete 病人费用销帐 Where 费用id = Id_In And 申请类别 = n_申请类别 And 状态 = 0;
    End If;
  End If;
  If 数量_In <> 0 Then
    --审核科室
    --1.药品费用或跟踪在用的卫材:
    --    a. 如果未执行,则按病人病区作为审核部门;
    --    b. 如果已执行,则按执行部门ID作为审核部门
    --2.医技科室开单的费用(即开单科室<>病人科室)，销帐审核科室为开单科室,
    --  如果开单科室是属于病区的临床科室,则销帐科室为所属病区(即护士记病人在其它科室发生的费用)
    --  (如果执行科室x属于a、b两病区，则a、b两病区都可以作为销帐确认科室,取第一个，如果a病区同时是病人病区，则只有a病区能确认)。
    --3.病区产生的费用,没有经过划价审核的,销帐审核科室为病人病区(如果已经被执行，则为执行部门,否则为病人病区)
    --  经过划价审核的,销帐审核科室为执行科室。
    --  如果执行科室是属于病区的临床科室，则销帐审核科室为所属病区
    --  (如果执行科室x属于a、b两病区，则a、b两病区都可以作为销帐确认科室,取第一个，如果a病区同时是病人病区，则只有a病区能确认)。
    --4.如果当前操作员是属于ICU,并且病人当前科室也为ICU以及未执行的项目,由ICU科室来来进行审核.
  
    If Nvl(n_跟踪在用, 0) = 1 Then
      If Nvl(申请类别_In, 0) = 0 Then
        --要检查未执行的数量必须大于等于申请数量,才会通过
        Select Sum(Nvl(付数, 0) * Nvl(实际数量, 0))
        Into n_实际数量
        From 药品收发记录
        Where 审核日期 Is Null And 费用id = Id_In And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0;
      
        If Nvl(n_实际数量, 0) < Nvl(数量_In, 0) Then
          Select '在单据号<<' || v_No || '>>中卫材料为:' || Chr(13) || 编码 || '-' || 名称 || Chr(13) || '的申请数量(' ||
                  LTrim(To_Char(数量_In, '9999999990.99')) || ')大于了待发料数量(' ||
                  LTrim(To_Char(Nvl(n_实际数量, 0), '9999999990.99')) || '),不能进行申请销帐!'
          Into v_Err_Msg
          From 收费项目目录
          Where ID = 收费细目id_In;
          Raise Err_Item;
        End If;
      End If;
    Else
      --a.执行科室或其所属病区:：0:未执行;1:完全执行;2:部份执行
      Select Decode(b.病区id, Null, a.执行部门id, Nvl(c.病区id, b.病区id)), Decode(a.执行状态, 1, 1, 2, 1, 0)
      Into n_执行科室病区, n_执行状态
      From 住院费用记录 A, 病区科室对应 B, 病区科室对应 C
      Where a.Id = Id_In And a.执行部门id = b.科室id(+) And a.执行部门id = c.科室id(+) And a.病人病区id = c.病区id(+) And Rownum < 2;
    
      --b.开单科室或其所属病区
      Select Decode(b.病区id, Null, a.开单部门id, Nvl(c.病区id, b.病区id))
      Into n_开单科室病区
      From 住院费用记录 A, 病区科室对应 B, 病区科室对应 C
      Where a.Id = Id_In And a.开单部门id = b.科室id(+) And a.开单部门id = c.科室id(+) And a.病人病区id = c.病区id(+) And Rownum < 2;
    
      For v_费用 In (Select 收费类别, Nvl(执行状态, 0) As 执行状态, 病人病区id, 执行部门id, 开单部门id, 病人科室id, 划价人, 操作员姓名
                   From 住院费用记录
                   Where ID = Id_In) Loop
        If Instr('567', v_费用.收费类别, 1) > 0 Then
          n_Temp       := Case
                            When 申请类别_In Is Null Then
                             Nvl(v_费用.执行状态, 0)
                            Else
                             申请类别_In
                          End;
          n_审核部门id := Case
                        When n_Temp = 0 Then
                         v_费用.病人病区id
                        Else
                         v_费用.执行部门id
                      End;
          If n_Temp = 0 And n_Icu = 1 Then
            --ICU为ICU科室
            n_审核部门id := n_Icu科室id;
          End If;
        Else
          If v_费用.开单部门id = v_费用.病人科室id Then
            --临床产生的费用
            If Nvl(v_费用.划价人, '-') = v_费用.操作员姓名 Or v_费用.划价人 Is Null Then
              --划价审核
              n_审核部门id := Case
                            When n_执行状态 = 1 Then
                             v_费用.执行部门id
                            Else
                             v_费用.病人病区id
                          End;
            Else
              n_审核部门id := n_执行科室病区;
            End If;
          Else
            n_审核部门id := n_执行科室病区;
          End If;
          If n_执行状态 = 0 And n_Icu = 1 Then
            --ICU为ICU科室
            n_审核部门id := n_Icu科室id;
          End If;
        End If;
      End Loop;
    
      If Instr(',5,6,7', ',' || v_收费类别) > 0 And Nvl(申请类别_In, Nvl(n_执行状态, 0)) = 0 Then
        --需要检查未执行的数量必须大于等于申请数量,才会通过
        Select Sum(Nvl(付数, 0) * Nvl(实际数量, 0))
        Into n_实际数量
        From 药品收发记录
        Where 审核日期 Is Null And 费用id = Id_In And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0;
        If Nvl(n_实际数量, 0) < Nvl(数量_In, 0) Then
          Select '在单据号<<' || v_No || '>>中药品为:' || Chr(13) || 编码 || '-' || 名称 || Chr(13) || '的申请数量(' ||
                  LTrim(To_Char(数量_In, '9999999990.99')) || ')不能大于待发药数量(' ||
                  LTrim(To_Char(Nvl(n_实际数量, 0), '9999999990.99')) || '),不能进行申请销帐!'
          Into v_Err_Msg
          From 收费项目目录
          Where ID = 收费细目id_In;
          Raise Err_Item;
        End If;
      End If;
    End If;
    --解决并发问题:当前申请数量+已经申请数量不能大于某笔申请数量
    Select Sum(Nvl(数量, 0)) Into n_已申请数量 From 病人费用销帐 Where 费用id = Id_In And Nvl(状态, 0) <> 2;
    Select Sum(Nvl(付数, 1) * Nvl(数次, 0))
    Into n_实际数量
    From 住院费用记录
    Where NO = v_No And 序号 = n_序号 And Nvl(价格父号, 0) = 0 And 记录状态 In (0, 1, 3) And
          记录性质 In (Select 记录性质 From 住院费用记录 Where ID = Id_In);
    If Nvl(n_实际数量, 0) < Nvl(n_已申请数量, 0) + Nvl(数量_In, 0) Then
      Select '在单据号<<' || v_No || '>>收费项目:' || Chr(13) || 编码 || '-' || 名称 || Chr(13) || '的申请数量(' ||
              LTrim(To_Char(Nvl(n_已申请数量, 0) + Nvl(数量_In, 0), '9999999990.99')) || ')不能大于记帐数量(' ||
              LTrim(To_Char(Nvl(n_实际数量, 0), '9999999990.99')) || '),不能进行申请销帐!'
      Into v_Err_Msg
      From 收费项目目录
      Where ID = 收费细目id_In;
      Raise Err_Item;
    End If;
  
    If n_医嘱id <> 0 And 配药id_In <> 0 Then
      --如果是输液配药中心的，则更新相关表字段
      Select Count(1)
      Into n_Temp
      From 输液配药状态
      Where 配药id = 配药id_In And 操作类型 = 9 And 操作时间 = 申请时间_In;
      If n_Temp = 0 Then
        Insert Into 输液配药状态(配药id, 操作类型, 操作人员, 操作时间, 操作说明)Values(配药id_In, 9, 申请人_In, 申请时间_In, 销帐原因_In);
      End If;
      Update 输液配药记录
      Set 操作人员 = 申请人_In, 操作时间 = 申请时间_In, 操作状态 = 9
      Where ID = 配药id_In
      Returning 部门id Into n_审核部门id;
    End If;
    Insert Into 病人费用销帐
      (费用id, 申请类别, 收费细目id, 审核部门id, 申请部门id, 数量, 申请人, 申请时间, 状态, 销帐原因)
    Values
      (Id_In, n_申请类别, 收费细目id_In, n_审核部门id, 申请部门id_In, 数量_In, 申请人_In, 申请时间_In, 0, 销帐原因_In);
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人费用销帐_Insert;
/

--104444:廖思奇,2017-02-23,修正  Zl_病理号码_序号获取  变量名称
--104444:廖思奇,2017-02-20,修正脚本检查问题17-2-20 Q102 规范
--104444:廖思奇,2017-01-06,增加一种获得病理号码记录当前序号的方式
Create Or Replace Function Zl_病理号码_序号获取
(  
  Id_In 病理号码规则.Id%Type
) Return Number Is
  Cursor c_Patholnumrule(v_Id 病理号码规则.Id%Type) Is
    Select 年, 月, 日 From 病理号码规则 Where ID = v_Id;
  r_Patholnumrule c_Patholnumrule%RowType;
  n_Curnum        Number;
  n_Year          Number;
  n_Month         Number;
  n_Day           Number;
  v_Error         Varchar(255);
  Err_Custom Exception;
Begin

  Open c_Patholnumrule(Id_In);
  Fetch c_Patholnumrule
    Into r_Patholnumrule;

  If c_Patholnumrule%RowCount = 0 Then
    Close c_Patholnumrule;
    v_Error := '不能读取病理号码生成规则，过程终止。';
    Raise Err_Custom;
  End If;
  n_Year  := 0;
  n_Month := 0;
  n_Day   := 0;

  If r_Patholnumrule.年 = 1 Then
    Select To_Char(Sysdate, 'yyyy') Into n_Year From Dual;
  End If;
  If r_Patholnumrule.月 = 1 Then
    Select To_Char(Sysdate, 'mm') Into n_Month From Dual;
  End If;
  If r_Patholnumrule.日 = 1 Then
    Select To_Char(Sysdate, 'dd') Into n_Day From Dual;
  End If;

  Select Nvl(Max(当前序号), 0)
  Into n_Curnum
  From 病理号码记录
  Where 号码规则id = Id_In And 年 = n_Year And 月 = n_Month And 日 = n_Day;

  If n_Curnum = 0 Then
    Select Nvl(Max(当前序号), 0)
    Into n_Curnum
    From 病理号码记录
    Where 类型 = Id_In - 1 And 年 = n_Year And 月 = n_Month And 日 = n_Day;
  End If;

  Close c_Patholnumrule;
  Return n_Curnum + 1;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病理号码_序号获取;
/


--104643:张德婷,2017-01-04,静配中心通过扫描完成配药操作时，添加操作说明
CREATE OR REPLACE Procedure Zl_输液配药记录_配药
(
  配药id_In   In Varchar2, --ID串:ID1,ID2....
  操作人员_In In 输液配药记录.操作人员%Type := Null,
  操作时间_In In 输液配药记录.操作时间%Type := Null,
  操作说明_In In 输液配药状态.操作说明%Type := Null
) Is
  v_Tansid   Varchar2(20);
  v_Tmp      Varchar2(4000);
  v_No       Varchar2(20);
  v_Usercode Varchar2(100);
  n_操作状态 输液配药记录.操作状态%Type;
  v_Error    Varchar2(255);
  n_People      number(1);
  n_row      number(2);
  d_执行时间 date;
  v_配药类型 varchar2(50);
  n_项目id   number(18);
  v_收费项目id varchar2(200);
  v_info    varchar2(200);
  v_id varchar2(20);
  n_数次 number(2);
  n_count number(18);
  n_Out number(10);
  n_OutNum number(10);
  n_打包状态 number(1);
  Err_Custom Exception;

  Cursor c_Bill Is
    Select a.病人id, a.主页id, a.标识号, a.姓名, a.性别, a.年龄, a.床号, a.费别, a.病人病区id, a.病人科室id, a.婴儿费, e.药品id, b.库房id,f.配药类型
    From 住院费用记录 A, 药品收发记录 B, 输液配药记录 C, 输液配药内容 D, 药品规格 E, 输液药品属性 F
    Where a.Id = b.费用id And b.Id = d.收发id And d.记录id = c.Id And b.药品id = e.药品id And b.药品id = f.药品id And Nvl(c.是否打包, 0) <> 1 And c.Id = v_Tansid;

Begin
  v_Usercode := Zl_Identity;
  v_Usercode := Substr(v_Usercode, Instr(v_Usercode, ';') + 1);
  v_Usercode := Substr(v_Usercode, Instr(v_Usercode, ',') + 1);
  v_Usercode := Substr(v_Usercode, 1, Instr(v_Usercode, ',') - 1);
  n_People:=Nvl(zl_GetSysParameter('配置费按病人收取', 1345), 0);
  n_Out:=Nvl(zl_GetSysParameter('出院病人不收配置费', 1345), 0);

  If 配药id_In Is Null Then
    v_Tmp := Null;
  Else
    v_Tmp := 配药id_In || ',';
  End If;

  While v_Tmp Is Not Null Loop
    --分解单据ID串
    v_Tansid := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
    v_Tmp    := Replace(',' || v_Tmp, ',' || v_Tansid || ',');

    --检查当前输液单的状态是否为待摆药状态
    Begin
      Select 操作状态,执行时间,nvl(是否打包,0)  Into n_操作状态,d_执行时间,n_打包状态 From 输液配药记录 Where ID = v_Tansid;

      if n_操作状态>3 then
        v_Error := '该数据已被操作，不能进行发药！';
        Raise Err_Custom;
      end if;
    Exception
      When Others Then
        v_Error := '该数据已被操作！';
        Raise Err_Custom;
    End;

    Update 输液配药记录 Set 操作状态 = 4, 操作人员 = 操作人员_In, 操作时间 = 操作时间_In Where ID = v_Tansid;
    Insert Into 输液配药状态 (配药id, 操作类型, 操作人员, 操作时间,操作说明) Values (v_Tansid, 4, 操作人员_In, 操作时间_In,操作说明_In);

    if n_打包状态=0 then
      n_count:=0;
      Select Nextno(14) Into v_No From Dual;
      For r_Bill In c_Bill Loop
        Select count(病人id) into n_OutNum From 病案主页 where 主页ID=r_Bill.主页id And 病人ID=r_Bill.病人id  And (Nvl(状态,0)=3 Or 出院日期 Is Not NULL);
        if n_count=0 and (n_OutNum=0 or n_out=0) then
          --收取材料费
          --v_收费项目id:='6970,2;6971,1;';
          select zl_fun_PIVACustom(v_Tansid) into  v_收费项目id from dual;
          While v_收费项目id Is Not Null Loop
             v_info:= Substr(v_收费项目id, 1, Instr(v_收费项目id, ';') - 1);
             v_收费项目id := Replace(';' || v_收费项目id, ';' || v_info || ';');
             

             v_id:= Substr(v_info, 1, Instr(v_info, ',') - 1);
             v_info := Replace(',' || v_info, ',' || v_id || ',');

            For r_Item In (Select a.Id 收费细目id, a.类别 收费类别, a.计算单位, a.加班加价 加班标志, d.Id 收入项目id, d.收据费目, b.现价
                           From 收费项目目录 A, 收费价目 B, 收入项目 D
                           Where a.Id = b.收费细目id And b.收入项目id = d.Id And a.id=v_id and
                                 b.执行日期 <= Sysdate And
                                 (b.终止日期 >= Sysdate Or b.终止日期 Is Null)) Loop
              if n_count=0 then
                Insert Into 输液配药附费 (配药id, NO,病人id) Values (v_Tansid, v_No, r_Bill.病人id);
              end if;

              n_count:=n_count+1;
              Zl_住院记帐记录_Insert(v_No, n_count, r_Bill.病人id, r_Bill.主页id, r_Bill.标识号, r_Bill.姓名, r_Bill.性别, r_Bill.年龄, r_Bill.床号,
                               r_Bill.费别, r_Bill.病人病区id, r_Bill.病人科室id, r_Item.加班标志, r_Bill.婴儿费, r_Bill.库房id, 操作人员_In, Null,
                               r_Item.收费细目id, r_Item.收费类别, r_Item.计算单位, Null, Null, Null, 1,v_info, Null, r_Bill.库房id, Null,
                               r_Item.收入项目id, r_Item.收据费目, r_Item.现价, r_Item.现价*v_info, r_Item.现价*v_info, Null, Sysdate, Sysdate, Null, Null,
                               v_Usercode, 操作人员_In);
            End Loop;
          end loop;
        end if;


        select count(项目id) into n_项目id from 配置收费方案 where 配药类型=substr(r_Bill.配药类型,INSTR(r_Bill.配药类型,'-',1,1)+1);
        if n_项目id<>0 then
          n_row:=0;
          select nvl(项目id,0) into n_项目id from 配置收费方案 where 配药类型=substr(r_Bill.配药类型,INSTR(r_Bill.配药类型,'-',1,1)+1);
          if n_People=1 then
            select count(配药id) into n_row from 输液配药附费 A,住院费用记录 B,输液配药记录 C where A.No=b.no and A.配药ID=C.id and b.病人id=r_Bill.病人id And B.记录状态=1 and B.收费细目id=n_项目id and d_执行时间 Between Trunc(c.执行时间) And Trunc(c.执行时间+1) - 1 / 24 / 60 / 60;
          end if;
        else
          n_row:=1;
        end if;

        if n_row=0 and (n_OutNum=0 or n_out=0) then
          For r_Item In (Select a.Id 收费细目id, a.类别 收费类别, a.计算单位, a.加班加价 加班标志, d.Id 收入项目id, d.收据费目, b.现价
                         From 收费项目目录 A, 收费价目 B, 收入项目 D
                         Where a.Id = b.收费细目id And b.收入项目id = d.Id And a.id=n_项目id and
                               b.执行日期 <= Sysdate And
                               (b.终止日期 >= Sysdate Or b.终止日期 Is Null)) Loop
            if n_count=0 then
              Insert Into 输液配药附费 (配药id, NO,病人id) Values (v_Tansid, v_No, r_Bill.病人id);
            end if;

            n_count:=n_count+1;
            Zl_住院记帐记录_Insert(v_No, n_count, r_Bill.病人id, r_Bill.主页id, r_Bill.标识号, r_Bill.姓名, r_Bill.性别, r_Bill.年龄, r_Bill.床号,
                             r_Bill.费别, r_Bill.病人病区id, r_Bill.病人科室id, r_Item.加班标志, r_Bill.婴儿费, r_Bill.库房id, 操作人员_In, Null,
                             r_Item.收费细目id, r_Item.收费类别, r_Item.计算单位, Null, Null, Null, 1, 1, Null, r_Bill.库房id, Null,
                             r_Item.收入项目id, r_Item.收据费目, r_Item.现价, r_Item.现价, r_Item.现价, Null, Sysdate, Sysdate, Null, Null,
                             v_Usercode, 操作人员_In);
          End Loop;
        end if;

        if n_People<>1 and n_row=0 then
          Exit;
        end if;
      End Loop;
    end if;
  End Loop;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_输液配药记录_配药;
/

--104247:胡俊勇,2017-01-03,停嘱原因修改
CREATE OR REPLACE Procedure Zl_病人医嘱发送_Insert
( 
  医嘱id_In     病人医嘱发送.医嘱id%Type, 
  发送号_In     病人医嘱发送.发送号%Type, 
  记录性质_In   病人医嘱发送.记录性质%Type, 
  No_In         病人医嘱发送.No%Type, 
  记录序号_In   病人医嘱发送.记录序号%Type, 
  发送数次_In   病人医嘱发送.发送数次%Type, 
  首次时间_In   病人医嘱发送.首次时间%Type, 
  末次时间_In   病人医嘱发送.末次时间%Type, 
  发送时间_In   病人医嘱发送.发送时间%Type, 
  执行状态_In   病人医嘱发送.执行状态%Type, 
  执行部门id_In 病人医嘱发送.执行部门id%Type, 
  计费状态_In   病人医嘱发送.计费状态%Type, 
  First_In      Number := 0, 
  样本条码_In   病人医嘱发送.样本条码%Type := Null, 
  操作员编号_In 人员表.编号%Type := Null, 
  操作员姓名_In 人员表.姓名%Type := Null, 
  领药号_In     未发药品记录.领药号%Type := Null, 
  门诊记帐_In   病人医嘱发送.门诊记帐%Type := Null, 
  分解时间_In   Varchar2 := Null 
  --功能：填写病人医嘱发送记录 
  --参数： 
  --      医嘱id_In=要发送的每个医嘱ID 
  --      First_IN=表示是否一组医嘱的第一医嘱行,以便处理医嘱相关内容(如成药,配方的第一行,因为给药途径,配方煎法,用法可能为叮嘱不发送) 
  --      发送数次_IN,首次时间_IN,末次时间_IN:对"持续性"长嘱,不填写发送数次,可填写首末次时间(用于回退)。 
  --      门诊记帐_In,住院临嘱发送到门诊记帐时才填写为1（因为记录性质是2，用于区分住院记帐），其余情况均填空。 
) Is 
  --包含病人及医嘱(一组医嘱中第一行)相关信息的游标 
  Cursor c_Advice Is 
    Select Nvl(a.相关id, a.Id) As 组id, a.序号, a.病人id, a.主页id, a.婴儿, a.姓名, a.病人科室id, c.操作类型, a.诊疗类别, a.医嘱期效, a.医嘱状态, a.医嘱内容, 
           a.开嘱医生, a.开嘱时间, a.开始执行时间, a.上次执行时间, a.执行终止时间, a.执行时间方案, a.频率次数, a.频率间隔, a.间隔单位, a.开嘱科室id, a.标本部位, a.执行科室id, 
           a.相关id, a.诊疗项目id 
    From 病人医嘱记录 A, 诊疗项目目录 C 
    Where a.诊疗项目id = c.Id And a.Id = 医嘱id_In; 
  r_Advice c_Advice%RowType; 
 
  --包含病人(婴儿)的所有未停长嘱(含配方长嘱),婴儿传入-1表示都处理 
  Cursor c_Needstop 
  ( 
    v_病人id   病人医嘱记录.病人id%Type, 
    v_主页id   病人医嘱记录.主页id%Type, 
    v_婴儿     病人医嘱记录.婴儿%Type, 
    v_Stoptime Date 
  ) Is 
    Select a.Id, a.诊疗类别, b.操作类型, b.执行频率 
    From 病人医嘱记录 A, 诊疗项目目录 B 
    Where a.诊疗项目id = b.Id(+) And a.病人id = v_病人id And a.主页id = v_主页id And (v_婴儿 = -1 Or Nvl(a.婴儿, 0) = Nvl(v_婴儿, 0)) And 
          Nvl(a.医嘱期效, 0) = 0 And a.医嘱状态 Not In (1, 2, 4, 8, 9) And a.开始执行时间 < v_Stoptime 
    Order By a.序号; 
  --包含病人(婴儿)的已停但未确认的长嘱,终止执行时间在指定时间之后,婴儿传入-1表示都处理 
  Cursor c_Havestop 
  ( 
    v_病人id   病人医嘱记录.病人id%Type, 
    v_主页id   病人医嘱记录.主页id%Type, 
    v_婴儿     病人医嘱记录.婴儿%Type, 
    v_Stoptime Date 
  ) Is 
    Select ID 
    From 病人医嘱记录 
    Where 病人id = v_病人id And 主页id = v_主页id And (v_婴儿 = -1 Or Nvl(婴儿, 0) = Nvl(v_婴儿, 0)) And Nvl(医嘱期效, 0) = 0 And 
          医嘱状态 = 8 And 执行终止时间 > v_Stoptime And 开始执行时间 < v_Stoptime 
    Order By 序号; 
 
  --其它临时变量 
  v_婴儿     病人医嘱记录.婴儿%Type; 
  v_持续性   Number(1); --是否持续性长嘱 
  v_Autostop Number(1); 
  v_Date     Date; 
  v_Temp     Varchar2(255); 
  v_人员编号 人员表.编号%Type; 
  v_人员姓名 人员表.姓名%Type; 
  v_停止时间 病人医嘱记录.开嘱时间%Type; 
  n_执行状态 病人医嘱发送.执行状态%Type; 
  d_开始时间 病人医嘱记录.开始执行时间%Type; 
 
  v_Stopadviceids 病人医嘱记录.医嘱内容%Type; 
  n_Adviceid      病人医嘱记录.病人id%Type; 
  n_标记          Number(18); 
  v_Error         Varchar2(255); 
  Err_Custom Exception; 
Begin 
  --当前操作人员 
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then 
    v_人员编号 := 操作员编号_In; 
    v_人员姓名 := 操作员姓名_In; 
  Else 
    v_Temp     := Zl_Identity; 
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1); 
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1); 
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1); 
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1); 
  End If; 
  --如果首次时间为空则填入开始执行时间 
  If 首次时间_In Is Null Or 分解时间_In Is Null Or 末次时间_In Is Null Then 
    Select 开始执行时间 Into d_开始时间 From 病人医嘱记录 Where ID = 医嘱id_In; 
  End If; 
 
  Open c_Advice; 
  Fetch c_Advice 
    Into r_Advice; 
  Close c_Advice; 
 
  --是一组医嘱的第一行时处理医嘱内容 
  If Nvl(First_In, 0) = 1 Then 
    --并发操作检查 
    --------------------------------------------------------------------------------------- 
    If Nvl(r_Advice.医嘱状态, 0) = 4 Then 
      --检查要发送的医嘱是否被作废 
      v_Error := '"' || r_Advice.姓名 || '"的医嘱"' || r_Advice.医嘱内容 || '"已经被其他人作废。' || Chr(13) || Chr(10) || 
                 '该病人的医嘱发送失败。请重新读取发送清单再试。'; 
      Raise Err_Custom; 
    End If; 
 
    If Nvl(r_Advice.医嘱期效, 0) = 0 Then 
      --长嘱：含成药长嘱,配方长嘱,非药"可选频率"长嘱,非药"持续性"长嘱 
 
      --检查长嘱是否已被发送 
      If r_Advice.上次执行时间 Is Not Null Then 
        If r_Advice.上次执行时间 >= 首次时间_In Then 
          v_Error := '"' || r_Advice.姓名 || '"的医嘱"' || r_Advice.医嘱内容 || '"已经被其他人发送。' || Chr(13) || Chr(10) || 
                     '该病人的医嘱发送失败。请重新读取发送清单再试。'; 
          Raise Err_Custom; 
        End If; 
      End If; 
 
      --检查长嘱发送前是否已被自动停止(如术后) 
      If r_Advice.执行终止时间 Is Not Null Then 
        If 首次时间_In > r_Advice.执行终止时间 Then 
          v_Error := '"' || r_Advice.姓名 || '"的医嘱"' || r_Advice.医嘱内容 || '"已经被停止。' || Chr(13) || Chr(10) || 
                     '该病人的医嘱发送失败。请重新读取发送清单再试。'; 
          Raise Err_Custom; 
        End If; 
      End If; 
    Elsif Nvl(r_Advice.医嘱状态, 0) In (8, 9) Then 
      --临嘱：含配方临嘱 
 
      --检查是否已被发送(或因其它原因自动停止) 
      v_Error := '"' || r_Advice.姓名 || '"的医嘱"' || r_Advice.医嘱内容 || '"已经被其他人发送。' || Chr(13) || Chr(10) || 
                 '该病人的医嘱发送失败。请重新读取发送清单再试。'; 
      Raise Err_Custom; 
    End If; 
 
    --发送后的医嘱处理 
    --------------------------------------------------------------------------------------- 
    If Nvl(r_Advice.医嘱期效, 0) = 0 Then 
      --长期医嘱:更新上次执行时间 
      Update 病人医嘱记录 Set 上次执行时间 = 末次时间_In Where ID = r_Advice.组id Or 相关id = r_Advice.组id; 
 
      --判断是否持续性长嘱 
      v_持续性 := 0; 
      If r_Advice.执行时间方案 Is Null And (Nvl(r_Advice.频率次数, 0) = 0 Or Nvl(r_Advice.频率间隔, 0) = 0 Or r_Advice.间隔单位 Is Null) Then 
        v_持续性 := 1; 
      End If; 
 
      --预定了终止时间且未停止的自动停止 
      If r_Advice.执行终止时间 Is Not Null And Nvl(r_Advice.医嘱状态, 0) Not In (8, 9) Then 
        v_Autostop := 0; 
        If v_持续性 = 1 Then 
          --非药"持续性"长嘱 
          If Trunc(末次时间_In) = Trunc(r_Advice.执行终止时间 - 1) Then 
            v_Autostop := 1; --终止这天不执行 
          End If; 
        Elsif Zl_Advicenexttime(医嘱id_In) > r_Advice.执行终止时间 Then 
          --成药长嘱或非药"可选频率"长嘱 
          v_Autostop := 1; --如果是等于,还可以执行一次 
        End If; 
 
        If v_Autostop = 1 Then 
          Update 病人医嘱记录 
          Set 医嘱状态 = 8, 停嘱时间 = 末次时间_In, 停嘱医生 = r_Advice.开嘱医生 
          Where ID = r_Advice.组id Or 相关id = r_Advice.组id;  
          v_Temp := zl_GetSysParameter(271);
          If v_Temp = '1' Then
            v_Temp := '自动停止：预定停止时间。';
          Else
            v_Temp := Null;
          End If;
          Insert Into 病人医嘱状态
            (医嘱id, 操作类型, 操作人员, 操作时间, 操作说明)
            Select ID, 8, r_Advice.开嘱医生, 发送时间_In, v_Temp
            From 病人医嘱记录
            Where ID = r_Advice.组id Or 相关id = r_Advice.组id;
          v_Stopadviceids := v_Stopadviceids || ',' || r_Advice.组id; 
        End If; 
      End If; 
    Else 
      --临嘱停止。 
      --住院医生发送时自动校对、停止：校对是以Sysdate取的,为避免重复,停止时间也取Sysdate 
      Select Sysdate Into v_Date From Dual; 
      Update 病人医嘱记录 
      Set 医嘱状态 = 8, 执行终止时间 = 末次时间_In, 
          --为一次性临嘱时没有 
          上次执行时间 = 末次时间_In, 
          --为一次性临嘱时没有 
          停嘱时间 = v_Date, 
          --发送时间_IN, 
          停嘱医生 = r_Advice.开嘱医生 
      Where ID = r_Advice.组id Or 相关id = r_Advice.组id; 
 
      Insert Into 病人医嘱状态 
        (医嘱id, 操作类型, 操作人员, 操作时间) 
        Select ID, 8, v_人员姓名, v_Date --发送时间_IN 
        From 病人医嘱记录 
        Where ID = r_Advice.组id Or 相关id = r_Advice.组id; 
    End If; 
 
    --特殊医嘱的处理 
    --------------------------------------------------------------------------------------- 
    If r_Advice.诊疗类别 = 'Z' And Nvl(r_Advice.操作类型, '0') <> '0' Then 
      --(1-留观;2-住院;)3-转科;4-术后(不发送);5-出院;6-转院,7-会诊,11-死亡 
 
      --几种特殊医嘱要自动停止病人该医嘱之前(按时间算)所有未停的长嘱 
      If r_Advice.操作类型 In ('3', '5', '6', '11') Then 
        If Nvl(r_Advice.婴儿, 0) = 0 Then 
          v_婴儿 := -1; 
        Else 
          v_婴儿 := Nvl(r_Advice.婴儿, 0); 
        End If; 
        For r_Needstop In c_Needstop(r_Advice.病人id, r_Advice.主页id, v_婴儿, r_Advice.开始执行时间) Loop 
          Select Decode(Sign(开始执行时间 - r_Advice.开始执行时间), 1, 开始执行时间, r_Advice.开始执行时间) 
          Into v_停止时间 
          From 病人医嘱记录 
          Where ID = r_Needstop.Id; 
          Update 病人医嘱记录 
          Set 医嘱状态 = 8, 执行终止时间 = v_停止时间, 停嘱时间 = 发送时间_In, 停嘱医生 = r_Advice.开嘱医生 
          Where ID = r_Needstop.Id; 
 
          Insert Into 病人医嘱状态 
            (医嘱id, 操作类型, 操作人员, 操作时间) 
            Select ID, 8, v_人员姓名, 发送时间_In From 病人医嘱记录 Where ID = r_Needstop.Id; 
          v_Stopadviceids := v_Stopadviceids || ',' || r_Needstop.Id; 
        End Loop; 
        --已停止未确认的长嘱,终止时间在医嘱开始后的,调前其终止时间(同时多个特殊医嘱的情况) 
        For r_Havestop In c_Havestop(r_Advice.病人id, r_Advice.主页id, v_婴儿, r_Advice.开始执行时间) Loop 
          Update 病人医嘱记录 
          Set 执行终止时间 = Decode(Sign(开始执行时间 - r_Advice.开始执行时间), 1, 开始执行时间, r_Advice.开始执行时间), 停嘱时间 = 发送时间_In, 
              停嘱医生 = r_Advice.开嘱医生 
          Where ID = r_Havestop.Id; 
 
          --不修改停止医嘱的操作人员，因为停止时，医生可能已进行电子签名 
          Update 病人医嘱状态 Set 操作时间 = 发送时间_In Where 医嘱id = r_Havestop.Id And 操作类型 = 8; 
          v_Stopadviceids := v_Stopadviceids || ',' || r_Havestop.Id; 
        End Loop; 
        --处理长期备用医嘱(没有执行（发送）过的标记未用）,同时处理临嘱 
        Update 病人医嘱记录 
        Set 执行标记 = -1 
        Where 病人id = r_Advice.病人id And 主页id = r_Advice.主页id And 
              (医嘱期效 = 0 And 执行频次 = '必要时' And 上次执行时间 Is Null And 医嘱状态 In (3, 5, 6, 7) Or 
              医嘱期效 = 1 And 执行频次 = '需要时' And 医嘱状态 = 3) And 执行标记 <> -1; 
      End If; 
 
      --具体的特殊处理 
      If Nvl(r_Advice.婴儿, 0) = 0 Then 
        If r_Advice.操作类型 = '3' And 执行部门id_In Is Not Null And r_Advice.病人科室id Is Not Null And 
           Nvl(r_Advice.病人科室id, 0) <> Nvl(执行部门id_In, 0) Then 
          --转科医嘱,将病人登记转科到"执行科室ID"(在院病人且当前科室与转入科室不同才处理) 
          Zl_病人变动记录_Change(r_Advice.病人id, r_Advice.主页id, 执行部门id_In, v_人员编号, v_人员姓名); 
        Elsif r_Advice.操作类型 In ('5', '6', '11') Then 
          --出院、转院、死亡医嘱,将病人标记为预出院 
          Begin 
            Select 开始时间 
            Into v_Date 
            From 病人变动记录 
            Where 开始时间 Is Not Null And 终止时间 Is Null And 病人id = r_Advice.病人id And 主页id = r_Advice.主页id; 
          Exception 
            When Others Then 
              v_Date := To_Date('1900-01-01', 'YYYY-MM-DD'); 
          End; 
          If r_Advice.开始执行时间 <= v_Date Then 
            v_Error := '医嘱"' || r_Advice.医嘱内容 || '"的开始时间应大于该病人上次变动时间 ' || To_Char(v_Date, 'YYYY-MM-DD HH24:Mi') || ' 。'; 
            Raise Err_Custom; 
          End If; 
          Zl_病人变动记录_Preout(r_Advice.病人id, r_Advice.主页id, r_Advice.开始执行时间); 
        End If; 
      End If; 
    End If; 
    --12小时未执行的备用临嘱处理为标记未用 
    If r_Advice.医嘱期效 = 1 Then 
      Update 病人医嘱记录 
      Set 执行标记 = -1 
      Where 病人id = r_Advice.病人id And 主页id = r_Advice.主页id And 执行标记 <> -1 And 医嘱期效 = 1 And 执行频次 = '需要时' And 
            Sysdate - 开始执行时间 > 0.5 And 医嘱状态 = 3; 
    End If; 
  End If; 
 
  --填写发送记录 
  --------------------------------------------------------------------------------------- 
  n_执行状态 := 执行状态_In; 
  If 执行状态_In = 1 Then 
    v_Temp := zl_GetSysParameter(186); 
    If v_Temp = '11' Then 
      If r_Advice.诊疗类别 = 'E' And r_Advice.操作类型 in ('1','8') Or r_Advice.诊疗类别 = 'K' Then 
        n_执行状态 := 0; 
      End If; 
    Elsif v_Temp = '01' Then 
      If r_Advice.诊疗类别 = 'E' And r_Advice.操作类型 = '1' Then 
        n_执行状态 := 0; 
      End If; 
    Elsif v_Temp = '10' Then 
      If r_Advice.诊疗类别 = 'E' And r_Advice.操作类型 = '8' Or r_Advice.诊疗类别 = 'K' Then 
        n_执行状态 := 0; 
      End If; 
    End If; 
  End If; 
 
  Insert Into 病人医嘱发送 
    (医嘱id, 发送号, 记录性质, NO, 记录序号, 发送数次, 发送人, 发送时间, 执行状态, 执行部门id, 计费状态, 首次时间, 末次时间, 样本条码, 门诊记帐) 
  Values 
    (医嘱id_In, 发送号_In, 记录性质_In, No_In, 记录序号_In, 发送数次_In, v_人员姓名, 发送时间_In, n_执行状态, 执行部门id_In, 计费状态_In, 
     Nvl(首次时间_In, d_开始时间), Nvl(末次时间_In, d_开始时间), 样本条码_In, 门诊记帐_In); 
     
  --手术和检查医嘱同步更新主医嘱的计费状态   
  If 计费状态_In = 1 And  r_Advice.组ID <> 医嘱id_In  And (r_Advice.诊疗类别 = 'D' Or r_Advice.诊疗类别 = 'F') Then   
     Update 病人医嘱发送 Set 计费状态 = 1 Where 医嘱ID = r_Advice.组ID And 发送号 = 发送号_In;
  End If;
 
  --领药号的填写 
  If 领药号_In Is Not Null Then 
    Update 未发药品记录 Set 领药号 = 领药号_In Where NO = No_In And 单据 = 9 And 领药号 Is Null; 
    Update 药品收发记录 Set 产品合格证 = 领药号_In Where NO = No_In And 单据 = 9 And 产品合格证 Is Null; 
  End If; 
 
  --自动填为已执行时，需要同步处理费用执行状态及审核划价状态 
  If 执行状态_In = 1 Then 
    Zl_病人医嘱执行_Finish(医嘱id_In, 发送号_In, Null, Null, v_人员编号, v_人员姓名, 执行部门id_In); 
  End If; 
 
  --产生医嘱执行时间记录(只产生主记录的) 
  If Nvl(分解时间_In, To_Char(d_开始时间, 'yyyy-mm-dd hh24:mi:ss')) Is Not Null Then 
    If r_Advice.相关id Is Null Then 
      Insert Into 医嘱执行时间 
        (要求时间, 医嘱id, 发送号) 
        Select To_Date(Column_Value, 'yyyy-mm-dd hh24:mi:ss'), 医嘱id_In, 发送号_In 
        From Table(f_Str2list(Nvl(分解时间_In, To_Char(d_开始时间, 'yyyy-mm-dd hh24:mi:ss')))); 
    End If; 
  End If; 
 
  --病历书写时机的填写 
  If r_Advice.诊疗类别 = 'F' Then 
    --一组手术只调一次 
    If r_Advice.相关id Is Null Then 
      If Not r_Advice.标本部位 Is Null Then 
        v_Date := To_Date(r_Advice.标本部位, 'yyyy-mm-dd hh24:mi:ss'); 
      Else 
        v_Date := r_Advice.开始执行时间; 
      End If; 
      Zl_电子病历时机_Insert(r_Advice.病人id, r_Advice.主页id, 2, '手术', r_Advice.开嘱科室id, r_Advice.开嘱医生, v_Date, v_Date, 
                       r_Advice.执行科室id); 
    End If; 
  Elsif r_Advice.诊疗类别 = 'Z' And r_Advice.操作类型 = '7' Then 
    Zl_电子病历时机_Insert(r_Advice.病人id, r_Advice.主页id, 2, '会诊', r_Advice.开嘱科室id, r_Advice.开嘱医生, r_Advice.开始执行时间, 
                     r_Advice.开始执行时间, r_Advice.执行科室id); 
  Elsif r_Advice.诊疗类别 = 'Z' And r_Advice.操作类型 = '8' Then 
    Zl_电子病历时机_Insert(r_Advice.病人id, r_Advice.主页id, 2, '抢救', r_Advice.开嘱科室id, r_Advice.开嘱医生, r_Advice.开始执行时间, 
                     r_Advice.开始执行时间, r_Advice.执行科室id); 
  Elsif r_Advice.诊疗类别 = 'Z' And r_Advice.操作类型 = '11' Then 
    Zl_电子病历时机_Insert(r_Advice.病人id, r_Advice.主页id, 2, '死亡', r_Advice.开嘱科室id, r_Advice.开嘱医生, r_Advice.开始执行时间, 
                     r_Advice.开始执行时间, r_Advice.执行科室id); 
  End If; 
  --额外调用(知情文件允许的诊疗类别才调用) 
  If Instr('C,D,E,F,G,K,L', r_Advice.诊疗类别) > 0 Then 
    Zl_电子病历时机_Insert(r_Advice.病人id, r_Advice.主页id, 2, '知情文书', r_Advice.开嘱科室id, r_Advice.开嘱医生, r_Advice.开始执行时间, 
                     r_Advice.开始执行时间, r_Advice.执行科室id, r_Advice.诊疗项目id, r_Advice.医嘱内容); 
  End If; 
  --医嘱停止消息的处理 
  If v_Stopadviceids Is Not Null Then 
    v_Stopadviceids := Substr(v_Stopadviceids, 2); 
    Select Max(a.Id) 
    Into n_标记 
    From 病人医嘱记录 A 
    Where a.Id In (Select Column_Value From Table(f_Num2list(v_Stopadviceids))) And a.医嘱期效 = 0 And a.医嘱状态 = 8 And 
          Nvl(a.执行标记, 0) <> -1 And a.病人来源 <> 3; 
    If n_标记 Is Not Null Then 
      Select Max(a.Id) 
      Into n_Adviceid 
      From 病人医嘱记录 A 
      Where a.Id In (Select Column_Value From Table(f_Num2list(v_Stopadviceids))) And a.紧急标志 = 1 And a.医嘱期效 = 0 And 
            a.医嘱状态 = 8 And Nvl(a.执行标记, 0) <> -1 And a.病人来源 <> 3; 
      If n_Adviceid Is Not Null Then 
        Select Nvl(Max(0), 2) 
        Into n_标记 
        From 业务消息清单 A 
        Where a.病人id = r_Advice.病人id And a.就诊id = r_Advice.主页id And a.类型编码 = 'ZLHIS_CIS_002' And a.优先程度 = 2 And 
              a.是否已阅 = 0; 
      Else 
        n_Adviceid := n_标记; 
        Select Nvl(Max(0), 1) 
        Into n_标记 
        From 业务消息清单 A 
        Where a.病人id = r_Advice.病人id And a.就诊id = r_Advice.主页id And a.类型编码 = 'ZLHIS_CIS_002' And a.是否已阅 = 0; 
      End If; 
      If n_标记 > 0 Then 
        For R In (Select a.病人性质 As 性质, a.出院科室id As 科室id, a.当前病区id As 病区id 
                  From 病案主页 A 
                  Where a.病人id = r_Advice.病人id And a.主页id = r_Advice.主页id) Loop 
          Zl_业务消息清单_Insert(r_Advice.病人id, r_Advice.主页id, r.科室id, r.病区id, r.性质, '有新停止医嘱。', '0010', 'ZLHIS_CIS_002', 
                           n_Adviceid, n_标记, 0, Null, r.病区id); 
        End Loop; 
      End If; 
    End If; 
  End If; 
Exception 
  When Err_Custom Then 
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]'); 
  When Others Then 
    zl_ErrorCenter(SQLCode, SQLErrM); 
End Zl_病人医嘱发送_Insert;
/

--104247:胡俊勇,2017-01-03,停嘱原因
Create Or Replace Procedure Zl_病人医嘱记录_停止
(
  --功能：停止指定的医嘱
  --说明：一并给药的只能调用一次
  --参数：ID_IN=相关ID为NULL的医嘱的ID(给药途径,中药用法,检查项目,主要手术,及独立医嘱)
  --      内部调用_IN=是否其他过程内部在调用，主要区分是否手工调用停止护理等级
  Id_In         病人医嘱记录.Id%Type,
  终止时间_In   病人医嘱记录.执行终止时间%Type,
  停嘱医生_In   病人医嘱记录.停嘱医生%Type,
  内部调用_In   Number := 0,
  医师资格_In   Number := 0,
  停嘱审核_In   Number := 0,
  操作员编号_In 人员表.编号%Type := Null,
  操作员姓名_In 人员表.姓名%Type := Null,
  停嘱原因_In   病人医嘱状态.操作说明%Type := Null
) Is
  v_状态       病人医嘱记录.医嘱状态%Type;
  v_医嘱内容   病人医嘱记录.医嘱内容%Type;
  v_护理等级id 病案主页.护理等级id%Type;
  v_病人id     病案主页.病人id%Type;
  v_主页id     病案主页.主页id%Type;
  v_婴儿       病人医嘱记录.婴儿%Type;
  v_诊疗类别   病人医嘱记录.诊疗类别%Type;
  v_操作类型   诊疗项目目录.操作类型%Type;

  Cursor c_Oldinfo Is
    Select b.*
    From (Select c.*
           From 病人变动记录 C
           Where c.病人id = v_病人id And c.主页id = v_主页id And
                 c.开始时间 = (Select Min(开始时间)
                           From 病人变动记录
                           Where 病人id = v_病人id And 主页id = v_主页id And 开始时间 > 终止时间_In) And
                 Nvl(c.终止时间 || '', '空') =
                 (Select Nvl(Min(终止时间) || '', '空')
                  From 病人变动记录
                  Where 病人id = v_病人id And 主页id = v_主页id And 开始时间 > 终止时间_In)) A, 病人变动记录 B
    
    Where b.病人id = v_病人id And b.主页id = v_主页id And a.开始时间 = b.终止时间 And a.开始原因 = b.终止原因 And a.附加床位 = b.附加床位
    Union
    Select *
    From 病人变动记录
    Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 Is Null And 开始时间 <= 终止时间_In;

  Cursor c_Endinfo Is
    Select * From 病人变动记录 Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 Is Null;
  r_Oldinfo  c_Oldinfo%RowType;
  r_Endinfo  c_Endinfo%RowType;
  v_终止原因 病人变动记录.终止原因%Type;
  v_终止时间 病人变动记录.终止时间%Type;
  v_终止人员 病人变动记录.终止人员%Type;

  v_Date     Date;
  v_Count    Number;
  v_Temp     Varchar2(255);
  v_人员编号 病人变动记录.操作员编号%Type;
  v_人员姓名 病人变动记录.操作员姓名%Type;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --检查医嘱状态是否正确:并发操作
  Select a.医嘱状态, a.医嘱内容, a.病人id, a.主页id, Nvl(a.婴儿, 0), Nvl(a.诊疗类别, '*') As 诊疗类别, b.操作类型
  Into v_状态, v_医嘱内容, v_病人id, v_主页id, v_婴儿, v_诊疗类别, v_操作类型
  From 病人医嘱记录 A, 诊疗项目目录 B
  Where a.诊疗项目id = b.Id(+) And a.Id = Id_In;
  If v_状态 In (4, 8, 9) Then
    v_Error := '医嘱"' || v_医嘱内容 || '"已经被作废或停止，不能再停止。';
    Raise Err_Custom;
  End If;

  --检查是否是输液配液记录，并是否已经锁定
  Select Count(1) Into v_Count From 输液配药记录 Where 是否锁定 = 1 And 医嘱id = Id_In And 执行时间 > 终止时间_In;
  If v_Count > 0 Then
    v_Error := '医嘱"' || v_医嘱内容 || '"是输液药品，已经被输液配置中心锁定，不能停止。';
    Raise Err_Custom;
  End If;

  --当前操作人员
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
    v_人员编号 := 操作员编号_In;
    v_人员姓名 := 操作员姓名_In;
  Else
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;

  Select Sysdate Into v_Date From Dual;

  --判断是否具有执业医师或助理医师的资格和参数是否勾选
  If 医师资格_In > 0 Or 停嘱审核_In = 0 Then
    Update 病人医嘱记录
    Set 医嘱状态 = 8, 执行终止时间 = 终止时间_In, 停嘱医生 = Decode(审核标记, 2, 停嘱医生_In || Decode(停嘱医生, Null, '', '/' || 停嘱医生), 停嘱医生_In),
        停嘱时间 = v_Date, 审核标记 = Decode(审核标记, 2, 3, 审核标记)
    Where ID = Id_In Or 相关id = Id_In;
  
    Insert Into 病人医嘱状态
      (医嘱id, 操作类型, 操作人员, 操作时间, 操作说明)
      Select ID, 8, v_人员姓名, v_Date, 停嘱原因_In --护士停时记录为护士
      From 病人医嘱记录
      Where ID = Id_In Or 相关id = Id_In;
  Else
    --否则只修改审核标记，产生新的状态,实习医生名字填写
    Update 病人医嘱记录 Set 审核标记 = 2, 停嘱医生 = 停嘱医生_In Where ID = Id_In Or 相关id = Id_In;
  
    If 停嘱原因_In Is Null Then
      v_Temp := To_Char(终止时间_In, 'YYYY-MM-DD HH24:MI:SS');
    Else
      v_Temp := To_Char(终止时间_In, 'YYYY-MM-DD HH24:MI:SS') || '<T>' || 停嘱原因_In;
    End If;
  
    Insert Into 病人医嘱状态
      (医嘱id, 操作类型, 操作人员, 操作时间, 操作说明)
      Select ID, 13, v_人员姓名, v_Date, v_Temp --护士停时记录为护士
      From 病人医嘱记录
      Where ID = Id_In Or 相关id = Id_In;
  End If;

  --其他特殊处理
  If Nvl(内部调用_In, 0) = 0 And (医师资格_In > 0 Or 停嘱审核_In = 0) Then
    --停止病情医嘱时，变动病人病情
    If v_诊疗类别 = 'Z' And v_操作类型 In ('9', '10') Then
      Open c_Oldinfo; --必须在处理之前先打开
      Fetch c_Oldinfo
        Into r_Oldinfo;
      Open c_Endinfo;
      Fetch c_Endinfo
        Into r_Endinfo;
      If c_Endinfo%RowCount = 0 Then
        Close c_Endinfo;
        v_Error := '未发现该病人当前有效的变动记录！';
        Raise Err_Custom;
      End If;
      Select Count(*)
      Into v_Count
      From 病人变动记录
      Where 病人id = v_病人id And 主页id = v_主页id And 开始时间 Is Null And 终止时间 Is Null;
      If v_Count > 0 Then
        v_Error := '病人当前处于转科状态，请先办理转科确认或者取消转科状态。';
        Raise Err_Custom;
      End If;
    
      Update 病案主页 Set 当前病况 = '一般' Where 病人id = v_病人id And 主页id = v_主页id;
    
      --取消上次变动
      If r_Oldinfo.终止时间 Is Not Null Then
        v_终止时间 := r_Oldinfo.终止时间;
        v_终止原因 := r_Oldinfo.终止原因;
        v_终止人员 := r_Oldinfo.终止人员;
        --取消上次变动
        Update 病人变动记录
        Set 终止时间 = 终止时间_In, 终止原因 = 13, 终止人员 = v_人员姓名, 上次计算时间 = Null
        Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 = v_终止时间 And 终止原因 = v_终止原因;
        --更新将来的记录如果有停止到将来的则删除上次计算时间
        Update 病人变动记录
        Set 病情 = '一般', 上次计算时间 = Null
        Where 病人id = v_病人id And 主页id = v_主页id And 开始时间 > 终止时间_In;
      Else
        Update 病人变动记录
        Set 终止时间 = 终止时间_In, 终止原因 = 13, 终止人员 = v_人员姓名,
            上次计算时间 = Decode(Sign(Nvl(上次计算时间, 终止时间_In) - 终止时间_In), 1, Null, 上次计算时间)
        Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 Is Null;
      End If;
    
      While c_Oldinfo%Found Loop
        Insert Into 病人变动记录
          (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号, 操作员姓名,
           终止时间, 终止原因, 终止人员)
        Values
          (病人变动记录_Id.Nextval, v_病人id, v_主页id, 终止时间_In, 13, r_Oldinfo.附加床位, r_Oldinfo.病区id, r_Oldinfo.科室id,
           r_Oldinfo.护理等级id, r_Oldinfo.床位等级id, r_Oldinfo.床号, r_Oldinfo.责任护士, r_Oldinfo.经治医师, r_Oldinfo.主治医师,
           r_Oldinfo.主任医师, '一般', v_人员编号, v_人员姓名, v_终止时间, v_终止原因, v_终止人员);
      
        Fetch c_Oldinfo
          Into r_Oldinfo;
      End Loop;
    
      Close c_Oldinfo;
      Close c_Endinfo;
    Elsif v_诊疗类别 = 'H' And v_操作类型 = '1' And v_婴儿 = 0 Then
      --停止护理等级时，同时取消病人的护理等级费用
      Begin
        Select c.收费细目id
        Into v_护理等级id
        From 病人医嘱记录 A, 病人医嘱计价 C, 收费项目目录 D
        Where a.Id = c.医嘱id And c.收费细目id = d.Id And d.类别 = 'H' And Nvl(d.项目特性, 0) <> 0 And a.Id = Id_In And Rownum = 1 And
              Exists
         (Select 1 From 病案主页 Where 病人id = v_病人id And 主页id = v_主页id And 护理等级id = c.收费细目id);
      Exception
        When Others Then
          Null;
      End;
      If v_护理等级id Is Not Null Then
        --变动记录的时间加上秒，以便回退操作时区分同一分种的校对、停止等操作
        v_Date := To_Date(To_Char(终止时间_In, 'yyyy-mm-dd hh24:mi') || To_Char(v_Date, 'ss'), 'yyyy-mm-dd hh24:mi:ss');
        Zl_病人变动记录_Nurse(v_病人id, v_主页id, Null, v_Date, v_人员编号, v_人员姓名);
      End If;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱记录_停止;
/

--103917:陈刘,2016-12-28,婴儿记录出院体温
Create Or Replace Procedure Zl_体温单数据_Update
(
  文件id_In   In 病人护理文件.Id%Type, --病人护理文件ID
  发生时间_In In 病人护理数据.发生时间%Type, --护理数据的发生时间
  记录类型_In In 病人护理明细.记录类型%Type, --护理项目=1，上标说明=2，入出转标记=3，手术日标记=4,下标说明=6
  项目序号_In In 病人护理明细.项目序号%Type, --护理项目的序号，非护理项目固定为0
  记录内容_In In 病人护理明细.记录内容%Type := Null, --记录内容，如果内容为空，即清除以前的内容  36或36/37
  体温部位_In In 病人护理明细.体温部位%Type := Null, --删除数据时不用填写部位 除活动项目外
  复试合格_In In Number := 0,
  未记说明_In In 病人护理明细.未记说明%Type := Null, --未记说明
  他人记录_In In Number := 1,
  数据来源_In In 病人护理明细.数据来源%Type := 0,
  来源id_In   In 病人护理明细.来源id%Type := Null, --始终为原始记录的来源ID
  共用_In     In 病人护理明细.共用%Type := 0,
  项目首次_In In Number := 0, --汇总项目使用，保存数据前是否先删除一段时间内的数据信息。 1 删除
  开始时间_In In 病人护理数据.发生时间%Type := Null, --本记录有效跨度的开始时间
  结束时间_In In 病人护理数据.发生时间%Type := Null, --本记录有效跨度的终止时间，单独记录为每分钟，体温表为4小时,时间跨度内的相同项目记录要删除


  操作员_In   In 病人护理数据.保存人%Type := Null,
  检查科室_In In Number := 1
) Is
  n_项目序号 病人护理明细.项目序号%Type;
  n_记录标记 病人护理明细.记录标记%Type; --记录内容的特殊标志
  v_保存人   病人护理数据.保存人%Type;
  v_记录人   病人护理明细.记录人%Type;
  d_结束时间 病人护理数据.发生时间%Type;
  d_发生时间 病人护理数据.发生时间%Type;
  d_开始时间 病人护理数据.发生时间%Type;
  n_记录id   病人护理明细.记录id%Type;
  v_科室id   病人护理文件.科室id%Type;
  n_心率应用 护理记录项目.应用方式%Type;
  n_脉搏     护理记录项目.项目序号%Type := 2;
  n_体温     护理记录项目.项目序号%Type := 1;
  n_心率     护理记录项目.项目序号%Type := -1;
  n_项目性质 护理记录项目.项目性质%Type := 1;
  n_开始版本 病人护理明细.开始版本%Type;
  n_疼痛强度 护理记录项目.项目序号%Type;

  n_病人id       病人护理文件.病人id%Type;
  n_主页id       病人护理文件.主页id%Type;
  n_婴儿         病人护理文件.婴儿%Type;
  d_婴儿出院时间 病人医嘱记录.开始执行时间%Type;
  d_文件开始时间 病人护理文件.开始时间%Type;
  n_Preblue      Number;
  n_i            Number;
  n_Sqlrowcount  Number;
  Lngorder       Number;
  v_记录内容     病人护理明细.记录内容%Type;
  v_Data         病人护理明细.记录内容%Type;
  --主过程
  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  d_发生时间 := 发生时间_In;

  If d_发生时间 Is Null Then
    v_Error := '数据发生时间不能为空！';
    Raise Err_Custom;
  End If;

  If 开始时间_In Is Null Then
    d_开始时间 := d_发生时间;
  Else
    d_开始时间 := 开始时间_In;
  End If;

  If 结束时间_In Is Null Then
    d_结束时间 := d_开始时间;
  Else
    d_结束时间 := 结束时间_In;
  End If;

  --提取记录ID
  n_记录id := 0;
  If 操作员_In Is Null Then
    v_保存人 := Zl_Username;
  Else
    v_保存人 := 操作员_In;
  End If;
  ----------------------------------------------------------------------------------------------------------------------
  Begin
    Select Id Into n_记录id From 病人护理数据 Where 文件id = 文件id_In And 发生时间 = 发生时间_In;
  Exception
    When Others Then
      n_记录id := 0;
  End;

  --检查数据的发生时间是否对应科室
  ---------------------------------------------------------------------------------------------------------------------
  Select 病人id, 主页id, Nvl(婴儿, 0), 开始时间
  Into n_病人id, n_主页id, n_婴儿, d_文件开始时间
  From 病人护理文件
  Where Id = 文件id_In;
  d_婴儿出院时间 := Null;
  If n_婴儿 <> 0 Then
    Begin
      Select 开始执行时间
      Into d_婴儿出院时间
      From 病人医嘱记录 b, 诊疗项目目录 c
      Where b.诊疗项目id + 0 = c.Id And b.医嘱状态 = 8 And Nvl(b.婴儿, 0) <> 0 And c.类别 = 'Z' And
            Instr(',3,5,11,', ',' || c.操作类型 || ',', 1) > 0 And b.病人id = n_病人id And b.主页id = n_主页id And b.婴儿 = n_婴儿;
    Exception
      When Others Then
        d_婴儿出院时间 := Null;
    End;
  End If;
  If d_婴儿出院时间 Is Null Then
    v_科室id := 0;
    Begin
      Select a.科室id
      Into v_科室id
      From 病人变动记录 a, 病人护理文件 b
      Where a.科室id Is Not Null And a.病人id = b.病人id And a.主页id = b.主页id And b.Id = 文件id_In And
            (发生时间_In >= a.开始时间 And (发生时间_In < = Nvl(a.终止时间, Sysdate) Or a.终止时间 Is Null)) And Rownum < 2;
    Exception
      When Others Then
        v_科室id := 0;
    End;
    If v_科室id = 0 And 检查科室_In = 1 Then
      v_Error := '数据发生时间 ' || To_Char(发生时间_In, 'YYYY-MM-DD HH24:MI:SS') || ' 不在病人有效变动时间范围内，不能操作！';
      Raise Err_Custom;
    End If;
  Else
    If 发生时间_In < d_文件开始时间 Or (发生时间_In > d_婴儿出院时间 and 检查科室_In = 1)  Then
      v_Error := '数据发生时间 ' || To_Char(发生时间_In, 'YYYY-MM-DD HH24:MI:SS') || ' 不在病人有效变动时间范围内，不能操作！';
      Raise Err_Custom;
    End If;
  End If;
  --检查是不是本人的记录
  ---------------------------------------------------------------------------------------------------------------------
  If 他人记录_In = 0 And n_记录id > 0 Then
    v_记录人 := '';
    Begin
      Select 记录人
      Into v_记录人
      From 病人护理明细
      Where 记录id = n_记录id And 记录类型 = 记录类型_In And 项目序号 = 项目序号_In And 终止版本 Is Null And Rownum < 2
      Order By Nvl(记录标记, 0);
    Exception
      When Others Then
        v_记录人 := '';
    End;
    If v_记录人 Is Not Null And v_记录人 <> v_保存人 Then
      v_Error := '在' || To_Char(d_开始时间, 'yyyy-mm-dd hh24:mi:ss') || '至' || To_Char(d_结束时间, 'yyyy-mm-dd hh24:mi:ss') ||
                 '段内记录人不是当前人，你无权修改！';
      Raise Err_Custom;
    End If;
  End If;

  --提取疼痛强度曲线项目的项目序号
  Begin
    Select 项目序号 Into n_疼痛强度 From 体温记录项目 Where 记录名 = '疼痛强度';
  Exception
    When Others Then
      n_疼痛强度 := -999;
  End;
  --检查脉搏心率是否共用
  If 项目序号_In = n_脉搏 Then
    n_项目序号 := n_心率;
  Else
    n_项目序号 := 项目序号_In;
  End If;
  Begin
    Select 应用方式, 项目性质 Into n_心率应用, n_项目性质 From 护理记录项目 Where 项目序号 = n_项目序号;
  Exception
    When Others Then
      n_心率应用 := 0;
  End;

  ----清除某段时间内的护理数据信息
  --项目首次_In 汇总项目根据汇总时间段保存一天数据时先清除在保存 项目首次_In：=1
  --记录内容_In Is Null And 未记说明_In Is Null 则认为删除数据
  ---------------------------------------------------------------------------------------------------------------------
  If (项目首次_In = 1) Or (记录内容_In Is Null And 未记说明_In Is Null) Then
    For r_List In (Select l.Id, Count(*) As 记录数
                   From 病人护理文件 a, 病人护理数据 l, 病人护理明细 d
                   Where a.Id = l.文件id And l.Id = d.记录id And a.Id = 文件id_In And d.终止版本 Is Null And l.发生时间 >= d_开始时间 And
                         l.发生时间 <= d_结束时间
                   Group By l.Id) Loop
      n_Sqlrowcount := 0;
      If 记录类型_In = 2 Or 记录类型_In = 6 Then
        Delete 病人护理明细
        Where 记录id = r_List.Id And 记录类型 = 记录类型_In And 项目序号 = 项目序号_In And 终止版本 Is Null;
        n_Sqlrowcount := Sql%Rowcount;
      Else
        If 体温部位_In Is Not Null Then
          --此处主要针对活动项目
          Delete 病人护理明细
          Where 记录id = r_List.Id And 记录类型 = 记录类型_In And 项目序号 = 项目序号_In And Nvl(体温部位, '无') = Nvl(体温部位_In, '无') And
                终止版本 Is Null;
        Else
          Delete 病人护理明细
          Where 记录id = r_List.Id And 记录类型 = 记录类型_In And 项目序号 = 项目序号_In And 终止版本 Is Null;
        End If;
      
        n_Sqlrowcount := Sql%Rowcount;
        --如果脉搏和心率共用删除脉搏是同时删除心率数据
        If 项目序号_In = n_脉搏 And n_心率应用 = 2 Then
          Delete 病人护理明细
          Where 记录id = r_List.Id And 记录类型 = 记录类型_In And 项目序号 = n_心率 And 终止版本 Is Null;
          n_Sqlrowcount := n_Sqlrowcount + Sql%Rowcount;
        End If;
        --如果为收缩压/舒张压删除收缩压时同时删除舒张压数据
        If 项目序号_In = 4 Then
          Delete 病人护理明细
          Where 记录id = r_List.Id And 记录类型 = 记录类型_In And 项目序号 = 5 And 终止版本 Is Null;
          n_Sqlrowcount := n_Sqlrowcount + Sql%Rowcount;
        End If;
      End If;
      If n_Sqlrowcount >= r_List.记录数 Then
        Delete 病人护理数据 Where Id = r_List.Id;
      End If;
    End Loop;
  End If;

  If 记录内容_In Is Null And 未记说明_In Is Null Then
    Return;
  End If;

  --分解项目记录内容
  n_Preblue := 0;
  If 记录类型_In = 1 And Instr(',' || n_疼痛强度 || ',1,2,4,', ',' || 项目序号_In || ',', 1) > 0 Then
    n_Preblue := Nvl(Instr(Nvl(记录内容_In, ''), '/', 1), 0);
    If n_Preblue > 1 Then
      n_Preblue := 1;
    End If;
  End If;

  If 项目序号_In = 4 And n_Preblue = 0 Then
    v_Error := '血压数据格式错误! 格式:收缩压/舒张压。';
    Raise Err_Custom;
  End If;

  --确认开始版本号
  ---------------------------------------------------------------------------------------------------------------------
  n_开始版本 := 1;

  --改写病人护理数据：如果已经存在与病人、科室和发生时间相同的记录则修改，否则增加新的记录
  ---------------------------------------------------------------------------------------------------------------------
  --汇总项目是删除后在增加，可能开始提取的记录ID已经不存在。
  Begin
    Select Id Into n_记录id From 病人护理数据 Where Id = n_记录id;
  Exception
    When Others Then
      n_记录id := 0;
  End;

  If n_记录id = 0 Then
    Select 病人护理数据_Id.Nextval Into n_记录id From Dual;
    Insert Into 病人护理数据
      (Id, 文件id, 显示, 发生时间, 保存人, 保存时间, 最后版本)
    Values
      (n_记录id, 文件id_In, 0, d_发生时间, v_保存人, Sysdate, n_开始版本);
  End If;

  --检查删除物理降温数据或脉搏短轴数据
  If (项目序号_In = n_体温 Or 项目序号_In = n_疼痛强度 Or (项目序号_In = n_脉搏 And n_心率应用 = 2)) And n_Preblue = 0 Then
    Delete From 病人护理明细
    Where 记录id = n_记录id And 项目序号 = Decode(项目序号_In, n_脉搏, n_心率, 项目序号_In) And
          Decode(项目序号_In, n_脉搏, 1, Nvl(记录标记, 0)) = 1 And 记录类型 = 记录类型_In And 终止版本 Is Null;
  End If;

  --改写病人护理明细：如果已经存在与病人、科室和发生时间相同的记录则修改，否则增加新的记录
  -----------------------------------------------------------------------------------------------------------------------
  v_Data     := 记录内容_In;
  n_项目序号 := 项目序号_In;
  For n_i In 0 .. n_Preblue Loop
    If n_i = 0 Then
      If 项目序号_In = n_心率 Then
        n_记录标记 := 1;
      Else
        n_记录标记 := 0;
      End If;
    Else
      --收缩压/舒张压
      If 项目序号_In = 4 Then
        n_记录标记 := 0;
        n_项目序号 := 5;
      Else
        n_记录标记 := 1;
        If 项目序号_In = n_脉搏 Then
          n_项目序号 := n_心率;
        End If;
      End If;
    
    End If;
    If n_Preblue > 0 Then
      v_记录内容 := Substr(v_Data, 1, Instr(v_Data, '/', 1) - 1);
      If v_记录内容 Is Null Then
        v_记录内容 := v_Data;
      End If;
    Else
      v_记录内容 := v_Data;
    End If;
  
    --为了兼容以前同步过来的心率数据记录标记为0
    If n_i = 0 Then
      Update 病人护理明细
      Set 记录内容 = v_记录内容, 体温部位 = 体温部位_In, 复试合格 = 复试合格_In,
          未记说明 = Decode(n_项目序号, n_体温, Decode(v_记录内容, '不升', Null, 未记说明_In), 未记说明_In), 记录人 = v_保存人, 记录时间 = Sysdate
      Where 记录id = n_记录id And 项目序号 = n_项目序号 And 记录类型 = 记录类型_In And
            Decode(项目序号_In, n_体温, Nvl(记录标记, 0), n_疼痛强度, Nvl(记录标记, 0), Nvl(n_记录标记, 0)) = Nvl(n_记录标记, 0) And
            Decode(n_项目性质, 2, Nvl(体温部位, '无'), Nvl(体温部位_In, '无')) = Nvl(体温部位_In, '无') And 终止版本 Is Null;
    Else
      Update 病人护理明细
      Set 记录内容 = v_记录内容, 记录人 = v_保存人, 记录时间 = Sysdate
      Where 记录id = n_记录id And 项目序号 = n_项目序号 And 记录类型 = 记录类型_In And
            Decode(项目序号_In, n_体温, Nvl(记录标记, 0), n_疼痛强度, Nvl(记录标记, 0), Nvl(n_记录标记, 0)) = Nvl(n_记录标记, 0) And 终止版本 Is Null;
    End If;
    If Sql%Rowcount = 0 Then
      --插入本次登记的病人护理内容
      If Mod(记录类型_In, 10) = 1 Then
        Insert Into 病人护理明细
          (Id, 记录id, 记录类型, 项目分组, 项目id, 项目序号, 项目名称, 项目类型, 记录内容, 项目单位, 记录标记, 记录人, 体温部位, 复试合格, 开始版本, 终止版本, 记录组号, 未记说明,
           记录时间, 数据来源, 显示, 来源id, 共用)
          Select 病人护理明细_Id.Nextval, n_记录id, 记录类型_In, 分组名, 项目id, 项目序号, 项目名称, 项目类型, v_记录内容, 项目单位, n_记录标记, v_保存人, 体温部位_In,
                 复试合格_In, n_开始版本, Null, Null,
                 Decode(n_项目序号, n_体温, Decode(v_记录内容, '不升', Null, 未记说明_In), 未记说明_In), Sysdate, 数据来源_In, 0, 来源id_In, 共用_In
          From 护理记录项目
          Where 项目序号 = n_项目序号;
      Else
        Insert Into 病人护理明细
          (Id, 记录id, 记录类型, 项目分组, 项目id, 项目序号, 项目名称, 项目类型, 记录内容, 项目单位, 记录标记, 记录人, 体温部位, 复试合格, 开始版本, 终止版本, 记录组号, 未记说明,
           记录时间, 数据来源, 显示, 来源id, 共用)
        Values
          (病人护理明细_Id.Nextval, n_记录id, 记录类型_In, Null, Null, 0,
           Decode(记录类型_In, 2, '上标说明', 6, '下标说明', 3, '入出转', 4, v_记录内容), Decode(记录类型_In, 3, 0, 1),
           Decode(记录类型_In, 4, '1', 记录内容_In), '', n_记录标记, v_保存人, 体温部位_In, 复试合格_In, n_开始版本, Null, Null, 未记说明_In, Sysdate,
           数据来源_In, 0, 来源id_In, 共用_In);
      End If;
    End If;
    If n_Preblue > 0 Then
      v_Data := Substr(v_Data, Instr(v_Data, '/', 1) + 1);
    End If;
  End Loop;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_体温单数据_Update;
/

--104363:梁经伙,2016-12-27,重新填写皮试结果时删除之前的过敏记录
CREATE OR REPLACE Procedure Zl_病人医嘱记录_皮试
(
  --功能：填写医嘱皮试结果
  --说明：同时处理病人过敏记录
  --参数：标注_In=比如阳性："(+)",阴性："(-)",免试："免试"，等
  --      结果_IN=0-阴性,1-阳性，NULL=免试
  Id_In         病人医嘱记录.Id%Type,
  标注_In       病人医嘱记录.皮试结果%Type,
  结果_In       病人过敏记录.结果%Type,
  操作员姓名_In Varchar2 := Null,
  皮试时间_In   病人过敏记录.过敏时间%Type := Null,
  过敏反应_In   病人过敏药物.过敏反应%Type := Null
) Is
  --跟该过敏试验相关的所有药品信息项目
  Cursor c_Data Is
    Select Distinct c.病人id, Decode(c.挂号单, Null, c.主页id, d.Id) As 主页id, a.项目id, b.名称
    From 诊疗用法用量 A, 诊疗项目目录 B, 病人医嘱记录 C, 病人挂号记录 D
    Where Nvl(a.性质, 0) = 0 And a.用法id = c.诊疗项目id And a.项目id = b.Id And b.类别 In ('5', '6') And c.挂号单 = d.No(+) And
          c.Id = Id_In;

  v_挂号单   病人医嘱记录.挂号单%Type;
  v_状态     病人医嘱记录.医嘱状态%Type;
  v_医嘱内容 病人医嘱记录.医嘱内容%Type;

  v_Date     Date;
  d_操作时间 Date;
  v_Temp     Varchar2(255);
  v_人员编号 人员表.编号%Type;
  v_人员姓名 病人医嘱状态.操作人员%Type;
  v_上次记录时间 Date;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --检查医嘱状态是否正确:并发操作
  Select 挂号单, 医嘱状态, 医嘱内容 Into v_挂号单, v_状态, v_医嘱内容 From 病人医嘱记录 Where ID = Id_In;
  If v_状态 = 4 Then
    v_Error := '医嘱"' || v_医嘱内容 || '"已经作废，不能登记过敏试验结果。';
    Raise Err_Custom;
  End If;
  If v_挂号单 Is Not Null And v_状态 = 1 And Not 结果_In Is Null Then
    v_Error := '医嘱"' || v_医嘱内容 || '"尚未发送，不能登记过敏试验结果。';
    Raise Err_Custom;
  End If;

  --当前操作人员
  If 操作员姓名_In Is Null Then
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  Else
    v_人员姓名 := 操作员姓名_In;
    Select 编号 Into v_人员编号 From 人员表 Where 姓名 = v_人员姓名;
  End If;

  If 皮试时间_In Is Null Then
    Select Sysdate Into v_Date From Dual;
    d_操作时间 := v_Date;
  Else
    v_Date := 皮试时间_In;
    Select Sysdate Into d_操作时间 From Dual;
  End If;

  --处理医嘱记录:清除免试一样记录
  Update 病人医嘱记录 Set 皮试结果 = 标注_In Where ID = Id_In;
  
  --获取上次填写该记录的时间
  Begin
    Select 操作时间 Into v_上次记录时间
    From (Select 操作时间 From 病人医嘱状态 Where 医嘱id = Id_In And 操作类型 = 10 Order By 操作时间 Desc)
    Where Rownum < 2;
  Exception
    When No_Data_Found Then
      v_上次记录时间 := Null;
  End;
  
  Insert Into 病人医嘱状态 (医嘱id, 操作类型, 操作人员, 操作时间) Values (Id_In, 10, v_人员姓名, d_操作时间);

  --登记病人过敏记录(即使以前有同类药的过敏结果登记)
  If Not 结果_In Is Null Then
    For r_Data In c_Data Loop
      
      If Not v_上次记录时间 Is Null Then
           Delete from 病人过敏记录 A  where A.病人ID= r_Data.病人id and A.主页ID = r_Data.主页id and A.记录来源 = 2 and A.记录时间 = v_上次记录时间;
      End IF;
      Insert Into 病人过敏记录
        (ID, 病人id, 主页id, 记录来源, 药物id, 药物名, 结果, 过敏时间, 记录时间, 记录人, 过敏反应)
      Values
        (病人过敏记录_Id.Nextval, r_Data.病人id, r_Data.主页id, 2, r_Data.项目id, r_Data.名称, 结果_In, v_Date, d_操作时间, v_人员姓名, 过敏反应_In);
      If 结果_In = 1 Then
        Update 病人过敏药物
        Set 过敏反应 = 过敏反应_In, 过敏药物id = r_Data.项目id
        Where 病人id = r_Data.病人id And 过敏药物 = r_Data.名称;
        If Sql%RowCount = 0 Then
          Insert Into 病人过敏药物
            (病人id, 过敏药物id, 过敏药物, 过敏反应)
          Values
            (r_Data.病人id, r_Data.项目id, r_Data.名称, 过敏反应_In);
        End If;
      Else
        --如果没有过敏的记录就删除该药品的过敏记录
        Delete From 病人过敏药物 A
        Where a.病人id = r_Data.病人id And a.过敏药物 = r_Data.名称 And a.过敏药物id = r_Data.项目id And Not Exists
         (Select 1
               From 病人过敏记录 B
               Where b.病人id = a.病人id And b.药物id = a.过敏药物id And b.药物名 = a.过敏药物 And 结果 = 1);
      End If;
    End Loop;
    --标记皮试结果时将医嘱自动设为执行完成
    For X In (Select 执行状态, 发送号, 执行部门id From 病人医嘱发送 Where 医嘱id = Id_In) Loop
      If x.执行状态 <> 1 Then
        Zl_病人医嘱执行_Finish(Id_In, x.发送号, Null, 0, v_人员编号, v_人员姓名, x.执行部门id);
      End If;
    End Loop;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱记录_皮试;
/

--104448:张险华,2016-12-26,增加电子病历格式.文本内容
Create Or Replace Procedure Zl_Lob_Append
(
  Tab_In     In Number,
  Key_In     In Varchar2,
  Txt_In     In Varchar2, --16进制的文件片段或文字片段
  Cls_In     In Number := 0, --是否清除原来的内容，第一片段传递时为1，以后为0
  Lobtype_In In Number := 0 --0-BLOB;1-CLOB
  --参数说明：
  --Tab_In：包含LOB的数据表
  --        0-病历标记图形;1-病历文件格式;2-病历文件图形;3-病历范文格式;4-病历范文图形;
  --        5-电子病历格式;6-电子病历图形;7-病历页面格式；8-电子病历附件;9-体温重叠标记
  --        10-临床路径文件,11-临床路径图标;14-人员证书记录;15-人员表;16-人员照片;
  --        19-部门扩展信息;20-人员扩展信息;
  --Key_In：数据记录的关键字
  --Txt_In：16进制的文件片段或文字片段
  --Cls_In：是否清除原来的内容，第一片段传递时为1，以后为0
  --Lobtype_In:--0-BLOB;1-CLOB
) Is
  l_Blob Blob;
  l_Clob Clob;
  t_Key  t_Strlist;

Begin
  If Tab_In = 0 Then
    If Cls_In = 1 Then
      Update 病历标记图形 Set 图形 = Empty_Blob() Where 编码 = Key_In;
    End If;
    Select 图形 Into l_Blob From 病历标记图形 Where 编码 = Key_In For Update;
  Elsif Tab_In = 1 Then
    If Cls_In = 1 Then
      Update 病历文件格式 Set 内容 = Empty_Blob() Where 文件id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 病历文件格式 (文件id, 内容) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 内容 Into l_Blob From 病历文件格式 Where 文件id = To_Number(Key_In) For Update;
  Elsif Tab_In = 2 Then
    If Cls_In = 1 Then
      Update 病历文件图形 Set 图形 = Empty_Blob() Where 对象id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 病历文件图形 (对象id, 图形) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 图形 Into l_Blob From 病历文件图形 Where 对象id = To_Number(Key_In) For Update;
  Elsif Tab_In = 3 Then
    If Cls_In = 1 Then
      Update 病历范文格式 Set 内容 = Empty_Blob() Where 文件id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 病历范文格式 (文件id, 内容) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 内容 Into l_Blob From 病历范文格式 Where 文件id = To_Number(Key_In) For Update;
  Elsif Tab_In = 4 Then
    If Cls_In = 1 Then
      Update 病历范文图形 Set 图形 = Empty_Blob() Where 对象id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 病历范文图形 (对象id, 图形) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 图形 Into l_Blob From 病历范文图形 Where 对象id = To_Number(Key_In) For Update;
  Elsif Tab_In = 5 Then
    If Cls_In = 1 Then
      Update 电子病历格式 Set 内容 = Empty_Blob() Where 文件id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 电子病历格式 (文件id, 内容) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 内容 Into l_Blob From 电子病历格式 Where 文件id = To_Number(Key_In) For Update;
  Elsif Tab_In = 6 Then
    If Cls_In = 1 Then
      Update 电子病历图形 Set 图形 = Empty_Blob() Where 对象id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 电子病历图形 (对象id, 图形) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 图形 Into l_Blob From 电子病历图形 Where 对象id = To_Number(Key_In) For Update;
  Elsif Tab_In = 7 Then
    If Cls_In = 1 Then
      Update 病历页面格式
      Set 图形 = Empty_Blob()
      Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
    End If;
    Select 图形
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3)
    For Update;
  Elsif Tab_In = 8 Then
    If Cls_In = 1 Then
      Update 电子病历附件
      Set 内容 = Empty_Blob()
      Where 病历id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 序号 = Substr(Key_In, Instr(Key_In, ',') + 1);
    End If;
    Select 内容
    Into l_Blob
    From 电子病历附件
    Where 病历id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 序号 = Substr(Key_In, Instr(Key_In, ',') + 1)
    For Update;
  Elsif Tab_In = 9 Then
    If Cls_In = 1 Then
      Update 体温重叠标记 Set 标记图形 = Empty_Blob() Where 序号 = To_Number(Key_In);
    End If;
    Select 标记图形 Into l_Blob From 体温重叠标记 Where 序号 = To_Number(Key_In) For Update;
  Elsif Tab_In = 10 Then
    If Cls_In = 1 Then
      Update 临床路径文件
      Set 内容 = Empty_Blob()
      Where 路径id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And
            文件名 = Substr(Key_In, Instr(Key_In, ',') + 1);
    End If;
    Select 内容
    Into l_Blob
    From 临床路径文件
    Where 路径id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 文件名 = Substr(Key_In, Instr(Key_In, ',') + 1)
    For Update;
  Elsif Tab_In = 11 Then
    If Cls_In = 1 Then
      Update 临床路径图标 Set 图标 = Empty_Blob() Where ID = To_Number(Key_In);
    End If;
    Select 图标 Into l_Blob From 临床路径图标 Where ID = To_Number(Key_In) For Update;
  Elsif Tab_In = 12 Then
    If Cls_In = 1 Then
      Update 病历页面格式
      Set 页眉文件 = Empty_Blob()
      Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
    End If;
    Select 页眉文件
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3)
    For Update;
  Elsif Tab_In = 13 Then
    If Cls_In = 1 Then
      Update 病历页面格式
      Set 页脚文件 = Empty_Blob()
      Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
    End If;
    Select 页脚文件
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3)
    For Update;
  Elsif Tab_In = 14 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    If Cls_In = 1 Then
      Update 人员证书记录 Set 签章信息 = Empty_Clob() Where 人员id = To_Number(t_Key(1)) And Certsn = t_Key(2);
    End If;
    Select 签章信息 Into l_Clob From 人员证书记录 Where 人员id = To_Number(t_Key(1)) And Certsn = t_Key(2) For Update;
  Elsif Tab_In = 15 Then
    If Cls_In = 1 Then
      Update 人员表 Set 签名图片 = Empty_Blob() Where ID = To_Number(Key_In);
    End If;
    Select 签名图片 Into l_Blob From 人员表 Where ID = To_Number(Key_In) For Update;
    Update 人员表 Set 最后修改时间 = Sysdate Where ID = To_Number(Key_In);
  Elsif Tab_In = 16 Then
    If Cls_In = 1 Then
      Update 人员照片 Set 照片 = Empty_Blob() Where 人员id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 人员照片 (人员id, 照片) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 照片 Into l_Blob From 人员照片 Where 人员id = To_Number(Key_In) For Update;
    Update 人员表 Set 最后修改时间 = Sysdate Where ID = To_Number(Key_In);
  Elsif Tab_In = 19 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    If Cls_In = 1 Then
      Update 部门扩展信息 Set 图片 = Empty_Blob() Where 部门id = To_Number(t_Key(1)) And 项目 = t_Key(2);
    End If;
    Select 图片 Into l_Blob From 部门扩展信息 Where 部门id = To_Number(t_Key(1)) And 项目 = t_Key(2) For Update;
    Update 部门表 Set 最后修改时间 = Sysdate Where ID = To_Number(t_Key(1));
  Elsif Tab_In = 20 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    If Cls_In = 1 Then
      Update 人员扩展信息 Set 图片 = Empty_Blob() Where 人员id = To_Number(t_Key(1)) And 项目 = t_Key(2);
    End If;
    Select 图片 Into l_Blob From 人员扩展信息 Where 人员id = To_Number(t_Key(1)) And 项目 = t_Key(2) For Update;
    Update 人员表 Set 最后修改时间 = Sysdate Where ID = To_Number(t_Key(1));
  Elsif Tab_In = 21 Then 
    If Cls_In = 1 Then 
      Update 电子病历格式 Set 文本内容 = Empty_Clob() Where 文件id = To_Number(Key_In); 
      If Sql%RowCount = 0 Then 
        Insert Into 电子病历格式 (文件id, 文本内容) Values (To_Number(Key_In), Empty_Clob()); 
      End If; 
    End If; 
    Select 文本内容 Into l_Clob From 电子病历格式 Where 文件id = To_Number(Key_In) For Update; 
  End If;

  If Lobtype_In = 1 Then
    Dbms_Lob.Writeappend(l_Clob, Length(Txt_In), Txt_In);
  Else
    Dbms_Lob.Writeappend(l_Blob, Length(Hextoraw(Txt_In)) / 2, Hextoraw(Txt_In));
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Lob_Append;
/

--103221:刘尔旋,2016-12-26,开放停诊号码
Create Or Replace Function Zl_Fun_Get临床出诊预约状态
(
  记录id_In   In 临床出诊记录.Id%Type,
  预约时间_In In 病人挂号记录.预约时间%Type,
  序号_In     临床出诊序号控制.序号%Type := Null,
  预约方式_In 预约方式.名称%Type := Null,
  合作单位_In 挂号合作单位.名称%Type := Null,
  收费预约_In Number := 0
) Return Varchar2 As
  --功能：判断出诊记录在预约时间是否可预约
  --入参：
  --返回：
  --     格式：预约状态|提示信息，如："1|预约时间不在当前上班时段时间范围内。"
  --     预约状态：
  --         0-可预约
  --         ======================================================
  --         1-不可预约，预约时间不在当前上班时段时间范围内
  --         2-不可预约，当前上班时段禁止预约
  --         3-不可预约，当前上班时段在预约时间时已停诊
  --         4-不可预约，当前上班时段剩余可预约数为零
  --         ======================================================
  --         5-不可预约，当前预约时间在法定节假日时间范围内，不上班
  --         6-不可预约，当前预约时间在法定节假日时间范围内，禁止预约
  --         7-不可预约，当前预约时间在法定节假日不允许预约的时间范围内
  --         8-不可预约，当前预约时间在法定节假日不允许挂号的时间范围内
  --         9-不可预约，当前预约时间在法定节假日时间范围内，已停诊
  --         ======================================================
  --         10-不可预约，当前预约方式禁止预约
  --         11-不可预约，当前预约方式可预约数不足
  --         ======================================================
  --         12-不可预约，当前合作单位禁止预约
  --         13-不可预约，当前合作单位可预约数不足
  --         ======================================================
  --         14-不可预约，当前序号禁止预约
  --         15-不可预约，当前序号已经被使用
  --         16-不可预约，当前序号不可用
  --
  n_号源id         临床出诊记录.号源id%Type;
  n_是否分时段     临床出诊记录.是否分时段%Type;
  n_预约控制       临床出诊记录.预约控制%Type;
  d_停诊开始时间   临床出诊记录.停诊开始时间%Type;
  d_停诊终止时间   临床出诊记录.停诊终止时间%Type;
  v_停诊原因       临床出诊记录.停诊原因%Type;
  n_限约数         临床出诊记录.限约数%Type;
  n_已约数         临床出诊记录.已约数%Type;
  n_独占           临床出诊记录.是否独占%Type;
  n_控制方式       临床出诊挂号控制记录.控制方式%Type;
  n_数量           临床出诊挂号控制记录.数量%Type;
  n_数量限制       临床出诊挂号控制记录.数量%Type;
  n_序号控制       临床出诊记录.是否序号控制%Type;
  v_预约方式       临床出诊挂号控制记录.名称%Type;
  n_类型           临床出诊挂号控制记录.类型%Type;
  n_预约方式限约数 临床出诊记录.限约数%Type;
  n_预约方式已约数 临床出诊记录.已约数%Type;
  n_挂号状态       临床出诊序号控制.挂号状态%Type;
  n_是否预约       临床出诊序号控制.是否预约%Type;

  n_假日控制状态 临床出诊号源.假日控制状态%Type;

  v_允许预约 法定假日表.允许预约%Type;
  v_允许挂号 法定假日表.允许挂号%Type;
  n_Count    Number(2);
  n_已使用   Number(5);
Begin
  Begin
    Select a.号源id, a.是否分时段, a.预约控制, a.停诊开始时间, a.停诊终止时间, a.停诊原因, Nvl(限约数, 限号数), 已约数, 是否独占, 是否序号控制
    Into n_号源id, n_是否分时段, n_预约控制, d_停诊开始时间, d_停诊终止时间, v_停诊原因, n_限约数, n_已约数, n_独占, n_序号控制
    From 临床出诊记录 A
    Where a.Id = 记录id_In And 预约时间_In Between 开始时间 And 终止时间;
  Exception
    When Others Then
      Return '1|预约时间不在当前上班时段时间范围内。';
  End;

  --预约方式检查
  If 预约方式_In Is Not Null Then
    Begin
      Select 控制方式
      Into n_控制方式
      From 临床出诊挂号控制记录
      Where 类型 = 2 And 性质 = 1 And 记录id = 记录id_In And 名称 = 预约方式_In And Rownum < 2;
    Exception
      When Others Then
        Begin
          Select 控制方式
          Into n_控制方式
          From 临床出诊挂号控制记录
          Where 类型 = 2 And 性质 = 1 And 记录id = 记录id_In And Rownum < 2;
        Exception
          When Others Then
            Null;
        End;
    End;
    If n_控制方式 = 0 Then
      Return '10|当前预约方式禁止预约。';
    End If;
    If n_控制方式 = 1 Or n_控制方式 = 2 Then
      Select Nvl(限约数, 限号数) Into n_预约方式限约数 From 临床出诊记录 Where ID = 记录id_In;
      If n_独占 = 0 Then
        Begin
          Select 数量
          Into n_数量
          From 临床出诊挂号控制记录
          Where 类型 = 2 And 性质 = 1 And 名称 = 预约方式_In And 记录id = 记录id_In;
        Exception
          When Others Then
            n_数量 := Null;
        End;
        If n_数量 Is Not Null Then
          If n_控制方式 = 1 Then
            n_预约方式限约数 := Round(n_预约方式限约数 * n_数量 / 100);
          Else
            n_预约方式限约数 := n_数量;
          End If;
          Select Count(1)
          Into n_预约方式已约数
          From 病人挂号记录
          Where 出诊记录id = 记录id_In And 记录状态 = 1 And 预约方式 = 预约方式_In;
          If n_预约方式已约数 >= n_预约方式限约数 Then
            Return '11|当前预约方式可预约数不足。';
          End If;
        End If;
      Else
        --限数量独占
        Begin
          Select 数量
          Into n_数量
          From 临床出诊挂号控制记录
          Where 类型 = 2 And 性质 = 1 And 名称 = 预约方式_In And 记录id = 记录id_In;
        Exception
          When Others Then
            n_数量 := Null;
        End;
        If n_数量 Is Not Null Then
          If n_控制方式 = 1 Then
            n_预约方式限约数 := Round(n_预约方式限约数 * n_数量 / 100);
          Else
            n_预约方式限约数 := n_数量;
          End If;
          Select Count(1)
          Into n_预约方式已约数
          From 病人挂号记录
          Where 出诊记录id = 记录id_In And 记录状态 = 1 And 预约方式 = 预约方式_In;
          If n_预约方式已约数 >= n_预约方式限约数 Then
            Return '11|当前预约方式可预约数不足。';
          End If;
        Else
          If 收费预约_In = 0 Then
            For r_限制 In (Select 数量, 名称, 类型 From 临床出诊挂号控制记录 Where 性质 = 1 And 记录id = 记录id_In) Loop
              If r_限制.类型 = 1 Then
                Select Count(1)
                Into n_已使用
                From 病人挂号记录
                Where 出诊记录id = 记录id_In And 合作单位 = r_限制.名称 And 记录状态 = 1;
              Else
                Select Count(1)
                Into n_已使用
                From 病人挂号记录
                Where 出诊记录id = 记录id_In And 预约方式 = r_限制.名称 And 记录状态 = 1;
              End If;
              If n_控制方式 = 1 Then
                n_数量限制 := Nvl(n_数量限制, 0) + Round(r_限制.数量 * n_预约方式限约数 / 100) - Nvl(n_已使用, 0);
              Else
                n_数量限制 := Nvl(n_数量限制, 0) + r_限制.数量 - Nvl(n_已使用, 0);
              End If;
            End Loop;
            Select Count(1) Into n_已使用 From 病人挂号记录 Where 出诊记录id = 记录id_In And 记录状态 = 1;
            If n_预约方式限约数 - n_数量限制 - n_已使用 > 0 Then
              Null;
            Else
              Return '11|当前预约方式可预约数不足。';
            End If;
          Else
            For r_限制 In (Select 数量, 名称, 类型
                         From 临床出诊挂号控制记录
                         Where 性质 = 1 And 类型 = 2 And 记录id = 记录id_In) Loop
              Select Count(1)
              Into n_已使用
              From 病人挂号记录
              Where 出诊记录id = 记录id_In And 预约方式 = r_限制.名称 And 记录状态 = 1;
              If n_控制方式 = 1 Then
                n_数量限制 := Nvl(n_数量限制, 0) + Round(r_限制.数量 * n_预约方式限约数 / 100) - Nvl(n_已使用, 0);
              Else
                n_数量限制 := Nvl(n_数量限制, 0) + r_限制.数量 - Nvl(n_已使用, 0);
              End If;
            End Loop;
            Select Count(1) Into n_已使用 From 病人挂号记录 Where 出诊记录id = 记录id_In And 记录状态 = 1;
            If n_预约方式限约数 - n_数量限制 - n_已使用 > 0 Then
              Null;
            Else
              Return '11|当前预约方式可预约数不足。';
            End If;
          End If;
        End If;
      End If;
    End If;
    If n_控制方式 = 3 Then
      If n_序号控制 = 1 Then
        If 收费预约_In = 0 Then
          Begin
            Select 数量, 名称, 类型
            Into n_预约方式限约数, v_预约方式, n_类型
            From 临床出诊挂号控制记录
            Where 性质 = 1 And 记录id = 记录id_In And 序号 = 序号_In;
          Exception
            When Others Then
              n_预约方式限约数 := Null;
          End;
          If n_预约方式限约数 Is Not Null Then
            If v_预约方式 <> 预约方式_In Or n_类型 = 1 Then
              Return '11|当前预约方式可预约数不足。';
            End If;
            Select Nvl(Max(1), 0)
            Into n_预约方式已约数
            From 病人挂号记录
            Where 出诊记录id = 记录id_In And 号序 = 序号_In;
            If n_预约方式已约数 >= n_预约方式限约数 Then
              Return '11|当前预约方式可预约数不足。';
            End If;
          End If;
        Else
          Begin
            Select 数量, 名称, 类型
            Into n_预约方式限约数, v_预约方式, n_类型
            From 临床出诊挂号控制记录
            Where 性质 = 1 And 类型 = 2 And 记录id = 记录id_In And 序号 = 序号_In;
          Exception
            When Others Then
              n_预约方式限约数 := Null;
          End;
          If n_预约方式限约数 Is Not Null Then
            If v_预约方式 <> 预约方式_In Then
              Return '11|当前预约方式可预约数不足。';
            End If;
            Select Nvl(Max(1), 0)
            Into n_预约方式已约数
            From 病人挂号记录
            Where 出诊记录id = 记录id_In And 号序 = 序号_In;
            If n_预约方式已约数 >= n_预约方式限约数 Then
              Return '11|当前预约方式可预约数不足。';
            End If;
          End If;
        End If;
      Else
        If 收费预约_In = 0 Then
          For r_限制 In (Select 数量, 名称, 类型
                       From 临床出诊挂号控制记录
                       Where 性质 = 1 And 记录id = 记录id_In And 序号 = 序号_In) Loop
            If r_限制.名称 <> 预约方式_In Or r_限制.类型 = 1 Then
              If r_限制.类型 = 1 Then
                Select Count(1)
                Into n_已使用
                From 临床出诊序号控制 A, 病人挂号记录 B
                Where a.记录id = 记录id_In And a.预约顺序号 Is Not Null And Nvl(a.挂号状态, 0) <> 0 And a.备注 = b.号序 And
                      b.合作单位 = r_限制.名称 And b.记录状态 = 1;
              Else
                Select Count(1)
                Into n_已使用
                From 临床出诊序号控制 A, 病人挂号记录 B
                Where a.记录id = 记录id_In And a.预约顺序号 Is Not Null And Nvl(a.挂号状态, 0) <> 0 And a.备注 = b.号序 And
                      b.预约方式 = r_限制.名称 And b.记录状态 = 1;
              End If;
              n_数量限制 := Nvl(n_数量限制, 0) + r_限制.数量 - Nvl(n_已使用, 0);
            Else
              Select Count(1)
              Into n_预约方式已约数
              From 临床出诊序号控制 A, 病人挂号记录 B
              Where a.记录id = 记录id_In And a.预约顺序号 Is Not Null And Nvl(a.挂号状态, 0) <> 0 And a.备注 = b.号序 And
                    b.预约方式 = 预约方式_In And b.记录状态 = 1;
              If n_预约方式已约数 >= n_预约方式限约数 Then
                Return '11|当前预约方式可预约数不足。';
              End If;
            End If;
          End Loop;
          Select Count(1)
          Into n_已使用
          From 临床出诊序号控制 A
          Where a.记录id = 记录id_In And a.预约顺序号 Is Not Null And Nvl(a.挂号状态, 0) <> 0 And 序号 = 序号_In;
          Select Nvl(限约数, 限号数) Into n_预约方式限约数 From 临床出诊记录 Where ID = 记录id_In;
          If n_预约方式限约数 - n_数量限制 - n_已使用 > 0 Then
            Null;
          Else
            Return '11|当前预约方式可预约数不足。';
          End If;
        Else
          For r_限制 In (Select 数量, 名称, 类型
                       From 临床出诊挂号控制记录
                       Where 性质 = 1 And 类型 = 2 And 记录id = 记录id_In And 序号 = 序号_In) Loop
            If r_限制.名称 <> 预约方式_In Then
              Select Count(1)
              Into n_已使用
              From 临床出诊序号控制 A, 病人挂号记录 B
              Where a.记录id = 记录id_In And a.预约顺序号 Is Not Null And Nvl(a.挂号状态, 0) <> 0 And a.备注 = b.号序 And
                    b.预约方式 = r_限制.名称 And b.记录状态 = 1;
              n_数量限制 := Nvl(n_数量限制, 0) + r_限制.数量 - Nvl(n_已使用, 0);
            Else
              Select Count(1)
              Into n_预约方式已约数
              From 临床出诊序号控制 A, 病人挂号记录 B
              Where a.记录id = 记录id_In And a.预约顺序号 Is Not Null And Nvl(a.挂号状态, 0) <> 0 And a.备注 = b.号序 And
                    b.预约方式 = 预约方式_In And b.记录状态 = 1;
              If n_预约方式已约数 >= n_预约方式限约数 Then
                Return '11|当前预约方式可预约数不足。';
              End If;
            End If;
          End Loop;
          Select Count(1)
          Into n_已使用
          From 临床出诊序号控制 A
          Where a.记录id = 记录id_In And a.预约顺序号 Is Not Null And Nvl(a.挂号状态, 0) <> 0 And 序号 = 序号_In;
          Select Nvl(限约数, 限号数) Into n_预约方式限约数 From 临床出诊记录 Where ID = 记录id_In;
          If n_预约方式限约数 - n_数量限制 - n_已使用 > 0 Then
            Null;
          Else
            Return '11|当前预约方式可预约数不足。';
          End If;
        End If;
      End If;
    End If;
  End If;

  --合作单位检查
  If 合作单位_In Is Not Null Then
    Begin
      Select 控制方式
      Into n_控制方式
      From 临床出诊挂号控制记录
      Where 类型 = 1 And 性质 = 1 And 记录id = 记录id_In And 名称 = 合作单位_In And Rownum < 2;
    Exception
      When Others Then
        Begin
          Select 控制方式
          Into n_控制方式
          From 临床出诊挂号控制记录
          Where 类型 = 1 And 性质 = 1 And 记录id = 记录id_In And Rownum < 2;
        Exception
          When Others Then
            Null;
        End;
    End;
    If n_控制方式 = 0 Then
      Return '12|当前合作单位禁止预约。';
    End If;
    If n_控制方式 = 1 Or n_控制方式 = 2 Then
      Select Nvl(限约数, 限号数) Into n_预约方式限约数 From 临床出诊记录 Where ID = 记录id_In;
      If n_独占 = 0 Then
        Begin
          Select 数量
          Into n_数量
          From 临床出诊挂号控制记录
          Where 类型 = 1 And 性质 = 1 And 名称 = 合作单位_In And 记录id = 记录id_In;
        Exception
          When Others Then
            n_数量 := Null;
        End;
        If n_数量 Is Not Null Then
          If n_控制方式 = 1 Then
            n_预约方式限约数 := Round(n_预约方式限约数 * n_数量 / 100);
          Else
            n_预约方式限约数 := n_数量;
          End If;
          Select Count(1)
          Into n_预约方式已约数
          From 病人挂号记录
          Where 出诊记录id = 记录id_In And 记录状态 = 1 And 合作单位 = 合作单位_In;
          If n_预约方式已约数 >= n_预约方式限约数 Then
            Return '13|当前合作单位可预约数不足。';
          End If;
        End If;
      Else
        --限数量独占
        Begin
          Select 数量
          Into n_数量
          From 临床出诊挂号控制记录
          Where 类型 = 1 And 性质 = 1 And 名称 = 合作单位_In And 记录id = 记录id_In;
        Exception
          When Others Then
            n_数量 := Null;
        End;
        If n_数量 Is Not Null Then
          If n_控制方式 = 1 Then
            n_预约方式限约数 := Round(n_预约方式限约数 * n_数量 / 100);
          Else
            n_预约方式限约数 := n_数量;
          End If;
          Select Count(1)
          Into n_预约方式已约数
          From 病人挂号记录
          Where 出诊记录id = 记录id_In And 记录状态 = 1 And 合作单位 = 合作单位_In;
          If n_预约方式已约数 >= n_预约方式限约数 Then
            Return '13|当前合作单位可预约数不足。';
          End If;
        Else
          For r_限制 In (Select 数量, 名称, 类型 From 临床出诊挂号控制记录 Where 性质 = 1 And 记录id = 记录id_In) Loop
            If r_限制.类型 = 1 Then
              Select Count(1)
              Into n_已使用
              From 病人挂号记录
              Where 出诊记录id = 记录id_In And 合作单位 = r_限制.名称 And 记录状态 = 1;
            Else
              Select Count(1)
              Into n_已使用
              From 病人挂号记录
              Where 出诊记录id = 记录id_In And 预约方式 = r_限制.名称 And 记录状态 = 1;
            End If;
            If n_控制方式 = 1 Then
              n_数量限制 := Nvl(n_数量限制, 0) + Round(r_限制.数量 * n_预约方式限约数 / 100) - Nvl(n_已使用, 0);
            Else
              n_数量限制 := Nvl(n_数量限制, 0) + r_限制.数量 - Nvl(n_已使用, 0);
            End If;
          End Loop;
          Select Count(1) Into n_已使用 From 病人挂号记录 Where 出诊记录id = 记录id_In And 记录状态 = 1;
          If n_预约方式限约数 - n_数量限制 - n_已使用 > 0 Then
            Null;
          Else
            Return '13|当前合作单位可预约数不足。';
          End If;
        End If;
      End If;
    End If;
    If n_控制方式 = 3 Then
      If n_序号控制 = 1 Then
        Begin
          Select 数量, 名称, 类型
          Into n_预约方式限约数, v_预约方式, n_类型
          From 临床出诊挂号控制记录
          Where 性质 = 1 And 记录id = 记录id_In And 序号 = 序号_In;
        Exception
          When Others Then
            n_预约方式限约数 := Null;
        End;
        If n_预约方式限约数 Is Not Null Then
          If v_预约方式 <> 合作单位_In Or n_类型 = 1 Then
            Return '13|当前合作单位可预约数不足。';
          End If;
          Select Nvl(Max(1), 0)
          Into n_预约方式已约数
          From 病人挂号记录
          Where 出诊记录id = 记录id_In And 号序 = 序号_In;
          If n_预约方式已约数 >= n_预约方式限约数 Then
            Return '13|当前合作单位可预约数不足。';
          End If;
        End If;
      Else
        For r_限制 In (Select 数量, 名称, 类型
                     From 临床出诊挂号控制记录
                     Where 性质 = 1 And 记录id = 记录id_In And 序号 = 序号_In) Loop
          If r_限制.名称 <> 合作单位_In Or r_限制.类型 = 1 Then
            If r_限制.类型 = 1 Then
              Select Count(1)
              Into n_已使用
              From 临床出诊序号控制 A, 病人挂号记录 B
              Where a.记录id = 记录id_In And a.预约顺序号 Is Not Null And Nvl(a.挂号状态, 0) <> 0 And a.备注 = b.号序 And
                    b.合作单位 = r_限制.名称 And b.记录状态 = 1;
            Else
              Select Count(1)
              Into n_已使用
              From 临床出诊序号控制 A, 病人挂号记录 B
              Where a.记录id = 记录id_In And a.预约顺序号 Is Not Null And Nvl(a.挂号状态, 0) <> 0 And a.备注 = b.号序 And
                    b.预约方式 = r_限制.名称 And b.记录状态 = 1;
            End If;
            n_数量限制 := Nvl(n_数量限制, 0) + r_限制.数量 - Nvl(n_已使用, 0);
          Else
            Select Count(1)
            Into n_预约方式已约数
            From 临床出诊序号控制 A, 病人挂号记录 B
            Where a.记录id = 记录id_In And a.预约顺序号 Is Not Null And Nvl(a.挂号状态, 0) <> 0 And a.备注 = b.号序 And b.合作单位 = 合作单位_In And
                  b.记录状态 = 1;
            If n_预约方式已约数 >= n_预约方式限约数 Then
              Return '13|当前合作单位可预约数不足。';
            End If;
          End If;
        End Loop;
        Select Count(1)
        Into n_已使用
        From 临床出诊序号控制 A
        Where a.记录id = 记录id_In And a.预约顺序号 Is Not Null And Nvl(a.挂号状态, 0) <> 0 And 序号 = 序号_In;
        Select Nvl(限约数, 限号数) Into n_预约方式限约数 From 临床出诊记录 Where ID = 记录id_In;
        If n_预约方式限约数 - n_数量限制 - n_已使用 > 0 Then
          Null;
        Else
          Return '13|当前合作单位可预约数不足。';
        End If;
      End If;
    End If;
  End If;

  --0-不作预约限制;1-该号别禁止预约;2-仅禁止三方机构平台的预约
  If Nvl(n_预约控制, 0) = 1 Then
    Return '2|当前上班时段禁止预约。';
  End If;

  If d_停诊开始时间 Is Not Null And Not (Nvl(n_序号控制, 0) = 1 And Nvl(n_是否分时段, 0) = 1) Then
    If 预约时间_In >= d_停诊开始时间 And 预约时间_In <= d_停诊终止时间 Then
      Return '3|当前上班时段在预约时间时已停诊，不能预约！';
    End If;
  End If;

  If Nvl(n_限约数, 0) > 0 Then
    If Nvl(n_限约数, 0) - Nvl(n_已约数, 0) <= 0 Then
      Return '4|当前上班时段剩余可预约数为零，不能继续预约！';
    End If;
  End If;

  If Nvl(n_是否分时段, 0) = 0 Then
    --不分时段
    Begin
      Select Nvl(b.假日控制状态, 0) Into n_假日控制状态 From 临床出诊号源 B Where b.Id = n_号源id;
    Exception
      When Others Then
        n_假日控制状态 := 0;
    End;
  
    --1.查找包含预约时间的节假日
    Begin
      Select 允许预约, 允许挂号
      Into v_允许预约, v_允许挂号
      From 法定假日表 A
      Where a.性质 = 0 And 预约时间_In Between a.开始日期 And a.终止日期 + 1 - 1 / 24 / 60 / 60 And Rownum < 2;
    Exception
      When Others Then
        Return '0|正常预约。';
    End;
  
    --假日控制状态：0-不上班;1-上班且开放预约;2-上班但不开放预约;3-受节假日设置控制
    If Nvl(n_假日控制状态, 0) = 0 Then
      --不上班的肯定是不能预约的
      Return '5|当前预约时间在法定节假日时间范围内，不上班。';
    Elsif Nvl(n_假日控制状态, 0) = 1 Then
      Return '0|正常预约。';
    Elsif Nvl(n_假日控制状态, 0) = 2 Then
      --在节假日时间范围内，则不能预约
      Return '6|当前预约时间在法定节假日时间范围内，禁止预约。';
    Elsif Nvl(n_假日控制状态, 0) = 3 Then
      --没有"允许挂号"就一定没有"允许预约"
      If v_允许挂号 Is Not Null Then
        --2.检查是否有包含预约时间的"允许挂号"
        Select Max(1)
        Into n_Count
        From Table(f_Str2list(v_允许挂号, ';'))
        Where 预约时间_In Between To_Date(Column_Value, 'yyyy-mm-dd') And
              To_Date(Column_Value, 'yyyy-mm-dd') + 1 - 1 / 24 / 60 / 60 And Rownum < 2;
      
        If Nvl(n_Count, 0) <> 0 Then
          --3.检查是否有包含预约时间的"允许预约"
          Select Max(1)
          Into n_Count
          From Table(f_Str2list(v_允许预约, ';'))
          Where 预约时间_In Between To_Date(Column_Value, 'yyyy-mm-dd') And
                To_Date(Column_Value, 'yyyy-mm-dd') + 1 - 1 / 24 / 60 / 60 And Rownum < 2;
        
          If Nvl(n_Count, 0) = 0 Then
            --不在"允许预约"时间范围内，则不能预约
            Return '7|当前预约时间在法定节假日不允许预约的时间范围内，不能预约。';
          Else
            Return '0|正常预约。';
          End If;
        Else
          Return '8|当前预约时间在法定节假日不允许挂号的时间范围内，不能预约。';
        End If;
      Else
        --没有设置"允许挂号"/"允许预约"表示停诊，肯定不能预约
        Return '9|当前预约时间在法定节假日时间范围内，已停诊，不能预约。';
      End If;
    End If;
  Else
    --分时段
    If Nvl(序号_In, 0) <> 0 Then
      Begin
        Select Nvl(是否预约, 0), Nvl(挂号状态, 0)
        Into n_是否预约, n_挂号状态
        From 临床出诊序号控制
        Where 记录id = 记录id_In And 序号 = 序号_In;
      Exception
        When Others Then
          Return '16|当前选择的序号不可用。';
      End;
      If n_是否预约 = 0 Then
        Return '14|当前选择的序号禁止预约。';
      End If;
      If n_挂号状态 <> 0 Then
        Return '15|当前选择的序号已经被使用。';
      End If;
    End If;
    Return '0|正常预约。';
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Fun_Get临床出诊预约状态;
/

--104319:刘硕,2016-12-29,支持二级地址缺失的情况下对地址解析
Create Or Replace Function Zl_Adderss_Structure(v_Addressinfo Varchar2) Return Varchar2 Is
  --返回结构：省,省编码,是否虚拟,是否不显示,是否只有虚拟级|市,市编码,是否虚拟,是否不显示,是否只有虚拟级 
  --          |区县,区县编码,是否虚拟,是否不显示,是否只有虚拟级|乡镇,乡镇编码,是否虚拟,是否不显示,是否只有虚拟级 
  --          |街道,街道编码,是否虚拟,是否不显示,是否只有虚拟级 
  v_省       Varchar2(100);
  v_Code省   Varchar2(15);
  v_Info省   Varchar2(150);
  v_市       Varchar2(100);
  v_Code市   Varchar2(15);
  v_Info市   Varchar2(150);
  v_区县     Varchar2(100);
  v_Code区县 Varchar2(15);
  v_Info区县 Varchar2(150);
  v_乡镇     Varchar2(100);
  v_Code乡镇 Varchar2(15);
  v_Info乡镇 Varchar2(150);
  v_街道     Varchar2(500);
  v_Code街道 Varchar2(15);
  v_Info街道 Varchar2(550);
  v_Tmp      Varchar2(100);
  v_Adrstmp  Varchar2(500);
  n_Pos      Number(5);
  n_虚拟     Number(1);
  n_不显示   Number(1);
  n_Count    Number(3);
  v_Return   Varchar2(700);
Begin
  --传入结构化的地址，不用进行地址标准化分割解析 
  v_Adrstmp := v_Addressinfo;
  If v_Addressinfo Like '%,%,%,%,%' Then
    n_Pos     := Instr(v_Adrstmp, ',');
    v_省      := Substr(v_Adrstmp, 1, n_Pos - 1);
    v_Adrstmp := Substr(v_Adrstmp, n_Pos + 1);
    n_Pos     := Instr(v_Adrstmp, ',');
    v_市      := Substr(v_Adrstmp, 1, n_Pos - 1);
    v_Adrstmp := Substr(v_Adrstmp, n_Pos + 1);
    n_Pos     := Instr(v_Adrstmp, ',');
    v_区县    := Substr(v_Adrstmp, 1, n_Pos - 1);
    v_Adrstmp := Substr(v_Adrstmp, n_Pos + 1);
    n_Pos     := Instr(v_Adrstmp, ',');
    v_乡镇    := Substr(v_Adrstmp, 1, n_Pos - 1);
    v_街道    := Substr(v_Adrstmp, n_Pos + 1);
    Select Max(编码) Into v_Code省 From 区域 Where 名称 = v_省 And Nvl(级数, 0) = 0;
    --省级地址都没有，就不做处理 
    If v_Code省 Is Not Null Then
      Select Max(编码), Max(是否虚拟), Max(是否不显示)
      Into v_Code市, n_虚拟, n_不显示
      From 区域
      Where 名称 = v_市 And Nvl(级数, 0) = 1 And 上级编码 = v_Code省;
      If v_Code市 Is Not Null Then
        v_Info市 := v_市 || ',' || v_Code市 || ',' || n_虚拟 || ',' || n_不显示;
        Select Max(编码), Max(是否虚拟), Max(是否不显示)
        Into v_Code区县, n_虚拟, n_不显示
        From 区域
        Where 名称 = v_区县 And Nvl(级数, 0) = 2 And 上级编码 = v_Code市;
        --可能是虚拟地址 
      Else
        Select Max(编码), Max(上级编码)
        Into v_Code区县, v_Code市
        From 区域
        Where 名称 = v_区县 And Nvl(级数, 0) = 2 And 上级编码 In (Select 编码 From 区域 Where 上级编码 = v_Code省);
        If v_Code市 Is Not Null Then
          Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示)
          Into v_市, v_Code市, n_虚拟, n_不显示
          From 区域
          Where 编码 = v_Code市;
        End If;
        v_Info市 := v_市 || ',' || v_Code市 || ',' || n_虚拟 || ',' || n_不显示;
        Select Max(编码), Max(是否虚拟), Max(是否不显示)
        Into v_Code区县, n_虚拟, n_不显示
        From 区域
        Where 编码 = v_Code区县;
      End If;
      v_Info区县 := v_区县 || ',' || v_Code区县 || ',' || n_虚拟 || ',' || n_不显示;
      If v_Code区县 Is Not Null Then
        --可能乡镇在详细地址中，关联参数乡镇地址结构化录入 
        If v_乡镇 Is Null And Not v_街道 Is Null Then
          --先截取乡镇级的两个字做关键字，来匹配 
          v_Tmp := Substr(v_街道, 1, 2);
          Select Max(名称)
          Into v_乡镇
          From 区域
          Where 名称 Like v_Tmp || '%' And Nvl(级数, 0) = 3 And 上级编码 = v_Code区县;
          --存在多行匹配，则继续增加长度，暂时从2个字增加到3个字匹配 
          If n_Count > 1 Then
            v_Tmp := Substr(v_街道, 1, 3);
            Select Max(名称)
            Into v_乡镇
            From 区域
            Where 名称 Like v_Tmp || '%' And Nvl(级数, 0) = 3 And 上级编码 = v_Code区县;
          End If;
          If Not v_乡镇 Is Null Then
            v_街道 := Substr(v_街道, Length(v_乡镇) + 1);
          End If;
        End If;
        Select Max(编码), Max(是否虚拟), Max(是否不显示)
        Into v_Code乡镇, n_虚拟, n_不显示
        From 区域
        Where 名称 = v_乡镇 And Nvl(级数, 0) = 3 And 上级编码 = v_Code区县;
        --可能是虚拟地址 
        If v_Code乡镇 Is Null Then
          Select Max(编码), Max(上级编码)
          Into v_Code街道, v_Code乡镇
          From 区域
          Where 名称 = v_街道 And Nvl(级数, 0) = 4 And 上级编码 In (Select 编码 From 区域 Where 上级编码 = v_Code区县);
          If v_Code乡镇 Is Not Null Then
            Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示)
            Into v_乡镇, v_Code乡镇, n_虚拟, n_不显示
            From 区域
            Where 编码 = v_Code乡镇;
          End If;
        End If;
        v_Info乡镇 := v_乡镇 || ',' || v_Code乡镇 || ',' || n_虚拟 || ',' || n_不显示;
        If v_Code乡镇 Is Not Null Then
          Select Max(编码), Max(是否虚拟), Max(是否不显示)
          Into v_Code街道, n_虚拟, n_不显示
          From 区域
          Where 名称 = v_街道 And Nvl(级数, 0) = 4 And 上级编码 = v_Code乡镇;
          v_Info街道 := v_街道 || ',' || v_Code街道 || ',' || n_虚拟 || ',' || n_不显示;
        End If;
      End If;
    End If;
    --非标准地址，是完整地址，需要分割省，市，县, 
  Else
    v_Adrstmp := v_Addressinfo;
    v_Tmp     := Substr(v_Adrstmp, 1, 2);
    Select Max(名称), Max(编码) Into v_省, v_Code省 From 区域 Where 名称 Like v_Tmp || '%' And Nvl(级数, 0) = 0;
    --有省级地址，说明可以结构化 
    If v_Code省 Is Not Null Then
      --省级地址是标准的 
      If Substr(v_Adrstmp, 1, Length(v_省)) = v_省 Then
        v_Adrstmp := Substr(v_Adrstmp, Length(v_省) + 1);
        --省级地址不标准,可能新疆省略自治区等,此时，市级地址可能是标准化的。 
      Else
        --先判断二级地址是否存在虚拟地址与不显示的地址 
        If v_Tmp = '内蒙' Then
          v_Tmp := '内蒙古';
        Elsif v_Tmp = '黑龙' Then
          v_Tmp := '黑龙江';
        End If;
        v_Adrstmp := Substr(v_Adrstmp, Length(v_Tmp) + 1);
      End If;
      --先截取市级的两个字做关键字，来匹配 
      v_Tmp := Substr(v_Adrstmp, 1, 2);
      Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示), Count(1)
      Into v_市, v_Code市, n_虚拟, n_不显示, n_Count
      From 区域
      Where 名称 Like v_Tmp || '%' And Nvl(级数, 0) = 1 And 上级编码 = v_Code省;
      --存在多行匹配，则继续增加长度，暂时从2个字增加到3个字匹配 
      If n_Count > 1 Then
        v_Tmp := Substr(v_Adrstmp, 1, 3);
        Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示)
        Into v_市, v_Code市, n_虚拟, n_不显示
        From 区域
        Where 名称 Like v_Tmp || '%' And Nvl(级数, 0) = 1 And 上级编码 = v_Code省;
      End If;
      --判断是否存在虚拟地址或不显示的地址导致的,如果存在，则根据第三级地址来确定虚拟地址 
      --可能是没有第二级，因此需要第三级判断
      If v_Code市 Is Null Then
        Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示), Count(1), Max(上级编码)
        Into v_区县, v_Code区县, n_虚拟, n_不显示, n_Count, v_Code市
        From 区域
        Where 名称 Like v_Tmp || '%' And Nvl(级数, 0) = 2 And 上级编码 In (Select 编码 From 区域 Where 上级编码 = v_Code省);
        --存在多行匹配，则继续增加长度，暂时从2个字增加到3个字匹配 
        If n_Count > 1 Then
          v_Tmp := Substr(v_Adrstmp, 1, 3);
          Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示), Max(上级编码)
          Into v_区县, v_Code区县, n_虚拟, n_不显示, v_Code市
          From 区域
          Where 名称 Like v_Tmp || '%' And Nvl(级数, 0) = 2 And 上级编码 In (Select 编码 From 区域 Where 上级编码 = v_Code省);
        End If;
        If v_Code市 Is Not Null Then
          v_Info区县 := v_区县 || ',' || v_Code区县 || ',' || n_虚拟 || ',' || n_不显示;
          v_Adrstmp  := Substr(v_Adrstmp, Length(v_区县) + 1);
          Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示)
          Into v_市, v_Code市, n_虚拟, n_不显示
          From 区域
          Where 编码 = v_Code市;
          v_Info市 := v_市 || ',' || v_Code市 || ',' || n_虚拟 || ',' || n_不显示;
        End If;
      Else
        v_Info市  := v_市 || ',' || v_Code市 || ',' || n_虚拟 || ',' || n_不显示;
        v_Adrstmp := Substr(v_Adrstmp, Length(v_市) + 1);
      End If;
      --没有区县，则解析区县 
      If Not v_Code市 Is Null And v_Code区县 Is Null Then
        --先截取县级的两个字做关键字，来匹配 
        v_Tmp := Substr(v_Adrstmp, 1, 2);
        Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示), Count(1)
        Into v_区县, v_Code区县, n_虚拟, n_不显示, n_Count
        From 区域
        Where 名称 Like v_Tmp || '%' And Nvl(级数, 0) = 2 And 上级编码 = v_Code市;
        --存在多行匹配，则继续增加长度，暂时从2个字增加到3个字匹配 
        If n_Count > 1 Then
          v_Tmp := Substr(v_Adrstmp, 1, 3);
          Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示)
          Into v_区县, v_Code区县, n_虚拟, n_不显示
          From 区域
          Where 名称 Like v_Tmp || '%' And Nvl(级数, 0) = 2 And 上级编码 = v_Code市;
        End If;
        If v_Code区县 Is Null Then
          Select Max(是否虚拟), Max(是否不显示) Into n_虚拟, n_不显示 From 区域 Where 上级编码 = v_Code市;
          If Nvl(n_虚拟, 0) = 1 Or Nvl(n_不显示, 0) = 1 Then
            Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示), Count(1), Max(上级编码)
            Into v_乡镇, v_Code乡镇, n_虚拟, n_不显示, n_Count, v_Code区县
            From 区域
            Where 名称 Like v_Tmp || '%' And Nvl(级数, 0) = 3 And 上级编码 In (Select 编码 From 区域 Where 上级编码 = v_Code市);
            --存在多行匹配，则继续增加长度，暂时从2个字增加到3个字匹配 
            If n_Count > 1 Then
              v_Tmp := Substr(v_Adrstmp, 1, 3);
              Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示), Max(上级编码)
              Into v_乡镇, v_Code乡镇, n_虚拟, n_不显示, v_Code区县
              From 区域
              Where 名称 Like v_Tmp || '%' And Nvl(级数, 0) = 3 And 上级编码 In (Select 编码 From 区域 Where 上级编码 = v_Code市);
            End If;
          
            If v_Code乡镇 Is Not Null Then
              v_Info乡镇 := v_乡镇 || ',' || v_Code乡镇 || ',' || n_虚拟 || ',' || n_不显示;
              v_Adrstmp  := Substr(v_Adrstmp, Length(v_乡镇) + 1);
              Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示)
              Into v_区县, v_Code区县, n_虚拟, n_不显示
              From 区域
              Where 编码 = v_Code区县;
              v_Info区县 := v_区县 || ',' || v_Code区县 || ',' || n_虚拟 || ',' || n_不显示;
            End If;
          End If;
        Else
          v_Info区县 := v_区县 || ',' || v_Code区县 || ',' || n_虚拟 || ',' || n_不显示;
          v_Adrstmp  := Substr(v_Adrstmp, Length(v_区县) + 1);
        End If;
      End If;
      If v_Code区县 Is Not Null And v_Code乡镇 Is Null Then
        --先截取乡镇级的两个字做关键字，来匹配 
        v_Tmp := Substr(v_Adrstmp, 1, 2);
        Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示), Count(1)
        Into v_乡镇, v_Code乡镇, n_虚拟, n_不显示, n_Count
        From 区域
        Where 名称 Like v_Tmp || '%' And Nvl(级数, 0) = 3 And 上级编码 = v_Code区县;
        --存在多行匹配，则继续增加长度，暂时从2个字增加到3个字匹配 
        If n_Count > 1 Then
          v_Tmp := Substr(v_Adrstmp, 1, 3);
          Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示), Count(1)
          Into v_乡镇, v_Code乡镇, n_虚拟, n_不显示, n_Count
          From 区域
          Where 名称 Like v_Tmp || '%' And Nvl(级数, 0) = 3 And 上级编码 = v_Code区县;
        End If;
        If v_Code乡镇 Is Null Then
          Select Max(是否虚拟), Max(是否不显示) Into n_虚拟, n_不显示 From 区域 Where 上级编码 = v_Code区县;
          If Nvl(n_虚拟, 0) = 1 Or Nvl(n_不显示, 0) = 1 Then
            Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示), Count(1), Max(上级编码)
            Into v_街道, v_Code街道, n_虚拟, n_不显示, n_Count, v_Code乡镇
            From 区域
            Where 名称 = v_Adrstmp And 上级编码 In (Select 编码 From 区域 Where 上级编码 = v_Code区县);
          End If;
          If v_Code乡镇 Is Not Null Then
            v_Info街道 := v_街道 || ',' || v_Code街道 || ',' || n_虚拟 || ',' || n_不显示;
            Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示)
            Into v_乡镇, v_Code乡镇, n_虚拟, n_不显示
            From 区域
            Where 编码 = v_Code乡镇;
            v_Info乡镇 := v_乡镇 || ',' || v_Code乡镇 || ',' || n_虚拟 || ',' || n_不显示;
          End If;
        Else
          v_Info乡镇 := v_乡镇 || ',' || v_Code乡镇 || ',' || n_虚拟 || ',' || n_不显示;
          v_Adrstmp  := Substr(v_Adrstmp, Length(v_乡镇) + 1);
        End If;
        If v_Code乡镇 Is Not Null And v_Code街道 Is Null Then
          Select Max(名称), Max(编码), Max(是否虚拟), Max(是否不显示)
          Into v_街道, v_Code街道, n_虚拟, n_不显示
          From 区域
          Where 名称 = v_Adrstmp And Nvl(级数, 0) = 4 And 上级编码 = v_Code乡镇;
          If v_Code街道 Is Not Null Then
            v_Info街道 := v_街道 || ',' || v_Code街道 || ',' || n_虚拟 || ',' || n_不显示;
          End If;
        End If;
      End If;
    End If;
    If v_街道 Is Null Then
      v_街道 := v_Adrstmp;
    End If;
  End If;
  v_Info省 := v_省 || ',' || v_Code省 || ',,,';
  If v_Info市 Is Null Then
    v_Info市 := v_市 || ',,,';
  End If;
  --只有省没有市，判断市是否只有虚拟级 
  If Not v_Code省 Is Null And v_市 Is Null Then
    Select Count(1)
    Into n_Count
    From 区域
    Where 上级编码 = v_Code省 And Nvl(是否虚拟, 0) = 0 And Nvl(是否不显示, 0) = 0 And Rownum < 2;
    If n_Count = 0 Then
      Select Count(1) Into n_Count From 区域 Where 上级编码 = v_Code省 And Rownum < 2;
      If n_Count = 0 Then
        v_Info市 := v_Info市 || ',';
      Else
        v_Info市 := v_Info市 || ',1';
      End If;
    Else
      v_Info市 := v_Info市 || ',';
    End If;
  Else
    v_Info市 := v_Info市 || ',';
  End If;
  If v_Info区县 Is Null Then
    v_Info区县 := v_区县 || ',,,';
  End If;
  --只有市没有区县，判断区县只有虚拟级 
  If Not v_Code市 Is Null And v_区县 Is Null Then
    Select Count(1)
    Into n_Count
    From 区域
    Where 上级编码 = v_Code市 And Nvl(是否虚拟, 0) = 0 And Nvl(是否不显示, 0) = 0 And Rownum < 2;
    If n_Count = 0 Then
      Select Count(1) Into n_Count From 区域 Where 上级编码 = v_Code市 And Rownum < 2;
      If n_Count = 0 Then
        v_Info区县 := v_Info区县 || ',';
      Else
        v_Info区县 := v_Info区县 || ',1';
      End If;
    Else
      v_Info区县 := v_Info区县 || ',';
    End If;
  Else
    v_Info区县 := v_Info区县 || ',';
  End If;
  If v_Info乡镇 Is Null Then
    v_Info乡镇 := v_乡镇 || ',,,';
  End If;
  --只有区县没有乡镇，判断乡镇是否只有虚拟的下级 
  If Not v_Code区县 Is Null And v_乡镇 Is Null Then
    Select Count(1)
    Into n_Count
    From 区域
    Where 上级编码 = v_Code区县 And Nvl(是否虚拟, 0) = 0 And Nvl(是否不显示, 0) = 0 And Rownum < 2;
    If n_Count = 0 Then
      Select Count(1) Into n_Count From 区域 Where 上级编码 = v_Code区县 And Rownum < 2;
      If n_Count = 0 Then
        v_Info乡镇 := v_Info乡镇 || ',';
      Else
        v_Info乡镇 := v_Info乡镇 || ',1';
      End If;
    Else
      v_Info乡镇 := v_Info乡镇 || ',';
    End If;
  Else
    v_Info乡镇 := v_Info乡镇 || ',';
  End If;
  If v_Info街道 Is Null Then
    v_Info街道 := v_街道 || ',,,,';
  Else
    v_Info街道 := v_Info街道 || ',';
  End If;
  v_Return := v_Info省 || '|' || v_Info市 || '|' || v_Info区县 || '|' || v_Info乡镇 || '|' || v_Info街道;
  Return(v_Return);
End;
/

--106331:刘尔旋,2017-02-22,服务窗锁号自动获取序号问题
--103236:刘尔旋,2016-12-22,支付宝服务窗停诊处理
Create Or Replace Procedure Zl_Third_Lockno
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:HIS锁号
  --入参:Xml_In:
  --<IN>
  --  <HM>5</HM>           //号码
  --  <CZJLID>1</CZJLID>       //出诊记录ID,出诊表排班模式下传入
  --  <RQ>2013-11-21 09:00</RQ>     //预约时间
  --  <CZ>1</CZ>           //操作
  --  <HX></HX>          //号序
  --  <HZDW>支付宝</HZDW>   //合作单位
  --  <JQM>机器名</JQM>        //机器名
  --  <SJD>时间段</SJD>        //锁号的时间段
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  -- <HX>号序</HX>          //锁号操作并且成功时返回
  -- 错误信息  //出错时返回
  --</ OUTPUT>
  --------------------------------------------------------------------------------------------------
  v_号码         挂号安排.号码%Type;
  d_日期         Date;
  n_操作类型     Number(3);
  n_序号控制     Number(3);
  n_存在         Number(3);
  n_分时段       Number(3);
  n_限号数       挂号安排限制.限号数%Type;
  n_安排id       挂号安排.Id%Type;
  n_计划id       挂号安排计划.Id%Type;
  n_号序         挂号序号状态.序号%Type;
  v_星期         挂号安排限制.限制项目%Type;
  v_操作员姓名   挂号序号状态.操作员姓名%Type;
  v_机器名       挂号序号状态.机器名%Type;
  v_验证姓名     挂号序号状态.操作员姓名%Type;
  v_验证机器名   挂号序号状态.机器名%Type;
  n_状态         挂号序号状态.状态%Type;
  v_合作单位     合作单位安排控制.合作单位%Type;
  n_合约模式     Number(3);
  n_启用合作单位 Number(3);
  v_Temp         Varchar2(32767); --临时XML
  v_Optemp       Varchar2(300);
  x_Templet      Xmltype; --模板XML
  n_Exists       Number(2);
  n_记录id       临床出诊记录.Id%Type;
  n_序号         临床出诊序号控制.序号%Type;
  n_数量         临床出诊序号控制.数量%Type;
  n_顺序号       临床出诊序号控制.预约顺序号%Type;
  d_启用时间     Date;
  v_时间段       Varchar2(200);
  v_Para         Varchar2(2000);
  n_挂号模式     Number(3);
  d_时段开始     Date;
  d_序号时间     Date;
  d_时段结束     Date;
  n_出诊         Number(3);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/HM'), To_Date(Extractvalue(Value(A), 'IN/RQ'), 'YYYY-MM-DD hh24:mi:ss'),
         Extractvalue(Value(A), 'IN/CZ'), Extractvalue(Value(A), 'IN/HX'), Extractvalue(Value(A), 'IN/HZDW'),
         Extractvalue(Value(A), 'IN/JQM'), Extractvalue(Value(A), 'IN/CZJLID'), Extractvalue(Value(A), 'IN/SJD')
  Into v_号码, d_日期, n_操作类型, n_号序, v_合作单位, v_机器名, n_记录id, v_时间段
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  v_Para     := zl_GetSysParameter(256);
  n_挂号模式 := Substr(v_Para, 1, 1);
  Begin
    d_启用时间 := To_Date(Substr(v_Para, 3), 'yyyy-mm-dd hh24:mi:ss');
  Exception
    When Others Then
      d_启用时间 := Null;
  End;
  If Sysdate - 10 > Nvl(d_启用时间, Sysdate - 30) Then
    If n_挂号模式 = 1 And Nvl(d_日期, Sysdate) > Nvl(d_启用时间, Sysdate - 30) And n_记录id Is Null Then
      v_Temp := '系统当前处于出诊表排班模式，传入的参数无法确定挂号安排，请重试！';
      Raise Err_Item;
    End If;
  Else
    If n_挂号模式 = 1 And Nvl(d_日期, Sysdate) > Nvl(d_启用时间, Sysdate - 30) And n_记录id Is Null Then
      Begin
        Select a.Id
        Into n_记录id
        From 临床出诊记录 A, 临床出诊号源 B
        Where a.号源id = b.Id And b.号码 = v_号码 And Nvl(d_日期, Sysdate) Between a.开始时间 And a.终止时间;
      Exception
        When Others Then
          v_Temp := '系统当前处于出诊表排班模式，传入的参数无法确定挂号安排，请重试！';
          Raise Err_Item;
      End;
    End If;
  End If;

  If v_时间段 Is Not Null And n_操作类型 = 1 Then
    Begin
      d_时段开始 := To_Date(To_Char(d_日期, 'yyyy-mm-dd') || Substr(v_时间段, 1, Instr(v_时间段, '-') - 1), 'yyyy-mm-dd hh24:mi:ss');
      If Substr(v_时间段, Instr(v_时间段, '-') + 1) Is Null Then
        d_时段结束 := Null;
      Else
        d_时段结束 := To_Date(To_Char(d_日期, 'yyyy-mm-dd') || Substr(v_时间段, Instr(v_时间段, '-') + 1), 'yyyy-mm-dd hh24:mi:ss');
      End If;
    Exception
      When Others Then
        v_Temp := '无法解析传入的时间段格式，请检查！';
        Raise Err_Item;
    End;
  End If;

  If v_机器名 Is Null Then
    Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
  End If;
  v_Optemp := Zl_Identity(1);
  Select Substr(v_Optemp, Instr(v_Optemp, ',') + 1) Into v_Optemp From Dual;
  Select Substr(v_Optemp, Instr(v_Optemp, ',') + 1) Into v_操作员姓名 From Dual;

  If n_记录id Is Null Then
    If n_操作类型 = 0 Then
      --解锁
      Select Nvl(Max(1), 0)
      Into n_Exists
      From 挂号序号状态
      Where 机器名 = v_机器名 And 操作员姓名 = v_操作员姓名 And 状态 = 5 And 序号 = n_号序 And Trunc(日期) = Trunc(d_日期) And 号码 = v_号码 And
            Rownum < 2;
      If n_Exists = 1 Then
        Delete 挂号序号状态
        Where 机器名 = v_机器名 And 操作员姓名 = v_操作员姓名 And 状态 = 5 And 序号 = n_号序 And Trunc(日期) = Trunc(d_日期) And 号码 = v_号码;
        v_Temp := '<HX>' || n_号序 || '</HX>';
        Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
      Else
        v_Temp := '没有发现需要解锁的序号';
        Raise Err_Item;
      End If;
    End If;
  
    If n_操作类型 = 1 Then
      --锁号
      Select Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六',
                     Null)
      Into v_星期
      From Dual;
      Begin
        Select 序号控制, ID
        Into n_序号控制, n_计划id
        From (Select 序号控制, ID
               From 挂号安排计划
               Where 号码 = v_号码 And d_日期 Between Nvl(生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                     Nvl(失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And 审核时间 Is Not Null
               Order By 生效时间 Desc)
        Where Rownum < 2;
      Exception
        When Others Then
          Select 序号控制, ID Into n_序号控制, n_安排id From 挂号安排 Where 号码 = v_号码;
      End;
      If n_序号控制 = 1 Then
        If Nvl(n_计划id, 0) <> 0 Then
          Select Nvl(Max(1), 0)
          Into n_分时段
          From 挂号计划时段
          Where 星期 = v_星期 And 计划id = n_计划id And Rownum < 2;
          Select Nvl(Max(1), 0)
          Into n_启用合作单位
          From 合作单位计划控制
          Where 限制项目 = v_星期 And 计划id = n_计划id And 合作单位 = v_合作单位 And Rownum < 2;
          If v_时间段 Is Null Then
            Begin
              Select 1, a.状态, a.操作员姓名, a.机器名
              Into n_存在, n_状态, v_验证姓名, v_验证机器名
              From 挂号序号状态 A, 挂号计划时段 B
              Where a.号码 = v_号码 And Trunc(a.日期) = Trunc(d_日期) And a.序号 = b.序号 And b.计划id = n_计划id And b.星期 = v_星期 And
                    To_Char(b.开始时间, 'hh24:mi') = To_Char(d_日期, 'hh24:mi') And Rownum < 2;
            Exception
              When Others Then
                n_存在 := 0;
            End;
          Else
            n_存在 := 0;
          End If;
        
          If n_存在 = 1 Then
            If n_状态 = 5 And v_验证姓名 = v_操作员姓名 And v_机器名 = v_验证机器名 Then
              Null;
            Else
              --传入时间的序号已经被使用
              v_Temp := '传入时间' || d_日期 || '的序号已被使用';
              Raise Err_Item;
            End If;
          Else
            If n_分时段 = 1 Then
              If v_时间段 Is Null Then
                --精确定位序号
                Begin
                  Select 序号
                  Into n_号序
                  From 挂号计划时段
                  Where 计划id = n_计划id And 星期 = v_星期 And To_Char(开始时间, 'hh24:mi') = To_Char(d_日期, 'hh24:mi') And
                        Rownum < 2;
                Exception
                  When Others Then
                    Select Max(序号) + 1
                    Into n_号序
                    From (Select Distinct 序号
                           From 挂号计划时段
                           Where 计划id = n_计划id And 星期 = v_星期
                           Union
                           Select Distinct 序号 From 挂号序号状态 Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期));
                  
                End;
                Begin
                  Select 1 Into n_存在 From 挂号序号状态 Where 号码 = v_号码 And 日期 = d_日期 And 序号 = n_号序;
                Exception
                  When Others Then
                    Insert Into 挂号序号状态
                      (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                    Values
                      (v_号码, d_日期, n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                End;
              Else
                --时间段自动取序号
                Begin
                  Select Min(a.序号)
                  Into n_号序
                  From 挂号计划时段 A, 挂号序号状态 B
                  Where a.序号 = b.序号(+) And Nvl(b.状态, 0) = 0 And b.号码(+) = v_号码 And Trunc(b.日期(+)) = Trunc(d_日期) And
                        a.计划id = n_计划id And a.星期 = v_星期 And To_Char(a.开始时间, 'hh24:mi') >= To_Char(d_时段开始, 'hh24:mi') And
                        To_Char(a.开始时间, 'hh24:mi') < To_Char(d_时段结束, 'hh24:mi');
                  If Nvl(n_号序, 0) = 0 Then
                    If d_时段结束 Is Null Then
                      Select Max(序号) + 1
                      Into n_号序
                      From (Select Distinct 序号
                             From 挂号计划时段
                             Where 计划id = n_计划id And 星期 = v_星期
                             Union
                             Select Distinct 序号 From 挂号序号状态 Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期));
                    Else
                      v_Temp := '传入时间段' || v_时间段 || '的序号已被使用完';
                      Raise Err_Item;
                    End If;
                  End If;
                Exception
                  When Others Then
                    If d_时段结束 Is Null Then
                      Select Max(序号) + 1
                      Into n_号序
                      From (Select Distinct 序号
                             From 挂号计划时段
                             Where 计划id = n_计划id And 星期 = v_星期
                             Union
                             Select Distinct 序号 From 挂号序号状态 Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期));
                    Else
                      v_Temp := '传入时间段' || v_时间段 || '的序号已被使用完';
                      Raise Err_Item;
                    End If;
                End;
                Begin
                  Select To_Date(To_Char(d_日期, 'yyyy-mm-dd') || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss')
                  Into d_序号时间
                  From 挂号计划时段
                  Where 计划id = n_计划id And 星期 = v_星期 And 序号 = n_号序;
                Exception
                  When Others Then
                    d_序号时间 := d_日期;
                End;
                Begin
                  Select 1 Into n_存在 From 挂号序号状态 Where 号码 = v_号码 And 日期 = d_序号时间 And 序号 = n_号序;
                Exception
                  When Others Then
                    Insert Into 挂号序号状态
                      (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                    Values
                      (v_号码, d_序号时间, n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                End;
              End If;
              v_Temp := '<HX>' || n_号序 || '</HX>';
              Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
            Else
              If v_合作单位 Is Null Or n_启用合作单位 = 0 Then
                If Trunc(d_日期) = Trunc(Sysdate) Then
                  n_号序 := 1;
                  Select 限号数 Into n_限号数 From 挂号计划限制 Where 计划id = n_计划id And 限制项目 = v_星期;
                  For r_序号 In (Select 序号, 状态, 操作员姓名, 机器名
                               From 挂号序号状态
                               Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期)
                               Order By 序号) Loop
                    Exit When r_序号.状态 = 5 And r_序号.操作员姓名 = v_操作员姓名 And r_序号.机器名 = v_机器名;
                    If r_序号.序号 = n_号序 Then
                      n_号序 := n_号序 + 1;
                    End If;
                  End Loop;
                  If n_号序 > n_限号数 Then
                    v_Temp := '传入号别' || v_号码 || '的所有序号已被用完';
                    Raise Err_Item;
                  Else
                    Begin
                      Select 1
                      Into n_存在
                      From 挂号序号状态
                      Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期) And 序号 = n_号序;
                    Exception
                      When Others Then
                        Insert Into 挂号序号状态
                          (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                        Values
                          (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                    End;
                    v_Temp := '<HX>' || n_号序 || '</HX>';
                    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                  End If;
                Else
                  n_号序 := 1;
                  Select 限号数 Into n_限号数 From 挂号计划限制 Where 计划id = n_计划id And 限制项目 = v_星期;
                  For r_序号 In (Select 序号, 状态, 操作员姓名, 机器名
                               From 挂号序号状态
                               Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期)
                               
                               Union
                               Select 序号, Null, Null, Null
                               From 合作单位计划控制
                               Where 计划id = n_计划id And 限制项目 = v_星期 And 数量 <> 0
                               Order By 序号) Loop
                    Exit When r_序号.状态 = 5 And r_序号.操作员姓名 = v_操作员姓名 And r_序号.机器名 = v_机器名;
                    If r_序号.序号 = n_号序 Then
                      n_号序 := n_号序 + 1;
                    End If;
                  End Loop;
                  If n_号序 > n_限号数 Then
                    v_Temp := '传入号别' || v_号码 || '的所有序号已被用完';
                    Raise Err_Item;
                  Else
                    Begin
                      Select 1
                      Into n_存在
                      From 挂号序号状态
                      Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期) And 序号 = n_号序;
                    Exception
                      When Others Then
                        Insert Into 挂号序号状态
                          (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                        Values
                          (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                    End;
                    v_Temp := '<HX>' || n_号序 || '</HX>';
                    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                  End If;
                End If;
              Else
                Select Count(1)
                Into n_合约模式
                From 合作单位计划控制
                Where 序号 = 0 And 计划id = n_计划id And 合作单位 = v_合作单位 And 限制项目 = v_星期 And 数量 <> 0;
                If n_合约模式 = 0 Then
                  Begin
                    Select 序号
                    Into n_号序
                    From (Select 序号
                           From 合作单位计划控制 A
                           Where 计划id = n_计划id And 合作单位 = v_合作单位 And 限制项目 = v_星期 And 数量 <> 0 And
                                 (Not Exists
                                  (Select 1
                                   From 挂号序号状态
                                   Where 号码 = v_号码 And 序号 = a.序号 And Trunc(日期) = Trunc(d_日期) And 状态 <> 0) Or Exists
                                  (Select 1
                                   From 挂号序号状态
                                   Where 号码 = v_号码 And 序号 = a.序号 And Trunc(日期) = Trunc(d_日期) And 状态 = 5 And 操作员姓名 = v_操作员姓名 And
                                         机器名 = v_机器名))
                           Order By 序号)
                    Where Rownum < 2;
                  Exception
                    When Others Then
                      n_号序 := 0;
                  End;
                  If n_号序 = 0 Then
                    v_Temp := '传入号别' || v_号码 || '的所有序号已被用完';
                    Raise Err_Item;
                  Else
                    Begin
                      Select 1
                      Into n_存在
                      From 挂号序号状态
                      Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期) And 序号 = n_号序;
                    Exception
                      When Others Then
                        Insert Into 挂号序号状态
                          (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                        Values
                          (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                    End;
                    v_Temp := '<HX>' || n_号序 || '</HX>';
                    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                  End If;
                Else
                  n_号序 := 1;
                  Select 限号数 Into n_限号数 From 挂号计划限制 Where 计划id = n_计划id And 限制项目 = v_星期;
                  For r_序号 In (Select 序号, 状态, 操作员姓名, 机器名
                               From 挂号序号状态
                               Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期)
                               
                               Union
                               Select 序号, Null, Null, Null
                               From 合作单位计划控制
                               Where 计划id = n_计划id And 限制项目 = v_星期 And 数量 <> 0
                               Order By 序号) Loop
                    Exit When r_序号.状态 = 5 And r_序号.操作员姓名 = v_操作员姓名 And r_序号.机器名 = v_机器名;
                    If r_序号.序号 = n_号序 Then
                      n_号序 := n_号序 + 1;
                    End If;
                  End Loop;
                  If n_号序 > n_限号数 Then
                    v_Temp := '传入号别' || v_号码 || '的所有序号已被用完';
                    Raise Err_Item;
                  Else
                    Begin
                      Select 1
                      Into n_存在
                      From 挂号序号状态
                      Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期) And 序号 = n_号序;
                    Exception
                      When Others Then
                        Insert Into 挂号序号状态
                          (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                        Values
                          (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                    End;
                    v_Temp := '<HX>' || n_号序 || '</HX>';
                    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                  End If;
                End If;
              End If;
            End If;
          End If;
        Else
          Select Nvl(Max(1), 0)
          Into n_分时段
          From 挂号安排时段
          Where 星期 = v_星期 And 安排id = n_安排id And Rownum < 2;
          Select Nvl(Max(1), 0)
          Into n_启用合作单位
          From 合作单位安排控制
          Where 限制项目 = v_星期 And 安排id = n_安排id And 合作单位 = v_合作单位 And Rownum < 2;
          If v_时间段 Is Null Then
            Begin
              Select 1, a.状态, a.操作员姓名, a.机器名
              Into n_存在, n_状态, v_验证姓名, v_验证机器名
              From 挂号序号状态 A, 挂号安排时段 B
              Where a.号码 = v_号码 And Trunc(a.日期) = Trunc(d_日期) And a.序号 = b.序号 And b.安排id = n_安排id And b.星期 = v_星期 And
                    To_Char(b.开始时间, 'hh24:mi') = To_Char(d_日期, 'hh24:mi') And Rownum < 2;
            Exception
              When Others Then
                n_存在 := 0;
            End;
          Else
            n_存在 := 0;
          End If;
          If n_存在 = 1 Then
            If n_状态 = 5 And v_验证姓名 = v_操作员姓名 And v_机器名 = v_验证机器名 Then
              Null;
            Else
              --传入时间的序号已经被使用
              v_Temp := '传入时间' || d_日期 || '的序号已被使用';
              Raise Err_Item;
            End If;
          Else
            If n_分时段 = 1 Then
              If v_时间段 Is Null Then
                Begin
                  Select 序号
                  Into n_号序
                  From 挂号安排时段
                  Where 安排id = n_安排id And 星期 = v_星期 And To_Char(开始时间, 'hh24:mi') = To_Char(d_日期, 'hh24:mi') And
                        Rownum < 2;
                Exception
                  When Others Then
                    Select Max(序号) + 1
                    Into n_号序
                    From (Select Distinct 序号
                           From 挂号安排时段
                           Where 安排id = n_安排id And 星期 = v_星期
                           Union
                           Select Distinct 序号 From 挂号序号状态 Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期));
                End;
                Begin
                  Select 1 Into n_存在 From 挂号序号状态 Where 号码 = v_号码 And 日期 = d_日期 And 序号 = n_号序;
                Exception
                  When Others Then
                    Insert Into 挂号序号状态
                      (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                    Values
                      (v_号码, d_日期, n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                End;
              Else
                --时间段自动取序号
                Begin
                  Select Min(a.序号)
                  Into n_号序
                  From 挂号安排时段 A, 挂号序号状态 B
                  Where a.序号 = b.序号(+) And Nvl(b.状态, 0) = 0 And b.号码(+) = v_号码 And Trunc(b.日期(+)) = Trunc(d_日期) And
                        a.安排id = n_安排id And a.星期 = v_星期 And To_Char(a.开始时间, 'hh24:mi') >= To_Char(d_时段开始, 'hh24:mi') And
                        To_Char(a.开始时间, 'hh24:mi') < To_Char(d_时段结束, 'hh24:mi');
                  If n_号序 Is Null Then
                    If d_时段结束 Is Null Then
                      Select Max(序号) + 1
                      Into n_号序
                      From (Select Distinct 序号
                             From 挂号安排时段
                             Where 安排id = n_安排id And 星期 = v_星期
                             Union
                             Select Distinct 序号 From 挂号序号状态 Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期));
                    Else
                      v_Temp := '传入时间段' || v_时间段 || '的序号已被使用完';
                      Raise Err_Item;
                    End If;
                  End If;
                Exception
                  When Others Then
                    If d_时段结束 Is Null Then
                      Select Max(序号) + 1
                      Into n_号序
                      From (Select Distinct 序号
                             From 挂号安排时段
                             Where 安排id = n_安排id And 星期 = v_星期
                             Union
                             Select Distinct 序号 From 挂号序号状态 Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期));
                    Else
                      v_Temp := '传入时间段' || v_时间段 || '的序号已被使用完';
                      Raise Err_Item;
                    End If;
                  
                End;
                Begin
                  Select To_Date(To_Char(d_日期, 'yyyy-mm-dd') || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss')
                  Into d_序号时间
                  From 挂号安排时段
                  Where 安排id = n_安排id And 星期 = v_星期 And 序号 = n_号序;
                Exception
                  When Others Then
                    d_序号时间 := d_日期;
                End;
                Begin
                  Select 1 Into n_存在 From 挂号序号状态 Where 号码 = v_号码 And 日期 = d_序号时间 And 序号 = n_号序;
                Exception
                  When Others Then
                    Insert Into 挂号序号状态
                      (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                    Values
                      (v_号码, d_序号时间, n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                End;
              End If;
              v_Temp := '<HX>' || n_号序 || '</HX>';
              Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
            Else
              If v_合作单位 Is Null Or n_启用合作单位 = 0 Then
                If Trunc(d_日期) = Trunc(Sysdate) Then
                  n_号序 := 1;
                  Select 限号数 Into n_限号数 From 挂号安排限制 Where 安排id = n_安排id And 限制项目 = v_星期;
                  For r_序号 In (Select 序号, 状态, 操作员姓名, 机器名
                               From 挂号序号状态
                               Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期)
                               Order By 序号) Loop
                    Exit When r_序号.状态 = 5 And r_序号.操作员姓名 = v_操作员姓名 And r_序号.机器名 = v_机器名;
                    If r_序号.序号 = n_号序 Then
                      n_号序 := n_号序 + 1;
                    End If;
                  End Loop;
                  If n_号序 > n_限号数 Then
                    v_Temp := '传入号别' || v_号码 || '的所有序号已被用完';
                    Raise Err_Item;
                  Else
                    Begin
                      Select 1
                      Into n_存在
                      From 挂号序号状态
                      Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期) And 序号 = n_号序;
                    Exception
                      When Others Then
                        Insert Into 挂号序号状态
                          (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                        Values
                          (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                    End;
                    v_Temp := '<HX>' || n_号序 || '</HX>';
                    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                  End If;
                Else
                  n_号序 := 1;
                  Select 限号数 Into n_限号数 From 挂号安排限制 Where 安排id = n_安排id And 限制项目 = v_星期;
                  For r_序号 In (Select 序号, 状态, 操作员姓名, 机器名
                               From 挂号序号状态
                               Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期)
                               
                               Union
                               Select 序号, Null, Null, Null
                               From 合作单位安排控制
                               Where 安排id = n_安排id And 限制项目 = v_星期 And 数量 <> 0
                               Order By 序号) Loop
                    Exit When r_序号.状态 = 5 And r_序号.操作员姓名 = v_操作员姓名 And r_序号.机器名 = v_机器名;
                    If r_序号.序号 = n_号序 Then
                      n_号序 := n_号序 + 1;
                    End If;
                  End Loop;
                  If n_号序 > n_限号数 Then
                    v_Temp := '传入号别' || v_号码 || '的所有序号已被用完';
                    Raise Err_Item;
                  Else
                    Begin
                      Select 1
                      Into n_存在
                      From 挂号序号状态
                      Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期) And 序号 = n_号序;
                    Exception
                      When Others Then
                        Insert Into 挂号序号状态
                          (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                        Values
                          (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                    End;
                    v_Temp := '<HX>' || n_号序 || '</HX>';
                    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                  End If;
                End If;
              Else
                Select Count(1)
                Into n_合约模式
                From 合作单位安排控制
                Where 序号 = 0 And 安排id = n_安排id And 合作单位 = v_合作单位 And 限制项目 = v_星期 And 数量 <> 0;
                If n_合约模式 = 0 Then
                  Begin
                    Select 序号
                    Into n_号序
                    From (Select 序号
                           From 合作单位安排控制 A
                           Where 安排id = n_安排id And 合作单位 = v_合作单位 And 限制项目 = v_星期 And 数量 <> 0 And
                                 (Not Exists
                                  (Select 1
                                   From 挂号序号状态
                                   Where 号码 = v_号码 And 序号 = a.序号 And Trunc(日期) = Trunc(d_日期) And 状态 <> 0) Or Exists
                                  (Select 1
                                   From 挂号序号状态
                                   Where 号码 = v_号码 And 序号 = a.序号 And Trunc(日期) = Trunc(d_日期) And 状态 = 5 And 操作员姓名 = v_操作员姓名 And
                                         机器名 = v_机器名))
                           Order By 序号)
                    Where Rownum < 2;
                  Exception
                    When Others Then
                      n_号序 := 0;
                  End;
                  If n_号序 = 0 Then
                    v_Temp := '传入号别' || v_号码 || '的所有序号已被用完';
                    Raise Err_Item;
                  Else
                    Begin
                      Select 1
                      Into n_存在
                      From 挂号序号状态
                      Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期) And 序号 = n_号序;
                    Exception
                      When Others Then
                        Insert Into 挂号序号状态
                          (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                        Values
                          (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                    End;
                    v_Temp := '<HX>' || n_号序 || '</HX>';
                    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                  End If;
                Else
                  n_号序 := 1;
                  Select 限号数 Into n_限号数 From 挂号安排限制 Where 安排id = n_安排id And 限制项目 = v_星期;
                  For r_序号 In (Select 序号, 状态, 操作员姓名, 机器名
                               From 挂号序号状态
                               Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期)
                               
                               Union
                               Select 序号, Null, Null, Null
                               From 合作单位安排控制
                               Where 安排id = n_安排id And 限制项目 = v_星期 And 数量 <> 0
                               Order By 序号) Loop
                    Exit When r_序号.状态 = 5 And r_序号.操作员姓名 = v_操作员姓名 And r_序号.机器名 = v_机器名;
                    If r_序号.序号 = n_号序 Then
                      n_号序 := n_号序 + 1;
                    End If;
                  End Loop;
                  If n_号序 > n_限号数 Then
                    v_Temp := '传入号别' || v_号码 || '的所有序号已被用完';
                    Raise Err_Item;
                  Else
                    Begin
                      Select 1
                      Into n_存在
                      From 挂号序号状态
                      Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期) And 序号 = n_号序;
                    Exception
                      When Others Then
                        Insert Into 挂号序号状态
                          (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                        Values
                          (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                    End;
                    v_Temp := '<HX>' || n_号序 || '</HX>';
                    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                  End If;
                End If;
              End If;
            End If;
          End If;
        End If;
      End If;
    End If;
  Else
    --出诊表排班模式
    If n_操作类型 = 0 Then
      --解锁
      Select Nvl(Max(1), 0)
      Into n_Exists
      From 临床出诊序号控制
      Where 工作站名称 = v_机器名 And 操作员姓名 = v_操作员姓名 And 挂号状态 = 5 And (序号 = n_号序 Or 备注 = n_号序) And 记录id = n_记录id And
            Rownum < 2;
      If n_Exists = 1 Then
        Update 临床出诊序号控制
        Set 挂号状态 = 0
        Where 工作站名称 = v_机器名 And 操作员姓名 = v_操作员姓名 And 挂号状态 = 5 And (序号 = n_号序 Or 备注 = n_号序) And 记录id = n_记录id;
        v_Temp := '<HX>' || n_号序 || '</HX>';
        Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
      Else
        v_Temp := '没有发现需要解锁的序号';
        Raise Err_Item;
      End If;
    End If;
  
    If n_操作类型 = 1 Then
      --锁号
      Select Nvl(Max(1), 0)
      Into n_出诊
      From 临床出诊记录
      Where ID = n_记录id And d_日期 Between 开始时间 And 终止时间 And Rownum < 2;
      If Nvl(n_出诊, 0) = 0 Then
        v_Temp := '传入的出诊记录与时间不符,请检查!';
        Raise Err_Item;
      End If;
      If n_号序 Is Null Then
        Select 是否序号控制, 是否分时段 Into n_序号控制, n_分时段 From 临床出诊记录 Where ID = n_记录id;
        Select Nvl(Max(1), 0)
        Into n_启用合作单位
        From 临床出诊挂号控制记录
        Where 记录id = n_记录id And 名称 = v_合作单位 And 类型 = 1 And 性质 = 1 And Rownum < 2;
        If n_序号控制 = 1 Then
          If n_分时段 = 1 Then
            If v_时间段 Is Null Then
              Update 临床出诊序号控制
              Set 备注 = 备注
              Where 记录id = n_记录id And 开始时间 <> 终止时间 And To_Char(开始时间, 'hh24:mi') = To_Char(d_日期, 'hh24:mi') And
                    Rownum < 2;
              Begin
                Select 1, 挂号状态, 操作员姓名, 工作站名称
                Into n_存在, n_状态, v_验证姓名, v_验证机器名
                From 临床出诊序号控制
                Where 记录id = n_记录id And 开始时间 <> 终止时间 And To_Char(开始时间, 'hh24:mi') = To_Char(d_日期, 'hh24:mi') And
                      Nvl(挂号状态, 0) <> 0 And Rownum < 2;
              Exception
                When Others Then
                  n_存在 := 0;
              End;
            Else
              n_存在 := 0;
            End If;
          
            If n_存在 = 1 Then
              If n_状态 = 5 And v_验证姓名 = v_操作员姓名 And v_机器名 = v_验证机器名 Then
                Null;
              Else
                --传入时间的序号已经被使用
                v_Temp := '传入时间' || d_日期 || '的序号已被使用';
                Raise Err_Item;
              End If;
            Else
              If v_时间段 Is Null Then
                Begin
                  Select 序号
                  Into n_序号
                  From 临床出诊序号控制
                  Where 记录id = n_记录id And 开始时间 <> 终止时间 And To_Char(开始时间, 'hh24:mi') = To_Char(d_日期, 'hh24:mi') And
                        Nvl(挂号状态, 0) = 0 And Nvl(是否停诊, 0) <> 1 And Rownum < 2;
                Exception
                  When Others Then
                    If Trunc(d_日期) = Trunc(Sysdate) Then
                      Select Min(序号)
                      Into n_序号
                      From 临床出诊序号控制
                      Where 记录id = n_记录id And 开始时间 >= d_日期 And Nvl(挂号状态, 0) = 0 And Nvl(是否停诊, 0) <> 1;
                      If Nvl(n_序号, 0) = 0 Then
                        Select Max(序号) + 1 Into n_序号 From 临床出诊序号控制 Where 记录id = n_记录id;
                      End If;
                    Else
                      v_Temp := '传入时间' || d_日期 || '没有找到对应的序号,无法预约';
                      Raise Err_Item;
                    End If;
                End;
                Update 临床出诊序号控制
                Set 挂号状态 = 5, 锁号时间 = Sysdate, 操作员姓名 = v_操作员姓名, 工作站名称 = v_机器名
                Where 记录id = n_记录id And 序号 = n_序号;
                If Sql%RowCount = 0 Then
                  Insert Into 临床出诊序号控制
                    (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 锁号时间, 名称, 类型, 操作员姓名, 工作站名称)
                    Select 记录id, n_序号,
                           To_Date(To_Char(开始时间, 'yyyy-mm-dd') || ' ' || To_Char(d_日期, 'hh24:mi:ss'),
                                    'yyyy-mm-dd hh24:mi:ss'),
                           To_Date(To_Char(开始时间, 'yyyy-mm-dd') || ' ' || To_Char(d_日期, 'hh24:mi:ss'),
                                    'yyyy-mm-dd hh24:mi:ss'), 1, 是否预约, 5, Sysdate, v_合作单位, 1, v_操作员姓名, v_机器名
                    From 临床出诊序号控制
                    Where 记录id = n_记录id And Rownum < 2;
                End If;
              Else
                Begin
                  Select Min(序号)
                  Into n_序号
                  From 临床出诊序号控制
                  Where 记录id = n_记录id And 开始时间 <> 终止时间 And To_Char(开始时间, 'hh24:mi') >= To_Char(d_时段开始, 'hh24:mi') And
                        Nvl(挂号状态, 0) = 0 And Nvl(是否停诊, 0) <> 1 And
                        To_Char(开始时间, 'hh24:mi') < To_Char(d_时段结束, 'hh24:mi') And Rownum < 2;
                  If Nvl(n_序号, 0) = 0 Then
                    If d_时段结束 Is Null Then
                      If Trunc(d_日期) = Trunc(Sysdate) Then
                        Select Min(序号)
                        Into n_序号
                        From 临床出诊序号控制
                        Where 记录id = n_记录id And 开始时间 >= d_日期 And Nvl(挂号状态, 0) = 0 And Nvl(是否停诊, 0) <> 1;
                        If Nvl(n_序号, 0) = 0 Then
                          Select Max(序号) + 1 Into n_序号 From 临床出诊序号控制 Where 记录id = n_记录id;
                        End If;
                      Else
                        v_Temp := '传入时间' || d_日期 || '没有找到对应的序号,无法预约';
                        Raise Err_Item;
                      End If;
                    
                    Else
                      v_Temp := '传入时间段' || v_时间段 || '序号已被使用完,无法预约';
                      Raise Err_Item;
                    End If;
                  End If;
                Exception
                  When Others Then
                    If d_时段结束 Is Null Then
                      If Trunc(d_日期) = Trunc(Sysdate) Then
                        Select Min(序号)
                        Into n_序号
                        From 临床出诊序号控制
                        Where 记录id = n_记录id And 开始时间 >= d_日期 And Nvl(挂号状态, 0) = 0 And Nvl(是否停诊, 0) <> 1;
                        If Nvl(n_序号, 0) = 0 Then
                          Select Max(序号) + 1 Into n_序号 From 临床出诊序号控制 Where 记录id = n_记录id;
                        End If;
                      Else
                        v_Temp := '传入时间' || d_日期 || '没有找到对应的序号,无法预约';
                        Raise Err_Item;
                      End If;
                    Else
                      v_Temp := '传入时间段' || v_时间段 || '序号已被使用完,无法预约';
                      Raise Err_Item;
                    End If;
                End;
                Update 临床出诊序号控制
                Set 挂号状态 = 5, 锁号时间 = Sysdate, 操作员姓名 = v_操作员姓名, 工作站名称 = v_机器名
                Where 记录id = n_记录id And 序号 = n_序号;
                If Sql%RowCount = 0 Then
                  Insert Into 临床出诊序号控制
                    (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 锁号时间, 名称, 类型, 操作员姓名, 工作站名称)
                    Select 记录id, n_序号,
                           To_Date(To_Char(开始时间, 'yyyy-mm-dd') || ' ' || To_Char(d_日期, 'hh24:mi:ss'),
                                    'yyyy-mm-dd hh24:mi:ss'),
                           
                           To_Date(To_Char(开始时间, 'yyyy-mm-dd') || ' ' || To_Char(d_日期, 'hh24:mi:ss'),
                                    'yyyy-mm-dd hh24:mi:ss'), 1, 是否预约, 5, Sysdate, v_合作单位, 1, v_操作员姓名, v_机器名
                    From 临床出诊序号控制
                    Where 记录id = n_记录id And Rownum < 2;
                End If;
              End If;
            End If;
            v_Temp := '<HX>' || n_序号 || '</HX>';
            Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
          Else
            If v_合作单位 Is Null Or n_启用合作单位 = 0 Then
              --非合作单位
              Select Min(序号)
              Into n_序号
              From 临床出诊序号控制
              Where 记录id = n_记录id And Nvl(挂号状态, 0) = 0 And Nvl(是否停诊, 0) <> 1;
              If Nvl(n_序号, 0) = 0 Then
                Select Max(序号) + 1 Into n_序号 From 临床出诊序号控制 Where 记录id = n_记录id;
              End If;
              Update 临床出诊序号控制
              Set 挂号状态 = 5, 锁号时间 = Sysdate, 操作员姓名 = v_操作员姓名, 工作站名称 = v_机器名
              Where 记录id = n_记录id And 序号 = n_序号;
              If Sql%RowCount = 0 Then
                Insert Into 临床出诊序号控制
                  (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 锁号时间, 名称, 类型, 操作员姓名, 工作站名称)
                  Select 记录id, n_序号,
                         To_Date(To_Char(开始时间, 'yyyy-mm-dd') || ' ' || To_Char(d_日期, 'hh24:mi:ss'),
                                  'yyyy-mm-dd hh24:mi:ss'),
                         To_Date(To_Char(开始时间, 'yyyy-mm-dd') || ' ' || To_Char(d_日期, 'hh24:mi:ss'),
                                  'yyyy-mm-dd hh24:mi:ss'), 1, 是否预约, 5, Sysdate, v_合作单位, 1, v_操作员姓名, v_机器名
                  From 临床出诊序号控制
                  Where 记录id = n_记录id And Rownum < 2;
              End If;
              v_Temp := '<HX>' || n_序号 || '</HX>';
              Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
            Else
              --合作单位
              Begin
                Select 控制方式
                Into n_合约模式
                From 临床出诊挂号控制记录
                Where 记录id = n_记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位 And Rownum < 2;
              Exception
                When Others Then
                  n_合约模式 := 4;
              End;
              If n_合约模式 = 0 Then
                v_Temp := '本号别禁止该合作单位预约!';
                Raise Err_Item;
              End If;
              If n_合约模式 = 1 Or n_合约模式 = 2 Or n_合约模式 = 4 Then
                Select Min(序号)
                Into n_序号
                From 临床出诊序号控制
                Where 记录id = n_记录id And Nvl(挂号状态, 0) = 0 And Nvl(是否停诊, 0) <> 1;
                If n_序号 = 0 Then
                  Select Max(序号) + 1 Into n_序号 From 临床出诊序号控制 Where 记录id = n_记录id;
                End If;
              End If;
              If n_合约模式 = 3 Then
                Select Min(a.序号)
                Into n_序号
                From 临床出诊序号控制 A, 临床出诊挂号控制记录 B
                Where a.记录id = n_记录id And a.记录id = b.记录id And b.类型 = 1 And b.性质 = 1 And b.名称 = v_合作单位 And a.序号 = b.序号 And
                      Nvl(a.挂号状态, 0) = 0 And Nvl(是否停诊, 0) <> 1;
                If n_序号 = 0 Then
                  v_Temp := '本号别合作单位可预约序号已经全部使用完!';
                  Raise Err_Item;
                End If;
              End If;
              Update 临床出诊序号控制
              Set 挂号状态 = 5, 锁号时间 = Sysdate, 操作员姓名 = v_操作员姓名, 工作站名称 = v_机器名
              Where 记录id = n_记录id And 序号 = n_序号;
              If Sql%RowCount = 0 Then
                Insert Into 临床出诊序号控制
                  (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 锁号时间, 名称, 类型, 操作员姓名, 工作站名称)
                  Select 记录id, n_序号,
                         To_Date(To_Char(开始时间, 'yyyy-mm-dd') || ' ' || To_Char(d_日期, 'hh24:mi:ss'),
                                  'yyyy-mm-dd hh24:mi:ss'),
                         To_Date(To_Char(开始时间, 'yyyy-mm-dd') || ' ' || To_Char(d_日期, 'hh24:mi:ss'),
                                  'yyyy-mm-dd hh24:mi:ss'), 1, 是否预约, 5, Sysdate, v_合作单位, 1, v_操作员姓名, v_机器名
                  From 临床出诊序号控制
                  Where 记录id = n_记录id And Rownum < 2;
              End If;
              v_Temp := '<HX>' || n_序号 || '</HX>';
              Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
            End If;
          End If;
        End If;
      Else
        --非序号控制
        If n_分时段 = 1 Then
          If v_合作单位 Is Null Or n_启用合作单位 = 0 Then
            Begin
              If v_时间段 Is Null Then
                Select 序号, 数量
                Into n_号序, n_数量
                From 临床出诊序号控制
                Where 记录id = n_记录id And 预约顺序号 Is Null And 开始时间 = d_日期;
              Else
                Select Min(序号)
                Into n_号序
                From 临床出诊序号控制 A
                Where a.记录id = n_记录id And a.预约顺序号 Is Null And a.开始时间 >= d_时段开始 And a.开始时间 < d_时段结束 And
                      数量 > (Select Count(1)
                            From 临床出诊序号控制
                            Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = a.序号 And Nvl(挂号状态, 0) <> 0);
                If Nvl(n_号序, 0) = 0 Then
                  v_Temp := '本号别可用序号已经全部使用完!';
                  Raise Err_Item;
                End If;
                Select 数量
                Into n_数量
                From 临床出诊序号控制
                Where 记录id = n_记录id And 预约顺序号 Is Null And 序号 = n_号序;
              End If;
              Select Count(1)
              Into n_Exists
              From 临床出诊序号控制
              Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = n_号序 And Nvl(挂号状态, 0) <> 0;
            
              If n_Exists >= n_数量 Then
                v_Temp := '本号别可用序号已经全部使用完!';
                Raise Err_Item;
              Else
                Select Min(预约顺序号)
                Into n_顺序号
                From 临床出诊序号控制
                Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = n_号序 And Nvl(挂号状态, 0) = 0 And Nvl(是否停诊, 0) <> 1;
                If n_顺序号 = 0 Then
                  Select Max(预约顺序号) + 1
                  Into n_顺序号
                  From 临床出诊序号控制
                  Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = n_号序;
                End If;
                Update 临床出诊序号控制
                Set 挂号状态 = 5, 锁号时间 = Sysdate, 操作员姓名 = v_操作员姓名, 工作站名称 = v_机器名
                Where 记录id = n_记录id And 序号 = n_序号 And 预约顺序号 = n_顺序号;
                If Sql%RowCount = 0 Then
                  Insert Into 临床出诊序号控制
                    (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 锁号时间, 名称, 类型, 操作员姓名, 工作站名称, 预约顺序号)
                    Select 记录id, n_序号,
                           To_Date(To_Char(开始时间, 'yyyy-mm-dd') || ' ' || To_Char(d_日期, 'hh24:mi:ss'),
                                    'yyyy-mm-dd hh24:mi:ss'),
                           To_Date(To_Char(开始时间, 'yyyy-mm-dd') || ' ' || To_Char(d_日期, 'hh24:mi:ss'),
                                    'yyyy-mm-dd hh24:mi:ss'), 1, 是否预约, 5, Sysdate, v_合作单位, 1, v_操作员姓名, v_机器名, n_顺序号
                    From 临床出诊序号控制
                    Where 记录id = n_记录id And Rownum < 2;
                End If;
                v_Temp := '<HX>' || n_号序 || '</HX>';
                Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
              End If;
            Exception
              When Others Then
                Null;
            End;
          Else
            --合作单位
            Begin
              Select 控制方式
              Into n_合约模式
              From 临床出诊挂号控制记录
              Where 记录id = n_记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位 And Rownum < 2;
            Exception
              When Others Then
                n_合约模式 := 4;
            End;
            If n_合约模式 = 0 Then
              v_Temp := '本号别禁止该合作单位预约!';
              Raise Err_Item;
            End If;
            If n_合约模式 = 1 Or n_合约模式 = 2 Or n_合约模式 = 4 Then
              Begin
                If v_时间段 Is Null Then
                  Select 序号, 数量
                  Into n_号序, n_数量
                  From 临床出诊序号控制
                  Where 记录id = n_记录id And 预约顺序号 Is Null And 开始时间 = d_日期;
                Else
                  Select Min(序号)
                  Into n_号序
                  From 临床出诊序号控制 A
                  Where a.记录id = n_记录id And a.预约顺序号 Is Null And a.开始时间 >= d_时段开始 And a.开始时间 < d_时段结束 And
                        数量 > (Select Count(1)
                              From 临床出诊序号控制
                              Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = a.序号 And Nvl(挂号状态, 0) <> 0);
                  If Nvl(n_号序, 0) = 0 Then
                    v_Temp := '本号别可用序号已经全部使用完!';
                    Raise Err_Item;
                  End If;
                  Select 数量
                  Into n_数量
                  From 临床出诊序号控制
                  Where 记录id = n_记录id And 预约顺序号 Is Null And 序号 = n_号序;
                End If;
                Select Count(1)
                Into n_Exists
                From 临床出诊序号控制
                Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = n_号序 And Nvl(挂号状态, 0) <> 0;
                If n_Exists >= n_数量 Then
                  v_Temp := '本号别可用序号已经全部使用完!';
                  Raise Err_Item;
                Else
                  Select Min(预约顺序号)
                  Into n_顺序号
                  From 临床出诊序号控制
                  Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = n_号序 And Nvl(挂号状态, 0) = 0 And Nvl(是否停诊, 0) <> 1;
                  If n_顺序号 = 0 Then
                    Select Max(预约顺序号) + 1
                    Into n_顺序号
                    From 临床出诊序号控制
                    Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = n_号序;
                  End If;
                  Update 临床出诊序号控制
                  Set 挂号状态 = 5, 锁号时间 = Sysdate, 操作员姓名 = v_操作员姓名, 工作站名称 = v_机器名
                  Where 记录id = n_记录id And 序号 = n_序号 And 预约顺序号 = n_顺序号;
                  If Sql%RowCount = 0 Then
                    Insert Into 临床出诊序号控制
                      (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 锁号时间, 名称, 类型, 操作员姓名, 工作站名称, 预约顺序号)
                      Select 记录id, n_序号,
                             To_Date(To_Char(开始时间, 'yyyy-mm-dd') || ' ' || To_Char(d_日期, 'hh24:mi:ss'),
                                      'yyyy-mm-dd hh24:mi:ss'),
                             To_Date(To_Char(开始时间, 'yyyy-mm-dd') || ' ' || To_Char(d_日期, 'hh24:mi:ss'),
                                      'yyyy-mm-dd hh24:mi:ss'), 1, 是否预约, 5, Sysdate, v_合作单位, 1, v_操作员姓名, v_机器名, n_顺序号
                      From 临床出诊序号控制
                      Where 记录id = n_记录id And Rownum < 2;
                  End If;
                  v_Temp := '<HX>' || n_号序 || '</HX>';
                  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                End If;
              Exception
                When Others Then
                  Null;
              End;
            End If;
            If n_合约模式 = 3 Then
              Begin
                If v_时间段 Is Null Then
                  Select 序号
                  Into n_号序
                  From 临床出诊序号控制
                  Where 记录id = n_记录id And 预约顺序号 Is Null And 开始时间 = d_日期;
                  Select 数量
                  Into n_数量
                  From 临床出诊挂号控制记录
                  Where 记录id = n_记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位 And 序号 = n_号序;
                Else
                  Select Min(序号)
                  Into n_号序
                  From 临床出诊序号控制 A
                  Where a.记录id = n_记录id And a.预约顺序号 Is Null And a.开始时间 >= d_时段开始 And a.开始时间 < d_时段结束 And
                        数量 > (Select Count(1)
                              From 临床出诊序号控制
                              Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = a.序号 And Nvl(挂号状态, 0) <> 0);
                  If Nvl(n_号序, 0) = 0 Then
                    v_Temp := '本号别可用序号已经全部使用完!';
                    Raise Err_Item;
                  End If;
                  Select 数量
                  Into n_数量
                  From 临床出诊序号控制
                  Where 记录id = n_记录id And 预约顺序号 Is Null And 序号 = n_号序;
                End If;
                Select Count(1)
                Into n_Exists
                From 临床出诊序号控制
                Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = n_号序 And Nvl(挂号状态, 0) <> 0;
                If n_Exists >= n_数量 Then
                  v_Temp := '本号别可用序号已经全部使用完!';
                  Raise Err_Item;
                Else
                  Select Min(预约顺序号)
                  Into n_顺序号
                  From 临床出诊序号控制
                  Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = n_号序 And Nvl(挂号状态, 0) = 0 And Nvl(是否停诊, 0) <> 1;
                  If n_顺序号 = 0 Then
                    Select Max(预约顺序号) + 1
                    Into n_顺序号
                    From 临床出诊序号控制
                    Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = n_号序;
                  End If;
                  Update 临床出诊序号控制
                  Set 挂号状态 = 5, 锁号时间 = Sysdate, 操作员姓名 = v_操作员姓名, 工作站名称 = v_机器名
                  Where 记录id = n_记录id And 序号 = n_序号 And 预约顺序号 = n_顺序号;
                  If Sql%RowCount = 0 Then
                    Insert Into 临床出诊序号控制
                      (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 锁号时间, 名称, 类型, 操作员姓名, 工作站名称, 预约顺序号)
                      Select 记录id, n_序号,
                             To_Date(To_Char(开始时间, 'yyyy-mm-dd') || ' ' || To_Char(d_日期, 'hh24:mi:ss'),
                                      'yyyy-mm-dd hh24:mi:ss'),
                             To_Date(To_Char(开始时间, 'yyyy-mm-dd') || ' ' || To_Char(d_日期, 'hh24:mi:ss'),
                                      'yyyy-mm-dd hh24:mi:ss'), 1, 是否预约, 5, Sysdate, v_合作单位, 1, v_操作员姓名, v_机器名, n_顺序号
                      From 临床出诊序号控制
                      Where 记录id = n_记录id And Rownum < 2;
                  End If;
                  v_Temp := '<HX>' || n_号序 || '</HX>';
                  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                End If;
              Exception
                When Others Then
                  Null;
              End;
            End If;
          End If;
        End If;
      End If;
    Else
      n_序号 := n_号序;
      Update 临床出诊序号控制
      Set 挂号状态 = 5, 操作员姓名 = v_操作员姓名, 工作站名称 = v_机器名, 锁号时间 = Sysdate
      Where 记录id = n_记录id And 序号 = n_序号;
      If Sql%RowCount = 0 Then
        Begin
          Insert Into 临床出诊序号控制
            (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 锁号时间, 名称, 类型, 操作员姓名, 工作站名称)
            Select 记录id, n_序号,
                   To_Date(To_Char(开始时间, 'yyyy-mm-dd') || ' ' || To_Char(d_日期, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'),
                   To_Date(To_Char(开始时间, 'yyyy-mm-dd') || ' ' || To_Char(d_日期, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'),
                   1, 是否预约, 5, Sysdate, v_合作单位, 1, v_操作员姓名, v_机器名
            From 临床出诊序号控制
            Where 记录id = n_记录id And Rownum < 2;
        Exception
          When Others Then
            v_Temp := '传入的锁号序号已被使用!';
            Raise Err_Item;
        End;
      End If;
    End If;
  End If;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Temp || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Lockno;
/

--103209:刘尔旋,2016-12-20,服务窗医保实时结算
Create Or Replace Procedure Zl_预约挂号接收_Insert
(
  No_In            门诊费用记录.No%Type,
  票据号_In        门诊费用记录.实际票号%Type,
  领用id_In        票据使用明细.领用id%Type,
  结帐id_In        门诊费用记录.结帐id%Type,
  诊室_In          门诊费用记录.发药窗口%Type,
  病人id_In        门诊费用记录.病人id%Type,
  门诊号_In        门诊费用记录.标识号%Type,
  姓名_In          门诊费用记录.姓名%Type,
  性别_In          门诊费用记录.性别%Type,
  年龄_In          门诊费用记录.年龄%Type,
  付款方式_In      门诊费用记录.付款方式%Type, --用于存放病人的医疗付款方式编号
  费别_In          门诊费用记录.费别%Type,
  结算方式_In      病人预交记录.结算方式%Type, --现金的结算名称
  现金支付_In      病人预交记录.冲预交%Type, --挂号时现金支付部份金额
  预交支付_In      病人预交记录.冲预交%Type, --挂号时使用的预交金额
  个帐支付_In      病人预交记录.冲预交%Type, --挂号时个人帐户支付金额
  发生时间_In      门诊费用记录.发生时间%Type,
  号序_In          挂号序号状态.序号%Type,
  操作员编号_In    门诊费用记录.操作员编号%Type,
  操作员姓名_In    门诊费用记录.操作员姓名%Type,
  生成队列_In      Number := 0,
  登记时间_In      门诊费用记录.登记时间%Type := Null,
  卡类别id_In      病人预交记录.卡类别id%Type := Null,
  结算卡序号_In    病人预交记录.结算卡序号%Type := Null,
  卡号_In          病人预交记录.卡号%Type := Null,
  交易流水号_In    病人预交记录.交易流水号%Type := Null,
  交易说明_In      病人预交记录.交易说明%Type := Null,
  险类_In          病人挂号记录.险类%Type := Null,
  结算模式_In      Number := 0,
  记帐费用_In      Number := 0,
  冲预交病人ids_In Varchar2 := Null,
  三方调用_In      Number := 0,
  更新交款余额_In  Number := 0 --是否更新人员交款余额，主要是处理统一操作员登录多台自助机的情况
) As
  --该游标用于收费冲预交的可用预交列表
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit
  (
    v_病人id        病人信息.病人id%Type,
    v_冲预交病人ids Varchar2
  ) Is
    Select 病人id, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额, Min(记录状态) As 记录状态, Nvl(Max(结帐id), 0) As 结帐id,
           Max(Decode(记录性质, 1, ID, 0) * Decode(记录状态, 2, 0, 1)) As 原预交id
    From 病人预交记录
    Where 记录性质 In (1, 11) And 病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And Nvl(预交类别, 2) = 1
     Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
    Group By NO, 病人id
    Order By Decode(病人id, Nvl(v_病人id, 0), 0, 1), 结帐id, NO;

  v_Err_Msg Varchar2(255);
  Err_Item Exception;
  Err_Special Exception;

  v_现金     结算方式.名称%Type;
  v_个人帐户 结算方式.名称%Type;
  v_队列名称 排队叫号队列.队列名称%Type;
  v_号别     门诊费用记录.计算单位%Type;
  v_号序     门诊费用记录.发药窗口%Type;
  v_排队号码 排队叫号队列.排队号码 %Type;
  v_预约方式 病人挂号记录.预约方式 %Type;

  n_打印id        票据打印内容.Id%Type;
  n_预交金额      病人预交记录.金额%Type;
  n_返回值        病人预交记录.金额%Type;
  v_冲预交病人ids Varchar2(4000);

  n_挂号id         病人挂号记录.Id%Type;
  n_分诊台签到排队 Number;
  n_组id           财务缴款分组.Id%Type;
  n_Count          Number(18);
  n_排队           Number;
  n_当天排队       Number;
  n_当前金额       病人预交记录.金额%Type;
  n_预交id         病人预交记录.Id%Type;
  n_消费卡id       消费卡目录.Id%Type;
  n_自制卡         Number;

  d_Date       Date;
  d_预约时间   门诊费用记录.发生时间%Type;
  d_发生时间   Date;
  d_排队时间   Date;
  n_时段       Number := 0;
  n_存在       Number := 0;
  v_排队序号   排队叫号队列.排队序号%Type;
  n_结算模式   病人信息.结算模式%Type;
  n_票种       票据使用明细.票种%Type;
  v_付款方式   病人挂号记录.医疗付款方式%Type;
  v_操作员姓名 病人挂号记录.接收人%Type;
  n_接收模式   Number := 0;
Begin
  n_组id          := Zl_Get组id(操作员姓名_In);
  v_冲预交病人ids := Nvl(冲预交病人ids_In, 病人id_In);
  n_接收模式      := Nvl(zl_GetSysParameter('预约接收模式', 1111), 0);

  --获取结算方式名称
  Begin
    Select 名称 Into v_现金 From 结算方式 Where 性质 = 1;
  Exception
    When Others Then
      v_现金 := '现金';
  End;
  Begin
    Select 名称 Into v_个人帐户 From 结算方式 Where 性质 = 3;
  Exception
    When Others Then
      v_个人帐户 := '个人帐户';
  End;
  If 登记时间_In Is Null Then
    Select Sysdate Into d_Date From Dual;
  Else
    d_Date := 登记时间_In;
  End If;

  --更新挂号序号状态
  Begin
    Select 号别, 号序, Trunc(发生时间), 发生时间, 预约方式
    Into v_号别, v_号序, d_预约时间, d_发生时间, v_预约方式
    From 病人挂号记录
    Where 记录性质 = 2 And 记录状态 = 1 And Rownum = 1 And NO = No_In;
  Exception
    When Others Then
      Select Max(接收人) Into v_操作员姓名 From 病人挂号记录 Where 记录性质 = 2 And 记录状态 In (1, 3) And NO = No_In;
      If v_操作员姓名 Is Null Then
        v_Err_Msg := '当前预约挂号单已被取消';
        Raise Err_Item;
      Else
        If v_操作员姓名 = 操作员姓名_In Then
          v_Err_Msg := '当前预约挂号单已被接收';
          Raise Err_Special;
        Else
          v_Err_Msg := '当前预约挂号单已被其它人接收';
          Raise Err_Item;
        End If;
      End If;
  End;

  --判断是否分时段
  Begin
    Select 1
    Into n_时段
    From Dual
    Where Exists (Select 1
           From 挂号安排时段 A, 挂号安排 B
           Where a.安排id = b.Id And b.号码 = v_号别 And Rownum < 2
           Union All
           Select 1
           From 挂号计划时段 C, 挂号安排计划 D 　
           Where c.计划id = d.Id And d.号码 = v_号别 And d.生效时间 > Sysdate And Rownum < 2);
  Exception
    When Others Then
      n_时段 := 0;
  End;

  If n_时段 = 0 And 三方调用_In = 0 Then
    If n_接收模式 = 0 Then
      If Trunc(发生时间_In) = Trunc(Sysdate) Then
        d_发生时间 := 发生时间_In;
      Else
        d_发生时间 := Sysdate;
      End If;
    Else
      d_发生时间 := 发生时间_In;
    End If;
  Else
    If Not 发生时间_In Is Null Then
      d_发生时间 := 发生时间_In;
    End If;
  End If;
  If Not v_号序 Is Null Then
    If 号序_In Is Null Then
      Delete 挂号序号状态 Where 号码 = v_号别 And Trunc(日期) = Trunc(d_预约时间) And 序号 = v_号序;
    Else
      If Trunc(d_预约时间) <> Trunc(Sysdate) And n_接收模式 = 0 Then
      
        If n_时段 = 0 And 三方调用_In = 0 Then
          --提前接收或延迟接收
          Delete 挂号序号状态 Where 号码 = v_号别 And Trunc(日期) = Trunc(d_预约时间) And 序号 = v_号序;
          Begin
            Select 1 Into n_存在 From 挂号序号状态 Where 号码 = v_号别 And 日期 = Trunc(Sysdate) And 序号 = v_号序;
          Exception
            When Others Then
              n_存在 := 0;
          End;
          If n_存在 = 0 Then
            Insert Into 挂号序号状态
              (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
            Values
              (v_号别, Trunc(Sysdate), v_号序, 1, 操作员姓名_In, Sysdate);
          Else
            --号码已被使用的情况
            Begin
              v_号序 := 1;
              Insert Into 挂号序号状态
                (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
              Values
                (v_号别, Trunc(Sysdate), v_号序, 1, 操作员姓名_In, Sysdate);
            Exception
              When Others Then
                Select Min(序号 + 1)
                Into v_号序
                From 挂号序号状态 A
                Where 号码 = v_号别 And 日期 = Trunc(Sysdate) And Not Exists
                 (Select 1 From 挂号序号状态 Where 号码 = a.号码 And 日期 = a.日期 And 序号 = a.序号 + 1);
                Insert Into 挂号序号状态
                  (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
                Values
                  (v_号别, Trunc(Sysdate), v_号序, 1, 操作员姓名_In, Sysdate);
            End;
          End If;
        Else
          Update 挂号序号状态
          Set 状态 = 1, 登记时间 = Sysdate
          Where Trunc(日期) = Trunc(d_预约时间) And 序号 = v_号序 And 号码 = v_号别 And 状态 = 2;
          If Sql% NotFound Then
            Begin
              Insert Into 挂号序号状态
                (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
              Values
                (v_号别, Trunc(Sysdate), v_号序, 1, 操作员姓名_In, Sysdate);
            Exception
              When Others Then
                v_Err_Msg := '序号' || v_号序 || '已被其它人使用,请重新选择一个序号.';
                Raise Err_Item;
            End;
          End If;
        
        End If;
      
      Else
        Update 挂号序号状态
        Set 序号 = 号序_In, 状态 = 1, 登记时间 = Sysdate
        Where 号码 = v_号别 And Trunc(日期) = Trunc(d_预约时间) And 序号 = v_号序;
        If Sql%RowCount = 0 Then
          Begin
            Insert Into 挂号序号状态
              (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
            Values
              (v_号别, Trunc(d_发生时间), v_号序, 1, 操作员姓名_In, Sysdate);
          Exception
            When Others Then
              v_Err_Msg := '序号' || v_号序 || '已被其它人使用,请重新选择一个序号.';
              Raise Err_Item;
          End;
        End If;
      End If;
    End If;
  Else
    If Not 号序_In Is Null Then
      Begin
        Insert Into 挂号序号状态
          (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
        Values
          (v_号别, Trunc(Sysdate), 号序_In, 1, 操作员姓名_In, Sysdate);
      Exception
        When Others Then
          v_Err_Msg := '序号' || 号序_In || '已被其它人使用,请重新选择一个序号.';
          Raise Err_Item;
      End;
      v_号序 := 号序_In;
    Else
      v_号序 := Null;
    End If;
  End If;

  --更新门诊费用记录
  Update 门诊费用记录
  Set 记录状态 = 1, 实际票号 = Decode(Nvl(记帐费用_In, 0), 1, Null, 票据号_In), 结帐id = Decode(Nvl(记帐费用_In, 0), 1, Null, 结帐id_In),
      结帐金额 = Decode(Nvl(记帐费用_In, 0), 1, Null, 实收金额), 发药窗口 = 诊室_In, 病人id = 病人id_In, 标识号 = 门诊号_In, 姓名 = 姓名_In, 年龄 = 年龄_In,
      性别 = 性别_In, 付款方式 = 付款方式_In, 费别 = 费别_In, 发生时间 = d_发生时间, 登记时间 = d_Date, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In,
      缴款组id = n_组id, 记帐费用 = Decode(Nvl(记帐费用_In, 0), 1, 1, 0)
  Where 记录性质 = 4 And 记录状态 = 0 And NO = No_In;

  --病人挂号记录
  Update 病人挂号记录
  Set 接收人 = 操作员姓名_In, 接收时间 = d_Date, 记录性质 = 1, 病人id = 病人id_In, 门诊号 = 门诊号_In, 发生时间 = d_发生时间, 姓名 = 姓名_In, 性别 = 性别_In,
      年龄 = 年龄_In, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In, 险类 = Decode(Nvl(险类_In, 0), 0, Null, 险类_In), 号序 = v_号序, 诊室 = 诊室_In
  Where 记录状态 = 1 And NO = No_In And 记录性质 = 2
  Returning ID Into n_挂号id;
  If Sql%NotFound Then
    Begin
      Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
      Begin
        Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In And Rownum < 2;
      Exception
        When Others Then
          v_付款方式 := Null;
      End;
      Insert Into 病人挂号记录
        (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 操作员编号, 操作员姓名,
         摘要, 号序, 预约, 预约方式, 接收人, 接收时间, 预约时间, 险类, 医疗付款方式)
        Select n_挂号id, No_In, 1, 1, 病人id_In, 门诊号_In, 姓名_In, 性别_In, 年龄_In, 计算单位, 加班标志, 诊室_In, Null, 执行部门id, 执行人, 0, Null,
               登记时间, 发生时间, 操作员编号, 操作员姓名, 摘要, v_号序, 1, Substr(结论, 1, 10) As 预约方式, 操作员姓名_In, Nvl(登记时间_In, Sysdate), 发生时间,
               Decode(Nvl(险类_In, 0), 0, Null, 险类_In), v_付款方式
        From 门诊费用记录
        Where 记录性质 = 4 And 记录状态 = 1 And Rownum = 1 And NO = No_In;
    Exception
      When Others Then
        v_Err_Msg := '由于并发原因,单据号为【' || No_In || '】的病人' || 姓名_In || '已经被接收';
        Raise Err_Item;
    End;
  End If;

  --0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站
  If Nvl(生成队列_In, 0) <> 0 Then
    n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
    If Nvl(n_分诊台签到排队, 0) = 0 Then
      For v_挂号 In (Select ID, 姓名, 诊室, 执行人, 执行部门id, 发生时间, 号别, 号序 From 病人挂号记录 Where NO = No_In) Loop
      
        Begin
          Select 1,
                 Case
                   When 排队时间 < Trunc(Sysdate) Then
                    1
                   Else
                    0
                 End
          Into n_排队, n_当天排队
          From 排队叫号队列
          Where 业务类型 = 0 And 业务id = v_挂号.Id And Rownum <= 1;
        Exception
          When Others Then
            n_排队 := 0;
        End;
        If n_排队 = 0 Then
          --产生队列
          --按”执行部门”产生队列
          n_挂号id   := v_挂号.Id;
          v_队列名称 := v_挂号.执行部门id;
          v_排队号码 := Zlgetnextqueue(v_挂号.执行部门id, n_挂号id, v_挂号.号别 || '|' || v_挂号.号序);
          v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
        
          --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)
          d_排队时间 := Zl_Get_Queuedate(n_挂号id, v_挂号.号别, v_挂号.号序, v_挂号.发生时间);
          --   队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,排队标记_In,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In,
          Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, v_挂号.执行部门id, v_排队号码, Null, 姓名_In, 病人id_In, v_挂号.诊室, v_挂号.执行人, d_排队时间,
                           v_预约方式, Null, v_排队序号);
        Elsif Nvl(n_当天排队, 0) = 1 Then
          --更新队列号
          v_排队号码 := Zlgetnextqueue(v_挂号.执行部门id, v_挂号.Id, v_挂号.号别 || '|' || Nvl(v_挂号.号序, 0));
          v_排队序号 := Zlgetsequencenum(0, v_挂号.Id, 1);
          --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In, 医生姓名_In ,排队号码_In
          Zl_排队叫号队列_Update(v_挂号.执行部门id, 0, v_挂号.Id, v_挂号.执行部门id, v_挂号.姓名, v_挂号.诊室, v_挂号.执行人, v_排队号码, v_排队序号);
        
        Else
          --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In, 医生姓名_In ,排队号码_In
          Zl_排队叫号队列_Update(v_挂号.执行部门id, 0, v_挂号.Id, v_挂号.执行部门id, v_挂号.姓名, v_挂号.诊室, v_挂号.执行人);
        End If;
        --预约接收时，改变记录标志
        Update 病人挂号记录 Set 记录标志 = 1 Where ID = n_挂号id;
      End Loop;
    End If;
  End If;

  --汇总结算到病人预交记录
  If (Nvl(现金支付_In, 0) <> 0 Or (Nvl(现金支付_In, 0) = 0 And Nvl(个帐支付_In, 0) = 0 And Nvl(预交支付_In, 0) = 0)) And
     Nvl(记帐费用_In, 0) = 0 Then
    Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
    Insert Into 病人预交记录
      (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 结算序号,
       结算性质)
    Values
      (n_预交id, 4, 1, No_In, 病人id_In, Nvl(结算方式_In, v_现金), Nvl(现金支付_In, 0), d_Date, 操作员编号_In, 操作员姓名_In, 结帐id_In, '挂号收费',
       n_组id, 卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, 结帐id_In, 4);
  
    If Nvl(结算卡序号_In, 0) <> 0 And Nvl(现金支付_In, 0) <> 0 Then
    
      n_消费卡id := Null;
      Begin
        Select Nvl(自制卡, 0), 1 Into n_自制卡, n_Count From 卡消费接口目录 Where 编号 = 结算卡序号_In;
      Exception
        When Others Then
          n_Count := 0;
      End;
      If n_Count = 0 Then
        v_Err_Msg := '[ZLSOFT]没有发现原结算卡的相应类别,不能继续操作！[ZLSOFT]';
        Raise Err_Item;
      End If;
      If n_自制卡 = 1 Then
        Select ID
        Into n_消费卡id
        From 消费卡目录
        Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In And
              序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In);
      End If;
      Zl_病人卡结算记录_Insert(结算卡序号_In, n_消费卡id, 结算方式_In, 现金支付_In, 卡号_In, Null, 登记时间_In, Null, 结帐id_In, n_预交id);
    End If;
  
  End If;

  --对于就诊卡通过预交金挂号
  If Nvl(预交支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 Then
    n_预交金额 := 预交支付_In;
    For r_Deposit In c_Deposit(病人id_In, v_冲预交病人ids) Loop
      n_当前金额 := Case
                  When r_Deposit.金额 - n_预交金额 < 0 Then
                   r_Deposit.金额
                  Else
                   n_预交金额
                End;
      If r_Deposit.结帐id = 0 Then
        --第一次冲预交(填上结帐ID,金额为0)
        Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 4 Where ID = r_Deposit.原预交id;
      End If;
      --冲上次剩余额
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结算序号, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 登记时间_In,
               操作员姓名_In, 操作员编号_In, n_当前金额, 结帐id_In, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结帐id_In, 4
        From 病人预交记录
        Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
    
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - n_当前金额
      Where 病人id = r_Deposit.病人id And 性质 = 1 And 类型 = Nvl(1, 2)
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (r_Deposit.病人id, Nvl(1, 2), -1 * n_当前金额, 1);
        n_返回值 := -1 * n_当前金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Deposit.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --检查是否已经处理完
      If r_Deposit.金额 < n_预交金额 Then
        n_预交金额 := n_预交金额 - r_Deposit.金额;
      Else
        n_预交金额 := 0;
      End If;
    
      If n_预交金额 = 0 Then
        Exit;
      End If;
    End Loop;
  End If;

  --对于医保挂号
  If Nvl(个帐支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 Then
    Insert Into 病人预交记录
      (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
       预交类别, 结算序号, 结算性质)
    Values
      (病人预交记录_Id.Nextval, 4, 1, No_In, 病人id_In, v_个人帐户, 个帐支付_In, d_Date, 操作员编号_In, 操作员姓名_In, 结帐id_In, '医保挂号', n_组id,
       Null, Null, Null, Null, Null, Null, Null, 结帐id_In, 4);
  End If;

  --相关汇总表的处理
  --人员缴款余额
  If Nvl(现金支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 And Nvl(更新交款余额_In, 0) = 0 Then
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + 现金支付_In
    Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = Nvl(结算方式_In, v_现金)
    Returning 余额 Into n_返回值;
  
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额
        (收款员, 结算方式, 性质, 余额)
      Values
        (操作员姓名_In, Nvl(结算方式_In, v_现金), 1, 现金支付_In);
      n_返回值 := 现金支付_In;
    
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 人员缴款余额
      Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = Nvl(结算方式_In, v_现金) And Nvl(余额, 0) = 0;
    End If;
  End If;

  If Nvl(个帐支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 And Nvl(更新交款余额_In, 0) = 0 Then
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + 个帐支付_In
    Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = v_个人帐户
    Returning 余额 Into n_返回值;
  
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, v_个人帐户, 1, 个帐支付_In);
      n_返回值 := 个帐支付_In;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 人员缴款余额 Where 收款员 = 操作员姓名_In And 性质 = 1 And Nvl(余额, 0) = 0;
    End If;
  End If;

  --处理票据使用情况
  If 票据号_In Is Not Null And Nvl(记帐费用_In, 0) = 0 Then
    Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
  
    --当前票据的票种
    Select 票种 Into n_票种 From 票据领用记录 Where ID = Nvl(领用id_In, 0);
    --发出票据
    Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 4, No_In);
  
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
    Values
      (票据使用明细_Id.Nextval, n_票种, 票据号_In, 1, 1, 领用id_In, n_打印id, d_Date, 操作员姓名_In);
  
    --状态改动
    Update 票据领用记录
    Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = d_Date
    Where ID = Nvl(领用id_In, 0);
  End If;

  If Nvl(记帐费用_In, 0) = 1 Then
    --记帐
    If Nvl(病人id_In, 0) = 0 Then
      v_Err_Msg := '要针对病人的挂号费进行记帐，必须是建档病人才能记帐挂号。';
      Raise Err_Item;
    End If;
    For c_费用 In (Select 实收金额, 病人科室id, 开单部门id, 执行部门id, 收入项目id
                 From 门诊费用记录
                 Where 记录性质 = 4 And 记录状态 = 1 And NO = No_In And Nvl(记帐费用, 0) = 1) Loop
      --病人余额
      Update 病人余额
      Set 费用余额 = Nvl(费用余额, 0) + Nvl(c_费用.实收金额, 0)
      Where 病人id = Nvl(病人id_In, 0) And 性质 = 1 And 类型 = 1;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 费用余额, 预交余额)
        Values
          (病人id_In, 1, 1, Nvl(c_费用.实收金额, 0), 0);
      End If;
    
      --病人未结费用
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) + Nvl(c_费用.实收金额, 0)
      Where 病人id = 病人id_In And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(c_费用.病人科室id, 0) And
            Nvl(开单部门id, 0) = Nvl(c_费用.开单部门id, 0) And Nvl(执行部门id, 0) = Nvl(c_费用.执行部门id, 0) And 收入项目id + 0 = c_费用.收入项目id And
            来源途径 + 0 = 1;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人未结费用
          (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
        Values
          (病人id_In, Null, Null, c_费用.病人科室id, c_费用.开单部门id, c_费用.执行部门id, c_费用.收入项目id, 1, Nvl(c_费用.实收金额, 0));
      End If;
    End Loop;
  End If;
  If Nvl(病人id_In, 0) <> 0 Then
    n_结算模式 := 0;
    Update 病人信息
    Set 就诊时间 = d_发生时间, 就诊状态 = 1, 就诊诊室 = 诊室_In
    Where 病人id = 病人id_In
    Returning Nvl(结算模式, 0) Into n_结算模式;
    --取参数:
    If Nvl(n_结算模式, 0) <> Nvl(结算模式_In, 0) Then
      --结算模式的确定
      If n_结算模式 = 1 And Nvl(结算模式_In, 0) = 0 Then
        --病人已经是"先诊疗后结算的",本次是"先结算后诊疗的",则检查是否存在未结数据
        Select Count(1)
        Into n_Count
        From 病人未结费用
        Where 病人id = 病人id_In And (来源途径 In (1, 4) Or 来源途径 = 3 And Nvl(主页id, 0) = 0) And Nvl(金额, 0) <> 0 And Rownum < 2;
        If Nvl(n_Count, 0) <> 0 Then
          --存在未结算数据，必须先结算后才允许执行
          v_Err_Msg := '当前病人的就诊模式为先诊疗后结算且存在未结费用，不允许调整该病人的就诊模式,你可以先对未结费用结帐后再挂号或不调整病人的就诊模式!';
          Raise Err_Item;
        End If;
        --检查
        --未发生医嘱业务的（即当时就挂号的,需要保证同一次的就诊模式是一至的(程序已经检查，不用再处理)
      End If;
      Update 病人信息 Set 结算模式 = 结算模式_In Where 病人id = 病人id_In;
    End If;
  End If;

  --病人担保信息
  If 病人id_In Is Not Null Then
    Update 病人信息
    Set 担保人 = Null, 担保额 = Null, 担保性质 = Null
    Where 病人id = 病人id_In And Nvl(在院, 0) = 0 And Exists
     (Select 1
           From 病人担保记录
           Where 病人id = 病人id_In And 主页id Is Not Null And
                 登记时间 = (Select Max(登记时间) From 病人担保记录 Where 病人id = 病人id_In));
    If Sql%RowCount > 0 Then
      Update 病人担保记录
      Set 到期时间 = d_Date
      Where 病人id = 病人id_In And 主页id Is Not Null And Nvl(到期时间, d_Date) >= d_Date;
    End If;
  End If;
  --消息推送
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 1, n_挂号id;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Err_Special Then
    Raise_Application_Error(-20105, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_预约挂号接收_Insert;
/


--105249:刘尔旋,2017-01-22,新挂号安排可调整挂号收费项目关联修改
--103221:刘尔旋,2017-01-03,新挂号安排停诊处理
--103209:刘尔旋,2016-12-20,服务窗医保实时结算
Create Or Replace Procedure Zl_预约挂号接收_出诊_Insert
(
  No_In            门诊费用记录.No%Type,
  票据号_In        门诊费用记录.实际票号%Type,
  领用id_In        票据使用明细.领用id%Type,
  结帐id_In        门诊费用记录.结帐id%Type,
  诊室_In          门诊费用记录.发药窗口%Type,
  病人id_In        门诊费用记录.病人id%Type,
  门诊号_In        门诊费用记录.标识号%Type,
  姓名_In          门诊费用记录.姓名%Type,
  性别_In          门诊费用记录.性别%Type,
  年龄_In          门诊费用记录.年龄%Type,
  付款方式_In      门诊费用记录.付款方式%Type, --用于存放病人的医疗付款方式编号
  费别_In          门诊费用记录.费别%Type,
  结算方式_In      Varchar2, --现金的结算名称
  现金支付_In      病人预交记录.冲预交%Type, --挂号时现金支付部份金额
  预交支付_In      病人预交记录.冲预交%Type, --挂号时使用的预交金额
  个帐支付_In      病人预交记录.冲预交%Type, --挂号时个人帐户支付金额
  发生时间_In      门诊费用记录.发生时间%Type,
  号序_In          挂号序号状态.序号%Type,
  操作员编号_In    门诊费用记录.操作员编号%Type,
  操作员姓名_In    门诊费用记录.操作员姓名%Type,
  生成队列_In      Number := 0,
  登记时间_In      门诊费用记录.登记时间%Type := Null,
  卡类别id_In      病人预交记录.卡类别id%Type := Null,
  结算卡序号_In    病人预交记录.结算卡序号%Type := Null,
  卡号_In          病人预交记录.卡号%Type := Null,
  交易流水号_In    病人预交记录.交易流水号%Type := Null,
  交易说明_In      病人预交记录.交易说明%Type := Null,
  险类_In          病人挂号记录.险类%Type := Null,
  结算模式_In      Number := 0,
  记帐费用_In      Number := 0,
  冲预交病人ids_In Varchar2 := Null,
  三方调用_In      Number := 0,
  更新交款余额_In  Number := 0 --是否更新人员交款余额，主要是处理统一操作员登录多台自助机的情况
) As
  --该游标用于收费冲预交的可用预交列表
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit
  (
    v_病人id        病人信息.病人id%Type,
    v_冲预交病人ids Varchar2
  ) Is
    Select 病人id, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额, Min(记录状态) As 记录状态, Nvl(Max(结帐id), 0) As 结帐id,
           Max(Decode(记录性质, 1, ID, 0) * Decode(记录状态, 2, 0, 1)) As 原预交id
    From 病人预交记录
    Where 记录性质 In (1, 11) And 病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And Nvl(预交类别, 2) = 1
     Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
    Group By NO, 病人id
    Order By Decode(病人id, Nvl(v_病人id, 0), 0, 1), 结帐id, NO;

  v_Err_Msg Varchar2(255);
  Err_Item    Exception;
  Err_Special Exception;
  v_操作员姓名 病人挂号记录.接收人%Type;
  v_现金       结算方式.名称%Type;
  v_个人帐户   结算方式.名称%Type;
  v_队列名称   排队叫号队列.队列名称%Type;
  v_号别       门诊费用记录.计算单位%Type;
  v_号序       门诊费用记录.发药窗口%Type;
  v_排队号码   排队叫号队列.排队号码 %Type;
  v_预约方式   病人挂号记录.预约方式 %Type;

  n_打印id        票据打印内容.Id%Type;
  n_预交金额      病人预交记录.金额%Type;
  n_返回值        病人预交记录.金额%Type;
  v_冲预交病人ids Varchar2(4000);

  n_挂号id         病人挂号记录.Id%Type;
  n_分诊台签到排队 Number;
  n_组id           财务缴款分组.Id%Type;
  n_Count          Number(18);
  n_排队           Number;
  n_当天排队       Number;
  n_当前金额       病人预交记录.金额%Type;
  n_预交id         病人预交记录.Id%Type;
  n_消费卡id       消费卡目录.Id%Type;
  n_自制卡         Number;

  d_Date         Date;
  d_预约时间     门诊费用记录.发生时间%Type;
  d_发生时间     Date;
  d_排队时间     Date;
  n_时段         Number := 0;
  n_存在         Number := 0;
  v_结算内容     Varchar2(2000);
  v_当前结算     Varchar2(500);
  n_结算金额     病人预交记录.冲预交%Type;
  v_结算号码     病人预交记录.结算号码%Type;
  v_结算方式     病人预交记录.结算方式%Type;
  n_三方卡标志   Number(3);
  v_排队序号     排队叫号队列.排队序号%Type;
  n_结算模式     病人信息.结算模式%Type;
  n_票种         票据使用明细.票种%Type;
  v_付款方式     病人挂号记录.医疗付款方式%Type;
  n_接收模式     Number := 0;
  n_出诊记录id   病人挂号记录.出诊记录id%Type;
  n_新出诊记录id 病人挂号记录.出诊记录id%Type;
  n_号源id       临床出诊记录.号源id%Type;
  n_预约顺序号   临床出诊序号控制.预约顺序号%Type;
  n_旧分时段     临床出诊记录.是否分时段%Type;
  n_旧序号控制   临床出诊记录.是否序号控制%Type;
  n_旧科室id     临床出诊记录.科室id%Type;
  n_旧项目id     临床出诊记录.项目id%Type;
  n_旧医生id     临床出诊记录.医生id%Type;
  n_挂号模式     Number(3);
  d_启用时间     Date;
  v_Paratemp     Varchar2(500);
  v_Registtemp   Varchar2(500);
  n_检查         Number(3);
  n_序号控制     临床出诊记录.是否序号控制%Type;
  v_旧上班时段   临床出诊记录.上班时段%Type;
Begin
  n_组id          := Zl_Get组id(操作员姓名_In);
  v_冲预交病人ids := Nvl(冲预交病人ids_In, 病人id_In);
  v_Paratemp      := Nvl(zl_GetSysParameter('挂号排班模式'), 0);
  n_接收模式      := Nvl(zl_GetSysParameter('预约接收模式', 1111), 0);
  n_挂号模式      := To_Number(Substr(v_Paratemp, 1, 1));
  If n_挂号模式 = 1 Then
    Begin
      d_启用时间 := To_Date(Substr(v_Paratemp, 3), 'yyyy-mm-dd hh24:mi:ss');
    Exception
      When Others Then
        d_启用时间 := Null;
    End;
  End If;

  --获取结算方式名称
  Begin
    Select 名称 Into v_现金 From 结算方式 Where 性质 = 1;
  Exception
    When Others Then
      v_现金 := '现金';
  End;
  Begin
    Select 名称 Into v_个人帐户 From 结算方式 Where 性质 = 3;
  Exception
    When Others Then
      v_个人帐户 := '个人帐户';
  End;
  If 登记时间_In Is Null Then
    Select Sysdate Into d_Date From Dual;
  Else
    d_Date := 登记时间_In;
  End If;

  --更新挂号序号状态
  Begin
    Select 号别, 号序, Trunc(发生时间), 发生时间, 预约方式, 出诊记录id
    Into v_号别, v_号序, d_预约时间, d_发生时间, v_预约方式, n_出诊记录id
    From 病人挂号记录
    Where 记录性质 = 2 And 记录状态 = 1 And Rownum = 1 And NO = No_In;
  Exception
    When Others Then
      Select Max(接收人) Into v_操作员姓名 From 病人挂号记录 Where 记录性质 = 2 And 记录状态 In (1, 3) And NO = No_In;
      If v_操作员姓名 Is Null Then
        v_Err_Msg := '当前预约挂号单已被取消';
        Raise Err_Item;
      Else
        If v_操作员姓名 = 操作员姓名_In Then
          v_Err_Msg := '当前预约挂号单已被接收';
          Raise Err_Special;
        Else
          v_Err_Msg := '当前预约挂号单已被其它人接收';
          Raise Err_Item;
        End If;
      End If;
  End;

  --判断是否分时段
  Select Nvl(是否分时段, 0), 号源id, Nvl(是否序号控制, 0)
  Into n_时段, n_号源id, n_序号控制
  From 临床出诊记录
  Where ID = n_出诊记录id;

  If n_时段 = 1 And 三方调用_In = 0 And n_接收模式 = 0 Then
    If Trunc(发生时间_In) <> Trunc(Sysdate) Then
      v_Err_Msg := '分时段的预约挂号单只能当天接收！';
      Raise Err_Item;
    End If;
  End If;

  If n_时段 = 0 And 三方调用_In = 0 Then
    If n_接收模式 = 0 Then
      If Trunc(发生时间_In) = Trunc(Sysdate) Then
        d_发生时间 := 发生时间_In;
      Else
        d_发生时间 := Sysdate;
      End If;
    Else
      d_发生时间 := 发生时间_In;
    End If;
  Else
    If Not 发生时间_In Is Null Then
      d_发生时间 := 发生时间_In;
    End If;
  End If;

  If d_启用时间 Is Not Null Then
    If d_发生时间 < d_启用时间 Then
      v_Err_Msg := '当前预约挂号单属于出诊表排班模式安排，不能在' || To_Char(d_启用时间, 'yyyy-mm-dd hh24:mi:ss') || '之前接收!';
      Raise Err_Item;
    End If;
  End If;

  If Not v_号序 Is Null Then
    If 号序_In Is Null Then
      Update 临床出诊序号控制 Set 挂号状态 = 0 Where (序号 = v_号序 Or 备注 = v_号序) And 记录id = n_出诊记录id;
    Else
      If Trunc(d_预约时间) <> Trunc(Sysdate) And n_接收模式 = 0 Then
        If n_时段 = 0 And 三方调用_In = 0 Then
          --提前接收或延迟接收
          Update 临床出诊序号控制 Set 挂号状态 = 0 Where 序号 = v_号序 And 记录id = n_出诊记录id;
        
          Select 是否分时段, 是否序号控制, 科室id, 医生id, 项目id, 上班时段
          Into n_旧分时段, n_旧序号控制, n_旧科室id, n_旧医生id, n_旧项目id, v_旧上班时段
          From 临床出诊记录
          Where ID = n_出诊记录id;
          Begin
            Select ID
            Into n_新出诊记录id
            From 临床出诊记录
            Where 号源id = n_号源id And 是否分时段 = n_旧分时段 And 是否序号控制 = n_旧序号控制 And 科室id = n_旧科室id And
                  Nvl(医生id, 0) = Nvl(n_旧医生id, 0) And 上班时段 = v_旧上班时段 And Nvl(是否发布, 0) = 1 And 出诊日期 = Trunc(Sysdate) And
                  Rownum < 2;
          Exception
            When Others Then
              v_Err_Msg := '接收当天没有对应的出诊安排,无法接收!';
              Raise Err_Item;
          End;
        
          Begin
            Select 1
            Into n_存在
            From 临床出诊序号控制
            Where 记录id = n_新出诊记录id And 序号 = v_号序 And Nvl(挂号状态, 0) = 0;
          Exception
            When Others Then
              n_存在 := 0;
          End;
        
          If n_存在 = 1 Then
            Update 临床出诊序号控制
            Set 挂号状态 = 1, 操作员姓名 = 操作员姓名_In
            Where 记录id = n_新出诊记录id And 序号 = v_号序 And Nvl(挂号状态, 0) = 0;
          Else
            --号码已被使用的情况
            Select Min(序号) Into v_号序 From 临床出诊序号控制 Where 记录id = n_新出诊记录id And Nvl(挂号状态, 0) = 0;
            If v_号序 Is Null Then
              v_Err_Msg := '接收当天没有可用序号,无法接收!';
              Raise Err_Item;
            End If;
            Update 临床出诊序号控制
            Set 挂号状态 = 1, 操作员姓名 = 操作员姓名_In
            Where 记录id = n_新出诊记录id And 序号 = v_号序 And Nvl(挂号状态, 0) = 0;
          End If;
        Else
          Select 是否分时段, 是否序号控制, 科室id, 医生id, 项目id, 上班时段
          Into n_旧分时段, n_旧序号控制, n_旧科室id, n_旧医生id, n_旧项目id, v_旧上班时段
          From 临床出诊记录
          Where ID = n_出诊记录id;
          Begin
            Select ID
            Into n_新出诊记录id
            From 临床出诊记录
            Where 号源id = n_号源id And 是否分时段 = n_旧分时段 And 是否序号控制 = n_旧序号控制 And 科室id = n_旧科室id And
                  Nvl(医生id, 0) = Nvl(n_旧医生id, 0) And 上班时段 = v_旧上班时段 And Nvl(是否发布, 0) = 1 And 出诊日期 = Trunc(Sysdate) And
                  Rownum < 2;
          Exception
            When Others Then
              v_Err_Msg := '接收当天没有对应的出诊安排,无法接收!';
              Raise Err_Item;
          End;
          Update 临床出诊序号控制
          Set 挂号状态 = 0, 操作员姓名 = 操作员姓名_In
          Where (序号 = v_号序 Or 备注 = v_号序) And 记录id = n_出诊记录id And Nvl(挂号状态, 0) = 2
          Returning 预约顺序号 Into n_预约顺序号;
        
          Update 临床出诊序号控制
          Set 挂号状态 = 1, 操作员姓名 = 操作员姓名_In, 预约顺序号 = n_预约顺序号
          Where 序号 = v_号序 And 记录id = n_新出诊记录id And Nvl(挂号状态, 0) = 0;
          If Sql% RowCount = 0 Then
            v_Err_Msg := '接收当天序号' || v_号序 || '已被其它人使用,无法接收.';
            Raise Err_Item;
          End If;
        End If;
      Else
        Update 临床出诊序号控制
        Set 挂号状态 = 1, 操作员姓名 = 操作员姓名_In
        Where (序号 = v_号序 Or 备注 = v_号序) And 记录id = n_出诊记录id;
        If Sql%RowCount = 0 Then
          v_Err_Msg := '序号' || v_号序 || '已被其它人使用,请重新选择一个序号.';
          Raise Err_Item;
        End If;
      End If;
    End If;
  Else
    If Not 号序_In Is Null Then
      If Trunc(d_预约时间) <> Trunc(Sysdate) And n_接收模式 = 0 Then
        Select 是否分时段, 是否序号控制, 科室id, 医生id, 项目id, 上班时段
        Into n_旧分时段, n_旧序号控制, n_旧科室id, n_旧医生id, n_旧项目id, v_旧上班时段
        From 临床出诊记录
        Where ID = n_出诊记录id;
        Begin
          Select ID
          Into n_新出诊记录id
          From 临床出诊记录
          Where 号源id = n_号源id And 是否分时段 = n_旧分时段 And 是否序号控制 = n_旧序号控制 And 科室id = n_旧科室id And
                Nvl(医生id, 0) = Nvl(n_旧医生id, 0) And 上班时段 = v_旧上班时段 And Nvl(是否发布, 0) = 1 And 出诊日期 = Trunc(Sysdate) And
                Rownum < 2;
        Exception
          When Others Then
            v_Err_Msg := '接收当天没有对应的出诊安排,无法接收!';
            Raise Err_Item;
        End;
        Update 临床出诊序号控制
        Set 挂号状态 = 0, 操作员姓名 = 操作员姓名_In
        Where (序号 = 号序_In Or 备注 = 号序_In) And 记录id = n_出诊记录id And Nvl(挂号状态, 0) = 2
        Returning 预约顺序号 Into n_预约顺序号;
        Update 临床出诊序号控制
        Set 挂号状态 = 1, 操作员姓名 = 操作员姓名_In, 预约顺序号 = n_预约顺序号
        Where 序号 = 号序_In And 记录id = n_新出诊记录id And Nvl(挂号状态, 0) = 0;
        If Sql%RowCount = 0 Then
          v_Err_Msg := '接收当天序号' || 号序_In || '已被其它人使用,无法接收.';
          Raise Err_Item;
        End If;
      Else
        Update 临床出诊序号控制
        Set 挂号状态 = 1, 操作员姓名 = 操作员姓名_In
        Where (序号 = 号序_In Or 备注 = 号序_In) And 记录id = n_出诊记录id;
      
      End If;
      v_号序 := 号序_In;
    Else
      v_号序 := Null;
    End If;
  End If;

  --更新门诊费用记录
  Update 门诊费用记录
  Set 记录状态 = 1, 实际票号 = Decode(Nvl(记帐费用_In, 0), 1, Null, 票据号_In), 结帐id = Decode(Nvl(记帐费用_In, 0), 1, Null, 结帐id_In),
      结帐金额 = Decode(Nvl(记帐费用_In, 0), 1, Null, 实收金额), 发药窗口 = 诊室_In, 病人id = 病人id_In, 标识号 = 门诊号_In, 姓名 = 姓名_In, 年龄 = 年龄_In,
      性别 = 性别_In, 付款方式 = 付款方式_In, 费别 = 费别_In, 发生时间 = d_发生时间, 登记时间 = d_Date, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In,
      缴款组id = n_组id, 记帐费用 = Decode(Nvl(记帐费用_In, 0), 1, 1, 0)
  Where 记录性质 = 4 And 记录状态 = 0 And NO = No_In;

  v_Registtemp := zl_GetSysParameter('挂号排班模式');
  If Substr(v_Registtemp, 1, 1) = 1 Then
    Begin
      If To_Date(Substr(v_Registtemp, 3), 'yyyy-mm-dd hh24:mi:ss') > d_发生时间 Then
        v_Err_Msg := '接收时间' || To_Char(d_发生时间, 'yyyy-mm-dd hh24:mi:ss') || '未启用出诊表排班模式,目前无法接收!';
        Raise Err_Item;
      End If;
    Exception
      When Others Then
        Null;
    End;
    Begin
      Select 1
      Into n_检查
      From 临床出诊记录
      Where ID = Nvl(n_新出诊记录id, n_出诊记录id) And d_发生时间 Between 停诊开始时间 And 停诊终止时间;
    Exception
      When Others Then
        n_检查 := 0;
    End;
    If n_检查 = 1 And Not (n_时段 = 1 And n_序号控制 = 1) Then
      v_Err_Msg := '接收时间' || To_Char(d_发生时间, 'yyyy-mm-dd hh24:mi:ss') || '的安排已经被停诊,无法接收!';
      Raise Err_Item;
    End If;
  End If;

  --病人挂号记录
  Update 病人挂号记录
  Set 接收人 = 操作员姓名_In, 接收时间 = d_Date, 记录性质 = 1, 病人id = 病人id_In, 门诊号 = 门诊号_In, 发生时间 = d_发生时间, 姓名 = 姓名_In, 性别 = 性别_In,
      年龄 = 年龄_In, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In, 险类 = Decode(Nvl(险类_In, 0), 0, Null, 险类_In), 号序 = v_号序, 诊室 = 诊室_In,
      出诊记录id = Nvl(n_新出诊记录id, n_出诊记录id)
  Where 记录状态 = 1 And NO = No_In And 记录性质 = 2
  Returning ID Into n_挂号id;
  If Sql%NotFound Then
    Begin
      Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
      Begin
        Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In And Rownum < 2;
      Exception
        When Others Then
          v_付款方式 := Null;
      End;
      Insert Into 病人挂号记录
        (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 操作员编号, 操作员姓名,
         摘要, 号序, 预约, 预约方式, 接收人, 接收时间, 预约时间, 险类, 医疗付款方式, 出诊记录id)
        Select n_挂号id, No_In, 1, 1, 病人id_In, 门诊号_In, 姓名_In, 性别_In, 年龄_In, 计算单位, 加班标志, 诊室_In, Null, 执行部门id, 执行人, 0, Null,
               登记时间, 发生时间, 操作员编号, 操作员姓名, 摘要, v_号序, 1, Substr(结论, 1, 10) As 预约方式, 操作员姓名_In, Nvl(登记时间_In, Sysdate), 发生时间,
               Decode(Nvl(险类_In, 0), 0, Null, 险类_In), v_付款方式, Nvl(n_新出诊记录id, n_出诊记录id)
        From 门诊费用记录
        Where 记录性质 = 4 And 记录状态 = 1 And Rownum = 1 And NO = No_In;
    Exception
      When Others Then
        v_Err_Msg := '由于并发原因,单据号为【' || No_In || '】的病人' || 姓名_In || '已经被接收';
        Raise Err_Item;
    End;
  End If;

  --0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站
  If Nvl(生成队列_In, 0) <> 0 Then
    n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
    If Nvl(n_分诊台签到排队, 0) = 0 Then
      For v_挂号 In (Select ID, 姓名, 诊室, 执行人, 执行部门id, 发生时间, 号别, 号序 From 病人挂号记录 Where NO = No_In) Loop
      
        Begin
          Select 1,
                 Case
                   When 排队时间 < Trunc(Sysdate) Then
                    1
                   Else
                    0
                 End
          Into n_排队, n_当天排队
          From 排队叫号队列
          Where 业务类型 = 0 And 业务id = v_挂号.Id And Rownum <= 1;
        Exception
          When Others Then
            n_排队 := 0;
        End;
        If n_排队 = 0 Then
          --产生队列
          --按”执行部门”产生队列
          n_挂号id   := v_挂号.Id;
          v_队列名称 := v_挂号.执行部门id;
          v_排队号码 := Zlgetnextqueue(v_挂号.执行部门id, n_挂号id, v_挂号.号别 || '|' || v_挂号.号序);
          v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
        
          --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)
          d_排队时间 := Zl_Get_Queuedate(n_挂号id, v_挂号.号别, v_挂号.号序, v_挂号.发生时间);
          --   队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,排队标记_In,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In,
          Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, v_挂号.执行部门id, v_排队号码, Null, 姓名_In, 病人id_In, v_挂号.诊室, v_挂号.执行人, d_排队时间,
                           v_预约方式, Null, v_排队序号);
        Elsif Nvl(n_当天排队, 0) = 1 Then
          --更新队列号
          v_排队号码 := Zlgetnextqueue(v_挂号.执行部门id, v_挂号.Id, v_挂号.号别 || '|' || Nvl(v_挂号.号序, 0));
          v_排队序号 := Zlgetsequencenum(0, v_挂号.Id, 1);
          --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In, 医生姓名_In ,排队号码_In
          Zl_排队叫号队列_Update(v_挂号.执行部门id, 0, v_挂号.Id, v_挂号.执行部门id, v_挂号.姓名, v_挂号.诊室, v_挂号.执行人, v_排队号码, v_排队序号);
        
        Else
          --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In, 医生姓名_In ,排队号码_In
          Zl_排队叫号队列_Update(v_挂号.执行部门id, 0, v_挂号.Id, v_挂号.执行部门id, v_挂号.姓名, v_挂号.诊室, v_挂号.执行人);
        End If;
      End Loop;
    End If;
  End If;

  --汇总结算到病人预交记录
  If Nvl(记帐费用_In, 0) = 0 Then
    If Nvl(现金支付_In, 0) = 0 And Nvl(个帐支付_In, 0) = 0 And Nvl(预交支付_In, 0) = 0 Then
      Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      Insert Into 病人预交记录
        (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
         结算性质)
      Values
        (n_预交id, 4, 1, No_In, Decode(病人id_In, 0, Null, 病人id_In), v_现金, 0, 登记时间_In, 操作员编号_In, 操作员姓名_In, 结帐id_In, '挂号收费',
         n_组id, 卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, Null, 4);
    End If;
    If Nvl(现金支付_In, 0) <> 0 Then
      v_结算内容 := 结算方式_In || '|'; --以空格分开以|结尾,没有结算号码的
      While v_结算内容 Is Not Null Loop
        v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '|') - 1);
        v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1);
      
        v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
        n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1));
      
        v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
        v_结算号码 := Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1);
      
        v_当前结算   := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
        n_三方卡标志 := To_Number(v_当前结算);
      
        If n_三方卡标志 = 0 Then
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          Insert Into 病人预交记录
            (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
             合作单位, 结算性质, 结算号码)
          Values
            (n_预交id, 4, 1, No_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(v_结算方式, v_现金), Nvl(n_结算金额, 0), 登记时间_In,
             操作员编号_In, 操作员姓名_In, 结帐id_In, '挂号收费', n_组id, Null, Null, Null, Null, Null, Null, 4, v_结算号码);
        Else
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          Insert Into 病人预交记录
            (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
             合作单位, 结算性质, 结算号码)
          Values
            (n_预交id, 4, 1, No_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(v_结算方式, v_现金), Nvl(n_结算金额, 0), 登记时间_In,
             操作员编号_In, 操作员姓名_In, 结帐id_In, '挂号收费', n_组id, 卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, Null, 4, v_结算号码);
          If Nvl(结算卡序号_In, 0) <> 0 Then
            n_消费卡id := Null;
            Begin
              Select Nvl(自制卡, 0), 1 Into n_自制卡, n_Count From 卡消费接口目录 Where 编号 = 结算卡序号_In;
            Exception
              When Others Then
                n_Count := 0;
            End;
            If n_Count = 0 Then
              v_Err_Msg := '没有发现原结算卡的相应类别,不能继续操作！';
              Raise Err_Item;
            End If;
            If n_自制卡 = 1 Then
              Select ID
              Into n_消费卡id
              From 消费卡目录
              Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In And
                    序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In);
            End If;
            Zl_病人卡结算记录_Insert(结算卡序号_In, n_消费卡id, v_结算方式, n_结算金额, 卡号_In, Null, 登记时间_In, Null, 结帐id_In, n_预交id);
          End If;
        End If;
      
        If Nvl(更新交款余额_In, 0) = 0 Then
          Update 人员缴款余额
          Set 余额 = Nvl(余额, 0) + n_结算金额
          Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = Nvl(v_结算方式, v_现金)
          Returning 余额 Into n_返回值;
        
          If Sql%RowCount = 0 Then
            Insert Into 人员缴款余额
              (收款员, 结算方式, 性质, 余额)
            Values
              (操作员姓名_In, Nvl(v_结算方式, v_现金), 1, n_结算金额);
            n_返回值 := n_结算金额;
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 人员缴款余额
            Where 收款员 = 操作员姓名_In And 结算方式 = Nvl(v_结算方式, v_现金) And 性质 = 1 And Nvl(余额, 0) = 0;
          End If;
        End If;
      
        v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '|') + 1);
      End Loop;
    End If;
  End If;

  --对于就诊卡通过预交金挂号
  If Nvl(预交支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 Then
    n_预交金额 := 预交支付_In;
    For r_Deposit In c_Deposit(病人id_In, v_冲预交病人ids) Loop
      n_当前金额 := Case
                  When r_Deposit.金额 - n_预交金额 < 0 Then
                   r_Deposit.金额
                  Else
                   n_预交金额
                End;
      If r_Deposit.结帐id = 0 Then
        --第一次冲预交(填上结帐ID,金额为0)
        Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 4 Where ID = r_Deposit.原预交id;
      End If;
      --冲上次剩余额
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结算序号, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 登记时间_In,
               操作员姓名_In, 操作员编号_In, n_当前金额, 结帐id_In, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结帐id_In, 4
        From 病人预交记录
        Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
    
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - n_当前金额
      Where 病人id = r_Deposit.病人id And 性质 = 1 And 类型 = Nvl(1, 2)
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (r_Deposit.病人id, Nvl(1, 2), -1 * n_当前金额, 1);
        n_返回值 := -1 * n_当前金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Deposit.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --检查是否已经处理完
      If r_Deposit.金额 < n_预交金额 Then
        n_预交金额 := n_预交金额 - r_Deposit.金额;
      Else
        n_预交金额 := 0;
      End If;
    
      If n_预交金额 = 0 Then
        Exit;
      End If;
    End Loop;
  End If;

  --对于医保挂号
  If Nvl(个帐支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 Then
    Insert Into 病人预交记录
      (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
       预交类别, 结算序号, 结算性质)
    Values
      (病人预交记录_Id.Nextval, 4, 1, No_In, 病人id_In, v_个人帐户, 个帐支付_In, d_Date, 操作员编号_In, 操作员姓名_In, 结帐id_In, '医保挂号', n_组id,
       Null, Null, Null, Null, Null, Null, Null, 结帐id_In, 4);
  End If;

  --相关汇总表的处理
  --人员缴款余额
  If Nvl(个帐支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 And Nvl(更新交款余额_In, 0) = 0 Then
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + 个帐支付_In
    Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = v_个人帐户
    Returning 余额 Into n_返回值;
  
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, v_个人帐户, 1, 个帐支付_In);
      n_返回值 := 个帐支付_In;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 人员缴款余额 Where 收款员 = 操作员姓名_In And 性质 = 1 And Nvl(余额, 0) = 0;
    End If;
  End If;

  --处理票据使用情况
  If 票据号_In Is Not Null And Nvl(记帐费用_In, 0) = 0 Then
    Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
  
    --当前票据的票种
    Select 票种 Into n_票种 From 票据领用记录 Where ID = Nvl(领用id_In, 0);
    --发出票据
    Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 4, No_In);
  
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
    Values
      (票据使用明细_Id.Nextval, n_票种, 票据号_In, 1, 1, 领用id_In, n_打印id, d_Date, 操作员姓名_In);
  
    --状态改动
    Update 票据领用记录
    Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = d_Date
    Where ID = Nvl(领用id_In, 0);
  End If;

  If Nvl(记帐费用_In, 0) = 1 Then
    --记帐
    If Nvl(病人id_In, 0) = 0 Then
      v_Err_Msg := '要针对病人的挂号费进行记帐，必须是建档病人才能记帐挂号。';
      Raise Err_Item;
    End If;
    For c_费用 In (Select 实收金额, 病人科室id, 开单部门id, 执行部门id, 收入项目id
                 From 门诊费用记录
                 Where 记录性质 = 4 And 记录状态 = 1 And NO = No_In And Nvl(记帐费用, 0) = 1) Loop
      --病人余额
      Update 病人余额
      Set 费用余额 = Nvl(费用余额, 0) + Nvl(c_费用.实收金额, 0)
      Where 病人id = Nvl(病人id_In, 0) And 性质 = 1 And 类型 = 1;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 费用余额, 预交余额)
        Values
          (病人id_In, 1, 1, Nvl(c_费用.实收金额, 0), 0);
      End If;
    
      --病人未结费用
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) + Nvl(c_费用.实收金额, 0)
      Where 病人id = 病人id_In And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(c_费用.病人科室id, 0) And
            Nvl(开单部门id, 0) = Nvl(c_费用.开单部门id, 0) And Nvl(执行部门id, 0) = Nvl(c_费用.执行部门id, 0) And 收入项目id + 0 = c_费用.收入项目id And
            来源途径 + 0 = 1;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人未结费用
          (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
        Values
          (病人id_In, Null, Null, c_费用.病人科室id, c_费用.开单部门id, c_费用.执行部门id, c_费用.收入项目id, 1, Nvl(c_费用.实收金额, 0));
      End If;
    End Loop;
  End If;
  If Nvl(病人id_In, 0) <> 0 Then
    n_结算模式 := 0;
    Update 病人信息
    Set 就诊时间 = d_发生时间, 就诊状态 = 1, 就诊诊室 = 诊室_In
    Where 病人id = 病人id_In
    Returning Nvl(结算模式, 0) Into n_结算模式;
    --取参数:
    If Nvl(n_结算模式, 0) <> Nvl(结算模式_In, 0) Then
      --结算模式的确定
      If n_结算模式 = 1 And Nvl(结算模式_In, 0) = 0 Then
        --病人已经是"先诊疗后结算的",本次是"先结算后诊疗的",则检查是否存在未结数据
        Select Count(1)
        Into n_Count
        From 病人未结费用
        Where 病人id = 病人id_In And (来源途径 In (1, 4) Or 来源途径 = 3 And Nvl(主页id, 0) = 0) And Nvl(金额, 0) <> 0 And Rownum < 2;
        If Nvl(n_Count, 0) <> 0 Then
          --存在未结算数据，必须先结算后才允许执行
          v_Err_Msg := '当前病人的就诊模式为先诊疗后结算且存在未结费用，不允许调整该病人的就诊模式,你可以先对未结费用结帐后再挂号或不调整病人的就诊模式!';
          Raise Err_Item;
        End If;
        --检查
        --未发生医嘱业务的（即当时就挂号的,需要保证同一次的就诊模式是一至的(程序已经检查，不用再处理)
      End If;
      Update 病人信息 Set 结算模式 = 结算模式_In Where 病人id = 病人id_In;
    End If;
  End If;

  --病人担保信息
  If 病人id_In Is Not Null Then
    Update 病人信息
    Set 担保人 = Null, 担保额 = Null, 担保性质 = Null
    Where 病人id = 病人id_In And Nvl(在院, 0) = 0 And Exists
     (Select 1
           From 病人担保记录
           Where 病人id = 病人id_In And 主页id Is Not Null And
                 登记时间 = (Select Max(登记时间) From 病人担保记录 Where 病人id = 病人id_In));
    If Sql%RowCount > 0 Then
      Update 病人担保记录
      Set 到期时间 = d_Date
      Where 病人id = 病人id_In And 主页id Is Not Null And Nvl(到期时间, d_Date) >= d_Date;
    End If;
  End If;
  --消息推送
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 1, n_挂号id;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Err_Special Then
    Raise_Application_Error(-20105, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_预约挂号接收_出诊_Insert;
/


--103209:刘尔旋,2016-12-20,服务窗医保实时结算
Create Or Replace Procedure Zl_Third_Reghistory
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取历史挂号数据
  --入参:Xml_In:
  --<IN>
  --   <BRID>88393</BRID>    //卡号
  --   <JLS>5</JLS >       //记录条数，按日期由近到远
  --   <JSKLB></JSKLB>     //结算卡类别
  --   <ZD></ZD>           //站点
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  --   <GHLIST>       //如果为空表示没有找到数据
  --    <GH>
  --     <GHDH>N001</GHDH>   //挂号单号
  --     <KS>门诊外科</KS>     //挂号科室
  --     <KSID>42</KSID>    //科室id
  --     <DJSJ>2014-10-21 14:12:44</DJSJ>    //登记时间
  --     <YYSJ>2014-10-21 14:10</YYSJ>    //预约时间
  --     <ZXZT>1</ZXZT>     //状态(预约中等待付款、已挂号、候诊等)
  --     <DDFK>1</DDFK>     //是否付款
  --     <GHFS>支付宝</GHFS>    //挂号方式(支付宝、自助机、窗口)
  --     <YSXM>LEX</YSXM>    //医生姓名
  --    </GH>
  --   </GHLIST>
  --   <ERROR><MSG>错误信息</MSG></ERROR>     //如果有错误返回
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  v_费别         病人信息.费别%Type;
  v_付款方式     病人信息.医疗付款方式%Type;
  v_姓名         病人信息.姓名%Type;
  v_性别         病人信息.性别%Type;
  v_年龄         病人信息.年龄%Type;
  d_出生日期     病人信息.出生日期%Type;
  v_身份证号     病人信息.身份证号%Type;
  v_卡类别       医疗卡类别.名称%Type;
  v_卡号         病人医疗卡信息.卡号%Type;
  n_卡类别id     医疗卡类别.Id%Type;
  v_结算方式     医疗卡类别.结算方式%Type;
  v_验证姓名     病人信息.姓名%Type;
  n_病人id       病人信息.病人id%Type;
  n_卡病人id     病人信息.病人id%Type;
  v_医疗卡编码   医疗卡类别.编码%Type;
  n_是否缺省密码 医疗卡类别.是否缺省密码%Type;
  v_密码         病人医疗卡信息.密码%Type;
  n_密码长度     医疗卡类别.密码长度%Type;
  n_记录数       Number(4);
  v_结算卡类别   Varchar2(100);
  n_是否付款     Number(3);
  v_Temp         Varchar2(32767); --临时XML
  x_Templet      Xmltype; --模板XML
  v_Err_Msg      Varchar2(200);
  n_Exists       Number(2);
  v_状态         Varchar2(100);
  n_站点         Number(1);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT><GHLIST></GHLIST></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/BRID'), Extractvalue(Value(A), 'IN/JLS'), Extractvalue(Value(A), 'IN/JSKLB'),
         Extractvalue(Value(A), 'IN/ZD')
  Into n_病人id, n_记录数, v_结算卡类别, n_站点
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  If v_结算卡类别 Is Not Null Then
    Begin
      n_卡类别id := To_Number(v_结算卡类别);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
    If n_卡类别id = 0 Then
      Begin
        Select ID Into n_卡类别id From 医疗卡类别 Where 名称 = v_结算卡类别;
      Exception
        When Others Then
          v_Err_Msg := '无法确认传入的结算卡！';
          Raise Err_Item;
      End;
    End If;
  Else
    n_卡类别id := 0;
  End If;

  n_记录数 := Nvl(n_记录数, 0);

  If Nvl(n_卡类别id, 0) = 0 Then
    For r_Reg In (Select Distinct a.No, a.执行部门id As 科室id, b.名称 As 科室, a.登记时间 As 创建时间, a.发生时间 As 预约时间,
                                  Decode(a.记录性质, 2, '预约中',
                                          Decode(a.执行状态, -1, '不就诊', 0, '等待就诊', 1, '完成就诊', 2, '正在就诊', '已挂号')) As 状态,
                                  Decode(c.记录状态, 0, 0, 1) As 是否付款, a.预约方式 As 挂号方式, a.执行人 As 医生姓名
                  From 病人挂号记录 A, 部门表 B, 门诊费用记录 C
                  Where a.病人id = n_病人id And a.执行部门id = b.Id And c.No = a.No And c.序号 = 1 And c.记录性质 = 4 And a.记录状态 = 1 And
                        (b.站点 = Nvl(n_站点, 0) Or b.站点 Is Null)
                  Order By a.登记时间 Desc) Loop
      If n_记录数 <> 0 Then
        Begin
          Select Decode(记录状态, 0, 0, 1)
          Into n_是否付款
          From 门诊费用记录
          Where 记录性质 = 1 And 病人id = n_病人id And Instr(摘要, '挂号:' || r_Reg.No) > 0 And Rownum < 2;
        Exception
          When Others Then
            n_是否付款 := r_Reg.是否付款;
        End;
        If n_是否付款 = 0 And r_Reg.状态 = '预约中' And Sysdate > r_Reg.预约时间 Then
          v_状态 := '已失效';
        Else
          v_状态 := r_Reg.状态;
        End If;
        v_Temp := '<GH>' || '<GHDH>' || r_Reg.No || '</GHDH>' || '<KS>' || r_Reg.科室 || '</KS>' || '<KSID>' ||
                  r_Reg.科室id || '</KSID>' || '<DJSJ>' || To_Char(r_Reg.创建时间, 'YYYY-MM-DD hh24:mi:ss') || '</DJSJ>' ||
                  '<YYSJ>' || To_Char(r_Reg.预约时间, 'YYYY-MM-DD hh24:mi:ss') || '</YYSJ>' || '<ZXZT>' || v_状态 ||
                  '</ZXZT>' || '<DDFK>' || n_是否付款 || '</DDFK>' || '<GHFS>' || r_Reg.挂号方式 || '</GHFS>' || '<YSXM>' ||
                  r_Reg.医生姓名 || '</YSXM>' || '</GH>';
        Select Appendchildxml(x_Templet, '/OUTPUT/GHLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
        n_记录数 := n_记录数 - 1;
      End If;
    End Loop;
  Else
    For r_Reg In (Select Distinct a.No, a.执行部门id As 科室id, b.名称 As 科室, a.登记时间 As 创建时间, a.发生时间 As 预约时间,
                                  Decode(a.记录性质, 2, '预约中',
                                          Decode(a.执行状态, -1, '不就诊', 0, '等待就诊', 1, '完成就诊', 2, '正在就诊', '已挂号')) As 状态,
                                  Decode(c.记录状态, 0, 0, 1) As 是否付款, a.预约方式 As 挂号方式, a.执行人 As 医生姓名
                  From 病人挂号记录 A, 部门表 B, 门诊费用记录 C, 病人预交记录 D
                  Where a.病人id = n_病人id And a.执行部门id = b.Id And c.No = a.No And c.序号 = 1 And c.记录性质 = 4 And a.记录状态 = 1 And
                        c.结帐id = d.结帐id And (d.卡类别id = n_卡类别id Or d.卡类别id Is Null) And Not Exists
                   (Select 1
                         From 病人预交记录
                         Where 结帐id = c.结帐id And Nvl(卡类别id, 0) <> 0 And Nvl(卡类别id, 0) <> n_卡类别id) And
                        (b.站点 = Nvl(n_站点, 0) Or b.站点 Is Null)
                  Order By a.登记时间 Desc) Loop
      If n_记录数 <> 0 Then
        Begin
          Select Decode(记录状态, 0, 0, 1)
          Into n_是否付款
          From 门诊费用记录
          Where 记录性质 = 1 And 病人id = n_病人id And Instr(摘要, '挂号:' || r_Reg.No) > 0 And Rownum < 2;
        Exception
          When Others Then
            n_是否付款 := r_Reg.是否付款;
        End;
        If n_是否付款 = 0 And r_Reg.状态 = '预约中' And Sysdate > r_Reg.预约时间 Then
          v_状态 := '已失效';
        Else
          v_状态 := r_Reg.状态;
        End If;
        v_Temp := '<GH>' || '<GHDH>' || r_Reg.No || '</GHDH>' || '<KS>' || r_Reg.科室 || '</KS>' || '<KSID>' ||
                  r_Reg.科室id || '</KSID>' || '<DJSJ>' || To_Char(r_Reg.创建时间, 'YYYY-MM-DD hh24:mi:ss') || '</DJSJ>' ||
                  '<YYSJ>' || To_Char(r_Reg.预约时间, 'YYYY-MM-DD hh24:mi:ss') || '</YYSJ>' || '<ZXZT>' || v_状态 ||
                  '</ZXZT>' || '<DDFK>' || n_是否付款 || '</DDFK>' || '<GHFS>' || r_Reg.挂号方式 || '</GHFS>' || '<YSXM>' ||
                  r_Reg.医生姓名 || '</YSXM>' || '</GH>';
        Select Appendchildxml(x_Templet, '/OUTPUT/GHLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
        n_记录数 := n_记录数 - 1;
      End If;
    End Loop;
  End If;

  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Reghistory;
/


--103112:余伟节,2017-02-15,病人入院管理支持手机号录入及查询
--104064:余伟节,2016-12-19,解决入院登记插入在院病人失败的问题
Create Or Replace Procedure Zl_入院病案主页_Insert
(
  登记模式_In       Number,
  病人性质_In       病案主页.病人性质%Type,
  病人id_In         病人信息.病人id%Type,
  住院号_In         病人信息.住院号%Type,
  医保号_In         保险帐户.医保号%Type,
  姓名_In           病人信息.姓名%Type,
  性别_In           病人信息.性别%Type,
  年龄_In           病人信息.年龄%Type,
  费别_In           病人信息.费别%Type,
  出生日期_In       病人信息.出生日期%Type,
  国籍_In           病人信息.国籍%Type,
  民族_In           病人信息.民族%Type,
  学历_In           病人信息.学历%Type,
  婚姻状况_In       病人信息.婚姻状况%Type,
  职业_In           病人信息.职业%Type,
  身份_In           病人信息.身份%Type,
  身份证号_In       病人信息.身份证号%Type,
  出生地点_In       病人信息.出生地点%Type,
  家庭地址_In       病人信息.家庭地址%Type,
  家庭地址邮编_In   病人信息.家庭地址邮编%Type,
  家庭电话_In       病人信息.家庭电话%Type,
  户口地址_In       病人信息.户口地址%Type,
  户口地址邮编_In   病人信息.户口地址邮编%Type,
  联系人姓名_In     病人信息.联系人姓名%Type,
  联系人关系_In     病人信息.联系人关系%Type,
  联系人地址_In     病人信息.联系人地址%Type,
  联系人电话_In     病人信息.联系人电话%Type,
  工作单位_In       病人信息.工作单位%Type,
  合同单位id_In     病人信息.合同单位id%Type,
  单位电话_In       病人信息.单位电话%Type,
  单位邮编_In       病人信息.单位邮编%Type,
  单位开户行_In     病人信息.单位开户行%Type,
  单位帐号_In       病人信息.单位帐号%Type,
  担保人_In         病人信息.担保人%Type,
  担保额_In         病人信息.担保额%Type,
  担保性质_In       病人信息.担保性质%Type,
  入院科室id_In     病案主页.入院科室id%Type,
  护理等级id_In     病案主页.护理等级id%Type,
  入院病况_In       病案主页.入院病况%Type,
  入院方式_In       病案主页.入院方式%Type,
  住院目的_In       病案主页.住院目的%Type,
  二级院转入_In     病案主页.二级院转入%Type,
  门诊医师_In       病案主页.门诊医师%Type,
  籍贯_In           病人信息.籍贯%Type,
  区域_In           病案主页.区域%Type,
  入院时间_In       病案主页.入院日期%Type,
  是否陪伴_In       病案主页.是否陪伴%Type,
  床号_In           病案主页.入院病床%Type,
  付款方式_In       病案主页.医疗付款方式%Type,
  疾病id_In         病人诊断记录.疾病id%Type,
  诊断id_In         病人诊断记录.诊断id%Type,
  门诊诊断_In       病人诊断记录.诊断描述%Type,
  中医疾病id_In     病人诊断记录.疾病id%Type,
  中医诊断id_In     病人诊断记录.诊断id%Type,
  中医诊断_In       病人诊断记录.诊断描述%Type,
  险类_In           病案主页.险类%Type,
  操作员编号_In     病案主页.编目员编号%Type,
  操作员姓名_In     病案主页.编目员姓名%Type,
  新病人_In         Number := 1,
  备注_In           病案主页.备注%Type,
  入院病区id_In     病案主页.入院病区id%Type,
  再入院_In         病案主页.再入院%Type,
  入院属性_In       病案主页.入院属性%Type := Null,
  主页id_In         病案主页.主页id%Type := Null,
  住院次数_In       病人信息.住院次数%Type := Null,
  其他证件_In       病人信息.其他证件%Type := Null,
  病人类型_In       病案主页.病人类型%Type := Null,
  联系人身份证号_In 病人信息.联系人身份证号%Type := Null,
  手机号_In         病人信息.手机号%Type := Null
) As
  -----------------------------------------------------------
  --功能：对入院病人新增一张病案主页，同时可能处理入科。
  --参数：
  --      登记模式_IN=0-正常登记,1-预约登记,2-接收预约(新病人_IN=0)
  --      病人性质_IN=对应"病案主页.病人性质"
  --      床号_IN=Null:不同时入科;'家庭病床':分配家庭病床,填为空;其他:分配具体床位。
  --      新病人_IN=如果是已有档案的病人入院,则该参数为0；缺省为新病人
  --      入院病区ID_IN=只有当使用[病区管理病床]模式(参数号99)时,并且入院同时入科分床时,才有值
  --      住院号_In = 登记门诊留观病人时 住院号_In 为病人门诊号
  -----------------------------------------------------------
  v_主页id   病案主页.主页id%Type;
  v_等级id   床位状况记录.等级id%Type;
  n_住院次数 病人信息.住院次数%Type;

  v_费别  病案主页.费别%Type;
  v_Count Number;
  v_Date  Date;
  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --判断病人是否锁定
  Select Count(病人id) Into v_Count From 病人信息 Where 病人id = 病人id_In;
  If v_Count <> 0 Then
    Zl_病人信息_锁定检查(病人id_In);
  End If;

  Select Sysdate Into v_Date From Dual;
  Zl_病区标记记录_Clear(病人id_In);
  --病人基本信息
  If 病人性质_In = 1 Then
    If 新病人_In = 1 Then
      Insert Into 病人信息
        (病人id, 门诊号, 住院号, 姓名, 性别, 年龄, 费别, 医疗付款方式, 出生日期, 国籍, 民族, 籍贯, 区域, 学历, 婚姻状况, 职业, 身份, 身份证号, 出生地点, 家庭地址, 家庭地址邮编, 家庭电话,
         户口地址, 户口地址邮编, 联系人姓名, 联系人关系, 联系人地址, 联系人电话, 工作单位, 合同单位id, 单位电话, 单位邮编, 单位开户行, 单位帐号, 担保人, 担保额, 担保性质, 险类, 登记时间, 其他证件,
         联系人身份证号, 手机号)
      Values
        (病人id_In, 住院号_In, Null, 姓名_In, 性别_In, 年龄_In, 费别_In, 付款方式_In, 出生日期_In, 国籍_In, 民族_In, 籍贯_In, 区域_In, 学历_In,
         婚姻状况_In, 职业_In, 身份_In, 身份证号_In, 出生地点_In, 家庭地址_In, 家庭地址邮编_In, 家庭电话_In, 户口地址_In, 户口地址邮编_In, 联系人姓名_In, 联系人关系_In,
         联系人地址_In, 联系人电话_In, 工作单位_In, Decode(合同单位id_In, 0, Null, 合同单位id_In), 单位电话_In, 单位邮编_In, 单位开户行_In, 单位帐号_In, 担保人_In,
         Decode(担保额_In, 0, Null, 担保额_In), 担保性质_In, 险类_In, v_Date, 其他证件_In, 联系人身份证号_In, 手机号_In);
    Else
      --老病人的门诊费别不变,除非是门诊留观病人
      Update 病人信息
      Set 门诊号 = 住院号_In, 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In, 费别 = Decode(病人性质_In, 1, 费别_In, 费别), 医疗付款方式 = 付款方式_In,
          出生日期 = 出生日期_In, 国籍 = 国籍_In, 民族 = 民族_In, 籍贯 = 籍贯_In, 区域 = 区域_In, 学历 = 学历_In, 婚姻状况 = 婚姻状况_In, 职业 = 职业_In,
          身份 = 身份_In, 身份证号 = 身份证号_In, 出生地点 = 出生地点_In, 家庭地址 = 家庭地址_In, 家庭地址邮编 = 家庭地址邮编_In, 家庭电话 = 家庭电话_In, 户口地址 = 户口地址_In,
          户口地址邮编 = 户口地址邮编_In, 联系人姓名 = 联系人姓名_In, 联系人关系 = 联系人关系_In, 联系人地址 = 联系人地址_In, 联系人电话 = 联系人电话_In, 工作单位 = 工作单位_In,
          合同单位id = Decode(合同单位id_In, 0, Null, 合同单位id_In), 单位电话 = 单位电话_In, 单位邮编 = 单位邮编_In, 单位开户行 = 单位开户行_In,
          单位帐号 = 单位帐号_In, 担保人 = 担保人_In, 担保额 = Decode(担保额_In, 0, Null, 担保额_In), 担保性质 = 担保性质_In, 险类 = 险类_In,
          其他证件 = 其他证件_In, 联系人身份证号 = 联系人身份证号_In, 手机号 = NVL(手机号_In, 手机号)
      Where 病人id = 病人id_In;
    End If;
  Else
    If 新病人_In = 1 Then
      Insert Into 病人信息
        (病人id, 住院号, 姓名, 性别, 年龄, 费别, 医疗付款方式, 出生日期, 国籍, 民族, 籍贯, 区域, 学历, 婚姻状况, 职业, 身份, 身份证号, 出生地点, 家庭地址, 家庭地址邮编, 家庭电话,
         户口地址, 户口地址邮编, 联系人姓名, 联系人关系, 联系人地址, 联系人电话, 工作单位, 合同单位id, 单位电话, 单位邮编, 单位开户行, 单位帐号, 担保人, 担保额, 担保性质, 险类, 登记时间, 其他证件,
         联系人身份证号, 手机号)
      Values
        (病人id_In, Decode(病人性质_In, 2, Null, 住院号_In), 姓名_In, 性别_In, 年龄_In, 费别_In, 付款方式_In, 出生日期_In, 国籍_In, 民族_In, 籍贯_In,
         区域_In, 学历_In, 婚姻状况_In, 职业_In, 身份_In, 身份证号_In, 出生地点_In, 家庭地址_In, 家庭地址邮编_In, 家庭电话_In, 户口地址_In, 户口地址邮编_In,
         联系人姓名_In, 联系人关系_In, 联系人地址_In, 联系人电话_In, 工作单位_In, Decode(合同单位id_In, 0, Null, 合同单位id_In), 单位电话_In, 单位邮编_In,
         单位开户行_In, 单位帐号_In, 担保人_In, Decode(担保额_In, 0, Null, 担保额_In), 担保性质_In, 险类_In, v_Date, 其他证件_In, 联系人身份证号_In, 手机号_In);
    Else
      --老病人的门诊费别不变,除非是门诊留观病人
      Update 病人信息
      Set 住院号 = Decode(病人性质_In, 2, 住院号, Decode(住院号_In, Null, 住院号, 住院号_In)), 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In,
          费别 = Decode(病人性质_In, 1, 费别_In, 费别), 医疗付款方式 = 付款方式_In, 出生日期 = 出生日期_In, 国籍 = 国籍_In, 民族 = 民族_In, 籍贯 = 籍贯_In,
          区域 = 区域_In, 学历 = 学历_In, 婚姻状况 = 婚姻状况_In, 职业 = 职业_In, 身份 = 身份_In, 身份证号 = 身份证号_In, 出生地点 = 出生地点_In, 家庭地址 = 家庭地址_In,
          家庭地址邮编 = 家庭地址邮编_In, 家庭电话 = 家庭电话_In, 户口地址 = 户口地址_In, 户口地址邮编 = 户口地址邮编_In, 联系人姓名 = 联系人姓名_In, 联系人关系 = 联系人关系_In,
          联系人地址 = 联系人地址_In, 联系人电话 = 联系人电话_In, 工作单位 = 工作单位_In, 合同单位id = Decode(合同单位id_In, 0, Null, 合同单位id_In),
          单位电话 = 单位电话_In, 单位邮编 = 单位邮编_In, 单位开户行 = 单位开户行_In, 单位帐号 = 单位帐号_In, 担保人 = 担保人_In,
          担保额 = Decode(担保额_In, 0, Null, 担保额_In), 担保性质 = 担保性质_In, 险类 = 险类_In, 其他证件 = 其他证件_In, 联系人身份证号 = 联系人身份证号_In,
          手机号 = NVL(手机号_In, 手机号)
      Where 病人id = 病人id_In;
    End If;
  End If;

  --病案信息
  Begin
    If 登记模式_In = 1 Then
      v_主页id := 0; --预约登记记录的主页ID=0
    Else
      If 主页id_In Is Null Then
        Select Nvl(Max(主页id), 0) + 1 Into v_主页id From 病案主页 Where 病人id = 病人id_In And Nvl(主页id, 0) <> 0;
      Else
        v_主页id := 主页id_In;
      End If;
    End If;
  Exception
    When Others Then
      Null;
  End;

  If 登记模式_In <> 1 Then
    Update 病人信息
    Set 主页id = v_主页id, 当前病区id = 入院病区id_In, 当前科室id = 入院科室id_In, 当前床号 = Decode(床号_In, '家庭病床', Null, 床号_In), 入院时间 = 入院时间_In,
        出院时间 = Null, 在院 = 1
    Where 病人id = 病人id_In;
  End If;

  --更新住院次数
  If 登记模式_In <> 1 And 病人性质_In = 0 Then
    If Nvl(住院次数_In, 0) = 0 Then
      Select Nvl(住院次数, 0) + 1 Into n_住院次数 From 病人信息 Where 病人id = 病人id_In;
    Else
      n_住院次数 := 住院次数_In;
    End If;
    Update 病人信息 Set 住院次数 = n_住院次数 Where 病人id = 病人id_In;
  End If;

  --状态：0-正常在院,1-等待入科,2-等待转科
  If 登记模式_In = 2 Then
    --处理病案主页从表
    Delete From 病案主页从表 Where 病人id = 病人id_In And Nvl(主页id, 0) = 0;
    --接收预约
    Update 病案主页
    Set 主页id = v_主页id, 病人性质 = 病人性质_In, 住院号 = Decode(病人性质_In, 1, Null, 2, Null, 住院号_In),
        留观号 = Decode(病人性质_In, 2, 住院号_In, Null),
        --主页ID变更,病人性质可能变更
        费别 = 费别_In, 入院病区id = 入院病区id_In, 入院科室id = 入院科室id_In, 入院日期 = 入院时间_In, 入院病况 = 入院病况_In, 入院方式 = 入院方式_In,
        入院属性 = 入院属性_In, 二级院转入 = 二级院转入_In, 住院目的 = 住院目的_In, 入院病床 = Decode(床号_In, '家庭病床', Null, 床号_In), 是否陪伴 = 是否陪伴_In,
        当前病况 = 入院病况_In, 当前病区id = 入院病区id_In, 护理等级id = Decode(护理等级id_In, 0, Null, 护理等级id_In), 出院科室id = 入院科室id_In,
        出院病床 = Decode(床号_In, '家庭病床', Null, 床号_In), 门诊医师 = 门诊医师_In, 编目员编号 = 操作员编号_In, 编目员姓名 = 操作员姓名_In, 姓名 = 姓名_In,
        性别 = 性别_In, 年龄 = 年龄_In, 婚姻状况 = 婚姻状况_In, 职业 = 职业_In, 国籍 = 国籍_In, 学历 = 学历_In, 单位电话 = 单位电话_In, 单位邮编 = 单位邮编_In,
        单位地址 = 工作单位_In, 区域 = 区域_In, 家庭地址 = 家庭地址_In, 家庭电话 = 家庭电话_In, 家庭地址邮编 = 家庭地址邮编_In, 户口地址 = 户口地址_In,
        户口地址邮编 = 户口地址邮编_In, 联系人姓名 = 联系人姓名_In, 联系人关系 = 联系人关系_In, 联系人地址 = 联系人地址_In, 联系人身份证号 = 联系人身份证号_In, 联系人电话 = 联系人电话_In,
        医疗付款方式 = 付款方式_In, 备注 = 备注_In, 险类 = 险类_In, 状态 = Decode(床号_In, Null, 1, 0), 登记人 = 操作员姓名_In, 登记时间 = v_Date,
        再入院 = 再入院_In, 病人类型 = 病人类型_In
    Where 病人id = 病人id_In And Nvl(主页id, 0) = 0;
    Update 病人预交记录
    Set 主页id = 主页id_In
    Where 病人id = 病人id_In And 主页id Is Null And 科室id = 入院科室id_In And 预交类别 = 2 And 冲预交 Is Null And
          Trunc(收款时间) = Trunc(Sysdate);
  Else
    --入院登记或预约登记
    Insert Into 病案主页
      (病人性质, 病人id, 主页id, 住院号, 留观号, 费别, 入院病区id, 入院科室id, 入院日期, 入院病况, 入院方式, 入院属性, 二级院转入, 住院目的, 入院病床, 是否陪伴, 当前病况, 当前病区id,
       护理等级id, 出院科室id, 出院病床, 门诊医师, 编目员编号, 编目员姓名, 状态, 姓名, 性别, 年龄, 婚姻状况, 职业, 国籍, 学历, 单位电话, 单位邮编, 单位地址, 区域, 家庭地址, 家庭电话,
       家庭地址邮编, 户口地址, 户口地址邮编, 联系人姓名, 联系人关系, 联系人地址, 联系人电话, 联系人身份证号, 医疗付款方式, 险类, 备注, 登记人, 登记时间, 再入院, 病人类型)
    Values
      (病人性质_In, 病人id_In, v_主页id, Decode(病人性质_In, 1, Null, 2, Null, 住院号_In), Decode(病人性质_In, 2, 住院号_In, Null), 费别_In,
       入院病区id_In, 入院科室id_In, 入院时间_In, 入院病况_In, 入院方式_In, 入院属性_In, 二级院转入_In, 住院目的_In, Decode(床号_In, '家庭病床', Null, 床号_In),
       是否陪伴_In, 入院病况_In, 入院病区id_In, Decode(护理等级id_In, 0, Null, 护理等级id_In), 入院科室id_In, Decode(床号_In, '家庭病床', Null, 床号_In),
       门诊医师_In, 操作员编号_In, 操作员姓名_In, Decode(床号_In, Null, 1, 0), 姓名_In, 性别_In, 年龄_In, 婚姻状况_In, 职业_In, 国籍_In, 学历_In,
       单位电话_In, 单位邮编_In, 工作单位_In, 区域_In, 家庭地址_In, 家庭电话_In, 家庭地址邮编_In, 户口地址_In, 户口地址邮编_In, 联系人姓名_In, 联系人关系_In, 联系人地址_In,
       联系人电话_In, 联系人身份证号_In, 付款方式_In, 险类_In, 备注_In, 操作员姓名_In, v_Date, 再入院_In, 病人类型_In);
  End If;

  If 登记模式_In <> 1 Then
    Update 在院病人 Set 病区id = Nvl(入院病区id_In, 0), 科室id = 入院科室id_In Where 病人id = 病人id_In;
    If Sql%RowCount = 0 Then
      Insert Into 在院病人
        (病人id, 科室id, 病区id, 主页id)
      Values
        (病人id_In, 入院科室id_In, Nvl(入院病区id_In, 0), Nvl(v_主页id, 0));
    End If;
  End If;

  Select 费别 Into v_费别 From 病人信息 Where 病人id = 病人id_In;
  If v_费别 Is Null Then
    Update 病人信息
    Set 费别 =
         (Select 费别 From 病案主页 Where 病人id = 病人id_In And 主页id = v_主页id)
    Where 病人id = 病人id_In;
  End If;

  --医保号
  If 登记模式_In <> 1 Then
    Select Zl_住院日报_Count(入院科室id_In, Trunc(入院时间_In)) Into v_Count From Dual;
    If v_Count > 0 Then
      v_Error := '已产生业务时间内的住院日报,不能办理该业务!';
      Raise Err_Custom;
    End If;
  
    If 医保号_In Is Not Null Then
      Insert Into 病案主页从表 (病人id, 主页id, 信息名, 信息值) Values (病人id_In, v_主页id, '医保号', 医保号_In);
    End If;
  
    --病人变动记录
    --同时入科且非家庭病床时有等级
    If 床号_In Is Not Null And 床号_In <> '家庭病床' Then
      Select 等级id Into v_等级id From 床位状况记录 Where 病区id = 入院病区id_In And 床号 = 床号_In;
    End If;
  
    --如果同时入科,则入院和入科填写到一条入院变动
    Insert Into 病人变动记录
      (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 护理等级id, 床位等级id, 床号, 病情, 操作员编号, 操作员姓名)
    Values
      (病人变动记录_Id.Nextval, 病人id_In, v_主页id, 入院时间_In, 1, 0, 入院病区id_In, 入院科室id_In, Decode(护理等级id_In, 0, Null, 护理等级id_In),
       v_等级id, Decode(床号_In, '家庭病床', Null, 床号_In), 入院病况_In, 操作员编号_In, 操作员姓名_In);
  
    --同时入科且非家庭病床时床位被占用
    If 床号_In Is Not Null And 床号_In <> '家庭病床' Then
      Select Count(*) Into v_Count From 床位状况记录 Where 病区id = 入院病区id_In And 床号 = 床号_In And 状态 = '空床';
    
      If v_Count = 0 Then
        v_Error := '操作失败,床位 ' || 床号_In || ' 不是空床！';
        Raise Err_Custom;
      End If;
    
      Update 床位状况记录
      Set 状态 = '占用', 病人id = 病人id_In, 科室id = Decode(共用, 1, 入院科室id_In, 科室id)
      Where 病区id = 入院病区id_In And 床号 = 床号_In;
    End If;
  
    --病人诊断记录
    If 门诊诊断_In Is Not Null Or 疾病id_In Is Not Null Then
      Insert Into 病人诊断记录
        (ID, 病人id, 主页id, 记录来源, 诊断类型, 诊断次序, 疾病id, 诊断id, 诊断描述, 记录日期, 记录人)
      Values
        (病人诊断记录_Id.Nextval, 病人id_In, v_主页id, 2, 1, 1, 疾病id_In, 诊断id_In, 门诊诊断_In, Sysdate, 操作员姓名_In);
    End If;
    If 中医诊断_In Is Not Null Or 中医疾病id_In Is Not Null Then
      Insert Into 病人诊断记录
        (ID, 病人id, 主页id, 记录来源, 诊断类型, 诊断次序, 疾病id, 诊断id, 诊断描述, 记录日期, 记录人)
      Values
        (病人诊断记录_Id.Nextval, 病人id_In, v_主页id, 2, 11, 1, 中医疾病id_In, 中医诊断id_In, 中医诊断_In, Sysdate, 操作员姓名_In);
    End If;
    --病人担保记录
    Update 病人担保记录
    Set 到期时间 = Sysdate
    Where 病人id = 病人id_In And 到期时间 Is Not Null And 到期时间 > Sysdate;
  
    --病人费用审批项目
    If 登记模式_In <> 1 Then
      Delete From 病人审批项目 Where 病人id = 病人id_In;
    End If;
  
    If 登记模式_In = 0 And ((门诊诊断_In Is Not Null Or 疾病id_In Is Not Null) Or (中医诊断_In Is Not Null Or 中医疾病id_In Is Not Null)) Then
      --产生病历书写时机
      Zl_电子病历时机_Insert(病人id_In, 主页id_In, 2, '诊断', 入院科室id_In, Null, Sysdate, Sysdate);
    End If;
  
    If 登记模式_In = 0 And 床号_In Is Not Null Then
      If 再入院_In = 0 Then
        Zl_电子病历时机_Insert(病人id_In, 主页id_In, 2, '入院', 入院科室id_In, Null, 入院时间_In, 入院时间_In);
      Else
        Zl_电子病历时机_Insert(病人id_In, 主页id_In, 2, '再次入院', 入院科室id_In, Null, 入院时间_In, 入院时间_In);
      End If;
    End If;
  
    If 床号_In Is Not Null Then
      --添加首份体温单
      Zl_病人体温单_Newfirst(病人id_In, 主页id_In, 入院病区id_In);
    End If;
  
    --并发操作检查
    Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 出院日期 Is Null;
    If v_Count > 1 Then
      v_Error := '发现病人存在非法的病案记录,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
      Raise Err_Custom;
    End If;
  
    Select Count(*)
    Into v_Count
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = v_主页id And Nvl(附加床位, 0) = 0 And 开始时间 Is Not Null And 终止时间 Is Null;
    If v_Count > 1 Then
      v_Error := '发现病人存在非法的变动记录,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
      Raise Err_Custom;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_入院病案主页_Insert;
/

--103500:张永康,2016-12-16,更正门诊预交款是否冲完的判断错误
--104417:张永康,2016-12-30,处理通过负数退预交款的数据
Create Or Replace Procedure Zl1_Datamove_Tag
(
  d_End            In Date,
  n_批次           In Number,
  n_System         In Number,
  n_预交剩余款上限 In 病人预交记录.金额%Type := 10 --当病人不存在未结费用，也不是在院病人时，允许未冲完的预交款在指定值以下的数据强制转出，避免大量呆帐未转出从而影响转出速度
) As
  --功能：标记待转出的数据 
  --说明：为避免Undo表空间膨胀过大，分段提交 
  d_Lastend Date; --最终转出截止时间（d_End为本批转出截止时间）

  --递归取消“一张预交款单据中的一部分被标记为待转出”的数据
  Procedure Datamove_Tag_Update
  (
    结帐id_In t_Numlist,
    d_End     In Date,
    n_批次    In Number
  ) As
  
    c_结帐id t_Numlist := t_Numlist();
    c_No     t_Strlist := t_Strlist();
  Begin
    --1.1一张预交单据被多个结帐ID冲了，找出其中的一部分被标记为待转出的数据，如：
    --   NO=A001 记录性质=11 结帐ID=10 待转出=1
    --   NO=A001 记录性质=11 结帐ID=11 待转出=NULL
    If 结帐id_In Is Null Then
      Select Distinct a.No
      Bulk Collect
      Into c_No
      From 病人预交记录 A
      Where a.记录性质 In (1, 11) And a.待转出 = n_批次 And Exists
       (Select 1 From 病人预交记录 Where NO = a.No And 记录性质 In (1, 11) And 待转出 Is Null);
    Else
      Select Distinct a.No
      Bulk Collect
      Into c_No
      From 病人预交记录 A
      Where a.结帐id In (Select /*+cardinality(b,10) */
                        Column_Value
                       From Table(结帐id_In) B) And a.记录性质 In (1, 11) And a.待转出 Is Null And Exists
       (Select 1 From 病人预交记录 Where NO = a.No And 记录性质 In (1, 11) And 待转出 + 0 = n_批次);
    End If;
  
    If c_No.Count = 0 Then
      Return;
    End If;
  
    --1.2取消标记
    Forall I In 1 .. c_No.Count
      Update 病人预交记录 Set 待转出 = Null Where NO = c_No(I) And 记录性质 In (1, 11);
  
    --------------------------------------------------------------------------------------------------------
    --2.1一个结帐ID冲了多张预交单据，找出其中的一部分被标记为待转出的数据，如：
    --   NO=A001 记录性质=11 结帐ID=20 待转出=1
    --   NO=A002 记录性质=11 结帐ID=20 待转出=NULL
    Select Distinct a.结帐id
    Bulk Collect
    Into c_结帐id
    From 病人预交记录 A
    Where a.No In (Select /*+cardinality(b,10) */
                    Column_Value
                   From Table(c_No) B) And a.记录性质 In (1, 11) And a.待转出 Is Null And a.收款时间 + 0 < d_End And Exists
     (Select 1 From 病人预交记录 Where 结帐id = a.结帐id And 待转出 + 0 = n_批次);
  
    If c_结帐id.Count = 0 Then
      Return;
    End If;
  
    --2.2取消标记(包括一次结帐的其他结算方式的记录)
    Forall I In 1 .. c_结帐id.Count
      Update 病人预交记录 Set 待转出 = Null Where 结帐id = c_结帐id(I);
  
    --递归调用
    Datamove_Tag_Update(c_结帐id, d_End, n_批次);
  End Datamove_Tag_Update;
Begin
  Select 本次最终日期 Into d_Lastend From zlDataMove Where 系统 = n_System And 组号 = 1;
  If d_Lastend Is Null Then
    Return;
  End If;
  --新加子查询注意性能优化，把能够将数据过滤到最小的条件放到最后，Exists类条件放前面

  --1.经济核算（费用,药品,收款和票据等）  
  --冲销业务与原始业务的发生时间相同，登记时间不同，所以要按发生时间来查询.
  --以下情况，可能有多个结帐ID，或涉及多个费用单据，这些数据要一起转出或排除转出，否则影响后续判断是否结清
  --1.一张费用单据的一行费用或多行费用可能分多次结帐（有多个不同的结帐ID）
  --2.结帐作废后也可能分多次结清(一张单据多个不同的结帐ID)
  --3.结帐作废后可能与其他费用单据一起结(一张单据的多个结帐ID，涉及多个费用NO，这些NO可能之前结帐作废过，有其他结帐ID)
  --考虑到这情况的复杂性，为简化逻辑，提升查询性能，按病人ID来排除(该病人的结帐数据都不转出)

  Update /*+ rule*/ 病人预交记录 L
  Set 待转出 = n_批次
  Where 结帐id In
        (Select Distinct a.结帐id --1.门诊收费和挂号的收费结算记录
         From 门诊费用记录 A
         Where (a.记录状态 In (1, 2) Or a.记录状态 = 3 And Not Exists
                (Select 1
                 From 门诊费用记录 B
                 Where a.No = b.No And a.记录性质 = b.记录性质 And b.记录状态 = 2 And b.登记时间 >= d_Lastend)) And a.待转出 Is Null And
               a.记录性质 In (1, 4) And a.发生时间 < d_End
         Union All
         Select Distinct b.结算id --2.医保补结算(没有发生时间字段,作废记录的登记时间不同，为了把收费和作废的一次性转出，所以要连接B表)
         From 费用补充记录 A, 费用补充记录 B
         Where a.待转出 Is Null And a.No = b.No And a.记录性质 = b.记录性质 And a.登记时间 < d_End
         Union All
         Select Distinct a.结帐id --3.就诊卡的收费结算记录(排除之后退卡费的,一张单据中只要其中一行退了) 
         From 住院费用记录 A
         Where (a.记录状态 In (1, 2) Or a.记录状态 = 3 And Not Exists
                (Select 1
                 From 住院费用记录 B
                 Where a.No = b.No And a.记录性质 = b.记录性质 And b.记录状态 = 2 And b.登记时间 >= d_Lastend)) And a.待转出 Is Null And
               a.记帐费用 = 0 And a.记录性质 = 5 And a.发生时间 < d_End
         Union All --4.住院记帐费用的结帐结算记录     
         Select 结帐id
         From (With Settle As (Select Distinct c.结帐id
                               From (Select Distinct b.No, b.序号, Mod(b.记录性质, 10) As 记录性质
                                      From (Select Distinct b.Id
                                             From 病人结帐记录 A, 病人结帐记录 B --作废的结帐单的收费时间可能在指定时间之后，所以要连接B表
                                             Where (a.记录状态 In (1, 2) Or a.记录状态 = 3 And Not Exists
                                                    (Select 1
                                                     From 病人结帐记录 C
                                                     Where a.No = c.No And c.记录状态 = 2 And c.收费时间 >= d_Lastend)) And
                                                   a.待转出 Is Null And a.No = b.No And (a.结帐类型 = 2 Or Nvl(a.结帐类型, 0) = 0) And
                                                   a.收费时间 < d_End) A, 住院费用记录 B
                                      Where a.Id = b.结帐id) B, 住院费用记录 C --通过C表找到这些费用单据的所有结帐ID一起转(可能在转出时间之后)
                               Where c.No = b.No And Mod(c.记录性质, 10) = b.记录性质 And c.序号 = b.序号)
                Select 结帐id
                From Settle
                Minus
                Select Distinct a.Id
                From 病人结帐记录 A,
                     (Select Distinct 病人id
                       From (Select c.病人id, c.No, Mod(c.记录性质, 10) As 记录性质, Nvl(Sum(c.实收金额), 0) As 实收金额,
                                     Nvl(Sum(c.结帐金额), 0) As 结帐金额
                              From 住院费用记录 C, Settle S
                              Where c.结帐id = s.结帐id
                              Group By c.No, Mod(c.记录性质, 10), c.病人id) C
                       Where c.实收金额 <> c.结帐金额 And Exists (Select 1 From 在院病人 F Where c.病人id = f.病人id) --出院病人没有结清的也转走（在需要时再抽回），否则排除的数据量太大
                             Or Exists (Select 1
                              From 住院费用记录 E, 病人结帐记录 S
                              Where e.No = c.No And Mod(e.记录性质, 10) = c.记录性质 And e.结帐id = s.Id And
                                    s.待转出 Is Null And s.收费时间 >= d_Lastend)) N --即使是在本批转出时间之后结清，只要不是在最终转出时间之后，就不排除
                Where a.病人id = n.病人id And (a.结帐类型 = 2 Or Nvl(a.结帐类型, 0) = 0))
                Union All --5.门诊记帐费用的结帐结算记录  
                Select 结帐id
                From (With Settle As (Select Distinct c.结帐id
                                      From (Select Distinct b.No, b.序号, Mod(b.记录性质, 10) As 记录性质
                                             From (Select Distinct b.Id
                                                    From 病人结帐记录 A, 病人结帐记录 B
                                                    Where a.待转出 Is Null And a.No = b.No And (a.结帐类型 = 1 Or Nvl(a.结帐类型, 0) = 0) And
                                                          a.收费时间 < d_End) A, 门诊费用记录 B
                                             Where a.Id = b.结帐id) B, 门诊费用记录 C
                                      Where c.No = b.No And Mod(c.记录性质, 10) = b.记录性质 And c.序号 = b.序号)
                       Select 结帐id
                       From Settle
                       Minus
                       Select Distinct a.Id
                       From 病人结帐记录 A,
                            (Select Distinct c.病人id
                              From (Select c.病人id, c.No, Mod(c.记录性质, 10) As 记录性质, Nvl(Sum(c.实收金额), 0) As 实收金额,
                                            Nvl(Sum(c.结帐金额), 0) As 结帐金额
                                     From 门诊费用记录 C, Settle S
                                     Where c.结帐id = s.结帐id
                                     Group By c.No, Mod(c.记录性质, 10), c.病人id) C
                              Where c.实收金额 <> c.结帐金额 --门诊病人没有结清的不转走
                                    Or Exists (Select 1
                                     From 门诊费用记录 E, 病人结帐记录 S
                                     Where e.No = c.No And Mod(e.记录性质, 10) = c.记录性质 And e.结帐id = s.Id And
                                           s.待转出 Is Null And s.收费时间 >= d_Lastend)) N
                       Where a.病人id = n.病人id And (a.结帐类型 = 1 Or Nvl(a.结帐类型, 0) = 0))
         );

  --排除预交款未冲完的
  --为了降低逻辑的复杂性，不排除在转出时间之后发药或未发药的费用记录对应的结帐ID，将这种情况的结算数据和费用数据强制转走 
  --因为前面的SQL查出的结帐ID可能不全是冲预交的(门诊收费和住院结帐补费等)，所以，需要单独一个SQL来排除 
  Update /*+ rule*/ 病人预交记录
  Set 待转出 = Null
  Where 待转出 = n_批次 And
        结帐id In
        (Select Distinct d.结帐id --该单据相关的所有冲预交的结帐ID都不转出
         From 病人预交记录 D,
              (Select Distinct l.No
                From (Select l.No, l.病人id, l.预交类别, Nvl(Sum(l.金额), 0) As 金额, Nvl(Sum(l.冲预交), 0) As 冲预交,
                              Sum(Decode(l.待转出, Null, 1, 0)) As 未转出
                       From 病人预交记录 L --可能按结帐ID确认本次待转出的冲的只是剩余款，所以需要连接L表，查原始交预交的单据，以及记录性质为11的可能还有转出时间之后其他冲剩余款的结帐ID 
                       Where l.记录性质 In (1, 11) And
                             l.No In
                             (Select Distinct p.No From 病人预交记录 P Where p.记录性质 In (1, 11) And p.待转出 = n_批次)
                       Group By l.No, l.病人id, l.预交类别) L --多次住院可以一次结清，所以，不能加主页ID
                Where 未转出 > 0 --只要该预交单据还有未转出的预交或冲预交记录，则不转出，避免转出一部分导致后续判断错误                      
                      Or
                      l.金额 <> l.冲预交 And
                      (Exists (Select 1
                               From 病人预交记录 E --剩的预交款，一般用负数交预交来退款（NO号不同），这种相当于是冲完了，不排除
                               Where e.病人id = l.病人id And e.预交类别 = l.预交类别 And e.记录性质 In (1, 11) And
                                     (e.待转出 = n_批次 Or e.待转出 Is Null And e.结帐id Is Null And e.记录性质 = 1 And 收款时间 < d_End)
                                Having abs(Nvl(Sum(e.金额), 0) - Nvl(Sum(e.冲预交), 0)) > n_预交剩余款上限) --余额小于等于n不排除，与下面第3种结帐ID为空的要保持一致
                       Or l.预交类别 = 2 And Exists (Select 1 From 在院病人 E Where l.病人id = e.病人id) Or Exists
                       (Select 1
                        From 病人未结费用 E
                        Where l.病人id = e.病人id And (l.预交类别 = 1 And e.主页id Is Null Or l.预交类别 = 2 And e.主页id Is Not Null)))) N
         Where d.No = n.No And d.记录性质 In (1, 11));

  --单独处理3种结帐ID为空的预交记录
  --1.预交款没有使用就直接退了的记录(结帐ID为空) 
  Update /*+ rule*/ 病人预交记录
  Set 待转出 = n_批次
  Where 记录性质 = 1 And
        NO In (Select a.No
               From 病人预交记录 A
               Where a.结帐id Is Null And a.记录性质 = 1 And a.记录状态 In (2, 3) And a.待转出 Is Null And a.收款时间 < d_End
               Group By a.No
               Having Sum(a.金额) = 0);

  --2.交预交款后退款的记录（结帐ID为空，记录状态为2）
  Update /*+ rule*/ 病人预交记录
  Set 待转出 = n_批次
  Where 结帐id Is Null And 记录性质 = 1 And 记录状态 = 2 And
        NO In (Select a.No From 病人预交记录 A Where a.记录性质 = 1 And a.记录状态 = 3 And a.待转出 = n_批次);

  --排除同一张预交款单据部分记录被标记为转出的,只要有不转出的，则整张单据都不转出
  --跟第2种有关联影响，所以要放在它之后执行
  --要影响第3种情况的判断，所以要放在它之前执行
  Datamove_Tag_Update(Null, d_End, n_批次);

  --3.预交款未用完时用交负数预交来退款(结帐ID为空，并且跟原始的冲预交的NO没有关联关系)
  --不加条件"金额 < 0"，因为存在预交款没有使用过，就直接用交负数预交来退款的情况
  Update /*+ rule*/ 病人预交记录 L
  Set 待转出 = n_批次
  Where Exists (Select 1
         From 病人预交记录 E
         Where e.病人id = l.病人id And e.预交类别 = l.预交类别 And e.记录性质 In (1, 11) And
               (e.待转出 = n_批次 Or e.待转出 Is Null And e.结帐id Is Null And e.记录性质 = 1 And 记录状态 = 1 And 收款时间 < d_End)
         Group By e.病人id
         Having abs(Nvl(Sum(e.金额), 0) - Nvl(Sum(e.冲预交), 0)) <= n_预交剩余款上限) --余额小于等于n要转出，与前面“排除预交款未冲完的”要保持一致
        And Exists (Select 1
         From 病人预交记录 E
         Where e.病人id = l.病人id And e.预交类别 = l.预交类别 And e.记录性质 In (1, 11) And e.待转出 = n_批次) And
        待转出 Is Null And 结帐id Is Null And 记录性质 = 1 And 记录状态 = 1 And 收款时间 < d_End;

  Update Zldatamovelog
  Set 当前进度 = '(1/10)结算数据标记完成，正在标记费用数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  Update /*+ rule*/ 病人结帐记录
  Set 待转出 = n_批次
  Where ID In (Select 结帐id From 病人预交记录 Where 待转出 = n_批次);

  --结帐无结算的记录(为了提升性能，不判断费用，只要结了帐且无预交记录就当成是零费用结帐) 
  Update /*+ rule*/ 病人结帐记录 L
  Set 待转出 = n_批次
  Where 收费时间 < d_End And 待转出 Is Null And Not Exists (Select 1 From 病人预交记录 P Where l.Id = p.结帐id);

  Update /*+ rule*/ 病人卡结算对照
  Set 待转出 = n_批次
  Where 预交id In (Select a.Id From 病人预交记录 A Where 待转出 = n_批次);

  Update /*+ rule*/ 病人卡结算记录
  Set 待转出 = n_批次
  Where ID In (Select 卡结算id From 病人卡结算对照 Where 待转出 = n_批次);

  Update /*+ rule*/ 三方结算交易
  Set 待转出 = n_批次
  Where 交易id In (Select a.Id From 病人预交记录 A Where 待转出 = n_批次);

  Update /*+ rule*/ 三方退款信息
  Set 待转出 = n_批次
  Where (记录id, 结帐id) In (Select a.Id, a.结帐id From 病人预交记录 A Where 待转出 = n_批次);

  --1.挂号费用异常数据
  --a.结帐ID为空（实收金额可能不为零）
  --b.结帐ID不为空，打折后实收金额为0（应收金额正负冲销）的挂号费用，没有挂号记录，也没有预交记录
  --按发生时间转出，因为收和退的发生时间相同，登记时间不同。
  Update /*+ rule*/ 门诊费用记录
  Set 待转出 = n_批次
  Where 待转出 Is Null And 发生时间 < d_End And 记录性质 = 4 And (实收金额 = 0 Or 结帐id Is Null);

  --2.直接收费的和结帐无结算（预交）记录的，Union不加all去掉重复以减少in的数量 
  Update /*+ rule*/ 门诊费用记录
  Set 待转出 = n_批次
  Where 结帐id In
        (Select 结帐id From 病人预交记录 Where 待转出 = n_批次 Union Select ID From 病人结帐记录 Where 待转出 = n_批次);

  --3.没有结帐id的数据(按发生时间) 
  --a.未结帐的划价记录
  --b.未收费的零费用
  --加条件"待转出 Is Null"是为了处理连续多次标记转出的情况   
  Update /*+ rule*/ 门诊费用记录 A
  Set 待转出 = n_批次
  Where (记录状态 = 0 Or 记录性质 = 1 And 实收金额 = 0 And 结帐金额 = 0) And 结帐id Is Null And 待转出 Is Null And 发生时间 < d_End;

  --4.没有结帐id的数据(按发生时间) 
  --未结帐的门诊记帐费用(赖账)，该病人没有预交余额，并且病人在最终转出时间之后无未结门诊记帐费用
  Update /*+ rule*/ 门诊费用记录 A
  Set 待转出 = n_批次
  Where Not Exists (Select 1
         From 病人预交记录 B
         Where b.病人id = a.病人id And b.待转出 Is Null And b.预交类别 = 1 And b.记录性质 In (1, 11) Having
          Nvl(Sum(b.金额), 0) <> Nvl(Sum(b.冲预交), 0)) And Not Exists
   (Select 1
         From 门诊费用记录 B
         Where a.病人id = b.病人id And b.记录性质 = 2 And b.结帐id Is Null And b.待转出 Is Null And b.登记时间 > = d_Lastend) And
        记录性质 = 2 And 结帐id Is Null And 待转出 Is Null And 发生时间 < d_End;

  --5.没有结帐id的数据(按发生时间)
  --冲销产生的记帐记录（记录状态为2），登记时间可能在当前指定转出时间之后，而原始记帐记录（记录状态为3），登记时间在指定转出时间之前。前后两者的发生时间是相同的。
  --a.未结帐的零记帐费用或打折后实收金额为零的（结帐模块参数没有勾选对零费用结帐）
  --b.结帐作废后，记帐单销帐的记录（结帐ID为空且记录状态为2的），记录状态为3的且有结帐ID的在最前面已转出. 
  Update /*+ rule*/ 门诊费用记录 A
  Set 待转出 = n_批次
  Where (Exists (Select 1
                 From 门诊费用记录 B
                 Where a.No = b.No And a.记录性质 = b.记录性质 And a.序号 = b.序号 And b.记录状态 = 3 And b.结帐id Is Not Null And
                       b.待转出 + 0 = n_批次) And 记录状态 = 2 Or Exists
         (Select 1
          From 门诊费用记录 B
          Where a.No = b.No And a.记录性质 = b.记录性质 And a.序号 = b.序号 And b.结帐id Is Null
          Group By b.No, b.记录性质, b.序号
          Having Nvl(Sum(b.实收金额), 0) = 0)) And 记录性质 = 2 And 结帐id Is Null And 待转出 Is Null And 发生时间 < d_End;

  --6.有结帐id的零费用(按发生时间)
  --a.按费别打折后结帐金额为零的收费记录,
  --b.一张单据相同结帐ID的结帐金额之和为0(冲销后为零)
  --即使在转出时间之后发药的，也强制转出（为了减少逻辑复杂性，提高查询性能）
  Update /*+ rule*/ 门诊费用记录 A
  Set 待转出 = n_批次
  Where (结帐金额 = 0 Or Exists
         (Select 1 From 门诊费用记录 C Where a.结帐id = c.结帐id Group By c.结帐id, c.No Having Sum(c.结帐金额) = 0)) And Not Exists
   (Select 1 From 病人预交记录 B Where a.结帐id = b.结帐id And b.待转出 Is Null) And 记录性质 = 1 And 结帐id Is Not Null And
        待转出 Is Null And 发生时间 < d_End;

  Update /*+ rule*/ 医保结算明细
  Set 待转出 = n_批次
  Where 结帐id In (Select 结帐id From 病人预交记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 费用补充记录
  Set 待转出 = n_批次
  Where 结算id In (Select 结帐id From 病人预交记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 凭条打印记录
  Set 待转出 = n_批次
  Where (NO, 记录性质) In (Select NO, 记录性质 From 门诊费用记录 Where 待转出 = n_批次);

  --1.从预交记录读是为了取就诊卡直接收费的（无结帐ID）,再加结帐记录是为了取结帐无结算（预交）记录的 
  Update /*+ rule*/ 住院费用记录
  Set 待转出 = n_批次
  Where 结帐id In
        (Select 结帐id From 病人预交记录 Where 待转出 = n_批次 Union Select ID From 病人结帐记录 Where 待转出 = n_批次);

  --2.没有结帐id的数据(按发生时间)
  --冲销产生的记帐记录（记录状态为2），原始记录和冲销记录的发生时间是相同的。
  --1)转出结帐作废后，记帐单销帐的记录（记录状态为2，且没有结帐ID，且(记录状态为3的有结帐ID的)在最前面已转出） 
  --2)未结帐的零费用(已冲销的记帐单或打折后实收金额为零) 
  --3)没有结帐ID的划价记录处理为转出
  Update /*+ rule*/ 住院费用记录 A
  Set 待转出 = n_批次
  Where ((Exists (Select 1
                  From 住院费用记录 B
                  Where a.No = b.No And a.记录性质 = b.记录性质 And a.序号 = b.序号 And b.记录状态 = 3 And b.结帐id Is Not Null And
                        b.待转出 + 0 = n_批次) And 记录状态 = 2 Or Exists
         (Select 1
           From 住院费用记录 B
           Where a.No = b.No And a.记录性质 = b.记录性质 And a.序号 = b.序号 And b.结帐id Is Null
           Group By b.No, b.记录性质, b.序号
           Having Nvl(Sum(b.实收金额), 0) = 0)) And a.记录性质 In (2, 3) Or a.记录状态 = 0) And a.结帐id Is Null And a.待转出 Is Null And
        a.发生时间 < d_End;

  --3.离院未结帐的（赖帐病人），因为是很久以前的这些数据，如果预交已冲完，则处理为要转出 
  Update /*+ rule*/ 住院费用记录 A
  Set 待转出 = n_批次
  Where 待转出 Is Null And 结帐id Is Null And
        (病人id, 主页id) In (Select 病人id, 主页id
                         From 病案主页 C
                         Where 出院日期 < d_End And 待转出 Is Null And 数据转出 Is Null And Not Exists
                          (Select 1
                                From 病人预交记录 B
                                Where b.病人id = c.病人id And b.待转出 Is Null And b.预交类别 = 2 And b.记录性质 In (1, 11) Having
                                 Nvl(Sum(b.金额), 0) <> Nvl(Sum(b.冲预交), 0)));

  Update /*+ rule*/ 费用清单打印
  Set 待转出 = n_批次
  Where (NO, Mod(记录性质, 10), Decode(记录状态, 3, 1, 记录状态), 序号) In
        (Select NO, Mod(记录性质, 10) As 记录性质, Decode(记录状态, 3, 1, 记录状态) As 记录状态, 序号
         From 门诊费用记录
         Where 待转出 = n_批次
         Union
         Select NO, Mod(记录性质, 10) As 记录性质, Decode(记录状态, 3, 1, 记录状态) As 记录状态, 序号
         From 住院费用记录
         Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(2/10)费用数据标记完成，正在标记药品数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  Update /*+ Rule*/ 药品收发记录 A
  Set 待转出 = n_批次
  Where Rowid In (Select m.Rowid
                  From 药品收发记录 M, 门诊费用记录 E
                  Where m.费用id = e.Id And (e.记录性质 = 1 And m.单据 In (8, 24) Or e.记录性质 = 2 And m.单据 In (9, 25)) And
                        e.收费类别 In ('4', '5', '6', '7') And e.待转出 = n_批次
                  Union All
                  Select m.Rowid
                  From 药品收发记录 M, 住院费用记录 E
                  Where m.费用id = e.Id And m.单据 In (9, 10, 25, 26) And e.记录性质 = 2 And e.收费类别 In ('4', '5', '6', '7') And
                        e.待转出 = n_批次);

  Update /*+ rule*/ 收发记录补充信息
  Set 待转出 = n_批次
  Where 收发id In (Select ID From 药品收发记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 输液配药内容
  Set 待转出 = n_批次
  Where 收发id In (Select ID From 药品收发记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 输液配药记录
  Set 待转出 = n_批次
  Where ID In (Select 记录id From 输液配药内容 Where 待转出 = n_批次);

  Update /*+ rule*/ 输液配药附费
  Set 待转出 = n_批次
  Where 配药id In (Select ID From 输液配药记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 输液配药状态
  Set 待转出 = n_批次
  Where 配药id In (Select ID From 输液配药记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 药品留存计划
  Set 待转出 = n_批次
  Where 留存id In (Select ID From 药品收发记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 药品签名明细
  Set 待转出 = n_批次
  Where 收发id In (Select ID From 药品收发记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 药品签名记录
  Set 待转出 = n_批次
  Where ID In (Select 签名id From 药品签名明细 Where 待转出 = n_批次);

  Update /*+ rule*/ 药品收发门诊标志 A
  Set 待转出 = n_批次
  Where (a.处方号, a.单据) In (Select b.No, b.单据 From 药品收发记录 B Where b.待转出 = n_批次);

  Update /*+ rule*/ 药品收发住院标志
  Set 待转出 = n_批次
  Where 收发id In (Select ID From 药品收发记录 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(3/10)药品数据标记完成，正在标记缴款与票据数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  Update /*+ rule*/ 人员借款记录 Set 待转出 = n_批次 Where 待转出 Is Null And 借出时间 < d_End;

  Update /*+ rule*/ 人员收缴记录 Set 待转出 = n_批次 Where 待转出 Is Null And 登记时间 < d_End;

  Update /*+ rule*/ 人员收缴对照
  Set 待转出 = n_批次
  Where 收缴id In (Select ID From 人员收缴记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 人员收缴明细
  Set 待转出 = n_批次
  Where 收缴id In (Select ID From 人员收缴记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 人员收缴票据
  Set 待转出 = n_批次
  Where 收缴id In (Select ID From 人员收缴记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 人员暂存记录
  Set 待转出 = n_批次
  Where 收缴id In (Select ID From 人员收缴记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 人员暂存记录 Set 待转出 = n_批次 Where 待转出 Is Null And 记录性质 = 1 And 登记时间 < d_End;

  Update /*+ rule*/ 票据领用记录 A
  Set 待转出 = n_批次
  Where Not Exists (Select 1 From 票据使用明细 B Where b.领用id = a.Id And b.使用时间 >= d_Lastend) And 待转出 Is Null And 剩余数量 = 0 And
        登记时间 < d_End;

  Update /*+ rule*/ 票据使用明细
  Set 待转出 = n_批次
  Where 领用id In (Select ID From 票据领用记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 票据打印内容
  Set 待转出 = n_批次
  Where ID In (Select 打印id From 票据使用明细 Where 待转出 = n_批次);

  Update /*+ rule*/ 票据打印明细
  Set 待转出 = n_批次
  Where 使用id In (Select ID From 票据使用明细 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(4/10)缴款与票据数据标记完成，正在标记就诊及诊治数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  --2.就诊及诊治数据 
  --不转出的条件：挂号费用未转出的，最终转出时间之后存在医嘱（这些医嘱因为时间没有到，不应转出），医嘱对应的费用未转出的 
  --即使正在就诊(r.执行状态 <> 2 )的也强制转出(医生可能没有使用完成就诊功能)
  Update /*+ rule*/ 病人挂号记录 T
  Set 待转出 = n_批次
  Where Rowid In
        (Select Rowid
         From 病人挂号记录 R
         Where Not Exists (Select 1 From 门诊费用记录 A Where r.No = a.No And a.记录性质 = 4 And a.待转出 Is Null) And Not Exists
          (Select 1
                From 病人医嘱记录 A
                Where a.挂号单 = r.No And a.待转出 Is Null And a.病人来源 <> 4 And Nvl(a.停嘱时间, a.开嘱时间) >= d_Lastend) And
               Not Exists (Select 1
                From 门诊费用记录 E, 病人医嘱记录 A
                Where r.No = a.挂号单 And a.Id = e.医嘱序号 And a.病人来源 <> 4 And e.待转出 Is Null) And
               r.待转出 Is Null And r.发生时间 < d_End);

  --由于有一部分挂号数据未转出，所以，汇总表的数据可能与挂号数据不匹配 
  Update 病人挂号汇总 Set 待转出 = n_批次 Where 待转出 Is Null And 日期 < d_End;
  Update /*+ rule*/ 病人转诊记录 Set 待转出 = n_批次 Where NO In (Select NO From 病人挂号记录 Where 待转出 = n_批次);

--通过"住院费用记录"来查询，而不是"病人结帐记录",因为离院未结的赖帐病人也转出了费用 
  --出院日期条件仍然需要，因为可能某次结帐转出了，但病人在最终转出截止时间之前并未出院(一次住院多次结帐)。 
  --通过指定索引方式进行特殊优化（缺省采用"病案主页IX_出院日期"索引的效率太低） 
  --不加"数据转出 is null"的条件，因为一次住院多次结帐时，如果跨不同的转出批次(转出截止时间)，该字段将会被更新多次。
  Update /*+ rule*/ 病案主页 P
  Set 待转出 = n_批次
  Where Not Exists
  (Select 1 From 住院费用记录 A Where a.病人id = p.病人id And a.主页id = p.主页id And a.待转出 Is Null) And 待转出 Is Null And
          出院日期 < d_Lastend And (病人id, 主页id) In (Select Distinct 病人id, 主页id From 住院费用记录 Where 待转出 = n_批次);

  --已出院，但没有费用的，也标记为转出，以便转出病历数据
  Update /*+ rule*/ 病案主页 P
  Set 待转出 = n_批次
  Where Not Exists (Select 1 From 住院费用记录 A Where a.病人id = p.病人id And a.主页id = p.主页id) And 待转出 Is Null And 数据转出 Is Null And
        出院日期 < d_End;

  Update /*+ rule*/ 病人过敏记录
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, ID
                         From 病人挂号记录
                         Where 待转出 = n_批次
                         Union All
                         Select 病人id, 主页id
                         From 病案主页
                         Where 待转出 = n_批次);

  Update /*+ rule*/ 病人诊断记录
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, ID
                         From 病人挂号记录
                         Where 待转出 = n_批次
                         Union All
                         Select 病人id, 主页id
                         From 病案主页
                         Where 待转出 = n_批次);

  Update /*+ rule*/ 病人手麻记录
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, ID
                         From 病人挂号记录
                         Where 待转出 = n_批次
                         Union All
                         Select 病人id, 主页id
                         From 病案主页
                         Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(5/10)就诊及诊治数据标记完成，正在标记护理数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  --3.护理数据 
  Update /*+ rule*/ 病人护理文件
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, 主页id From 病案主页 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人护理数据
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 病人护理文件 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人护理明细
  Set 待转出 = n_批次
  Where 记录id In (Select ID From 病人护理数据 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人护理打印
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 病人护理文件 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人护理活动项目
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 病人护理文件 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人护理要素内容
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 病人护理文件 Where 待转出 = n_批次);
  Update /*+ rule*/ 产程要素内容
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 病人护理文件 Where 待转出 = n_批次);

  --老版护理系统数据 
  Update /*+ rule*/ 病人护理记录
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, 主页id From 病案主页 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人护理内容
  Set 待转出 = n_批次
  Where 记录id In (Select ID From 病人护理记录 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(6/10)护理数据标记完成，正在标记病历数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  --4.病历数据 
  Update /*+ rule*/ 电子病历记录
  Set 待转出 = n_批次
  Where 病人来源 <> 4 And (病人id, 主页id) In (Select 病人id, ID
                                       From 病人挂号记录
                                       Where 待转出 = n_批次
                                       Union All
                                       Select 病人id, 主页id
                                       From 病案主页
                                       Where 待转出 = n_批次);

  --自登记类病人(无挂号单号) 
  --病历ID可能重复是因为检验报告之类的，如肝功、肾功共打一张报告，即在病人医嘱报告表中，多个医嘱id对应同一报告ID 
  --为提升性能，不从医嘱发送记录的发送时间查询，不采用精确的时间，因为直接登记的检验医嘱，一般开嘱时间与发送时间相差不大
  Update /*+ rule*/ 电子病历记录
  Set 待转出 = n_批次
  Where ID In (Select c.病历id
               From 病人医嘱记录 B, 病人医嘱报告 C
               Where c.医嘱id = b.Id And Nvl(b.主页id,0) = 0 And b.挂号单 Is Null And
                     b.相关id Is Null And b.待转出 Is Null And b.开嘱时间 < d_End);

  Update /*+ rule*/ 电子病历附件
  Set 待转出 = n_批次
  Where 病历id In (Select ID From 电子病历记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 电子病历格式
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 电子病历记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 电子病历内容
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 电子病历记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 电子病历图形
  Set 待转出 = n_批次
  Where 对象id In (Select ID From 电子病历内容 Where 待转出 = n_批次 And 对象类型 = 5);

  Update /*+ rule*/ 病人医嘱报告
  Set 待转出 = n_批次
  Where 病历id In (Select ID From 电子病历记录 Where 病历种类 = 7 And 待转出 = n_批次);
  Update /*+ rule*/ 影像报告驳回
  Set 待转出 = n_批次
  Where (医嘱id, 病历id) In (Select 医嘱id, 病历id From 病人医嘱报告 Where 待转出 = n_批次);

  Update /*+ rule*/ 报告查阅记录
  Set 待转出 = n_批次
  Where 病历id In (Select ID From 电子病历记录 Where 病历种类 = 7 And 待转出 = n_批次);

  Update /*+ rule*/ 疾病申报记录
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 电子病历记录 Where 病历种类 = 5 And 待转出 = n_批次);

  Update /*+ rule*/ 疾病报告反馈
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 电子病历记录 Where 病历种类 = 5 And 待转出 = n_批次);

  Update /*+ rule*/ 疾病申报反馈
  Set 待转出 = n_批次
  Where 申报id In (Select ID From 电子病历记录 Where 病历种类 = 5 And 待转出 = n_批次);

  Update /*+ rule*/ 病人诊断记录
  Set 待转出 = n_批次
  Where 病历id In (Select ID From 电子病历记录 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(7/10)病历数据标记完成，正在标记临床路径数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  --5.临床路径 
  Update /*+ rule*/ 病人临床路径
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, 主页id From 病案主页 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人合并路径
  Set 待转出 = n_批次
  Where 首要路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人合并路径评估
  Set 待转出 = n_批次
  Where 路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人出径记录
  Set 待转出 = n_批次
  Where 路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人路径执行
  Set 待转出 = n_批次
  Where 路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人路径评估
  Set 待转出 = n_批次
  Where 路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人路径变异
  Set 待转出 = n_批次
  Where 路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人路径指标
  Set 待转出 = n_批次
  Where 路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人路径医嘱
  Set 待转出 = n_批次
  Where 路径执行id In (Select ID From 病人路径执行 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(8/10)临床路径数据标记完成，正在标记医嘱数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  --6.医嘱，检验，检查 
  Update /*+ rule*/ 病人医嘱记录
  Set 待转出 = n_批次
  Where 挂号单 In (Select NO From 病人挂号记录 Where 待转出 = n_批次) And 病人来源 <> 4;
  Update /*+ rule*/ 病人医嘱记录
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, 主页id From 病案主页 Where 待转出 = n_批次);

  --自登记类病人(无挂号单)，病人医嘱报告在前面转病历时已转出 
  Update /*+ rule*/ 病人医嘱记录
  Set 待转出 = n_批次
  Where Rowid In (Select b.Rowid
                  From 病人医嘱记录 B, 病人医嘱报告 C
                  Where (b.相关id = c.医嘱id Or b.Id = c.医嘱id) And c.待转出 = n_批次);
  
  --自登记类病人(无挂号单)，没有医嘱报告
  Update /*+ rule*/ 病人医嘱记录 A
  Set 待转出 = n_批次
  Where Not Exists (Select 1 From 病人医嘱报告 B Where a.Id = b.医嘱id) And Not Exists
     (Select 1 From 病人医嘱报告 B Where a.相关id = b.医嘱id) And 挂号单 Is Null And 病人来源 = 3 And 待转出 Is Null And 开嘱时间 < d_End;

  Update /*+ rule*/ 病人医嘱计价
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人医嘱附费
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人医嘱附件
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 输血申请记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 输血检验结果
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人医嘱执行
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人医嘱打印
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 医嘱执行打印
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人诊断医嘱
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人诊断记录
  Set 待转出 = n_批次
  Where ID In (Select 诊断id From 病人诊断医嘱 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人医嘱状态
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 医嘱签名记录
  Set 待转出 = n_批次
  Where ID In (Select 签名id From 病人医嘱状态 Where 待转出 = n_批次 And 签名id Is Not Null);

  Update /*+ rule*/ 病人医嘱发送
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 诊疗单据打印
  Set 待转出 = n_批次
  Where (NO, 记录性质) In (Select NO, 记录性质 From 病人医嘱发送 Where 待转出 = n_批次);

  Update /*+ rule*/ 医嘱执行时间
  Set 待转出 = n_批次
  Where (医嘱id, 发送号) In (Select 医嘱id, 发送号 From 病人医嘱发送 Where 待转出 = n_批次);

  Update /*+ rule*/ 医嘱执行计价
  Set 待转出 = n_批次
  Where (医嘱id, 发送号) In (Select 医嘱id, 发送号 From 病人医嘱发送 Where 待转出 = n_批次);

  Update /*+ rule*/ 执行打印记录
  Set 待转出 = n_批次
  Where (医嘱id, 发送号) In (Select 医嘱id, 发送号 From 病人医嘱发送 Where 待转出 = n_批次);

  Update /*+ rule*/ 处方审查明细
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 处方审查记录
  Set 待转出 = n_批次
  Where ID In (Select 审方id From 处方审查明细 Where 待转出 = n_批次);

  Update /*+ rule*/ 处方审查结果
  Set 待转出 = n_批次
  Where 审方id In (Select ID From 处方审查记录 Where 待转出 = n_批次);

  Update /*+ rule*/ Ris检查预约
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 疾病阳性记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(9/10)医嘱数据标记完成，正在标记检查检验数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  Update /*+ rule*/ 影像检查记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 影像报告记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 影像报告操作记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 影像检查序列
  Set 待转出 = n_批次
  Where 检查uid In (Select 检查uid From 影像检查记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 影像检查图象
  Set 待转出 = n_批次
  Where 序列uid In (Select 序列uid From 影像检查序列 Where 待转出 = n_批次);

  Update /*+ rule*/ 影像申请单图像
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 影像收藏内容
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 影像危急值记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(10/10)影像数据标记完成，正在标记检验数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  Update /*+ rule*/ 检验标本记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验申请项目
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验项目分布
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验分析记录
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验质控记录
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 检验操作记录
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 检验签名记录
  Set 待转出 = n_批次
  Where 检验标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 检验图像结果
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 检验试剂记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验拒收记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 检验普通结果
  Set 待转出 = n_批次
  Where 检验标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验质控报告
  Set 待转出 = n_批次
  Where 结果id In (Select ID From 检验普通结果 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验药敏结果
  Set 待转出 = n_批次
  Where 细菌结果id In (Select ID From 检验普通结果 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验流水线标本
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验流水线指标
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);

  Commit;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl1_Datamove_Tag;
/

--104476:张永康,2017-01-05,更正预交款的抽回遗漏
Create Or Replace Procedure Zl_Retu_Exes
(
  v_No   In Varchar2,
  n_Type In Number
) As
  --------------------------------------------
  --参数:v_No,单据号码
  --     n_Type,单据类型:1-收费,2-记帐,3-自动记帐,4-挂号,5-就诊卡,6-预交,7-结帐,8-未结费用的病人id,主页ID
  --------------------------------------------
  n_Allow  Number(1); --是否能够单据返回
  n_Patiid Number(18);
  n_Pageid Number(5);
  Err_Item Exception;
  v_Err_Msg Varchar2(100);
  n_System  Number(5);
  n_只读    Number(2);

  v_Table  Varchar2(100);
  v_Field  Varchar2(100);
  v_Sql    Varchar2(4000);
  v_Fields Varchar2(4000);

  --功能：获取表的字段字符串
  Function Getfields(v_Table In Varchar2) Return Varchar2 As
    v_Colstr Varchar2(4000);
  Begin
    Select f_List2str(Cast(Collect(Column_Name) As t_Strlist)) As Colsstr
    Into v_Colstr
    From (Select Column_Name From User_Tab_Columns Where Table_Name = v_Table Order By Column_Id);
  
    Return v_Colstr;
  End Getfields;

  --------------------------------------------
  --返回指定ID的病人预交记录子过程
  --------------------------------------------
  Procedure Zl_Retu_Prepay(n_Settle_Id H病人预交记录.结帐id%Type) As
  Begin
    For r_Rec In (Select * From H病人预交记录 Where 结帐id = n_Settle_Id) Loop
      v_Table  := '病人卡结算对照';
      v_Fields := Getfields(v_Table);
      v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                  Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table || ' Where 预交id = :1';
      Execute Immediate v_Sql
        Using r_Rec.Id;
    
      v_Table  := '三方结算交易';
      v_Fields := Getfields(v_Table);
      v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                  Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table || ' Where 交易ID = :1';
      Execute Immediate v_Sql
        Using r_Rec.Id;
    
      v_Table  := '三方退款信息';
      v_Fields := Getfields(v_Table);
      v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                  Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table || ' Where 记录ID = :1 And 结帐ID = :2';
      Execute Immediate v_Sql
        Using r_Rec.Id, n_Settle_Id;
    
      v_Table  := '病人卡结算记录';
      v_Fields := Getfields(v_Table);
      v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                  Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table ||
                  ' Where ID In(Select 卡结算id From H病人卡结算对照 Where 预交id = :1)';
      Execute Immediate v_Sql
        Using r_Rec.Id;
    
      Delete H病人卡结算记录 Where ID In (Select Distinct 卡结算id From H病人卡结算对照 Where 预交id = r_Rec.Id);
      Delete From H病人卡结算对照 Where 预交id = r_Rec.Id;
      Delete From H三方结算交易 Where 交易id = r_Rec.Id;
      Delete From H三方退款信息 Where 记录id = r_Rec.Id And 结帐id = n_Settle_Id;
    End Loop;
  
    v_Table  := '病人预交记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                ' From H' || v_Table || ' Where 结帐id = :1';
    Execute Immediate v_Sql
      Using n_Settle_Id;
  
    Delete H病人预交记录 Where 结帐id = n_Settle_Id;
  End Zl_Retu_Prepay;

  --------------------------------------------
  --返回指定ID的病人费用记录子过程
  --------------------------------------------
  Procedure Zl_Retu_Fee(n_Settle_Id H住院费用记录.结帐id%Type) As
  Begin
    --返回病人费用记录
    v_Table  := '住院费用记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                ' From H' || v_Table || ' Where 结帐id = :1';
    Execute Immediate v_Sql
      Using n_Settle_Id;
  
    v_Table  := '门诊费用记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                ' From H' || v_Table || ' Where 结帐id = :1';
    Execute Immediate v_Sql
      Using n_Settle_Id;
  
    v_Table  := '费用补充记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                ' From H' || v_Table || ' Where 结算id = :1';
    Execute Immediate v_Sql
      Using n_Settle_Id;
  
    v_Table  := '医保结算明细';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                ' From H' || v_Table || ' Where 结帐id = :1';
    Execute Immediate v_Sql
      Using n_Settle_Id;
  
    --删除已返回的费用记录
    Delete H门诊费用记录 Where 结帐id = n_Settle_Id;
    Delete H住院费用记录 Where 结帐id = n_Settle_Id;
    Delete H费用补充记录 Where 结算id = n_Settle_Id;
    Delete H医保结算明细 Where 结帐id = n_Settle_Id;
  End Zl_Retu_Fee;

  --------------------------------------------
  --返回指定ID的药品收发记录子过程
  --------------------------------------------
  Procedure Zl_Retu_Medilist(n_Rec_Id H药品收发记录.Id%Type) As
  Begin
    --按外键引用顺序返回药品收发相关表的数据     
    v_Table  := '药品收发记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                ' From H' || v_Table || ' Where ID = :1';
    Execute Immediate v_Sql
      Using n_Rec_Id;
  
    v_Table  := '输液配药记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                ' From H' || v_Table || ' Where ID In(Select 记录ID From H输液配药内容 Where 收发ID =:1)';
    Execute Immediate v_Sql
      Using n_Rec_Id;
  
    For P In (Select ID From H输液配药记录 Where ID In (Select 记录id From H输液配药内容 Where 收发id = n_Rec_Id)) Loop
      For R In (Select Column_Value From Table(f_Str2list('输液配药附费,输液配药状态'))) Loop
        v_Table := r.Column_Value;
        v_Field := 'ID';
      
        v_Fields := Getfields(v_Table);
        v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                    Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table || ' Where ' || v_Field || ' = :1';
        Execute Immediate v_Sql
          Using p.Id;
      
        v_Sql := 'Delete H' || v_Table || ' Where ' || v_Field || ' = :1';
        Execute Immediate v_Sql
          Using p.Id;
      End Loop;
    End Loop;
  
    Delete H输液配药记录 Where ID In (Select 记录id From H输液配药内容 Where 收发id = n_Rec_Id);
  
    v_Table  := '药品签名记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                ' From H' || v_Table || ' Where ID In(Select 签名ID From H药品签名明细 Where 收发ID =:1)';
    Execute Immediate v_Sql
      Using n_Rec_Id;
    Delete H药品签名记录 Where ID In (Select 签名id From H药品签名明细 Where 收发id = n_Rec_Id);
  
    For R In (Select Column_Value From Table(f_Str2list('收发记录补充信息,输液配药内容,药品签名明细,药品留存计划'))) Loop
      v_Table := r.Column_Value;
      If v_Table = '药品留存计划' Then
        v_Field := '留存ID';
      Else
        v_Field := '收发ID';
      End If;
    
      v_Fields := Getfields(v_Table);
      v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                  Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table || ' Where ' || v_Field || ' = :1';
      Execute Immediate v_Sql
        Using n_Rec_Id;
    
      v_Sql := 'Delete From H' || v_Table || ' Where ' || v_Field || ' = :1';
      Execute Immediate v_Sql
        Using n_Rec_Id;
    End Loop;
  
    --删除已返回的药品收发记录
    Delete H药品收发记录 Where ID = n_Rec_Id;
  End Zl_Retu_Medilist;

  --------------------------------------------
  --以下为主程序体
  --------------------------------------------
Begin
  ----------------------------------------------------------------------------------------------------------
  --刘兴宏:主要是对基于视图的视图的转储方案进行了只读判断.
  Select 编号 Into n_System From zlSystems Where Upper(所有者) = Zl_Owner And 编号 Like '1%';
  Begin
    Select Nvl(只读, 0) Into n_只读 From zlBakSpaces Where 系统 = n_System And 当前 = 1;
  Exception
    When Others Then
      v_Err_Msg := '[ZLSOFT]当前没有可用的历史数据空间,不能继续![ZLSOFT]';
      Raise Err_Item;
  End;
  If n_只读 = 1 Then
    v_Err_Msg := '[ZLSOFT]历史数据空间目前的状态为只读,不能继续![ZLSOFT]';
    Raise Err_Item;
  End If;

  If n_Type = 8 Then
    --8-抽回指定病人的未结记帐费用
    --排除：结帐作废后，记帐单销帐的记录（记录状态为2的没有结帐ID，记录状态为3的有结帐ID的) 
    If Instr(v_No, ',') = 0 Then
      --a.按病人ID抽回门诊病人的未结记帐费用
      For Rno In (Select NO, 记录性质
                  From H门诊费用记录 A
                  Where 病人id = To_Number(v_No) And a.记帐费用 = 1 And 结帐id Is Null And Not Exists
                   (Select 1
                         From H门诊费用记录 B
                         Where a.No = b.No And a.记录性质 = b.记录性质 And a.序号 = b.序号 And b.记录状态 = 3 And b.结帐id Is Not Null)) Loop
        v_Table  := '门诊费用记录';
        v_Fields := Getfields(v_Table);
        v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                    Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table || ' Where NO = :1 And 记录性质 = :2';
        Execute Immediate v_Sql
          Using Rno.No, Rno.记录性质;
      
        For r_Rxlist In (Select m.Id
                         From H药品收发记录 M, H门诊费用记录 E
                         Where e.No = Rno.No And e.记录性质 = Rno.记录性质 And e.收费类别 In ('4', '5', '6', '7') And m.费用id = e.Id And
                               m.单据 In (9, 10, 25, 26)) Loop
          Zl_Retu_Medilist(r_Rxlist.Id);
        End Loop;
        Delete H门诊费用记录 Where NO = Rno.No And 记录性质 = Rno.记录性质;
      End Loop;
    Else
      --b.按病人ID,主页ID抽回住院病人的未结记帐费用
      n_Patiid := Substr(v_No, 1, Instr(v_No, ',') - 1);
      n_Pageid := Substr(v_No, Instr(v_No, ',') + 1);
    
      For Rno In (Select NO, 记录性质
                  From H住院费用记录 A
                  Where 病人id = n_Patiid And 主页id = n_Pageid And a.记帐费用 = 1 And 结帐id Is Null And Not Exists
                   (Select 1
                         From H住院费用记录 B
                         Where a.No = b.No And a.记录性质 = b.记录性质 And a.序号 = b.序号 And b.记录状态 = 3 And b.结帐id Is Not Null)) Loop
        v_Table  := '住院费用记录';
        v_Fields := Getfields(v_Table);
        v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                    Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table || ' Where NO = :1 And 记录性质 = :2';
        Execute Immediate v_Sql
          Using Rno.No, Rno.记录性质;
      
        For r_Rxlist In (Select m.Id
                         From H药品收发记录 M, H住院费用记录 E
                         Where e.No = Rno.No And e.记录性质 = Rno.记录性质 And e.收费类别 In ('4', '5', '6', '7') And m.费用id = e.Id And
                               m.单据 In (9, 10, 25, 26)) Loop
          Zl_Retu_Medilist(r_Rxlist.Id);
        End Loop;
        Delete H住院费用记录 Where NO = Rno.No And 记录性质 = Rno.记录性质;
      End Loop;
    End If;
  Else
    --判断是否能按照单据返回（预交冲完，费用结清）
    Select Decode(Nvl(Sum(p.金额), 0) - Nvl(Sum(p.冲预交), 0), Null, 1, 0, 1, 0)
    Into n_Allow
    From H病人预交记录 P,
         (Select 结帐id
           From H门诊费用记录
           Where NO = v_No And (1 = n_Type And 记录性质 = 1 Or 2 = n_Type And 记录性质 = 2 Or 3 = n_Type And 记录性质 = 3 Or
                 4 = n_Type And 记录性质 = 4 Or 5 = n_Type And 记录性质 = 5)
           Union
           Select 结帐id
           From H住院费用记录
           Where NO = v_No And (1 = n_Type And 记录性质 = 1 Or 2 = n_Type And 记录性质 = 2 Or 3 = n_Type And 记录性质 = 3 Or
                 4 = n_Type And 记录性质 = 4 Or 5 = n_Type And 记录性质 = 5)
           Union
           Select 结帐id
           From H病人预交记录
           Where NO = v_No And 6 = n_Type And 记录性质 In (1, 11)
           Union
           Select ID
           From H病人结帐记录
           Where NO = v_No And 7 = n_Type) L
    Where p.结帐id = l.结帐id And p.记录性质 In (1, 11);
    If n_Allow = 1 Then
      Select Decode(Nvl(Sum(e.实收金额), 0) - Nvl(Sum(e.结帐金额), 0), Null, 1, 0, 1, 0)
      Into n_Allow
      From (Select e.实收金额, e.结帐金额
             From H门诊费用记录 E,
                  (Select 结帐id
                    From H门诊费用记录
                    Where NO = v_No And (1 = n_Type And 记录性质 = 1 Or 2 = n_Type And 记录性质 = 2 Or 3 = n_Type And 记录性质 = 3 Or
                          4 = n_Type And 记录性质 = 4 Or 5 = n_Type And 记录性质 = 5)
                    Union
                    Select 结帐id
                    From H病人预交记录
                    Where NO = v_No And 6 = n_Type And 记录性质 In (1, 11)
                    Union
                    Select ID
                    From H病人结帐记录
                    Where NO = v_No And 7 = n_Type) L
             Where e.结帐id = l.结帐id
             Union All
             Select e.实收金额, e.结帐金额
             From H住院费用记录 E,
                  (Select 结帐id
                    From H住院费用记录
                    Where NO = v_No And (1 = n_Type And 记录性质 = 1 Or 2 = n_Type And 记录性质 = 2 Or 3 = n_Type And 记录性质 = 3 Or
                          4 = n_Type And 记录性质 = 4 Or 5 = n_Type And 记录性质 = 5)
                    Union
                    Select 结帐id
                    From H病人预交记录
                    Where NO = v_No And 6 = n_Type And 记录性质 In (1, 11)
                    Union
                    Select ID
                    From H病人结帐记录
                    Where NO = v_No And 7 = n_Type) L
             Where e.结帐id = l.结帐id) E;
    End If;
  
    --1.按照单据获取结帐相关数据抽回
    If n_Allow = 1 Then
      If n_Type = 6 And v_No Is Not Null Then
        --抽回病人所有的结帐ID为空的交预交款的数据,三种：
        --a.预交款没有使用就直接退了的记录
        --b.交预交款后退款的记录(使用后又退费或结帐作废，再退预交)
        --c.预交款未用完时用交负数预交来退款(跟原始的冲预交的NO没有关联关系)
        v_Table  := '病人预交记录';
        v_Fields := Getfields(v_Table);
        v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                    Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table ||
                    ' Where 结帐id is Null And 记录性质 = 1 And NO = :1';
        Execute Immediate v_Sql
          Using v_No;
      
        Delete H病人预交记录 Where 结帐id Is Null And 记录性质 = 1 And NO = v_No;
      End If;
    
      For r_Settle In (Select 结帐id
                       From H门诊费用记录
                       Where NO = v_No And
                             (1 = n_Type And 记录性质 = 1 Or 2 = n_Type And 记录性质 = 2 Or 3 = n_Type And 记录性质 = 3 Or
                             4 = n_Type And 记录性质 = 4 Or 5 = n_Type And 记录性质 = 5)
                       Union
                       Select 结帐id
                       From H住院费用记录
                       Where NO = v_No And
                             (1 = n_Type And 记录性质 = 1 Or 2 = n_Type And 记录性质 = 2 Or 3 = n_Type And 记录性质 = 3 Or
                             4 = n_Type And 记录性质 = 4 Or 5 = n_Type And 记录性质 = 5)
                       Union
                       Select 结帐id
                       From H病人预交记录
                       Where NO = v_No And 6 = n_Type And 记录性质 In (1, 11)
                       Union All
                       Select ID
                       From H病人结帐记录
                       Where NO = v_No And 7 = n_Type) Loop
      
        v_Table  := '病人结帐记录';
        v_Fields := Getfields(v_Table);
        v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                    Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table || ' Where id = :1';
        Execute Immediate v_Sql
          Using r_Settle.结帐id;
      
        Zl_Retu_Prepay(r_Settle.结帐id);
        For r_Rxlist In (Select m.Id
                         From H药品收发记录 M,
                              (Select ID, 记录性质
                                From H门诊费用记录
                                Where 结帐id = r_Settle.结帐id And 收费类别 In ('4', '5', '6', '7') And 记录性质 In (1, 2)) E
                         Where m.费用id = e.Id And (e.记录性质 = 1 And m.单据 In (8, 24) Or e.记录性质 = 2 And m.单据 In (9, 25))
                         Union All
                         Select m.Id
                         From H药品收发记录 M,
                              (Select ID
                                From H住院费用记录
                                Where 结帐id = r_Settle.结帐id And 收费类别 In ('4', '5', '6', '7') And 记录性质 = 2) E
                         Where m.费用id = e.Id And m.单据 In (9, 10, 25, 26)) Loop
          Zl_Retu_Medilist(r_Rxlist.Id);
        End Loop;
      
        --费用清单打印
        For r_Feeprint In (Select NO, Mod(记录性质, 10) As 记录性质, Decode(记录状态, 3, 1, 记录状态) As 记录状态, 序号
                           From H门诊费用记录
                           Where 结帐id = r_Settle.结帐id
                           Union
                           Select NO, Mod(记录性质, 10) As 记录性质, Decode(记录状态, 3, 1, 记录状态) As 记录状态, 序号
                           From H住院费用记录
                           Where 结帐id = r_Settle.结帐id) Loop
        
          v_Table  := '费用清单打印';
          v_Fields := Getfields(v_Table);
          v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                      Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table ||
                      ' Where NO = :1 And Mod(记录性质,10) = :2 And Decode(记录状态,3,1,记录状态) = :3 And 序号 = :4';
          Execute Immediate v_Sql
            Using r_Feeprint.No, r_Feeprint.记录性质, r_Feeprint.记录状态, r_Feeprint.序号;
          Delete H费用清单打印
          Where NO = r_Feeprint.No And Mod(记录性质, 10) = r_Feeprint.记录性质 And Decode(记录状态, 3, 1, 记录状态) = r_Feeprint.记录状态 And
                序号 = r_Feeprint.序号;
        End Loop;
      
        Zl_Retu_Fee(r_Settle.结帐id);
      
        Delete H病人结帐记录 Where ID = r_Settle.结帐id;
      End Loop;
    Else
      --2.按照病人获取结帐相关数据抽回
      Begin
        --n_Type,单据类型:1-收费,2-记帐,3-自动记帐,4-挂号,5-就诊卡,6-预交,7-结帐
        If n_Type = 7 Then
          Select Distinct 病人id Into n_Patiid From H病人结帐记录 Where NO = v_No;
        Elsif n_Type = 6 Then
          Select Distinct 病人id Into n_Patiid From H病人预交记录 Where NO = v_No And 记录性质 In (1, 11);
        Elsif n_Type = 5 Or n_Type = 3 Then
          Select Distinct 病人id
          Into n_Patiid
          From H住院费用记录
          Where NO = v_No And (3 = n_Type And 记录性质 = 3 Or 5 = n_Type And 记录性质 = 5);
        Elsif n_Type = 4 Or n_Type = 1 Then
          If n_Type = 1 Then
            Select Distinct 病人id
            Into n_Patiid
            From (Select Distinct 病人id
                   From H门诊费用记录
                   Where NO = v_No And 记录性质 = 1
                   Union All
                   Select Distinct 病人id
                   From H费用补充记录
                   Where NO = v_No And 记录性质 = 1)
            Where Rownum < 2;
          Else
            Select Distinct 病人id Into n_Patiid From H门诊费用记录 Where NO = v_No And 记录性质 = 4;
          End If;
        Else
          Begin
            Select Distinct 病人id
            Into n_Patiid
            From H住院费用记录
            Where NO = v_No And (1 = n_Type And 记录性质 = 1 Or 2 = n_Type And 记录性质 = 2 Or 3 = n_Type And 记录性质 = 3 Or
                  4 = n_Type And 记录性质 = 4 Or 5 = n_Type And 记录性质 = 5);
          Exception
            When Others Then
              n_Patiid := -1;
          End;
          If Nvl(n_Patiid, 0) <= 0 Then
            Select Distinct 病人id
            Into n_Patiid
            From H门诊费用记录
            Where NO = v_No And (1 = n_Type And 记录性质 = 1 Or 2 = n_Type And 记录性质 = 2 Or 3 = n_Type And 记录性质 = 3 Or
                  4 = n_Type And 记录性质 = 4 Or 5 = n_Type And 记录性质 = 5);
          End If;
        End If;
      Exception
        When Others Then
          n_Patiid := Null;
      End Zl_Patiid;
    
      If n_Type = 6 And n_Patiid Is Not Null Then
        --抽回病人所有的结帐ID为空的交预交款的数据,三种：
        --a.预交款没有使用就直接退了的记录
        --b.交预交款后退款的记录(使用后又退费或结帐作废，再退预交)
        --c.预交款未用完时用交负数预交来退款(跟原始的冲预交的NO没有关联关系)
        v_Table  := '病人预交记录';
        v_Fields := Getfields(v_Table);
        v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                    Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table ||
                    ' Where 结帐id is Null And 记录性质 = 1 And 病人ID = :1';
        Execute Immediate v_Sql
          Using n_Patiid;
      
        Delete H病人预交记录 Where 结帐id Is Null And 记录性质 = 1 And 病人id = n_Patiid;
      End If;
    
      For r_Settle In (Select Distinct 结帐id
                       From (Select Distinct 结帐id
                              From H门诊费用记录
                              Where 病人id = n_Patiid
                              Union All
                              Select Distinct 结帐id
                              From H住院费用记录
                              Where 病人id = n_Patiid
                              Union All
                              Select Distinct 结帐id
                              From H病人预交记录
                              Where 病人id = n_Patiid
                              Union All
                              Select Distinct 结算id
                              From H费用补充记录
                              Where 病人id = n_Patiid)
                       Where 结帐id Is Not Null) Loop
      
        v_Table  := '病人结帐记录';
        v_Fields := Getfields(v_Table);
        v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                    Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table || ' Where id = :1';
        Execute Immediate v_Sql
          Using r_Settle.结帐id;
      
        Zl_Retu_Prepay(r_Settle.结帐id);
        For r_Rxlist In (Select m.Id
                         From H药品收发记录 M,
                              (Select ID, 记录性质
                                From H门诊费用记录
                                Where 结帐id = r_Settle.结帐id And 收费类别 In ('4', '5', '6', '7') And 记录性质 In (1, 2)) E
                         Where m.费用id = e.Id And (e.记录性质 = 1 And m.单据 In (8, 24) Or e.记录性质 = 2 And m.单据 In (9, 25))
                         Union All
                         Select m.Id
                         From H药品收发记录 M,
                              (Select ID
                                From H住院费用记录
                                Where 结帐id = r_Settle.结帐id And 收费类别 In ('4', '5', '6', '7') And 记录性质 = 2) E
                         Where m.费用id = e.Id And m.单据 In (9, 10, 25, 26)) Loop
          Zl_Retu_Medilist(r_Rxlist.Id);
        End Loop;
      
        --费用清单打印
        For r_Feeprint In (Select NO, Mod(记录性质, 10) As 记录性质, Decode(记录状态, 3, 1, 记录状态) As 记录状态, 序号
                           From H门诊费用记录
                           Where 结帐id = r_Settle.结帐id
                           Union
                           Select NO, Mod(记录性质, 10) As 记录性质, Decode(记录状态, 3, 1, 记录状态) As 记录状态, 序号
                           From H住院费用记录
                           Where 结帐id = r_Settle.结帐id) Loop
        
          v_Table  := '费用清单打印';
          v_Fields := Getfields(v_Table);
          v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                      Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table ||
                      ' Where NO = :1 And Mod(记录性质,10) = :2 And Decode(记录状态,3,1,记录状态) = :3 And 序号 = :4';
          Execute Immediate v_Sql
            Using r_Feeprint.No, r_Feeprint.记录性质, r_Feeprint.记录状态, r_Feeprint.序号;
          Delete H费用清单打印
          Where NO = r_Feeprint.No And Mod(记录性质, 10) = r_Feeprint.记录性质 And Decode(记录状态, 3, 1, 记录状态) = r_Feeprint.记录状态 And
                序号 = r_Feeprint.序号;
        End Loop;
      
        Zl_Retu_Fee(r_Settle.结帐id);
        Delete H病人结帐记录 Where ID = r_Settle.结帐id;
      
      End Loop;
    End If;
  End If;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM || ':' || v_Sql);
End Zl_Retu_Exes;
/



--103873:廖思奇,2016-12-19,增加字符串参数长度
Create Or Replace Procedure Zl_病理制片_接受
(
  病理医嘱id_In 病理取材信息.病理医嘱id%Type,
  制片人_In     病理制片信息.制片人%Type
) Is
  v_Maxno    病理玻片信息.条码号%Type;
  v_Patholno 病理检查信息.病理号%Type;
  n_Index    Number;

  --需要使用该游标对查询的制片id进行排序，以便后面生成条码好事，相同制片id的条码号能够连续 
  Cursor c_Temp_Table Is
    Select ID As 来源id, 材块id, b.病理医嘱id, c.病理号
    From (Select Rownum As Num From Dual T Connect By Level < 1000) A, 病理制片信息 B, 病理检查信息 C
    Where a.Num <= b.制片数 And b.病理医嘱id = c.病理医嘱id And b.当前状态 = 0 And b.病理医嘱id = 病理医嘱id_In
    Order By b.Id;
Begin

  --更新申请状态（0-已申请，1-已接受，2-已完成） 
  Update 病理申请信息
  Set 申请状态 = 1
  Where 申请id In
        (Select Distinct 申请id From 病理制片信息 Where 病理医嘱id = 病理医嘱id_In And 当前状态 = 0 And 申请id > 0) And 申请状态 = 0;

  --修改检查的制片过程 
  Update 病理检查信息 Set 制片过程 = 2 Where 病理医嘱id = 病理医嘱id_In And 制片过程 = 1;

  --写入玻片信息 
  Select Nvl(Max(条码号), 0) Into v_Maxno From 病理玻片信息 Where 病理医嘱id = 病理医嘱id_In;
  Select 病理号 Into v_Patholno From 病理检查信息 Where 病理医嘱id = 病理医嘱id_In;

  v_Maxno := To_Number(Replace('000000' || To_Char(v_Maxno), '000000' || To_Char(v_Patholno), ''));

  n_Index := 1;
  For r_Row In c_Temp_Table Loop
    Insert Into 病理玻片信息
      (ID, 来源id, 来源类型, 材块id, 病理医嘱id, 条码号, 归档状态)
    Values
      (病理玻片信息_Id.Nextval, r_Row.来源id, 0, r_Row.材块id, r_Row.病理医嘱id,
       r_Row.病理号 || LPad(To_Number(v_Maxno) + n_Index, 3, 0), 0);
  
    n_Index := n_Index + 1;
  End Loop;

  --更新制片状态(为处理的制片才能接受) 
  Update 病理制片信息
  Set 当前状态 = 1, 制片人 = 制片人_In
  Where 材块id In (Select 材块id From 病理取材信息 Where 病理医嘱id = 病理医嘱id_In And 确认状态 = 1) And 当前状态 = 0;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病理制片_接受;
/

--104091:张险华,2012-12-19,数字签名变更为电子签名
Create Or Replace Procedure Zl_病人信息_基本信息调整_病历
(
  病人id_In 病人信息.病人id%Type,
  就诊id_In Number,
  姓名_In   病人信息.姓名%Type,
  性别_In   病人信息.性别%Type,
  年龄_In   病人信息.年龄%Type,
  场合_In   Number, --1-门诊;2-住院 
  说明_Out  Out Varchar2
) As
  Err_Custom Exception;
  v_Error Varchar2(2000);
Begin

  --以要素方式存储的姓名、性别、年龄 
  For r_Rec In (Select /*+ RULE */
                Distinct d.名称 科室, a.Id, a.病历名称, a.病历种类, a.完成时间, a.保存人,
                         Nvl((Select Decode(a.编辑方式, 0, Decode(Substr(b.对象属性, 1, 1), '2', 1, 0),
                                             Decode(Substr(b.对象属性, Instr(b.对象属性, '|'), 1), '2', 1, 0))
                              From 电子病历内容 B
                              Where a.Id = b.文件id And
                                    ((b.对象类型 = 8 And a.编辑方式 = 0) Or (b.对象类型 In (6, 7, 8) And a.编辑方式 = 1)) And Rownum < 2),
                              0) As 电子签名
                From 电子病历记录 A, 部门表 D
                Where a.病人id = 病人id_In And a.主页id = 就诊id_In And a.科室id = d.Id And Exists
                 (Select 1 --包含 
                       From 电子病历内容 C
                       Where a.Id = c.文件id And ((c.对象类型 = 4 And c.要素名称 = '姓名') Or (c.对象类型 = 4 And c.要素名称 = '性别') Or
                             (c.对象类型 = 4 And c.要素名称 = '年龄') Or (c.对象类型 = 2 And c.要素名称 = '姓名') Or
                             (c.对象类型 = 2 And c.要素名称 = '性别') Or (c.对象类型 = 2 And c.要素名称 = '年龄'))) And Rownum < 2) Loop
  
    --读取所有包含姓名、性别、年龄要素的病历 
    If r_Rec.电子签名 = 1 Then
      --构建电子签名病历报错串 
      v_Error := '书写的病历已经进行过电子签名,不能进行病人信息修改操作！';
      Raise Err_Custom;
    Else
      --返回病历名称串 
      说明_Out := r_Rec.科室 || ':书写的病历中包含病人基本信息，需要手工调整。';
      If r_Rec.病历种类 = 5 Then
        --更新疾病申报记录 
        Update 疾病申报记录 Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In Where 文件id = r_Rec.Id;
      End If;
    End If;
  End Loop;

  --以自由录入的姓名 
  For r_Rec In (Select /*+ RULE */
                Distinct d.名称 科室, a.Id, a.病历名称, a.病历种类, a.完成时间, a.保存人,
                         Nvl((Select Decode(a.编辑方式, 0, Decode(Substr(b.对象属性, 1, 1), '2', 1, 0),
                                             Decode(Substr(b.对象属性, Instr(b.对象属性, '|'), 1), '2', 1, 0))
                              From 电子病历内容 B
                              Where a.Id = b.文件id And ((b.对象类型 = 8 And 编辑方式 = 0) Or (b.对象类型 In (6, 7, 8) And 编辑方式 = 1)) And
                                    Rownum < 2), 0) As 电子签名
                From 电子病历记录 A, 部门表 D, 病人信息 E
                Where a.病人id = 病人id_In And a.主页id = 就诊id_In And a.科室id = d.Id And a.病人id = e.病人id And Exists
                 (Select 1 --包含 
                       From 电子病历内容 C
                       Where a.Id = c.文件id And
                             ((c.对象类型 = 2 And Instr(c.内容文本, e.姓名) > 0) Or (c.对象类型 = 1 And Instr(c.内容文本, e.姓名) > 0))) And
                      Rownum < 2) Loop
  
    --读取所有包含姓名的病历 
    If r_Rec.电子签名 = 1 Then
      --构建电子签名病历报错串 
      v_Error := '书写的病历已经进行过电子签名,不能进行病人信息修改操作！';
      Raise Err_Custom;
    Else
      --返回病历名称串 
      说明_Out := r_Rec.科室 || ':书写的病历中包含病人基本信息，需要手工调整。';
      If r_Rec.病历种类 = 5 Then
        --更新疾病申报记录 
        Update 疾病申报记录 Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In Where 文件id = r_Rec.Id;
      End If;
    End If;
  End Loop;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人信息_基本信息调整_病历;
/
--103838:涂建华,2016-12-19,婴儿信息修改
CREATE OR REPLACE Procedure zl_影像病人信息_修改
(
  病人来源_In       number,--1、门诊；2、住院；3、外来；4、体检
  医嘱id_In         病人医嘱记录.id%type,
  病人id_In         病人信息.病人id%Type,
  姓名_In           病人信息.姓名%Type,
  性别_In           病人信息.性别%Type,
  年龄_In           病人信息.年龄%Type,
  费别_In           病人信息.费别%Type,
  医疗付款方式_In   病人信息.医疗付款方式%Type,
  民族_In           病人信息.民族%Type,
  婚姻_In           病人信息.婚姻状况%Type,
  职业_In           病人信息.职业%Type,
  身份证号_In       病人信息.身份证号%Type,
  家庭地址_In       病人信息.家庭地址%Type,
  家庭电话_In       病人信息.家庭电话%Type,
  家庭地址邮编_In   病人信息.家庭地址邮编%Type,
  出生日期_In       病人信息.出生日期%Type := Null,
  主页id_In         病人信息.主页ID%Type := Null,
  婴儿_In           病人医嘱记录.婴儿%Type := Null             
) As
  --功能：处理病人病案信息
  --参数：

  v_年龄     Varchar2(20);
  v_年龄单位 Varchar2(20);
  v_出生日期 Date;
Begin
  If 出生日期_In Is Null And 年龄_In Is Not Null Then
    --根据年龄求出生日期
    v_年龄单位 := Substr(年龄_In, Length(年龄_In), 1);
    If Instr('岁,月,天', v_年龄单位) <= 0 Then
      v_年龄单位 := Null;
    Else
      v_年龄 := Replace(年龄_In, v_年龄单位, '');
    End If;
    Begin
      v_年龄 := To_Number(v_年龄);
    Exception
      When Others Then
        v_年龄 := Null;
    End;
    If v_年龄 Is Not Null And v_年龄单位 Is Not Null Then
      Select Decode(v_年龄单位, '岁', Add_Months(Sysdate, -12 * v_年龄), '月', Add_Months(Sysdate, -1 * v_年龄), '天',
                     Sysdate - v_年龄)
      Into v_出生日期
      From Dual;
    End If;
  Else
    v_出生日期 := 出生日期_In;
  End If;

  If 病人来源_In=3 then
    If nvl(婴儿_In, 0) <> 0 Then
      --婴儿信息修改
      Update 病人新生儿记录 
      Set 婴儿姓名 = 姓名_In,婴儿性别 = Nvl(性别_In, 婴儿性别), 出生时间 = v_出生日期
      Where 病人ID=病人id_In And 主页ID=Nvl(主页id_In, 0) And 序号=婴儿_In;
      
      Update 病人信息
      Set 民族 = Nvl(民族_In, 民族),婚姻状况 = Nvl(婚姻_In, 婚姻状况),
          费别 = Nvl(费别_In, 费别),医疗付款方式 = Nvl(医疗付款方式_In, 医疗付款方式), 
          职业 = Nvl(职业_In, 职业), 身份证号 = 身份证号_In, 家庭地址 = 家庭地址_In, 家庭电话 = 家庭电话_In,家庭地址邮编 = 家庭地址邮编_In
      Where 病人id = 病人id_In;
    Else
      Update 病人信息
      Set 姓名 = 姓名_In,性别 = Nvl(性别_In, 性别), 年龄 = 年龄_In, 出生日期 = v_出生日期, 
          民族 = Nvl(民族_In, 民族),婚姻状况 = Nvl(婚姻_In, 婚姻状况),
          费别 = Nvl(费别_In, 费别),医疗付款方式 = Nvl(医疗付款方式_In, 医疗付款方式),           
          职业 = Nvl(职业_In, 职业), 身份证号 = 身份证号_In,家庭地址 = 家庭地址_In, 家庭电话 = 家庭电话_In,家庭地址邮编 = 家庭地址邮编_In
      Where 病人id = 病人id_In;
      
      --修改对应的医嘱记录
      Update 病人医嘱记录 Set 姓名=姓名_In, 性别=性别_In, 年龄=年龄_In Where id=医嘱id_In or 相关ID=医嘱id_In;
    End If;  
  Else
    Update 病人信息
    Set 民族 = Nvl(民族_In, 民族),婚姻状况 = Nvl(婚姻_In, 婚姻状况),
        职业 = Nvl(职业_In, 职业), 家庭地址 = 家庭地址_In, 家庭电话 = 家庭电话_In,家庭地址邮编 = 家庭地址邮编_In
    Where 病人id = 病人id_In;
  End if;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End zl_影像病人信息_修改;
/

--103905:余伟节,2016-12-19,取消住院首页签名的限制
Create Or Replace Procedure Zl_病人信息_基本信息调整_医嘱
(
  病人id_In 病人信息变动.病人id%Type,
  就诊id_In Number,
  姓名_In   病人信息.姓名%Type,
  性别_In   病人信息.性别%Type,
  年龄_In   病人信息.年龄%Type,
  场合_In   Number, --1-门诊;2-住院 
  说明_Out  Out 病人信息变动.说明%Type
) As
  ------------------------------------------------------------------------------------------ 
  --功能:更新医嘱相关业务数据的病人基本信息 
  --入参:病人id_In:病人ID 
  --     就诊id_In:门诊病人为挂号ID;住院病人为主页ID;为0说明是外来或非挂号就诊的病人(就诊id_In为空时,将批量更改该病人的所有业务数据) 
  --     姓名_In:需要更改的病人姓名 
  --     性别_In:需要更改的病人性别 
  --     年龄_In:需要更改的病人年龄 
  --     场合_In:1-门诊;2-住院 
  --出参:说明_Out:病人信息调整后的说明信息，用于提示操作员进行相关操作 
  ------------------------------------------------------------------------------------------ 
  Err_Custom Exception;
  V_Error Varchar2(2000);
  N_Count Number(3);
  V_No    病人挂号记录.No%Type;
  V_Tmp   Varchar2(100);
Begin
  --外来人员，不处理
  If Nvl(就诊id_In, 0) = 0 Then
    Return;
  End If;
  --门诊取挂号单
  If Nvl(场合_In, 0) = 1 Then
    Select NO Into V_No From 病人挂号记录 Where ID = 就诊id_In;
    If V_No Is Null Then
      V_Error := '问找到该病人的挂号记录,不能更新病人基本信息.';
      Raise Err_Custom;
    End If;
    --门诊医嘱签名,则不允许修改病人基本信息
    Select Nvl(Count(1), 0)
    Into N_Count
    From 病人医嘱记录
    Where 病人id = 病人id_In And 挂号单 = V_No And 新开签名id Is Not Null And Rownum < 2;
    If N_Count <> 0 Then
      V_Error := '病人医嘱已经签名,不能更新病人基本信息.';
      Raise Err_Custom;
    End If;
  
    --更新病人本次就诊的医嘱中的病人基本信息
    Update 病人医嘱记录
    Set 姓名 = Nvl(姓名_In, 姓名), 性别 = Nvl(性别_In, 性别), 年龄 = Nvl(年龄_In, 年龄)
    Where 病人id = 病人id_In And 挂号单 = V_No;
    Return;
  End If;
  --住院病人
  If Nvl(场合_In, 0) = 2 Then
    --住院医嘱签名,则不允许修改病人基本信息
    Select Nvl(Count(1), 0)
    Into N_Count
    From 病人医嘱记录
    Where 病人id = 病人id_In And 主页id = 就诊id_In And 新开签名id Is Not Null And Rownum < 2;
  
    If N_Count <> 0 Then
      V_Error := '该病人医嘱已经签名,不能更新病人基本信息.';
      Raise Err_Custom;
    End If;
    --病案处于锁定状态，则不允许修改病人基本信息
    Select Decode(病案状态, 1, '等待审查中', 3, '正在审查中', 5, '已经审查归档', 10, '接收待审中', Null)
    Into V_Tmp
    From 病案主页
    Where 病人id = 病人id_In And 主页id = 就诊id_In;
  
    If Not V_Tmp Is Null Then
      V_Error := '该病人的病案' || V_Tmp || ',不能更新病人基本信息.';
      Raise Err_Custom;
    End If;
    --病案处于编目状态，则不允许修改病人基本信息
    Select Nvl(Count(1), 0)
    Into N_Count
    From 病案主页
    Where 病人id = 病人id_In And 主页id = 就诊id_In And 编目日期 Is Not Null;
    If N_Count <> 0 Then
      V_Error := '该病人的病案已经编目,不能更新病人基本信息.';
      Raise Err_Custom;
    End If;
  
    --已经打印了医嘱清单的提示重新打印
    Select Nvl(Count(1), 0)
    Into N_Count
    From 病人医嘱打印
    Where 病人id = 病人id_In And 主页id = 就诊id_In And Rownum < 2;
  
    If N_Count <> 0 Then
      If Not 说明_Out Is Null Then
        说明_Out := 说明_Out || Chr(13);
      End If;
      说明_Out := 说明_Out || '医嘱清单:已经打印需重新打印.';
    End If;
  
    --已经打印了首页的提示重新打印
    Select Nvl(Count(1), 0)
    Into N_Count
    From 电子病历打印
    Where 病人id = 病人id_In And 主页id = 就诊id_In And 文件id Is Null And 种类 = 9 And Rownum < 2;
    If N_Count <> 0 Then
      If Not 说明_Out Is Null Then
        说明_Out := 说明_Out || Chr(13);
      End If;
      说明_Out := 说明_Out || '病人首页:已经打印需重新打印.';
    End If;
  
    Update 病人医嘱记录
    Set 姓名 = Nvl(姓名_In, 姓名), 性别 = Nvl(性别_In, 性别), 年龄 = Nvl(年龄_In, 年龄)
    Where 病人id = 病人id_In And 主页id = 就诊id_In;
  
    Update 输液配药记录
    Set 姓名 = Nvl(姓名_In, 姓名), 性别 = Nvl(性别_In, 性别), 年龄 = Nvl(年龄_In, 年龄)
    Where 医嘱id In (Select ID From 病人医嘱记录 Where 病人id = 病人id_In And 主页id = 就诊id_In);
    Return;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || V_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人信息_基本信息调整_医嘱;
/
--00000:余伟节,2016-12-23,删掉体检子过程调用的示例
--103905:余伟节,2016-12-19,病人基本信息调整必须录入修改原因
Create Or Replace Procedure Zl_病人信息_基本信息调整
(
  病人id_In   病人信息变动.病人id%Type,
  就诊id_In   Number, --门诊病人为挂号ID;住院病人为主页ID;为0说明是外来或非挂号就诊的病人
  模块_In     病人信息变动.变动模块%Type,
  姓名_In     病人信息.姓名%Type,
  性别_In     病人信息.性别%Type,
  年龄_In     病人信息.年龄%Type,
  出生日期_In 病人信息.出生日期%Type,
  场合_In     Number, --1-门诊;2-住院
  修改原因_In Varchar2,
  说明_Out    Out 病人信息变动.说明%Type --出参
) As
  v_Username 人员表.姓名%Type;
  v_姓名     病人信息.姓名%Type;
  v_性别     病人信息.性别%Type;
  v_年龄     病人信息.年龄%Type;
  d_出生日期 病人信息.出生日期%Type;
  d_变动时间 病人信息变动.变动时间%Type;
  v_说明     病人信息变动.说明%Type;
  n_共享     Number(1);
  Err_Custom Exception;
  v_Error Varchar2(2000);
Begin
  v_Username := Zl_Username;

  --提取病人基本信息
  If Nvl(就诊id_In, 0) = 0 Then
    Begin
      Select 姓名, 性别, 年龄, 出生日期 Into v_姓名, v_性别, v_年龄, d_出生日期 From 病人信息 Where 病人id = 病人id_In;
    Exception
      When Others Then
        v_Error := '病人ID[' || 病人id_In || ']在病人信息中不存在,不能继续进行病人信息变更操作!';
        Raise Err_Custom;
    End;
  Else
    Case 场合_In
      When 1 Then
        Begin
          Select b.姓名, b.性别, b.年龄, a.出生日期
          Into v_姓名, v_性别, v_年龄, d_出生日期
          From 病人信息 A, 病人挂号记录 B
          Where a.病人id = b.病人id And a.病人id = 病人id_In And b.Id = 就诊id_In;
        Exception
          When Others Then
            v_Error := '病人ID[' || 病人id_In || ']、挂号ID[' || 就诊id_In || ']在病人挂号记录中不存在,不能继续进行病人信息变更操作!';
            Raise Err_Custom;
        End;
      When 2 Then
        Begin
          Select Nvl(b.姓名, a.姓名), Nvl(b.性别, a.性别), b.年龄, a.出生日期
          Into v_姓名, v_性别, v_年龄, d_出生日期
          From 病人信息 A, 病案主页 B
          Where a.病人id = b.病人id And a.病人id = 病人id_In And b.主页id = 就诊id_In;
        Exception
          When Others Then
            v_Error := '病人ID[' || 病人id_In || ']、主页ID[' || 就诊id_In || ']在病案主页中不存在,不能继续进行病人信息变更操作!';
            Raise Err_Custom;
        End;
      Else
        v_Error := '过程参数[场合]只能为1或2,不能继续进行病人信息变更操作!';
        Raise Err_Custom;
    End Case;
  End If;

  说明_Out := '';
  --检查病人是否已经被锁定
  Zl_病人信息_锁定检查(病人id_In);

  --调用对应模块子过程完成病人信息更新
  --1、费用部分
  v_说明 := '';
  Zl_病人信息_基本信息调整_费用(病人id_In, 就诊id_In, 姓名_In, 性别_In, 年龄_In, 场合_In, v_说明);
  If v_说明 Is Not Null Then
    说明_Out := 说明_Out || Chr(10) || Chr(13) || '费用部分:' || Chr(13) || v_说明;
  End If;

  --2、医嘱部分
  v_说明 := '';
  Zl_病人信息_基本信息调整_医嘱(病人id_In, 就诊id_In, 姓名_In, 性别_In, 年龄_In, 场合_In, v_说明);
  If v_说明 Is Not Null Then
    说明_Out := 说明_Out || Chr(10) || Chr(13) || '医嘱部分:' || Chr(13) || v_说明;
  End If;
  --3、体检部分
  --体检部分不调用子过程,因体检系统的就诊记录由体检系统自己产生,所以此处传入就诊id_In无法对体检系统进行修正。
  --体检系统提供单独的修改入口。
  --4、PACS部分
  v_说明 := '';
  Zl_病人信息_基本信息调整_Pacs(病人id_In, 就诊id_In, 姓名_In, 性别_In, 年龄_In, 场合_In, v_说明);
  If v_说明 Is Not Null Then
    说明_Out := 说明_Out || Chr(10) || Chr(13) || 'PACS部分:' || Chr(13) || v_说明;
  End If;
  --5、LIS部分
  v_说明 := '';
  Zl_病人信息_基本信息调整_Lis(病人id_In, 就诊id_In, 姓名_In, 性别_In, 年龄_In, 场合_In, v_说明);
  If v_说明 Is Not Null Then
    说明_Out := 说明_Out || Chr(10) || Chr(13) || 'LIS部分:' || Chr(13) || v_说明;
  End If;
  --6、病历部分
  v_说明 := '';
  Zl_病人信息_基本信息调整_病历(病人id_In, 就诊id_In, 姓名_In, 性别_In, 年龄_In, 场合_In, v_说明);
  If v_说明 Is Not Null Then
    说明_Out := 说明_Out || Chr(10) || Chr(13) || '病历部分:' || Chr(13) || v_说明;
  End If;
  --7、血库部分
  Begin
    Select 1
    Into n_共享
    From zlSystems
    Where Trunc(编号 / 100) = 22 And 所有者 = Sys_Context('USERENV', 'CURRENT_SCHEMA');
  Exception
    When Others Then
      n_共享 := 0;
  End;
  If n_共享 = 1 Then
    Execute Immediate 'Call Zl_病人信息_基本信息调整_血库(:1,:2,:3,:4,:5,:6,:7)'
      Using 病人id_In, 就诊id_In, 姓名_In, 性别_In, 年龄_In, 场合_In, Out v_说明;
    If v_说明 Is Not Null Then
      说明_Out := 说明_Out || Chr(10) || Chr(13) || '血库部分:' || Chr(13) || v_说明;
    End If;
  End If;

  --最后完成主表的更新(病案主页、病人挂号记录、病人信息)
  If 场合_In = 1 And Nvl(就诊id_In, 0) <> 0 Then
    --门诊病人
    Update 病人挂号记录 Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In Where 病人id = 病人id_In And ID = 就诊id_In;
  End If;
  If 场合_In = 2 And Nvl(就诊id_In, 0) <> 0 Then
    --住院病人
    Update 病案主页 Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In Where 病人id = 病人id_In And 主页id = 就诊id_In;
  End If;

  Update 病人信息 Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In, 出生日期 = 出生日期_In Where 病人id = 病人id_In;

  --更新病人信息变动
  If 说明_Out Is Not Null Then
    说明_Out := Substr(说明_Out, 3);
    说明_Out := '修改原因:' || 修改原因_In || Chr(13) || '病人基本信息调整导致以下内容发生变化:' || Chr(13) || 说明_Out;
    If Lengthb(说明_Out) > 4000 Then
      说明_Out := Substrb(说明_Out, 1, 4000);
    End If;
  End If;

  d_变动时间 := Sysdate;
  If Nvl(姓名_In, '_') <> Nvl(v_姓名, '_') Then
    Insert Into 病人信息变动
      (病人id, 变动项目, 原信息, 新信息, 变动时间, 变动人, 变动模块, 说明)
    Values
      (病人id_In, '姓名', v_姓名, 姓名_In, d_变动时间, v_Username, 模块_In, 说明_Out);
  End If;
  If Nvl(性别_In, '_') <> Nvl(v_性别, '_') Then
    Insert Into 病人信息变动
      (病人id, 变动项目, 原信息, 新信息, 变动时间, 变动人, 变动模块, 说明)
    Values
      (病人id_In, '性别', v_性别, 性别_In, d_变动时间, v_Username, 模块_In, 说明_Out);
  End If;
  If Nvl(年龄_In, '_') <> Nvl(v_年龄, '_') Then
    Insert Into 病人信息变动
      (病人id, 变动项目, 原信息, 新信息, 变动时间, 变动人, 变动模块, 说明)
    Values
      (病人id_In, '年龄', v_年龄, 年龄_In, d_变动时间, v_Username, 模块_In, 说明_Out);
  End If;
  If Nvl(出生日期_In, Sysdate) <> Nvl(d_出生日期, Sysdate) Then
    Insert Into 病人信息变动
      (病人id, 变动项目, 原信息, 新信息, 变动时间, 变动人, 变动模块, 说明)
    Values
      (病人id_In, '出生日期', To_Char(d_出生日期, 'YYYY-MM-DD hh24:mi'), To_Char(出生日期_In, 'YYYY-MM-DD hh24:mi'), d_变动时间,
       v_Username, 模块_In, 说明_Out);
  End If;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人信息_基本信息调整;
/

--104247:胡俊勇,2017-01-03,停嘱原因修改
--101393:胡俊勇,2016-12-16,电子签明参数判断
CREATE OR REPLACE Procedure Zl_病人医嘱记录_校对
(
  --功能：校对指定的医嘱
  --参数：医嘱ID_IN=Nvl(相关ID,ID)
  --      状态_IN=校对通过3或校对疑问2
  --      自动校对_IN=保存之后调用自动校对,自动填写计价内容
  --说明：一组医嘱只能调用一次,过程同时完成处理一组医嘱的校对
  医嘱id_In     病人医嘱记录.Id%Type,
  状态_In       病人医嘱记录.医嘱状态%Type,
  校对时间_In   病人医嘱状态.操作时间%Type,
  校对说明_In   病人医嘱状态.操作说明%Type := Null,
  自动校对_In   Number := Null,
  操作员编号_In 人员表.编号%Type := Null,
  操作员姓名_In 人员表.姓名%Type := Null
) Is
  --用于医嘱检查
  v_状态       病人医嘱记录.医嘱状态%Type;
  v_期效       病人医嘱记录.医嘱期效%Type;
  v_病人id     病人医嘱记录.病人id%Type;
  v_主页id     病人医嘱记录.主页id%Type;
  v_婴儿       病人医嘱记录.婴儿%Type;
  v_医嘱内容   病人医嘱记录.医嘱内容%Type;
  v_开嘱时间   病人医嘱记录.开嘱时间%Type;
  v_开始时间   病人医嘱记录.开始执行时间%Type;
  v_开嘱医生   病人医嘱记录.开嘱医生%Type;
  v_前提id     病人医嘱记录.前提id%Type;
  v_执行标记   病人医嘱记录.执行标记%Type;
  v_执行科室id 病人医嘱记录.执行科室id%Type;
  v_标本部位   病人医嘱记录.标本部位%Type;
  v_停止时间   病人医嘱记录.开嘱时间%Type;
  v_开嘱科室id 病人医嘱记录.开嘱科室id%Type;

  --用于变更护理等级
  v_诊疗类别   病人医嘱记录.诊疗类别%Type;
  v_诊疗项目id 病人医嘱记录.诊疗项目id%Type;
  v_操作类型   诊疗项目目录.操作类型%Type;
  v_护理等级id 病案主页.护理等级id%Type;
  v_紧急标志   病人医嘱记录.紧急标志%Type;
  v_入院方式   入院方式.名称%Type;

  v_Stopadviceids 病人医嘱记录.医嘱内容%Type;
  n_Adviceid      病人医嘱记录.病人id%Type;
  n_标记          Number(18);
  --与该项目同一自动停止互斥组的项目:组中应该都是长嘱(包括当前医嘱),程序应已检查。
  --注意应加婴儿条件,同时也应停止除当前医嘱外的其它相同诊疗项目的医嘱。
  Cursor c_Exclude Is
    Select Distinct b.Id As 医嘱id, b.开始执行时间, b.执行终止时间, b.上次执行时间, b.开嘱医生, b.执行时间方案, b.频率间隔, b.频率次数, b.间隔单位
    From 诊疗互斥项目 A, 病人医嘱记录 B
    Where a.类型 = 3 And a.项目id = b.诊疗项目id And b.Id <> 医嘱id_In And Nvl(b.医嘱期效, 0) = 0 And b.医嘱状态 In (3, 5, 6, 7) And
          b.病人id = v_病人id And Nvl(b.主页id, 0) = Nvl(v_主页id, 0) And Nvl(b.婴儿, 0) = Nvl(v_婴儿, 0) And
          a.组编号 In (Select Distinct 组编号 From 诊疗互斥项目 Where 类型 = 3 And 项目id = v_诊疗项目id)
    Order By b.Id;
  v_终止时间 病人医嘱记录.执行终止时间%Type;

  --护理等级互斥
  Cursor c_Nurse Is
    Select a.Id As 医嘱id, a.开始执行时间, a.执行终止时间, a.上次执行时间, a.开嘱医生
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id And a.诊疗类别 = 'H' And b.操作类型 = '1' And a.病人id = v_病人id And Nvl(a.主页id, 0) = Nvl(v_主页id, 0) And
          Nvl(a.婴儿, 0) = Nvl(v_婴儿, 0) And Nvl(a.医嘱期效, 0) = 0 And a.医嘱状态 In (3, 5, 6, 7) And a.Id <> 医嘱id_In;

  --记录入出量互斥
  Cursor c_Patiio Is
    Select a.Id As 医嘱id, a.开始执行时间, a.执行终止时间, a.上次执行时间, a.开嘱医生
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id And a.诊疗类别 = 'Z' And b.操作类型 = '12' And a.病人id = v_病人id And Nvl(a.主页id, 0) = Nvl(v_主页id, 0) And
          Nvl(a.婴儿, 0) = Nvl(v_婴儿, 0) And Nvl(a.医嘱期效, 0) = 0 And a.医嘱状态 In (3, 5, 6, 7) And a.Id <> 医嘱id_In;

  --记录病情互斥
  Cursor c_Patistate Is
    Select a.Id As 医嘱id, a.开始执行时间, a.执行终止时间, a.上次执行时间, a.开嘱医生
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id And a.诊疗类别 = 'Z' And b.操作类型 In ('9', '10') And a.病人id = v_病人id And
          Nvl(a.主页id, 0) = Nvl(v_主页id, 0) And Nvl(a.婴儿, 0) = Nvl(v_婴儿, 0) And Nvl(a.医嘱期效, 0) = 0 And
          a.医嘱状态 In (3, 5, 6, 7) And a.Id <> 医嘱id_In;
  --变动有效记录
  Cursor c_Oldinfo Is
    Select b.*
    From (Select c.*
           From 病人变动记录 C
           Where c.病人id = v_病人id And c.主页id = v_主页id And
                 c.开始时间 = (Select Min(开始时间)
                           From 病人变动记录
                           Where 病人id = v_病人id And 主页id = v_主页id And 开始时间 > v_开始时间) And
                 NVL(c.终止时间|| '','空') = (Select  NVL(Min(终止时间)|| '','空')
                           From 病人变动记录
                           Where 病人id = v_病人id And 主页id = v_主页id And 开始时间 > v_开始时间)) A, 病人变动记录 B

    Where b.病人id = v_病人id And b.主页id = v_主页id And a.开始时间 = b.终止时间 And a.开始原因 = b.终止原因 And a.附加床位 = b.附加床位
    Union
    Select *
    From 病人变动记录
    Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 Is Null And 开始时间 <= v_开始时间;

  Cursor c_Endinfo Is
    Select * From 病人变动记录 Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 Is Null;
  r_Oldinfo      c_Oldinfo%RowType;
  r_Endinfo      c_Endinfo%RowType;
  v_变动终止原因 病人变动记录.终止原因%Type;
  v_变动终止时间 病人变动记录.终止时间%Type;
  v_变动终止人员 病人变动记录.终止人员%Type;

  --包含病人(婴儿)的所有未停长嘱(含配方长嘱)
  Cursor c_Needstop
  (
    v_病人id   病人医嘱记录.病人id%Type,
    v_主页id   病人医嘱记录.主页id%Type,
    v_婴儿     病人医嘱记录.婴儿%Type,
    v_Stoptime Date
  ) Is
    Select a.Id, a.诊疗类别, b.操作类型, b.执行频率
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id(+) And a.病人id = v_病人id And a.主页id = v_主页id And (v_婴儿 = -1 Or Nvl(a.婴儿, 0) = Nvl(v_婴儿, 0)) And
          Nvl(a.医嘱期效, 0) = 0 And a.医嘱状态 Not In (1, 2, 4, 8, 9) And a.开始执行时间 < v_Stoptime
    Order By a.序号;
  --包含病人(婴儿)的已停但未确认的长嘱,终止执行时间在指定时间之后
  Cursor c_Havestop
  (
    v_病人id   病人医嘱记录.病人id%Type,
    v_主页id   病人医嘱记录.主页id%Type,
    v_婴儿     病人医嘱记录.婴儿%Type,
    v_Stoptime Date
  ) Is
    Select ID
    From 病人医嘱记录
    Where 病人id = v_病人id And 主页id = v_主页id And (v_婴儿 = -1 Or Nvl(婴儿, 0) = Nvl(v_婴儿, 0)) And Nvl(医嘱期效, 0) = 0 And
          医嘱状态 = 8 And 执行终止时间 > v_Stoptime And 开始执行时间 < v_Stoptime
    Order By 序号;

  --取一组医嘱的计价内容
  Cursor c_Price Is
    Select a.Id, b.收费项目id, b.收费数量, b.从属项目, b.费用性质, b.收费方式, c.类别 As 收费类别, a.诊疗类别, e.操作类型, e.试管编码,
           Sum(Decode(Nvl(c.是否变价, 0), 1, Nvl(d.缺省价格, d.原价), Null)) As 单价
    From 病人医嘱记录 A, 诊疗收费关系 B, 收费项目目录 C, 收费价目 D, 诊疗项目目录 E
    Where a.诊疗项目id = b.诊疗项目id And b.收费项目id = c.Id And c.Id = d.收费细目id And
          (a.相关id Is Null And a.执行标记 In (1, 2) And b.费用性质 = 1 Or
          a.标本部位 = b.检查部位 And a.检查方法 = b.检查方法 And Nvl(b.费用性质, 0) = 0 Or
          a.检查方法 Is Null And Nvl(b.费用性质, 0) = 0 And b.检查部位 Is Null And b.检查方法 Is Null) And
          a.诊疗类别 Not In ('5', '6', '7') And Nvl(a.计价特性, 0) = 0 And Nvl(a.执行性质, 0) Not In (0, 5) And c.服务对象 In (2, 3) And
          (c.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or c.撤档时间 Is Null) And Sysdate Between d.执行日期 And
          Nvl(d.终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')) And Nvl(b.收费数量, 0) <> 0 And
          Not (Nvl(c.是否变价, 0) = 1 And Nvl(Nvl(d.缺省价格, d.原价), 0) = 0) And a.诊疗项目id = e.Id And
          (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In)
    Group By a.Id, b.收费项目id, b.收费数量, b.从属项目, b.费用性质, b.收费方式, c.类别, a.诊疗类别, e.操作类型, e.试管编码;

  Cursor c_Pati(v_病人id 病人信息.病人id%Type) Is
    Select * From 病人信息 Where 病人id = v_病人id;
  r_Pati c_Pati%RowType;

  v_材料id 采血管类型.材料id%Type;

  --其它临时变量
  v_Count    Number;
  v_Date     Date;
  v_Temp     Varchar2(255);
  v_Par停嘱  Varchar2(255);
  v_人员编号 人员表.编号%Type;
  v_人员姓名 人员表.姓名%Type;

  v_Error Varchar2(255);
  Err_Custom Exception;

  Function Getadvicetext(v_医嘱id 病人医嘱记录.Id%Type) Return Varchar2 Is
    v_Text 病人医嘱记录.医嘱内容%Type;
    v_类别 病人医嘱记录.诊疗类别%Type;
    v_配方 Number;
  Begin
    Select 诊疗类别, 医嘱内容 Into v_类别, v_Text From 病人医嘱记录 Where ID = v_医嘱id;
    If v_类别 = 'E' Then
      --西药，中成药的医嘱内容
      Begin
        Select 诊疗类别, Decode(诊疗类别, '7', v_Text, 医嘱内容)
        Into v_类别, v_Text
        From 病人医嘱记录
        Where 相关id = v_医嘱id And 诊疗类别 In ('5', '6', '7') And Rownum = 1;
      Exception
        When Others Then
          Null;
      End;
      If v_类别 = '7' Then
        v_配方 := 1;
      End If;
    End If;
    If Length(v_Text) > 30 Then
      v_Text := Substr(v_Text, 1, 30) || '...';
    End If;
    If Length(v_Text) > 20 Then
      v_Text := '"' || v_Text || '"' || Chr(13) || Chr(10);
    Else
      v_Text := '"' || v_Text || '"';
    End If;
    If v_配方 = 1 Then
      v_Text := '中药配方' || v_Text;
    End If;
    Return(v_Text);
  End;
Begin
  --检查医嘱状态是否正确:并发操作
  Begin
    Select a.医嘱期效, a.医嘱状态, a.开嘱时间, a.开嘱医生, a.开始执行时间, a.病人id, a.主页id, a.婴儿, a.医嘱内容, a.诊疗类别, a.诊疗项目id, a.前提id,
           Nvl(b.操作类型, '0'), Nvl(a.执行标记, 0), a.执行科室id, a.标本部位, a.开嘱科室id, Nvl(a.紧急标志, 0) As 紧急标志
    Into v_期效, v_状态, v_开嘱时间, v_开嘱医生, v_开始时间, v_病人id, v_主页id, v_婴儿, v_医嘱内容, v_诊疗类别, v_诊疗项目id, v_前提id, v_操作类型, v_执行标记,
         v_执行科室id, v_标本部位, v_开嘱科室id, v_紧急标志
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id(+) And a.Id = 医嘱id_In;
  Exception
    When Others Then
      Begin
        v_Error := '医嘱已被删除，不能进行校对。' || Chr(13) || Chr(10) || '这可能是并发操作引起的，请重新读取校对数据。';
        Raise Err_Custom;
      End;
  End;
  If v_状态 <> 1 Then
    v_Error := '医嘱"' || Getadvicetext(医嘱id_In) || '"不是新开的医嘱，不能通过校对。' || Chr(13) || Chr(10) || '这可能是并发操作引起的，请重新读取校对数据。';
    Raise Err_Custom;
  End If;
  --再次检查校对时间的有效性:并发操作
  If To_Char(v_开嘱时间, 'YYYY-MM-DD HH24:MI') <= To_Char(v_开始时间, 'YYYY-MM-DD HH24:MI') Then
    If To_Char(校对时间_In, 'YYYY-MM-DD HH24:MI') < To_Char(v_开嘱时间, 'YYYY-MM-DD HH24:MI') Then
      v_Error := '医嘱"' || Getadvicetext(医嘱id_In) || '"的校对时间不能小于开嘱时间 ' || To_Char(v_开嘱时间, 'YYYY-MM-DD HH24:MI') || '。' ||
                 Chr(13) || Chr(10) || '这可能是并发操作引起的，请重新读取校对数据。';
      Raise Err_Custom;
    End If;
  Else
    If To_Char(校对时间_In, 'YYYY-MM-DD HH24:MI') < To_Char(v_开始时间, 'YYYY-MM-DD HH24:MI') Then
      v_Error := '医嘱"' || Getadvicetext(医嘱id_In) || '"的校对时间不能小于开始执行时间 ' || To_Char(v_开始时间, 'YYYY-MM-DD HH24:MI') || '。' ||
                 Chr(13) || Chr(10) || '这可能是并发操作引起的，请重新读取校对数据。';
      Raise Err_Custom;
    End If;
  End If;

  --如果要求签名，检查校对时是否有签名(并发取消签名)
  If 状态_In = 3 Then
    Select Zl_Fun_Getsignpar(Decode(v_前提id, Null, 1, 3), v_开嘱科室id) Into v_Count From Dual;
    If v_Count = 1 Then
      --证书停用或未注册证书不进入签名环节只判断一条数据即可
      For C In (Select a.是否停用
                From 人员证书记录 A, 人员表 B
                Where a.人员id = b.Id And b.姓名 = v_开嘱医生
                Order By a.注册时间 Desc) Loop
        If Nvl(c.是否停用, 0) = 0 Then
          Select Count(*)
          Into v_Count
          From 病人医嘱状态 A
          Where 操作类型 = 1 And 医嘱id = 医嘱id_In And
                (签名id Is Null And Exists
                 (Select 1
                  From 人员表 R, 人员性质说明 X
                  Where r.Id = x.人员id And r.姓名 = a.操作人员 And x.人员性质 = '护士') And Not Exists
                 (Select 1
                  From 人员表 R, 人员性质说明 Y
                  Where r.Id = y.人员id And r.姓名 = a.操作人员 And y.人员性质 = '医生') Or 签名id Is Not Null Or a.操作人员 <> v_开嘱医生);
          If Nvl(v_Count, 0) = 0 Then
            v_Error := '医嘱"' || Getadvicetext(医嘱id_In) || '"还没有电子签名，不能通过校对。';
            Raise Err_Custom;
          End If;
        End If;
        Exit;
      End Loop;
    End If;
  End If;

  --当前操作人员
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
    v_人员编号 := 操作员编号_In;
    v_人员姓名 := 操作员姓名_In;
  Else
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;

  --因为可能同时：新开->自动校对->互斥自动停止,因此分别-2,-1秒
  Select Sysdate - 1 / 60 / 60 / 24 Into v_Date From Dual;

  Update 病人医嘱记录
  Set 医嘱状态 = 状态_In, 校对护士 = v_人员姓名, 校对时间 = 校对时间_In
  Where ID = 医嘱id_In Or 相关id = 医嘱id_In;

  Insert Into 病人医嘱状态
    (医嘱id, 操作类型, 操作人员, 操作时间, 操作说明)
    Select ID, 状态_In, v_人员姓名, v_Date, 校对说明_In From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;

  --校对通过时的其它处理
  If 状态_In = 3 Then
    --自动校对时，自动填写缺省的计价内容
    If Nvl(自动校对_In, 0) = 1 Then
      --1.变价的计价项目,如果最低限价不为0,则缺省为最低限价,否则不加入;可再手工计价.
      --2.对于非药嘱药品和在用卫材未定执行科室,发送时会取缺省的,可再手工设置。
      For r_Price In c_Price Loop
        --取(检验)医嘱的管码和材料,采集方式以检验项目的为准
        v_材料id := Null;
        If r_Price.诊疗类别 = 'E' And r_Price.操作类型 = '6' Then
          Begin
            Select c.材料id
            Into v_材料id
            From 病人医嘱记录 A, 诊疗项目目录 B, 采血管类型 C
            Where a.诊疗项目id = b.Id And b.试管编码 = c.编码 And a.相关id = r_Price.Id And Rownum = 1;
          Exception
            When Others Then
              Null;
          End;
        Elsif r_Price.诊疗类别 = 'C' And r_Price.试管编码 Is Not Null Then
          Begin
            Select 材料id Into v_材料id From 采血管类型 Where 编码 = r_Price.试管编码;
          Exception
            When Others Then
              Null;
          End;
        End If;

        --判断处理检验试管费用的收取
        If (Nvl(r_Price.收费方式, 0) = 1 And r_Price.收费类别 = '4' And r_Price.收费项目id = Nvl(v_材料id, 0) Or
           Not (Nvl(r_Price.收费方式, 0) = 1 And r_Price.收费类别 = '4' And Nvl(v_材料id, 0) <> 0)) Then
          Insert Into 病人医嘱计价
            (医嘱id, 收费细目id, 数量, 单价, 从项, 执行科室id, 费用性质, 收费方式)
          Values
            (r_Price.Id, r_Price.收费项目id, r_Price.收费数量, r_Price.单价, r_Price.从属项目, Null, r_Price.费用性质, r_Price.收费方式);
        End If;
      End Loop;
    End If;

    --自由录入的临嘱医嘱标记为停止
    If Nvl(v_期效, 0) = 1 And v_诊疗项目id Is Null Then
      Update 病人医嘱记录
      Set 医嘱状态 = 8, 停嘱时间 = 校对时间_In, 停嘱医生 = v_开嘱医生
      Where ID = 医嘱id_In Or 相关id = 医嘱id_In;

      Insert Into 病人医嘱状态
        (医嘱id, 操作类型, 操作人员, 操作时间)
        Select ID, 8, v_人员姓名, Sysdate From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
    End If;
    v_Par停嘱 := zl_GetSysParameter(271);
    --将同一自动停止互斥组中的病人其它医嘱停止(如果尚未停止)
    For r_Exclude In c_Exclude Loop
      Select Decode(Sign(r_Exclude.开始执行时间 - v_开始时间), 1, r_Exclude.开始执行时间, v_开始时间)
      Into v_终止时间
      From Dual;
      Select Decode(Sign(r_Exclude.执行终止时间 - v_开始时间), -1, r_Exclude.执行终止时间, v_开始时间)
      Into v_终止时间
      From Dual;
      If v_Par停嘱 = '1' Then
        v_Temp := '自动停止：医嘱互斥。';
      Else
        v_Temp := Null;
      End If;
      Zl_病人医嘱记录_停止(r_Exclude.医嘱id, v_终止时间, v_开嘱医生, 1, 0, 0, Null, Null, v_Temp);
      v_Stopadviceids := v_Stopadviceids || ',' || r_Exclude.医嘱id;
    End Loop;

    --对一些特殊医嘱的处理
    If v_诊疗类别 = 'H' And v_操作类型 = '1' And Nvl(v_期效, 0) = 0 Then
      --校对护理等级时,同步更改病人护理等级
      If Nvl(v_婴儿, 0) = 0 Then
        --病人当前应处于正常住院状态
        v_Temp := Null;
        Begin
          Select Decode(状态, 1, '等待入科', 2, '正在转科', 3, '已预出院', Null)
          Into v_Temp
          From 病案主页
          Where 病人id = v_病人id And 主页id = v_主页id;
        Exception
          When Others Then
            Null;
        End;
        If v_Temp Is Not Null Then
          v_Error := '病人当前处于' || v_Temp || '状态,医嘱"' || v_医嘱内容 || '"不能通过校对。';
          Raise Err_Custom;
        End If;

        Begin
          --根据收费对照处理，当前医嘱计价表还没有填写
          --未设置时,不处理；相同时,不处理；有多个时,只取一个。
          Select a.收费项目id
          Into v_护理等级id
          From 诊疗收费关系 A, 收费项目目录 B
          Where a.收费项目id = b.Id And b.类别 = 'H' And Nvl(b.项目特性, 0) <> 0 And a.诊疗项目id = v_诊疗项目id And Rownum = 1 And
                Not Exists
           (Select 1 From 病案主页 Where 病人id = v_病人id And 主页id = v_主页id And 护理等级id = a.收费项目id);
        Exception
          When Others Then
            Null;
        End;
      End If;

      --变动记录的时间加上秒，以便回退操作时区分同一分种的校对、停止等操作
      v_开始时间 := To_Date(To_Char(v_开始时间, 'yyyy-mm-dd hh24:mi') || To_Char(Sysdate, 'ss'), 'yyyy-mm-dd hh24:mi:ss');
      If v_护理等级id Is Not Null Then
        Zl_病人变动记录_Nurse(v_病人id, v_主页id, v_护理等级id, v_开始时间, v_人员编号, v_人员姓名);
      End If;

      --并停止其它护理等级医嘱(护理等级应该都为"持续性"长嘱,且只有一个未停)
      For r_Nurse In c_Nurse Loop
        Select Decode(Sign(r_Nurse.开始执行时间 - v_开始时间), 1, r_Nurse.开始执行时间, v_开始时间)
        Into v_终止时间
        From Dual;
        Select Decode(Sign(r_Nurse.执行终止时间 - v_开始时间), -1, r_Nurse.执行终止时间, v_开始时间)
        Into v_终止时间
        From Dual;
        If v_Par停嘱 = '1' Then
          v_Temp := '自动停止：护理等级。';
        Else
          v_Temp := Null;
        End If;
        Zl_病人医嘱记录_停止(r_Nurse.医嘱id, v_终止时间, v_开嘱医生, 1, 0, 0, Null, Null, v_Temp);
        v_Stopadviceids := v_Stopadviceids || ',' || r_Nurse.医嘱id;
      End Loop;
    Elsif v_诊疗类别 = 'Z' And v_操作类型 In ('9', '10') And Nvl(v_期效, 0) = 0 And Nvl(v_婴儿, 0) = 0 Then
      --病重病危医嘱：9-病重;10-病危
      --停止相同医嘱
      For r_Patistate In c_Patistate Loop
        Select Decode(Sign(r_Patistate.开始执行时间 - v_开始时间), 1, r_Patistate.开始执行时间, v_开始时间)
        Into v_终止时间
        From Dual;
        Select Decode(Sign(r_Patistate.执行终止时间 - v_开始时间), -1, r_Patistate.执行终止时间, v_开始时间)
        Into v_终止时间
        From Dual;
        If v_Par停嘱 = '1' Then
          If v_操作类型 = '9' Then
            v_Temp := '自动停止：病重医嘱。';
          Else
            v_Temp := '自动停止：病危医嘱。';
          End If;
        Else
          v_Temp := Null;
        End If;      
        Zl_病人医嘱记录_停止(r_Patistate.医嘱id, v_终止时间, v_开嘱医生, 1, 0, 0, Null, Null, v_Temp);
        v_Stopadviceids := v_Stopadviceids || ',' || r_Patistate.医嘱id;
      End Loop;

      --产生病情变动
      Open c_Oldinfo; --必须在处理之前先打开
      Fetch c_Oldinfo
        Into r_Oldinfo;
      Open c_Endinfo;
      Fetch c_Endinfo
        Into r_Endinfo;
      If c_Endinfo%RowCount = 0 Then
        Close c_Endinfo;
        v_Error := '未发现该病人当前有效的变动记录！';
        Raise Err_Custom;
      End If;
      Select Count(*)
      Into v_Count
      From 病人变动记录
      Where 病人id = v_病人id And 主页id = v_主页id And 开始时间 Is Null And 终止时间 Is Null;
      If v_Count > 0 Then
        v_Error := '病人当前处于转科状态，请先办理转科确认或者取消转科状态。';
        Raise Err_Custom;
      End If;

      Update 病案主页
      Set 当前病况 = Decode(v_操作类型, '9', '重', '10', '危')
      Where 病人id = v_病人id And 主页id = v_主页id;

      --取消上次变动
      If r_Oldinfo.终止时间 Is Not Null Then
        v_变动终止时间 := r_Oldinfo.终止时间;
        v_变动终止原因 := r_Oldinfo.终止原因;
        v_变动终止人员 := r_Oldinfo.终止人员;
        --取消上次变动
        Update 病人变动记录
        Set 终止时间 = v_开始时间, 终止原因 = 13, 终止人员 = v_人员姓名, 上次计算时间 = Null
        Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 = v_变动终止时间 And 终止原因 = v_变动终止原因;
        --更新将来的记录如果有停止到将来的则删除上次计算时间
        Update 病人变动记录
        Set 病情 = Decode(v_操作类型, '9', '重', '10', '危'), 上次计算时间 = Null
        Where 病人id = v_病人id And 主页id = v_主页id And 开始时间 > v_开始时间;
      Else
        Update 病人变动记录
        Set 终止时间 = v_开始时间, 终止原因 = 13, 终止人员 = v_人员姓名,
            上次计算时间 = Decode(Sign(Nvl(上次计算时间, v_开始时间) - v_开始时间), 1, Null, 上次计算时间)
        Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 Is Null;
      End If;

      While c_Oldinfo%Found Loop
        Insert Into 病人变动记录
          (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号, 操作员姓名,
           终止时间, 终止原因, 终止人员)
        Values
          (病人变动记录_Id.Nextval, v_病人id, v_主页id, v_开始时间, 13, r_Oldinfo.附加床位, r_Oldinfo.病区id, r_Oldinfo.科室id,
           r_Oldinfo.护理等级id, r_Oldinfo.床位等级id, r_Oldinfo.床号, r_Oldinfo.责任护士, r_Oldinfo.经治医师, r_Oldinfo.主治医师,
           r_Oldinfo.主任医师, Decode(v_操作类型, '9', '重', '10', '危'), v_人员编号, v_人员姓名, v_变动终止时间, v_变动终止原因, v_变动终止人员);

        Fetch c_Oldinfo
          Into r_Oldinfo;
      End Loop;

      Close c_Oldinfo;
      Close c_Endinfo;
    Elsif v_诊疗类别 = 'Z' And v_操作类型 = '12' And Nvl(v_期效, 0) = 0 And Nvl(v_婴儿, 0) = 0 Then
      --记录入出量的医嘱，互斥
      For r_Patiio In c_Patiio Loop
        Select Decode(Sign(r_Patiio.开始执行时间 - v_开始时间), 1, r_Patiio.开始执行时间, v_开始时间)
        Into v_终止时间
        From Dual;
        Select Decode(Sign(r_Patiio.执行终止时间 - v_开始时间), -1, r_Patiio.执行终止时间, v_开始时间)
        Into v_终止时间
        From Dual;
        Zl_病人医嘱记录_停止(r_Patiio.医嘱id, v_终止时间, v_开嘱医生, 1);
        v_Stopadviceids := v_Stopadviceids || ',' || r_Patiio.医嘱id;
      End Loop;
    Elsif (v_诊疗类别 = 'Z' And v_操作类型 In ('3', '4', '5', '6', '11', '14') And
          (v_操作类型 <> '14' Or v_操作类型 = '14' And v_执行标记 = 1)) Or (v_诊疗类别 = 'F' And v_执行标记 = 1) Then
      v_Count := 0;
      If v_操作类型 = '4' Or v_操作类型 = '14' Or v_诊疗类别 = 'F' Then
        --保持与以前校对时相同的处理
        If Nvl(v_婴儿, 0) = 0 Then
          v_Count := 1;
        End If;
      Else
        --这几个特殊医嘱在校对中停止医嘱是新加的内容，保持与发送中相同的处理
        v_Count := 1;
        If Nvl(v_婴儿, 0) = 0 Then
          v_婴儿 := -1;
        Else
          v_婴儿 := Nvl(v_婴儿, 0);
        End If;
      End If;
      If v_Count = 1 Then
        If v_诊疗类别 = 'F' And v_执行标记 = 1 Then
          --在手术当天(取整)停止
          v_开始时间 := Trunc(To_Date(v_标本部位, 'yyyy-mm-dd hh24:mi:ss'));
        End If;

        --几个特殊医嘱校对时停止前面的长嘱,在医嘱开始时终止：3-转科;4-术后;5-出院;6-转院,11-死亡,14-术前
        For r_Needstop In c_Needstop(v_病人id, v_主页id, v_婴儿, v_开始时间) Loop
          Select Decode(Sign(开始执行时间 - v_开始时间), 1, 开始执行时间, v_开始时间)
          Into v_停止时间
          From 病人医嘱记录
          Where ID = r_Needstop.Id;
          Update 病人医嘱记录
          Set 医嘱状态 = 8, 执行终止时间 = v_停止时间, 停嘱时间 = 校对时间_In, 停嘱医生 = v_开嘱医生
          Where ID = r_Needstop.Id;

          Insert Into 病人医嘱状态
            (医嘱id, 操作类型, 操作人员, 操作时间)
            Select ID, 8, v_人员姓名, 校对时间_In From 病人医嘱记录 Where ID = r_Needstop.Id;
          v_Stopadviceids := v_Stopadviceids || ',' || r_Needstop.Id;
        End Loop;
        --已停止未确认的长嘱,终止时间在医嘱开始后的,调前其终止时间(同时多个特殊医嘱的情况)
        For r_Havestop In c_Havestop(v_病人id, v_主页id, v_婴儿, v_开始时间) Loop
          Update 病人医嘱记录
          Set 执行终止时间 = Decode(Sign(开始执行时间 - v_开始时间), 1, 开始执行时间, v_开始时间), 停嘱时间 = 校对时间_In, 停嘱医生 = v_开嘱医生
          Where ID = r_Havestop.Id;

          --不修改停止医嘱的操作人员，因为停止时，医生可能已进行电子签名
          Update 病人医嘱状态 Set 操作时间 = 校对时间_In Where 医嘱id = r_Havestop.Id And 操作类型 = 8;
          v_Stopadviceids := v_Stopadviceids || ',' || r_Havestop.Id;
        End Loop;
        --处理长期备用医嘱(没有执行（发送）过的标记未用）
        Update 病人医嘱记录
        Set 执行标记 = -1
        Where 病人id = v_病人id And 主页id = v_主页id And 医嘱期效 = 0 And 执行频次 = '必要时' And 上次执行时间 Is Null And 医嘱状态 In (3, 5, 6, 7) And
              执行标记 <> -1;
        --如果是转院转科死亡出院医嘱同时处理临时备用医嘱。
        If v_操作类型 In ('3', '5', '6', '11') Then
          Update 病人医嘱记录
          Set 执行标记 = -1
          Where 病人id = v_病人id And 主页id = v_主页id And 医嘱期效 = 1 And 执行频次 = '需要时' And 医嘱状态 = 3 And 执行标记 <> -1;
        End If;
      End If;
    Elsif v_诊疗类别 = 'Z' And v_操作类型 = '2' Then
      --对留观病人下达入院通知;
      --预约登记的条件：1.当前无预约,2.当前是门诊留观病人（在院时也允许，因为需要先预约,入院接收时检查了必须出院后才能接收）
      Select Count(*) Into v_Count From 病案主页 Where 病人id = v_病人id And Nvl(主页id, 0) = 0;
      If v_Count = 0 Then
        Select Count(*) Into v_Count From 病案主页 Where 病人id = v_病人id And 主页id = v_主页id And 病人性质 <> 1;
      End If;
      If v_Count = 0 Then
        Open c_Pati(v_病人id);
        Fetch c_Pati
          Into r_Pati;
        Close c_Pati;

        v_入院方式 := Null;
        If v_紧急标志 = 1 Then
          v_入院方式 := '急诊';
        End If;

        Zl_入院病案主页_Insert(1, 0, r_Pati.病人id, r_Pati.住院号, Null, r_Pati.姓名, r_Pati.性别, r_Pati.年龄, r_Pati.费别, r_Pati.出生日期,
                         r_Pati.国籍, r_Pati.民族, r_Pati.学历, r_Pati.婚姻状况, r_Pati.职业, r_Pati.身份, r_Pati.身份证号, r_Pati.出生地点,
                         r_Pati.家庭地址, r_Pati.家庭地址邮编, r_Pati.家庭电话, r_Pati.户口地址, r_Pati.户口地址邮编, r_Pati.联系人姓名, r_Pati.联系人关系,
                         r_Pati.联系人地址, r_Pati.联系人电话, r_Pati.工作单位, r_Pati.合同单位id, r_Pati.单位电话, r_Pati.单位邮编, r_Pati.单位开户行,
                         r_Pati.单位帐号, r_Pati.担保人, r_Pati.担保额, r_Pati.担保性质, v_执行科室id, Null, Null, v_入院方式, Null, Null,
                         v_开嘱医生, r_Pati.籍贯, r_Pati.区域, v_开始时间, Null, Null, r_Pati.医疗付款方式, Null, Null, Null, Null, Null,
                         Null, r_Pati.险类, v_人员编号, v_人员姓名, 0, Null, Null, 0);
      End If;
    End If;
    --医嘱停止消息的处理
    If v_Stopadviceids Is Not Null Then
      v_Stopadviceids := Substr(v_Stopadviceids, 2);
      Select Max(a.Id)
      Into n_标记
      From 病人医嘱记录 A
      Where a.Id In (Select Column_Value From Table(f_Num2list(v_Stopadviceids))) And a.医嘱期效 = 0 And a.医嘱状态 = 8 And
            Nvl(a.执行标记, 0) <> -1 And a.病人来源 <> 3;
      If n_标记 Is Not Null Then
        Select Max(a.Id)
        Into n_Adviceid
        From 病人医嘱记录 A
        Where a.Id In (Select Column_Value From Table(f_Num2list(v_Stopadviceids))) And a.紧急标志 = 1 And a.医嘱期效 = 0 And
              a.医嘱状态 = 8 And Nvl(a.执行标记, 0) <> -1 And a.病人来源 <> 3;
        If n_Adviceid Is Not Null Then
          n_Adviceid := n_标记;
          Select Nvl(Max(0), 2)
          Into n_标记
          From 业务消息清单 A
          Where a.病人id = v_病人id And a.就诊id = v_主页id And a.类型编码 = 'ZLHIS_CIS_002' And a.优先程度 = 2 And a.是否已阅 = 0;
        Else
          Select Nvl(Max(0), 1)
          Into n_标记
          From 业务消息清单 A
          Where a.病人id = v_病人id And a.就诊id = v_主页id And a.类型编码 = 'ZLHIS_CIS_002' And a.是否已阅 = 0;
        End If;
        If n_标记 > 0 Then
          For R In (Select a.病人性质 As 性质, a.出院科室id As 科室id, a.当前病区id As 病区id
                    From 病案主页 A
                    Where a.病人id = v_病人id And a.主页id = v_主页id) Loop
            Zl_业务消息清单_Insert(v_病人id, v_主页id, r.科室id, r.病区id, r.性质, '有新停止医嘱。', '0010', 'ZLHIS_CIS_002', n_Adviceid, n_标记,
                             0, Null, r.病区id);
          End Loop;
        End If;
      End If;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱记录_校对;
/

--101951:梁经伙,2016-12-16,住院首页的诊断可以填写ICD附码
Create Or Replace Procedure Zl_病人诊断记录_Update
(
  Id_In       病人诊断记录.Id%Type,
  病人id_In   病人诊断记录.病人id%Type,
  主页id_In   病人诊断记录.主页id%Type,
  记录来源_In 病人诊断记录.记录来源%Type,
  诊断类型_In 病人诊断记录.诊断类型%Type,
  疾病id_In   病人诊断记录.疾病id%Type,
  诊断id_In   病人诊断记录.诊断id%Type,
  证候id_In   病人诊断记录.证候id%Type,
  诊断描述_In 病人诊断记录.诊断描述%Type,
  出院情况_In 病人诊断记录.出院情况%Type,
  是否未治_In 病人诊断记录.是否未治%Type,
  是否疑诊_In 病人诊断记录.是否疑诊%Type,
  诊断次序_In 病人诊断记录.诊断次序%Type := 1,
  备注_In     病人诊断记录.备注%Type := Null,
  入院病情_In 病人诊断记录.入院病情%Type := Null,
  发病时间_In 病人诊断记录.发病时间%Type := Null,
  附码id_In   病人诊断记录.疾病id%Type := Null
) Is
  --功能：更新病人诊断记录
  v_诊断id     病人诊断记录.Id%Type;
  d_记录日期   病人诊断记录.记录日期%Type;
  v_病人科室id 病人信息.当前科室id%Type;
  v_经治医师   人员表.姓名%Type;
  v_编码       疾病编码目录.编码%Type;
  n_Count      Number;
  v_发病时间   病人诊断记录.发病时间%Type;

  v_Temp     Varchar2(255);
  v_人员姓名 人员表.姓名%Type;
Begin
  --先判断当前诊断是指定的诊断来源的诊断，是则更新，否则新增
  Select Count(1) Into n_Count From 病人诊断记录 Where ID = Id_In And (记录来源 = 记录来源_In Or 记录来源_In Is Null);
  If n_Count = 1 Then
  
    --删除主诊断对应的附码诊断
    For Rs In (Select 病人id, 主页id, 诊断类型, 诊断次序, 编码序号
               From 病人诊断记录
               Where ID = Id_In And 记录来源 <> 4 And Nvl(编码序号, 1) = 1) Loop
      Delete From 病人诊断记录
      Where 病人id = Rs.病人id And Nvl(主页id, 0) = Nvl(Rs.主页id, 0) And 记录来源 <> 4 And 诊断次序 = Rs.诊断次序 And 诊断类型 = Rs.诊断类型 And
            Nvl(编码序号, 1) = 2;
    End Loop;
  
    Update 病人诊断记录
    Set 记录来源 = 记录来源_In, 诊断次序 = 诊断次序_In, 疾病id = 疾病id_In, 诊断id = 诊断id_In, 证候id = 证候id_In, 诊断描述 = 诊断描述_In, 入院病情 = 入院病情_In,
        出院情况 = 出院情况_In, 是否未治 = 是否未治_In, 是否疑诊 = 是否疑诊_In, 备注 = 备注_In, 发病时间 = 发病时间_In
    Where ID = Id_In
    Returning 记录日期 Into d_记录日期;
  Else
    Select 病人诊断记录_Id.Nextval Into v_诊断id From Dual;
  
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    d_记录日期 := Sysdate;
    Insert Into 病人诊断记录
      (ID, 病人id, 主页id, 记录来源, 诊断类型, 诊断次序, 疾病id, 诊断id, 证候id, 诊断描述, 入院病情, 出院情况, 是否未治, 是否疑诊, 记录日期, 记录人, 备注, 发病时间)
      Select v_诊断id, 病人id, 主页id, 记录来源_In, 诊断类型_In, 诊断次序_In, 疾病id_In, 诊断id_In, 证候id_In, 诊断描述_In, 入院病情_In, 出院情况_In,
             是否未治_In, 是否疑诊_In, Sysdate, v_人员姓名, 备注_In, 发病时间_In
      From 病人诊断记录
      Where ID = Id_In;
  End If;

  If 附码id_In Is Not Null Then
    Insert Into 病人诊断记录
      (ID, 病人id, 主页id, 记录来源, 诊断类型, 诊断次序, 疾病id, 诊断id, 证候id, 诊断描述, 入院病情, 出院情况, 是否未治, 是否疑诊, 记录日期, 记录人, 备注, 发病时间, 编码序号)
      Select 病人诊断记录_Id.Nextval, 病人id, 主页id, 记录来源_In, 诊断类型_In, 诊断次序_In, 附码id_In, 诊断id_In, 证候id_In, 诊断描述_In, 入院病情_In,
             出院情况_In, 是否未治_In, 是否疑诊_In, Sysdate, v_人员姓名, 备注_In, 发病时间_In, 2
      From 病人诊断记录
      Where ID = Id_In;
  End If;

  --如果是门诊第一诊断则更新病人挂号记录.发病时间
  v_发病时间 := 发病时间_In;
  If 诊断类型_In = 1 And 诊断次序_In = 1 Then
    If 发病时间_In Is Null Then
      --检查中医的发病时间，有则取中医的，否则清空
      Select Max(发病时间)
      Into v_发病时间
      From 病人诊断记录
      Where 病人id = 病人id_In And 主页id = 主页id_In And 诊断类型 = 11 And 诊断次序 = 1;
    End If;
    If v_发病时间 Is Null Then
      --如果都为NULL，则取挂号记录中的
      Select Max(发病时间) Into v_发病时间 From 病人挂号记录 Where 病人id = 病人id_In And ID = 主页id_In;
    End If;
    Update 病人挂号记录 Set 发病时间 = v_发病时间 Where 病人id = 病人id_In And ID = 主页id_In;
  End If;
  If 诊断类型_In = 11 And 诊断次序_In = 1 Then
    --如果是中医，则判断是否填写了西医的发病时间，没有填写，则修改，否则以西医发病时间为准
    Select Count(*)
    Into n_Count
    From 病人诊断记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 诊断类型 = 1 And 诊断次序 = 1 And 发病时间 Is Not Null;
    If n_Count = 0 Then
      If v_发病时间 Is Null Then
        --如果都为NULL，则取挂号记录中的
        Select Max(发病时间) Into v_发病时间 From 病人挂号记录 Where 病人id = 病人id_In And ID = 主页id_In;
      End If;
      Update 病人挂号记录 Set 发病时间 = v_发病时间 Where 病人id = 病人id_In And ID = 主页id_In;
    End If;
  End If;

  --如果是入院第一诊断，则判断是否是单病种
  If 诊断类型_In = 2 And 诊断次序_In = 1 And 记录来源_In = 3 Then
    If 疾病id_In Is Not Null Then
      Select 编码 Into v_编码 From 疾病编码目录 Where ID = 疾病id_In;
      Select Max(Upper(编码))
      Into v_编码
      From 单病种目录
      Where Instr('/' || Replace(Upper(Icd编码), ' ', '') || '/', '/' || Upper(v_编码) || '/') > 0 And Rownum < 2;
    Else
      v_编码 := '';
    End If;
    Update 病案主页 Set 单病种 = v_编码 Where 病人id = 病人id_In And 主页id = 主页id_In;
  End If;

  --根据传入的主页id_In查询挂号记录来区分是门诊首页还是住院首页调用
  Begin
    Select 执行人, 执行部门id Into v_病人科室id, v_经治医师 From 病人挂号记录 Where ID = 主页id_In;
    Zl_电子病历时机_Insert(病人id_In, 主页id_In, 1, '诊断', v_病人科室id, v_经治医师, d_记录日期, d_记录日期);
  Exception
    When Others Then
      Null;
  End;
  If v_病人科室id Is Null And (诊断类型_In <> 1 Or 诊断类型_In <> 11) Then
    Begin
      Select 出院科室id, 住院医师
      Into v_病人科室id, v_经治医师
      From 病案主页
      Where 病人id = 病人id_In And 主页id = 主页id_In;
      Zl_电子病历时机_Insert(病人id_In, 主页id_In, 2, '诊断', v_病人科室id, v_经治医师, d_记录日期, d_记录日期);
    Exception
      When Others Then
        Null;
    End;
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人诊断记录_Update;
/

--101951:梁经伙,2016-12-15,住院首页也需要存储ICD附码
CREATE OR REPLACE Procedure Zl_病人诊断记录_Insert
(
  病人id_In   病人诊断记录.病人id%Type,
  主页id_In   病人诊断记录.主页id%Type,
  记录来源_In 病人诊断记录.记录来源%Type,
  病历id_In   病人诊断记录.病历id%Type,
  诊断类型_In 病人诊断记录.诊断类型%Type,
  疾病id_In   病人诊断记录.疾病id%Type,
  诊断id_In   病人诊断记录.诊断id%Type,
  证候id_In   病人诊断记录.证候id%Type,
  诊断描述_In 病人诊断记录.诊断描述%Type,
  出院情况_In 病人诊断记录.出院情况%Type,
  是否未治_In 病人诊断记录.是否未治%Type,
  是否疑诊_In 病人诊断记录.是否疑诊%Type,
  记录日期_In 病人诊断记录.记录日期%Type,
  医嘱id_In   Varchar2 := Null,
  诊断次序_In 病人诊断记录.诊断次序%Type := 1,
  备注_In     病人诊断记录.备注%Type := Null,
  入院病情_In 病人诊断记录.入院病情%Type := Null,
  发病时间_In 病人诊断记录.发病时间%Type := Null,
  记录人_In   病人诊断记录.记录人%Type := Null,
  Id_In       病人诊断记录.Id%Type := Null,
  附码id_In   病人诊断记录.疾病id%Type := Null
) Is
  --功能：插入病人诊断记录
  --医嘱id_In=与当前诊断相关联的，用","间隔的医嘱ID串
  v_诊断id 病人诊断记录.Id%Type;
  v_医嘱id 病人医嘱记录.Id%Type;

  v_病人科室id 病人信息.当前科室id%Type;
  v_经治医师   人员表.姓名%Type;
  v_编码       疾病编码目录.编码%Type;
  n_Count      Number;
  v_发病时间   病人诊断记录.发病时间%Type;

  v_Temp     Varchar2(255);
  v_人员姓名 人员表.姓名%Type;
Begin
  --当前操作人员
  If 记录人_In Is Null Then
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  Else
    v_人员姓名 := 记录人_In;
  End If;

  If Id_In Is Null Then
    Select 病人诊断记录_Id.Nextval Into v_诊断id From Dual;
  Else
    v_诊断id := Id_In;
  End If;

  v_医嘱id := Zl_To_Number(医嘱id_In);
  If v_医嘱id = 0 Then
    v_医嘱id := Null;
  End If;

  Insert Into 病人诊断记录
    (ID, 病人id, 主页id, 记录来源, 病历id, 诊断类型, 诊断次序, 疾病id, 诊断id, 证候id, 诊断描述, 入院病情, 出院情况, 是否未治, 是否疑诊, 
         记录日期, 记录人, 医嘱id, 备注, 发病时间)
  Values
    (v_诊断id, 病人id_In, 主页id_In, 记录来源_In, 病历id_In, 诊断类型_In, 诊断次序_In, 疾病id_In, 诊断id_In, 证候id_In, 诊断描述_In, 入院病情_In, 出院情况_In,
     是否未治_In, 是否疑诊_In, 记录日期_In, v_人员姓名, v_医嘱id, 备注_In, 发病时间_In);

 If 附码id_In Is Not Null Then
    Insert Into 病人诊断记录
      (Id, 病人id, 主页id, 记录来源, 病历id, 诊断类型, 诊断次序,疾病id, 诊断id, 证候id, 诊断描述, 入院病情, 出院情况, 是否未治, 是否疑诊, 
          记录日期, 记录人, 医嘱id, 备注, 发病时间,编码序号)
      Select 病人诊断记录_Id.Nextval, 病人id_In, 主页id_In, 记录来源_In, 病历id_In, 诊断类型_In, 诊断次序_In, 附码id_In, 诊断id_In, 证候id_In, 诊断描述_In,
           入院病情_In, 出院情况_In, 是否未治_In, 是否疑诊_In, 记录日期_In, v_人员姓名, v_医嘱id, 备注_In, 发病时间_In,2
      From Dual;
  End If;

  --如果是门诊第一诊断则更新病人挂号记录.发病时间
  v_发病时间 := 发病时间_In;
  If 诊断类型_In = 1 And 诊断次序_In = 1 Then
    If 发病时间_In Is Null Then
      --检查中医的发病时间，有则取中医的，否则清空
      Select Max(发病时间)
      Into v_发病时间
      From 病人诊断记录
      Where 病人id = 病人id_In And 主页id = 主页id_In And 诊断类型 = 11 And 诊断次序 = 1;
    End If;
    If v_发病时间 Is Null Then
      --如果都为NULL，则取挂号记录中的
      Select Max(发病时间) Into v_发病时间 From 病人挂号记录 Where 病人id = 病人id_In And ID = 主页id_In;
    End If;
    Update 病人挂号记录 Set 发病时间 = v_发病时间 Where 病人id = 病人id_In And ID = 主页id_In;
  End If;
  If 诊断类型_In = 11 And 诊断次序_In = 1 Then
    --如果是中医，则判断是否填写了西医的发病时间，没有填写，则修改，否则以西医发病时间为准
    Select Count(*)
    Into n_Count
    From 病人诊断记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 诊断类型 = 1 And 诊断次序 = 1 And 发病时间 Is Not Null;
    If n_Count = 0 Then
      If v_发病时间 Is Null Then
        --如果都为NULL，则取挂号记录中的
        Select Max(发病时间) Into v_发病时间 From 病人挂号记录 Where 病人id = 病人id_In And ID = 主页id_In;
      End If;
      Update 病人挂号记录 Set 发病时间 = v_发病时间 Where 病人id = 病人id_In And ID = 主页id_In;
    End If;
  End If;

  If 医嘱id_In Is Not Null Then
    For r_Advice In (Select Column_Value As 医嘱id From Table(Cast(f_Num2list(医嘱id_In) As Zltools.t_Numlist))) Loop
      Insert Into 病人诊断医嘱 (诊断id, 医嘱id) Values (v_诊断id, r_Advice.医嘱id);
    End Loop;
  End If;

  --如果是入院第一诊断，则判断是否是单病种
  If 诊断类型_In = 2 And 诊断次序_In = 1 And 记录来源_In = 3 Then
    If 疾病id_In Is Not Null Then
      Select 编码 Into v_编码 From 疾病编码目录 Where ID = 疾病id_In;
      Select Max(Upper(编码))
      Into v_编码
      From 单病种目录
      Where Instr('/' || Replace(Upper(Icd编码), ' ', '') || '/', '/' || Upper(v_编码) || '/') > 0 And Rownum < 2;
    Else
      v_编码 := '';
    End If;
    Update 病案主页 Set 单病种 = v_编码 Where 病人id = 病人id_In And 主页id = 主页id_In;
  End If;

  --根据传入的主页id_In查询挂号记录来区分是门诊首页还是住院首页调用
  Begin
    Select 执行人, 执行部门id Into v_病人科室id, v_经治医师 From 病人挂号记录 Where ID = 主页id_In;
    Zl_电子病历时机_Insert(病人id_In, 主页id_In, 1, '诊断', v_病人科室id, v_经治医师, 记录日期_In, 记录日期_In);
  Exception
    When Others Then
      Null;
  End;
  If v_病人科室id Is Null And (诊断类型_In <> 1 Or 诊断类型_In <> 11) Then
    Begin
      Select 出院科室id, 住院医师
      Into v_病人科室id, v_经治医师
      From 病案主页
      Where 病人id = 病人id_In And 主页id = 主页id_In;
      Zl_电子病历时机_Insert(病人id_In, 主页id_In, 2, '诊断', v_病人科室id, v_经治医师, 记录日期_In, 记录日期_In);
    Exception
      When Others Then
        Null;
    End;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人诊断记录_Insert;
/

--103209:刘尔旋,2016-12-15,服务窗医保实时结算
Create Or Replace Procedure Zl_病人结算记录_Update
(
  结帐id_In        病人预交记录.结帐id%Type,
  保险结算_In      Varchar2, --"结算方式|结算金额||....."
  结帐_In          Number := 0,
  缺省结算方式_In  Varchar2 := Null,
  缺省冲预交_In    Number := 0, --0-用现金缴款,1:剩于款项用冲预交支付(门诊预交),2-剩于款项用冲预交支付(住院预交)
  卡类别id_In      病人预交记录.卡类别id%Type := Null,
  结算卡序号_In    病人预交记录.结算卡序号%Type := Null,
  卡号_In          病人预交记录.卡号%Type := Null,
  交易流水号_In    病人预交记录.交易流水号%Type := Null,
  交易说明_In      病人预交记录.交易说明%Type := Null,
  合作单位_In      病人预交记录.合作单位%Type := Null,
  冲预交病人ids_In Varchar2 := Null,
  仅修正医保_In    Number := 0
) As
  --该游标为要删除的由费用记录产生的结算记录

  Cursor c_Del Is
    Select a.Id, a.记录性质, a.冲预交, a.结算方式, b.性质, a.预交类别
    From 病人预交记录 A, 结算方式 B
    Where a.结算方式 = b.名称 And a.结帐id = 结帐id_In;

  Cursor c_Del_医保 Is
    Select a.Id, a.记录性质, a.冲预交, a.结算方式, b.性质, a.预交类别
    From 病人预交记录 A, 结算方式 B
    Where a.结算方式 = b.名称 And b.性质 In (3, 4) And a.结帐id = 结帐id_In;

  --相关信息
  v_No         病人预交记录.No%Type;
  v_病人id     住院费用记录.病人id%Type;
  v_主页id     住院费用记录.主页id%Type;
  v_发生时间   住院费用记录.发生时间%Type;
  v_登记时间   住院费用记录.登记时间%Type;
  v_操作员编号 住院费用记录.操作员编号%Type;
  v_操作员姓名 住院费用记录.操作员姓名%Type;

  v_冲预交病人ids Varchar2(4000);

  --本次结算变量
  v_金额合计 病人预交记录.冲预交%Type;

  --保险结算
  v_保险结算 Varchar2(255);
  v_当前结算 Varchar2(50);
  v_结算方式 病人预交记录.结算方式%Type;
  v_结算金额 病人预交记录.冲预交%Type;

  v_记录性质 病人预交记录.记录性质%Type;
  v_缺省     病人预交记录.结算方式%Type;

  --分币处理及误差变量
  v_现金金额   病人预交记录.冲预交%Type;
  v_Cashcented 病人预交记录.冲预交%Type;
  v_误差金额   病人预交记录.冲预交%Type;
  v_费用id     住院费用记录.Id%Type;
  v_序号       住院费用记录.序号%Type;
  v_收费类别   住院费用记录.收费类别%Type;
  v_收费细目id 住院费用记录.收费细目id%Type;
  v_收入项目id 住院费用记录.收入项目id%Type;
  v_收据费目   住院费用记录.收据费目%Type;
  n_Noexists   Number(3);
  n_医疗小组id 住院费用记录.医疗小组id%Type;
  n_结算序号   病人预交记录.结算序号%Type;
  n_费用状态   门诊费用记录.费用状态%Type;
  n_预交金额   病人预交记录.金额%Type;
  n_当前金额   病人预交记录.金额%Type;
  v_误差项     结算方式.名称%Type;

  --临时变量
  Err_Item Exception;
  v_Err_Msg  Varchar2(255);
  n_组id     财务缴款分组.Id%Type;
  n_执行状态 门诊费用记录.执行状态%Type;
Begin
  --如果缺省结算方式为空，则取现金结算方式
  If 缺省结算方式_In Is Null Then
    Begin
      Select 名称 Into v_缺省 From 结算方式 Where 性质 = 1 And Rownum < 2;
    Exception
      When Others Then
        v_缺省 := '现金';
    End;
  Else
    v_缺省 := 缺省结算方式_In;
  End If;

  --取得本次结算的相关信息
  If Nvl(结帐_In, 0) = 1 Then
    Select NO, 病人id, 收费时间, 操作员编号, 操作员姓名, 缴款组id, 0
    Into v_No, v_病人id, v_登记时间, v_操作员编号, v_操作员姓名, n_组id, n_执行状态
    From 病人结帐记录
    Where ID = 结帐id_In;
  Else
    Begin
      n_Noexists := 0;
      Select NO, 病人id, 登记时间, 操作员编号, 操作员姓名, 缴款组id, 执行状态, 费用状态
      Into v_No, v_病人id, v_登记时间, v_操作员编号, v_操作员姓名, n_组id, n_执行状态, n_费用状态
      From 门诊费用记录
      Where 结帐id = 结帐id_In And Rownum < 2;
    Exception
      When Others Then
        n_Noexists := 1;
    End;
    If n_Noexists = 1 Then
      --费用记录不存在，从补充记录中找
      Select NO, 病人id, 登记时间, 操作员编号, 操作员姓名, 缴款组id, 费用状态
      Into v_No, v_病人id, v_登记时间, v_操作员编号, v_操作员姓名, n_组id, n_费用状态
      From 费用补充记录
      Where 结算id = 结帐id_In And Rownum < 2;
    End If;
    If Nvl(n_费用状态, 0) = 1 Then
      --异常单据为空:
      v_缺省 := Null;
    End If;
  
    Begin
      --20051027 陈东
      Select 记录性质
      Into v_记录性质
      From 病人预交记录
      Where 结帐id = 结帐id_In And Rownum = 1 And Mod(记录性质, 10) <> 1;
    Exception
      When Others Then
        v_记录性质 := -1;
    End;
    If v_记录性质 = -1 Then
      Begin
        Select Decode(记录性质, 1, 3, 11, 3, 4, 4, 记录性质)
        Into v_记录性质
        From 门诊费用记录
        Where 结帐id = 结帐id_In And Rownum = 1;
      Exception
        When Others Then
          --可能是卡费
          Select 记录性质 Into v_记录性质 From 住院费用记录 Where 结帐id = 结帐id_In And Rownum = 1;
      End;
    End If;
  End If;

  If Nvl(v_病人id, 0) <> 0 And Nvl(结帐_In, 0) = 1 Then
    Select 主页id Into v_主页id From 病人信息 Where 病人id = v_病人id;
  End If;
  Select 结算序号 Into n_结算序号 From 病人预交记录 Where 结帐id = 结帐id_In And Rownum = 1;

  v_冲预交病人ids := Nvl(冲预交病人ids_In, v_病人id);

  ----回退缴款,预交不动,因为没有改冲预交的
  --收费未最未最终完成的,代表按异常单据修正,不处理人员缴款余额
  v_金额合计 := 0;
  If Nvl(仅修正医保_In, 0) = 0 Then
    For r_Del In c_Del Loop
      If r_Del.记录性质 Not In (1, 11) Then
        If Nvl(n_费用状态, 0) <> 1 Then
          Update 人员缴款余额
          Set 余额 = Nvl(余额, 0) - r_Del.冲预交
          Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = r_Del.结算方式;
        
          If Sql%RowCount = 0 Then
            Insert Into 人员缴款余额
              (收款员, 结算方式, 性质, 余额)
            Values
              (v_操作员姓名, r_Del.结算方式, 1, -1 * r_Del.冲预交);
          End If;
        End If;
        v_金额合计 := v_金额合计 + r_Del.冲预交;
        Delete From 病人预交记录 Where ID = r_Del.Id;
      Else
        --检查是否冲预交
        If Nvl(缺省冲预交_In, 0) <> 0 Then
          v_金额合计 := v_金额合计 + r_Del.冲预交;
          If Nvl(n_费用状态, 0) <> 1 Then
            Update 病人余额
            Set 预交余额 = Nvl(预交余额, 0) + Nvl(r_Del.冲预交, 0)
            Where 病人id = v_病人id And 类型 = Nvl(r_Del.预交类别, 2);
            If Sql%NotFound Then
              Insert Into 病人余额
                (病人id, 性质, 预交余额, 费用余额, 类型)
              Values
                (v_病人id, 1, Nvl(r_Del.冲预交, 0), 0, Nvl(r_Del.预交类别, 2));
            End If;
          End If;
          If r_Del.记录性质 = 1 Then
            Update 病人预交记录 Set 冲预交 = 0 Where ID = r_Del.Id;
          Else
            Delete 病人预交记录 Where ID = r_Del.Id;
          End If;
        End If;
      End If;
    End Loop;
  Else
    For r_Del In c_Del_医保 Loop
      If r_Del.记录性质 Not In (1, 11) Then
        If Nvl(n_费用状态, 0) <> 1 Then
          Update 人员缴款余额
          Set 余额 = Nvl(余额, 0) - r_Del.冲预交
          Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = r_Del.结算方式;
        
          If Sql%RowCount = 0 Then
            Insert Into 人员缴款余额
              (收款员, 结算方式, 性质, 余额)
            Values
              (v_操作员姓名, r_Del.结算方式, 1, -1 * r_Del.冲预交);
          End If;
        End If;
        v_金额合计 := v_金额合计 + r_Del.冲预交;
        Delete From 病人预交记录 Where ID = r_Del.Id;
      Else
        --检查是否冲预交
        If Nvl(缺省冲预交_In, 0) <> 0 Then
          v_金额合计 := v_金额合计 + r_Del.冲预交;
          If Nvl(n_费用状态, 0) <> 1 Then
            Update 病人余额
            Set 预交余额 = Nvl(预交余额, 0) + Nvl(r_Del.冲预交, 0)
            Where 病人id = v_病人id And 类型 = Nvl(r_Del.预交类别, 2);
            If Sql%NotFound Then
              Insert Into 病人余额
                (病人id, 性质, 预交余额, 费用余额, 类型)
              Values
                (v_病人id, 1, Nvl(r_Del.冲预交, 0), 0, Nvl(r_Del.预交类别, 2));
            End If;
          End If;
          If r_Del.记录性质 = 1 Then
            Update 病人预交记录 Set 冲预交 = 0 Where ID = r_Del.Id;
          Else
            Delete 病人预交记录 Where ID = r_Del.Id;
          End If;
        End If;
      End If;
    End Loop;
  End If;

  --------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------
  --产生医保支付结算
  If 保险结算_In Is Not Null Then
    --各个保险结算
    v_保险结算 := 保险结算_In || '||';
    While v_保险结算 Is Not Null Loop
      v_当前结算 := Substr(v_保险结算, 1, Instr(v_保险结算, '||') - 1);
    
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算性质)
      Values
        (病人预交记录_Id.Nextval, Decode(结帐_In, 1, 2, v_记录性质), v_No, 1, v_病人id, v_主页id, '保险部份', v_结算方式, v_登记时间, v_操作员编号,
         v_操作员姓名, v_结算金额, 结帐id_In, n_组id, n_结算序号, Mod(Decode(结帐_In, 1, 2, v_记录性质), 10));
    
      v_金额合计 := v_金额合计 - v_结算金额;
    
      v_保险结算 := Substr(v_保险结算, Instr(v_保险结算, '||') + 2);
    End Loop;
  End If;
  --剩余部分用预交
  If Nvl(缺省冲预交_In, 0) <> 0 And v_金额合计 <> 0 Then
  
    n_预交金额 := v_金额合计;
    For c_预交 In (Select *
                 From (Select a.Id, a.病人id, a.记录状态, a.预交类别, a.No, Nvl(a.金额, 0) As 金额
                        From 病人预交记录 A,
                             (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                               From 病人预交记录 A
                               Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And
                                     a.病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And
                                     Nvl(a.预交类别, 2) = 缺省冲预交_In
                               Group By NO
                               Having Sum(Nvl(a.金额, 0)) <> 0) B
                        Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And
                              a.结算方式 Not In (Select 名称 From 结算方式 Where 性质 = 5) And a.No = b.No And
                              a.病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And
                              Nvl(a.预交类别, 2) = 缺省冲预交_In
                        Union All
                        Select 0 As ID, Max(病人id) As 病人id, 记录状态, 预交类别, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额

                        
                        From 病人预交记录
                        Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(金额, 0) <> Nvl(冲预交, 0) And
                              病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And Nvl(预交类别, 2) = 缺省冲预交_In
                         Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
                        Group By 记录状态, NO, 预交类别)
                 Order By Decode(病人id, Nvl(v_病人id, 0), 0, 1), ID, NO) Loop
    
      n_当前金额 := Case
                  When c_预交.金额 - n_预交金额 < 0 Then
                   c_预交.金额
                  Else
                   n_预交金额
                End;
    
      If c_预交.Id <> 0 Then
        --第一次冲预交(填上结帐ID,金额为0)
        Update 病人预交记录
        Set 冲预交 = 0, 结帐id = 结帐id_In, 结算序号 = n_结算序号, 结算性质 = Mod(Decode(结帐_In, 1, 2, v_记录性质), 10)
        Where ID = c_预交.Id;
      End If;
      --冲上次剩余额
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 预交类别, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号,
         冲预交, 结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 预交类别, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
               v_登记时间, v_操作员姓名, v_操作员编号, n_当前金额, 结帐id_In, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, n_结算序号,
               Mod(Decode(结帐_In, 1, 2, v_记录性质), 10)
        From 病人预交记录
        Where NO = c_预交.No And 记录状态 = c_预交.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
    
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - n_当前金额
      Where 病人id = c_预交.病人id And 性质 = 1 And 类型 = Nvl(c_预交.预交类别, 2);
    
      --检查是否已经处理完
      If c_预交.金额 < n_预交金额 Then
        n_预交金额 := n_预交金额 - c_预交.金额;
      Else
        n_预交金额 := 0;
      End If;
    
      If n_预交金额 = 0 Then
        Exit;
      End If;
    End Loop;
    If n_预交金额 <> 0 Then
      v_Err_Msg := '[ZLSOFT]预交余不够支付本次支付金额,不能继续操作！[ZLSOFT]';
      Raise Err_Item;
    End If;
    Delete From 病人余额 Where 病人id = v_病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
    v_金额合计 := n_预交金额;
  End If;

  --剩余部份全部用缺省结算方式结算，(小于零也不进行额外处理)
  If v_金额合计 <> 0 Then
    Update 病人预交记录
    Set 冲预交 = 冲预交 + v_金额合计, 卡类别id = 卡类别id_In, 结算卡序号 = 结算卡序号_In, 卡号 = 卡号_In, 交易流水号 = 交易流水号_In, 交易说明 = 交易说明_In,
        合作单位 = 合作单位_In, 结算序号 = n_结算序号
    
    Where 结帐id = 结帐id_In And Nvl(结算方式, 'LXH_Test') = Nvl(v_缺省, 'LXH_Test') And 记录性质 = Decode(结帐_In, 1, 2, v_记录性质);
    If Sql%RowCount = 0 Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 卡类别id, 结算卡序号, 卡号, 交易流水号,
         交易说明, 合作单位, 结算性质)
      Values
        (病人预交记录_Id.Nextval, Decode(结帐_In, 1, 2, v_记录性质), v_No, 1, v_病人id, v_主页id, '保险结算修正', v_缺省, v_登记时间, v_操作员编号,
         v_操作员姓名, v_金额合计, 结帐id_In, n_组id, n_结算序号, 卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, 合作单位_In,
         Mod(Decode(结帐_In, 1, 2, v_记录性质), 10));
    End If;
  
    --挂号结算,分币处理(由于挂号界面没有预结算,所以在此过程中根据分币处理规则来修正)
    If v_记录性质 = 4 Then
      Begin
        Select a.冲预交
        Into v_现金金额
        From 病人预交记录 A, 结算方式 B
        Where a.结算方式 = b.名称 And b.性质 = 1 And a.结帐id = 结帐id_In;
      Exception
        When Others Then
          v_现金金额 := 0;
      End;
      If Floor(Abs(v_现金金额) * 10) <> Abs(v_现金金额) * 10 Then
        --误差处理
        v_Cashcented := Zl_Cent_Money(v_现金金额);
      
        v_误差金额 := v_Cashcented - v_现金金额;
        If v_误差金额 <> 0 Then
          Begin
            Select 名称 Into v_误差项 From 结算方式 Where 性质 = 9;
          Exception
            When Others Then
              v_误差项 := Null;
          End;
          If v_误差项 Is Not Null Then
            --10.34之后误差数据
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算性质)
            Values
              (病人预交记录_Id.Nextval, Decode(结帐_In, 1, 2, v_记录性质), v_No, 1, v_病人id, v_主页id, '误差费', v_误差项, v_登记时间, v_操作员编号,
               v_操作员姓名, v_误差金额, 结帐id_In, n_组id, n_结算序号, Mod(Decode(结帐_In, 1, 2, v_记录性质), 10));
          Else
            --1.更新预交记录(一定存在记录)
            Update 病人预交记录
            Set 冲预交 = v_Cashcented
            Where 结算方式 = (Select 名称 From 结算方式 Where 性质 = 1 And Rownum = 1) And 结帐id = 结帐id_In;
          
            --2.生成误差费用记录(注:计算单位记录的是号别,所以不取误差项的)
            Begin
              Select a.类别, a.Id, c.Id, c.收据费目
              Into v_收费类别, v_收费细目id, v_收入项目id, v_收据费目
              From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费特定项目 D
              Where d.特定项目 = '误差项' And d.收费细目id = a.Id And a.Id = b.收费细目id And b.收入项目id = c.Id And
                    Sysdate Between b.执行日期 And Nvl(b.终止日期, To_Date('3000-01-01', 'YYYY-MM-DD'));
            Exception
              When Others Then
                v_Err_Msg := '不能正确读取收费误差项的信息，请先检查该项目是否设置正确。';
                Raise Err_Item;
            End;
            If Nvl(结帐_In, 0) = 1 Then
              Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
              Select Max(序号) + 1, Max(发生时间) Into v_序号, v_发生时间 From 住院费用记录 Where 结帐id = 结帐id_In;
              n_医疗小组id := Zl_医疗小组_Get(0, v_操作员姓名, v_病人id, v_主页id, v_发生时间);
            
              Insert Into 住院费用记录
                (ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 床号, 姓名, 性别, 年龄, 病人病区id, 病人科室id, 费别, 收费类别,
                 收费细目id, 计算单位, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 记帐费用, 划价人, 开单部门id, 开单人, 发生时间,
                 登记时间, 执行部门id, 执行人, 执行状态, 结帐id, 结帐金额, 操作员编号, 操作员姓名, 是否上传, 缴款组id, 医疗小组id)
                Select v_费用id, 记录性质, NO, 实际票号, 记录状态, v_序号, Null, Null, 门诊标志, 病人id, 标识号, 床号, 姓名, 性别, 年龄, 病人病区id, 病人科室id,
                       费别, v_收费类别, v_收费细目id, 计算单位, 发药窗口, 1, 1, 加班标志, 9, v_收入项目id, v_收据费目, v_误差金额, v_误差金额, v_误差金额, 记帐费用,
                       划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 执行状态, 结帐id_In, v_误差金额, 操作员编号, 操作员姓名, 1, 缴款组id,
                       Decode(n_医疗小组id, Null, 医疗小组id, n_医疗小组id)
                From 住院费用记录
                Where 结帐id = 结帐id_In And Rownum = 1;
            Else
              Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
              Select Max(序号) + 1 Into v_序号 From 门诊费用记录 Where 结帐id = 结帐id_In;
              Insert Into 门诊费用记录
                (ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id,
                 计算单位, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 记帐费用, 划价人, 开单部门id, 开单人, 发生时间, 登记时间,
                 执行部门id, 执行人, 执行状态, 费用状态, 结帐id, 结帐金额, 操作员编号, 操作员姓名, 是否上传, 缴款组id)
                Select v_费用id, 记录性质, NO, 实际票号, 记录状态, v_序号, Null, Null, 门诊标志, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 病人科室id, 费别,
                       v_收费类别, v_收费细目id, 计算单位, 发药窗口, 1, 1, 加班标志, 9, v_收入项目id, v_收据费目, v_误差金额, v_误差金额, v_误差金额, 记帐费用, 划价人,
                       开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 执行状态, 费用状态, 结帐id_In, v_误差金额, 操作员编号, 操作员姓名, 1, 缴款组id
                From 门诊费用记录
                Where 结帐id = 结帐id_In And Rownum = 1;
            End If;
          End If;
          --3.更新汇总表
          --只可能产生误差金额的变化.仅为了变量处理方便而用游标
        End If;
      End If;
    End If;
  End If;

  --最后再处理"人员缴款余额"(没有动冲预交那部分,所以"病人余额"的预交余额不用更新)
  For r_Del In c_Del Loop
    If r_Del.记录性质 Not In (1, 11) Then
      If Nvl(n_费用状态, 0) <> 1 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + r_Del.冲预交
        Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = r_Del.结算方式;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (v_操作员姓名, r_Del.结算方式, 1, r_Del.冲预交);
        End If;
      End If;
    End If;
  End Loop;
  Delete From 人员缴款余额 Where 性质 = 1 And 收款员 = v_操作员姓名 And Nvl(余额, 0) = 0;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人结算记录_Update;
/

--103232:冉俊明,2016-12-15,临床出诊安排，按序号时段开放停诊安排。
Create Or Replace Procedure Zl_临床出诊停诊_Audit
(
  操作类型_In Number,
  Id_In       临床出诊停诊记录.Id%Type,
  审批人_In   临床出诊停诊记录.审批人%Type := Null,
  审批时间_In 临床出诊停诊记录.审批时间%Type := Null
) As
  --功能：审核停诊安排
  --参数：
  --       状态_In：1-审核，2-取消审核
  n_Count Number;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  If Nvl(操作类型_In, 0) = 1 Then
    --审核
    Select Count(1) Into n_Count From 临床出诊停诊记录 Where ID = Id_In;
    If Nvl(n_Count, 0) = 0 Then
      v_Error := '该申请已被取消申请，请刷新后查看...';
      Raise Err_Custom;
    End If;
  
    Select Count(1) Into n_Count From 临床出诊停诊记录 Where ID = Id_In And 审批人 Is Null;
    If Nvl(n_Count, 0) = 0 Then
      v_Error := '该申请已被审核，不能再次审核！';
      Raise Err_Custom;
    End If;
  
    Update 临床出诊停诊记录 Set 审批人 = 审批人_In, 审批时间 = 审批时间_In Where ID = Id_In;
  
    --对出诊记录进行停诊标记
    For c_记录 In (Select a.Id,
                        Case
                          When a.开始时间 < b.开始时间 Then
                           b.开始时间
                          Else
                           a.开始时间
                        End As 停诊开始时间,
                        Case
                          When a.终止时间 > b.终止时间 Then
                           b.终止时间
                          Else
                           a.终止时间
                        End As 停诊终止时间, b.停诊原因, c.号码
                 From 临床出诊记录 A, 临床出诊停诊记录 B, 临床出诊号源 C
                 Where ((a.替诊医生姓名 Is Null And a.医生id Is Not Null And a.医生姓名 = b.申请人) Or
                       (a.替诊医生姓名 Is Not Null And a.替诊医生id Is Not Null And a.替诊医生姓名 = b.申请人)) And a.号源id = c.Id And
                       b.Id = Id_In And Not (a.开始时间 > b.终止时间 Or a.终止时间 < b.开始时间)
                      --只处理已发布了的
                       And Exists (Select 1
                        From 临床出诊安排 C, 临床出诊表 D
                        Where c.出诊id = d.Id And c.Id = a.安排id And d.发布时间 Is Not Null)) Loop
    
      Update 临床出诊记录
      Set 停诊开始时间 = c_记录.停诊开始时间, 停诊终止时间 = c_记录.停诊终止时间, 停诊原因 = c_记录.停诊原因
      Where ID = c_记录.Id;
    
      --调整"临床出诊序号控制.是否停诊"为1
      Update 临床出诊序号控制 A
      Set 是否停诊 = 1
      Where 记录id = c_记录.Id And 开始时间 Between c_记录.停诊开始时间 And c_记录.停诊终止时间 And Exists
       (Select 1 From 临床出诊记录 Where ID = a.记录id And Nvl(是否序号控制, 0) = 1 And Nvl(是否分时段, 0) = 1);
    
      Insert Into 病人服务信息记录
        (ID, 通知类型, 记录id, 挂号id, 号源id, 号码, 科室id, 项目id, 医生id, 医生姓名, 病人id, 登记人, 登记时间)
        Select 病人服务信息记录_Id.Nextval, 1, a.Id, b.Id, c.Id, c.号码, c.科室id, a.项目id, a.医生id, a.医生姓名, b.病人id, 审批人_In, 审批时间_In
        From 临床出诊记录 A, 病人挂号记录 B, 临床出诊号源 C
        Where a.Id = b.出诊记录id And a.号源id = c.Id And b.记录状态 = 1 And a.Id = c_记录.Id And
              (b.记录性质 = 1 And b.发生时间 Between a.停诊开始时间 And a.停诊终止时间 Or
              b.记录性质 = 2 And b.预约时间 Between a.停诊开始时间 And a.停诊终止时间);
    
      --消息推送
      -- 停诊类型(1-停诊,2-取消停诊),出诊记录ID,停诊号码
      Begin
        Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
          Using 17, 1 || ',' || c_记录.Id || ',' || c_记录.号码;
      Exception
        When Others Then
          Null;
      End;
    End Loop;
  Else
    --取消审核
    Select Count(1)
    Into n_Count
    From 临床出诊停诊记录
    Where ID = Id_In And 审批人 Is Not Null And 取消人 Is Null And 记录id Is Not Null;
    If Nvl(n_Count, 0) <> 0 Then
      v_Error := '当前停诊记录是对出诊记录进行停诊产生的，不能取消审批，只能通过选择出诊记录做取消停诊处理！';
      Raise Err_Custom;
    End If;
  
    Select Count(1) Into n_Count From 临床出诊停诊记录 Where ID = Id_In And 审批人 Is Not Null And 取消人 Is Null;
    If Nvl(n_Count, 0) = 0 Then
      v_Error := '原审核记录未找到，请刷新后查看...';
      Raise Err_Custom;
    End If;
  
    Select Count(1)
    Into n_Count
    From 病人服务信息记录
    Where 记录id In (Select a.Id
                   From 临床出诊记录 A, 临床出诊停诊记录 B
                   Where Nvl(a.替诊医生姓名, a.医生姓名) = b.申请人 And b.Id = Id_In And
                         (a.开始时间 Between b.开始时间 And b.终止时间 Or a.终止时间 Between b.开始时间 And b.终止时间)) And 处理人 Is Not Null;
    If Nvl(n_Count, 0) <> 0 Then
      v_Error := '该停诊安排的部分停诊信息已被处理，不能取消审批！';
      Raise Err_Custom;
    End If;
  
    Update 临床出诊停诊记录 Set 审批人 = Null, 审批时间 = Null Where ID = Id_In;
  
    For c_记录 In (Select a.Id, c.号码
                 From 临床出诊记录 A, 临床出诊停诊记录 B, 临床出诊号源 C
                 Where ((a.替诊医生姓名 Is Null And a.医生id Is Not Null And a.医生姓名 = b.申请人) Or
                       (a.替诊医生姓名 Is Not Null And a.替诊医生id Is Not Null And a.替诊医生姓名 = b.申请人)) And a.号源id = c.Id And
                       b.Id = Id_In And (a.开始时间 Between b.开始时间 And b.终止时间 Or a.终止时间 Between b.开始时间 And b.终止时间) And
                       Exists (Select 1
                        From 临床出诊安排 C, 临床出诊表 D
                        Where c.出诊id = d.Id And c.Id = a.安排id And d.发布时间 Is Not Null)) Loop
    
      Update 临床出诊记录 Set 停诊开始时间 = Null, 停诊终止时间 = Null, 停诊原因 = Null Where ID = c_记录.Id;
    
      --调整"临床出诊序号控制.是否停诊"为0
      Update 临床出诊序号控制 Set 是否停诊 = 0 Where 记录id = c_记录.Id And Nvl(是否停诊, 0) = 1;
    
      Delete 病人服务信息记录 Where 记录id = c_记录.Id And 通知类型 = 1 And 处理人 Is Null;
    
      --消息推送
      -- 停诊类型(1-停诊,2-取消停诊),出诊记录ID,停诊号码
      Begin
        Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
          Using 17, 2 || ',' || c_记录.Id || ',' || c_记录.号码;
      Exception
        When Others Then
          Null;
      End;
    End Loop;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊停诊_Audit;
/

--103232:冉俊明,2016-12-23,临床出诊安排，按序号时段开放停诊安排。
Create Or Replace Procedure Zl_临床出诊序号控制_开放挂号
(
  记录id_In 临床出诊记录.Id%Type,
  数量_In   Number
) As
  --功能：按序号开放已停诊安排
  --参数：
  --     数量_In:开放数量
  n_是否分时段   临床出诊记录.是否分时段%Type;
  n_是否序号控制 临床出诊记录.是否序号控制%Type;
  d_停诊开始时间 临床出诊记录.停诊开始时间%Type;
  d_停诊终止时间 临床出诊记录.停诊终止时间%Type;

  n_最小数量 Number;
  n_最大数量 Number;
  n_Count    Number;
  l_序号     t_Numlist := t_Numlist();

  Err_Item Exception;
  v_Err_Msg Varchar2(255);
Begin
  Begin
    Select 是否分时段, 是否序号控制, 停诊开始时间, 停诊终止时间
    Into n_是否分时段, n_是否序号控制, d_停诊开始时间, d_停诊终止时间
    From 临床出诊记录
    Where ID = 记录id_In;
  Exception
    When Others Then
      v_Err_Msg := '未查找到出诊安排，不能开放停诊安排！';
      Raise Err_Item;
  End;

  If Nvl(n_是否序号控制, 0) = 0 Or Nvl(n_是否分时段, 0) = 0 Then
    v_Err_Msg := '出诊安排不是启用了序号且启用时段的，不能开放停诊安排！';
    Raise Err_Item;
  End If;

  If d_停诊开始时间 Is Null Then
    v_Err_Msg := '当前上班时段无停诊安排，不能开放停诊安排！';
    Raise Err_Item;
  End If;

  If Sysdate > d_停诊开始时间 Then
    v_Err_Msg := '当前时间已大于了停诊开始时间，不能再开放停诊安排！';
    Raise Err_Item;
  End If;

  Begin
    --And a.开始时间 <> a. 终止时间 
    --开始时间与终止时间相等的是加号的序号
    Select Sum(Decode(a.是否停诊, 1, 0, 1) * Decode(Nvl(a.挂号状态, 0), 0, 0, 1)) As 最小数量, Count(1) As 最大数量
    Into n_最小数量, n_最大数量
    From 临床出诊序号控制 A
    Where a.记录id = 记录id_In And a.开始时间 Between d_停诊开始时间 And d_停诊终止时间 And a.开始时间 <> a.终止时间;
  Exception
    When Others Then
      n_最小数量 := 0;
      n_最大数量 := 0;
  End;
  If Nvl(n_最小数量, 0) > Nvl(数量_In, 0) Then
    v_Err_Msg := '开放数量不能小于最小开放数量 ' || Nvl(n_最小数量, 0) || ' ！';
    Raise Err_Item;
  End If;
  If Nvl(n_最大数量, 0) < Nvl(数量_In, 0) Then
    v_Err_Msg := '开放数量不能大于最大开放数量 ' || Nvl(n_最大数量, 0) || ' ！';
    Raise Err_Item;
  End If;

  If Nvl(数量_In, 0) = 0 Then
    Update 临床出诊序号控制
    Set 是否停诊 = 1
    Where 记录id = 记录id_In And 开始时间 Between d_停诊开始时间 And d_停诊终止时间 And Nvl(是否停诊, 0) = 0;
  Else
    --先将上次开放的未使用的号设置为停诊状态
    Update 临床出诊序号控制
    Set 是否停诊 = 1
    Where 记录id = 记录id_In And 开始时间 Between d_停诊开始时间 And d_停诊终止时间 And Nvl(是否停诊, 0) = 0 And Nvl(挂号状态, 0) = 0;
  
    n_Count := Nvl(数量_In, 0) - Nvl(n_最小数量, 0);
    --And 开始时间 <> 终止时间 
    --开始时间与终止时间相等的是加号的序号
    For c_序号 In (Select 序号, 是否停诊, 挂号状态
                 From 临床出诊序号控制
                 Where 记录id = 记录id_In And 开始时间 Between d_停诊开始时间 And d_停诊终止时间 And 开始时间 <> 终止时间
                 Order By 序号) Loop
      If n_Count = 0 Then
        Exit;
      Else
        --上次开放的已使用的号不改变其停诊状态
        If Not (Nvl(c_序号.是否停诊, 0) = 0 And Nvl(c_序号.挂号状态, 0) <> 0) Then
          l_序号.Extend();
          l_序号(l_序号.Count) := c_序号.序号;
          n_Count := n_Count - 1;
        End If;
      End If;
    End Loop;
  
    If Nvl(数量_In, 0) - Nvl(n_最小数量, 0) <> l_序号.Count Then
      v_Err_Msg := '开放数量与实际可开放数量不等，开放停诊安排失败！';
      Raise Err_Item;
    End If;
  
    Forall I In 1 .. l_序号.Count
      Update 临床出诊序号控制 Set 是否停诊 = 0 Where 记录id = 记录id_In And 序号 = l_序号(I);
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊序号控制_开放挂号;
/

--103232:冉俊明,2016-12-15,临床出诊安排，按序号时段开放停诊安排。
Create Or Replace Procedure Zl_临床出诊记录_Stopvisit
(
  记录id_In     临床出诊停诊记录.记录id%Type,
  开始时间_In   临床出诊停诊记录.开始时间%Type := Null,
  终止时间_In   临床出诊停诊记录.终止时间%Type := Null,
  停诊原因_In   临床出诊停诊记录.停诊原因%Type := Null,
  操作员_In     临床出诊停诊记录.申请人%Type := Null,
  操作时间_In   临床出诊停诊记录.申请时间%Type := Null,
  取消停诊_In   Number := 0,
  是否不检查_In Number := 0
) As
  --功能：停诊或者取消停诊
  --入参：
  --       是否不检查_in 主要用于停用/启用号源时使用
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  n_Count Number;
  d_Cur   Date;

  v_号码 临床出诊号源.号码%Type;
Begin
  If Nvl(取消停诊_In, 0) = 0 Then
    --停诊
    If Nvl(是否不检查_In, 0) = 0 Then
      Select Count(1) Into n_Count From 临床出诊记录 A Where ID = 记录id_In And 停诊开始时间 Is Not Null;
      If Nvl(n_Count, 0) <> 0 Then
        v_Err_Msg := '当前安排已被他人进行了停诊，请刷新数据后查看！';
        Raise Err_Item;
      End If;
    
      If 开始时间_In <= Sysdate Then
        v_Err_Msg := '停诊时间的开始时间小于了当前时间，不能进行停诊操作！';
        Raise Err_Item;
      End If;
    End If;
  
    Insert Into 临床出诊停诊记录
      (ID, 记录id, 开始时间, 终止时间, 停诊原因, 申请人, 申请时间, 审批人, 审批时间, 登记人)
      Select 临床出诊停诊记录_Id.Nextval, 记录id_In, 开始时间_In, 终止时间_In, 停诊原因_In, Nvl(a.医生姓名, 操作员_In), 操作时间_In, 操作员_In, 操作时间_In,
             操作员_In
      From 临床出诊记录 A
      Where ID = 记录id_In;
  
    --保存原始临床出诊记录
    Select Count(1) Into n_Count From 临床出诊记录 Where 相关id = 记录id_In;
    If Nvl(n_Count, 0) = 0 Then
      For c_记录 In (Select ID, 安排id, To_Date('1900-01-01', 'yyyy-mm-dd') As 出诊日期, 登记人, 登记时间, 是否发布
                   From 临床出诊记录
                   Where ID = 记录id_In) Loop
        Zl_临床出诊记录_Copy(c_记录.Id, c_记录.安排id, c_记录.出诊日期, c_记录.登记人, c_记录.登记时间, c_记录.是否发布, c_记录.Id);
      End Loop;
    End If;
  
    Update 临床出诊记录
    Set 停诊开始时间 = 开始时间_In, 停诊终止时间 = 终止时间_In, 停诊原因 = 停诊原因_In
    Where ID = 记录id_In;
  
    --调整"临床出诊序号控制.是否停诊"为1
    Update 临床出诊序号控制 A
    Set 是否停诊 = 1
    Where 记录id = 记录id_In And 开始时间 Between 开始时间_In And 终止时间_In And Exists
     (Select 1 From 临床出诊记录 Where ID = a.记录id And Nvl(是否序号控制, 0) = 1 And Nvl(是否分时段, 0) = 1);
  
    Insert Into 病人服务信息记录
      (ID, 通知类型, 记录id, 挂号id, 号源id, 号码, 科室id, 项目id, 医生id, 医生姓名, 病人id, 登记人, 登记时间, 通知原因)
      Select 病人服务信息记录_Id.Nextval, 1, 记录id_In, 挂号id, 号源id, 号码, 科室id, 项目id, 医生id, 医生姓名, 病人id, 操作员_In, 操作时间_In,
             '医生' || 停诊原因_In || '，已停诊'
      From (Select b.Id As 挂号id, c.Id As 号源id, c.号码, c.科室id, a.项目id, a.医生id, a.医生姓名, b.病人id
             From 临床出诊记录 A, 病人挂号记录 B, 临床出诊号源 C
             Where a.Id = b.出诊记录id And a.号源id = c.Id And b.记录状态 = 1 And a.Id = 记录id_In And
                   (b.记录性质 = 1 And b.发生时间 Between a.停诊开始时间 And a.停诊终止时间 Or
                   b.记录性质 = 2 And b.预约时间 Between a.停诊开始时间 And a.停诊终止时间));
  
    --消息推送
    -- 停诊类型(1-停诊,2-取消停诊),出诊记录ID,停诊号码
    Begin
      Select b.号码 Into v_号码 From 临床出诊记录 A, 临床出诊号源 B Where a.号源id = b.Id And a.Id = 记录id_In;
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 17, 1 || ',' || 记录id_In || ',' || v_号码;
    Exception
      When Others Then
        Null;
    End;
  Else
    --取消停诊
    --数据检查
    Select Count(1) Into n_Count From 临床出诊记录 A Where ID = 记录id_In And 停诊开始时间 Is Null;
    If Nvl(n_Count, 0) <> 0 Then
      If Nvl(是否不检查_In, 0) = 1 Then
        Return;
      End If;
      v_Err_Msg := '当前安排已被他人取消停诊，请刷新数据后查看！';
      Raise Err_Item;
    End If;
  
    If Nvl(是否不检查_In, 0) = 0 Then
      Select 停诊终止时间 Into d_Cur From 临床出诊记录 Where ID = 记录id_In And 停诊开始时间 Is Not Null;
      If d_Cur <= Sysdate Then
        v_Err_Msg := '停诊时间的终止时间小于了当前时间，不能进行取消停诊操作！';
        Raise Err_Item;
      End If;
      Select Count(1)
      Into n_Count
      From 病人服务信息记录
      Where 记录id = 记录id_In And 通知类型 = 1 And 处理人 Is Not Null;
      If n_Count <> 0 Then
        v_Err_Msg := '该出诊记录存在病人服务信息记录，且已被处理，不允许取消停诊操作！';
        Raise Err_Item;
      End If;
    End If;
  
    With 出诊记录 As
     (Select a.开始时间, a.终止时间, a.停诊开始时间, a.停诊终止时间
      From 临床出诊记录 A, 临床出诊记录 B
      Where a.号源id = b.号源id And a.出诊日期 = b.出诊日期 And b.Id = 记录id_In And a.Id <> b.Id),
    有效时间段 As
     (Select 开始时间, 停诊开始时间 As 终止时间
      From 出诊记录
      Where 开始时间 < 停诊开始时间 And 终止时间 = 停诊终止时间
      Union All
      Select 停诊终止时间 As 开始时间, 终止时间
      From 出诊记录
      Where 开始时间 = 停诊开始时间 And 终止时间 > 停诊终止时间
      Union All
      Select 开始时间, 停诊开始时间 As 终止时间
      From 出诊记录
      Where 开始时间 < 停诊开始时间 And 终止时间 > 停诊终止时间
      Union All
      Select 停诊终止时间 As 开始时间, 终止时间 From 出诊记录 Where 开始时间 < 停诊开始时间 And 终止时间 > 停诊终止时间)
    Select Count(1)
    Into n_Count
    From 有效时间段 M, 临床出诊记录 N
    Where m.开始时间 < n.终止时间 And m.终止时间 > n.开始时间 And n.Id = 记录id_In And Rownum < 2;
    If n_Count <> 0 Then
      If Nvl(是否不检查_In, 0) = 1 Then
        Return;
      End If;
      v_Err_Msg := '当前上班时段的时间范围与该号源今日目前有效的上班时段的时间范围有交叉，你不能取消停诊！';
      Raise Err_Item;
    End If;
  
    Update 临床出诊停诊记录
    Set 取消人 = 操作员_In, 取消时间 = 操作时间_In
    Where 记录id = 记录id_In And 替诊医生姓名 Is Null And 取消人 Is Null;
  
    Update 临床出诊记录
    Set 停诊开始时间 = Null, 停诊终止时间 = Null, 停诊原因 = Null
    Where ID = 记录id_In And 停诊开始时间 Is Not Null;
  
    --调整"临床出诊序号控制.是否停诊"为0
    Update 临床出诊序号控制 Set 是否停诊 = 0 Where 记录id = 记录id_In And Nvl(是否停诊, 0) = 1;
  
    Delete 病人服务信息记录 Where 记录id = 记录id_In And 通知类型 = 1 And 处理人 Is Null;
  
    --消息推送
    -- 停诊类型(1-停诊,2-取消停诊),出诊记录ID,停诊号码
    Begin
      Select b.号码 Into v_号码 From 临床出诊记录 A, 临床出诊号源 B Where a.号源id = b.Id And a.Id = 记录id_In;
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 17, 2 || ',' || 记录id_In || ',' || v_号码;
    Exception
      When Others Then
        Null;
    End;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊记录_Stopvisit;
/

--103632:冉俊明,2016-12-15,门诊医保多单据一次结算部分退费时医嘱发送的计费状态不正确。
Create Or Replace Procedure Zl_医嘱发送_计费状态_Update
(
  场合_In    Integer := 0, --0:门诊;1-住院
  性质_In    Integer := 1, --1-收费单;2-记帐单
  操作_In    Integer := 0, --0:删除划价单;1-收费或记帐;2-退费或销帐
  No_In      门诊费用记录.No%Type,
  医嘱ids_In Varchar2 := Null
) As
  Err_Item Exception;
  v_Err_Msg Varchar2(255);

  l_医嘱id   t_Numlist := t_Numlist();
  l_计费状态 t_Numlist := t_Numlist();
  l_医嘱id1  t_Numlist := t_Numlist();

  n_Count Number(18);

  n_组状态 Number(18);
  n_状态   Number(18);

  Type Ty_Rec_医嘱 Is Record(
    医嘱id   病人医嘱记录.Id%Type,
    计费状态 病人医嘱发送.计费状态%Type,
    附加信息 Varchar2(100));
  Type Ty_Tb_医嘱 Is Table Of Ty_Rec_医嘱;
  c_主医嘱信息 Ty_Tb_医嘱 := Ty_Tb_医嘱();
  c_医嘱信息   Ty_Tb_医嘱 := Ty_Tb_医嘱();

  v_Temp Varchar2(4000);

  Function Get_Status(主医嘱id_In 病人医嘱记录.Id%Type) Return Number Is
    n_Temp Number(2);
  Begin
  
    If 场合_In = 0 Then
      For c_主医嘱 In (Select Max(Case
                                  When Nvl(a.剩余数量, 0) = Nvl(a.原始数量, 0) And Nvl(a.原始数量, 0) <> 0 Then --0：表示未退
                                   0
                                  When Nvl(a.剩余数量, 0) = 0 Then --2-表示全退
                                   2
                                  Else
                                   3 --3--表示部分退
                                End) As 状态,
                           Min(Case
                                  When Nvl(a.剩余数量, 0) = Nvl(a.原始数量, 0) And Nvl(a.原始数量, 0) <> 0 Then --0：表示未退
                                   0
                                  When Nvl(a.剩余数量, 0) = 0 Then --2-表示全退
                                   2
                                  Else
                                   3 --3--表示部分退
                                End) As 状态1, Min(a.记录状态) As Min_记录状态, Max(a.记录状态) As Max_记录状态
                    From (Select a.序号, a.医嘱序号 As 医嘱id, Mod(a.记录性质, 10) As 记录性质, Sum(Nvl(Nvl(a.付数, 1) * a.数次, 0)) As 剩余数量,
                                  Min(Nvl(a.记录状态, 0)) As 记录状态,
                                  Nvl(Sum(Decode(a.记录状态, 1, 1, 3, 1, 0) * Decode(a.记录性质, 11, 0, 1) *
                                           Nvl(Nvl(a.付数, 1) * a.数次, 0)), 0) As 原始数量
                           From 门诊费用记录 A
                           Where a.医嘱序号 + 0 In (Select ID From 病人医嘱记录 Where ID = 主医嘱id_In Or 相关id = 主医嘱id_In) And
                                 Decode(性质_In, 2, a.记录性质, Mod(a.记录性质, 10)) = 性质_In And a.No = No_In And a.价格父号 Is Null And
                                 Nvl(a.附加标志, 0) <> 9
                           Group By a.序号, a.医嘱序号, Mod(a.记录性质, 10), a.No) A) Loop
        n_Temp := Case
                    When c_主医嘱.状态 Is Null Then
                     0
                    When Nvl(c_主医嘱.状态, -1) <> Nvl(c_主医嘱.状态1, -1) Or c_主医嘱.状态 = 3 Then
                     2
                    When Nvl(c_主医嘱.Min_记录状态, -1) = 0 And Instr(',0,-1,', ',' || Nvl(c_主医嘱.Max_记录状态, -1) || ',') = 0 Then
                     2
                    When c_主医嘱.状态 = 2 Then
                     4
                    When c_主医嘱.状态 = 0 And c_主医嘱.状态1 = 0 And Nvl(性质_In, 0) <> 1 Then --记帐时，表示已记帐
                     1
                    When c_主医嘱.状态 = 0 And c_主医嘱.状态1 = 0 And Nvl(c_主医嘱.Min_记录状态, -1) <> 0 And Nvl(性质_In, 0) = 1 Then
                    --收费时，表示全部收费，同一单据不存在部分收费
                     3
                    Else
                     0
                  End;
        Return n_Temp;
        Exit;
      End Loop;
    End If;
  
    For c_主医嘱 In (Select Max(Case
                               When Nvl(a.剩余数量, 0) = Nvl(a.原始数量, 0) And Nvl(a.原始数量, 0) <> 0 Then --0：表示未退
                                0
                               When Nvl(a.剩余数量, 0) = 0 Then --2-表示全退
                                2
                               Else
                                3 --3--表示部分退
                             End) As 状态,
                         Min(Case
                               When Nvl(a.剩余数量, 0) = Nvl(a.原始数量, 0) And Nvl(a.原始数量, 0) <> 0 Then --0：表示未退
                                0
                               When Nvl(a.剩余数量, 0) = 0 Then --2-表示全退
                                2
                               Else
                                3 --3--表示部分退
                             End) As 状态1, Min(a.记录状态) As Min_记录状态, Max(a.记录状态) As Max_记录状态
                  From (Select a.序号, a.医嘱序号 As 医嘱id, Mod(a.记录性质, 10) As 记录性质, Sum(Nvl(Nvl(a.付数, 1) * a.数次, 0)) As 剩余数量,
                                Min(Nvl(a.记录状态, 0)) As 记录状态,
                                Nvl(Sum(Decode(a.记录状态, 1, 1, 3, 1, 0) * Decode(a.记录性质, 11, 0, 1) *
                                         Nvl(Nvl(a.付数, 1) * a.数次, 0)), 0) As 原始数量
                         From 住院费用记录 A
                         Where a.医嘱序号 + 0 In (Select ID From 病人医嘱记录 Where ID = 主医嘱id_In Or 相关id = 主医嘱id_In) And
                               a.记录性质 = 性质_In And a.No = No_In And a.价格父号 Is Null And Nvl(a.附加标志, 0) <> 9
                         Group By a.序号, a.医嘱序号, Mod(a.记录性质, 10), a.No) A) Loop
      n_Temp := Case
                  When c_主医嘱.状态 Is Null Then
                   0
                  When Nvl(c_主医嘱.状态, -1) <> Nvl(c_主医嘱.状态1, -1) Or c_主医嘱.状态 = 3 Then
                   2
                  When Nvl(c_主医嘱.Min_记录状态, -1) = 0 And Instr(',0,-1,', ',' || Nvl(c_主医嘱.Max_记录状态, -1) || ',') = 0 Then
                   2
                  When c_主医嘱.状态 = 2 Then
                   4
                  When c_主医嘱.状态 = 0 And c_主医嘱.状态1 = 0 And Nvl(性质_In, 0) <> 1 Then --记帐时，表示已记帐
                   1
                  Else
                   0
                End;
      Return n_Temp;
      Exit;
    End Loop;
  
  End Get_Status;
Begin

  If 医嘱ids_In Is Null Then
    If 场合_In = 0 Then
      Select ID Bulk Collect
      Into l_医嘱id
      From (Select Distinct 医嘱序号 As ID
             From 门诊费用记录
             Where NO = No_In And 记录性质 = 性质_In And 记录状态 In (0, 1, 3) And 医嘱序号 Is Not Null);
    Else
      Select ID Bulk Collect
      Into l_医嘱id
      From (Select Distinct 医嘱序号 As ID
             From 住院费用记录
             Where NO = No_In And 记录性质 = 性质_In And 记录状态 In (0, 1, 3) And 医嘱序号 Is Not Null);
    End If;
  Else
    Select ID Bulk Collect
    Into l_医嘱id
    From (Select Distinct Column_Value As ID From Table(f_Str2list(医嘱ids_In)) B);
  End If;

  If l_医嘱id.Count = 0 Then
    Return;
  End If;

  If 操作_In = 0 Or 操作_In = 1 Then
    v_Temp := '';
    For c_医嘱 In (
                 --1-无须计费(通常无执行和院外执行的都无须计费);0-未计费;1-已计费，2-部分退费(销帐)，3-全部收费(仅门诊收费有)，4-全部退费(销帐)
                 Select a.医嘱id, Max(Nvl(b.相关id, b.Id)) As 主医嘱id,
                         Max(Decode(Nvl(c.诊疗类别, '-'), 'D', 1, 'F', 1, 0)) As 检查手术医嘱
                 From 病人医嘱发送 A, 病人医嘱记录 B, 病人医嘱记录 C
                 Where NO = No_In And a.记录性质 = 性质_In And a.医嘱id = b.Id And
                       a.医嘱id + 0 In (Select Column_Value From Table(l_医嘱id)) And Nvl(b.相关id, b.Id) + 0 = c.Id
                 Group By a.医嘱id) Loop
    
      If Nvl(c_医嘱.检查手术医嘱, 0) = 1 And c_医嘱.主医嘱id Is Not Null And
         Instr(Nvl(v_Temp, '') || ',', ',' || c_医嘱.主医嘱id || ',') = 0 Then
        --查找是否存在划价单的情况或者被删除或者存在审核
        If Nvl(操作_In, 0) = 0 Then
          --删除划价单,分两种情况:
          --1.整张单据删除,这个时候填为0
          --2.部分删除（如：记帐单
          If 性质_In = 1 Then
            n_组状态 := 0;
          Else
            n_组状态 := Get_Status(c_医嘱.主医嘱id);
          End If;
        End If;
        If 操作_In = 1 Then
          --收费记帐
          If 性质_In = 1 Then
            n_组状态 := 3;
          Else
            n_组状态 := Get_Status(c_医嘱.主医嘱id);
          End If;
        End If;
        c_主医嘱信息.Extend;
        c_主医嘱信息(c_主医嘱信息.Count).医嘱id := c_医嘱.主医嘱id;
        c_主医嘱信息(c_主医嘱信息.Count).计费状态 := n_组状态;
        v_Temp := Nvl(v_Temp, '') || ',' || c_医嘱.主医嘱id;
      End If;
      c_医嘱信息.Extend;
      c_医嘱信息(c_医嘱信息.Count).医嘱id := c_医嘱.医嘱id;
      c_医嘱信息(c_医嘱信息.Count).计费状态 := Case
                                     When 操作_In = 1 And 性质_In = 1 Then
                                      3
                                     When 操作_In = 1 And 性质_In = 2 Then
                                      1
                                     Else
                                      0
                                   End;
    End Loop;
  End If;
  --退费或销帐
  If 操作_In = 2 Then
    If 场合_In = 0 Then
    
      For c_医嘱 In (Select a.医嘱id, Max(Decode(Nvl(b.诊疗类别, '-'), 'D', 1, 'F', 1, 0)) As 检查手术医嘱, Max(a.主医嘱id) As 主医嘱id,
                          Max(Case
                                 When Nvl(a.剩余数量, 0) = Nvl(a.原始数量, 0) And Nvl(a.原始数量, 0) <> 0 Then --0：表示未退
                                  0
                                 When Nvl(a.剩余数量, 0) = 0 Then --2-表示全退
                                  2
                                 Else
                                  3 --3--表示部分退
                               End) As 状态, Min(a.记录状态) As Min_记录状态, Max(a.记录状态) As Max_记录状态
                   From (Select a.序号, a.医嘱序号 As 医嘱id, Mod(a.记录性质, 10) As 记录性质, a.No,
                                 Sum(Nvl(Nvl(a.付数, 1) * a.数次, 0)) As 剩余数量, Min(Nvl(a.记录状态, 0)) As 记录状态,
                                 Nvl(Sum(Decode(a.记录状态, 1, 1, 3, 1, 0) * Decode(a.记录性质, 11, 0, 1) *
                                          Nvl(Nvl(a.付数, 1) * a.数次, 0)), 0) As 原始数量, c.相关id As 主医嘱id
                          From 门诊费用记录 A, 病人医嘱记录 C
                          Where a.医嘱序号 = c.Id And Decode(性质_In, 2, a.记录性质, Mod(a.记录性质, 10)) = 性质_In And a.No = No_In And
                                a.价格父号 Is Null And Nvl(a.附加标志, 0) <> 9 And
                                a.医嘱序号 + 0 In (Select Column_Value From Table(l_医嘱id))
                          Group By a.序号, a.医嘱序号, Mod(a.记录性质, 10), a.No, c.相关id) A, 病人医嘱记录 B
                   Where a.主医嘱id = b.Id(+)
                   Group By a.医嘱id
                   
                   ) Loop
      
        ---1-无须计费(通常无执行和院外执行的都无须计费);0-未计费;1-已计费，2-部分退费(销帐)，3-全部收费(仅门诊收费有)，4-全部退费(销帐)
        n_状态 := Case
                  When Nvl(c_医嘱.状态, 0) = 3 Then --表示部分退
                   2
                  When Nvl(c_医嘱.状态, 0) = 0 And Nvl(性质_In, 0) = 1 Then --收费时，表示全收
                   3
                  When Nvl(c_医嘱.Min_记录状态, 0) = 0 And Nvl(c_医嘱.Max_记录状态, 0) <> 0 Then
                   2
                  When Nvl(c_医嘱.状态, 0) = 0 And Nvl(性质_In, 0) <> 1 Then --记帐时，表示已记帐
                   1
                  Else
                   4
                End;
      
        c_医嘱信息.Extend;
        c_医嘱信息(c_医嘱信息.Count).医嘱id := c_医嘱.医嘱id;
        c_医嘱信息(c_医嘱信息.Count).计费状态 := n_状态;
      
        If Nvl(c_医嘱.检查手术医嘱, 0) = 1 And c_医嘱.主医嘱id Is Not Null Then
          --手术或检查医嘱，需要处理主医嘱
          n_组状态 := -9;
          n_Count  := 0;
          For J In 1 .. c_主医嘱信息.Count Loop
            If c_主医嘱信息(J).医嘱id = c_医嘱.主医嘱id Then
              --:-1-无须计费(通常无执行和院外执行的都无须计费);0-未计费;1-已计费，2-部分退费(销帐)，3-全部收费(仅门诊收费有)，4-全部退费(销帐)
              If c_主医嘱信息(J).计费状态 <> 2 And n_状态 = 2 Then
                --部分退
                c_主医嘱信息(J).计费状态 := 2;
                n_组状态 := 2;
              End If;
            
              If Instr(Nvl(c_主医嘱信息(J).附加信息, '') || ',', ',' || n_状态 || ',') = 0 And Nvl(c_主医嘱信息(J).计费状态, 0) <> 2 Then
                c_主医嘱信息(J).附加信息 := Nvl(c_主医嘱信息(J).附加信息, '') || ',' || n_状态;
                c_主医嘱信息(J).计费状态 := 2;
                n_组状态 := 2;
              End If;
              n_Count := 1;
              Exit;
            End If;
          End Loop;
          If n_Count = 0 Then
            If n_状态 = 2 Then
              n_组状态 := 2;
            End If;
            --未找到时,需要重新加入
            c_主医嘱信息.Extend;
            c_主医嘱信息(c_主医嘱信息.Count).医嘱id := c_医嘱.主医嘱id;
            c_主医嘱信息(c_主医嘱信息.Count).计费状态 := n_组状态;
            c_主医嘱信息(c_主医嘱信息.Count).附加信息 := ',' || n_状态;
          End If;
        End If;
      End Loop;
    Else
    
      For c_医嘱 In (Select a.医嘱id, Max(Decode(Nvl(b.诊疗类别, '-'), 'D', 1, 'F', 1, 0)) As 检查手术医嘱, Max(a.主医嘱id) As 主医嘱id,
                          Max(Case
                                When Nvl(a.剩余数量, 0) = Nvl(a.原始数量, 0) And Nvl(a.原始数量, 0) <> 0 Then --0：表示未退
                                 0
                                When Nvl(a.剩余数量, 0) = 0 Then --2-表示全退
                                 2
                                Else
                                 3 --3--表示部分退
                              End) As 状态, Min(a.记录状态) As Min_记录状态, Max(a.记录状态) As Max_记录状态
                   From (Select a.序号, a.医嘱序号 As 医嘱id, Mod(a.记录性质, 10) As 记录性质, a.No,
                                 Sum(Nvl(Nvl(a.付数, 1) * a.数次, 0)) As 剩余数量, Min(Nvl(a.记录状态, 0)) As 记录状态,
                                 Nvl(Sum(Decode(a.记录状态, 1, 1, 3, 1, 0) * Decode(a.记录性质, 11, 0, 1) *
                                          Nvl(Nvl(a.付数, 1) * a.数次, 0)), 0) As 原始数量, c.相关id As 主医嘱id
                          From 住院费用记录 A, 病人医嘱记录 C
                          Where a.医嘱序号 = c.Id And a.记录性质 = 性质_In And a.No = No_In And a.价格父号 Is Null And
                                Nvl(a.附加标志, 0) <> 9 And a.医嘱序号 + 0 In (Select Column_Value From Table(l_医嘱id))
                          Group By a.序号, a.医嘱序号, Mod(a.记录性质, 10), a.No, c.相关id) A, 病人医嘱记录 B
                   Where a.主医嘱id = b.Id(+)
                   Group By a.医嘱id
                   
                   ) Loop
      
        ---1-无须计费(通常无执行和院外执行的都无须计费);0-未计费;1-已计费，2-部分退费(销帐)，3-全部收费(仅门诊收费有)，4-全部退费(销帐)
        n_状态 := Case
                  When Nvl(c_医嘱.状态, 0) = 3 Then --表示部分退
                   2
                  When Nvl(c_医嘱.状态, 0) = 0 And Nvl(性质_In, 0) = 1 Then --收费时，表示全收
                   3
                  When Nvl(c_医嘱.Min_记录状态, 0) = 0 And Nvl(c_医嘱.Max_记录状态, 0) <> 0 Then
                   2
                  When Nvl(c_医嘱.状态, 0) = 0 And Nvl(性质_In, 0) <> 1 Then --记帐时，表示已记帐
                   1
                  Else
                   4
                End;
      
        c_医嘱信息.Extend;
        c_医嘱信息(c_医嘱信息.Count).医嘱id := c_医嘱.医嘱id;
        c_医嘱信息(c_医嘱信息.Count).计费状态 := n_状态;
      
        If Nvl(c_医嘱.检查手术医嘱, 0) = 1 And c_医嘱.主医嘱id Is Not Null Then
          --手术或检查医嘱，需要处理主医嘱
          n_组状态 := -9;
          n_Count  := 0;
          For J In 1 .. c_主医嘱信息.Count Loop
            If c_主医嘱信息(J).医嘱id = c_医嘱.主医嘱id Then
              --:-1-无须计费(通常无执行和院外执行的都无须计费);0-未计费;1-已计费，2-部分退费(销帐)，3-全部收费(仅门诊收费有)，4-全部退费(销帐)
              If c_主医嘱信息(J).计费状态 <> 2 And n_状态 = 2 Then
                --部分退
                c_主医嘱信息(J).计费状态 := 2;
                n_组状态 := 2;
              End If;
            
              If Instr(Nvl(c_主医嘱信息(J).附加信息, '') || ',', ',' || n_状态 || ',') = 0 And Nvl(c_主医嘱信息(J).计费状态, 0) <> 2 Then
                c_主医嘱信息(J).附加信息 := Nvl(c_主医嘱信息(J).附加信息, '') || ',' || n_状态;
                c_主医嘱信息(J).计费状态 := 2;
                n_组状态 := 2;
              End If;
              n_Count := 1;
              Exit;
            End If;
          End Loop;
          If n_Count = 0 Then
            If n_状态 = 2 Then
              n_组状态 := 2;
            End If;
            --未找到时,需要重新加入
            c_主医嘱信息.Extend;
            c_主医嘱信息(c_主医嘱信息.Count).医嘱id := c_医嘱.主医嘱id;
            c_主医嘱信息(c_主医嘱信息.Count).计费状态 := n_组状态;
            c_主医嘱信息(c_主医嘱信息.Count).附加信息 := ',' || n_状态;
          End If;
        End If;
      End Loop;
    
    End If;
    --处理主医嘱
    If c_主医嘱信息.Count <> 0 Then
      For J In 1 .. c_主医嘱信息.Count Loop
        --需要处理划价信息部分
        --收费时: -1-无须计费(通常无执行和院外执行的都无须计费);0-未计费;1-已计费，2-部分退费(销帐)，3-全部收费(仅门诊收费有)，4-全部退费(销帐)
        If c_主医嘱信息(J).计费状态 = -9 Then
          n_组状态 := Get_Status(c_主医嘱信息(J).医嘱id);
          c_主医嘱信息(J).计费状态 := n_组状态;
        End If;
      End Loop;
    End If;
  End If;

  If c_主医嘱信息.Count = 0 And c_医嘱信息.Count = 0 Then
    Return;
  End If;
  For J In 1 .. c_医嘱信息.Count Loop
    l_医嘱id1.Extend;
    l_计费状态.Extend;
    l_医嘱id1(l_医嘱id1.Count) := c_医嘱信息(J).医嘱id;
    l_计费状态(l_计费状态.Count) := c_医嘱信息(J).计费状态;
  End Loop;

  For J In 1 .. c_主医嘱信息.Count Loop
    l_医嘱id1.Extend;
    l_计费状态.Extend;
    l_医嘱id1(l_医嘱id1.Count) := c_主医嘱信息(J).医嘱id;
    l_计费状态(l_计费状态.Count) := c_主医嘱信息(J).计费状态;
  End Loop;

  Forall I In 1 .. l_医嘱id1.Count
    Update 病人医嘱发送 A
    Set a.计费状态 = l_计费状态(I)
    Where 医嘱id = l_医嘱id1(I) And 记录性质 = 性质_In And NO = No_In;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_医嘱发送_计费状态_Update;
/

--104981:冉俊明,2017-02-06,退费时，相应的退费记录中的挂号ID和主页ID为原费用记录的挂号ID和主页ID。
--103632:冉俊明,2016-12-15,门诊医保多单据一次结算部分退费时医嘱发送的计费状态不正确。
Create Or Replace Procedure Zl_门诊收费记录_重收
(
  原结帐id_In     门诊费用记录.结帐id%Type,
  冲销id_In       门诊费用记录.结帐id%Type,
  重收结帐id_In   门诊费用记录.结帐id%Type,
  排开医保结算_In Varchar2 := Null
) As
  --排开医保结算_IN:多个用逗号分离(只某些医保结算,允许退现金)
  Cursor c_Fee_Data Is
    Select ID
    From 门诊费用记录 A
    Where 结帐id = 原结帐id_In And Not Exists
     (Select 1
           From 门诊费用记录 B
           Where Mod(b.记录性质, 10) = 1 And a.No = b.No And a.序号 = b.序号 And 结帐id = 冲销id_In)
    Order By ID;

  v_操作员编号 门诊费用记录.操作员编号%Type;
  v_操作员姓名 门诊费用记录.操作员姓名%Type;
  d_登记时间   门诊费用记录.登记时间%Type;
  n_缴款组id   门诊费用记录.缴款组id%Type;
  n_病人id     门诊费用记录.病人id%Type;
  Err_Item Exception;
  v_Err_Msg    Varchar2(255);
  n_Array_Size Number := 200;
  t_费用id     t_Numlist;
  n_结算金额   门诊费用记录.实收金额%Type;
  n_冲销金额   病人预交记录.冲预交%Type;
  n_Count      Number(18);
Begin
  Begin
    Select 操作员编号, 操作员姓名, 登记时间, 缴款组id, 病人id
    Into v_操作员编号, v_操作员姓名, d_登记时间, n_缴款组id, n_病人id
    From 门诊费用记录
    Where 结帐id = 冲销id_In And Rownum < 2;
  Exception
    When Others Then
      v_Err_Msg := 'NO';
  End;

  If Nvl(v_Err_Msg, '-') = 'NO' Then
    v_Err_Msg := '由于并发操作,该单据可能已经初他人退费或删除,不能再进行退费操作！';
    Raise Err_Item;
  End If;

  --1.处理界面选择的且是部分退或部分执行的
  Insert Into 门诊费用记录
    (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别, 收费细目id, 计算单位,
     付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, 执行状态, 费用状态, 执行时间,
     操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 结论, 缴款组id, 挂号id, 主页id)
    Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id,
           收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人,
           执行人, 执行状态, 费用状态, 执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 结论,
           缴款组id, 挂号id, 主页id
    From (Select NO, Max(实际票号) As 实际票号, 11 As 记录性质, 1 As 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式,
                  费别, 病人科室id, 收费类别, 收费细目id, 计算单位, 1 As 付数, Max(发药窗口) As 发药窗口, Sum(Nvl(付数, 1) * Nvl(数次, 0)) As 数次,
                  Max(加班标志) As 加班标志, Max(附加标志) As 附加标志, 收入项目id, 收据费目, 记帐费用, Avg(标准单价) As 标准单价, Sum(应收金额) As 应收金额,
                  Sum(实收金额) As 实收金额, 开单部门id, 开单人, 执行部门id, Max(划价人) As 划价人, Max(执行人) 执行人, Max(执行状态) As 执行状态, 1 As 费用状态,
                  Max(执行时间) 执行时间, v_操作员编号 As 操作员编号, v_操作员姓名 As 操作员姓名, 发生时间, d_登记时间 As 登记时间, 重收结帐id_In As 结帐id,
                  Sum(结帐金额) As 结帐金额, Max(保险项目否) As 保险项目否, 保险大类id, Sum(统筹金额) As 统筹金额,
                  Max(Decode(记录性质, 1, 摘要, 11, 摘要, Null)) As 摘要, Max(是否上传) As 是否上传, Max(保险编码) As 保险编码, Max(费用类型) As 费用类型,
                  Max(Decode(记录性质, 1, 结论, 11, 结论, Null)) As 结论, n_缴款组id As 缴款组id, Max(挂号id) As 挂号id, Max(主页id) As 主页id
           From 门诊费用记录
           Where Mod(记录性质, 10) = 1 And (NO, 序号) In (Select NO, 序号 From 门诊费用记录 Where 结帐id = 冲销id_In)
           Group By NO, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别, 收费细目id, 计算单位, 收入项目id,
                    收据费目, 记帐费用, 开单部门id, 开单人, 执行部门id, 发生时间, 保险大类id
           Having Sum(Nvl(付数, 1) * Nvl(数次, 0)) <> 0);

  For c_冲销 In (Select NO, 序号, 从属父号, 价格父号, 收入项目id, -1 * Sum(Nvl(付数, 1) * Nvl(数次, 0)) As 数次, Sum(标准单价) As 标准单价,
                      -1 * Sum(应收金额) As 应收金额, -1 * Sum(实收金额) As 实收金额, -1 * Sum(统筹金额) As 统筹金额, -1 * Sum(结帐金额) As 结帐金额
               From 门诊费用记录
               Where 记录性质 = 11 And 结帐id = 重收结帐id_In
               Group By NO, 序号, 从属父号, 价格父号, 收入项目id) Loop
    Update 门诊费用记录
    Set 数次 = Nvl(数次, 0) + Nvl(c_冲销.数次, 0), 实收金额 = Nvl(实收金额, 0) + Nvl(c_冲销.实收金额, 0),
        应收金额 = Nvl(应收金额, 0) + Nvl(c_冲销.应收金额, 0), 结帐金额 = Nvl(结帐金额, 0) + Nvl(c_冲销.结帐金额, 0),
        统筹金额 = Nvl(统筹金额, 0) + Nvl(c_冲销.统筹金额, 0)
    Where NO = c_冲销.No And 序号 = c_冲销.序号 And Nvl(从属父号, -1) = Nvl(c_冲销.从属父号, '-1') And
          Nvl(价格父号, -1) = Nvl(c_冲销.价格父号, '-1') And 收入项目id = c_冲销.收入项目id And 结帐id = 冲销id_In;
  End Loop;

  --2.处理界面未选退费部分,需要全退且产生11的重收记录
  Open c_Fee_Data;
  Loop
    Fetch c_Fee_Data Bulk Collect
      Into t_费用id Limit n_Array_Size;
    Exit When t_费用id.Count = 0;
  
    --退费记录
    Forall I In 1 .. t_费用id.Count
      Insert Into 门诊费用记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别, 收费细目id,
         计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, 执行状态, 费用状态,
         执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 结论, 缴款组id, 挂号id, 主页id)
        Select 病人费用记录_Id.Nextval, a.No, a.实际票号, 1, 2, a.序号, a.从属父号, a.价格父号, a.病人id, a.医嘱序号, a.门诊标志, a.姓名, a.性别, a.年龄,
               a.标识号, a.付款方式, a.费别, a.病人科室id, a.收费类别, a.收费细目id, a.计算单位, a.付数, a.发药窗口, -1 * a.数次, a.加班标志, a.附加标志,
               a.收入项目id, a.收据费目, a.记帐费用, a.标准单价, -1 * a.应收金额, -1 * a.实收金额, a.开单部门id, a.开单人, a.执行部门id, a.划价人, 执行人,
               Nvl(q.执行状态, -1) As 执行状态, 1, a.执行时间, v_操作员编号, v_操作员姓名, a.发生时间, d_登记时间, 冲销id_In, -1 * a.结帐金额, a.保险项目否,
               a.保险大类id, -1 * a.统筹金额, a.摘要, a.是否上传, a.保险编码, a.费用类型, a.结论, n_缴款组id As 缴款组id, 挂号id, 主页id
        From 门诊费用记录 A,
             (Select j.No, j.序号, Nvl(Max(j.执行状态), 0) - 1 As 执行状态
               From 门诊费用记录 M, 门诊费用记录 J
               Where m.Id = t_费用id(I) And m.No = j.No And m.序号 = j.序号 And Mod(j.记录性质, 10) = 1 And j.记录状态 = 2
               Group By j.No, j.序号) Q
        Where ID = t_费用id(I) And a.No = q.No(+) And a.序号 = q.序号(+);
  
    --将原记录状态由1变为3
    Forall I In 1 .. t_费用id.Count
      Update 门诊费用记录 Set 记录状态 = 3 Where ID = t_费用id(I) And 记录状态 = 1;
  
    --重新收费记录
    If Nvl(重收结帐id_In, 0) <> 0 Then
      Forall I In 1 .. t_费用id.Count
        Insert Into 门诊费用记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别, 收费细目id,
           计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, 执行状态,
           费用状态, 执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 结论, 缴款组id, 挂号id,
           主页id)
          Select 病人费用记录_Id.Nextval, NO, 实际票号, 11, 1, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id,
                 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id,
                 划价人, 执行人, 执行状态, 1, 执行时间, v_操作员编号, v_操作员姓名, 发生时间, d_登记时间, 重收结帐id_In, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传,
                 保险编码, 费用类型, 结论, n_缴款组id As 缴款组id, 挂号id, 主页id
          From 门诊费用记录
          Where ID = t_费用id(I);
    End If;
  End Loop;
  Close c_Fee_Data;

  Select Count(1) Into n_Count From 病人预交记录 Where 结帐id = 冲销id_In And 结算方式 Is Null;
  If n_Count = 0 Then
    --退费结算方式
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
      Select 病人预交记录_Id.Nextval, 3, Null, 2, n_病人id, 结算方式, d_登记时间, v_操作员编号, v_操作员姓名, -1 * 冲预交, 冲销id_In, n_缴款组id,
             -1 * 冲销id_In, 2, 3
      From 病人预交记录
      Where 结帐id = 原结帐id_In And 结算方式 In (Select 名称 From 结算方式 Where 性质 In (3, 4)) And
            Instr(',' || 排开医保结算_In || ',', ',' || 结算方式 || ',') = 0 And Mod(记录性质, 10) <> 1;
    --将原误差费全部退了
    --Insert Into 病人预交记录
    --  (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志)
    --  Select 病人预交记录_Id.Nextval, 3, Null, 2, n_病人id, 结算方式, d_登记时间, v_操作员编号, v_操作员姓名, -1 * 冲预交, 冲销id_In, n_缴款组id,
    --         -1 * 冲销id_In, 2
    --  From 病人预交记录
    --  Where 结帐id = 原结帐id_In And 结算方式 = v_误差费 And Mod(记录性质, 10) <> 1;
  
    Select Sum(冲预交) Into n_冲销金额 From 病人预交记录 Where 结帐id = 冲销id_In;
    Select Sum(结帐金额) Into n_结算金额 From 门诊费用记录 Where 结帐id = 冲销id_In;
  
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
    Values
      (病人预交记录_Id.Nextval, 3, Null, 2, n_病人id, Null, d_登记时间, v_操作员编号, v_操作员姓名, -1 * (Nvl(n_冲销金额, 0) - Nvl(n_结算金额, 0)),
       冲销id_In, n_缴款组id, -1 * 冲销id_In, 1, 3);
  
  End If;
  If Nvl(重收结帐id_In, 0) <> 0 Then
    Select Count(1) Into n_Count From 病人预交记录 Where 结帐id = 重收结帐id_In And 结算方式 Is Null;
    If n_Count = 0 Then
      Select Sum(结帐金额) Into n_结算金额 From 门诊费用记录 Where 结帐id = 重收结帐id_In;
    
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 1, n_病人id, Null, d_登记时间, v_操作员编号, v_操作员姓名, n_结算金额, 重收结帐id_In, n_缴款组id,
         -1 * 冲销id_In, 1, 3);
    End If;
  
    --场合_In    Integer:=0, --0:门诊;1-住院
    --性质_In    Integer:=1, --1-收费单;2-记帐单
    --操作_In    Integer:=0, --0:删除划价单;1-收费或记帐;2-退费或销帐
    --No_In      门诊费用记录.No%Type,
    --医嘱ids_In Varchar2 := Null
    For c_No In (Select Distinct NO From 门诊费用记录 Where 记录性质 = 11 And 结帐id = 重收结帐id_In) Loop
      Zl_医嘱发送_计费状态_Update(0, 1, 2, c_No.No);
    End Loop;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费记录_重收;
/

--103209:刘尔旋,2016-12-15,服务窗医保实时结算
Create Or Replace Procedure Zl_三方机构挂号_Delete
(
  单据号_In     门诊费用记录.No%Type,
  交易流水号_In 病人预交记录.交易流水号%Type,
  交易说明_In   病人预交记录.交易说明%Type,
  退号时间_In   门诊费用记录.登记时间%Type := Null,
  预交id_In     病人预交记录.Id%Type := Null
) As
  v_Error Varchar(255);
  Err_Custom Exception;

  --该游标用于判断是否单独收病历费,及挂号汇总表处理
  Cursor c_Registinfo
  (
    v_状态     病人挂号记录.记录状态%Type,
    v_性质     病人挂号记录.记录性质%Type,
    v_无效单据 Number := 0
  ) Is
    Select a.发生时间, a.登记时间, b.项目id, b.科室id, b.医生姓名, b.医生id, b.号码
    From 病人挂号记录 A, 挂号安排 B
    Where a.记录性质 = Decode(v_无效单据, 0, v_性质, a.记录性质) And a.记录状态 = v_状态 And a.No = 单据号_In And a.号别 = b.号码 And Rownum = 1;

  r_Registrow c_Registinfo%RowType;

  --该光标用于处理人员缴款余额中退的不同结算方式的金额
  Cursor c_Opermoney Is
    Select Distinct b.结算方式, b.冲预交
    From 门诊费用记录 A, 病人预交记录 B
    Where a.结帐id = b.结帐id And a.No = 单据号_In And a.记录性质 = 4 And a.记录状态 = 3 And b.记录性质 = 4 And b.记录状态 = 3 And
          Nvl(b.冲预交, 0) <> 0;

  n_执行状态       病人挂号记录.执行状态%Type;
  n_打印id         票据打印内容.Id%Type;
  n_结帐id         门诊费用记录.结帐id%Type;
  n_原结帐id       病人预交记录.结帐id%Type;
  n_病人id         病人信息.病人id%Type;
  n_返回值         病人余额.预交余额%Type;
  n_分诊台签到排队 Number;
  n_预交id         病人预交记录.Id%Type;
  n_预约挂号       Number;
  n_无效单据       Number; --无效单据没有产生费用单据
  n_挂号生成队列   Number;
  n_Count          Number;
  n_组id           财务缴款分组.Id%Type;
  d_退号时间       Date;
  v_操作员编号     人员表.编号%Type;
  v_操作员姓名     人员表.姓名%Type;
  v_合作单位       合作单位挂号汇总.合作单位%Type;
  n_预约状态       病人挂号记录.预约%Type;
  v_Temp           Varchar2(100);
  d_登记时间       病人挂号记录.登记时间%Type;
  v_号别           病人挂号记录.号别%Type;
  n_号序           病人挂号记录.号序%Type;
  n_启用分时段     Number;
  d_预约时间       病人挂号记录.预约时间%Type;
  n_合作单位限制   Number(18);
  n_预约生成队列   Number;
  n_记录性质       Number;
  n_状态           Number;
  n_退号重用       Number(3);
  n_挂号排班模式   Number;
  n_预交支付       Number(3);
  n_正常支付       Number(3);
  n_安排id         挂号安排.Id%Type;
  n_计划id         挂号安排计划.Id%Type;
  v_时间段         时间段.时间段%Type;
  d_检查开始时间   Date;
  d_检查结束时间   Date;
  d_启用时间       Date;
  n_出诊记录id     Number(18);
  Function Zl_操作员
  (
    Type_In     Integer,
    Splitstr_In Varchar2
  ) Return Varchar2 As
    n_Step Number(18);
    v_Sub  Varchar2(1000);
    --Type_In:0-获取缺省部门ID;1-获取操作员编号;2-获取操作员姓名
    -- SplitStr:格式为:部门ID,部门名称;人员ID,人员编号,人员姓名(用Zl_Identity获取的)
  Begin
    If Type_In = 0 Then
      --缺省部门
      n_Step := Instr(Splitstr_In, ',');
      v_Sub  := Substr(Splitstr_In, 1, n_Step - 1);
      Return v_Sub;
    End If;
    If Type_In = 1 Then
      --操作员编码
      n_Step := Instr(Splitstr_In, ';');
      v_Sub  := Substr(Splitstr_In, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, 1, n_Step - 1);
      Return v_Sub;
    End If;
    If Type_In = 2 Then
      --操作员姓名
      n_Step := Instr(Splitstr_In, ';');
      v_Sub  := Substr(Splitstr_In, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      Return v_Sub;
    End If;
  End;

  Procedure Zl_三方机构挂号_出诊_Delete
  (
    单据号_In     门诊费用记录.No%Type,
    交易流水号_In 病人预交记录.交易流水号%Type,
    交易说明_In   病人预交记录.交易说明%Type,
    退号时间_In   门诊费用记录.登记时间%Type := Null,
    预交id_In     病人预交记录.Id%Type := Null
  ) As
    v_Error Varchar(255);
    Err_Custom Exception;
  
    --该游标用于判断是否单独收病历费,及挂号汇总表处理
    Cursor c_Registinfo
    (
      v_状态     病人挂号记录.记录状态%Type,
      v_性质     病人挂号记录.记录性质%Type,
      v_无效单据 Number := 0
    ) Is
      Select a.发生时间, a.登记时间, b.项目id, b.科室id, b.医生姓名, b.医生id, b.Id As 记录id, a.号别 As 号码
      From 病人挂号记录 A, 临床出诊记录 B
      Where a.记录性质 = Decode(v_无效单据, 0, v_性质, a.记录性质) And a.记录状态 = v_状态 And a.No = 单据号_In And a.出诊记录id = b.Id And
            Rownum < 2;
  
    r_Registrow c_Registinfo%RowType;
  
    --该光标用于处理人员缴款余额中退的不同结算方式的金额
    Cursor c_Opermoney Is
      Select Distinct b.结算方式, b.冲预交
      From 门诊费用记录 A, 病人预交记录 B
      Where a.结帐id = b.结帐id And a.No = 单据号_In And a.记录性质 = 4 And a.记录状态 = 3 And b.记录性质 = 4 And b.记录状态 = 3 And
            Nvl(b.冲预交, 0) <> 0;
  
    n_执行状态       病人挂号记录.执行状态%Type;
    n_打印id         票据打印内容.Id%Type;
    n_结帐id         门诊费用记录.结帐id%Type;
    n_原结帐id       病人预交记录.结帐id%Type;
    n_病人id         病人信息.病人id%Type;
    n_返回值         病人余额.预交余额%Type;
    n_分诊台签到排队 Number;
    n_预交id         病人预交记录.Id%Type;
    n_预约挂号       Number;
    n_无效单据       Number; --无效单据没有产生费用单据
    n_挂号生成队列   Number;
    n_Count          Number;
    n_组id           财务缴款分组.Id%Type;
    d_退号时间       Date;
    v_操作员编号     人员表.编号%Type;
    v_操作员姓名     人员表.姓名%Type;
    v_合作单位       合作单位挂号汇总.合作单位%Type;
    n_预约状态       病人挂号记录.预约%Type;
    v_Temp           Varchar2(100);
    d_登记时间       病人挂号记录.登记时间%Type;
    v_号别           病人挂号记录.号别%Type;
    n_号序           病人挂号记录.号序%Type;
    n_启用分时段     Number;
    d_预约时间       病人挂号记录.预约时间%Type;
    n_合作单位限制   Number(18);
    n_预约生成队列   Number;
    n_记录性质       Number;
    n_状态           Number;
    n_退号重用       Number(3);
    n_记录id         临床出诊记录.Id%Type;
    n_预交支付       Number(3);
    n_正常支付       Number(3);
    Function Zl_操作员
    (
      Type_In     Integer,
      Splitstr_In Varchar2
    ) Return Varchar2 As
      n_Step Number(18);
      v_Sub  Varchar2(1000);
      --Type_In:0-获取缺省部门ID;1-获取操作员编号;2-获取操作员姓名
      -- SplitStr:格式为:部门ID,部门名称;人员ID,人员编号,人员姓名(用Zl_Identity获取的)
    Begin
      If Type_In = 0 Then
        --缺省部门
        n_Step := Instr(Splitstr_In, ',');
        v_Sub  := Substr(Splitstr_In, 1, n_Step - 1);
        Return v_Sub;
      End If;
      If Type_In = 1 Then
        --操作员编码
        n_Step := Instr(Splitstr_In, ';');
        v_Sub  := Substr(Splitstr_In, n_Step + 1);
        n_Step := Instr(v_Sub, ',');
        v_Sub  := Substr(v_Sub, n_Step + 1);
        n_Step := Instr(v_Sub, ',');
        v_Sub  := Substr(v_Sub, 1, n_Step - 1);
        Return v_Sub;
      End If;
      If Type_In = 2 Then
        --操作员姓名
        n_Step := Instr(Splitstr_In, ';');
        v_Sub  := Substr(Splitstr_In, n_Step + 1);
        n_Step := Instr(v_Sub, ',');
        v_Sub  := Substr(v_Sub, n_Step + 1);
        n_Step := Instr(v_Sub, ',');
        v_Sub  := Substr(v_Sub, n_Step + 1);
        Return v_Sub;
      End If;
    End;
  Begin
    --部门ID,部门名称;人员ID,人员编号,人员姓名
    v_Temp := Zl_Identity(0);
    If Nvl(v_Temp, ' ') = ' ' Then
      v_Error := '当前操作人员未设置对应的人员关系,不能继续。';
      Raise Err_Custom;
    End If;
    v_操作员编号 := Zl_操作员(1, v_Temp);
    v_操作员姓名 := Zl_操作员(2, v_Temp);
  
    n_组id := Zl_Get组id(v_操作员姓名);
  
    d_退号时间 := 退号时间_In;
    If d_退号时间 Is Null Then
      d_退号时间 := Sysdate;
    End If;
  
    --首先判断要退号/取消预约的记录是否存在
    Begin
      Select Decode(记录性质, 2, 1, 0), 记录性质, 登记时间, 号别, 号序, Nvl(预约时间, 发生时间), Nvl(合作单位, ''), Nvl(预约, 0),
             Decode(记录状态, 0, 1, 0), 出诊记录id
      Into n_预约挂号, n_记录性质, d_登记时间, v_号别, n_号序, d_预约时间, v_合作单位, n_预约状态, n_无效单据, n_记录id
      From 病人挂号记录
      Where NO = 单据号_In And 记录状态 In (0, 1) And Rownum < 2;
    Exception
      When Others Then
        n_预约挂号 := -1;
    End;
  
    If n_预约挂号 = -1 Then
      v_Error := '单据可能已经被退号或单据输入错误!';
      Raise Err_Custom;
    End If;
  
    Begin
      Select Nvl(是否分时段, 0) Into n_启用分时段 From 临床出诊记录 Where ID = n_记录id And Rownum < 2;
    Exception
      When Others Then
        n_启用分时段 := 0;
    End;
  
    --预约检查是否添加合作单位控制
    --如果设置了合作单位控制 则
    Select Count(0) Into n_合作单位限制 From 临床出诊挂号控制记录 Where 类型 = 1 And 性质 = 1 And Rownum < 2;
    --更新挂号序号状态
    n_退号重用 := Zl_To_Number(zl_GetSysParameter('已退序号允许挂号', 1111));
    If n_退号重用 = 0 Then
      Update 临床出诊序号控制 Set 挂号状态 = 4 Where 记录id = n_记录id And (序号 = n_号序 Or 备注 = To_Char(n_号序));
    Else
      Update 临床出诊序号控制
      Set 挂号状态 = 0, 类型 = Null, 名称 = Null, 操作员姓名 = Null, 工作站名称 = Null
      Where 记录id = n_记录id And (序号 = n_号序 Or 备注 = To_Char(n_号序));
    End If;
    If Nvl(n_预约挂号, 0) = 1 Or Nvl(n_无效单据, 0) = 1 Then
      If Nvl(n_无效单据, 0) = 0 Then
        --N天内不能取消预约号
        n_Count := Zl_To_Number(zl_GetSysParameter('N天内不能取消预约号', 1111));
        If n_Count <> 0 Then
          If Trunc(Sysdate - n_Count) < d_登记时间 Then
            v_Error := '不能退掉预约在' || To_Char(Trunc(Sysdate - n_Count), 'yyyy-mm-dd') || '以前的预约单!';
            Raise Err_Custom;
          End If;
        End If;
      End If;
    
      n_状态 := Case n_无效单据
                When 1 Then
                 0
                Else
                 1
              End;
      --减少已约数
      Open c_Registinfo(n_状态, 2, n_无效单据);
      Fetch c_Registinfo
        Into r_Registrow;
    
      Update 病人挂号汇总
      Set 已约数 = Nvl(已约数, 0) - n_预约状态, 已挂数 = Nvl(已挂数, 0) - Decode(n_预约状态, 0, 1, 0)
      Where 日期 = Trunc(r_Registrow.发生时间) And 科室id = r_Registrow.科室id And 项目id = r_Registrow.项目id And
            Nvl(医生姓名, '医生') = Nvl(r_Registrow.医生姓名, '医生') And Nvl(医生id, 0) = Nvl(r_Registrow.医生id, 0) And
            (号码 = r_Registrow.号码 Or 号码 Is Null);
    
      If Sql%RowCount = 0 Then
        Insert Into 病人挂号汇总
          (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已约数, 已挂数)
        Values
          (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
           Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, -n_预约状态, Decode(n_预约状态, 0, 1, 0));
      End If;
    
      Update 临床出诊记录
      Set 已约数 = Nvl(已约数, 0) - n_预约状态, 已挂数 = Nvl(已挂数, 0) - Decode(n_预约状态, 0, 1, 0)
      Where ID = n_记录id;
      Close c_Registinfo;
    
      If Nvl(n_无效单据, 0) = 0 Then
        --删除门诊费用记录
        Delete From 门诊费用记录 Where NO = 单据号_In And 记录性质 = 4 And 记录状态 = 0;
        --如果预约生成队列时需要清除队列
        n_挂号生成队列 := Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113));
        If Nvl(n_挂号生成队列, 0) = 1 Then
          n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
          If Nvl(n_预约生成队列, 0) = 1 Then
            --要删除队列
            For v_挂号 In (Select ID, 诊室, 执行部门id, 执行人 From 病人挂号记录 Where NO = 单据号_In) Loop
              Zl_排队叫号队列_Delete(v_挂号.执行部门id, v_挂号.Id);
            End Loop;
          End If;
        End If;
      End If;
    Else
      Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
    
      --更新挂号序号状态
    
      --病人就诊状态
      Select 病人id
      Into n_病人id
      From 门诊费用记录
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And 序号 = 1;
    
      If n_病人id Is Not Null Then
        Update 病人信息 Set 就诊状态 = 0, 就诊诊室 = Null Where 病人id = n_病人id;
        --删除门诊号相关处理,只有当只有一条挂号记录并且病人建档日期与挂号日期近似时才会处理
      End If;
    
      --门诊费用记录
      Insert Into 门诊费用记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别, 收费细目id, 计算单位,
         付数, 数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 执行人, 操作员编号, 操作员姓名, 发生时间,
         登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 缴款组id)
        Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别,
               收费细目id, 计算单位, 付数, -数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, -应收金额, -实收金额, 开单部门id, 开单人, 执行部门id, 执行人,
               v_操作员编号, v_操作员姓名, 发生时间, d_退号时间, n_结帐id, -1 * 结帐金额, 保险项目否, 保险大类id, -1 * 统筹金额, 摘要,
               Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, n_组id
        From 门诊费用记录
        Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In;
    
      Update 门诊费用记录 Set 记录状态 = 3 Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In;
      Select 结帐id
      Into n_原结帐id
      From 门诊费用记录
      Where 记录性质 = 4 And 记录状态 = 3 And NO = 单据号_In And Rownum = 1;
    
      Begin
        Select 1
        Into n_预交支付
        From 病人预交记录
        Where Mod(记录性质, 10) = 1 And 记录状态 = 1 And 结帐id = n_原结帐id And Rownum < 2;
      Exception
        When Others Then
          n_预交支付 := 0;
      End;
      Begin
        Select 1
        Into n_正常支付
        From 病人预交记录
        Where Mod(记录性质, 10) = 4 And 记录状态 = 1 And 结帐id = n_原结帐id And Rownum < 2;
      Exception
        When Others Then
          n_正常支付 := 0;
      End;
      If n_预交支付 = 1 And n_正常支付 = 1 Then
        v_Error := '不能处理多种结算方式,请检查传入的退号单据是否正确!';
        Raise Err_Custom;
      End If;
      If n_预交支付 = 1 Then
        --原样退回预交
        If Nvl(预交id_In, 0) = 0 Then
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
             结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                   d_退号时间, v_操作员姓名, v_操作员编号, -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
            From 病人预交记录
            Where 记录性质 In (1, 11) And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0;
        Else
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
             结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
            Select 预交id_In, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, d_退号时间,
                   v_操作员姓名, v_操作员编号, -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
            From 病人预交记录
            Where 记录性质 In (1, 11) And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0;
        End If;
        --处理病人预交余额 
        For c_预交 In (Select 病人id, 预交类别, -1 * Sum(Nvl(冲预交, 0)) As 冲预交
                     From 病人预交记录
                     Where 记录性质 In (1, 11) And 结帐id = n_结帐id
                     Group By 病人id, 预交类别) Loop
          Update 病人余额
          Set 预交余额 = Nvl(预交余额, 0) + Nvl(c_预交.冲预交, 0)
          Where 病人id = c_预交.病人id And 类型 = Nvl(c_预交.预交类别, 2) And 性质 = 1
          Returning 预交余额 Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 病人余额
              (病人id, 预交余额, 性质, 类型)
            Values
              (c_预交.病人id, Nvl(c_预交.冲预交, 0), 1, Nvl(c_预交.预交类别, 2));
            n_返回值 := Nvl(c_预交.冲预交, 0);
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 病人余额
            Where 病人id = c_预交.病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
          End If;
        End Loop;
      Else
        If Nvl(预交id_In, 0) = 0 Then
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 交易流水号, 交易说明,
             合作单位, 结算序号, 卡类别id, 结算性质)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_退号时间, v_操作员编号, v_操作员姓名, -冲预交,
                   n_结帐id, n_组id, 交易流水号_In, 交易说明_In, 合作单位, n_结帐id, 卡类别id, 结算性质
            From 病人预交记录
            Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_原结帐id;
        Else
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 交易流水号, 交易说明,
             合作单位, 结算序号, 卡类别id, 结算性质)
            Select 预交id_In, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_退号时间, v_操作员编号, v_操作员姓名, -冲预交, n_结帐id, n_组id,
                   交易流水号_In, 交易说明_In, 合作单位, n_结帐id, 卡类别id, 结算性质
            From 病人预交记录
            Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_原结帐id;
        End If;
        Update 病人预交记录 Set 记录状态 = 3 Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_原结帐id;
      End If;
      --退卡收回票据(可能上次挂号使用票据,不能收回)
      Begin
        --从最后一次的打印内容中取
        Select ID
        Into n_打印id
        From (Select b.Id
               From 票据使用明细 A, 票据打印内容 B
               Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 4 And b.No = 单据号_In
               Order By a.使用时间 Desc)
        Where Rownum < 2;
      Exception
        When Others Then
          Null;
      End;
      If n_打印id Is Not Null Then
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_退号时间, v_操作员姓名
          From 票据使用明细
          Where 打印id = n_打印id And 性质 = 1;
      End If;
    
      --相关汇总表的处理
    
      --病人挂号汇总
      Open c_Registinfo(1, 1);
      Fetch c_Registinfo
        Into r_Registrow;
    
      If c_Registinfo%RowCount = 0 Then
        --只收病历费时无号别,不处理
        Close c_Registinfo;
      Else
      
        --需要确定是否预约挂号
        --1.如果是退预约挂号产生的挂号记录,则需要减已挂数和其中已接数
        --2.如果是正常挂号,则只减已挂数
        Begin
          Select Decode(预约, Null, 0, 0, 0, 1), 执行状态
          Into n_预约挂号, n_执行状态
          From 病人挂号记录
          Where NO = 单据号_In And 记录状态 = 1 And Rownum = 1;
        Exception
          When Others Then
            n_预约挂号 := 0;
        End;
        --0-等待接诊,1-完成就诊,2-正在就诊,-1标记为不就诊
        If n_执行状态 > 0 Then
          If n_执行状态 = 1 Then
            v_Error := '该病人已经完成就诊,不能再退号!';
          Else
            v_Error := '该病人正在就诊, 不能退号!';
          End If;
          Raise Err_Custom;
        End If;
      
        Update 病人挂号汇总
        Set 已挂数 = Nvl(已挂数, 0) - 1, 其中已接收 = Nvl(其中已接收, 0) - n_预约状态, 已约数 = Nvl(已约数, 0) - n_预约状态
        Where 日期 = Trunc(r_Registrow.发生时间) And 科室id = r_Registrow.科室id And 项目id = r_Registrow.项目id And
              Nvl(医生姓名, '医生') = Nvl(r_Registrow.医生姓名, '医生') And Nvl(医生id, 0) = Nvl(r_Registrow.医生id, 0) And
              (号码 = r_Registrow.号码 Or 号码 Is Null);
      
        If Sql%RowCount = 0 Then
          Insert Into 病人挂号汇总
            (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 其中已接收)
          Values
            (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
             Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, -1, -1 * n_预约挂号);
        End If;
      
        Update 临床出诊记录
        Set 已挂数 = Nvl(已挂数, 0) - 1, 其中已接收 = Nvl(其中已接收, 0) - n_预约状态, 已约数 = Nvl(已约数, 0) - n_预约状态
        Where ID = n_记录id;
        Close c_Registinfo;
      End If;
    
      --人员缴款余额(包括个人帐户等的结算金额,不含退冲预交款)
      For r_Opermoney In c_Opermoney Loop
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + (-1 * r_Opermoney.冲预交)
        Where 收款员 = v_操作员姓名 And 结算方式 = r_Opermoney.结算方式 And 性质 = 1
        Returning 余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (v_操作员姓名, r_Opermoney.结算方式, 1, -1 * r_Opermoney.冲预交);
          n_返回值 := r_Opermoney.冲预交;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = v_操作员姓名 And 结算方式 = r_Opermoney.结算方式 And 性质 = 1 And Nvl(余额, 0) = 0;
        End If;
      End Loop;
    
      n_挂号生成队列 := Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113));
      If n_挂号生成队列 <> 0 Then
        n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
        If Nvl(n_分诊台签到排队, 0) = 0 Then
          --要删除队列
          For v_挂号 In (Select ID, 诊室, 执行部门id, 执行人 From 病人挂号记录 Where NO = 单据号_In) Loop
            Zl_排队叫号队列_Delete(v_挂号.执行部门id, v_挂号.Id);
          End Loop;
        End If;
      End If;
    
      --医保产生的就诊登记记录
      Delete From 就诊登记记录
      Where (病人id, 主页id, 就诊时间) In (Select 病人id, 主页id, 发生时间 From 病人挂号记录 Where NO = 单据号_In);
    End If;
  
    If Nvl(n_无效单据, 0) = 0 Then
      Update 病人挂号记录 Set 记录状态 = 3 Where NO = 单据号_In And 记录状态 = 1;
      If Sql%NotFound Then
        v_Error := '未找到挂号单据,请检查!';
        Raise Err_Custom;
      End If;
      Insert Into 病人挂号记录
        (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 操作员编号, 操作员姓名,
         复诊, 号序, 预约, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 出诊记录id)
        Select 病人挂号记录_Id.Nextval, NO, 记录性质, 2, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, d_退号时间,
               发生时间, v_操作员编号, v_操作员姓名, 复诊, 号序, 预约, 接收人, 接收时间, 交易流水号_In, 交易说明_In, 合作单位, 出诊记录id
        From 病人挂号记录
        Where NO = 单据号_In And 记录状态 = 3;
    End If;
    --消息推送
    Begin
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 2, 单据号_In;
    Exception
      When Others Then
        Null;
    End;
  Exception
    When Err_Custom Then
      Raise_Application_Error(-20101, '[ZLSOFT]+' || v_Error || '+[ZLSOFT]');
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End;

Begin
  n_挂号排班模式 := To_Number(Substr(Nvl(zl_GetSysParameter('挂号排班模式'), 0), 1, 1));
  If n_挂号排班模式 = 1 Then
    --出诊表排班模式
    Zl_三方机构挂号_出诊_Delete(单据号_In, 交易流水号_In, 交易说明_In, 退号时间_In, 预交id_In);
  Else
    v_Temp := zl_GetSysParameter(256);
    If v_Temp Is Null Or Substr(v_Temp, 1, 1) = '0' Then
      Null;
    Else
      Begin
        d_启用时间 := To_Date(Substr(v_Temp, 3), 'YYYY-MM-DD hh24:mi:ss');
      Exception
        When Others Then
          d_启用时间 := Null;
      End;
    End If;
    --部门ID,部门名称;人员ID,人员编号,人员姓名
    v_Temp := Zl_Identity(0);
    If Nvl(v_Temp, ' ') = ' ' Then
      v_Error := '当前操作人员未设置对应的人员关系,不能继续。';
      Raise Err_Custom;
    End If;
    v_操作员编号 := Zl_操作员(1, v_Temp);
    v_操作员姓名 := Zl_操作员(2, v_Temp);
  
    n_组id := Zl_Get组id(v_操作员姓名);
  
    d_退号时间 := 退号时间_In;
    If d_退号时间 Is Null Then
      d_退号时间 := Sysdate;
    End If;
  
    --首先判断要退号/取消预约的记录是否存在
    Begin
      Select Decode(记录性质, 2, 1, 0), 记录性质, 登记时间, 号别, 号序, Nvl(预约时间, 发生时间), Nvl(合作单位, ''), Nvl(预约, 0),
             Decode(记录状态, 0, 1, 0)
      Into n_预约挂号, n_记录性质, d_登记时间, v_号别, n_号序, d_预约时间, v_合作单位, n_预约状态, n_无效单据
      From 病人挂号记录
      Where NO = 单据号_In And 记录状态 In (0, 1) And Rownum <= 1;
    Exception
      When Others Then
        n_预约挂号 := -1;
    End;
  
    If n_预约挂号 = -1 Then
      v_Error := '单据可能已经被退号或单据输入错误!';
      Raise Err_Custom;
    End If;
  
    Begin
      Select a.Id Into n_安排id From 挂号安排 A Where a.号码 = v_号别;
    Exception
      When Others Then
        n_安排id := -1;
    End;
  
    Begin
      Select ID
      Into n_计划id
      From 挂号安排计划
      Where 安排id = n_安排id And 审核时间 Is Not Null And
            Nvl(生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) =
            (Select Max(a.生效时间) As 生效
             From 挂号安排计划 A
             Where a.审核时间 Is Not Null And d_预约时间 Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                   Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) And a.安排id = n_安排id) And
            d_预约时间 Between Nvl(生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
            Nvl(失效时间, To_Date('3000-01-01', 'yyyy-mm-dd'));
    Exception
      When Others Then
        n_计划id := 0;
    End;
  
    If Nvl(n_计划id, 0) = 0 Then
      Select Decode(To_Char(d_预约时间, 'D'), '1', 周日, '2', 周一, '3', 周二, '4', 周三, '5', 周四, '6', 周五, '7', 周六, Null)
      Into v_时间段
      From 挂号安排
      Where ID = n_安排id;
    Else
      Select Decode(To_Char(d_预约时间, 'D'), '1', 周日, '2', 周一, '3', 周二, '4', 周三, '5', 周四, '6', 周五, '7', 周六, Null)
      Into v_时间段
      From 挂号安排计划
      Where ID = n_计划id;
    End If;
  
    If v_时间段 Is Not Null And d_启用时间 Is Not Null Then
      --检查是否跨模式挂号安排
      Select To_Date(To_Char(d_预约时间, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'),
             To_Date(To_Char(d_预约时间, 'yyyy-mm-dd') || ' ' || To_Char(终止时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss')
      Into d_检查开始时间, d_检查结束时间
      From 时间段
      Where 时间段 = v_时间段 And 站点 Is Null And 号类 Is Null;
      If d_检查开始时间 > d_检查结束时间 Then
        d_检查结束时间 := d_检查结束时间 + 1;
      End If;
      If d_检查结束时间 > d_启用时间 Then
        --获取出诊记录id
        Begin
          Select a.Id
          Into n_出诊记录id
          From 临床出诊记录 A, 临床出诊号源 B
          Where a.号源id = b.Id And b.号码 = v_号别 And 上班时段 = v_时间段 And d_预约时间 Between 开始时间 And 终止时间;
        Exception
          When Others Then
            n_出诊记录id := Null;
        End;
      End If;
    End If;
  
    Begin
      Select 1
      Into n_启用分时段
      From 挂号安排 A, 挂号安排时段 B
      Where a.号码 = v_号别 And a.Id = b.安排id And Rownum <= 1;
    Exception
      When Others Then
        n_启用分时段 := 0;
    End;
  
    --预约检查是否添加合作单位控制
    --如果设置了合作单位控制 则
    Select Count(0) Into n_合作单位限制 From 合作单位安排控制 Where Rownum = 1;
    --更新挂号序号状态
    n_退号重用 := Zl_To_Number(zl_GetSysParameter('已退序号允许挂号', 1111));
    If n_退号重用 = 0 Then
      Update 挂号序号状态
      Set 状态 = 4
      Where 号码 = v_号别 And 序号 = n_号序 And 日期 Between Trunc(d_预约时间) And Trunc(d_预约时间 + 1) - 1 / 24 / 60 / 60;
    Else
      Delete 挂号序号状态
      Where 号码 = v_号别 And 序号 = n_号序 And 日期 Between Trunc(d_预约时间) And Trunc(d_预约时间 + 1) - 1 / 24 / 60 / 60;
    End If;
    If Nvl(n_预约挂号, 0) = 1 Or Nvl(n_无效单据, 0) = 1 Then
      If Nvl(n_无效单据, 0) = 0 Then
        --N天内不能取消预约号
        n_Count := Zl_To_Number(zl_GetSysParameter('N天内不能取消预约号', 1111));
        If n_Count <> 0 Then
          If Trunc(Sysdate - n_Count) < d_登记时间 Then
            v_Error := '不能退掉预约在' || To_Char(Trunc(Sysdate - n_Count), 'yyyy-mm-dd') || '以前的预约单!';
            Raise Err_Custom;
          End If;
        End If;
      End If;
    
      n_状态 := Case n_无效单据
                When 1 Then
                 0
                Else
                 1
              End;
      --减少已约数
      Open c_Registinfo(n_状态, 2, n_无效单据);
      Fetch c_Registinfo
        Into r_Registrow;
    
      Update 病人挂号汇总
      Set 已约数 = Nvl(已约数, 0) - n_预约状态, 已挂数 = Nvl(已挂数, 0) - Decode(n_预约状态, 0, 1, 0)
      Where 日期 = Trunc(r_Registrow.发生时间) And 科室id = r_Registrow.科室id And 项目id = r_Registrow.项目id And
            Nvl(医生姓名, '医生') = Nvl(r_Registrow.医生姓名, '医生') And Nvl(医生id, 0) = Nvl(r_Registrow.医生id, 0) And
            (号码 = r_Registrow.号码 Or 号码 Is Null);
    
      If Sql%RowCount = 0 Then
        Insert Into 病人挂号汇总
          (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已约数, 已挂数)
        Values
          (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
           Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, -n_预约状态, Decode(n_预约状态, 0, 1, 0));
      End If;
    
      If n_出诊记录id Is Not Null Then
        Update 临床出诊记录
        Set 已约数 = Nvl(已约数, 0) - n_预约状态, 已挂数 = Nvl(已挂数, 0) - Decode(n_预约状态, 0, 1, 0)
        Where ID = n_出诊记录id And Nvl(已约数, 0) > 0;
        Update 临床出诊序号控制 Set 挂号状态 = Null, 操作员姓名 = Null Where 记录id = n_出诊记录id And 序号 = n_号序;
      End If;
      If Nvl(n_合作单位限制, 0) <> 0 And Nvl(v_合作单位, '') <> '' And Nvl(n_预约状态, 0) <> 0 Then
        Update 合作单位挂号汇总
        Set 已约数 = Nvl(已约数, 0) - n_预约状态, 已接数 = Nvl(已接数, 0) - Decode(n_预约状态, 0, 1, 0)
        Where 日期 = Trunc(r_Registrow.发生时间) And (号码 = r_Registrow.号码 Or 号码 Is Null) And 合作单位 = Nvl(v_合作单位, '') And
              序号 = Nvl(n_号序, 0);
        If Sql%RowCount = 0 Then
          Insert Into 合作单位挂号汇总
            (日期, 号码, 已约数, 合作单位, 序号, 已接数)
          Values
            (Trunc(r_Registrow.发生时间), r_Registrow.号码, -n_预约状态, v_合作单位, Nvl(n_号序, 0), -decode(n_预约状态, 0, 1, 0));
        End If;
      End If;
      Close c_Registinfo;
    
      If Nvl(n_无效单据, 0) = 0 Then
        --删除门诊费用记录
        Delete From 门诊费用记录 Where NO = 单据号_In And 记录性质 = 4 And 记录状态 = 0;
        --如果预约生成队列时需要清除队列
        n_挂号生成队列 := Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113));
        If Nvl(n_挂号生成队列, 0) = 1 Then
          n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
          If Nvl(n_预约生成队列, 0) = 1 Then
            --要删除队列
            For v_挂号 In (Select ID, 诊室, 执行部门id, 执行人 From 病人挂号记录 Where NO = 单据号_In) Loop
              Zl_排队叫号队列_Delete(v_挂号.执行部门id, v_挂号.Id);
            End Loop;
          End If;
        End If;
      End If;
    Else
      Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
    
      --更新挂号序号状态
    
      --病人就诊状态
      Select 病人id
      Into n_病人id
      From 门诊费用记录
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And 序号 = 1;
    
      If n_病人id Is Not Null Then
        Update 病人信息 Set 就诊状态 = 0, 就诊诊室 = Null Where 病人id = n_病人id;
        --删除门诊号相关处理,只有当只有一条挂号记录并且病人建档日期与挂号日期近似时才会处理
      End If;
    
      --门诊费用记录
      Insert Into 门诊费用记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别, 收费细目id, 计算单位,
         付数, 数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 执行人, 操作员编号, 操作员姓名, 发生时间,
         登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 缴款组id)
        Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别,
               收费细目id, 计算单位, 付数, -数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, -应收金额, -实收金额, 开单部门id, 开单人, 执行部门id, 执行人,
               v_操作员编号, v_操作员姓名, 发生时间, d_退号时间, n_结帐id, -1 * 结帐金额, 保险项目否, 保险大类id, -1 * 统筹金额, 摘要,
               Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, n_组id
        From 门诊费用记录
        Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In;
    
      Update 门诊费用记录 Set 记录状态 = 3 Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In;
      Select 结帐id
      Into n_原结帐id
      From 门诊费用记录
      Where 记录性质 = 4 And 记录状态 = 3 And NO = 单据号_In And Rownum = 1;
    
      Begin
        Select 1
        Into n_预交支付
        From 病人预交记录
        Where Mod(记录性质, 10) = 1 And 记录状态 = 1 And 结帐id = n_原结帐id And Rownum < 2;
      Exception
        When Others Then
          n_预交支付 := 0;
      End;
    
      Begin
        Select 1
        Into n_正常支付
        From 病人预交记录
        Where Mod(记录性质, 10) = 4 And 记录状态 = 1 And 结帐id = n_原结帐id And Rownum < 2;
      Exception
        When Others Then
          n_正常支付 := 0;
      End;
    
      If n_预交支付 = 1 And n_正常支付 = 1 Then
        v_Error := '不能处理多种结算方式,请检查传入的退号单据是否正确!';
        Raise Err_Custom;
      End If;
    
      If n_预交支付 = 1 Then
        --原样退回预交
        If Nvl(预交id_In, 0) = 0 Then
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
             结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                   d_退号时间, v_操作员姓名, v_操作员编号, -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
            From 病人预交记录
            Where 记录性质 In (1, 11) And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0;
        Else
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
             结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
            Select 预交id_In, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, d_退号时间,
                   v_操作员姓名, v_操作员编号, -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
            From 病人预交记录
            Where 记录性质 In (1, 11) And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0;
        End If;
        --处理病人预交余额 
        For c_预交 In (Select 病人id, 预交类别, -1 * Sum(Nvl(冲预交, 0)) As 冲预交
                     From 病人预交记录
                     Where 记录性质 In (1, 11) And 结帐id = n_结帐id
                     Group By 病人id, 预交类别) Loop
          Update 病人余额
          Set 预交余额 = Nvl(预交余额, 0) + Nvl(c_预交.冲预交, 0)
          Where 病人id = c_预交.病人id And 类型 = Nvl(c_预交.预交类别, 2) And 性质 = 1
          Returning 预交余额 Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 病人余额
              (病人id, 预交余额, 性质, 类型)
            Values
              (c_预交.病人id, Nvl(c_预交.冲预交, 0), 1, Nvl(c_预交.预交类别, 2));
            n_返回值 := Nvl(c_预交.冲预交, 0);
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 病人余额
            Where 病人id = c_预交.病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
          End If;
        End Loop;
      Else
        If Nvl(预交id_In, 0) = 0 Then
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 交易流水号, 交易说明,
             合作单位, 结算序号, 卡类别id, 结算性质)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_退号时间, v_操作员编号, v_操作员姓名, -冲预交,
                   n_结帐id, n_组id, 交易流水号_In, 交易说明_In, 合作单位, n_结帐id, 卡类别id, 结算性质
            From 病人预交记录
            Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_原结帐id;
        Else
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 交易流水号, 交易说明,
             合作单位, 结算序号, 卡类别id, 结算性质)
            Select 预交id_In, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_退号时间, v_操作员编号, v_操作员姓名, -冲预交, n_结帐id, n_组id,
                   交易流水号_In, 交易说明_In, 合作单位, n_结帐id, 卡类别id, 结算性质
            From 病人预交记录
            Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_原结帐id;
        End If;
      
        Update 病人预交记录 Set 记录状态 = 3 Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_原结帐id;
      End If;
    
      --退卡收回票据(可能上次挂号使用票据,不能收回)
      Begin
        --从最后一次的打印内容中取
        Select ID
        Into n_打印id
        From (Select b.Id
               From 票据使用明细 A, 票据打印内容 B
               Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 4 And b.No = 单据号_In
               Order By a.使用时间 Desc)
        Where Rownum < 2;
      Exception
        When Others Then
          Null;
      End;
      If n_打印id Is Not Null Then
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_退号时间, v_操作员姓名
          From 票据使用明细
          Where 打印id = n_打印id And 性质 = 1;
      End If;
    
      --相关汇总表的处理
    
      --病人挂号汇总
      Open c_Registinfo(1, 1);
      Fetch c_Registinfo
        Into r_Registrow;
    
      If c_Registinfo%RowCount = 0 Then
        --只收病历费时无号别,不处理
        Close c_Registinfo;
      Else
      
        --需要确定是否预约挂号
        --1.如果是退预约挂号产生的挂号记录,则需要减已挂数和其中已接数
        --2.如果是正常挂号,则只减已挂数
        Begin
          Select Decode(预约, Null, 0, 0, 0, 1), 执行状态
          Into n_预约挂号, n_执行状态
          From 病人挂号记录
          Where NO = 单据号_In And 记录状态 = 1 And Rownum = 1;
        Exception
          When Others Then
            n_预约挂号 := 0;
        End;
        --0-等待接诊,1-完成就诊,2-正在就诊,-1标记为不就诊
        If n_执行状态 > 0 Then
          If n_执行状态 = 1 Then
            v_Error := '该病人已经完成就诊,不能再退号!';
          Else
            v_Error := '该病人正在就诊, 不能退号!';
          End If;
          Raise Err_Custom;
        End If;
      
        Update 病人挂号汇总
        Set 已挂数 = Nvl(已挂数, 0) - 1, 其中已接收 = Nvl(其中已接收, 0) - n_预约状态, 已约数 = Nvl(已约数, 0) - n_预约状态
        Where 日期 = Trunc(r_Registrow.发生时间) And 科室id = r_Registrow.科室id And 项目id = r_Registrow.项目id And
              Nvl(医生姓名, '医生') = Nvl(r_Registrow.医生姓名, '医生') And Nvl(医生id, 0) = Nvl(r_Registrow.医生id, 0) And
              (号码 = r_Registrow.号码 Or 号码 Is Null);
      
        If Sql%RowCount = 0 Then
          Insert Into 病人挂号汇总
            (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 其中已接收)
          Values
            (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
             Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, -1, -1 * n_预约挂号);
        End If;
        If n_出诊记录id Is Not Null Then
          Update 临床出诊记录
          Set 已挂数 = Nvl(已挂数, 0) - 1, 其中已接收 = Nvl(其中已接收, 0) - n_预约状态, 已约数 = Nvl(已约数, 0) - n_预约状态
          Where ID = n_出诊记录id And Nvl(已约数, 0) > 0;
          Update 临床出诊序号控制 Set 挂号状态 = Null, 操作员姓名 = Null Where 记录id = n_出诊记录id And 序号 = n_号序;
        End If;
        If Nvl(n_合作单位限制, 0) <> 0 And Nvl(v_合作单位, '') <> '' And Nvl(n_预约状态, 0) <> 0 Then
          Update 合作单位挂号汇总
          Set 已接数 = Nvl(已接数, 0) - 1, 已约数 = Nvl(已约数, 0) - n_预约挂号
          Where 日期 = Trunc(r_Registrow.发生时间) And (号码 = r_Registrow.号码 Or 号码 Is Null) And 合作单位 = Nvl(v_合作单位, '') And
                序号 = Nvl(n_号序, 0);
          If Sql%RowCount = 0 Then
            Insert Into 合作单位挂号汇总
              (日期, 号码, 已约数, 合作单位, 已接数)
            Values
              (Trunc(r_Registrow.发生时间), r_Registrow.号码, -1, v_合作单位, -1 * n_预约挂号);
          End If;
        End If;
        Close c_Registinfo;
      End If;
    
      --人员缴款余额(包括个人帐户等的结算金额,不含退冲预交款)
      For r_Opermoney In c_Opermoney Loop
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + (-1 * r_Opermoney.冲预交)
        Where 收款员 = v_操作员姓名 And 结算方式 = r_Opermoney.结算方式 And 性质 = 1
        Returning 余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (v_操作员姓名, r_Opermoney.结算方式, 1, -1 * r_Opermoney.冲预交);
          n_返回值 := r_Opermoney.冲预交;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = v_操作员姓名 And 结算方式 = r_Opermoney.结算方式 And 性质 = 1 And Nvl(余额, 0) = 0;
        End If;
      End Loop;
    
      n_挂号生成队列 := Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113));
      If n_挂号生成队列 <> 0 Then
        n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
        If Nvl(n_分诊台签到排队, 0) = 0 Then
          --要删除队列
          For v_挂号 In (Select ID, 诊室, 执行部门id, 执行人 From 病人挂号记录 Where NO = 单据号_In) Loop
            Zl_排队叫号队列_Delete(v_挂号.执行部门id, v_挂号.Id);
          End Loop;
        End If;
      End If;
    
      --医保产生的就诊登记记录
      Delete From 就诊登记记录
      Where (病人id, 主页id, 就诊时间) In (Select 病人id, 主页id, 发生时间 From 病人挂号记录 Where NO = 单据号_In);
    End If;
  
    If Nvl(n_无效单据, 0) = 0 Then
      Update 病人挂号记录 Set 记录状态 = 3 Where NO = 单据号_In And 记录状态 = 1;
      If Sql%NotFound Then
        v_Error := '未找到挂号单据,请检查!';
        Raise Err_Custom;
      End If;
      Insert Into 病人挂号记录
        (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 操作员编号, 操作员姓名,
         复诊, 号序, 预约, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位)
        Select 病人挂号记录_Id.Nextval, NO, 记录性质, 2, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, d_退号时间,
               发生时间, v_操作员编号, v_操作员姓名, 复诊, 号序, 预约, 接收人, 接收时间, 交易流水号_In, 交易说明_In, 合作单位
        From 病人挂号记录
        Where NO = 单据号_In And 记录状态 = 3;
    End If;
    --消息推送
    Begin
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 2, 单据号_In;
    Exception
      When Others Then
        Null;
    End;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]+' || v_Error || '+[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_三方机构挂号_Delete;
/

--103685:余伟节,2016-12-09,支持婴儿年龄格式X天X小时
Create Or Replace Function Zl_Age_Calc
(
  病人id_In   病人信息.病人id%Type,
  出生日期_In Date := Null,
  计算日期_In Date := Null
) Return Varchar2
--功能:根据出生日期计算年龄.当天登记病人,保持年龄不变.
  --返回:1天以内：X小时[X分钟],1天至1月以内：X天[X小时],1月至1岁以内：X月[X天],1岁至儿童年龄上限：X岁[X月],>=儿童年龄上限：X岁
  --说明:1天以内，是指按出生日期24小时算;1月以内，是指对天计算；比如7.8日出生，8.8日才算1月;1岁以内，也是对天计算。;“以内”都是指“<”。
 As
  d_出生日期      Date;
  d_计算日期      Date;
  n_Days          Number;
  n_Months        Number;
  v_年龄          病人信息.年龄%Type;
  n_Upperagelimit Number; --参数:年龄上限

  v_Return Varchar2(20); --由于病人信息等相关表的年龄字段为10个字符，所以最大允许10个字符或5个汉字
Begin
  --当天登记的病人不用重算年龄
  If Nvl(病人id_In, 0) <> 0 Then
    Begin
      Select 年龄
      Into v_年龄
      From 病人信息
      Where 病人id = 病人id_In And Floor(Sysdate - 登记时间) = 0 And 年龄 Is Not Null;
    Exception
      When Others Then
        Null;
    End;
    If v_年龄 Is Not Null Then
      v_Return := v_年龄;
      Return v_Return;
    End If;
  End If;

  If 出生日期_In Is Null Then
    If Nvl(病人id_In, 0) <> 0 Then
      Select 出生日期 Into d_出生日期 From 病人信息 Where 病人id = 病人id_In;
    End If;
    If d_出生日期 Is Null Then
      Return Null;
    End If;
  Else
    d_出生日期 := 出生日期_In;
  End If;
  If 计算日期_In Is Null Then
    Select Sysdate Into d_计算日期 From Dual;
  Else
    d_计算日期 := 计算日期_In;
  End If;
  --如果出生日期大于计算日期,则直接为0小时
  If (d_计算日期 - d_出生日期) < 0 Then
    v_Return := '0小时';
    Return v_Return;
  End If;
  --获取儿童年龄的上限
  Select Nvl(zl_GetSysParameter(147, 0, 1), 14) Into n_Upperagelimit From Dual;

  n_Months := Trunc(Months_Between(d_计算日期, d_出生日期));
  If n_Months < 12 * n_Upperagelimit Then
    --小于1岁的情况
    If n_Months < 12 Then
      --小于1月
      If n_Months < 1 Then
        n_Days := Trunc(d_计算日期 - d_出生日期);
        --一天以内
        If n_Days = 0 Then
          n_Days := Trunc((d_计算日期 - d_出生日期) * 24 * 60);
          If Mod(n_Days, 60) = 0 Then
            v_Return := n_Days / 60 || '小时';
          Else
            v_Return := Floor(n_Days / 60) || '小时' || Mod(n_Days, 60) || '分钟';
          End If;
        Else
          --一天至一月  精确到小时 :X天X小时
          n_Days := Trunc((d_计算日期 - d_出生日期) * 24);
          If Mod(n_Days, 24) = 0 Then
            v_Return := n_Days / 24 || '天';
          Else
            v_Return := Floor(n_Days / 24) || '天' || Mod(n_Days, 24) || '小时';
          End If;
        End If;
      Else
        --大于1月
        n_Days := Trunc(Add_Months(d_计算日期, -1 * n_Months) - d_出生日期);
        If n_Days >= 31 Then
          --针对计算日期是2月份最后一天,出生日期刚好大于2月份最后一天且当天不是本月的最后一天
          --如：计算日期：2016-02-29   出生日期：2015-01-30
          n_Months := n_Months + 1;
          n_Days   := n_Days - 31;
        End If;
        If n_Days = 0 Then
          v_Return := n_Months || '月';
        Else
          v_Return := n_Months || '月' || n_Days || '天';
        End If;
      End If;
    Else
      --1岁到小于婴儿年龄上限的情况
      If Mod(n_Months, 12) = 0 Then
        v_Return := n_Months / 12 || '岁';
      Else
        v_Return := Floor(n_Months / 12) || '岁' || Mod(n_Months, 12) || '月';
      End If;
    End If;
  Else
    --大于等于婴儿年龄上限(直接X岁)
    v_Return := Floor(n_Months / 12) || '岁';
  End If;
  Return v_Return;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Age_Calc;
/

--103884:余伟节,2016-12-14,年龄格式检查允许指定计算日期
--103685:余伟节,2016-12-09,解决婴儿年龄支持X天X小时
Create Or Replace Function Zl_Age_Check
(
  年龄_In     病人信息.年龄%Type,
  出生日期_In Date := Null,
  计算日期_In Date := Null
) Return Varchar2
--年龄格式:X小时[X分钟];X天[X小时];X月[X天];X岁[X月]
 As
  v_Return           Varchar2(1000);
  v_Info             Varchar2(1000);
  v_Tmpone           Varchar2(20);
  v_Tmptwo           Varchar2(20);
  v_Unitone          Varchar2(4);
  v_Unittwo          Varchar2(4);
  n_Ageformatcorrect Number(1);
  n_Ageformat        Number(1);
  v_Age              病人信息.年龄%Type;
  v_Birthday         Varchar2(20);
Begin
  v_Info             := '1|年龄格式只能为:X小时[X分钟] 或 X天[X小时] 或 X月[X天] 或 X岁[X月]，并且X为正整数。';
  n_Ageformatcorrect := 0;
  --检查年龄格式是否正确
  For I In 1 .. 4 Loop
    If I = 1 Then
      v_Unitone := '岁';
      v_Unittwo := '月';
    Elsif I = 2 Then
      v_Unitone := '月';
      v_Unittwo := '天';
    Elsif I = 3 Then
      v_Unitone := '天';
      v_Unittwo := '小时';
    Else
      v_Unitone := '小时';
      v_Unittwo := '分钟';
    End If;
    --1:X岁[X月],2:X月[X天],3:X天,4:X小时[X分钟]
    If Instr(年龄_In, v_Unitone, 1) > 0 And n_Ageformatcorrect = 0 Then
      If Instr(年龄_In, v_Unitone, 1) = 1 Then
        v_Return := v_Info;
        Return v_Return;
      Else
        v_Tmpone := Substr(年龄_In, 1, Instr(年龄_In, v_Unitone, 1) - 1);
        --岁前面必须为数字
        If Translate(v_Tmpone, '\0123456789', '\') Is Null Then
          If To_Number(v_Tmpone) > 200 And v_Unitone = '岁' Then
            v_Return := '1|年龄格式为:X岁时，岁数不能大于200岁。';
            Return v_Return;
          Elsif To_Number(v_Tmpone) >= 12 And v_Unitone = '月' Then
            v_Return := '1|年龄格式为:X月时，月份数必须小于12个月。';
            Return v_Return;
          Elsif To_Number(v_Tmpone) >= 31 And v_Unitone = '天' Then
            v_Return := '1|年龄格式为:X天时，天数必须小于31天。';
            Return v_Return;
          Elsif To_Number(v_Tmpone) >= 24 And v_Unitone = '小时' Then
            v_Return := '1|年龄格式为:X小时时，小时数必须小于24小时。';
            Return v_Return;
          End If;
          If Instr(年龄_In, v_Unitone, 1) + Length(v_Unitone) - 1 = Length(年龄_In) Then
            n_Ageformatcorrect := I;
            Exit;
          Else
            v_Tmpone := Substr(年龄_In, Instr(年龄_In, v_Unitone, 1) + Length(v_Unitone));
            If Instr(v_Tmpone, v_Unittwo, 1) = 0 Or Length(v_Tmpone) = Length(v_Unittwo) Or
               Substr(v_Tmpone, Length(v_Tmpone) - Length(v_Unittwo) + 1, Length(v_Unittwo)) <> v_Unittwo Then
              v_Return := v_Info;
              Return v_Return;
            Else
              v_Tmptwo := Substr(v_Tmpone, 1, Length(v_Tmpone) - Length(v_Unittwo));
              If Translate(v_Tmptwo, '\0123456789', '\') Is Null Then
                If To_Number(v_Tmptwo) >= 12 And v_Unittwo = '月' Then
                  v_Return := '1|年龄格式为:[X岁X月]时，月份数必须小于12个月。';
                  Return v_Return;
                Elsif To_Number(v_Tmptwo) >= 31 And v_Unittwo = '天' Then
                  v_Return := '1|年龄格式为:[X月X天]时，天数必须小于31天。';
                  Return v_Return;
                Elsif To_Number(v_Tmptwo) >= 60 And v_Unittwo = '分钟' Then
                  v_Return := '1|年龄格式为:[X小时X分钟]时，分钟数必须小于60分钟。';
                  Return v_Return;
                Elsif To_Number(v_Tmptwo) >= 24 And v_Unittwo = '小时' Then
                  v_Return := '1|年龄格式为:[X天X小时]时，小时数必须小于24小时。';
                  Return v_Return;
                Else
                  n_Ageformatcorrect := I;
                  Exit;
                End If;
              Else
                v_Return := v_Info;
                Return v_Return;
              End If;
            End If;
          End If;
        Else
          v_Return := v_Info;
          Return v_Return;
        End If;
      End If;
    End If;
  End Loop;

  --年龄不再上述任何一个范围:如年龄为:51、1周1天
  If n_Ageformatcorrect = 0 Then
    v_Return := v_Info;
    Return v_Return;
  End If;
  --年龄格式正确，检查年龄段是否在出生日期段内
  If 出生日期_In Is Null Then
    Return Null;
  End If;
  v_Birthday := To_Char(出生日期_In, 'YYYY-MM-DD hh24:mi:ss');
  If Substr(v_Birthday, 12) = '00:00:00' Then
    v_Birthday := Substr(v_Birthday, 1, 10);
  Else
    v_Birthday := Substr(v_Birthday, 1, 16);
  End If;
  v_Age := Zl_Age_Calc(0, 出生日期_In, 计算日期_In);
  --计算根据出生日期计算出来的年龄在那一个段
  n_Ageformat := 0;
  v_Tmpone    := '';
  If Instr(v_Age, '岁', 1) > 0 Then
    n_Ageformat := 1;
    v_Tmpone    := 'X岁[X月]';
  Elsif Instr(v_Age, '月', 1) > 0 Then
    n_Ageformat := 2;
    v_Tmpone    := 'X月[X天]';
  Elsif Instr(v_Age, '天', 1) > 0 Then
    n_Ageformat := 3;
    v_Tmpone    := 'X天[小时]';
  Elsif Instr(v_Age, '小时', 1) > 0 Then
    n_Ageformat := 4;
    v_Tmpone    := 'X小时[X分钟]';
  End If;
  v_Return := '';
  If n_Ageformat = 0 Then
    v_Return := '1|计算年龄的函数：Zl_Age_Calc 存在问题,请直接与开发商联系。';
    Return v_Return;
  End If;
  --检查根据出生日期计算出来的年龄段和传入的年龄年龄段是否相同
  If n_Ageformatcorrect <> n_Ageformat Then
    v_Return := '1|年龄[' || 年龄_In || ']与出生日期计算出来的年龄[' || v_Age || ']在格式上不一致，';
    v_Return := v_Return || '当前年龄格式应该为:' || v_Tmpone || '。';
    Return v_Return;
  End If;
  --同一时间段内则坚持年龄是否相等
  If 年龄_In <> v_Age Then
    v_Return := '0|年龄[' || 年龄_In || ']与出生日期不一致，' || v_Birthday || '出生到现在应该是[' || v_Age || ']。';
  End If;
  Return v_Return;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Age_Check;
/

--103544:廖思奇,2016-12-08,过程增加对应参数
CREATE OR REPLACE Procedure Zl_影像插件功能_Update
(
  插件id_In           In 影像插件功能.插件id%Type,
  名称_In             In 影像插件功能.名称%Type,
  方法_In             In 影像插件功能.方法%Type,
  方法参数_In         In 影像插件功能.方法参数%Type,
  是否启用_In         In 影像插件功能.是否启用%Type,
  是否加入右键菜单_In In 影像插件功能.是否加入右键菜单%Type,
  是否加入工具栏_In   In 影像插件功能.是否加入工具栏%Type,
  自动执行时机_In     In 影像插件功能.自动执行时机%Type,
  Vbs脚本_In          In 影像插件功能.Vbs脚本%Type
) Is

  n_功能序号 影像插件功能.功能序号%Type;
  n_Id       Number;

Begin

  Select Nvl(Max(功能序号), 0) + 1 Into n_功能序号 From 影像插件功能 Where 插件id = 插件id_In;
  Select Nvl(Max(ID), 0) + 1 Into n_Id From 影像插件功能;

  Insert Into 影像插件功能
    (ID, 插件id, 功能序号, 名称, 方法, 方法参数, 是否启用, 是否加入右键菜单, 是否加入工具栏, 自动执行时机, Vbs脚本)
  Values
    (n_Id, 插件id_In, n_功能序号, 名称_In, 方法_In, 方法参数_In, 是否启用_In, 是否加入右键菜单_In, 是否加入工具栏_In, 自动执行时机_In, Vbs脚本_In);

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_影像插件功能_Update;
/

--103428:李南春,2017-02-16,医疗卡增加发卡控制
--103310:李南春,2016-12-08,医疗卡卡号增加回车符位
Create Or Replace Procedure Zl_医疗卡类别_Update
(
  Id_In             In 医疗卡类别.Id%Type,
  编码_In           In 医疗卡类别.编码%Type,
  名称_In           In 医疗卡类别.名称%Type,
  短名_In           In 医疗卡类别.短名%Type,
  前缀文本_In       In 医疗卡类别.前缀文本%Type,
  卡号长度_In       In 医疗卡类别.卡号长度%Type,
  缺省标志_In       In 医疗卡类别.缺省标志%Type,
  是否固定_In       In 医疗卡类别.是否固定%Type,
  是否严格控制_In   In 医疗卡类别.是否严格控制%Type,
  是否自制_In       In 医疗卡类别.是否自制%Type,
  是否存在帐户_In   In 医疗卡类别.是否存在帐户%Type,
  是否全退_In       In 医疗卡类别.是否全退%Type,
  部件_In           In 医疗卡类别.部件%Type,
  备注_In           In 医疗卡类别.备注%Type,
  特定项目_In       In 医疗卡类别.特定项目%Type,
  收费细目id_In     In 收费项目目录.Id%Type,
  结算方式_In       In 医疗卡类别.结算方式%Type,
  是否启用_In       In 医疗卡类别.是否启用%Type,
  卡号密文_In       In 医疗卡类别.卡号密文%Type,
  是否重复使用_In   In 医疗卡类别.是否重复使用%Type,
  密码长度_In       In 医疗卡类别.密码长度%Type,
  密码长度限制_In   In 医疗卡类别.密码长度限制%Type,
  密码规则_In       In 医疗卡类别.密码规则%Type,
  是否退现_In       In 医疗卡类别.是否退现%Type,
  操作方式_In       In Integer := 0,
  是否模糊查找_In   In 医疗卡类别.是否模糊查找%Type := 0,
  密码输入限制_In   In 医疗卡类别.密码输入限制%Type := 0,
  是否缺省密码_In   In 医疗卡类别.是否缺省密码%Type := 0,
  是否制卡_In       In 医疗卡类别.是否制卡%Type := 0,
  是否发卡_In       In 医疗卡类别.是否发卡%Type := 0,
  是否写卡_In       In 医疗卡类别.是否写卡%Type := 0,
  险类_In           In 医疗卡类别.险类%Type := 0,
  发卡性质_In       In 医疗卡类别.发卡性质%Type := 0,
  是否转帐及代扣_In In 医疗卡类别.是否转帐及代扣%Type := 0,
  读卡性质_In       In 医疗卡类别.读卡性质%Type := '1000',
  键盘控制方式_In   In 医疗卡类别.键盘控制方式%Type := 0,
  是否证件_In       In 医疗卡类别.是否证件%Type:=0,
  是否持卡消费_In   In 医疗卡类别.是否持卡消费%Type := 0,
  发送调用接口_In   In 医疗卡类别.发送调用接口%Type := 0,
  是否退款验卡_In   In 医疗卡类别.是否退款验卡%Type := 0,
  设备是否启用回车_In   In 医疗卡类别.设备是否启用回车%Type := 0,
  发卡卡号控制_In   In 医疗卡类别.发卡控制%Type := 0
) Is
  v_Err_Msg Varchar2(200);
  Err_Item Exception;
Begin
  If Nvl(是否自制_In, 0) = 1 And Nvl(是否存在帐户_In, 0) = 1 Then
    v_Err_Msg := '[ZLSOFT]是否存在帐户只有非自制卡才会存在,请检查![ZLSOFT]';
    Raise Err_Item;
  End If;
  If Nvl(是否自制_In, 0) = 0 And Nvl(是否存在帐户_In, 0) = 1 And 结算方式_In Is Null Then
    v_Err_Msg := '[ZLSOFT]第三方机构的卡结算，必须要设置结算方式,请检查![ZLSOFT]';
    Raise Err_Item;
  End If;
  If Nvl(是否自制_In, 0) = 1 And 特定项目_In Is Null Then
    v_Err_Msg := '[ZLSOFT]特定项目必须输入,请检查![ZLSOFT]';
    Raise Err_Item;
  End If;

  If 操作方式_In = 0 Then
    Insert Into 医疗卡类别
      (ID, 编码, 名称, 短名, 前缀文本, 卡号长度, 缺省标志, 是否固定, 是否严格控制, 是否自制, 是否存在帐户, 是否全退, 部件, 备注, 特定项目, 结算方式, 是否启用, 卡号密文, 是否重复使用, 密码长度,
       密码长度限制, 密码规则, 是否退现, 是否模糊查找, 密码输入限制, 是否缺省密码, 是否制卡, 是否发卡, 是否写卡, 险类, 发卡性质, 是否转帐及代扣, 读卡性质, 键盘控制方式, 是否持卡消费, 发送调用接口,
       是否退款验卡,是否证件, 设备是否启用回车, 发卡控制)
    Values
      (Id_In, 编码_In, 名称_In, 短名_In, 前缀文本_In, 卡号长度_In, 缺省标志_In, 是否固定_In, 是否严格控制_In, 是否自制_In, 是否存在帐户_In, 是否全退_In, 部件_In,
       备注_In, 特定项目_In, 结算方式_In, 是否启用_In, 卡号密文_In, 是否重复使用_In, 密码长度_In, 密码长度限制_In, 密码规则_In, 是否退现_In, 是否模糊查找_In, 密码输入限制_In,
       是否缺省密码_In, 是否制卡_In, 是否发卡_In, 是否写卡_In, 险类_In, 发卡性质_In, 是否转帐及代扣_In, 读卡性质_In, 键盘控制方式_In, 是否持卡消费_In, 发送调用接口_In,
       是否退款验卡_In,是否证件_In, 设备是否启用回车_In, 发卡卡号控制_In);
  
  Else
  
    Delete 收费特定项目 Where 特定项目 = (Select Max(特定项目) From 医疗卡类别 Where ID = Id_In);
  
    Update 医疗卡类别
    Set 编码 = 编码_In, 名称 = 名称_In, 短名 = 短名_In, 前缀文本 = 前缀文本_In, 卡号长度 = 卡号长度_In, 缺省标志 = 缺省标志_In, 是否严格控制 = 是否严格控制_In,
        是否自制 = 是否自制_In, 是否存在帐户 = 是否存在帐户_In, 是否全退 = 是否全退_In, 部件 = 部件_In, 备注 = 备注_In, 特定项目 = 特定项目_In, 结算方式 = 结算方式_In,
        是否启用 = 是否启用_In, 卡号密文 = 卡号密文_In, 是否重复使用 = 是否重复使用_In, 密码长度 = 密码长度_In, 密码长度限制 = 密码长度限制_In, 密码规则 = 密码规则_In,
        是否退现 = 是否退现_In, 是否模糊查找 = 是否模糊查找_In, 密码输入限制 = 密码输入限制_In, 是否缺省密码 = 是否缺省密码_In, 是否制卡 = 是否制卡_In, 是否发卡 = 是否发卡_In,
        是否写卡 = 是否写卡_In, 险类 = 险类_In, 发卡性质 = 发卡性质_In, 是否转帐及代扣 = 是否转帐及代扣_In, 读卡性质 = 读卡性质_In, 键盘控制方式 = 键盘控制方式_In,
        是否持卡消费 = 是否持卡消费_In, 发送调用接口 = 发送调用接口_In, 是否退款验卡 = 是否退款验卡_In,是否证件 = 是否证件_In, 设备是否启用回车 = 设备是否启用回车_In,
        发卡控制 = 发卡卡号控制_In
    Where ID = Id_In;
    If Nvl(缺省标志_In, 0) = 1 Then
      Update 医疗卡类别 Set 缺省标志 = 0 Where ID <> Id_In;
    End If;
  
  End If;
  If Not 特定项目_In Is Null And Nvl(收费细目id_In, 0) <> 0 Then
    Insert Into 收费特定项目 (特定项目, 收费细目id) Values (特定项目_In, 收费细目id_In);
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_医疗卡类别_Update;
/

--104513:刘尔旋,2016-12-28,计划排班模式单独购买病历费问题
--102791:刘尔旋,2016-12-08,预约排队按时点显示
Create Or Replace Procedure Zl_病人挂号记录_Insert
(
  病人id_In        门诊费用记录.病人id%Type,
  门诊号_In        门诊费用记录.标识号%Type,
  姓名_In          门诊费用记录.姓名%Type,
  性别_In          门诊费用记录.性别%Type,
  年龄_In          门诊费用记录.年龄%Type,
  付款方式_In      门诊费用记录.付款方式%Type, --用于存放病人的医疗付款方式编号
  费别_In          门诊费用记录.费别%Type,
  单据号_In        门诊费用记录.No%Type,
  票据号_In        门诊费用记录.实际票号%Type,
  序号_In          门诊费用记录.序号%Type,
  价格父号_In      门诊费用记录.价格父号%Type,
  从属父号_In      门诊费用记录.从属父号%Type,
  收费类别_In      门诊费用记录.收费类别%Type,
  收费细目id_In    门诊费用记录.收费细目id%Type,
  数次_In          门诊费用记录.数次%Type,
  标准单价_In      门诊费用记录.标准单价%Type,
  收入项目id_In    门诊费用记录.收入项目id%Type,
  收据费目_In      门诊费用记录.收据费目%Type,
  结算方式_In      病人预交记录.结算方式%Type, --现金的结算名称
  应收金额_In      门诊费用记录.应收金额%Type,
  实收金额_In      门诊费用记录.实收金额%Type,
  病人科室id_In    门诊费用记录.病人科室id%Type,
  开单部门id_In    门诊费用记录.开单部门id%Type,
  执行部门id_In    门诊费用记录.执行部门id%Type,
  操作员编号_In    门诊费用记录.操作员编号%Type,
  操作员姓名_In    门诊费用记录.操作员姓名%Type,
  发生时间_In      门诊费用记录.发生时间%Type,
  登记时间_In      门诊费用记录.登记时间%Type,
  医生姓名_In      挂号安排.医生姓名%Type,
  医生id_In        挂号安排.医生id%Type,
  病历费_In        Number, --该条记录是否病历工本费
  急诊_In          Number,
  号别_In          挂号安排.号码%Type,
  诊室_In          门诊费用记录.发药窗口%Type,
  结帐id_In        门诊费用记录.结帐id%Type,
  领用id_In        票据使用明细.领用id%Type,
  预交支付_In      病人预交记录.冲预交%Type, --刷卡挂号时使用的预交金额,序号为1传入.
  现金支付_In      病人预交记录.冲预交%Type, --挂号时现金支付部份金额,序号为1传入.
  个帐支付_In      病人预交记录.冲预交%Type, --挂号时个人帐户支付金额,,序号为1传入.
  保险大类id_In    门诊费用记录.保险大类id%Type,
  保险项目否_In    门诊费用记录.保险项目否%Type,
  统筹金额_In      门诊费用记录.统筹金额%Type,
  摘要_In          门诊费用记录.摘要%Type, --预约挂号摘要信息
  预约挂号_In      Number := 0, --预约挂号时用(记录状态=0,发生时间为预约时间),此时不需要传入结算相关参数
  收费票据_In      Number := 0, --挂号是否使用收费票据
  保险编码_In      门诊费用记录.保险编码%Type,
  复诊_In          病人挂号记录.复诊%Type := 0,
  号序_In          挂号序号状态.序号%Type := Null, --预约时填入费用记录的发药窗口字段,挂号时填入挂号记录
  社区_In          病人挂号记录.社区%Type := Null,
  预约接收_In      Number := 0,
  预约方式_In      预约方式.名称%Type := Null,
  生成队列_In      Number := 0,
  卡类别id_In      病人预交记录.卡类别id%Type := Null,
  结算卡序号_In    病人预交记录.结算卡序号%Type := Null,
  卡号_In          病人预交记录.卡号%Type := Null,
  交易流水号_In    病人预交记录.交易流水号%Type := Null,
  交易说明_In      病人预交记录.交易说明%Type := Null,
  合作单位_In      病人预交记录.合作单位%Type := Null,
  操作类型_In      Number := 0,
  险类_In          病人挂号记录.险类%Type := Null,
  结算模式_In      Number := 0,
  记帐费用_In      Number := 0,
  退号重用_In      Number := 1,
  冲预交病人ids_In Varchar2 := Null,
  修正病人费别_In  Number := 0,
  修正病人年龄_In  Number := 0
) As
  ---------------------------------------------------------------------------
  --
  --参数:
  --     操作类型_in:0-正常挂号或者预约 1-操作员拥有加号权限加号
  --     修正病人费别_In:0-不修改病人费别 1-修改病人费别
  ----------------------------------------------------------------------------
  --该游标用于收费冲预交的可用预交列表
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit
  (
    v_病人id        病人信息.病人id%Type,
    v_冲预交病人ids Varchar2
  ) Is
    Select 病人id, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额, Min(记录状态) As 记录状态, Nvl(Max(结帐id), 0) As 结帐id,
           Max(Decode(记录性质, 1, ID, 0) * Decode(记录状态, 2, 0, 1)) As 原预交id
    From 病人预交记录
    Where 记录性质 In (1, 11) And 病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And Nvl(预交类别, 2) = 1
     Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
    Group By NO, 病人id
    Order By Decode(病人id, Nvl(v_病人id, 0), 0, 1), 结帐id, NO;
  --功能：新增一行病人挂号费用，并将结算汇总到病人预交记录
  --       同时汇总相关的汇总表(病人挂号汇总、费用汇总)
  --       第一行费用处理票据使用情况(领用ID_IN>0)

  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_排队号码 排队叫号队列.排队号码%Type;
  v_现金     结算方式.名称%Type;
  v_个人帐户 结算方式.名称%Type;
  v_队列名称 排队叫号队列.队列名称%Type;

  n_分时段       Number;
  n_时段限号     Number;
  n_时段限约     Number;
  d_时段时间     Date;
  d_最大序号时间 Date;
  n_追加号       Number := 0; --处理时段过期 追加挂号的情况 
  n_已约数       病人挂号汇总.已约数%Type;
  n_已接收       病人挂号汇总.其中已接收%Type;
  n_预约有效时间 Number;
  n_失效数       Number;
  n_失约挂号     Number := 0;
  n_已用数量     Number;
  n_锁定         Number := 0;

  n_打印id        票据打印内容.Id%Type;
  n_费用id        门诊费用记录.Id%Type;
  n_预交金额      病人预交记录.金额%Type;
  n_当前金额      病人预交记录.金额%Type;
  n_返回值        病人预交记录.金额%Type;
  n_预交id        病人预交记录.Id%Type;
  n_消费卡id      消费卡目录.Id%Type;
  n_挂号id        病人挂号记录.Id%Type;
  v_冲预交病人ids Varchar2(4000);

  n_组id           财务缴款分组.Id%Type;
  n_门诊号         病人信息.门诊号%Type;
  n_序号           挂号序号状态.序号%Type;
  n_已用序号       挂号序号状态.序号%Type;
  n_序号控制       挂号安排.序号控制%Type;
  n_分诊台签到排队 Number;
  n_Count          Number;
  n_限号数         Number(18);
  n_自制卡         Number;
  d_排队时间       Date;
  d_序号时间       Date;
  v_费别           费别.名称%Type;
  n_时段序号       Number := -1;
  n_预约生成队列   Number;
  n_安排id         挂号安排.Id%Type;
  n_计划id         挂号安排计划.Id%Type := 0;
  v_星期           挂号安排限制.限制项目%Type;
  n_限约数         Number(18);
  n_已挂数         Number(4) := 0;

  n_挂出的最大序号 Number(4) := 0;
  n_结算模式       病人信息.结算模式%Type;
  v_排队序号       排队叫号队列.排队序号%Type;
  v_机器名         挂号序号状态.机器名%Type;
  v_序号操作员     挂号序号状态.操作员姓名%Type;
  v_序号机器名     挂号序号状态.机器名%Type;
  v_付款方式       病人挂号记录.医疗付款方式%Type;
  v_Temp           Varchar2(3000);
  v_时间段         时间段.时间段%Type;
  d_检查开始时间   时间段.开始时间%Type;
  d_检查结束时间   时间段.终止时间%Type;
  n_出诊记录id     临床出诊记录.Id%Type;
  n_分时点显示     Number(3);
  d_启用时间       Date;
Begin
  --获取当前机器名称
  Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
  n_组id          := Zl_Get组id(操作员姓名_In);
  v_冲预交病人ids := Nvl(冲预交病人ids_In, 病人id_In);

  If 费别_In Is Null Then
    Begin
      Select 名称 Into v_费别 From 费别 Where 缺省标志 = 1 And Rownum < 2;
      Update 病人信息 Set 费别 = v_费别 Where 病人id = 病人id_In;
    Exception
      When Others Then
        v_Err_Msg := '无法确定病人费别，请检查缺省费别是否正确设置！';
        Raise Err_Item;
    End;
  Else
    v_费别 := 费别_In;
    If Nvl(修正病人费别_In, 0) = 1 Then
      Begin
        Update 病人信息 Set 费别 = v_费别 Where 病人id = 病人id_In;
      Exception
        When Others Then
          v_Err_Msg := '没有找到对应的病人！';
          Raise Err_Item;
      End;
    End If;
  End If;

  If Nvl(修正病人年龄_In, 0) = 1 Then
    Begin
      Update 病人信息 Set 年龄 = 年龄_In Where 病人id = 病人id_In;
    Exception
      When Others Then
        v_Err_Msg := '没有找到对应的病人！';
        Raise Err_Item;
    End;
  End If;

  If 门诊号_In Is Not Null Then
    Begin
      Select Nvl(门诊号, 0) Into n_门诊号 From 病人信息 Where 病人id = 病人id_In;
    Exception
      When Others Then
        n_门诊号 := 0;
    End;
    If n_门诊号 = 0 Then
      Update 病人信息 Set 门诊号 = 门诊号_In Where 病人id = 病人id_In;
    End If;
  End If;

  Begin
    Delete From 挂号序号状态
    Where 号码 = 号别_In And 日期 = 发生时间_In And 序号 = 号序_In And 状态 = 3 And 操作员姓名 = 操作员姓名_In;
  Exception
    When Others Then
      Null;
  End;
  v_Temp := zl_GetSysParameter(256);
  If v_Temp Is Null Or Substr(v_Temp, 1, 1) = '0' Then
    Null;
  Else
    Begin
      d_启用时间 := To_Date(Substr(v_Temp, 3), 'YYYY-MM-DD hh24:mi:ss');
    Exception
      When Others Then
        d_启用时间 := Null;
    End;
    If d_启用时间 Is Not Null Then
      If 发生时间_In > d_启用时间 Then
        v_Err_Msg := '当前挂号的发生时间' || To_Char(发生时间_In, 'yyyy-mm-dd hh24:mi:ss') || '已经启用了出诊表排班模式,不能再使用计划排班模式挂号!';
        Raise Err_Item;
      End If;
    End If;
  End If;

  If Nvl(预约挂号_In, 0) = 0 Then
    --挂号或者预约接收
    --因为现在有按日编单据号规则,日挂号量不能超过10000次,所以要检查唯一约束。
    Select Count(*)
    Into n_Count
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 In (1, 3) And 序号 = 序号_In And NO = 单据号_In;
    If n_Count <> 0 Then
      v_Err_Msg := '挂号单据号重复,不能保存！' || Chr(13) || '如果使用了按日顺序编号,当日挂号量不能超过10000人次。';
      Raise Err_Item;
    End If;
  
    --获取结算方式名称
    Begin
      Select 名称 Into v_现金 From 结算方式 Where 性质 = 1;
    Exception
      When Others Then
        v_现金 := '现金';
    End;
    Begin
      Select 名称 Into v_个人帐户 From 结算方式 Where 性质 = 3;
    Exception
      When Others Then
        v_个人帐户 := '个人帐户';
    End;
  End If;

  n_序号 := 号序_In;
  Select Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null)
  Into v_星期
  From Dual;

  --挂号获取安排
  Begin
    Select a.Id, a.序号控制, Nvl(b.限号数, 0), Nvl(b.限约数, 0)
    Into n_安排id, n_序号控制, n_限号数, n_限约数
    From 挂号安排 A, 挂号安排限制 B
    Where a.Id = b.安排id(+) And b.限制项目(+) = v_星期 And a.号码 = 号别_In;
  
  Exception
    When Others Then
      n_安排id := -1;
  End;

  --如果是病历费或者号别为空时不检查
  If Nvl(病历费_In, 0) = 0 Or 号别_In Is Not Null Then
    If n_安排id = -1 Then
      v_Err_Msg := '不存相应的挂号安排数据,请检查';
      Raise Err_Item;
    End If;
  End If;

  If Nvl(预约挂号_In, 0) = 1 Then
    --首先获取计划
    Begin
      Select ID
      Into n_计划id
      From 挂号安排计划
      Where 安排id = n_安排id And 审核时间 Is Not Null And
            Nvl(生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) =
            (Select Max(a.生效时间) As 生效
             From 挂号安排计划 A
             Where a.审核时间 Is Not Null And 发生时间_In Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                   Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) And a.安排id = n_安排id) And
            发生时间_In Between Nvl(生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
            Nvl(失效时间, To_Date('3000-01-01', 'yyyy-mm-dd'));
    
    Exception
      When Others Then
        n_计划id := 0;
    End;
    If Nvl(n_计划id, 0) <> 0 Then
      Begin
        --获取计划的限制
        Select a.Id, a.序号控制, Nvl(b.限号数, 0) As 限号数, Nvl(b.限约数, 0) As 限约数
        Into n_计划id, n_序号控制, n_限号数, n_限约数
        From 挂号安排计划 A, 挂号计划限制 B
        Where a.号码 = 号别_In And a.Id = n_计划id And a.审核时间 Is Not Null And a.Id = b.计划id(+) And b.限制项目(+) = v_星期;
      Exception
        When Others Then
          v_Err_Msg := '不存相应的挂号安排或计划数据,请检查';
          Raise Err_Item;
      End;
    End If;
  End If;

  --获取是否分时段
  Begin
    If Nvl(n_计划id, 0) = 0 Then
      Select Count(Rownum) Into n_分时段 From 挂号安排时段 Where 星期 = v_星期 And 安排id = n_安排id And Rownum <= 1;
      Select Decode(To_Char(发生时间_In, 'D'), '1', 周日, '2', 周一, '3', 周二, '4', 周三, '5', 周四, '6', 周五, '7', 周六, Null)
      Into v_时间段
      From 挂号安排
      Where ID = n_安排id;
    Else
      Select Count(Rownum) Into n_分时段 From 挂号计划时段 Where 星期 = v_星期 And 计划id = n_计划id And Rownum <= 1;
      Select Decode(To_Char(发生时间_In, 'D'), '1', 周日, '2', 周一, '3', 周二, '4', 周三, '5', 周四, '6', 周五, '7', 周六, Null)
      Into v_时间段
      From 挂号安排计划
      Where ID = n_计划id;
    End If;
  Exception
    When Others Then
      v_时间段 := Null;
  End;

  If v_时间段 Is Not Null And d_启用时间 Is Not Null And 序号_In = 1 Then
    --检查是否跨模式挂号安排
    Select To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'),
           To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(终止时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss')
    Into d_检查开始时间, d_检查结束时间
    From 时间段
    Where 时间段 = v_时间段 And 站点 Is Null And 号类 Is Null;
    If d_检查开始时间 > d_检查结束时间 Then
      d_检查结束时间 := d_检查结束时间 + 1;
    End If;
    If d_检查结束时间 > d_启用时间 Then
      --获取出诊记录id
      Begin
        Select a.Id
        Into n_出诊记录id
        From 临床出诊记录 A, 临床出诊号源 B
        Where a.号源id = b.Id And b.号码 = 号别_In And 上班时段 = v_时间段 And 发生时间_In Between 开始时间 And 终止时间;
      Exception
        When Others Then
          n_出诊记录id := Null;
      End;
    End If;
  End If;

  --分时段挂号时判断是否是过期挂号 也就是追加号的情况 目前只针对专家号分时段进行处理
  If Nvl(预约挂号_In, 0) = 0 And n_分时段 > 0 And Nvl(n_序号控制, 0) = 1 And 号序_In Is Null And Nvl(操作类型_In, 0) = 0 Then
    --发生时间_in>Sysdate 发生时间>最大的时段时间--号序_in is null
    Begin
      Select Max(To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'))
      Into d_最大序号时间
      From 挂号安排时段
      Where 安排id = n_安排id And 星期 = v_星期 And Nvl(限制数量, 0) <> 0;
      n_追加号 := Case Sign(发生时间_In - d_最大序号时间)
                 When -1 Then
                  0
                 Else
                  1
               End;
    Exception
      When Others Then
        n_追加号 := 0;
    End;
  End If;
  d_时段时间 := 发生时间_In;

  If 序号_In = 1 And Nvl(预约挂号_In, 0) = 0 And n_分时段 > 0 Then
    --挂号时检查 是否分了时段,分了时段,把时段的限制条件给取出来
    Begin
      Select Nvl(序号, 0),
             To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'),
             限制数量, Decode(Nvl(是否预约, 0), 0, 0, 限制数量)
      Into n_时段序号, d_时段时间, n_时段限号, n_时段限约
      From 挂号安排时段
      Where 安排id = n_安排id And 星期 = v_星期 And
            (序号, 安排id, 星期) In (Select Nvl(Max(序号), -1), 安排id, 星期
                               From 挂号安排时段
                               Where 安排id = n_安排id And 星期 = v_星期 And
                                     Decode(操作类型_In + n_追加号, 0, To_Char(发生时间_In, 'hh24:mi'),
                                            To_Char(Nvl(开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi')) =
                                     To_Char(Nvl(开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi')
                               Group By 安排id, 星期);
    Exception
      When Others Then
        n_时段序号 := -1;
        n_分时段   := 0;
        d_时段时间 := 发生时间_In;
        n_时段限号 := 0;
        n_时段限约 := 0;
    End;
  End If;

  If 序号_In = 1 And Nvl(预约挂号_In, 0) = 1 And n_分时段 > 0 Then
    --预约号,取计划
    Begin
      If Nvl(n_计划id, 0) = 0 Then
        --没计划生效,取安排的数据
        Select Nvl(序号, 0),
               To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(c.开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 时段时间,
               限制数量, Decode(Nvl(是否预约, 0), 0, 0, 限制数量)
        Into n_时段序号, d_时段时间, n_时段限号, n_时段限约
        From 挂号安排时段 C
        Where 安排id = n_安排id And 星期 = v_星期 And
              (序号, 安排id, 星期) In
              (Select Nvl(Max(c.序号), -1), 安排id, 星期
               From 挂号安排时段 C
               Where 安排id = n_安排id And c.星期 = v_星期 And
                     Decode(操作类型_In, 1, To_Char(Nvl(c.开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi'),
                            To_Char(发生时间_In, 'hh24:mi')) =
                     To_Char(Nvl(c.开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi')
               Group By 安排id, 星期);
      Else
        --有计划生效取计划
        --没生效，代表是从挂号计划时段查询      
        Select Nvl(序号, -1),
               To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(c.开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 时段时间,
               限制数量, Decode(Nvl(是否预约, 0), 0, 0, 限制数量)
        Into n_时段序号, d_时段时间, n_时段限号, n_时段限约
        From 挂号计划时段 C
        Where 计划id = n_计划id And 星期 = v_星期 And
              (序号, 计划id, 星期) In
              (Select Nvl(Max(c.序号), -1), 计划id, 星期
               From 挂号计划时段 C
               Where 计划id = n_计划id And c.星期 = v_星期 And
                     Decode(操作类型_In, 1, To_Char(Nvl(c.开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi'),
                            To_Char(发生时间_In, 'hh24:mi')) =
                     To_Char(Nvl(c.开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi')
               Group By 计划id, 星期);
      End If;
    Exception
      When Others Then
        n_时段序号 := -1;
        n_分时段   := 0;
        d_时段时间 := 发生时间_In;
        n_时段限号 := 0;
        n_时段限约 := 0;
    End;
  End If;

  If 序号_In = 1 Then
  
    --获取当前未使用的序号
    If Nvl(n_序号控制, 0) = 1 And n_分时段 = 0 Then
      --<序号控制 未设置时段 获取可用的最大序号,以及已经使用的数量>     
      Begin
        --最大序号
        If 退号重用_In = 1 Then
          Select Max(Nvl(序号, 0)), Sum(Decode(序号, Nvl(号序_In, 0), 0, 1)), Sum(Nvl(预约, 0))
          Into n_已用序号, n_已用数量, n_已约数
          From 挂号序号状态
          Where 号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 状态 Not In (4, 5);
        Else
          Select Max(Nvl(序号, 0)), Sum(Decode(序号, Nvl(号序_In, 0), 0, 1)), Sum(Nvl(预约, 0))
          Into n_已用序号, n_已用数量, n_已约数
          From 挂号序号状态
          Where 号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 状态 <> 5;
        End If;
      Exception
        When Others Then
          n_已用序号 := 0;
          n_已用数量 := 0;
      End;
      If n_序号 Is Null Then
        n_序号 := Nvl(n_已用序号, 0) + 1;
      End If;
      --<序号控制 未设置时段 获取可用的最大序号 以及已经使用的数量 --end>
    
      --非加号的情况需要检查是否超过了限制
      If 操作类型_In = 0 Then
        If Nvl(预约挂号_In, 0) = 0 Then
          --挂号时检查       
          --启用序号控制未分时段 达到了限制
          If n_限号数 <= n_已用数量 And n_限号数 > 0 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(Trunc(发生时间_In), 'yyyy-mm-dd ') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        
        Else
          --预约时检查
          If n_限约数 = 0 Then
            n_限约数 := n_限号数;
          End If;
        
          If n_限约数 <= n_已约数 And n_限约数 > 0 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(Trunc(发生时间_In), 'yyyy-mm-dd') || '已达到最大限约数！';
            Raise Err_Item;
          End If;
        End If;
      
      Else
        Null;
        --启用序号控制,未分时段 加号情况   不处理,如果以后有限制条件以后补充
      End If;
    
    Elsif Nvl(n_分时段, 0) > 0 And Nvl(n_序号控制, 0) = 0 Then
      --<--普通号分时段 这里只有预约一种情况-->
      If 操作类型_In = 0 Then
        --<正常预约挂号-->
        Begin
          Select Count(0) As 已挂数, Nvl(Sum(Decode(Nvl(Sign(a.日期 - d_时段时间), 0), 0, 1, 0)), 0) As 已约数
          Into n_已挂数, n_已约数
          From 挂号序号状态 A
          Where a.号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And
                状态 Not In (4, 5);
        Exception
          When Others Then
            n_已挂数 := 0;
            n_已约数 := 0;
        End;
      
        n_时段限约 := n_时段限号; --普通号分时段的情况,29中n_时段限约始终是0 这里特殊处理
        --检查限制数量  
        If n_限约数 = 0 Then
          n_限约数 := n_限号数;
        End If;
        If n_时段限约 <= n_已约数 Or n_限约数 <= n_已约数 Then
          v_Err_Msg := '号别' || 号别_In || '在时段' || To_Char(d_时段时间, 'hh24:mi') || '已达到最大限约数！';
          Raise Err_Item;
        End If;
        If n_限号数 <= n_已挂数 Then
          v_Err_Msg := '号别' || 号别_In || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
          Raise Err_Item;
        End If;
      End If;
    
      --没有达到时段的限号数 号码在当前时段往后追加
    
      --获取当天挂出的最大号序
      If 退号重用_In = 1 Then
        Select Nvl(Max(序号), 0)
        Into n_挂出的最大序号
        From 挂号序号状态 A
        Where a.日期 = d_时段时间 And 号码 = 号别_In And 状态 Not In (4, 5);
      Else
        Select Nvl(Max(序号), 0)
        Into n_挂出的最大序号
        From 挂号序号状态 A
        Where a.日期 = d_时段时间 And 号码 = 号别_In And 状态 <> 5;
      End If;
    
      --设置序号
      n_序号 := RPad(Nvl(n_时段序号, 0), Length(n_限号数) + Length(Nvl(n_时段序号, 0)), 0) + n_已约数 + 1;
      If n_序号 <= Nvl(n_挂出的最大序号, 0) Then
        n_序号 := Nvl(n_挂出的最大序号, 0) + 1;
      End If;
    
      --<--普通号分时段--End>
    Elsif Nvl(n_分时段, 0) > 0 And Nvl(n_序号控制, 0) = 1 Then
      --<启用序号控制 设置时段
      --专家号分时段
      Begin
        If 退号重用_In = 1 Then
          Select Max(序号), Sum(Decode(序号, Nvl(号序_In, 0), 0, 1)), Sum(Decode(Sign(日期 - d_时段时间), 0, 1, 0))
          Into n_已用序号, n_已挂数, n_已用数量
          From 挂号序号状态
          Where 号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 状态 Not In (4, 5);
        Else
          Select Max(序号), Sum(Decode(序号, Nvl(号序_In, 0), 0, 1)), Sum(Decode(Sign(日期 - d_时段时间), 0, 1, 0))
          Into n_已用序号, n_已挂数, n_已用数量
          From 挂号序号状态
          Where 号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 状态 <> 5;
        End If;
      Exception
        When Others Then
          n_已用序号 := 0;
          n_已用数量 := 0;
          n_已挂数   := 0;
      End;
    
      n_失效数 := 0;
      If Nvl(预约挂号_In, 0) = 0 Then
        n_预约有效时间 := Zl_To_Number(zl_GetSysParameter('预约有效时间', 1111));
        n_失约挂号     := Zl_To_Number(zl_GetSysParameter('失约用于挂号', 1111));
        If Nvl(n_预约有效时间, 0) <> 0 And Nvl(n_失约挂号, 0) > 0 Then
          Begin
            Select Sum(Decode(Sign((Sysdate - n_预约有效时间 / 24 / 60) - 日期), 1, 1, 0))
            Into n_失效数
            From 挂号序号状态
            Where 号码 = 号别_In And 日期 Between Trunc(Sysdate) And Sysdate And Nvl(预约, 0) = 1 And 状态 = 2;
          Exception
            When Others Then
              n_失效数 := 0;
          End;
        End If;
      End If;
    
      If 操作类型_In = 0 Then
        If Nvl(预约挂号_In, 0) = 0 Then
        
          --挂号 追加号码时不检查时段限号数
          If n_时段限号 <= n_已用数量 And Nvl(n_追加号, 0) = 0 Then
            v_Err_Msg := '号别' || 号别_In || '在时段' || To_Char(d_时段时间, 'hh24:mi') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
          If n_限号数 <= n_已挂数 - n_失效数 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        
        Else
          --挂号
          If n_限约数 = 0 Then
            n_限约数 := n_限号数;
          End If;
          If n_限约数 <= n_已用数量 Then
            v_Err_Msg := '号别' || 号别_In || '在时段' || To_Char(d_时段时间, 'hh24:mi') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
          If n_限号数 <= n_已挂数 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        End If;
      End If;
      If n_序号 Is Null Then
        --设置序号
        If Nvl(n_已用序号, 0) < Nvl(n_时段序号, 0) Then
          n_已用序号 := Nvl(n_时段序号, 0);
        End If;
        n_序号 := Nvl(n_已用序号, 0) + 1;
      End If;
    Elsif Nvl(n_分时段, 0) = 0 And Nvl(n_序号控制, 0) = 0 And Nvl(病历费_In, 0) = 0 And Nvl(号别_In, 0) > 0 Then
      ---<--普通号  -->
      Begin
        Select 已挂数, 已约数
        Into n_已用数量, n_已约数
        From 病人挂号汇总
        Where 日期 = Trunc(发生时间_In) And 号码 = 号别_In;
      Exception
        When Others Then
          n_已用数量 := 0;
          n_已约数   := 0;
      End;
      If Nvl(操作类型_In, 0) = 0 Then
        If Nvl(预约挂号_In, 0) = 0 Then
          --挂号
          If Nvl(n_已用数量, 0) >= Nvl(n_限号数, 0) And Nvl(n_限号数, 0) > 0 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        Else
          --预约
          If (Nvl(n_限约数, 0) > 0 And Nvl(n_已约数, 0) >= Nvl(n_限约数, 0)) Or
             (Nvl(n_已用数量, 0) >= Nvl(n_限号数, 0) And Nvl(n_限号数, 0) > 0) Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        End If;
      End If;
      ---<--普通号  -->
    End If;
  End If;

  --更新挂号序号状态
  If 序号_In = 1 And Not n_序号 Is Null Then
    If n_分时段 = 1 Then
      d_序号时间 := 发生时间_In;
    Else
      d_序号时间 := Trunc(发生时间_In);
    End If;
    --锁定序号的处理
    Begin
      Select 操作员姓名, 机器名
      Into v_序号操作员, v_序号机器名
      From 挂号序号状态
      Where 状态 = 5 And 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号;
      n_锁定 := 1;
    Exception
      When Others Then
        v_序号操作员 := Null;
        v_序号机器名 := Null;
        n_锁定       := 0;
    End;
    If n_锁定 = 0 Then
      Update 挂号序号状态
      Set 状态 = Decode(预约挂号_In, 1, 2, 1), 预约 = Decode(预约接收_In, 1, 1, 0), 登记时间 = Sysdate
      Where 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号 And 状态 = 3 And 操作员姓名 = 操作员姓名_In;
      If Sql%RowCount = 0 Then
        Begin
          If Nvl(n_分时段, 0) = 0 Or Nvl(预约挂号_In, 0) = 1 Or (Nvl(n_序号控制, 0) = 0 And Nvl(号序_In, 0) = 0) Then
            Insert Into 挂号序号状态
              (号码, 日期, 序号, 状态, 操作员姓名, 预约, 登记时间)
            Values
              (号别_In, d_序号时间, n_序号, Decode(预约挂号_In, 1, 2, 1), 操作员姓名_In, Decode(预约接收_In, 1, 1, 0), Sysdate);
            If Nvl(预约挂号_In, 0) = 0 And 预约方式_In Is Not Null Then
              Update 挂号序号状态 Set 预约 = 1 Where 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号;
            End If;
          Elsif Nvl(n_分时段, 0) > 0 Then
            --分时段后专家号 失约的预约号允许挂号
            Update 挂号序号状态
            Set 状态 = Decode(预约挂号_In, 1, 2, 1), 操作员姓名 = 操作员姓名_In, 预约 = Decode(预约接收_In, 1, 1, 0), 登记时间 = Sysdate
            Where 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号 And 状态 = 2;
            If Sql%NotFound Then
              Insert Into 挂号序号状态
                (号码, 日期, 序号, 状态, 操作员姓名, 预约, 登记时间)
              Values
                (号别_In, d_序号时间, n_序号, Decode(预约挂号_In, 1, 2, 1), 操作员姓名_In, Decode(预约接收_In, 1, 1, 0), Sysdate);
            End If;
            If Nvl(预约挂号_In, 0) = 0 And 预约方式_In Is Not Null Then
              Update 挂号序号状态 Set 预约 = 1 Where 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号;
            End If;
          End If;
        Exception
          When Others Then
            v_Err_Msg := '序号' || n_序号 || '已被使用,请重新选择一个序号.';
            Raise Err_Item;
        End;
      End If;
    Else
      If 操作员姓名_In <> v_序号操作员 Or v_机器名 <> v_序号机器名 Then
        v_Err_Msg := '序号' || n_序号 || '已被自助机' || v_机器名 || '锁定,请重新选择一个序号.';
        Raise Err_Item;
      Else
        Update 挂号序号状态
        Set 状态 = Decode(预约挂号_In, 1, 2, 1), 预约 = Decode(预约接收_In, 1, 1, 0), 登记时间 = Sysdate
        Where 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号 And 状态 = 5 And 操作员姓名 = 操作员姓名_In And 机器名 = v_机器名;
        If Nvl(预约挂号_In, 0) = 0 And 预约方式_In Is Not Null Then
          Update 挂号序号状态 Set 预约 = 1 Where 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号;
        End If;
      End If;
    End If;
  End If;

  If n_出诊记录id Is Not Null Then
    Update 临床出诊序号控制
    Set 挂号状态 = Decode(预约挂号_In, 1, 2, 1), 操作员姓名 = 操作员姓名_In
    Where 记录id = n_出诊记录id And 序号 = n_序号;
    If 预约挂号_In = 1 Then
      Update 临床出诊记录 Set 已约数 = 已约数 + 1 Where ID = n_出诊记录id;
    Else
      If 预约接收_In = 1 Then
        Update 临床出诊记录
        Set 已约数 = 已约数 + 1, 已挂数 = 已挂数 + 1, 其中已接收 = 其中已接收 + 1
        Where ID = n_出诊记录id;
      Else
        Update 临床出诊记录 Set 已挂数 = 已挂数 + 1 Where ID = n_出诊记录id;
      End If;
    End If;
  End If;

  --产生病人挂号费用(可能单独是或包括病历费用)
  Select 病人费用记录_Id.Nextval Into n_费用id From Dual; --应该通过程序得到

  Insert Into 门诊费用记录
    (ID, 记录性质, 记录状态, 序号, 价格父号, 从属父号, NO, 实际票号, 门诊标志, 加班标志, 附加标志, 发药窗口, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 病人科室id, 收费类别,
     计算单位, 收费细目id, 收入项目id, 收据费目, 付数, 数次, 标准单价, 应收金额, 实收金额, 结帐金额, 结帐id, 记帐费用, 开单部门id, 开单人, 划价人, 执行部门id, 执行人, 操作员编号, 操作员姓名,
     发生时间, 登记时间, 保险大类id, 保险项目否, 保险编码, 统筹金额, 摘要, 结论, 缴款组id)
  Values
    (n_费用id, 4, Decode(预约挂号_In, 1, 0, 1), 序号_In, Decode(价格父号_In, 0, Null, 价格父号_In), 从属父号_In, 单据号_In, 票据号_In, 1, 急诊_In,
     病历费_In, Decode(预约挂号_In, 1, To_Char(n_序号), 诊室_In), Decode(病人id_In, 0, Null, 病人id_In),
     Decode(门诊号_In, 0, Null, 门诊号_In), 付款方式_In, 姓名_In, Decode(姓名_In, Null, Null, 性别_In), Decode(姓名_In, Null, Null, 年龄_In),
     v_费别, 病人科室id_In, 收费类别_In, 号别_In, 收费细目id_In, 收入项目id_In, 收据费目_In, 1, 数次_In, 标准单价_In, 应收金额_In, 实收金额_In,
     Decode(预约挂号_In, 1, Null, Decode(Nvl(记帐费用_In, 0), 1, Null, 实收金额_In)),
     Decode(预约挂号_In, 1, Null, Decode(Nvl(记帐费用_In, 0), 1, Null, 结帐id_In)), Decode(Nvl(记帐费用_In, 0), 1, 1, 0), 开单部门id_In,
     操作员姓名_In, Decode(预约挂号_In, 1, 操作员姓名_In, Null), 执行部门id_In, 医生姓名_In, 操作员编号_In, 操作员姓名_In, 发生时间_In, 登记时间_In, 保险大类id_In,
     保险项目否_In, 保险编码_In, 统筹金额_In, 摘要_In, 预约方式_In, Decode(预约挂号_In, 1, Null, n_组id));

  --汇总结算到病人预交记录
  If Nvl(预约挂号_In, 0) = 0 And Nvl(记帐费用_In, 0) = 0 Then
  
    If (Nvl(现金支付_In, 0) <> 0 Or (Nvl(现金支付_In, 0) = 0 And Nvl(个帐支付_In, 0) = 0 And Nvl(预交支付_In, 0) = 0)) And 序号_In = 1 Then
      Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      Insert Into 病人预交记录
        (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
         结算性质)
      Values
        (n_预交id, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(结算方式_In, v_现金), Nvl(现金支付_In, 0), 登记时间_In,
         操作员编号_In, 操作员姓名_In, 结帐id_In, '挂号收费', n_组id, 卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, 合作单位_In, 4);
    
      If Nvl(结算卡序号_In, 0) <> 0 And Nvl(现金支付_In, 0) <> 0 Then
      
        n_消费卡id := Null;
        Begin
          Select Nvl(自制卡, 0), 1 Into n_自制卡, n_Count From 卡消费接口目录 Where 编号 = 结算卡序号_In;
        Exception
          When Others Then
            n_Count := 0;
        End;
        If n_Count = 0 Then
          v_Err_Msg := '没有发现原结算卡的相应类别,不能继续操作！';
          Raise Err_Item;
        End If;
        If n_自制卡 = 1 Then
          Select ID
          Into n_消费卡id
          From 消费卡目录
          Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In And
                序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In);
        End If;
        Zl_病人卡结算记录_Insert(结算卡序号_In, n_消费卡id, 结算方式_In, 现金支付_In, 卡号_In, Null, 登记时间_In, Null, 结帐id_In, n_预交id);
      End If;
    
    End If;
  
    --对于医保挂号
    If Nvl(个帐支付_In, 0) <> 0 And 序号_In = 1 Then
      Insert Into 病人预交记录
        (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), v_个人帐户, 个帐支付_In, 登记时间_In, 操作员编号_In,
         操作员姓名_In, 结帐id_In, '医保挂号', n_组id, 4);
    End If;
  
    --对于就诊卡通过预交金挂号
    If Nvl(预交支付_In, 0) <> 0 And 序号_In = 1 Then
      n_预交金额 := 预交支付_In;
      For r_Deposit In c_Deposit(病人id_In, v_冲预交病人ids) Loop
        n_当前金额 := Case
                    When r_Deposit.金额 - n_预交金额 < 0 Then
                     r_Deposit.金额
                    Else
                     n_预交金额
                  End;
      
        If r_Deposit.结帐id = 0 Then
          --第一次冲预交(填上结帐ID,金额为0)
          Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 4 Where ID = r_Deposit.原预交id;
        
        End If;
        --冲上次剩余额
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 预交类别, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号,
           冲预交, 结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 预交类别, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 登记时间_In, 操作员姓名_In, 操作员编号_In, n_当前金额, 结帐id_In, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
          From 病人预交记录
          Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
      
        --更新病人预交余额
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) - n_当前金额
        Where 病人id = r_Deposit.病人id And 性质 = 1 And 类型 = Nvl(1, 2);
        --检查是否已经处理完
        If r_Deposit.金额 < n_预交金额 Then
          n_预交金额 := n_预交金额 - r_Deposit.金额;
        Else
          n_预交金额 := 0;
        End If;
      
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
      If n_预交金额 > 0 Then
        v_Err_Msg := '预交余不够支付本次支付金额,不能继续操作！';
        Raise Err_Item;
      
      End If;
      Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
    End If;
  
    --相关汇总表的处理
    --人员缴款余额
    If 序号_In = 1 Then
      If Nvl(现金支付_In, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + 现金支付_In
        Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = Nvl(结算方式_In, v_现金)
        Returning 余额 Into n_返回值;
      
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (操作员姓名_In, Nvl(结算方式_In, v_现金), 1, 现金支付_In);
          n_返回值 := 现金支付_In;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = 操作员姓名_In And 结算方式 = Nvl(结算方式_In, v_现金) And 性质 = 1 And Nvl(余额, 0) = 0;
        End If;
      End If;
    
      If Nvl(个帐支付_In, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + 个帐支付_In
        Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = v_个人帐户
        Returning 余额 Into n_返回值;
      
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, v_个人帐户, 1, 个帐支付_In);
          n_返回值 := 个帐支付_In;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_个人帐户 And Nvl(余额, 0) = 0;
        End If;
      End If;
    End If;
  End If;

  --病人挂号汇总(只处理一次,且单独收取病历费不处理)
  If Nvl(预约挂号_In, 0) = 0 Then
    If Nvl(记帐费用_In, 0) = 0 Then
      --处理票据使用情况
      If 序号_In = 1 And 票据号_In Is Not Null Then
        Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
      
        --发出票据
        Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 4, 单据号_In);
      
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
        Values
          (票据使用明细_Id.Nextval, Decode(收费票据_In, 1, 1, 4), 票据号_In, 1, 1, 领用id_In, n_打印id, 登记时间_In, 操作员姓名_In);
      
        --状态改动
        Update 票据领用记录
        Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
        Where ID = Nvl(领用id_In, 0);
      End If;
    End If;
    --病人本次就诊(以发生时间为准)
    If Nvl(病人id_In, 0) <> 0 And 序号_In = 1 Then
      Update 病人信息 Set 就诊时间 = 发生时间_In, 就诊状态 = 1, 就诊诊室 = 诊室_In Where 病人id = 病人id_In;
    End If;
  End If;

  If Nvl(预约挂号_In, 0) = 0 And Nvl(记帐费用_In, 0) = 1 Then
    --记帐
    If Nvl(病人id_In, 0) = 0 Then
      v_Err_Msg := '要针对病人的挂号费进行记帐，必须是建档病人才能记帐挂号。';
      Raise Err_Item;
    End If;
  
    --病人余额
    Update 病人余额
    Set 费用余额 = Nvl(费用余额, 0) + Nvl(实收金额_In, 0)
    Where 病人id = Nvl(病人id_In, 0) And 性质 = 1 And 类型 = 1;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (病人id_In, 1, 1, Nvl(实收金额_In, 0), 0);
    End If;
  
    --病人未结费用
    Update 病人未结费用
    Set 金额 = Nvl(金额, 0) + Nvl(实收金额_In, 0)
    Where 病人id = 病人id_In And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(病人科室id_In, 0) And
          Nvl(开单部门id, 0) = Nvl(开单部门id_In, 0) And Nvl(执行部门id, 0) = Nvl(执行部门id_In, 0) And 收入项目id + 0 = 收入项目id_In And
          来源途径 + 0 = 1;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人未结费用
        (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
      Values
        (病人id_In, Null, Null, 病人科室id_In, 开单部门id_In, 执行部门id_In, 收入项目id_In, 1, Nvl(实收金额_In, 0));
    End If;
  End If;

  --病人挂号记录
  If 号别_In Is Not Null And 序号_In = 1 Then
    --And Nvl(预约挂号_In, 0) = 0
    Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
    Begin
      Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In And Rownum < 2;
    Exception
      When Others Then
        v_付款方式 := Null;
    End;
    Insert Into 病人挂号记录
      (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 预约时间, 操作员编号,
       操作员姓名, 复诊, 号序, 社区, 预约, 预约方式, 摘要, 交易流水号, 交易说明, 合作单位, 接收时间, 接收人, 预约操作员, 预约操作员编号, 险类, 医疗付款方式)
    Values
      (n_挂号id, 单据号_In, Decode(Nvl(预约挂号_In, 0), 1, 2, 1), 1, 病人id_In, 门诊号_In, 姓名_In, 性别_In, 年龄_In, 号别_In, 急诊_In, 诊室_In,
       Null, 执行部门id_In, 医生姓名_In, 0, Null, 登记时间_In, 发生时间_In, Decode(Nvl(预约挂号_In, 0), 1, 发生时间_In, Null), 操作员编号_In,
       操作员姓名_In, 复诊_In, n_序号, 社区_In, Decode(预约接收_In, 1, 1, 0), 预约方式_In, 摘要_In, 交易流水号_In, 交易说明_In, 合作单位_In,
       Decode(Nvl(预约挂号_In, 0), 0, 登记时间_In, Null), Decode(Nvl(预约挂号_In, 0), 0, 操作员姓名_In, Null),
       Decode(Nvl(预约挂号_In, 0), 1, 操作员姓名_In, Null), Decode(Nvl(预约挂号_In, 0), 1, 操作员编号_In, Null),
       Decode(Nvl(险类_In, 0), 0, Null, 险类_In), v_付款方式);
    If Nvl(预约挂号_In, 0) = 0 And 预约方式_In Is Not Null Then
      Update 病人挂号记录
      Set 预约 = 1, 预约时间 = 发生时间_In, 预约操作员 = 操作员姓名_In, 预约操作员编号 = 操作员编号_In
      Where ID = n_挂号id;
    End If;
    n_预约生成队列 := 0;
    If Nvl(预约挂号_In, 0) = 1 Then
      n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
    End If;
  
    --0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站
    If Nvl(生成队列_In, 0) <> 0 And Nvl(预约挂号_In, 0) = 0 Or n_预约生成队列 = 1 Then
      n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
      If Nvl(n_分诊台签到排队, 0) = 0 Or n_预约生成队列 = 1 Then
        n_分时点显示 := Nvl(Zl_To_Number(zl_GetSysParameter(270)), 0);
        If Nvl(预约挂号_In, 0) = 1 And n_分时点显示 = 1 And n_分时段 = 1 Then
          n_分时点显示 := 1;
        Else
          n_分时点显示 := Null;
        End If;
        --产生队列
        --.按”执行部门” 的方式生成队列
        v_队列名称 := 执行部门id_In;
        v_排队号码 := Zlgetnextqueue(执行部门id_In, n_挂号id, 号别_In || '|' || n_序号);
        v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
        d_排队时间 := Zl_Get_Queuedate(n_挂号id, 号别_In, n_序号, 发生时间_In);
        --  队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,排队标记_In,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In, 排队时间_In
        Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, 执行部门id_In, v_排队号码, Null, 姓名_In, 病人id_In, 诊室_In, 医生姓名_In, d_排队时间, 预约方式_In,
                         n_分时点显示, v_排队序号);
      
        --挂号立即排队
        If Nvl(n_分诊台签到排队, 0) = 0 Then
          Update 病人挂号记录 Set 记录标志 = 1 Where ID = n_挂号id;
        End If;
      End If;
    End If;
  End If;
  --病人担保信息
  If 病人id_In Is Not Null And 序号_In = 1 Then
    --取参数:
    If Nvl(n_结算模式, 0) <> Nvl(结算模式_In, 0) Then
      --结算模式的确定
    
      v_Err_Msg := Null;
      Begin
        Select Nvl(结算模式, 0) Into n_结算模式 From 病人信息 Where 病人id = 病人id_In;
      Exception
        When Others Then
          v_Err_Msg := '未找到指定的病人信息,不允许挂号';
      End;
    
      If v_Err_Msg Is Not Null Then
        Raise Err_Item;
      End If;
      If n_结算模式 = 1 And Nvl(结算模式_In, 0) = 0 Then
        --病人已经是"先诊疗后结算的",本次是"先结算后诊疗的",则检查是否存在未结数据
        Select Count(1)
        Into n_Count
        From 病人未结费用
        Where 病人id = 病人id_In And (来源途径 In (1, 4) Or 来源途径 = 3 And Nvl(主页id, 0) = 0) And Nvl(金额, 0) <> 0 And Rownum < 2;
        If Nvl(n_Count, 0) <> 0 Then
          --存在未结算数据，必须先结算后才允许执行
          v_Err_Msg := '当前病人的就诊模式为先诊疗后结算且存在未结费用，不允许调整该病人的就诊模式,你可以先对未结费用结帐后再挂号或不调整病人的就诊模式!';
          Raise Err_Item;
        End If;
        --检查
        --未发生医嘱业务的（即当时就挂号的,需要保证同一次的就诊模式是一至的(程序已经检查，不用再处理)
      End If;
      Update 病人信息 Set 结算模式 = 结算模式_In Where 病人id = 病人id_In;
    End If;
  
    Update 病人信息
    Set 担保人 = Null, 担保额 = Null, 担保性质 = Null
    Where 病人id = 病人id_In And Nvl(在院, 0) = 0 And Exists
     (Select 1
           From 病人担保记录
           Where 病人id = 病人id_In And 主页id Is Not Null And
                 登记时间 = (Select Max(登记时间) From 病人担保记录 Where 病人id = 病人id_In));
  
    If Sql%RowCount > 0 Then
      Update 病人担保记录
      Set 到期时间 = Sysdate
      Where 病人id = 病人id_In And 主页id Is Not Null And Nvl(到期时间, Sysdate) >= Sysdate;
    End If;
  End If;
  If 序号_In = 1 Then
    --消息推送
    Begin
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 1, n_挂号id;
    Exception
      When Others Then
        Null;
    End;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人挂号记录_Insert;
/

--103348:梁唐彬,2016-12-06,执行完成自动发料
Create Or Replace Procedure Zl_门诊医嘱执行_Cancel
(
  医嘱id_In     病人医嘱执行.医嘱id%Type,
  发送号_In     病人医嘱执行.发送号%Type,
  单独执行_In   Number,
  操作员编号_In 人员表.编号%Type,
  操作员姓名_In 人员表.姓名%Type,
  组id_In       病人医嘱执行.医嘱id%Type,
  诊疗类别_In   病人医嘱记录.诊疗类别%Type,
  执行部门id_In 门诊费用记录.执行部门id%Type
  --参数：医嘱ID_IN=单独执行的医嘱ID，检验组合为显示的检验项目的ID。 
  --      单独执行_In=检验医嘱组合是否采用对每个项目分散单独执行的方式 
) Is
  --医嘱相关的费用单据 
  Cursor c_No Is
    Select a.No || ':' || a.记录性质
    From 病人医嘱附费 A, 病人医嘱记录 B
    Where a.发送号 + 0 = 发送号_In And a.医嘱id = b.Id And b.诊疗类别 = 诊疗类别_In And (b.Id = 组id_In Or b.相关id = 组id_In)
    Union
    Select NO || ':' || 记录性质 From 病人医嘱发送 Where 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In;

  Cursor c_Noone Is
    Select NO || ':' || 记录性质
    From 病人医嘱附费
    Where 发送号 + 0 = 发送号_In And 医嘱id = 医嘱id_In
    Union
    Select NO || ':' || 记录性质 From 病人医嘱发送 Where 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In;

  r_No       t_Strlist;
  r_No_Stuff t_Strlist;
  r_Finish   t_Numlist;

  n_执行次数 Number;
  n_剩余次数 Number;
  n_执行状态 Number;

  --要取消执行的费用行(不包含药品和跟踪在用的卫材) 
  Cursor c_Finish(r_No t_Strlist) Is
    Select /*+ RULE */
     a.Id
    From (Select Distinct a.Id, a.收费类别, a.收费细目id
           From 门诊费用记录 A, 病人医嘱记录 B,
                (Select Substr(Column_Value, 1, Instr(Column_Value, ':') - 1) As NO,
                         To_Number(Substr(Column_Value, Instr(Column_Value, ':') + 1)) As 记录性质
                  From Table(r_No)) N
           Where a.医嘱序号 = b.Id And (b.Id = 组id_In Or b.相关id = 组id_In) And a.No = n.No And
                 (a.记录性质 = n.记录性质 Or a.记录性质 = 11 And n.记录性质 = 1) And a.记录状态 In (0, 1, 3) And
                 (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In)) A, 材料特性 B
    Where a.收费细目id = b.材料id(+) And Not a.收费类别 In ('5', '6', '7') And Not (a.收费类别 = '4' And Nvl(b.跟踪在用, 0) = 1);

  Cursor c_Finishone(r_No t_Strlist) Is
    Select /*+ RULE */
     a.Id
    From (Select a.Id, a.收费类别, a.收费细目id
           From 门诊费用记录 A,
                (Select Substr(Column_Value, 1, Instr(Column_Value, ':') - 1) As NO,
                         To_Number(Substr(Column_Value, Instr(Column_Value, ':') + 1)) As 记录性质
                  From Table(r_No)) N
           Where a.医嘱序号 = 医嘱id_In And a.No = n.No And (a.记录性质 = n.记录性质 Or a.记录性质 = 11 And n.记录性质 = 1) And
                 a.记录状态 In (0, 1, 3) And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In)) A, 材料特性 B
    Where a.收费细目id = b.材料id(+) And Not a.收费类别 In ('5', '6', '7') And Not (a.收费类别 = '4' And Nvl(b.跟踪在用, 0) = 1);

  --取消执行中包含跟踪在用的发料卫料时，根据参数设置是否自动退料 
  --卫生材料医嘱目前不存在单独和组合执行的情况 
  Cursor c_Stuff(r_No t_Strlist) Is
    Select /*+ RULE */
     b.Id
    From 门诊费用记录 A, 药品收发记录 B, 病人医嘱记录 C,
         (Select Substr(Column_Value, 1, Instr(Column_Value, ':') - 1) As NO,
                  To_Number(Substr(Column_Value, Instr(Column_Value, ':') + 1)) As 记录性质
           From Table(r_No)) N
    Where a.Id = b.费用id And (b.记录状态 = 1 Or Mod(b.记录状态, 3) = 0) And b.审核人 Is Not Null And a.收费类别 = '4' And a.记录状态 = 1 And
          a.医嘱序号 = c.Id And c.诊疗类别 = 诊疗类别_In And (c.Id = 组id_In Or c.相关id = 组id_In) And a.No = n.No And
          (a.记录性质 = n.记录性质 Or a.记录性质 = 11 And n.记录性质 = 1) And b.单据 IN(24,25,26) And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In)
    Order By b.药品id;
Begin
  Open c_Noone;
  Fetch c_Noone Bulk Collect
    Into r_No_Stuff;
  Close c_Noone;

  If Nvl(单独执行_In, 0) = 0 Then
    Open c_No;
    Fetch c_No Bulk Collect
      Into r_No;
    Close c_No;
  Else
    r_No := r_No_Stuff;
  End If;

  --主费用可能需要限制医嘱序号 
  --不包含药品和跟踪在用的卫材，因为这些都要发放才表示执行 
  If Nvl(单独执行_In, 0) = 0 Then
    Open c_Finish(r_No);
    Fetch c_Finish Bulk Collect
      Into r_Finish;
    Close c_Finish;
  Else
    Open c_Finishone(r_No);
    Fetch c_Finishone Bulk Collect
      Into r_Finish;
    Close c_Finishone;
  End If;

  Select Decode(a.执行状态, 1, a.发送数次, c.登记次数), Decode(a.执行状态, 1, 0, a.发送数次 - c.登记次数)
  Into n_执行次数, n_剩余次数
  From 病人医嘱发送 A,
       (Select 医嘱id_In 医嘱id, 发送号_In 发送号, Nvl(Sum(b.本次数次), 0) As 登记次数
         From 病人医嘱执行 B
         Where b.医嘱id = 医嘱id_In And b.发送号 = 发送号_In And Nvl(b.执行结果, 1) <> 0) C
  Where a.医嘱id = c.医嘱id And a.发送号 = c.发送号 And a.医嘱id = 医嘱id_In And a.发送号 = 发送号_In;

  --如果全部执行则状态为1，未执行状态为0，部分执行状态为2 
  Select Decode(n_剩余次数, 0, 1, Decode(n_执行次数, 0, 0, 2)) Into n_执行状态 From Dual;

  --对于门诊单据（包含记账与收费）部分执行（2）与完全执行（1）,执行时间为执行完成的执行时间，执行人为执行完成的执行人 
  Forall I In 1 .. r_Finish.Count
    Update 门诊费用记录
    Set 执行状态 = n_执行状态, 执行时间 = Decode(n_执行状态, 0, Null, 执行时间), 执行人 = Decode(n_执行状态, 0, Null, 执行人)
    Where ID = r_Finish(I);

  --处理跟踪在用卫材自动发料 
  For r_Stuff In c_Stuff(r_No_Stuff) Loop
    Zl_材料收发记录_部门退料(r_Stuff.Id, 操作员姓名_In, Sysdate, Null, Null, Null, Null, 0, 操作员姓名_In);
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊医嘱执行_Cancel;
/

--103765:刘尔旋,2017-02-07,服务窗当天挂号返回大时段数量问题
--105182:刘尔旋,2017-01-25,计划排班模式停诊处理
--103236:刘尔旋,2016-12-26,支付宝停诊处理
--102628:刘尔旋,2016-12-06,支付宝当天获取分时段非序号控制号别问题
Create Or Replace Procedure Zl_Third_Getnolist
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取号源列表(简易模式)
  --入参:Xml_In:
  --<IN>
  --  <RQ>日期</RQ>
  --  <KSID>科室ID</KSID>
  --  <YSID>医生ID</YSID>
  --  <YSXM>医生姓名</YSXM>
  --  <HZDW>支付宝</HZDW>    //合作单位，传入了的时候，只取合作单位的号;为空时，只取非合作单位的号
  --  <SJJG>60</SJJG>     //时间间隔,不传则返回序号时段
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  --  <GROUP>
  --    <RQ>日期</RQ>
  --    <HBLIST>
  --     <HB>
  --        <CZJLID>1</CZJLID>     //出诊记录ID
  --        <HM>235</HM>       //号码
  --        <YSID>549</YSID>      //医生ID
  --        <YS>张锐</YS>       //医生姓名
  --        <KSID>123</KSID>   //科室ID
  --        <KSMC>内科</KSMC>   //科室名称
  --        <ZC>主治医师</ZC> //职称
  --        <XMID>10086<XMID> //挂号项目的ID
  --        <XMMC>挂号费</XMMC> //挂号项目的名称
  --        <YGHS>0</YGHS>      //已挂号数
  --        <SYHS>99</SYHS>   //剩余号数
  --        <PRICE>15</PRICE>      //价格
  --        <HL>普通</HL>       //挂号类型
  --        <HCXH>1</HCXH>    //是否存在缓冲序号时间段，1-存在 0或者空-不存在
  --        <FSD>0</FSD>      //是否分时段
  --        <FWMC>白天</FWMC>     //号别时段
  --        <HBTIME>(08:00-17:59)</HBTIME> //可挂时间
  --     <SPANLIST>
  --            <SPAN>
  --                  <SJD></SJD>          //时间段,格式:hh24:mi-hh24:mi
  --                  <GHZS></GHZS>      //时段挂号总数
  --                  <SL></SL>      //剩余数量
  --            </SPAN>
  --            ……
  --          </SPANLIST>
  --      </HB>
  --      <HB>
  --      ……
  --      </HB>
  --    </HBLIST>
  --  </GROUP>
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  d_日期         Date;
  n_科室id       病人挂号记录.执行部门id%Type;
  n_医生id       人员表.Id%Type;
  v_医生姓名     人员表.姓名%Type;
  v_星期         挂号安排限制.限制项目%Type;
  v_时间段       Varchar2(100);
  v_合作单位     挂号合作单位.名称%Type;
  n_分时段       Number(3);
  n_单个剩余     Number(5);
  n_已挂数       Number(5);
  n_合约已挂数   Number(5);
  n_合计金额     收费价目.现价%Type;
  n_合约总数量   Number(5);
  n_合约剩余数量 Number(5);
  n_最大可用数量 Number(5);
  n_合约模式     Number(3); --合约模式:1-合约单位限数量模式 0-合约单位指定序号模式
  n_非合约       Number(3);
  n_是否预留     Number(3);
  d_加号时间     Date;
  d_开始时间     临床出诊记录.开始时间%Type;
  d_终止时间     临床出诊记录.终止时间%Type;
  n_缓冲序号     Number(3);
  n_时段数量     Number(5);
  n_序号控制     临床出诊记录.是否序号控制%Type;
  n_预留数量     Number(5);
  n_特殊预约     Number(3);
  n_禁用         Number(3);
  v_剩余数量     Varchar2(100);
  v_Timetemp     Varchar2(100);
  v_Temp         Varchar2(32767); --临时XML
  v_Xmlmain      Clob; --临时XML
  c_Xmlmain      Clob; --临时XML
  x_Templet      Xmltype; --模板XML
  v_Err_Msg      Varchar2(200);
  n_Exists       Number(5);
  n_时段已挂     Number(5);
  n_挂号模式     Number(3);
  v_挂号模式     Varchar2(500);
  v_启用时间     Varchar2(500);
  n_时间间隔     Number(5);
  n_预约天数     Number(5);
  d_时段开始     Date;
  d_时段结束     Date;
  n_时段总数     Number(5);
  n_时段剩余     Number(5);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select To_Date(Extractvalue(Value(A), 'IN/RQ'), 'YYYY-MM-DD hh24:mi:ss'), Extractvalue(Value(A), 'IN/KSID'),
         Extractvalue(Value(A), 'IN/YSID'), Extractvalue(Value(A), 'IN/YSXM'), Extractvalue(Value(A), 'IN/HZDW'),
         Extractvalue(Value(A), 'IN/SJJG')
  Into d_日期, n_科室id, n_医生id, v_医生姓名, v_合作单位, n_时间间隔
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  v_挂号模式 := zl_GetSysParameter('挂号排班模式');
  n_挂号模式 := To_Number(Substr(v_挂号模式, 1, 1));
  If n_挂号模式 = 1 Then
    Begin
      v_启用时间 := Substr(v_挂号模式, 3);
    Exception
      When Others Then
        v_启用时间 := Null;
    End;
  End If;
  --日期节点为空的情况
  If d_日期 Is Null Then
    d_日期 := Trunc(Sysdate);
  End If;
  n_预约天数 := Nvl(zl_GetSysParameter(66), 7);
  If d_日期 < To_Date(v_启用时间, 'yyyy-mm-dd hh24:mi:ss') And n_挂号模式 = 1 Then
    n_挂号模式 := 0;
  End If;

  If n_挂号模式 = 0 Then
    Select Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null)
    Into v_星期
    From Dual;
    n_合约剩余数量 := 0;
  
    For r_No In (Select a.科室id, a.号类, a.科室名称, a.医生姓名, a.医生id, a.职称, a.号码, a.安排id, a.计划id, a.排班, a.项目id, a.项目名称, a.序号控制,
                        a.限号数, a.限约数, a.预约天数, Nvl(Hz.已挂数, 0) As 已挂数, Nvl(Hz.已约数, 0) As 已约数, Nvl(Hz.其中已接收, 0) As 已接收,
                        Sum(b.现价) As 价格
                 From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Nvl(Ap.医生id, 0) As 医生id, Ry.专业技术职务 As 职称, Ap.号码,
                               Ap.安排id, Ap.计划id, Ap.排班, Ap.项目id, Fy.名称 As 项目名称, Ap.序号控制, Ap.限号数, Ap.限约数, Ap.预约天数
                        From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Ap.医生id, Ap.号码, Ap.Id As 安排id, 0 As 计划id,
                                      Ap.项目id, Nvl(Ap.序号控制, 0) As 序号控制,
                                      Decode(To_Char(d_日期, 'D'), '1', Ap.周日, '2', Ap.周一, '3', Ap.周二, '4', Ap.周三, '5', Ap.周四,
                                              '6', Ap.周五, '7', Ap.周六, Null) As 排班, Xz.限约数, Xz.限号数,
                                      Nvl(Ap.预约天数, n_预约天数) As 预约天数
                               From 挂号安排 Ap, 部门表 Bm, 挂号安排限制 Xz
                               Where Ap.科室id = Bm.Id(+) And Decode(Nvl(n_科室id, 0), 0, 0, Ap.科室id) = Nvl(n_科室id, 0) And
                                     Decode(Nvl(n_医生id, 0), 0, 0, Ap.医生id) = Nvl(n_医生id, 0) And
                                     Decode(Nvl(v_医生姓名, '-'), '-', '-', Ap.医生姓名) = Nvl(v_医生姓名, '-') And Ap.停用日期 Is Null And
                                     d_日期 Between Nvl(Ap.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                     Nvl(Ap.终止时间, To_Date('3000 - 01 - 01', 'YYYY-MM-DD')) And Xz.安排id(+) = Ap.Id And
                                     Xz.限制项目(+) = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                         '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                (Select Rownum
                                      From 挂号安排停用状态 Ty
                                      Where Ty.安排id = Ap.Id And d_日期 Between Ty.开始停止时间 And Ty.结束停止时间) And Not Exists
                                (Select Rownum
                                      From 挂号安排计划 Jh
                                      Where Jh.安排id = Ap.Id And Jh.审核时间 Is Not Null And
                                            d_日期 Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                            Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')))
                               Union All
                               Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Jh.医生姓名, Jh.医生id, Ap.号码, Ap.Id As 安排id, Jh.Id As 计划id,
                                      Jh.项目id, Nvl(Jh.序号控制, 0) As 序号控制,
                                      Decode(To_Char(d_日期, 'D'), '1', Jh.周日, '2', Jh.周一, '3', Jh.周二, '4', Jh.周三, '5', Jh.周四,
                                              '6', Jh.周五, '7', Jh.周六, Null) As 排班, Xz.限约数, Xz.限号数,
                                      Nvl(Ap.预约天数, n_预约天数) As 预约天数
                               From 挂号安排计划 Jh, 挂号安排 Ap, 部门表 Bm, 挂号计划限制 Xz
                               Where Jh.安排id = Ap.Id And Ap.科室id = Bm.Id(+) And Ap.停用日期 Is Null And
                                     Decode(Nvl(n_科室id, 0), 0, 0, Ap.科室id) = Nvl(n_科室id, 0) And
                                     Decode(Nvl(n_医生id, 0), 0, 0, Jh.医生id) = Nvl(n_医生id, 0) And
                                     Decode(Nvl(v_医生姓名, '-'), '-', '-', Jh.医生姓名) = Nvl(v_医生姓名, '-') And
                                     d_日期 Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                     Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.计划id(+) = Jh.Id And
                                     Xz.限制项目(+) = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                         '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                (Select Rownum
                                      From 挂号安排停用状态 Ty
                                      Where Ty.安排id = Ap.Id And d_日期 Between Ty.开始停止时间 And Ty.结束停止时间) And
                                     (Jh.生效时间, Jh.安排id) =
                                     (Select Max(Sxjh.生效时间) As 生效时间, 安排id
                                      From 挂号安排计划 Sxjh
                                      Where Sxjh.审核时间 Is Not Null And
                                            d_日期 Between Nvl(Sxjh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                            Nvl(Sxjh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Sxjh.安排id = Jh.安排id
                                      Group By Sxjh.安排id)) Ap, 部门表 Bm, 人员表 Ry, 收费项目目录 Fy
                        Where Ap.科室id = Bm.Id(+) And Ap.医生id = Ry.Id(+) And Ap.项目id = Fy.Id And 排班 Is Not Null) A,
                      病人挂号汇总 Hz, 收费价目 B
                 Where a.号码 = Hz.号码(+) And Hz.日期(+) = Trunc(d_日期) And a.项目id = b.收费细目id And
                       Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-Mm-DD')) > d_日期 And b.执行日期 <= d_日期
                 Group By a.科室id, a.号类, a.科室名称, a.医生姓名, a.医生id, a.职称, a.号码, a.安排id, a.计划id, a.排班, a.项目id, a.项目名称, a.序号控制,
                          a.限号数, a.限约数, a.预约天数, Nvl(Hz.已挂数, 0), Nvl(Hz.已约数, 0), Nvl(Hz.其中已接收, 0)) Loop
      Zl_挂号序号状态_Delete(1, r_No.号码);
      If Sysdate + Nvl(r_No.预约天数, n_预约天数) >= d_日期 Then
        If r_No.计划id <> 0 Then
          Select Sign(Count(Rownum))
          Into n_分时段
          From 挂号安排计划 Jh, 挂号计划时段 Sd
          Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7',
                               '周六', Null) And Rownum < 2;
        Else
          Select Sign(Count(Rownum))
          Into n_分时段
          From 挂号安排 Ap, 挂号安排时段 Sd
          Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7',
                               '周六', Null) And Rownum < 2;
        End If;
        --分时段不序号控制当天号为普通号
        If Trunc(Sysdate) = Trunc(d_日期) And n_分时段 = 1 And r_No.序号控制 = 0 Then
          n_分时段 := 0;
        End If;
        If n_分时段 = 0 Then
          v_Temp := '';
          If v_合作单位 Is Not Null And r_No.序号控制 = 1 Then
            If r_No.计划id <> 0 Then
              Select Nvl(Sum(数量), 0)
              Into n_合约总数量
              From 合作单位计划控制
              Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null);
              Select Count(1)
              Into n_合约模式
              From 合作单位计划控制
              Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 序号 = 0;
            Else
              Select Nvl(Sum(数量), 0)
              Into n_合约总数量
              From 合作单位安排控制
              Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null);
              Select Count(1)
              Into n_合约模式
              From 合作单位安排控制
              Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 序号 = 0;
            End If;
            If n_合约模式 = 0 Then
              If r_No.计划id <> 0 Then
                Select Count(1)
                Into n_合约已挂数
                From 病人挂号记录 A
                Where 号别 = r_No.号码 And 记录状态 = 1 And 发生时间 Between Trunc(d_日期) And Trunc(d_日期 + 1) - 1 / 60 / 60 / 24 And
                      Exists
                 (Select 1
                       From 合作单位计划控制
                       Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                             限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                           '周五', '7', '周六', Null) And 序号 = a.号序 And 数量 <> 0);
              Else
                Select Count(1)
                Into n_合约已挂数
                From 病人挂号记录 A
                Where 号别 = r_No.号码 And 记录状态 = 1 And 发生时间 Between Trunc(d_日期) And Trunc(d_日期 + 1) - 1 / 60 / 60 / 24 And
                      Exists
                 (Select 1
                       From 合作单位安排控制
                       Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                             限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                           '周五', '7', '周六', Null) And 序号 = a.号序 And 数量 <> 0);
              End If;
            Else
              Select Count(1)
              Into n_合约已挂数
              From 病人挂号记录
              Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                    Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
            End If;
            If n_合约总数量 = 0 Then
              n_合约剩余数量 := 0;
            Else
              n_合约剩余数量 := n_合约总数量 - n_合约已挂数;
              If n_合约剩余数量 > (Nvl(r_No.限号数, 0) - r_No.已挂数) Then
                n_合约剩余数量 := Nvl(r_No.限号数, 0) - r_No.已挂数;
              End If;
            End If;
          End If;
        Else
          v_Temp := '<SPANLIST>';
          If r_No.计划id <> 0 Then
            Select To_Date(To_Char(d_日期, 'yyyy-mm-dd') || To_Char(Max(结束时间), 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss')
            Into d_加号时间
            From 挂号计划时段
            Where 计划id = r_No.计划id And 星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                   '周四', '6', '周五', '7', '周六', Null);
            If r_No.序号控制 = 1 Then
              If Trunc(d_日期) = Trunc(Sysdate) Then
                n_特殊预约 := 0;
              Else
                Select Nvl(Max(Jh.是否预约), 0)
                Into n_特殊预约
                From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                              To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                              To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                       From 挂号安排计划 Jh, 挂号计划时段 Sd
                       Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                             Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                            '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                Where Zt.日期(+) = Jh.开始时间 And Zt.号码(+) = Jh.号码 And Zt.序号(+) = Jh.序号 And
                      Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) <> 1;
              End If;
            
              d_时段开始 := Null;
              d_时段结束 := Null;
              n_时段总数 := 0;
              n_时段剩余 := 0;
              For r_Time In (Select Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约, 0 As 已约数,
                                    Decode(Nvl(Zt.序号, 0), 0, 1, 0) As 剩余数,
                                    Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) As 失效时段
                             From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                    From 挂号安排计划 Jh, 挂号计划时段 Sd
                                    Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And Not Exists
                                     (Select 1
                                           From 挂号安排停用状态
                                           Where 安排id = Jh.安排id And
                                                 To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' ||
                                                         To_Char(Sd.开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') Between
                                                 开始停止时间 And 结束停止时间) And
                                          Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                         '5', '周四', '6', '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                             Where Zt.日期(+) = Jh.开始时间 And Zt.号码(+) = Jh.号码 And Zt.序号(+) = Jh.序号
                             Order By 序号) Loop
                If Nvl(n_时间间隔, 0) <> 0 Then
                  If d_时段开始 Is Null Then
                    d_时段开始 := r_Time.开始时间;
                    d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                    n_时段总数 := n_时段总数 + r_Time.限制数量;
                    If d_加号时间 < d_时段结束 Then
                      d_时段结束 := d_加号时间;
                    End If;
                  Else
                    If r_Time.开始时间 >= d_时段结束 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                    To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                    '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                      n_时段总数 := r_Time.限制数量;
                      n_时段剩余 := 0;
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      n_时段总数 := n_时段总数 + r_Time.限制数量;
                    End If;
                  End If;
                End If;
                If v_合作单位 Is Not Null Then
                  Select Nvl(Max(1), 0)
                  Into n_合约模式
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
                Else
                  n_合约模式 := 0;
                End If;
                If r_Time.剩余数 = 0 Then
                  n_单个剩余 := 0;
                Else
                  n_单个剩余 := r_Time.限制数量;
                End If;
                If v_合作单位 Is Null Or n_合约模式 = 1 Then
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And Rownum < 2;
                  If n_Exists = 0 And r_Time.失效时段 <> 1 Then
                    If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                      Null;
                    Else
                      Select Nvl(Max(1), 0)
                      Into n_是否预留
                      From 挂号序号状态
                      Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                      If n_是否预留 = 0 Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                    '</SPAN>';
                        Else
                          n_时段剩余 := n_时段剩余 + n_单个剩余;
                        End If;
                        n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                      End If;
                    End If;
                  End If;
                Else
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                  Begin
                    Select 0
                    Into n_非合约
                    From 合作单位计划控制
                    Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_非合约 := 1;
                  End;
                  If (n_Exists = 1 Or n_非合约 = 1) And r_Time.失效时段 <> 1 Then
                    If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                      Null;
                    Else
                      Select Nvl(Max(1), 0)
                      Into n_是否预留
                      From 挂号序号状态
                      Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                      If n_是否预留 = 0 Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                    '</SPAN>';
                        Else
                          n_时段剩余 := n_时段剩余 + n_单个剩余;
                        End If;
                        n_合约剩余数量 := n_合约剩余数量 + 1;
                      End If;
                    End If;
                  End If;
                End If;
              End Loop;
              If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                              To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                              n_时段剩余 || '</SL>' || '</SPAN>';
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
              End If;
            Else
              n_最大可用数量 := Nvl(r_No.限约数, Nvl(r_No.限号数, 0)) - Nvl(r_No.已约数, 0);
              n_时段总数     := 0;
              n_时段剩余     := 0;
              d_时段开始     := Null;
              d_时段结束     := Null;
              For r_Time In (Select Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约,
                                    Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 已约数,
                                    Jh.限制数量 - Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 剩余数,
                                    Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) As 失效时段
                             From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                    From 挂号安排计划 Jh, 挂号计划时段 Sd
                                    Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And Not Exists
                                     (Select 1
                                           From 挂号安排停用状态
                                           Where 安排id = Jh.安排id And
                                                 To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' ||
                                                         To_Char(Sd.开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') Between
                                                 开始停止时间 And 结束停止时间) And
                                          Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                         '5', '周四', '6', '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                             Where Jh.号码 = Zt.号码(+) And Jh.开始时间 = Zt.日期(+)
                             Group By Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约
                             Order By Jh.序号) Loop
                If Nvl(n_时间间隔, 0) <> 0 Then
                  If d_时段开始 Is Null Then
                    d_时段开始 := r_Time.开始时间;
                    d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                    n_时段总数 := n_时段总数 + r_Time.限制数量;
                    If d_加号时间 < d_时段结束 Then
                      d_时段结束 := d_加号时间;
                    End If;
                  Else
                    If r_Time.开始时间 >= d_时段结束 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                    To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                    '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                      n_时段总数 := r_Time.限制数量;
                      n_时段剩余 := 0;
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      n_时段总数 := n_时段总数 + r_Time.限制数量;
                    End If;
                  End If;
                End If;
                If v_合作单位 Is Not Null Then
                  Select Nvl(Max(1), 0)
                  Into n_合约模式
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
                Else
                  n_合约模式 := 0;
                End If;
                n_单个剩余 := r_Time.剩余数;
                If v_合作单位 Is Null Or n_合约模式 = 1 Then
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And Rownum < 2;
                  If n_Exists = 0 And r_Time.失效时段 <> 1 Then
                    If n_最大可用数量 < n_单个剩余 Then
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_最大可用数量;
                      End If;
                      n_时段数量 := Nvl(n_时段数量, 0) + n_最大可用数量;
                    Else
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_单个剩余;
                      End If;
                      n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                    End If;
                  End If;
                Else
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                  Begin
                    Select 0
                    Into n_非合约
                    From 合作单位计划控制
                    Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_非合约 := 1;
                  End;
                  If (n_Exists = 1 Or n_非合约 = 1) And r_Time.失效时段 <> 1 Then
                    If n_最大可用数量 < n_单个剩余 Then
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_最大可用数量;
                      End If;
                      n_合约剩余数量 := n_合约剩余数量 + Nvl(n_最大可用数量, 0);
                    Else
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_单个剩余;
                      End If;
                      n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                    End If;
                  End If;
                End If;
              End Loop;
              If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                              To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                              n_时段剩余 || '</SL>' || '</SPAN>';
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
              End If;
            End If;
          Else
            Select To_Date(To_Char(d_日期, 'yyyy-mm-dd') || To_Char(Max(结束时间), 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss')
            Into d_加号时间
            From 挂号安排时段
            Where 安排id = r_No.安排id And 星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                   '周四', '6', '周五', '7', '周六', Null);
            If r_No.序号控制 = 1 Then
              If Trunc(d_日期) = Trunc(Sysdate) Then
                n_特殊预约 := 0;
              Else
                Select Nvl(Max(Ap.是否预约), 0)
                Into n_特殊预约
                From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                              To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                              To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                       From 挂号安排 Ap, 挂号安排时段 Sd
                       Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                             Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                            '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                Where Zt.日期(+) = Ap.开始时间 And Zt.号码(+) = Ap.号码 And Zt.序号(+) = Ap.序号 And
                      Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) <> 1;
              End If;
              n_时段总数 := 0;
              n_时段剩余 := 0;
              d_时段开始 := Null;
              d_时段结束 := Null;
              For r_Time In (Select Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约, 0 As 已约数,
                                    Decode(Nvl(Zt.序号, 0), 0, 1, 0) As 剩余数,
                                    Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) As 失效时段
                             
                             From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                    From 挂号安排 Ap, 挂号安排时段 Sd
                                    Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And Not Exists
                                     (Select 1
                                           From 挂号安排停用状态
                                           Where 安排id = Ap.Id And
                                                 To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' ||
                                                         To_Char(Sd.开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') Between
                                                 开始停止时间 And 结束停止时间) And
                                          Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                         '5', '周四', '6', '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                             Where Zt.日期(+) = Ap.开始时间 And Zt.号码(+) = Ap.号码 And Zt.序号(+) = Ap.序号
                             Order By 序号) Loop
                If Nvl(n_时间间隔, 0) <> 0 Then
                  If d_时段开始 Is Null Then
                    d_时段开始 := r_Time.开始时间;
                    n_时段总数 := n_时段总数 + r_Time.限制数量;
                    d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                    If d_加号时间 < d_时段结束 Then
                      d_时段结束 := d_加号时间;
                    End If;
                  Else
                    If r_Time.开始时间 >= d_时段结束 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                    To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                    '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                      n_时段总数 := r_Time.限制数量;
                      n_时段剩余 := 0;
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      n_时段总数 := n_时段总数 + r_Time.限制数量;
                    End If;
                  End If;
                End If;
                If v_合作单位 Is Not Null Then
                  Begin
                    Select 1
                    Into n_合约模式
                    From 合作单位安排控制
                    Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
                  Exception
                    When Others Then
                      n_合约模式 := 0;
                  End;
                Else
                  n_合约模式 := 0;
                End If;
                If r_Time.剩余数 = 0 Then
                  n_单个剩余 := 0;
                Else
                  n_单个剩余 := r_Time.限制数量;
                End If;
                If v_合作单位 Is Null Or n_合约模式 = 1 Then
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And Rownum < 2;
                  If n_Exists = 0 And r_Time.失效时段 <> 1 Then
                    If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                      Null;
                    Else
                      Select Nvl(Max(1), 0)
                      Into n_是否预留
                      From 挂号序号状态
                      Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                      If n_是否预留 = 0 Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                    '</SPAN>';
                        Else
                          n_时段剩余 := n_时段剩余 + n_单个剩余;
                        End If;
                        n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                      End If;
                    End If;
                  End If;
                Else
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                  Begin
                    Select 0
                    Into n_非合约
                    From 合作单位安排控制
                    Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_非合约 := 1;
                  End;
                  If (n_Exists = 1 Or n_非合约 = 1) And r_Time.失效时段 <> 1 Then
                    If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                      Null;
                    Else
                      Select Nvl(Max(1), 0)
                      Into n_是否预留
                      From 挂号序号状态
                      Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                      If n_是否预留 = 0 Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                    '</SPAN>';
                        Else
                          n_时段剩余 := n_时段剩余 + n_单个剩余;
                        End If;
                        n_合约剩余数量 := n_合约剩余数量 + n_单个剩余;
                      End If;
                    End If;
                  End If;
                End If;
              End Loop;
              If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                              To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                              n_时段剩余 || '</SL>' || '</SPAN>';
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
              End If;
            Else
              n_最大可用数量 := Nvl(r_No.限约数, Nvl(r_No.限号数, 0)) - Nvl(r_No.已约数, 0);
              n_时段总数     := 0;
              n_时段剩余     := 0;
              d_时段开始     := Null;
              d_时段结束     := Null;
              For r_Time In (Select Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约,
                                    Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 已约数,
                                    Ap.限制数量 - Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 剩余数,
                                    Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) As 失效时段
                             From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                    From 挂号安排 Ap, 挂号安排时段 Sd
                                    Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And Not Exists
                                     (Select 1
                                           From 挂号安排停用状态
                                           Where 安排id = Ap.Id And
                                                 To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' ||
                                                         To_Char(Sd.开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') Between
                                                 开始停止时间 And 结束停止时间) And
                                          Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                         '5', '周四', '6', '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                             Where Ap.号码 = Zt.号码(+) And Ap.开始时间 = Zt.日期(+)
                             Group By Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约
                             Order By Ap.序号) Loop
                If Nvl(n_时间间隔, 0) <> 0 Then
                  If d_时段开始 Is Null Then
                    d_时段开始 := r_Time.开始时间;
                    d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                    n_时段总数 := n_时段总数 + r_Time.限制数量;
                    If d_加号时间 < d_时段结束 Then
                      d_时段结束 := d_加号时间;
                    End If;
                  Else
                    If r_Time.开始时间 >= d_时段结束 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                    To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                    '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                      n_时段总数 := r_Time.限制数量;
                      n_时段剩余 := 0;
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      n_时段总数 := n_时段总数 + r_Time.限制数量;
                    End If;
                  End If;
                End If;
                If v_合作单位 Is Not Null Then
                  Select Nvl(Max(1), 0)
                  Into n_合约模式
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
                Else
                  n_合约模式 := 0;
                End If;
                n_单个剩余 := r_Time.剩余数;
                If v_合作单位 Is Null Or n_合约模式 = 1 Then
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And Rownum < 2;
                  If n_Exists = 0 And r_Time.失效时段 <> 1 Then
                    If n_最大可用数量 < n_单个剩余 Then
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_最大可用数量;
                      End If;
                      n_时段数量 := Nvl(n_时段数量, 0) + n_最大可用数量;
                    Else
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_单个剩余;
                      End If;
                      n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                    End If;
                  End If;
                Else
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                  Begin
                    Select 0
                    Into n_非合约
                    From 合作单位安排控制
                    Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_非合约 := 1;
                  End;
                  If (n_Exists = 1 Or n_非合约 = 1) And r_Time.失效时段 <> 1 Then
                    If n_最大可用数量 < n_单个剩余 Then
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_最大可用数量;
                      End If;
                      n_合约剩余数量 := n_合约剩余数量 + Nvl(n_最大可用数量, 0);
                    Else
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_单个剩余;
                      End If;
                      n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                    End If;
                  End If;
                End If;
              End Loop;
              If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                              To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                              n_时段剩余 || '</SL>' || '</SPAN>';
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
              End If;
            End If;
          End If;
        End If;
        If v_合作单位 Is Not Null Then
          If Nvl(r_No.计划id, 0) <> 0 Then
            Begin
              Select 0
              Into n_非合约
              From 合作单位计划控制
              Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
            Exception
              When Others Then
                n_非合约 := 1;
            End;
          Else
            Begin
              Select 0
              Into n_非合约
              From 合作单位安排控制
              Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
            Exception
              When Others Then
                n_非合约 := 1;
            End;
          End If;
        End If;
        If v_合作单位 Is Null Or n_非合约 = 1 Then
          If r_No.限号数 = 0 Then
            v_剩余数量 := '';
          Else
            If Nvl(r_No.计划id, 0) <> 0 Then
              Select Sum(数量)
              Into n_合约总数量
              From 合作单位计划控制
              Where 计划id = r_No.计划id And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null);
            Else
              Select Sum(数量)
              Into n_合约总数量
              From 合作单位安排控制
              Where 安排id = r_No.安排id And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null);
            End If;
            Select Count(1)
            Into n_合约已挂数
            From 病人挂号记录
            Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 Is Not Null And 发生时间 Between Trunc(d_日期) And
                  Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
            Select Count(1)
            Into n_预留数量
            From 挂号序号状态
            Where 状态 = 3 And 号码 = r_No.号码 And Trunc(日期) = Trunc(d_日期);
            If Trunc(d_日期) = Trunc(Sysdate) Then
              If Nvl(n_合约总数量, 0) = 0 Then
                v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_预留数量;
              Else
                v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_合约总数量 + n_合约已挂数 - n_预留数量;
              End If;
              n_已挂数 := r_No.已挂数;
              If Nvl(n_时段数量, 0) < v_剩余数量 And n_分时段 <> 0 Then
                n_缓冲序号 := 1;
                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_加号时间, 'hh24:mi:ss') || '-' || '</SJD>' ||
                              '<SL>' || To_Number(v_剩余数量 - Nvl(n_时段数量, 0) - Nvl(n_合约剩余数量, 0)) || '</SL>' || '</SPAN>';
              Else
                n_缓冲序号 := 0;
              End If;
            Else
              If Nvl(n_合约总数量, 0) = 0 Then
                v_剩余数量 := r_No.限约数 - r_No.已约数 - n_预留数量;
                If v_剩余数量 Is Null Then
                  v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_预留数量;
                End If;
              Else
                v_剩余数量 := r_No.限约数 - r_No.已约数 - n_合约总数量 + n_合约已挂数 - n_预留数量;
                If v_剩余数量 Is Null Then
                  v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_合约总数量 + n_合约已挂数 - n_预留数量;
                End If;
              End If;
              n_已挂数 := r_No.已挂数;
            End If;
          End If;
        Else
          If Nvl(r_No.计划id, 0) <> 0 Then
            If v_合作单位 Is Not Null Then
              Select Nvl(Max(1), 0)
              Into n_合约模式
              From 合作单位计划控制
              Where 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
            Else
              n_合约模式 := 0;
            End If;
            Select Sum(数量)
            Into n_合约总数量
            From 合作单位计划控制
            Where 计划id = r_No.计划id And 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                     '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
          Else
            If v_合作单位 Is Not Null Then
              Select Nvl(Max(1), 0)
              Into n_合约模式
              From 合作单位安排控制
              Where 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
            Else
              n_合约模式 := 0;
            End If;
            Select Sum(数量)
            Into n_合约总数量
            From 合作单位安排控制
            Where 安排id = r_No.安排id And 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                     '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
          End If;
          If n_合约模式 = 0 Then
            v_剩余数量   := n_合约剩余数量;
            n_已挂数     := r_No.已挂数;
            n_合约已挂数 := Nvl(n_合约总数量, 0) - n_合约剩余数量;
          Else
            n_已挂数 := r_No.已挂数;
            Select Count(1)
            Into n_合约已挂数
            From 病人挂号记录
            Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                  Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
            If Nvl(n_合约总数量, 0) = 0 Then
              v_剩余数量 := '0';
            Else
              v_剩余数量 := n_合约总数量 - n_合约已挂数;
            End If;
          End If;
        End If;
        Select To_Char(开始时间, 'hh24:mi') Into v_Timetemp From 时间段 Where 时间段 = r_No.排班;
        v_时间段 := v_Timetemp || '-';
        Select To_Char(终止时间, 'hh24:mi') Into v_Timetemp From 时间段 Where 时间段 = r_No.排班;
        v_时间段 := v_时间段 || v_Timetemp;
        If v_Temp Is Not Null Then
          v_Temp := v_Temp || '</SPANLIST>';
        End If;
        If v_合作单位 Is Not Null Then
          If Nvl(r_No.计划id, 0) <> 0 Then
            Select Nvl(Max(1), 0)
            Into n_禁用
            From 合作单位计划控制
            Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
          Else
            Select Nvl(Max(1), 0)
            Into n_禁用
            From 合作单位安排控制
            Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
          End If;
        End If;
        --限约数=0的预约禁止
        If Trunc(d_日期) <> Trunc(Sysdate) Then
          If r_No.限约数 = 0 Then
            n_禁用 := 1;
          End If;
        End If;
        If Nvl(n_禁用, 0) = 0 Then
          --从项金额计算
          n_合计金额 := r_No.价格;
          For r_Subfee In (Select 现价, 从项数次
                           From 收费从属项目 A, 收费价目 B
                           Where a.主项id = r_No.项目id And a.从项id = b.收费细目id And Sysdate Between b.执行日期 And
                                 Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))) Loop
            n_合计金额 := n_合计金额 + r_Subfee.现价 * r_Subfee.从项数次;
          End Loop;
          If Trunc(Sysdate) = Trunc(d_日期) Then
            Select Nvl(Max(1), 0)
            Into n_Exists
            From (Select 时间段
                   From 时间段
                   Where ('3000-01-10 ' || To_Char(Sysdate, 'HH24:MI:SS') < '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS')) Or
                         ('3000-01-10 ' || To_Char(Sysdate, 'HH24:MI:SS') <
                         Decode(Sign(开始时间 - 终止时间), 1, '3000-01-11 ' || To_Char(终止时间, 'HH24:MI:SS'),
                                 '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS'))))
            Where 时间段 = r_No.排班;
          Else
            n_Exists := 1;
          End If;
          If n_Exists = 1 Then
            If v_剩余数量 > 0 Then
              c_Xmlmain := '<HB>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' || r_No.医生id || '</YSID>' || '<YS>' ||
                           r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id || '</KSID>' || '<KSMC>' || r_No.科室名称 ||
                           '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' || r_No.项目id || '</XMID>' || '<XMMC>' ||
                           r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 || '</YGHS>' || '<SYHS>' || v_剩余数量 || '</SYHS>' ||
                           '<PRICE>' || n_合计金额 || '</PRICE>' || '<HCXH>' || n_缓冲序号 || '</HCXH>' || '<HL>' || r_No.号类 ||
                           '</HL>' || '<FSD>' || n_分时段 || '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' || '<FWMC>' ||
                           r_No.排班 || '</FWMC>' || v_Temp || '</HB>';
              v_Xmlmain := v_Xmlmain || c_Xmlmain;
            Else
              c_Xmlmain := '<HB>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' || r_No.医生id || '</YSID>' || '<YS>' ||
                           r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id || '</KSID>' || '<KSMC>' || r_No.科室名称 ||
                           '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' || r_No.项目id || '</XMID>' || '<XMMC>' ||
                           r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 || '</YGHS>' || '<SYHS>' || v_剩余数量 || '</SYHS>' ||
                           '<PRICE>' || n_合计金额 || '</PRICE>' || '<HL>' || r_No.号类 || '</HL>' || '<FSD>' || n_分时段 ||
                           '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' || '<FWMC>' || r_No.排班 || '</FWMC>' ||
                           '</HB>';
              v_Xmlmain := v_Xmlmain || c_Xmlmain;
            End If;
          End If;
        End If;
      End If;
      n_合约剩余数量 := 0;
      n_合约总数量   := 0;
      n_时段数量     := 0;
      n_禁用         := 0;
      n_非合约       := 0;
    End Loop;
    v_Xmlmain := '<GROUP>' || '<RQ>' || To_Char(d_日期, 'yyyy-mm-dd') || '</RQ>' || '<HBLIST>' || v_Xmlmain ||
                 '</HBLIST>' || '</GROUP>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Xmlmain)) Into x_Templet From Dual;
  Else
    --出诊表排班模式
    n_合约剩余数量 := 0;
    For r_No In (Select a.科室id, b.号类, c.名称 As 科室名称, a.医生姓名, a.医生id, d.专业技术职务 As 职称, b.号码, a.Id As 记录id, a.上班时段 As 排班,
                        a.项目id, e.名称 As 项目名称, a.是否序号控制 As 序号控制, a.限号数, Nvl(a.限约数, a.限号数) As 限约数, Nvl(a.已挂数, 0) As 已挂数,
                        Nvl(a.已约数, 0) As 已约数, Nvl(a.其中已接收, 0) As 已接收, a.是否分时段 As 分时段, a.开始时间, a.终止时间, a.预约控制, a.替诊开始时间,
                        a.替诊终止时间, Nvl(b.预约天数, n_预约天数) As 预约天数, a.停诊开始时间, a.停诊终止时间
                 From 临床出诊记录 A, 临床出诊号源 B, 部门表 C, 人员表 D, 收费项目目录 E
                 Where a.出诊日期 = Trunc(d_日期) And a.终止时间 > Sysdate And a.号源id = b.Id And a.项目id = e.Id And
                       a.医生id = d.Id(+) And b.科室id = c.Id And Nvl(a.是否锁定, 0) = 0 And
                       (a.开始时间 < Nvl(a.停诊开始时间, a.终止时间) Or a.终止时间 > Nvl(a.停诊终止时间, a.开始时间) Or Exists
                        (Select 1
                         From 临床出诊序号控制 C, 临床出诊记录 D
                         Where d.Id = a.Id And c.记录id = d.Id And Nvl(c.是否停诊, 0) = 0 And d.是否序号控制 = 1 And d.是否分时段 = 1 And
                               c.开始时间 <> c.终止时间)) And (a.开始时间 < Nvl(a.替诊开始时间, a.终止时间) Or a.终止时间 > Nvl(a.替诊终止时间, a.开始时间)) And
                       Nvl(a.是否发布, 0) = 1 And a.开始时间 > Trunc(To_Date(v_启用时间, 'yyyy-mm-dd hh24:mi:ss')) And
                       Decode(Nvl(n_科室id, 0), 0, 0, b.科室id) = Nvl(n_科室id, 0) And
                       Decode(Nvl(n_医生id, 0), 0, 0, a.医生id) = Nvl(n_医生id, 0) And
                       Decode(Nvl(v_医生姓名, '-'), '-', '-', a.医生姓名) = Nvl(v_医生姓名, '-')) Loop
      Zl_挂号序号状态_出诊_Delete(r_No.记录id);
      v_Temp := Null;
      If Sysdate + Nvl(r_No.预约天数, n_预约天数) >= d_日期 Then
        If Trunc(d_日期) = Trunc(Sysdate) Then
          --当天挂号
          If v_合作单位 Is Null Then
            --未传入合作单位
            n_已挂数   := r_No.已挂数;
            v_剩余数量 := r_No.限号数 - Nvl(r_No.已挂数, 0) - (Nvl(r_No.已约数, 0) - Nvl(r_No.已接收, 0));
            If r_No.分时段 = 1 And r_No.序号控制 = 1 Then
              --分时段
              Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
              v_Temp     := '<SPANLIST>';
              n_Exists   := 0;
              n_时段总数 := 0;
              n_时段剩余 := 0;
              d_时段开始 := Null;
              d_时段结束 := Null;
              For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                             From 临床出诊序号控制
                             Where 记录id = r_No.记录id And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                                   Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1) Loop
                If Nvl(n_时间间隔, 0) <> 0 Then
                  If d_时段开始 Is Null Then
                    d_时段开始 := r_Time.开始时间;
                    d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                    n_时段总数 := n_时段总数 + 1;
                    If d_加号时间 < d_时段结束 Then
                      d_时段结束 := d_加号时间;
                    End If;
                  Else
                    If r_Time.开始时间 >= d_时段结束 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                    To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                    '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                      n_时段总数 := 1;
                      n_时段剩余 := 0;
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      n_时段总数 := n_时段总数 + 1;
                    End If;
                  End If;
                End If;
                If r_Time.开始时间 > Sysdate Then
                  If Nvl(n_时间间隔, 0) = 0 Then
                    v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                              To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                    If Nvl(r_Time.挂号状态, 0) = 0 Then
                      v_Temp   := v_Temp || '<SL>1</SL></SPAN>';
                      n_Exists := n_Exists + 1;
                    Else
                      v_Temp := v_Temp || '<SL>0</SL></SPAN>';
                    End If;
                  Else
                    If Nvl(r_Time.挂号状态, 0) = 0 Then
                      n_时段剩余 := n_时段剩余 + 1;
                      n_Exists   := n_Exists + 1;
                    End If;
                  End If;
                End If;
              End Loop;
              If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                              To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                              n_时段剩余 || '</SL>' || '</SPAN>';
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
              End If;
            
              If n_Exists < To_Number(v_剩余数量) And r_No.替诊开始时间 Is Null Then
                v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_加号时间, 'hh24:mi:ss') || '-' || '</SJD><SL>' ||
                          To_Number(v_剩余数量 - n_Exists) || '</SL></SPAN>';
              End If;
              v_Temp := v_Temp || '</SPANLIST>';
            End If;
          Else
            --传入合作单位
            n_已挂数 := r_No.已挂数;
            Begin
              Select 控制方式
              Into n_合约模式
              From 临床出诊挂号控制记录
              Where 记录id = r_No.记录id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1 And Rownum < 2;
            Exception
              When Others Then
                n_合约模式 := 4;
            End;
            If n_合约模式 = 0 Then
              n_禁用 := 1;
            End If;
            If n_合约模式 = 1 Or n_合约模式 = 2 Then
              Select 数量
              Into n_合约总数量
              From 临床出诊挂号控制记录
              Where 记录id = r_No.记录id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1;
              If n_合约模式 = 1 Then
                n_合约总数量 := Round(r_No.限号数 * n_合约总数量 / 100);
              End If;
              Select Count(1)
              Into n_合约已挂数
              From 病人挂号记录
              Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                    Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
              n_合约剩余数量 := n_合约总数量 - n_合约已挂数;
              If r_No.限号数 - Nvl(r_No.已挂数, 0) < n_合约剩余数量 Then
                v_剩余数量 := r_No.限号数 - Nvl(r_No.已挂数, 0);
              Else
                v_剩余数量 := n_合约剩余数量;
              End If;
              If r_No.分时段 = 1 And r_No.序号控制 = 1 Then
                --分时段
                v_Temp   := '<SPANLIST>';
                n_Exists := 0;
                Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
                For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                               From 临床出诊序号控制
                               Where 记录id = r_No.记录id And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                                     Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1) Loop
                  If Nvl(n_时间间隔, 0) <> 0 Then
                    If d_时段开始 Is Null Then
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                      n_时段总数 := n_时段总数 + 1;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      If r_Time.开始时间 >= d_时段结束 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 1;
                        n_时段剩余 := 0;
                        d_时段开始 := r_Time.开始时间;
                        d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                        If d_加号时间 < d_时段结束 Then
                          d_时段结束 := d_加号时间;
                        End If;
                      Else
                        n_时段总数 := n_时段总数 + 1;
                      End If;
                    End If;
                  End If;
                  If r_Time.开始时间 > Sysdate Then
                    If Nvl(n_时间间隔, 0) = 0 Then
                      v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                      If Nvl(r_Time.挂号状态, 0) = 0 Then
                        v_Temp   := v_Temp || '<SL>1</SL></SPAN>';
                        n_Exists := n_Exists + 1;
                      Else
                        v_Temp := v_Temp || '<SL>0</SL></SPAN>';
                      End If;
                    Else
                      If Nvl(r_Time.挂号状态, 0) = 0 Then
                        n_时段剩余 := n_时段剩余 + 1;
                        n_Exists   := n_Exists + 1;
                      End If;
                    End If;
                  End If;
                End Loop;
                If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                  v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                                n_时段剩余 || '</SL>' || '</SPAN>';
                  n_时段总数 := 0;
                  n_时段剩余 := 0;
                  d_时段开始 := Null;
                  d_时段结束 := Null;
                End If;
                If n_Exists < To_Number(v_剩余数量) And r_No.替诊开始时间 Is Null Then
                  v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_加号时间, 'hh24:mi:ss') || '-' || '</SJD><SL>' ||
                            To_Number(v_剩余数量 - n_Exists) || '</SL></SPAN>';
                End If;
                v_Temp := v_Temp || '</SPANLIST>';
              End If;
            End If;
            If n_合约模式 = 3 Then
              If n_序号控制 = 0 Then
                n_已挂数   := r_No.已挂数;
                v_剩余数量 := r_No.限号数 - Nvl(r_No.已挂数, 0) - (Nvl(r_No.已约数, 0) - Nvl(r_No.已接收, 0));
              Else
                n_已挂数   := 0;
                v_剩余数量 := 0;
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
                For r_合作 In (Select 序号
                             From 临床出诊挂号控制记录
                             Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位) Loop
                  Begin
                    Select 1, 开始时间, 终止时间
                    Into n_Exists, d_开始时间, d_终止时间
                    From 临床出诊序号控制
                    Where 序号 = r_合作.序号 And Nvl(挂号状态, 0) = 0 And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                          Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1;
                  Exception
                    When Others Then
                      n_Exists := 0;
                  End;
                  If Nvl(n_时间间隔, 0) <> 0 Then
                    If d_时段开始 Is Null Then
                      d_时段开始 := d_开始时间;
                      d_时段结束 := d_开始时间 + 1 / 24 / 60 * n_时间间隔;
                      n_时段总数 := n_时段总数 + 1;
                    Else
                      If d_开始时间 >= d_时段结束 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 1;
                        n_时段剩余 := 0;
                        d_时段开始 := d_开始时间;
                        d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                      Else
                        n_时段总数 := n_时段总数 + 1;
                      End If;
                    End If;
                  End If;
                  If n_Exists = 1 Then
                    v_剩余数量 := v_剩余数量 + 1;
                    If r_No.分时段 = 1 Then
                      If d_开始时间 > Sysdate Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(d_终止时间, 'hh24:mi:ss') || '</SJD><SL>1</SL></SPAN>';
                        Else
                          n_时段剩余 := n_时段剩余 + 1;
                        End If;
                      End If;
                    End If;
                  Else
                    n_已挂数 := n_已挂数 + 1;
                  End If;
                End Loop;
                If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                  v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                                n_时段剩余 || '</SL>' || '</SPAN>';
                  n_时段总数 := 0;
                  n_时段剩余 := 0;
                  d_时段开始 := Null;
                  d_时段结束 := Null;
                End If;
                If v_Temp Is Not Null Then
                  v_Temp := '<SPANLIST>' || v_Temp || '</SPANLIST>';
                End If;
              End If;
            End If;
            If n_合约模式 = 4 Then
              n_已挂数   := r_No.已挂数;
              v_剩余数量 := r_No.限号数 - Nvl(r_No.已挂数, 0) - (Nvl(r_No.已约数, 0) - Nvl(r_No.已接收, 0));
              If r_No.分时段 = 1 And r_No.序号控制 = 1 Then
                --分时段
                v_Temp   := '<SPANLIST>';
                n_Exists := 0;
                Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
                For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                               From 临床出诊序号控制
                               Where 记录id = r_No.记录id And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                                     Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1) Loop
                  If Nvl(n_时间间隔, 0) <> 0 Then
                    If d_时段开始 Is Null Then
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                      n_时段总数 := n_时段总数 + 1;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      If r_Time.开始时间 >= d_时段结束 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 1;
                        n_时段剩余 := 0;
                        d_时段开始 := r_Time.开始时间;
                        d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                        If d_加号时间 < d_时段结束 Then
                          d_时段结束 := d_加号时间;
                        End If;
                      Else
                        n_时段总数 := n_时段总数 + 1;
                      End If;
                    End If;
                  End If;
                  If r_Time.开始时间 > Sysdate Then
                    If Nvl(n_时间间隔, 0) = 0 Then
                      v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                      If Nvl(r_Time.挂号状态, 0) = 0 Then
                        v_Temp   := v_Temp || '<SL>1</SL></SPAN>';
                        n_Exists := n_Exists + 1;
                      Else
                        v_Temp := v_Temp || '<SL>0</SL></SPAN>';
                      End If;
                    Else
                      If Nvl(r_Time.挂号状态, 0) = 0 Then
                        n_时段剩余 := n_时段剩余 + 1;
                        n_Exists   := n_Exists + 1;
                      End If;
                    End If;
                  End If;
                End Loop;
                If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                  v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                                n_时段剩余 || '</SL>' || '</SPAN>';
                  n_时段总数 := 0;
                  n_时段剩余 := 0;
                  d_时段开始 := Null;
                  d_时段结束 := Null;
                End If;
                If n_Exists < To_Number(v_剩余数量) And r_No.替诊开始时间 Is Null Then
                  v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_加号时间, 'hh24:mi:ss') || '-' || '</SJD><SL>' ||
                            To_Number(v_剩余数量 - n_Exists) || '</SL></SPAN>';
                End If;
                v_Temp := v_Temp || '</SPANLIST>';
              End If;
            End If;
          End If;
        Else
          --预约挂号
          If r_No.预约控制 = 1 Then
            n_禁用 := 1;
          Else
            --不限制预约
            If v_合作单位 Is Null Then
              If r_No.分时段 = 0 Then
                n_已挂数   := r_No.已约数;
                v_剩余数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
              Else
                --分时段
                n_已挂数   := 0;
                v_剩余数量 := 0;
                v_Temp     := '<SPANLIST>';
                If r_No.序号控制 = 0 Then
                  --非序号控制分时段预约
                  n_时段总数 := 0;
                  n_时段剩余 := 0;
                  d_时段开始 := Null;
                  d_时段结束 := Null;
                  Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                  For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态, 数量
                                 From 临床出诊序号控制
                                 Where 记录id = r_No.记录id And 预约顺序号 Is Null And 是否预约 = 1 And
                                       开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) And
                                       开始时间 Not Between Nvl(r_No.停诊开始时间, Sysdate) And Nvl(r_No.停诊终止时间, Sysdate - 1)) Loop
                    If Nvl(n_时间间隔, 0) <> 0 Then
                      If d_时段开始 Is Null Then
                        d_时段开始 := r_Time.开始时间;
                        d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                        n_时段总数 := n_时段总数 + r_Time.数量;
                        If d_加号时间 < d_时段结束 Then
                          d_时段结束 := d_加号时间;
                        End If;
                      Else
                        If r_Time.开始时间 >= d_时段结束 Then
                          v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                        To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                        '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                          n_时段总数 := r_Time.数量;
                          n_时段剩余 := 0;
                          d_时段开始 := r_Time.开始时间;
                          d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                          If d_加号时间 < d_时段结束 Then
                            d_时段结束 := d_加号时间;
                          End If;
                        Else
                          n_时段总数 := n_时段总数 + r_Time.数量;
                        End If;
                      End If;
                    End If;
                    Select Count(1)
                    Into n_时段已挂
                    From 临床出诊序号控制
                    Where 预约顺序号 Is Not Null And Nvl(挂号状态, 0) <> 0;
                    If r_Time.开始时间 > Sysdate Then
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                        v_Temp := v_Temp || '<SL>' || r_Time.数量 - n_时段已挂 || '</SL></SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + r_Time.数量 - n_时段已挂;
                      End If;
                      n_已挂数   := n_已挂数 + n_时段已挂;
                      v_剩余数量 := v_剩余数量 + (r_Time.数量 - n_时段已挂);
                    End If;
                  End Loop;
                  If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                    v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                  To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                  '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                    n_时段总数 := 0;
                    n_时段剩余 := 0;
                    d_时段开始 := Null;
                    d_时段结束 := Null;
                  End If;
                Else
                  n_时段总数 := 0;
                  n_时段剩余 := 0;
                  d_时段开始 := Null;
                  d_时段结束 := Null;
                  Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                  For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                                 From 临床出诊序号控制
                                 Where 记录id = r_No.记录id And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                                       Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1) Loop
                    If Nvl(n_时间间隔, 0) <> 0 Then
                      If d_时段开始 Is Null Then
                        d_时段开始 := r_Time.开始时间;
                        d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                        n_时段总数 := n_时段总数 + 1;
                        If d_加号时间 < d_时段结束 Then
                          d_时段结束 := d_加号时间;
                        End If;
                      Else
                        If r_Time.开始时间 >= d_时段结束 Then
                          v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                        To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                        '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                          n_时段总数 := 1;
                          n_时段剩余 := 0;
                          d_时段开始 := r_Time.开始时间;
                          d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                          If d_加号时间 < d_时段结束 Then
                            d_时段结束 := d_加号时间;
                          End If;
                        Else
                          n_时段总数 := n_时段总数 + 1;
                        End If;
                      End If;
                    End If;
                    If r_Time.开始时间 > Sysdate Then
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                        If Nvl(r_Time.挂号状态, 0) = 0 Then
                          v_Temp     := v_Temp || '<SL>1</SL></SPAN>';
                          v_剩余数量 := v_剩余数量 + 1;
                        Else
                          v_Temp   := v_Temp || '<SL>0</SL></SPAN>';
                          n_已挂数 := n_已挂数 + 1;
                        End If;
                      Else
                        If Nvl(r_Time.挂号状态, 0) = 0 Then
                          n_时段剩余 := n_时段剩余 + 1;
                          v_剩余数量 := v_剩余数量 + 1;
                        Else
                          n_已挂数 := n_已挂数 + 1;
                        End If;
                        n_时段剩余 := n_时段剩余 + 1;
                      End If;
                    End If;
                  End Loop;
                  If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                    v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                  To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                  '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                    n_时段总数 := 0;
                    n_时段剩余 := 0;
                    d_时段开始 := Null;
                    d_时段结束 := Null;
                  End If;
                End If;
                v_Temp := v_Temp || '</SPANLIST>';
              End If;
            Else
              --合作单位预约挂号
              If r_No.预约控制 = 2 Then
                n_禁用 := 1;
              Else
                Begin
                  Select 控制方式
                  Into n_合约模式
                  From 临床出诊挂号控制记录
                  Where 记录id = r_No.记录id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1 And Rownum < 2;
                Exception
                  When Others Then
                    n_合约模式 := 4;
                End;
                If n_合约模式 = 0 Then
                  n_禁用 := 1;
                End If;
                If n_合约模式 = 1 Or n_合约模式 = 2 Then
                  Select 数量
                  Into n_合约总数量
                  From 临床出诊挂号控制记录
                  Where 记录id = r_No.记录id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1;
                  If n_合约模式 = 1 Then
                    n_合约总数量 := Round(r_No.限号数 * n_合约总数量 / 100);
                  End If;
                  Begin
                    Select Count(1)
                    Into n_合约已挂数
                    From 病人挂号记录
                    Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                          Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
                  Exception
                    When Others Then
                      n_合约已挂数 := 0;
                  End;
                  n_合约剩余数量 := n_合约总数量 - n_合约已挂数;
                  If Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0) < n_合约剩余数量 Then
                    v_剩余数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
                  Else
                    v_剩余数量 := n_合约剩余数量;
                  End If;
                  If r_No.分时段 = 1 Then
                    v_Temp := '<SPANLIST>';
                    If r_No.序号控制 = 1 Then
                      --分时段,序号控制
                      n_Exists   := 0;
                      n_时段总数 := 0;
                      n_时段剩余 := 0;
                      d_时段开始 := Null;
                      d_时段结束 := Null;
                      Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                      For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                                     From 临床出诊序号控制
                                     Where 记录id = r_No.记录id And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                                           Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1) Loop
                        If Nvl(n_时间间隔, 0) <> 0 Then
                          If d_时段开始 Is Null Then
                            d_时段开始 := r_Time.开始时间;
                            d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                            n_时段总数 := n_时段总数 + 1;
                            If d_加号时间 < d_时段结束 Then
                              d_时段结束 := d_加号时间;
                            End If;
                          Else
                            If r_Time.开始时间 >= d_时段结束 Then
                              v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                            To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 ||
                                            '</GHZS>' || '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                              n_时段总数 := 1;
                              n_时段剩余 := 0;
                              d_时段开始 := r_Time.开始时间;
                              d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                              If d_加号时间 < d_时段结束 Then
                                d_时段结束 := d_加号时间;
                              End If;
                            Else
                              n_时段总数 := n_时段总数 + 1;
                            End If;
                          End If;
                        End If;
                        If r_Time.开始时间 > Sysdate Then
                          If Nvl(n_时间间隔, 0) = 0 Then
                            v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                            If Nvl(r_Time.挂号状态, 0) = 0 Then
                              v_Temp   := v_Temp || '<SL>1</SL></SPAN>';
                              n_Exists := n_Exists + 1;
                            Else
                              v_Temp := v_Temp || '<SL>0</SL></SPAN>';
                            End If;
                          Else
                            n_Exists   := n_Exists + 1;
                            n_时段剩余 := n_时段剩余 + 1;
                          End If;
                        End If;
                      End Loop;
                      If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 0;
                        n_时段剩余 := 0;
                        d_时段开始 := Null;
                        d_时段结束 := Null;
                      End If;
                      If n_Exists < To_Number(v_剩余数量) Then
                        v_剩余数量 := n_Exists;
                      End If;
                    Else
                      --分时段,非序号控制
                      n_Exists   := 0;
                      n_时段总数 := 0;
                      n_时段剩余 := 0;
                      d_时段开始 := Null;
                      d_时段结束 := Null;
                      Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                      For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态, 数量
                                     From 临床出诊序号控制
                                     Where 记录id = r_No.记录id And 预约顺序号 Is Null And 是否预约 = 1 And
                                           开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) And
                                           开始时间 Not Between Nvl(r_No.停诊开始时间, Sysdate) And Nvl(r_No.停诊终止时间, Sysdate - 1)) Loop
                        If Nvl(n_时间间隔, 0) <> 0 Then
                          If d_时段开始 Is Null Then
                            d_时段开始 := r_Time.开始时间;
                            d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                            n_时段总数 := n_时段总数 + r_Time.数量;
                            If d_加号时间 < d_时段结束 Then
                              d_时段结束 := d_加号时间;
                            End If;
                          Else
                            If r_Time.开始时间 >= d_时段结束 Then
                              v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                            To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 ||
                                            '</GHZS>' || '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                              n_时段总数 := r_Time.数量;
                              n_时段剩余 := 0;
                              d_时段开始 := r_Time.开始时间;
                              d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                              If d_加号时间 < d_时段结束 Then
                                d_时段结束 := d_加号时间;
                              End If;
                            Else
                              n_时段总数 := n_时段总数 + r_Time.数量;
                            End If;
                          End If;
                        End If;
                        Select Count(1)
                        Into n_时段已挂
                        From 临床出诊序号控制
                        Where 预约顺序号 Is Not Null And Nvl(挂号状态, 0) <> 0;
                        If r_Time.开始时间 > Sysdate Then
                          If Nvl(n_时间间隔, 0) = 0 Then
                            v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                            v_Temp := v_Temp || '<SL>' || r_Time.数量 - n_时段已挂 || '</SL></SPAN>';
                          Else
                            n_时段剩余 := n_时段剩余 + (r_Time.数量 - n_时段已挂);
                          End If;
                          n_Exists := n_Exists + (r_Time.数量 - n_时段已挂);
                        End If;
                      End Loop;
                      If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 0;
                        n_时段剩余 := 0;
                        d_时段开始 := Null;
                        d_时段结束 := Null;
                      End If;
                      If n_Exists < To_Number(v_剩余数量) Then
                        v_剩余数量 := n_Exists;
                      End If;
                    End If;
                    v_Temp := v_Temp || '</SPANLIST>';
                  End If;
                  n_已挂数 := r_No.已约数;
                End If;
                If n_合约模式 = 3 Then
                  If r_No.分时段 = 0 Then
                    If r_No.序号控制 = 0 Then
                      n_禁用 := 1;
                    Else
                      n_已挂数   := 0;
                      v_剩余数量 := 0;
                      For r_合作 In (Select 序号
                                   From 临床出诊挂号控制记录
                                   Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位) Loop
                        Begin
                          Select 1
                          Into n_Exists
                          From 临床出诊序号控制
                          Where 记录id = r_No.记录id And 序号 = r_合作.序号 And 是否预约 = 1 And Nvl(挂号状态, 0) = 0 And
                                开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) And
                                Nvl(是否停诊, 0) <> 1;
                        Exception
                          When Others Then
                            n_Exists := 0;
                        End;
                        If n_Exists = 1 Then
                          v_剩余数量 := v_剩余数量 + 1;
                        Else
                          n_已挂数 := n_已挂数 + 1;
                        End If;
                      End Loop;
                      If Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0) < v_剩余数量 Then
                        v_剩余数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
                      End If;
                    End If;
                  Else
                    If r_No.序号控制 = 0 Then
                      --合作单位,分时段,非序号控制
                      n_已挂数   := 0;
                      v_剩余数量 := 0;
                      v_Temp     := '<SPANLIST>';
                      n_时段总数 := 0;
                      n_时段剩余 := 0;
                      d_时段开始 := Null;
                      d_时段结束 := Null;
                      For r_合作 In (Select 序号, 数量
                                   From 临床出诊挂号控制记录
                                   Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位) Loop
                        Begin
                          Select Count(1), Max(开始时间), Max(终止时间)
                          Into n_时段已挂, d_开始时间, d_终止时间
                          From 临床出诊序号控制
                          Where 记录id = r_No.记录id And 预约顺序号 Is Not Null And Nvl(挂号状态, 0) <> 0 And 序号 = r_合作.序号 And
                                开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1);
                        
                          If Nvl(n_时间间隔, 0) <> 0 Then
                            If d_时段开始 Is Null Then
                              d_时段开始 := d_开始时间;
                              d_时段结束 := d_开始时间 + 1 / 24 / 60 * n_时间间隔;
                              n_时段总数 := n_时段总数 + r_合作.数量;
                            Else
                              If d_开始时间 >= d_时段结束 Then
                                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                              To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 ||
                                              '</GHZS>' || '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                                n_时段总数 := r_合作.数量;
                                n_时段剩余 := 0;
                                d_时段开始 := d_开始时间;
                                d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                              Else
                                n_时段总数 := n_时段总数 + r_合作.数量;
                              End If;
                            End If;
                          End If;
                          If d_开始时间 > Sysdate Then
                            n_已挂数 := n_已挂数 + n_时段已挂;
                            If Nvl(n_时间间隔, 0) = 0 Then
                              v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(d_终止时间, 'hh24:mi:ss') || '</SJD>';
                              v_Temp := v_Temp || '<SL>' || r_合作.数量 - n_时段已挂 || '</SL></SPAN>';
                            Else
                              n_时段剩余 := n_时段剩余 + r_合作.数量 - n_时段已挂;
                            End If;
                            v_剩余数量 := v_剩余数量 + r_合作.数量 - n_时段已挂;
                          End If;
                        Exception
                          When Others Then
                            Null;
                        End;
                      End Loop;
                      If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 0;
                        n_时段剩余 := 0;
                        d_时段开始 := Null;
                        d_时段结束 := Null;
                      End If;
                      v_Temp := v_Temp || '</SPANLIST>';
                    Else
                      n_已挂数   := 0;
                      v_剩余数量 := 0;
                      v_Temp     := '<SPANLIST>';
                      n_时段总数 := 0;
                      n_时段剩余 := 0;
                      d_时段开始 := Null;
                      d_时段结束 := Null;
                      For r_合作 In (Select 序号
                                   From 临床出诊挂号控制记录
                                   Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位) Loop
                        Begin
                          Select 1, 开始时间, 终止时间
                          Into n_Exists, d_开始时间, d_终止时间
                          From 临床出诊序号控制
                          Where 记录id = r_No.记录id And Nvl(挂号状态, 0) = 0 And 序号 = r_合作.序号 And
                                开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) And
                                Nvl(是否停诊, 0) <> 1;
                        Exception
                          When Others Then
                            n_Exists := 0;
                        End;
                        If Nvl(n_时间间隔, 0) <> 0 Then
                          If d_时段开始 Is Null Then
                            d_时段开始 := d_开始时间;
                            d_时段结束 := d_开始时间 + 1 / 24 / 60 * n_时间间隔;
                            n_时段总数 := n_时段总数 + 1;
                          Else
                            If d_开始时间 >= d_时段结束 Then
                              v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                            To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 ||
                                            '</GHZS>' || '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                              n_时段总数 := 1;
                              n_时段剩余 := 0;
                              d_时段开始 := d_开始时间;
                              d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                            Else
                              n_时段总数 := n_时段总数 + 1;
                            End If;
                          End If;
                        End If;
                        If d_开始时间 > Sysdate Then
                          If n_Exists = 1 Then
                            v_剩余数量 := v_剩余数量 + 1;
                            If Nvl(n_时间间隔, 0) = 0 Then
                              v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(d_终止时间, 'hh24:mi:ss') || '</SJD>';
                              v_Temp := v_Temp || '<SL>' || 1 || '</SL></SPAN>';
                            Else
                              n_时段剩余 := n_时段剩余 + 1;
                            End If;
                          Else
                            If Nvl(n_时间间隔, 0) = 0 Then
                              v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(d_终止时间, 'hh24:mi:ss') || '</SJD>';
                              v_Temp := v_Temp || '<SL>' || 0 || '</SL></SPAN>';
                            End If;
                            n_已挂数 := n_已挂数 + 1;
                          End If;
                        End If;
                      End Loop;
                      If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 0;
                        n_时段剩余 := 0;
                        d_时段开始 := Null;
                        d_时段结束 := Null;
                      End If;
                    End If;
                  End If;
                End If;
                If n_合约模式 = 4 Then
                  If r_No.分时段 = 0 Then
                    n_已挂数   := r_No.已约数;
                    v_剩余数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
                  Else
                    --分时段
                    n_已挂数   := 0;
                    v_剩余数量 := 0;
                    v_Temp     := '<SPANLIST>';
                    n_时段总数 := 0;
                    n_时段剩余 := 0;
                    d_时段开始 := Null;
                    d_时段结束 := Null;
                    Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                    If r_No.序号控制 = 0 Then
                      --非序号控制分时段预约
                      For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态, 数量
                                     From 临床出诊序号控制
                                     Where 记录id = r_No.记录id And 预约顺序号 Is Null And 是否预约 = 1 And
                                           开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) And
                                           开始时间 Not Between Nvl(r_No.停诊开始时间, Sysdate) And Nvl(r_No.停诊终止时间, Sysdate - 1)) Loop
                        If Nvl(n_时间间隔, 0) <> 0 Then
                          If d_时段开始 Is Null Then
                            d_时段开始 := r_Time.开始时间;
                            d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                            n_时段总数 := n_时段总数 + r_Time.数量;
                            If d_加号时间 < d_时段结束 Then
                              d_时段结束 := d_加号时间;
                            End If;
                          Else
                            If r_Time.开始时间 >= d_时段结束 Then
                              v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                            To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 ||
                                            '</GHZS>' || '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                              n_时段总数 := r_Time.数量;
                              n_时段剩余 := 0;
                              d_时段开始 := r_Time.开始时间;
                              d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                              If d_加号时间 < d_时段结束 Then
                                d_时段结束 := d_加号时间;
                              End If;
                            Else
                              n_时段总数 := n_时段总数 + r_Time.数量;
                            End If;
                          End If;
                        End If;
                        Select Count(1)
                        Into n_时段已挂
                        From 临床出诊序号控制
                        Where 预约顺序号 Is Not Null And Nvl(挂号状态, 0) <> 0;
                        If r_Time.开始时间 > Sysdate Then
                          If Nvl(n_时间间隔, 0) = 0 Then
                            v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                            v_Temp := v_Temp || '<SL>' || r_Time.数量 - n_时段已挂 || '</SL></SPAN>';
                          Else
                            n_时段剩余 := n_时段剩余 + (r_Time.数量 - n_时段已挂);
                          End If;
                          n_已挂数   := n_已挂数 + n_时段已挂;
                          v_剩余数量 := v_剩余数量 + (r_Time.数量 - n_时段已挂);
                        End If;
                      End Loop;
                      If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 0;
                        n_时段剩余 := 0;
                        d_时段开始 := Null;
                        d_时段结束 := Null;
                      End If;
                    Else
                      n_时段总数 := 0;
                      n_时段剩余 := 0;
                      d_时段开始 := Null;
                      d_时段结束 := Null;
                      For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                                     From 临床出诊序号控制
                                     Where 记录id = r_No.记录id And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                                           Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1) Loop
                        If Nvl(n_时间间隔, 0) <> 0 Then
                          If d_时段开始 Is Null Then
                            d_时段开始 := r_Time.开始时间;
                            d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                            n_时段总数 := n_时段总数 + 1;
                            If d_加号时间 < d_时段结束 Then
                              d_时段结束 := d_加号时间;
                            End If;
                          Else
                            If r_Time.开始时间 >= d_时段结束 Then
                              v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                            To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 ||
                                            '</GHZS>' || '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                              n_时段总数 := 1;
                              n_时段剩余 := 0;
                              d_时段开始 := r_Time.开始时间;
                              d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                              If d_加号时间 < d_时段结束 Then
                                d_时段结束 := d_加号时间;
                              End If;
                            Else
                              n_时段总数 := n_时段总数 + 1;
                            End If;
                          End If;
                        End If;
                        If r_Time.开始时间 > Sysdate Then
                          If Nvl(n_时间间隔, 0) = 0 Then
                            v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                            If Nvl(r_Time.挂号状态, 0) = 0 Then
                              v_Temp     := v_Temp || '<SL>1</SL></SPAN>';
                              v_剩余数量 := v_剩余数量 + 1;
                            Else
                              v_Temp   := v_Temp || '<SL>0</SL></SPAN>';
                              n_已挂数 := n_已挂数 + 1;
                            End If;
                          Else
                            If Nvl(r_Time.挂号状态, 0) = 0 Then
                              n_时段剩余 := n_时段剩余 + 1;
                              v_剩余数量 := v_剩余数量 + 1;
                            Else
                              n_已挂数 := n_已挂数 + 1;
                            End If;
                          End If;
                        End If;
                      End Loop;
                      If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 0;
                        n_时段剩余 := 0;
                        d_时段开始 := Null;
                        d_时段结束 := Null;
                      End If;
                    End If;
                    v_Temp := v_Temp || '</SPANLIST>';
                  End If;
                End If;
              End If;
            End If;
          End If;
        End If;
      
        If Not (r_No.分时段 = 1 And r_No.序号控制 = 1) Then
          If d_日期 Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) Then
            n_禁用 := 1;
          End If;
          If d_日期 Between Nvl(r_No.停诊开始时间, Sysdate) And Nvl(r_No.停诊终止时间, Sysdate - 1) Then
            n_禁用 := 1;
          End If;
        End If;
      
        If Nvl(n_禁用, 0) = 0 Then
          n_合计金额 := 0;
          For r_Fee In (Select b.现价, a.从项数次
                        From 收费从属项目 A, 收费价目 B
                        Where a.主项id = r_No.项目id And a.从项id = b.收费细目id And Sysdate Between b.执行日期 And
                              Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                        Union
                        Select b.现价, 1 As 从项数次
                        From 收费项目目录 A, 收费价目 B
                        Where a.Id = b.收费细目id And a.Id = r_No.项目id And Sysdate Between b.执行日期 And
                              Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))) Loop
            n_合计金额 := n_合计金额 + r_Fee.现价 * r_Fee.从项数次;
          End Loop;
          v_时间段 := To_Char(r_No.开始时间, 'HH24:MI') || '-' || To_Char(r_No.终止时间, 'HH24:MI');
          If Trunc(Sysdate) = Trunc(d_日期) Then
            c_Xmlmain := '<HB>' || '<CZJLID>' || r_No.记录id || '</CZJLID>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' ||
                         r_No.医生id || '</YSID>' || '<YS>' || r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id || '</KSID>' ||
                         '<KSMC>' || r_No.科室名称 || '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' || r_No.项目id ||
                         '</XMID>' || '<XMMC>' || r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 || '</YGHS>' || '<SYHS>' ||
                         v_剩余数量 || '</SYHS>' || '<PRICE>' || n_合计金额 || '</PRICE>' || '<HL>' || r_No.号类 || '</HL>' ||
                         '<FSD>' || r_No.分时段 || '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' || '<FWMC>' || r_No.排班 ||
                         '</FWMC>' || v_Temp || '</HB>';
            v_Xmlmain := v_Xmlmain || c_Xmlmain;
          Else
            If r_No.已约数 >= r_No.限约数 Then
              c_Xmlmain := '<HB>' || '<CZJLID>' || r_No.记录id || '</CZJLID>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' ||
                           r_No.医生id || '</YSID>' || '<YS>' || r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id ||
                           '</KSID>' || '<KSMC>' || r_No.科室名称 || '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' ||
                           r_No.项目id || '</XMID>' || '<XMMC>' || r_No.项目名称 || '</XMMC>' || '<YGHS>' || r_No.已约数 ||
                           '</YGHS>' || '<SYHS>' || 0 || '</SYHS>' || '<PRICE>' || n_合计金额 || '</PRICE>' || '<HL>' ||
                           r_No.号类 || '</HL>' || '<FSD>' || r_No.分时段 || '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' ||
                           '<FWMC>' || r_No.排班 || '</FWMC>' || '</HB>';
              v_Xmlmain := v_Xmlmain || c_Xmlmain;
            Else
              c_Xmlmain := '<HB>' || '<CZJLID>' || r_No.记录id || '</CZJLID>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' ||
                           r_No.医生id || '</YSID>' || '<YS>' || r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id ||
                           '</KSID>' || '<KSMC>' || r_No.科室名称 || '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' ||
                           r_No.项目id || '</XMID>' || '<XMMC>' || r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 ||
                           '</YGHS>' || '<SYHS>' || v_剩余数量 || '</SYHS>' || '<PRICE>' || n_合计金额 || '</PRICE>' || '<HL>' ||
                           r_No.号类 || '</HL>' || '<FSD>' || r_No.分时段 || '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' ||
                           '<FWMC>' || r_No.排班 || '</FWMC>' || v_Temp || '</HB>';
              v_Xmlmain := v_Xmlmain || c_Xmlmain;
            End If;
          End If;
        End If;
      End If;
      n_禁用 := 0;
    End Loop;
  
    --加入替诊号源
    n_合约剩余数量 := 0;
    For r_No In (Select a.科室id, b.号类, c.名称 As 科室名称, a.替诊医生姓名 As 医生姓名, a.替诊医生id As 医生id, d.专业技术职务 As 职称, b.号码,
                        a.Id As 记录id, a.上班时段 As 排班, a.项目id, e.名称 As 项目名称, a.是否序号控制 As 序号控制, a.限号数,
                        Nvl(a.限约数, a.限号数) As 限约数, Nvl(a.已挂数, 0) As 已挂数, Nvl(a.已约数, 0) As 已约数, Nvl(a.其中已接收, 0) As 已接收,
                        a.是否分时段 As 分时段, a.开始时间, a.终止时间, a.预约控制, a.替诊开始时间, a.替诊终止时间, Nvl(b.预约天数, n_预约天数) As 预约天数, a.停诊开始时间,
                        a.停诊终止时间
                 From 临床出诊记录 A, 临床出诊号源 B, 部门表 C, 人员表 D, 收费项目目录 E
                 Where a.出诊日期 = Trunc(d_日期) And a.替诊医生姓名 Is Not Null And a.终止时间 > Sysdate And a.号源id = b.Id And
                       a.项目id = e.Id And a.替诊医生id = d.Id(+) And b.科室id = c.Id And Nvl(a.是否锁定, 0) = 0 And
                       (a.开始时间 < Nvl(a.停诊开始时间, a.终止时间) Or a.终止时间 > Nvl(a.停诊终止时间, a.开始时间) Or Exists
                        (Select 1
                         From 临床出诊序号控制 C, 临床出诊记录 D
                         Where d.Id = a.Id And c.记录id = d.Id And Nvl(c.是否停诊, 0) = 0 And d.是否序号控制 = 1 And d.是否分时段 = 1 And
                               c.开始时间 <> c.终止时间)) And Nvl(a.是否发布, 0) = 1 And
                       a.开始时间 > Trunc(To_Date(v_启用时间, 'yyyy-mm-dd hh24:mi:ss')) And
                       Decode(Nvl(n_科室id, 0), 0, 0, b.科室id) = Nvl(n_科室id, 0) And
                       Decode(Nvl(n_医生id, 0), 0, 0, a.医生id) = Nvl(n_医生id, 0) And
                       Decode(Nvl(v_医生姓名, '-'), '-', '-', a.医生姓名) = Nvl(v_医生姓名, '-')) Loop
      v_Temp := '';
      If Sysdate + Nvl(r_No.预约天数, n_预约天数) >= d_日期 Then
        If Trunc(d_日期) = Trunc(Sysdate) Then
          --当天挂号
          If v_合作单位 Is Null Then
            --未传入合作单位
            n_已挂数   := r_No.已挂数;
            v_剩余数量 := r_No.限号数 - Nvl(r_No.已挂数, 0);
            If r_No.分时段 = 1 And r_No.序号控制 = 1 Then
              --分时段
              v_Temp     := '<SPANLIST>';
              n_Exists   := 0;
              n_时段总数 := 0;
              n_时段剩余 := 0;
              d_时段开始 := Null;
              d_时段结束 := Null;
              Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
              For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                             From 临床出诊序号控制
                             Where 记录id = r_No.记录id And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And
                                   Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1) Loop
                If Nvl(n_时间间隔, 0) <> 0 Then
                  If d_时段开始 Is Null Then
                    d_时段开始 := r_Time.开始时间;
                    d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                    n_时段总数 := n_时段总数 + 1;
                    If d_加号时间 < d_时段结束 Then
                      d_时段结束 := d_加号时间;
                    End If;
                  Else
                    If r_Time.开始时间 >= d_时段结束 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                    To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                    '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                      n_时段总数 := 1;
                      n_时段剩余 := 0;
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      n_时段总数 := n_时段总数 + 1;
                    End If;
                  End If;
                End If;
                If r_Time.开始时间 > Sysdate Then
                  If Nvl(n_时间间隔, 0) = 0 Then
                    v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                              To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                    If Nvl(r_Time.挂号状态, 0) = 0 Then
                      v_Temp   := v_Temp || '<SL>1</SL></SPAN>';
                      n_Exists := n_Exists + 1;
                    Else
                      v_Temp := v_Temp || '<SL>0</SL></SPAN>';
                    End If;
                  Else
                    If Nvl(r_Time.挂号状态, 0) = 0 Then
                      n_Exists   := n_Exists + 1;
                      n_时段剩余 := n_时段剩余 + 1;
                    End If;
                  End If;
                End If;
              End Loop;
              If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                              To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                              n_时段剩余 || '</SL>' || '</SPAN>';
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
              End If;
              If n_Exists < To_Number(v_剩余数量) And r_No.替诊开始时间 Is Null Then
                v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_加号时间, 'hh24:mi:ss') || '-' || '</SJD><SL>' ||
                          To_Number(v_剩余数量 - n_Exists) || '</SL></SPAN>';
              End If;
              v_Temp := v_Temp || '</SPANLIST>';
            End If;
          Else
            --传入合作单位
            n_已挂数 := r_No.已挂数;
            Begin
              Select 控制方式
              Into n_合约模式
              From 临床出诊挂号控制记录
              Where 记录id = r_No.记录id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1 And Rownum < 2;
            Exception
              When Others Then
                n_合约模式 := 4;
            End;
            If n_合约模式 = 0 Then
              n_禁用 := 1;
            End If;
            If n_合约模式 = 1 Or n_合约模式 = 2 Then
              Select 数量
              Into n_合约总数量
              From 临床出诊挂号控制记录
              Where 记录id = r_No.记录id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1;
              If n_合约模式 = 1 Then
                n_合约总数量 := Round(r_No.限号数 * n_合约总数量 / 100);
              End If;
              Select Count(1)
              Into n_合约已挂数
              From 病人挂号记录
              Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                    Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
              n_合约剩余数量 := n_合约总数量 - n_合约已挂数;
              If r_No.限号数 - Nvl(r_No.已挂数, 0) < n_合约剩余数量 Then
                v_剩余数量 := r_No.限号数 - Nvl(r_No.已挂数, 0);
              Else
                v_剩余数量 := n_合约剩余数量;
              End If;
              If r_No.分时段 = 1 And r_No.序号控制 = 1 Then
                --分时段
                v_Temp   := '<SPANLIST>';
                n_Exists := 0;
                Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
                For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                               From 临床出诊序号控制
                               Where 记录id = r_No.记录id And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And
                                     Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1) Loop
                
                  If Nvl(n_时间间隔, 0) <> 0 Then
                    If d_时段开始 Is Null Then
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                      n_时段总数 := n_时段总数 + 1;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      If r_Time.开始时间 >= d_时段结束 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 1;
                        n_时段剩余 := 0;
                        d_时段开始 := r_Time.开始时间;
                        d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                        If d_加号时间 < d_时段结束 Then
                          d_时段结束 := d_加号时间;
                        End If;
                      Else
                        n_时段总数 := n_时段总数 + 1;
                      End If;
                    End If;
                  End If;
                  If r_Time.开始时间 > Sysdate Then
                    If Nvl(n_时间间隔, 0) = 0 Then
                      v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                      If Nvl(r_Time.挂号状态, 0) = 0 Then
                        v_Temp   := v_Temp || '<SL>1</SL></SPAN>';
                        n_Exists := n_Exists + 1;
                      Else
                        v_Temp := v_Temp || '<SL>0</SL></SPAN>';
                      End If;
                    Else
                      If Nvl(r_Time.挂号状态, 0) = 0 Then
                        n_Exists   := n_Exists + 1;
                        n_时段剩余 := n_时段剩余 + 1;
                      End If;
                    End If;
                  End If;
                End Loop;
                If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                  v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                                n_时段剩余 || '</SL>' || '</SPAN>';
                  n_时段总数 := 0;
                  n_时段剩余 := 0;
                  d_时段开始 := Null;
                  d_时段结束 := Null;
                End If;
                If n_Exists < To_Number(v_剩余数量) And r_No.替诊开始时间 Is Null Then
                  v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_加号时间, 'hh24:mi:ss') || '-' || '</SJD><SL>' ||
                            To_Number(v_剩余数量 - n_Exists) || '</SL></SPAN>';
                End If;
                v_Temp := v_Temp || '</SPANLIST>';
              End If;
            End If;
            If n_合约模式 = 3 Then
              If n_序号控制 = 0 Then
                n_已挂数   := r_No.已挂数;
                v_剩余数量 := r_No.限号数 - Nvl(r_No.已挂数, 0);
              Else
                n_已挂数   := 0;
                v_剩余数量 := 0;
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
                For r_合作 In (Select 序号
                             From 临床出诊挂号控制记录
                             Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位) Loop
                  Begin
                    Select 1, 开始时间, 终止时间
                    Into n_Exists, d_开始时间, d_终止时间
                    From 临床出诊序号控制
                    Where 序号 = r_合作.序号 And Nvl(挂号状态, 0) = 0 And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And
                          Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1;
                  Exception
                    When Others Then
                      n_Exists := 0;
                  End;
                  If n_Exists = 1 Then
                    v_剩余数量 := v_剩余数量 + 1;
                    If r_No.分时段 = 1 Then
                    
                      If Nvl(n_时间间隔, 0) <> 0 Then
                        If d_时段开始 Is Null Then
                          d_时段开始 := d_开始时间;
                          d_时段结束 := d_开始时间 + 1 / 24 / 60 * n_时间间隔;
                          n_时段总数 := n_时段总数 + 1;
                        Else
                          If d_开始时间 >= d_时段结束 Then
                            v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                          To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                          '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                            n_时段总数 := 1;
                            n_时段剩余 := 0;
                            d_时段开始 := d_开始时间;
                            d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                          Else
                            n_时段总数 := n_时段总数 + 1;
                          End If;
                        End If;
                      End If;
                      If d_开始时间 > Sysdate Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(d_终止时间, 'hh24:mi:ss') || '</SJD><SL>1</SL></SPAN>';
                        Else
                          n_时段剩余 := n_时段剩余 + 1;
                        End If;
                      End If;
                    End If;
                  Else
                    n_已挂数 := n_已挂数 + 1;
                  End If;
                End Loop;
                If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                  v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                                n_时段剩余 || '</SL>' || '</SPAN>';
                  n_时段总数 := 0;
                  n_时段剩余 := 0;
                  d_时段开始 := Null;
                  d_时段结束 := Null;
                End If;
                If v_Temp Is Not Null Then
                  v_Temp := '<SPANLIST>' || v_Temp || '</SPANLIST>';
                End If;
              End If;
            End If;
            If n_合约模式 = 4 Then
              n_已挂数   := r_No.已挂数;
              v_剩余数量 := r_No.限号数 - Nvl(r_No.已挂数, 0);
              If r_No.分时段 = 1 And r_No.序号控制 = 1 Then
                --分时段
                v_Temp   := '<SPANLIST>';
                n_Exists := 0;
                Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
                For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                               From 临床出诊序号控制
                               Where 记录id = r_No.记录id And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And
                                     Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1) Loop
                
                  If Nvl(n_时间间隔, 0) <> 0 Then
                    If d_时段开始 Is Null Then
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                      n_时段总数 := n_时段总数 + 1;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      If r_Time.开始时间 >= d_时段结束 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 1;
                        n_时段剩余 := 0;
                        d_时段开始 := r_Time.开始时间;
                        d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                        If d_加号时间 < d_时段结束 Then
                          d_时段结束 := d_加号时间;
                        End If;
                      Else
                        n_时段总数 := n_时段总数 + 1;
                      End If;
                    End If;
                  End If;
                  If r_Time.开始时间 > Sysdate Then
                    If Nvl(n_时间间隔, 0) = 0 Then
                      v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                      If Nvl(r_Time.挂号状态, 0) = 0 Then
                        v_Temp   := v_Temp || '<SL>1</SL></SPAN>';
                        n_Exists := n_Exists + 1;
                      Else
                        v_Temp := v_Temp || '<SL>0</SL></SPAN>';
                      End If;
                    Else
                      If Nvl(r_Time.挂号状态, 0) = 0 Then
                        n_Exists   := n_Exists + 1;
                        n_时段剩余 := n_时段剩余 + 1;
                      End If;
                    End If;
                  End If;
                End Loop;
                If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                  v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                                n_时段剩余 || '</SL>' || '</SPAN>';
                  n_时段总数 := 0;
                  n_时段剩余 := 0;
                  d_时段开始 := Null;
                  d_时段结束 := Null;
                End If;
                If n_Exists < To_Number(v_剩余数量) And r_No.替诊开始时间 Is Null Then
                
                  v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_加号时间, 'hh24:mi:ss') || '-' || '</SJD><SL>' ||
                            To_Number(v_剩余数量 - n_Exists) || '</SL></SPAN>';
                End If;
                v_Temp := v_Temp || '</SPANLIST>';
              End If;
            End If;
          End If;
        Else
          --预约挂号
          If r_No.预约控制 = 1 Then
            n_禁用 := 1;
          Else
            --不限制预约
            If v_合作单位 Is Null Then
              If r_No.分时段 = 0 Then
                n_已挂数   := r_No.已约数;
                v_剩余数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
              Else
                --分时段
                n_已挂数   := 0;
                v_剩余数量 := 0;
                v_Temp     := '<SPANLIST>';
                If r_No.序号控制 = 0 Then
                  --非序号控制分时段预约
                  n_时段总数 := 0;
                  n_时段剩余 := 0;
                  d_时段开始 := Null;
                  d_时段结束 := Null;
                  Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                  For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态, 数量
                                 From 临床出诊序号控制
                                 Where 记录id = r_No.记录id And 预约顺序号 Is Null And 是否预约 = 1 And
                                       开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) And
                                       开始时间 Not Between Nvl(r_No.停诊开始时间, Sysdate) And Nvl(r_No.停诊终止时间, Sysdate - 1)) Loop
                    If Nvl(n_时间间隔, 0) <> 0 Then
                      If d_时段开始 Is Null Then
                        d_时段开始 := r_Time.开始时间;
                        d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                        n_时段总数 := n_时段总数 + r_Time.数量;
                        If d_加号时间 < d_时段结束 Then
                          d_时段结束 := d_加号时间;
                        End If;
                      Else
                        If r_Time.开始时间 >= d_时段结束 Then
                          v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                        To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                        '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                          n_时段总数 := r_Time.数量;
                          n_时段剩余 := 0;
                          d_时段开始 := r_Time.开始时间;
                          d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                          If d_加号时间 < d_时段结束 Then
                            d_时段结束 := d_加号时间;
                          End If;
                        Else
                          n_时段总数 := n_时段总数 + r_Time.数量;
                        End If;
                      End If;
                    End If;
                    Select Count(1)
                    Into n_时段已挂
                    From 临床出诊序号控制
                    Where 预约顺序号 Is Not Null And Nvl(挂号状态, 0) <> 0;
                    If r_Time.开始时间 > Sysdate Then
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                        v_Temp := v_Temp || '<SL>' || r_Time.数量 - n_时段已挂 || '</SL></SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + (r_Time.数量 - n_时段已挂);
                      End If;
                      n_已挂数   := n_已挂数 + n_时段已挂;
                      v_剩余数量 := v_剩余数量 + (r_Time.数量 - n_时段已挂);
                    End If;
                  End Loop;
                  If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                    v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                  To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                  '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                    n_时段总数 := 0;
                    n_时段剩余 := 0;
                    d_时段开始 := Null;
                    d_时段结束 := Null;
                  End If;
                Else
                  n_时段总数 := 0;
                  n_时段剩余 := 0;
                  d_时段开始 := Null;
                  d_时段结束 := Null;
                  Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                  For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                                 From 临床出诊序号控制
                                 Where 记录id = r_No.记录id And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And
                                       Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1) Loop
                    If Nvl(n_时间间隔, 0) <> 0 Then
                      If d_时段开始 Is Null Then
                        d_时段开始 := r_Time.开始时间;
                        d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                        n_时段总数 := n_时段总数 + 1;
                        If d_加号时间 < d_时段结束 Then
                          d_时段结束 := d_加号时间;
                        End If;
                      Else
                        If r_Time.开始时间 >= d_时段结束 Then
                          v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                        To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                        '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                          n_时段总数 := 1;
                          n_时段剩余 := 0;
                          d_时段开始 := r_Time.开始时间;
                          d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                          If d_加号时间 < d_时段结束 Then
                            d_时段结束 := d_加号时间;
                          End If;
                        Else
                          n_时段总数 := n_时段总数 + 1;
                        End If;
                      End If;
                    End If;
                    If r_Time.开始时间 > Sysdate Then
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                        If Nvl(r_Time.挂号状态, 0) = 0 Then
                          v_Temp     := v_Temp || '<SL>1</SL></SPAN>';
                          v_剩余数量 := v_剩余数量 + 1;
                        Else
                          v_Temp   := v_Temp || '<SL>0</SL></SPAN>';
                          n_已挂数 := n_已挂数 + 1;
                        End If;
                      Else
                        If Nvl(r_Time.挂号状态, 0) = 0 Then
                          n_时段剩余 := n_时段剩余 + 1;
                          v_剩余数量 := v_剩余数量 + 1;
                        Else
                          n_已挂数 := n_已挂数 + 1;
                        End If;
                      End If;
                    End If;
                  End Loop;
                  If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                    v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                  To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                  '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                    n_时段总数 := 0;
                    n_时段剩余 := 0;
                    d_时段开始 := Null;
                    d_时段结束 := Null;
                  End If;
                End If;
                v_Temp := v_Temp || '</SPANLIST>';
              End If;
            Else
              --合作单位预约挂号
              If r_No.预约控制 = 2 Then
                n_禁用 := 1;
              Else
                Begin
                  Select 控制方式
                  Into n_合约模式
                  From 临床出诊挂号控制记录
                  Where 记录id = r_No.记录id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1 And Rownum < 2;
                Exception
                  When Others Then
                    n_合约模式 := 4;
                End;
                If n_合约模式 = 0 Then
                  n_禁用 := 1;
                End If;
                If n_合约模式 = 1 Or n_合约模式 = 2 Then
                  Select 数量
                  Into n_合约总数量
                  From 临床出诊挂号控制记录
                  Where 记录id = r_No.记录id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1;
                  If n_合约模式 = 1 Then
                    n_合约总数量 := Round(r_No.限号数 * n_合约总数量 / 100);
                  End If;
                  Select Count(1)
                  Into n_合约已挂数
                  From 病人挂号记录
                  Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                        Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
                  n_合约剩余数量 := n_合约总数量 - n_合约已挂数;
                  If Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0) < n_合约剩余数量 Then
                    v_剩余数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
                  Else
                    v_剩余数量 := n_合约剩余数量;
                  End If;
                  If r_No.分时段 = 1 Then
                    v_Temp := '<SPANLIST>';
                    If r_No.序号控制 = 1 Then
                      --分时段,序号控制
                      n_Exists   := 0;
                      n_时段总数 := 0;
                      n_时段剩余 := 0;
                      d_时段开始 := Null;
                      d_时段结束 := Null;
                      Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                      For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                                     From 临床出诊序号控制
                                     Where 记录id = r_No.记录id And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And
                                           Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1) Loop
                      
                        If Nvl(n_时间间隔, 0) <> 0 Then
                          If d_时段开始 Is Null Then
                            d_时段开始 := r_Time.开始时间;
                            d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                            n_时段总数 := n_时段总数 + 1;
                            If d_加号时间 < d_时段结束 Then
                              d_时段结束 := d_加号时间;
                            End If;
                          Else
                            If r_Time.开始时间 >= d_时段结束 Then
                              v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                            To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 ||
                                            '</GHZS>' || '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                              n_时段总数 := 1;
                              n_时段剩余 := 0;
                              d_时段开始 := r_Time.开始时间;
                              d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                              If d_加号时间 < d_时段结束 Then
                                d_时段结束 := d_加号时间;
                              End If;
                            Else
                              n_时段总数 := n_时段总数 + 1;
                            End If;
                          End If;
                        End If;
                        If r_Time.开始时间 > Sysdate Then
                          If Nvl(n_时间间隔, 0) = 0 Then
                            v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                            If Nvl(r_Time.挂号状态, 0) = 0 Then
                              v_Temp   := v_Temp || '<SL>1</SL></SPAN>';
                              n_Exists := n_Exists + 1;
                            Else
                              v_Temp := v_Temp || '<SL>0</SL></SPAN>';
                            End If;
                          Else
                            If Nvl(r_Time.挂号状态, 0) = 0 Then
                              n_时段剩余 := n_时段剩余 + 1;
                              n_Exists   := n_Exists + 1;
                            End If;
                          End If;
                        End If;
                      End Loop;
                      If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 0;
                        n_时段剩余 := 0;
                        d_时段开始 := Null;
                        d_时段结束 := Null;
                      End If;
                      If n_Exists < To_Number(v_剩余数量) Then
                        v_剩余数量 := n_Exists;
                      End If;
                    Else
                      --分时段,非序号控制
                      n_Exists   := 0;
                      n_时段总数 := 0;
                      n_时段剩余 := 0;
                      d_时段开始 := Null;
                      d_时段结束 := Null;
                      Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                      For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态, 数量
                                     From 临床出诊序号控制
                                     Where 记录id = r_No.记录id And 预约顺序号 Is Null And 是否预约 = 1 And
                                           开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) And
                                           开始时间 Not Between Nvl(r_No.停诊开始时间, Sysdate) And Nvl(r_No.停诊终止时间, Sysdate - 1)) Loop
                        If Nvl(n_时间间隔, 0) <> 0 Then
                          If d_时段开始 Is Null Then
                            d_时段开始 := r_Time.开始时间;
                            d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                            n_时段总数 := n_时段总数 + r_Time.数量;
                            If d_加号时间 < d_时段结束 Then
                              d_时段结束 := d_加号时间;
                            End If;
                          Else
                            If r_Time.开始时间 >= d_时段结束 Then
                              v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                            To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 ||
                                            '</GHZS>' || '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                              n_时段总数 := r_Time.数量;
                              n_时段剩余 := 0;
                              d_时段开始 := r_Time.开始时间;
                              d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                              If d_加号时间 < d_时段结束 Then
                                d_时段结束 := d_加号时间;
                              End If;
                            Else
                              n_时段总数 := n_时段总数 + r_Time.数量;
                            End If;
                          End If;
                        End If;
                        Select Count(1)
                        Into n_时段已挂
                        From 临床出诊序号控制
                        Where 预约顺序号 Is Not Null And Nvl(挂号状态, 0) <> 0;
                        If r_Time.开始时间 > Sysdate Then
                          If Nvl(n_时间间隔, 0) = 0 Then
                            v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                            v_Temp := v_Temp || '<SL>' || r_Time.数量 - n_时段已挂 || '</SL></SPAN>';
                          Else
                            n_时段剩余 := n_时段剩余 + (r_Time.数量 - n_时段已挂);
                          End If;
                          n_Exists := n_Exists + (r_Time.数量 - n_时段已挂);
                        
                        End If;
                      End Loop;
                      If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 0;
                        n_时段剩余 := 0;
                        d_时段开始 := Null;
                        d_时段结束 := Null;
                      End If;
                      If n_Exists < To_Number(v_剩余数量) Then
                        v_剩余数量 := n_Exists;
                      End If;
                    End If;
                    v_Temp := v_Temp || '</SPANLIST>';
                  End If;
                  n_已挂数 := r_No.已约数;
                End If;
                If n_合约模式 = 3 Then
                  If r_No.分时段 = 0 Then
                    If r_No.序号控制 = 0 Then
                      n_禁用 := 1;
                    Else
                      n_已挂数   := 0;
                      v_剩余数量 := 0;
                      For r_合作 In (Select 序号
                                   From 临床出诊挂号控制记录
                                   Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位) Loop
                        Select Nvl(Max(1), 0)
                        Into n_Exists
                        From 临床出诊序号控制
                        Where 记录id = r_No.记录id And 序号 = r_合作.序号 And 是否预约 = 1 And Nvl(挂号状态, 0) = 0 And
                              开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) And
                              Nvl(是否停诊, 0) <> 1;
                        If n_Exists = 1 Then
                          v_剩余数量 := v_剩余数量 + 1;
                        Else
                          n_已挂数 := n_已挂数 + 1;
                        End If;
                      End Loop;
                      If Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0) < v_剩余数量 Then
                        v_剩余数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
                      End If;
                    End If;
                  Else
                    If r_No.序号控制 = 0 Then
                      --合作单位,分时段,非序号控制
                      n_已挂数   := 0;
                      v_剩余数量 := 0;
                      n_时段总数 := 0;
                      n_时段剩余 := 0;
                      d_时段开始 := Null;
                      d_时段结束 := Null;
                      v_Temp     := '<SPANLIST>';
                      For r_合作 In (Select 序号, 数量
                                   From 临床出诊挂号控制记录
                                   Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位) Loop
                        Begin
                          Select Count(1), Max(开始时间), Max(终止时间)
                          Into n_时段已挂, d_开始时间, d_终止时间
                          From 临床出诊序号控制
                          Where 记录id = r_No.记录id And 预约顺序号 Is Not Null And Nvl(挂号状态, 0) <> 0 And 序号 = r_合作.序号 And
                                开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1);
                        
                          If Nvl(n_时间间隔, 0) <> 0 Then
                            If d_时段开始 Is Null Then
                              d_时段开始 := d_开始时间;
                              d_时段结束 := d_开始时间 + 1 / 24 / 60 * n_时间间隔;
                              n_时段总数 := n_时段总数 + r_合作.数量;
                            Else
                              If d_开始时间 >= d_时段结束 Then
                                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                              To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 ||
                                              '</GHZS>' || '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                                n_时段总数 := r_合作.数量;
                                n_时段剩余 := 0;
                                d_时段开始 := d_开始时间;
                                d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                              Else
                                n_时段总数 := n_时段总数 + r_合作.数量;
                              End If;
                            End If;
                          End If;
                          n_已挂数 := n_已挂数 + n_时段已挂;
                          If d_开始时间 > Sysdate Then
                            If Nvl(n_时间间隔, 0) = 0 Then
                              v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(d_终止时间, 'hh24:mi:ss') || '</SJD>';
                              v_Temp := v_Temp || '<SL>' || r_合作.数量 - n_时段已挂 || '</SL></SPAN>';
                            Else
                              n_时段剩余 := n_时段剩余 + r_合作.数量 - n_时段已挂;
                            End If;
                            v_剩余数量 := v_剩余数量 + r_合作.数量 - n_时段已挂;
                          End If;
                        Exception
                          When Others Then
                            Null;
                        End;
                      End Loop;
                      If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 0;
                        n_时段剩余 := 0;
                        d_时段开始 := Null;
                        d_时段结束 := Null;
                      End If;
                      v_Temp := v_Temp || '</SPANLIST>';
                    Else
                      n_已挂数   := 0;
                      v_剩余数量 := 0;
                      n_时段总数 := 0;
                      n_时段剩余 := 0;
                      d_时段开始 := Null;
                      d_时段结束 := Null;
                      v_Temp     := '<SPANLIST>';
                      For r_合作 In (Select 序号
                                   From 临床出诊挂号控制记录
                                   Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位) Loop
                        Begin
                          Select 1, 开始时间, 终止时间
                          Into n_Exists, d_开始时间, d_终止时间
                          From 临床出诊序号控制
                          Where 记录id = r_No.记录id And Nvl(挂号状态, 0) = 0 And 序号 = r_合作.序号 And
                                开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) And
                                Nvl(是否停诊, 0) <> 1;
                        Exception
                          When Others Then
                            n_Exists := 0;
                        End;
                      
                        If Nvl(n_时间间隔, 0) <> 0 Then
                          If d_时段开始 Is Null Then
                            d_时段开始 := d_开始时间;
                            d_时段结束 := d_开始时间 + 1 / 24 / 60 * n_时间间隔;
                            n_时段总数 := n_时段总数 + 1;
                          Else
                            If d_开始时间 >= d_时段结束 Then
                              v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                            To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 ||
                                            '</GHZS>' || '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                              n_时段总数 := 1;
                              n_时段剩余 := 0;
                              d_时段开始 := d_开始时间;
                              d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                            Else
                              n_时段总数 := n_时段总数 + 1;
                            End If;
                          End If;
                        End If;
                        If d_开始时间 > Sysdate Then
                          If n_Exists = 1 Then
                            v_剩余数量 := v_剩余数量 + 1;
                            If Nvl(n_时间间隔, 0) = 0 Then
                              v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(d_终止时间, 'hh24:mi:ss') || '</SJD>';
                              v_Temp := v_Temp || '<SL>' || 1 || '</SL></SPAN>';
                            Else
                              n_时段剩余 := n_时段剩余 + 1;
                            End If;
                          Else
                            If Nvl(n_时间间隔, 0) = 0 Then
                              v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(d_终止时间, 'hh24:mi:ss') || '</SJD>';
                              v_Temp := v_Temp || '<SL>' || 0 || '</SL></SPAN>';
                            End If;
                            n_已挂数 := n_已挂数 + 1;
                          End If;
                        End If;
                      End Loop;
                      If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 0;
                        n_时段剩余 := 0;
                        d_时段开始 := Null;
                        d_时段结束 := Null;
                      End If;
                    End If;
                  End If;
                End If;
                If n_合约模式 = 4 Then
                  If r_No.分时段 = 0 Then
                    n_已挂数   := r_No.已约数;
                    v_剩余数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
                  Else
                    --分时段
                    n_已挂数   := 0;
                    v_剩余数量 := 0;
                    n_时段总数 := 0;
                    n_时段剩余 := 0;
                    d_时段开始 := Null;
                    d_时段结束 := Null;
                    v_Temp     := '<SPANLIST>';
                    If r_No.序号控制 = 0 Then
                      --非序号控制分时段预约
                      Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                      For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态, 数量
                                     From 临床出诊序号控制
                                     Where 记录id = r_No.记录id And 预约顺序号 Is Null And 是否预约 = 1 And
                                           开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) And
                                           开始时间 Not Between Nvl(r_No.停诊开始时间, Sysdate) And Nvl(r_No.停诊终止时间, Sysdate - 1)) Loop
                      
                        If Nvl(n_时间间隔, 0) <> 0 Then
                          If d_时段开始 Is Null Then
                            d_时段开始 := r_Time.开始时间;
                            d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                            n_时段总数 := n_时段总数 + r_Time.数量;
                            If d_加号时间 < d_时段结束 Then
                              d_时段结束 := d_加号时间;
                            End If;
                          Else
                            If r_Time.开始时间 >= d_时段结束 Then
                              v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                            To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 ||
                                            '</GHZS>' || '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                              n_时段总数 := r_Time.数量;
                              n_时段剩余 := 0;
                              d_时段开始 := r_Time.开始时间;
                              d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                              If d_加号时间 < d_时段结束 Then
                                d_时段结束 := d_加号时间;
                              End If;
                            Else
                              n_时段总数 := n_时段总数 + r_Time.数量;
                            End If;
                          End If;
                        End If;
                        Select Count(1)
                        Into n_时段已挂
                        From 临床出诊序号控制
                        Where 预约顺序号 Is Not Null And Nvl(挂号状态, 0) <> 0;
                        If r_Time.开始时间 > Sysdate Then
                          If Nvl(n_时间间隔, 0) = 0 Then
                            v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                            v_Temp := v_Temp || '<SL>' || r_Time.数量 - n_时段已挂 || '</SL></SPAN>';
                          Else
                            n_时段剩余 := n_时段剩余 + (r_Time.数量 - n_时段已挂);
                          End If;
                          n_已挂数   := n_已挂数 + n_时段已挂;
                          v_剩余数量 := v_剩余数量 + (r_Time.数量 - n_时段已挂);
                        End If;
                      End Loop;
                      If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 0;
                        n_时段剩余 := 0;
                        d_时段开始 := Null;
                        d_时段结束 := Null;
                      End If;
                    Else
                      n_时段总数 := 0;
                      n_时段剩余 := 0;
                      d_时段开始 := Null;
                      d_时段结束 := Null;
                      Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                      For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                                     From 临床出诊序号控制
                                     Where 记录id = r_No.记录id And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And
                                           Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1) Loop
                      
                        If Nvl(n_时间间隔, 0) <> 0 Then
                          If d_时段开始 Is Null Then
                            d_时段开始 := r_Time.开始时间;
                            d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                            n_时段总数 := n_时段总数 + 1;
                            If d_加号时间 < d_时段结束 Then
                              d_时段结束 := d_加号时间;
                            End If;
                          Else
                            If r_Time.开始时间 >= d_时段结束 Then
                              v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                            To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 ||
                                            '</GHZS>' || '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                              n_时段总数 := 1;
                              n_时段剩余 := 0;
                              d_时段开始 := r_Time.开始时间;
                              d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                              If d_加号时间 < d_时段结束 Then
                                d_时段结束 := d_加号时间;
                              End If;
                            Else
                              n_时段总数 := n_时段总数 + 1;
                            End If;
                          End If;
                        End If;
                        If r_Time.开始时间 > Sysdate Then
                          If Nvl(n_时间间隔, 0) = 0 Then
                            v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                            If Nvl(r_Time.挂号状态, 0) = 0 Then
                              v_Temp     := v_Temp || '<SL>1</SL></SPAN>';
                              v_剩余数量 := v_剩余数量 + 1;
                            Else
                              v_Temp   := v_Temp || '<SL>0</SL></SPAN>';
                              n_已挂数 := n_已挂数 + 1;
                            End If;
                          Else
                            If Nvl(r_Time.挂号状态, 0) = 0 Then
                              n_时段剩余 := n_时段剩余 + 1;
                              v_剩余数量 := v_剩余数量 + 1;
                            Else
                              n_已挂数 := n_已挂数 + 1;
                            End If;
                          End If;
                        End If;
                      End Loop;
                      If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 0;
                        n_时段剩余 := 0;
                        d_时段开始 := Null;
                        d_时段结束 := Null;
                      End If;
                    End If;
                    v_Temp := v_Temp || '</SPANLIST>';
                  End If;
                End If;
              End If;
            End If;
          End If;
        End If;
      
        If Not (r_No.分时段 = 1 And r_No.序号控制 = 1) Then
          If d_日期 Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) Then
            n_禁用 := 1;
          End If;
          If d_日期 Between Nvl(r_No.停诊开始时间, Sysdate) And Nvl(r_No.停诊终止时间, Sysdate - 1) Then
            n_禁用 := 1;
          End If;
        End If;
      
        If Nvl(n_禁用, 0) = 0 Then
          n_合计金额 := 0;
          For r_Fee In (Select b.现价, a.从项数次
                        From 收费从属项目 A, 收费价目 B
                        Where a.主项id = r_No.项目id And a.从项id = b.收费细目id And Sysdate Between b.执行日期 And
                              Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                        Union
                        Select b.现价, 1 As 从项数次
                        From 收费项目目录 A, 收费价目 B
                        Where a.Id = b.收费细目id And a.Id = r_No.项目id And Sysdate Between b.执行日期 And
                              Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))) Loop
            n_合计金额 := n_合计金额 + r_Fee.现价 * r_Fee.从项数次;
          End Loop;
          v_时间段 := To_Char(r_No.替诊开始时间, 'HH24:MI') || '-' || To_Char(r_No.替诊终止时间, 'HH24:MI');
          If Trunc(Sysdate) = Trunc(d_日期) Then
            c_Xmlmain := '<HB>' || '<CZJLID>' || r_No.记录id || '</CZJLID>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' ||
                         r_No.医生id || '</YSID>' || '<YS>' || r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id || '</KSID>' ||
                         '<KSMC>' || r_No.科室名称 || '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' || r_No.项目id ||
                         '</XMID>' || '<XMMC>' || r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 || '</YGHS>' || '<SYHS>' ||
                         v_剩余数量 || '</SYHS>' || '<PRICE>' || n_合计金额 || '</PRICE>' || '<HL>' || r_No.号类 || '</HL>' ||
                         '<FSD>' || r_No.分时段 || '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' || '<FWMC>' || r_No.排班 ||
                         '</FWMC>' || v_Temp || '</HB>';
            v_Xmlmain := v_Xmlmain || c_Xmlmain;
          Else
            If r_No.已约数 >= r_No.限约数 Then
              c_Xmlmain := '<HB>' || '<CZJLID>' || r_No.记录id || '</CZJLID>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' ||
                           r_No.医生id || '</YSID>' || '<YS>' || r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id ||
                           '</KSID>' || '<KSMC>' || r_No.科室名称 || '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' ||
                           r_No.项目id || '</XMID>' || '<XMMC>' || r_No.项目名称 || '</XMMC>' || '<YGHS>' || r_No.已约数 ||
                           '</YGHS>' || '<SYHS>' || 0 || '</SYHS>' || '<PRICE>' || n_合计金额 || '</PRICE>' || '<HL>' ||
                           r_No.号类 || '</HL>' || '<FSD>' || r_No.分时段 || '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' ||
                           '<FWMC>' || r_No.排班 || '</FWMC>' || '</HB>';
              v_Xmlmain := v_Xmlmain || c_Xmlmain;
            Else
              c_Xmlmain := '<HB>' || '<CZJLID>' || r_No.记录id || '</CZJLID>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' ||
                           r_No.医生id || '</YSID>' || '<YS>' || r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id ||
                           '</KSID>' || '<KSMC>' || r_No.科室名称 || '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' ||
                           r_No.项目id || '</XMID>' || '<XMMC>' || r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 ||
                           '</YGHS>' || '<SYHS>' || v_剩余数量 || '</SYHS>' || '<PRICE>' || n_合计金额 || '</PRICE>' || '<HL>' ||
                           r_No.号类 || '</HL>' || '<FSD>' || r_No.分时段 || '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' ||
                           '<FWMC>' || r_No.排班 || '</FWMC>' || v_Temp || '</HB>';
              v_Xmlmain := v_Xmlmain || c_Xmlmain;
            End If;
          End If;
        End If;
      End If;
      n_禁用 := 0;
    End Loop;
    v_Xmlmain := '<GROUP>' || '<RQ>' || To_Char(d_日期, 'yyyy-mm-dd') || '</RQ>' || '<HBLIST>' || v_Xmlmain ||
                 '</HBLIST>' || '</GROUP>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Xmlmain)) Into x_Templet From Dual;
  End If;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getnolist;
/

--103348:梁唐彬,2016-12-05,执行完成自动发料
Create Or Replace Procedure Zl_门诊医嘱执行_Finish
(
  医嘱id_In     病人医嘱执行.医嘱id%Type,
  发送号_In     病人医嘱执行.发送号%Type,
  单独执行_In   Number,
  操作员编号_In 人员表.编号%Type,
  操作员姓名_In 人员表.姓名%Type,
  组id_In       病人医嘱执行.医嘱id%Type,
  诊疗类别_In   病人医嘱记录.诊疗类别%Type,
  执行部门id_In 门诊费用记录.执行部门id%Type
  --参数：医嘱ID_IN=单独执行的医嘱ID，检验组合为显示的检验项目的ID。
  --      单独执行_In=检验医嘱组合是否采用对每个项目分散单独执行的方式
  --执行部门id_In=仅处理指定执行部门的费用，不传或传入0时不限制执行部门
) Is
  --医嘱相关的费用单据
  Cursor c_No Is
    Select a.No || ':' || a.记录性质
    From 病人医嘱附费 A, 病人医嘱记录 B
    Where a.发送号 + 0 = 发送号_In And a.医嘱id = b.Id And b.诊疗类别 = 诊疗类别_In And (b.Id = 组id_In Or b.相关id = 组id_In)
    Union
    Select NO || ':' || 记录性质 From 病人医嘱发送 Where 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In;

  Cursor c_Noone Is
    Select NO || ':' || 记录性质
    From 病人医嘱附费
    Where 发送号 + 0 = 发送号_In And 医嘱id = 医嘱id_In
    Union
    Select NO || ':' || 记录性质 From 病人医嘱发送 Where 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In;

  r_No       t_Strlist;
  r_No_Stuff t_Strlist;
  r_Finish   t_Numlist;
  n_Cnt      Number;
  v_Error    Varchar2(2000);
  Err_Custom Exception;
  v_执行前先结算 Varchar2(500);

  Cursor c_Finish(r_No t_Strlist) Is
    Select a.Id
    From (Select Distinct a.Id, a.收费类别, a.收费细目id
           From 门诊费用记录 A, 病人医嘱记录 B,
                (Select /*+cardinality(f,10)*/
                   Substr(f.Column_Value, 1, Instr(f.Column_Value, ':') - 1) As NO,
                   To_Number(Substr(f.Column_Value, Instr(f.Column_Value, ':') + 1)) As 记录性质
                  From Table(r_No) F) N
           Where a.医嘱序号 = b.Id And (b.Id = 组id_In Or b.相关id = 组id_In) And a.No = n.No And Mod(a.记录性质, 10) = n.记录性质 And
                 a.记录状态 In (0, 1, 3) And a.执行状态 <> 1 And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In)) A, 材料特性 B
    Where a.收费细目id = b.材料id(+) And Not a.收费类别 In ('5', '6', '7') And Not (a.收费类别 = '4' And Nvl(b.跟踪在用, 0) = 1);

  Cursor c_Finishone(r_No t_Strlist) Is
    Select a.Id
    From (Select a.Id, a.收费类别, a.收费细目id
           From 门诊费用记录 A,
                (Select /*+cardinality(f,10)*/
                   Substr(f.Column_Value, 1, Instr(f.Column_Value, ':') - 1) As NO,
                   To_Number(Substr(f.Column_Value, Instr(f.Column_Value, ':') + 1)) As 记录性质
                  From Table(r_No) F) N
           Where a.医嘱序号 = 医嘱id_In And a.No = n.No And Mod(a.记录性质, 10) = n.记录性质 And a.记录状态 In (0, 1, 3) And a.执行状态 <> 1 And
                 (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In)) A, 材料特性 B
    Where a.收费细目id = b.材料id(+) And Not a.收费类别 In ('5', '6', '7') And Not (a.收费类别 = '4' And Nvl(b.跟踪在用, 0) = 1);

  --执行中包含跟踪在用的未发卫料时，根据参数设置是否自动发料
  --卫生材料医嘱目前不存在单独和组合执行的情况
  Cursor c_Stuff(r_No t_Strlist) Is
    Select b.Id, Decode(d.高值材料, 1, a.执行部门id, b.库房id) As 库房id
    From 门诊费用记录 A, 药品收发记录 B, 病人医嘱记录 C, 材料特性 D,
         (Select /*+cardinality(f,10)*/
            Substr(f.Column_Value, 1, Instr(f.Column_Value, ':') - 1) As NO,
            To_Number(Substr(f.Column_Value, Instr(f.Column_Value, ':') + 1)) As 记录性质
           From Table(r_No) F) N
    Where d.材料id = a.收费细目id And a.Id = b.费用id And Mod(b.记录状态, 3) = 1 And b.审核人 Is Null And b.库房id Is Not Null And
          a.收费类别 = '4' And a.记录状态 = 1 And a.医嘱序号 = c.Id And c.诊疗类别 = 诊疗类别_In And (c.Id = 组id_In Or c.相关id = 组id_In) And
          a.No = n.No And Mod(a.记录性质, 10) = n.记录性质 And b.单据 IN(24,25,26) And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In)
    Order By b.库房id, b.药品id;

  --未审核的费用行(包含药品和卫材)
  Cursor c_Verify
  (
    r_No        t_Strlist,
    记帐费用_In Number := 1
  ) Is
    Select Distinct a.No, a.序号
    From 门诊费用记录 A, 病人医嘱记录 C,
         (Select /*+cardinality(f,10)*/
            Substr(f.Column_Value, 1, Instr(f.Column_Value, ':') - 1) As NO,
            To_Number(Substr(f.Column_Value, Instr(f.Column_Value, ':') + 1)) As 记录性质
           From Table(r_No) F) N
    Where Nvl(a.记帐费用, 0) = 记帐费用_In And a.记录状态 = 0 And a.价格父号 Is Null And a.医嘱序号 = c.Id And
          (c.Id = 组id_In Or c.相关id = 组id_In) And a.No = n.No And Mod(a.记录性质, 10) = n.记录性质 And
          (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In)
    Order By NO, 序号;

  Cursor c_Verifyone
  (
    r_No        t_Strlist,
    记帐费用_In Number := 1
  ) Is
    Select a.No, a.序号
    From 门诊费用记录 A,
         (Select /*+cardinality(f,10)*/
            Substr(f.Column_Value, 1, Instr(f.Column_Value, ':') - 1) As NO,
            To_Number(Substr(f.Column_Value, Instr(f.Column_Value, ':') + 1)) As 记录性质
           From Table(r_No) F) N
    Where Nvl(a.记帐费用, 0) = 记帐费用_In And a.记录状态 = 0 And a.价格父号 Is Null And a.医嘱序号 + 0 = 医嘱id_In And a.No = n.No And
          Mod(a.记录性质, 10) = n.记录性质 And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In)
    Order By NO, 序号;

  v_No   病人医嘱发送.No%Type;
  v_序号 Varchar2(1000);

  v_发料号  药品收发记录.汇总发药号%Type;
  v_库房id  药品收发记录.库房id%Type;
  v_收发ids Varchar2(4000);
Begin
  Open c_Noone;
  Fetch c_Noone Bulk Collect
    Into r_No_Stuff;
  Close c_Noone;

  If Nvl(单独执行_In, 0) = 0 Then
    Open c_No;
    Fetch c_No Bulk Collect
      Into r_No;
    Close c_No;
  Else
    r_No := r_No_Stuff;
  End If;

  --主费用可能需要限制医嘱序号
  --不包含药品和跟踪在用的卫材，因为这些都要发放才表示执行
  If Nvl(单独执行_In, 0) = 0 Then
    Open c_Finish(r_No);
    Fetch c_Finish Bulk Collect
      Into r_Finish;
    Close c_Finish;
  Else
    Open c_Finishone(r_No);
    Fetch c_Finishone Bulk Collect
      Into r_Finish;
    Close c_Finishone;
  End If;
  Select Count(1)
  Into n_Cnt
  From 门诊费用记录 A,
       (Select /*+cardinality(f,10)*/
          To_Number(f.Column_Value) As 费用id
         From Table(r_Finish) F) B
  Where a.Id = b.费用id And a.费用状态 = 1;

  If n_Cnt > 0 Then
    v_Error := '当前执行的医嘱对应的费用单据中存在异常单据。';
    Raise Err_Custom;
  End If;

  Select zl_GetSysParameter(163) Into v_执行前先结算 From Dual;
  Forall I In 1 .. r_Finish.Count
    Update 门诊费用记录 Set 执行状态 = 1, 执行时间 = Sysdate, 执行人 = 操作员姓名_In Where ID = r_Finish(I);

  --执行时自动审核对应的记帐划价单费用
  --包含医嘱对应的药品及卫材费用，因为医嘱已执行，费用应该生效。
  If Nvl(单独执行_In, 0) = 0 Then
    If Nvl(v_执行前先结算, '0') <> '0' Then
      For r_Verify In c_Verify(r_No, 0) Loop
        v_Error := '当前执行的医嘱还存在未收取的费用。';
        Raise Err_Custom;
      End Loop;
    End If;
    For r_Verify In c_Verify(r_No) Loop
      If r_Verify.No <> v_No And v_序号 Is Not Null Then
        Zl_门诊记帐记录_Verify(v_No, 操作员编号_In, 操作员姓名_In, Substr(v_序号, 2));
        v_序号 := Null;
      End If;
      v_No   := r_Verify.No;
      v_序号 := v_序号 || ',' || r_Verify.序号;
    End Loop;
  Else
    If Nvl(v_执行前先结算, '0') <> '0' Then
      For r_Verify In c_Verifyone(r_No, 0) Loop
        v_Error := '当前执行的医嘱还存在未收取的费用。';
        Raise Err_Custom;
      End Loop;
    End If;
    For r_Verify In c_Verifyone(r_No) Loop
      If r_Verify.No <> v_No And v_序号 Is Not Null Then
        Zl_门诊记帐记录_Verify(v_No, 操作员编号_In, 操作员姓名_In, Substr(v_序号, 2));
        v_序号 := Null;
      End If;
      v_No   := r_Verify.No;
      v_序号 := v_序号 || ',' || r_Verify.序号;
    End Loop;
  End If;
  If v_序号 Is Not Null Then
    Zl_门诊记帐记录_Verify(v_No, 操作员编号_In, 操作员姓名_In, Substr(v_序号, 2));
  End If;

  --处理跟踪在用卫材自动发料
  For r_Stuff In c_Stuff(r_No_Stuff) Loop
    If v_发料号 Is Null Then
      v_发料号 := Nextno(20);
    End If;
  
    If r_Stuff.库房id <> Nvl(v_库房id, 0) Then
      If Nvl(v_库房id, 0) <> 0 And v_收发ids Is Not Null Then
        v_收发ids := Substr(v_收发ids, 2);
        Zl_药品收发记录_批量发料(v_收发ids, v_库房id, 操作员姓名_In, Sysdate, 1, 操作员姓名_In, v_发料号, 操作员姓名_In);
      End If;
      v_库房id  := r_Stuff.库房id;
      v_收发ids := Null;
    End If;
  
    v_收发ids := v_收发ids || '|' || r_Stuff.Id || ',0';
  End Loop;
  If Nvl(v_库房id, 0) <> 0 And v_收发ids Is Not Null Then
    v_收发ids := Substr(v_收发ids, 2);
    Zl_药品收发记录_批量发料(v_收发ids, v_库房id, 操作员姓名_In, Sysdate, 1, 操作员姓名_In, v_发料号, 操作员姓名_In);
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊医嘱执行_Finish;
/

--103232:冉俊明,2016-12-15,临床出诊安排，按序号时段开放停诊安排。
--103318:冉俊明,2016-12-06,周出诊表节假日换休有问题。
Create Or Replace Procedure Zl_Clinicvisitmodify
(
  号源id_In     In 临床出诊记录.号源id%Type,
  安排id_In     In 临床出诊记录.号源id%Type,
  出诊日期_In   In 临床出诊记录.出诊日期%Type,
  登记人_In     In 临床出诊记录.登记人%Type,
  登记时间_In   In 临床出诊记录.登记时间%Type,
  是否已换休_In In Number := 0
) As
  --功能：根据停诊安排和法定节假日调整出诊记录的出诊/预约情况
  --入参：
  --     是否已换休_In 主要用于换休后进行停诊处理
  --说明：
  --     临床出诊号源.假日控制状态：0-不上班;1-上班且开放预约;2-上班但不开放预约;3-受节假日设置控制
  --     1-停诊，在停诊安排时间范围内
  --     2-停诊，在法定节假日内
  --       2.1临床出诊号源.假日控制状态=0
  --       2.2临床出诊号源.假日控制状态=3，且设置了允许预约/允许挂号，但该上班时段不在设置的允许预约/允许挂号的时间范围内
  --     3-禁止预约，在法定节假日内，
  --       3.1临床出诊号源.假日控制状态=2
  --       3.3临床出诊号源.假日控制状态=3，设置了允许预约/允许挂号，且该上班时段在设置的允许挂号的时间范围内，但不在设置的允许预约时间范围内
  --     else-正常出诊

  n_假日控制状态 临床出诊号源.假日控制状态%Type;
  n_是否假日换休 临床出诊号源.是否假日换休%Type;

  d_原上班日期 临床出诊记录.出诊日期%Type;
  d_调休日期   临床出诊记录.出诊日期%Type;

  d_停诊开始时间 临床出诊记录.停诊开始时间%Type;
  d_停诊终止时间 临床出诊记录.停诊终止时间%Type;
  v_停诊原因     临床出诊记录.停诊原因%Type;

  d_假日开始日期 法定假日表.开始日期%Type;
  d_假日终止日期 法定假日表.终止日期%Type;
  v_允许预约     法定假日表.允许预约%Type;
  v_允许挂号     法定假日表.允许挂号%Type;

  d_停止预约开始时间 临床出诊记录.停诊开始时间%Type;
  d_停止预约终止时间 临床出诊记录.停诊终止时间%Type;

  n_Count    Number(2);
  n_允许预约 Number(2);
  n_允许挂号 Number(2);

  Procedure Stopbespeak
  (
    记录id_In   In 临床出诊记录.Id%Type,
    开始时间_In In 临床出诊记录.开始时间%Type,
    终止时间_In In 临床出诊记录.终止时间%Type
  ) As
    --功能：禁止预约
    --说明：
    --      分时段且序号控制的，修改"临床出诊序号控制.是否预约"等于1的为0；取消发布时根据"预约顺序号"恢复
    --      分时段且不序号控制的，修改"临床出诊序号控制.是否预约"为0；取消发布时根据恢复为1
    --      不分时段的，提供公共函数在挂号预约时检查预约时间是否在不允许预约的时间范围内
  Begin
    Update 临床出诊序号控制 Set 是否预约 = 0 Where 记录id = 记录id_In And 开始时间 Between 开始时间_In And 终止时间_In;
  End Stopbespeak;

  Procedure Stopvisit
  (
    记录id_In       In 临床出诊记录.Id%Type,
    停诊开始时间_In In 临床出诊记录.停诊开始时间%Type,
    停诊终止时间_In In 临床出诊记录.停诊终止时间%Type,
    停诊原因_In     In 临床出诊记录.停诊原因%Type
  ) As
    --功能：停诊
    --说明：
    --     同一条出诊记录可以存在多条停诊记录，临床出诊记录的停诊开始时间为多条停诊记录的最小开始时间，停诊终止时间为多条停诊记录的最大终止时间

  
    d_停诊开始时间 临床出诊记录.停诊开始时间%Type;
    d_停诊终止时间 临床出诊记录.停诊终止时间%Type;
    v_停诊原因     临床出诊记录.停诊原因%Type;
  Begin
    --产生停诊记录
    Insert Into 临床出诊停诊记录
      (ID, 记录id, 开始时间, 终止时间, 停诊原因, 申请人, 申请时间, 审批人, 审批时间, 登记人)
      Select 临床出诊停诊记录_Id.Nextval, ID, 停诊开始时间_In, 停诊终止时间_In, 停诊原因_In, Nvl(医生姓名, 登记人_In), 登记时间_In, 登记人_In, 登记时间_In, 登记人_In
      From 临床出诊记录
      Where ID = 记录id_In;
  
    Begin
      Select Min(a.开始时间), Max(a.终止时间), Max(a.停诊原因)
      Into d_停诊开始时间, d_停诊终止时间, v_停诊原因
      From 临床出诊停诊记录 A
      Where a.记录id = 记录id_In And a.取消时间 Is Null;
    Exception
      When Others Then
        d_停诊开始时间 := Null;
        d_停诊终止时间 := Null;
        v_停诊原因     := Null;
    End;
  
    Update 临床出诊记录
    Set 停诊开始时间 = d_停诊开始时间, 停诊终止时间 = d_停诊终止时间, 停诊原因 = v_停诊原因
    Where ID = 记录id_In;
  
    --调整"临床出诊序号控制.是否停诊"为1
    Update 临床出诊序号控制 A
    Set 是否停诊 = 1
    Where 记录id = 记录id_In And 开始时间 Between 停诊开始时间_In And 停诊终止时间_In And Exists
     (Select 1 From 临床出诊记录 Where ID = a.记录id And Nvl(是否序号控制, 0) = 1 And Nvl(是否分时段, 0) = 1);
  End Stopvisit;

  Procedure Changedaysoff
  (
    号源id_In     In 临床出诊记录.号源id%Type,
    安排id_In     In 临床出诊记录.安排id%Type,
    出诊日期_In   In 临床出诊记录.出诊日期%Type,
    原上班日期_In In 临床出诊记录.出诊日期%Type,
    调休日期_In   In 临床出诊记录.出诊日期%Type
  ) As
    --功能：换休处理
    n_安排id 临床出诊记录.安排id%Type;
    l_记录id t_Numlist := t_Numlist();
    n_Count  Number(2);
  Begin
    --1.前面的安排换到今日
    If 原上班日期_In Is Not Null Then
      --1.1.前面的日期没有安排则不处理
      Select Count(1)
      Into n_Count
      From 临床出诊记录
      Where 号源id = 号源id_In And 出诊日期 = 原上班日期_In And Rownum < 2;
    
      If Nvl(n_Count, 0) > 0 Then
        --[1]删除今日现有的安排
        Select ID Bulk Collect Into l_记录id From 临床出诊记录 Where 号源id = 号源id_In And 出诊日期 = 出诊日期_In;
        Zl_临床出诊记录_Batchdelete(l_记录id);
      
        --[2]复制安排
        For c_换休记录 In (Select ID, 是否发布 From 临床出诊记录 Where 号源id = 号源id_In And 出诊日期 = 原上班日期_In) Loop
          Zl_临床出诊记录_Copy(c_换休记录.Id, 安排id_In, 出诊日期_In, 登记人_In, 登记时间_In, c_换休记录.是否发布);
        End Loop;
      
        --[3]重新对今日进行停诊安排和法定节假日调整
        For c_记录 In (Select ID From 临床出诊记录 Where 号源id = 号源id_In And 出诊日期 = 出诊日期_In) Loop
          Zl_Clinicvisitmodify(号源id_In, 安排id_In, 出诊日期_In, 登记人_In, 登记时间_In, 1);
        End Loop;
      End If;
    End If;
  
    --2.今日的安排换到前面
    If 调休日期_In Is Not Null Then
      --2.1.今日没有安排则不处理
      Select Count(1)
      Into n_Count
      From 临床出诊记录
      Where 号源id = 号源id_In And 出诊日期 = 出诊日期_In And Rownum < 2;
    
      If Nvl(n_Count, 0) > 0 Then
        --2.2.前面那一天的安排已存在预约挂号记录则不替换(有漏洞)
        Select Count(1)
        Into n_Count
        From 临床出诊记录 A, 病人挂号记录 B
        Where a.Id = b.出诊记录id And a.号源id = 号源id_In And a.出诊日期 = 调休日期_In And Rownum < 2;
      
        If Nvl(n_Count, 0) = 0 Then
          --[1]记录前面那一天的原安排ID,没有就不处理
          Begin
            Select ID
            Into n_安排id
            From (Select Rownum As Rn, ID
                   From 临床出诊安排
                   Where 号源id = 号源id_In And 调休日期_In Between 开始时间 And 终止时间 And 审核时间 Is Not Null
                   Order By 登记时间 Desc)
            Where Rn < 2;
          Exception
            When Others Then
              n_安排id := 0;
          End;
        
          If Nvl(n_安排id, 0) <> 0 Then
            --[2]删除前面那一天现有的安排
            Select ID Bulk Collect Into l_记录id From 临床出诊记录 Where 号源id = 号源id_In And 出诊日期 = 调休日期_In;
            Zl_临床出诊记录_Batchdelete(l_记录id);
          
            --[3]复制安排
            For c_换休记录 In (Select ID From 临床出诊记录 Where 号源id = 号源id_In And 出诊日期 = 出诊日期_In) Loop
              --肯定是发布了的
              Zl_临床出诊记录_Copy(c_换休记录.Id, n_安排id, 调休日期_In, 登记人_In, 登记时间_In, 1);
            
            End Loop;
          
            --[4]重新对前面那一天进行停诊安排和法定节假日调整
            For c_记录 In (Select ID From 临床出诊记录 Where 号源id = 号源id_In And 出诊日期 = 调休日期_In) Loop
              Zl_Clinicvisitmodify(号源id_In, 安排id_In, 调休日期_In, 登记人_In, 登记时间_In, 1);
            End Loop;
          End If;
        End If;
      End If;
    End If;
  End Changedaysoff;
Begin
  Begin
    Select Nvl(b.假日控制状态, 0), Nvl(b.是否假日换休, 0)
    Into n_假日控制状态, n_是否假日换休
    From 临床出诊号源 B
    Where b.Id = 号源id_In;
  Exception
    When Others Then
      --没有找到号源，直接退出
      Return;
  End;

  --================================================================================
  --【1】假日换休处理
  --说明：只能用后面的日期向前面检查，因为后面的日期可能还没有制定安排
  --================================================================================
  If Nvl(是否已换休_In, 0) = 0 Then
    --确定法定节假日是否需要换休
    If Nvl(n_是否假日换休, 0) = 1 Then
      --1.前面的安排换到今日
      Begin
        --开始日期：原本休息日(即调休日) ， 终止日期：原本上班日(即被调休日)
        Select a.终止日期
        Into d_原上班日期
        From 法定假日表 A
        Where a.性质 = 1 And 出诊日期_In = a.开始日期 And a.终止日期 < 出诊日期_In And Rownum < 2;
      Exception
        When Others Then
          d_原上班日期 := Null;
      End;
    
      --2.今日的安排换到前面
      Begin
        --开始日期：原本休息日(即调休日) ， 终止日期：原本上班日(即被调休日)
        Select a.开始日期
        Into d_调休日期
        From 法定假日表 A
        Where a.性质 = 1 And 出诊日期_In = a.终止日期 And a.开始日期 < 出诊日期_In And Rownum < 2;
      Exception
        When Others Then
          d_调休日期 := Null;
      End;
    
      Changedaysoff(号源id_In, 安排id_In, 出诊日期_In, d_原上班日期, d_调休日期);
    End If;
  End If;

  For c_记录 In (Select ID, 出诊日期, 开始时间, 终止时间
               From 临床出诊记录
               Where 号源id = 号源id_In And 出诊日期 = 出诊日期_In And 上班时段 Is Not Null) Loop
    --================================================================================
    --【2】停诊安排停诊处理
    --================================================================================
    For c_停诊 In (Select a.开始时间, a.终止时间, a.停诊原因
                 From 临床出诊停诊记录 A, 临床出诊记录 B
                 Where a.申请人 = b.医生姓名 And a.记录id Is Null And a.审批时间 Is Not Null And a.取消时间 Is Null And
                       b.医生id Is Not Null And b.Id = c_记录.Id And c_记录.开始时间 < a.终止时间 And c_记录.终止时间 > a.开始时间
                 Order By a.审批时间) Loop
    
      d_停诊开始时间 := c_停诊.开始时间;
      d_停诊终止时间 := c_停诊.终止时间;
      If d_停诊开始时间 < c_记录.开始时间 Then
        d_停诊开始时间 := c_记录.开始时间;
      End If;
      If d_停诊终止时间 > c_记录.终止时间 Then
        d_停诊终止时间 := c_记录.终止时间;
      End If;
      Stopvisit(c_记录.Id, d_停诊开始时间, d_停诊终止时间, c_停诊.停诊原因);
    End Loop;
  
    --================================================================================
    --【3】法定节假日停诊及禁止预约处理
    --================================================================================
    --1.查找含有上班时段时间的节假日，以第一个为准（开始时间升序排序），一般也只有一个
    Begin
      Select 开始日期, 终止日期, 节日名称, 允许预约, 允许挂号
      Into d_假日开始日期, d_假日终止日期, v_停诊原因, v_允许预约, v_允许挂号
      From (Select a.开始日期, a.终止日期, a.节日名称, a.允许预约, a.允许挂号
             From 法定假日表 A
             Where a.性质 = 0 And c_记录.开始时间 < a.终止日期 And c_记录.终止时间 > a.开始日期
             Order By a.开始日期)
      Where Rownum < 2;
    Exception
      When Others Then
        Return;
    End;
  
    --假日控制状态:0-不上班;1-上班且开放预约;2-上班但不开放预约;3-受节假日设置控制
    If Nvl(n_假日控制状态, 0) = 0 Then
      --不上班，停诊
      d_停诊开始时间 := d_假日开始日期;
      d_停诊终止时间 := d_假日终止日期 + 1 - 1 / 24 / 60 / 60;
      If d_停诊开始时间 < c_记录.开始时间 Then
        d_停诊开始时间 := c_记录.开始时间;
      End If;
      If d_停诊终止时间 > c_记录.终止时间 Then
        d_停诊终止时间 := c_记录.终止时间;
      End If;
      Stopvisit(c_记录.Id, d_停诊开始时间, d_停诊终止时间, v_停诊原因);
    Elsif Nvl(n_假日控制状态, 0) = 2 Then
      --允许挂号，但禁止预约
      d_停止预约开始时间 := d_假日开始日期;
      d_停止预约终止时间 := d_假日终止日期 + 1 - 1 / 24 / 60 / 60;
      If d_停止预约开始时间 < c_记录.开始时间 Then
        d_停止预约开始时间 := c_记录.开始时间;
      End If;
      If d_停止预约终止时间 > c_记录.终止时间 Then
        d_停止预约终止时间 := c_记录.终止时间;
      End If;
      Stopbespeak(c_记录.Id, d_停止预约开始时间, d_停止预约终止时间);
    Elsif Nvl(n_假日控制状态, 0) = 3 Then
      --没有"允许挂号"的就一定没有"允许预约"的
      If v_允许挂号 Is Not Null Then
        --2.检查是否有包含上班时段时间的"允许挂号"
        --因为上班时段最多24小时，所以查出的结果最多两天，且这两天一定是连续的
        n_允许挂号 := 0;
        For c_允许挂号 In (With 临时表 As
                          (Select To_Date(Column_Value, 'yyyy-mm-dd') As 开始时间,
                                 To_Date(Column_Value, 'yyyy-mm-dd') + 1 - 1 / 24 / 60 / 60 As 终止时间
                          From Table(f_Str2list(v_允许挂号, ';'))
                          Where c_记录.开始时间 < To_Date(Column_Value, 'yyyy-mm-dd') + 1 - 1 / 24 / 60 / 60 And
                                c_记录.终止时间 > To_Date(Column_Value, 'yyyy-mm-dd')
                          Order By To_Date(Column_Value, 'yyyy-mm-dd'))
                         Select a.开始时间, Nvl(b.终止时间, a.终止时间) As 终止时间
                         From 临时表 A, 临时表 B
                         Where a.终止时间 = b.开始时间(+) - 1 / 24 / 60 / 60 And Rownum < 2) Loop
        
          n_允许挂号 := 1;
          n_允许预约 := 0;
          --3.检查是否有包含上班时段时间的"允许预约"
          For c_允许预约 In (With 临时表 As
                            (Select To_Date(Column_Value, 'yyyy-mm-dd') As 开始时间,
                                   To_Date(Column_Value, 'yyyy-mm-dd') + 1 - 1 / 24 / 60 / 60 As 终止时间
                            From Table(f_Str2list(v_允许预约, ';'))
                            Where c_记录.开始时间 < To_Date(Column_Value, 'yyyy-mm-dd') + 1 - 1 / 24 / 60 / 60 And
                                  c_记录.终止时间 > To_Date(Column_Value, 'yyyy-mm-dd')
                            Order By To_Date(Column_Value, 'yyyy-mm-dd'))
                           Select a.开始时间, Nvl(b.终止时间, a.终止时间) As 终止时间
                           From 临时表 A, 临时表 B
                           Where a.终止时间 = b.开始时间(+) - 1 / 24 / 60 / 60 And Rownum < 2) Loop
          
            n_允许预约 := 1;
            --在"允许挂号","允许预约"时间范围内的不需要处理
          
            --检查前后是否需要禁止预约
            If c_记录.开始时间 < c_允许预约.开始时间 And c_允许挂号.开始时间 < c_允许预约.开始时间 Then
              If c_记录.开始时间 < c_允许挂号.开始时间 Then
                d_停止预约开始时间 := c_允许挂号.开始时间;
              Else
                d_停止预约开始时间 := c_记录.开始时间;
              End If;
              d_停止预约终止时间 := c_允许预约.开始时间;
              Stopbespeak(c_记录.Id, d_停止预约开始时间, d_停止预约终止时间);
            End If;
          
            If c_记录.终止时间 > c_允许预约.终止时间 And c_允许挂号.终止时间 > c_允许预约.终止时间 Then
              d_停止预约开始时间 := c_允许预约.终止时间;
              If c_记录.终止时间 > c_允许挂号.终止时间 Then
                d_停止预约开始时间 := c_允许挂号.终止时间;
              Else
                d_停止预约开始时间 := c_记录.终止时间;
              End If;
              Stopbespeak(c_记录.Id, d_停止预约开始时间, d_停止预约终止时间);
            End If;
          End Loop;
        
          --允许挂号，但禁止预约
          If Nvl(n_允许预约, 0) = 0 Then
            d_停止预约开始时间 := c_允许挂号.开始时间;
            d_停止预约终止时间 := c_允许挂号.终止时间;
            If d_停止预约开始时间 < c_记录.开始时间 Then
              d_停止预约开始时间 := c_记录.开始时间;
            End If;
            If d_停止预约终止时间 > c_记录.终止时间 Then
              d_停止预约终止时间 := c_记录.终止时间;
            End If;
            Stopbespeak(c_记录.Id, d_停止预约开始时间, d_停止预约终止时间);
          End If;
        
          --检查前后是否需要停诊
          If c_记录.开始时间 < c_允许挂号.开始时间 And d_假日开始日期 < c_允许挂号.开始时间 Then
            If c_记录.开始时间 < d_假日开始日期 Then
              d_停诊开始时间 := d_假日开始日期;
            Else
              d_停诊开始时间 := c_记录.开始时间;
            End If;
            d_停诊终止时间 := c_允许挂号.开始时间;
            Stopvisit(c_记录.Id, d_停诊开始时间, d_停诊终止时间, v_停诊原因);
          End If;
        
          If c_记录.终止时间 > c_允许挂号.终止时间 And d_假日终止日期 > c_允许挂号.终止时间 Then
            d_停诊开始时间 := c_允许挂号.终止时间;
            If c_记录.终止时间 > d_假日终止日期 Then
              d_停诊终止时间 := d_停诊终止时间;
            Else
              d_停诊终止时间 := c_记录.终止时间;
            End If;
            Stopvisit(c_记录.Id, d_停诊开始时间, d_停诊终止时间, v_停诊原因);
          End If;
        End Loop;
      
        --不在设置的允许挂号时间范围内，停诊
        If Nvl(n_允许挂号, 0) = 0 Then
          d_停诊开始时间 := d_假日开始日期;
          d_停诊终止时间 := d_假日终止日期 + 1 - 1 / 24 / 60 / 60;
          If d_停诊开始时间 < c_记录.开始时间 Then
            d_停诊开始时间 := c_记录.开始时间;
          End If;
          If d_停诊终止时间 > c_记录.终止时间 Then
            d_停诊终止时间 := c_记录.终止时间;
          End If;
          Stopvisit(c_记录.Id, d_停诊开始时间, d_停诊终止时间, v_停诊原因);
        End If;
      Else
        --未设置允许挂号/允许预约，则停诊
        d_停诊开始时间 := d_假日开始日期;
        d_停诊终止时间 := d_假日终止日期 + 1 - 1 / 24 / 60 / 60;
        If d_停诊开始时间 < c_记录.开始时间 Then
          d_停诊开始时间 := c_记录.开始时间;
        End If;
        If d_停诊终止时间 > c_记录.终止时间 Then
          d_停诊终止时间 := c_记录.终止时间;
        End If;
        Stopvisit(c_记录.Id, d_停诊开始时间, d_停诊终止时间, v_停诊原因);
      End If;
    End If;
  End Loop;
End Zl_Clinicvisitmodify;
/

--106360:冉俊明,2017-02-22,临床出诊安排取消发布时未清除序号控制中是是否停诊标志。
--103325:冉俊明,2017-02-16,跨月周出诊表按整周（七天）生成新的周出诊表或保存为模板。
--103318:冉俊明,2017-01-03,周出诊表节假日换休有问题。
Create Or Replace Procedure Zl_临床出诊安排_Publish
(
  Id_In       临床出诊表.Id%Type,
  发布人_In   临床出诊表.发布人%Type := Null,
  发布时间_In 临床出诊表.发布时间%Type := Null,
  取消发布_In Number := 0
) As
  --发布和取消发布安排
  --参数：
  --        取消发布_In 是否取消发布
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  n_Count    Number(2);
  n_排班方式 临床出诊表.排班方式%Type;
  l_记录id   t_Numlist := t_Numlist();

  d_开始时间 临床出诊安排.开始时间%Type;
  d_终止时间 临床出诊安排.终止时间%Type;

  n_跨月周出诊id 临床出诊表.Id%Type;

  Function Get跨月周出诊id(出诊id_In 临床出诊表.Id%Type) Return 临床出诊表.Id%Type Is
    ----------------------------------------
    --如果原周出诊表不是整周(不足7天)，则需要查找到另一个出诊表构成整周
    ----------------------------------------
    n_出诊id 临床出诊表.Id%Type;
    n_年份   临床出诊表.年份%Type;
    n_月份   临床出诊表.月份%Type;
    n_周数   临床出诊表.周数%Type;
  
    d_开始时间 临床出诊安排.开始时间%Type;
    d_结束时间 临床出诊安排.终止时间%Type;
  
    --根据日期计算当月的周数，以及每一周的时间范围
    Cursor c_Weekrange(Date_In Date) Is
      Select Rownum As 周数, 开始日期, 结束日期
      From (With Month_Range As (Select Trunc(Date_In) As First_Day, Last_Day(Trunc(Date_In)) As Last_Day From Dual)
             Select Decode(To_Char(First_Day, 'day'), '星期日', First_Day, Null) As 开始日期,
                    Decode(To_Char(First_Day, 'day'), '星期日', First_Day, Null) As 结束日期
             From Month_Range
             Union All
             Select Decode(Sign(Trunc(First_Day + 7 * Week, 'day') + 1 - First_Day), 1,
                            Trunc(First_Day + 7 * Week, 'day') + 1, First_Day) As 开始日期,
                    Decode(Sign(Trunc(First_Day + 7 * Week, 'day') + 7 - Last_Day), 1, Last_Day,
                            Trunc(First_Day + 7 * Week, 'day') + 7) As 结束日期
             From Month_Range A, (Select Level - 1 As Week From Dual Connect By Level <= 6) B)
             Where 开始日期 <= 结束日期;
  
  
  Begin
    Begin
      Select 年份, 月份, 周数 Into n_年份, n_月份, n_周数 From 临床出诊表 Where ID = 出诊id_In;
    Exception
      When Others Then
        Return 0;
    End;
  
    If n_年份 Is Null Or n_月份 Is Null Or n_周数 Is Null Then
      Return 0;
    End If;
  
    For r_Weekrange In c_Weekrange(To_Date(n_年份 || '-' || n_月份 || '-01', 'yyyy-mm-dd')) Loop
      If r_Weekrange.周数 = n_周数 Then
        d_开始时间 := r_Weekrange.开始日期;
        d_结束时间 := r_Weekrange.结束日期;
        Exit;
      End If;
    End Loop;
  
    If d_开始时间 Is Null Or d_结束时间 Is Null Then
      Return 0;
    End If;
    If Trunc(d_结束时间) - Trunc(d_开始时间) >= 6 Then
      Return 0;
    End If;
  
    --存在跨月的，查找另一个出诊表的年月周
    n_年份 := Null;
    n_月份 := Null;
    n_周数 := Null;
    If Trunc(d_开始时间 - 1, 'month') <> Trunc(d_开始时间, 'month') Then
      --当前是第一周,获取另一个出诊表的年月
      n_年份 := To_Number(To_Char(d_开始时间 - 1, 'yyyy'));
      n_月份 := To_Number(To_Char(d_开始时间 - 1, 'mm'));
    Elsif Trunc(d_结束时间 + 1, 'month') <> Trunc(d_结束时间, 'month') Then
      --当前是最后一周,获取另一个出诊表的年月
      n_年份 := To_Number(To_Char(d_结束时间 + 1, 'yyyy'));
      n_月份 := To_Number(To_Char(d_结束时间 + 1, 'mm'));
      n_周数 := 1;
    Else
      Return 0;
    End If;
  
    --获取跨月的另一个出诊表的ID
    Begin
      Select ID
      Into n_出诊id
      From (Select Rownum As 行号, ID
             From 临床出诊表
             Where Nvl(排班方式, 0) = 2 And 年份 = n_年份 And 月份 = n_月份 And (n_周数 Is Null Or 周数 = n_周数)
             Order By 周数 Desc)
      Where 行号 < 2;
    Exception
      When Others Then
        Return 0;
    End;
  
    Return n_出诊id;
  End;
Begin
  Begin
    Select Nvl(排班方式, 0) Into n_排班方式 From 临床出诊表 Where ID = Id_In;
  Exception
    When Others Then
      v_Err_Msg := '出诊表信息未找到！';
      Raise Err_Item;
  End;

  If Nvl(取消发布_In, 0) = 0 Then
    --发布安排
    If Nvl(n_排班方式, 0) = 0 Then
      Select Max(1)
      Into n_Count
      From 临床出诊安排 A, 临床出诊限制 B, 临床出诊表 C
      Where a.Id = b.安排id And a.出诊id = c.Id And c.排班方式 = 0 And c.Id = Id_In And Rownum < 2;
      If Nvl(n_Count, 0) = 0 Then
        v_Err_Msg := '当前出诊表无有效的安排，不能发布！';
        Raise Err_Item;
      End If;
    Else
      If Nvl(n_排班方式, 0) = 2 Then
        n_跨月周出诊id := Get跨月周出诊id(Id_In);
      End If;
      Select Max(1)
      Into n_Count
      From 临床出诊安排 A, 临床出诊记录 B, 临床出诊表 C
      Where a.Id = b.安排id And a.出诊id = c.Id And c.排班方式 In (1, 2) And (c.Id = Id_In Or c.Id = n_跨月周出诊id) And Rownum < 2;
      If Nvl(n_Count, 0) = 0 Then
        v_Err_Msg := '当前出诊表无有效的安排，不能发布！';
        Raise Err_Item;
      End If;
    
      Select Max(1)
      Into n_Count
      From 临床出诊记录 A, 临床出诊安排 B
      Where a.号源id = b.号源id And a.出诊日期 Between b.开始时间 And b.终止时间 And a.安排id <> b.Id And b.出诊id = Id_In And Rownum < 2;
      If Nvl(n_Count, 0) <> 0 Then
        v_Err_Msg := '当前出诊表中的部分号源在当前出诊表的生效时间范围内已经存在有效的安排，不能发布！';
        Raise Err_Item;
      End If;
    End If;
  
    --如果存在多个未发布的安排表，则不允许发布后面日期的安排，必须按最小有效时间进行发布
    Select Max(1)
    Into n_Count
    From (Select ID, 年份 || LPad(月份, 2, '0') || 周数 As 日期
           From 临床出诊表
           Where Nvl(排班方式, 0) = Nvl(n_排班方式, 0) And 发布人 Is Null) A,
         (Select ID, 年份 || LPad(月份, 2, '0') || 周数 As 日期 From 临床出诊表 Where ID = Id_In) B
    Where a.日期 < b.日期 And Rownum < 2;
    If Nvl(n_Count, 0) <> 0 Then
      If Nvl(n_排班方式, 0) = 0 Then
        v_Err_Msg := '当前出诊表前面还有未发布的固定出诊表，必须先将其发布或删除后才能发布该出诊表！';
      Elsif Nvl(n_排班方式, 0) = 1 Then
        v_Err_Msg := '当前出诊表前面还有未发布的月出诊表，必须先将其发布或删除后才能发布该出诊表！';
      Elsif Nvl(n_排班方式, 0) = 2 Then
        v_Err_Msg := '当前出诊表前面还有未发布的周出诊表，必须先将其发布或删除后才能发布该出诊表！';
      End If;
      Raise Err_Item;
    End If;
  
    Update 临床出诊表 Set 发布人 = 发布人_In, 发布时间 = 发布时间_In Where ID = Id_In;
    Update 临床出诊安排 Set 审核人 = 发布人_In, 审核时间 = 发布时间_In Where 出诊id = Id_In;
  
    --删除发布时有安排，但是号源已被停用的记录
    For c_安排 In (Select a.Id
                 From 临床出诊安排 A, 临床出诊号源 B
                 Where a.号源id = b.Id And a.出诊id = Id_In And
                       Not (Nvl(b.是否删除, 0) = 0 And (b.撤档时间 Is Null Or b.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')))) Loop
      Zl_临床出诊安排_Delete(c_安排.Id, Nvl(n_排班方式, 0));
    End Loop;
  
    If Nvl(n_排班方式, 0) <> 0 Then
      --月安排/周安排根据停诊安排和法定节假日调整出诊记录的出诊/预约情况
      Select 开始时间, 终止时间 Into d_开始时间, d_终止时间 From 临床出诊安排 Where 出诊id = Id_In And Rownum < 2;
      For c_安排 In (Select a.Id, a.号源id, b.日期
                   From 临床出诊安排 A,
                        (Select Trunc(d_开始时间) + Level - 1 As 日期
                          From Dual
                          Connect By Level <= Trunc(d_终止时间) - Trunc(d_开始时间) + 1) B
                   Where a.出诊id = Id_In
                   Order By 号源id, 日期) Loop
      
        Zl_Clinicvisitmodify(c_安排.号源id, c_安排.Id, c_安排.日期, 发布人_In, 发布时间_In);
      End Loop;
    
      --修改临床出诊记录中的"是否发布"
      Select a.Id Bulk Collect
      Into l_记录id
      From 临床出诊记录 A, 临床出诊安排 B
      Where a.安排id = b.Id And b.出诊id = Id_In;
    
      Forall I In 1 .. l_记录id.Count
        Update 临床出诊记录 Set 是否发布 = 1 Where ID = l_记录id(I);
    End If;
    Return;
  End If;

  --==================================================================================================================
  --取消发布
  Select Max(1)
  Into n_Count
  From (Select ID, 年份 || LPad(月份, 2, '0') || 周数 As 日期
         From 临床出诊表
         Where Nvl(排班方式, 0) = Nvl(n_排班方式, 0) And 发布人 Is Not Null) A,
       (Select ID, 年份 || LPad(月份, 2, '0') || 周数 As 日期 From 临床出诊表 Where ID = Id_In) B
  Where a.日期 > b.日期 And Rownum < 2;
  If Nvl(n_Count, 0) <> 0 Then
    If Nvl(n_排班方式, 0) = 0 Then
      v_Err_Msg := '当前出诊后面还有已发布的固定出诊表，必须先将其取消发布后才能取消发布该出诊表！';
    Elsif Nvl(n_排班方式, 0) = 1 Then
      v_Err_Msg := '当前出诊后面还有已发布的月出诊表，必须先将其取消发布后才能取消发布该出诊表！';
    Elsif Nvl(n_排班方式, 0) = 2 Then
      v_Err_Msg := '当前出诊后面还有已发布的周出诊表，必须先将其取消发布后才能取消发布该出诊表！';
    End If;
    Raise Err_Item;
  End If;

  Select Max(1)
  Into n_Count
  From 病人挂号记录 C, 临床出诊记录 A, 临床出诊安排 B
  Where c.出诊记录id = a.Id And a.安排id = b.Id And b.出诊id = Id_In And Rownum < 2;
  If Nvl(n_Count, 0) <> 0 Then
    v_Err_Msg := '当前出诊表的安排已被使用，不允许取消发布！';
    Raise Err_Item;
  End If;

  Update 临床出诊表 Set 发布人 = Null, 发布时间 = Null Where ID = Id_In;
  If Sql%NotFound Then
    v_Err_Msg := '出诊表信息未找到！';
    Raise Err_Item;
  End If;
  Update 临床出诊安排 Set 审核人 = Null, 审核时间 = Null Where 出诊id = Id_In;

  --固定安排取消发布时删除出诊记录
  If Nvl(n_排班方式, 0) = 0 Then
    --删除出诊记录
    Select a.Id Bulk Collect
    Into l_记录id
    From 临床出诊记录 A, 临床出诊安排 B
    Where a.安排id = b.Id And b.出诊id = Id_In;
  
    Zl_临床出诊记录_Batchdelete(l_记录id);
  Else
    --月安排/周安排清除停诊信息，并修改是否发布
    Select a.Id Bulk Collect
    Into l_记录id
    From 临床出诊记录 A, 临床出诊安排 B
    Where a.安排id = b.Id And b.出诊id = Id_In;
  
    Forall I In 1 .. l_记录id.Count
      Delete From 临床出诊停诊记录 Where 记录id = l_记录id(I);
  
    --修改临床出诊记录中的"是否发布"
    Select a.Id Bulk Collect
    Into l_记录id
    From 临床出诊记录 A, 临床出诊安排 B
    Where a.安排id = b.Id And b.出诊id = Id_In;
  
    Forall I In 1 .. l_记录id.Count
      Update 临床出诊记录
      Set 停诊开始时间 = Null, 停诊终止时间 = Null, 停诊原因 = Null, 是否发布 = 0
      Where ID = l_记录id(I);
  
    --恢复临床出诊序号控制的"是否预约"及"是否停诊"
    For c_记录 In (Select a.Id, a.是否分时段, a.是否序号控制
                 From 临床出诊记录 A, 临床出诊安排 B
                 Where a.安排id = b.Id And b.出诊id = Id_In) Loop
      If Nvl(c_记录.是否分时段, 0) = 1 Then
        If Nvl(c_记录.是否序号控制, 0) = 0 Then
          Update 临床出诊序号控制 Set 是否预约 = 1 Where 记录id = c_记录.Id;
        Else
          Update 临床出诊序号控制 Set 是否预约 = Nvl(预约顺序号, 0), 是否停诊 = 0 Where 记录id = c_记录.Id;
        End If;
      End If;
    End Loop;
  
    --换休的不再恢复
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊安排_Publish;
/

--104979:冉俊明,2017-01-18,固定安排在制定临时安排时可修改收费项目，已被使用的按月或周排班的号源可以修改收费项目。
--103318:冉俊明,2017-01-03,周出诊表节假日换休有问题。
Create Or Replace Procedure Zl1_Auto_Buildingregisterplan
(
  挂号时间_In In Date := Null,
  号源id_In   临床出诊号源.Id%Type := Null
) As
  -------------------------------------------------------------------------
  --功能说明：自动生成临床出诊记录
  --          1、根据号源自动生成预约数内的临床出诊记录;
  --          2、预约天数的确定:号源预约天数-->预约方式的天数（取最大)-->系统预约天数
  --入参:挂号时间_IN:NULL时，自动生成;否则只检查指定日期是否生成了出诊记录没有
  --    号源id_In:NULL时处理所有号源，否则只处理指定号源
  -------------------------------------------------------------------------
  n_缺省预约天数 临床出诊号源.预约天数%Type;
  v_操作员姓名   临床出诊安排.操作员姓名%Type;
  d_登记日期     临床出诊安排.登记时间%Type;
  n_安排id       临床出诊安排.Id%Type;
  n_项目id       临床出诊安排.项目id %Type;

  n_记录id   临床出诊记录.Id%Type;
  d_当前日期 临床出诊记录.出诊日期%Type;

  n_是否出诊 Number(2);
  l_固定时段 t_Strlist := t_Strlist();
  n_Count    Number(18);
Begin

  Select Max(预约天数) Into n_缺省预约天数 From 预约方式;
  If Nvl(n_缺省预约天数, 0) = 0 Then
    n_缺省预约天数 := To_Number(Nvl(zl_GetSysParameter('挂号允许预约天数'), '0'));
  End If;
  If Nvl(n_缺省预约天数, 0) = 0 Then
    n_缺省预约天数 := 7;
  End If;

  d_当前日期   := Trunc(Nvl(挂号时间_In, Sysdate));
  d_登记日期   := Sysdate;
  v_操作员姓名 := Zl_Username;

  --第一层循环，号源信息
  For c_号源 In (Select c.Id, c.号类, c.号码, c.项目id, c.科室id, c.医生姓名, Decode(Nvl(c.预约天数, 0), 0, n_缺省预约天数, c.预约天数) As 预约天数,
                      Nvl(b.站点, '-') As 站点, Nvl(c.是否假日换休, 0) As 是否假日换休, Nvl(c.假日控制状态, 0) As 假日控制状态,
                      Nvl(c.排班方式, 0) As 排班方式
               From 临床出诊号源 C, 部门表 B
               Where c.科室id = b.Id And Nvl(c.是否删除, 0) = 0 And
                     (c.撤档时间 Is Null Or c.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
                     (号源id_In Is Null Or c.Id = 号源id_In)
                    --
                     And Exists (Select 1
                      From 临床出诊安排 M, 临床出诊表 N
                      Where m.出诊id = n.Id And m.号源id = c.Id And Nvl(n.排班方式, 0) = 0 And n.发布时间 Is Not Null And
                            m.审核时间 Is Not Null And d_当前日期 <= m.终止时间)) Loop
  
    --检查当前日期所在的安排的收费项目是否为号源中的收费项目，如果不是，则更新号源中的收费项目
    Begin
      Select 项目id
      Into n_项目id
      From (Select a.项目id
             From 临床出诊安排 A, 临床出诊表 B
             Where a.出诊id = b.Id And a.号源id = c_号源.Id And a.审核时间 Is Not Null And d_当前日期 Between a.开始时间 And a.终止时间 And
                   Nvl(b.排班方式, 0) = 0 And b.发布时间 Is Not Null
             Order By a.登记时间 Desc)
      Where Rownum < 2;
    Exception
      When Others Then
        n_项目id := Null;
    End;
    If Nvl(n_项目id, 0) <> 0 Then
      If Nvl(c_号源.项目id, 0) <> n_项目id Then
        Update 临床出诊号源 Set 项目id = n_项目id Where ID = c_号源.Id;
        Commit;
      End If;
    End If;
  
    --第二层循环，出诊日期
    --从头一天开始生成，避免如全日(8:00-7:59)在0:00-7:59没有出诊记录
    For c_日期 In (Select m.日期,
                        Decode(To_Char(m.日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7',
                                '周六', Null) As 星期
                 From (Select Trunc(d_当前日期) + 天数 As 日期
                        From (Select Level - 1 As 天数 From Dual Connect By Level <= c_号源.预约天数 + 1)
                        Where 号源id_In Is Not Null
                        Union All
                        Select Trunc(d_当前日期 - 1) + 天数 As 日期
                        From (Select Level - 1 As 天数 From Dual Connect By Level <= c_号源.预约天数 + 2)
                        Where 号源id_In Is Null) M) Loop
    
      l_固定时段 := t_Strlist();
      --检查当日是否在月/周出诊表中,若在，则不生成出诊记录
      Select Count(1)
      Into n_Count
      From 临床出诊安排 A, 临床出诊表 B
      Where a.出诊id = b.Id And a.号源id = c_号源.Id And c_日期.日期 Between Trunc(a.开始时间) And Trunc(a.终止时间) And
            Nvl(b.排班方式, 0) In (1, 2) And Rownum < 2;
    
      --当前号源为按月/周排班，且当前日期之前已有按月/周排班的出诊记录就不再按固定安排生成出诊记录了
      If Nvl(n_Count, 0) = 0 And Nvl(c_号源.排班方式, 0) <> 0 Then
        Select Count(1)
        Into n_Count
        From 临床出诊安排 A, 临床出诊表 B
        Where a.出诊id = b.Id And Nvl(b.排班方式, 0) In (1, 2) And a.号源id = c_号源.Id And a.开始时间 < c_日期.日期 And Rownum < 2;
      End If;
    
      If Nvl(n_Count, 0) = 0 Then
        If 号源id_In Is Null Then
          --出诊安排,取最后登记的一个
          Begin
            Select 安排id
            Into n_安排id
            From (Select a.Id As 安排id
                   From 临床出诊安排 A, 临床出诊表 B
                   Where a.号源id = c_号源.Id And a.出诊id = b.Id And Nvl(b.排班方式, 0) = 0 And b.发布时间 Is Not Null And
                         a.审核时间 Is Not Null And c_日期.日期 Between a.开始时间 And a.终止时间
                   Order By a.登记时间 Desc)
            Where Rownum < 2;
          Exception
            When Others Then
              n_安排id := 0;
          End;
        Else
          --如果指定了号源ID，肯定是发布后新增了临时安排重新生成出诊记录，最后登记的一个肯定是本次新增的，
          --只需要处理这个安排即可，不在这个安排有效时间范围内的就不处理
          Begin
            Select 安排id
            Into n_安排id
            From (Select a.Id As 安排id, a.开始时间, a.终止时间, Row_Number() Over(Order By a.登记时间 Desc) As 行号
                   From 临床出诊安排 A, 临床出诊表 B
                   Where a.号源id = c_号源.Id And a.出诊id = b.Id And Nvl(b.排班方式, 0) = 0 And b.发布时间 Is Not Null And
                         a.审核时间 Is Not Null)
            Where 行号 = 1 And c_日期.日期 Between 开始时间 And 终止时间;
          Exception
            When Others Then
              n_安排id := 0;
          End;
        End If;
      
        If Nvl(n_安排id, 0) <> 0 Then
          If 号源id_In Is Null Then
            --确定当日是否有出诊记录
            Select Count(1)
            Into n_Count
            From 临床出诊记录 A
            Where a.号源id = c_号源.Id And a.出诊日期 = c_日期.日期 And Rownum < 2;
          
            --1.未指定号源ID，则是正常生成出诊记录，有出诊记录的日期将不再处理
            If Nvl(n_Count, 0) = 0 Then
              --1.1无出诊记录，正常生成
              n_是否出诊 := 1;
            Else
              --1.2有出诊记录，不再处理
              n_是否出诊 := 0;
            End If;
          Else
            --2.指定了号源ID，肯定是发布后新增了临时安排重新生成出诊记录
            n_是否出诊 := 1;
            --当日有出诊记录，需要做如下处理
            For c_记录 In (Select a.安排id, a.Id As 记录id, a.出诊日期, a.上班时段, a.是否分时段, a.是否序号控制
                         From 临床出诊记录 A
                         Where a.号源id = c_号源.Id And a.出诊日期 = c_日期.日期) Loop
            
              Select Count(1) Into n_Count From 病人挂号记录 Where 出诊记录id = c_记录.记录id;
              If Nvl(n_Count, 0) = 0 Then
                --2.2.1如果时段不存在预约挂号数据，则删除重新生成
                Zl_临床出诊上班时段_Delete(c_记录.安排id, To_Char(c_记录.出诊日期, 'yyyy-mm-dd'), 1, c_记录.上班时段);
              Else
                --2.2.2如果时段存在预约挂号数据，则只需调整出诊记录的安排ID即可
                Update 临床出诊记录 Set 安排id = n_安排id Where ID = c_记录.记录id;
                l_固定时段.Extend();
                l_固定时段(l_固定时段.Count) := c_记录.上班时段;
              End If;
            End Loop;
          End If;
        
          --检查这天是否出诊
          If n_是否出诊 = 1 Then
            Select Count(1) Into n_Count From 临床出诊限制 Where 安排id = n_安排id And 限制项目 = c_日期.星期;
            If Nvl(n_Count, 0) = 0 Then
              n_是否出诊 := 0;
            End If;
          End If;
        
          If Nvl(n_是否出诊, 0) = 0 Then
            --如果不存在临床出诊记录，则增加临床出诊记录(时间段为NULL 的空记录)
            Insert Into 临床出诊记录
              (ID, 安排id, 号源id, 出诊日期, 登记人, 登记时间)
              Select 临床出诊记录_Id.Nextval, n_安排id, a.Id As ID, c_日期.日期, v_操作员姓名, d_登记日期 As 登记时间
              From 临床出诊号源 A, 临床出诊安排 B
              Where a.Id = b.号源id And b.Id = n_安排id
                   --
                    And Not Exists (Select 1 From 临床出诊记录 Where 号源id = a.Id And 出诊日期 = c_日期.日期);
          Else
            For c_记录 In (With c_时间段 As
                            (Select 时间段, 开始时间, 终止时间, 号类, 站点, 缺省时间, 提前时间
                            From (Select 时间段, 开始时间, 终止时间, 号类, 站点, 缺省时间, 提前时间,
                                          Row_Number() Over(Partition By 时间段 Order By 时间段, 站点 Asc, 号类 Asc) As 组号
                                   From 时间段
                                   Where Nvl(站点, c_号源.站点) = c_号源.站点 And Nvl(号类, c_号源.号类) = c_号源.号类)
                            Where 组号 = 1)
                           Select n_安排id As 安排id, B1.号源id, c_日期.日期 As 出诊日期, m.上班时段, m.Id As 限制id,
                                  To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') || To_Char(j.开始时间, 'hh24:mi:ss'),
                                           'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                  To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') || To_Char(j.终止时间, 'hh24:mi:ss'),
                                          'yyyy-mm-dd hh24:mi:ss') + Case
                                    When j.终止时间 <= j.开始时间 Then
                                     1
                                    Else
                                     0
                                  End As 终止时间, Null As 停诊开始时间, Null As 停诊终止时间, Null As 停诊原因,
                                  To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') || To_Char(Nvl(j.缺省时间, j.开始时间), 'hh24:mi:ss'),
                                          'yyyy-mm-dd hh24:mi:ss') + Case
                                    When j.缺省时间 < j.开始时间 Then
                                     1
                                    Else
                                     0
                                  End As 缺省预约时间,
                                  To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') || To_Char(Nvl(j.提前时间, j.开始时间), 'hh24:mi:ss'),
                                          'yyyy-mm-dd hh24:mi:ss') + Case
                                    When j.开始时间 < j.提前时间 Then
                                     -1
                                    Else
                                     0
                                  End As 提前挂号时间, m.限号数, 0 As 已挂数, m.限约数, 0 As 已约数, 0 As 其中已接收, m.是否序号控制, m.是否分时段, m.预约控制,
                                  m.是否独占, B1.项目id, B1.医生id, B1.医生姓名, Null As 替诊医生id, Null As 替诊医生姓名, m.分诊方式, m.诊室id,
                                  0 As 是否锁定, 0 As 是否临时出诊, v_操作员姓名 As 操作员姓名, d_登记日期 As 登记时间, c_日期.星期 As 限制项目
                           From 临床出诊安排 B1, 临床出诊限制 M, c_时间段 J
                           Where B1.Id = n_安排id And B1.Id = m.安排id And m.限制项目 = c_日期.星期 And m.上班时段 = j.时间段 And
                                 To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') || To_Char(j.开始时间, 'hh24:mi:ss'),
                                         'yyyy-mm-dd hh24:mi:ss') >= B1.开始时间) Loop
              Begin
                Select 1 Into n_Count From Table(l_固定时段) Where Column_Value = c_记录.上班时段;
              Exception
                When Others Then
                  n_Count := 0;
              End;
            
              If Nvl(n_Count, 0) = 0 Then
                Select 临床出诊记录_Id.Nextval Into n_记录id From Dual;
                Insert Into 临床出诊记录
                  (ID, 安排id, 号源id, 出诊日期, 上班时段, 开始时间, 终止时间, 停诊开始时间, 停诊终止时间, 停诊原因, 缺省预约时间, 提前挂号时间, 限号数, 已挂数, 限约数, 已约数,
                   其中已接收, 是否序号控制, 是否分时段, 预约控制, 是否独占, 项目id, 科室id, 医生id, 医生姓名, 替诊医生id, 替诊医生姓名, 分诊方式, 诊室id, 是否锁定, 是否临时出诊,
                   登记人, 登记时间, 是否发布)
                Values
                  (n_记录id, c_记录.安排id, c_记录.号源id, c_记录.出诊日期, c_记录.上班时段, c_记录.开始时间, c_记录.终止时间, c_记录.停诊开始时间, c_记录.停诊终止时间,
                   c_记录.停诊原因, c_记录.缺省预约时间, c_记录.提前挂号时间, c_记录.限号数, c_记录.已挂数, c_记录.限约数, c_记录.已约数, c_记录.其中已接收, c_记录.是否序号控制,
                   c_记录.是否分时段, c_记录.预约控制, c_记录.是否独占, c_记录.项目id, c_号源.科室id, c_记录.医生id, c_记录.医生姓名, c_记录.替诊医生id,
                   c_记录.替诊医生姓名, c_记录.分诊方式, c_记录.诊室id, c_记录.是否锁定, c_记录.是否临时出诊, c_记录.操作员姓名, d_登记日期, 1);
              
                --插入临床出诊序号控制
                If Nvl(c_记录.是否分时段, 0) = 1 And Nvl(c_记录.是否序号控制, 0) = 1 Then
                  --分时段且启用序号控制，使用"预约顺序号"记录"是否预约"
                  Insert Into 临床出诊序号控制
                    (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 预约顺序号)
                    Select n_记录id, 序号,
                           To_Date(To_Char(c_记录.出诊日期, 'yyyy-mm-dd ') || To_Char(开始时间, 'hh24:mi:ss'),
                                    'yyyy-mm-dd hh24:mi:ss'),
                           To_Date(To_Char(c_记录.出诊日期, 'yyyy-mm-dd ') || To_Char(终止时间, 'hh24:mi:ss'),
                                    'yyyy-mm-dd hh24:mi:ss') + Case
                              When 终止时间 <= 开始时间 Then
                               1
                              Else
                               0
                            End, 限制数量, 是否预约, 是否预约
                    From 临床出诊时段
                    Where 限制id = c_记录.限制id;
                Else
                  Insert Into 临床出诊序号控制
                    (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约)
                    Select n_记录id, 序号,
                           To_Date(To_Char(c_记录.出诊日期, 'yyyy-mm-dd ') || To_Char(开始时间, 'hh24:mi:ss'),
                                    'yyyy-mm-dd hh24:mi:ss'),
                           To_Date(To_Char(c_记录.出诊日期, 'yyyy-mm-dd ') || To_Char(终止时间, 'hh24:mi:ss'),
                                   'yyyy-mm-dd hh24:mi:ss') + Case
                             When 终止时间 <= 开始时间 Then
                              1
                             Else
                              0
                           End, 限制数量, 是否预约
                    From 临床出诊时段
                    Where 限制id = c_记录.限制id;
                End If;
              
                --插入合作单位挂号控制记录
                Insert Into 临床出诊挂号控制记录
                  (类型, 性质, 名称, 记录id, 序号, 控制方式, 数量)
                  Select 类型, 性质, 名称, n_记录id, 序号, 控制方式, 数量
                  From 临床出诊挂号控制
                  Where 限制id = c_记录.限制id;
              
                --插入临床出诊诊室记录
                Insert Into 临床出诊诊室记录
                  (记录id, 诊室id)
                  Select n_记录id, 诊室id From 临床出诊诊室 Where 限制id = c_记录.限制id;
              End If;
            End Loop;
          
            --根据停诊安排和法定节假日调整出诊记录的出诊/预约情况
            Zl_Clinicvisitmodify(c_号源.Id, n_安排id, c_日期.日期, v_操作员姓名, d_登记日期);
          End If;
        End If;
      End If;
      --一天一提交
      Commit;
    End Loop;
  End Loop;
End Zl1_Auto_Buildingregisterplan;
/

--103209:刘尔旋,2016-12-05,服务窗医保实时结算处理
Create Or Replace Procedure Zl_Third_Registdelcheck
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:HIS退号检查
  --入参:Xml_In:
  --<IN>
  --  <GHDH>A000001</GHDH>    //挂号单号
  --  <JSKLB>支付宝</JSKLB>      //结算卡类别
  --  <JCFP>1</JCFP>            //检查发票
  --  <GHJE>20</GHJE>            //挂号金额
  --  <LSH>34563</LSH>           //交易流水号
  --  <JKFS>0</JKFS>             //缴款方式,0-挂号或预约缴款;1-预约不缴款
  --  <YYFS></YYFS>              //缴款方式=1时传入，预约的预约方式
  --  <XL></XL>                  //险类
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  -- <ERROR><MSG></MSG></ERROR> //为空表示检查成功
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  v_卡类别     Varchar2(100);
  v_No         病人挂号记录.No%Type;
  n_挂号金额   门诊费用记录.实收金额%Type;
  v_操作员编号 门诊费用记录.操作员编号%Type;
  v_操作员姓名 门诊费用记录.操作员姓名%Type;
  v_结算方式   医疗卡类别.结算方式%Type;
  n_实收金额   门诊费用记录.实收金额%Type;
  v_交易流水号 病人预交记录.交易流水号%Type;
  n_存在       Number(3);
  v_Type       Varchar2(50);
  v_Temp       Varchar2(32767); --临时XML
  x_Templet    Xmltype; --模板XML
  v_Err_Msg    Varchar2(200);
  n_已开医嘱   Number(2);
  n_检查发票   Number(3);
  n_是否打印   Number(3);
  n_缴款方式   Number(3);
  n_险类       病人信息.险类%Type;
  v_预约方式   病人挂号记录.预约方式%Type;
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/GHDH'), Extractvalue(Value(A), 'IN/JSKLB'), Extractvalue(Value(A), 'IN/GHJE'),
         Extractvalue(Value(A), 'IN/LSH'), To_Number(Extractvalue(Value(A), 'IN/JCFP')),
         To_Number(Extractvalue(Value(A), 'IN/JKFS')), Extractvalue(Value(A), 'IN/YYFS'),
         To_Number(Extractvalue(Value(A), 'IN/XL'))
  Into v_No, v_卡类别, n_挂号金额, v_交易流水号, n_检查发票, n_缴款方式, v_预约方式, n_险类
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  n_缴款方式 := Nvl(n_缴款方式, 0);

  If v_卡类别 Is Not Null And n_缴款方式 = 0 Then
    Select Nvl2(Translate(v_卡类别, '\1234567890', '\'), 'Char', 'Num') Into v_Type From Dual;
    If v_Type = 'Num' Then
      --传入的是卡类别ID
      Select 结算方式 Into v_结算方式 From 医疗卡类别 Where ID = To_Number(v_卡类别);
    Else
      --传入的是卡类别名称
      Select 结算方式 Into v_结算方式 From 医疗卡类别 Where 名称 = v_卡类别;
    End If;
    If Nvl(n_缴款方式, 0) = 0 Then
      If Nvl(n_险类, 0) = 0 Then
        Select Nvl(Max(1), 0)
        Into n_存在
        From 病人预交记录 A,
             (Select Distinct 结帐id
               From 门诊费用记录
               Where NO = v_No And 记录性质 = 4
               Union
               Select Distinct 结帐id From 住院费用记录 Where NO = v_No And 记录性质 = 5) B
        Where a.结帐id = b.结帐id And 结算方式 <> v_结算方式 And Mod(记录性质, 10) <> 1 And Rownum < 2;
      Else
        Select Nvl(Max(1), 0)
        Into n_存在
        From 病人预交记录 A,
             (Select Distinct 结帐id
               From 门诊费用记录
               Where NO = v_No And 记录性质 = 4
               Union
               Select Distinct 结帐id From 住院费用记录 Where NO = v_No And 记录性质 = 5) B, 结算方式 C
        Where a.结帐id = b.结帐id And 结算方式 <> v_结算方式 And Mod(记录性质, 10) <> 1 And a.结算方式 = c.名称 And c.性质 Not In (3, 4) And
              Rownum < 2;
        If n_存在 = 0 Then
          Select Nvl(Max(1), 0)
          Into n_存在
          From 保险结算记录 A,
               (Select Distinct 结帐id
                 From 门诊费用记录
                 Where NO = v_No And 记录性质 = 4
                 Union
                 Select Distinct 结帐id From 住院费用记录 Where NO = v_No And 记录性质 = 5) B
          Where a.记录id = b.结帐id And 险类 <> n_险类 And Rownum < 2;
        End If;
      End If;
      If n_存在 = 1 Then
        v_Err_Msg := '传入的挂号单据包含' || v_结算方式 || '以外的结算方式,无法退号!';
        Raise Err_Item;
      End If;
    Else
      Begin
        Select 1 Into n_存在 From 病人挂号记录 A Where a.No = v_No And a.预约方式 = v_预约方式 And Rownum < 2;
      Exception
        When Others Then
          n_存在 := 0;
      End;
      If n_存在 = 0 Then
        v_Err_Msg := '传入的挂号单据不是' || v_预约方式 || '预约的,无法退号!';
        Raise Err_Item;
      End If;
    End If;
  End If;

  If n_缴款方式 = 0 Then
    Select Sum(实收金额) Into n_实收金额 From 门诊费用记录 Where NO = v_No And 记录性质 = 4;
    If n_实收金额 <> n_挂号金额 Then
      v_Err_Msg := '传入的退款金额与实际挂号金额不符，请检查!';
      Raise Err_Item;
    End If;
  End If;

  --补充结算检查，已存在补结算数据的，不能退号
  Begin
    Select 1
    Into n_存在
    From 费用补充记录 A,
         (Select Distinct 结帐id
           From 门诊费用记录
           Where NO = v_No And 记录性质 = 4
           Union
           Select Distinct 结帐id From 住院费用记录 Where NO = v_No And 记录性质 = 5) B
    Where a.收费结帐id = b.结帐id And a.记录性质 = 1 And a.附加标志 = 1 And Nvl(a.费用状态, 0) <> 2 And Rownum < 2;
  Exception
    When Others Then
      n_存在 := 0;
  End;
  If n_存在 = 1 Then
    v_Err_Msg := '传入的挂号单据已经进行了二次结算,无法退号!';
    Raise Err_Item;
  End If;
  --医嘱检查，已经开过医嘱的，不能退号
  Begin
    Select Distinct 1 Into n_已开医嘱 From 病人医嘱记录 Where 挂号单 = v_No;
  Exception
    When Others Then
      n_已开医嘱 := 0;
  End;
  If n_已开医嘱 = 1 Then
    v_Err_Msg := '传入的挂号单据已经开过医嘱,无法退号!';
    Raise Err_Item;
  End If;
  If Nvl(n_检查发票, 0) = 1 Then
    Select Max(Decode(a.实际票号, Null, 0, 1)) Into n_是否打印 From 门诊费用记录 A Where NO = v_No And 记录性质 = 4;
    If Nvl(n_是否打印, 0) = 1 Then
      v_Err_Msg := '本次退号的单据已开发票,不能退费!';
      Raise Err_Item;
    End If;
  End If;

  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Registdelcheck;
/

--103209:刘尔旋,2016-12-05,服务窗医保实时结算处理
Create Or Replace Procedure Zl_Third_Registdel
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:HIS退号
  --入参:Xml_In:
  --<IN>
  --  <GHDH>A000001</GHDH>    //挂号单号
  --  <JSKLB>支付宝</JSKLB>      //结算卡类别
  --  <JCFP>1</JCFP>            //检查发票
  --  <GHJE>20</GHJE>            //挂号金额
  --  <LSH>34563</LSH>           //交易流水号
  --  <JKFS>0</JKFS>             //缴款方式,0-挂号或预约缴款;1-预约不缴款
  --  <YYFS></YYFS>              //缴款方式=1时传入，预约的预约方式
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  -- <CZSJ>操作时间</CZSJ>          //HIS的登记时间
  -- <YJZID>原结帐ID</YJZID>
  -- <CXID>冲销ID</CXID>
  -- <ERROR><MSG></MSG></ERROR> //为空表示取消挂号成功
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  v_卡类别     Varchar2(100);
  v_No         病人挂号记录.No%Type;
  n_挂号金额   门诊费用记录.实收金额%Type;
  v_操作员编号 门诊费用记录.操作员编号%Type;
  v_操作员姓名 门诊费用记录.操作员姓名%Type;
  v_结算方式   医疗卡类别.结算方式%Type;
  n_实收金额   门诊费用记录.实收金额%Type;
  v_交易流水号 病人预交记录.交易流水号%Type;
  n_存在       Number(3);
  v_Type       Varchar2(50);
  v_Temp       Varchar2(32767); --临时XML
  x_Templet    Xmltype; --模板XML
  v_Err_Msg    Varchar2(200);
  n_已开医嘱   Number(2);
  n_检查发票   Number(3);
  n_是否打印   Number(3);
  n_缴款方式   Number(3);
  n_结帐id     门诊费用记录.结帐id%Type;
  n_冲销id     门诊费用记录.结帐id%Type;
  d_登记时间   Date;
  v_预约方式   病人挂号记录.预约方式%Type;
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/GHDH'), Extractvalue(Value(A), 'IN/JSKLB'), Extractvalue(Value(A), 'IN/GHJE'),
         Extractvalue(Value(A), 'IN/LSH'), To_Number(Extractvalue(Value(A), 'IN/JCFP')),
         To_Number(Extractvalue(Value(A), 'IN/JKFS')), Extractvalue(Value(A), 'IN/YYFS')
  Into v_No, v_卡类别, n_挂号金额, v_交易流水号, n_检查发票, n_缴款方式, v_预约方式
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  n_缴款方式 := Nvl(n_缴款方式, 0);

  If n_缴款方式 = 1 Then
    Begin
      Select 1 Into n_存在 From 门诊费用记录 Where NO = v_No And 记录性质 = 4 And 结帐id Is Not Null And Rownum < 2;
    Exception
      When Others Then
        n_存在 := 0;
    End;
    If n_存在 = 1 Then
      v_Err_Msg := '传入的挂号单据不是预约挂号单,无法取消预约!';
      Raise Err_Item;
    End If;
    Begin
      Select 1 Into n_存在 From 病人挂号记录 A Where a.No = v_No And a.预约方式 = v_预约方式 And Rownum < 2;
    Exception
      When Others Then
        n_存在 := 0;
    End;
    If n_存在 = 0 Then
      v_Err_Msg := '传入的挂号单据不是' || v_预约方式 || '预约的,无法取消预约!';
      Raise Err_Item;
    End If;
  End If;

  If v_卡类别 Is Not Null And n_缴款方式 = 0 Then
    Select Nvl2(Translate(v_卡类别, '\1234567890', '\'), 'Char', 'Num') Into v_Type From Dual;
    If v_Type = 'Num' Then
      --传入的是卡类别ID
      Select 结算方式 Into v_结算方式 From 医疗卡类别 Where ID = To_Number(v_卡类别);
    Else
      --传入的是卡类别名称
      Select 结算方式 Into v_结算方式 From 医疗卡类别 Where 名称 = v_卡类别;
    End If;
  
    Select Sum(实收金额) Into n_实收金额 From 门诊费用记录 Where NO = v_No And 记录性质 = 4;
  
    If Nvl(n_缴款方式, 0) = 0 Then
      --要退的单据不是以该结算卡结算的，则禁止退号
      Begin
        Select 1
        Into n_存在
        From 病人预交记录 A,
             (Select Distinct 结帐id
               From 门诊费用记录
               Where NO = v_No And 记录性质 = 4
               Union
               Select Distinct 结帐id From 住院费用记录 Where NO = v_No And 记录性质 = 5) B
        Where a.结帐id = b.结帐id And 结算方式 = v_结算方式 And Rownum < 2;
      Exception
        When Others Then
          n_存在 := 0;
      End;
      If n_存在 = 0 Then
        v_Err_Msg := '传入的挂号单据不是' || v_结算方式 || '结算的,无法退号!';
        Raise Err_Item;
      End If;
    End If;
  End If;

  --补充结算检查，已存在补结算数据的，不能退号
  Begin
    Select 1
    Into n_存在
    From 费用补充记录 A,
         (Select Distinct 结帐id
           From 门诊费用记录
           Where NO = v_No And 记录性质 = 4
           Union
           Select Distinct 结帐id From 住院费用记录 Where NO = v_No And 记录性质 = 5) B
    Where a.收费结帐id = b.结帐id And a.记录性质 = 1 And a.附加标志 = 1 And Nvl(a.费用状态, 0) <> 2 And Rownum < 2;
  Exception
    When Others Then
      n_存在 := 0;
  End;
  If n_存在 = 1 Then
    v_Err_Msg := '传入的挂号单据已经进行了二次结算,无法退号!';
    Raise Err_Item;
  End If;
  --医嘱检查，已经开过医嘱的，不能退号
  Begin
    Select Distinct 1 Into n_已开医嘱 From 病人医嘱记录 Where 挂号单 = v_No;
  Exception
    When Others Then
      n_已开医嘱 := 0;
  End;
  If n_已开医嘱 = 1 Then
    v_Err_Msg := '传入的挂号单据已经开过医嘱,无法退号!';
    Raise Err_Item;
  End If;
  If Nvl(n_检查发票, 0) = 1 Then
    Select Max(Decode(a.实际票号, Null, 0, 1)) Into n_是否打印 From 门诊费用记录 A Where NO = v_No And 记录性质 = 4;
    If Nvl(n_是否打印, 0) = 1 Then
      v_Err_Msg := '本次退号的单据已开发票,不能退费!';
      Raise Err_Item;
    End If;
  End If;
  --获取操作员信息
  v_Temp := Zl_Identity(1);
  Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_Temp From Dual;
  Select Substr(v_Temp, 0, Instr(v_Temp, ',') - 1) Into v_操作员编号 From Dual;
  Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_操作员姓名 From Dual;
  d_登记时间 := Sysdate;

  Zl_三方机构挂号_Delete(v_No, v_交易流水号, '移动平台退号', d_登记时间);

  Select Max(结帐id) Into n_结帐id From 门诊费用记录 Where NO = v_No And 记录性质 = 4 And 记录状态 = 3;
  Select Max(结帐id) Into n_冲销id From 门诊费用记录 Where NO = v_No And 记录性质 = 4 And 记录状态 = 2;

  v_Temp := '<CZSJ>' || To_Char(d_登记时间, 'YYYY-MM-DD hh24:mi:ss') || '</CZSJ>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  v_Temp := '<YJZID>' || n_结帐id || '</YJZID>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  v_Temp := '<CXID>' || n_冲销id || '</CXID>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;

  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Registdel;
/

--103209:刘尔旋,2016-12-12,服务窗医保实时结算处理
Create Or Replace Procedure Zl_Third_Regist
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:HIS挂号
  --入参:Xml_In:
  --<IN>
  --   <CZFS>3</CZFS>    //操作方式
  --   <CZJLID>1</CZJLID>    //出诊记录ID
  --   <HM>号码</HM>    //号码
  --   <HX>号序</HX>     //号序
  --   <JKFS>0</JKFS>  //缴款方式,0-挂号或预约缴款;1-预约不缴款
  --   <YYSJ>2014-10-21 </YYSJ>    //预约日期 YYYY-MM-DD,分时段非序号控制需要传入时间
  --   <JE>金额</JE>     //金额
  --   <JSLIST>
  --     <JS>            //结算信息，挂号非医保结算目前仅支持一个，结构与收费一致
  --       <JSKLB>结算卡类别</JSKLB>    //结算卡类别
  --       <JSKH>支付宝帐号</JSKH>           //结算卡号(支付宝帐号)
  --       <JYSM>交易说明</JYSM>            //说明，固定传支付宝
  --       <JYLSH>流水号</JYLSH>           //流水号，传订单号
  --       <JSFS>结算方式</JSFS>            //结算方式:现金、支票，如果是三方卡,可以传空
  --       <JSJE>结算金额</JSJE>            //结算金额
  --       <ZY>摘要</ZY>                  //摘要
  --       <SFCYJ></SFCYJ>              //是否冲预交，挂号目前不传
  --       <SFXFK></SFXFK>              //是否消费卡,挂号目前不传
  --       <EXPENDLIST>                 //扩展信息
  --         <EXPEND>
  --           <JYMC>交易名称</JYMC>        //交易名称
  --           <JYLR>交易内容<JYLR>         //交易内容
  --         </EXPEND>
  --         <EXPEND>
  --           ...
  --         </EXPEND>
  --       </EXPENDLIST>
  --     </JS>
  --   </JSLIST>
  --   <HZDW>合作单位</HZDW>        //合作单位名称
  --   <YYFS>支付宝<YYFS>    //预约方式,如自助机，支付宝
  --   <BRID>病人ID</BRID>     //病人ID
  --   <BRLX></BRLX>             //医保病人类型
  --   <FB>普通</FB>               //病人费别，可以不传
  --   <JQM>机器名</JQM>            //机器名
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  -- <GHDH>挂号单号</GHDH>          //挂号单号
  -- <CZSJ>操作时间</CZSJ>          //HIS的登记时间
  -- <JZID>结帐ID</JZID>          //本次结帐ID
  -- <ERROR><MSG>错误信息</MSG></ERROR>  //出错时返回
  --</ OUTPUT>
  --------------------------------------------------------------------------------------------------
  v_号码     挂号安排.号码%Type;
  d_发生时间 Date;
  d_原始时间 Date;
  d_登记时间 Date;
  v_金额     Varchar2(200);

  n_应收金额   门诊费用记录.应收金额%Type;
  v_流水号     病人预交记录.交易流水号%Type;
  v_说明       门诊费用记录.摘要%Type;
  n_病人id     病人信息.病人id%Type;
  v_预约方式   预约方式.名称%Type;
  v_卡类别名称 医疗卡类别.名称%Type;
  v_结算卡号   病人预交记录.卡号%Type;
  n_门诊号     门诊费用记录.标识号%Type;
  v_姓名       门诊费用记录.姓名%Type;
  v_性别       门诊费用记录.性别%Type;
  v_年龄       门诊费用记录.年龄%Type;
  v_付款方式   门诊费用记录.付款方式%Type;
  v_费别       门诊费用记录.费别%Type;
  v_No         病人挂号记录.No%Type;
  v_结算方式   医疗卡类别.结算方式%Type;
  v_收费类别   门诊费用记录.收费类别%Type;
  n_收费细目id 门诊费用记录.收费细目id%Type;
  n_标准单价   门诊费用记录.标准单价%Type;
  n_收入项目id 门诊费用记录.收入项目id%Type;
  n_屏蔽费别   收费项目目录.屏蔽费别%Type;
  v_收据费目   门诊费用记录.收据费目%Type;
  n_病人科室id 门诊费用记录.病人科室id%Type;
  n_开单部门id 门诊费用记录.开单部门id%Type;
  v_操作员编号 门诊费用记录.操作员编号%Type;
  v_操作员姓名 门诊费用记录.操作员姓名%Type;
  v_医生姓名   挂号安排.医生姓名%Type;
  n_医生id     挂号安排.医生id%Type;
  n_结帐id     门诊费用记录.结帐id%Type;
  n_卡类别id   医疗卡类别.Id%Type;
  v_排班       挂号安排.周日%Type;
  n_安排id     挂号安排.Id%Type;
  n_计划id     挂号安排计划.Id%Type;
  n_预交id     病人预交记录.Id%Type;
  n_序号控制   挂号安排.序号控制%Type;
  n_号序       挂号序号状态.序号%Type;
  v_星期       挂号安排限制.限制项目%Type;
  v_病人类型   病人信息.病人类型%Type;
  n_存在       Number(3);
  v_现金       结算方式.名称%Type;
  n_分时段     Number(3);
  v_结算内容   Varchar2(3000);
  v_合作单位   病人挂号记录.合作单位%Type;
  v_机器名     挂号序号状态.机器名%Type;
  n_缴款方式   Number(3);
  n_挂号模式   Number(3);
  n_普通结算   Number(3);
  n_Exists     Number(3);
  v_保险结算   Varchar2(1000);
  n_记录id     临床出诊记录.Id%Type;
  v_Temp       Varchar2(32767); --临时XML
  x_Templet    Xmltype; --模板XML
  v_Err_Msg    Varchar2(200);
  d_启用时间   Date;
  v_Para       Varchar2(2000);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/HM'), Extractvalue(Value(A), 'IN/HX'),
         To_Date(Extractvalue(Value(A), 'IN/YYSJ'), 'YYYY-MM-DD hh24:mi:ss'), Extractvalue(Value(A), 'IN/JE'),
         Extractvalue(Value(A), 'IN/YYFS'), Extractvalue(Value(A), 'IN/HZDW'), Extractvalue(Value(A), 'IN/BRID'),
         Extractvalue(Value(A), 'IN/BRLX'), Extractvalue(Value(A), 'IN/FB'), Extractvalue(Value(A), 'IN/JQM'),
         Extractvalue(Value(A), 'IN/JKFS'), Extractvalue(Value(A), 'IN/CZJLID')
  Into v_号码, n_号序, d_原始时间, n_应收金额, v_预约方式, v_合作单位, n_病人id, v_病人类型, v_费别, v_机器名, n_缴款方式, n_记录id
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  v_Para     := zl_GetSysParameter(256);
  n_挂号模式 := Substr(v_Para, 1, 1);
  Begin
    d_启用时间 := To_Date(Substr(v_Para, 3), 'yyyy-mm-dd hh24:mi:ss');
  Exception
    When Others Then
      d_启用时间 := Null;
  End;

  If Sysdate - 10 > Nvl(d_启用时间, Sysdate - 30) Then
    If n_挂号模式 = 1 And Nvl(d_原始时间, Sysdate) > Nvl(d_启用时间, Sysdate - 30) And n_记录id Is Null Then
      v_Err_Msg := '系统当前处于出诊表排班模式，传入的参数无法确定挂号安排，请重试！';
      Raise Err_Item;
    End If;
  Else
    If n_挂号模式 = 1 And Nvl(d_原始时间, Sysdate) > Nvl(d_启用时间, Sysdate - 30) And n_记录id Is Null Then
      Begin
        Select a.Id
        Into n_记录id
        From 临床出诊记录 A, 临床出诊号源 B
        Where a.号源id = b.Id And b.号码 = v_号码 And Nvl(d_原始时间, Sysdate) Between a.开始时间 And a.终止时间;
      Exception
        When Others Then
          v_Err_Msg := '系统当前处于出诊表排班模式，传入的参数无法确定挂号安排，请重试！';
          Raise Err_Item;
      End;
    End If;
  End If;

  d_登记时间 := Sysdate;
  d_发生时间 := Trunc(d_原始时间);
  If v_病人类型 Is Not Null Then
    Begin
      Select 1 Into n_存在 From 病人类型 Where 名称 = v_病人类型;
    Exception
      When Others Then
        v_Err_Msg := '没有发现为(' || v_病人类型 || ')的病人类型';
        Raise Err_Item;
    End;
    Update 病人信息 Set 病人类型 = Nvl(病人类型, v_病人类型) Where 病人id = n_病人id;
  End If;

  Select a.门诊号, a.姓名, a.性别, a.年龄, Nvl(b.编码, c.编码)
  Into n_门诊号, v_姓名, v_性别, v_年龄, v_付款方式
  From 病人信息 A, 医疗付款方式 B, (Select 编码 From 医疗付款方式 Where 缺省标志 = '1' And Rownum < 2) C
  Where a.病人id = n_病人id And a.医疗付款方式 = b.名称(+);
  v_No   := Nextno(12);
  v_Temp := Zl_Identity(1);
  Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_Temp From Dual;
  Select Substr(v_Temp, 0, Instr(v_Temp, ',') - 1) Into v_操作员编号 From Dual;
  Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_操作员姓名 From Dual;
  v_Temp := Zl_Identity(2);
  Select Substr(v_Temp, 0, Instr(v_Temp, ',') - 1) Into n_开单部门id From Dual;

  If n_记录id Is Null Then
    n_普通结算 := 0;
    For r_结算 In (Select Extractvalue(b.Column_Value, '/JS/JSKLB') As 结算卡类别,
                        Extractvalue(b.Column_Value, '/JS/JSKH') As 结算卡号,
                        Extractvalue(b.Column_Value, '/JS/JSFS') As 结算方式,
                        Extractvalue(b.Column_Value, '/JS/JYLSH') As 交易流水号,
                        Extractvalue(b.Column_Value, '/JS/JYSM') As 交易说明,
                        Extractvalue(b.Column_Value, '/JS/JSJE') As 结算金额
                 From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B) Loop
      If r_结算.结算方式 Is Null Then
        Begin
          Select b.结算方式, b.Id
          Into v_结算方式, n_卡类别id
          From 医疗卡类别 B
          Where b.名称 = r_结算.结算卡类别 And Rownum < 2;
        Exception
          When Others Then
            v_Err_Msg := '没有发现该结算卡的相关信息';
            Raise Err_Item;
        End;
      Else
        Select Nvl(Max(1), 0) Into n_Exists From 结算方式 Where 名称 = r_结算.结算方式 And 性质 In (3, 4);
        If n_Exists = 1 Then
          v_保险结算 := v_保险结算 || '||' || r_结算.结算方式 || '|' || r_结算.结算金额;
        Else
          If v_结算方式 Is Null Then
            v_结算方式 := r_结算.结算方式;
          Else
            v_Err_Msg := '目前计划排班挂号不支持非医保外的多种结算方式,请检查!';
            Raise Err_Item;
          End If;
        End If;
      End If;
      If r_结算.结算卡类别 Is Not Null Then
        v_卡类别名称 := r_结算.结算卡类别;
        v_结算卡号   := r_结算.结算卡号;
        v_流水号     := r_结算.交易流水号;
        v_说明       := r_结算.交易说明;
        If n_卡类别id Is Null Then
          Begin
            Select b.Id Into n_卡类别id From 医疗卡类别 B Where b.名称 = r_结算.结算卡类别 And Rownum < 2;
          Exception
            When Others Then
              v_Err_Msg := '没有发现该结算卡的相关信息';
              Raise Err_Item;
          End;
        End If;
      End If;
    End Loop;
    If v_保险结算 Is Not Null Then
      v_保险结算 := Substr(v_保险结算, 3);
    End If;
  
    Select Decode(To_Char(d_原始时间, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六',
                   Null)
    Into v_星期
    From Dual;
    Begin
      Select ID
      Into n_计划id
      From (Select ID
             From 挂号安排计划
             Where 号码 = v_号码 And d_原始时间 Between Nvl(生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                   Nvl(失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And 审核时间 Is Not Null
             Order By 生效时间 Desc)
      Where Rownum < 2;
    Exception
      When Others Then
        Select ID Into n_安排id From 挂号安排 Where 号码 = v_号码;
    End;
    If Nvl(n_计划id, 0) <> 0 Then
      --从计划读取信息
      Select a.项目id, b.科室id, a.医生姓名, a.医生id,
             Decode(To_Char(d_发生时间, 'D'), '1', a.周日, '2', a.周一, '3', a.周二, '4', a.周三, '5', a.周四, '6', a.周五, '7', a.周六,
                     Null), Nvl(a.序号控制, 0)
      Into n_收费细目id, n_病人科室id, v_医生姓名, n_医生id, v_排班, n_序号控制
      From 挂号安排计划 A, 挂号安排 B
      Where a.Id = n_计划id And b.Id = a.安排id;
      Select Count(Rownum) Into n_分时段 From 挂号计划时段 Where 星期 = v_星期 And 计划id = n_计划id And Rownum < 2;
      --合作单位检查
      If v_合作单位 Is Not Null Then
        Begin
          Select 1 Into n_存在 From 合作单位计划控制 Where 计划id = n_计划id And 数量 = 0 And 合作单位 = v_合作单位;
        Exception
          When Others Then
            n_存在 := 0;
        End;
      End If;
      If n_存在 = 1 Then
        v_Err_Msg := '传入的合作单位在此号码上被禁用！';
        Raise Err_Item;
      End If;
      If n_分时段 = 1 And n_序号控制 = 0 Then
        d_发生时间 := d_原始时间;
        Select 序号
        Into n_号序
        From 挂号计划时段
        Where 计划id = n_计划id And 星期 = v_星期 And To_Char(开始时间, 'hh24:mi:ss') = To_Char(d_发生时间, 'hh24:mi:ss');
      Else
        Begin
          Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || '' || To_Char(开始时间, 'hh24:mi:ss'), 'YYYY-MM-DD hh24:mi:ss')
          Into d_发生时间
          From 挂号计划时段
          Where 计划id = n_计划id And 星期 = v_星期 And 序号 = Nvl(n_号序, 0);
        Exception
          When Others Then
            If n_分时段 = 1 And n_序号控制 = 1 Then
              Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || '' || To_Char(Max(结束时间), 'hh24:mi:ss'),
                              'YYYY-MM-DD hh24:mi:ss')
              Into d_发生时间
              From 挂号计划时段
              Where 计划id = n_计划id And 星期 = v_星期;
            Else
              Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || '' || To_Char(开始时间, 'hh24:mi:ss'), 'YYYY-MM-DD hh24:mi:ss')
              Into d_发生时间
              From 时间段
              Where 时间段 = v_排班;
            End If;
            If d_发生时间 < d_登记时间 Then
              d_发生时间 := d_登记时间;
            End If;
        End;
      End If;
    Else
      --从安排读取信息
      Select b.项目id, b.科室id, b.医生姓名, b.医生id,
             Decode(To_Char(d_发生时间, 'D'), '1', b.周日, '2', b.周一, '3', b.周二, '4', b.周三, '5', b.周四, '6', b.周五, '7', b.周六,
                     Null), Nvl(b.序号控制, 0)
      Into n_收费细目id, n_病人科室id, v_医生姓名, n_医生id, v_排班, n_序号控制
      From 挂号安排 B
      Where b.Id = n_安排id;
      Select Count(Rownum) Into n_分时段 From 挂号安排时段 Where 星期 = v_星期 And 安排id = n_安排id And Rownum < 2;
      --合作单位检查
      If v_合作单位 Is Not Null Then
        Begin
          Select 1 Into n_存在 From 合作单位安排控制 Where 安排id = n_安排id And 数量 = 0 And 合作单位 = v_合作单位;
        Exception
          When Others Then
            n_存在 := 0;
        End;
      End If;
      If n_存在 = 1 Then
        v_Err_Msg := '传入的合作单位在此号码上被禁用！';
        Raise Err_Item;
      End If;
      If n_分时段 = 1 And n_序号控制 = 0 Then
        d_发生时间 := d_原始时间;
        Select 序号
        Into n_号序
        From 挂号安排时段
        Where 安排id = n_安排id And 星期 = v_星期 And To_Char(开始时间, 'hh24:mi:ss') = To_Char(d_发生时间, 'hh24:mi:ss');
      Else
        Begin
          Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || '' || To_Char(开始时间, 'hh24:mi:ss'), 'YYYY-MM-DD hh24:mi:ss')
          Into d_发生时间
          From 挂号安排时段
          Where 安排id = n_安排id And 星期 = v_星期 And 序号 = Nvl(n_号序, 0);
        Exception
          When Others Then
            If n_分时段 = 1 And n_序号控制 = 1 Then
              Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || '' || To_Char(Max(结束时间), 'hh24:mi:ss'),
                              'YYYY-MM-DD hh24:mi:ss')
              Into d_发生时间
              From 挂号安排时段
              Where 安排id = n_安排id And 星期 = v_星期;
            Else
              Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || '' || To_Char(开始时间, 'hh24:mi:ss'), 'YYYY-MM-DD hh24:mi:ss')
              Into d_发生时间
              From 时间段
              Where 时间段 = v_排班;
            End If;
            If d_发生时间 < d_登记时间 Then
              d_发生时间 := d_登记时间;
            End If;
        End;
      End If;
    End If;
  
    Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
    Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
  
    If Trunc(d_发生时间) <> Trunc(Sysdate) Then
      If Nvl(n_缴款方式, 0) = 0 Then
        Zl_三方机构挂号_Insert(3, n_病人id, v_号码, n_号序, v_No, Null, v_结算方式, Null, d_发生时间, d_登记时间, v_合作单位, n_应收金额, Null, Null,
                         v_流水号, v_说明, v_预约方式, n_预交id, n_卡类别id, Null, 1, n_结帐id, 0, Null, Null, v_结算卡号, 1, v_费别, Null,
                         v_机器名, 1);
      Else
        Zl_三方机构挂号_Insert(2, n_病人id, v_号码, n_号序, v_No, Null, v_结算方式, Null, d_发生时间, d_登记时间, v_合作单位, n_应收金额, Null, Null,
                         v_流水号, v_说明, v_预约方式, n_预交id, n_卡类别id, Null, 1, n_结帐id, 0, Null, Null, v_结算卡号, 1, v_费别, Null,
                         v_机器名, 1);
      End If;
    Else
      If Nvl(n_缴款方式, 0) = 0 Then
        Zl_三方机构挂号_Insert(1, n_病人id, v_号码, n_号序, v_No, Null, v_结算方式, Null, d_发生时间, d_登记时间, v_合作单位, n_应收金额, Null, Null,
                         v_流水号, v_说明, v_预约方式, n_预交id, n_卡类别id, Null, 1, n_结帐id, 0, Null, Null, v_结算卡号, 1, v_费别, Null,
                         v_机器名, 1);
      Else
        Zl_三方机构挂号_Insert(2, n_病人id, v_号码, n_号序, v_No, Null, v_结算方式, Null, d_发生时间, d_登记时间, v_合作单位, n_应收金额, Null, Null,
                         v_流水号, v_说明, v_预约方式, n_预交id, n_卡类别id, Null, 1, n_结帐id, 0, Null, Null, v_结算卡号, 1, v_费别, Null,
                         v_机器名, 1);
      End If;
    End If;
  
    For c_扩展信息 In (Select Extractvalue(b.Column_Value, '/EXPEND/JYMC') As 交易名称,
                          Extractvalue(b.Column_Value, '/EXPEND/JYLR') As 交易内容
                   From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS/EXPENDLIST/EXPEND'))) B) Loop
      Zl_三方结算交易_Insert(n_卡类别id, 0, v_结算卡号, n_结帐id, c_扩展信息.交易名称 || '|' || c_扩展信息.交易内容, 0);
    End Loop;
  
    v_Temp := '<GHDH>' || v_No || '</GHDH>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    v_Temp := '<CZSJ>' || To_Char(d_登记时间, 'YYYY-MM-DD hh24:mi:ss') || '</CZSJ>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    v_Temp := '<JZID>' || n_结帐id || '</JZID>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Else
    --出诊表排班模式
    For r_结算 In (Select Extractvalue(b.Column_Value, '/JS/JSKLB') As 结算卡类别,
                        Extractvalue(b.Column_Value, '/JS/JSKH') As 结算卡号,
                        Extractvalue(b.Column_Value, '/JS/JSFS') As 结算方式,
                        Extractvalue(b.Column_Value, '/JS/JYLSH') As 交易流水号,
                        Extractvalue(b.Column_Value, '/JS/JYSM') As 交易说明,
                        Extractvalue(b.Column_Value, '/JS/JSJE') As 结算金额
                 From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B) Loop
      If r_结算.结算方式 Is Null Then
        Begin
          Select b.结算方式, b.Id
          Into v_结算方式, n_卡类别id
          From 医疗卡类别 B
          Where b.名称 = r_结算.结算卡类别 And Rownum < 2;
        Exception
          When Others Then
            v_Err_Msg := '没有发现该结算卡的相关信息';
            Raise Err_Item;
        End;
        v_结算内容 := v_结算内容 || '|' || v_结算方式 || ',' || r_结算.结算金额 || ',,';
      Else
        v_结算内容 := v_结算内容 || '|' || r_结算.结算方式 || ',' || r_结算.结算金额 || ',,';
      End If;
      If r_结算.结算卡类别 Is Not Null Then
        v_结算内容   := v_结算内容 || '1';
        v_卡类别名称 := r_结算.结算卡类别;
        v_结算卡号   := r_结算.结算卡号;
        v_流水号     := r_结算.交易流水号;
        v_说明       := r_结算.交易说明;
        If n_卡类别id Is Null Then
          Begin
            Select b.Id Into n_卡类别id From 医疗卡类别 B Where b.名称 = r_结算.结算卡类别 And Rownum < 2;
          Exception
            When Others Then
              v_Err_Msg := '没有发现该结算卡的相关信息';
              Raise Err_Item;
          End;
        End If;
      Else
        v_结算内容 := v_结算内容 || '0';
      End If;
    End Loop;
    If v_结算内容 Is Not Null Then
      v_结算内容 := Substr(v_结算内容, 2);
    Else
      Begin
        Select 名称 Into v_现金 From 结算方式 Where 性质 = 1;
      Exception
        When Others Then
          v_现金 := '现金';
      End;
      v_结算内容 := v_现金 || ',' || 0 || ',,0';
    End If;
    Select 项目id, 科室id, 医生姓名, 医生id, 是否序号控制, 是否分时段
    Into n_收费细目id, n_病人科室id, v_医生姓名, n_医生id, n_序号控制, n_分时段
    From 临床出诊记录
    Where ID = n_记录id;
  
    Begin
      Select 开始时间 Into d_发生时间 From 临床出诊序号控制 Where 记录id = n_记录id And 序号 = n_号序;
    Exception
      When Others Then
        d_发生时间 := d_原始时间;
    End;
  
    Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
    Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
  
    If Trunc(d_发生时间) <> Trunc(Sysdate) Then
      If Nvl(n_缴款方式, 0) = 0 Then
        Zl_三方机构挂号_Insert(3, n_病人id, v_号码, n_号序, v_No, Null, v_结算内容, Null, d_发生时间, d_登记时间, v_合作单位, n_应收金额, Null, Null,
                         v_流水号, v_说明, v_预约方式, n_预交id, n_卡类别id, Null, 1, n_结帐id, 0, v_保险结算, Null, v_结算卡号, 1, v_费别, Null,
                         v_机器名, 1, 0, n_记录id);
      Else
        Zl_三方机构挂号_Insert(2, n_病人id, v_号码, n_号序, v_No, Null, v_结算内容, Null, d_发生时间, d_登记时间, v_合作单位, n_应收金额, Null, Null,
                         v_流水号, v_说明, v_预约方式, n_预交id, n_卡类别id, Null, 1, n_结帐id, 0, v_保险结算, Null, v_结算卡号, 1, v_费别, Null,
                         v_机器名, 1, 0, n_记录id);
      End If;
    Else
      If Nvl(n_缴款方式, 0) = 0 Then
        Zl_三方机构挂号_Insert(1, n_病人id, v_号码, n_号序, v_No, Null, v_结算内容, Null, d_发生时间, d_登记时间, v_合作单位, n_应收金额, Null, Null,
                         v_流水号, v_说明, v_预约方式, n_预交id, n_卡类别id, Null, 1, n_结帐id, 0, v_保险结算, Null, v_结算卡号, 1, v_费别, Null,
                         v_机器名, 1, 0, n_记录id);
      Else
        Zl_三方机构挂号_Insert(2, n_病人id, v_号码, n_号序, v_No, Null, v_结算内容, Null, d_发生时间, d_登记时间, v_合作单位, n_应收金额, Null, Null,
                         v_流水号, v_说明, v_预约方式, n_预交id, n_卡类别id, Null, 1, n_结帐id, 0, v_保险结算, Null, v_结算卡号, 1, v_费别, Null,
                         v_机器名, 1, 0, n_记录id);
      End If;
    End If;
  
    For c_扩展信息 In (Select Extractvalue(b.Column_Value, '/EXPEND/JYMC') As 交易名称,
                          Extractvalue(b.Column_Value, '/EXPEND/JYLR') As 交易内容
                   From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS/EXPENDLIST/EXPEND'))) B) Loop
      Zl_三方结算交易_Insert(n_卡类别id, 0, v_结算卡号, n_结帐id, c_扩展信息.交易名称 || '|' || c_扩展信息.交易内容, 0);
    End Loop;
  
    v_Temp := '<GHDH>' || v_No || '</GHDH>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    v_Temp := '<CZSJ>' || To_Char(d_登记时间, 'YYYY-MM-DD hh24:mi:ss') || '</CZSJ>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    v_Temp := '<JZID>' || n_结帐id || '</JZID>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  End If;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Regist;
/

--103209:刘尔旋,2016-12-05,服务窗医保实时结算处理
Create Or Replace Procedure Zl_Third_Paymentinfo
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  -------------------------------------------------------------------------------------------------- 
  --功能:获取指定单据交易信息 
  --入参:Xml_In: 
  --<IN>
  --    <DJ>单据号,性质|....</DJ> //可以传入多个单据
  --    <JSKLB>结算卡类别</JSKLB>
  --    <XL>险类</XL>          //为空代表普通病人
  --</IN>
  --出参:Xml_Out
  --<OUTPUT>
  --<DJ>  //如果为空表示没有找到数据
  --    <DJH>单据号</DJH>
  --    <JLXZ>记录性质</JLXZ>   
  --    <YSJE>应收金额</YSJE>
  --    <SSJE>实收金额</SSJE>
  --    <FYMC>收据费目</FYMC> //(多个用逗号分离 )
  --    <JSKZF>结算卡支付</JSKZF> //:0-不是结算卡支付;1-结算卡支付(入参中:JSKLB判断,存在该类别支付的,返回1,否则返回0)
  --    <FKSJ>付款时间</FKSJ>
  --    <JYLSH>交易流水号</JYLSH> //(非结算卡支付的，不返回)
  --    <YXTK>是否允许退款</YXTK>            //0不允许1允许
  --    <YBJS>医保是否结算</YBJS>   //1-已结算;0-未结算
  --    <KP>是否开票</KP>  1是0否
  --    <SQZT>退费申请状态</SQZT>                  //退费申请状态,0-未申请,1-申请中,2-审核通过,3-审核未通过
  --    <JZTFSM>禁止退款说明</JZTFSM>
  --    <YJZID>结帐ID</YJZID>                  //已收费单据的结帐ID
  --</DJ>
  --<ERROR><MSG></MSG></ERROR>          //错误情况返回
  --</OUTPUT>
  -------------------------------------------------------------------------------------------------- 
  v_Err_Msg Varchar2(200);
  Err_Item Exception;

  x_Templet      Xmltype; --模板XML 
  v_No           Varchar2(4000);
  v_结算卡类别   Varchar2(100);
  n_结算卡类别id 医疗卡类别.Id%Type;

  n_Temp       Number(18);
  n_Mark       Number(5);
  v_Temp       Varchar2(32767); --临时XML 
  v_交易流水号 病人预交记录.交易流水号%Type;
  n_医保结算   Number(2);
  n_允许退款   Number(2);
  n_退费状态   病人退费申请.状态%Type;
  v_审核原因   病人退费申请.审核原因%Type;
  v_说明       Varchar2(100);
  n_补结算     Number(18);
  v_结算方式   结算方式.名称%Type;
  n_已开医嘱   Number(2);
  n_险类       病人信息.险类%Type;

Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/DJ'), Extractvalue(Value(A), 'IN/JSKLB'),
         To_Number(Extractvalue(Value(A), 'IN/XL'))
  Into v_No, v_结算卡类别, n_险类
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  If v_No Is Null Then
    v_Err_Msg := '不能找到指定的收费单据(当前单据为空)';
    Raise Err_Item;
  End If;
  If v_结算卡类别 Is Not Null Then
    v_Err_Msg := Null;
    Begin
      n_结算卡类别id := To_Number(v_结算卡类别);
    Exception
      When Others Then
        n_结算卡类别id := 0;
    End;
    If Nvl(n_结算卡类别id, 0) = 0 Then
      Begin
        Select ID, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 结算方式
        Into n_结算卡类别id, v_Err_Msg, v_结算方式
        From 医疗卡类别
        Where 名称 = v_结算卡类别;
      Exception
        When Others Then
          n_结算卡类别id := 0;
          v_Err_Msg      := v_结算卡类别 || '不存在!';
      End;
    Else
      Begin
        Select ID, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 结算方式
        Into n_结算卡类别id, v_Err_Msg, v_结算方式
        From 医疗卡类别
        Where ID = n_结算卡类别id;
      Exception
        When Others Then
          n_结算卡类别id := 0;
          v_Err_Msg      := '未找到指定的结算支付信息!';
      End;
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
  End If;

  For c_收费单 In (Select /*+ rule*/
                 记录性质, NO, Sum(应收金额) As 应收金额, Sum(实收金额) As 实收金额, Max(收款时间) As 收款时间, Max(结帐id) As 结帐id, Max(是否退款) As 是否退款,
                 Max(是否打印) As 是否打印, Max(记录状态) As 记录状态, f_List2str(Cast(Collect(收据费目) As t_Strlist)) As 收据费目,
                 Max(挂号单) As 挂号单
                
                From (Select 记录性质, NO, 收据费目, Sum(应收金额) As 应收金额, Sum(实收金额) As 实收金额,
                              To_Char(Max(登记时间), 'yyyy-mm-dd hh24:mi:ss') As 收款时间, Max(结帐id) As 结帐id,
                              Max(Decode(Nvl(a.执行状态, 0), 1, 0, 1)) As 是否退款, Max(Decode(a.实际票号, Null, 0, 1)) 是否打印,
                              Max(a.记录状态) As 记录状态, Max(Decode(Instr(摘要, '挂号:'), 0, '', Replace(摘要, '挂号:', ''))) As 挂号单
                       From 门诊费用记录 A, Table(f_Str2list2(v_No, '|', ',')) B
                       Where a.No = b.C1 And a.记录性质 = b.C2 And 记录状态 In (1, 3)
                       Group By 记录性质, NO, 收据费目
                       Order By 记录性质, NO, 收据费目)
                Group By 记录性质, NO) Loop
    n_Temp := 0;
    If n_结算卡类别id <> 0 Then
      Begin
        Select 交易流水号, 1
        Into v_交易流水号, n_Temp
        From 病人预交记录
        Where 卡类别id = n_结算卡类别id And 结帐id = Nvl(c_收费单.结帐id, 0);
      Exception
        When Others Then
          n_Temp := 0;
      End;
    
    End If;
    Begin
      Select Count(*) Into n_补结算 From 费用补充记录 Where 收费结帐id = Nvl(c_收费单.结帐id, 0) And Rownum < 2;
    Exception
      When Others Then
        n_补结算 := 0;
    End;
  
    Select Decode(Nvl(Count(*), 0), 0, 0, 1)
    Into n_医保结算
    From 保险结算记录
    Where 性质 = 1 And 记录id = Nvl(c_收费单.结帐id, 0);
  
    n_允许退款 := Nvl(c_收费单.是否退款, 0);
    n_已开医嘱 := 0;
  
    If c_收费单.挂号单 Is Not Null Then
      Begin
        Select 1 Into n_已开医嘱 From 病人医嘱记录 Where 挂号单 = c_收费单.挂号单;
      Exception
        When Others Then
          n_已开医嘱 := 0;
      End;
      If Nvl(n_已开医嘱, 0) = 1 Then
        n_允许退款 := 0;
      End If;
    End If;
    If Nvl(n_已开医嘱, 0) = 1 Then
      v_说明 := '挂号单已开医嘱';
    Elsif Nvl(n_允许退款, 0) = 0 Then
      v_说明 := '单据已经执行';
    End If;
  
    If n_险类 Is Null Then
      Select Nvl(Max(1), 0) Into n_Mark From 病人预交记录 A Where a.结帐id = c_收费单.结帐id And a.结算方式 <> v_结算方式;
    
      If Nvl(n_医保结算, 0) = 1 Then
        v_说明     := '单据已经医保结算';
        n_允许退款 := 0;
      End If;
    Else
      Select Nvl(Max(1), 0)
      Into n_Mark
      From 病人预交记录 A, 结算方式 B
      Where a.结帐id = c_收费单.结帐id And a.结算方式 <> v_结算方式 And a.结算方式 = b.名称 And b.性质 Not In (3, 4);
      If n_Mark = 0 Then
        Select Nvl(Max(1), 0) Into n_Mark From 保险结算记录 A Where a.记录id = c_收费单.结帐id And 险类 <> n_险类;
      End If;
    End If;
    If Nvl(n_Mark, 0) = 1 Then
      v_说明     := '该单据包含不能退费的结算方式';
      n_允许退款 := 0;
    End If;
  
    If Nvl(n_补结算, 0) <> 0 Then
      v_说明     := '单据已经补充结算';
      n_允许退款 := 0;
      n_医保结算 := 1;
    End If;
  
    If Nvl(n_允许退款, 0) = 1 Then
      --检查是否有可退数量
      Select Decode(Nvl(Count(*), 0), 0, 0, 1)
      Into n_允许退款
      From (Select 序号, Sum(Nvl(付数, 0) * 数次) As 数量
             From 门诊费用记录 A
             Where NO = c_收费单.No And Mod(记录性质, 10) = c_收费单.记录性质 And 价格父号 Is Null Having Sum(Nvl(付数, 0) * 数次) <> 0
             Group By 序号);
      If Nvl(c_收费单.记录状态, 0) = 3 And n_允许退款 = 0 Then
        v_说明     := '单据已全退';
        n_允许退款 := 0;
      Elsif Nvl(c_收费单.记录状态, 0) = 3 Then
        v_说明     := '单据已部分退费';
        n_允许退款 := 0;
      End If;
    End If;
  
    If Nvl(n_允许退款, 0) = 1 And Nvl(c_收费单.是否打印, 0) = 1 Then
      v_说明     := '单据已开发票';
      n_允许退款 := 0;
    End If;
  
    Begin
      Select 状态, 审核原因
      Into n_退费状态, v_审核原因
      From 病人退费申请
      Where NO = c_收费单.No And Mod(记录性质, 10) = Mod(c_收费单.记录性质, 10);
    Exception
      When Others Then
        n_退费状态 := -1;
        v_审核原因 := '';
    End;
    n_退费状态 := n_退费状态 + 1;
    If n_退费状态 = 3 Then
      v_说明     := v_审核原因;
      n_允许退款 := 0;
    End If;
  
    v_Temp := '<DJH>' || c_收费单.No || '</DJH>';
    v_Temp := v_Temp || '<JLXZ>' || c_收费单.记录性质 || '</JLXZ>';
    v_Temp := v_Temp || '<YSJE>' || c_收费单.应收金额 || '</YSJE>';
    v_Temp := v_Temp || '<SSJE>' || c_收费单.实收金额 || '</SSJE>';
    v_Temp := v_Temp || '<FYMC>' || c_收费单.收据费目 || '</FYMC>';
    v_Temp := v_Temp || '<FKSJ>' || c_收费单.收款时间 || '</FKSJ>';
    v_Temp := v_Temp || '<JSKZF>' || n_Temp || '</JSKZF>';
    v_Temp := v_Temp || '<JYLSH>' || Nvl(v_交易流水号, '') || '</JYLSH>';
    v_Temp := v_Temp || '<YXTK>' || Nvl(n_允许退款, 0) || '</YXTK>';
    v_Temp := v_Temp || '<YBJS>' || n_医保结算 || '</YBJS>';
    v_Temp := v_Temp || '<KP>' || Nvl(c_收费单.是否打印, 0) || '</KP>';
    v_Temp := v_Temp || '<SQZT>' || n_退费状态 || '</SQZT>';
    v_Temp := v_Temp || '<JZTFSM>' || v_说明 || '</JZTFSM>';
    v_Temp := v_Temp || '<YJZID>' || c_收费单.结帐id || '</YJZID>';
    v_Temp := '<DJ>' || v_Temp || '</DJ>';
  
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  End Loop;

  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Paymentinfo;
/

--103209:刘尔旋,2016-12-05,服务窗医保实时结算处理
Create Or Replace Procedure Zl_Third_Getregfeedetail
(
  Xml_In  In Xmltype,
  Xml_Out In Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取挂号费用明细
  --入参:Xml_In:
  --<IN>
  --  <BRID></BRID> //病人ID
  --  <SFYY></SFYY> //是否仅预约不支付,1-仅预约不支付,0-挂号,预约支付,预约接收，默认为0
  --  <GHDH></GHDH> //挂号单号,预约接收时传入
  --  <GHHM></GHHM> //挂号安排号码,挂号和预约时传入
  --  <XMID></XMID> //挂号安排的项目ID,挂号和预约时传入
  --  <FB></FB>     //病人费别
  --  <ZD></ZD>     //站点
  --</IN>
  --出参:Xml_Out
  -- <OUTPUT>
  --  <ZJE></ZJE>   //总实收金额
  --  <XMMX>        //项目明细
  --    <XM>
  --      <DJH></DJH>       //单据号
  --      <MC></MC>   //项目名称
  --      <ID></ID>   //项目ID
  --      <SL></SL>   //数量，数次*付数
  --      <YSJE></YSJE>   //应收金额
  --      <SSJE></SSJE>   //实收金额
  --      <SJFM></SJFM>       //收据费目
  --    </XM>
  --    <XM>
  --    ...
  --    </XM>
  --  </XMMX>
  -- </OUTPUT>

  --------------------------------------------------------------------------------------------------
  x_Templet    Xmltype; --模板XML
  v_Err_Msg    Varchar2(200);
  v_Temp       Varchar2(4000);
  n_项目id     挂号安排.项目id%Type;
  v_No         门诊费用记录.No%Type;
  n_预约       Number(3);
  n_病人id     病人信息.病人id%Type;
  v_费别       病人信息.费别%Type;
  v_站点       部门表.站点%Type;
  v_号码       挂号安排.号码%Type;
  n_总金额     门诊费用记录.实收金额%Type;
  n_实收金额   门诊费用记录.实收金额%Type;
  v_实收       Varchar(500);
  v_附加项目id Varchar2(500);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');
  Select Extractvalue(Value(A), 'IN/BRID'), Extractvalue(Value(A), 'IN/XMID'), Extractvalue(Value(A), 'IN/GHHM'),
         Extractvalue(Value(A), 'IN/FB'), Extractvalue(Value(A), 'IN/ZD'), Extractvalue(Value(A), 'IN/SFYY'),
         Extractvalue(Value(A), 'IN/GHDH')
  Into n_病人id, n_项目id, v_号码, v_费别, v_站点, n_预约, v_No
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  n_总金额 := 0;
  If v_No Is Null Then
    --挂号或者预约
    For c_挂号项目 In (Select 1 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, -1 As 执行科室类型
                   From 收费项目目录 A, 收费价目 B, 收入项目 C
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = n_项目id And Sysdate Between b.执行日期 And
                         Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                   Union All
                   Select 2 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, d.从项数次 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, -1 As 执行科室类型
                   From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费从属项目 D
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = d.从项id And d.主项id = n_项目id And
                         Sysdate Between b.执行日期 And Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))) Loop
      v_实收     := Zl_Actualmoney(v_费别, c_挂号项目.项目id, c_挂号项目.收入项目id, c_挂号项目.数次 * c_挂号项目.单价);
      n_实收金额 := To_Number(Substr(v_实收, Instr(v_实收, ':') + 1));
      n_总金额   := n_总金额 + Nvl(n_实收金额, 0);
      v_Temp     := v_Temp || '<XM><DJH></DJH><MC>' || c_挂号项目.项目名称 || '</MC>' || '<ID>' || c_挂号项目.项目id || '</ID>' ||
                    '<SL>' || c_挂号项目.数次 || '</SL>' || '<YSJE>' || c_挂号项目.数次 * c_挂号项目.单价 || '</YSJE>' || '<SSJE>' ||
                    n_实收金额 || '</SSJE>' || '<SJFM>' || c_挂号项目.收据费目 || '</SJFM></XM>';
    End Loop;
  Else
    --预约接收
    For c_挂号项目 In (Select a.收费细目id As 项目id, a.应收金额, a.实收金额, a.计算单位, a.收据费目, b.名称 As 项目名称, a.No, Nvl(a.付数, 1) As 付数, a.数次
                   From 门诊费用记录 A, 收费项目目录 B
                   Where a.收费细目id = b.Id And a.No = v_No And a.记录性质 = 4 And a.记录状态 = 0) Loop
      n_总金额 := n_总金额 + Nvl(c_挂号项目.实收金额, 0);
      v_号码   := c_挂号项目.计算单位;
      v_Temp   := v_Temp || '<XM><DJH>' || c_挂号项目.No || '</DJH><MC>' || c_挂号项目.项目名称 || '</MC>' || '<ID>' || c_挂号项目.项目id ||
                  '</ID>' || '<SL>' || c_挂号项目.付数 * c_挂号项目.数次 || '</SL>' || '<YSJE>' || c_挂号项目.应收金额 || '</YSJE>' ||
                  '<SSJE>' || c_挂号项目.实收金额 || '</SSJE>' || '<SJFM>' || c_挂号项目.收据费目 || '</SJFM></XM>';
    End Loop;
  End If;

  v_Temp := '<XMMX>' || v_Temp || '</XMMX>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;

  v_Temp := '<ZJE>' || n_总金额 || '</ZJE>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;

  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getregfeedetail;
/

--103209:刘尔旋,2016-12-05,服务窗医保实时结算处理
Create Or Replace Procedure Zl_Third_Getpayfeedetail
(
  Xml_In  In Xmltype,
  Xml_Out In Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取收费划价单费用明细
  --入参:Xml_In:
  --<IN>
  --  <BRID></BRID> //病人ID
  --  <DJH></DJH> //单据号
  --</IN>
  --出参:Xml_Out
  -- <OUTPUT>
  --  <ZJE></ZJE>   //总实收金额
  --  <MXLIST>        //项目明细
  --    <ITEM>
  --      <DJH></DJH>       //单据号
  --      <MC></MC>   //项目名称
  --      <ID></ID>   //项目ID
  --      <SL></SL>   //数量，数次*付数
  --      <YSJE></YSJE>   //应收金额
  --      <SSJE></SSJE>   //实收金额
  --      <SJFM></SJFM>       //收据费目
  --    </ITEM>
  --    <ITEM>
  --    ...
  --    </ITEM>
  --  </MXLIST>
  -- </OUTPUT>

  --------------------------------------------------------------------------------------------------
  x_Templet    Xmltype; --模板XML
  v_Err_Msg    Varchar2(200);
  v_Temp       Varchar2(4000);
  v_Nos        Varchar2(4000);
  n_病人id     病人信息.病人id%Type;
  v_费别       病人信息.费别%Type;
  v_号码       挂号安排.号码%Type;
  n_总金额     门诊费用记录.实收金额%Type;
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');
  Select Extractvalue(Value(A), 'IN/BRID'), Extractvalue(Value(A), 'IN/DJH')
  Into n_病人id, v_Nos
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  n_总金额 := 0;

  For c_项目 In (Select a.收费细目id As 项目id, a.应收金额, a.实收金额, a.计算单位, a.收据费目, b.名称 As 项目名称, a.No, Nvl(a.付数, 1) As 付数, a.数次
               From 门诊费用记录 A, 收费项目目录 B, Table(f_Str2list(v_Nos)) C
               Where a.收费细目id = b.Id And a.No = c.Column_Value And a.记录性质 = 1 And a.记录状态 = 0
               Order By NO, 序号) Loop
    n_总金额 := n_总金额 + Nvl(c_项目.实收金额, 0);
    v_号码   := c_项目.计算单位;
    v_Temp   := v_Temp || '<ITEM><DJH>' || c_项目.No || '</DJH><MC>' || c_项目.项目名称 || '</MC>' || '<ID>' || c_项目.项目id ||
                '</ID>' || '<SL>' || c_项目.付数 * c_项目.数次 || '</SL>' || '<YSJE>' || c_项目.应收金额 || '</YSJE>' || '<SSJE>' ||
                c_项目.实收金额 || '</SSJE>' || '<SJFM>' || c_项目.收据费目 || '</SJFM></ITEM>';
  End Loop;

  v_Temp := '<MXLIST>' || v_Temp || '</MXLIST>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;

  v_Temp := '<ZJE>' || n_总金额 || '</ZJE>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;

  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getpayfeedetail;
/

--103209:刘尔旋,2016-12-05,服务窗医保实时结算处理
Create Or Replace Procedure Zl_Third_Charge_Delcheck
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is

  -------------------------------------------------------------------------------------------------- 
  --功能:三方退费检查 
  --入参:Xml_In: 
  --<IN>
  --    <BRID>病人ID</BRID>
  --    <JE></JE> //退款总金额
  --    <JSKLB></JSKLB>     //结算卡类别
  --    <TFZY>退费摘要</TFZY>
  --    <JCFP>1</JCFP>      //检查发票,0-不检查;1-检查;为1时，打印了发票的单据不能退费
  --    <XL>险类</XL>         //医保病人险类,空代表普通病人
  --    <FYLIST>
  --        <FY>
  --           <DJH>退款单据号</DJH>
  --           <XH>退款序号(格式:1,2,3..为空代表退剩余数量)</DJH>
  --        <FY>
  --    </FYLIST>
  --    <TKLIST>
  --        <TK>
  --            <TKKLB>退款卡类别</TKKLB>
  --            <TKKH>退款卡号</TKKH>
  --            <TKFS>退款方式</TKFS> //退款方式:现金;支票,如果是三方卡,可以传空
  --            <TKJE>支付金额</TKJE>
  --            <JYLSH>交易流水号</JYLSH>
  --            <TKZY>摘要</TKZY>
  --            <TYJK>退回预交款</TYJK> //允冲预交时,只填JSJE节点:1-冲预交
  --            <SFXFK>是否消费卡</SFXFK>   //(1-是消费卡),消费卡时,传入结算卡类别,结算卡号,结算金额等接点
  --            <EXPENDLIST>  //扩展交易信息
  --                <EXPEND>
  --                    <JYMC>交易名称</JYMC>
  --                    <JYLR>交易内容</JYLR>
  --                </EXPEND>
  --            </EXPENDLIST>
  --        </TK>
  --    </TKLIST>
  --</IN>

  --出参:Xml_Out 
  --  <OUT> 
  --    DD如无下列错误结点则说明通过检查
  --    <ERROR> 
  --      <MSG>错误信息</MSG> 
  --    </ERROR> 
  --  </OUT> 
  -------------------------------------------------------------------------------------------------- 
  n_退款总额 门诊费用记录.实收金额%Type;

  n_病人id     门诊费用记录.病人id%Type;
  n_单据病人id 门诊费用记录.病人id%Type;
  v_操作员编码 门诊费用记录.操作员编号%Type;
  v_操作员姓名 门诊费用记录.操作员姓名%Type;
  n_结帐id     门诊费用记录.结帐id%Type;
  n_原结算序号 病人预交记录.结算序号%Type;
  v_结算卡类别 Varchar2(100);
  v_结算方式   医疗卡类别.结算方式%Type;
  n_卡类别id   医疗卡类别.Id%Type;

  v_摘要     门诊费用记录.摘要%Type;
  n_Count    Number(18);
  n_Temp     Number(18);
  n_检查发票 Number(3);
  n_是否打印 Number(3);
  n_退费模式 Number(3);
  n_状态     Number(3);
  n_险类     病人信息.险类%Type;

  v_Temp    Varchar2(32767); --临时XML 
  x_Templet Xmltype; --模板XML 

  v_Err_Msg Varchar2(200);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  --0.获取入参中的病人ID等信息
  Select To_Number(Extractvalue(Value(A), 'IN/BRID')), To_Number(Extractvalue(Value(A), 'IN/JE')),
         Extractvalue(Value(A), 'IN/TFZY'), To_Number(Extractvalue(Value(A), 'IN/JCFP')),
         Extractvalue(Value(A), 'IN/JSKLB'), To_Number(Extractvalue(Value(A), 'IN/XL'))
  Into n_病人id, n_退款总额, v_摘要, n_检查发票, v_结算卡类别, n_险类
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  --0.相关检查
  If Nvl(n_病人id, 0) = 0 Then
    v_Err_Msg := '不能有效识别病人身份,不允许退费操作!';
    Raise Err_Item;
  End If;

  n_退费模式 := zl_GetSysParameter('门诊退费须先申请');

  If v_结算卡类别 Is Not Null Then
    Begin
      n_卡类别id := To_Number(v_结算卡类别);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
    If n_卡类别id = 0 Then
      Begin
        Select ID Into n_卡类别id From 医疗卡类别 Where 名称 = v_结算卡类别;
      Exception
        When Others Then
          v_Err_Msg := '无法确认传入的结算卡！';
          Raise Err_Item;
      End;
    End If;
  Else
    n_卡类别id := 0;
  End If;

  If Nvl(n_卡类别id, 0) <> 0 Then
    Select 结算方式 Into v_结算方式 From 医疗卡类别 Where ID = n_卡类别id;
  End If;

  --人员id,人员编号,人员姓名 
  v_Temp := Zl_Identity(1);
  If Nvl(v_Temp, '0') = '0' Or Nvl(v_Temp, '_') = '_' Then
    v_Err_Msg := '系统不能认别有效的操作员,不允许退费!';
    Raise Err_Item;
  End If;
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员编码 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员姓名 := v_Temp;
  v_Err_Msg    := Null;

  --1.退费检查

  n_Count      := 0;
  n_原结算序号 := 0;
  For c_费用 In (Select Extractvalue(b.Column_Value, '/FY/DJH') As 单据号, Extractvalue(b.Column_Value, '/FY/XH') As 退款序号
               From Table(Xmlsequence(Extract(Xml_In, '/IN/FYLIST/FY'))) B) Loop
  
    If c_费用.单据号 Is Null Then
      v_Err_Msg := '未确定指定退费的单据号,不能退费!';
      Raise Err_Item;
    End If;
  
    If Nvl(n_退费模式, 0) = 1 Then
      Begin
        Select Nvl(状态, 0) Into n_状态 From 病人退费申请 Where NO = c_费用.单据号 And Mod(记录性质, 10) = 1;
      Exception
        When Others Then
          n_状态 := 0;
      End;
      If n_状态 <> 1 Then
        v_Err_Msg := '当前为退费申请模式,退费之前需申请并审核通过该单据!';
        Raise Err_Item;
      End If;
    End If;
  
    Begin
      Select a.结算序号, a.结帐id, a.病人id
      Into n_Temp, n_结帐id, n_单据病人id
      From 病人预交记录 A, 门诊费用记录 B
      Where a.结帐id = b.结帐id And b.No = c_费用.单据号 And b.记录性质 = 1 And Nvl(b.费用状态, 0) = 0 And b.记录状态 In (1, 3) And
            Rownum < 2;
    Exception
      When Others Then
        n_Temp := Null;
    End;
  
    If n_Temp Is Null Then
      v_Err_Msg := '指定的单据号:' || c_费用.单据号 || '未找到,不能退费!';
      Raise Err_Item;
    End If;
  
    If Nvl(n_单据病人id, 0) = 0 Then
      Begin
        Select 病人id
        Into n_单据病人id
        From 门诊费用记录
        Where NO = c_费用.单据号 And 记录性质 = 1 And Nvl(费用状态, 0) = 0 And 记录状态 In (1, 3) And Rownum < 2;
      Exception
        When Others Then
          n_单据病人id := 0;
      End;
    End If;
  
    If Nvl(n_病人id, 0) <> Nvl(n_单据病人id, 0) Then
      v_Err_Msg := '本次退费的收费单:' || c_费用.单据号 || '不是当前病人的收费单,不能退费!';
      Raise Err_Item;
    End If;
  
    If n_原结算序号 <> 0 And n_原结算序号 <> n_Temp Then
      v_Err_Msg := '本次退费的单据号不是一次收费结算,不能退费!';
      Raise Err_Item;
    End If;
    n_原结算序号 := n_Temp;
  
    Select Count(*) Into n_Temp From 费用补充记录 Where 收费结帐id = n_结帐id;
    If Nvl(n_Temp, 0) <> 0 Then
      v_Err_Msg := '本次退费的单据号已经进行了保险补充结算,不能退费!';
      Raise Err_Item;
    End If;
  
    If v_结算卡类别 Is Not Null Then
      If Nvl(n_险类, 0) = 0 Then
        Select Count(*) Into n_Temp From 病人预交记录 Where 结帐id = n_结帐id And 结算方式 <> v_结算方式;
      Else
        Select Count(*)
        Into n_Temp
        From 病人预交记录 A, 结算方式 B
        Where a.结帐id = n_结帐id And a.结算方式 <> v_结算方式 And a.结算方式 = b.名称 And b.性质 Not In (3, 4);
        If n_Temp = 0 Then
          Select Nvl(Max(1), 0)
          Into n_Temp
          From 保险结算记录 A
          Where a.记录id = n_结帐id And 险类 <> n_险类 And Rownum < 2;
        End If;
      End If;
      If Nvl(n_Temp, 0) > 0 Then
        v_Err_Msg := '本次退费的单据包含' || v_结算方式 || '以外的结算方式,不能退费!';
        Raise Err_Item;
      End If;
    End If;
  
    If Nvl(n_检查发票, 0) = 1 Then
      Select Max(Decode(a.实际票号, Null, 0, 1))
      Into n_是否打印
      From 门诊费用记录 A
      Where NO = c_费用.单据号 And 记录性质 = 1;
      If Nvl(n_是否打印, 0) = 1 Then
        v_Err_Msg := '本次退费的单据号已开发票,不能退费!';
        Raise Err_Item;
      End If;
    End If;
  
    n_Count := n_Count + 1;
  End Loop;

  If n_Count = 0 Then
    v_Err_Msg := '未确定本次需要退费的单据,不能退费!';
    Raise Err_Item;
  End If;

  --2.支付方式检查
  n_Count := 0;
  For c_结算方式 In (Select Extractvalue(b.Column_Value, '/TK/TKKLB') As 卡类别, Extractvalue(b.Column_Value, '/TK/TKKH') As 卡号,
                        Extractvalue(b.Column_Value, '/TK/TKFS') As 结算方式,
                        -1 * To_Number(Extractvalue(b.Column_Value, '/TK/TKJE')) As 退款金额,
                        Extractvalue(b.Column_Value, '/TK/JYLSH') As 交易流水号,
                        Extractvalue(b.Column_Value, '/TK/JYSM') As 交易说明, Extractvalue(b.Column_Value, '/TK/TKZY') As 摘要,
                        Extractvalue(b.Column_Value, '/TK/TYJK') As 是否退预交,
                        Extractvalue(b.Column_Value, '/TK/SFXFK') As 是否消费卡,
                        Extract(b.Column_Value, '/TK/EXPENDLIST') As Expend
                 From Table(Xmlsequence(Extract(Xml_In, '/IN/TKLIST/TK'))) B) Loop
  
    --1.退回三方卡
    If c_结算方式.卡类别 Is Not Null And Nvl(c_结算方式.是否消费卡, 0) = 0 Then
      --1.三方卡结算
      Null;
    Elsif c_结算方式.卡类别 Is Not Null And Nvl(c_结算方式.是否消费卡, 0) = 1 Then
      --2.消费卡结算
      Null;
    Elsif Nvl(c_结算方式.是否退预交, 0) = 1 Then
      --3.退预交款
      Null;
    Else
      --4.普通结算
      If c_结算方式.结算方式 Is Null Then
        v_Err_Msg := '未指定支付方式,不能退费!';
        Raise Err_Item;
      End If;
    End If;
    n_Count := n_Count + 1;
  End Loop;

  If n_Count = 0 Then
    v_Err_Msg := '不能有效确认当前的支付方式,不能退费!';
    Raise Err_Item;
  End If;

  Xml_Out := x_Templet;

Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Charge_Delcheck;
/

--103209:刘尔旋,2016-12-05,服务窗医保实时结算处理
Create Or Replace Procedure Zl_Third_Charge_Del
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is

  -------------------------------------------------------------------------------------------------- 
  --功能:三方退费交易 
  --入参:Xml_In: 
  --<IN>
  --    <BRID>病人ID</BRID>
  --    <JE></JE> //退款总金额
  --    <JSKLB></JSKLB>     //结算卡类别
  --    <TFZY>退费摘要</TFZY>
  --    <JCFP>1</JCFP>      //检查发票
  --    <FYLIST>
  --        <FY>
  --           <DJH>退款单据号</DJH>
  --           <XH>退款序号(格式:1,2,3..为空代表退剩余数量)</DJH>
  --        <FY>
  --    </FYLIST>
  --    <TKLIST>
  --        <TK>
  --            <TKKLB>退款卡类别</TKKLB>
  --            <TKKH>退款卡号</TKKH>
  --            <TKFS>退款方式</TKFS> //退款方式:现金;支票,如果是三方卡,可以传空
  --            <TKJE>支付金额</TKJE>
  --            <JYLSH>交易流水号</JYLSH>
  --            <TKZY>摘要</TKZY>
  --            <TYJK>退回预交款</TYJK> //允冲预交时,只填JSJE节点:1-冲预交
  --            <SFXFK>是否消费卡</SFXFK>   //(1-是消费卡),消费卡时,传入结算卡类别,结算卡号,结算金额等接点
  --            <EXPENDLIST>  //扩展交易信息
  --                <EXPEND>
  --                    <JYMC>交易名称</JYMC>
  --                    <JYLR>交易内容</JYLR>
  --                </EXPEND>
  --            </EXPENDLIST>
  --        </TK>
  --    </TKLIST>
  --</IN>

  --出参:Xml_Out 
  --  <OUT> 
  --    <CZSJ>操作时间</CZSJ>          //HIS的登记时间
  --    <YJZID>原结帐ID</YJZID>       //原结帐ID
  --    <CXID>冲销ID</CXID>          //冲销ID
  --    DD如无下列错误结点则说明正确执行 
  --    <ERROR> 
  --      <MSG>错误信息</MSG> 
  --    </ERROR> 
  --  </OUT> 
  -------------------------------------------------------------------------------------------------- 
  n_退款总额 门诊费用记录.实收金额%Type;
  n_卡类别id 医疗卡类别.Id%Type;
  v_结算方式 Varchar2(2000);

  n_病人id     门诊费用记录.病人id%Type;
  n_单据病人id 门诊费用记录.病人id%Type;
  v_操作员编码 门诊费用记录.操作员编号%Type;
  v_操作员姓名 门诊费用记录.操作员姓名%Type;
  n_冲销id     门诊费用记录.结帐id%Type;
  n_结帐id     门诊费用记录.结帐id%Type;
  n_结帐金额   门诊费用记录.结帐金额%Type;
  n_误差额     病人预交记录.冲预交%Type;
  n_原结算序号 病人预交记录.结算序号%Type;
  l_挂号单     t_Strlist := t_Strlist();
  v_挂号单     门诊费用记录.No%Type;
  n_检查发票   Number(3);
  n_是否打印   Number(3);
  v_结算卡类别 Varchar2(100);
  v_结帐ids    Varchar2(1000);

  n_消费卡id 消费卡目录.Id%Type;
  v_摘要     门诊费用记录.摘要%Type;
  n_Count    Number(18);

  d_退费时间 病人预交记录.收款时间%Type;

  v_退费结算 Varchar2(2000);
  v_普通结算 Varchar2(4000);
  n_Temp     Number(18);

  v_Temp    Varchar2(32767); --临时XML 
  x_Templet Xmltype; --模板XML 

  v_Err_Msg Varchar2(200);
  Err_Item Exception;
  Procedure Third_Cardbalance_Modfiy
  (
    冲销id_In     病人预交记录.结帐id%Type,
    卡类别_In     Varchar2,
    卡号_In       病人预交记录.卡号%Type,
    退款金额_In   病人预交记录.冲预交%Type,
    交易流水号_In 病人预交记录.交易流水号%Type,
    交易说明_In   病人预交记录.交易说明%Type,
    摘要_In       病人预交记录.摘要%Type,
    Xmlexpned_In  Xmltype
  ) Is
    n_卡类别id 医疗卡类别.Id%Type;
    v_结算方式 病人预交记录.结算方式%Type;
  
  Begin
    v_Err_Msg := Null;
    Begin
      n_卡类别id := To_Number(卡类别_In);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
    If n_卡类别id = 0 Then
      Begin
        Select ID, 结算方式, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_卡类别id, v_结算方式, v_Err_Msg
        From 医疗卡类别
        Where 名称 = 卡类别_In;
      Exception
        When Others Then
          n_卡类别id := -1;
          v_Err_Msg  := 卡类别_In || '不存在!';
      End;
    Else
      Begin
        Select ID, 结算方式, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_卡类别id, v_结算方式, v_Err_Msg
        From 医疗卡类别
        Where ID = n_卡类别id;
      Exception
        When Others Then
          n_卡类别id := -1;
          v_Err_Msg  := '未找到指定的结算支付信息!';
      End;
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
  
    v_退费结算 := v_结算方式 || '|' || 退款金额_In || '|' || ' |' || Nvl(摘要_In, ' ');
    --   2.三方卡退费结算:
    --     ①结算方式_IN:只能传入一个结算方式,但允许包含一些辅助信息,格式为:结算方式|结算金额|结算号码|结算摘要
    --     ②卡类别ID_IN,卡号_IN,交易流水号_IN,交易说明_In:需要传入
    --结算方式|结算金额|结算号码|结算摘要 
    Zl_门诊退费结算_Modify(2, n_病人id, 冲销id_In, v_退费结算, 0, n_卡类别id, 卡号_In, 交易流水号_In, 交易说明_In, 0, 0, 0, 0);
  
    --保存扩展结算信息
    For c_扩展 In (Select Extractvalue(j.Column_Value, '/EXPEND/JYMC') As Jymc,
                        Extractvalue(j.Column_Value, '/EXPEND/JYLR') As Jylr
                 From Table(Xmlsequence(Extract(Xmlexpned_In, '/EXPENDLIST/EXPEND'))) J) Loop
      Zl_三方结算交易_Insert(n_卡类别id, 0, 卡号_In, 冲销id_In, c_扩展.Jymc || '|' || c_扩展.Jylr, 0);
    End Loop;
  End Third_Cardbalance_Modfiy;

  Procedure Square_Cardbalance_Modfiy
  (
    冲销id_In     病人预交记录.结帐id%Type,
    卡类别_In     Varchar2,
    卡号_In       病人预交记录.卡号%Type,
    退款金额_In   病人预交记录.冲预交%Type,
    交易流水号_In 病人预交记录.交易流水号%Type,
    交易说明_In   病人预交记录.交易说明%Type,
    摘要_In       病人预交记录.摘要%Type,
    
    Xmlexpned_In Xmltype
  ) Is
    n_卡类别id 医疗卡类别.Id%Type;
    v_结算方式 病人预交记录.结算方式%Type;
  
  Begin
    v_Err_Msg := Null;
    Begin
      n_卡类别id := To_Number(卡类别_In);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
  
    If n_卡类别id = 0 Then
      Begin
        Select 编号, 结算方式, Decode(Nvl(启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_卡类别id, v_结算方式, v_Err_Msg
        From 卡消费接口目录
        Where 名称 = 卡类别_In;
      Exception
        When Others Then
          v_Err_Msg := '消费:' || 卡类别_In || '不存在!';
      End;
    
    Else
    
      Begin
        Select 编号, 结算方式, Decode(Nvl(启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_卡类别id, v_结算方式, v_Err_Msg
        From 卡消费接口目录
        Where 编号 = 卡类别_In;
      Exception
        When Others Then
          v_Err_Msg := '未找到指定的结算支付信息!';
      End;
    
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
  
    v_退费结算 := v_结算方式 || '|' || 退款金额_In || '|' || ' |' || Nvl(摘要_In, ' ');
    --   4-消费卡结算:
    --     ①结算方式_IN:允许一次刷多张卡,格式为:卡类别ID|卡号|消费卡ID|消费金额||
    --     ②退支票额_In:传入零
    Select ID
    Into n_消费卡id
    From 消费卡目录
    Where 接口编号 = n_卡类别id And 卡号 = 卡号_In And
          序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = n_卡类别id And 卡号 = 卡号_In);
  
    --卡类别ID|卡号|消费卡ID|消费金额||.
    v_退费结算 := n_卡类别id || '|' || 卡号_In || '|' || n_消费卡id || '|' || 退款金额_In;
    Zl_门诊退费结算_Modify(4, n_病人id, 冲销id_In, v_退费结算, 0, Null, 卡号_In, 交易流水号_In, 交易说明_In, 0, 0, 0, 0);
  
    --保存扩展结算信息
    For c_扩展 In (Select Extractvalue(j.Column_Value, '/EXPEND/JYMC') As Jymc,
                        Extractvalue(j.Column_Value, '/EXPEND/JYLR') As Jylr
                 From Table(Xmlsequence(Extract(Xmlexpned_In, '/EXPENDLIST/EXPEND'))) J) Loop
      Zl_三方结算交易_Insert(n_卡类别id, 1, 卡号_In, 冲销id_In, c_扩展.Jymc || '|' || c_扩展.Jylr, 0);
    End Loop;
  End Square_Cardbalance_Modfiy;

Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  --0.获取入参中的病人ID等信息
  Select To_Number(Extractvalue(Value(A), 'IN/BRID')), To_Number(Extractvalue(Value(A), 'IN/JE')),
         Extractvalue(Value(A), 'IN/TFZY'), To_Number(Extractvalue(Value(A), 'IN/JCFP')),
         Extractvalue(Value(A), 'IN/JSKLB')
  Into n_病人id, n_退款总额, v_摘要, n_检查发票, v_结算卡类别
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  --人员id,人员编号,人员姓名 
  v_Temp       := Zl_Identity(1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员编码 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员姓名 := v_Temp;
  v_Err_Msg    := Null;
  v_结帐ids    := Null;

  If v_结算卡类别 Is Not Null Then
    Begin
      n_卡类别id := To_Number(v_结算卡类别);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
    If n_卡类别id = 0 Then
      Begin
        Select ID Into n_卡类别id From 医疗卡类别 Where 名称 = v_结算卡类别;
      Exception
        When Others Then
          v_Err_Msg := '无法确认传入的结算卡！';
          Raise Err_Item;
      End;
    End If;
  Else
    n_卡类别id := 0;
  End If;

  If Nvl(n_卡类别id, 0) <> 0 Then
    Select 结算方式 Into v_结算方式 From 医疗卡类别 Where ID = n_卡类别id;
  End If;

  --1.先进行退费

  Select 病人结帐记录_Id.Nextval, Sysdate Into n_冲销id, d_退费时间 From Dual;

  n_Count      := 0;
  n_原结算序号 := 0;
  For c_费用 In (Select Extractvalue(b.Column_Value, '/FY/DJH') As 单据号, Extractvalue(b.Column_Value, '/FY/XH') As 退款序号
               From Table(Xmlsequence(Extract(Xml_In, '/IN/FYLIST/FY'))) B) Loop
    Begin
      Select 结算序号, 结帐id, 病人id
      Into n_Temp, n_结帐id, n_单据病人id
      From 病人预交记录
      Where 结帐id In (Select 结帐id
                     From 门诊费用记录
                     Where NO = c_费用.单据号 And 记录性质 = 1 And Nvl(费用状态, 0) = 0 And 记录状态 In (1, 3) And Rownum < 2) And
            Rownum < 2;
    Exception
      When Others Then
        n_Temp := Null;
    End;
    If Instr(',' || v_结帐ids || ',', ',' || n_结帐id || ',') = 0 Then
      v_结帐ids := v_结帐ids || ',' || n_结帐id;
    End If;
  
    If n_Temp Is Null Then
      v_Err_Msg := '指定的单据号:' || c_费用.单据号 || '未找到,不能退费!';
      Raise Err_Item;
    End If;
    Begin
      Select Max(Decode(Instr(摘要, '挂号:'), 0, '', Replace(摘要, '挂号:', '')))
      Into v_挂号单
      From 门诊费用记录
      Where NO = c_费用.单据号 And 记录性质 = 1 And Nvl(费用状态, 0) = 0 And 记录状态 In (1, 3) And Rownum < 2;
    Exception
      When Others Then
        v_挂号单 := Null;
    End;
    If Not v_挂号单 Is Null Then
      l_挂号单.Extend;
      l_挂号单(l_挂号单.Count) := v_挂号单;
    End If;
  
    If Nvl(n_单据病人id, 0) = 0 Then
      Begin
        Select 病人id
        Into n_单据病人id
        From 门诊费用记录
        Where NO = c_费用.单据号 And 记录性质 = 1 And Nvl(费用状态, 0) = 0 And 记录状态 In (1, 3) And Rownum < 2;
      Exception
        When Others Then
          n_单据病人id := 0;
      End;
    End If;
  
    If Nvl(n_病人id, 0) <> Nvl(n_单据病人id, 0) Then
      v_Err_Msg := '本次退费的收费单:' || c_费用.单据号 || '不是当前病人的收费单,不能退费!';
      Raise Err_Item;
    End If;
  
    If n_原结算序号 <> 0 And n_原结算序号 <> n_Temp Then
      v_Err_Msg := '本次退费的单据号不是一次收费结算,不能退费!';
      Raise Err_Item;
    End If;
    n_原结算序号 := n_Temp;
  
    Select Count(*) Into n_Temp From 费用补充记录 Where 收费结帐id = n_结帐id;
    If Nvl(n_Temp, 0) <> 0 Then
      v_Err_Msg := '本次退费的单据号已经进行了保险补充结算,不能退费!';
      Raise Err_Item;
    End If;
  
    If v_结算卡类别 Is Not Null Then
      Select Count(*) Into n_Temp From 病人预交记录 Where 结帐id = n_结帐id And 结算方式 = v_结算方式;
      If Nvl(n_Temp, 0) = 0 Then
        v_Err_Msg := '本次退费的单据不是' || v_结算方式 || '结算的,不能退费!';
        Raise Err_Item;
      End If;
    End If;
  
    If Nvl(n_检查发票, 0) = 1 Then
      Select Max(Decode(a.实际票号, Null, 0, 1))
      Into n_是否打印
      From 门诊费用记录 A
      Where NO = c_费用.单据号 And 记录性质 = 1;
      If Nvl(n_是否打印, 0) = 1 Then
        v_Err_Msg := '本次退费的单据号已开发票,不能退费!';
        Raise Err_Item;
      End If;
    End If;
  
    Zl_门诊收费记录_销帐(c_费用.单据号, v_操作员编码, v_操作员姓名, c_费用.退款序号, d_退费时间, v_摘要, n_冲销id);
    n_Count := n_Count + 1;
  End Loop;
  If n_Count = 0 Then
    v_Err_Msg := '未确定本次需要退费的单据,不能退费!';
    Raise Err_Item;
  End If;

  --2.处理退费的结算信息

  n_结帐金额 := 0;

  --检查总金额是否正确 
  Select Sum(结帐金额) Into n_结帐金额 From 门诊费用记录 Where 结帐id = n_冲销id;

  n_误差额 := -1 * Nvl(n_结帐金额, 0) - Nvl(n_退款总额, 0);
  If Abs(n_误差额) > 1.00 Then
    v_Err_Msg := '单据缴款金额与实际结算的误差太大!';
    Raise Err_Item;
  End If;

  --2.确定支付方式
  n_Count := 0;
  For c_结算方式 In (Select Extractvalue(b.Column_Value, '/TK/TKKLB') As 卡类别, Extractvalue(b.Column_Value, '/TK/TKKH') As 卡号,
                        Extractvalue(b.Column_Value, '/TK/TKFS') As 结算方式,
                        -1 * To_Number(Extractvalue(b.Column_Value, '/TK/TKJE')) As 退款金额,
                        Extractvalue(b.Column_Value, '/TK/JYLSH') As 交易流水号,
                        Extractvalue(b.Column_Value, '/TK/JYSM') As 交易说明, Extractvalue(b.Column_Value, '/TK/TKZY') As 摘要,
                        Extractvalue(b.Column_Value, '/TK/TYJK') As 是否退预交,
                        Extractvalue(b.Column_Value, '/TK/SFXFK') As 是否消费卡,
                        Extract(b.Column_Value, '/TK/EXPENDLIST') As Expend
                 From Table(Xmlsequence(Extract(Xml_In, '/IN/TKLIST/TK'))) B) Loop
  
    --1.退回三方卡
    If c_结算方式.卡类别 Is Not Null And Nvl(c_结算方式.是否消费卡, 0) = 0 Then
      --1.三方卡结算
      Third_Cardbalance_Modfiy(n_冲销id, c_结算方式.卡类别, c_结算方式.卡号, c_结算方式.退款金额, c_结算方式.交易流水号, c_结算方式.交易说明, c_结算方式.摘要,
                               c_结算方式.Expend);
    Elsif c_结算方式.卡类别 Is Not Null And Nvl(c_结算方式.是否消费卡, 0) = 1 Then
      --2.消费卡结算
      Square_Cardbalance_Modfiy(n_冲销id, c_结算方式.卡类别, c_结算方式.卡号, c_结算方式.退款金额, c_结算方式.交易流水号, c_结算方式.交易说明, c_结算方式.摘要,
                                c_结算方式.Expend);
    Elsif Nvl(c_结算方式.是否退预交, 0) = 1 Then
      --3.退预交款
      Zl_门诊退费结算_Modify(4, n_病人id, n_冲销id, Null, c_结算方式.退款金额, Null, Null, Null, Null, 0, 0, 0, 0);
    Else
      --4.普通结算
      If c_结算方式.结算方式 Is Null Then
        v_Err_Msg := '未指定指付方式，不允缴款!';
        Raise Err_Item;
      End If;
      --结算方式|结算金额|结算号码|结算摘要||..
      v_退费结算 := c_结算方式.结算方式 || '|' || c_结算方式.退款金额 || '| |' || Nvl(c_结算方式.摘要, '  ');
      v_普通结算 := Nvl(v_普通结算, '') || '||' || v_退费结算;
    End If;
    n_Count := n_Count + 1;
  End Loop;

  --   0-原样退
  --      原样结算一起全退,所有校对标志都为1,医保调用成功后,调整为2,完成后变成0
  --   1-普通退费方式:
  --     ①结算方式_IN:允许传入多个,格式为:"结算方式|结算金额|结算号码|结算摘要||.." ;也允许传入空.
  --   3-医保结算(如果存在医保的结算,则要先删除原医保结算,后按新传入的更新)
  --     ①结算方式_IN:允许传入多个,格式为:结算方式|结算金额||..
  --     ②退支票额_In:传入零
  If n_Count = 0 Then
    v_Err_Msg := '不能有效确认当前的支付方式!';
    Raise Err_Item;
  End If;

  --5.普通结算及完成结
  If v_普通结算 Is Not Null Then
    v_普通结算 := Substr(v_普通结算, 3);
  End If;
  Zl_门诊退费结算_Modify(1, n_病人id, n_冲销id, v_普通结算, 0, Null, Null, Null, Null, 0, 0, n_误差额, 2);

  If v_结帐ids Is Not Null Then
    v_结帐ids := Substr(v_结帐ids, 2);
  End If;

  If l_挂号单.Count <> 0 Then
    For I In 0 .. l_挂号单.Count Loop
      x_Templet := Xmltype('<IN></IN>');
      v_Temp    := '<GHDH>' || l_挂号单(I) || '</GHDH>';
      Select Appendchildxml(x_Templet, '/IN', Xmltype(v_Temp)) Into x_Templet From Dual;
      Zl_Third_Registdel(x_Templet, Xml_Out);
      v_Temp := '<JSKLB>' || 4 || '</JSKLB>';
      Select Appendchildxml(x_Templet, '/IN', Xmltype(v_Temp)) Into x_Templet From Dual;
      Zl_Third_Registdel(x_Templet, Xml_Out);
      v_Temp := '<GHJE>' || 0 || '</GHJE>';
      Select Appendchildxml(x_Templet, '/IN', Xmltype(v_Temp)) Into x_Templet From Dual;
      Zl_Third_Registdel(x_Templet, Xml_Out);
    End Loop;
  End If;
  v_Temp := '<CZSJ>' || To_Char(d_退费时间, 'YYYY-MM-DD hh24:mi:ss') || '</CZSJ>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  v_Temp := '<YJZID>' || v_结帐ids || '</YJZID>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  v_Temp := '<CXID>' || n_冲销id || '</CXID>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Charge_Del;
/

--101575:余伟节,2016-12-01,解决路径项目对应的继承医嘱数据超长问题
Create Or Replace Procedure Zl_临床路径版本_Copy
(
  源路径id_In     临床路径版本.路径id%Type,
  源版本号_In     临床路径版本.版本号%Type,
  目标路径id_In   临床路径版本.路径id%Type,
  目标版本号_In   临床路径版本.版本号%Type,
  源分支id_In     临床路径分支.Id%Type := Null,
  是否分支路径_In Number := Null,
  目标分支id_In   临床路径分支.Id%Type := Null
  --功能：复制产生新的临床路径版本
  --参数：
  --  源版本号_In：如果未指定(0或NULL)，则取最新有效的版本号
  --  目标本号_In：如果未指定(0或NULL)，则产生新的版本号
  --  是否分支路径_In：编辑分支路径时从其他分支或主路径复制路径结构,1-是，0否。
  --  目标分支ID_In:编辑分支路径时复制其他分支的结构，其他分支的ID。
) Is
  n_源版本号   临床路径版本.版本号%Type;
  n_目标版本号 临床路径版本.版本号%Type;

  n_Advice_New_Id    Number;
  n_Advice_Parent_Id Number;

  n_Step_New_Id    Number;
  n_Step_Parent_Id Number;

  n_Item_New_Id Number;

  n_Eval_New_Id Number;
  n_Eval_Old_Id Number;

  n_Mark_New_Id Number;

  n_Branch_New_Id Number;

  v_Error Varchar2(255);
  Err_Custom Exception;

  n_前一阶段序号 临床路径阶段.序号%Type;
  n_结束天数     临床路径阶段.结束天数%Type;
  v_标准住院日   临床路径分支.标准住院日%Type;
  t_Advice       t_Numlist2 := t_Numlist2(); --缓存继承的医嘱ID C1:=上一个版本的医嘱ID;C2:=新生成的医嘱ID
  --临床路径分支
  Procedure 临床路径分支_Insert
  (
    源id_In       Number,
    New_Id_In     Number,
    路径id_In     Number,
    版本号_In     Number,
    名称_In       临床路径分支.名称%Type := Null,
    说明_In       临床路径分支.说明%Type := Null,
    前一阶段id_In 临床路径分支.前一阶段id%Type := Null,
    标准住院日_In 临床路径分支.标准住院日%Type := Null,
    标准费用_In   临床路径分支.标准费用%Type := Null
  ) Is
  Begin
    If Nvl(源id_In, 0) <> 0 Then
      Insert Into 临床路径分支
        (ID, 路径id, 版本号, 名称, 说明, 前一阶段id, 标准住院日, 标准费用, 创建人, 创建时间)
        Select New_Id_In, 路径id_In, 版本号_In, Nvl(名称_In, 名称), 说明, 前一阶段id, 标准住院日, 标准费用, Zl_Username, Sysdate
        From 临床路径分支
        Where ID = 源id_In;
    Else
      --如果是复制主路径，则如果标准住院日超出了，自动修改。
      Insert Into 临床路径分支
        (ID, 路径id, 版本号, 名称, 说明, 前一阶段id, 标准住院日, 标准费用, 创建人, 创建时间)
        Select New_Id_In, 路径id_In, 版本号_In, 名称_In, 说明_In, 前一阶段id_In, 标准住院日_In, 标准费用_In, Zl_Username, Sysdate
        From Dual;
    End If;
  
  End;

  --临床路径阶段
  Procedure 临床路径阶段_Insert
  (
    源id_In       Number,
    New_Id_In     Number,
    路径id_In     Number,
    版本号_In     Number,
    New_父id_In   Number,
    分支id_Old_In Number := Null,
    分支id_New_In Number := Null
  ) Is
  Begin
    Insert Into 临床路径阶段
      (ID, 路径id, 版本号, 父id, 序号, 名称, 开始天数, 结束天数, 标志, 说明, 分支id)
      Select New_Id_In, 路径id_In, 版本号_In, New_父id_In, 序号, 名称, 开始天数, 结束天数, 标志, 说明, 分支id_New_In
      From 临床路径阶段
      Where ID = 源id_In And Nvl(分支id, 0) = Nvl(分支id_Old_In, 0);
  End;
  ---临床路径项目
  Procedure 临床路径项目_Insert
  (
    源id_In       Number,
    New_Id_In     Number,
    路径id_In     Number,
    版本号_In     Number,
    New_阶段id_In Number,
    分支id_Old_In Number := Null,
    分支id_New_In Number := Null
  ) Is
  Begin
    Insert Into 临床路径项目
      (ID, 路径id, 版本号, 阶段id, 分类, 项目序号, 项目内容, 内容要求, 执行方式, 执行者, 生成者, 项目结果, 图标id, 分支id)
      Select New_Id_In, 路径id_In, 版本号_In, New_阶段id_In, 分类, 项目序号, 项目内容, 内容要求, 执行方式, 执行者, 生成者, 项目结果, 图标id, 分支id_New_In
      From 临床路径项目
      Where ID = 源id_In And Nvl(分支id, 0) = Nvl(分支id_Old_In, 0);
  End;
  --路径医嘱内容
  Procedure 路径医嘱内容_Insert
  (
    源id_In       Number,
    New_Id_In     Number,
    New_相关id_In Number
  ) Is
  Begin
    Insert Into 路径医嘱内容
      (ID, 相关id, 序号, 期效, 诊疗项目id, 医嘱内容, 单次用量, 总给予量, 收费细目id, 标本部位, 检查方法, 执行频次, 频率次数, 频率间隔, 间隔单位, 医生嘱托, 执行性质, 执行科室id, 时间方案,
       是否缺省, 是否备选, 组合项目id)
      Select New_Id_In, New_相关id_In, 序号, 期效, 诊疗项目id, 医嘱内容, 单次用量, 总给予量, 收费细目id, 标本部位, 检查方法, 执行频次, 频率次数, 频率间隔, 间隔单位, 医生嘱托,
             执行性质, 执行科室id, 时间方案, 是否缺省, 是否备选, 组合项目id
      From 路径医嘱内容
      Where ID = 源id_In;
  End;
  --临床路径医嘱
  Procedure 临床路径医嘱_Inset
  (
    路径项目id_In Number,
    医嘱内容id_In Number
  ) Is
  Begin
    Insert Into 临床路径医嘱 (路径项目id, 医嘱内容id) Values (路径项目id_In, 医嘱内容id_In);
  End;
  --临床路径病历
  Procedure 临床路径病历_Inset
  (
    源项目id_In   Number,
    项目id_New_In Number
  ) Is
  Begin
    Insert Into 临床路径病历
      (项目id, 文件id, 原型id, 名称, 序号)
      Select 项目id_New_In, 文件id, 原型id, 名称, 序号 From 临床路径病历 Where 项目id = 源项目id_In;
  End;
  ---临床路径评估
  Procedure 临床路径评估_Insert
  (
    源id_In       Number,
    New_Id_In     Number,
    路径id_In     Number,
    版本号_In     Number,
    阶段id_In     Number,
    分支id_Old_In Number := Null,
    分支id_New_In Number := Null
  ) Is
  Begin
    Insert Into 临床路径评估
      (ID, 路径id, 版本号, 阶段id, 评估类型, 分支id)
      Select New_Id_In, 路径id_In, 版本号_In, 阶段id_In, 评估类型, 分支id_New_In
      From 临床路径评估
      Where ID = 源id_In And Nvl(分支id, 0) = Nvl(分支id_Old_In, 0);
  End;

  Procedure 路径评估指标_Insert
  (
    源id_In   Number,
    New_Id_In Number,
    评估id_In Number
  ) Is
  Begin
    Insert Into 路径评估指标
      (ID, 评估id, 序号, 评估指标, 指标类型, 指标结果)
      Select New_Id_In, 评估id_In, 序号, 评估指标, 指标类型, 指标结果 From 路径评估指标 Where ID = 源id_In;
  End;
  --路径评估条件
  Procedure 路径评估条件_Insert
  (
    源评估id_In   Number,
    源指标id_In   Number,
    源项目id_In   Number,
    New_评估id_In Number,
    New_指标id_In Number,
    New_项目id_In Number
  ) Is
  Begin
    If 源指标id_In Is Null Then
      Insert Into 路径评估条件
        (评估id, 指标id, 项目id, 关系式, 条件值, 条件组合)
        Select New_评估id_In, New_指标id_In, New_项目id_In, 关系式, 条件值, 条件组合
        From 路径评估条件
        Where 评估id = 源评估id_In And 指标id Is Null And 项目id = 源项目id_In;
    Elsif 源项目id_In Is Null Then
      Insert Into 路径评估条件
        (评估id, 指标id, 项目id, 关系式, 条件值, 条件组合)
        Select New_评估id_In, New_指标id_In, New_项目id_In, 关系式, 条件值, 条件组合
        From 路径评估条件
        Where 评估id = 源评估id_In And 指标id = 源指标id_In And 项目id Is Null;
    End If;
  End;
  --临床路径阶段
  Procedure 临床路径阶段cascade_Insert
  (
    源id_In       Number,
    New_Id_In     Number,
    Old路径id_In  Number,
    New路径id_In  Number,
    Old版本号_In  Number,
    New版本号_In  Number,
    分支id_Old_In Number := Null,
    分支id_New_In Number := Null
  ) Is
    n_After   Number(10);
    n_Count   Number(10);
    n_Inherit Number;
    v_Oldid   Varchar2(4000);
    n_Start   Number(10);
    Arr_Id    t_Numlist;
  
  Begin
    ---临床路径评估(阶段，指标类评估条件）
    Select Max(a.Id)
    Into n_Eval_Old_Id
    From 临床路径评估 A
    Where a.路径id = Old路径id_In And a.版本号 = Old版本号_In And a.阶段id = 源id_In And a.评估类型 = 2 And
          Nvl(a.分支id, 0) = Nvl(分支id_Old_In, 0);
  
    If Nvl(n_Eval_Old_Id, 0) <> 0 Then
      Select 临床路径评估_Id.Nextval Into n_Eval_New_Id From Dual;
      临床路径评估_Insert(n_Eval_Old_Id, n_Eval_New_Id, New路径id_In, New版本号_In, New_Id_In, 分支id_Old_In, 分支id_New_In);
      ---路径评估指标
      For r_路径评估指标 In (Select ID From 路径评估指标 Where 评估id = n_Eval_Old_Id) Loop
        Select 路径评估指标_Id.Nextval Into n_Mark_New_Id From Dual;
        路径评估指标_Insert(r_路径评估指标.Id, n_Mark_New_Id, n_Eval_New_Id);
        ---路径评估条件
        路径评估条件_Insert(n_Eval_Old_Id, r_路径评估指标.Id, Null, n_Eval_New_Id, n_Mark_New_Id, Null);
      End Loop;
    End If;
    --临床路径项目
    For r_临床路径项目 In (Select ID
                     From 临床路径项目
                     Where 阶段id = 源id_In And 路径id = Old路径id_In And 版本号 = Old版本号_In And
                           Nvl(分支id, 0) = Nvl(分支id_Old_In, 0)) Loop
    
      Select 临床路径项目_Id.Nextval Into n_Item_New_Id From Dual;
      临床路径项目_Insert(r_临床路径项目.Id, n_Item_New_Id, New路径id_In, New版本号_In, New_Id_In, 分支id_Old_In, 分支id_New_In);
      ---临床路径评估（阶段评估，项目类评估条件）
      If Nvl(n_Eval_Old_Id, 0) <> 0 Then
        ---路径评估条件
        路径评估条件_Insert(n_Eval_Old_Id, Null, r_临床路径项目.Id, n_Eval_New_Id, Null, n_Item_New_Id);
      End If;
      ---临床路径病历
      临床路径病历_Inset(r_临床路径项目.Id, n_Item_New_Id);
    
      --路径医嘱内容
      For r_临床路径医嘱 In (Select b.Id
                       From 临床路径医嘱 A, 路径医嘱内容 B
                       Where a.路径项目id = r_临床路径项目.Id And a.医嘱内容id = b.Id And b.相关id Is Null) Loop
        --继承的医嘱判断
        Select Count(1) Into n_Inherit From 临床路径医嘱 Where 医嘱内容id = r_临床路径医嘱.Id;
        v_Oldid := Null;
        If n_Inherit > 1 Then
          Begin
            Select a.C2 Into v_Oldid From Table(t_Advice) A Where a.C1 = r_临床路径医嘱.Id;
          Exception
            When No_Data_Found Then
              v_Oldid := Null;
          End;
        End If;
        If v_Oldid Is Null Then
          ---b.序号 > a.序号 and b.ID >a.ID --获取父医嘱ID大于子医嘱ID并且父医嘱序号大于子医嘱序号的记录数
          Select Count(1)
          Into n_After
          From 路径医嘱内容 A
          Where a.相关id = r_临床路径医嘱.Id And Exists
           (Select 1 From 路径医嘱内容 B Where b.Id = r_临床路径医嘱.Id And b.序号 > a.序号 And b.Id > a.Id);
        
          Select Count(1) + 1 Into n_Count From 路径医嘱内容 A Where a.相关id = r_临床路径医嘱.Id;
          Select 路径医嘱内容_Id.Nextval Bulk Collect Into Arr_Id From Dual Connect By Rownum <= n_Count;
          If n_After = 0 Then
            n_Advice_Parent_Id := Arr_Id(1);
            n_Start            := 2;
          Else
            n_Advice_Parent_Id := Arr_Id(n_Count);
            n_Start            := 1;
          End If;
        
          路径医嘱内容_Insert(r_临床路径医嘱.Id, n_Advice_Parent_Id, Null);
          If n_Inherit > 1 Then
            t_Advice.Extend;
            t_Advice(t_Advice.Count) := t_Numobj2(r_临床路径医嘱.Id, n_Advice_Parent_Id);
          End If;
        Else
          n_Advice_Parent_Id := To_Number(v_Oldid);
        End If;
        ---临床路径医嘱
        临床路径医嘱_Inset(n_Item_New_Id, n_Advice_Parent_Id);
        --路径医嘱内容相应子节点
        For r_路径医嘱内容 In (Select ID From 路径医嘱内容 Where 相关id = r_临床路径医嘱.Id) Loop
          If v_Oldid Is Null Then
            n_Advice_New_Id := Arr_Id(n_Start);
            n_Start         := n_Start + 1;
          
            路径医嘱内容_Insert(r_路径医嘱内容.Id, n_Advice_New_Id, n_Advice_Parent_Id);
            If n_Inherit > 1 Then
              t_Advice.Extend;
              t_Advice(t_Advice.Count) := t_Numobj2(r_路径医嘱内容.Id, n_Advice_New_Id);
            End If;
          Else
            --继承医嘱，未产生新的ID
            If n_Inherit > 1 Then
              Select a.C2 Into n_Advice_New_Id From Table(t_Advice) A Where a.C1 = r_路径医嘱内容.Id;
            End If;
          End If;
          ---临床路径医嘱
          临床路径医嘱_Inset(n_Item_New_Id, n_Advice_New_Id);
        End Loop;
      End Loop;
    End Loop;
  End;
Begin
  --确定源路径版本号
  n_源版本号 := Nvl(源版本号_In, 0);
  If n_源版本号 = 0 Then
    Select 最新版本 Into n_源版本号 From 临床路径目录 Where ID = 源路径id_In;
    If Nvl(n_源版本号, 0) = 0 Then
      v_Error := '要复制的来源临床路径中没有可用的有效版本。';
      Raise Err_Custom;
    End If;
  End If;

  --确定目标路径版本号
  n_目标版本号 := Nvl(目标版本号_In, 0);
  If n_目标版本号 = 0 Then
    Select Nvl(Max(版本号), 0) + 1 Into n_目标版本号 From 临床路径版本 Where 路径id = 目标路径id_In;
  Else
    If Nvl(是否分支路径_In, 0) = 1 Then
      --从其他分支或主路径复制时
      --记录下前一阶段序号
      Select Max(a.序号)
      Into n_前一阶段序号
      From 临床路径阶段 A, 临床路径分支 B
      Where a.Id = b.前一阶段id And b.Id = Nvl(目标分支id_In, 0);
    
      For r_目标分支 In (Select * From 临床路径分支 Where ID = Nvl(目标分支id_In, 0)) Loop
        Zl_临床路径分支_Delete(目标分支id_In);
        Select 临床路径分支_Id.Nextval Into n_Branch_New_Id From Dual;
        --先确定是否超出标准住院日
        v_标准住院日 := r_目标分支.标准住院日;
        If 源分支id_In = 0 Then
          Select Max(Nvl(结束天数, 开始天数))
          Into n_结束天数
          From 临床路径阶段
          Where 路径id = 源路径id_In And 版本号 = n_目标版本号 And Nvl(分支id, 0) = Nvl(源分支id_In, 0);
          If Instr(v_标准住院日, '-') > 0 Then
            If Substr(v_标准住院日, Instr(v_标准住院日, '-') + 1) < n_结束天数 Then
              v_标准住院日 := Substr(v_标准住院日, 1, Instr(v_标准住院日, '-')) || n_结束天数;
            End If;
          End If;
        End If;
        临床路径分支_Insert(源分支id_In, n_Branch_New_Id, 目标路径id_In, n_目标版本号, r_目标分支.名称, r_目标分支.说明, r_目标分支.前一阶段id, v_标准住院日,
                      r_目标分支.标准费用);
      End Loop;
    Else
      --从其他路径复制或是新增版本是
      Zl_临床路径版本_Delete(目标路径id_In, 目标版本号_In);
    End If;
  End If;
  If Nvl(是否分支路径_In, 0) <> 1 Then
    --从其他路径复制或是新增版本是
    --临床路径版本
    Insert Into 临床路径版本
      (路径id, 版本号, 标准住院日, 标准费用, 版本说明, 创建人, 创建时间)
      Select 目标路径id_In, n_目标版本号, 标准住院日, 标准费用, 版本说明, Zl_Username, Sysdate
      From 临床路径版本
      Where 路径id = 源路径id_In And 版本号 = n_源版本号;
    --路径导入评估
    Select Max(ID)
    Into n_Eval_Old_Id
    From 临床路径评估
    Where 路径id = 源路径id_In And 版本号 = n_源版本号 And 评估类型 = 1;
    If Nvl(n_Eval_Old_Id, 0) <> 0 Then
      Select 临床路径评估_Id.Nextval Into n_Eval_New_Id From Dual;
      临床路径评估_Insert(n_Eval_Old_Id, n_Eval_New_Id, 目标路径id_In, n_目标版本号, Null);
      ---路径评估指标
      For r_路径评估指标 In (Select ID From 路径评估指标 Where 评估id = n_Eval_Old_Id) Loop
        Select 路径评估指标_Id.Nextval Into n_Mark_New_Id From Dual;
        路径评估指标_Insert(r_路径评估指标.Id, n_Mark_New_Id, n_Eval_New_Id);
        ---路径评估条件
        路径评估条件_Insert(n_Eval_Old_Id, r_路径评估指标.Id, Null, n_Eval_New_Id, n_Mark_New_Id, Null);
      End Loop;
    End If;
  Else
    --从其他分支或主路径复制时
    Insert Into 临床路径分类
      (路径id, 版本号, 序号, 名称, 分支id)
      Select 目标路径id_In, n_目标版本号, 序号, 名称, n_Branch_New_Id
      From 临床路径分类
      Where 路径id = 源路径id_In And 版本号 = n_目标版本号 And Nvl(分支id, 0) = Nvl(源分支id_In, 0);
  
    For r_临床路径阶段 In (Select ID, 序号
                     From 临床路径阶段
                     Where 路径id = 源路径id_In And 版本号 = n_目标版本号 And 父id Is Null And Nvl(分支id, 0) = Nvl(源分支id_In, 0)
                     Order By 序号) Loop
      If Nvl(源分支id_In, 0) <> 0 Or r_临床路径阶段.序号 > n_前一阶段序号 Then
        --临床路径阶段的父级行插入
        Select 临床路径阶段_Id.Nextval Into n_Step_Parent_Id From Dual;
        临床路径阶段_Insert(r_临床路径阶段.Id, n_Step_Parent_Id, 目标路径id_In, n_目标版本号, Null, 源分支id_In, n_Branch_New_Id);
      
        临床路径阶段cascade_Insert(r_临床路径阶段.Id, n_Step_Parent_Id, 源路径id_In, 目标路径id_In, 源版本号_In, n_目标版本号, 源分支id_In,
                             n_Branch_New_Id);
        --临床路径阶段的子级行
        For r_临床路径子阶段 In (Select ID
                          From 临床路径阶段
                          Where 路径id = 源路径id_In And 版本号 = n_目标版本号 And 父id = r_临床路径阶段.Id And
                                Nvl(分支id, 0) = Nvl(源分支id_In, 0)) Loop
          --生成新的阶段ID
          Select 临床路径阶段_Id.Nextval Into n_Step_New_Id From Dual;
          临床路径阶段_Insert(r_临床路径子阶段.Id, n_Step_New_Id, 目标路径id_In, n_目标版本号, n_Step_Parent_Id, 源分支id_In, n_Branch_New_Id);
        
          临床路径阶段cascade_Insert(r_临床路径子阶段.Id, n_Step_New_Id, 源路径id_In, 目标路径id_In, 源版本号_In, n_目标版本号, 源分支id_In,
                               n_Branch_New_Id);
        End Loop;
      End If;
    End Loop;
  End If;

  --临床路径分支
  If Nvl(源分支id_In, 0) = 0 And Nvl(目标分支id_In, 0) = 0 Then
    --新增版本时
    For r_临床路径分支 In (Select ID From 临床路径分支 Where 路径id = 源路径id_In And 版本号 = n_源版本号) Loop
      Select 临床路径分支_Id.Nextval Into n_Branch_New_Id From Dual;
      临床路径分支_Insert(r_临床路径分支.Id, n_Branch_New_Id, 目标路径id_In, n_目标版本号);
    
      Insert Into 临床路径分类
        (路径id, 版本号, 序号, 名称, 分支id)
        Select 目标路径id_In, n_目标版本号, 序号, 名称, n_Branch_New_Id
        From 临床路径分类
        Where 路径id = 源路径id_In And 版本号 = n_源版本号 And 分支id = r_临床路径分支.Id;
    
      For r_临床路径阶段 In (Select ID
                       From 临床路径阶段
                       Where 路径id = 源路径id_In And 版本号 = n_源版本号 And 父id Is Null And 分支id = r_临床路径分支.Id
                       Order By 序号) Loop
        --临床路径阶段的父级行插入
        Select 临床路径阶段_Id.Nextval Into n_Step_Parent_Id From Dual;
        临床路径阶段_Insert(r_临床路径阶段.Id, n_Step_Parent_Id, 目标路径id_In, n_目标版本号, Null, r_临床路径分支.Id, n_Branch_New_Id);
      
        临床路径阶段cascade_Insert(r_临床路径阶段.Id, n_Step_Parent_Id, 源路径id_In, 目标路径id_In, 源版本号_In, n_目标版本号, r_临床路径分支.Id,
                             n_Branch_New_Id);
        --临床路径阶段的子级行
        For r_临床路径子阶段 In (Select ID
                          From 临床路径阶段
                          Where 路径id = 源路径id_In And 版本号 = n_源版本号 And 父id = r_临床路径阶段.Id And 分支id = r_临床路径分支.Id) Loop
          --生成新的阶段ID
          Select 临床路径阶段_Id.Nextval Into n_Step_New_Id From Dual;
          临床路径阶段_Insert(r_临床路径子阶段.Id, n_Step_New_Id, 目标路径id_In, n_目标版本号, n_Step_Parent_Id, r_临床路径分支.Id, n_Branch_New_Id);
        
          临床路径阶段cascade_Insert(r_临床路径子阶段.Id, n_Step_New_Id, 源路径id_In, 目标路径id_In, 源版本号_In, n_目标版本号, r_临床路径分支.Id,
                               n_Branch_New_Id);
        End Loop;
      End Loop;
    End Loop;
  
  End If;

  If Nvl(是否分支路径_In, 0) <> 1 Then
    --从其他路径复制或是新增版本是
    --临床路径分类
    Insert Into 临床路径分类
      (路径id, 版本号, 序号, 名称)
      Select 目标路径id_In, n_目标版本号, 序号, 名称
      From 临床路径分类
      Where 路径id = 源路径id_In And 版本号 = n_源版本号 And 分支id Is Null;
  
    --临床路径项目
    --临床路径医嘱
    --路径医嘱内容
    --临床路径病历
    --临床路径评估
    --路径评估指标
    --路径评估条件
  
    For r_临床路径阶段 In (Select ID
                     From 临床路径阶段
                     Where 路径id = 源路径id_In And 版本号 = n_源版本号 And 父id Is Null And 分支id Is Null
                     Order By 序号) Loop
      --临床路径阶段的父级行插入
      Select 临床路径阶段_Id.Nextval Into n_Step_Parent_Id From Dual;
      临床路径阶段_Insert(r_临床路径阶段.Id, n_Step_Parent_Id, 目标路径id_In, n_目标版本号, Null);
      If Nvl(源分支id_In, 0) = 0 And Nvl(目标分支id_In, 0) = 0 Then
        --新增版本时,更新前一阶段ID
        Update 临床路径分支
        Set 前一阶段id = n_Step_Parent_Id
        Where 前一阶段id = r_临床路径阶段.Id And 版本号 = n_目标版本号;
      End If;
    
      临床路径阶段cascade_Insert(r_临床路径阶段.Id, n_Step_Parent_Id, 源路径id_In, 目标路径id_In, 源版本号_In, n_目标版本号);
      --临床路径阶段的子级行
      For r_临床路径子阶段 In (Select ID
                        From 临床路径阶段
                        Where 路径id = 源路径id_In And 版本号 = n_源版本号 And 父id = r_临床路径阶段.Id And 分支id Is Null) Loop
        --生成新的阶段ID
        Select 临床路径阶段_Id.Nextval Into n_Step_New_Id From Dual;
        临床路径阶段_Insert(r_临床路径子阶段.Id, n_Step_New_Id, 目标路径id_In, n_目标版本号, n_Step_Parent_Id);
      
        临床路径阶段cascade_Insert(r_临床路径子阶段.Id, n_Step_New_Id, 源路径id_In, 目标路径id_In, 源版本号_In, n_目标版本号);
      End Loop;
    End Loop;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床路径版本_Copy;
/

--102806:胡俊勇,2016-12-01,会诊医嘱和会诊病历关联问题
Create Or Replace Procedure Zl_病人医嘱记录_作废
(
  Id_In         病人医嘱记录.Id%Type,
  操作员编号_In 人员表.编号%Type := Null,
  操作员姓名_In 人员表.姓名%Type := Null,
  护理医嘱id_In 病人医嘱记录.Id%Type := Null,
  作废时间_In   病人医嘱状态.操作时间%Type := Null
) Is
  --功能：作废指定的医嘱(未发送的长嘱或临嘱)
  --说明：一并给药的只能调用一次(界面显示有多行)
  --参数：ID_IN=组医嘱ID
  --      护理医嘱id_In 取除开本次作废的护理等级医嘱外的最近的自动停止的护理等级医嘱id

  v_发送号       病人医嘱发送.发送号%Type;
  v_费用no       门诊费用记录.No%Type;
  v_记录性质     门诊费用记录.记录性质%Type;
  v_费用序号     Varchar2(255);
  n_自动取消执行 Number(1) := 0;
  n_先作废后退药 Number(1) := 0;

  v_Date     Date;
  v_Count    Number;
  v_Temp     Varchar2(255);
  v_人员编号 人员表.编号%Type;
  v_人员姓名 人员表.姓名%Type;

  --包含医嘱相关信息
  Cursor c_Advice Is
    Select a.病人id, a.挂号单, a.主页id, a.婴儿, a.医嘱状态, a.上次执行时间, a.医嘱内容, a.诊疗类别, b.操作类型, a.病人来源, a.执行科室id, b.执行频率, a.诊疗项目id,
           a.开始执行时间
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id And a.Id = Id_In;

  r_Advice c_Advice%RowType;

  --门诊医嘱作废时，取对应的费用销帐或作废(收费划价单)：
  --根据医嘱及发送NO求出本次回退要销帐或退费的记录
  --一组医嘱并不是都填写了发送记录,也不一定都计费了,且可能NO不同
  --只管记录状态为1的记录,如果已经销帐或部份销帐的记录,不再处理
  --费用只求价格父号为空的,以便取序号销帐
  --如果"门诊药嘱先作废后退药",则不对相应费用(包括给药途径的)进行检查和处理,除非是还没有执行的记帐单,或未执行、收费的划价单，可以先删了。




  Cursor c_Rollmoney(v_发送号 病人医嘱发送.发送号%Type) Is
    Select Decode(a.记录性质, 11, 1, a.记录性质) As 记录性质, a.记录状态, a.No, a.序号, a.执行状态 As 费用执行, c.执行状态 As 医嘱执行, c.执行部门id, b.病人科室id,
           b.诊疗类别, i.操作类型
    From 门诊费用记录 A, 病人医嘱记录 B, 病人医嘱发送 C, 诊疗项目目录 I
    Where c.医嘱id = b.Id And c.发送号 = v_发送号 And (b.Id = Id_In Or b.相关id = Id_In) And a.医嘱序号 = b.Id And a.记录状态 In (0, 1) And
          a.No = c.No And (a.记录性质 = c.记录性质 Or a.记录性质 = 11 And c.记录性质 = 1) And b.诊疗项目id = i.Id And a.价格父号 Is Null And
          (n_先作废后退药 = 0 Or
          n_先作废后退药 = 1 And
          Not (Exists (Select 1
                        From 门诊费用记录 D
                        Where d.医嘱序号 = b.Id And d.记录状态 In (0, 1) And d.No = c.No And
                              (d.记录性质 = c.记录性质 Or d.记录性质 = 11 And c.记录性质 = 1) And d.收费类别 In ('5', '6', '7'))) Or
          Nvl(a.执行状态, 0) = 0 And Not (a.记录性质 = 1 And a.记录状态 <> 0))
    Order By a.记录性质, a.No, a.序号, a.收费细目id;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --检查医嘱状态是否正确:并发操作
  Open c_Advice;
  Fetch c_Advice
    Into r_Advice;

  --当前操作人员
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
    v_人员编号 := 操作员编号_In;
    v_人员姓名 := 操作员姓名_In;
  Else
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;

  --检查是否已经出了报告单，已经出报告单的医嘱不能够作废
  Select Count(1) Into v_Count From 病人医嘱报告 Where 医嘱id = Id_In;
  If v_Count > 0 Then
    If Not (r_Advice.操作类型 = '7' And r_Advice.诊疗类别 = 'Z') Then
      v_Error := '医嘱"' || r_Advice.医嘱内容 || '"已出报告，不能作废。';
      Raise Err_Custom;
    End If;
  End If;

  --检查是否是输液配液记录，并是否已经锁定
  Select Count(1) Into v_Count From 输液配药记录 Where 是否锁定 = 1 And 医嘱id = Id_In;
  If v_Count > 0 Then
    v_Error := '医嘱"' || r_Advice.医嘱内容 || '"是输液药品，已经被输液配置中心锁定，不能作废。';
    Raise Err_Custom;
  End If;

  If r_Advice.挂号单 Is Null And r_Advice.病人来源 <> 3 Then
    If r_Advice.医嘱状态 In (4, 8, 9) Then
      v_Error := '医嘱"' || r_Advice.医嘱内容 || '"已经被作废或停止，不能再作废。';
      Raise Err_Custom;
    Elsif r_Advice.上次执行时间 Is Not Null Then
      v_Error := '医嘱"' || r_Advice.医嘱内容 || '"已经发送，不能被作废。';
      Raise Err_Custom;
    End If;
  
    --持续性护理等级无须发送，校对后就可能已自动计费，作废及回退作废都应按停止流程处理。
    If r_Advice.诊疗类别 = 'H' And r_Advice.操作类型 = '1' And r_Advice.执行频率 = '2' And Nvl(r_Advice.婴儿, 0) = 0 Then
      --(已取消，由于存在无费退院的情况，问题号：45977)a.开始时间是当天之前的，说明已生效（自动费用计算），不允许作废。
      --医嘱的时间只精确到了分钟，所以变动记录的开始时间要去掉秒来比较。
      v_Count := 0;
      Begin
        Select b.终止时间
        Into v_Date
        From 病人变动记录 B, 病人医嘱计价 C
        Where b.病人id = r_Advice.病人id And b.主页id = r_Advice.主页id And c.医嘱id = Id_In And c.收费细目id = b.护理等级id And
              b.开始原因 = 6 And b.附加床位 = 0 And
              To_Char(b.开始时间, 'yyyy-mm-dd hh24:mi') = To_Char(r_Advice.开始执行时间, 'yyyy-mm-dd hh24:mi');
      Exception
        When Others Then
          v_Count := 1;
      End;
      If v_Count = 0 Then
        --d.后续有其他变动发生
        If v_Date Is Not Null Then
          v_Error := '由于护理等级医嘱生效后已经产生了其他变动记录,不能作废该医嘱。';
          Raise Err_Custom;
        Else
          --本次有要自动启用的护理等级，如果和原来护理等级相同则不用撤消护理变动记录
          If Nvl(护理医嘱id_In, 0) <> 0 Then
            Delete 病人医嘱状态 Where 医嘱id = 护理医嘱id_In And 操作类型 In (8, 9);
            Select 操作类型
            Into v_Count
            From (Select 操作类型 From 病人医嘱状态 Where 医嘱id = 护理医嘱id_In Order By 操作时间 Desc)
            Where Rownum < 2;
            Update 病人医嘱记录
            Set 医嘱状态 = v_Count, 执行终止时间 = Null, 停嘱医生 = Null, 停嘱时间 = Null, 确认停嘱时间 = Null, 确认停嘱护士 = Null
            Where ID = 护理医嘱id_In;
            --排除过于频繁的操作
            Select Count(a.Id)
            Into v_Count
            From 病人医嘱记录 A, 诊疗收费关系 B, 病案主页 C
            Where a.诊疗项目id = b.诊疗项目id And c.护理等级id = b.收费项目id And c.病人id = a.病人id And c.主页id = a.主页id And
                  a.Id = 护理医嘱id_In;
          End If;
          If v_Count = 0 Then
            --c.护理等级是最后一条变动
            Zl_病人变动记录_Undo(r_Advice.病人id, r_Advice.主页id, v_人员编号, v_人员姓名, '1', Null, Null, '护理等级变动');
          End If;
        End If;
      Else
        --恢复最近一次被自动停止的护理等级
        If Nvl(护理医嘱id_In, 0) <> 0 Then
          Delete 病人医嘱状态 Where 医嘱id = 护理医嘱id_In And 操作类型 In (8, 9);
          Select 操作类型
          Into v_Count
          From (Select 操作类型 From 病人医嘱状态 Where 医嘱id = 护理医嘱id_In Order By 操作时间 Desc)
          Where Rownum < 2;
          Update 病人医嘱记录
          Set 医嘱状态 = v_Count, 执行终止时间 = Null, 停嘱医生 = Null, 停嘱时间 = Null, 确认停嘱时间 = Null, 确认停嘱护士 = Null
          Where ID = 护理医嘱id_In;
        Else
          --病人入院时指定的护理级产生的变动记录和医嘱新开产生的变动记录不同，这里要先判断
          Select Count(a.Id)
          Into v_Count
          From 病人变动记录 A
          Where a.病人id = r_Advice.病人id And a.主页id = r_Advice.主页id And a.开始原因 = 6;
          If v_Count <> 0 Then
            --b.如果与以前的护理等级相同，则校对时没有产生护理等级变动,产生护理等级停止变动
            Zl_病人变动记录_Nurse(r_Advice.病人id, r_Advice.主页id, Null, Sysdate, v_人员编号, v_人员姓名);
          End If;
        End If;
      End If;
    End If;
  Else
    If r_Advice.医嘱状态 <> 8 Then
      v_Error := '医嘱"' || r_Advice.医嘱内容 || '"尚未发送或已经作废。';
      Raise Err_Custom;
    End If;
    --医嘱附费判断
    Select Count(1)
    Into v_Count
    From 病人医嘱附费 A, 病人医嘱记录 B
    Where a.医嘱id = b.Id And (b.Id = Id_In Or b.相关id = Id_In);
    If v_Count <> 0 Then
      v_Error := '医嘱"' || r_Advice.医嘱内容 || '"存在附加费用，不能作废。';
      Raise Err_Custom;
    End If;
  
    Begin
      --医嘱ID为传入值的这条医嘱不一定发送了的,甚至无发送。
      Select Distinct 发送号
      Into v_发送号
      From 病人医嘱发送
      Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = Id_In Or 相关id = Id_In);
    Exception
      When Others Then
        v_发送号 := Null;
    End;
  
    Select Zl_To_Number(Nvl(zl_GetSysParameter(68), 0)) Into n_先作废后退药 From Dual;
    Select Zl_To_Number(Nvl(zl_GetSysParameter('门诊本科自动执行', '1252'), 0)) Into n_自动取消执行 From Dual;
    If n_自动取消执行 = 1 And v_发送号 Is Not Null Then
      --先更新医嘱和费用的执行状态，因为后续的判断，以及过程Zl_门诊记帐记录_Delete中有检查
      For Rc In (Select a.医嘱id, a.执行部门id
                 From 病人医嘱发送 A, 病人医嘱记录 B
                 Where a.医嘱id = b.Id And (b.Id = Id_In Or b.相关id = Id_In) And a.执行部门id = b.病人科室id) Loop
        Zl_病人医嘱执行_Cancel(Rc.医嘱id, v_发送号, Null, 1, Rc.执行部门id);
      End Loop;
    End If;
  
    --门诊医嘱只可能发送一次
    --后面退费时还有检查，因为可能医嘱没有费用，所以要检查一次执行状态
    Select Count(*)
    Into v_Count
    From 病人医嘱发送 A, 病人医嘱记录 B, 诊疗项目目录 I
    Where a.医嘱id = b.Id And b.诊疗项目id = i.Id And a.执行状态 In (1, 3) And (b.Id = Id_In Or b.相关id = Id_In) And
          (n_先作废后退药 = 0 Or
          n_先作废后退药 = 1 And Not (b.诊疗类别 In ('5', '6', '7') Or b.诊疗类别 = 'E' And i.操作类型 In ('2', '3', '4')));
    If v_Count > 0 Then
      v_Error := '该医嘱已经执行或正在执行，不能作废。';
      Raise Err_Custom;
    End If;
  End If;

  If 作废时间_In Is Null Then
    Select Sysdate Into v_Date From Dual;
  Else
    v_Date := 作废时间_In;
  End If;

  Update 病人医嘱记录 Set 医嘱状态 = 4 Where ID = Id_In Or 相关id = Id_In;

  Insert Into 病人医嘱状态
    (医嘱id, 操作类型, 操作人员, 操作时间)
    Select ID, 4, v_人员姓名, v_Date From 病人医嘱记录 Where ID = Id_In Or 相关id = Id_In;

  --住院医嘱作废时,未打印的情况下,缺省设置为屏蔽打印
  If r_Advice.挂号单 Is Null Then
    Select Count(*)
    Into v_Count
    From 病人医嘱打印
    Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = Id_In Or 相关id = Id_In);
    If Nvl(v_Count, 0) = 0 Then
      Zl_病人医嘱记录_屏蔽打印(Id_In, 1);
    End If;
  Else
    --门诊医嘱(临嘱)作废时还需要回退相关内容:只有一次发送
    --回退划价或记帐费用
    If v_发送号 Is Not Null Then
      --将该组医嘱的费用删除或销帐(按一组医嘱可能有不同NO处理)
      --门诊记帐：如果原始费用已被销帐(或部分销帐),调用过程中有判断
      --门诊划价：如果已收费，则不允许删除
      v_费用no   := Null;
      v_费用序号 := Null;
      For r_Rollmoney In c_Rollmoney(v_发送号) Loop
        If Nvl(r_Rollmoney.医嘱执行, 0) In (1, 3) Then
          --1-完全执行;3-正在执行
          v_Error := '医嘱"' || r_Advice.医嘱内容 || '"已经执行或正在执行，不能作废。';
          Raise Err_Custom;
        End If;
        If Nvl(r_Rollmoney.费用执行, 0) In (1, 2) Then
          --1-完全执行;2-部份执行
          v_Error := '医嘱费用单据"' || r_Rollmoney.No || '"中的内容已经全部或部分执行，不能作废。';
          Raise Err_Custom;
        End If;
        If r_Rollmoney.费用执行 = 9 Then
          v_Error := '医嘱费用单据"' || r_Rollmoney.No || '"中的收费结算产生异常，不能作废。';
          Raise Err_Custom;
        End If;
        v_Count := 1;
        If r_Rollmoney.记录性质 = 1 And r_Rollmoney.记录状态 <> 0 Then
          If 1 = n_先作废后退药 And r_Rollmoney.诊疗类别 = 'E' And r_Rollmoney.操作类型 In ('2', '3', '4') Then
            v_Count := 0;
          Else
            v_Error := '医嘱费用单据"' || r_Rollmoney.No || '"已经收费，不能作废。';
            Raise Err_Custom;
          End If;
        End If;
        If 1 = v_Count Then
          If Nvl(v_费用no, '空') <> r_Rollmoney.No Then
            If v_费用序号 Is Not Null And v_费用no Is Not Null Then
              v_费用序号 := Substr(v_费用序号, 2);
              If v_记录性质 = 1 Then
                Zl_门诊划价记录_Delete(v_费用no, v_费用序号);
              Elsif v_记录性质 = 2 Then
                Zl_门诊记帐记录_Delete(v_费用no, v_费用序号, v_人员编号, v_人员姓名);
              End If;
            End If;
            v_费用序号 := Null;
          End If;
          v_记录性质 := r_Rollmoney.记录性质;
          v_费用no   := r_Rollmoney.No;
          v_费用序号 := v_费用序号 || ',' || r_Rollmoney.序号;
        End If;
      End Loop;
      If v_费用序号 Is Not Null And v_费用no Is Not Null Then
        v_费用序号 := Substr(v_费用序号, 2);
        If v_记录性质 = 1 Then
          Zl_门诊划价记录_Delete(v_费用no, v_费用序号);
        Elsif v_记录性质 = 2 Then
          Zl_门诊记帐记录_Delete(v_费用no, v_费用序号, v_人员编号, v_人员姓名);
        End If;
      End If;
    
      --如果"门诊药嘱先作废后退药"，则对应的给药途径费用设置为未执行，以便退费
      If n_先作废后退药 = 1 Then
        Update 门诊费用记录
        Set 执行状态 = 0
        Where 执行状态 = 1 And 医嘱序号 = Id_In And Exists
         (Select 1
               From 病人医嘱记录 A, 诊疗项目目录 B
               Where a.诊疗项目id = b.Id And b.类别 = 'E' And b.操作类型 In ('2', '3', '4') And a.Id = Id_In);
      End If;
    
      --回退医嘱发送记录(及执行记录)
      Delete From 病人医嘱执行 Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = Id_In Or 相关id = Id_In);
      Delete From 病人医嘱发送 Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = Id_In Or 相关id = Id_In);
    
      --回退特殊医嘱的处理
      If r_Advice.诊疗类别 = 'Z' And Nvl(r_Advice.操作类型, '0') <> '0' And Nvl(r_Advice.婴儿, 0) = 0 Then
        If r_Advice.操作类型 = '1' And r_Advice.执行科室id Is Not Null Then
          --留观医嘱
          Select Count(*)
          Into v_Count
          From 病案主页
          Where 病人id = r_Advice.病人id And Nvl(主页id, 0) = 0 And 入院科室id = r_Advice.执行科室id And 病人性质 In (1, 2);
          If v_Count = 1 Then
            Zl_入院病案主页_Delete(r_Advice.病人id, 0);
          End If;
        Elsif r_Advice.操作类型 = '2' And r_Advice.执行科室id Is Not Null Then
          --住院医嘱
          Select Count(*)
          Into v_Count
          From 病案主页
          Where 病人id = r_Advice.病人id And Nvl(主页id, 0) = 0 And 入院科室id = r_Advice.执行科室id And Nvl(病人性质, 0) = 0;
          If v_Count = 1 Then
            Zl_入院病案主页_Delete(r_Advice.病人id, 0);
          End If;
        End If;
      End If;
    End If;
  End If;

  --删除过敏登记记录
  If r_Advice.诊疗类别 = 'E' And r_Advice.操作类型 = '1' Then
    --Update 病人医嘱记录 Set 皮试结果=Null Where ID=ID_IN; --保留最后的皮试结果
    --删除不过敏的记录，过敏记录保留，因为不管医嘱是否作废，病人对该药过敏
    For r_Test In (Select 操作时间 From 病人医嘱状态 Where 医嘱id = Id_In And 操作类型 = 10) Loop
      Delete From 病人过敏记录
      Where 病人id = r_Advice.病人id And 记录来源 = 2 And Nvl(主页id, 0) = Nvl(r_Advice.主页id, 0) And 记录时间 = r_Test.操作时间 And
            Nvl(结果, 0) = 0;
    End Loop;
  End If;

  Close c_Advice;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱记录_作废;
/

--92604:刘尔旋,2017-02-09,收费预约保存更多信息
--102791:刘尔旋,2016-12-08,预约排队时按时点显示
--102689:刘尔旋,2016-12-01,分时段不序号控制号别预约问题
Create Or Replace Procedure Zl_病人挂号记录_出诊_Insert
(
  出诊记录id_In    临床出诊记录.Id%Type,
  病人id_In        门诊费用记录.病人id%Type,
  门诊号_In        门诊费用记录.标识号%Type,
  姓名_In          门诊费用记录.姓名%Type,
  性别_In          门诊费用记录.性别%Type,
  年龄_In          门诊费用记录.年龄%Type,
  付款方式_In      门诊费用记录.付款方式%Type, --用于存放病人的医疗付款方式编号
  费别_In          门诊费用记录.费别%Type,
  单据号_In        门诊费用记录.No%Type,
  票据号_In        门诊费用记录.实际票号%Type,
  序号_In          门诊费用记录.序号%Type,
  价格父号_In      门诊费用记录.价格父号%Type,
  从属父号_In      门诊费用记录.从属父号%Type,
  收费类别_In      门诊费用记录.收费类别%Type,
  收费细目id_In    门诊费用记录.收费细目id%Type,
  数次_In          门诊费用记录.数次%Type,
  标准单价_In      门诊费用记录.标准单价%Type,
  收入项目id_In    门诊费用记录.收入项目id%Type,
  收据费目_In      门诊费用记录.收据费目%Type,
  结算方式_In      Varchar2,
  应收金额_In      门诊费用记录.应收金额%Type,
  实收金额_In      门诊费用记录.实收金额%Type,
  病人科室id_In    门诊费用记录.病人科室id%Type,
  开单部门id_In    门诊费用记录.开单部门id%Type,
  执行部门id_In    门诊费用记录.执行部门id%Type,
  操作员编号_In    门诊费用记录.操作员编号%Type,
  操作员姓名_In    门诊费用记录.操作员姓名%Type,
  发生时间_In      门诊费用记录.发生时间%Type,
  登记时间_In      门诊费用记录.登记时间%Type,
  医生姓名_In      挂号安排.医生姓名%Type,
  医生id_In        挂号安排.医生id%Type,
  病历费_In        Number, --该条记录是否病历工本费
  急诊_In          Number,
  号别_In          挂号安排.号码%Type,
  诊室_In          门诊费用记录.发药窗口%Type,
  结帐id_In        门诊费用记录.结帐id%Type,
  领用id_In        票据使用明细.领用id%Type,
  预交支付_In      病人预交记录.冲预交%Type, --刷卡挂号时使用的预交金额,序号为1传入.
  现金支付_In      病人预交记录.冲预交%Type, --挂号时现金支付部份金额,序号为1传入.
  个帐支付_In      病人预交记录.冲预交%Type, --挂号时个人帐户支付金额,,序号为1传入.
  保险大类id_In    门诊费用记录.保险大类id%Type,
  保险项目否_In    门诊费用记录.保险项目否%Type,
  统筹金额_In      门诊费用记录.统筹金额%Type,
  摘要_In          门诊费用记录.摘要%Type, --预约挂号摘要信息
  预约挂号_In      Number := 0, --预约挂号时用(记录状态=0,发生时间为预约时间),此时不需要传入结算相关参数
  收费票据_In      Number := 0, --挂号是否使用收费票据
  保险编码_In      门诊费用记录.保险编码%Type,
  复诊_In          病人挂号记录.复诊%Type := 0,
  号序_In          挂号序号状态.序号%Type := Null, --预约时填入费用记录的发药窗口字段,挂号时填入挂号记录
  社区_In          病人挂号记录.社区%Type := Null,
  预约接收_In      Number := 0,
  预约方式_In      预约方式.名称%Type := Null,
  生成队列_In      Number := 0,
  卡类别id_In      病人预交记录.卡类别id%Type := Null,
  结算卡序号_In    病人预交记录.结算卡序号%Type := Null,
  卡号_In          病人预交记录.卡号%Type := Null,
  交易流水号_In    病人预交记录.交易流水号%Type := Null,
  交易说明_In      病人预交记录.交易说明%Type := Null,
  合作单位_In      病人预交记录.合作单位%Type := Null,
  操作类型_In      Number := 0,
  险类_In          病人挂号记录.险类%Type := Null,
  结算模式_In      Number := 0,
  记帐费用_In      Number := 0,
  退号重用_In      Number := 1,
  冲预交病人ids_In Varchar2 := Null,
  修正病人费别_In  Number := 0,
  预约顺序号_In    临床出诊序号控制.预约顺序号%Type := Null,
  修正病人年龄_In  Number := 0
) As
  ---------------------------------------------------------------------------
  --
  --参数:
  --     操作类型_in:0-正常挂号或者预约 1-操作员拥有加号权限加号
  --     修正病人费别_In:0-不修改病人费别 1-修改病人费别
  ----------------------------------------------------------------------------
  --该游标用于收费冲预交的可用预交列表
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit
  (
    v_病人id        病人信息.病人id%Type,
    v_冲预交病人ids Varchar2
  ) Is
    Select 病人id, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额, Min(记录状态) As 记录状态, Nvl(Max(结帐id), 0) As 结帐id,
           Max(Decode(记录性质, 1, ID, 0) * Decode(记录状态, 2, 0, 1)) As 原预交id
    From 病人预交记录
    Where 记录性质 In (1, 11) And 病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And Nvl(预交类别, 2) = 1
     Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
    Group By NO, 病人id
    Order By Decode(病人id, Nvl(v_病人id, 0), 0, 1), 结帐id, NO;
  --功能：新增一行病人挂号费用，并将结算汇总到病人预交记录
  --       同时汇总相关的汇总表(病人挂号汇总、费用汇总)
  --       第一行费用处理票据使用情况(领用ID_IN>0)

  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_排队号码 排队叫号队列.排队号码%Type;
  v_现金     结算方式.名称%Type;
  v_个人帐户 结算方式.名称%Type;
  v_队列名称 排队叫号队列.队列名称%Type;

  n_分时段       Number;
  n_原始分时段   Number;
  n_时段限号     Number;
  n_时段限约     Number;
  d_时段时间     Date;
  d_最大序号时间 Date;
  n_追加号       Number := 0; --处理时段过期 追加挂号的情况
  n_已约数       病人挂号汇总.已约数%Type;
  n_已接收       病人挂号汇总.其中已接收%Type;
  n_预约有效时间 Number;
  n_失效数       Number;
  n_失约挂号     Number := 0;
  n_已用数量     Number;
  n_锁定         Number := 0;

  n_打印id        票据打印内容.Id%Type;
  n_费用id        门诊费用记录.Id%Type;
  n_预交金额      病人预交记录.金额%Type;
  n_当前金额      病人预交记录.金额%Type;
  n_返回值        病人预交记录.金额%Type;
  n_预交id        病人预交记录.Id%Type;
  n_消费卡id      消费卡目录.Id%Type;
  n_挂号id        病人挂号记录.Id%Type;
  v_冲预交病人ids Varchar2(4000);

  n_组id           财务缴款分组.Id%Type;
  n_门诊号         病人信息.门诊号%Type;
  n_序号           挂号序号状态.序号%Type;
  n_已用序号       挂号序号状态.序号%Type;
  n_序号控制       挂号安排.序号控制%Type;
  n_分诊台签到排队 Number;
  n_Count          Number;
  n_限号数         Number(18);
  n_自制卡         Number;
  d_排队时间       Date;
  v_结算方式记录   Varchar2(1000);
  d_序号时间       Date;
  v_费别           费别.名称%Type;
  n_时段序号       Number := -1;
  n_预约生成队列   Number;
  v_结算方式       结算方式.名称%Type;
  v_结算内容       Varchar2(1000);
  v_当前结算       Varchar2(200);
  v_结算号码       病人预交记录.结算号码%Type;
  n_结算金额       病人预交记录.冲预交%Type;
  n_三方卡标志     Number(2);
  n_安排id         挂号安排.Id%Type;
  n_预约顺序号     临床出诊序号控制.预约顺序号%Type;
  n_计划id         挂号安排计划.Id%Type := 0;
  v_星期           挂号安排限制.限制项目%Type;
  n_限约数         Number(18);
  n_已挂数         Number(4) := 0;
  n_Exists         Number;
  n_挂出的最大序号 Number(4) := 0;
  n_分时点显示     Number(3);
  n_结算模式       病人信息.结算模式%Type;
  v_排队序号       排队叫号队列.排队序号%Type;
  v_机器名         挂号序号状态.机器名%Type;
  v_序号操作员     挂号序号状态.操作员姓名%Type;
  v_序号机器名     挂号序号状态.机器名%Type;
  v_付款方式       病人挂号记录.医疗付款方式%Type;
  n_状态           临床出诊序号控制.挂号状态%Type;
Begin
  --记录锁定判断
  If 出诊记录id_In Is Not Null Then
    Begin
      Select 1
      Into n_Exists
      From 临床出诊记录
      Where ID = 出诊记录id_In And Nvl(是否发布, 0) = 1 And Nvl(是否锁定, 0) = 0;
    Exception
      When Others Then
        v_Err_Msg := '无法确定出诊记录，请检查出诊记录是否存在或被锁定！';
        Raise Err_Item;
    End;
  End If;

  --获取当前机器名称
  Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
  n_组id          := Zl_Get组id(操作员姓名_In);
  v_冲预交病人ids := Nvl(冲预交病人ids_In, 病人id_In);

  If 费别_In Is Null Then
    Begin
      Select 名称 Into v_费别 From 费别 Where 缺省标志 = 1 And Rownum < 2;
      Update 病人信息 Set 费别 = v_费别 Where 病人id = 病人id_In;
    Exception
      When Others Then
        v_Err_Msg := '无法确定病人费别，请检查缺省费别是否正确设置！';
        Raise Err_Item;
    End;
  Else
    v_费别 := 费别_In;
    If Nvl(修正病人费别_In, 0) = 1 Then
      Begin
        Update 病人信息 Set 费别 = v_费别 Where 病人id = 病人id_In;
      Exception
        When Others Then
          v_Err_Msg := '没有找到对应的病人！';
          Raise Err_Item;
      End;
    End If;
  End If;

  If Nvl(修正病人年龄_In, 0) = 1 Then
    Begin
      Update 病人信息 Set 年龄 = 年龄_In Where 病人id = 病人id_In;
    Exception
      When Others Then
        v_Err_Msg := '没有找到对应的病人！';
        Raise Err_Item;
    End;
  End If;

  If 门诊号_In Is Not Null Then
    Begin
      Select Nvl(门诊号, 0) Into n_门诊号 From 病人信息 Where 病人id = 病人id_In;
    Exception
      When Others Then
        n_门诊号 := 0;
    End;
    If n_门诊号 = 0 Then
      Update 病人信息 Set 门诊号 = 门诊号_In Where 病人id = 病人id_In;
    End If;
  End If;

  Begin
    Update 临床出诊序号控制
    Set 挂号状态 = 0
    Where 记录id = 出诊记录id_In And 序号 = 号序_In And Nvl(挂号状态, 0) = 3 And 操作员姓名 = 操作员姓名_In;
  Exception
    When Others Then
      Null;
  End;

  If Nvl(预约挂号_In, 0) = 0 Then
    --挂号或者预约接收
    --因为现在有按日编单据号规则,日挂号量不能超过10000次,所以要检查唯一约束。
    Select Count(*)
    Into n_Count
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 In (1, 3) And 序号 = 序号_In And NO = 单据号_In;
    If n_Count <> 0 Then
      v_Err_Msg := '挂号单据号重复,不能保存！' || Chr(13) || '如果使用了按日顺序编号,当日挂号量不能超过10000人次。';
      Raise Err_Item;
    End If;
  
    --获取结算方式名称
    Begin
      Select 名称 Into v_现金 From 结算方式 Where 性质 = 1;
    Exception
      When Others Then
        v_现金 := '现金';
    End;
    Begin
      Select 名称 Into v_个人帐户 From 结算方式 Where 性质 = 3;
    Exception
      When Others Then
        v_个人帐户 := '个人帐户';
    End;
  End If;

  n_序号 := 号序_In;

  --获取是否分时段
  Begin
    Select Nvl(是否分时段, 0), Nvl(是否序号控制, 0), 限号数, 限约数
    Into n_分时段, n_序号控制, n_限号数, n_限约数
    From 临床出诊记录
    Where ID = 出诊记录id_In;
    n_原始分时段 := n_分时段;
  Exception
    When Others Then
      n_分时段     := 0;
      n_原始分时段 := n_分时段;
      n_序号控制   := 0;
      n_限号数     := Null;
      n_限约数     := Null;
  End;

  If n_序号 Is Null And n_分时段 = 1 And n_序号控制 = 0 Then
    Begin
      Select 序号
      Into n_序号
      From 临床出诊序号控制
      Where 记录id = 出诊记录id_In And 开始时间 = 发生时间_In And Rownum < 2;
    Exception
      When Others Then
        n_序号 := Null;
    End;
  End If;

  --分时段挂号时判断是否是过期挂号 也就是追加号的情况 目前只针对专家号分时段进行处理
  If Nvl(预约挂号_In, 0) = 0 And n_分时段 > 0 And Nvl(n_序号控制, 0) = 1 And 号序_In Is Null And Nvl(操作类型_In, 0) = 0 Then
    Begin
      Select Max(To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'))
      Into d_最大序号时间
      From 临床出诊序号控制
      Where 记录id = 出诊记录id_In And Nvl(数量, 0) <> 0;
    
      n_追加号 := Case Sign(发生时间_In - d_最大序号时间)
                 When -1 Then
                  0
                 Else
                  1
               End;
    Exception
      When Others Then
        n_追加号 := 0;
    End;
  End If;
  d_时段时间 := 发生时间_In;

  If 序号_In = 1 And n_分时段 > 0 Then
    If Nvl(n_序号控制, 0) = 1 Then
      Begin
        Select Nvl(序号, 0),
               To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'),
               数量, Decode(Nvl(是否预约, 0), 0, 0, 数量)
        Into n_时段序号, d_时段时间, n_时段限号, n_时段限约
        From 临床出诊序号控制
        Where 记录id = 出诊记录id_In And 序号 = n_序号;
      Exception
        When Others Then
          n_时段序号 := -1;
          n_分时段   := 0;
          d_时段时间 := 发生时间_In;
          n_时段限号 := 0;
          n_时段限约 := 0;
      End;
    Else
      --挂号时检查 是否分了时段,分了时段,把时段的限制条件给取出来
      Begin
        Select Nvl(序号, 0),
               To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'),
               数量, Decode(Nvl(是否预约, 0), 0, 0, 数量)
        Into n_时段序号, d_时段时间, n_时段限号, n_时段限约
        From 临床出诊序号控制
        Where 记录id = 出诊记录id_In And 序号 = n_序号 And 预约顺序号 Is Null;
      Exception
        When Others Then
          n_时段序号 := -1;
          n_分时段   := 0;
          d_时段时间 := 发生时间_In;
          n_时段限号 := 0;
          n_时段限约 := 0;
      End;
    End If;
  End If;

  If 序号_In = 1 Then
    --获取当前未使用的序号
    If Nvl(n_序号控制, 0) = 1 And n_分时段 = 0 Then
      --<序号控制 未设置时段 获取可用的最大序号,以及已经使用的数量>
      Begin
        --最大序号
        Select Count(1) Into n_已用数量 From 病人挂号记录 Where 出诊记录id = 出诊记录id_In And 记录状态 = 1;
        Select Max(序号) Into n_已用序号 From 临床出诊序号控制 Where 记录id = 出诊记录id_In;
      Exception
        When Others Then
          n_已用序号 := 0;
          n_已用数量 := 0;
      End;
      Begin
        --最大序号
        Select Sum(Nvl(数量, 0))
        
        Into n_已约数
        From 临床出诊序号控制
        Where 记录id = 出诊记录id_In And Nvl(挂号状态, 0) = 2;
      Exception
        When Others Then
          n_已约数 := 0;
      End;
    
      If n_原始分时段 = 0 Then
        Begin
          Select Min(序号) Into n_已用序号 From 临床出诊序号控制 Where 记录id = 出诊记录id_In And Nvl(挂号状态, 0) = 0;
          If n_序号 Is Null Then
            n_序号 := Nvl(n_已用序号, 0);
          End If;
        Exception
          When Others Then
            Select Max(序号)
            Into n_已用序号
            From 临床出诊序号控制
            Where 记录id = 出诊记录id_In And Nvl(挂号状态, 0) <> 0;
            If n_序号 Is Null Then
              n_序号 := Nvl(n_已用序号, 0) + 1;
            End If;
        End;
      Else
        Select Max(序号) Into n_已用序号 From 临床出诊序号控制 Where 记录id = 出诊记录id_In;
        If n_序号 Is Null Then
          n_序号 := Nvl(n_已用序号, 0) + 1;
        End If;
      End If;
      --<序号控制 未设置时段 获取可用的最大序号 以及已经使用的数量 --end>
    
      --非加号的情况需要检查是否超过了限制
      If 操作类型_In = 0 Then
        If Nvl(预约挂号_In, 0) = 0 Then
          --挂号时检查
          --启用序号控制未分时段 达到了限制
          If n_限号数 <= n_已用数量 And n_限号数 > 0 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(Trunc(发生时间_In), 'yyyy-mm-dd ') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        
        Else
          --预约时检查
          If n_限约数 = 0 Then
            n_限约数 := n_限号数;
          End If;
        
          If n_限约数 <= n_已约数 And n_限约数 > 0 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(Trunc(发生时间_In), 'yyyy-mm-dd') || '已达到最大限约数！';
            Raise Err_Item;
          End If;
        End If;
      
      Else
        Null;
        --启用序号控制,未分时段 加号情况   不处理,如果以后有限制条件以后补充
      End If;
    
    Elsif Nvl(n_分时段, 0) > 0 And Nvl(n_序号控制, 0) = 0 Then
      --<--普通号分时段 这里只有预约一种情况-->
      If 操作类型_In = 0 Then
        --<正常预约挂号-->
        Begin
          Select Count(0) As 已挂数, Nvl(Sum(Decode(Nvl(Sign(a.开始时间 - d_时段时间), 0), 0, 1, 0)), 0) As 已约数
          Into n_已挂数, n_已约数
          From 临床出诊序号控制 A
          Where 记录id = 出诊记录id_In And 挂号状态 Not In (0, 4, 5);
        Exception
          When Others Then
            n_已挂数 := 0;
            n_已约数 := 0;
        End;
      
        n_时段限约 := n_时段限号; --普通号分时段的情况,29中n_时段限约始终是0 这里特殊处理
        --检查限制数量
        If n_限约数 = 0 Then
          n_限约数 := n_限号数;
        End If;
        If n_时段限约 <= n_已约数 Or n_限约数 <= n_已约数 Then
          v_Err_Msg := '号别' || 号别_In || '在时段' || To_Char(d_时段时间, 'hh24:mi') || '已达到最大限约数！';
          Raise Err_Item;
        End If;
        If n_限号数 <= n_已挂数 Then
          v_Err_Msg := '号别' || 号别_In || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
          Raise Err_Item;
        End If;
      End If;
    
      --没有达到时段的限号数 号码在当前时段往后追加
    
      --获取当天挂出的最大号序
      Select Nvl(Max(序号), 0)
      Into n_挂出的最大序号
      From 临床出诊序号控制 A
      Where 记录id = 出诊记录id_In And 预约顺序号 Is Null And 挂号状态 Not In (0, 5);
      If 预约顺序号_In Is Not Null Then
        n_预约顺序号 := 预约顺序号_In;
      Else
        Begin
          Select Nvl(Max(预约顺序号), 0) + 1
          Into n_预约顺序号
          From 临床出诊序号控制
          Where 记录id = 出诊记录id_In And 序号 = n_时段序号 And 预约顺序号 Is Not Null;
        Exception
          When Others Then
            n_预约顺序号 := Null;
        End;
      End If;
      --设置序号
      n_序号 := RPad(Nvl(n_时段序号, 0), Length(n_限号数) + Length(Nvl(n_时段序号, 0)), 0) + n_预约顺序号;
      If n_预约顺序号 Is Null Then
        n_序号 := Nvl(n_挂出的最大序号, 0) + 1;
      End If;
    
      --<--普通号分时段--End>
    Elsif Nvl(n_分时段, 0) > 0 And Nvl(n_序号控制, 0) = 1 Then
      --<启用序号控制 设置时段
      --专家号分时段
      Begin
        Select Max(序号), Sum(Decode(序号, Nvl(号序_In, 0), 0, 1)), Sum(Decode(Sign(开始时间 - d_时段时间), 0, 1, 0))
        Into n_已用序号, n_已挂数, n_已用数量
        From 临床出诊序号控制
        Where 记录id = 出诊记录id_In And 挂号状态 Not In (0, 4, 5);
      Exception
        When Others Then
          n_已用序号 := 0;
          n_已用数量 := 0;
          n_已挂数   := 0;
      End;
    
      n_失效数 := 0;
      If Nvl(预约挂号_In, 0) = 0 Then
        n_预约有效时间 := Zl_To_Number(zl_GetSysParameter('预约有效时间', 1111));
        n_失约挂号     := Zl_To_Number(zl_GetSysParameter('失约用于挂号', 1111));
        If Nvl(n_预约有效时间, 0) <> 0 And Nvl(n_失约挂号, 0) > 0 Then
          Begin
            Select Sum(Decode(Sign((Sysdate - n_预约有效时间 / 24 / 60) - 开始时间), 1, 1, 0))
            Into n_失效数
            From 临床出诊序号控制
            Where 记录id = 出诊记录id_In And 开始时间 Between Trunc(Sysdate) And Sysdate And Nvl(挂号状态, 0) = 2;
          Exception
            When Others Then
              n_失效数 := 0;
          End;
        End If;
      End If;
    
      If 操作类型_In = 0 Then
        If Nvl(预约挂号_In, 0) = 0 Then
        
          --挂号 追加号码时不检查时段限号数
          If n_时段限号 <= n_已用数量 And Nvl(n_追加号, 0) = 0 Then
            v_Err_Msg := '号别' || 号别_In || '在时段' || To_Char(d_时段时间, 'hh24:mi') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
          If n_限号数 <= n_已挂数 - n_失效数 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        
        Else
          --挂号
          If n_限约数 = 0 Then
            n_限约数 := n_限号数;
          End If;
          If n_限约数 <= n_已用数量 Then
            v_Err_Msg := '号别' || 号别_In || '在时段' || To_Char(d_时段时间, 'hh24:mi') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
          If n_限号数 <= n_已挂数 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        End If;
      End If;
      If n_序号 Is Null Then
        --设置序号
        If Nvl(n_已用序号, 0) < Nvl(n_时段序号, 0) Then
          n_已用序号 := Nvl(n_时段序号, 0);
        End If;
        n_序号 := Nvl(n_已用序号, 0) + 1;
      End If;
    Elsif Nvl(n_分时段, 0) = 0 And Nvl(n_序号控制, 0) = 0 And Nvl(病历费_In, 0) = 0 And Nvl(号别_In, 0) > 0 Then
      ---<--普通号  -->
      Begin
        Select 已挂数, 已约数 Into n_已用数量, n_已约数 From 临床出诊记录 Where ID = 出诊记录id_In;
      Exception
        When Others Then
          n_已用数量 := 0;
          n_已约数   := 0;
      End;
      If Nvl(操作类型_In, 0) = 0 Then
        If Nvl(预约挂号_In, 0) = 0 Then
          --挂号
          If Nvl(n_已用数量, 0) >= Nvl(n_限号数, 0) And Nvl(n_限号数, 0) > 0 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        Else
          --预约
          If (Nvl(n_限约数, 0) > 0 And Nvl(n_已约数, 0) >= Nvl(n_限约数, 0)) Or
             (Nvl(n_已用数量, 0) >= Nvl(n_限号数, 0) And Nvl(n_限号数, 0) > 0) Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        End If;
      End If;
      ---<--普通号  -->
    End If;
  End If;

  --更新挂号序号状态
  If 序号_In = 1 And Not n_序号 Is Null Then
    If n_分时段 = 1 Then
      d_序号时间 := 发生时间_In;
    Else
      d_序号时间 := Trunc(发生时间_In);
    End If;
    --锁定序号的处理
    Begin
      If n_预约顺序号 Is Null Then
        Select 操作员姓名, 工作站名称
        Into v_序号操作员, v_序号机器名
        From 临床出诊序号控制
        Where Nvl(挂号状态, 0) = 5 And 记录id = 出诊记录id_In And 序号 = n_序号;
      Else
        Select 操作员姓名, 工作站名称
        Into v_序号操作员, v_序号机器名
        From 临床出诊序号控制
        Where Nvl(挂号状态, 0) = 5 And 记录id = 出诊记录id_In And 序号 = n_时段序号 And 预约顺序号 = n_预约顺序号;
      End If;
      n_锁定 := 1;
    Exception
      When Others Then
        v_序号操作员 := Null;
        v_序号机器名 := Null;
        n_锁定       := 0;
    End;
    If n_锁定 = 0 Then
      If n_预约顺序号 Is Null Then
        Update 临床出诊序号控制
        Set 挂号状态 = Decode(预约挂号_In, 1, 2, 1)
        Where 记录id = 出诊记录id_In And 序号 = n_序号 And Nvl(挂号状态, 0) = 3 And 操作员姓名 = 操作员姓名_In;
      Else
        Update 临床出诊序号控制
        Set 挂号状态 = Decode(预约挂号_In, 1, 2, 1)
        Where 记录id = 出诊记录id_In And 序号 = n_序号 And 预约顺序号 = n_预约顺序号 And Nvl(挂号状态, 0) = 3 And 操作员姓名 = 操作员姓名_In;
      End If;
      If Sql%RowCount = 0 Then
        Begin
          If Nvl(n_分时段, 0) > 0 Then
            If Nvl(n_序号控制, 0) = 1 Then
              --分时段后专家号 失约的预约号允许挂号
              Update 临床出诊序号控制
              Set 挂号状态 = Decode(预约挂号_In, 1, 2, 1), 操作员姓名 = 操作员姓名_In
              Where 记录id = 出诊记录id_In And 序号 = n_序号 And Nvl(挂号状态, 0) In (0, 2);
              If Sql%NotFound Then
                Begin
                  Select 挂号状态 Into n_状态 From 临床出诊序号控制 Where 记录id = 出诊记录id_In And 序号 = n_序号;
                  v_Err_Msg := '序号' || n_序号 || '已被使用,请重新选择一个序号.';
                  Raise Err_Item;
                Exception
                  When Others Then
                    Insert Into 临床出诊序号控制
                      (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 锁号时间, 类型, 名称, 操作员姓名, 备注)
                      Select 出诊记录id_In, n_序号, d_序号时间, d_序号时间, 1, Decode(预约挂号_In, 1, 1, 0), Decode(预约挂号_In, 1, 2, 1),
                             Null, Null, Null, 操作员姓名_In, '追加号'
                      From Dual;
                End;
              End If;
            Else
              If Nvl(预约接收_In, 0) = 1 Then
                Insert Into 临床出诊序号控制
                  (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 锁号时间, 类型, 名称, 操作员姓名, 备注, 预约顺序号)
                  Select 记录id, 序号, 开始时间, 终止时间, 1, 1, Decode(预约挂号_In, 1, 2, 1), Null, Null, Null, 操作员姓名_In, n_序号, n_预约顺序号
                  From 临床出诊序号控制
                  Where 记录id = 出诊记录id_In And 序号 = n_时段序号 And 预约顺序号 Is Null;
              End If;
            End If;
          Else
            If Nvl(n_序号控制, 0) = 1 Then
              Update 临床出诊序号控制
              Set 挂号状态 = Decode(预约挂号_In, 1, 2, 1), 操作员姓名 = 操作员姓名_In
              Where 记录id = 出诊记录id_In And 序号 = n_序号 And Nvl(挂号状态, 0) = 0;
            
              If Sql%RowCount = 0 Then
                Insert Into 临床出诊序号控制
                  (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 锁号时间, 类型, 名称, 操作员姓名, 备注)
                  Select 出诊记录id_In, n_序号, 发生时间_In, 发生时间_In, 1, Decode(预约挂号_In, 1, 1, 0), Decode(预约挂号_In, 1, 2, 1), Null,
                         Null, Null, 操作员姓名_In, '追加号'
                  From Dual;
              End If;
            End If;
          End If;
        Exception
          When Others Then
            v_Err_Msg := '序号' || n_序号 || '已被使用,请重新选择一个序号.';
            Raise Err_Item;
        End;
      End If;
    Else
      If 操作员姓名_In <> v_序号操作员 Or v_机器名 <> v_序号机器名 Then
        v_Err_Msg := '序号' || n_序号 || '已被自助机' || v_机器名 || '锁定,请重新选择一个序号.';
        Raise Err_Item;
      Else
        If n_预约顺序号 Is Null Then
          Update 临床出诊序号控制
          Set 挂号状态 = Decode(预约挂号_In, 1, 2, 1)
          Where 记录id = 出诊记录id_In And 序号 = n_序号 And Nvl(挂号状态, 0) = 5 And 操作员姓名 = 操作员姓名_In And 工作站名称 = v_机器名;
        Else
          Update 临床出诊序号控制
          Set 挂号状态 = Decode(预约挂号_In, 1, 2, 1)
          Where 记录id = 出诊记录id_In And 序号 = n_时段序号 And 预约顺序号 = n_预约顺序号 And Nvl(挂号状态, 0) = 5 And 操作员姓名 = 操作员姓名_In And
                工作站名称 = v_机器名;
        End If;
      End If;
    End If;
  End If;

  --产生病人挂号费用(可能单独是或包括病历费用)
  Select 病人费用记录_Id.Nextval Into n_费用id From Dual; --应该通过程序得到

  Insert Into 门诊费用记录
    (ID, 记录性质, 记录状态, 序号, 价格父号, 从属父号, NO, 实际票号, 门诊标志, 加班标志, 附加标志, 发药窗口, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 病人科室id, 收费类别,
     计算单位, 收费细目id, 收入项目id, 收据费目, 付数, 数次, 标准单价, 应收金额, 实收金额, 结帐金额, 结帐id, 记帐费用, 开单部门id, 开单人, 划价人, 执行部门id, 执行人, 操作员编号, 操作员姓名,
     发生时间, 登记时间, 保险大类id, 保险项目否, 保险编码, 统筹金额, 摘要, 结论, 缴款组id)
  Values
    (n_费用id, 4, Decode(预约挂号_In, 1, 0, 1), 序号_In, Decode(价格父号_In, 0, Null, 价格父号_In), 从属父号_In, 单据号_In, 票据号_In, 1, 急诊_In,
     病历费_In, Decode(预约挂号_In, 1, To_Char(n_序号), 诊室_In), Decode(病人id_In, 0, Null, 病人id_In),
     Decode(门诊号_In, 0, Null, 门诊号_In), 付款方式_In, 姓名_In, Decode(姓名_In, Null, Null, 性别_In), Decode(姓名_In, Null, Null, 年龄_In),
     v_费别, 病人科室id_In, 收费类别_In, 号别_In, 收费细目id_In, 收入项目id_In, 收据费目_In, 1, 数次_In, 标准单价_In, 应收金额_In, 实收金额_In,
     Decode(预约挂号_In, 1, Null, Decode(Nvl(记帐费用_In, 0), 1, Null, 实收金额_In)),
     Decode(预约挂号_In, 1, Null, Decode(Nvl(记帐费用_In, 0), 1, Null, 结帐id_In)), Decode(Nvl(记帐费用_In, 0), 1, 1, 0), 开单部门id_In,
     操作员姓名_In, Decode(预约挂号_In, 1, 操作员姓名_In, Null), 执行部门id_In, 医生姓名_In, 操作员编号_In, 操作员姓名_In, 发生时间_In, 登记时间_In, 保险大类id_In,
     保险项目否_In, 保险编码_In, 统筹金额_In, 摘要_In, 预约方式_In, Decode(预约挂号_In, 1, Null, n_组id));

  --汇总结算到病人预交记录
  If Nvl(预约挂号_In, 0) = 0 And Nvl(记帐费用_In, 0) = 0 Then
    If Nvl(现金支付_In, 0) = 0 And Nvl(个帐支付_In, 0) = 0 And Nvl(预交支付_In, 0) = 0 And 序号_In = 1 Then
      Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      Insert Into 病人预交记录
        (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
         结算性质)
      Values
        (n_预交id, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), v_现金, 0, 登记时间_In, 操作员编号_In, 操作员姓名_In, 结帐id_In, '挂号收费',
         n_组id, 卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, 合作单位_In, 4);
    End If;
    If Nvl(现金支付_In, 0) <> 0 And 序号_In = 1 Then
      v_结算内容     := 结算方式_In || '|'; --以空格分开以|结尾,没有结算号码的
      v_结算方式记录 := '';
      While v_结算内容 Is Not Null Loop
        v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '|') - 1);
        v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1);
      
        v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
        n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1));
      
        v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
        v_结算号码 := Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1);
      
        v_当前结算   := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
        n_三方卡标志 := To_Number(v_当前结算);
      
        If Instr('|' || v_结算方式记录 || '|', '|' || Nvl(v_结算方式, v_现金) || '|') <> 0 Then
          v_Err_Msg := '使用了重复的结算方式,请检查!';
          Raise Err_Item;
        Else
          v_结算方式记录 := v_结算方式记录 || '|' || Nvl(v_结算方式, v_现金);
        End If;
      
        If n_三方卡标志 = 0 Then
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          Insert Into 病人预交记录
            (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
             合作单位, 结算性质, 结算号码)
          Values
            (n_预交id, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(v_结算方式, v_现金), Nvl(n_结算金额, 0), 登记时间_In,
             操作员编号_In, 操作员姓名_In, 结帐id_In, '挂号收费', n_组id, Null, Null, Null, Null, Null, 合作单位_In, 4, v_结算号码);
        Else
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          Insert Into 病人预交记录
            (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
             合作单位, 结算性质, 结算号码)
          Values
            (n_预交id, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(v_结算方式, v_现金), Nvl(n_结算金额, 0), 登记时间_In,
             操作员编号_In, 操作员姓名_In, 结帐id_In, '挂号收费', n_组id, 卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, 合作单位_In, 4,
             v_结算号码);
          If Nvl(结算卡序号_In, 0) <> 0 And Nvl(现金支付_In, 0) <> 0 Then
            n_消费卡id := Null;
            Begin
              Select Nvl(自制卡, 0), 1 Into n_自制卡, n_Count From 卡消费接口目录 Where 编号 = 结算卡序号_In;
            Exception
              When Others Then
                n_Count := 0;
            End;
            If n_Count = 0 Then
              v_Err_Msg := '没有发现原结算卡的相应类别,不能继续操作！';
              Raise Err_Item;
            End If;
            If n_自制卡 = 1 Then
              Select ID
              Into n_消费卡id
              From 消费卡目录
              Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In And
                    序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In);
            End If;
            Zl_病人卡结算记录_Insert(结算卡序号_In, n_消费卡id, Nvl(v_结算方式, v_现金), Nvl(n_结算金额, 0), 卡号_In, Null, 登记时间_In, Null, 结帐id_In,
                              n_预交id);
          End If;
        End If;
      
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + n_结算金额
        Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = Nvl(v_结算方式, v_现金)
        Returning 余额 Into n_返回值;
      
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (操作员姓名_In, Nvl(v_结算方式, v_现金), 1, n_结算金额);
          n_返回值 := n_结算金额;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = 操作员姓名_In And 结算方式 = Nvl(v_结算方式, v_现金) And 性质 = 1 And Nvl(余额, 0) = 0;
        End If;
      
        v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '|') + 1);
      End Loop;
    End If;
  
    --对于医保挂号
    If Nvl(个帐支付_In, 0) <> 0 And 序号_In = 1 Then
      Insert Into 病人预交记录
        (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), v_个人帐户, 个帐支付_In, 登记时间_In, 操作员编号_In,
         操作员姓名_In, 结帐id_In, '医保挂号', n_组id, 4);
    End If;
  
    --对于就诊卡通过预交金挂号
    If Nvl(预交支付_In, 0) <> 0 And 序号_In = 1 Then
      n_预交金额 := 预交支付_In;
      For r_Deposit In c_Deposit(病人id_In, v_冲预交病人ids) Loop
        n_当前金额 := Case
                    When r_Deposit.金额 - n_预交金额 < 0 Then
                     r_Deposit.金额
                    Else
                     n_预交金额
                  End;
      
        If r_Deposit.结帐id = 0 Then
          --第一次冲预交(填上结帐ID,金额为0)
          Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 4 Where ID = r_Deposit.原预交id;
        
        End If;
        --冲上次剩余额
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 预交类别, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号,
           冲预交, 结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 预交类别, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 登记时间_In, 操作员姓名_In, 操作员编号_In, n_当前金额, 结帐id_In, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
          From 病人预交记录
          Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
      
        --更新病人预交余额
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) - n_当前金额
        Where 病人id = r_Deposit.病人id And 性质 = 1 And 类型 = Nvl(1, 2);
        --检查是否已经处理完
        If r_Deposit.金额 < n_预交金额 Then
          n_预交金额 := n_预交金额 - r_Deposit.金额;
        Else
          n_预交金额 := 0;
        End If;
      
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
      If n_预交金额 > 0 Then
        v_Err_Msg := '预交余不够支付本次支付金额,不能继续操作！';
        Raise Err_Item;
      
      End If;
      Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
    End If;
  
    --相关汇总表的处理
    --人员缴款余额
    If 序号_In = 1 Then
      If Nvl(个帐支付_In, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + 个帐支付_In
        Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = v_个人帐户
        Returning 余额 Into n_返回值;
      
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, v_个人帐户, 1, 个帐支付_In);
          n_返回值 := 个帐支付_In;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_个人帐户 And Nvl(余额, 0) = 0;
        End If;
      End If;
    End If;
  End If;

  --病人挂号汇总(只处理一次,且单独收取病历费不处理)
  If Nvl(预约挂号_In, 0) = 0 Then
    If Nvl(记帐费用_In, 0) = 0 Then
      --处理票据使用情况
      If 序号_In = 1 And 票据号_In Is Not Null Then
        Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
      
        --发出票据
        Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 4, 单据号_In);
      
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
        Values
          (票据使用明细_Id.Nextval, Decode(收费票据_In, 1, 1, 4), 票据号_In, 1, 1, 领用id_In, n_打印id, 登记时间_In, 操作员姓名_In);
      
        --状态改动
        Update 票据领用记录
        Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
        Where ID = Nvl(领用id_In, 0);
      End If;
    End If;
    --病人本次就诊(以发生时间为准)
    If Nvl(病人id_In, 0) <> 0 And 序号_In = 1 Then
      Update 病人信息 Set 就诊时间 = 发生时间_In, 就诊状态 = 1, 就诊诊室 = 诊室_In Where 病人id = 病人id_In;
    End If;
  End If;

  If Nvl(预约挂号_In, 0) = 0 And Nvl(记帐费用_In, 0) = 1 Then
    --记帐
    If Nvl(病人id_In, 0) = 0 Then
      v_Err_Msg := '要针对病人的挂号费进行记帐，必须是建档病人才能记帐挂号。';
      Raise Err_Item;
    End If;
  
    --病人余额
    Update 病人余额
    Set 费用余额 = Nvl(费用余额, 0) + Nvl(实收金额_In, 0)
    Where 病人id = Nvl(病人id_In, 0) And 性质 = 1 And 类型 = 1;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (病人id_In, 1, 1, Nvl(实收金额_In, 0), 0);
    End If;
  
    --病人未结费用
    Update 病人未结费用
    Set 金额 = Nvl(金额, 0) + Nvl(实收金额_In, 0)
    Where 病人id = 病人id_In And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(病人科室id_In, 0) And
          Nvl(开单部门id, 0) = Nvl(开单部门id_In, 0) And Nvl(执行部门id, 0) = Nvl(执行部门id_In, 0) And 收入项目id + 0 = 收入项目id_In And
          来源途径 + 0 = 1;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人未结费用
        (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
      Values
        (病人id_In, Null, Null, 病人科室id_In, 开单部门id_In, 执行部门id_In, 收入项目id_In, 1, Nvl(实收金额_In, 0));
    End If;
  End If;

  --病人挂号记录
  If 号别_In Is Not Null And 序号_In = 1 Then
    --And Nvl(预约挂号_In, 0) = 0
    Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
    Begin
      Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In And Rownum < 2;
    Exception
      When Others Then
        v_付款方式 := Null;
    End;
    Insert Into 病人挂号记录
      (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 预约时间, 操作员编号,
       操作员姓名, 复诊, 号序, 社区, 预约, 预约方式, 摘要, 交易流水号, 交易说明, 合作单位, 接收时间, 接收人, 预约操作员, 预约操作员编号, 险类, 医疗付款方式, 出诊记录id)
    Values
      (n_挂号id, 单据号_In, Decode(Nvl(预约挂号_In, 0), 1, 2, 1), 1, 病人id_In, 门诊号_In, 姓名_In, 性别_In, 年龄_In, 号别_In, 急诊_In, 诊室_In,
       Null, 执行部门id_In, 医生姓名_In, 0, Null, 登记时间_In, 发生时间_In, Decode(Nvl(预约挂号_In, 0), 1, 发生时间_In, Null), 操作员编号_In,
       操作员姓名_In, 复诊_In, n_序号, 社区_In, Decode(预约接收_In, 1, 1, 0), 预约方式_In, 摘要_In, 交易流水号_In, 交易说明_In, 合作单位_In,
       Decode(Nvl(预约挂号_In, 0), 0, 登记时间_In, Null), Decode(Nvl(预约挂号_In, 0), 0, 操作员姓名_In, Null),
       Decode(Nvl(预约挂号_In, 0), 1, 操作员姓名_In, Null), Decode(Nvl(预约挂号_In, 0), 1, 操作员编号_In, Null),
       Decode(Nvl(险类_In, 0), 0, Null, 险类_In), v_付款方式, 出诊记录id_In);
  
    If Nvl(预约挂号_In, 0) = 0 And 预约方式_In Is Not Null Then
      Update 病人挂号记录
      Set 预约 = 1, 预约时间 = 发生时间_In, 预约操作员 = 操作员姓名_In, 预约操作员编号 = 操作员编号_In
      Where ID = n_挂号id;
    End If;
  
    n_预约生成队列 := 0;
    If Nvl(预约挂号_In, 0) = 1 Then
      n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
    End If;
  
    --0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站
    If Nvl(生成队列_In, 0) <> 0 And Nvl(预约挂号_In, 0) = 0 Or n_预约生成队列 = 1 Then
      n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
      If Nvl(n_分诊台签到排队, 0) = 0 Or n_预约生成队列 = 1 Then
        n_分时点显示 := Nvl(Zl_To_Number(zl_GetSysParameter(270)), 0);
        If Nvl(预约挂号_In, 0) = 1 And n_分时点显示 = 1 And n_分时段 = 1 Then
          n_分时点显示 := 1;
        Else
          n_分时点显示 := Null;
        End If;
        --产生队列
        --.按”执行部门” 的方式生成队列
        v_队列名称 := 执行部门id_In;
        v_排队号码 := Zlgetnextqueue(执行部门id_In, n_挂号id, 号别_In || '|' || n_序号);
        v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
        d_排队时间 := Zl_Get_Queuedate(n_挂号id, 号别_In, n_序号, 发生时间_In);
        --  队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,排队标记_In,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In, 排队时间_In
        Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, 执行部门id_In, v_排队号码, Null, 姓名_In, 病人id_In, 诊室_In, 医生姓名_In, d_排队时间, 预约方式_In,
                         n_分时点显示, v_排队序号);
      
        --挂号立即排队
        If Nvl(n_分诊台签到排队, 0) = 0 Then
          Update 病人挂号记录 Set 记录标志 = 1 Where ID = n_挂号id;
        End If;
      End If;
    End If;
  End If;
  --病人担保信息
  If 病人id_In Is Not Null And 序号_In = 1 Then
    --取参数:
    If Nvl(n_结算模式, 0) <> Nvl(结算模式_In, 0) Then
      --结算模式的确定
    
      v_Err_Msg := Null;
      Begin
        Select Nvl(结算模式, 0) Into n_结算模式 From 病人信息 Where 病人id = 病人id_In;
      Exception
        When Others Then
          v_Err_Msg := '未找到指定的病人信息,不允许挂号';
      End;
    
      If v_Err_Msg Is Not Null Then
        Raise Err_Item;
      End If;
      If n_结算模式 = 1 And Nvl(结算模式_In, 0) = 0 Then
        --病人已经是"先诊疗后结算的",本次是"先结算后诊疗的",则检查是否存在未结数据
        Select Count(1)
        Into n_Count
        From 病人未结费用
        Where 病人id = 病人id_In And (来源途径 In (1, 4) Or 来源途径 = 3 And Nvl(主页id, 0) = 0) And Nvl(金额, 0) <> 0 And Rownum < 2;
        If Nvl(n_Count, 0) <> 0 Then
          --存在未结算数据，必须先结算后才允许执行
          v_Err_Msg := '当前病人的就诊模式为先诊疗后结算且存在未结费用，不允许调整该病人的就诊模式,你可以先对未结费用结帐后再挂号或不调整病人的就诊模式!';
          Raise Err_Item;
        End If;
        --检查
        --未发生医嘱业务的（即当时就挂号的,需要保证同一次的就诊模式是一至的(程序已经检查，不用再处理)
      End If;
      Update 病人信息 Set 结算模式 = 结算模式_In Where 病人id = 病人id_In;
    End If;
  
    Update 病人信息
    Set 担保人 = Null, 担保额 = Null, 担保性质 = Null
    Where 病人id = 病人id_In And Exists (Select 1
           From 病人担保记录
           Where 病人id = 病人id_In And 主页id Is Not Null And
                 登记时间 = (Select Max(登记时间) From 病人担保记录 Where 病人id = 病人id_In));
  
    If Sql%RowCount > 0 Then
      Update 病人担保记录
      Set 到期时间 = Sysdate
      Where 病人id = 病人id_In And 主页id Is Not Null And Nvl(到期时间, Sysdate) > Sysdate;
    End If;
  End If;
  If 序号_In = 1 Then
    --消息推送
    Begin
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 1, n_挂号id;
    Exception
      When Others Then
        Null;
    End;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人挂号记录_出诊_Insert;
/

--102666:胡俊勇,2016-11-30,门诊病人诊断医嘱对应
Create Or Replace Procedure Zl_病人诊断医嘱_Insert
(
  医嘱id_In  In 病人诊断医嘱.医嘱id%Type,
  诊断ids_In In Varchar2,
  诊断id_In  In 病人诊断医嘱.诊断id%Type := Null,
  医嘱ids_In In Varchar2 := Null
) Is
  n_Count Number(1);
  Err_Custom Exception;
  v_Error Varchar2(2000);
Begin
  If Not 诊断ids_In Is Null Then
    For r_Diag In (Select Column_Value As 诊断id From Table(Cast(f_Num2list(诊断ids_In) As Zltools.t_Numlist))) Loop
      Select Count(1) Into n_Count From 病人诊断记录 Where ID = r_Diag.诊断id;
      If n_Count = 1 Then
        Insert Into 病人诊断医嘱 (诊断id, 医嘱id) Values (r_Diag.诊断id, 医嘱id_In);
      Else
        v_Error := '申请单对应的诊断被删除，请重新选择申请单对应的诊断！';
        Raise Err_Custom;
      End If;
    End Loop;
  End If;

  If Not 诊断id_In Is Null Then
    Select Count(1) Into n_Count From 病人诊断记录 Where ID = 诊断id_In;
    If n_Count = 0 Then
      v_Error := '对应的诊断被删除，请重新选择申请单对应的诊断！';
      Raise Err_Custom;
    End If;
    For r_Diag In (Select Column_Value As 医嘱id From Table(Cast(f_Num2list(医嘱ids_In) As Zltools.t_Numlist))) Loop
      Insert Into 病人诊断医嘱 (诊断id, 医嘱id) Values (诊断id_In, r_Diag.医嘱id);
    End Loop;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人诊断医嘱_Insert;
/

--84426:冉俊明,2016-11-30,10.34.0以前历史数据医疗卡部分退费。
Create Or Replace Procedure Zl_门诊收费记录_Delete
(
  No_In           门诊费用记录.No%Type,
  操作员编号_In   门诊费用记录.操作员编号%Type,
  操作员姓名_In   门诊费用记录.操作员姓名%Type,
  医保结算方式_In Varchar2 := Null,
  序号_In         Varchar2 := Null,
  结算方式_In     病人预交记录.结算方式%Type := Null,
  误差_In         门诊费用记录.实收金额%Type := 0,
  退费时间_In     门诊费用记录.登记时间%Type := Null,
  回收票据_In     Number := 0,
  退费摘要_In     门诊费用记录.摘要%Type := Null,
  校对标志_In     Number := 0,
  结帐id_In       病人预交记录.结帐id%Type := Null,
  结算序号_In     病人预交记录.结算序号%Type := Null,
  一卡通结算_In   Varchar2 := Null,
  退款操作_In     Number := 0,
  多单据全退_In   Number := 0
) As
  --功能：删除一张门诊收费单据
  --参数：
  --        医保结算方式_IN   =医保退费时,不支持结算作废的结算方式,如果为空表示非医保退费或医保退费全部结算允许作废。
  --        序号_IN           =要退费的项目序号,格式为"1,3,5,6...",缺省NULL表示退"未退的"所有行。
  --        结算方式_IN       =当为部分退费时,退费金额的结算方式。
  --        误差_IN           =指退费时新产生的误差金额,部份退费或医保全退但某种结算退现金时才会产生新的误差。
  --                           此时传入仅用于计算本次退费的结算金额,误差费用记录的处理在本过程执行完后调用Zl_门诊收费误差_Insert产生
  --        回收票据_In       =0:单张全退或多张一起全退时收回票据,注意,多张单据退费循环调本过程时只收回一次。
  --                           1:部份退费不处理票据,通过重打调用单独处理。
  --        校对标志_IN:0-不需要较对;1-需较对(不处理人员缴款余额,不回收票据,不处理预交余额)
  --        一卡通结算_In 全退时传入不原样退回的结算方式；医疗卡部分退费时，传入"结算方式|金额"
  --        退款操作_In:1-进行部分退(将退款方式退到指定的结算方式<结算方式_In>中,0-不指定退款方式)
  --        多单据全退_IN=1-多单据全退(多张单据全退,原样退);0-非原样退
  --该游标为要退费单据的所有原始记录

  --医保全退但某种结算退现金从而产生了新的误差时,排开此处的误差处理,执行完本过程后,界面程序中单独处理新误差
  Cursor c_Bill Is
    Select a.Id, a.No, a.附加标志, a.收费细目id, a.序号, a.价格父号, a.执行状态, a.收费类别, a.付数, a.数次, a.医嘱序号, j.诊疗类别, m.跟踪在用,
           Nvl(a.附加标志, 0) As 误差
    From 门诊费用记录 A, 病人医嘱记录 J, 材料特性 M
    Where a.医嘱序号 = j.Id(+) And a.No = No_In And a.记录性质 = 1 And a.记录状态 In (1, 3) And a.收费细目id + 0 = m.材料id(+) And
          Nvl(a.附加标志, 0) <> Decode(多单据全退_In, 1, 999, 9)
    Order By a.收费细目id, a.序号;
  --:不管原始单据误差,都应该根据当前退费产生的误差项进行处理
  -- Decode(Sign(误差_In), 0, 999, 9)

  --该光标用于处理人员缴款余额中退的不同结算方式的金额
  Cursor c_Money(冲销id_In 病人预交记录.结帐id%Type) Is
    Select 结算方式, 冲预交
    From 病人预交记录
    Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = 冲销id_In And 结算方式 Is Not Null And Nvl(冲预交, 0) <> 0 And Nvl(校对标志, 0) = 0;

  --该游标用于查找收费时使用过的冲预交款记录
  Cursor c_Deposit(V结帐id 病人预交记录.结帐id%Type) Is
    Select ID, 病人id, 冲预交 As 金额, 预交类别
    From 病人预交记录
    Where 记录性质 In (1, 11) And 记录状态 In (1, 3) And 结帐id = V结帐id And Nvl(冲预交, 0) <> 0
    Order By ID Desc;

  n_病人id   病人信息.病人id%Type;
  n_结帐id   门诊费用记录.结帐id%Type;
  n_结算序号 病人预交记录.结算序号%Type;
  n_打印id   票据打印内容.Id%Type;

  n_已退金额 病人预交记录.冲预交%Type;
  n_预交金额 病人预交记录.冲预交%Type;
  n_返回值   病人预交记录.冲预交%Type;
  n_原误差费 门诊费用记录.实收金额%Type;
  --部分退费计算变量
  n_剩余数量 Number;
  n_剩余应收 Number;
  n_剩余实收 Number;
  n_剩余统筹 Number;
  n_准退数量 Number;
  n_退费次数 Number;

  n_应收金额 Number;
  n_实收金额 Number;
  n_统筹金额 Number;
  n_总金额   Number;
  n_费用状态 门诊费用记录.费用状态%Type;
  n_正常退费 Number; --是否第一次退费且全部退费,在每行退费过程中判断得到。
  n_组id     财务缴款分组.Id%Type;

  v_退费结算 结算方式.名称%Type;
  v_结算内容 Varchar2(500);
  n_部分退   Number(2);
  v_当前结算 Varchar2(50);
  v_结算方式 病人预交记录.结算方式%Type;
  n_结算金额 病人预交记录.冲预交%Type;

  l_使用id   t_Numlist := t_Numlist();
  n_Dec      Number;
  d_Date     Date;
  n_Count    Number;
  n_原结帐id Number;

  Err_Item Exception;
  v_Err_Msg      Varchar2(255);
  n_启用模式     Number(3);
  v_Para         Varchar2(1000);
  n_医属执行计价 Number;
  n_会话号       病人预交记录.会话号%Type; --格式：SID+'_'+SERIAL#

  Procedure Zl_Square_Update
  (
    原结帐id_In 病人预交记录.结帐id%Type,
    现结帐id_In 病人预交记录.结帐id%Type,
    缴款组id_In 病人预交记录.缴款组id%Type,
    退款时间_In 病人预交记录.收款时间%Type,
    结算序号_In 病人预交记录.结算序号%Type,
    结算内容_In Varchar2 := Null
  ) As
    n_记录状态 病人卡结算记录.记录状态%Type;
    n_预交id   病人预交记录.Id%Type;
    v_卡号     病人卡结算记录.卡号%Type;
    n_存在卡片 Number;
    d_停用日期 消费卡目录.停用日期%Type;
    n_最大序号 病人卡结算记录.序号%Type;
    n_序号     病人卡结算记录.序号%Type;
    n_余额     消费卡目录.余额%Type;
    n_接口编号 病人卡结算记录.接口编号%Type;
    d_回收时间 消费卡目录.回收时间%Type;
    n_Id       病人预交记录.Id%Type;
  Begin
    n_预交id := 0;
    --处理消费卡,结算卡在上面就已经处理了
    For v_校对 In (Select a.Id As 预交id, c.消费卡id, c.结算金额, c.接口编号, c.卡号, c.序号, c.Id
                 From 病人预交记录 A, 病人卡结算对照 B, 病人卡结算记录 C
                 Where a.Id = b.预交id And b.卡结算id = c.Id And a.记录性质 = 3 And a.记录状态 = 1 And
                       Instr(Nvl(结算内容_In, '_LXH'), ',' || a.结算方式 || ',') = 0 And a.结帐id = 原结帐id_In) Loop
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id = Nvl(v_校对.消费卡id, 0) And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      Else
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id Is Null And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      End If;
    
      If n_记录状态 = 1 Then
        n_记录状态 := 2;
      Else
        n_记录状态 := n_记录状态 + 2;
      End If;
      --多条时,只更新一条
      If n_预交id = 0 Then
        Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id,
           预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
          Select n_预交id, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, 退款时间_In, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
                 -1 * 冲预交, 现结帐id_In, 缴款组id_In, 预交类别, 卡类别id, Nvl(结算卡序号, v_校对.接口编号), 卡号, 交易流水号, 交易说明, 合作单位,
                 Decode(Nvl(校对标志_In, 0), 0, 0, Decode(Nvl(v_校对.消费卡id, 0), 0, 1, 2)), 结算序号_In, 3, n_会话号
          From 病人预交记录 A
          Where ID = v_校对.预交id;
      End If;
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        --消费卡,直接退回卡数据中
        Begin
          Select 卡号, 1, 停用日期, (Select Max(序号) From 消费卡目录 B Where a.卡号 = b.卡号 And a.接口编号 = b.接口编号), 序号, 余额, 接口编号, 回收时间
          Into v_卡号, n_存在卡片, d_停用日期, n_最大序号, n_序号, n_余额, n_接口编号, d_回收时间
          From 消费卡目录 A
          Where ID = v_校对.消费卡id;
        Exception
          When Others Then
            n_存在卡片 := 0;
        End;
      
        --取消停用
        If n_存在卡片 = 0 Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡被他人删除，不能再启用该卡片,请检查！';
          Raise Err_Item;
        End If;
        If Nvl(n_序号, 0) < Nvl(n_最大序号, 0) Then
          v_Err_Msg := '不能启用历史发卡记录(卡号为"' || v_卡号 || '"),请检查！';
          Raise Err_Item;
        End If;
        If Nvl(d_停用日期, To_Date('3000-01-01', 'yyyy-mm-dd')) < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经被他人停用，不能再进行退费,请检查！';
          Raise Err_Item;
        End If;
      
        If d_回收时间 < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经回收，不能退费,请检查！';
          Raise Err_Item;
        End If;
        Update 消费卡目录 Set 余额 = Nvl(余额, 0) + v_校对.结算金额 Where ID = Nvl(v_校对.消费卡id, 0);
      End If;
    
      Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      Insert Into 病人卡结算记录
        (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Select n_Id, 接口编号, 消费卡id, 序号, n_记录状态, 结算方式, -1 * v_校对.结算金额, 卡号, 交易流水号, 交易时间, 备注,
               Decode(消费卡id, Null, 0, 0, 0, 1) As 标志
        From 病人卡结算记录
        Where ID = v_校对.Id;
      Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
    
      If n_记录状态 <> 2 And n_记录状态 <> 1 Then
        Update 病人卡结算记录 Set 记录状态 = 3 Where ID = v_校对.Id;
      End If;
    End Loop;
  End;

Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  Begin
    Select Sid || '_' || Serial# Into n_会话号 From V$session Where Audsid = Userenv('sessionid');
  Exception
    When Others Then
      n_会话号 := Null;
  End;

  n_部分退 := 0;
  --是否已经全部完全执行(只是该单据整张单据的检查)
  Select Nvl(Count(*), 0)
  Into n_Count
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1;
  If n_Count = 0 Then
    v_Err_Msg := '该单据中的项目已经全部完全执行！';
    Raise Err_Item;
  End If;

  --未完全执行的项目是否有剩余数量(只是整张单据的检查)
  --执行状态在原始记录上判断
  Select Nvl(Count(*), 0)
  Into n_Count
  From (Select 序号, Sum(数量) As 剩余数量
         From (Select 记录状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                From 门诊费用记录
                Where NO = No_In And 记录性质 = 1 And Nvl(附加标志, 0) <> 9 And
                      Nvl(价格父号, 序号) In
                      (Select Nvl(价格父号, 序号)
                       From 门诊费用记录
                       Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1)
                Group By 记录状态, Nvl(价格父号, 序号))
         Group By 序号
         Having Sum(数量) <> 0);
  If n_Count = 0 Then
    v_Err_Msg := '该单据中未完全执行部分项目剩余数量为零,没有可以退费的费用！';
    Raise Err_Item;
  End If;
  --确定是否在医嘱执行计价中存在数据,如果存在数据,则根据医嘱执行计价进行退费,否则按旧方式进行处理
  Select Count(1)
  Into n_医属执行计价
  From 门诊费用记录 A, 医嘱执行计价 B
  Where a.医嘱序号 = b.医嘱id And a.记录性质 = 1 And a.No = No_In And a.记录状态 In (1, 3) And Rownum = 1;

  ---------------------------------------------------------------------------------
  --公用变量
  If 退费时间_In Is Not Null Then
    d_Date := 退费时间_In;
  Else
    Select Sysdate Into d_Date From Dual;
  End If;
  If 结帐id_In Is Null Then
    Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  Else
    n_结帐id := 结帐id_In;
  End If;
  n_结算序号 := 结算序号_In;
  If n_结算序号 Is Null Then
    n_结算序号 := 结帐id_In;
  End If;
  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into n_Dec From Dual;

  --获取结算方式名称
  v_退费结算 := 结算方式_In;
  If v_退费结算 Is Null Then
    Begin
      Select 名称 Into v_退费结算 From 结算方式 Where 性质 = 1;
    Exception
      When Others Then
        v_退费结算 := '现金';
    End;
  End If;
  --循环处理每行费用(收入项目行)
  n_总金额   := 0;
  n_正常退费 := 1;
  For r_Bill In c_Bill Loop
    If Instr(',' || 序号_In || ',', ',' || Nvl(r_Bill.价格父号, r_Bill.序号) || ',') > 0 Or 序号_In Is Null Then
      If Nvl(r_Bill.执行状态, 0) <> 1 Then
        --求剩余数量,剩余应收,剩余实收
        Select Sum(Nvl(付数, 1) * 数次), Sum(应收金额), Sum(实收金额), Sum(统筹金额)
        Into n_剩余数量, n_剩余应收, n_剩余实收, n_剩余统筹
        From 门诊费用记录
        Where NO = No_In And 记录性质 = 1 And 序号 = r_Bill.序号;
      
        If n_剩余数量 = 0 Then
          If 序号_In Is Not Null Then
            v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经全部退费！';
            Raise Err_Item;
          End If;
          --情况：未限定行号,原始单据中的该笔已经全部退费(执行状态=0的一种可能)
          n_正常退费 := 0;
        Else
          --准退数量(非药品项目为剩余数量,原始数量)
          If Instr(',4,5,6,7,', r_Bill.收费类别) = 0 Or (r_Bill.收费类别 = '4' And Nvl(r_Bill.跟踪在用, 0) = 0) Then
            --@@@
            --非药品部分(以具体医嘱执行为准进行检查)
            --: 1.存在医嘱发送的,则以医嘱执行为准(但不能包含:检查;检验;手术;麻醉及输血)
            --: 2.不存在医嘱的,则以剩余数量为准
            n_Count := 0;
            If Instr(',C,D,F,G,K,', ',' || r_Bill.诊疗类别 || ',') = 0 And r_Bill.诊疗类别 Is Not Null Then
              If n_医属执行计价 = 1 Then
                Select Decode(Sign(Sum(数量)), -1, 0, Sum(数量)), Count(*)
                Into n_准退数量, n_Count
                From (Select Max(Decode(a.记录状态, 2, 0, a.Id)) As ID, Max(a.医嘱序号) As 医嘱id, Max(a.收费细目id) As 收费细目id,
                              Sum(Nvl(a.付数, 1) * Nvl(a.数次, 1)) As 数量,
                              Sum(Decode(a.记录状态, 2, 0, Nvl(a.付数, 1) * Nvl(a.数次, 1))) As 原始数量
                       From 门诊费用记录 A, 病人医嘱记录 M
                       Where a.医嘱序号 = m.Id And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                             Instr('5,6,7', a.收费类别) = 0 And a.No = No_In And a.序号 = r_Bill.序号 And a.记录性质 = 1 And
                             a.记录状态 In (1, 2, 3) And a.价格父号 Is Null
                       Group By a.序号
                       Union All
                       Select a.Id, a.医嘱序号 As 医嘱id, a.收费细目id, -1 * b.数量 As 已执行, 0 原始数量
                       From 门诊费用记录 A, 医嘱执行计价 B, 病人医嘱记录 M
                       Where a.医嘱序号 = b.医嘱id And a.收费细目id = b.收费细目id + 0 And a.医嘱序号 = m.Id And
                             Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Instr('5,6,7', a.收费类别) = 0 And
                             (Exists
                              (Select 1
                               From 病人医嘱执行
                               Where b.医嘱id = 医嘱id And b.发送号 = 发送号 And b.要求时间 = 要求时间 And Nvl(执行结果, 0) = 1) Or Exists
                              (Select 1
                               From 病人医嘱发送
                               Where b.医嘱id = 医嘱id And b.发送号 = 发送号 And Nvl(执行状态, 0) = 1)) And Not Exists
                        (Select 1
                              From 病人医嘱附费
                              Where a.医嘱序号 = 医嘱id And a.No = NO And Mod(a.记录性质, 10) = 记录性质) And a.No = No_In And
                             a.序号 = r_Bill.序号 And a.记录性质 = 1 And a.记录状态 In (1, 3) 　and a.价格父号 Is Null) Q1
                Where Not Exists (Select 1
                       From 药品收发记录
                       Where 费用id = Q1.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0) Having
                 Max(ID) <> 0;
              Else
              
                Select Nvl(Sum(数量), 0), Count(*)
                Into n_准退数量, n_Count
                From (Select a.医嘱id, a.收费细目id, Nvl(a.数量, 1) * Nvl(b.发送数次, 1) As 数量
                       From 病人医嘱计价 A, 病人医嘱发送 B, 门诊费用记录 J, 病人医嘱记录 M
                       Where a.医嘱id = b.医嘱id And a.医嘱id = m.Id And Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And
                             a.收费细目id = j.收费细目id And j.No = No_In And j.记录性质 = 1 And j.序号 = r_Bill.序号 And
                             j.记录状态 In (1, 3) And j.价格父号 Is Null And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                             Exists
                        (Select 1
                              From 病人医嘱计价 A
                              Where a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And Nvl(a.收费方式, 0) = 0) And Not Exists
                        (Select 1
                              From 药品收发记录
                              Where 费用id = j.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0)
                       Union All
                       Select a.医嘱id, a.收费细目id, -1 * Nvl(a.数量, 1) * Nvl(c.本次数次, 1) As 数量
                       From 病人医嘱计价 A, 病人医嘱发送 B, 病人医嘱执行 C, 门诊费用记录 J, 病人医嘱记录 M
                       Where a.医嘱id = b.医嘱id And b.医嘱id = c.医嘱id And b.发送号 = c.发送号 And a.医嘱id = m.Id And
                             Nvl(c.执行结果, 1) = 1 And Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And
                             j.No = No_In And j.记录性质 = 1 And Nvl(a.收费方式, 0) = 0 And j.序号 = r_Bill.序号 And j.记录状态 In (1, 3) And
                             j.价格父号 Is Null And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Not Exists
                        (Select 1
                              From 药品收发记录
                              Where 费用id = j.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0) And Not Exists
                        (Select 1 From 材料特性 Where 材料id = j.收费细目id And Nvl(跟踪在用, 0) = 1)
                       Union All
                       Select a.医嘱序号 As 医嘱id, a.收费细目id, Nvl(a.付数, 1) * a.数次 As 数量
                       From 门诊费用记录 A, 病人医嘱记录 M
                       Where a.医嘱序号 = m.Id And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And a.No = No_In And
                             a.记录性质 = 1 And a.序号 = r_Bill.序号 And a.记录状态 = 2 And a.价格父号 Is Null And Not Exists
                        (Select 1 From 药品收发记录 Where NO = No_In And 单据 In (8, 24) And 药品id = a.收费细目id));
              End If;
            End If;
            If Nvl(n_Count, 0) <> 0 And n_准退数量 = 0 Then
              v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已执行,不允许退费！';
              Raise Err_Item;
            End If;
          
            If Nvl(n_Count, 0) = 0 Then
              n_准退数量 := n_剩余数量;
            End If;
          
          Else
            Select Nvl(Sum(Nvl(付数, 1) * 实际数量), 0), Count(*)
            Into n_准退数量, n_Count
            From 药品收发记录
            Where NO = No_In And 单据 In (8, 24) And Mod(记录状态, 3) = 1 --@@@
                  And 审核人 Is Null And 费用id = r_Bill.Id;
          
            --有剩余数量无准退数量的有两种情况：
            --1.不跟踪在用的卫材无对应的收发记录,这时使用剩余数量
            --2.并发操作,此时已发药或发料
            If n_准退数量 = 0 Then
              If r_Bill.收费类别 = '4' Then
                If n_Count > 0 Then
                  v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发料,须退料后再退费！';
                  Raise Err_Item;
                Else
                  n_准退数量 := n_剩余数量;
                End If;
              Else
                v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发药,须退药后再退费！';
                Raise Err_Item;
              End If;
            End If;
          End If;
        
          --是否部分退费
          If r_Bill.执行状态 = 2 Or n_准退数量 <> Nvl(r_Bill.付数, 1) * r_Bill.数次 Then
            n_正常退费 := 0;
          End If;
        
          --处理门诊费用记录
          n_费用状态 := 0;
          --该笔项目第几次退费
          If Nvl(校对标志_In, 0) <> 0 Then
            n_退费次数 := -9; --先标明,固定为9
            n_费用状态 := 1;
          Else
            Select Nvl(Max(Abs(执行状态)), 0) + 1
            Into n_退费次数
            From 门诊费用记录
            Where NO = No_In And 记录性质 = 1 And 记录状态 = 2 And Nvl(执行状态, 0) < 0 And 序号 = r_Bill.序号;
          End If;
        
          --金额=剩余金额*(准退数/剩余数)
          If Nvl(r_Bill.误差, 0) = 9 Then
            --误差可以超过设置的小数位(比如:医保结算超过小数位后,误差就可能超过小数位
            n_应收金额 := Round(n_剩余应收 * (n_准退数量 / n_剩余数量), 5);
            n_实收金额 := Round(n_剩余实收 * (n_准退数量 / n_剩余数量), 5);
            n_统筹金额 := Round(n_剩余统筹 * (n_准退数量 / n_剩余数量), 5);
          Else
            n_应收金额 := Round(n_剩余应收 * (n_准退数量 / n_剩余数量), n_Dec);
            n_实收金额 := Round(n_剩余实收 * (n_准退数量 / n_剩余数量), n_Dec);
            n_统筹金额 := Round(n_剩余统筹 * (n_准退数量 / n_剩余数量), n_Dec);
          End If;
          n_总金额 := n_总金额 + n_实收金额;
        
          --插入退费记录
          Insert Into 门诊费用记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别,
             收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人,
             执行状态, 费用状态, 执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 结论,
             缴款组id)
            Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别,
                   病人科室id, 收费类别, 收费细目id, 计算单位, Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, 付数, 1), 发药窗口,
                   Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, -1 * 数次, -1 * n_准退数量), 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价,
                   -1 * n_应收金额, -1 * n_实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, -1 * n_退费次数, n_费用状态, 执行时间, 操作员编号_In,
                   操作员姓名_In, 发生时间, d_Date, n_结帐id, -1 * n_实收金额, 保险项目否, 保险大类id, -1 * n_统筹金额, Nvl(退费摘要_In, 摘要),
                   Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, 结论, n_组id
            From 门诊费用记录
            Where ID = r_Bill.Id;
        
          --标记原费用记录
          --执行状态:全部退完(准退数=剩余数)标记为0,否则标记为1,异常收费单,还是标明9
          Update 门诊费用记录
          Set 记录状态 = 3, 执行状态 = Decode(Nvl(执行状态, 0), 9, 9, Decode(Sign(n_准退数量 - n_剩余数量), 0, 0, 1))
          Where ID = r_Bill.Id;
        End If;
      Else
        If 序号_In Is Not Null Then
          v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经完全执行,不能退费！';
          Raise Err_Item;
        End If;
        --情况:没限定行号,原始单据中包括已经完全执行的
        n_正常退费 := 0;
      End If;
    Else
      n_正常退费 := 0; --未指定该笔,属于部分退费
    End If;
  End Loop;
  ---------------------------------------------------------------------------------
  --处理病人预交记录

  --原单据的结帐ID
  Select 结帐id, 病人id
  Into n_原结帐id, n_病人id
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Rownum = 1;

  If n_正常退费 = 1 And Nvl(退款操作_In, 0) = 0 Then
    --单据第一次退费且全部退完
    --冲预交部分记录
    Insert Into 病人预交记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交, 结帐id,
       缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
      Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, d_Date,
             操作员姓名_In, 操作员编号_In, -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
             Decode(校对标志_In, 1, 2, 校对标志_In), n_结算序号, 3, n_会话号
      From 病人预交记录
      Where 记录性质 In (1, 11) And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0;
    If Nvl(校对标志_In, 0) = 0 Then
      --处理病人预交余额
      For v_预交 In (Select 预交类别, Nvl(Sum(Nvl(冲预交, 0)), 0) As 预交金额, 病人id
                   From 病人预交记录
                   Where 记录性质 In (1, 11) And 结帐id = n_原结帐id
                   Group By 预交类别, 病人id
                   Having Sum(Nvl(冲预交, 0)) <> 0) Loop
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) + Nvl(v_预交.预交金额, 0)
        Where 病人id = v_预交.病人id And 性质 = 1 And 类型 = Nvl(v_预交.预交类别, 2)
        Returning 预交余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 病人余额
            (病人id, 类型, 预交余额, 性质)
          Values
            (v_预交.病人id, Nvl(v_预交.预交类别, 2), Nvl(v_预交.预交金额, 0), 1);
          n_返回值 := n_预交金额;
        End If;
        If n_返回值 = 0 Then
          Delete From 病人余额
          Where 病人id = v_预交.病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
        End If;
      End Loop;
    End If;
    --非医保全退,和医保所有结算方式都允许回退,原样退回(冲预交在前面已处理)
    If 医保结算方式_In Is Null Then
      v_结算内容 := ',' || Nvl(一卡通结算_In, '-Lxh') || ',' || Nvl(一卡通结算_In, 'Lxh') || ',';
    
      --一卡通或消费卡或银行卡的相关数据需要特殊处理,需要最后较对.
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
         卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
        Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, d_Date, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
               -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
               Case
                 When Nvl(卡类别id, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(结算卡序号, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(q.预交id, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(j.名称, '-') <> '-' Then
                  Decode(校对标志_In, 1, 1, 0)
                 Else
                  Decode(校对标志_In, 1, 2, 0)
               End As 校对标志, n_结算序号, 3, n_会话号
        From 病人预交记录 A, (Select 名称 From 结算方式 Where 性质 In (3, 4)) J,
             (Select m.Id As 预交id
               From 病人预交记录 M, 一卡通目录 C
               Where m.结帐id = n_原结帐id And m.结算方式 = c.结算方式 And m.记录性质 = 3 And m.记录状态 = 1) Q
        Where a.记录性质 = 3 And a.记录状态 = 1 And a.结帐id = n_原结帐id And a.Id = q.预交id(+) And a.结算方式 = j.名称(+) And
              Instr(v_结算内容, ',' || 结算方式 || ',') = 0 And
              (Not Exists (Select 1 From 病人卡结算对照 Where a.Id = 预交id) Or Nvl(结算卡序号, 0) = 0);
    
      --处理消费卡,结算卡在上面就已经处理了
      Zl_Square_Update(n_原结帐id, n_结帐id, n_组id, d_Date, n_结算序号, v_结算内容);
      --b.余下的就是三方接口支持的退现了,不允许作废的结算方式,加上到指定的结算方式上,加上误差(因为界面程序会在这之后退误差)
      If 一卡通结算_In Is Not Null Then
        Begin
          Select -1 * Nvl(Sum(冲预交), 0) Into n_已退金额 From 病人预交记录 Where 结帐id = n_结帐id;
        Exception
          When Others Then
            n_已退金额 := 0;
        End;
      
        If (n_总金额 - n_已退金额) <> 0 Then
          --此时的总金额还没有包含误差,因为界面程序中在调用本过程后才产生误差费用记录
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号,
             交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
            Select 病人预交记录_Id.Nextval, 3, NO, 2, 病人id, 主页id, '门诊退费结算', v_退费结算, d_Date, 操作员编号_In, 操作员姓名_In,
                   -1 * (n_总金额 - n_已退金额), n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
                   Decode(校对标志_In, 1, 2, 0), n_结算序号, 3, n_会话号
            From 病人预交记录
            Where 记录性质 = 3 And 记录状态 = 1 And 结帐id = n_原结帐id And Rownum = 1;
          n_部分退 := 1;
        End If;
      End If;
      --医保按允许作废的结算方式退,不允许的,退到指定的结算方式上
      --需要处理误差金额
    Else
      --a.原样退回
      v_结算内容 := ',' || 医保结算方式_In || ',' || Nvl(一卡通结算_In, '-Lxh') || ',' || v_退费结算 || ',';
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
        Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, d_Date, 操作员编号_In, 操作员姓名_In, -1 * 冲预交, n_结帐id,
               n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
               
               Case
                 When Nvl(卡类别id, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(结算卡序号, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(q.预交id, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(j.名称, '-') <> '-' Then
                  Decode(校对标志_In, 1, 1, 0)
                 Else
                  Decode(校对标志_In, 1, 2, 0)
               End As 校对标志, n_结算序号, 3, n_会话号
        From 病人预交记录 A, (Select 名称 From 结算方式 Where 性质 In (3, 4)) J,
             (Select m.Id As 预交id
               From 病人预交记录 M, 一卡通目录 C
               Where m.结帐id = n_原结帐id And m.结算方式 = c.结算方式 And m.记录性质 = 3 And m.记录状态 = 1) Q
        Where a.记录性质 = 3 And a.记录状态 = 1 And a.结算方式 = j.名称(+) And a.结帐id = n_原结帐id And
              Instr(v_结算内容, ',' || a.结算方式 || ',') = 0 And a.Id = q.预交id(+) And
              (Not Exists (Select 1 From 病人卡结算对照 Where a.Id = 预交id) Or Nvl(结算卡序号, 0) = 0);
    
      --处理消费卡,结算卡在上面就已经处理了
      Zl_Square_Update(n_原结帐id, n_结帐id, n_组id, d_Date, n_结算序号, v_结算内容);
    
      --b.余下的就是医保不允许作废的结算方式,加上到指定的结算方式上,加上误差(因为界面程序会在这之后退误差)
      Begin
        Select -1 * Nvl(Sum(冲预交), 0) Into n_已退金额 From 病人预交记录 Where 结帐id = n_结帐id;
      Exception
        When Others Then
          n_已退金额 := 0;
      End;
    
      If (n_总金额 - n_已退金额) <> 0 Then
        --此时的总金额还没有包含误差,因为界面程序中在调用本过程后才产生误差费用记录
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
          Select 病人预交记录_Id.Nextval, 3, NO, 2, 病人id, 主页id, Decode(一卡通结算_In, Null, '门诊医保接口退费', '门诊医保接口和三方接口退费'), v_退费结算,
                 d_Date, 操作员编号_In, 操作员姓名_In, -1 * (n_总金额 - n_已退金额), n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
                 合作单位, Decode(校对标志_In, 1, 2, 0), n_结算序号, 3, n_会话号
          From 病人预交记录
          Where 记录性质 = 3 And 记录状态 = 1 And 结帐id = n_原结帐id And Rownum = 1;
        n_部分退 := 1;
      End If;
    
    End If;
  Else
    -------------------------------------------------
    --部分退费
    n_已退金额 := 0;
    --医疗卡部分退费时，传入:结算方式|金额
    If 一卡通结算_In Is Not Null Then
      If Instr(一卡通结算_In, '|') > 0 Then
        v_当前结算 := 一卡通结算_In;
        v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
        v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
        n_结算金额 := Nvl(To_Number(v_当前结算), 0);
        If Not Nvl(v_结算方式, 'TMP') = 'TMP' Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
             卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
            Select 病人预交记录_Id.Nextval, 3, No_In, 2, 病人id, 主页id, '三方接口部分退费', v_结算方式, d_Date, Null, Null, Null, 操作员编号_In,
                   操作员姓名_In, -1 * (n_结算金额), n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
                   Decode(校对标志_In, 1, 1, 0), n_结算序号, 3, n_会话号
            From 病人预交记录
            Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id And Rownum < 2;
        End If;
        n_已退金额 := n_结算金额;
      End If;
    End If;
    --其它直接退为指定结算方式
    If (n_总金额 - n_已退金额 + Nvl(误差_In, 0)) <> 0 Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
         结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
        Select 病人预交记录_Id.Nextval, 3, No_In, 2, 病人id, 主页id, '部分退费结算', v_退费结算, d_Date, Null, Null, Null, 操作员编号_In,
               操作员姓名_In, -1 * (n_总金额 - n_已退金额 + Nvl(误差_In, 0)), n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
               Decode(校对标志, 1, 2, 0), n_结算序号, 3, n_会话号
        From 病人预交记录
        Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id And Rownum = 1;
    End If;
    --如果收费时只使用了预交款,则要退预交,并且可能有多笔冲预交
    If Sql%RowCount = 0 And 一卡通结算_In Is Null Then
      n_预交金额 := n_总金额 - n_已退金额 + Nvl(误差_In, 0);
    
      For r_Deposit In c_Deposit(n_原结帐id) Loop
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 d_Date, 操作员姓名_In, 操作员编号_In, Decode(Sign(r_Deposit.金额 - n_预交金额), -1, -1 * r_Deposit.金额, -1 * n_预交金额),
                 n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, Decode(校对标志_In, 1, 2, 0), n_结算序号, 3, n_会话号
          From 病人预交记录
          Where ID = r_Deposit.Id;
      
        If Nvl(校对标志_In, 0) = 0 Then
          --更新病人预交余额
          Update 病人余额
          Set 预交余额 = Nvl(预交余额, 0) + n_总金额 + Nvl(误差_In, 0)
          Where 病人id = r_Deposit.病人id And 性质 = 1 And 类型 = 1
          Returning 预交余额 Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 病人余额
              (病人id, 类型, 预交余额, 性质)
            Values
              (r_Deposit.病人id, 1, n_总金额 + Nvl(误差_In, 0), 1);
            n_返回值 := n_总金额 + Nvl(误差_In, 0);
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 病人余额
            Where 病人id = r_Deposit.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
          End If;
        End If;
      
        --检查是否已经处理完
        If r_Deposit.金额 < n_预交金额 Then
          n_预交金额 := n_预交金额 - r_Deposit.金额;
        Else
          n_预交金额 := 0;
        End If;
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
    End If;
  End If;

  --更新原记录
  Update 病人预交记录 Set 记录状态 = 3 Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id;

  If 多单据全退_In <> 1 Then
    --处理误差项,多单据全退时 ,按原样退无误差处理
    --将误差项的记录状态调整为3
    If Nvl(误差_In, 0) <> 0 Then
      n_Count := 1;
      If n_正常退费 = 1 And Nvl(退款操作_In, 0) = 0 Then
        n_原误差费 := 0;
        --原样退,但存在误差
        If n_部分退 = 0 Then
          Select -1 * Nvl(Sum(实收金额), 0)
          Into n_原误差费
          From 门诊费用记录 A
          Where NO = No_In And a.记录性质 = 1 And a.记录状态 In (1, 3) And Nvl(a.附加标志, 0) = 9;
        End If;
        If Nvl(n_原误差费, 0) <> 0 Or Nvl(误差_In, 0) <> 0 Then
          Update 病人预交记录
          Set 冲预交 = 冲预交 - n_原误差费 - Nvl(误差_In, 0)
          Where 结算方式 = v_退费结算 And 结帐id = n_结帐id;
          If Sql%NotFound Then
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
               卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
              Select 病人预交记录_Id.Nextval, 3, No_In, 2, 病人id, 主页id, '误差费', v_退费结算, d_Date, Null, Null, Null, 操作员编号_In,
                     操作员姓名_In, -1 * n_原误差费 - Nvl(误差_In, 0), n_结帐id, n_组id, 预交类别, Null, Null, Null, Null, Null, Null, 0,
                     n_结算序号, 3, n_会话号
              From 病人预交记录
              Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id And Rownum = 1;
          End If;
        End If;
      End If;
    Elsif n_正常退费 = 1 And Nvl(退款操作_In, 0) = 0 Then
      --原样退时,需要处理预交记录不足的情况
      Select Nvl(Sum(Nvl(结帐金额, 0)), 0) Into n_实收金额 From 门诊费用记录 Where 结帐id = n_结帐id;
      Select Nvl(Sum(Nvl(冲预交, 0)), 0) Into n_返回值 From 病人预交记录 Where 结帐id = n_结帐id;
      If Abs(n_实收金额) <> Abs(n_返回值) Then
        n_实收金额 := n_实收金额 - n_返回值;
        Update 病人预交记录 Set 冲预交 = 冲预交 + Nvl(n_实收金额, 0) Where 结算方式 = v_退费结算 And 结帐id = n_结帐id;
        If Sql%NotFound Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
             卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
            Select 病人预交记录_Id.Nextval, 3, No_In, 2, 病人id, 主页id, '误差费', v_退费结算, d_Date, Null, Null, Null, 操作员编号_In,
                   操作员姓名_In, Nvl(n_实收金额, 0), n_结帐id, n_组id, 预交类别, Null, Null, Null, Null, Null, Null, 0, n_结算序号, 3,
                   n_会话号
            From 病人预交记录
            Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id And Rownum = 1;
        End If;
      End If;
    End If;
  
    Select Nvl(Sum(Nvl(结帐金额, 0)), 0) Into n_实收金额 From 门诊费用记录 Where 结帐id = n_结帐id;
    Select Nvl(Sum(Nvl(冲预交, 0)), 0) Into n_返回值 From 病人预交记录 Where 结帐id = n_结帐id;
  
    n_实收金额 := n_实收金额 - n_返回值;
  
    If n_实收金额 <> 0 Then
      --未找到，新产生误差项
      Zl_门诊收费误差_Insert(No_In, n_实收金额, 1);
    End If;
  End If;
  ---------------------------------------------------------------------------------
  --人员缴款余额(注意是预交记录处理后才处理，包括个人帐户等的结算金额,不含退冲预交款)
  --如果是需要校对的,暂不处理人员缴款余额
  If Nvl(校对标志_In, 0) = 0 Then
    For r_Moneyrow In c_Money(n_结帐id) Loop
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + r_Moneyrow.冲预交
      Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Moneyrow.结算方式
      Returning 余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (操作员姓名_In, r_Moneyrow.结算方式, 1, r_Moneyrow.冲预交);
        n_返回值 := r_Moneyrow.冲预交;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Moneyrow.结算方式 And Nvl(余额, 0) = 0;
      End If;
    End Loop;
  End If;

  ---------------------------------------------------------------------------------
  --退费票据回收(仅全退时才回退,部分退是在重打过程中回收)
  If 回收票据_In = 0 Then
  
    --启用标志||NO;执行科室(条数);收据费目(首页汇总,条数);收费细目(条数)
    v_Para     := Nvl(zl_GetSysParameter('票据分配规则', 1121), '0||0;0;0,0;0');
    n_启用模式 := Zl_To_Number(Substr(v_Para, 1, 1));
    If n_启用模式 <> 0 Then
      --收回票据
      Select 使用id Bulk Collect
      Into l_使用id
      From (Select Distinct b.使用id From 票据打印明细 B Where b.No = No_In And Nvl(b.票种, 0) = 1);
    
      n_启用模式 := l_使用id.Count;
      If l_使用id.Count <> 0 Then
        --插入回收记录
        Forall I In 1 .. l_使用id.Count
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 操作员姓名_In, d_Date
            From 票据使用明细 A
            Where ID = l_使用id(I) And 性质 = 1 And Not Exists
             (Select 1 From 票据使用明细 Where 号码 = a.号码 And 票种 = a.票种 And Nvl(性质, 0) <> 1);
      
        Forall I In 1 .. l_使用id.Count
          Update 票据打印明细 Set 是否回收 = 1 Where 使用id = l_使用id(I) And Nvl(是否回收, 0) = 0;
      
      End If;
    End If;
    If n_启用模式 = 0 Then
      --获取单据最后一次的打印ID(可能是多张单据收费打印)
      Begin
        --性质=1，原因=6为退费打印票据(红票)，不回收
        Select ID
        Into n_打印id
        From (Select b.Id
               From 票据使用明细 A, 票据打印内容 B
               Where a.打印id = b.Id And a.性质 = 1 And a.原因 In (1, 3) And b.数据性质 = 1 And b.No = No_In
               Order By a.使用时间 Desc)
        Where Rownum < 2;
      Exception
        When Others Then
          Null;
      End;
      --可能以前没有打印,无收回
      If n_打印id Is Not Null Then
        --a.多张单据循环调用时只能收回一次
        Select Count(*) Into n_Count From 票据使用明细 Where 票种 = 1 And 性质 = 2 And 打印id = n_打印id;
        If n_Count = 0 Then
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
            From 票据使用明细
            Where 打印id = n_打印id And 票种 = 1 And 性质 = 1;
        Else
          --b.部分退费多次收回时,最后一次全退收回要排开已收回的
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
            From 票据使用明细 A
            Where 打印id = n_打印id And 票种 = 1 And 性质 = 1 And Not Exists
             (Select 1 From 票据使用明细 B Where a.号码 = b.号码 And 打印id = n_打印id And 票种 = 1 And 性质 = 2);
        End If;
      End If;
    End If;
  End If;

  ---------------------------------------------------------------------------------
  --药品卫材相关内容
  For r_Expenses In (Select ID
                     From 门诊费用记录
                     Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And 收费类别 In ('4', '5', '6', '7') And
                           (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null)) Loop
    Zl_药品收发记录_销售退费(r_Expenses.Id);
  End Loop;

  --医嘱处理
  --删除病人医嘱附费(最后一次删除时)
  For c_医嘱 In (Select Distinct 医嘱序号
               From 门诊费用记录
               Where NO = No_In And 记录性质 = 1 And 记录状态 = 3 And 医嘱序号 Is Not Null) Loop
    Select Nvl(Count(*), 0)
    Into n_Count
    From (Select 序号, Sum(数量) As 剩余数量
           From (Select 记录状态, 执行状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                  From 门诊费用记录
                  Where 记录性质 = 1 And Nvl(附加标志, 0) <> 9 And 医嘱序号 + 0 = c_医嘱.医嘱序号 And NO = No_In
                  Group By 记录状态, 执行状态, Nvl(价格父号, 序号))
           Group By 序号
           Having Sum(数量) <> 0);
  
    If n_Count = 0 Then
      Delete From 病人医嘱附费 Where 医嘱id = c_医嘱.医嘱序号 And 记录性质 = 1 And NO = No_In;
    End If;
  End Loop;

  --场合_In    Integer:=0, --0:门诊;1-住院
  --性质_In    Integer:=1, --1-收费单;2-记帐单
  --操作_In    Integer:=0, --0:删除划价单;1-收费或记帐;2-退费或销帐
  --No_In      门诊费用记录.No%Type,
  --医嘱ids_In Varchar2 := Null
  Zl_医嘱发送_计费状态_Update(0, 1, 2, No_In);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费记录_Delete;
/

--102414:涂建华,2016-11-29,pacs依赖接口调整，支持多份报告
CREATE OR REPLACE Function Zlpub_Pacs_获取报告列表
(
  病人id_In In 病人医嘱记录.病人id%Type,
  主页id_In In 病人医嘱记录.主页id%Type
) Return Varchar2 Is
  Pragma Autonomous_Transaction;
  
  TYPE C_REPORT_LIST IS REF CURSOR;
  C_REPORT_ITEM C_REPORT_LIST;

  v_Return Varchar2(4000);  
  v_Sql    Varchar2(4000);
  v_Temp   Varchar2(2000);
  n_Count  Number;
  
  n_ITEM_Id       Varchar2(64);
  n_ITEM_YZID     Number(18);
  v_ITEM_GP       Varchar2(64);
  v_ITEM_MC       Varchar2(1024);
  n_ITEM_BGLX     Number(18);
  v_ITEM_BGR      Varchar2(64);
  v_ITEM_BGSJ     Varchar2(64);  

Begin
  
    Select Count(*) Into n_Count From user_tables Where table_name =Upper('zlTempReportList');
    
    if n_Count > 0 then
      v_sql := 'Truncate Table zlTempReportList';
      Execute Immediate v_sql;
      Commit;
    Else
      v_sql := 'Create Global Temporary Table zlTempReportList(
               ID Varchar2(64),   
               YZID Number(18),             
               GP Number(1),
               MC Varchar2(1024),
               BGLX Number(1),
               BGR Varchar2(64),
               BGSJ Date
              ) On Commit Preserve Rows'; 
                    
      Execute Immediate v_sql;
    End if;

    v_Sql := 'Insert Into zlTempReportList(Id, YZID, GP, MC, BGLX, BGR, BGSJ) 
                           Select b.病历id || '''' As ID, a.Id As YZID, Decode(d.检查uid, Null, 0, 1) As GP, a.医嘱内容 As MC, 0 As BGLX, c.保存人 As BGR, c.完成时间 As BGSJ
                           From 病人医嘱记录 A, 病人医嘱报告 B, 电子病历记录 C, 影像检查记录 D, 病人医嘱发送 E
                           Where a.Id = b.医嘱id And b.病历id = c.Id And A.Id=E.医嘱ID And a.诊疗类别 = ''D'' And A.相关id Is Null And B.RISID Is Null And
                           c.完成时间 Is Not Null And a.Id = d.医嘱id(+) And a.医嘱期效 = 1 And a.医嘱状态 In (3, 5, 6, 7, 8) And E.执行状态=1 And
                           a.病人id = :1 And nvl(a.主页id,0) = :2';  
    Begin                   
        Execute Immediate v_Sql Using 病人id_In,主页id_In;
    Exception
      When Others Then
        Begin
          v_Sql := 'Insert Into zlTempReportList(Id, YZID, GP, MC, BGLX, BGR, BGSJ) 
                                 Select b.病历id || '''' As ID, a.Id As YZID, Decode(d.检查uid, Null, 0, 1) As GP, a.医嘱内容 As MC, 0 As BGLX, c.保存人 As BGR, c.完成时间 As BGSJ
                                 From 病人医嘱记录 A, 病人医嘱报告 B, 电子病历记录 C, 影像检查记录 D, 病人医嘱发送 E
                                 Where a.Id = b.医嘱id And b.病历id = c.Id And A.Id=E.医嘱ID And a.诊疗类别 = ''D'' And 相关id Is Null And
                                 c.完成时间 Is Not Null And a.Id = d.医嘱id(+) And a.医嘱期效 = 1 And a.医嘱状态 In (3, 5, 6, 7, 8) And E.执行状态=1 And
                                 a.病人id = :1 And nvl(a.主页id,0) = :2';  
          Execute Immediate v_Sql Using 病人id_In,主页id_In;
        Exception
          When Others Then Null;
        end; 
    End;
    
    
    v_Sql := 'Insert Into zlTempReportList(Id, YZID, GP, MC, BGLX, BGR, BGSJ) 
                          Select b.检查报告id || '''' As ID, a.Id As YZID, Decode(d.检查uid, Null, 0, 1) As GP, a.医嘱内容 As MC, 1 as BGLX, c.最后编辑人 As BGR, c.最后审核时间 As BGSJ
                          From 病人医嘱记录 A, 病人医嘱报告 B, 影像报告记录 C, 影像检查记录 D, 病人医嘱发送 E
                          where a.Id = b.医嘱id And b.检查报告id = c.Id And A.Id=E.医嘱ID And a.诊疗类别 = ''D'' And 相关id Is Null And
                          c.最后审核时间 Is Not Null And a.Id = d.医嘱id(+) And a.医嘱期效 = 1 And a.医嘱状态 In (3, 5, 6, 7, 8) And E.执行状态=1 And
                          a.病人id = :1 And nvl(a.主页id,0) = :2';
    Begin
        Execute Immediate v_Sql Using 病人id_In,主页id_In;
    Exception
      When Others Then Null;
    End;
     
    
    v_Sql := 'Insert Into zlTempReportList(Id, YZID, GP, MC, BGLX, BGR, BGSJ)
                          Select b.RISID || '''' As ID, a.Id As YZID, 2 As GP, a.医嘱内容 As MC, 2 as BGLX, c.保存人 As BGR, c.完成时间 As BGSJ
                          From 病人医嘱记录 A, 病人医嘱报告 B, 电子病历记录 C, 影像检查记录 D, 病人医嘱发送 E
                          Where a.Id = b.医嘱id And b.病历ID = c.Id And A.Id=E.医嘱ID And a.诊疗类别 = ''D'' And 相关id Is Null And B.RISID Is Not Null And
                          c.完成时间 Is Not Null And a.Id = d.医嘱id(+) And a.医嘱期效 = 1 And a.医嘱状态 In (3, 5, 6, 7, 8) And E.执行状态=1 And
                          a.病人id = :1 And nvl(a.主页id,0) = :2';     
    Begin
        Execute Immediate v_Sql Using 病人id_In,主页id_In; 
    Exception
      When Others Then Null;
    End;
    
    Commit;
    
    v_Sql := 'Select Id, YZID, GP, MC, BGLX, BGR, To_Char(BGSJ,''yyyy-mm-dd hh24:mi:ss'') As BGSJ  From zlTempReportList Order by BGSJ';

    Open C_REPORT_ITEM For v_Sql;
    Loop
      Fetch C_REPORT_ITEM INTO n_ITEM_ID, n_ITEM_YZID, v_ITEM_GP, v_ITEM_MC, n_ITEM_BGLX, v_ITEM_BGR, v_ITEM_BGSJ;
      Exit When C_REPORT_ITEM%NotFound;
      
      v_Temp := '<FILE>' || 
                      '<ID>' || n_ITEM_ID || '</ID>' || 
                      '<YZID>' || n_ITEM_YZID || '</YZID>' ||
                      '<GP>' || v_ITEM_GP || '</GP>' || 
                      '<MC>' || v_ITEM_MC || '</MC>' || 
                      '<BGLX>' || n_ITEM_BGLX || '</BGLX>' || 
                      '<BGR>' || v_ITEM_BGR || '</BGR>' ||
                      '<BGSJ>' || v_ITEM_BGSJ || '</BGSJ>' || 
             '</FILE>';

      v_Return := v_Return || v_Temp;
    End Loop;
    Close C_REPORT_ITEM;

    If v_Return <> ' ' Then
      v_Return := '<FILELIST>' || v_Return || '</FILELIST>';
    End If;

    Return v_Return;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zlpub_Pacs_获取报告列表;
/

--102414:涂建华,2016-12-09,pacs依赖接口调整，支持多份报告
CREATE OR REPLACE Function Zlpub_Pacs_获取报告列表Ex
(
  医嘱ID_In In 病人医嘱记录.id%Type
) Return Varchar2 Is
  Pragma Autonomous_Transaction;
  
  TYPE C_REPORT_LIST IS REF CURSOR;
  C_REPORT_ITEM C_REPORT_LIST;

  v_Return Varchar2(4000);  
  v_Sql    Varchar2(4000);
  v_Temp   Varchar2(2000);
  n_Count  Number;
  
  n_ITEM_Id       Varchar2(64);
  n_ITEM_YZID     Number(18);
  v_ITEM_YZNR     Varchar2(1024);
  v_ITEM_MC       Varchar2(60);
  n_ITEM_BGLX     Number(18);
  v_ITEM_BGR      Varchar2(64);
  v_ITEM_BGSJ     Varchar2(64);  

Begin
  
    Select Count(*) Into n_Count From user_tables Where table_name =Upper('zlTempReportListEx');
    
    if n_Count > 0 then
      v_sql := 'Truncate Table zlTempReportListEx';
      Execute Immediate v_sql;
      Commit;
    Else
      v_sql := 'Create Global Temporary Table zlTempReportListEx(
               ID Varchar2(64),   
               YZID Number(18),             
               YZNR Varchar2(1024),
               MC Varchar2(60),
               BGLX Number(1),
               BGR Varchar2(64),
               BGSJ Date
              ) On Commit Preserve Rows'; 
                    
      Execute Immediate v_sql;
    End if;

    v_Sql := 'Insert Into zlTempReportListEx(Id, YZID, YZNR, MC, BGLX, BGR, BGSJ) 
                           Select b.病历id || '''' As ID, a.Id As YZID, a.医嘱内容 As YXNR, c.病历名称 as MC, 0 As BGLX, c.保存人 As BGR, c.完成时间 As BGSJ
                           From 病人医嘱记录 A, 病人医嘱报告 B, 电子病历记录 C, 影像检查记录 D, 病人医嘱发送 E
                           Where a.Id = b.医嘱id And b.病历id = c.Id And A.Id=E.医嘱ID And a.诊疗类别 = ''D'' And 相关id Is Null And B.RISID Is Null And
                           c.完成时间 Is Not Null And a.Id = d.医嘱id(+) And a.医嘱期效 = 1 And a.医嘱状态 In (3, 5, 6, 7, 8) And E.执行状态 = 1 And
                           a.ID = :1';  
    Begin                   
        Execute Immediate v_Sql Using 医嘱ID_In;
    Exception
      When Others Then
        Begin
          v_Sql := 'Insert Into zlTempReportListEx(Id, YZID, YZNR, MC, BGLX, BGR, BGSJ) 
                                 Select b.病历id || '''' As ID, a.Id As YZID, a.医嘱内容 As YZNR, c.病历名称 As MC, 0 As BGLX, c.保存人 As BGR, c.完成时间 As BGSJ
                                 From 病人医嘱记录 A, 病人医嘱报告 B, 电子病历记录 C, 影像检查记录 D, 病人医嘱发送 E
                                 Where a.Id = b.医嘱id And b.病历id = c.Id And A.Id=E.医嘱ID And a.诊疗类别 = ''D'' And 相关id Is Null And
                                 c.完成时间 Is Not Null And a.Id = d.医嘱id(+) And a.医嘱期效 = 1 And a.医嘱状态 In (3, 5, 6, 7, 8) And E.执行状态 = 1 And
                                 a.id = :1';  
          Execute Immediate v_Sql Using 医嘱ID_In;
        Exception
          When Others Then Null;
        end; 
    End;
    
    
    v_Sql := 'Insert Into zlTempReportListEx(Id, YZID, YZNR, MC, BGLX, BGR, BGSJ) 
                          Select b.检查报告id || '''' As ID, a.Id As YZID, a.医嘱内容 As YZNR, c.文档标题 As MC, 1 as BGLX, c.最后编辑人 As BGR, c.最后审核时间 As BGSJ
                          From 病人医嘱记录 A, 病人医嘱报告 B, 影像报告记录 C, 影像检查记录 D, 病人医嘱发送 E
                          where a.Id = b.医嘱id And b.检查报告id = c.Id And A.Id=E.医嘱ID And a.诊疗类别 = ''D'' And 相关id Is Null And
                          c.最后审核时间 Is Not Null And a.Id = d.医嘱id(+) And a.医嘱期效 = 1 And a.医嘱状态 In (3, 5, 6, 7, 8) And E.执行状态 = 1 And
                          a.id = :1';
    Begin
        Execute Immediate v_Sql Using 医嘱ID_In;
    Exception
      When Others Then Null;
    End;
     
    
    v_Sql := 'Insert Into zlTempReportListEx(Id, YZID, YZNR, MC, BGLX, BGR, BGSJ)
                          Select b.RISID || '''' As ID, a.Id As YZID, a.医嘱内容 As YZNR, c.病历名称 As MC, 2 as BGLX, c.保存人 As BGR, c.完成时间 As BGSJ
                          From 病人医嘱记录 A, 病人医嘱报告 B, 电子病历记录 C, 影像检查记录 D, 病人医嘱发送 E
                          Where a.Id = b.医嘱id And b.病历ID = c.Id And A.Id=E.医嘱ID And a.诊疗类别 = ''D'' And 相关id Is Null And B.RISID Is Not Null And
                          c.完成时间 Is Not Null And a.Id = d.医嘱id(+) And a.医嘱期效 = 1 And a.医嘱状态 In (3, 5, 6, 7, 8) And E.执行状态 = 1 And
                          a.id = :1';     
    Begin
        Execute Immediate v_Sql Using 医嘱ID_In; 
    Exception
      When Others Then Null;
    End;
    
    Commit;
    
    v_Sql := 'Select Id, YZID, YZNR, MC, BGLX, BGR, To_Char(BGSJ,''yyyy-mm-dd hh24:mi:ss'') As BGSJ  From zlTempReportListEx Order by BGSJ';

    Open C_REPORT_ITEM For v_Sql;
    Loop
      Fetch C_REPORT_ITEM INTO n_ITEM_ID, n_ITEM_YZID, v_ITEM_YZNR, v_ITEM_MC, n_ITEM_BGLX, v_ITEM_BGR, v_ITEM_BGSJ;
      Exit When C_REPORT_ITEM%NotFound;
      
      v_Temp := '<FILE>' || 
                      '<ID>' || n_ITEM_ID || '</ID>' || 
                      '<YZID>' || n_ITEM_YZID || '</YZID>' ||
                      '<YZNR>' || v_ITEM_YZNR || '</YZNR>' || 
                      '<MC>' || v_ITEM_MC || '</MC>' || 
                      '<BGLX>' || n_ITEM_BGLX || '</BGLX>' || 
                      '<BGR>' || v_ITEM_BGR || '</BGR>' ||
                      '<BGSJ>' || v_ITEM_BGSJ || '</BGSJ>' || 
             '</FILE>';

      v_Return := v_Return || v_Temp;
    End Loop;
    Close C_REPORT_ITEM;

    If v_Return <> ' ' Then
      v_Return := '<FILELIST>' || v_Return || '</FILELIST>';
    End If;

    Return v_Return;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zlpub_Pacs_获取报告列表Ex;
/

--102414:涂建华,2016-11-29,pacs依赖接口调整，支持多份报告
CREATE OR REPLACE Function Zlpub_Pacs_获取文档提纲
(
  报告id_In In 病人医嘱报告.检查报告ID%Type
) Return Varchar2 Is
  v_报告提纲 Varchar2(1000);
  v_提纲内容 Varchar2(100);

  x_Content xmltype;
  n_NodeNum number(2);
  Xcdom            Xmldom.Domdocument;
  Section_List     Xmldom.Domnodelist;
Begin
    v_报告提纲 := '';

    Select b.报告内容 Into x_Content From 病人医嘱报告 a, 影像报告记录 b Where a.检查报告id=b.id And  a.检查报告id = 报告id_In;

    Xcdom         := Xmldom.Newdomdocument(x_Content);
    Section_List  := Xmldom.Getelementsbytagname(Xcdom, 'section');
    n_NodeNum     := Xmldom.Getlength(Section_List);

    For i in 0..n_NodeNum-1 Loop
      v_提纲内容 := Xmldom.Getattribute(Xmldom.Makeelement(Xmldom.Item(Section_List, i)), 'title');

      If Nvl(v_提纲内容,' ') != ' ' Then
        v_报告提纲 := v_报告提纲 || '<split>' || v_提纲内容;
      End If;
    End Loop;
    
    Return(Substr(v_报告提纲, 8));
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zlpub_Pacs_获取文档提纲;
/

--102414:涂建华,2016-11-29,pacs依赖接口调整，支持多份报告
CREATE OR REPLACE Function Zlpub_Pacs_获取病历提纲
(
  报告id_In In 病人医嘱报告.病历id%Type
) Return Varchar2 Is
  v_报告提纲 Varchar2(1000);

  Cursor c_报告提纲 Is
    Select Distinct a.内容文本
    From 电子病历内容 A, 电子病历内容 B, 病人医嘱报告 C
    Where a.对象类型 = 3 And a.Id = b.父id And b.对象类型 = 2 And b.终止版 = 0 And a.文件id = c.病历id And c.病历id = 报告id_In;
Begin
  For Row_Cols In c_报告提纲 Loop
    v_报告提纲 := '<split>' || Row_Cols.内容文本 || v_报告提纲;
  End Loop;

  Return(Substr(v_报告提纲, 8));

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zlpub_Pacs_获取病历提纲;
/

--102414:涂建华,2016-11-29,pacs依赖接口调整，支持多份报告
CREATE OR REPLACE Function Zlpub_Pacs_获取报告提纲
(
  报告id_In In Varchar2,
  报告来源_In In Number
) Return Varchar2 Is
  v_报告提纲 Varchar2(2000);
  n_病历ID Number(18);
  
  v_Sql Varchar2(100);
Begin
  If 报告来源_In = 1 Then
    v_Sql := 'Select Zlpub_Pacs_获取文档提纲(:1)  From Dual';  
    Begin                   
        Execute Immediate v_Sql Into v_报告提纲 Using 报告id_In ;
    Exception
      When Others Then v_报告提纲 := '';          
    End;
  Else
    n_病历ID := To_Number(报告id_In);
      
    If 报告来源_In = 2 Then
      v_Sql := 'Select 病历ID From 病人医嘱报告 Where RISID=:1';
      Execute Immediate v_Sql Into n_病历ID Using 报告id_In ;
    End If;
      
    v_Sql := 'Select Zlpub_Pacs_获取病历提纲(:1)  From Dual';  
    Begin                   
        Execute Immediate v_Sql Into v_报告提纲 Using n_病历ID ;
    Exception
      When Others Then v_报告提纲 := '';          
    End;
  End If;

  Return v_报告提纲;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zlpub_Pacs_获取报告提纲;
/

--102414:涂建华,2016-11-29,pacs依赖接口调整，支持多份报告
CREATE OR REPLACE Function Zlpub_Pacs_获取文档文本
(
  Ids_In   In Varchar2
)Return XmlType Is
  Docxml XmlType;
  
  File_Id Varchar2(32);
  n_Adviceid Number(18);
  
  x_Content    Xmltype;
  Section_Node Xmldom.Domnode;
  Element_Node Xmldom.Domnode;
  Xcdom        Xmldom.Domdocument;
  Node_List    Xmldom.Domnodelist;
  Section_List Xmldom.Domnodelist;
  
  n_Count Number(1);
  --标记变量
  
  n_Len     Number(3);
  n_Width   Number(4);
  n_Height  Number(4);
  v_Id      Varchar2(100);
  v_Title   Varchar2(100);
  v_Newline Varchar2(2);
  v_Text    Varchar2(4000);
  v_Name    Varchar2(100);
  v_Type    Varchar2(20);
Begin
  Select Xmltype('<?xml version="1.0" encoding="' || Value || '"?><ZlEPR></ZlEPR>')
  Into Docxml
  From Nls_Database_Parameters
  Where Parameter = 'NLS_CHARACTERSET';
  
  For J In 1 .. 1000 Loop
    File_Id := 0;
    Select Zl_Eprsplit(Ids_In, '|', J) Into File_Id From Dual;
    
    If File_Id Is Null Then
      Exit;
    End If;      
    
    --开始某个文件读取
    Begin
      Select a.医嘱id,
             Appendchildxml(Docxml, '/ZlEPR',
                             Xmlelement("Document",
                                         Xmlattributes(b.姓名 As "姓名", b.病人id As "病人ID", b.主页id As "主页ID", a.文档标题 As "文件名",
                                                        Rawtohex(a.Id) As "文件ID")))
      Into n_Adviceid, Docxml
      From 影像报告记录 A, 病人医嘱记录 B
      Where a.Id = Hextoraw(File_Id) And a.医嘱id = b.Id;
    Exception
      --给定的文件ID无效
      When Others Then
        Return Null;
    End;
    
    Select Insertchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]', 'Compend',
                           Xmlelement("Compend", Xmlattributes('0' As "ID", '内容' As "Name")))
    Into Docxml
    From Dual;
      
    --开始读取内容
    Select b.报告内容 Into x_Content From 影像报告记录 B Where b.Id || '' = File_Id;
      
    Xcdom := Xmldom.Newdomdocument(x_Content);
      
    Section_List := Xmldom.Getelementsbytagname(Xcdom, 'zlxml');
    Section_Node := Xmldom.Item(Section_List, 0);
    Node_List    := Xmldom.Getelementsbytagname(Xmldom.Makeelement(Section_Node), '*');
    n_Len        := Xmldom.Getlength(Node_List);
      
    For I In 0 .. n_Len - 1 Loop
      Element_Node := Xmldom.Item(Node_List, I);
        
      v_Name    := Xmldom.Getnodename(Element_Node);
      v_Newline := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'br');
        
      If v_Newline Is Null Then
        v_Newline := '1';
      End If;
        
      If v_Name = 'section' Then
        --提纲
        v_Title := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'title');
        v_Id    := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'sid');
          
        Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]',
                               Xmlelement("Compend", Xmlattributes(v_Title As "Name", v_Id As "ID")))
        Into Docxml
        From Dual;
      Elsif v_Name = 'utext' Then
        --文本
        v_Text := LTrim(LTrim(Xmldom.Getnodevalue(Xmldom.Getfirstchild(Element_Node)), ':'), '：');
          
        If Nvl(v_Id, ' ') = ' ' Then
          Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/Compend[@ID=0]',
                                 Xmlelement("Text", Xmlattributes(v_Newline As "NewLine"), v_Text))
          Into Docxml
          From Dual;
        Else
          Select Appendchildxml(Docxml,
                                 '/ZlEPR/Document[@文件ID="' || File_Id || '"]/descendant::Compend[@ID="' || v_Id || '"]',
                                 Xmlelement("Text", Xmlattributes(v_Newline As "NewLine"), v_Text))
          Into Docxml
          From Dual;
        End If;
      Elsif v_Name = 'element' Then
        --要素
        v_Title := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'title');
        v_Text  := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'value') ||
                   Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'unit');
          
        If Nvl(v_Id, ' ') = ' ' Then
          Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/Compend[@ID=0]',
                                 Xmlelement("Element", Xmlattributes(v_Title As "Name", v_Newline As "NewLine"),
                                             v_Text))
          Into Docxml
          From Dual;
        Else
          Select Appendchildxml(Docxml,
                                 '/ZlEPR/Document[@文件ID="' || File_Id || '"]/descendant::Compend[@ID="' || v_Id || '"]',
                                 Xmlelement("Element", Xmlattributes(v_Title As "Name", v_Newline As "NewLine"),
                                             v_Text))
          Into Docxml
          From Dual;
        End If;
      Elsif v_Name = 'image' Then
        --图片
        n_Width  := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'width');
        n_Height := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'height');
        v_Name   := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'key');
        v_Type   := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'class');
          
        If Nvl(v_Name, ' ') <> ' ' Then
          If Nvl(v_Id, ' ') = ' ' Then
            Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/Compend[@ID=0]',
                                   Xmlelement("Picture",
                                               Xmlattributes(n_Width As "OrigWidth", n_Height As "OrigHeight",
                                                              n_Width As "ShowWidth", n_Height As "ShowHeight",
                                                              v_Name As "PicName", n_Adviceid As "AdviceID",
                                                              v_Type As "Type")))
            Into Docxml
            From Dual;
          Else
            Select Appendchildxml(Docxml,
                                   '/ZlEPR/Document[@文件ID="' || File_Id || '"]/descendant::Compend[@ID="' || v_Id || '"]',
                                   Xmlelement("Picture",
                                               Xmlattributes(n_Width As "OrigWidth", n_Height As "OrigHeight",
                                                              n_Width As "ShowWidth", n_Height As "ShowHeight",
                                                              v_Name As "PicName", n_Adviceid As "AdviceID",
                                                              v_Type As "Type")))
            Into Docxml
            From Dual;
          End If;
        End If;
          
      Elsif v_Name = 'signature' Then
        --签名
        v_Text := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'displayinfo');
          
        If Nvl(v_Id, ' ') = ' ' Then
          Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/Compend[@ID=0]',
                                 Xmlelement("Sign", Xmlattributes(v_Newline As "NewLine"), Zl_Eprsplit(v_Text, ';', 1)))
          Into Docxml
          From Dual;
        Else
          Select Appendchildxml(Docxml,
                                 '/ZlEPR/Document[@文件ID="' || File_Id || '"]/descendant::Compend[@ID="' || v_Id || '"]',
                                 Xmlelement("Sign", Xmlattributes(v_Newline As "NewLine"), Zl_Eprsplit(v_Text, ';', 1)))
          Into Docxml
          From Dual;
        End If;
      End If;
    End Loop;
      
    For Aa In (Select '/' || a.Ftp目录 || '/ReportImages/' || To_Char(b.创建时间, 'YYYYMMDD') || '/' || b.Id || '/' As v_Ftppath
               From 影像设备目录 A, 影像报告记录 B
               Where a.设备号 = b.设备号 And b.Id = File_Id) Loop
        
      Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/Compend[@ID=0]',
                             Xmlelement("FtpPath", Xmlattributes(v_Newline As "NewLine"), Aa.v_Ftppath))
      Into Docxml
      From Dual;
    End Loop;
  End Loop;
  
  Return Docxml;
End Zlpub_Pacs_获取文档文本;
/
--102414:涂建华,2016-11-30,pacs依赖接口调整，支持多份报告
CREATE OR REPLACE Function Zlpub_Pacs_获取病历文本
(
  Ids_In   In Varchar2,
  From_In Number
)Return XmlType Is
  Docxml XmlType;
  
  File_Id Varchar2(32);
  n_Adviceid Number(18);
  
  v_Sql        Varchar2(1000);
  
  --标记变量
  v_Mark     Varchar2(500);
  v_Marks    Varchar2(2500);
  Makxml     Xmltype;
  Maksxml    Xmltype;
  v_Ftppath  Varchar2(200);
  
  v_Newline Varchar2(2);
Begin
  Select Xmltype('<?xml version="1.0" encoding="' || Value || '"?><ZlEPR></ZlEPR>')
  Into Docxml
  From Nls_Database_Parameters
  Where Parameter = 'NLS_CHARACTERSET';
  
  For J In 1 .. 1000 Loop
    File_Id := 0;
    Select Zl_Eprsplit(Ids_In, '|', J) Into File_Id From Dual;
    
    If File_Id Is Null Then
      Exit;
    End If;  
    
    If From_In = 2 Then
       --RIS报告
       v_Sql := 'Select 病历Id From 病人医嘱报告 Where RISID = :1';
       Execute Immediate v_Sql Into File_Id Using File_Id;
    End If;
        
    --开始某个病历文件读取
    Begin
      Select Appendchildxml(Docxml, '/ZlEPR',
                             Xmlelement("Document",
                                         Xmlattributes(b.姓名 As "姓名", a.病人id As "病人ID", a.主页id As "主页ID", a.病历名称 As "文件名",
                                                        a.Id As "文件ID")))
      Into Docxml
      From 电子病历记录 A, 病人信息 B
      Where a.Id = File_Id And a.编辑方式 = 0 And a.病人id = b.病人id;
          
      Select 医嘱id Into n_Adviceid From 病人医嘱报告 Where 病历id = File_Id;
    Exception
      --给定的病历文件ID无效
      When Others Then Return Null;
    End;
        
    Select Insertchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]', 'Compend',
                           Xmlelement("Compend", Xmlattributes('0' As "ID", '内容' As "Name")))
    Into Docxml
    From Dual;
      
    Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                           Xmlelement("Text", Xmlattributes(Nvl(Null, 0) As "NewLine"), '内容文本'))
    Into Docxml
    From Dual;
      
    For Rs In (Select ID, 父id, 对象序号, 对象类型, 对象属性, 内容行次, 内容文本, 是否换行, 要素名称
               From (Select ID, 父id, 对象序号, 对象类型, 对象属性, 内容行次, 内容文本, 是否换行, 要素名称
                      From 电子病历内容
                      Where 文件id = File_Id And 对象序号 > 0 And 对象序号 <> ID And 终止版 = 0)
               Start With 父id Is Null
               Connect By Prior ID = 父id
               Order Siblings By 对象序号, 内容行次) Loop
      If Rs.对象类型 = 1 Then
        --提纲
        If Rs.父id Is Null Then
          Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']',
                                 Xmlelement("Compend", Xmlattributes(Rs.内容文本 As "Name", Rs.Id As "ID")))
          Into Docxml
          From Dual;
        Else
          Select Appendchildxml(Docxml,
                                 '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                 Xmlelement("Compend", Xmlattributes(Rs.内容文本 As "Name", Rs.Id As "ID")))
          Into Docxml
          From Dual;
        End If;
      Elsif Rs.对象类型 = 2 Then
        --文本
        If Rs.父id Is Null Then
          Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                 Xmlelement("Text", Xmlattributes(Nvl(Rs.是否换行, 0) As "NewLine"), Rs.内容文本))
          Into Docxml
          From Dual;
        Else
          Select Appendchildxml(Docxml,
                                 '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                 Xmlelement("Text", Xmlattributes(Nvl(Rs.是否换行, 0) As "NewLine"), Rs.内容文本))
          Into Docxml
          From Dual;
        End If;
      Elsif Rs.对象类型 = 3 Then
        --表格
        If Rs.父id Is Null Then
          Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                 Xmlelement("Table",
                                             Xmlattributes(Zl_Eprsplit(Rs.对象属性, ';', 1) As "Rows",
                                                            Zl_Eprsplit(Rs.对象属性, ';', 2) As "Cols",
                                                            Zl_Eprsplit(Rs.对象属性, ';', 3) As "Width",
                                                            Zl_Eprsplit(Rs.对象属性, ';', 4) As "Height",
                                                            Zl_Eprsplit(Rs.对象属性, ';', 5) As "ColWidthString",
                                                            Nvl(Rs.是否换行, 0) As "NewLine", Rs.Id As "ID"), Rs.内容文本))
          Into Docxml
          From Dual;
        Else
          Select Appendchildxml(Docxml,
                                 '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                 Xmlelement("Table",
                                             Xmlattributes(Zl_Eprsplit(Rs.对象属性, ';', 1) As "Rows",
                                                            Zl_Eprsplit(Rs.对象属性, ';', 2) As "Cols",
                                                            Zl_Eprsplit(Rs.对象属性, ';', 3) As "Width",
                                                            Zl_Eprsplit(Rs.对象属性, ';', 4) As "Height",
                                                            Zl_Eprsplit(Rs.对象属性, ';', 5) As "ColWidthString",
                                                            Nvl(Rs.是否换行, 0) As "NewLine", Rs.Id As "ID"), Rs.内容文本))
          Into Docxml
          From Dual;
        End If;
          
        ---对表格的单元格进行填充
        For Rs_Cell In (Select ID, 父id, 对象序号, 对象类型, 对象属性, 内容行次, 内容文本, 是否换行, 要素名称
                        From 电子病历内容
                        Where 文件id = File_Id And 父id = Rs.Id And 终止版 = 0
                        Order By 内容行次, ID) Loop
          If Rs_Cell.对象类型 = 2 Or Rs_Cell.对象类型 = 4 Then
            If Zl_Eprsplit(Rs_Cell.对象属性, '|', 26) Is Null Then
              --兼容历史病历
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Table[@ID=' || Rs.Id || ']',
                                     Xmlelement("Cell",
                                                 Xmlattributes(Zl_Eprsplit(Rs_Cell.对象属性, '|', 2) As "Row",
                                                                Zl_Eprsplit(Rs_Cell.对象属性, '|', 3) As "Col",
                                                                Zl_Eprsplit(Rs_Cell.对象属性, '|', 2) || '_' ||
                                                                 Zl_Eprsplit(Rs_Cell.对象属性, '|', 3) As "Row_Col",
                                                                Decode(Rs_Cell.对象类型, 2, 0, 4, 1) As "Type",
                                                                Zl_Eprsplit(Rs_Cell.对象属性, '|', 5) As "Width",
                                                                Zl_Eprsplit(Rs_Cell.对象属性, '|', 6) As "Height",
                                                                Zl_Eprsplit(Rs_Cell.对象属性, '|', 4) As "MergeNo",
                                                                Nvl(Rs.是否换行, 0) As "NewLine", Rs_Cell.Id As "ID"),
                                                 Rs_Cell.内容文本))
              Into Docxml
              From Dual;
            Else
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Table[@ID=' || Rs.Id || ']',
                                     Xmlelement("Cell",
                                                 Xmlattributes(Zl_Eprsplit(Rs_Cell.对象属性, '|', 3) As "Row",
                                                                Zl_Eprsplit(Rs_Cell.对象属性, '|', 4) As "Col",
                                                                Zl_Eprsplit(Rs_Cell.对象属性, '|', 3) || '_' ||
                                                                 Zl_Eprsplit(Rs_Cell.对象属性, '|', 4) As "Row_Col",
                                                                Decode(Rs_Cell.对象类型, 2, 0, 4, 1) As "Type",
                                                                Zl_Eprsplit(Rs_Cell.对象属性, '', 6) As "Width",
                                                                Zl_Eprsplit(Rs_Cell.对象属性, '|', 7) As "Height",
                                                                Zl_Eprsplit(Rs_Cell.对象属性, '|', 5) As "MergeNo",
                                                                Nvl(Rs.是否换行, 0) As "NewLine", Rs_Cell.Id As "ID"),
                                                 Rs_Cell.内容文本))
              Into Docxml
              From Dual;
            End If;
          Elsif Rs_Cell.对象类型 = 5 And Zl_Eprsplit(Rs_Cell.对象属性, ';', 1) = 2 Then
            --单元格图由Webservice直接读取BLOB之后直接写文件以提高速度
            Select Appendchildxml(Docxml,
                                   '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Table[@ID=' || Rs.Id || ']',
                                   Xmlelement("Picture",
                                               Xmlattributes(Zl_Eprsplit(Rs_Cell.对象属性, ';', 2) As "Row",
                                                              Zl_Eprsplit(Rs_Cell.对象属性, ';', 3) As "Col",
                                                              Zl_Eprsplit(Rs_Cell.对象属性, ';', 8) As "OrigWidth",
                                                              Zl_Eprsplit(Rs_Cell.对象属性, ';', 9) As "OrigHeight",
                                                              Zl_Eprsplit(Rs_Cell.对象属性, ';', 6) As "ShowWidth",
                                                              Zl_Eprsplit(Rs_Cell.对象属性, ';', 7) As "ShowHeight",
                                                              Nvl(Zl_Eprsplit(Rs_Cell.对象属性, ';', 12), ' ') As "PicName",
                                                              Nvl(Zl_Eprsplit(Rs_Cell.对象属性, ';', 13), '0') As "AdviceID",
                                                              Rs_Cell.Id As "ID"), Rs_Cell.Id))
            Into Docxml
            From Dual;
              
            If Nvl(n_Adviceid, 0) = 0 Then
              n_Adviceid := Nvl(Zl_Eprsplit(Rs_Cell.对象属性, ';', 13), '0');
            End If;
          Elsif Rs_Cell.对象类型 = 5 And Zl_Eprsplit(Rs_Cell.对象属性, ';', 1) <> 2 Then
            --单元格图由Webservice直接读取BLOB之后直接写文件以提高速度
            Select Appendchildxml(Docxml,
                                   '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Table[@ID=' || Rs.Id ||
                                    ']/Cell[@Row_Col="' || Zl_Eprsplit(Rs_Cell.对象属性, ';', 2) || '_' ||
                                    Zl_Eprsplit(Rs_Cell.对象属性, ';', 3) || '"]',
                                   Xmlelement("Picture",
                                               Xmlattributes(Zl_Eprsplit(Rs_Cell.对象属性, ';', 2) As "Row",
                                                              Zl_Eprsplit(Rs_Cell.对象属性, ';', 3) As "Col",
                                                              Zl_Eprsplit(Rs_Cell.对象属性, ';', 8) As "OrigWidth",
                                                              Zl_Eprsplit(Rs_Cell.对象属性, ';', 9) As "OrigHeight",
                                                              Zl_Eprsplit(Rs_Cell.对象属性, ';', 6) As "ShowWidth",
                                                              Zl_Eprsplit(Rs_Cell.对象属性, ';', 7) As "ShowHeight",
                                                              Nvl(Zl_Eprsplit(Rs_Cell.对象属性, ';', 12), ' ') As "PicName",
                                                              Nvl(Zl_Eprsplit(Rs_Cell.对象属性, ';', 13), '0') As "AdviceID",
                                                              Rs_Cell.Id As "ID"), Rs_Cell.Id))
            Into Docxml
            From Dual;
            --制作标记子节点集
            v_Mark  := '';
            Makxml  := Null;
            Maksxml := Null;
            For Rs_Mark In (Select ID, 父id, 内容文本, 内容行次
                            From 电子病历内容
                            Where 父id = Rs_Cell.Id
                            Order By 内容行次) Loop
              v_Marks := v_Mark || Rs_Mark.内容文本;
              v_Marks := Replace(v_Marks, '||', '^');
              For I In 1 .. 100 Loop
                v_Mark := Zl_Eprsplit(v_Marks, '^', I);
                If Zl_Eprsplit(v_Mark, '|', 15) Is Null Then
                  --最后一个标记信息不全，存在下一行中
                  Exit;
                Else
                  Select Xmlelement("Mark",
                                     Xmlforest(Zl_Eprsplit(v_Mark, '|', 2) As "类型",
                                                Zl_Eprsplit(v_Mark, '|', 3) As "内容", Zl_Eprsplit(v_Mark, '|', 4) As "点集",
                                                Zl_Eprsplit(v_Mark, '|', 5) As "X1", Zl_Eprsplit(v_Mark, '|', 6) As "Y1",
                                                Zl_Eprsplit(v_Mark, '|', 7) As "X2", Zl_Eprsplit(v_Mark, '|', 8) As "Y2",
                                                Zl_Eprsplit(v_Mark, '|', 9) As "填充色",
                                                Zl_Eprsplit(v_Mark, '|', 10) As "填充方式",
                                                Zl_Eprsplit(v_Mark, '|', 11) As "线条色",
                                                Zl_Eprsplit(v_Mark, '|', 12) As "字体色",
                                                Zl_Eprsplit(v_Mark, '|', 13) As "线型",
                                                Zl_Eprsplit(v_Mark, '|', 14) As "线宽",
                                                Zl_Eprsplit(v_Mark, '|', 15) As "字体"))
                  Into Makxml
                  From Dual;
                  Select Xmlconcat(Maksxml, Makxml) Into Maksxml From Dual;
                End If;
              End Loop;
            End Loop;
            --向Picture插入标记子节点
            Select Appendchildxml(Docxml,
                                   '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Picture[@ID=' || Rs_Cell.Id || ']',
                                   Maksxml)
            Into Docxml
            From Dual;
          End If;
        End Loop;
      Elsif Rs.对象类型 = 4 Then
        --要素
        If Rs.父id Is Null Then
          Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                 Xmlelement("Element", Xmlattributes(Rs.要素名称 As "Name", Nvl(Rs.是否换行, 0) As "NewLine"),
                                             Rs.内容文本))
          Into Docxml
          From Dual;
        Else
          Select Appendchildxml(Docxml,
                                 '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                 Xmlelement("Element", Xmlattributes(Rs.要素名称 As "Name", Nvl(Rs.是否换行, 0) As "NewLine"),
                                             Rs.内容文本))
          Into Docxml
          From Dual;
        End If;
      Elsif Rs.对象类型 = 5 And Nvl(Rs.内容行次, 0) = 0 Then
        --图片由Webservice直接读取BLOB之后直接写文件以提高速度
 
        If Rs.父id Is Null Then
          Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                 Xmlelement("Picture",
                                             Xmlattributes(Zl_Eprsplit(Rs.对象属性, ';', 8) As "OrigWidth",
                                                            Zl_Eprsplit(Rs.对象属性, ';', 9) As "OrigHeight",
                                                            Zl_Eprsplit(Rs.对象属性, ';', 6) As "ShowWidth",
                                                            Zl_Eprsplit(Rs.对象属性, ';', 7) As "ShowHeight",
                                                            Nvl(Zl_Eprsplit(Rs.对象属性, ';', 12), ' ') As "PicName",
                                                            Nvl(Zl_Eprsplit(Rs.对象属性, ';', 13), '0') As "AdviceID",
                                                            Nvl(Rs.是否换行, 0) As "NewLine", Rs.Id As "ID"), Rs.Id))
          Into Docxml
          From Dual;
        Else
          Select Appendchildxml(Docxml,
                                 '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                 Xmlelement("Picture",
                                             Xmlattributes(Zl_Eprsplit(Rs.对象属性, ';', 8) As "OrigWidth",
                                                            Zl_Eprsplit(Rs.对象属性, ';', 9) As "OrigHeight",
                                                            Zl_Eprsplit(Rs.对象属性, ';', 6) As "ShowWidth",
                                                            Zl_Eprsplit(Rs.对象属性, ';', 7) As "ShowHeight",
                                                            Nvl(Zl_Eprsplit(Rs.对象属性, ';', 12), ' ') As "PicName",
                                                            Nvl(Zl_Eprsplit(Rs.对象属性, ';', 13), '0') As "AdviceID",
                                                            Nvl(Rs.是否换行, 0) As "NewLine", Rs.Id As "ID"), Rs.Id))
          Into Docxml
          From Dual;
        End If;
        --制作标记子节点集
        v_Mark  := '';
        Makxml  := Null;
        Maksxml := Null;
        For Rs_Mark In (Select ID, 父id, 内容文本, 内容行次 From 电子病历内容 Where 父id = Rs.Id Order By 内容行次) Loop
          v_Marks := v_Mark || Rs_Mark.内容文本;
          v_Marks := Replace(v_Marks, '||', '^');
          For I In 1 .. 100 Loop
            v_Mark := Zl_Eprsplit(v_Marks, '^', I);
            If Zl_Eprsplit(v_Mark, '|', 15) Is Null Then
              --最后一个标记信息不全，存在下一行中
              Exit;
            Else
              Select Xmlelement("Mark",
                                 Xmlforest(Zl_Eprsplit(v_Mark, '|', 2) As "类型", Zl_Eprsplit(v_Mark, '|', 3) As "内容",
                                            Zl_Eprsplit(v_Mark, '|', 4) As "点集", Zl_Eprsplit(v_Mark, '|', 5) As "X1",
                                            Zl_Eprsplit(v_Mark, '|', 6) As "Y1", Zl_Eprsplit(v_Mark, '|', 7) As "X2",
                                            Zl_Eprsplit(v_Mark, '|', 8) As "Y2", Zl_Eprsplit(v_Mark, '|', 9) As "填充色",
                                            Zl_Eprsplit(v_Mark, '|', 10) As "填充方式",
                                            Zl_Eprsplit(v_Mark, '|', 11) As "线条色", Zl_Eprsplit(v_Mark, '|', 12) As "字体色",
                                            Zl_Eprsplit(v_Mark, '|', 13) As "线型", Zl_Eprsplit(v_Mark, '|', 14) As "线宽",
                                            Zl_Eprsplit(v_Mark, '|', 15) As "字体"))
              Into Makxml
              From Dual;
              Select Xmlconcat(Maksxml, Makxml) Into Maksxml From Dual;
            End If;
          End Loop;
        End Loop;
        --向Picture插入标记子节点
        Select Appendchildxml(Docxml,
                               '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Picture[@ID=' || Rs.Id || ']',
                               Maksxml)
        Into Docxml
        From Dual;
      Elsif Rs.对象类型 = 7 Then
        --诊断
        If Rs.父id Is Null Then
          Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                 Xmlelement("Diagnosise", Xmlattributes(Nvl(Rs.是否换行, 0) As "NewLine"), Rs.内容文本))
          Into Docxml
          From Dual;
        Else
          Select Appendchildxml(Docxml,
                                 '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                 Xmlelement("Diagnosise", Xmlattributes(Nvl(Rs.是否换行, 0) As "NewLine"), Rs.内容文本))
          Into Docxml
          From Dual;
        End If;
      Elsif Rs.对象类型 = 8 Then
        --签名
        If Rs.父id Is Null Then
          Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                 Xmlelement("Sign", Xmlattributes(Nvl(Rs.是否换行, 0) As "NewLine"),
                                             Zl_Eprsplit(Rs.内容文本, ';', 1)))
          Into Docxml
          From Dual;
        Else
          Select Appendchildxml(Docxml,
                                 '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                 Xmlelement("Sign", Xmlattributes(Nvl(Rs.是否换行, 0) As "NewLine"),
                                             Zl_Eprsplit(Rs.内容文本, ';', 1)))
          Into Docxml
          From Dual;
        End If;
      End If;
    End Loop;
      
    For Aa In (Select A1.Ftp目录 || '/' || To_Char(l.接收日期, 'yyyymmdd') || '/' || l.检查uid As v_Ftppath
               From 影像检查记录 L, 影像设备目录 A1
               Where l.位置一 = A1.设备号(+) And l.医嘱id = n_Adviceid) Loop
        
      Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/Compend[@ID=0]',
                             Xmlelement("FtpPath", Xmlattributes(v_Newline As "NewLine"), Aa.v_Ftppath))
      Into Docxml
      From Dual;
    End Loop;
    
  End Loop;
  
  Return Docxml;  
End Zlpub_Pacs_获取病历文本;
/

--102414:涂建华,2016-11-30,pacs依赖接口调整，支持多份报告
CREATE OR REPLACE Function Zlpub_Pacs_获取报告文本
(
  Ids_In In Varchar2,
  From_In Number
) Return Xmltype Is
--Ids_In规则是以 '|' 分隔的ID串，开始/结尾无 '|'
  --根所给定的病历文件ID串生成内容XML并返回XMLType
  Docxml XmlType;
  v_Sql Varchar2(1000);
Begin
    
  If From_In = 1 Then
    v_Sql := 'Select Zlpub_Pacs_获取文档文本(:1) From Dual';
    Execute Immediate v_Sql Into Docxml Using Ids_In;
  Else
    v_Sql := 'Select Zlpub_Pacs_获取病历文本(:1, :2) From Dual';
    Execute Immediate v_Sql Into Docxml Using Ids_In, From_In;
  End If;

  Return Docxml;
Exception
  When Others Then
    Return Null;
End Zlpub_Pacs_获取报告文本;
/

--102414:涂建华,2016-11-30,pacs依赖接口调整，支持多份报告
CREATE OR REPLACE Function Zlpub_Pacs_获取文档内容
( 
  报告ID_In In 影像报告记录.ID%Type, 
  报告提纲_In In 影像报告记录.诊断意见%Type 
) Return Varchar2 Is 
  x_Content        xmltype; 
  Xcdom            Xmldom.Domdocument; 
  Section_List     Xmldom.Domnodelist; 
  Section_Node     Xmldom.Domnode; 
  Node_List        Xmldom.Domnodelist; 
  n_Len            Number; 
  Element_Node     Xmldom.Domnode; 
  p_Node           Xmldom.Domnode; 
  Enum_Node        Xmldom.Domnode; 
  e_Node           Xmldom.Domnodelist; 
  c_Node           Xmldom.Domnode; 
  Enumeration_List Xmldom.Domnodelist; 
  Enumeration_Node Xmldom.Domnode; 
  Item_List        Xmldom.Domnodelist; 
  Item_Node        Xmldom.Domnode; 
  Item_Node1       Xmldom.Domnode; 
  v_Name           Varchar2(100); 
  v_Result         Varchar2(4000); 
  n_i              Number; 
  n_Num            Number; 
  n_j              Number; 
  n_Enum           Number; 
  v_Val            Varchar2(20); 
  v_Content        Varchar2(4000); 
  v_Eleid          Varchar2(50); 
  v_Multisel       Varchar2(10); 
Begin 
    v_Result := ''; 
    
    Select 报告内容 Into x_Content From 影像报告记录 Where id = 报告ID_In;

    Select Deletexml(x_Content, '//image') Into x_Content From Dual; 
 
    Xcdom := Xmldom.Newdomdocument(x_Content); 
 
    For Myrow In (Select Column_Value Name From Table(f_Str2list(报告提纲_In))) Loop 
      n_i := -1; 
      --循环提纲名称 
      Section_List := Xmldom.Getelementsbytagname(Xcdom, 'section'); 
      n_Len        := Xmldom.Getlength(Section_List); 
 
      For I In 0 .. n_Len - 1 Loop 
        If Xmldom.Getattribute(Xmldom.Makeelement(Xmldom.Item(Section_List, I)), 'title') = Myrow.Name Then 
          n_i := I; 
          Exit; 
        End If; 
      End Loop; 
 
      If n_i >= 0 Then 
        Section_Node := Xmldom.Item(Section_List, n_i); 
        Node_List    := Xmldom.Getelementsbytagname(Xmldom.Makeelement(Section_Node), '*'); 
        n_Len        := Xmldom.Getlength(Node_List); 
 
        For I In 0 .. n_Len - 1 Loop 
          Element_Node := Xmldom.Item(Node_List, I); 
          v_Name       := Xmldom.Getnodename(Element_Node); 
 
          If v_Name = 'element' Then 
            If Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'unit') Is Not Null Then 
              v_Content := Xmldom.Getnodevalue(Xmldom.Getfirstchild(Element_Node)); 
 
              If Instr(v_Content, 'textstyleno') > 0 Then 
                v_Content := ''; 
              End If; 
              --如果有单位 
              v_Result := v_Result || v_Content || Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'unit'); 
            Else 
              p_Node := Xmldom.Getparentnode(Element_Node); 
              If Xmldom.Getnodename(p_Node) <> 'enumvalues' Then 
                v_Result := v_Result || Xmldom.Getnodevalue(Xmldom.Getfirstchild(Element_Node)); 
              End If; 
            End If; 
          Elsif v_Name = 'utext' Then 
            v_Result := v_Result || LTrim(LTrim(Xmldom.Getnodevalue(Xmldom.Getfirstchild(Element_Node)), ':'), '：'); 
          Elsif v_Name = 'e_list' Or v_Name = 'e_enum' Or v_Name = 'e_etree' Or v_Name = 'e_utree' Then 
            Enumeration_List := Xmldom.Getelementsbytagname(Xmldom.Makeelement(Element_Node), 'enumeration'); 
            n_Num            := Xmldom.Getlength(Enumeration_List); 
 
            If v_Name = 'e_enum' And n_Num > 0 Then 
              For J In 0 .. n_Num - 1 Loop 
                Enumeration_Node := Xmldom.Item(Enumeration_List, J); 
                Item_List        := Xmldom.Getelementsbytagname(Xmldom.Makeelement(Element_Node), 'item'); 
                n_j              := Xmldom.Getlength(Item_List); 
 
                For K In 0 .. n_j - 1 Loop 
                  Item_Node := Xmldom.Item(Item_List, K); 
                  If Xmldom.Getattribute(Xmldom.Makeelement(Item_Node), 'checked') = '1' Then 
                    v_Val := Xmldom.Getattribute(Xmldom.Makeelement(Item_Node), 'val'); 
 
                    For Z In 0 .. n_j - 1 Loop 
                      Item_Node1 := Xmldom.Item(Item_List, Z); 
                      If Xmldom.Getattribute(Xmldom.Makeelement(Item_Node1), 'val') = v_Val And 
                         Xmldom.Getattribute(Xmldom.Makeelement(Item_Node1), 'issymbol') = '0' Then 
                        v_Result := v_Result || Xmldom.Getnodevalue(Xmldom.Getfirstchild(Item_Node1)); 
                        Exit; 
                      End If; 
                    End Loop; 
                  End If; 
                End Loop; 
              End Loop; 
            Else 
              --这里处理枚举有无的情况 
              v_Eleid := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'sid'); --获取元素ID 
 
              Select Extractvalue(b.值域描述, '/root/multisel') 
              Into v_Multisel 
              From 影像报告元素清单 A, 影像报告值域清单 B 
              Where a.值域id = b.id And a.id = Hextoraw(v_Eleid); 
 
              If v_Multisel = 2 And v_Name = 'e_enum' Then 
                --为是否类型的枚举 
                v_Result := v_Result || Xmldom.Getnodevalue(Xmldom.getLastChild(Element_Node)); 
              Else 
                Enum_Node := Xmldom.Item(Xmldom.Getelementsbytagname(Xmldom.Makeelement(Element_Node), 'enumvalues'), 0); 
                e_Node := Xmldom.Getelementsbytagname(Xmldom.Makeelement(Enum_Node), 'element'); 
                n_Enum := Xmldom.Getlength(e_Node); 
 
                For K In 0 .. n_Enum - 1 Loop 
                  c_Node   := Xmldom.Item(e_Node, K); 
                  v_Result := v_Result || Xmldom.Getattribute(Xmldom.Makeelement(c_Node), 'showtext'); 
 
                  If K <> n_Enum - 1 Then 
                    v_Result := v_Result || '、'; 
                  End If; 
                End Loop; 
              End If; 
            End If; 
          End If; 
        End Loop; 
      End If; 
    End Loop; 
 
    Xmldom.Freedocument(Xcdom); 
 
    Return translate(v_Result,chr(13)||chr(10),','); 
Exception 
  When Others Then 
    zl_ErrorCenter(SQLCode, SQLErrM); 
End Zlpub_Pacs_获取文档内容; 
/

--102414:涂建华,2016-12-09,pacs依赖接口调整，支持多份报告
CREATE OR REPLACE Function Zlpub_Pacs_获取病历内容
(
  报告ID_In   In Number,
  报告来源_In In Number,
  报告提纲_In In Varchar2
) Return Varchar2 Is
  Type t_Str_Table Is Table Of Varchar2(4000);
  a_Return t_Str_Table := t_Str_Table();

  v_Return        Varchar2(4000);
  v_Temp          Varchar2(4000);
  n_Count         Number(2);
  n_病历ID        Number(18);

  v_Sql           Varchar2(1000);
Begin
  n_病历ID := 报告id_In;
  v_Return       := '';

  If 报告来源_In = 2 Then
     v_Sql := 'Select 病历ID From 病人医嘱报告 Where RISID=:1';
     Execute Immediate v_Sql Into n_病历ID Using 报告id_In;
  End If;

  Begin
    Select Decode(是否换行, 1, 内容文本 || Chr(10) || Chr(13), 内容文本) Bulk Collect
    Into a_Return
    From 电子病历内容
    Where 终止版 = 0  And 对象类型 In(2,4) And 文件id = n_病历ID 
    Start With  父id = (Select ID From 电子病历内容 Where 文件id = n_病历ID And 内容文本 = 报告提纲_In And 对象类型 = 1)
    Connect By Prior ID=父ID
    Order By 对象序号;

    For n_Count In 1 .. a_Return.Count Loop
      If v_Return Is Null Then
        If n_Count = 1 Then
          v_Temp := a_Return(n_Count);
          If Instr(v_Temp,报告提纲_In) <> 1 Then
            v_Return := v_Temp;
          End If; 
        Else
          v_Return := a_Return(n_Count);
        End If;
        
      Else
        v_Return := v_Return || a_Return(n_Count);
      End If;
    End Loop;

  Exception
    When Others Then
      v_Return := Null;
  End;

  Begin
    If v_Return Is Null Then
      Select Decode(是否换行, 1, 内容文本 || Chr(10) || Chr(13), 内容文本) Bulk Collect
      Into a_Return
      From 电子病历内容
      Where 终止版 = 0  And 对象类型 In(2,4) And 文件id = n_病历ID
      Start With  父id = (Select ID From 电子病历内容 Where 文件id = n_病历ID And 内容文本 = 报告提纲_In And 对象类型 = 3)
      Connect By Prior ID=父ID
      Order By 对象序号;

      For n_Count In 1 .. a_Return.Count Loop
        If v_Return Is Null Then
          v_Return := a_Return(n_Count);
        Else
          v_Return := v_Return || a_Return(n_Count);
        End If;
      End Loop;

    End If;
  Exception
    When Others Then
      v_Return := Null;
  End;

  If v_Return Is Null Then
    Select Decode(是否换行, 1, 内容文本 || Chr(10) || Chr(13), 内容文本) Bulk Collect
    Into a_Return
    From 电子病历内容
    Where 终止版 = 0  And Substr(对象属性,1,1) = '0' And 文件id = n_病历ID
    Start With  父id = (Select ID From 电子病历内容 Where 文件id = n_病历ID And 内容文本 = 报告提纲_In And 对象类型 = 1)
    Connect By Prior ID=父ID
    Order By 对象序号;

    For n_Count In 1 .. a_Return.Count Loop
        If v_Return Is Null Then
          If n_Count = 1 Then
            v_Temp := a_Return(n_Count);
            If Instr(v_Temp,报告提纲_In) <> 1 Then
              v_Return := v_Temp;
            End If; 
          Else
            v_Return := a_Return(n_Count);
          End If;
          
        Else
          v_Return := v_Return || a_Return(n_Count);
        End If;
    End Loop;
  End If;

  Return v_Return;
End Zlpub_Pacs_获取病历内容;
/


--102414:涂建华,2016-11-30,pacs依赖接口调整，支持多份报告
Create Or Replace Function Zlpub_Pacs_获取提纲内容
(
  报告id_In   In Varchar2,
  报告来源_In In Number,
  报告提纲_In In Varchar2
) Return Varchar2 Is

  v_Result        Varchar2(4000);
  v_Singleresult  Varchar2(4000);
  v_Sql           Varchar2(1000);
  
Begin
  v_Result       := '';
  v_Singleresult := '';

  If 报告来源_In = 1 Then
    v_Sql := 'Select Zlpub_Pacs_获取文档内容(:1, :2) From Dual';
    Execute Immediate v_Sql Into v_Singleresult Using 报告id_In,报告提纲_In;
  Else
    v_Sql := 'Select Zlpub_Pacs_获取病历内容(:1, :2, :3) From Dual';
    Execute Immediate v_Sql Into v_Singleresult Using 报告id_In,报告来源_In, 报告提纲_In;
  End If;
  
  If v_Result Is Null And Not v_Singleresult Is Null Then
    v_Result := v_Singleresult;
  Elsif Not v_Singleresult Is Null Then
    v_Result := v_Result || ';' || v_Singleresult;
  End If;
    
  Return v_Result;
      
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zlpub_Pacs_获取提纲内容;
/

--103000:李南春,2017-02-08,保存病人手机号信息
--102812:余伟节,2016-11-29,病人信息允许修改监护人
Create Or Replace Procedure Zl_病人信息_Update
(
  病人id_In         病人信息.病人id%Type,
  门诊号_In         病人信息.门诊号%Type,
  住院号_In         病人信息.住院号%Type,
  费别_In           病人信息.费别%Type,
  医疗付款_In       病人信息.医疗付款方式%Type,
  姓名_In           病人信息.姓名%Type,
  性别_In           病人信息.性别%Type,
  年龄_In           病人信息.年龄%Type,
  出生日期_In       病人信息.出生日期%Type,
  出生地点_In       病人信息.出生地点%Type,
  身份证号_In       病人信息.身份证号%Type,
  身份_In           病人信息.身份%Type,
  职业_In           病人信息.职业%Type,
  民族_In           病人信息.民族%Type,
  国籍_In           病人信息.国籍%Type,
  学历_In           病人信息.学历%Type,
  婚姻_In           病人信息.婚姻状况%Type,
  家庭地址_In       病人信息.家庭地址%Type,
  家庭电话_In       病人信息.家庭电话%Type,
  家庭地址邮编_In   病人信息.家庭地址邮编%Type,
  联系人姓名_In     病人信息.联系人姓名%Type,
  联系人关系_In     病人信息.联系人关系%Type,
  联系人地址_In     病人信息.联系人地址%Type,
  联系人电话_In     病人信息.联系人电话%Type,
  合同单位id_In     病人信息.合同单位id%Type,
  工作单位_In       病人信息.工作单位%Type,
  单位电话_In       病人信息.单位电话%Type,
  单位邮编_In       病人信息.单位邮编%Type,
  单位开户行_In     病人信息.单位开户行%Type,
  单位帐号_In       病人信息.单位帐号%Type,
  担保人_In         病人信息.担保人%Type,
  担保额_In         病人信息.担保额%Type,
  险类_In           病人信息.险类%Type,
  住院费别_In       Number := 0, --是否修改的是病人的住院费别
  医保号_In         保险帐户.医保号%Type := Null,
  区域_In           病人信息.区域%Type := Null,
  担保性质_In       病人信息.担保性质%Type := Null,
  操作员编号_In     病人担保记录.操作员编号%Type := Null,
  操作员姓名_In     病人担保记录.操作员姓名%Type := Null,
  其他证件_In       病人信息.其他证件%Type := Null,
  病人类型_In       病案主页.病人类型%Type := Null,
  备注_In           病案主页.备注%Type := Null,
  籍贯_In           病人信息.籍贯%Type := Null,
  户口地址_In       病人信息.户口地址%Type := Null,
  户口地址邮编_In   病人信息.户口地址邮编%Type := Null,
  联系人身份证号_In In 病人信息.联系人身份证号%Type := Null,
  模块号_In         Number := 0, --修改病人姓名、性别、年龄、出生日期的模块
  监护人_In         病人信息.监护人%Type :=Null,
  手机号_In         病人信息.手机号%Type :=Null
) As
  v_主页id   病案主页.主页id%Type;
  v_出院日期 病案主页.出院日期%Type;
  v_模块号   Varchar2(1000); --要修改病人姓名的模块号组合,格式为:,模块号,模块号,....

Begin
  v_模块号 := ',1111,1107,1103,';
  Begin
    Select Max(主页id) Into v_主页id From 病案主页 Where 病人id = 病人id_In;
  Exception
    When Others Then
      Null;
  End;
  If 门诊号_In Is Not Null Then
    Update 门诊病案记录 Set 病案号 = 门诊号_In Where 病人id = 病人id_In;
    If Sql%Rowcount = 0 Then
      Insert Into 门诊病案记录
        (病人id, 病案号, 建立日期, 病案类别, 存储状态, 存放位置)
      Values
        (病人id_In, 门诊号_In, Sysdate, '一般', '正常', Null);
    End If;
  Else
    Delete From 门诊病案记录 Where 病人id = 病人id_In;
  End If;

  If Instr(v_模块号, ',' || 模块号_In || ',',1) = 0 Then
    Update 病人信息
    Set 门诊号 = 门诊号_In, 住院号 = 住院号_In, 医疗付款方式 = 医疗付款_In, 费别 = Decode(Nvl(住院费别_In, 0), 0, 费别_In, 费别), 出生地点 = 出生地点_In,
        身份证号 = 身份证号_In, 身份 = 身份_In, 职业 = 职业_In, 民族 = 民族_In, 国籍 = 国籍_In, 籍贯 = Nvl(籍贯_In,籍贯), 区域 = 区域_In, 学历 = 学历_In, 婚姻状况 = 婚姻_In,
        家庭地址 = 家庭地址_In, 家庭电话 = 家庭电话_In, 家庭地址邮编 = 家庭地址邮编_In, 户口地址 = Nvl(户口地址_In,户口地址), 户口地址邮编 = Nvl(户口地址邮编_In,户口地址邮编), 联系人姓名 = 联系人姓名_In,
        联系人关系 = 联系人关系_In, 联系人地址 = 联系人地址_In, 联系人电话 = 联系人电话_In, 合同单位id = Decode(合同单位id_In, 0, Null, 合同单位id_In),
        工作单位 = 工作单位_In, 单位电话 = 单位电话_In, 单位邮编 = 单位邮编_In, 单位开户行 = 单位开户行_In, 单位帐号 = 单位帐号_In, 担保人 = 担保人_In,
        担保额 = Decode(担保额_In, 0, Null, 担保额_In), 担保性质 = 担保性质_In, 险类 = 险类_In, 医保号 = 医保号_In, 其他证件 = 其他证件_In,
        联系人身份证号 = 联系人身份证号_In, 病人类型 = 病人类型_In, 监护人 = 监护人_In, 手机号 = Nvl(手机号_In,手机号)
    Where 病人id = 病人id_In;
  Else
    Update 病人信息
    Set 门诊号 = 门诊号_In, 住院号 = 住院号_In, 医疗付款方式 = 医疗付款_In, 费别 = Decode(Nvl(住院费别_In, 0), 0, 费别_In, 费别), 姓名 = 姓名_In, 性别 = 性别_In,
        年龄 = 年龄_In, 出生日期 = 出生日期_In, 出生地点 = 出生地点_In, 身份证号 = 身份证号_In, 身份 = 身份_In, 职业 = 职业_In, 民族 = 民族_In, 国籍 = 国籍_In,
        籍贯 = Nvl(籍贯_In,籍贯), 区域 = 区域_In, 学历 = 学历_In, 婚姻状况 = 婚姻_In, 家庭地址 = 家庭地址_In, 家庭电话 = 家庭电话_In, 家庭地址邮编 = 家庭地址邮编_In,
        户口地址 = Nvl(户口地址_In,户口地址), 户口地址邮编 = Nvl(户口地址邮编_In,户口地址邮编), 联系人姓名 = 联系人姓名_In, 联系人关系 = 联系人关系_In, 联系人地址 = 联系人地址_In, 联系人电话 = 联系人电话_In,
        合同单位id = Decode(合同单位id_In, 0, Null, 合同单位id_In), 工作单位 = 工作单位_In, 单位电话 = 单位电话_In, 单位邮编 = 单位邮编_In, 单位开户行 = 单位开户行_In,
        单位帐号 = 单位帐号_In, 担保人 = 担保人_In, 担保额 = Decode(担保额_In, 0, Null, 担保额_In), 担保性质 = 担保性质_In, 险类 = 险类_In, 医保号 = 医保号_In,
        其他证件 = 其他证件_In, 联系人身份证号 = 联系人身份证号_In, 病人类型 = 病人类型_In, 监护人 = 监护人_In, 手机号 = Nvl(手机号_In,手机号)
    Where 病人id = 病人id_In;
  End If;

  If v_主页id Is Not Null Then
    Update 病案主页
    Set 住院号 = 住院号_In, 费别 = Decode(Nvl(住院费别_In, 0), 1, 费别_In, 费别), 医疗付款方式 = 医疗付款_In,
        区域 = Decode(区域_In, Null, 区域, 区域_In), 备注 = 备注_In
    Where 病人id = 病人id_In And 主页id = v_主页id;
  
    --对在院病人更新病案主页中的信息
    Begin
      Select 出院日期 Into v_出院日期 From 病案主页 Where 病人id = 病人id_In And 主页id = v_主页id;
    Exception
      When Others Then
        Null;
    End;
    If v_出院日期 Is Null Then
      Update 病案主页
      Set 婚姻状况 = 婚姻_In, 学历 = 学历_In, 职业 = 职业_In, 单位电话 = 单位电话_In, 单位邮编 = 单位邮编_In, 家庭地址 = 家庭地址_In, 家庭电话 = 家庭电话_In,
          家庭地址邮编 = 家庭地址邮编_In, 户口地址 = Nvl(户口地址_In,户口地址), 户口地址邮编 = Nvl(户口地址邮编_In,户口地址邮编), 联系人姓名 = 联系人姓名_In, 联系人关系 = 联系人关系_In, 联系人地址 = 联系人地址_In,
          联系人电话 = 联系人电话_In, 病人类型 = 病人类型_In, 备注 = 备注_In
      Where 病人id = 病人id_In And 主页id = v_主页id;
    End If;
  
    If 医保号_In Is Not Null Then
      Update 病案主页从表 Set 信息值 = 医保号_In Where 病人id = 病人id_In And 主页id = v_主页id And 信息名 = '医保号';
      If Sql%Rowcount = 0 Then
        Insert Into 病案主页从表 (病人id, 主页id, 信息名, 信息值) Values (病人id_In, v_主页id, '医保号', 医保号_In);
      End If;
    Else
      Delete From 病案主页从表 Where 病人id = 病人id_In And 主页id = v_主页id And 信息名 = '医保号';
    End If;
  End If;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人信息_Update;
/

--103000:李南春,2017-02-08,保存病人手机号信息
--102812:余伟节,2016-11-29,病人信息管理允许修改监护人
Create Or Replace Procedure Zl_病人信息_Insert
(
  病人id_In     病人信息.病人id%Type,
  门诊号_In     病人信息.门诊号%Type,
  费别_In       病人信息.费别%Type,
  医疗付款_In   病人信息.医疗付款方式%Type,
  姓名_In       病人信息.姓名%Type,
  性别_In       病人信息.性别%Type,
  年龄_In       病人信息.年龄%Type,
  出生日期_In   病人信息.出生日期%Type,
  出生地点_In   病人信息.出生地点%Type,
  身份证号_In   病人信息.身份证号%Type,
  身份_In       病人信息.身份%Type,
  职业_In       病人信息.职业%Type,
  民族_In       病人信息.民族%Type,
  国籍_In       病人信息.国籍%Type,
  学历_In       病人信息.学历%Type,
  婚姻_In       病人信息.婚姻状况%Type,
  家庭地址_In   病人信息.家庭地址%Type,
  家庭电话_In   病人信息.家庭电话%Type,
  家庭地址邮编_In   病人信息.家庭地址邮编%Type,
  联系人姓名_In 病人信息.联系人姓名%Type,
  联系人关系_In 病人信息.联系人关系%Type,
  联系人地址_In 病人信息.联系人地址%Type,
  联系人电话_In 病人信息.联系人电话%Type,
  合同单位id_In 病人信息.合同单位id%Type,
  工作单位_In   病人信息.工作单位%Type,
  单位电话_In   病人信息.单位电话%Type,
  单位邮编_In   病人信息.单位邮编%Type,
  单位开户行_In 病人信息.单位开户行%Type,
  单位帐号_In   病人信息.单位帐号%Type,
  担保人_In     病人信息.担保人%Type,
  担保额_In     病人信息.担保额%Type,
  险类_In       病人信息.险类%Type,
  登记时间_In   病人信息.登记时间%Type,
  区域_In       病人信息.区域%Type := Null,
  担保性质_In   病人信息.担保性质%Type := Null,
  操作员编号_In 病人担保记录.操作员编号%Type := Null,
  操作员姓名_In 病人担保记录.操作员姓名%Type := Null,
  医保号_In     病人信息.医保号%Type := Null,
  其他证件_In   病人信息.其他证件%Type := Null,
  籍贯_In       病人信息.籍贯%Type := Null,
  户口地址_In   病人信息.户口地址%Type := Null,
  户口地址邮编_In   病人信息.户口地址邮编%Type := Null,
  联系人身份证号_In  病人信息.联系人身份证号%Type :=Null,
  病人类型_In       病人信息.病人类型%Type := Null,
  监护人_In     病人信息.监护人%Type := Null,
  手机号_In     病人信息.手机号%Type := Null
) As
  v_费别 病人信息.费别%Type;
Begin
  If 费别_In Is Null Then
    Select Max(名称) Into v_费别 From 费别 Where 缺省标志 = 1; --不管适用科室和服务对象
  Else
    v_费别 := 费别_In;
  End If;
  Insert Into 病人信息
    (病人id, 门诊号, 费别, 医疗付款方式, 姓名, 性别, 年龄, 出生日期, 出生地点, 身份证号, 身份, 职业, 民族, 国籍, 区域, 籍贯,
     学历, 婚姻状况, 家庭地址, 家庭电话, 家庭地址邮编, 户口地址, 户口地址邮编, 联系人姓名, 联系人关系, 联系人地址, 联系人电话, 合同单位id, 工作单位,
     单位电话, 单位邮编, 单位开户行, 单位帐号, 担保人, 担保额, 担保性质, 险类, 登记时间, 医保号, 其他证件,联系人身份证号,病人类型,监护人,手机号)
  Values
    (病人id_In, 门诊号_In, v_费别, 医疗付款_In, 姓名_In, 性别_In, 年龄_In, 出生日期_In, 出生地点_In, 身份证号_In,
     身份_In, 职业_In, 民族_In, 国籍_In, 区域_In, 籍贯_In, 学历_In, 婚姻_In, 家庭地址_In, 家庭电话_In, 家庭地址邮编_In, 户口地址_In, 户口地址邮编_In,
     联系人姓名_In, 联系人关系_In, 联系人地址_In, 联系人电话_In, Decode(合同单位id_In, 0, Null, 合同单位id_In), 工作单位_In,
     单位电话_In, 单位邮编_In, 单位开户行_In, 单位帐号_In, 担保人_In, Decode(担保额_In, 0, Null, 担保额_In), 担保性质_In,
     险类_In, 登记时间_In, 医保号_In, 其他证件_In,联系人身份证号_In,病人类型_In,监护人_In,手机号_In);

  If 门诊号_In Is Not Null Then
    Insert Into 门诊病案记录
      (病人id, 病案号, 建立日期, 病案类别, 存储状态, 存放位置)
    Values
      (病人id_In, 门诊号_In, 登记时间_In, '一般', '正常', Null);
  End If;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人信息_Insert;
/

--106288:张德婷,2017-02-22,修正自动排批对已摆药数据的影响
--102386:张德婷,2017-02-21,自动排批或继承批次时取消该病人当天输液单的确认调整标志
--104668:张德婷,2017-01-25,静配中心自动排批与保持上一天批次整合
--103002:张德婷,2017-01-03,抗生素等特殊药品类型根据执行时间确认批次
--101938:张德婷,2016-12-09,修正静配中心跨批次数据问题的错误
--106606:李业庆,2017-03-03,药品收发记录的金额按流通参数取舍
Create Or Replace Procedure Zl_输液配药记录_核查
(
  部门id_In   In 输液配药记录.部门id%Type,
  医嘱id_In   In Varchar2, --输液医嘱给药途径对应的医嘱ID:医嘱ID1,医嘱ID2...
  发送号_In   In 病人医嘱发送.发送号%Type,
  核查人_In   In 输液配药状态.操作人员%Type,
  核查时间_In In 输液配药状态.操作时间%Type
) Is
  v_Count    Number;
  v_序号     Number;
  v_执行时间 Date;

  v_相关id      Number;
  v_New相关id   Number;
  v_Old相关id   Number;
  v_发送号      Number;
  v_Tmp         Varchar2(200);
  I             Number;
  v_配药id      Number;
  v_批次        Number;
  v_Maxno       Varchar2(4000);
  v_Lableno     Varchar2(200);
  v_Maxbatch    Number;
  v_Curdose     Number;
  v_Sumdose     Number;
  v_Drugcount   Number;
  v_Currdate    Date;
  n_Needcheck   Number;
  n_Lngid       药品收发记录.Id%Type;
  n_Count       Number(3);
  n_单据        药品收发记录.单据%Type;
  v_No          药品收发记录.No%Type;
  n_发送次数    Number(5);
  n_病人id      病人信息.病人id%Type := 0;
  b_Change      Boolean := True;
  n_Sum         Number(8);
  n_调整批次    Number(1);
  n_Cur         Number(5);
  v_上次发送号  病人医嘱发送.发送号%Type;
  v_医嘱ids     Varchar2(4000);
  v_Tansid      Varchar2(12);
  v_当前病人    Varchar2(20);
  n_Num         Number(8);
  d_Old执行时间 Date;
  n_是否打包    Number(1);
  n_打包        Number(1);
  n_摆药单      Number(2);
  --控制参数
  v_医嘱类型       Number;
  v_输液总量       Number;
  v_大输液剂型     Varchar2(2000);
  v_大输液给药途径 Varchar2(2000);
  v_来源科室       Varchar2(4000);
  v_Continue       Number := 1;
  v_Nodosage       Number := 0;
  v_保持上次批次   Number := 0;
  d_手工打包时间   Date;
  n_Tpn处置方式    Number := 0;
  v_药品类型       Varchar2(20);
  n_打包药品批次   Number(1);
  n_特殊药品批次   Number(1);
  n_优先级         Number := 999;
  n_自动排批       Number := 0;
  n_科室id         Number := 0;
  n_Row            Number(2);
  n_备用批次       Number := 0;
  n_剩余数量       Number := 0;
  n_单次数量       Number := 0;
  n_累计数量       Number := 0;
  n_医嘱id         Number := 0;
  n_填写数量       Number := 0;
  v_配药类型       Varchar2(20);
  v_时间串         Varchar2(100);
  v_时间值         Date;
  v_Fields         Varchar2(100);
  v_是否改变       Varchar2(20);
  v_时间串1        Varchar2(100);
  Err_Item Exception;
  n_流通金额小数 Number;

  Cursor c_医嘱记录 Is
    Select /*+rule */
    Distinct e.医嘱id As 相关id, e.发送号, b.频率间隔, b.间隔单位, b.执行时间方案, a.姓名, a.性别, a.年龄, a.住院号, a.当前床号 As 床号, a.当前病区id As 病人病区id,
             a.当前科室id As 病人科室id, e.首次时间, e.末次时间, b.开始执行时间, Nvl(e.发送数次, 0) As 次数, e.发送时间, Decode(b.医嘱期效, 0, 1, 2) As 医嘱类型,
             b.诊疗项目id As 给药途径, b.病人id, Nvl(c.执行标记, 0) As 是否tpn
    From 病人医嘱发送 E, 病人医嘱记录 B, 病人信息 A, 诊疗项目目录 C, Table(f_Num2list(医嘱id_In)) D
    Where e.医嘱id = b.Id And b.病人id = a.病人id And c.类别 = 'E' And c.操作类型 = '2' And c.执行分类 = 1 And b.诊疗项目id = c.Id And
          e.医嘱id = d.Column_Value And e.发送号 = 发送号_In
    Order By b.病人id, e.医嘱id, e.发送号;

  Cursor c_单个医嘱记录 Is
    Select /*+rule */
    Distinct e.医嘱id, e.发送号, b.频率间隔, b.间隔单位, b.执行时间方案, a.姓名, a.性别, a.年龄, a.住院号, a.当前床号 As 床号, a.当前病区id As 病人病区id,
             a.当前科室id As 病人科室id, e.首次时间, e.末次时间, b.开始执行时间, Nvl(e.发送数次, 0) As 次数, e.发送时间, Decode(b.医嘱期效, 0, 1, 2) As 医嘱类型,
             b.诊疗项目id As 给药途径, b.病人id
    From 病人医嘱发送 E, 病人医嘱记录 B, 病人信息 A, 诊疗项目目录 C
    Where e.医嘱id = b.Id And b.病人id = a.病人id And b.诊疗项目id = c.Id And b.相关id = v_相关id And e.发送号 = 发送号_In
    Order By e.医嘱id, e.发送号;

  Cursor c_收发记录 Is
    Select Distinct c.Id As 收发id, c.序号, c.实际数量 As 数量, Nvl(e.是否不予配置, 0) As 是否不予配置, c.单据, c.No
    From 病人医嘱记录 A, 病人医嘱发送 B, 药品收发记录 C, 住院费用记录 D, 输液药品属性 E
    Where a.Id = b.医嘱id And c.费用id = d.Id And a.Id = d.医嘱序号 And b.No = c.No And c.药品id = e.药品id(+) And
          b.执行部门id + 0 = 部门id_In And c.单据 = 9 And c.审核日期 Is Null And a.Id = n_医嘱id And b.发送号 = 发送号_In And c.序号 < 1000
    Order By c.No, c.序号;

  Cursor c_原始收发记录 Is
    Select Distinct c.Id As 收发id, c.序号, c.实际数量 As 数量, Nvl(e.是否不予配置, 0) As 是否不予配置, c.单据, c.No
    From 病人医嘱记录 A, 病人医嘱发送 B, 药品收发记录 C, 住院费用记录 D, 输液药品属性 E
    Where a.Id = b.医嘱id And c.费用id = d.Id And a.Id = d.医嘱序号 And b.No = c.No And c.药品id = e.药品id(+) And
          b.执行部门id + 0 = 部门id_In And c.单据 = 9 And c.审核日期 Is Null And a.相关id = v_相关id And b.发送号 = 发送号_In And c.序号 < 1000
    Order By c.No, c.序号;

  Cursor c_输液单记录 Is
    Select a.Id, a.执行时间, a.配药批次, a.医嘱id, d.发送时间
    From 输液配药记录 A, 病人医嘱记录 B, 配药工作批次 C, 病人医嘱发送 D
    Where a.医嘱id = b.Id And a.配药批次 = c.批次 And d.医嘱id = a.医嘱id And a.发送号 = d.发送号 And c.批次 <> 0 And c.药品类型 Is Null And
          b.病人id = n_病人id And a.操作状态 < 2 And a.执行时间 Between Trunc(v_时间值) And Trunc(v_时间值 + 1) - 1 / 24 / 60 / 60;

  v_输液单记录   c_输液单记录%RowType;
  v_医嘱记录     c_医嘱记录%RowType;
  v_收发记录     c_收发记录%RowType;
  v_单个医嘱记录 c_单个医嘱记录%RowType;

  Function Zl_Getpivaworkbatch
  (
    执行时间_In In Date,
    发送时间_In In Date,
    药品类型_In In Varchar2 := Null
  ) Return Number As
  
    v_Exetime   Date;
    v_Starttime Date;
    v_Endtime   Date;
    v_Maxbatch  Number(2);
    v_Batch     Number;
    Cursor c_配药批次 Is
      Select 批次, 配药时间, 给药时间, 打包, 药品类型
      From 配药工作批次
      Where 启用 = 1 And 配置中心id = 部门id_In
      Order By 药品类型, 批次;
  
    v_配药批次 c_配药批次%RowType;
  Begin
    v_Exetime := To_Date(Substr(To_Char(执行时间_In, 'yyyy-mm-dd hh24:mi'), 12), 'hh24:mi');
  
    Select Max(Nvl(批次, 0)) + 1 Into v_Maxbatch From 配药工作批次 Where 启用 = 1 And 配置中心id = 部门id_In;
  
    For v_配药批次 In c_配药批次 Loop
      v_Batch := 0;
    
      --当天发送的医嘱发送到备用批次
      If (Trunc(执行时间_In) >= Trunc(v_Currdate) And Trunc(发送时间_In) < Trunc(执行时间_In)) Or n_备用批次 = 0 Then
        If v_配药批次.批次 <> '0' And
           ((Nvl(v_配药批次.药品类型, '0') <> '0' And v_配药批次.药品类型 = 药品类型_In) Or Nvl(v_配药批次.药品类型, '0') = '0') Then
          v_Starttime := To_Date(Substr(v_配药批次.给药时间, 1, Instr(v_配药批次.给药时间, '-') - 1), 'hh24:mi');
          v_Endtime   := To_Date(Substr(v_配药批次.给药时间, Instr(v_配药批次.给药时间, '-') + 1), 'hh24:mi');
        
          If v_Exetime >= v_Starttime And v_Exetime <= v_Endtime Then
            v_Batch := v_配药批次.批次;
            n_打包  := v_配药批次.打包;
            Exit When v_Batch > 0;
          End If;
        End If;
      End If;
    End Loop;
  
    If v_Batch = 0 And (n_打包药品批次 <> 1 Or n_备用批次 = 1) Then
      v_Batch := v_Maxbatch;
    End If;
    Return(v_Batch);
  End;

  Function Zl_Getfirst
  (
    配药id_In In Number,
    科室id_In In Number
  ) Return Number As
    n_First  Number;
    n_科室id Number;
    Cursor c_优先级 Is
      Select 科室id, 配药类型, 优先级, 频次
      From 输液药品优先级
      Where (科室id = 科室id_In Or 科室id = 0)
      Order By 科室id, 优先级 Desc;
  
    r_优先级 c_优先级%RowType;
  Begin
    n_First := 0;
    For r_优先级 In c_优先级 Loop
      If n_科室id <> 0 And r_优先级.科室id = 0 Then
        Exit;
      End If;
      n_科室id := r_优先级.科室id;
    
      For r_配药记录 In (Select Distinct d.配药类型, e.执行频次
                     From 输液配药记录 A, 输液配药内容 B, 药品收发记录 C, 输液药品属性 D, 病人医嘱记录 E
                     Where a.医嘱id = e.Id And a.Id = b.记录id And b.收发id = c.Id And c.药品id = d.药品id And a.Id = 配药id_In) Loop
        If Instr(r_配药记录.配药类型, r_优先级.配药类型, 1) > 0 And (Instr(r_优先级.频次, r_配药记录.执行频次, 1) > 0 Or r_优先级.频次 = '所有频次') Then
          n_First := r_优先级.优先级;
          Exit;
        End If;
      End Loop;
    End Loop;
  
    If n_First = 0 Then
      n_First := 999;
    End If;
    Return(n_First);
  End;
Begin
  n_Count          := 0;
  v_医嘱类型       := Zl_To_Number(Nvl(zl_GetSysParameter('医嘱类型', 1345), 1));
  v_输液总量       := Zl_To_Number(Nvl(zl_GetSysParameter('同批次输液总量', 1345), 0));
  v_大输液剂型     := Nvl(zl_GetSysParameter('大输液药品剂型', 1345), '');
  v_大输液给药途径 := Nvl(zl_GetSysParameter('输液给药途径', 1345), '');
  v_来源科室       := Nvl(zl_GetSysParameter('来源科室', 1345), '');
  v_保持上次批次   := Zl_To_Number(Nvl(zl_GetSysParameter('保持上次批次', 1345), 0));
  n_Tpn处置方式    := Zl_To_Number(Nvl(zl_GetSysParameter('静脉营养药物处置方式', 1345), 0));
  n_打包药品批次   := Zl_To_Number(Nvl(zl_GetSysParameter('单个药品，不予配置药品及根据给药时间没有配药批次的输液单默认为0批次并打包', 1345), 0));
  n_特殊药品批次   := Zl_To_Number(Nvl(zl_GetSysParameter('特殊药品按药品类型指定批次', 1345), 0));
  n_自动排批       := Zl_To_Number(Nvl(zl_GetSysParameter('启动自动排批', 1345), 0));
  n_备用批次       := Zl_To_Number(Nvl(zl_GetSysParameter('当天发送的医嘱产生的输液单全部到备用批次', 1345), 0));
  v_医嘱ids        := 医嘱id_In;
  v_当前病人       := '';
  n_发送次数       := 0;

  --取流通业务精度位数
  --类别:1-药品 2-卫材
  --内容：2-零售价 4-金额
  --单位：药品:1-售价 5-金额单位
  Select 精度 Into n_流通金额小数 From 药品卫材精度 Where 类别 = 1 And 内容 = 4 And 单位 = 5;

  Select Trunc(Sysdate) Into v_Currdate From Dual;

  Select Max(Nvl(批次, 0)) + 1 Into v_Maxbatch From 配药工作批次;

  --检查当前病人的医嘱是否有今天需要执行的输液单是锁定状态的
  If Instr(v_医嘱ids, ',') = 0 Then
    v_Tansid := v_医嘱ids;
  Else
    v_Tansid := Substr(v_Tmp, 1, Instr(v_医嘱ids, ',') - 1);
  End If;

  Select Count(ID)
  Into n_Num
  From 输液配药记录
  Where 是否锁定 = 1 And 执行时间 Between Trunc(v_Currdate) And Trunc(v_Currdate + 1) - 1 / 24 / 60 / 60 And
        医嘱id In
        (Select 相关id
         From 病人医嘱记录
         Where 病人id = (Select 病人id From 病人医嘱记录 Where 相关id = v_Tansid And Rownum < 2) And (诊疗类别 = '5' Or 诊疗类别 = '6')) And
        Rownum < 2;

  If n_Num > 0 Then
    Select 姓名
    Into v_当前病人
    From 输液配药记录
    Where 是否锁定 = 1 And 执行时间 Between Trunc(v_Currdate) And Trunc(v_Currdate + 1) - 1 / 24 / 60 / 60 And
          医嘱id In
          (Select 相关id
           From 病人医嘱记录
           Where 病人id = (Select 病人id From 病人医嘱记录 Where 相关id = v_Tansid And Rownum < 2) And (诊疗类别 = '5' Or 诊疗类别 = '6')) And
          Rownum < 2;
    Raise Err_Item;
  End If;

  --先将原收发记录的序号增大，新的收发记录产生后再删除
  --Update 药品收发记录
  --Set 序号 = 序号 + 10000
  --Where ID In (Select \*+rule *\
  --             Distinct c.Id
  --             From 病人医嘱记录 A, 病人医嘱发送 B, 药品收发记录 C, 住院费用记录 D, Table(f_Num2list(医嘱id_In)) F
  --             Where a.Id = b.医嘱id And c.费用id = d.Id And a.Id = d.医嘱序号 And b.No = c.No And b.执行部门id + 0 = 部门id_In And
  --                   c.单据 = 9 And c.审核日期 Is Null And a.相关id = f.Column_Value And b.发送号 = 发送号_In And c.序号 < 10000);

  For v_医嘱记录 In c_医嘱记录 Loop
    v_Continue := 1;
    n_病人id   := v_医嘱记录.病人id;
    n_科室id   := v_医嘱记录.病人科室id;
  
    Select Count(1)
    Into v_Continue
    From 病人医嘱记录 A, 输液不配置药品 B, 住院费用记录 C
    Where c.收费细目id = b.药品id And c.医嘱序号 = a.Id And a.相关id = v_医嘱记录.相关id;
    If v_Continue = 0 Then
      v_Continue := 1;
    Else
      v_Continue := 0;
    End If;
  
    --参数控制产生输液单
    If (v_医嘱类型 = 1 And v_医嘱记录.医嘱类型 <> 1) Or (v_医嘱类型 = 2 And v_医嘱记录.医嘱类型 <> 2) Then
      v_Continue := 0;
    End If;
  
    If Not v_大输液给药途径 Is Null Then
      If Instr(',' || v_大输液给药途径 || ',', ',' || v_医嘱记录.给药途径 || ',') = 0 Then
        v_Continue := 0;
      End If;
    End If;
  
    If Not v_来源科室 Is Null Then
      If Instr(',' || v_来源科室 || ',', ',' || v_医嘱记录.病人科室id || ',') = 0 Then
        v_Continue := 0;
      End If;
    End If;
  
    v_药品类型 := Null;
    For r_药品类型 In (Select Decode(Nvl(d.抗生素, 0), 0, Decode(Nvl(d.是否肿瘤药, 0), 0, '', '肿瘤药'), '抗生素') 药品类型
                   From 病人医嘱记录 A, 药品规格 B, 住院费用记录 C, 药品特性 D
                   Where c.收费细目id = b.药品id And b.药名id = d.药名id And c.医嘱序号 = a.Id And a.相关id = v_医嘱记录.相关id) Loop
      If r_药品类型.药品类型 Is Not Null Then
        v_药品类型 := r_药品类型.药品类型;
        v_Continue := 1;
      End If;
    End Loop;
  
    If v_药品类型 Is Null Then
      If v_医嘱记录.是否tpn = 2 Then
        v_药品类型 := '营养药';
        v_Continue := 1;
      End If;
    End If;
  
    If v_Continue = 1 Then
      v_Old相关id := v_New相关id;
      v_相关id    := v_医嘱记录.相关id;
      v_New相关id := v_相关id;
      v_发送号    := v_医嘱记录.发送号;
      v_序号      := 0;
    
      If v_Continue = 1 Then
        --v_Count := Zl_Gettransexenumber(v_医嘱记录.开始执行时间, v_医嘱记录.首次时间, v_医嘱记录.末次时间, v_医嘱记录.频率间隔, v_医嘱记录.间隔单位, v_医嘱记录.执行时间方案);
        Select Count(医嘱id)
        Into v_Count
        From 医嘱执行时间
        Where 医嘱id = v_医嘱记录.相关id And 发送号 = v_医嘱记录.发送号;
      
        v_Nodosage := 0;
      
        For I In 1 .. v_Count Loop
          Select 输液配药记录_Id.Nextval Into v_配药id From Dual;
          v_序号 := v_序号 + 1;
        
          If I > 1 Then
            --从医嘱执行时间表中取医嘱的执行时间
            Select 要求时间
            Into v_执行时间
            From 医嘱执行时间
            Where 医嘱id = v_医嘱记录.相关id And 发送号 = v_医嘱记录.发送号 And 要求时间 > v_执行时间 And Rownum = 1
            Order By 要求时间;
          Else
            Select Min(要求时间)
            Into v_执行时间
            From 医嘱执行时间
            Where 医嘱id = v_医嘱记录.相关id And 发送号 = v_医嘱记录.发送号 And Rownum = 1
            Order By 要求时间;
          End If;
        
          v_批次 := 0;
        
          If d_Old执行时间 <> Trunc(v_执行时间) Or d_Old执行时间 Is Null Then
            b_Change := True;
          End If;
        
          If b_Change = True Then
            If d_Old执行时间 <> Trunc(v_执行时间) Or d_Old执行时间 Is Null Then
              d_Old执行时间 := v_执行时间;
            
              Select Count(Distinct a.摆药单号)
              Into n_摆药单
              From 输液配药记录 A
              Where a.医嘱id In (Select ID From 病人医嘱记录 Where 病人id = v_医嘱记录.病人id And 相关id Is Null) And
                    a.执行时间 Between Trunc(v_执行时间 - 1) And Trunc(v_执行时间) - 1 / 24 / 60 / 60 And 操作状态 >= 2 And 操作状态 < 9;
            
              If n_摆药单 > 1 Then
                Update 输液配药记录
                Set 是否调整批次 = 1
                Where 医嘱id In (Select ID From 病人医嘱记录 Where 病人id = n_病人id) And
                     
                      执行时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
                b_Change := False;
              
              End If;
            End If;
          End If;
        
          If b_Change = True Then
            n_病人id := v_医嘱记录.病人id;
            Select Count(ID)
            
            Into n_Sum
            From 输液配药记录
            Where 医嘱id = v_医嘱记录.相关id And 执行时间 Between Trunc(v_执行时间 - 1) And Trunc(v_执行时间) - 1 / 24 / 60 / 60;
            If n_Sum = 0 Then
              Update 输液配药记录
              Set 是否调整批次 = 1
              Where 医嘱id In (Select ID From 病人医嘱记录 Where 病人id = n_病人id) And
                   
                    执行时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
              b_Change := False;
            
            End If;
          
            If b_Change = True Then
              --检查输液单是否调整到打包状态
              Select Count(a.Id)
              Into n_Sum
              From 输液配药记录 A, 输液配药内容 B, 药品收发记录 C
              Where a.Id = b.记录id And b.收发id = c.Id And
                    a.医嘱id In (Select ID
                               From 病人医嘱记录
                               Where 病人id = (Select 病人id From 病人医嘱记录 Where ID = v_医嘱记录.相关id And Rownum < 2)) And
                    a.执行时间 Between Trunc(v_执行时间 - 1) And Trunc(v_执行时间) - 1 / 24 / 60 / 60 And a.打包时间 Is Not Null;
              If n_Sum <> 0 Then
                Update 输液配药记录
                Set 是否调整批次 = 1
                Where 医嘱id In (Select ID From 病人医嘱记录 Where 病人id = n_病人id) And 执行时间 Between Trunc(v_执行时间) And
                      Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
                b_Change := False;
              End If;
            
              Select Count(医嘱id)
              Into n_Cur
              From 医嘱执行时间
              Where 医嘱id = v_医嘱记录.相关id And 要求时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60;
            
              Select Count(医嘱id)
              Into n_Sum
              From 医嘱执行时间
              Where 医嘱id = v_医嘱记录.相关id And 要求时间 Between Trunc(v_执行时间 - 1) And Trunc(v_执行时间) - 1 / 24 / 60 / 60;
            
              If n_Sum <> n_Cur Then
                Update 输液配药记录
                Set 是否调整批次 = 1
                Where 医嘱id In (Select ID From 病人医嘱记录 Where 病人id = n_病人id) And 执行时间 Between Trunc(v_执行时间) And
                      Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
                b_Change := False;
              End If;
            End If;
          End If;
        
          If v_时间串 <> Trunc(Sysdate) || ';false\' Or v_时间串 Is Null Then
            If Trunc(v_执行时间) = Trunc(Sysdate) Then
              If b_Change = False Then
                v_时间串 := Trunc(v_执行时间) || ';false\';
              Else
                v_时间串 := Trunc(v_执行时间) || ';true\';
              End If;
            End If;
          End If;
        
          If v_时间串1 <> Trunc(Sysdate + 1) || ';false\' Or v_时间串1 Is Null Then
            If Trunc(v_执行时间) = Trunc(Sysdate + 1) Then
              If b_Change = False Then
                v_时间串1 := Trunc(v_执行时间) || ';false\';
              Else
                v_时间串1 := Trunc(v_执行时间) || ';true\';
              End If;
            End If;
          End If;
        
          If v_药品类型 Is Null Or n_特殊药品批次 = 0 Then
            v_批次 := Zl_Getpivaworkbatch(v_执行时间, Sysdate);
          Else
            --药品类型不为空，直接根据药品类型匹配批次
            v_批次 := Zl_Getpivaworkbatch(v_执行时间, Sysdate, v_药品类型);
          End If;
        
          Select Count(医嘱id)
          Into n_发送次数
          From 医嘱执行时间
          Where 医嘱id = v_医嘱记录.相关id And 要求时间 <= v_执行时间
          Order By 要求时间;
        
          If n_发送次数 > 99 Then
            n_发送次数 := Mod(n_发送次数, 99);
          End If;
        
          If Length(v_医嘱记录.相关id) > 9 Then
            If n_发送次数 < 10 Then
              Select '91' || Substr(To_Char(v_医嘱记录.相关id), Length(v_医嘱记录.相关id) - 8) || To_Char(v_医嘱记录.相关id) || '0' ||
                      To_Char(n_发送次数)
              Into v_Maxno
              From Dual;
            Else
              Select '91' || Substr(To_Char(v_医嘱记录.相关id), Length(v_医嘱记录.相关id) - 8) || To_Char(v_医嘱记录.相关id) ||
                      To_Char(n_发送次数)
              Into v_Maxno
              From Dual;
            End If;
          Else
            If n_发送次数 < 10 Then
              Select '91' || Substr('000000000', Length(v_医嘱记录.相关id) + 1) || To_Char(v_医嘱记录.相关id) || '0' ||
                      To_Char(n_发送次数)
              Into v_Maxno
              From Dual;
            Else
              Select '91' || Substr('000000000', Length(v_医嘱记录.相关id) + 1) || To_Char(v_医嘱记录.相关id) || To_Char(n_发送次数)
              Into v_Maxno
              From Dual;
            End If;
          End If;
          n_调整批次 := 0;
          If b_Change = False Then
            n_调整批次 := 1;
          End If;
        
          If v_批次 <> 0 Then
            Select Nvl(Max(打包), 0), Max(药品类型)
            Into n_打包, v_配药类型
            From 配药工作批次
            Where 批次 = v_批次 And 配置中心id = 部门id_In;
          End If;
        
          If (Trunc(v_执行时间) <= v_Currdate Or n_打包 <> 0) And v_配药类型 Is Null Then
            n_是否打包     := 1;
            d_手工打包时间 := Null;
          Else
            n_是否打包     := 0;
            d_手工打包时间 := Null;
          End If;
        
          --如果是TPN不管其他条件如何都设置为配置
          If v_医嘱记录.是否tpn = 2 Then
            n_是否打包     := 0;
            d_手工打包时间 := Null;
          End If;
        
          If v_批次 = 0 Then
            n_是否打包 := 1;
          End If;
          --产生配药记录
          Insert Into 输液配药记录
            (ID, 部门id, 序号, 姓名, 性别, 年龄, 住院号, 床号, 病人病区id, 病人科室id, 执行时间, 医嘱id, 发送号, 配药批次, 瓶签号, 是否调整批次, 是否打包, 打包时间, 操作状态,
             操作人员, 操作时间)
          Values
            (v_配药id, 部门id_In, v_序号, v_医嘱记录.姓名, v_医嘱记录.性别, v_医嘱记录.年龄, v_医嘱记录.住院号, v_医嘱记录.床号, v_医嘱记录.病人病区id,
             v_医嘱记录.病人科室id, v_执行时间, v_医嘱记录.相关id, v_医嘱记录.发送号, v_批次, v_Maxno, n_调整批次, n_是否打包, d_手工打包时间, 1, 核查人_In, 核查时间_In);
        
          Insert Into 输液配药状态 (配药id, 操作类型, 操作人员, 操作时间) Values (v_配药id, 1, 核查人_In, 核查时间_In);
        
          For v_单个医嘱记录 In c_单个医嘱记录 Loop
            n_医嘱id   := v_单个医嘱记录.医嘱id;
            n_累计数量 := 0;
            n_剩余数量 := 0;
          
            Select Sum(c.实际数量)
            Into n_Sum
            From 病人医嘱记录 A, 病人医嘱发送 B, 药品收发记录 C, 住院费用记录 D
            Where a.Id = b.医嘱id And c.费用id = d.Id And a.Id = d.医嘱序号 And b.No = c.No And b.执行部门id + 0 = 部门id_In And
                  c.单据 = 9 And c.审核日期 Is Null And a.Id = n_医嘱id And b.发送号 = v_医嘱记录.发送号 And c.序号 < 1000;
          
            --产生配药记录对应的药品记录
            For v_收发记录 In c_收发记录 Loop
              If v_收发记录.是否不予配置 = 1 Then
                v_Nodosage := 1;
              End If;
            
              Select 药品收发记录_Id.Nextval Into n_Lngid From Dual;
              n_累计数量 := n_累计数量 + v_收发记录.数量;
            
              If n_剩余数量 = 0 Then
                n_剩余数量 := n_Sum / v_Count;
              End If;
              n_单次数量 := n_Sum / v_Count;
            
              If n_累计数量 >= n_Sum / v_Count * I Then
                n_Count := n_Count + 1;
                Insert Into 药品收发记录
                  (ID, 记录状态, 单据, NO, 序号, 库房id, 供药单位id, 入出类别id, 对方部门id, 入出系数, 药品id, 批次, 产地, 批号, 生产日期, 效期, 付数, 填写数量, 实际数量,
                   成本价, 成本金额, 扣率, 零售价, 零售金额, 差价, 摘要, 填制人, 填制日期, 配药人, 配药日期, 审核人, 审核日期, 价格id, 费用id, 单量, 频次, 用法, 外观, 灭菌日期,
                   灭菌效期, 产品合格证, 发药方式, 发药窗口, 领用人, 批准文号, 汇总发药号, 注册证号, 库房货位, 商品条码, 内部条码, 核查人, 核查日期, 签到确认人, 签到时间)
                  Select n_Lngid, 记录状态, 单据, NO, n_Count + 1000, 库房id, 供药单位id, 入出类别id, 对方部门id, 入出系数, 药品id, 批次, 产地, 批号,
                         生产日期, 效期, 付数, n_剩余数量, n_剩余数量, 成本价, Round(成本价 * n_剩余数量, n_流通金额小数), 扣率, 零售价,
                         Round(零售价 * n_剩余数量, n_流通金额小数), Round(差价 * (实际数量 / n_剩余数量), n_流通金额小数), '复制', 填制人, 填制日期, 配药人,
                         配药日期, 审核人, 审核日期, 价格id, 费用id, 单量, 频次, 用法, 外观, 灭菌日期, 灭菌效期, 产品合格证, 发药方式, 发药窗口, 领用人, 批准文号, 汇总发药号,
                         注册证号, 库房货位, 商品条码, 内部条码, 核查人, 核查日期, 签到确认人, 签到时间
                  From 药品收发记录
                  Where ID = v_收发记录.收发id;
              
                Insert Into 输液配药内容 (记录id, 收发id, 数量) Values (v_配药id, n_Lngid, n_剩余数量);
              
                n_剩余数量 := 0;
                Exit;
              Elsif n_累计数量 > (n_Sum / v_Count * (I - 1)) Then
                n_Count    := n_Count + 1;
                n_填写数量 := n_累计数量 - (n_Sum / v_Count * (I - 1)) - (n_单次数量 - n_剩余数量);
                Insert Into 药品收发记录
                  (ID, 记录状态, 单据, NO, 序号, 库房id, 供药单位id, 入出类别id, 对方部门id, 入出系数, 药品id, 批次, 产地, 批号, 生产日期, 效期, 付数, 填写数量, 实际数量,
                   成本价, 成本金额, 扣率, 零售价, 零售金额, 差价, 摘要, 填制人, 填制日期, 配药人, 配药日期, 审核人, 审核日期, 价格id, 费用id, 单量, 频次, 用法, 外观, 灭菌日期,
                   灭菌效期, 产品合格证, 发药方式, 发药窗口, 领用人, 批准文号, 汇总发药号, 注册证号, 库房货位, 商品条码, 内部条码, 核查人, 核查日期, 签到确认人, 签到时间)
                  Select n_Lngid, 记录状态, 单据, NO, n_Count + 1000, 库房id, 供药单位id, 入出类别id, 对方部门id, 入出系数, 药品id, 批次, 产地, 批号,
                         生产日期, 效期, 付数, n_填写数量, n_填写数量, 成本价, Round(成本价 * n_填写数量, n_流通金额小数), 扣率, 零售价,
                         Round(零售价 * n_填写数量, n_流通金额小数), Round(差价 * (实际数量 / n_填写数量), n_流通金额小数), '复制', 填制人, 填制日期, 配药人,
                         配药日期, 审核人, 审核日期, 价格id, 费用id, 单量, 频次, 用法, 外观, 灭菌日期, 灭菌效期, 产品合格证, 发药方式, 发药窗口, 领用人, 批准文号, 汇总发药号,
                         注册证号, 库房货位, 商品条码, 内部条码, 核查人, 核查日期, 签到确认人, 签到时间
                  From 药品收发记录
                  Where ID = v_收发记录.收发id;
              
                Insert Into 输液配药内容 (记录id, 收发id, 数量) Values (v_配药id, n_Lngid, n_填写数量);
              
                n_剩余数量 := n_剩余数量 - n_填写数量;
              End If;
            End Loop;
          End Loop;
          n_优先级 := Zl_Getfirst(v_配药id, v_医嘱记录.病人科室id);
          Update 输液配药记录 Set 优先级 = n_优先级 Where ID = v_配药id;
        
        End Loop;
      
        For v_收发记录 In c_原始收发记录 Loop
          n_单据 := v_收发记录.单据;
        
          v_No := v_收发记录.No;
          Delete From 药品收发记录 Where ID = v_收发记录.收发id;
        End Loop;
      
        --单个药品或者不予配置的药品默认为0批次
        Select Count(收发id) Into n_Row From 输液配药内容 Where 记录id = v_配药id;
        If (v_Nodosage = 1 Or n_Row = 1) And n_打包药品批次 = 1 Then
          Update 输液配药记录
          Set 配药批次 = 0, 是否打包 = 1
          Where 医嘱id = v_医嘱记录.相关id And 发送号 = v_医嘱记录.发送号 And 操作状态 < 2;
        End If;
        --如果存在“不予配置”属性的药品，也设置为打包
        If v_Nodosage = 1 Then
          Update 输液配药记录
          Set 是否打包 = 1
          Where 医嘱id = v_医嘱记录.相关id And 发送号 = v_医嘱记录.发送号 And 操作状态 < 2;
        End If;
      End If;
    End If;
  End Loop;

  For v_收发记录 In (Select ID From 药品收发记录 Where 序号 < 1000 And 单据 = n_单据 And NO = v_No) Loop
    n_Count := n_Count + 1;
    Update 药品收发记录 Set 序号 = n_Count + 1000, 摘要 = '复制' Where ID = v_收发记录.Id;
  End Loop;

  Update 药品收发记录
  Set 序号 = 序号 - 1000, 摘要 = '医嘱发送'
  Where 摘要 = '复制' And 序号 > 1000 And 单据 = n_单据 And NO = v_No;

  If n_备用批次 = 1 Then
  
    Select Count(a.Id)
    Into n_Sum
    From 输液配药记录 A, 病人医嘱发送 B
    Where a.医嘱id = b.医嘱id And a.发送号 = b.发送号 And
          a.医嘱id In (Select ID From 病人医嘱记录 Where 病人id = n_病人id And 相关id Is Null) And b.发送时间 Between Trunc(Sysdate) And
          Trunc(Sysdate + 1) - 1 / 24 / 60 / 60 And a.执行时间 Between Trunc(Sysdate) And
          Trunc(Sysdate + 1) - 1 / 24 / 60 / 60 And 操作状态 < 9;
    If n_Sum <> 0 Then
      b_Change  := False;
      v_时间串1 := Trunc(Sysdate + 1) || ';false\';
    
      Update 输液配药记录
      Set 是否调整批次 = 1
      Where 医嘱id In (Select ID From 病人医嘱记录 Where 病人id = n_病人id) And 执行时间 Between Trunc(Sysdate + 1) And
            Trunc(Sysdate + 2) - 1 / 24 / 60 / 60 And 操作状态 < 2;
    End If;
  End If;
  If v_时间串 Is Null Then
    v_时间串 := v_时间串1;
  Else
    v_时间串 := v_时间串 || v_时间串1;
  End If;

  While v_时间串 Is Not Null Loop
    --分解单据ID串
    v_Fields   := Substr(v_时间串, 1, Instr(v_时间串, '\') - 1);
    v_时间值   := Substr(v_Fields, 1, Instr(v_Fields, ';') - 1);
    v_是否改变 := Substr(v_Fields, Instr(v_Fields, ';') + 1);
  
    v_时间串 := Replace('\' || v_时间串, '\' || v_Fields || '\');
  
    If v_是否改变 = 'true' Then
      b_Change := True;
    Else
      b_Change := False;
    End If;
  
    If b_Change = True Then
      Select Count(医嘱id)
      Into n_Cur
      From (Select Distinct a.要求时间, a.医嘱id
             From 医嘱执行时间 A, 输液配药记录 B
             Where a.要求时间 = b.执行时间 And a.医嘱id = b.医嘱id And a.要求时间 Between Trunc(v_时间值) And
                   Trunc(v_时间值 + 1) - 1 / 24 / 60 / 60 And
                   a.医嘱id In (Select ID From 病人医嘱记录 Where 病人id = n_病人id And 相关id Is Null));
    
      Select Count(医嘱id)
      Into n_Sum
      From (Select Distinct a.要求时间, a.医嘱id
             From 医嘱执行时间 A, 输液配药记录 B
             Where a.要求时间 = b.执行时间 And a.医嘱id = b.医嘱id And a.要求时间 Between Trunc(v_时间值 - 1) And
                   Trunc(v_时间值) - 1 / 24 / 60 / 60 And
                   a.医嘱id In (Select ID From 病人医嘱记录 Where 病人id = n_病人id And 相关id Is Null));
    
      If n_Cur <> n_Sum Then
        Update 输液配药记录
        Set 是否调整批次 = 1
        Where 医嘱id In (Select ID From 病人医嘱记录 Where 病人id = n_病人id) And 执行时间 Between Trunc(v_时间值) And
              Trunc(v_时间值 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
        b_Change := False;
      End If;
    End If;
  
    If v_保持上次批次 = 1 And b_Change = True Then
      For v_输液单记录 In c_输液单记录 Loop
        Select Distinct 配药批次
        Into v_批次
        From 输液配药记录 A, 输液配药内容 B, 药品收发记录 C
        Where a.Id = b.记录id And b.收发id = c.Id And a.医嘱id = v_输液单记录.医嘱id And
              To_Char(a.执行时间, 'hh24:mi:ss') = To_Char(v_输液单记录.执行时间, 'hh24:mi:ss') And
              a.执行时间 Between Trunc(v_输液单记录.执行时间 - 1) And Trunc(v_输液单记录.执行时间) - 1 / 24 / 60 / 60 And Rownum = 1;
      
        Update 输液配药记录
        Set 是否确认调整 = 0
        Where 医嘱id In (Select ID From 病人医嘱记录 Where 病人id = n_病人id) And 执行时间 Between Trunc(v_输液单记录.执行时间) And
              Trunc(v_输液单记录.执行时间 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
      
        If v_输液单记录.配药批次 <> v_批次 Then
          Update 输液配药记录 Set 配药批次 = v_批次 Where ID = v_输液单记录.Id;
          Select Nvl(Max(打包), 0) Into n_打包 From 配药工作批次 Where 批次 = v_批次 And 配置中心id = 部门id_In;
          If n_打包 <> 0 Then
            Update 输液配药记录 Set 是否打包 = n_打包 Where ID = v_输液单记录.Id;
          Else
            Select Nvl(Max(打包), 0)
            Into n_打包
            From 配药工作批次
            Where 批次 = v_输液单记录.配药批次 And 配置中心id = 部门id_In;
          
            If n_打包 <> 0 Then
              Update 输液配药记录 Set 是否打包 = 0 Where ID = v_输液单记录.Id;
            End If;
          End If;
        End If;
      End Loop;
    End If;
  
    If n_自动排批 = 1 And (b_Change = False Or v_保持上次批次 = 0) Then
      For v_输液单记录 In c_输液单记录 Loop
        v_批次 := Zl_Getpivaworkbatch(v_输液单记录.执行时间, v_输液单记录.发送时间);
        Update 输液配药记录 Set 配药批次 = v_批次 Where ID = v_输液单记录.Id;
      End Loop;
      Zl_输液配药记录_自动排批(n_病人id, n_科室id, 部门id_In, v_时间值);
    End If;
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]病人' || v_当前病人 || '在输液配置中心有被锁定的输液单，发送失败！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_输液配药记录_核查;
/



--102941:冉俊明,2016-11-25,删除号源的同时停用当前时间以后的所有出诊安排。
Create Or Replace Procedure Zl_临床出诊号源_Delete(Id_In 临床出诊号源.Id%Type) As
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  n_Count    Number;
  l_限制id   t_Numlist := t_Numlist();
  d_开始时间 临床出诊记录.开始时间%Type;
Begin
  Select Count(1) Into n_Count From 临床出诊安排 Where 号源id = Id_In And Rownum < 2;

  If n_Count = 0 Then
  
    Select ID Bulk Collect Into l_限制id From 临床出诊号源限制 Where 号源id = Id_In;
  
    Forall I In 1 .. l_限制id.Count
      Delete 临床出诊号源时段 Where 限制id = l_限制id(I);
  
    Forall I In 1 .. l_限制id.Count
      Delete 临床出诊号源控制 Where 限制id = l_限制id(I);
  
    Forall I In 1 .. l_限制id.Count
      Delete 临床出诊号源诊室 Where 限制id = l_限制id(I);
  
    Delete 临床出诊号源限制 Where 号源id = Id_In;
  
    Delete From 临床出诊号源 Where ID = Id_In;
    If Sql%NotFound Then
      v_Err_Msg := '当前号源可能已被他人删除，不能再删除！';
      Raise Err_Item;
    End If;
    Return;
  End If;

  --假删除
  Update 临床出诊号源 Set 是否删除 = 1, 撤档时间 = Sysdate Where ID = Id_In And Nvl(是否删除, 0) = 0;
  If Sql%NotFound Then
    v_Err_Msg := '当前号源可能已被他人删除，不能再删除！';
    Raise Err_Item;
  End If;

  --将当前时间以后的所有出诊记录停诊
  For c_记录 In (Select ID, 开始时间, 终止时间
               From 临床出诊记录
               Where 号源id = Id_In And 出诊日期 >= Trunc(Sysdate) - 1 And 终止时间 > Sysdate And 上班时段 Is Not Null) Loop
  
    If c_记录.开始时间 < Sysdate Then
      d_开始时间 := Sysdate;
    Else
      d_开始时间 := c_记录.开始时间;
    End If;
    Zl_临床出诊记录_Stopvisit(c_记录.Id, d_开始时间, c_记录.终止时间, '删除号源', Zl_Username, Sysdate, 0, 1);
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊号源_Delete;
/

--102641:胡俊勇,2016-11-25,RIS预约相关修改
Create Or Replace Procedure Zl_Ris检查预约_Insert
(
  医嘱id_In     In Ris检查预约.医嘱id%Type,
  预约id_In     In Ris检查预约.预约id%Type,
  预约日期_In   In Ris检查预约.预约日期%Type,
  设备id_In     In Ris检查预约.检查设备id%Type,
  设备名称_In   In Ris检查预约.检查设备名称%Type,
  开始时间_In   In Ris检查预约.预约开始时间%Type,
  结束时间_In   In Ris检查预约.预约结束时间%Type,
  开始时间段_In In Ris检查预约.预约开始时间段%Type,
  结束时间段_In In Ris检查预约.预约结束时间段%Type,
  序号_In       In Ris检查预约.序号%Type
) Is
Begin
  Insert Into Ris检查预约
    (医嘱id, 预约id, 预约日期, 检查设备id, 检查设备名称, 预约开始时间, 预约结束时间, 预约开始时间段, 预约结束时间段, 序号)
  Values
    (医嘱id_In, 预约id_In, 预约日期_In, 设备id_In, 设备名称_In, 开始时间_In, 结束时间_In, 开始时间段_In, 结束时间段_In, 序号_In);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Ris检查预约_Insert;
/

--103097:王振涛,2016-11-24,处理多个年龄单位的情况
CREATE OR REPLACE Function Zl_Get_Reference
(
  Type_In       In Number, --0=参考 1=参考ID 2=危急参考 3=危急参考下限 4=危急参考上限
  项目id_In     In Number,
  标本类型_In   In Varchar2,
  性别_In       In Number,
  出生日期_In   In Date,
  仪器id_In     In Number := Null,
  年龄_In       In Varchar2 := Null,
  申请科室id_In In Number := Null
) Return Varchar2 As

  Cursor v_Reference_Type Is
    Select a.Id,
           Trim(To_Char(a.参考低值, c.格式)) || '～' || Trim(To_Char(a.参考高值, c.格式)) ||
            Decode(a.临床特征, Null, '', '成人', '', '婴儿', '', ' ' || a.临床特征) As 结果参考, b.结果类型, b.取值序列,
           Trim(To_Char(a.警示下限, c.格式)) || '～' || Trim(To_Char(a.警示上限, c.格式)) ||
            Decode(a.临床特征, Null, '', '成人', '', '婴儿', '', ' ' || a.临床特征) As 危急参考, a.警示下限, a.警示上限, Nvl(b.多参考, 0) 多参考
    From 检验项目参考 A, 检验项目 B,
         (Select '9999990' ||
                   Decode(Max(Nvl(c.小数位数, -1)), 0, '', -1, '.00', Substr('.000000', 1, 1 + Max(Nvl(c.小数位数, -1)))) As 格式


           From 检验仪器项目 C, 检验项目 D
           Where d.诊治项目id = 项目id_In And d.诊治项目id = c.项目id(+)) C
    Where a.项目id = 项目id_In And a.项目id = b.诊治项目id;

  v_Return Varchar2(4000);
  v_Sql    Varchar2(4000);

  Type c_Type Is Ref Cursor; --声明REF游标类型
  r_Emp v_Reference_Type%RowType; --声明一个行类型变量
  Cur   c_Type; --声明REF游标类型的变量

  v_结果类型 Number(1);

  v_年数     Number(18, 1);
  v_月数     Number(18, 1);
  v_日数     Number(18, 1);
  v_小时     Number(18, 1);
  v_出生日期 Date;
  v_Pos      Number(4);
  v_多参考   Number(4);
  v_Value    Number(18);
  v_Valuerec Varchar2(255);
  v_年龄     Varchar2(50);
  v_结果参考 Varchar2(1000);
  v_参考id   Number(18);
  v_危紧参考 Varchar2(1000);
  v_警示下限 Varchar2(1000);
  v_警示上限 Varchar2(1000);
  d_Sysdate  Date;

  v_项目id_Bound   检验项目参考.项目id%Type;
  v_标本类型_Bound 检验项目参考.标本类型%Type;
  v_性别域1_Bound  检验项目参考.性别域%Type;
  v_性别域2_Bound  检验项目参考.性别域%Type;
  v_性别域3_Bound  检验项目参考.性别域%Type;
  v_仪器id_Bound   检验项目参考.仪器id%Type;

  v_年龄单位日_Bound   检验项目参考.年龄单位%Type;
  v_年龄单位月_Bound   检验项目参考.年龄单位%Type;
  v_年龄单位小时_Bound 检验项目参考.年龄单位%Type;
  v_年龄单位年_Bound   检验项目参考.年龄单位%Type;

  v_年龄单位日1_Bound   检验项目参考.年龄单位%Type;
  v_年龄单位月1_Bound   检验项目参考.年龄单位%Type;
  v_年龄单位小时1_Bound 检验项目参考.年龄单位%Type;
  v_年龄单位年1_Bound   检验项目参考.年龄单位%Type;

  v_临床特征_Bound   检验项目参考.临床特征%Type;
  v_申请科室id_Bound 检验项目参考.申请科室id%Type;
  v_年龄_1           Varchar2(50);
  v_年龄_2           Varchar2(50);

  Function Sub_Is_Number(v_In In Varchar2) Return Boolean Is
    n_Tmp Number;
  Begin
    n_Tmp := To_Number(v_In);
    If n_Tmp Is Not Null Then
      Return True;
    Else
      Return False;
    End If;
  Exception
    When Others Then
      Return False;
  End Sub_Is_Number;

  Function Zlsplit
  (
    v_Str       In Varchar2,
    v_Delimiter In Varchar2,
    v_Number    In Number
  ) Return Varchar2 Is
    v_Record     Varchar2(1000);
    v_Currrecord Varchar2(1000);
    v_Currnum    Number;
  Begin
    v_Record  := v_Str || v_Delimiter;
    v_Currnum := 0;
    While v_Record Is Not Null Loop
      v_Currrecord := Substr(v_Record, 1, Instr(v_Record, v_Delimiter) - 1);
      If v_Currnum = v_Number Then
        Return(v_Currrecord);
      End If;

      v_Currnum := v_Currnum + 1;
      v_Record  := Replace(v_Delimiter || v_Record, v_Delimiter || v_Currrecord || v_Delimiter);
    End Loop;

    Return('');
  End Zlsplit;
  Function Zlval(Vstr In Varchar2) Return Number Is
    Result Number(16, 6);
    Intbit Number(8);
    Strnum Varchar(10);
  Begin
    Strnum := '';
    For Intbit In 1 .. 10 Loop
      If Instr('0123456789.', Substr(Vstr, Intbit, 1)) = 0 Then
        Exit;
      End If;
      Strnum := Strnum || Substr(Vstr, Intbit, 1);
      Null;
    End Loop;
    Result := To_Number(Strnum);
    Return(Result);
  End Zlval;

Begin
  d_Sysdate := Sysdate;

  v_Sql := ' Select a.id,Trim(To_Char(A.参考低值, C.格式)) || ''～'' || Trim(To_Char(A.参考高值, C.格式)) || ' ||
           ' Decode(A.临床特征, Null, '''', ''成人'', '''', ''婴儿'','''', '' '' || A.临床特征) As 结果参考, B.结果类型, B.取值序列, ' ||
           ' Trim(To_Char(A.警示下限, C.格式)) || ''～'' || Trim(To_Char(A.警示上限, C.格式)) || ' || ' Decode(A.临床特征, Null, '''', ''成人'', '''', ''婴儿'','''', '' '' || A.临床特征) As 危急参考,a.警示下限,a.警示上限,
             nvl(b.多参考,0) 多参考 ' || ' From 检验项目参考 A, 检验项目 B, ' || ' (Select ''9999990'' || ' ||
           ' Decode(Max(Nvl(C.小数位数, -1)), 0, '''', -1, ''.00'', Substr(''.000000'', 1, 1 + Max(Nvl(C.小数位数, -1)))) As 格式 ' ||
           ' From 检验仪器项目 C, 检验项目 D ' || ' Where D.诊治项目ID = :项目ID And D.诊治项目ID = C.项目ID(+)) C ' ||
           ' Where A.项目ID = :项目ID And A.项目ID = B.诊治项目ID ';

  v_项目id_Bound := 项目id_In;

  v_年龄 := 年龄_In;
  If v_年龄 = '岁' Then
    v_年龄 := Null;
  End If;

  If v_年龄 = '月' Then
    v_年龄 := Null;
  End If;

  If v_年龄 = '小时' Then
    v_年龄 := Null;
  End If;

  If v_年龄 = '天' Then
    v_年龄 := Null;
  End If;

  If Nvl(标本类型_In, '') <> '' Or 标本类型_In Is Not Null Then
    v_Sql := v_Sql || ' And A.标本类型 = :标本类型 ';
  Else
    v_Sql := v_Sql || ' And (A.标本类型 = :标本类型 or 1=1) ';
  End If;
  v_标本类型_Bound := 标本类型_In;

  If Nvl(性别_In, '') <> '' Or 性别_In Is Not Null Then
    --V_Sql := V_Sql || ' And A.性别域 = Nvl(' || 性别_In || ', 1) ';
    v_Sql := v_Sql || ' And decode(A.性别域,null,:性别,0,:性别,A.性别域) = Nvl(:性别, 1) ';

  Else
    v_Sql := v_Sql || ' And (decode(A.性别域,null,:性别1,0,:性别2,A.性别域) = Nvl(:性别3, 1) or 1 = 1) ';
  End If;
  v_性别域1_Bound := 性别_In;
  v_性别域2_Bound := 性别_In;
  v_性别域3_Bound := 性别_In;

  If Nvl(仪器id_In, '') <> '' Or 仪器id_In Is Not Null Then
    v_Sql := v_Sql || ' And (A.仪器id = :仪器ID Or A.仪器id Is Null) ';
  Else
    v_Sql := v_Sql || ' And (A.仪器id = :仪器ID Or A.仪器id Is Null or 1=1) ';
  End If;
  v_仪器id_Bound := 仪器id_In;

  If Nvl(v_年龄, '') <> '' Or v_年龄 Is Not Null Then
    If Instr(v_年龄, '岁') > 0 Or Instr(v_年龄, '月') > 0 Or Instr(v_年龄, '天') > 0 Or Instr(v_年龄, '小时') > 0 Or
       Sub_Is_Number(v_年龄) Then
      --处理日期
      v_出生日期 := 出生日期_In;
      v_年龄_1   := v_年龄;
      If Instr(v_年龄_1, '岁') > 0 Then
        v_年龄   := Substr(v_年龄_1, 1, Instr(v_年龄_1, '岁'));
        v_年龄_2 := Substr(v_年龄_1, Instr(v_年龄_1, '岁') + 1);
      Elsif Instr(v_年龄, '月') > 0 Then
        v_年龄   := Substr(v_年龄_1, 1, Instr(v_年龄_1, '月'));
        v_年龄_2 := Substr(v_年龄_1, Instr(v_年龄_1, '月') + 1);
      Elsif Instr(v_年龄, '小时') > 0 Then
        v_年龄   := Substr(v_年龄_1, 1, Instr(v_年龄_1, '小时') + 1);
        v_年龄_2 := Substr(v_年龄_1, Instr(v_年龄_1, '小时') + 2);
        If v_年龄 = '0小时' Or v_年龄 = '0时' Then
          v_年龄 := ' ';
        End If;
      End If;
      If v_年龄 Is Not Null And (v_年龄 = '成人' Or v_年龄 = '婴儿' Or v_年龄 = '岁') = False Then
        If Substr(v_年龄, 1, 1) = '*' Then
          v_出生日期 := Add_Months(d_Sysdate, -216);
        Else
          If Substr(v_年龄, Length(v_年龄)) = '月' Then
            v_出生日期 := Add_Months(d_Sysdate, -1 * Nvl(Zlval(v_年龄), 0));
          Else
            If Substr(v_年龄, Length(v_年龄)) = '天' Then
              v_出生日期 := d_Sysdate - Nvl(Zlval(v_年龄), 0);
            Else
              If Substr(v_年龄, Length(v_年龄) - 1) = '小时' Then
                If Nvl(Zlval(v_年龄), 0) <> 0 Then
                  v_出生日期 := d_Sysdate - Nvl(Zlval(v_年龄), 0) / 24;
                End If;
              Else
                v_出生日期 := Add_Months(d_Sysdate, -12 * Nvl(Zlval(v_年龄), 0)) - 1;
              End If;
            End If;
          End If;
          If v_年龄_2 Is Not Null Then
            If Substr(v_年龄_2, Length(v_年龄_2)) = '月' Then
              v_出生日期 := Add_Months(v_出生日期, -1 * Nvl(Zlval(v_年龄_2), 0));
            Else
              If Substr(v_年龄_2, Length(v_年龄_2)) = '天' Then
                v_出生日期 := v_出生日期 - Nvl(Zlval(v_年龄_2), 0);
              Else
                If Substr(v_年龄_2, Length(v_年龄_2) - 1) = '小时' Then
                  If Nvl(Zlval(v_年龄_2), 0) <> 0 Then
                    v_出生日期 := v_出生日期 - Nvl(Zlval(v_年龄_2), 0) / 24;
                  End If;
                End If;
              End If;
            End If;
          End If;
        End If;
      End If;
      If Not (v_出生日期 Is Null) Then
        v_年数 := Round(Months_Between(d_Sysdate, v_出生日期) / 12 ,1);
        v_月数 := Round(Months_Between(d_Sysdate, v_出生日期) ,1);
        v_日数 := Round(d_Sysdate - v_出生日期 ,1);
        v_小时 := Round((d_Sysdate - (v_出生日期 - 1 / 24)) * 24 - 1);
      End If;
      v_Sql := v_Sql || 'And (Decode(A.年龄单位, ''日'',:日, ''月'',:月,''小时'',:小时,:年) ' ||
               ' Between Nvl(A.年龄下限, -9999) And Nvl(A.年龄上限, 9999) )';
    Else
      v_Sql := v_Sql || 'And (Decode(A.年龄单位, ''日'',:日, ''月'',:月,''小时'',:小时,:年) ' ||
               ' Between Nvl(A.年龄下限, -9999) And Nvl(A.年龄上限, 9999) or 1=1 )';
    End If;

  Else
    v_Sql := v_Sql || 'And (Decode(A.年龄单位, ''日'',:日, ''月'',:月,''小时'',:小时,:年) ' ||
             ' Between Nvl(A.年龄下限, -9999) And Nvl(A.年龄上限, 9999) or 1=1 )';
  End If;
  v_年龄单位日_Bound   := v_日数;
  v_年龄单位月_Bound   := v_月数;
  v_年龄单位小时_Bound := v_小时;
  v_年龄单位年_Bound   := v_年数;
  If Instr(v_年龄, '成人') > 0 Or Instr(v_年龄, '婴儿') > 0 Or Instr(v_年龄, '分钟') > 0 Then
    --处理成人和婴儿
    v_Sql := v_Sql || ' And A.临床特征 =:年龄';
  Else
    v_Sql := v_Sql || ' And (A.临床特征 =:年龄 or 1=1)';
    v_Sql := v_Sql || ' And instr(''婴儿,成人'',nvl(临床特征,'' '')) <= 0  ';
  End If;

  v_临床特征_Bound := Replace(v_年龄, '分钟', '婴儿');

  If Nvl(申请科室id_In, '') <> '' Or 申请科室id_In Is Not Null Then
    v_Sql := v_Sql || ' And (A.申请科室ID = :申请科室ID Or nvl(A.申请科室ID,0) = 0) ';
  Else
    v_Sql := v_Sql || ' And ((A.申请科室ID = :申请科室ID Or nvl(A.申请科室ID,0) = 0) or 1=1) ';
  End If;
  v_申请科室id_Bound := 申请科室id_In;

  If (Nvl(v_年龄, '') = '' Or v_年龄 Is Null) And (出生日期_In <> '' Or 出生日期_In Is Not Null) Then
    --按出生日期查询
    If Not (出生日期_In Is Null) Then
      v_年数 := Round(Months_Between(d_Sysdate, 出生日期_In) / 12 - 0.5);
      v_月数 := Round(Months_Between(d_Sysdate, 出生日期_In) - 0.5);
      v_日数 := Round(d_Sysdate - 出生日期_In - 0.5);
      v_小时 := Round((d_Sysdate - (出生日期_In - 1 / 24)) * 24 - 1);

      v_Sql := v_Sql || 'And (Decode(A.年龄单位, ''日'',:日, ''月'',:月,''小时'',:小时,:年) ' ||
               ' Between Nvl(A.年龄下限, -9999) And Nvl(A.年龄上限, 9999) )';
    Else
      v_Sql := v_Sql || 'And (Decode(A.年龄单位, ''日'',:日, ''月'',:月,''小时'',:小时,:年) ' ||
               ' Between Nvl(A.年龄下限, -9999) And Nvl(A.年龄上限, 9999) or 1=1 )';
    End If;

  Else
    v_Sql := v_Sql || 'And (Decode(A.年龄单位, ''日'',:日, ''月'',:月,''小时'',:小时,:年) ' ||
             ' Between Nvl(A.年龄下限, -9999) And Nvl(A.年龄上限, 9999) or 1=1 )';
  End If;
  v_年龄单位日1_Bound   := v_日数;
  v_年龄单位月1_Bound   := v_月数;
  v_年龄单位小时1_Bound := v_小时;
  v_年龄单位年1_Bound   := v_年数;

  --加上排序
  v_Sql := v_Sql || ' Order By a.默认 desc,A.临床特征 ';

  If Nvl(申请科室id_In, '') <> '' Or 申请科室id_In Is Not Null Then
    v_Sql := v_Sql || ' ,a.申请科室ID  ';
  End If;

  If Nvl(性别_In, '') <> '' Or 性别_In Is Not Null Then
    v_Sql := v_Sql || ' ,a.性别域 desc  ';
  Else
    v_Sql := v_Sql || ' ,a.性别域 ';
  End If;

  v_Sql := v_Sql || ' ,a.id ';

  v_Return := '';
  Open Cur For v_Sql
    Using v_项目id_Bound, v_项目id_Bound, v_标本类型_Bound, v_性别域1_Bound, v_性别域2_Bound, v_性别域3_Bound, v_仪器id_Bound, v_年龄单位日_Bound, v_年龄单位月_Bound, v_年龄单位小时_Bound, v_年龄单位年_Bound, v_临床特征_Bound, v_申请科室id_Bound, v_年龄单位日1_Bound, v_年龄单位月1_Bound, v_年龄单位小时1_Bound, v_年龄单位年1_Bound;

  Loop
    Fetch Cur
      Into r_Emp;
    Exit When Cur%NotFound;
    If Cur%RowCount > 0 Then

      v_结果类型 := r_Emp.结果类型;
      v_Valuerec := r_Emp.取值序列;
      v_参考id   := r_Emp.Id;
      v_多参考   := r_Emp.多参考;

      If Nvl(v_Return, '') = '' Or v_Return Is Null Then
        If Type_In = 2 Then
          v_Return := r_Emp.危急参考;
        Else
          v_Return := r_Emp.结果参考;
        End If;
      Else
        If Type_In = 2 Then
          v_Return := v_Return || Chr(13) || Chr(10) || r_Emp.危急参考;
        Else
          If v_多参考 = 1 Then
            v_Return := v_Return || Chr(13) || Chr(10) || r_Emp.结果参考;
          End If;
        End If;
      End If;

      --只增加第一个选出的警示参考
      If v_警示下限 = '' Or v_警示下限 Is Null Then
        v_警示下限 := r_Emp.警示下限;
      End If;
      If v_警示上限 = '' Or v_警示上限 Is Null Then
        v_警示上限 := r_Emp.警示上限;
      End If;
    End If;
  End Loop;

  If v_Return = '' Or v_Return Is Null Then
    Begin
      Select 结果参考, 结果类型, 取值序列, ID, 危急参考, 警示下限, 警示上限
      Into v_结果参考, v_结果类型, v_Valuerec, v_参考id, v_危紧参考, v_警示下限, v_警示上限
      From (Select a.Id,
                    Trim(To_Char(a.参考低值, c.格式)) || '～' || Trim(To_Char(a.参考高值, c.格式)) ||
                     Decode(a.临床特征, Null, '', '成人', '', '婴儿', '', ' ' || a.临床特征) As 结果参考, b.结果类型, b.取值序列,
                    Trim(To_Char(a.警示下限, c.格式)) || '～' || Trim(To_Char(a.警示上限, c.格式)) ||
                     Decode(a.临床特征, Null, '', '成人', '', '婴儿', '', ' ' || a.临床特征) As 危急参考, a.警示下限, a.警示上限
             From 检验项目参考 A, 检验项目 B,
                  (Select '9999990' ||
                            Decode(Max(Nvl(c.小数位数, -1)), 0, '', -1, '.00', Substr('.000000', 1, 1 + Max(Nvl(c.小数位数, -1)))) As 格式
                    From 检验仪器项目 C, 检验项目 D
                    Where d.诊治项目id = 项目id_In And d.诊治项目id = c.项目id(+)) C
             Where a.项目id = 项目id_In And a.项目id = b.诊治项目id
             Order By a.默认 Desc, a.临床特征, a.性别域)
      Where Rownum = 1;
      If Type_In = 2 Then
        v_Return := v_危紧参考;
      Else
        v_Return := v_结果参考;
      End If;
      --只增加第一个选出的警示参考
      If v_警示下限 = '' Or v_警示下限 Is Null Then
        v_警示下限 := r_Emp.警示下限;
      End If;
      If v_警示上限 = '' Or v_警示上限 Is Null Then
        v_警示上限 := r_Emp.警示上限;
      End If;
    Exception
      When Others Then
        v_Return := Null;
    End;
  End If;
  If v_Return <> '' Or v_Return Is Not Null Then

    If v_Return = '～' Then
      v_Return := '';
    Else
      If v_结果类型 = 2 Then
        v_Pos := Instr(v_Return, '～');

        Begin
          Select To_Number(Substr(v_Return, 1, v_Pos - 1)) Into v_Value From Dual;
        Exception
          When Others Then
            v_Value := 0;
        End;
        v_Return := Zlsplit(v_Valuerec, ';', v_Value);
      End If;
    End If;
    If Type_In = 0 Then
      Return v_Return;
    Elsif Type_In = 1 Then
      Return v_参考id;
    Elsif Type_In = 2 Then
      Return v_Return;
    Elsif Type_In = 3 Then
      Return v_警示下限;
    Elsif Type_In = 4 Then
      Return v_警示上限;
    End If;
  End If;
  Close Cur; --关闭游标
  Return v_Return;
End Zl_Get_Reference;
/

--104546:黄捷,2016-12-28,RIS提取信息
--102623:黄捷,2016-11-24,RIS打印预约通知
--103157:黄捷,2016-12-02,RIS分科室启用控制
--102400:黄捷,2016-12-08,报告名称自动编号

CREATE OR REPLACE Package b_Zlxwinterface Is
  Type t_Refcur Is Ref Cursor;

  --1、接收RIS状态改变
  Procedure Receiverisstate(医嘱id_In   病人医嘱发送.医嘱id%Type,
                            Risid_In    病人医嘱报告.Risid%Type,
                            状态_In     Number,
                            操作人员_In 病人医嘱发送.完成人%Type,
                            执行时间_In 病人医嘱发送.完成时间%Type := Null,
                            执行说明_In 病人医嘱发送.执行说明%Type := Null,
                            单独执行_In Number := 0);

  --2、费用确认
  Procedure 影像费用执行(医嘱id_In     影像检查记录.医嘱id%Type,
                   单独执行_In   Number := 0,
                   操作员编号_In 人员表.编号%Type := Null,
                   操作员姓名_In 人员表.姓名%Type := Null,
                   执行部门id_In 门诊费用记录.执行部门id%Type := Null);

  --3、取消费用确认
  Procedure 影像费用执行_Cancel(医嘱id_In     影像检查记录.医嘱id%Type,
                          单独执行_In   Number := 0,
                          操作员编号_In 人员表.编号%Type := Null,
                          操作员姓名_In 人员表.姓名%Type := Null,
                          执行部门id_In 门诊费用记录.执行部门id%Type := Null);

  --4、接收RIS的报告
  Procedure Receivereport(医嘱id_In   病人医嘱发送.医嘱id%Type,
                          Risid_In    病人医嘱报告.Risid%Type,
                          报告所见_In 电子病历内容.内容文本%Type,
                          报告意见_In 电子病历内容.内容文本%Type,
                          报告建议_In 电子病历内容.内容文本%Type,
                          报告医生_In 电子病历记录.创建人%Type);

  --5、修改申请单信息
  Procedure 影像病人信息_修改(医嘱id_In       病人医嘱记录.Id%Type,
                      姓名_In         病人信息.姓名%Type,
                      性别_In         病人信息.性别%Type,
                      年龄_In         病人信息.年龄%Type,
                      费别_In         病人信息.费别%Type,
                      医疗付款方式_In 病人信息.医疗付款方式%Type,
                      民族_In         病人信息.民族%Type,
                      婚姻_In         病人信息.婚姻状况%Type,
                      职业_In         病人信息.职业%Type,
                      身份证号_In     病人信息.身份证号%Type,
                      家庭地址_In     病人信息.家庭地址%Type,
                      家庭电话_In     病人信息.家庭电话%Type,
                      家庭地址邮编_In 病人信息.家庭地址邮编%Type,
                      出生日期_In     病人信息.出生日期%Type := Null);

  --6、取消申请单信息
  Procedure 取消检查申请单(医嘱id_In     病人医嘱执行.医嘱id%Type,
                    操作员编号_In 人员表.编号%Type := Null,
                    操作员姓名_In 人员表.姓名%Type := Null,
                    执行部门id_In 门诊费用记录.执行部门id%Type := 0,
                    拒绝原因_In   病人医嘱发送.执行说明%Type := Null);

  --7、插入医嘱操作失败记录
  Procedure RIS医嘱失败记录_Insert(病人来源_In   In RIS医嘱失败记录.病人来源%Type,
                             病人ID_In     In RIS医嘱失败记录.病人ID%Type,
                             主页ID_In     In RIS医嘱失败记录.主页ID%Type,
                             挂号单号_In   In RIS医嘱失败记录.挂号单号%Type,
                             发送号_In     In RIS医嘱失败记录.发送号%Type,
                             体检任务ID_In In RIS医嘱失败记录.体检任务ID%Type,
                             体检报到号_In In RIS医嘱失败记录.体检报到号%Type,
                             发送类型_In   In RIS医嘱失败记录.发送类型%Type);

  --8、更新医嘱操作失败记录
  Procedure RIS医嘱失败记录_重发(ID_In       In RIS医嘱失败记录.ID%Type,
                         操作类型_In In Number);

  --9、销账后新建住院记账单据
  Procedure 病人医嘱_重建单据(医嘱ID_In In 病人医嘱发送.医嘱ID%Type,
                      No_In     In 病人医嘱发送.No%Type,
                      Action_In In number);

  --10、打印RIS检查预约通知单
  Procedure RIS检查预约_打印(医嘱ID_In In RIS检查预约.医嘱ID%Type);

  --11、更新RIS分科室启用参数
  Procedure RIS启用控制_Update(检查类型_In RIS启用控制.检查类型%Type,
                           场合_In     RIS启用控制.场合%Type,
                           部门ids_In  Varchar2,
                           启用类型_In Number);

  --12、删除RIS分科室启用参数
  Procedure RIS启用控制_Delete;

  --13、根据元素名提取信息
  Function RIS_Replace_Element_Value(元素名_In   In 诊治所见项目.中文名%Type,
                                     病人id_In   In 电子病历记录.病人id%Type,
                                     就诊id_In   In 电子病历记录.主页id%Type,
                                     病人来源_In In 电子病历记录.病人来源%Type,
                                     医嘱id_In   In 病人医嘱发送.医嘱Id%Type)
    Return Varchar2;

End b_Zlxwinterface;

/

CREATE OR REPLACE Package Body b_Zlxwinterface Is

  --1、接收RIS状态改变
  Procedure Receiverisstate(医嘱id_In   病人医嘱发送.医嘱id%Type,
                            Risid_In    病人医嘱报告.Risid%Type,
                            状态_In     Number,
                            操作人员_In 病人医嘱发送.完成人%Type,
                            执行时间_In 病人医嘱发送.完成时间%Type := Null,
                            执行说明_In 病人医嘱发送.执行说明%Type := Null,
                            单独执行_In Number := 0) Is
  
    --参数：医嘱ID_IN - 单独执行的医嘱ID。
    --      状态_IN - -1-删除；0-预约；1-登记；3-检查完成；4-检查中止；9-初步报告；12-报告审核；15-发放
    --     单独执行_In -0-全部执行；1-单独执行；检查医嘱组合是否采用对每个项目分散单独执行的方式
  
    Cursor c_Adviceinfo Is
      Select ID,
             相关id,
             Nvl(相关id, ID) As 组id,
             诊疗类别,
             病人来源,
             执行科室id
        From 病人医嘱记录
       Where ID = 医嘱id_In;
    r_Adviceinfo c_Adviceinfo%RowType;
  
    v_执行状态 病人医嘱发送.执行状态%Type;
    v_执行过程 病人医嘱发送.执行过程%Type;
    n_执行     Number; --标记是否需要更新状态，1：需要更新，其他不需要更新
    v_Count    Number;
    v_完成人   病人医嘱发送.完成人%Type;
    v_完成时间 病人医嘱发送.完成时间%Type;
  
  Begin
  
    v_执行状态 := 0;
    v_执行过程 := 0;
  
    --提取医嘱的主医嘱ID，及组ID
    Open c_Adviceinfo;
    Fetch c_Adviceinfo
      Into r_Adviceinfo;
    Close c_Adviceinfo;
  
    --根据状态_IN执行医嘱
    ---1-删除；0-预约；1-登记；3-检查完成；4-检查中止；9-初步报告；12-报告审核；13-取消审核；14-报告删除；15-发放
  
    If 状态_In = -1 Or 状态_In = 0 Then
      v_执行状态 := 0; --未执行
      v_执行过程 := 0;
    Elsif 状态_In = 1 Then
      v_执行状态 := 3; --正在执行
      v_执行过程 := 2; --已报到
    Elsif 状态_In = 3 Or 状态_In = 14 Then
      v_执行状态 := 3; --正在执行
      v_执行过程 := 3; --已检查
    Elsif 状态_In = 4 Then
      --不改变
      v_执行状态 := v_执行状态;
    Elsif 状态_In = 9 Or 状态_In = 13 Then
      v_执行状态 := 3; --正在执行
      v_执行过程 := 4; --已报告
    Elsif 状态_In = 12 Then
      v_执行状态 := 3; --正在执行
      v_执行过程 := 5; --已审核
    Elsif 状态_In = 15 Then
      v_执行状态 := 1; --完全执行
      v_执行过程 := 6; --已完成
      v_完成人   := 操作人员_In;
      v_完成时间 := 执行时间_In;
    End If;
  
    n_执行 := 1; --默认都要更新状态
  
    If 状态_In = 13 Or 状态_In = 14 Then
      --删除对应报告数据
      Delete From 电子病历记录
       Where ID = (Select 病历id
                     From 病人医嘱报告
                    Where 医嘱id = 医嘱id_In
                      And Risid = Risid_In);
      Delete From 病人医嘱报告
       Where 医嘱id = 医嘱id_In
         And Risid = Risid_In;
    
      --删除后判断是否还存在报告，若存在则医嘱状态保持不变，若报告全部删除则更新医嘱状态
      Select Count(1)
        Into v_Count
        From 病人医嘱报告
       Where 医嘱id = 医嘱id_In;
    
      If v_Count > 0 Then
        n_执行 := 0; --若存在则医嘱状态保持不变
      End If;
    End If;
  
    --开始执行医嘱
    If n_执行 = 1 Then
      If Nvl(单独执行_In, 0) = 1 Then
        -- 单个部位医嘱单独执行
        Update 病人医嘱发送
           Set 执行状态 = v_执行状态,
               执行过程 = v_执行过程,
               执行说明 = 执行说明_In,
               完成人   = v_完成人,
               完成时间 = v_完成时间
         Where 医嘱id = 医嘱id_In;
      Else
        Update 病人医嘱发送
           Set 执行状态 = v_执行状态,
               执行过程 = v_执行过程,
               执行说明 = 执行说明_In,
               完成人   = v_完成人,
               完成时间 = v_完成时间
         Where 医嘱id In
               (Select ID
                  From 病人医嘱记录
                 Where (ID = r_Adviceinfo.组id Or 相关id = r_Adviceinfo.组id));
      End If;
    End If;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End Receiverisstate;

  --2、费用确认
  Procedure 影像费用执行(医嘱id_In     影像检查记录.医嘱id%Type,
                   单独执行_In   Number := 0,
                   操作员编号_In 人员表.编号%Type := Null,
                   操作员姓名_In 人员表.姓名%Type := Null,
                   执行部门id_In 门诊费用记录.执行部门id%Type := Null) Is
    --参数：医嘱ID_IN=单独执行的医嘱ID。
    --      单独执行_In=检查医嘱组合是否采用对每个项目分散单独执行的方式,0-不单独执行
    Cursor c_Advice Is
      Select ID, 相关id, Nvl(相关id, ID) As 组id, 诊疗类别, 病人来源
        From 病人医嘱记录
       Where ID = 医嘱id_In;
    r_Advice c_Advice%RowType;
  
    v_Temp     Varchar2(255);
    v_人员编号 人员表.编号%Type;
    v_人员姓名 人员表.姓名%Type;
    v_部门id   部门表.Id%Type;
    v_费用性质 病人医嘱发送.记录性质%Type;
    v_发送号   病人医嘱发送.发送号%Type;
    v_执行过程 病人医嘱发送.执行过程%Type;
    v_Count    Number;
    v_Error    Varchar2(255);
    Err_Custom Exception;
  Begin
  
    --取主医嘱ID
    Open c_Advice;
    Fetch c_Advice
      Into r_Advice;
    Close c_Advice;
  
    Select 发送号, 执行过程
      Into v_发送号, v_执行过程
      From 病人医嘱发送
     Where 医嘱id = r_Advice.组id;
  
    --登记和完成才执行费用  2-登记，3-检查，4-报告，5-审核，6-完成
    If v_执行过程 >= 2 Or v_执行过程 <= 6 Then
    
      --先检查是否已经出院的住院病人，已经预出院或者出院的检查申请，不允执行费用
      Select Count(*)
        Into v_Count
        From 病人医嘱记录 A, 病案主页 B
       Where a.病人id = b.病人id
         And a.主页id = b.主页id
         And (b.出院日期 Is Not Null Or b.状态 = 3)
         And a.Id = r_Advice.组id;
    
      If v_Count > 0 Then
        v_Error := '住院病人已经出院或者预出院，不能执行费用。';
        Raise Err_Custom;
      End If;
    
      --取当前操作人员
      If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null And
         执行部门id_In Is Not Null Then
        v_人员编号 := 操作员编号_In;
        v_人员姓名 := 操作员姓名_In;
        v_部门id   := 执行部门id_In;
      Else
        v_Temp     := Zl_Identity;
        v_部门id   := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
        v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
        v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
      End If;
    
      If r_Advice.病人来源 = 2 Then
        Select Decode(记录性质, 1, 1, Decode(门诊记帐, 1, 1, 2))
          Into v_费用性质
          From 病人医嘱发送
         Where 发送号 = v_发送号
           And 医嘱id = 医嘱id_In;
      Else
        v_费用性质 := 1;
      End If;
    
      --执行费用和自动发料
      If v_费用性质 = 1 Then
        Zl_门诊医嘱执行_Finish(医嘱id_In,
                         v_发送号,
                         单独执行_In,
                         v_人员编号,
                         v_人员姓名,
                         r_Advice.组id,
                         r_Advice.诊疗类别,
                         v_部门id);
      Else
        Zl_住院医嘱执行_Finish(医嘱id_In,
                         v_发送号,
                         单独执行_In,
                         v_人员编号,
                         v_人员姓名,
                         r_Advice.组id,
                         r_Advice.诊疗类别,
                         v_部门id);
      End If;
    End If;
  
  Exception
    When Err_Custom Then
      Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End 影像费用执行;

  --3、取消费用确认
  Procedure 影像费用执行_Cancel(医嘱id_In     影像检查记录.医嘱id%Type,
                          单独执行_In   Number := 0,
                          操作员编号_In 人员表.编号%Type := Null,
                          操作员姓名_In 人员表.姓名%Type := Null,
                          执行部门id_In 门诊费用记录.执行部门id%Type := Null) Is
    --参数：
    --      医嘱ID_IN=单独执行的医嘱ID。
    --      单独执行_In=检查医嘱组合是否采用对每个项目分散单独执行的方式,0-不单独执行
  
    Cursor c_Advice Is
      Select ID, 相关id, Nvl(相关id, ID) As 组id
        From 病人医嘱记录
       Where ID = 医嘱id_In;
    r_Advice c_Advice%RowType;
  
    v_发送号 病人医嘱发送.发送号%Type;
    v_Count  Number;
    v_Error  Varchar2(255);
    Err_Custom Exception;
  
  Begin
  
    --取主医嘱ID
    Open c_Advice;
    Fetch c_Advice
      Into r_Advice;
    Close c_Advice;
  
    --先检查是否已经出院的住院病人，已经预出院或者出院的检查申请，不允执行费用
    Select Count(*)
      Into v_Count
      From 病人医嘱记录 A, 病案主页 B
     Where a.病人id = b.病人id
       And a.主页id = b.主页id
       And (b.出院日期 Is Not Null Or b.状态 = 3)
       And a.Id = r_Advice.组id;
  
    If v_Count > 0 Then
      v_Error := '住院病人已经出院或者预出院，不能取消费用。';
      Raise Err_Custom;
    End If;
  
    Select 发送号
      Into v_发送号
      From 病人医嘱发送
     Where 医嘱id = r_Advice.组id;
  
    --调用统一的医嘱执行Cancel过程
    Zl_病人医嘱执行_Cancel(医嘱id_In,
                     v_发送号,
                     Null,
                     单独执行_In,
                     执行部门id_In,
                     操作员编号_In,
                     操作员姓名_In);
  
  Exception
    When Err_Custom Then
      Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End 影像费用执行_Cancel;

  --4、接收RIS的报告
  Procedure Receivereport(医嘱id_In   病人医嘱发送.医嘱id%Type,
                          Risid_In    病人医嘱报告.Risid%Type,
                          报告所见_In 电子病历内容.内容文本%Type,
                          报告意见_In 电子病历内容.内容文本%Type,
                          报告建议_In 电子病历内容.内容文本%Type,
                          报告医生_In 电子病历记录.创建人%Type) Is
    --提取病人医嘱及报告的相关信息
    Cursor c_Advice(v_组id Number, v_Risid Number) Is
      Select e.Id,
             e.病人来源,
             e.病人id,
             e.主页id,
             e.婴儿,
             e.病人科室id,
             e.文件id,
             e.病历种类,
             e.病历名称,
             f.病历id,
             e.执行科室id
        From (Select c.Id,
                     c.病人来源,
                     c.病人id,
                     c.主页id,
                     c.婴儿,
                     c.病人科室id,
                     c.文件id,
                     d.种类       病历种类,
                     d.名称       病历名称,
                     c.执行科室id
                From (Select a.Id,
                             a.病人来源,
                             a.病人id,
                             a.主页id,
                             a.婴儿,
                             a.病人科室id,
                             b.病历文件id 文件id,
                             a.执行科室id
                        From 病人医嘱记录 A, 病历单据应用 B
                       Where a.Id = v_组id
                         And a.诊疗项目id = b.诊疗项目id(+)
                         And b.应用场合(+) = Decode(a.病人来源, 2, 2, 4, 4, 1)) C,
                     病历文件列表 D
               Where c.文件id = d.Id(+)) E,
             病人医嘱报告 F
       Where e.Id = f.医嘱id(+)
         And f.Risid(+) = v_Risid;
  
    --查找文件的组成元素
    Cursor c_File(v_File Number) Is
      Select a.Id,
             a.文件id,
             a.父id,
             a.对象序号,
             a.对象类型,
             a.对象标记,
             a.保留对象,
             a.对象属性,
             a.内容行次,
             a.内容文本,
             a.是否换行,
             a.预制提纲id,
             a.复用提纲,
             a.使用时机,
             a.诊治要素id,
             a.替换域,
             a.要素名称,
             a.要素类型,
             a.要素长度,
             a.要素小数,
             a.要素单位,
             a.要素表示,
             a.输入形态,
             a.要素值域
        From 病历文件结构 A
       Where a.文件id = v_File
       Order By a.对象序号;
  
    Cursor c_Report(v_电子病历记录id Number) Is
      Select b.Id, a.内容文本
        From 电子病历内容 A, 电子病历内容 B
       Where a.对象类型 = 3
         And a.Id = b.父id
         And b.对象类型 = 2
         And b.终止版 = 0
         And a.文件id = v_电子病历记录id;
  
    Cursor c_Content(v_文件id Number, v_表格id Number) Is
      Select a.Id,
             a.文件id,
             a.父id,
             a.对象序号,
             a.对象类型,
             a.对象标记,
             a.保留对象,
             a.对象属性,
             a.内容行次,
             a.内容文本,
             a.是否换行,
             a.预制提纲id,
             a.复用提纲,
             a.使用时机,
             a.诊治要素id,
             a.替换域,
             a.要素名称,
             a.要素类型,
             a.要素长度,
             a.要素小数,
             a.要素单位,
             a.要素表示,
             a.输入形态,
             a.要素值域
        From 病历文件结构 A
       Where 文件id = v_文件id
         And 父id = v_表格id;
  
    r_Advice        c_Advice%RowType;
    v_病历id        电子病历内容.文件id%Type;
    v_病历内容id    电子病历内容.Id%Type;
    v_病历内容idnew 电子病历内容.Id%Type;
    v_对象序号      电子病历内容.对象序号%Type;
    v_父id          电子病历内容.父id%Type;
    v_内容文本      电子病历内容.内容文本%Type;
    v_定义提纲id    电子病历内容.定义提纲id%Type;
    --v_格式内容    电子病历格式.内容%Type;
    v_Error Varchar2(255);
    Err_Custom Exception;
    v_主医嘱id 病人医嘱发送.医嘱id%Type;
    v_表格     Varchar2(300);
    n_数量     Number;
    n_rptCount Number;
    v_病历名称 电子病历记录.病历名称%Type;
  
    Function GetRptNo(v_医嘱IDIn   病人医嘱发送.医嘱id%Type,
                      v_病历名称In 电子病历记录.病历名称%Type) return varchar as
      v_return number;
      v_No     number;
      v_Count  number;
    begin
      Select count(医嘱id) + 1
        into v_No
        from 病人医嘱报告
       where 医嘱ID = v_医嘱IDIn;
      v_count := 1;
      while v_count = 1 loop
        Select count(id)
          into v_count
          from 病人医嘱报告 a, 电子病历记录 b
         where a.医嘱id = v_医嘱IDIn
           and a.病历id = b.id
           and b.病历名称 = v_病历名称In || v_no;
        if v_count = 1 then
          v_no := v_no + 1;
        end if;
      end loop;
      v_return := v_No;
      return v_return;
    end GetRptNo;
  
  Begin
  
    -- 提取主医嘱ID ，防止因为传入部位医嘱，导致报告保存出错
    Select Nvl(相关id, ID) As 组id
      Into v_主医嘱id
      From 病人医嘱记录
     Where ID = 医嘱id_In;
  
    Open c_Advice(v_主医嘱id, Nvl(Risid_In, 0));
    Fetch c_Advice
      Into r_Advice;
  
    If Nvl(r_Advice.文件id, 0) = 0 Then
      v_Error := '本次检查项目没有对应相关的检查报告，请与管理员联系！';
      Raise Err_Custom;
    Else
      If Nvl(r_Advice.病历id, 0) > 0 Then
        ----产生过报告
        --找出检查已填写的报告提纲中含有"%所见%","%描述%","%建议%","%意见%",并用传入的参数更新
        For r_Report In c_Report(r_Advice.病历id) Loop
          If r_Report.内容文本 Like '%所见%' Then
            Update 电子病历内容
               Set 内容文本 = 报告所见_In || Chr(13) || Chr(13)
             Where ID = r_Report.Id;
          Elsif r_Report.内容文本 Like '%意见%' Then
            Update 电子病历内容
               Set 内容文本 = 报告意见_In || Chr(13) || Chr(13)
             Where ID = r_Report.Id;
          Elsif r_Report.内容文本 Like '%建议%' Then
            Update 电子病历内容
               Set 内容文本 = 报告建议_In || Chr(13) || Chr(13)
             Where ID = r_Report.Id;
          End If;
        End Loop;
        --更新保存时间
        Update 电子病历记录
           Set 完成时间 = Sysdate, 保存人 = 报告医生_In, 保存时间 = Sysdate
         Where ID = r_Advice.病历id;
      Else
        --先判断单据中是否有对应的提纲和表格
        If Nvl(报告所见_In, ' ') <> ' ' Then
          Select Count(1)
            Into n_数量
            From 病历文件结构 A, 病历文件结构 B
           Where a.父id = b.Id
             And a.对象类型 = 3
             And b.对象类型 = 1
             And a.内容文本 Like '%所见%'
             And a.文件id = r_Advice.文件id;
        
          If n_数量 <= 0 Then
            v_Error := '在诊疗单据中没有找到【所见】对应的提纲或表格，请联系管理员设置！';
            Raise Err_Custom;
          End If;
        End If;
        If Nvl(报告意见_In, ' ') <> ' ' Then
          Select Count(1)
            Into n_数量
            From 病历文件结构 A, 病历文件结构 B
           Where a.父id = b.Id
             And a.对象类型 = 3
             And b.对象类型 = 1
             And a.内容文本 Like '%意见%'
             And a.文件id = r_Advice.文件id;
        
          If n_数量 <= 0 Then
            v_Error := '在诊疗单据中没有找到【意见】对应的提纲或表格，请联系管理员设置！';
            Raise Err_Custom;
          End If;
        End If;
        If Nvl(报告建议_In, ' ') <> ' ' Then
          Select Count(1)
            Into n_数量
            From 病历文件结构 A, 病历文件结构 B
           Where a.父id = b.Id
             And a.对象类型 = 3
             And b.对象类型 = 1
             And a.内容文本 Like '%建议%'
             And a.文件id = r_Advice.文件id;
        
          If n_数量 <= 0 Then
            v_Error := '在诊疗单据中没有找到【建议】对应的提纲或表格，请联系管理员设置！';
            Raise Err_Custom;
          End If;
        End If;
      
        --产生电子病历记录
        Select 电子病历记录_Id.Nextval Into v_病历id From Dual;
        n_rptCount := GetRptNo(医嘱id_In, r_Advice.病历名称);
        if n_rptCount > 1 then
          v_病历名称 := r_Advice.病历名称 || n_rptCount;
        else
          v_病历名称 := r_Advice.病历名称;
        end if;
        Insert Into 电子病历记录
          (ID,
           病人来源,
           病人id,
           主页id,
           婴儿,
           科室id,
           病历种类,
           文件id,
           病历名称,
           创建人,
           创建时间,
           完成时间,
           保存人,
           保存时间,
           最后版本,
           签名级别)
        Values
          (v_病历id,
           r_Advice.病人来源,
           r_Advice.病人id,
           r_Advice.主页id,
           r_Advice.婴儿,
           r_Advice.病人科室id,
           r_Advice.病历种类,
           r_Advice.文件id,
           v_病历名称,
           报告医生_In,
           Sysdate,
           Sysdate,
           报告医生_In,
           Sysdate,
           1,
           2);
      
        --产生医嘱报告记录
        Insert Into 病人医嘱报告
          (医嘱id, 病历id, Risid)
        Values
          (v_主医嘱id, v_病历id, Risid_In);
      
        v_对象序号 := 0;
      
        --新产生报告内容
        For r_File In c_File(r_Advice.文件id) Loop
          Select 电子病历内容_Id.Nextval Into v_病历内容id From Dual;
          v_内容文本   := r_File.内容文本;
          v_定义提纲id := 0;
        
          If Nvl(r_File.对象类型, 0) = 1 And Nvl(r_File.父id, 0) = 0 Then
            --提纲
            v_定义提纲id := r_File.Id;
            v_父id       := v_病历内容id;
          End If;
        
          If Nvl(r_File.对象类型, 0) = 4 And r_File.要素名称 Is Not Null Then
            --元素
            v_内容文本 := Zl_Replace_Element_Value(r_File.要素名称,
                                               r_Advice.病人id,
                                               r_Advice.主页id,
                                               r_Advice.病人来源,
                                               r_Advice.Id);
          End If;
        
          If Nvl(r_File.父id, 0) <> 0 Then
            v_定义提纲id := 0;
          End If;
        
          v_对象序号 := v_对象序号 + 1;
        
          If Instr(v_表格, '|' || r_File.父id || '|') > 0 Then
            Null;
          Else
            Insert Into 电子病历内容
              (ID,
               文件id,
               开始版,
               终止版,
               父id,
               对象序号,
               对象类型,
               对象标记,
               保留对象,
               对象属性,
               内容行次,
               内容文本,
               是否换行,
               预制提纲id,
               复用提纲,
               使用时机,
               诊治要素id,
               替换域,
               要素名称,
               要素类型,
               要素长度,
               要素小数,
               要素单位,
               要素表示,
               输入形态,
               要素值域,
               定义提纲id)
            Values
              (v_病历内容id,
               v_病历id,
               1,
               0,
               Decode(v_定义提纲id, 0, v_父id, Null),
               v_对象序号,
               r_File.对象类型,
               r_File.对象标记,
               r_File.保留对象,
               r_File.对象属性,
               Null,
               v_内容文本,
               r_File.是否换行,
               r_File.预制提纲id,
               r_File.复用提纲,
               r_File.使用时机,
               r_File.诊治要素id,
               r_File.替换域,
               r_File.要素名称,
               r_File.要素类型,
               r_File.要素长度,
               r_File.要素小数,
               r_File.要素单位,
               r_File.要素表示,
               r_File.输入形态,
               r_File.要素值域,
               Decode(v_定义提纲id, 0, Null, v_定义提纲id));
          End If;
        
          --为表格时，插入文本内容
          If Nvl(r_File.对象类型, 0) = 3 And Nvl(r_File.父id, 0) <> 0 Then
            v_表格 := v_表格 || ',|' || r_File.Id || '|';
          
            If r_File.内容文本 Like '%所见%' Then
              v_内容文本 := 报告所见_In || Chr(13) || Chr(13);
            Elsif r_File.内容文本 Like '%意见%' Then
              v_内容文本 := 报告意见_In || Chr(13) || Chr(13);
            Else
              v_内容文本 := 报告建议_In || Chr(13) || Chr(13);
            End If;
          
            For r_Con In c_Content(r_Advice.文件id, r_File.Id) Loop
              Select 电子病历内容_Id.Nextval
                Into v_病历内容idnew
                From Dual;
              v_对象序号 := v_对象序号 + 1;
            
              Insert Into 电子病历内容
                (ID,
                 文件id,
                 开始版,
                 终止版,
                 父id,
                 对象序号,
                 对象类型,
                 对象标记,
                 保留对象,
                 对象属性,
                 内容行次,
                 内容文本,
                 是否换行,
                 预制提纲id,
                 复用提纲,
                 使用时机,
                 诊治要素id,
                 替换域,
                 要素名称,
                 要素类型,
                 要素长度,
                 要素小数,
                 要素单位,
                 要素表示,
                 输入形态,
                 要素值域,
                 定义提纲id)
              Values
                (v_病历内容idnew,
                 v_病历id,
                 1,
                 0,
                 v_病历内容id,
                 v_对象序号,
                 2,
                 r_Con.对象标记,
                 r_Con.保留对象,
                 r_Con.对象属性,
                 Null,
                 v_内容文本,
                 r_Con.是否换行,
                 r_Con.预制提纲id,
                 r_Con.复用提纲,
                 r_Con.使用时机,
                 r_Con.诊治要素id,
                 r_Con.替换域,
                 r_Con.要素名称,
                 r_Con.要素类型,
                 r_Con.要素长度,
                 r_Con.要素小数,
                 r_Con.要素单位,
                 r_Con.要素表示,
                 r_Con.输入形态,
                 r_Con.要素值域,
                 Decode(v_定义提纲id, 0, Null, v_定义提纲id));
            End Loop;
          End If;
        End Loop;
      
        --因电子病历格式中含了内容文字格式，此种方法导入之后内容文字将不可见
        --Select 内容 Into v_格式内容 From 病历文件格式 Where 文件ID=r_Advice.文件ID;
        --Insert Into 电子病历格式 (文件ID,内容) Values (v_病历id,v_格式内容);
      
      End If;
    End If;
    Close c_Advice;
  
  Exception
    When Err_Custom Then
      Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End Receivereport;

  --5、修改申请单信息
  Procedure 影像病人信息_修改(医嘱id_In       病人医嘱记录.Id%Type,
                      姓名_In         病人信息.姓名%Type,
                      性别_In         病人信息.性别%Type,
                      年龄_In         病人信息.年龄%Type,
                      费别_In         病人信息.费别%Type,
                      医疗付款方式_In 病人信息.医疗付款方式%Type,
                      民族_In         病人信息.民族%Type,
                      婚姻_In         病人信息.婚姻状况%Type,
                      职业_In         病人信息.职业%Type,
                      身份证号_In     病人信息.身份证号%Type,
                      家庭地址_In     病人信息.家庭地址%Type,
                      家庭电话_In     病人信息.家庭电话%Type,
                      家庭地址邮编_In 病人信息.家庭地址邮编%Type,
                      出生日期_In     病人信息.出生日期%Type := Null) As
  
    v_年龄     Varchar2(20);
    v_年龄单位 Varchar2(20);
    v_出生日期 Date;
    v_病人来源 病人医嘱记录.病人来源%Type;
    v_病人id   病人医嘱记录.病人id%Type;
  Begin
    Begin
      Select 病人来源, 病人id
        Into v_病人来源, v_病人id
        From 病人医嘱记录
       Where ID = 医嘱id_In;
    Exception
      When Others Then
        Return;
    End;
  
    If 出生日期_In Is Null And 年龄_In Is Not Null Then
      --根据年龄求出生日期
      v_年龄单位 := Substr(年龄_In, Length(年龄_In), 1);
      If Instr('岁,月,天', v_年龄单位) <= 0 Then
        v_年龄单位 := Null;
      Else
        v_年龄 := Replace(年龄_In, v_年龄单位, '');
      End If;
      Begin
        v_年龄 := To_Number(v_年龄);
      Exception
        When Others Then
          v_年龄 := Null;
      End;
      If v_年龄 Is Not Null And v_年龄单位 Is Not Null Then
        Select Decode(v_年龄单位,
                      '岁',
                      Add_Months(Sysdate, -12 * v_年龄),
                      '月',
                      Add_Months(Sysdate, -1 * v_年龄),
                      '天',
                      Sysdate - v_年龄)
          Into v_出生日期
          From Dual;
      End If;
    Else
      v_出生日期 := 出生日期_In;
    End If;
  
    If v_病人来源 = 3 Then
      Update 病人信息
         Set 姓名         = 姓名_In,
             性别         = Nvl(性别_In, 性别),
             年龄         = 年龄_In,
             出生日期     = v_出生日期,
             费别         = Nvl(费别_In, 费别),
             医疗付款方式 = Nvl(医疗付款方式_In, 医疗付款方式),
             民族         = Nvl(民族_In, 民族),
             婚姻状况     = Nvl(婚姻_In, 婚姻状况),
             职业         = Nvl(职业_In, 职业),
             身份证号     = 身份证号_In,
             家庭地址     = 家庭地址_In,
             家庭电话     = 家庭电话_In,
             家庭地址邮编 = 家庭地址邮编_In
       Where 病人id = v_病人id;
    
      --修改对应的医嘱记录
      Update 病人医嘱记录
         Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In
       Where ID = 医嘱id_In
          Or 相关id = 医嘱id_In;
    Else
      Update 病人信息
         Set 民族         = Nvl(民族_In, 民族),
             婚姻状况     = Nvl(婚姻_In, 婚姻状况),
             职业         = Nvl(职业_In, 职业),
             家庭地址     = 家庭地址_In,
             家庭电话     = 家庭电话_In,
             家庭地址邮编 = 家庭地址邮编_In
       Where 病人id = v_病人id;
    End If;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End 影像病人信息_修改;

  --6、取消申请单信息
  Procedure 取消检查申请单(医嘱id_In     病人医嘱执行.医嘱id%Type,
                    操作员编号_In 人员表.编号%Type := Null,
                    操作员姓名_In 人员表.姓名%Type := Null,
                    执行部门id_In 门诊费用记录.执行部门id%Type := 0,
                    拒绝原因_In   病人医嘱发送.执行说明%Type := Null) As
    --参数：医嘱ID_IN=单独执行的医嘱ID
  
    v_发送号 病人医嘱执行.发送号%Type;
  
  Begin
  
    Begin
      Select 发送号
        Into v_发送号
        From 病人医嘱发送
       Where 医嘱id = 医嘱id_In;
    Exception
      When Others Then
        Return;
    End;
  
    Zl_病人医嘱执行_拒绝执行(医嘱id_In,
                   v_发送号,
                   操作员编号_In,
                   操作员姓名_In,
                   执行部门id_In,
                   拒绝原因_In);
  
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End 取消检查申请单;

  --7、插入医嘱操作失败记录
  Procedure RIS医嘱失败记录_Insert(病人来源_In   In RIS医嘱失败记录.病人来源%Type,
                             病人ID_In     In RIS医嘱失败记录.病人ID%Type,
                             主页ID_In     In RIS医嘱失败记录.主页ID%Type,
                             挂号单号_In   In RIS医嘱失败记录.挂号单号%Type,
                             发送号_In     In RIS医嘱失败记录.发送号%Type,
                             体检任务ID_In In RIS医嘱失败记录.体检任务ID%Type,
                             体检报到号_In In RIS医嘱失败记录.体检报到号%Type,
                             发送类型_In   In RIS医嘱失败记录.发送类型%Type) Is
  Begin
    Insert Into RIS医嘱失败记录
      (ID,
       病人来源,
       病人ID,
       主页ID,
       挂号单号,
       发送号,
       体检任务ID,
       体检报到号,
       发送类型,
       发送时间,
       重发次数)
    Values
      (RIS医嘱失败记录_Id.Nextval,
       病人来源_In,
       病人ID_In,
       主页ID_In,
       挂号单号_In,
       发送号_In,
       体检任务ID_In,
       体检报到号_In,
       发送类型_In,
       sysdate,
       0);
  
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End RIS医嘱失败记录_Insert;

  --8、更新医嘱操作失败记录
  Procedure RIS医嘱失败记录_重发(ID_In       In RIS医嘱失败记录.ID%Type,
                         操作类型_In In Number) Is
    v_重发次数 RIS医嘱失败记录.重发次数%Type;
  Begin
    --操作类型_In -- 1 重发成功，删除记录；2--重发失败
  
    if 操作类型_In = 1 then
      delete from RIS医嘱失败记录 where ID = ID_In;
    else
      select 重发次数
        into v_重发次数
        from RIS医嘱失败记录
       where ID = ID_In;
      if v_重发次数 >= 99 then
        v_重发次数 := 99;
      else
        v_重发次数 := v_重发次数 + 1;
      end if;
      update RIS医嘱失败记录
         set 发送时间 = sysdate, 重发次数 = v_重发次数
       where ID = ID_In;
    end if;
  
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End RIS医嘱失败记录_重发;

  --9、销账后新建住院记账单据
  Procedure 病人医嘱_重建单据(医嘱ID_In In 病人医嘱发送.医嘱ID%Type,
                      No_In     In 病人医嘱发送.No%Type,
                      Action_In In number) Is
    -- Action_In: 1 重建单据；2 取消重建单据
    v_No 病人医嘱发送.no%Type;
  Begin
    if Action_In = 1 then
      select NextNo(14) into v_No from dual;
    
      update 病人医嘱发送
         set no = v_No, 计费状态 = 0
       where 医嘱ID in (select id
                        from 病人医嘱记录
                       where id = 医嘱ID_In
                          or 相关ID = 医嘱ID_In);
      update 住院费用记录 set 医嘱序号 = null where no = No_In;
    elsif Action_In = 2 then
      update 住院费用记录 set 医嘱序号 = 医嘱ID_In where no = No_In;
      update 病人医嘱发送
         set no = No_In, 计费状态 = 4
       where 医嘱ID in (select id
                        from 病人医嘱记录
                       where id = 医嘱ID_In
                          or 相关ID = 医嘱ID_In);
    end if;
  
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End 病人医嘱_重建单据;

  --10、打印RIS检查预约通知单
  Procedure RIS检查预约_打印(医嘱ID_In In RIS检查预约.医嘱ID%Type) Is
  Begin
    Update RIS检查预约 SET 是否打印 = 1 where 医嘱ID = 医嘱ID_In;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End RIS检查预约_打印;

  --11、更新RIS分科室启用参数
  Procedure RIS启用控制_Update(检查类型_In RIS启用控制.检查类型%Type,
                           场合_In     RIS启用控制.场合%Type,
                           部门ids_In  Varchar2,
                           启用类型_In Number) Is
  
    l_部门id   t_Numlist := t_Numlist();
    v_启用RIS  RIS启用控制.是否启用RIS%Type;
    v_启用预约 RIS启用控制.是否启用预约%Type;
  
    Cursor c_Dept(Dept_In Varchar2) Is
      Select Column_Value From Table(f_Num2list(Dept_In));
  Begin
  
    if 启用类型_In = 1 then
      v_启用RIS  := 1;
      v_启用预约 := null;
      Delete From RIS启用控制
       Where 检查类型 = 检查类型_In
         and 场合 = 场合_In
         and 是否启用RIS = 1;
    else
      v_启用RIS  := null;
      v_启用预约 := 1;
      Delete From RIS启用控制
       Where 检查类型 = 检查类型_In
         and 场合 = 场合_In
         and 是否启用预约 = 1;
    end if;
  
    if 部门ids_In is null then
      Insert Into RIS启用控制
        (ID, 检查类型, 场合, 部门id, 是否启用RIS, 是否启用预约)
      Values
        (ris启用控制_id.nextval,
         检查类型_In,
         场合_In,
         null,
         v_启用RIS,
         v_启用预约);
    else
      Open c_Dept(部门ids_In);
      Fetch c_Dept Bulk Collect
        Into l_部门id;
      Close c_Dept;
    
      Forall I In 1 .. l_部门id.Count
        Insert Into RIS启用控制
          (ID, 检查类型, 场合, 部门id, 是否启用RIS, 是否启用预约)
        Values
          (ris启用控制_id.nextval,
           检查类型_In,
           场合_In,
           l_部门id(I),
           v_启用RIS,
           v_启用预约);
    end if;
  
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End RIS启用控制_Update;

  --12、删除RIS分科室启用参数
  Procedure RIS启用控制_Delete Is
  
  Begin
    Delete From RIS启用控制;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End RIS启用控制_Delete;

  --13、根据元素名提取信息
  Function RIS_Replace_Element_Value(元素名_In   In 诊治所见项目.中文名%Type,
                                     病人id_In   In 电子病历记录.病人id%Type,
                                     就诊id_In   In 电子病历记录.主页id%Type,
                                     病人来源_In In 电子病历记录.病人来源%Type,
                                     医嘱id_In   In 病人医嘱发送.医嘱Id%Type)
    Return Varchar2 Is
    v_Return Varchar2(4000) := Null;
    Cursor c_Patient Is
      Select 姓名,
             性别,
             Decode(性别, '男', 'M', '女', 'F', 'O') As 性别编码,
             出生日期,
             病人ID,
             联系人地址,
             家庭电话,
             联系人电话,
             婚姻状况,
             身份证号,
             当前科室ID,
             当前病区ID,
             当前床号 as 床号,
             就诊卡号,
             入院时间,
             出院时间
        From 病人信息
       Where 病人ID = 病人id_In;
    r_Patient c_Patient%RowType;
  
    Cursor c_Order Is
      Select 主页ID,
             婴儿,
             decode(病人来源, 1, 'OUTPAT', 2, 'INPAT', 'UNK') as 病人来源,
             开嘱医生,
             开嘱时间,
             校对护士,
             医嘱内容,
             紧急标志,
             执行科室ID
        From 病人医嘱记录
       Where Id = 医嘱id_In;
    r_Order c_Order%Rowtype;
  
    Cursor c_Diagnose Is
      Select 诊断描述 || Decode(Nvl(是否疑诊, 0), 0, '', ' (？)') As 临床诊断
        From 病人诊断医嘱 a, 病人诊断记录 b
       Where a.医嘱ID = 医嘱id_In
         And a.诊断ID = b.id;
    r_Diagnose c_Diagnose%Rowtype;
  
    --获取指定表的行类型  
    Procedure p_Get_Rowtype(Table_In In Varchar2) Is
    Begin
      If Table_In = '病人信息' Then
        Open c_Patient;
        Fetch c_Patient
          Into r_Patient;
      Elsif Table_In = '病人医嘱记录' Then
        Open c_Order;
        Fetch c_Order
          Into r_Order;
      Elsif Table_In = '病人诊断记录' Then
        Open c_Diagnose;
        Fetch c_Diagnose
          Into r_Diagnose;
      End If;
    Exception
      When Others Then
        Null;
    End p_Get_Rowtype;
  
  Begin
    Case
    --直接返回的输入元素
      When 元素名_In = '医嘱ID' Then
        v_Return := 医嘱id_In;
      When 元素名_In = '病人ID' Then
        v_Return := 病人id_In;
      
    --姓名，性别单独处理，可能是婴儿
      When Instr(',姓名,性别,性别编码,出生日期,', ',' || 元素名_In || ',') > 0 Then
        p_Get_Rowtype('病人医嘱记录');
        p_Get_Rowtype('病人信息');
        If Nvl(r_Order.婴儿, 0) = 0 Then
          If 元素名_In = '姓名' Then
            v_Return := r_Patient.姓名;
          Elsif 元素名_In = '性别' Then
            v_Return := r_Patient.性别;
          Elsif 元素名_In = '性别编码' Then
            v_Return := r_Patient.性别编码;
          Elsif 元素名_In = '出生日期' Then
            v_Return := To_Char(r_Patient.出生日期, 'YYYYMMDDMISS');
          End If;
        Else
          If 元素名_In = '姓名' Then
            Select Decode(婴儿姓名,
                          Null,
                          r_Patient.姓名 || '之婴' || Trim(To_Char(序号, '9')),
                          婴儿姓名) As 婴儿姓名
              Into v_Return
              From 病人新生儿记录
             Where 病人id = 病人id_In
               And 主页id = r_Order.主页ID
               And 序号 = Nvl(r_Order.婴儿, 0);
          Elsif Instr('性别', 元素名_In) > 0 Then
            Select 婴儿性别
              Into v_Return
              From 病人新生儿记录
             Where 病人id = 病人id_In
               And 主页id = r_Order.主页ID
               And 序号 = Nvl(r_Order.婴儿, 0);
            If 元素名_In = '性别编码' Then
              Select Decode(v_Return, '男', 'M', '女', 'F', 'O')
                Into v_Return
                From dual;
            End If;
          Elsif 元素名_In = '出生日期' Then
            Select 出生时间
              Into v_Return
              From 病人新生儿记录
             Where 病人id = 病人id_In
               And 主页id = r_Order.主页ID
               And 序号 = Nvl(r_Order.婴儿, 0);
            v_Return := To_Char(v_Return, 'YYYYMMDDMISS');
          End If;
        End If;
      
    --查询病人信息表返回的元素
      When Instr(',联系人地址,家庭电话,联系人电话,婚姻状况,身份证号,床号,就诊卡号,入院时间,出院时间,',
                 ',' || 元素名_In || ',') > 0 Then
        p_Get_Rowtype('病人信息');
        Case 元素名_In
          When '联系人地址' Then
            v_Return := r_Patient.联系人地址;
          When '家庭电话' Then
            v_Return := r_Patient.家庭电话;
          When '联系人电话' Then
            v_Return := r_Patient.联系人电话;
          When '婚姻状况' Then
            v_Return := r_Patient.婚姻状况;
          When '身份证号' Then
            v_Return := r_Patient.身份证号;
          When '床号' Then
            v_Return := r_Patient.床号;
          When '就诊卡号' Then
            v_Return := r_Patient.就诊卡号;
          When '入院时间' Then
            v_Return := To_Char(r_Patient.入院时间, 'YYYYMMDDMISS');
          When '出院时间' Then
            v_Return := To_Char(r_Patient.出院时间, 'YYYYMMDDMISS');
          Else
            v_Return := '';
        End Case;
        --查询医嘱表返回的元素
      When instr(',病人来源,开嘱医生,开嘱时间,校对护士,医嘱内容,紧急标志,紧急标志对码,',
                 ',' || 元素名_In || ',') > 0 Then
        p_Get_Rowtype('病人医嘱记录');
        Case 元素名_In
          When '病人来源' Then
            v_Return := r_Order.病人来源;
          When '开嘱医生' Then
            v_Return := r_Order.开嘱医生;
          When '开嘱时间' Then
            v_Return := To_Char(r_Order.开嘱时间, 'YYYYMMDDMISS');
          When '校对护士' Then
            v_Return := r_Order.校对护士;
          When '医嘱内容' Then
            v_Return := r_Order.医嘱内容;
          When '紧急标志' Then
            v_Return := r_Order.紧急标志;
        End Case;
        --查询诊断记录返回的元素
      When 元素名_In = '临床诊断' Then
        p_Get_Rowtype('病人诊断记录');
        v_Return := r_Diagnose.临床诊断;
      
      Else
        --自行查询SQL返回值的元素  
        If 元素名_In = '执行站点' Then
          p_Get_Rowtype('病人医嘱记录');
          Select decode(站点,
                        1,
                        'SITE0002',
                        2,
                        'SITE0001',
                        3,
                        'SITE0003',
                        'SITE0001')
            Into v_Return
            From 部门表
           Where id = r_Order.执行科室ID;
        End If;
        If 元素名_In = '当前科室名称' Then
          p_Get_Rowtype('病人信息');
          Select 名称
            Into v_Return
            From 部门表
           Where id = r_Patient.当前科室ID;
        End If;
        If 元素名_In = '病区名称' Then
          p_Get_Rowtype('病人信息');
          Select 名称
            Into v_Return
            From 部门表
           Where id = r_Patient.当前病区ID;
        End If;
        If 元素名_In = '标识号' Then
          Select decode(a.病人来源,
                        1,
                        c.门诊号,
                        2,
                        decode(c.住院号, null, c.门诊号, c.住院号),
                        4,
                        c.健康号,
                        c.门诊号)
            Into v_Return
            From 病人医嘱记录 a, 病人信息 c
           Where a.病人ID = c.病人id
             And a.id = 医嘱id_In;
        End If;
    End Case;
  
    Return Trim(v_Return);
  Exception
    When Others Then
      Return Null;
  End RIS_Replace_Element_Value;
End b_Zlxwinterface;

/


--96692:廖思奇,2016-11-24,Zl_病理号码规则_Insert 缺少前缀字段的更新，修正之
Create Or Replace Procedure Zl_病理号码规则_Insert
(
  Id_In       病理号码规则.Id%Type,
  号码类型_In 病理号码规则.类型%Type,
  号码前缀_In 病理号码规则.前缀%Type,
  使用年_In   病理号码规则.年%Type,
  使用月_In   病理号码规则.月%Type,
  使用日_In   病理号码规则.日%Type,
  序号位数_In 病理号码规则.序号位数%Type,
  年份位数_In 病理号码规则.年份位数%Type,
  起始数_In   病理号码规则.起始数%Type,
  名称_In     病理号码规则.名称%Type
) Is
  v_Count Number(5);
  v_Year  Varchar2(4);
  v_Month Varchar2(2);
  v_Day   Varchar2(2);
Begin
  Begin
    Select Count(1) Into v_Count From 病理号码规则 Where ID = Id_In;
  Exception
    When Others Then
      v_Count := 0;
  End;

  --更新号码规则
  If v_Count <= 0 Then
    Insert Into 病理号码规则
      (ID, 类型, 前缀, 年, 月, 日, 年份位数, 序号位数, 起始数, 名称)
    Values
      (Id_In, 号码类型_In, 号码前缀_In, 使用年_In, 使用月_In, 使用日_In, 年份位数_In, 序号位数_In, 起始数_In, 名称_In);
  Else
    Update 病理号码规则
    Set 前缀 = 号码前缀_In, 年 = 使用年_In, 月 = 使用月_In, 日 = 使用日_In, 年份位数 = 年份位数_In, 序号位数 = 序号位数_In, 起始数 = 起始数_In, 名称 = 名称_In
    Where ID = Id_In;
  End If;

  --更新号码记录
  v_Year  := 0;
  v_Month := 0;
  v_Day   := 0;

  If 使用年_In = 1 Then
    Select To_Char(Sysdate, 'yyyy') Into v_Year From Dual;
  End If;

  If 使用月_In = 1 Then
    Select To_Char(Sysdate, 'mm') Into v_Month From Dual;
  End If;

  If 使用日_In = 1 Then
    Select To_Char(Sysdate, 'dd') Into v_Day From Dual;
  End If;

  Delete 病理号码记录 Where 号码规则id = Id_In;

  Insert Into 病理号码记录
    (ID, 类型, 年, 月, 日, 当前序号, 号码规则id)
  Values
    (病理号码记录_Id.Nextval, 号码类型_In, v_Year, v_Month, v_Day, 起始数_In - 1, Id_In);

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病理号码规则_Insert;
/

--101736:冉俊明,2016-11-23,手工记帐缺省执行科室调整。
Create Or Replace Procedure Zl_收费细目_Dept
(
  收费细目id_In In 收费项目目录.Id%Type,
  执行科室_In   In Number,
  应用范围_In   In Number,
  分类id_In     In 收费项目目录.分类id%Type,
  类别_In       In 收费项目目录.类别%Type,
  科室列表_In   In Varchar2, --开单科室定向执行的说明串，以|分割，每个定向按开单科室id^执行科室id形式组织
  门诊执行_In   In 诊疗执行科室.执行科室id%Type := Null,
  住院执行_In   In 诊疗执行科室.执行科室id%Type := Null
) Is
  Type t_收费细目 Is Ref Cursor;

  c_收费细目   t_收费细目;
  v_Id         收费项目目录.Id%Type;
  v_执行科室   收费项目目录.执行科室%Type;
  v_Records    Varchar2(4000); --临时记录开单科室定向执行科室的字符串
  v_Currrec    Varchar2(1000); --包含在定向执行科室字符串中的一个定向
  v_Fields     Varchar2(1000);
  v_开单科室id 收费执行科室.开单科室id%Type := Null;
  v_执行科室id 收费执行科室.执行科室id%Type := Null;
Begin
  --首先按不同范围打开记录集
  If 应用范围_In = 1 Then
    --同级项目
    If 分类id_In Is Null Then
      Open c_收费细目 For
        Select ID, 执行科室 From 收费项目目录 Where 分类id Is Null Order By 编码;
    Else
      Open c_收费细目 For
        Select ID, 执行科室 From 收费项目目录 Where 分类id = 分类id_In Order By 编码;
    End If;
  Elsif 应用范围_In = 2 Then
    --分类下所有项目
    If 分类id_In Is Null Then
      Open c_收费细目 For
        Select c.Id, c.执行科室
        From 收费项目目录 C, (Select ID From 收费分类目录 Start With 上级id Is Null Connect By Prior ID = 上级id) D
        Where d.Id = c.分类id
        Order By 编码;
    Else
      Open c_收费细目 For
        Select c.Id, c.执行科室
        From 收费项目目录 C, (Select ID From 收费分类目录 Start With ID = 分类id_In Connect By Prior ID = 上级id) D
        Where d.Id = c.分类id
        Order By 编码;
    End If;
  Elsif 应用范围_In = 3 Then
    --类别下所有项目
    Open c_收费细目 For
      Select ID, 执行科室 From 收费项目目录 Where 类别 = 类别_In Order By 编码;
  Else
    Open c_收费细目 For
      Select ID, 执行科室 From 收费项目目录 Where ID = 收费细目id_In;
  End If;

  --接着修改
  Loop
    Fetch c_收费细目
      Into v_Id, v_执行科室;
    Exit When c_收费细目%NotFound;
  
    If v_执行科室 = 4 Or v_执行科室 = 0 Then
      Delete From 收费执行科室 Where 收费细目id = v_Id;
    End If;
  
    Update 收费项目目录 Set 执行科室 = 执行科室_In Where ID = v_Id;
  
    If 执行科室_In = 4 And 门诊执行_In Is Not Null Then
      Insert Into 收费执行科室 (收费细目id, 病人来源, 开单科室id, 执行科室id) Values (v_Id, 1, Null, 门诊执行_In);
    End If;
    If (执行科室_In = 4 Or 执行科室_In = 0) And 住院执行_In Is Not Null Then
      Insert Into 收费执行科室 (收费细目id, 病人来源, 开单科室id, 执行科室id) Values (v_Id, 2, Null, 住院执行_In);
    End If;
    If 执行科室_In <> 4 Or 科室列表_In Is Null Then
      v_Records := Null;
    Else
      v_Records := 科室列表_In || '|';
    End If;
    While v_Records Is Not Null Loop
      v_Currrec    := Substr(v_Records, 1, Instr(v_Records, '|') - 1);
      v_Fields     := v_Currrec;
      v_开单科室id := To_Number(Substr(v_Fields, 1, Instr(v_Fields, '^') - 1));
      v_Fields     := Substr(v_Fields, Instr(v_Fields, '^') + 1);
      v_执行科室id := To_Number(v_Fields);
      Insert Into 收费执行科室
        (收费细目id, 病人来源, 开单科室id, 执行科室id)
      Values
        (v_Id, Null, Decode(v_开单科室id, 0, Null, v_开单科室id), v_执行科室id);
      v_Records := Replace('|' || v_Records, '|' || v_Currrec || '|');
    End Loop;
  End Loop;

  Close c_收费细目;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_收费细目_Dept;
/

--102980:梁唐彬,2016-11-23,附费执行时报错报错
Create Or Replace Procedure Zl_病人费用记录_Unexecute
(
  No_In         住院费用记录.No%Type,
  记录性质_In   住院费用记录.记录性质%Type,
  序号_In       Varchar2,
  来源_In       Number := 2,
  仅更新费用_In Number := 0
) As
  --  来源_IN :1-门诊;2-住院 
  --  序号_In：费用行的行号，收入项目子行以父行为序号为准,为空表示单据所有行 
  --  仅更新费用_In:1表示:只更新病人费用记录.执行人,执行时间,结论;0-根据执行情况填写相关表

  Err_Item Exception;
  v_Err_Msg Varchar2(255);

  v_审核人 药品收发记录.审核人%Type;
  v_医嘱id 病人医嘱发送.医嘱id%Type;
  v_发送号 病人医嘱发送.发送号%Type;
  v_Temp   Varchar2(100);
  n_Count  Number(8);
  n_卫材   Number(18);
  n_药品   Number(18);
  Cursor c_Stuff_Mz Is
    Select a.Id
    From 药品收发记录 A, 门诊费用记录 B, 材料特性 C
    Where a.费用id = b.Id And a.药品id = c.材料id And Nvl(c.跟踪在用, 0) = 1 And (a.记录状态 = 1 Or Mod(a.记录状态, 3) = 0) And
          a.审核人 Is Not Null And b.No = No_In And b.记录性质 = 记录性质_In And instr( ',8,9,10,24,25,26,',','||a.单据||',')>0 And
          (Instr(',' || 序号_In || ',', ',' || Nvl(b.价格父号, b.序号) || ',') > 0 Or 序号_In Is Null) And b.记录状态 = 1;

  Cursor c_Stuff_Zy Is
    Select a.Id
    From 药品收发记录 A, 住院费用记录 B, 材料特性 C
    Where a.费用id = b.Id And a.药品id = c.材料id And Nvl(c.跟踪在用, 0) = 1 And (a.记录状态 = 1 Or Mod(a.记录状态, 3) = 0) And
          a.审核人 Is Not Null And b.No = No_In And b.记录性质 = 记录性质_In And instr( ',8,9,10,24,25,26,',','||a.单据||',')>0 And
          (Instr(',' || 序号_In || ',', ',' || Nvl(b.价格父号, b.序号) || ',') > 0 Or 序号_In Is Null) And b.记录状态 = 1;
Begin

  If Nvl(仅更新费用_In, 1) = 1 Then
    If 来源_In = 1 Then
      Update 门诊费用记录 A
      Set a.执行人 = Null, a.执行时间 = Null, a.执行状态 = 0, a.结论 = Null
      Where a.No = No_In And a.记录性质 = 记录性质_In And
            (Instr(',' || 序号_In || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 Or 序号_In Is Null) And a.记录状态 In (0, 1);
    
    Else
      Update 住院费用记录 A
      Set a.执行人 = Null, a.执行时间 = Null, a.执行状态 = 0, a.结论 = Null
      Where a.No = No_In And a.记录性质 = 记录性质_In And
            (Instr(',' || 序号_In || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 Or 序号_In Is Null) And a.记录状态 In (0, 1);
    End If;
    Return;
  End If;

  If 来源_In = 1 Then
    --执行之后卫材自动发料,取消执行时自动退料 
    For r_Stuff In c_Stuff_Mz Loop
      --操作员信息:部门ID,部门名称;人员ID,人员编号,人员姓名 
      If v_审核人 Is Null Then
        v_审核人 := Zl_Username;
      End If;
      Zl_材料收发记录_部门退料(r_Stuff.Id, v_审核人, Sysdate, Null, Null, Null, Null, 0, v_审核人);
    End Loop;
  Else
    --执行之后卫材自动发料,取消执行时自动退料 
    For r_Stuff In c_Stuff_Zy Loop
      --操作员信息:部门ID,部门名称;人员ID,人员编号,人员姓名 
      If v_审核人 Is Null Then
        v_审核人 := Zl_Username;
      End If;
      Zl_材料收发记录_部门退料(r_Stuff.Id, v_审核人, Sysdate, Null, Null, Null, Null, 0, v_审核人);
    End Loop;
  End If;

  ---执行之后卫材自动发料,则不需要更新跟踪在用的卫材 
  If 来源_In = 1 Then
    Update 门诊费用记录 A
    Set a.执行人 = Null, a.执行时间 = Null, a.执行状态 = 0, a.结论 = Null
    Where a.No = No_In And a.记录性质 = 记录性质_In And
          (Instr(',' || 序号_In || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 Or 序号_In Is Null) And a.记录状态 In (0, 1) And
          a.收费类别 Not In ('5', '6', '7') And Not Exists
     (Select 1 From 材料特性 B Where a.收费细目id = b.材料id And a.收费类别 = '4' And Nvl(b.跟踪在用, 0) = 1);
  
  Else
    Update 住院费用记录 A
    Set a.执行人 = Null, a.执行时间 = Null, a.执行状态 = 0, a.结论 = Null
    Where a.No = No_In And a.记录性质 = 记录性质_In And
          (Instr(',' || 序号_In || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 Or 序号_In Is Null) And a.记录状态 In (0, 1) And
          a.收费类别 Not In ('5', '6', '7') And Not Exists
     (Select 1 From 材料特性 B Where a.收费细目id = b.材料id And a.收费类别 = '4' And Nvl(b.跟踪在用, 0) = 1);
  End If;
  --处理并发，若单据全部是药品或非跟踪在用状态下的卫材，程序里面已做禁止执行 
  --若单据中全部是跟踪在用卫材，且执行之后卫材自动发料，此时不抛出错误（药品已经在程序里禁止） 

  If Sql%NotFound Then
      If 来源_In = 1 Then
        Select Count(1)
        Into n_Count
        From 门诊费用记录 A
        Where a.No = No_In And a.记录性质 = 记录性质_In And
              (Instr(',' || 序号_In || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 Or 序号_In Is Null) And a.记录状态 In (0, 1) And
              Nvl(a.执行状态, 0) <> 9 And a.收费类别 Not In ('5', '6', '7') And Not Exists
         (Select 1 From 材料特性 B Where a.收费细目id = b.材料id And a.收费类别 = '4' And Nvl(b.跟踪在用, 0) = 1);
      Else
        Select Count(1)
        Into n_Count
        From 住院费用记录 A
        Where a.No = No_In And a.记录性质 = 记录性质_In And
              (Instr(',' || 序号_In || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 Or 序号_In Is Null) And a.记录状态 In (0, 1) And
              a.收费类别 Not In ('5', '6', '7') And Not Exists
         (Select 1 From 材料特性 B Where a.收费细目id = b.材料id And a.收费类别 = '4' And Nvl(b.跟踪在用, 0) = 1);
      End If;
    
      If n_Count <> 0 Then
        v_Err_Msg := '未找到相关的费用数据,可能该单据正在进行收费,不能执行登记或与系统管理员联系!';
        Raise Err_Item;
      End If;
  
  End If;

  If 来源_In = 1 Then
    Begin
      Select Max(a.医嘱id), Max(a.发送号)
      Into v_医嘱id, v_发送号
      From 病人医嘱发送 A, 门诊费用记录 B
      Where a.医嘱id = b.医嘱序号 And a.No = b.No And a.记录性质 = b.记录性质 And b.No = No_In And b.记录性质 = 记录性质_In And
            (Instr(',' || 序号_In || ',', ',' || Nvl(b.价格父号, b.序号) || ',') > 0 Or 序号_In Is Null) And b.记录状态 In (0, 1);
    Exception
      When Others Then
        Null;
    End;
  Else
    Begin
      Select Max(a.医嘱id), Max(a.发送号)
      Into v_医嘱id, v_发送号
      From 病人医嘱发送 A, 住院费用记录 B
      Where a.医嘱id = b.医嘱序号 And a.No = b.No And a.记录性质 = b.记录性质 And b.No = No_In And b.记录性质 = 记录性质_In And
            (Instr(',' || 序号_In || ',', ',' || Nvl(b.价格父号, b.序号) || ',') > 0 Or 序号_In Is Null) And b.记录状态 In (0, 1);
    Exception
      When Others Then
        Null;
    End;
  End If;

  If v_医嘱id Is Not Null And v_发送号 Is Not Null Then
    --处理医嘱的执行状态 
    --1.如果同一张医嘱发送单都取消执行完了,才更新执行状态为未执行 
    --2.如果同一医嘱发送单中存在卫材和药品被发料和发药的,则不允许取消执行登记
    If Not 序号_In Is Null Then
      If 来源_In = 1 Then
        Select Count(*), Sum(Decode(a.收费类别, '5', 1, '6', 1, '7', 1, 0)),
               Sum(Decode(a.收费类别, '4', Decode(Nvl(b.跟踪在用, 0), 1, 1, 0), 0))
        Into n_Count, n_药品, n_卫材
        From 门诊费用记录 A, 材料特性 B
        Where a.No = No_In And a.记录性质 = 记录性质_In And a.医嘱序号 = v_医嘱id And a.执行状态 In (1, 2) And a.记录状态 In (1, 3) And
              a.收费细目id = b.材料id(+);
      Else
        Select Count(*), Sum(Decode(a.收费类别, '5', 1, '6', 1, '7', 1, 0)),
               Sum(Decode(收费类别, '4', Decode(Nvl(b.跟踪在用, 0), 1, 1, 0), 0))
        Into n_Count, n_药品, n_卫材
        From 住院费用记录 A, 材料特性 B
        Where a.No = No_In And a.记录性质 = 记录性质_In And a.医嘱序号 = v_医嘱id And a.执行状态 In (1, 2) And a.记录状态 In (1, 3) And
              a.收费细目id = b.材料id(+);
      End If;
      If Nvl(n_药品, 0) <> 0 Then
        v_Err_Msg := '存在已经发药的药品,不能取消执行登记,请先退药!';
        Raise Err_Item;
      End If;
      If Nvl(n_卫材, 0) <> 0 Then
        v_Err_Msg := '存在已经发料的卫生材料,不能取消执行登记,请先退料!';
        Raise Err_Item;
      End If;
    Else
      n_Count := 0;
    End If;
  
    If n_Count = 0 Then
      Update 病人医嘱发送
      Set 执行状态 = 0, 完成人 = Null, 完成时间 = Null
      Where 发送号 = v_发送号 And 医嘱id = v_医嘱id And NO = No_In And 记录性质 = 记录性质_In And 执行状态 In (1, 3);
    Else
      Update 病人医嘱发送
      Set 执行状态 = 3, 完成人 = Null, 完成时间 = Null
      Where 发送号 = v_发送号 And 医嘱id = v_医嘱id And NO = No_In And 记录性质 = 记录性质_In And 执行状态 = 1;
    End If;
  End If;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人费用记录_Unexecute;
/

--102760:刘尔旋,2016-11-23,支付宝并发错误提示更改
Create Or Replace Procedure Zl_预约挂号接收_出诊_Insert
(
  No_In            门诊费用记录.No%Type,
  票据号_In        门诊费用记录.实际票号%Type,
  领用id_In        票据使用明细.领用id%Type,
  结帐id_In        门诊费用记录.结帐id%Type,
  诊室_In          门诊费用记录.发药窗口%Type,
  病人id_In        门诊费用记录.病人id%Type,
  门诊号_In        门诊费用记录.标识号%Type,
  姓名_In          门诊费用记录.姓名%Type,
  性别_In          门诊费用记录.性别%Type,
  年龄_In          门诊费用记录.年龄%Type,
  付款方式_In      门诊费用记录.付款方式%Type, --用于存放病人的医疗付款方式编号
  费别_In          门诊费用记录.费别%Type,
  结算方式_In      Varchar2, --现金的结算名称
  现金支付_In      病人预交记录.冲预交%Type, --挂号时现金支付部份金额
  预交支付_In      病人预交记录.冲预交%Type, --挂号时使用的预交金额
  个帐支付_In      病人预交记录.冲预交%Type, --挂号时个人帐户支付金额
  发生时间_In      门诊费用记录.发生时间%Type,
  号序_In          挂号序号状态.序号%Type,
  操作员编号_In    门诊费用记录.操作员编号%Type,
  操作员姓名_In    门诊费用记录.操作员姓名%Type,
  生成队列_In      Number := 0,
  登记时间_In      门诊费用记录.登记时间%Type := Null,
  卡类别id_In      病人预交记录.卡类别id%Type := Null,
  结算卡序号_In    病人预交记录.结算卡序号%Type := Null,
  卡号_In          病人预交记录.卡号%Type := Null,
  交易流水号_In    病人预交记录.交易流水号%Type := Null,
  交易说明_In      病人预交记录.交易说明%Type := Null,
  险类_In          病人挂号记录.险类%Type := Null,
  结算模式_In      Number := 0,
  记帐费用_In      Number := 0,
  冲预交病人ids_In Varchar2 := Null,
  三方调用_In      Number := 0,
  更新交款余额_In  Number := 0 --是否更新人员交款余额，主要是处理统一操作员登录多台自助机的情况
) As
  --该游标用于收费冲预交的可用预交列表
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit
  (
    v_病人id        病人信息.病人id%Type,
    v_冲预交病人ids Varchar2
  ) Is
    Select 病人id, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额, Min(记录状态) As 记录状态, Nvl(Max(结帐id), 0) As 结帐id,
           Max(Decode(记录性质, 1, ID, 0) * Decode(记录状态, 2, 0, 1)) As 原预交id
    From 病人预交记录
    Where 记录性质 In (1, 11) And 病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And Nvl(预交类别, 2) = 1
     Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
    Group By NO, 病人id
    Order By Decode(病人id, Nvl(v_病人id, 0), 0, 1), 结帐id, NO;

  v_Err_Msg Varchar2(255);
  Err_Item Exception;
  Err_Special Exception;
  v_操作员姓名 病人挂号记录.接收人%Type;
  v_现金       结算方式.名称%Type;
  v_个人帐户   结算方式.名称%Type;
  v_队列名称   排队叫号队列.队列名称%Type;
  v_号别       门诊费用记录.计算单位%Type;
  v_号序       门诊费用记录.发药窗口%Type;
  v_排队号码   排队叫号队列.排队号码 %Type;
  v_预约方式   病人挂号记录.预约方式 %Type;

  n_打印id        票据打印内容.Id%Type;
  n_预交金额      病人预交记录.金额%Type;
  n_返回值        病人预交记录.金额%Type;
  v_冲预交病人ids Varchar2(4000);

  n_挂号id         病人挂号记录.Id%Type;
  n_分诊台签到排队 Number;
  n_组id           财务缴款分组.Id%Type;
  n_Count          Number(18);
  n_排队           Number;
  n_当天排队       Number;
  n_当前金额       病人预交记录.金额%Type;
  n_预交id         病人预交记录.Id%Type;
  n_消费卡id       消费卡目录.Id%Type;
  n_自制卡         Number;

  d_Date         Date;
  d_预约时间     门诊费用记录.发生时间%Type;
  d_发生时间     Date;
  d_排队时间     Date;
  n_时段         Number := 0;
  n_存在         Number := 0;
  v_结算内容     Varchar2(2000);
  v_当前结算     Varchar2(500);
  n_结算金额     病人预交记录.冲预交%Type;
  v_结算号码     病人预交记录.结算号码%Type;
  v_结算方式     病人预交记录.结算方式%Type;
  n_三方卡标志   Number(3);
  v_排队序号     排队叫号队列.排队序号%Type;
  n_结算模式     病人信息.结算模式%Type;
  n_票种         票据使用明细.票种%Type;
  v_付款方式     病人挂号记录.医疗付款方式%Type;
  n_接收模式     Number := 0;
  n_出诊记录id   病人挂号记录.出诊记录id%Type;
  n_新出诊记录id 病人挂号记录.出诊记录id%Type;
  n_号源id       临床出诊记录.号源id%Type;
  n_预约顺序号   临床出诊序号控制.预约顺序号%Type;
  n_旧分时段     临床出诊记录.是否分时段%Type;
  n_旧序号控制   临床出诊记录.是否序号控制%Type;
  n_旧科室id     临床出诊记录.科室id%Type;
  n_旧项目id     临床出诊记录.项目id%Type;
  n_旧医生id     临床出诊记录.医生id%Type;
  n_挂号模式     Number(3);
  d_启用时间     Date;
  v_Paratemp     Varchar2(500);
  v_Registtemp   Varchar2(500);
  n_检查         Number(3);
Begin
  n_组id          := Zl_Get组id(操作员姓名_In);
  v_冲预交病人ids := Nvl(冲预交病人ids_In, 病人id_In);
  v_Paratemp      := Nvl(zl_GetSysParameter('挂号排班模式'), 0);
  n_接收模式      := Nvl(zl_GetSysParameter('预约接收模式', 1111), 0);
  n_挂号模式      := To_Number(Substr(v_Paratemp, 1, 1));
  If n_挂号模式 = 1 Then
    Begin
      d_启用时间 := To_Date(Substr(v_Paratemp, 3), 'yyyy-mm-dd hh24:mi:ss');
    Exception
      When Others Then
        d_启用时间 := Null;
    End;
  End If;

  --获取结算方式名称
  Begin
    Select 名称 Into v_现金 From 结算方式 Where 性质 = 1;
  Exception
    When Others Then
      v_现金 := '现金';
  End;
  Begin
    Select 名称 Into v_个人帐户 From 结算方式 Where 性质 = 3;
  Exception
    When Others Then
      v_个人帐户 := '个人帐户';
  End;
  If 登记时间_In Is Null Then
    Select Sysdate Into d_Date From Dual;
  Else
    d_Date := 登记时间_In;
  End If;

  --更新挂号序号状态
  Begin
    Select 号别, 号序, Trunc(发生时间), 发生时间, 预约方式, 出诊记录id
    Into v_号别, v_号序, d_预约时间, d_发生时间, v_预约方式, n_出诊记录id
    From 病人挂号记录
    Where 记录性质 = 2 And 记录状态 = 1 And Rownum = 1 And NO = No_In;
  Exception
    When Others Then
      Select Max(接收人) Into v_操作员姓名 From 病人挂号记录 Where 记录性质 = 2 And 记录状态 In (1, 3) And NO = No_In;
      If v_操作员姓名 Is Null Then
        v_Err_Msg := '当前预约挂号单已被取消';
        Raise Err_Item;
      Else
        If v_操作员姓名 = 操作员姓名_In Then
          v_Err_Msg := '当前预约挂号单已被接收';
          Raise Err_Special;
        Else
          v_Err_Msg := '当前预约挂号单已被其它人接收';
          Raise Err_Item;
        End If;
      End If;
  End;

  --判断是否分时段
  Select Nvl(是否分时段, 0), 号源id Into n_时段, n_号源id From 临床出诊记录 Where ID = n_出诊记录id;

  If n_时段 = 1 And 三方调用_In = 0 And n_接收模式 = 0 Then
    If Trunc(发生时间_In) <> Trunc(Sysdate) Then
      v_Err_Msg := '分时段的预约挂号单只能当天接收！';
      Raise Err_Item;
    End If;
  End If;

  If n_时段 = 0 And 三方调用_In = 0 Then
    If n_接收模式 = 0 Then
      If Trunc(发生时间_In) = Trunc(Sysdate) Then
        d_发生时间 := 发生时间_In;
      Else
        d_发生时间 := Sysdate;
      End If;
    Else
      d_发生时间 := 发生时间_In;
    End If;
  Else
    If Not 发生时间_In Is Null Then
      d_发生时间 := 发生时间_In;
    End If;
  End If;

  If d_启用时间 Is Not Null Then
    If d_发生时间 < d_启用时间 Then
      v_Err_Msg := '当前预约挂号单属于出诊表排班模式安排，不能在' || To_Char(d_启用时间, 'yyyy-mm-dd hh24:mi:ss') || '之前接收!';
      Raise Err_Item;
    End If;
  End If;

  If Not v_号序 Is Null Then
    If 号序_In Is Null Then
      Update 临床出诊序号控制 Set 挂号状态 = 0 Where (序号 = v_号序 Or 备注 = v_号序) And 记录id = n_出诊记录id;
    Else
      If Trunc(d_预约时间) <> Trunc(Sysdate) And n_接收模式 = 0 Then
        If n_时段 = 0 And 三方调用_In = 0 Then
          --提前接收或延迟接收
          Update 临床出诊序号控制 Set 挂号状态 = 0 Where 序号 = v_号序 And 记录id = n_出诊记录id;
        
          Select 是否分时段, 是否序号控制, 科室id, 医生id, 项目id
          Into n_旧分时段, n_旧序号控制, n_旧科室id, n_旧医生id, n_旧项目id
          From 临床出诊记录
          Where ID = n_出诊记录id;
          Begin
            Select ID
            Into n_新出诊记录id
            From 临床出诊记录
            Where 号源id = n_号源id And 是否分时段 = n_旧分时段 And 是否序号控制 = n_旧序号控制 And 科室id = n_旧科室id And 医生id = n_旧医生id And
                  项目id = n_旧项目id And Nvl(是否发布, 0) = 1 And 出诊日期 = Trunc(Sysdate) And Rownum < 2;
          Exception
            When Others Then
              v_Err_Msg := '接收当天没有对应的出诊安排,无法接收!';
              Raise Err_Item;
          End;
        
          Begin
            Select 1
            Into n_存在
            From 临床出诊序号控制
            Where 记录id = n_新出诊记录id And 序号 = v_号序 And Nvl(挂号状态, 0) = 0;
          Exception
            When Others Then
              n_存在 := 0;
          End;
        
          If n_存在 = 0 Then
            Update 临床出诊序号控制
            Set 挂号状态 = 1, 操作员姓名 = 操作员姓名_In
            Where 记录id = n_新出诊记录id And 序号 = v_号序 And Nvl(挂号状态, 0) = 0;
          Else
            --号码已被使用的情况
            Select Min(序号) Into v_号序 From 临床出诊序号控制 Where 记录id = n_新出诊记录id And Nvl(挂号状态, 0) = 0;
            If v_号序 Is Null Then
              v_Err_Msg := '接收当天没有可用序号,无法接收!';
              Raise Err_Item;
            End If;
            Update 临床出诊序号控制
            Set 挂号状态 = 1, 操作员姓名 = 操作员姓名_In
            Where 记录id = n_新出诊记录id And 序号 = v_号序 And Nvl(挂号状态, 0) = 0;
          End If;
        Else
          Select 是否分时段, 是否序号控制, 科室id, 医生id, 项目id
          Into n_旧分时段, n_旧序号控制, n_旧科室id, n_旧医生id, n_旧项目id
          From 临床出诊记录
          Where ID = n_出诊记录id;
          Begin
            Select ID
            Into n_新出诊记录id
            From 临床出诊记录
            Where 号源id = n_号源id And 是否分时段 = n_旧分时段 And 是否序号控制 = n_旧序号控制 And 科室id = n_旧科室id And 医生id = n_旧医生id And
                  项目id = n_旧项目id And Nvl(是否发布, 0) = 1 And 出诊日期 = Trunc(Sysdate) And Rownum < 2;
          Exception
            When Others Then
              v_Err_Msg := '接收当天没有对应的出诊安排,无法接收!';
              Raise Err_Item;
          End;
          Update 临床出诊序号控制
          Set 挂号状态 = 0, 操作员姓名 = 操作员姓名_In
          Where (序号 = v_号序 Or 备注 = v_号序) And 记录id = n_出诊记录id And Nvl(挂号状态, 0) = 2
          Returning 预约顺序号 Into n_预约顺序号;
        
          Update 临床出诊序号控制
          Set 挂号状态 = 1, 操作员姓名 = 操作员姓名_In, 预约顺序号 = n_预约顺序号
          Where 序号 = v_号序 And 记录id = n_新出诊记录id And Nvl(挂号状态, 0) = 0;
          If Sql% RowCount = 0 Then
            v_Err_Msg := '接收当天序号' || v_号序 || '已被其它人使用,无法接收.';
            Raise Err_Item;
          End If;
        End If;
      Else
        Update 临床出诊序号控制
        Set 挂号状态 = 1, 操作员姓名 = 操作员姓名_In
        Where (序号 = v_号序 Or 备注 = v_号序) And 记录id = n_出诊记录id;
        If Sql%RowCount = 0 Then
          v_Err_Msg := '序号' || v_号序 || '已被其它人使用,请重新选择一个序号.';
          Raise Err_Item;
        End If;
      End If;
    End If;
  Else
    If Not 号序_In Is Null Then
      If Trunc(d_预约时间) <> Trunc(Sysdate) And n_接收模式 = 0 Then
        Select 是否分时段, 是否序号控制, 科室id, 医生id, 项目id
        Into n_旧分时段, n_旧序号控制, n_旧科室id, n_旧医生id, n_旧项目id
        From 临床出诊记录
        Where ID = n_出诊记录id;
        Begin
          Select ID
          Into n_新出诊记录id
          From 临床出诊记录
          Where 号源id = n_号源id And 是否分时段 = n_旧分时段 And 是否序号控制 = n_旧序号控制 And 科室id = n_旧科室id And 医生id = n_旧医生id And
                项目id = n_旧项目id And Nvl(是否发布, 0) = 1 And 出诊日期 = Trunc(Sysdate) And Rownum < 2;
        Exception
          When Others Then
            v_Err_Msg := '接收当天没有对应的出诊安排,无法接收!';
            Raise Err_Item;
        End;
        Update 临床出诊序号控制
        Set 挂号状态 = 0, 操作员姓名 = 操作员姓名_In
        Where (序号 = 号序_In Or 备注 = 号序_In) And 记录id = n_出诊记录id And Nvl(挂号状态, 0) = 2
        Returning 预约顺序号 Into n_预约顺序号;
        Update 临床出诊序号控制
        Set 挂号状态 = 1, 操作员姓名 = 操作员姓名_In, 预约顺序号 = n_预约顺序号
        Where 序号 = 号序_In And 记录id = n_新出诊记录id And Nvl(挂号状态, 0) = 0;
        If Sql%RowCount = 0 Then
          v_Err_Msg := '接收当天序号' || 号序_In || '已被其它人使用,无法接收.';
          Raise Err_Item;
        End If;
      Else
        Update 临床出诊序号控制
        Set 挂号状态 = 1, 操作员姓名 = 操作员姓名_In
        Where (序号 = 号序_In Or 备注 = 号序_In) And 记录id = n_出诊记录id;
      
      End If;
      v_号序 := 号序_In;
    Else
      v_号序 := Null;
    End If;
  End If;

  --更新门诊费用记录
  Update 门诊费用记录
  Set 记录状态 = 1, 实际票号 = Decode(Nvl(记帐费用_In, 0), 1, Null, 票据号_In), 结帐id = Decode(Nvl(记帐费用_In, 0), 1, Null, 结帐id_In),
      结帐金额 = Decode(Nvl(记帐费用_In, 0), 1, Null, 实收金额), 发药窗口 = 诊室_In, 病人id = 病人id_In, 标识号 = 门诊号_In, 姓名 = 姓名_In, 年龄 = 年龄_In,
      性别 = 性别_In, 付款方式 = 付款方式_In, 费别 = 费别_In, 发生时间 = d_发生时间, 登记时间 = d_Date, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In,
      缴款组id = n_组id, 记帐费用 = Decode(Nvl(记帐费用_In, 0), 1, 1, 0)
  Where 记录性质 = 4 And 记录状态 = 0 And NO = No_In;

  v_Registtemp := zl_GetSysParameter('挂号排班模式');
  If Substr(v_Registtemp, 1, 1) = 1 Then
    Begin
      If To_Date(Substr(v_Registtemp, 3), 'yyyy-mm-dd hh24:mi:ss') > d_发生时间 Then
        v_Err_Msg := '接收时间' || To_Char(d_发生时间, 'yyyy-mm-dd hh24:mi:ss') || '未启用出诊表排班模式,目前无法接收!';
        Raise Err_Item;
      End If;
    Exception
      When Others Then
        Null;
    End;
    Begin
      Select 1
      Into n_检查
      From 临床出诊记录
      Where ID = Nvl(n_新出诊记录id, n_出诊记录id) And d_发生时间 Between 停诊开始时间 And 停诊终止时间;
    Exception
      When Others Then
        n_检查 := 0;
    End;
    If n_检查 = 1 Then
      v_Err_Msg := '接收时间' || To_Char(d_发生时间, 'yyyy-mm-dd hh24:mi:ss') || '的安排已经被停诊,无法接收!';
      Raise Err_Item;
    End If;
  End If;

  --病人挂号记录
  Update 病人挂号记录
  Set 接收人 = 操作员姓名_In, 接收时间 = d_Date, 记录性质 = 1, 病人id = 病人id_In, 门诊号 = 门诊号_In, 发生时间 = d_发生时间, 姓名 = 姓名_In, 性别 = 性别_In,
      年龄 = 年龄_In, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In, 险类 = Decode(Nvl(险类_In, 0), 0, Null, 险类_In), 号序 = v_号序, 诊室 = 诊室_In,
      出诊记录id = Nvl(n_新出诊记录id, n_出诊记录id)
  Where 记录状态 = 1 And NO = No_In And 记录性质 = 2
  Returning ID Into n_挂号id;
  If Sql%NotFound Then
    Begin
      Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
      Begin
        Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In And Rownum < 2;
      Exception
        When Others Then
          v_付款方式 := Null;
      End;
      Insert Into 病人挂号记录
        (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 操作员编号, 操作员姓名,
         摘要, 号序, 预约, 预约方式, 接收人, 接收时间, 预约时间, 险类, 医疗付款方式, 出诊记录id)
        Select n_挂号id, No_In, 1, 1, 病人id_In, 门诊号_In, 姓名_In, 性别_In, 年龄_In, 计算单位, 加班标志, 诊室_In, Null, 执行部门id, 执行人, 0, Null,
               登记时间, 发生时间, 操作员编号, 操作员姓名, 摘要, v_号序, 1, Substr(结论, 1, 10) As 预约方式, 操作员姓名_In, Nvl(登记时间_In, Sysdate), 发生时间,
               Decode(Nvl(险类_In, 0), 0, Null, 险类_In), v_付款方式, Nvl(n_新出诊记录id, n_出诊记录id)
        From 门诊费用记录
        Where 记录性质 = 4 And 记录状态 = 1 And Rownum = 1 And NO = No_In;
    Exception
      When Others Then
        v_Err_Msg := '由于并发原因,单据号为【' || No_In || '】的病人' || 姓名_In || '已经被接收';
        Raise Err_Item;
    End;
  End If;

  --0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站
  If Nvl(生成队列_In, 0) <> 0 Then
    n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
    If Nvl(n_分诊台签到排队, 0) = 0 Then
      For v_挂号 In (Select ID, 姓名, 诊室, 执行人, 执行部门id, 发生时间, 号别, 号序 From 病人挂号记录 Where NO = No_In) Loop
      
        Begin
          Select 1,
                 Case
                   When 排队时间 < Trunc(Sysdate) Then
                    1
                   Else
                    0
                 End
          Into n_排队, n_当天排队
          From 排队叫号队列
          Where 业务类型 = 0 And 业务id = v_挂号.Id And Rownum <= 1;
        Exception
          When Others Then
            n_排队 := 0;
        End;
        If n_排队 = 0 Then
          --产生队列
          --按”执行部门”产生队列
          n_挂号id   := v_挂号.Id;
          v_队列名称 := v_挂号.执行部门id;
          v_排队号码 := Zlgetnextqueue(v_挂号.执行部门id, n_挂号id, v_挂号.号别 || '|' || v_挂号.号序);
          v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
        
          --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)
          d_排队时间 := Zl_Get_Queuedate(n_挂号id, v_挂号.号别, v_挂号.号序, v_挂号.发生时间);
          --   队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,排队标记_In,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In,
          Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, v_挂号.执行部门id, v_排队号码, Null, 姓名_In, 病人id_In, v_挂号.诊室, v_挂号.执行人, d_排队时间,
                           v_预约方式, Null, v_排队序号);
        Elsif Nvl(n_当天排队, 0) = 1 Then
          --更新队列号
          v_排队号码 := Zlgetnextqueue(v_挂号.执行部门id, v_挂号.Id, v_挂号.号别 || '|' || Nvl(v_挂号.号序, 0));
          v_排队序号 := Zlgetsequencenum(0, v_挂号.Id, 1);
          --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In, 医生姓名_In ,排队号码_In
          Zl_排队叫号队列_Update(v_挂号.执行部门id, 0, v_挂号.Id, v_挂号.执行部门id, v_挂号.姓名, v_挂号.诊室, v_挂号.执行人, v_排队号码, v_排队序号);
        
        Else
          --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In, 医生姓名_In ,排队号码_In
          Zl_排队叫号队列_Update(v_挂号.执行部门id, 0, v_挂号.Id, v_挂号.执行部门id, v_挂号.姓名, v_挂号.诊室, v_挂号.执行人);
        End If;
      End Loop;
    End If;
  End If;

  --汇总结算到病人预交记录
  If Nvl(记帐费用_In, 0) = 0 Then
    If Nvl(现金支付_In, 0) = 0 And Nvl(个帐支付_In, 0) = 0 And Nvl(预交支付_In, 0) = 0 Then
      Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      Insert Into 病人预交记录
        (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
         结算性质)
      Values
        (n_预交id, 4, 1, No_In, Decode(病人id_In, 0, Null, 病人id_In), v_现金, 0, 登记时间_In, 操作员编号_In, 操作员姓名_In, 结帐id_In, '挂号收费',
         n_组id, 卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, Null, 4);
    End If;
    If Nvl(现金支付_In, 0) <> 0 Then
      v_结算内容 := 结算方式_In || '|'; --以空格分开以|结尾,没有结算号码的
      While v_结算内容 Is Not Null Loop
        v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '|') - 1);
        v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1);
      
        v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
        n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1));
      
        v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
        v_结算号码 := Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1);
      
        v_当前结算   := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
        n_三方卡标志 := To_Number(v_当前结算);
      
        If n_三方卡标志 = 0 Then
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          Insert Into 病人预交记录
            (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
             合作单位, 结算性质, 结算号码)
          Values
            (n_预交id, 4, 1, No_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(v_结算方式, v_现金), Nvl(n_结算金额, 0), 登记时间_In,
             操作员编号_In, 操作员姓名_In, 结帐id_In, '挂号收费', n_组id, Null, Null, Null, Null, Null, Null, 4, v_结算号码);
        Else
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          Insert Into 病人预交记录
            (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
             合作单位, 结算性质, 结算号码)
          Values
            (n_预交id, 4, 1, No_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(v_结算方式, v_现金), Nvl(n_结算金额, 0), 登记时间_In,
             操作员编号_In, 操作员姓名_In, 结帐id_In, '挂号收费', n_组id, 卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, Null, 4, v_结算号码);
          If Nvl(结算卡序号_In, 0) <> 0 Then
            n_消费卡id := Null;
            Begin
              Select Nvl(自制卡, 0), 1 Into n_自制卡, n_Count From 卡消费接口目录 Where 编号 = 结算卡序号_In;
            Exception
              When Others Then
                n_Count := 0;
            End;
            If n_Count = 0 Then
              v_Err_Msg := '没有发现原结算卡的相应类别,不能继续操作！';
              Raise Err_Item;
            End If;
            If n_自制卡 = 1 Then
              Select ID
              Into n_消费卡id
              From 消费卡目录
              Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In And
                    序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In);
            End If;
            Zl_病人卡结算记录_Insert(结算卡序号_In, n_消费卡id, v_结算方式, n_结算金额, 卡号_In, Null, 登记时间_In, Null, 结帐id_In, n_预交id);
          End If;
        End If;
      
        If Nvl(更新交款余额_In, 0) = 0 Then
          Update 人员缴款余额
          Set 余额 = Nvl(余额, 0) + n_结算金额
          Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = Nvl(v_结算方式, v_现金)
          Returning 余额 Into n_返回值;
        
          If Sql%RowCount = 0 Then
            Insert Into 人员缴款余额
              (收款员, 结算方式, 性质, 余额)
            Values
              (操作员姓名_In, Nvl(v_结算方式, v_现金), 1, n_结算金额);
            n_返回值 := n_结算金额;
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 人员缴款余额
            Where 收款员 = 操作员姓名_In And 结算方式 = Nvl(v_结算方式, v_现金) And 性质 = 1 And Nvl(余额, 0) = 0;
          End If;
        End If;
      
        v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '|') + 1);
      End Loop;
    End If;
  End If;

  --对于就诊卡通过预交金挂号
  If Nvl(预交支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 Then
    n_预交金额 := 预交支付_In;
    For r_Deposit In c_Deposit(病人id_In, v_冲预交病人ids) Loop
      n_当前金额 := Case
                  When r_Deposit.金额 - n_预交金额 < 0 Then
                   r_Deposit.金额
                  Else
                   n_预交金额
                End;
      If r_Deposit.结帐id = 0 Then
        --第一次冲预交(填上结帐ID,金额为0)
        Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 4 Where ID = r_Deposit.原预交id;
      End If;
      --冲上次剩余额
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结算序号, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 登记时间_In,
               操作员姓名_In, 操作员编号_In, n_当前金额, 结帐id_In, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结帐id_In, 4
        From 病人预交记录
        Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
    
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - n_当前金额
      Where 病人id = r_Deposit.病人id And 性质 = 1 And 类型 = Nvl(1, 2)
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (r_Deposit.病人id, Nvl(1, 2), -1 * n_当前金额, 1);
        n_返回值 := -1 * n_当前金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Deposit.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --检查是否已经处理完
      If r_Deposit.金额 < n_预交金额 Then
        n_预交金额 := n_预交金额 - r_Deposit.金额;
      Else
        n_预交金额 := 0;
      End If;
    
      If n_预交金额 = 0 Then
        Exit;
      End If;
    End Loop;
  End If;

  --对于医保挂号
  If Nvl(个帐支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 Then
    Insert Into 病人预交记录
      (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
       预交类别, 结算序号, 结算性质)
    Values
      (病人预交记录_Id.Nextval, 4, 1, No_In, 病人id_In, v_个人帐户, 个帐支付_In, d_Date, 操作员编号_In, 操作员姓名_In, 结帐id_In, '医保挂号', n_组id,
       卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, Null, Null, 结帐id_In, 4);
  End If;

  --相关汇总表的处理
  --人员缴款余额
  If Nvl(个帐支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 And Nvl(更新交款余额_In, 0) = 0 Then
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + 个帐支付_In
    Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = v_个人帐户
    Returning 余额 Into n_返回值;
  
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, v_个人帐户, 1, 个帐支付_In);
      n_返回值 := 个帐支付_In;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 人员缴款余额 Where 收款员 = 操作员姓名_In And 性质 = 1 And Nvl(余额, 0) = 0;
    End If;
  End If;

  --处理票据使用情况
  If 票据号_In Is Not Null And Nvl(记帐费用_In, 0) = 0 Then
    Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
  
    --当前票据的票种
    Select 票种 Into n_票种 From 票据领用记录 Where ID = Nvl(领用id_In, 0);
    --发出票据
    Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 4, No_In);
  
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
    Values
      (票据使用明细_Id.Nextval, n_票种, 票据号_In, 1, 1, 领用id_In, n_打印id, d_Date, 操作员姓名_In);
  
    --状态改动
    Update 票据领用记录
    Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = d_Date
    Where ID = Nvl(领用id_In, 0);
  End If;

  If Nvl(记帐费用_In, 0) = 1 Then
    --记帐
    If Nvl(病人id_In, 0) = 0 Then
      v_Err_Msg := '要针对病人的挂号费进行记帐，必须是建档病人才能记帐挂号。';
      Raise Err_Item;
    End If;
    For c_费用 In (Select 实收金额, 病人科室id, 开单部门id, 执行部门id, 收入项目id
                 From 门诊费用记录
                 Where 记录性质 = 4 And 记录状态 = 1 And NO = No_In And Nvl(记帐费用, 0) = 1) Loop
      --病人余额
      Update 病人余额
      Set 费用余额 = Nvl(费用余额, 0) + Nvl(c_费用.实收金额, 0)
      Where 病人id = Nvl(病人id_In, 0) And 性质 = 1 And 类型 = 1;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 费用余额, 预交余额)
        Values
          (病人id_In, 1, 1, Nvl(c_费用.实收金额, 0), 0);
      End If;
    
      --病人未结费用
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) + Nvl(c_费用.实收金额, 0)
      Where 病人id = 病人id_In And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(c_费用.病人科室id, 0) And
            Nvl(开单部门id, 0) = Nvl(c_费用.开单部门id, 0) And Nvl(执行部门id, 0) = Nvl(c_费用.执行部门id, 0) And 收入项目id + 0 = c_费用.收入项目id And
            来源途径 + 0 = 1;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人未结费用
          (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
        Values
          (病人id_In, Null, Null, c_费用.病人科室id, c_费用.开单部门id, c_费用.执行部门id, c_费用.收入项目id, 1, Nvl(c_费用.实收金额, 0));
      End If;
    End Loop;
  End If;
  If Nvl(病人id_In, 0) <> 0 Then
    n_结算模式 := 0;
    Update 病人信息
    Set 就诊时间 = d_发生时间, 就诊状态 = 1, 就诊诊室 = 诊室_In
    Where 病人id = 病人id_In
    Returning Nvl(结算模式, 0) Into n_结算模式;
    --取参数:
    If Nvl(n_结算模式, 0) <> Nvl(结算模式_In, 0) Then
      --结算模式的确定
      If n_结算模式 = 1 And Nvl(结算模式_In, 0) = 0 Then
        --病人已经是"先诊疗后结算的",本次是"先结算后诊疗的",则检查是否存在未结数据
        Select Count(1)
        Into n_Count
        From 病人未结费用
        Where 病人id = 病人id_In And (来源途径 In (1, 4) Or 来源途径 = 3 And Nvl(主页id, 0) = 0) And Nvl(金额, 0) <> 0 And Rownum < 2;
        If Nvl(n_Count, 0) <> 0 Then
          --存在未结算数据，必须先结算后才允许执行
          v_Err_Msg := '当前病人的就诊模式为先诊疗后结算且存在未结费用，不允许调整该病人的就诊模式,你可以先对未结费用结帐后再挂号或不调整病人的就诊模式!';
          Raise Err_Item;
        End If;
        --检查
        --未发生医嘱业务的（即当时就挂号的,需要保证同一次的就诊模式是一至的(程序已经检查，不用再处理)
      End If;
      Update 病人信息 Set 结算模式 = 结算模式_In Where 病人id = 病人id_In;
    End If;
  End If;

  --病人担保信息
  If 病人id_In Is Not Null Then
    Update 病人信息
    Set 担保人 = Null, 担保额 = Null, 担保性质 = Null
    Where 病人id = 病人id_In And Nvl(在院, 0) = 0 And Exists
     (Select 1
           From 病人担保记录
           Where 病人id = 病人id_In And 主页id Is Not Null And
                 登记时间 = (Select Max(登记时间) From 病人担保记录 Where 病人id = 病人id_In));
    If Sql%RowCount > 0 Then
      Update 病人担保记录
      Set 到期时间 = d_Date
      Where 病人id = 病人id_In And 主页id Is Not Null And Nvl(到期时间, d_Date) >= d_Date;
    End If;
  End If;
  --消息推送
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 1, n_挂号id;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Err_Special Then
    Raise_Application_Error(-20105, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_预约挂号接收_出诊_Insert;
/

--102760:刘尔旋,2016-11-23,支付宝并发错误提示更改
Create Or Replace Procedure Zl_预约挂号接收_Insert
(
  No_In            门诊费用记录.No%Type,
  票据号_In        门诊费用记录.实际票号%Type,
  领用id_In        票据使用明细.领用id%Type,
  结帐id_In        门诊费用记录.结帐id%Type,
  诊室_In          门诊费用记录.发药窗口%Type,
  病人id_In        门诊费用记录.病人id%Type,
  门诊号_In        门诊费用记录.标识号%Type,
  姓名_In          门诊费用记录.姓名%Type,
  性别_In          门诊费用记录.性别%Type,
  年龄_In          门诊费用记录.年龄%Type,
  付款方式_In      门诊费用记录.付款方式%Type, --用于存放病人的医疗付款方式编号
  费别_In          门诊费用记录.费别%Type,
  结算方式_In      病人预交记录.结算方式%Type, --现金的结算名称
  现金支付_In      病人预交记录.冲预交%Type, --挂号时现金支付部份金额
  预交支付_In      病人预交记录.冲预交%Type, --挂号时使用的预交金额
  个帐支付_In      病人预交记录.冲预交%Type, --挂号时个人帐户支付金额
  发生时间_In      门诊费用记录.发生时间%Type,
  号序_In          挂号序号状态.序号%Type,
  操作员编号_In    门诊费用记录.操作员编号%Type,
  操作员姓名_In    门诊费用记录.操作员姓名%Type,
  生成队列_In      Number := 0,
  登记时间_In      门诊费用记录.登记时间%Type := Null,
  卡类别id_In      病人预交记录.卡类别id%Type := Null,
  结算卡序号_In    病人预交记录.结算卡序号%Type := Null,
  卡号_In          病人预交记录.卡号%Type := Null,
  交易流水号_In    病人预交记录.交易流水号%Type := Null,
  交易说明_In      病人预交记录.交易说明%Type := Null,
  险类_In          病人挂号记录.险类%Type := Null,
  结算模式_In      Number := 0,
  记帐费用_In      Number := 0,
  冲预交病人ids_In Varchar2 := Null,
  三方调用_In      Number := 0,
  更新交款余额_In  Number := 0 --是否更新人员交款余额，主要是处理统一操作员登录多台自助机的情况
) As
  --该游标用于收费冲预交的可用预交列表
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit
  (
    v_病人id        病人信息.病人id%Type,
    v_冲预交病人ids Varchar2
  ) Is
    Select 病人id, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额, Min(记录状态) As 记录状态, Nvl(Max(结帐id), 0) As 结帐id,
           Max(Decode(记录性质, 1, ID, 0) * Decode(记录状态, 2, 0, 1)) As 原预交id
    From 病人预交记录
    Where 记录性质 In (1, 11) And 病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And Nvl(预交类别, 2) = 1
     Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
    Group By NO, 病人id
    Order By Decode(病人id, Nvl(v_病人id, 0), 0, 1), 结帐id, NO;

  v_Err_Msg Varchar2(255);
  Err_Item Exception;
  Err_Special Exception;

  v_现金     结算方式.名称%Type;
  v_个人帐户 结算方式.名称%Type;
  v_队列名称 排队叫号队列.队列名称%Type;
  v_号别     门诊费用记录.计算单位%Type;
  v_号序     门诊费用记录.发药窗口%Type;
  v_排队号码 排队叫号队列.排队号码 %Type;
  v_预约方式 病人挂号记录.预约方式 %Type;

  n_打印id        票据打印内容.Id%Type;
  n_预交金额      病人预交记录.金额%Type;
  n_返回值        病人预交记录.金额%Type;
  v_冲预交病人ids Varchar2(4000);

  n_挂号id         病人挂号记录.Id%Type;
  n_分诊台签到排队 Number;
  n_组id           财务缴款分组.Id%Type;
  n_Count          Number(18);
  n_排队           Number;
  n_当天排队       Number;
  n_当前金额       病人预交记录.金额%Type;
  n_预交id         病人预交记录.Id%Type;
  n_消费卡id       消费卡目录.Id%Type;
  n_自制卡         Number;

  d_Date       Date;
  d_预约时间   门诊费用记录.发生时间%Type;
  d_发生时间   Date;
  d_排队时间   Date;
  n_时段       Number := 0;
  n_存在       Number := 0;
  v_排队序号   排队叫号队列.排队序号%Type;
  n_结算模式   病人信息.结算模式%Type;
  n_票种       票据使用明细.票种%Type;
  v_付款方式   病人挂号记录.医疗付款方式%Type;
  v_操作员姓名 病人挂号记录.接收人%Type;
  n_接收模式   Number := 0;
Begin
  n_组id          := Zl_Get组id(操作员姓名_In);
  v_冲预交病人ids := Nvl(冲预交病人ids_In, 病人id_In);
  n_接收模式      := Nvl(zl_GetSysParameter('预约接收模式', 1111), 0);

  --获取结算方式名称
  Begin
    Select 名称 Into v_现金 From 结算方式 Where 性质 = 1;
  Exception
    When Others Then
      v_现金 := '现金';
  End;
  Begin
    Select 名称 Into v_个人帐户 From 结算方式 Where 性质 = 3;
  Exception
    When Others Then
      v_个人帐户 := '个人帐户';
  End;
  If 登记时间_In Is Null Then
    Select Sysdate Into d_Date From Dual;
  Else
    d_Date := 登记时间_In;
  End If;

  --更新挂号序号状态
  Begin
    Select 号别, 号序, Trunc(发生时间), 发生时间, 预约方式
    Into v_号别, v_号序, d_预约时间, d_发生时间, v_预约方式
    From 病人挂号记录
    Where 记录性质 = 2 And 记录状态 = 1 And Rownum = 1 And NO = No_In;
  Exception
    When Others Then
      Select Max(接收人) Into v_操作员姓名 From 病人挂号记录 Where 记录性质 = 2 And 记录状态 In (1, 3) And NO = No_In;
      If v_操作员姓名 Is Null Then
        v_Err_Msg := '当前预约挂号单已被取消';
        Raise Err_Item;
      Else
        If v_操作员姓名 = 操作员姓名_In Then
          v_Err_Msg := '当前预约挂号单已被接收';
          Raise Err_Special;
        Else
          v_Err_Msg := '当前预约挂号单已被其它人接收';
          Raise Err_Item;
        End If;
      End If;
  End;

  --判断是否分时段
  Begin
    Select 1
    Into n_时段
    From Dual
    Where Exists (Select 1
           From 挂号安排时段 A, 挂号安排 B
           Where a.安排id = b.Id And b.号码 = v_号别 And Rownum < 2
           Union All
           Select 1
           From 挂号计划时段 C, 挂号安排计划 D 　
           Where c.计划id = d.Id And d.号码 = v_号别 And d.生效时间 > Sysdate And Rownum < 2);
  Exception
    When Others Then
      n_时段 := 0;
  End;

  If n_时段 = 0 And 三方调用_In = 0 Then
    If n_接收模式 = 0 Then
      If Trunc(发生时间_In) = Trunc(Sysdate) Then
        d_发生时间 := 发生时间_In;
      Else
        d_发生时间 := Sysdate;
      End If;
    Else
      d_发生时间 := 发生时间_In;
    End If;
  Else
    If Not 发生时间_In Is Null Then
      d_发生时间 := 发生时间_In;
    End If;
  End If;
  If Not v_号序 Is Null Then
    If 号序_In Is Null Then
      Delete 挂号序号状态 Where 号码 = v_号别 And Trunc(日期) = Trunc(d_预约时间) And 序号 = v_号序;
    Else
      If Trunc(d_预约时间) <> Trunc(Sysdate) And n_接收模式 = 0 Then
      
        If n_时段 = 0 And 三方调用_In = 0 Then
          --提前接收或延迟接收
          Delete 挂号序号状态 Where 号码 = v_号别 And Trunc(日期) = Trunc(d_预约时间) And 序号 = v_号序;
          Begin
            Select 1 Into n_存在 From 挂号序号状态 Where 号码 = v_号别 And 日期 = Trunc(Sysdate) And 序号 = v_号序;
          Exception
            When Others Then
              n_存在 := 0;
          End;
          If n_存在 = 0 Then
            Insert Into 挂号序号状态
              (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
            Values
              (v_号别, Trunc(Sysdate), v_号序, 1, 操作员姓名_In, Sysdate);
          Else
            --号码已被使用的情况
            Begin
              v_号序 := 1;
              Insert Into 挂号序号状态
                (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
              Values
                (v_号别, Trunc(Sysdate), v_号序, 1, 操作员姓名_In, Sysdate);
            Exception
              When Others Then
                Select Min(序号 + 1)
                Into v_号序
                From 挂号序号状态 A
                Where 号码 = v_号别 And 日期 = Trunc(Sysdate) And Not Exists
                 (Select 1 From 挂号序号状态 Where 号码 = a.号码 And 日期 = a.日期 And 序号 = a.序号 + 1);
                Insert Into 挂号序号状态
                  (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
                Values
                  (v_号别, Trunc(Sysdate), v_号序, 1, 操作员姓名_In, Sysdate);
            End;
          End If;
        Else
          Update 挂号序号状态
          Set 状态 = 1, 登记时间 = Sysdate
          Where Trunc(日期) = Trunc(d_预约时间) And 序号 = v_号序 And 号码 = v_号别 And 状态 = 2;
          If Sql% NotFound Then
            Begin
              Insert Into 挂号序号状态
                (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
              Values
                (v_号别, Trunc(Sysdate), v_号序, 1, 操作员姓名_In, Sysdate);
            Exception
              When Others Then
                v_Err_Msg := '序号' || v_号序 || '已被其它人使用,请重新选择一个序号.';
                Raise Err_Item;
            End;
          End If;
        
        End If;
      
      Else
        Update 挂号序号状态
        Set 序号 = 号序_In, 状态 = 1, 登记时间 = Sysdate
        Where 号码 = v_号别 And Trunc(日期) = Trunc(d_预约时间) And 序号 = v_号序;
        If Sql%RowCount = 0 Then
          Begin
            Insert Into 挂号序号状态
              (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
            Values
              (v_号别, Trunc(d_发生时间), v_号序, 1, 操作员姓名_In, Sysdate);
          Exception
            When Others Then
              v_Err_Msg := '序号' || v_号序 || '已被其它人使用,请重新选择一个序号.';
              Raise Err_Item;
          End;
        End If;
      End If;
    End If;
  Else
    If Not 号序_In Is Null Then
      Begin
        Insert Into 挂号序号状态
          (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
        Values
          (v_号别, Trunc(Sysdate), 号序_In, 1, 操作员姓名_In, Sysdate);
      Exception
        When Others Then
          v_Err_Msg := '序号' || 号序_In || '已被其它人使用,请重新选择一个序号.';
          Raise Err_Item;
      End;
      v_号序 := 号序_In;
    Else
      v_号序 := Null;
    End If;
  End If;

  --更新门诊费用记录
  Update 门诊费用记录
  Set 记录状态 = 1, 实际票号 = Decode(Nvl(记帐费用_In, 0), 1, Null, 票据号_In), 结帐id = Decode(Nvl(记帐费用_In, 0), 1, Null, 结帐id_In),
      结帐金额 = Decode(Nvl(记帐费用_In, 0), 1, Null, 实收金额), 发药窗口 = 诊室_In, 病人id = 病人id_In, 标识号 = 门诊号_In, 姓名 = 姓名_In, 年龄 = 年龄_In,
      性别 = 性别_In, 付款方式 = 付款方式_In, 费别 = 费别_In, 发生时间 = d_发生时间, 登记时间 = d_Date, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In,
      缴款组id = n_组id, 记帐费用 = Decode(Nvl(记帐费用_In, 0), 1, 1, 0)
  Where 记录性质 = 4 And 记录状态 = 0 And NO = No_In;

  --病人挂号记录
  Update 病人挂号记录
  Set 接收人 = 操作员姓名_In, 接收时间 = d_Date, 记录性质 = 1, 病人id = 病人id_In, 门诊号 = 门诊号_In, 发生时间 = d_发生时间, 姓名 = 姓名_In, 性别 = 性别_In,
      年龄 = 年龄_In, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In, 险类 = Decode(Nvl(险类_In, 0), 0, Null, 险类_In), 号序 = v_号序, 诊室 = 诊室_In
  Where 记录状态 = 1 And NO = No_In And 记录性质 = 2
  Returning ID Into n_挂号id;
  If Sql%NotFound Then
    Begin
      Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
      Begin
        Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In And Rownum < 2;
      Exception
        When Others Then
          v_付款方式 := Null;
      End;
      Insert Into 病人挂号记录
        (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 操作员编号, 操作员姓名,
         摘要, 号序, 预约, 预约方式, 接收人, 接收时间, 预约时间, 险类, 医疗付款方式)
        Select n_挂号id, No_In, 1, 1, 病人id_In, 门诊号_In, 姓名_In, 性别_In, 年龄_In, 计算单位, 加班标志, 诊室_In, Null, 执行部门id, 执行人, 0, Null,
               登记时间, 发生时间, 操作员编号, 操作员姓名, 摘要, v_号序, 1, Substr(结论, 1, 10) As 预约方式, 操作员姓名_In, Nvl(登记时间_In, Sysdate), 发生时间,
               Decode(Nvl(险类_In, 0), 0, Null, 险类_In), v_付款方式
        From 门诊费用记录
        Where 记录性质 = 4 And 记录状态 = 1 And Rownum = 1 And NO = No_In;
    Exception
      When Others Then
        v_Err_Msg := '由于并发原因,单据号为【' || No_In || '】的病人' || 姓名_In || '已经被接收';
        Raise Err_Item;
    End;
  End If;

  --0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站
  If Nvl(生成队列_In, 0) <> 0 Then
    n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
    If Nvl(n_分诊台签到排队, 0) = 0 Then
      For v_挂号 In (Select ID, 姓名, 诊室, 执行人, 执行部门id, 发生时间, 号别, 号序 From 病人挂号记录 Where NO = No_In) Loop
      
        Begin
          Select 1,
                 Case
                   When 排队时间 < Trunc(Sysdate) Then
                    1
                   Else
                    0
                 End
          Into n_排队, n_当天排队
          From 排队叫号队列
          Where 业务类型 = 0 And 业务id = v_挂号.Id And Rownum <= 1;
        Exception
          When Others Then
            n_排队 := 0;
        End;
        If n_排队 = 0 Then
          --产生队列
          --按”执行部门”产生队列
          n_挂号id   := v_挂号.Id;
          v_队列名称 := v_挂号.执行部门id;
          v_排队号码 := Zlgetnextqueue(v_挂号.执行部门id, n_挂号id, v_挂号.号别 || '|' || v_挂号.号序);
          v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
        
          --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)
          d_排队时间 := Zl_Get_Queuedate(n_挂号id, v_挂号.号别, v_挂号.号序, v_挂号.发生时间);
          --   队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,排队标记_In,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In,
          Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, v_挂号.执行部门id, v_排队号码, Null, 姓名_In, 病人id_In, v_挂号.诊室, v_挂号.执行人, d_排队时间,
                           v_预约方式, Null, v_排队序号);
        Elsif Nvl(n_当天排队, 0) = 1 Then
          --更新队列号
          v_排队号码 := Zlgetnextqueue(v_挂号.执行部门id, v_挂号.Id, v_挂号.号别 || '|' || Nvl(v_挂号.号序, 0));
          v_排队序号 := Zlgetsequencenum(0, v_挂号.Id, 1);
          --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In, 医生姓名_In ,排队号码_In
          Zl_排队叫号队列_Update(v_挂号.执行部门id, 0, v_挂号.Id, v_挂号.执行部门id, v_挂号.姓名, v_挂号.诊室, v_挂号.执行人, v_排队号码, v_排队序号);
        
        Else
          --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In, 医生姓名_In ,排队号码_In
          Zl_排队叫号队列_Update(v_挂号.执行部门id, 0, v_挂号.Id, v_挂号.执行部门id, v_挂号.姓名, v_挂号.诊室, v_挂号.执行人);
        End If;
        --预约接收时，改变记录标志
        Update 病人挂号记录 Set 记录标志 = 1 Where ID = n_挂号id;
      End Loop;
    End If;
  End If;

  --汇总结算到病人预交记录
  If (Nvl(现金支付_In, 0) <> 0 Or (Nvl(现金支付_In, 0) = 0 And Nvl(个帐支付_In, 0) = 0 And Nvl(预交支付_In, 0) = 0)) And
     Nvl(记帐费用_In, 0) = 0 Then
    Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
    Insert Into 病人预交记录
      (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 结算序号,
       结算性质)
    Values
      (n_预交id, 4, 1, No_In, 病人id_In, Nvl(结算方式_In, v_现金), Nvl(现金支付_In, 0), d_Date, 操作员编号_In, 操作员姓名_In, 结帐id_In, '挂号收费',
       n_组id, 卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, 结帐id_In, 4);
  
    If Nvl(结算卡序号_In, 0) <> 0 And Nvl(现金支付_In, 0) <> 0 Then
    
      n_消费卡id := Null;
      Begin
        Select Nvl(自制卡, 0), 1 Into n_自制卡, n_Count From 卡消费接口目录 Where 编号 = 结算卡序号_In;
      Exception
        When Others Then
          n_Count := 0;
      End;
      If n_Count = 0 Then
        v_Err_Msg := '[ZLSOFT]没有发现原结算卡的相应类别,不能继续操作！[ZLSOFT]';
        Raise Err_Item;
      End If;
      If n_自制卡 = 1 Then
        Select ID
        Into n_消费卡id
        From 消费卡目录
        Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In And
              序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In);
      End If;
      Zl_病人卡结算记录_Insert(结算卡序号_In, n_消费卡id, 结算方式_In, 现金支付_In, 卡号_In, Null, 登记时间_In, Null, 结帐id_In, n_预交id);
    End If;
  
  End If;

  --对于就诊卡通过预交金挂号
  If Nvl(预交支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 Then
    n_预交金额 := 预交支付_In;
    For r_Deposit In c_Deposit(病人id_In, v_冲预交病人ids) Loop
      n_当前金额 := Case
                  When r_Deposit.金额 - n_预交金额 < 0 Then
                   r_Deposit.金额
                  Else
                   n_预交金额
                End;
      If r_Deposit.结帐id = 0 Then
        --第一次冲预交(填上结帐ID,金额为0)
        Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 4 Where ID = r_Deposit.原预交id;
      End If;
      --冲上次剩余额
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结算序号, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 登记时间_In,
               操作员姓名_In, 操作员编号_In, n_当前金额, 结帐id_In, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结帐id_In, 4
        From 病人预交记录
        Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
    
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - n_当前金额
      Where 病人id = r_Deposit.病人id And 性质 = 1 And 类型 = Nvl(1, 2)
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (r_Deposit.病人id, Nvl(1, 2), -1 * n_当前金额, 1);
        n_返回值 := -1 * n_当前金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Deposit.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --检查是否已经处理完
      If r_Deposit.金额 < n_预交金额 Then
        n_预交金额 := n_预交金额 - r_Deposit.金额;
      Else
        n_预交金额 := 0;
      End If;
    
      If n_预交金额 = 0 Then
        Exit;
      End If;
    End Loop;
  End If;

  --对于医保挂号
  If Nvl(个帐支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 Then
    Insert Into 病人预交记录
      (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
       预交类别, 结算序号, 结算性质)
    Values
      (病人预交记录_Id.Nextval, 4, 1, No_In, 病人id_In, v_个人帐户, 个帐支付_In, d_Date, 操作员编号_In, 操作员姓名_In, 结帐id_In, '医保挂号', n_组id,
       卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, Null, Null, 结帐id_In, 4);
  End If;

  --相关汇总表的处理
  --人员缴款余额
  If Nvl(现金支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 And Nvl(更新交款余额_In, 0) = 0 Then
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + 现金支付_In
    Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = Nvl(结算方式_In, v_现金)
    Returning 余额 Into n_返回值;
  
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额
        (收款员, 结算方式, 性质, 余额)
      Values
        (操作员姓名_In, Nvl(结算方式_In, v_现金), 1, 现金支付_In);
      n_返回值 := 现金支付_In;
    
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 人员缴款余额
      Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = Nvl(结算方式_In, v_现金) And Nvl(余额, 0) = 0;
    End If;
  End If;

  If Nvl(个帐支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 And Nvl(更新交款余额_In, 0) = 0 Then
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + 个帐支付_In
    Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = v_个人帐户
    Returning 余额 Into n_返回值;
  
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, v_个人帐户, 1, 个帐支付_In);
      n_返回值 := 个帐支付_In;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 人员缴款余额 Where 收款员 = 操作员姓名_In And 性质 = 1 And Nvl(余额, 0) = 0;
    End If;
  End If;

  --处理票据使用情况
  If 票据号_In Is Not Null And Nvl(记帐费用_In, 0) = 0 Then
    Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
  
    --当前票据的票种
    Select 票种 Into n_票种 From 票据领用记录 Where ID = Nvl(领用id_In, 0);
    --发出票据
    Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 4, No_In);
  
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
    Values
      (票据使用明细_Id.Nextval, n_票种, 票据号_In, 1, 1, 领用id_In, n_打印id, d_Date, 操作员姓名_In);
  
    --状态改动
    Update 票据领用记录
    Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = d_Date
    Where ID = Nvl(领用id_In, 0);
  End If;

  If Nvl(记帐费用_In, 0) = 1 Then
    --记帐
    If Nvl(病人id_In, 0) = 0 Then
      v_Err_Msg := '要针对病人的挂号费进行记帐，必须是建档病人才能记帐挂号。';
      Raise Err_Item;
    End If;
    For c_费用 In (Select 实收金额, 病人科室id, 开单部门id, 执行部门id, 收入项目id
                 From 门诊费用记录
                 Where 记录性质 = 4 And 记录状态 = 1 And NO = No_In And Nvl(记帐费用, 0) = 1) Loop
      --病人余额
      Update 病人余额
      Set 费用余额 = Nvl(费用余额, 0) + Nvl(c_费用.实收金额, 0)
      Where 病人id = Nvl(病人id_In, 0) And 性质 = 1 And 类型 = 1;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 费用余额, 预交余额)
        Values
          (病人id_In, 1, 1, Nvl(c_费用.实收金额, 0), 0);
      End If;
    
      --病人未结费用
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) + Nvl(c_费用.实收金额, 0)
      Where 病人id = 病人id_In And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(c_费用.病人科室id, 0) And
            Nvl(开单部门id, 0) = Nvl(c_费用.开单部门id, 0) And Nvl(执行部门id, 0) = Nvl(c_费用.执行部门id, 0) And 收入项目id + 0 = c_费用.收入项目id And
            来源途径 + 0 = 1;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人未结费用
          (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
        Values
          (病人id_In, Null, Null, c_费用.病人科室id, c_费用.开单部门id, c_费用.执行部门id, c_费用.收入项目id, 1, Nvl(c_费用.实收金额, 0));
      End If;
    End Loop;
  End If;
  If Nvl(病人id_In, 0) <> 0 Then
    n_结算模式 := 0;
    Update 病人信息
    Set 就诊时间 = d_发生时间, 就诊状态 = 1, 就诊诊室 = 诊室_In
    Where 病人id = 病人id_In
    Returning Nvl(结算模式, 0) Into n_结算模式;
    --取参数:
    If Nvl(n_结算模式, 0) <> Nvl(结算模式_In, 0) Then
      --结算模式的确定
      If n_结算模式 = 1 And Nvl(结算模式_In, 0) = 0 Then
        --病人已经是"先诊疗后结算的",本次是"先结算后诊疗的",则检查是否存在未结数据
        Select Count(1)
        Into n_Count
        From 病人未结费用
        Where 病人id = 病人id_In And (来源途径 In (1, 4) Or 来源途径 = 3 And Nvl(主页id, 0) = 0) And Nvl(金额, 0) <> 0 And Rownum < 2;
        If Nvl(n_Count, 0) <> 0 Then
          --存在未结算数据，必须先结算后才允许执行
          v_Err_Msg := '当前病人的就诊模式为先诊疗后结算且存在未结费用，不允许调整该病人的就诊模式,你可以先对未结费用结帐后再挂号或不调整病人的就诊模式!';
          Raise Err_Item;
        End If;
        --检查
        --未发生医嘱业务的（即当时就挂号的,需要保证同一次的就诊模式是一至的(程序已经检查，不用再处理)
      End If;
      Update 病人信息 Set 结算模式 = 结算模式_In Where 病人id = 病人id_In;
    End If;
  End If;

  --病人担保信息
  If 病人id_In Is Not Null Then
    Update 病人信息
    Set 担保人 = Null, 担保额 = Null, 担保性质 = Null
    Where 病人id = 病人id_In And Nvl(在院, 0) = 0 And Exists
     (Select 1
           From 病人担保记录
           Where 病人id = 病人id_In And 主页id Is Not Null And
                 登记时间 = (Select Max(登记时间) From 病人担保记录 Where 病人id = 病人id_In));
    If Sql%RowCount > 0 Then
      Update 病人担保记录
      Set 到期时间 = d_Date
      Where 病人id = 病人id_In And 主页id Is Not Null And Nvl(到期时间, d_Date) >= d_Date;
    End If;
  End If;
  --消息推送
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 1, n_挂号id;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Err_Special Then
    Raise_Application_Error(-20105, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_预约挂号接收_Insert;
/

--106331:刘尔旋,2017-02-22,支付宝重复提交检查问题
--102791:刘尔旋,2016-12-08,预约排队时按时点显示
--102760:刘尔旋,2016-11-23,支付宝并发错误提示更改
Create Or Replace Procedure Zl_三方机构挂号_Insert
(
  操作方式_In      Integer,
  病人id_In        门诊费用记录.病人id%Type,
  号码_In          挂号安排.号码%Type,
  号序_In          挂号序号状态.序号%Type,
  单据号_In        门诊费用记录.No%Type,
  票据号_In        门诊费用记录.实际票号%Type,
  结算方式_In      Varchar2,
  摘要_In          门诊费用记录.摘要%Type, --预约挂号摘要信息
  发生时间_In      门诊费用记录.发生时间%Type,
  登记时间_In      门诊费用记录.登记时间%Type,
  合作单位_In      挂号合作单位.名称%Type,
  挂号金额合计_In  门诊费用记录.实收金额%Type,
  领用id_In        票据使用明细.领用id%Type,
  收费票据_In      Number := 0, --挂号是否使用收费票据
  交易流水号_In    病人预交记录.交易流水号%Type,
  交易说明_In      病人预交记录.交易说明%Type,
  预约方式_In      预约方式.名称%Type := Null,
  预交id_In        病人预交记录.Id%Type := Null,
  卡类别id_In      病人预交记录.卡类别id%Type := Null,
  加入序号状态_In  Number := 0,
  是否自助设备_In  Number := 0,
  结帐id_In        门诊费用记录.结帐id%Type := Null,
  锁定类型_In      Number := 0,
  保险结算_In      Varchar2 := Null,
  冲预交_In        Number := Null,
  支付卡号_In      病人预交记录.卡号%Type := Null,
  退号重用_In      Number := 1,
  费别_In          门诊费用记录.费别%Type := Null,
  冲预交病人ids_In Varchar2 := Null,
  机器名_In        挂号序号状态.机器名%Type := Null,
  更新年龄_In      Number := 0,
  购买病历_In      Number := 0,
  出诊记录id_In    临床出诊记录.Id%Type := Null
) As
  --功能：三方机构进行挂号(包含预约;预约挂号不扣款;预约挂号扣款)
  --入参:操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
  --      结算方式_IN:支持多种结算方式,多种结算方式时，传入格式如下:结算方式名称1,金额,结算号码,三方卡标志|结算方式名称2,金额,结算号码,三方卡标志|...
  --      加入序号状态_In:1-表示强制加入挂号序号状态表中;否则根据启用序号或启用时段时才加入.
  --      是否自助设备_In:1-表示是医院的自助设备进行此函数的调用,自助设备调用此函数 允许加号,否则不允许
  --      锁定类型_In :0-产生正常数据 1-表示对单据进行锁定,产生未生效的单据信息;2-对锁定的记录进行解锁-生成正常数据:未生效的单据在银行扣款完成后进行解锁
  --      保险结算_IN:格式="结算方式|结算金额||....."
  --      冲预交病人ids_In:多个用逗分分离,冲预交时有效(冲预交类别与业务操作保持一致),主要是使用家属的预交款
  Err_Item Exception;
  Err_Special Exception;
  v_Err_Msg  Varchar2(255);
  n_打印id   票据打印内容.Id%Type;
  n_返回值   病人预交记录.金额%Type;
  v_排队号码 Varchar2(20);
  v_队列名称 排队叫号队列.队列名称%Type;
  n_预交id   病人预交记录.Id%Type;
  n_挂号id   病人挂号记录.Id%Type;
  v_结算内容 Varchar2(3000);
  v_当前结算 Varchar2(150);

  v_结算方式       病人预交记录.结算方式%Type;
  n_结算金额       病人预交记录.冲预交%Type;
  n_结算合计       Number(16, 5);
  n_预交金额       病人预交记录.冲预交%Type;
  n_组id           财务缴款分组.Id%Type;
  d_排队时间       Date;
  n_锁定           Number;
  n_同科限约一个号 Number(18);
  n_病人预约科室数 Number(18);
  n_已约科室       Number(18);

  n_合作单位限制       Number(18);
  n_是否开放           Number(1);
  n_Count              Number(18);
  n_行号               Number(18);
  n_序号               病人挂号记录.号序%Type;
  n_费用id             门诊费用记录.Id%Type;
  n_价格父号           Number(18);
  n_原项目id           收费项目目录.Id%Type;
  n_原收入项目id       收费项目目录.Id%Type;
  v_诊室               病人挂号记录.诊室%Type;
  n_安排id             挂号安排.Id%Type;
  n_实收金额合计       门诊费用记录.实收金额%Type;
  n_开单部门id         门诊费用记录.开单部门id%Type;
  n_实收金额           门诊费用记录.实收金额%Type;
  n_应收金额           门诊费用记录.实收金额%Type;
  n_结帐id             病人结帐记录.Id%Type;
  v_Temp               Varchar2(500);
  n_预约时段序号       Number;
  n_预约总数           Number;
  n_分时点显示         Number;
  d_时段开始时间       Date;
  v_冲预交病人ids      Varchar2(4000);
  v_收费项目ids        Varchar2(300);
  n_预约数量           合作单位挂号汇总.已约数%Type;
  n_号序               病人挂号记录.号序%Type;
  d_登记时间           Date;
  v_操作员编号         人员表.编号%Type;
  v_操作员姓名         人员表.姓名%Type;
  n_预约               Integer;
  v_星期               挂号安排时段.星期%Type;
  n_启用分时段         Integer;
  n_已挂数             病人挂号汇总.已挂数%Type;
  n_已约数             病人挂号汇总.已约数%Type;
  n_其中已接收         病人挂号汇总.已约数%Type;
  n_预约生成队列       Number;
  d_Date               Date;
  n_挂号序号           Number;
  n_Exists             Number;
  v_排队标记           排队叫号队列.排队标记%Type;
  v_排队序号           排队叫号队列.排队序号%Type;
  v_机器名             挂号序号状态.机器名%Type;
  v_序号操作员         挂号序号状态.操作员姓名%Type;
  v_序号机器名         挂号序号状态.机器名%Type;
  n_序号锁定           Number := 0;
  n_病历费id           收费特定项目.收费细目id%Type;
  v_付款方式           病人挂号记录.医疗付款方式%Type;
  v_费别               门诊费用记录.费别%Type;
  n_屏蔽费别           Number(3) := 0;
  n_Tmp安排id          挂号安排.Id%Type;
  n_计划id             挂号安排计划.Id%Type;
  v_年龄               病人信息.年龄%Type;
  n_合作单位限数量模式 Number;
  n_出诊记录id         临床出诊记录.Id%Type;
  n_挂号模式           Number(3);
  n_同科限号数         Number;
  n_同科限约数         Number;
  n_病人挂号科室数     Number;
  d_启用时间           Date;
  v_Para               Varchar2(2000);
  n_专家号挂号限制     Number;
  n_专家号预约限制     Number;
  v_时间段             时间段.时间段%Type;
  d_检查开始时间       时间段.开始时间%Type;
  d_检查结束时间       时间段.终止时间%Type;

  Cursor c_Pati(n_病人id 病人信息.病人id%Type) Is
    Select a.病人id, a.姓名, a.性别, a.年龄, a.住院号, a.门诊号, a.费别, a.险类, c.编码 As 付款方式
    From 病人信息 A, 医疗付款方式 C
    Where a.病人id = n_病人id And a.医疗付款方式 = c.名称(+);

  r_Pati c_Pati%RowType;

  --该游标用于收费冲预交的可用预交列表
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit
  (
    v_病人id        病人信息.病人id%Type,
    v_冲预交病人ids Varchar2
  ) Is
    Select 病人id, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额, Min(记录状态) As 记录状态, Nvl(Max(结帐id), 0) As 结帐id,
           Max(Decode(记录性质, 1, ID, 0) * Decode(记录状态, 2, 0, 1)) As 原预交id
    From 病人预交记录
    Where 记录性质 In (1, 11) And 病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And Nvl(预交类别, 2) = 1
     Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
    Group By NO, 病人id
    Order By Decode(病人id, Nvl(v_病人id, 0), 0, 1), 结帐id, NO;

  Cursor c_安排
  (
    v_号码        挂号安排.号码%Type,
    d_发生时间_In Date
  ) Is
    Select *
    From (With 安排时间段 As (Select 时间段
                         From (Select 时间段,
                                       To_Date(Decode(Sign(开始时间 - 终止时间), 1, '3000-01-09 ' || To_Char(开始时间, 'HH24:MI:SS'),
                                                       '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS')), 'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                       To_Date(Decode(Sign(开始时间 - 终止时间), 1, '3000-01-11 ' || To_Char(终止时间, 'HH24:MI:SS'),
                                                       '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS')), 'yyyy-mm-dd hh24:mi:ss') As 终止时间,
                                       To_Date('3000-01-10 ' || To_Char(d_发生时间_In, 'HH24:MI:SS'), 'yyyy-mm-dd hh24:mi:ss') As 当前时间,
                                       To_Date('3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS'), 'yyyy-mm-dd hh24:mi:ss') As 开始时间1,
                                       To_Date('3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS'), 'yyyy-mm-dd hh24:mi:ss') As 终止时间1
                                From 时间段)
                         Where 当前时间 Between 开始时间 And 终止时间1 Or 当前时间 Between 开始时间1 And 终止时间)
           Select Distinct p.Id, p.号类, p.号码, p.科室id, b.编码 As 科室编码, b.名称 As 科室名称, p.项目id, c.编码 As 项目编码, c.名称 As 项目名称,
                           p.医生id, d.编号 As 医生编号, p.医生姓名, p.限号数, p.限约数, p.周日 As 日, p.周一 As 一, p.周二 As 二, p.周三 As 三,
                           p.周四 As 四, p.周五 As 五, p.周六 As 六, p.序号控制, p.计划id
           From (Select p.Id, p.号码, p.号类, p.科室id, p.项目id, p.医生id, p.医生姓名, b.限号数, b.限约数, Nvl(p.病案必须, 0) As 病案必须, p.周日, p.周一,
                         p.周二, p.周三, p.周四, p.周五, p.周六, p.分诊方式, p.序号控制,
                         Decode(To_Char(d_发生时间_In, 'D'), '1', p.周日, '2', p.周一, '3', p.周二, '4', p.周三, '5', p.周四, '6', p.周五,
                                 '7', p.周六, Null) As 排班, Null As 计划id
                  From 挂号安排 P, 挂号安排限制 B
                  Where p.停用日期 Is Null And p.Id = b.安排id(+) And
                        b.限制项目(+) = Decode(To_Char(d_发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四',
                                           '6', '周五', '7', '周六', Null) And
                        d_发生时间_In Between Nvl(p.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                        Nvl(p.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Not Exists
                   (Select 1
                         From 挂号安排计划
                         Where 安排id = p.Id And (d_发生时间_In Between 生效时间 And 失效时间) And 审核时间 Is Not Null) And Not Exists
                   (Select 1
                         From 挂号安排停用状态
                         Where 安排id = p.Id And d_发生时间_In Between 开始停止时间 And 结束停止时间) And p.号码 = v_号码
                  Union All
                  Select c.Id, c.号码, c.号类, c.科室id, p.项目id, p.医生id, p.医生姓名, b.限号数, b.限约数, Nvl(c.病案必须, 0) As 病案必须, p.周日, p.周一,
                         p.周二, p.周三, p.周四, p.周五, p.周六, p.分诊方式, p.序号控制,
                         Decode(To_Char(d_发生时间_In, 'D'), '1', p.周日, '2', p.周一, '3', p.周二, '4', p.周三, '5', p.周四, '6', p.周五,
                                 '7', p.周六, Null) As 排班, p.Id As 计划id
                  From 挂号安排计划 P, 挂号安排 C, 挂号计划限制 B,
                       (Select Max(a.生效时间) As 生效, 安排id
                         From 挂号安排计划 A, 挂号安排 B
                         Where a.安排id = b.Id And a.审核时间 Is Not Null And
                               发生时间_In Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                               Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) And b.号码 = 号码_In
                         Group By 安排id) E
                  Where p.安排id = c.Id And p.Id = b.计划id(+) And p.生效时间 = e.生效 And p.安排id = e.安排id And
                        Nvl(p.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) = Nvl(e.生效, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                        b.限制项目(+) = Decode(To_Char(d_发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四',
                                           '6', '周五', '7', '周六', Null) And (d_发生时间_In Between p.生效时间 And p.失效时间) And
                        p.审核时间 Is Not Null And Not Exists
                   (Select 1
                         From 挂号安排停用状态
                         Where 安排id = c.Id And d_发生时间_In Between 开始停止时间 And 结束停止时间) And p.号码 = v_号码) P, 部门表 B, 收费项目目录 C,
                人员表 D
           Where p.科室id = b.Id And p.医生id = d.Id(+) And p.项目id = c.Id And
                 (c.撤档时间 Is Null Or c.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD')) And
                 (Nvl(p.医生id, 0) = 0 Or Exists
                  (Select 1
                   From 人员表 Q
                   Where p.医生id = q.Id And (q.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or q.撤档时间 Is Null))) And Exists
            (Select 1 From 安排时间段 Where 时间段 = p.排班))
           Order By 号码;


  r_安排 c_安排%RowType;

  Function Zl_诊室(号码_In 挂号安排.号码%Type) Return Varchar2 As
    n_分诊方式 挂号安排.分诊方式%Type;
    n_安排id   挂号安排.Id%Type;
    v_诊室     病人挂号记录.诊室%Type;
    v_Rowid    Varchar2(500);
    n_Next     Integer;
    n_First    Integer;
  Begin
  
    If 锁定类型_In = 2 Then
      --对单据进行解锁,首先检查是否存在锁定
      Select Count(Rowid) Into n_锁定 From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
      If n_锁定 = 0 Then
        v_Err_Msg := '单据号为(' || 单据号_In || ')的单据,不存在或者已经被解锁!';
        Raise Err_Item;
      End If;
      Select Max(号序) Into n_号序 From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
    End If;
  
    Begin
      Select ID, Nvl(分诊方式, 0) Into n_安排id, n_分诊方式 From 挂号安排 Where 号码 = 号码_In;
    Exception
      When Others Then
        n_安排id := -1;
    End;
  
    If n_安排id = -1 Then
      v_Err_Msg := '号码(' || 号码_In || ')未找到!';
      Raise Err_Item;
    End If;
    --0-不分诊、1-指定诊室、2-动态分诊、3-平均分诊,对应门诊诊室设置
    v_诊室 := Null;
    If n_分诊方式 = 1 Then
      --1-指定诊室
      Begin
        Select 门诊诊室 Into v_诊室 From 挂号安排诊室 Where 号表id = n_安排id;
      Exception
        When Others Then
          v_诊室 := Null;
      End;
    End If;
    If n_分诊方式 = 2 Then
      --2-动态分诊:该个号别当天挂号未诊数最少的诊室
      For c_诊室 In (Select 门诊诊室, Sum(Num) As Num
                   From (Select 门诊诊室, 0 As Num
                          From 挂号安排诊室
                          Where 号表id = n_安排id
                          Union All
                          Select 诊室, Count(诊室) As Num
                          From 病人挂号记录
                          Where Nvl(执行状态, 0) = 0 And 发生时间 Between Trunc(Sysdate) And Sysdate And 号别 = 号码_In And
                                诊室 In (Select 门诊诊室 From 挂号安排诊室 Where 号表id = n_安排id)
                          Group By 诊室)
                   Group By 门诊诊室
                   Order By Num) Loop
        v_诊室 := c_诊室.门诊诊室;
        Exit;
      End Loop;
    End If;
    If n_分诊方式 = 3 Then
    
      --平均分诊：当前分配=1表示下次应取的当前诊室
      n_Next  := 0;
      n_First := 1;
      For c_诊室 In (Select Rowid As Rid, 号表id, 门诊诊室, 当前分配 From 挂号安排诊室 Where 号表id = n_安排id) Loop
        If n_First = 1 Then
          v_Rowid := c_诊室.Rid;
        End If;
        If n_Next = 1 Then
          v_诊室 := c_诊室.门诊诊室;
          Update 挂号安排诊室 Set 当前分配 = 1 Where Rowid = c_诊室.Rid;
          Exit;
        End If;
        If Nvl(c_诊室.当前分配, 0) = 1 Then
          Update 挂号安排诊室 Set 当前分配 = 0 Where Rowid = c_诊室.Rid;
          n_Next := 1;
        End If;
      End Loop;
      If v_诊室 Is Null Then
        Update 挂号安排诊室 Set 当前分配 = 1 Where Rowid = v_Rowid Returning 门诊诊室 Into v_诊室;
      End If;
    End If;
  
    Return v_诊室;
  End;

  Function Zl_操作员
  (
    Type_In     Integer,
    Splitstr_In Varchar2
  ) Return Varchar2 As
    n_Step Number(18);
    v_Sub  Varchar2(1000);
    --Type_In:0-获取缺省部门ID;1-获取操作员编号;2-获取操作员姓名
    -- SplitStr:格式为:部门ID,部门名称;人员ID,人员编号,人员姓名(用Zl_Identity获取的)
  Begin
    If Type_In = 0 Then
      --缺省部门
      n_Step := Instr(Splitstr_In, ',');
      v_Sub  := Substr(Splitstr_In, 1, n_Step - 1);
      Return v_Sub;
    End If;
    If Type_In = 1 Then
      --操作员编码
      n_Step := Instr(Splitstr_In, ';');
      v_Sub  := Substr(Splitstr_In, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, 1, n_Step - 1);
      Return v_Sub;
    End If;
    If Type_In = 2 Then
      --操作员姓名
      n_Step := Instr(Splitstr_In, ';');
      v_Sub  := Substr(Splitstr_In, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      Return v_Sub;
    End If;
  End;

  Procedure Zl_三方机构挂号_出诊_Insert
  (
    记录id_In        临床出诊记录.Id%Type,
    操作方式_In      Integer,
    病人id_In        门诊费用记录.病人id%Type,
    号码_In          挂号安排.号码%Type,
    号序_In          挂号序号状态.序号%Type,
    单据号_In        门诊费用记录.No%Type,
    票据号_In        门诊费用记录.实际票号%Type,
    结算方式_In      Varchar2,
    摘要_In          门诊费用记录.摘要%Type, --预约挂号摘要信息
    发生时间_In      门诊费用记录.发生时间%Type,
    登记时间_In      门诊费用记录.登记时间%Type,
    合作单位_In      挂号合作单位.名称%Type,
    挂号金额合计_In  门诊费用记录.实收金额%Type,
    领用id_In        票据使用明细.领用id%Type,
    收费票据_In      Number := 0, --挂号是否使用收费票据
    交易流水号_In    病人预交记录.交易流水号%Type,
    交易说明_In      病人预交记录.交易说明%Type,
    预约方式_In      预约方式.名称%Type := Null,
    预交id_In        病人预交记录.Id%Type := Null,
    卡类别id_In      病人预交记录.卡类别id%Type := Null,
    加入序号状态_In  Number := 0,
    是否自助设备_In  Number := 0,
    结帐id_In        门诊费用记录.结帐id%Type := Null,
    锁定类型_In      Number := 0,
    保险结算_In      Varchar2 := Null,
    冲预交_In        Number := Null,
    支付卡号_In      病人预交记录.卡号%Type := Null,
    退号重用_In      Number := 1,
    费别_In          门诊费用记录.费别%Type := Null,
    冲预交病人ids_In Varchar2 := Null,
    机器名_In        挂号序号状态.机器名%Type := Null,
    更新年龄_In      Number := 0,
    购买病历_In      Number := 0
  ) As
    --功能：三方机构进行挂号(包含预约;预约挂号不扣款;预约挂号扣款),出诊表排班模式下使用
    --入参: 操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
    --      加入序号状态_In:1-表示强制加入挂号序号状态表中;否则根据启用序号或启用时段时才加入.
    --      是否自助设备_In:1-表示是医院的自助设备进行此函数的调用,自助设备调用此函数 允许加号,否则不允许
    --      锁定类型_In :0-产生正常数据 1-表示对单据进行锁定,产生未生效的单据信息;2-对锁定的记录进行解锁-生成正常数据:未生效的单据在银行扣款完成后进行解锁
    --      保险结算_IN:格式="结算方式|结算金额||....."
    --      冲预交病人ids_In:多个用逗分分离,冲预交时有效(冲预交类别与业务操作保持一致),主要是使用家属的预交款
    Err_Item Exception;
    Err_Special Exception;
    v_Err_Msg  Varchar2(255);
    n_打印id   票据打印内容.Id%Type;
    n_返回值   病人预交记录.金额%Type;
    v_排队号码 Varchar2(20);
    v_队列名称 排队叫号队列.队列名称%Type;
    n_预交id   病人预交记录.Id%Type;
    n_挂号id   病人挂号记录.Id%Type;
    v_结算内容 Varchar2(3000);
    v_当前结算 Varchar2(150);
  
    v_结算方式       病人预交记录.结算方式%Type;
    n_结算金额       病人预交记录.冲预交%Type;
    n_结算合计       Number(16, 5);
    n_预交金额       病人预交记录.冲预交%Type;
    n_组id           财务缴款分组.Id%Type;
    d_排队时间       Date;
    n_锁定           Number;
    n_同科限约一个号 Number(18);
    n_病人预约科室数 Number(18);
    n_已约科室       Number(18);
  
    n_合作单位限制       Number(18);
    n_是否开放           Number(1);
    n_Count              Number(18);
    n_行号               Number(18);
    n_序号               病人挂号记录.号序%Type;
    n_费用id             门诊费用记录.Id%Type;
    n_价格父号           Number(18);
    n_原项目id           收费项目目录.Id%Type;
    n_原收入项目id       收费项目目录.Id%Type;
    v_诊室               病人挂号记录.诊室%Type;
    n_安排id             挂号安排.Id%Type;
    n_实收金额合计       门诊费用记录.实收金额%Type;
    n_开单部门id         门诊费用记录.开单部门id%Type;
    n_实收金额           门诊费用记录.实收金额%Type;
    n_应收金额           门诊费用记录.实收金额%Type;
    n_结帐id             病人结帐记录.Id%Type;
    v_Temp               Varchar2(500);
    v_结算方式记录       Varchar2(1000);
    n_预约时段序号       Number;
    n_序号控制           临床出诊记录.是否序号控制%Type;
    n_限约数             临床出诊记录.限约数%Type;
    n_项目id             临床出诊记录.项目id%Type;
    n_科室id             临床出诊记录.科室id%Type;
    d_终止时间           临床出诊记录.终止时间%Type;
    v_医生姓名           临床出诊记录.医生姓名%Type;
    n_医生id             临床出诊记录.医生id%Type;
    n_预约顺序号         临床出诊序号控制.预约顺序号%Type;
    n_预约总数           Number;
    n_分时点显示         Number;
    d_时段开始时间       Date;
    d_时段终止时间       Date;
    v_收费项目ids        Varchar2(300);
    n_三方卡标志         Number;
    n_预约数量           合作单位挂号汇总.已约数%Type;
    n_号序               病人挂号记录.号序%Type;
    d_登记时间           Date;
    n_单笔金额           病人预交记录.冲预交%Type;
    v_结算号码           病人预交记录.结算号码%Type;
    v_操作员编号         人员表.编号%Type;
    v_操作员姓名         人员表.姓名%Type;
    n_预约               Integer;
    v_现金               病人预交记录.结算方式%Type;
    v_星期               挂号安排时段.星期%Type;
    n_启用分时段         Integer;
    n_已挂数             病人挂号汇总.已挂数%Type;
    n_已约数             病人挂号汇总.已约数%Type;
    n_其中已接收         病人挂号汇总.已约数%Type;
    n_预约生成队列       Number;
    n_限号数             临床出诊记录.限号数%Type;
    d_Date               Date;
    n_挂号序号           Number;
    v_排队标记           排队叫号队列.排队标记%Type;
    v_排队序号           排队叫号队列.排队序号%Type;
    v_机器名             挂号序号状态.机器名%Type;
    v_序号操作员         挂号序号状态.操作员姓名%Type;
    v_序号机器名         挂号序号状态.机器名%Type;
    n_序号锁定           Number := 0;
    n_病历费id           收费特定项目.收费细目id%Type;
    v_付款方式           病人挂号记录.医疗付款方式%Type;
    v_费别               门诊费用记录.费别%Type;
    n_屏蔽费别           Number(3) := 0;
    v_年龄               病人信息.年龄%Type;
    n_合作单位限数量模式 Number;
    n_同科限号数         Number;
    n_同科限约数         Number;
    n_病人挂号科室数     Number;
    n_Exists             Number(5);
    v_冲预交病人ids      Varchar2(4000);
    n_替诊医生id         临床出诊记录.替诊医生id%Type;
    v_替诊医生姓名       临床出诊记录.替诊医生姓名%Type;
    d_替诊开始时间       临床出诊记录.替诊开始时间%Type;
    d_替诊终止时间       临床出诊记录.替诊终止时间%Type;
    n_专家号挂号限制     Number;
    n_专家号预约限制     Number;
  
    Cursor c_Pati(n_病人id 病人信息.病人id%Type) Is
      Select a.病人id, a.姓名, a.性别, a.年龄, a.住院号, a.门诊号, a.费别, a.险类, c.编码 As 付款方式
      From 病人信息 A, 医疗付款方式 C
      Where a.病人id = n_病人id And a.医疗付款方式 = c.名称(+);
  
    r_Pati c_Pati%RowType;
  
    --该游标用于收费冲预交的可用预交列表
    --以ID排序，优先冲上次未冲完的。
    Cursor c_Deposit
    (
      v_病人id        病人信息.病人id%Type,
      v_冲预交病人ids Varchar2
    ) Is
      Select 病人id, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额, Min(记录状态) As 记录状态, Nvl(Max(结帐id), 0) As 结帐id,
             Max(Decode(记录性质, 1, ID, 0) * Decode(记录状态, 2, 0, 1)) As 原预交id
      From 病人预交记录
      Where 记录性质 In (1, 11) And 病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And Nvl(预交类别, 2) = 1
       Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
      Group By NO, 病人id
      Order By Decode(病人id, Nvl(v_病人id, 0), 0, 1), 结帐id, NO;
  
    Function Zl_诊室(记录id_In 临床出诊记录.Id%Type) Return Varchar2 As
      n_分诊方式 临床出诊记录.分诊方式%Type;
      v_诊室     病人挂号记录.诊室%Type;
      v_Rowid    Varchar2(500);
      n_Next     Integer;
      n_First    Integer;
    Begin
    
      If 锁定类型_In = 2 Then
        --对单据进行解锁,首先检查是否存在锁定
        Select Count(Rowid)
        Into n_锁定
        From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
        If n_锁定 = 0 Then
          v_Err_Msg := '单据号为(' || 单据号_In || ')的单据,不存在或者已经被解锁!';
          Raise Err_Item;
        End If;
        Select Max(号序) Into n_号序 From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
      End If;
    
      Begin
        Select Nvl(分诊方式, 0) Into n_分诊方式 From 临床出诊记录 Where ID = 记录id_In;
      Exception
        When Others Then
          v_Err_Msg := '出诊记录(' || 记录id_In || ')未找到!';
          Raise Err_Item;
      End;
    
      --0-不分诊、1-指定诊室、2-动态分诊、3-平均分诊,对应门诊诊室设置
      v_诊室 := Null;
      If n_分诊方式 = 1 Then
        --1-指定诊室
        Begin
          Select b.名称 Into v_诊室 From 临床出诊诊室记录 A, 门诊诊室 B Where a.诊室id = b.Id And a.记录id = 记录id_In;
        Exception
          When Others Then
            v_诊室 := Null;
        End;
      End If;
      If n_分诊方式 = 2 Then
        --2-动态分诊:该个号别当天挂号未诊数最少的诊室
        For c_诊室 In (Select 门诊诊室, Sum(Num) As Num
                     From (Select b.名称 As 门诊诊室, 0 As Num
                            From 临床出诊诊室记录 A, 门诊诊室 B
                            Where a.诊室id = b.Id And a.记录id = 记录id_In
                            Union All
                            Select 诊室, Count(诊室) As Num
                            From 病人挂号记录
                            Where Nvl(执行状态, 0) = 0 And 发生时间 Between Trunc(Sysdate) And Sysdate And 号别 = 号码_In And
                                  诊室 In (Select d.名称
                                         From 临床出诊诊室记录 C, 门诊诊室 D
                                         Where c.诊室id = d.Id And c.记录id = 记录id_In)
                            Group By 诊室)
                     Group By 门诊诊室
                     Order By Num) Loop
          v_诊室 := c_诊室.门诊诊室;
          Exit;
        End Loop;
      End If;
      If n_分诊方式 = 3 Then
        --平均分诊：当前分配=1表示下次应取的当前诊室
        n_Next  := 0;
        n_First := 1;
        For c_诊室 In (Select a.Rowid As Rid, b.名称 As 门诊诊室, a.当前分配
                     From 临床出诊诊室记录 A, 门诊诊室 B
                     Where a.诊室id = b.Id And a.记录id = 记录id_In) Loop
          If n_First = 1 Then
            v_Rowid := c_诊室.Rid;
          End If;
          If n_Next = 1 Then
            v_诊室 := c_诊室.门诊诊室;
            Update 临床出诊诊室记录 Set 当前分配 = 1 Where Rowid = c_诊室.Rid;
            Exit;
          End If;
          If Nvl(c_诊室.当前分配, 0) = 1 Then
            Update 临床出诊诊室记录 Set 当前分配 = 0 Where Rowid = c_诊室.Rid;
            n_Next := 1;
          End If;
        End Loop;
        If v_诊室 Is Null Then
          Update 临床出诊诊室记录 Set 当前分配 = 1 Where Rowid = v_Rowid Returning 诊室id Into v_诊室;
          Select 名称 Into v_诊室 From 门诊诊室 Where ID = v_诊室;
        End If;
      End If;
      Return v_诊室;
    End;
  
    Function Zl_操作员
    (
      Type_In     Integer,
      Splitstr_In Varchar2
    ) Return Varchar2 As
      n_Step Number(18);
      v_Sub  Varchar2(1000);
      --Type_In:0-获取缺省部门ID;1-获取操作员编号;2-获取操作员姓名
      -- SplitStr:格式为:部门ID,部门名称;人员ID,人员编号,人员姓名(用Zl_Identity获取的)
    Begin
      If Type_In = 0 Then
        --缺省部门
        n_Step := Instr(Splitstr_In, ',');
        v_Sub  := Substr(Splitstr_In, 1, n_Step - 1);
        Return v_Sub;
      End If;
      If Type_In = 1 Then
        --操作员编码
        n_Step := Instr(Splitstr_In, ';');
        v_Sub  := Substr(Splitstr_In, n_Step + 1);
        n_Step := Instr(v_Sub, ',');
        v_Sub  := Substr(v_Sub, n_Step + 1);
        n_Step := Instr(v_Sub, ',');
        v_Sub  := Substr(v_Sub, 1, n_Step - 1);
        Return v_Sub;
      End If;
      If Type_In = 2 Then
        --操作员姓名
        n_Step := Instr(Splitstr_In, ';');
        v_Sub  := Substr(Splitstr_In, n_Step + 1);
        n_Step := Instr(v_Sub, ',');
        v_Sub  := Substr(v_Sub, n_Step + 1);
        n_Step := Instr(v_Sub, ',');
        v_Sub  := Substr(v_Sub, n_Step + 1);
        Return v_Sub;
      End If;
    End;
  
  Begin
    v_冲预交病人ids := Nvl(冲预交病人ids_In, 病人id_In);
    Begin
      Select 名称 Into v_现金 From 结算方式 Where 性质 = 1;
    Exception
      When Others Then
        v_现金 := '现金';
    End;
  
    If 费别_In Is Null Then
      Select Zl_Custom_Getpatifeetype(1, 病人id_In) Into v_费别 From Dual;
    Else
      v_费别 := 费别_In;
    End If;
    If v_费别 Is Null Then
      n_屏蔽费别 := 1;
      Select 名称 Into v_费别 From 费别 Where 缺省标志 = 1 And Rownum < 2;
    End If;
    Update 病人信息 Set 费别 = v_费别 Where 病人id = 病人id_In;
  
    If 更新年龄_In = 1 Then
      Select Zl_Age_Calc(病人id_In) Into v_年龄 From Dual;
      If v_年龄 Is Not Null Then
        Update 病人信息 Set 年龄 = v_年龄 Where 病人id = 病人id_In;
      End If;
    End If;
    --获取当前机器名称
    If 机器名_In Is Not Null Then
      v_机器名 := 机器名_In;
    Else
      Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
    End If;
    n_实收金额合计 := 0;
  
    Select Count(*) + 1
    Into n_挂号序号
    From 病人挂号记录
    Where 出诊记录id = 记录id_In And 登记时间 Between Trunc(发生时间_In) And Trunc(发生时间_In + 1) - 1 / 24 / 60 / 60;
  
    If 登记时间_In Is Null Then
      d_登记时间 := Sysdate;
    Else
      d_登记时间 := 登记时间_In;
    End If;
    If Trunc(Sysdate) > Trunc(发生时间_In) Then
      v_Err_Msg := '不能挂以前的号(' || To_Char(发生时间_In, 'yyyy-mm-dd') || ')。';
      Raise Err_Item;
    End If;
  
    v_Temp           := Nvl(zl_GetSysParameter('病人同科限挂N个号', 1111), '0|0') || '|';
    n_同科限号数     := To_Number(Substr(v_Temp, 1, Instr(v_Temp, '|') - 1));
    n_同科限约数     := To_Number(Nvl(zl_GetSysParameter('病人同科限约N个号', 1111), '0'));
    n_病人预约科室数 := To_Number(Nvl(zl_GetSysParameter('病人预约科室数', 1111), '0'));
    n_病人挂号科室数 := To_Number(Nvl(zl_GetSysParameter('病人挂号科室限制', 1111), '0'));
    n_专家号挂号限制 := To_Number(Nvl(zl_GetSysParameter('专家号挂号限制'), '0'));
    n_专家号预约限制 := To_Number(Nvl(zl_GetSysParameter('专家号预约限制'), '0'));
  
    --部门ID,部门名称;人员ID,人员编号,人员姓名
    v_Temp := Zl_Identity(0);
    If Nvl(v_Temp, ' ') = ' ' Then
      v_Err_Msg := '当前操作人员未设置对应的人员关系,不能继续。';
      Raise Err_Item;
    End If;
    n_开单部门id := To_Number(Zl_操作员(0, v_Temp));
    v_操作员编号 := Zl_操作员(1, v_Temp);
    v_操作员姓名 := Zl_操作员(2, v_Temp);
    n_组id       := Zl_Get组id(v_操作员姓名);
  
    --支付宝并发提交检查
    Select Nvl(Max(1), 0)
    Into n_Exists
    From 病人挂号记录
    Where 病人id = 病人id_In And 号别 = 号码_In And 号序 = 号序_In And 操作员姓名 = v_操作员姓名 And Nvl(记录id_In, 0) = Nvl(出诊记录id, 0) And
          登记时间 > Sysdate - 0.01 And 记录状态 = 1 And 发生时间 = 发生时间_In;
    If n_Exists = 1 Then
      v_Err_Msg := '病人已经挂号,不能重复挂相同的号！';
      Raise Err_Special;
    End If;
  
    If 操作方式_In <> 1 Then
      --预约检查是否添加合作单位控制
      --如果设置了合作单位控制 则
      Begin
        Select 1
        Into n_合作单位限制
        From 临床出诊挂号控制记录
        Where 记录id = 记录id_In And 类型 = 1 And 性质 = 1 And 控制方式 <> 4 And Rownum < 2;
      Exception
        When Others Then
          n_合作单位限制 := 0;
      End;
    End If;
  
    If 操作方式_In <> 2 Then
      v_诊室 := Zl_诊室(记录id_In);
    End If;
  
    --因为现在有按日编单据号规则,日挂号量不能超过10000次,所以要检查唯一约束。
    Select Count(*) Into n_Count From 门诊费用记录 Where 记录性质 = 4 And 记录状态 In (1, 3) And NO = 单据号_In;
    If n_Count <> 0 Then
      v_Err_Msg := '挂号单据号重复,不能保存！' || Chr(13) || '如果使用了按日顺序编号,当日挂号量不能超过10000人次。';
      Raise Err_Item;
    End If;
  
    Open c_Pati(病人id_In);
    n_Count := 0;
    Begin
      Fetch c_Pati
        Into r_Pati;
    Exception
      When Others Then
        n_Count := -1;
    End;
    If n_Count = -1 Then
      v_Err_Msg := '病人未找到，不能继续。';
      Raise Err_Item;
    End If;
  
    Begin
      Select Nvl(是否分时段, 0), 限号数, 已挂数, 其中已接收, 已约数, 是否序号控制, 限约数, 项目id, 科室id, 医生id, 医生姓名, 替诊医生id, 替诊医生姓名, 替诊开始时间, 替诊终止时间
      Into n_启用分时段, n_限号数, n_已挂数, n_其中已接收, n_已约数, n_序号控制, n_限约数, n_项目id, n_科室id, n_医生id, v_医生姓名, n_替诊医生id, v_替诊医生姓名,
           d_替诊开始时间, d_替诊终止时间
      From 临床出诊记录
      Where ID = 记录id_In And Nvl(是否锁定, 0) = 0;
    Exception
      When Others Then
        n_Count := -1;
    End;
    If n_Count = -1 Then
      v_Err_Msg := '该号别没有在' || To_Char(发生时间_In, 'yyyy-mm-dd hh24:mi:ss') || '中进行安排。';
      Raise Err_Item;
    End If;
  
    If 发生时间_In Between Nvl(d_替诊开始时间, Sysdate) And Nvl(d_替诊终止时间, Sysdate - 1) And v_替诊医生姓名 Is Not Null Then
      n_医生id   := n_替诊医生id;
      v_医生姓名 := v_替诊医生姓名;
    End If;
  
    --对参数控制进行检查
    --仅在预约不扣款时进行检查
    If 操作方式_In = 2 Then
      If Nvl(n_同科限约数, 0) <> 0 Or Nvl(n_病人预约科室数, 0) <> 0 Then
        n_已约科室 := 0;
        For c_Chkitem In (Select Distinct 执行部门id
                          From 病人挂号记录
                          Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 2 And 预约时间 Between Trunc(发生时间_In) And
                                Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id <> n_科室id) Loop
          n_已约科室 := n_已约科室 + 1;
        End Loop;
        If n_已约科室 >= Nvl(n_病人预约科室数, 0) And Nvl(n_病人预约科室数, 0) > 0 Then
          v_Err_Msg := '同一病人最多同时能预约[' || Nvl(n_病人预约科室数, 0) || ']个科室,不能再预约！';
          Raise Err_Item;
        End If;
      
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 2 And 预约时间 Between Trunc(发生时间_In) And
              Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id = n_科室id;
        If n_Count >= Nvl(n_同科限约数, 0) And Nvl(n_同科限约数, 0) > 0 Then
          v_Err_Msg := '该病人已经在该科室预约了' || n_Count || '次,不能再预约！';
          Raise Err_Item;
        End If;
      End If;
      If Nvl(n_专家号预约限制, 0) <> 0 Then
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 2 And 出诊记录id = 记录id_In;
        If n_Count >= Nvl(n_专家号预约限制, 0) And Nvl(n_专家号预约限制, 0) > 0 Then
          v_Err_Msg := '该病人已经超过本号预约限制,不能再预约！';
          Raise Err_Item;
        End If;
      End If;
    Else
      If Nvl(n_同科限号数, 0) <> 0 Or Nvl(n_病人挂号科室数, 0) <> 0 Then
        n_已约科室 := 0;
        For c_Chkitem In (Select Distinct 执行部门id
                          From 病人挂号记录
                          Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 1 And 发生时间 Between Trunc(发生时间_In) And
                                Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id <> n_科室id) Loop
          n_已约科室 := n_已约科室 + 1;
        End Loop;
        If n_已约科室 >= Nvl(n_病人挂号科室数, 0) And Nvl(n_病人挂号科室数, 0) > 0 Then
          v_Err_Msg := '同一病人最多同时能挂号[' || Nvl(n_病人挂号科室数, 0) || ']个科室,不能再挂号！';
          Raise Err_Item;
        End If;
      
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 1 And 发生时间 Between Trunc(发生时间_In) And
              Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id = n_科室id;
        If n_Count >= Nvl(n_同科限号数, 0) And Nvl(n_同科限号数, 0) > 0 Then
          v_Err_Msg := '该病人已经在该科室挂号了' || n_Count || '次,不能再挂号！';
          Raise Err_Item;
        End If;
      End If;
      If Nvl(n_专家号挂号限制, 0) <> 0 Then
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 1 And 出诊记录id = 记录id_In;
        If n_Count >= Nvl(n_专家号挂号限制, 0) And Nvl(n_专家号挂号限制, 0) > 0 Then
          v_Err_Msg := '该病人已经超过本号挂号限制,不能再挂号！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  
    d_Date         := Null;
    d_时段开始时间 := Null;
  
    If Nvl(n_限号数, 0) >= 0 Or n_限号数 Is Null Then
      If n_启用分时段 = 1 Then
        If Nvl(n_序号控制, 0) = 1 Then
          If Nvl(是否自助设备_In, 0) = 0 Then
            Select Count(*), Max(开始时间)
            Into n_Count, d_时段开始时间
            From 临床出诊序号控制
            Where 记录id = 记录id_In And 序号 = Nvl(号序_In, 0);
          
            v_Temp := '挂号';
            If 操作方式_In > 1 Then
              v_Temp := '预约挂号';
            End If;
          
            If n_Count = 0 Then
              v_Err_Msg := '号别为' || 号码_In || '的挂号安排中不存在序号为' || Nvl(号序_In, 0) || '的安排,不能再' || v_Temp || '！';
              Raise Err_Item;
            End If;
          End If;
        
          --过点的,不能选择挂号
          If Trunc(Sysdate) = Trunc(发生时间_In) Then
            --挂当天的号
            v_Temp := To_Char(Sysdate, 'yyyy-mm-dd') || ' ';
            For v_时段 In (Select To_Date(v_Temp || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                To_Date(To_Char(Sysdate + Decode(Sign(开始时间 - 终止时间), 1, 1, 0), 'yyyy-mm-dd') || ' ' ||
                                         To_Char(终止时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 终止时间, 数量, 是否预约
                         From 临床出诊序号控制
                         Where 记录id = 记录id_In And 序号 = Nvl(号序_In, 0)) Loop
              If Sysdate > v_时段.终止时间 Then
                v_Err_Msg := '号别为' || 号码_In || '及号序为' || Nvl(号序_In, 0) || '的安排,已经超过时点,不能再' || v_Temp || '！';
                Raise Err_Item;
              End If;
            End Loop;
          End If;
        Elsif 操作方式_In > 1 Then
          --未启用序号的,需要检查预约的情况
          n_Count := 0;
          For v_时段 In (Select 序号, 开始时间, 终止时间, 数量, 是否预约
                       From 临床出诊序号控制
                       Where 记录id = 记录id_In And
                             (('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                             Decode(Sign(开始时间 - 终止时间 - 1 / 24 / 60 / 60), 1,
                                      '3000-01-09 ' || To_Char(开始时间, 'HH24:MI:SS'),
                                      '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS')) And
                             '3000-01-10 ' || To_Char(终止时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS')) Or
                             ('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                             '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS') And
                             Decode(Sign(开始时间 - 终止时间 - 1 / 24 / 60 / 60), 1,
                                      '3000-01-11 ' || To_Char(终止时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'),
                                      '3000-01-10 ' || To_Char(终止时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'))))) Loop
            n_预约时段序号 := v_时段.序号;
            d_时段开始时间 := v_时段.开始时间;
            d_时段终止时间 := v_时段.终止时间;
          
            Select Count(*), Max(序号), Max(预约顺序号) + 1
            Into n_Count, n_预约总数, n_预约顺序号
            From 临床出诊序号控制
            Where 记录id = 记录id_In And Nvl(挂号状态, 0) Not In (0, 4, 5);
          
            If Nvl(n_Count, 0) > Nvl(v_时段.数量, 0) And 锁定类型_In <> 2 Then
              v_Err_Msg := '号别为' || 号码_In || '的挂号安排中在' || To_Char(v_时段.开始时间, 'hh24:mi:ss') || '至' ||
                           To_Char(v_时段.终止时间, 'hh24:mi:ss') || '最多只能预约' || Nvl(v_时段.数量, 0) || '人,不能再进行预约挂号！';
              Raise Err_Item;
            End If;
            n_Count := 1;
          End Loop;
        
          If n_Count = 0 Then
            v_Err_Msg := '号别为' || 号码_In || '的挂号安排中没有相关的安排计划(' || To_Char(发生时间_In, 'YYYY-mm-dd HH24:MI:SS') ||
                         '),不能进行预约挂号！';
            Raise Err_Item;
          End If;
        End If;
      End If;
    End If;
  
    If 操作方式_In = 1 And 锁定类型_In <> 2 Then
      --挂号规则:
      --  已挂数不能大于限号数
      If n_已挂数 >= Nvl(n_限号数, 0) And n_限号数 Is Not Null Then
        v_Err_Msg := '该号别今天已达到限号数 ' || Nvl(n_限号数, 0) || '不能再挂号！';
        Raise Err_Item;
      End If;
    End If;
  
    If 操作方式_In > 1 Then
      --预约的相关检查
      --规则:
      --   1.已限约不能超过限约数
      --   2.检查是否启用时段的
      If n_已约数 >= Nvl(n_限约数, 0) And Nvl(n_限约数, 0) <> 0 And n_限约数 Is Not Null And 锁定类型_In <> 2 Then
        v_Err_Msg := '该号别已达到限约数 ' || Nvl(n_限约数, 0) || '不能再预约挂号！';
        Raise Err_Item;
      End If;
      If 预约方式_In Is Not Null Then
        Select To_Number(Substr(Zl_Fun_Get临床出诊预约状态(记录id_In, 发生时间_In, 号序_In, 预约方式_In), 1, 1))
        Into n_Exists
        From Dual;
        If n_Exists <> 0 Then
          v_Err_Msg := '传入的预约方式' || 预约方式_In || '不可用,不能继续。';
          Raise Err_Item;
        End If;
      End If;
    End If;
    If n_合作单位限制 > 0 And 操作方式_In <> 1 And 合作单位_In Is Not Null Then
      If Nvl(n_序号控制, 0) = 1 And Nvl(号序_In, 0) = 0 Then
        v_Err_Msg := '当前安排使用了序号控制,请确认所需要预约的序号,不能继续。';
        Raise Err_Item;
      End If; --Nvl(r_安排.序号控制, 0) =0
    
      n_序号 := Case
                When Nvl(n_序号控制, 0) = 1 Or n_启用分时段 = 1 And 操作方式_In > 1 Then
                 Nvl(号序_In, 0)
                Else
                 0
              End;
    
      --合作单位控制模式
      Select Nvl(控制方式, 0)
      Into n_合作单位限数量模式
      From 临床出诊挂号控制记录
      Where 记录id = 记录id_In And 名称 = 合作单位_In And 类型 = 1 And 性质 = 1 And Rownum < 2;
    
      If n_合作单位限数量模式 = 0 Then
        v_Err_Msg := '当前号码(' || Nvl(号码_In, 0) || '未开放' || 合作单位_In || '的预约,不能继续。';
        Raise Err_Item;
      End If;
      If n_合作单位限数量模式 = 1 Or n_合作单位限数量模式 = 2 Then
        Select 数量
        Into n_Count
        From 临床出诊挂号控制记录
        Where 记录id = 记录id_In And 名称 = 合作单位_In And 类型 = 1 And 性质 = 1;
        If n_合作单位限数量模式 = 1 Then
          n_Count := Round(Nvl(n_限约数, n_限号数) * n_Count / 100);
        End If;
        Select Count(1)
        Into n_Exists
        From 病人挂号记录
        Where 记录状态 = 1 And 出诊记录id = 记录id_In And 合作单位 = 合作单位_In;
        If n_Exists >= n_Count Then
          v_Err_Msg := '当前号码(' || Nvl(号码_In, 0) || '已经超过' || 合作单位_In || '的预约限制,不能继续。';
          Raise Err_Item;
        End If;
      End If;
      --开放序号检查
      If n_合作单位限数量模式 = 3 Then
        For c_合作单位 In (Select 序号, 数量
                       From 临床出诊挂号控制记录
                       Where 记录id = 记录id_In And 名称 = 合作单位_In And 类型 = 1 And 性质 = 1 And 序号 = 号序_In) Loop
          If n_序号控制 = 1 Then
            Begin
              Select 1
              Into n_Count
              From 临床出诊序号控制
              Where 记录id = 记录id_In And 序号 = 号序_In And Nvl(挂号状态, 0) = 0;
            Exception
              When Others Then
                n_Count := 0;
            End;
            If n_Count = 1 Then
              n_是否开放 := 1;
            Else
              v_Err_Msg := '当前序号(' || Nvl(号序_In, 0) || '已经超过' || 合作单位_In || '的预约限制,不能继续。';
              Raise Err_Item;
            End If;
          Else
            Select Count(1)
            Into n_Count
            From 临床出诊序号控制
            Where 记录id = 记录id_In And 序号 = 号序_In And 预约顺序号 Is Not Null And Nvl(挂号状态, 0) <> 0;
            If n_Count >= c_合作单位.数量 Then
              v_Err_Msg := '当前序号(' || Nvl(号序_In, 0) || '已经超过' || 合作单位_In || '的预约限制,不能继续。';
              Raise Err_Item;
            Else
              n_是否开放 := 1;
            End If;
          End If;
        End Loop;
      
        If Nvl(n_是否开放, 0) = 0 Then
          v_Err_Msg := '当前序号(' || Nvl(号序_In, 0) || '未开放,不能继续。';
          Raise Err_Item;
        End If;
      End If;
    End If;
  
    --检查限号数和限约数
    n_行号         := 1;
    n_原项目id     := 0;
    n_原收入项目id := 0;
    n_实收金额合计 := 0;
    If 锁定类型_In <> 1 Then
      If 操作方式_In <> 2 Then
        If Nvl(结帐id_In, 0) = 0 Then
          --这里应该程序传入
          Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
        Else
          n_结帐id := 结帐id_In;
        End If;
      Else
        n_结帐id := Null;
      End If;
    End If;
  
    If Nvl(购买病历_In, 0) = 1 Then
      Begin
        Select 收费细目id Into n_病历费id From 收费特定项目 Where 特定项目 = '病历费';
        v_收费项目ids := n_项目id || ',' || n_病历费id;
      Exception
        When Others Then
          v_Err_Msg := '不能确定病历费,挂号失败!';
          Raise Err_Item;
      End;
    Else
      v_收费项目ids := n_项目id;
    End If;
  
    For c_Item In (Select 1 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, Null As 从属父号
                   From 收费项目目录 A, 收费价目 B, 收入项目 C
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = n_项目id And Sysdate Between b.执行日期 And
                         Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                   Union All
                   Select 2 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, Null As 从属父号
                   From 收费项目目录 A, 收费价目 B, 收入项目 C
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = n_病历费id And Sysdate Between b.执行日期 And
                         Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                   Union All
                   Select 3 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, d.从项数次 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, 1 As 从属父号
                   From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费从属项目 D
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = d.从项id And
                         d.主项id In (Select Column_Value From Table(f_Str2list(v_收费项目ids))) And Sysdate Between b.执行日期 And
                         Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                   Order By 性质, 项目编码, 收入编码) Loop
      n_价格父号 := Null;
      If n_原项目id = c_Item.项目id Then
        If n_原收入项目id <> c_Item.收入项目id Then
          n_价格父号 := n_行号;
        End If;
        n_原收入项目id := c_Item.收入项目id;
      End If;
      n_原项目id := c_Item.项目id;
      n_应收金额 := Round(c_Item.数次 * c_Item.单价, 5);
      n_实收金额 := n_应收金额;
      If Nvl(c_Item.屏蔽费别, 0) <> 1 And n_屏蔽费别 = 0 Then
        --打折:
        v_Temp     := Zl_Actualmoney(r_Pati.费别, c_Item.项目id, c_Item.收入项目id, n_应收金额);
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ':') + 1);
        n_实收金额 := Zl_To_Number(v_Temp);
      End If;
      n_实收金额合计 := Nvl(n_实收金额合计, 0) + n_实收金额;
    
      --锁定单据不产生费用
      If 锁定类型_In <> 1 Then
        --产生病人挂号费用(可能单独是或包括病历费用)
        Select 病人费用记录_Id.Nextval Into n_费用id From Dual;
        --:操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
        Insert Into 门诊费用记录
          (ID, 记录性质, 记录状态, 序号, 价格父号, 从属父号, NO, 实际票号, 门诊标志, 加班标志, 附加标志, 发药窗口, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 病人科室id,
           收费类别, 计算单位, 收费细目id, 收入项目id, 收据费目, 付数, 数次, 标准单价, 应收金额, 实收金额, 结帐金额, 结帐id, 记帐费用, 开单部门id, 开单人, 划价人, 执行部门id, 执行人,
           操作员编号, 操作员姓名, 发生时间, 登记时间, 保险大类id, 保险项目否, 保险编码, 统筹金额, 摘要, 结论, 缴款组id)
        Values
          (n_费用id, 4, Decode(操作方式_In, 2, 0, 1), n_行号, n_价格父号, c_Item.从属父号, 单据号_In, 票据号_In, 1, Null, Null,
           Decode(操作方式_In, 2, To_Char(号序_In), v_诊室), r_Pati.病人id, r_Pati.门诊号, r_Pati.付款方式, r_Pati.姓名, r_Pati.性别,
           r_Pati.年龄, r_Pati.费别, n_科室id, c_Item.类别, 号码_In, c_Item.项目id, c_Item.收入项目id, c_Item.收据费目, 1, c_Item.数次,
           c_Item.单价, n_应收金额, n_实收金额, Decode(操作方式_In, 2, Null, n_实收金额), n_结帐id, 0, n_开单部门id, v_操作员姓名,
           Decode(操作方式_In, 2, v_操作员姓名, Null), n_科室id, v_医生姓名, v_操作员编号, v_操作员姓名, 发生时间_In, d_登记时间, Null, 0, Null, Null,
           摘要_In, 预约方式_In, Decode(操作方式_In, 2, Null, n_组id));
      End If;
      n_行号 := n_行号 + 1;
    
    End Loop;
  
    If Round(Nvl(挂号金额合计_In, 0), 5) <> Round(Nvl(n_实收金额合计, 0), 5) Then
      v_Err_Msg := '本次挂号金额不正确,可能是因为医院调整了价格,请重新获取挂号收费项目的价格,不能继续。';
      Raise Err_Item;
    End If;
  
    If n_启用分时段 = 1 Then
      d_Date := To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(d_时段开始时间, 'hh24:mi:ss'),
                        'yyyy-mm-dd hh24:mi:ss');
    Else
      d_Date := Trunc(发生时间_In);
    End If;
  
    --更新挂号序号状态
    If 锁定类型_In <> 2 Then
      n_号序 := 号序_In;
    End If;
    Begin
      Select 1
      Into n_Count
      From 临床出诊序号控制
      Where 记录id = 记录id_In And 序号 = n_号序 And Nvl(挂号状态, 0) Not In (0, 5);
    Exception
      When Others Then
        n_Count := 0;
    End;
    If n_Count = 1 Then
      If n_启用分时段 = 0 And Nvl(n_序号控制, 0) = 1 Then
        n_号序 := Null;
      End If;
      If n_启用分时段 = 1 And Nvl(n_序号控制, 0) = 1 Then
        v_Err_Msg := '当前序号已被使用，请重新选择一个序号！';
        Raise Err_Item;
      End If;
    End If;
    n_Count := 0;
    If n_启用分时段 = 0 And Nvl(n_序号控制, 0) = 1 And n_号序 Is Null And 锁定类型_In <> 2 Then
      Select Nvl(Min(序号), 0)
      Into n_号序
      From 临床出诊序号控制
      Where 记录id = 记录id_In And Nvl(挂号状态, 0) = 5 And 操作员姓名 = v_操作员姓名 And 工作站名称 = v_机器名;
      If n_号序 = 0 Then
        Select Nvl(Min(序号), 0) Into n_号序 From 临床出诊序号控制 Where 记录id = 记录id_In And Nvl(挂号状态, 0) = 0;
        If n_号序 = 0 Then
          Select Nvl(Max(序号), 0) + 1 Into n_号序 From 临床出诊序号控制 Where 记录id = 记录id_In;
        End If;
      End If;
    End If;
  
    If n_启用分时段 = 1 And 锁定类型_In <> 2 Then
      If 操作方式_In > 1 And Nvl(n_序号控制, 0) = 0 Then
        --规则:预约时段序号||预约数
        If Nvl(n_预约总数, 0) = 0 Then
          v_Temp := Nvl(n_限约数, 0);
          v_Temp := LTrim(RTrim(v_Temp));
          v_Temp := LPad(Nvl(n_预约总数, 0) + 1, Length(v_Temp), '0');
          v_Temp := n_预约时段序号 || v_Temp;
          n_号序 := To_Number(v_Temp);
        Else
          n_号序 := n_预约总数 + 1;
        End If;
      End If;
    End If;
  
    If Nvl(n_序号控制, 0) = 1 Or (操作方式_In > 1 And n_启用分时段 = 1) Or 加入序号状态_In = 1 Then
      --锁定序号的处理
      Begin
        Select 操作员姓名, 工作站名称
        Into v_序号操作员, v_序号机器名
        From 临床出诊序号控制
        Where 挂号状态 = 5 And 记录id = 记录id_In And 序号 = n_号序;
        n_序号锁定 := 1;
      Exception
        When Others Then
          v_序号操作员 := Null;
          v_序号机器名 := Null;
          n_序号锁定   := 0;
      End;
      If n_序号锁定 = 0 Then
        If n_启用分时段 = 1 And n_序号控制 = 0 Then
          Insert Into 临床出诊序号控制
            (记录id, 序号, 预约顺序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 类型, 名称, 操作员姓名, 备注)
            Select 记录id_In, n_预约时段序号, n_预约顺序号, d_时段开始时间, d_时段终止时间, 1, Decode(操作方式_In, 1, 0, 1), Decode(操作方式_In, 2, 2, 1),
                   1, 合作单位_In, v_操作员姓名, n_号序
            From Dual;
        Else
          Update 临床出诊序号控制
          Set 挂号状态 = Decode(操作方式_In, 2, 2, 1), 操作员姓名 = v_操作员姓名
          Where 记录id = 记录id_In And 序号 = n_号序;
        End If;
        If Sql%RowCount = 0 Then
          Begin
            If n_启用分时段 = 1 Then
              --分时段
              If n_序号控制 = 1 Then
                --序号控制
                Select Max(终止时间) Into d_终止时间 From 临床出诊序号控制 Where 记录id = 记录id_In;
                If Sysdate > d_终止时间 Then
                  d_终止时间 := Sysdate;
                End If;
                Insert Into 临床出诊序号控制
                  (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 类型, 名称, 操作员姓名)
                  Select 记录id_In, n_号序, d_终止时间, d_终止时间, 1, Decode(操作方式_In, 1, 0, 1), Decode(操作方式_In, 2, 2, 1), 1,
                         合作单位_In, v_操作员姓名
                  From Dual;
              Else
                --分时段,非序号控制
                Null;
              End If;
            Else
              --不分时段
              Insert Into 临床出诊序号控制
                (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 类型, 名称, 操作员姓名)
                Select 记录id_In, n_号序, 开始时间, 终止时间, 1, Decode(操作方式_In, 1, 0, 1), Decode(操作方式_In, 2, 2, 1), 1, 合作单位_In,
                       v_操作员姓名
                From 临床出诊序号控制
                Where 记录id = 记录id_In And 序号 = 1;
            End If;
          Exception
            When Others Then
              v_Err_Msg := '序号' || n_号序 || '已被使用,请重新选择一个序号.';
              Raise Err_Item;
          End;
        End If;
      Else
        If v_操作员姓名 <> v_序号操作员 Or v_机器名 <> v_序号机器名 Then
          v_Err_Msg := '序号' || n_号序 || '已被机器' || v_机器名 || '锁定,请重新选择一个序号.';
          Raise Err_Item;
        Else
          Update 临床出诊序号控制
          Set 挂号状态 = Decode(操作方式_In, 2, 2, 1), 锁号时间 = Null
          Where 记录id = 记录id_In And 序号 = n_号序 And 挂号状态 = 5 And 操作员姓名 = v_操作员姓名 And 工作站名称 = v_机器名;
        End If;
      End If;
    End If;
  
    --锁定单据不产生任何 费用
    If 操作方式_In <> 2 And 锁定类型_In <> 1 Then
      --挂号,预约挂号已经扣款部分
      n_预交id := 预交id_In;
      If Nvl(n_预交id, 0) = 0 Then
        Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      End If;
      n_结算合计 := 0;
      If 保险结算_In Is Not Null Then
        --各个保险结算
        v_结算内容 := 保险结算_In || '||';
        n_结算合计 := 0;
        While v_结算内容 Is Not Null Loop
          v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
          v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
          n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
          If Nvl(n_结算金额, 0) <> 0 Then
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 记录状态, 病人id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算性质)
            Values
              (n_预交id, 4, 单据号_In, 1, Decode(病人id_In, 0, Null, 病人id_In), '保险结算', v_结算方式, d_登记时间, v_操作员编号, v_操作员姓名,
               n_结算金额, n_结帐id, n_组id, n_结帐id, 4);
            Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          End If;
          n_结算合计 := Nvl(n_结算合计, 0) + Nvl(n_结算金额, 0);
          v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
        End Loop;
      End If;
    
      If Nvl(冲预交_In, 0) <> 0 Then
        --处理总预交
        n_结算合计 := n_结算合计 + Nvl(冲预交_In, 0);
        n_预交金额 := 冲预交_In;
        For r_Deposit In c_Deposit(病人id_In, v_冲预交病人ids) Loop
          n_结算金额 := Case
                      When r_Deposit.金额 - n_预交金额 < 0 Then
                       r_Deposit.金额
                      Else
                       n_预交金额
                    End;
          If r_Deposit.结帐id = 0 Then
            --第一次冲预交(填上结帐ID,金额为0)
            Update 病人预交记录 Set 冲预交 = 0, 结帐id = n_结帐id, 结算性质 = 4 Where ID = r_Deposit.原预交id;
          End If;
          --冲上次剩余额
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 预交类别, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名,
             操作员编号, 冲预交, 结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 预交类别, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行,
                   单位帐号, d_登记时间, v_操作员姓名, v_操作员编号, n_结算金额, n_结帐id, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, n_结帐id, 4
            From 病人预交记录
            Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
        
          --更新病人预交余额
          Update 病人余额
          Set 预交余额 = Nvl(预交余额, 0) - n_结算金额
          Where 病人id = r_Deposit.病人id And 性质 = 1 And 类型 = Nvl(1, 2)
          Returning 预交余额 Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 病人余额 (病人id, 预交余额, 性质, 类型) Values (r_Deposit.病人id, -1 * n_结算金额, 1, 1);
            n_返回值 := -1 * n_结算金额;
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 病人余额
            Where 病人id = r_Deposit.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
          End If;
        
          --检查是否已经处理完
          If r_Deposit.金额 <= n_结算金额 Then
            n_预交金额 := n_预交金额 - r_Deposit.金额;
          Else
            n_预交金额 := 0;
          End If;
          If n_预交金额 = 0 Then
            Exit;
          End If;
        End Loop;
        If n_预交金额 > 0 Then
          v_Err_Msg := '预交余额不够支付本次支付金额,不能继续操作！';
          Raise Err_Item;
        End If;
      End If;
      --剩余款项,用指定结算方支付
      n_结算金额 := Nvl(n_实收金额合计, 0) - Nvl(n_结算合计, 0);
      If Nvl(n_结算金额, 0) < 0 Then
        v_Err_Msg := '挂号的相关结算金额超出了当前实结金额,不能继续操作！';
        Raise Err_Item;
      End If;
    
      If Nvl(n_结算金额, 0) <> 0 Or (Nvl(n_结算金额, 0) = 0 And Nvl(冲预交_In, 0) = 0) Then
        If 结算方式_In Is Null Then
          v_Err_Msg := '未传入指定的结算方式,不能继续操作！';
          Raise Err_Item;
        End If;
      
        If Nvl(预交id_In, 0) <> 0 Then
          --传入的预交ID_In主要是为了解决三方交易,如果医保结算站用了该ID,需要用新的ID进行更新,三方交易用转入的ID
          Update 病人预交记录 Set ID = n_预交id Where ID = Nvl(预交id_In, 0);
          n_预交id := Nvl(预交id_In, 0);
        End If;
        If Instr(结算方式_In, ',') = 0 Then
          --只传入一种结算方式的
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          Insert Into 病人预交记录
            (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
             合作单位, 结算性质, 结算号码)
          Values
            (n_预交id, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(结算方式_In, v_现金), Nvl(n_结算金额, 0), 登记时间_In,
             v_操作员编号, v_操作员姓名, n_结帐id, '挂号收费', n_组id, 卡类别id_In, Null, 支付卡号_In, 交易流水号_In, 交易说明_In, 合作单位_In, 4, v_结算号码);
        Else
          v_结算内容     := 结算方式_In || '|'; --以空格分开以|结尾,没有结算号码的
          n_Exists       := 0;
          v_结算方式记录 := '';
          While v_结算内容 Is Not Null Loop
            v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '|') - 1);
            v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1);
          
            v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
            n_单笔金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1));
          
            v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
            v_结算号码 := Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1);
          
            v_当前结算   := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
            n_三方卡标志 := To_Number(v_当前结算);
          
            If Instr('|' || v_结算方式记录 || '|', '|' || Nvl(v_结算方式, v_现金) || '|') <> 0 Then
              v_Err_Msg := '使用了重复的结算方式,请检查!';
              Raise Err_Item;
            Else
              v_结算方式记录 := v_结算方式记录 || '|' || Nvl(v_结算方式, v_现金);
            End If;
          
            If n_三方卡标志 = 0 Then
              Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
              Insert Into 病人预交记录
                (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号,
                 交易说明, 合作单位, 结算性质, 结算号码)
              Values
                (n_预交id, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(v_结算方式, v_现金), Nvl(n_单笔金额, 0), 登记时间_In,
                 v_操作员编号, v_操作员姓名, n_结帐id, '挂号收费', n_组id, Null, Null, Null, Null, Null, 合作单位_In, 4, v_结算号码);
            Else
              If n_Exists = 1 Then
                v_Err_Msg := '目前挂号仅支持一种三方结算方式,不能继续操作！';
                Raise Err_Item;
              End If;
              Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
              Insert Into 病人预交记录
                (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号,
                 交易说明, 合作单位, 结算性质, 结算号码)
              Values
                (n_预交id, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(v_结算方式, v_现金), Nvl(n_单笔金额, 0), 登记时间_In,
                 v_操作员编号, v_操作员姓名, n_结帐id, '挂号收费', n_组id, 卡类别id_In, Null, 支付卡号_In, 交易流水号_In, 交易说明_In, 合作单位_In, 4, v_结算号码);
              n_Exists := 1;
            End If;
          
            v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '|') + 1);
          End Loop;
        End If;
      End If;
    
      --更新人员缴款数据
    
      For v_缴款 In (Select 结算方式, Sum(Nvl(a.冲预交, 0)) As 冲预交
                   From 病人预交记录 A
                   Where a.结帐id = n_结帐id And Mod(a.记录性质, 10) <> 1 And Nvl(病人id, 0) = Nvl(病人id_In, 0)
                   Group By 结算方式) Loop
      
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + Nvl(v_缴款.冲预交, 0)
        Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = v_缴款.结算方式
        Returning 余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (v_操作员姓名, v_缴款.结算方式, 1, Nvl(v_缴款.冲预交, 0));
          n_返回值 := Nvl(v_缴款.冲预交, 0);
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = v_操作员姓名 And 结算方式 = v_缴款.结算方式 And 性质 = 1 And Nvl(余额, 0) = 0;
        End If;
      End Loop;
    End If;
  
    --处理挂号记录
    If 锁定类型_In = 2 Then
      Begin
        Select ID Into n_挂号id From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
      Exception
        When Others Then
          Null;
      End;
    Else
      Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
    End If;
  
    Update 病人挂号记录
    Set 记录性质 = Decode(操作方式_In, 2, 2, 1), 记录状态 = Decode(锁定类型_In, 1, 0, 1), 门诊号 = r_Pati.门诊号, 操作员姓名 = v_操作员姓名,
        操作员编号 = v_操作员编号, 预约 = Decode(操作方式_In, 1, 0, 1),
        接收人 = Decode(锁定类型_In, 1, Null, Decode(操作方式_In, 2, Null, v_操作员姓名)),
        接收时间 = Case 锁定类型_In
                  When 1 Then
                   Null
                  Else
                   Case 操作方式_In
                     When 2 Then
                      Null
                     Else
                      d_登记时间
                   End
                End, 交易流水号 = Nvl(交易流水号_In, 交易流水号), 交易说明 = Nvl(交易说明_In, 交易说明), 合作单位 = Nvl(合作单位_In, 合作单位),
        预约操作员 = Decode(操作方式_In, 1, Nvl(预约操作员, Null), Nvl(预约操作员, v_操作员姓名)),
        预约操作员编号 = Decode(操作方式_In, 1, Nvl(预约操作员编号, Null), Nvl(预约操作员编号, v_操作员编号)), 出诊记录id = 记录id_In
    Where ID = n_挂号id;
    If Sql%NotFound Then
      Begin
        Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = r_Pati.付款方式 And Rownum < 2;
      Exception
        When Others Then
          v_付款方式 := Null;
      End;
      Insert Into 病人挂号记录
        (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 预约时间, 操作员编号,
         操作员姓名, 复诊, 号序, 预约, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 医疗付款方式, 预约操作员, 预约操作员编号, 出诊记录id)
      Values
        (n_挂号id, 单据号_In, Decode(操作方式_In, 2, 2, 1), Decode(锁定类型_In, 1, 0, 1), r_Pati.病人id, r_Pati.门诊号, r_Pati.姓名,
         r_Pati.性别, r_Pati.年龄, 号码_In, 0, v_诊室, Null, n_科室id, v_医生姓名, 0, Null, d_登记时间, 发生时间_In,
         Case When(Nvl(操作方式_In, 0)) = 1 Then Null Else 发生时间_In End, v_操作员编号, v_操作员姓名, 0, n_号序, Decode(操作方式_In, 1, 0, 1),
         Decode(操作方式_In, 2, Null, v_操作员姓名), Decode(操作方式_In, 2, To_Date(Null), d_登记时间), 交易流水号_In, 交易说明_In, 合作单位_In,
         v_付款方式, Decode(操作方式_In, 1, Null, v_操作员姓名), Decode(操作方式_In, 1, Null, v_操作员编号), 记录id_In);
    End If;
    --锁定单据不能产生队列
    If 锁定类型_In <> 1 Then
      n_预约生成队列 := 0;
      If 操作方式_In > 1 Then
        n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
      End If;
      --挂号和收费的预约都直接进入队列(收费预约缺少接收过程,所以直接和挂号一样直接进入队列)
      If 操作方式_In <> 2 Or n_预约生成队列 = 1 Then
        If Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113)) <> 0 Then
          --排队叫号模式:-0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站
          If Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113)) = 0 Or n_预约生成队列 = 1 Then
            n_分时点显示 := Nvl(Zl_To_Number(zl_GetSysParameter(270)), 0);
            If Nvl(操作方式_In, 0) > 1 And n_分时点显示 = 1 And n_启用分时段 = 1 Then
              n_分时点显示 := 1;
            Else
              n_分时点显示 := Null;
            End If;
            --产生队列
            --.按”执行部门” 的方式生成队列
            v_队列名称 := n_科室id;
            v_排队号码 := Zlgetnextqueue(n_科室id, n_挂号id, 号码_In || '|' || 号序_In);
            --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)
            v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
            --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)
            d_排队时间 := Zl_Get_Queuedate(n_挂号id, 号码_In, 号序_In, d_Date);
            --  队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,v_排队标记,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In, 排队时间_In
            Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, n_科室id, v_排队号码, Null, r_Pati.姓名, r_Pati.病人id, v_诊室, v_医生姓名, d_排队时间,
                             预约方式_In, n_分时点显示, v_排队序号);
          End If;
        End If;
      End If;
    
      If Nvl(操作方式_In, 0) = 1 Then
        --处理票据使用情况
        If 票据号_In Is Not Null Then
          Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
          --发出票据
          Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 4, 单据号_In);
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
          Values
            (票据使用明细_Id.Nextval, Decode(收费票据_In, 1, 1, 4), 票据号_In, 1, 1, 领用id_In, n_打印id, d_登记时间, v_操作员姓名);
          --状态改动
          Update 票据领用记录
          Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
          Where ID = Nvl(领用id_In, 0);
        End If;
        --病人本次就诊(以发生时间为准)
        If Nvl(r_Pati.病人id, 0) <> 0 Then
          Update 病人信息 Set 就诊时间 = 发生时间_In, 就诊状态 = 1, 就诊诊室 = v_诊室 Where 病人id = r_Pati.病人id;
        End If;
      End If;
    End If;
    --病人挂号汇总
    --解锁单据时不用再对汇总单据进行统计了 在锁定单据时已经进行了汇总
    If 锁定类型_In <> 2 Then
      --操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
      --是否为预约接收:0-非预约挂号; 1-预约挂号,2-预约接收;3-收费预约
      n_预约 := Case
                When Nvl(操作方式_In, 0) = 1 Then
                 0
                When Nvl(操作方式_In, 0) = 2 Then
                 1
                When Nvl(操作方式_In, 0) = 3 Then
                 3
                Else
                 0
              End;
      Zl_病人挂号汇总_Update(v_医生姓名, n_医生id, n_项目id, n_科室id, 发生时间_In, n_预约, 号码_In, 0, 记录id_In);
    End If;
    --消息推送
    Begin
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 1, n_挂号id;
    Exception
      When Others Then
        Null;
    End;
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, '[ZLSOFT]+' || v_Err_Msg || '+[ZLSOFT]');
    When Err_Special Then
      Raise_Application_Error(-20105, '[ZLSOFT]+' || v_Err_Msg || '+[ZLSOFT]');
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End;

Begin
  n_出诊记录id := 出诊记录id_In;
  v_Para       := zl_GetSysParameter(256);
  n_挂号模式   := Substr(v_Para, 1, 1);
  Begin
    d_启用时间 := To_Date(Substr(v_Para, 3), 'yyyy-mm-dd hh24:mi:ss');
  Exception
    When Others Then
      d_启用时间 := Null;
  End;

  If Sysdate - 10 > Nvl(d_启用时间, Sysdate - 30) Then
    If n_挂号模式 = 1 And Nvl(发生时间_In, Sysdate) > Nvl(d_启用时间, Sysdate - 30) And n_出诊记录id Is Null Then
      v_Err_Msg := '系统当前处于出诊表排班模式，传入的参数无法确定挂号安排，请重试！';
      Raise Err_Item;
    End If;
  Else
    If n_挂号模式 = 1 And Nvl(发生时间_In, Sysdate) > Nvl(d_启用时间, Sysdate - 30) And n_出诊记录id Is Null Then
      Begin
        Select a.Id
        Into n_出诊记录id
        From 临床出诊记录 A, 临床出诊号源 B
        Where a.号源id = b.Id And b.号码 = 号码_In And Nvl(发生时间_In, Sysdate) Between a.开始时间 And a.终止时间;
      Exception
        When Others Then
          v_Err_Msg := '系统当前处于出诊表排班模式，传入的参数无法确定挂号安排，请重试！';
          Raise Err_Item;
      End;
    End If;
  End If;

  If n_出诊记录id Is Not Null Then
    --出诊表排班模式
    Zl_三方机构挂号_出诊_Insert(n_出诊记录id, 操作方式_In, 病人id_In, 号码_In, 号序_In, 单据号_In, 票据号_In, 结算方式_In, 摘要_In, 发生时间_In, 登记时间_In,
                        合作单位_In, 挂号金额合计_In, 领用id_In, 收费票据_In, 交易流水号_In, 交易说明_In, 预约方式_In, 预交id_In, 卡类别id_In, 加入序号状态_In,
                        是否自助设备_In, 结帐id_In, 锁定类型_In, 保险结算_In, 冲预交_In, 支付卡号_In, 退号重用_In, 费别_In, 机器名_In, 更新年龄_In, 购买病历_In);
  Else
    v_冲预交病人ids := Nvl(冲预交病人ids_In, 病人id_In);
    v_Temp          := zl_GetSysParameter(256);
    If v_Temp Is Null Or Substr(v_Temp, 1, 1) = '0' Then
      Null;
    Else
      Begin
        d_启用时间 := To_Date(Substr(v_Temp, 3), 'YYYY-MM-DD hh24:mi:ss');
      Exception
        When Others Then
          Null;
      End;
      If 发生时间_In > d_启用时间 Then
        v_Err_Msg := '当前挂号的发生时间' || To_Char(发生时间_In, 'yyyy-mm-dd hh24:mi:ss') || '已经启用了出诊表排班模式,不能再使用计划排班模式挂号!';
        Raise Err_Item;
      End If;
    End If;
    If 费别_In Is Null Then
      Select Zl_Custom_Getpatifeetype(1, 病人id_In) Into v_费别 From Dual;
    Else
      v_费别 := 费别_In;
    End If;
    If v_费别 Is Null Then
      n_屏蔽费别 := 1;
      Select 名称 Into v_费别 From 费别 Where 缺省标志 = 1 And Rownum < 2;
    End If;
    Update 病人信息 Set 费别 = v_费别 Where 病人id = 病人id_In;
  
    If 更新年龄_In = 1 Then
      Select Zl_Age_Calc(病人id_In) Into v_年龄 From Dual;
      If v_年龄 Is Not Null Then
        Update 病人信息 Set 年龄 = v_年龄 Where 病人id = 病人id_In;
      End If;
    End If;
    --获取当前机器名称
    If 机器名_In Is Not Null Then
      v_机器名 := 机器名_In;
    Else
      Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
    End If;
    n_实收金额合计 := 0;
    Select Count(*) + 1
    Into n_挂号序号
    From 病人挂号记录
    Where 号别 = 号码_In And 登记时间 Between Trunc(发生时间_In) And Trunc(发生时间_In + 1) - 1 / 24 / 60 / 60;
    --Begin
    v_Temp           := Nvl(zl_GetSysParameter('病人同科限挂N个号', 1111), '0|0') || '|';
    n_同科限号数     := To_Number(Substr(v_Temp, 1, Instr(v_Temp, '|') - 1));
    n_同科限约数     := To_Number(Nvl(zl_GetSysParameter('病人同科限约N个号', 1111), '0'));
    n_病人预约科室数 := To_Number(Nvl(zl_GetSysParameter('病人预约科室数', 1111), '0'));
    n_病人挂号科室数 := To_Number(Nvl(zl_GetSysParameter('病人挂号科室限制', 1111), '0'));
    n_专家号挂号限制 := To_Number(Nvl(zl_GetSysParameter('专家号挂号限制'), '0'));
    n_专家号预约限制 := To_Number(Nvl(zl_GetSysParameter('专家号预约限制'), '0'));
  
    --部门ID,部门名称;人员ID,人员编号,人员姓名
    v_Temp := Zl_Identity(0);
    If Nvl(v_Temp, ' ') = ' ' Then
      v_Err_Msg := '当前操作人员未设置对应的人员关系,不能继续。';
      Raise Err_Item;
    End If;
  
    If 登记时间_In Is Null Then
      d_登记时间 := Sysdate;
    Else
      d_登记时间 := 登记时间_In;
    End If;
    If Trunc(Sysdate) > Trunc(发生时间_In) Then
      v_Err_Msg := '不能挂以前的号(' || To_Char(发生时间_In, 'yyyy-mm-dd') || ')。';
      Raise Err_Item;
    End If;
    n_开单部门id := To_Number(Zl_操作员(0, v_Temp));
    v_操作员编号 := Zl_操作员(1, v_Temp);
    v_操作员姓名 := Zl_操作员(2, v_Temp);
    n_组id       := Zl_Get组id(v_操作员姓名);
  
    --支付宝并发提交检查
    Select Nvl(Max(1), 0)
    Into n_Exists
    From 病人挂号记录
    Where 病人id = 病人id_In And 号别 = 号码_In And 号序 = 号序_In And 操作员姓名 = v_操作员姓名 And Nvl(n_出诊记录id, 0) = Nvl(出诊记录id, 0) And
          登记时间 > Sysdate - 0.01 And 记录状态 = 1 And 发生时间 = 发生时间_In;
    If n_Exists = 1 Then
      v_Err_Msg := '病人已经挂号,不能重复挂相同的号！';
      Raise Err_Special;
    End If;
  
    If 操作方式_In <> 1 Then
      --预约检查是否添加合作单位控制
      --如果设置了合作单位控制 则
      Begin
        Select ID
        Into n_计划id
        From 挂号安排计划
        Where 号码 = 号码_In And 发生时间_In Between Nvl(生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
              Nvl(失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Rownum < 2
        Order By 生效时间 Desc;
      Exception
        When Others Then
          Select ID Into n_Tmp安排id From 挂号安排 Where 号码 = 号码_In;
      End;
      If Nvl(n_计划id, 0) <> 0 Then
        Select Count(0)
        Into n_合作单位限制
        From 合作单位计划控制
        Where 合作单位 = 合作单位_In And 计划id = n_计划id And Rownum < 2;
      Else
        Select Count(0)
        Into n_合作单位限制
        From 合作单位安排控制
        Where 合作单位 = 合作单位_In And 安排id = n_Tmp安排id And Rownum < 2;
      End If;
    End If;
  
    If 操作方式_In <> 2 Then
      v_诊室 := Zl_诊室(号码_In);
    End If;
    If 操作方式_In <> 2 And 结算方式_In Is Not Null Then
      --检查结算方式是否完备
      Select Count(*) Into n_Count From 结算方式 Where 名称 = Nvl(结算方式_In, 'Lxh') And 性质 In (2, 7, 8);
      If Nvl(卡类别id_In, 0) <> 0 And n_Count = 0 Then
        Select Count(1)
        Into n_Count
        From 医疗卡类别
        Where ID = Nvl(卡类别id_In, 0) And 结算方式 = Nvl(结算方式_In, 'lxh');
      End If;
      If n_Count = 0 Then
        v_Err_Msg := '结算方式(' || 结算方式_In || ')未设置,请在结算方式管理中设置。';
        Raise Err_Item;
      End If;
    End If;
  
    --因为现在有按日编单据号规则,日挂号量不能超过10000次,所以要检查唯一约束。
    Select Count(*) Into n_Count From 门诊费用记录 Where 记录性质 = 4 And 记录状态 In (1, 3) And NO = 单据号_In;
    If n_Count <> 0 Then
      v_Err_Msg := '挂号单据号重复,不能保存！' || Chr(13) || '如果使用了按日顺序编号,当日挂号量不能超过10000人次。';
      Raise Err_Item;
    End If;
  
    Open c_Pati(病人id_In);
    n_Count := 0;
    Begin
      Fetch c_Pati
        Into r_Pati;
    Exception
      When Others Then
        n_Count := -1;
    End;
    If n_Count = -1 Then
      v_Err_Msg := '病人未找到，不能继续。';
      Raise Err_Item;
    End If;
  
    Open c_安排(号码_In, 发生时间_In);
    Begin
      Fetch c_安排
        Into r_安排;
    Exception
      When Others Then
        n_Count := -1;
    End;
    If n_Count = -1 Then
      v_Err_Msg := '该号别没有在' || To_Char(发生时间_In, 'yyyy-mm-dd hh24:mi:ss') || '中进行安排。';
      Raise Err_Item;
    End If;
  
    Select Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六',
                   '周日')
    Into v_星期
    From Dual;
    Begin
      If r_安排.计划id Is Null Then
        Select Max(1) Into n_启用分时段 From 挂号安排时段 Where 安排id = r_安排.Id And 星期 = v_星期 And Rownum < 2;
        Select Decode(To_Char(发生时间_In, 'D'), '1', 周日, '2', 周一, '3', 周二, '4', 周三, '5', 周四, '6', 周五, '7', 周六, Null)
        Into v_时间段
        From 挂号安排
        Where ID = r_安排.Id;
      Else
        Select Max(1)
        Into n_启用分时段
        From 挂号计划时段
        Where 计划id = r_安排.计划id And 星期 = v_星期 And Rownum < 2;
        Select Decode(To_Char(发生时间_In, 'D'), '1', 周日, '2', 周一, '3', 周二, '4', 周三, '5', 周四, '6', 周五, '7', 周六, Null)
        Into v_时间段
        From 挂号安排计划
        Where ID = r_安排.计划id;
      End If;
    Exception
      When Others Then
        n_启用分时段 := 0;
    End;
  
    If v_时间段 Is Not Null And d_启用时间 Is Not Null Then
      --检查是否跨模式挂号安排
      Select To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'),
             To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(终止时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss')
      Into d_检查开始时间, d_检查结束时间
      From 时间段
      Where 时间段 = v_时间段 And 站点 Is Null And 号类 Is Null;
      If d_检查开始时间 > d_检查结束时间 Then
        d_检查结束时间 := d_检查结束时间 + 1;
      End If;
      If d_检查结束时间 > d_启用时间 Then
        --获取出诊记录id
        Begin
          Select a.Id
          Into n_出诊记录id
          From 临床出诊记录 A, 临床出诊号源 B
          Where a.号源id = b.Id And b.号码 = 号码_In And 上班时段 = v_时间段 And 发生时间_In Between 开始时间 And 终止时间;
        Exception
          When Others Then
            n_出诊记录id := Null;
        End;
      End If;
    End If;
  
    --对参数控制进行检查
    --仅在预约不扣款时进行检查
    If 操作方式_In = 2 Then
      If Nvl(n_同科限约数, 0) <> 0 Or Nvl(n_病人预约科室数, 0) <> 0 Then
        n_已约科室 := 0;
        For c_Chkitem In (Select Distinct 执行部门id
                          From 病人挂号记录
                          Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 2 And 预约时间 Between Trunc(发生时间_In) And
                                Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id <> r_安排.科室id) Loop
          n_已约科室 := n_已约科室 + 1;
        End Loop;
        If n_已约科室 >= Nvl(n_病人预约科室数, 0) And Nvl(n_病人预约科室数, 0) > 0 Then
          v_Err_Msg := '同一病人最多同时能预约[' || Nvl(n_病人预约科室数, 0) || ']个科室,不能再预约！';
          Raise Err_Item;
        End If;
      
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 2 And 预约时间 Between Trunc(发生时间_In) And
              Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id = r_安排.科室id;
        If n_Count >= Nvl(n_同科限约数, 0) And Nvl(n_同科限约数, 0) > 0 Then
          v_Err_Msg := '该病人已经在该科室预约了' || n_Count || '次,不能再预约！';
          Raise Err_Item;
        End If;
      End If;
      If Nvl(n_专家号预约限制, 0) <> 0 Then
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 2 And 预约时间 Between Trunc(发生时间_In) And
              Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 号别 = r_安排.号码;
        If n_Count >= Nvl(n_专家号预约限制, 0) And Nvl(n_专家号预约限制, 0) > 0 Then
          v_Err_Msg := '该病人已经超过本号预约限制,不能再预约！';
          Raise Err_Item;
        End If;
      End If;
    Else
      If Nvl(n_同科限号数, 0) <> 0 Or Nvl(n_病人挂号科室数, 0) <> 0 Then
        n_已约科室 := 0;
        For c_Chkitem In (Select Distinct 执行部门id
                          From 病人挂号记录
                          Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 1 And 发生时间 Between Trunc(发生时间_In) And
                                Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id <> r_安排.科室id) Loop
          n_已约科室 := n_已约科室 + 1;
        End Loop;
        If n_已约科室 >= Nvl(n_病人挂号科室数, 0) And Nvl(n_病人挂号科室数, 0) > 0 Then
          v_Err_Msg := '同一病人最多同时能挂号[' || Nvl(n_病人挂号科室数, 0) || ']个科室,不能再挂号！';
          Raise Err_Item;
        End If;
      
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 1 And 发生时间 Between Trunc(发生时间_In) And
              Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id = r_安排.科室id;
        If n_Count >= Nvl(n_同科限号数, 0) And Nvl(n_同科限号数, 0) > 0 Then
          v_Err_Msg := '该病人已经在该科室挂号了' || n_Count || '次,不能再挂号！';
          Raise Err_Item;
        End If;
      End If;
      If Nvl(n_专家号挂号限制, 0) <> 0 Then
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 1 And 预约时间 Between Trunc(发生时间_In) And
              Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 号别 = r_安排.号码;
        If n_Count >= Nvl(n_专家号挂号限制, 0) And Nvl(n_专家号挂号限制, 0) > 0 Then
          v_Err_Msg := '该病人已经超过本号挂号限制,不能再挂号！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  
    d_Date         := Null;
    d_时段开始时间 := Null;
  
    If Nvl(r_安排.限号数, 0) >= 0 Or r_安排.限号数 Is Null Then
    
      Select Nvl(Sum(Nvl(b.已挂数, 0)), 0), Nvl(Sum(Nvl(b.其中已接收, 0)), 0), Nvl(Sum(Nvl(b.已约数, 0)), 0)
      Into n_已挂数, n_其中已接收, n_已约数
      From 挂号安排 A, 病人挂号汇总 B
      Where a.科室id = b.科室id And a.项目id = b.项目id And a.号码 = 号码_In And b.日期 Between Trunc(发生时间_In) And
            Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And (a.号码 = b.号码 Or b.号码 Is Null) And Nvl(a.医生id, 0) = Nvl(b.医生id, 0) And
            Nvl(a.医生姓名, '医生') = Nvl(b.医生姓名, '医生');
    
      If n_启用分时段 = 1 Then
        If Nvl(r_安排.序号控制, 0) = 1 Then
          If Nvl(是否自助设备_In, 0) = 0 Then
            If r_安排.计划id Is Null Then
              Select Count(*), Max(开始时间)
              Into n_Count, d_时段开始时间
              From 挂号安排时段
              Where 安排id = r_安排.Id And 星期 = v_星期 And 序号 = Nvl(号序_In, 0);
            Else
              Select Count(*), Max(开始时间)
              Into n_Count, d_时段开始时间
              From 挂号计划时段
              Where 计划id = r_安排.计划id And 星期 = v_星期 And 序号 = Nvl(号序_In, 0);
            End If;
            v_Temp := '挂号';
            If 操作方式_In > 1 Then
              v_Temp := '预约挂号';
            End If;
          
            If n_Count = 0 Then
              v_Err_Msg := '号别为' || 号码_In || '的挂号安排中不存在序号为' || Nvl(号序_In, 0) || '的安排,不能再' || v_Temp || '！';
              Raise Err_Item;
            End If;
          End If;
          --过点的,不能选择挂号
          If Trunc(Sysdate) = Trunc(发生时间_In) Then
            --挂当天的号
            v_Temp := To_Char(Sysdate, 'yyyy-mm-dd') || ' ';
            If r_安排.计划id Is Null Then
              For v_时段 In (Select To_Date(v_Temp || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                  To_Date(To_Char(Sysdate + Decode(Sign(开始时间 - 结束时间), 1, 1, 0), 'yyyy-mm-dd') || ' ' ||
                                           To_Char(结束时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 结束时间, 限制数量, 是否预约
                           From 挂号安排时段
                           Where 安排id = r_安排.Id And 星期 = v_星期 And 序号 = Nvl(号序_In, 0)) Loop
                If Sysdate > v_时段.结束时间 Then
                  v_Err_Msg := '号别为' || 号码_In || '及号序为' || Nvl(号序_In, 0) || '的安排,已经超过时点,不能再' || v_Temp || '！';
                  Raise Err_Item;
                End If;
              End Loop;
            Else
              For v_时段 In (Select To_Date(v_Temp || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                  To_Date(To_Char(Sysdate + Decode(Sign(开始时间 - 结束时间), 1, 1, 0), 'yyyy-mm-dd') || ' ' ||
                                           To_Char(结束时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 结束时间, 限制数量, 是否预约
                           From 挂号计划时段
                           Where 计划id = r_安排.计划id And 星期 = v_星期 And 序号 = Nvl(号序_In, 0)) Loop
                If Sysdate > v_时段.结束时间 Then
                  v_Err_Msg := '号别为' || 号码_In || '及号序为' || Nvl(号序_In, 0) || '的安排,已经超过时点,不能再' || v_Temp || '！';
                  Raise Err_Item;
                End If;
              End Loop;
            End If;
          End If;
        Elsif 操作方式_In > 1 Then
          --未启用序号的,需要检查预约的情况
          n_Count := 0;
          If r_安排.计划id Is Null Then
            For v_时段 In (Select 序号, 开始时间, 结束时间, 限制数量, 是否预约
                         From 挂号安排时段
                         Where 安排id = r_安排.Id And 星期 = v_星期 And
                               (('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                               Decode(Sign(开始时间 - 结束时间 - 1 / 24 / 60 / 60), 1,
                                        '3000-01-09 ' || To_Char(开始时间, 'HH24:MI:SS'),
                                        '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS')) And
                               '3000-01-10 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS')) Or
                               ('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                               '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS') And
                               Decode(Sign(开始时间 - 结束时间 - 1 / 24 / 60 / 60), 1,
                                        '3000-01-11 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'),
                                        '3000-01-10 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'))))) Loop
              n_预约时段序号 := v_时段.序号;
              d_时段开始时间 := v_时段.开始时间;
            
              Select Count(*), Max(序号)
              Into n_Count, n_预约总数
              From 挂号序号状态
              Where 号码 = 号码_In And 日期 = 发生时间_In And 状态 Not In (4, 5);
            
              If Nvl(n_Count, 0) > Nvl(v_时段.限制数量, 0) And 锁定类型_In <> 2 Then
                v_Err_Msg := '号别为' || 号码_In || '的挂号安排中在' || To_Char(v_时段.开始时间, 'hh24:mi:ss') || '至' ||
                             To_Char(v_时段.结束时间, 'hh24:mi:ss') || '最多只能预约' || Nvl(v_时段.限制数量, 0) || '人,不能再进行预约挂号！';
                Raise Err_Item;
              End If;
              n_Count := 1;
            End Loop;
          Else
            For v_时段 In (Select 序号, 开始时间, 结束时间, 限制数量, 是否预约
                         From 挂号计划时段
                         Where 计划id = r_安排.计划id And 星期 = v_星期 And
                               (('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                               Decode(Sign(开始时间 - 结束时间 - 1 / 24 / 60 / 60), 1,
                                        '3000-01-09 ' || To_Char(开始时间, 'HH24:MI:SS'),
                                        '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS')) And
                               '3000-01-10 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS')) Or
                               ('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                               '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS') And
                               Decode(Sign(开始时间 - 结束时间 - 1 / 24 / 60 / 60), 1,
                                        '3000-01-11 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'),
                                        '3000-01-10 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'))))) Loop
              n_预约时段序号 := v_时段.序号;
              d_时段开始时间 := v_时段.开始时间;
            
              Select Count(*), Max(序号)
              Into n_Count, n_预约总数
              From 挂号序号状态
              Where 号码 = 号码_In And 日期 = 发生时间_In And 状态 Not In (4, 5);
            
              If Nvl(n_Count, 0) > Nvl(v_时段.限制数量, 0) And 锁定类型_In <> 2 Then
                v_Err_Msg := '号别为' || 号码_In || '的挂号安排中在' || To_Char(v_时段.开始时间, 'hh24:mi:ss') || '至' ||
                             To_Char(v_时段.结束时间, 'hh24:mi:ss') || '最多只能预约' || Nvl(v_时段.限制数量, 0) || '人,不能再进行预约挂号！';
                Raise Err_Item;
              End If;
              n_Count := 1;
            End Loop;
          End If;
        
          If n_Count = 0 Then
            v_Err_Msg := '号别为' || 号码_In || '的挂号安排中没有相关的安排计划(' || To_Char(发生时间_In, 'YYYY-mm-dd HH24:MI:SS') ||
                         '),不能进行预约挂号！';
            Raise Err_Item;
          End If;
        End If;
      End If;
    End If;
  
    If 操作方式_In = 1 And 锁定类型_In <> 2 Then
      --挂号规则:
      --  已挂数不能大于限号数
      If n_已挂数 >= Nvl(r_安排.限号数, 0) And r_安排.限号数 Is Not Null Then
        v_Err_Msg := '该号别今天已达到限号数 ' || Nvl(r_安排.限号数, 0) || '不能再挂号！';
        Raise Err_Item;
      End If;
    End If;
  
    If 操作方式_In > 1 Then
      --预约的相关检查
      --规则:
      --   1.已限约不能超过限约数
      --   2.检查是否启用时段的
      If n_已约数 >= Nvl(r_安排.限约数, 0) And Nvl(r_安排.限约数, 0) <> 0 And r_安排.限约数 Is Not Null And 锁定类型_In <> 2 Then
        v_Err_Msg := '该号别已达到限约数 ' || Nvl(r_安排.限约数, 0) || '不能再预约挂号！';
        Raise Err_Item;
      End If;
    End If;
    If n_合作单位限制 > 0 And 操作方式_In <> 1 And 合作单位_In Is Not Null Then
    
      If Nvl(r_安排.序号控制, 0) = 1 And Nvl(号序_In, 0) = 0 Then
        v_Err_Msg := '当前安排使用了序号控制,请确认所需要预约的序号,不能继续。';
        Raise Err_Item;
      End If; --Nvl(r_安排.序号控制, 0) =0
    
      n_序号 := Case
                When Nvl(r_安排.序号控制, 0) = 1 Or n_启用分时段 = 1 And 操作方式_In > 1 Then
                 Nvl(号序_In, 0)
                Else
                 0
              End;
    
      --合作单位限数量模式
      Begin
        If Nvl(n_计划id, 0) <> 0 Then
          Select 0
          Into n_序号
          From 合作单位计划控制
          Where 合作单位 = 合作单位_In And 计划id = n_计划id And
                限制项目 = Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                              '7', '周六', Null) And 数量 <> 0 And 序号 = 0 And Rownum < 2;
        Else
          Select 0
          Into n_序号
          From 合作单位安排控制
          Where 合作单位 = 合作单位_In And 安排id = n_Tmp安排id And
                限制项目 = Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                              '7', '周六', Null) And 数量 <> 0 And 序号 = 0 And Rownum < 2;
        End If;
        n_合作单位限数量模式 := 1;
      Exception
        When Others Then
          n_合作单位限数量模式 := 0;
      End;
      --开放序号检查
      For c_合作单位 In (Select c.序号, 数量
                     From 挂号安排 A, 合作单位安排控制 C
                     Where a.号码 = 号码_In And Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                   '周四', '6', '周五', '7', '周六', Null) = c.限制项目(+) And a.Id = c.安排id And
                           c.合作单位 = 合作单位_In And c.序号 = n_序号 And Not Exists
                      (Select 1
                            From 挂号安排计划 D
                            Where d.安排id = a.Id And d.审核时间 Is Not Null And
                                  发生时间_In Between Nvl(d.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                                  Nvl(d.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')))
                     Union All
                     Select c.序号, 数量
                     From 挂号安排计划 A, 挂号安排 D, 合作单位计划控制 C,
                          (Select Max(a.生效时间) As 生效, 安排id
                            From 挂号安排计划 A, 挂号安排 B
                            Where a.安排id = b.Id And a.审核时间 Is Not Null And
                                  发生时间_In Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                                  Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) And b.号码 = 号码_In
                            Group By 安排id) E
                     Where a.安排id = d.Id And a.审核时间 Is Not Null And d.号码 = 号码_In And a.安排id = e.安排id And
                           Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) =
                           Nvl(e.生效, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                           Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) = c.限制项目(+) And a.Id = c.计划id And c.合作单位 = 合作单位_In And c.序号 = n_序号 And
                           发生时间_In Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                           Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd'))) Loop
      
        If Nvl(r_安排.序号控制, 0) = 1 And c_合作单位.序号 = n_序号 And n_合作单位限数量模式 = 0 Then
          n_是否开放 := 1;
          Exit;
        Elsif (Nvl(r_安排.序号控制, 0) = 0 And c_合作单位.序号 = n_序号) Or n_合作单位限数量模式 = 1 Then
          Begin
            Select Nvl(已约数, 0)
            Into n_预约数量
            From 合作单位挂号汇总
            Where 合作单位 = 合作单位_In And 日期 = Trunc(发生时间_In) And 号码 = 号码_In;
          Exception
            When Others Then
              n_预约数量 := 0;
          End;
          If c_合作单位.数量 <= n_预约数量 And Nvl(c_合作单位.数量, 0) > 0 And 锁定类型_In <> 2 Then
            v_Err_Msg := '该号别已达到限约数 ' || Nvl(c_合作单位.数量, 0) || '不能再预约挂号！';
            Raise Err_Item;
          End If;
          n_是否开放 := 1;
          Exit;
        End If;
      
      End Loop;
    
      If Nvl(n_是否开放, 0) = 0 Then
        v_Err_Msg := '当前序号(' || Nvl(号序_In, 0) || '未开放,不能继续。';
        Raise Err_Item;
      End If;
    End If;
  
    --检查限号数和限约数
    n_行号         := 1;
    n_原项目id     := 0;
    n_原收入项目id := 0;
    n_实收金额合计 := 0;
    If 锁定类型_In <> 1 Then
      If 操作方式_In <> 2 Then
        If Nvl(结帐id_In, 0) = 0 Then
          --这里应该程序传入
          Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
        Else
          n_结帐id := 结帐id_In;
        End If;
      Else
        n_结帐id := Null;
      End If;
    End If;
  
    If Nvl(购买病历_In, 0) = 1 Then
      Begin
        Select 收费细目id Into n_病历费id From 收费特定项目 Where 特定项目 = '病历费';
        v_收费项目ids := r_安排.项目id || ',' || n_病历费id;
      Exception
        When Others Then
          v_Err_Msg := '不能确定病历费,挂号失败!';
          Raise Err_Item;
      End;
    Else
      v_收费项目ids := r_安排.项目id;
    End If;
  
    For c_Item In (Select 1 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, Null As 从属父号
                   From 收费项目目录 A, 收费价目 B, 收入项目 C
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = r_安排.项目id And Sysdate Between b.执行日期 And
                         Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                   Union All
                   Select 2 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, Null As 从属父号
                   From 收费项目目录 A, 收费价目 B, 收入项目 C
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = n_病历费id And Sysdate Between b.执行日期 And
                         Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                   Union All
                   Select 3 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, d.从项数次 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, 1 As 从属父号
                   From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费从属项目 D
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = d.从项id And
                         d.主项id In (Select Column_Value From Table(f_Str2list(v_收费项目ids))) And Sysdate Between b.执行日期 And
                         Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                   Order By 性质, 项目编码, 收入编码) Loop
      n_价格父号 := Null;
      If n_原项目id = c_Item.项目id Then
        If n_原收入项目id <> c_Item.收入项目id Then
          n_价格父号 := n_行号;
        End If;
        n_原收入项目id := c_Item.收入项目id;
      End If;
      n_原项目id := c_Item.项目id;
      n_应收金额 := Round(c_Item.数次 * c_Item.单价, 5);
      n_实收金额 := n_应收金额;
      If Nvl(c_Item.屏蔽费别, 0) <> 1 And n_屏蔽费别 = 0 Then
        --打折:
        v_Temp     := Zl_Actualmoney(r_Pati.费别, c_Item.项目id, c_Item.收入项目id, n_应收金额);
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ':') + 1);
        n_实收金额 := Zl_To_Number(v_Temp);
      End If;
      n_实收金额合计 := Nvl(n_实收金额合计, 0) + n_实收金额;
    
      --锁定单据不产生费用
      If 锁定类型_In <> 1 Then
        --产生病人挂号费用(可能单独是或包括病历费用)
        Select 病人费用记录_Id.Nextval Into n_费用id From Dual;
        --:操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
        Insert Into 门诊费用记录
          (ID, 记录性质, 记录状态, 序号, 价格父号, 从属父号, NO, 实际票号, 门诊标志, 加班标志, 附加标志, 发药窗口, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 病人科室id,
           收费类别, 计算单位, 收费细目id, 收入项目id, 收据费目, 付数, 数次, 标准单价, 应收金额, 实收金额, 结帐金额, 结帐id, 记帐费用, 开单部门id, 开单人, 划价人, 执行部门id, 执行人,
           操作员编号, 操作员姓名, 发生时间, 登记时间, 保险大类id, 保险项目否, 保险编码, 统筹金额, 摘要, 结论, 缴款组id)
        Values
          (n_费用id, 4, Decode(操作方式_In, 2, 0, 1), n_行号, n_价格父号, c_Item.从属父号, 单据号_In, 票据号_In, 1, Null, Null,
           Decode(操作方式_In, 2, To_Char(号序_In), v_诊室), r_Pati.病人id, r_Pati.门诊号, r_Pati.付款方式, r_Pati.姓名, r_Pati.性别,
           r_Pati.年龄, r_Pati.费别, r_安排.科室id, c_Item.类别, 号码_In, c_Item.项目id, c_Item.收入项目id, c_Item.收据费目, 1, c_Item.数次,
           c_Item.单价, n_应收金额, n_实收金额, Decode(操作方式_In, 2, Null, n_实收金额), n_结帐id, 0, n_开单部门id, v_操作员姓名,
           Decode(操作方式_In, 2, v_操作员姓名, Null), r_安排.科室id, r_安排.医生姓名, v_操作员编号, v_操作员姓名, 发生时间_In, d_登记时间, Null, 0, Null,
           Null, 摘要_In, 预约方式_In, Decode(操作方式_In, 2, Null, n_组id));
      End If;
      n_行号 := n_行号 + 1;
    
    End Loop;
  
    If Round(Nvl(挂号金额合计_In, 0), 5) <> Round(Nvl(n_实收金额合计, 0), 5) Then
      v_Err_Msg := '本次挂号金额不正确,可能是因为医院调整了价格,请重新获取挂号收费项目的价格,不能继续。';
      Raise Err_Item;
    End If;
  
    If n_启用分时段 = 1 Then
      d_Date := To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(d_时段开始时间, 'hh24:mi:ss'),
                        'yyyy-mm-dd hh24:mi:ss');
    Else
      d_Date := Trunc(发生时间_In);
    End If;
  
    --更新挂号序号状态
    If 锁定类型_In <> 2 Then
      n_号序 := 号序_In;
    End If;
    Begin
      Select 1
      Into n_Count
      From 挂号序号状态
      Where Trunc(日期) = Trunc(发生时间_In) And 号码 = 号码_In And 序号 = n_号序 And 状态 <> 5;
    Exception
      When Others Then
        n_Count := 0;
    End;
    If n_Count = 1 Then
      If n_启用分时段 = 0 And Nvl(r_安排.序号控制, 0) = 1 Then
        n_号序 := Null;
      End If;
      If n_启用分时段 = 1 And Nvl(r_安排.序号控制, 0) = 1 Then
        v_Err_Msg := '当前序号已被使用，请重新选择一个序号！';
        Raise Err_Item;
      End If;
    End If;
    n_Count := 0;
    If n_启用分时段 = 0 And Nvl(r_安排.序号控制, 0) = 1 And n_号序 Is Null And 锁定类型_In <> 2 Then
      If 退号重用_In = 1 Then
        Select Nvl(Max(序号), 0) + 1
        Into n_号序
        From 挂号序号状态
        Where 日期 = Trunc(发生时间_In) And 号码 = r_安排.号码 And 状态 Not In (4, 5);
      Else
        Select Nvl(Max(序号), 0) + 1
        Into n_号序
        From 挂号序号状态
        Where 日期 = Trunc(发生时间_In) And 号码 = r_安排.号码 And 状态 <> 5;
      End If;
    End If;
    If n_启用分时段 = 1 And 锁定类型_In <> 2 Then
    
      If 操作方式_In > 1 And Nvl(r_安排.序号控制, 0) = 0 Then
        --规则:预约时段序号||预约数
        If Nvl(n_预约总数, 0) = 0 Then
          v_Temp := Nvl(r_安排.限约数, 0);
          v_Temp := LTrim(RTrim(v_Temp));
          v_Temp := LPad(Nvl(n_预约总数, 0) + 1, Length(v_Temp), '0');
          v_Temp := n_预约时段序号 || v_Temp;
          n_号序 := To_Number(v_Temp);
        Else
          n_号序 := n_预约总数 + 1;
        End If;
      End If;
    End If;
  
    If Nvl(r_安排.序号控制, 0) = 1 Or (操作方式_In > 1 And n_启用分时段 = 1) Or 加入序号状态_In = 1 Then
      --锁定序号的处理
      Begin
        Select 操作员姓名, 机器名
        Into v_序号操作员, v_序号机器名
        From 挂号序号状态
        Where 状态 = 5 And 号码 = 号码_In And Trunc(日期) = Trunc(d_Date) And 序号 = n_号序;
        n_序号锁定 := 1;
      Exception
        When Others Then
          v_序号操作员 := Null;
          v_序号机器名 := Null;
          n_序号锁定   := 0;
      End;
      If n_序号锁定 = 0 Then
        Update 挂号序号状态
        Set 状态 = Decode(操作方式_In, 2, 2, 1), 预约 = Decode(操作方式_In, 1, 0, 1), 登记时间 = Sysdate
        Where 号码 = 号码_In And 日期 = d_Date And 序号 = n_号序 And 操作员姓名 = v_操作员姓名;
        If Sql%RowCount = 0 Then
          Begin
            Insert Into 挂号序号状态
              (号码, 日期, 序号, 状态, 操作员姓名, 预约, 登记时间)
            Values
              (号码_In, d_Date, n_号序, Decode(操作方式_In, 2, 2, 1), v_操作员姓名, Decode(操作方式_In, 1, 0, 1), Sysdate);
          
            If n_合作单位限制 > 0 And 操作方式_In > 1 And Nvl(n_是否开放, 0) = 1 Then
              Update 合作单位挂号汇总
              Set 已约数 = 已约数 + Decode(操作方式_In, 2, 1, 0), 已接数 = 已接数 + Decode(操作方式_In, 3, 1, 0)
              Where 号码 = 号码_In And 日期 = d_Date And 序号 = n_号序 And 合作单位 = 合作单位_In;
              If Sql%NotFound Then
                Insert Into 合作单位挂号汇总
                  (号码, 日期, 序号, 合作单位, 已约数, 已接数)
                Values
                  (号码_In, d_Date, n_号序, 合作单位_In, Decode(操作方式_In, 1, 0, 1), Decode(操作方式_In, 3, 1, 0));
              End If;
            End If;
          Exception
            When Others Then
              v_Err_Msg := '序号' || n_号序 || '已被使用,请重新选择一个序号.';
              Raise Err_Item;
          End;
        End If;
      Else
        If v_操作员姓名 <> v_序号操作员 Or v_机器名 <> v_序号机器名 Then
          v_Err_Msg := '序号' || n_号序 || '已被自助机' || v_机器名 || '锁定,请重新选择一个序号.';
          Raise Err_Item;
        Else
          Update 挂号序号状态
          Set 状态 = Decode(操作方式_In, 2, 2, 1), 预约 = Decode(操作方式_In, 1, 0, 1), 登记时间 = Sysdate
          Where 号码 = 号码_In And Trunc(日期) = Trunc(d_Date) And 序号 = n_号序 And 状态 = 5 And 操作员姓名 = v_操作员姓名 And 机器名 = v_机器名;
        End If;
      End If;
    End If;
  
    If n_出诊记录id Is Not Null Then
      Update 临床出诊序号控制
      Set 挂号状态 = Decode(操作方式_In, 2, 2, 1), 操作员姓名 = v_操作员姓名
      Where 记录id = n_出诊记录id And 序号 = n_序号;
      If 操作方式_In = 2 Then
        Update 临床出诊记录 Set 已约数 = 已约数 + 1 Where ID = n_出诊记录id;
      Else
        If 操作方式_In <> 1 Then
          Update 临床出诊记录
          Set 已约数 = 已约数 + 1, 已挂数 = 已挂数 + 1, 其中已接收 = 其中已接收 + 1
          Where ID = n_出诊记录id;
        Else
          Update 临床出诊记录 Set 已挂数 = 已挂数 + 1 Where ID = n_出诊记录id;
        End If;
      End If;
    End If;
  
    --锁定单据不产生任何 费用
    If 操作方式_In <> 2 And 锁定类型_In <> 1 Then
      --挂号,预约挂号已经扣款部分
      n_预交id := 预交id_In;
      If Nvl(n_预交id, 0) = 0 Then
        Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      End If;
      n_结算合计 := 0;
      If 保险结算_In Is Not Null Then
        --各个保险结算
        v_结算内容 := 保险结算_In || '||';
        n_结算合计 := 0;
        While v_结算内容 Is Not Null Loop
          v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
          v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
          n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
          If Nvl(n_结算金额, 0) <> 0 Then
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 记录状态, 病人id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算性质)
            Values
              (n_预交id, 4, 单据号_In, 1, Decode(病人id_In, 0, Null, 病人id_In), '保险结算', v_结算方式, d_登记时间, v_操作员编号, v_操作员姓名,
               n_结算金额, n_结帐id, n_组id, n_结帐id, 4);
            Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          End If;
          n_结算合计 := Nvl(n_结算合计, 0) + Nvl(n_结算金额, 0);
          v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
        End Loop;
      End If;
    
      If Nvl(冲预交_In, 0) <> 0 Then
        --处理总预交
        n_结算合计 := n_结算合计 + Nvl(冲预交_In, 0);
        n_预交金额 := 冲预交_In;
        For r_Deposit In c_Deposit(病人id_In, v_冲预交病人ids) Loop
          n_结算金额 := Case
                      When r_Deposit.金额 - n_预交金额 < 0 Then
                       r_Deposit.金额
                      Else
                       n_预交金额
                    End;
          If r_Deposit.结帐id = 0 Then
            --第一次冲预交(填上结帐ID,金额为0)
            Update 病人预交记录 Set 冲预交 = 0, 结帐id = n_结帐id, 结算性质 = 4 Where ID = r_Deposit.原预交id;
          End If;
          --冲上次剩余额
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 预交类别, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名,
             操作员编号, 冲预交, 结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 预交类别, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行,
                   单位帐号, d_登记时间, v_操作员姓名, v_操作员编号, n_结算金额, n_结帐id, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, n_结帐id, 4
            From 病人预交记录
            Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
        
          --更新病人预交余额
          Update 病人余额
          Set 预交余额 = Nvl(预交余额, 0) - n_结算金额
          Where 病人id = r_Deposit.病人id And 性质 = 1 And 类型 = Nvl(1, 2)
          Returning 预交余额 Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 病人余额 (病人id, 预交余额, 性质, 类型) Values (r_Deposit.病人id, -1 * n_结算金额, 1, 1);
            n_返回值 := -1 * n_结算金额;
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 病人余额
            Where 病人id = r_Deposit.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
          End If;
        
          --检查是否已经处理完
          If r_Deposit.金额 <= n_结算金额 Then
            n_预交金额 := n_预交金额 - r_Deposit.金额;
          Else
            n_预交金额 := 0;
          End If;
          If n_预交金额 = 0 Then
            Exit;
          End If;
        End Loop;
        If n_预交金额 > 0 Then
          v_Err_Msg := '预交余额不够支付本次支付金额,不能继续操作！';
          Raise Err_Item;
        End If;
      End If;
      --剩余款项,用指定结算方支付
      n_结算金额 := Nvl(n_实收金额合计, 0) - Nvl(n_结算合计, 0);
      If Nvl(n_结算金额, 0) < 0 Then
        v_Err_Msg := '挂号的相关结算金额超出了当前实结金额,不能继续操作！';
        Raise Err_Item;
      End If;
      If Nvl(n_结算金额, 0) <> 0 Or (Nvl(n_结算金额, 0) = 0 And Nvl(冲预交_In, 0) = 0) Then
        If 结算方式_In Is Null Then
          v_Err_Msg := '未传入指定的结算方式,不能继续操作！';
          Raise Err_Item;
        End If;
      
        If Nvl(预交id_In, 0) <> 0 Then
          --传入的预交ID_In主要是为了解决三方交易,如果医保结算站用了该ID,需要用新的ID进行更新,三方交易用转入的ID
          Update 病人预交记录 Set ID = n_预交id Where ID = Nvl(预交id_In, 0);
          n_预交id := Nvl(预交id_In, 0);
        End If;
      
        Insert Into 病人预交记录
          (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 交易流水号, 交易说明, 结算序号, 合作单位, 卡类别id, 卡号,
           结算性质)
        Values
          (n_预交id, 4, 1, 单据号_In, r_Pati.病人id, 结算方式_In, Nvl(n_结算金额, 0), d_登记时间, v_操作员编号, v_操作员姓名, n_结帐id,
           合作单位_In || '缴款', n_组id, 交易流水号_In, 交易说明_In, n_结帐id, 合作单位_In, 卡类别id_In, 支付卡号_In, 4);
      End If;
    
      --更新人员缴款数据
    
      For v_缴款 In (Select 结算方式, Sum(Nvl(a.冲预交, 0)) As 冲预交
                   From 病人预交记录 A
                   Where a.结帐id = n_结帐id And Mod(a.记录性质, 10) <> 1 And Nvl(病人id, 0) = Nvl(病人id_In, 0)
                   Group By 结算方式) Loop
      
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + Nvl(v_缴款.冲预交, 0)
        Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = v_缴款.结算方式
        Returning 余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (v_操作员姓名, v_缴款.结算方式, 1, Nvl(v_缴款.冲预交, 0));
          n_返回值 := Nvl(v_缴款.冲预交, 0);
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = v_操作员姓名 And 结算方式 = 结算方式_In And 性质 = 1 And Nvl(余额, 0) = 0;
        End If;
      
      End Loop;
    
    End If;
  
    --处理挂号记录
    If 锁定类型_In = 2 Then
      Begin
        Select ID Into n_挂号id From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
      Exception
        When Others Then
          Null;
      End;
    Else
      Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
    End If;
  
    Update 病人挂号记录
    Set 记录性质 = Decode(操作方式_In, 2, 2, 1), 记录状态 = Decode(锁定类型_In, 1, 0, 1), 门诊号 = r_Pati.门诊号, 操作员姓名 = v_操作员姓名,
        操作员编号 = v_操作员编号, 预约 = Decode(操作方式_In, 1, 0, 1),
        接收人 = Decode(锁定类型_In, 1, Null, Decode(操作方式_In, 2, Null, v_操作员姓名)),
        接收时间 = Case 锁定类型_In
                  When 1 Then
                   Null
                  Else
                   Case 操作方式_In
                     When 2 Then
                      Null
                     Else
                      d_登记时间
                   End
                End, 交易流水号 = Nvl(交易流水号_In, 交易流水号), 交易说明 = Nvl(交易说明_In, 交易说明), 合作单位 = Nvl(合作单位_In, 合作单位),
        预约操作员 = Decode(操作方式_In, 1, Nvl(预约操作员, Null), Nvl(预约操作员, v_操作员姓名)),
        预约操作员编号 = Decode(操作方式_In, 1, Nvl(预约操作员编号, Null), Nvl(预约操作员编号, v_操作员编号))
    Where ID = n_挂号id;
    If Sql%NotFound Then
      Begin
        Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = r_Pati.付款方式 And Rownum < 2;
      Exception
        When Others Then
          v_付款方式 := Null;
      End;
      Insert Into 病人挂号记录
        (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 预约时间, 操作员编号,
         操作员姓名, 复诊, 号序, 预约, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 医疗付款方式, 预约操作员, 预约操作员编号)
      Values
        (n_挂号id, 单据号_In, Decode(操作方式_In, 2, 2, 1), Decode(锁定类型_In, 1, 0, 1), r_Pati.病人id, r_Pati.门诊号, r_Pati.姓名,
         r_Pati.性别, r_Pati.年龄, 号码_In, 0, v_诊室, Null, r_安排.科室id, r_安排.医生姓名, 0, Null, d_登记时间, 发生时间_In,
         Case When(Nvl(操作方式_In, 0)) = 1 Then Null Else 发生时间_In End, v_操作员编号, v_操作员姓名, 0, n_号序, Decode(操作方式_In, 1, 0, 1),
         Decode(操作方式_In, 2, Null, v_操作员姓名), Decode(操作方式_In, 2, To_Date(Null), d_登记时间), 交易流水号_In, 交易说明_In, 合作单位_In,
         v_付款方式, Decode(操作方式_In, 1, Null, v_操作员姓名), Decode(操作方式_In, 1, Null, v_操作员编号));
    End If;
    --锁定单据不能产生队列
    If 锁定类型_In <> 1 Then
      n_预约生成队列 := 0;
      If 操作方式_In > 1 Then
        n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
      End If;
      --挂号和收费的预约都直接进入队列(收费预约缺少接收过程,所以直接和挂号一样直接进入队列)
      If 操作方式_In <> 2 Or n_预约生成队列 = 1 Then
        If Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113)) <> 0 Then
          --排队叫号模式:-0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站
          If Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113)) = 0 Or n_预约生成队列 = 1 Then
            n_分时点显示 := Nvl(Zl_To_Number(zl_GetSysParameter(270)), 0);
            If Nvl(操作方式_In, 0) > 1 And n_分时点显示 = 1 And n_启用分时段 = 1 Then
              n_分时点显示 := 1;
            Else
              n_分时点显示 := Null;
            End If;
            --产生队列
            --.按”执行部门” 的方式生成队列
            v_队列名称 := r_安排.科室id;
            v_排队号码 := Zlgetnextqueue(r_安排.科室id, n_挂号id, 号码_In || '|' || 号序_In);
            --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)
            v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
            --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)
            d_排队时间 := Zl_Get_Queuedate(n_挂号id, 号码_In, 号序_In, d_Date);
            --  队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,v_排队标记,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In, 排队时间_In
            Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, r_安排.科室id, v_排队号码, Null, r_Pati.姓名, r_Pati.病人id, v_诊室, r_安排.医生姓名,
                             d_排队时间, 预约方式_In, n_分时点显示, v_排队序号);
          End If;
        End If;
      End If;
    
      If Nvl(操作方式_In, 0) = 1 Then
        --处理票据使用情况
        If 票据号_In Is Not Null Then
          Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
          --发出票据
          Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 4, 单据号_In);
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
          Values
            (票据使用明细_Id.Nextval, Decode(收费票据_In, 1, 1, 4), 票据号_In, 1, 1, 领用id_In, n_打印id, d_登记时间, v_操作员姓名);
          --状态改动
          Update 票据领用记录
          Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
          Where ID = Nvl(领用id_In, 0);
        End If;
        --病人本次就诊(以发生时间为准)
        If Nvl(r_Pati.病人id, 0) <> 0 Then
          Update 病人信息 Set 就诊时间 = 发生时间_In, 就诊状态 = 1, 就诊诊室 = v_诊室 Where 病人id = r_Pati.病人id;
        End If;
      End If;
    End If;
    --病人挂号汇总
    --解锁单据时不用再对汇总单据进行统计了 在锁定单据时已经进行了汇总
    If 锁定类型_In <> 2 Then
      --操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
      --是否为预约接收:0-非预约挂号; 1-预约挂号,2-预约接收;3-收费预约
      n_预约 := Case
                When Nvl(操作方式_In, 0) = 1 Then
                 0
                When Nvl(操作方式_In, 0) = 2 Then
                 1
                When Nvl(操作方式_In, 0) = 3 Then
                 3
                Else
                 0
              End;
      Zl_病人挂号汇总_Update(r_安排.医生姓名, r_安排.医生id, r_安排.项目id, r_安排.科室id, 发生时间_In, n_预约, 号码_In);
    End If;
    --消息推送
    Begin
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 1, n_挂号id;
    Exception
      When Others Then
        Null;
    End;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]+' || v_Err_Msg || '+[ZLSOFT]');
  When Err_Special Then
    Raise_Application_Error(-20105, '[ZLSOFT]+' || v_Err_Msg || '+[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_三方机构挂号_Insert;
/

--102760:刘尔旋,2016-11-23,支付宝并发错误提示更改
Create Or Replace Procedure Zl_结帐费用记录_Insert
(
  Id_In       住院费用记录.Id%Type,
  No_In       住院费用记录.No%Type,
  记录性质_In 住院费用记录.记录性质%Type,
  记录状态_In 住院费用记录.记录状态%Type,
  执行状态_In 住院费用记录.执行状态%Type,
  序号_In     住院费用记录.序号%Type,
  结帐金额_In 住院费用记录.结帐金额%Type,
  结帐id_In   住院费用记录.结帐id%Type
) As
  n_Next_Id    住院费用记录.Id%Type;
  n_病人id     住院费用记录.病人id%Type;
  n_主页id     住院费用记录.主页id%Type;
  n_病人病区id 住院费用记录.病人病区id%Type;
  n_病人科室id 住院费用记录.病人科室id%Type;
  n_开单部门id 住院费用记录.开单部门id%Type;
  n_执行部门id 住院费用记录.执行部门id%Type;
  n_收入项目id 住院费用记录.收入项目id%Type;
  n_门诊标志   住院费用记录.门诊标志%Type;
  n_记帐费用   住院费用记录.记帐费用%Type;
  v_操作员     住院费用记录.操作员姓名%Type;
  v_操作员姓名 住院费用记录.操作员姓名%Type;
  v_操作员编码 住院费用记录.操作员编号%Type;

  n_结帐金额 住院费用记录.结帐金额%Type;
  n_实收金额 住院费用记录.实收金额%Type;
  n_返回值   病人余额.预交余额%Type;
  n_类别     Number(18);
  v_Temp     Varchar2(500);

  Err_Custom Exception;
  Err_Special Exception;
  v_Error Varchar2(255);
  n_来源  Number;
Begin
  --人员id,人员编号,人员姓名
  v_Temp := Zl_Identity(1);
  If Not (Nvl(v_Temp, '0') = '0' Or Nvl(v_Temp, '_') = '_') Then
    v_Temp       := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_操作员编码 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_操作员姓名 := v_Temp;
  End If;

  If Id_In <> 0 Then
    Begin
      Select 2 Into n_来源 From 住院费用记录 Where ID = Id_In;
    Exception
      When Others Then
        n_来源 := 1;
    End;
  
    --第一次结帐但部分结
    If n_来源 = 1 Then
      Update 门诊费用记录 Set 结帐金额 = 结帐金额_In, 结帐id = 结帐id_In Where ID = Id_In And 结帐id Is Null;
    Else
      Update 住院费用记录 Set 结帐金额 = 结帐金额_In, 结帐id = 结帐id_In Where ID = Id_In And 结帐id Is Null;
    End If;
  
    If Sql%RowCount = 0 Then
      If n_来源 = 1 Then
        Select Max(b.操作员姓名)
        Into v_操作员
        From 门诊费用记录 A, 病人结帐记录 B
        Where a.Id = Id_In And b.Id = a.结帐id;
      Else
        Select Max(b.操作员姓名)
        Into v_操作员
        From 住院费用记录 A, 病人结帐记录 B
        Where a.Id = Id_In And b.Id = a.结帐id;
      End If;
      If v_操作员 Is Null Then
        v_Error := '未发现结帐的费用,当前结帐操作不能继续。';
        Raise Err_Custom;
      Else
        If v_操作员姓名 = v_操作员 Then
          v_Error := '发现已经被结帐的费用,当前结帐操作不能继续。';
          Raise Err_Special;
        Else
          v_Error := '发现已经被其他人结帐的费用,当前结帐操作不能继续。';
          Raise Err_Custom;
        End If;
      End If;
    End If;
  
    n_Next_Id := Id_In;
  Else
    --结以前的余帐
    Select 病人费用记录_Id.Nextval Into n_Next_Id From Dual;
  
    If Mod(记录性质_In, 10) = 3 Or Mod(记录性质_In, 10) = 5 Then
      --自动记帐或就诊卡;肯定是住院
      n_来源 := 2;
    Else
      Begin
        If 记录状态_In = 1 Then
          Select 2
          Into n_来源
          From 住院费用记录
          Where NO = No_In And 序号 = 序号_In And 记录状态 In (1, 3) And Nvl(执行状态, 0) = Nvl(执行状态_In, 0) And
                Substr(记录性质, Length(记录性质), 1) = 记录性质_In And Rownum = 1;
        Else
          Select 2
          Into n_来源
          From 住院费用记录
          Where NO = No_In And 序号 = 序号_In And 记录状态 = 记录状态_In And Nvl(执行状态, 0) = Nvl(执行状态_In, 0) And
                Substr(记录性质, Length(记录性质), 1) = 记录性质_In And Rownum = 1;
        End If;
      Exception
        When Others Then
          n_来源 := 1;
      End;
    End If;
  
    If n_来源 = 1 Then
      If 记录状态_In = 1 Then
        Insert Into 门诊费用记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 记帐单id, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 病人科室id, 费别, 收费类别,
           收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 划价人, 开单部门id, 开单人, 发生时间,
           登记时间, 执行部门id, 执行状态, 执行人, 执行时间, 操作员姓名, 操作员编号, 结帐金额, 结帐id, 保险项目否, 保险大类id, 统筹金额, 保险编码, 费用类型, 是否急诊, 摘要, 主页id)
          Select n_Next_Id, NO, 实际票号, To_Number('1' || 记录性质_In), 记录状态, 序号, 从属父号, 价格父号, 记帐单id, 病人id, 医嘱序号, 门诊标志, 姓名, 性别,
                 年龄, 标识号, 付款方式, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价,
                 Null, Null, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 执行人, 执行时间, 操作员姓名, 操作员编号, 结帐金额_In, 结帐id_In,
                 保险项目否, 保险大类id, 统筹金额, 保险编码, 费用类型, 是否急诊, 摘要, 主页id
          From 门诊费用记录
          Where NO = No_In And 序号 = 序号_In And 记录状态 In (1, 3) And Nvl(执行状态, 0) = Nvl(执行状态_In, 0) And
                Substr(记录性质, Length(记录性质), 1) = 记录性质_In And Rownum = 1;
      Else
        Insert Into 门诊费用记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 记帐单id, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 病人科室id, 费别, 收费类别,
           收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 划价人, 开单部门id, 开单人, 发生时间,
           登记时间, 执行部门id, 执行状态, 执行人, 执行时间, 操作员姓名, 操作员编号, 结帐金额, 结帐id, 保险项目否, 保险大类id, 统筹金额, 保险编码, 费用类型, 是否急诊, 摘要, 主页id)
          Select n_Next_Id, NO, 实际票号, To_Number('1' || 记录性质_In), 记录状态, 序号, 从属父号, 价格父号, 记帐单id, 病人id, 医嘱序号, 门诊标志, 姓名, 性别,
                 年龄, 标识号, 付款方式, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价,
                 Null, Null, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 执行人, 执行时间, 操作员姓名, 操作员编号, 结帐金额_In, 结帐id_In,
                 保险项目否, 保险大类id, 统筹金额, 保险编码, 费用类型, 是否急诊, 摘要, 主页id
          From 门诊费用记录
          Where NO = No_In And 序号 = 序号_In And 记录状态 = 记录状态_In And Nvl(执行状态, 0) = Nvl(执行状态_In, 0) And
                Substr(记录性质, Length(记录性质), 1) = 记录性质_In And Rownum = 1;
      End If;
      --检查多次结帐后结帐金额是否高于原金额
      Select Nvl(Sum(实收金额), 0), Nvl(Sum(结帐金额), 0)
      Into n_实收金额, n_结帐金额
      From 门诊费用记录
      Where NO = No_In And 序号 = 序号_In And 记录状态 = 记录状态_In And Substr(记录性质, Length(记录性质), 1) = 记录性质_In And
            Nvl(执行状态, 0) = 执行状态_In;
    
    Else
      If 记录状态_In = 1 Then
        Insert Into 住院费用记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 记帐单id, 病人id, 主页id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 床号, 病人病区id,
           病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 划价人,
           开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 执行人, 执行时间, 操作员姓名, 操作员编号, 结帐金额, 结帐id, 保险项目否, 保险大类id, 统筹金额, 保险编码, 费用类型,
           是否急诊, 摘要, 医疗小组id)
          Select n_Next_Id, NO, 实际票号, To_Number('1' || 记录性质_In), 记录状态, 序号, 从属父号, 价格父号, 多病人单, 记帐单id, 病人id, 主页id, 医嘱序号,
                 门诊标志, 姓名, 性别, 年龄, 标识号, 床号, 病人病区id, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用,
                 收入项目id, 收据费目, 标准单价, Null, Null, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 执行人, 执行时间, 操作员姓名, 操作员编号,
                 结帐金额_In, 结帐id_In, 保险项目否, 保险大类id, 统筹金额, 保险编码, 费用类型, 是否急诊, 摘要, 医疗小组id
          From 住院费用记录
          Where NO = No_In And 序号 = 序号_In And 记录状态 In (1, 3) And Nvl(执行状态, 0) = Nvl(执行状态_In, 0) And
                Substr(记录性质, Length(记录性质), 1) = 记录性质_In And Rownum = 1;
      Else
        Insert Into 住院费用记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 记帐单id, 病人id, 主页id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 床号, 病人病区id,
           病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 划价人,
           开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 执行人, 执行时间, 操作员姓名, 操作员编号, 结帐金额, 结帐id, 保险项目否, 保险大类id, 统筹金额, 保险编码, 费用类型,
           是否急诊, 摘要, 医疗小组id)
          Select n_Next_Id, NO, 实际票号, To_Number('1' || 记录性质_In), 记录状态, 序号, 从属父号, 价格父号, 多病人单, 记帐单id, 病人id, 主页id, 医嘱序号,
                 门诊标志, 姓名, 性别, 年龄, 标识号, 床号, 病人病区id, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用,
                 收入项目id, 收据费目, 标准单价, Null, Null, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 执行人, 执行时间, 操作员姓名, 操作员编号,
                 结帐金额_In, 结帐id_In, 保险项目否, 保险大类id, 统筹金额, 保险编码, 费用类型, 是否急诊, 摘要, 医疗小组id
          From 住院费用记录
          Where NO = No_In And 序号 = 序号_In And 记录状态 = 记录状态_In And Nvl(执行状态, 0) = Nvl(执行状态_In, 0) And
                Substr(记录性质, Length(记录性质), 1) = 记录性质_In And Rownum = 1;
      End If;
      --检查多次结帐后结帐金额是否高于原金额
      Select Nvl(Sum(实收金额), 0), Nvl(Sum(结帐金额), 0)
      Into n_实收金额, n_结帐金额
      From 住院费用记录
      Where NO = No_In And 序号 = 序号_In And 记录状态 = 记录状态_In And Substr(记录性质, Length(记录性质), 1) = 记录性质_In And
            Nvl(执行状态, 0) = 执行状态_In;
    End If;
    If n_结帐金额 > n_实收金额 Then
      If n_来源 = 1 Then
        Select Max(b.操作员姓名)
        Into v_操作员
        From 门诊费用记录 A, 病人结帐记录 B
        Where a.Id = Id_In And b.Id = a.结帐id;
      Else
        Select Max(b.操作员姓名)
        Into v_操作员
        From 住院费用记录 A, 病人结帐记录 B
        Where a.Id = Id_In And b.Id = a.结帐id;
      End If;
      If v_操作员 Is Null Then
        v_Error := '未发现结帐的费用,当前结帐操作不能继续。';
        Raise Err_Custom;
      Else
        If v_操作员姓名 = v_操作员 Then
          v_Error := '发现已经被结帐的费用,当前结帐操作不能继续。';
          Raise Err_Special;
        Else
          v_Error := '发现已经被其他人结帐的费用,当前结帐操作不能继续。';
          Raise Err_Custom;
        End If;
      End If;
    End If;
  End If;
  If n_来源 = 1 Then
    Select 病人id, Null, Null, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 门诊标志, 记帐费用
    Into n_病人id, n_主页id, n_病人病区id, n_病人科室id, n_开单部门id, n_执行部门id, n_收入项目id, n_门诊标志, n_记帐费用
    From 门诊费用记录
    Where ID = n_Next_Id;
    n_类别 := 1;
  Else
    Select 病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 门诊标志, 记帐费用
    Into n_病人id, n_主页id, n_病人病区id, n_病人科室id, n_开单部门id, n_执行部门id, n_收入项目id, n_门诊标志, n_记帐费用
    From 住院费用记录
    Where ID = n_Next_Id;
  
    If Nvl(n_门诊标志, 0) = 1 Or Nvl(n_门诊标志, 0) = 2 Then
      n_类别 := n_门诊标志;
    Elsif Nvl(n_主页id, 0) = 0 Or Nvl(n_门诊标志, 0) = 4 Then
      n_类别 := 1;
    Else
      n_类别 := 2;
    End If;
  End If;

  If Nvl(n_门诊标志, 0) <> 4 Then
    --病人余额
    Update 病人余额
    Set 费用余额 = Nvl(费用余额, 0) - 结帐金额_In
    Where 病人id = n_病人id And 性质 = 1 And 类型 = n_类别
    Returning 费用余额 Into n_返回值;
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 性质, 类型, 预交余额, 费用余额) Values (n_病人id, 1, n_类别, 0, -1 * 结帐金额_In);
      n_返回值 := -1 * 结帐金额_In;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 病人余额 Where Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0 And 病人id = n_病人id;
    End If;
  End If;

  --病人未结费用
  Update 病人未结费用
  Set 金额 = Nvl(金额, 0) - 结帐金额_In
  Where 病人id = n_病人id And Nvl(主页id, 0) = Nvl(n_主页id, 0) And Nvl(病人病区id, 0) = Nvl(n_病人病区id, 0) And
        Nvl(病人科室id, 0) = Nvl(n_病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(n_开单部门id, 0) And Nvl(执行部门id, 0) = Nvl(n_执行部门id, 0) And
        收入项目id + 0 = n_收入项目id And 来源途径 + 0 = n_门诊标志
  Returning 金额 Into n_返回值;
  If Sql%RowCount = 0 Then
    Insert Into 病人未结费用
      (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
    Values
      (n_病人id, Decode(n_主页id, 0, Null, n_主页id), Decode(n_病人病区id, 0, Null, n_病人病区id), n_病人科室id, n_开单部门id, n_执行部门id,
       n_收入项目id, n_门诊标志, -1 * 结帐金额_In);
    n_返回值 := -1 * 结帐金额_In;
  End If;
  If Nvl(n_返回值, 0) = 0 Then
    Delete From 病人未结费用 Where 病人id = n_病人id And Nvl(金额, 0) = 0;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Err_Special Then
    Raise_Application_Error(-20105, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_结帐费用记录_Insert;
/

--102760:刘尔旋,2016-11-23,支付宝并发错误提示更改
Create Or Replace Procedure Zl_结帐费用记录_Batch
(
  Ids_In    Varchar2,
  病人id_In 住院费用记录.病人id%Type,
  结帐id_In 住院费用记录.结帐id%Type
  
) As
  Err_Item Exception;
  v_Err_Msg Varchar2(255);
  v_Temp    Varchar2(500);
  Err_Special Exception;
  v_操作员     住院费用记录.操作员姓名%Type;
  v_操作员姓名 住院费用记录.操作员姓名%Type;
  v_操作员编码 住院费用记录.操作员编号%Type;

  n_门诊结算合计 住院费用记录.结帐金额%Type;
  n_住院结算合计 住院费用记录.结帐金额%Type;
  n_类别         Number;

  n_来源   Number; --1门诊;2-住院;3-门诊和住院
  n_返回值 病人余额.费用余额%Type;
Begin
  --人员id,人员编号,人员姓名
  v_Temp := Zl_Identity(1);
  If Not (Nvl(v_Temp, '0') = '0' Or Nvl(v_Temp, '_') = '_') Then
    v_Temp       := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_操作员编码 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_操作员姓名 := v_Temp;
  End If;
  n_门诊结算合计 := 0;
  n_住院结算合计 := 0;
  Begin
    Select Case
             When Max(住院来源) = 1 And Max(门诊来源) = 1 Then
              3
             When Max(门诊来源) = 1 Then
              1
             Else
              2
           End
    Into n_来源
    From (Select /*+ Rule*/
            1 As 住院来源, 0 As 门诊来源
           From 住院费用记录 A, (Select Column_Value From Table(Cast(f_Num2list(Ids_In) As Zltools.t_Numlist))) J
           Where a.Id = j.Column_Value And 病人id + 0 = 病人id_In And 结帐id Is Null And Rownum = 1
           Union All
           Select /*+ Rule*/
            0 As 住院来源, 1 As 门诊来源
           From 门诊费用记录 A, (Select Column_Value From Table(Cast(f_Num2list(Ids_In) As Zltools.t_Numlist))) J
           Where a.Id = j.Column_Value And 病人id + 0 = 病人id_In And 结帐id Is Null And Rownum = 1);
  Exception
    When Others Then
      n_来源 := 2;
  End;

  --第一次结帐并且全结,Ids_In最大长度限制3998
  If n_来源 = 1 Then
    Update 门诊费用记录
    Set 结帐金额 = 实收金额, 结帐id = 结帐id_In
    Where 病人id = 病人id_In And Instr(',' || Ids_In || ',', ',' || ID || ',') > 0 And 结帐id Is Null;
  Elsif n_来源 = 2 Then
    Update 住院费用记录
    Set 结帐金额 = 实收金额, 结帐id = 结帐id_In
    Where 病人id = 病人id_In And Instr(',' || Ids_In || ',', ',' || ID || ',') > 0 And 结帐id Is Null;
  Else
    Update 门诊费用记录
    Set 结帐金额 = 实收金额, 结帐id = 结帐id_In
    Where 病人id = 病人id_In And Instr(',' || Ids_In || ',', ',' || ID || ',') > 0 And 结帐id Is Null;
  
    Update 住院费用记录
    Set 结帐金额 = 实收金额, 结帐id = 结帐id_In
    Where 病人id = 病人id_In And Instr(',' || Ids_In || ',', ',' || ID || ',') > 0 And 结帐id Is Null;
  End If;

  If Sql%RowCount = 0 Then
    If n_来源 = 1 Then
      Select Max(b.操作员姓名)
      Into v_操作员
      From 门诊费用记录 A, 病人结帐记录 B
      Where Instr(',' || Ids_In || ',', ',' || a.Id || ',') > 0 And b.Id = a.结帐id;
    Else
      Select Max(b.操作员姓名)
      Into v_操作员
      From 住院费用记录 A, 病人结帐记录 B
      Where Instr(',' || Ids_In || ',', ',' || a.Id || ',') > 0 And b.Id = a.结帐id;
    End If;
    If v_操作员 Is Null Then
      v_Err_Msg := '未发现结帐的费用,当前结帐操作不能继续。';
      Raise Err_Item;
    Else
      If v_操作员姓名 = v_操作员 Then
        v_Err_Msg := '发现已经被结帐的费用,当前结帐操作不能继续。';
        Raise Err_Special;
      Else
        v_Err_Msg := '发现已经被其他人结帐的费用,当前结帐操作不能继续。';
        Raise Err_Item;
      End If;
    End If;
  End If;
  If n_来源 = 2 Or n_来源 = 3 Then
    For r_f In (Select 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 门诊标志, 记帐费用, Sum(结帐金额) 结帐金额

                
                From 住院费用记录
                Where 病人id = 病人id_In And Instr(',' || Ids_In || ',', ',' || ID || ',') > 0
                Group By 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 门诊标志, 记帐费用) Loop
    
      --病人未结费用
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) - r_f.结帐金额
      Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(r_f.主页id, 0) And Nvl(病人病区id, 0) = Nvl(r_f.病人病区id, 0) And
            Nvl(病人科室id, 0) = Nvl(r_f.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(r_f.开单部门id, 0) And
            Nvl(执行部门id, 0) = Nvl(r_f.执行部门id, 0) And 收入项目id + 0 = r_f.收入项目id And 来源途径 + 0 = r_f.门诊标志;
      If Sql%RowCount = 0 Then
        Insert Into 病人未结费用
          (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
        Values
          (病人id_In, r_f.主页id, r_f.病人病区id, r_f.病人科室id, r_f.开单部门id, r_f.执行部门id, r_f.收入项目id, r_f.门诊标志, -1 * r_f.结帐金额);
      End If;
    
      If Nvl(r_f.门诊标志, 0) = 1 Or Nvl(r_f.门诊标志, 0) = 2 Then
        n_类别 := r_f.门诊标志;
      Elsif Nvl(r_f.主页id, 0) = 0 Or Nvl(r_f.门诊标志, 0) = 4 Then
        n_类别 := 1;
      Else
        n_类别 := 2;
      End If;
    
      If Nvl(r_f.门诊标志, 0) <> 4 Then
        If n_类别 = 1 Then
          n_门诊结算合计 := Nvl(n_门诊结算合计, 0) + Nvl(r_f.结帐金额, 0);
        Else
          n_住院结算合计 := Nvl(n_住院结算合计, 0) + Nvl(r_f.结帐金额, 0);
        End If;
      End If;
    End Loop;
  End If;
  If n_来源 = 3 Or n_来源 = 1 Then
    For r_f In (Select Null As 主页id, Null As 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 门诊标志, 记帐费用, Sum(结帐金额) 结帐金额
                From 门诊费用记录
                Where 病人id = 病人id_In And Instr(',' || Ids_In || ',', ',' || ID || ',') > 0
                Group By 病人科室id, 开单部门id, 执行部门id, 收入项目id, 门诊标志, 记帐费用) Loop
    
      --病人未结费用
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) - r_f.结帐金额
      Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(r_f.主页id, 0) And Nvl(病人病区id, 0) = Nvl(r_f.病人病区id, 0) And
            Nvl(病人科室id, 0) = Nvl(r_f.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(r_f.开单部门id, 0) And
            Nvl(执行部门id, 0) = Nvl(r_f.执行部门id, 0) And 收入项目id + 0 = r_f.收入项目id And 来源途径 + 0 = r_f.门诊标志;
      If Sql%RowCount = 0 Then
        Insert Into 病人未结费用
          (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
        Values
          (病人id_In, r_f.主页id, r_f.病人病区id, r_f.病人科室id, r_f.开单部门id, r_f.执行部门id, r_f.收入项目id, r_f.门诊标志, -1 * r_f.结帐金额);
      End If;
      If Nvl(r_f.门诊标志, 0) = 1 Or Nvl(r_f.门诊标志, 0) = 2 Then
        n_类别 := r_f.门诊标志;
      Elsif Nvl(r_f.主页id, 0) = 0 Or Nvl(r_f.门诊标志, 0) = 4 Then
        n_类别 := 1;
      Else
        n_类别 := 2;
      End If;
    
      If Nvl(r_f.门诊标志, 0) <> 4 Then
        If n_类别 = 1 Then
          n_门诊结算合计 := Nvl(n_门诊结算合计, 0) + Nvl(r_f.结帐金额, 0);
        Else
          n_住院结算合计 := Nvl(n_住院结算合计, 0) + Nvl(r_f.结帐金额, 0);
        End If;
      End If;
    End Loop;
  End If;

  Delete From 病人未结费用 Where 病人id = 病人id_In And Nvl(金额, 0) = 0;

  --病人余额
  If Nvl(n_门诊结算合计, 0) <> 0 Then
    Update 病人余额
    Set 费用余额 = Nvl(费用余额, 0) - n_门诊结算合计
    Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1
    Returning 费用余额 Into n_返回值;
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 性质, 类型, 预交余额, 费用余额) Values (病人id_In, 1, 1, 0, -1 * n_门诊结算合计);
      n_返回值 := -1 * n_门诊结算合计;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 病人余额 Where Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0 And 病人id = 病人id_In And 类型 = 1;
    End If;
  End If;
  If Nvl(n_住院结算合计, 0) <> 0 Then
    Update 病人余额
    Set 费用余额 = Nvl(费用余额, 0) - n_住院结算合计
    Where 病人id = 病人id_In And 性质 = 1 And 类型 = 2
    Returning 费用余额 Into n_返回值;
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 性质, 类型, 预交余额, 费用余额) Values (病人id_In, 1, 2, 0, -1 * n_住院结算合计);
      n_返回值 := -1 * n_住院结算合计;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 病人余额 Where Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0 And 病人id = 病人id_In And 类型 = 2;
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Err_Special Then
    Raise_Application_Error(-20105, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_结帐费用记录_Batch;
/


--102112:冉俊明,2016-12-22,门诊划价收费时门诊病人标识号填写了住院号。
--102760:刘尔旋,2016-11-23,支付宝并发错误提示更改
Create Or Replace Procedure Zl_病人划价收费_Insert
(
  No_In         门诊费用记录.No%Type,
  病人id_In     门诊费用记录.病人id%Type,
  病人来源_In   Number,
  付款方式_In   门诊费用记录.付款方式%Type,
  姓名_In       门诊费用记录.姓名%Type,
  性别_In       门诊费用记录.性别%Type,
  年龄_In       门诊费用记录.年龄%Type,
  病人科室id_In 门诊费用记录.病人科室id%Type,
  开单部门id_In 门诊费用记录.开单部门id%Type,
  开单人_In     门诊费用记录.开单人%Type,
  结帐id_In     门诊费用记录.结帐id%Type,
  发生时间_In   门诊费用记录.发生时间%Type,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  发药窗口_In   Varchar2 := Null,
  是否急诊_In   门诊费用记录.是否急诊%Type := 0,
  登记时间_In   门诊费用记录.登记时间%Type := Null
) As
  --功能：用于收费时收取划价单费用
  --参数：
  --      发药窗口_In:执行部门ID1|发药窗口1;...;执行部门IDn|发药窗口n

  --        病人来源_IN:1-门诊;2-住院
  --说明：
  --        1.收取划价费用时,才计算费用相关汇总,在划价时不处理;但药品相关汇总(姓名除外)划价时已经计算。
  --        2.收取划价费用时,目前界面及过程中未处理加收工本费,由划价时直接处理。
  --该游标为划价原单据内容
  Cursor c_Price Is
    Select ID
    From 门诊费用记录
    Where NO = No_In And 记录性质 = 1 And 记录状态 = 0 And 操作员姓名 Is Null
    Order By 序号;

  n_Array_Size Number := 200;
  t_费用id     t_Numlist;
  v_部门名称   部门表.名称%Type;

  v_标识号   门诊费用记录.标识号%Type;
  n_病人来源 门诊费用记录.门诊标志%Type;
  v_付款方式 医疗付款方式.名称%Type;

  --临时变量
  n_Count      Number;
  v_操作员姓名 门诊费用记录.操作员姓名%Type;
  n_新病人模式 Number;
  v_出库no     药品收发记录.No%Type;
  v_Date       Date;
  v_Err_Msg    Varchar2(255);
  Err_Item Exception;
  Err_Special Exception;
  n_组id 财务缴款分组.Id%Type;

Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  Select Count(ID)
  Into n_Count
  From 门诊费用记录
  Where 记录性质 = 1 And 记录状态 = 0 And NO = No_In And 操作员姓名 Is Null;
  If n_Count = 0 Then
    Select Max(操作员姓名) Into v_操作员姓名 From 门诊费用记录 Where 记录性质 = 1 And NO = No_In;
    If v_操作员姓名 Is Not Null Then
      If v_操作员姓名 = 操作员姓名_In Then
        v_Err_Msg := '不能读取划价单内容,该单据已经被收费！';
        Raise Err_Special;
      Else
        v_Err_Msg := '不能读取划价单内容,该单据已经被收费！';
        Raise Err_Item;
      End If;
    Else
      v_Err_Msg := '不能读取划价单内容,该单据已经被删除！';
      Raise Err_Item;
    End If;
  End If;
  v_Date := 登记时间_In;
  If v_Date Is Null Then
    Select Sysdate Into v_Date From Dual;
  End If;
  If Nvl(病人id_In, 0) <> 0 Then
    Select Decode(当前科室id, Null, 门诊号, 住院号), Decode(当前科室id, Null, 1, 2)
    Into v_标识号, n_病人来源
    From 病人信息
    Where 病人id = 病人id_In;
  End If;

  ------------------------------------------------------------------------------------------------------------------------
  --批量更新
  Open c_Price;
  Loop
    Fetch c_Price Bulk Collect
      Into t_费用id Limit n_Array_Size;
    Exit When t_费用id.Count = 0;
  
    --循环处理门诊费用记录
    Forall I In 1 .. t_费用id.Count
    --执行状态相关字段不处理,在划价时处理;因为可能未收费发药,这种已执行的划价单是允许收费操作的。
    --为保证与预交结算记录的时间相同,重新填写登记时间,但药品部分不变动。
      Update 门诊费用记录
      Set 记录状态 = 1, 病人id = Decode(病人id_In, 0, Null, 病人id_In), 门诊标志 = Decode(标识号, Null, Nvl(n_病人来源, 门诊标志), 门诊标志),
          标识号 = Nvl(标识号, v_标识号), 付款方式 = 付款方式_In, 姓名 = 姓名_In, 年龄 = 年龄_In, 性别 = 性别_In,
          --可能保持医嘱发送的内容
          病人科室id = Nvl(病人科室id_In, 病人科室id), 开单部门id = Nvl(开单部门id_In, 开单部门id), 开单人 = Nvl(开单人_In, 开单人), 结帐金额 = 实收金额,
          结帐id = 结帐id_In, 发生时间 = 发生时间_In, 登记时间 = v_Date, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In, 是否急诊 = 是否急诊_In,
          缴款组id = n_组id, 费用状态 = 1, 执行状态 = Decode(Nvl(执行状态, 0), -1, Null, Nvl(执行状态, 0))
      Where ID = t_费用id(I) And 记录状态 = 0;
  
    If Sql%RowCount <> t_费用id.Count Then
      Select Count(1)
      Into n_Count
      From 门诊费用记录
      Where 记录状态 = 1 And ID In (Select Column_Value From Table(t_费用id));
      If n_Count <> t_费用id.Count Then
        v_Err_Msg := '由于并发操作,该单据已经删除！';
        Raise Err_Item;
      Else
        Select Max(操作员姓名)
        Into v_操作员姓名
        From 门诊费用记录
        Where 记录状态 = 1 And ID In (Select Column_Value From Table(t_费用id));
        If v_操作员姓名 = 操作员姓名_In Then
          v_Err_Msg := '由于并发操作,该单据已经收费！';
          Raise Err_Special;
        Else
          v_Err_Msg := '由于并发操作,该单据已经收费！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  End Loop;

  Close c_Price;

  --相关汇总表的处理
  --药品部分非费用信息的修改
  --药品未发记录(如果已发药则修改不到),分离发药时无库房ID
  --可能存在材料和药品库房相同，但材料无发药窗口
  Update 未发药品记录
  Set 病人id = Decode(病人id_In, 0, Null, 病人id_In), 姓名 = 姓名_In, 对方部门id = 开单部门id_In, 已收费 = 1, 填制日期 = v_Date
  Where 单据 = 24 And NO = No_In And
        Nvl(库房id, 0) In (Select Distinct Nvl(执行部门id, 0)
                         From 门诊费用记录
                         Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 = '4');

  Update 未发药品记录
  Set 病人id = Decode(病人id_In, 0, Null, 病人id_In), 姓名 = 姓名_In, 对方部门id = 开单部门id_In, 已收费 = 1, 填制日期 = v_Date
  Where 单据 = 8 And NO = No_In And
        Nvl(库房id, 0) In (Select Distinct Nvl(执行部门id, 0)
                         From 门诊费用记录
                         Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 In ('5', '6', '7'));

  --药品收发记录(可能已经发药或取消发药,所有记录更改)
  Update 药品收发记录
  Set 对方部门id = 开单部门id_In, 填制日期 = Decode(Sign(Nvl(审核日期, v_Date) - v_Date), -1, 填制日期, v_Date)
  Where 单据 = 24 And NO = No_In And
        费用id + 0 In (Select ID From 门诊费用记录 Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 = '4');

  -------------------------------------------------------------------------------------------
  --处理备货卫材
  n_Count := Null;
  Begin
    Select Count(*), Max(a.No)
    Into n_Count, v_出库no
    From 药品收发记录 A, 门诊费用记录 B
    Where a.费用id = b.Id And b.收费类别 = '4' And b.记录性质 = 1 And b.记录状态 = 1 And b.No = No_In And
          Instr(',8,9,10,21,24,25,26,', ',' || a.单据 || ',') > 0 And Rownum <= 1;
  Exception
    When Others Then
      Null;
  End;
  If Nvl(n_Count, 0) > 0 Then
    If Nvl(病人科室id_In, 0) <> 0 Then
      Select 名称 Into v_部门名称 From 部门表 Where ID = 病人科室id_In;
    End If;
    v_Err_Msg := LPad(' ', 4);
    v_Err_Msg := Substr('病人姓名:' || 姓名_In || v_Err_Msg || '性别:' || 性别_In || v_Err_Msg || '年龄' || 年龄_In || v_Err_Msg ||
                        '门诊号:' || Nvl(v_标识号, '') || v_Err_Msg || '病人科室:' || v_部门名称, 1, 100);
  
    Update 药品收发记录
    Set 对方部门id = 开单部门id_In, 填制日期 = Decode(Sign(Nvl(审核日期, v_Date) - v_Date), -1, 填制日期, v_Date), 摘要 = v_Err_Msg
    Where 单据 = 21 And NO = v_出库no And
          费用id + 0 In (Select ID From 门诊费用记录 Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 = '4');
  End If;

  Update 药品收发记录
  Set 对方部门id = 开单部门id_In, 填制日期 = Decode(Sign(Nvl(审核日期, v_Date) - v_Date), -1, 填制日期, v_Date)
  Where 单据 = 8 And NO = No_In And
        费用id + 0 In
        (Select ID From 门诊费用记录 Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 In ('5', '6', '7'));

  If Not 发药窗口_In Is Null Then
    --更新发药窗口
    For v_窗口 In (Select To_Number(C1) As C1, C2 From Table(f_Str2list2(发药窗口_In, ';', '|'))) Loop
    
      Update 门诊费用记录
      Set 发药窗口 = Nvl(v_窗口.C2, 发药窗口)
      Where NO = No_In And 记录性质 = 1 And 记录状态 = 1 And 执行部门id = Nvl(v_窗口.C1, 执行部门id) And 收费类别 In ('5', '6', '7');
    
      Update 药品收发记录
      Set 发药窗口 = Nvl(v_窗口.C2, 发药窗口)
      Where 单据 = 8 And NO = No_In And 库房id = Nvl(v_窗口.C1, 库房id) And
            费用id + 0 In (Select ID
                         From 门诊费用记录
                         Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 In ('5', '6', '7'));
    
      Update 未发药品记录
      Set 发药窗口 = Nvl(v_窗口.C2, 发药窗口)
      Where 单据 = 8 And NO = No_In And 库房id = Nvl(v_窗口.C1, 库房id) And
            Nvl(库房id, 0) In (Select Distinct Nvl(执行部门id, 0)
                             From 门诊费用记录
                             Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 In ('5', '6', '7'));
    
    End Loop;
  End If;

  --更新部份病人信息
  If 病人id_In Is Not Null Then
    If 付款方式_In Is Not Null And 病人来源_In = 1 Then
      Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In;
    End If;
    --通过划价单收费时不允许改费别,因为费用不允许变
    Update 病人信息
    Set 性别 = Decode(姓名, '新病人', Nvl(性别_In, 性别), 性别), 年龄 = Decode(姓名, '新病人', Nvl(年龄_In, 年龄), 年龄),
        姓名 = Decode(姓名, '新病人', 姓名_In, 姓名), 医疗付款方式 = Nvl(v_付款方式, 医疗付款方式)
    Where 病人id = 病人id_In;
    Select Zl_To_Number(Nvl(zl_GetSysParameter('自动产生姓名', '1111'), '0')) Into n_新病人模式 From Dual;
    If n_新病人模式 = 1 Then
    
      Update 病人挂号记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In
      Where 病人id = 病人id_In And 姓名 = '新病人';
    
      Update 门诊费用记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In, 付款方式 = 付款方式_In
      Where 病人id = 病人id_In And 姓名 = '新病人';
    End If;
  End If;

  --医嘱处理
  --场合_In    Integer:=0, --0:门诊;1-住院
  --性质_In    Integer:=1, --1-收费单;2-记帐单
  --操作_In    Integer:=0, --0:删除划价单;1-收费或记帐;2-退费或销帐
  --No_In      门诊费用记录.No%Type,
  --医嘱ids_In Varchar2 := Null
  Zl_医嘱发送_计费状态_Update(0, 1, 1, No_In);

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Err_Special Then
    Raise_Application_Error(-20105, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人划价收费_Insert;
/


--96956:刘尔旋,2017-01-12,付款接口误差处理
--103209:刘尔旋,2016-12-15,服务窗医保实时结算
--102760:刘尔旋,2016-11-23,支付宝并发错误提示更改
Create Or Replace Procedure Zl_Third_Payment
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is

  -------------------------------------------------------------------------------------------------- 
  --功能:三方接口支付 
  --入参:Xml_In: 
  --<IN>
  --        <NO></NO>                       //收费单据号串,逗号分隔多个单据号
  --        <JE></JE>                       //总金额
  --        <BRID>病人ID</BRID>
  --        <SFGH></SFGH>                   //是否挂号单
  --        <WCJE>误差额</WCJE>             //误差项不传时,以总金额-本次结算费用总额为准
  --       <JSLIST>
  --         <JS>
  --              <JSKLB>支付卡类别</JSKLB >
  --              <JSKH>支付卡号</ JSKH >
  --              <JSFS>支付方式</JSFS> //支付方式:现金;支票,如果是三方卡,可以传空
  --              <JSJE>支付金额</JSJE>
  --              <JYLSH>交易流水号</JYLSH>
  --              <ZY>摘要</ZY>
  --              <SFCYJ>是否冲预交</SFCYJ>  //允冲预交时,只填JSJE节点:1-冲预交
  --              <SFXFK>是否消费卡</SFXFK>  //(1-是消费卡),消费卡时,传入结算卡类别,结算卡号,结算金额等接点
  --              <EXPENDLIST>  //扩展交易信息
  --                  <EXPEND>
  --                        <JYMC >交易名称</交易名称>
  --                        <JYLR>交易内容</JYLR>
  --                  </EXPEND>
  --              </EXPENDLIST>
  --         </JS>
  --       </JSLIST >
  --</IN>

  --出参:Xml_Out 
  --  <OUT> 
  --    <JZID></JZID>       //结帐ID
  --    <CZSJ>操作时间</CZSJ>          //HIS的登记时间
  --    DD如无下列错误结点则说明正确执行 
  --    <ERROR> 
  --      <MSG>错误信息</MSG> 
  --    </ERROR> 
  --  </OUT> 
  -------------------------------------------------------------------------------------------------- 
  v_Nos      Varchar2(4000);
  n_收费总额 门诊费用记录.实收金额%Type;

  n_卡类别id 医疗卡类别.Id%Type;
  v_结算方式 Varchar2(2000);
  n_病人id   门诊费用记录.病人id%Type;
  v_姓名     门诊费用记录.姓名%Type;
  v_性别     门诊费用记录.性别%Type;
  v_年龄     门诊费用记录.年龄%Type;

  v_医疗付款方式编码 医疗付款方式.编码%Type;
  v_操作员编码       门诊费用记录.操作员编号%Type;
  v_操作员姓名       门诊费用记录.操作员姓名%Type;
  n_结帐id           门诊费用记录.结帐id%Type;
  n_结帐金额         门诊费用记录.结帐金额%Type;
  d_收费时间         病人预交记录.收款时间%Type;
  n_消费卡id         消费卡目录.Id%Type;
  v_收费结算         Varchar2(2000);
  v_普通结算         Varchar2(4000);
  n_是否挂号         Number(3);
  n_预交支付         门诊费用记录.实收金额%Type;
  n_普通支付         门诊费用记录.实收金额%Type;
  v_结算卡号         病人预交记录.卡号%Type;
  n_结算卡序号       病人预交记录.结算卡序号%Type;
  v_交易流水号       病人预交记录.交易流水号%Type;
  v_交易说明         病人预交记录.交易说明%Type;
  v_摘要             病人预交记录.摘要%Type;
  n_科室id           挂号安排.科室id%Type;
  n_项目id           挂号安排.项目id%Type;
  n_医生id           挂号安排.医生id%Type;
  v_医生姓名         挂号安排.医生姓名%Type;
  v_号码             挂号安排.号码%Type;
  n_门诊号           病人信息.门诊号%Type;
  d_发生时间         病人挂号记录.发生时间%Type;
  v_费别             病人信息.费别%Type;
  n_号序             病人挂号记录.号序%Type;
  n_生成队列         Number(3);
  v_Para             Varchar2(500);
  n_挂号模式         Number(3);
  d_启用时间         Date;
  v_临时结算方式     病人预交记录.结算方式%Type;
  n_出诊记录id       临床出诊记录.Id%Type;
  n_医保支付         病人预交记录.冲预交%Type;
  n_Exists           Number;

  v_Temp    Varchar2(32767); --临时XML 
  x_Templet Xmltype; --模板XML 

  v_Err_Msg Varchar2(200);
  Err_Item    Exception;
  Err_Special Exception;
  n_Count    Number(18);
  v_操作员   门诊费用记录.操作员姓名%Type;
  v_发药窗口 Varchar2(4000);
  n_误差额   病人预交记录.冲预交%Type;

  Function Zl_出诊诊室(记录id_In 临床出诊记录.Id%Type) Return Varchar2 As
    n_分诊方式 临床出诊记录.分诊方式%Type;
    v_诊室     病人挂号记录.诊室%Type;
    v_Rowid    Varchar2(500);
    n_Next     Integer;
    n_First    Integer;
  Begin
    Begin
      Select Nvl(分诊方式, 0) Into n_分诊方式 From 临床出诊记录 Where ID = 记录id_In;
    Exception
      When Others Then
        v_Err_Msg := '出诊记录(' || 记录id_In || ')未找到!';
        Raise Err_Item;
    End;
  
    --0-不分诊、1-指定诊室、2-动态分诊、3-平均分诊,对应门诊诊室设置
    v_诊室 := Null;
    If n_分诊方式 = 1 Then
      --1-指定诊室
      Begin
        Select b.名称 Into v_诊室 From 临床出诊诊室记录 A, 门诊诊室 B Where a.诊室id = b.Id And a.记录id = 记录id_In;
      Exception
        When Others Then
          v_诊室 := Null;
      End;
    End If;
    If n_分诊方式 = 2 Then
      --2-动态分诊:该个号别当天挂号未诊数最少的诊室
      For c_诊室 In (Select 门诊诊室, Sum(Num) As Num
                   From (Select b.名称 As 门诊诊室, 0 As Num
                          From 临床出诊诊室记录 A, 门诊诊室 B
                          Where a.诊室id = b.Id And a.记录id = 记录id_In
                          Union All
                          Select 诊室, Count(诊室) As Num
                          From 病人挂号记录
                          Where Nvl(执行状态, 0) = 0 And 发生时间 Between Trunc(Sysdate) And Sysdate And 出诊记录id = 记录id_In And
                                诊室 In (Select d.名称
                                       From 临床出诊诊室记录 C, 门诊诊室 D
                                       Where c.诊室id = d.Id And c.记录id = 记录id_In)
                          Group By 诊室)
                   Group By 门诊诊室
                   Order By Num) Loop
        v_诊室 := c_诊室.门诊诊室;
        Exit;
      End Loop;
    End If;
    If n_分诊方式 = 3 Then
      --平均分诊：当前分配=1表示下次应取的当前诊室
      n_Next  := 0;
      n_First := 1;
      For c_诊室 In (Select a.Rowid As Rid, b.名称 As 门诊诊室, a.当前分配
                   From 临床出诊诊室记录 A, 门诊诊室 B
                   Where a.诊室id = b.Id And a.记录id = 记录id_In) Loop
        If n_First = 1 Then
          v_Rowid := c_诊室.Rid;
        End If;
        If n_Next = 1 Then
          v_诊室 := c_诊室.门诊诊室;
          Update 临床出诊诊室记录 Set 当前分配 = 1 Where Rowid = c_诊室.Rid;
          Exit;
        End If;
        If Nvl(c_诊室.当前分配, 0) = 1 Then
          Update 临床出诊诊室记录 Set 当前分配 = 0 Where Rowid = c_诊室.Rid;
          n_Next := 1;
        End If;
      End Loop;
      If v_诊室 Is Null Then
        Update 临床出诊诊室记录 Set 当前分配 = 1 Where Rowid = v_Rowid Returning 诊室id Into v_诊室;
        Select 名称 Into v_诊室 From 门诊诊室 Where ID = v_诊室;
      End If;
    End If;
    Return v_诊室;
  End;

  Function Zl_诊室(号码_In 挂号安排.号码%Type) Return Varchar2 As
    n_分诊方式 挂号安排.分诊方式%Type;
    n_安排id   挂号安排.Id%Type;
    v_诊室     病人挂号记录.诊室%Type;
    v_Rowid    Varchar2(500);
    n_Next     Integer;
    n_First    Integer;
  Begin
  
    Begin
      Select ID, Nvl(分诊方式, 0) Into n_安排id, n_分诊方式 From 挂号安排 Where 号码 = 号码_In;
    Exception
      When Others Then
        n_安排id := -1;
    End;
  
    If n_安排id = -1 Then
      v_Err_Msg := '号码(' || 号码_In || ')未找到!';
      Raise Err_Item;
    End If;
    --0-不分诊、1-指定诊室、2-动态分诊、3-平均分诊,对应门诊诊室设置
    v_诊室 := Null;
    If n_分诊方式 = 1 Then
      --1-指定诊室
      Begin
        Select 门诊诊室 Into v_诊室 From 挂号安排诊室 Where 号表id = n_安排id;
      Exception
        When Others Then
          v_诊室 := Null;
      End;
    End If;
    If n_分诊方式 = 2 Then
      --2-动态分诊:该个号别当天挂号未诊数最少的诊室
      For c_诊室 In (Select 门诊诊室, Sum(Num) As Num
                   From (Select 门诊诊室, 0 As Num
                          From 挂号安排诊室
                          Where 号表id = n_安排id
                          Union All
                          Select 诊室, Count(诊室) As Num
                          From 病人挂号记录
                          Where Nvl(执行状态, 0) = 0 And 发生时间 Between Trunc(Sysdate) And Sysdate And 号别 = 号码_In And
                                诊室 In (Select 门诊诊室 From 挂号安排诊室 Where 号表id = n_安排id)
                          Group By 诊室)
                   Group By 门诊诊室
                   Order By Num) Loop
        v_诊室 := c_诊室.门诊诊室;
        Exit;
      End Loop;
    End If;
    If n_分诊方式 = 3 Then
    
      --平均分诊：当前分配=1表示下次应取的当前诊室
      n_Next  := 0;
      n_First := 1;
      For c_诊室 In (Select Rowid As Rid, 号表id, 门诊诊室, 当前分配 From 挂号安排诊室 Where 号表id = n_安排id) Loop
        If n_First = 1 Then
          v_Rowid := c_诊室.Rid;
        End If;
        If n_Next = 1 Then
          v_诊室 := c_诊室.门诊诊室;
          Update 挂号安排诊室 Set 当前分配 = 1 Where Rowid = c_诊室.Rid;
          Exit;
        End If;
        If Nvl(c_诊室.当前分配, 0) = 1 Then
          Update 挂号安排诊室 Set 当前分配 = 0 Where Rowid = c_诊室.Rid;
          n_Next := 1;
        End If;
      End Loop;
      If v_诊室 Is Null Then
        Update 挂号安排诊室 Set 当前分配 = 1 Where Rowid = v_Rowid Returning 门诊诊室 Into v_诊室;
      End If;
    End If;
  
    Return v_诊室;
  End;
  Procedure Third_Cardbalance_Modfiy
  (
    结帐id_In     病人预交记录.结帐id%Type,
    卡类别_In     Varchar2,
    卡号_In       病人预交记录.卡号%Type,
    支付金额_In   病人预交记录.冲预交%Type,
    交易流水号_In 病人预交记录.交易流水号%Type,
    交易说明_In   病人预交记录.交易说明%Type,
    Xmlexpned_In  Xmltype
  ) Is
    n_卡类别id 医疗卡类别.Id%Type;
    v_结算方式 病人预交记录.结算方式%Type;
    v_名称     医疗卡类别.名称%Type;
  Begin
    v_Err_Msg := Null;
    Begin
      n_卡类别id := To_Number(卡类别_In);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
    If n_卡类别id = 0 Then
      Begin
        Select ID, 结算方式, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
        Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
        From 医疗卡类别
        Where 名称 = 卡类别_In;
      Exception
        When Others Then
          n_卡类别id := -1;
          v_Err_Msg  := 卡类别_In || '不存在!';
      End;
    Else
      Begin
        Select ID, 结算方式, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
        Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
        From 医疗卡类别
        Where ID = n_卡类别id;
      Exception
        When Others Then
          n_卡类别id := -1;
          v_Err_Msg  := '未找到指定的结算支付信息!';
      End;
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
    If v_结算方式 Is Null Then
      v_Err_Msg := Nvl(v_名称, '') || '未设置结算方式,请在医疗卡类别中设置结算方式';
      Raise Err_Item;
    End If;
  
    v_收费结算 := v_结算方式 || '|' || 支付金额_In || '|' || ' |' || ' ';
    --结算方式|结算金额|结算号码|结算摘要 
    Zl_门诊收费结算_Modify(1, n_病人id, 结帐id_In, v_收费结算, 0, 0, n_卡类别id, 卡号_In, 交易流水号_In, 交易说明_In, 0, 0, 0, 0);
  
    --保存扩展结算信息
    For c_扩展 In (Select Extractvalue(j.Column_Value, '/EXPEND/JYMC') As Jymc,
                        Extractvalue(j.Column_Value, '/EXPEND/JYLR') As Jylr
                 From Table(Xmlsequence(Extract(Xmlexpned_In, '/EXPENDLIST/EXPEND'))) J) Loop
      Zl_三方结算交易_Insert(n_卡类别id, 0, 卡号_In, 结帐id_In, c_扩展.Jymc || '|' || c_扩展.Jylr, 0);
    End Loop;
  End Third_Cardbalance_Modfiy;

  Procedure Square_Cardbalance_Modfiy
  (
    结帐id_In     病人预交记录.结帐id%Type,
    卡类别_In     Varchar2,
    卡号_In       病人预交记录.卡号%Type,
    支付金额_In   病人预交记录.冲预交%Type,
    交易流水号_In 病人预交记录.交易流水号%Type,
    交易说明_In   病人预交记录.交易说明%Type,
    Xmlexpned_In  Xmltype
  ) Is
    n_卡类别id 医疗卡类别.Id%Type;
    v_结算方式 病人预交记录.结算方式%Type;
    v_名称     卡消费接口目录.名称%Type;
  Begin
    v_Err_Msg := Null;
    Begin
      n_卡类别id := To_Number(卡类别_In);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
  
    If n_卡类别id = 0 Then
      Begin
        Select 编号, 结算方式, Decode(Nvl(启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
        Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
        From 卡消费接口目录
        Where 名称 = 卡类别_In;
      Exception
        When Others Then
          v_Err_Msg := '消费:' || 卡类别_In || '不存在!';
      End;
    
    Else
    
      Begin
        Select 编号, 结算方式, Decode(Nvl(启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
        Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
        From 卡消费接口目录
        Where 编号 = 卡类别_In;
      Exception
        When Others Then
          v_Err_Msg := '未找到指定的结算支付信息!';
      End;
    
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
    If v_结算方式 Is Null Then
      v_Err_Msg := Nvl(v_名称, '') || '未设置结算方式,请在医疗卡类别中设置结算方式';
      Raise Err_Item;
    End If;
  
    Select ID
    Into n_消费卡id
    From 消费卡目录
    Where 接口编号 = n_卡类别id And 卡号 = 卡号_In And
          序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = n_卡类别id And 卡号 = 卡号_In);
  
    --结算方式_IN格式为:卡类别ID|卡号|消费卡ID|消费金额||.... 
    v_收费结算 := n_卡类别id || '|' || 卡号_In || '|' || n_消费卡id || '|' || 支付金额_In;
    Zl_门诊收费结算_Modify(3, n_病人id, 结帐id_In, v_收费结算, 0, 0, n_卡类别id, 卡号_In, 交易流水号_In, 交易说明_In, 0, 0, 0, 0);
    --保存扩展结算信息
    For c_扩展 In (Select Extractvalue(j.Column_Value, '/EXPEND/JYMC') As Jymc,
                        Extractvalue(j.Column_Value, '/EXPEND/JYLR') As Jylr
                 From Table(Xmlsequence(Extract(Xmlexpned_In, '/EXPENDLIST/EXPEND'))) J) Loop
      Zl_三方结算交易_Insert(n_卡类别id, 1, 卡号_In, 结帐id_In, c_扩展.Jymc || '|' || c_扩展.Jylr, 0);
    End Loop;
  End Square_Cardbalance_Modfiy;

Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/NO'), To_Number(Extractvalue(Value(A), 'IN/BRID')),
         To_Number(Extractvalue(Value(A), 'IN/JE')), To_Number(Extractvalue(Value(A), 'IN/WCJE')),
         To_Number(Extractvalue(Value(A), 'IN/SFGH'))
  Into v_Nos, n_病人id, n_收费总额, n_误差额, n_是否挂号
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  --0.相关检查

  If Nvl(n_病人id, 0) = 0 Then
    v_Err_Msg := '不能有效识别病人身份,不允许缴费!';
    Raise Err_Item;
  
  End If;

  If v_Nos Is Null Then
    v_Err_Msg := '没有指定相关的收费单据,不允许缴费!';
    Raise Err_Item;
  
  End If;

  --人员id,人员编号,人员姓名 
  v_Temp := Zl_Identity(1);
  If Nvl(v_Temp, '0') = '0' Or Nvl(v_Temp, '_') = '_' Then
    v_Err_Msg := '系统不能认别有效的操作员,不允许缴费!';
    Raise Err_Item;
  End If;
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员编码 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员姓名 := v_Temp;
  v_Err_Msg    := Null;
  Begin
    Select b.编码, a.姓名, a.性别, a.年龄
    Into v_医疗付款方式编码, v_姓名, v_性别, v_年龄
    From 病人信息 A, 医疗付款方式 B
    Where a.医疗付款方式 = b.名称(+) And a.病人id = n_病人id;
  Exception
    When Others Then
      v_Err_Msg := '指定的缴费单据中不能有效识别病人,不允许缴费!';
  End;
  If Not v_Err_Msg Is Null Then
    Raise Err_Item;
  End If;
  Select 病人结帐记录_Id.Nextval, Sysdate Into n_结帐id, d_收费时间 From Dual;

  If Nvl(n_是否挂号, 0) = 0 Then
    --费用单据
    v_发药窗口 := Zl_Getclinicchargepaywins(v_Nos);
  
    --1.进行费用收费处理
    --获取发药窗口
  
    n_结帐金额 := 0;
    For c_缴费单 In (Select /*+ rule */
                   a.No, Max(a.开单部门id) As 开单部门id, Max(a.病人科室id) As 病人科室id, Max(a.病人id) As 病人id, Sum(实收金额) As 实收金额,
                   Max(a.开单人) As 开单人
                  From 门诊费用记录 A, Table(f_Str2list(v_Nos)) J
                  Where a.记录性质 = 1 And a.No = j.Column_Value And a.记录状态 = 0
                  Group By a.No) Loop
      If Nvl(c_缴费单.病人id, 0) <> n_病人id Then
        v_Err_Msg := '缴费单据:' || c_缴费单.No || '与当前病人身份不符,不允许缴费!';
        Raise Err_Item;
      End If;
    
      n_结帐金额 := n_结帐金额 + Nvl(c_缴费单.实收金额, 0);
      Zl_病人划价收费_Insert(c_缴费单.No, n_病人id, 1, v_医疗付款方式编码, v_姓名, v_性别, v_年龄, c_缴费单.病人科室id, c_缴费单.开单部门id, c_缴费单.开单人, n_结帐id,
                       d_收费时间, v_操作员编码, v_操作员姓名, v_发药窗口, 0, d_收费时间);
    
    End Loop;
  
    --检查总金额是否正确 
    If Nvl(n_误差额, 0) = 0 Then
      n_误差额 := Nvl(n_收费总额, 0) - Nvl(n_结帐金额, 0);
      If Abs(n_误差额) > 1.00 Then
        v_Err_Msg := '单据缴款金额与实际结算的误差太大!';
        Raise Err_Item;
      End If;
    End If;
    If Nvl(n_结帐金额, 0) + Nvl(n_误差额, 0) <> Nvl(n_收费总额, 0) Then
      v_Err_Msg := '指定的缴费单据的总金额不对,请重新选择缴费单据!';
      Raise Err_Item;
    End If;
  
    --2.确定支付方式
    n_Count := 0;
    For c_结算方式 In (Select Extractvalue(b.Column_Value, '/JS/JSKLB') As 结算卡类别,
                          Extractvalue(b.Column_Value, '/JS/JSKH') As 结算卡号,
                          Extractvalue(b.Column_Value, '/JS/JSFS') As 结算方式,
                          Extractvalue(b.Column_Value, '/JS/JSJE') As 结算金额,
                          Extractvalue(b.Column_Value, '/JS/JYLSH') As 交易流水号,
                          Extractvalue(b.Column_Value, '/JS/JYSM') As 交易说明, Extractvalue(b.Column_Value, '/JS/ZY') As 摘要,
                          Extractvalue(b.Column_Value, '/JS/SFCYJ') As 是否冲预交,
                          Extractvalue(b.Column_Value, '/JS/SFXFK') As 是否消费卡,
                          Extract(b.Column_Value, '/JS/EXPENDLIST') As Expend
                   From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B) Loop
    
      --1.三方卡结算
    
      If c_结算方式.结算卡类别 Is Not Null And Nvl(c_结算方式.是否消费卡, 0) = 0 Then
        --1.三方卡结算
        Third_Cardbalance_Modfiy(n_结帐id, c_结算方式.结算卡类别, c_结算方式.结算卡号, c_结算方式.结算金额, c_结算方式.交易流水号, c_结算方式.交易说明,
                                 c_结算方式.Expend);
      Elsif c_结算方式.结算卡类别 Is Not Null And Nvl(c_结算方式.是否消费卡, 0) = 1 Then
        --2.消费卡结算
        Square_Cardbalance_Modfiy(n_结帐id, c_结算方式.结算卡类别, c_结算方式.结算卡号, c_结算方式.结算金额, c_结算方式.交易流水号, c_结算方式.交易说明,
                                  c_结算方式.Expend);
      Elsif Nvl(c_结算方式.是否冲预交, 0) = 1 Then
        --3.冲预交款
        Zl_门诊收费结算_Modify(0, n_病人id, n_结帐id, Null, c_结算方式.结算金额, 0, Null, Null, Null, Null, 0, 0, 0, 0);
      Else
        --4.普通结算
        If c_结算方式.结算方式 Is Null Then
          v_Err_Msg := '未指定指付方式，不允缴款!';
          Raise Err_Item;
        End If;
        --结算方式|结算金额|结算号码|结算摘要||..
        v_收费结算 := c_结算方式.结算方式 || '|' || c_结算方式.结算金额 || '| | ';
        v_普通结算 := Nvl(v_普通结算, '') || '||' || v_收费结算;
      End If;
      n_Count := n_Count + 1;
    End Loop;
    If n_Count = 0 Then
      v_Err_Msg := '不能有效确认当前的支付方式!';
      Raise Err_Item;
    End If;
    --5.普通结算及完成结
    If v_普通结算 Is Not Null Then
      v_普通结算 := Substr(v_普通结算, 3);
    End If;
    Zl_门诊收费结算_Modify(0, n_病人id, n_结帐id, v_普通结算, Null, 0, Null, Null, Null, Null, 0, 0, n_误差额, 1);
  Else
    n_结帐金额 := 0;
    --挂号单据
    v_Para     := zl_GetSysParameter(256);
    n_挂号模式 := Substr(v_Para, 1, 1);
    Begin
      d_启用时间 := To_Date(Substr(v_Para, 3), 'yyyy-mm-dd hh24:mi:ss');
    Exception
      When Others Then
        d_启用时间 := Null;
    End;
    For c_费用 In (Select 1 As 顺序号, b.No, b.收据费目, b.结帐id, b.执行部门id, b.病人科室id, b.开单人, b.收费类别, b.收入项目id, b.附加标志,
                        To_Char(b.登记时间, 'yyyy-mm-dd hh24:mi:ss') As 登记时间, b.价格父号, b.从属父号, b.序号, b.收费细目id, b.计算单位,
                        Max(m.名称) As 名称, Max(m.规格) As 规格, Sum(b.标准单价) As 单价, Avg(Nvl(b.付数, 1) * b.数次) As 数量,
                        Sum(b.应收金额) As 应收金额, Sum(b.实收金额) As 实收金额, Max(j.名称) As 开单科室, Max(q.名称) As 执行科室
                 From 门诊费用记录 B, 收费项目目录 M, 部门表 J, 部门表 Q
                 Where b.No = v_Nos And b.记录性质 = 4 And Nvl(b.费用状态, 0) = 0 And b.记录状态 = 0 And b.收费细目id = m.Id And
                       b.开单部门id = j.Id(+) And b.执行部门id = q.Id(+)
                 Group By b.No, b.收据费目, b.结帐id, b.执行部门id, b.病人科室id, b.开单人, b.收入项目id, b.收费类别, b.登记时间, b.价格父号, b.从属父号, b.序号,
                          b.收费细目id, b.计算单位, b.附加标志
                 Order By 序号) Loop
      Zl_病人预约挂号记录_Update(c_费用.No, c_费用.序号, c_费用.价格父号, c_费用.从属父号, c_费用.收费类别, c_费用.收费细目id, c_费用.数量, c_费用.单价, c_费用.收入项目id,
                         c_费用.收据费目, c_费用.应收金额, c_费用.实收金额, c_费用.附加标志, Null, Null, Null, Null, c_费用.病人科室id, c_费用.执行部门id);
      n_结帐金额 := n_结帐金额 + c_费用.实收金额;
    End Loop;
  
    --检查总金额是否正确 
    If Nvl(n_误差额, 0) = 0 Then
      n_误差额 := Nvl(n_收费总额, 0) - Nvl(n_结帐金额, 0);
      If Abs(n_误差额) > 1.00 Then
        v_Err_Msg := '单据缴款金额与实际结算的误差太大!';
        Raise Err_Item;
      End If;
    End If;
    If Nvl(n_结帐金额, 0) + Nvl(n_误差额, 0) <> Nvl(n_收费总额, 0) Then
      Select Max(操作员姓名) Into v_操作员 From 门诊费用记录 Where 记录性质 = 4 And NO = v_Nos;
      If v_操作员 = v_操作员姓名 Then
        v_Err_Msg := '指定的缴费单据的总金额不对,请重新选择缴费单据!';
        Raise Err_Special;
      Else
        v_Err_Msg := '指定的缴费单据的总金额不对,请重新选择缴费单据!';
        Raise Err_Item;
      End If;
    End If;
  
    --预约接收
    Select a.执行部门id, a.收费细目id, c.Id, a.执行人, b.号别, b.门诊号, b.发生时间, a.费别, b.号序, b.出诊记录id
    Into n_科室id, n_项目id, n_医生id, v_医生姓名, v_号码, n_门诊号, d_发生时间, v_费别, n_号序, n_出诊记录id
    From 门诊费用记录 A, 病人挂号记录 B, 人员表 C
    Where a.No = v_Nos And a.记录性质 = 4 And a.序号 = 1 And a.No = b.No And a.执行人 = c.姓名(+);
  
    If n_挂号模式 = 1 Then
      If d_启用时间 > d_发生时间 And n_出诊记录id Is Null Then
        n_挂号模式 := 0;
      End If;
    End If;
  
    Select Decode(To_Number(zl_GetSysParameter('排队叫号模式', 1113, 100)), 0, 0, 1) Into n_生成队列 From Dual;
    If n_挂号模式 = 0 Then
      For c_结算方式 In (Select Extractvalue(b.Column_Value, '/JS/JSKLB') As 结算卡类别,
                            Extractvalue(b.Column_Value, '/JS/JSKH') As 结算卡号,
                            Extractvalue(b.Column_Value, '/JS/JSFS') As 结算方式,
                            Extractvalue(b.Column_Value, '/JS/JSJE') As 结算金额,
                            Extractvalue(b.Column_Value, '/JS/JYLSH') As 交易流水号,
                            Extractvalue(b.Column_Value, '/JS/JYSM') As 交易说明,
                            Extractvalue(b.Column_Value, '/JS/ZY') As 摘要,
                            Extractvalue(b.Column_Value, '/JS/SFCYJ') As 是否冲预交,
                            Extractvalue(b.Column_Value, '/JS/SFXFK') As 是否消费卡
                     From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B) Loop
        If Nvl(c_结算方式.是否冲预交, 0) = 1 Then
          n_预交支付 := c_结算方式.结算金额;
        Else
          If c_结算方式.结算方式 Is Not Null Then
            Select Nvl(Max(1), 0) Into n_Exists From 结算方式 Where 名称 = c_结算方式.结算方式 And 性质 In (3, 4);
            If n_Exists = 1 Then
              n_医保支付 := c_结算方式.结算金额;
            Else
              If Nvl(n_普通支付, 0) = 0 Then
                n_普通支付 := c_结算方式.结算金额;
                v_结算方式 := c_结算方式.结算方式;
                If Nvl(c_结算方式.是否消费卡, 0) = 1 Then
                  Begin
                    n_结算卡序号 := To_Number(c_结算方式.结算卡类别);
                  Exception
                    When Others Then
                      n_结算卡序号 := 0;
                  End;
                  If n_结算卡序号 = 0 Then
                    Begin
                      Select 编号
                      Into n_结算卡序号
                      From 卡消费接口目录
                      Where 名称 = c_结算方式.结算卡类别 And Nvl(启用, 0) = 1;
                    Exception
                      When Others Then
                        v_Err_Msg := '未找到对应的消费卡!';
                        Raise Err_Item;
                    End;
                  End If;
                  If v_结算方式 Is Null Then
                    Select 结算方式 Into v_结算方式 From 卡消费接口目录 Where 编号 = n_结算卡序号;
                  End If;
                Else
                  Begin
                    n_卡类别id := To_Number(c_结算方式.结算卡类别);
                  Exception
                    When Others Then
                      n_卡类别id := 0;
                  End;
                  If n_卡类别id = 0 Then
                    Begin
                      Select ID
                      Into n_卡类别id
                      From 医疗卡类别
                      Where 名称 = c_结算方式.结算卡类别 And Nvl(是否启用, 0) = 1;
                    Exception
                      When Others Then
                        v_Err_Msg := '未找到对应的医疗卡!';
                        Raise Err_Item;
                    End;
                  End If;
                  If v_结算方式 Is Null Then
                    Select 结算方式 Into v_结算方式 From 医疗卡类别 Where ID = n_卡类别id;
                  End If;
                End If;
                v_结算卡号   := c_结算方式.结算卡号;
                v_交易流水号 := c_结算方式.交易流水号;
                v_交易说明   := c_结算方式.交易说明;
                v_摘要       := c_结算方式.摘要;
              Else
                v_Err_Msg := '挂号结算暂不支持多种结算方式!';
                Raise Err_Item;
              End If;
            End If;
          Else
            If Nvl(n_普通支付, 0) = 0 Then
              n_普通支付 := c_结算方式.结算金额;
              v_结算方式 := c_结算方式.结算方式;
              If Nvl(c_结算方式.是否消费卡, 0) = 1 Then
                Begin
                  n_结算卡序号 := To_Number(c_结算方式.结算卡类别);
                Exception
                  When Others Then
                    n_结算卡序号 := 0;
                End;
                If n_结算卡序号 = 0 Then
                  Begin
                    Select 编号
                    Into n_结算卡序号
                    From 卡消费接口目录
                    Where 名称 = c_结算方式.结算卡类别 And Nvl(启用, 0) = 1;
                  Exception
                    When Others Then
                      v_Err_Msg := '未找到对应的消费卡!';
                      Raise Err_Item;
                  End;
                End If;
                If v_结算方式 Is Null Then
                  Select 结算方式 Into v_结算方式 From 卡消费接口目录 Where 编号 = n_结算卡序号;
                End If;
              Else
                Begin
                  n_卡类别id := To_Number(c_结算方式.结算卡类别);
                Exception
                  When Others Then
                    n_卡类别id := 0;
                End;
                If n_卡类别id = 0 Then
                  Begin
                    Select ID
                    Into n_卡类别id
                    From 医疗卡类别
                    Where 名称 = c_结算方式.结算卡类别 And Nvl(是否启用, 0) = 1;
                  Exception
                    When Others Then
                      v_Err_Msg := '未找到对应的医疗卡!';
                      Raise Err_Item;
                  End;
                End If;
                If v_结算方式 Is Null Then
                  Select 结算方式 Into v_结算方式 From 医疗卡类别 Where ID = n_卡类别id;
                End If;
              End If;
              v_结算卡号   := c_结算方式.结算卡号;
              v_交易流水号 := c_结算方式.交易流水号;
              v_交易说明   := c_结算方式.交易说明;
              v_摘要       := c_结算方式.摘要;
            Else
              v_Err_Msg := '挂号结算暂不支持多种结算方式!';
              Raise Err_Item;
            End If;
          End If;
        End If;
      End Loop;
      Zl_预约挂号接收_Insert(v_Nos, Null, Null, n_结帐id, Zl_诊室(v_号码), n_病人id, n_门诊号, v_姓名, v_性别, v_年龄, v_医疗付款方式编码, v_费别,
                       v_结算方式, n_普通支付, n_预交支付, n_医保支付, d_发生时间, n_号序, v_操作员编码, v_操作员姓名, n_生成队列, d_收费时间, n_卡类别id, n_结算卡序号,
                       v_结算卡号, v_交易流水号, v_交易说明, Null, 0, 0, Null, 1);
    Else
      For c_结算方式 In (Select Extractvalue(b.Column_Value, '/JS/JSKLB') As 结算卡类别,
                            Extractvalue(b.Column_Value, '/JS/JSKH') As 结算卡号,
                            Extractvalue(b.Column_Value, '/JS/JSFS') As 结算方式,
                            Extractvalue(b.Column_Value, '/JS/JSJE') As 结算金额,
                            Extractvalue(b.Column_Value, '/JS/JYLSH') As 交易流水号,
                            Extractvalue(b.Column_Value, '/JS/JYSM') As 交易说明,
                            Extractvalue(b.Column_Value, '/JS/ZY') As 摘要,
                            Extractvalue(b.Column_Value, '/JS/SFCYJ') As 是否冲预交,
                            Extractvalue(b.Column_Value, '/JS/SFXFK') As 是否消费卡
                     From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B) Loop
        If Nvl(c_结算方式.是否冲预交, 0) = 1 Then
          n_预交支付 := c_结算方式.结算金额;
        Else
          n_普通支付 := Nvl(n_普通支付, 0) + c_结算方式.结算金额;
          If c_结算方式.结算方式 Is Null Then
            --三方卡结算方式
            If Nvl(c_结算方式.是否消费卡, 0) = 1 Then
              Begin
                n_结算卡序号 := To_Number(c_结算方式.结算卡类别);
              Exception
                When Others Then
                  n_结算卡序号 := 0;
              End;
              If n_结算卡序号 = 0 Then
                Begin
                  Select 编号
                  Into n_结算卡序号
                  From 卡消费接口目录
                  Where 名称 = c_结算方式.结算卡类别 And Nvl(启用, 0) = 1;
                Exception
                  When Others Then
                    v_Err_Msg := '未找到对应的消费卡!';
                    Raise Err_Item;
                End;
              End If;
              Select 结算方式 Into v_临时结算方式 From 卡消费接口目录 Where 编号 = n_结算卡序号;
            Else
              Begin
                n_卡类别id := To_Number(c_结算方式.结算卡类别);
              Exception
                When Others Then
                  n_卡类别id := 0;
              End;
              If n_卡类别id = 0 Then
                Begin
                  Select ID
                  Into n_卡类别id
                  From 医疗卡类别
                  Where 名称 = c_结算方式.结算卡类别 And Nvl(是否启用, 0) = 1;
                Exception
                  When Others Then
                    v_Err_Msg := '未找到对应的医疗卡!';
                    Raise Err_Item;
                End;
              End If;
              Select 结算方式 Into v_临时结算方式 From 医疗卡类别 Where ID = n_卡类别id;
            End If;
            v_结算卡号   := c_结算方式.结算卡号;
            v_交易流水号 := c_结算方式.交易流水号;
            v_交易说明   := c_结算方式.交易说明;
            v_摘要       := c_结算方式.摘要;
            v_结算方式   := v_结算方式 || '|' || v_临时结算方式 || ',' || c_结算方式.结算金额 || ',,1';
          Else
            --其他结算方式
            v_结算方式 := v_结算方式 || '|' || c_结算方式.结算方式 || ',' || c_结算方式.结算金额 || ',,1';
          End If;
        End If;
      End Loop;
      If v_结算方式 Is Not Null Then
        v_结算方式 := Substr(v_结算方式, 2);
      End If;
      Zl_预约挂号接收_出诊_Insert(v_Nos, Null, Null, n_结帐id, Zl_出诊诊室(n_出诊记录id), n_病人id, n_门诊号, v_姓名, v_性别, v_年龄, v_医疗付款方式编码,
                          v_费别, v_结算方式, n_普通支付, n_预交支付, Null, d_发生时间, n_号序, v_操作员编码, v_操作员姓名, n_生成队列, d_收费时间, n_卡类别id,
                          n_结算卡序号, v_结算卡号, v_交易流水号, v_交易说明, Null, 0, 0, Null, 1);
    End If;
    --处理扩展信息
    If Nvl(n_卡类别id, 0) <> 0 Then
      For c_扩展信息 In (Select Extractvalue(b.Column_Value, '/EXPEND/JYMC') As 交易名称,
                            Extractvalue(b.Column_Value, '/EXPEND/JYLR') As 交易内容
                     From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS/EXPENDLIST/EXPEND'))) B) Loop
        Zl_三方结算交易_Insert(n_卡类别id, 0, v_结算卡号, n_结帐id, c_扩展信息.交易名称 || '|' || c_扩展信息.交易内容, 0);
      End Loop;
    End If;
    If Nvl(n_结算卡序号, 0) <> 0 Then
      For c_扩展信息 In (Select Extractvalue(b.Column_Value, '/EXPEND/JYMC') As 交易名称,
                            Extractvalue(b.Column_Value, '/EXPEND/JYLR') As 交易内容
                     From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS/EXPENDLIST/EXPEND'))) B) Loop
        Zl_三方结算交易_Insert(n_结算卡序号, 1, v_结算卡号, n_结帐id, c_扩展信息.交易名称 || '|' || c_扩展信息.交易内容, 0);
      End Loop;
    End If;
    --处理汇总
    Zl_病人挂号汇总_Update(v_医生姓名, n_医生id, n_项目id, n_科室id, d_发生时间, 2, v_号码, 1, n_出诊记录id);
  End If;
  v_Temp := '<CZSJ>' || To_Char(d_收费时间, 'YYYY-MM-DD hh24:mi:ss') || '</CZSJ>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  v_Temp := '<JZID>' || n_结帐id || '</JZID>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Err_Special Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20105, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Payment;
/


--102705:刘尔旋,2016-11-22,挂号安排性能问题
Create Or Replace Procedure Zl_挂号安排_Autoupdate Is
  Err_Item Exception;
  v_Date Date;
  -- v_Err_Msg Varchar2(100); 
  v_Unitscount Number;
Begin
  --n_更新执行人 ：是否更新病人挂号记录 和门诊费用记录中的执行人 
  --               如果计划中更改了 挂号项目 则不允许更新 病人挂号记录和门诊费用记录中的数据 
  Select Sysdate Into v_Date From Dual;
  Select Count(0) Into v_Unitscount From 合作单位安排控制 Where Rownum = 1;

  For v_生效 In (Select ID, 安排id, 号码, 生效时间, 失效时间, 周日, 周一, 周二, 周三, 周四, 周五, 周六, 分诊方式, 序号控制, 执行时间 As 上次生效时间, 项目id, 医生姓名, 医生id,
                      序号, 科室id
               From (Select a.Id, a.安排id, a.号码, a.生效时间, a.失效时间, a.周日, a.周一, a.周二, a.周三, a.周四, a.周五, a.周六, a.分诊方式, a.序号控制,
                             b.执行时间, a.项目id, a.医生姓名, a.医生id, Nvl(b.执行计划id, 0) As 执行计划id,
                             Row_Number() Over(Partition By a.安排id Order By a.生效时间 Desc) As 顺序号, b.序号, b.科室id
                      From 挂号安排计划 A, 挂号安排 B
                      Where Sysdate Between a.生效时间 And a.失效时间 And a.安排id = b.Id And
                            a.实际生效 >= To_Date('3000-01-01', 'yyyy-mm-dd') And a.生效时间 <= Sysdate And 审核时间 Is Not Null And
                            b.停用日期 Is Null)
               Where 顺序号 = 1 And ID <> Nvl(执行计划id, 0)) Loop
    Update 挂号安排计划 Set 实际生效 = v_生效.上次生效时间 Where ID = v_生效.安排id And 失效时间 < v_生效.失效时间;
  
    Update 挂号安排
    Set 周日 = v_生效.周日, 周一 = v_生效.周一, 周二 = v_生效.周二, 周三 = v_生效.周三, 周四 = v_生效.周四, 周五 = v_生效.周五, 周六 = v_生效.周六,
        分诊方式 = v_生效.分诊方式, 序号控制 = v_生效.序号控制, 开始时间 = Sysdate, 终止时间 = v_生效.失效时间, 项目id = Nvl(v_生效.项目id, 项目id), 执行时间 = v_Date,
        执行计划id = v_生效.Id, 序号 = 9999999, 医生姓名 = v_生效.医生姓名, 医生id = v_生效.医生id
    Where ID = v_生效.安排id;
  
    --重新调整序号 
    Update 挂号安排 A
    Set 序号 = -1 * 序号
    Where 项目id = v_生效.项目id And a.科室id = v_生效.科室id And Nvl(a.医生姓名, '-') = Nvl(v_生效.医生姓名, '-') And
          Nvl(a.医生id, 0) = Nvl(v_生效.医生id, 0);
    For v_序号 In (Select a.Id, Rownum As 序号
                 From 挂号安排 A
                 Where a.项目id = v_生效.项目id And a.科室id = v_生效.科室id And Nvl(a.医生姓名, '-') = Nvl(v_生效.医生姓名, '-') And
                       Nvl(a.医生id, 0) = Nvl(v_生效.医生id, 0)
                 Order By a.Id) Loop
      Update 挂号安排 A Set 序号 = v_序号.序号 Where ID = v_序号.Id;
    End Loop;
    Delete 挂号安排诊室 Where 号表id = v_生效.安排id;
    Insert Into 挂号安排诊室
      (号表id, 门诊诊室)
      Select v_生效.安排id, 门诊诊室 From 挂号计划诊室 Where 计划id = v_生效.Id;
    Delete 挂号安排限制 Where 安排id = v_生效.安排id;
    Insert Into 挂号安排限制
      (安排id, 限制项目, 限号数, 限约数)
      Select v_生效.安排id, 限制项目, 限号数, 限约数 From 挂号计划限制 Where 计划id = v_生效.Id;
    Delete 挂号安排时段 Where 安排id = v_生效.安排id;
    Insert Into 挂号安排时段
      (安排id, 序号, 开始时间, 结束时间, 限制数量, 是否预约, 星期)
      Select v_生效.安排id, 序号, 开始时间, 结束时间, 限制数量, 是否预约, 星期
      From 挂号计划时段
      Where 计划id = v_生效.Id;
    If Nvl(v_Unitscount, 0) > 0 Then
      Delete 合作单位安排控制 Where 安排id = v_生效.安排id;
      Insert Into 合作单位安排控制
        (安排id, 合作单位, 限制项目, 序号, 数量)
        Select v_生效.安排id, 合作单位, 限制项目, 序号, 数量 From 合作单位计划控制 Where 计划id = v_生效.Id;
    End If;
  End Loop;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_挂号安排_Autoupdate;
/


--102861:张险华,2016-11-21,会诊医嘱取消关联
Create Or Replace Procedure Zl_病历医嘱报告_Modify
(
  病历id_In In 病人医嘱报告.病历id%Type,
  医嘱id_In In 病人医嘱报告.医嘱id%Type
) Is
Begin
  Update 病人医嘱报告 Set 医嘱id = 医嘱id_In Where 病历id = 病历id_In;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病历医嘱报告_Modify;
/
CREATE OR REPLACE Procedure Zl_电子病历记录_Delete(Id_In In 电子病历记录.Id%Type) Is
  n_处理状态 电子病历记录.处理状态%Type; 
  e_Submit Exception; 
Begin 
  Select Nvl(处理状态, 0) Into n_处理状态 From 电子病历记录 Where ID = Id_In; 
  If n_处理状态 > 0 Then 
    Raise e_Submit; 
  End If; 
  Delete 病人诊断记录 T 
  Where t.Id In (Select a.Id 
                 From 病人诊断记录 A, 电子病历记录 C 
                 Where a.病历id = c.Id And a.病人id = c.病人id And a.主页id = c.主页id And c.Id = Id_In); 
  Update 电子病历时机 
  Set 完成记录id = Null, 完成时间 = Null 
  Where (病人id, 主页id, 文件id) = (Select 病人id, 主页id, 文件id From 电子病历记录 Where ID = Id_In) And 完成记录id = Id_In; 
  update 疾病阳性记录 set 文件ID = NULL where 文件ID = Id_In;  --传染病管理系统清除关联的反馈单的文件ID
  Delete 电子病历打印 Where 文件id = Id_In; 
  Delete 电子病历记录 Where ID = Id_In; 
  Delete 疾病申报记录 Where 文件id = Id_In; --为支持新版病历，删除了外键 
  Delete 病人医嘱报告 Where 病历ID=Id_In;
Exception 
  When e_Submit Then 
    Raise_Application_Error(-20101, '[ZLSOFT]不能删除被后续接收的病历！[ZLSOFT]'); 
  When Others Then 
    zl_ErrorCenter(SQLCode, SQLErrM); 
End Zl_电子病历记录_Delete;
/
--102853:张险华,2016-11-21,检查报告保存时使用低效索引
Create Or Replace Procedure Zl_电子病历记录_Update
(
  Id_In       In 电子病历记录.Id%Type,
  病人来源_In In 电子病历记录.病人来源%Type,
  病人id_In   In 电子病历记录.病人id%Type,
  主页id_In   In 电子病历记录.主页id%Type,
  婴儿_In     In 电子病历记录.婴儿%Type,
  科室id_In   In 电子病历记录.科室id%Type,
  文件id_In   In 电子病历记录.文件id%Type,
  医嘱id_In   In 病人医嘱报告.医嘱id%Type := Null,
  创建时间_In In 电子病历记录.创建时间%Type := Null
) Is
  v_保存人     电子病历记录.保存人%Type;
  d_创建时间   电子病历记录.创建时间%Type;
  d_保存时间   电子病历记录.保存时间%Type;
  d_完成时间   电子病历记录.完成时间%Type := Null;
  n_最后版本   电子病历记录.最后版本%Type := 1;
  n_预制提纲id 电子病历内容.预制提纲id%Type;
  n_定义提纲id 电子病历内容.定义提纲id%Type;
  v_对象属性   电子病历内容.对象属性%Type;
  n_处理状态   电子病历记录.处理状态%Type;
  e_Submit Exception;
  e_Nofile Exception;
  e_Repeat Exception;

  n_种类 病历文件列表.种类%Type;
  v_名称 病历文件列表.名称%Type;
  v_事件 病历时限要求.事件%Type;
  n_唯一 病历时限要求.唯一%Type;
  n_表格 Number(1);
  n_Num  Number;
  n_Lab  Number;

  --传送病人诊断记录 
  Procedure Put_Pati_Diag
  (
    v_Kind_Emr  In Varchar2,
    n_Kind_Base In 病人诊断记录.诊断类型%Type,
    n_Del_Old   In Number
  ) Is
    n_类型      病人诊断记录.诊断类型%Type;
    n_中医      Number(1); --是否中医：0-西医;1-中医 
    n_疾病id    病人诊断记录.疾病id%Type; --对应疾病编码目录(ICD或中医疾病)的ID 
    n_诊断id    病人诊断记录.诊断id%Type; --对应疾病诊断目录的ID 
    n_证候id    病人诊断记录.证候id%Type; --对应疾病诊断目录的ID 
    n_疑诊      病人诊断记录.是否疑诊%Type; --是否疑诊：0-确诊;1-疑诊 
    d_日期      病人诊断记录.记录日期%Type; --诊断次序 
    n_次序      病人诊断记录.诊断次序%Type; --诊断次序 
    v_入院病情  病人诊断记录.入院病情%Type;
    v_出院情况  病人诊断记录.出院情况%Type;
    n_Syncpage  Number(1); --是否同步更新病案首页 0-不同步 1-同步 
    n_西医order Number(2); --首页诊断次序 
    n_中医order Number(2); --首页诊断次序 
  Begin
    --取得是否同步更新病案首页参数 
    n_Syncpage := Nvl(zl_GetSysParameter('SyncPage', 1070), 0);
  
    If n_Del_Old = 1 Then
      n_次序      := 0;
      n_西医order := 0;
      n_中医order := 0;
    Else
      Select Nvl(Max(诊断次序), 0)
      Into n_次序
      From 病人诊断记录
      Where 病人id = 病人id_In And 主页id = 主页id_In And 记录来源 = 1 And 病历id + 0 = Id_In And Nvl(医嘱id, 0) = Nvl(医嘱id_In, 0);
      If n_Syncpage = 1 Then
        Select Nvl(Max(诊断次序), 0)
        Into n_西医order
        From 病人诊断记录
        Where 病人id = 病人id_In And 主页id = 主页id_In And 记录来源 = 3;
      End If;
    End If;
  
    For r_Temp In (Select Rownum As 次序, 对象属性 As 属性, 内容文本 As 描述
                   From 临时病历内容
                   Where 对象类型 = 7 And Substr(对象属性, 1, 2) = v_Kind_Emr And Nvl(终止版, 0) = 0) Loop
      If n_Del_Old = 1 And r_Temp.次序 = 1 Then
        Delete 病人诊断记录
        Where 病人id = 病人id_In And 主页id = 主页id_In And 记录来源 = 1 And 病历id + 0 = Id_In And
              诊断类型 In (n_Kind_Base, n_Kind_Base + 10) And Nvl(医嘱id, 0) = Nvl(医嘱id_In, 0);
        If n_Syncpage = 1 And (n_Kind_Base = 2 Or n_Kind_Base = 3) Then
          --只处理入院诊断和出院诊断 
          Delete 病人诊断记录
          Where 病人id = 病人id_In And 主页id = 主页id_In And 记录来源 = 3 And 诊断类型 In (n_Kind_Base, n_Kind_Base + 10);
        End If;
      End If;
      n_中医   := To_Number(Substr(r_Temp.属性, Instr(r_Temp.属性, ';', 1, 1) + 1,
                                 Instr(r_Temp.属性, ';', 1, 2) - Instr(r_Temp.属性, ';', 1, 1) - 1));
      n_疾病id := To_Number(Substr(r_Temp.属性, Instr(r_Temp.属性, ';', 1, 2) + 1,
                                 Instr(r_Temp.属性, ';', 1, 3) - Instr(r_Temp.属性, ';', 1, 2) - 1));
      n_诊断id := To_Number(Substr(r_Temp.属性, Instr(r_Temp.属性, ';', 1, 3) + 1,
                                 Instr(r_Temp.属性, ';', 1, 4) - Instr(r_Temp.属性, ';', 1, 3) - 1));
      n_证候id := To_Number(Substr(r_Temp.属性, Instr(r_Temp.属性, ';', 1, 4) + 1,
                                 Instr(r_Temp.属性, ';', 1, 5) - Instr(r_Temp.属性, ';', 1, 4) - 1));
      n_疑诊   := To_Number(Substr(r_Temp.属性, Instr(r_Temp.属性, ';', 1, 5) + 1,
                                 Instr(r_Temp.属性, ';', 1, 6) - Instr(r_Temp.属性, ';', 1, 5) - 1));
      d_日期   := To_Date(Substr(r_Temp.属性, Instr(r_Temp.属性, ';', 1, 6) + 1,
                               Instr(r_Temp.属性, ';', 1, 7) - Instr(r_Temp.属性, ';', 1, 6) - 1), 'yyyy-mm-dd hh24:mi:ss');
      If n_Kind_Base <> 1 And n_Kind_Base <> 2 And n_Kind_Base <> 3 Then
        n_中医 := 0;
      End If;
      If n_中医 = 1 Then
        n_类型 := n_Kind_Base + 10;
      Else
        n_类型 := n_Kind_Base;
      End If;
      Insert Into 病人诊断记录
        (ID, 病人id, 主页id, 医嘱id, 记录来源, 诊断次序, 病历id, 诊断类型, 疾病id, 诊断id, 证候id, 诊断描述, 是否疑诊, 记录日期, 记录人)
      Values
        (病人诊断记录_Id.Nextval, 病人id_In, 主页id_In, 医嘱id_In, 1, r_Temp.次序 + n_次序, Id_In, n_类型,
         Decode(n_疾病id, 0, Null, n_疾病id), Decode(n_诊断id, 0, Null, n_诊断id), Decode(n_证候id, 0, Null, n_证候id), r_Temp.描述,
         n_疑诊, d_日期, v_保存人);
      If n_Syncpage = 1 And (n_Kind_Base = 2 Or n_Kind_Base = 3) Then
        If n_Kind_Base = 3 Then
          v_入院病情 := Substr(r_Temp.属性, Instr(r_Temp.属性, ';', 1, 7) + 1,
                           Instr(r_Temp.属性, ';', 1, 8) - Instr(r_Temp.属性, ';', 1, 7) - 1);
          v_出院情况 := Substr(r_Temp.属性, Instr(r_Temp.属性, ';', 1, 8) + 1);
        End If;
        --如果需要同步首页诊断，只处理入院诊断和出院诊断 
        If n_中医 = 1 Then
          n_中医order := n_中医order + 1;
        Else
          n_西医order := n_西医order + 1;
        End If;
        Insert Into 病人诊断记录
          (ID, 病人id, 主页id, 记录来源, 诊断次序, 编码序号, 诊断类型, 疾病id, 诊断id, 证候id, 诊断描述, 入院病情, 出院情况, 是否疑诊, 记录日期, 记录人)
        Values
          (病人诊断记录_Id.Nextval, 病人id_In, 主页id_In, 3, Decode(n_中医, 1, n_中医order, n_西医order), 1, n_类型,
           Decode(n_疾病id, 0, Null, n_疾病id), Decode(n_诊断id, 0, Null, n_诊断id), Decode(n_证候id, 0, Null, n_证候id),
           Replace(r_Temp.描述, '(?)', ''), v_入院病情, v_出院情况, n_疑诊, d_日期, v_保存人);
      End If;
    End Loop;
  End Put_Pati_Diag;

Begin
  Begin
    Select p.姓名 Into v_保存人 From 上机人员表 O, 人员表 P Where o.人员id = p.Id And 用户名 = User;
  Exception
    When Others Then
      v_保存人 := User;
  End;
  d_保存时间 := Sysdate;
  d_创建时间 := Nvl(创建时间_In, Sysdate);

  Select Greatest(Nvl(Max(开始版), 1), Nvl(Max(终止版), 1) + 1) Into n_最后版本 From 临时病历内容;
  If n_最后版本 <= 0 Then
    n_最后版本 := 1;
  End If;

  Select Count(*) Into n_Num From 病历文件列表 Where ID = 文件id_In;
  If n_Num = 0 Then
    Raise e_Nofile;
  End If;

  Select l.种类, l.名称, q.事件, q.唯一
  Into n_种类, v_名称, v_事件, n_唯一
  From 病历文件列表 L, 病历时限要求 Q
  Where l.Id = q.文件id(+) And l.Id = 文件id_In;

  Update 电子病历记录
  Set 病人来源 = 病人来源_In, 病人id = 病人id_In, 主页id = 主页id_In, 婴儿 = 婴儿_In, 科室id = 科室id_In, 文件id = 文件id_In, 保存时间 = d_保存时间
  Where ID = Id_In;
  If Sql%RowCount = 0 Then
    Insert Into 电子病历记录
      (ID, 病人来源, 病人id, 主页id, 婴儿, 科室id, 病历种类, 文件id, 病历名称, 最后版本, 创建人, 创建时间, 保存人, 保存时间)
    Values
      (Id_In, 病人来源_In, 病人id_In, 主页id_In, 婴儿_In, 科室id_In, n_种类, 文件id_In, v_名称, n_最后版本, v_保存人, d_创建时间, v_保存人, d_保存时间);
  
    If n_种类 = 2 And Nvl(医嘱id_In, 0) <> 0 And Instr(v_名称, '会诊') > 0 Then
      Insert Into 病人医嘱报告 (医嘱id, 病历id) Values (医嘱id_In, Id_In);
    Elsif n_种类 = 7 And Nvl(医嘱id_In, 0) <> 0 Then
      --检查报告的重复性
      Select Count(l.Id)
      Into n_Num
      From 电子病历记录 L, 病人医嘱报告 R
      Where l.Id = r.病历id And r.医嘱id = 医嘱id_In And l.文件id + 0 = 文件id_In;
      If n_Num > 0 Then
        Raise e_Repeat;
      End If;
      --单独处理检验有多个单独下的医嘱合并为一个核收的情况 
      Begin
        Select a.Id
        Into n_Lab
        From 检验标本记录 A, 病人医嘱记录 B
        Where a.医嘱id = b.相关id And Rownum <= 1 And a.医嘱id = 医嘱id_In;
      Exception
        When Others Then
          n_Lab := 0;
      End;
      If n_Lab = 0 Then
        --其他项目还是正常处理 
        Insert Into 病人医嘱报告 (医嘱id, 病历id) Values (医嘱id_In, Id_In);
      Else
        --单独处理检验项目 
        Insert Into 病人医嘱报告
          (医嘱id, 病历id)
          Select Distinct b.医嘱id, Id_In
          From 检验标本记录 A, 检验项目分布 B
          Where a.Id = b.标本id And a.医嘱id = 医嘱id_In And b.医嘱id Is Not Null;
      End If;
    End If;
  Else
    Select Nvl(处理状态, 0) Into n_处理状态 From 电子病历记录 Where ID = Id_In;
    Select Max(处理状态) Into n_Num From 疾病申报记录 Where 文件id = Id_In;
    If Nvl(n_Num, 0) <> 4 and Nvl(n_Num, 0) <> 5 Then
      If n_处理状态 > 0 Then
        Raise e_Submit;
      End If;
    End If;
  End If;

  Update 电子病历内容
  Set 对象序号 = -1 * 对象序号, 内容行次 = -1 * 内容行次, 终止版 = Decode(Nvl(终止版, 0), 0, n_最后版本, 终止版)
  Where 文件id = Id_In;
  For r_Temp In (Select ID, 父id, 开始版, 终止版, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行, 定义提纲id, 预制提纲id, 复用提纲, 使用时机,
                        诊治要素id, 替换域, 要素名称, 要素类型, 要素长度, 要素小数, 要素单位, 要素表示, 输入形态, 要素值域
                 From 临时病历内容
                 Order By ID) Loop
  
    --清理预制提纲id：对以前文件(XML或历史文件)，可能预制提纲与当前系统不符合。 
    n_预制提纲id := r_Temp.预制提纲id;
    If r_Temp.对象类型 = 1 And Nvl(n_预制提纲id, 0) <> 0 Then
      Select Max(ID) Into n_预制提纲id From 病历文件结构 Where ID = n_预制提纲id And 文件id Is Null;
      If n_预制提纲id = 0 Then
        n_预制提纲id := Null;
      End If;
    End If;
    --修复定义提纲id：如果定义提纲id不存在，则根据提纲名称查找对应的定义提纲id 
    n_定义提纲id := r_Temp.定义提纲id;
    If r_Temp.对象类型 = 1 Then
      If Nvl(n_定义提纲id, 0) <> 0 Then
        Select Max(ID) Into n_定义提纲id From 病历文件结构 Where ID = n_定义提纲id And 文件id = 文件id_In;
      End If;
      If Nvl(n_定义提纲id, 0) = 0 Then
        Select Max(ID)
        Into n_定义提纲id
        From 病历文件结构
        Where 文件id = 文件id_In And 内容文本 || 预制提纲id = r_Temp.内容文本 || n_预制提纲id;
      End If;
      If n_定义提纲id = 0 Then
        n_定义提纲id := Null;
      End If;
    End If;
  
    v_对象属性 := r_Temp.对象属性;
    --从签名对象获得保存人和完成时间 
    If r_Temp.对象类型 = 8 Then
      If Instr(v_对象属性, ';', 1, 5) = 0 Then
        v_对象属性 := v_对象属性 || ';';
      End If;
      If Instr(v_对象属性, ';', 1, 5) - Instr(v_对象属性, ';', 1, 4) = 1 Then
        v_对象属性 := Substr(v_对象属性, 1, Instr(v_对象属性, ';', 1, 4) - 1) || ';' || To_Char(d_保存时间, 'yyyy-mm-dd hh24:mi:ss') ||
                  Substr(v_对象属性, Instr(v_对象属性, ';', 1, 5));
      End If;
      If r_Temp.开始版 >= n_最后版本 Then
        If Nvl(Instr(r_Temp.内容文本, ';'), 0) = 0 Then
          v_保存人 := r_Temp.内容文本;
        Else
          --内容文本中存放有签名人;ID,有可能签名同名所以必须使用ID,同时确保历史数据的回退正常。 
          Begin
            Select 姓名 Into v_保存人 From 人员表 Where ID = Substr(r_Temp.内容文本, Instr(r_Temp.内容文本, ';') + 1);
          Exception
            When Others Then
              v_保存人 := Substr(r_Temp.内容文本, 1, Instr(r_Temp.内容文本, ';') - 1);
          End;
        End If;
      End If;
      If d_完成时间 Is Null And r_Temp.开始版 = 1 Then
        d_完成时间 := To_Date(Substr(v_对象属性, Instr(v_对象属性, ';', 1, 4) + 1,
                                 Instr(v_对象属性, ';', 1, 5) - Instr(v_对象属性, ';', 1, 4) - 1), 'yyyy-mm-dd hh24:mi:ss');
      End If;
    End If;
  
    Update 电子病历内容
    Set 父id = r_Temp.父id, 开始版 = r_Temp.开始版, 终止版 = r_Temp.终止版, 对象序号 = r_Temp.对象序号, 对象类型 = r_Temp.对象类型, 对象标记 = r_Temp.对象标记,
        保留对象 = r_Temp.保留对象, 对象属性 = v_对象属性, 内容行次 = r_Temp.内容行次, 内容文本 = r_Temp.内容文本, 是否换行 = r_Temp.是否换行, 定义提纲id = n_定义提纲id,
        预制提纲id = n_预制提纲id, 复用提纲 = r_Temp.复用提纲, 使用时机 = r_Temp.使用时机, 诊治要素id = r_Temp.诊治要素id, 替换域 = r_Temp.替换域,
        要素名称 = r_Temp.要素名称, 要素类型 = r_Temp.要素类型, 要素长度 = r_Temp.要素长度, 要素小数 = r_Temp.要素小数, 要素单位 = r_Temp.要素单位,
        要素表示 = r_Temp.要素表示, 输入形态 = r_Temp.输入形态, 要素值域 = r_Temp.要素值域
    Where ID = r_Temp.Id And 文件id + 0 = Id_In;
    If Sql%RowCount = 0 Then
      Insert Into 电子病历内容
        (ID, 文件id, 父id, 开始版, 终止版, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行, 定义提纲id, 预制提纲id, 复用提纲, 使用时机, 诊治要素id,
         替换域, 要素名称, 要素类型, 要素长度, 要素小数, 要素单位, 要素表示, 输入形态, 要素值域)
      Values
        (r_Temp.Id, Id_In, r_Temp.父id, r_Temp.开始版, r_Temp.终止版, r_Temp.对象序号, r_Temp.对象类型, r_Temp.对象标记, r_Temp.保留对象,
         v_对象属性, r_Temp.内容行次, r_Temp.内容文本, r_Temp.是否换行, n_定义提纲id, n_预制提纲id, r_Temp.复用提纲, r_Temp.使用时机, r_Temp.诊治要素id,
         r_Temp.替换域, r_Temp.要素名称, r_Temp.要素类型, r_Temp.要素长度, r_Temp.要素小数, r_Temp.要素单位, r_Temp.要素表示, r_Temp.输入形态,
         r_Temp.要素值域);
    Else
      --普通表格：由于编辑时没有痕迹，按单元保存；因此需要恢复子单元，保证版本记录 
      If r_Temp.对象类型 = 3 Then
        n_表格 := 0;
        If Instr(v_对象属性, ';', 1, 18) = 0 Then
          n_表格 := 1;
        Elsif Substr(v_对象属性, Instr(v_对象属性, ';', 1, 18) + 1, 1) = '0' Then
          n_表格 := 1;
        End If;
        If n_表格 = 1 Then
          Update 电子病历内容
          Set 对象序号 = Abs(对象序号), 内容行次 = Abs(内容行次)
          Where 文件id = Id_In And 父id = r_Temp.Id And 开始版 <= n_最后版本 And 对象类型 <> 5;
        End If;
      End If;
    End If;
  End Loop;
  Delete 电子病历内容
  Where (Nvl(对象序号, 0) < 0 Or Nvl(内容行次, 0) < 0 Or Nvl(开始版, 1) > n_最后版本) And 文件id = Id_In;

  Update 电子病历记录
  Set 完成时间 = d_完成时间, 保存人 = v_保存人, 最后版本 = n_最后版本,
      签名级别 =
       (Select Nvl(Sum(Power(2, 要素表示 - 1)), 0)
        From (Select Distinct 要素表示 From 临时病历内容 Where 对象类型 = 8 And 开始版 >= n_最后版本))
  Where ID = Id_In;

  --先删除原有诊断，因为有可能原有诊断被删除或更改 
  Delete 病人诊断记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 病历id + 0 = Id_In;
  --填写病人诊断记录 
  If n_种类 = 1 Then
    Put_Pati_Diag('11', 1, 1);
  Elsif n_种类 = 2 And (v_事件 = '入院' Or v_事件 = '首次入院' Or v_事件 = '再次入院') And n_唯一 = 1 Then
    Put_Pati_Diag('21', 2, 1);
    Put_Pati_Diag('22', 2, 1);
    Put_Pati_Diag('23', 2, 1);
    Put_Pati_Diag('24', 2, 0);
  Elsif n_种类 = 2 And (v_事件 = '24小时出院' Or v_事件 = '24小时死亡') Then
    Put_Pati_Diag('21', 2, 1);
    Put_Pati_Diag('22', 2, 1);
    Put_Pati_Diag('23', 2, 1);
    Put_Pati_Diag('24', 2, 0);
    Put_Pati_Diag('31', 3, 1);
  Elsif n_种类 = 2 And (v_事件 = '出院' Or v_事件 = '死亡') Then
    Put_Pati_Diag('31', 3, 1);
  Elsif n_种类 = 2 And v_事件 = '手术' Then
    Put_Pati_Diag('41', 8, 1);
    Put_Pati_Diag('42', 9, 1);
  Elsif n_种类 = 7 And (医嘱id_In Is Not Null) Then
    Put_Pati_Diag('51', 6, 1);
    Put_Pati_Diag('52', 22, 1);
    --只处理阳性标志 
    --Update 病人医嘱发送 Set 结果阳性 = 0 Where 医嘱id = 医嘱id_In; 
    Update 病人医嘱发送
    Set 结果阳性 = 1
    Where 医嘱id = 医嘱id_In And Exists
     (Select 内容文本
           From 临时病历内容
           Where 对象类型 = 7 And (Substr(对象属性, 1, 2) = '51' Or Substr(对象属性, 1, 2) = '52') And Nvl(终止版, 0) = 0);
  End If;

  --处理电子病历时机 
  If d_完成时间 Is Null Then
    Update 电子病历时机 Set 完成时间 = Null Where 病人id = 病人id_In And 主页id = 主页id_In And 完成记录id = Id_In;
    If Sql%RowCount = 0 Then
      Zl_电子病历时机_Update(病人id_In, 主页id_In, 病人来源_In, 科室id_In, 文件id_In, Id_In, Null, v_保存人);
    End If;
  Else
    Zl_电子病历时机_Update(病人id_In, 主页id_In, 病人来源_In, 科室id_In, 文件id_In, Id_In, d_完成时间, v_保存人);
  End If;
Exception
  When e_Submit Then
    Raise_Application_Error(-20101, '[ZLSOFT]不能更改被后续接收的病历！[ZLSOFT]');
  When e_Nofile Then
    Raise_Application_Error(-20101, '[ZLSOFT]病历文件定义丢失，请联系系统管理员！[ZLSOFT]');
  When e_Repeat Then
    Raise_Application_Error(-20101, '[ZLSOFT]其他人已经书写并保存了报告，不能再保存！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_电子病历记录_Update;
/

--104911:胡俊勇,2017-01-11,护士站配液医嘱销帐
--104114:胡俊勇,2016-12-19,超期发送收回
--102633:胡俊勇,2016-11-16,收回配液医嘱
Create Or Replace Procedure Zl_病人医嘱记录_收回
(
  --功能：将指定医嘱超期发送部分收回。如果上次发送没有产生费用，则仅收回医嘱的上次执行时间。
  --参数：
  --      收回量_IN=对西药、中成药为按住院单位的收回量,对中药为收回付数,对其它医嘱为收回总量或次数。
  --      医嘱ID_IN=每条要收回的医嘱记录的ID(明细存储的ID),对成药或配方,不一定包含给药途径或用法煎法(可能为叮嘱而未读取)
  --      上次时间_IN=医嘱超期发送部分收回后应该还原的上次执行时间(严格按频率计算得来),为空时表示被全部收回了。
  --      NO_IN=当收回要产生负数费用记录时，为新生成记录的单据号(供费用及药品使用),当前处理的只是新NO的一部份。
  --            因为药品可能分批,所以序号在处理时取。
  --            如果全是划价单（传入值为：调整划价单），则不产生负数单据，直接修改或删除划价单
  收回量_In     病人医嘱发送.发送数次%Type,
  医嘱id_In     病人医嘱记录.Id%Type,
  上次时间_In   病人医嘱记录.上次执行时间%Type,
  收回时间_In   Date,
  No_In         住院费用记录.No%Type := Null,
  操作员编号_In 人员表.编号%Type := Null,
  操作员姓名_In 人员表.姓名%Type := Null
) Is
  --收回医嘱对应的发送费用明细的剩余数量,按后产生的费用先收回
  --剩余数量没有排开已申请的数量部份，在产生新申请时覆盖原来的申请
  --对药品和卫材，对一个数量，可能存在未执行和已执行部分，需分别填写申请记录，且以未执行优先
  --执行标志=0-未执行,1-已执行；药品的有部分执行，以收发记录中的明细量区分为准；非药品的只优先处理未执行的
  Cursor c_Detail Is
    Select *
    From (With 医嘱费用记录 As (Select Max(Decode(b.记录状态, 2, 0, b.Id)) As 费用id, b.No, Nvl(b.价格父号, b.序号) As 序号, b.收费细目id,
                                 b.病人病区id, Sum(Nvl(b.付数, 1) * b.数次) As 剩余数量, b.收费类别, Max(Nvl(b.执行状态, 0)) As 执行状态, d.跟踪在用,
                                 c.诊疗类别, c.医嘱内容, c.单次用量, Max(b.记录状态) As 记录状态, Max(b.登记时间) As 登记时间, Nvl(e.收费方式, 0) As 收费方式
                          From 病人医嘱发送 A, 住院费用记录 B, 病人医嘱记录 C, 材料特性 D, 病人医嘱计价 E
                          Where a.医嘱id = 医嘱id_In And a.No = b.No And a.记录性质 = b.记录性质 And a.医嘱id = b.医嘱序号 And
                                b.价格父号 Is Null And b.收费细目id = d.材料id(+) And c.Id = 医嘱id_In And e.医嘱id(+) = b.医嘱序号 And
                                e.收费细目id(+) = b.收费细目id And Not Exists
                           (Select 1 From 输液配药记录 F Where f.医嘱id = c.相关id And a.发送号 = f.发送号)
                          Group By b.No, b.记录性质, Nvl(b.价格父号, b.序号), b.收费细目id, b.病人病区id, b.收费类别, d.跟踪在用, c.诊疗类别, c.医嘱内容,
                                   c.单次用量, e.收费方式
                          Having Sum(Nvl(b.付数, 1) * b.数次) > 0)
           Select 费用id, NO, 序号, 收费细目id, 病人病区id, 收费类别, 跟踪在用, 诊疗类别, 医嘱内容, 单次用量, 剩余数量, Null As 已执行量, Null As 未执行量,
                  执行状态 As 执行标志, 记录状态, 登记时间, 收费方式
           From 医嘱费用记录
           Where 收费类别 Not In ('5', '6', '7') And Not (收费类别 = '4' And Nvl(跟踪在用, 0) = 1)
           Union All
           Select a.费用id, a.No, a.序号, a.收费细目id, a.病人病区id, a.收费类别, a.跟踪在用, a.诊疗类别, a.医嘱内容, a.单次用量, a.剩余数量, 0 As 已执行量,
                  Sum(Nvl(b.付数, 1) * b.实际数量) As 未执行量, 0 As 执行标志, a.记录状态, Max(a.登记时间) As 登记时间, 收费方式
           From 医嘱费用记录 A, 药品收发记录 B
           Where (a.收费类别 In ('5', '6', '7') Or (a.收费类别 = '4' And Nvl(a.跟踪在用, 0) = 1)) And a.费用id = b.费用id And
                 a.No = b.No And b.单据 In (9, 10, 25, 26) And Mod(b.记录状态, 3) = 1 And b.审核人 Is Null
           Group By a.费用id, a.No, a.序号, a.记录状态, a.收费细目id, a.病人病区id, a.收费类别, a.跟踪在用, a.诊疗类别, a.医嘱内容, a.单次用量, a.剩余数量, 收费方式
           Having Sum(Nvl(b.付数, 1) * b.实际数量) > 0
           Union All
           Select a.费用id, a.No, a.序号, a.收费细目id, a.病人病区id, a.收费类别, a.跟踪在用, a.诊疗类别, a.医嘱内容, a.单次用量, a.剩余数量,
                  Sum(Nvl(b.付数, 1) * b.实际数量) As 已执行量, 0 As 未执行量, 1 As 执行标志, a.记录状态, Max(a.登记时间) As 登记时间, 收费方式
           From 医嘱费用记录 A, 药品收发记录 B
           Where (a.收费类别 In ('5', '6', '7') Or (a.收费类别 = '4' And Nvl(a.跟踪在用, 0) = 1)) And a.费用id = b.费用id And
                 a.No = b.No And b.单据 In (9, 10, 25, 26) And Not (Mod(b.记录状态, 3) = 1 And b.审核人 Is Null)
           Group By a.费用id, a.No, a.序号, a.记录状态, a.收费细目id, a.病人病区id, a.收费类别, a.跟踪在用, a.诊疗类别, a.医嘱内容, a.单次用量, a.剩余数量, 收费方式
           Having Sum(Nvl(b.付数, 1) * b.实际数量) > 0)
           Order By Decode(诊疗类别, '5', 0, '6', 0, '7', 0, 收费细目id), 执行标志, 登记时间 Desc;


  Cursor c_Applay(v_费用ids Varchar2) Is
    Select a.费用id, b.No, b.序号, a.数量, a.申请时间, a.申请类别
    From 病人费用销帐 A, 住院费用记录 B
    Where a.费用id = b.Id And a.申请部门id = a.审核部门id And a.申请时间 = 收回时间_In And
          a.费用id In (Select * From Table(Cast(f_Num2list(v_费用ids) As Zltools.t_Numlist)))
    Order By NO, 序号;

  --包含指定药品长嘱发送时产生的相关费用及药品/卫材记录信息(因多次发送有多条记录,分批的已在界面禁止)
  --药品医嘱填写了"病人医嘱发送"记录,对应的给药途径不一定填写了的(可能为叮嘱),且NO不同。
  --因为要收回的次数可能包含了多次发送的内容,所以要将多次发送的收发记录都取出来，多次发送时，划价的先收回（修改或删除）
  Cursor c_Drug Is
    Select a.病人id, a.主页id, d.姓名, Nvl(x.剂量系数, 1) As 剂量系数, Nvl(x.住院包装, 1) As 住院包装, x.最大效期, Nvl(b.付数, 1) * b.实际数量 As 数量,
           b.Id As 收发id, b.单据, b.药品id, b.对方部门id, b.库房id, b.费用id, Nvl(x.药房分批, 0) As 分批, b.批次, b.批号, b.效期, a.记录状态, a.No,
           a.序号, a.收费细目id, a.执行状态 As 执行标志
    From 住院费用记录 A, 药品收发记录 B, 病人医嘱发送 C, 病人信息 D, 药品规格 X
    Where c.医嘱id = 医嘱id_In And a.No = c.No And a.记录性质 = c.记录性质 And a.记录状态 In (0, 1, 3) And a.医嘱序号 + 0 = 医嘱id_In And
          a.No = b.No And a.Id = b.费用id + 0 And b.单据 In (9, 10, 25, 26) And (b.记录状态 = 1 Or Mod(b.记录状态, 3) = 0) And
          a.病人id = d.病人id And b.药品id = x.药品id(+)
    Order By a.记录状态, b.No Desc, b.Id Desc;

  --包含非药长嘱(含给药途径)发送时所产生的费用(因多个收入而有多条记录)
  --对非药医嘱,直接收回指定量,不管多次发送(如果多次发送价格不同,则收回的价格是以最后次的；不然就要根据多个收入依次减收回量)。
  --卫材本身是售价单位，无需住院单位转换
  --非药长嘱都填写了发送记录(除开了叮嘱及护理等级)
  --一天只收一次或一次发送只收一次的项目暂时不支持负数申请
  Cursor c_Other(n_发送号 病人医嘱发送.发送号%Type) Is
    With 医嘱费用记录 As
     (Select a.No, a.序号, a.记录状态, a.收费细目id, a.Id As 费用id, a.数次 As 剩余数量, Nvl(a.执行状态, 0) As 执行状态, a.医嘱序号, b.发送号,
             c.数量 As 对照数量, Nvl(c.收费方式, 0) As 收费方式, a.收费类别
      From 住院费用记录 A, 病人医嘱发送 B, 病人医嘱计价 C
      Where a.No = b.No And a.记录性质 = b.记录性质 And a.医嘱序号 + 0 = b.医嘱id And b.医嘱id = 医嘱id_In And a.医嘱序号 = c.医嘱id(+) And
            a.收费细目id = c.收费细目id(+))
    Select a.No, a.序号, a.费用id, a.剩余数量, a.收费细目id, a.记录状态, a.执行状态, a.对照数量, a.收费方式, a.收费类别
    From (Select a.No, a.序号, a.记录状态, a.收费细目id, a.费用id, a.剩余数量, a.对照数量, a.执行状态, a.医嘱序号, a.收费方式, a.收费类别
           From 医嘱费用记录 A
           Where a.记录状态 In (1, 3) And a.发送号 = n_发送号
           Union All
           Select a.No, a.序号, a.记录状态, a.收费细目id, a.费用id, a.剩余数量, a.对照数量, a.执行状态, a.医嘱序号, a.收费方式, a.收费类别
           From 医嘱费用记录 A
           Where a.记录状态 = 0) A
    Order By a.收费细目id, a.序号, a.记录状态;

  --按序号排序是为了产生新记录时,填写同一收费细目的不同收入项目的价格父号

  --该游标用于处理费用相关汇总表
  Cursor c_Money
  (
    v_Start 住院费用记录.序号%Type,
    v_End   住院费用记录.序号%Type
  ) Is
    Select 病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, Sum(Nvl(应收金额, 0)) As 应收金额, Sum(Nvl(实收金额, 0)) As 实收金额
    From 住院费用记录
    Where 记录性质 = 2 And 记录状态 = 1 And NO = No_In And 序号 Between v_Start And v_End
    Group By 病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id;

  --系统参数指定执行后需要自动审核的划价费用：用于非药医嘱，包含对应的药品及卫材费用
  Cursor c_Verify
  (
    v_Start 住院费用记录.序号%Type,
    v_End   住院费用记录.序号%Type
  ) Is
    Select NO, 序号
    From 住院费用记录
    Where 记录性质 = 2 And 记录状态 = 0 And NO = No_In And 价格父号 Is Null And 序号 Between v_Start And v_End;

  Cursor c_Compound
  (
    相关id_In       病人医嘱记录.相关id%Type,
    执行终止时间_In 病人医嘱记录.执行终止时间%Type,
    配药id_In       输液配药记录.Id%Type
  ) Is
    Select b.费用id, b.药品id As 收费细目id, a.数量, c.住院包装, c.住院单位, d.名称, e.病人病区id, e.操作状态, e.Id As 配药id, f.No,
           Nvl(f.价格父号, f.序号) As 序号, f.记录状态 As 记录状态, f.执行状态 As 执行标志
    From 输液配药内容 A, 药品收发记录 B, 药品规格 C, 收费项目目录 D, 输液配药记录 E, 住院费用记录 F
    Where a.收发id = b.Id And b.药品id = c.药品id And c.药品id = d.Id And e.Id = a.记录id And f.No = b.No And f.Id = b.费用id And
          e.医嘱id = 相关id_In And e.执行时间 > 执行终止时间_In And e.Id = 配药id_In;

  v_Dec      Number;
  v_First    Number;
  v_划价类别 Varchar2(255);

  v_诊疗类别 病人医嘱记录.诊疗类别%Type;
  v_单次用量 病人医嘱记录.单次用量%Type;
  v_跟踪在用 材料特性.跟踪在用%Type;

  v_费用序号 住院费用记录.序号%Type;
  v_收发序号 药品收发记录.序号%Type;
  v_费用id   住院费用记录.Id%Type;
  v_实收金额 住院费用记录.实收金额%Type;

  v_开始序号 住院费用记录.序号%Type;
  v_结束序号 住院费用记录.序号%Type;

  v_医嘱执行 病人医嘱发送.执行状态%Type;

  v_剂量系数 药品规格.剂量系数%Type;
  v_住院包装 药品规格.住院包装%Type;
  v_医嘱内容 病人医嘱记录.医嘱内容%Type;

  v_结帐参数       Zlparameters.参数值%Type;
  v_配液药销帐申请 Zlparameters.参数值%Type;
  v_结帐金额       住院费用记录.结帐金额%Type;

  v_收费细目id   住院费用记录.收费细目id%Type;
  v_剩余数量     住院费用记录.数次%Type;
  v_收回数量     住院费用记录.数次%Type;
  v_当前数量     住院费用记录.数次%Type;
  v_当前付数     住院费用记录.付数%Type;
  v_费用ids      Varchar2(4000);
  v_组id         病人医嘱记录.Id%Type;
  v_对照数量     病人医嘱计价.数量%Type;
  v_收回量       住院费用记录.数次%Type;
  v_收回剩余     住院费用记录.数次%Type;
  v_输液收回剩余 住院费用记录.数次%Type;

  v_Delno    Varchar2(4000);
  v_Temp     Varchar2(4000);
  v_收费内容 Varchar2(4000);
  v_No       住院费用记录.No%Type;
  v_人员编号 住院费用记录.操作员编号%Type;
  v_人员姓名 住院费用记录.操作员姓名%Type;

  n_相关id       病人医嘱记录.相关id%Type;
  d_执行终止时间 病人医嘱记录.执行终止时间%Type;
  n_药品id       病人医嘱记录.收费细目id%Type;
  b_输液配药记录 Boolean;
  d_收回时间     病人医嘱记录.执行终止时间%Type;
  n_申请类别     病人费用销帐.申请类别%Type;
  v_销帐原因     病人费用销帐.销帐原因%Type;
  n_Count        Number;

  v_Error Varchar2(255);
  Err_Custom Exception;

  Procedure 负数收发记录_Insert
  (
    费用id_In     Number,
    批次_In       药品收发记录.批次%Type,
    分批_In       药品规格.药房分批%Type,
    批号_In       药品收发记录.批号%Type,
    效期_In       药品收发记录.效期%Type,
    最大效期_In   药品规格.最大效期%Type,
    收发id_In     药品收发记录.Id%Type,
    病人id_In     住院费用记录.病人id%Type,
    主页id_In     住院费用记录.主页id%Type,
    药品id_In     药品收发记录.药品id%Type,
    库房id_In     药品收发记录.库房id%Type,
    单据_In       药品收发记录.单据%Type,
    姓名_In       病人信息.姓名%Type,
    对方部门id_In 药品收发记录.对方部门id%Type,
    收费类别_In   住院费用记录.收费类别%Type,
    划价类别_In   Varchar
  ) Is
    v_批次   药品收发记录.批次%Type;
    v_效期   药品收发记录.效期%Type;
    v_批号   药品收发记录.批号%Type;
    v_优先级 身份.优先级%Type;
  Begin
    --确定批次
    If Nvl(批次_In, 0) <> 0 And 分批_In = 0 Then
      --原分批,现不分批
      v_批次 := Null;
      v_批号 := 批号_In;
      v_效期 := 效期_In;
    Elsif Nvl(批次_In, 0) = 0 And 分批_In = 1 Then
      --原不分批,现分批
      Select 药品收发记录_Id.Nextval Into v_批次 From Dual;
      Select To_Char(Sysdate, 'YYYYMMDD') Into v_批号 From Dual;
      If 最大效期_In Is Not Null Then
        v_效期 := Trunc(Sysdate + 最大效期_In * 30);
      Else
        v_效期 := Null;
      End If;
    Else
      v_批次 := 批次_In;
      v_批号 := 批号_In;
      v_效期 := 效期_In;
    End If;
  
    Insert Into 药品收发记录
      (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人, 填制日期,
       费用id, 单量, 频次, 用法, 供药单位id, 生产日期, 批准文号, 灭菌效期)
      Select 药品收发记录_Id.Nextval, 1, 单据, No_In, v_收发序号, 库房id, 对方部门id, 入出类别id, -1, 药品id, v_批次, 产地, v_批号, v_效期, v_当前付数,
             -1 * v_当前数量, -1 * v_当前数量, 零售价, Round(-1 * v_当前付数 * v_当前数量 * 零售价, v_Dec), '超期发送收回', v_人员姓名, 收回时间_In, 费用id_In,
             单量, 频次, 用法, 供药单位id, 生产日期, 批准文号, 灭菌效期
      From 药品收发记录
      Where ID = 收发id_In;
  
    --药品库存
    Update 药品库存
    Set 可用数量 = Nvl(可用数量, 0) - (-1 * v_当前付数 * v_当前数量)
    Where 库房id = 库房id_In And 药品id = 药品id_In And Nvl(批次, 0) = Nvl(v_批次, 0) And 性质 = 1;
    If Sql%RowCount = 0 Then
      Insert Into 药品库存
        (库房id, 药品id, 性质, 可用数量, 批次, 效期)
      Values
        (库房id_In, 药品id_In, 1, v_当前付数 * v_当前数量, v_批次, v_效期);
    End If;
  
    --未发药品记录
    Update 未发药品记录
    Set 病人id = 病人id_In, 主页id = 主页id_In, 姓名 = 姓名_In
    Where 单据 = 单据_In And NO = No_In And 库房id + 0 = 库房id_In;
  
    If Sql%RowCount = 0 Then
      --取身份优先级
      Begin
        Select b.优先级 Into v_优先级 From 病人信息 A, 身份 B Where a.身份 = b.名称(+) And a.病人id = 病人id_In;
      Exception
        When Others Then
          Null;
      End;
    
      Insert Into 未发药品记录
        (单据, NO, 病人id, 主页id, 姓名, 优先级, 对方部门id, 库房id, 填制日期, 已收费, 打印状态)
      Values
        (单据_In, No_In, 病人id_In, 主页id_In, 姓名_In, v_优先级, 对方部门id_In, 库房id_In, 收回时间_In,
         Decode(Nvl(Instr(划价类别_In, Decode(收费类别_In, '4', '4', '5')), 0), 0, 1, 0), 0);
    End If;
  
    v_收发序号 := v_收发序号 + 1;
  End;
Begin
  --取操作员信息(部门ID,部门名称;人员ID,人员编号,人员姓名)
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
    v_人员编号 := 操作员编号_In;
    v_人员姓名 := 操作员姓名_In;
  Else
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;
  --检查是否是输液配液记录，并是否已经锁定
  Select 医嘱内容 Into v_医嘱内容 From 病人医嘱记录 Where ID = 医嘱id_In;
  Select Count(1)
  Into n_Count
  From 输液配药记录 A, 病人医嘱记录 B
  Where a.医嘱id = b.Id And 医嘱id = 医嘱id_In And a.执行时间 > b.执行终止时间 And a.是否锁定 = 1;

  If n_Count > 0 Then
    v_Error := '医嘱"' || v_医嘱内容 || '"是输液药品，已经被输液配置中心锁定，不能超期收回。';
    Raise Err_Custom;
  End If;
  Select Max(操作说明) Into v_销帐原因 From 病人医嘱状态 Where 医嘱id = 医嘱id_In And 操作类型 = 8;
  If Nvl(收回量_In, 0) > 0 Then
    --判断是否是输液配药药品(输液配制中心药品统一走销帐申请)
    b_输液配药记录 := False;
    v_输液收回剩余 := 收回量_In;
    Select a.相关id, a.执行终止时间, Max(b.收费细目id)
    Into n_相关id, d_执行终止时间, n_药品id
    From 病人医嘱记录 A, 住院费用记录 B
    Where a.Id = 医嘱id_In And a.Id = b.医嘱序号(+)
    Group By a.相关id, a.执行终止时间;
    If n_相关id Is Not Null Then
      If d_执行终止时间 Is Not Null Then
        d_收回时间       := 收回时间_In;
        v_配液药销帐申请 := zl_GetSysParameter('配液输液单配药后允许销帐申请', 1345);
        Select Count(1) Into n_Count From 输液配药记录 E Where e.医嘱id = n_相关id And e.执行时间 > d_执行终止时间;
        If n_Count > 0 Then
          b_输液配药记录 := True;
          For X In (Select e.Id As 配药id, e.操作状态
                    From 输液配药记录 E
                    Where e.医嘱id = n_相关id And e.执行时间 > d_执行终止时间 And Nvl(e.操作状态, 0) In (1, 2, 3, 4, 5, 6, 7, 8)) Loop
            If Not (x.操作状态 In (4, 5, 6, 7, 8) And Nvl(v_配液药销帐申请, '0') = '0') Then
              For r_Compound In c_Compound(n_相关id, d_执行终止时间, x.配药id) Loop
              
                v_输液收回剩余 := v_输液收回剩余 - r_Compound.数量;
                If x.操作状态 = 1 Then
                  n_申请类别 := 0;
                Else
                  n_申请类别 := 1;
                End If;
                Select Count(1)
                Into n_Count
                From 病人费用销帐
                Where 费用id = r_Compound.费用id And 收费细目id = r_Compound.收费细目id And
                      申请时间 =
                      (Select Max(操作时间) From 输液配药状态 A Where a.配药id = r_Compound.配药id And a.操作类型 = 9);
                If n_Count = 0 Then
                  Zl_病人费用销帐_Insert(r_Compound.费用id, r_Compound.收费细目id, r_Compound.病人病区id, r_Compound.数量, v_人员姓名, d_收回时间,
                                   n_申请类别, Null, r_Compound.配药id, v_销帐原因);
                  If x.操作状态 = 1 Then
                    --未发药的，自动审核。
                    Zl_病人费用销帐_Audit(r_Compound.费用id, d_收回时间, v_人员姓名, d_收回时间, 1, 1, n_申请类别);
                    Zl_住院记帐记录_Delete(r_Compound.No, r_Compound.序号 || ':' || r_Compound.数量 || ':' || r_Compound.配药id,
                                     v_人员编号, v_人员姓名, 2, Null, Null, d_收回时间);
                  End If;
                End If;
              End Loop;
              --由于不同批次（执行时间）申请时，申请时间和费用ID有唯一约束，所以同时销帐多个批次时，依次加一秒
              d_收回时间 := d_收回时间 + 1 / 24 / 60 / 60;
            End If;
          End Loop;
        End If;
      End If;
    End If;
    --a.销帐申请收回模式
    --输液配药记录单独进行销帐
    If b_输液配药记录 = False Or v_输液收回剩余 > 0 Then
      If No_In Is Null Then
        v_结帐参数 := zl_GetSysParameter(23);
        --根据收回数量对照原始费用进行分摊申请
        For r_Detail In c_Detail Loop
          --确定该收费细目ID的收回总数量
          If Nvl(v_收费细目id, 0) <> r_Detail.收费细目id And (r_Detail.诊疗类别 Not In ('5', '6', '7') Or Nvl(v_收费细目id, 0) = 0) Then
            --数量未分摊完成
            If v_收费细目id Is Not Null And v_收回数量 > 0 Then
              v_Error := '医嘱"' || v_医嘱内容 || '"对应的费用剩余数量不足收回数量，可能存在手工销帐或已结帐的费用，或相应的划价单已被删除。';
              Raise Err_Custom;
            End If;
            --药品收回总量是以最后发送规格为准计算的，以此计算出收回售价数量
            Begin
              Select 剂量系数, 住院包装 Into v_剂量系数, v_住院包装 From 药品规格 Where 药品id = r_Detail.收费细目id;
            Exception
              When Others Then
                Null;
            End;
            --计算收回数量，如果收费方式不是0正常收取，则使用特殊的方法进行计算
            If r_Detail.收费方式 = 0 Then
              If r_Detail.诊疗类别 = '7' Then
                --中药配方药品：付数*单量
                v_收回数量 := Round(v_输液收回剩余 * r_Detail.单次用量 / Nvl(v_剂量系数, 1), 5);
              Else
                If r_Detail.诊疗类别 Not In ('5', '6') Then
                  Select Nvl(Max(数量), 1)
                  Into v_对照数量
                  From 病人医嘱计价
                  Where 医嘱id = 医嘱id_In And 收费细目id = r_Detail.收费细目id;
                Else
                  v_对照数量 := 1;
                End If;
                v_收回数量 := Round(v_输液收回剩余 * Nvl(v_住院包装, 1), 5) * v_对照数量;
              End If;
            Else
              Select Nvl(Sum(数量), 0)
              Into v_收回数量
              From 医嘱执行计价
              Where 医嘱id = 医嘱id_In And 收费细目id = r_Detail.收费细目id And
                    要求时间 > Nvl(上次时间_In, To_Date('1900-01-01', 'yyyy-MM-dd'));
            
              v_收回数量 := Round(v_收回数量, 5);
            
            End If;
            v_医嘱内容 := r_Detail.医嘱内容;
          End If;
        
          --该收费细目的每个费用明细分摊收回
          If v_收回数量 > 0 Then
            --检查对应费用是否已结帐，当禁止时
            v_结帐金额 := 0;
            If v_结帐参数 = '2' And r_Detail.记录状态 <> 0 Then
              Select Sum(结帐金额)
              Into v_结帐金额
              From 住院费用记录
              Where NO = r_Detail.No And 记录性质 In (2, 12) And Nvl(价格父号, 序号) = r_Detail.序号;
            End If;
          
            If Nvl(v_结帐金额, 0) = 0 Then
              If r_Detail.收费类别 In ('5', '6', '7') Or r_Detail.收费类别 = '4' And r_Detail.跟踪在用 = 1 Then
                --药品和跟踪在用的卫材
                If r_Detail.执行标志 = 0 Then
                  v_剩余数量 := r_Detail.未执行量;
                Elsif r_Detail.执行标志 = 1 Then
                  v_剩余数量 := r_Detail.已执行量;
                End If;
              Else
                --普通费用
                v_剩余数量 := r_Detail.剩余数量;
              End If;
              If v_收回数量 > v_剩余数量 Then
                v_当前数量 := v_剩余数量;
              Else
                v_当前数量 := v_收回数量;
              End If;
              v_收回数量 := v_收回数量 - v_当前数量;
              --系统参数决定执行后是否审核划价单，所以，已执行的仍然可能是划价单
              If r_Detail.执行标志 = 0 And r_Detail.记录状态 = 0 Then
                v_Delno := v_Delno || '|' || r_Detail.No || ',' || r_Detail.序号 || ':' || v_当前数量;
              Else
                If Not (r_Detail.收费类别 = '7' And r_Detail.执行标志 <> 0) Then
                  Zl_病人费用销帐_Insert(r_Detail.费用id, r_Detail.收费细目id, r_Detail.病人病区id, v_当前数量, v_人员姓名, 收回时间_In,
                                   r_Detail.执行标志, Null, Null, v_销帐原因);
                End If;
              End If;
              v_费用ids := v_费用ids || ',' || r_Detail.费用id;
            End If;
          End If;
          v_收费细目id := r_Detail.收费细目id;
        End Loop;
      
        --数量未分摊完成
        If v_收回数量 > 0 Then
          v_Error := '医嘱"' || v_医嘱内容 || '"对应的费用剩余数量不足收回数量，可能存在手工销帐或已结帐的费用，或相应的划价单已被删除。';
          Raise Err_Custom;
        End If;
        --本科的销帐申请自动审核
        If zl_GetSysParameter('超期收回费用本科自动审核', 1254) = '1' And v_费用ids Is Not Null Then
          For r_Applay In c_Applay(Substr(v_费用ids, 2)) Loop
            Zl_病人费用销帐_Audit(r_Applay.费用id, r_Applay.申请时间, v_人员姓名, 收回时间_In, 1, 1, r_Applay.申请类别);
            v_Delno := v_Delno || '|' || r_Applay.No || ',' || r_Applay.序号 || ':' || r_Applay.数量;
          End Loop;
        End If;
      Else
        ---b.负数收回模式-------------------------------------------------------------------------------------------------------
        --如果全是划价单，就不用产生负数冲销单据
        If No_In = '调整划价单' Then
          --未审核的划价单，先进行修改或删除，可能多次发送为不同的NO,为了计算每次的收回量，需要按收费细目ID排序
          For r_Price In (Select c.诊疗类别, b.No, b.序号, b.收费细目id, Nvl(b.付数, 1) * b.数次 As 剩余数量, c.单次用量, d.剂量系数, d.住院包装,
                                 c.医嘱内容, Nvl(e.收费方式, 0) As 收费方式
                          From 病人医嘱发送 A, 住院费用记录 B, 病人医嘱记录 C, 药品规格 D, 病人医嘱计价 E
                          Where a.医嘱id = 医嘱id_In And a.No = b.No And a.记录性质 = b.记录性质 And a.医嘱id = b.医嘱序号 And
                                b.价格父号 Is Null And b.收费细目id = d.药品id(+) And b.记录状态 = 0 And c.Id = a.医嘱id And
                                b.医嘱序号 = e.医嘱id(+) And b.收费细目id = e.收费细目id(+)
                          Order By 收费细目id, NO Desc) Loop
            If Nvl(v_收费细目id, 0) <> r_Price.收费细目id Then
              --数量未分摊完成
              If v_收费细目id Is Not Null And v_收回数量 > 0 Then
                v_Error := '医嘱"' || v_医嘱内容 || '"对应的费用剩余数量不足收回数量，可能相关划价单已被删除或审核。';
                Raise Err_Custom;
              End If;
              --计算收回数量，如果收费方式不是0正常收取，则使用特殊的方法进行计算
              If r_Price.收费方式 = 0 Then
                If r_Price.诊疗类别 = '7' Then
                  --中药配方药品：付数*单量
                  v_收回数量 := Round(v_输液收回剩余 * r_Price.单次用量 / Nvl(r_Price.剂量系数, 1), 5);
                Else
                  If r_Price.诊疗类别 Not In ('5', '6') Then
                    Select Nvl(Max(数量), 1)
                    Into v_对照数量
                    From 病人医嘱计价
                    Where 医嘱id = 医嘱id_In And 收费细目id = r_Price.收费细目id;
                  Else
                    v_对照数量 := 1;
                  End If;
                  v_收回数量 := Round(v_输液收回剩余 * Nvl(r_Price.住院包装, 1), 5) * v_对照数量;
                End If;
              Else
                Select Nvl(Sum(数量), 0)
                Into v_收回数量
                From 医嘱执行计价
                Where 医嘱id = 医嘱id_In And 收费细目id = r_Price.收费细目id And
                      要求时间 > Nvl(上次时间_In, To_Date('1900-01-01', 'yyyy-MM-dd'));
              
                v_收回数量 := Round(v_收回数量, 5);
              End If;
              v_医嘱内容 := r_Price.医嘱内容;
            End If;
            If v_收回数量 > 0 Then
              If v_收回数量 > r_Price.剩余数量 Then
                v_当前数量 := r_Price.剩余数量;
              Else
                v_当前数量 := v_收回数量;
              End If;
              v_收回数量 := v_收回数量 - v_当前数量;
              v_Delno    := v_Delno || '|' || r_Price.No || ',' || r_Price.序号 || ':' || v_当前数量;
            End If;
            v_收费细目id := r_Price.收费细目id;
          End Loop;
          --数量未分摊完成
          If v_收回数量 > 0 Then
            v_Error := '医嘱"' || v_医嘱内容 || '"对应的费用剩余数量不足收回数量，可能相关划价单已被删除或审核。';
            Raise Err_Custom;
          End If;
        Else
          --负数冲销，可能存在划价单与记帐单混合的情况
          --金额小数位数
          Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into v_Dec From Dual;
          --生成划价单系统参数
          Select zl_GetSysParameter(80) Into v_划价类别 From Dual;
          v_开始序号 := Null;
          v_结束序号 := Null;
        
          Select a.诊疗类别, a.单次用量, b.跟踪在用
          Into v_诊疗类别, v_单次用量, v_跟踪在用
          From 病人医嘱记录 A, 材料特性 B
          Where ID = 医嘱id_In And a.收费细目id = b.材料id(+);
        
          If v_诊疗类别 In ('5', '6', '7') Or (v_诊疗类别 = '4' And Nvl(v_跟踪在用, 0) = 1) Then
            --药品、卫材
            -----------------------------------------------------------------------------------------------------
            v_收回数量 := Null;
            Select Nvl(Max(序号), 0) + 1
            Into v_收发序号
            From 药品收发记录
            Where 单据 In (9, 10, 25, 26) And 记录状态 = 1 And NO = No_In;
            Select Nvl(Max(序号), 0) + 1
            Into v_费用序号
            From 住院费用记录
            Where 记录性质 = 2 And 记录状态 In (0, 1) And NO = No_In;
          
            --一条医嘱的药品只有一行，这里的循环是为了处理多次发送的情况，分批药品在界面已禁用负数收回
            For r_Drug In c_Drug Loop
              --初始化要收回的总数量(零售数量)
              v_First := 0;
              If v_收回数量 Is Null Then
                If v_诊疗类别 = '7' Then
                  v_收回数量 := Round(v_输液收回剩余 * v_单次用量 / r_Drug.剂量系数, 5);
                Else
                  If v_诊疗类别 Not In ('5', '6') Then
                    Select Nvl(Max(数量), 1)
                    Into v_对照数量
                    From 病人医嘱计价
                    Where 医嘱id = 医嘱id_In And 收费细目id = r_Drug.收费细目id;
                  Else
                    v_对照数量 := 1;
                  End If;
                  v_收回数量 := Round(v_输液收回剩余 * r_Drug.住院包装, 5) * v_对照数量;
                End If;
                v_First := 1;
              End If;
            
              --如果第一次数量就足够，则按付数处理，否则付数不好处理
              If v_收回数量 > r_Drug.数量 Then
                v_当前付数 := 1;
                v_当前数量 := r_Drug.数量;
                v_收回数量 := v_收回数量 - r_Drug.数量;
              Else
                If v_First = 1 And v_诊疗类别 = '7' Then
                  v_当前付数 := v_输液收回剩余;
                  v_当前数量 := Round(v_单次用量 / r_Drug.剂量系数, 5);
                Else
                  v_当前付数 := 1;
                  v_当前数量 := v_收回数量;
                End If;
                v_收回数量 := 0;
              End If;
            
              If r_Drug.记录状态 = 0 Then
                v_Delno := v_Delno || '|' || r_Drug.No || ',' || r_Drug.序号 || ':' || v_当前数量 * v_当前付数;
              Else
                If Not (v_诊疗类别 = '7' And r_Drug.执行标志 <> 0) Then
                
                  Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
                  负数收发记录_Insert(v_费用id, r_Drug.批次, r_Drug.分批, r_Drug.批号, r_Drug.效期, r_Drug.最大效期, r_Drug.收发id,
                                r_Drug.病人id, r_Drug.主页id, r_Drug.药品id, r_Drug.库房id, r_Drug.单据, r_Drug.姓名, r_Drug.对方部门id,
                                v_诊疗类别, v_划价类别);
                
                  --住院费用记录
                  -------------------------------------------------------------------------------------
                  --记录序号范围以处理汇总表
                  If v_开始序号 Is Null Then
                    v_开始序号 := v_费用序号;
                  End If;
                  v_结束序号 := v_费用序号;
                
                  Insert Into 住院费用记录
                    (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id,
                     费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额,
                     统筹金额, 记帐费用, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 医嘱序号, 划价人, 操作员编号, 操作员姓名)
                    Select v_费用id, 2, No_In, Decode(Nvl(Instr(v_划价类别, Decode(v_诊疗类别, '4', '4', '5')), 0), 0, 1, 0),
                           v_费用序号, Null, Null, 多病人单, 2, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id, 费别, 收费类别,
                           收费细目id, 计算单位, 保险项目否, 保险大类id, v_当前付数, -1 * v_当前数量, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价,
                           Round(-1 * v_当前付数 * v_当前数量 * 标准单价, v_Dec), Round(-1 * v_当前付数 * v_当前数量 * 标准单价, v_Dec), Null, 1,
                           开单部门id, 开单人, 收回时间_In, 收回时间_In, 执行部门id, 0, 医嘱序号, v_人员姓名,
                           Decode(Nvl(Instr(v_划价类别, Decode(v_诊疗类别, '4', '4', '5')), 0), 0, v_人员编号, Null),
                           Decode(Nvl(Instr(v_划价类别, Decode(v_诊疗类别, '4', '4', '5')), 0), 0, v_人员姓名, Null)
                    From 住院费用记录
                    Where ID = r_Drug.费用id;
                
                  Select Zl_Actualmoney(费别, 收费细目id, 收入项目id, 应收金额, 数次, 执行部门id)
                  Into v_Temp
                  From 住院费用记录
                  Where ID = v_费用id;
                  v_实收金额 := Round(Substr(v_Temp, Instr(v_Temp, ':') + 1), v_Dec);
                  Update 住院费用记录 A Set 实收金额 = v_实收金额 Where ID = v_费用id;
                
                  v_费用序号 := v_费用序号 + 1;
                End If;
                If v_收回数量 <= 0 Then
                  Exit;
                End If;
              End If;
            End Loop;
          
            If v_收回数量 <> 0 Then
              --没有收回所有数量,收发记录本身有问题(如记录不全或数量为负)
              Null;
            End If;
          Else
            --其它非药医嘱(包括给药途径，及绑定的卫材等)
            -----------------------------------------------------------------------------------------------------
            Select Nvl(Max(序号), 0) + 1
            Into v_收发序号
            From 药品收发记录
            Where 单据 In (9, 10, 25, 26) And 记录状态 = 1 And NO = No_In;
            --取费用序号
            Select Nvl(Max(序号), 0) + 1
            Into v_费用序号
            From 住院费用记录
            Where 记录性质 = 2 And 记录状态 In (0, 1) And NO = No_In;
          
            v_收回剩余 := v_输液收回剩余;
          
            For r_Othersend In (Select 发送号, 发送数次
                                From 病人医嘱发送
                                Where 医嘱id = 医嘱id_In And 末次时间 > 上次时间_In
                                Order By 发送号 Desc) Loop
              If r_Othersend.发送数次 < v_收回剩余 Then
                --一次收回多次发送，但是每次发送费用有所变动（计价）
                v_收回剩余 := v_收回剩余 - r_Othersend.发送数次;
                v_收回量   := r_Othersend.发送数次;
              Else
                --一次发送中收回剩余；
                v_收回量   := v_收回剩余;
                v_收回剩余 := 0;
              End If;
              v_收费内容 := '';
              For r_Other In c_Other(r_Othersend.发送号) Loop
                If Nvl(v_收费内容, '0') <> r_Other.收费细目id || ',' || r_Other.序号 Then
                  --根据最近一次发送的费用记录，按需要收回的数量全部收回
                  --计算收回数量，如果收费方式不是0正常收取，则使用特殊的方法进行计算
                  If r_Other.收费方式 = 0 Then
                    v_收回数量 := v_收回量 * Nvl(r_Other.对照数量, 1);
                  Else
                    Select Nvl(Sum(数量), 0)
                    Into v_收回数量
                    From 医嘱执行计价
                    Where 医嘱id = 医嘱id_In And 收费细目id = r_Other.收费细目id And
                          要求时间 > Nvl(上次时间_In, To_Date('1900-01-01', 'yyyy-MM-dd'));
                  End If;
                End If;
              
                If v_收回数量 > 0 Then
                  If r_Other.记录状态 = 0 Then
                    If v_收回数量 > r_Other.剩余数量 Then
                      v_当前数量 := r_Other.剩余数量;
                    Else
                      v_当前数量 := v_收回数量;
                    End If;
                  Else
                    v_当前数量 := v_收回数量;
                  End If;
                  v_收回数量 := v_收回数量 - v_当前数量;
                  v_当前付数 := 1;
                
                  If r_Other.记录状态 = 0 Then
                    v_Delno := v_Delno || '|' || r_Other.No || ',' || r_Other.序号 || ':' || v_当前数量;
                  Else
                    --记录序号范围以处理汇总表
                    If v_开始序号 Is Null Then
                      v_开始序号 := v_费用序号;
                    End If;
                    v_结束序号 := v_费用序号;
                  
                    --住院费用记录:按理如果收回量大于了上次发送量,则不正确
                    Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
                    If r_Other.收费类别 In ('4', '5', '6', '7') Then
                      For r_Otherdrug In (Select a.病人id, a.主页id, d.姓名, Nvl(x.剂量系数, 1) As 剂量系数, Nvl(x.住院包装, 1) As 住院包装,
                                                 x.最大效期, Nvl(b.付数, 1) * b.实际数量 As 数量, b.Id As 收发id, b.单据, b.药品id,
                                                 b.对方部门id, b.库房id, b.费用id, Nvl(x.药房分批, 0) As 分批, b.批次, b.批号, b.效期, a.记录状态,
                                                 a.No, a.序号, a.收费细目id
                                          From 住院费用记录 A, 药品收发记录 B, 病人信息 D, 药品规格 X
                                          Where a.Id = r_Other.费用id And a.记录状态 In (0, 1, 3) And a.No = b.No And
                                                a.Id = b.费用id + 0 And b.单据 In (9, 10, 25, 26) And
                                                (b.记录状态 = 1 Or Mod(b.记录状态, 3) = 0) And a.病人id = d.病人id And
                                                b.药品id = x.药品id(+)
                                          Order By a.记录状态, b.No Desc, b.Id Desc) Loop
                        负数收发记录_Insert(v_费用id, r_Otherdrug.批次, r_Otherdrug.分批, r_Otherdrug.批号, r_Otherdrug.效期,
                                      r_Otherdrug.最大效期, r_Otherdrug.收发id, r_Otherdrug.病人id, r_Otherdrug.主页id,
                                      r_Otherdrug.药品id, r_Otherdrug.库房id, r_Otherdrug.单据, r_Otherdrug.姓名,
                                      r_Otherdrug.对方部门id, r_Other.收费类别, v_划价类别);
                      End Loop;
                    End If;
                    --医嘱已执行，收回的费用也填为已执行：不包含药品和跟踪在用的卫材，因为实际发放表示执行
                    Insert Into 住院费用记录
                      (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id,
                       费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额,
                       统筹金额, 记帐费用, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 执行时间, 执行人, 医嘱序号, 划价人, 操作员编号, 操作员姓名)
                      Select v_费用id, 2, No_In, Decode(Nvl(Instr(v_划价类别, r_Other.收费类别), 0), 0, 1, 0), v_费用序号, Null,
                             Decode(a.价格父号, Null, Null, v_费用序号 + a.价格父号 - a.序号), a.多病人单, 2, a.病人id, a.主页id, a.标识号, a.姓名,
                             a.性别, a.年龄, a.床号, a.病人病区id, a.病人科室id, a.费别, a.收费类别, a.收费细目id, a.计算单位, a.保险项目否, a.保险大类id, 1,
                             -1 * v_当前数量, a.加班标志, a.附加标志, a.婴儿费, a.收入项目id, a.收据费目, a.标准单价,
                             Round(-1 * v_当前数量 * a.标准单价, v_Dec), Round(-1 * v_当前数量 * a.标准单价, v_Dec), Null, 1, a.开单部门id,
                             a.开单人, 收回时间_In, 收回时间_In, a.执行部门id,
                             Decode(r_Other.执行状态, 1,
                                     Decode(a.收费类别, '4', Decode(b.跟踪在用, 1, 0, 1),
                                             Decode(Instr(',5,6,7,', a.收费类别), 0, 1, 0)), 0),
                             Decode(r_Other.执行状态, 1,
                                     Decode(a.收费类别, '4', Decode(b.跟踪在用, 1, Null, 收回时间_In),
                                             Decode(Instr(',5,6,7,', a.收费类别), 0, 收回时间_In, Null)), Null),
                             Decode(r_Other.执行状态, 1,
                                     Decode(a.收费类别, '4', Decode(b.跟踪在用, 1, Null, v_人员姓名),
                                             Decode(Instr(',5,6,7,', a.收费类别), 0, v_人员姓名, Null)), Null), a.医嘱序号, v_人员姓名,
                             Decode(Nvl(Instr(v_划价类别, r_Other.收费类别), 0), 0, v_人员编号, Null),
                             Decode(Nvl(Instr(v_划价类别, r_Other.收费类别), 0), 0, v_人员姓名, Null)
                      From 住院费用记录 A, 材料特性 B
                      Where a.Id = r_Other.费用id And a.收费细目id = b.材料id(+);
                  
                    Select Zl_Actualmoney(费别, 收费细目id, 收入项目id, 应收金额, 数次, 执行部门id)
                    Into v_Temp
                    From 住院费用记录
                    Where ID = v_费用id;
                    v_实收金额 := Round(Substr(v_Temp, Instr(v_Temp, ':') + 1), v_Dec);
                    Update 住院费用记录 A Set 实收金额 = v_实收金额 Where ID = v_费用id;
                  
                    v_费用序号 := v_费用序号 + 1;
                    v_医嘱执行 := r_Other.执行状态; --多个收费项目的执行状态是一样的
                  End If;
                
                  v_收费内容 := r_Other.收费细目id || ',' || r_Other.序号;
                End If;
              End Loop;
              If v_收回剩余 = 0 Then
                Exit;
              End If;
            End Loop;
          
            --如果医嘱已执行，则按系统参数执行后自动审核费用：包含已执行医嘱对应的药品和卫材费用。
            -----------------------------------------------------------------------------------------------------
            If Nvl(v_医嘱执行, 0) = 1 And v_开始序号 Is Not Null And v_结束序号 Is Not Null Then
              For r_Verify In c_Verify(v_开始序号, v_结束序号) Loop
                Zl_住院记帐记录_Verify(r_Verify.No, v_人员编号, v_人员姓名, r_Verify.序号, Null, 收回时间_In);
              End Loop;
            End If;
          End If;
        
          --处理费用汇总表
          -----------------------------------------------------------------------------------------------------
          If v_开始序号 Is Not Null And v_结束序号 Is Not Null Then
            --最后统一处理费用相关汇总表
            For r_Money In c_Money(v_开始序号, v_结束序号) Loop
              --病人余额
              Update 病人余额
              Set 费用余额 = Nvl(费用余额, 0) + r_Money.实收金额
              Where 病人id = r_Money.病人id And 性质 = 1 And 类型 = 2;
            
              If Sql%RowCount = 0 Then
                Insert Into 病人余额
                  (病人id, 性质, 类型, 费用余额, 预交余额)
                Values
                  (r_Money.病人id, 1, 2, r_Money.实收金额, 0);
              End If;
            
              --病人未结费用
              Update 病人未结费用
              Set 金额 = Nvl(金额, 0) + r_Money.实收金额
              Where 病人id = r_Money.病人id And 主页id = r_Money.主页id And Nvl(病人病区id, 0) = Nvl(r_Money.病人病区id, 0) And
                    Nvl(病人科室id, 0) = Nvl(r_Money.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(r_Money.开单部门id, 0) And
                    Nvl(执行部门id, 0) = Nvl(r_Money.执行部门id, 0) And 收入项目id + 0 = r_Money.收入项目id And 来源途径 + 0 = 2;
            
              If Sql%RowCount = 0 Then
                Insert Into 病人未结费用
                  (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
                Values
                  (r_Money.病人id, r_Money.主页id, r_Money.病人病区id, r_Money.病人科室id, r_Money.开单部门id, r_Money.执行部门id,
                   r_Money.收入项目id, 2, r_Money.实收金额);
              End If;
            End Loop;
          End If;
        End If;
      End If;
    End If;
  End If;

  --过程Zl_住院记帐记录_Delete，不支持每次删除一行的循环处理（序号重整），必须把一个单据要删除的序号一次性传入
  If Not v_Delno Is Null Then
    v_Temp := '';
    v_No   := '';
    For r_Price In (Select /*+ rule*/
                     C1 As NO, C2 As 序号数量
                    From Table(f_Str2list2(Substr(v_Delno, 2), '|', ','))
                    Order By NO) Loop
      If v_No Is Not Null And v_No <> r_Price.No Then
        Zl_住院记帐记录_Delete(v_No, v_Temp, v_人员编号, v_人员姓名, 2);
        v_No := '';
      End If;
      If v_No Is Null Then
        v_No   := r_Price.No;
        v_Temp := r_Price.序号数量;
      Else
        v_Temp := v_Temp || ',' || r_Price.序号数量;
      End If;
    End Loop;
    If Not v_No Is Null Then
      Zl_住院记帐记录_Delete(v_No, v_Temp, v_人员编号, v_人员姓名, 2);
    End If;
  End If;

  --处理医嘱的上次执行时间:给药途径等可能因为未发送而没调用收回过程。
  -----------------------------------------------------------------------------------------------------
  Select Nvl(相关id, ID) Into v_组id From 病人医嘱记录 Where ID = 医嘱id_In;
  Update 病人医嘱记录 Set 上次执行时间 = 上次时间_In Where ID = v_组id Or 相关id = v_组id;

  --删除医嘱执行时间
  If 上次时间_In Is Null Then
    --全部收回
    Delete From 医嘱执行时间 Where 医嘱id = v_组id;
    Delete From 医嘱执行计价 Where 医嘱id = 医嘱id_In;
  Else
    --可能收回多次发送的数据
    Delete From 医嘱执行时间 Where 医嘱id = v_组id And 要求时间 > 上次时间_In;
    Delete From 医嘱执行计价 Where 医嘱id = 医嘱id_In And 要求时间 > 上次时间_In;
  End If;
  --处理输液配液记录的批次问题，每个医嘱都进行调用，在过程里面只处理了输液配液的医嘱
  Zl_输液配药记录_批次调整(医嘱id_In);

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱记录_收回;
/

--0:梁唐彬,2016-11-10,过程内容兼容性调整不涉及问题修改
CREATE OR REPLACE Procedure Zl_门诊医嘱发送_Insert
( 
  医嘱id_In     病人医嘱发送.医嘱id%Type, 
  发送号_In     病人医嘱发送.发送号%Type, 
  记录性质_In   病人医嘱发送.记录性质%Type, 
  No_In         病人医嘱发送.No%Type, 
  记录序号_In   病人医嘱发送.记录序号%Type, 
  发送数次_In   病人医嘱发送.发送数次%Type, 
  首次时间_In   病人医嘱发送.首次时间%Type, 
  末次时间_In   病人医嘱发送.末次时间%Type, 
  发送时间_In   病人医嘱发送.发送时间%Type, 
  执行状态_In   病人医嘱发送.执行状态%Type, 
  执行部门id_In 病人医嘱发送.执行部门id%Type, 
  计费状态_In   病人医嘱发送.计费状态%Type, 
  First_In      Number := 0, 
  样本条码_In   病人医嘱发送.样本条码%Type := Null, 
  操作员编号_In 人员表.编号%Type := Null, 
  操作员姓名_In 人员表.姓名%Type := Null 
  --功能：填写病人医嘱发送记录 
  --参数：First_IN=表示是否一组医嘱的第一医嘱行,以便处理医嘱相关内容(如成药,配方的第一行,因为给药途径,配方煎法,用法可能为叮嘱不发送) 
) Is 
  --包含病人及医嘱(一组医嘱中第一行)相关信息的游标 
  Cursor c_Advice Is 
    Select Nvl(a.相关id, a.Id) As 组id, a.序号, a.病人id, a.挂号单, a.婴儿, b.姓名, c.操作类型, a.诊疗类别, a.医嘱状态, a.医嘱内容, a.开嘱医生, a.开始执行时间, 
           a.执行时间方案, a.频率次数, a.频率间隔, a.间隔单位, Nvl(a.紧急标志, 0) As 紧急标志 
    From 病人医嘱记录 A, 病人信息 B, 诊疗项目目录 C 
    Where a.病人id = b.病人id And a.诊疗项目id = c.Id And a.Id = 医嘱id_In 
    Group By Nvl(a.相关id, a.Id), a.序号, a.病人id, a.挂号单, a.婴儿, b.姓名, c.操作类型, a.诊疗类别, a.医嘱状态, a.医嘱内容, a.开嘱医生, a.开始执行时间, 
             a.执行时间方案, a.频率次数, a.频率间隔, a.间隔单位, a.紧急标志; 
  r_Advice c_Advice%RowType; 
 
  Cursor c_Pati(v_病人id 病人信息.病人id%Type) Is 
    Select * From 病人信息 Where 病人id = v_病人id; 
  r_Pati c_Pati%RowType; 
 
  --其它临时变量 
  v_Temp     Varchar2(255); 
  v_Count    Number; 
  v_病人性质 病案主页.病人性质%Type; 
  v_人员编号 人员表.编号%Type; 
  v_人员姓名 人员表.姓名%Type; 
  v_入院方式 入院方式.名称%Type; 
  d_开始时间 病人医嘱记录.开始执行时间%Type; 
  n_医嘱状态 病人医嘱记录.医嘱状态%Type;

  v_Error Varchar2(255); 
  Err_Custom Exception; 
Begin 
  --当前操作人员 
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then 
    v_人员编号 := 操作员编号_In; 
    v_人员姓名 := 操作员姓名_In; 
  Else 
    v_Temp     := Zl_Identity; 
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1); 
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1); 
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1); 
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1); 
  End If; 
  --如果首次时间为空则填入开始执行时间 
  Select 开始执行时间,医嘱状态 Into d_开始时间,n_医嘱状态 From 病人医嘱记录 Where ID = 医嘱id_In;
  
  Open c_Advice; 
    Fetch c_Advice 
  Into r_Advice; 
  --是一组医嘱的第一行时处理医嘱内容 
  If Nvl(First_In, 0) = 1 or n_医嘱状态 = 1 Then 
    --并发操作检查 
    --------------------------------------------------------------------------------------- 
    If Nvl(r_Advice.医嘱状态, 0) <> 1 Then 
      v_Error := '"' || r_Advice.姓名 || '"的医嘱"' || r_Advice.医嘱内容 || '"已经被其他人发送。' || Chr(13) || Chr(10) || 
                 '该病人的医嘱发送失败。请重新读取发送清单再试。'; 
      Raise Err_Custom; 
    End If; 
 
    --发送后的医嘱处理:临嘱发送后自动停止 
    --------------------------------------------------------------------------------------- 
    Update 病人医嘱记录 
    Set 医嘱状态 = 8, 执行终止时间 = 末次时间_In, 
        --可能没有 
        停嘱时间 = 发送时间_In, 
        --要作为发送时间显示 
        停嘱医生 = v_人员姓名 --要作为发送人显示,不同于住院,门诊医嘱无护士操作 
    Where ID = r_Advice.组id Or 相关id = r_Advice.组id; 
 
    Insert Into 病人医嘱状态 
      (医嘱id, 操作类型, 操作人员, 操作时间) 
      Select ID, 8, v_人员姓名, 发送时间_In From 病人医嘱记录 Where ID = r_Advice.组id Or 相关id = r_Advice.组id; 
 
    --特殊医嘱的处理 
    --------------------------------------------------------------------------------------- 
    If r_Advice.诊疗类别 = 'Z' And Nvl(r_Advice.操作类型, '0') <> '0' And Nvl(r_Advice.婴儿, 0) = 0 Then 
      --1-留观;2-住院; 
      If Instr(',1,2,', r_Advice.操作类型) > 0 And 执行部门id_In Is Not Null Then 
        --满足产生新的预约登记的条件：1.当前无预约,2.当前不在院,3-无要求预约时间内的住院记录 
 
        --删除超过挂号有效天数的预约登记 
        Begin 
          Select Count(*) Into v_Count From 病案主页 Where 病人id = r_Advice.病人id And Nvl(主页id, 0) = 0; 
        Exception 
          When Others Then 
            v_Count := 0; 
        End; 
        If Nvl(v_Count, 0) > 0 Then 
          Zl_入院病案主页_Delete(r_Advice.病人id, 0, 0, 0); 
          v_Count := 0; 
        End If; 
 
        If v_Count = 0 Then 
          Select Count(*) Into v_Count From 病案主页 Where 病人id = r_Advice.病人id And 出院日期 Is Null; 
        End If; 
        If v_Count = 0 Then 
          Select Count(*) 
          Into v_Count 
          From 病案主页 
          Where 病人id = r_Advice.病人id And (入院日期 >= r_Advice.开始执行时间 Or 出院日期 >= r_Advice.开始执行时间); 
        End If; 
        If v_Count = 0 Then 
          If r_Advice.操作类型 = '1' Then 
            --留观医嘱,将病人在"开始时间"留观到临床执行科室 
            Begin 
              v_病人性质 := 2; 
              Select Decode(服务对象, 1, 1, 2) 
              Into v_病人性质 
              From 部门性质说明 
              Where 工作性质 = '临床' And 部门id = 执行部门id_In; 
            Exception 
              When Others Then 
                Null; 
            End; 
          Elsif r_Advice.操作类型 = '2' Then 
            --住院医嘱,将病人在"开始时间"登记到临床执行科室 
            v_病人性质 := 0; 
          End If; 
 
          Open c_Pati(r_Advice.病人id); 
          Fetch c_Pati 
            Into r_Pati; 
 
          v_入院方式 := Null; 
          If r_Advice.紧急标志 = 1 Then 
            v_入院方式 := '急诊'; 
          Else 
            Select Decode(急诊, 1, '急诊', Null) 
            Into v_入院方式 
            From 病人挂号记录 
            Where NO = r_Advice.挂号单 And 记录性质 = 1 And 记录状态 = 1; 
          End If; 
 
          If v_病人性质 = 1 Then 
            Zl_入院病案主页_Insert(1, v_病人性质, r_Pati.病人id, r_Pati.门诊号, Null, r_Pati.姓名, r_Pati.性别, r_Pati.年龄, r_Pati.费别, 
                             r_Pati.出生日期, r_Pati.国籍, r_Pati.民族, r_Pati.学历, r_Pati.婚姻状况, r_Pati.职业, r_Pati.身份, 
                             r_Pati.身份证号, r_Pati.出生地点, r_Pati.家庭地址, r_Pati.家庭地址邮编, r_Pati.家庭电话, r_Pati.户口地址, 
                             r_Pati.户口地址邮编, r_Pati.联系人姓名, r_Pati.联系人关系, r_Pati.联系人地址, r_Pati.联系人电话, r_Pati.工作单位, 
                             r_Pati.合同单位id, r_Pati.单位电话, r_Pati.单位邮编, r_Pati.单位开户行, r_Pati.单位帐号, r_Pati.担保人, r_Pati.担保额, 
                             r_Pati.担保性质, 执行部门id_In, Null, Null, v_入院方式, Null, Null, r_Advice.开嘱医生, r_Pati.籍贯, r_Pati.区域, 
                             r_Advice.开始执行时间, Null, Null, r_Pati.医疗付款方式, Null, Null, Null, Null, Null, Null, r_Pati.险类, 
                             v_人员编号, v_人员姓名, 0, Null, Null, 0); 
          Else 
            Zl_入院病案主页_Insert(1, v_病人性质, r_Pati.病人id, r_Pati.住院号, Null, r_Pati.姓名, r_Pati.性别, r_Pati.年龄, r_Pati.费别, 
                             r_Pati.出生日期, r_Pati.国籍, r_Pati.民族, r_Pati.学历, r_Pati.婚姻状况, r_Pati.职业, r_Pati.身份, 
                             r_Pati.身份证号, r_Pati.出生地点, r_Pati.家庭地址, r_Pati.家庭地址邮编, r_Pati.家庭电话, r_Pati.户口地址, 
                             r_Pati.户口地址邮编, r_Pati.联系人姓名, r_Pati.联系人关系, r_Pati.联系人地址, r_Pati.联系人电话, r_Pati.工作单位, 
                             r_Pati.合同单位id, r_Pati.单位电话, r_Pati.单位邮编, r_Pati.单位开户行, r_Pati.单位帐号, r_Pati.担保人, r_Pati.担保额, 
                             r_Pati.担保性质, 执行部门id_In, Null, Null, v_入院方式, Null, Null, r_Advice.开嘱医生, r_Pati.籍贯, r_Pati.区域, 
                             r_Advice.开始执行时间, Null, Null, r_Pati.医疗付款方式, Null, Null, Null, Null, Null, Null, r_Pati.险类, 
                             v_人员编号, v_人员姓名, 0, Null, Null, 0); 
          End If; 
          Close c_Pati; 
        End If; 
      End If; 
    End If; 
  End If; 
  Close c_Advice; 
 
  --填写发送记录 
  --------------------------------------------------------------------------------------- 
  Insert Into 病人医嘱发送 
    (医嘱id, 发送号, 记录性质, NO, 记录序号, 发送数次, 发送人, 发送时间, 执行状态, 执行部门id, 计费状态, 首次时间, 末次时间, 样本条码, 门诊记帐) 
  Values 
    (医嘱id_In, 发送号_In, 记录性质_In, No_In, 记录序号_In, 发送数次_In, v_人员姓名, 发送时间_In, 执行状态_In, 执行部门id_In, 计费状态_In, 
     Nvl(首次时间_In, d_开始时间), Nvl(末次时间_In, d_开始时间), 样本条码_In, Decode(记录性质_In, 2, 1, Null)); 
     
  --手术和检查医嘱同步更新主医嘱的计费状态   
  If 计费状态_In = 1 And  r_Advice.组ID <> 医嘱id_In  And (r_Advice.诊疗类别 = 'D' Or r_Advice.诊疗类别 = 'F') Then   
     Update 病人医嘱发送 Set 计费状态 = 1 Where 医嘱ID = r_Advice.组ID And 发送号 = 发送号_In;
  End If;
  
  --自动填为已执行时，需要同步处理费用执行状态及审核划价状态 
  If 执行状态_In = 1 Then 
    Zl_病人医嘱执行_Finish(医嘱id_In, 发送号_In, Null, Null, v_人员编号, v_人员姓名, 执行部门id_In); 
  End If; 
  --消息推送 
  Begin 
    Execute Immediate 'Begin zl_服务窗消息_发送(:1,:2); End;' 
      Using 3, 发送号_In; 
  Exception 
    When Others Then 
      Null; 
  End; 
Exception 
  When Err_Custom Then 
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]'); 
  When Others Then 
    zl_ErrorCenter(SQLCode, SQLErrM); 
End Zl_门诊医嘱发送_Insert;
/


--102857:李业庆,2016-11-21,病人医嘱记录表医嘱ID字段错误问题
Create Or Replace Procedure Zl_输液配药记录_分批
(
  配药id_In       In Varchar2, --ID串:配药ID1,批次1:优先级|配药ID2,批次2....
  手工调整批次_In In Number := 0
) Is
  v_Tansid   Varchar2(20);
  v_批次     Varchar2(20);
  v_Tmp      Varchar2(4000);
  v_Fields   Varchar2(4000);
  n_优先级   输液配药记录.优先级%Type;
  d_执行时间 Date;
Begin
  If 配药id_In Is Null Then
    v_Tmp := Null;
  Else
    v_Tmp := 配药id_In || '|';
  End If;
  While v_Tmp Is Not Null Loop
    --分解单据ID串
    v_Fields := Substr(v_Tmp, 1, Instr(v_Tmp, '|') - 1);
    v_Tansid := Substr(v_Fields, 1, Instr(v_Fields, ',') - 1);
    v_批次   := Substr(v_Fields, Instr(v_Fields, ',') + 1, Instr(v_Fields, ':') - 1 - Instr(v_Fields, ','));
    n_优先级 := Substr(v_Fields, Instr(v_Fields, ':') + 1);
  
    v_Tmp := Replace('|' || v_Tmp, '|' || v_Fields || '|');
  
    Update 输液配药记录 Set 配药批次 = v_批次 Where ID = v_Tansid;
  
    If 手工调整批次_In = 1 Then
      Select 执行时间 Into d_执行时间 From 输液配药记录 Where ID = v_Tansid And Rownum < 2;
      Update 输液配药记录
      Set 手工调整批次 = 1
      Where 医嘱id In
            (Select Id
             From 病人医嘱记录
             Where 病人id =
                   (Select 病人id
                    From 病人医嘱记录
                    Where Id = (Select 医嘱id From 输液配药记录 Where ID = v_Tansid And Rownum < 2) And Rownum < 2)) And
            Trunc(执行时间) = Trunc(d_执行时间);
    End If;
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_输液配药记录_分批;
/

--103561:李业庆,2016-12-08,更新门诊记账单的费用记录的执行状态
Create Or Replace Procedure Zl_药品收发记录_批量发料
(
  收发id_In     In Varchar2, --格式:id1,批次1|id2,批次2|.....
  库房id_In     In 药品收发记录.库房id%Type,
  审核人_In     In 药品收发记录.审核人%Type,
  审核日期_In   In 药品收发记录.审核日期%Type,
  发料方式_In   In 药品收发记录.发药方式%Type := 3, --1-处方发料;2-批量发料;3-部门发料;-1 停止发料
  领料人_In     In 药品收发记录.领用人%Type := Null,
  发料标识号_In In 药品收发记录.汇总发药号%Type := Null,
  配料人_In     In 药品收发记录.配药人%Type := Null,
  审核人编码_In In 人员表.编号%Type := Null
) Is
  --只读变量
  Err_Item Exception;
  v_Err_Msg Varchar2(255);

  v_批号     药品收发记录.批号%Type;
  v_上次产地 药品库存.上次产地%Type;
  v_批准文号 药品库存.批准文号%Type;

  v_Loop_Str Varchar2(4000);
  v_Fields   Varchar2(4000);

  n_Id       药品收发记录.Id%Type;
  n_批次     药品收发记录.批次%Type;
  n_成本价   药品收发记录.成本价%Type;
  n_库房id   药品收发记录.库房id%Type;
  n_库存金额 药品库存.实际金额%Type;
  n_库存差价 药品库存.实际差价%Type;
  n_未发数   未发药品记录.未发数%Type;
  --可写变量
  n_成本金额 药品收发记录.成本金额%Type;
  n_实际差价 药品收发记录.差价%Type;
  n_可用数量 药品收发记录.填写数量%Type;
  n_批次_Cur 药品收发记录.批次%Type;
  n_实价卫材 收费项目目录.是否变价%Type;

  n_上次供应商id       药品库存.上次供应商id%Type;
  n_上次采购价         药品库存.上次采购价%Type;
  n_执行状态           Number;
  n_差价率             Number;
  n_收费与发料分离     Number(1);
  n_小数               Number(2);
  n_允许未审核处方发料 Number(2);
  n_序号               Number;

  d_效期                   药品收发记录.效期%Type;
  d_上次生产日期           药品库存.上次生产日期%Type;
  n_门诊标志               Number(1);
  v_入库no                 药品收发记录.No%Type;
  v_入库库房id             药品收发记录.库房id%Type := 0;
  v_病人信息               Varchar2(200);
  v_备货                   Number(1);
  v_允许未审核记账单发料   Number(1);
  v_允许未收费的划价单发料 Number(1);
  v_自动审核记账单         Number(1);
  n_平均成本价             药品库存.平均成本价%Type;
Begin
  --获取金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into n_小数 From Dual;
  
  select zl_GetSysParameter('允许未审核的记账处方发料') into v_允许未审核记账单发料  from dual;
  select zl_GetSysParameter('执行后自动审核划价单') into v_自动审核记账单  from dual;
  select zl_GetSysParameter('允许未收费的门诊划价处方发料') into v_允许未收费的划价单发料  from dual;

  If 收发id_In Is Null Then
    v_Loop_Str := Null;
  Else
    v_Loop_Str := 收发id_In || '|';
  End If;

  While v_Loop_Str Is Not Null Loop
    --分解单据ID串
    v_Fields   := Substr(v_Loop_Str, 1, Instr(v_Loop_Str, '|') - 1);
    n_Id       := Substr(v_Fields, 1, Instr(v_Fields, ',') - 1);
    n_批次     := Substr(v_Fields, Instr(v_Fields, ',') + 1);
    v_Loop_Str := Replace('|' || v_Loop_Str, '|' || v_Fields || '|');
  
    --检查相关操作
    v_Err_Msg := 'NO';
    For c_Check In (Select a.Id, a.单据, b.Id 费用id, a.No, b.No 费用no, b.病人id, Null 主页id, Null 病人病区id, b.病人科室id, b.开单部门id,
                           b.执行部门id, b.收入项目id, b.实收金额, b.操作员编号, b.操作员姓名, Nvl(b.记录状态, 0) As 审核标志, a.审核人,
                           Decode(Nvl(a.摘要, 'No拒发'), '拒发', 3, b.执行状态) 执行状态, 1 门诊标志
                    From 药品收发记录 A, 门诊费用记录 B
                    Where a.费用id = b.Id And a.Id = n_Id
                    Union All
                    Select a.Id, a.单据, b.Id 费用id, a.No, b.No 费用no, b.病人id, b.主页id, b.病人病区id, b.病人科室id, b.开单部门id, b.执行部门id,
                           b.收入项目id, b.实收金额, b.操作员编号, b.操作员姓名, Nvl(b.记录状态, 0) As 审核标志, a.审核人,
                           Decode(Nvl(a.摘要, 'No拒发'), '拒发', 3, b.执行状态) 执行状态, 2 门诊标志
                    From 药品收发记录 A, 住院费用记录 B
                    Where a.费用id = b.Id And a.Id = n_Id) Loop
      If Not (c_Check.审核人 Is Null) Then
        v_Err_Msg := '该处方[' || c_Check.No || ']已被其它操作员发料，操作被迫中止！';
        Raise Err_Item;
      End If;
      If Nvl(c_Check.执行状态, 0) = 3 Then
        v_Err_Msg := '该处方[' || c_Check.No || ']已拒发，操作被迫中止！';
        Raise Err_Item;
      End If;
    
      If Nvl(c_Check.审核标志, 0) = 0 And c_Check.单据 = 25 Then
        If v_允许未审核记账单发料 = 0 Then
          v_Err_Msg := '该处方[' || c_Check.No || ']还未审核，操作被迫中止！';
          Raise Err_Item;
        Else
          If v_自动审核记账单 = 1 Then
            --审核门诊和住院的单据
            If c_Check.操作员姓名 Is Null Then
              --审核门诊和住院的单据
              Zl_记帐记录_发料审核(c_Check.Id, c_Check.费用id, c_Check.费用no, c_Check.病人id, c_Check.主页id, c_Check.病人病区id,
                           c_Check.病人科室id, c_Check.开单部门id, c_Check.执行部门id, c_Check.收入项目id, c_Check.实收金额, 审核人编码_In,
                           审核人_In, c_Check.门诊标志, Null);
            Else
              --审核门诊和住院的单据
              Zl_记帐记录_发料审核(c_Check.Id, c_Check.费用id, c_Check.费用no, c_Check.病人id, c_Check.主页id, c_Check.病人病区id,
                           c_Check.病人科室id, c_Check.开单部门id, c_Check.执行部门id, c_Check.收入项目id, c_Check.实收金额, c_Check.操作员编号,
                           c_Check.操作员姓名, c_Check.门诊标志, Null);
            End If;
          End If;
        End If;
      End If;
    
      If Nvl(c_Check.审核标志, 0) = 0 And c_Check.单据 = 24 And v_允许未收费的划价单发料 = 0 Then
        v_Err_Msg := '该处方[' || c_Check.No || ']还未收费，操作被迫中止！';
        Raise Err_Item;
      End If;
    
      v_Err_Msg := 'Have';
    
      n_门诊标志 := c_Check.门诊标志;
    
    End Loop;
  
    If v_Err_Msg = 'NO' Then
      v_Err_Msg := '未找到指定单据,可能已经被其他操作员处理,操作被迫中止！';
      Raise Err_Item;
    End If;
  
    --获取该收发记录的单据、药品ID、库房ID,零售金额及实际数量、入出类别ID
    For c_收发 In (Select a.单据, a.No, a.药品id, a.库房id, a.费用id, a.零售价, Nvl(a.零售金额, 0) As 实际金额,
                        Nvl(a.实际数量, 0) * Nvl(a.付数, 1) As 实际数量, a.入出类别id, a.入出系数, Nvl(a.批次, 0) As 批次,
                        '[' || c.编码 || ']' || c.名称 As 名称, a.批号, a.效期, a.供药单位id, a.产地, a.生产日期, a.批准文号, a.商品条码, a.内部条码,
                        b.序号 As 费用序号
                 From 药品收发记录 A, 收费项目目录 C, 门诊费用记录 B
                 Where a.Id = n_Id And a.药品id = c.Id And a.费用id = b.Id
                 Union All
                 Select a.单据, a.No, a.药品id, a.库房id, a.费用id, a.零售价, Nvl(a.零售金额, 0) As 实际金额,
                        Nvl(a.实际数量, 0) * Nvl(a.付数, 1) As 实际数量, a.入出类别id, a.入出系数, Nvl(a.批次, 0) As 批次,
                        '[' || c.编码 || ']' || c.名称 As 名称, a.批号, a.效期, a.供药单位id, a.产地, a.生产日期, a.批准文号, a.商品条码, a.内部条码,
                        b.序号 As 费用序号
                 From 药品收发记录 A, 收费项目目录 C, 住院费用记录 B
                 Where a.Id = n_Id And a.药品id = c.Id And a.费用id = b.Id) Loop
      If Nvl(n_批次, 0) = 0 Then
        n_批次_Cur := c_收发.批次;
      Else
        n_批次_Cur := Nvl(n_批次, 0);
      End If;
    
      --检查是否已经填写库房
      n_收费与发料分离 := 0;
      If c_收发.库房id Is Null Then
        n_收费与发料分离 := 1;
      End If;
    
      n_库房id := 库房id_In;
      --取该批卫生材料的批号
      Begin
        Select 上次批号, 效期, Nvl(可用数量, 0), 上次供应商id, 上次产地, 上次生产日期, 批准文号, 上次采购价, Nvl(实际金额, 0) 实际金额, Nvl(实际差价, 0) 实际差价
        Into v_批号, d_效期, n_可用数量, n_上次供应商id, v_上次产地, d_上次生产日期, v_批准文号, n_上次采购价, n_库存金额, n_库存差价 
        From 药品库存
        Where 库房id + 0 = n_库房id And 药品id = c_收发.药品id And 性质 = 1 And Nvl(批次, 0) = n_批次_Cur;
      Exception
        When Others Then
          n_库存金额   := 0;
          n_库存差价   := 0;
          n_上次采购价 := 0;
          n_可用数量   := 0;
      End;
    
      Begin
        Select 1
        Into v_备货
        From 药品收发记录
        Where 单据 = 21 And 审核日期 Is Null And 药品id = c_收发.药品id And Nvl(批次, 0) = c_收发.批次 And 费用id = c_收发.费用id And
              Rownum = 1;
      Exception
        When Others Then
          v_备货 := 0;
      End;
    
      --可用数量不足则退出
      If n_批次_Cur <> Nvl(c_收发.批次, 0) Then
        If v_备货 = 0 And n_可用数量 < Nvl(c_收发.实际数量, 0) And n_批次_Cur <> 0 Then
          v_Err_Msg := c_收发.名称 || '的可用数量不足，操作中止！';
          Raise Err_Item;
        End If;
      End If;
    
      n_成本价   := Round(Zl_Fun_Getoutcost(c_收发.药品id, c_收发.批次, n_库房id), 7);
      n_成本金额 := Round(n_成本价 * c_收发.实际数量, n_小数);
      n_实际差价 := Round(c_收发.实际金额 - n_成本金额, n_小数);
    
      --更新药品收发记录的零售金额、成本金额及差价
      Update 药品收发记录
      Set 成本价 = n_成本价, 成本金额 = n_成本金额, 差价 = n_实际差价, 库房id = n_库房id, 批次 = n_批次_Cur, 批号 = v_批号, 效期 = d_效期, 配药人 = 配料人_In,
          审核人 = 审核人_In, 审核日期 = 审核日期_In, 发药方式 = 发料方式_In, 领用人 = 领料人_In, 汇总发药号 = 发料标识号_In, 供药单位id = n_上次供应商id, 产地 = v_上次产地,
          生产日期 = d_上次生产日期, 批准文号 = v_批准文号
      Where ID = n_Id;
    
      --并发操作检查
      If Sql%RowCount = 0 Then
        v_Err_Msg := '不存在相关的发料记录，材料信息为:' || c_收发.名称 || '，操作中止！';
        Raise Err_Item;
      End If;
    
      --更新费用记录的执行状态(已执行)
      Select Decode(Sum(Nvl(付数, 1) * 实际数量), Null, 1, 0, 1, 2)
      Into n_执行状态
      From 药品收发记录
      Where 单据 = c_收发.单据 And NO = c_收发.No And 费用id = c_收发.费用id And 审核人 Is Null And 记录状态 <> 1 And Mod(记录状态, 3) <> 0;
    
      If n_门诊标志 = 1 Then
        Update 门诊费用记录
        Set 执行状态 = n_执行状态, 执行部门id = 库房id_In, 执行人 = 审核人_In, 执行时间 = 审核日期_In
        Where NO = c_收发.No And (Mod(记录性质, 10) = 1 Or Mod(记录性质, 10) = 2) And 记录状态 <> 2 And 序号 = c_收发.费用序号;
      Else
        Update 住院费用记录
        Set 执行状态 = n_执行状态, 执行部门id = 库房id_In, 执行人 = 审核人_In, 执行时间 = 审核日期_In
        Where ID = c_收发.费用id;
      End If;
    
      --更新未发药品记录(如果未发数为零则删除)
      Select Count(*)
      Into n_未发数
      From 药品收发记录
      Where 单据 = c_收发.单据 And NO = c_收发.No And 审核人 Is Null And (库房id + 0 = n_库房id Or 库房id Is Null) And
            Nvl(LTrim(RTrim(摘要)), 'No_拒发') <> '拒发';
    
      If n_未发数 = 0 Then
        Delete 未发药品记录 Where 单据 = c_收发.单据 And NO = c_收发.No And (库房id + 0 = n_库房id Or 库房id Is Null);
      End If;
    
      Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = c_收发.药品id;
    
      --更新原批次库存的可用数量
      --更新发料批次库存的可用及实际数量
      If c_收发.批次 <> n_批次_Cur Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) + c_收发.实际数量,
            零售价 = Decode(n_实价卫材, 1, Decode(Nvl(c_收发.批次, 0), 0, Null, Decode(Nvl(零售价, 0), 0, c_收发.零售价, 零售价)), Null)
        Where 性质 = 1 And 库房id + 0 = n_库房id And 药品id = c_收发.药品id And Nvl(批次, 0) = c_收发.批次;
      
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - c_收发.实际数量,
            零售价 = Decode(n_实价卫材, 1, Decode(Nvl(n_批次_Cur, 0), 0, Null, Decode(Nvl(零售价, 0), 0, c_收发.零售价, 零售价)), Null)
        Where 性质 = 1 And 库房id + 0 = n_库房id And 药品id = c_收发.药品id And Nvl(批次, 0) = n_批次_Cur;
      End If;
    
      If n_收费与发料分离 = 1 Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - c_收发.实际数量, 实际数量 = Nvl(实际数量, 0) - c_收发.实际数量, 实际金额 = Nvl(实际金额, 0) - c_收发.实际金额,
            实际差价 = Nvl(实际差价, 0) - n_实际差价,
            零售价 = Decode(n_实价卫材, 1, Decode(Nvl(n_批次_Cur, 0), 0, Null, Decode(Nvl(零售价, 0), 0, c_收发.零售价, 零售价)), Null)
        Where 库房id + 0 = n_库房id And 药品id = c_收发.药品id And 性质 = 1 And Nvl(批次, 0) = n_批次_Cur;
      Else
        Update 药品库存
        Set 实际数量 = Nvl(实际数量, 0) - c_收发.实际数量, 实际金额 = Nvl(实际金额, 0) - c_收发.实际金额, 实际差价 = Nvl(实际差价, 0) - n_实际差价,
            零售价 = Decode(n_实价卫材, 1, Decode(Nvl(n_批次_Cur, 0), 0, Null, Decode(Nvl(零售价, 0), 0, c_收发.零售价, 零售价)), Null)
        Where 库房id + 0 = n_库房id And 药品id = c_收发.药品id And 性质 = 1 And Nvl(批次, 0) = n_批次_Cur;
      End If;
    
      If Sql%RowCount = 0 Then
        If n_上次采购价 = 0 Then
          If Nvl(c_收发.实际数量, 0) = 0 Then
            n_上次采购价 := Round(n_成本金额, 5);
          Else
            n_上次采购价 := Round(n_成本金额 / c_收发.实际数量, 5);
          End If;
        
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次批号, 上次产地, 上次供应商id, 上次采购价, 上次生产日期, 批准文号, 效期, 零售价, 商品条码, 内部条码,
             平均成本价)
          Values
            (n_库房id, c_收发.药品id, n_批次_Cur, 1, 0 - c_收发.实际数量, 0 - c_收发.实际数量, 0 - c_收发.实际金额, 0 - n_实际差价, v_批号, v_上次产地,
             n_上次供应商id, n_上次采购价, d_上次生产日期, v_批准文号, d_效期,
             Decode(n_实价卫材, 1, Decode(Nvl(n_批次_Cur, 0), 0, Null, c_收发.零售价), Null), c_收发.商品条码, c_收发.内部条码, n_上次采购价);
        End If;
      
      End If;
      Delete 药品库存
      Where 性质 = 1 And 库房id + 0 = n_库房id And 药品id = c_收发.药品id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And
            Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0;
    
      If v_备货 = 1 Then
        --审核备货卫材在虚拟库房的其他出库单据
        For v_出库 In (Select 序号, NO, 库房id, 药品id, Nvl(批次, 0) As 批次, 实际数量, 成本价, 成本金额, 零售金额, 差价, 入出类别id
                     From 药品收发记录
                     Where 单据 = 21 And 审核日期 Is Null And 药品id = c_收发.药品id And Nvl(批次, 0) = c_收发.批次 And 费用id = c_收发.费用id) Loop
        
          Update 药品收发记录
          Set 汇总发药号 = n_Id
          Where 单据 = 21 And 审核日期 Is Null And 药品id = c_收发.药品id And Nvl(批次, 0) = c_收发.批次 And 费用id = c_收发.费用id;
        
          Zl_材料其他出库_Verify(v_出库.序号, v_出库.No, v_出库.库房id, v_出库.药品id, v_出库.批次, v_出库.实际数量, v_出库.成本价, v_出库.成本金额, v_出库.零售金额,
                           v_出库.差价, v_出库.入出类别id, 审核人_In, 审核日期_In);
        End Loop;
      
        --产生备货卫材在卫材仓库的外购入库单据
        For v_入库 In (Select NO, 序号, 供药单位id, 药品id, 产地, 批号, 生产日期, 效期, 灭菌日期, 灭菌效期, 实际数量, 成本价, 成本金额, 扣率, 零售价, 零售金额, 差价, 摘要,
                            注册证号, Nvl(批次, 0) As 批次, 商品条码, 内部条码
                     From 药品收发记录
                     Where 单据 = 21 And 审核日期 Is Not Null And 药品id = c_收发.药品id And Nvl(批次, 0) = c_收发.批次 And
                           费用id = c_收发.费用id And 汇总发药号 = n_Id) Loop
          Begin
            Select 库房id Into v_入库库房id From 虚拟库房对照 Where 科室id = c_收发.库房id;
          Exception
            When Others Then
              v_入库库房id := 0;
          End;
        
          If v_入库库房id > 0 Then
          
            --同一张发料单产生的入库单的NO要一致
            Select Max(NO), Max(序号) + 1
            Into v_入库no, n_序号
            From 药品收发记录
            Where 单据 = 15 And 审核日期 Is Null And 供药单位id = v_入库.供药单位id And
                  费用id In
                  (Select Distinct 费用id
                   From 药品收发记录
                   Where 单据 = 21 And 审核日期 Is Not Null And
                         NO = (Select Distinct NO
                               From 药品收发记录
                               Where 单据 = 21 And 审核日期 Is Not Null And 费用id = c_收发.费用id And 汇总发药号 = n_Id));
          
            If v_入库no Is Null Or v_入库no = '' Then
              --如果入库NO为Null, 产生新的入库单NO
              v_入库no := Nextno(68, v_入库库房id);
              n_序号   := 1;
            End If;
          
            Begin
              If n_门诊标志 = 1 Then
                Select b.名称 || ',' || a.姓名 || ',' || a.标识号 || ',' || '' As 病人信息
                Into v_病人信息
                From 门诊费用记录 A, 部门表 B
                Where a.病人科室id = b.Id And a.Id = c_收发.费用id;
              Else
                Select b.名称 || ',' || a.姓名 || ',' || a.标识号 || ',' || a.床号 As 病人信息
                Into v_病人信息
                From 住院费用记录 A, 部门表 B
                Where a.病人科室id = b.Id And a.Id = c_收发.费用id;
              End If;
            Exception
              When Others Then
                v_病人信息 := '';
            End;
          
            Zl_材料外购_Insert(v_入库no, n_序号, v_入库库房id, v_入库.供药单位id, v_入库.药品id, v_入库.产地, v_入库.批号, v_入库.生产日期, v_入库.效期,
                           v_入库.灭菌日期, v_入库.灭菌效期, v_入库.实际数量, v_入库.成本价, v_入库.成本金额, v_入库.扣率, v_入库.零售价, v_入库.零售金额, v_入库.差价,
                           Null, '【自动入账】' || v_入库.摘要, v_入库.注册证号, 审核人_In, Null, Null, Null, Null, 审核日期_In, Null, Null,
                           v_入库.批次, 1, v_病人信息, v_入库.商品条码, v_入库.内部条码, c_收发.费用id);
          End If;
        End Loop;
      End If;
    End Loop;
    --修正误差数据
    Zl_材料收发记录_调价修正(n_Id);
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_批量发料;
/

--103653:李业庆,2016-12-09,只有批次大于0的才插入批号对照表
Create Or Replace Function Zl_Fun_Getbatchnum
(
  药品id_In   药品批号对照.药品id%Type,
  生产厂家_In 药品批号对照.生产厂家%Type,
  批号_In     药品批号对照.批号%Type,
  成本价_In   药品批号对照.成本价%Type,
  售价_In     药品批号对照.售价%Type,
  新批次_In   药品批号对照.批次%Type
) Return Number Is
  --功能：药品入库产生入库记录时根据传递过来的参数找对应的批次
  --返回值：查询到的批次，如果批次>0则说明找到了批次,如果批次=0则说明没有找到
  --参数：
  --     生产厂家_in：入库传递过来的生产商
  --     批号_in：入库时录入的批号
  --     成本价_in 入库时的成本价
  --     售价_in  入库时的售价
  --     
  n_批次     药品批号对照.批次%Type;
  n_药库包装 药品规格.药库包装%Type;
  n_是否变价 收费项目目录.是否变价%Type;
Begin
  --只处理生产厂家和批号不为空的情况
  If 生产厂家_In Is Not Null And 批号_In Is Not Null Then
    Begin
      Select 批次
      Into n_批次
      From 药品批号对照
      Where 药品id = 药品id_In And Nvl(生产厂家, 'a') = Nvl(生产厂家_In, 'a') And Nvl(批号, 'b') = Nvl(批号_In, 'b') And 成本价 = 成本价_In And
            售价 = 售价_In;
    Exception
      When Others Then
        n_批次 := 新批次_In;
      
        If n_批次 > 0 Then
          Insert Into 药品批号对照
            (药品id, 生产厂家, 批号, 批次, 成本价, 售价)
          Values
            (药品id_In, 生产厂家_In, 批号_In, 新批次_In, 成本价_In, 售价_In);
        End If;
    End;
  End If;

  Return(n_批次);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Fun_Getbatchnum;
/
--106685:余伟节,2017-03-02,15位身份证号反算出生日期
--104221:余伟节,2016-12-22,身份证号码合法性校验,并返回身份证号的出生日期、性别、年龄
Create Or Replace Function Zl_Fun_Checkidcard(Idcard_In In Varchar2) Return Varchar2 Is
  -------------------------------------------------------------------------------
  --功能：身份证号码合法性校验,并返回身份证号的出生日期、性别、年龄
  --参数说明:
  -- 入参 IDcard_In:身份证号码
  -- 返回值：固定格式XML串
  --<OUTPUT>
  --       <BIRTHDAY></BIRTHDAY>                //出生日期
  --       <SEX></SEX>                  //性别
  --       <AGE></AGE>                //年龄
  --     <MSG></MSG>         //空串-身份证号有效(可从身份证号中获取出生日期和性别)，非空串-返回错误信息
  --</OUTPUT>
  -------------------------------------------------------------------------------
  n_Count     Number(5);
  n_Sum       Number(5);
  v_校验位    Varchar2(50);
  v_Pattern   Varchar2(500);
  v_Err_Msg   Varchar2(2000);
  v_性别      Varchar2(100);
  v_年龄      Varchar2(100);
  d_Curr_Time Date;
  d_出生日期  Date;

Begin
  Select Sysdate Into d_Curr_Time From Dual;

  If Idcard_In Is Null Then
    v_Err_Msg := '传人身份证号为空!';
    Return '<OUTPUT><BIRTHDAY></BIRTHDAY><SEX></SEX><AGE></AGE><MSG>' || v_Err_Msg || '</MSG></OUTPUT>';
  Else
    --身份证合法验证
    v_Pattern := '11,12,13,14,15,21,22,23,31,32,33,34,35,36,37,41,42,43,44,45,46,50,51,52,53,54,61,62,63,64,65,71,81,82,91';
    --地区检验
    If Instr(v_Pattern, Substr(Idcard_In, 1, 2)) = 0 Then
      v_Err_Msg := '身份证前两位地区码不正确!';
      Return '<OUTPUT><BIRTHDAY></BIRTHDAY><SEX></SEX><AGE></AGE><MSG>' || v_Err_Msg || '</MSG></OUTPUT>';
    End If;
    --身份证长度检查
    If Length(Idcard_In) = 15 Then
      --检查身份证号:15位身份证号要求全部为数字
      v_Pattern := '^\d{15}$';
      Select Count(1) Into n_Count From Dual Where Regexp_Like(Idcard_In, v_Pattern);
      If n_Count = 0 Then
        v_Err_Msg := '身份证中包含非法字符，请检查!';
        Return '<OUTPUT><BIRTHDAY></BIRTHDAY><SEX></SEX><AGE></AGE><MSG>' || v_Err_Msg || '</MSG></OUTPUT>';
      End If;
      --获取性别
      If Mod(To_Number(Substr(Idcard_In, 15, 1)), 2) = 1 Then
        v_性别 := '男';
      Else
        v_性别 := '女';
      End If;
      --出生日期的合法性检查
      v_Pattern := '^19[0-9]{2}((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|[1-2][0-9]))$';
      Select Count(1) Into n_Count From Dual Where Regexp_Like('19' || Substr(Idcard_In, 7, 6), v_Pattern);
      If n_Count = 0 Then
        v_Err_Msg := '身份证中的出生日期无效，请检查!';
        Return '<OUTPUT><BIRTHDAY></BIRTHDAY><SEX></SEX><AGE></AGE><MSG>' || v_Err_Msg || '</MSG></OUTPUT>';
      Else
        d_出生日期 := To_Date('19' || Substr(Idcard_In, 7, 6), 'yyyy-mm-dd');
        If d_出生日期 > To_Date(To_Char(d_Curr_Time, 'YYYY-MM-DD'), 'YYYY-MM-dd') Then
          v_Err_Msg := '身份证中的出生日期无效，请检查!';
          Return '<OUTPUT><BIRTHDAY></BIRTHDAY><SEX></SEX><AGE></AGE><MSG>' || v_Err_Msg || '</MSG></OUTPUT>';
        End If;
      End If;
    Elsif Length(Idcard_In) = 18 Then
      -- 18 位身份证号前17 位全部为数字，最后1位可为数字或x
      v_Pattern := '^\d{17}[0-9Xx]$';
      Select Count(1) Into n_Count From Dual Where Regexp_Like(Idcard_In, v_Pattern);
      If n_Count = 0 Then
        v_Err_Msg := '身份证中包含非法字符!';
        Return '<OUTPUT><BIRTHDAY></BIRTHDAY><SEX></SEX><AGE></AGE><MSG>' || v_Err_Msg || '</MSG></OUTPUT>';
      End If;
      --获取性别
      If Mod(To_Number(Substr(Idcard_In, 17, 1)), 2) = 1 Then
        v_性别 := '男';
      Else
        v_性别 := '女';
      End If;
      --出生日期的合法性检查
      v_Pattern := '^(1[6-9]|[2-9][0-9])[0-9]{2}((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|[1-2][0-9]))$';
      Select Count(1) Into n_Count From Dual Where Regexp_Like(Substr(Idcard_In, 7, 8), v_Pattern);
      If n_Count = 0 Then
        v_Err_Msg := '身份证中的出生日期无效，请检查!';
        Return '<OUTPUT><BIRTHDAY></BIRTHDAY><SEX></SEX><AGE></AGE><MSG>' || v_Err_Msg || '</MSG></OUTPUT>';
      Else
        d_出生日期 := To_Date(Substr(Idcard_In, 7, 8), 'yyyy-mm-dd');
        If d_出生日期 > To_Date(To_Char(d_Curr_Time, 'YYYY-MM-DD'), 'YYYY-MM-dd') Then
          v_Err_Msg := '身份证中的出生日期无效，请检查!';
          Return '<OUTPUT><BIRTHDAY></BIRTHDAY><SEX></SEX><AGE></AGE><MSG>' || v_Err_Msg || '</MSG></OUTPUT>';
        End If;
        --计算校验位
        n_Sum     := (To_Number(Substr(Idcard_In, 1, 1)) + To_Number(Substr(Idcard_In, 11, 1))) * 7 +
                     (To_Number(Substr(Idcard_In, 2, 1)) + To_Number(Substr(Idcard_In, 12, 1))) * 9 +
                     (To_Number(Substr(Idcard_In, 3, 1)) + To_Number(Substr(Idcard_In, 13, 1))) * 10 +
                     (To_Number(Substr(Idcard_In, 4, 1)) + To_Number(Substr(Idcard_In, 14, 1))) * 5 +
                     (To_Number(Substr(Idcard_In, 5, 1)) + To_Number(Substr(Idcard_In, 15, 1))) * 8 +
                     (To_Number(Substr(Idcard_In, 6, 1)) + To_Number(Substr(Idcard_In, 16, 1))) * 4 +
                     (To_Number(Substr(Idcard_In, 7, 1)) + To_Number(Substr(Idcard_In, 17, 1))) * 2 +
                     To_Number(Substr(Idcard_In, 8, 1)) * 1 + To_Number(Substr(Idcard_In, 9, 1)) * 6 +
                     To_Number(Substr(Idcard_In, 10, 1)) * 3;
        n_Count   := Mod(n_Sum, 11);
        v_Pattern := '10X98765432';
        v_校验位  := Substr(v_Pattern, n_Count + 1, 1);
        If v_校验位 <> Upper(Substr(Idcard_In, 18, 1)) Then
          v_Err_Msg := '身份证号码不正确，请检查。';
          Return '<OUTPUT><BIRTHDAY></BIRTHDAY><SEX></SEX><AGE></AGE><MSG>' || v_Err_Msg || '</MSG></OUTPUT>';
        End If;
      End If;
    Else
      v_Err_Msg := '身份证长度不对,请检查。';
      Return '<OUTPUT><BIRTHDAY></BIRTHDAY><SEX></SEX><AGE></AGE><MSG>' || v_Err_Msg || '</MSG></OUTPUT>';
    End If;
    v_年龄 := Zl_Age_Calc(0, d_出生日期, d_Curr_Time);
  End If;

  Return '<OUTPUT><BIRTHDAY>' || To_Char(d_出生日期, 'YYYY-MM-DD') || '</BIRTHDAY><SEX>' || v_性别 || '</SEX><AGE>' || v_年龄 || '</AGE><MSG></MSG></OUTPUT>';
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Fun_Checkidcard;
/

--104833:李业庆,2017-01-09,售价调价策略调整
--99679:李业庆,2017-02-22,金额差和差价差算法改为一致，金额位数按流通金额参数设置确定
--105044:李业庆,2017-02-24,价格用最大精度取值和计算，金额差和差价差算法改为一致，时价直接比较价格
--106523:李业庆,2017-03-05,退药再发药时处理调价修正
Create Or Replace Procedure Zl_药品收发记录_调价修正(收发id_In In 药品收发记录.Id%Type) Is
  v_单据         药品收发记录.单据%Type;
  v_入出类别id   药品收发记录.入出类别id%Type;
  v_售价精度     Number;
  v_金额精度     Number;
  v_收发id       药品收发记录.Id%Type;
  v_原价         药品收发记录.零售价%Type;
  v_现价         药品收发记录.零售价%Type;
  v_是否变价     收费项目目录.是否变价%Type;
  v_价格id       收费价目.Id%Type;
  v_库房id       药品收发记录.库房id%Type;
  v_药品id       药品收发记录.药品id%Type;
  v_批次         药品收发记录.批次%Type;
  v_实际数量     药品收发记录.实际数量%Type;
  v_修正金额     药品收发记录.零售金额%Type;
  v_入出系数     药品收发记录.入出系数%Type;
  v_执行修正     Number;
  v_填制日期     药品收发记录.填制日期%Type;
  v_审核日期     药品收发记录.审核日期%Type;
  d_调价时间     收费价目.执行日期%Type;
  v_零售金额     药品收发记录.零售金额%Type;
  v_差价         药品收发记录.差价%Type;
  v_No           药品收发记录.No%Type;
  n_记录状态     药品收发记录.记录状态%Type;
  n_当前数量     药品库存.实际数量%Type;
  n_是否门诊记录 Number;
  n_价目表售价   药品收发记录.零售价%Type;
Begin
  ----售价：
  --定价和时价分批：判断在此期间有无主动调价，有则修正，无则不修正
  --时价不分批：直接比较价格
  --要修正时：判断当前价格与冲销价格是否不同，不同则处理否则不处理
  --          时价无库存不修正，因为取不出价格

  ----成本价：
  --有调价记录则修正，无调价检查库存与冲销价格是否不同，不同则修正，否则不修正

  --取原始单据的审核时间
  Select a.审核日期, a.填制日期
  Into v_审核日期, v_填制日期
  From 药品收发记录 A, 药品收发记录 B
  Where b.Id = 收发id_In And a.单据 = b.单据 And a.No = b.No And a.库房id = b.库房id And a.药品id + 0 = b.药品id And a.序号 = b.序号 And
        (a.记录状态 = 1 Or Mod(a.记录状态, 3) = 0);

  --1、售价调价处理
  --提取单据信息，原价，现价及药价属性
  Select a.单据, a.记录状态, a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, a.入出系数 * Nvl(a.实际数量, 0) * Nvl(a.付数, 1) As 实际数量,
         Nvl(a.零售价, 0) 原价, b.现价, Nvl(c.是否变价, 0) 是否变价, b.Id As 价格id, b.执行日期
  Into v_单据, n_记录状态, v_库房id, v_药品id, v_批次, v_实际数量, v_原价, v_现价, v_是否变价, v_价格id, d_调价时间
  From 药品收发记录 A, 收费价目 B, 收费项目目录 C
  Where a.药品id = b.收费细目id And a.药品id = c.Id And
        (Sysdate Between b.执行日期 And b.终止日期 Or Sysdate >= b.执行日期 And b.终止日期 Is Null) And a.Id = 收发id_In;

  v_执行修正 := 0;
  If v_是否变价 = 0 Then
    --定价，单据原始时间在最新调价时间后，需要执行调价修正
    If v_单据 = 8 Or v_单据 = 9 Or v_单据 = 10 Then
      --发药单看填制日期
      If v_填制日期 < d_调价时间 Then
        v_执行修正 := 1;
      End If;
    Elsif v_审核日期 < d_调价时间 Then
      --其他流通单据看审核时间
      v_执行修正 := 1;
    End If;
  Else
    --时价主要比较新老价格，这里不判断
    v_执行修正 := 1;
  End If;

  If v_执行修正 = 1 Then
    If v_是否变价 = 1 Then
      --时价从库存记录中取现价
      Begin
        Select Nvl(零售价, 0)
        Into v_现价
        From 药品库存
        Where 性质 = 1 And 库房id + 0 = v_库房id And 药品id = v_药品id And Nvl(批次, 0) = v_批次;
      Exception
        When Others Then
          --时价如果无库存则不进行修正
          v_现价     := 0;
          v_执行修正 := 0;
      End;
    End If;
  
    If v_执行修正 = 1 Then
      Select 精度 Into v_金额精度 From 药品卫材精度 Where 类别 = 1 And 内容 = 4 And 单位 = 5 And 性质 = 0;
    
      --比较原价和现价，不同则处理
      If Round(v_原价, 4) <> Round(v_现价, 4) Then
        v_修正金额 := Round(v_现价 * v_实际数量, v_金额精度) - Round(v_原价 * v_实际数量, v_金额精度);
      
        If v_修正金额 <> 0 Then
          Select 药品收发记录_Id.Nextval Into v_收发id From Dual;
          Select Nextno(147) Into v_No From Dual;
        
          Select 类别id Into v_入出类别id From 药品单据性质 Where 单据 = 13;
        
          --产生调价修正记录
          Insert Into 药品收发记录
            (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 零售金额, 差价, 摘要, 填制人,
             填制日期, 库房id, 入出系数, 价格id, 审核人, 审核日期, 费用id)
            Select v_收发id, 1, 13, v_No, 序号, v_入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, v_实际数量, 0, v_原价, 0, v_现价, 扣率, v_修正金额,
                   v_修正金额, '自动修正调价变动', 审核人, 审核日期, 库房id, 1, v_价格id, 审核人, 审核日期, 收发id_In
            From 药品收发记录
            Where ID = 收发id_In;
        
          --更新药品库存
          Zl_药品库存_Update(v_收发id, 2, 0);
        End If;
      End If;
    End If;
  End If;

  --2、成本价调价，发药单退药再发和冲销业务才修正
  v_执行修正 := 0;
  If (v_单据 In (8, 9, 10) And Mod(n_记录状态, 3) = 1 And n_记录状态 <> 1) Or Mod(n_记录状态, 3) = 2 Then
    Select 库房id, 药品id, Nvl(批次, 0) 批次, 入出系数 * Nvl(实际数量, 0) * Nvl(付数, 1) As 实际数量, 入出系数 * 零售金额, 入出系数 * 差价,
           Decode(单据, 12, 单量, 成本价) As 原价
    Into v_库房id, v_药品id, v_批次, v_实际数量, v_零售金额, v_差价, v_原价
    From 药品收发记录
    Where ID = 收发id_In;
  
    --冲销时取当前库存成本价
    Begin
      Select 1, 平均成本价, Nvl(实际数量, 0) As 实际数量
      Into v_执行修正, v_现价, n_当前数量
      From 药品库存
      Where 库房id = v_库房id And 药品id = v_药品id And Nvl(批次, 0) = v_批次 And 性质 = 1;
    Exception
      When Others Then
        v_现价     := 0;
        v_执行修正 := 0;
    End;
  
    If v_执行修正 = 1 And Round(v_现价, 4) <> Round(v_原价, 4) Then
      Select 精度 Into v_金额精度 From 药品卫材精度 Where 类别 = 1 And 内容 = 4 And 单位 = 5 And 性质 = 0;
    
      v_修正金额 := Round(v_原价 * v_实际数量, v_金额精度) - Round(v_现价 * v_实际数量, v_金额精度);
    
      If v_修正金额 <> 0 Then
        Select 药品收发记录_Id.Nextval Into v_收发id From Dual;
        Select b.Id, b.系数
        Into v_入出类别id, v_入出系数
        From 药品单据性质 A, 药品入出类别 B
        Where a.类别id = b.Id And a.单据 = 5 And Rownum < 2;
      
        v_No := Nextno(25, v_库房id);
      
        --产生库存差价调整单
        Insert Into 药品收发记录
          (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 供药单位id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 零售价, 成本价, 差价, 摘要, 填制人, 填制日期,
           审核人, 审核日期, 生产日期, 批准文号, 单量, 发药方式, 扣率, 灭菌效期, 费用id)
          Select v_收发id, 1, 5, v_No, 1, 库房id, v_入出类别id, 供药单位id, v_入出系数, 药品id, 批次, 产地, 批号, 效期, v_实际数量, v_零售金额, v_差价,
                 v_修正金额, '自动修正调价变动', 审核人, 审核日期, 审核人, 审核日期, 生产日期, 批准文号, v_现价, 1, 成本价, 灭菌效期, 收发id_In
          From 药品收发记录
          Where ID = 收发id_In;
      
        --更新库存
        Zl_药品库存_Update(v_收发id, 2, 0);
      
      End If;
    End If;
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_调价修正;
/

--104843:李业庆,2017-01-09,入库时库房分批药品不重算价格
--105044:李业庆,2017-02-24,冲销时如果无库存则用最新价格保存库存数据
Create Or Replace Procedure Zl_药品库存_Update
(
  Id_In       In 药品收发记录.Id%Type,
  业务类型_In In Number := 0,
  入出类型_In In Number := 0,
  财务审核_In In Number := 0
) Is
  --功能：
  --      根据业务类型处理库存表，处理业务药品所有业务和卫材发料业务，卫材内部流通业务不处理
  --id_in  需要处理收发记录单
  --业务类型_in  业务类型，0-新增、1-删除、2-审核、3-冲销
  --入出类型_in  0-入库，1-出库
  --财务审核_in  0-不是财务审核，1-财务审核，目前只有外购入库有财务审核

  n_可用数量 药品库存.实际数量%Type;
  n_实际数量 药品库存.实际数量%Type;
  n_零售金额 药品库存.实际金额%Type;
  n_差价     药品库存.实际差价%Type;
  n_时价     Number(1);
  n_成本价   药品收发记录.成本价%Type;
  n_零售价   药品库存.零售价%Type;

  n_库存数量   药品库存.实际数量%Type;
  n_库存平均价 药品库存.平均成本价%Type;
  n_库存售价   药品库存.零售价%Type;
  n_总数量     药品收发记录.实际数量%Type;
  n_总成本价   药品收发记录.成本价%Type;
  n_总售价     药品收发记录.零售价%Type;
  n_库房分批   药品规格.药库分批%Type;
  n_申请冲销   Number(1);
  n_更新库存   Number(1) := 0;
  v_现价       药品收发记录.零售价%Type;
  v_执行新价格 Number(1) := 0;
  n_有库存     Number(1) := 0;
  v_审核日期   药品收发记录.审核日期%Type;
  --业务明细数据，把库存数据更新需要的数据都列出来
  Cursor c_Detail Is
    Select a.Id, a.记录状态, a.单据, a.No, a.序号, a.库房id, a.供药单位id, a.入出类别id, a.对方部门id, a.入出系数, Nvl(a.发药方式, 0) As 发药方式, a.药品id,
           Nvl(a.批次, 0) 批次, a.产地, a.批号, a.生产日期, a.效期, a.付数, Nvl(a.填写数量, 0) As 填写数量, a.实际数量, a.成本价, a.成本金额, a.扣率, a.零售价,
           Nvl(a.零售金额, 0) As 零售金额, Nvl(a.差价, 0) As 差价, a.配药人, a.配药日期, a.审核人, a.审核日期, a.灭菌日期, a.灭菌效期, a.批准文号, a.商品条码,
           a.内部条码, b.是否变价, a.单量, a.频次, a.摘要, Nvl(a.费用id, 0) As 费用id
    From 药品收发记录 A, 收费项目目录 B
    Where a.药品id = b.Id And a.Id = Id_In;

  r_Detail c_Detail%RowType;
Begin
  For r_Detail In c_Detail Loop
    n_实际数量 := r_Detail.入出系数 * r_Detail.实际数量 * Nvl(r_Detail.付数, 1);
    If n_实际数量 Is Null Then
      n_实际数量 := 0;
    End If;
    n_可用数量 := 0;
    n_零售价   := r_Detail.零售价;
    If r_Detail.单据 = 12 Then
      n_成本价 := r_Detail.单量;
    Else
      n_成本价 := r_Detail.成本价;
    End If;
    n_零售金额 := r_Detail.入出系数 * r_Detail.零售金额;
    n_差价     := r_Detail.入出系数 * r_Detail.差价;
  
    --先取库存和单据的数量和成本价
    Begin
      Select Nvl(实际数量, 0), Nvl(平均成本价, 0), Decode(Nvl(零售价, 0), 0, Decode(Nvl(实际数量, 0), 0, n_零售价, 实际金额 / 实际数量), 零售价)
      Into n_库存数量, n_库存平均价, n_库存售价
      From 药品库存
      Where 性质 = 1 And 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次;
    Exception
      When Others Then
        n_库存数量   := 0;
        n_库存平均价 := 0;
        n_库存售价   := 0;
    End;
  
    --时价药品都需要更新库存表零售价字段
    If r_Detail.是否变价 = 1 Then
      n_时价 := 1;
    Else
      n_时价 := 0;
    End If;
  
    --特殊业务处理库存
    --包含业务--5-差价调整；13-调价变动
    --单据5，13都是业务类型_in，2-审核、入出类型_in  0-入库
    If r_Detail.单据 = 5 Or r_Detail.单据 = 13 Then
      --这种类型的单据收发记录成本价字段不是保存的真正成本价而是存储的其他数据
      If r_Detail.单据 = 5 Then
        If r_Detail.填写数量 <> 0 Then
          n_零售价 := Nvl(r_Detail.零售价, 0) / r_Detail.填写数量;
        Else
          n_零售价 := 0;
        End If;
        --审核
        If r_Detail.记录状态 = 1 Then
          --差价调整发药方式=0；主动调价、退货、发药产生的调价修正发药方式=1
          n_成本价 := r_Detail.单量;
        Else
          --冲销 还原原始成本价
          Begin
            --成本价=(金额-差价)/数量
            n_成本价 := (Nvl(r_Detail.零售价, 0) - Nvl(r_Detail.成本价, 0)) / r_Detail.填写数量;
          Exception
            When Others Then
              Select 成本价 Into n_成本价 From 药品规格 Where 药品id = r_Detail.药品id;
          End;
        End If;
      Else
        n_成本价 := Nvl(r_Detail.单量, 0) - Nvl(r_Detail.频次, 0);
      End If;
    
      If r_Detail.单据 = 5 Then
        --单据=5 的成本价修正记录 平均成本价不需要重算，因为保存了最新价格的
        If r_Detail.摘要 = '外购退库差价误差自动修正' Or r_Detail.摘要 = '财务审核价格变动修正' Then
          --这一步肯定是外购退库，外购退库只更新成本价,且肯定有库存
          Update 药品库存
          Set 实际差价 = Nvl(实际差价, 0) + n_差价
          Where 性质 = 1 And 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次;
        Else
          Update 药品库存
          Set 平均成本价 = n_成本价, 上次采购价 = n_成本价, 实际金额 = Nvl(实际金额, 0) + n_零售金额, 实际差价 = Nvl(实际差价, 0) + n_差价
          Where 性质 = 1 And 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次;
          If Sql%NotFound Then
            Insert Into 药品库存
              (库房id, 药品id, 批次, 性质, 实际差价, 上次批号, 效期, 上次产地, 上次供应商id, 上次生产日期, 批准文号, 实际金额, 上次采购价, 平均成本价)
            Values
              (r_Detail.库房id, r_Detail.药品id, r_Detail.批次, 1, n_差价, r_Detail.批号, r_Detail.效期, r_Detail.产地,
               r_Detail.供药单位id, r_Detail.生产日期, r_Detail.批准文号, n_零售金额, n_成本价, n_成本价);
          End If;
        End If;
      Elsif r_Detail.单据 = 13 Then
        --单据=13 的售价修正记录 同步更新的金额和差价，所以不需要重算平均成本价
        If r_Detail.费用id = 0 Then
          Update 药品库存
          Set 零售价 = Decode(n_时价, 1, n_零售价, Null), 实际金额 = Nvl(实际金额, 0) + n_零售金额, 实际差价 = Nvl(实际差价, 0) + n_差价
          Where 性质 = 1 And 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次;
        Else
          Update 药品库存
          Set 实际金额 = Nvl(实际金额, 0) + n_零售金额, 实际差价 = Nvl(实际差价, 0) + n_差价
          Where 性质 = 1 And 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次;
        End If;
      
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 零售价)
          Values
            (r_Detail.库房id, r_Detail.药品id, r_Detail.批次, 1, 0, 0, n_零售金额, n_零售金额, Decode(n_时价, 1, n_零售价, Null));
        End If;
      End If;
    Else
      --一般业务处理库存
      --包含业务--1-外购入库；2-自制入库；3-协药入库；4-其他入库；6-库房移出；
      --7-部门领用；8-收费处方发药；9-记帐单处方发药；10-记帐表处方发药；11-其他出库；
      --12-盘点；14-药品盘点记录单
      --21-材料其他出库；24-收费处方发料；25-记帐单处方发料；26-记帐表处方发料
      If 业务类型_In = 0 Or 业务类型_In = 1 Then
        --新增，删除
        If r_Detail.单据 = 8 Or r_Detail.单据 = 9 Or r_Detail.单据 = 10 Or r_Detail.单据 = 21 Or r_Detail.单据 = 24 Or
           r_Detail.单据 = 25 Or r_Detail.单据 = 26 Or r_Detail.单据 = 7 Or r_Detail.单据 = 11 Or
           ((r_Detail.单据 = 2 Or r_Detail.单据 = 3 Or r_Detail.单据 = 12) And r_Detail.入出系数 = -1) Or
           (r_Detail.单据 = 1 And r_Detail.发药方式 = 1) Or (r_Detail.单据 = 6 And r_Detail.入出系数 = -1 And r_Detail.记录状态 = 1) Or
           (r_Detail.单据 = 6 And Mod(r_Detail.记录状态, 3) = 2 And r_Detail.入出系数 = 1) Then
          --需要在新增/删除单据时减少/增加可用数量的单据类型
          ----1.发药/发料单据(收费处方，记账单，记账表)
          ----2.普通出库（领用、其他出库、移库中出的那笔(r_Detail.单据 = 6 And r_Detail.入出系数 = -1 And r_Detail.记录状态 = 1)、盘点单中盘亏那笔）
          ----3.退库单（r_Detail.单据 = 1 And r_Detail.发药方式 = 1）
          ----4.移库申请冲销单（原入库那笔的冲销记录，r_Detail.单据 = 6 And Mod(r_Detail.记录状态, 3) = 2 And r_Detail.入出系数 = 1）
        
          --新增，删除单据时，因为没有审核所以只处理数量不处理金额和差价
        
          If 业务类型_In = 0 Then
            --新增时正常处理可用数量
            n_可用数量 := n_实际数量;
          Else
            --删除时按相反数计算可用数量
            n_可用数量 := -1 * n_实际数量;
          End If;
        
          n_实际数量 := 0;
          n_零售金额 := 0;
          n_差价     := 0;
        
          --处理库存
          Update 药品库存
          Set 可用数量 = 可用数量 + n_可用数量
          Where 药品id = r_Detail.药品id And 库房id = r_Detail.库房id And Nvl(批次, 0) = r_Detail.批次 And 性质 = 1;
        
          n_更新库存 := 1;
        End If;
      Elsif 业务类型_In = 2 Then
        --审核
        --10.35开始，理论上所有的出库类单据在审核时都不再处理可用数量
        If r_Detail.单据 = 8 Or r_Detail.单据 = 9 Or r_Detail.单据 = 10 Or r_Detail.单据 = 21 Or r_Detail.单据 = 24 Or
           r_Detail.单据 = 25 Or r_Detail.单据 = 26 Or r_Detail.单据 = 7 Or r_Detail.单据 = 11 Or
           ((r_Detail.单据 = 2 Or r_Detail.单据 = 3 Or r_Detail.单据 = 12) And r_Detail.入出系数 = -1) Or
           (r_Detail.单据 = 1 And r_Detail.发药方式 = 1) Or (r_Detail.单据 = 6 And r_Detail.入出系数 = -1 And r_Detail.记录状态 = 1) Or
           (r_Detail.单据 = 6 And Mod(r_Detail.记录状态, 3) = 2 And r_Detail.入出系数 = 1) Then
          n_可用数量 := 0;
        Else
          n_可用数量 := n_实际数量;
        End If;
      
        --处理库存
        If 入出类型_In = 0 Then
          --入库审核
          Update 药品库存
          Set 可用数量 = Nvl(可用数量, 0) + n_可用数量, 实际数量 = Nvl(实际数量, 0) + n_实际数量, 实际金额 = Nvl(实际金额, 0) + n_零售金额,
              实际差价 = Nvl(实际差价, 0) + n_差价, 上次供应商id = r_Detail.供药单位id,
              上次采购价 = Decode(r_Detail.单据, 1, Decode(r_Detail.发药方式, 1, 上次采购价, n_成本价), n_成本价),
              上次批号 = Nvl(r_Detail.批号, 上次批号), 上次生产日期 = Nvl(r_Detail.生产日期, 上次生产日期), 上次产地 = Nvl(r_Detail.产地, 上次产地),
              灭菌效期 = Nvl(r_Detail.灭菌效期, 灭菌效期), 效期 = Nvl(r_Detail.效期, 效期), 批准文号 = Nvl(r_Detail.批准文号, 批准文号),
              上次扣率 = Decode(r_Detail.单据, 12, 上次扣率, r_Detail.扣率), 商品条码 = Nvl(r_Detail.商品条码, 商品条码),
              内部条码 = Nvl(r_Detail.内部条码, 内部条码)
          Where 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次 And 性质 = 1;
        Else
          --出库审核，只需要下数量和金额
          Update 药品库存
          Set 可用数量 = Nvl(可用数量, 0) + n_可用数量, 实际数量 = Nvl(实际数量, 0) + n_实际数量, 实际金额 = Nvl(实际金额, 0) + n_零售金额,
              实际差价 = Nvl(实际差价, 0) + n_差价
          Where 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次 And 性质 = 1;
        End If;
      
        n_更新库存 := 1;
      Elsif 业务类型_In = 3 Then
        --冲销
        If r_Detail.单据 = 8 Or r_Detail.单据 = 9 Or r_Detail.单据 = 10 Or r_Detail.单据 = 21 Or r_Detail.单据 = 24 Or
           r_Detail.单据 = 25 Or r_Detail.单据 = 26 Then
          --发药/发料单退药/退料时同时又产生了未发单据，所以就不处理可用数量
          n_可用数量 := 0;
        Elsif r_Detail.单据 = 6 And Mod(r_Detail.记录状态, 3) = 2 And r_Detail.入出系数 = 1 Then
          --药库单的冲销单据，要判断是否需要申请
          n_申请冲销 := Nvl(zl_GetSysParameter('冲销申请', 1304, 1), 0);
          If n_申请冲销 = 0 Then
            --不需要申请的在冲销时处理可用数量
            n_可用数量 := n_实际数量;
          Else
            --需要申请的，已经在申请时处理了可用数量
            n_可用数量 := 0;
          End If;
        Else
          n_可用数量 := n_实际数量;
        End If;
      
        Begin
          Select 1
          Into n_有库存
          From 药品库存
          Where 性质 = 1 And 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次;
        Exception
          When Others Then
            n_有库存 := 0;
        End;
      
        --冲销时如果原来无库存，由于需要重新插入数据，则需要取最新成本价格，因为后面可能还要触发调价修正
        If n_有库存 = 0 Then
          --取原始单据的审核时间
          Select a.审核日期
          Into v_审核日期
          From 药品收发记录 A, 药品收发记录 B
          Where b.Id = r_Detail.Id And a.单据 = b.单据 And a.No = b.No And a.库房id = b.库房id And a.药品id + 0 = b.药品id And
                a.序号 = b.序号 And (a.记录状态 = 1 Or Mod(a.记录状态, 3) = 0);
        
          --成本价取最新价格
          Begin
            Select 1, 新成本价
            Into v_执行新价格, v_现价
            From 成本价调价信息
            Where 库房id + 0 = r_Detail.库房id And 药品id + 0 = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次 And 执行日期 > v_审核日期 And
                  Rownum = 1
            Order By 执行日期 Desc;
          Exception
            When Others Then
              v_执行新价格 := 0;
            
              --可能是无库存调价，那么不需要库房id和批次判断，只需要用药品id
              Begin
                Select 1, 新成本价
                Into v_执行新价格, v_现价
                From 成本价调价信息
                Where 药品id + 0 = r_Detail.药品id And 执行日期 > v_审核日期 And Rownum = 1
                Order By 执行日期 Desc;
              Exception
                When Others Then
                  v_执行新价格 := 0;
              End;
          End;
        
          If v_执行新价格 = 1 Then
            n_成本价 := v_现价;
          End If;
        End If;
      
        --处理库存
        If 入出类型_In = 0 Then
          --出库单据冲销需要将入库库房数据都更新
          Update 药品库存
          Set 可用数量 = Nvl(可用数量, 0) + n_可用数量, 实际数量 = Nvl(实际数量, 0) + n_实际数量, 实际金额 = Nvl(实际金额, 0) + n_零售金额,
              实际差价 = Nvl(实际差价, 0) + n_差价, 上次供应商id = r_Detail.供药单位id,
              上次采购价 = Decode(r_Detail.单据, 1, Decode(r_Detail.发药方式, 1, 上次采购价, n_成本价), 上次采购价),
              上次批号 = Nvl(r_Detail.批号, 上次批号), 上次生产日期 = Nvl(r_Detail.生产日期, 上次生产日期), 上次产地 = Nvl(r_Detail.产地, 上次产地),
              灭菌效期 = Nvl(r_Detail.灭菌效期, 灭菌效期), 效期 = Nvl(r_Detail.效期, 效期), 批准文号 = Nvl(r_Detail.批准文号, 批准文号),
              上次扣率 = Decode(r_Detail.单据, 12, 上次扣率, r_Detail.扣率), 商品条码 = Nvl(r_Detail.商品条码, 商品条码),
              内部条码 = Nvl(r_Detail.内部条码, 内部条码)
          Where 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次 And 性质 = 1;
        Else
          --入库单据冲销只需要下数量和金额
          Update 药品库存
          Set 可用数量 = Nvl(可用数量, 0) + n_可用数量, 实际数量 = Nvl(实际数量, 0) + n_实际数量, 实际金额 = Nvl(实际金额, 0) + n_零售金额,
              实际差价 = Nvl(实际差价, 0) + n_差价
          Where 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次 And 性质 = 1;
        End If;
      
        n_更新库存 := 1;
      End If;
    
      --新增/删除/审核/冲销业务时，库存表未找到数据则需要产生库存表所有信息
      If Sql%RowCount = 0 And n_更新库存 = 1 Then
        Insert Into 药品库存
          (库房id, 药品id, 批次, 效期, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 灭菌效期, 批准文号, 零售价, 上次扣率,
           商品条码, 内部条码, 平均成本价)
        Values
          (r_Detail.库房id, r_Detail.药品id, r_Detail.批次, r_Detail.效期, 1, n_可用数量, n_实际数量, n_零售金额, n_差价, r_Detail.供药单位id,
           n_成本价, r_Detail.批号, r_Detail.生产日期, r_Detail.产地, r_Detail.灭菌效期, r_Detail.批准文号, Decode(n_时价, 1, n_零售价, Null),
           r_Detail.扣率, r_Detail.商品条码, r_Detail.内部条码, n_成本价);
      End If;
    
      --重算平均成本价，入库审核需要重算平均成本价和零售价，注意只限于不分批药品，分批药品不用重算（确保和之前库存的数据一致）
      If 入出类型_In = 0 And 业务类型_In = 2 And r_Detail.批次 = 0 Then
        --按总金额/总数量方式计算平均成本价而不用（金额-差价）/数量是为了数据的准确性
        n_总数量 := (n_库存数量 + n_实际数量);
        If n_总数量 <> 0 Then
          n_总成本价 := (n_库存数量 * n_库存平均价 + n_实际数量 * n_成本价) / n_总数量;
          Update 药品库存
          Set 平均成本价 = n_总成本价
          Where 性质 = 1 And 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次;
        
          --更新时价零售价
          If n_时价 = 1 Then
            n_总售价 := (n_库存数量 * n_库存售价 + n_实际数量 * n_零售价) / n_总数量;
            Update 药品库存
            Set 零售价 = n_总售价
            Where 性质 = 1 And 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次 And
                  Nvl(实际数量, 0) <> 0;
            If Sql%NotFound Then
              Update 药品库存
              Set 零售价 = n_零售价
              Where 性质 = 1 And 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次;
            End If;
          End If;
        End If;
      End If;
    End If;
  
    --删除多余的库存数据，财务审核为了确保库存不变产生修正数据必须保证不删除库存
    If 财务审核_In = 0 Then
      Delete From 药品库存
      Where 性质 = 1 And 库房id = r_Detail.库房id And 药品id = r_Detail.药品id And Nvl(批次, 0) = r_Detail.批次 And Nvl(可用数量, 0) = 0 And
            Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0;
    End If;
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品库存_Update;
/



--105308:李业庆,2016-10-20,药品零差价管理药品精度适应调整
Create Or Replace Procedure Zl_药品卫材精度_零差价调整 Is
  n_零差价管理 Number(1);

  --售价和成本价精度不一致
  Cursor c_Digit Is
    Select a.单位, a.精度 As 零售价精度, b.精度 As 成本价精度
    From 药品卫材精度 A, 药品卫材精度 B
    Where a.性质 = 0 And b.性质 = 0 And a.类别 = 1 And b.类别 = 1 And a.内容 = 2 And b.内容 = 1 And a.单位 = b.单位 And a.精度 <> b.精度;
  r_Digit c_Digit%RowType;
Begin
  n_零差价管理 := Nvl(zl_GetSysParameter(275), 0);

  --如果是零差价管理，调整精度参数
  If n_零差价管理 <> 0 Then
    For r_Digit In c_Digit Loop
      If r_Digit.零售价精度 > r_Digit.成本价精度 Then
        Update 药品卫材精度
        Set 精度 = r_Digit.零售价精度
        Where 性质 = 0 And 类别 = 1 And 内容 = 1 And 单位 = r_Digit.单位;
      Else
        Update 药品卫材精度
        Set 精度 = r_Digit.成本价精度
        Where 性质 = 0 And 类别 = 1 And 内容 = 2 And 单位 = r_Digit.单位;
      End If;
    End Loop;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品卫材精度_零差价调整;
/

--105308:李业庆,2016-10-20,药品零差价管理药品规格新增字段
Create Or Replace Procedure Zl_成药规格_Insert
(
  药名id_In         In 药品规格.药名id%Type,
  药品id_In         In 药品规格.药品id%Type,
  编码_In           In 收费项目目录.编码%Type,
  规格_In           In 收费项目目录.规格%Type,
  产地_In           In 收费项目目录.产地%Type := Null,
  品名_In           In 收费项目别名.名称%Type := Null,
  拼音_In           In 收费项目别名.简码%Type := Null,
  五笔_In           In 收费项目别名.简码%Type := Null,
  数字码_In         In 收费项目别名.简码%Type := Null,
  标识码_In         In 药品规格.标识码%Type := Null,
  药品来源_In       In 药品规格.药品来源%Type := Null,
  批准文号_In       In 药品规格.批准文号%Type := Null,
  注册商标_In       In 药品规格.注册商标%Type := Null,
  售价单位_In       In 收费项目目录.计算单位%Type := Null,
  剂量系数_In       In 药品规格.剂量系数%Type := Null,
  门诊单位_In       In 药品规格.门诊单位%Type := Null,
  门诊包装_In       In 药品规格.门诊包装%Type := Null,
  住院单位_In       In 药品规格.住院单位%Type := Null,
  住院包装_In       In 药品规格.住院包装%Type := Null,
  药库单位_In       In 药品规格.药库单位%Type := Null,
  药库包装_In       In 药品规格.药库包装%Type := Null,
  申领单位_In       In 药品规格.申领单位%Type := 1,
  申领阀值_In       In 药品规格.申领阀值%Type := Null,
  是否变价_In       In 收费项目目录.是否变价%Type := Null,
  指导批发价_In     In 药品规格.指导批发价%Type := Null,
  扣率_In           In 药品规格.扣率%Type := 95,
  指导零售价_In     In 药品规格.指导零售价%Type := Null,
  加成率_In         In 药品规格.加成率%Type := Null,
  管理费比例_In     In 药品规格.管理费比例%Type := Null,
  药价级别_In       In 药品规格.药价级别%Type := Null,
  费用类型_In       In 收费项目目录.费用类型%Type := Null,
  服务对象_In       In 收费项目目录.服务对象%Type := Null,
  Gmp认证_In        In 药品规格.Gmp认证%Type := 0,
  招标药品_In       In 药品规格.招标药品%Type := 0,
  屏蔽费别_In       In 收费项目目录.屏蔽费别%Type := 0,
  住院可否分零_In   In 药品规格.住院可否分零%Type := 0,
  药库分批_In       In 药品规格.药库分批%Type := Null,
  药房分批_In       In 药品规格.药房分批%Type := Null,
  最大效期_In       In 药品规格.最大效期%Type := Null,
  差价让利比_In     In 药品规格.差价让利比%Type := 0,
  成本价_In         In 药品规格.成本价%Type := 0,
  当前售价_In       In 收费价目.现价%Type := 0,
  收入id_In         In 收费价目.收入项目id%Type := Null,
  合同单位id_In     In 药品规格.合同单位id%Type := Null,
  说明_In           In 收费项目目录.说明%Type := Null,
  动态分零_In       In 药品规格.动态分零%Type := 0,
  发药类型_In       In 药品规格.发药类型%Type := Null,
  备选码_In         In 收费项目目录.备选码%Type := Null,
  增值税率_In       In 药品规格.增值税率%Type := Null,
  基本药物_In       In 药品规格.基本药物%Type := Null,
  站点_In           In 收费项目目录.站点%Type := Null,
  是否常备_In       In 药品规格.是否常备%Type := Null,
  存储温度_In       In 输液药品属性.存储温度%Type := Null,
  存储条件_In       In 输液药品属性.存储条件%Type := Null,
  配药类型_In       In 输液药品属性.配药类型%Type := Null,
  是否不予配置_In   In 输液药品属性.是否不予配置%Type := Null,
  容量_In           In 药品规格.容量%Type := Null,
  病案费目_In       In 收费项目目录.病案费目%Type := Null,
  门诊可否分零_In   In 药品规格.门诊可否分零%Type := 0,
  Ddd值_In          In 药品规格.Ddd值%Type := 0,
  高危药品_In       In 药品规格.高危药品%Type := Null,
  送货单位_In       In 药品规格.送货单位%Type := Null,
  送货包装_In       In 药品规格.送货包装%Type := Null,
  输液注意事项_In   In 输液药品属性.输液注意事项%Type := Null,
  是否摆药_In       In 药品规格.是否摆药%Type := Null,
  是否零差价管理_In In 药品规格.是否零差价管理%Type := Null
) Is

  v_类别       诊疗项目目录.类别%Type;
  v_名称       诊疗项目目录.名称%Type;
  v_Kind       Varchar2(20);
  v_No         收费价目.No%Type;
  v_Temp       收费项目目录.病案费目%Type;
  v_病案费目   收费项目目录.病案费目%Type;
  n_指导差价率 药品规格.指导差价率%Type;

  --盘点库房的工作性质 
  Cursor c_Storageid Is
    Select Distinct 部门id From 部门性质说明 Where 工作性质 Like v_Kind Or 工作性质 = '制剂室';
  r_Storageid c_Storageid%RowType;
Begin
  v_病案费目 := 病案费目_In;
  --判断病案费目 
  If v_病案费目 Is Null Then
    If 收入id_In Is Not Null Then
      Begin
        Select 病案费目 Into v_Temp From 收入项目 Where ID = 收入id_In;
      Exception
        When Others Then
          v_Temp := Null;
      End;
      If v_Temp Is Not Null Then
        v_病案费目 := v_Temp;
      End If;
    End If;
  End If;
  --类别和名称 
  Select 类别, 名称 Into v_类别, v_名称 From 诊疗项目目录 Where ID = 药名id_In;
  n_指导差价率 := (1 - 1 / (1 + 加成率_In / 100)) * 100;
  --规格信息 
  Insert Into 收费项目目录
    (类别, ID, 编码, 名称, 规格, 产地, 计算单位, 费用类型, 服务对象, 屏蔽费别, 是否变价, 建档时间, 撤档时间, 说明, 备选码, 站点, 病案费目)
  Values
    (v_类别, 药品id_In, 编码_In, v_名称, 规格_In, 产地_In, 售价单位_In, 费用类型_In, 服务对象_In, 屏蔽费别_In, 是否变价_In, Sysdate,
     To_Date('3000-01-01', 'YYYY-MM-DD'), 说明_In, 备选码_In, 站点_In, v_病案费目);
  Insert Into 药品规格
    (药名id, 药品id, 标识码, 药品来源, 批准文号, 注册商标, 剂量系数, 门诊单位, 门诊包装, 住院单位, 住院包装, 药库单位, 药库包装, 申领单位, 申领阀值, 指导批发价, 扣率, 指导零售价, 指导差价率,
     管理费比例, 药价级别, 成本价, Gmp认证, 招标药品, 差价让利比, 住院可否分零, 药库分批, 药房分批, 最大效期, 合同单位id, 动态分零, 发药类型, 增值税率, 基本药物, 是否常备, 容量, 门诊可否分零,
     Ddd值, 高危药品, 送货单位, 送货包装, 加成率, 是否摆药, 是否零差价管理)
  Values
    (药名id_In, 药品id_In, 标识码_In, 药品来源_In, 批准文号_In, 注册商标_In, 剂量系数_In, 门诊单位_In, 门诊包装_In, 住院单位_In, 住院包装_In, 药库单位_In, 药库包装_In,
     申领单位_In, 申领阀值_In, 指导批发价_In, 扣率_In, 指导零售价_In, n_指导差价率, 管理费比例_In, 药价级别_In, 成本价_In, Gmp认证_In, 招标药品_In, 差价让利比_In,
     住院可否分零_In, 药库分批_In, 药房分批_In, 最大效期_In, 合同单位id_In, 动态分零_In, 发药类型_In, 增值税率_In, 基本药物_In, 是否常备_In, 容量_In, 门诊可否分零_In,
     Ddd值_In, 高危药品_In, 送货单位_In, 送货包装_In, 加成率_In, 是否摆药_In, 是否零差价管理_In);

  --朱玉宝修改：建立药品（西成药、中成药）时，缺省服务对象为门诊和住院，因此建立规格药品时，不再根据规格药品的服务对象更新药品的服务对象 
  --诊疗项目服务对象的更改 
  --select nvl(sum(distinct I.服务对象),0) into v_对象 
  --from 收费项目目录 I,药品规格 S 
  --where I.ID=S.药品ID and S.药名ID=药名ID_IN; 
  --update 诊疗项目目录 
  --set 服务对象=decode(v_对象,0,0,1,1,2,2,3) 
  --where ID=药名ID_IN; 

  --别名的处理 
  Insert Into 收费项目别名
    (收费细目id, 名称, 性质, 简码, 码类)
    Select 药品id_In, 名称, 性质, 简码, 码类 From 诊疗项目别名 Where 诊疗项目id = 药名id_In;
  If 数字码_In Is Not Null Then
    Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (药品id_In, v_名称, 1, 数字码_In, 3);
  End If;
  If (品名_In Is Not Null) And (拼音_In Is Not Null) Then
    Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (药品id_In, 品名_In, 3, 拼音_In, 1);
  End If;
  If (品名_In Is Not Null) And (五笔_In Is Not Null) Then
    Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (药品id_In, 品名_In, 3, 五笔_In, 2);
  End If;

  --定价信息 
  If 收入id_In Is Not Null Then
    v_No := Nextno(9);
    Insert Into 收费价目
      (ID, 原价id, 收费细目id, 原价, 现价, 收入项目id, 变动原因, 调价说明, 调价人, 执行日期, 终止日期, NO, 序号)
    Values
      (收费价目_Id.Nextval, Null, 药品id_In, 0, 当前售价_In, 收入id_In, 1, '新增定价', User, Sysdate,
       To_Date('3000-01-01', 'YYYY-MM-DD'), v_No, 1);
  End If;

  --药品生产商比较增加 
  If 产地_In Is Not Null Then
    Update 药品生产商 Set 名称 = 产地_In Where 名称 = 产地_In;
    If Sql%RowCount = 0 Then
      Insert Into 药品生产商
        (编码, 名称, 简码)
        Select Nvl(Max(To_Number(编码)), 0) + 1, 产地_In, zlSpellCode(产地_In, 10) From 药品生产商;
    End If;
  End If;

  --插入该规格的服务科室 
  Insert Into 收费执行科室
    (收费细目id, 病人来源, 开单科室id, 执行科室id)
    Select 药品id_In, 病人来源, 开单科室id, 执行科室id From 诊疗执行科室 Where 诊疗项目id = 药名id_In;

  --插入盘点属性 

  If v_类别 = 5 Then
    v_Kind := '西药%';
  Else
    v_Kind := '成药%';
  End If;

  For r_Storageid In c_Storageid Loop
    Insert Into 药品储备限额
      (库房id, 药品id, 上限, 下限, 盘点属性, 库房货位)
    Values
      (r_Storageid.部门id, 药品id_In, 0, 0, '1111', Null);
  End Loop;

  --插入输液药品属性 
  Insert Into 输液药品属性
    (药品id, 存储温度, 存储条件, 配药类型, 是否不予配置, 输液注意事项)
  Values
    (药品id_In, 存储温度_In, 存储条件_In, 配药类型_In, 是否不予配置_In, 输液注意事项_In);

  --药品精度调整(零差价模式时)
  Zl_药品卫材精度_零差价调整;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_成药规格_Insert;
/

--105308:李业庆,2016-10-20,药品零差价管理药品规格新增字段
Create Or Replace Procedure Zl_成药规格_Update
(
  药品id_In         In 药品规格.药品id%Type,
  编码_In           In 收费项目目录.编码%Type,
  规格_In           In 收费项目目录.规格%Type,
  产地_In           In 收费项目目录.产地%Type := Null,
  品名_In           In 收费项目别名.名称%Type := Null,
  拼音_In           In 收费项目别名.简码%Type := Null,
  五笔_In           In 收费项目别名.简码%Type := Null,
  数字码_In         In 收费项目别名.简码%Type := Null,
  标识码_In         In 药品规格.标识码%Type := Null,
  药品来源_In       In 药品规格.药品来源%Type := Null,
  批准文号_In       In 药品规格.批准文号%Type := Null,
  注册商标_In       In 药品规格.注册商标%Type := Null,
  售价单位_In       In 收费项目目录.计算单位%Type := Null,
  剂量系数_In       In 药品规格.剂量系数%Type := Null,
  门诊单位_In       In 药品规格.门诊单位%Type := Null,
  门诊包装_In       In 药品规格.门诊包装%Type := Null,
  住院单位_In       In 药品规格.住院单位%Type := Null,
  住院包装_In       In 药品规格.住院包装%Type := Null,
  药库单位_In       In 药品规格.药库单位%Type := Null,
  药库包装_In       In 药品规格.药库包装%Type := Null,
  申领单位_In       In 药品规格.申领单位%Type := 1,
  申领阀值_In       In 药品规格.申领阀值%Type := Null,
  是否变价_In       In 收费项目目录.是否变价%Type := Null,
  指导批发价_In     In 药品规格.指导批发价%Type := Null,
  扣率_In           In 药品规格.扣率%Type := 95,
  指导零售价_In     In 药品规格.指导零售价%Type := Null,
  加成率_In         In 药品规格.加成率%Type := Null,
  管理费比例_In     In 药品规格.管理费比例%Type := Null,
  药价级别_In       In 药品规格.药价级别%Type := Null,
  费用类型_In       In 收费项目目录.费用类型%Type := Null,
  服务对象_In       In 收费项目目录.服务对象%Type := Null,
  Gmp认证_In        In 药品规格.Gmp认证%Type := 0,
  招标药品_In       In 药品规格.招标药品%Type := 0,
  屏蔽费别_In       In 收费项目目录.屏蔽费别%Type := 0,
  住院可否分零_In   In 药品规格.住院可否分零%Type := 0,
  药库分批_In       In 药品规格.药库分批%Type := Null,
  药房分批_In       In 药品规格.药房分批%Type := Null,
  最大效期_In       In 药品规格.最大效期%Type := Null,
  差价让利比_In     In 药品规格.差价让利比%Type := 0,
  成本价_In         In 药品规格.成本价%Type := 0,
  当前售价_In       In 收费价目.现价%Type := 0,
  收入id_In         In 收费价目.收入项目id%Type := Null,
  合同单位id_In     In 药品规格.合同单位id%Type := Null,
  说明_In           In 收费项目目录.说明%Type := Null,
  动态分零_In       In 药品规格.动态分零%Type := 0,
  发药类型_In       In 药品规格.发药类型%Type := Null,
  备选码_In         In 收费项目目录.备选码%Type := Null,
  增值税率_In       In 药品规格.增值税率%Type := Null,
  基本药物_In       In 药品规格.基本药物%Type := Null,
  站点_In           In 收费项目目录.站点%Type := Null,
  是否常备_In       In 药品规格.是否常备%Type := Null,
  存储温度_In       In 输液药品属性.存储温度%Type := Null,
  存储条件_In       In 输液药品属性.存储条件%Type := Null,
  配药类型_In       In 输液药品属性.配药类型%Type := Null,
  是否不予配置_In   In 输液药品属性.是否不予配置%Type := Null,
  容量_In           In 药品规格.容量%Type := Null,
  病案费目_In       In 收费项目目录.病案费目%Type := Null,
  门诊可否分零_In   In 药品规格.门诊可否分零%Type := 0,
  Ddd值_In          In 药品规格.Ddd值%Type := 0,
  高危药品_In       药品规格.高危药品%Type := Null,
  送货单位_In       In 药品规格.送货单位%Type := Null,
  送货包装_In       In 药品规格.送货包装%Type := Null,
  输液注意事项_In   In 输液药品属性.输液注意事项%Type := Null,
  是否摆药_In       In 药品规格.是否摆药%Type := Null,
  是否零差价管理_In In 药品规格.是否零差价管理%Type := Null
) Is
  v_药名id   诊疗项目目录.Id%Type;
  v_名称     诊疗项目目录.名称%Type;
  v_是否变价 收费项目目录.是否变价%Type; --允许定价药品随时改为时价，时价药品只能在未发生的情况下修改为定价，其它情况不允许修改定价属性 
  v_发生     Number(2);
  Err_Notfind Exception;
  v_No         收费价目.No%Type;
  v_Temp       收费项目目录.病案费目%Type;
  v_病案费目   收费项目目录.病案费目%Type;
  n_指导差价率 药品规格.指导差价率%Type;
Begin
  v_病案费目 := 病案费目_In;
  --判断病案费目 
  If v_病案费目 Is Null Then
    If 收入id_In Is Not Null Then
      Begin
        Select 病案费目 Into v_Temp From 收入项目 Where ID = 收入id_In;
      Exception
        When Others Then
          v_Temp := Null;
      End;
      If v_Temp Is Not Null Then
        v_病案费目 := v_Temp;
      End If;
    End If;
  End If;
  --通用名称 
  Select ID, 名称
  Into v_药名id, v_名称
  From 诊疗项目目录
  Where ID = (Select 药名id From 药品规格 Where 药品id = 药品id_In);
  --取原始的定价属性 
  Select 是否变价 Into v_是否变价 From 收费项目目录 Where ID = 药品id_In;
  --规格信息 
  Update 收费项目目录
  Set 编码 = 编码_In, 名称 = v_名称, 规格 = 规格_In, 产地 = 产地_In, 计算单位 = 售价单位_In, 费用类型 = 费用类型_In, 服务对象 = 服务对象_In, 屏蔽费别 = 屏蔽费别_In,
      病案费目 = v_病案费目, 说明 = 说明_In, 备选码 = 备选码_In, 站点 = 站点_In
  Where ID = 药品id_In;
  If Sql%RowCount = 0 Then
    Raise Err_Notfind;
  End If;
  n_指导差价率 := (1 - 1 / (1 + 加成率_In / 100)) * 100;
  Update 药品规格
  Set 标识码 = 标识码_In, 药品来源 = 药品来源_In, 批准文号 = 批准文号_In, 注册商标 = 注册商标_In, 剂量系数 = 剂量系数_In, 门诊单位 = 门诊单位_In, 门诊包装 = 门诊包装_In,
      住院单位 = 住院单位_In, 住院包装 = 住院包装_In, 药库单位 = 药库单位_In, 药库包装 = 药库包装_In, 申领单位 = 申领单位_In, 申领阀值 = 申领阀值_In, 指导批发价 = 指导批发价_In,
      扣率 = 扣率_In, 指导零售价 = 指导零售价_In, 指导差价率 = n_指导差价率, 管理费比例 = 管理费比例_In, 药价级别 = 药价级别_In, 住院可否分零 = 住院可否分零_In,
      药库分批 = 药库分批_In, 药房分批 = 药房分批_In, 最大效期 = 最大效期_In, 招标药品 = 招标药品_In, Gmp认证 = Gmp认证_In, 差价让利比 = 差价让利比_In,
      合同单位id = 合同单位id_In, 动态分零 = 动态分零_In, 发药类型 = 发药类型_In, 增值税率 = 增值税率_In, 基本药物 = 基本药物_In, 是否常备 = 是否常备_In, 容量 = 容量_In,
      门诊可否分零 = 门诊可否分零_In, Ddd值 = Ddd值_In, 高危药品 = 高危药品_In, 送货单位 = 送货单位_In, 送货包装 = 送货包装_In, 加成率 = 加成率_In, 是否摆药 = 是否摆药_In,
      是否零差价管理 = 是否零差价管理_In
  Where 药品id = 药品id_In;

  --朱玉宝修改：建立药品（西成药、中成药）时，缺省服务对象为门诊和住院，因此修改规格药品时，不再根据规格药品的服务对象更新药品的服务对象 
  --诊疗项目服务对象的更改 
  --select nvl(sum(distinct I.服务对象),0) into v_对象 
  --from 收费项目目录 I,药品规格 S 
  --where I.ID=S.药品ID and S.药名ID=v_药名ID; 
  --update 诊疗项目目录 
  --set 服务对象=decode(v_对象,0,0,1,1,2,2,3) 
  --where ID=v_药名ID; 

  --别名的处理 
  If 数字码_In Is Null Then
    Delete 收费项目别名 Where 收费细目id = 药品id_In And 性质 = 1 And 码类 = 3;
  Else
    Update 收费项目别名 Set 名称 = v_名称, 简码 = 数字码_In Where 收费细目id = 药品id_In And 性质 = 1 And 码类 = 3;
    If Sql%RowCount = 0 Then
      Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (药品id_In, v_名称, 1, 数字码_In, 3);
    End If;
  End If;
  If 品名_In Is Null Then
    Delete 收费项目别名 Where 收费细目id = 药品id_In And 性质 = 3;
  Else
    If 拼音_In Is Null Then
      Delete 收费项目别名 Where 收费细目id = 药品id_In And 性质 = 3 And 码类 = 1;
    Else
      Update 收费项目别名 Set 名称 = 品名_In, 简码 = 拼音_In Where 收费细目id = 药品id_In And 性质 = 3 And 码类 = 1;
      If Sql%RowCount = 0 Then
        Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (药品id_In, 品名_In, 3, 拼音_In, 1);
      End If;
    End If;
    If 五笔_In Is Null Then
      Delete 收费项目别名 Where 收费细目id = 药品id_In And 性质 = 3 And 码类 = 2;
    Else
      Update 收费项目别名 Set 名称 = 品名_In, 简码 = 五笔_In Where 收费细目id = 药品id_In And 性质 = 3 And 码类 = 2;
      If Sql%RowCount = 0 Then
        Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (药品id_In, 品名_In, 3, 五笔_In, 2);
      End If;
    End If;
  End If;

  --定价信息：如果已经有发生，则不允许直接更改这些信息 
  Select Nvl(Count(*), 0) Into v_发生 From 药品收发记录 Where 药品id = 药品id_In And Rownum < 2;
  If v_发生 = 0 Then
    Update 收费项目目录 Set 是否变价 = 是否变价_In Where ID = 药品id_In;
    Update 药品规格 Set 成本价 = 成本价_In Where 药品id = 药品id_In;
    If 收入id_In Is Not Null Then
      Update 收费价目
      Set 现价 = 当前售价_In, 收入项目id = 收入id_In, 变动原因 = 1, 调价说明 = '修改定价', 调价人 = User
      Where 收费细目id = 药品id_In And (Sysdate Between 执行日期 And 终止日期 Or Sysdate >= 执行日期 And 终止日期 Is Null) And 变动原因 = 1;
      If Sql%RowCount = 0 Then
        v_No := Nextno(9);
        Insert Into 收费价目
          (ID, 原价id, 收费细目id, 原价, 现价, 收入项目id, 变动原因, 调价说明, 调价人, 执行日期, 终止日期, NO, 序号)
        Values
          (收费价目_Id.Nextval, Null, 药品id_In, 0, 当前售价_In, 收入id_In, 1, '新增定价', User, Sysdate,
           To_Date('3000-01-01', 'YYYY-MM-DD'), v_No, 1);
      End If;
    End If;
  Else
    --定价药品随时可改为时价 
    If v_是否变价 = 0 And 是否变价_In = 1 Then
      Update 收费项目目录 Set 是否变价 = 是否变价_In Where ID = 药品id_In;
    End If;
    --发生业务数据时，不能修改价格但是可以修改收入项目 
    Update 收费价目
    Set 收入项目id = 收入id_In
    Where 收费细目id = 药品id_In And (Sysdate Between 执行日期 And 终止日期 Or Sysdate >= 执行日期 And 终止日期 Is Null) And 变动原因 = 1;
  End If;

  --药品生产商比较增加 
  If 产地_In Is Not Null Then
    Update 药品生产商 Set 名称 = 产地_In Where 名称 = 产地_In;
    If Sql%RowCount = 0 Then
      Insert Into 药品生产商
        (编码, 名称, 简码)
        Select Nvl(Max(To_Number(编码)), 0) + 1, 产地_In, zlSpellCode(产地_In, 10) From 药品生产商;
    End If;
  End If;

  --修改输液药品属性 
  Update 输液药品属性
  Set 存储温度 = 存储温度_In, 存储条件 = 存储条件_In, 配药类型 = 配药类型_In, 是否不予配置 = 是否不予配置_In, 输液注意事项 = 输液注意事项_In
  Where 药品id = 药品id_In;

  If Sql%NotFound Then
    Insert Into 输液药品属性
      (药品id, 存储温度, 存储条件, 配药类型, 是否不予配置, 输液注意事项)
    Values
      (药品id_In, 存储温度_In, 存储条件_In, 配药类型_In, 是否不予配置_In, 输液注意事项_In);
  End If;
  
  --药品精度调整(零差价模式时)
  Zl_药品卫材精度_零差价调整;
Exception
  When Err_Notfind Then
    Raise_Application_Error(-20101, '[ZLSOFT]该规格不存在，可能已被其他用户删除！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_成药规格_Update;
/

--105308:李业庆,2016-10-20,药品零差价管理药品规格新增字段
Create Or Replace Procedure Zl_草药规格_Insert
(
  药名id_In         In 药品规格.药名id%Type,
  药品id_In         In 药品规格.药品id%Type,
  编码_In           In 收费项目目录.编码%Type,
  规格_In           In 收费项目目录.规格%Type,
  产地_In           In 收费项目目录.产地%Type := Null,
  品名_In           In 收费项目别名.名称%Type := Null,
  拼音_In           In 收费项目别名.简码%Type := Null,
  五笔_In           In 收费项目别名.简码%Type := Null,
  数字码_In         In 收费项目别名.简码%Type := Null,
  标识码_In         In 药品规格.标识码%Type := Null,
  药品来源_In       In 药品规格.药品来源%Type := Null,
  批准文号_In       In 药品规格.批准文号%Type := Null,
  注册商标_In       In 药品规格.注册商标%Type := Null,
  售价单位_In       In 收费项目目录.计算单位%Type := Null,
  剂量系数_In       In 药品规格.剂量系数%Type := Null,
  门诊单位_In       In 药品规格.门诊单位%Type := Null,
  门诊包装_In       In 药品规格.门诊包装%Type := Null,
  药库单位_In       In 药品规格.药库单位%Type := Null,
  药库包装_In       In 药品规格.药库包装%Type := Null,
  申领单位_In       In 药品规格.申领单位%Type := 1,
  申领阀值_In       In 药品规格.申领阀值%Type := Null,
  是否变价_In       In 收费项目目录.是否变价%Type := Null,
  指导批发价_In     In 药品规格.指导批发价%Type := Null,
  扣率_In           In 药品规格.扣率%Type := 95,
  指导零售价_In     In 药品规格.指导零售价%Type := Null,
  加成率_In         In 药品规格.加成率%Type := Null,
  管理费比例_In     In 药品规格.管理费比例%Type := Null,
  药价级别_In       In 药品规格.药价级别%Type := Null,
  费用类型_In       In 收费项目目录.费用类型%Type := Null,
  服务对象_In       In 收费项目目录.服务对象%Type := Null,
  Gmp认证_In        In 药品规格.Gmp认证%Type := 0,
  招标药品_In       In 药品规格.招标药品%Type := 0,
  屏蔽费别_In       In 收费项目目录.屏蔽费别%Type := 0,
  住院可否分零_In   In 药品规格.住院可否分零%Type := 0,
  药库分批_In       In 药品规格.药库分批%Type := Null,
  药房分批_In       In 药品规格.药房分批%Type := Null,
  最大效期_In       In 药品规格.最大效期%Type := Null,
  差价让利比_In     In 药品规格.差价让利比%Type := 0,
  成本价_In         In 药品规格.成本价%Type := 0,
  当前售价_In       In 收费价目.现价%Type := 0,
  收入id_In         In 收费价目.收入项目id%Type := Null,
  合同单位id_In     In 药品规格.合同单位id%Type := Null,
  说明_In           In 收费项目目录.说明%Type := Null,
  动态分零_In       In 药品规格.动态分零%Type := 0,
  发药类型_In       In 药品规格.发药类型%Type := Null,
  备选码_In         In 收费项目目录.备选码%Type := Null,
  增值税率_In       In 药品规格.增值税率%Type := Null,
  基本药物_In       In 药品规格.基本药物%Type := Null,
  中药形态_In       In 药品规格.中药形态%Type := Null,
  站点_In           In 收费项目目录.站点%Type := Null,
  是否常备_In       In 药品规格.是否常备%Type := Null,
  病案费目_In       In 收费项目目录.病案费目%Type := Null,
  门诊可否分零_In   In 药品规格.门诊可否分零%Type := 0,
  送货单位_In       In 药品规格.送货单位%Type := Null,
  送货包装_In       In 药品规格.送货包装%Type := Null,
  是否摆药_In       In 药品规格.是否摆药%Type := Null,
  是否零差价管理_In In 药品规格.是否零差价管理%Type := Null
) Is

  v_类别       诊疗项目目录.类别%Type;
  v_名称       诊疗项目目录.名称%Type;
  v_Kind       Varchar2(20);
  v_No         收费价目.No%Type;
  v_Temp       收费项目目录.病案费目%Type;
  v_病案费目   收费项目目录.病案费目%Type;
  n_指导差价率 药品规格.指导差价率%Type;
  --盘点库房的工作性质 
  Cursor c_Storageid Is
    Select Distinct 部门id From 部门性质说明 Where 工作性质 Like v_Kind Or 工作性质 = '制剂室';
  r_Storageid c_Storageid%RowType;

Begin
  v_病案费目 := 病案费目_In;
  --判断病案费目 
  If v_病案费目 Is Null Then
    If 收入id_In Is Not Null Then
      Begin
        Select 病案费目 Into v_Temp From 收入项目 Where ID = 收入id_In;
      Exception
        When Others Then
          v_Temp := Null;
      End;
      If v_Temp Is Not Null Then
        v_病案费目 := v_Temp;
      End If;
    End If;
  End If;
  --类别和名称 
  Select 类别, 名称 Into v_类别, v_名称 From 诊疗项目目录 Where ID = 药名id_In;
  n_指导差价率 := (1 - 1 / (1 + 加成率_In / 100)) * 100;
  --规格信息 
  Insert Into 收费项目目录
    (类别, ID, 编码, 名称, 规格, 产地, 计算单位, 费用类型, 服务对象, 屏蔽费别, 是否变价, 建档时间, 撤档时间, 说明, 备选码, 站点, 病案费目)
  Values
    (v_类别, 药品id_In, 编码_In, v_名称, 规格_In, 产地_In, 售价单位_In, 费用类型_In, 服务对象_In, 屏蔽费别_In, 是否变价_In, Sysdate,
     To_Date('3000-01-01', 'YYYY-MM-DD'), 说明_In, 备选码_In, 站点_In, v_病案费目);
  Insert Into 药品规格
    (药名id, 药品id, 标识码, 药品来源, 批准文号, 注册商标, 剂量系数, 门诊单位, 门诊包装, 住院单位, 住院包装, 药库单位, 药库包装, 申领单位, 申领阀值, 指导批发价, 扣率, 指导零售价, 指导差价率,
     管理费比例, 药价级别, 成本价, Gmp认证, 招标药品, 差价让利比, 住院可否分零, 药库分批, 药房分批, 最大效期, 合同单位id, 动态分零, 发药类型, 增值税率, 基本药物, 中药形态, 是否常备, 门诊可否分零,
     送货单位, 送货包装, 加成率, 是否摆药, 是否零差价管理)
  Values
    (药名id_In, 药品id_In, 标识码_In, 药品来源_In, 批准文号_In, 注册商标_In, 剂量系数_In, 门诊单位_In, 门诊包装_In, 门诊单位_In, 门诊包装_In, 药库单位_In, 药库包装_In,
     申领单位_In, 申领阀值_In, 指导批发价_In, 扣率_In, 指导零售价_In, n_指导差价率, 管理费比例_In, 药价级别_In, 成本价_In, Gmp认证_In, 招标药品_In, 差价让利比_In,
     住院可否分零_In, 药库分批_In, 药房分批_In, 最大效期_In, 合同单位id_In, 动态分零_In, 发药类型_In, 增值税率_In, 基本药物_In, 中药形态_In, 是否常备_In, 门诊可否分零_In,
     送货单位_In, 送货包装_In, 加成率_In, 是否摆药_In, 是否零差价管理_In);

  --朱玉宝修改：建立药品（西成药、中成药）时，缺省服务对象为门诊和住院，因此建立规格药品时，不再根据规格药品的服务对象更新药品的服务对象 
  --诊疗项目服务对象的更改 
  --select nvl(sum(distinct I.服务对象),0) into v_对象 
  --from 收费项目目录 I,药品规格 S 
  --where I.ID=S.药品ID and S.药名ID=药名ID_IN; 
  --update 诊疗项目目录 
  --set 服务对象=decode(v_对象,0,0,1,1,2,2,3) 
  --where ID=药名ID_IN; 

  --别名的处理 
  Insert Into 收费项目别名
    (收费细目id, 名称, 性质, 简码, 码类)
    Select 药品id_In, 名称, 性质, 简码, 码类 From 诊疗项目别名 Where 诊疗项目id = 药名id_In;
  If 数字码_In Is Not Null Then
    Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (药品id_In, v_名称, 1, 数字码_In, 3);
  End If;
  If (品名_In Is Not Null) And (拼音_In Is Not Null) Then
    Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (药品id_In, 品名_In, 3, 拼音_In, 1);
  End If;
  If (品名_In Is Not Null) And (五笔_In Is Not Null) Then
    Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (药品id_In, 品名_In, 3, 五笔_In, 2);
  End If;

  --定价信息 
  If 收入id_In Is Not Null Then
    v_No := Nextno(9);
    Insert Into 收费价目
      (ID, 原价id, 收费细目id, 原价, 现价, 收入项目id, 变动原因, 调价说明, 调价人, 执行日期, 终止日期, NO, 序号)
    Values
      (收费价目_Id.Nextval, Null, 药品id_In, 0, 当前售价_In, 收入id_In, 1, '新增定价', User, Sysdate,
       To_Date('3000-01-01', 'YYYY-MM-DD'), v_No, 1);
  End If;

  --药品生产商比较增加 
  If 产地_In Is Not Null Then
    Update 药品生产商 Set 名称 = 产地_In Where 名称 = 产地_In;
    If Sql%RowCount = 0 Then
      Insert Into 药品生产商
        (编码, 名称, 简码)
        Select Nvl(Max(To_Number(编码)), 0) + 1, 产地_In, zlSpellCode(产地_In, 10) From 药品生产商;
    End If;
  End If;

  --插入该规格的服务科室 
  Insert Into 收费执行科室
    (收费细目id, 病人来源, 开单科室id, 执行科室id)
    Select 药品id_In, 病人来源, 开单科室id, 执行科室id From 诊疗执行科室 Where 诊疗项目id = 药名id_In;

  --插入盘点属性 
  v_Kind := '中药%';

  For r_Storageid In c_Storageid Loop
    Insert Into 药品储备限额
      (库房id, 药品id, 上限, 下限, 盘点属性, 库房货位)
    Values
      (r_Storageid.部门id, 药品id_In, 0, 0, '1111', Null);
  End Loop;
  
  --药品精度调整(零差价模式时)
  Zl_药品卫材精度_零差价调整;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_草药规格_Insert;
/

--105308:李业庆,2016-10-20,药品零差价管理药品规格新增字段
Create Or Replace Procedure Zl_草药规格_Update
(
  药品id_In         In 药品规格.药品id%Type,
  编码_In           In 收费项目目录.编码%Type,
  规格_In           In 收费项目目录.规格%Type,
  产地_In           In 收费项目目录.产地%Type := Null,
  品名_In           In 收费项目别名.名称%Type := Null,
  拼音_In           In 收费项目别名.简码%Type := Null,
  五笔_In           In 收费项目别名.简码%Type := Null,
  数字码_In         In 收费项目别名.简码%Type := Null,
  标识码_In         In 药品规格.标识码%Type := Null,
  药品来源_In       In 药品规格.药品来源%Type := Null,
  批准文号_In       In 药品规格.批准文号%Type := Null,
  注册商标_In       In 药品规格.注册商标%Type := Null,
  售价单位_In       In 收费项目目录.计算单位%Type := Null,
  剂量系数_In       In 药品规格.剂量系数%Type := Null,
  门诊单位_In       In 药品规格.门诊单位%Type := Null,
  门诊包装_In       In 药品规格.门诊包装%Type := Null,
  药库单位_In       In 药品规格.药库单位%Type := Null,
  药库包装_In       In 药品规格.药库包装%Type := Null,
  申领单位_In       In 药品规格.申领单位%Type := 1,
  申领阀值_In       In 药品规格.申领阀值%Type := Null,
  是否变价_In       In 收费项目目录.是否变价%Type := Null,
  指导批发价_In     In 药品规格.指导批发价%Type := Null,
  扣率_In           In 药品规格.扣率%Type := 95,
  指导零售价_In     In 药品规格.指导零售价%Type := Null,
  加成率_In         In 药品规格.加成率%Type := Null,
  管理费比例_In     In 药品规格.管理费比例%Type := Null,
  药价级别_In       In 药品规格.药价级别%Type := Null,
  费用类型_In       In 收费项目目录.费用类型%Type := Null,
  服务对象_In       In 收费项目目录.服务对象%Type := Null,
  Gmp认证_In        In 药品规格.Gmp认证%Type := 0,
  招标药品_In       In 药品规格.招标药品%Type := 0,
  屏蔽费别_In       In 收费项目目录.屏蔽费别%Type := 0,
  住院可否分零_In   In 药品规格.住院可否分零%Type := 0,
  药库分批_In       In 药品规格.药库分批%Type := Null,
  药房分批_In       In 药品规格.药房分批%Type := Null,
  最大效期_In       In 药品规格.最大效期%Type := Null,
  差价让利比_In     In 药品规格.差价让利比%Type := 0,
  成本价_In         In 药品规格.成本价%Type := 0,
  当前售价_In       In 收费价目.现价%Type := 0,
  收入id_In         In 收费价目.收入项目id%Type := Null,
  合同单位id_In     In 药品规格.合同单位id%Type := Null,
  说明_In           In 收费项目目录.说明%Type := Null,
  动态分零_In       In 药品规格.动态分零%Type := 0,
  发药类型_In       In 药品规格.发药类型%Type := Null,
  备选码_In         In 收费项目目录.备选码%Type := Null,
  增值税率_In       In 药品规格.增值税率%Type := Null,
  基本药物_In       In 药品规格.基本药物%Type := Null,
  中药形态_In       In 药品规格.中药形态%Type := Null,
  站点_In           In 收费项目目录.站点%Type := Null,
  是否常备_In       In 药品规格.是否常备%Type := Null,
  病案费目_In       In 收费项目目录.病案费目%Type := Null,
  门诊可否分零_In   In 药品规格.门诊可否分零%Type := 0,
  送货单位_In       药品规格.送货单位%Type := Null,
  送货包装_In       药品规格.送货包装%Type := Null,
  是否摆药_In       药品规格.是否摆药%Type := Null,
  是否零差价管理_In In 药品规格.是否零差价管理%Type := Null
) Is
  v_药名id   诊疗项目目录.Id%Type;
  v_名称     诊疗项目目录.名称%Type;
  v_是否变价 收费项目目录.是否变价%Type; --允许定价药品随时改为时价，时价药品只能在未发生的情况下修改为定价，其它情况不允许修改定价属性 
  v_发生     Number(2);
  Err_Notfind Exception;
  v_No         收费价目.No%Type;
  v_Temp       收费项目目录.病案费目%Type;
  v_病案费目   收费项目目录.病案费目%Type;
  n_指导差价率 药品规格.指导差价率%Type;
Begin
  v_病案费目 := 病案费目_In;
  --判断病案费目 
  If v_病案费目 Is Null Then
    If 收入id_In Is Not Null Then
      Begin
        Select 病案费目 Into v_Temp From 收入项目 Where ID = 收入id_In;
      Exception
        When Others Then
          v_Temp := Null;
      End;
      If v_Temp Is Not Null Then
        v_病案费目 := v_Temp;
      End If;
    End If;
  End If;
  --通用名称 
  Select ID, 名称
  Into v_药名id, v_名称
  From 诊疗项目目录
  Where ID = (Select 药名id From 药品规格 Where 药品id = 药品id_In);
  --取原始的定价属性 
  Select 是否变价 Into v_是否变价 From 收费项目目录 Where ID = 药品id_In;
  --规格信息 
  Update 收费项目目录
  Set 编码 = 编码_In, 名称 = v_名称, 规格 = 规格_In, 产地 = 产地_In, 计算单位 = 售价单位_In, 费用类型 = 费用类型_In, 服务对象 = 服务对象_In, 屏蔽费别 = 屏蔽费别_In,
      病案费目 = v_病案费目, 说明 = 说明_In, 备选码 = 备选码_In, 站点 = 站点_In
  Where ID = 药品id_In;
  If Sql%RowCount = 0 Then
    Raise Err_Notfind;
  End If;
  n_指导差价率 := (1 - 1 / (1 + 加成率_In / 100)) * 100;
  Update 药品规格
  Set 标识码 = 标识码_In, 药品来源 = 药品来源_In, 批准文号 = 批准文号_In, 注册商标 = 注册商标_In, 剂量系数 = 剂量系数_In, 门诊单位 = 门诊单位_In, 门诊包装 = 门诊包装_In,
      住院单位 = 门诊单位_In, 住院包装 = 门诊包装_In, 药库单位 = 药库单位_In, 药库包装 = 药库包装_In, 申领单位 = 申领单位_In, 申领阀值 = 申领阀值_In, 指导批发价 = 指导批发价_In,
      扣率 = 扣率_In, 指导零售价 = 指导零售价_In, 指导差价率 = n_指导差价率, 管理费比例 = 管理费比例_In, 药价级别 = 药价级别_In, 住院可否分零 = 住院可否分零_In,
      药库分批 = 药库分批_In, 药房分批 = 药房分批_In, 最大效期 = 最大效期_In, 招标药品 = 招标药品_In, Gmp认证 = Gmp认证_In, 差价让利比 = 差价让利比_In,
      合同单位id = 合同单位id_In, 动态分零 = 动态分零_In, 发药类型 = 发药类型_In, 增值税率 = 增值税率_In, 基本药物 = 基本药物_In, 中药形态 = 中药形态_In, 是否常备 = 是否常备_In,
      门诊可否分零 = 门诊可否分零_In, 送货单位 = 送货单位_In, 送货包装 = 送货包装_In, 加成率 = 加成率_In, 是否摆药 = 是否摆药_In, 是否零差价管理 = 是否零差价管理_In
  Where 药品id = 药品id_In;

  --朱玉宝修改：建立药品（西成药、中成药）时，缺省服务对象为门诊和住院，因此修改规格药品时，不再根据规格药品的服务对象更新药品的服务对象 
  --诊疗项目服务对象的更改 
  --select nvl(sum(distinct I.服务对象),0) into v_对象 
  --from 收费项目目录 I,药品规格 S 
  --where I.ID=S.药品ID and S.药名ID=v_药名ID; 
  --update 诊疗项目目录 
  --set 服务对象=decode(v_对象,0,0,1,1,2,2,3) 
  --where ID=v_药名ID; 

  --别名的处理 
  If 数字码_In Is Null Then
    Delete 收费项目别名 Where 收费细目id = 药品id_In And 性质 = 1 And 码类 = 3;
  Else
    Update 收费项目别名 Set 名称 = v_名称, 简码 = 数字码_In Where 收费细目id = 药品id_In And 性质 = 1 And 码类 = 3;
    If Sql%RowCount = 0 Then
      Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (药品id_In, v_名称, 1, 数字码_In, 3);
    End If;
  End If;
  If 品名_In Is Null Then
    Delete 收费项目别名 Where 收费细目id = 药品id_In And 性质 = 3;
  Else
    If 拼音_In Is Null Then
      Delete 收费项目别名 Where 收费细目id = 药品id_In And 性质 = 3 And 码类 = 1;
    Else
      Update 收费项目别名 Set 名称 = 品名_In, 简码 = 拼音_In Where 收费细目id = 药品id_In And 性质 = 3 And 码类 = 1;
      If Sql%RowCount = 0 Then
        Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (药品id_In, 品名_In, 3, 拼音_In, 1);
      End If;
    End If;
    If 五笔_In Is Null Then
      Delete 收费项目别名 Where 收费细目id = 药品id_In And 性质 = 3 And 码类 = 2;
    Else
      Update 收费项目别名 Set 名称 = 品名_In, 简码 = 五笔_In Where 收费细目id = 药品id_In And 性质 = 3 And 码类 = 2;
      If Sql%RowCount = 0 Then
        Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (药品id_In, 品名_In, 3, 五笔_In, 2);
      End If;
    End If;
  End If;

  --定价信息：如果已经有发生，则不允许直接更改这些信息 
  Select Nvl(Count(*), 0) Into v_发生 From 药品收发记录 Where 药品id = 药品id_In And Rownum < 2;
  If v_发生 = 0 Then
    Update 收费项目目录 Set 是否变价 = 是否变价_In Where ID = 药品id_In;
    Update 药品规格 Set 成本价 = 成本价_In Where 药品id = 药品id_In;
    If 收入id_In Is Not Null Then
      Update 收费价目
      Set 现价 = 当前售价_In, 收入项目id = 收入id_In, 变动原因 = 1, 调价说明 = '修改定价', 调价人 = User
      Where 收费细目id = 药品id_In And (Sysdate Between 执行日期 And 终止日期 Or Sysdate >= 执行日期 And 终止日期 Is Null) And 变动原因 = 1;
      If Sql%RowCount = 0 Then
        v_No := Nextno(9);
        Insert Into 收费价目
          (ID, 原价id, 收费细目id, 原价, 现价, 收入项目id, 变动原因, 调价说明, 调价人, 执行日期, 终止日期, NO, 序号)
        Values
          (收费价目_Id.Nextval, Null, 药品id_In, 0, 当前售价_In, 收入id_In, 1, '新增定价', User, Sysdate,
           To_Date('3000-01-01', 'YYYY-MM-DD'), v_No, 1);
      End If;
    End If;
  Else
    --定价药品随时可改为时价 
    If v_是否变价 = 0 And 是否变价_In = 1 Then
      Update 收费项目目录 Set 是否变价 = 是否变价_In Where ID = 药品id_In;
    End If;
    --发生业务数据时，不能修改价格但是可以修改收入项目 
    Update 收费价目
    Set 收入项目id = 收入id_In
    Where 收费细目id = 药品id_In And (Sysdate Between 执行日期 And 终止日期 Or Sysdate >= 执行日期 And 终止日期 Is Null) And 变动原因 = 1;
  End If;

  --药品生产商比较增加 
  If 产地_In Is Not Null Then
    Update 药品生产商 Set 名称 = 产地_In Where 名称 = 产地_In;
    If Sql%RowCount = 0 Then
      Insert Into 药品生产商
        (编码, 名称, 简码)
        Select Nvl(Max(To_Number(编码)), 0) + 1, 产地_In, zlSpellCode(产地_In, 10) From 药品生产商;
    End If;
  End If;
  
  --药品精度调整(零差价模式时)
  Zl_药品卫材精度_零差价调整;
Exception
  When Err_Notfind Then
    Raise_Application_Error(-20101, '[ZLSOFT]该规格不存在，可能已被其他用户删除！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_草药规格_Update;
/

--99679:李业庆,2017-02-22,销售出库价格取原始价格，金额位数按流通参数确定
Create Or Replace Procedure Zl_药品收发记录_销售出库
(
  Id_In           In 门诊费用记录.Id%Type,
  药品摘要_In     药品收发记录.摘要%Type := Null,
  频次_In         药品收发记录.频次%Type := Null,
  单量_In         药品收发记录.单量%Type := Null,
  用法_In         药品收发记录.用法%Type := Null,
  煎法_In         药品收发记录.外观%Type := Null,
  期效_In         药品收发记录.扣率%Type := Null,
  计价特性_In     药品收发记录.扣率%Type := Null,
  主页id_In       未发药品记录.主页id%Type := Null,
  备货材料_In     Number := 0,
  备货材料批次_In 药品收发记录.批次%Type := Null
) Is
  ----------------------------------
  --功能：收费、划价时按照参数设置分解药品并产生相应的收发记录
  --规则：
  --      1、循环游标判断总出库数量与游标中每条记录数量是否充足，如果充足就是总数量，不充足挨个遍历直到数量直到遍历完并退出
  --      2、金额计算方式：定价取收费价目表现价，时价分批取库存表零售价，时价不分批，零售金额/实际数量，并将所有批次的金额累加起来为总出库金额
  --参数：
  --      Id_In：门诊费用记录或者住院费用记录ID
  --      备货材料_In：只有高值卫材才需要传入，非0表示是高值卫材
  --      备货材料批次_In：只有高值卫材才需要传入，非空表示是高值卫材的批次
  --      药品摘要_In：可选参数
  --      频次_In；单量_In；用法_In；煎法_In；期效_In；计价特性_In，可选参数，医嘱记录产生
  -----------------------------------
  Cursor c_Stock
  (
    n_Outmode  Number,
    n_库房id   药品收发记录.库房id%Type,
    n_药品id   药品收发记录.药品id%Type,
    n_备货材料 Number,
    n_备货批次 药品收发记录.批次%Type
  ) Is
    Select 库房id, 药品id, 批次, 效期, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 灭菌效期, 批准文号, 平均成本价, 零售价,
           上次扣率, 商品条码, 内部条码
    From 药品库存
    Where 药品id = n_药品id And 库房id = n_库房id And 性质 = 1 And
          Decode(n_备货材料, 0, 0, Nvl(n_备货批次, 0)) = Decode(n_备货材料, 0, 0, Nvl(n_备货批次, 0)) And
          (Nvl(批次, 0) = 0 Or 效期 Is Null Or 效期 > Trunc(Sysdate)) And Nvl(可用数量, 0) > 0
    Order By Decode(n_Outmode, 1, 效期, Null), Nvl(批次, 0);
  r_Stock c_Stock%RowType;

  n_Outmode      Number;
  n_分批         药品规格.药房分批%Type;
  n_时价         收费项目目录.是否变价%Type;
  n_当前数量     药品库存.实际数量%Type;
  n_费用金额小数 Number;
  n_费用单价小数 Number;
  n_流通金额小数 Number;
  n_流通单价小数 Number;
  n_标准单价     收费价目.现价%Type;
  n_当前单价     收费价目.现价%Type;
  n_类别         药品单据性质.类别id%Type;
  n_总金额       Number;
  n_总数量       药品库存.实际数量%Type;
  n_单据         药品单据性质.单据%Type;
  n_跟踪在用     材料特性.跟踪在用%Type;
  n_序号         门诊费用记录.序号%Type;
  v_名称         收费项目目录.名称%Type;
  n_虚拟库房id   部门表.Id%Type;
  n_库房id       部门表.Id%Type;
  n_优先级       身份.优先级%Type;
  n_Count        Number;
  Err_Custom Exception;
  v_Rust     Varchar2(300);
  v_Error    Varchar2(255);
  v_部门名称 部门表.名称%Type;

  v_单据类别   Varchar2(10);
  v_No         药品收发记录.No%Type;
  n_对方部门id 药品收发记录.对方部门id%Type;
  n_收费细目id 药品收发记录.药品id%Type;
  n_总出库数量 药品库存.实际数量%Type;
  n_发药库房id 药品收发记录.库房id%Type;
  n_记录性质   门诊费用记录.记录性质%Type;
  v_收费类别   门诊费用记录.收费类别%Type;
  n_多病人单   住院费用记录.多病人单%Type;
  n_医嘱序号   门诊费用记录.医嘱序号%Type;
  v_姓名       门诊费用记录.姓名%Type;
  n_付数       门诊费用记录.付数%Type;
  v_操作员     门诊费用记录.操作员姓名%Type;
  d_登记时间   门诊费用记录.登记时间%Type;
  n_门诊标志   门诊费用记录.门诊标志%Type;
  n_病人科室id 门诊费用记录.病人科室id%Type;
  n_标识号     门诊费用记录.标识号%Type;
  v_性别       门诊费用记录.性别%Type;
  n_年龄       门诊费用记录.年龄%Type;
  n_病人id     门诊费用记录.病人id%Type;
  v_发药窗口   门诊费用记录.发药窗口%Type;
  n_记录状态   门诊费用记录.记录状态%Type;

  --药品收发记录
  n_收发id   药品收发记录.Id%Type;
  n_扣率     药品收发记录.扣率%Type;
  d_灭菌效期 药品收发记录.灭菌效期%Type;
  d_灭菌日期 药品收发记录.灭菌日期%Type;

  v_其他出库no 药品收发记录.No%Type;
  n_出库序号   药品收发记录.序号%Type;
  n_定价售价   收费价目.现价%Type;
  n_出库检查   Number(1);
Begin
  Begin
    Select 类别, NO, 序号, 对方部门id, 收费细目id, 总出库数量, 发药库房id, 记录性质, 收费类别, 多病人单, 医嘱序号, 姓名, 付数, 划价人, 登记时间, 门诊标志, 病人科室id, 标识号, 性别,
           年龄, 病人id, 发药窗口, 记录状态, 标准单价
    Into v_单据类别, v_No, n_序号, n_对方部门id, n_收费细目id, n_总出库数量, n_发药库房id, n_记录性质, v_收费类别, n_多病人单, n_医嘱序号, v_姓名, n_付数, v_操作员,
         d_登记时间, n_门诊标志, n_病人科室id, n_标识号, v_性别, n_年龄, n_病人id, v_发药窗口, n_记录状态, n_标准单价
    From (Select '门诊' As 类别, NO, 序号, 病人科室id As 对方部门id, 收费细目id, 付数 * 数次 As 总出库数量, 执行部门id As 发药库房id, 记录性质, 收费类别, 0 As 多病人单,
                  医嘱序号, 姓名, 付数, 划价人, 登记时间, 门诊标志, 病人科室id, 标识号, 性别, 年龄, 病人id, 发药窗口, 记录状态, 标准单价
           From 门诊费用记录
           Where ID = Id_In
           Union All
           Select '住院' As 类别, NO, 序号, 病人科室id As 对方部门id, 收费细目id, 付数 * 数次 As 总出库数量, 执行部门id As 发药库房id, 记录性质, 收费类别, 多病人单, 医嘱序号,
                  姓名, 付数, 划价人, 登记时间, 门诊标志, 病人科室id, 标识号, 性别, 年龄, 病人id, 发药窗口, 记录状态, 标准单价
           From 住院费用记录
           Where ID = Id_In);
  Exception
    When Others Then
      v_No         := Null;
      n_对方部门id := 0;
      n_总出库数量 := 0;
  End;

  n_跟踪在用 := 0;
  --只处理有数量的
  If n_总出库数量 <> 0 Then
    --药品分批出库方式
    Select Zl_To_Number(Nvl(zl_GetSysParameter(150), 0)) Into n_Outmode From Dual;
    --金额小数位数
    Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')), Zl_To_Number(Nvl(zl_GetSysParameter(157), '5'))
    Into n_费用金额小数, n_费用单价小数
    From Dual;
  
    --取流通业务精度位数
    --类别:1-药品 2-卫材
    --内容：2-零售价 4-金额
    --单位：药品:1-售价 5-金额单位
    If v_收费类别 = '4' Then
      Select 精度 Into n_流通单价小数 From 药品卫材精度 Where 类别 = 2 And 内容 = 2 And 单位 = 1;
      Select 精度 Into n_流通金额小数 From 药品卫材精度 Where 类别 = 2 And 内容 = 4 And 单位 = 5;
    Else
      Select 精度 Into n_流通单价小数 From 药品卫材精度 Where 类别 = 1 And 内容 = 2 And 单位 = 1;
      Select 精度 Into n_流通金额小数 From 药品卫材精度 Where 类别 = 1 And 内容 = 4 And 单位 = 5;
    End If;
  
    n_总数量 := n_总出库数量;
  
    If v_收费类别 = '4' Then
      --收费类别=4表示是卫材单据
      If v_单据类别 = '门诊' Then
        If n_记录性质 = 1 Then
          n_单据 := 24;
        Else
          n_单据 := 25;
        End If;
      Elsif v_单据类别 = '住院' Then
        If n_多病人单 = 1 Then
          n_单据 := 26;
        Else
          n_单据 := 25;
        End If;
      End If;
    
      Select Nvl(a.在用分批, 0), Nvl(b.是否变价, 0), b.名称, c.现价
      Into n_分批, n_时价, v_名称, n_定价售价
      From 材料特性 A, 收费项目目录 B, 收费价目 C
      Where a.材料id = b.Id And b.Id = n_收费细目id And b.Id = c.收费细目id And Sysdate Between c.执行日期 And c.终止日期;
      --跟踪在用
      Select 跟踪在用 Into n_跟踪在用 From 材料特性 Where 材料id = n_收费细目id;
      --备货卫材需要判断是否设置了虚拟库房对照
      If Nvl(备货材料_In, 0) = 1 Then
        Begin
          Select 虚拟库房id Into n_虚拟库房id From 虚拟库房对照 Where 科室id = n_发药库房id And Rownum <= 1;
        Exception
          When Others Then
            n_虚拟库房id := 0;
        End;
        If Nvl(n_虚拟库房id, 0) = 0 Then
          Begin
            Select 名称 Into v_Error From 部门表 Where ID = n_发药库房id;
          Exception
            When Others Then
              v_Error := '';
          End;
          v_Error := '执行部门"' || Nvl(v_Error, '') || '"未设置虚拟部门,请在卫材参数设置中设置.';
          Raise Err_Custom;
        End If;
      End If;
    Else
      --收费类别<>4表示是药品单据，收费类别有"5，6，7"
      If v_单据类别 = '门诊' Then
        If n_记录性质 = 1 Then
          n_单据 := 8;
        Else
          n_单据 := 9;
        End If;
      Elsif v_单据类别 = '住院' Then
        If n_多病人单 = 1 Then
          n_单据 := 10;
        Else
          n_单据 := 9;
        End If;
      End If;
    
      Select Nvl(a.药房分批, 0), Nvl(b.是否变价, 0), b.名称, c.现价
      Into n_分批, n_时价, v_名称, n_定价售价
      From 药品规格 A, 收费项目目录 B, 收费价目 C
      Where a.药品id = b.Id And b.Id = n_收费细目id And b.Id = c.收费细目id And Sysdate Between c.执行日期 And c.终止日期;
    End If;
  
    --可能分批时价药品分解的批次变了
    If n_时价 = 1 Then
      --只有一个批次时,直接取该批次的单价
      --按照最小单位进行格式化
      v_Rust     := Zl_Fun_Getprice(n_收费细目id, n_发药库房id, n_总出库数量, 备货材料_In, 备货材料批次_In);
      n_当前单价 := To_Number(Substr(v_Rust, 1, Instr(v_Rust, '|') - 1));
    
      If round(n_当前单价,n_费用单价小数) <> Round(n_标准单价, n_费用单价小数) Then
        If n_医嘱序号 Is Null Then
          If v_收费类别 = '4' Then
            v_Error := '第 ' || n_序号 || ' 行的时价卫生材料"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
          Else
            v_Error := '第 ' || n_序号 || ' 行的时价药品"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
          End If;
        Else
          If v_收费类别 = '4' Then
            v_Error := '在处理病人"' || v_姓名 || '"时发现时价卫生材料"' || v_名称 || '"当前计算的单价发生变化。' || Chr(13) || Chr(10) ||
                       '请检查该病人是否同时使用了两笔相同的"' || v_名称 || '"！';
          Else
            v_Error := '在处理病人"' || v_姓名 || '"时发现时价药品"' || v_名称 || '"当前计算的单价发生变化。' || Chr(13) || Chr(10) ||
                       '请检查该病人是否同时使用了两笔相同的"' || v_名称 || '"！';
          End If;
        End If;
        Raise Err_Custom;
      End If;
    End If;
  
    If v_收费类别 In ('5', '6', '7') Or (v_收费类别 = '4' And Nvl(n_跟踪在用, 0) = 1) Then
      If Nvl(备货材料_In, 0) = 1 And v_收费类别 = '4' Then
        n_库房id := n_虚拟库房id;
      Else
        n_库房id := n_发药库房id;
      End If;
      
      Begin
        If v_收费类别 In ('5', '6', '7') Then
          Select 检查方式 Into n_出库检查 From 药品出库检查 Where 库房id = n_库房id;
        Else
          Select 检查方式 Into n_出库检查 From 材料出库检查 Where 库房id = n_库房id;
        End If;
      Exception
        When Others Then
          n_出库检查 := 0;
      End;
    
      If v_收费类别 = '4' Then
        Select 类别id Into n_类别 From 药品单据性质 Where 单据 = n_单据 + 16;
      Else
        Select 类别id Into n_类别 From 药品单据性质 Where 单据 = n_单据;
      End If;
    
      n_总金额 := 0;
      --打开游标
      Open c_Stock(n_Outmode, n_库房id, n_收费细目id, 备货材料_In, 备货材料批次_In);
      --循环遍历
      While n_总出库数量 <> 0 Loop
        Fetch c_Stock
          Into r_Stock;
        If c_Stock%NotFound Then
          --第一次就没有库存,分批或时价都不允许。
          --分批药品数量分解不完,也就是库存不足。
          If n_分批 = 1 Or n_时价 = 1 Then
            Close c_Stock;
            If n_单据 = 8 Or n_单据 = 24 Then
              If v_收费类别 = '4' Then
                v_Error := '第 ' || n_序号 || ' 行的分批或时价卫生材料"' || v_名称 || '"没有可用的库存！';
              Else
                v_Error := '第 ' || n_序号 || ' 行的分批或时价药品"' || v_名称 || '"没有可用的药品库存！';
              End If;
            Else
              --单据=9，10，25，26是记账单提示不一样
              If n_医嘱序号 Is Null Then
                If v_收费类别 = '4' Then
                  If Nvl(备货材料_In, 0) = 1 And Not (n_分批 = 1 Or n_时价 = 1) Then
                    v_Error := '第 ' || n_序号 || ' 行的卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
                  Else
                    v_Error := '第 ' || n_序号 || ' 行的分批或时价卫生材料"' || v_名称 || '"没有足够的材料库存' || Case
                                 When Nvl(备货材料_In, 0) = 0 Then
                                  '！'
                                 Else
                                  ',不能进行备货记帐！'
                               End;
                  End If;
                Else
                  v_Error := '第 ' || n_序号 || ' 行的分批或时价药品"' || v_名称 || '"没有足够的库存！';
                End If;
              Else
                If v_收费类别 = '4' Then
                  If Nvl(备货材料_In, 0) = 1 And Not (n_分批 = 1 Or n_时价 = 1) Then
                    v_Error := '在处理病人"' || v_姓名 || '"时发现卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
                  Else
                    v_Error := '在处理病人"' || v_姓名 || '"时发现分批或时价卫生材料"' || v_名称 || '"没有足够的材料库存' || Case
                                 When Nvl(备货材料_In, 0) = 0 Then
                                  '！'
                                 Else
                                  ',不能进行备货记帐！'
                               End;
                  End If;
                Else
                  v_Error := '在处理病人"' || v_姓名 || '"时发现分批或时价药品"' || v_名称 || '"没有足够的库存！';
                End If;
              End If;
            End If;
            Raise Err_Custom;
          End If;
        Elsif (n_分批 = 1 And Nvl(r_Stock.批次, 0) = 0) Or (n_分批 = 0 And Nvl(r_Stock.批次, 0) <> 0) Then
          Close c_Stock;
          If n_医嘱序号 Is Null Then
            If v_收费类别 = '4' Then
              v_Error := '第 ' || n_序号 || ' 行卫生材料"' || v_名称 || '"的在用分批属性与库存记录不相符,请检查材料数据的正确性！';
            Else
              v_Error := '第 ' || n_序号 || ' 行药品"' || v_名称 || '"的分批属性与库存记录不相符,请检查药品数据的正确性！';
            End If;
          Else
            If v_收费类别 = '4' Then
              v_Error := '在处理病人"' || v_姓名 || '"时发现卫生材料"' || v_名称 || '"的分批属性与库存记录不相符,请检查材料数据的正确性！';
            Else
              v_Error := '在处理病人"' || v_姓名 || '"时发现药品"' || v_名称 || '"的分批属性与库存记录不相符,请检查药品数据的正确性！';
            End If;
          End If;
          Raise Err_Custom;
        End If;
      
        If c_Stock%Found Then
          If Nvl(r_Stock.实际数量, 0) = 0 And (n_总出库数量 > 0 Or n_时价 = 1) And n_出库检查 = 2 Then
            --实际数量为零时，如果严格控制库存，不允许出库
            --实际数量不为零，金额为零，可能是正常的零价格管理。
            --负数的情况相当于入库,这种情况应是允许的；但时价需要计算价格，必须要有实际数量。
            Close c_Stock;
            If n_医嘱序号 Is Null Then
              If v_收费类别 = '4' Then
                v_Error := '第 ' || n_序号 || ' 行的卫生材料"' || v_名称 || '"当前无库存实际数量，可能存在尚未退料的记录，当前不能出库。';
              Else
                v_Error := '第 ' || n_序号 || ' 行药品"' || v_名称 || '"当前无库存实际数量，可能存在尚未退药的记录，当前不能出库。';
              End If;
            Else
              If v_收费类别 = '4' Then
                v_Error := '在处理病人"' || v_姓名 || '"时发现卫生材料"' || v_名称 || '"当前无库存实际数量，可能存在尚未退料的记录，当前不能出库。';
              Else
                v_Error := '在处理病人"' || v_姓名 || '"时发现药品"' || v_名称 || '"当前无库存实际数量，可能存在尚未退药的记录，当前不能出库。';
              End If;
            End If;
            Raise Err_Custom;
          End If;
        End If;
      
        If n_分批 = 1 Or n_时价 = 1 Then
          --对于不分批的时价只可能分解一次,分解不完上面判断了.它分解是为了计算单价.
          --每次分解取小者,库存不够分解不完在上面判断.
          If n_总出库数量 <= Nvl(r_Stock.可用数量, 0) Then
            n_当前数量 := n_总出库数量;
          Else
            n_当前数量 := Nvl(r_Stock.可用数量, 0);
          End If;
          If n_时价 = 1 Then
            n_当前单价 := Nvl(r_Stock.零售价, Nvl(r_Stock.实际金额 / r_Stock.实际数量, 0));
          Elsif n_分批 = 1 Then
            n_当前单价 := n_定价售价;
          End If;
        Else
          --定价不分批
          --非门诊单据且是高值卫材需要检查库存
          If n_单据 <> 8 Or n_单据 <> 24 Then
            If Nvl(备货材料_In, 0) = 1 And v_收费类别 = '4' Then
              If n_总出库数量 > Nvl(r_Stock.可用数量, 0) Then
                --不分批, 但又是备货卫材方式出库的,则需要检查当前库存是否充足.
                v_Error := '第 ' || n_序号 || ' 行的卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
                Raise Err_Custom;
              End If;
            End If;
          End If;
          n_当前数量 := n_总出库数量;
          n_当前单价 := n_定价售价;
        End If;
      
        --药品收发记录
        If c_Stock%Found Then
          --卫材灭菌效期:一次性材料且有效期
          If v_收费类别 = '4' Then
            n_Count := 0;
            Begin
              Select 灭菌效期 Into n_Count From 材料特性 Where Nvl(一次性材料, 0) = 1 And 材料id = n_收费细目id;
            Exception
              When Others Then
                Null;
            End;
            If Nvl(n_Count, 0) > 0 Then
              d_灭菌效期 := r_Stock.灭菌效期;
              d_灭菌日期 := d_灭菌效期 - n_Count * 30;
            End If;
          End If;
        End If;
      
        Select Nvl(Max(序号), 0) + 1 Into n_序号 From 药品收发记录 Where 单据 = n_单据 And 记录状态 = 1 And NO = v_No;
      
        n_扣率 := Null;
        If 期效_In Is Not Null Or 计价特性_In Is Not Null Then
          n_扣率 := Nvl(期效_In, 0) || Nvl(计价特性_In, 0);
        End If;
      
        --分批药品,如果是只使用了一个批次,则要填写付数
        If n_分批 = 1 And n_当前数量 <> n_总数量 Then
          n_Count := 1;
        Else
          n_Count := 0;
        End If;
      
        Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
        --修改的原单据号存放在摘要中
        Insert Into 药品收发记录
          (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人,
           填制日期, 费用id, 频次, 单量, 用法, 外观, 扣率, 灭菌效期, 灭菌日期, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
        Values
          (n_收发id, 1, n_单据, v_No, n_序号, n_发药库房id, n_对方部门id, n_类别, -1, n_收费细目id, r_Stock.批次, r_Stock.上次产地, r_Stock.上次批号,
           r_Stock.效期, Decode(n_Count, 1, 1, n_付数), Decode(n_Count, 1, n_当前数量, n_当前数量 / n_付数),
           Decode(n_Count, 1, n_当前数量, n_当前数量 / n_付数), n_当前单价, Round(n_当前单价 * n_当前数量, n_流通金额小数), 药品摘要_In, v_操作员, d_登记时间,
           Id_In, 频次_In, 单量_In, 用法_In, 煎法_In, n_扣率, d_灭菌效期, d_灭菌日期, r_Stock.上次供应商id, r_Stock.上次生产日期, r_Stock.批准文号,
           r_Stock.商品条码, r_Stock.内部条码);
      
        --药品库存(普通情况可能没有记录)
        Zl_药品库存_Update(n_收发id, 0, 1);
      
        --产生其他出库单 ，只有高值卫材才需要处理
        If v_收费类别 = '4' And Nvl(备货材料_In, 0) = 1 Then
          Begin
            Select Max(a.No), Max(a.序号)
            Into v_其他出库no, n_出库序号
            From 药品收发记录 A, 住院费用记录 B
            Where a.费用id = b.Id And b.No = v_No And 记录性质 = 2 And b.门诊标志 = n_门诊标志 And
                  Instr(',8,9,10,21,24,25,26,', ',' || a.单据 || ',') > 0;
          Exception
            When Others Then
              v_其他出库no := Null;
          End;
          If v_其他出库no Is Null Then
            v_其他出库no := Nextno(74, n_虚拟库房id, Null, 1);
          End If;
          If v_其他出库no Is Null Then
            v_Error := '在生成卫生材料的其他出库单时,获取相关的出库NO有误,请检查出库单的规则是否有误!';
            Raise Err_Custom;
          End If;
          If Nvl(n_病人科室id, 0) <> 0 Then
            Select 名称 Into v_部门名称 From 部门表 Where ID = n_病人科室id;
          End If;
          v_Error := LPad(' ', 4);
          v_Error := Substr('病人姓名:' || v_姓名 || v_Error || '性别:' || v_性别 || v_Error || '年龄' || n_年龄 || v_Error || '门诊号:' ||
                            Nvl(n_标识号, '') || v_Error || '病人科室:' || v_部门名称, 1, 100);
        
          n_出库序号 := Nvl(n_出库序号, 0) + 1;
          Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
        
          --高值卫材类别id默认19是为了方便统计，因为其他出库可以设置很多类别，所以默认19
          Insert Into 药品收发记录
            (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人,
             填制日期, 费用id, 频次, 发药窗口, 单量, 用法, 外观, 扣率, 灭菌效期, 灭菌日期, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
          Values
            (n_收发id, 1, 21, v_其他出库no, n_出库序号, n_虚拟库房id, n_对方部门id, 19, -1, n_收费细目id, r_Stock.批次, r_Stock.上次产地,
             r_Stock.上次批号, r_Stock.效期, 1, n_当前数量, n_当前数量,n_当前单价,Round(n_当前单价 * n_当前数量, n_流通金额小数), v_Error, v_操作员,
             d_登记时间, Id_In, 频次_In, v_发药窗口, 单量_In, 用法_In, 煎法_In, n_扣率, d_灭菌效期, d_灭菌日期, r_Stock.上次供应商id, r_Stock.上次生产日期,
             r_Stock.批准文号, r_Stock.商品条码, r_Stock.内部条码);
        
          --药品库存(普通情况可能没有记录)
          Zl_药品库存_Update(n_收发id, 0, 1);
        End If;
      
        v_Error      := '';
        n_总出库数量 := n_总出库数量 - n_当前数量;
        n_总金额     := n_总金额 + n_当前数量 * n_当前单价;
      End Loop;
    
      --未发药品记录
      Update 未发药品记录
      Set 病人id = n_病人id, 姓名 = v_姓名, 发药窗口 = v_发药窗口, 主页id = 主页id_In
      Where 单据 = n_单据 And NO = v_No And Nvl(库房id, 0) = Nvl(n_发药库房id, 0);
      If Sql%RowCount = 0 Then
        --取身份优先级
        Begin
          Select b.优先级 Into n_优先级 From 病人信息 A, 身份 B Where a.身份 = b.名称(+) And a.病人id = n_病人id;
        Exception
          When Others Then
            Null;
        End;
        Insert Into 未发药品记录
          (单据, NO, 病人id, 主页id, 姓名, 优先级, 库房id, 对方部门id, 填制日期, 已收费, 打印状态, 发药窗口)
        Values
          (n_单据, v_No, n_病人id, 主页id_In, v_姓名, n_优先级, n_发药库房id, n_对方部门id, d_登记时间, n_记录状态, 0, v_发药窗口);
      End If;
    
      --处理未发药记录状态
      Zl_Prescription_Type_Update(v_No, n_记录性质, n_收费细目id, v_收费类别);
    
      Close c_Stock;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_销售出库;
/

--99679:李业庆,2017-02-22,发药成本价取原始价格，金额位数按流通参数确定
--105308:李业庆,2017-02-22,零差价特殊处理
--106576:李业庆,2017-03-02,零差价升级前售价不是取最大位数的处理
--106523:李业庆,2017-03-05,退药再发药时取原始发药时的成本价
Create Or Replace Procedure Zl_药品收发记录_处方发药
(
  Partid_In        In 药品收发记录.库房id%Type,
  Bill_In          In 药品收发记录.单据%Type,
  No_In            In 药品收发记录.No%Type,
  People_In        In 药品收发记录.审核人%Type,
  配药人_In        In 药品收发记录.配药人%Type := Null,
  校验人_In        In 药品收发记录.填制人%Type := Null,
  发药方式_In      In 药品收发记录.发药方式%Type := 1,
  发药时间_In      In 药品收发记录.审核日期%Type := Null,
  操作员编号_In    In 人员表.编号%Type := Null,
  操作员姓名_In    In 人员表.姓名%Type := Null,
  Intdigit_In      In Number := 2,
  Intautoverify_In In Number := 0,
  门诊_In          In Number := 1,
  核查人_In        In 药品收发记录.核查人%Type := Null,
  未取药_In        In 药品收发记录.是否未取药%Type := Null,
  汇总发药号_In    In 药品收发记录.汇总发药号%Type := Null
) Is
  --住院病人
  Cursor c_Modifybillin Is
    Select a.Id, a.药品id, a.入出类别id, a.入出系数, a.费用id, Nvl(a.实际数量, 0) * Nvl(a.付数, 1) 数量, Nvl(a.零售金额, 0) 金额, Nvl(a.批次, 0) 批次,
           a.供药单位id, a.成本价, a.批号, a.产地, a.效期, a.生产日期, a.批准文号, b.病人id, b.序号, Nvl(c.处方类型, Nvl(a.注册证号, 0)) 处方类型,
           Nvl(a.零售价, 0) As 零售价, a.记录状态
    From 药品收发记录 A, 住院费用记录 B, 未发药品记录 C
    Where a.单据 = c.单据 And a.No = c.No And Nvl(a.库房id, 0) = Nvl(c.库房id, 0) And a.No = No_In And a.单据 = Bill_In And
          (a.库房id + 0 = Partid_In Or a.库房id Is Null) And Nvl(a.摘要, '小宝') <> '拒发' And a.费用id = b.Id And
          Nvl(b.执行状态, 0) <> 1 And Mod(a.记录状态, 3) = 1 And a.审核人 Is Null;

  --门诊病人
  Cursor c_Modifybillout Is
    Select a.Id, a.药品id, a.入出类别id, a.入出系数, a.费用id, Nvl(a.实际数量, 0) * Nvl(a.付数, 1) 数量, Nvl(a.零售金额, 0) 金额, Nvl(a.批次, 0) 批次,
           a.供药单位id, a.成本价, a.批号, a.产地, a.效期, a.生产日期, a.批准文号, b.病人id, b.序号, Nvl(c.处方类型, Nvl(a.注册证号, 0)) 处方类型,
           Nvl(a.零售价, 0) As 零售价, b.No, b.记录性质, a.记录状态
    From 药品收发记录 A, 门诊费用记录 B, 未发药品记录 C
    Where a.单据 = c.单据 And a.No = c.No And Nvl(a.库房id, 0) = Nvl(c.库房id, 0) And a.No = No_In And a.单据 = Bill_In And
          (a.库房id + 0 = Partid_In Or a.库房id Is Null) And Nvl(a.摘要, '小宝') <> '拒发' And a.费用id = b.Id And
          Nvl(b.执行状态, 0) <> 1 And Mod(a.记录状态, 3) = 1 And a.审核人 Is Null
    Order By 药品id;

  v_Modifybillin  c_Modifybillin%RowType;
  v_Modifybillout c_Modifybillout%RowType;

  --只读变量
  Dbl差价率  Number;
  v_核查日期 药品收发记录.核查日期%Type;
  --可写变量
  Dbl实际金额       药品收发记录.零售金额%Type;
  Dbl成本金额       药品收发记录.成本金额%Type;
  Dbl实际差价       药品收发记录.差价%Type;
  Date操作时间      药品收发记录.审核日期%Type;
  Bln收费与发药分离 Number(1);
  n_平均成本价      药品库存.平均成本价%Type;
  v_填制人          药品收发记录.填制人%Type;
  v_Error           Varchar2(4000);
  Err_Custom Exception;
  n_流通售价小数   Number;
  n_流通金额小数   Number;
  n_零差价管理模式 Number(1);
  n_药品零差价管理 Number(1);
Begin
  --取发药时间
  If 发药时间_In Is Null Then
    Select Sysdate Into Date操作时间 From Dual;
  Else
    Date操作时间 := 发药时间_In;
  End If;

  v_核查日期 := Date操作时间;
  Begin
    Select 0 Into Bln收费与发药分离 From 未发药品记录 Where 单据 = Bill_In And NO = No_In And 库房id + 0 = Partid_In;
  Exception
    When Others Then
      Bln收费与发药分离 := 1;
  End;

  --重写已发药处方的配药人和汇总发药号
  Update 药品收发记录
  Set 配药人 = Decode(配药人_In, Null, 配药人, 配药人_In), 配药日期 = Decode(配药人_In, Null, 配药日期, Date操作时间), 汇总发药号 = 汇总发药号_In
  Where NO = No_In And 单据 = Bill_In And (库房id + 0 = Partid_In Or 库房id Is Null) And Mod(记录状态, 3) = 1 And 审核人 Is Not Null;

  Begin
    Select 填制人
    Into v_填制人
    From 药品收发记录
    Where NO = No_In And 单据 = Bill_In And 库房id + 0 = Partid_In And 审核日期 Is Null And Rownum = 1
    For Update Nowait;
  Exception
    When Others Then
      v_Error := '已有其他用户在执行发药，不能重复操作！';
      Raise Err_Custom;
  End;

  --取流通业务精度位数
  --类别:1-药品 2-卫材
  --内容：2-零售价 4-金额
  --单位：药品:1-售价 5-金额单位
  Begin
    Select 精度 Into n_流通金额小数 From 药品卫材精度 Where 类别 = 1 And 内容 = 4 And 单位 = 5;
  Exception
    When Others Then
      n_流通金额小数 := 2;
  End;

  Begin
    Select 精度 Into n_流通售价小数 From 药品卫材精度 Where 类别 = 1 And 内容 = 2 And 单位 = 1;
  Exception
    When Others Then
      n_流通售价小数 := 2;
  End;

  Select Zl_To_Number(Nvl(zl_GetSysParameter(275), '0')) Into n_零差价管理模式 From Dual;

  --重新计算成本价、成本金额、零售金额及差价
  If 门诊_In = 1 Then
    --处理门诊数据
    For v_Modifybillout In c_Modifybillout Loop
      If n_零差价管理模式 <> 0 Then
        Select Nvl(是否零差价管理, 0) Into n_药品零差价管理 From 药品规格 Where 药品id = v_Modifybillout.药品id;
      End If;
    
      If v_Modifybillout.记录状态 = 1 Then
        --原始发药记录，取最新价格
        n_平均成本价 := Zl_Fun_Getoutcost(v_Modifybillout.药品id, v_Modifybillout.批次, Partid_In);
      
        If n_零差价管理模式 <> 0 And n_药品零差价管理 = 1 And
           (v_Modifybillout.零售价 = n_平均成本价 Or Round(v_Modifybillout.零售价, n_流通售价小数) = Round(n_平均成本价, n_流通售价小数)) Then
          Dbl成本金额 := Nvl(v_Modifybillout.金额, 0);
        Else
          Dbl成本金额 := Round(n_平均成本价 * Nvl(v_Modifybillout.数量, 0), n_流通金额小数);
        End If;
      Else
        --退药再发记录，取原始单据价格
        Select a.成本价
        Into n_平均成本价
        From 药品收发记录 A, 药品收发记录 B
        Where b.Id = v_Modifybillout.Id And a.单据 = b.单据 And a.No = b.No And a.库房id = b.库房id And a.药品id + 0 = b.药品id And
              a.序号 = b.序号 And Nvl(a.批次, 0) = Nvl(b.批次, 0) And (a.记录状态 = 1 Or Mod(a.记录状态, 3) = 0);
      
        Dbl成本金额 := Round(n_平均成本价 * Nvl(v_Modifybillout.数量, 0), n_流通金额小数);
      End If;
    
      --零售金额
      Dbl实际金额 := Nvl(v_Modifybillout.金额, 0);
      --差价
      Dbl实际差价 := Round(Dbl实际金额 - Dbl成本金额, n_流通金额小数);
    
      --更新药品收发记录的零售金额、成本金额、差价、审核人等信息
      Update 药品收发记录
      Set 成本价 = n_平均成本价, 成本金额 = Dbl成本金额, 差价 = Dbl实际差价, 库房id = Partid_In, 配药人 = Decode(配药人_In, Null, 配药人, 配药人_In),
          核查人 = 核查人_In, 核查日期 = v_核查日期, 配药日期 = Decode(配药人_In, Null, 配药日期, Date操作时间),
          填制人 = Decode(校验人_In, Null, 填制人, 校验人_In), 审核人 = Decode(People_In, Null, Zl_Username, People_In),
          审核日期 = Date操作时间, 发药方式 = 发药方式_In, 注册证号 = v_Modifybillout.处方类型, 是否未取药 = 未取药_In, 汇总发药号 = 汇总发药号_In
      Where ID = v_Modifybillout.Id;
    
      --处理库存
      Zl_药品库存_Update(v_Modifybillout.Id, 2, 1);
    
      --更新费用记录的执行状态(已执行)
      Update 门诊费用记录
      Set 执行状态 = 1, 执行人 = Decode(People_In, Null, Zl_Username, People_In), 执行部门id = Partid_In, 执行时间 = Date操作时间
      
      Where NO = v_Modifybillout.No And Mod(记录性质, 10) = v_Modifybillout.记录性质 And 记录状态 <> 2 And 序号 = v_Modifybillout.序号;
    
      --费用审核（重复审核也没有关系）
      If Intautoverify_In = 1 Then
        If Bill_In = 9 Then
          Zl_门诊记帐记录_Verify(No_In, 操作员编号_In, 操作员姓名_In, v_Modifybillout.序号, 发药时间_In);
        End If;
      End If;
    
      --处理调价修正
      Zl_药品收发记录_调价修正(v_Modifybillout.Id);
    End Loop;
  Else
    --处理住院数据
    For v_Modifybillin In c_Modifybillin Loop
      If n_零差价管理模式 <> 0 Then
        Select Nvl(是否零差价管理, 0) Into n_药品零差价管理 From 药品规格 Where 药品id = v_Modifybillin.药品id;
      End If;
    
      If v_Modifybillin.记录状态 = 1 Then
        --原始发药记录，取最新价格
        n_平均成本价 := Zl_Fun_Getoutcost(v_Modifybillin.药品id, v_Modifybillin.批次, Partid_In);
      
        If n_零差价管理模式 <> 0 And n_药品零差价管理 = 1 And
           (v_Modifybillin.零售价 = n_平均成本价 Or Round(v_Modifybillin.零售价, n_流通售价小数) = Round(n_平均成本价, n_流通售价小数)) Then
          Dbl成本金额 := Nvl(v_Modifybillin.金额, 0);
        Else
          Dbl成本金额 := Round(n_平均成本价 * Nvl(v_Modifybillin.数量, 0), n_流通金额小数);
        End If;
      Else
        --退药再发记录，取原始单据价格
        Select a.成本价
        Into n_平均成本价
        From 药品收发记录 A, 药品收发记录 B
        Where b.Id = v_Modifybillin.Id And a.单据 = b.单据 And a.No = b.No And a.库房id = b.库房id And a.药品id + 0 = b.药品id And
              a.序号 = b.序号 And Nvl(a.批次, 0) = Nvl(b.批次, 0) And (a.记录状态 = 1 Or Mod(a.记录状态, 3) = 0);
      
        Dbl成本金额 := Round(n_平均成本价 * Nvl(v_Modifybillin.数量, 0), n_流通金额小数);
      End If;
    
      --零售金额
      Dbl实际金额 := Nvl(v_Modifybillin.金额, 0);
      --差价
      Dbl实际差价 := Round(Dbl实际金额 - Dbl成本金额, n_流通金额小数);
    
      --更新药品收发记录的零售金额、成本金额、差价、审核人等信息
      Update 药品收发记录
      Set 成本价 = n_平均成本价, 成本金额 = Dbl成本金额, 差价 = Dbl实际差价, 库房id = Partid_In, 配药人 = Decode(配药人_In, Null, 配药人, 配药人_In),
          核查人 = 核查人_In, 核查日期 = v_核查日期, 配药日期 = Decode(配药人_In, Null, 配药日期, Date操作时间),
          填制人 = Decode(校验人_In, Null, 填制人, 校验人_In), 审核人 = Decode(People_In, Null, Zl_Username, People_In),
          审核日期 = Date操作时间, 发药方式 = 发药方式_In, 注册证号 = v_Modifybillout.处方类型, 汇总发药号 = 汇总发药号_In
      Where ID = v_Modifybillin.Id;
    
      --处理库存
      Zl_药品库存_Update(v_Modifybillin.Id, 2, 1);
    
      --更新费用记录的执行状态(已执行)
      Update 住院费用记录
      Set 执行状态 = 1, 执行人 = Decode(People_In, Null, Zl_Username, People_In), 执行部门id = Partid_In, 执行时间 = Date操作时间
      
      Where ID = v_Modifybillin.费用id;
    
      --费用审核（重复审核也没有关系）
      If Intautoverify_In = 1 Then
        If Bill_In = 9 Then
          Zl_住院记帐记录_Verify(No_In, 操作员编号_In, 操作员姓名_In, v_Modifybillin.序号, v_Modifybillin.病人id, 发药时间_In);
        End If;
      End If;
    
      --处理调价修正
      Zl_药品收发记录_调价修正(v_Modifybillin.Id);
    End Loop;
  End If;

  --更新或删除未发药品记录
  Delete 未发药品记录 Where NO = No_In And 单据 = Bill_In And (库房id + 0 = Partid_In Or 库房id Is Null);

  If Bill_In = 8 Then
    Begin
      --移动支付宝项目在发药后动态调用生成推送信息的过程
      Execute Immediate 'Begin zl_服务窗消息_发送(:1,:2); End;'
        Using 6, No_In || ',' || Partid_In;
    Exception
      When Others Then
        Null;
    End;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_处方发药;
/

--99679:李业庆,2017-02-22,发药成本价取原始价格，金额位数按流通参数确定
--105308:李业庆,2017-02-22,零差价特殊处理
--106576:李业庆,2017-03-02,零差价升级前售价不是取最大位数的处理
--106523:李业庆,2017-03-05,退药再发药时取原始发药时的成本价
Create Or Replace Procedure Zl_药品收发记录_批量发药
(
  Billinfo_In   In Varchar2, --格式:"id1,批次1|id2,批次2|....."
  Partid_In     In 药品收发记录.库房id%Type,
  People_In     In 药品收发记录.审核人%Type,
  Date_In       In 药品收发记录.审核日期%Type,
  发药方式_In   In 药品收发记录.发药方式%Type := 3,
  领药人_In     In 药品收发记录.领用人%Type := Null,
  汇总发药号_In In 药品收发记录.汇总发药号%Type := Null,
  Intdigit_In   In Number := 2,
  配药人_In     In 药品收发记录.配药人%Type := Null,
  核查人_In     In 药品收发记录.核查人%Type := Null
) Is
  --只读变量
  v_Infotmp     Varchar2(4000);
  v_Fields      Varchar2(4000);
  n_Billid      药品收发记录.Id%Type;
  n_批次        药品收发记录.批次%Type;
  Lng入出类别id Number(18);
  Int入出系数   Number;
  Int执行状态   Number;
  Int单据       药品收发记录.单据%Type;
  Strno         药品收发记录.No%Type;
  Lng库房id     药品收发记录.库房id%Type;
  Lng药品id     药品收发记录.药品id%Type;
  Lng费用id     药品收发记录.费用id%Type;
  Dbl差价率     Number;
  v_零售价      药品收发记录.零售价%Type;
  Int未发数     未发药品记录.未发数%Type;
  v_核查日期    药品收发记录.核查日期%Type;
  --可写变量
  Dbl实际数量 药品收发记录.实际数量%Type;
  Dbl实际金额 药品收发记录.零售金额%Type;
  Dbl成本金额 药品收发记录.成本金额%Type;
  Dbl实际差价 药品收发记录.差价%Type;
  --2002-07-31朱玉宝
  --LNGLAST批次 发药前确定的批次(已减可用数量)
  Str药名           Varchar2(200);
  Dbl可用数量       药品收发记录.填写数量%Type;
  Lnglast批次       药品收发记录.批次%Type;
  Lngcur批次        药品收发记录.批次%Type;
  Str批号           药品收发记录.批号%Type;
  Str效期           药品收发记录.效期%Type;
  n_上次供应商id    药品库存.上次供应商id%Type;
  n_上次采购价      药品库存.上次采购价%Type;
  v_上次产地        药品库存.上次产地%Type;
  d_上次生产日期    药品库存.上次生产日期%Type;
  v_批准文号        药品库存.批准文号%Type;
  n_记录状态        药品收发记录.记录状态%Type;
  n_平均成本价      药品库存.平均成本价%Type;
  n_发药方式        药品收发记录.发药方式%Type;
  v_摘要            药品收发记录.摘要%Type;
  Bln收费与发药分离 Number(1);
  v_Error           Varchar2(255);
  Err_Custom Exception;
  n_流通售价小数   Number;
  n_流通金额小数   Number;
  n_零差价管理模式 Number(1);
  n_药品零差价管理 Number(1);
Begin
  Select Sysdate Into v_核查日期 From Dual;
  If Billinfo_In Is Null Then
    v_Infotmp := Null;
  Else
    v_Infotmp := Billinfo_In || '|';
  End If;
  While v_Infotmp Is Not Null Loop
    --分解单据ID串
    v_Fields  := Substr(v_Infotmp, 1, Instr(v_Infotmp, '|') - 1);
    n_Billid  := Substr(v_Fields, 1, Instr(v_Fields, ',') - 1);
    n_批次    := Substr(v_Fields, Instr(v_Fields, ',') + 1);
    v_Infotmp := Replace('|' || v_Infotmp, '|' || v_Fields || '|');
  
    --获取该收发记录的单据、药品ID、库房ID,零售金额及实际数量、入出类别ID
    Begin
      Select a.单据, a.No, a.药品id, a.库房id, a.费用id, Nvl(a.零售价, 0), Nvl(a.零售金额, 0), Nvl(a.实际数量, 0) * Nvl(a.付数, 1), a.入出类别id,
             a.入出系数, Nvl(a.批次, 0), a.批号, a.效期, a.供药单位id, a.产地, a.生产日期, a.批准文号, Nvl(a.发药方式, 0), a.摘要, 记录状态
      Into Int单据, Strno, Lng药品id, Lng库房id, Lng费用id, v_零售价, Dbl实际金额, Dbl实际数量, Lng入出类别id, Int入出系数, Lnglast批次, Str批号, Str效期,
           n_上次供应商id, v_上次产地, d_上次生产日期, v_批准文号, n_发药方式, v_摘要, n_记录状态
      From 药品收发记录 A
      Where a.Id = n_Billid And a.审核日期 Is Null
      For Update Nowait;
    
      Select '[' || c.编码 || ']' || c.名称 Into Str药名 From 收费项目目录 C Where c.Id = Lng药品id;
    Exception
      When Others Then
        Int单据 := 0;
        v_Error := '已有其他用户在执行发药，不能重复操作！';
        Raise Err_Custom;
    End;
  
    --取流通业务精度位数
    --类别:1-药品 2-卫材
    --内容：2-零售价 4-金额
    --单位：药品:1-售价 5-金额单位
    Begin
      Select 精度 Into n_流通金额小数 From 药品卫材精度 Where 类别 = 1 And 内容 = 4 And 单位 = 5;
    Exception
      When Others Then
        n_流通金额小数 := 2;
    End;
  
    Begin
      Select 精度 Into n_流通售价小数 From 药品卫材精度 Where 类别 = 1 And 内容 = 2 And 单位 = 1;
    Exception
      When Others Then
        n_流通售价小数 := 2;
    End;
  
    Select Zl_To_Number(Nvl(zl_GetSysParameter(275), '0')) Into n_零差价管理模式 From Dual;
  
    If n_发药方式 = -1 Or v_摘要 = '拒发' Then
      Int单据 := 0;
    End If;
  
    If Int单据 > 0 Then
      If Nvl(n_批次, 0) = 0 Then
        Lngcur批次 := Lnglast批次;
      Else
        Lngcur批次 := Nvl(n_批次, 0);
      End If;
    
      --检查是否已经填写库房
      Bln收费与发药分离 := 0;
      If Lng库房id Is Null Then
        Bln收费与发药分离 := 1;
      End If;
      Lng库房id := Partid_In;
    
      --取该批药品的批号
      Begin
        Select 上次批号, 效期, Nvl(可用数量, 0), 上次供应商id, 上次产地, 上次生产日期, 批准文号, 上次采购价
        Into Str批号, Str效期, Dbl可用数量, n_上次供应商id, v_上次产地, d_上次生产日期, v_批准文号, n_上次采购价
        From 药品库存
        Where 库房id + 0 = Lng库房id And 药品id = Lng药品id And 性质 = 1 And Nvl(批次, 0) = Lngcur批次;
      Exception
        When Others Then
          n_上次采购价 := 0;
          Dbl可用数量  := 0;
      End;
    
      --可用数量不足则退出
      If Lngcur批次 <> Nvl(Lnglast批次, 0) Then
        If Dbl可用数量 < Dbl实际数量 And Lngcur批次 <> 0 Then
          v_Error := Str药名 || '的可用数量不足，操作中止！';
          Raise Err_Custom;
        End If;
      End If;
    
      If n_零差价管理模式 <> 0 Then
        Select Nvl(是否零差价管理, 0) Into n_药品零差价管理 From 药品规格 Where 药品id = Lng药品id;
      End If;
    
      If n_记录状态 = 1 Then
        --原始发药记录，取最新价格
        n_平均成本价 := Zl_Fun_Getoutcost(Lng药品id, Lngcur批次, Lng库房id);
      
        If n_零差价管理模式 <> 0 And n_药品零差价管理 = 1 And (v_零售价 = n_平均成本价 Or Round(v_零售价, n_流通售价小数) = Round(n_平均成本价, n_流通售价小数)) Then
          Dbl成本金额 := Dbl实际金额;
        Else
          Dbl成本金额 := Round(n_平均成本价 * Nvl(Dbl实际数量, 0), n_流通金额小数);
        End If;
      Else
        --退药再发记录，取原始单据价格
        Select a.成本价
        Into n_平均成本价
        From 药品收发记录 A, 药品收发记录 B
        Where b.Id = n_Billid And a.单据 = b.单据 And a.No = b.No And a.库房id = b.库房id And a.药品id + 0 = b.药品id And
              a.序号 = b.序号 And Nvl(a.批次, 0) = Nvl(b.批次, 0) And (a.记录状态 = 1 Or Mod(a.记录状态, 3) = 0);
      
        Dbl成本金额 := Round(n_平均成本价 * Nvl(Dbl实际数量, 0), n_流通金额小数);
      End If;
    
      Dbl实际差价 := Round(Dbl实际金额 - Dbl成本金额, n_流通金额小数);
    
      --更新药品收发记录的零售金额、成本金额及差价
      Update 药品收发记录
      Set 库房id = Lng库房id, 成本价 = n_平均成本价, 成本金额 = Dbl成本金额, 差价 = Dbl实际差价, 批次 = Lngcur批次, 批号 = Str批号, 效期 = Str效期,
          配药人 = 配药人_In, 核查人 = 核查人_In, 核查日期 = v_核查日期, 审核人 = People_In, 审核日期 = Date_In, 发药方式 = 发药方式_In, 领用人 = 领药人_In,
          汇总发药号 = 汇总发药号_In, 供药单位id = n_上次供应商id, 产地 = v_上次产地, 生产日期 = d_上次生产日期, 批准文号 = v_批准文号
      Where ID = n_Billid;
      --并发操作检查
      If Sql%RowCount = 0 Then
        v_Error := '要发药的药品记录"' || Str药名 || '"不存在，操作中止！';
        Raise Err_Custom;
      End If;
    
      --更新住院费用记录的执行状态(已执行)
      Select Decode(Sum(Nvl(付数, 1) * 实际数量), Null, 1, 0, 1, 2)
      Into Int执行状态
      From 药品收发记录
      Where 单据 = Int单据 And NO = Strno And 费用id = Lng费用id And 审核人 Is Null;
      Update 住院费用记录
      Set 执行状态 = Int执行状态, 执行人 = Decode(People_In, Null, Zl_Username, People_In), 执行时间 = Date_In, 执行部门id = Partid_In
      Where ID = Lng费用id;
    
      --更新未发药品记录(如果未发数为零则删除)
      Select Count(*)
      Into Int未发数
      From 药品收发记录
      Where 单据 = Int单据 And (库房id + 0 = Lng库房id Or 库房id Is Null) And NO = Strno And 审核人 Is Null And
            Nvl(LTrim(RTrim(摘要)), '小宝') <> '拒发';
    
      If Int未发数 = 0 Then
        Delete 未发药品记录 Where NO = Strno And 单据 = Int单据 And (库房id + 0 = Lng库房id Or 库房id Is Null);
      End If;
    
      --更新原批次库存的可用数量
      --更新发药批次库存的可用及实际数量
      If Lnglast批次 <> Lngcur批次 Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) + Dbl实际数量
        Where 库房id + 0 = Lng库房id And 药品id = Lng药品id And 性质 = 1 And Nvl(批次, 0) = Lnglast批次;
      
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - Dbl实际数量
        Where 库房id + 0 = Lng库房id And 药品id = Lng药品id And 性质 = 1 And Nvl(批次, 0) = Lngcur批次;
      End If;
    
      --更新库存
      Zl_药品库存_Update(n_Billid, 2, 1);
    
      --处理调价修正
      Zl_药品收发记录_调价修正(n_Billid);
    End If;
  End Loop;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_批量发药;
/

--99679:李业庆,2017-02-22,发药成本价取原始价格，金额位数按流通参数确定
--105308:李业庆,2017-02-22,零差价特殊处理
--106576:李业庆,2017-03-02,零差价升级前售价不是取最大位数的处理
--106523:李业庆,2017-03-05,退药再发药时取原始发药时的成本价
Create Or Replace Procedure Zl_药品收发记录_部门发药
(
  Partid_In        In 药品收发记录.库房id%Type,
  Billid_In        In 药品收发记录.Id%Type,
  People_In        In 药品收发记录.审核人%Type,
  Date_In          In 药品收发记录.审核日期%Type,
  批次_In          In 药品收发记录.批次%Type := Null,
  发药方式_In      In 药品收发记录.发药方式%Type := 3,
  领药人_In        In 药品收发记录.领用人%Type := Null,
  汇总发药号_In    In 药品收发记录.汇总发药号%Type := Null,
  操作员编号_In    In 人员表.编号%Type := Null,
  操作员姓名_In    In 人员表.姓名%Type := Null,
  Intdigit_In      In Number := 2,
  Intautoverify_In In Number := 1
) Is
  --只读变量
  Lng入出类别id Number(18);
  Int入出系数   Number;
  Int执行状态   Number;
  Int单据       药品收发记录.单据%Type;
  Strno         药品收发记录.No%Type;
  Lng库房id     药品收发记录.库房id%Type;
  Lng药品id     药品收发记录.药品id%Type;
  Lng费用id     药品收发记录.费用id%Type;
  v_零售价      药品收发记录.零售价%Type;
  Dbl差价率     Number;
  Int未发数     未发药品记录.未发数%Type;
  --可写变量
  Dbl实际数量 药品收发记录.实际数量%Type;
  Dbl实际金额 药品收发记录.零售金额%Type;
  Dbl成本金额 药品收发记录.成本金额%Type;
  Dbl实际差价 药品收发记录.差价%Type;
  --2002-07-31朱玉宝
  --LNGLAST批次 发药前确定的批次(已减可用数量)
  Str药名           Varchar2(200);
  Dbl可用数量       药品收发记录.填写数量%Type;
  Lnglast批次       药品收发记录.批次%Type;
  Lngcur批次        药品收发记录.批次%Type;
  Bln收费与发药分离 Number(1);
  v_Error           Varchar2(255);
  Err_Custom Exception;

  Str批号          药品收发记录.批号%Type;
  Str效期          药品收发记录.效期%Type;
  n_上次供应商id   药品库存.上次供应商id%Type;
  n_上次采购价     药品库存.上次采购价%Type;
  v_上次产地       药品库存.上次产地%Type;
  d_上次生产日期   药品库存.上次生产日期%Type;
  v_批准文号       药品库存.批准文号%Type;
  n_平均成本价     药品库存.平均成本价%Type;
  n_记录状态       药品收发记录.记录状态%Type;
  n_流通售价小数   Number;
  n_流通金额小数   Number;
  n_零差价管理模式 Number(1);
  n_药品零差价管理 Number(1);
  --自动审核费用
  Int序号   住院费用记录.序号%Type;
  Lng病人id 住院费用记录.病人id%Type;
Begin
  --获取该收发记录的单据、药品ID、库房ID,零售金额及实际数量、入出类别ID
  Begin
    Select a.单据, a.No, a.药品id, a.库房id, a.费用id, Nvl(a.零售价, 0), Nvl(a.零售金额, 0), Nvl(a.实际数量, 0) * Nvl(a.付数, 1), a.入出类别id,
           a.入出系数, Nvl(a.批次, 0), '[' || c.编码 || ']' || c.名称, a.批号, a.效期, a.供药单位id, a.产地, a.生产日期, a.批准文号, 记录状态
    Into Int单据, Strno, Lng药品id, Lng库房id, Lng费用id, v_零售价, Dbl实际金额, Dbl实际数量, Lng入出类别id, Int入出系数, Lnglast批次, Str药名, Str批号,
         Str效期, n_上次供应商id, v_上次产地, d_上次生产日期, v_批准文号, n_记录状态
    From 药品收发记录 A, 收费项目目录 C
    Where a.Id = Billid_In And a.药品id = c.Id And a.审核日期 Is Null
    For Update Nowait;
  Exception
    When Others Then
      Int单据 := 0;
      v_Error := '已有其他用户在执行发药，不能重复操作！';
      Raise Err_Custom;
  End;

  --取流通业务精度位数
  --类别:1-药品 2-卫材
  --内容：2-零售价 4-金额
  --单位：药品:1-售价 5-金额单位
  Begin
    Select 精度 Into n_流通金额小数 From 药品卫材精度 Where 类别 = 1 And 内容 = 4 And 单位 = 5;
  Exception
    When Others Then
      n_流通金额小数 := 2;
  End;

  Begin
    Select 精度 Into n_流通售价小数 From 药品卫材精度 Where 类别 = 1 And 内容 = 2 And 单位 = 1;
  Exception
    When Others Then
      n_流通售价小数 := 2;
  End;

  Select Zl_To_Number(Nvl(zl_GetSysParameter(275), '0')) Into n_零差价管理模式 From Dual;

  If Int单据 > 0 Then
    If Nvl(批次_In, 0) = 0 Then
      Lngcur批次 := Lnglast批次;
    Else
      Lngcur批次 := Nvl(批次_In, 0);
    End If;
  
    --检查是否已经填写库房
    Bln收费与发药分离 := 0;
    If Lng库房id Is Null Then
      Bln收费与发药分离 := 1;
    End If;
    Lng库房id := Partid_In;
  
    --取该批药品的批号
    Begin
      Select 上次批号, 效期, Nvl(可用数量, 0), 上次供应商id, 上次产地, 上次生产日期, 批准文号, 上次采购价
      Into Str批号, Str效期, Dbl可用数量, n_上次供应商id, v_上次产地, d_上次生产日期, v_批准文号, n_上次采购价
      From 药品库存
      Where 库房id + 0 = Lng库房id And 药品id = Lng药品id And 性质 = 1 And Nvl(批次, 0) = Lngcur批次;
    Exception
      When Others Then
        Dbl可用数量  := 0;
        n_上次采购价 := 0;
    End;
  
    --可用数量不足则退出
    If Lngcur批次 <> Nvl(Lnglast批次, 0) Then
      If Dbl可用数量 < Dbl实际数量 And Lngcur批次 <> 0 Then
        v_Error := Str药名 || '的可用数量不足，操作中止！';
        Raise Err_Custom;
      End If;
    End If;
  
    If n_零差价管理模式 <> 0 Then
      Select Nvl(是否零差价管理, 0) Into n_药品零差价管理 From 药品规格 Where 药品id = Lng药品id;
    End If;
  
    --计算该药品收发记录的成本价、成本金额、零售金额及差价(先计算零售金额，再计算差价，最后计算成本金额及成本价)
    If n_记录状态 = 1 Then
      --原始发药记录，取最新价格
      n_平均成本价 := Zl_Fun_Getoutcost(Lng药品id, Lngcur批次, Lng库房id);
    
      If n_零差价管理模式 <> 0 And n_药品零差价管理 = 1 And (v_零售价 = n_平均成本价 Or Round(v_零售价, n_流通售价小数) = Round(n_平均成本价, n_流通售价小数)) Then
        Dbl成本金额 := Dbl实际金额;
      Else
        Dbl成本金额 := Round(n_平均成本价 * Nvl(Dbl实际数量, 0), n_流通金额小数);
      End If;
    Else
      --退药再发记录，取原始单据价格
      Select a.成本价
      Into n_平均成本价
      From 药品收发记录 A, 药品收发记录 B
      Where b.Id = Billid_In And a.单据 = b.单据 And a.No = b.No And a.库房id = b.库房id And a.药品id + 0 = b.药品id And
            a.序号 = b.序号 And Nvl(a.批次, 0) = Nvl(b.批次, 0) And (a.记录状态 = 1 Or Mod(a.记录状态, 3) = 0);
    
      Dbl成本金额 := Round(n_平均成本价 * Nvl(Dbl实际数量, 0), n_流通金额小数);
    End If;
    Dbl实际差价 := Round(Dbl实际金额 - Dbl成本金额, n_流通金额小数);
  
    --更新药品收发记录的零售金额、成本金额及差价
    Update 药品收发记录
    Set 库房id = Lng库房id, 成本价 = n_平均成本价, 成本金额 = Dbl成本金额, 差价 = Dbl实际差价, 批次 = Lngcur批次, 批号 = Str批号, 效期 = Str效期,
        审核人 = People_In, 审核日期 = Date_In, 发药方式 = 发药方式_In, 领用人 = 领药人_In, 汇总发药号 = 汇总发药号_In, 供药单位id = n_上次供应商id, 产地 = v_上次产地,
        生产日期 = d_上次生产日期, 批准文号 = v_批准文号
    Where ID = Billid_In;
    --并发操作检查
    If Sql%RowCount = 0 Then
      v_Error := '要发药的药品记录"' || Str药名 || '"不存在，操作中止！';
      Raise Err_Custom;
    End If;
  
    --更改所有已发药处方的配药人为发药人
    Update 药品收发记录
    Set 配药人 = People_In
    Where NO = Strno And 单据 = Int单据 And (库房id + 0 = Lng库房id Or 库房id Is Null) And 审核人 Is Not Null And Mod(记录状态, 3) = 1;
  
    --更新原批次库存的可用数量
    --更新发药批次库存的可用及实际数量
    If Lnglast批次 <> Lngcur批次 Then
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) + Dbl实际数量
      Where 库房id + 0 = Lng库房id And 药品id = Lng药品id And 性质 = 1 And Nvl(批次, 0) = Lnglast批次;
    
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) - Dbl实际数量
      Where 库房id + 0 = Lng库房id And 药品id = Lng药品id And 性质 = 1 And Nvl(批次, 0) = Lngcur批次;
    End If;
  
    If Bln收费与发药分离 = 1 Then
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) - Dbl实际数量, 实际数量 = Nvl(实际数量, 0) - Dbl实际数量, 实际金额 = Nvl(实际金额, 0) - Dbl实际金额,
          实际差价 = Nvl(实际差价, 0) - Dbl实际差价
      Where 库房id + 0 = Lng库房id And 药品id = Lng药品id And 性质 = 1 And Nvl(批次, 0) = Lngcur批次;
    Else
      Update 药品库存
      Set 实际数量 = Nvl(实际数量, 0) - Dbl实际数量, 实际金额 = Nvl(实际金额, 0) - Dbl实际金额, 实际差价 = Nvl(实际差价, 0) - Dbl实际差价
      Where 库房id + 0 = Lng库房id And 药品id = Lng药品id And 性质 = 1 And Nvl(批次, 0) = Lngcur批次;
    End If;
  
    If Sql%RowCount = 0 Then
      If n_上次采购价 = 0 Then
        If Dbl实际数量 = 0 Then
          Dbl实际数量 := 1;
        End If;
        n_上次采购价 := Round(Dbl成本金额 / Dbl实际数量, 5);
      End If;
    
      If Bln收费与发药分离 = 1 Then
        Insert Into 药品库存
          (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次产地, 效期, 上次生产日期, 批准文号, 平均成本价)
        Values
          (Lng库房id, Lng药品id, Lngcur批次, 1, 0 - Dbl实际数量, 0 - Dbl实际数量, 0 - Dbl实际金额, 0 - Dbl实际差价, n_上次供应商id, n_上次采购价, Str批号,
           v_上次产地, Str效期, d_上次生产日期, v_批准文号, n_上次采购价);
      Else
        Insert Into 药品库存
          (库房id, 药品id, 批次, 性质, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次产地, 效期, 上次生产日期, 批准文号, 平均成本价)
        Values
          (Lng库房id, Lng药品id, Lngcur批次, 1, 0 - Dbl实际数量, 0 - Dbl实际金额, 0 - Dbl实际差价, n_上次供应商id, n_上次采购价, Str批号, v_上次产地,
           Str效期, d_上次生产日期, v_批准文号, n_上次采购价);
      End If;
    End If;
  
    Delete 药品库存
    Where 库房id + 0 = Lng库房id And 药品id = Lng药品id And 性质 = 1 And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And
          Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0;
  
    --更新费用记录的执行状态(已执行)
    Select Decode(Sum(Nvl(付数, 1) * 实际数量), Null, 1, 0, 1, 2)
    Into Int执行状态
    From 药品收发记录
    Where 单据 = Int单据 And NO = Strno And 费用id = Lng费用id And 审核人 Is Null And 记录状态 <> 1 And Mod(记录状态, 3) <> 0;
    Update 住院费用记录
    Set 执行状态 = Int执行状态, 执行人 = Decode(People_In, Null, Zl_Username, People_In), 执行时间 = Date_In
    Where ID = Lng费用id;
  
    --更新未发药品记录(如果未发数为零则删除)
    Select Count(*)
    Into Int未发数
    From 药品收发记录
    Where 单据 = Int单据 And (库房id + 0 = Lng库房id Or 库房id Is Null) And NO = Strno And 审核人 Is Null And
          Nvl(LTrim(RTrim(摘要)), '小宝') <> '拒发';
  
    If Int未发数 = 0 Then
      Delete 未发药品记录 Where NO = Strno And 单据 = Int单据 And (库房id + 0 = Lng库房id Or 库房id Is Null);
    End If;
  
    --费用审核（重复审核也没有关系）
    Select 序号, 病人id, NO
    Into Int序号, Lng病人id, Strno
    From 住院费用记录
    Where ID = (Select 费用id From 药品收发记录 Where ID = Billid_In);
  
    Zl_住院记帐记录_Verify(Strno, 操作员编号_In, 操作员姓名_In, Int序号, Lng病人id, Date_In);
  
    --处理调价修正
    Zl_药品收发记录_调价修正(Billid_In);
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_部门发药;
/


--104948:李业庆,2017-02-23,差价金额精度按流通金额精度确定，金额公式调整
Create Or Replace Procedure Zl_药品收发记录_成本价调价
(
  药品id_In   In 药品收发记录.药品id%Type,
  执行时间_In In 成本价调价信息.执行日期%Type := Null
) As
  Adjustdate     Date; --调价时间
  n_序号         Number(8);
  n_Stockid      药品收发记录.库房id%Type;
  n_入出类别id   药品收发记录.入出类别id%Type;
  n_入出系数     药品收发记录.入出系数%Type;
  n_收发id       药品收发记录.Id%Type;
  n_调整额       药品收发记录.零售金额%Type;
  n_供应商id     药品收发记录.供药单位id%Type;
  v_No           药品收发记录.No%Type;
  v_应付id       应付记录.Id%Type; --应付记录的ID
  v_应付no       应付记录.No%Type;
  n_原成本价     药品收发记录.成本价%Type;
  n_新成本价     药品收发记录.成本价%Type;
  n_Run          Number(1);
  v_Count        Number(1) := 0;
  v_调价id       成本价调价信息.Id%Type;
  n_平均成本价   药品收发记录.成本价%Type;
  n_流通金额小数 Number;

  Cursor c_Stock Is --当前库存
    Select 上次供应商id, a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, a.上次批号, a.效期, a.上次产地, a.灭菌效期,
           Decode(Sign(Nvl(a.批次, 0)), 1, a.上次采购价, a.平均成本价) As 原成本价
    From 药品库存 A
    Where a.性质 = 1 And a.药品id = 药品id_In
    Order By a.库房id;

  v_Stock c_Stock%RowType;

  Cursor c_Costadjust Is --成本价调价信息
    Select a.库房id, a.药品id, Nvl(a.批次, 0) 批次, a.上次供应商id, Nvl(a.实际数量, 0) As 实际数量, a.实际金额, a.实际差价, a.上次产地 As 产地,
           a.上次批号 As 批号, a.效期, a.上次生产日期 As 生产日期, a.批准文号, a.灭菌效期, a.平均成本价 As 原成本价, b.新成本价, b.发票号, b.发票日期, b.发票金额,
           Nvl(a.上次采购价, 0) As 上次采购价, b.Id As 调价id
    From 药品库存 A, 成本价调价信息 B
    Where a.药品id = b.药品id And Nvl(a.上次供应商id, 0) = Nvl(b.供药单位id, 0) And a.库房id = b.库房id And Nvl(a.批次, 0) = Nvl(b.批次, 0) And
          a.性质 = 1 And b.执行日期 Is Null And a.药品id = 药品id_In
    Order By a.库房id;

  v_Costadjust c_Costadjust%RowType;

  Cursor c_Pay Is --应付管理
    Select Distinct a.供药单位id, a.药品id, a.发票号, a.发票日期, a.发票金额, b.名称, b.计算单位, b.规格
    From 成本价调价信息 A, 收费项目目录 B
    Where a.药品id = b.Id And a.应付款变动 = 1 And a.药品id = 药品id_In And a.供药单位id Is Not Null
    Order By a.供药单位id;

  v_Pay c_Pay%RowType;
Begin
  Adjustdate := Sysdate;
  n_Stockid  := 0;
  n_Run      := 0;

  --判断是否存在无库存调价
  Begin
    Select ID, 新成本价
    Into v_调价id, n_新成本价
    From 成本价调价信息
    Where 执行日期 Is Null And Nvl(库房id, 0) = 0 And 药品id = 药品id_In;
  Exception
    When Others Then
      v_调价id   := 0;
      n_新成本价 := Null;
  End;

  --取流通业务精度位数
  --类别:1-药品 2-卫材
  --内容：2-零售价 4-金额
  --单位：药品:1-售价 5-金额单位
  Select 精度 Into n_流通金额小数 From 药品卫材精度 Where 类别 = 1 And 内容 = 4 And 单位 = 5;

  --无库存调价
  If v_调价id > 0 Then
    --根据当前库存重新产生调价信息
    For v_Stock In c_Stock Loop
      Zl_成本价调价信息_Insert(v_Stock.上次供应商id, v_Stock.库房id, v_Stock.药品id, v_Stock.批次, v_Stock.上次批号, v_Stock.效期, v_Stock.上次产地,
                        v_Stock.灭菌效期, v_Stock.原成本价, n_新成本价);
      v_Count := v_Count + 1;
    End Loop;
  
    If v_Count > 0 Then
      --如果当前有库存记录，则删除无库存调价记录
      Delete 成本价调价信息 Where ID = v_调价id;
    Else
      Update 成本价调价信息 Set 执行日期 = Decode(执行时间_In, Null, Adjustdate, 执行时间_In) Where ID = v_调价id;
    
      Update 药品规格 Set 成本价 = n_新成本价 Where 药品id = 药品id_In And 成本价 <> n_新成本价;
    End If;
  End If;

  Select b.Id, b.系数
  Into n_入出类别id, n_入出系数
  From 药品单据性质 A, 药品入出类别 B
  Where a.类别id = b.Id And a.单据 = 5 And Rownum < 2;

  For v_Costadjust In c_Costadjust Loop
    n_Run := 1;
    If n_Stockid <> v_Costadjust.库房id Then
      n_序号    := 1;
      n_Stockid := v_Costadjust.库房id;
      v_No      := Nextno(25, n_Stockid);
    Else
      n_序号 := n_序号 + 1;
    End If;
  
    --产生库存差价调整单
    Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
  
    If v_Costadjust.实际数量 = 0 And (Nvl(v_Costadjust.实际金额, 0) <> 0 Or Nvl(v_Costadjust.实际差价, 0) <> 0) Then
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 供药单位id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 零售价, 成本价, 差价, 摘要, 填制人, 填制日期, 审核人,
         审核日期, 生产日期, 批准文号, 单量, 发药方式, 扣率, 灭菌效期)
      Values
        (n_收发id, 1, 5, v_No, n_序号, v_Costadjust.库房id, n_入出类别id, v_Costadjust.上次供应商id, n_入出系数, v_Costadjust.药品id,
         v_Costadjust.批次, v_Costadjust.产地, v_Costadjust.批号, v_Costadjust.效期, 0, v_Costadjust.实际金额, v_Costadjust.实际差价, 0,
         '成本价调价', Zl_Username, Adjustdate, Zl_Username, Adjustdate, v_Costadjust.生产日期, v_Costadjust.批准文号,
         v_Costadjust.新成本价, 1, v_Costadjust.原成本价, v_Costadjust.灭菌效期);
    
      --更新库存
      Zl_药品库存_Update(n_收发id, 2, 0);
    
      Update 药品规格 Set 成本价 = v_Costadjust.新成本价 Where 药品id = v_Costadjust.药品id;
    
      --更新成本价调价信息
      Update 成本价调价信息
      Set 批号 = v_Costadjust.批号, 效期 = v_Costadjust.效期, 产地 = v_Costadjust.产地, 灭菌效期 = v_Costadjust.灭菌效期, 收发id = n_收发id,
          执行日期 = Decode(执行时间_In, Null, Adjustdate, 执行时间_In)
      Where ID = v_Costadjust.调价id;
    Else
      n_调整额   := Round(v_Costadjust.原成本价 * v_Costadjust.实际数量, n_流通金额小数) -
                 Round(v_Costadjust.新成本价 * v_Costadjust.实际数量, n_流通金额小数);
      n_原成本价 := v_Costadjust.原成本价;
      If n_原成本价 <= 0 Then
        n_原成本价 := v_Costadjust.上次采购价;
      End If;
    
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 供药单位id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 零售价, 成本价, 差价, 摘要, 填制人, 填制日期, 审核人,
         审核日期, 生产日期, 批准文号, 单量, 发药方式, 扣率, 灭菌效期)
      Values
        (n_收发id, 1, 5, v_No, n_序号, v_Costadjust.库房id, n_入出类别id, v_Costadjust.上次供应商id, n_入出系数, v_Costadjust.药品id,
         v_Costadjust.批次, v_Costadjust.产地, v_Costadjust.批号, v_Costadjust.效期, v_Costadjust.实际数量, v_Costadjust.实际金额,
         v_Costadjust.实际差价, n_调整额, '成本价调价', Zl_Username, Adjustdate, Zl_Username, Adjustdate, v_Costadjust.生产日期,
         v_Costadjust.批准文号, v_Costadjust.新成本价, 1, n_原成本价, v_Costadjust.灭菌效期);
    
      --更新库存
      Zl_药品库存_Update(n_收发id, 2, 0);
    
      Update 药品规格
      Set 成本价 = v_Costadjust.新成本价
      Where 药品id = v_Costadjust.药品id And 成本价 <> v_Costadjust.新成本价;
    
      --更新成本价调价信息
      Update 成本价调价信息
      Set 批号 = v_Costadjust.批号, 效期 = v_Costadjust.效期, 产地 = v_Costadjust.产地, 灭菌效期 = v_Costadjust.灭菌效期, 原成本价 = n_原成本价,
          收发id = n_收发id, 执行日期 = Decode(执行时间_In, Null, Adjustdate, 执行时间_In)
      Where ID = v_Costadjust.调价id;
    End If;
  End Loop;

  --产生应付记录及修改应付余额
  If n_Run = 1 Then
    For v_Pay In c_Pay Loop
      v_应付no := Nextno(67);
    
      Select 应付记录_Id.Nextval Into v_应付id From Dual;
    
      Insert Into 应付记录
        (ID, 记录性质, 记录状态, 单位id, NO, 系统标识, 发票号, 发票日期, 发票金额, 品名, 规格, 填制人, 填制日期, 摘要)
      Values
        (v_应付id, 1, 1, v_Pay.供药单位id, v_应付no, 1, v_Pay.发票号, v_Pay.发票日期, v_Pay.发票金额, v_Pay.名称, v_Pay.规格, Zl_Username,
         Adjustdate, '成本价调价自动产生应付款变动记录');
    
      Update 应付余额 Set 金额 = Nvl(金额, 0) + Nvl(v_Pay.发票金额, 0) Where 单位id = v_Pay.供药单位id And 性质 = 1;
    
      If Sql%NotFound Then
        Insert Into 应付余额 (单位id, 性质, 金额) Values (v_Pay.供药单位id, 1, Nvl(v_Pay.发票金额, 0));
      End If;
    End Loop;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_成本价调价;
/

--104948:李业庆,2017-02-23,零售，差价金额精度按流通金额精度确定，金额计算公式调整
Create Or Replace Procedure Zl_药品收发记录_Adjust
(
  Adjustid    In Number, --调价记录的ID
  Bln定价     In Number := 0, --是否转为定价销售（更新2004-06-08、收费细目中的变价）
  Billinfo_In In Varchar2 := Null, --用于时价药品按批次调价。格式:"批次1,现价1|批次2,现价2|....."
  药品id_In   In Number := 0 --当不为0时表示是成本价调价，不处理售价相关内容
) As
  Classid        Number(18); --入出类别
  v_Billno       药品收发记录.No%Type; --调价单号
  Rundate        Date; --调价生效时间
  Blnrun         Number(1); --调价时刻到了
  Blncurprice    Number(1); --时价药品
  Lng细目id      Number(18); --收费细目ID
  Adjustdate     Date; --调价时间
  n_批次         Number(18);
  n_现价         收费价目.现价%Type;
  n_原价         收费价目.原价%Type;
  v_Infotmp      Varchar2(4000);
  v_Fields       Varchar2(4000);
  n_序号         Number(8);
  n_原价id       收费价目.原价id%Type;
  n_收入项目id   收费价目.收入项目id%Type;
  n_零售金额     药品库存.实际金额%Type;
  n_零售价       药品库存.零售价%Type;
  n_收发id       药品收发记录.Id%Type;
  n_变动原因     收费价目.变动原因%Type;
  n_流通金额小数 Number;
  Cursor c_Price --普通调价
  Is
    Select 1 记录状态, 13 单据, v_Billno NO, Rownum 序号, Classid 入出类别id, m.Id As 药品id, s.批次, Null 批号, Null 效期, s.上次产地 As 产地,
           1 付数, s.上次供应商id As 供应商id, s.实际数量 填写数量, 0 实际数量, a.原价 成本价, 0 成本金额, a.现价 零售价, 0 扣率, '药品调价' 摘要, Zl_Username 填制人,
           Sysdate 填制日期, s.库房id 库房id, 1 入出系数, a.Id 价格id, Nvl(m.是否变价, 0) As 时价, s.实际金额 As 库存金额, s.实际差价 As 库存差价,
           Nvl(s.零售价, Decode(Nvl(s.实际数量, 0), 0, a.原价, Nvl(s.实际金额, 0) / s.实际数量)) As 原售价
    From 药品库存 S, 收费项目目录 M, 收费价目 A
    Where s.药品id = m.Id And m.Id = a.收费细目id And s.性质 = 1 And a.变动原因 = 0 And a.Id = Adjustid And a.执行日期 <= Sysdate;

  v_Data c_Price%RowType;

  Cursor c_时价按批次调价 --时价药品按批次调价
  Is
    Select 1 记录状态, 13 单据, v_Billno NO, n_序号 + Rownum 序号, Classid 入出类别id, m.药品id 药品id, s.批次 批次, Null 批号, Null 效期,
           s.上次产地 As 产地, s.上次供应商id As 供应商id, 1 付数, Nvl(s.实际数量, 0) 填写数量, 0 实际数量, a.原价 成本价, 0 成本金额, n_现价 零售价, 0 扣率,
           '药品调价' 摘要, Zl_Username 填制人, Sysdate 填制日期, s.库房id 库房id, 1 入出系数, a.Id 价格id, Nvl(b.是否变价, 0) As 时价,
           s.实际金额 As 库存金额, s.实际差价 As 库存差价, Nvl(s.零售价, Decode(Nvl(s.实际数量, 0), 0, a.原价, Nvl(s.实际金额, 0) / s.实际数量)) As 原售价
    From 药品库存 S, 药品目录 M, 收费价目 A, 收费项目目录 B
    Where s.药品id = b.Id And s.药品id = m.药品id And m.药品id = a.收费细目id And s.性质 = 1 And a.变动原因 = 0 And a.Id = Adjustid And
          a.执行日期 <= Sysdate And Nvl(s.批次, 0) = n_批次;

  v_时价按批次调价 c_时价按批次调价%RowType;
Begin
  --取流通业务精度位数
  --类别:1-药品 2-卫材
  --内容：2-零售价 4-金额
  --单位：药品:1-售价 5-金额单位
  Select 精度 Into n_流通金额小数 From 药品卫材精度 Where 类别 = 1 And 内容 = 4 And 单位 = 5;

  If 药品id_In <> 0 Then
    --成本价调价
    Zl_药品收发记录_成本价调价(药品id_In);
  Else
    n_变动原因 := 0;
    --取调价记录生效日期
    Select 收费细目id, 执行日期, 收入项目id Into Lng细目id, Rundate, n_收入项目id From 收费价目 Where ID = Adjustid;
  
    If Sysdate >= Rundate Then
      Blnrun := 1;
    Else
      Blnrun := 0;
    End If;
  
    If Blnrun = 1 Then
      --取入出类别ID
      Select 类别id Into Classid From 药品单据性质 Where 单据 = 13;
    
      --取序列
      Select Nextno(147) Into v_Billno From Dual;
    
      --取该药品是否是时价药品
      Select Nvl(是否变价, 0) Into Blncurprice From 收费项目目录 Where ID = Lng细目id;
    
      --检查是否存在原价和现价相同的情况，相同时不执行调售价功能，并且删除这条收费价目记录，恢复原来的收费价目
      Begin
        Select 原价id Into n_原价id From 收费价目 Where ID = Adjustid And 原价 = 现价 And 原价id Is Not Null;
      Exception
        When Others Then
          n_原价id := 0;
      End;
    
      If n_原价id > 0 Then
        --如果现价=原价，这种情况下是单独调整收入项目，更新收入项目ID，删除调价记录
        Delete 收费价目 Where ID = Adjustid;
        Update 收费价目
        Set 收入项目id = n_收入项目id, 终止日期 = To_Date('3000-01-01', 'yyyy-mm-dd')
        Where ID = n_原价id;
      Else
        Adjustdate := Sysdate;
      
        Begin
          Select 变动原因 Into n_变动原因 From 收费价目 Where ID = Adjustid And 变动原因 = 1;
        Exception
          When Others Then
            n_变动原因 := 0;
        End;
        If n_变动原因 = 0 Then
          If Billinfo_In = '' Or Billinfo_In Is Null Then
            For v_Data In c_Price Loop
              Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
              If Nvl(v_Data.填写数量, 0) = 0 And (Nvl(v_Data.库存金额, 0) <> 0 Or Nvl(v_Data.库存差价, 0) <> 0) Then
                --数量=0 金额或差价<>0时只更新库存表中对应的零售价,并产生售价修正数据但是金额差=0，只记录最新售价，金额差和差价差不填数据
              
                --产生调价影响记录
                Insert Into 药品收发记录
                  (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 摘要, 填制人,
                   填制日期, 库房id, 入出系数, 价格id, 审核人, 审核日期, 单量, 频次, 供药单位id)
                Values
                  (n_收发id, v_Data.记录状态, v_Data.单据, v_Data.No, v_Data.序号, v_Data.入出类别id, v_Data.药品id, v_Data.批次,
                   v_Data.批号, v_Data.效期, v_Data.产地, v_Data.付数, v_Data.填写数量, v_Data.实际数量,
                   Decode(Blncurprice, 1, v_Data.原售价, v_Data.成本价), v_Data.成本金额, v_Data.零售价, v_Data.扣率, v_Data.摘要,
                   v_Data.填制人, v_Data.填制日期, v_Data.库房id, v_Data.入出系数, v_Data.价格id, Zl_Username, Adjustdate, v_Data.库存金额,
                   v_Data.库存差价, v_Data.供应商id);
              
                --更新库存零售价,只有时价分批药品才能更新零售价字段
                Zl_药品库存_Update(n_收发id, 2, 0);
              Else
                If Blncurprice = 1 Then
                  n_零售价 := v_Data.原售价;
                Else
                  n_零售价 := v_Data.成本价;
                End If;
                n_零售金额 := Round(v_Data.零售价 * v_Data.填写数量, n_流通金额小数) - Round(n_零售价 * v_Data.填写数量, n_流通金额小数);
              
                --产生调价影响记录
                Insert Into 药品收发记录
                  (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 零售金额, 差价, 摘要,
                   填制人, 填制日期, 库房id, 入出系数, 价格id, 审核人, 审核日期, 单量, 频次, 供药单位id)
                Values
                  (n_收发id, v_Data.记录状态, v_Data.单据, v_Data.No, v_Data.序号, v_Data.入出类别id, v_Data.药品id, v_Data.批次,
                   v_Data.批号, v_Data.效期, v_Data.产地, v_Data.付数, v_Data.填写数量, v_Data.实际数量,
                   Decode(Blncurprice, 1, v_Data.原售价, v_Data.成本价), v_Data.成本金额, v_Data.零售价, v_Data.扣率, n_零售金额, n_零售金额,
                   v_Data.摘要, v_Data.填制人, v_Data.填制日期, v_Data.库房id, v_Data.入出系数, v_Data.价格id, Zl_Username, Adjustdate,
                   v_Data.库存金额, v_Data.库存差价, v_Data.供应商id);
              
                --更新药品库存
                Zl_药品库存_Update(n_收发id, 2, 0);
              End If;
            End Loop;
          Else
            n_序号 := 0;
            --时价药品按批次调价
            v_Infotmp := Billinfo_In || '|';
            While v_Infotmp Is Not Null Loop
              --分解单据ID串
              v_Fields  := Substr(v_Infotmp, 1, Instr(v_Infotmp, '|') - 1);
              n_批次    := Substr(v_Fields, 1, Instr(v_Fields, ',') - 1);
              n_现价    := Substr(v_Fields, Instr(v_Fields, ',') + 1);
              v_Infotmp := Replace('|' || v_Infotmp, '|' || v_Fields || '|');
            
              For v_时价按批次调价 In c_时价按批次调价 Loop
                If v_时价按批次调价.填写数量 <> 0 Then
                  n_原价 := Nvl(v_时价按批次调价.库存金额, 0) / v_时价按批次调价.填写数量;
                Else
                  n_原价 := v_时价按批次调价.成本价;
                End If;
              
                Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
                If Nvl(v_时价按批次调价.填写数量, 0) = 0 And (Nvl(v_时价按批次调价.库存金额, 0) <> 0 Or Nvl(v_时价按批次调价.库存差价, 0) <> 0) Then
                  --数量=0 金额或差价<>0时只更新库存表中对应的零售价,并产生售价修正数据但是金额差=0，只记录最新售价，金额差和差价差不填数据
                
                  --产生调价影响记录
                  Insert Into 药品收发记录
                    (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 摘要, 填制人,
                     填制日期, 库房id, 入出系数, 价格id, 审核人, 审核日期, 单量, 频次, 供药单位id)
                  Values
                    (n_收发id, v_时价按批次调价.记录状态, v_时价按批次调价.单据, v_时价按批次调价.No, v_时价按批次调价.序号, v_时价按批次调价.入出类别id, v_时价按批次调价.药品id,
                     v_时价按批次调价.批次, v_时价按批次调价.批号, v_时价按批次调价.效期, v_时价按批次调价.产地, v_时价按批次调价.付数, v_时价按批次调价.填写数量,
                     v_时价按批次调价.实际数量, Decode(Blncurprice, 1, v_时价按批次调价.原售价, v_时价按批次调价.成本价), v_时价按批次调价.成本金额, v_时价按批次调价.零售价,
                     v_时价按批次调价.扣率, v_时价按批次调价.摘要, v_时价按批次调价.填制人, v_时价按批次调价.填制日期, v_时价按批次调价.库房id, v_时价按批次调价.入出系数,
                     v_时价按批次调价.价格id, Zl_Username, Adjustdate, v_时价按批次调价.库存金额, v_时价按批次调价.库存差价, v_时价按批次调价.供应商id);
                  n_序号 := n_序号 + 1;
                
                  --更新库存零售价,只有时价分批药品才能更新零售价字段
                  Zl_药品库存_Update(n_收发id, 2, 0);
                Else
                  If Blncurprice = 1 Then
                    n_零售价 := v_时价按批次调价.原售价;
                  Else
                    n_零售价 := v_时价按批次调价.成本价;
                  End If;
                  n_零售金额 := Round(n_现价 * v_时价按批次调价.填写数量, n_流通金额小数) - Round(n_零售价 * v_时价按批次调价.填写数量, n_流通金额小数);
                
                  --产生调价影响记录
                  Insert Into 药品收发记录
                    (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 零售金额, 差价,
                     摘要, 填制人, 填制日期, 库房id, 入出系数, 价格id, 审核人, 审核日期, 单量, 频次, 供药单位id)
                  Values
                    (n_收发id, v_时价按批次调价.记录状态, v_时价按批次调价.单据, v_时价按批次调价.No, v_时价按批次调价.序号, v_时价按批次调价.入出类别id, v_时价按批次调价.药品id,
                     v_时价按批次调价.批次, v_时价按批次调价.批号, v_时价按批次调价.效期, v_时价按批次调价.产地, v_时价按批次调价.付数, v_时价按批次调价.填写数量,
                     v_时价按批次调价.实际数量, Decode(Blncurprice, 1, v_时价按批次调价.原售价, v_时价按批次调价.成本价), v_时价按批次调价.成本金额, v_时价按批次调价.零售价,
                     v_时价按批次调价.扣率, n_零售金额, n_零售金额, v_时价按批次调价.摘要, v_时价按批次调价.填制人, v_时价按批次调价.填制日期, v_时价按批次调价.库房id,
                     v_时价按批次调价.入出系数, v_时价按批次调价.价格id, Zl_Username, Adjustdate, v_时价按批次调价.库存金额, v_时价按批次调价.库存差价,
                     v_时价按批次调价.供应商id);
                  n_序号 := n_序号 + 1;
                
                  --更新库存
                  Zl_药品库存_Update(n_收发id, 2, 0);
                End If;
              End Loop;
            End Loop;
          End If;
        
          Update 收费价目 Set 变动原因 = 1 Where ID = Adjustid;
          --更新药品目录、收费细目中的变价
          If Bln定价 = 1 Then
            Update 收费项目目录 Set 是否变价 = 0 Where ID = Lng细目id;
            Update 收费细目 Set 是否变价 = 0 Where ID = Lng细目id;
          End If;
        End If;
      End If;
    
      If n_变动原因 = 0 Then
        --成本价调价
        Zl_药品收发记录_成本价调价(Lng细目id, Rundate);
      End If;
    End If;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_Adjust;
/

---------------------------------------------------------------------------------------------------
--更改系统及部件的版本号
-------------------------------------------------------------------------------------------------------
--102830:刘硕,2016-11-21,支持文件下载到多个目录
Update Zltools.Zlfilesupgrade a Set a.附加安装路径 = '[APPSOFT]\DEV_[*]' Where Upper(a.文件名) = 'ZL9LABRECEIV.EXE';
--102830:刘硕,2016-11-21,支持文件下载到多个目录
Update Zltools.Zlfilesupgrade a Set a.文件名 = Upper(a.文件名) Where Upper(a.文件名) = 'ZLHISCRUST.EXE';




--zlfiles
EXECUTE Zlfiles_Autoupdate('7CACKY16.DLL','5BC90529B6E4C1AC842E97A847DE969F',Null,To_Date('2000-03-29 10:51:46', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'语音报价接口文件',0,0,Null);
EXECUTE Zlfiles_Autoupdate('7CACKY95.DLL','EAC9442E0D695FBC41E863BAB377407C',Null,To_Date('2000-03-22 20:10:56', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'语音报价接口文件',0,0,Null);
EXECUTE Zlfiles_Autoupdate('7CADSBNT.DLL','D77A5058DB6930BC9E8DD7C44BD8C74F',Null,To_Date('2000-03-28 11:48:34', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'语音报价接口文件',0,0,Null);
EXECUTE Zlfiles_Autoupdate('7Z.DLL','E3C7BC97672CDEB280DD43F2A69776BB','9.20.0.0',To_Date('2011-03-30 11:44:26', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'7-ZIP压缩程序',0,0,Null);
EXECUTE Zlfiles_Autoupdate('7Z.EXE','7083BA03D91F9D76CC659F973F14F839','9.20.0.0',To_Date('2011-03-30 11:44:26', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'7-ZIP压缩程序',0,0,Null);
EXECUTE Zlfiles_Autoupdate('AAMD532.DLL','CEFD956A1EF122CDA4D53007BAB6C694','1.0.0.1',To_Date('2011-09-27 11:15:40', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),4,'[System]',Null,Null,'Almeida & Andrade Ltda MD5 Maker DLL',0,0,Null);
EXECUTE Zlfiles_Autoupdate('Anigif.ocx','769D2ADF8126AA2A319EF5C3A7462ABE','2.4.3.0',To_Date('2012-04-20 10:25:26', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('BEIJING_TAX.DLL','F75E7082787D499BDA01B6ECB37ACF03','1.0.0.0',To_Date('2004-05-26 10:00:26', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'北京医疗行业外挂式税控器开票API接口库',1,0,Null);
EXECUTE Zlfiles_Autoupdate('C1REGSVR.EXE','F408A0E2369427403299BC63EE273C0C',Null,To_Date('2004-10-01 10:26:56', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'ComponentOne Chart 2D的注册程序',0,0,Null);
EXECUTE Zlfiles_Autoupdate('CKY32.DLL','9FB806B837B3781C3F24EF26E5FE8C6A',Null,To_Date('2001-12-26 11:23:48', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'语音报价接口文件',0,0,Null);
EXECUTE Zlfiles_Autoupdate('CKY95H.DLL','E969175463B1AED7D1333EFF9440491E',Null,To_Date('2005-01-10 11:27:32', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'语音报价接口文件',0,0,Null);
EXECUTE Zlfiles_Autoupdate('CM.DLL','596D744BEB23A50BCEAD721452B75077','1.10.0.1',To_Date('2000-09-20 15:42:18', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'快速和方便的C++运算功能库，LIS使用',0,0,Null);
EXECUTE Zlfiles_Autoupdate('CODEJOCK.COMMANDBARS.9600.LIC','ED46DCDCF57502AEAA7BE86D252F437B',Null,To_Date('2005-12-23 07:53:32', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Codejock Xtreme Suite Pro ActiveX License',0,0,Null);
EXECUTE Zlfiles_Autoupdate('CODEJOCK.COMMANDBARS.9600.OCX','CABB63F5268AA4FD0D097743ABD903F1','9.6.0.0',To_Date('2005-12-23 07:53:32', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Codejock Xtreme Suite Pro ActiveX，公用界面控件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('CODEJOCK.COMMANDBARS.UNICODE.9600.OCX','809AFFE35F156F1AFE034A6619CAA512','9.6.0.0',To_Date('2005-12-23 07:53:34', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Codejock Xtreme Suite Pro ActiveX，公用界面控件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('CODEJOCK.DOCKINGPANE.9600.LIC','3A676CD407912795EAF5237CFB5AC227',Null,To_Date('2005-12-23 07:53:34', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Codejock Xtreme Suite Pro ActiveX License',0,0,Null);
EXECUTE Zlfiles_Autoupdate('CODEJOCK.DOCKINGPANE.9600.OCX','DA1C0D8AC594334A25D03A089C88D356','9.6.0.0',To_Date('2005-12-23 07:53:34', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Codejock Xtreme Suite Pro ActiveX，公用界面控件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('CODEJOCK.DOCKINGPANE.UNICODE.9600.OCX','067A890FC0FA47DB4A5253F9401FC2EA','9.6.0.0',To_Date('2005-12-23 07:53:34', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Codejock Xtreme Suite Pro ActiveX，公用界面控件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('CODEJOCK.PROPERTYGRID.9600.LIC','8AA50250F7A5771E8868B08643032F30',Null,To_Date('2005-12-23 07:53:34', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Codejock Xtreme Suite Pro ActiveX License',0,0,Null);
EXECUTE Zlfiles_Autoupdate('CODEJOCK.PROPERTYGRID.9600.OCX','A59F212A58789CB0041AD6D6C9DFE9C4','9.6.0.0',To_Date('2005-12-23 07:53:34', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Codejock Xtreme Suite Pro ActiveX，公用界面控件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('CODEJOCK.PROPERTYGRID.UNICODE.9600.OCX','5A5C9DB738260CF7386732CB1A2BE7BD','9.6.0.0',To_Date('2005-12-23 07:53:34', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Codejock Xtreme Suite Pro ActiveX，公用界面控件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('CODEJOCK.REPORTCONTROL.9600.LIC','FD979FF45D93E43B9527E420A6BB531D',Null,To_Date('2005-12-23 07:53:34', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Codejock Xtreme Suite Pro ActiveX License',0,0,Null);
EXECUTE Zlfiles_Autoupdate('CODEJOCK.REPORTCONTROL.9600.OCX','FAD0A8D707F057AF7B0388DB99409409','9.6.0.0',To_Date('2005-12-23 07:53:34', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Codejock Xtreme Suite Pro ActiveX，公用界面控件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('CODEJOCK.REPORTCONTROL.UNICODE.9600.OCX','93C69111E3EB48D3A2BE3612C3BCA11E','9.6.0.0',To_Date('2005-12-23 07:53:34', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Codejock Xtreme Suite Pro ActiveX，公用界面控件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('CODEJOCK.SUITECTRLS.9600.LIC','30089843FEDBE8FD2F66BD536CB12DB1',Null,To_Date('2005-12-23 07:53:34', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Codejock Xtreme Suite Pro ActiveX License',0,0,Null);
EXECUTE Zlfiles_Autoupdate('CODEJOCK.SUITECTRLS.9600.OCX','B72B2DD6B5810F48D6FD1F1136166B6E','9.6.0.0',To_Date('2005-12-23 07:53:34', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Codejock Xtreme Suite Pro ActiveX，公用界面控件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('CODEJOCK.SUITECTRLS.UNICODE.9600.OCX','9B0B4585A130DCA83436A12AD6386CC3','9.6.0.0',To_Date('2005-12-23 07:53:34', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Codejock Xtreme Suite Pro ActiveX，公用界面控件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('CTS2R.DLL','D0DC712EC17AC883B2F5EEEEF4B086A5',Null,To_Date('2003-07-17 09:53:58', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'NJF-VH语音报价接口文件',0,0,Null);
EXECUTE Zlfiles_Autoupdate('CTSVR.EXE','5E7FBB0B5070E73620AD725F9F6028B7','1.0.0.1',To_Date('2010-04-27 14:04:30', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'NJF-VH语音报价接口文件',0,0,Null);
EXECUTE Zlfiles_Autoupdate('Codejock.SyntaxEdit.v15.3.1.lic','26046FB1E5310C24FF62EC9B2FC79C0F',Null,To_Date('2014-09-10 16:33:02', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:10', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Xtreme CommandBars ActiveX Control 15.3.1的许可文件',0,0,Null);
EXECUTE Zlfiles_Autoupdate('Codejock.SyntaxEdit.v15.3.1.ocx','7010CEB71C0AEAFFE49A16EF5A27E582','15.3.1.0',To_Date('2014-09-10 16:33:04', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:10', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Xtreme CommandBars ActiveX Control 15.3.1',1,0,Null);
EXECUTE Zlfiles_Autoupdate('Crcdes.dll','95B6B837D8454841F23EFB8146F70427',Null,To_Date('2002-06-09 17:35:48', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,Null,0,0,Null);
EXECUTE Zlfiles_Autoupdate('Crwicc.dll','021E3D2EEF171A651D28B24A960D0276',Null,To_Date('2002-06-09 17:35:50', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,Null,0,0,Null);
EXECUTE Zlfiles_Autoupdate('DICOMOBJECTS.LIC','596DE9629453A9EBF6963492B6A79122',Null,To_Date('2004-10-01 10:23:28', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'DicomObjects注册文件',0,0,Null);
EXECUTE Zlfiles_Autoupdate('DICOMOBJECTS.OCX','09A8853D33F1DD50C04C5B3920DD0F49','4.3.82.2',To_Date('2009-10-21 16:07:52', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'DicomObjects，PACS观片站使用',1,0,Null);
EXECUTE Zlfiles_Autoupdate('DVDPROX2.DLL','9E71EFB14917D41448ECC43AAECCAB51','1.0.0.8',To_Date('2006-07-05 11:13:48', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'DVDWriterPro2 ActiveX Control，PACS使用',1,0,Null);
EXECUTE Zlfiles_Autoupdate('EZTW32.DLL','F0E99175D1F85098CD23D54ED7C9B761',Null,To_Date('2005-12-23 07:53:34', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'扫描仪API，电子病历使用',0,0,Null);
EXECUTE Zlfiles_Autoupdate('FINDFILE.AVI','416F9E50BA85BC43A5EB464AB74F6151',Null,To_Date('1998-04-24 00:00:00', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),3,'[APPSOFT]\附加文件',Null,'1',Null,0,0,Null);
EXECUTE Zlfiles_Autoupdate('FLASH.OCX','C917184D61A06B1E144AB48EB4AE43C1','6.0.23.0',To_Date('2002-07-14 16:10:38', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Macromedia Flash Player ActiveX Control，导诊，LED使用。',0,0,Null);
EXECUTE Zlfiles_Autoupdate('FLASH9F.OCX','48FDF435B8595604E54125B321924510','9.0.124.0',To_Date('2008-03-25 10:32:42', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[System]',Null,Null,Null,0,0,Null);
EXECUTE Zlfiles_Autoupdate('FTP_TRANS.DLL','1EE7A40E279D3036EFAEF2F4C63033FC',Null,To_Date('2002-06-09 17:35:50', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'FTP传输、加密API库，医保使用',0,0,Null);
EXECUTE Zlfiles_Autoupdate('Gapi32.dll','DCA8111D07CADD143207FBA3C2CA4B98','4.0.994.25',To_Date('1998-04-24 00:00:00', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,Null,0,0,Null);
EXECUTE Zlfiles_Autoupdate('HASHCTL.DLL','A33B99621F6AA045F14EC8A263CC3A03','10.0.2316.0',To_Date('2003-06-25 10:31:24', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[System]',Null,Null,Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('HOSP_INTERFACE_FYPROJ.OCX','043A05A17EA272E87E89DDB78C434B63',Null,To_Date('2002-08-01 11:36:42', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[System]',Null,Null,Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('ICAPI.DLL','09F7414ECEEF633B972DFCE5A3D233F8',Null,To_Date('2002-07-22 10:21:08', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'中软医保接口API库',0,0,Null);
EXECUTE Zlfiles_Autoupdate('ICREAD.DLL','A2F1668C08DF5BE7A945F886F57DA0D8',Null,To_Date('2002-06-09 17:35:50', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'医保用的IC卡读卡API接口库',0,0,Null);
EXECUTE Zlfiles_Autoupdate('ICWRITE.DLL','944C8EFC0F69DC83FF4FFFA8971CDF57',Null,To_Date('2002-06-09 17:35:50', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'医保用的IC卡写卡API接口库',0,0,Null);
EXECUTE Zlfiles_Autoupdate('IME.EXE','6242B69581D9CF830BE82632F655775D','4.0.1381.1',To_Date('2014-10-16 16:58:54', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:10', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\TOOLS',Null,Null,Null,0,0,Null);
EXECUTE Zlfiles_Autoupdate('IMGCMN.DLL','229997F4C39A5304378FDA4A8374FDB1','5.0.2134.1',To_Date('2010-03-29 17:43:32', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Kodak扫描控件支持库，影像采集对Twain接口的支持',0,0,Null);
EXECUTE Zlfiles_Autoupdate('IMGSCAN.OCX','3CFA184C981CE73EF8BF7DAE05CD89FE','5.0.2134.1',To_Date('2010-03-29 17:43:32', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Kodak Image Scan for Windows，PACS使用',0,0,Null);
EXECUTE Zlfiles_Autoupdate('IMGSHL.DLL','A54B4B5473CDC0ABC8F1DB095FC9D489','5.0.2134.1',To_Date('2010-03-29 17:43:32', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Kodak扫描控件支持库，影像采集对Twain接口的支持',0,0,Null);
EXECUTE Zlfiles_Autoupdate('INMONEYONLINE.DLL','FE0580F5F7BCDFCBD33F8922FEEE30F8',Null,To_Date('2002-09-05 16:14:50', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'医保用的IC卡处理API接口库',0,0,Null);
EXECUTE Zlfiles_Autoupdate('ISHF_EX.TLB','07934C956B971F10B7F73D55239AB976',Null,To_Date('2005-12-23 07:53:34', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'IShellFolder Extended Type Library 1.2，病历编辑器和表格病历使用',0,0,Null);
EXECUTE Zlfiles_Autoupdate('JPEG1X32.DLL','1E7919CC2305C6F15E0DC476B0440686','4.10.0.2000',To_Date('2010-03-29 17:43:32', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Kodak扫描控件支持库，影像采集对Twain接口的支持',0,0,Null);
EXECUTE Zlfiles_Autoupdate('JPEG2X32.DLL','8E73DD953D4A6FA116B2CE4CB7647B0D','4.10.0.2000',To_Date('2010-03-29 17:43:32', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Kodak扫描控件支持库，影像采集对Twain接口的支持',0,0,Null);
EXECUTE Zlfiles_Autoupdate('LAME_ENC.DLL','803B4ABFE7552D12640E292159F2280C',Null,To_Date('2010-12-28 16:20:24', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[System]',Null,Null,'视频采集支持文件',0,0,Null);
EXECUTE Zlfiles_Autoupdate('LNCATOOLKITS.OCX','096D3A2C35AD2D1599993608A5B17794','2.5.0.1',To_Date('2005-11-18 17:01:52', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'辽宁CA电子签名接口控件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('LSOUND.DIC','4CC6D271CE620C06049D43A9A0511634',Null,To_Date('2009-05-19 14:14:56', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'排队叫号语音库',0,0,Null);
EXECUTE Zlfiles_Autoupdate('MSINET.OCX','90A39346E9B67F132EF133725C487FF6','6.1.97.82',To_Date('2013-05-02 10:13:26', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[System]',Null,Null,'Microsoft Internet Transfer Control，自动升级、PACS等使用',1,0,Null);
EXECUTE Zlfiles_Autoupdate('MSSTKPRP.DLL','D08A99C462298C041139789627168A0B','6.0.81.69',To_Date('1998-06-18 00:00:00', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[System]',Null,Null,Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('Msprpchs.dll','92930846270F378F23A4BB1F206FC79E','6.0.81.63',To_Date('1998-07-29 00:00:00', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,Null,0,0,Null);
EXECUTE Zlfiles_Autoupdate('OIADM400.DLL','1A6E7C331F871E8099F544D2F81A6E74','4.10.0.2000',To_Date('2010-03-29 17:43:34', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Kodak扫描控件支持库，影像采集对Twain接口的支持',0,0,Null);
EXECUTE Zlfiles_Autoupdate('OICOM400.DLL','8F9693CD3BBECE1A12B151927C9DEE9A','4.10.0.2000',To_Date('2010-03-29 17:43:34', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:15', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Kodak扫描控件支持库，影像采集对Twain接口的支持',0,0,Null);
EXECUTE Zlfiles_Autoupdate('OIDIS400.DLL','89D0BD8C2E9C3596B97D47FAE11CCCE1','4.10.0.2000',To_Date('2010-03-29 17:43:36', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:16', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Kodak扫描控件支持库，影像采集对Twain接口的支持',0,0,Null);
EXECUTE Zlfiles_Autoupdate('OIENG400.DLL','931764D251736C753E821222D7C0824A','5.0.2134.1',To_Date('2010-03-29 17:43:36', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:16', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Kodak扫描控件支持库，影像采集对Twain接口的支持',0,0,Null);
EXECUTE Zlfiles_Autoupdate('OIFIL400.DLL','CCCB9B2E0DDB66953202A991E9E717B6','4.10.0.2000',To_Date('2010-03-29 17:43:36', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:16', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Kodak扫描控件支持库，影像采集对Twain接口的支持',0,0,Null);
EXECUTE Zlfiles_Autoupdate('OIGFS400.DLL','683521ADC21EE6C668518FE650464F15','4.10.0.2000',To_Date('2010-03-29 17:43:36', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:16', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Kodak扫描控件支持库，影像采集对Twain接口的支持',0,0,Null);
EXECUTE Zlfiles_Autoupdate('OIPRT400.DLL','CCA69D3352246AA42CA9A32F4E7705A3','5.0.2134.1',To_Date('2010-03-29 17:43:36', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:16', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Kodak扫描控件支持库，影像采集对Twain接口的支持',0,0,Null);
EXECUTE Zlfiles_Autoupdate('OISLB400.DLL','512956CB4ACEB022BBA873518E34BBDE','5.0.2134.1',To_Date('2010-03-29 17:43:38', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:16', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Kodak扫描控件支持库，影像采集对Twain接口的支持',0,0,Null);
EXECUTE Zlfiles_Autoupdate('OISSQ400.DLL','1E73D6F4ADDB4148377D89AD0203872D','5.0.2134.1',To_Date('2010-03-29 17:43:38', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:16', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Kodak扫描控件支持库，影像采集对Twain接口的支持',0,0,Null);
EXECUTE Zlfiles_Autoupdate('OITWA400.DLL','CDCF612BE58C12C32BBA4F8A97C76AF9','5.0.2134.1',To_Date('2010-03-29 17:43:38', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:16', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Kodak扫描控件支持库，影像采集对Twain接口的支持',0,0,Null);
EXECUTE Zlfiles_Autoupdate('OIUI400.DLL','2663E07C8D3E2D0B015A6C3C4351CB65','5.0.2134.1',To_Date('2010-03-29 17:43:38', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:16', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Kodak扫描控件支持库，影像采集对Twain接口的支持',0,0,Null);
EXECUTE Zlfiles_Autoupdate('OLCH2X8.OCX','4A6E99A3FD8EC2B0E0D5D3A2F2A6D219','8.0.20043.45',To_Date('2004-10-01 10:26:56', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:16', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'ComponentOne Chart 2D 8.0 OLE/ActiveX，自定义报表、LIS等使用',1,0,Null);
EXECUTE Zlfiles_Autoupdate('OLEGUIDS.TLB','21699843C3F8594D68263645ECE51DD3',Null,To_Date('2005-12-23 07:53:34', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:16', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Ole Guid  and Interface  Definitions，电子病历使用',0,0,Null);
EXECUTE Zlfiles_Autoupdate('OLELIB.TLB','ABA5F3549C922EA6B1BB9F8226C78362',Null,To_Date('2009-09-03 13:02:50', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:16', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Edanmo-s OLE interface & functions v1.81，LIS、电子病历使用',0,0,Null);
EXECUTE Zlfiles_Autoupdate('PDFTOTEXT.DLL','8C9F672996B03CE91678094F584CAED6','1.7.7.14',To_Date('2013-11-19 14:13:52', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:10', 'yyyy-mm-dd HH24:mi:ss'),4,'[System]',Null,Null,Null,0,0,Null);
EXECUTE Zlfiles_Autoupdate('QRMAKER.LIC','29C08475686167BBD20F1D3A0E8F053E',Null,To_Date('2013-11-19 14:13:28', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Microsoft Internet Transfer Control，自动升级、PACS等使用',0,0,Null);
EXECUTE Zlfiles_Autoupdate('QRMAKER.OCX','C00A0B76BC515DAA01060F7F9A230D0D','1.31.0.0',To_Date('2013-11-19 14:13:28', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Microsoft Internet Transfer Control，自动升级、PACS等使用',1,0,Null);
EXECUTE Zlfiles_Autoupdate('READBARCOMM.DLL','8BDFF3C6AC2ECC26503016D51C948257','1.0.0.1',To_Date('2005-01-11 10:20:32', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:16', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'海量公司二维条码识别控件，医保用',1,0,Null);
EXECUTE Zlfiles_Autoupdate('SHLEXT.TLB','FD0EBEFD50F7AD036F9DAA93715A285B',Null,To_Date('2005-12-23 07:53:34', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:16', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Shell Extension Interfaces v1.01，病历编辑器和表格病历使用',0,0,Null);
EXECUTE Zlfiles_Autoupdate('SQLite3.dll','8A1CBAE63FC06EDAEDCCE1B23E9C9267','3.7.5.111',To_Date('2014-07-15 14:27:22', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'SQLite相关支持文件',0,1,Null);
EXECUTE Zlfiles_Autoupdate('SSMDRAW.DLL','9256921D458CD02E6706DACA57771BB3','1.0.0.1',To_Date('2009-02-16 11:14:14', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:16', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Graphic Process DLL，LIS用',0,0,Null);
EXECUTE Zlfiles_Autoupdate('SSMG7.DLL','1FA6998784F256AC8D56B73F2D15024F','1.0.0.0',To_Date('2005-01-19 21:40:34', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:16', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'GIF图形处理工具，LIS用',0,0,Null);
EXECUTE Zlfiles_Autoupdate('STRSOUND.DLL','C66CBE7551F0E70C6379DCBDA6167D55','1.0.0.1',To_Date('2009-05-19 14:14:56', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:16', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'排队叫号语音输出程序',0,0,Null);
EXECUTE Zlfiles_Autoupdate('Sdtapi.dll','1640584FF35B1B9820E28DE5C8C59F4B',Null,To_Date('2011-06-24 10:53:56', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:16', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,Null,0,0,Null);
EXECUTE Zlfiles_Autoupdate('Sqlite36_engine.dll','0C9BA5358338BC4A141F0F2D1E83B275',Null,To_Date('2014-07-15 14:27:22', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'SQLite引擎文件',0,1,Null);
EXECUTE Zlfiles_Autoupdate('TTF16.OCX','AE9B2EE1564B46045E078D4618C2834E','6.1.4.1',To_Date('2001-06-28 19:42:54', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:16', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Formula One OLE Control，主要是表格病历使用',1,0,Null);
EXECUTE Zlfiles_Autoupdate('UNZIP32.DLL','8326C4DCD9EBD90ED4C0C14FBAAAC1C3','1.1.0.0',To_Date('2002-06-09 17:35:50', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:16', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Info-ZIP-s UnZip Windows DLL',0,0,Null);
EXECUTE Zlfiles_Autoupdate('VSFLEX8.OCX','46DD6C80DCCDB51F83FBDC8CB739B6ED','8.0.20041.202',To_Date('2006-08-09 12:03:48', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:16', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'ComponentOne VSFlexGrid 8 (OLEDB/ADO)，公用控件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('VSPRINT8.OCX','61B0322CAAB5646A7DBE2DE794A00AF7','8.0.20082.148',To_Date('2009-09-03 13:02:50', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:16', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'ComponentOne VSPrinter8 Control，LIS使用',1,0,Null);
EXECUTE Zlfiles_Autoupdate('WBX.TXT','BBFDF552D55B81FE987A9D816B4B9846',Null,To_Date('2003-01-20 14:17:36', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),3,'[APPSOFT]\附加文件',Null,'1',Null,0,0,Null);
EXECUTE Zlfiles_Autoupdate('WINCMP3.EXE','4A8C0E6B9E9537418FAADAB1223376AE','4.2.0.2221',To_Date('2013-11-19 14:13:54', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:10', 'yyyy-mm-dd HH24:mi:ss'),4,'[System]',Null,Null,Null,0,0,Null);
EXECUTE Zlfiles_Autoupdate('Wltrs.dll','0F50CAABFB6CF343B65DC6594D495175',Null,To_Date('2011-06-24 10:53:58', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:16', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,Null,0,0,Null);
EXECUTE Zlfiles_Autoupdate('XCDZIP35.OCX','E2259545A6EDABFABF613CB7BE765CDA','3.5.0.0',To_Date('2004-06-18 09:10:32', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:16', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Xceed Zip ActiveX Control，收费价格导入用',1,0,Null);
EXECUTE Zlfiles_Autoupdate('XTPRESOURCEZHCN.DLL','C241E8B935C2B35763FEAAB2209AADBC',Null,To_Date('2005-12-23 07:53:34', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:16', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Codejock Xtreme Suite Pro ActiveX 中文语言文件',0,0,Null);
EXECUTE Zlfiles_Autoupdate('XTXAPPCOM.DLL','8829809B322B2479550FB174A80B7487','2.0.1.5',To_Date('2013-01-22 10:06:20', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:16', 'yyyy-mm-dd HH24:mi:ss'),4,'[System]',Null,Null,'Microsoft Internet Transfer Control，自动升级、PACS等使用',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZIP32.DLL','65B137E17EE7D9E400B7AB20C55F8FCF','1.1.0.0',To_Date('2002-06-09 17:35:50', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:16', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'Info-ZIP-s Zip dll',0,0,Null);
EXECUTE Zlfiles_Autoupdate('ZL9BillEdit.ocx','8EE6B672D9FB072D9C09141CC8DE9ADD','10.35.40',To_Date('2017-03-06 14:46:08', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),0,'[Public]',Null,Null,'表格控件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZL9Insure.dll','336FB2D40DA0956D89C332DC9B74846D','10.35.30',To_Date('2017-03-01 15:42:50', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),0,'[Public]',Null,Null,'医保部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZL9LABWork.dll','47D9E2DDDD37535B698B29813BB27351','10.35.40',To_Date('2017-03-06 15:10:47', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'25','新版LIS不仅安',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZL9LisInsideComm.dll','98A3C73360F7614C67E76E3A8FE510CA','10.35.40',To_Date('2017-03-06 17:46:36', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'1,22,21,25','新版LIS与HIS接口部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZL9PACSIMAGECAP.DLL','BC3CE5E38A003055FC94052B53BC9E1E','10.35.40',To_Date('2017-03-06 15:07:38', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:25:11', 'yyyy-mm-dd HH24:mi:ss'),1,'[Appsoft]\Apply',Null,'1',Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZL9TEMPERATURECHARTSD.dll','F9C1EFE2F8CA33F7BA258A3C917863C3','10.35.40',To_Date('2017-03-08 11:55:03', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[Appsoft]\apply',Null,'1','山东省专用体温部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZL9TemperaTureChartYN.Dll','AD4B02A130AEE33ED655E0004E80D222','10.35.40',To_Date('2017-03-08 11:54:30', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[Appsoft]\Apply','zl9CISJob.dll','1','云南大理专用体温部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLDSVIDEOPROCESS.OCX','915B1465C101552783EF186341BDA99A','1.2.74',To_Date('2016-08-03 14:10:50', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),1,'[Public]','zl9CardSquare.dll,zl9PACSWork.dll','1,21,22,24,26',Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLFLAG.AVI','4AC428B4D37D58BF77555CDD1EBFCBC4',Null,To_Date('1999-05-21 16:29:08', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),3,'[APPSOFT]\附加文件',Null,'1',Null,0,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLHIS+.exe','4E35B0BE8A775BB7ECABC8A2423702C3','10.35.40',To_Date('2017-03-06 14:48:17', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),0,'[APPSOFT]',Null,Null,Null,0,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLHISCRUST.EXE','9D799F496834E4E6D463EB5D3E999945','10.35.40',To_Date('2017-03-06 14:47:37', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),0,'[APPSOFT]',Null,Null,'部件升级程序',0,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLLOGIN.DLL','E1405EF49C88A1ECD295C2A29040C158','10.35.40',To_Date('2017-03-06 15:13:24', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:25:11', 'yyyy-mm-dd HH24:mi:ss'),0,'[Appsoft]\Public',Null,'1',Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLNewQuery.exe','591702DC63412D627F2E23893DE9451A','10.35.40',To_Date('2017-03-06 14:51:22', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]','ZLNewQuery.exe','1',Null,0,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLPacsBrowserStation.exe','8F1D75B19CD6111B66DAAC7C6DB2BCB3','10.35.40',To_Date('2017-03-08 14:48:44', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]','zl9PACSWork.dll','1','独立观片站',0,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLREGISTER.DLL','1B3D9C45BD7055C9DF29548D7E00E3D4','10.35.30',To_Date('2016-09-14 09:16:32', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:25:11', 'yyyy-mm-dd HH24:mi:ss'),0,'[Appsoft]\Public',Null,'1',Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLRUNAS.exe','CACE237C26F0699C63828FF3D79B8566','9.43.0',To_Date('2013-11-04 10:14:23', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),0,'[APPSOFT]',Null,Null,'该文件在自动升级zlhisCrust.exe中使用。主要功能,在USER权限下可以使用管理员权限来进行登录执行管理操作',0,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLUZIP10.DLL','90C34787F181708DC15233E06A275CBE','1.1.0',To_Date('2006-04-28 16:48:38', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),0,'[SYSTEM]',Null,Null,'ZIP解压部件',0,0,Null);
EXECUTE Zlfiles_Autoupdate('ZLZIP11.DLL','ABEE1079EA3F3E74C933915BF10A7B9B','1.1.0',To_Date('2006-04-28 16:48:38', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),0,'[SYSTEM]',Null,Null,'ZIP压缩部件',0,0,Null);
EXECUTE Zlfiles_Autoupdate('Zl9DrugStore.dll','9AF29EC6283E0D2F7EB9207B6704D8D7','10.35.40',To_Date('2017-03-08 10:38:42', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','Zl9DrugStore.dll','1','药房处理部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('Zl9LISComm.exe','EEB097F5373EAD042088D2979D37DEC5','10.35.30',To_Date('2016-11-08 08:59:10', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]','zl9LisWork.dll','1','老版LIS仪器设置程序',0,0,Null);
EXECUTE Zlfiles_Autoupdate('ZlBrw.dll','EE20F766D38A3D62E9028F226C0E2936','10.35.40',To_Date('2017-03-06 14:48:18', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),0,'[APPSOFT]\APPLY','zl9BaseItem.dll,zl9CISBase.dll,zl9InExse.DLL',Null,'导航台部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZlMdi.dll','50ADDA3B457A9A337CA554F0A4ED43C1','10.35.40',To_Date('2017-03-06 14:48:22', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),0,'[APPSOFT]\APPLY',Null,Null,Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZlPacsSrv.exe','3D3B38FE0604A0C539612740A9ECDAD5','10.35.40',To_Date('2017-03-06 15:05:32', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]','zl9PACSWork.dll','1','PACS网关服务程序',0,0,Null);
EXECUTE Zlfiles_Autoupdate('ZlPatiAddress.ocx','CDD4D2B8B6D2E9F1588B21C970F6BE84','10.35.40',To_Date('2017-03-02 17:50:22', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),1,'[Public]','zl9CISJob.dll,zl9InExse.DLL,zl9InPatient.dll,zl9MedRec.dll','1,3','地址录入控件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('ZlWin.dll','CCCF90C353735F8669F5C654A1517D4D','10.35.40',To_Date('2017-03-06 14:48:25', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),0,'[APPSOFT]\APPLY',Null,Null,Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('_sql.schclass','DB00476956C307C75B75808662F482BE',Null,To_Date('2014-09-10 16:33:01', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:10', 'yyyy-mm-dd HH24:mi:ss'),4,'[Public]',Null,Null,'SyntaxEdit控件SQL颜色方案配置文件。',0,0,Null);
EXECUTE Zlfiles_Autoupdate('avi.bmp','919525151F3194043A5FD1A9F75B8A07',Null,To_Date('2011-02-11 17:23:58', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),3,'[APPSOFT]\附加文件',Null,'1',Null,0,0,Null);
EXECUTE Zlfiles_Autoupdate('aviDownLoad.bmp','852B762B823B345C939C67CD3D517271',Null,To_Date('2011-02-11 17:24:00', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),3,'[APPSOFT]\附加文件',Null,'1',Null,0,0,Null);
EXECUTE Zlfiles_Autoupdate('codejock.calendar.v16.3.1.lic','EA1945B52D982049E4CAA7EA28AA9877',Null,To_Date('2016-07-15 15:27:48', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:25:39', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,Null,0,0,Null);
EXECUTE Zlfiles_Autoupdate('codejock.calendar.v16.3.1.ocx','78ED7FE2F2076E79AE2E8FA2D40B44CF','16.3.1.0',To_Date('2016-07-15 15:27:48', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:25:39', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('dhRichClient3.dll','9A40975DD04C50B128D9C6D288671054','3.0.0.25',To_Date('2014-07-15 14:27:22', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]',Null,Null,'SQLite相关文件',1,1,Null);
EXECUTE Zlfiles_Autoupdate('vfpodbc.dll','294F954734F66A9BFF02B57BA4ED7D72','6.1.8629.1',To_Date('1999-12-07 05:00:00', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:16', 'yyyy-mm-dd HH24:mi:ss'),4,'[SYSTEM]','zl9MedRec.dll',Null,'该文件为创建dbf文件的驱动文件',0,1,Null);
EXECUTE Zlfiles_Autoupdate('wav.bmp','F9433769970E83406522C0BE89C9E186',Null,To_Date('2011-02-11 17:24:00', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),3,'[APPSOFT]\附加文件',Null,'1',Null,0,0,Null);
EXECUTE Zlfiles_Autoupdate('wavDownLoad.bmp','F8ADC35B1E3C436D0B1207147359C2DF',Null,To_Date('2011-02-11 17:24:00', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),3,'[APPSOFT]\附加文件',Null,'1',Null,0,0,Null);
EXECUTE Zlfiles_Autoupdate('zL9Analysis.dll','FDECD666AA7DB03A96DB9F404CFD21D9','10.35.30',To_Date('2016-11-08 08:47:35', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zL9Analysis.dll','1','查询分析部件（涂建华）？？？',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zL9CashBill.dll','D95C01D96B362B994F09BED7CEE24547','10.35.40',To_Date('2017-03-06 14:49:25', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zL9CashBill.dll','1,21','财务监控部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9AppTool.dll','13291D221C8F57750D28F4AB13B7DC44','10.35.40',To_Date('2017-03-06 14:47:04', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:10', 'yyyy-mm-dd HH24:mi:ss'),0,'[Public]',Null,Null,'字典管理工具',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BaseItem.dll','30FDDE077336A03A1259DAA9023D7B2D','10.35.40',To_Date('2017-03-08 10:37:58', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9BaseItem.dll','1,3,4,6,21','基础设置部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Blood.dll','3D29B9187AEC04986BF12F9F846BC76E','10.35.40',To_Date('2017-03-06 15:05:42', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9Blood.dll','22','血库系统部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BodyEditor.dll','A1B8E8BC7B1B4E02103A0E74233C8D32','10.35.40',To_Date('2017-03-02 14:49:04', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll,zl9Oper.dll','1,24','体温单部件（系统自带，老版）',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BodyEditorGS.dll','9CD6BDB9CDBF511D040B8578FC2FF80B','10.35.40',To_Date('2017-03-08 11:09:57', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','体温单部件（甘肃，老版）',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BodyEditorGX.dll','A324DF858D90C0B3C05DBAEB999F4807','10.35.40',To_Date('2017-03-08 11:10:07', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','体温单部件（广西，老版）',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BodyEditorHEN.dll','7B34C157A8C064D71485D3649F6D4210','10.35.40',To_Date('2017-03-08 11:10:27', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','体温单部件（河南，老版）',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BodyEditorHN.dll','9BCC14388564552DB310E9B0492B7F42','10.35.40',To_Date('2017-03-08 11:09:48', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','体温单部件（河南，老版）',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BodyEditorHun.dll','C1E1B7B3DA51E725DB0B0AA12A90FAA5','10.35.40',To_Date('2017-03-08 11:10:45', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','体温单部件（湖南，老版）',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BodyEditorQD.dll','96871ADE63F15D48E255EBF559A76E14','10.35.40',To_Date('2017-03-08 11:10:17', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','体温单部件（青岛，老版）',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BodyEditorSCDQ.dll','6C4249C5DE90E9C99557E0247EC7DC22','10.35.40',To_Date('2017-03-08 11:09:19', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','体温单部件（四川，老版）',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BodyEditorSXHZ.dll','1AD7EF17C8900546ACBBD365DCFE9310','10.35.40',To_Date('2017-03-08 11:09:38', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','陕西汉中专用体温部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BodyEditorSxet.dll','026B6213C40C6A3297FBF1E706B1F6B2','10.35.40',To_Date('2017-03-08 11:10:36', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','体温单部件（陕西儿童医院，老版）',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BodyEditorYDEY.dll','A0F455C528217C25430502918B8646C4','10.35.40',To_Date('2017-03-08 11:09:27', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','体温单部件（医大二院，老版）',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9BodyEditorYX.dll','C12717649DCF19098750C639C3441FBC','10.35.40',To_Date('2017-03-08 11:09:09', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','玉溪市人民医院专用体温部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9CISAudit.dll','B88827C3A26F75F080E19B922C6F1710','10.35.40',To_Date('2017-03-06 15:05:52', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISAudit.dll','1','电子病历监控',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9CISBase.dll','B0C72CF53BD4B526F21D3CFC7C5DED4B','10.35.40',To_Date('2017-03-08 10:40:38', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISBase.dll','1','基础设置部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9CISCore.dll','DCA83973D2079E44E9761612371195AC','10.35.40',To_Date('2017-03-06 10:20:37', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'1','这几个部件应该是老版医生站相关，是否可以取消？',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9CISJob.dll','60CC35F1D85FDA967F847E834E95728A','10.35.40',To_Date('2017-03-07 09:18:53', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'1','临床工作站',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9CardSquare.dll','2F65C1920DBA42EDD7EC9CFEFC888354','10.35.40',To_Date('2017-03-06 14:53:26', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9BaseItem.dll,zl9Blood.dll,zl9CISBase.dll,zl9InExse.DLL,zl9PeisManage.dll','1,21,22,24','一卡通相关部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9ComLib.dll','8673F68F45B08C323F3834C8FAD4A0DA','10.35.40',To_Date('2017-03-06 09:41:22', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),0,'[Public]',Null,Null,'公共部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9ComLibpss.dll','A63D66AEEA66CEFB06E133390E1BB1D2','10.35.30',To_Date('2016-11-08 09:05:05', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:10', 'yyyy-mm-dd HH24:mi:ss'),1,'[Public]','zl9WizardManage.dll','26',Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9CommEvents.dll','3ADC8789A62DC4094F78B3B29534DEBA','10.35.40',To_Date('2017-03-08 11:42:03', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),1,'[Public]','zl9CardSquare.dll,zl9WizardCards.dll,zl9WizardDeposit.dll,zl9WizardFeeQuery.dll,zl9WizardPayFee.dll,zl9WizardPeisQueue.dll,zl9WizardRegEvent.dll,zlWizardNewLabPrint.dll,zlWizardPacsPrint.dll','1,21,22,24,26','一卡通公共事务部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9CustAcc.dll','99B0721BE5AFE26E426A641E2F9F2143','10.35.40',To_Date('2017-03-06 14:49:31', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[Public]','zl9InExse.DLL,zl9OutExse.dll','1','自定义收费单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Device.dll','F0F7F7674C68AECCB09C60F24E08CEEE','10.35.40',To_Date('2017-03-07 15:04:45', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9Device.dll','6','设备相关部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Disease.dll','71A86B8F568BCB77F5CADD7FA6E8593E','10.35.40',To_Date('2017-03-06 14:55:18', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:25:39', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','疾病报告部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9DrawReport.dll','E8A52C3231273A2AA0F93E87B83F079C','10.35.40',To_Date('2017-03-06 15:06:10', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9Oper.dll,zl9PeisManage.dll','21,24','麻醉单打印和体检报告打印的公共处理程序',1,1,Null);
EXECUTE Zlfiles_Autoupdate('zl9Due.dll','4AB324798259F48AB0A6767D510B3948','10.35.40',To_Date('2017-03-06 14:50:35', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9Due.dll','1,4,6','应付账款部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9ESign.dll','16134869BE61348F6AE9DCC9795FBB6D','10.35.40',To_Date('2017-03-06 14:47:11', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),0,'[Public]',Null,Null,'签名部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Function.dll','6A6324A74F55C2215DB16BC8E3567578','10.35.30',To_Date('2016-11-08 08:44:07', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),0,'[Public]',Null,Null,'函数部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9I_Configure.dll','FBECDADC86437D14A0BB580452CEC522','9.29.0',To_Date('2015-11-30 10:01:32', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[Appsoft]\Apply',Null,'1','医保工具部件',1,1,Null);
EXECUTE Zlfiles_Autoupdate('zl9InExse.DLL','D0AE731248B7544670422EEBAB137926','10.35.40',To_Date('2017-03-06 14:54:58', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','住院收费部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9InPatient.dll','2CF657FE8791F20A9D8B628644CD1381','10.35.40',To_Date('2017-03-06 14:51:00', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','病人入出管理',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Infect.dll','5CFC6895672B43D235476AD2B02E8498','10.35.0',To_Date('2016-04-18 17:36:58', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9Infect.dll','23','院感系统部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9LCDShow.dll','7A34A90A75985CB2E0093C4B4D3B819C','10.35.40',To_Date('2017-03-08 11:17:57', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zlQueueManage.dll','1',Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9LabPrintSvr.exe','43E16A949D7D38987DE58C756453073E','10.35.20',To_Date('2016-08-17 13:41:51', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]',Null,'25','检验报告打印',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9LabReceiv.exe','CC8FB5ECCD138BFA28C305936E7136BC','10.35.40',To_Date('2017-03-06 15:09:23', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]',Null,'25','新版LIS通讯程序',0,0,'[APPSOFT]\DEV_[*]');
EXECUTE Zlfiles_Autoupdate('zl9LabTcpSvr.exe','96ADDFB20DE9CAD357CE0C56F215E4E1','10.35.0',To_Date('2015-12-01 09:20:47', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]',Null,'25',Null,0,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9LedVoice.dll','5992B93BE565C31068B811EAB30A1C07','10.35.40',To_Date('2017-03-06 14:46:11', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[Public]','zl9InExse.DLL,zl9InPatient.dll,zl9OutExse.dll,zl9Patient.dll,zl9RegEvent.dll','1','LED呼叫显示部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9LisQuery_Base.dll','E4AEDCE7605521A7700BE779248FA7E7','10.35.10',To_Date('2016-07-11 16:55:46', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9LisWork.dll','1','新版LIS的自定义查询部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9LisQuery_Dfn.dll','0BE8EEAD6D6EB47F9C63E2685EE955AF','10.35.0',To_Date('2015-12-01 09:06:50', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[Public]','zl9LisWork.dll','1','老版LIS自定义查询部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9LisWork.dll','4045171040683DAF77C4727AA00B9497','10.35.40',To_Date('2017-03-07 09:19:50', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9LisWork.dll','1','老版LIS部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Material.dll','43E7E601BC46987CD9C37972EDFAE822','10.35.40',To_Date('2017-03-06 15:04:38', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9Material.dll','4','物资系统部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9MedRec.dll','EF07A3988DDDA06BE8F1D3ACCAFFF016','10.35.40',To_Date('2017-03-06 15:05:05', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:10', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9MedRec.dll','3','病案系统部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9MediStore.dll','532074C32B6E50B41C6B7A27CCDC0E01','10.35.40',To_Date('2017-03-08 16:12:56', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9MediStore.dll','1','药品流通处理部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Medical.dll','DEB456258A601EA7E6D751F50D6DC129','10.34.0',To_Date('2014-08-26 11:10:17', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'1','老版体检部件，现在未用可以取消',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Oper.dll','B386834D8E4920D5C1BC2F3019C25F16','10.35.40',To_Date('2017-03-06 15:06:48', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'24','手麻部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Ops.dll','07D54DAA3207F3FC212407F6224A8AB4','10.34.0',To_Date('2014-10-30 22:33:19', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'1','老版手麻系统',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9OpsStarand.dll','5BE38ED9CA82CB944262A4886249C385','10.35.3',To_Date('2016-10-31 11:29:25', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'24','麻醉单输出格式',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9OutExse.dll','BA7E9D3F0C57381519910170FF22D5B5','10.35.40',To_Date('2017-03-06 14:51:56', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9OutExse.dll','1','门诊收费部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PACSWork.dll','203631107FE3B14D7998AB6CBF1359B8','10.35.40',To_Date('2017-03-06 15:08:36', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9PACSWork.dll','1','PACS工作站部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PacsCapture.exe','CBDB085A9B92470CD1DA54C7F0985E75','10.35.0',To_Date('2015-12-01 09:17:41', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9PACSWork.dll','1','因影像采集系统的视频采集方式优化调整,而独立出来的ActivexExe项目',1,1,Null);
EXECUTE Zlfiles_Autoupdate('zl9PacsControl.ocx','2873B93BD95B5790376CFBE431D125F1','10.35.40',To_Date('2017-03-06 15:07:27', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9PACSWork.dll','1','因影像采集系统的视频采集方式优化调整,而独立出来的pacs所需组件.',1,1,Null);
EXECUTE Zlfiles_Autoupdate('zl9PacsCore.dll','DC16C35201A5945E356B80B30E937FDE','10.35.40',To_Date('2017-03-06 15:07:22', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9PACSWork.dll,zl9PeisManage.dll','1,21','观片站部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Partogram.dll','F0973870CE85E0A0CF917D34191E8C51','10.35.0',To_Date('2016-04-18 10:49:33', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'1','产程图专用部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Patient.dll','1DD6CC3B96DFBEEE805BF8EB6C960FCE','10.35.40',To_Date('2017-03-06 14:51:40', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9Patient.dll','1','病人管理部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PeisBase.dll','CFEA3A8C9FB2E2D9B81E70C2ABDE9739','10.35.40',To_Date('2017-03-06 15:13:17', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9PeisManage.dll','21','体检基础业务',1,1,Null);
EXECUTE Zlfiles_Autoupdate('zl9PeisComLib.dll','560C4CC938D7376969A9259942853559','10.35.40',To_Date('2017-03-06 10:21:09', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[Public]','zl9PeisManage.dll','21','体检公共资源部件',1,1,Null);
EXECUTE Zlfiles_Autoupdate('zl9PeisDevAnalyse.dll','191FB33503B62F5F44588EFB0B4606E6','10.35.0',To_Date('2015-12-01 09:22:53', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9PeisManage.dll','21','体检外接仪器接口（非标准的接口）',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PeisFlow.dll','91F78749AA4AF1D9E9AE30F4F270FFED','10.35.40',To_Date('2017-03-06 15:12:28', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9PeisManage.dll','21','体检执行业务',1,1,Null);
EXECUTE Zlfiles_Autoupdate('zl9PeisInnerInterface.dll','C5ADA19D0E61979EC0A06E5D97F9EB3F','10.35.40',To_Date('2017-03-06 15:11:44', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9PeisManage.dll','21','体检内部接口',1,1,Null);
EXECUTE Zlfiles_Autoupdate('zl9PeisInstrument.dll','E72B4A469D1F491BB4DA1E110169A4E2','10.35.0',To_Date('2015-12-01 09:20:44', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9PeisManage.dll','21','体检外接仪器接口（准的串口接口）',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PeisInterface.dll','26F9A8D3CFDEA0B62E165B3A397EA8FB','10.35.40',To_Date('2017-03-06 15:48:53', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9PeisManage.dll','21','第三方体检接口部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PeisManage.dll','DF3A37DAFE92B5BF19E04760930D93D7','10.35.40',To_Date('2017-03-06 15:13:07', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'21','体检管理业务部件',1,1,Null);
EXECUTE Zlfiles_Autoupdate('zl9PeisPersonPDF.dll','4427D023C90DD3B19F9BB02FFD2539EA','10.35.40',To_Date('2017-03-07 15:06:00', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLy',Null,'21','体检个人报告（PDF格式）',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PeisPersonReport.dll','E3919232F4B4B467D6DBB7FD59AD066C','10.35.40',To_Date('2017-03-07 15:15:07', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'21','体检个人报告中的一种格式，专门用于处理报表类的个人报告',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PeisPersonRpt.dll','305B4846501741A6926A58D39B258179','10.35.40',To_Date('2017-03-06 15:08:28', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9PeisManage.dll','21','个人体检报告',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PeisRpt.dll','43CA019426158C6D2B04E16D74E3CA9B','10.35.40',To_Date('2017-03-06 15:06:33', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9PeisManage.dll','21','固定格式的个人报告',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9PrintMode.dll','1990EC57E45D2BCAFF54B207204759A2','10.35.40',To_Date('2017-03-06 14:46:20', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),0,'[Public]',Null,Null,'打印部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Purvey.dll','E8E47FF97A2F64855F1339200301697E','10.35.40',To_Date('2017-03-06 15:06:06', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9Material.dll','4','供应室部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9RTFCreator.dll','57F781977E1DA406D0F4A71FAC7ADB00','10.35.0',To_Date('2015-12-01 09:04:05', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[Public]','zl9CISJob.dll','1','老版电子病历导出为RTF使用的部件，在用需要保留。',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9RecipeAudit.dll','8A8334EBACB25A54113150EC03F3E455','10.35.40',To_Date('2017-03-06 15:13:21', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[Appsoft]\Apply','zl9CISJob.dll','1','处方审核系统',1,1,Null);
EXECUTE Zlfiles_Autoupdate('zl9RegEvent.dll','7A0B1548B2E8BA5EDD2FFE39F048EF18','10.35.40',To_Date('2017-03-06 14:53:12', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9RegEvent.dll','1','挂号部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Report.dll','A901ACA01DF871ECE9650E4141FA23EF','10.35.40',To_Date('2017-03-08 11:38:42', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),0,'[Public]',Null,Null,'报表部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Stuff.dll','80A6E02E64EFFA7E4DCC47CE676720DF','10.35.40',To_Date('2017-03-06 14:53:13', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9Stuff.dll','1','卫材管理部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TaxBill.dll','F1F8F76590E9A0A0F24EEEF81044410E','10.35.40',To_Date('2017-03-06 14:46:54', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),1,'[Public]','zl9InExse.DLL,zl9OutExse.dll,zl9WizardPayFee.dll,zl9WizardRegEvent.dll','1,26','税控打印部件（标准版是安装）',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TechCore.dll','332AA3BD3D88AF55DB4B3CB4CFC86DE7','10.35.0',To_Date('2015-12-01 09:12:50', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'1',Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChart.dll','25746E7C3965ED0B4B4C7133A2B9A6A2','10.35.40',To_Date('2017-03-08 11:52:36', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','体温单部件（系统自带，老版）',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChartGD.dll','4B1CC1912AFE63878A447E63AD83D068','10.35.40',To_Date('2017-03-08 11:54:14', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'1','广东省专用体温部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChartGS.dll','1FB5622975674DA72CFD8C0C76185788','10.35.40',To_Date('2017-03-08 11:53:12', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'1','体温单部件（甘肃，新版）',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChartGX.dll','BD13371E8B381C11F29FA4AF2F6AA8A9','10.35.40',To_Date('2017-03-08 11:52:49', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'1','体温单部件（广西，新版）',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChartHnnx.dll','0D0EBDDDF94BD6723EFC885C0C54B3DF','10.35.40',To_Date('2017-03-08 11:53:42', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'1','湖南宁乡人民医院专用部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChartNJ.dll','B3F9CEF43DB6CDB984F84F3110525DF3','10.35.40',To_Date('2017-03-08 11:54:47', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'1','江苏省专用体温部件',1,1,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChartS3201.dll','5E176905D9CD953F97D21D21D6408E10','10.35.40',To_Date('2017-03-08 11:53:00', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'1','陕西汉中3201医院',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChartSC.dll','7D342E4F3E137DBB6527AA0DD34C0750','10.35.40',To_Date('2017-03-08 11:52:08', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'1','四川专用体温部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChartSCZG.dll','66E94E66D85AC4D66EC578E3B4287C4D','10.35.40',To_Date('2017-03-08 11:52:24', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'1','四川自贡地区专用体温部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChartSX.dll','682696F8C01F57932A0275DDAF361938','10.35.40',To_Date('2017-03-08 11:53:29', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'1','山西地区专用体温部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TemperatureChartYDEY.dll','52272B1592B3A1E2E76C976A10E3F939','10.35.40',To_Date('2017-03-08 11:53:57', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'1','体温单部件（医大二院，新版）',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9TendFile.dll','D4A4676DCB717A5E7D72521C6992C7C6','10.35.40',To_Date('2017-03-06 14:57:28', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll,zl9Oper.dll','1,24','护理记录单',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9Transfusion.dll','6058756FB279D8A1F74D78D4EB6FCE1F','10.35.40',To_Date('2017-03-08 10:40:34', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9Transfusion.dll','1','门诊输液部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WardMonitor.dll','8D35B71860EEBAB22EBD39050EBF983F','10.35.0',To_Date('2015-12-01 09:06:54', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[Public]','zl9CISJob.dll','1','护士工作站(非新版)嵌入监护仪界面使用的部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardCards.dll','7963B7E6C63331EAE08DC4EB4AF210B1','10.35.40',To_Date('2017-03-08 14:11:36', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:10', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'26',Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardControl.ocx','E3DB10E515050E2C8229223A48E229E4','10.35.40',To_Date('2017-03-08 11:39:13', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:10', 'yyyy-mm-dd HH24:mi:ss'),1,'[Public]','zl9WizardManage.dll,zl9WizardPage.dll','26',Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardDeposit.dll','7462E4FFEA7C36CF3AB3071F382D5B65','10.35.40',To_Date('2017-03-08 14:10:34', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:10', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'26',Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardEMR.dll','685324BC79AB0885D0BA3352CAFB2387','10.35.40',To_Date('2017-03-08 14:11:46', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:10', 'yyyy-mm-dd HH24:mi:ss'),1,'[Appsoft]\Apply',Null,'26','门诊病历自助打印',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardFeeQuery.dll','47E39D0F1130F8299463AE760EC8DB29','10.35.40',To_Date('2017-03-08 14:10:42', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:10', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'26',Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardInvoicePrint.dll','BCE3C0CF8BCD846DCB2AD4F438A78E31','10.35.40',To_Date('2017-03-08 14:10:50', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:10', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'26',Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardLABCall.dll','1A7E1B561EDF642DA466115F29A99A46','10.35.40',To_Date('2017-03-08 15:38:23', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:10', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'26',Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardLabPrint.dll','78CB1F72235BD0287AC5045248663B20','10.35.40',To_Date('2017-03-08 14:10:55', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:10', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'26',Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardLib.dll','504C3B3AF91445DDF74F34968171A939','10.35.40',To_Date('2017-03-08 11:39:48', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:10', 'yyyy-mm-dd HH24:mi:ss'),1,'[Public]','zl9WizardManage.dll,zl9WizardPage.dll','26',Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardMain.exe','5E611C9821DB3AA8D1E4DE8068D0F7AF','10.35.40',To_Date('2017-03-08 10:12:40', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:10', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]',Null,'26',Null,0,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardManage.dll','34041AECB74FBB327B9F676B4E0E5DE7','10.35.40',To_Date('2017-03-08 14:10:11', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:10', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'26',Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardPage.dll','61533BFD091D3A6F2ED26E89E1707FE6','10.35.40',To_Date('2017-03-08 14:09:44', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:10', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'26',Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardPayFee.dll','6AB2DBDFA199CE520BB58BD705383FE0','10.35.40',To_Date('2017-03-08 14:11:10', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:10', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'26',Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardPeisQueue.dll','2E3E31D1545527596FEA29BD92E0747E','10.35.40',To_Date('2017-03-08 15:18:03', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:10', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9WizardManage.dll','26',Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardPharmacy.dll','45C1B505BEC01F34EF7BEA930301CD5A','10.35.40',To_Date('2017-03-08 14:12:06', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:25:39', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9WizardManage.dll','26',Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardPrice.dll','3C314282182080E6B1B386E249A8C773','10.35.40',To_Date('2017-03-08 14:09:47', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:10', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'26',Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardProficient.dll','1B5D5FFC49BD6528DD300014E0B5141E','10.35.40',To_Date('2017-03-08 14:09:54', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:10', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'26',Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardProof.dll','8009EC6851F1FBCFFCE90608EC3FB6BA','10.35.40',To_Date('2017-03-08 14:12:02', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:10', 'yyyy-mm-dd HH24:mi:ss'),1,'[Appsoft]\Apply',Null,'26','自助凭条件打印',1,1,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardRegEvent.dll','6788518F1CFF36D956B5CFFFBAA9B260','10.35.40',To_Date('2017-03-08 14:11:33', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:10', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'26',Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9WizardToday.dll','AD67158FE86103C1C1C75EAA8553F1AA','10.35.40',To_Date('2017-03-08 14:10:00', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:10', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'26',Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9keyboard.dll','94EFD2A89C9714355BDC7BB8EA7F8143','10.35.0',To_Date('2015-12-01 09:01:40', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),1,'[Public]','zl9CardSquare.dll,zl9ComLibpss.dll,zl9InPatient.dll,zl9Patient.dll,zl9RegEvent.dll','1,21,22,24,26','密码键盘的接口部件',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zl9peisgrouprpt.dll','45E3AB0197D303231A550100EB0CF594','10.35.40',To_Date('2017-03-07 15:35:28', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9PeisManage.dll','21','团队体检报告部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlActMain.exe','7CC4876A5420B69547E80C4A6056514E','10.35.40',To_Date('2017-03-08 15:36:00', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]',Null,'1','BH融合启动程序',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zlCISKernel.dll','34417BBA8F9A03C1800E6062B4EF9B31','10.35.40',To_Date('2017-03-06 14:55:09', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9Blood.dll,zl9CISAudit.dll,zl9CISBase.dll,zl9CISJob.dll,zl9LisWork.dll,zl9Oper.dll,zl9Ops.dll,zl9PACSWork.dll,zl9Transfusion.dll','1,21,22,24','临床公共部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlCISPath.dll','90C19E1EFF5BA37BFBE1FD6EC6231EBB','10.35.40',To_Date('2017-03-06 14:55:42', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','临床路径相关部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlCisAuditPrint.EXE','D2D2EA2F455EE03242531A86FF1F5CFD','10.35.30',To_Date('2016-10-24 14:27:21', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'1','用于电子病案审查中对病案进行PDF批量输出，以防止GDI泄露',0,1,Null);
EXECUTE Zlfiles_Autoupdate('zlCommunity.dll','982A1CC45A89BD54061CAFD37CC5BC5A','10.35.40',To_Date('2017-03-06 14:51:45', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[Public]','zl9BaseItem.dll,zl9CISJob.dll,zl9RegEvent.dll','1','社区接口部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlDataOracle.dll','9963D738201D9B5948714579458F8F01','10.35.0',To_Date('2015-12-01 08:53:59', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),0,'[Public]',Null,Null,'消息集成平台ZLHIS客户端公共部件',1,1,Null);
EXECUTE Zlfiles_Autoupdate('zlDataSQLite.dll','4C5A2923C0A3B5264ED3B32E316D3179','10.35.0',To_Date('2015-12-01 08:54:01', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),0,'[Public]',Null,Null,'消息集成平台ZLHIS客户端公共部件',1,1,Null);
EXECUTE Zlfiles_Autoupdate('zlDisReportCard.DLL','94E36A2EE7F50DD000DB65D6F0EC5827','10.35.40',To_Date('2017-03-06 15:13:15', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','ZLRICHEPR.DLL,ZL9DISEASE.DLL','1','传染病报告卡专用编辑器',1,1,Null);
EXECUTE Zlfiles_Autoupdate('zlGetImage.exe','0B732B8809DD7A96191D6FB86B63C6D2','10.35.0',To_Date('2015-12-01 09:19:46', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9PACSWork.dll','1','PACS观片下载图像',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zlGetImageEx.exe','7B548F51F375D84777CD61F0930D9D3C','10.35.0',To_Date('2015-12-01 09:24:50', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:13', 'yyyy-mm-dd HH24:mi:ss'),1,'[Appsoft]\Apply',Null,'1','zlGetImageEx是使用ActiveExe的方式实现后台进程加载及上传图像，是一个ActiveExe部件',1,1,Null);
EXECUTE Zlfiles_Autoupdate('zlGrant.dll','D1C83ED751EF296AC18791135D3C6E3B','9.0.2',To_Date('2004-10-08 18:48:18', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),0,'[Public]',Null,Null,'授权部件',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zlICCard.dll','1AC360E9715581D2C2F7AB9C2605ABF9','10.35.0',To_Date('2015-12-01 09:02:28', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),0,'[Public]',Null,Null,Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlIDCard.dll','B0867F6913815BFBD0B9D9C67572207F','10.35.0',To_Date('2015-12-01 09:02:25', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),0,'[Public]',Null,Null,Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlIDKind.ocx','CD1C520335C6E2D23776D00C43470F96','10.35.40',To_Date('2017-03-06 14:45:51', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),0,'[Public]',Null,Null,Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlLISDev.dll','E31A4AF897463A0CAC341B60F840351E','10.35.0',To_Date('2015-12-01 09:16:26', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9LisWork.dll','25,1','LIS仪器接口部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlLISInterface.DLL','D50E3B0322623B12A0D3000C27243D7D','10.35.30',To_Date('2016-11-08 09:09:59', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'1','LIS第三方接口',1,1,Null);
EXECUTE Zlfiles_Autoupdate('zlLisReceiveSend.exe','1A7E194151478D9BE76375DBF4890389','10.35.0',To_Date('2015-12-01 09:12:48', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]','zl9LisWork.dll','1',Null,0,0,Null);
EXECUTE Zlfiles_Autoupdate('zlMedRecPage.dll','BB0C48B1C219EE0881F58EA081DCC422','10.35.40',To_Date('2017-03-06 14:47:35', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),0,'[Public]',Null,Null,'首页相关信息的统一部件,主要包括电子病案审查查阅,诊断选择器,门诊首页,住院首页,病案首页窗体.  ',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlMipClient.dll','531EA518F537DA0A3085D269D5235336','1.0.0',To_Date('2014-05-26 15:03:40', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),4,'[Public]',Null,Null,'消息集成平台接口',1,1,Null);
EXECUTE Zlfiles_Autoupdate('zlMipClientComLib.dll','0D6D2333DBCE41913EB05F73A1F5006B','10.35.0',To_Date('2015-12-01 08:54:08', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),0,'[Public]',Null,Null,'消息集成平台ZLHIS客户端公共部件',1,1,Null);
EXECUTE Zlfiles_Autoupdate('zlMipClientManage.exe','B686B7BCD8E021DD88496B538E494C6E','10.35.0',To_Date('2015-12-01 08:54:22', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),0,'[AppSoft]',Null,Null,'消息集成平台ZLHIS客户端后台管理程序（exe）',0,1,Null);
EXECUTE Zlfiles_Autoupdate('zlMipClientPoll.exe','1BDD1B42D83A56AC90DC831A71EE2EE8','10.35.0',To_Date('2015-12-01 08:54:19', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),0,'[AppSoft]',Null,Null,'消息集成平台ZLHIS客户端轮询检查服务程序（exe）',0,1,Null);
EXECUTE Zlfiles_Autoupdate('zlMipClientShell.exe','63EA8CA7D98D030000D472D6C294E2F0','10.35.0',To_Date('2015-12-01 08:54:20', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),0,'[Public]',Null,Null,'消息集成平台ZLHIS客户端公共部件(ActiveX EXE)',1,1,Null);
EXECUTE Zlfiles_Autoupdate('zlOperInterface.dll','1383F6D368FB08008AA619CE4D143D1A','10.35.40',To_Date('2017-03-06 15:07:54', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'24','第三方手麻接口部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlOrclConfig.exe','BFC1E7171D907BB30B5A82FAAC4BED0F','10.35.0',To_Date('2015-12-01 09:23:20', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]',Null,'1,3,4,6,21,22,23,24,25,26','用于快速配置ORACLE配置文件的工具。',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zlPacsRichPages.ocx','1AECE8FE5ABB73B5DC04BE911A46D289','1.3520.345',To_Date('2016-08-08 15:17:06', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),0,'[Public]',Null,Null,'新Pacs报告编辑器核心处理控件',1,1,Null);
EXECUTE Zlfiles_Autoupdate('zlPacsVBCommon.dll','F4DBD6AED0FAD0BBB074B9A8365BF0EF','10.35.30',To_Date('2016-11-08 09:03:10', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),0,'[Public]',Null,Null,'新版PACS报告编辑器和vb层PACS程序交互的部件',1,1,Null);
EXECUTE Zlfiles_Autoupdate('zlPassInterface.dll','6FA34755ABE2B63E675EF71B4B7F5E88','10.35.40',To_Date('2017-03-06 14:53:40', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),0,'[Public]',Null,Null,'从ZLCisKernel里提取出来的合理用药接口部件',1,1,Null);
EXECUTE Zlfiles_Autoupdate('zlPeisAutoAnalyse.exe','AF020DFF5AC935B95B7983E3D280AA0E','10.35.40',To_Date('2017-03-08 14:51:34', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]','zl9PeisManage.dll','21','非标准接口的服务程序',0,0,Null);
EXECUTE Zlfiles_Autoupdate('zlPictureEditor.dll','803646F0D9FC07C8900373153842BA89','10.35.0',To_Date('2015-12-01 09:08:01', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),1,'[Public]','zl9CISJob.dll','1,22,24','是否只有标准版用到',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlPublicAdvice.dll','AD0C8BB5A6658B1F5A2FA9C37989479A','10.35.40',To_Date('2017-03-06 14:55:45', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),0,'[Public]',Null,Null,'医嘱业务封装公共部件',1,1,Null);
EXECUTE Zlfiles_Autoupdate('zlPublicExpense.dll','6F3C1416C44E2D69A9F665F6BCE2C066','10.35.40',To_Date('2017-03-06 14:47:55', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),0,'[Public]',Null,Null,'医嘱附费部件',1,1,Null);
EXECUTE Zlfiles_Autoupdate('zlPublicLIS.dll','A0B7E31EC93612D7E9E7CC1CB1CDC0AC','10.35.40',To_Date('2017-03-02 14:41:10', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),0,'[Public]',Null,Null,Null,1,1,Null);
EXECUTE Zlfiles_Autoupdate('zlPublicPacs.dll','ED140C5B3835240AB603060BAD945A3F','10.35.40',To_Date('2017-03-06 14:56:44', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),0,'[Public]',Null,Null,'pacs依赖业务封装部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlPublicPath.dll','5631A6B20F4576C9F6E5C6C457F965EB','10.35.30',To_Date('2016-11-08 08:55:28', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),0,'[Public]',Null,Null,'路径业务封装公共部件',1,1,Null);
EXECUTE Zlfiles_Autoupdate('zlPublicPatient.dll','0E83EEED08357F2FCC69C8702904ED00','10.35.40',To_Date('2017-03-06 14:55:50', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),0,'[Public]',Null,Null,'病人管理业务封装公共部件',1,1,Null);
EXECUTE Zlfiles_Autoupdate('zlPublicPeis.dll','D06D09AE0E7BCFDC603F14AD704BDD65','10.35.0',To_Date('2015-12-01 09:03:42', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),0,'[Public]',Null,Null,'体检业务封装公共部件',1,1,Null);
EXECUTE Zlfiles_Autoupdate('zlQueueManage.dll','E4EAD522CEFD148B923B8AB1C5C58FCC','10.35.40',To_Date('2017-03-08 11:41:58', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll,zl9PACSWork.dll,zl9PeisManage.dll,zl9RegEvent.dll','1,21','排队叫号部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlQueueOper.ocx','AC9A03F941FAE9EAE96FE322ACC9D2AC','10.35.40',To_Date('2017-03-06 15:06:47', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),0,'[Public]','zl9PACSWork.dll',Null,Null,1,1,Null);
EXECUTE Zlfiles_Autoupdate('zlQueueShow.exe','6884D9711C3743E02C3C4B0DF0A14C68','10.35.40',To_Date('2017-03-06 15:13:29', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\zlQueueShow',Null,'1','新版排队叫号显示程序',0,1,Null);
EXECUTE Zlfiles_Autoupdate('zlRecipeAuditEx.dll','969D919DCB63D6877A2AA17FD3477A2E','10.35.0',To_Date('2015-12-01 09:25:35', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),1,'[Appsoft]\Apply','zl9CISJob.dll','1','处方审查系统的外挂部件（用户可自行维护）',1,1,Null);
EXECUTE Zlfiles_Autoupdate('zlRichEPR.DLL','525CD74FCACA06AD111CDD678CBC053B','10.35.40',To_Date('2017-03-08 10:40:28', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9Blood.dll,zl9CISAudit.dll,zl9CISJob.dll,zl9LisWork.dll,zl9Oper.dll,zl9Ops.dll,zl9PACSWork.dll','1,22,24','老版电子病历相关部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlRichEditor.ocx','12926132DDA42F93D02BA3580837756D','10.35.40',To_Date('2017-03-06 14:53:52', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),1,'[Public]','zl9Blood.dll,zl9CISJob.dll,zl9Oper.dll','1,22,24','电子病历编辑控件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlScreenKeyboard.exe','B8C3E47A26784CA912ADD4C91B43A991','10.35.0',To_Date('2015-12-01 09:23:05', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9CISJob.dll','1','小键盘程序文件位置调整',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlSubclass.ocx','58D1C1E0EB97540476970B61CBD7CC60','10.35.0',To_Date('2015-12-01 09:08:03', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),1,'[Public]','zl9Blood.dll,zl9CISJob.dll,zl9Oper.dll','1,22,24','电子病历低层消息处理的部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlSvgProcess.dll','9E00926BA33C621864432B114DF8CE93','1.0.3',To_Date('2015-09-29 16:24:43', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),0,'[Public]',Null,Null,'用于处理svg图像',1,1,Null);
EXECUTE Zlfiles_Autoupdate('zlSvrNotice.exe','3AA0AB15921689208EEF21EE50208071','10.35.30',To_Date('2016-11-08 08:45:11', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:10', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]',Null,Null,Null,0,0,Null);
EXECUTE Zlfiles_Autoupdate('zlSvrStudio.exe','3E3ACF6FE9107F081C58A5C968357AFA','10.35.40',To_Date('2017-03-08 12:02:20', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:10', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]',Null,Null,Null,0,0,Null);
EXECUTE Zlfiles_Autoupdate('zlSwitchEffect.dll','55968705B856B2947F168E114D35309C','10.35.0',To_Date('2015-12-01 09:22:27', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:10', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'26',Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlSwitchPage.dll','EDB7BEA3A23946049A12248AC02AD01E','10.35.0',To_Date('2015-12-01 09:22:25', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:10', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'26',Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlTable.ocx','4DD3E56B8D287A4C88A1E73F0273BCAC','10.35.0',To_Date('2015-12-01 09:08:17', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),1,'[Public]','zl9Blood.dll,zl9CISJob.dll,zl9Oper.dll,zl9PACSWork.dll','1,22,24','表格控件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlTableEPR.dll','992F2075475A7559F1801A3B8E9AE86A','10.35.40',To_Date('2017-03-06 14:53:38', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:11', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY','zl9Blood.dll,zl9CISJob.dll,zl9Oper.dll','1,22,24','表格电子病历相关部件',1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlVSFlexGrid.dll','74AAB740FFFA50077602CCEC909756CF','10.35.0',To_Date('2015-12-01 08:54:03', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:12', 'yyyy-mm-dd HH24:mi:ss'),0,'[Public]',Null,Null,'消息集成平台ZLHIS客户端公共部件',1,1,Null);
EXECUTE Zlfiles_Autoupdate('zlWizardNewLabPrint.dll','8D549CAD7CBAF74FA438FD73DECE1C08','10.35.40',To_Date('2017-03-08 15:16:20', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:10', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'26',Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlWizardPacsPrint.dll','A76E6F21E50651D86BCC84FB8B4B9014','10.35.40',To_Date('2017-03-08 14:11:44', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:10', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]\APPLY',Null,'26',Null,1,0,Null);
EXECUTE Zlfiles_Autoupdate('zlWizardStart.exe','40BD5A565E58BE7F8B6C1B9386B3EEBE','10.35.40',To_Date('2017-03-06 15:48:57', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:10', 'yyyy-mm-dd HH24:mi:ss'),1,'[APPSOFT]',Null,'26',Null,0,0,Null);
EXECUTE Zlfiles_Autoupdate('打印.AVI','C181F16316913B78F518EFB789581084',Null,To_Date('2003-02-14 17:37:12', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),3,'[APPSOFT]\附加文件',Null,'1',Null,0,0,Null);
EXECUTE Zlfiles_Autoupdate('单病人宽屏深蓝.ini','2E78B1F478EDC7142842A433B1288CA3',Null,To_Date('2014-10-16 17:01:07', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),3,'[APPSOFT]\zlQueueShow\Skin\单病人样式',Null,'1','新版排队叫号显示程序的皮肤',0,0,Null);
EXECUTE Zlfiles_Autoupdate('单病人宽屏深蓝.jpg','25CF28EC30A8E6B893B53A1A41E66250',Null,To_Date('2014-10-16 17:01:07', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),3,'[APPSOFT]\zlQueueShow\Skin\单病人样式',Null,'1','新版排队叫号显示程序的皮肤',0,0,Null);
EXECUTE Zlfiles_Autoupdate('单队列宽屏浅紫.ini','771D5C66769E78214AAAD0978189E97C',Null,To_Date('2014-10-16 17:01:07', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),3,'[APPSOFT]\zlQueueShow\Skin\单队列样式',Null,'1','新版排队叫号显示程序的皮肤',0,0,Null);
EXECUTE Zlfiles_Autoupdate('单队列宽屏浅紫.jpg','D99E55E3C12482DBA258CC2EBA0249CE',Null,To_Date('2014-10-16 17:01:07', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),3,'[APPSOFT]\zlQueueShow\Skin\单队列样式',Null,'1','新版排队叫号显示程序的皮肤',0,0,Null);
EXECUTE Zlfiles_Autoupdate('单队列宽屏深蓝.ini','1D906F234FE8081784B8854E2B9761B0',Null,To_Date('2014-10-16 17:01:07', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),3,'[APPSOFT]\zlQueueShow\Skin\单队列样式',Null,'1','新版排队叫号显示程序的皮肤',0,0,Null);
EXECUTE Zlfiles_Autoupdate('单队列宽屏深蓝.jpg','2F5241399197FCA726FA3355C66B4F43',Null,To_Date('2014-10-16 17:01:07', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),3,'[APPSOFT]\zlQueueShow\Skin\单队列样式',Null,'1','新版排队叫号显示程序的皮肤',0,0,Null);
EXECUTE Zlfiles_Autoupdate('单队列宽屏天蓝.ini','95C216EC8FA5662BB73A42C2A0059EBC',Null,To_Date('2014-10-16 17:01:07', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),3,'[APPSOFT]\zlQueueShow\Skin\单队列样式',Null,'1','新版排队叫号显示程序的皮肤',0,0,Null);
EXECUTE Zlfiles_Autoupdate('单队列宽屏天蓝.jpg','40689FACC5B8DA5E11AA24903C48274C',Null,To_Date('2014-10-16 17:01:07', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),3,'[APPSOFT]\zlQueueShow\Skin\单队列样式',Null,'1','新版排队叫号显示程序的皮肤',0,0,Null);
EXECUTE Zlfiles_Autoupdate('单队列竖屏天蓝.ini','EAFFF1AEAFFDA6C8E0666ECCCB9543D1',Null,To_Date('2014-10-16 17:01:07', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),3,'[APPSOFT]\zlQueueShow\Skin\单队列样式',Null,'1','新版排队叫号显示程序的皮肤',0,0,Null);
EXECUTE Zlfiles_Autoupdate('单队列竖屏天蓝.jpg','A7381080C65DCD8C87105EB6C6FEC79F',Null,To_Date('2014-10-16 17:01:07', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),3,'[APPSOFT]\zlQueueShow\Skin\单队列样式',Null,'1','新版排队叫号显示程序的皮肤',0,0,Null);
EXECUTE Zlfiles_Autoupdate('多队列样式浅紫.ini','9DEB997BDE5D1E4E25CA540C84B96651',Null,To_Date('2014-10-16 17:01:07', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),3,'[APPSOFT]\zlQueueShow\Skin\多队列样式',Null,'1','新版排队叫号显示程序的皮肤',0,0,Null);
EXECUTE Zlfiles_Autoupdate('多队列样式浅紫.jpg','811E1412AFE4F228A2702E5ECFA6D2DA',Null,To_Date('2014-10-16 17:01:07', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),3,'[APPSOFT]\zlQueueShow\Skin\多队列样式',Null,'1','新版排队叫号显示程序的皮肤',0,0,Null);
EXECUTE Zlfiles_Autoupdate('多队列样式深蓝.ini','98857A8901F5801320A8E2C5E3ED6234',Null,To_Date('2014-10-16 17:01:07', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),3,'[APPSOFT]\zlQueueShow\Skin\多队列样式',Null,'1','新版排队叫号显示程序的皮肤',0,0,Null);
EXECUTE Zlfiles_Autoupdate('多队列样式深蓝.jpg','3BA502B067D6DDEA7B7B2BF0713AB16B',Null,To_Date('2014-10-16 17:01:08', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),3,'[APPSOFT]\zlQueueShow\Skin\多队列样式',Null,'1','新版排队叫号显示程序的皮肤',0,0,Null);
EXECUTE Zlfiles_Autoupdate('多队列样式天蓝.ini','95A2D13E95282C473D2EDE718EE1CCD6',Null,To_Date('2014-10-16 17:01:08', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),3,'[APPSOFT]\zlQueueShow\Skin\多队列样式',Null,'1','新版排队叫号显示程序的皮肤',0,0,Null);
EXECUTE Zlfiles_Autoupdate('多队列样式天蓝.jpg','BCCFD2F0617A1020A7FF8E8377E3F4B2',Null,To_Date('2014-10-16 17:01:08', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),3,'[APPSOFT]\zlQueueShow\Skin\多队列样式',Null,'1','新版排队叫号显示程序的皮肤',0,0,Null);
EXECUTE Zlfiles_Autoupdate('收费项目.xlsx','3769E6B8DD69023D34C8AFA17DEB4755',Null,To_Date('2014-01-09 11:11:41', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),3,'[APPSOFT]\附加文件',Null,'1',Null,0,0,Null);
EXECUTE Zlfiles_Autoupdate('卫材目录.xlsx','8D6E43900F148CACB72C4ECAAF372BE5',Null,To_Date('2014-01-09 11:11:41', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),3,'[APPSOFT]\附加文件',Null,'1',Null,0,0,Null);
EXECUTE Zlfiles_Autoupdate('药品目录.xlsx','92DDE8BE67C6978B9862D3E40F951A97',Null,To_Date('2014-01-09 11:11:41', 'yyyy-mm-dd HH24:mi:ss'),To_Date('2017-03-08 09:18:14', 'yyyy-mm-dd HH24:mi:ss'),3,'[APPSOFT]\附加文件',Null,'1',Null,0,0,Null);

--系统版本号
Update zlSystems Set 版本号='10.35.40' Where 编号=&n_System;
--部件版本号
Commit;
