Attribute VB_Name = "mReport"
Option Explicit

Public pReport_CheckViewName As String
Public pReport_ResultName As String
Public pReport_AdviceName As String

Public preWinProc As Long
Public fReport As frmReportWord
Public fReportElement As frmReportElement
Public glngEelmentWinProc As Long

Public Const ReportViewType_检查所见 = "检查所见"
Public Const ReportViewType_诊断意见 = "诊断意见"
Public Const ReportViewType_建议 = "建议"
Public Const ReportViewType_病理诊断 = "病理诊断"
Public Const ReportViewType_活检部位 = "活检部位"

'################################################################################################################
'## 功能：  在压缩文件相同目录释放产生解压文件
'## 参数：  strZipFile     :压缩文件
'## 返回：  解压文件名，失败则返回零长度""
'################################################################################################################
Public Function zlFileUnzip(ByVal strZipFile As String) As String
    Dim strZipPath As String
    Dim objFSO As Scripting.FileSystemObject     'FSO对象
    Dim clsUnzip As cUnzip
    
    Set objFSO = New Scripting.FileSystemObject
    Set clsUnzip = New cUnzip
    
    If strZipFile = "" Then Exit Function
    If Dir(strZipFile) = "" Then zlFileUnzip = "": Exit Function
    strZipPath = Left(strZipFile, Len(strZipFile) - Len(Dir(strZipFile)))
    If objFSO.FileExists(strZipPath & "TMP.RTF") Then objFSO.DeleteFile strZipPath & "TMP.RTF"
    
    With clsUnzip
        .ZipFile = strZipFile
        .UnzipFolder = strZipPath
        .Unzip
    End With
    If Dir(strZipPath & "TMP.RTF") <> "" Then
        zlFileUnzip = strZipPath & "TMP.RTF"
    Else
        zlFileUnzip = ""
    End If
End Function

'################################################################################################################
'## 功能：  将文件压缩为新文件放到相同目录中
'## 参数：  strFile     :原始文件
'## 返回：  压缩文件名，失败则返回零长度""
'################################################################################################################
Public Function zlFileZip(ByVal strFile As String) As String
    Dim strZipFile As String, lngCount As Long
    Dim clsZip As cZip
    
    Set clsZip = New cZip
    If strFile = "" Then Exit Function
    If Dir(strFile) = "" Then zlFileZip = "": Exit Function
    
    lngCount = 0
    Do While True
        strZipFile = Left(strFile, Len(strFile) - Len(Dir(strFile))) & "ZLZIP" & lngCount & ".ZIP"
        If Dir(strZipFile) = "" Then Exit Do
        lngCount = lngCount + 1
    Loop
    
    With clsZip
        .Encrypt = False: .AddComment = False
        .ZipFile = strZipFile
        .StoreFolderNames = False
        .RecurseSubDirs = False
        .ClearFileSpecs
        .AddFileSpec strFile
        .Zip
        If (.Success) Then
            zlFileZip = .ZipFile
        Else
            zlFileZip = ""
        End If
    End With
End Function


' 从电子病历中复制过来的一些过程
'################################################################################################################
'## 功能：  将指定的LOB字段复制为临时文件
'##
'## 参数：  Action      :操作类型（用以区别是操作哪个表）
'##         KeyWord     :确定数据记录的关键字，复合关键字以逗号分隔(仅5-电子病历格式为复合)
'##         strFile     :用户指定存放的文件名；不指定时，取当前路径产生文件名
'##
'## 返回：  存放内容的文件名，失败则返回零长度""
'##
'## 说明：  Action取值说明：
'##         0-病历标记图形；1-病历文件格式；2-病历文件图形；3-病历范文格式；4-病历范文图形；5-电子病历格式；6-电子病历图形；
'################################################################################################################
Public Function zlBlobRead(ByVal Action As Long, ByVal KeyWord As String, Optional ByRef strFile As String) As String
    
    Const conChunkSize As Integer = 10240
    Dim lngFileNum As Long, lngCount As Long, lngBound As Long
    Dim aryChunk() As Byte, strText As String
    Dim rsLob As New ADODB.Recordset
    
    err = 0: On Error GoTo errHand
    
    lngFileNum = FreeFile
    If strFile = "" Then
        lngCount = 0
        Do While True
            strFile = App.Path & "\zlBlobFile" & CStr(lngCount) & ".tmp"
            If Len(Dir(strFile)) = 0 Then Exit Do
            lngCount = lngCount + 1
        Loop
    End If
    Open strFile For Binary As lngFileNum
    
    gstrSQL = "Select Zl_Lob_Read(" & Action & ",'" & KeyWord & "'," & "[1]) as 片段 From Dual"
    lngCount = 0
    Do
        Set rsLob = zlDatabase.OpenSQLRecord(gstrSQL, "zlBlobRead", lngCount)
        If rsLob.EOF Then Exit Do
        If IsNull(rsLob.Fields(0).value) Then Exit Do
        strText = rsLob.Fields(0).value
        
        ReDim aryChunk(Len(strText) / 2 - 1) As Byte
        For lngBound = LBound(aryChunk) To UBound(aryChunk)
            aryChunk(lngBound) = CByte("&H" & Mid(strText, lngBound * 2 + 1, 2))
        Next
        
        Put lngFileNum, , aryChunk()
        lngCount = lngCount + 1
    Loop
    Close lngFileNum
    If lngCount = 0 Then Kill strFile: strFile = ""
    zlBlobRead = strFile
    Exit Function

errHand:
    Close lngFileNum
    Kill strFile: zlBlobRead = ""
End Function


'################################################################################################################
'## 功能：  判断指定用户是否是主任医师
'##
'## 参数：  lngUserID       ：用户ID
'##         strUserName     ：用户名
'##         lngPatiID       ：病人ID
'##         lngPatiPageID   ：主页ID
'##
'## 说明：  根据“人员表”中的“聘任技术职务”字段确定医生技术级别（住院医师、主治医师、主任医师）
'##         ＋病人变动记录中的医生级别，从而确定审核级别
'################################################################################################################
Public Function GetUserSignLevel(lngUserID As Long, Optional strUserName As String, _
    Optional lngPatiID As Long, Optional lngPatiPageID As Long) As EPRSignLevelEnum
    Dim RS As New ADODB.Recordset, lngR As Long, lngLevel1 As Long, lngLevel2 As Long
    
    err = 0: On Error GoTo errHand
    gstrSQL = "Select g.功能" & vbNewLine & _
            "From zlRoleGrant g, Sys.Dba_Role_Privs r, 上机人员表 p" & vbNewLine & _
            "Where r.Grantee = p.用户名 And g.角色 = r.Granted_Role And g.系统 = [2] And g.序号 = [3] And g.功能 = [4] And" & vbNewLine & _
            "      p.人员id = [1]" & vbNewLine & _
            "Union" & vbNewLine & _
            "Select [4] As 功能 From 上机人员表 p Where 用户名 = '" & UCase(UserInfo.用户名) & "' And p.人员id = [1]"
    Set RS = zlDatabase.OpenSQLRecord(gstrSQL, "mReport", lngUserID, glngSys, 1070, "签名权")
    If RS.RecordCount <= 0 Then GetUserSignLevel = cprSL_空白: Exit Function
    
    gstrSQL = "select 聘任技术职务 from 人员表 p where ID=[1]"
    Set RS = zlDatabase.OpenSQLRecord(gstrSQL, "mRichEPR", lngUserID)
    If Not RS.EOF Then
        lngR = Nvl(RS("聘任技术职务"), 0)
    End If
    Select Case lngR    '1 正高  2 副高  3 中级  4 助理/师级  5 员/士  9 待聘
    Case 1: lngLevel1 = cprSL_正高
    Case 2: lngLevel1 = cprSL_主任
    Case 3: lngLevel1 = cprSL_主治
    Case Else: lngLevel1 = cprSL_经治
    End Select
    RS.Close
    
    If lngPatiID > 0 Then
        gstrSQL = "Select 经治医师, 主治医师, 主任医师 " & _
            " From 病人变动记录 " & _
            " Where 病人ID = [1] And 主页ID = [2] And (终止时间 Is Null Or 终止原因 = 1) " & _
            "       And 开始时间 Is Not Null And Nvl(附加床位, 0) = 0"
        Set RS = zlDatabase.OpenSQLRecord(gstrSQL, "cEPRDocument", lngPatiID, lngPatiPageID)
        If RS.EOF Then
            lngLevel2 = cprSL_经治
        Else
            If RS.Fields("主任医师") = IIf(strUserName = "", UserInfo.姓名, strUserName) Then
                lngLevel2 = cprSL_主任
            ElseIf RS.Fields("主治医师") = IIf(strUserName = "", UserInfo.姓名, strUserName) Then
                lngLevel2 = cprSL_主治
            Else
                lngLevel2 = cprSL_经治
            End If
        End If
    End If
    GetUserSignLevel = IIf(lngLevel1 >= lngLevel2, lngLevel1, lngLevel2)
    Exit Function

errHand:
    GetUserSignLevel = cprSL_空白
End Function

'################################################################################################################
'## 功能：  搜索整个文本给出指定关键字区域的定位信息
'##
'## 参数：  edtThis         :   IN  ，编辑控件
'##         strKeyType      :   IN  ，给定关键字名称。取值为："O"、"P"、"T"、"E"、"U"
'##         lngKey           :   IN  ，给定欲查找的关键字ID号。
'##         lngKSS、lngKSE  :   OUT ，分别表示起始关键字的开始位置和结束位置；
'##         lngKES、lngKEE  :   OUT ，分别表示终止关键字的开始位置和结束位置；
'##         blnNeeded:      :   OUT ，是否是保留对象
'##
'## 返回：  如果找到该关键字具体位置，则返回True，否则返回False
'################################################################################################################
Public Function FindKey(ByRef edtThis As Object, _
        ByRef strKeyType As String, _
        ByRef lngKey As Long, _
        ByRef lngKSS As Long, _
        ByRef lngKSE As Long, _
        ByRef lngKES As Long, _
        ByRef lngKEE As Long, _
        ByRef blnNeeded As Boolean) As Boolean
        
    Dim i As Long, j As Long
    Dim sTMP As String
    Dim sText As String     '尽量少用.Text属性，因此用一个字符串变量来减少时间开支！
    
    sTMP = strKeyType & "S(" & Format(lngKey, "00000000")
    With edtThis
        sText = .Text   '只读取.Text属性1次！！！
        i = 1
LL1:
        i = InStr(i, sText, sTMP)
        If i <> 0 Then
            '看是否是关键字
            If .TOM.TextDocument.range(i - 1, i).Font.Hidden = False Then   '若为关键字，必须是隐藏且受保护的。
                i = i + 1
                GoTo LL1
            End If
            '已找到起始关键字
            
            '查找结束关键字
            j = i + 16
LL2:
            sTMP = strKeyType & "E(" & Format(lngKey, "00000000")
            j = InStr(j, sText, sTMP)
            If j <> 0 Then
                '看是否是关键字
                If .TOM.TextDocument.range(j - 1, j).Font.Hidden = False Then
                    j = j + 1
                    GoTo LL2
                End If
                '找到结束关键字
                strKeyType = strKeyType
                lngKSS = i - 1 '转换为0开始的坐标位置。
                lngKSE = i + 15
                lngKES = j - 1
                lngKEE = j + 15
                blnNeeded = -Val(.TOM.TextDocument.range(i + 11, i + 12))
                FindKey = True
            End If
        End If
    End With
End Function


Public Sub richTextBoxShowElements(rText As RichTextBox)
    Dim strSel As String
    Dim miESingleS As Integer
    Dim miESingleE As Integer
    Dim miEMultiS As Integer
    Dim miEMultiE As Integer
    
    
    '判断当前选中内容是否要素
    If rText.SelColor = vbBlue Then
        miESingleS = InStrRev(rText.Text, "{{", rText.SelStart, vbTextCompare)
        miEMultiS = InStrRev(rText.Text, "{<", rText.SelStart, vbTextCompare)
        If miESingleS > miEMultiS Then  '当前最接近光标的是单选要素
            miESingleE = InStr(rText.SelStart, rText.Text, "}}", vbTextCompare)
            miESingleE = miESingleE + 1
            If miESingleE > miESingleS Then
                '是单选要素
                strSel = Left(rText.Text, miESingleE)
                strSel = Right(strSel, miESingleE - miESingleS + 1)
                frmReportElement.ShowElement strSel, 0
                rText.SelStart = miESingleS - 1
                rText.SelLength = miESingleE - miESingleS + 1
                rText.SelText = frmReportElement.strReturnElement
            End If
        ElseIf miEMultiS > miESingleS Then  '当前最接近的是多选要素
            miEMultiE = InStr(rText.SelStart, rText.Text, ">}", vbTextCompare)
            miEMultiE = miEMultiE + 1
            If miEMultiE > miEMultiS Then
                '是多选要素
                strSel = Left(rText.Text, miEMultiE)
                strSel = Right(strSel, miEMultiE - miEMultiS + 1)
                frmReportElement.ShowElement strSel, 1
                rText.SelStart = miEMultiS - 1
                rText.SelLength = miEMultiE - miEMultiS + 1
                rText.SelText = frmReportElement.strReturnElement
            End If
        Else    '两个要素的位置相等，说明都等于0，当前什么要素都没有
        
        End If
    End If
End Sub

Public Function Wndproc(ByVal hWnd As Long, ByVal Msg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
    Dim pt As POINTL
    Dim wzDelta, wKeys As Integer
    On Error Resume Next
    wzDelta = OS.HIWORD(wParam)
    wKeys = OS.LOWORD(wParam)
    Select Case Msg
        Case WM_MOUSEWHEEL
            If fReport.picWordShow.Visible = False Or fReport.vscroWordH.Enabled = False Then Exit Function
            
            If Sgn(wzDelta) = 1 Then
                If fReport.vscroWordH.value - 1 < 0 Then
                    fReport.vscroWordH.value = 0
                Else
                    fReport.vscroWordH.value = fReport.vscroWordH.value - 1
                End If
            Else
                If fReport.vscroWordH.value + 1 > fReport.vscroWordH.Max Then
                    fReport.vscroWordH.value = fReport.vscroWordH.Max
                Else
                    fReport.vscroWordH.value = fReport.vscroWordH.value + 1
                End If
            End If
    End Select
    Wndproc = CallWindowProc(preWinProc, hWnd, Msg, wParam, lParam)
End Function

Public Function zlGetWordPower() As Integer
'******************************************************************************************************************
'功能：获得当前用户的词句管理的权限
'返回：词句管理权限数值
'******************************************************************************************************************
    Dim intWordPower As Integer
    Dim strPrivs As String
    
    strPrivs = ";" & GetPrivFunc(glngSys, 1070) & ";"
    If InStr(1, strPrivs, ";全院病历词句;") <> 0 Then
        intWordPower = 0
    ElseIf InStr(1, strPrivs, ";科室病历词句;") <> 0 Then
        intWordPower = 1
    ElseIf InStr(1, strPrivs, ";个人病历词句;") <> 0 Then
        intWordPower = 2
    Else
        intWordPower = -1
    End If
    zlGetWordPower = intWordPower
End Function

Public Function zlDefaultWordCode(lngClassID As Long) As String
'功能：设置词句示范的默认编号
'参数： lngClassID --- 词句分类ID

    Dim strSql As String
    Dim rsTemp As New ADODB.Recordset
    
    strSql = "Select LPad(Nvl(To_Number(Max(编号)), 0) + 1, Nvl(Max(Length(编号)), 5), '0') As 编码" & vbNewLine & _
            "From 病历词句示范" & vbNewLine & _
            "Where 分类id = [1]"
    err = 0: On Error Resume Next
    Set rsTemp = zlDatabase.OpenSQLRecord(strSql, "提取词句编号", lngClassID)
    zlDefaultWordCode = rsTemp.Fields(0).value
    
    Exit Function
errHand:
    If ErrCenter() = 1 Then Resume
    Call SaveErrLog
End Function

Public Function GetSignSourceString(int提取类型 As Integer, lngReportID As Long, int签名版本 As Integer, blnMoved As Boolean, _
    thisSign As cEPRSign, strSourceOut As String, ByVal strImg64 As String, Optional ByVal lngAdviceID As Long = 0) As Integer
'------------------------------------------------
'功能：获取用于电子签名，签名验证的报告源文内容
'参数： int提取类型 -- 1、签名时提取源文；2、签名验证时提取源文
'       lngReportID -- 报告ID，电子病历记录ID
'       int签名版本 -- 本次签名/验证签名提取源文的版本号
'       blnMoved --- 报告数据是否已经转储
'       thisSign --- 签名对象，签名的时候传入此对象，验证签名的时候传入nothing
'       strSourceOut -- 【返回】签名源文
'返回： 签名/验证签名的源文生成规则
'-----------------------------------------------
    Dim intRule As Integer
    Dim lng签名ID  As Long                  '签名所在的行的ID
    Dim strSql As String
    Dim rs病历记录 As ADODB.Recordset
    Dim rs病历内容 As ADODB.Recordset
    Dim rs签名记录 As ADODB.Recordset
    Dim str签名时间 As String
    Dim arr对象属性() As String
    Dim strSignName As String
    Dim strSignImgBase64 As String
    
    '源文提取规则：
    'intRule = 1时，提取 ID，病人ID，婴儿，创建人，创建时间，医生姓名，签名级别，签名时间,检查所见，诊断意见，建议
    '验证签名的时候，医生姓名，签名级别，签名时间从签名记录中获取，分别是医生姓名= “内容文本”，签名级别=“要素表示”，签名时间 =“对象属性（5）”
    '签名的时候，医生姓名，签名级别，签名时间 从签名对象中获取
    On Error GoTo err
    
    If lngReportID = 0 Or int签名版本 = 0 Then Exit Function
    
    
    '初始化默认值
    intRule = 1
    strSourceOut = ""
    
    '根据int提取类型 来判断是签名还是验证签名，分别从对应的地方提取数据
    '从电子病历记录中提取报告源文的基本信息
    strSql = "Select ID,病人ID,婴儿,创建人,创建时间 From 电子病历记录 Where Id = [1]"
    Set rs病历记录 = zlDatabase.OpenSQLRecord(strSql, "提取报告源文基本信息", lngReportID)
    If rs病历记录.RecordCount = 0 Then
        Exit Function
    End If
    
    '从电子病历内容中提取报告源文的内容信息
    strSql = "Select a.内容文本 As 标题, b.对象属性, b.内容文本 As 正文,b.开始版 as 版本 From 电子病历内容 a,电子病历内容 b " & _
             " Where a.文件id = [1] And a.对象类型 = 3 And a.Id = b.父ID And b.对象类型 = 2 and b.开始版 = [2]  "
    Set rs病历内容 = zlDatabase.OpenSQLRecord(strSql, "提取报告源文内容信息", lngReportID, int签名版本)
    If rs病历内容.RecordCount = 0 Then
        Exit Function
    End If
    
    If int提取类型 = 1 Then
        '签名，检查签名对象是否存在
        If thisSign Is Nothing Then
            Exit Function
        End If
    Else
        '验证签名，从签名记录中提取医生姓名，签名级别，签名时间信息,签名规则
        strSql = "Select 内容文本 as 医生姓名 ,要素表示  as 签名级别 ,对象属性 From 电子病历内容 Where 文件ID = [1] And 对象类型 = 8 and 开始版 =[2] "
        Set rs签名记录 = zlDatabase.OpenSQLRecord(strSql, "提取最后报告源文签名信息", lngReportID, int签名版本)
        If rs签名记录.RecordCount = 0 Then
            Exit Function
        End If
        
        '提取格式化的签名时间，签名规则
        arr对象属性 = Split(rs签名记录!对象属性, ";")
        If UBound(arr对象属性) >= 5 Then
            intRule = Val(arr对象属性(1))
            str签名时间 = Format(arr对象属性(4), "yyyy-MM-dd HH:mm:ss")
        End If
        If intRule = 0 Then Exit Function
    End If
    
    '根据规则组织报告源文： ID，病人ID，婴儿，创建人，创建时间，医生姓名，签名级别，签名时间,检查所见，诊断意见，建议
    If intRule = 1 Then
        '源文基本信息
        strSourceOut = rs病历记录!ID
        strSourceOut = strSourceOut & vbTab & Nvl(rs病历记录!病人ID)
        strSourceOut = strSourceOut & vbTab & Nvl(rs病历记录!婴儿)
        strSourceOut = strSourceOut & vbTab & Nvl(rs病历记录!创建人)
        strSourceOut = strSourceOut & vbTab & Nvl(rs病历记录!创建时间)
        
        '源文签名信息
        If int提取类型 = 1 Then
            '签名，从签名对象提取
            strSourceOut = strSourceOut & vbTab & thisSign.姓名
            strSourceOut = strSourceOut & vbTab & thisSign.签名级别
            strSourceOut = strSourceOut & vbTab & Format(thisSign.签名时间, "yyyy-MM-dd HH:mm:ss")
        Else
            '验证签名，从数据库签名记录提取
            strSignName = Nvl(rs签名记录!医生姓名)
            If InStr(strSignName, M_STR_TAG_SIGNWITHIMG) > 0 Then
                strSignImgBase64 = Split(strSignName, M_STR_TAG_SIGNWITHIMG)(1)
                strSignName = Split(strSignName, M_STR_TAG_SIGNWITHIMG)(0)
            End If
 
            strSourceOut = strSourceOut & vbTab & strSignName
            strSourceOut = strSourceOut & vbTab & Nvl(rs签名记录!签名级别)
            strSourceOut = strSourceOut & vbTab & str签名时间
        End If
        
        '源文报告内容
        rs病历内容.Filter = "标题 ='" & ReportViewType_检查所见 & "'"
        If rs病历内容.RecordCount = 0 Then
            strSourceOut = strSourceOut & vbTab
        Else
            strSourceOut = strSourceOut & vbTab & Nvl(rs病历内容!正文)
        End If
        
        rs病历内容.Filter = "标题 ='" & ReportViewType_诊断意见 & "'"
        If rs病历内容.RecordCount = 0 Then
            strSourceOut = strSourceOut & vbTab
        Else
            strSourceOut = strSourceOut & vbTab & Nvl(rs病历内容!正文)
        End If
        
        rs病历内容.Filter = "标题 ='" & ReportViewType_建议 & "'"
        If rs病历内容.RecordCount = 0 Then
            strSourceOut = strSourceOut & vbTab
        Else
            strSourceOut = strSourceOut & vbTab & Nvl(rs病历内容!正文)
        End If
        
        '源文签名图像信息
        If gblUseImgSignValid Then
            If int提取类型 = 1 Then
                '从过程参数获取
                strSourceOut = strSourceOut & vbTab & strImg64
            Else
                '从数据库签名记录提取
                strSignImgBase64 = ImgFileNamesToBase64(strSignImgBase64, lngAdviceID)
                If gblnUseValidLog Then
                    Call WriteLog("签名验证Base64数据：" & vbLf & strSignImgBase64)
                End If
                If InStr("errN", strSignImgBase64) > 0 Then
                    Call SaveSetting("ZLSOFT", "公共模块\ZL9PACSWork", "图像签名错误信息", Mid(strSignImgBase64, 1, 20))
                End If
                strSourceOut = strSourceOut & vbTab & strSignImgBase64
            End If
        End If
    End If
    
    GetSignSourceString = intRule
    Exit Function
err:
    If ErrCenter() = 1 Then Resume
    Call SaveErrLog
End Function

Public Function ElementHook(ByVal hWnd As Long) As Long
    '返回并保存原来默认的窗口过程指针
    If App.LogMode <> 0 Then
        '用自定义程序代替原来的window程序
        ElementHook = SetWindowLong(hWnd, GWL_WNDPROC, AddressOf ElementWindowProc)
    End If
End Function

Public Sub ElementUnhook(ByVal hWnd As Long, ByVal lpWndProc As Long)
  Dim temp As Long
  
    If App.LogMode <> 0 Then
        temp = SetWindowLong(hWnd, GWL_WNDPROC, lpWndProc)
    End If
End Sub

Public Function ElementWindowProc(ByVal hWnd As Long, ByVal Msg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
''------------------------------------------------
''功能：元素写入窗口的windows消息处理程序，专门处理鼠标滚轮 消息
''参数：
''返回：
''------------------------------------------------
    Dim pt As POINTAPI
    Dim wzDelta As Integer
    
    On Error Resume Next
    
    wzDelta = OS.HIWORD(wParam)
    
    Select Case Msg
        Case WM_MOUSEWHEEL
            If Sgn(wzDelta) = 1 Then    '鼠标上滚
                Call fReportElement.subMouseWheel(1)
            Else                        '鼠标下滚
                Call fReportElement.subMouseWheel(2)
            End If
    End Select
    
    '调用原来的窗口过程
    ElementWindowProc = CallWindowProc(glngEelmentWinProc, hWnd, Msg, wParam, lParam)
End Function

Private Function ImgFileNamesToBase64(ByVal strImgFileNames As String, ByVal lngAdviceID As Long) As String
'将"文件名_1;文件名_2;文件名_3"转化为"base64_1;banse64_2;base64_3"的形式
On Error GoTo errH
    Dim objFile As New Scripting.FileSystemObject
    
    Dim strBase64 As String
    
    Dim strSql As String
    Dim rsTemp As Recordset
    Dim strLocalDir As String
    Dim strImgName() As String
    Dim i As Integer, lngResult As Long
    Dim strPathTmp As String
    Dim blnIsMark As Boolean '是否标记图
    Dim strFtpDir As String
    Dim strLocalPath As String
    Dim strSaveDeviceID As String
    Dim strFTPDirUrl As String, strFtpIp As String, strFTPUser As String, strFTPPwd As String
    Dim strPathCheck As String
    Dim strNewDirectory As String
    
    Dim Inet1 As New clsFtp
    
    If gblnUseValidLog Then
        Call WriteLog("验证签名图像文件名称：" & vbLf & strImgFileNames)
    End If
    
    strSql = "Select 位置一,位置二,检查UID,接收日期 From 影像检查记录 Where 检查UID is not null And 医嘱ID = [1]"
    Set rsTemp = zlDatabase.OpenSQLRecord(strSql, "hehe", lngAdviceID)
    
    If rsTemp.RecordCount > 0 Then
        strLocalDir = App.Path & "\TmpImage\" & Format(Nvl(rsTemp!接收日期), "yyyyMMdd") & "\" & Nvl(rsTemp!检查UID) & "\"
         strSaveDeviceID = Nvl(rsTemp!位置一)
        If strSaveDeviceID = "" Then
            strSaveDeviceID = Nvl(rsTemp!位置二)
        End If
    End If
    
    strImgName = Split(strImgFileNames, ";")
    For i = 0 To UBound(strImgName)
        
        If InStr(strImgName(i), "jpg") < 1 Then
            strPathTmp = App.Path & "\TmpImage\MarkImages\" & strImgName(i)
            blnIsMark = True
        Else
            blnIsMark = False
            strPathTmp = strLocalDir & strImgName(i)
        End If
        '判断文件是否存在，若存在，转化为base64
        '若不存在 从FTP下载然后转化为base64，若下载失败。最终也没办法验证签名
        
        If objFile.FileExists(strPathTmp) Then
            If strBase64 <> "" Then strBase64 = strBase64 & ";"
            
            strBase64 = strBase64 & zlStr.EncodeBase64_File(strPathTmp)
        Else
            '从FTP下载文件
            
            If blnIsMark Then
                strFtpDir = "MarkImages/"
                strPathCheck = App.Path & "\TmpImage\MarkImages"
                strLocalPath = strPathCheck & "\" & strImgName(i)
            Else
                strFtpDir = Format(Nvl(rsTemp!接收日期), "yyyyMMdd") & "/" & Nvl(rsTemp!检查UID)
                strPathCheck = App.Path & "\TmpImage\" & Format(Nvl(rsTemp!接收日期), "yyyyMMdd") & "\" & Nvl(rsTemp!检查UID)
                strLocalPath = strPathCheck & "\" & strImgName(i)
            End If
            
            '如果没有目录，则创建目录
            If Dir(strPathCheck, vbDirectory) = "" Then
                strNewDirectory = App.Path & "\TmpImage"
                If Not DirExists(strNewDirectory) Then MkDir strNewDirectory
                
                If blnIsMark Then
                    strNewDirectory = strNewDirectory & "\MarkImages"
                    If Not DirExists(strNewDirectory) Then MkDir strNewDirectory
                Else
                    strNewDirectory = strNewDirectory & "\" & Format(Nvl(rsTemp!接收日期), "yyyyMMdd")
                    If Not DirExists(strNewDirectory) Then MkDir strNewDirectory
                    
                    strNewDirectory = strNewDirectory & "\" & Nvl(rsTemp!检查UID)
                    If Not DirExists(strNewDirectory) Then MkDir strNewDirectory
                End If
            End If
            
            If strSaveDeviceID <> "" Then
            
                Call funGetStorageDevice(Nothing, strSaveDeviceID, strFTPDirUrl, strFtpIp, strFTPUser, strFTPPwd)
                '建立FTP连接
                If Inet1.hConnection = 0 Then
                    If Inet1.FuncFtpConnect(strFtpIp, strFTPUser, strFTPPwd) = 0 Then
                        ImgFileNamesToBase64 = "errN4:FTP连接失败"
                        Exit Function
                    End If
                End If
            
            Else
                '终止
                ImgFileNamesToBase64 = "errN1:缺少FTP位置信息,无法继续验证"
                Exit Function
            End If
            
            lngResult = Inet1.FuncDownloadFile(strFTPDirUrl & strFtpDir, strLocalPath, strImgName(i))
            
            If strBase64 <> "" Then strBase64 = strBase64 & ";"
            strBase64 = strBase64 & zlStr.EncodeBase64_File(strPathTmp)
        End If
    Next
    
    ImgFileNamesToBase64 = strBase64
    Inet1.FuncFtpDisConnect
    Exit Function
errH:
    '终止
    If Inet1.hConnection <> 0 Then Inet1.FuncFtpDisConnect
    ImgFileNamesToBase64 = "errN3:" & err.Description
    Call err.Raise(0, , "根据文件名称产生base64数据异常-" & err.Description)
    Resume
End Function
